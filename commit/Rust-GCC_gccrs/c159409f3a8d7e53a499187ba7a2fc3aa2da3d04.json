{"sha": "c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE1OTQwOWYzYThkN2U1M2E0OTkxODdiYTdhMmZjM2FhMmRhM2QwNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T10:43:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T10:43:04Z"}, "message": "[multiple changes]\n\n2010-10-11  Robert Dewar  <dewar@adacore.com>\n\n\t* g-htable.ads (Get_First): New procedural version for Simple_HTable\n\t(Get_Next): New procedural version for Simple_HTable\n\t* s-htable.adb (Get_First): New procedural version for Simple_HTable\n\t(Get_Next): New procedural version for Simple_HTable\n\t* s-htable.ads (Get_First): New procedural version for Simple_HTable\n\t(Get_Next): New procedural version for Simple_HTable\n\n2010-10-11  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aggr.adb (Propagate_Discriminants): To gather the components of a\n\tvariant part, use the association list of the subaggregate, which\n\talready includes the values of the needed discriminants.\n\n2010-10-11  Robert Dewar  <dewar@adacore.com>\n\n\t* aspects.ads, aspects.adb: Changes to accomodate aspect delay\n\t(Tree_Write): New procedure.\n\t* atree.ads, atree.adb: Flag3 is now Has_Aspects and applies to all\n\tnodes.\n\t* atree.h: Flag3 is now Has_Aspects and applies to all nodes\n\t* debug.adb: Add debug flag gnatd.A\n\t* einfo.adb (Has_Delayed_Aspects): New flag\n\t(Get_Rep_Item_For_Entity): New function\n\t* einfo.ads (Has_Delayed_Aspects): New flag\n\t(Get_Rep_Item_For_Entity): New function\n\t* exp_ch13.adb (Expand_N_Freeze_Entity): Insert delayed aspects into\n\ttree.\n\t* exp_ch3.adb, exp_ch6.adb, exp_ch9.adb, exp_disp.adb: New calling\n\tsequence for Freeze_Entity.\n\t* freeze.ads, freeze.adb (Freeze_Entity): Takes node rather than source\n\tptr. All calls are changed to this new interface.\n\t(Freeze_And_Append): Same change\n\t(Freeze_Entity): Evaluate deferred aspects\n\t* sem_attr.adb: New calling sequence for Freeze_Entity\n\t(Eval_Attribute): Don't try to evaluate attributes of unfrozen types\n\twhen we are in spec expression preanalysis mode.\n\t* sem_ch10.adb: New calling sequence for Freeze_Entity\n\t* sem_ch11.adb: Simplify analysis of aspect specifications now that the\n\tflag Has_Aspects applies to all nodes (no need to save aspects).\n\t* sem_ch12.adb: Simplify analysis of aspect specifications now that the\n\tflag Has_Aspects applies to all nodes (no need to save aspects).\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Major rewrite to\n\taccomodate delaying aspect evaluation to the freeze point.\n\t(Duplicate_Clause): Simplify using Get_Rep_Item_For_Entity, and also\n\taccomodate delayed aspects.\n\t(Rep_Item_Too_Late): Deal with delayed aspects case\n\t* sem_ch13.ads (Rep_Item_Too_Late): Document handling of delayed aspects\n\t* sem_ch3.adb (Analyze_Subtype_Declaration): Make sure that generic\n\tactual types are properly frozen (this is needed because of the new\n\tcheck in Eval_Attribute that declines to evaluate attributes\n\tfor unfrozen types).\n\tSimplify analysis of aspect specifications now that the flag\n\tHas_Aspects applies to all nodes (no need to save aspects).\n\t* sem_ch3.ads (Preanalyze_Spec_Expression): Note use for delayed aspects\n\t* sem_ch5.adb: Simplify analysis of aspect specifications now that the\n\tflag Has_Aspects applies to all nodes (no need to save aspects).\n\tNew calling sequence for Freeze_Entity.\n\t* sem_ch9.adb, sem_ch7.adb, sem_ch6.adb: Simplify analysis of aspect\n\tspecifications now that the flag Has_Aspects applies to all nodes\n\t(no need to save aspects).\n\tNew calling sequence for Freeze_Entity\n\t* sem_prag.adb (Check_Duplicate_Pragma): Simplify using\n\tGet_Rep_Item_For_Entity\n\t(Get_Pragma_Arg): Moved to Sinfo\n\t* sinfo.ads, sinfo.adb (Aspect_Rep_Item_: New field\n\t(Is_Delayed_Aspect): New flag\n\t(Next_Rep_Item): Document use for aspects\n\t(Get_Pragma_Arg): Moved here from Sem_Prag\n\t* sprint.adb (Sprint_Aspect_Specifications): Now called after semicolon\n\tis output and removes semicolon (simplifies interface).\n\t(Sprint_Node_Actual): Simplify handling of aspects now that Has_Aspects\n\tapplies to any node.\n\t* tree_gen.adb: Write contents of Aspect_Specifications hash table\n\t* tree_in.adb: Read and initialize Aspect_Specifications hash table\n\t* treepr.adb (Print_Node): Print Has_Aspects flag\n\t(Print_Node): Print Aspect_Specifications in Has_Aspects set\n\t* xtreeprs.adb: Remove obsolete references to Flag1,2,3\n\nFrom-SVN: r165300", "tree": {"sha": "8193b0facbe2ccdb239a536cc0e48b413a954d64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8193b0facbe2ccdb239a536cc0e48b413a954d64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/comments", "author": null, "committer": null, "parents": [{"sha": "0f1a6a0b83ac281cb77b7432154626b4e78b8171", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1a6a0b83ac281cb77b7432154626b4e78b8171", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f1a6a0b83ac281cb77b7432154626b4e78b8171"}], "stats": {"total": 1673, "additions": 1093, "deletions": 580}, "files": [{"sha": "2282a299380451213917e673e96c8e8e7c43b411", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -1,3 +1,83 @@\n+2010-10-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* g-htable.ads (Get_First): New procedural version for Simple_HTable\n+\t(Get_Next): New procedural version for Simple_HTable\n+\t* s-htable.adb (Get_First): New procedural version for Simple_HTable\n+\t(Get_Next): New procedural version for Simple_HTable\n+\t* s-htable.ads (Get_First): New procedural version for Simple_HTable\n+\t(Get_Next): New procedural version for Simple_HTable\n+\n+2010-10-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aggr.adb (Propagate_Discriminants): To gather the components of a\n+\tvariant part, use the association list of the subaggregate, which\n+\talready includes the values of the needed discriminants.\n+\n+2010-10-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* aspects.ads, aspects.adb: Changes to accomodate aspect delay\n+\t(Tree_Write): New procedure.\n+\t* atree.ads, atree.adb: Flag3 is now Has_Aspects and applies to all\n+\tnodes.\n+\t* atree.h: Flag3 is now Has_Aspects and applies to all nodes\n+\t* debug.adb: Add debug flag gnatd.A\n+\t* einfo.adb (Has_Delayed_Aspects): New flag\n+\t(Get_Rep_Item_For_Entity): New function\n+\t* einfo.ads (Has_Delayed_Aspects): New flag\n+\t(Get_Rep_Item_For_Entity): New function\n+\t* exp_ch13.adb (Expand_N_Freeze_Entity): Insert delayed aspects into\n+\ttree.\n+\t* exp_ch3.adb, exp_ch6.adb, exp_ch9.adb, exp_disp.adb: New calling\n+\tsequence for Freeze_Entity.\n+\t* freeze.ads, freeze.adb (Freeze_Entity): Takes node rather than source\n+\tptr. All calls are changed to this new interface.\n+\t(Freeze_And_Append): Same change\n+\t(Freeze_Entity): Evaluate deferred aspects\n+\t* sem_attr.adb: New calling sequence for Freeze_Entity\n+\t(Eval_Attribute): Don't try to evaluate attributes of unfrozen types\n+\twhen we are in spec expression preanalysis mode.\n+\t* sem_ch10.adb: New calling sequence for Freeze_Entity\n+\t* sem_ch11.adb: Simplify analysis of aspect specifications now that the\n+\tflag Has_Aspects applies to all nodes (no need to save aspects).\n+\t* sem_ch12.adb: Simplify analysis of aspect specifications now that the\n+\tflag Has_Aspects applies to all nodes (no need to save aspects).\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Major rewrite to\n+\taccomodate delaying aspect evaluation to the freeze point.\n+\t(Duplicate_Clause): Simplify using Get_Rep_Item_For_Entity, and also\n+\taccomodate delayed aspects.\n+\t(Rep_Item_Too_Late): Deal with delayed aspects case\n+\t* sem_ch13.ads (Rep_Item_Too_Late): Document handling of delayed aspects\n+\t* sem_ch3.adb (Analyze_Subtype_Declaration): Make sure that generic\n+\tactual types are properly frozen (this is needed because of the new\n+\tcheck in Eval_Attribute that declines to evaluate attributes\n+\tfor unfrozen types).\n+\tSimplify analysis of aspect specifications now that the flag\n+\tHas_Aspects applies to all nodes (no need to save aspects).\n+\t* sem_ch3.ads (Preanalyze_Spec_Expression): Note use for delayed aspects\n+\t* sem_ch5.adb: Simplify analysis of aspect specifications now that the\n+\tflag Has_Aspects applies to all nodes (no need to save aspects).\n+\tNew calling sequence for Freeze_Entity.\n+\t* sem_ch9.adb, sem_ch7.adb, sem_ch6.adb: Simplify analysis of aspect\n+\tspecifications now that the flag Has_Aspects applies to all nodes\n+\t(no need to save aspects).\n+\tNew calling sequence for Freeze_Entity\n+\t* sem_prag.adb (Check_Duplicate_Pragma): Simplify using\n+\tGet_Rep_Item_For_Entity\n+\t(Get_Pragma_Arg): Moved to Sinfo\n+\t* sinfo.ads, sinfo.adb (Aspect_Rep_Item_: New field\n+\t(Is_Delayed_Aspect): New flag\n+\t(Next_Rep_Item): Document use for aspects\n+\t(Get_Pragma_Arg): Moved here from Sem_Prag\n+\t* sprint.adb (Sprint_Aspect_Specifications): Now called after semicolon\n+\tis output and removes semicolon (simplifies interface).\n+\t(Sprint_Node_Actual): Simplify handling of aspects now that Has_Aspects\n+\tapplies to any node.\n+\t* tree_gen.adb: Write contents of Aspect_Specifications hash table\n+\t* tree_in.adb: Read and initialize Aspect_Specifications hash table\n+\t* treepr.adb (Print_Node): Print Has_Aspects flag\n+\t(Print_Node): Print Aspect_Specifications in Has_Aspects set\n+\t* xtreeprs.adb: Remove obsolete references to Flag1,2,3\n+\n 2010-10-11  Robert Dewar  <dewar@adacore.com>\n \n \t* aspects.ads, aspects.adb: Major revision of this package for 2nd"}, {"sha": "d951c5aadb15ce1883b8552607a1e61877fd2ae9", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -29,10 +29,11 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Atree;  use Atree;\n-with Nlists; use Nlists;\n-with Sinfo;  use Sinfo;\n-with Snames; use Snames;\n+with Atree;   use Atree;\n+with Nlists;  use Nlists;\n+with Sinfo;   use Sinfo;\n+with Snames;  use Snames;\n+with Tree_IO; use Tree_IO;\n \n with GNAT.HTable; use GNAT.HTable;\n \n@@ -152,7 +153,11 @@ package body Aspects is\n \n    function Aspect_Specifications (N : Node_Id) return List_Id is\n    begin\n-      return Aspect_Specifications_Hash_Table.Get (N);\n+      if Has_Aspects (N) then\n+         return Aspect_Specifications_Hash_Table.Get (N);\n+      else\n+         return No_List;\n+      end if;\n    end Aspect_Specifications;\n \n    -----------------------------------\n@@ -199,14 +204,47 @@ package body Aspects is\n    procedure Set_Aspect_Specifications (N : Node_Id; L : List_Id) is\n    begin\n       pragma Assert (Permits_Aspect_Specifications (N));\n-      pragma Assert (not Has_Aspect_Specifications (N));\n+      pragma Assert (not Has_Aspects (N));\n       pragma Assert (L /= No_List);\n \n-      Set_Has_Aspect_Specifications (N);\n+      Set_Has_Aspects (N);\n       Set_Parent (L, N);\n       Aspect_Specifications_Hash_Table.Set (N, L);\n    end Set_Aspect_Specifications;\n \n+   ---------------\n+   -- Tree_Read --\n+   ---------------\n+\n+   procedure Tree_Read is\n+      Node : Node_Id;\n+      List : List_Id;\n+   begin\n+      loop\n+         Tree_Read_Int (Int (Node));\n+         Tree_Read_Int (Int (List));\n+         exit when List = No_List;\n+         Set_Aspect_Specifications (Node, List);\n+      end loop;\n+   end Tree_Read;\n+\n+   ----------------\n+   -- Tree_Write --\n+   ----------------\n+\n+   procedure Tree_Write is\n+      Node : Node_Id := Empty;\n+      List : List_Id;\n+   begin\n+      Aspect_Specifications_Hash_Table.Get_First (Node, List);\n+      loop\n+         Tree_Write_Int (Int (Node));\n+         Tree_Write_Int (Int (List));\n+         exit when List = No_List;\n+         Aspect_Specifications_Hash_Table.Get_Next (Node, List);\n+      end loop;\n+   end Tree_Write;\n+\n --  Package initialization sets up Aspect Id hash table\n \n begin"}, {"sha": "3289d22d60f072cb4a019fa756cd46d745f26849", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -168,27 +168,37 @@ package Aspects is\n \n    function Permits_Aspect_Specifications (N : Node_Id) return Boolean;\n    --  Returns True if the node N is a declaration node that permits aspect\n-   --  specifications. All such nodes have the Has_Aspect_Specifications\n-   --  flag defined. Returns False for all other nodes.\n+   --  specifications in the grammar. It is possible for other nodes to have\n+   --  aspect specifications as a result of Rewrite or Replace calls.\n \n    function Aspect_Specifications (N : Node_Id) return List_Id;\n    --  Given a node N, returns the list of N_Aspect_Specification nodes that\n    --  are attached to this declaration node. If the node is in the class of\n    --  declaration nodes that permit aspect specifications, as defined by the\n-   --  predicate above, and if their Has_Aspect_Specifications flag is set to\n-   --  True, then this will always be a non-empty list. If this flag is set to\n-   --  False, or the node is not in the declaration class permitting aspect\n-   --  specifications, then No_List is returned.\n+   --  predicate above, and if their Has_Aspects flag is set to True, then this\n+   --  will always be a non-empty list. If this flag is set to False, then\n+   --  No_List is returned. Normally, the only nodes that have Has_Aspects set\n+   --  True are the nodes for which Permits_Aspect_Specifications would return\n+   --  True (i.e. the declaration nodes defined in the RM as permitting the\n+   --  presence of Aspect_Specifications). However, it is possible for the\n+   --  flag Has_Aspects to be set on other nodes as a result of Rewrite and\n+   --  Replace calls, and this function may be used to retrive the aspect\n+   --  specifications for the original rewritten node in such cases.\n \n    procedure Set_Aspect_Specifications (N : Node_Id; L : List_Id);\n    --  The node N must be in the class of declaration nodes that permit aspect\n-   --  specifications and the Has_Aspect_Specifications flag must be False on\n-   --  entry. L must be a non-empty list of N_Aspect_Specification nodes. This\n-   --  procedure sets the Has_Aspect_Specifications flag to True, and makes an\n-   --  entry that can be retrieved by a subsequent Aspect_Specifications call.\n-   --  The parent of list L is set to reference the declaration node N. It is\n-   --  an error to call this procedure with a node that does not permit aspect\n-   --  specifications, or a node that has its Has_Aspect_Specifications flag\n-   --  set True on entry, or with L being an empty list or No_List.\n+   --  specifications and the Has_Aspects flag must be False on entry. L must\n+   --  be a non-empty list of N_Aspect_Specification nodes. This procedure sets\n+   --  the Has_Aspects flag to True, and makes an entry that can be retrieved\n+   --  by a subsequent Aspect_Specifications call. It is an error to call this\n+   --  procedure with a node that does not permit aspect specifications, or a\n+   --  node that has its Has_Aspects flag set True on entry, or with L being an\n+   --  empty list or No_List.\n+\n+   procedure Tree_Write;\n+   --  Writes contents of Aspect_Specifications hash table to the tree file\n+\n+   procedure Tree_Read;\n+   --  Reads contents of Aspect_Specificatins hash table from the tree file\n \n end Aspects;"}, {"sha": "2a54d63e7ec0e31f1f508be2d7d00d0c7c9cadcd", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 52, "deletions": 29, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -36,6 +36,7 @@ pragma Style_Checks (All_Checks);\n --  file must be properly reflected in the file atree.h which is a C header\n --  file containing equivalent definitions for use by gigi.\n \n+with Aspects; use Aspects;\n with Debug;   use Debug;\n with Nlists;  use Nlists;\n with Output;  use Output;\n@@ -1087,6 +1088,16 @@ package body Atree is\n       return Default_Node.Comes_From_Source;\n    end Get_Comes_From_Source_Default;\n \n+   -----------------\n+   -- Has_Aspects --\n+   -----------------\n+\n+   function Has_Aspects (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (N <= Nodes.Last);\n+      return Nodes.Table (N).Has_Aspects;\n+   end Has_Aspects;\n+\n    -------------------\n    -- Has_Extension --\n    -------------------\n@@ -1563,20 +1574,22 @@ package body Atree is\n    -------------\n \n    procedure Replace (Old_Node, New_Node : Node_Id) is\n-      Old_Post : constant Boolean  := Nodes.Table (Old_Node).Error_Posted;\n-      Old_CFS  : constant Boolean  := Nodes.Table (Old_Node).Comes_From_Source;\n+      Old_Post : constant Boolean := Nodes.Table (Old_Node).Error_Posted;\n+      Old_HasA : constant Boolean := Nodes.Table (Old_Node).Has_Aspects;\n+      Old_CFS  : constant Boolean := Nodes.Table (Old_Node).Comes_From_Source;\n \n    begin\n       pragma Assert\n         (not Has_Extension (Old_Node)\n-           and not Has_Extension (New_Node)\n-           and not Nodes.Table (New_Node).In_List);\n+          and not Has_Extension (New_Node)\n+          and not Nodes.Table (New_Node).In_List);\n \n-      --  Do copy, preserving link and in list status and comes from source\n+      --  Do copy, preserving link and in list status and required flags\n \n       Copy_Node (Source => New_Node, Destination => Old_Node);\n       Nodes.Table (Old_Node).Comes_From_Source := Old_CFS;\n       Nodes.Table (Old_Node).Error_Posted      := Old_Post;\n+      Nodes.Table (Old_Node).Has_Aspects       := Old_HasA;\n \n       --  Fix parents of substituted node, since it has changed identity\n \n@@ -1601,7 +1614,10 @@ package body Atree is\n \n    procedure Rewrite (Old_Node, New_Node : Node_Id) is\n       Old_Error_P : constant Boolean  := Nodes.Table (Old_Node).Error_Posted;\n-      --  This fields is always preserved in the new node\n+      --  This field is always preserved in the new node\n+\n+      Old_Has_Aspects : constant Boolean := Nodes.Table (Old_Node).Has_Aspects;\n+      --  This field is always preserved in the new node\n \n       Old_Paren_Count     : Nat;\n       Old_Must_Not_Freeze : Boolean;\n@@ -1616,15 +1632,15 @@ package body Atree is\n    begin\n       pragma Assert\n         (not Has_Extension (Old_Node)\n-           and not Has_Extension (New_Node)\n-           and not Nodes.Table (New_Node).In_List);\n+          and not Has_Extension (New_Node)\n+          and not Nodes.Table (New_Node).In_List);\n       pragma Debug (Rewrite_Debugging_Output (Old_Node, New_Node));\n \n       if Nkind (Old_Node) in N_Subexpr then\n          Old_Paren_Count     := Paren_Count (Old_Node);\n          Old_Must_Not_Freeze := Must_Not_Freeze (Old_Node);\n       else\n-         Old_Paren_Count := 0;\n+         Old_Paren_Count     := 0;\n          Old_Must_Not_Freeze := False;\n       end if;\n \n@@ -1638,12 +1654,21 @@ package body Atree is\n          Sav_Node := New_Copy (Old_Node);\n          Orig_Nodes.Table (Sav_Node) := Sav_Node;\n          Orig_Nodes.Table (Old_Node) := Sav_Node;\n+\n+         --  Both the old and new copies of the node will share the same list\n+         --  of aspect specifications if aspect specifications are present.\n+\n+         if Has_Aspects (Sav_Node) then\n+            Set_Aspect_Specifications\n+              (Sav_Node, Aspect_Specifications (Old_Node));\n+         end if;\n       end if;\n \n       --  Copy substitute node into place, preserving old fields as required\n \n       Copy_Node (Source => New_Node, Destination => Old_Node);\n       Nodes.Table (Old_Node).Error_Posted := Old_Error_P;\n+      Nodes.Table (Old_Node).Has_Aspects  := Old_Has_Aspects;\n \n       if Nkind (New_Node) in N_Subexpr then\n          Set_Paren_Count     (Old_Node, Old_Paren_Count);\n@@ -1736,6 +1761,16 @@ package body Atree is\n       Nodes.Table (N).Error_Posted := Val;\n    end Set_Error_Posted;\n \n+   ---------------------\n+   -- Set_Has_Aspects --\n+   ---------------------\n+\n+   procedure Set_Has_Aspects (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (N <= Nodes.Last);\n+      Nodes.Table (N).Has_Aspects := Val;\n+   end Set_Has_Aspects;\n+\n    ---------------------\n    -- Set_Paren_Count --\n    ---------------------\n@@ -2704,12 +2739,6 @@ package body Atree is\n          return From_Union (Nodes.Table (N + 3).Field8);\n       end Ureal21;\n \n-      function Flag3 (N : Node_Id) return Boolean is\n-      begin\n-         pragma Assert (N <= Nodes.Last);\n-         return Nodes.Table (N).Flag3;\n-      end Flag3;\n-\n       function Flag4 (N : Node_Id) return Boolean is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -2809,7 +2838,7 @@ package body Atree is\n       function Flag20 (N : Node_Id) return Boolean is\n       begin\n          pragma Assert (Nkind (N) in N_Entity);\n-         return Nodes.Table (N + 1).Flag3;\n+         return Nodes.Table (N + 1).Has_Aspects;\n       end Flag20;\n \n       function Flag21 (N : Node_Id) return Boolean is\n@@ -2935,7 +2964,7 @@ package body Atree is\n       function Flag41 (N : Node_Id) return Boolean is\n       begin\n          pragma Assert (Nkind (N) in N_Entity);\n-         return Nodes.Table (N + 2).Flag3;\n+         return Nodes.Table (N + 2).Has_Aspects;\n       end Flag41;\n \n       function Flag42 (N : Node_Id) return Boolean is\n@@ -3469,7 +3498,7 @@ package body Atree is\n       function Flag130 (N : Node_Id) return Boolean is\n       begin\n          pragma Assert (Nkind (N) in N_Entity);\n-         return Nodes.Table (N + 3).Flag3;\n+         return Nodes.Table (N + 3).Has_Aspects;\n       end Flag130;\n \n       function Flag131 (N : Node_Id) return Boolean is\n@@ -3991,7 +4020,7 @@ package body Atree is\n       function Flag217 (N : Node_Id) return Boolean is\n       begin\n          pragma Assert (Nkind (N) in N_Entity);\n-         return Nodes.Table (N + 4).Flag3;\n+         return Nodes.Table (N + 4).Has_Aspects;\n       end Flag217;\n \n       function Flag218 (N : Node_Id) return Boolean is\n@@ -4812,12 +4841,6 @@ package body Atree is\n          Nodes.Table (N + 3).Field8 := To_Union (Val);\n       end Set_Ureal21;\n \n-      procedure Set_Flag3 (N : Node_Id; Val : Boolean) is\n-      begin\n-         pragma Assert (N <= Nodes.Last);\n-         Nodes.Table (N).Flag3 := Val;\n-      end Set_Flag3;\n-\n       procedure Set_Flag4 (N : Node_Id; Val : Boolean) is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -4917,7 +4940,7 @@ package body Atree is\n       procedure Set_Flag20 (N : Node_Id; Val : Boolean) is\n       begin\n          pragma Assert (Nkind (N) in N_Entity);\n-         Nodes.Table (N + 1).Flag3 := Val;\n+         Nodes.Table (N + 1).Has_Aspects := Val;\n       end Set_Flag20;\n \n       procedure Set_Flag21 (N : Node_Id; Val : Boolean) is\n@@ -5043,7 +5066,7 @@ package body Atree is\n       procedure Set_Flag41 (N : Node_Id; Val : Boolean) is\n       begin\n          pragma Assert (Nkind (N) in N_Entity);\n-         Nodes.Table (N + 2).Flag3 := Val;\n+         Nodes.Table (N + 2).Has_Aspects := Val;\n       end Set_Flag41;\n \n       procedure Set_Flag42 (N : Node_Id; Val : Boolean) is\n@@ -5705,7 +5728,7 @@ package body Atree is\n       procedure Set_Flag130 (N : Node_Id; Val : Boolean) is\n       begin\n          pragma Assert (Nkind (N) in N_Entity);\n-         Nodes.Table (N + 3).Flag3 := Val;\n+         Nodes.Table (N + 3).Has_Aspects := Val;\n       end Set_Flag130;\n \n       procedure Set_Flag131 (N : Node_Id; Val : Boolean) is\n@@ -6355,7 +6378,7 @@ package body Atree is\n       procedure Set_Flag217 (N : Node_Id; Val : Boolean) is\n       begin\n          pragma Assert (Nkind (N) in N_Entity);\n-         Nodes.Table (N + 4).Flag3 := Val;\n+         Nodes.Table (N + 4).Has_Aspects := Val;\n       end Set_Flag217;\n \n       procedure Set_Flag218 (N : Node_Id; Val : Boolean) is"}, {"sha": "8b81ade2454bb519a5326d96bb716d5afb8e3b77", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -151,7 +151,6 @@ package Atree is\n    --   it is useful to be able to do untyped traversals, and an internal\n    --   package in Atree allows for direct untyped accesses in such cases.\n \n-   --   Flag3\n    --   Flag4         Sixteen Boolean flags (use depends on Nkind and\n    --   Flag5         Ekind, as described for FieldN). Again the access\n    --   Flag6         is usually via subprograms in Sinfo and Einfo which\n@@ -293,7 +292,7 @@ package Atree is\n    -------------------------------------\n \n    --  A subpackage Atree.Unchecked_Access provides routines for reading and\n-   --  writing the fields defined above (Field1-27, Node1-27, Flag3-254 etc).\n+   --  writing the fields defined above (Field1-27, Node1-27, Flag4-254 etc).\n    --  These unchecked access routines can be used for untyped traversals.\n    --  In addition they are used in the implementations of the Sinfo and\n    --  Einfo packages. These packages both provide logical synonyms for\n@@ -518,6 +517,9 @@ package Atree is\n    function Analyzed          (N : Node_Id) return Boolean;\n    pragma Inline (Analyzed);\n \n+   function Has_Aspects       (N : Node_Id) return Boolean;\n+   pragma Inline (Has_Aspects);\n+\n    function Comes_From_Source (N : Node_Id) return Boolean;\n    pragma Inline (Comes_From_Source);\n \n@@ -750,6 +752,9 @@ package Atree is\n    --  unusual cases, the value needs to be reset (e.g. when a source\n    --  node is copied, and the copy must not have Comes_From_Source set.\n \n+   procedure Set_Has_Aspects (N : Node_Id; Val : Boolean := True);\n+   pragma Inline (Set_Has_Aspects);\n+\n    ------------------------------\n    -- Entity Update Procedures --\n    ------------------------------\n@@ -1196,9 +1201,6 @@ package Atree is\n       function Ureal21 (N : Node_Id) return Ureal;\n       pragma Inline (Ureal21);\n \n-      function Flag3 (N : Node_Id) return Boolean;\n-      pragma Inline (Flag3);\n-\n       function Flag4 (N : Node_Id) return Boolean;\n       pragma Inline (Flag4);\n \n@@ -2254,9 +2256,6 @@ package Atree is\n       procedure Set_Ureal21 (N : Node_Id; Val : Ureal);\n       pragma Inline (Set_Ureal21);\n \n-      procedure Set_Flag3 (N : Node_Id; Val : Boolean);\n-      pragma Inline (Set_Flag3);\n-\n       procedure Set_Flag4 (N : Node_Id; Val : Boolean);\n       pragma Inline (Set_Flag4);\n \n@@ -3091,7 +3090,9 @@ package Atree is\n          --  Flag used to indicate if node is a member of a list.\n          --  This field is considered private to the Atree package.\n \n-         Flag3 : Boolean;\n+         Has_Aspects : Boolean;\n+         --  Flag used to indicate that a node has aspect specifications that\n+         --  are associated with the node. See Aspects package for details.\n \n          Rewrite_Ins : Boolean;\n          --  Flag set by Mark_Rewrite_Insertion procedure.\n@@ -3126,32 +3127,31 @@ package Atree is\n          --  The eighteen flags for a normal node\n \n          --  The above fields are used as follows in components 2-5 of\n-         --  an extended node entry. These fields are not currently\n-         --  used in component 5 (where we still have lots of room!)\n-\n-         --    In_List            used as  Flag19, Flag40, Flag129, Flag216\n-         --    Flag3              used as  Flag20, Flag41, Flag130, Flag217\n-         --    Rewrite_Ins        used as  Flag21, Flag42, Flag131, Flag218\n-         --    Analyzed           used as  Flag22, Flag43, Flag132, Flag219\n-         --    Comes_From_Source  used as  Flag23, Flag44, Flag133, Flag220\n-         --    Error_Posted       used as  Flag24, Flag45, Flag134, Flag221\n-         --    Flag4              used as  Flag25, Flag46, Flag135, Flag222\n-         --    Flag5              used as  Flag26, Flag47, Flag136, Flag223\n-         --    Flag6              used as  Flag27, Flag48, Flag137, Flag224\n-         --    Flag7              used as  Flag28, Flag49, Flag138, Flag225\n-         --    Flag8              used as  Flag29, Flag50, Flag139, Flag226\n-         --    Flag9              used as  Flag30, Flag51, Flag140, Flag227\n-         --    Flag10             used as  Flag31, Flag52, Flag141, Flag228\n-         --    Flag11             used as  Flag32, Flag53, Flag142, Flag229\n-         --    Flag12             used as  Flag33, Flag54, Flag143, Flag230\n-         --    Flag13             used as  Flag34, Flag55, Flag144, Flag231\n-         --    Flag14             used as  Flag35, Flag56, Flag145, Flag232\n-         --    Flag15             used as  Flag36, Flag57, Flag146, Flag233\n-         --    Flag16             used as  Flag37, Flag58, Flag147, Flag234\n-         --    Flag17             used as  Flag38, Flag59, Flag148, Flag235\n-         --    Flag18             used as  Flag39, Flag60, Flag149, Flag236\n-         --    Pflag1             used as  Flag61, Flag62, Flag150, Flag237\n-         --    Pflag2             used as  Flag63, Flag64, Flag151, Flag238\n+         --  an extended node entry.\n+\n+         --    In_List              used as  Flag19, Flag40, Flag129, Flag216\n+         --    Has_Aspects          used as  Flag20, Flag41, Flag130, Flag217\n+         --    Rewrite_Ins          used as  Flag21, Flag42, Flag131, Flag218\n+         --    Analyzed             used as  Flag22, Flag43, Flag132, Flag219\n+         --    Comes_From_Source    used as  Flag23, Flag44, Flag133, Flag220\n+         --    Error_Posted         used as  Flag24, Flag45, Flag134, Flag221\n+         --    Flag4                used as  Flag25, Flag46, Flag135, Flag222\n+         --    Flag5                used as  Flag26, Flag47, Flag136, Flag223\n+         --    Flag6                used as  Flag27, Flag48, Flag137, Flag224\n+         --    Flag7                used as  Flag28, Flag49, Flag138, Flag225\n+         --    Flag8                used as  Flag29, Flag50, Flag139, Flag226\n+         --    Flag9                used as  Flag30, Flag51, Flag140, Flag227\n+         --    Flag10               used as  Flag31, Flag52, Flag141, Flag228\n+         --    Flag11               used as  Flag32, Flag53, Flag142, Flag229\n+         --    Flag12               used as  Flag33, Flag54, Flag143, Flag230\n+         --    Flag13               used as  Flag34, Flag55, Flag144, Flag231\n+         --    Flag14               used as  Flag35, Flag56, Flag145, Flag232\n+         --    Flag15               used as  Flag36, Flag57, Flag146, Flag233\n+         --    Flag16               used as  Flag37, Flag58, Flag147, Flag234\n+         --    Flag17               used as  Flag38, Flag59, Flag148, Flag235\n+         --    Flag18               used as  Flag39, Flag60, Flag149, Flag236\n+         --    Pflag1               used as  Flag61, Flag62, Flag150, Flag237\n+         --    Pflag2               used as  Flag63, Flag64, Flag151, Flag238\n \n          Nkind : Node_Kind;\n          --  For a non-extended node, or the initial section of an extended\n@@ -3245,7 +3245,7 @@ package Atree is\n          Pflag1            => False,\n          Pflag2            => False,\n          In_List           => False,\n-         Flag3             => False,\n+         Has_Aspects       => False,\n          Rewrite_Ins       => False,\n          Analyzed          => False,\n          Comes_From_Source => False,\n@@ -3290,7 +3290,7 @@ package Atree is\n          Pflag1            => False,\n          Pflag2            => False,\n          In_List           => False,\n-         Flag3             => False,\n+         Has_Aspects       => False,\n          Rewrite_Ins       => False,\n          Analyzed          => False,\n          Comes_From_Source => False,"}, {"sha": "447338fefebf1cb2a0a24fa735b9c04715460229", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -40,7 +40,7 @@ struct NFK\n   Boolean      pflag1        :  1;\n   Boolean      pflag2        :  1;\n   Boolean      in_list       :  1;\n-  Boolean      flag3         :  1;\n+  Boolean      has_aspects   :  1;\n   Boolean      rewrite_ins   :  1;\n   Boolean      analyzed      :  1;\n   Boolean      c_f_s\t     :  1;\n@@ -75,7 +75,7 @@ struct NFNK\n   Boolean      pflag1        :  1;\n   Boolean      pflag2        :  1;\n   Boolean      in_list       :  1;\n-  Boolean      flag3         :  1;\n+  Boolean      has_aspects   :  1;\n   Boolean      rewrite_ins   :  1;\n   Boolean      analyzed      :  1;\n   Boolean      c_f_s\t     :  1;\n@@ -466,10 +466,10 @@ extern Node_Id Current_Error_Node;\n #define Analyzed(N)          (Nodes_Ptr[(N) - First_Node_Id].U.K.analyzed)\n #define Comes_From_Source(N) (Nodes_Ptr[(N) - First_Node_Id].U.K.c_f_s)\n #define Error_Posted(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.error_posted)\n+#define Has_Aspects(N)       (Nodes_Ptr[(N) - First_Node_Id].U.K.has_aspects)\n #define Convention(N) \\\n     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.convention)\n \n-#define Flag3(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag3)\n #define Flag4(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag4)\n #define Flag5(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag5)\n #define Flag6(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag6)\n@@ -487,7 +487,7 @@ extern Node_Id Current_Error_Node;\n #define Flag18(N)     (Nodes_Ptr[(N) - First_Node_Id].U.K.flag18)\n \n #define Flag19(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.in_list)\n-#define Flag20(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag3)\n+#define Flag20(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.has_aspects)\n #define Flag21(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.rewrite_ins)\n #define Flag22(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.analyzed)\n #define Flag23(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.c_f_s)\n@@ -509,7 +509,7 @@ extern Node_Id Current_Error_Node;\n #define Flag39(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag18)\n \n #define Flag40(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.in_list)\n-#define Flag41(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag3)\n+#define Flag41(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.has_aspects)\n #define Flag42(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.rewrite_ins)\n #define Flag43(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.analyzed)\n #define Flag44(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.c_f_s)\n@@ -601,7 +601,7 @@ extern Node_Id Current_Error_Node;\n #define Flag128(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag128)\n \n #define Flag129(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.in_list)\n-#define Flag130(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag3)\n+#define Flag130(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.has_aspects)\n #define Flag131(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.rewrite_ins)\n #define Flag132(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.analyzed)\n #define Flag133(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.c_f_s)\n@@ -691,7 +691,7 @@ extern Node_Id Current_Error_Node;\n #define Flag215(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag215)\n \n #define Flag216(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.in_list)\n-#define Flag217(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag3)\n+#define Flag217(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.has_aspects)\n #define Flag218(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.rewrite_ins)\n #define Flag219(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.analyzed)\n #define Flag220(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.c_f_s)"}, {"sha": "a22b52147c5e2406c336807aa82b49b028f45317", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -118,7 +118,7 @@ package body Debug is\n    --  d.y\n    --  d.z\n \n-   --  d.A\n+   --  d.A  Properly defer address aspect\n    --  d.B\n    --  d.C  Generate concatenation call, do not generate inline code\n    --  d.D\n@@ -558,6 +558,12 @@ package body Debug is\n    --  d.w  This flag turns off the scanning of loops to detect possible\n    --       infinite loops.\n \n+   --  d.A  Properly defer address aspect. In the case where the expression\n+   --       of an address aspect is non-static, we should defer the evaluation\n+   --       of the expression till the freeze point, but this does not seem to\n+   --       work properly. So we have this debug switch temporarily so that we\n+   --       can easily investigate this problem.\n+\n    --  d.x  No exception handlers in generated code. This causes exception\n    --       handlers to be eliminated from the generated code. They are still\n    --       fully compiled and analyzed, they just get eliminated from the"}, {"sha": "8c583238314d2ff00413d761d5e2ce3c18d76a60", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 70, "deletions": 14, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -459,6 +459,7 @@ package body Einfo is\n    --    Has_Pragma_Ordered              Flag198\n    --    Is_Ada_2012_Only                Flag199\n \n+   --    Has_Delayed_Aspects             Flag200\n    --    Has_Anon_Block_Suffix           Flag201\n    --    Itype_Printed                   Flag202\n    --    Has_Pragma_Pure                 Flag203\n@@ -510,8 +511,6 @@ package body Einfo is\n    --    Is_Underlying_Record_View       Flag246\n    --    OK_To_Rename                    Flag247\n \n-   --    (unused)                        Flag3\n-   --    (unused)                        Flag200\n    --    (unused)                        Flag232\n \n    --    (unused)                        Flag248\n@@ -580,18 +579,6 @@ package body Einfo is\n       return Flag104 (Id);\n    end Address_Taken;\n \n-   function Aft_Value (Id : E) return U is\n-      Result    : Nat := 1;\n-      Delta_Val : Ureal := Delta_Value (Id);\n-   begin\n-      while Delta_Val < Ureal_Tenth loop\n-         Delta_Val := Delta_Val * Ureal_10;\n-         Result := Result + 1;\n-      end loop;\n-\n-      return UI_From_Int (Result);\n-   end Aft_Value;\n-\n    function Alias (Id : E) return E is\n    begin\n       pragma Assert\n@@ -1220,6 +1207,12 @@ package body Einfo is\n       return Flag119 (Id);\n    end Has_Convention_Pragma;\n \n+   function Has_Delayed_Aspects (Id : E) return B is\n+   begin\n+      pragma Assert (Nkind (Id) in N_Entity);\n+      return Flag200 (Id);\n+   end Has_Delayed_Aspects;\n+\n    function Has_Delayed_Freeze (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -3628,6 +3621,12 @@ package body Einfo is\n       Set_Flag119 (Id, V);\n    end Set_Has_Convention_Pragma;\n \n+   procedure Set_Has_Delayed_Aspects (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Nkind (Id) in N_Entity);\n+      Set_Flag200 (Id, V);\n+   end Set_Has_Delayed_Aspects;\n+\n    procedure Set_Has_Delayed_Freeze (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -5476,6 +5475,22 @@ package body Einfo is\n       return Rep_Clause (Id, Name_Address);\n    end Address_Clause;\n \n+   ---------------\n+   -- Aft_Value --\n+   ---------------\n+\n+   function Aft_Value (Id : E) return U is\n+      Result    : Nat := 1;\n+      Delta_Val : Ureal := Delta_Value (Id);\n+   begin\n+      while Delta_Val < Ureal_Tenth loop\n+         Delta_Val := Delta_Val * Ureal_10;\n+         Result := Result + 1;\n+      end loop;\n+\n+      return UI_From_Int (Result);\n+   end Aft_Value;\n+\n    ----------------------\n    -- Alignment_Clause --\n    ----------------------\n@@ -5802,6 +5817,46 @@ package body Einfo is\n       return Empty;\n    end Get_Record_Representation_Clause;\n \n+   -----------------------------\n+   -- Get_Rep_Item_For_Entity --\n+   -----------------------------\n+\n+   function Get_Rep_Item_For_Entity\n+     (E   : Entity_Id;\n+      Nam : Name_Id) return Node_Id\n+   is\n+      N   : Node_Id;\n+      Arg : Node_Id;\n+\n+   begin\n+      N := First_Rep_Item (E);\n+      while Present (N) loop\n+         if Nkind (N) = N_Pragma and then Pragma_Name (N) = Nam then\n+            Arg := Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n+\n+            if Is_Entity_Name (Arg) and then Entity (Arg) = E then\n+               return N;\n+            end if;\n+\n+         elsif Nkind (N) = N_Attribute_Definition_Clause\n+           and then Chars (N) = Nam\n+           and then Entity (N) = E\n+         then\n+            return N;\n+\n+         elsif Nkind (N) = N_Aspect_Specification\n+           and then Chars (Identifier (N)) = Nam\n+           and then Entity (N) = E\n+         then\n+            return N;\n+         end if;\n+\n+         Next_Rep_Item (N);\n+      end loop;\n+\n+      return Empty;\n+   end Get_Rep_Item_For_Entity;\n+\n    --------------------\n    -- Get_Rep_Pragma --\n    --------------------\n@@ -6899,6 +6954,7 @@ package body Einfo is\n       W (\"Has_Controlled_Component\",        Flag43  (Id));\n       W (\"Has_Controlling_Result\",          Flag98  (Id));\n       W (\"Has_Convention_Pragma\",           Flag119 (Id));\n+      W (\"Has_Delayed_Aspects\",             Flag200 (Id));\n       W (\"Has_Delayed_Freeze\",              Flag18  (Id));\n       W (\"Has_Discriminants\",               Flag5   (Id));\n       W (\"Has_Enumeration_Rep_Clause\",      Flag66  (Id));"}, {"sha": "ea2a20862e36c425dde6cfca7c7e54c76d13c5d1", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 43, "deletions": 18, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -264,8 +264,8 @@ package Einfo is\n --  on the actions triggered by a freeze node, which include the construction\n --  of initialization procedures and dispatch tables.\n \n---  b) The presence of a freeze node on an entity  is used by the backend to\n---  defer elaboration of the entity until its freeze node is seen.  In the\n+--  b) The presence of a freeze node on an entity is used by the backend to\n+--  defer elaboration of the entity until its freeze node is seen. In the\n --  absence of an explicit freeze node, an entity is frozen (and elaborated)\n --  at the point of declaration.\n \n@@ -1391,6 +1391,12 @@ package Einfo is\n --       Convention, Import, or Export pragma has been given. Used to prevent\n --       more than one such pragma appearing for a given entity (RM B.1(45)).\n \n+--    Has_Delayed_Aspects (Flag200) Present in all entities. Set true if the\n+--       Rep_Item chain for the entity has one or more N_Aspect_Definition\n+--       nodes chained which are not to be evaluated till the freeze point.\n+--       The aspect definition expression clause has been preanalyzed to get\n+--       visibility at the point of use, but no other action has been taken.\n+\n --    Has_Delayed_Freeze (Flag18)\n --       Present in all entities. Set to indicate that an explicit freeze\n --       node must be generated for the entity at its freezing point. See\n@@ -4572,6 +4578,7 @@ package Einfo is\n    --    Has_Anon_Block_Suffix               (Flag201)\n    --    Has_Controlled_Component            (Flag43)   (base type only)\n    --    Has_Convention_Pragma               (Flag119)\n+   --    Has_Delayed_Aspects                 (Flag200)\n    --    Has_Delayed_Freeze                  (Flag18)\n    --    Has_Fully_Qualified_Name            (Flag173)\n    --    Has_Gigi_Rep_Item                   (Flag82)\n@@ -5863,6 +5870,7 @@ package Einfo is\n    function Has_Controlled_Component            (Id : E) return B;\n    function Has_Controlling_Result              (Id : E) return B;\n    function Has_Convention_Pragma               (Id : E) return B;\n+   function Has_Delayed_Aspects                 (Id : E) return B;\n    function Has_Delayed_Freeze                  (Id : E) return B;\n    function Has_Discriminants                   (Id : E) return B;\n    function Has_Dispatch_Table                  (Id : E) return B;\n@@ -6424,6 +6432,7 @@ package Einfo is\n    procedure Set_Has_Controlled_Component        (Id : E; V : B := True);\n    procedure Set_Has_Controlling_Result          (Id : E; V : B := True);\n    procedure Set_Has_Convention_Pragma           (Id : E; V : B := True);\n+   procedure Set_Has_Delayed_Aspects             (Id : E; V : B := True);\n    procedure Set_Has_Delayed_Freeze              (Id : E; V : B := True);\n    procedure Set_Has_Discriminants               (Id : E; V : B := True);\n    procedure Set_Has_Dispatch_Table              (Id : E; V : B := True);\n@@ -6846,13 +6855,17 @@ package Einfo is\n    -- Subprograms for Accessing Rep Item Chain --\n    ----------------------------------------------\n \n-   --  The First_Rep_Item field of every entity points to a linked list\n-   --  (linked through Next_Rep_Item) of representation pragmas and attribute\n-   --  definition clauses that apply to the item. Note that in the case of\n-   --  types, it is assumed that any such rep items for a base type also apply\n-   --  to all subtypes. This is implemented by having the chain for subtypes\n-   --  link onto the chain for the base type, so that any new entries for the\n-   --  subtype are added at the start of the chain.\n+   --  The First_Rep_Item field of every entity points to a linked list (linked\n+   --  through Next_Rep_Item) of representation pragmas, attribute definition\n+   --  clauses, representation clauses, and aspect specifications that apply to\n+   --  the item. Note that in the case of types, it is assumed that any such\n+   --  rep items for a base type also apply to all subtypes. This is achieved\n+   --  by having the chain for subtypes link onto the chain for the base type,\n+   --  so that new entries for the subtype are added at the start of the chain.\n+   --\n+   --  Note: aspect specification nodes are linked only when evaluation of the\n+   --  expression is deferred to the freeze point. For further details see\n+   --  Sem_Ch13.Analyze_Aspect_Specifications.\n \n    function Get_Attribute_Definition_Clause\n      (E  : Entity_Id;\n@@ -6862,6 +6875,16 @@ package Einfo is\n    --  value returned is the N_Attribute_Definition_Clause node, otherwise\n    --  Empty is returned.\n \n+   function Get_Rep_Item_For_Entity\n+     (E   : Entity_Id;\n+      Nam : Name_Id) return Node_Id;\n+   --  Searches the Rep_Item chain for a given entity E, for an instance of a\n+   --  rep item (pragma, attribute definition clause, or aspect specitication)\n+   --  whose name matches the given name. If one is found, it is returned,\n+   --  otherwise Empty is returned. Unlike the other Get routines for the\n+   --  Rep_Item chain, this only returns items whose entity matches E (it\n+   --  does not return items from the parent chain).\n+\n    function Get_Record_Representation_Clause (E : Entity_Id) return Node_Id;\n    --  Searches the Rep_Item chain for a given entity E, for a record\n    --  representation clause, and if found, returns it. Returns Empty\n@@ -6885,15 +6908,15 @@ package Einfo is\n    --  is returned, otherwise False indicates that no matching entry was found.\n \n    procedure Record_Rep_Item (E : Entity_Id; N : Node_Id);\n-   --  N is the node for either a representation pragma or an attribute\n-   --  definition clause that applies to entity E. This procedure links the\n-   --  node N onto the Rep_Item chain for entity E. Note that it is an error to\n-   --  call this procedure with E being overloadable, and N being a pragma that\n-   --  can apply to multiple overloadable entities (i.e. Convention, Interface,\n-   --  Inline, Inline_Always, Import, Export, External). This is not allowed\n-   --  even if in fact the entity is not overloaded, since we can't rely on\n-   --  it being present in the overloaded case, it is not useful to have it\n-   --  present in the non-overloaded case.\n+   --  N is the node for a representation pragma, representation clause, an\n+   --  attribute definition clause, or an aspect specification that applies to\n+   --  entity E. This procedure links the node N onto the Rep_Item chain for\n+   --  entity E. Note that it is an error to call this procedure with E being\n+   --  overloadable, and N being a pragma that applies to multiple overloadable\n+   --  entities (Convention, Interface, Inline, Inline_Always, Import, Export,\n+   --  External). This is not allowed even in the case where the entity is not\n+   --  overloaded, since we can't rely on it being present in the overloaded\n+   --  case, it is not useful to have it present in the non-overloaded case.\n \n    -------------------------------\n    -- Miscellaneous Subprograms --\n@@ -7083,6 +7106,7 @@ package Einfo is\n    pragma Inline (Has_Controlled_Component);\n    pragma Inline (Has_Controlling_Result);\n    pragma Inline (Has_Convention_Pragma);\n+   pragma Inline (Has_Delayed_Aspects);\n    pragma Inline (Has_Delayed_Freeze);\n    pragma Inline (Has_Discriminants);\n    pragma Inline (Has_Dispatch_Table);\n@@ -7515,6 +7539,7 @@ package Einfo is\n    pragma Inline (Set_Has_Controlled_Component);\n    pragma Inline (Set_Has_Controlling_Result);\n    pragma Inline (Set_Has_Convention_Pragma);\n+   pragma Inline (Set_Has_Delayed_Aspects);\n    pragma Inline (Set_Has_Delayed_Freeze);\n    pragma Inline (Set_Has_Discriminants);\n    pragma Inline (Set_Has_Dispatch_Table);"}, {"sha": "9cdef48449e5d15027a83f4ee65fe3412dc04acf", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -220,6 +220,31 @@ package body Exp_Ch13 is\n       Delete         : Boolean := False;\n \n    begin\n+      --  If there are delayed aspect specifications, we insert them just\n+      --  before the freeze node. They are already analyzed so we don't need\n+      --  to reanalyze them (they were analyzed before the type was frozen),\n+      --  but we want them in the tree for the back end, and so that the\n+      --  listing from sprint is clearer on where these occur logically.\n+\n+      if Has_Delayed_Aspects (E) then\n+         declare\n+            Aitem : Node_Id;\n+            Ritem : Node_Id;\n+\n+         begin\n+            Ritem := First_Rep_Item (E);\n+            while Present (Ritem) loop\n+               if Nkind (Ritem) = N_Aspect_Specification then\n+                  Aitem := Aspect_Rep_Item (Ritem);\n+                  pragma Assert (Is_Delayed_Aspect (Aitem));\n+                  Insert_Before (N, Aitem);\n+               end if;\n+\n+               Next_Rep_Item (Ritem);\n+            end loop;\n+         end;\n+      end if;\n+\n       --  Processing for objects with address clauses\n \n       if Is_Object (E) and then Present (Address_Clause (E)) then"}, {"sha": "f67e1c4e039984ec68cd7fb936b6fcfa91540166", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -6157,16 +6157,16 @@ package body Exp_Ch3 is\n                if not Is_Limited_Type (Def_Id) then\n                   Append_Freeze_Actions (Def_Id,\n                     Freeze_Entity\n-                      (Find_Prim_Op (Def_Id, Name_Adjust), Sloc (Def_Id)));\n+                      (Find_Prim_Op (Def_Id, Name_Adjust), Def_Id));\n                end if;\n \n                Append_Freeze_Actions (Def_Id,\n                  Freeze_Entity\n-                   (Find_Prim_Op (Def_Id, Name_Initialize), Sloc (Def_Id)));\n+                   (Find_Prim_Op (Def_Id, Name_Initialize), Def_Id));\n \n                Append_Freeze_Actions (Def_Id,\n                  Freeze_Entity\n-                   (Find_Prim_Op (Def_Id, Name_Finalize), Sloc (Def_Id)));\n+                   (Find_Prim_Op (Def_Id, Name_Finalize), Def_Id));\n             end if;\n \n             --  Freeze rest of primitive operations. There is no need to handle\n@@ -6361,8 +6361,7 @@ package body Exp_Ch3 is\n                       N_Subprogram_Declaration\n            and then not Is_Frozen (Stream_Op)\n          then\n-            Append_Freeze_Actions\n-               (Typ, Freeze_Entity (Stream_Op, Sloc (N)));\n+            Append_Freeze_Actions (Typ, Freeze_Entity (Stream_Op, N));\n          end if;\n       end loop;\n    end Freeze_Stream_Operations;\n@@ -8998,7 +8997,6 @@ package body Exp_Ch3 is\n    function Predefined_Primitive_Freeze\n      (Tag_Typ : Entity_Id) return List_Id\n    is\n-      Loc     : constant Source_Ptr := Sloc (Tag_Typ);\n       Res     : constant List_Id    := New_List;\n       Prim    : Elmt_Id;\n       Frnodes : List_Id;\n@@ -9007,7 +9005,7 @@ package body Exp_Ch3 is\n       Prim := First_Elmt (Primitive_Operations (Tag_Typ));\n       while Present (Prim) loop\n          if Is_Predefined_Dispatching_Operation (Node (Prim)) then\n-            Frnodes := Freeze_Entity (Node (Prim), Loc);\n+            Frnodes := Freeze_Entity (Node (Prim), Tag_Typ);\n \n             if Present (Frnodes) then\n                Append_List_To (Res, Frnodes);"}, {"sha": "e2b5ea86af1965d8010960a678699c643868b0e0", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -5459,7 +5459,7 @@ package body Exp_Ch6 is\n \n             Push_Scope (Scope (Scop));\n             Analyze (Prot_Decl);\n-            Insert_Actions (N, Freeze_Entity (Prot_Id, Loc));\n+            Insert_Actions (N, Freeze_Entity (Prot_Id, N));\n             Set_Protected_Body_Subprogram (Subp, Prot_Id);\n \n             --  Create protected operation as well. Even though the operation\n@@ -5699,7 +5699,7 @@ package body Exp_Ch6 is\n                            (Corresponding_Record_Type (Scop), Loc))));\n \n             Insert_Actions (N, Decls);\n-            Insert_Actions (N, Freeze_Entity (Obj_Ptr, Sloc (N)));\n+            Insert_Actions (N, Freeze_Entity (Obj_Ptr, N));\n \n             Rec :=\n               Make_Explicit_Dereference (Loc,"}, {"sha": "aa035571b11e61b68e8debafb293e254bb3f1019", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -10587,7 +10587,7 @@ package body Exp_Ch9 is\n          --  in time if we don't freeze now.\n \n          declare\n-            L : constant List_Id := Freeze_Entity (Rec_Ent, Loc);\n+            L : constant List_Id := Freeze_Entity (Rec_Ent, N);\n          begin\n             if Is_Non_Empty_List (L) then\n                Insert_List_After (Body_Decl, L);"}, {"sha": "ce9c3358717745ad534116f0b78d62fe75d96318", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -4387,7 +4387,7 @@ package body Exp_Disp is\n             Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n             while Present (Prim_Elmt) loop\n                Prim    := Node (Prim_Elmt);\n-               Frnodes := Freeze_Entity (Prim, Loc);\n+               Frnodes := Freeze_Entity (Prim, Typ);\n \n                declare\n                   F : Entity_Id;\n@@ -6728,8 +6728,8 @@ package body Exp_Disp is\n             --  generating these freezing nodes in wrong scopes (for example in\n             --  the IC routine of a derivation of Typ).\n \n-            Append_List_To (Result, Freeze_Entity (DT_Prims, Loc));\n-            Append_List_To (Result, Freeze_Entity (DT_Prims_Acc, Loc));\n+            Append_List_To (Result, Freeze_Entity (DT_Prims, Typ));\n+            Append_List_To (Result, Freeze_Entity (DT_Prims_Acc, Typ));\n \n             --  Mark entity of dispatch table. Required by the back end to\n             --  handle them properly."}, {"sha": "91e984386f2c0349b24d7221dbd07edbd5a84a50", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 88, "deletions": 63, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -101,10 +101,11 @@ package body Freeze is\n \n    procedure Freeze_And_Append\n      (Ent    : Entity_Id;\n-      Loc    : Source_Ptr;\n+      N      : Node_Id;\n       Result : in out List_Id);\n    --  Freezes Ent using Freeze_Entity, and appends the resulting list of\n-   --  nodes to Result, modifying Result from No_List if necessary.\n+   --  nodes to Result, modifying Result from No_List if necessary. N has\n+   --  the same usage as in Freeze_Entity.\n \n    procedure Freeze_Enumeration_Type (Typ : Entity_Id);\n    --  Freeze enumeration type. The Esize field is set as processing\n@@ -138,20 +139,20 @@ package body Freeze is\n    procedure Process_Default_Expressions\n      (E     : Entity_Id;\n       After : in out Node_Id);\n-   --  This procedure is called for each subprogram to complete processing\n-   --  of default expressions at the point where all types are known to be\n-   --  frozen. The expressions must be analyzed in full, to make sure that\n-   --  all error processing is done (they have only been pre-analyzed). If\n-   --  the expression is not an entity or literal, its analysis may generate\n-   --  code which must not be executed. In that case we build a function\n-   --  body to hold that code. This wrapper function serves no other purpose\n-   --  (it used to be called to evaluate the default, but now the default is\n-   --  inlined at each point of call).\n+   --  This procedure is called for each subprogram to complete processing of\n+   --  default expressions at the point where all types are known to be frozen.\n+   --  The expressions must be analyzed in full, to make sure that all error\n+   --  processing is done (they have only been pre-analyzed). If the expression\n+   --  is not an entity or literal, its analysis may generate code which must\n+   --  not be executed. In that case we build a function body to hold that\n+   --  code. This wrapper function serves no other purpose (it used to be\n+   --  called to evaluate the default, but now the default is inlined at each\n+   --  point of call).\n \n    procedure Set_Component_Alignment_If_Not_Set (Typ : Entity_Id);\n-   --  Typ is a record or array type that is being frozen. This routine\n-   --  sets the default component alignment from the scope stack values\n-   --  if the alignment is otherwise not specified.\n+   --  Typ is a record or array type that is being frozen. This routine sets\n+   --  the default component alignment from the scope stack values if the\n+   --  alignment is otherwise not specified.\n \n    procedure Check_Debug_Info_Needed (T : Entity_Id);\n    --  As each entity is frozen, this routine is called to deal with the\n@@ -162,9 +163,9 @@ package body Freeze is\n    --  subsidiary entities have the flag set as required.\n \n    procedure Undelay_Type (T : Entity_Id);\n-   --  T is a type of a component that we know to be an Itype.\n-   --  We don't want this to have a Freeze_Node, so ensure it doesn't.\n-   --  Do the same for any Full_View or Corresponding_Record_Type.\n+   --  T is a type of a component that we know to be an Itype. We don't want\n+   --  this to have a Freeze_Node, so ensure it doesn't. Do the same for any\n+   --  Full_View or Corresponding_Record_Type.\n \n    procedure Warn_Overlay\n      (Expr : Node_Id;\n@@ -1208,7 +1209,6 @@ package body Freeze is\n    --  as they are generated.\n \n    procedure Freeze_All (From : Entity_Id; After : in out Node_Id) is\n-      Loc   : constant Source_Ptr := Sloc (After);\n       E     : Entity_Id;\n       Decl  : Node_Id;\n \n@@ -1311,7 +1311,7 @@ package body Freeze is\n                      if Comes_From_Source (Subp)\n                        and then not Is_Frozen (Subp)\n                      then\n-                        Flist := Freeze_Entity (Subp, Loc);\n+                        Flist := Freeze_Entity (Subp, After);\n                         Process_Flist;\n                      end if;\n \n@@ -1321,7 +1321,7 @@ package body Freeze is\n             end if;\n \n             if not Is_Frozen (E) then\n-               Flist := Freeze_Entity (E, Loc);\n+               Flist := Freeze_Entity (E, After);\n                Process_Flist;\n             end if;\n \n@@ -1446,10 +1446,10 @@ package body Freeze is\n \n    procedure Freeze_And_Append\n      (Ent    : Entity_Id;\n-      Loc    : Source_Ptr;\n+      N      : Node_Id;\n       Result : in out List_Id)\n    is\n-      L : constant List_Id := Freeze_Entity (Ent, Loc);\n+      L : constant List_Id := Freeze_Entity (Ent, N);\n    begin\n       if Is_Non_Empty_List (L) then\n          if Result = No_List then\n@@ -1465,7 +1465,7 @@ package body Freeze is\n    -------------------\n \n    procedure Freeze_Before (N : Node_Id; T : Entity_Id) is\n-      Freeze_Nodes : constant List_Id := Freeze_Entity (T, Sloc (N));\n+      Freeze_Nodes : constant List_Id := Freeze_Entity (T, N);\n    begin\n       if Is_Non_Empty_List (Freeze_Nodes) then\n          Insert_Actions (N, Freeze_Nodes);\n@@ -1476,7 +1476,8 @@ package body Freeze is\n    -- Freeze_Entity --\n    -------------------\n \n-   function Freeze_Entity (E : Entity_Id; Loc : Source_Ptr) return List_Id is\n+   function Freeze_Entity (E : Entity_Id; N : Node_Id) return List_Id is\n+      Loc    : constant Source_Ptr := Sloc (N);\n       Test_E : Entity_Id := E;\n       Comp   : Entity_Id;\n       F_Node : Node_Id;\n@@ -1829,7 +1830,7 @@ package body Freeze is\n                      Undelay_Type (Etype (Comp));\n                   end if;\n \n-                  Freeze_And_Append (Etype (Comp), Loc, Result);\n+                  Freeze_And_Append (Etype (Comp), N, Result);\n \n                   --  Check for error of component clause given for variable\n                   --  sized type. We have to delay this test till this point,\n@@ -1988,21 +1989,21 @@ package body Freeze is\n                      then\n                         if Is_Entity_Name (Expression (Alloc)) then\n                            Freeze_And_Append\n-                             (Entity (Expression (Alloc)), Loc, Result);\n+                             (Entity (Expression (Alloc)), N, Result);\n                         elsif\n                           Nkind (Expression (Alloc)) = N_Subtype_Indication\n                         then\n                            Freeze_And_Append\n                             (Entity (Subtype_Mark (Expression (Alloc))),\n-                              Loc, Result);\n+                             N, Result);\n                         end if;\n \n                      elsif Is_Itype (Designated_Type (Etype (Comp))) then\n                         Check_Itype (Etype (Comp));\n \n                      else\n                         Freeze_And_Append\n-                          (Designated_Type (Etype (Comp)), Loc, Result);\n+                          (Designated_Type (Etype (Comp)), N, Result);\n                      end if;\n                   end if;\n                end;\n@@ -2023,7 +2024,7 @@ package body Freeze is\n             then\n                Freeze_And_Append\n                  (Designated_Type\n-                   (Component_Type (Etype (Comp))), Loc, Result);\n+                   (Component_Type (Etype (Comp))), N, Result);\n             end if;\n \n             Prev := Comp;\n@@ -2110,8 +2111,7 @@ package body Freeze is\n \n          if Ekind (Rec) = E_Record_Type then\n             if Present (Corresponding_Remote_Type (Rec)) then\n-               Freeze_And_Append\n-                 (Corresponding_Remote_Type (Rec), Loc, Result);\n+               Freeze_And_Append (Corresponding_Remote_Type (Rec), N, Result);\n             end if;\n \n             Comp := First_Component (Rec);\n@@ -2372,6 +2372,32 @@ package body Freeze is\n          end;\n       end if;\n \n+      --  Deal with delayed aspect specifications. At the point of occurrence\n+      --  of the aspect definition, we preanalyzed the argument, to capture\n+      --  the visibility at that point, but the actual analysis of the aspect\n+      --  is required to be delayed to the freeze point, so we evalute the\n+      --  pragma or attribute definition clause in the tree at this point.\n+\n+      if Has_Delayed_Aspects (E) then\n+         declare\n+            Ritem : Node_Id;\n+            Aitem : Node_Id;\n+\n+         begin\n+            Ritem := First_Rep_Item (E);\n+            while Present (Ritem) loop\n+               if Nkind (Ritem) = N_Aspect_Specification then\n+                  Aitem := Aspect_Rep_Item (Ritem);\n+                  pragma Assert (Is_Delayed_Aspect (Aitem));\n+                  Set_Parent (Aitem, Ritem);\n+                  Analyze (Aitem);\n+               end if;\n+\n+               Next_Rep_Item (Ritem);\n+            end loop;\n+         end;\n+      end if;\n+\n       --  Here to freeze the entity\n \n       Result := No_List;\n@@ -2433,7 +2459,7 @@ package body Freeze is\n                   Formal := First_Formal (E);\n                   while Present (Formal) loop\n                      F_Type := Etype (Formal);\n-                     Freeze_And_Append (F_Type, Loc, Result);\n+                     Freeze_And_Append (F_Type, N, Result);\n \n                      if Is_Private_Type (F_Type)\n                        and then Is_Private_Type (Base_Type (F_Type))\n@@ -2589,7 +2615,7 @@ package body Freeze is\n                         if Is_Itype (Etype (Formal))\n                           and then Ekind (F_Type) = E_Subprogram_Type\n                         then\n-                           Freeze_And_Append (F_Type, Loc, Result);\n+                           Freeze_And_Append (F_Type, N, Result);\n                         end if;\n                      end if;\n \n@@ -2603,7 +2629,7 @@ package body Freeze is\n                      --  Freeze return type\n \n                      R_Type := Etype (E);\n-                     Freeze_And_Append (R_Type, Loc, Result);\n+                     Freeze_And_Append (R_Type, N, Result);\n \n                      --  Check suspicious return type for C function\n \n@@ -2716,7 +2742,7 @@ package body Freeze is\n             --  Must freeze its parent first if it is a derived subprogram\n \n             if Present (Alias (E)) then\n-               Freeze_And_Append (Alias (E), Loc, Result);\n+               Freeze_And_Append (Alias (E), N, Result);\n             end if;\n \n             --  We don't freeze internal subprograms, because we don't normally\n@@ -2740,7 +2766,7 @@ package body Freeze is\n             if Present (Etype (E))\n               and then Ekind (E) /= E_Generic_Function\n             then\n-               Freeze_And_Append (Etype (E), Loc, Result);\n+               Freeze_And_Append (Etype (E), N, Result);\n             end if;\n \n             --  Special processing for objects created by object declaration\n@@ -3075,20 +3101,20 @@ package body Freeze is\n             Atype := Ancestor_Subtype (E);\n \n             if Present (Atype) then\n-               Freeze_And_Append (Atype, Loc, Result);\n+               Freeze_And_Append (Atype, N, Result);\n \n             --  Otherwise freeze the base type of the entity before freezing\n             --  the entity itself (RM 13.14(15)).\n \n             elsif E /= Base_Type (E) then\n-               Freeze_And_Append (Base_Type (E), Loc, Result);\n+               Freeze_And_Append (Base_Type (E), N, Result);\n             end if;\n \n          --  For a derived type, freeze its parent type first (RM 13.14(15))\n \n          elsif Is_Derived_Type (E) then\n-            Freeze_And_Append (Etype (E), Loc, Result);\n-            Freeze_And_Append (First_Subtype (Etype (E)), Loc, Result);\n+            Freeze_And_Append (Etype (E), N, Result);\n+            Freeze_And_Append (First_Subtype (Etype (E)), N, Result);\n          end if;\n \n          --  For array type, freeze index types and component type first\n@@ -3105,11 +3131,11 @@ package body Freeze is\n                --  with a non-standard representation.\n \n             begin\n-               Freeze_And_Append (Ctyp, Loc, Result);\n+               Freeze_And_Append (Ctyp, N, Result);\n \n                Indx := First_Index (E);\n                while Present (Indx) loop\n-                  Freeze_And_Append (Etype (Indx), Loc, Result);\n+                  Freeze_And_Append (Etype (Indx), N, Result);\n \n                   if Is_Enumeration_Type (Etype (Indx))\n                     and then Has_Non_Standard_Rep (Etype (Indx))\n@@ -3458,7 +3484,7 @@ package body Freeze is\n                  and then Ekind (E) /= E_String_Literal_Subtype\n                then\n                   Create_Packed_Array_Type (E);\n-                  Freeze_And_Append (Packed_Array_Type (E), Loc, Result);\n+                  Freeze_And_Append (Packed_Array_Type (E), N, Result);\n \n                   --  Size information of packed array type is copied to the\n                   --  array type, since this is really the representation. But\n@@ -3501,7 +3527,7 @@ package body Freeze is\n          --  frozen as well (RM 13.14(15))\n \n          elsif Is_Class_Wide_Type (E) then\n-            Freeze_And_Append (Root_Type (E), Loc, Result);\n+            Freeze_And_Append (Root_Type (E), N, Result);\n \n             --  If the base type of the class-wide type is still incomplete,\n             --  the class-wide remains unfrozen as well. This is legal when\n@@ -3541,7 +3567,7 @@ package body Freeze is\n             if Ekind (E) = E_Class_Wide_Subtype\n               and then Present (Equivalent_Type (E))\n             then\n-               Freeze_And_Append (Equivalent_Type (E), Loc, Result);\n+               Freeze_And_Append (Equivalent_Type (E), N, Result);\n             end if;\n \n          --  For a record (sub)type, freeze all the component types (RM\n@@ -3565,13 +3591,13 @@ package body Freeze is\n          elsif Is_Concurrent_Type (E) then\n             if Present (Corresponding_Record_Type (E)) then\n                Freeze_And_Append\n-                 (Corresponding_Record_Type (E), Loc, Result);\n+                 (Corresponding_Record_Type (E), N, Result);\n             end if;\n \n             Comp := First_Entity (E);\n             while Present (Comp) loop\n                if Is_Type (Comp) then\n-                  Freeze_And_Append (Comp, Loc, Result);\n+                  Freeze_And_Append (Comp, N, Result);\n \n                elsif (Ekind (Comp)) /= E_Function then\n                   if Is_Itype (Etype (Comp))\n@@ -3580,7 +3606,7 @@ package body Freeze is\n                      Undelay_Type (Etype (Comp));\n                   end if;\n \n-                  Freeze_And_Append (Etype (Comp), Loc, Result);\n+                  Freeze_And_Append (Etype (Comp), N, Result);\n                end if;\n \n                Next_Entity (Comp);\n@@ -3638,7 +3664,6 @@ package body Freeze is\n                --  processing is required\n \n                if Is_Frozen (Full_View (E)) then\n-\n                   Set_Has_Delayed_Freeze (E, False);\n                   Set_Freeze_Node (E, Empty);\n                   Check_Debug_Info_Needed (E);\n@@ -3655,10 +3680,10 @@ package body Freeze is\n                        and then Present (Underlying_Full_View (Full))\n                      then\n                         Freeze_And_Append\n-                          (Underlying_Full_View (Full), Loc, Result);\n+                          (Underlying_Full_View (Full), N, Result);\n                      end if;\n \n-                     Freeze_And_Append (Full, Loc, Result);\n+                     Freeze_And_Append (Full, N, Result);\n \n                      if Has_Delayed_Freeze (E) then\n                         F_Node := Freeze_Node (Full);\n@@ -3746,7 +3771,7 @@ package body Freeze is\n                   end if;\n                end if;\n \n-               Freeze_And_Append (Etype (Formal), Loc, Result);\n+               Freeze_And_Append (Etype (Formal), N, Result);\n                Next_Formal (Formal);\n             end loop;\n \n@@ -3758,7 +3783,7 @@ package body Freeze is\n \n          elsif Is_Access_Protected_Subprogram_Type (E) then\n             if Present (Equivalent_Type (E)) then\n-               Freeze_And_Append (Equivalent_Type (E), Loc, Result);\n+               Freeze_And_Append (Equivalent_Type (E), N, Result);\n             end if;\n          end if;\n \n@@ -4008,7 +4033,7 @@ package body Freeze is\n       --  since obviously the first subtype depends on its own base type.\n \n       if Is_Type (E) then\n-         Freeze_And_Append (First_Subtype (E), Loc, Result);\n+         Freeze_And_Append (First_Subtype (E), N, Result);\n \n          --  If we just froze a tagged non-class wide record, then freeze the\n          --  corresponding class-wide type. This must be done after the tagged\n@@ -4019,7 +4044,7 @@ package body Freeze is\n            and then not Is_Class_Wide_Type (E)\n            and then Present (Class_Wide_Type (E))\n          then\n-            Freeze_And_Append (Class_Wide_Type (E), Loc, Result);\n+            Freeze_And_Append (Class_Wide_Type (E), N, Result);\n          end if;\n       end if;\n \n@@ -4525,21 +4550,21 @@ package body Freeze is\n         or else Ekind (Current_Scope) = E_Void\n       then\n          declare\n-            Loc          : constant Source_Ptr := Sloc (Current_Scope);\n-            Freeze_Nodes : List_Id := No_List;\n-            Pos          : Int := Scope_Stack.Last;\n+            N            : constant Node_Id    := Current_Scope;\n+            Freeze_Nodes : List_Id             := No_List;\n+            Pos          : Int                 := Scope_Stack.Last;\n \n          begin\n             if Present (Desig_Typ) then\n-               Freeze_And_Append (Desig_Typ, Loc, Freeze_Nodes);\n+               Freeze_And_Append (Desig_Typ, N, Freeze_Nodes);\n             end if;\n \n             if Present (Typ) then\n-               Freeze_And_Append (Typ, Loc, Freeze_Nodes);\n+               Freeze_And_Append (Typ, N, Freeze_Nodes);\n             end if;\n \n             if Present (Nam) then\n-               Freeze_And_Append (Nam, Loc, Freeze_Nodes);\n+               Freeze_And_Append (Nam, N, Freeze_Nodes);\n             end if;\n \n             --  The current scope may be that of a constrained component of\n@@ -4553,7 +4578,7 @@ package body Freeze is\n             if Is_Non_Empty_List (Freeze_Nodes) then\n                if No (Scope_Stack.Table (Pos).Pending_Freeze_Actions) then\n                   Scope_Stack.Table (Pos).Pending_Freeze_Actions :=\n-                      Freeze_Nodes;\n+                    Freeze_Nodes;\n                else\n                   Append_List (Freeze_Nodes,\n                     Scope_Stack.Table (Pos).Pending_Freeze_Actions);\n@@ -5056,7 +5081,7 @@ package body Freeze is\n \n    begin\n       Set_Has_Delayed_Freeze (T);\n-      L := Freeze_Entity (T, Sloc (N));\n+      L := Freeze_Entity (T, N);\n \n       if Is_Non_Empty_List (L) then\n          Insert_Actions (N, L);"}, {"sha": "d4dd1a1251b7d18c78c55e931e0143396b78df68", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -179,21 +179,21 @@ package Freeze is\n      (E   : Entity_Id;\n       Typ : Entity_Id) return Boolean;\n \n-   --  If an atomic object is initialized with an aggregate or is assigned\n-   --  an aggregate, we have to prevent a piecemeal access or assignment\n-   --  to the object, even if the aggregate is to be expanded. We create\n-   --  a temporary for the aggregate, and assign the temporary instead,\n-   --  so that the back end can generate an atomic move for it. This is\n-   --  only done in the context of an object declaration or an assignment.\n-   --  Function is a noop and returns false in other contexts.\n-\n-   function Freeze_Entity (E : Entity_Id; Loc : Source_Ptr) return List_Id;\n-   --  Freeze an entity, and return Freeze nodes, to be inserted at the\n-   --  point of call. Loc is a source location which corresponds to the\n-   --  freeze point. This is used in placing warning messages in the\n-   --  situation where it appears that a type has been frozen too early,\n-   --  e.g. when a primitive operation is declared after the freezing\n-   --  point of its tagged type. Returns No_List if no freeze nodes needed.\n+   --  If an atomic object is initialized with an aggregate or is assigned an\n+   --  aggregate, we have to prevent a piecemeal access or assignment to the\n+   --  object, even if the aggregate is to be expanded. We create a temporary\n+   --  for the aggregate, and assign the temporary instead, so that the back\n+   --  end can generate an atomic move for it. This is only done in the context\n+   --  of an object declaration or an assignment. Function is a noop and\n+   --  returns false in other contexts.\n+\n+   function Freeze_Entity (E : Entity_Id; N : Node_Id) return List_Id;\n+   --  Freeze an entity, and return Freeze nodes, to be inserted at the point\n+   --  of call. N is a node whose source location corresponds to the freeze\n+   --  point. This is used in placing warning messages in the situation where\n+   --  it appears that a type has been frozen too early, e.g. when a primitive\n+   --  operation is declared after the freezing point of its tagged type.\n+   --  Returns No_List if no freeze nodes needed.\n \n    procedure Freeze_All (From : Entity_Id; After : in out Node_Id);\n    --  Before a non-instance body, or at the end of a declarative part"}, {"sha": "a080ee8311a714a0e9a7f4d1aaa1f0c29a280b86", "filename": "gcc/ada/g-htable.ads", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fg-htable.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fg-htable.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-htable.ads?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1995-2009, AdaCore                     --\n+--                     Copyright (C) 1995-2010, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -111,6 +111,20 @@ package GNAT.HTable is\n    --     --  same function since the last call to Get_First or No_Element if\n    --     --  there is no such element. If there is no call to 'Set' in between\n    --     --  Get_Next calls, all the elements of the HTable will be traversed.\n+\n+   --     procedure Get_First (K : out Key; E : out Element);\n+   --     --  This version of the iterator returns a key/element pair. A non-\n+   --     --  specified entry is returned, and there is no guarantee that two\n+   --     --  calls to this procedure will return the same element.\n+\n+   --     procedure Get_Next (K : out Key; E : out Element);\n+   --     --  This version of the iterator returns a key/element pair. It\n+   --     --  returns a non-specified element that has not been returned since\n+   --     --  the last call to Get_First. If there is no remaining element,\n+   --     --  then E is set to No_Element, and the value in K is undefined.\n+   --     --  If there is no call to Set in between Get_Next calls, all the\n+   --     --  elements of the HTable will be traversed.\n+\n    --  end Simple_HTable;\n \n    -------------------"}, {"sha": "2a54ed1622d809c177202d72ef12c62234612035", "filename": "gcc/ada/s-htable.adb", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fs-htable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fs-htable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-htable.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -246,6 +246,17 @@ package body System.HTable is\n          end if;\n       end Get_First;\n \n+      procedure Get_First (K : in out Key; E : out Element) is\n+         Tmp : constant Elmt_Ptr := Tab.Get_First;\n+      begin\n+         if Tmp = null then\n+            E := No_Element;\n+         else\n+            K := Tmp.K;\n+            E := Tmp.E;\n+         end if;\n+      end Get_First;\n+\n       -------------\n       -- Get_Key --\n       -------------\n@@ -269,6 +280,17 @@ package body System.HTable is\n          end if;\n       end Get_Next;\n \n+      procedure Get_Next (K : in out Key; E : out Element) is\n+         Tmp : constant Elmt_Ptr := Tab.Get_Next;\n+      begin\n+         if Tmp = null then\n+            E := No_Element;\n+         else\n+            K := Tmp.K;\n+            E := Tmp.E;\n+         end if;\n+      end Get_Next;\n+\n       ----------\n       -- Next --\n       ----------"}, {"sha": "8f02b95f4769d1ec4760fc127701d06381c50f27", "filename": "gcc/ada/s-htable.ads", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fs-htable.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fs-htable.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-htable.ads?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -94,8 +94,24 @@ package System.HTable is\n       function Get_Next return Element;\n       --  Returns a non-specified element that has not been returned by the\n       --  same function since the last call to Get_First or No_Element if\n-      --  there is no such element. If there is no call to 'Set' in between\n+      --  there is no such element. If there is no call to Set in between\n       --  Get_Next calls, all the elements of the HTable will be traversed.\n+\n+      procedure Get_First (K : in out Key; E : out Element);\n+      --  This version of the iterator returns a key/element pair. A non-\n+      --  specified entry is returned, and there is no guarantee that two\n+      --  calls to this procedure will return the same element. If the table\n+      --  is empty, E is set to No_Element, and K is unchanged, otherwise\n+      --  K and E are set to the first returned entry.\n+\n+      procedure Get_Next (K : in out Key; E : out Element);\n+      --  This version of the iterator returns a key/element pair. It returns\n+      --  a non-specified element that has not been returned since the last\n+      --  call to Get_First. If there is no remaining element, then E is set\n+      --  to No_Element, and the value in K is unchanged, otherwise K and E\n+      --  are set to the next entry. If there is no call to Set in between\n+      --  Get_Next calls, all the elements of the HTable will be traversed.\n+\n    end Simple_HTable;\n \n    -------------------"}, {"sha": "1e28ab0cd425816c7d992b1d78d159af89a22fa4", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -3706,10 +3706,14 @@ package body Sem_Aggr is\n                               end if;\n                            end Process_Component;\n \n+                        --  Start of processing for Propagate_Discriminants\n+\n                         begin\n                            --  The component type may be a variant type, so\n                            --  collect the components that are ruled by the\n-                           --  known values of the discriminants.\n+                           --  known values of the discriminants. Their values\n+                           --  have already been inserted into the component\n+                           --  list of the current aggregate.\n \n                            if Nkind (Def_Node) =  N_Record_Definition\n                              and then\n@@ -3720,7 +3724,7 @@ package body Sem_Aggr is\n                            then\n                               Gather_Components (Aggr_Type,\n                                 Component_List (Def_Node),\n-                                Governed_By   => Assoc_List,\n+                                Governed_By   => Component_Associations (Aggr),\n                                 Into          => Components,\n                                 Report_Errors => Errors);\n "}, {"sha": "1dd183d284f5ca284a34ebf7e3b5ab8f52d2ab3b", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -5356,8 +5356,34 @@ package body Sem_Attr is\n    --  Start of processing for Eval_Attribute\n \n    begin\n-      --  Acquire first two expressions (at the moment, no attributes\n-      --  take more than two expressions in any case).\n+      --  No folding in spec expression that comes from source where the prefix\n+      --  is an unfrozen entity. This avoids premature folding in cases like:\n+\n+      --    procedure DefExprAnal is\n+      --       type R is new Integer;\n+      --       procedure P (Arg : Integer := R'Size);\n+      --       for R'Size use 64;\n+      --       procedure P (Arg : Integer := R'Size) is\n+      --       begin\n+      --          Put_Line (Arg'Img);\n+      --       end P;\n+      --    begin\n+      --       P;\n+      --    end;\n+\n+      --  which shouold print 64 rather than 32. The exclusion of non-source\n+      --  constructs from this test comes from some internal usage in packed\n+      --  arrays, which otherwise fails, could use more analysis perhaps???\n+\n+      if In_Spec_Expression\n+        and then Comes_From_Source (N)\n+        and then not (Is_Entity_Name (P) and then Is_Frozen (Entity (P)))\n+      then\n+         return;\n+      end if;\n+\n+      --  Acquire first two expressions (at the moment, no attributes take more\n+      --  than two expressions in any case).\n \n       if Present (Expressions (N)) then\n          E1 := First (Expressions (N));\n@@ -5374,8 +5400,6 @@ package body Sem_Attr is\n \n       if Id = Attribute_Enabled then\n \n-         --  Evaluate the Enabled attribute\n-\n          --  We skip evaluation if the expander is not active. This is not just\n          --  an optimization. It is of key importance that we not rewrite the\n          --  attribute in a generic template, since we want to pick up the\n@@ -7889,7 +7913,7 @@ package body Sem_Attr is\n                   --  Avoid insertion of freeze actions in spec expression mode\n \n                   if not In_Spec_Expression then\n-                     Insert_Actions (N, Freeze_Entity (Entity (P), Loc));\n+                     Insert_Actions (N, Freeze_Entity (Entity (P), N));\n                   end if;\n \n                elsif Is_Type (Entity (P)) then\n@@ -8668,14 +8692,14 @@ package body Sem_Attr is\n          -- Range --\n          -----------\n \n-         --  We replace the Range attribute node with a range expression\n-         --  whose bounds are the 'First and 'Last attributes applied to the\n-         --  same prefix. The reason that we do this transformation here\n-         --  instead of in the expander is that it simplifies other parts of\n-         --  the semantic analysis which assume that the Range has been\n-         --  replaced; thus it must be done even when in semantic-only mode\n-         --  (note that the RM specifically mentions this equivalence, we\n-         --  take care that the prefix is only evaluated once).\n+         --  We replace the Range attribute node with a range expression whose\n+         --  bounds are the 'First and 'Last attributes applied to the same\n+         --  prefix. The reason that we do this transformation here instead of\n+         --  in the expander is that it simplifies other parts of the semantic\n+         --  analysis which assume that the Range has been replaced; thus it\n+         --  must be done even when in semantic-only mode (note that the RM\n+         --  specifically mentions this equivalence, we take care that the\n+         --  prefix is only evaluated once).\n \n          when Attribute_Range => Range_Attribute :\n             declare"}, {"sha": "4db2fb74245414888601855d2e05696825053bb6", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -1204,9 +1204,8 @@ package body Sem_Ch10 is\n       --  compilation unit actions list, and analyze them.\n \n       declare\n-         Loc : constant Source_Ptr := Sloc (N);\n-         L   : constant List_Id :=\n-                 Freeze_Entity (Cunit_Entity (Current_Sem_Unit), Loc);\n+         L : constant List_Id :=\n+               Freeze_Entity (Cunit_Entity (Current_Sem_Unit), N);\n       begin\n          while Is_Non_Empty_List (L) loop\n             Insert_Library_Level_Action (Remove_Head (L));"}, {"sha": "da7e05e3242c17fe09f50f49668c564554f9803f", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -57,7 +57,6 @@ package body Sem_Ch11 is\n    procedure Analyze_Exception_Declaration (N : Node_Id) is\n       Id : constant Entity_Id := Defining_Identifier (N);\n       PF : constant Boolean   := Is_Pure (Current_Scope);\n-      AS : constant List_Id   := Aspect_Specifications (N);\n    begin\n       Generate_Definition         (Id);\n       Enter_Name                  (Id);\n@@ -66,7 +65,7 @@ package body Sem_Ch11 is\n       Set_Etype                   (Id, Standard_Exception_Type);\n       Set_Is_Statically_Allocated (Id);\n       Set_Is_Pure                 (Id, PF);\n-      Analyze_Aspect_Specifications (N, Id, AS);\n+      Analyze_Aspect_Specifications (N, Id, Aspect_Specifications (N));\n    end Analyze_Exception_Declaration;\n \n    --------------------------------"}, {"sha": "5ef698695972ea989b888dadb1ee17d90afea5f6", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -1802,7 +1802,6 @@ package body Sem_Ch12 is\n    procedure Analyze_Formal_Object_Declaration (N : Node_Id) is\n       E  : constant Node_Id := Default_Expression (N);\n       Id : constant Node_Id := Defining_Identifier (N);\n-      AS : constant List_Id := Aspect_Specifications (N);\n       K  : Entity_Kind;\n       T  : Node_Id;\n \n@@ -1932,7 +1931,7 @@ package body Sem_Ch12 is\n          end if;\n       end if;\n \n-      Analyze_Aspect_Specifications (N, Id, AS);\n+      Analyze_Aspect_Specifications (N, Id, Aspect_Specifications (N));\n    end Analyze_Formal_Object_Declaration;\n \n    ----------------------------------------------\n@@ -1983,7 +1982,6 @@ package body Sem_Ch12 is\n    procedure Analyze_Formal_Package_Declaration (N : Node_Id) is\n       Loc              : constant Source_Ptr := Sloc (N);\n       Pack_Id          : constant Entity_Id  := Defining_Identifier (N);\n-      AS               : constant List_Id    := Aspect_Specifications (N);\n       Formal           : Entity_Id;\n       Gen_Id           : constant Node_Id    := Name (N);\n       Gen_Decl         : Node_Id;\n@@ -2279,7 +2277,8 @@ package body Sem_Ch12 is\n       Set_Scope (Pack_Id, Scope (Formal));\n       Set_Has_Completion (Pack_Id, True);\n \n-      <<Leave>> Analyze_Aspect_Specifications (N, Pack_Id, AS);\n+      <<Leave>>\n+         Analyze_Aspect_Specifications (N, Pack_Id, Aspect_Specifications (N));\n    end Analyze_Formal_Package_Declaration;\n \n    ---------------------------------\n@@ -2338,7 +2337,6 @@ package body Sem_Ch12 is\n       Spec : constant Node_Id   := Specification (N);\n       Def  : constant Node_Id   := Default_Name (N);\n       Nam  : constant Entity_Id := Defining_Unit_Name (Spec);\n-      AS   : constant List_Id   := Aspect_Specifications (N);\n       Subp : Entity_Id;\n \n    begin\n@@ -2500,7 +2498,8 @@ package body Sem_Ch12 is\n          end if;\n       end if;\n \n-      <<Leave>> Analyze_Aspect_Specifications (N, Nam, AS);\n+      <<Leave>>\n+         Analyze_Aspect_Specifications (N, Nam, Aspect_Specifications (N));\n    end Analyze_Formal_Subprogram_Declaration;\n \n    -------------------------------------\n@@ -2509,7 +2508,6 @@ package body Sem_Ch12 is\n \n    procedure Analyze_Formal_Type_Declaration (N : Node_Id) is\n       Def : constant Node_Id := Formal_Type_Definition (N);\n-      AS  : constant List_Id := Aspect_Specifications (N);\n       T   : Entity_Id;\n \n    begin\n@@ -2575,7 +2573,7 @@ package body Sem_Ch12 is\n       end case;\n \n       Set_Is_Generic_Type (T);\n-      Analyze_Aspect_Specifications (N, T, AS);\n+      Analyze_Aspect_Specifications (N, T, Aspect_Specifications (N));\n    end Analyze_Formal_Type_Declaration;\n \n    ------------------------------------\n@@ -2642,7 +2640,6 @@ package body Sem_Ch12 is\n \n    procedure Analyze_Generic_Package_Declaration (N : Node_Id) is\n       Loc         : constant Source_Ptr := Sloc (N);\n-      AS          : constant List_Id    := Aspect_Specifications (N);\n       Id          : Entity_Id;\n       New_N       : Node_Id;\n       Save_Parent : Node_Id;\n@@ -2754,15 +2751,14 @@ package body Sem_Ch12 is\n          end if;\n       end if;\n \n-      Analyze_Aspect_Specifications (N, Id, AS);\n+      Analyze_Aspect_Specifications (N, Id, Aspect_Specifications (N));\n    end Analyze_Generic_Package_Declaration;\n \n    --------------------------------------------\n    -- Analyze_Generic_Subprogram_Declaration --\n    --------------------------------------------\n \n    procedure Analyze_Generic_Subprogram_Declaration (N : Node_Id) is\n-      AS          : constant List_Id := Aspect_Specifications (N);\n       Spec        : Node_Id;\n       Id          : Entity_Id;\n       Formals     : List_Id;\n@@ -2881,7 +2877,7 @@ package body Sem_Ch12 is\n       End_Scope;\n       Exit_Generic_Scope (Id);\n       Generate_Reference_To_Formals (Id);\n-      Analyze_Aspect_Specifications (N, Id, AS);\n+      Analyze_Aspect_Specifications (N, Id, Aspect_Specifications (N));\n    end Analyze_Generic_Subprogram_Declaration;\n \n    -----------------------------------\n@@ -2891,7 +2887,6 @@ package body Sem_Ch12 is\n    procedure Analyze_Package_Instantiation (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Gen_Id : constant Node_Id    := Name (N);\n-      AS     : constant List_Id    := Aspect_Specifications (N);\n \n       Act_Decl      : Node_Id;\n       Act_Decl_Name : Node_Id;\n@@ -3555,7 +3550,9 @@ package body Sem_Ch12 is\n          Set_Defining_Identifier (N, Act_Decl_Id);\n       end if;\n \n-      <<Leave>> Analyze_Aspect_Specifications (N, Act_Decl_Id, AS);\n+      <<Leave>>\n+         Analyze_Aspect_Specifications\n+           (N, Act_Decl_Id, Aspect_Specifications (N));\n \n    exception\n       when Instantiation_Error =>\n@@ -3582,8 +3579,7 @@ package body Sem_Ch12 is\n                       Cunit_Entity (Get_Source_Unit (Gen_Unit));\n       Curr_Comp    : constant Node_Id := Cunit (Current_Sem_Unit);\n       Curr_Scope   : Entity_Id := Empty;\n-      Curr_Unit    : constant Entity_Id :=\n-                       Cunit_Entity (Current_Sem_Unit);\n+      Curr_Unit    : constant Entity_Id := Cunit_Entity (Current_Sem_Unit);\n       Removed      : Boolean := False;\n       Num_Scopes   : Int := 0;\n \n@@ -3910,7 +3906,6 @@ package body Sem_Ch12 is\n    is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Gen_Id : constant Node_Id    := Name (N);\n-      AS     : constant List_Id    := Aspect_Specifications (N);\n \n       Anon_Id : constant Entity_Id :=\n                   Make_Defining_Identifier (Sloc (Defining_Entity (N)),\n@@ -4332,7 +4327,9 @@ package body Sem_Ch12 is\n          Generic_Renamings_HTable.Reset;\n       end if;\n \n-      <<Leave>> Analyze_Aspect_Specifications (N, Act_Decl_Id, AS);\n+      <<Leave>>\n+         Analyze_Aspect_Specifications\n+           (N, Act_Decl_Id, Aspect_Specifications (N));\n \n    exception\n       when Instantiation_Error =>"}, {"sha": "921c23c442200cb98a3ac918a5ada4863639ec8e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 212, "deletions": 58, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -26,6 +26,7 @@\n with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -629,12 +630,31 @@ package body Sem_Ch13 is\n       L : List_Id)\n    is\n       Aspect : Node_Id;\n+      Aitem  : Node_Id;\n       Ent    : Node_Id;\n-      Result : Boolean;\n-      Ritem  : Node_Id;\n \n       Ins_Node : Node_Id := N;\n-      --  Insert pragmas after this node\n+      --  Insert pragmas (other than Pre/Post) after this node\n+\n+      --  The general processing involves building an attribute definition\n+      --  clause or a pragma node that corresponds to the access type. Then\n+      --  one of two things happens:\n+\n+      --  If we are required to delay the evaluation of this aspect to the\n+      --  freeze point, we preanalyze the relevant argument, and then attach\n+      --  the corresponding pragma/attribute definition clause to the aspect\n+      --  specification node, which is then placed in the Rep Item chain.\n+      --  In this case we mark the entity with the Has_Delayed_Aspects flag,\n+      --  and we evaluate the rep item at the freeze point.\n+\n+      --  If no delay is required, we just insert the pragma or attribute\n+      --  after the declaration, and it will get processed by the normal\n+      --  circuit. The From_Aspect_Specification flag is set on the pragma\n+      --  or attribute definition node in either case to activate special\n+      --  processing (e.g. not traversing the list of homonyms for inline).\n+\n+      Delay_Required : Boolean;\n+      --  Set True if delay is required\n \n    begin\n       if L = No_List then\n@@ -644,12 +664,17 @@ package body Sem_Ch13 is\n       Aspect := First (L);\n       while Present (Aspect) loop\n          declare\n-            Id   : constant Node_Id  := Identifier (Aspect);\n-            Expr : constant Node_Id  := Expression (Aspect);\n-            Nam  : constant Name_Id  := Chars (Id);\n+            Id   : constant Node_Id   := Identifier (Aspect);\n+            Expr : constant Node_Id   := Expression (Aspect);\n+            Nam  : constant Name_Id   := Chars (Id);\n+            A_Id : constant Aspect_Id := Get_Aspect_Id (Nam);\n             Anod : Node_Id;\n+            T    : Entity_Id;\n \n          begin\n+            Set_Entity (Aspect, E);\n+            Ent := New_Occurrence_Of (E, Sloc (Id));\n+\n             --  Check for duplicate aspect\n \n             Anod := First (L);\n@@ -667,7 +692,7 @@ package body Sem_Ch13 is\n \n             --  Processing based on specific aspect\n \n-            case Get_Aspect_Id (Nam) is\n+            case A_Id is\n \n                --  No_Aspect should be impossible\n \n@@ -701,40 +726,46 @@ package body Sem_Ch13 is\n                     Aspect_Volatile                     |\n                     Aspect_Volatile_Components          =>\n \n+                  --  Build corresponding pragma node\n+\n+                  Aitem :=\n+                    Make_Pragma (Sloc (Aspect),\n+                      Pragma_Argument_Associations => New_List (Ent),\n+                      Pragma_Identifier            =>\n+                        Make_Identifier (Sloc (Id), Chars (Id)));\n+\n+                  --  Deal with missing expression case, delay never needed\n+\n                   if No (Expr) then\n-                     Result := True;\n+                     Delay_Required := False;\n+\n+                  --  Expression is present\n \n                   else\n-                     Analyze_And_Resolve (Expr);\n+                     Preanalyze_Spec_Expression (Expr, Standard_Boolean);\n \n-                     if not Is_OK_Static_Expression (Expr) then\n-                        Error_Msg_N\n-                          (\"static boolean expression required here\", Expr);\n-                        Result := True;\n+                     --  If preanalysis gives a static expression, we don't\n+                     --  need to delay (this will happen often in practice).\n \n-                     else\n-                        Result := Is_True (Expr_Value (Expr));\n-                     end if;\n-                  end if;\n+                     if Is_OK_Static_Expression (Expr) then\n+                        Delay_Required := False;\n \n-                  Ent := New_Occurrence_Of (E, Sloc (Id));\n+                        if Is_False (Expr_Value (Expr)) then\n+                           Set_Aspect_Cancel (Aitem);\n+                        end if;\n \n-                  Ritem :=\n-                    Make_Pragma (Sloc (Aspect),\n-                      Pragma_Argument_Associations => New_List (Ent),\n-                      Pragma_Identifier            =>\n-                         Make_Identifier (Sloc (Id), Chars (Id)));\n+                     --  If we don't get a static expression, then delay, the\n+                     --  expression may turn out static by freeze time.\n \n-                  if Result = False then\n-                     Set_Aspect_Cancel (Ritem);\n+                     else\n+                        Delay_Required := True;\n+                     end if;\n                   end if;\n \n-               --  Aspects corresponding to attribute definition clauses. We\n-               --  create the matching clause and insert it following the\n-               --  declaration in the tree.\n+               --  Aspects corresponding to attribute definition clauses with\n+               --  the exception of Address which is treated specially.\n \n-               when Aspect_Address        |\n-                    Aspect_Alignment      |\n+               when Aspect_Alignment      |\n                     Aspect_Bit_Order      |\n                     Aspect_Component_Size |\n                     Aspect_External_Tag   |\n@@ -746,70 +777,156 @@ package body Sem_Ch13 is\n                     Aspect_Stream_Size    |\n                     Aspect_Value_Size     =>\n \n-                  Ritem :=\n+                  --  Preanalyze the expression with the appropriate type\n+\n+                  case A_Id is\n+                     when Aspect_Bit_Order    =>\n+                        T := RTE (RE_Bit_Order);\n+                     when Aspect_External_Tag =>\n+                        T := Standard_String;\n+                     when Aspect_Storage_Pool =>\n+                        T := Class_Wide_Type (RTE (RE_Root_Storage_Pool));\n+                     when others              =>\n+                        T := Any_Integer;\n+                  end case;\n+\n+                  Preanalyze_Spec_Expression (Expr, T);\n+\n+                  --  Construct the attribute definition clause\n+\n+                  Aitem :=\n                     Make_Attribute_Definition_Clause (Sloc (Aspect),\n-                      Name       => New_Occurrence_Of (E, Sloc (Id)),\n+                      Name       => Ent,\n                       Chars      => Chars (Id),\n                       Expression => Relocate_Node (Expr));\n \n+                  --  We do not need a delay if we have a static expression\n+\n+                  if Is_OK_Static_Expression (Expression (Aitem)) then\n+                     Delay_Required := False;\n+\n+                  --  Here a delay is required\n+\n+                  else\n+                     Delay_Required := True;\n+                  end if;\n+\n+               --  Address aspect, treated specially because we have some\n+               --  strange problem in the back end if we try to delay ???\n+\n+               when Aspect_Address =>\n+\n+                  --  Construct the attribute definition clause\n+\n+                  Aitem :=\n+                    Make_Attribute_Definition_Clause (Sloc (Aspect),\n+                      Name       => Ent,\n+                      Chars      => Chars (Id),\n+                      Expression => Relocate_Node (Expr));\n+\n+                  --  If -gnatd.A is set, do the delay if needed (this is\n+                  --  so we can debug the relevant problem).\n+\n+                  if Debug_Flag_Dot_AA then\n+                     Preanalyze_Spec_Expression\n+                       (Expression (Aitem), RTE (RE_Address));\n+\n+                     if Is_OK_Static_Expression (Expression (Aitem)) then\n+                        Delay_Required := False;\n+                     else\n+                        Delay_Required := True;\n+                     end if;\n+\n+                  --  Here if -gnatd.A not set, never do the delay\n+\n+                  else\n+                     Delay_Required := False;\n+                  end if;\n+\n                --  Aspects corresponding to pragmas with two arguments, where\n                --  the first argument is a local name referring to the entity,\n                --  and the second argument is the aspect definition expression.\n \n                when Aspect_Suppress   |\n                     Aspect_Unsuppress =>\n \n-                  Ritem :=\n+                  --  Construct the pragma\n+\n+                  Aitem :=\n                     Make_Pragma (Sloc (Aspect),\n                       Pragma_Argument_Associations => New_List (\n                         New_Occurrence_Of (E, Sloc (Expr)),\n                         Relocate_Node (Expr)),\n                       Pragma_Identifier            =>\n-                         Make_Identifier (Sloc (Id), Chars (Id)));\n+                      Make_Identifier (Sloc (Id), Chars (Id)));\n+\n+                  --  We don't have to play the delay game here, since the only\n+                  --  values are check names which don't get analyzed anyway.\n+\n+                  Delay_Required := False;\n \n                --  Aspects corresponding to pragmas with two arguments, where\n                --  the second argument is a local name referring to the entity,\n                --  and the first argument is the aspect definition expression.\n \n                when Aspect_Warnings =>\n \n-                  Ritem :=\n+                  --  Construct the pragma\n+\n+                  Aitem :=\n                     Make_Pragma (Sloc (Aspect),\n                       Pragma_Argument_Associations => New_List (\n                         Relocate_Node (Expr),\n                         New_Occurrence_Of (E, Sloc (Expr))),\n                       Pragma_Identifier            =>\n                          Make_Identifier (Sloc (Id), Chars (Id)));\n \n+                  --  We don't have to play the delay game here, since the only\n+                  --  values are check names which don't get analyzed anyway.\n+\n+                  Delay_Required := False;\n+\n                --  Aspect Post corresponds to pragma Postcondition with single\n                --  argument that is the expression (we never give a message\n-               --  argument. This is inserted right after the declaration, to\n+               --  argument. This is inserted right after the declaration,\n                --  to get the required pragma placement.\n \n                when Aspect_Post =>\n \n-                  Insert_After (N,\n+                  --  Construct the pragma\n+\n+                  Aitem :=\n                     Make_Pragma (Sloc (Expr),\n                       Pragma_Argument_Associations => New_List (\n                         Relocate_Node (Expr)),\n                       Pragma_Identifier            =>\n-                         Make_Identifier (Sloc (Id), Name_Postcondition)));\n-                  goto Continue;\n+                      Make_Identifier (Sloc (Id), Name_Postcondition));\n+\n+                  --  We don't have to play the delay game here. The required\n+                  --  delay in this case is already implemented by the pragma.\n+\n+                  Delay_Required := False;\n \n                --  Aspect Pre corresponds to pragma Precondition with single\n                --  argument that is the expression (we never give a message\n-               --  argument. This is inserted right after the declaration, to\n-               --  get the required pragma placement.\n+               --  argument). This is inserted right after the declaration,\n+               --  to get the required pragma placement.\n \n                when Aspect_Pre =>\n \n-                  Insert_After (N,\n+                  --  Construct the pragma\n+\n+                  Aitem :=\n                     Make_Pragma (Sloc (Expr),\n                       Pragma_Argument_Associations => New_List (\n                         Relocate_Node (Expr)),\n                       Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Precondition)));\n-                  goto Continue;\n+                        Make_Identifier (Sloc (Id), Name_Precondition));\n+\n+                  --  We don't have to play the delay game here. The required\n+                  --  delay in this case is already implemented by the pragma.\n+\n+                  Delay_Required := False;\n \n                --  Aspects currently unimplemented\n \n@@ -820,9 +937,36 @@ package body Sem_Ch13 is\n                   goto Continue;\n             end case;\n \n-            Set_From_Aspect_Specification (Ritem);\n-            Insert_After (Ins_Node, Ritem);\n-            Ins_Node := Ritem;\n+            Set_From_Aspect_Specification (Aitem, True);\n+\n+            --  If a delay is required, we delay the freeze (not much point in\n+            --  delaying the aspect if we don't delay the freeze!). The pragma\n+            --  or clause is then attached to the aspect specification which\n+            --  is placed in the rep item list.\n+\n+            if Delay_Required then\n+               Ensure_Freeze_Node (E);\n+               Set_Is_Delayed_Aspect (Aitem);\n+               Set_Has_Delayed_Aspects (E);\n+               Set_Aspect_Rep_Item (Aspect, Aitem);\n+               Record_Rep_Item (E, Aspect);\n+\n+            --  If no delay required, insert the pragma/clause in the tree\n+\n+            else\n+               --  For Pre/Post cases, insert immediately after the entity\n+               --  declaration, since that is the required pragma placement.\n+\n+               if A_Id = Aspect_Pre or else A_Id = Aspect_Post then\n+                  Insert_After (N, Aitem);\n+\n+               --  For all other cases, insert in sequence\n+\n+               else\n+                  Insert_After (Ins_Node, Aitem);\n+                  Ins_Node := Aitem;\n+               end if;\n+            end if;\n          end;\n \n          <<Continue>>\n@@ -1043,9 +1187,7 @@ package body Sem_Ch13 is\n       ----------------------\n \n       function Duplicate_Clause return Boolean is\n-         A   : constant Node_Id :=\n-                 Get_Attribute_Definition_Clause\n-                   (U_Ent, Get_Attribute_Id (Chars (N)));\n+         A : Node_Id;\n \n       begin\n          --  Nothing to do if this attribute definition clause comes from an\n@@ -1057,8 +1199,10 @@ package body Sem_Ch13 is\n             return False;\n          end if;\n \n-         --  Otherwise current pragma may duplicate previous pragma or a\n-         --  previously given aspect specification for the same pragma.\n+         --  Otherwise current clause may duplicate previous clause or a\n+         --  previously given aspect specification for the same aspect.\n+\n+         A := Get_Rep_Item_For_Entity (U_Ent, Chars (N));\n \n          if Present (A) then\n             if Entity (A) = U_Ent then\n@@ -1572,12 +1716,11 @@ package body Sem_Ch13 is\n             elsif Csize /= No_Uint then\n                Check_Size (Expr, Ctyp, Csize, Biased);\n \n-               --  For the biased case, build a declaration for a subtype\n-               --  that will be used to represent the biased subtype that\n-               --  reflects the biased representation of components. We need\n-               --  this subtype to get proper conversions on referencing\n-               --  elements of the array. Note that component size clauses\n-               --  are ignored in VM mode.\n+               --  For the biased case, build a declaration for a subtype that\n+               --  will be used to represent the biased subtype that reflects\n+               --  the biased representation of components. We need the subtype\n+               --  to get proper conversions on referencing elements of the\n+               --  array. Note: component size clauses are ignored in VM mode.\n \n                if VM_Target = No_VM then\n                   if Biased then\n@@ -4879,6 +5022,17 @@ package body Sem_Ch13 is\n    --  Start of processing for Rep_Item_Too_Late\n \n    begin\n+      --  If this is from an aspect that was delayed till the freeze point,\n+      --  then we skip this check entirely, since it is not required and\n+      --  furthermore can generate false errors. Also we don't need to chain\n+      --  the item into the rep item chain in that case, it is already there!\n+\n+      if Nkind_In (N, N_Attribute_Definition_Clause, N_Pragma)\n+        and then Is_Delayed_Aspect (N)\n+      then\n+         return False;\n+      end if;\n+\n       --  First make sure entity is not frozen (RM 13.1(9)). Exclude imported\n       --  types, which may be frozen if they appear in a representation clause\n       --  for a local type."}, {"sha": "b00d270a4e1301c68baa5c5c272a8494cb19700d", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -159,6 +159,11 @@ package Sem_Ch13 is\n    --  the case of a private or incomplete type. The protocol is to first\n    --  check for Rep_Item_Too_Early using the initial entity, then take the\n    --  underlying type, then call Rep_Item_Too_Late on the result.\n+   --\n+   --  Note: Calls to Rep_Item_Too_Late are ignored for the case of attribute\n+   --  definition clauses which have From_Aspect_Specification set. This is\n+   --  because such clauses are linked on to the Rep_Item chain in procedure\n+   --  Sem_Ch13.Analyze_Aspect_Specifications. See that procedure for details.\n \n    function Same_Representation (Typ1, Typ2 : Entity_Id) return Boolean;\n    --  Given two types, where the two types are related by possible derivation,"}, {"sha": "954833e9b5fe554f9eb0f200556a8ecfae1fa4f0", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -1619,7 +1619,6 @@ package body Sem_Ch3 is\n    procedure Analyze_Component_Declaration (N : Node_Id) is\n       Id : constant Entity_Id := Defining_Identifier (N);\n       E  : constant Node_Id   := Expression (N);\n-      AS : constant List_Id   := Aspect_Specifications (N);\n       T  : Entity_Id;\n       P  : Entity_Id;\n \n@@ -1946,7 +1945,7 @@ package body Sem_Ch3 is\n       end if;\n \n       Set_Original_Record_Component (Id, Id);\n-      Analyze_Aspect_Specifications (N, Id, AS);\n+      Analyze_Aspect_Specifications (N, Id, Aspect_Specifications (N));\n    end Analyze_Component_Declaration;\n \n    --------------------------\n@@ -2079,7 +2078,6 @@ package body Sem_Ch3 is\n    procedure Analyze_Full_Type_Declaration (N : Node_Id) is\n       Def    : constant Node_Id   := Type_Definition (N);\n       Def_Id : constant Entity_Id := Defining_Identifier (N);\n-      AS     : constant List_Id   := Aspect_Specifications (N);\n       T      : Entity_Id;\n       Prev   : Entity_Id;\n \n@@ -2381,7 +2379,8 @@ package body Sem_Ch3 is\n       Set_Optimize_Alignment_Flags (Def_Id);\n       Check_Eliminated (Def_Id);\n \n-      <<Leave>> Analyze_Aspect_Specifications (N, Def_Id, AS);\n+      <<Leave>>\n+         Analyze_Aspect_Specifications (N, Def_Id, Aspect_Specifications (N));\n    end Analyze_Full_Type_Declaration;\n \n    ----------------------------------\n@@ -2644,7 +2643,6 @@ package body Sem_Ch3 is\n    procedure Analyze_Object_Declaration (N : Node_Id) is\n       Loc   : constant Source_Ptr := Sloc (N);\n       Id    : constant Entity_Id  := Defining_Identifier (N);\n-      AS    : constant List_Id    := Aspect_Specifications (N);\n       T     : Entity_Id;\n       Act_T : Entity_Id;\n \n@@ -3530,7 +3528,8 @@ package body Sem_Ch3 is\n          Check_Restriction (No_Local_Timing_Events, N);\n       end if;\n \n-      <<Leave>> Analyze_Aspect_Specifications (N, Id, AS);\n+      <<Leave>>\n+         Analyze_Aspect_Specifications (N, Id, Aspect_Specifications (N));\n    end Analyze_Object_Declaration;\n \n    ---------------------------\n@@ -3553,7 +3552,6 @@ package body Sem_Ch3 is\n    procedure Analyze_Private_Extension_Declaration (N : Node_Id) is\n       T           : constant Entity_Id := Defining_Identifier (N);\n       Indic       : constant Node_Id   := Subtype_Indication (N);\n-      AS          : constant List_Id   := Aspect_Specifications (N);\n       Parent_Type : Entity_Id;\n       Parent_Base : Entity_Id;\n \n@@ -3740,7 +3738,8 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n-      <<Leave>> Analyze_Aspect_Specifications (N, T, AS);\n+      <<Leave>>\n+         Analyze_Aspect_Specifications (N, T, Aspect_Specifications (N));\n    end Analyze_Private_Extension_Declaration;\n \n    ---------------------------------\n@@ -3752,7 +3751,6 @@ package body Sem_Ch3 is\n       Skip : Boolean := False)\n    is\n       Id       : constant Entity_Id := Defining_Identifier (N);\n-      AS       : constant List_Id   := Aspect_Specifications (N);\n       T        : Entity_Id;\n       R_Checks : Check_Result;\n \n@@ -4152,10 +4150,19 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  Make sure that generic actual types are properly frozen\n+\n+      if Expander_Active\n+        and then Is_Generic_Actual_Type (Id)\n+      then\n+         Insert_Actions (N, Freeze_Entity (Id, N));\n+      end if;\n+\n       Set_Optimize_Alignment_Flags (Id);\n       Check_Eliminated (Id);\n \n-      <<Leave>> Analyze_Aspect_Specifications (N, Id, AS);\n+      <<Leave>>\n+         Analyze_Aspect_Specifications (N, Id, Aspect_Specifications (N));\n    end Analyze_Subtype_Declaration;\n \n    --------------------------------\n@@ -14345,7 +14352,7 @@ package body Sem_Ch3 is\n          then\n             null;\n          else\n-            Insert_Actions (Obj_Def, Freeze_Entity (T, Sloc (P)));\n+            Insert_Actions (Obj_Def, Freeze_Entity (T, P));\n          end if;\n \n       --  Ada 2005 AI-406: the object definition in an object declaration"}, {"sha": "2bff2e2bbd99c3c22db70d7ab99c2664660128aa", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -227,6 +227,8 @@ package Sem_Ch3 is\n    --  In_Default_Expression flag. See the documentation section entitled\n    --  \"Handling of Default and Per-Object Expressions\" in sem.ads for full\n    --  details. N is the expression to be analyzed, T is the expected type.\n+   --  This mechanism is also used for aspect specifications that have an\n+   --  expression parameter that needs similar preanalysis.\n \n    procedure Process_Full_View (N : Node_Id; Full_T, Priv_T : Entity_Id);\n    --  Process some semantic actions when the full view of a private type is"}, {"sha": "f74d24e3b061f3888c354300b4c701d8a8a6efae", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -1841,7 +1841,7 @@ package body Sem_Ch5 is\n                   --  declared \"within\" must be frozen explicitly.\n \n                   declare\n-                     Flist : constant List_Id := Freeze_Entity (Id, Sloc (N));\n+                     Flist : constant List_Id := Freeze_Entity (Id, N);\n                   begin\n                      if Is_Non_Empty_List (Flist) then\n                         Insert_Actions (N, Flist);"}, {"sha": "4a2d3df4e367aec723427eb0bc1a17c88d1ff319", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -354,7 +354,6 @@ package body Sem_Ch6 is\n       Designator : constant Entity_Id :=\n                      Analyze_Subprogram_Specification (Specification (N));\n       Scop       : constant Entity_Id := Current_Scope;\n-      AS         : constant List_Id   := Aspect_Specifications (N);\n \n    begin\n       Generate_Definition (Designator);\n@@ -384,7 +383,7 @@ package body Sem_Ch6 is\n \n       Generate_Reference_To_Formals (Designator);\n       Check_Eliminated (Designator);\n-      Analyze_Aspect_Specifications (N, Designator, AS);\n+      Analyze_Aspect_Specifications (N, Designator, Aspect_Specifications (N));\n    end Analyze_Abstract_Subprogram_Declaration;\n \n    ----------------------------------------\n@@ -2168,7 +2167,7 @@ package body Sem_Ch6 is\n             --  why, to be investigated further???\n \n             Set_Has_Delayed_Freeze (Spec_Id);\n-            Insert_Actions (N, Freeze_Entity (Spec_Id, Loc));\n+            Insert_Actions (N, Freeze_Entity (Spec_Id, N));\n          end if;\n       end if;\n \n@@ -2700,7 +2699,6 @@ package body Sem_Ch6 is\n \n    procedure Analyze_Subprogram_Declaration (N : Node_Id) is\n       Loc        : constant Source_Ptr := Sloc (N);\n-      AS         : constant List_Id    := Aspect_Specifications (N);\n       Scop       : constant Entity_Id  := Current_Scope;\n       Designator : Entity_Id;\n       Form       : Node_Id;\n@@ -2710,9 +2708,9 @@ package body Sem_Ch6 is\n \n    begin\n       --  For a null procedure, capture the profile before analysis, for\n-      --  expansion at the freeze point and at each point of call.\n-      --  The body will only be used if the procedure has preconditions.\n-      --  In that case the body is analyzed at the freeze point.\n+      --  expansion at the freeze point and at each point of call. The body\n+      --  will only be used if the procedure has preconditions. In that case\n+      --  the body is analyzed at the freeze point.\n \n       if Nkind (Specification (N)) = N_Procedure_Specification\n         and then Null_Present (Specification (N))\n@@ -2897,7 +2895,7 @@ package body Sem_Ch6 is\n          Write_Eol;\n       end if;\n \n-      Analyze_Aspect_Specifications (N, Designator, AS);\n+      Analyze_Aspect_Specifications (N, Designator, Aspect_Specifications (N));\n    end Analyze_Subprogram_Declaration;\n \n    --------------------------------------\n@@ -8825,7 +8823,6 @@ package body Sem_Ch6 is\n    -------------------------\n \n    procedure Set_Actual_Subtypes (N : Node_Id; Subp : Entity_Id) is\n-      Loc            : constant Source_Ptr := Sloc (N);\n       Decl           : Node_Id;\n       Formal         : Entity_Id;\n       T              : Entity_Id;\n@@ -8939,7 +8936,7 @@ package body Sem_Ch6 is\n \n             if Present (First_Stmt) then\n                Insert_List_Before_And_Analyze (First_Stmt,\n-                 Freeze_Entity (Defining_Identifier (Decl), Loc));\n+                 Freeze_Entity (Defining_Identifier (Decl), N));\n             end if;\n \n             if Nkind (N) = N_Accept_Statement"}, {"sha": "e3555525118315e83032ea8352434f89f217020c", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -751,7 +751,6 @@ package body Sem_Ch7 is\n \n    procedure Analyze_Package_Declaration (N : Node_Id) is\n       Id : constant Node_Id := Defining_Entity (N);\n-      AS : constant List_Id := Aspect_Specifications (N);\n \n       PF : Boolean;\n       --  True when in the context of a declared pure library unit\n@@ -846,7 +845,8 @@ package body Sem_Ch7 is\n          Write_Eol;\n       end if;\n \n-      <<Leave>> Analyze_Aspect_Specifications (N, Id, AS);\n+      <<Leave>>\n+         Analyze_Aspect_Specifications (N, Id, Aspect_Specifications (N));\n    end Analyze_Package_Declaration;\n \n    -----------------------------------\n@@ -1417,7 +1417,6 @@ package body Sem_Ch7 is\n    procedure Analyze_Private_Type_Declaration (N : Node_Id) is\n       PF : constant Boolean   := Is_Pure (Enclosing_Lib_Unit_Entity);\n       Id : constant Entity_Id := Defining_Identifier (N);\n-      AS : constant List_Id   := Aspect_Specifications (N);\n \n    begin\n       Generate_Definition (Id);\n@@ -1432,7 +1431,7 @@ package body Sem_Ch7 is\n \n       New_Private_Type (N, Id, N);\n       Set_Depends_On_Private (Id);\n-      Analyze_Aspect_Specifications (N, Id, AS);\n+      Analyze_Aspect_Specifications (N, Id, Aspect_Specifications (N));\n    end Analyze_Private_Type_Declaration;\n \n    ----------------------------------"}, {"sha": "bcf38cd0a851531cdb608f3e1a8e110dff4619f8", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -875,7 +875,6 @@ package body Sem_Ch9 is\n       D_Sdef  : constant Node_Id   := Discrete_Subtype_Definition (N);\n       Def_Id  : constant Entity_Id := Defining_Identifier (N);\n       Formals : constant List_Id   := Parameter_Specifications (N);\n-      AS      : constant List_Id   := Aspect_Specifications (N);\n \n    begin\n       Generate_Definition (Def_Id);\n@@ -907,7 +906,7 @@ package body Sem_Ch9 is\n       end if;\n \n       Generate_Reference_To_Formals (Def_Id);\n-      Analyze_Aspect_Specifications (N, Def_Id, AS);\n+      Analyze_Aspect_Specifications (N, Def_Id, Aspect_Specifications (N));\n    end Analyze_Entry_Declaration;\n \n    ---------------------------------------\n@@ -1132,7 +1131,6 @@ package body Sem_Ch9 is\n \n    procedure Analyze_Protected_Type_Declaration (N : Node_Id) is\n       Def_Id : constant Entity_Id := Defining_Identifier (N);\n-      AS     : constant List_Id   := Aspect_Specifications (N);\n       E      : Entity_Id;\n       T      : Entity_Id;\n \n@@ -1260,7 +1258,8 @@ package body Sem_Ch9 is\n          end if;\n       end if;\n \n-      <<Leave>> Analyze_Aspect_Specifications (N, Def_Id, AS);\n+      <<Leave>>\n+         Analyze_Aspect_Specifications (N, Def_Id, Aspect_Specifications (N));\n    end Analyze_Protected_Type_Declaration;\n \n    ---------------------\n@@ -1665,7 +1664,6 @@ package body Sem_Ch9 is\n    procedure Analyze_Single_Protected_Declaration (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Id     : constant Node_Id    := Defining_Identifier (N);\n-      AS     : constant List_Id    := Aspect_Specifications (N);\n       T      : Entity_Id;\n       T_Decl : Node_Id;\n       O_Decl : Node_Id;\n@@ -1713,7 +1711,7 @@ package body Sem_Ch9 is\n       --  disastrous result.\n \n       Analyze_Protected_Type_Declaration (N);\n-      Analyze_Aspect_Specifications (N, Id, AS);\n+      Analyze_Aspect_Specifications (N, Id, Aspect_Specifications (N));\n    end Analyze_Single_Protected_Declaration;\n \n    -------------------------------------\n@@ -1723,7 +1721,6 @@ package body Sem_Ch9 is\n    procedure Analyze_Single_Task_Declaration (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Id     : constant Node_Id    := Defining_Identifier (N);\n-      AS     : constant List_Id    := Aspect_Specifications (N);\n       T      : Entity_Id;\n       T_Decl : Node_Id;\n       O_Decl : Node_Id;\n@@ -1779,7 +1776,7 @@ package body Sem_Ch9 is\n       --  disastrous result.\n \n       Analyze_Task_Type_Declaration (N);\n-      Analyze_Aspect_Specifications (N, Id, AS);\n+      Analyze_Aspect_Specifications (N, Id, Aspect_Specifications (N));\n    end Analyze_Single_Task_Declaration;\n \n    -----------------------\n@@ -1952,7 +1949,6 @@ package body Sem_Ch9 is\n \n    procedure Analyze_Task_Type_Declaration (N : Node_Id) is\n       Def_Id : constant Entity_Id := Defining_Identifier (N);\n-      AS     : constant List_Id   := Aspect_Specifications (N);\n       T      : Entity_Id;\n \n    begin\n@@ -2051,7 +2047,7 @@ package body Sem_Ch9 is\n          end if;\n       end if;\n \n-      Analyze_Aspect_Specifications (N, Def_Id, AS);\n+      Analyze_Aspect_Specifications (N, Def_Id, Aspect_Specifications (N));\n    end Analyze_Task_Type_Declaration;\n \n    -----------------------------------"}, {"sha": "c7414b94d9a4024aae20104d77f40c7768323915", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 14, "deletions": 41, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -178,14 +178,6 @@ package body Sem_Prag is\n    --  original one, following the renaming chain) is returned. Otherwise the\n    --  entity is returned unchanged. Should be in Einfo???\n \n-   function Get_Pragma_Arg (Arg : Node_Id) return Node_Id;\n-   --  All the routines that check pragma arguments take either a pragma\n-   --  argument association (in which case the expression of the argument\n-   --  association is checked), or the expression directly. The function\n-   --  Get_Pragma_Arg is a utility used to deal with these two cases. If Arg\n-   --  is a pragma argument association node, then its expression is returned,\n-   --  otherwise Arg is returned unchanged.\n-\n    procedure rv;\n    --  This is a dummy function called by the processing for pragma Reviewable.\n    --  It is there for assisting front end debugging. By placing a Reviewable\n@@ -416,8 +408,9 @@ package body Sem_Prag is\n \n       procedure Check_Duplicate_Pragma (E : Entity_Id);\n       --  Check if a pragma of the same name as the current pragma is already\n-      --  chained as a rep pragma to the given entity. if so give a message\n+      --  chained as a rep pragma to the given entity. If so give a message\n       --  about the duplicate, and then raise Pragma_Exit so does not return.\n+      --  Also checks for delayed aspect specification node in the chain.\n \n       procedure Check_Duplicated_Export_Name (Nam : Node_Id);\n       --  Nam is an N_String_Literal node containing the external name set by\n@@ -1232,8 +1225,7 @@ package body Sem_Prag is\n       ----------------------------\n \n       procedure Check_Duplicate_Pragma (E : Entity_Id) is\n-         P   : constant Node_Id := Get_Rep_Pragma (E, Pragma_Name (N));\n-         Arg : Node_Id;\n+         P : Node_Id;\n \n       begin\n          --  Nothing to do if this pragma comes from an aspect specification,\n@@ -1247,27 +1239,21 @@ package body Sem_Prag is\n          --  Otherwise current pragma may duplicate previous pragma or a\n          --  previously given aspect specification for the same pragma.\n \n-         if Present (P) then\n-\n-            --  Make sure pragma is for this entity, and not for some parent\n-            --  entity in the case of a derived type.\n+         P := Get_Rep_Item_For_Entity (E, Pragma_Name (N));\n \n-            Arg := Get_Pragma_Arg (First (Pragma_Argument_Associations (P)));\n+         if Present (P) then\n+            Error_Msg_Name_1 := Pragma_Name (N);\n+            Error_Msg_Sloc := Sloc (P);\n \n-            if Nkind (Arg) = N_Identifier\n-              and then Entity (Arg) = E\n+            if Nkind (P) = N_Aspect_Specification\n+              or else From_Aspect_Specification (P)\n             then\n-               Error_Msg_Name_1 := Pname;\n-               Error_Msg_Sloc := Sloc (P);\n-\n-               if From_Aspect_Specification (P) then\n-                  Error_Msg_NE (\"aspect% for & previously specified#\", N, E);\n-               else\n-                  Error_Msg_NE (\"pragma% for & duplicates pragma#\", N, E);\n-               end if;\n-\n-               raise Pragma_Exit;\n+               Error_Msg_NE (\"aspect% for & previously specified#\", N, E);\n+            else\n+               Error_Msg_NE (\"pragma% for & duplicates pragma#\", N, E);\n             end if;\n+\n+            raise Pragma_Exit;\n          end if;\n       end Check_Duplicate_Pragma;\n \n@@ -13358,19 +13344,6 @@ package body Sem_Prag is\n       return Result;\n    end Get_Base_Subprogram;\n \n-   --------------------\n-   -- Get_Pragma_Arg --\n-   --------------------\n-\n-   function Get_Pragma_Arg (Arg : Node_Id) return Node_Id is\n-   begin\n-      if Nkind (Arg) = N_Pragma_Argument_Association then\n-         return Expression (Arg);\n-      else\n-         return Arg;\n-      end if;\n-   end Get_Pragma_Arg;\n-\n    ----------------\n    -- Initialize --\n    ----------------"}, {"sha": "5a1448468212913d713de1dcab5de85150b4872b", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 56, "deletions": 20, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -32,8 +32,7 @@\n pragma Style_Checks (All_Checks);\n --  No subprogram ordering check, due to logical grouping\n \n-with Aspects; use Aspects;\n-with Atree;   use Atree;\n+with Atree; use Atree;\n \n package body Sinfo is\n \n@@ -264,6 +263,14 @@ package body Sinfo is\n       return Flag11 (N);\n    end Aspect_Cancel;\n \n+   function Aspect_Rep_Item\n+      (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification);\n+      return Node2 (N);\n+   end Aspect_Rep_Item;\n+\n    function Assignment_OK\n       (N : Node_Id) return Boolean is\n    begin\n@@ -1048,8 +1055,9 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind in N_Has_Entity\n-        or else NT (N).Nkind = N_Freeze_Entity\n-        or else NT (N).Nkind = N_Attribute_Definition_Clause);\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Attribute_Definition_Clause\n+        or else NT (N).Nkind = N_Freeze_Entity);\n       return Node4 (N);\n    end Entity;\n \n@@ -1400,13 +1408,6 @@ package body Sinfo is\n       return Node2 (N);\n    end Handler_List_Entry;\n \n-   function Has_Aspect_Specifications\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (Permits_Aspect_Specifications (N));\n-      return Flag3 (N);\n-   end Has_Aspect_Specifications;\n-\n    function Has_Created_Identifier\n       (N : Node_Id) return Boolean is\n    begin\n@@ -1690,6 +1691,15 @@ package body Sinfo is\n       return Flag16 (N);\n    end Is_Controlling_Actual;\n \n+   function Is_Delayed_Aspect\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Attribute_Definition_Clause\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag14 (N);\n+   end Is_Delayed_Aspect;\n+\n    function Is_Dynamic_Coextension\n       (N : Node_Id) return Boolean is\n    begin\n@@ -2116,6 +2126,7 @@ package body Sinfo is\n       (N : Node_Id) return Node_Id is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n         or else NT (N).Nkind = N_Attribute_Definition_Clause\n         or else NT (N).Nkind = N_Enumeration_Representation_Clause\n         or else NT (N).Nkind = N_Pragma\n@@ -3212,6 +3223,14 @@ package body Sinfo is\n       Set_Flag11 (N, Val);\n    end Set_Aspect_Cancel;\n \n+   procedure Set_Aspect_Rep_Item\n+      (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification);\n+      Set_Node2 (N, Val);\n+   end Set_Aspect_Rep_Item;\n+\n    procedure Set_Assignment_OK\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -3996,8 +4015,9 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind in N_Has_Entity\n-        or else NT (N).Nkind = N_Freeze_Entity\n-        or else NT (N).Nkind = N_Attribute_Definition_Clause);\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Attribute_Definition_Clause\n+        or else NT (N).Nkind = N_Freeze_Entity);\n       Set_Node4 (N, Val); -- semantic field, no parent set\n    end Set_Entity;\n \n@@ -4339,13 +4359,6 @@ package body Sinfo is\n       Set_Node2 (N, Val);\n    end Set_Handler_List_Entry;\n \n-   procedure Set_Has_Aspect_Specifications\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (Permits_Aspect_Specifications (N));\n-      Set_Flag3 (N, Val);\n-   end Set_Has_Aspect_Specifications;\n-\n    procedure Set_Has_Created_Identifier\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -4630,6 +4643,15 @@ package body Sinfo is\n       Set_Flag16 (N, Val);\n    end Set_Is_Controlling_Actual;\n \n+   procedure Set_Is_Delayed_Aspect\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Attribute_Definition_Clause\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag14 (N, Val);\n+   end Set_Is_Delayed_Aspect;\n+\n    procedure Set_Is_Dynamic_Coextension\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -5056,6 +5078,7 @@ package body Sinfo is\n       (N : Node_Id; Val : Node_Id) is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n         or else NT (N).Nkind = N_Attribute_Definition_Clause\n         or else NT (N).Nkind = N_Enumeration_Representation_Clause\n         or else NT (N).Nkind = N_Pragma\n@@ -5980,6 +6003,19 @@ package body Sinfo is\n       end if;\n    end End_Location;\n \n+   --------------------\n+   -- Get_Pragma_Arg --\n+   --------------------\n+\n+   function Get_Pragma_Arg (Arg : Node_Id) return Node_Id is\n+   begin\n+      if Nkind (Arg) = N_Pragma_Argument_Association then\n+         return Expression (Arg);\n+      else\n+         return Arg;\n+      end if;\n+   end Get_Pragma_Arg;\n+\n    ----------------------\n    -- Set_End_Location --\n    ----------------------"}, {"sha": "ed14a866334fa566b0609a6aa6d599f95dc89861", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 59, "deletions": 99, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -595,6 +595,10 @@ package Sinfo is\n    --    aspect (i.e. turn if off), the generated pragma has the Aspect_Cancel\n    --    flag set to indicate that the pragma operates in the opposite sense.\n \n+   --  Aspect_Rep_Item (Node2-Sem)\n+   --    Present in N_Aspect_Specification nodes. Points to the corresponding\n+   --    pragma/attribute definition node used to process the aspect.\n+\n    --  Assignment_OK (Flag15-Sem)\n    --    This flag is set in a subexpression node for an object, indicating\n    --    that the associated object can be modified, even if this would not\n@@ -1230,6 +1234,11 @@ package Sinfo is\n    --    operand is of the component type of the result. Used in resolving\n    --    concatenation nodes in instances.\n \n+   --  Is_Delayed_Aspect (Flag14-Sem)\n+   --    Present in N_Pragma and N_Attribute_Definition_Clause nodes which\n+   --    come from aspect specifications, where the evaluation of the aspect\n+   --    must be delayed to the freeze point.\n+\n    --  Is_Controlling_Actual (Flag16-Sem)\n    --    This flag is set on in an expression that is a controlling argument in\n    --    a dispatching call. It is off in all other cases. See Sem_Disp for\n@@ -1456,9 +1465,10 @@ package Sinfo is\n    --      details).\n \n    --  Next_Rep_Item (Node5-Sem)\n-   --    Present in pragma nodes and attribute definition nodes. Used to link\n-   --    representation items that apply to an entity. See description of\n-   --    First_Rep_Item field in Einfo for full details.\n+   --    Present in pragma nodes, attribute definition nodes, enumeration rep\n+   --    clauses, record rep clauses, aspect specification nodes. Used to link\n+   --    representation items that apply to an entity. See full description of\n+   --    First_Rep_Item field in Einfo for further details.\n \n    --  Next_Use_Clause (Node3-Sem)\n    --    While use clauses are active during semantic processing, they are\n@@ -2015,6 +2025,7 @@ package Sinfo is\n       --  Next_Rep_Item (Node5-Sem)\n       --  Pragma_Enabled (Flag5-Sem)\n       --  From_Aspect_Specification (Flag13-Sem)\n+      --  Is_Delayed_Aspect (Flag14-Sem)\n       --  Import_Interface_Present (Flag16-Sem)\n       --  Aspect_Cancel (Flag11-Sem)\n \n@@ -2123,9 +2134,6 @@ package Sinfo is\n       --  Discriminant_Specifications (List4) (set to No_List if none)\n       --  Type_Definition (Node3)\n       --  Discr_Check_Funcs_Built (Flag11-Sem)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       ----------------------------\n       -- 3.2.1  Type Definition --\n@@ -2154,9 +2162,6 @@ package Sinfo is\n       --  Subtype_Indication (Node5)\n       --  Generic_Parent_Type (Node4-Sem) (set for an actual derived type).\n       --  Exception_Junk (Flag8-Sem)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       -------------------------------\n       -- 3.2.2  Subtype Indication --\n@@ -2287,9 +2292,6 @@ package Sinfo is\n       --  Exception_Junk (Flag8-Sem)\n       --  Is_Subprogram_Descriptor (Flag16-Sem)\n       --  Has_Init_Expression (Flag14)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       -------------------------------------\n       -- 3.3.1  Defining Identifier List --\n@@ -2862,9 +2864,6 @@ package Sinfo is\n       --  Expression (Node3) (set to Empty if no default expression)\n       --  More_Ids (Flag5) (set to False if no more identifiers in list)\n       --  Prev_Ids (Flag6) (set to False if no previous identifiers in list)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       -------------------------\n       -- 3.8.1  Variant Part --\n@@ -4218,9 +4217,6 @@ package Sinfo is\n       --  Body_To_Inline (Node3-Sem)\n       --  Corresponding_Body (Node5-Sem)\n       --  Parent_Spec (Node4-Sem)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       ------------------------------------------\n       -- 6.1  Abstract Subprogram Declaration --\n@@ -4232,9 +4228,6 @@ package Sinfo is\n       --  N_Abstract_Subprogram_Declaration\n       --  Sloc points to ABSTRACT\n       --  Specification (Node1)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       -----------------------------------\n       -- 6.1  Subprogram Specification --\n@@ -4658,9 +4651,6 @@ package Sinfo is\n       --  Corresponding_Body (Node5-Sem)\n       --  Parent_Spec (Node4-Sem)\n       --  Activation_Chain_Entity (Node3-Sem)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       --------------------------------\n       -- 7.1  Package Specification --\n@@ -4727,9 +4717,6 @@ package Sinfo is\n       --  Abstract_Present (Flag4)\n       --  Tagged_Present (Flag15)\n       --  Limited_Present (Flag17)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       ----------------------------------------\n       -- 7.4  Private Extension Declaration --\n@@ -4755,9 +4742,6 @@ package Sinfo is\n       --  Synchronized_Present (Flag7)\n       --  Subtype_Indication (Node5)\n       --  Interface_List (List2) (set to No_List if none)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       ---------------------\n       -- 8.4  Use Clause --\n@@ -4915,9 +4899,6 @@ package Sinfo is\n       --  Interface_List (List2) (set to No_List if none)\n       --  Task_Definition (Node3) (set to Empty if not present)\n       --  Corresponding_Body (Node5-Sem)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       ----------------------------------\n       -- 9.1  Single Task Declaration --\n@@ -4932,9 +4913,6 @@ package Sinfo is\n       --  Defining_Identifier (Node1)\n       --  Interface_List (List2) (set to No_List if none)\n       --  Task_Definition (Node3) (set to Empty if not present)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       --------------------------\n       -- 9.1  Task Definition --\n@@ -5007,9 +4985,6 @@ package Sinfo is\n       --  Interface_List (List2) (set to No_List if none)\n       --  Protected_Definition (Node3)\n       --  Corresponding_Body (Node5-Sem)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       ---------------------------------------\n       -- 9.4  Single Protected Declaration --\n@@ -5026,9 +5001,6 @@ package Sinfo is\n       --  Defining_Identifier (Node1)\n       --  Interface_List (List2) (set to No_List if none)\n       --  Protected_Definition (Node3)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       -------------------------------\n       -- 9.4  Protected Definition --\n@@ -5111,10 +5083,8 @@ package Sinfo is\n       --  Corresponding_Body (Node5-Sem)\n       --  Must_Override (Flag14) set if overriding indicator present\n       --  Must_Not_Override (Flag15) set if not_overriding indicator present\n-      --  Has_Aspect_Specifications (Flag3)\n \n       --  Note: overriding indicator is an Ada 2005 feature\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       -----------------------------\n       -- 9.5.2  Accept statement --\n@@ -5778,9 +5748,6 @@ package Sinfo is\n       --  Renaming_Exception (Node2-Sem)\n       --  More_Ids (Flag5) (set to False if no more identifiers in list)\n       --  Prev_Ids (Flag6) (set to False if no previous identifiers in list)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       ------------------------------------------\n       -- 11.2  Handled Sequence Of Statements --\n@@ -5929,9 +5896,6 @@ package Sinfo is\n       --  Corresponding_Body (Node5-Sem)\n       --  Generic_Formal_Declarations (List2) from generic formal part\n       --  Parent_Spec (Node4-Sem)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       ---------------------------------------\n       -- 12.1  Generic Package Declaration --\n@@ -5953,9 +5917,6 @@ package Sinfo is\n       --  Generic_Formal_Declarations (List2) from generic formal part\n       --  Parent_Spec (Node4-Sem)\n       --  Activation_Chain_Entity (Node3-Sem)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       -------------------------------\n       -- 12.1  Generic Formal Part --\n@@ -5997,7 +5958,6 @@ package Sinfo is\n       --  Parent_Spec (Node4-Sem)\n       --  Instance_Spec (Node5-Sem)\n       --  ABE_Is_Certain (Flag18-Sem)\n-      --  Has_Aspect_Specifications (Flag3)\n \n       --  N_Procedure_Instantiation\n       --  Sloc points to PROCEDURE\n@@ -6010,7 +5970,6 @@ package Sinfo is\n       --  Must_Override (Flag14) set if overriding indicator present\n       --  Must_Not_Override (Flag15) set if not_overriding indicator present\n       --  ABE_Is_Certain (Flag18-Sem)\n-      --  Has_Aspect_Specifications (Flag3)\n \n       --  N_Function_Instantiation\n       --  Sloc points to FUNCTION\n@@ -6023,10 +5982,8 @@ package Sinfo is\n       --  Must_Override (Flag14) set if overriding indicator present\n       --  Must_Not_Override (Flag15) set if not_overriding indicator present\n       --  ABE_Is_Certain (Flag18-Sem)\n-      --  Has_Aspect_Specifications (Flag3)\n \n       --  Note: overriding indicator is an Ada 2005 feature\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       -------------------------------\n       -- 12.3  Generic Actual Part --\n@@ -6097,9 +6054,6 @@ package Sinfo is\n       --  Default_Expression (Node5) (set to Empty if no default expression)\n       --  More_Ids (Flag5) (set to False if no more identifiers in list)\n       --  Prev_Ids (Flag6) (set to False if no previous identifiers in list)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       -----------------------------------\n       -- 12.5  Formal Type Declaration --\n@@ -6116,9 +6070,6 @@ package Sinfo is\n       --  Discriminant_Specifications (List4) (set to No_List if no\n       --   discriminant part)\n       --  Unknown_Discriminants_Present (Flag13) set if (<>) discriminant\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       ----------------------------------\n       -- 12.5  Formal type definition --\n@@ -6264,13 +6215,10 @@ package Sinfo is\n       --  Specification (Node1)\n       --  Default_Name (Node2) (set to Empty if no subprogram default)\n       --  Box_Present (Flag15)\n-      --  Has_Aspect_Specifications (Flag3)\n \n       --  Note: if no subprogram default is present, then Name is set\n       --  to Empty, and Box_Present is False.\n \n-      --  Note: Aspect_Specification is an Ada 2012 feature\n-\n       --------------------------------------------------\n       -- 12.6  Formal Abstract Subprogram Declaration --\n       --------------------------------------------------\n@@ -6283,13 +6231,10 @@ package Sinfo is\n       --  Specification (Node1)\n       --  Default_Name (Node2) (set to Empty if no subprogram default)\n       --  Box_Present (Flag15)\n-      --  Has_Aspect_Specifications (Flag3)\n \n       --  Note: if no subprogram default is present, then Name is set\n       --  to Empty, and Box_Present is False.\n \n-      --  Note: Aspect_Specification is an Ada 2012 feature\n-\n       ------------------------------\n       -- 12.6  Subprogram Default --\n       ------------------------------\n@@ -6326,9 +6271,6 @@ package Sinfo is\n       --  Box_Present (Flag15)\n       --  Instance_Spec (Node5-Sem)\n       --  ABE_Is_Certain (Flag18-Sem)\n-      --  Has_Aspect_Specifications (Flag3)\n-\n-      --  Note: Aspect_Specification is an Ada 2012 feature\n \n       --------------------------------------\n       -- 12.7  Formal Package Actual Part --\n@@ -6417,6 +6359,7 @@ package Sinfo is\n       --  From_At_Mod (Flag4-Sem)\n       --  Check_Address_Alignment (Flag11-Sem)\n       --  From_Aspect_Specification (Flag13-Sem)\n+      --  Is_Delayed_Aspect (Flag14-Sem)\n       --  Address_Warning_Posted (Flag18-Sem)\n \n       --  Note: if From_Aspect_Specification is set, then Sloc points to the\n@@ -6457,8 +6400,11 @@ package Sinfo is\n       --  N_Aspect_Specification\n       --  Sloc points to aspect identifier\n       --  Identifier (Node1) aspect identifier\n+      --  Aspect_Rep_Item (Node2-Sem)\n       --  Expression (Node3) Aspect_Definition (set to Empty if none)\n+      --  Entity (Node4-Sem) entity to which the aspect applies\n       --  Class_Present (Flag6) Set if 'Class present\n+      --  Next_Rep_Item (Node5-Sem)\n \n       --  Note: Aspect_Specification is an Ada 2012 feature\n \n@@ -7302,10 +7248,10 @@ package Sinfo is\n    --------------------------\n \n    --  The following is the definition of the Node_Kind type. As previously\n-   --  discussed, this is separated off to allow rearrangement of the order\n-   --  to facilitate definition of subtype ranges. The comments show the\n-   --  subtype classes which apply to each set of node kinds. The first\n-   --  entry in the comment characterizes the following list of nodes.\n+   --  discussed, this is separated off to allow rearrangement of the order to\n+   --  facilitate definition of subtype ranges. The comments show the subtype\n+   --  classes which apply to each set of node kinds. The first entry in the\n+   --  comment characterizes the following list of nodes.\n \n    type Node_Kind is (\n       N_Unused_At_Start,\n@@ -7317,7 +7263,6 @@ package Sinfo is\n       N_Enumeration_Representation_Clause,\n       N_Mod_Clause,\n       N_Record_Representation_Clause,\n-      N_Aspect_Specification,\n \n       --  N_Representation_Clause, N_Has_Chars\n \n@@ -7621,6 +7566,7 @@ package Sinfo is\n       N_Abstract_Subprogram_Declaration,\n       N_Access_Definition,\n       N_Access_To_Object_Definition,\n+      N_Aspect_Specification,\n       N_Case_Expression_Alternative,\n       N_Case_Statement_Alternative,\n       N_Compilation_Unit,\n@@ -7747,7 +7693,8 @@ package Sinfo is\n      N_Expanded_Name ..\n      N_Attribute_Reference;\n    --  Nodes that have Entity fields\n-   --  Warning: DOES NOT INCLUDE N_Freeze_Entity!\n+   --  Warning: DOES NOT INCLUDE N_Freeze_Entity, N_Aspect_Specification,\n+   --  or N_Attribute_Definition_Clause.\n \n    subtype N_Has_Etype is Node_Kind range\n      N_Error ..\n@@ -7942,6 +7889,9 @@ package Sinfo is\n    function Aspect_Cancel\n      (N : Node_Id) return Boolean;    -- Flag11\n \n+   function Aspect_Rep_Item\n+     (N : Node_Id) return Node_Id;    -- Node2\n+\n    function Assignment_OK\n      (N : Node_Id) return Boolean;    -- Flag15\n \n@@ -8296,9 +8246,6 @@ package Sinfo is\n    function Handler_List_Entry\n      (N : Node_Id) return Node_Id;    -- Node2\n \n-   function Has_Aspect_Specifications\n-     (N : Node_Id) return Boolean;    -- Flag3\n-\n    function Has_Created_Identifier\n      (N : Node_Id) return Boolean;    -- Flag15\n \n@@ -8395,6 +8342,9 @@ package Sinfo is\n    function Is_Controlling_Actual\n      (N : Node_Id) return Boolean;    -- Flag16\n \n+   function Is_Delayed_Aspect\n+     (N : Node_Id) return Boolean;    -- Flag14\n+\n    function Is_Dynamic_Coextension\n      (N : Node_Id) return Boolean;    -- Flag18\n \n@@ -8881,12 +8831,12 @@ package Sinfo is\n    procedure Set_Array_Aggregate\n      (N : Node_Id; Val : Node_Id);            -- Node3\n \n-   procedure Set_Has_Aspect_Specifications\n-     (N : Node_Id; Val : Boolean := True);    -- Flag3\n-\n    procedure Set_Aspect_Cancel\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n+   procedure Set_Aspect_Rep_Item\n+     (N : Node_Id; Val : Node_Id);            -- Node2\n+\n    procedure Set_Assignment_OK\n      (N : Node_Id; Val : Boolean := True);    -- Flag15\n \n@@ -9334,6 +9284,9 @@ package Sinfo is\n    procedure Set_Is_Controlling_Actual\n      (N : Node_Id; Val : Boolean := True);    -- Flag16\n \n+   procedure Set_Is_Delayed_Aspect\n+     (N : Node_Id; Val : Boolean := True);    -- Flag14\n+\n    procedure Set_Is_Dynamic_Coextension\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n \n@@ -9756,20 +9709,25 @@ package Sinfo is\n    procedure Next_Rep_Item     (N : in out Node_Id);\n    procedure Next_Use_Clause   (N : in out Node_Id);\n \n-   --------------------------------------\n-   -- Logical Access to End_Span Field --\n-   --------------------------------------\n+   -------------------------------------------\n+   -- Miscellaneous Tree Access Subprograms --\n+   -------------------------------------------\n \n    function End_Location (N : Node_Id) return Source_Ptr;\n-   --  N is an N_If_Statement or N_Case_Statement node, and this\n-   --  function returns the location of the IF token in the END IF\n-   --  sequence by translating the value of the End_Span field.\n+   --  N is an N_If_Statement or N_Case_Statement node, and this function\n+   --  returns the location of the IF token in the END IF sequence by\n+   --  translating the value of the End_Span field.\n \n    procedure Set_End_Location (N : Node_Id; S : Source_Ptr);\n-   --  N is an N_If_Statement or N_Case_Statement node. This procedure\n-   --  sets the End_Span field to correspond to the given value S. In\n-   --  other words, End_Span is set to the difference between S and\n-   --  Sloc (N), the starting location.\n+   --  N is an N_If_Statement or N_Case_Statement node. This procedure sets\n+   --  the End_Span field to correspond to the given value S. In other words,\n+   --  End_Span is set to the difference between S and Sloc (N), the starting\n+   --  location.\n+\n+   function Get_Pragma_Arg (Arg : Node_Id) return Node_Id;\n+   --  Given an argument to a pragma Arg, this function returns the expression\n+   --  for the argument. This is Arg itself, or, in the case where Arg is a\n+   --  pragma argument association node, the expression from this node.\n \n    --------------------------------\n    -- Node_Kind Membership Tests --\n@@ -11165,10 +11123,10 @@ package Sinfo is\n \n      N_Aspect_Specification =>\n        (1 => True,    --  Identifier (Node1)\n-        2 => False,   --  unused\n+        2 => False,   --  Aspect_Rep_Item (Node2-Sem)\n         3 => True,    --  Expression (Node3)\n-        4 => False,   --  unused\n-        5 => False),  --  unused\n+        4 => False,   --  Entity (Node4-Sem)\n+        5 => False),  --  Next_Rep_Item (Node5-Sem)\n \n      N_Enumeration_Representation_Clause =>\n        (1 => True,    --  Identifier (Node1)\n@@ -11482,6 +11440,7 @@ package Sinfo is\n    pragma Inline (Ancestor_Part);\n    pragma Inline (Array_Aggregate);\n    pragma Inline (Aspect_Cancel);\n+   pragma Inline (Aspect_Rep_Item);\n    pragma Inline (Assignment_OK);\n    pragma Inline (Associated_Node);\n    pragma Inline (At_End_Proc);\n@@ -11600,7 +11559,6 @@ package Sinfo is\n    pragma Inline (Generic_Parent_Type);\n    pragma Inline (Handled_Statement_Sequence);\n    pragma Inline (Handler_List_Entry);\n-   pragma Inline (Has_Aspect_Specifications);\n    pragma Inline (Has_Created_Identifier);\n    pragma Inline (Has_Dynamic_Length_Check);\n    pragma Inline (Has_Dynamic_Range_Check);\n@@ -11633,6 +11591,7 @@ package Sinfo is\n    pragma Inline (Is_Component_Left_Opnd);\n    pragma Inline (Is_Component_Right_Opnd);\n    pragma Inline (Is_Controlling_Actual);\n+   pragma Inline (Is_Delayed_Aspect);\n    pragma Inline (Is_Dynamic_Coextension);\n    pragma Inline (Is_Elsif);\n    pragma Inline (Is_Entry_Barrier_Function);\n@@ -11793,6 +11752,7 @@ package Sinfo is\n    pragma Inline (Set_Ancestor_Part);\n    pragma Inline (Set_Array_Aggregate);\n    pragma Inline (Set_Aspect_Cancel);\n+   pragma Inline (Set_Aspect_Rep_Item);\n    pragma Inline (Set_Assignment_OK);\n    pragma Inline (Set_Associated_Node);\n    pragma Inline (Set_At_End_Proc);\n@@ -11910,7 +11870,6 @@ package Sinfo is\n    pragma Inline (Set_Generic_Parent_Type);\n    pragma Inline (Set_Handled_Statement_Sequence);\n    pragma Inline (Set_Handler_List_Entry);\n-   pragma Inline (Set_Has_Aspect_Specifications);\n    pragma Inline (Set_Has_Created_Identifier);\n    pragma Inline (Set_Has_Dynamic_Length_Check);\n    pragma Inline (Set_Has_Init_Expression);\n@@ -11942,6 +11901,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Component_Left_Opnd);\n    pragma Inline (Set_Is_Component_Right_Opnd);\n    pragma Inline (Set_Is_Controlling_Actual);\n+   pragma Inline (Set_Is_Delayed_Aspect);\n    pragma Inline (Set_Is_Dynamic_Coextension);\n    pragma Inline (Set_Is_Elsif);\n    pragma Inline (Set_Is_Entry_Barrier_Function);"}, {"sha": "ada95bcf784f1c04ca575882492a452f6e01c6f4", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 55, "deletions": 58, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -184,10 +184,10 @@ package body Sprint is\n    --  Print the given list with items separated by vertical \"and\"\n \n    procedure Sprint_Aspect_Specifications (Node : Node_Id);\n-   --  Node is a declaration node that accepts aspect specifications. This\n-   --  procedure tests if aspect specifications are present, and if so prints\n-   --  them, with a terminating semicolon. If no aspect specifications are\n-   --  present, then a single semicolon is output.\n+   --  Node is a declaration node that has aspect specifications (Has_Aspects\n+   --  flag set True). It is called after outputting the terminating semicolon\n+   --  for the related node. The effect is to remove the semicolon and print\n+   --  the aspect specifications, followed by a terminating semicolon.\n \n    procedure Sprint_Bar_List (List : List_Id);\n    --  Print the given list with items separated by vertical bars\n@@ -631,40 +631,37 @@ package body Sprint is\n    ----------------------------------\n \n    procedure Sprint_Aspect_Specifications (Node : Node_Id) is\n-      AS : List_Id;\n+      AS : constant List_Id := Aspect_Specifications (Node);\n       A  : Node_Id;\n \n    begin\n-      if Has_Aspect_Specifications (Node) then\n-         AS := Aspect_Specifications (Node);\n-         Indent := Indent + 2;\n-         Write_Indent;\n-         Write_Str (\"with \");\n-         Indent := Indent + 5;\n+      Write_Erase_Char (';');\n+      Indent := Indent + 2;\n+      Write_Indent;\n+      Write_Str (\"with \");\n+      Indent := Indent + 5;\n \n-         A := First (AS);\n-         loop\n-            Sprint_Node (Identifier (A));\n+      A := First (AS);\n+      loop\n+         Sprint_Node (Identifier (A));\n \n-            if Class_Present (A) then\n-               Write_Str (\"'Class\");\n-            end if;\n+         if Class_Present (A) then\n+            Write_Str (\"'Class\");\n+         end if;\n \n-            if Present (Expression (A)) then\n-               Write_Str (\" => \");\n-               Sprint_Node (Expression (A));\n-            end if;\n+         if Present (Expression (A)) then\n+            Write_Str (\" => \");\n+            Sprint_Node (Expression (A));\n+         end if;\n \n-            Next (A);\n+         Next (A);\n \n-            exit when No (A);\n-            Write_Char (',');\n-            Write_Indent;\n-         end loop;\n-\n-         Indent := Indent - 7;\n-      end if;\n+         exit when No (A);\n+         Write_Char (',');\n+         Write_Indent;\n+      end loop;\n \n+      Indent := Indent - 7;\n       Write_Char (';');\n    end Sprint_Aspect_Specifications;\n \n@@ -864,8 +861,7 @@ package body Sprint is\n             Write_Indent;\n             Sprint_Node (Specification (Node));\n             Write_Str_With_Col_Check (\" is \");\n-            Write_Str_Sloc (\"abstract\");\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Str_Sloc (\"abstract;\");\n \n          when N_Accept_Alternative =>\n             Sprint_Node_List (Pragmas_Before (Node));\n@@ -1274,7 +1270,7 @@ package body Sprint is\n                   Sprint_Node (Expression (Node));\n                end if;\n \n-               Sprint_Aspect_Specifications (Node);\n+               Write_Char (';');\n             end if;\n \n          when N_Component_List =>\n@@ -1503,7 +1499,7 @@ package body Sprint is\n             end if;\n \n             Write_Param_Specs (Node);\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Entry_Index_Specification =>\n             Write_Str_With_Col_Check_Sloc (\"for \");\n@@ -1549,7 +1545,7 @@ package body Sprint is\n                   Sprint_Node (Expression (Node));\n                end if;\n \n-               Sprint_Aspect_Specifications (Node);\n+               Write_Char (';');\n             end if;\n \n          when N_Exception_Handler =>\n@@ -1675,7 +1671,7 @@ package body Sprint is\n                Sprint_Node (Default_Name (Node));\n             end if;\n \n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Formal_Concrete_Subprogram_Declaration =>\n             Write_Indent_Str_Sloc (\"with \");\n@@ -1688,7 +1684,7 @@ package body Sprint is\n                Sprint_Node (Default_Name (Node));\n             end if;\n \n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Formal_Discrete_Type_Definition =>\n             Write_Str_With_Col_Check_Sloc (\"<>\");\n@@ -1736,7 +1732,7 @@ package body Sprint is\n                   Sprint_Node (Default_Expression (Node));\n                end if;\n \n-               Sprint_Aspect_Specifications (Node);\n+               Write_Char (';');\n             end if;\n \n          when N_Formal_Ordinary_Fixed_Point_Definition =>\n@@ -1747,8 +1743,7 @@ package body Sprint is\n             Write_Id (Defining_Identifier (Node));\n             Write_Str_With_Col_Check (\" is new \");\n             Sprint_Node (Name (Node));\n-            Write_Str_With_Col_Check (\" (<>)\");\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Str_With_Col_Check (\" (<>);\");\n \n          when N_Formal_Private_Type_Definition =>\n             if Abstract_Present (Node) then\n@@ -1780,7 +1775,7 @@ package body Sprint is\n \n             Write_Str_With_Col_Check (\" is \");\n             Sprint_Node (Formal_Type_Definition (Node));\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Free_Statement =>\n             Write_Indent_Str_Sloc (\"free \");\n@@ -1821,7 +1816,7 @@ package body Sprint is\n             Write_Discr_Specs (Node);\n             Write_Str_With_Col_Check (\" is \");\n             Sprint_Node (Type_Definition (Node));\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Function_Call =>\n             Set_Debug_Sloc;\n@@ -1834,7 +1829,7 @@ package body Sprint is\n             Write_Str_With_Col_Check (\" is new \");\n             Sprint_Node (Name (Node));\n             Sprint_Opt_Paren_Comma_List (Generic_Associations (Node));\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Function_Specification =>\n             Write_Str_With_Col_Check_Sloc (\"function \");\n@@ -1875,7 +1870,7 @@ package body Sprint is\n             Sprint_Indented_List (Generic_Formal_Declarations (Node));\n             Write_Indent;\n             Sprint_Node (Specification (Node));\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Generic_Package_Renaming_Declaration =>\n             Write_Indent_Str_Sloc (\"generic package \");\n@@ -1897,7 +1892,7 @@ package body Sprint is\n             Sprint_Indented_List (Generic_Formal_Declarations (Node));\n             Write_Indent;\n             Sprint_Node (Specification (Node));\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Goto_Statement =>\n             Write_Indent_Str_Sloc (\"goto \");\n@@ -2128,7 +2123,7 @@ package body Sprint is\n                      Sprint_Node (Expression (Node));\n                   end if;\n \n-                  Sprint_Aspect_Specifications (Node);\n+                  Write_Char (';');\n \n                   --  Handle implicit importation and implicit exportation of\n                   --  object declarations:\n@@ -2369,7 +2364,7 @@ package body Sprint is\n             Extra_Blank_Line;\n             Write_Indent;\n             Sprint_Node_Sloc (Specification (Node));\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Package_Instantiation =>\n             Extra_Blank_Line;\n@@ -2378,7 +2373,7 @@ package body Sprint is\n             Write_Str (\" is new \");\n             Sprint_Node (Name (Node));\n             Sprint_Opt_Paren_Comma_List (Generic_Associations (Node));\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Package_Renaming_Declaration =>\n             Write_Indent_Str_Sloc (\"package \");\n@@ -2479,8 +2474,7 @@ package body Sprint is\n                Sprint_And_List (Interface_List (Node));\n             end if;\n \n-            Write_Str_With_Col_Check (\" with private\");\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Str_With_Col_Check (\" with private;\");\n \n          when N_Private_Type_Declaration =>\n             Write_Indent_Str_Sloc (\"type \");\n@@ -2502,8 +2496,7 @@ package body Sprint is\n                Write_Str_With_Col_Check (\"limited \");\n             end if;\n \n-            Write_Str_With_Col_Check (\"private\");\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Str_With_Col_Check (\"private;\");\n \n          when N_Push_Constraint_Error_Label =>\n             Write_Indent_Str (\"%push_constraint_error_label (\");\n@@ -2566,7 +2559,7 @@ package body Sprint is\n             Write_Str_With_Col_Check (\" is new \");\n             Sprint_Node (Name (Node));\n             Sprint_Opt_Paren_Comma_List (Generic_Associations (Node));\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Procedure_Specification =>\n             Write_Str_With_Col_Check_Sloc (\"procedure \");\n@@ -2613,7 +2606,7 @@ package body Sprint is\n \n             Sprint_Node (Protected_Definition (Node));\n             Write_Id (Defining_Identifier (Node));\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Qualified_Expression =>\n             Sprint_Node (Subtype_Mark (Node));\n@@ -2809,7 +2802,7 @@ package body Sprint is\n             Write_Str (\" is\");\n             Sprint_Node (Protected_Definition (Node));\n             Write_Id (Defining_Identifier (Node));\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Single_Task_Declaration =>\n             Write_Indent_Str_Sloc (\"task \");\n@@ -2820,7 +2813,7 @@ package body Sprint is\n                Sprint_Node (Task_Definition (Node));\n             end if;\n \n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Selected_Component =>\n             Sprint_Node (Prefix (Node));\n@@ -2893,7 +2886,7 @@ package body Sprint is\n                Write_Str_With_Col_Check (\" is null\");\n             end if;\n \n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Subprogram_Info =>\n             Sprint_Node (Identifier (Node));\n@@ -2918,7 +2911,7 @@ package body Sprint is\n             end if;\n \n             Sprint_Node (Subtype_Indication (Node));\n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Subtype_Indication =>\n             Sprint_Node_Sloc (Subtype_Mark (Node));\n@@ -2981,7 +2974,7 @@ package body Sprint is\n                Sprint_Node (Task_Definition (Node));\n             end if;\n \n-            Sprint_Aspect_Specifications (Node);\n+            Write_Char (';');\n \n          when N_Terminate_Alternative =>\n             Sprint_Node_List (Pragmas_Before (Node));\n@@ -3144,6 +3137,10 @@ package body Sprint is\n             end if;\n       end case;\n \n+      if Has_Aspects (Node) then\n+         Sprint_Aspect_Specifications (Node);\n+      end if;\n+\n       if Nkind (Node) in N_Subexpr\n         and then Do_Range_Check (Node)\n       then"}, {"sha": "d36e1f74a51bbb9b251bb1690756cff5695ac092", "filename": "gcc/ada/tree_gen.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Ftree_gen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Ftree_gen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_gen.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;\n with Atree;\n with Elists;\n with Fname;\n@@ -50,6 +51,7 @@ begin\n    if Opt.Tree_Output then\n       Osint.C.Tree_Create;\n       Opt.Tree_Write;\n+      Aspects.Tree_Write;\n       Atree.Tree_Write;\n       Elists.Tree_Write;\n       Fname.Tree_Write;"}, {"sha": "60f7d45cb4e8d3aeb28d2aa6e86d0b0a9e6b29e1", "filename": "gcc/ada/tree_in.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Ftree_in.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Ftree_in.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_in.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009  Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,6 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;\n with Atree;\n with Csets;\n with Elists;\n@@ -50,6 +51,7 @@ procedure Tree_In (Desc : File_Descriptor) is\n begin\n    Tree_IO.Tree_Read_Initialize (Desc);\n    Opt.Tree_Read;\n+   Aspects.Tree_Read;\n    Atree.Tree_Read;\n    Elists.Tree_Read;\n    Fname.Tree_Read;"}, {"sha": "82d0c86178a863bbd01d9e6646553612cab25105", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Csets;    use Csets;\n with Debug;    use Debug;\n@@ -1010,6 +1011,12 @@ package body Treepr is\n                Print_Eol;\n             end if;\n \n+            if Has_Aspects (N) then\n+               Print_Str (Prefix_Str_Char);\n+               Print_Str (\"Has_Aspects = True\");\n+               Print_Eol;\n+            end if;\n+\n             if Has_Dynamic_Range_Check (N) then\n                Print_Str (Prefix_Str_Char);\n                Print_Str (\"Has_Dynamic_Range_Check = True\");\n@@ -1099,7 +1106,10 @@ package body Treepr is\n             when F_Field5 =>\n                Field_To_Be_Printed := Field5 (N) /= Union_Id (Empty);\n \n-            when F_Flag3  => Field_To_Be_Printed := Flag3  (N);\n+            --  Flag3 is obsolete, so this probably gets removed ???\n+\n+            when F_Flag3 => Field_To_Be_Printed := Has_Aspects (N);\n+\n             when F_Flag4  => Field_To_Be_Printed := Flag4  (N);\n             when F_Flag5  => Field_To_Be_Printed := Flag5  (N);\n             when F_Flag6  => Field_To_Be_Printed := Flag6  (N);\n@@ -1169,11 +1179,14 @@ package body Treepr is\n                when F_Flag17 => Print_Flag  (Flag17 (N));\n                when F_Flag18 => Print_Flag  (Flag18 (N));\n \n-               --  Flag1,2,3 are no longer used\n+               --  Flag1,2 are no longer used\n \n                when F_Flag1  => raise Program_Error;\n                when F_Flag2  => raise Program_Error;\n-               when F_Flag3  => raise Program_Error;\n+\n+               --  Not clear why we need the following ???\n+\n+               when F_Flag3  => Print_Flag (Has_Aspects (N));\n             end case;\n \n             Print_Eol;\n@@ -1187,9 +1200,17 @@ package body Treepr is\n                P := P + 1;\n             end loop;\n          end if;\n-\n       end loop;\n \n+      --  Print aspects if present\n+\n+      if Has_Aspects (N) then\n+         Print_Str (Prefix_Str_Char);\n+         Print_Str (\"Aspect_Specifications = \");\n+         Print_Field (Union_Id (Aspect_Specifications (N)));\n+         Print_Eol;\n+      end if;\n+\n       --  Print entity information for entities\n \n       if Nkind (N) in N_Entity then\n@@ -1906,6 +1927,10 @@ package body Treepr is\n          Visit_Descendent (Field4 (N));\n          Visit_Descendent (Field5 (N));\n \n+         if Has_Aspects (N) then\n+            Visit_Descendent (Union_Id (Aspect_Specifications (N)));\n+         end if;\n+\n       --  Entity case\n \n       else"}, {"sha": "416e5cbba800f466ee29e8dc1ec5ef7040dc3282", "filename": "gcc/ada/xtreeprs.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fxtreeprs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c159409f3a8d7e53a499187ba7a2fc3aa2da3d04/gcc%2Fada%2Fxtreeprs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxtreeprs.adb?ref=c159409f3a8d7e53a499187ba7a2fc3aa2da3d04", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -252,9 +252,6 @@ begin\n                --    Field3       '%'\n                --    Field4       '&'\n                --    Field5       \"'\"\n-               --    Flag1        \"(\"\n-               --    Flag2        \")\"\n-               --    Flag3        '*'\n                --    Flag4        '+'\n                --    Flag5        ','\n                --    Flag6        '-'"}]}