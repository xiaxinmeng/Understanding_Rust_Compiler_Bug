{"sha": "1a9dddada346b812bafc8918d082c993c7f0a82d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE5ZGRkYWRhMzQ2YjgxMmJhZmM4OTE4ZDA4MmM5OTNjN2YwYTgyZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-03-01T02:43:49Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-03-01T02:43:49Z"}, "message": "re PR tree-optimization/20216 (Simple loop runs out of stack at -O1)\n\n\n\tPR tree-optimization/20216\n\t* tree-chrec.c (tree_fold_factorial): Delete.\n\t(tree_fold_binomial): Change argument list to take a return type\n\tand change the type of K to unsigned int.  Rewrite to avoid explicit\n\tevaluation of factorials, and (recursively) calling fold to perform\n\tcompile-time arithmetic.  Return NULL on (internal) overflow.\n\t(chrec_evaluate): Change type of K to an unsigned int.  Avoid\n\tcalling tree_fold_binomial unnecessarily.  Return chrec_dont_know\n\tif any intermediate calculation overflows.\n\t(chrec_apply): Update call to chrec_evaluate.\n\nFrom-SVN: r95722", "tree": {"sha": "64d2edac2cf6316d5116125278fb576fd0d0116e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64d2edac2cf6316d5116125278fb576fd0d0116e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a9dddada346b812bafc8918d082c993c7f0a82d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a9dddada346b812bafc8918d082c993c7f0a82d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a9dddada346b812bafc8918d082c993c7f0a82d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a9dddada346b812bafc8918d082c993c7f0a82d/comments", "author": null, "committer": null, "parents": [{"sha": "6a88516c9d9bfd528fdfa2ac2904fc0c14597b9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a88516c9d9bfd528fdfa2ac2904fc0c14597b9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a88516c9d9bfd528fdfa2ac2904fc0c14597b9c"}], "stats": {"total": 151, "additions": 106, "deletions": 45}, "files": [{"sha": "7eed83204604f5f532742dec31765be8690d7c31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a9dddada346b812bafc8918d082c993c7f0a82d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a9dddada346b812bafc8918d082c993c7f0a82d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a9dddada346b812bafc8918d082c993c7f0a82d", "patch": "@@ -1,3 +1,16 @@\n+2005-02-28  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR tree-optimization/20216\n+\t* tree-chrec.c (tree_fold_factorial): Delete.\n+\t(tree_fold_binomial): Change argument list to take a return type\n+\tand change the type of K to unsigned int.  Rewrite to avoid explicit\n+\tevaluation of factorials, and (recursively) calling fold to perform\n+\tcompile-time arithmetic.  Return NULL on (internal) overflow.\n+\t(chrec_evaluate): Change type of K to an unsigned int.  Avoid\n+\tcalling tree_fold_binomial unnecessarily.  Return chrec_dont_know\n+\tif any intermediate calculation overflows.\n+\t(chrec_apply): Update call to chrec_evaluate.\n+\n 2005-02-28  James E Wilson  <wilson@specifixinc.com>\n \n \t* config/mips/mips.h (NO_PROFILE_COUNTERS): Define."}, {"sha": "a360301d53e05186c3793b35f9ffc6723183ed70", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 93, "deletions": 45, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a9dddada346b812bafc8918d082c993c7f0a82d/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a9dddada346b812bafc8918d082c993c7f0a82d/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=1a9dddada346b812bafc8918d082c993c7f0a82d", "patch": "@@ -1,5 +1,5 @@\n /* Chains of recurrences.\n-   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <s.pop@laposte.net>\n \n This file is part of GCC.\n@@ -383,63 +383,111 @@ chrec_fold_multiply (tree type,\n \n /* Operations.  */\n \n-/* The factorial.  */\n- \n+/* Evaluate the binomial coefficient.  Return NULL_TREE if the intermediate\n+   calculation overflows, otherwise return C(n,k) with type TYPE.  */\n+\n static tree \n-tree_fold_factorial (tree f)\n+tree_fold_binomial (tree type, tree n, unsigned int k)\n {\n-  if (tree_int_cst_sgn (f) <= 0)\n-    return integer_one_node;\n+  unsigned HOST_WIDE_INT lidx, lnum, ldenom, lres, ldum;\n+  HOST_WIDE_INT hidx, hnum, hdenom, hres, hdum;\n+  unsigned int i;\n+  tree res;\n+\n+  /* Handle the most frequent cases.  */\n+  if (k == 0)\n+    return build_int_cst (type, 1);\n+  if (k == 1)\n+    return fold_convert (type, n);\n+\n+  /* Check that k <= n.  */\n+  if (TREE_INT_CST_HIGH (n) == 0\n+      && TREE_INT_CST_LOW (n) < k)\n+    return NULL_TREE;\n+\n+  /* Numerator = n.  */\n+  lnum = TREE_INT_CST_LOW (n);\n+  hnum = TREE_INT_CST_HIGH (n);\n+\n+  /* Denominator = 2.  */\n+  ldenom = 2;\n+  hdenom = 0;\n+\n+  /* Index = Numerator-1.  */\n+  if (lnum == 0)\n+    {\n+      hidx = hnum - 1;\n+      lidx = ~ (unsigned HOST_WIDE_INT) 0;\n+    }\n   else\n-    return fold \n-      (build (MULT_EXPR, integer_type_node, f, \n-\t      tree_fold_factorial (fold (build (MINUS_EXPR, integer_type_node, \n-\t\t\t\t\t\tf, integer_one_node)))));\n-}\n+    {\n+      hidx = hnum;\n+      lidx = lnum - 1;\n+    }\n \n-/* The binomial coefficient.  */\n+  /* Numerator = Numerator*Index = n*(n-1).  */\n+  if (mul_double (lnum, hnum, lidx, hidx, &lnum, &hnum))\n+    return NULL_TREE;\n \n-static tree \n-tree_fold_binomial (tree n,\n-\t\t    tree k)\n-{\n-  return fold \n-    (build (EXACT_DIV_EXPR, integer_type_node, tree_fold_factorial (n), \n-\t    fold (build (MULT_EXPR, integer_type_node, \n-\t\t\t tree_fold_factorial (k),\n-\t\t\t tree_fold_factorial \n-\t\t\t (fold (build (MINUS_EXPR, integer_type_node, \n-\t\t\t\t       n, k)))))));\n+  for (i = 3; i <= k; i++)\n+    {\n+      /* Index--.  */\n+      if (lidx == 0)\n+\t{\n+\t  hidx--;\n+\t  lidx = ~ (unsigned HOST_WIDE_INT) 0;\n+\t}\n+      else\n+        lidx--;\n+\n+      /* Numerator *= Index.  */\n+      if (mul_double (lnum, hnum, lidx, hidx, &lnum, &hnum))\n+\treturn NULL_TREE;\n+\n+      /* Denominator *= i.  */\n+      mul_double (ldenom, hdenom, i, 0, &ldenom, &hdenom);\n+    }\n+\n+  /* Result = Numerator / Denominator.  */\n+  div_and_round_double (EXACT_DIV_EXPR, 1, lnum, hnum, ldenom, hdenom,\n+\t\t\t&lres, &hres, &ldum, &hdum);\n+\n+  res = build_int_cst_wide (type, lres, hres);\n+  return int_fits_type_p (res, type) ? res : NULL_TREE;\n }\n \n /* Helper function.  Use the Newton's interpolating formula for\n    evaluating the value of the evolution function.  */\n \n static tree \n-chrec_evaluate (unsigned var,\n-\t\ttree chrec,\n-\t\ttree n,\n-\t\ttree k)\n+chrec_evaluate (unsigned var, tree chrec, tree n, unsigned int k)\n {\n-  tree type = chrec_type (chrec);\n-  tree binomial_n_k = tree_fold_binomial (n, k);\n-  \n-  if (TREE_CODE (chrec) == POLYNOMIAL_CHREC)\n+  tree arg0, arg1, binomial_n_k;\n+  tree type = TREE_TYPE (chrec);\n+\n+  while (TREE_CODE (chrec) == POLYNOMIAL_CHREC\n+\t && CHREC_VARIABLE (chrec) > var)\n+    chrec = CHREC_LEFT (chrec);\n+\n+  if (TREE_CODE (chrec) == POLYNOMIAL_CHREC\n+      && CHREC_VARIABLE (chrec) == var)\n     {\n-      if (CHREC_VARIABLE (chrec) > var)\n-\treturn chrec_evaluate (var, CHREC_LEFT (chrec), n, k);\n-      \n-      if (CHREC_VARIABLE (chrec) == var)\n-\treturn chrec_fold_plus \n-\t  (type, \n-\t   fold (build (MULT_EXPR, type, binomial_n_k, CHREC_LEFT (chrec))),\n-\t   chrec_evaluate (var, CHREC_RIGHT (chrec), n, \n-\t\t\t   fold (build (PLUS_EXPR, type, k, integer_one_node))));\n-      \n-      return fold (build (MULT_EXPR, type, binomial_n_k, chrec));\n+      arg0 = chrec_evaluate (var, CHREC_RIGHT (chrec), n, k + 1);\n+      if (arg0 == chrec_dont_know)\n+\treturn chrec_dont_know;\n+      binomial_n_k = tree_fold_binomial (type, n, k);\n+      if (!binomial_n_k)\n+\treturn chrec_dont_know;\n+      arg1 = fold (build2 (MULT_EXPR, type,\n+\t\t\t   CHREC_LEFT (chrec), binomial_n_k));\n+      return chrec_fold_plus (type, arg0, arg1);\n     }\n-  else\n-    return fold (build (MULT_EXPR, type, binomial_n_k, chrec));\n+\n+  binomial_n_k = tree_fold_binomial (type, n, k);\n+  if (!binomial_n_k)\n+    return chrec_dont_know;\n+  \n+  return fold (build2 (MULT_EXPR, type, chrec, binomial_n_k));\n }\n \n /* Evaluates \"CHREC (X)\" when the varying variable is VAR.  \n@@ -493,7 +541,7 @@ chrec_apply (unsigned var,\n   else if (TREE_CODE (x) == INTEGER_CST\n \t   && tree_int_cst_sgn (x) == 1)\n     /* testsuite/.../ssa-chrec-38.c.  */\n-    res = chrec_evaluate (var, chrec, x, integer_zero_node);\n+    res = chrec_evaluate (var, chrec, x, 0);\n \n   else\n     res = chrec_dont_know;"}]}