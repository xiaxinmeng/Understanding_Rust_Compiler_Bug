{"sha": "dcf59308566293ab3695b5e42c36216906609d3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNmNTkzMDg1NjYyOTNhYjM2OTViNWU0MmMzNjIxNjkwNjYwOWQzYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-11T10:18:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-11T10:18:05Z"}, "message": "Renamed s-thread__ae653.adb\n\nFrom-SVN: r251972", "tree": {"sha": "83b7fe8264fcfe4c2836fab8979854a5062b9743", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83b7fe8264fcfe4c2836fab8979854a5062b9743"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcf59308566293ab3695b5e42c36216906609d3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcf59308566293ab3695b5e42c36216906609d3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcf59308566293ab3695b5e42c36216906609d3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcf59308566293ab3695b5e42c36216906609d3b/comments", "author": null, "committer": null, "parents": [{"sha": "c64be6371eb55e656e26d55e647a3f9d0c2eb872", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c64be6371eb55e656e26d55e647a3f9d0c2eb872", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c64be6371eb55e656e26d55e647a3f9d0c2eb872"}], "stats": {"total": 247, "additions": 0, "deletions": 247}, "files": [{"sha": "ca871286fceed2b1474f38671ba6b4cdfc41f63b", "filename": "gcc/ada/libgnat/s__thread-ae653.adb", "status": "removed", "additions": 0, "deletions": 247, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c64be6371eb55e656e26d55e647a3f9d0c2eb872/gcc%2Fada%2Flibgnat%2Fs__thread-ae653.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c64be6371eb55e656e26d55e647a3f9d0c2eb872/gcc%2Fada%2Flibgnat%2Fs__thread-ae653.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs__thread-ae653.adb?ref=c64be6371eb55e656e26d55e647a3f9d0c2eb872", "patch": "@@ -1,247 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                       S Y S T E M . T H R E A D S                        --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the VxWorks 653 version of this package\n-\n-pragma Restrictions (No_Tasking);\n---  The VxWorks 653 version of this package is intended only for programs\n---  which do not use Ada tasking. This restriction ensures that this\n---  will be checked by the binder.\n-\n-with System.OS_Versions; use System.OS_Versions;\n-with System.Secondary_Stack;\n-pragma Elaborate_All (System.Secondary_Stack);\n-\n-package body System.Threads is\n-\n-   use Interfaces.C;\n-\n-   package SSS renames System.Secondary_Stack;\n-\n-   package SSL renames System.Soft_Links;\n-\n-   Current_ATSD : aliased System.Address := System.Null_Address;\n-   pragma Export (C, Current_ATSD, \"__gnat_current_atsd\");\n-\n-   Main_ATSD : aliased ATSD;\n-   --  TSD for environment task\n-\n-   Stack_Limit : Address;\n-\n-   pragma Import (C, Stack_Limit, \"__gnat_stack_limit\");\n-\n-   type Set_Stack_Limit_Proc_Acc is access procedure;\n-   pragma Convention (C, Set_Stack_Limit_Proc_Acc);\n-\n-   Set_Stack_Limit_Hook : Set_Stack_Limit_Proc_Acc;\n-   pragma Import (C, Set_Stack_Limit_Hook, \"__gnat_set_stack_limit_hook\");\n-   --  Procedure to be called when a task is created to set stack limit if\n-   --  limit checking is used.\n-\n-   --------------------------\n-   -- VxWorks specific API --\n-   --------------------------\n-\n-   ERROR : constant STATUS := Interfaces.C.int (-1);\n-\n-   function taskIdVerify (tid : t_id) return STATUS;\n-   pragma Import (C, taskIdVerify, \"taskIdVerify\");\n-\n-   function taskIdSelf return t_id;\n-   pragma Import (C, taskIdSelf, \"taskIdSelf\");\n-\n-   function taskVarAdd\n-     (tid : t_id; pVar : System.Address) return int;\n-   pragma Import (C, taskVarAdd, \"taskVarAdd\");\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Init_RTS;\n-   --  This procedure performs the initialization of the run-time lib.\n-   --  It installs System.Threads versions of certain operations of the\n-   --  run-time lib.\n-\n-   procedure Install_Handler;\n-   pragma Import (C, Install_Handler, \"__gnat_install_handler\");\n-\n-   function  Get_Sec_Stack_Addr return  Address;\n-\n-   procedure Set_Sec_Stack_Addr (Addr : Address);\n-\n-   -----------------------\n-   -- Thread_Body_Enter --\n-   -----------------------\n-\n-   procedure Thread_Body_Enter\n-     (Sec_Stack_Address    : System.Address;\n-      Sec_Stack_Size       : Natural;\n-      Process_ATSD_Address : System.Address)\n-   is\n-      --  Current_ATSD must already be a taskVar of taskIdSelf.\n-      --  No assertion because taskVarGet is not available on VxWorks/CERT,\n-      --  which is used on VxWorks 653 3.x as a guest OS.\n-\n-      TSD : constant ATSD_Access := From_Address (Process_ATSD_Address);\n-\n-   begin\n-\n-      TSD.Sec_Stack_Addr := Sec_Stack_Address;\n-      SSS.SS_Init (TSD.Sec_Stack_Addr, Sec_Stack_Size);\n-      Current_ATSD := Process_ATSD_Address;\n-\n-      Install_Handler;\n-\n-      --  Initialize stack limit if needed\n-\n-      if Current_ATSD /= Main_ATSD'Address\n-        and then Set_Stack_Limit_Hook /= null\n-      then\n-         Set_Stack_Limit_Hook.all;\n-      end if;\n-   end Thread_Body_Enter;\n-\n-   ----------------------------------\n-   -- Thread_Body_Exceptional_Exit --\n-   ----------------------------------\n-\n-   procedure Thread_Body_Exceptional_Exit\n-     (EO : Ada.Exceptions.Exception_Occurrence)\n-   is\n-      pragma Unreferenced (EO);\n-\n-   begin\n-      --  No action for this target\n-\n-      null;\n-   end Thread_Body_Exceptional_Exit;\n-\n-   -----------------------\n-   -- Thread_Body_Leave --\n-   -----------------------\n-\n-   procedure Thread_Body_Leave is\n-   begin\n-      --  No action for this target\n-\n-      null;\n-   end Thread_Body_Leave;\n-\n-   --------------\n-   -- Init_RTS --\n-   --------------\n-\n-   procedure Init_RTS is\n-      --  Register environment task\n-      Result : constant Interfaces.C.int := Register (taskIdSelf);\n-      pragma Assert (Result /= ERROR);\n-\n-   begin\n-      Main_ATSD.Sec_Stack_Addr := SSL.Get_Sec_Stack_Addr_NT;\n-      Current_ATSD := Main_ATSD'Address;\n-      Install_Handler;\n-      SSL.Get_Sec_Stack_Addr := Get_Sec_Stack_Addr'Access;\n-      SSL.Set_Sec_Stack_Addr := Set_Sec_Stack_Addr'Access;\n-   end Init_RTS;\n-\n-   ------------------------\n-   -- Get_Sec_Stack_Addr --\n-   ------------------------\n-\n-   function  Get_Sec_Stack_Addr return  Address is\n-      CTSD : constant ATSD_Access := From_Address (Current_ATSD);\n-   begin\n-      pragma Assert (CTSD /= null);\n-      return CTSD.Sec_Stack_Addr;\n-   end Get_Sec_Stack_Addr;\n-\n-   --------------\n-   -- Register --\n-   --------------\n-\n-   function Register (T : Thread_Id) return STATUS is\n-      Result : STATUS;\n-\n-   begin\n-      --  It cannot be assumed that the caller of this routine has a ATSD;\n-      --  so neither this procedure nor the procedures that it calls should\n-      --  raise or handle exceptions, or make use of a secondary stack.\n-\n-      --  This routine is only necessary because taskVarAdd cannot be\n-      --  executed once an VxWorks 653 partition has entered normal mode\n-      --  (depending on configRecord.c, allocation could be disabled).\n-      --  Otherwise, everything could have been done in Thread_Body_Enter.\n-\n-      if taskIdVerify (T) = ERROR then\n-         return ERROR;\n-      end if;\n-\n-      Result := taskVarAdd (T, Current_ATSD'Address);\n-      pragma Assert (Result /= ERROR);\n-\n-      --  The same issue applies to the task variable that contains the stack\n-      --  limit when that overflow checking mechanism is used instead of\n-      --  probing. If stack checking is enabled and limit checking is used,\n-      --  allocate the limit for this task. The environment task has this\n-      --  initialized by the binder-generated main when\n-      --  System.Stack_Check_Limits = True.\n-\n-      pragma Warnings (Off);\n-      --  OS is a constant\n-      if Result /= ERROR\n-        and then OS /= VxWorks_653\n-        and then Set_Stack_Limit_Hook /= null\n-      then\n-         Result := taskVarAdd (T, Stack_Limit'Address);\n-         pragma Assert (Result /= ERROR);\n-      end if;\n-      pragma Warnings (On);\n-\n-      return Result;\n-   end Register;\n-\n-   ------------------------\n-   -- Set_Sec_Stack_Addr --\n-   ------------------------\n-\n-   procedure Set_Sec_Stack_Addr (Addr : Address) is\n-      CTSD : constant ATSD_Access := From_Address (Current_ATSD);\n-   begin\n-      pragma Assert (CTSD /= null);\n-      CTSD.Sec_Stack_Addr := Addr;\n-   end Set_Sec_Stack_Addr;\n-\n-begin\n-   --  Initialize run-time library\n-\n-   Init_RTS;\n-end System.Threads;"}]}