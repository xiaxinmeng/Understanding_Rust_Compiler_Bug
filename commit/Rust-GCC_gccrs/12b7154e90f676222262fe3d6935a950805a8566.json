{"sha": "12b7154e90f676222262fe3d6935a950805a8566", "node_id": "C_kwDOANBUbNoAKDEyYjcxNTRlOTBmNjc2MjIyMjYyZmUzZDY5MzVhOTUwODA1YTg1NjY", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-24T18:16:37Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-25T14:11:10Z"}, "message": "improve the error handling on operator overload cases\n\nThis operator overloading function was extracted from the callers within\ncompound assignment etc, where we needed to be able to fall back to code\nwithin the same function. This improves the error handling to return early\nwhen there are no such lang-items or no available method instead of trying\nto continue. It flattens the conditional's previously required in the code\npath.", "tree": {"sha": "80b6d67075bf8d3adb1ceefdc039b30e6d0cb306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80b6d67075bf8d3adb1ceefdc039b30e6d0cb306"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12b7154e90f676222262fe3d6935a950805a8566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12b7154e90f676222262fe3d6935a950805a8566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12b7154e90f676222262fe3d6935a950805a8566", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12b7154e90f676222262fe3d6935a950805a8566/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "717b6da459b26ace9a3c303cfa5e485ff8935709", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/717b6da459b26ace9a3c303cfa5e485ff8935709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/717b6da459b26ace9a3c303cfa5e485ff8935709"}], "stats": {"total": 114, "additions": 54, "deletions": 60}, "files": [{"sha": "492342647e584c9ee690ad8b45b38ed114dad6c9", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 54, "deletions": 60, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12b7154e90f676222262fe3d6935a950805a8566/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12b7154e90f676222262fe3d6935a950805a8566/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=12b7154e90f676222262fe3d6935a950805a8566", "patch": "@@ -1260,34 +1260,37 @@ class TypeCheckExpr : public TypeCheckBase\n     const TyTy::BaseType *root = lhs->get_root ();\n \n     // look up lang item for arithmetic type\n-    std::vector<PathProbeCandidate> candidates;\n     std::string associated_item_name\n       = Analysis::RustLangItem::ToString (lang_item_type);\n     DefId respective_lang_item_id = UNKNOWN_DEFID;\n     bool lang_item_defined\n       = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n \n     // probe for the lang-item\n-    if (lang_item_defined)\n-      {\n-\tbool receiver_is_type_param\n-\t  = root->get_kind () == TyTy::TypeKind::PARAM;\n-\tbool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n-\n-\tbool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n-\tbool probe_bounds = true;\n-\tbool probe_impls = !receiver_is_generic;\n-\tbool ignore_mandatory_trait_items = !receiver_is_generic;\n-\n-\tcandidates = PathProbeType::Probe (\n-\t  root, HIR::PathIdentSegment (associated_item_name), probe_impls,\n-\t  probe_bounds, ignore_mandatory_trait_items, respective_lang_item_id);\n-      }\n+    if (!lang_item_defined)\n+      return false;\n \n-    // autoderef\n+    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n+    bool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n+    bool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n+    bool probe_bounds = true;\n+    bool probe_impls = !receiver_is_generic;\n+    bool ignore_mandatory_trait_items = !receiver_is_generic;\n+\n+    auto candidates = PathProbeType::Probe (\n+      root, HIR::PathIdentSegment (associated_item_name), probe_impls,\n+      probe_bounds, ignore_mandatory_trait_items, respective_lang_item_id);\n+\n+    // autoderef to find the relevant method\n     std::vector<Adjustment> adjustments;\n     PathProbeCandidate *resolved_candidate\n       = MethodResolution::Select (candidates, lhs, adjustments);\n+    if (resolved_candidate == nullptr)\n+      return false;\n+\n+    bool have_implementation_for_lang_item = resolved_candidate != nullptr;\n+    if (!have_implementation_for_lang_item)\n+      return false;\n \n     // mark the required tree addressable\n     if (Adjuster::needs_address (adjustments))\n@@ -1297,56 +1300,47 @@ class TypeCheckExpr : public TypeCheckBase\n     // handle the case where we are within the impl block for this lang_item\n     // otherwise we end up with a recursive operator overload such as the i32\n     // operator overload trait\n-    if (lang_item_defined && resolved_candidate != nullptr)\n+    TypeCheckContextItem &fn_context = context->peek_context ();\n+    if (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n       {\n-\tTypeCheckContextItem &fn_context = context->peek_context ();\n-\tif (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n-\t  {\n-\t    auto &impl_item = fn_context.get_impl_item ();\n-\t    HIR::ImplBlock *parent = impl_item.first;\n-\t    HIR::Function *fn = impl_item.second;\n+\tauto &impl_item = fn_context.get_impl_item ();\n+\tHIR::ImplBlock *parent = impl_item.first;\n+\tHIR::Function *fn = impl_item.second;\n \n-\t    if (parent->has_trait_ref ()\n-\t\t&& fn->get_function_name ().compare (associated_item_name) == 0)\n+\tif (parent->has_trait_ref ()\n+\t    && fn->get_function_name ().compare (associated_item_name) == 0)\n+\t  {\n+\t    TraitReference *trait_reference\n+\t      = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n+\t    if (!trait_reference->is_error ())\n \t      {\n-\t\tTraitReference *trait_reference\n-\t\t  = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n-\t\tif (!trait_reference->is_error ())\n-\t\t  {\n-\t\t    TyTy::BaseType *lookup = nullptr;\n-\t\t    bool ok\n-\t\t      = context->lookup_type (fn->get_mappings ().get_hirid (),\n-\t\t\t\t\t      &lookup);\n-\t\t    rust_assert (ok);\n-\t\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-\n-\t\t    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n-\t\t    rust_assert (fntype->is_method ());\n-\n-\t\t    Adjuster adj (lhs);\n-\t\t    TyTy::BaseType *adjusted = adj.adjust_type (adjustments);\n-\n-\t\t    bool is_lang_item_impl\n-\t\t      = trait_reference->get_mappings ().get_defid ()\n-\t\t\t== respective_lang_item_id;\n-\t\t    bool self_is_lang_item_self\n-\t\t      = fntype->get_self_type ()->is_equal (*adjusted);\n-\t\t    bool recursive_operator_overload\n-\t\t      = is_lang_item_impl && self_is_lang_item_self;\n-\n-\t\t    lang_item_defined = !recursive_operator_overload;\n-\t\t  }\n+\t\tTyTy::BaseType *lookup = nullptr;\n+\t\tbool ok\n+\t\t  = context->lookup_type (fn->get_mappings ().get_hirid (),\n+\t\t\t\t\t  &lookup);\n+\t\trust_assert (ok);\n+\t\trust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t\tTyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+\t\trust_assert (fntype->is_method ());\n+\n+\t\tAdjuster adj (lhs);\n+\t\tTyTy::BaseType *adjusted = adj.adjust_type (adjustments);\n+\n+\t\tbool is_lang_item_impl\n+\t\t  = trait_reference->get_mappings ().get_defid ()\n+\t\t    == respective_lang_item_id;\n+\t\tbool self_is_lang_item_self\n+\t\t  = fntype->get_self_type ()->is_equal (*adjusted);\n+\t\tbool recursive_operator_overload\n+\t\t  = is_lang_item_impl && self_is_lang_item_self;\n+\n+\t\tif (recursive_operator_overload)\n+\t\t  return false;\n \t      }\n \t  }\n       }\n \n-    bool have_implementation_for_lang_item = resolved_candidate != nullptr;\n-    if (!lang_item_defined || !have_implementation_for_lang_item)\n-      {\n-\t// no operator overload exists for this\n-\treturn false;\n-      }\n-\n     // now its just like a method-call-expr\n     context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n "}]}