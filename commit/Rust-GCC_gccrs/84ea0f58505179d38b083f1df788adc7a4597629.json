{"sha": "84ea0f58505179d38b083f1df788adc7a4597629", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRlYTBmNTg1MDUxNzlkMzhiMDgzZjFkZjc4OGFkYzdhNDU5NzYyOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-02-29T10:20:31Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-02-29T10:20:31Z"}, "message": "re PR target/69706 (internal compiler error: in extract_constrain_insn, at recog.c:2246)\n\n\tPR target/69706\n\t* config/sparc/sparc.c (ROUND_ADVANCE): Rename to...\n\t(NWORDS_UP): ...this\n\t(init_cumulative_args): Minor tweaks.\n\t(sparc_promote_function_mode): Likewise.\n\t(scan_record_type): Delete.\n\t(traverse_record_type): New function template.\n\t(classify_data_t): New structure type.\n\t(classify_registers): New inline function.\n\t(function_arg_slotno): In 64-bit mode, bail out early if FP slots are\n\texhausted.  Instantiate traverse_record_type on classify_registers and\n\tdeal with the case of a structure passed in slot #15 with no FP field\n\tin the first word.\n\t(assign_data_t): New structure type.\n\t(compute_int_layout): New static function.\n\t(compute_fp_layout): Likewise.\n\t(count_registers): New inline function.\n\t(assign_int_registers): New static function.\n\t(assign_fp_registers): Likewise.\n\t(assign_registers): New inline function.\n\t(function_arg_record_value_1): Delete.\n\t(function_arg_record_value_2): Likewise.\n\t(function_arg_record_value_3): Likewise.\n\t(function_arg_record_value): Adjust to above changes.  Instantiate\n\ttraverse_record_type on count_registers to first count the number of\n\tregisters to be used and then on assign_registers to assign them.\n\t(function_arg_union_value): Adjust to above renaming.\n\t(sparc_function_arg_1); Minor tweaks.  Remove commented out code.\n\t(sparc_arg_partial_bytes): Adjust to above renaming.  Deal with the\n\tcase of a structure passed in slot #15\n\t(sparc_function_arg_advance): Likewise.\n\t(function_arg_padding): Minor tweak.\n\nFrom-SVN: r233808", "tree": {"sha": "d253331df7d56edd4f18a30266dfc41303a1de89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d253331df7d56edd4f18a30266dfc41303a1de89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84ea0f58505179d38b083f1df788adc7a4597629", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84ea0f58505179d38b083f1df788adc7a4597629", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84ea0f58505179d38b083f1df788adc7a4597629", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84ea0f58505179d38b083f1df788adc7a4597629/comments", "author": null, "committer": null, "parents": [{"sha": "8ea456b94ac356fd36ba7043195a2d6c65eebfa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ea456b94ac356fd36ba7043195a2d6c65eebfa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ea456b94ac356fd36ba7043195a2d6c65eebfa7"}], "stats": {"total": 860, "additions": 490, "deletions": 370}, "files": [{"sha": "3edc42e47fffcc04f8ce3d4e57d3682c74a1c2dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84ea0f58505179d38b083f1df788adc7a4597629/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84ea0f58505179d38b083f1df788adc7a4597629/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84ea0f58505179d38b083f1df788adc7a4597629", "patch": "@@ -1,3 +1,38 @@\n+2016-02-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/69706\n+\t* config/sparc/sparc.c (ROUND_ADVANCE): Rename to...\n+\t(NWORDS_UP): ...this\n+\t(init_cumulative_args): Minor tweaks.\n+\t(sparc_promote_function_mode): Likewise.\n+\t(scan_record_type): Delete.\n+\t(traverse_record_type): New function template.\n+\t(classify_data_t): New structure type.\n+\t(classify_registers): New inline function.\n+\t(function_arg_slotno): In 64-bit mode, bail out early if FP slots are\n+\texhausted.  Instantiate traverse_record_type on classify_registers and\n+\tdeal with the case of a structure passed in slot #15 with no FP field\n+\tin the first word.\n+\t(assign_data_t): New structure type.\n+\t(compute_int_layout): New static function.\n+\t(compute_fp_layout): Likewise.\n+\t(count_registers): New inline function.\n+\t(assign_int_registers): New static function.\n+\t(assign_fp_registers): Likewise.\n+\t(assign_registers): New inline function.\n+\t(function_arg_record_value_1): Delete.\n+\t(function_arg_record_value_2): Likewise.\n+\t(function_arg_record_value_3): Likewise.\n+\t(function_arg_record_value): Adjust to above changes.  Instantiate\n+\ttraverse_record_type on count_registers to first count the number of\n+\tregisters to be used and then on assign_registers to assign them.\n+\t(function_arg_union_value): Adjust to above renaming.\n+\t(sparc_function_arg_1); Minor tweaks.  Remove commented out code.\n+\t(sparc_arg_partial_bytes): Adjust to above renaming.  Deal with the\n+\tcase of a structure passed in slot #15\n+\t(sparc_function_arg_advance): Likewise.\n+\t(function_arg_padding): Minor tweak.\n+\n 2016-02-29  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/69720"}, {"sha": "d077680048c6b78d297ecc9291c063efd7af971c", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 294, "deletions": 370, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84ea0f58505179d38b083f1df788adc7a4597629/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84ea0f58505179d38b083f1df788adc7a4597629/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=84ea0f58505179d38b083f1df788adc7a4597629", "patch": "@@ -518,7 +518,6 @@ int sparc_indent_opcode = 0;\n \n static void sparc_option_override (void);\n static void sparc_init_modes (void);\n-static void scan_record_type (const_tree, int *, int *, int *);\n static int function_arg_slotno (const CUMULATIVE_ARGS *, machine_mode,\n \t\t\t\tconst_tree, bool, bool, int *, int *);\n \n@@ -6086,34 +6085,29 @@ conventions.  */\n #define SPARC_INT_ARG_MAX 6\n /* Maximum number of fp regs for args.  */\n #define SPARC_FP_ARG_MAX 16\n-\n-#define ROUND_ADVANCE(SIZE) (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+/* Number of words (partially) occupied for a given size in units.  */\n+#define NWORDS_UP(SIZE) (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* Handle the INIT_CUMULATIVE_ARGS macro.\n    Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n \n void\n-init_cumulative_args (struct sparc_args *cum, tree fntype,\n-\t\t      rtx libname ATTRIBUTE_UNUSED,\n-\t\t      tree fndecl ATTRIBUTE_UNUSED)\n+init_cumulative_args (struct sparc_args *cum, tree fntype, rtx, tree)\n {\n   cum->words = 0;\n   cum->prototype_p = fntype && prototype_p (fntype);\n-  cum->libcall_p = fntype == 0;\n+  cum->libcall_p = !fntype;\n }\n \n /* Handle promotion of pointer and integer arguments.  */\n \n static machine_mode\n-sparc_promote_function_mode (const_tree type,\n-                             machine_mode mode,\n-                             int *punsignedp,\n-                             const_tree fntype ATTRIBUTE_UNUSED,\n-                             int for_return ATTRIBUTE_UNUSED)\n+sparc_promote_function_mode (const_tree type, machine_mode mode,\n+\t\t\t     int *punsignedp, const_tree, int)\n {\n-  if (type != NULL_TREE && POINTER_TYPE_P (type))\n+  if (type && POINTER_TYPE_P (type))\n     {\n       *punsignedp = POINTERS_EXTEND_UNSIGNED;\n       return Pmode;\n@@ -6135,36 +6129,75 @@ sparc_strict_argument_naming (cumulative_args_t ca ATTRIBUTE_UNUSED)\n   return TARGET_ARCH64 ? true : false;\n }\n \n-/* Scan the record type TYPE and return the following predicates:\n-    - INTREGS_P: the record contains at least one field or sub-field\n-      that is eligible for promotion in integer registers.\n-    - FP_REGS_P: the record contains at least one field or sub-field\n-      that is eligible for promotion in floating-point registers.\n-    - PACKED_P: the record contains at least one field that is packed.  */\n+/* Traverse the record TYPE recursively and call FUNC on its fields.\n+   NAMED is true if this is for a named parameter.  DATA is passed\n+   to FUNC for each field.  OFFSET is the starting position and\n+   PACKED is true if we are inside a packed record.  */\n \n+template <typename T, void Func (const_tree, HOST_WIDE_INT, bool, T*)>\n static void\n-scan_record_type (const_tree type, int *intregs_p, int *fpregs_p,\n-\t\t  int *packed_p)\n+traverse_record_type (const_tree type, bool named, T *data,\n+\t\t      HOST_WIDE_INT offset = 0, bool packed = false)\n {\n-  for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n-    {\n-      if (TREE_CODE (field) == FIELD_DECL)\n+  /* The ABI obviously doesn't specify how packed structures are passed.\n+     These are passed in integer regs if possible, otherwise memory.  */\n+  if (!packed)\n+    for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+      if (TREE_CODE (field) == FIELD_DECL && DECL_PACKED (field))\n \t{\n-\t  tree field_type = TREE_TYPE (field);\n+\t  packed = true;\n+\t  break;\n+\t}\n \n-\t  if (TREE_CODE (field_type) == RECORD_TYPE)\n-\t    scan_record_type (field_type, intregs_p, fpregs_p, packed_p);\n-\t  else if ((FLOAT_TYPE_P (field_type)\n-\t\t   || TREE_CODE (field_type) == VECTOR_TYPE)\n-\t\t  && TARGET_FPU)\n-\t    *fpregs_p = 1;\n-\t  else\n-\t    *intregs_p = 1;\n+  /* Walk the real fields, but skip those with no size or a zero size.\n+     ??? Fields with variable offset are handled as having zero offset.  */\n+  for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    if (TREE_CODE (field) == FIELD_DECL)\n+      {\n+\tif (!DECL_SIZE (field) || integer_zerop (DECL_SIZE (field)))\n+\t  continue;\n \n-\t  if (DECL_PACKED (field))\n-\t    *packed_p = 1;\n-\t}\n+\tHOST_WIDE_INT bitpos = offset;\n+\tif (TREE_CODE (DECL_FIELD_OFFSET (field)) == INTEGER_CST)\n+\t  bitpos += int_bit_position (field);\n+\n+\ttree field_type = TREE_TYPE (field);\n+\tif (TREE_CODE (field_type) == RECORD_TYPE)\n+\t  traverse_record_type<T, Func> (field_type, named, data, bitpos,\n+\t\t\t\t\t packed);\n+\telse\n+\t  {\n+\t    const bool fp_type\n+\t      = FLOAT_TYPE_P (field_type) || VECTOR_TYPE_P (field_type);\n+\t    Func (field, bitpos, fp_type && named && !packed && TARGET_FPU,\n+\t\t  data);\n+\t  }\n+      }\n+}\n+\n+/* Handle recursive register classifying for structure layout.  */\n+\n+typedef struct\n+{\n+  bool int_regs;\t/* true if field eligible to int registers.  */\n+  bool fp_regs;\t\t/* true if field eligible to FP registers.  */\n+  bool fp_regs_in_first_word;\t/* true if such field in first word.  */\n+} classify_data_t;\n+\n+/* A subroutine of function_arg_slotno.  Classify the field.  */\n+\n+inline void\n+classify_registers (const_tree, HOST_WIDE_INT bitpos, bool fp,\n+\t\t    classify_data_t *data)\n+{\n+  if (fp)\n+    {\n+      data->fp_regs = true;\n+      if (bitpos < BITS_PER_WORD)\n+\tdata->fp_regs_in_first_word = true;\n     }\n+  else\n+    data->int_regs = true;\n }\n \n /* Compute the slot number to pass an argument in.\n@@ -6178,16 +6211,16 @@ scan_record_type (const_tree type, int *intregs_p, int *fpregs_p,\n     not be available.\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).\n-   INCOMING_P is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.\n+   INCOMING is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.\n    *PREGNO records the register number to use if scalar type.\n    *PPADDING records the amount of padding needed in words.  */\n \n static int\n function_arg_slotno (const struct sparc_args *cum, machine_mode mode,\n-\t\t     const_tree type, bool named, bool incoming_p,\n+\t\t     const_tree type, bool named, bool incoming,\n \t\t     int *pregno, int *ppadding)\n {\n-  int regbase = (incoming_p\n+  int regbase = (incoming\n \t\t ? SPARC_INCOMING_INT_ARG_FIRST\n \t\t : SPARC_OUTGOING_INT_ARG_FIRST);\n   int slotno = cum->words;\n@@ -6243,8 +6276,10 @@ function_arg_slotno (const struct sparc_args *cum, machine_mode mode,\n     case MODE_VECTOR_INT:\n       if (TARGET_ARCH64 && TARGET_FPU && named)\n \t{\n+\t  /* If all arg slots are filled, then must pass on stack.  */\n \t  if (slotno >= SPARC_FP_ARG_MAX)\n \t    return -1;\n+\n \t  regno = SPARC_FP_ARG_FIRST + slotno * 2;\n \t  /* Arguments filling only one single FP register are\n \t     right-justified in the outer double FP register.  */\n@@ -6256,8 +6291,10 @@ function_arg_slotno (const struct sparc_args *cum, machine_mode mode,\n \n     case MODE_INT:\n     case MODE_COMPLEX_INT:\n+      /* If all arg slots are filled, then must pass on stack.  */\n       if (slotno >= SPARC_INT_ARG_MAX)\n \treturn -1;\n+\n       regno = regbase + slotno;\n       break;\n \n@@ -6270,42 +6307,43 @@ function_arg_slotno (const struct sparc_args *cum, machine_mode mode,\n \n       if (TARGET_ARCH32\n \t  || !type\n-\t  || (TREE_CODE (type) != VECTOR_TYPE\n-\t      && TREE_CODE (type) != RECORD_TYPE))\n+\t  || (TREE_CODE (type) != RECORD_TYPE\n+\t      && TREE_CODE (type) != VECTOR_TYPE))\n \t{\n+\t  /* If all arg slots are filled, then must pass on stack.  */\n \t  if (slotno >= SPARC_INT_ARG_MAX)\n \t    return -1;\n+\n \t  regno = regbase + slotno;\n \t}\n       else  /* TARGET_ARCH64 && type */\n \t{\n-\t  int intregs_p = 0, fpregs_p = 0, packed_p = 0;\n-\n-\t  /* First see what kinds of registers we would need.  */\n-\t  if (TREE_CODE (type) == VECTOR_TYPE)\n-\t    fpregs_p = 1;\n-\t  else\n-\t    scan_record_type (type, &intregs_p, &fpregs_p, &packed_p);\n-\n-\t  /* The ABI obviously doesn't specify how packed structures\n-\t     are passed.  These are defined to be passed in int regs\n-\t     if possible, otherwise memory.  */\n-\t  if (packed_p || !named)\n-\t    fpregs_p = 0, intregs_p = 1;\n-\n \t  /* If all arg slots are filled, then must pass on stack.  */\n-\t  if (fpregs_p && slotno >= SPARC_FP_ARG_MAX)\n+\t  if (slotno >= SPARC_FP_ARG_MAX)\n \t    return -1;\n \n-\t  /* If there are only int args and all int arg slots are filled,\n-\t     then must pass on stack.  */\n-\t  if (!fpregs_p && intregs_p && slotno >= SPARC_INT_ARG_MAX)\n-\t    return -1;\n+\t  if (TREE_CODE (type) == RECORD_TYPE)\n+\t    {\n+\t      classify_data_t data = { false, false, false };\n+\t      traverse_record_type<classify_data_t, classify_registers>\n+\t\t(type, named, &data);\n+\n+\t      /* If all slots are filled except for the last one, but there\n+\t\t is no FP field in the first word, then must pass on stack.  */\n+\t      if (data.fp_regs\n+\t\t  && !data.fp_regs_in_first_word\n+\t\t  && slotno >= SPARC_FP_ARG_MAX - 1)\n+\t\treturn -1;\n+\n+\t      /* If there are only int args and all int slots are filled,\n+\t\t then must pass on stack.  */\n+\t      if (!data.fp_regs\n+\t\t  && data.int_regs\n+\t\t  && slotno >= SPARC_INT_ARG_MAX)\n+\t\treturn -1;\n+\t    }\n \n-\t  /* Note that even if all int arg slots are filled, fp members may\n-\t     still be passed in regs if such regs are available.\n-\t     *PREGNO isn't set because there may be more than one, it's up\n-\t     to the caller to compute them.  */\n+\t  /* PREGNO isn't set since both int and FP regs can be used.  */\n \t  return slotno;\n \t}\n       break;\n@@ -6318,277 +6356,211 @@ function_arg_slotno (const struct sparc_args *cum, machine_mode mode,\n   return slotno;\n }\n \n-/* Handle recursive register counting for structure field layout.  */\n+/* Handle recursive register counting/assigning for structure layout.  */\n \n-struct function_arg_record_value_parms\n+typedef struct\n {\n-  rtx ret;\t\t/* return expression being built.  */\n   int slotno;\t\t/* slot number of the argument.  */\n-  int named;\t\t/* whether the argument is named.  */\n   int regbase;\t\t/* regno of the base register.  */\n-  int stack;\t\t/* 1 if part of the argument is on the stack.  */\n   int intoffset;\t/* offset of the first pending integer field.  */\n-  unsigned int nregs;\t/* number of words passed in registers.  */\n-};\n-\n-static void function_arg_record_value_3\n- (HOST_WIDE_INT, struct function_arg_record_value_parms *);\n-static void function_arg_record_value_2\n- (const_tree, HOST_WIDE_INT, struct function_arg_record_value_parms *, bool);\n-static void function_arg_record_value_1\n- (const_tree, HOST_WIDE_INT, struct function_arg_record_value_parms *, bool);\n-static rtx function_arg_record_value (const_tree, machine_mode, int, int, int);\n-static rtx function_arg_union_value (int, machine_mode, int, int);\n+  int nregs;\t\t/* number of words passed in registers.  */\n+  bool stack;\t\t/* true if part of the argument is on the stack.  */\n+  rtx ret;\t\t/* return expression being built.  */\n+} assign_data_t;\n \n-/* A subroutine of function_arg_record_value.  Traverse the structure\n-   recursively and determine how many registers will be required.  */\n+/* A subroutine of function_arg_record_value.  Compute the number of integer\n+   registers to be assigned between PARMS->intoffset and BITPOS.  Return\n+   true if at least one integer register is assigned or false otherwise.  */\n \n-static void\n-function_arg_record_value_1 (const_tree type, HOST_WIDE_INT startbitpos,\n-\t\t\t     struct function_arg_record_value_parms *parms,\n-\t\t\t     bool packed_p)\n+static bool\n+compute_int_layout (HOST_WIDE_INT bitpos, assign_data_t *data, int *pnregs)\n {\n-  tree field;\n+  if (data->intoffset < 0)\n+    return false;\n \n-  /* We need to compute how many registers are needed so we can\n-     allocate the PARALLEL but before we can do that we need to know\n-     whether there are any packed fields.  The ABI obviously doesn't\n-     specify how structures are passed in this case, so they are\n-     defined to be passed in int regs if possible, otherwise memory,\n-     regardless of whether there are fp values present.  */\n+  const int intoffset = data->intoffset;\n+  data->intoffset = -1;\n \n-  if (! packed_p)\n-    for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-      {\n-\tif (TREE_CODE (field) == FIELD_DECL && DECL_PACKED (field))\n-\t  {\n-\t    packed_p = true;\n-\t    break;\n-\t  }\n-      }\n+  const int this_slotno = data->slotno + intoffset / BITS_PER_WORD;\n+  const unsigned int startbit = ROUND_DOWN (intoffset, BITS_PER_WORD);\n+  const unsigned int endbit = ROUND_UP (bitpos, BITS_PER_WORD);\n+  int nregs = (endbit - startbit) / BITS_PER_WORD;\n \n-  /* Compute how many registers we need.  */\n-  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+  if (nregs > 0 && nregs > SPARC_INT_ARG_MAX - this_slotno)\n     {\n-      if (TREE_CODE (field) == FIELD_DECL)\n-\t{\n-\t  HOST_WIDE_INT bitpos = startbitpos;\n+      nregs = SPARC_INT_ARG_MAX - this_slotno;\n \n-\t  if (DECL_SIZE (field) != 0)\n-\t    {\n-\t      if (integer_zerop (DECL_SIZE (field)))\n-\t\tcontinue;\n+      /* We need to pass this field (partly) on the stack.  */\n+      data->stack = 1;\n+    }\n \n-\t      if (tree_fits_uhwi_p (bit_position (field)))\n-\t\tbitpos += int_bit_position (field);\n-\t    }\n+  if (nregs <= 0)\n+    return false;\n \n-\t  /* ??? FIXME: else assume zero offset.  */\n-\n-\t  if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n-\t    function_arg_record_value_1 (TREE_TYPE (field),\n-\t    \t\t\t\t bitpos,\n-\t\t\t\t\t parms,\n-\t\t\t\t\t packed_p);\n-\t  else if ((FLOAT_TYPE_P (TREE_TYPE (field))\n-\t\t    || TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE)\n-\t\t   && TARGET_FPU\n-\t\t   && parms->named\n-\t\t   && ! packed_p)\n-\t    {\n-\t      if (parms->intoffset != -1)\n-\t\t{\n-\t\t  unsigned int startbit, endbit;\n-\t\t  int intslots, this_slotno;\n+  *pnregs = nregs;\n+  return true;\n+}\n \n-\t\t  startbit = ROUND_DOWN (parms->intoffset, BITS_PER_WORD);\n-\t\t  endbit   = ROUND_UP (bitpos, BITS_PER_WORD);\n+/* A subroutine of function_arg_record_value.  Compute the number and the mode\n+   of the FP registers to be assigned for FIELD.  Return true if at least one\n+   FP register is assigned or false otherwise.  */\n \n-\t\t  intslots = (endbit - startbit) / BITS_PER_WORD;\n-\t\t  this_slotno = parms->slotno + parms->intoffset\n-\t\t    / BITS_PER_WORD;\n+static bool\n+compute_fp_layout (const_tree field, HOST_WIDE_INT bitpos,\n+\t\t   assign_data_t *data,\n+\t\t   int *pnregs, machine_mode *pmode)\n+{\n+  const int this_slotno = data->slotno + bitpos / BITS_PER_WORD;\n+  machine_mode mode = DECL_MODE (field);\n+  int nregs, nslots;\n \n-\t\t  if (intslots > 0 && intslots > SPARC_INT_ARG_MAX - this_slotno)\n-\t\t    {\n-\t\t      intslots = MAX (0, SPARC_INT_ARG_MAX - this_slotno);\n-\t\t      /* We need to pass this field on the stack.  */\n-\t\t      parms->stack = 1;\n-\t\t    }\n+  /* Slots are counted as words while regs are counted as having the size of\n+     the (inner) mode.  */\n+  if (TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE && mode == BLKmode)\n+    {\n+      mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (field)));\n+      nregs = TYPE_VECTOR_SUBPARTS (TREE_TYPE (field));\n+    }\n+  else if (TREE_CODE (TREE_TYPE (field)) == COMPLEX_TYPE)\n+    {\n+      mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (field)));\n+      nregs = 2;\n+    }\n+  else\n+    nregs = 1;\n \n-\t\t  parms->nregs += intslots;\n-\t\t  parms->intoffset = -1;\n-\t\t}\n+  nslots = NWORDS_UP (nregs * GET_MODE_SIZE (mode));\n \n-\t      /* There's no need to check this_slotno < SPARC_FP_ARG MAX.\n-\t\t If it wasn't true we wouldn't be here.  */\n-\t      if (TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE\n-\t\t  && DECL_MODE (field) == BLKmode)\n-\t\tparms->nregs += TYPE_VECTOR_SUBPARTS (TREE_TYPE (field));\n-\t      else if (TREE_CODE (TREE_TYPE (field)) == COMPLEX_TYPE)\n-\t\tparms->nregs += 2;\n-\t      else\n-\t\tparms->nregs += 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (parms->intoffset == -1)\n-\t\tparms->intoffset = bitpos;\n-\t    }\n-\t}\n+  if (nslots > SPARC_FP_ARG_MAX - this_slotno)\n+    {\n+      nslots = SPARC_FP_ARG_MAX - this_slotno;\n+      nregs = (nslots * UNITS_PER_WORD) / GET_MODE_SIZE (mode);\n+\n+      /* We need to pass this field (partly) on the stack.  */\n+      data->stack = 1;\n+\n+      if (nregs <= 0)\n+\treturn false;\n     }\n+\n+  *pnregs = nregs;\n+  *pmode = mode;\n+  return true;\n }\n \n-/* A subroutine of function_arg_record_value.  Assign the bits of the\n-   structure between parms->intoffset and bitpos to integer registers.  */\n+/* A subroutine of function_arg_record_value.  Count the number of registers\n+   to be assigned for FIELD and between PARMS->intoffset and BITPOS.  */\n \n-static void\n-function_arg_record_value_3 (HOST_WIDE_INT bitpos,\n-\t\t\t     struct function_arg_record_value_parms *parms)\n+inline void\n+count_registers (const_tree field, HOST_WIDE_INT bitpos, bool fp,\n+\t\t assign_data_t *data)\n {\n-  machine_mode mode;\n-  unsigned int regno;\n-  unsigned int startbit, endbit;\n-  int this_slotno, intslots, intoffset;\n-  rtx reg;\n+  if (fp)\n+    {\n+      int nregs;\n+      machine_mode mode;\n \n-  if (parms->intoffset == -1)\n-    return;\n+      if (compute_int_layout (bitpos, data, &nregs))\n+\tdata->nregs += nregs;\n \n-  intoffset = parms->intoffset;\n-  parms->intoffset = -1;\n+      if (compute_fp_layout (field, bitpos, data, &nregs, &mode))\n+\tdata->nregs += nregs;\n+    }\n+  else\n+    {\n+      if (data->intoffset < 0)\n+\tdata->intoffset = bitpos;\n+    }\n+}\n \n-  startbit = ROUND_DOWN (intoffset, BITS_PER_WORD);\n-  endbit = ROUND_UP (bitpos, BITS_PER_WORD);\n-  intslots = (endbit - startbit) / BITS_PER_WORD;\n-  this_slotno = parms->slotno + intoffset / BITS_PER_WORD;\n+/* A subroutine of function_arg_record_value.  Assign the bits of the\n+   structure between PARMS->intoffset and BITPOS to integer registers.  */\n+\n+static void\n+assign_int_registers (HOST_WIDE_INT bitpos, assign_data_t *data)\n+{\n+  int intoffset = data->intoffset;\n+  machine_mode mode;\n+  int nregs;\n \n-  intslots = MIN (intslots, SPARC_INT_ARG_MAX - this_slotno);\n-  if (intslots <= 0)\n+  if (!compute_int_layout (bitpos, data, &nregs))\n     return;\n \n   /* If this is the trailing part of a word, only load that much into\n      the register.  Otherwise load the whole register.  Note that in\n      the latter case we may pick up unwanted bits.  It's not a problem\n      at the moment but may wish to revisit.  */\n-\n   if (intoffset % BITS_PER_WORD != 0)\n     mode = smallest_mode_for_size (BITS_PER_WORD - intoffset % BITS_PER_WORD,\n \t\t\t  \t   MODE_INT);\n   else\n     mode = word_mode;\n \n+  const int this_slotno = data->slotno + intoffset / BITS_PER_WORD;\n+  unsigned int regno = data->regbase + this_slotno;\n   intoffset /= BITS_PER_UNIT;\n+\n   do\n     {\n-      regno = parms->regbase + this_slotno;\n-      reg = gen_rtx_REG (mode, regno);\n-      XVECEXP (parms->ret, 0, parms->stack + parms->nregs)\n+      rtx reg = gen_rtx_REG (mode, regno);\n+      XVECEXP (data->ret, 0, data->stack + data->nregs)\n \t= gen_rtx_EXPR_LIST (VOIDmode, reg, GEN_INT (intoffset));\n-\n-      this_slotno += 1;\n-      intoffset = (intoffset | (UNITS_PER_WORD-1)) + 1;\n+      data->nregs += 1;\n       mode = word_mode;\n-      parms->nregs += 1;\n-      intslots -= 1;\n+      regno += 1;\n+      intoffset = (intoffset | (UNITS_PER_WORD - 1)) + 1;\n     }\n-  while (intslots > 0);\n+  while (--nregs > 0);\n }\n \n-/* A subroutine of function_arg_record_value.  Traverse the structure\n-   recursively and assign bits to floating point registers.  Track which\n-   bits in between need integer registers; invoke function_arg_record_value_3\n-   to make that happen.  */\n+/* A subroutine of function_arg_record_value.  Assign FIELD at position\n+   BITPOS to FP registers.  */\n \n static void\n-function_arg_record_value_2 (const_tree type, HOST_WIDE_INT startbitpos,\n-\t\t\t     struct function_arg_record_value_parms *parms,\n-\t\t\t     bool packed_p)\n+assign_fp_registers (const_tree field, HOST_WIDE_INT bitpos,\n+\t\t\t     assign_data_t *data)\n {\n-  tree field;\n+  int nregs;\n+  machine_mode mode;\n \n-  if (! packed_p)\n-    for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n-      {\n-\tif (TREE_CODE (field) == FIELD_DECL && DECL_PACKED (field))\n-\t  {\n-\t    packed_p = true;\n-\t    break;\n-\t  }\n-      }\n+  if (!compute_fp_layout (field, bitpos, data, &nregs, &mode))\n+    return;\n+\n+  const int this_slotno = data->slotno + bitpos / BITS_PER_WORD;\n+  int regno = SPARC_FP_ARG_FIRST + this_slotno * 2;\n+  if (GET_MODE_SIZE (mode) <= 4 && (bitpos & 32) != 0)\n+    regno++;\n+  int pos = bitpos / BITS_PER_UNIT;\n \n-  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+  do\n     {\n-      if (TREE_CODE (field) == FIELD_DECL)\n-\t{\n-\t  HOST_WIDE_INT bitpos = startbitpos;\n+      rtx reg = gen_rtx_REG (mode, regno);\n+      XVECEXP (data->ret, 0, data->stack + data->nregs)\n+\t= gen_rtx_EXPR_LIST (VOIDmode, reg, GEN_INT (pos));\n+      data->nregs += 1;\n+      regno += GET_MODE_SIZE (mode) / 4;\n+      pos += GET_MODE_SIZE (mode);\n+    }\n+  while (--nregs > 0);\n+}\n \n-\t  if (DECL_SIZE (field) != 0)\n-\t    {\n-\t      if (integer_zerop (DECL_SIZE (field)))\n-\t\tcontinue;\n+/* A subroutine of function_arg_record_value.  Assign FIELD and the bits of\n+   the structure between PARMS->intoffset and BITPOS to registers.  */\n \n-\t      if (tree_fits_uhwi_p (bit_position (field)))\n-\t\tbitpos += int_bit_position (field);\n-\t    }\n+inline void\n+assign_registers (const_tree field, HOST_WIDE_INT bitpos, bool fp,\n+\t\t  assign_data_t *data)\n+{\n+  if (fp)\n+    {\n+      assign_int_registers (bitpos, data);\n \n-\t  /* ??? FIXME: else assume zero offset.  */\n-\n-\t  if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n-\t    function_arg_record_value_2 (TREE_TYPE (field),\n-\t    \t\t\t\t bitpos,\n-\t\t\t\t\t parms,\n-\t\t\t\t\t packed_p);\n-\t  else if ((FLOAT_TYPE_P (TREE_TYPE (field))\n-\t\t    || TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE)\n-\t\t   && TARGET_FPU\n-\t\t   && parms->named\n-\t\t   && ! packed_p)\n-\t    {\n-\t      int this_slotno = parms->slotno + bitpos / BITS_PER_WORD;\n-\t      int regno, nregs, pos;\n-\t      machine_mode mode = DECL_MODE (field);\n-\t      rtx reg;\n-\n-\t      function_arg_record_value_3 (bitpos, parms);\n-\n-\t      if (TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE\n-\t\t  && mode == BLKmode)\n-\t        {\n-\t\t  mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (field)));\n-\t\t  nregs = TYPE_VECTOR_SUBPARTS (TREE_TYPE (field));\n-\t\t}\n-\t      else if (TREE_CODE (TREE_TYPE (field)) == COMPLEX_TYPE)\n-\t        {\n-\t\t  mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (field)));\n-\t\t  nregs = 2;\n-\t\t}\n-\t      else\n-\t        nregs = 1;\n-\n-\t      regno = SPARC_FP_ARG_FIRST + this_slotno * 2;\n-\t      if (GET_MODE_SIZE (mode) <= 4 && (bitpos & 32) != 0)\n-\t\tregno++;\n-\t      reg = gen_rtx_REG (mode, regno);\n-\t      pos = bitpos / BITS_PER_UNIT;\n-\t      XVECEXP (parms->ret, 0, parms->stack + parms->nregs)\n-\t\t= gen_rtx_EXPR_LIST (VOIDmode, reg, GEN_INT (pos));\n-\t      parms->nregs += 1;\n-\t      while (--nregs > 0)\n-\t\t{\n-\t\t  regno += GET_MODE_SIZE (mode) / 4;\n-\t  \t  reg = gen_rtx_REG (mode, regno);\n-\t\t  pos += GET_MODE_SIZE (mode);\n-\t\t  XVECEXP (parms->ret, 0, parms->stack + parms->nregs)\n-\t\t    = gen_rtx_EXPR_LIST (VOIDmode, reg, GEN_INT (pos));\n-\t\t  parms->nregs += 1;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      if (parms->intoffset == -1)\n-\t\tparms->intoffset = bitpos;\n-\t    }\n-\t}\n+      assign_fp_registers (field, bitpos, data);\n+    }\n+  else\n+    {\n+      if (data->intoffset < 0)\n+\tdata->intoffset = bitpos;\n     }\n }\n \n@@ -6602,52 +6574,33 @@ function_arg_record_value_2 (const_tree type, HOST_WIDE_INT startbitpos,\n     not be available.\n    MODE is the argument's machine mode.\n    SLOTNO is the index number of the argument's slot in the parameter array.\n-   NAMED is nonzero if this argument is a named parameter\n+   NAMED is true if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).\n    REGBASE is the regno of the base register for the parameter array.  */\n \n static rtx\n function_arg_record_value (const_tree type, machine_mode mode,\n-\t\t\t   int slotno, int named, int regbase)\n+\t\t\t   int slotno, bool named, int regbase)\n {\n   HOST_WIDE_INT typesize = int_size_in_bytes (type);\n-  struct function_arg_record_value_parms parms;\n-  unsigned int nregs;\n+  assign_data_t data;\n+  int nregs;\n \n-  parms.ret = NULL_RTX;\n-  parms.slotno = slotno;\n-  parms.named = named;\n-  parms.regbase = regbase;\n-  parms.stack = 0;\n+  data.slotno = slotno;\n+  data.regbase = regbase;\n \n-  /* Compute how many registers we need.  */\n-  parms.nregs = 0;\n-  parms.intoffset = 0;\n-  function_arg_record_value_1 (type, 0, &parms, false);\n+  /* Count how many registers we need.  */\n+  data.nregs = 0;\n+  data.intoffset = 0;\n+  data.stack = false;\n+  traverse_record_type<assign_data_t, count_registers> (type, named, &data);\n \n   /* Take into account pending integer fields.  */\n-  if (parms.intoffset != -1)\n-    {\n-      unsigned int startbit, endbit;\n-      int intslots, this_slotno;\n-\n-      startbit = ROUND_DOWN (parms.intoffset, BITS_PER_WORD);\n-      endbit = ROUND_UP (typesize*BITS_PER_UNIT, BITS_PER_WORD);\n-      intslots = (endbit - startbit) / BITS_PER_WORD;\n-      this_slotno = slotno + parms.intoffset / BITS_PER_WORD;\n-\n-      if (intslots > 0 && intslots > SPARC_INT_ARG_MAX - this_slotno)\n-        {\n-\t  intslots = MAX (0, SPARC_INT_ARG_MAX - this_slotno);\n-\t  /* We need to pass this field on the stack.  */\n-\t  parms.stack = 1;\n-        }\n-\n-      parms.nregs += intslots;\n-    }\n+  if (compute_int_layout (typesize * BITS_PER_UNIT, &data, &nregs))\n+    data.nregs += nregs;\n \n   /* Allocate the vector and handle some annoying special cases.  */\n-  nregs = parms.nregs;\n+  nregs = data.nregs;\n \n   if (nregs == 0)\n     {\n@@ -6670,27 +6623,29 @@ function_arg_record_value (const_tree type, machine_mode mode,\n \n   gcc_assert (nregs > 0);\n \n-  parms.ret = gen_rtx_PARALLEL (mode, rtvec_alloc (parms.stack + nregs));\n+  data.ret = gen_rtx_PARALLEL (mode, rtvec_alloc (data.stack + nregs));\n \n   /* If at least one field must be passed on the stack, generate\n      (parallel [(expr_list (nil) ...) ...]) so that all fields will\n      also be passed on the stack.  We can't do much better because the\n      semantics of TARGET_ARG_PARTIAL_BYTES doesn't handle the case\n      of structures for which the fields passed exclusively in registers\n      are not at the beginning of the structure.  */\n-  if (parms.stack)\n-    XVECEXP (parms.ret, 0, 0)\n+  if (data.stack)\n+    XVECEXP (data.ret, 0, 0)\n       = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n \n-  /* Fill in the entries.  */\n-  parms.nregs = 0;\n-  parms.intoffset = 0;\n-  function_arg_record_value_2 (type, 0, &parms, false);\n-  function_arg_record_value_3 (typesize * BITS_PER_UNIT, &parms);\n+  /* Assign the registers.  */\n+  data.nregs = 0;\n+  data.intoffset = 0;\n+  traverse_record_type<assign_data_t, assign_registers> (type, named, &data);\n \n-  gcc_assert (parms.nregs == nregs);\n+  /* Assign pending integer fields.  */\n+  assign_int_registers (typesize * BITS_PER_UNIT, &data);\n \n-  return parms.ret;\n+  gcc_assert (data.nregs == nregs);\n+\n+  return data.ret;\n }\n \n /* Used by function_arg and sparc_function_value_1 to implement the conventions\n@@ -6706,7 +6661,7 @@ static rtx\n function_arg_union_value (int size, machine_mode mode, int slotno,\n \t\t\t  int regno)\n {\n-  int nwords = ROUND_ADVANCE (size), i;\n+  int nwords = NWORDS_UP (size), i;\n   rtx regs;\n \n   /* See comment in previous function for empty structures.  */\n@@ -6777,17 +6732,17 @@ function_arg_vector_value (int size, int regno)\n \n static rtx\n sparc_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n-\t\t      const_tree type, bool named, bool incoming_p)\n+\t\t      const_tree type, bool named, bool incoming)\n {\n   const CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  int regbase = (incoming_p\n+  int regbase = (incoming\n \t\t ? SPARC_INCOMING_INT_ARG_FIRST\n \t\t : SPARC_OUTGOING_INT_ARG_FIRST);\n   int slotno, regno, padding;\n   enum mode_class mclass = GET_MODE_CLASS (mode);\n \n-  slotno = function_arg_slotno (cum, mode, type, named, incoming_p,\n+  slotno = function_arg_slotno (cum, mode, type, named, incoming,\n \t\t\t\t&regno, &padding);\n   if (slotno == -1)\n     return 0;\n@@ -6837,35 +6792,7 @@ sparc_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n     {\n       rtx reg = gen_rtx_REG (mode, regno);\n       if (cum->prototype_p || cum->libcall_p)\n-\t{\n-\t  /* \"* 2\" because fp reg numbers are recorded in 4 byte\n-\t     quantities.  */\n-#if 0\n-\t  /* ??? This will cause the value to be passed in the fp reg and\n-\t     in the stack.  When a prototype exists we want to pass the\n-\t     value in the reg but reserve space on the stack.  That's an\n-\t     optimization, and is deferred [for a bit].  */\n-\t  if ((regno - SPARC_FP_ARG_FIRST) >= SPARC_INT_ARG_MAX * 2)\n-\t    return gen_rtx_PARALLEL (mode,\n-\t\t\t    gen_rtvec (2,\n-\t\t\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\tNULL_RTX, const0_rtx),\n-\t\t\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\treg, const0_rtx)));\n-\t  else\n-#else\n-\t  /* ??? It seems that passing back a register even when past\n-\t     the area declared by REG_PARM_STACK_SPACE will allocate\n-\t     space appropriately, and will not copy the data onto the\n-\t     stack, exactly as we desire.\n-\n-\t     This is due to locate_and_pad_parm being called in\n-\t     expand_call whenever reg_parm_stack_space > 0, which\n-\t     while beneficial to our example here, would seem to be\n-\t     in error from what had been intended.  Ho hum...  -- r~ */\n-#endif\n-\t    return reg;\n-\t}\n+\treturn reg;\n       else\n \t{\n \t  rtx v0, v1;\n@@ -6877,7 +6804,7 @@ sparc_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n \t      /* On incoming, we don't need to know that the value\n \t\t is passed in %f0 and %i0, and it confuses other parts\n \t\t causing needless spillage even on the simplest cases.  */\n-\t      if (incoming_p)\n+\t      if (incoming)\n \t\treturn reg;\n \n \t      intreg = (SPARC_OUTGOING_INT_ARG_FIRST\n@@ -6956,7 +6883,7 @@ sparc_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n {\n   int slotno, regno, padding;\n \n-  /* We pass false for incoming_p here, it doesn't matter.  */\n+  /* We pass false for incoming here, it doesn't matter.  */\n   slotno = function_arg_slotno (get_cumulative_args (cum), mode, type, named,\n \t\t\t\tfalse, &regno, &padding);\n \n@@ -6966,8 +6893,8 @@ sparc_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n   if (TARGET_ARCH32)\n     {\n       if ((slotno + (mode == BLKmode\n-\t\t     ? ROUND_ADVANCE (int_size_in_bytes (type))\n-\t\t     : ROUND_ADVANCE (GET_MODE_SIZE (mode))))\n+\t\t     ? NWORDS_UP (int_size_in_bytes (type))\n+\t\t     : NWORDS_UP (GET_MODE_SIZE (mode))))\n \t  > SPARC_INT_ARG_MAX)\n \treturn (SPARC_INT_ARG_MAX - slotno) * UNITS_PER_WORD;\n     }\n@@ -6982,7 +6909,8 @@ sparc_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n \t  int size = int_size_in_bytes (type);\n \n \t  if (size > UNITS_PER_WORD\n-\t      && slotno == SPARC_INT_ARG_MAX - 1)\n+\t      && (slotno == SPARC_INT_ARG_MAX - 1\n+\t\t  || slotno == SPARC_FP_ARG_MAX - 1))\n \t    return UNITS_PER_WORD;\n \t}\n       else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT\n@@ -7068,18 +6996,16 @@ sparc_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int regno, padding;\n \n-  /* We pass false for incoming_p here, it doesn't matter.  */\n+  /* We pass false for incoming here, it doesn't matter.  */\n   function_arg_slotno (cum, mode, type, named, false, &regno, &padding);\n \n   /* If argument requires leading padding, add it.  */\n   cum->words += padding;\n \n   if (TARGET_ARCH32)\n-    {\n-      cum->words += (mode != BLKmode\n-\t\t     ? ROUND_ADVANCE (GET_MODE_SIZE (mode))\n-\t\t     : ROUND_ADVANCE (int_size_in_bytes (type)));\n-    }\n+    cum->words += (mode == BLKmode\n+\t\t   ? NWORDS_UP (int_size_in_bytes (type))\n+\t\t   : NWORDS_UP (GET_MODE_SIZE (mode)));\n   else\n     {\n       if (type && AGGREGATE_TYPE_P (type))\n@@ -7094,11 +7020,9 @@ sparc_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t    ++cum->words;\n \t}\n       else\n-\t{\n-\t  cum->words += (mode != BLKmode\n-\t\t\t ? ROUND_ADVANCE (GET_MODE_SIZE (mode))\n-\t\t\t : ROUND_ADVANCE (int_size_in_bytes (type)));\n-\t}\n+\tcum->words += (mode == BLKmode\n+\t\t       ? NWORDS_UP (int_size_in_bytes (type))\n+\t\t       : NWORDS_UP (GET_MODE_SIZE (mode)));\n     }\n }\n \n@@ -7109,7 +7033,7 @@ sparc_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n enum direction\n function_arg_padding (machine_mode mode, const_tree type)\n {\n-  if (TARGET_ARCH64 && type != 0 && AGGREGATE_TYPE_P (type))\n+  if (TARGET_ARCH64 && type && AGGREGATE_TYPE_P (type))\n     return upward;\n \n   /* Fall back to the default.  */"}, {"sha": "e5ec39c67f7b9d56c8c9c162d62f834062e263f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84ea0f58505179d38b083f1df788adc7a4597629/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84ea0f58505179d38b083f1df788adc7a4597629/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=84ea0f58505179d38b083f1df788adc7a4597629", "patch": "@@ -1,3 +1,7 @@\n+2016-02-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/sparc/20160229-1.c: New test.\n+\n 2016-02-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/stack_usage3.adb: New test."}, {"sha": "c64b7a83540686fb11a6db743a979a258083b0c3", "filename": "gcc/testsuite/gcc.target/sparc/20160229-1.c", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84ea0f58505179d38b083f1df788adc7a4597629/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20160229-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84ea0f58505179d38b083f1df788adc7a4597629/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20160229-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20160229-1.c?ref=84ea0f58505179d38b083f1df788adc7a4597629", "patch": "@@ -0,0 +1,157 @@\n+/* PR target/69706 */\n+/* Reported by John Paul Adrian Glaubitz <glaubitz@physik.fu-berlin.de> */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" }\n+/* { dg-require-effective-target lp64 } */\n+\n+extern void abort (void);\n+\n+\n+/* Pass a 12-byte structure partially in slot #15 and on the stack.  */\n+\n+struct t_rgb { float r, g, b; };\n+\n+void write_xpm (void *out, unsigned int flags, const char *title, \n+\t        const char *legend, const char *label_x, const char *label_y,\n+\t        int n_x, int n_y, float axis_x[], float axis_y[], float *mat[],\n+\t        float lo, float hi, struct t_rgb rlo, struct t_rgb rhi)\n+{\n+  register float f30 asm (\"f30\");\n+  register float f31 asm (\"f31\");\n+\n+  if (f30 != 1.0f)\n+    abort ();\n+\n+  if (f31 != 2.0f)\n+    abort ();\n+\n+  if (rhi.r != 1.0f)\n+    abort ();\n+\n+  if (rhi.g != 2.0f)\n+    abort ();\n+\n+  if (rhi.b != 3.0f)\n+    abort ();\n+}\n+\n+\n+/* Pass a 16-byte structure partially in slot #15 and on the stack.  */\n+\n+struct S1 { _Complex float f1; _Complex float f2; };\n+\n+void f1 (int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8,\n+\t int p9, int p10, int p11, int p12, int p13, int p14, int p15,\n+\t struct S1 s1)\n+{\n+  register float f30 asm (\"f30\");\n+  register float f31 asm (\"f31\");\n+\n+  if (f30 != 4.0f)\n+    abort ();\n+\n+  if (f31 != 5.0f)\n+    abort ();\n+\n+  if (__real__ s1.f1 != 4.0f)\n+    abort ();\n+\n+  if (__imag__ s1.f1 != 5.0f)\n+    abort ();\n+\n+  if (__real__ s1.f2 != 6.0f)\n+    abort ();\n+\n+  if (__imag__ s1.f2 != 7.0f)\n+    abort ();\n+}\n+\n+\n+/* Pass a 16-byte structure partially in slot #15 and on the stack.  */\n+\n+struct S2 { double d1; double d2; };\n+\n+void f2 (int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8,\n+\t int p9, int p10, int p11, int p12, int p13, int p14, int p15,\n+\t struct S2 s2)\n+{\n+  register double d30 asm (\"f30\");\n+\n+  if (d30 != 1.0)\n+    abort ();\n+\n+  if (s2.d1 != 1.0)\n+    abort ();\n+\n+  if (s2.d2 != 2.0)\n+    abort ();\n+}\n+\n+\n+/* Pass a 16-byte structure partially in slot #15 and on the stack.  */\n+\n+struct S3 { _Complex double d; };\n+\n+void f3 (int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8,\n+\t int p9, int p10, int p11, int p12, int p13, int p14, int p15,\n+\t struct S3 s3)\n+{\n+  register double d30 asm (\"f30\");\n+\n+  if (d30 != 3.0)\n+    abort ();\n+\n+  if (__real__ s3.d != 3.0)\n+    abort ();\n+\n+  if (__imag__ s3.d != 4.0)\n+    abort ();\n+}\n+\n+\n+/* Pass a 16-byte structure entirely on the stack.  */\n+\n+struct S4 { long l; double d; };\n+\n+void f4 (int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8,\n+\t int p9, int p10, int p11, int p12, int p13, int p14, int p15,\n+\t struct S4 s4)\n+{\n+  if (s4.l != 5)\n+    abort ();\n+\n+  if (s4.d != 6.0)\n+    abort ();\n+}\n+\n+\n+#define PI 3.141592654\n+\n+int main (void)\n+{\n+  struct t_rgb lo = { -1.0f, -2.0f, -3.0f };\n+  struct t_rgb hi = { 1.0f, 2.0f, 3.0f };\n+  float arrf[1];\n+  float *arrp[1];\n+  struct S1 s1 = { 4.0f + 5.0fi, 6.0f + 7.0fi };\n+  struct S2 s2 = { 1.0, 2.0 };\n+  struct S3 s3 = { 3.0 + 4.0i };\n+  struct S4 s4 = { 5, 6.0 };\n+  register double d32 asm (\"f32\") = PI;\n+\n+  write_xpm (0, 0, \"\", \"\", \"\", \"\", 0, 0, arrf, arrf, arrp, 0.0f, 0.0f, lo, hi);\n+\n+  f1 (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, s1);\n+\n+  f2 (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, s2);\n+\n+  f3 (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, s3);\n+\n+  f4 (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, s4);\n+\n+  if (d32 != PI)\n+    abort ();\n+\n+  return 0;\n+}"}]}