{"sha": "07a8bdf810ac5dba4ad7d287b95c907faab88a77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdhOGJkZjgxMGFjNWRiYTRhZDdkMjg3Yjk1YzkwN2ZhYWI4OGE3Nw==", "commit": {"author": {"name": "Kelley Cook", "email": "kcook@gcc.gnu.org", "date": "2004-09-24T11:14:51Z"}, "committer": {"name": "R. Kelley Cook", "email": "kcook@gcc.gnu.org", "date": "2004-09-24T11:14:51Z"}, "message": "* Revert to previous version due to Binutils breakage.\n\nFrom-SVN: r88026", "tree": {"sha": "1944dae0c76e9f7cda211717646286b80485b0e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1944dae0c76e9f7cda211717646286b80485b0e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07a8bdf810ac5dba4ad7d287b95c907faab88a77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a8bdf810ac5dba4ad7d287b95c907faab88a77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07a8bdf810ac5dba4ad7d287b95c907faab88a77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a8bdf810ac5dba4ad7d287b95c907faab88a77/comments", "author": null, "committer": null, "parents": [{"sha": "28c23a8cd3cbda3333f7f6dd7b519c2adac351d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28c23a8cd3cbda3333f7f6dd7b519c2adac351d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28c23a8cd3cbda3333f7f6dd7b519c2adac351d7"}], "stats": {"total": 245, "additions": 75, "deletions": 170}, "files": [{"sha": "952e282196daa7dcaaf9a60b4bb466ee19b10a82", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a8bdf810ac5dba4ad7d287b95c907faab88a77/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a8bdf810ac5dba4ad7d287b95c907faab88a77/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=07a8bdf810ac5dba4ad7d287b95c907faab88a77", "patch": "@@ -1,3 +1,7 @@\n+2004-09-24  Kelley Cook <kcook@gcc.gnu.org>\n+\n+\t* ylwrap: Revert to previous version.\n+\n 2004-09-23  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR bootstrap/17369"}, {"sha": "2288ccde3ac14b2e968b92d2260c130e8becebee", "filename": "ylwrap", "status": "modified", "additions": 71, "deletions": 170, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a8bdf810ac5dba4ad7d287b95c907faab88a77/ylwrap", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a8bdf810ac5dba4ad7d287b95c907faab88a77/ylwrap", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ylwrap?ref=07a8bdf810ac5dba4ad7d287b95c907faab88a77", "patch": "@@ -1,11 +1,6 @@\n #! /bin/sh\n # ylwrap - wrapper for lex/yacc invocations.\n-\n-scriptversion=2004-09-10.20\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004\n-#   Free Software Foundation, Inc.\n-#\n+# Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n # Written by Tom Tromey <tromey@cygnus.com>.\n #\n # This program is free software; you can redistribute it and/or modify\n@@ -22,201 +17,107 @@ scriptversion=2004-09-10.20\n # along with this program; if not, write to the Free Software\n # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n-# As a special exception to the GNU General Public License, if you\n-# distribute this file as part of a program that contains a\n-# configuration script generated by Autoconf, you may include it under\n-# the same distribution terms that you use for the rest of that program.\n+# Usage:\n+#     ylwrap PROGRAM INPUT [OUTPUT DESIRED]... -- [ARGS]...\n+# * PROGRAM is program to run.\n+# * INPUT is the input file\n+# * OUTPUT is file PROG generates\n+# * DESIRED is file we actually want\n+# * ARGS are passed to PROG\n+# Any number of OUTPUT,DESIRED pairs may be used.\n \n-# This file is maintained in Automake, please report\n-# bugs to <bug-automake@gnu.org> or send patches to\n-# <automake-patches@gnu.org>.\n-\n-case \"$1\" in\n-  '')\n-    echo \"$0: No files given.  Try \\`$0 --help' for more information.\" 1>&2\n-    exit 1\n-    ;;\n-  --basedir)\n-    basedir=$2\n-    shift 2\n-    ;;\n-  -h|--h*)\n-    cat <<\\EOF\n-Usage: ylwrap [--help|--version] INPUT [OUTPUT DESIRED]... -- PROGRAM [ARGS]...\n-\n-Wrapper for lex/yacc invocations, renaming files as desired.\n-\n-  INPUT is the input file\n-  OUTPUT is one file PROG generates\n-  DESIRED is the file we actually want instead of OUTPUT\n-  PROGRAM is program to run\n-  ARGS are passed to PROG\n-\n-Any number of OUTPUT,DESIRED pairs may be used.\n-\n-Report bugs to <bug-automake@gnu.org>.\n-EOF\n-    exit 0\n-    ;;\n-  -v|--v*)\n-    echo \"ylwrap $scriptversion\"\n-    exit 0\n-    ;;\n+# The program to run.\n+prog=\"$1\"\n+shift\n+# Make any relative path in $prog absolute.\n+case \"$prog\" in\n+ /* | [A-Za-z]:\\\\*) ;;\n+ */*) prog=\"`pwd`/$prog\" ;;\n esac\n \n-\n # The input.\n input=\"$1\"\n shift\n case \"$input\" in\n-  [\\\\/]* | ?:[\\\\/]*)\n+ /* | [A-Za-z]:\\\\*)\n     # Absolute path; do nothing.\n     ;;\n-  *)\n-    # Relative path.  Make it absolute.\n+ *)\n+    # Relative path.  Make it absolute.  Why?  Because otherwise any\n+    # debugging info in the generated file will point to the wrong\n+    # place.  This is really gross.\n     input=\"`pwd`/$input\"\n     ;;\n esac\n \n+# We don't want to use the absolute path if the input in the current\n+# directory like when making a tar ball.\n+input_base=`echo $input | sed -e 's|.*/||'`\n+if test -f $input_base && cmp $input_base $input >/dev/null 2>&1; then\n+  input=$input_base\n+fi\n+\n pairlist=\n while test \"$#\" -ne 0; do\n-  if test \"$1\" = \"--\"; then\n-    shift\n-    break\n-  fi\n-  pairlist=\"$pairlist $1\"\n-  shift\n+   if test \"$1\" = \"--\"; then\n+      shift\n+      break\n+   fi\n+   pairlist=\"$pairlist $1\"\n+   shift\n done\n \n-# The program to run.\n-prog=\"$1\"\n-shift\n-# Make any relative path in $prog absolute.\n-case \"$prog\" in\n-  [\\\\/]* | ?:[\\\\/]*) ;;\n-  *[\\\\/]*) prog=\"`pwd`/$prog\" ;;\n-esac\n-\n # FIXME: add hostname here for parallel makes that run commands on\n # other machines.  But that might take us over the 14-char limit.\n dirname=ylwrap$$\n trap \"cd `pwd`; rm -rf $dirname > /dev/null 2>&1\" 1 2 3 15\n mkdir $dirname || exit 1\n \n cd $dirname\n-\n-case $# in\n-  0) $prog \"$input\" ;;\n-  *) $prog \"$@\" \"$input\" ;;\n+case \"$input\" in\n+ /* | [A-Za-z]:\\\\*)\n+    # Absolute path; do nothing.\n+    ;;\n+ *)\n+    # Make a symbolic link, hard link or hardcopy.\n+    ln -s ../\"$input\" . > /dev/null 2>&1 || ln ../\"$input\" . > /dev/null 2>&1 || cp ../\"$input\" .\n+    ;;\n esac\n-ret=$?\n-\n-if test $ret -eq 0; then\n-  set X $pairlist\n-  shift\n-  first=yes\n-  # Since DOS filename conventions don't allow two dots,\n-  # the DOS version of Bison writes out y_tab.c instead of y.tab.c\n-  # and y_tab.h instead of y.tab.h. Test to see if this is the case.\n-  y_tab_nodot=\"no\"\n-  if test -f y_tab.c || test -f y_tab.h; then\n-    y_tab_nodot=\"yes\"\n-  fi\n-\n-  # The directory holding the input.\n-  input_dir=`echo \"$input\" | sed -e 's,\\([\\\\/]\\)[^\\\\/]*$,\\1,'`\n-  # Quote $INPUT_DIR so we can use it in a regexp.\n-  # FIXME: really we should care about more than `.' and `\\'.\n-  input_rx=`echo \"$input_dir\" | sed 's,\\\\\\\\,\\\\\\\\\\\\\\\\,g;s,\\\\.,\\\\\\\\.,g'`\n-\n-  while test \"$#\" -ne 0; do\n-    from=\"$1\"\n-    # Handle y_tab.c and y_tab.h output by DOS\n-    if test $y_tab_nodot = \"yes\"; then\n-      if test $from = \"y.tab.c\"; then\n-    \tfrom=\"y_tab.c\"\n+$prog ${1+\"$@\"} \"$input\"\n+status=$?\n+\n+if test $status -eq 0; then\n+   set X $pairlist\n+   shift\n+   first=yes\n+   while test \"$#\" -ne 0; do\n+      if test -f \"$1\"; then\n+         # If $2 is an absolute path name, then just use that,\n+         # otherwise prepend `../'.\n+         case \"$2\" in\n+\t   /* | [A-Za-z]:\\\\*) target=\"$2\";;\n+\t   *) target=\"../$2\";;\n+\t esac\n+\t mv \"$1\" \"$target\" || status=$?\n       else\n-    \tif test $from = \"y.tab.h\"; then\n-    \t  from=\"y_tab.h\"\n-    \tfi\n-      fi\n-    fi\n-    if test -f \"$from\"; then\n-      # If $2 is an absolute path name, then just use that,\n-      # otherwise prepend `../'.\n-      case \"$2\" in\n-    \t[\\\\/]* | ?:[\\\\/]*) target=\"$2\";;\n-    \t*) target=\"../$2\";;\n-      esac\n-\n-      # We do not want to overwrite a header file if it hasn't\n-      # changed.  This avoid useless recompilations.  However the\n-      # parser itself (the first file) should always be updated,\n-      # because it is the destination of the .y.c rule in the\n-      # Makefile.  Divert the output of all other files to a temporary\n-      # file so we can compare them to existing versions.\n-      if test $first = no; then\n-\trealtarget=\"$target\"\n-\ttarget=\"tmp-`echo $target | sed s/.*[\\\\/]//g`\"\n+\t # A missing file is only an error for the first file.  This\n+\t # is a blatant hack to let us support using \"yacc -d\".  If -d\n+\t # is not specified, we don't want an error when the header\n+\t # file is \"missing\".\n+\t if test $first = yes; then\n+\t    status=1\n+\t fi\n       fi\n-      # Edit out `#line' or `#' directives.\n-      #\n-      # We don't want the resulting debug information to point at\n-      # an absolute srcdir; it is better for it to just mention the\n-      # .y file with no path.\n-      #\n-      # We want to use the real output file name, not yy.lex.c for\n-      # instance.\n-      #\n-      # We want the include guards to be adjusted too.\n-      FROM=`echo \"$from\" | sed \\\n-            -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'\\\n-            -e 's/[^ABCDEFGHIJKLMNOPQRSTUVWXYZ]/_/g'`\n-      TARGET=`echo \"$2\" | sed \\\n-            -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'\\\n-            -e 's/[^ABCDEFGHIJKLMNOPQRSTUVWXYZ]/_/g'`\n-\n-      sed -e \"/^#/!b\" -e \"s,$input_rx,,\" -e \"s,$from,$2,\" \\\n-          -e \"s,$FROM,$TARGET,\" \"$from\" >\"$target\" || ret=$?\n-\n-      # Check whether header files must be updated.\n-      if test $first = no; then\n-\tif test -f \"$realtarget\" && cmp -s \"$realtarget\" \"$target\"; then\n-\t  echo \"$2\" is unchanged\n-\t  rm -f \"$target\"\n-\telse\n-          echo updating \"$2\"\n-          mv -f \"$target\" \"$realtarget\"\n-        fi\n-      fi\n-    else\n-      # A missing file is only an error for the first file.  This\n-      # is a blatant hack to let us support using \"yacc -d\".  If -d\n-      # is not specified, we don't want an error when the header\n-      # file is \"missing\".\n-      if test $first = yes; then\n-        ret=1\n-      fi\n-    fi\n-    shift\n-    shift\n-    first=no\n-  done\n+      shift\n+      shift\n+      first=no\n+   done\n else\n-  ret=$?\n+   status=$?\n fi\n \n # Remove the directory.\n cd ..\n rm -rf $dirname\n \n-exit $ret\n-\n-# Local Variables:\n-# mode: shell-script\n-# sh-indentation: 2\n-# eval: (add-hook 'write-file-hooks 'time-stamp)\n-# time-stamp-start: \"scriptversion=\"\n-# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n-# time-stamp-end: \"$\"\n-# End:\n+exit $status"}]}