{"sha": "f9ac2f95ec83f10ccc2266ccba9755b9466008d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlhYzJmOTVlYzgzZjEwY2NjMjI2NmNjYmE5NzU1Yjk0NjYwMDhkOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-01-07T16:02:20Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-01-07T16:02:20Z"}, "message": "h8300.c (output_logical_op): Simplify and optimize the handling of SImode.\n\n\t* config/h8300/h8300.c (output_logical_op): Simplify and\n\toptimize the handling of SImode.\n\t* config/h8300/h8300.c (compute_logical_op_length): Update\n\taccordingly.\n\t* config/h8300/h8300.c (compute_logical_op_cc): Likewise.\n\nFrom-SVN: r60995", "tree": {"sha": "0666458d633ce85b9280c444d0f41e6714a4b499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0666458d633ce85b9280c444d0f41e6714a4b499"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9ac2f95ec83f10ccc2266ccba9755b9466008d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9ac2f95ec83f10ccc2266ccba9755b9466008d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9ac2f95ec83f10ccc2266ccba9755b9466008d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9ac2f95ec83f10ccc2266ccba9755b9466008d8/comments", "author": null, "committer": null, "parents": [{"sha": "c93721124b765f21e04fb1d3031510ac86dbd41e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93721124b765f21e04fb1d3031510ac86dbd41e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c93721124b765f21e04fb1d3031510ac86dbd41e"}], "stats": {"total": 116, "additions": 80, "deletions": 36}, "files": [{"sha": "03b0d83ac7bff04d7b7804ff08ea5cfa68e6c897", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9ac2f95ec83f10ccc2266ccba9755b9466008d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9ac2f95ec83f10ccc2266ccba9755b9466008d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9ac2f95ec83f10ccc2266ccba9755b9466008d8", "patch": "@@ -1,3 +1,11 @@\n+2003-01-07  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/h8300.c (output_logical_op): Simplify and\n+\toptimize the handling of SImode.\n+\t* config/h8300/h8300.c (compute_logical_op_length): Update\n+\taccordingly.\n+\t* config/h8300/h8300.c (compute_logical_op_cc): Likewise.\n+\n 2003-01-07  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (mips_va_arg): In the EABI code, apply the"}, {"sha": "d7e521900bbe8a133c0d935bb66df30432704a08", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 72, "deletions": 36, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9ac2f95ec83f10ccc2266ccba9755b9466008d8/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9ac2f95ec83f10ccc2266ccba9755b9466008d8/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=f9ac2f95ec83f10ccc2266ccba9755b9466008d8", "patch": "@@ -2061,6 +2061,13 @@ output_logical_op (mode, operands)\n   /* The determinant of the algorithm.  If we perform an AND, 0\n      affects a bit.  Otherwise, 1 affects a bit.  */\n   const unsigned HOST_WIDE_INT det = (code != AND) ? intval : ~intval;\n+  /* Break up DET into pieces.  */\n+  const unsigned HOST_WIDE_INT b0 = (det >>  0) & 0xff;\n+  const unsigned HOST_WIDE_INT b1 = (det >>  8) & 0xff;\n+  const unsigned HOST_WIDE_INT w0 = (det >>  0) & 0xffff;\n+  const unsigned HOST_WIDE_INT w1 = (det >> 16) & 0xffff;\n+  int lower_half_easy_p = 0;\n+  int upper_half_easy_p = 0;\n   /* The name of an insn.  */\n   const char *opname;\n   char insn_buf[100];\n@@ -2108,20 +2115,25 @@ output_logical_op (mode, operands)\n \t}\n       break;\n     case SImode:\n-      /* First, see if we can finish with one insn.\n+      if (TARGET_H8300H || TARGET_H8300S)\n+\t{\n+\t  /* Determine if the lower half can be taken care of in no more\n+\t     than two bytes.  */\n+\t  lower_half_easy_p = (b0 == 0\n+\t\t\t       || b1 == 0\n+\t\t\t       || (code != IOR && w0 == 0xffff));\n+\n+\t  /* Determine if the upper half can be taken care of in no more\n+\t     than two bytes.  */\n+\t  upper_half_easy_p = ((code != IOR && w1 == 0xffff)\n+\t\t\t       || (code == AND && w1 == 0xff00));\n+\t}\n \n-\t If code is either AND or XOR, we exclude two special cases,\n-\t 0xffffff00 and 0xffff00ff, because insns like sub.w or not.w\n-\t can do a better job.  */\n+      /* Check if doing everything with one insn is no worse than\n+\t using multiple insns.  */\n       if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && ((det & 0x0000ffff) != 0)\n-\t  && ((det & 0xffff0000) != 0)\n-\t  && (code == IOR || det != 0xffffff00)\n-\t  && (code == IOR || det != 0xffff00ff)\n-\t  && !(code == AND\n-\t       && (det == 0xff00ffff\n-\t\t   || (det & 0xffff00ff) == 0xff000000\n-\t\t   || (det & 0xffffff00) == 0xff000000)))\n+\t  && w0 != 0 && w1 != 0\n+\t  && !(lower_half_easy_p && upper_half_easy_p))\n \t{\n \t  sprintf (insn_buf, \"%s.l\\t%%S2,%%S0\", opname);\n \t  output_asm_insn (insn_buf, operands);\n@@ -2214,6 +2226,13 @@ compute_logical_op_length (mode, operands)\n   /* The determinant of the algorithm.  If we perform an AND, 0\n      affects a bit.  Otherwise, 1 affects a bit.  */\n   const unsigned HOST_WIDE_INT det = (code != AND) ? intval : ~intval;\n+  /* Break up DET into pieces.  */\n+  const unsigned HOST_WIDE_INT b0 = (det >>  0) & 0xff;\n+  const unsigned HOST_WIDE_INT b1 = (det >>  8) & 0xff;\n+  const unsigned HOST_WIDE_INT w0 = (det >>  0) & 0xffff;\n+  const unsigned HOST_WIDE_INT w1 = (det >> 16) & 0xffff;\n+  int lower_half_easy_p = 0;\n+  int upper_half_easy_p = 0;\n   /* Insn length.  */\n   unsigned int length = 0;\n \n@@ -2242,20 +2261,25 @@ compute_logical_op_length (mode, operands)\n \t}\n       break;\n     case SImode:\n-      /* First, see if we can finish with one insn.\n+      if (TARGET_H8300H || TARGET_H8300S)\n+\t{\n+\t  /* Determine if the lower half can be taken care of in no more\n+\t     than two bytes.  */\n+\t  lower_half_easy_p = (b0 == 0\n+\t\t\t       || b1 == 0\n+\t\t\t       || (code != IOR && w0 == 0xffff));\n+\n+\t  /* Determine if the upper half can be taken care of in no more\n+\t     than two bytes.  */\n+\t  upper_half_easy_p = ((code != IOR && w1 == 0xffff)\n+\t\t\t       || (code == AND && w1 == 0xff00));\n+\t}\n \n-\t If code is either AND or XOR, we exclude two special cases,\n-\t 0xffffff00 and 0xffff00ff, because insns like sub.w or not.w\n-\t can do a better job.  */\n+      /* Check if doing everything with one insn is no worse than\n+\t using multiple insns.  */\n       if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && ((det & 0x0000ffff) != 0)\n-\t  && ((det & 0xffff0000) != 0)\n-\t  && (code == IOR || det != 0xffffff00)\n-\t  && (code == IOR || det != 0xffff00ff)\n-\t  && !(code == AND\n-\t       && (det == 0xff00ffff\n-\t\t   || (det & 0xffff00ff) == 0xff000000\n-\t\t   || (det & 0xffffff00) == 0xff000000)))\n+\t  && w0 != 0 && w1 != 0\n+\t  && !(lower_half_easy_p && upper_half_easy_p))\n \t{\n \t  if (REG_P (operands[2]))\n \t    length += 4;\n@@ -2336,6 +2360,13 @@ compute_logical_op_cc (mode, operands)\n   /* The determinant of the algorithm.  If we perform an AND, 0\n      affects a bit.  Otherwise, 1 affects a bit.  */\n   const unsigned HOST_WIDE_INT det = (code != AND) ? intval : ~intval;\n+  /* Break up DET into pieces.  */\n+  const unsigned HOST_WIDE_INT b0 = (det >>  0) & 0xff;\n+  const unsigned HOST_WIDE_INT b1 = (det >>  8) & 0xff;\n+  const unsigned HOST_WIDE_INT w0 = (det >>  0) & 0xffff;\n+  const unsigned HOST_WIDE_INT w1 = (det >> 16) & 0xffff;\n+  int lower_half_easy_p = 0;\n+  int upper_half_easy_p = 0;\n   /* Condition code.  */\n   enum attr_cc cc = CC_CLOBBER;\n \n@@ -2351,20 +2382,25 @@ compute_logical_op_cc (mode, operands)\n \t}\n       break;\n     case SImode:\n-      /* First, see if we can finish with one insn.\n+      if (TARGET_H8300H || TARGET_H8300S)\n+\t{\n+\t  /* Determine if the lower half can be taken care of in no more\n+\t     than two bytes.  */\n+\t  lower_half_easy_p = (b0 == 0\n+\t\t\t       || b1 == 0\n+\t\t\t       || (code != IOR && w0 == 0xffff));\n+\n+\t  /* Determine if the upper half can be taken care of in no more\n+\t     than two bytes.  */\n+\t  upper_half_easy_p = ((code != IOR && w1 == 0xffff)\n+\t\t\t       || (code == AND && w1 == 0xff00));\n+\t}\n \n-\t If code is either AND or XOR, we exclude two special cases,\n-\t 0xffffff00 and 0xffff00ff, because insns like sub.w or not.w\n-\t can do a better job.  */\n+      /* Check if doing everything with one insn is no worse than\n+\t using multiple insns.  */\n       if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && ((det & 0x0000ffff) != 0)\n-\t  && ((det & 0xffff0000) != 0)\n-\t  && (code == IOR || det != 0xffffff00)\n-\t  && (code == IOR || det != 0xffff00ff)\n-\t  && !(code == AND\n-\t       && (det == 0xff00ffff\n-\t\t   || (det & 0xffff00ff) == 0xff000000\n-\t\t   || (det & 0xffffff00) == 0xff000000)))\n+\t  && w0 != 0 && w1 != 0\n+\t  && !(lower_half_easy_p && upper_half_easy_p))\n \t{\n \t  cc = CC_SET_ZNV;\n \t}"}]}