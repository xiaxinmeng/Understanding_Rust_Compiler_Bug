{"sha": "8410904a77b9238a1b65798a0fcd92f340ffe0ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQxMDkwNGE3N2I5MjM4YTFiNjU3OThhMGZjZDkyZjM0MGZmZTBjYQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2015-01-27T11:36:01Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2015-01-27T11:36:01Z"}, "message": "cmpsi2.S: Use function start and end macros.\n\n\t* config/rl78/cmpsi2.S: Use function start and end macros.\n\t(__gcc_bcmp): New function.\n\t* config/rl78/lshrsi3.S: Use function start and end macros.\n\t* config/rl78/mulsi3.S: Add support for G10.\n\t(__mulqi3): New function for G10.\n\t* config/rl78/signbit.S: Use function start and end macros.\n\t* config/rl78/t-rl78 (LIB2ADD): Add bit-count.S, fpbit-sf.S and\n\tfpmath-sf.S.\n\t(LIB2FUNCS_EXCLUDE): Define.\n\t(LIB2FUNCS_ST): Define.\n\t* config/rl78/trampoline.S: Use function start and end macros.\n\t* config/rl78/vregs.h (START_FUNC): New macro.\n\t(START_ANOTHER_FUNC): New macro.\n\t(END_FUNC): New macro.\n\t(END_ANOTHER_FUNC): New macro.\n\t* config/rl78/bit-count.S: New file.  Contains assembler\n\timplementations of the bit counting functions: ___clzhi2,\n\t__clzsi2, ctzhi2, ctzsi2, ffshi2, ffssi2, __partityhi2,\n\t__paritysi2, __popcounthi2 and __popcountsi2.\n\t* config/rl78/fpbit-sf.S: New file.  Contains assembler\n\timplementationas of the math functions: __negsf2, __cmpsf2,\n\t__eqsf2, __nesf2, __lesf2, __ltsf2, __gesf2, gtsf2, __unordsf2,\n\t__fixsfsi,  __fixunssfsi, __floatsisf and __floatunssisf.\n\t* config/rl78/fpmath-sf.S: New file.  Contains assembler\n\timplementations of the math functions: __subsf3, __addsf3,\n\t__mulsf3 and __divsf3\n\nFrom-SVN: r220162", "tree": {"sha": "969cf563af72951fa4e504d4f6e8554327091aeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/969cf563af72951fa4e504d4f6e8554327091aeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8410904a77b9238a1b65798a0fcd92f340ffe0ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8410904a77b9238a1b65798a0fcd92f340ffe0ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8410904a77b9238a1b65798a0fcd92f340ffe0ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8410904a77b9238a1b65798a0fcd92f340ffe0ca/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "506f03c370e7cc6658a1aeb291a1a5b3d6143000", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/506f03c370e7cc6658a1aeb291a1a5b3d6143000", "html_url": "https://github.com/Rust-GCC/gccrs/commit/506f03c370e7cc6658a1aeb291a1a5b3d6143000"}], "stats": {"total": 2099, "additions": 2046, "deletions": 53}, "files": [{"sha": "dbe2b82905a9f3ab1b06747102773f96388c3d08", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=8410904a77b9238a1b65798a0fcd92f340ffe0ca", "patch": "@@ -1,3 +1,32 @@\n+2015-01-27  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rl78/cmpsi2.S: Use function start and end macros.\n+\t(__gcc_bcmp): New function.\n+\t* config/rl78/lshrsi3.S: Use function start and end macros.\n+\t* config/rl78/mulsi3.S: Add support for G10.\n+\t(__mulqi3): New function for G10.\n+\t* config/rl78/signbit.S: Use function start and end macros.\n+\t* config/rl78/t-rl78 (LIB2ADD): Add bit-count.S, fpbit-sf.S and\n+\tfpmath-sf.S.\n+\t(LIB2FUNCS_EXCLUDE): Define.\n+\t(LIB2FUNCS_ST): Define.\n+\t* config/rl78/trampoline.S: Use function start and end macros.\n+\t* config/rl78/vregs.h (START_FUNC): New macro.\n+\t(START_ANOTHER_FUNC): New macro.\n+\t(END_FUNC): New macro.\n+\t(END_ANOTHER_FUNC): New macro.\n+\t* config/rl78/bit-count.S: New file.  Contains assembler\n+\timplementations of the bit counting functions: ___clzhi2,\n+\t__clzsi2, ctzhi2, ctzsi2, ffshi2, ffssi2, __partityhi2,\n+\t__paritysi2, __popcounthi2 and __popcountsi2.\n+\t* config/rl78/fpbit-sf.S: New file.  Contains assembler\n+\timplementationas of the math functions: __negsf2, __cmpsf2,\n+\t__eqsf2, __nesf2, __lesf2, __ltsf2, __gesf2, gtsf2, __unordsf2,\n+\t__fixsfsi,  __fixunssfsi, __floatsisf and __floatunssisf.\n+\t* config/rl78/fpmath-sf.S: New file.  Contains assembler\n+\timplementations of the math functions: __subsf3, __addsf3,\n+\t__mulsf3 and __divsf3\n+\n 2015-01-27  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config.host (i[34567]86-*-solaris2*, x86_64-*-solaris2.1[0-9]*):"}, {"sha": "2685c84ca3fa25dc945040159ff1ab2c6d0e155c", "filename": "libgcc/config/rl78/bit-count.S", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Fbit-count.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Fbit-count.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fbit-count.S?ref=8410904a77b9238a1b65798a0fcd92f340ffe0ca", "patch": "@@ -0,0 +1,213 @@\n+;   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+;   Contributed by Red Hat.\n+; \n+; This file is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published by the\n+; Free Software Foundation; either version 3, or (at your option) any\n+; later version.\n+; \n+; This file is distributed in the hope that it will be useful, but\n+; WITHOUT ANY WARRANTY; without even the implied warranty of\n+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+; General Public License for more details.\n+; \n+; Under Section 7 of GPL version 3, you are granted additional\n+; permissions described in the GCC Runtime Library Exception, version\n+; 3.1, as published by the Free Software Foundation.\n+;\n+; You should have received a copy of the GNU General Public License and\n+; a copy of the GCC Runtime Library Exception along with this program;\n+; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+; <http://www.gnu.org/licenses/>.\n+\n+#include \"vregs.h\"\n+\n+START_FUNC\t___clzhi2\n+\t;; Argument is in [SP+4], return in R8.\n+\tmovw\tax, [SP+4]\n+\n+\t.global __clzhi2_internal\n+__clzhi2_internal:\n+\tmovw\tr8, #16\n+\tcmpw\tax, #0\n+\tbz\t$clzhi2_is_zero\n+\tmov\te, #0xff\n+1:\n+\tinc\te\n+\tshlw\tax, 1\n+\tbnc\t$1b\n+\tmov\ta, e\n+\tmov\tr8, a\n+clzhi2_is_zero:\n+\tret\n+END_FUNC\t___clzhi2\n+\n+\n+START_FUNC\t___clzsi2\n+\t;; Argument is in [SP+6]:[SP+4], return in R8.\n+\tmovw\tax, [SP+6]\n+\tcmpw\tax, #0\n+\tbnz\t$__clzhi2_internal\n+\tmovw\tax, [SP+4]\n+\tcall\t!__clzhi2_internal\n+\tmovw\tax, r8\n+\taddw\tax, #16\n+\tmovw\tr8, ax\n+\tret\n+END_FUNC\t___clzsi2\n+\n+\n+START_FUNC\t___ctzhi2\n+\t;; Argument is in [SP+4], return in R8.\n+\tmovw\tax, [SP+4]\n+\n+\t.global __ctzhi2_internal\n+__ctzhi2_internal:\n+\tmovw\tr8, #16\n+\tcmpw\tax, #0\n+\tbz\t$ctzhi2_is_zero\n+\tmov\te, #0xff\n+1:\n+\tinc\te\n+\tshrw\tax, 1\n+\tbnc\t$1b\n+\tmov\ta, e\n+\tmov\tr8, a\n+ctzhi2_is_zero:\n+\tret\n+END_FUNC\t___ctzhi2\n+\n+\n+START_FUNC\t___ctzsi2\n+\t;; Argument is in [SP+6]:[SP+4], return in R8.\n+\tmovw\tax, [SP+4]\n+\tcmpw\tax, #0\n+\tbnz\t$__ctzhi2_internal\n+\tmovw\tax, [SP+6]\n+\tcall\t!__ctzhi2_internal\n+\tmovw\tax, r8\n+\taddw\tax, #16\n+\tmovw\tr8, ax\n+\tret\n+END_FUNC\t___ctzsi2\n+\n+\n+START_FUNC\t___ffshi2\n+\t;; Argument is in [SP+4], return in R8.\n+\tmovw\tax, [SP+4]\n+\n+\t.global __ffshi2_internal\n+__ffshi2_internal:\n+\tmovw\tr8, #0\n+\tcmpw\tax, #0\n+\tbz\t$ffshi2_is_zero\n+\tmov\te, #0\n+1:\n+\tinc\te\n+\tshrw\tax, 1\n+\tbnc\t$1b\n+\tmov\ta, e\n+\tmov\tr8, a\n+ffshi2_is_zero:\n+\tret\n+END_FUNC\t___ffshi2\n+\n+\n+START_FUNC\t___ffssi2\n+\t;; Argument is in [SP+6]:[SP+4], return in R8.\n+\tmovw\tax, [SP+4]\n+\tcmpw\tax, #0\n+\tbnz\t$__ffshi2_internal\n+\tmovw\tax, [SP+6]\n+\tcmpw\tax, #0\n+\tbz\t$1f\n+\tcall\t!__ffshi2_internal\n+\tmovw\tax, r8\n+\taddw\tax, #16\n+1:\t\n+\tmovw\tr8, ax\n+\tret\n+END_FUNC\t___ffssi2\n+\n+\n+START_FUNC\t___parityqi_internal\n+\tmov1\tcy, a.0\n+\txor1\tcy, a.1\n+\txor1\tcy, a.2\n+\txor1\tcy, a.3\n+\txor1\tcy, a.4\n+\txor1\tcy, a.5\n+\txor1\tcy, a.6\n+\txor1\tcy, a.7\n+\tmovw\tax, #0\n+\tbnc\t$1f\n+\tincw\tax\n+1:\n+\tmovw\tr8, ax\n+\tret\n+END_FUNC\t___parityqi_internal\n+\n+\n+START_FUNC\t___parityhi2\n+\t;; Argument is in [SP+4], return in R8.\n+\tmovw\tax, [SP+4]\n+\txor\ta, x\n+\tbr\t$___parityqi_internal\n+END_FUNC\t___parityhi2\n+\n+\n+START_FUNC\t___paritysi2\n+\t;; Argument is in [SP+6]:[SP+4], return in R8.\n+\tmovw\tax, [SP+4]\n+\txor\ta, x\n+\tmov\tb, a\n+\tmovw\tax, [SP+6]\n+\txor\ta, x\n+\txor\ta, b\n+\tbr\t$___parityqi_internal\n+END_FUNC\t___paritysi2\n+\n+\n+\n+START_FUNC\t___popcounthi2\n+\t;; Argument is in [SP+4], return in R8.\n+\tmov\td, #2\n+\tbr\t$___popcountqi_internal\n+END_FUNC\t___popcounthi2\n+\n+\n+START_FUNC\t___popcountsi2\n+\t;; Argument is in [SP+6]:[SP+4], return in R8.\n+\tmov\td, #4\n+\tbr\t$___popcountqi_internal\n+END_FUNC\t___popcountsi2\n+\n+\n+START_FUNC\t___popcountqi_internal\n+\t;; There are D bytes starting at [HL]\n+\t;; store count in R8.\n+\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tmov\ta, #0\n+1:\n+\txch\ta, b\n+\tmov\ta, [hl]\n+\txch\ta, b\n+\tmov\te, #8\n+2:\t\n+\tshl\tb,1\n+\taddc\ta, #0\n+\tdec\te\n+\tbnz\t$2b\n+\n+\tincw\thl\n+\tdec\td\n+\tbnz\t$1b\n+\n+\tmov\tx, a\n+\tmov\ta, #0\n+\tmovw\tr8, ax\n+\tret\t\n+END_FUNC\t___popcountqi_internal"}, {"sha": "f0d8292625df1ffdcb1e974b58bff1b6f11c9ebc", "filename": "libgcc/config/rl78/cmpsi2.S", "status": "modified", "additions": 62, "deletions": 11, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Fcmpsi2.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Fcmpsi2.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fcmpsi2.S?ref=8410904a77b9238a1b65798a0fcd92f340ffe0ca", "patch": "@@ -31,9 +31,8 @@\n \t;; If A is less than B it returns 0.  If A is greater\n \t;; than B it returns 2.  If they are equal it returns 1.\n \n-\t.global\t___cmpsi2\n-        .type   ___cmpsi2, @function\n-___cmpsi2:\n+START_FUNC ___cmpsi2\n+\n \t;; A is at [sp+4]\n \t;; B is at [sp+8]\n \t;; Result put in R8\n@@ -88,18 +87,18 @@ ___cmpsi2:\n \tmovw\tr8, ax\n \tret\n \n-\t.size\t___cmpsi2, . - ___cmpsi2\n-\t\n-\t\n+END_FUNC ___cmpsi2\n+\n+;; ------------------------------------------------------\n+\n \t;;   int __ucmpsi2 (unsigned long A, unsigned long B)\n \t;;\n \t;; Performs an unsigned comparison of A and B.\n \t;; If A is less than B it returns 0.  If A is greater\n \t;; than B it returns 2.  If they are equal it returns 1.\n \n-\t.global\t___ucmpsi2\n-        .type   ___ucmpsi2, @function\n-___ucmpsi2:\n+START_FUNC ___ucmpsi2\n+\n \t;; A is at [sp+4]\n \t;; B is at [sp+8]\n \t;; Result put in R8..R9\n@@ -117,5 +116,57 @@ ___ucmpsi2:\n \tbr\t!!.Lless_than_or_greater_than\n \tbr\t!!.Lcompare_bottom_words\n \n-\t.size\t___ucmpsi2, . - ___ucmpsi2\n-\t\n\\ No newline at end of file\n+END_FUNC ___ucmpsi2\n+\n+;; ------------------------------------------------------\n+\t\n+\t;;   signed int __gcc_bcmp (const unsigned char *s1, const unsigned char *s2, size_t size)\n+\t;;   Result is negative if S1 is less than S2,\n+\t;;   positive if S1 is greater, 0 if S1 and S2 are equal.\n+\n+START_FUNC __gcc_bcmp\n+\n+\t;; S1 is at [sp+4]\n+\t;; S2 is at [sp+6]\n+\t;; SIZE is at [sp+8]\n+\t;; Result in r8/r9\n+\t\n+        movw\tr10, #0\n+1:\n+\t;; Compare R10 against the SIZE parameter\n+        movw\tax, [sp+8]\n+        subw\tax, r10\n+        sknz\n+        br\t!!1f\n+\n+\t;; Load S2[r10] into R8\n+        movw\tax, [sp+6]\n+        addw\tax, r10\n+        movw\thl, ax\n+        mov\ta, [hl]\n+        mov\tr8, a\n+\n+\t;; Load S1[r10] into A\n+        movw\tax, [sp+4]\n+        addw\tax, r10\n+        movw\thl, ax\n+        mov\ta, [hl]\n+\n+\t;; Increment offset\n+        incw\tr10\n+\n+\t;; Compare loaded bytes\n+        cmp\ta, r8\n+        sknz\n+        br\t!!1b\n+\n+\t;; They differ.  Subtract *S2 from *S1 and return as the result.\n+\tmov\tx, a\n+\tmov\ta, #0\n+\tmov\tr9, #0\n+\tsubw\tax, r8\n+1:\n+\tmovw\tr8, ax\n+        ret\n+\n+END_FUNC __gcc_bcmp"}, {"sha": "042facee14eae64c95f77e3bc2f25dda7a61d454", "filename": "libgcc/config/rl78/fpbit-sf.S", "status": "added", "additions": 608, "deletions": 0, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Ffpbit-sf.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Ffpbit-sf.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Ffpbit-sf.S?ref=8410904a77b9238a1b65798a0fcd92f340ffe0ca", "patch": "@@ -0,0 +1,608 @@\n+; SF format is:\n+;\n+; [sign] 1.[23bits] E[8bits(n-127)]\n+;\n+; SEEEEEEE Emmmmmmm mmmmmmmm mmmmmmmm\n+;\n+; [A+0] mmmmmmmm\n+; [A+1] mmmmmmmm\n+; [A+2] Emmmmmmm\n+; [A+3] SEEEEEEE\n+;\n+; Special values (xxx != 0):\n+;\n+;  s1111111 10000000 00000000 00000000\tinfinity\n+;  s1111111 1xxxxxxx xxxxxxxx xxxxxxxx\tNaN\n+;  s0000000 00000000 00000000 00000000\tzero\n+;  s0000000 0xxxxxxx xxxxxxxx xxxxxxxx\tdenormals\n+;\n+; Note that CMPtype is \"signed char\" for rl78\n+;\n+\t\n+#include \"vregs.h\"\n+\n+#define Z\tPSW.6\n+\n+START_FUNC\t___negsf2\n+\n+\t;; Negate the floating point value.\n+\t;; Input at [SP+4]..[SP+7].\n+\t;; Output to R8..R11.\n+\n+\tmovw\tax, [SP+4]\n+\tmovw\tr8, ax\n+\tmovw\tax, [SP+6]\n+\txor\ta, #0x80\n+\tmovw\tr10, ax\n+\tret\n+\n+END_FUNC\t___negsf2\n+\n+;; ------------------internal functions used by later code --------------\n+\n+START_FUNC\t__int_isnan\n+\n+\t;; [HL] points to value, returns Z if it's a NaN\n+\n+\tmov\ta, [hl+2]\n+\tand\ta, #0x80\n+\tmov\tx, a\n+\tmov\ta, [hl+3]\n+\tand\ta, #0x7f\n+\tcmpw\tax, #0x7f80\n+\tskz\n+\tret\t\t\t; return NZ if not NaN\n+\tmov\ta, [hl+2]\n+\tand\ta, #0x7f\n+\tor\ta, [hl+1]\n+\tor\ta, [hl]\n+\tbnz\t$1f\n+\tclr1\tZ\t\t; Z, normal\n+\tret\n+1:\n+\tset1\tZ\t\t; nan\n+\tret\n+\n+END_FUNC\t__int_isnan\n+\n+START_FUNC\t__int_eithernan\n+\n+\t;; call from toplevel functions, returns Z if either number is a NaN,\n+\t;; or NZ if both are OK.\n+\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t$!__int_isnan\n+\tbz\t$1f\n+\n+\tmovw\tax, sp\n+\taddw\tax, #12\n+\tmovw\thl, ax\n+\tcall\t$!__int_isnan\n+1:\n+\tret\n+\n+END_FUNC\t__int_eithernan\n+\n+START_FUNC\t__int_iszero\n+\n+\t;; [HL] points to value, returns Z if it's zero\n+\n+\tmov\ta, [hl+3]\n+\tand\ta, #0x7f\n+\tor\ta, [hl+2]\n+\tor\ta, [hl+1]\n+\tor\ta, [hl]\n+\tret\n+\n+END_FUNC\t__int_iszero\n+\n+START_FUNC\t__int_cmpsf\n+\n+\t;; This is always called from some other function here,\n+\t;; so the stack offsets are adjusted accordingly.\n+\n+\t;; X [SP+8] <=> Y [SP+12] : <a> <=> 0\n+\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t$!__int_iszero\n+\tbnz\t$1f\n+\n+\tmovw\tax, sp\n+\taddw\tax, #12\n+\tmovw\thl, ax\n+\tcall\t$!__int_iszero\n+\tbnz\t$2f\n+\t;; At this point, both args are zero.\n+\tmov\ta, #0\n+\tret\n+\n+2:\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+1:\n+\t;; At least one arg is non-zero so we can just compare magnitudes.\n+\t;; Args are [HL] and [HL+4].\n+\n+\tmov\ta, [HL+3]\n+\txor\ta, [HL+7]\n+\tmov1\tcy, a.7\n+\tbnc\t$1f\n+\n+\tmov\ta, [HL+3]\n+\tsar\ta, 7\n+\tor\ta, #1\n+\tret\n+\n+1:\t;; Signs the same, compare magnitude.  It's safe to lump\n+\t;; the sign bits, exponent, and mantissa together here, since they're\n+\t;; stored in the right sequence.\n+\tmovw\tax, [HL+2]\n+\tcmpw\tax, [HL+6]\n+\tbc\t$ybig_cmpsf\t; branch if X < Y\n+\tbnz\t$xbig_cmpsf\t; branch if X > Y\n+\n+\tmovw\tax, [HL]\n+\tcmpw\tax, [HL+4]\n+\tbc\t$ybig_cmpsf\t; branch if X < Y\n+\tbnz\t$xbig_cmpsf\t; branch if X > Y\n+\n+\tmov\ta, #0\n+\tret\n+\n+xbig_cmpsf:\t\t\t; |X| > |Y| so return A = 1 if pos, 0xff if neg\n+\tmov\ta, [HL+3]\n+\tsar\ta, 7\n+\tor\ta, #1\n+\tret\n+ybig_cmpsf:\t\t\t; |X| < |Y| so return A = 0xff if pos, 1 if neg\n+\tmov\ta, [HL+3]\n+\txor\ta, #0x80\n+\tsar\ta, 7\n+\tor\ta, #1\n+\tret\n+\n+END_FUNC\t__int_cmpsf\n+\n+;; ----------------------------------------------------------\n+\n+START_FUNC\t___cmpsf2\n+\t;; This functions calculates \"A <=> B\".  That is, if A is less than B\n+\t;; they return -1, if A is greater than B, they return 1, and if A\n+\t;; and B are equal they return 0.  If either argument is NaN the\n+\t;; behaviour is undefined.\n+\n+\t;; Input at [SP+4]..[SP+7].\n+\t;; Output to R8..R9.\n+\n+\tcall\t$!__int_eithernan\n+\tbnz\t$1f\n+\tmovw\tr8, #1\n+\tret\n+1:\n+\tcall\t$!__int_cmpsf\n+\tmov\tr8, a\n+\tsar\ta, 7\n+\tmov\tr9, a\n+\tret\n+\n+END_FUNC\t___cmpsf2\n+\n+;; ----------------------------------------------------------\n+\n+\t;; These functions are all basically the same as ___cmpsf2\n+\t;; except that they define how they handle NaNs.\n+\n+START_FUNC\t\t___eqsf2\n+\t;; Returns zero iff neither argument is NaN\n+\t;; and both arguments are equal.\n+START_ANOTHER_FUNC\t___nesf2\n+\t;; Returns non-zero iff either argument is NaN or the arguments are\n+\t;; unequal.  Effectively __nesf2 is the same as __eqsf2\n+START_ANOTHER_FUNC\t___lesf2\n+\t;; Returns a value less than or equal to zero if neither\n+\t;; argument is NaN, and the first is less than or equal to the second.\n+START_ANOTHER_FUNC\t___ltsf2\n+\t;; Returns a value less than zero if neither argument is\n+\t;; NaN, and the first is strictly less than the second.\n+\n+\t;; Input at [SP+4]..[SP+7].\n+\t;; Output to R8.\n+\n+\tmov\tr8, #1\n+\n+;;;  Fall through\n+\n+START_ANOTHER_FUNC\t__int_cmp_common\n+\n+\tcall\t$!__int_eithernan\n+\tsknz\n+\t;; return value (pre-filled-in below) for \"either is nan\"\n+\tret\n+\n+\tcall\t$!__int_cmpsf\n+\tmov\tr8, a\n+\tret\n+\n+END_ANOTHER_FUNC\t__int_cmp_common\n+END_ANOTHER_FUNC\t___ltsf2\n+END_ANOTHER_FUNC\t___lesf2\n+END_ANOTHER_FUNC\t___nesf2\n+END_FUNC\t\t___eqsf2\n+\n+START_FUNC\t\t___gesf2\n+\t;; Returns a value greater than or equal to zero if neither argument\n+\t;; is a NaN and the first is greater than or equal to the second.\n+START_ANOTHER_FUNC\t___gtsf2\n+\t;; Returns a value greater than zero if neither argument\n+\t;; is NaN, and the first is strictly greater than the second.\n+\n+\tmov\tr8, #0xffff\n+\tbr\t$__int_cmp_common\n+\n+END_ANOTHER_FUNC\t___gtsf2\n+END_FUNC\t\t___gesf2\n+\n+;; ----------------------------------------------------------\n+\n+START_FUNC\t___unordsf2\n+\t;; Returns a nonzero value if either argument is NaN, otherwise 0.\n+\n+\tcall\t$!__int_eithernan\n+\tmovw\tr8, #0\n+\tsknz\t\t\t; this is from the call, not the movw\n+\tmovw\tr8, #1\n+\tret\n+\t\n+END_FUNC\t___unordsf2\n+\n+;; ----------------------------------------------------------\n+\n+START_FUNC\t___fixsfsi\n+\t;; Converts its floating point argument into a signed long,\n+\t;; rounding toward zero.\n+\t;; The behaviour with NaNs and Infinities is not well defined.\n+\t;; We choose to return 0 for NaNs, -INTMAX for -inf and INTMAX for +inf.\n+\t;; This matches the behaviour of the C function in libgcc2.c.\n+\n+\t;; Input at [SP+4]..[SP+7], result is in (lsb) R8..R11 (msb).\n+\n+\t;; Special case handling for infinities as __fixunssfsi\n+\t;; will not give us the values that we want.\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tcall\t!!__int_isinf\n+\tbnz\t$1f\n+\tmov\ta, [SP+7]\n+\tbt\ta.7, $2f\n+\t;; +inf\n+\tmovw\tr8, #-1\n+\tmovw\tr10, #0x7fff\n+\tret\n+\t;; -inf\n+2:\tmov\tr8, #0\n+\tmov\tr10, #0x8000\n+\tret\n+\t\n+\t;; Load the value into r10:r11:X:A\n+1:\tmovw\tax, [SP+4]\n+\tmovw\tr10, ax\n+\tmovw\tax, [SP+6]\n+\n+\t;; If the value is positive we can just use __fixunssfsi\n+\tbf\ta.7, $__int_fixunssfsi\n+\n+\t;; Otherwise we negate the value, call __fixunssfsi and\n+\t;; then negate its result.\n+\tclr1\ta.7\n+\tcall\t$!__int_fixunssfsi\n+\n+\tmovw\tax, #0\n+\tsubw\tax, r8\n+\tmovw\tr8, ax\n+\tmovw\tax, #0\n+        sknc\n+        decw    ax\n+        subw    ax, r10\n+\tmovw\tr10, ax\n+\t\n+\t;; Check for a positive result (which should only happen when\n+\t;; __fixunssfsi returns UINTMAX or 0).  In such cases just return 0.\n+\tmov\ta, r11\n+\tbt      a.7, $1f\n+\tmovw\tr10,#0x0\n+\tmovw\tr8, #0x0\n+\n+1:\tret\n+\n+END_FUNC   \t___fixsfsi\n+\n+START_FUNC \t___fixunssfsi\n+\t;; Converts its floating point argument into an unsigned long\n+\t;; rounding towards zero.  Negative arguments all become zero.\n+\t;; We choose to return 0 for NaNs and -inf, but UINTMAX for +inf.\n+\t;; This matches the behaviour of the C function in libgcc2.c.\n+\n+\t;; Input at [SP+4]..[SP+7], result is in (lsb) R8..R11 (msb)\n+\t\n+\t;; Get the input value.\n+\tmovw\tax, [SP+4]\n+\tmovw\tr10, ax\n+\tmovw\tax, [SP+6]\n+\n+\t;; Fall through into the internal function.\n+\t\n+\t.global __int_fixunssfsi\n+__int_fixunssfsi:\n+\t;; Input in (lsb) r10.r11.x.a (msb).\n+\n+\t;; Test for a negative input.  We shift the other bits at the\n+\t;; same time so that A ends up holding the whole exponent:\n+\t;;\n+\t;; before:\n+\t;;   SEEEEEEE EMMMMMMM MMMMMMMM MMMMMMMM\n+\t;;       A       X        R11     R10\n+\t;;\n+\t;; after:\n+\t;;   EEEEEEEE MMMMMMM0 MMMMMMMM MMMMMMMM\n+\t;;       A       X        R11     R10\n+\tshlw\tax, 1\n+\tbnc\t$1f\n+\n+\t;; Return zero.\n+2:\tmovw\tr8, #0\n+\tmovw\tr10, #0\n+\tret\n+\n+\t;; An exponent of -1 is either a NaN or infinity.\n+1:\tcmp\ta, #-1\n+\tbnz\t$3f\n+\t;; For NaN we return 0.  For infinity we return UINTMAX.\n+\tmov\ta, x\n+\tor\ta, r10\n+\tor\ta, r11\n+\tcmp0\ta\n+\tbnz\t$2b\n+\n+6:\tmovw\tr8, #-1\t\t; -1 => UINT_MAX\n+\tmovw\tr10, #-1\n+\tret\n+\t\n+\t;; If the exponent is negative the value is < 1 and so the\n+\t;; converted value is 0.  Note we must allow for the bias\n+\t;; applied to the exponent.  Thus a value of 127 in the\n+\t;; EEEEEEEE bits actually represents an exponent of 0, whilst\n+\t;; a value less than 127 actually represents a negative exponent.\n+\t;; Also if the EEEEEEEE bits are all zero then this represents\n+\t;; either a denormal value or 0.0.  Either way for these values\n+\t;; we return 0.\n+3:\tsub     a, #127\n+\tbc\t$2b\n+\n+\t;; A now holds the bias adjusted exponent, which is known to be >= 0.\n+\t;; If the exponent is > 31 then the conversion will overflow.\n+\tcmp \ta, #32\n+\tbnc\t$6b\n+4:\n+\t;; Save the exponent in H.  We increment it by one because we want\n+\t;; to be sure that the loop below will always execute at least once.\n+ \tinc\ta\n+\tmov\th, a\n+\n+\t;; Get the top 24 bits of the mantissa into A:X:R10\n+\t;; Include the implicit 1-bit that is inherent in the IEEE fp format.\n+\t;;\n+\t;; before:\n+\t;;   EEEEEEEE MMMMMMM0 MMMMMMMM MMMMMMMM\n+\t;;       H       X        R11     R10\n+\t;; after:\n+\t;;   EEEEEEEE 1MMMMMMM MMMMMMMM MMMMMMMM\n+\t;;       H       A        X       R10\n+\n+\tmov\ta, r11\n+\txch\ta, x\n+\tshr\ta, 1\n+\tset1\ta.7\n+\n+\t;; Clear B:C:R12:R13\n+\tmovw\tbc, #0\n+\tmovw\tr12, #0\n+\n+\t;; Shift bits from the mantissa (A:X:R10) into (B:C:R12:R13),\n+\t;; decrementing the exponent as we go.\n+\n+\t;; before:\n+\t;;   MMMMMMMM MMMMMMMM MMMMMMMM   xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx\n+\t;;       A        X      R10          B       C       R12      R13\n+\t;; first iter:\n+\t;;   MMMMMMMM MMMMMMMM MMMMMMM0   xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxM\n+\t;;       A        X      R10          B       C       R12      R13\n+\t;; second iter:\n+\t;;   MMMMMMMM MMMMMMMM MMMMMM00   xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxMM\n+\t;;       A        X      R10          B       C       R12      R13\n+\t;; etc.\n+5:\n+\txch\ta, r10\n+\tshl\ta, 1\n+\txch\ta, r10\n+\t\n+\trolwc\tax, 1\n+\t\n+\txch\ta, r13\n+\trolc\ta, 1\n+\txch\ta, r13\n+\n+\txch\ta, r12\n+\trolc\ta, 1\n+\txch\ta, r12\n+\n+\trolwc\tbc, 1\n+\t\n+\tdec\th\n+\tbnz\t$5b\n+\n+\t;; Result is currently in (lsb) r13.r12. c.  b.  (msb),\n+\t;; Move it into           (lsb) r8. r9. r10. r11 (msb).\n+\n+\tmov\ta, r13\n+\tmov\tr8, a\n+\n+\tmov\ta, r12\n+\tmov\tr9, a\n+\t\n+\tmov\ta, c\n+\tmov\tr10, a\n+\n+\tmov\ta, b\n+\tmov\tr11, a\n+\n+\tret\n+\n+END_FUNC\t___fixunssfsi\n+\n+;; ------------------------------------------------------------------------\n+\n+START_FUNC\t___floatsisf\n+\t;; Converts its signed long argument into a floating point.\n+\t;; Argument in [SP+4]..[SP+7].  Result in R8..R11.\n+\n+\t;; Get the argument.\n+\tmovw\tax, [SP+4]\n+\tmovw\tbc, ax\n+\tmovw\tax, [SP+6]\n+\n+\t;; Test the sign bit.  If the value is positive then drop into\n+\t;; the unsigned conversion routine.\n+\tbf \ta.7, $2f\n+\n+\t;; If negative convert to positive ...\n+\tmovw \thl, ax\n+\tmovw\tax, #0\n+\tsubw\tax, bc\n+\tmovw\tbc, ax\n+\tmovw\tax, #0\n+\tsknc\n+\tdecw\tax\n+\tsubw\tax, hl\n+\n+\t;; If the result is negative then the input was 0x80000000 and\n+\t;; we want to return -0.0, which will not happen if we call\n+\t;; __int_floatunsisf.\n+\tbt\ta.7, $1f\n+\n+\t;;  Call the unsigned conversion routine.\n+\tcall\t$!__int_floatunsisf\n+\n+\t;; Negate the result.\n+\tset1\tr11.7\n+\n+\t;; Done.\n+\tret\n+\n+1:\t;; Return -0.0 aka 0xcf000000\n+\n+\tclrb\ta\n+\tmov\tr8, a\n+\tmov\tr9, a\n+\tmov\tr10, a\n+\tmov\ta, #0xcf\n+\tmov\tr11, a\n+\tret\n+\t\n+START_ANOTHER_FUNC\t___floatunsisf\n+\t;; Converts its unsigned long argument into a floating point.\n+\t;; Argument in [SP+4]..[SP+7].  Result in R8..R11.\n+\n+\t;; Get the argument.\n+\tmovw\tax, [SP+4]\n+\tmovw\tbc, ax\n+\tmovw\tax, [SP+6]\n+\n+2:\t;; Internal entry point from __floatsisf\n+\t;; Input in AX (high) and BC (low)\n+\t.global __int_floatunsisf\n+__int_floatunsisf:\n+\t\n+\t;; Special case handling for zero.\n+\tcmpw\tax, #0\n+\tbnz\t$1f\n+\tmovw\tax, bc\n+\tcmpw\tax, #0\n+\tmovw\tax, #0\n+\tbnz\t$1f\n+\n+\t;; Return 0.0\n+\tmovw\tr8, ax\n+\tmovw\tr10, ax\n+\tret\n+\n+1:\t;; Pre-load the loop count/exponent.\n+\t;; Exponents are biased by 0x80 and we start the loop knowing that\n+\t;; we are going to skip the highest set bit.  Hence the highest value\n+\t;; that we can get for the exponent is 0x1e (bits from input) + 0x80 = 0x9e.\n+\tmov     h, #0x9e\n+\n+\t;; Move bits off the top of AX:BC until we hit a 1 bit.\n+\t;; Decrement the count of remaining bits as we go.\n+\n+2:\tshlw\tbc, 1\n+\trolwc\tax, 1\n+\tbc\t$3f\n+\tdec\th\n+\tbr\t$2b\n+\n+\t;; Ignore the first one bit - it is implicit in the IEEE format.\n+\t;; The count of remaining bits is the exponent.\n+\n+\t;; Assemble the final floating point value.  We have...\n+\t;; before:\n+\t;;   EEEEEEEE MMMMMMMM MMMMMMMM MMMMMMMM xxxxxxxx\n+\t;;       H        A       X        B         C\n+\t;; after:\n+\t;;   0EEEEEEE EMMMMMMM MMMMMMMM MMMMMMMM\n+\t;;      R11      R10      R9       R8\n+\n+\t\n+3:\tshrw\tax, 1\n+\tmov\tr10, a\n+\tmov\ta, x\n+\tmov\tr9, a\t\n+\n+\tmov\ta, b\n+\trorc\ta, 1\t\n+\n+\t;; If the bottom bit of B was set before we shifted it out then we\n+\t;; need to round the result up.  Unless none of the bits in C are set.\n+\t;; In this case we are exactly half-way between two values, and we\n+\t;; round towards an even value.  We round up by increasing the\n+\t;; mantissa by 1.  If this results in a zero mantissa we have to\n+\t;; increment the exponent.  We round down by ignoring the dropped bits.\n+\t\n+\tbnc\t$4f\n+\tcmp0\tc\n+\tsknz\t\n+\tbf\ta.0, $4f\n+\n+5:\t;; Round the mantissa up by 1.\n+\tadd\ta, #1\n+\taddc\tr9, #0\n+\taddc\tr10, #0\n+\tbf\tr10.7, $4f\n+\tinc\th\n+\tclr1\tr10.7\n+\n+4:\tmov\tr8, a\n+\tmov\ta, h\n+\tshr\ta, 1\n+\tmov\tr11, a\n+\tsknc\n+\tset1\tr10.7\n+\tret\n+\n+END_ANOTHER_FUNC\t___floatunsisf\t\n+END_FUNC\t\t___floatsisf"}, {"sha": "f232f6b5f83dc5faa7aefddf303c75ef864c10f8", "filename": "libgcc/config/rl78/fpmath-sf.S", "status": "added", "additions": 1030, "deletions": 0, "changes": 1030, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Ffpmath-sf.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Ffpmath-sf.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Ffpmath-sf.S?ref=8410904a77b9238a1b65798a0fcd92f340ffe0ca", "patch": "@@ -0,0 +1,1030 @@\n+; SF format is:\n+;\n+; [sign] 1.[23bits] E[8bits(n-127)]\n+;\n+; SEEEEEEE Emmmmmmm mmmmmmmm mmmmmmmm\n+;\n+; [A+0] mmmmmmmm\n+; [A+1] mmmmmmmm\n+; [A+2] Emmmmmmm\n+; [A+3] SEEEEEEE\n+;\n+; Special values (xxx != 0):\n+;\n+;  r11      r10      r9       r8\n+;  [HL+3]   [HL+2]   [HL+1]   [HL+0]   \n+;  s1111111 10000000 00000000 00000000\tinfinity\n+;  s1111111 1xxxxxxx xxxxxxxx xxxxxxxx\tNaN\n+;  s0000000 00000000 00000000 00000000\tzero\n+;  s0000000 0xxxxxxx xxxxxxxx xxxxxxxx\tdenormals\n+;\n+; Note that CMPtype is \"signed char\" for rl78\n+;\n+\t\n+#include \"vregs.h\"\n+\n+#define Z\tPSW.6\n+\n+; External Functions:\n+;\n+;  __int_isnan  [HL] -> Z if NaN\n+;  __int_iszero  [HL] -> Z if zero\n+\n+START_FUNC\t__int_isinf\n+\t;; [HL] points to value, returns Z if it's #Inf\n+\n+\tmov\ta, [hl+2]\n+\tand\ta, #0x80\n+\tmov\tx, a\n+\tmov\ta, [hl+3]\n+\tand\ta, #0x7f\n+\tcmpw\tax, #0x7f80\n+\tskz\n+\tret\t\t\t; return NZ if not NaN\n+\tmov\ta, [hl+2]\n+\tand\ta, #0x7f\n+\tor\ta, [hl+1]\n+\tor\ta, [hl]\n+\tret\n+\n+END_FUNC\t__int_isinf\n+\n+START_FUNC\t_int_unpack_sf\n+\t;; convert 32-bit SFmode [DE] to 6-byte struct [HL] (\"A\")\n+\n+#define A_SIGN\t\t[hl+0]\t/* byte */\n+#define A_EXP\t\t[hl+2]\t/* word */\n+#define A_FRAC_L\t[hl+4]\t/* word */\n+#define A_FRAC_LH\t[hl+5]\t/* byte */\n+#define A_FRAC_H\t[hl+6]\t/* word or byte */\n+#define A_FRAC_HH\t[hl+7]\t/* byte */\n+\n+#define B_SIGN\t\t[hl+8]\n+#define B_EXP\t\t[hl+10]\n+#define B_FRAC_L\t[hl+12]\n+#define B_FRAC_LH\t[hl+13]\n+#define B_FRAC_H\t[hl+14]\n+#define B_FRAC_HH\t[hl+15]\n+\n+\tmov\ta, [de+3]\n+\tsar\ta, 7\n+\tmov\tA_SIGN, a\n+\n+\tmovw\tax, [de+2]\n+\tand\ta, #0x7f\n+\tshrw\tax, 7\n+\tmovw\tbc, ax\t\t; remember if the exponent is all zeros\n+\tsubw\tax, #127\t; exponent is now non-biased\n+\tmovw\tA_EXP, ax\n+\n+\tmovw\tax, [de]\n+\tmovw\tA_FRAC_L, ax\n+\n+\tmov\ta, [de+2]\n+\tand\ta, #0x7f\n+\tcmp0\tc\t\t; if the exp is all zeros, it's denormal\n+\tskz\n+\tor\ta, #0x80\n+\tmov\tA_FRAC_H, a\n+\n+\tmov\ta, #0\n+\tmov\tA_FRAC_HH, a\n+\n+\t;; rounding-bit-shift\n+\tmovw\tax, A_FRAC_L\n+\tshlw\tax, 1\n+\tmovw\tA_FRAC_L, ax\n+\tmov\ta, A_FRAC_H\n+\trolc\ta, 1\n+\tmov\tA_FRAC_H, a\n+\tmov\ta, A_FRAC_HH\n+\trolc\ta, 1\n+\tmov\tA_FRAC_HH, a\n+\n+\tret\n+\n+END_FUNC\t_int_unpack_sf\n+\n+;\tfunc(SF a,SF b)\n+;\t[SP+4..7]\ta\n+;\t[SP+8..11]\tb\n+\n+START_FUNC\t\t___subsf3\n+\n+\t;; a - b => a + (-b)\n+\n+\t;; Note - we cannot just change the sign of B on the stack and\n+\t;; then fall through into __addsf3.  The stack'ed value may be\n+\t;; used again (it was created by our caller after all).  Instead\n+\t;; we have to allocate some stack space of our own, copy A and B,\n+\t;; change the sign of B, call __addsf3, release the allocated stack\n+\t;; and then return.\n+\n+\tsubw\tsp, #8\n+\tmovw\tax, [sp+4+8]\n+\tmovw\t[sp], ax\n+\tmovw\tax, [sp+4+2+8]\n+\tmovw\t[sp+2], ax\n+\tmovw\tax, [sp+4+4+8]\n+\tmovw\t[sp+4], ax\n+\tmov \ta, [sp+4+6+8]\n+\tmov\t[sp+6], a\n+\tmov\ta, [sp+4+7+8]\n+\txor\ta, #0x80\n+\tmov\t[sp+7], a\n+\tcall\t$!___addsf3\n+\taddw\tsp, #8\n+\tret\n+END_FUNC\t___subsf3\n+\n+START_FUNC\t___addsf3\n+\n+\t;; if (isnan(a)) return a\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tcall\t!!__int_isnan\n+\tbnz\t$1f\n+ret_a:\n+\tmovw\tax, [sp+4]\n+\tmovw\tr8, ax\n+\tmovw\tax, [sp+6]\n+\tmovw\tr10, ax\n+\tret\n+\n+1:\t;; if (isnan (b)) return b;\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t!!__int_isnan\n+\tbnz\t$2f\n+ret_b:\n+\tmovw\tax, [sp+8]\n+\tmovw\tr8, ax\n+\tmovw\tax, [sp+10]\n+\tmovw\tr10, ax\n+\tret\n+\n+2:\t;; if (isinf (a))\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tcall\t$!__int_isinf\n+\tbnz\t$3f\n+\n+\t;;   if (isinf (b) && a->sign != b->sign) return NaN\n+\t\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t$!__int_isinf\n+\tbnz\t$ret_a\n+\n+\tmov\ta, [sp+7]\n+\tmov\th, a\n+\tmov\ta, [sp+11]\n+\txor\ta, h\n+\tbf\ta.7, $ret_a\n+\n+\tmovw\tr8,  #0x0001\n+\tmovw\tr10, #0x7f80\n+\tret\n+\n+3:\t;; if (isinf (b)) return b;\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t$!__int_isinf\n+\tbz\t$ret_b\n+\n+\t;; if (iszero (b))\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t!!__int_iszero\n+\tbnz\t$4f\n+\n+\t;;   if (iszero (a))\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tcall\t!!__int_iszero\n+\tbnz\t$ret_a\n+\n+\tmovw\tax, [sp+4]\n+\tmovw\tr8, ax\n+\tmov\ta, [sp+7]\n+\tmov\th, a\n+\tmovw\tax, [sp+10]\n+\tand\ta, h\n+\tmovw\tr10, ax\n+\tret\n+\n+4:\t;; if (iszero (a)) return b;\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tcall\t!!__int_iszero\n+\tbz\t$ret_b\n+\n+; Normalize the two numbers relative to each other.  At this point,\n+; we need the numbers converted to their \"unpacked\" format.\n+\n+\tsubw\tsp, #16\t\t; Save room for two unpacked values.\n+\n+\tmovw\tax, sp\n+\tmovw\thl, ax\n+\taddw\tax, #16+4\n+\tmovw\tde, ax\n+\tcall\t$!_int_unpack_sf\n+\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\taddw\tax, #16+8-8\n+\tmovw\tde, ax\n+\tcall\t$!_int_unpack_sf\n+\n+\tmovw\tax, sp\n+\tmovw\thl, ax\n+\n+\t;; diff = a.exponent - b.exponent\n+\tmovw\tax, B_EXP\t; sign/exponent word\n+\tmovw\tbc, ax\n+\tmovw\tax, A_EXP\t; sign/exponent word\n+\t\n+\tsubw\tax, bc\t\t; a = a.exp - b.exp\n+\tmovw\tde, ax\t\t; d = sdiff\n+\n+\t;;  if (diff < 0) diff = -diff\n+\tbf\ta.7, $1f\n+\txor\ta, #0xff\n+\txor\tr_0, #0xff\t; x\n+\tincw\tax\t\t; a = diff\n+1:\t\n+\t;; if (diff >= 23) zero the smaller one\n+\tcmpw\tax, #24\n+\tbc\t$.L661\t\t; if a < 23 goto 661\n+\n+\t;; zero out the smaller one\n+\n+\tmovw\tax, de\n+\tbt\ta.7, $1f\t; if sdiff < 0 (a_exp < b_exp) goto 1f\n+\t;; \"zero out\" b\n+\tmovw\tax, A_EXP\n+\tmovw\tB_EXP, ax\n+\tmovw\tax, #0\n+\tmovw\tB_FRAC_L, ax\n+\tmovw\tB_FRAC_H, ax\n+\tbr\t$5f\n+1:\t\n+\t;; \"zero out\" a\n+\tmovw\tax, B_EXP\n+\tmovw\tA_EXP, ax\n+\tmovw\tax, #0\n+\tmovw\tA_FRAC_L, ax\n+\tmovw\tA_FRAC_H, ax\n+\n+\tbr\t$5f\n+.L661:\n+\t;; shift the smaller one so they have the same exponents\n+1:\t\n+\tmovw\tax, de\n+\tbt\ta.7, $1f\n+\tcmpw\tax, #0\t\t; sdiff > 0\n+\tbnh\t$1f\t\t; if (sdiff <= 0) goto 1f\n+\n+\tdecw\tde\n+\tincw\tB_EXP\t\t; because it's [HL+byte]\n+\n+\tmovw\tax, B_FRAC_H\n+\tshrw\tax, 1\n+\tmovw\tB_FRAC_H, ax\n+\tmov\ta, B_FRAC_LH\n+\trorc\ta, 1\n+\tmov\tB_FRAC_LH, a\n+\tmov\ta, B_FRAC_L\n+\trorc\ta, 1\n+\tmov\tB_FRAC_L, a\n+\t\n+\tbr\t$1b\n+1:\t\n+\tmovw\tax, de\n+\tbf\ta.7, $1f\n+\n+\tincw\tde\n+\tincw\tA_EXP\t\t; because it's [HL+byte]\n+\n+\tmovw\tax, A_FRAC_H\n+\tshrw\tax, 1\n+\tmovw\tA_FRAC_H, ax\n+\tmov\ta, A_FRAC_LH\n+\trorc\ta, 1\n+\tmov\tA_FRAC_LH, a\n+\tmov\ta, A_FRAC_L\n+\trorc\ta, 1\n+\tmov\tA_FRAC_L, a\n+\t\n+\tbr\t$1b\n+1:\t\n+\n+5:\t;; At this point, A and B have the same exponent.\n+\n+\tmov\ta, A_SIGN\n+\tcmp\ta, B_SIGN\n+\tbnz\t$1f\n+\n+\t;; Same sign, just add.\n+\tmovw\tax, A_FRAC_L\n+\taddw\tax, B_FRAC_L\n+\tmovw\tA_FRAC_L, ax\n+\tmov\ta, A_FRAC_H\n+\taddc\ta, B_FRAC_H\n+\tmov\tA_FRAC_H, a\n+\tmov\ta, A_FRAC_HH\n+\taddc\ta, B_FRAC_HH\n+\tmov\tA_FRAC_HH, a\n+\n+\tbr\t$.L728\n+\n+1:\t;; Signs differ - A has A_SIGN still.\n+\tbf\ta.7, $.L696\n+\n+\t;; A is negative, do B-A\n+\tmovw\tax, B_FRAC_L\n+\tsubw\tax, A_FRAC_L\n+\tmovw\tA_FRAC_L, ax\n+\tmov\ta, B_FRAC_H\n+\tsubc\ta, A_FRAC_H\n+\tmov\tA_FRAC_H, a\n+\tmov\ta, B_FRAC_HH\n+\tsubc\ta, A_FRAC_HH\n+\tmov\tA_FRAC_HH, a\n+\n+\tbr\t$.L698\n+.L696:\n+\t;; B is negative, do A-B\n+\tmovw\tax, A_FRAC_L\n+\tsubw\tax, B_FRAC_L\n+\tmovw\tA_FRAC_L, ax\n+\tmov\ta, A_FRAC_H\n+\tsubc\ta, B_FRAC_H\n+\tmov\tA_FRAC_H, a\n+\tmov\ta, A_FRAC_HH\n+\tsubc\ta, B_FRAC_HH\n+\tmov\tA_FRAC_HH, a\n+\n+.L698:\t\n+\t;; A is still A_FRAC_HH\n+\tbt\ta.7, $.L706\n+\t\n+\t;; subtraction was positive\n+\tmov\ta, #0\n+\tmov\tA_SIGN, a\n+\tbr\t$.L712\n+\n+.L706:\n+\t;; subtraction was negative\n+\tmov\ta, #0xff\n+\tmov\tA_SIGN, a\n+\n+\t;; This negates A_FRAC\n+\tmov\ta, A_FRAC_L\n+\txor\ta, #0xff\t\t; XOR doesn't mess with carry\n+\tadd\ta, #1\t\t\t; INC doesn't set the carry\n+\tmov\tA_FRAC_L, a\n+\tmov\ta, A_FRAC_LH\n+\txor\ta, #0xff\n+\taddc\ta, #0\n+\tmov\tA_FRAC_LH, a\n+\tmov\ta, A_FRAC_H\n+\txor\ta, #0xff\n+\taddc\ta, #0\n+\tmov\tA_FRAC_H, a\n+\tmov\ta, A_FRAC_HH\n+\txor\ta, #0xff\n+\taddc\ta, #0\n+\tmov\tA_FRAC_HH, a\n+\n+.L712:\n+\t;; Renormalize the subtraction\n+\n+\tmov\ta, A_FRAC_L\n+\tor\ta, A_FRAC_LH\n+\tor\ta, A_FRAC_H\n+\tor\ta, A_FRAC_HH\n+\tbz\t$.L728\n+\n+\t;; Mantissa is not zero, left shift until the MSB is in the\n+\t;; right place\n+1:\n+\tmovw\tax, A_FRAC_H\n+\tcmpw\tax, #0x0200\n+\tbnc\t$.L728\n+\n+\tdecw\tA_EXP\n+\n+\tmovw\tax, A_FRAC_L\n+\tshlw\tax, 1\n+\tmovw\tA_FRAC_L, ax\n+\tmovw\tax, A_FRAC_H\n+\trolwc\tax, 1\n+\tmovw\tA_FRAC_H, ax\n+\tbr\t$1b\n+\n+.L728:\n+\t;; normalize A and pack it\n+\n+\tmovw\tax, A_FRAC_H\n+\tcmpw\tax, #0x01ff\n+\tbnh\t$1f\n+\t;; overflow in the mantissa; adjust\n+\tmovw\tax, A_FRAC_H\n+\tshrw\tax, 1\n+\tmovw\tA_FRAC_H, ax\n+\tmov\ta, A_FRAC_LH\n+\trorc\ta, 1\n+\tmov\tA_FRAC_LH, a\n+\tmov\ta, A_FRAC_L\n+\trorc\ta, 1\n+\tmov\tA_FRAC_L, a\n+\tincw\tA_EXP\n+1:\t\n+\n+\tcall\t$!__rl78_int_pack_a_r8\n+\taddw\tsp, #16\n+\tret\n+\n+END_FUNC\t___addsf3\n+\n+START_FUNC\t__rl78_int_pack_a_r8\n+\t;; pack A to R8\n+\tmovw\tax, A_EXP\n+\taddw\tax, #126\t; not 127, we want the \"bt/bf\" test to check for denormals\n+\n+\tbf\ta.7, $1f\n+\t;; make a denormal\n+2:\n+\tmovw\tbc, ax\n+\tmovw\tax, A_FRAC_H\n+\tshrw\tax, 1\n+\tmovw\tA_FRAC_H, ax\n+\tmov\ta, A_FRAC_LH\n+\trorc\ta, 1\n+\tmov\tA_FRAC_LH, a\n+\tmov\ta, A_FRAC_L\n+\trorc\ta, 1\n+\tmov\tA_FRAC_L, a\n+\tmovw\tax, bc\n+\tincw\tax\n+\tbt\ta.7, $2b\n+\tdecw\tax\n+1:\t\n+\tincw\tax\t\t; now it's as if we added 127\n+\tmovw\tA_EXP, ax\n+\n+\tcmpw\tax, #0xfe\n+\tbnh\t$1f\n+\t;; store #Inf instead\n+\tmov\ta, A_SIGN\n+\tor\ta, #0x7f\n+\tmov\tx, #0x80\n+\tmovw\tr10, ax\n+\tmovw\tr8, #0\n+\tret\n+\n+1:\n+\tbf\ta.7, $1f\t; note AX has EXP at top of loop\n+\t;; underflow, denormal?\n+\tmovw\tax, A_FRAC_H\n+\tshrw\tax, 1\n+\tmovw\tA_FRAC_H, ax\n+\tmov\ta, A_FRAC_LH\n+\trorc\ta, 1\n+\tmovw\tA_FRAC_LH, ax\n+\tmov\ta, A_FRAC_L\n+\trorc\ta, 1\n+\tmovw\tA_FRAC_L, ax\n+\tincw\tA_EXP\n+\tmovw\tax, A_EXP\n+\tbr\t$1b\n+\n+1:\n+\t;; undo the rounding-bit-shift\n+\tmov\ta, A_FRAC_L\n+\tbf\ta.0, $1f\n+\t;; round up\n+\tmovw\tax, A_FRAC_L\n+\taddw\tax, #1\n+\tmovw\tA_FRAC_L, ax\n+\tsknc\n+\tincw\tA_FRAC_H\n+1:\t\n+\tmovw\tax, A_FRAC_H\n+\tshrw\tax, 1\n+\tmovw\tA_FRAC_H, ax\n+\tmov\ta, A_FRAC_LH\n+\trorc\ta, 1\n+\tmov\tA_FRAC_LH, a\n+\tmov\ta, A_FRAC_L\n+\trorc\ta, 1\n+\tmov\tA_FRAC_L, a\n+\n+\tmovw\tax, A_FRAC_L\n+\tmovw\tr8, ax\n+\n+\tor\ta, x\n+\tor\ta, A_FRAC_H\n+\tor\ta, A_FRAC_HH\n+\tbnz\t$1f\n+\tmovw\tax, #0\n+\tmovw\tA_EXP, ax\n+1:\t\n+\tmov\ta, A_FRAC_H\n+\tand\ta, #0x7f\n+\tmov\tb, a\n+\tmov\ta, A_EXP\n+\tshl\ta, 7\n+\tor\ta, b\n+\tmov\tr10, a\n+\n+\tmov\ta, A_SIGN\n+\tand\ta, #0x80\n+\tmov\tb, a\n+\tmov\ta, A_EXP\n+\tshr\ta, 1\n+\tor\ta, b\n+\tmov\tr11, a\n+\n+\tret\n+END_FUNC\t__rl78_int_pack_a_r8\n+\n+START_FUNC\t___mulsf3\n+\n+\t;; if (isnan(a)) return a\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tcall\t!!__int_isnan\n+\tbnz\t$1f\n+mret_a:\n+\tmovw\tax, [sp+4]\n+\tmovw\tr8, ax\n+\tmov\ta, [sp+11]\n+\tand\ta, #0x80\n+\tmov\tb, a\n+\tmovw\tax, [sp+6]\n+\txor\ta, b\t\t; sign is always a ^ b\n+\tmovw\tr10, ax\n+\tret\n+1:\t\n+\t;; if (isnan (b)) return b;\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t!!__int_isnan\n+\tbnz\t$1f\n+mret_b:\n+\tmovw\tax, [sp+8]\n+\tmovw\tr8, ax\n+\tmov\ta, [sp+7]\n+\tand\ta, #0x80\n+\tmov\tb, a\n+\tmovw\tax, [sp+10]\n+\txor\ta, b\t\t; sign is always a ^ b\n+\tmovw\tr10, ax\n+\tret\n+1:\t\n+\t;; if (isinf (a)) return (b==0) ? nan : a\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tcall\t$!__int_isinf\n+\tbnz\t$.L805\n+\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t!!__int_iszero\n+\tbnz\t$mret_a\n+\n+\tmovw\tr8,  #0x0001\t; return NaN\n+\tmovw\tr10, #0x7f80\n+\tret\n+\n+.L805:\t\n+\t;; if (isinf (b)) return (a==0) ? nan : b\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t$!__int_isinf\n+\tbnz\t$.L814\n+\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tcall\t!!__int_iszero\n+\tbnz\t$mret_b\n+\n+\tmovw\tr8,  #0x0001\t; return NaN\n+\tmovw\tr10, #0x7f80\n+\tret\n+\n+.L814:\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tcall\t!!__int_iszero\n+\tbz\t$mret_a\n+\t\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t!!__int_iszero\n+\tbz\t$mret_b\n+\n+\t;; at this point, we're doing the multiplication.\n+\n+\tsubw\tsp, #16\t; save room for two unpacked values\n+\n+\tmovw\tax, sp\n+\tmovw\thl, ax\n+\taddw\tax, #16+4\n+\tmovw\tde, ax\n+\tcall\t$!_int_unpack_sf\n+\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\taddw\tax, #16+8-8\n+\tmovw\tde, ax\n+\tcall\t$!_int_unpack_sf\n+\n+\tmovw\tax, sp\n+\tmovw\thl, ax\n+\n+\t;; multiply SI a.FRAC * SI b.FRAC to DI r8\n+\n+\tsubw\tsp, #16\n+\tmovw\tax, A_FRAC_L\n+\tmovw\t[sp+0], ax\n+\tmovw\tax, A_FRAC_H\n+\tmovw\t[sp+2], ax\n+\n+\tmovw\tax, B_FRAC_L\n+\tmovw\t[sp+8], ax\n+\tmovw\tax, B_FRAC_H\n+\tmovw\t[sp+10], ax\n+\n+\tmovw\tax, #0\n+\tmovw\t[sp+4], ax\n+\tmovw\t[sp+6], ax\n+\tmovw\t[sp+12], ax\n+\tmovw\t[sp+14], ax\n+\n+\tcall\t!!___muldi3\t; MTMPa * MTMPb -> R8..R15\n+\taddw\tsp, #16\n+\n+\tmovw\tax, sp\n+\tmovw\thl, ax\n+\n+\t;;  add the exponents together\n+\tmovw\tax, A_EXP\n+\taddw\tax, B_EXP\n+\tmovw\tbc, ax\t\t; exponent in BC\n+\n+\t;; now, re-normalize the DI value in R8..R15 to have the\n+\t;; MSB in the \"right\" place, adjusting BC as we shift it.\n+\n+\t;; The value will normally be in this range:\n+\t;; R15              R8\n+\t;; 0001_0000_0000_0000\n+\t;; 0003_ffff_fc00_0001\n+\n+\t;; so to speed it up, we normalize to:\n+\t;; 0001_xxxx_xxxx_xxxx\n+\t;; then extract the bytes we want (r11-r14)\n+\n+1:\n+\tmov\ta, r15\n+\tcmp0\ta\n+\tbnz\t$2f\n+\tmov\ta, r14\n+\tand\ta, #0xfe\n+\tbz\t$1f\n+2:\t\n+\t;; shift right, inc exponent\n+\tmovw\tax, r14\n+\tshrw\tax, 1\n+\tmovw\tr14, ax\n+\tmov\ta, r13\n+\trorc\ta, 1\n+\tmov\tr13, a\n+\tmov\ta, r12\n+\trorc\ta, 1\n+\tmov\tr12, a\n+\tmov\ta, r11\n+\trorc\ta, 1\n+\tmov\tr11, a\n+\t;; we don't care about r8/r9/r10 if we're shifting this way\n+\tincw\tbc\n+\tbr\t$1b\n+1:\t\n+\tmov\ta, r15\n+\tor\ta, r14\n+\tbnz\t$1f\n+\t;; shift left, dec exponent\n+\tmovw\tax, r8\n+\tshlw\tax, 1\n+\tmovw\tr8, ax\n+\tmovw\tax, r10\n+\trolwc\tax, 1\n+\tmovw\tr10, ax\n+\tmovw\tax, r12\n+\trolwc\tax, 1\n+\tmovw\tr12, ax\n+\tmovw\tax, r14\n+\trolwc\tax, 1\n+\tmovw\tr14, ax\n+\tdecw\tbc\n+\tbr\t$1b\n+1:\n+\t;; at this point, FRAC is in R11..R14 and EXP is in BC\n+\tmovw\tax, bc\n+\tmovw\tA_EXP, ax\n+\n+\tmov\ta, r11\n+\tmov\tA_FRAC_L, a\n+\tmov\ta, r12\n+\tmov\tA_FRAC_LH, a\n+\tmov\ta, r13\n+\tmov\tA_FRAC_H, a\n+\tmov\ta, r14\n+\tmov\tA_FRAC_HH, a\n+\n+\tmov\ta, A_SIGN\n+\txor\ta, B_SIGN\n+\tmov\tA_SIGN, a\n+\n+\tcall\t$!__rl78_int_pack_a_r8\n+\n+\taddw\tsp, #16\n+\tret\n+\n+END_FUNC\t\t___mulsf3\n+\t\n+START_FUNC\t\t___divsf3\n+\n+\t;; if (isnan(a)) return a\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tcall\t!!__int_isnan\n+\tbnz\t$1f\n+dret_a:\n+\tmovw\tax, [sp+4]\n+\tmovw\tr8, ax\n+\tmov\ta, [sp+11]\n+\tand\ta, #0x80\n+\tmov\tb, a\n+\tmovw\tax, [sp+6]\n+\txor\ta, b\t\t; sign is always a ^ b\n+\tmovw\tr10, ax\n+\tret\n+1:\t\n+\t;; if (isnan (b)) return b;\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t!!__int_isnan\n+\tbnz\t$1f\n+dret_b:\n+\tmovw\tax, [sp+8]\n+\tmovw\tr8, ax\n+\tmov\ta, [sp+7]\n+\tand\ta, #0x80\n+\tmov\tb, a\n+\tmovw\tax, [sp+10]\n+\txor\ta, b\t\t; sign is always a ^ b\n+\tmovw\tr10, ax\n+\tret\n+1:\t\n+\n+\t;; if (isinf (a)) return isinf(b) ? nan : a\n+\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tcall\t$!__int_isinf\n+\tbnz\t$1f\n+\t\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t$!__int_isinf\n+\tbnz\t$dret_a\n+dret_nan:\t\n+\tmovw\tr8,  #0x0001\t; return NaN\n+\tmovw\tr10, #0x7f80\n+\tret\n+\t\n+1:\t\n+\n+\t;; if (iszero (a)) return iszero(b) ? nan : a\n+\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tmovw\thl, ax\n+\tcall\t!!__int_iszero\n+\tbnz\t$1f\n+\t\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t!!__int_iszero\n+\tbnz\t$dret_a\n+\tbr\t$dret_nan\n+\t\n+1:\t\n+\t;; if (isinf (b)) return 0\n+\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t$!__int_isinf\n+\tbnz\t$1f\n+\t\n+\tmov\ta, [sp+7]\n+\tmov\tb, a\n+\tmov\ta, [sp+11]\n+\txor\ta, b\n+\tand\ta, #0x80\n+\tmov\tr11, a\n+\tmovw\tr8, #0\n+\tmov\tr10, #0\n+\tret\n+\t\n+1:\t\n+\t;; if (iszero (b)) return Inf\n+\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\tcall\t!!__int_iszero\n+\tbnz\t$1f\n+\n+\tmov\ta, [sp+7]\n+\tmov\tb, a\n+\tmov\ta, [sp+11]\n+\txor\ta, b\n+\tor\ta, #0x7f\n+\tmov\tr11, a\n+\tmovw\tr8, #0\n+\tmov\tr10, #0x80\n+\tret\n+1:\t\n+\n+\t;; at this point, we're doing the division.  Normalized\n+\t;; mantissas look like:\n+\t;; 01.xx.xx.xx\n+\t;; so we divide:\n+\t;; 01.xx.xx.xx.00.00.00.00\n+\t;; by          01.xx.xx.xx\n+\t;; to get approx 00.80.00.00.00 to 01.ff.ff.ff.00\n+\n+\n+\tsubw\tsp, #16\t; save room for two unpacked values\n+\n+\tmovw\tax, sp\n+\tmovw\thl, ax\n+\taddw\tax, #16+4\n+\tmovw\tde, ax\n+\tcall\t$!_int_unpack_sf\n+\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tmovw\thl, ax\n+\taddw\tax, #16+8-8\n+\tmovw\tde, ax\n+\tcall\t$!_int_unpack_sf\n+\n+\tmovw\tax, sp\n+\tmovw\thl, ax\n+\n+\t;; divide DI a.FRAC / SI b.FRAC to DI r8\n+\n+\tsubw\tsp, #16\n+\tmovw\tax, A_FRAC_L\n+\tmovw\t[sp+4], ax\n+\tmovw\tax, A_FRAC_H\n+\tmovw\t[sp+6], ax\n+\n+\tmovw\tax, B_FRAC_L\n+\tmovw\t[sp+8], ax\n+\tmovw\tax, B_FRAC_H\n+\tmovw\t[sp+10], ax\n+\n+\tmovw\tax, #0\n+\tmovw\t[sp+0], ax\n+\tmovw\t[sp+2], ax\n+\tmovw\t[sp+12], ax\n+\tmovw\t[sp+14], ax\n+\n+\tcall\t!!___divdi3\t; MTMPa / MTMPb -> R8..R15\n+\taddw\tsp, #16\n+\n+\tmovw\tax, sp\n+\tmovw\thl, ax\n+\n+\t;;  subtract the exponents A - B\n+\tmovw\tax, A_EXP\n+\tsubw\tax, B_EXP\n+\tmovw\tbc, ax\t\t; exponent in BC\n+\n+\t;; now, re-normalize the DI value in R8..R15 to have the\n+\t;; MSB in the \"right\" place, adjusting BC as we shift it.\n+\n+\t;; The value will normally be in this range:\n+\t;; R15              R8\n+\t;; 0000_0000_8000_0000\n+\t;; 0000_0001_ffff_ff00\n+\n+\t;; so to speed it up, we normalize to:\n+\t;; 0000_0001_xxxx_xxxx\n+\t;; then extract the bytes we want (r9-r12)\n+\n+1:\n+\tmovw\tax, r14\n+\tcmpw\tax, #0\n+\tbnz\t$2f\n+\tmovw\tax, r12\n+\tcmpw\tax, #1\n+\tbnh\t$1f\n+2:\t\n+\t;; shift right, inc exponent\n+\tmovw\tax, r14\n+\tshrw\tax, 1\n+\tmovw\tr14, ax\n+\tmov\ta, r13\n+\trorc\ta, 1\n+\tmov\tr13, a\n+\tmov\ta, r12\n+\trorc\ta, 1\n+\tmov\tr12, a\n+\tmov\ta, r11\n+\trorc\ta, 1\n+\tmov\tr11, a\n+\tmov\ta, r10\n+\trorc\ta, 1\n+\tmov\tr10, a\n+\tmov\ta, r9\n+\trorc\ta, 1\n+\tmov\tr9, a\n+\tmov\ta, r8\n+\trorc\ta, 1\n+\tmov\tr8, a\n+\n+\tincw\tbc\n+\tbr\t$1b\n+1:\t\n+\t;; the previous loop leaves r15.r13 zero\n+\tmov\ta, r12\n+\tcmp0\ta\n+\tbnz\t$1f\n+\t;; shift left, dec exponent\n+\tmovw\tax, r8\n+\tshlw\tax, 1\n+\tmovw\tr8, ax\n+\tmovw\tax, r10\n+\trolwc\tax, 1\n+\tmovw\tr10, ax\n+\tmovw\tax, r12\n+\trolwc\tax, 1\n+\tmovw\tr12, ax\n+\t;; don't need to do r14\n+\tdecw\tbc\n+\tbr\t$1b\n+1:\n+\t;; at this point, FRAC is in R8..R11 and EXP is in BC\n+\tmovw\tax, bc\n+\tmovw\tA_EXP, ax\n+\n+\tmov\ta, r9\n+\tmov\tA_FRAC_L, a\n+\tmov\ta, r10\n+\tmov\tA_FRAC_LH, a\n+\tmov\ta, r11\n+\tmov\tA_FRAC_H, a\n+\tmov\ta, r12\n+\tmov\tA_FRAC_HH, a\n+\n+\tmov\ta, A_SIGN\n+\txor\ta, B_SIGN\n+\tmov\tA_SIGN, a\n+\n+\tcall\t$!__rl78_int_pack_a_r8\n+\n+\taddw\tsp, #16\n+\tret\n+\t\n+END_FUNC\t___divsf3"}, {"sha": "164917932fe8ac18848d5cbfd5f5fb53fc7b4c6b", "filename": "libgcc/config/rl78/lshrsi3.S", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Flshrsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Flshrsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Flshrsi3.S?ref=8410904a77b9238a1b65798a0fcd92f340ffe0ca", "patch": "@@ -22,11 +22,7 @@\n \n #include \"vregs.h\"\n \t\n-\t.text\n-\t.global\t___lshrsi3\n-\t.type\t___lshrsi3, @function\n-___lshrsi3:\n-\n+START_FUNC ___lshrsi3\n \t;; input:\n \t;; \n \t;; [zero]\n@@ -46,7 +42,6 @@ ___lshrsi3:\n \t;; B  - count\n \n \tmov\ta, [sp+8]\t; A now contains the count\n-\n \tcmp\ta, #0x20\n \tbc\t$.Lcount_is_normal\n \n@@ -113,4 +108,4 @@ ___lshrsi3:\n \n \tbr\t$.Lloop_top\n \n-\t.size\t___lshrsi3, .-___lshrsi3\n+END_FUNC ___lshrsi3"}, {"sha": "c19865f78e5b6803d6992f515b970ed0a2dec1c3", "filename": "libgcc/config/rl78/mulsi3.S", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Fmulsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Fmulsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fmulsi3.S?ref=8410904a77b9238a1b65798a0fcd92f340ffe0ca", "patch": "@@ -33,6 +33,18 @@\n ; DE\tcount\t(resL-tmp)\n ; HL\t[sp+4]\n \n+; Register use (G10):\n+;\t\n+; AX\t    op2L\n+; BC\t    op2H\n+; DE\t    count\n+; HL\t    [sp+4]\n+; r8/r9\t    res32L\n+; r10/r11   (resH)\n+; r12/r13   (resL-tmp)\n+; r16/r17   res32H\n+; r18/r19   op1\n+\n START_FUNC ___mulsi3\n \t;; A is at [sp+4]\n \t;; B is at [sp+8]\n@@ -159,7 +171,7 @@ START_FUNC ___mulsi3\n \tsknc\n \tincw\tax\n \taddw\tax, r_2\n-.Lmul_hisi_no_add:\t\n+.Lmul_hisi_no_add:\n \tsel\trb1\n \tshlw\tbc, 1\n \tsel\trb0\n@@ -267,3 +279,45 @@ START_FUNC ___mulhi3\n .Lmul_hi_done:\n \tret\n END_FUNC ___mulhi3\n+\n+;;; --------------------------------------\n+#ifdef __RL78_G10__\n+\tSTART_FUNC ___mulqi3\n+\n+       \tmov\ta, [sp+4]\n+       \tmov\tr9, a\n+       \tmov\ta, [sp+6]\n+       \tmov\tr10, a\n+       \tmov\ta, #9\n+       \tmov\tr11, a\n+       \tclrb\ta\n+       \tmov\tr8, a\n+.L2:\n+    \tcmp0\tr10\n+    \tskz\n+    \tdec\tr11\n+    \tsknz\n+    \tret\n+    \tmov\ta, r10\n+    \tand\ta, #1\n+    \tmov\tr12, a\n+    \tcmp0\tr12\n+    \tsknz\n+    \tbr\t!!.L3\n+    \tmov\ta, r9\n+    \tmov\tl, a\n+    \tmov\ta, r8\n+    \tadd\ta, l\n+    \tmov\tr8, a\n+.L3:\n+       \tmov\ta, r9\n+       \tadd\ta, a\n+       \tmov\tr9, a\n+       \tmov\ta, r10\n+       \tshr\ta, 1\n+       \tmov\tr10, a\n+       \tbr\t!!.L2\n+\n+\tEND_FUNC   ___mulqi3\n+#endif\t\n+"}, {"sha": "d315e1c83ca53a5f9980df646de1e8d27575ea03", "filename": "libgcc/config/rl78/signbit.S", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Fsignbit.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Fsignbit.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fsignbit.S?ref=8410904a77b9238a1b65798a0fcd92f340ffe0ca", "patch": "@@ -37,11 +37,9 @@\n \n \t.text\n \n-\t.global\t_signbit\n-_signbit:\n-\t.global\t_signbitf\n-_signbitf:\n-\t;; X is at [sp+4]\n+START_FUNC\t\t_signbit\n+START_ANOTHER_FUNC\t_signbitf\n+\t;; X is at [sp+4]..[SP+7]\n \t;; result is in R8..R9\n \n \tmovw\tr8, #0\n@@ -50,12 +48,12 @@ _signbitf:\n \tsknc\n \tmovw\tr8, #1\n \tret\n-\t.size\t_signbit, . - _signbit\n-\t.size\t_signbitf, . - _signbitf\n+END_ANOTHER_FUNC\t_signbitf\n+END_FUNC\t\t_signbit\n \n-\t.global\t_signbitl\n-_signbitl:\n-\t;; X is at [sp+4]\n+\n+START_FUNC\t_signbitl\n+\t;; X is at [sp+4]..[SP+7]\n \t;; result is in R8..R9\n \n \tmovw\tr8, #0\n@@ -64,4 +62,4 @@ _signbitl:\n \tsknc\n \tmovw\tr8, #1\n \tret\n-\t.size\t_signbitl, . - _signbitl\n+END_FUNC \t_signbitl"}, {"sha": "e030c99c1bd631ca05787350d264416cab343eda", "filename": "libgcc/config/rl78/t-rl78", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Ft-rl78", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Ft-rl78", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Ft-rl78?ref=8410904a77b9238a1b65798a0fcd92f340ffe0ca", "patch": "@@ -20,15 +20,29 @@\n \n LIB2ADD = \\\n \t$(srcdir)/config/rl78/trampoline.S \\\n-\t$(srcdir)/config/rl78/lib2div.c \\\n-\t$(srcdir)/config/rl78/lib2mul.c \\\n \t$(srcdir)/config/rl78/lib2shift.c \\\n \t$(srcdir)/config/rl78/lshrsi3.S \\\n \t$(srcdir)/config/rl78/mulsi3.S \\\n \t$(srcdir)/config/rl78/divmodsi.S \\\n \t$(srcdir)/config/rl78/divmodhi.S \\\n \t$(srcdir)/config/rl78/divmodqi.S \\\n \t$(srcdir)/config/rl78/signbit.S \\\n+\t$(srcdir)/config/rl78/bit-count.S \\\n+\t$(srcdir)/config/rl78/fpbit-sf.S \\\n+\t$(srcdir)/config/rl78/fpmath-sf.S \\\n \t$(srcdir)/config/rl78/cmpsi2.S\n \n+LIB2FUNCS_EXCLUDE = _clzhi2 _clzsi2 _ctzhi2 _ctzsi2 \\\n+  _popcounthi2 _popcountsi2 \\\n+  _parityhi2 _paritysi2 _ffssi2 _ffshi2 \\\n+  _negate_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \\\n+  _lt_sf _le_sf _unord_sf \\\n+  _si_to_sf _usi_to_sf \\\n+  _sf_to_si   _sf_to_usi \\\n+  _fixunssfsi _fixsfsi \\\n+  _addsub_sf _mul_sf _div_sf\n+\n+# Remove __gcc_bcmp from LIB2FUNCS_ST\n+LIB2FUNCS_ST = _eprintf\n+\t\n HOST_LIBGCC2_CFLAGS += -Os -ffunction-sections -fdata-sections"}, {"sha": "9ea8fc4a82bd05c50f79d5b034b0799ecf7014bd", "filename": "libgcc/config/rl78/trampoline.S", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Ftrampoline.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Ftrampoline.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Ftrampoline.S?ref=8410904a77b9238a1b65798a0fcd92f340ffe0ca", "patch": "@@ -80,14 +80,10 @@ trampoline_array_end:\n    pointer in R10, allocate a trampoline and return its address in\n    R8. */\n \n-\t.text\n-\t.global ___trampoline_init\n-        .type   ___trampoline_init, @function\n-___trampoline_init:\n-\n+START_FUNC ___trampoline_init\n \tmovw\thl, #trampoline_array\n-1:\n-\tmovw\tax, [hl + TO_ADDR]\n+\n+1:\tmovw\tax, [hl + TO_ADDR]\n \tcmpw\tax, #0\n \tbz\t$2f\n \n@@ -107,30 +103,27 @@ ___trampoline_init:\n \n \tmovw\tax, [hl + TO_STUB]\n \tmovw\tr8, ax\n-\n \tret\n-\t.size\t___trampoline_init, . - ___trampoline_init\n+END_FUNC ___trampoline_init\n \n-\t.global\t___trampoline_uninit\n-        .type   ___trampoline_uninit, @function\n-___trampoline_uninit:\n+\n+START_FUNC ___trampoline_uninit\n \tmovw\thl, #trampoline_array\n \tmovw\tax, sp\n \tmovw\tbc, ax\n-1:\n-\tmovw\tax, [hl + TO_FRAME]\n+\n+1:\tmovw\tax, [hl + TO_FRAME]\n \tcmpw\tax, bc\n \tbc\t$2f\n \n \tclrw\tax\n \tmovw\t[hl + TO_ADDR], ax\n \n-2:\n-\tmovw\tax, hl\n+2:\tmovw\tax, hl\n \taddw\tax, #TO_SIZE\n \tmovw\thl, ax\n \tcmpw\tax, #trampoline_array_end\n \tbnz\t$1b\n \n \tret\n-\t.size\t___trampoline_uninit, . - ___trampoline_uninit\n+END_FUNC ___trampoline_uninit"}, {"sha": "f1bc5c24761d81c7dac9f3483b34724d5dbd5cf8", "filename": "libgcc/config/rl78/vregs.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Fvregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410904a77b9238a1b65798a0fcd92f340ffe0ca/libgcc%2Fconfig%2Frl78%2Fvregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fvregs.h?ref=8410904a77b9238a1b65798a0fcd92f340ffe0ca", "patch": "@@ -55,17 +55,25 @@ r23\t=\t0xffeef\n \n #endif\n \n+.macro START_ANOTHER_FUNC name\n+\t.global \\name\n+\t.type \\name , @function\n+\\name:\n+.endm\n+    \n     /* Start a function in its own section, so that it\n        can be subject to linker garbage collection.  */\n .macro START_FUNC name\n \t.pushsection .text.\\name,\"ax\",@progbits\n-\t.global \\name\n-\t.type \\name , @function\n-\\name:\n+\tSTART_ANOTHER_FUNC \\name\n+.endm\n+\n+.macro END_ANOTHER_FUNC name\t\n+\t.size \\name , . - \\name\n .endm\n \n     /* End the function.  Set the size.  */\n .macro END_FUNC name\t\n-\t.size \\name , . - \\name\n+\tEND_ANOTHER_FUNC \\name\n \t.popsection\n .endm"}]}