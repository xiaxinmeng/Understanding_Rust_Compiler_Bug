{"sha": "aa7543832a1a981c69c4c3f08cd6ebee77828519", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE3NTQzODMyYTFhOTgxYzY5YzRjM2YwOGNkNmViZWU3NzgyODUxOQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-03-10T03:31:08Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-03-10T03:31:08Z"}, "message": "configure.in: Define SLOW_PTHREAD_SELF if configure.host set slow_pthread_self.\n\nlibjava:\n\t* configure.in: Define SLOW_PTHREAD_SELF if configure.host set\n\tslow_pthread_self. Set up symlink for sysdeps directory.\n\t* configure.host: Document more shell variables. Set sysdeps_dir\n\tfor most platforms. Set slow_pthread_self for i686. Set\n\tenable_hash_synchronization_default and slow_pthread_self for PowerPC.\n\t* posix-threads.cc (_Jv_ThreadSelf_out_of_line): Use release_set so\n\tthat memory barrier is emitted where required.\n\t* include/posix-threads.h (_Jv_ThreadSelf for SLOW_PTHREAD_SELF): Add\n\tread_barrier() to enforce ordering of reads.\n\t* sysdep/powerpc/locks.h: New file. Implementation of synchronization\n\tprimitives for PowerPC.\n\t* sysdep/i386/locks.h: New file. Synchronization primitives for i386\n\tmoved from natObject.cc.\n\t* sysdep/alpha/locks.h: Likewise.\n\t* sysdep/ia64/locks.h: Likewise.\n\t* sysdep/generic/locks.h: Likewise.\n\t* java/lang/natObject.cc: Move thread synchronization primitives to\n\tsystem-dependent headers.\n\ngcc/java:\n\t* decl.c (java_init_decl_processing): Make sure class_type_node\n\talignment is not less than 64 bits if hash synchronization is enabled.\n\nboehm-gc:\n\t* include/gc_priv.h: Define ALIGN_DOUBLE on 32 bit targets if GCJ\n\tsupport is enabled, for hash synchronization.\n\n[[Split portion of a mixed commit.]]\n\nFrom-SVN: r50518.2", "tree": {"sha": "52c6bd2d7f1822d111578beb65b257f62c1d3114", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52c6bd2d7f1822d111578beb65b257f62c1d3114"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa7543832a1a981c69c4c3f08cd6ebee77828519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa7543832a1a981c69c4c3f08cd6ebee77828519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa7543832a1a981c69c4c3f08cd6ebee77828519", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa7543832a1a981c69c4c3f08cd6ebee77828519/comments", "author": null, "committer": null, "parents": [{"sha": "0139adcaa7056e95fc8ad379239ececac80b482b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0139adcaa7056e95fc8ad379239ececac80b482b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0139adcaa7056e95fc8ad379239ececac80b482b"}], "stats": {"total": 257, "additions": 257, "deletions": 0}, "files": [{"sha": "1c20249cce393aea1cadc02dfee08f35739e4c77", "filename": "libjava/sysdep/alpha/locks.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7543832a1a981c69c4c3f08cd6ebee77828519/libjava%2Fsysdep%2Falpha%2Flocks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7543832a1a981c69c4c3f08cd6ebee77828519/libjava%2Fsysdep%2Falpha%2Flocks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Falpha%2Flocks.h?ref=aa7543832a1a981c69c4c3f08cd6ebee77828519", "patch": "@@ -0,0 +1,53 @@\n+// locks.h - Thread synchronization primitives. Alpha implementation.\n+\n+/* Copyright (C) 2002  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __SYSDEP_LOCKS_H__\n+#define __SYSDEP_LOCKS_H__\n+\n+typedef size_t obj_addr_t;\t/* Integer type big enough for object\t*/\n+\t\t\t\t/* address.\t\t\t\t*/\n+\n+inline static bool\n+compare_and_swap(volatile obj_addr_t *addr,\n+\t\t  \t\t\t      obj_addr_t old,\n+\t\t\t\t\t      obj_addr_t new_val) \n+{\n+  unsigned long oldval;\n+  char result;\n+  __asm__ __volatile__(\n+      \"1:ldq_l %0, %1\\n\\t\" \\\n+      \"cmpeq %0, %5, %2\\n\\t\" \\\n+      \"beq %2, 2f\\n\\t\" \\\n+      \"mov %3, %0\\n\\t\" \\\n+      \"stq_c %0, %1\\n\\t\" \\\n+      \"bne %0, 2f\\n\\t\" \\\n+      \"br 1b\\n\\t\" \\\n+      \"2:mb\"\n+\t      : \"=&r\"(oldval), \"=m\"(*addr), \"=&r\"(result)\n+\t      : \"r\" (new_val), \"m\"(*addr), \"r\"(old) : \"memory\");\n+  return (bool) result;\n+}\n+\n+inline static void\n+release_set(volatile obj_addr_t *addr, obj_addr_t new_val)\n+{\n+  __asm__ __volatile__(\"mb\" : : : \"memory\");\n+  *(addr) = new_val;\n+}\n+\n+inline static bool\n+compare_and_swap_release(volatile obj_addr_t *addr,\n+\t\t  \t\t\t\t     obj_addr_t old,\n+\t\t\t\t\t\t     obj_addr_t new_val)\n+{\n+  return compare_and_swap(addr, old, new_val);\n+}\n+\n+#endif"}, {"sha": "fce6c71669ebc8505a82a6f134c6d48661a993c8", "filename": "libjava/sysdep/generic/locks.h", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7543832a1a981c69c4c3f08cd6ebee77828519/libjava%2Fsysdep%2Fgeneric%2Flocks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7543832a1a981c69c4c3f08cd6ebee77828519/libjava%2Fsysdep%2Fgeneric%2Flocks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fgeneric%2Flocks.h?ref=aa7543832a1a981c69c4c3f08cd6ebee77828519", "patch": "@@ -0,0 +1,11 @@\n+// locks.h - Thread synchronization primitives. Generic implementation.\n+\n+/* Copyright (C) 2002  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#error Thread synchronization primitives not implemented for this platform."}, {"sha": "0c029ac939aa9c457ee2caa7323e8c1fd2e5373e", "filename": "libjava/sysdep/i386/locks.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7543832a1a981c69c4c3f08cd6ebee77828519/libjava%2Fsysdep%2Fi386%2Flocks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7543832a1a981c69c4c3f08cd6ebee77828519/libjava%2Fsysdep%2Fi386%2Flocks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fi386%2Flocks.h?ref=aa7543832a1a981c69c4c3f08cd6ebee77828519", "patch": "@@ -0,0 +1,65 @@\n+// locks.h - Thread synchronization primitives. X86 implementation.\n+\n+/* Copyright (C) 2002  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __SYSDEP_LOCKS_H__\n+#define __SYSDEP_LOCKS_H__\n+\n+typedef size_t obj_addr_t;\t/* Integer type big enough for object\t*/\n+\t\t\t\t/* address.\t\t\t\t*/\n+\n+// Atomically replace *addr by new_val if it was initially equal to old.\n+// Return true if the comparison succeeded.\n+// Assumed to have acquire semantics, i.e. later memory operations\n+// cannot execute before the compare_and_swap finishes.\n+inline static bool\n+compare_and_swap(volatile obj_addr_t *addr,\n+\t\t  \t\t\t      obj_addr_t old,\n+\t\t\t\t\t      obj_addr_t new_val) \n+{\n+  char result;\n+  __asm__ __volatile__(\"lock; cmpxchgl %2, %0; setz %1\"\n+\t      : \"+m\"(*(addr)), \"=q\"(result)\n+\t      : \"r\" (new_val), \"a\"(old)\n+\t      : \"memory\");\n+  return (bool) result;\n+}\n+\n+// Set *addr to new_val with release semantics, i.e. making sure\n+// that prior loads and stores complete before this\n+// assignment.\n+// On X86, the hardware shouldn't reorder reads and writes,\n+// so we just have to convince gcc not to do it either.\n+inline static void\n+release_set(volatile obj_addr_t *addr, obj_addr_t new_val)\n+{\n+  __asm__ __volatile__(\" \" : : : \"memory\");\n+  *(addr) = new_val;\n+}\n+\n+// Compare_and_swap with release semantics instead of acquire semantics.\n+// On many architecture, the operation makes both guarantees, so the\n+// implementation can be the same.\n+inline static bool\n+compare_and_swap_release(volatile obj_addr_t *addr,\n+\t\t  \t\t\t\t     obj_addr_t old,\n+\t\t\t\t\t\t     obj_addr_t new_val)\n+{\n+  return compare_and_swap(addr, old, new_val);\n+}\n+\n+// Ensure that subsequent instructions do not execute on stale\n+// data that was loaded from memory before the barrier.\n+// On X86, the hardware ensures that reads are properly ordered.\n+inline static void\n+read_barrier()\n+{\n+}\n+\n+#endif"}, {"sha": "6edee83ea99a41294a706522054f64e94b8029ae", "filename": "libjava/sysdep/ia64/locks.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7543832a1a981c69c4c3f08cd6ebee77828519/libjava%2Fsysdep%2Fia64%2Flocks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7543832a1a981c69c4c3f08cd6ebee77828519/libjava%2Fsysdep%2Fia64%2Flocks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fia64%2Flocks.h?ref=aa7543832a1a981c69c4c3f08cd6ebee77828519", "patch": "@@ -0,0 +1,50 @@\n+// locks.h - Thread synchronization primitives. IA64 implementation.\n+\n+/* Copyright (C) 2002  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __SYSDEP_LOCKS_H__\n+#define __SYSDEP_LOCKS_H__\n+\n+typedef size_t obj_addr_t;\t/* Integer type big enough for object\t*/\n+\t\t\t\t/* address.\t\t\t\t*/\n+\n+inline static bool\n+compare_and_swap(volatile obj_addr_t *addr,\n+\t \t\t\t\t      obj_addr_t old,\n+\t\t\t\t\t      obj_addr_t new_val) \n+{\n+  unsigned long oldval;\n+  __asm__ __volatile__(\"mov ar.ccv=%4 ;; cmpxchg8.acq %0=%1,%2,ar.ccv\"\n+\t      : \"=r\"(oldval), \"=m\"(*addr)\n+\t      : \"r\"(new_val), \"1\"(*addr), \"r\"(old) : \"memory\");\n+  return (oldval == old);\n+}\n+\n+// The fact that *addr is volatile should cause the compiler to\n+// automatically generate an st8.rel.\n+inline static void\n+release_set(volatile obj_addr_t *addr, obj_addr_t new_val)\n+{\n+  __asm__ __volatile__(\" \" : : : \"memory\");\n+  *(addr) = new_val;\n+}\n+\n+inline static bool\n+compare_and_swap_release(volatile obj_addr_t *addr,\n+\t \t\t\t\t             obj_addr_t old,\n+\t\t\t\t\t\t     obj_addr_t new_val) \n+{\n+  unsigned long oldval;\n+  __asm__ __volatile__(\"mov ar.ccv=%4 ;; cmpxchg8.rel %0=%1,%2,ar.ccv\"\n+\t      : \"=r\"(oldval), \"=m\"(*addr)\n+\t      : \"r\"(new_val), \"1\"(*addr), \"r\"(old) : \"memory\");\n+  return (oldval == old);\n+}\n+\n+#endif"}, {"sha": "414b5dcb7f8699f4adce83d4fe3361f805e29185", "filename": "libjava/sysdep/powerpc/locks.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7543832a1a981c69c4c3f08cd6ebee77828519/libjava%2Fsysdep%2Fpowerpc%2Flocks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7543832a1a981c69c4c3f08cd6ebee77828519/libjava%2Fsysdep%2Fpowerpc%2Flocks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fpowerpc%2Flocks.h?ref=aa7543832a1a981c69c4c3f08cd6ebee77828519", "patch": "@@ -0,0 +1,78 @@\n+// locks.h - Thread synchronization primitives. PowerPC implementation.\n+\n+/* Copyright (C) 2002  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __SYSDEP_LOCKS_H__\n+#define __SYSDEP_LOCKS_H__\n+\n+typedef size_t obj_addr_t;\t/* Integer type big enough for object\t*/\n+\t\t\t\t/* address.\t\t\t\t*/\n+\n+inline static bool\n+compare_and_swap(volatile obj_addr_t *addr,\n+\t\t  \t\t\t      obj_addr_t old,\n+\t\t\t\t\t      obj_addr_t new_val) \n+{\n+  int ret;\n+\n+  __asm__ __volatile__ (\n+\t   \"0:    lwarx %0,0,%1 ;\"\n+\t   \"      xor. %0,%3,%0;\"\n+\t   \"      bne 1f;\"\n+\t   \"      stwcx. %2,0,%1;\"\n+\t   \"      bne- 0b;\"\n+\t   \"1:    \"\n+\t: \"=&r\"(ret)\n+\t: \"r\"(addr), \"r\"(new_val), \"r\"(old)\n+\t: \"cr0\", \"memory\");\n+  /* This version of __compare_and_swap is to be used when acquiring\n+     a lock, so we don't need to worry about whether other memory\n+     operations have completed, but we do need to be sure that any loads\n+     after this point really occur after we have acquired the lock.  */\n+  __asm__ __volatile__ (\"isync\" : : : \"memory\");\n+  return ret == 0;\n+}\n+\n+inline static void\n+release_set(volatile obj_addr_t *addr, obj_addr_t new_val)\n+{\n+  __asm__ __volatile__ (\"sync\" : : : \"memory\");\n+  *(addr) = new_val;\n+}\n+\n+inline static bool\n+compare_and_swap_release(volatile obj_addr_t *addr,\n+\t\t  \t\t\t\t     obj_addr_t old,\n+\t\t\t\t\t\t     obj_addr_t new_val)\n+{\n+  int ret;\n+\n+  __asm__ __volatile__ (\"sync\" : : : \"memory\");\n+  __asm__ __volatile__ (\n+\t   \"0:    lwarx %0,0,%1 ;\"\n+\t   \"      xor. %0,%3,%0;\"\n+\t   \"      bne 1f;\"\n+\t   \"      stwcx. %2,0,%1;\"\n+\t   \"      bne- 0b;\"\n+\t   \"1:    \"\n+\t: \"=&r\"(ret)\n+\t: \"r\"(addr), \"r\"(new_val), \"r\"(old)\n+\t: \"cr0\", \"memory\");\n+  return ret == 0;\n+}\n+\n+// Ensure that subsequent instructions do not execute on stale\n+// data that was loaded from memory before the barrier.\n+inline static void\n+read_barrier()\n+{\n+  __asm__ __volatile__ (\"isync\" : : : \"memory\");\n+}\n+\n+#endif"}]}