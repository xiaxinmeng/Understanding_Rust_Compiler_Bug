{"sha": "700f8a87923fe4fb60045c6edbb1430636342fa1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAwZjhhODc5MjNmZTRmYjYwMDQ1YzZlZGJiMTQzMDYzNjM0MmZhMQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-05-05T22:19:26Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-05-05T22:19:26Z"}, "message": "35th Cygnus<->FSF merge\n\nFrom-SVN: r7217", "tree": {"sha": "820a79d0e2b42485be29768b946c1ef57aa78f89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/820a79d0e2b42485be29768b946c1ef57aa78f89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/700f8a87923fe4fb60045c6edbb1430636342fa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/700f8a87923fe4fb60045c6edbb1430636342fa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/700f8a87923fe4fb60045c6edbb1430636342fa1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/700f8a87923fe4fb60045c6edbb1430636342fa1/comments", "author": null, "committer": null, "parents": [{"sha": "87e3e0c1b502d3cbb316cd32745eb1fc4542a540", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e3e0c1b502d3cbb316cd32745eb1fc4542a540", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e3e0c1b502d3cbb316cd32745eb1fc4542a540"}], "stats": {"total": 1024, "additions": 616, "deletions": 408}, "files": [{"sha": "d5443014a11ab3bc43a93a7725be26a93b125188", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 211, "deletions": 2, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -1,17 +1,210 @@\n-Tue May  3 19:11:24 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+Thu May  5 09:35:35 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* typeck.c (build_modify_expr): Warn about assignment to `this'.\n+\n+Wed May  4 15:55:49 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* init.c (build_delete): Use the global operator delete when\n+\trequested.\n+\n+\t* decl.c (lookup_name_real): If we find the type we're looking in a\n+\tbase class while defining a class, set IDENTIFIER_CLASS_VALUE for\n+\tthe type.\n+\n+\t* class.c (finish_struct): Remove a couple of dependencies on\n+\tlanguage linkage.\n+\n+\t* decl.c (pushtag): Classes do nest in extern \"C\" blocks.\n+\t(pushdecl): Only set DECL_NESTED_TYPENAME on the canonical one for\n+\tthe type.\n+\t(pushtag): Remove another dependency on the language linkage.\n+\n+\t* lex.c (cons_up_default_function): Don't set DECL_CLASS_CONTEXT to\n+\ta const-qualified type.\n+\n+\t* decl.c (push_overloaded_decl): Throw away built-in decls here.\n+\t(duplicate_decls): Instead of here.\n+\n+Wed May  4 15:27:40 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n+\n+\t* typeck.c (get_member_function_from_ptrfunc):  Do The Right\n+\tThing (I hope) if we're using thunks.\n+\n+Wed May  4 13:52:38 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* parse.y (specialization): aggr template_type_name ';'.\n+\t(named_class_head_sans_basetype): Use it.\n+\t(explicit_instantiation): Ditto.\n+\t(tmpl.2): Revert.\n+\n+\t* cvt.c (build_type_conversion_1): Use convert_for_initialization,\n+\trather than convert, to do conversions after the UDC.\n+\n+\t* cp-tree.h (SHARED_MEMBER_P): This member is shared between all\n+\tinstances of the class.\n+\n+\t* search.c (lookup_field): If the entity found by two routes is the\n+\tsame, it's not ambiguous.\n+\n+Wed May  4 12:10:00 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n+\n+\t* decl.c (lookup_name_real):  Check for a NULL TREE_VALUE,\n+\tto prevent the compiler from crashing ...\n+\n+Wed May  4 11:19:45 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* call.c (build_method_call): If we don't have an object, check\n+\tbasetype_path to figure out where to look up the function.\n+\n+\t* typeck.c (convert_for_initialization): Pass TYPE_BINFO (type) to\n+\tbuild_method_call in case exp is NULL_TREE.\n+\n+Tue May  3 16:02:53 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n+\n+\tGive a vtable entries a unique named type, for the sake of gdb.\n+\t* class.c (build_vtable_entry):  The addres of a thunk now has\n+\ttype vtable_entry_type, not ptr_type_node.\n+\t* method.c (make_thunk):  Fix type of THUNK_DECL.\n+\t* class.c (add_virtual_function, override_one_vtable):  Use\n+\tvfunc_ptr_type_node, instead of ptr_type_node.\n+\t* cp-tree.h (vfunc_ptr_type_node):  New macro.\n+\t* decl.c (init_decl_processing):  Make vtable_entry_type\n+\tbe a unique type of pointer to a unique function type.\n+\n+Tue May  3 09:20:44 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* parse.y (do_explicit): Sets doing_explicit to 1.\n+\t(explicit_instantiation): Use do_explicit rather than TEMPLATE\n+\tdirectly, add \"do_explicit error\" rule.\n+\t(datadef): Set doing_explicit to 0 after an explicit instantiation.\n+\t(tmpl.2): Don't instantiate if we see a ';' unless we're doing an\n+\texplicit instantiation.\n+\t(named_class_head_sans_basetype): Remove aggr template_type_name\n+\t';' again.\n+\n+Mon May  2 23:17:21 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* search.c (lookup_nested_tag): Lose.\n+\n+\t* decl2.c (grokfield): Set DECL_CONTEXT on TYPE_DECLs.\n+\t(lookup_name_nonclass): Lose.\n+\n+\t* decl.c (poplevel_class): Add force parameter.\n+\t(lookup_name_real): Fix handling of explicit scoping which specifies\n+\ta class currently being defined.  Add 'nonclass' argument.\n+\t(lookup_name, lookup_name_nonclass): Shells for lookup_name_real.\n+\n+\t* class.c (finish_struct): Don't unset IDENTIFIER_CLASS_VALUEs here.\n+\t(popclass): Force clearing of IDENTIFIER_CLASS_VALUEs if we're being\n+\tcalled from finish_struct.\n+\n+Mon May  2 19:06:21 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n+\n+\t* decl.c (init_decl_processing), cp-tree.h:  Removed memptr_type.\n+\t(It seeems redundant, given build_ptrmemfunc_type.)\n+\t* typeck.c (get_member_function_from_ptrfunc), gc.c (build_headof,\n+\tbuild_classof):  Use vtable_entry_type instead of memptr_type.\n+\t* method.c (emit_thunk):  Call poplevel with functionbody==0\n+\tto prevent DECL_INITIAL being set to a BLOCK.\n+\n+Mon May  2 15:02:11 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* parse.y (named_class_head_sans_basetype): Add \"aggr\n+\ttemplate_type_name ';'\" rule for forward declaration of\n+\tspecializations.\n+\n+Mon May  2 15:02:11 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* class.c (instantiate_type): Deal with pmf's.\n \n \t* Make-lang.in (cc1plus): Don't depend on OBJS or BC_OBJS, since\n \tstamp-objlist does.\n+\n \t* Makefile.in (../cc1plus): Depend on OBJDEPS.\n \t(OBJDEPS): Dependency version of OBJS.\n \n+Mon May  2 12:51:31 1994  Kung Hsu  (kung@mexican.cygnus.com)\n+\n+\t* search.c (dfs_debug_mark): unmark TYPE_DECL_SUPPRESS_DEBUG, not\n+\tDECL_IGNORED_P.\n+\n+Fri Apr 29 12:29:56 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* class.c (finish_struct): Clear out memory of local tags.  And\n+\ttypedefs.\n+\n+\t* decl2.c (grokclassfn): Don't set DECL_CONTEXT to a cv-qualified\n+\ttype.\n+\t* search.c (get_matching_virtual): Be more helpful in error message.\n+\n+\t* *: Use DECL_ARTIFICIAL (renamed from DECL_SYNTHESIZED).\n+\n+\t* lex.c (default_assign_ref_body): Expect TYPE_NESTED_NAME to work.\n+\t(default_copy_constructor_body): Ditto.\n+\n+\t* class.c (finish_struct): Don't gratuitously create multiple decls\n+\tfor nested classes.\n+\n+Thu Apr 28 23:39:38 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\tAvoid clobbering the arg types of other functions when reverting\n+\tstatic member functions.\n+\t* decl.c (revert_static_member_fn): Rearrange arguments, don't\n+\trequire values for 'fn' and 'argtypes', add warning to comment\n+\tabove.\n+\t(decls_match): Rearrange arguments in call to rsmf.\n+\t(grok_op_properties): Don't pass values for fn and argtypes.\n+\t* pt.c (instantiate_template): Don't pass values for fn and argtypes.\n+\n Thu Apr 28 16:29:11 1994  Doug Evans  (dje@canuck.cygnus.com)\n \n \t* Make-lang.in (cc1plus): Depend on stamp-objlist.\n \t* Makefile.in (BC_OBJS): Delete.\n-\t(OBJS): Cat ../stamp-objlist to get everything, except ../c-common.o.\n+\t(OBJS): Cat ../stamp-objlist to get language independent files.\n+\tInclude ../c-common.o.\n \t(../cc1plus): Delete reference to BC_OBJS.\n \n+Thu Apr 28 02:12:08 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* search.c (compute_access): No really, deal with static members\n+\tproperly.  Would I lie to you?\n+\n+\tImplement lexical hiding of function declarations.\n+\t* pt.c (tsubst): Use lookup_name to look for function decls to guide\n+\tinstantiation.\n+\t* method.c (build_opfncall): Use lookup_name_nonclass to look for\n+\tnon-member functions.\n+\t* init.c (do_friend): Use lookup_name_nonclass to look for\n+\tfunctions.\n+\t* error.c (ident_fndecl): Use lookup_name to look for functions.\n+\t* decl2.c (lookup_name_nonclass): New function, skips over\n+\tCLASS_VALUE.\n+\t* decl.c (struct binding_level): Lose overloads_shadowed field.\n+\t(poplevel): Don't deal with overloads_shadowed.\n+\t(push_overloaded_decl): Do lexical hiding for functions.\n+\t* class.c (instantiate_type): Don't check non-members if we have\n+\tmembers with the same name.\n+\t* call.c (build_method_call): Use lookup_name_nonclass instead of\n+\tIDENTIFIER_GLOBAL_VALUE to check for non-member functions.\n+\t(build_overload_call_real): Ditto.\n+\n+\t* decl.c (duplicate_decls): Check for ambiguous overloads here.\n+\t(push_overloaded_decl): Instead of here.\n+\t\n+\t* decl.c (pushdecl): Back out Chip's last change.\n+\n+\t* decl.c (grok_op_properties): operators cannot be static members.\n+\n+\t* cp-tree.h (DECL_SYNTHESIZED): DECL_SOURCE_LINE == 0\n+\t(SET_DECL_SYNTHESIZED): DECL_SOURCE_LINE = 0\n+\t* lex.c (cons_up_default_function): Use SET_DECL_SYNTHESIZED.\n+\n+\t* method.c (do_inline_function_hair): Don't put friends of local\n+\tclasses into global scope, either.\n+\n+\t* typeck2.c (build_functional_cast): Don't look for a function call\n+\tinterpretation.\n+\n Thu Apr 28 15:19:46 1994  Mike Stump  (mrs@cygnus.com)\n \n \t* cp-tree.h: disable use of backend EH.\n@@ -170,6 +363,17 @@ Sun Apr 24 16:52:51 1994  Doug Evans  (dje@canuck.cygnus.com)\n \t(*.o): Use complete pathname to headers in parent dir.\n \t(doc, info, dvi): Delete.\n \n+Sun Apr 24 16:52:51 1994  Doug Evans  (dje@canuck.cygnus.com)\n+\n+\t* Make-lang.in (c++.install-common): Check for g++-cross.\n+\t* Makefile.in: Remove Cygnus cruft.\n+\t(config.status): Delete.\n+\t(RTL_H): Define.\n+\t(TREE_H): Use complete pathname, some native makes have minimal\n+\tVPATH support.\n+\t(*.o): Use complete pathname to headers in parent dir.\n+\t(doc, info, dvi): Delete.\n+\n Sun Apr 24 00:47:49 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* decl.c (pushdecl): Avoid redundant warning on redeclaring function\n@@ -290,6 +494,11 @@ Fri Apr 22 03:27:26 1994  Doug Evans  (dje@cygnus.com)\n \t* Language directory reorganization.\n \tSee parent makefile.\n \n+Fri Apr 22 03:27:26 1994  Doug Evans  (dje@cygnus.com)\n+\n+\t* Language directory reorganization.\n+\tSee parent makefile.\n+\n Thu Apr 21 18:27:57 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n \n \t* cp-tree.h (THUNK_DELTA):  It is normally negative, so"}, {"sha": "bc3b7314b911d8335abf43a37cd5185fb2988eb2", "filename": "gcc/cp/call.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -2859,6 +2859,8 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       if (basetype != NULL_TREE)\n \t;\n       /* call to a constructor... */\n+      else if (basetype_path)\n+\tbasetype = BINFO_TYPE (basetype_path);\n       else if (IDENTIFIER_HAS_TYPE_VALUE (name))\n \t{\n \t  basetype = IDENTIFIER_TYPE_VALUE (name);\n@@ -3429,7 +3431,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t}\n       if (pass == 0)\n \t{\n-\t  tree igv = IDENTIFIER_GLOBAL_VALUE (name);\n+\t  tree igv = lookup_name_nonclass (name);\n \n \t  /* No exact match could be found.  Now try to find match\n \t     using default conversions.  */\n@@ -3516,7 +3518,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  goto found_and_maybe_warn;\n \t}\n \n-      if ((flags & ~LOOKUP_GLOBAL) & (LOOKUP_COMPLAIN|LOOKUP_SPECULATIVELY))\n+      if (flags & (LOOKUP_COMPLAIN|LOOKUP_SPECULATIVELY))\n \t{\n \t  if ((flags & (LOOKUP_SPECULATIVELY|LOOKUP_COMPLAIN))\n \t      == LOOKUP_SPECULATIVELY)\n@@ -3925,23 +3927,25 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n \n   if (! flag_ansi_overloading)\n     {\n+      tree fn;\n+\n       /* This is a speed improvement that ends up not working properly in\n \t the situation of fns with and without default parameters.  I turned\n \t this off in the new method so it'll go through the argument matching\n \t code to properly diagnose a match/failure. (bpk)  */\n       overload_name = build_decl_overload (fnname, parmtypes, 0);\n+      fn = lookup_name_nonclass (overload_name);\n \n       /* Now check to see whether or not we can win.\n \t Note that if we are called from `build_method_call',\n \t then we cannot have a mis-match, because we would have\n \t already found such a winning case.  */\n \n-      if (IDENTIFIER_GLOBAL_VALUE (overload_name))\n-\tif (TREE_CODE (IDENTIFIER_GLOBAL_VALUE (overload_name)) != TREE_LIST)\n-\t  return build_function_call (DECL_MAIN_VARIANT (IDENTIFIER_GLOBAL_VALUE (overload_name)), parms);\n+      if (fn && TREE_CODE (fn) == FUNCTION_DECL)\n+\treturn build_function_call (DECL_MAIN_VARIANT (fn), parms);\n     }\n \n-  functions = IDENTIFIER_GLOBAL_VALUE (fnname);\n+  functions = lookup_name_nonclass (fnname);\n \n   if (functions == NULL_TREE)\n     {"}, {"sha": "fe169ad3e37c42b7ead0dda277862d7080057995", "filename": "gcc/cp/class.c", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -361,7 +361,7 @@ build_vtable_entry (delta, pfn)\n       extern tree make_thunk ();\n       if (idelta)\n \t{\n-\t  pfn = build1 (ADDR_EXPR, ptr_type_node,\n+\t  pfn = build1 (ADDR_EXPR, vtable_entry_type,\n \t\t\tmake_thunk (pfn, idelta));\n \t  TREE_READONLY (pfn) = 1;\n \t  TREE_CONSTANT (pfn) = 1;\n@@ -782,7 +782,7 @@ add_virtual_function (pending_virtuals, has_virtual, fndecl, t)\n {\n   /* FUNCTION_TYPEs and OFFSET_TYPEs no longer freely\n      convert to void *.  Make such a conversion here.  */\n-  tree vfn = build1 (ADDR_EXPR, ptr_type_node, fndecl);\n+  tree vfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fndecl);\n   TREE_CONSTANT (vfn) = 1;\n \n #ifndef DUMB_USER\n@@ -2389,7 +2389,7 @@ override_one_vtable (binfo, old, t)\n \t    if (! CLASSTYPE_ABSTRACT_VIRTUALS (t))\n \t      CLASSTYPE_ABSTRACT_VIRTUALS (t) = error_mark_node;\n \n-\t    vfn = build1 (ADDR_EXPR, ptr_type_node, fndecl);\n+\t    vfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fndecl);\n \t    TREE_CONSTANT (vfn) = 1;\n \t    \n \t    /* We can use integer_zero_node, as we will will core dump\n@@ -2668,7 +2668,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n     }\n \n   if (write_virtuals == 3 && CLASSTYPE_INTERFACE_KNOWN (t)\n-      && current_lang_name == lang_name_cplusplus && ! IS_SIGNATURE (t))\n+      && ! IS_SIGNATURE (t))\n     {\n       CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n       CLASSTYPE_VTABLE_NEEDS_WRITING (t) = ! interface_only;\n@@ -3653,7 +3653,14 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       last_x = tree_last (TYPE_FIELDS (t));\n       while (x)\n \t{\n+#if 0 /* What's wrong with using the decl the type already has? */\n \t  tree tag = build_lang_decl (TYPE_DECL, TREE_PURPOSE (x), TREE_VALUE (x));\n+\t  DECL_CONTEXT (tag) = t;\n+#else\n+\t  tree tag = TYPE_NAME (TREE_VALUE (x));\n+#endif\n+\t  DECL_CLASS_CONTEXT (tag) = t;\n+\n #ifdef DWARF_DEBUGGING_INFO\n \t  if (write_symbols == DWARF_DEBUG)\n \t    {\n@@ -3662,8 +3669,8 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t      DECL_IGNORED_P (tag) = 1;\n \t    }\n #endif /* DWARF_DEBUGGING_INFO */\n-\t  DECL_CONTEXT (tag) = t;\n-\t  DECL_CLASS_CONTEXT (tag) = t;\n+\n+\t  TREE_NONLOCAL_FLAG (TREE_VALUE (x)) = 0;\n \t  x = TREE_CHAIN (x);\n \t  last_x = chainon (last_x, tag);\n \t}\n@@ -3691,16 +3698,12 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   else if (TYPE_NEEDS_CONSTRUCTING (t))\n     build_class_init_list (t);\n \n-  if (current_lang_name == lang_name_cplusplus)\n-    {\n-      if (! CLASSTYPE_DECLARED_EXCEPTION (t)\n-\t  && ! IS_SIGNATURE (t))\n-\tembrace_waiting_friends (t);\n+  if (! CLASSTYPE_DECLARED_EXCEPTION (t) && ! IS_SIGNATURE (t))\n+    embrace_waiting_friends (t);\n \n-      /* Write out inline function definitions.  */\n-      do_inline_function_hair (t, CLASSTYPE_INLINE_FRIENDS (t));\n-      CLASSTYPE_INLINE_FRIENDS (t) = 0;\n-    }\n+  /* Write out inline function definitions.  */\n+  do_inline_function_hair (t, CLASSTYPE_INLINE_FRIENDS (t));\n+  CLASSTYPE_INLINE_FRIENDS (t) = 0;\n \n   if (CLASSTYPE_VSIZE (t) != 0)\n     {\n@@ -4097,9 +4100,9 @@ pushclass (type, modify)\n }\n  \n /* Get out of the current class scope. If we were in a class scope\n-   previously, that is the one popped to.  The flag MODIFY tells\n-   whether the current scope declarations needs to be modified\n-   as a result of popping to the previous scope.  */\n+   previously, that is the one popped to.  The flag MODIFY tells whether\n+   the current scope declarations needs to be modified as a result of\n+   popping to the previous scope.  0 is used for class definitions.  */\n void\n popclass (modify)\n      int modify;\n@@ -4116,7 +4119,7 @@ popclass (modify)\n       /* This code can be seen as a cache miss.  When we've cached a\n \t class' scope's bindings and we can't use them, we need to reset\n \t them.  This is it!  */\n-      for (t = previous_class_values; t; t = TREE_CHAIN(t))\n+      for (t = previous_class_values; t; t = TREE_CHAIN (t))\n \tIDENTIFIER_CLASS_VALUE (TREE_PURPOSE (t)) = NULL_TREE;\n       while (tags)\n \t{\n@@ -4141,7 +4144,9 @@ popclass (modify)\n \tundo_template_name_overload (current_class_name, 0);\n     }\n \n-  poplevel_class ();\n+  /* Force clearing of IDENTIFIER_CLASS_VALUEs after a class definition,\n+     since not all class decls make it there currently.  */\n+  poplevel_class (! modify);\n \n   /* Since poplevel_class does the popping of class decls nowadays,\n      this really only frees the obstack used for these decls.\n@@ -4540,17 +4545,19 @@ instantiate_type (lhstype, rhs, complain)\n \t\treturn save_elem;\n \t      }\n \t    name = DECL_NAME (TREE_VALUE (rhs));\n+#if 0\n \t    if (TREE_CODE (lhstype) == FUNCTION_TYPE && globals < 0)\n \t      {\n \t\t/* Try to instantiate from non-member functions.  */\n-\t\trhs = IDENTIFIER_GLOBAL_VALUE (name);\n+\t\trhs = lookup_name_nonclass (name);\n \t\tif (rhs && TREE_CODE (rhs) == TREE_LIST)\n \t\t  {\n \t\t    /* This code seems to be missing a `return'.  */\n \t\t    my_friendly_abort (4);\n \t\t    instantiate_type (lhstype, rhs, complain);\n \t\t  }\n \t      }\n+#endif\n \t  }\n \tif (complain)\n \t  error (\"no static member functions named `%s'\",\n@@ -4655,15 +4662,18 @@ instantiate_type (lhstype, rhs, complain)\n       return rhs;\n       \n     case ADDR_EXPR:\n-      if (TREE_CODE (lhstype) != POINTER_TYPE)\n+      if (TYPE_PTRMEMFUNC_P (lhstype))\n+\tlhstype = TYPE_PTRMEMFUNC_FN_TYPE (lhstype);\n+      else if (TREE_CODE (lhstype) != POINTER_TYPE)\n \t{\n \t  if (complain)\n \t    error (\"type for resolving address of overloaded function must be pointer type\");\n \t  return error_mark_node;\n \t}\n       TREE_TYPE (rhs) = lhstype;\n       lhstype = TREE_TYPE (lhstype);\n-      TREE_OPERAND (rhs, 0) = instantiate_type (lhstype, TREE_OPERAND (rhs, 0), complain);\n+      TREE_OPERAND (rhs, 0) = instantiate_type (lhstype, TREE_OPERAND (rhs, 0),\n+\t\t\t\t\t\tcomplain);\n       if (TREE_OPERAND (rhs, 0) == error_mark_node)\n \treturn error_mark_node;\n "}, {"sha": "1a82e0bc96dbf656a84a2a4b9ff62cb0b51bc099", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -936,9 +936,8 @@ struct lang_decl_flags\n   unsigned constructor_for_vbase_attr : 1;\n   unsigned mutable_flag : 1;\n   unsigned is_default_implementation : 1;\n-  unsigned synthesized : 1;\n   unsigned saved_inline : 1;\n-  unsigned dummy : 9;\n+  unsigned dummy : 10;\n \n   tree access;\n   tree context;\n@@ -1000,6 +999,12 @@ struct lang_decl\n    member function.  */\n #define DECL_STATIC_FUNCTION_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.static_function)\n \n+/* Nonzero for a class member means that it is shared between all objects\n+   of that class.  */\n+#define SHARED_MEMBER_P(NODE) \\\n+  (TREE_CODE (NODE) == VAR_DECL || TREE_CODE (NODE) == TYPE_DECL \\\n+   || TREE_CODE (NODE) == CONST_DECL)\n+\t\t\t\t\n /* Nonzero for FUNCTION_DECL means that this decl is a member function\n    (static or non-static).  */\n #define DECL_FUNCTION_MEMBER_P(NODE) \\\n@@ -1106,8 +1111,9 @@ struct lang_decl\n #define DECL_PUBLIC(NODE) (DECL_LANG_FLAG_7 (NODE))\n #endif\n \n-/* This method was synthesized by cons_up_default_function.  */\n-#define DECL_SYNTHESIZED(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.synthesized)\n+/* This _DECL represents a compiler-generated entity.  */\n+#define DECL_ARTIFICIAL(NODE) (DECL_SOURCE_LINE (NODE) == 0)\n+#define SET_DECL_ARTIFICIAL(NODE) (DECL_SOURCE_LINE (NODE) = 0)\n \n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(exp) DECL_LANG_FLAG_1 ((exp))\n@@ -1327,7 +1333,6 @@ extern tree void_list_node;\n extern tree void_zero_node;\n extern tree default_function_type;\n extern tree vtable_entry_type;\n-extern tree memptr_type;\n extern tree sigtable_entry_type;\n extern tree __t_desc_type_node, __i_desc_type_node, __m_desc_type_node;\n extern tree Type_info_type_node;\n@@ -1347,6 +1352,11 @@ extern tree class_type_node, record_type_node, union_type_node, enum_type_node;\n extern tree exception_type_node, unknown_type_node;\n extern tree opaque_type_node, signature_type_node;\n \n+/* Node for \"pointer to (virtual) function\".\n+   This may be distinct from ptr_type_node so gdb can distinuish them. */\n+#define vfunc_ptr_type_node \\\n+  (flag_vtable_thunks ? vtable_entry_type : ptr_type_node)\n+\n /* Array type `(void *)[]' */\n extern tree vtbl_type_node;\n extern tree delta_type_node;\n@@ -1812,7 +1822,7 @@ extern void insert_block\t\t\tPROTO((tree));\n extern void add_block_current_level\t\tPROTO((tree));\n extern void set_block\t\t\t\tPROTO((tree));\n extern void pushlevel_class\t\t\tPROTO((void));\n-extern tree poplevel_class\t\t\tPROTO((void));\n+extern tree poplevel_class\t\t\tPROTO((int));\n /* skip print_other_binding_stack and print_binding_level */\n extern void print_binding_stack\t\t\tPROTO((void));\n extern void push_to_top_level\t\t\tPROTO((void));\n@@ -1906,6 +1916,7 @@ extern tree reparse_absdcl_as_expr\t\tPROTO((tree, tree));\n extern tree reparse_absdcl_as_casts\t\tPROTO((tree, tree));\n extern tree reparse_decl_as_expr\t\tPROTO((tree, tree));\n extern tree finish_decl_parsing\t\t\tPROTO((tree));\n+extern tree lookup_name_nonclass\t\tPROTO((tree));\n \n /* in edsel.c */\n "}, {"sha": "b1604129ca5b6e39f4477c0c593f569eeeddfa3f", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -1539,7 +1539,11 @@ build_type_conversion_1 (xtype, basetype, expr, typename, for_sure)\n       && (TREE_READONLY (TREE_TYPE (TREE_TYPE (rval)))\n \t  > TREE_READONLY (TREE_TYPE (xtype))))\n     warning (\"user-defined conversion casting away `const'\");\n-  return convert (xtype, rval);\n+  rval = convert_for_initialization (NULL_TREE, xtype, rval, flags,\n+\t\t\t\t     \"conversion\", NULL_TREE, 0);\n+  if (rval == error_mark_node)\n+    return NULL_TREE;\n+  return rval;\n }\n \n /* Convert an aggregate EXPR to type XTYPE.  If a conversion"}, {"sha": "1533f95620c0d3c685a2e3f3e6d7400b7e0b46d4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 211, "deletions": 148, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -224,7 +224,7 @@ tree sizet_ftype_string;\n tree int_ftype_cptr_cptr_sizet;\n \n /* C++ extensions */\n-tree memptr_type, vtable_entry_type;\n+tree vtable_entry_type;\n tree delta_type_node;\n tree __t_desc_type_node, __i_desc_type_node, __m_desc_type_node;\n tree __t_desc_array_type, __i_desc_array_type, __m_desc_array_type;\n@@ -531,9 +531,6 @@ struct binding_level\n     /* Same, for IDENTIFIER_TYPE_VALUE.  */\n     tree type_shadowed;\n \n-    /* Same, for IDENTIFIER_GLOBAL_VALUE for overloaded functions.  */\n-    tree overloads_shadowed;\n-\n     /* For each level (except not the global one),\n        a chain of BLOCK nodes for all the levels\n        that were entered and exited one level down.  */\n@@ -1025,9 +1022,6 @@ poplevel (keep, reverse, functionbody)\n   for (link = current_binding_level->type_shadowed;\n        link; link = TREE_CHAIN (link))\n     IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-  for (link = current_binding_level->overloads_shadowed;\n-       link; link = TREE_CHAIN (link))\n-    IDENTIFIER_GLOBAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n \n   /* If the level being exited is the top level of a function,\n      check over all the labels.  */\n@@ -1232,9 +1226,11 @@ pushlevel_class ()\n   while (current_binding_level->parm_flag == 2);\n }\n \n-/* ...and a poplevel for class declarations.  */\n+/* ...and a poplevel for class declarations.  FORCE is used to force\n+   clearing out of CLASS_VALUEs after a class definition.  */\n tree\n-poplevel_class ()\n+poplevel_class (force)\n+     int force;\n {\n   register struct binding_level *level = class_binding_level;\n   tree block = NULL_TREE;\n@@ -1250,7 +1246,7 @@ poplevel_class ()\n      shouldn't even be used when current_class_type isn't set, and second,\n      if we don't touch it here, we're able to use the caching effect if the\n      next time we're entering a class scope, it is the same class.  */\n-  if (current_class_depth != 1)\n+  if (current_class_depth != 1 || force)\n     for (shadowed = level->class_shadowed;\n \t shadowed;\n \t shadowed = TREE_CHAIN (shadowed))\n@@ -1779,10 +1775,7 @@ pushtag (name, type, globalize)\n \t  if (b->parm_flag != 2\n \t      || TYPE_SIZE (current_class_type) != NULL_TREE)\n \t    {\n-\t      if (current_lang_name == lang_name_cplusplus)\n-\t\td = lookup_nested_type (type, cdecl);\n-\t      else\n-\t\td = NULL_TREE;\n+\t      d = lookup_nested_type (type, cdecl);\n \n \t      if (d == NULL_TREE)\n \t\t{\n@@ -1854,7 +1847,7 @@ pushtag (name, type, globalize)\n \t    }\n \t  TYPE_NAME (type) = d;\n \n-\t  if (context == NULL_TREE || current_lang_name != lang_name_cplusplus)\n+\t  if (context == NULL_TREE)\n \t    /* Non-nested class.  */\n \t    DECL_NESTED_TYPENAME (d) = name;\n \t  else if (context && TREE_CODE (context) == FUNCTION_DECL)\n@@ -1980,10 +1973,10 @@ decls_match (newdecl, olddecl)\n \t is METHOD_TYPE.  Change that to FUNCTION_TYPE, and\n \t proceed.  */\n       if (TREE_CODE (f1) == METHOD_TYPE && DECL_STATIC_FUNCTION_P (olddecl))\n-\trevert_static_member_fn (&f1, &newdecl, &p1);\n+\trevert_static_member_fn (&newdecl, &f1, &p1);\n       else if (TREE_CODE (f2) == METHOD_TYPE\n \t       && DECL_STATIC_FUNCTION_P (newdecl))\n-\trevert_static_member_fn (&f2, &olddecl, &p2);\n+\trevert_static_member_fn (&olddecl, &f2, &p2);\n \n       /* Here we must take care of the case where new default\n \t parameters are specified.  Also, warn if an old\n@@ -2154,29 +2147,29 @@ duplicate_decls (newdecl, olddecl)\n   else if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t   && (DECL_BUILT_IN (olddecl) || DECL_BUILT_IN_NONANSI (olddecl))\n \t   && DECL_ASSEMBLER_NAME (newdecl) == DECL_ASSEMBLER_NAME (olddecl))\n+    /* Redeclaring a builtin as another function is handled in\n+       push_overloaded_decl.  */\n     {\n       /* If you declare a built-in or predefined function name as static,\n \t the old definition is overridden,\n \t but optionally warn this was a bad choice of name.  */\n       if (! TREE_PUBLIC (newdecl))\n-\t{\n-\t  if (warn_shadow)\n-\t    cp_warning (\"shadowing %s function `%#D'\",\n-\t\t\tDECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n-\t\t\tnewdecl);\n-\t  /* Discard the old built-in function.  */\n-\t}\n-      else if (! types_match)\n+\tif (warn_shadow)\n+\t  cp_warning (\"shadowing %s function `%#D'\",\n+\t\t      DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n+\t\t      newdecl);\n+      /* Likewise, if the built-in is not ansi, then programs can override\n+         it even globally without an error.  */\n+      else if (! DECL_BUILT_IN (olddecl))\n+\tcp_warning (\"library function `%#D' redeclared as non-function `%#D'\",\n+\t\t    olddecl, newdecl);\n+      else\n \t{\n \t  cp_warning (\"declaration of `%#D'\", newdecl);\n \t  cp_warning (\"conflicts with built-in declaration `%#D'\",\n \t\t      olddecl);\n \t}\n-      if (TREE_CODE (newdecl) != FUNCTION_DECL)\n-\treturn 0;\n-\n-      if (! types_match)\n-\tTREE_TYPE (olddecl) = TREE_TYPE (newdecl);\n+      return 0;\n     }\n   else if (TREE_CODE (olddecl) != TREE_CODE (newdecl))\n     {\n@@ -2211,8 +2204,15 @@ duplicate_decls (newdecl, olddecl)\n \t\t\tnewdecl);\n \t      cp_error_at (\"previous declaration `%#D' here\", olddecl);\n \t    }\n-\t  \n-\t  return 0;\n+\n+\t  if (compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n+\t\t\t TYPE_ARG_TYPES (TREE_TYPE (olddecl)), 2))\n+\t    {\n+\t      cp_error (\"new declaration `%#D'\", newdecl);\n+\t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);\n+\t    }\n+\t  else\n+\t    return 0;\n \t}\n \n       /* Already complained about this, so don't do so again.  */\n@@ -2333,7 +2333,7 @@ duplicate_decls (newdecl, olddecl)\n   /* Optionally warn about more than one declaration for the same name,\n      but don't warn about a function declaration followed by a definition.  */\n   if (warn_redundant_decls\n-      && DECL_SOURCE_LINE (olddecl) != 0\n+      && ! DECL_ARTIFICIAL (olddecl)\n       && !(new_defines_function && DECL_INITIAL (olddecl) == NULL_TREE)\n       /* Don't warn about extern decl followed by (tentative) definition.  */\n       && !(DECL_EXTERNAL (olddecl) && ! DECL_EXTERNAL (newdecl)))\n@@ -2490,6 +2490,14 @@ duplicate_decls (newdecl, olddecl)\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n+      if (! types_match)\n+\t{\n+\t  DECL_LANGUAGE (olddecl) = DECL_LANGUAGE (newdecl);\n+\t  DECL_ASSEMBLER_NAME (olddecl) = DECL_ASSEMBLER_NAME (newdecl);\n+\t  DECL_ARGUMENTS (olddecl) = DECL_ARGUMENTS (newdecl);\n+\t  DECL_RESULT (olddecl) = DECL_RESULT (newdecl);\n+\t  DECL_RTL (olddecl) = DECL_RTL (newdecl);\n+\t}\n       if (new_defines_function)\n \t/* If defining a function declared with other language\n \t   linkage, use the previously declared language linkage.  */\n@@ -2630,10 +2638,9 @@ pushdecl (x)\n     nglobals = len;\n #endif\n \n-  /* Don't change DECL_CONTEXT of virtual methods.  */\n   if (x != current_function_decl\n-      && (TREE_CODE (x) != FUNCTION_DECL\n-\t  || !DECL_VIRTUAL_P (x))\n+      /* Don't change DECL_CONTEXT of virtual methods.  */\n+      && (TREE_CODE (x) != FUNCTION_DECL || !DECL_VIRTUAL_P (x))\n       && ! DECL_CONTEXT (x))\n     DECL_CONTEXT (x) = current_function_decl;\n   /* A local declaration for a function doesn't constitute nesting.  */\n@@ -2660,10 +2667,7 @@ pushdecl (x)\n       char *file;\n       int line;\n \n-      if (DECL_EXTERNAL (x))\n-\tt = lookup_name (name, 0);\n-      else\n-\tt = lookup_name_current_level (name);\n+      t = lookup_name_current_level (name);\n       if (t == error_mark_node)\n \t{\n \t  /* error_mark_node is 0 for a while during initialization!  */\n@@ -2956,7 +2960,7 @@ pushdecl (x)\n \t  /* Maybe warn if shadowing something else.  */\n \t  else if (warn_shadow && !DECL_EXTERNAL (x)\n \t\t   /* No shadow warnings for internally generated vars.  */\n-\t\t   && DECL_SOURCE_LINE (x) != 0\n+\t\t   && ! DECL_ARTIFICIAL (x)\n \t\t   /* No shadow warnings for vars made for inlining.  */\n \t\t   && ! DECL_FROM_INLINE (x))\n \t    {\n@@ -2997,7 +3001,7 @@ pushdecl (x)\n     {\n       if (current_class_name)\n \t{\n-\t  if (!DECL_NESTED_TYPENAME (x))\n+\t  if (!DECL_NESTED_TYPENAME (TYPE_NAME (TREE_TYPE (x))))\n \t    set_nested_typename (x, current_class_name, DECL_NAME (x),\n \t\t\t\t TREE_TYPE (x));\n \t}\n@@ -3173,10 +3177,10 @@ overloaded_globals_p (list)\n   return 0;\n }\n \n-/* DECL is a FUNCTION_DECL which may have other definitions already in place.\n-   We get around this by making IDENTIFIER_GLOBAL_VALUE (DECL_NAME (DECL))\n-   point to a list of all the things that want to be referenced by that name.\n-   It is then up to the users of that name to decide what to do with that\n+/* DECL is a FUNCTION_DECL which may have other definitions already in\n+   place.  We get around this by making the value of the identifier point\n+   to a list of all the things that want to be referenced by that name.  It\n+   is then up to the users of that name to decide what to do with that\n    list.\n \n    DECL may also be a TEMPLATE_DECL, with a FUNCTION_DECL in its DECL_RESULT\n@@ -3191,80 +3195,89 @@ push_overloaded_decl (decl, forgettable)\n      int forgettable;\n {\n   tree orig_name = DECL_NAME (decl);\n-  tree glob = IDENTIFIER_GLOBAL_VALUE (orig_name);\n+  tree old;\n+  int doing_global = (global_bindings_p () || ! forgettable\n+\t\t      || flag_traditional || pseudo_global_level_p ());\n+\n+  if (doing_global)\n+    {\n+      old = IDENTIFIER_GLOBAL_VALUE (orig_name);\n+      if (old && TREE_CODE (old) == FUNCTION_DECL\n+\t  && (DECL_BUILT_IN (old) || DECL_BUILT_IN_NONANSI (old)))\n+\t{\n+\t  if (! decls_match (decl, old)\n+\t      && (DECL_LANGUAGE (decl) == lang_c\n+\t\t  || compparms (TYPE_ARG_TYPES (TREE_TYPE (decl)),\n+\t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (old)), 2)))\n+\t    {\n+\t      cp_warning (\"declaration of `%#D'\", decl);\n+\t      cp_warning (\"conflicts with built-in declaration `%#D'\", old);\n+\t    }\n+\t  old = NULL_TREE;\n+\t}\n+    }\n+  else\n+    {\n+      old = IDENTIFIER_LOCAL_VALUE (orig_name);\n+      \n+      if (! purpose_member (orig_name, current_binding_level->shadowed))\n+\t{\n+\t  current_binding_level->shadowed\n+\t    = tree_cons (orig_name, old, current_binding_level->shadowed);\n+\t  old = NULL_TREE;\n+\t}\n+    }\n \n-  if (glob)\n+  if (old)\n     {\n+#if 0\n       /* We cache the value of builtin functions as ADDR_EXPRs\n \t in the name space.  Convert it to some kind of _DECL after\n \t remembering what to forget.  */\n-      if (TREE_CODE (glob) == ADDR_EXPR)\n-\tglob = TREE_OPERAND (glob, 0);\n-\n-      else if (TREE_CODE (decl) == TEMPLATE_DECL)\n-\t{\n-\t  tree tmp;\n-\n-\t  for (tmp = get_first_fn (glob); tmp; tmp = DECL_CHAIN (tmp))\n-\t    if (decl == tmp || duplicate_decls (decl, tmp))\n-\t      return decl;\n-\t}\n-      else if (TREE_CODE (glob) == VAR_DECL)\n+      if (TREE_CODE (old) == ADDR_EXPR)\n+\told = TREE_OPERAND (old, 0);\n+      else\n+#endif\n+      if (TREE_CODE (old) == VAR_DECL)\n \t{\n-\t  cp_error_at (\"previous non-function declaration `%#D'\", glob);\n+\t  cp_error_at (\"previous non-function declaration `%#D'\", old);\n \t  cp_error (\"conflicts with function declaration `%#D'\", decl);\n \t  return error_mark_node;\n \t}\n-      else if (TREE_CODE (glob) == TYPE_DECL)\n+      else if (TREE_CODE (old) == TYPE_DECL)\n \t{\n-\t  tree t = TREE_TYPE (glob);\n+\t  tree t = TREE_TYPE (old);\n \t  if (IS_AGGR_TYPE (t) && warn_shadow)\n \t    cp_warning (\"`%#D' hides constructor for `%#T'\", decl, t);\n \t}\n-      else if (is_overloaded_fn (glob))\n+      else if (is_overloaded_fn (old))\n         {\n           tree tmp;\n \t  \n-\t  for (tmp = get_first_fn (glob); tmp; tmp = DECL_CHAIN (tmp))\n-\t    {\n-\t      if (decl == tmp || duplicate_decls (decl, tmp))\n-\t\treturn tmp;\n-\t      /* Avoid doing things about built-ins, since duplicate_decls\n-\t\t will have given warnings/errors for them.  */\n-\t      if (!DECL_BUILT_IN (tmp) && !DECL_BUILT_IN_NONANSI (tmp)\n-\t\t  && compparms (TYPE_ARG_TYPES (TREE_TYPE (decl)),\n-\t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (tmp)), 2))\n-\t\t{\n-\t\t  cp_error (\"new declaration `%#D'\", decl);\n-\t\t  cp_error_at (\"ambiguates old declaration `%#D'\", tmp);\n-\t\t}\n-\t    }\n+\t  for (tmp = get_first_fn (old); tmp; tmp = DECL_CHAIN (tmp))\n+\t    if (decl == tmp || duplicate_decls (decl, tmp))\n+\t      return tmp;\n \t}\n     }\n \n-  if (forgettable\n-      && ! flag_traditional\n-      && (glob == NULL_TREE || TREE_PERMANENT (glob) == 1)\n-      && !global_bindings_p ()\n-      && !pseudo_global_level_p ())\n-    current_binding_level->overloads_shadowed\n-      = tree_cons (orig_name, glob,\n-\t\t   current_binding_level->overloads_shadowed);\n-\n-  if (glob || TREE_CODE (decl) == TEMPLATE_DECL)\n+  if (old || TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n-      if (glob && is_overloaded_fn (glob))\n-\tDECL_CHAIN (decl) = get_first_fn (glob);\n+      if (old && is_overloaded_fn (old))\n+\tDECL_CHAIN (decl) = get_first_fn (old);\n       else\n \tDECL_CHAIN (decl) = NULL_TREE;\n-      glob = tree_cons (orig_name, decl, NULL_TREE);\n-      TREE_TYPE (glob) = unknown_type_node;\n+      old = tree_cons (orig_name, decl, NULL_TREE);\n+      TREE_TYPE (old) = unknown_type_node;\n     }\n   else\n     /* orig_name is not ambiguous.  */\n-    glob = decl;\n-  \n-  IDENTIFIER_GLOBAL_VALUE (orig_name) = glob;\n+    old = decl;\n+\n+  if (doing_global)\n+    IDENTIFIER_GLOBAL_VALUE (orig_name) = old;\n+  else\n+    IDENTIFIER_LOCAL_VALUE (orig_name) = old;\n+\n   return decl;\n }\n \f\n@@ -3530,7 +3543,7 @@ define_label (filename, line, name)\n \t\t\t   of internal entities.  They can't be accessed,\n \t\t\t   and they should be cleaned up\n \t\t\t   by the time we get to the label.  */\n-\t\t\t&& DECL_SOURCE_LINE (new_decls) != 0\n+\t\t\t&& ! DECL_ARTIFICIAL (new_decls)\n \t\t\t&& ((DECL_INITIAL (new_decls) != NULL_TREE\n \t\t\t     && DECL_INITIAL (new_decls) != error_mark_node)\n \t\t\t    || TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (new_decls))))\n@@ -3849,9 +3862,9 @@ lookup_nested_type (type, context)\n    Otherwise we prefer non-TYPE_DECLs.  */\n \n tree\n-lookup_name (name, prefer_type)\n+lookup_name_real (name, prefer_type, nonclass)\n      tree name;\n-     int prefer_type;\n+     int prefer_type, nonclass;\n {\n   register tree val;\n   int yylex = 0;\n@@ -3879,10 +3892,29 @@ lookup_name (name, prefer_type)\n \t  else if (! IS_AGGR_TYPE (got_scope))\n \t    /* Someone else will give an error about this if needed. */\n \t    val = NULL_TREE;\n+\t  else if (TYPE_BEING_DEFINED (got_scope))\n+\t    {\n+\t      val = IDENTIFIER_CLASS_VALUE (name);\n+\t      if (val && DECL_CONTEXT (val) != got_scope)\n+\t\t{\n+\t\t  struct binding_level *b = class_binding_level;\n+\t\t  for (val = NULL_TREE; b; b = b->level_chain)\n+\t\t    {\n+\t\t      tree t = purpose_member (name, b->class_shadowed);\n+\t\t      if (t && TREE_VALUE (t)\n+\t\t\t  && DECL_CONTEXT (TREE_VALUE (t)) == got_scope)\n+\t\t\t{\n+\t\t\t  val = TREE_VALUE (t);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      if (val == NULL_TREE\n+\t\t  && CLASSTYPE_LOCAL_TYPEDECLS (got_scope))\n+\t\tval = lookup_field (got_scope, name, 0, 1);\n+\t    }\n \t  else if (got_scope == current_class_type)\n \t    val = IDENTIFIER_CLASS_VALUE (name);\n-\t  else if (TYPE_BEING_DEFINED (got_scope))\n-\t    val = lookup_nested_tag (got_scope, name);\n \t  else\n \t    val = lookup_field (got_scope, name, 0, 0);\n \n@@ -3895,21 +3927,19 @@ lookup_name (name, prefer_type)\n     val = IDENTIFIER_LOCAL_VALUE (name);\n   /* In C++ class fields are between local and global scope,\n      just before the global scope.  */\n-  else if (current_class_type)\n+  else if (current_class_type && ! nonclass)\n     {\n       val = IDENTIFIER_CLASS_VALUE (name);\n       if (val == NULL_TREE\n-\t  && TYPE_SIZE (current_class_type) == NULL_TREE\n+\t  && TYPE_BEING_DEFINED (current_class_type)\n \t  && CLASSTYPE_LOCAL_TYPEDECLS (current_class_type))\n+\t/* Try to find values from base classes if we are presently\n+\t   defining a type.  We are presently only interested in\n+\t   TYPE_DECLs.  */\n \t{\n-\t  /* Try to find values from base classes\n-\t     if we are presently defining a type.\n-\t     We are presently only interested in TYPE_DECLs.  */\n \t  val = lookup_field (current_class_type, name, 0, 1);\n-\t  if (val == error_mark_node)\n-\t    return val;\n-\t  if (val && TREE_CODE (val) != TYPE_DECL)\n-\t    val = NULL_TREE;\n+\t  if (val)\n+\t    pushdecl_class_level (val);\n \t}\n \n       /* yylex() calls this with -2, since we should never start digging for\n@@ -3948,6 +3978,21 @@ lookup_name (name, prefer_type)\n   return val;\n }\n \n+tree\n+lookup_name_nonclass (name)\n+     tree name;\n+{\n+  return lookup_name_real (name, 0, 1);\n+}\n+\n+tree\n+lookup_name (name, prefer_type)\n+     tree name;\n+     int prefer_type;\n+{\n+  return lookup_name_real (name, prefer_type, 0);\n+}\n+\n /* Similar to `lookup_name' but look only at current binding level.  */\n \n tree\n@@ -4654,34 +4699,40 @@ init_decl_processing ()\n       pushdecl (lookup_name (get_identifier (\"__gc_main\"), 0));\n     }\n \n-  /* Simplify life by making a \"memptr_type\".  Give its\n-     fields names so that the debugger can use them.  */\n-\n-  memptr_type = make_lang_type (RECORD_TYPE);\n-  fields[0] = build_lang_field_decl (FIELD_DECL, delta_identifier,\n-\t\t\t\t     delta_type_node);\n-  fields[1] = build_lang_field_decl (FIELD_DECL, index_identifier,\n-\t\t\t\t     delta_type_node);\n-  fields[2] = build_lang_field_decl (FIELD_DECL, pfn_identifier,\n-\t\t\t\t     ptr_type_node);\n-  finish_builtin_type (memptr_type, VTBL_PTR_TYPE, fields, 2,\n-\t\t       double_type_node);\n-\n-  /* Make this part of an invisible union.  */\n-  fields[3] = copy_node (fields[2]);\n-  TREE_TYPE (fields[3]) = delta_type_node;\n-  DECL_NAME (fields[3]) = delta2_identifier;\n-  DECL_MODE (fields[3]) = TYPE_MODE (delta_type_node);\n-  DECL_SIZE (fields[3]) = TYPE_SIZE (delta_type_node);\n-  TREE_UNSIGNED (fields[3]) = 0;\n-  TREE_CHAIN (fields[2]) = fields[3];\n-  memptr_type = build_type_variant (memptr_type, 1, 0);\n-  record_builtin_type (RID_MAX, VTBL_PTR_TYPE, memptr_type);\n-\n   if (flag_vtable_thunks)\n-    vtable_entry_type = ptr_type_node;\n+    {\n+      /* Make sure we get a unique function type, so we can give\n+\t its pointer type a name.  (This wins for gdb.) */\n+      tree vfunc_type = make_node (FUNCTION_TYPE);\n+      TREE_TYPE (vfunc_type) = integer_type_node;\n+      TYPE_ARG_TYPES (vfunc_type) = NULL_TREE;\n+      layout_type (vfunc_type);\n+\n+      vtable_entry_type = build_pointer_type (vfunc_type);\n+    }\n   else\n-    vtable_entry_type = memptr_type;\n+    {\n+      vtable_entry_type = make_lang_type (RECORD_TYPE);\n+      fields[0] = build_lang_field_decl (FIELD_DECL, delta_identifier,\n+\t\t\t\t\t delta_type_node);\n+      fields[1] = build_lang_field_decl (FIELD_DECL, index_identifier,\n+\t\t\t\t\t delta_type_node);\n+      fields[2] = build_lang_field_decl (FIELD_DECL, pfn_identifier,\n+\t\t\t\t\t ptr_type_node);\n+      finish_builtin_type (vtable_entry_type, VTBL_PTR_TYPE, fields, 2,\n+\t\t\t   double_type_node);\n+\n+      /* Make this part of an invisible union.  */\n+      fields[3] = copy_node (fields[2]);\n+      TREE_TYPE (fields[3]) = delta_type_node;\n+      DECL_NAME (fields[3]) = delta2_identifier;\n+      DECL_MODE (fields[3]) = TYPE_MODE (delta_type_node);\n+      DECL_SIZE (fields[3]) = TYPE_SIZE (delta_type_node);\n+      TREE_UNSIGNED (fields[3]) = 0;\n+      TREE_CHAIN (fields[2]) = fields[3];\n+      vtable_entry_type = build_type_variant (vtable_entry_type, 1, 0);\n+    }\n+  record_builtin_type (RID_MAX, VTBL_PTR_TYPE, vtable_entry_type);\n \n   vtbl_type_node\n     = build_array_type (vtable_entry_type, NULL_TREE);\n@@ -6625,7 +6676,8 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n       grok_ctor_properties (ctype, decl);\n       if (check == 0 && ! current_function_decl)\n \t{\n-\t  /* FIXME: this should only need to look at IDENTIFIER_GLOBAL_VALUE.  */\n+\t  /* FIXME: this should only need to look at\n+             IDENTIFIER_GLOBAL_VALUE.  */\n \t  tmp = lookup_name (DECL_ASSEMBLER_NAME (decl), 0);\n \t  if (tmp == NULL_TREE)\n \t    IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl)) = decl;\n@@ -9515,8 +9567,7 @@ grok_op_properties (decl, virtualp, friendp)\n       /* When the compiler encounters the definition of A::operator new, it\n \t doesn't look at the class declaration to find out if it's static.  */\n       if (methodp)\n-\trevert_static_member_fn (&TREE_TYPE (decl), &decl,\n-\t\t\t\t &TYPE_ARG_TYPES (TREE_TYPE (decl)));\n+\trevert_static_member_fn (&decl, NULL, NULL);\n      \n       /* Take care of function decl if we had syntax errors.  */\n       if (argtypes == NULL_TREE)\n@@ -9531,8 +9582,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t   || name == ansi_opname[(int) VEC_DELETE_EXPR])\n     {\n       if (methodp)\n-\trevert_static_member_fn (&TREE_TYPE (decl), &decl,\n-\t\t\t\t &TYPE_ARG_TYPES (TREE_TYPE (decl)));\n+\trevert_static_member_fn (&decl, NULL, NULL);\n      \n       if (argtypes == NULL_TREE)\n \tTREE_TYPE (decl) =\n@@ -9554,7 +9604,7 @@ grok_op_properties (decl, virtualp, friendp)\n       /* An operator function must either be a non-static member function\n \t or have at least one parameter of a class, a reference to a class,\n \t an enumeration, or a reference to an enumeration.  13.4.0.6 */\n-      if (! methodp)\n+      if (! methodp || DECL_STATIC_FUNCTION_P (decl))\n \t{\n \t  if (OPERATOR_TYPENAME_P (name)\n \t      || name == ansi_opname[(int) CALL_EXPR]\n@@ -9566,6 +9616,9 @@ grok_op_properties (decl, virtualp, friendp)\n \t    {\n \t      tree p = argtypes;\n \n+\t      if (DECL_STATIC_FUNCTION_P (decl))\n+\t\tcp_error (\"`%D' must be either a non-static member function or a non-member function\", decl);\n+\n \t      if (p)\n \t\tfor (; TREE_VALUE (p) != void_type_node ; p = TREE_CHAIN (p))\n \t\t  {\n@@ -12119,20 +12172,30 @@ deactivate_exception_cleanups ()\n }\n \n /* Change a static member function definition into a FUNCTION_TYPE, instead\n-   of the METHOD_TYPE that we create when it's originally parsed.  */\n+   of the METHOD_TYPE that we create when it's originally parsed.\n+\n+   WARNING: DO NOT pass &TREE_TYPE (decl) to FN or &TYPE_ARG_TYPES\n+   (TREE_TYPE (decl)) to ARGTYPES, as doing so will corrupt the types of\n+   other decls.  Either pass the addresses of local variables or NULL.  */\n+\n void\n-revert_static_member_fn (fn, decl, argtypes)\n-     tree *fn, *decl, *argtypes;\n+revert_static_member_fn (decl, fn, argtypes)\n+     tree *decl, *fn, *argtypes;\n {\n-  tree tmp, function = *fn;\n+  tree tmp;\n+  tree function = fn ? *fn : TREE_TYPE (*decl);\n+  tree args = argtypes ? *argtypes : TYPE_ARG_TYPES (function);\n \n-  *argtypes = TREE_CHAIN (*argtypes);\n-  tmp = build_function_type (TREE_TYPE (function), *argtypes);\n+  args = TREE_CHAIN (args);\n+  tmp = build_function_type (TREE_TYPE (function), args);\n   tmp = build_type_variant (tmp, TYPE_READONLY (function),\n \t\t\t    TYPE_VOLATILE (function));\n   tmp = build_exception_variant (TYPE_METHOD_BASETYPE (function), tmp,\n \t\t\t\t TYPE_RAISES_EXCEPTIONS (function));\n   TREE_TYPE (*decl) = tmp;\n-  *fn = tmp;\n   DECL_STATIC_FUNCTION_P (*decl) = 1;\n+  if (fn)\n+    *fn = tmp;\n+  if (argtypes)\n+    *argtypes = args;\n }"}, {"sha": "34b7499fcecb92c360d2bfb683a2ba1e9bc674db", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -781,6 +781,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n   tree fn_name = DECL_NAME (function);\n   tree arg_types;\n   tree parm;\n+  tree qualtype;\n \n   if (fn_name == NULL_TREE)\n     {\n@@ -790,7 +791,9 @@ grokclassfn (ctype, cname, function, flags, quals)\n     }\n \n   if (quals)\n-    ctype = grok_method_quals (ctype, function, quals);\n+    qualtype = grok_method_quals (ctype, function, quals);\n+  else\n+    qualtype = ctype;\n \n   arg_types = TYPE_ARG_TYPES (TREE_TYPE (function));\n   if (TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n@@ -812,7 +815,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n \t\t of virtual baseclasses or not.  */\n \t      parm = build_decl (PARM_DECL, in_charge_identifier, integer_type_node);\n \t      /* Mark the artificial `__in_chrg' parameter as \"artificial\".  */\n-\t      DECL_SOURCE_LINE (parm) = 0;\n+\t      SET_DECL_ARTIFICIAL (parm);\n \t      DECL_ARG_TYPE (parm) = integer_type_node;\n \t      DECL_REGISTER (parm) = 1;\n \t      TREE_CHAIN (parm) = last_function_parms;\n@@ -822,7 +825,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n \n       parm = build_decl (PARM_DECL, this_identifier, type);\n       /* Mark the artificial `this' parameter as \"artificial\".  */\n-      DECL_SOURCE_LINE (parm) = 0;\n+      SET_DECL_ARTIFICIAL (parm);\n       DECL_ARG_TYPE (parm) = type;\n       /* We can make this a register, so long as we don't\n \t accidentally complain if someone tries to take its address.  */\n@@ -865,7 +868,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n       DECL_ASSEMBLER_NAME (function) = get_identifier (buf);\n       parm = build_decl (PARM_DECL, in_charge_identifier, const_integer_type);\n       /* Mark the artificial `__in_chrg' parameter as \"artificial\".  */\n-      DECL_SOURCE_LINE (parm) = 0;\n+      SET_DECL_ARTIFICIAL (parm);\n       TREE_USED (parm) = 1;\n #if 0\n       /* We don't need to mark the __in_chrg parameter itself as `const'\n@@ -878,7 +881,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n       /* This is the same chain as DECL_ARGUMENTS (...).  */\n       TREE_CHAIN (last_function_parms) = parm;\n \n-      TREE_TYPE (function) = build_cplus_method_type (ctype, void_type_node,\n+      TREE_TYPE (function) = build_cplus_method_type (qualtype, void_type_node,\n \t\t\t\t\t\t      arg_types);\n       TYPE_HAS_DESTRUCTOR (ctype) = 1;\n     }\n@@ -891,7 +894,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n \t  arg_types = hash_tree_chain (integer_type_node,\n \t\t\t\t       TREE_CHAIN (arg_types));\n \t  TREE_TYPE (function)\n-\t    = build_cplus_method_type (ctype,\n+\t    = build_cplus_method_type (qualtype,\n \t\t\t\t       TREE_TYPE (TREE_TYPE (function)),\n \t\t\t\t       arg_types);\n \t  arg_types = TYPE_ARG_TYPES (TREE_TYPE (function));\n@@ -901,7 +904,8 @@ grokclassfn (ctype, cname, function, flags, quals)\n \n       if (TREE_CODE (TREE_TYPE (function)) == FUNCTION_TYPE)\n \t/* Only true for static member functions.  */\n-\tthese_arg_types = hash_tree_chain (TYPE_POINTER_TO (ctype), arg_types);\n+\tthese_arg_types = hash_tree_chain (TYPE_POINTER_TO (qualtype),\n+\t\t\t\t\t   arg_types);\n \n       DECL_ASSEMBLER_NAME (function)\n \t= build_decl_overload (fn_name, these_arg_types,\n@@ -1211,6 +1215,8 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n   if (TREE_CODE (value) == TYPE_DECL)\n     {\n       DECL_NONLOCAL (value) = 1;\n+      DECL_CONTEXT (value) = current_class_type;\n+      DECL_CLASS_CONTEXT (value) = current_class_type;\n       CLASSTYPE_LOCAL_TYPEDECLS (current_class_type) = 1;\n       pushdecl_class_level (value);\n       return value;\n@@ -2739,7 +2745,7 @@ finish_file ()\n   vars = build_decl (TYPE_DECL, get_identifier (\" @%$#@!\"), integer_type_node);\n #endif\n   DECL_IGNORED_P (vars) = 1;\n-  DECL_SOURCE_LINE (vars) = 0;\n+  SET_DECL_ARTIFICIAL (vars);\n   pushdecl (vars);\n #endif\n "}, {"sha": "66f12669b084250b753f5c9718e72ab39756633f", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -500,7 +500,7 @@ tree\n ident_fndecl (t)\n      tree t;\n {\n-  tree n = IDENTIFIER_GLOBAL_VALUE (t);\n+  tree n = lookup_name (t, 0);\n \n   if (TREE_CODE (n) == FUNCTION_DECL)\n     return n;"}, {"sha": "8a81db9ef5cf92ebdd057c2578ec0e938488a061", "filename": "gcc/cp/init.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -2791,7 +2791,7 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n     {\n       /* @@ Should be able to ingest later definitions of this function\n \t before use.  */\n-      tree decl = IDENTIFIER_GLOBAL_VALUE (declarator);\n+      tree decl = lookup_name_nonclass (declarator);\n       if (decl == NULL_TREE)\n \t{\n \t  warning (\"implicitly declaring `%s' as struct\",\n@@ -3676,6 +3676,26 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n     {\n       tree dtor = DECL_MAIN_VARIANT (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 0));\n       tree basetypes = TYPE_BINFO (type);\n+      tree passed_auto_delete;\n+      tree do_delete = NULL_TREE;\n+\n+      if (use_global_delete)\n+\t{\n+\t  tree cond = fold (build (BIT_AND_EXPR, integer_type_node,\n+\t\t\t\t   auto_delete, integer_one_node));\n+\t  tree call = build_builtin_call\n+\t    (void_type_node, BID, build_tree_list (NULL_TREE, addr));\n+\n+\t  cond = fold (build (COND_EXPR, void_type_node, cond,\n+\t\t\t      call, void_zero_node));\n+\t  if (cond != void_zero_node)\n+\t    do_delete = cond;\n+\n+\t  passed_auto_delete = fold (build (BIT_AND_EXPR, integer_type_node,\n+\t\t\t\t\t    auto_delete, integer_two_node));\n+\t}\n+      else\n+\tpassed_auto_delete = auto_delete;\n \n       if (flags & LOOKUP_PROTECT)\n \t{\n@@ -3723,8 +3743,10 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t  if (function == error_mark_node)\n \t    return error_mark_node;\n \t  TREE_TYPE (function) = build_pointer_type (TREE_TYPE (dtor));\n-\t  TREE_CHAIN (parms) = build_tree_list (NULL_TREE, auto_delete);\n+\t  TREE_CHAIN (parms) = build_tree_list (NULL_TREE, passed_auto_delete);\n \t  expr = build_function_call (function, parms);\n+\t  if (do_delete)\n+\t    expr = build (COMPOUND_EXPR, void_type_node, expr, do_delete);\n \t  if (ptr && (flags & LOOKUP_DESTRUCTOR) == 0)\n \t    {\n \t      /* Handle the case where a virtual destructor is\n@@ -3761,8 +3783,10 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t     but that's now obsolete.  */\n \t  my_friendly_assert (DECL_INITIAL (dtor) != void_type_node, 221);\n \n-\t  TREE_CHAIN (parms) = build_tree_list (NULL_TREE, auto_delete);\n+\t  TREE_CHAIN (parms) = build_tree_list (NULL_TREE, passed_auto_delete);\n \t  expr = build_function_call (dtor, parms);\n+\t  if (do_delete)\n+\t    expr = build (COMPOUND_EXPR, void_type_node, expr, do_delete);\n \n \t  if (ifexp != integer_one_node)\n \t    expr = build (COND_EXPR, void_type_node,"}, {"sha": "51cb77238e24741ca5f9081ab5cc6062453f4691", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -1836,14 +1836,10 @@ cons_up_default_function (type, name, fields, kind)\n   }\n #endif /* DEBUG_DEFAULT_FUNCTIONS */\n \n-  DECL_CLASS_CONTEXT (fn) = type;\n+  DECL_CLASS_CONTEXT (fn) = TYPE_MAIN_VARIANT (type);\n \n   /* Show that this function was generated by the compiler.  */\n-#if 0\n-  DECL_SOURCE_LINE (fn) = 0;\n-#else\n-  DECL_SYNTHESIZED (fn) = 1;\n-#endif\n+  SET_DECL_ARTIFICIAL (fn);\n   \n   return fn;\n }\n@@ -1956,7 +1952,6 @@ default_assign_ref_body (bufp, lenp, type, fields)\n \n \t  btype = BINFO_TYPE (binfo);\n \t  name = TYPE_NESTED_NAME (btype);\n-          if (!name) name = DECL_NAME(TYPE_NAME(btype));\n \t  s = IDENTIFIER_POINTER (name);\n \n \t  tneed = (2 * strlen (s)) + 33;\n@@ -2122,7 +2117,6 @@ default_copy_constructor_body (bufp, lenp, type, fields)\n \n \t  btype = BINFO_TYPE (binfo);\n \t  name = TYPE_NESTED_NAME (btype);\n-\t  if (!name) name = DECL_NAME(TYPE_NAME(btype));\n \t  s = IDENTIFIER_POINTER (name);\n \n \t  tneed = (2 * strlen (s)) + 30;"}, {"sha": "d4ce558abb98f66a3713280984201a23a41e38df", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -135,7 +135,8 @@ do_inline_function_hair (type, friend_list)\n \t    }\n \n \t  /* Allow this decl to be seen in global scope */\n-\t  IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (fndecl)) = fndecl;\n+\t  if (! current_function_decl)\n+\t    IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (fndecl)) = fndecl;\n \t}\n \n       friend_list = TREE_CHAIN (friend_list);\n@@ -1242,7 +1243,7 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n   else\n     fnname = ansi_opname[(int) code];\n \n-  global_fn = IDENTIFIER_GLOBAL_VALUE (fnname);\n+  global_fn = lookup_name_nonclass (fnname);\n \n   /* This is the last point where we will accept failure.  This\n      may be too eager if we wish an overloaded operator not to match,\n@@ -1682,7 +1683,7 @@ make_thunk (function, delta)\n   thunk = build_decl (THUNK_DECL, get_identifier (buffer),\n \t\t      TREE_TYPE (func_decl));\n   DECL_RESULT (thunk)\n-    = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n+    = build_decl (RESULT_DECL, NULL_TREE, TREE_TYPE (vtable_entry_type));\n   make_function_rtl (thunk);\n   DECL_INITIAL (thunk) = function;\n   THUNK_DELTA (thunk) = delta;\n@@ -1824,7 +1825,7 @@ emit_thunk (thunk_fndecl)\n     emit_insn (gen_rtx (USE, VOIDmode, need_use[--need_use_count]));\n \n   expand_end_bindings (NULL, 1, 0);\n-  poplevel (0, 0, 1);\n+  poplevel (0, 0, 0);\n \n   TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n "}, {"sha": "32c5e524fd99e1f791219fe05251f2735efd323e", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -80,6 +80,8 @@ void yyerror ();\n    error message if the user supplies an empty conditional expression.  */\n static char *cond_stmt_keyword;\n \n+static int doing_explicit;\n+\n /* Nonzero if we have an `extern \"C\"' acting as an extern specifier.  */\n int have_extern_spec;\n int used_extern_spec;\n@@ -262,7 +264,7 @@ empty_parms ()\n %type <ttype> qualified_type_name complete_type_name notype_identifier\n %type <ttype> complex_type_name nested_name_specifier_1\n %type <itype> nomods_initdecls nomods_initdcl0\n-%type <ttype> new_initializer new_placement\n+%type <ttype> new_initializer new_placement specialization\n \n /* in order to recognize aggr tags as defining and thus shadowing. */\n %token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN\n@@ -542,6 +544,7 @@ datadef:\n         | declmods ';'\n \t  { pedwarn (\"empty declaration\"); }\n \t| explicit_instantiation ';'\n+\t\t{ doing_explicit = 0; }\n \t| typed_declspecs ';'\n \t  {\n \t    tree t = $<ttype>$;\n@@ -778,11 +781,16 @@ identifier_defn:\n \t| PTYPENAME_DEFN\n \t;\n \n+do_explicit: TEMPLATE %prec EMPTY\n+\t{ doing_explicit = 1; }\n+\t;\n+\n explicit_instantiation:\n-\t  TEMPLATE aggr template_type\n-\t\t{ do_type_instantiation ($3); }\n-\t| TEMPLATE typed_declspecs declarator\n+\t  do_explicit specialization template_instantiation\n+\t\t{ do_type_instantiation ($3 ? $3 : $2); }\n+\t| do_explicit typed_declspecs declarator\n \t\t{ do_function_instantiation ($2, $3); }\n+\t| do_explicit error\n \t;\n \n template_type:\n@@ -797,8 +805,8 @@ template_type_name:\n \t\t{ $$ = lookup_template_class ($$, $3, NULL_TREE); }\n \t;\n \n-tmpl.2: %prec EMPTY\n-\t/* Always do expansion if it hasn't been done already. */\n+tmpl.2: \n+\t  /* empty */ %prec EMPTY\n \t\t{ $$ = instantiate_class_template ($<ttype>0, 1); }\n \t;\n \n@@ -2212,6 +2220,15 @@ aggr:\t  AGGR\n \t\t{ error (\"no body nor ';' separates two class, struct or union declarations\"); }\n \t;\n \n+specialization:\n+\t  aggr template_type_name ';'\n+\t\t{ \n+\t\t  yyungetc (';', 1); current_aggr = $$; $$ = $2; \n+\t\t  if (doing_explicit)\n+\t\t    instantiate_class_template ($$, 1);\n+\t\t}\n+\t;\n+\n named_class_head_sans_basetype:\n \t  aggr identifier\n \t\t{ current_aggr = $$; $$ = $2; }\n@@ -2227,6 +2244,7 @@ named_class_head_sans_basetype:\n \t\t  overload_template_name ($$, 0); }\n \t| aggr template_type_name ':'\n \t\t{ yyungetc (':', 1); goto aggr2; }\n+\t| specialization\n \t;\n \n named_class_head_sans_basetype_defn:\n@@ -4137,7 +4155,7 @@ operator_name:\n \t\t{ $$ = ansi_opname[VEC_NEW_EXPR]; }\n \t| operator DELETE '[' ']'\n \t\t{ $$ = ansi_opname[VEC_DELETE_EXPR]; }\n-\t/* Should we be pushing into class scope to parse this?  */\n+\t/* Names here should be looked up in class scope ALSO.  */\n \t| operator typed_typespecs conversion_declarator\n \t\t{ $$ = grokoptypename ($2, $3); }\n \t| operator error"}, {"sha": "377d4a7a7e3c705c3639656945d3322452e1268e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -1314,7 +1314,7 @@ tsubst (t, args, nargs, in_decl)\n \t      tree decls;\n \t      int got_it = 0;\n \n-\t      decls = IDENTIFIER_GLOBAL_VALUE (r);\n+\t      decls = lookup_name (r, 0);\n \t      if (decls == NULL_TREE)\n \t\t/* no match */;\n \t      else if (TREE_CODE (decls) == TREE_LIST)\n@@ -1624,8 +1624,7 @@ instantiate_template (tmpl, targ_ptr)\n       && DECL_STATIC_FUNCTION_P (fndecl))\n     {\n       tree olddecl = DECL_RESULT (tmpl);\n-      revert_static_member_fn (&TREE_TYPE (olddecl), &DECL_RESULT (tmpl),\n-\t\t\t       &TYPE_ARG_TYPES (TREE_TYPE (olddecl)));\n+      revert_static_member_fn (&DECL_RESULT (tmpl), NULL, NULL);\n       /* Chop off the this pointer that grokclassfn so kindly added\n \t for us (it didn't know yet if the fn was static or not).  */\n       DECL_ARGUMENTS (olddecl) = TREE_CHAIN (DECL_ARGUMENTS (olddecl));"}, {"sha": "946763c4aaa9892e8e795cd97cbab4d712cbb254", "filename": "gcc/cp/search.c", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -813,7 +813,7 @@ compute_access (basetype_path, field)\n     PUBLIC_RETURN;\n \n   /* Member found immediately within object.  */\n-  if (BINFO_INHERITANCE_CHAIN (basetype_path) == NULL_TREE || static_mem)\n+  if (BINFO_INHERITANCE_CHAIN (basetype_path) == NULL_TREE)\n     {\n       /* Are we (or an enclosing scope) friends with the class that has\n          FIELD? */\n@@ -847,7 +847,8 @@ compute_access (basetype_path, field)\n   types = basetype_path;\n   via_protected = 0;\n   access = access_default;\n-  protected_ok = 0;\n+  protected_ok = static_mem && current_class_type\n+    && ACCESSIBLY_DERIVED_FROM_P (BINFO_TYPE (types), current_class_type);\n \n   while (1)\n     {\n@@ -1024,7 +1025,6 @@ lookup_field (xbasetype, name, protect, want_type)\n      we know that binfo of a virtual base class will always == itself when\n      found along any line.  (mrs)  */\n \n-  /* Things for memoization.  */\n   char *errstr = 0;\n \n   /* Set this to nonzero if we don't know how to compute\n@@ -1209,7 +1209,11 @@ lookup_field (xbasetype, name, protect, want_type)\n \n       if (nval || lookup_fnfields_here (type, name)>=0)\n \t{\n-\t  if (rval_binfo && hides (rval_binfo_h, binfo_h))\n+\t  if (nval && nval == rval && SHARED_MEMBER_P (nval))\n+\t    {\n+\t      /* This is ok, the member found is the same [class.ambig] */\n+\t    }\n+\t  else if (rval_binfo && hides (rval_binfo_h, binfo_h))\n \t    {\n \t      /* This is ok, the member found is in rval_binfo, not\n \t\t here (binfo). */\n@@ -1476,7 +1480,6 @@ lookup_fnfields (basetype_path, name, complain)\n   /* For now, don't try this.  */\n   int protect = complain;\n \n-  /* Things for memoization.  */\n   char *errstr = 0;\n \n   /* Set this to nonzero if we don't know how to compute\n@@ -1578,11 +1581,6 @@ lookup_fnfields (basetype_path, name, complain)\n \t  TREE_TYPE (entry) = NULL_TREE;\n \t}\n \n-      if (errstr && protect)\n-\t{\n-\t  error (errstr, IDENTIFIER_POINTER (name), TYPE_NAME_STRING (type));\n-\t  return error_mark_node;\n-\t}\n       return rvals;\n     }\n   rval = NULL_TREE;\n@@ -1697,7 +1695,7 @@ lookup_fnfields (basetype_path, name, complain)\n \t  else\n \t    {\n \t      /* This is ambiguous. */\n-\t      errstr = \"request for member `%s' is ambiguous\";\n+\t      errstr = \"request for method `%D' is ambiguous\";\n \t      rvals = error_mark_node;\n \t      break;\n \t    }\n@@ -1733,7 +1731,7 @@ lookup_fnfields (basetype_path, name, complain)\n \n   if (errstr && protect)\n     {\n-      error (errstr, IDENTIFIER_POINTER (name), TYPE_NAME_STRING (type));\n+      cp_error (errstr, name);\n       rvals = error_mark_node;\n     }\n \n@@ -1946,7 +1944,8 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \t\t  if (IDENTIFIER_ERROR_LOCUS (name) == NULL_TREE\n \t\t      && ! comptypes (TREE_TYPE (TREE_TYPE (tmp)), drettype, 1))\n \t\t    {\n-\t\t      cp_error (\"conflicting return type specified for virtual function `%D'\", fndecl);\n+\t\t      cp_error (\"conflicting return type specified for virtual function `%#D'\", fndecl);\n+\t\t      cp_error (\"overriding definition as `%#D'\", tmp);\n \t\t      SET_IDENTIFIER_ERROR_LOCUS (name, basetype);\n \t\t    }\n \t\t  break;\n@@ -2368,7 +2367,7 @@ dfs_debug_mark (binfo)\n   /* We cannot rely on some alien method to solve our problems,\n      so we must write out the debug info ourselves.  */\n   if (write_symbols != DWARF_DEBUG)\n-    DECL_IGNORED_P (TYPE_NAME (t)) = 0;\n+    TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 0;\n   if (! TREE_ASM_WRITTEN (TYPE_NAME (t)))\n     rest_of_type_compilation (t, global_bindings_p ());\n }\n@@ -3175,27 +3174,3 @@ reinit_search_statistics ()\n   n_outer_fields_searched = 0;\n   n_contexts_saved = 0;\n }\n-\n-tree\n-lookup_nested_tag (type, name)\n-     tree type, name;\n-{\n-  tree tags = CLASSTYPE_TAGS (type);\n-\n-  for (; tags; tags = TREE_CHAIN (tags))\n-    {\n-      /* The TREE_PURPOSE of an enum tag (which becomes a member of the\n-\t enclosing class) is set to the name for the enum type.  So, if\n-\t name is `bar', and we strike `baz' for `enum bar { baz }', then\n-\t this test will be true.  */\n-      if (TREE_PURPOSE (tags) == name)\n-\tbreak;\n-    }\n-  if (tags)\n-    return TYPE_NAME (TREE_VALUE (tags));\n-\n-  if (TYPE_CONTEXT (type))\n-    return lookup_nested_tag (TYPE_CONTEXT (type), name);\n-\n-  return NULL_TREE;\n-}"}, {"sha": "55f5f86f3c377139a7f52304bd718c96059036d9", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -2114,28 +2114,35 @@ get_member_function_from_ptrfunc (instance_ptrptr, instance, function)\n \treturn instance;\n \n       vtbl = convert_pointer_to (ptr_type_node, instance);\n-      vtbl = build (PLUS_EXPR,\n-\t\t    build_pointer_type (build_pointer_type (memptr_type)),\n-\t\t    vtbl, convert (sizetype, delta2));\n+      vtbl\n+\t= build (PLUS_EXPR,\n+\t\t build_pointer_type (build_pointer_type (vtable_entry_type)),\n+\t\t vtbl, convert (sizetype, delta2));\n       vtbl = build_indirect_ref (vtbl, NULL_PTR);\n       aref = build_array_ref (vtbl, size_binop (MINUS_EXPR,\n \t\t\t\t\t\tindex,\n \t\t\t\t\t\tinteger_one_node));\n-      aref = save_expr (aref);\n+      if (! flag_vtable_thunks)\n+\t{\n+\t  aref = save_expr (aref);\n \n-      /* Save the intermediate result in a SAVE_EXPR so we don't have to\n-\t compute each component of the virtual function pointer twice.  */ \n-     if (/* !building_cleanup && */ TREE_CODE (aref) == INDIRECT_REF)\n-\tTREE_OPERAND (aref, 0) = save_expr (TREE_OPERAND (aref, 0));\n+\t  /* Save the intermediate result in a SAVE_EXPR so we don't have to\n+\t     compute each component of the virtual function pointer twice.  */ \n+\t  if (/* !building_cleanup && */ TREE_CODE (aref) == INDIRECT_REF)\n+\t    TREE_OPERAND (aref, 0) = save_expr (TREE_OPERAND (aref, 0));\n       \n-      delta = build (PLUS_EXPR, integer_type_node,\n-\t\t     build_conditional_expr (e1, build_component_ref (aref, delta_identifier, 0, 0), integer_zero_node),\n-\t\t     delta);\n+\t  delta = build (PLUS_EXPR, integer_type_node,\n+\t\t\t build_conditional_expr (e1, build_component_ref (aref, delta_identifier, 0, 0), integer_zero_node),\n+\t\t\t delta);\n+\t}\n \n       *instance_ptrptr = build (PLUS_EXPR, TREE_TYPE (*instance_ptrptr),\n \t\t\t\t*instance_ptrptr,\n \t\t\t\tconvert (integer_type_node, delta));\n-      e2 = build_component_ref (aref, pfn_identifier, 0, 0);\n+      if (flag_vtable_thunks)\n+\te2 = aref;\n+      else\n+\te2 = build_component_ref (aref, pfn_identifier, 0, 0);\n \n       e3 = PFN_FROM_PTRMEMFUNC (function);\n       TREE_TYPE (e2) = TREE_TYPE (e3);\n@@ -5502,10 +5509,16 @@ build_modify_expr (lhs, modifycode, rhs)\n   /* check to see if there is an assignment to `this' */\n   if (lhs == current_class_decl)\n     {\n-      if (flag_this_is_variable > 0\n-\t  && DECL_NAME (current_function_decl) != NULL_TREE\n-\t  && current_class_name != DECL_NAME (current_function_decl))\n-\twarning (\"assignment to `this' not in constructor or destructor\");\n+      if (DECL_NAME (current_function_decl) != NULL_TREE)\n+\t{\n+\t  /* ARM 18.3.3 and draft standard section C.11 say that assigning\n+\t     something to this is an anachronism.  */\n+\t  if (pedantic)\n+\t    warning (\"anachronistic assignment to `this' pointer\");\n+\t  else if (flag_this_is_variable > 0\n+\t\t   && current_class_name != DECL_NAME (current_function_decl))\n+\t    warning (\"assignment to `this' not in constructor or destructor\");\n+\t}\n       current_function_just_assigned_this = 1;\n     }\n \n@@ -5670,7 +5683,7 @@ build_modify_expr (lhs, modifycode, rhs)\n     {\n       /* Allow array assignment in compiler-generated code.  */\n       if ((pedantic || flag_ansi)\n-\t  && ! DECL_SYNTHESIZED (current_function_decl))\n+\t  && ! DECL_ARTIFICIAL (current_function_decl))\n \tpedwarn (\"ANSI C++ forbids assignment between arrays\");\n \n       /* Have to wrap this in RTL_EXPR for two cases:\n@@ -6600,7 +6613,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \t    {\n \t      tree init = build_method_call (exp, constructor_name_full (type),\n \t\t\t\t\t     build_tree_list (NULL_TREE, rhs),\n-\t\t\t\t\t     NULL_TREE, LOOKUP_NORMAL);\n+\t\t\t\t\t     TYPE_BINFO (type), LOOKUP_NORMAL);\n \n \t      if (init == error_mark_node)\n \t\treturn error_mark_node;"}, {"sha": "53106b2e44d8644203b869e950a1c1b089338d5d", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 9, "deletions": 132, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700f8a87923fe4fb60045c6edbb1430636342fa1/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=700f8a87923fe4fb60045c6edbb1430636342fa1", "patch": "@@ -1362,10 +1362,9 @@ build_m_component_ref (datum, component)\n \n /* Return a tree node for the expression TYPENAME '(' PARMS ')'.\n \n-   Because we cannot tell whether this construct is really\n-   a function call or a call to a constructor or a request for\n-   a type conversion, we try all three, and report any ambiguities\n-   we find.  */\n+   Because we cannot tell whether this construct is really a call to a\n+   constructor or a request for a type conversion, we try both, and\n+   report any ambiguities we find.  */\n tree\n build_functional_cast (exp, parms)\n      tree exp;\n@@ -1375,8 +1374,6 @@ build_functional_cast (exp, parms)\n      or a C cast in C++'s `functional' notation.  */\n   tree type, name = NULL_TREE;\n   tree expr_as_ctor = NULL_TREE;\n-  tree expr_as_method = NULL_TREE;\n-  tree expr_as_fncall = NULL_TREE;\n   tree expr_as_conversion = NULL_TREE;\n \n   if (exp == error_mark_node || parms == error_mark_node)\n@@ -1423,50 +1420,16 @@ build_functional_cast (exp, parms)\n \tname = DECL_NAME (name);\n     }\n \n-  /* Try evaluating as a call to a function.  */\n-  if (IDENTIFIER_CLASS_VALUE (name)\n-      && (TREE_CODE (IDENTIFIER_CLASS_VALUE (name)) == TREE_LIST\n-\t  || TREE_CODE (IDENTIFIER_CLASS_VALUE (name)) == FUNCTION_DECL))\n-    {\n-      expr_as_method = build_method_call (current_class_decl, name, parms,\n-\t\t\t\t\t  NULL_TREE, LOOKUP_SPECULATIVELY);\n-      if (expr_as_method == error_mark_node)\n-\texpr_as_method = NULL_TREE;\n-    }\n-\n-  if (IDENTIFIER_GLOBAL_VALUE (name)\n-      && (TREE_CODE (IDENTIFIER_GLOBAL_VALUE (name)) == TREE_LIST\n-\t  || TREE_CODE (IDENTIFIER_GLOBAL_VALUE (name)) == FUNCTION_DECL))\n-    {\n-      expr_as_fncall = build_overload_call (name, parms, 0,\n-\t\t\t\t\t    (struct candidate *)0);\n-      if (expr_as_fncall == NULL_TREE)\n-\texpr_as_fncall = error_mark_node;\n-    }\n-\n   if (! IS_AGGR_TYPE (type))\n     {\n       /* this must build a C cast */\n       if (parms == NULL_TREE)\n-\t{\n-\t  if (expr_as_method || expr_as_fncall)\n-\t    goto return_function;\n-\n-\t  return build1 (NOP_EXPR, type, integer_zero_node);\n-\t}\n-      if (expr_as_method\n-\t  || (expr_as_fncall && expr_as_fncall != error_mark_node))\n-\t{\n-\t  cp_error (\"ambiguity between cast to `%#T' and function call\", type);\n-\t  return error_mark_node;\n-\t}\n+\treturn build1 (NOP_EXPR, type, integer_zero_node);\n       return build_c_cast (type, build_compound_expr (parms));\n     }\n \n   if (TYPE_SIZE (type) == NULL_TREE)\n     {\n-      if (expr_as_method || expr_as_fncall)\n-\tgoto return_function;\n       cp_error (\"type `%T' is not yet defined\", type);\n       return error_mark_node;\n     }\n@@ -1475,7 +1438,7 @@ build_functional_cast (exp, parms)\n     expr_as_conversion\n       = build_type_conversion (CONVERT_EXPR, type, TREE_VALUE (parms), 0);\n     \n-  if (! TYPE_NEEDS_CONSTRUCTING (type) && parms != NULL_TREE)\n+  if (! TYPE_HAS_CONSTRUCTOR (type) && parms != NULL_TREE)\n     {\n       char *msg = 0;\n \n@@ -1488,71 +1451,13 @@ build_functional_cast (exp, parms)\n \t}\n       else msg = \"type `%T' does not have a constructor\";\n \n-      if ((expr_as_method || expr_as_fncall) && expr_as_conversion)\n-\tmsg = \"ambiguity between conversion to `%T' and function call\";\n-      else if (expr_as_method || expr_as_fncall)\n-\tgoto return_function;\n-      else if (expr_as_conversion)\n+      if (expr_as_conversion)\n \treturn expr_as_conversion;\n \n       cp_error (msg, type);\n       return error_mark_node;\n     }\n \n-#if 0\n-  /* Constructors are not inherited...  --jason */\n-  if (! TYPE_HAS_CONSTRUCTOR (type))\n-    {\n-      if (expr_as_method || expr_as_fncall)\n-\tgoto return_function;\n-      if (expr_as_conversion)\n-\treturn expr_as_conversion;\n-\n-      /* Look through this type until we find the\n-\t base type which has a constructor.  */\n-      do\n-\t{\n-\t  tree binfos = TYPE_BINFO_BASETYPES (type);\n-\t  int i, index = 0;\n-\n-\t  while (binfos && TREE_VEC_LENGTH (binfos) == 1\n-\t\t && ! TYPE_HAS_CONSTRUCTOR (type))\n-\t    {\n-\t      type = BINFO_TYPE (TREE_VEC_ELT (binfos, 0));\n-\t      binfos = TYPE_BINFO_BASETYPES (type);\n-\t    }\n-\t  if (TYPE_HAS_CONSTRUCTOR (type))\n-\t    break;\n-\t  /* Hack for MI.  */\n-\t  i = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\t  if (i == 0) break;\t    \n-\t  while (--i > 0)\n-\t    {\n-\t      if (TYPE_HAS_CONSTRUCTOR (BINFO_TYPE (TREE_VEC_ELT (binfos, i))))\n-\t\t{\n-\t\t  if (index == 0)\n-\t\t    index = i;\n-\t\t  else\n-\t\t    {\n-\t\t      error (\"multiple base classes with constructor, ambiguous\");\n-\t\t      type = 0;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  if (type == 0)\n-\t    break;\n-\t} while (! TYPE_HAS_CONSTRUCTOR (type));\n-      if (type == 0)\n-\treturn error_mark_node;\n-    }\n-  name = TYPE_NAME (type);\n-  if (TREE_CODE (name) == TYPE_DECL)\n-    name = DECL_NAME (name);\n-\n-  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 321);\n-#endif\n-\n   {\n     int flags = LOOKUP_SPECULATIVELY|LOOKUP_COMPLAIN;\n \n@@ -1565,20 +1470,7 @@ build_functional_cast (exp, parms)\n \n     if (expr_as_ctor && expr_as_ctor != error_mark_node)\n       {\n-#if 0\n-\t/* mrs Mar 12, 1992 I claim that if it is a constructor, it is\n-\t   impossible to be an expr_as_method, without being a\n-\t   constructor call. */\n-\tif (expr_as_method\n-\t    || (expr_as_fncall && expr_as_fncall != error_mark_node))\n-#else\n-\tif (expr_as_fncall && expr_as_fncall != error_mark_node)\n-#endif\n-\t  {\n-\t    cp_warning (\"function hides constructor for class `%T'\", type);\n-\t    return expr_as_fncall;\n-\t  }\n-\telse if (expr_as_conversion && expr_as_conversion != error_mark_node)\n+\tif (expr_as_conversion && expr_as_conversion != error_mark_node)\n \t  {\n \t    /* ANSI C++ June 5 1992 WP 12.3.2.6.1 */\n \t    cp_error (\"ambiguity between conversion to `%T' and constructor\",\n@@ -1632,23 +1524,8 @@ build_functional_cast (exp, parms)\n       }\n \n     if (expr_as_conversion)\n-      {\n-\tif (expr_as_method || expr_as_fncall)\n-\t  {\n-\t    cp_error (\"ambiguity between conversion to `%T' and function call\",\n-\t\t      type);\n-\t    return error_mark_node;\n-\t  }\n-\treturn expr_as_conversion;\n-      }\n-  return_function:\n-    if (expr_as_method)\n-      return build_method_call (current_class_decl, name, parms,\n-\t\t\t\tNULL_TREE, LOOKUP_NORMAL);\n-    if (expr_as_fncall)\n-      return expr_as_fncall == error_mark_node\n-\t? build_overload_call (name, parms, LOOKUP_COMPLAIN, (struct candidate *)0)\n-\t  : expr_as_fncall;\n+      return expr_as_conversion;\n+\n     cp_error (\"no suitable conversion to `%T' exists\", type);\n     return error_mark_node;\n   }"}]}