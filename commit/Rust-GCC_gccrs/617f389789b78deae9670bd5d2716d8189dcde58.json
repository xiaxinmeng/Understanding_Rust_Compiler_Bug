{"sha": "617f389789b78deae9670bd5d2716d8189dcde58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE3ZjM4OTc4OWI3OGRlYWU5NjcwYmQ1ZDI3MTZkODE4OWRjZGU1OA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-03-28T18:10:14Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-03-28T18:10:14Z"}, "message": "fold-const.c (get_pointer_modulus_and_residue): New parameter allow_func_align.\n\n2009-03-28  Martin Jambor  <mjambor@suse.cz>\n\n\t* fold-const.c (get_pointer_modulus_and_residue): New parameter\n\tallow_func_align.\n\t(fold_binary): Allow function decl aligment consideration is the\n\tsecond argument is integer constant one.\n\t* tree-ssa-forwprop.c (simplify_bitwise_and): New function.\n\t(tree_ssa_forward_propagate_single_use_vars): Handle assing statements\n\twith BIT_AND_EXPR on the RHS by calling simplify_bitwise_and.\n\n\t* g++.dg/tree-ssa/fwprop-align.C: New test.\n\nFrom-SVN: r145203", "tree": {"sha": "ec21a4926e278a7f693b166376b54cfbf7cf0c46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec21a4926e278a7f693b166376b54cfbf7cf0c46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/617f389789b78deae9670bd5d2716d8189dcde58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617f389789b78deae9670bd5d2716d8189dcde58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617f389789b78deae9670bd5d2716d8189dcde58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617f389789b78deae9670bd5d2716d8189dcde58/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fe89fbc56dd937c74ebfe7338fe785699386cb59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe89fbc56dd937c74ebfe7338fe785699386cb59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe89fbc56dd937c74ebfe7338fe785699386cb59"}], "stats": {"total": 104, "additions": 99, "deletions": 5}, "files": [{"sha": "a9775465906bd45fdf284f40cfab1f8e9ba7f7cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617f389789b78deae9670bd5d2716d8189dcde58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617f389789b78deae9670bd5d2716d8189dcde58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=617f389789b78deae9670bd5d2716d8189dcde58", "patch": "@@ -1,3 +1,13 @@\n+2009-03-28  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* fold-const.c (get_pointer_modulus_and_residue): New parameter\n+\tallow_func_align.\n+\t(fold_binary): Allow function decl aligment consideration is the\n+\tsecond argument is integer constant one.\n+\t* tree-ssa-forwprop.c (simplify_bitwise_and): New function.\n+\t(tree_ssa_forward_propagate_single_use_vars): Handle assing statements\n+\twith BIT_AND_EXPR on the RHS by calling simplify_bitwise_and.\n+\n 2009-03-28  Jan Hubicka  <jh@suse.cz>\n \n \t* dwarf2out.c (dwarf2out_begin_prologue): Use crtl->nothrow"}, {"sha": "a68b7b8637d6a73591ee940b95048f92a6126f25", "filename": "gcc/fold-const.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617f389789b78deae9670bd5d2716d8189dcde58/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617f389789b78deae9670bd5d2716d8189dcde58/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=617f389789b78deae9670bd5d2716d8189dcde58", "patch": "@@ -9551,10 +9551,15 @@ fold_mult_zconjz (tree type, tree expr)\n    0 <= N < M as is common.  In general, the precise value of P is unknown.\n    M is chosen as large as possible such that constant N can be determined.\n \n-   Returns M and sets *RESIDUE to N.  */\n+   Returns M and sets *RESIDUE to N.\n+\n+   If ALLOW_FUNC_ALIGN is true, do take functions' DECL_ALIGN_UNIT into\n+   account.  This is not always possible due to PR 35705.\n+ */\n \n static unsigned HOST_WIDE_INT\n-get_pointer_modulus_and_residue (tree expr, unsigned HOST_WIDE_INT *residue)\n+get_pointer_modulus_and_residue (tree expr, unsigned HOST_WIDE_INT *residue,\n+\t\t\t\t bool allow_func_align)\n {\n   enum tree_code code;\n \n@@ -9584,7 +9589,8 @@ get_pointer_modulus_and_residue (tree expr, unsigned HOST_WIDE_INT *residue)\n \t    }\n \t}\n \n-      if (DECL_P (expr) && TREE_CODE (expr) != FUNCTION_DECL)\n+      if (DECL_P (expr)\n+\t  && (allow_func_align || TREE_CODE (expr) != FUNCTION_DECL))\n \treturn DECL_ALIGN_UNIT (expr);\n     }\n   else if (code == POINTER_PLUS_EXPR)\n@@ -9595,7 +9601,8 @@ get_pointer_modulus_and_residue (tree expr, unsigned HOST_WIDE_INT *residue)\n       \n       op0 = TREE_OPERAND (expr, 0);\n       STRIP_NOPS (op0);\n-      modulus = get_pointer_modulus_and_residue (op0, residue);\n+      modulus = get_pointer_modulus_and_residue (op0, residue,\n+\t\t\t\t\t\t allow_func_align);\n \n       op1 = TREE_OPERAND (expr, 1);\n       STRIP_NOPS (op1);\n@@ -11235,7 +11242,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  unsigned HOST_WIDE_INT modulus, residue;\n \t  unsigned HOST_WIDE_INT low = TREE_INT_CST_LOW (arg1);\n \n-\t  modulus = get_pointer_modulus_and_residue (arg0, &residue);\n+\t  modulus = get_pointer_modulus_and_residue (arg0, &residue,\n+\t\t\t\t\t\t     integer_onep (arg1));\n \n \t  /* This works because modulus is a power of 2.  If this weren't the\n \t     case, we'd have to replace it by its greatest power-of-2"}, {"sha": "467691c1e474f30ae2d11866adc97fd4cf8d729e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617f389789b78deae9670bd5d2716d8189dcde58/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617f389789b78deae9670bd5d2716d8189dcde58/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=617f389789b78deae9670bd5d2716d8189dcde58", "patch": "@@ -1,3 +1,7 @@\n+2009-03-28  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* g++.dg/tree-ssa/fwprop-align.C: New test.\n+\n 2009-03-28  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.target/powerpc/altivec-28.c: New test."}, {"sha": "69f26021689a9906aba7627ed14416b1d590b185", "filename": "gcc/testsuite/g++.dg/tree-ssa/fwprop-align.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617f389789b78deae9670bd5d2716d8189dcde58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Ffwprop-align.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617f389789b78deae9670bd5d2716d8189dcde58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Ffwprop-align.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Ffwprop-align.C?ref=617f389789b78deae9670bd5d2716d8189dcde58", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-forwprop2\" } */\n+\n+struct A\n+{\n+  void foo ()\n+  {\n+  }\n+};\n+\n+int main()\n+{\n+  void (A::* const p)() = & A::foo;\n+  A a;\n+  (a.*p)();\n+}\n+\n+/* We should eliminate the check if p points to a virtual function. */\n+/* { dg-final { scan-tree-dump-times \"& 1\" 0 \"forwprop2\" } } */\n+/* { dg-final { cleanup-tree-dump \"forwprop2\" } } */"}, {"sha": "fb29f91bbf192e1484f669f90129f573d869bf3a", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617f389789b78deae9670bd5d2716d8189dcde58/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617f389789b78deae9670bd5d2716d8189dcde58/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=617f389789b78deae9670bd5d2716d8189dcde58", "patch": "@@ -147,6 +147,14 @@ along with GCC; see the file COPYING3.  If not see\n \n      ptr2 = &x[index];\n \n+  Or\n+    ssa = (int) decl\n+    res = ssa & 1\n+\n+  Provided that decl has known alignment >= 2, will get turned into\n+\n+    res = 0\n+\n   We also propagate casts into SWITCH_EXPR and COND_EXPR conditions to\n   allow us to remove the cast and {NOT_EXPR,NEG_EXPR} into a subsequent\n   {NOT_EXPR,NEG_EXPR}.\n@@ -1124,6 +1132,45 @@ simplify_gimple_switch (gimple stmt)\n     }\n }\n \n+/* Run bitwise and assignments throug the folder.  If the first argument is an\n+   ssa name that is itself a result of a typecast of an ADDR_EXPR to an\n+   integer, feed the ADDR_EXPR to the folder rather than the ssa name.\n+*/\n+\n+static void\n+simplify_bitwise_and (gimple_stmt_iterator *gsi, gimple stmt)\n+{\n+  tree res;\n+  tree arg1 = gimple_assign_rhs1 (stmt);\n+  tree arg2 = gimple_assign_rhs2 (stmt);\n+\n+  if (TREE_CODE (arg2) != INTEGER_CST)\n+    return;\n+\n+  if (TREE_CODE (arg1) == SSA_NAME && !SSA_NAME_IS_DEFAULT_DEF (arg1))\n+    {\n+      gimple def = SSA_NAME_DEF_STMT (arg1);\n+\n+      if (gimple_assign_cast_p (def)\n+\t  && INTEGRAL_TYPE_P (gimple_expr_type (def)))\n+\t{\n+\t  tree op = gimple_assign_rhs1 (def);\n+\n+\t  if (TREE_CODE (op) == ADDR_EXPR)\n+\t    arg1 = op;\n+\t}\n+    }\n+\n+  res = fold_binary (BIT_AND_EXPR, TREE_TYPE (gimple_assign_lhs (stmt)),\n+\t\t     arg1, arg2);\n+  if (res && is_gimple_min_invariant (res))\n+    {\n+      gimple_assign_set_rhs_from_tree (gsi, res);\n+      update_stmt (stmt);\n+    }\n+  return;\n+}\n+\n /* Main entry point for the forward propagation optimizer.  */\n \n static unsigned int\n@@ -1206,6 +1253,11 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \t\t  else\n \t\t    gsi_next (&gsi);\n \t\t}\n+\t      else if (gimple_assign_rhs_code (stmt) == BIT_AND_EXPR)\n+\t\t{\n+\t\t  simplify_bitwise_and (&gsi, stmt);\n+\t\t  gsi_next (&gsi);\n+\t\t}\n \t      else\n \t\tgsi_next (&gsi);\n \t    }"}]}