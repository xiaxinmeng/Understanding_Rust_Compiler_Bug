{"sha": "533d08358648911d66784084812d57e086cb9578", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMzZDA4MzU4NjQ4OTExZDY2Nzg0MDg0ODEyZDU3ZTA4NmNiOTU3OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-24T10:30:43Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-24T10:30:43Z"}, "message": "(forbidden_inc_dec_class, in_inc_dec): New variables.\n\n(regclass): Don't alloca the costs twice.\nInitialize forbidden_inc_dec_class.\nFor regs that have inc-dec, ignore forbidden classes.\n(record_address_regs): Update in_inc_dec.\n\nFrom-SVN: r2227", "tree": {"sha": "3b55ad01a5b1bafef09ba73e650477b5cc1f0508", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b55ad01a5b1bafef09ba73e650477b5cc1f0508"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/533d08358648911d66784084812d57e086cb9578", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533d08358648911d66784084812d57e086cb9578", "html_url": "https://github.com/Rust-GCC/gccrs/commit/533d08358648911d66784084812d57e086cb9578", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533d08358648911d66784084812d57e086cb9578/comments", "author": null, "committer": null, "parents": [{"sha": "dc24dc0a611473f5f48f22122d625ac0d52eca6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc24dc0a611473f5f48f22122d625ac0d52eca6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc24dc0a611473f5f48f22122d625ac0d52eca6e"}], "stats": {"total": 95, "additions": 90, "deletions": 5}, "files": [{"sha": "03e0d84a55d9297c8790b346c49b6ceb563bd036", "filename": "gcc/regclass.c", "status": "modified", "additions": 90, "deletions": 5, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533d08358648911d66784084812d57e086cb9578/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533d08358648911d66784084812d57e086cb9578/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=533d08358648911d66784084812d57e086cb9578", "patch": "@@ -40,6 +40,16 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #ifndef MEMORY_MOVE_COST\n #define MEMORY_MOVE_COST(x) 4\n #endif\n+\n+/* If we have auto-increment or auto-decrement and we can have secondary\n+   reloads, we are not allowed to use classes requiring secondary\n+   reloads for psuedos auto-incremented since reload can't handle it.  */\n+\n+#ifdef AUTO_INC_DEC\n+#if defined(SECONARY_INPUT_RELOAD_CLASS) || defined(SECONDARY_OUTPUT_RELOAD_CLASS)\n+#define FORBIDDEN_INC_DEC_CLASSES\n+#endif\n+#endif\n \f\n /* Register tables used by many passes.  */\n \n@@ -160,6 +170,20 @@ static int move_cost[N_REG_CLASSES][N_REG_CLASSES];\n \n static int may_move_cost[N_REG_CLASSES][N_REG_CLASSES];\n \n+#ifdef FORBIDDEN_INC_DEC_CLASSES\n+\n+/* These are the classes that regs which are auto-incremented or decremented\n+   cannot be put in.  */\n+\n+static int forbidden_inc_dec_class[N_REG_CLASSES];\n+\n+/* Indexed by n, is non-zero if (REG n) is used in an auto-inc or auto-dec\n+   context.  */\n+\n+static char *in_inc_dec;\n+\n+#endif FORBIDDEN_INC_DEC_CLASSES\n+\n /* Function called only once to initialize the above data on reg usage.\n    Once this is done, various switches may override.  */\n \n@@ -507,6 +531,48 @@ regclass (f, nregs)\n \n   init_recog ();\n \n+  costs = (struct costs *) alloca (nregs * sizeof (struct costs));\n+\n+#ifdef FORBIDDEN_INC_DEC_CLASSES\n+\n+  in_inc_dec = (char *) alloca (nregs);\n+\n+  /* Initialize information about which register classes can be used for\n+     pseudos that are auto-incremented or auto-decremented.  It would\n+     seem better to put this in init_reg_sets, but we need to be able\n+     to allocate rtx, which we can't do that early.  */\n+\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    {\n+      rtx r = gen_rtx (REG, VOIDmode, 0);\n+      enum machine_mode m;\n+\n+      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+\tif (TEST_HARD_REG_BIT (reg_class_contents[i], j))\n+\t  {\n+\t    REGNO (r) = j;\n+\n+\t    for (m = VOIDmode; (int) m < (int) MAX_MACHINE_MODE;\n+\t\t m = (enum machine_mode) ((int) m) + 1)\n+\t      if (HARD_REGNO_MODE_OK (j, m))\n+\t\t{\n+\t\t  PUT_MODE (r, m);\n+\t\t  if (0\n+#ifdef SECONDARY_INPUT_RELOAD_CLASS\n+\t\t      || (SECONDARY_INPUT_RELOAD_CLASS (BASE_REG_CLASS, m, r)\n+\t\t\t  != NO_REGS)\n+#endif\n+#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n+\t\t      || (SECONDARY_OUTPUT_RELOAD_CLASS (BASE_REG_CLASS, m, r)\n+\t\t\t  != NO_REGS)\n+#endif\n+\t\t      )\n+\t\t    forbidden_inc_dec_class[i] = 1;\n+\t\t}\n+\t  }\n+    }\n+#endif /* FORBIDDEN_INC_DEC_CLASSES */\n+\n   init_cost.mem_cost = 10000;\n   for (i = 0; i < N_REG_CLASSES; i++)\n     init_cost.cost[i] = 10000;\n@@ -520,9 +586,12 @@ regclass (f, nregs)\n     {\n       /* Zero out our accumulation of the cost of each class for each reg.  */\n \n-      costs = (struct costs *) alloca (nregs * sizeof (struct costs));\n       bzero (costs, nregs * sizeof (struct costs));\n \n+#ifdef FORBIDDEN_INC_DEC_CLASSES\n+      bzero (in_inc_dec, nregs);\n+#endif\n+\n       loop_depth = 0, loop_cost = 1;\n \n       /* Scan the instructions and record each time it would\n@@ -796,9 +865,14 @@ regclass (f, nregs)\n \n \t  for (class = (int) ALL_REGS - 1; class > 0; class--)\n \t    {\n-\t      /* Ignore classes that are too small for this operand.  */\n+\t      /* Ignore classes that are too small for this operand or\n+\t\t invalid for a operand that was auto-incremented.  */\n \t      if (CLASS_MAX_NREGS (class, PSEUDO_REGNO_MODE (i))\n-\t\t  > reg_class_size[class])\n+\t\t  > reg_class_size[class]\n+#ifdef FORBIDDEN_INC_DEC_CLASSES\n+\t\t  || (in_inc_dec[i] && forbidden_inc_dec_class[class])\n+#endif\n+\t\t  )\n \t\t;\n \t      else if (p->cost[class] < best_cost)\n \t\t{\n@@ -820,7 +894,11 @@ regclass (f, nregs)\n \t    for (class = 0; class < N_REG_CLASSES; class++)\n \t      if (p->cost[class] < p->mem_cost\n \t\t  && (reg_class_size[reg_class_subunion[(int) alt][class]]\n-\t\t      > reg_class_size[(int) alt]))\n+\t\t      > reg_class_size[(int) alt])\n+#ifdef FORBIDDEN_INC_DEC_CLASSES\n+\t\t  && ! (in_inc_dec[i] && forbidden_inc_dec_class[class])\n+#endif\n+\t\t  )\n \t\talt = reg_class_subunion[(int) alt][class];\n \t  \n \t  /* If we don't add any classes, nothing to try.  */\n@@ -1391,7 +1469,14 @@ record_address_regs (x, class, scale)\n     case PRE_DEC:\n       /* Double the importance of a pseudo register that is incremented\n \t or decremented, since it would take two extra insns\n-\t if it ends up in the wrong place.  */\n+\t if it ends up in the wrong place.  If the operand is a pseudo,\n+\t show it is being used in an INC_DEC context.  */\n+\n+#ifdef FORBIDDEN_INC_DEC_CLASSES\n+      if (GET_CODE (XEXP (x, 0)) == REG\n+\t  && REGNO (XEXP (x, 0)) >= FIRST_PSEUDO_REGISTER)\n+\tin_inc_dec[REGNO (XEXP (x, 0))] = 1;\n+#endif\n \n       record_address_regs (XEXP (x, 0), class, 2 * scale);\n       break;"}]}