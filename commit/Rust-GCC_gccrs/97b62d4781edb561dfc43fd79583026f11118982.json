{"sha": "97b62d4781edb561dfc43fd79583026f11118982", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdiNjJkNDc4MWVkYjU2MWRmYzQzZmQ3OTU4MzAyNmYxMTExODk4Mg==", "commit": {"author": {"name": "Matthias Klose", "email": "doko@gcc.gnu.org", "date": "2004-07-06T21:40:08Z"}, "committer": {"name": "Matthias Klose", "email": "doko@gcc.gnu.org", "date": "2004-07-06T21:40:08Z"}, "message": "[multiple changes]\n\n2004-07-06  Matthias Klose  <doko@debian.org>\n\n\t* Makefile.in: Regenerate.\n\t* fastjar.texi: Update for '-u'.\n\n2004-05-19  Casey Marshall <csm@gnu.org>\n\n\tPR 7854\n\t* Makefile.am\n\t(jar_SOURCES): added shift.c, shift.h.\n        (jar_CPPFLAGS): define WITH_SHIFT_DOWN.\n\n        * compress.c\n        Added FSF copyright.\n        (write_data): new function.\n        (compress_file): call write_data.\n\n        * jartool.c\n        Updated copyright year.\n        (progname): new variable.\n        (end_of_entries): new variable.\n        (main): open and read file when updating.\n        (find_entry): new function.\n        (looks_like_dir): new function.\n        (read_entries): new function.\n        (make_manifest): added parameter `updating'.\n        Call `add_file_to_jar' with `updating'.\n        (add_to_jar_with_dir): added parameter `updating'.\n        Call `add_to_jar' with `updating'.\n        (add_to_jar): added parameter `updating'.\n        Call `add_file_to_jar' with `updating'.\n        Don't add directories if they already exist.\n        (add_file_to_jar): added parameter `updating'.\n        Update entries if they already exist.\n\n        * jartool.h\n        Added #ifndef __FASTJAR_JARTOOL_H__.\n        (struct zipentry): added `flags'.\n\n        * shift.c: new file.\n\n        * shift.h: new file.\n\n        * zipfile.h\n        (CEN_FLAGS): new constant.\n\nFrom-SVN: r84171", "tree": {"sha": "cede115c5e69e77d0b68edda7dfceb560ccb5b15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cede115c5e69e77d0b68edda7dfceb560ccb5b15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97b62d4781edb561dfc43fd79583026f11118982", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97b62d4781edb561dfc43fd79583026f11118982", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97b62d4781edb561dfc43fd79583026f11118982", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97b62d4781edb561dfc43fd79583026f11118982/comments", "author": null, "committer": null, "parents": [{"sha": "ca4f3d13192837e3c285b1b3179a09e6fbb49500", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4f3d13192837e3c285b1b3179a09e6fbb49500", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca4f3d13192837e3c285b1b3179a09e6fbb49500"}], "stats": {"total": 825, "additions": 731, "deletions": 94}, "files": [{"sha": "ff7196914f56597b7b46b91a702ebd9dc2fa5ed3", "filename": "fastjar/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2FChangeLog?ref=97b62d4781edb561dfc43fd79583026f11118982", "patch": "@@ -1,3 +1,49 @@\n+2004-07-06  Matthias Klose  <doko@debian.org>\n+\n+\t* Makefile.in: Regenerate.\n+\t* fastjar.texi: Update for '-u'.\n+\t\n+2004-05-19  Casey Marshall <csm@gnu.org>\n+\n+\tPR 7854\n+\t* Makefile.am\n+\t(jar_SOURCES): added shift.c, shift.h.\n+        (jar_CPPFLAGS): define WITH_SHIFT_DOWN.\n+\n+        * compress.c\n+        Added FSF copyright.\n+        (write_data): new function.\n+        (compress_file): call write_data.\n+\n+        * jartool.c\n+        Updated copyright year.\n+        (progname): new variable.\n+        (end_of_entries): new variable.\n+        (main): open and read file when updating.\n+        (find_entry): new function.\n+        (looks_like_dir): new function.\n+        (read_entries): new function.\n+        (make_manifest): added parameter `updating'.\n+        Call `add_file_to_jar' with `updating'.\n+        (add_to_jar_with_dir): added parameter `updating'.\n+        Call `add_to_jar' with `updating'.\n+        (add_to_jar): added parameter `updating'.\n+        Call `add_file_to_jar' with `updating'.\n+        Don't add directories if they already exist.\n+        (add_file_to_jar): added parameter `updating'.\n+        Update entries if they already exist.\n+\n+        * jartool.h\n+        Added #ifndef __FASTJAR_JARTOOL_H__.\n+        (struct zipentry): added `flags'.\n+\n+        * shift.c: new file.\n+\n+        * shift.h: new file.\n+\n+        * zipfile.h\n+        (CEN_FLAGS): new constant.\n+\n 2004-07-05  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* Makefile.am: Silence two automake warnings."}, {"sha": "3358e47ef60503420e88fe802dc04c0feb0af330", "filename": "fastjar/Makefile.am", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2FMakefile.am?ref=97b62d4781edb561dfc43fd79583026f11118982", "patch": "@@ -46,10 +46,11 @@ AM_CPPFLAGS = -I. -I$(top_srcdir) $(ZINCS) -I$(top_srcdir)/../include\n LIBIBERTY = ../libiberty/libiberty.a\n \n bin_PROGRAMS = jar grepjar\n-jar_SOURCES = jartool.c dostime.c compress.c pushback.c jartool.h \\\n-zipfile.h dostime.h compress.h pushback.h\n+jar_SOURCES = jartool.c dostime.c compress.c pushback.c shift.c jartool.h \\\n+zipfile.h dostime.h compress.h pushback.h shift.h\n jar_LDADD = $(ZLIBS) $(LIBIBERTY)\n jar_DEPENDENCIES = $(ZDEPS) $(LIBIBERTY)\n+jar_CPPFLAGS = -DWITH_SHIFT_DOWN\n \n grepjar_SOURCES = jargrep.c dostime.c compress.c pushback.c jartool.h \\\n zipfile.h dostime.h compress.h pushback.h"}, {"sha": "b0fc08389bebf3d604ebd59b79e51b64c297f6c4", "filename": "fastjar/Makefile.in", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2FMakefile.in?ref=97b62d4781edb561dfc43fd79583026f11118982", "patch": "@@ -41,11 +41,11 @@ POST_UNINSTALL = :\n bin_PROGRAMS = jar$(EXEEXT) grepjar$(EXEEXT)\n subdir = .\n DIST_COMMON = README $(am__configure_deps) $(fastjar_TEXINFOS) \\\n-\t$(srcdir)/../install-sh $(srcdir)/../missing \\\n-\t$(srcdir)/../mkinstalldirs $(srcdir)/Makefile.am \\\n-\t$(srcdir)/Makefile.in $(srcdir)/config.h.in \\\n-\t$(srcdir)/install-defs.sh.in $(top_srcdir)/configure AUTHORS \\\n-\tCOPYING ChangeLog INSTALL NEWS\n+\t$(srcdir)/../compile $(srcdir)/../install-sh \\\n+\t$(srcdir)/../missing $(srcdir)/../mkinstalldirs \\\n+\t$(srcdir)/Makefile.am $(srcdir)/Makefile.in \\\n+\t$(srcdir)/config.h.in $(srcdir)/install-defs.sh.in \\\n+\t$(top_srcdir)/configure AUTHORS COPYING ChangeLog INSTALL NEWS\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \\\n \t$(top_srcdir)/../config/accross.m4 $(top_srcdir)/configure.ac\n@@ -64,8 +64,9 @@ am_grepjar_OBJECTS = jargrep.$(OBJEXT) dostime.$(OBJEXT) \\\n grepjar_OBJECTS = $(am_grepjar_OBJECTS)\n am__DEPENDENCIES_1 =\n am__DEPENDENCIES_2 = ../libiberty/libiberty.a\n-am_jar_OBJECTS = jartool.$(OBJEXT) dostime.$(OBJEXT) \\\n-\tcompress.$(OBJEXT) pushback.$(OBJEXT)\n+am_jar_OBJECTS = jar-jartool.$(OBJEXT) jar-dostime.$(OBJEXT) \\\n+\tjar-compress.$(OBJEXT) jar-pushback.$(OBJEXT) \\\n+\tjar-shift.$(OBJEXT)\n jar_OBJECTS = $(am_jar_OBJECTS)\n DEFAULT_INCLUDES = -I. -I$(srcdir) -I.\n depcomp =\n@@ -129,7 +130,6 @@ EGREP = @EGREP@\n EXEEXT = @EXEEXT@\n GENINSRC_FALSE = @GENINSRC_FALSE@\n GENINSRC_TRUE = @GENINSRC_TRUE@\n-GREP = @GREP@\n INSTALL_DATA = @INSTALL_DATA@\n INSTALL_PROGRAM = @INSTALL_PROGRAM@\n INSTALL_SCRIPT = @INSTALL_SCRIPT@\n@@ -229,11 +229,12 @@ AM_MAKEFLAGS = \\\n \n AM_CPPFLAGS = -I. -I$(top_srcdir) $(ZINCS) -I$(top_srcdir)/../include\n LIBIBERTY = ../libiberty/libiberty.a\n-jar_SOURCES = jartool.c dostime.c compress.c pushback.c jartool.h \\\n-zipfile.h dostime.h compress.h pushback.h\n+jar_SOURCES = jartool.c dostime.c compress.c pushback.c shift.c jartool.h \\\n+zipfile.h dostime.h compress.h pushback.h shift.h\n \n jar_LDADD = $(ZLIBS) $(LIBIBERTY)\n jar_DEPENDENCIES = $(ZDEPS) $(LIBIBERTY)\n+jar_CPPFLAGS = -DWITH_SHIFT_DOWN\n grepjar_SOURCES = jargrep.c dostime.c compress.c pushback.c jartool.h \\\n zipfile.h dostime.h compress.h pushback.h\n \n@@ -362,6 +363,36 @@ distclean-compile:\n .c.obj:\n \t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n \n+jar-jartool.o: jartool.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(jar_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o jar-jartool.o `test -f 'jartool.c' || echo '$(srcdir)/'`jartool.c\n+\n+jar-jartool.obj: jartool.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(jar_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o jar-jartool.obj `if test -f 'jartool.c'; then $(CYGPATH_W) 'jartool.c'; else $(CYGPATH_W) '$(srcdir)/jartool.c'; fi`\n+\n+jar-dostime.o: dostime.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(jar_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o jar-dostime.o `test -f 'dostime.c' || echo '$(srcdir)/'`dostime.c\n+\n+jar-dostime.obj: dostime.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(jar_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o jar-dostime.obj `if test -f 'dostime.c'; then $(CYGPATH_W) 'dostime.c'; else $(CYGPATH_W) '$(srcdir)/dostime.c'; fi`\n+\n+jar-compress.o: compress.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(jar_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o jar-compress.o `test -f 'compress.c' || echo '$(srcdir)/'`compress.c\n+\n+jar-compress.obj: compress.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(jar_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o jar-compress.obj `if test -f 'compress.c'; then $(CYGPATH_W) 'compress.c'; else $(CYGPATH_W) '$(srcdir)/compress.c'; fi`\n+\n+jar-pushback.o: pushback.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(jar_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o jar-pushback.o `test -f 'pushback.c' || echo '$(srcdir)/'`pushback.c\n+\n+jar-pushback.obj: pushback.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(jar_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o jar-pushback.obj `if test -f 'pushback.c'; then $(CYGPATH_W) 'pushback.c'; else $(CYGPATH_W) '$(srcdir)/pushback.c'; fi`\n+\n+jar-shift.o: shift.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(jar_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o jar-shift.o `test -f 'shift.c' || echo '$(srcdir)/'`shift.c\n+\n+jar-shift.obj: shift.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(jar_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o jar-shift.obj `if test -f 'shift.c'; then $(CYGPATH_W) 'shift.c'; else $(CYGPATH_W) '$(srcdir)/shift.c'; fi`\n+\n .texi.info:\n \trestore=: && \\\n \tbackupdir=\"$(am__leading_dot)am$$$$\" && \\"}, {"sha": "ec1d5c4b7ab1b898915255b02560a26d67426300", "filename": "fastjar/compress.c", "status": "modified", "additions": 55, "deletions": 17, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fcompress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fcompress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fcompress.c?ref=97b62d4781edb561dfc43fd79583026f11118982", "patch": "@@ -74,6 +74,7 @@\n /*\n   compress.c - code for handling deflation\n   Copyright (C) 1999  Bryan Burns\n+  Copyright (C) 2004  Free Software Foundation, Inc.\n   \n   This program is free software; you can redistribute it and/or\n   modify it under the terms of the GNU General Public License\n@@ -109,8 +110,12 @@\n #include \"jartool.h\"\n #include \"pushback.h\"\n #include \"compress.h\"\n+#include \"shift.h\"\n+\n+int write_data (int, void *, size_t, struct zipentry *);\n \n extern int seekable;\n+extern off_t end_of_entries;\n \n static z_stream zs;\n \n@@ -133,7 +138,36 @@ void init_compression(){\n   }\n }\n \n-int compress_file(int in_fd, int out_fd, struct zipentry *ze){\n+int\n+write_data (int fd, void *buf, size_t len, struct zipentry *ze)\n+{\n+#ifdef WITH_SHIFT_DOWN\n+  struct zipentry *next = NULL;\n+  off_t here = lseek (fd, 0, SEEK_CUR);\n+  /*\n+   * If we are updating and there is not enough space before the next\n+   * entry, expand the file.\n+   */\n+  if (ze)\n+    {\n+      next = ze->next_entry;\n+      if (next && here + len >= next->offset)\n+\t{\n+\t  if (shift_down (fd, next->offset, (here + len) - next->offset, next))\n+\t    {\n+\t      perror (\"can't expand file\");\n+\t      exit (1);\n+\t    }\n+\t}\n+    }\n+#endif /* WITH_SHIFT_DOWN */\n+\n+  return write (fd, buf, len);\n+}\n+\n+int compress_file(int in_fd, int out_fd, struct zipentry *ze,\n+\t\t  struct zipentry *existing)\n+{\n   Bytef in_buff[RDSZ];\n   Bytef out_buff[RDSZ];\n   unsigned int rdamt, wramt;\n@@ -183,10 +217,11 @@ int compress_file(int in_fd, int out_fd, struct zipentry *ze){\n     /* If the output buffer is full, dump it to disk */\n     if(zs.avail_out == 0){\n \n-      if(write(out_fd, out_buff, RDSZ) != RDSZ){\n-        perror(\"write\");\n-        exit(1);\n-      }\n+      if (write_data (out_fd, out_buff, RDSZ, existing) != RDSZ)\n+\t{\n+\t  perror(\"write\");\n+\t  exit(1);\n+\t}\n \n       /* clear the output buffer */\n       zs.next_out = out_buff;\n@@ -201,10 +236,11 @@ int compress_file(int in_fd, int out_fd, struct zipentry *ze){\n \n     wramt = RDSZ - zs.avail_out;\n \n-    if(write(out_fd, out_buff, wramt) != (int)wramt){\n-      perror(\"write\");\n-      exit(1);\n-    }\n+    if (write_data (out_fd, out_buff, wramt, existing) != (int)wramt)\n+      {\n+\tperror(\"write\");\n+\texit(1);\n+      }\n     /* clear the output buffer */\n     zs.next_out = out_buff;\n     zs.avail_out = (uInt)RDSZ;\n@@ -215,10 +251,11 @@ int compress_file(int in_fd, int out_fd, struct zipentry *ze){\n   while(deflate(&zs, Z_FINISH) == Z_OK){\n     wramt = RDSZ - zs.avail_out;\n \n-    if(write(out_fd, out_buff, wramt) != (int)wramt){\n-      perror(\"write\");\n-      exit(1);\n-    }\n+    if (write_data (out_fd, out_buff, wramt, existing) != (int)wramt)\n+      {\n+\tperror(\"write\");\n+\texit(1);\n+      }\n \n     zs.next_out = out_buff;\n     zs.avail_out = (uInt)RDSZ;\n@@ -228,10 +265,11 @@ int compress_file(int in_fd, int out_fd, struct zipentry *ze){\n   if(zs.avail_out != RDSZ){\n     wramt = RDSZ - zs.avail_out;\n \n-    if(write(out_fd, out_buff, wramt) != (int)wramt){\n-      perror(\"write\");\n-      exit(1);\n-    }\n+    if (write_data (out_fd, out_buff, wramt, existing) != (int)wramt)\n+      {\n+\tperror(\"write\");\n+\texit(1);\n+      }\n   }\n \n   /* update fastjar's entry information */"}, {"sha": "9e98034817b29c9cc4a4a629e900db12ccea217c", "filename": "fastjar/compress.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fcompress.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fcompress.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fcompress.h?ref=97b62d4781edb561dfc43fd79583026f11118982", "patch": "@@ -46,7 +46,7 @@\n void init_compression(void);\n \n /* Compresses the file specified by in_fd and appends it to out_fd */\n-int compress_file(int in_fd, int out_fd, struct zipentry *ze);\n+int compress_file(int, int, struct zipentry *, struct zipentry *);\n \n /* Frees memory used by compression function */\n void end_compression(void);"}, {"sha": "e07b37a8ce43f1c26af16a135cbc8b62df8d4a7c", "filename": "fastjar/fastjar.texi", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Ffastjar.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Ffastjar.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Ffastjar.texi?ref=97b62d4781edb561dfc43fd79583026f11118982", "patch": "@@ -125,8 +125,7 @@ List table of contents for archive.\n Extract named (or all) files from archive.\n \n @item -u\n-Update existing archive. This option is disabled due to bugs (currently\n-fails with exit status 1 and does nothing).\n+Update existing archive.\n \n @end table\n "}, {"sha": "b4b66744e0ca99cda45293b48b85f0924429abf9", "filename": "fastjar/jartool.c", "status": "modified", "additions": 381, "deletions": 62, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fjartool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fjartool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fjartool.c?ref=97b62d4781edb561dfc43fd79583026f11118982", "patch": "@@ -1,6 +1,6 @@\n /*\n   jartool.c - main functions for fastjar utility\n-  Copyright (C) 2002 Free Software Foundation\n+  Copyright (C) 2002, 2004  Free Software Foundation\n   Copyright (C) 1999, 2000, 2001  Bryan Burns\n   \n   This program is free software; you can redistribute it and/or\n@@ -238,6 +238,7 @@\n #include \"dostime.h\"\n #include \"pushback.h\"\n #include \"compress.h\"\n+#include \"shift.h\"\n \n /* Some systems have mkdir that takes a single argument.  */\n #ifdef MKDIR_TAKES_ONE_ARG\n@@ -273,15 +274,18 @@ void init_headers(void);\n int consume(pb_file *, int);\n int list_jar(int, char**, int);\n int extract_jar(int, char**, int);\n-int add_file_to_jar(int, int, const char*, struct stat*);\n-int add_to_jar(int, const char*);\n-int add_to_jar_with_dir(int, const char*, const char*);\n+int add_file_to_jar(int, int, const char*, struct stat*, int);\n+int add_to_jar(int, const char*, int);\n+int add_to_jar_with_dir(int, const char*, const char*, int);\n int create_central_header(int);\n-int make_manifest(int, const char*);\n+int make_manifest(int, const char*, int);\n+int read_entries (int);\n static void init_args(char **, int);\n static char *get_next_arg (void);\n static char *jt_strdup (char*);\n static void expand_options (int *argcp, char ***argvp);\n+static inline struct zipentry *find_entry (const char *);\n+static inline int looks_like_dir (const char *);\n \n /* global variables */\n ub1 file_header[30];\n@@ -305,6 +309,12 @@ zipentry *ziptail; /* tail of the linked list */\n \n int number_of_entries; /* number of entries in the linked list */\n \n+/* What we go by. */\n+const char *progname;\n+\n+/* The offset of the end of the last zip entry. */\n+ub4 end_of_entries;\n+\n /* This is used to mark options with no short value.  */\n #define LONG_OPT(Num)  ((Num) + 128)\n \n@@ -340,6 +350,8 @@ int main(int argc, char **argv){\n   int new_argc;\n   char **new_argv;\n \n+  progname = argv[0];\n+\n   do_compress = TRUE;\n   verbose = FALSE;\n   \n@@ -418,15 +430,11 @@ int main(int argc, char **argv){\n   new_argv[new_argc] = NULL;\n \n   if(action == ACTION_NONE){\n-    fprintf(stderr, \"One of options -{ctxu} must be specified.\\n\");\n+    fprintf(stderr, \"%s: one of options -{ctxu} must be specified.\\n\",\n+\t    progname);\n     usage(argv[0]);\n   }\n \n-  if(action == ACTION_UPDATE){\n-    fprintf(stderr, \"%s: `-u' mode unimplemented.\\n\", argv[0]);\n-    exit(1);\n-  }\n-\n   /* Verify unsupported combinations and warn of the use of non\n      standard features */\n   if(verbose && use_explicit_list_only)\n@@ -435,7 +443,8 @@ int main(int argc, char **argv){\n     fprintf (stderr, \"Warning: using non standard '-@' option\\n\");\n   if(read_names_from_stdin\n       && (action != ACTION_CREATE && action != ACTION_UPDATE)){\n-      fprintf(stderr, \"Option '-@' is supported only with '-c' or '-u'.\\n\");\n+      fprintf(stderr, \"%s: option '-@' is supported only with '-c' or '-u'.\\n\",\n+\t      progname);\n       usage(argv[0]);\n   }\n \n@@ -445,8 +454,8 @@ int main(int argc, char **argv){\n       jarfd = open(jarfile, O_CREAT | O_BINARY | O_WRONLY | O_TRUNC, 0666);\n \n       if(jarfd < 0){\n-        fprintf(stderr, \"Error opening %s for writing!\\n\", jarfile);\n-        perror(jarfile);\n+        fprintf(stderr, \"%s: error opening %s for writing: %s\\n\", progname,\n+\t\tjarfile, strerror (errno));\n         exit(1);\n       }\n       \n@@ -470,8 +479,8 @@ int main(int argc, char **argv){\n       jarfd = open(jarfile, O_RDONLY | O_BINARY);\n \n       if(jarfd < 0){\n-        fprintf(stderr, \"Error opening %s for reading!\\n\", jarfile);\n-        perror(jarfile);\n+        fprintf(stderr, \"%s: error opening %s for reading: %s\\n\", progname,\n+\t\tjarfile, strerror (errno));\n         exit(1);\n       }\n \n@@ -484,28 +493,51 @@ int main(int argc, char **argv){\n     }\n   }\n \n+  if (action == ACTION_UPDATE)\n+    {\n+      if (!jarfile)\n+\t{\n+\t  fprintf (stderr, \"%s: `-u' mode requires a file name\\n\",\n+\t\t   argv[0]);\n+\t  exit (1);\n+\t}\n+\n+      if ((jarfd = open (jarfile, O_RDWR | O_BINARY)) < 0)\n+\t{\n+\t  fprintf (stderr, \"Error opening %s for reading!\\n\", jarfile);\n+\t  perror (jarfile);\n+\t  exit (1);\n+\t}\n+\n+      /* Assert that jarfd is seekable. */\n+      if (lseek (jarfd, 0, SEEK_CUR) == -1)\n+\t{\n+\t  fprintf (stderr, \"%s: %s is not seekable\\n\", argv[0], jarfile);\n+\t  exit (1);\n+\t}\n+\n+      seekable = TRUE;\n+    }\n+\n   if(action == ACTION_CREATE || action == ACTION_UPDATE){\n     const char *arg;\n     init_headers();\n \n-   if((action == ACTION_UPDATE) && jarfile) {\n-      if((jarfd = open(jarfile, O_RDWR | O_BINARY)) < 0) {\n-\tfprintf(stderr, \"Error opening %s for reading!\\n\", jarfile);\n-        perror(jarfile);\n-        exit(1);\n-      }\n-    }\n-\n     if(do_compress)\n       init_compression();\n-  \n+\n+    if (action == ACTION_UPDATE)\n+      {\n+\tif (read_entries (jarfd))\n+\t  exit (1);\n+      }\n \n     /* Add the META-INF/ directory and the manifest */\n     if(manifest && mfile)\n-      make_manifest(jarfd, mfile);\n-    else if(manifest)\n-      make_manifest(jarfd, NULL);\n-    \n+      make_manifest(jarfd, mfile, action == ACTION_UPDATE);\n+    else if(manifest && action == ACTION_CREATE)\n+      make_manifest(jarfd, NULL, FALSE);\n+\n     init_args (new_argv, 0);\n     /* now we add the files to the archive */\n     while ((arg = get_next_arg ())){\n@@ -514,17 +546,19 @@ int main(int argc, char **argv){\n \tconst char *dir_to_change = get_next_arg ();\n \tconst char *file_to_add = get_next_arg ();\n         if (!dir_to_change || !file_to_add) {\n-          fprintf(stderr, \"Error: missing argument for -C.\\n\");\n-          exit(1);\n-        }\n-\tif (add_to_jar_with_dir(jarfd, dir_to_change, file_to_add)) {\n-          fprintf(stderr,\n-                 \"Error adding %s (in directory %s) to jar archive!\\n\",\n-                 file_to_add, dir_to_change);\n+          fprintf(stderr, \"%s: error: missing argument for -C.\\n\", progname);\n           exit(1);\n         }\n+\tif (add_to_jar_with_dir(jarfd, dir_to_change, file_to_add,\n+\t\t\t\taction == ACTION_UPDATE))\n+\t  {\n+\t    fprintf(stderr,\n+\t\t    \"Error adding %s (in directory %s) to jar archive!\\n\",\n+\t\t    file_to_add, dir_to_change);\n+\t    exit(1);\n+\t  }\n       } else {\n-        if(add_to_jar(jarfd, arg)){\n+        if(add_to_jar(jarfd, arg, action == ACTION_UPDATE)){\n           fprintf(stderr, \"Error adding %s to jar archive!\\n\", arg);\n           exit(1);\n         }\n@@ -533,11 +567,20 @@ int main(int argc, char **argv){\n     /* de-initialize the compression DS */\n     if(do_compress)\n       end_compression();\n+\n+    if (action == ACTION_UPDATE)\n+      lseek (jarfd, end_of_entries, SEEK_SET);\n     \n     create_central_header(jarfd);\n-    \n-    if (close(jarfd) != 0) {\n-      fprintf(stderr, \"Error closing jar archive!\\n\");\n+\n+    /* Check if the file shrunk when we updated it. */\n+    if (action == ACTION_UPDATE)\n+      ftruncate (jarfd, lseek (jarfd, 0, SEEK_CUR));\n+\n+    if (jarfd != STDIN_FILENO && close(jarfd) != 0) {\n+      fprintf(stderr, \"%s: error closing jar archive: %s\\n\",\n+\t      progname, strerror (errno));\n+      exit (1);\n     }\n   } else if(action == ACTION_LIST){\n     list_jar(jarfd, &new_argv[0], new_argc);\n@@ -688,7 +731,175 @@ void add_entry(struct zipentry *ze){\n   number_of_entries++;\n }\n \n-int make_manifest(int jfd, const char *mf_name){\n+static inline struct zipentry *\n+find_entry (const char *fname)\n+{\n+  struct zipentry *ze;\n+\n+  for (ze = ziptail; ze; ze = ze->next_entry)\n+    {\n+      if (!strcmp (ze->filename, fname))\n+\treturn ze;\n+    }\n+  return NULL;\n+}\n+\n+\n+static inline int\n+looks_like_dir (const char *fname)\n+{\n+  struct zipentry *ze;\n+  size_t len = strlen (fname);\n+\n+  for (ze = ziptail; ze; ze = ze->next_entry)\n+    {\n+      if (strlen (ze->filename) > len\n+\t  && !strncmp (fname, ze->filename, len)\n+\t  && ze->filename[len] == '/')\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+\n+/*\n+ * Read the zip entries of an existing file, building `ziplist' as we go.\n+ */\n+int read_entries (int fd)\n+{\n+  struct zipentry *ze;\n+  ub1 intbuf[4];\n+  ub1 header[46];\n+  ub2 len;\n+  ub2 count, i;\n+  off_t offset;\n+\n+  if (lseek (fd, -22, SEEK_END) == -1)\n+    {\n+      fprintf (stderr, \"%s: %s: can't seek file\\n\", progname, jarfile);\n+      return 1;\n+    }\n+\n+  if (read (fd, intbuf, 4) < 4)\n+    {\n+      perror (progname);\n+      return 1;\n+    }\n+  /* Is there a zipfile comment? */\n+  while (UNPACK_UB4(intbuf, 0) != 0x06054b50)\n+    {\n+      if (lseek (fd, -5, SEEK_CUR) == -1 ||\n+\t  read (fd, intbuf, 4) != 4)\n+\t{\n+\t  fprintf (stderr, \"%s: can't find end of central directory: %s\\n\",\n+\t\t   progname, strerror (errno));\n+\t  return 1;\n+\t}\n+    }\n+\n+  /* Skip disk numbers. */\n+  if (lseek (fd, 6, SEEK_CUR) == -1)\n+    {\n+      perror (progname);\n+      return 1;\n+    }\n+\n+  /* Number of entries in the central directory. */\n+  if (read (fd, intbuf, 2) != 2)\n+    {\n+      perror (progname);\n+      return 1;\n+    }\n+  count = UNPACK_UB2(intbuf, 0);\n+\n+  if (lseek (fd, 4, SEEK_CUR) == -1)\n+    {\n+      perror (progname);\n+      return 1;\n+    }\n+\n+  /* Offset where the central directory begins. */\n+  if (read (fd, intbuf, 4) != 4)\n+    {\n+      perror (progname);\n+      return 1;\n+    }\n+  offset = UNPACK_UB4(intbuf, 0);\n+  end_of_entries = offset;\n+\n+  if (lseek (fd, offset, SEEK_SET) != offset)\n+    {\n+      perror (progname);\n+      return 1;\n+    }\n+\n+  if (read (fd, header, 46) != 46)\n+    {\n+      fprintf (stderr, \"%s: %s: unexpected end of file\\n\",\n+\t       progname, jarfile);\n+      return 1;\n+    }\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      if (UNPACK_UB4(header, 0) != 0x02014b50)\n+\t{\n+\t  fprintf (stderr, \"%s: can't find central directory header\\n\",\n+\t\t   progname);\n+\t  return 1;\n+\t}\n+      ze = (struct zipentry *) malloc (sizeof (struct zipentry));\n+      if (!ze)\n+\t{\n+\t  perror (progname);\n+\t  return 1;\n+\t}\n+      memset (ze, 0, sizeof (struct zipentry));\n+      ze->flags = UNPACK_UB2(header, CEN_FLAGS);\n+      ze->mod_time = UNPACK_UB2(header, CEN_MODTIME);\n+      ze->mod_date = UNPACK_UB2(header, CEN_MODDATE);\n+      ze->crc = UNPACK_UB4(header, CEN_CRC);\n+      ze->usize = UNPACK_UB4(header, CEN_USIZE);\n+      ze->csize = UNPACK_UB4(header, CEN_CSIZE);\n+      ze->offset = UNPACK_UB4(header, CEN_OFFSET);\n+      ze->compressed = (header[CEN_COMP] || header[CEN_COMP+1]);\n+      len = UNPACK_UB2(header, CEN_FNLEN);\n+      ze->filename = (char *) malloc ((len+1) * sizeof (char));\n+      if (!ze->filename)\n+\t{\n+\t  perror (progname);\n+\t  return 1;\n+\t}\n+      if (read (fd, ze->filename, len) != len)\n+\t{\n+\t  fprintf (stderr, \"%s: %s: unexpected end of file\\n\",\n+\t\t   progname, jarfile);\n+\t  return 1;\n+\t}\n+      len = UNPACK_UB4(header, CEN_EFLEN);\n+      len += UNPACK_UB4(header, CEN_COMLEN);\n+      if (lseek (fd, len, SEEK_CUR) == -1)\n+\t{\n+\t  perror (progname);\n+\t  return 1;\n+\t}\n+      add_entry (ze);\n+      if (i < count - 1)\n+\t{\n+\t  if (read (fd, header, 46) != 46)\n+\t    {\n+\t      fprintf (stderr, \"%s: %s: unexpected end of file\\n\",\n+\t\t       progname, jarfile);\n+\t      return 1;\n+\t    }\n+\t}\n+    }\n+\n+  lseek (fd, 0, SEEK_SET);\n+  return 0;\n+}\n+\n+int make_manifest(int jfd, const char *mf_name, int updating){\n   time_t current_time;\n   int nlen;   /* length of file name */\n   int mod_time; /* file modification time */\n@@ -812,7 +1023,7 @@ int make_manifest(int jfd, const char *mf_name){\n       exit(1);\n     }\n \n-    if(add_file_to_jar(jfd, mfd, \"META-INF/MANIFEST.MF\", &statbuf)){\n+    if(add_file_to_jar(jfd, mfd, \"META-INF/MANIFEST.MF\", &statbuf, updating)){\n       perror(\"error writing to jar\");\n       exit(1);\n     }\n@@ -823,9 +1034,16 @@ int make_manifest(int jfd, const char *mf_name){\n }\n \n /* Implements -C by wrapping add_to_jar.  new_dir is the directory \n-   to switch to. */\n+   to switch to.\n+\n+   `updating', if nonzero, will indicate that we are updating an\n+   existing file, and will need to take special care. If set, we will\n+   also expect that the linked list of zip entries will be filled in\n+   with the jar file's current contents.\n+ */\n int \n-add_to_jar_with_dir (int fd, const char* new_dir, const char* file)\n+add_to_jar_with_dir (int fd, const char* new_dir, const char* file,\n+\t\t     const int updating)\n {\n   int retval;\n   char old_dir[MAXPATHLEN]; \n@@ -837,7 +1055,7 @@ add_to_jar_with_dir (int fd, const char* new_dir, const char* file)\n     perror(new_dir);\n     return 1;\n   }\n-  retval=add_to_jar(fd, file);\n+  retval=add_to_jar(fd, file, updating);\n   if (chdir(old_dir) == -1) {\n     perror(old_dir);\n     return 1;\n@@ -846,11 +1064,13 @@ add_to_jar_with_dir (int fd, const char* new_dir, const char* file)\n }\n \n int \n-add_to_jar (int fd, const char *file) {\n+add_to_jar (int fd, const char *file, const int updating)\n+{\n   struct stat statbuf;\n   DIR *dir;\n   struct dirent *de;\n   zipentry *ze;\n+  zipentry *existing = NULL;\n   int stat_return;\n \n   /* This is a quick compatibility fix -- Simon Weijgers <simon@weijgers.com> \n@@ -917,9 +1137,6 @@ add_to_jar (int fd, const char *file) {\n     PACK_UB2(file_header, LOC_FNLEN, nlen);\n     PACK_UB4(file_header, LOC_MODTIME, mod_time);\n \n-    if(verbose)\n-      printf(\"adding: %s (in=%d) (out=%d) (stored 0%%)\\n\", fullname, 0, 0);\n-\n     ze = (zipentry*)malloc(sizeof(zipentry));\n     if(ze == NULL){\n       perror(\"malloc\");\n@@ -936,10 +1153,36 @@ add_to_jar (int fd, const char *file) {\n     ze->mod_date = (ub2)((mod_time & 0xffff0000) >> 16);\n     ze->compressed = FALSE;\n \n-    add_entry(ze);\n+    if (updating)\n+      {\n+\tif ((existing = find_entry (ze->filename)) != NULL)\n+\t  {\n+\t    if (existing->usize != 0)\n+\t      {\n+\t\t/* XXX overwriting non-directory with directory? */\n+\t\tfprintf (stderr, \"%s: %s: can't overwrite non-directory with directory\\n\",\n+\t\t\t progname, fullname);\n+\t\treturn 1;\n+\t      }\n+\t  }\n+\tif (lseek (fd, end_of_entries, SEEK_SET) == -1)\n+\t  {\n+\t    fprintf (stderr, \"%s %d\\n\", __FILE__, __LINE__);\n+\t    perror (\"lseek\");\n+\t    return 1;\n+\t  }\n+      }\n+\n+    if (!existing)\n+      {\n+\tadd_entry (ze);\n+\twrite (fd, file_header, 30);\n+\twrite (fd, fullname, nlen);\n+\tend_of_entries = lseek (fd, 0, SEEK_CUR);\n \n-    write(fd, file_header, 30);\n-    write(fd, fullname, nlen);\n+\tif (verbose)\n+\t  printf (\"adding: %s (in=%d) (out=%d) (stored 0%%)\\n\", fullname, 0, 0);\n+      }\n \n     while(!use_explicit_list_only && (de = readdir(dir)) != NULL){\n       if(de->d_name[0] == '.')\n@@ -953,7 +1196,7 @@ add_to_jar (int fd, const char *file) {\n \n       strcpy(t_ptr, de->d_name);\n \n-      if (add_to_jar(fd, fullname)) {\n+      if (add_to_jar(fd, fullname, updating)) {\n         fprintf(stderr, \"Error adding file to jar!\\n\");\n         return 1;\n       }\n@@ -971,7 +1214,7 @@ add_to_jar (int fd, const char *file) {\n       return 1;\n     }\n     \n-    if(add_file_to_jar(fd, add_fd, file, &statbuf)){\n+    if(add_file_to_jar(fd, add_fd, file, &statbuf, updating)){\n       fprintf(stderr, \"Error adding file to jar!\\n\");\n       return 1;\n     }\n@@ -982,15 +1225,28 @@ add_to_jar (int fd, const char *file) {\n   return 0;\n }\n \n-int add_file_to_jar(int jfd, int ffd, const char *fname, struct stat *statbuf){\n-\n+int add_file_to_jar(int jfd, int ffd, const char *fname, struct stat *statbuf,\n+\t\t    const int updating)\n+{\n   unsigned short file_name_length;\n   unsigned long mod_time;\n   ub1 rd_buff[RDSZ];\n   uLong crc = 0;\n   off_t offset = 0;\n   int rdamt;\n   struct zipentry *ze;\n+  struct zipentry *existing = NULL;\n+\n+  if (updating)\n+    {\n+      existing = find_entry (fname);\n+      if (existing && looks_like_dir (fname))\n+\t{\n+\t  fprintf (stderr, \"%s: %s is a directory in the archive\\n\",\n+\t\t   progname, fname);\n+\t  return 1;\n+\t}\n+    }\n \n   mod_time = unix2dostime(&(statbuf->st_mtime));\n   file_name_length = strlen(fname);\n@@ -1045,13 +1301,29 @@ int add_file_to_jar(int jfd, int ffd, const char *fname, struct stat *statbuf){\n \n   ze->csize = statbuf->st_size;\n   ze->usize = ze->csize;\n-  ze->offset = lseek(jfd, 0, SEEK_CUR);\n+\n+  if (existing)\n+    ze->offset = existing->offset;\n+  else if (updating)\n+    ze->offset = end_of_entries;\n+  else\n+    ze->offset = lseek(jfd, 0, SEEK_CUR);\n+\n   if(do_compress)\n     ze->compressed = TRUE;\n   else\n     ze->compressed = FALSE;\n-  \n-  add_entry(ze);\n+\n+  if (!existing)\n+    add_entry(ze);\n+  if (updating && lseek (jfd, ze->offset, SEEK_SET) < 0)\n+    {\n+      perror (\"lseek\");\n+      return 1;\n+    }\n+\n+  /* We can safely write the header here, since it will be the same size\n+     as before */\n   \n   /* Write the local header */\n   write(jfd, file_header, 30);\n@@ -1061,14 +1333,31 @@ int add_file_to_jar(int jfd, int ffd, const char *fname, struct stat *statbuf){\n \n \n   if(verbose){\n-    printf(\"adding: %s \", fname);\n+    if (existing)\n+      printf (\"updating: %s \", fname);\n+    else\n+      printf(\"adding: %s \", fname);\n     fflush(stdout);\n   }\n  \n   if(do_compress){\n     /* compress the file */\n-    compress_file(ffd, jfd, ze);\n+    compress_file(ffd, jfd, ze, existing);\n   } else {\n+    /* If we are not writing the last entry, make space for it. */\n+    if (existing && existing->next_entry)\n+      {\n+\tif (ze->usize > existing->usize)\n+\t  {\n+\t    if (shift_down (jfd, existing->next_entry->offset,\n+\t\t\t    ze->usize - existing->usize, existing->next_entry))\n+\t      {\n+\t\tfprintf (stderr, \"%s: %s\\n\", progname, strerror (errno));\n+\t\treturn 1;\n+\t      }\n+\t  }\n+      }\n+\n     /* Write the contents of the file (uncompressed) to the zip file */\n     /* calculate the CRC as we go along */\n     ze->crc = crc32(0L, Z_NULL, 0); \n@@ -1112,12 +1401,42 @@ int add_file_to_jar(int jfd, int ffd, const char *fname, struct stat *statbuf){\n     /* Sun's jar tool will only allow a data descriptor if the entry is\n        compressed, but we'll save 16 bytes/entry if we only use it when\n        we can't seek back on the file */\n+    /* Technically, you CAN'T have a data descriptor unless the data\n+       part has an obvious end, which DEFLATED does. Otherwise, there\n+       would not be any way to determine where the data descriptor is.\n+       Store an uncompressed file that ends with 0x504b0708, and see.\n+       -- csm */\n     \n     if(write(jfd, data_descriptor, 16) != 16){\n       perror(\"write\");\n       return 0;\n     }\n   }\n+\n+  if (existing)\n+    {\n+      int dd = (existing->flags & (1 << 3)) ? 12 : 0;\n+      if (existing->next_entry && ze->csize < existing->csize + dd)\n+\t{\n+\t  if (shift_up (jfd, existing->next_entry->offset,\n+\t\t\texisting->csize + dd - ze->csize,\n+\t\t\texisting->next_entry))\n+\t    {\n+\t      perror (progname);\n+\t      return 1;\n+\t    }\n+\t}\n+      /* Replace the existing entry data with this entry's. */\n+      existing->csize = ze->csize;\n+      existing->usize = ze->usize;\n+      existing->crc = ze->crc;\n+      existing->mod_time = ze->mod_time;\n+      existing->mod_date = ze->mod_date;\n+      free (ze->filename);\n+      free (ze);\n+    }\n+  else if (updating)\n+    end_of_entries = lseek (jfd, 0, SEEK_CUR);\n   \n   if(verbose)\n     printf(\"(in=%d) (out=%d) (%s %d%%)\\n\", \n@@ -1890,7 +2209,7 @@ void version ()\n {\n   printf(\"jar (%s) %s\\n\\n\", PACKAGE, VERSION);\n   printf(\"Copyright 1999, 2000, 2001  Bryan Burns\\n\");\n-  printf(\"Copyright 2002 Free Software Foundation\\n\");\n+  printf(\"Copyright 2002, 2004 Free Software Foundation\\n\");\n   printf(\"\\\n This is free software; see the source for copying conditions.  There is NO\\n\\\n warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\");"}, {"sha": "11f0c889c14dae6d8cb955112170904abe411b37", "filename": "fastjar/jartool.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fjartool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fjartool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fjartool.h?ref=97b62d4781edb561dfc43fd79583026f11118982", "patch": "@@ -52,6 +52,10 @@\n   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n  */\n \n+#ifndef __FASTJAR_JARTOOL_H__\n+#define __FASTJAR_JARTOOL_H__\n+\n+#include <sys/types.h>\n #include \"config.h\"\n \n #define ACTION_NONE 0\n@@ -104,9 +108,12 @@ struct zipentry {\n   ub4 usize;\n   ub4 offset;\n   ub1 compressed;\n+  ub2 flags;\n   char *filename;\n   \n   struct zipentry *next_entry;\n };\n \n typedef struct zipentry zipentry;\n+\n+#endif /* __FASTJAR_JARTOOL_H__ */"}, {"sha": "dde9035871920ee29b938854b5e8bbff318fd39a", "filename": "fastjar/shift.c", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fshift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fshift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fshift.c?ref=97b62d4781edb561dfc43fd79583026f11118982", "patch": "@@ -0,0 +1,166 @@\n+/* shift.c -- utilities to move regions of data in a file.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2 of the License, or (at\n+your option) any later version.\n+  \n+This program is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+  \n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+USA.  */\n+\n+\n+#include <sys/types.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include \"jartool.h\"\n+#include \"shift.h\"\n+\n+#define BUFFER_SIZE 1024\n+\n+#define MIN(a, b) ((a) < (b) ? (a) : (b))\n+\n+/*\n+ * Shift the contents of a file up by `amount' bytes, starting at `begin'.\n+ * The file is not truncated, data from `amount' to `begin - amount' is\n+ * overwritten. The current file pointer of `fd' is preserved. Note that\n+ * this might be past the new \"end\" of the file.\n+ *\n+ * If this function is passed a `struct zipentry', then all `offset'\n+ * fields from that entry down the list that are greater than or equal\n+ * to `begin' will be decreased by `amount'.\n+ * \n+ * fd     - The file descriptor.\n+ * begin  - The offset of the first byte that should be shifted.\n+ * amount - The number of bytes to shift by.\n+ * ze     - A pointer into a list of zip entries that should be updated\n+ *          to reflect the modified offset.\n+ */\n+int\n+shift_up (int fd, off_t begin, off_t amount, struct zipentry *ze)\n+{\n+  extern off_t end_of_entries;\n+  int len, moved = 0;\n+  ub1 buffer[BUFFER_SIZE];\n+  off_t where, end, save;\n+\n+  if (amount <= 0)\n+    return 0;\n+\n+  if ((save = lseek (fd, 0, SEEK_CUR)) == -1)\n+    return 1;\n+  if ((end = lseek (fd, 0, SEEK_END)) == -1)\n+    return 1;\n+  if (end < begin)\n+    return 0;\n+\n+  where = begin;\n+\n+  do\n+    {\n+      if (lseek (fd, where, SEEK_SET) < 0)\n+\treturn 1;\n+      if ((len = read (fd, buffer, BUFFER_SIZE)) < 0)\n+\treturn 1;\n+      if (len == 0)\n+\tbreak;\n+      if (lseek (fd, where - amount, SEEK_SET) < 0)\n+\treturn 1;\n+      if (write (fd, buffer, len) < 0)\n+\treturn 1;\n+      where += len;\n+    }\n+  while (where < end);\n+\n+  for (; ze; ze = ze->next_entry)\n+    {\n+      if (ze->offset >= begin)\n+\t{\n+\t  ze->offset -= amount;\n+\t  moved = 1;\n+\t}\n+    }\n+  if (moved)\n+    end_of_entries -= amount;\n+\n+  if (lseek (fd, save, SEEK_SET) == -1)\n+    return 1;\n+  return 0;\n+}\n+\n+/*\n+ * Shift the contents of this file down by `amount' bytes, extending the\n+ * end of file, starting at `begin'. This function will preserve the\n+ * current file pointer of `fd'. Naturally, this function will fail if\n+ * `fd' is not seekable.\n+ *\n+ * If this function is passed a `struct zipentry', then all `offset'\n+ * fields from that entry down the list that are greater than or equal\n+ * to `begin' will be increased by `amount'.\n+ *\n+ * fd     - The file descriptor.\n+ * begin  - The offset of the first byte that should be shifted.\n+ * amount - The number of bytes to shift by.\n+ * ze     - A pointer into a list of zip entries that should be updated\n+ *          to reflect the modified offset.\n+ */\n+int\n+shift_down (int fd, off_t begin, off_t amount, struct zipentry *ze)\n+{\n+  extern off_t end_of_entries;\n+  int off, len, moved = 0;\n+  ub1 buffer[BUFFER_SIZE];\n+  off_t where, save;\n+\n+  if (amount <= 0)\n+    return 0;\n+\n+  if ((save = lseek (fd, 0, SEEK_CUR)) == -1)\n+    return 1;\n+  if ((where = lseek (fd, 0, SEEK_END)) == -1)\n+    return 1;\n+  if (where < begin)\n+    return 0;\n+  off = (where - begin) % BUFFER_SIZE;\n+  if (off == 0)\n+    where -= BUFFER_SIZE;\n+  else\n+    where -= off;\n+\n+  do\n+    {\n+      if (lseek (fd, where, SEEK_SET) < 0)\n+\treturn 1;\n+      if ((len = read (fd, buffer, BUFFER_SIZE)) < 0)\n+\treturn 1;\n+      if (lseek (fd, where + amount, SEEK_SET) < 0)\n+\treturn 1;\n+      if (write (fd, buffer, len) < 0)\n+\treturn 1;\n+      where -= BUFFER_SIZE;\n+    }\n+  while (where >= begin);\n+\n+  for (; ze; ze = ze->next_entry)\n+    {\n+      if (ze->offset >= begin)\n+\t{\n+\t  ze->offset += amount;\n+\t  moved = 1;\n+\t}\n+    }\n+  if (moved)\n+    end_of_entries += amount;\n+\n+  if (lseek (fd, save, SEEK_SET) == -1)\n+    return 1;\n+\n+  return 0;\n+}"}, {"sha": "0a792555c7957ed6f8e39f81f21aa57047a41911", "filename": "fastjar/shift.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fshift.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fshift.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fshift.h?ref=97b62d4781edb561dfc43fd79583026f11118982", "patch": "@@ -0,0 +1,29 @@\n+/* shift.h -- utilities to move regions of data in a file.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2 of the License, or (at\n+your option) any later version.\n+  \n+This program is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+  \n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+USA.  */\n+\n+\n+#ifndef __FASTJAR_SHIFT_H__\n+#define __FASTJAR_SHIFT_H__\n+\n+#include <sys/types.h>\n+#include \"jartool.h\"\n+\n+int shift_down (int, off_t, off_t, struct zipentry *);\n+int shift_up (int, off_t, off_t, struct zipentry *);\n+\n+#endif /* __FASTJAR_SHIFT_H__ */"}, {"sha": "dc034586bcc53f798cef7641aee61afa24a68c09", "filename": "fastjar/zipfile.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fzipfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b62d4781edb561dfc43fd79583026f11118982/fastjar%2Fzipfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fzipfile.h?ref=97b62d4781edb561dfc43fd79583026f11118982", "patch": "@@ -47,6 +47,7 @@\n #define LOC_FNLEN   26 /* filename length */\n #define LOC_EFLEN   28 /* extra-field length */\n \n+#define CEN_FLAGS    8\n #define CEN_COMP    10 /* compression method */\n #define CEN_MODTIME 12\n #define CEN_MODDATE 14"}]}