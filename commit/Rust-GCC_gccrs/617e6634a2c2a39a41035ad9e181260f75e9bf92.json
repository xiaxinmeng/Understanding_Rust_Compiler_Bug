{"sha": "617e6634a2c2a39a41035ad9e181260f75e9bf92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE3ZTY2MzRhMmMyYTM5YTQxMDM1YWQ5ZTE4MTI2MGY3NWU5YmY5Mg==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2010-11-24T18:24:39Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2010-11-24T18:24:39Z"}, "message": "Improve vzeroupper optimization.\n\ngcc/\n\n2010-11-24  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR target/46519\n\t* config/i386/i386.c (upper_128bits_state): New.\n\t(block_info_def): Remove upper_128bits_set and done.  Add state,\n\treferenced, count, processed and rescanned. \n\t(check_avx256_stores): Updated.\n\t(move_or_delete_vzeroupper_2): Updated. Handle deleted BB_END.\n\tCall note_stores only if needed.  Set referenced and count.\n\t(move_or_delete_vzeroupper_1): Updated.  Set rescan_vzeroupper_p.\n\t(rescan_move_or_delete_vzeroupper): New.\n\t(move_or_delete_vzeroupper):  Process and rescan all all basic\n\tblocks instead of predecessor blocks of all exit points.\n\t(ix86_option_override_internal): Enable vzeroupper optimization\n\tonly for -fexpensive-optimizations and not optimizing for size.\n\t(use_avx256_p): Removed.\n\t(init_cumulative_args): Don't set use_avx256_p.\n\t(ix86_function_arg): Likewise.\n\t(ix86_expand_move): Likewise.\n\t(ix86_expand_vector_move_misalign): Likewise.\n\t(ix86_local_alignment): Likewise.\n\t(ix86_minimum_alignment): Likewise.\n\t(ix86_expand_epilogue): Don't check use_avx256_p when generating\n\tvzeroupper.\n\t(ix86_expand_call): Likewise.\n\n\t* config/i386/i386.h (machine_function): Remove use_vzeroupper_p\n\tand use_avx256_p.  Add rescan_vzeroupper_p.\n\ngcc/testsuite/\n\n2010-11-24  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR target/46519\n\t* gcc.target/i386/avx-vzeroupper-10.c: Expect no avx_vzeroupper.\n\t* gcc.target/i386/avx-vzeroupper-11.c: Likewise.\n\n\t* gcc.target/i386/avx-vzeroupper-14.c: Replace -O0 with -O2.\n\t* gcc.target/i386/avx-vzeroupper-15.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-16.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-17.c: Likewise.\n\n\t* gcc.target/i386/avx-vzeroupper-20.c: New.\n\t* gcc.target/i386/avx-vzeroupper-21.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-22.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-23.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-24.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-25.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-26.c: Likewise.\n\nFrom-SVN: r167124", "tree": {"sha": "ff51025a91389fdadda16f5296b0266c6edc4b5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff51025a91389fdadda16f5296b0266c6edc4b5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/617e6634a2c2a39a41035ad9e181260f75e9bf92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617e6634a2c2a39a41035ad9e181260f75e9bf92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617e6634a2c2a39a41035ad9e181260f75e9bf92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617e6634a2c2a39a41035ad9e181260f75e9bf92/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a19ff177943cacfaad1fe950d2a775a266700eaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a19ff177943cacfaad1fe950d2a775a266700eaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a19ff177943cacfaad1fe950d2a775a266700eaf"}], "stats": {"total": 454, "additions": 356, "deletions": 98}, "files": [{"sha": "c388057f813b936d8ee7c1c152da2979c7221377", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -1,3 +1,32 @@\n+2010-11-24  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/46519\n+\t* config/i386/i386.c (upper_128bits_state): New.\n+\t(block_info_def): Remove upper_128bits_set and done.  Add state,\n+\treferenced, count, processed and rescanned. \n+\t(check_avx256_stores): Updated.\n+\t(move_or_delete_vzeroupper_2): Updated. Handle deleted BB_END.\n+\tCall note_stores only if needed.  Set referenced and count.\n+\t(move_or_delete_vzeroupper_1): Updated.  Set rescan_vzeroupper_p.\n+\t(rescan_move_or_delete_vzeroupper): New.\n+\t(move_or_delete_vzeroupper):  Process and rescan all all basic\n+\tblocks instead of predecessor blocks of all exit points.\n+\t(ix86_option_override_internal): Enable vzeroupper optimization\n+\tonly for -fexpensive-optimizations and not optimizing for size.\n+\t(use_avx256_p): Removed.\n+\t(init_cumulative_args): Don't set use_avx256_p.\n+\t(ix86_function_arg): Likewise.\n+\t(ix86_expand_move): Likewise.\n+\t(ix86_expand_vector_move_misalign): Likewise.\n+\t(ix86_local_alignment): Likewise.\n+\t(ix86_minimum_alignment): Likewise.\n+\t(ix86_expand_epilogue): Don't check use_avx256_p when generating\n+\tvzeroupper.\n+\t(ix86_expand_call): Likewise.\n+\n+\t* config/i386/i386.h (machine_function): Remove use_vzeroupper_p\n+\tand use_avx256_p.  Add rescan_vzeroupper_p.\n+\n 2010-11-24  Joseph Myers  <joseph@codesourcery.com>\n \n \t* toplev.c: Include <signal.h>."}, {"sha": "2a46f1a3982134eae1dfb1aee3b9b4e462802857", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 173, "deletions": 86, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -57,12 +57,25 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dwarf2out.h\"\n #include \"sched-int.h\"\n \n+enum upper_128bits_state\n+{\n+  unknown = 0,\t\t/* Unknown.  */\n+  unused,\t\t/* Not used or not referenced.  */\n+  used\t\t\t/* Used or referenced.  */\n+};\n+\n typedef struct block_info_def\n {\n-  /* TRUE if the upper 128bits of any AVX registers are live at exit.  */\n-  bool upper_128bits_set;\n+  /* State of the upper 128bits of any AVX registers at exit.  */\n+  enum upper_128bits_state state;\n+  /* If the upper 128bits of any AVX registers are referenced.  */\n+  enum upper_128bits_state referenced;\n+  /* Number of vzerouppers in this block.  */\n+  unsigned int count;\n   /* TRUE if block has been processed.  */\n-  bool done;\n+  bool processed;\n+  /* TRUE if block has been rescanned.  */\n+  bool rescanned;\n } *block_info;\n \n #define BLOCK_INFO(B)   ((block_info) (B)->aux)\n@@ -93,8 +106,9 @@ check_avx256_stores (rtx dest, const_rtx set, void *data)\n \t  && REG_P (SET_SRC (set))\n \t  && VALID_AVX256_REG_MODE (GET_MODE (SET_SRC (set)))))\n     {\n-      bool *upper_128bits_set = (bool *) data;\n-      *upper_128bits_set = true;\n+      enum upper_128bits_state *state\n+\t= (enum upper_128bits_state *) data;\n+      *state = used;\n     }\n }\n \n@@ -106,19 +120,24 @@ check_avx256_stores (rtx dest, const_rtx set, void *data)\n    are live at entry.  */\n \n static void\n-move_or_delete_vzeroupper_2 (basic_block bb, bool upper_128bits_set)\n+move_or_delete_vzeroupper_2 (basic_block bb,\n+\t\t\t     enum upper_128bits_state state)\n {\n-  rtx insn;\n+  rtx insn, bb_end;\n   rtx vzeroupper_insn = NULL_RTX;\n   rtx pat;\n   int avx256;\n+  enum upper_128bits_state referenced = BLOCK_INFO (bb)->referenced;\n+  int count = BLOCK_INFO (bb)->count;\n \n   if (dump_file)\n     fprintf (dump_file, \" BB [%i] entry: upper 128bits: %d\\n\",\n-\t     bb->index, upper_128bits_set);\n+\t     bb->index, state);\n \n+  /* BB_END changes when it is deleted.  */\n+  bb_end = BB_END (bb);\n   insn = BB_HEAD (bb);\n-  while (insn != BB_END (bb))\n+  while (insn != bb_end)\n     {\n       insn = NEXT_INSN (insn);\n \n@@ -167,67 +186,89 @@ move_or_delete_vzeroupper_2 (basic_block bb, bool upper_128bits_set)\n \t      && GET_CODE (XVECEXP (pat, 0, 0)) == UNSPEC_VOLATILE\n \t      && XINT (XVECEXP (pat, 0, 0), 1) == UNSPECV_VZEROALL)\n \t    {\n-\t      upper_128bits_set = false;\n+\t      state = unused;\n \n \t      /* Delete pending vzeroupper insertion.  */\n \t      if (vzeroupper_insn)\n \t\t{\n+\t\t  count--;\n \t\t  delete_insn (vzeroupper_insn);\n \t\t  vzeroupper_insn = NULL_RTX;\n \t\t}\n \t    }\n-\t  else if (!upper_128bits_set)\n-\t    note_stores (pat, check_avx256_stores, &upper_128bits_set);\n+\t  else if (state != used && referenced != unused)\n+\t    {\n+\t      /* No need to call note_stores if the upper 128bits of\n+\t\t AVX registers are never referenced.  */\n+\t      note_stores (pat, check_avx256_stores, &state);\n+\t      if (state == used)\n+\t\treferenced = used;\n+\t    }\n \t  continue;\n \t}\n \n       /* Process vzeroupper intrinsic.  */\n+      count++;\n       avx256 = INTVAL (XVECEXP (pat, 0, 0));\n \n-      if (!upper_128bits_set)\n+      if (state == unused)\n \t{\n \t  /* Since the upper 128bits are cleared, callee must not pass\n \t     256bit AVX register.  We only need to check if callee\n \t     returns 256bit AVX register.  */\n-\t  upper_128bits_set = (avx256 == callee_return_avx256);\n+\t  if (avx256 == callee_return_avx256)\n+\t    state = used;\n \n-\t  /* Remove unnecessary vzeroupper since\n-\t     upper 128bits are cleared.  */\n+\t  /* Remove unnecessary vzeroupper since upper 128bits are\n+\t     cleared.  */\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Delete redundant vzeroupper:\\n\");\n \t      print_rtl_single (dump_file, insn);\n \t    }\n+\t  count--;\n \t  delete_insn (insn);\n \t}\n-      else if (avx256 == callee_return_pass_avx256\n-\t       || avx256 == callee_pass_avx256)\n+      else\n \t{\n-\t  /* Callee passes 256bit AVX register.  Check if callee\n-\t     returns 256bit AVX register.  */\n-\t  upper_128bits_set = (avx256 == callee_return_pass_avx256);\n+\t  /* Set state to UNUSED if callee doesn't return 256bit AVX\n+\t     register.  */\n+\t  if (avx256 != callee_return_pass_avx256)\n+\t    state = unused;\n \n-\t  /* Must remove vzeroupper since\n-\t     callee passes in 256bit AVX register.  */\n-\t  if (dump_file)\n+\t  if (avx256 == callee_return_pass_avx256\n+\t      || avx256 == callee_pass_avx256)\n \t    {\n-\t      fprintf (dump_file, \"Delete callee pass vzeroupper:\\n\");\n-\t      print_rtl_single (dump_file, insn);\n+\t      /* Must remove vzeroupper since callee passes in 256bit\n+\t\t AVX register.  */\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"Delete callee pass vzeroupper:\\n\");\n+\t\t  print_rtl_single (dump_file, insn);\n+\t\t}\n+\t      count--;\n+\t      delete_insn (insn);\n \t    }\n-\t  delete_insn (insn);\n-\t}\n-      else\n-\t{\n-\t  upper_128bits_set = false;\n-\t  vzeroupper_insn = insn;\n+\t  else\n+\t    vzeroupper_insn = insn;\n \t}\n     }\n \n-  BLOCK_INFO (bb)->upper_128bits_set = upper_128bits_set;\n+  BLOCK_INFO (bb)->state = state;\n+\n+  if (BLOCK_INFO (bb)->referenced == unknown)\n+    {\n+      /* The upper 128bits of AVX registers are never referenced if\n+\t REFERENCED isn't updated.  */\n+      if (referenced == unknown)\n+\treferenced = unused;\n+      BLOCK_INFO (bb)->referenced = referenced;\n+      BLOCK_INFO (bb)->count = count;\n+    }\n \n   if (dump_file)\n     fprintf (dump_file, \" BB [%i] exit: upper 128bits: %d\\n\",\n-\t     bb->index, upper_128bits_set);\n+\t     bb->index, state);\n }\n \n /* Helper function for move_or_delete_vzeroupper.  Process vzeroupper\n@@ -238,31 +279,89 @@ move_or_delete_vzeroupper_1 (basic_block block)\n {\n   edge e;\n   edge_iterator ei;\n-  bool upper_128bits_set;\n+  enum upper_128bits_state state;\n \n   if (dump_file)\n     fprintf (dump_file, \" Process BB [%i]: status: %d\\n\",\n-\t     block->index, BLOCK_INFO (block)->done);\n+\t     block->index, BLOCK_INFO (block)->processed);\n \n-  if (BLOCK_INFO (block)->done)\n+  if (BLOCK_INFO (block)->processed)\n     return;\n \n-  BLOCK_INFO (block)->done = true;\n+  BLOCK_INFO (block)->processed = true;\n \n-  upper_128bits_set = false;\n+  state = unknown;\n \n   /* Process all predecessor edges of this block.  */\n   FOR_EACH_EDGE (e, ei, block->preds)\n     {\n       if (e->src == block)\n \tcontinue;\n       move_or_delete_vzeroupper_1 (e->src);\n-      if (BLOCK_INFO (e->src)->upper_128bits_set)\n-\tupper_128bits_set = true;\n+      switch (BLOCK_INFO (e->src)->state)\n+\t{\n+\tcase unknown:\n+\t  if (state == unused)\n+\t    state = unknown;\n+\t  break;\n+\tcase used:\n+\t  state = used;\n+\t  break;\n+\tcase unused:\n+\t  break;\n+\t}\n     }\n \n+  /* If state of any predecessor edges is unknown, we need to rescan.  */\n+  if (state == unknown)\n+    cfun->machine->rescan_vzeroupper_p = 1;\n+\n   /* Process this block.  */\n-  move_or_delete_vzeroupper_2 (block, upper_128bits_set);\n+  move_or_delete_vzeroupper_2 (block, state);\n+}\n+\n+/* Helper function for move_or_delete_vzeroupper.  Rescan vzeroupper\n+   in BLOCK and its predecessor blocks recursively.  */\n+\n+static void\n+rescan_move_or_delete_vzeroupper (basic_block block)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  enum upper_128bits_state state;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \" Rescan BB [%i]: status: %d\\n\",\n+\t     block->index, BLOCK_INFO (block)->rescanned);\n+\n+  if (BLOCK_INFO (block)->rescanned)\n+    return;\n+\n+  BLOCK_INFO (block)->rescanned = true;\n+\n+  state = unused;\n+\n+  /* Rescan all predecessor edges of this block.  */\n+  FOR_EACH_EDGE (e, ei, block->preds)\n+    {\n+      if (e->src == block)\n+\tcontinue;\n+      rescan_move_or_delete_vzeroupper (e->src);\n+      /* For rescan, UKKNOWN state is treated as UNUSED.  */\n+      if (BLOCK_INFO (e->src)->state == used)\n+\tstate = used;\n+    }\n+\n+  /* Rescan this block only if there are vzerouppers or the upper\n+     128bits of AVX registers are referenced.  */\n+  if (BLOCK_INFO (block)->count == 0\n+      && (state == used || BLOCK_INFO (block)->referenced != used))\n+    {\n+      if (state == used)\n+\tBLOCK_INFO (block)->state = state;\n+    }\n+  else\n+    move_or_delete_vzeroupper_2 (block, state);\n }\n \n /* Go through the instruction stream looking for vzeroupper.  Delete\n@@ -274,6 +373,8 @@ move_or_delete_vzeroupper (void)\n {\n   edge e;\n   edge_iterator ei;\n+  basic_block bb;\n+  unsigned int count = 0;\n \n   /* Set up block info for each basic block.  */\n   alloc_aux_for_blocks (sizeof (struct block_info_def));\n@@ -285,16 +386,31 @@ move_or_delete_vzeroupper (void)\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     {\n       move_or_delete_vzeroupper_2 (e->dest,\n-\t\t\t\t   cfun->machine->caller_pass_avx256_p);\n-      BLOCK_INFO (e->dest)->done = true;\n+\t\t\t\t   cfun->machine->caller_pass_avx256_p\n+\t\t\t\t   ? used : unused);\n+      BLOCK_INFO (e->dest)->processed = true;\n+      BLOCK_INFO (e->dest)->rescanned = true;\n     }\n \n-  /* Process predecessor blocks of all exit points.  */\n+  /* Process all basic blocks.  */\n   if (dump_file)\n-    fprintf (dump_file, \"Process all exit points\\n\");\n+    fprintf (dump_file, \"Process all basic blocks\\n\");\n \n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n-    move_or_delete_vzeroupper_1 (e->src);\n+  FOR_EACH_BB (bb)\n+    {\n+      move_or_delete_vzeroupper_1 (bb);\n+      count += BLOCK_INFO (bb)->count;\n+    }\n+\n+  /* Rescan all basic blocks if needed.  */\n+  if (count && cfun->machine->rescan_vzeroupper_p)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Rescan all basic blocks\\n\");\n+\n+      FOR_EACH_BB (bb)\n+\trescan_move_or_delete_vzeroupper (bb);\n+    }\n \n   free_aux_for_blocks ();\n }\n@@ -4051,8 +4167,11 @@ ix86_option_override_internal (bool main_args_p)\n \n   if (TARGET_AVX)\n     {\n-      /* Enable vzeroupper pass by default for TARGET_AVX.  */\n-      if (!(target_flags_explicit & MASK_VZEROUPPER))\n+      /* When not optimize for size, enable vzeroupper optimization for\n+\t TARGET_AVX with -fexpensive-optimizations.  */\n+      if (!optimize_size\n+\t  && flag_expensive_optimizations\n+\t  && !(target_flags_explicit & MASK_VZEROUPPER))\n \ttarget_flags |= MASK_VZEROUPPER;\n     }\n   else \n@@ -4062,17 +4181,6 @@ ix86_option_override_internal (bool main_args_p)\n     }\n }\n \n-/* Return TRUE if type TYPE and mode MODE use 256bit AVX modes.  */\n-\n-static bool\n-use_avx256_p (enum machine_mode mode, const_tree type)\n-{\n-  return (VALID_AVX256_REG_MODE (mode)\n-\t  || (type\n-\t      && TREE_CODE (type) == VECTOR_TYPE\n-\t      && int_size_in_bytes (type) == 32));\n-}\n-\n /* Return TRUE if VAL is passed in register with 256bit AVX modes.  */\n \n static bool\n@@ -5687,7 +5795,6 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n       if (function_pass_avx256_p (fnret_value))\n \t{\n \t  /* The return value of this function uses 256bit AVX modes.  */\n-\t  cfun->machine->use_avx256_p = true;\n \t  if (caller)\n \t    cfun->machine->callee_return_avx256_p = true;\n \t  else\n@@ -6956,7 +7063,6 @@ ix86_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode,\n   if (TARGET_VZEROUPPER && function_pass_avx256_p (arg))\n     {\n       /* This argument uses 256bit AVX modes.  */\n-      cfun->machine->use_avx256_p = true;\n       if (cum->caller)\n \tcfun->machine->callee_pass_avx256_p = true;\n       else\n@@ -10970,12 +11076,9 @@ ix86_expand_epilogue (int style)\n \n   /* Emit vzeroupper if needed.  */\n   if (TARGET_VZEROUPPER\n-      && cfun->machine->use_avx256_p\n+      && !TREE_THIS_VOLATILE (cfun->decl)\n       && !cfun->machine->caller_return_avx256_p)\n-    {\n-      cfun->machine->use_vzeroupper_p = 1;\n-      emit_insn (gen_avx_vzeroupper (GEN_INT (call_no_avx256))); \n-    }\n+    emit_insn (gen_avx_vzeroupper (GEN_INT (call_no_avx256))); \n \n   if (crtl->args.pops_args && crtl->args.size)\n     {\n@@ -15130,9 +15233,6 @@ ix86_expand_move (enum machine_mode mode, rtx operands[])\n   rtx op0, op1;\n   enum tls_model model;\n \n-  if (VALID_AVX256_REG_MODE (mode))\n-    cfun->machine->use_avx256_p = true;\n-\n   op0 = operands[0];\n   op1 = operands[1];\n \n@@ -15277,9 +15377,6 @@ ix86_expand_vector_move (enum machine_mode mode, rtx operands[])\n   rtx op0 = operands[0], op1 = operands[1];\n   unsigned int align = GET_MODE_ALIGNMENT (mode);\n \n-  if (VALID_AVX256_REG_MODE (mode))\n-    cfun->machine->use_avx256_p = true;\n-\n   /* Force constants other than zero into memory.  We do not know how\n      the instructions used to build constants modify the upper 64 bits\n      of the register, once we have that information we may be able\n@@ -15386,9 +15483,6 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n {\n   rtx op0, op1, m;\n \n-  if (VALID_AVX256_REG_MODE (mode))\n-    cfun->machine->use_avx256_p = true;\n-\n   op0 = operands[0];\n   op1 = operands[1];\n \n@@ -21661,12 +21755,11 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n     }\n \n   /* Add UNSPEC_CALL_NEEDS_VZEROUPPER decoration.  */\n-  if (TARGET_VZEROUPPER && cfun->machine->use_avx256_p)\n+  if (TARGET_VZEROUPPER && !TREE_THIS_VOLATILE (cfun->decl))\n     {\n       rtx unspec;\n       int avx256;\n \n-      cfun->machine->use_vzeroupper_p = 1;\n       if (cfun->machine->callee_pass_avx256_p)\n \t{\n \t  if (cfun->machine->callee_return_avx256_p)\n@@ -22763,9 +22856,6 @@ ix86_local_alignment (tree exp, enum machine_mode mode,\n       decl = NULL;\n     }\n \n-  if (use_avx256_p (mode, type))\n-    cfun->machine->use_avx256_p = true;\n-\n   /* Don't do dynamic stack realignment for long long objects with\n      -mpreferred-stack-boundary=2.  */\n   if (!TARGET_64BIT\n@@ -22872,9 +22962,6 @@ ix86_minimum_alignment (tree exp, enum machine_mode mode,\n       decl = NULL;\n     }\n \n-  if (use_avx256_p (mode, type))\n-    cfun->machine->use_avx256_p = true;\n-\n   if (TARGET_64BIT || align != 64 || ix86_preferred_stack_boundary >= 64)\n     return align;\n \n@@ -29782,7 +29869,7 @@ ix86_reorg (void)\n     }\n \n   /* Run the vzeroupper optimization if needed.  */\n-  if (cfun->machine->use_vzeroupper_p)\n+  if (TARGET_VZEROUPPER)\n     move_or_delete_vzeroupper ();\n }\n "}, {"sha": "6bfe99531fb73ebcfbe056b65f243c353004ad59", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -2294,12 +2294,6 @@ struct GTY(()) machine_function {\n      stack below the return address.  */\n   BOOL_BITFIELD static_chain_on_stack : 1;\n \n-  /* Nonzero if the current function uses vzeroupper.  */\n-  BOOL_BITFIELD use_vzeroupper_p : 1;\n-\n-  /* Nonzero if the current function uses 256bit AVX regisers.  */\n-  BOOL_BITFIELD use_avx256_p : 1;\n-\n   /* Nonzero if caller passes 256bit AVX modes.  */\n   BOOL_BITFIELD caller_pass_avx256_p : 1;\n \n@@ -2312,6 +2306,9 @@ struct GTY(()) machine_function {\n   /* Nonzero if the current callee returns 256bit AVX modes.  */\n   BOOL_BITFIELD callee_return_avx256_p : 1;\n \n+  /* Nonzero if rescan vzerouppers in the current function is needed.  */\n+  BOOL_BITFIELD rescan_vzeroupper_p : 1;\n+\n   /* During prologue/epilogue generation, the current frame state.\n      Otherwise, the frame state at the end of the prologue.  */\n   struct machine_frame_state fs;"}, {"sha": "054c1fdf9576c1bfc76fd7a68ae6dbb1ed13dfd9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -1,3 +1,22 @@\n+2010-11-24  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/46519\n+\t* gcc.target/i386/avx-vzeroupper-10.c: Expect no avx_vzeroupper.\n+\t* gcc.target/i386/avx-vzeroupper-11.c: Likewise.\n+\n+\t* gcc.target/i386/avx-vzeroupper-14.c: Replace -O0 with -O2.\n+\t* gcc.target/i386/avx-vzeroupper-15.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-16.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-17.c: Likewise.\n+\n+\t* gcc.target/i386/avx-vzeroupper-20.c: New.\n+\t* gcc.target/i386/avx-vzeroupper-21.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-22.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-23.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-24.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-25.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-26.c: Likewise.\n+\n 2010-11-24  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/43218"}, {"sha": "667bb17180f296a19391624519ecc092f81f1178", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-10.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -14,4 +14,4 @@ foo ()\n   _mm256_zeroupper ();\n }\n \n-/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 3 } } */\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "d98ceb9201201fc72747f978453517e5a86b5244", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-11.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -16,4 +16,4 @@ foo ()\n }\n \n /* { dg-final { scan-assembler-times \"\\\\*avx_vzeroall\" 1 } } */\n-/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 3 } } */\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "a31b4a2a63aa239acfca61193caa1b825d2b4d3b", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-14.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-14.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O0 -mavx -mtune=generic -dp\" } */\n+/* { dg-options \"-O2 -mavx -mtune=generic -dp\" } */\n \n #include <immintrin.h>\n "}, {"sha": "803936eef01e956edaf7dc7272cef32dd26def94", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-15.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-15.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O0 -mavx -mtune=generic -dp\" } */\n+/* { dg-options \"-O2 -mavx -mtune=generic -dp\" } */\n \n #include <immintrin.h>\n "}, {"sha": "ad46d35dc295acd822ba9ea3fb5b60c6a592ecf3", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-16.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target lp64 } */\n-/* { dg-options \"-O0 -mavx -mabi=ms -mtune=generic -dp\" } */\n+/* { dg-options \"-O2 -mavx -mabi=ms -mtune=generic -dp\" } */\n \n typedef float __m256 __attribute__ ((__vector_size__ (32), __may_alias__));\n "}, {"sha": "5b5c64bc0c594a926baf799dbb9fb8753f71a10f", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-17.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-17.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target lp64 } */\n-/* { dg-options \"-O0 -mavx -mabi=ms -mtune=generic -dp\" } */\n+/* { dg-options \"-O2 -mavx -mabi=ms -mtune=generic -dp\" } */\n \n typedef float __m256 __attribute__ ((__vector_size__ (32), __may_alias__));\n "}, {"sha": "33010839e9c6d24bdf4b1e7f53d9cd65de62fddb", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-20.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-20.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mavx -mtune=generic -dp\" } */\n+\n+extern void free (void *);\n+void\n+bar (void *ncstrp)\n+{\n+  if(ncstrp==((void *)0))\n+    return;\n+  free(ncstrp);\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "6dea0552fa37f572de723e2a62962f79088a5f8d", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-21.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-21.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx -mtune=generic -dp\" } */\n+\n+extern void exit (int) __attribute__ ((__noreturn__));\n+\n+int\n+foo (int i)\n+{\n+  if (i == 0)\n+    exit (1);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "b4e4a5806b0577fbada0e8bde0d57448c0072c1b", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-22.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-22.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx -mtune=generic -dp\" } */\n+\n+extern void exit (int) __attribute__ ((__noreturn__));\n+extern void bar (void);\n+\n+int\n+foo (int i)\n+{\n+  if (i == 0)\n+    {\n+      bar ();\n+      exit (1);\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "66df800e919648ec1db723cc8a0f2fa791544ab8", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-23.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-23.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx -mtune=generic -dp\" } */\n+\n+extern void fatal (void) __attribute__ ((__noreturn__));\n+extern void exit (int) __attribute__ ((__noreturn__));\n+\n+void\n+fatal (void)\n+{\n+  exit (1);\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "4fdd374467ef73ac92b2642f87222aa0dfde8790", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-24.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-24.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx -mtune=generic -dp\" } */\n+\n+typedef struct bitmap_element_def {\n+  struct bitmap_element_def *next;\n+  unsigned int indx;\n+} bitmap_element;\n+typedef struct bitmap_head_def {\n+  bitmap_element *first;\n+  bitmap_element *current;\n+  unsigned int indx;\n+} bitmap_head;\n+typedef struct bitmap_head_def *bitmap;\n+typedef const struct bitmap_head_def *const_bitmap;\n+extern void bar (void) __attribute__ ((__noreturn__));\n+unsigned char\n+bitmap_and_compl_into (bitmap a, const_bitmap b)\n+{\n+  bitmap_element *a_elt = a->first;\n+  const bitmap_element *b_elt = b->first;\n+  if (a == b)\n+    {\n+      if ((!(a)->first))\n+\treturn 0;\n+      else\n+\treturn 1;\n+    }\n+  while (a_elt && b_elt)\n+    {\n+      if (a_elt->indx < b_elt->indx)\n+\ta_elt = a_elt->next;\n+    }\n+  if (a->indx == a->current->indx)\n+    bar ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "5ef49c7d32d234d926f8e461da5a404b0c79c177", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-25.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-25.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mtune=generic -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern __m256 x, y;\n+\n+void\n+foo ()\n+{\n+  x = y;\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "96e9190fa810219a7a488bdb6ab7260c9ecebaac", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-26.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617e6634a2c2a39a41035ad9e181260f75e9bf92/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-26.c?ref=617e6634a2c2a39a41035ad9e181260f75e9bf92", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -mavx -mtune=generic -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern __m256 x, y;\n+extern void (*bar) (void);\n+\n+void\n+foo ()\n+{\n+  x = y;\n+  bar ();\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}]}