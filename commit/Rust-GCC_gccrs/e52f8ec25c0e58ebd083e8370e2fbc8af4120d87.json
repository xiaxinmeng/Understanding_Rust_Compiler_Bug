{"sha": "e52f8ec25c0e58ebd083e8370e2fbc8af4120d87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUyZjhlYzI1YzBlNThlYmQwODNlODM3MGUyZmJjOGFmNDEyMGQ4Nw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-02T12:49:29Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-02T12:49:29Z"}, "message": "c++: Fix satisfaction of placeholder type constraints [PR96443]\n\nThis fixes the way we check satisfaction of constraints on placeholder\ntypes in various deduction contexts, and in particular when the\nconstraint is dependent.\n\nFirstly, when evaluating the return type requirement of a compound\nrequirement, we currently substitute the outer template arguments into\nthe constraint before checking satisfaction. But we should instead be\npassing in the complete set of template arguments to satisfaction and\nnot do a prior separate substitution.  Our current approach leads to us\nincorrectly rejecting the testcase concepts-return-req2.C below.\n\nSecondly, when checking the constraints on a placeholder variable or\nreturn type, we don't consider the template arguments of the enclosing\ncontext at all.  This leads to bogus errors during satisfaction when the\nconstraint is dependent as in the testcase concepts-placeholder3.C\nbelow.\n\nIn order to fix these two issues, we need to be able to normalize the\nconstraints on a placeholder 'auto' on demand, which in turn requires us\nto know the template parameters that were in scope where the 'auto' was\nintroduced.  This information currently doesn't seem to be easily available\nwhen we need it, so this patch turns PLACEHOLDER_TYPE_CONSTRAINTS into a\nTREE_LIST whose TREE_PURPOSE additionally holds the value of\ncurrent_template_parms whence a constrained 'auto' was formed.\n\nThis patch also removes some seemingly wrong handling of placeholder\ntype arguments from tsubst_parameter_mapping.  The code doesn't trigger\nwith the example used in the comments, because type_uses_auto doesn't\nlook inside non-deduced contexts such as the operand of decltype.  And\nthe call to do_auto_deduction seems confused because if 'arg' is a type,\nthen so is 'parm', and therefore 'init' too is a type, but\ndo_auto_deduction expects it to be an expression.  Before this patch,\nthis code was dead (as far as our testsuite can tell), but now it breaks\nother parts of this patch, so let's remove it.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/96443\n\tPR c++/96960\n\t* constraint.cc (type_deducible_p): Don't substitute into the\n\tconstraints, and instead just pass 'args' to do_auto_deduction\n\tas the outer template arguments.\n\t(tsubst_parameter_mapping): Remove confused code for handling\n\tplaceholder type arguments.\n\t(normalize_placeholder_type_constraint): Define.\n\t(satisfy_constraint_expression): Use it to handle placeholder\n\t'auto' types.\n\t* cp-tree.h (PLACEHOLDER_TYPE_CONSTRAINTS_INFO): Define.\n\t(PLACEHOLDER_TYPE_CONSTRAINTS): Redefine in terms of the above.\n\t* pt.c (tsubst) <case TEMPLATE_TYPE_PARM>: Use\n\tPLACEHOLDER_TYPE_CONSTRAINTS_INFO instead.\n\t(make_constrained_placeholder_type): Set\n\tPLACEHOLDER_TYPE_CONSTRAINTS_INFO instead.\n\t(do_auto_deduction): Clarify comments about the outer_targs\n\tparameter.  Rework satisfaction of a placeholder type constraint\n\tto pass in the complete set of template arguments directly to\n\tconstraints_satisfied_p.\n\t(splice_late_return_type): Use PLACEHOLDER_TYPE_CONSTRAINTS_INFO\n\tinstead.  Also rebuild the the constraint info on the new auto.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/96443\n\tPR c++/96960\n\t* g++.dg/concepts/abbrev9.C: New test.\n\t* g++.dg/cpp2a/concepts-lambda15.C: New test.\n\t* g++.dg/cpp2a/concepts-placeholder3.C: New test.\n\t* g++.dg/cpp2a/concepts-return-req2.C: New test.\n\t* g++.dg/cpp2a/concepts-ts1.C: Add dg-bogus directive to the\n\tcall to f15 that we expect to accept.", "tree": {"sha": "406045a67c67f70d3ff1ebbe6525feaeed3ddfce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/406045a67c67f70d3ff1ebbe6525feaeed3ddfce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/comments", "author": null, "committer": null, "parents": [{"sha": "276cb81bec63906543b79915d9ff542a34910b2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/276cb81bec63906543b79915d9ff542a34910b2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/276cb81bec63906543b79915d9ff542a34910b2d"}], "stats": {"total": 276, "additions": 172, "deletions": 104}, "files": [{"sha": "3332e6092a950dda413d29cabb5a98c49cf08afc", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 50, "deletions": 61, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=e52f8ec25c0e58ebd083e8370e2fbc8af4120d87", "patch": "@@ -1989,39 +1989,19 @@ type_deducible_p (tree expr, tree type, tree placeholder, tree args,\n      references are preserved in the result.  */\n   expr = force_paren_expr_uneval (expr);\n \n-  /* Replace the constraints with the instantiated constraints. This\n-     substitutes args into any template parameters in the trailing\n-     result type.  */\n-  tree saved_constr = PLACEHOLDER_TYPE_CONSTRAINTS (placeholder);\n-  tree subst_constr\n-    = tsubst_constraint (saved_constr,\n-\t\t\t args,\n-\t\t\t info.complain | tf_partial,\n-\t\t\t info.in_decl);\n-\n-  if (subst_constr == error_mark_node)\n-    return false;\n-\n-  PLACEHOLDER_TYPE_CONSTRAINTS (placeholder) = subst_constr;\n-\n-  /* Temporarily unlink the canonical type.  */\n-  tree saved_type = TYPE_CANONICAL (placeholder);\n-  TYPE_CANONICAL (placeholder) = NULL_TREE;\n-\n-  tree deduced_type\n-    = do_auto_deduction (type,\n-\t\t\t expr,\n-\t\t\t placeholder,\n-\t\t\t info.complain,\n-\t\t\t adc_requirement);\n-\n-  PLACEHOLDER_TYPE_CONSTRAINTS (placeholder) = saved_constr;\n-  TYPE_CANONICAL (placeholder) = saved_type;\n+  /* When args is NULL, we're evaluating a non-templated requires expression,\n+     but even those are parsed under processing_template_decl == 1, and so the\n+     placeholder 'auto' inside this return-type-requirement has level 2.  In\n+     order to have all parms and arguments match up for satisfaction, we need\n+     to pass an empty level of OUTER_TARGS in this case.  */\n+  if (!args)\n+    args = make_tree_vec (0);\n \n-  if (deduced_type == error_mark_node)\n-    return false;\n+  tree deduced_type = do_auto_deduction (type, expr, placeholder,\n+\t\t\t\t\t info.complain, adc_requirement,\n+\t\t\t\t\t /*outer_targs=*/args);\n \n-  return true;\n+  return deduced_type != error_mark_node;\n }\n \n /* True if EXPR can not be converted to TYPE.  */\n@@ -2286,35 +2266,10 @@ tsubst_parameter_mapping (tree map, tree args, subst_info info)\n         return error_mark_node;\n       tree parm = TREE_VALUE (p);\n       tree arg = TREE_PURPOSE (p);\n-      tree new_arg = NULL_TREE;\n-      if (TYPE_P (arg))\n-        {\n-          /* If a template parameter is declared with a placeholder, we can\n-             get those in the argument list if decltype is applied to the\n-             placeholder. For example:\n-\n-\t\ttemplate<auto T>\n-\t\t  requires C<decltype(T)>\n-\t\tvoid f() { }\n-\n-\t     The normalized argument for C will be an auto type, so we'll\n-             need to deduce the actual argument from the corresponding\n-             initializer (whatever argument is provided for T), and use\n-             that result in the instantiated parameter mapping.  */\n-          if (tree auto_node = type_uses_auto (arg))\n-            {\n-              int level;\n-              int index;\n-\t      template_parm_level_and_index (parm, &level, &index);\n-\t      tree init = TMPL_ARG (args, level, index);\n-              new_arg = do_auto_deduction (arg, init, auto_node,\n-\t\t\t\t\t   complain, adc_variable_type,\n-\t\t\t\t\t   make_tree_vec (0));\n-            }\n-        }\n-      else if (ARGUMENT_PACK_P (arg))\n+      tree new_arg;\n+      if (ARGUMENT_PACK_P (arg))\n \tnew_arg = tsubst_argument_pack (arg, args, complain, in_decl);\n-      if (!new_arg)\n+      else\n \t{\n \t  new_arg = tsubst_template_arg (arg, args, complain, in_decl);\n \t  if (TYPE_P (new_arg))\n@@ -3020,6 +2975,36 @@ satisfy_associated_constraints (tree t, tree args, sat_info info)\n   return satisfy_constraint (t, args, info);\n }\n \n+/* Return the normal form of the constraints on the placeholder 'auto'\n+   type T.  */\n+\n+static tree\n+normalize_placeholder_type_constraints (tree t, bool diag)\n+{\n+  gcc_assert (is_auto (t));\n+  tree ci = PLACEHOLDER_TYPE_CONSTRAINTS_INFO (t);\n+  if (!ci)\n+    return NULL_TREE;\n+\n+  tree constr = TREE_VALUE (ci);\n+  /* The TREE_PURPOSE contains the set of template parameters that were in\n+     scope for this placeholder type; use them as the initial template\n+     parameters for normalization.  */\n+  tree initial_parms = TREE_PURPOSE (ci);\n+  /* The 'auto' itself is used as the first argument in its own constraints,\n+     and its level is one greater than its template depth.  So in order to\n+     capture all used template parameters, we need to add an extra level of\n+     template parameters to the context; a dummy level suffices.  */\n+  initial_parms\n+    = tree_cons (size_int (initial_parms\n+\t\t\t   ? TMPL_PARMS_DEPTH (initial_parms) + 1 : 1),\n+\t\t make_tree_vec (0), initial_parms);\n+\n+  norm_info info (diag ? tf_norm : tf_none);\n+  info.initial_parms = initial_parms;\n+  return normalize_constraint_expression (constr, info);\n+}\n+\n /* Evaluate EXPR as a constraint expression using ARGS, returning a\n    satisfaction value. */\n \n@@ -3029,8 +3014,6 @@ satisfy_constraint_expression (tree t, tree args, sat_info info)\n   if (t == error_mark_node)\n     return error_mark_node;\n \n-  gcc_assert (EXPR_P (t));\n-\n   /* Get the normalized constraints.  */\n   tree norm;\n   if (args == NULL_TREE && concept_check_p (t))\n@@ -3054,6 +3037,12 @@ satisfy_constraint_expression (tree t, tree args, sat_info info)\n       norm_info ninfo (info.noisy () ? tf_norm : tf_none);\n       norm = normalize_constraint_expression (t, ninfo);\n     }\n+  else if (is_auto (t))\n+    {\n+      norm = normalize_placeholder_type_constraints (t, info.noisy ());\n+      if (!norm)\n+\treturn boolean_true_node;\n+    }\n   else\n     gcc_unreachable ();\n "}, {"sha": "544e99538a41975de025b8b2d623e58442ddcb6e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e52f8ec25c0e58ebd083e8370e2fbc8af4120d87", "patch": "@@ -1578,11 +1578,19 @@ check_constraint_info (tree t)\n #define COMPOUND_REQ_NOEXCEPT_P(NODE) \\\n   TREE_LANG_FLAG_0 (TREE_CHECK (NODE, COMPOUND_REQ))\n \n-/* The constraints on an 'auto' placeholder type, used in an argument deduction\n-   constraint.  */\n-#define PLACEHOLDER_TYPE_CONSTRAINTS(NODE) \\\n+/* A TREE_LIST whose TREE_VALUE is the constraints on the 'auto' placeholder\n+   type NODE, used in an argument deduction constraint.  The TREE_PURPOSE\n+   holds the set of template parameters that were in-scope when this 'auto'\n+   was formed.  */\n+#define PLACEHOLDER_TYPE_CONSTRAINTS_INFO(NODE) \\\n   DECL_SIZE_UNIT (TYPE_NAME (NODE))\n \n+/* The constraints on the 'auto' placeholder type NODE.  */\n+#define PLACEHOLDER_TYPE_CONSTRAINTS(NODE)\t\t   \\\n+  (PLACEHOLDER_TYPE_CONSTRAINTS_INFO (NODE)\t\t   \\\n+   ? TREE_VALUE (PLACEHOLDER_TYPE_CONSTRAINTS_INFO (NODE)) \\\n+   : NULL_TREE)\n+\n /* True if NODE is a constraint.  */\n #define CONSTR_P(NODE)                  \\\n   (TREE_CODE (NODE) == ATOMIC_CONSTR    \\\n@@ -8420,7 +8428,7 @@ set_implicit_rvalue_p (tree ot)\n inline bool\n is_constrained_auto (const_tree t)\n {\n-  return is_auto (t) && PLACEHOLDER_TYPE_CONSTRAINTS (t);\n+  return is_auto (t) && PLACEHOLDER_TYPE_CONSTRAINTS_INFO (t);\n }\n \n /* RAII class to push/pop class scope T; if T is not a class, do nothing.  */"}, {"sha": "8d65a6e5bd202ce10969be5448446fcc3fb4cbab", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e52f8ec25c0e58ebd083e8370e2fbc8af4120d87", "patch": "@@ -15710,15 +15710,15 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t       ? tf_ignore_bad_quals : 0));\n \t      }\n \t    else if (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n-\t\t     && PLACEHOLDER_TYPE_CONSTRAINTS (t)\n+\t\t     && PLACEHOLDER_TYPE_CONSTRAINTS_INFO (t)\n \t\t     && (r = (TEMPLATE_PARM_DESCENDANTS\n \t\t\t      (TEMPLATE_TYPE_PARM_INDEX (t))))\n \t\t     && (r = TREE_TYPE (r))\n-\t\t     && !PLACEHOLDER_TYPE_CONSTRAINTS (r))\n+\t\t     && !PLACEHOLDER_TYPE_CONSTRAINTS_INFO (r))\n \t      /* Break infinite recursion when substituting the constraints\n \t\t of a constrained placeholder.  */;\n \t    else if (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n-\t\t     && !PLACEHOLDER_TYPE_CONSTRAINTS (t)\n+\t\t     && !PLACEHOLDER_TYPE_CONSTRAINTS_INFO (t)\n \t\t     && !CLASS_PLACEHOLDER_TEMPLATE (t)\n \t\t     && (arg = TEMPLATE_TYPE_PARM_INDEX (t),\n \t\t\t r = TEMPLATE_PARM_DESCENDANTS (arg))\n@@ -15741,8 +15741,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t  {\n \t\t    /* Propagate constraints on placeholders since they are\n \t\t       only instantiated during satisfaction.  */\n-\t\t    if (tree constr = PLACEHOLDER_TYPE_CONSTRAINTS (t))\n-\t\t      PLACEHOLDER_TYPE_CONSTRAINTS (r) = constr;\n+\t\t    if (tree ci = PLACEHOLDER_TYPE_CONSTRAINTS_INFO (t))\n+\t\t      PLACEHOLDER_TYPE_CONSTRAINTS_INFO (r) = ci;\n \t\t    else if (tree pl = CLASS_PLACEHOLDER_TEMPLATE (t))\n \t\t      {\n \t\t\tpl = tsubst_copy (pl, args, complain, in_decl);\n@@ -28183,7 +28183,8 @@ make_constrained_placeholder_type (tree type, tree con, tree args)\n   expr = build_concept_check (expr, type, args, tf_warning_or_error);\n   --processing_template_decl;\n \n-  PLACEHOLDER_TYPE_CONSTRAINTS (type) = expr;\n+  PLACEHOLDER_TYPE_CONSTRAINTS_INFO (type)\n+    = build_tree_list (current_template_parms, expr);\n \n   /* Our canonical type depends on the constraint.  */\n   TYPE_CANONICAL (type) = canonical_type_parameter (type);\n@@ -29423,9 +29424,11 @@ do_class_deduction (tree ptype, tree tmpl, tree init,\n    from INIT.  AUTO_NODE is the TEMPLATE_TYPE_PARM used for 'auto' in TYPE.\n    The CONTEXT determines the context in which auto deduction is performed\n    and is used to control error diagnostics.  FLAGS are the LOOKUP_* flags.\n-   OUTER_TARGS are used during template argument deduction\n-   (context == adc_unify) to properly substitute the result, and is ignored\n-   in other contexts.\n+\n+   OUTER_TARGS is used during template argument deduction (context == adc_unify)\n+   to properly substitute the result.  It's also used in the adc_unify and\n+   adc_requirement contexts to communicate the the necessary template arguments\n+   to satisfaction.  OUTER_TARGS is ignored in other contexts.\n \n    For partial-concept-ids, extra args may be appended to the list of deduced\n    template arguments prior to determining constraint satisfaction.  */\n@@ -29586,30 +29589,21 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n     }\n \n   /* Check any placeholder constraints against the deduced type. */\n-  if (flag_concepts && !processing_template_decl)\n-    if (tree check = NON_ERROR (PLACEHOLDER_TYPE_CONSTRAINTS (auto_node)))\n+  if (flag_concepts)\n+    if (NON_ERROR (PLACEHOLDER_TYPE_CONSTRAINTS (auto_node)))\n       {\n-        /* Use the deduced type to check the associated constraints. If we\n-           have a partial-concept-id, rebuild the argument list so that\n-           we check using the extra arguments. */\n-\tcheck = unpack_concept_check (check);\n-\tgcc_assert (TREE_CODE (check) == TEMPLATE_ID_EXPR);\n-\ttree cdecl = TREE_OPERAND (check, 0);\n-\tif (OVL_P (cdecl))\n-\t  cdecl = OVL_FIRST (cdecl);\n-        tree cargs = TREE_OPERAND (check, 1);\n-        if (TREE_VEC_LENGTH (cargs) > 1)\n-          {\n-            cargs = copy_node (cargs);\n-            TREE_VEC_ELT (cargs, 0) = TREE_VEC_ELT (targs, 0);\n-          }\n-        else\n-          cargs = targs;\n+\tif (processing_template_decl)\n+\t  /* In general we can't check satisfaction until we know all\n+\t     template arguments.  */\n+\t  return type;\n \n-\t/* Rebuild the check using the deduced arguments.  */\n-\tcheck = build_concept_check (cdecl, cargs, tf_none);\n+\tif ((context == adc_return_type || context == adc_variable_type)\n+\t    && current_function_decl\n+\t    && DECL_TEMPLATE_INFO (current_function_decl))\n+\t  outer_targs = DECL_TI_ARGS (current_function_decl);\n \n-\tif (!constraints_satisfied_p (check))\n+\ttree full_targs = add_to_template_args (outer_targs, targs);\n+\tif (!constraints_satisfied_p (auto_node, full_targs))\n           {\n             if (complain & tf_warning_or_error)\n               {\n@@ -29634,15 +29628,16 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n                            \"placeholder constraints\");\n                     break;\n                   }\n-\t\tdiagnose_constraints (input_location, check, targs);\n+\t\tdiagnose_constraints (input_location, auto_node, full_targs);\n               }\n             return error_mark_node;\n           }\n       }\n \n-  if (processing_template_decl && context != adc_unify)\n-    outer_targs = current_template_args ();\n-  targs = add_to_template_args (outer_targs, targs);\n+  if (context == adc_unify)\n+    targs = add_to_template_args (outer_targs, targs);\n+  else if (processing_template_decl)\n+    targs = add_to_template_args (current_template_args (), targs);\n   return tsubst (type, targs, complain, NULL_TREE);\n }\n \n@@ -29669,10 +29664,12 @@ splice_late_return_type (tree type, tree late_return_type)\n \tTREE_VEC_ELT (auto_vec, 0) = new_auto;\n \ttree targs = add_outermost_template_args (current_template_args (),\n \t\t\t\t\t\t  auto_vec);\n-\t/* FIXME: We should also rebuild the constraint to refer to the new\n-\t   auto.  */\n-\tPLACEHOLDER_TYPE_CONSTRAINTS (new_auto)\n-\t  = PLACEHOLDER_TYPE_CONSTRAINTS (auto_node);\n+\t/* Also rebuild the constraint info in terms of the new auto.  */\n+\tif (tree ci = PLACEHOLDER_TYPE_CONSTRAINTS_INFO (auto_node))\n+\t  PLACEHOLDER_TYPE_CONSTRAINTS_INFO (new_auto)\n+\t    = build_tree_list (current_template_parms,\n+\t\t\t       tsubst_constraint (TREE_VALUE (ci), targs,\n+\t\t\t\t\t\t  tf_none, NULL_TREE));\n \tTYPE_CANONICAL (new_auto) = canonical_type_parameter (new_auto);\n \treturn tsubst (type, targs, tf_none, NULL_TREE);\n       }"}, {"sha": "865b44c6a6361e94158c4adfc45522a0690c453b", "filename": "gcc/testsuite/g++.dg/concepts/abbrev9.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fabbrev9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fabbrev9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fabbrev9.C?ref=e52f8ec25c0e58ebd083e8370e2fbc8af4120d87", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile { target concepts } }\n+\n+template <class T, class U> concept same_as = __is_same(T, U);\n+\n+same_as<int> auto f(auto, auto y) {\n+  return y; // { dg-error \"deduced return type\" }\n+}\n+\n+template <class>\n+struct A {\n+  static auto g(auto x, auto y) -> same_as<decltype(x)> auto {\n+    return y; // { dg-error \"deduced return type\" }\n+  }\n+};\n+\n+int main() {\n+  f(0, 0);   // { dg-bogus \"\" }\n+  f(\"\", 0);  // { dg-bogus \"\" }\n+  f(0, \"\");  // { dg-message \"required from here\" }\n+  f(\"\", \"\"); // { dg-message \"required from here\" }\n+\n+  A<void>::g(0, 0);   // { dg-bogus \"\" }\n+  A<void>::g(\"\", 0);  // { dg-message \"required from here\" }\n+  A<void>::g(0, \"\");  // { dg-message \"required from here\" }\n+  A<void>::g(\"\", \"\"); // { dg-bogus \"\" }\n+}"}, {"sha": "29df5d0b1acc0bdca84df37cfb72edb86135eccf", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda15.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda15.C?ref=e52f8ec25c0e58ebd083e8370e2fbc8af4120d87", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/96960\n+// { dg-do compile { target c++20 } }\n+\n+template <class, class> concept C0 = true;\n+\n+template <class T>\n+concept C = requires(T t) {\n+  { 42 } -> C0<char [([] { return 42; }())]>;\n+};\n+\n+static_assert(C<int>);\n+\n+C0<char [([] { return 42; }())]> auto x = 42;\n+\n+int f(C0<char [([] { return 42; }())]> auto x);\n+int y = f(42);"}, {"sha": "87e3c093e28fa711c2efbfa6d4689ac850b2caf6", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-placeholder3.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-placeholder3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-placeholder3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-placeholder3.C?ref=e52f8ec25c0e58ebd083e8370e2fbc8af4120d87", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/96443\n+// { dg-do compile { target c++20 } }\n+\n+template <class T, class U> concept same_as = __is_same(T, U);\n+\n+auto f(auto x) -> same_as<decltype(x)> auto { return 0; }; // { dg-error \"constraints\" }\n+void g(auto x) { same_as<decltype(x)> auto y = 0; } // { dg-error \"constraints\" }\n+auto h(auto x) -> same_as<decltype(x.missing)> auto { return 0; } // { dg-error \"constraints|missing\" }\n+template <class T, same_as<T> auto N> void i() {}\n+\n+int main() {\n+  f(0); // { dg-bogus \"\" }\n+  f(true); // { dg-message \"required from here\" }\n+  g(0); // { dg-bogus \"\" }\n+  g(true); // { dg-message \"required from here\" }\n+  h(0); // { dg-message \"required from here\" }\n+  i<int, 0>(); // { dg-bogus \"\" }\n+  i<int, true>(); // { dg-error \"no match|constraints\" }\n+}"}, {"sha": "77208bb706942942da0e62e26c81efb1cc9a713b", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-return-req2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-return-req2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-return-req2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-return-req2.C?ref=e52f8ec25c0e58ebd083e8370e2fbc8af4120d87", "patch": "@@ -0,0 +1,13 @@\n+// Verify we check return-type-requirements by passing the entire set of\n+// template arguments to normalization rather than first substituting into\n+// the constraint.  The latter approach would induce a substitution failure and\n+// cause the requires-expression to evaluate to false here.\n+// { dg-do compile { target c++20 } }\n+\n+template <class, class>\n+concept C1 = true;\n+\n+template <class T>\n+concept C2 = requires { { 0 } -> C1<typename T::type>; };\n+\n+static_assert(C2<int>);"}, {"sha": "a116cac4ea40557f2b8e86e27fca9787c3003a10", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-ts1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-ts1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52f8ec25c0e58ebd083e8370e2fbc8af4120d87/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-ts1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-ts1.C?ref=e52f8ec25c0e58ebd083e8370e2fbc8af4120d87", "patch": "@@ -40,7 +40,7 @@ void driver()\n   f3('a'); // { dg-error \"\" }\n   f4(0, 0);\n   f4(0, 'a'); // { dg-error \"\" }\n-  f15(0);\n+  f15(0); // { dg-bogus \"\" }\n   f15('a'); // { dg-message \"\" }\n }\n "}]}