{"sha": "f5b0eb4e8855af46a10ce3ac99c9a685fe5010c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjViMGViNGU4ODU1YWY0NmExMGNlM2FjOTljOWE2ODVmZTUwMTBjMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-19T21:48:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-19T21:48:23Z"}, "message": "(struct switchstr): New field LIVE_COND.\n\n(process_command): Initialize it.\n(check_live_switch): New function.\n(handle_braces): Call it.\n\nFrom-SVN: r7078", "tree": {"sha": "b670a36e3e5423db5e9764cc9bcce88791240164", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b670a36e3e5423db5e9764cc9bcce88791240164"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5b0eb4e8855af46a10ce3ac99c9a685fe5010c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b0eb4e8855af46a10ce3ac99c9a685fe5010c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5b0eb4e8855af46a10ce3ac99c9a685fe5010c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b0eb4e8855af46a10ce3ac99c9a685fe5010c0/comments", "author": null, "committer": null, "parents": [{"sha": "c0c523d85bff72ecd63c9f68c9f6a1a78d10be79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0c523d85bff72ecd63c9f68c9f6a1a78d10be79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0c523d85bff72ecd63c9f68c9f6a1a78d10be79"}], "stats": {"total": 103, "additions": 97, "deletions": 6}, "files": [{"sha": "508875eea370d1642af67f58dc77d53db8a95bfd", "filename": "gcc/gcc.c", "status": "modified", "additions": 97, "deletions": 6, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b0eb4e8855af46a10ce3ac99c9a685fe5010c0/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b0eb4e8855af46a10ce3ac99c9a685fe5010c0/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=f5b0eb4e8855af46a10ce3ac99c9a685fe5010c0", "patch": "@@ -203,6 +203,7 @@ static char *find_a_file\tPROTO((struct path_prefix *, char *, int));\n static void add_prefix\t\tPROTO((struct path_prefix *, char *, int, int, int *));\n static char *skip_whitespace\tPROTO((char *));\n static void record_temp_file\tPROTO((char *, int, int));\n+static int check_live_switch\tPROTO((int, int));\n static char *handle_braces\tPROTO((char *));\n static char *save_string\tPROTO((char *, int));\n static char *concat\t\tPROTO((char *, char *, char *));\n@@ -330,6 +331,11 @@ The conditional text X in a %{S:X} or %{!S:X} construct may contain\n other nested % constructs or spaces, or even newlines.  They are\n processed as usual, as described above.\n \n+The -O, -f, -m, and -w switches are handled specifically in these\n+constructs.  If another value of -O or the negated form of a -f, -m, or\n+-W switch is found later in the command line, the earlier switch\n+value is ignored.\n+\n The character | is used to indicate that a command should be piped to\n the following command, but only if -pipe is specified.\n \n@@ -2113,13 +2119,16 @@ execute ()\n    If a switch uses following arguments, then the `part1' field\n    is the switch itself and the `args' field\n    is a null-terminated vector containing the following arguments.\n+   The `live_cond' field is 1 if the switch is true in a conditional spec,\n+   -1 if false (overridden by a later switch), and is initialized to zero.\n    The `valid' field is nonzero if any spec has looked at this switch;\n    if it remains zero at the end of the run, it must be meaningless.  */\n \n struct switchstr\n {\n   char *part1;\n   char **args;\n+  int live_cond;\n   int valid;\n };\n \n@@ -2567,6 +2576,7 @@ process_command (argc, argv)\n \t     -e0 or -e1 down into the linker.  */\n \t  switches[n_switches].part1 = &argv[i][0];\n \t  switches[n_switches].args = 0;\n+\t  switches[n_switches].live_cond = 0;\n \t  switches[n_switches].valid = 0;\n \t  n_switches++;\n \t}\n@@ -2633,6 +2643,8 @@ process_command (argc, argv)\n \t    }\n \t  else\n \t    switches[n_switches].args = 0;\n+\n+\t  switches[n_switches].live_cond = 0;\n \t  switches[n_switches].valid = 0;\n \t  /* This is always valid, since gcc.c itself understands it.  */\n \t  if (!strcmp (p, \"save-temps\"))\n@@ -3570,7 +3582,8 @@ handle_braces (p)\n       register int i;\n       --p;\n       for (i = 0; i < n_switches; i++)\n-\tif (!strncmp (switches[i].part1, filter, p - filter))\n+\tif (!strncmp (switches[i].part1, filter, p - filter)\n+\t    && check_live_switch (i, p - filter))\n \t  give_switch (i, 0);\n     }\n   else\n@@ -3605,7 +3618,8 @@ handle_braces (p)\n \t      char *string = save_string (p + 1, q - p - 2);\n \n \t      for (i = 0; i < n_switches; i++)\n-\t\tif (!strncmp (switches[i].part1, filter, hard_match_len))\n+\t\tif (!strncmp (switches[i].part1, filter, hard_match_len)\n+\t\t    && check_live_switch (i, hard_match_len))\n \t\t  {\n \t\t    do_spec_1 (string, 0, &switches[i].part1[hard_match_len]);\n \t\t    /* Pass any arguments this switch has.  */\n@@ -3624,9 +3638,9 @@ handle_braces (p)\n \t    {\n \t      unsigned hard_match_len = p - filter - 1;\n \n-\t      if (!strncmp (switches[i].part1, filter, hard_match_len))\n+\t      if (!strncmp (switches[i].part1, filter, hard_match_len)\n+\t\t  && check_live_switch (i, hard_match_len))\n \t\t{\n-\t\t  switches[i].valid = 1;\n \t\t  present = 1;\n \t\t}\n \t    }\n@@ -3637,9 +3651,9 @@ handle_braces (p)\n \t  for (i = 0; i < n_switches; i++)\n \t    {\n \t      if (!strncmp (switches[i].part1, filter, p - filter)\n-\t\t  && switches[i].part1[p - filter] == 0)\n+\t\t  && switches[i].part1[p - filter] == 0\n+\t\t  && check_live_switch (i, p - filter))\n \t\t{\n-\t\t  switches[i].valid = 1;\n \t\t  present = 1;\n \t\t  break;\n \t\t}\n@@ -3671,7 +3685,84 @@ handle_braces (p)\n \n   return q;\n }\n+\f\n+/* Return 0 if switch number SWITCHNUM is obsoleted by a later switch\n+   on the command line.  LENGTH is the length of the switch name we\n+   are to compare for.  Otherwise return zero.\n+\n+   A -O switch is obsoleted by a later -O switch.  A -f, -m, or -W switch\n+   whose value does not begin with \"no-\" is obsoleted by the same value\n+   with the \"no-\", similarly for a switch with the \"no-\" prefix.  */\n \n+static int\n+check_live_switch (switchnum, length)\n+     int switchnum;\n+     int length;\n+{\n+  char *name = switches[switchnum].part1;\n+  int i;\n+\n+  /* If we just have a single letter and it isn't \"O\", a negating\n+     switch would always match, so ignore that case.  We will just\n+     send the conflicting switches to the compiler phase.  */\n+  if (length == 1 && name[0] != 'O')\n+    return 1;\n+\n+  /* If we already processed this switch and determined if it was\n+     live or not, return our past determination.  */\n+  if (switches[switchnum].live_cond != 0)\n+    return switches[switchnum].live_cond > 0;\n+\n+  /* Now search for duplicate in a manner that depends on the name.  */\n+  switch (*name)\n+    {\n+    case 'O':\n+      if (length == 1)\n+\tfor (i = switchnum + 1; i < n_switches; i++)\n+\t  if (switches[i].part1[0] == 'O')\n+\t    {\n+\t      switches[switchnum].valid = 1;\n+\t      switches[switchnum].live_cond = -1;\n+\t      return 0;\n+\t    }\n+      break;\n+\n+    case 'W':  case 'f':  case 'm':\n+      if (length > 4 && ! strncmp (name + 1, \"no-\", 3))\n+\t{\n+\t  /* We have Xno-YYY, search for XYYY. */\n+\t  for (i = switchnum + 1; i < n_switches; i++)\n+\t    if (switches[i].part1[0] == name[0]\n+\t\t&& ! strcmp (&switches[i].part1[1], &name[4]))\n+\t    {\n+\t      switches[switchnum].valid = 1;\n+\t      switches[switchnum].live_cond = -1;\n+\t      return 0;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* We have XYYY, search for Xno-YYY.  */\n+\t  for (i = switchnum + 1; i < n_switches; i++)\n+\t    if (switches[i].part1[0] == name[0]\n+\t\t&& switches[i].part1[1] == 'n'\n+\t\t&& switches[i].part1[2] == 'o'\n+\t\t&& switches[i].part1[3] == '-'\n+\t\t&& !strcmp (&switches[i].part1[4], &name[1]))\n+\t    {\n+\t      switches[switchnum].valid = 1;\n+\t      switches[switchnum].live_cond = -1;\n+\t      return 0;\n+\t    }\n+\t}\n+      break;\n+    }\n+\n+  /* Otherwise the switch is live.  */\n+  switches[switchnum].live_cond = 1;\n+  return 1;\n+}\n+\f\n /* Pass a switch to the current accumulating command\n    in the same form that we received it.\n    SWITCHNUM identifies the switch; it is an index into"}]}