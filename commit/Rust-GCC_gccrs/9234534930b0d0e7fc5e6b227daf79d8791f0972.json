{"sha": "9234534930b0d0e7fc5e6b227daf79d8791f0972", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIzNDUzNDkzMGIwZDBlN2ZjNWU2YjIyN2RhZjc5ZDg3OTFmMDk3Mg==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2012-07-25T03:07:08Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-07-25T03:07:08Z"}, "message": "tm.texi: Regenerate.\n\n2012-07-24  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.c (default_init_cost): Add prologue and epilogue costs.\n\t(default_add_stmt_cost): Likewise; also handle NULL stmt_info.\n\t(default_finish_cost): Add prologue and epilogue costs.\n\t* targhooks.h (default_add_stmt_cost): Change parameter list.\n\t(default_finish_cost): Likewise.\n\t* target.def (init_cost): Change documentation string.\n\t(add_stmt_cost): Change documentation string and parameter list.\n\t(finish_cost): Likewise.\n\t* target.h (vect_cost_model_location): New enum.\n\t* tree-vectorizer.h (struct _slp_tree): Remove cost substruct.\n\t(struct _slp_instance): Remove cost substruct; rename stmt_cost_vec\n\tto body_cost_vec.\n\t(SLP_INSTANCE_OUTSIDE_OF_LOOP_COST): Remove.\n\t(SLP_INSTANCE_STMT_COST_VEC): Rename to SLP_INSTANCE_BODY_COST_VEC.\n\t(SLP_TREE_OUTSIDE_OF_LOOP_COST): Remove.\n\t(struct _vect_peel_extended_info): Rename stmt_cost_vec to\n\tbody_cost_vec.\n\t(struct _stmt_vec_info): Remove cost substruct.\n\t(STMT_VINFO_OUTSIDE_OF_LOOP_COST): Remove.\n\t(stmt_vinfo_set_outside_of_loop_cost): Remove.\n\t(builtin_vectorization_cost): New function.\n\t(vect_get_stmt_cost): Change to use builtin_vectorization_cost.\n\t(add_stmt_cost): Change parameter list.\n\t(finish_cost): Likewise.\n\t(vect_model_simple_cost): Likewise.\n\t(vect_model_store_cost): Likewise.\n\t(vect_model_load_cost): Likewise.\n\t(record_stmt_cost): Likewise.\n\t(vect_get_load_cost): Likewise.\n\t(vect_get_known_peeling_cost): Likewise.\n\t* tree-vect-loop.c (vect_get_known_peeling_cost): Change parameter\n\tlist; call record_stmt_cost for prologue and epilogue costs.\n\t(vect_estimate_min_profitable_iters): Call add_stmt_cost for\n\tprologue and epilogue costs; remove computation of vec_outside_cost;\n\treturn vec_prologue_cost and vec_epilogue_cost from finish_cost.\n\t(vect_model_reduction_cost): Revise call to add_stmt_cost for body\n\tcosts; call add_stmt_cost for prologue and epilogue costs.\n\t(vect_model_induction_cost): Revise call to add_stmt_cost for body\n\tcosts; call add_stmt_cost for prologue costs.\n\t* tree-vect-data-refs.c (vect_get_data_access_cost): Change parameter\n\tlist for function and arguments for calls to vect_get_load_cost and\n\tvect_get_store_cost.\n\t(vect_peeling_hash_get_lowest_cost): Change argument list for calls to\n\tvect_get_data_access_cost and vect_get_known_peeling_cost; use\n\ttemporary vectors prologue_cost_vec and epilogue_cost_vec for the\n\tlatter call and discard their results; rename stmt_cost_vec to\n\tbody_cost_vec; correct possible storage leak for body_cost_vec.\n\t(vect_peeling_hash_choose_best_peeling): Rename stmt_cost_vec to\n\tbody_cost_vec.\n\t(vect_enhance_data_refs_alignment): Rename stmt_cost_vec to\n\tbody_cost_vec; add extra dummy parameter on calls to\n\tvect_get_data_access_cost; tolerate null si->stmt; add vect_body to\n\targument list on call to add_stmt_cost.\n\t* tree-vect-stmts.c (record_stmt_cost): Change parameter list;\n\trename stmt_cost_vec to body_cost_vec; tolerate null stmt_info; call\n\tbuiltin_vectorization_cost; add \"where\" parameter on call to\n\tadd_stmt_cost.\n\t(vect_model_simple_cost): Change parameter list; call record_stmt_cost\n\tfor prologue costs; remove call to stmt_vinfo_set_outside_of_loop_cost;\n\trename stmt_cost_vec to body_cost_vec.\n\t(vect_model_promotion_demotion_cost): Add vect_body argument to call\n\tto add_stmt_cost; call add_stmt_cost for prologue costs; remove call\n\tto stmt_vinfo_set_outside_of_loop_cost.\n\t(vect_model_store_cost): Change parameter list; call record_stmt_cost\n\tfor prologue costs; add vect_body argument to call to record_stmt_cost;\n\trename stmt_cost_vec to body_cost_vec; remove call to\n\tstmt_vinfo_set_outside_of_loop_cost.\n\t(vect_get_store_cost): Rename stmt_cost_vec to body_cost_vec; add\n\tvect_body argument to calls to record_stmt_cost.\n\t(vect_model_load_cost): Change parameter list; rename stmt_cost_vec to\n\tbody_cost_vec; add vect_body argument to calls to record_stmt_cost;\n\tremove call to stmt_vinfo_set_outside_of_loop_cost.\n\t(vect_get_load_cost): Change parameter list; rename stmt_cost_vec to\n\tbody_cost_vec; add vect_body argument to calls to record_stmt_cost;\n\tcall record_stmt_cost for prologue costs.\n\t(vectorizable_store): Change argument list for call to\n\tvect_model_store_cost.\n\t(vectorizable_load): Change argument list for call to\n\tvect_model_load_cost.\n\t(new_stmt_vec_info): Remove assignment to\n\tSTMT_VINFO_OUTSIDE_OF_LOOP_COST.\n\t* config/spu/spu.c (spu_init_cost): Add prologue and epilogue costs.\n\t(spu_add_stmt_cost): Likewise; also handle NULL stmt_info.\n\t(spu_finish_cost): Add prologue and epilogue costs.\n\t* config/i386/i386.c (i386_init_cost): Add prologue and epilogue costs.\n\t(i386_add_stmt_cost): Likewise; also handle NULL stmt_info.\n\t(i386_finish_cost): Add prologue and epilogue costs.\n\t* config/rs6000/rs6000.c (rs6000_init_cost): Add prologue and epilogue\n\tcosts.\n\t(rs6000_add_stmt_cost): Likewise; also handle NULL stmt_info.\n\t(rs6000_finish_cost): Add prologue and epilogue costs.\n\t* tree-vect-slp.c (vect_free_slp_instance): Rename\n\tSLP_INSTANCE_STMT_COST_VEC to SLP_INSTANCE_BODY_COST_VEC.\n\t(vect_create_new_slp_node): Remove assignment to\n\tSLP_TREE_OUTSIDE_OF_LOOP_COST.\n\t(vect_get_and_check_slp_defs): Change parameter list; change argument\n\tlists to calls to vect_model_store_cost and vect_model_simple_cost.\n\t(vect_build_slp_tree): Change parameter list; change argument lists\n\tto calls to vect_model_load_cost, vect_get_and_check_slp_defs, and\n\trecursive self-calls; remove setting of outside_cost from\n\tSLP_TREE_OUTSIDE_OF_LOOP_COST; add vect_body argument to call to\n\trecord_stmt_cost.\n\t(vect_analyze_slp_instance): Rename stmt_cost_vec to body_cost_vec;\n\trename SLP_INSTANCE_STMT_COST_VEC to SLP_INSTANCE_BODY_COST_VEC;\n\tremove assignment to SLP_INSTANCE_OUTSIDE_OF_LOOP_COST; record SLP\n\tprologue costs.\n\t(vect_bb_vectorization_profitable_p): Rename stmt_cost_vec to\n\tbody_cost_vec; handle null ci->stmt; add vect_body argument to call\n\tto add_stmt_cost; simplify calls to targetm.vectorize.\n\tbuiltin_vectorization_cost; return vec_prologue_cost and\n\tvec_epilogue_cost from finish_cost.\n\t(vect_update_slp_costs_according_to_vf): Rename stmt_cost_vec to\n\tbody_cost_vec; add vect_body argument to call to add_stmt_cost.\n\nFrom-SVN: r189836", "tree": {"sha": "ae51baf9345c38bdbb25531d72d91e057a404b0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae51baf9345c38bdbb25531d72d91e057a404b0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9234534930b0d0e7fc5e6b227daf79d8791f0972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9234534930b0d0e7fc5e6b227daf79d8791f0972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9234534930b0d0e7fc5e6b227daf79d8791f0972", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9234534930b0d0e7fc5e6b227daf79d8791f0972/comments", "author": null, "committer": null, "parents": [{"sha": "ad7771415e97cb451a2bfab655629e389bbef0f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad7771415e97cb451a2bfab655629e389bbef0f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad7771415e97cb451a2bfab655629e389bbef0f4"}], "stats": {"total": 960, "additions": 575, "deletions": 385}, "files": [{"sha": "2ab21720688426f5182fa3d5db01723c091cef39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -1,3 +1,120 @@\n+2012-07-24  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.c (default_init_cost): Add prologue and epilogue costs.\n+\t(default_add_stmt_cost): Likewise; also handle NULL stmt_info.\n+\t(default_finish_cost): Add prologue and epilogue costs.\n+\t* targhooks.h (default_add_stmt_cost): Change parameter list.\n+\t(default_finish_cost): Likewise.\n+\t* target.def (init_cost): Change documentation string.\n+\t(add_stmt_cost): Change documentation string and parameter list.\n+\t(finish_cost): Likewise.\n+\t* target.h (vect_cost_model_location): New enum.\n+\t* tree-vectorizer.h (struct _slp_tree): Remove cost substruct.\n+\t(struct _slp_instance): Remove cost substruct; rename stmt_cost_vec\n+\tto body_cost_vec.\n+\t(SLP_INSTANCE_OUTSIDE_OF_LOOP_COST): Remove.\n+\t(SLP_INSTANCE_STMT_COST_VEC): Rename to SLP_INSTANCE_BODY_COST_VEC.\n+\t(SLP_TREE_OUTSIDE_OF_LOOP_COST): Remove.\n+\t(struct _vect_peel_extended_info): Rename stmt_cost_vec to\n+\tbody_cost_vec.\n+\t(struct _stmt_vec_info): Remove cost substruct.\n+\t(STMT_VINFO_OUTSIDE_OF_LOOP_COST): Remove.\n+\t(stmt_vinfo_set_outside_of_loop_cost): Remove.\n+\t(builtin_vectorization_cost): New function.\n+\t(vect_get_stmt_cost): Change to use builtin_vectorization_cost.\n+\t(add_stmt_cost): Change parameter list.\n+\t(finish_cost): Likewise.\n+\t(vect_model_simple_cost): Likewise.\n+\t(vect_model_store_cost): Likewise.\n+\t(vect_model_load_cost): Likewise.\n+\t(record_stmt_cost): Likewise.\n+\t(vect_get_load_cost): Likewise.\n+\t(vect_get_known_peeling_cost): Likewise.\n+\t* tree-vect-loop.c (vect_get_known_peeling_cost): Change parameter\n+\tlist; call record_stmt_cost for prologue and epilogue costs.\n+\t(vect_estimate_min_profitable_iters): Call add_stmt_cost for\n+\tprologue and epilogue costs; remove computation of vec_outside_cost;\n+\treturn vec_prologue_cost and vec_epilogue_cost from finish_cost.\n+\t(vect_model_reduction_cost): Revise call to add_stmt_cost for body\n+\tcosts; call add_stmt_cost for prologue and epilogue costs.\n+\t(vect_model_induction_cost): Revise call to add_stmt_cost for body\n+\tcosts; call add_stmt_cost for prologue costs.\n+\t* tree-vect-data-refs.c (vect_get_data_access_cost): Change parameter\n+\tlist for function and arguments for calls to vect_get_load_cost and\n+\tvect_get_store_cost.\n+\t(vect_peeling_hash_get_lowest_cost): Change argument list for calls to\n+\tvect_get_data_access_cost and vect_get_known_peeling_cost; use\n+\ttemporary vectors prologue_cost_vec and epilogue_cost_vec for the\n+\tlatter call and discard their results; rename stmt_cost_vec to\n+\tbody_cost_vec; correct possible storage leak for body_cost_vec.\n+\t(vect_peeling_hash_choose_best_peeling): Rename stmt_cost_vec to\n+\tbody_cost_vec.\n+\t(vect_enhance_data_refs_alignment): Rename stmt_cost_vec to\n+\tbody_cost_vec; add extra dummy parameter on calls to\n+\tvect_get_data_access_cost; tolerate null si->stmt; add vect_body to\n+\targument list on call to add_stmt_cost.\n+\t* tree-vect-stmts.c (record_stmt_cost): Change parameter list;\n+\trename stmt_cost_vec to body_cost_vec; tolerate null stmt_info; call\n+\tbuiltin_vectorization_cost; add \"where\" parameter on call to\n+\tadd_stmt_cost.\n+\t(vect_model_simple_cost): Change parameter list; call record_stmt_cost\n+\tfor prologue costs; remove call to stmt_vinfo_set_outside_of_loop_cost;\n+\trename stmt_cost_vec to body_cost_vec.\n+\t(vect_model_promotion_demotion_cost): Add vect_body argument to call\n+\tto add_stmt_cost; call add_stmt_cost for prologue costs; remove call\n+\tto stmt_vinfo_set_outside_of_loop_cost.\n+\t(vect_model_store_cost): Change parameter list; call record_stmt_cost\n+\tfor prologue costs; add vect_body argument to call to record_stmt_cost;\n+\trename stmt_cost_vec to body_cost_vec; remove call to\n+\tstmt_vinfo_set_outside_of_loop_cost.\n+\t(vect_get_store_cost): Rename stmt_cost_vec to body_cost_vec; add\n+\tvect_body argument to calls to record_stmt_cost.\n+\t(vect_model_load_cost): Change parameter list; rename stmt_cost_vec to\n+\tbody_cost_vec; add vect_body argument to calls to record_stmt_cost;\n+\tremove call to stmt_vinfo_set_outside_of_loop_cost.\n+\t(vect_get_load_cost): Change parameter list; rename stmt_cost_vec to\n+\tbody_cost_vec; add vect_body argument to calls to record_stmt_cost;\n+\tcall record_stmt_cost for prologue costs.\n+\t(vectorizable_store): Change argument list for call to\n+\tvect_model_store_cost.\n+\t(vectorizable_load): Change argument list for call to\n+\tvect_model_load_cost.\n+\t(new_stmt_vec_info): Remove assignment to\n+\tSTMT_VINFO_OUTSIDE_OF_LOOP_COST.\n+\t* config/spu/spu.c (spu_init_cost): Add prologue and epilogue costs.\n+\t(spu_add_stmt_cost): Likewise; also handle NULL stmt_info.\n+\t(spu_finish_cost): Add prologue and epilogue costs.\n+\t* config/i386/i386.c (i386_init_cost): Add prologue and epilogue costs.\n+\t(i386_add_stmt_cost): Likewise; also handle NULL stmt_info.\n+\t(i386_finish_cost): Add prologue and epilogue costs.\n+\t* config/rs6000/rs6000.c (rs6000_init_cost): Add prologue and epilogue\n+\tcosts.\n+\t(rs6000_add_stmt_cost): Likewise; also handle NULL stmt_info.\n+\t(rs6000_finish_cost): Add prologue and epilogue costs.\n+\t* tree-vect-slp.c (vect_free_slp_instance): Rename\n+\tSLP_INSTANCE_STMT_COST_VEC to SLP_INSTANCE_BODY_COST_VEC.\n+\t(vect_create_new_slp_node): Remove assignment to\n+\tSLP_TREE_OUTSIDE_OF_LOOP_COST.\n+\t(vect_get_and_check_slp_defs): Change parameter list; change argument\n+\tlists to calls to vect_model_store_cost and vect_model_simple_cost.\n+\t(vect_build_slp_tree): Change parameter list; change argument lists\n+\tto calls to vect_model_load_cost, vect_get_and_check_slp_defs, and\n+\trecursive self-calls; remove setting of outside_cost from\n+\tSLP_TREE_OUTSIDE_OF_LOOP_COST; add vect_body argument to call to\n+\trecord_stmt_cost.\n+\t(vect_analyze_slp_instance): Rename stmt_cost_vec to body_cost_vec;\n+\trename SLP_INSTANCE_STMT_COST_VEC to SLP_INSTANCE_BODY_COST_VEC;\n+\tremove assignment to SLP_INSTANCE_OUTSIDE_OF_LOOP_COST; record SLP\n+\tprologue costs.\n+\t(vect_bb_vectorization_profitable_p): Rename stmt_cost_vec to\n+\tbody_cost_vec; handle null ci->stmt; add vect_body argument to call\n+\tto add_stmt_cost; simplify calls to targetm.vectorize.\n+\tbuiltin_vectorization_cost; return vec_prologue_cost and\n+\tvec_epilogue_cost from finish_cost.\n+\t(vect_update_slp_costs_according_to_vf): Rename stmt_cost_vec to\n+\tbody_cost_vec; add vect_body argument to call to add_stmt_cost.\n+\n 2012-07-24  Richard Henderson  <rth@redhat.com>\n \n \t* system.h (FIXUNS_TRUNC_LIKE_FIX_TRUNC): Poison."}, {"sha": "4b9ddb0044034d18314d88360c70f07334c2a63e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -40119,44 +40119,49 @@ ix86_autovectorize_vector_sizes (void)\n static void *\n ix86_init_cost (struct loop *loop_info ATTRIBUTE_UNUSED)\n {\n-  unsigned *cost = XNEW (unsigned);\n-  *cost = 0;\n+  unsigned *cost = XNEWVEC (unsigned, 3);\n+  cost[vect_prologue] = cost[vect_body] = cost[vect_epilogue] = 0;\n   return cost;\n }\n \n /* Implement targetm.vectorize.add_stmt_cost.  */\n \n static unsigned\n ix86_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n-\t\t    struct _stmt_vec_info *stmt_info, int misalign)\n+\t\t    struct _stmt_vec_info *stmt_info, int misalign,\n+\t\t    enum vect_cost_model_location where)\n {\n   unsigned *cost = (unsigned *) data;\n   unsigned retval = 0;\n \n   if (flag_vect_cost_model)\n     {\n-      tree vectype = stmt_vectype (stmt_info);\n+      tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n       int stmt_cost = ix86_builtin_vectorization_cost (kind, vectype, misalign);\n \n       /* Statements in an inner loop relative to the loop being\n \t vectorized are weighted more heavily.  The value here is\n \t arbitrary and could potentially be improved with analysis.  */\n-      if (stmt_in_inner_loop_p (stmt_info))\n+      if (where == vect_body && stmt_info && stmt_in_inner_loop_p (stmt_info))\n \tcount *= 50;  /* FIXME.  */\n \n       retval = (unsigned) (count * stmt_cost);\n-      *cost += retval;\n+      cost[where] += retval;\n     }\n \n   return retval;\n }\n \n /* Implement targetm.vectorize.finish_cost.  */\n \n-static unsigned\n-ix86_finish_cost (void *data)\n+static void\n+ix86_finish_cost (void *data, unsigned *prologue_cost,\n+\t\t  unsigned *body_cost, unsigned *epilogue_cost)\n {\n-  return *((unsigned *) data);\n+  unsigned *cost = (unsigned *) data;\n+  *prologue_cost = cost[vect_prologue];\n+  *body_cost     = cost[vect_body];\n+  *epilogue_cost = cost[vect_epilogue];\n }\n \n /* Implement targetm.vectorize.destroy_cost_data.  */"}, {"sha": "fe7c4d7908715263a807ba5e80d67ab80b6f7d40", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -3525,44 +3525,49 @@ rs6000_preferred_simd_mode (enum machine_mode mode)\n static void *\n rs6000_init_cost (struct loop *loop_info ATTRIBUTE_UNUSED)\n {\n-  unsigned *cost = XNEW (unsigned);\n-  *cost = 0;\n+  unsigned *cost = XNEWVEC (unsigned, 3);\n+  cost[vect_prologue] = cost[vect_body] = cost[vect_epilogue] = 0;\n   return cost;\n }\n \n /* Implement targetm.vectorize.add_stmt_cost.  */\n \n static unsigned\n rs6000_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n-\t\t      struct _stmt_vec_info *stmt_info, int misalign)\n+\t\t      struct _stmt_vec_info *stmt_info, int misalign,\n+\t\t      enum vect_cost_model_location where)\n {\n   unsigned *cost = (unsigned *) data;\n   unsigned retval = 0;\n \n   if (flag_vect_cost_model)\n     {\n-      tree vectype = stmt_vectype (stmt_info);\n+      tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n       int stmt_cost = rs6000_builtin_vectorization_cost (kind, vectype,\n \t\t\t\t\t\t\t misalign);\n       /* Statements in an inner loop relative to the loop being\n \t vectorized are weighted more heavily.  The value here is\n \t arbitrary and could potentially be improved with analysis.  */\n-      if (stmt_in_inner_loop_p (stmt_info))\n+      if (where == vect_body && stmt_info && stmt_in_inner_loop_p (stmt_info))\n \tcount *= 50;  /* FIXME.  */\n \n       retval = (unsigned) (count * stmt_cost);\n-      *cost += retval;\n+      cost[where] += retval;\n     }\n \n   return retval;\n }\n \n /* Implement targetm.vectorize.finish_cost.  */\n \n-static unsigned\n-rs6000_finish_cost (void *data)\n+static void\n+rs6000_finish_cost (void *data, unsigned *prologue_cost,\n+\t\t    unsigned *body_cost, unsigned *epilogue_cost)\n {\n-  return *((unsigned *) data);\n+  unsigned *cost = (unsigned *) data;\n+  *prologue_cost = cost[vect_prologue];\n+  *body_cost     = cost[vect_body];\n+  *epilogue_cost = cost[vect_epilogue];\n }\n \n /* Implement targetm.vectorize.destroy_cost_data.  */"}, {"sha": "cdae4d861b1a730f5b031f872eec5daa3ba9fa58", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -6623,44 +6623,49 @@ spu_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n static void *\n spu_init_cost (struct loop *loop_info ATTRIBUTE_UNUSED)\n {\n-  unsigned *cost = XNEW (unsigned);\n-  *cost = 0;\n+  unsigned *cost = XNEWVEC (unsigned, 3);\n+  cost[vect_prologue] = cost[vect_body] = cost[vect_epilogue] = 0;\n   return cost;\n }\n \n /* Implement targetm.vectorize.add_stmt_cost.  */\n \n static unsigned\n spu_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n-\t\t   struct _stmt_vec_info *stmt_info, int misalign)\n+\t\t   struct _stmt_vec_info *stmt_info, int misalign,\n+\t\t   enum vect_cost_model_location where)\n {\n   unsigned *cost = (unsigned *) data;\n   unsigned retval = 0;\n \n   if (flag_vect_cost_model)\n     {\n-      tree vectype = stmt_vectype (stmt_info);\n+      tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n       int stmt_cost = spu_builtin_vectorization_cost (kind, vectype, misalign);\n \n       /* Statements in an inner loop relative to the loop being\n \t vectorized are weighted more heavily.  The value here is\n \t arbitrary and could potentially be improved with analysis.  */\n-      if (stmt_in_inner_loop_p (stmt_info))\n+      if (where == vect_body && stmt_info && stmt_in_inner_loop_p (stmt_info))\n \tcount *= 50;  /* FIXME.  */\n \n       retval = (unsigned) (count * stmt_cost);\n-      *cost += retval;\n+      cost[where] += retval;\n     }\n \n   return retval;\n }\n \n /* Implement targetm.vectorize.finish_cost.  */\n \n-static unsigned\n-spu_finish_cost (void *data)\n+static void\n+spu_finish_cost (void *data, unsigned *prologue_cost,\n+\t\t unsigned *body_cost, unsigned *epilogue_cost)\n {\n-  return *((unsigned *) data);\n+  unsigned *cost = (unsigned *) data;\n+  *prologue_cost = cost[vect_prologue];\n+  *body_cost     = cost[vect_body];\n+  *epilogue_cost = cost[vect_epilogue];\n }\n \n /* Implement targetm.vectorize.destroy_cost_data.  */"}, {"sha": "d1a27f8015728b960a42665c2aae90d76fb497a8", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -5771,15 +5771,15 @@ The default is zero which means to not iterate over other vector sizes.\n @end deftypefn\n \n @deftypefn {Target Hook} {void *} TARGET_VECTORIZE_INIT_COST (struct loop *@var{loop_info})\n-This hook should initialize target-specific data structures in preparation for modeling the costs of vectorizing a loop or basic block.  The default allocates an unsigned integer for accumulating a single cost.  If @var{loop_info} is non-NULL, it identifies the loop being vectorized; otherwise a single block is being vectorized.\n+This hook should initialize target-specific data structures in preparation for modeling the costs of vectorizing a loop or basic block.  The default allocates three unsigned integers for accumulating costs for the prologue, body, and epilogue of the loop or basic block.  If @var{loop_info} is non-NULL, it identifies the loop being vectorized; otherwise a single block is being vectorized.\n @end deftypefn\n \n-@deftypefn {Target Hook} unsigned TARGET_VECTORIZE_ADD_STMT_COST (void *@var{data}, int @var{count}, enum vect_cost_for_stmt @var{kind}, struct _stmt_vec_info *@var{stmt_info}, int @var{misalign})\n-This hook should update the target-specific @var{data} in response to adding @var{count} copies of the given @var{kind} of statement to the body of a loop or basic block.  The default adds the builtin vectorizer cost for the copies of the statement to the accumulator, and returns the amount added.  The return value should be viewed as a tentative cost that may later be overridden.\n+@deftypefn {Target Hook} unsigned TARGET_VECTORIZE_ADD_STMT_COST (void *@var{data}, int @var{count}, enum vect_cost_for_stmt @var{kind}, struct _stmt_vec_info *@var{stmt_info}, int @var{misalign}, enum vect_cost_model_location @var{where})\n+This hook should update the target-specific @var{data} in response to adding @var{count} copies of the given @var{kind} of statement to a loop or basic block.  The default adds the builtin vectorizer cost for the copies of the statement to the accumulator specified by @var{where}, (the prologue, body, or epilogue) and returns the amount added.  The return value should be viewed as a tentative cost that may later be revised.\n @end deftypefn\n \n-@deftypefn {Target Hook} unsigned TARGET_VECTORIZE_FINISH_COST (void *@var{data})\n-This hook should complete calculations of the cost of vectorizing a loop or basic block based on @var{data}, and return that cost as an unsigned integer.  The default returns the value of the accumulator.\n+@deftypefn {Target Hook} void TARGET_VECTORIZE_FINISH_COST (void *@var{data}, unsigned *@var{prologue_cost}, unsigned *@var{body_cost}, unsigned *@var{epilogue_cost})\n+This hook should complete calculations of the cost of vectorizing a loop or basic block based on @var{data}, and return the prologue, body, and epilogue costs as unsigned integers.  The default returns the value of the three accumulators.\n @end deftypefn\n \n @deftypefn {Target Hook} void TARGET_VECTORIZE_DESTROY_COST_DATA (void *@var{data})"}, {"sha": "c172673811ee60ead51927d9cd38d201d321ba61", "filename": "gcc/target.def", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -1054,38 +1054,43 @@ DEFHOOK\n (init_cost,\n  \"This hook should initialize target-specific data structures in preparation \"\n  \"for modeling the costs of vectorizing a loop or basic block.  The default \"\n- \"allocates an unsigned integer for accumulating a single cost.  \"\n- \"If @var{loop_info} is non-NULL, it identifies the loop being vectorized; \"\n- \"otherwise a single block is being vectorized.\",\n+ \"allocates three unsigned integers for accumulating costs for the prologue, \"\n+ \"body, and epilogue of the loop or basic block.  If @var{loop_info} is \"\n+ \"non-NULL, it identifies the loop being vectorized; otherwise a single block \"\n+ \"is being vectorized.\",\n  void *,\n  (struct loop *loop_info),\n  default_init_cost)\n \n /* Target function to record N statements of the given kind using the\n-   given vector type within the cost model data for the current loop\n-   or block.  */\n+   given vector type within the cost model data for the current loop or\n+    block.  */\n DEFHOOK\n (add_stmt_cost,\n  \"This hook should update the target-specific @var{data} in response to \"\n- \"adding @var{count} copies of the given @var{kind} of statement to the \"\n- \"body of a loop or basic block.  The default adds the builtin vectorizer \"\n- \"cost for the copies of the statement to the accumulator, and returns \"\n- \"the amount added.  The return value should be viewed as a tentative \"\n- \"cost that may later be overridden.\",\n+ \"adding @var{count} copies of the given @var{kind} of statement to a \"\n+ \"loop or basic block.  The default adds the builtin vectorizer cost for \"\n+ \"the copies of the statement to the accumulator specified by @var{where}, \"\n+ \"(the prologue, body, or epilogue) and returns the amount added.  The \"\n+ \"return value should be viewed as a tentative cost that may later be \"\n+ \"revised.\",\n  unsigned,\n  (void *data, int count, enum vect_cost_for_stmt kind,\n-  struct _stmt_vec_info *stmt_info, int misalign),\n+  struct _stmt_vec_info *stmt_info, int misalign,\n+  enum vect_cost_model_location where),\n  default_add_stmt_cost)\n \n /* Target function to calculate the total cost of the current vectorized\n    loop or block.  */\n DEFHOOK\n (finish_cost,\n  \"This hook should complete calculations of the cost of vectorizing a loop \"\n- \"or basic block based on @var{data}, and return that cost as an unsigned \"\n- \"integer.  The default returns the value of the accumulator.\",\n- unsigned,\n- (void *data),\n+ \"or basic block based on @var{data}, and return the prologue, body, and \"\n+ \"epilogue costs as unsigned integers.  The default returns the value of \"\n+ \"the three accumulators.\",\n+ void,\n+ (void *data, unsigned *prologue_cost, unsigned *body_cost,\n+  unsigned *epilogue_cost),\n  default_finish_cost)\n \n /* Function to delete target-specific cost modeling data.  */"}, {"sha": "3a039d3c5012aeac41f76dad7521ee3abd8afdd0", "filename": "gcc/target.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -157,6 +157,14 @@ enum vect_cost_for_stmt\n   vec_construct\n };\n \n+/* Separate locations for which the vectorizer cost model should\n+   track costs.  */\n+enum vect_cost_model_location {\n+  vect_prologue = 0,\n+  vect_body = 1,\n+  vect_epilogue = 2\n+};\n+\n /* The target structure.  This holds all the backend hooks.  */\n #define DEFHOOKPOD(NAME, DOC, TYPE, INIT) TYPE NAME;\n #define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) TYPE (* NAME) PARAMS;"}, {"sha": "8993659a9ecea2864c076c5884eaefc7d1c51be1", "filename": "gcc/targhooks.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -996,54 +996,58 @@ default_autovectorize_vector_sizes (void)\n   return 0;\n }\n \n-/* By default, the cost model just accumulates the inside_loop costs for\n-   a vectorized loop or block.  So allocate an unsigned int, set it to\n-   zero, and return its address.  */\n+/* By default, the cost model accumulates three separate costs (prologue,\n+   loop body, and epilogue) for a vectorized loop or block.  So allocate an\n+   array of three unsigned ints, set it to zero, and return its address.  */\n \n void *\n default_init_cost (struct loop *loop_info ATTRIBUTE_UNUSED)\n {\n-  unsigned *cost = XNEW (unsigned);\n-  *cost = 0;\n+  unsigned *cost = XNEWVEC (unsigned, 3);\n+  cost[vect_prologue] = cost[vect_body] = cost[vect_epilogue] = 0;\n   return cost;\n }\n \n /* By default, the cost model looks up the cost of the given statement\n    kind and mode, multiplies it by the occurrence count, accumulates\n-   it into the cost, and returns the cost added.  */\n+   it into the cost specified by WHERE, and returns the cost added.  */\n \n unsigned\n default_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n-\t\t       struct _stmt_vec_info *stmt_info, int misalign)\n+\t\t       struct _stmt_vec_info *stmt_info, int misalign,\n+\t\t       enum vect_cost_model_location where)\n {\n   unsigned *cost = (unsigned *) data;\n   unsigned retval = 0;\n \n   if (flag_vect_cost_model)\n     {\n-      tree vectype = stmt_vectype (stmt_info);\n+      tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n       int stmt_cost = default_builtin_vectorization_cost (kind, vectype,\n \t\t\t\t\t\t\t  misalign);\n       /* Statements in an inner loop relative to the loop being\n \t vectorized are weighted more heavily.  The value here is\n \t arbitrary and could potentially be improved with analysis.  */\n-      if (stmt_in_inner_loop_p (stmt_info))\n+      if (where == vect_body && stmt_info && stmt_in_inner_loop_p (stmt_info))\n \tcount *= 50;  /* FIXME.  */\n \n       retval = (unsigned) (count * stmt_cost);\n-      *cost += retval;\n+      cost[where] += retval;\n     }\n \n   return retval;\n }\n \n-/* By default, the cost model just returns the accumulated\n-   inside_loop cost.  */\n+/* By default, the cost model just returns the accumulated costs.  */\n \n-unsigned\n-default_finish_cost (void *data)\n+void\n+default_finish_cost (void *data, unsigned *prologue_cost,\n+\t\t     unsigned *body_cost, unsigned *epilogue_cost)\n {\n-  return *((unsigned *) data);\n+  unsigned *cost = (unsigned *) data;\n+  *prologue_cost = cost[vect_prologue];\n+  *body_cost     = cost[vect_body];\n+  *epilogue_cost = cost[vect_epilogue];\n }\n \n /* Free the cost data.  */"}, {"sha": "f6e03e7b4a769ec32f70c11aa1b18a5732af0416", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -92,8 +92,9 @@ extern enum machine_mode default_preferred_simd_mode (enum machine_mode mode);\n extern unsigned int default_autovectorize_vector_sizes (void);\n extern void *default_init_cost (struct loop *);\n extern unsigned default_add_stmt_cost (void *, int, enum vect_cost_for_stmt,\n-\t\t\t\t       struct _stmt_vec_info *, int);\n-extern unsigned default_finish_cost (void *);\n+\t\t\t\t       struct _stmt_vec_info *, int,\n+\t\t\t\t       enum vect_cost_model_location);\n+extern void default_finish_cost (void *, unsigned *, unsigned *, unsigned *);\n extern void default_destroy_cost_data (void *);\n \n /* These are here, and not in hooks.[ch], because not all users of"}, {"sha": "81a9521008467ba7bae730011f8940f73d9c167a", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -1212,30 +1212,28 @@ vector_alignment_reachable_p (struct data_reference *dr)\n \n /* Calculate the cost of the memory access represented by DR.  */\n \n-static stmt_vector_for_cost\n+static void\n vect_get_data_access_cost (struct data_reference *dr,\n                            unsigned int *inside_cost,\n-                           unsigned int *outside_cost)\n+                           unsigned int *outside_cost,\n+\t\t\t   stmt_vector_for_cost *body_cost_vec)\n {\n   gimple stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   int nunits = TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   int ncopies = vf / nunits;\n-  stmt_vector_for_cost stmt_cost_vec = VEC_alloc (stmt_info_for_cost, heap, 2);\n \n   if (DR_IS_READ (dr))\n-    vect_get_load_cost (dr, ncopies, true, inside_cost,\n-\t\t\toutside_cost, &stmt_cost_vec);\n+    vect_get_load_cost (dr, ncopies, true, inside_cost, outside_cost,\n+\t\t\tNULL, body_cost_vec, false);\n   else\n-    vect_get_store_cost (dr, ncopies, inside_cost, &stmt_cost_vec);\n+    vect_get_store_cost (dr, ncopies, inside_cost, body_cost_vec);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_get_data_access_cost: inside_cost = %d, \"\n              \"outside_cost = %d.\", *inside_cost, *outside_cost);\n-\n-  return stmt_cost_vec;\n }\n \n \n@@ -1328,7 +1326,12 @@ vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   struct data_reference *dr;\n-  stmt_vector_for_cost stmt_cost_vec = NULL;\n+  stmt_vector_for_cost prologue_cost_vec, body_cost_vec, epilogue_cost_vec;\n+  int single_iter_cost;\n+\n+  prologue_cost_vec = VEC_alloc (stmt_info_for_cost, heap, 2);\n+  body_cost_vec     = VEC_alloc (stmt_info_for_cost, heap, 2);\n+  epilogue_cost_vec = VEC_alloc (stmt_info_for_cost, heap, 2);\n \n   FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     {\n@@ -1342,23 +1345,35 @@ vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n \n       save_misalignment = DR_MISALIGNMENT (dr);\n       vect_update_misalignment_for_peel (dr, elem->dr, elem->npeel);\n-      stmt_cost_vec = vect_get_data_access_cost (dr, &inside_cost,\n-\t\t\t\t\t\t &outside_cost);\n+      vect_get_data_access_cost (dr, &inside_cost, &outside_cost,\n+\t\t\t\t &body_cost_vec);\n       SET_DR_MISALIGNMENT (dr, save_misalignment);\n     }\n \n-  outside_cost += vect_get_known_peeling_cost (loop_vinfo, elem->npeel, &dummy,\n-                         vect_get_single_scalar_iteration_cost (loop_vinfo));\n+  single_iter_cost = vect_get_single_scalar_iteration_cost (loop_vinfo);\n+  outside_cost += vect_get_known_peeling_cost (loop_vinfo, elem->npeel,\n+\t\t\t\t\t       &dummy, single_iter_cost,\n+\t\t\t\t\t       &prologue_cost_vec,\n+\t\t\t\t\t       &epilogue_cost_vec);\n+\n+  /* Prologue and epilogue costs are added to the target model later.\n+     These costs depend only on the scalar iteration cost, the\n+     number of peeling iterations finally chosen, and the number of\n+     misaligned statements.  So discard the information found here.  */\n+  VEC_free (stmt_info_for_cost, heap, prologue_cost_vec);\n+  VEC_free (stmt_info_for_cost, heap, epilogue_cost_vec);\n \n   if (inside_cost < min->inside_cost\n       || (inside_cost == min->inside_cost && outside_cost < min->outside_cost))\n     {\n       min->inside_cost = inside_cost;\n       min->outside_cost = outside_cost;\n-      min->stmt_cost_vec = stmt_cost_vec;\n+      min->body_cost_vec = body_cost_vec;\n       min->peel_info.dr = elem->dr;\n       min->peel_info.npeel = elem->npeel;\n     }\n+  else\n+    VEC_free (stmt_info_for_cost, heap, body_cost_vec);\n \n   return 1;\n }\n@@ -1371,12 +1386,12 @@ vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n static struct data_reference *\n vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n                                        unsigned int *npeel,\n-\t\t\t\t       stmt_vector_for_cost *stmt_cost_vec)\n+\t\t\t\t       stmt_vector_for_cost *body_cost_vec)\n {\n    struct _vect_peel_extended_info res;\n \n    res.peel_info.dr = NULL;\n-   res.stmt_cost_vec = NULL;\n+   res.body_cost_vec = NULL;\n \n    if (flag_vect_cost_model)\n      {\n@@ -1393,7 +1408,7 @@ vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n      }\n \n    *npeel = res.peel_info.npeel;\n-   *stmt_cost_vec = res.stmt_cost_vec;\n+   *body_cost_vec = res.body_cost_vec;\n    return res.peel_info.dr;\n }\n \n@@ -1510,7 +1525,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   unsigned possible_npeel_number = 1;\n   tree vectype;\n   unsigned int nelements, mis, same_align_drs_max = 0;\n-  stmt_vector_for_cost stmt_cost_vec = NULL;\n+  stmt_vector_for_cost body_cost_vec = NULL;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_enhance_data_refs_alignment ===\");\n@@ -1714,11 +1729,14 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           unsigned int store_inside_cost = 0, store_outside_cost = 0;\n           unsigned int load_inside_penalty = 0, load_outside_penalty = 0;\n           unsigned int store_inside_penalty = 0, store_outside_penalty = 0;\n+\t  stmt_vector_for_cost dummy = VEC_alloc (stmt_info_for_cost, heap, 2);\n+\n+          vect_get_data_access_cost (dr0, &load_inside_cost, &load_outside_cost,\n+\t\t\t\t     &dummy);\n+          vect_get_data_access_cost (first_store, &store_inside_cost,\n+\t\t\t\t     &store_outside_cost, &dummy);\n \n-          (void) vect_get_data_access_cost (dr0, &load_inside_cost,\n-\t\t\t\t\t    &load_outside_cost);\n-          (void) vect_get_data_access_cost (first_store, &store_inside_cost,\n-\t\t\t\t\t    &store_outside_cost);\n+\t  VEC_free (stmt_info_for_cost, heap, dummy);\n \n           /* Calculate the penalty for leaving FIRST_STORE unaligned (by\n              aligning the load DR0).  */\n@@ -1783,7 +1801,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       /* Choose the best peeling from the hash table.  */\n       dr0 = vect_peeling_hash_choose_best_peeling (loop_vinfo, &npeel,\n-\t\t\t\t\t\t   &stmt_cost_vec);\n+\t\t\t\t\t\t   &body_cost_vec);\n       if (!dr0 || !npeel)\n         do_peeling = false;\n     }\n@@ -1868,6 +1886,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       if (do_peeling)\n         {\n \t  stmt_info_for_cost *si;\n+\t  void *data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n \n           /* (1.2) Update the DR_MISALIGNMENT of each data reference DR_i.\n              If the misalignment of DR_i is identical to that of dr0 then set\n@@ -1895,13 +1914,16 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  /* We've delayed passing the inside-loop peeling costs to the\n \t     target cost model until we were sure peeling would happen.\n \t     Do so now.  */\n-\t  if (stmt_cost_vec)\n+\t  if (body_cost_vec)\n \t    {\n-\t      FOR_EACH_VEC_ELT (stmt_info_for_cost, stmt_cost_vec, i, si)\n-\t\t(void) add_stmt_cost (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo),\n-\t\t\t\t      si->count, si->kind,\n-\t\t\t\t      vinfo_for_stmt (si->stmt), si->misalign);\n-\t      VEC_free (stmt_info_for_cost, heap, stmt_cost_vec);\n+\t      FOR_EACH_VEC_ELT (stmt_info_for_cost, body_cost_vec, i, si)\n+\t\t{\n+\t\t  struct _stmt_vec_info *stmt_info\n+\t\t    = si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n+\t\t  (void) add_stmt_cost (data, si->count, si->kind, stmt_info,\n+\t\t\t\t\tsi->misalign, vect_body);\n+\t\t}\n+\t      VEC_free (stmt_info_for_cost, heap, body_cost_vec);\n \t    }\n \n \t  stat = vect_verify_datarefs_alignment (loop_vinfo, NULL);"}, {"sha": "d9094679dd28e6cbcb811b5d55475f761506750c", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 121, "deletions": 113, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -2440,9 +2440,11 @@ vect_get_single_scalar_iteration_cost (loop_vec_info loop_vinfo)\n int\n vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n                              int *peel_iters_epilogue,\n-                             int scalar_single_iter_cost)\n+                             int scalar_single_iter_cost,\n+\t\t\t     stmt_vector_for_cost *prologue_cost_vec,\n+\t\t\t     stmt_vector_for_cost *epilogue_cost_vec)\n {\n-  int peel_guard_costs = 0;\n+  int retval = 0;\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n@@ -2455,7 +2457,8 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n \n       /* If peeled iterations are known but number of scalar loop\n          iterations are unknown, count a taken branch per peeled loop.  */\n-      peel_guard_costs =  2 * vect_get_stmt_cost (cond_branch_taken);\n+      retval = record_stmt_cost (prologue_cost_vec, 2, cond_branch_taken,\n+\t\t\t\t NULL, 0, vect_prologue);\n     }\n   else\n     {\n@@ -2469,9 +2472,15 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n         *peel_iters_epilogue = vf;\n     }\n \n-   return (peel_iters_prologue * scalar_single_iter_cost)\n-            + (*peel_iters_epilogue * scalar_single_iter_cost)\n-           + peel_guard_costs;\n+  if (peel_iters_prologue)\n+    retval += record_stmt_cost (prologue_cost_vec,\n+\t\t\t\tpeel_iters_prologue * scalar_single_iter_cost,\n+\t\t\t\tscalar_stmt, NULL, 0, vect_prologue);\n+  if (*peel_iters_epilogue)\n+    retval += record_stmt_cost (epilogue_cost_vec,\n+\t\t\t\t*peel_iters_epilogue * scalar_single_iter_cost,\n+\t\t\t\tscalar_stmt, NULL, 0, vect_epilogue);\n+  return retval;\n }\n \n /* Function vect_estimate_min_profitable_iters\n@@ -2486,22 +2495,18 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n int\n vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n {\n-  int i;\n   int min_profitable_iters;\n   int peel_iters_prologue;\n   int peel_iters_epilogue;\n-  int vec_inside_cost = 0;\n+  unsigned vec_inside_cost = 0;\n   int vec_outside_cost = 0;\n+  unsigned vec_prologue_cost = 0;\n+  unsigned vec_epilogue_cost = 0;\n   int scalar_single_iter_cost = 0;\n   int scalar_outside_cost = 0;\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n-  int nbbs = loop->num_nodes;\n   int npeel = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n-  int peel_guard_costs = 0;\n-  VEC (slp_instance, heap) *slp_instances;\n-  slp_instance instance;\n+  void *target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n \n   /* Cost model disabled.  */\n   if (!flag_vect_cost_model)\n@@ -2515,8 +2520,10 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo))\n     {\n       /*  FIXME: Make cost depend on complexity of individual check.  */\n-      vec_outside_cost +=\n-\tVEC_length (gimple, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo));\n+      unsigned len = VEC_length (gimple,\n+\t\t\t\t LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo));\n+      (void) add_stmt_cost (target_cost_data, len, vector_stmt, NULL, 0,\n+\t\t\t    vect_prologue);\n       if (vect_print_dump_info (REPORT_COST))\n         fprintf (vect_dump, \"cost model: Adding cost of checks for loop \"\n                  \"versioning to treat misalignment.\\n\");\n@@ -2526,16 +2533,18 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n     {\n       /*  FIXME: Make cost depend on complexity of individual check.  */\n-      vec_outside_cost +=\n-        VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo));\n+      unsigned len = VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo));\n+      (void) add_stmt_cost (target_cost_data, len, vector_stmt, NULL, 0,\n+\t\t\t    vect_prologue);\n       if (vect_print_dump_info (REPORT_COST))\n         fprintf (vect_dump, \"cost model: Adding cost of checks for loop \"\n                  \"versioning aliasing.\\n\");\n     }\n \n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n       || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n-    vec_outside_cost += vect_get_stmt_cost (cond_branch_taken); \n+    (void) add_stmt_cost (target_cost_data, 1, cond_branch_taken, NULL, 0,\n+\t\t\t  vect_prologue);\n \n   /* Count statements in scalar loop.  Using this as scalar cost for a single\n      iteration for now.\n@@ -2545,52 +2554,6 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      TODO: Consider assigning different costs to different scalar\n      statements.  */\n \n-  for (i = 0; i < nbbs; i++)\n-    {\n-      gimple_stmt_iterator si;\n-      basic_block bb = bbs[i];\n-\n-      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-\t{\n-\t  gimple stmt = gsi_stmt (si);\n-\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\n-\t  if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n-\t    {\n-\t      stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n-\t      stmt_info = vinfo_for_stmt (stmt);\n-\t    }\n-\n-\t  /* Skip stmts that are not vectorized inside the loop.  */\n-\t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n-\t      && (!STMT_VINFO_LIVE_P (stmt_info)\n-                 || !VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info))))\n-\t    continue;\n-\n-\t  /* FIXME: for stmts in the inner-loop in outer-loop vectorization,\n-\t     some of the \"outside\" costs are generated inside the outer-loop.  */\n-\t  vec_outside_cost += STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info);\n-          if (is_pattern_stmt_p (stmt_info)\n-\t      && STMT_VINFO_PATTERN_DEF_SEQ (stmt_info))\n-            {\n-\t      gimple_stmt_iterator gsi;\n-\t      \n-\t      for (gsi = gsi_start (STMT_VINFO_PATTERN_DEF_SEQ (stmt_info));\n-\t\t   !gsi_end_p (gsi); gsi_next (&gsi))\n-                {\n-                  gimple pattern_def_stmt = gsi_stmt (gsi);\n-                  stmt_vec_info pattern_def_stmt_info\n-\t\t    = vinfo_for_stmt (pattern_def_stmt);\n-                  if (STMT_VINFO_RELEVANT_P (pattern_def_stmt_info)\n-                      || STMT_VINFO_LIVE_P (pattern_def_stmt_info))\n-\t\t    vec_outside_cost\n-\t\t      += STMT_VINFO_OUTSIDE_OF_LOOP_COST\n-\t\t        (pattern_def_stmt_info);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n   scalar_single_iter_cost = vect_get_single_scalar_iteration_cost (loop_vinfo);\n \n   /* Add additional cost for the peeled instructions in prologue and epilogue\n@@ -2621,18 +2584,54 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n          branch per peeled loop. Even if scalar loop iterations are known,\n          vector iterations are not known since peeled prologue iterations are\n          not known. Hence guards remain the same.  */\n-      peel_guard_costs +=  2 * (vect_get_stmt_cost (cond_branch_taken)\n-                                + vect_get_stmt_cost (cond_branch_not_taken));\n-      vec_outside_cost += (peel_iters_prologue * scalar_single_iter_cost)\n-                           + (peel_iters_epilogue * scalar_single_iter_cost)\n-                           + peel_guard_costs;\n+      (void) add_stmt_cost (target_cost_data, 2, cond_branch_taken,\n+\t\t\t    NULL, 0, vect_prologue);\n+      (void) add_stmt_cost (target_cost_data, 2, cond_branch_not_taken,\n+\t\t\t    NULL, 0, vect_prologue);\n+      /* FORNOW: Don't attempt to pass individual scalar instructions to\n+\t the model; just assume linear cost for scalar iterations.  */\n+      (void) add_stmt_cost (target_cost_data,\n+\t\t\t    peel_iters_prologue * scalar_single_iter_cost,\n+\t\t\t    scalar_stmt, NULL, 0, vect_prologue);\n+      (void) add_stmt_cost (target_cost_data, \n+\t\t\t    peel_iters_epilogue * scalar_single_iter_cost,\n+\t\t\t    scalar_stmt, NULL, 0, vect_epilogue);\n     }\n   else\n     {\n+      stmt_vector_for_cost prologue_cost_vec, epilogue_cost_vec;\n+      stmt_info_for_cost *si;\n+      int j;\n+      void *data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n+\n+      prologue_cost_vec = VEC_alloc (stmt_info_for_cost, heap, 2);\n+      epilogue_cost_vec = VEC_alloc (stmt_info_for_cost, heap, 2);\n       peel_iters_prologue = npeel;\n-      vec_outside_cost += vect_get_known_peeling_cost (loop_vinfo,\n-                                    peel_iters_prologue, &peel_iters_epilogue,\n-                                    scalar_single_iter_cost);\n+\n+      (void) vect_get_known_peeling_cost (loop_vinfo, peel_iters_prologue,\n+\t\t\t\t\t  &peel_iters_epilogue,\n+\t\t\t\t\t  scalar_single_iter_cost,\n+\t\t\t\t\t  &prologue_cost_vec,\n+\t\t\t\t\t  &epilogue_cost_vec);\n+\n+      FOR_EACH_VEC_ELT (stmt_info_for_cost, prologue_cost_vec, j, si)\n+\t{\n+\t  struct _stmt_vec_info *stmt_info\n+\t    = si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n+\t  (void) add_stmt_cost (data, si->count, si->kind, stmt_info,\n+\t\t\t\tsi->misalign, vect_prologue);\n+\t}\n+\n+      FOR_EACH_VEC_ELT (stmt_info_for_cost, epilogue_cost_vec, j, si)\n+\t{\n+\t  struct _stmt_vec_info *stmt_info\n+\t    = si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n+\t  (void) add_stmt_cost (data, si->count, si->kind, stmt_info,\n+\t\t\t\tsi->misalign, vect_epilogue);\n+\t}\n+\n+      VEC_free (stmt_info_for_cost, heap, prologue_cost_vec);\n+      VEC_free (stmt_info_for_cost, heap, epilogue_cost_vec);\n     }\n \n   /* FORNOW: The scalar outside cost is incremented in one of the\n@@ -2708,14 +2707,11 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \t}\n     }\n \n-  /* Add SLP costs.  */\n-  slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n-  FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n-    vec_outside_cost += SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (instance);\n+  /* Complete the target-specific cost calculations.  */\n+  finish_cost (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo), &vec_prologue_cost,\n+\t       &vec_inside_cost, &vec_epilogue_cost);\n \n-  /* Complete the target-specific cost calculation for the inside-of-loop\n-     costs.  */\n-  vec_inside_cost = finish_cost (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n+  vec_outside_cost = (int)(vec_prologue_cost + vec_epilogue_cost);\n   \n   /* Calculate number of iterations required to make the vector version\n      profitable, relative to the loop bodies only.  The following condition\n@@ -2727,7 +2723,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      PL_ITERS = prologue iterations, EP_ITERS= epilogue iterations\n      SOC = scalar outside cost for run time cost model check.  */\n \n-  if ((scalar_single_iter_cost * vf) > vec_inside_cost)\n+  if ((scalar_single_iter_cost * vf) > (int) vec_inside_cost)\n     {\n       if (vec_outside_cost <= 0)\n         min_profitable_iters = 1;\n@@ -2740,8 +2736,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n                                     - vec_inside_cost);\n \n           if ((scalar_single_iter_cost * vf * min_profitable_iters)\n-              <= ((vec_inside_cost * min_profitable_iters)\n-                  + ((vec_outside_cost - scalar_outside_cost) * vf)))\n+              <= (((int) vec_inside_cost * min_profitable_iters)\n+                  + (((int) vec_outside_cost - scalar_outside_cost) * vf)))\n             min_profitable_iters++;\n         }\n     }\n@@ -2761,8 +2757,10 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n       fprintf (vect_dump, \"Cost model analysis: \\n\");\n       fprintf (vect_dump, \"  Vector inside of loop cost: %d\\n\",\n \t       vec_inside_cost);\n-      fprintf (vect_dump, \"  Vector outside of loop cost: %d\\n\",\n-\t       vec_outside_cost);\n+      fprintf (vect_dump, \"  Vector prologue cost: %d\\n\",\n+\t       vec_prologue_cost);\n+      fprintf (vect_dump, \"  Vector epilogue cost: %d\\n\",\n+\t       vec_epilogue_cost);\n       fprintf (vect_dump, \"  Scalar iteration cost: %d\\n\",\n \t       scalar_single_iter_cost);\n       fprintf (vect_dump, \"  Scalar outside cost: %d\\n\", scalar_outside_cost);\n@@ -2803,7 +2801,7 @@ static bool\n vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \t\t\t   int ncopies)\n {\n-  int outer_cost = 0;\n+  int prologue_cost = 0, epilogue_cost = 0;\n   enum tree_code code;\n   optab optab;\n   tree vectype;\n@@ -2812,12 +2810,11 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   enum machine_mode mode;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  void *target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n \n   /* Cost of reduction op inside loop.  */\n-  unsigned inside_cost\n-    = add_stmt_cost (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo),\n-\t\t     ncopies, vector_stmt, stmt_info, 0);\n-\n+  unsigned inside_cost = add_stmt_cost (target_cost_data, ncopies, vector_stmt,\n+\t\t\t\t\tstmt_info, 0, vect_body);\n   stmt = STMT_VINFO_STMT (stmt_info);\n \n   switch (get_gimple_rhs_class (gimple_assign_rhs_code (stmt)))\n@@ -2859,7 +2856,8 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   code = gimple_assign_rhs_code (orig_stmt);\n \n   /* Add in cost for initial definition.  */\n-  outer_cost += vect_get_stmt_cost (scalar_to_vec);\n+  prologue_cost += add_stmt_cost (target_cost_data, 1, scalar_to_vec,\n+\t\t\t\t  stmt_info, 0, vect_prologue);\n \n   /* Determine cost of epilogue code.\n \n@@ -2869,8 +2867,12 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   if (!nested_in_vect_loop_p (loop, orig_stmt))\n     {\n       if (reduc_code != ERROR_MARK)\n-\touter_cost += vect_get_stmt_cost (vector_stmt) \n-                      + vect_get_stmt_cost (vec_to_scalar); \n+\t{\n+\t  epilogue_cost += add_stmt_cost (target_cost_data, 1, vector_stmt,\n+\t\t\t\t\t  stmt_info, 0, vect_epilogue);\n+\t  epilogue_cost += add_stmt_cost (target_cost_data, 1, vec_to_scalar,\n+\t\t\t\t\t  stmt_info, 0, vect_epilogue);\n+\t}\n       else\n \t{\n \t  int vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n@@ -2885,25 +2887,31 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \t  if (VECTOR_MODE_P (mode)\n \t      && optab_handler (optab, mode) != CODE_FOR_nothing\n \t      && optab_handler (vec_shr_optab, mode) != CODE_FOR_nothing)\n-\t    /* Final reduction via vector shifts and the reduction operator. Also\n-\t       requires scalar extract.  */\n-\t    outer_cost += ((exact_log2(nelements) * 2) \n-              * vect_get_stmt_cost (vector_stmt) \n-  \t      + vect_get_stmt_cost (vec_to_scalar));\n+\t    {\n+\t      /* Final reduction via vector shifts and the reduction operator.\n+\t\t Also requires scalar extract.  */\n+\t      epilogue_cost += add_stmt_cost (target_cost_data,\n+\t\t\t\t\t      exact_log2 (nelements) * 2,\n+\t\t\t\t\t      vector_stmt, stmt_info, 0,\n+\t\t\t\t\t      vect_epilogue);\n+\t      epilogue_cost += add_stmt_cost (target_cost_data, 1,\n+\t\t\t\t\t      vec_to_scalar, stmt_info, 0,\n+\t\t\t\t\t      vect_epilogue);\n+\t    }\t  \n \t  else\n-\t    /* Use extracts and reduction op for final reduction.  For N elements,\n-               we have N extracts and N-1 reduction ops.  */\n-\t    outer_cost += ((nelements + nelements - 1) \n-              * vect_get_stmt_cost (vector_stmt));\n+\t    /* Use extracts and reduction op for final reduction.  For N\n+\t       elements, we have N extracts and N-1 reduction ops.  */\n+\t    epilogue_cost += add_stmt_cost (target_cost_data, \n+\t\t\t\t\t    nelements + nelements - 1,\n+\t\t\t\t\t    vector_stmt, stmt_info, 0,\n+\t\t\t\t\t    vect_epilogue);\n \t}\n     }\n \n-  STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = outer_cost;\n-\n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_reduction_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", inside_cost,\n-             STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n+             \"prologue_cost = %d, epilogue_cost = %d .\", inside_cost,\n+\t     prologue_cost, epilogue_cost);\n \n   return true;\n }\n@@ -2917,20 +2925,20 @@ static void\n vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n {\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  void *target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n+  unsigned inside_cost, prologue_cost;\n \n   /* loop cost for vec_loop.  */\n-  unsigned inside_cost\n-    = add_stmt_cost (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo), ncopies,\n-\t\t     vector_stmt, stmt_info, 0);\n+  inside_cost = add_stmt_cost (target_cost_data, ncopies, vector_stmt,\n+\t\t\t       stmt_info, 0, vect_body);\n \n   /* prologue cost for vec_init and vec_step.  */\n-  STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info)  \n-    = 2 * vect_get_stmt_cost (scalar_to_vec);\n+  prologue_cost = add_stmt_cost (target_cost_data, 2, scalar_to_vec,\n+\t\t\t\t stmt_info, 0, vect_prologue);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_induction_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", inside_cost,\n-             STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n+             \"prologue_cost = %d .\", inside_cost, prologue_cost);\n }\n \n "}, {"sha": "79a7e3a39c9dd9dd11efaed9143f51411d099229", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 71, "deletions": 46, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -93,7 +93,7 @@ vect_free_slp_instance (slp_instance instance)\n   vect_free_slp_tree (SLP_INSTANCE_TREE (instance));\n   VEC_free (int, heap, SLP_INSTANCE_LOAD_PERMUTATION (instance));\n   VEC_free (slp_tree, heap, SLP_INSTANCE_LOADS (instance));\n-  VEC_free (stmt_info_for_cost, heap, SLP_INSTANCE_STMT_COST_VEC (instance));\n+  VEC_free (stmt_info_for_cost, heap, SLP_INSTANCE_BODY_COST_VEC (instance));\n }\n \n \n@@ -121,7 +121,6 @@ vect_create_new_slp_node (VEC (gimple, heap) *scalar_stmts)\n   SLP_TREE_SCALAR_STMTS (node) = scalar_stmts;\n   SLP_TREE_VEC_STMTS (node) = NULL;\n   SLP_TREE_CHILDREN (node) = VEC_alloc (slp_void_p, heap, nops);\n-  SLP_TREE_OUTSIDE_OF_LOOP_COST (node) = 0;\n \n   return node;\n }\n@@ -179,7 +178,8 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                              slp_tree slp_node, gimple stmt,\n \t\t\t     int ncopies_for_cost, bool first,\n                              VEC (slp_oprnd_info, heap) **oprnds_info,\n-\t\t\t     stmt_vector_for_cost *stmt_cost_vec)\n+\t\t\t     stmt_vector_for_cost *prologue_cost_vec,\n+\t\t\t     stmt_vector_for_cost *body_cost_vec)\n {\n   tree oprnd;\n   unsigned int i, number_of_oprnds;\n@@ -320,7 +320,8 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      if (REFERENCE_CLASS_P (lhs))\n \t\t/* Store.  */\n                 vect_model_store_cost (stmt_info, ncopies_for_cost, false,\n-\t\t\t\t       dt, slp_node, stmt_cost_vec);\n+\t\t\t\t       dt, slp_node, prologue_cost_vec,\n+\t\t\t\t       body_cost_vec);\n \t      else\n \t\t{\n \t\t  enum vect_def_type dts[2];\n@@ -329,7 +330,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  /* Not memory operation (we don't call this function for\n \t\t     loads).  */\n \t\t  vect_model_simple_cost (stmt_info, ncopies_for_cost, dts,\n-\t\t\t\t\t  slp_node, stmt_cost_vec);\n+\t\t\t\t\t  prologue_cost_vec, body_cost_vec);\n \t\t}\n \t    }\n \t}\n@@ -451,7 +452,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                      VEC (int, heap) **load_permutation,\n                      VEC (slp_tree, heap) **loads,\n                      unsigned int vectorization_factor, bool *loads_permuted,\n-\t\t     stmt_vector_for_cost *stmt_cost_vec)\n+\t\t     stmt_vector_for_cost *prologue_cost_vec,\n+\t\t     stmt_vector_for_cost *body_cost_vec)\n {\n   unsigned int i;\n   VEC (gimple, heap) *stmts = SLP_TREE_SCALAR_STMTS (*node);\n@@ -712,7 +714,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, *node,\n \t\t\t\t\t\tstmt, ncopies_for_cost,\n \t\t\t\t\t\t(i == 0), &oprnds_info,\n-\t\t\t\t\t\tstmt_cost_vec))\n+\t\t\t\t\t\tprologue_cost_vec,\n+\t\t\t\t\t\tbody_cost_vec))\n \t\t{\n \t  \t  vect_free_oprnd_info (&oprnds_info);\n  \t\t  return false;\n@@ -802,7 +805,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                   /* Analyze costs (for the first stmt in the group).  */\n                   vect_model_load_cost (vinfo_for_stmt (stmt),\n                                         ncopies_for_cost, false, *node,\n-\t\t\t\t\tstmt_cost_vec);\n+\t\t\t\t\tprologue_cost_vec, body_cost_vec);\n                 }\n \n               /* Store the place of this load in the interleaving chain.  In\n@@ -876,17 +879,15 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  /* Find the def-stmts.  */\n \t  if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, *node, stmt,\n \t\t\t\t\t    ncopies_for_cost, (i == 0),\n-\t\t\t\t\t    &oprnds_info, stmt_cost_vec))\n+\t\t\t\t\t    &oprnds_info, prologue_cost_vec,\n+\t\t\t\t\t    body_cost_vec))\n \t    {\n \t      vect_free_oprnd_info (&oprnds_info);\n \t      return false;\n \t    }\n \t}\n     }\n \n-  /* Add the costs of the node to the overall instance costs.  */\n-  *outside_cost += SLP_TREE_OUTSIDE_OF_LOOP_COST (*node);\n-\n   /* Grouped loads were reached - stop the recursion.  */\n   if (stop_recursion)\n     {\n@@ -895,8 +896,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n         {\n \t  gimple first_stmt = VEC_index (gimple, stmts, 0);\n           *loads_permuted = true;\n-\t  (void) record_stmt_cost (stmt_cost_vec, group_size, vec_perm, \n-\t\t\t\t   vinfo_for_stmt (first_stmt), 0);\n+\t  (void) record_stmt_cost (body_cost_vec, group_size, vec_perm, \n+\t\t\t\t   vinfo_for_stmt (first_stmt), 0, vect_body);\n         }\n       else\n         {\n@@ -925,7 +926,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t   outside_cost, ncopies_for_cost,\n \t\t\t\t   max_nunits, load_permutation, loads,\n \t\t\t\t   vectorization_factor, loads_permuted,\n-\t\t\t\t   stmt_cost_vec))\n+\t\t\t\t   prologue_cost_vec, body_cost_vec))\n         {\n \t  if (child)\n \t    oprnd_info->def_stmts = NULL;\n@@ -1470,7 +1471,8 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   struct data_reference *dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n   bool loads_permuted = false;\n   VEC (gimple, heap) *scalar_stmts;\n-  stmt_vector_for_cost stmt_cost_vec;\n+  stmt_vector_for_cost body_cost_vec, prologue_cost_vec;\n+  stmt_info_for_cost *si;\n \n   if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n@@ -1556,15 +1558,19 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n   load_permutation = VEC_alloc (int, heap, group_size * group_size);\n   loads = VEC_alloc (slp_tree, heap, group_size);\n-  stmt_cost_vec = VEC_alloc (stmt_info_for_cost, heap, 10);\n+  prologue_cost_vec = VEC_alloc (stmt_info_for_cost, heap, 10);\n+  body_cost_vec = VEC_alloc (stmt_info_for_cost, heap, 10);\n \n   /* Build the tree for the SLP instance.  */\n   if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &node, group_size,\n                            &outside_cost, ncopies_for_cost,\n \t\t\t   &max_nunits, &load_permutation, &loads,\n \t\t\t   vectorization_factor, &loads_permuted,\n-\t\t\t   &stmt_cost_vec))\n+\t\t\t   &prologue_cost_vec, &body_cost_vec))\n     {\n+      void *data = (loop_vinfo ? LOOP_VINFO_TARGET_COST_DATA (loop_vinfo)\n+\t\t    : BB_VINFO_TARGET_COST_DATA (bb_vinfo));\n+\n       /* Calculate the unrolling factor based on the smallest type.  */\n       if (max_nunits > nunits)\n         unrolling_factor = least_common_multiple (max_nunits, group_size)\n@@ -1575,7 +1581,8 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           if (vect_print_dump_info (REPORT_SLP))\n             fprintf (vect_dump, \"Build SLP failed: unrolling required in basic\"\n                                \" block SLP\");\n-\t  VEC_free (stmt_info_for_cost, heap, stmt_cost_vec);\n+\t  VEC_free (stmt_info_for_cost, heap, body_cost_vec);\n+\t  VEC_free (stmt_info_for_cost, heap, prologue_cost_vec);\n           return false;\n         }\n \n@@ -1584,8 +1591,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       SLP_INSTANCE_TREE (new_instance) = node;\n       SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n       SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n-      SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (new_instance) = outside_cost;\n-      SLP_INSTANCE_STMT_COST_VEC (new_instance) = stmt_cost_vec;\n+      SLP_INSTANCE_BODY_COST_VEC (new_instance) = body_cost_vec;\n       SLP_INSTANCE_LOADS (new_instance) = loads;\n       SLP_INSTANCE_FIRST_LOAD_STMT (new_instance) = NULL;\n       SLP_INSTANCE_LOAD_PERMUTATION (new_instance) = load_permutation;\n@@ -1603,6 +1609,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                 }\n \n               vect_free_slp_instance (new_instance);\n+\t      VEC_free (stmt_info_for_cost, heap, prologue_cost_vec);\n               return false;\n             }\n \n@@ -1612,6 +1619,19 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       else\n         VEC_free (int, heap, SLP_INSTANCE_LOAD_PERMUTATION (new_instance));\n \n+      /* Record the prologue costs, which were delayed until we were\n+\t sure that SLP was successful.  Unlike the body costs, we know\n+\t the final values now regardless of the loop vectorization factor.  */\n+      FOR_EACH_VEC_ELT (stmt_info_for_cost, prologue_cost_vec, i, si)\n+\t{\n+\t  struct _stmt_vec_info *stmt_info\n+\t    = si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n+\t  (void) add_stmt_cost (data, si->count, si->kind, stmt_info,\n+\t\t\t\tsi->misalign, vect_prologue);\n+\t}\n+\n+      VEC_free (stmt_info_for_cost, heap, prologue_cost_vec);\n+\n       if (loop_vinfo)\n         VEC_safe_push (slp_instance, heap,\n                        LOOP_VINFO_SLP_INSTANCES (loop_vinfo),\n@@ -1626,7 +1646,10 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       return true;\n     }\n   else\n-    VEC_free (stmt_info_for_cost, heap, stmt_cost_vec);\n+    {\n+      VEC_free (stmt_info_for_cost, heap, body_cost_vec);\n+      VEC_free (stmt_info_for_cost, heap, prologue_cost_vec);\n+    }\n \n   /* Failed to SLP.  */\n   /* Free the allocated memory.  */\n@@ -1932,26 +1955,27 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n   slp_instance instance;\n   int i, j;\n   unsigned int vec_inside_cost = 0, vec_outside_cost = 0, scalar_cost = 0;\n+  unsigned int vec_prologue_cost = 0, vec_epilogue_cost = 0;\n   unsigned int stmt_cost;\n   gimple stmt;\n   gimple_stmt_iterator si;\n   basic_block bb = BB_VINFO_BB (bb_vinfo);\n+  void *target_cost_data = BB_VINFO_TARGET_COST_DATA (bb_vinfo);\n   stmt_vec_info stmt_info = NULL;\n-  tree dummy_type = NULL;\n-  int dummy = 0;\n-  stmt_vector_for_cost stmt_cost_vec;\n+  stmt_vector_for_cost body_cost_vec;\n   stmt_info_for_cost *ci;\n \n   /* Calculate vector costs.  */\n   FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     {\n-      vec_outside_cost += SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (instance);\n-      stmt_cost_vec = SLP_INSTANCE_STMT_COST_VEC (instance);\n+      body_cost_vec = SLP_INSTANCE_BODY_COST_VEC (instance);\n \n-      FOR_EACH_VEC_ELT (stmt_info_for_cost, stmt_cost_vec, j, ci)\n-\t(void) add_stmt_cost (BB_VINFO_TARGET_COST_DATA (bb_vinfo),\n-\t\t\t      ci->count, ci->kind,\n-\t\t\t      vinfo_for_stmt (ci->stmt), ci->misalign);\n+      FOR_EACH_VEC_ELT (stmt_info_for_cost, body_cost_vec, j, ci)\n+\t{\n+\t  stmt_info = ci->stmt ? vinfo_for_stmt (ci->stmt) : NULL;\n+\t  (void) add_stmt_cost (target_cost_data, ci->count, ci->kind,\n+\t\t\t\tstmt_info, ci->misalign, vect_body);\n+\t}\n     }\n \n   /* Calculate scalar cost.  */\n@@ -1967,29 +1991,29 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n       if (STMT_VINFO_DATA_REF (stmt_info))\n         {\n           if (DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n-            stmt_cost = targetm.vectorize.builtin_vectorization_cost \n-                          (scalar_load, dummy_type, dummy);\n+            stmt_cost = vect_get_stmt_cost (scalar_load);\n           else\n-            stmt_cost = targetm.vectorize.builtin_vectorization_cost\n-                          (scalar_store, dummy_type, dummy);\n+            stmt_cost = vect_get_stmt_cost (scalar_store);\n         }\n       else\n-        stmt_cost = targetm.vectorize.builtin_vectorization_cost\n-                      (scalar_stmt, dummy_type, dummy);\n+        stmt_cost = vect_get_stmt_cost (scalar_stmt);\n \n       scalar_cost += stmt_cost;\n     }\n \n   /* Complete the target-specific cost calculation.  */\n-  vec_inside_cost = finish_cost (BB_VINFO_TARGET_COST_DATA (bb_vinfo));\n+  finish_cost (BB_VINFO_TARGET_COST_DATA (bb_vinfo), &vec_prologue_cost,\n+\t       &vec_inside_cost, &vec_epilogue_cost);\n+\n+  vec_outside_cost = vec_prologue_cost + vec_epilogue_cost;\n \n   if (vect_print_dump_info (REPORT_COST))\n     {\n       fprintf (vect_dump, \"Cost model analysis: \\n\");\n       fprintf (vect_dump, \"  Vector inside of basic block cost: %d\\n\",\n                vec_inside_cost);\n-      fprintf (vect_dump, \"  Vector outside of basic block cost: %d\\n\",\n-               vec_outside_cost);\n+      fprintf (vect_dump, \"  Vector prologue cost: %d\\n\", vec_prologue_cost);\n+      fprintf (vect_dump, \"  Vector epilogue cost: %d\\n\", vec_epilogue_cost);\n       fprintf (vect_dump, \"  Scalar cost of basic block: %d\", scalar_cost);\n     }\n \n@@ -2200,8 +2224,9 @@ vect_update_slp_costs_according_to_vf (loop_vec_info loop_vinfo)\n   unsigned int i, j, vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   VEC (slp_instance, heap) *slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n   slp_instance instance;\n-  stmt_vector_for_cost stmt_cost_vec;\n+  stmt_vector_for_cost body_cost_vec;\n   stmt_info_for_cost *si;\n+  void *data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n \n   if (vect_print_dump_info (REPORT_SLP))\n     fprintf (vect_dump, \"=== vect_update_slp_costs_according_to_vf ===\");\n@@ -2214,12 +2239,12 @@ vect_update_slp_costs_according_to_vf (loop_vec_info loop_vinfo)\n       /* Record the instance's instructions in the target cost model.\n \t This was delayed until here because the count of instructions\n \t isn't known beforehand.  */\n-      stmt_cost_vec = SLP_INSTANCE_STMT_COST_VEC (instance);\n+      body_cost_vec = SLP_INSTANCE_BODY_COST_VEC (instance);\n \n-      FOR_EACH_VEC_ELT (stmt_info_for_cost, stmt_cost_vec, j, si)\n-\t(void) add_stmt_cost (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo),\n-\t\t\t      si->count * ncopies, si->kind,\n-\t\t\t      vinfo_for_stmt (si->stmt), si->misalign);\n+      FOR_EACH_VEC_ELT (stmt_info_for_cost, body_cost_vec, j, si)\n+\t(void) add_stmt_cost (data, si->count * ncopies, si->kind,\n+\t\t\t      vinfo_for_stmt (si->stmt), si->misalign,\n+\t\t\t      vect_body);\n     }\n }\n "}, {"sha": "779b6fcf652bd5ed850df0926de1383fcfe16c36", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 86, "deletions": 84, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -72,18 +72,18 @@ stmt_in_inner_loop_p (struct _stmt_vec_info *stmt_info)\n    Return a preliminary estimate of the statement's cost.  */\n \n unsigned\n-record_stmt_cost (stmt_vector_for_cost *stmt_cost_vec, int count,\n+record_stmt_cost (stmt_vector_for_cost *body_cost_vec, int count,\n \t\t  enum vect_cost_for_stmt kind, stmt_vec_info stmt_info,\n-\t\t  int misalign)\n+\t\t  int misalign, enum vect_cost_model_location where)\n {\n-  if (stmt_cost_vec)\n+  if (body_cost_vec)\n     {\n-      tree vectype = stmt_vectype (stmt_info);\n-      add_stmt_info_to_vec (stmt_cost_vec, count, kind,\n-\t\t\t    STMT_VINFO_STMT (stmt_info), misalign);\n+      tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n+      add_stmt_info_to_vec (body_cost_vec, count, kind,\n+\t\t\t    stmt_info ? STMT_VINFO_STMT (stmt_info) : NULL,\n+\t\t\t    misalign);\n       return (unsigned)\n-\t(targetm.vectorize.builtin_vectorization_cost (kind, vectype, misalign)\n-\t * count);\n+\t(builtin_vectorization_cost (kind, vectype, misalign) * count);\n \t \n     }\n   else\n@@ -97,7 +97,8 @@ record_stmt_cost (stmt_vector_for_cost *stmt_cost_vec, int count,\n       else\n \ttarget_cost_data = BB_VINFO_TARGET_COST_DATA (bb_vinfo);\n \n-      return add_stmt_cost (target_cost_data, count, kind, stmt_info, misalign);\n+      return add_stmt_cost (target_cost_data, count, kind, stmt_info,\n+\t\t\t    misalign, where);\n     }\n }\n \n@@ -795,33 +796,30 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \n void\n vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n-\t\t\tenum vect_def_type *dt, slp_tree slp_node,\n-\t\t\tstmt_vector_for_cost *stmt_cost_vec)\n+\t\t\tenum vect_def_type *dt,\n+\t\t\tstmt_vector_for_cost *prologue_cost_vec,\n+\t\t\tstmt_vector_for_cost *body_cost_vec)\n {\n   int i;\n-  int inside_cost = 0, outside_cost = 0;\n+  int inside_cost = 0, prologue_cost = 0;\n \n   /* The SLP costs were already calculated during SLP tree build.  */\n   if (PURE_SLP_STMT (stmt_info))\n     return;\n \n   /* FORNOW: Assuming maximum 2 args per stmts.  */\n   for (i = 0; i < 2; i++)\n-    {\n-      if (dt[i] == vect_constant_def || dt[i] == vect_external_def)\n-\toutside_cost += vect_get_stmt_cost (vector_stmt); \n-    }\n-\n-  /* Set the costs either in STMT_INFO or SLP_NODE (if exists).  */\n-  stmt_vinfo_set_outside_of_loop_cost (stmt_info, slp_node, outside_cost);\n+    if (dt[i] == vect_constant_def || dt[i] == vect_external_def)\n+      prologue_cost += record_stmt_cost (prologue_cost_vec, 1, vector_stmt,\n+\t\t\t\t\t stmt_info, 0, vect_prologue);\n \n   /* Pass the inside-of-loop statements to the target-specific cost model.  */\n-  inside_cost = record_stmt_cost (stmt_cost_vec, ncopies, vector_stmt,\n-\t\t\t\t  stmt_info, 0);\n+  inside_cost = record_stmt_cost (body_cost_vec, ncopies, vector_stmt,\n+\t\t\t\t  stmt_info, 0, vect_body);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_simple_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", inside_cost, outside_cost);\n+             \"prologue_cost = %d .\", inside_cost, prologue_cost);\n }\n \n \n@@ -835,7 +833,7 @@ vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n \t\t\t\t    enum vect_def_type *dt, int pwr)\n {\n   int i, tmp;\n-  int inside_cost = 0, outside_cost = 0;\n+  int inside_cost = 0, prologue_cost = 0;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   void *target_cost_data;\n@@ -854,22 +852,19 @@ vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n       tmp = (STMT_VINFO_TYPE (stmt_info) == type_promotion_vec_info_type) ?\n \t(i + 1) : i;\n       inside_cost += add_stmt_cost (target_cost_data, vect_pow2 (tmp),\n-\t\t\t\t    vec_promote_demote, stmt_info, 0);\n+\t\t\t\t    vec_promote_demote, stmt_info, 0,\n+\t\t\t\t    vect_body);\n     }\n \n   /* FORNOW: Assuming maximum 2 args per stmts.  */\n   for (i = 0; i < 2; i++)\n-    {\n-      if (dt[i] == vect_constant_def || dt[i] == vect_external_def)\n-        outside_cost += vect_get_stmt_cost (vector_stmt);\n-    }\n+    if (dt[i] == vect_constant_def || dt[i] == vect_external_def)\n+      prologue_cost += add_stmt_cost (target_cost_data, 1, vector_stmt,\n+\t\t\t\t      stmt_info, 0, vect_prologue);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_promotion_demotion_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", inside_cost, outside_cost);\n-\n-  /* Set the costs in STMT_INFO.  */\n-  stmt_vinfo_set_outside_of_loop_cost (stmt_info, NULL, outside_cost);\n+             \"prologue_cost = %d .\", inside_cost, prologue_cost);\n }\n \n /* Function vect_cost_group_size\n@@ -898,10 +893,12 @@ vect_cost_group_size (stmt_vec_info stmt_info)\n void\n vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t       bool store_lanes_p, enum vect_def_type dt,\n-\t\t       slp_tree slp_node, stmt_vector_for_cost *stmt_cost_vec)\n+\t\t       slp_tree slp_node,\n+\t\t       stmt_vector_for_cost *prologue_cost_vec,\n+\t\t       stmt_vector_for_cost *body_cost_vec)\n {\n   int group_size;\n-  unsigned int inside_cost = 0, outside_cost = 0;\n+  unsigned int inside_cost = 0, prologue_cost = 0;\n   struct data_reference *first_dr;\n   gimple first_stmt;\n \n@@ -910,7 +907,8 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n     return;\n \n   if (dt == vect_constant_def || dt == vect_external_def)\n-    outside_cost = vect_get_stmt_cost (scalar_to_vec); \n+    prologue_cost += record_stmt_cost (prologue_cost_vec, 1, scalar_to_vec,\n+\t\t\t\t       stmt_info, 0, vect_prologue);\n \n   /* Grouped access?  */\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n@@ -944,31 +942,28 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n       /* Uses a high and low interleave operation for each needed permute.  */\n       \n       int nstmts = ncopies * exact_log2 (group_size) * group_size;\n-      inside_cost = record_stmt_cost (stmt_cost_vec, nstmts, vec_perm,\n-\t\t\t\t      stmt_info, 0);\n+      inside_cost = record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n+\t\t\t\t      stmt_info, 0, vect_body);\n \n       if (vect_print_dump_info (REPORT_COST))\n         fprintf (vect_dump, \"vect_model_store_cost: strided group_size = %d .\",\n                  group_size);\n     }\n \n   /* Costs of the stores.  */\n-  vect_get_store_cost (first_dr, ncopies, &inside_cost, stmt_cost_vec);\n+  vect_get_store_cost (first_dr, ncopies, &inside_cost, body_cost_vec);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_store_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", inside_cost, outside_cost);\n-\n-  /* Set the costs either in STMT_INFO or SLP_NODE (if exists).  */\n-  stmt_vinfo_set_outside_of_loop_cost (stmt_info, slp_node, outside_cost);\n+             \"prologue_cost = %d .\", inside_cost, prologue_cost);\n }\n \n \n /* Calculate cost of DR's memory access.  */\n void\n vect_get_store_cost (struct data_reference *dr, int ncopies,\n \t\t     unsigned int *inside_cost,\n-\t\t     stmt_vector_for_cost *stmt_cost_vec)\n+\t\t     stmt_vector_for_cost *body_cost_vec)\n {\n   int alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n   gimple stmt = DR_STMT (dr);\n@@ -978,8 +973,9 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n     {\n     case dr_aligned:\n       {\n-\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n-\t\t\t\t\t  vector_store, stmt_info, 0);\n+\t*inside_cost += record_stmt_cost (body_cost_vec, ncopies,\n+\t\t\t\t\t  vector_store, stmt_info, 0,\n+\t\t\t\t\t  vect_body);\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_store_cost: aligned.\");\n@@ -990,9 +986,9 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n     case dr_unaligned_supported:\n       {\n         /* Here, we assign an additional cost for the unaligned store.  */\n-\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n+\t*inside_cost += record_stmt_cost (body_cost_vec, ncopies,\n \t\t\t\t\t  unaligned_store, stmt_info,\n-\t\t\t\t\t  DR_MISALIGNMENT (dr));\n+\t\t\t\t\t  DR_MISALIGNMENT (dr), vect_body);\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_store_cost: unaligned supported by \"\n@@ -1025,13 +1021,15 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n    access scheme chosen.  */\n \n void\n-vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, bool load_lanes_p,\n-\t\t      slp_tree slp_node, stmt_vector_for_cost *stmt_cost_vec)\n+vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n+\t\t      bool load_lanes_p, slp_tree slp_node,\n+\t\t      stmt_vector_for_cost *prologue_cost_vec,\n+\t\t      stmt_vector_for_cost *body_cost_vec)\n {\n   int group_size;\n   gimple first_stmt;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr;\n-  unsigned int inside_cost = 0, outside_cost = 0;\n+  unsigned int inside_cost = 0, prologue_cost = 0;\n \n   /* The SLP costs were already calculated during SLP tree build.  */\n   if (PURE_SLP_STMT (stmt_info))\n@@ -1059,8 +1057,8 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, bool load_lanes_p,\n     {\n       /* Uses an even and odd extract operations for each needed permute.  */\n       int nstmts = ncopies * exact_log2 (group_size) * group_size;\n-      inside_cost += record_stmt_cost (stmt_cost_vec, nstmts, vec_perm,\n-\t\t\t\t       stmt_info, 0);\n+      inside_cost += record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n+\t\t\t\t       stmt_info, 0, vect_body);\n \n       if (vect_print_dump_info (REPORT_COST))\n         fprintf (vect_dump, \"vect_model_load_cost: strided group_size = %d .\",\n@@ -1072,33 +1070,33 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, bool load_lanes_p,\n     {\n       /* N scalar loads plus gathering them into a vector.  */\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-      inside_cost += record_stmt_cost (stmt_cost_vec,\n+      inside_cost += record_stmt_cost (body_cost_vec,\n \t\t\t\t       ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n-\t\t\t\t       scalar_load, stmt_info, 0);\n-      inside_cost += record_stmt_cost (stmt_cost_vec, ncopies, vec_construct,\n-\t\t\t\t       stmt_info, 0);\n+\t\t\t\t       scalar_load, stmt_info, 0, vect_body);\n+      inside_cost += record_stmt_cost (body_cost_vec, ncopies, vec_construct,\n+\t\t\t\t       stmt_info, 0, vect_body);\n     }\n   else\n     vect_get_load_cost (first_dr, ncopies,\n \t\t\t((!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \t\t\t || group_size > 1 || slp_node),\n-\t\t\t&inside_cost, &outside_cost, stmt_cost_vec);\n+\t\t\t&inside_cost, &prologue_cost, \n+\t\t\tprologue_cost_vec, body_cost_vec, true);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_load_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", inside_cost, outside_cost);\n-\n-  /* Set the costs either in STMT_INFO or SLP_NODE (if exists).  */\n-  stmt_vinfo_set_outside_of_loop_cost (stmt_info, slp_node, outside_cost);\n+             \"prologue_cost = %d .\", inside_cost, prologue_cost);\n }\n \n \n /* Calculate cost of DR's memory access.  */\n void\n vect_get_load_cost (struct data_reference *dr, int ncopies,\n \t\t    bool add_realign_cost, unsigned int *inside_cost,\n-\t\t    unsigned int *outside_cost,\n-\t\t    stmt_vector_for_cost *stmt_cost_vec)\n+\t\t    unsigned int *prologue_cost,\n+\t\t    stmt_vector_for_cost *prologue_cost_vec,\n+\t\t    stmt_vector_for_cost *body_cost_vec,\n+\t\t    bool record_prologue_costs)\n {\n   int alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n   gimple stmt = DR_STMT (dr);\n@@ -1108,8 +1106,8 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n     {\n     case dr_aligned:\n       {\n-\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n-\t\t\t\t\t  vector_load, stmt_info, 0);\n+\t*inside_cost += record_stmt_cost (body_cost_vec, ncopies, vector_load,\n+\t\t\t\t\t  stmt_info, 0, vect_body);\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_load_cost: aligned.\");\n@@ -1119,9 +1117,9 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n     case dr_unaligned_supported:\n       {\n         /* Here, we assign an additional cost for the unaligned load.  */\n-\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n+\t*inside_cost += record_stmt_cost (body_cost_vec, ncopies,\n \t\t\t\t\t  unaligned_load, stmt_info,\n-\t\t\t\t\t  DR_MISALIGNMENT (dr));\n+\t\t\t\t\t  DR_MISALIGNMENT (dr), vect_body);\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_load_cost: unaligned supported by \"\n@@ -1131,17 +1129,17 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n       }\n     case dr_explicit_realign:\n       {\n-\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies * 2,\n-\t\t\t\t\t  vector_load, stmt_info, 0);\n-\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n-\t\t\t\t\t  vec_perm, stmt_info, 0);\n+\t*inside_cost += record_stmt_cost (body_cost_vec, ncopies * 2,\n+\t\t\t\t\t  vector_load, stmt_info, 0, vect_body);\n+\t*inside_cost += record_stmt_cost (body_cost_vec, ncopies,\n+\t\t\t\t\t  vec_perm, stmt_info, 0, vect_body);\n \n         /* FIXME: If the misalignment remains fixed across the iterations of\n            the containing loop, the following cost should be added to the\n-           outside costs.  */\n+           prologue costs.  */\n         if (targetm.vectorize.builtin_mask_for_load)\n-\t  *inside_cost += record_stmt_cost (stmt_cost_vec, 1, vector_stmt,\n-\t\t\t\t\t    stmt_info, 0);\n+\t  *inside_cost += record_stmt_cost (body_cost_vec, 1, vector_stmt,\n+\t\t\t\t\t    stmt_info, 0, vect_body);\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_load_cost: explicit realign\");\n@@ -1161,17 +1159,21 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n            access in the group.  Inside the loop, there is a load op\n            and a realignment op.  */\n \n-        if (add_realign_cost)\n+        if (add_realign_cost && record_prologue_costs)\n           {\n-            *outside_cost = 2 * vect_get_stmt_cost (vector_stmt);\n+\t    *prologue_cost += record_stmt_cost (prologue_cost_vec, 2,\n+\t\t\t\t\t\tvector_stmt, stmt_info,\n+\t\t\t\t\t\t0, vect_prologue);\n             if (targetm.vectorize.builtin_mask_for_load)\n-              *outside_cost += vect_get_stmt_cost (vector_stmt);\n+\t      *prologue_cost += record_stmt_cost (prologue_cost_vec, 1,\n+\t\t\t\t\t\t  vector_stmt, stmt_info,\n+\t\t\t\t\t\t  0, vect_prologue);\n           }\n \n-\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n-\t\t\t\t\t  vector_load, stmt_info, 0);\n-\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n-\t\t\t\t\t  vec_perm, stmt_info, 0);\n+\t*inside_cost += record_stmt_cost (body_cost_vec, ncopies, vector_load,\n+\t\t\t\t\t  stmt_info, 0, vect_body);\n+\t*inside_cost += record_stmt_cost (body_cost_vec, ncopies, vec_perm,\n+\t\t\t\t\t  stmt_info, 0, vect_body);\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump,\n@@ -3878,7 +3880,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n-      vect_model_store_cost (stmt_info, ncopies, store_lanes_p, dt, NULL, NULL);\n+      vect_model_store_cost (stmt_info, ncopies, store_lanes_p, dt,\n+\t\t\t     NULL, NULL, NULL);\n       return true;\n     }\n \n@@ -4434,7 +4437,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n-      vect_model_load_cost (stmt_info, ncopies, load_lanes_p, NULL, NULL);\n+      vect_model_load_cost (stmt_info, ncopies, load_lanes_p, NULL, NULL, NULL);\n       return true;\n     }\n \n@@ -5872,7 +5875,6 @@ new_stmt_vec_info (gimple stmt, loop_vec_info loop_vinfo,\n     STMT_VINFO_DEF_TYPE (res) = vect_internal_def;\n \n   STMT_VINFO_SAME_ALIGN_REFS (res) = VEC_alloc (dr_p, heap, 5);\n-  STMT_VINFO_OUTSIDE_OF_LOOP_COST (res) = 0;\n   STMT_SLP_TYPE (res) = loop_vect;\n   GROUP_FIRST_ELEMENT (res) = NULL;\n   GROUP_NEXT_ELEMENT (res) = NULL;"}, {"sha": "96cc52e3df93c96f93fdc4ef638bc2c3dbe2c366", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 32, "deletions": 49, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9234534930b0d0e7fc5e6b227daf79d8791f0972/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=9234534930b0d0e7fc5e6b227daf79d8791f0972", "patch": "@@ -118,11 +118,6 @@ typedef struct _slp_tree {\n      scalar elements in one scalar iteration (GROUP_SIZE) multiplied by VF\n      divided by vector size.  */\n   unsigned int vec_stmts_size;\n-  /* Vectorization costs associated with SLP node.  */\n-  struct\n-  {\n-    int outside_of_loop;     /* Statements generated outside loop.  */\n-  } cost;\n } *slp_tree;\n \n DEF_VEC_P(slp_tree);\n@@ -141,13 +136,7 @@ typedef struct _slp_instance {\n   unsigned int unrolling_factor;\n \n   /* Vectorization costs associated with SLP instance.  */\n-  struct\n-  {\n-    int outside_of_loop;     /* Statements generated outside loop.  */\n-  } cost;\n-\n-  /* Inside-loop costs.  */\n-  stmt_vector_for_cost stmt_cost_vec;\n+  stmt_vector_for_cost body_cost_vec;\n \n   /* Loads permutation relatively to the stores, NULL if there is no\n      permutation.  */\n@@ -168,8 +157,7 @@ DEF_VEC_ALLOC_P(slp_instance, heap);\n #define SLP_INSTANCE_TREE(S)                     (S)->root\n #define SLP_INSTANCE_GROUP_SIZE(S)               (S)->group_size\n #define SLP_INSTANCE_UNROLLING_FACTOR(S)         (S)->unrolling_factor\n-#define SLP_INSTANCE_OUTSIDE_OF_LOOP_COST(S)     (S)->cost.outside_of_loop\n-#define SLP_INSTANCE_STMT_COST_VEC(S)            (S)->stmt_cost_vec\n+#define SLP_INSTANCE_BODY_COST_VEC(S)            (S)->body_cost_vec\n #define SLP_INSTANCE_LOAD_PERMUTATION(S)         (S)->load_permutation\n #define SLP_INSTANCE_LOADS(S)                    (S)->loads\n #define SLP_INSTANCE_FIRST_LOAD_STMT(S)          (S)->first_load\n@@ -178,7 +166,6 @@ DEF_VEC_ALLOC_P(slp_instance, heap);\n #define SLP_TREE_SCALAR_STMTS(S)                 (S)->stmts\n #define SLP_TREE_VEC_STMTS(S)                    (S)->vec_stmts\n #define SLP_TREE_NUMBER_OF_VEC_STMTS(S)          (S)->vec_stmts_size\n-#define SLP_TREE_OUTSIDE_OF_LOOP_COST(S)         (S)->cost.outside_of_loop\n \n /* This structure is used in creation of an SLP tree.  Each instance\n    corresponds to the same operand in a group of scalar stmts in an SLP\n@@ -212,7 +199,7 @@ typedef struct _vect_peel_extended_info\n   struct _vect_peel_info peel_info;\n   unsigned int inside_cost;\n   unsigned int outside_cost;\n-  stmt_vector_for_cost stmt_cost_vec;\n+  stmt_vector_for_cost body_cost_vec;\n } *vect_peel_extended_info;\n \n /*-----------------------------------------------------------------*/\n@@ -566,12 +553,6 @@ typedef struct _stmt_vec_info {\n      indicates whether the stmt needs to be vectorized.  */\n   enum vect_relevant relevant;\n \n-  /* Vectorization costs associated with statement.  */\n-  struct\n-  {\n-    int outside_of_loop;     /* Statements generated outside loop.  */\n-  } cost;\n-\n   /* The bb_vec_info with respect to which STMT is vectorized.  */\n   bb_vec_info bb_vinfo;\n \n@@ -628,7 +609,6 @@ typedef struct _stmt_vec_info {\n #define GROUP_READ_WRITE_DEPENDENCE(S)  (S)->read_write_dep\n \n #define STMT_VINFO_RELEVANT_P(S)          ((S)->relevant != vect_unused_in_scope)\n-#define STMT_VINFO_OUTSIDE_OF_LOOP_COST(S) (S)->cost.outside_of_loop\n \n #define HYBRID_SLP_STMT(S)                ((S)->slp_type == hybrid)\n #define PURE_SLP_STMT(S)                  ((S)->slp_type == pure_slp)\n@@ -767,18 +747,6 @@ is_loop_header_bb_p (basic_block bb)\n   return false;\n }\n \n-/* Set outside loop vectorization cost.  */\n-\n-static inline void\n-stmt_vinfo_set_outside_of_loop_cost (stmt_vec_info stmt_info, slp_tree slp_node,\n-\t\t\t\t     int cost)\n-{\n-  if (slp_node)\n-    SLP_TREE_OUTSIDE_OF_LOOP_COST (slp_node) = cost;\n-  else\n-    STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = cost;\n-}\n-\n /* Return pow2 (X).  */\n \n static inline int\n@@ -792,16 +760,22 @@ vect_pow2 (int x)\n   return res;\n }\n \n+/* Alias targetm.vectorize.builtin_vectorization_cost.  */\n+\n+static inline int\n+builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n+\t\t\t    tree vectype, int misalign)\n+{\n+  return targetm.vectorize.builtin_vectorization_cost (type_of_cost,\n+\t\t\t\t\t\t       vectype, misalign);\n+}\n+\n /* Get cost by calling cost target builtin.  */\n \n static inline\n int vect_get_stmt_cost (enum vect_cost_for_stmt type_of_cost)\n {\n-  tree dummy_type = NULL;\n-  int dummy = 0;\n-\n-  return targetm.vectorize.builtin_vectorization_cost (type_of_cost,\n-                                                       dummy_type, dummy);\n+  return builtin_vectorization_cost (type_of_cost, NULL, 0);\n }\n \n /* Alias targetm.vectorize.init_cost.  */\n@@ -816,18 +790,20 @@ init_cost (struct loop *loop_info)\n \n static inline unsigned\n add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n-\t       stmt_vec_info stmt_info, int misalign)\n+\t       stmt_vec_info stmt_info, int misalign,\n+\t       enum vect_cost_model_location where)\n {\n   return targetm.vectorize.add_stmt_cost (data, count, kind,\n-\t\t\t\t\t  stmt_info, misalign);\n+\t\t\t\t\t  stmt_info, misalign, where);\n }\n \n /* Alias targetm.vectorize.finish_cost.  */\n \n-static inline unsigned\n-finish_cost (void *data)\n+static inline void\n+finish_cost (void *data, unsigned *prologue_cost,\n+\t     unsigned *body_cost, unsigned *epilogue_cost)\n {\n-  return targetm.vectorize.finish_cost (data);\n+  targetm.vectorize.finish_cost (data, prologue_cost, body_cost, epilogue_cost);\n }\n \n /* Alias targetm.vectorize.destroy_cost_data.  */\n@@ -905,14 +881,18 @@ extern stmt_vec_info new_stmt_vec_info (gimple stmt, loop_vec_info,\n extern void free_stmt_vec_info (gimple stmt);\n extern tree vectorizable_function (gimple, tree, tree);\n extern void vect_model_simple_cost (stmt_vec_info, int, enum vect_def_type *,\n-                                    slp_tree, stmt_vector_for_cost *);\n+                                    stmt_vector_for_cost *,\n+\t\t\t\t    stmt_vector_for_cost *);\n extern void vect_model_store_cost (stmt_vec_info, int, bool,\n \t\t\t\t   enum vect_def_type, slp_tree,\n+\t\t\t\t   stmt_vector_for_cost *,\n \t\t\t\t   stmt_vector_for_cost *);\n extern void vect_model_load_cost (stmt_vec_info, int, bool, slp_tree,\n+\t\t\t\t  stmt_vector_for_cost *,\n \t\t\t\t  stmt_vector_for_cost *);\n extern unsigned record_stmt_cost (stmt_vector_for_cost *, int,\n-\t\t\t\t  enum vect_cost_for_stmt, stmt_vec_info, int);\n+\t\t\t\t  enum vect_cost_for_stmt, stmt_vec_info,\n+\t\t\t\t  int, enum vect_cost_model_location);\n extern void vect_finish_stmt_generation (gimple, gimple,\n                                          gimple_stmt_iterator *);\n extern bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n@@ -928,7 +908,8 @@ extern bool vectorizable_condition (gimple, gimple_stmt_iterator *, gimple *,\n                                     tree, int, slp_tree);\n extern void vect_get_load_cost (struct data_reference *, int, bool,\n \t\t\t\tunsigned int *, unsigned int *,\n-\t\t\t\tstmt_vector_for_cost *);\n+\t\t\t\tstmt_vector_for_cost *,\n+\t\t\t\tstmt_vector_for_cost *, bool);\n extern void vect_get_store_cost (struct data_reference *, int,\n \t\t\t\t unsigned int *, stmt_vector_for_cost *);\n extern bool vect_supportable_shift (enum tree_code, tree);\n@@ -992,7 +973,9 @@ extern bool vectorizable_induction (gimple, gimple_stmt_iterator *, gimple *);\n extern int vect_estimate_min_profitable_iters (loop_vec_info);\n extern tree get_initial_def_for_reduction (gimple, tree, tree *);\n extern int vect_min_worthwhile_factor (enum tree_code);\n-extern int vect_get_known_peeling_cost (loop_vec_info, int, int *, int);\n+extern int vect_get_known_peeling_cost (loop_vec_info, int, int *, int,\n+\t\t\t\t\tstmt_vector_for_cost *,\n+\t\t\t\t\tstmt_vector_for_cost *);\n extern int vect_get_single_scalar_iteration_cost (loop_vec_info);\n \n /* In tree-vect-slp.c.  */"}]}