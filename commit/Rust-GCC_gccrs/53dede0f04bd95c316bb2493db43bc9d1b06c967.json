{"sha": "53dede0f04bd95c316bb2493db43bc9d1b06c967", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNkZWRlMGYwNGJkOTVjMzE2YmIyNDkzZGI0M2JjOWQxYjA2Yzk2Nw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2020-10-29T09:30:50Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2020-10-29T09:30:50Z"}, "message": "CSE conversions within sincos\n\nOn platforms in which Aux_[Real_Type] involves non-NOP conversions\n(e.g., between single- and double-precision, or between short float\nand float), the conversions before the calls are CSEd too late for\nsincos to combine calls.\n\nThis patch enables the sincos pass to CSE type casts used as arguments\nto eligible calls before looking for other calls using the same\noperand.\n\n\nfor  gcc/ChangeLog\n\n\t* tree-ssa-math-opts.c (sincos_stats): Add conv_removed.\n\t(execute_cse_conv_1): New.\n\t(execute_cse_sincos_1): Call it.  Fix return within\n\tFOR_EACH_IMM_USE_STMT.\n\t(pass_cse_sincos::execute): Report conv_inserted.\n\nfor  gcc/testsuite/ChangeLog\n\n\t* gnat.dg/sin_cos.ads: New.\n\t* gnat.dg/sin_cos.adb: New.\n\t* gcc.dg/sin_cos.c: New.", "tree": {"sha": "3512917874a8747ce964ab95b64f398cf0abceb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3512917874a8747ce964ab95b64f398cf0abceb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53dede0f04bd95c316bb2493db43bc9d1b06c967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53dede0f04bd95c316bb2493db43bc9d1b06c967", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53dede0f04bd95c316bb2493db43bc9d1b06c967", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53dede0f04bd95c316bb2493db43bc9d1b06c967/comments", "author": null, "committer": null, "parents": [{"sha": "68990ed13dc36cb98f94afa84e9dadc39e955e8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68990ed13dc36cb98f94afa84e9dadc39e955e8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68990ed13dc36cb98f94afa84e9dadc39e955e8c"}], "stats": {"total": 166, "additions": 165, "deletions": 1}, "files": [{"sha": "aa71dcac6588be175a86ccfc745b0be51ada901f", "filename": "gcc/testsuite/gcc.dg/sin_cos.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dede0f04bd95c316bb2493db43bc9d1b06c967/gcc%2Ftestsuite%2Fgcc.dg%2Fsin_cos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dede0f04bd95c316bb2493db43bc9d1b06c967/gcc%2Ftestsuite%2Fgcc.dg%2Fsin_cos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsin_cos.c?ref=53dede0f04bd95c316bb2493db43bc9d1b06c967", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+/* This maps to essentially the same gimple that is generated for\n+   gnat.dg/sin_cos.adb, on platforms that use the wraplf variant of\n+   Ada.Numerics.Aux_Float.  The value of EPSILON is not relevant to\n+   the test, but the test must be there to keep the conversions in\n+   different BBs long enough to trigger the problem that prevented the\n+   sincos optimization, because the arguments passed to sin and cos\n+   didn't get unified into a single SSA_NAME in time for sincos.  */\n+\n+#include <math.h>\n+\n+#define EPSILON 3.4526697709225118160247802734375e-4\n+\n+static float my_sinf(float x) {\n+  return (float) sin ((double) x);\n+}\n+\n+static float wrap_sinf(float x) {\n+  if (fabs (x) < EPSILON)\n+    return 0;\n+  return my_sinf (x);\n+}\n+\n+static float my_cosf(float x) {\n+  return (float) cos ((double) x);\n+}\n+\n+static float wrap_cosf(float x) {\n+  if (fabs (x) < EPSILON)\n+    return 1;\n+  return my_cosf (x);\n+}\n+\n+float my_sin_cos(float x, float *s, float *c) {\n+  *s = wrap_sinf (x);\n+  *c = wrap_cosf (x);\n+}\n+\n+/* { dg-final { scan-assembler \"sincos\\|cexp\" { target *-linux-gnu* *-w64-mingw* *-*-vxworks* } } } */"}, {"sha": "6e18df997533aa907639990f19a87efe30d1d1ac", "filename": "gcc/testsuite/gnat.dg/sin_cos.adb", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dede0f04bd95c316bb2493db43bc9d1b06c967/gcc%2Ftestsuite%2Fgnat.dg%2Fsin_cos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dede0f04bd95c316bb2493db43bc9d1b06c967/gcc%2Ftestsuite%2Fgnat.dg%2Fsin_cos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsin_cos.adb?ref=53dede0f04bd95c316bb2493db43bc9d1b06c967", "patch": "@@ -0,0 +1,14 @@\n+--  { dg-do compile }\n+--  { dg-options \"-O2 -gnatn\" }\n+\n+with Ada.Numerics.Elementary_Functions;\n+use Ada.Numerics.Elementary_Functions;\n+package body Sin_Cos is\n+   procedure Sin_Cos (Angle : T; SinA, CosA : out T) is\n+   begin\n+      SinA := Sin (Angle);\n+      CosA := Cos (Angle);\n+   end;\n+end Sin_Cos;\n+\n+--  { dg-final { scan-assembler \"sincos\\|cexp\" { target *-linux-gnu* *-w64-mingw* *-*-vxworks* } } }"}, {"sha": "a0eff3dec5dbf583e56fab199cb357dcfd4400e7", "filename": "gcc/testsuite/gnat.dg/sin_cos.ads", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dede0f04bd95c316bb2493db43bc9d1b06c967/gcc%2Ftestsuite%2Fgnat.dg%2Fsin_cos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dede0f04bd95c316bb2493db43bc9d1b06c967/gcc%2Ftestsuite%2Fgnat.dg%2Fsin_cos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsin_cos.ads?ref=53dede0f04bd95c316bb2493db43bc9d1b06c967", "patch": "@@ -0,0 +1,4 @@\n+package Sin_Cos is\n+   subtype T is Float;\n+   procedure Sin_Cos (Angle : T; SinA, CosA : out T);\n+end Sin_Cos;"}, {"sha": "65c7b34c908409919af53c8555e43abb1a7846cb", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 106, "deletions": 1, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dede0f04bd95c316bb2493db43bc9d1b06c967/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dede0f04bd95c316bb2493db43bc9d1b06c967/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=53dede0f04bd95c316bb2493db43bc9d1b06c967", "patch": "@@ -187,6 +187,10 @@ static struct\n {\n   /* Number of cexpi calls inserted.  */\n   int inserted;\n+\n+  /* Number of conversions removed.  */\n+  int conv_removed;\n+\n } sincos_stats;\n \n static struct\n@@ -1099,6 +1103,103 @@ make_pass_cse_reciprocals (gcc::context *ctxt)\n   return new pass_cse_reciprocals (ctxt);\n }\n \n+/* If NAME is the result of a type conversion, look for other\n+   equivalent dominating or dominated conversions, and replace all\n+   uses with the earliest dominating name, removing the redundant\n+   conversions.  Return the prevailing name.  */\n+\n+static tree\n+execute_cse_conv_1 (tree name)\n+{\n+  if (SSA_NAME_IS_DEFAULT_DEF (name)\n+      || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n+    return name;\n+\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+\n+  if (!gimple_assign_cast_p (def_stmt))\n+    return name;\n+\n+  tree src = gimple_assign_rhs1 (def_stmt);\n+\n+  if (TREE_CODE (src) != SSA_NAME)\n+    return name;\n+\n+  imm_use_iterator use_iter;\n+  gimple *use_stmt;\n+\n+  /* Find the earliest dominating def.    */\n+  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, src)\n+    {\n+      if (use_stmt == def_stmt\n+\t  || !gimple_assign_cast_p (use_stmt))\n+\tcontinue;\n+\n+      tree lhs = gimple_assign_lhs (use_stmt);\n+\n+      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs)\n+\t  || (gimple_assign_rhs1 (use_stmt)\n+\t      != gimple_assign_rhs1 (def_stmt))\n+\t  || !types_compatible_p (TREE_TYPE (name), TREE_TYPE (lhs)))\n+\tcontinue;\n+\n+      bool use_dominates;\n+      if (gimple_bb (def_stmt) == gimple_bb (use_stmt))\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n+\t  while (!gsi_end_p (gsi) && gsi_stmt (gsi) != def_stmt)\n+\t    gsi_next (&gsi);\n+\t  use_dominates = !gsi_end_p (gsi);\n+\t}\n+      else if (dominated_by_p (CDI_DOMINATORS, gimple_bb (use_stmt),\n+\t\t\t       gimple_bb (def_stmt)))\n+\tuse_dominates = false;\n+      else if (dominated_by_p (CDI_DOMINATORS, gimple_bb (def_stmt),\n+\t\t\t       gimple_bb (use_stmt)))\n+\tuse_dominates = true;\n+      else\n+\tcontinue;\n+\n+      if (use_dominates)\n+\t{\n+\t  std::swap (name, lhs);\n+\t  std::swap (def_stmt, use_stmt);\n+\t}\n+    }\n+\n+  /* Now go through all uses of SRC again, replacing the equivalent\n+     dominated conversions.  We may replace defs that were not\n+     dominated by the then-prevailing defs when we first visited\n+     them.  */\n+  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, src)\n+    {\n+      if (use_stmt == def_stmt\n+\t  || !gimple_assign_cast_p (use_stmt))\n+\tcontinue;\n+\n+      tree lhs = gimple_assign_lhs (use_stmt);\n+\n+      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs)\n+\t  || (gimple_assign_rhs1 (use_stmt)\n+\t      != gimple_assign_rhs1 (def_stmt))\n+\t  || !types_compatible_p (TREE_TYPE (name), TREE_TYPE (lhs)))\n+\tcontinue;\n+\n+      if (gimple_bb (def_stmt) == gimple_bb (use_stmt)\n+\t  || dominated_by_p (CDI_DOMINATORS, gimple_bb (use_stmt),\n+\t\t\t     gimple_bb (def_stmt)))\n+\t{\n+\t  sincos_stats.conv_removed++;\n+\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n+\t  replace_uses_by (lhs, name);\n+\t  gsi_remove (&gsi, true);\n+\t}\n+    }\n+\n+  return name;\n+}\n+\n /* Records an occurrence at statement USE_STMT in the vector of trees\n    STMTS if it is dominated by *TOP_BB or dominates it or this basic block\n    is not yet initialized.  Returns true if the occurrence was pushed on\n@@ -1147,6 +1248,8 @@ execute_cse_sincos_1 (tree name)\n   int i;\n   bool cfg_changed = false;\n \n+  name = execute_cse_conv_1 (name);\n+\n   FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, name)\n     {\n       if (gimple_code (use_stmt) != GIMPLE_CALL\n@@ -1181,7 +1284,7 @@ execute_cse_sincos_1 (tree name)\n \t and, in subsequent rounds, that the built_in type is the same\n \t type, or a compatible type.  */\n       if (type != t && !types_compatible_p (type, t))\n-\treturn false;\n+\tRETURN_FROM_IMM_USE_STMT (use_iter, false);\n     }\n   if (seen_cos + seen_sin + seen_cexpi <= 1)\n     return false;\n@@ -2296,6 +2399,8 @@ pass_cse_sincos::execute (function *fun)\n \n   statistics_counter_event (fun, \"sincos statements inserted\",\n \t\t\t    sincos_stats.inserted);\n+  statistics_counter_event (fun, \"conv statements removed\",\n+\t\t\t    sincos_stats.conv_removed);\n \n   return cfg_changed ? TODO_cleanup_cfg : 0;\n }"}]}