{"sha": "5b92e1895eea1ea9a7eb69553af8d173bd62e134", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI5MmUxODk1ZWVhMWVhOWE3ZWI2OTU1M2FmOGQxNzNiZDYyZTEzNA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2015-10-27T05:26:27Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2015-10-27T05:26:27Z"}, "message": "loop-invariant.c (struct def): New field can_prop_to_addr_uses.\n\n\n\t* loop-invariant.c (struct def): New field can_prop_to_addr_uses.\n\t(inv_can_prop_to_addr_use): New function.\n\t(record_use): Call can_prop_to_addr_uses, set the new field.\n\t(get_inv_cost): Count cost if inv can't be propagated into its\n\taddress uses.\n\nFrom-SVN: r229402", "tree": {"sha": "10a6570c4bb4a7278ecda3f038b6b918f6ce1ac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10a6570c4bb4a7278ecda3f038b6b918f6ce1ac7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b92e1895eea1ea9a7eb69553af8d173bd62e134", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b92e1895eea1ea9a7eb69553af8d173bd62e134", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b92e1895eea1ea9a7eb69553af8d173bd62e134", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b92e1895eea1ea9a7eb69553af8d173bd62e134/comments", "author": null, "committer": null, "parents": [{"sha": "bda9c2451e766ec289ce746e803d863832b23f51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bda9c2451e766ec289ce746e803d863832b23f51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bda9c2451e766ec289ce746e803d863832b23f51"}], "stats": {"total": 53, "additions": 51, "deletions": 2}, "files": [{"sha": "0a2e2ad62322985e6afa2a4d9f7447de606d16d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b92e1895eea1ea9a7eb69553af8d173bd62e134/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b92e1895eea1ea9a7eb69553af8d173bd62e134/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b92e1895eea1ea9a7eb69553af8d173bd62e134", "patch": "@@ -1,3 +1,11 @@\n+2015-10-27  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* loop-invariant.c (struct def): New field can_prop_to_addr_uses.\n+\t(inv_can_prop_to_addr_use): New function.\n+\t(record_use): Call can_prop_to_addr_uses, set the new field.\n+\t(get_inv_cost): Count cost if inv can't be propagated into its\n+\taddress uses.\n+\n 2015-10-26  Doug Evans  <dje@google.com>\n \n \t* config/linux.h (INCLUDE_DEFAULTS): Add INCLUDE_DEFAULTS_MUSL_LOCAL."}, {"sha": "7ac38c68a945083b890e9e255ff952e79e098327", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b92e1895eea1ea9a7eb69553af8d173bd62e134/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b92e1895eea1ea9a7eb69553af8d173bd62e134/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=5b92e1895eea1ea9a7eb69553af8d173bd62e134", "patch": "@@ -99,6 +99,8 @@ struct def\n   unsigned n_uses;\t\t/* Number of such uses.  */\n   unsigned n_addr_uses;\t\t/* Number of uses in addresses.  */\n   unsigned invno;\t\t/* The corresponding invariant.  */\n+  bool can_prop_to_addr_uses;\t/* True if the corresponding inv can be\n+\t\t\t\t   propagated into its address uses.  */\n };\n \n /* The data stored for each invariant.  */\n@@ -762,6 +764,34 @@ create_new_invariant (struct def *def, rtx_insn *insn, bitmap depends_on,\n   return inv;\n }\n \n+/* Given invariant DEF and its address USE, check if the corresponding\n+   invariant expr can be propagated into the use or not.  */\n+\n+static bool\n+inv_can_prop_to_addr_use (struct def *def, df_ref use)\n+{\n+  struct invariant *inv;\n+  rtx *pos = DF_REF_REAL_LOC (use), def_set;\n+  rtx_insn *use_insn = DF_REF_INSN (use);\n+  rtx_insn *def_insn;\n+  bool ok;\n+\n+  inv = invariants[def->invno];\n+  /* No need to check if address expression is expensive.  */\n+  if (!inv->cheap_address)\n+    return false;\n+\n+  def_insn = inv->insn;\n+  def_set = single_set (def_insn);\n+  if (!def_set)\n+    return false;\n+\n+  validate_unshare_change (use_insn, pos, SET_SRC (def_set), true);\n+  ok = verify_changes (0);\n+  cancel_changes (0);\n+  return ok;\n+}\n+\n /* Record USE at DEF.  */\n \n static void\n@@ -777,7 +807,16 @@ record_use (struct def *def, df_ref use)\n   def->uses = u;\n   def->n_uses++;\n   if (u->addr_use_p)\n-    def->n_addr_uses++;\n+    {\n+      /* Initialize propagation information if this is the first addr\n+\t use of the inv def.  */\n+      if (def->n_addr_uses == 0)\n+\tdef->can_prop_to_addr_uses = true;\n+\n+      def->n_addr_uses++;\n+      if (def->can_prop_to_addr_uses && !inv_can_prop_to_addr_use (def, use))\n+\tdef->can_prop_to_addr_uses = false;\n+    }\n }\n \n /* Finds the invariants USE depends on and store them to the DEPENDS_ON\n@@ -1158,7 +1197,9 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed,\n \n   if (!inv->cheap_address\n       || inv->def->n_uses == 0\n-      || inv->def->n_addr_uses < inv->def->n_uses)\n+      || inv->def->n_addr_uses < inv->def->n_uses\n+      /* Count cost if the inv can't be propagated into address uses.  */\n+      || !inv->def->can_prop_to_addr_uses)\n     (*comp_cost) += inv->cost * inv->eqno;\n \n #ifdef STACK_REGS"}]}