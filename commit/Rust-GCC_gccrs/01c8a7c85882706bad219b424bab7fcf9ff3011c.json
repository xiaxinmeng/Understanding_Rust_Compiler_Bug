{"sha": "01c8a7c85882706bad219b424bab7fcf9ff3011c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFjOGE3Yzg1ODgyNzA2YmFkMjE5YjQyNGJhYjdmY2Y5ZmYzMDExYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-09-23T18:40:48Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-09-23T18:40:48Z"}, "message": "(var_rtx): New function.\n\n(expand_expr, case COND_EXPR): Also use target if same as singleton.\n\nFrom-SVN: r12777", "tree": {"sha": "bc4bf046438fdea53357139a4b4316ed3dcc0256", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc4bf046438fdea53357139a4b4316ed3dcc0256"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01c8a7c85882706bad219b424bab7fcf9ff3011c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01c8a7c85882706bad219b424bab7fcf9ff3011c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01c8a7c85882706bad219b424bab7fcf9ff3011c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01c8a7c85882706bad219b424bab7fcf9ff3011c/comments", "author": null, "committer": null, "parents": [{"sha": "9acc54fa93fbaea0f3b2e8976b1806d832297b45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9acc54fa93fbaea0f3b2e8976b1806d832297b45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9acc54fa93fbaea0f3b2e8976b1806d832297b45"}], "stats": {"total": 58, "additions": 40, "deletions": 18}, "files": [{"sha": "e0db90896b9ff51dcf4cacb3a33f95e983ec3a58", "filename": "gcc/expr.c", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01c8a7c85882706bad219b424bab7fcf9ff3011c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01c8a7c85882706bad219b424bab7fcf9ff3011c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=01c8a7c85882706bad219b424bab7fcf9ff3011c", "patch": "@@ -177,6 +177,7 @@ static tree save_noncopied_parts PROTO((tree, tree));\n static tree init_noncopied_parts PROTO((tree, tree));\n static int safe_from_p\t\tPROTO((rtx, tree));\n static int fixed_type_p\t\tPROTO((tree));\n+static rtx var_rtx\t\tPROTO((tree));\n static int get_pointer_alignment PROTO((tree, unsigned));\n static tree string_constant\tPROTO((tree, tree *));\n static tree c_strlen\t\tPROTO((tree));\n@@ -4635,6 +4636,24 @@ fixed_type_p (exp)\n     return 1;\n   return 0;\n }\n+\n+/* Subroutine of expand_expr: return rtx if EXP is a\n+   variable or parameter; else return 0.  */\n+\n+static rtx\n+var_rtx (exp)\n+     tree exp;\n+{\n+  STRIP_NOPS (exp);\n+  switch (TREE_CODE (exp))\n+    {\n+    case PARM_DECL:\n+    case VAR_DECL:\n+      return DECL_RTL (exp);\n+    default:\n+      return 0;\n+    }\n+}\n \f\n /* expand_expr: generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n@@ -6458,24 +6477,6 @@ expand_expr (exp, target, tmode, modifier)\n \t    return target;\n \t  }\n \n-\t/* If we are not to produce a result, we have no target.  Otherwise,\n-\t   if a target was specified use it; it will not be used as an\n-\t   intermediate target unless it is safe.  If no target, use a \n-\t   temporary.  */\n-\n-\tif (ignore)\n-\t  temp = 0;\n-\telse if (original_target\n-\t\t && safe_from_p (original_target, TREE_OPERAND (exp, 0))\n-\t\t && GET_MODE (original_target) == mode\n-\t\t && ! (GET_CODE (original_target) == MEM\n-\t\t       && MEM_VOLATILE_P (original_target)))\n-\t  temp = original_target;\n-\telse if (TREE_ADDRESSABLE (type))\n-\t  abort ();\n-\telse\n-\t  temp = assign_temp (type, 0, 0, 1);\n-\n \t/* Check for X ? A + B : A.  If we have this, we can copy\n \t   A to the output and conditionally add B.  Similarly for unary\n \t   operations.  Don't do this if X has side-effects because\n@@ -6499,6 +6500,27 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t     TREE_OPERAND (TREE_OPERAND (exp, 2), 0), 0))\n \t  singleton = TREE_OPERAND (exp, 1), unary_op = TREE_OPERAND (exp, 2);\n \n+\t/* If we are not to produce a result, we have no target.  Otherwise,\n+\t   if a target was specified use it; it will not be used as an\n+\t   intermediate target unless it is safe.  If no target, use a \n+\t   temporary.  */\n+\n+\tif (ignore)\n+\t  temp = 0;\n+\telse if (original_target\n+\t\t && (safe_from_p (original_target, TREE_OPERAND (exp, 0))\n+\t\t     || (singleton && GET_CODE (original_target) == REG\n+\t\t\t && REGNO (original_target) >= FIRST_PSEUDO_REGISTER\n+\t\t\t && original_target == var_rtx (singleton)))\n+\t\t && GET_MODE (original_target) == mode\n+\t\t && ! (GET_CODE (original_target) == MEM\n+\t\t       && MEM_VOLATILE_P (original_target)))\n+\t  temp = original_target;\n+\telse if (TREE_ADDRESSABLE (type))\n+\t  abort ();\n+\telse\n+\t  temp = assign_temp (type, 0, 0, 1);\n+\n \t/* If we had X ? A + 1 : A and we can do the test of X as a store-flag\n \t   operation, do this as A + (X != 0).  Similarly for other simple\n \t   binary operators.  */"}]}