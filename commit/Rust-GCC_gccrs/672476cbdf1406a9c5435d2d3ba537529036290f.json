{"sha": "672476cbdf1406a9c5435d2d3ba537529036290f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcyNDc2Y2JkZjE0MDZhOWM1NDM1ZDJkM2JhNTM3NTI5MDM2MjkwZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-02T21:37:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-08-02T21:37:23Z"}, "message": "cp-tree.def (LOOKUP_EXPR): Document.\n\n\t* cp-tree.def (LOOKUP_EXPR): Document.  Remove second argument.\n\t* cp-tree.h (DECL_TI_TEMPLATE): Improve documentation.\n\t* lex.c (do_identifier): Don't use a second argument, or a type,\n\twhen building LOOKUP_EXPRs.\n\t(do_identifier): Likewise.\n\t(do_scoped_id): Likewise.\n\t* method.c (hack_identifier): Improve error message.\n\t* pt.c (lookup_template_function): Don't needlessly call\n\tcopy_to_permanent or build_min.\n\t(tsubst_copy): Remove #if 0'd code.  Tsubst into LOOKUP_EXPRs if\n\tnecessary.\n\t(do_decl_instantiation): Improve error message.\n\t* tree.c (mapcar, case LOOKUP_EXPR): Don't be sorry; make a copy.\n\t(build_min): Copy the type to the permanent obstack, too.\n\nFrom-SVN: r21544", "tree": {"sha": "d2a17ab43d62c027bfce4d7a370eff0f9fdc5a22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2a17ab43d62c027bfce4d7a370eff0f9fdc5a22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/672476cbdf1406a9c5435d2d3ba537529036290f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/672476cbdf1406a9c5435d2d3ba537529036290f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/672476cbdf1406a9c5435d2d3ba537529036290f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/672476cbdf1406a9c5435d2d3ba537529036290f/comments", "author": null, "committer": null, "parents": [{"sha": "151ab2f29e19a6194329b37c8e9c379b5f0697b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/151ab2f29e19a6194329b37c8e9c379b5f0697b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/151ab2f29e19a6194329b37c8e9c379b5f0697b8"}], "stats": {"total": 138, "additions": 104, "deletions": 34}, "files": [{"sha": "b7f83bc7abcaaace78e428a76e71d125211c584a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=672476cbdf1406a9c5435d2d3ba537529036290f", "patch": "@@ -1,3 +1,20 @@\n+1998-08-02  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.def (LOOKUP_EXPR): Document.  Remove second argument.\n+\t* cp-tree.h (DECL_TI_TEMPLATE): Improve documentation.\n+\t* lex.c (do_identifier): Don't use a second argument, or a type,\n+\twhen building LOOKUP_EXPRs.\n+\t(do_identifier): Likewise.\n+\t(do_scoped_id): Likewise.\n+\t* method.c (hack_identifier): Improve error message.\n+\t* pt.c (lookup_template_function): Don't needlessly call\n+\tcopy_to_permanent or build_min.\n+\t(tsubst_copy): Remove #if 0'd code.  Tsubst into LOOKUP_EXPRs if\n+\tnecessary.\n+\t(do_decl_instantiation): Improve error message.\n+\t* tree.c (mapcar, case LOOKUP_EXPR): Don't be sorry; make a copy.\n+\t(build_min): Copy the type to the permanent obstack, too.\n+\t\n 1998-08-01  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* init.c (init_init_processing): Remove BI* handling."}, {"sha": "b610737cc2326e7e76eeb5a6563286281b39d26c", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=672476cbdf1406a9c5435d2d3ba537529036290f", "patch": "@@ -182,9 +182,14 @@ DEFTREECODE (WRAPPER, \"wrapper\", 'x', 1)\n /* A node to remember a source position.  */\n DEFTREECODE (SRCLOC, \"srcloc\", 'x', 2)\n \n+/* Used to represent deferred name lookup for dependent names while\n+   parsing a template declaration.  The first argument is an\n+   IDENTIFIER_NODE for the name in question.  The TREE_TYPE is\n+   unused.  */\n+DEFTREECODE (LOOKUP_EXPR, \"lookup_expr\", 'e', 1)\n+\n /* A whole bunch of tree codes for the initial, superficial parsing of\n    templates.  */\n-DEFTREECODE (LOOKUP_EXPR, \"lookup_expr\", 'e', 2)\n DEFTREECODE (MODOP_EXPR, \"modop_expr\", 'e', 3)\n DEFTREECODE (CAST_EXPR, \"cast_expr\", '1', 1)\n DEFTREECODE (REINTERPRET_CAST_EXPR, \"reinterpret_cast_expr\", '1', 1)"}, {"sha": "72a1655f5fe170a170690985cacfb11e901fd1b1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=672476cbdf1406a9c5435d2d3ba537529036290f", "patch": "@@ -1265,8 +1265,8 @@ struct lang_decl\n \n    As a special case, for a member friend template of a template\n    class, this value will not be a TEMPLATE_DECL, but rather a\n-   LOOKUP_EXPR indicating the name of the template and any explicit\n-   template arguments provided.  For example, in:\n+   LOOKUP_EXPR or IDENTIFIER_NODE indicating the name of the template\n+   and any explicit template arguments provided.  For example, in:\n \n      template <class T> struct S { friend void f<int>(int, double); }\n "}, {"sha": "a9166d1fd448826b54d3dd434cef8f38bf6c562c", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=672476cbdf1406a9c5435d2d3ba537529036290f", "patch": "@@ -2891,7 +2891,7 @@ do_identifier (token, parsing, args)\n \t}\n \n       if (current_template_parms)\n-\treturn build_min_nt (LOOKUP_EXPR, token, NULL_TREE);\n+\treturn build_min_nt (LOOKUP_EXPR, token);\n       else if (IDENTIFIER_OPNAME_P (token))\n \t{\n \t  if (token != ansi_opname[ERROR_MARK])\n@@ -2988,21 +2988,12 @@ do_identifier (token, parsing, args)\n   else\n     id = hack_identifier (id, token);\n \n-  if (current_template_parms)\n-    {\n-      if (is_overloaded_fn (id))\n-\t{\n-\t  tree t = build_min (LOOKUP_EXPR, unknown_type_node,\n-\t\t\t      token, get_first_fn (id));\n-\t  if (id != IDENTIFIER_NAMESPACE_VALUE (token))\n-\t    TREE_OPERAND (t, 1) = error_mark_node;\n-\t  id = t;\n-\t}\n-      else if (! TREE_PERMANENT (id) || TREE_CODE (id) == PARM_DECL\n-\t       || TREE_CODE (id) == USING_DECL)\n-\tid = build_min (LOOKUP_EXPR, TREE_TYPE (id), token, error_mark_node);\n-      /* else just use the decl */\n-    }\n+  if (current_template_parms\n+      && (is_overloaded_fn (id) \n+\t  || !TREE_PERMANENT (id)\n+\t  || TREE_CODE (id) == PARM_DECL\n+\t  || TREE_CODE (id) == USING_DECL))\n+    id = build_min_nt (LOOKUP_EXPR, token);\n       \n   return id;\n }\n@@ -3031,7 +3022,7 @@ do_scoped_id (token, parsing)\n     {\n       if (processing_template_decl)\n \t{\n-\t  id = build_min_nt (LOOKUP_EXPR, token, NULL_TREE);\n+\t  id = build_min_nt (LOOKUP_EXPR, token);\n \t  LOOKUP_EXPR_GLOBAL (id) = 1;\n \t  return id;\n \t}\n@@ -3068,9 +3059,9 @@ do_scoped_id (token, parsing)\n     {\n       if (is_overloaded_fn (id))\n \t{\n-\t  id = build_min (LOOKUP_EXPR, unknown_type_node,\n-\t\t\t  token, get_first_fn (id));\n+\t  id = build_min_nt (LOOKUP_EXPR, token);\n \t  LOOKUP_EXPR_GLOBAL (id) = 1;\n+\t  return id;\n \t}\n       /* else just use the decl */\n     }"}, {"sha": "18e638cda75f8cc3e083a20014495db241738278", "filename": "gcc/cp/method.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=672476cbdf1406a9c5435d2d3ba537529036290f", "patch": "@@ -1845,8 +1845,16 @@ hack_identifier (value, name)\n     {\n       if (current_class_ptr == NULL_TREE)\n \t{\n-\t  error (\"request for member `%s' in static member function\",\n-\t\t IDENTIFIER_POINTER (DECL_NAME (value)));\n+\t  if (current_function_decl \n+\t      && DECL_STATIC_FUNCTION_P (current_function_decl))\n+\t    cp_error (\"invalid use of member `%D' in static member function\",\n+\t\t      value);\n+\t  else\n+\t    /* We can get here when processing a bad default\n+\t       argument, like:\n+\t         struct S { int a; void f(int i = a); }  */\n+\t    cp_error (\"invalid use of member `%D'\", value);\n+\n \t  return error_mark_node;\n \t}\n       TREE_USED (current_class_ptr) = 1;"}, {"sha": "3906eb38d992f9113cd8afc4fbd4cc8f817ff26a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=672476cbdf1406a9c5435d2d3ba537529036290f", "patch": "@@ -2999,14 +2999,14 @@ lookup_template_function (fns, arglist)\n       return error_mark_node;\n     }\n \n-  if (arglist != NULL_TREE && !TREE_PERMANENT (arglist))\n-    copy_to_permanent (arglist);\n-\n   type = TREE_TYPE (fns);\n   if (TREE_CODE (fns) == OVERLOAD || !type)\n     type = unknown_type_node;\n \n-  return build_min (TEMPLATE_ID_EXPR, type, fns, arglist);  \n+  if (processing_template_decl)\n+    return build_min (TEMPLATE_ID_EXPR, type, fns, arglist);  \n+  else\n+    return build (TEMPLATE_ID_EXPR, type, fns, arglist);\n }\n \n /* Within the scope of a template class S<T>, the name S gets bound\n@@ -5469,11 +5469,25 @@ tsubst_copy (t, args, in_decl)\n       else\n \treturn t;\n \n-#if 0\n-    case IDENTIFIER_NODE:\n-      return do_identifier (t, 0);\n-#endif\n-      \n+    case LOOKUP_EXPR:\n+      {\n+\t/* We must tsbust into a LOOKUP_EXPR in case the names to\n+\t   which it refers is a conversion operator; in that case the\n+\t   name will change.  We avoid making unnecessary copies,\n+\t   however.  */\n+\t\n+\ttree id = tsubst_copy (TREE_OPERAND (t, 0), args, in_decl);\n+\n+\tif (id != TREE_OPERAND (t, 0))\n+\t  {\n+\t    tree r = build_nt (LOOKUP_EXPR, id);\n+\t    LOOKUP_EXPR_GLOBAL (r) = LOOKUP_EXPR_GLOBAL (t);\n+\t    t = r;\n+\t  }\n+\n+\treturn t;\n+      }\n+\n     case CAST_EXPR:\n     case REINTERPRET_CAST_EXPR:\n     case CONST_CAST_EXPR:\n@@ -7236,6 +7250,16 @@ do_decl_instantiation (declspecs, declarator, storage)\n       cp_error (\"explicit instantiation of `%#D'\", decl);\n       return;\n     }\n+  else if (DECL_TEMPLATE_SPECIALIZATION (decl))\n+    /* [temp.spec]\n+\n+       No program shall both explicit instantiation and explicit\n+       specialize a template.  */\n+    {\n+      cp_error (\"explicit instantiation of `%#D' after\", decl);\n+      cp_error_at (\"explicit specialization here\", decl);\n+      return;\n+    }\n   else if (DECL_TEMPLATE_INSTANTIATION (decl))\n     result = decl;\n "}, {"sha": "8b782bbb85c3a5861e5ca09e2daefeec94b59e34", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=672476cbdf1406a9c5435d2d3ba537529036290f", "patch": "@@ -1784,6 +1784,11 @@ mapcar (t, func)\n       TREE_OPERAND (t, 2) = mapcar (TREE_OPERAND (t, 2), func);\n       return t;\n \n+    case LOOKUP_EXPR:\n+      t = copy_node (t);\n+      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n+      return t;\n+\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \treturn build_ptrmemfunc_type\n@@ -2022,7 +2027,7 @@ build_min VPROTO((enum tree_code code, tree tt, ...))\n \n   t = make_node (code);\n   length = tree_code_length[(int) code];\n-  TREE_TYPE (t) = tt;\n+  TREE_TYPE (t) = copy_to_permanent (tt);\n   TREE_COMPLEXITY (t) = lineno;\n \n   for (i = 0; i < length; i++)"}, {"sha": "f3e0b359e19aed8c0897faf02891b53244ddcf2f", "filename": "gcc/testsuite/g++.old-deja/g++.pt/conv2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fconv2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fconv2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fconv2.C?ref=672476cbdf1406a9c5435d2d3ba537529036290f", "patch": "@@ -0,0 +1,15 @@\n+// Build don't link:\n+\n+template<class T>\n+class A {\n+public:\n+  operator const T*() const;\n+  const T* cast() const;\n+};\n+\n+template<class T>\n+const T* A<T>::cast() const {\n+  return operator const T*();\n+}\n+\n+template class A<char>;"}, {"sha": "f9b601125b4cc39eb86ad6bbfe542220fa226a18", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec19.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672476cbdf1406a9c5435d2d3ba537529036290f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec19.C?ref=672476cbdf1406a9c5435d2d3ba537529036290f", "patch": "@@ -0,0 +1,5 @@\n+// Build don't link:\n+\n+template<class T> T f(T o) { return o; }\n+template<> int f(int o)    { return o; } // ERROR - after specialization\n+template int f(int);  // ERROR - explicit instantiation"}]}