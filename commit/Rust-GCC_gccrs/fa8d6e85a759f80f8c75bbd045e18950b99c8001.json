{"sha": "fa8d6e85a759f80f8c75bbd045e18950b99c8001", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE4ZDZlODVhNzU5ZjgwZjhjNzViYmQwNDVlMTg5NTBiOTljODAwMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-04-19T12:23:55Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-04-19T12:23:55Z"}, "message": "cp-tree.h (finish_static_data_member_decl): New function.\n\n\t* cp-tree.h (finish_static_data_member_decl): New function.\n\t* decl2.c (finish_static_data_member_decl): Split out from ...\n\t(grokfield): Here.\n\t* pt.c (instantiate_class_template): Use it here instead of\n\ttrying to fake it.\n\t(tsubst_decl): Don't set DECL_ASSEMBLER_NAME;\n\tfinish_static_data_member_decl will do that.  Explicit set\n\tDECL_EXTERNAL to match non-template processing.\n\nFrom-SVN: r26548", "tree": {"sha": "21d5e12c82cd4a8ee3cc6711a20833bb723dd020", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21d5e12c82cd4a8ee3cc6711a20833bb723dd020"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa8d6e85a759f80f8c75bbd045e18950b99c8001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa8d6e85a759f80f8c75bbd045e18950b99c8001", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa8d6e85a759f80f8c75bbd045e18950b99c8001", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa8d6e85a759f80f8c75bbd045e18950b99c8001/comments", "author": null, "committer": null, "parents": [{"sha": "80e9dcb4b2227b960b43f5356531a004a8565fe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80e9dcb4b2227b960b43f5356531a004a8565fe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80e9dcb4b2227b960b43f5356531a004a8565fe1"}], "stats": {"total": 149, "additions": 100, "deletions": 49}, "files": [{"sha": "d8bdb2c35af947e8329cf31aea51b7db88ca7660", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa8d6e85a759f80f8c75bbd045e18950b99c8001/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa8d6e85a759f80f8c75bbd045e18950b99c8001/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fa8d6e85a759f80f8c75bbd045e18950b99c8001", "patch": "@@ -1,3 +1,14 @@\n+1999-04-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (finish_static_data_member_decl): New function.\n+\t* decl2.c (finish_static_data_member_decl): Split out from ...\n+\t(grokfield): Here.\n+\t* pt.c (instantiate_class_template): Use it here instead of \n+\ttrying to fake it.\n+\t(tsubst_decl): Don't set DECL_ASSEMBLER_NAME;\n+\tfinish_static_data_member_decl will do that.  Explicit set\n+\tDECL_EXTERNAL to match non-template processing.\n+\t\n 1999-04-18  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (finish_class_definition): Add parameter."}, {"sha": "21392cebbba5e8d4172c8f5b4b842aee2687e0ad", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa8d6e85a759f80f8c75bbd045e18950b99c8001/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa8d6e85a759f80f8c75bbd045e18950b99c8001/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fa8d6e85a759f80f8c75bbd045e18950b99c8001", "patch": "@@ -2947,6 +2947,7 @@ extern void check_default_args\t\t\tPROTO((tree));\n extern void mark_used\t\t\t\tPROTO((tree));\n extern tree handle_class_head\t\t\tPROTO((tree, tree, tree));\n extern tree lookup_arg_dependent                PROTO((tree, tree, tree));\n+extern void finish_static_data_member_decl      PROTO((tree, tree, tree, int, int));\n \n /* in errfn.c */\n /* The cp_* functions aren't suitable for ATTRIBUTE_PRINTF. */"}, {"sha": "744baae1f20c082d9e7373370628f02cb4baf9da", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 57, "deletions": 37, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa8d6e85a759f80f8c75bbd045e18950b99c8001/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa8d6e85a759f80f8c75bbd045e18950b99c8001/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=fa8d6e85a759f80f8c75bbd045e18950b99c8001", "patch": "@@ -1456,6 +1456,61 @@ check_classfn (ctype, function)\n   return NULL_TREE;\n }\n \n+/* We have just processed the DECL, which is a static data member.\n+   Its initializer, if present, is INIT.  The ASMSPEC_TREE, if\n+   present, is the assembly-language name for the data member.\n+   NEED_POP and FLAGS are as for cp_finish_decl.  */\n+\n+void\n+finish_static_data_member_decl (decl, init, asmspec_tree, need_pop, flags)\n+     tree decl;\n+     tree init;\n+     tree asmspec_tree;\n+     int need_pop;\n+     int flags;\n+{\n+  char* asmspec = 0;\n+\n+  if (asmspec_tree)\n+    asmspec = TREE_STRING_POINTER (asmspec_tree);\n+\n+  my_friendly_assert (TREE_PUBLIC (decl), 0);\n+\n+  /* We cannot call pushdecl here, because that would fill in the\n+     decl of our TREE_CHAIN.  Instead, we modify cp_finish_decl to do\n+     the right thing, namely, to put this decl out straight away.  */\n+  /* current_class_type can be NULL_TREE in case of error.  */\n+  if (!asmspec && current_class_type)\n+    {\n+      DECL_INITIAL (decl) = error_mark_node;\n+      DECL_ASSEMBLER_NAME (decl)\n+\t= build_static_name (current_class_type, DECL_NAME (decl));\n+    }\n+  if (! processing_template_decl)\n+    pending_statics = perm_tree_cons (NULL_TREE, decl, pending_statics);\n+      \n+  /* Static consts need not be initialized in the class definition.  */\n+  if (init != NULL_TREE && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n+    {\n+      static int explanation = 0;\n+\t  \n+      error (\"initializer invalid for static member with constructor\");\n+      if (explanation++ == 0)\n+\terror (\"(you really want to initialize it separately)\");\n+      init = 0;\n+    }\n+  /* Force the compiler to know when an uninitialized static const\n+     member is being used.  */\n+  if (CP_TYPE_CONST_P (TREE_TYPE (decl)) && init == 0)\n+    TREE_USED (decl) = 1;\n+  DECL_INITIAL (decl) = init;\n+  DECL_IN_AGGR_P (decl) = 1;\n+  DECL_CONTEXT (decl) = current_class_type;\n+  DECL_CLASS_CONTEXT (decl) = current_class_type;\n+\n+  cp_finish_decl (decl, init, asmspec_tree, need_pop, flags);\n+}\n+\n /* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)\n    of a structure component, returning a FIELD_DECL node.\n    QUALS is a list of type qualifiers for this decl (such as for declaring\n@@ -1635,43 +1690,8 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \n   if (TREE_CODE (value) == VAR_DECL)\n     {\n-      my_friendly_assert (TREE_PUBLIC (value), 0);\n-\n-      /* We cannot call pushdecl here, because that would\n-\t fill in the value of our TREE_CHAIN.  Instead, we\n-\t modify cp_finish_decl to do the right thing, namely, to\n-\t put this decl out straight away.  */\n-      /* current_class_type can be NULL_TREE in case of error.  */\n-      if (asmspec == 0 && current_class_type)\n-\t{\n-\t  TREE_PUBLIC (value) = 1;\n-\t  DECL_INITIAL (value) = error_mark_node;\n-\t  DECL_ASSEMBLER_NAME (value)\n-\t    = build_static_name (current_class_type, DECL_NAME (value));\n-\t}\n-      if (! processing_template_decl)\n-\tpending_statics = perm_tree_cons (NULL_TREE, value, pending_statics);\n-      \n-      /* Static consts need not be initialized in the class definition.  */\n-      if (init != NULL_TREE && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (value)))\n-\t{\n-\t  static int explanation = 0;\n-\t  \n-\t  error (\"initializer invalid for static member with constructor\");\n-\t  if (explanation++ == 0)\n-\t    error (\"(you really want to initialize it separately)\");\n-\t  init = 0;\n-\t}\n-      /* Force the compiler to know when an uninitialized static\n-\t const member is being used.  */\n-      if (CP_TYPE_CONST_P (TREE_TYPE (value)) && init == 0)\n-\tTREE_USED (value) = 1;\n-      DECL_INITIAL (value) = init;\n-      DECL_IN_AGGR_P (value) = 1;\n-      DECL_CONTEXT (value) = current_class_type;\n-      DECL_CLASS_CONTEXT (value) = current_class_type;\n-\n-      cp_finish_decl (value, init, asmspec_tree, 1, flags);\n+      finish_static_data_member_decl (value, init, asmspec_tree, \n+\t\t\t\t      /*need_pop=*/1, flags);\n       return value;\n     }\n   if (TREE_CODE (value) == FIELD_DECL)"}, {"sha": "f2e40b32242ed2f5a27e18146c7275233b0fd862", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa8d6e85a759f80f8c75bbd045e18950b99c8001/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa8d6e85a759f80f8c75bbd045e18950b99c8001/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fa8d6e85a759f80f8c75bbd045e18950b99c8001", "patch": "@@ -4982,16 +4982,19 @@ instantiate_class_template (type)\n \tr = tsubst (t, args, /*complain=*/1, NULL_TREE);\n \tif (TREE_CODE (r) == VAR_DECL)\n \t  {\n-\t    pending_statics = perm_tree_cons (NULL_TREE, r, pending_statics);\n-\t    /* Perhaps we should do more of grokfield here.  */\n+\t    tree init;\n+\n \t    if (DECL_DEFINED_IN_CLASS_P (r))\n-\t      /* Set up DECL_INITIAL, since tsubst doesn't.  */\n-\t      DECL_INITIAL (r) = tsubst_expr (DECL_INITIAL (t), args,\n-\t\t\t\t\t      /*complain=*/1, NULL_TREE);\n-\t    start_decl_1 (r);\n-\t    DECL_IN_AGGR_P (r) = 1;\n-\t    DECL_EXTERNAL (r) = 1;\n-\t    cp_finish_decl (r, DECL_INITIAL (r), NULL_TREE, 0, 0);\n+\t      init = tsubst_expr (DECL_INITIAL (t), args,\n+\t\t\t\t  /*complain=*/1, NULL_TREE);\n+\t    else\n+\t      init = NULL_TREE;\n+\n+\t    finish_static_data_member_decl (r, init,\n+\t\t\t\t\t    /*asmspec_tree=*/NULL_TREE, \n+\t\t\t\t\t    /*need_pop=*/0,\n+\t\t\t\t\t    /*flags=*/0);\n+\n \t    if (DECL_DEFINED_IN_CLASS_P (r))\n \t      check_static_variable_definition (r, TREE_TYPE (r));\n \t  }\n@@ -5825,9 +5828,6 @@ tsubst_decl (t, args, type, in_decl)\n \tTREE_TYPE (r) = type;\n \tc_apply_type_quals_to_decl (CP_TYPE_QUALS (type), r);\n \tDECL_CONTEXT (r) = ctx;\n-\tif (TREE_STATIC (r))\n-\t  DECL_ASSEMBLER_NAME (r)\n-\t    = build_static_name (DECL_CONTEXT (r), DECL_NAME (r));\n \n \t/* Don't try to expand the initializer until someone tries to use\n \t   this variable; otherwise we run into circular dependencies.  */\n@@ -5837,6 +5837,11 @@ tsubst_decl (t, args, type, in_decl)\n \tcopy_lang_decl (r);\n \tDECL_CLASS_CONTEXT (r) = DECL_CONTEXT (r);\n \n+\t/* A static data member declaration is always marked external\n+\t   when it is declared in-class, even if an initializer is\n+\t   present.  We mimic the non-template processing here.  */\n+\tDECL_EXTERNAL (r) = 1;\n+\n \tDECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n \tSET_DECL_IMPLICIT_INSTANTIATION (r);\n \tregister_specialization (r, gen_tmpl, argvec);"}, {"sha": "282f78fe8f828b545a6a541d537b39be20c71cdd", "filename": "gcc/testsuite/g++.old-deja/g++.pt/static7.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa8d6e85a759f80f8c75bbd045e18950b99c8001/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fstatic7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa8d6e85a759f80f8c75bbd045e18950b99c8001/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fstatic7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fstatic7.C?ref=fa8d6e85a759f80f8c75bbd045e18950b99c8001", "patch": "@@ -0,0 +1,14 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T>\n+struct S {\n+  S() {}\n+\n+  static S s;\n+};\n+\n+template <class T>\n+S<T> S<T>::s;\n+\n+S<int> si;"}]}