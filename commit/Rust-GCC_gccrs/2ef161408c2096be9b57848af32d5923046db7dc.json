{"sha": "2ef161408c2096be9b57848af32d5923046db7dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVmMTYxNDA4YzIwOTZiZTliNTc4NDhhZjMyZDU5MjMwNDZkYjdkYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-12-29T07:31:51Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-12-29T07:31:51Z"}, "message": "cp-tree.h (do_inline_function_hair): Remove.\n\n\t* cp-tree.h (do_inline_function_hair): Remove.\n\t* class.c (layout_class_type): New function, split out from\n\tfinish_struct_1.\n\t(fixup_pending_inline): Likewise.\n\t(fixup_inline_methods): New function.\n\t* method.c (fixup_pending_inline): Remove.\n\t(do_inline_function_hair): Likewise.\n\n\t* decl.c (BOOL_TYPE_SIZE): Bools always have size `1' under the\n\tnew ABI.\n\nFrom-SVN: r31115", "tree": {"sha": "e7de44b52c7132ed24ee68e6bc2a73617ba242cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7de44b52c7132ed24ee68e6bc2a73617ba242cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ef161408c2096be9b57848af32d5923046db7dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ef161408c2096be9b57848af32d5923046db7dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ef161408c2096be9b57848af32d5923046db7dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ef161408c2096be9b57848af32d5923046db7dc/comments", "author": null, "committer": null, "parents": [{"sha": "fee7654ec68b5a1a72169620a5609ce7a74cfa75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fee7654ec68b5a1a72169620a5609ce7a74cfa75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fee7654ec68b5a1a72169620a5609ce7a74cfa75"}], "stats": {"total": 282, "additions": 155, "deletions": 127}, "files": [{"sha": "6e9e6fb950dda4db1673119b2e8c3d9cc5ce2e44", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef161408c2096be9b57848af32d5923046db7dc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef161408c2096be9b57848af32d5923046db7dc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2ef161408c2096be9b57848af32d5923046db7dc", "patch": "@@ -1,5 +1,16 @@\n 1999-12-28  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (do_inline_function_hair): Remove.\n+\t* class.c (layout_class_type): New function, split out from\n+\tfinish_struct_1.\n+\t(fixup_pending_inline): Likewise.\n+\t(fixup_inline_methods): New function.\n+\t* method.c (fixup_pending_inline): Remove.\n+\t(do_inline_function_hair): Likewise.\n+\t\n+\t* decl.c (BOOL_TYPE_SIZE): Bools always have size `1' under the\n+\tnew ABI.\n+\t\n \t* cp-tree.h (lang_type): Replace abstract_virtuals with pure_virtuals.\n \t(CLASSTYPE_ABSTRACT_VIRTUALS): Rename to ...\n \t(CLASSTYPE_PURE_VIRTUALS): ... this.\n@@ -17,6 +28,7 @@\n \t(build_vtbl_initializer): Likewise.\n \t(override_one_vtable): Likewise.\n \t(check_methods): Likewise.\n+\n \t* decl.c (duplicate_decls): Likewise.\n \t(redeclaration_error_message): Likewise.\n \t(lang_mark_tree): Likewise."}, {"sha": "c381efb3ca291f8a566e6137eda8eb7b61fdffb6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 139, "deletions": 73, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef161408c2096be9b57848af32d5923046db7dc/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef161408c2096be9b57848af32d5923046db7dc/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=2ef161408c2096be9b57848af32d5923046db7dc", "patch": "@@ -134,6 +134,9 @@ static void remove_zero_width_bit_fields PROTO((tree));\n static void check_bases PROTO((tree, int *, int *, int *));\n static void check_bases_and_members PROTO((tree, int *));\n static void create_vtable_ptr PROTO((tree, int *, int *, int *, tree *, tree *));\n+static void layout_class_type PROTO((tree, int *, int *, int *, tree *, tree *));\n+static void fixup_pending_inline PROTO((struct pending_inline *));\n+static void fixup_inline_methods PROTO((tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -4112,99 +4115,93 @@ create_vtable_ptr (t, empty_p, has_virtual_p, max_has_virtual_p,\n     }\n }\n \n-/* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n-   (or C++ class declaration).\n-\n-   For C++, we must handle the building of derived classes.\n-   Also, C++ allows static class members.  The way that this is\n-   handled is to keep the field name where it is (as the DECL_NAME\n-   of the field), and place the overloaded decl in the DECL_FIELD_BITPOS\n-   of the field.  layout_record and layout_union will know about this.\n+/* Fixup the inline function given by INFO now that the class is\n+   complete.  */\n \n-   More C++ hair: inline functions have text in their\n-   DECL_PENDING_INLINE_INFO nodes which must somehow be parsed into\n-   meaningful tree structure.  After the struct has been laid out, set\n-   things up so that this can happen.\n+static void\n+fixup_pending_inline (info)\n+     struct pending_inline *info;\n+{\n+  if (info)\n+    {\n+      tree args;\n+      tree fn = info->fndecl;\n \n-   And still more: virtual functions.  In the case of single inheritance,\n-   when a new virtual function is seen which redefines a virtual function\n-   from the base class, the new virtual function is placed into\n-   the virtual function table at exactly the same address that\n-   it had in the base class.  When this is extended to multiple\n-   inheritance, the same thing happens, except that multiple virtual\n-   function tables must be maintained.  The first virtual function\n-   table is treated in exactly the same way as in the case of single\n-   inheritance.  Additional virtual function tables have different\n-   DELTAs, which tell how to adjust `this' to point to the right thing.\n+      args = DECL_ARGUMENTS (fn);\n+      while (args)\n+\t{\n+\t  DECL_CONTEXT (args) = fn;\n+\t  args = TREE_CHAIN (args);\n+\t}\n+    }\n+}\n \n-   ATTRIBUTES is the set of decl attributes to be applied, if any.  */\n+/* Fixup the inline methods and friends in TYPE now that TYPE is\n+   complete.  */\n \n-void\n-finish_struct_1 (t)\n-     tree t;\n+static void\n+fixup_inline_methods (type)\n+     tree type;\n {\n-  tree x;\n-  int has_virtual;\n-  int max_has_virtual;\n-  tree pending_virtuals = NULL_TREE;\n-  tree pending_hard_virtuals = NULL_TREE;\n-  int n_fields = 0;\n-  tree vfield;\n-  int n_baseclasses;\n-  int empty = 1;\n-  tree inline_friends;\n+  tree method = TYPE_METHODS (type);\n \n-  if (TYPE_SIZE (t))\n+  if (method && TREE_CODE (method) == TREE_VEC)\n     {\n-      if (IS_AGGR_TYPE (t))\n-\tcp_error (\"redefinition of `%#T'\", t);\n+      if (TREE_VEC_ELT (method, 1))\n+\tmethod = TREE_VEC_ELT (method, 1);\n+      else if (TREE_VEC_ELT (method, 0))\n+\tmethod = TREE_VEC_ELT (method, 0);\n       else\n-\tmy_friendly_abort (172);\n-      popclass ();\n-      return;\n+\tmethod = TREE_VEC_ELT (method, 2);\n     }\n \n-  GNU_xref_decl (current_function_decl, t);\n-\n-  /* If this type was previously laid out as a forward reference,\n-     make sure we lay it out again.  */\n+  /* Do inline member functions.  */\n+  for (; method; method = TREE_CHAIN (method))\n+    fixup_pending_inline (DECL_PENDING_INLINE_INFO (method));\n \n-  TYPE_SIZE (t) = NULL_TREE;\n-  CLASSTYPE_GOT_SEMICOLON (t) = 0;\n-\n-  CLASSTYPE_VFIELD_PARENT (t) = -1;\n-  has_virtual = 0;\n-  max_has_virtual = 0;\n-  CLASSTYPE_RTTI (t) = NULL_TREE;\n-  n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n+  /* Do friends.  */\n+  for (method = CLASSTYPE_INLINE_FRIENDS (type); \n+       method; \n+       method = TREE_CHAIN (method))\n+    fixup_pending_inline (DECL_PENDING_INLINE_INFO (TREE_VALUE (method)));\n+}\n \n-  /* Do end-of-class semantic processing: checking the validity of the\n-     bases and members and adding implicitly generated methods.  */\n-  check_bases_and_members (t, &empty);\n+/* Calculate the TYPE_SIZE, TYPE_ALIGN, etc for T.  Calculate\n+   BINFO_OFFSETs for all of the base-classes.  Position the vtable\n+   pointer.  */\n \n+static void\n+layout_class_type (t, empty_p, has_virtual_p, max_has_virtual_p,\n+\t\t   pending_virtuals_p, pending_hard_virtuals_p)\n+     tree t;\n+     int *empty_p;\n+     int *has_virtual_p;\n+     int *max_has_virtual_p;\n+     tree *pending_virtuals_p;\n+     tree *pending_hard_virtuals_p;\n+{\n   /* Add pointers to all of our virtual base-classes.  */\n-  TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (t, &empty),\n+  TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (t, empty_p),\n \t\t\t     TYPE_FIELDS (t));\n   /* Build FIELD_DECLs for all of the non-virtual base-types.  */\n-  TYPE_FIELDS (t) = chainon (build_base_fields (t, &empty), \n+  TYPE_FIELDS (t) = chainon (build_base_fields (t, empty_p), \n \t\t\t     TYPE_FIELDS (t));\n \n   /* Create a pointer to our virtual function table.  */\n-  create_vtable_ptr (t, &empty, &has_virtual, &max_has_virtual,\n-\t\t     &pending_virtuals, &pending_hard_virtuals);\n+  create_vtable_ptr (t, empty_p, has_virtual_p, max_has_virtual_p,\n+\t\t     pending_virtuals_p, pending_hard_virtuals_p);\n \n   /* CLASSTYPE_INLINE_FRIENDS is really TYPE_NONCOPIED_PARTS.  Thus,\n      we have to save this before we start modifying\n      TYPE_NONCOPIED_PARTS.  */\n-  inline_friends = CLASSTYPE_INLINE_FRIENDS (t);\n-  CLASSTYPE_INLINE_FRIENDS (t) = NULL_TREE;\n+  fixup_inline_methods (t);\n \n   /* We make all structures have at least one element, so that they\n      have non-zero size.  The field that we add here is fake, in the\n      sense that, for example, we don't want people to be able to\n      initialize it later.  So, we add it just long enough to let the\n      back-end lay out the type, and then remove it.  */\n-  if (empty)\n+  if (*empty_p)\n     {\n       tree decl = build_lang_decl\n \t(FIELD_DECL, NULL_TREE, char_type_node);\n@@ -4224,7 +4221,7 @@ finish_struct_1 (t)\n \n   /* If we added an extra field to make this class non-empty, remove\n      it now.  */\n-  if (empty)\n+  if (*empty_p)\n     TYPE_FIELDS (t) = TREE_CHAIN (TYPE_FIELDS (t));\n \n   /* Delete all zero-width bit-fields from the list of fields.  Now\n@@ -4233,7 +4230,7 @@ finish_struct_1 (t)\n \n   /* Remember the size and alignment of the class before adding\n      the virtual bases.  */\n-  if (empty && flag_new_abi)\n+  if (*empty_p && flag_new_abi)\n     CLASSTYPE_SIZE (t) = integer_zero_node;\n   else if (flag_new_abi && TYPE_HAS_COMPLEX_INIT_REF (t)\n \t   && TYPE_HAS_COMPLEX_ASSIGN_REF (t))\n@@ -4245,16 +4242,88 @@ finish_struct_1 (t)\n   /* Set the TYPE_DECL for this type to contain the right\n      value for DECL_OFFSET, so that we can use it as part\n      of a COMPONENT_REF for multiple inheritance.  */\n-\n   layout_decl (TYPE_MAIN_DECL (t), 0);\n \n   /* Now fix up any virtual base class types that we left lying\n      around.  We must get these done before we try to lay out the\n      virtual function table.  */\n-\n-  if (n_baseclasses)\n+  if (CLASSTYPE_N_BASECLASSES (t))\n     /* layout_basetypes will remove the base subobject fields.  */\n-    max_has_virtual = layout_basetypes (t, max_has_virtual);\n+    *max_has_virtual_p = layout_basetypes (t, *max_has_virtual_p);\n+}\n+     \n+/* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n+   (or C++ class declaration).\n+\n+   For C++, we must handle the building of derived classes.\n+   Also, C++ allows static class members.  The way that this is\n+   handled is to keep the field name where it is (as the DECL_NAME\n+   of the field), and place the overloaded decl in the DECL_FIELD_BITPOS\n+   of the field.  layout_record and layout_union will know about this.\n+\n+   More C++ hair: inline functions have text in their\n+   DECL_PENDING_INLINE_INFO nodes which must somehow be parsed into\n+   meaningful tree structure.  After the struct has been laid out, set\n+   things up so that this can happen.\n+\n+   And still more: virtual functions.  In the case of single inheritance,\n+   when a new virtual function is seen which redefines a virtual function\n+   from the base class, the new virtual function is placed into\n+   the virtual function table at exactly the same address that\n+   it had in the base class.  When this is extended to multiple\n+   inheritance, the same thing happens, except that multiple virtual\n+   function tables must be maintained.  The first virtual function\n+   table is treated in exactly the same way as in the case of single\n+   inheritance.  Additional virtual function tables have different\n+   DELTAs, which tell how to adjust `this' to point to the right thing.\n+\n+   ATTRIBUTES is the set of decl attributes to be applied, if any.  */\n+\n+void\n+finish_struct_1 (t)\n+     tree t;\n+{\n+  tree x;\n+  int has_virtual;\n+  int max_has_virtual;\n+  tree pending_virtuals = NULL_TREE;\n+  tree pending_hard_virtuals = NULL_TREE;\n+  int n_fields = 0;\n+  tree vfield;\n+  int n_baseclasses;\n+  int empty = 1;\n+\n+  if (TYPE_SIZE (t))\n+    {\n+      if (IS_AGGR_TYPE (t))\n+\tcp_error (\"redefinition of `%#T'\", t);\n+      else\n+\tmy_friendly_abort (172);\n+      popclass ();\n+      return;\n+    }\n+\n+  GNU_xref_decl (current_function_decl, t);\n+\n+  /* If this type was previously laid out as a forward reference,\n+     make sure we lay it out again.  */\n+\n+  TYPE_SIZE (t) = NULL_TREE;\n+  CLASSTYPE_GOT_SEMICOLON (t) = 0;\n+\n+  CLASSTYPE_VFIELD_PARENT (t) = -1;\n+  has_virtual = 0;\n+  max_has_virtual = 0;\n+  CLASSTYPE_RTTI (t) = NULL_TREE;\n+  n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n+\n+  /* Do end-of-class semantic processing: checking the validity of the\n+     bases and members and adding implicitly generated methods.  */\n+  check_bases_and_members (t, &empty);\n+\n+  /* Layout the class itself.  */\n+  layout_class_type (t, &empty, &has_virtual, &max_has_virtual,\n+\t\t     &pending_virtuals, &pending_hard_virtuals);\n \n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n     {\n@@ -4492,9 +4561,6 @@ finish_struct_1 (t)\n \t}\n     }\n \n-  /* Write out inline function definitions.  */\n-  do_inline_function_hair (t, inline_friends);\n-\n   if (CLASSTYPE_VSIZE (t) != 0)\n     {\n       /* In addition to this one, all the other vfields should be listed.  */"}, {"sha": "0935f1ec11e9bfcb7fbf5a8758c4adfc47801abd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef161408c2096be9b57848af32d5923046db7dc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef161408c2096be9b57848af32d5923046db7dc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2ef161408c2096be9b57848af32d5923046db7dc", "patch": "@@ -3757,7 +3757,6 @@ extern int cp_type_qual_from_rid                PROTO((tree));\n \n /* in method.c */\n extern void init_method\t\t\t\tPROTO((void));\n-extern void do_inline_function_hair\t\tPROTO((tree, tree));\n extern char *build_overload_name\t\tPROTO((tree, int, int));\n extern tree build_static_name\t\t\tPROTO((tree, tree));\n extern tree build_decl_overload\t\t\tPROTO((tree, tree, int));"}, {"sha": "e1b27ce82c83a64e9feebd095301b1d52362ca8a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef161408c2096be9b57848af32d5923046db7dc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef161408c2096be9b57848af32d5923046db7dc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2ef161408c2096be9b57848af32d5923046db7dc", "patch": "@@ -72,7 +72,10 @@ int ggc_p = 1;\n \n #ifndef BOOL_TYPE_SIZE\n #ifdef SLOW_BYTE_ACCESS\n-#define BOOL_TYPE_SIZE ((SLOW_BYTE_ACCESS) ? (POINTER_SIZE) : (CHAR_TYPE_SIZE))\n+/* In the new ABI, `bool' has size and alignment `1', on all\n+   platforms.  */\n+#define BOOL_TYPE_SIZE \\\n+  ((SLOW_BYTE_ACCESS && !flag_new_abi) ? (POINTER_SIZE) : (CHAR_TYPE_SIZE))\n #else\n #define BOOL_TYPE_SIZE CHAR_TYPE_SIZE\n #endif"}, {"sha": "12d96168001c392034089fd6c4ca61101f7a3ec4", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef161408c2096be9b57848af32d5923046db7dc/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef161408c2096be9b57848af32d5923046db7dc/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=2ef161408c2096be9b57848af32d5923046db7dc", "patch": "@@ -98,7 +98,6 @@ static int is_back_referenceable_type PROTO((tree));\n static int check_btype PROTO((tree));\n static void build_mangled_name_for_type PROTO((tree));\n static void build_mangled_name_for_type_with_Gcode PROTO((tree, int));\n-static void fixup_pending_inline PROTO((struct pending_inline *));\n \n # define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)\n # define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))\n@@ -143,57 +142,6 @@ init_method ()\n    value.  */\n static char digit_buffer[128];\n \n-/* Fixup the inline function given by INFO now that the class is\n-   complete.  */\n-\n-static void\n-fixup_pending_inline (info)\n-     struct pending_inline *info;\n-{\n-  if (info)\n-    {\n-      tree args;\n-      tree fn = info->fndecl;\n-\n-      args = DECL_ARGUMENTS (fn);\n-      while (args)\n-\t{\n-\t  DECL_CONTEXT (args) = fn;\n-\t  args = TREE_CHAIN (args);\n-\t}\n-    }\n-}\n-\n-/* Move inline function definitions out of structure so that they\n-   can be processed normally.  CNAME is the name of the class\n-   we are working from, METHOD_LIST is the list of method lists\n-   of the structure.  We delete friend methods here, after\n-   saving away their inline function definitions (if any).  */\n-\n-void\n-do_inline_function_hair (type, friend_list)\n-     tree type, friend_list;\n-{\n-  tree method = TYPE_METHODS (type);\n-\n-  if (method && TREE_CODE (method) == TREE_VEC)\n-    {\n-      if (TREE_VEC_ELT (method, 1))\n-\tmethod = TREE_VEC_ELT (method, 1);\n-      else if (TREE_VEC_ELT (method, 0))\n-\tmethod = TREE_VEC_ELT (method, 0);\n-      else\n-\tmethod = TREE_VEC_ELT (method, 2);\n-    }\n-\n-  /* Do inline member functions.  */\n-  for (; method; method = TREE_CHAIN (method))\n-    fixup_pending_inline (DECL_PENDING_INLINE_INFO (method));\n-\n-  /* Do friends.  */\n-  for (; friend_list; friend_list = TREE_CHAIN (friend_list))\n-    fixup_pending_inline (DECL_PENDING_INLINE_INFO (TREE_VALUE (friend_list)));\n-}\n \f\n /* Here is where overload code starts.  */\n "}]}