{"sha": "acd9204960d4417b564e75ce036618359ce5eeda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNkOTIwNDk2MGQ0NDE3YjU2NGU3NWNlMDM2NjE4MzU5Y2U1ZWVkYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-06-25T01:09:06Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-06-25T01:09:06Z"}, "message": "alpha.c (alpha_function_name): Delete.\n\n        * alpha.c (alpha_function_name): Delete.\n        (alpha_ra_ever_killed): Notice current_function_is_thunk.\n        (alpha_sa_mask, alpha_sa_size, alpha_does_function_need_gp): Likewise.\n        (alpha_start_function): Reorg from output_prologue.\n        (alpha_end_function): Reorg from output_epilogue.\n        * alpha.h (ASM_DECLARE_FUNCTION_NAME): Call alpha_start_function.\n        (ASM_DECLARE_FUNCTION_SIZE): New.\n        (FUNCTION_PROLOGUE, FUNCTION_EPILOGUE): Delete.\n        (PROFILE_BEFORE_PROLOGUE): Set.\n        (ASM_OUTPUT_MI_THUNK): Remove bits now output by start/end_function.\n        * alpha/win-nt.h (ASM_OUTPUT_MI_THUNK): Likewise.\n\nFrom-SVN: r20709", "tree": {"sha": "3058ad77354a051750813e222aa24bf1e7e864da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3058ad77354a051750813e222aa24bf1e7e864da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acd9204960d4417b564e75ce036618359ce5eeda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd9204960d4417b564e75ce036618359ce5eeda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acd9204960d4417b564e75ce036618359ce5eeda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd9204960d4417b564e75ce036618359ce5eeda/comments", "author": null, "committer": null, "parents": [{"sha": "ed48174c545ab4a2fe0414de4ff9fa9615618aef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed48174c545ab4a2fe0414de4ff9fa9615618aef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed48174c545ab4a2fe0414de4ff9fa9615618aef"}], "stats": {"total": 213, "additions": 96, "deletions": 117}, "files": [{"sha": "6918eb95575f883b3db9ff2bd91aa58b3bf5fe49", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd9204960d4417b564e75ce036618359ce5eeda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd9204960d4417b564e75ce036618359ce5eeda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=acd9204960d4417b564e75ce036618359ce5eeda", "patch": "@@ -1,3 +1,17 @@\n+Thu Jun 25 01:00:48 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (alpha_function_name): Delete.\n+\t(alpha_ra_ever_killed): Notice current_function_is_thunk.\n+\t(alpha_sa_mask, alpha_sa_size, alpha_does_function_need_gp): Likewise.\n+\t(alpha_start_function): Reorg from output_prologue.\n+\t(alpha_end_function): Reorg from output_epilogue.\n+\t* alpha.h (ASM_DECLARE_FUNCTION_NAME): Call alpha_start_function.\n+\t(ASM_DECLARE_FUNCTION_SIZE): New.\n+\t(FUNCTION_PROLOGUE, FUNCTION_EPILOGUE): Delete.\n+\t(PROFILE_BEFORE_PROLOGUE): Set.\n+\t(ASM_OUTPUT_MI_THUNK): Remove bits now output by start/end_function.\n+\t* alpha/win-nt.h (ASM_OUTPUT_MI_THUNK): Likewise.\n+\n Thu Jun 25 01:18:47 1998  John Wehle  (john@feith.com)\n \n \t* i386/freebsd-elf.h (ASM_OUTPUT_MAX_SKIP_ALIGN): Define."}, {"sha": "f04e06509d329bdfbd7e8230aa4b854823a80ab3", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd9204960d4417b564e75ce036618359ce5eeda/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd9204960d4417b564e75ce036618359ce5eeda/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=acd9204960d4417b564e75ce036618359ce5eeda", "patch": "@@ -79,11 +79,6 @@ char *alpha_mlat_string;\t/* -mmemory-latency= */\n rtx alpha_compare_op0, alpha_compare_op1;\n int alpha_compare_fp_p;\n \n-/* Save the name of the current function as used by the assembler.  This\n-   is used by the epilogue.  */\n-\n-char *alpha_function_name;\n-\n /* Non-zero if inside of a function, because the Alpha asm can't\n    handle .files inside of functions.  */\n \n@@ -2459,6 +2454,10 @@ alpha_return_addr (count, frame)\n static int\n alpha_ra_ever_killed ()\n {\n+#ifdef ASM_OUTPUT_MI_THUNK\n+  if (current_function_is_thunk)\n+    return 0;\n+#endif\n   if (!alpha_return_addr_rtx)\n     return regs_ever_live[REG_RA];\n \n@@ -2930,7 +2929,7 @@ static int vms_save_fp_regno;\n /* Register number used to reference objects off our PV.  */\n static int vms_base_regno;\n \n-/*  Compute register masks for saved registers.  */\n+/* Compute register masks for saved registers.  */\n \n static void\n alpha_sa_mask (imaskP, fmaskP)\n@@ -2941,28 +2940,30 @@ alpha_sa_mask (imaskP, fmaskP)\n   unsigned long fmask = 0;\n   int i;\n \n-  if (TARGET_OPEN_VMS && vms_is_stack_procedure)\n-    imask |= (1L << HARD_FRAME_POINTER_REGNUM);\n-\n-  /* One for every register we have to save.  */\n+#ifdef ASM_OUTPUT_MI_THUNK\n+  if (!current_function_is_thunk)\n+#endif\n+    {\n+      if (TARGET_OPEN_VMS && vms_is_stack_procedure)\n+\timask |= (1L << HARD_FRAME_POINTER_REGNUM);\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (! fixed_regs[i] && ! call_used_regs[i]\n-\t&& regs_ever_live[i] && i != REG_RA)\n-      {\n-\tif (i < 32)\n-\t  imask |= (1L << i);\n-\telse\n-\t  fmask |= (1L << (i - 32));\n-      }\n+      /* One for every register we have to save.  */\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (! fixed_regs[i] && ! call_used_regs[i]\n+\t    && regs_ever_live[i] && i != REG_RA)\n+\t  {\n+\t    if (i < 32)\n+\t      imask |= (1L << i);\n+\t    else\n+\t      fmask |= (1L << (i - 32));\n+\t  }\n \n-  if (imask || fmask || alpha_ra_ever_killed ())\n-    imask |= (1L << REG_RA);\n+      if (imask || fmask || alpha_ra_ever_killed ())\n+\timask |= (1L << REG_RA);\n+    }\n \n   *imaskP = imask;\n   *fmaskP = fmask;\n-\n-  return;\n }\n \n int\n@@ -2971,12 +2972,18 @@ alpha_sa_size ()\n   int sa_size = 0;\n   int i;\n \n-  /* One for every register we have to save.  */\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (! fixed_regs[i] && ! call_used_regs[i]\n-\t&& regs_ever_live[i] && i != REG_RA)\n-      sa_size++;\n+#ifdef ASM_OUTPUT_MI_THUNK\n+  if (current_function_is_thunk)\n+    sa_size = 0;\n+  else\n+#endif\n+    {\n+      /* One for every register we have to save.  */\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (! fixed_regs[i] && ! call_used_regs[i]\n+\t    && regs_ever_live[i] && i != REG_RA)\n+\t  sa_size++;\n+    }\n \n   if (TARGET_OPEN_VMS)\n     {\n@@ -3070,6 +3077,11 @@ alpha_does_function_need_gp ()\n     return 1;\n #endif\n \n+#ifdef ASM_OUTPUT_MI_THUNK\n+  if (current_function_is_thunk)\n+    return 1;\n+#endif\n+\n   /* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first. \n      Even if we are a static function, we still need to do this in case\n      our address is taken and passed to something like qsort.  */\n@@ -3328,12 +3340,13 @@ alpha_expand_prologue ()\n     emit_insn (gen_blockage ());\n }\n \n-/* Output the rest of the textual info surrounding the prologue.  */\n+/* Output the textual info surrounding the prologue.  */\n \n void\n-output_prologue (file, size)\n+alpha_start_function (file, fnname, decl)\n      FILE *file;\n-     HOST_WIDE_INT size;\n+     char *fnname;\n+     tree decl;\n {\n   unsigned long imask = 0;\n   unsigned long fmask = 0;\n@@ -3343,7 +3356,7 @@ output_prologue (file, size)\n   HOST_WIDE_INT frame_size;\n   /* Offset from base reg to register save area.  */\n   HOST_WIDE_INT reg_offset;\n-  char *entry_label = (char *) alloca (strlen (alpha_function_name) + 6);\n+  char *entry_label = (char *) alloca (strlen (fnname) + 6);\n   int i;\n \n   sa_size = alpha_sa_size ();\n@@ -3388,11 +3401,11 @@ output_prologue (file, size)\n   if (TARGET_OPEN_VMS || !flag_inhibit_size_directive)\n     {\n       fputs (\"\\t.ent \", file);\n-      assemble_name (file, alpha_function_name);\n+      assemble_name (file, fnname);\n       putc ('\\n', file);\n     }\n \n-  strcpy (entry_label, alpha_function_name);\n+  strcpy (entry_label, fnname);\n   if (TARGET_OPEN_VMS)\n     strcat (entry_label, \"..en\");\n   ASM_OUTPUT_LABEL (file, entry_label);\n@@ -3482,7 +3495,7 @@ output_prologue (file, size)\n \tfputs (\"\\tldgp $29,0($27)\\n\", file);\n \n       putc ('$', file);\n-      assemble_name (file, alpha_function_name);\n+      assemble_name (file, fnname);\n       fputs (\"..ng:\\n\", file);\n     }\n \n@@ -3491,21 +3504,21 @@ output_prologue (file, size)\n      available then.  */\n   readonly_section ();\n   fprintf (file, \"\\t.align 3\\n\");\n-  assemble_name (file, alpha_function_name); fputs (\"..na:\\n\", file);\n+  assemble_name (file, fnname); fputs (\"..na:\\n\", file);\n   fputs (\"\\t.ascii \\\"\", file);\n-  assemble_name (file, alpha_function_name);\n+  assemble_name (file, fnname);\n   fputs (\"\\\\0\\\"\\n\", file);\n       \n   link_section ();\n   fprintf (file, \"\\t.align 3\\n\");\n   fputs (\"\\t.name \", file);\n-  assemble_name (file, alpha_function_name);\n+  assemble_name (file, fnname);\n   fputs (\"..na\\n\", file);\n-  ASM_OUTPUT_LABEL (file, alpha_function_name);\n+  ASM_OUTPUT_LABEL (file, fnname);\n   fprintf (file, \"\\t.pdesc \");\n-  assemble_name (file, alpha_function_name);\n+  assemble_name (file, fnname);\n   fprintf (file, \"..en,%s\\n\", vms_is_stack_procedure ? \"stack\" : \"reg\");\n-  alpha_need_linkage (alpha_function_name, 1);\n+  alpha_need_linkage (fnname, 1);\n   text_section ();\n #endif\n }\n@@ -3709,15 +3722,16 @@ alpha_expand_epilogue ()\n /* Output the rest of the textual info surrounding the epilogue.  */\n \n void\n-output_epilogue (file, size)\n+alpha_end_function (file, fnname, decl)\n      FILE *file;\n-     int size;\n+     char *fnname;\n+     tree decl;\n {\n   /* End the function.  */\n   if (!flag_inhibit_size_directive)\n     {\n       fputs (\"\\t.end \", file);\n-      assemble_name (file, alpha_function_name);\n+      assemble_name (file, fnname);\n       putc ('\\n', file);\n     }\n   inside_function = FALSE;"}, {"sha": "da129637cff05fb95f5a51443c1162172d2cddfc", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 16, "deletions": 49, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd9204960d4417b564e75ce036618359ce5eeda/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd9204960d4417b564e75ce036618359ce5eeda/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=acd9204960d4417b564e75ce036618359ce5eeda", "patch": "@@ -1090,38 +1090,33 @@ extern struct rtx_def *alpha_compare_op0, *alpha_compare_op1;\n extern int alpha_compare_fp_p;\n \n /* Make (or fake) .linkage entry for function call.\n-\n    IS_LOCAL is 0 if name is used in call, 1 if name is used in definition.  */\n extern void alpha_need_linkage ();\n \n /* This macro defines the start of an assembly comment.  */\n \n #define ASM_COMMENT_START \" #\"\n \n-/* This macro produces the initial definition of a function name.  On the\n-   Alpha, we need to save the function name for the prologue and epilogue.  */\n-\n-extern char *alpha_function_name;\n+/* This macro produces the initial definition of a function.  */\n \n-#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\\\n-{\t\t\t\t\t\t\t\\\n-   alpha_function_name = NAME;\t\t\t\t\\\n-}\n-   \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n+#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL) \\\n+  alpha_start_function(FILE,NAME,DECL);\n+extern void alpha_start_function ();\n \n-#define FUNCTION_PROLOGUE(FILE, SIZE)  output_prologue (FILE, SIZE)\n+/* This macro closes up a function definition for the assembler.  */\n \n+#define ASM_DECLARE_FUNCTION_SIZE(FILE,NAME,DECL) \\\n+  alpha_end_function(FILE,NAME,DECL)\n+extern void alpha_end_function ();\n+   \n /* This macro notes the end of the prologue.  */\n \n #define FUNCTION_END_PROLOGUE(FILE)  output_end_prologue (FILE)\n \n+/* Output any profiling code before the prologue.  */\n+\n+#define PROFILE_BEFORE_PROLOGUE 1\n+\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  Under OSF/1, profiling is enabled\n    by simply passing -pg to the assembler and linker.  */\n@@ -1170,19 +1165,6 @@ extern char *alpha_function_name;\n    No definition is equivalent to always zero.  */\n \n #define EXIT_IGNORE_STACK 1\n-\n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE)\toutput_epilogue (FILE, SIZE)\n-\n \f\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.\n@@ -2124,16 +2106,8 @@ literal_section ()\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   char *fn_name = XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0);\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.ent \");\t\t\t\t\t\t\\\n-  assemble_name (FILE, alpha_function_name);\t\t\t\t\\\n-  fputc ('\\n', FILE);\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_LABEL (FILE, alpha_function_name);\t\t\t\t\\\n-  fprintf (FILE, \"\\tldgp $29,0($27)\\n\");\t\t\t\t\\\n-  fputc ('$', FILE);\t\t\t\t\t\t\t\\\n-  assemble_name (FILE, alpha_function_name);\t\t\t\t\\\n-  fprintf (FILE, \"..ng:\\n\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.frame $30,0,$26,0\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\t.prologue 1\\n\");\t\t\t\t\t\\\n+  /* Mark end of prologue.  */\t\t\t\t\t\t\\\n+  output_end_prologue (FILE);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* Rely on the assembler to macro expand a large delta.  */\t\t\\\n   fprintf (FILE, \"\\tlda $16,%ld($16)\\n\", (long)(DELTA));\t\t\\\n@@ -2146,18 +2120,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tlda $27,\");\t\t\t\t\t\\\n-      assemble_name (FILE, fn_name);\t\t\t\t\t\\\n-      fprintf (FILE, \"\\n\\tjmp $31,($27),\");\t\t\t\t\\\n+      fprintf (FILE, \"\\tjmp $31,\");\t\t\t\t\t\\\n       assemble_name (FILE, fn_name);\t\t\t\t\t\\\n       fputc ('\\n', FILE);\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.end \");\t\t\t\t\t\t\\\n-  assemble_name (FILE, alpha_function_name);\t\t\t\t\\\n-  fputc ('\\n', FILE);\t\t\t\t\t\t\t\\\n } while (0)\n-\n \f\n /* Define results of standard character escape sequences.  */\n #define TARGET_BELL 007"}, {"sha": "0f57cf327a2ab86473000eb4fc1c061113945c24", "filename": "gcc/config/alpha/win-nt.h", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd9204960d4417b564e75ce036618359ce5eeda/gcc%2Fconfig%2Falpha%2Fwin-nt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd9204960d4417b564e75ce036618359ce5eeda/gcc%2Fconfig%2Falpha%2Fwin-nt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fwin-nt.h?ref=acd9204960d4417b564e75ce036618359ce5eeda", "patch": "@@ -136,36 +136,20 @@ Boston, MA 02111-1307, USA.  */\n /* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n    Used for C++ multiple inheritance.  */\n \n-#undef ASM_OUTPUT_MI_THUNK\n #define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  char *fn_name = XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0);\t\t\\\n+  char *op, *fn_name = XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0);\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.ent \");\t\t\t\t\t\t\\\n-  assemble_name (FILE, alpha_function_name);\t\t\t\t\\\n-  fputc ('\\n', FILE);\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_LABEL (FILE, alpha_function_name);\t\t\t\t\\\n-  fprintf (FILE, \"\\t.frame $30,0,$26,0\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\t.prologue 1\\n\");\t\t\t\t\t\\\n+  /* Mark end of prologue.  */\t\t\t\t\t\t\\\n+  output_end_prologue (FILE);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* Rely on the assembler to macro expand a large delta.  */\t\t\\\n   fprintf (FILE, \"\\tlda $16,%ld($16)\\n\", (long)(DELTA));\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  op = \"jsr\";\t\t\t\t\t\t\t\t\\\n   if (current_file_function_operand (XEXP (DECL_RTL (FUNCTION), 0)))\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tbr $31,\");\t\t\t\t\t\\\n-      assemble_name (FILE, fn_name);\t\t\t\t\t\\\n-      fputc ('\\n', FILE);\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tjmp $31,\");\t\t\t\t\t\\\n-      assemble_name (FILE, fn_name);\t\t\t\t\t\\\n-      fputc ('\\n', FILE);\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.end \");\t\t\t\t\t\t\\\n-  assemble_name (FILE, alpha_function_name);\t\t\t\t\\\n+    op = \"br\";\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t%s $31,\", op);\t\t\t\t\t\\\n+  assemble_name (FILE, fn_name);\t\t\t\t\t\\\n   fputc ('\\n', FILE);\t\t\t\t\t\t\t\\\n } while (0)\n-"}]}