{"sha": "2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZkNDAxYzhmMTkwZjFmZTQzZTUxYTdmNzI2ZjZlZDYxMTlhMWY5Ng==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-03T02:17:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-03T02:17:34Z"}, "message": "libgo: Update to weekly.2011-11-02.\n\nFrom-SVN: r181964", "tree": {"sha": "7f76eff391f37fe6467ff4ffbc0c582c9959ea30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f76eff391f37fe6467ff4ffbc0c582c9959ea30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/comments", "author": null, "committer": null, "parents": [{"sha": "02e9018f1616b23f1276151797216717b3564202", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e9018f1616b23f1276151797216717b3564202", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02e9018f1616b23f1276151797216717b3564202"}], "stats": {"total": 8295, "additions": 4056, "deletions": 4239}, "files": [{"sha": "371a1738766a2e4f22695769107130737c509cf4", "filename": "gcc/testsuite/go.test/test/chan/goroutines.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fgoroutines.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fgoroutines.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fgoroutines.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -21,7 +21,7 @@ func f(left, right chan int) {\n func main() {\n \tvar n = 10000\n \tif len(os.Args) > 1 {\n-\t\tvar err os.Error\n+\t\tvar err error\n \t\tn, err = strconv.Atoi(os.Args[1])\n \t\tif err != nil {\n \t\t\tprint(\"bad arg\\n\")"}, {"sha": "a4b9d05d87dce7025a7445d4a04a43e8988e744c", "filename": "gcc/testsuite/go.test/test/env.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fenv.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -14,7 +14,7 @@ import (\n func main() {\n \tga, e0 := os.Getenverror(\"GOARCH\")\n \tif e0 != nil {\n-\t\tprint(\"$GOARCH: \", e0.String(), \"\\n\")\n+\t\tprint(\"$GOARCH: \", e0.Error(), \"\\n\")\n \t\tos.Exit(1)\n \t}\n \tif ga != runtime.GOARCH {\n@@ -23,7 +23,7 @@ func main() {\n \t}\n \txxx, e1 := os.Getenverror(\"DOES_NOT_EXIST\")\n \tif e1 != os.ENOENV {\n-\t\tprint(\"$DOES_NOT_EXIST=\", xxx, \"; err = \", e1.String(), \"\\n\")\n+\t\tprint(\"$DOES_NOT_EXIST=\", xxx, \"; err = \", e1.Error(), \"\\n\")\n \t\tos.Exit(1)\n \t}\n }"}, {"sha": "0554bbc8b85e5bedcc9d5bedfdd9ce63e692e3fa", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug107.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug107.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug107.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug107.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,7 +6,7 @@\n \n package main\n import os \"os\"\n-type _ os.Error\n+type _ os.FileInfo\n func f() (os int) {\n \t // In the next line \"os\" should refer to the result variable, not\n \t // to the package."}, {"sha": "e3ddf0e774537d803464608955537f0ec5d14f4d", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug243.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug243.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug243.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug243.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,7 +6,7 @@\n \n package main\n \n-import \"os\"\n+import \"errors\"\n \n // Issue 481: closures and var declarations\n // with multiple variables assigned from one\n@@ -22,7 +22,7 @@ func main() {\n \t\t}\n \t}()\n \n-\tvar conn, _ = Dial(\"tcp\", \"\", listen.Addr().String())\n+\tvar conn, _ = Dial(\"tcp\", \"\", listen.Addr().Error())\n \t_ = conn\n }\n \n@@ -37,8 +37,8 @@ func Listen(x, y string) (T, string) {\n \treturn global, y\n }\n \n-func (t T) Addr() os.Error {\n-\treturn os.NewError(\"stringer\")\n+func (t T) Addr() error {\n+\treturn errors.New(\"stringer\")\n }\n \n func (t T) Accept() (int, string) {"}, {"sha": "f5f2c35532222c56525a178e647a54abc01c51c2", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug262.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug262.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug262.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug262.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -18,9 +18,9 @@ func f() string {\n \treturn \"abc\"\n }\n \n-func g() *os.Error {\n+func g() *error {\n \ttrace += \"g\"\n-\tvar x os.Error\n+\tvar x error\n \treturn &x\n }\n \n@@ -35,15 +35,14 @@ func i() *int {\n \treturn &i\n }\n \n-\n func main() {\n \tm := make(map[string]int)\n \tm[f()], *g() = strconv.Atoi(h())\n \tif m[\"abc\"] != 123 || trace != \"fgh\" {\n \t\tprintln(\"BUG\", m[\"abc\"], trace)\n \t\tpanic(\"fail\")\n \t}\n-\tmm := make(map[string]os.Error)\n+\tmm := make(map[string]error)\n \ttrace = \"\"\n \tmm[\"abc\"] = os.EINVAL\n \t*i(), mm[f()] = strconv.Atoi(h())"}, {"sha": "7e123e3a39b6cdec7b88c701edeffaaad22eccfa", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug326.go", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug326.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug326.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug326.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,36 +6,34 @@\n \n package p\n \n-import \"os\"\n-\n-func f() (_ int, err os.Error) {\n+func f() (_ int, err error) {\n \treturn\n }\n \n-func g() (x int, _ os.Error) {\n+func g() (x int, _ error) {\n \treturn\n }\n \n-func h() (_ int, _ os.Error) {\n+func h() (_ int, _ error) {\n \treturn\n }\n \n-func i() (int, os.Error) {\n-\treturn\t// ERROR \"not enough arguments to return\"\n+func i() (int, error) {\n+\treturn // ERROR \"not enough arguments to return\"\n }\n \n-func f1() (_ int, err os.Error) {\n+func f1() (_ int, err error) {\n \treturn 1, nil\n }\n \n-func g1() (x int, _ os.Error) {\n+func g1() (x int, _ error) {\n \treturn 1, nil\n }\n \n-func h1() (_ int, _ os.Error) {\n+func h1() (_ int, _ error) {\n \treturn 1, nil\n }\n \n-func ii() (int, os.Error) {\n+func ii() (int, error) {\n \treturn 1, nil\n }"}, {"sha": "6c5acd1f4d9bb0a8be2fe53bfd443850f58dcef0", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug331.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug331.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug331.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug331.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,22 +6,22 @@\n \n package main\n \n-import \"os\"\n+import \"io\"\n \n-func f() (_ string, x float64, err os.Error) {\n+func f() (_ string, x float64, err error) {\n \treturn\n }\n \n-func g() (_ string, x float64, err os.Error) {\n-\treturn \"hello\", 3.14, os.EOF\n+func g() (_ string, x float64, err error) {\n+\treturn \"hello\", 3.14, io.EOF\n }\n \n-var _ func() (string, float64, os.Error) = f\n-var _ func() (string, float64, os.Error) = g\n+var _ func() (string, float64, error) = f\n+var _ func() (string, float64, error) = g\n \n func main() {\n \tx, y, z := g()\n-\tif x != \"hello\" || y != 3.14 || z != os.EOF {\n+\tif x != \"hello\" || y != 3.14 || z != io.EOF {\n \t\tprintln(\"wrong\", x, len(x), y, z)\n \t}\n }"}, {"sha": "a95256e272e248637cf875e3332483e7cd2cc2ae", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug354.go", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug354.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug354.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug354.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,12 +9,8 @@\n \n package main\n \n-import (\n-\t\"os\"\n-)\n-\n type Inner struct {\n-\tF func() os.Error\n+\tF func() error\n }\n \n type Outer struct {\n@@ -23,4 +19,4 @@ type Outer struct {\n \n // calls makeclosure twice on same closure\n \n-var Foo = Outer{[]Inner{Inner{func() os.Error{ return nil }}}}\n+var Foo = Outer{[]Inner{Inner{func() error { return nil }}}}"}, {"sha": "87e78194ef9af93a7185c7095840237f72ec8b27", "filename": "gcc/testsuite/go.test/test/func2.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffunc2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffunc2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffunc2.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,7 +5,6 @@\n // license that can be found in the LICENSE file.\n \n package main\n-import os \"os\"\n \n type t1 int\n type t2 int\n@@ -23,7 +22,7 @@ func f8(os int) int\n func f9(os int) int {\n \treturn os\n }\n-func f10(err os.Error) os.Error {\n+func f10(err error) error {\n \treturn err\n }\n func f11(t1 string) string {"}, {"sha": "bd83dc3bdd30c4d52f10e52c79b926b07cdfda2d", "filename": "gcc/testsuite/go.test/test/import.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fimport.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -13,13 +13,12 @@ import _os_ \"os\"\n import \"os\"\n import . \"os\"\n \n-func f(e os.Error)\n+func f(e *os.File)\n \n func main() {\n-\tvar _e_ _os_.Error\n-\tvar dot Error\n+\tvar _e_ *_os_.File\n+\tvar dot *File\n \n \tf(_e_)\n \tf(dot)\n }\n-"}, {"sha": "ccaf8ced16b1e5f366bf0d9d502c451709e284a2", "filename": "gcc/testsuite/go.test/test/recover2.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover2.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,10 +11,7 @@\n \n package main\n \n-import (\n-\t\"os\"\n-\t\"strings\"\n-)\n+import \"strings\"\n \n var x = make([]byte, 10)\n \n@@ -33,7 +30,7 @@ func mustRecover(s string) {\n \tif v == nil {\n \t\tpanic(\"expected panic\")\n \t}\n-\tif e := v.(os.Error).String(); strings.Index(e, s) < 0 {\n+\tif e := v.(error).Error(); strings.Index(e, s) < 0 {\n \t\tpanic(\"want: \" + s + \"; have: \" + e)\n \t}\n }"}, {"sha": "60ade9b61c5e6e3b675ea31f93056788ef5efc48", "filename": "gcc/testsuite/go.test/test/recover3.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover3.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -35,7 +35,7 @@ func check(name string, f func(), err string) {\n \t\t\tprintln(name, \"panicked but not with runtime.Error\")\n \t\t\treturn\n \t\t}\n-\t\ts := runt.String()\n+\t\ts := runt.Error()\n \t\tif strings.Index(s, err) < 0 {\n \t\t\tbug()\n \t\t\tprintln(name, \"panicked with\", s, \"not\", err)"}, {"sha": "f55d80b9670aa1c4cfd3c92fb6e07f967747998a", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -1,4 +1,4 @@\n-941b8015061a\n+780c85032b17\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "9a4588e441e731d646b9e3153055c025da1ceb70", "filename": "libgo/Makefile.am", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -107,6 +107,7 @@ toolexeclibgo_DATA = \\\n \tcmath.gox \\\n \tcrypto.gox \\\n \tcsv.gox \\\n+\terrors.gox \\\n \texec.gox \\\n \texpvar.gox \\\n \tflag.gox \\\n@@ -563,6 +564,9 @@ go_csv_files = \\\n \tgo/csv/reader.go \\\n \tgo/csv/writer.go\n \n+go_errors_files = \\\n+\tgo/errors/errors.go\n+\n go_exec_files = \\\n \tgo/exec/exec.go \\\n \tgo/exec/lp_unix.go\n@@ -1623,6 +1627,7 @@ libgo_go_objs = \\\n \tcmath/cmath.lo \\\n \tcrypto/crypto.lo \\\n \tcsv/csv.lo \\\n+\terrors/errors.lo \\\n \texec/exec.lo \\\n \texpvar/expvar.lo \\\n \tflag/flag.lo \\\n@@ -1944,6 +1949,15 @@ csv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: csv/check\n \n+@go_include@ errors/errors.lo.dep\n+errors/errors.lo.dep: $(go_errors_files)\n+\t$(BUILDDEPS)\n+errors/errors.lo: $(go_errors_files)\n+\t$(BUILDPACKAGE)\n+errors/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: errors/check\n+\n @go_include@ exec/exec.lo.dep\n exec/exec.lo.dep: $(go_exec_files)\n \t$(BUILDDEPS)\n@@ -3445,6 +3459,8 @@ crypto.gox: crypto/crypto.lo\n \t$(BUILDGOX)\n csv.gox: csv/csv.lo\n \t$(BUILDGOX)\n+errors.gox: errors/errors.lo\n+\t$(BUILDGOX)\n exec.gox: exec/exec.lo\n \t$(BUILDGOX)\n expvar.gox: expvar/expvar.lo\n@@ -3791,6 +3807,7 @@ TEST_PACKAGES = \\\n \tbytes/check \\\n \tcmath/check \\\n \tcsv/check \\\n+\terrors/check \\\n \texec/check \\\n \texpvar/check \\\n \tflag/check \\"}, {"sha": "4cb4b5fc5568550bad3c50bf58eb6d9bd6ff133c", "filename": "libgo/Makefile.in", "status": "modified", "additions": 57, "deletions": 40, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -132,46 +132,46 @@ LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n am__DEPENDENCIES_2 = asn1/asn1.lo big/big.lo bufio/bufio.lo \\\n \tbytes/bytes.lo bytes/index.lo cmath/cmath.lo crypto/crypto.lo \\\n-\tcsv/csv.lo exec/exec.lo expvar/expvar.lo flag/flag.lo \\\n-\tfmt/fmt.lo gob/gob.lo hash/hash.lo html/html.lo http/http.lo \\\n-\timage/image.lo io/io.lo json/json.lo log/log.lo math/math.lo \\\n-\tmail/mail.lo mime/mime.lo net/net.lo os/os.lo patch/patch.lo \\\n-\tpath/path.lo rand/rand.lo reflect/reflect.lo regexp/regexp.lo \\\n-\trpc/rpc.lo runtime/runtime.lo scanner/scanner.lo smtp/smtp.lo \\\n-\tsort/sort.lo strconv/strconv.lo strings/strings.lo \\\n-\tsync/sync.lo syslog/syslog.lo syslog/syslog_c.lo \\\n-\ttabwriter/tabwriter.lo template/template.lo time/time.lo \\\n-\tunicode/unicode.lo url/url.lo utf16/utf16.lo utf8/utf8.lo \\\n-\twebsocket/websocket.lo xml/xml.lo archive/tar.lo \\\n-\tarchive/zip.lo compress/bzip2.lo compress/flate.lo \\\n-\tcompress/gzip.lo compress/lzw.lo compress/zlib.lo \\\n-\tcontainer/heap.lo container/list.lo container/ring.lo \\\n-\tcrypto/aes.lo crypto/bcrypt.lo crypto/blowfish.lo \\\n-\tcrypto/cast5.lo crypto/cipher.lo crypto/des.lo crypto/dsa.lo \\\n-\tcrypto/ecdsa.lo crypto/elliptic.lo crypto/hmac.lo \\\n-\tcrypto/md4.lo crypto/md5.lo crypto/ocsp.lo crypto/openpgp.lo \\\n-\tcrypto/rand.lo crypto/rc4.lo crypto/ripemd160.lo crypto/rsa.lo \\\n-\tcrypto/sha1.lo crypto/sha256.lo crypto/sha512.lo \\\n-\tcrypto/subtle.lo crypto/tls.lo crypto/twofish.lo \\\n-\tcrypto/x509.lo crypto/xtea.lo crypto/openpgp/armor.lo \\\n-\tcrypto/openpgp/elgamal.lo crypto/openpgp/error.lo \\\n-\tcrypto/openpgp/packet.lo crypto/openpgp/s2k.lo \\\n-\tcrypto/x509/pkix.lo debug/dwarf.lo debug/elf.lo debug/gosym.lo \\\n-\tdebug/macho.lo debug/pe.lo encoding/ascii85.lo \\\n-\tencoding/base32.lo encoding/base64.lo encoding/binary.lo \\\n-\tencoding/git85.lo encoding/hex.lo encoding/pem.lo exp/ebnf.lo \\\n-\texp/gui.lo exp/norm.lo exp/spdy.lo exp/sql.lo exp/ssh.lo \\\n-\texp/terminal.lo exp/types.lo exp/gui/x11.lo exp/sql/driver.lo \\\n-\texp/template/html.lo go/ast.lo go/build.lo go/doc.lo \\\n-\tgo/parser.lo go/printer.lo go/scanner.lo go/token.lo \\\n-\thash/adler32.lo hash/crc32.lo hash/crc64.lo hash/fnv.lo \\\n-\thttp/cgi.lo http/fcgi.lo http/httptest.lo http/pprof.lo \\\n-\timage/bmp.lo image/color.lo image/draw.lo image/gif.lo \\\n-\timage/jpeg.lo image/png.lo image/tiff.lo image/ycbcr.lo \\\n-\tindex/suffixarray.lo io/ioutil.lo mime/multipart.lo \\\n-\tnet/dict.lo net/textproto.lo old/netchan.lo old/regexp.lo \\\n-\told/template.lo $(am__DEPENDENCIES_1) os/user.lo os/signal.lo \\\n-\tpath/filepath.lo regexp/syntax.lo rpc/jsonrpc.lo \\\n+\tcsv/csv.lo errors/errors.lo exec/exec.lo expvar/expvar.lo \\\n+\tflag/flag.lo fmt/fmt.lo gob/gob.lo hash/hash.lo html/html.lo \\\n+\thttp/http.lo image/image.lo io/io.lo json/json.lo log/log.lo \\\n+\tmath/math.lo mail/mail.lo mime/mime.lo net/net.lo os/os.lo \\\n+\tpatch/patch.lo path/path.lo rand/rand.lo reflect/reflect.lo \\\n+\tregexp/regexp.lo rpc/rpc.lo runtime/runtime.lo \\\n+\tscanner/scanner.lo smtp/smtp.lo sort/sort.lo \\\n+\tstrconv/strconv.lo strings/strings.lo sync/sync.lo \\\n+\tsyslog/syslog.lo syslog/syslog_c.lo tabwriter/tabwriter.lo \\\n+\ttemplate/template.lo time/time.lo unicode/unicode.lo \\\n+\turl/url.lo utf16/utf16.lo utf8/utf8.lo websocket/websocket.lo \\\n+\txml/xml.lo archive/tar.lo archive/zip.lo compress/bzip2.lo \\\n+\tcompress/flate.lo compress/gzip.lo compress/lzw.lo \\\n+\tcompress/zlib.lo container/heap.lo container/list.lo \\\n+\tcontainer/ring.lo crypto/aes.lo crypto/bcrypt.lo \\\n+\tcrypto/blowfish.lo crypto/cast5.lo crypto/cipher.lo \\\n+\tcrypto/des.lo crypto/dsa.lo crypto/ecdsa.lo crypto/elliptic.lo \\\n+\tcrypto/hmac.lo crypto/md4.lo crypto/md5.lo crypto/ocsp.lo \\\n+\tcrypto/openpgp.lo crypto/rand.lo crypto/rc4.lo \\\n+\tcrypto/ripemd160.lo crypto/rsa.lo crypto/sha1.lo \\\n+\tcrypto/sha256.lo crypto/sha512.lo crypto/subtle.lo \\\n+\tcrypto/tls.lo crypto/twofish.lo crypto/x509.lo crypto/xtea.lo \\\n+\tcrypto/openpgp/armor.lo crypto/openpgp/elgamal.lo \\\n+\tcrypto/openpgp/error.lo crypto/openpgp/packet.lo \\\n+\tcrypto/openpgp/s2k.lo crypto/x509/pkix.lo debug/dwarf.lo \\\n+\tdebug/elf.lo debug/gosym.lo debug/macho.lo debug/pe.lo \\\n+\tencoding/ascii85.lo encoding/base32.lo encoding/base64.lo \\\n+\tencoding/binary.lo encoding/git85.lo encoding/hex.lo \\\n+\tencoding/pem.lo exp/ebnf.lo exp/gui.lo exp/norm.lo exp/spdy.lo \\\n+\texp/sql.lo exp/ssh.lo exp/terminal.lo exp/types.lo \\\n+\texp/gui/x11.lo exp/sql/driver.lo exp/template/html.lo \\\n+\tgo/ast.lo go/build.lo go/doc.lo go/parser.lo go/printer.lo \\\n+\tgo/scanner.lo go/token.lo hash/adler32.lo hash/crc32.lo \\\n+\thash/crc64.lo hash/fnv.lo http/cgi.lo http/fcgi.lo \\\n+\thttp/httptest.lo http/pprof.lo image/bmp.lo image/color.lo \\\n+\timage/draw.lo image/gif.lo image/jpeg.lo image/png.lo \\\n+\timage/tiff.lo image/ycbcr.lo index/suffixarray.lo io/ioutil.lo \\\n+\tmime/multipart.lo net/dict.lo net/textproto.lo old/netchan.lo \\\n+\told/regexp.lo old/template.lo $(am__DEPENDENCIES_1) os/user.lo \\\n+\tos/signal.lo path/filepath.lo regexp/syntax.lo rpc/jsonrpc.lo \\\n \truntime/debug.lo runtime/pprof.lo sync/atomic.lo \\\n \tsync/atomic_c.lo syscall/syscall.lo syscall/errno.lo \\\n \tsyscall/wait.lo template/parse.lo testing/testing.lo \\\n@@ -568,6 +568,7 @@ toolexeclibgo_DATA = \\\n \tcmath.gox \\\n \tcrypto.gox \\\n \tcsv.gox \\\n+\terrors.gox \\\n \texec.gox \\\n \texpvar.gox \\\n \tflag.gox \\\n@@ -947,6 +948,9 @@ go_csv_files = \\\n \tgo/csv/reader.go \\\n \tgo/csv/writer.go\n \n+go_errors_files = \\\n+\tgo/errors/errors.go\n+\n go_exec_files = \\\n \tgo/exec/exec.go \\\n \tgo/exec/lp_unix.go\n@@ -1900,6 +1904,7 @@ libgo_go_objs = \\\n \tcmath/cmath.lo \\\n \tcrypto/crypto.lo \\\n \tcsv/csv.lo \\\n+\terrors/errors.lo \\\n \texec/exec.lo \\\n \texpvar/expvar.lo \\\n \tflag/flag.lo \\\n@@ -2167,6 +2172,7 @@ TEST_PACKAGES = \\\n \tbytes/check \\\n \tcmath/check \\\n \tcsv/check \\\n+\terrors/check \\\n \texec/check \\\n \texpvar/check \\\n \tflag/check \\\n@@ -4434,6 +4440,15 @@ csv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: csv/check\n \n+@go_include@ errors/errors.lo.dep\n+errors/errors.lo.dep: $(go_errors_files)\n+\t$(BUILDDEPS)\n+errors/errors.lo: $(go_errors_files)\n+\t$(BUILDPACKAGE)\n+errors/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: errors/check\n+\n @go_include@ exec/exec.lo.dep\n exec/exec.lo.dep: $(go_exec_files)\n \t$(BUILDDEPS)\n@@ -5930,6 +5945,8 @@ crypto.gox: crypto/crypto.lo\n \t$(BUILDGOX)\n csv.gox: csv/csv.lo\n \t$(BUILDGOX)\n+errors.gox: errors/errors.lo\n+\t$(BUILDGOX)\n exec.gox: exec/exec.lo\n \t$(BUILDGOX)\n expvar.gox: expvar/expvar.lo"}, {"sha": "65bf1204ab426f3fbc6cd2e581122cdcb897c36e", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,14 +9,15 @@ package tar\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"strconv\"\n )\n \n var (\n-\tHeaderError = os.NewError(\"invalid tar header\")\n+\tHeaderError = errors.New(\"invalid tar header\")\n )\n \n // A Reader provides sequential access to the contents of a tar archive.\n@@ -39,7 +40,7 @@ var (\n //\t}\n type Reader struct {\n \tr   io.Reader\n-\terr os.Error\n+\terr error\n \tnb  int64 // number of unread bytes for current file entry\n \tpad int64 // amount of padding (ignored) after current file entry\n }\n@@ -48,7 +49,7 @@ type Reader struct {\n func NewReader(r io.Reader) *Reader { return &Reader{r: r} }\n \n // Next advances to the next entry in the tar archive.\n-func (tr *Reader) Next() (*Header, os.Error) {\n+func (tr *Reader) Next() (*Header, error) {\n \tvar hdr *Header\n \tif tr.err == nil {\n \t\ttr.skipUnread()\n@@ -119,7 +120,7 @@ func (tr *Reader) readHeader() *Header {\n \t\t\treturn nil\n \t\t}\n \t\tif bytes.Equal(header, zeroBlock[0:blockSize]) {\n-\t\t\ttr.err = os.EOF\n+\t\t\ttr.err = io.EOF\n \t\t} else {\n \t\t\ttr.err = HeaderError // zero block and then non-zero block\n \t\t}\n@@ -201,10 +202,10 @@ func (tr *Reader) readHeader() *Header {\n // Read reads from the current entry in the tar archive.\n // It returns 0, os.EOF when it reaches the end of that entry,\n // until Next is called to advance to the next entry.\n-func (tr *Reader) Read(b []byte) (n int, err os.Error) {\n+func (tr *Reader) Read(b []byte) (n int, err error) {\n \tif tr.nb == 0 {\n \t\t// file consumed\n-\t\treturn 0, os.EOF\n+\t\treturn 0, io.EOF\n \t}\n \n \tif int64(len(b)) > tr.nb {\n@@ -213,7 +214,7 @@ func (tr *Reader) Read(b []byte) (n int, err os.Error) {\n \tn, err = tr.r.Read(b)\n \ttr.nb -= int64(n)\n \n-\tif err == os.EOF && tr.nb > 0 {\n+\tif err == io.EOF && tr.nb > 0 {\n \t\terr = io.ErrUnexpectedEOF\n \t}\n \ttr.err = err"}, {"sha": "00eea6b62d7fbffac00e503e596055eb87640347", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -132,7 +132,7 @@ testLoop:\n \t\t\t}\n \t\t}\n \t\thdr, err := tr.Next()\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\tbreak\n \t\t}\n \t\tif hdr != nil || err != nil {\n@@ -195,7 +195,7 @@ func TestIncrementalRead(t *testing.T) {\n \t// loop over all files\n \tfor ; ; nread++ {\n \t\thdr, err := tr.Next()\n-\t\tif hdr == nil || err == os.EOF {\n+\t\tif hdr == nil || err == io.EOF {\n \t\t\tbreak\n \t\t}\n \n@@ -211,7 +211,7 @@ func TestIncrementalRead(t *testing.T) {\n \t\trdbuf := make([]uint8, 8)\n \t\tfor {\n \t\t\tnr, err := tr.Read(rdbuf)\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tif err != nil {\n@@ -250,7 +250,7 @@ func TestNonSeekable(t *testing.T) {\n \t\tfor {\n \t\t\tnr, err := f.Read(rdbuf)\n \t\t\tw.Write(rdbuf[0:nr])\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n@@ -262,7 +262,7 @@ func TestNonSeekable(t *testing.T) {\n \n \tfor ; ; nread++ {\n \t\thdr, err := tr.Next()\n-\t\tif hdr == nil || err == os.EOF {\n+\t\tif hdr == nil || err == io.EOF {\n \t\t\tbreak\n \t\t}\n \t}"}, {"sha": "222df90782ca4812783257bb6834218cf75f02f5", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,15 +8,15 @@ package tar\n // - catch more errors (no first header, write after close, etc.)\n \n import (\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n var (\n-\tErrWriteTooLong    = os.NewError(\"write too long\")\n-\tErrFieldTooLong    = os.NewError(\"header field too long\")\n-\tErrWriteAfterClose = os.NewError(\"write after close\")\n+\tErrWriteTooLong    = errors.New(\"write too long\")\n+\tErrFieldTooLong    = errors.New(\"header field too long\")\n+\tErrWriteAfterClose = errors.New(\"write after close\")\n )\n \n // A Writer provides sequential writing of a tar archive in POSIX.1 format.\n@@ -36,7 +36,7 @@ var (\n //\ttw.Close()\n type Writer struct {\n \tw          io.Writer\n-\terr        os.Error\n+\terr        error\n \tnb         int64 // number of unwritten bytes for current file entry\n \tpad        int64 // amount of padding to write after current file entry\n \tclosed     bool\n@@ -47,7 +47,7 @@ type Writer struct {\n func NewWriter(w io.Writer) *Writer { return &Writer{w: w} }\n \n // Flush finishes writing the current file (optional).\n-func (tw *Writer) Flush() os.Error {\n+func (tw *Writer) Flush() error {\n \tn := tw.nb + tw.pad\n \tfor n > 0 && tw.err == nil {\n \t\tnr := n\n@@ -107,7 +107,7 @@ func (tw *Writer) numeric(b []byte, x int64) {\n // WriteHeader writes hdr and prepares to accept the file's contents.\n // WriteHeader calls Flush if it is not the first header.\n // Calling after a Close will return ErrWriteAfterClose.\n-func (tw *Writer) WriteHeader(hdr *Header) os.Error {\n+func (tw *Writer) WriteHeader(hdr *Header) error {\n \tif tw.closed {\n \t\treturn ErrWriteAfterClose\n \t}\n@@ -165,7 +165,7 @@ func (tw *Writer) WriteHeader(hdr *Header) os.Error {\n // Write writes to the current entry in the tar archive.\n // Write returns the error ErrWriteTooLong if more than\n // hdr.Size bytes are written after WriteHeader.\n-func (tw *Writer) Write(b []byte) (n int, err os.Error) {\n+func (tw *Writer) Write(b []byte) (n int, err error) {\n \tif tw.closed {\n \t\terr = ErrWriteTooLong\n \t\treturn\n@@ -187,7 +187,7 @@ func (tw *Writer) Write(b []byte) (n int, err os.Error) {\n \n // Close closes the tar archive, flushing any unwritten\n // data to the underlying writer.\n-func (tw *Writer) Close() os.Error {\n+func (tw *Writer) Close() error {\n \tif tw.err != nil || tw.closed {\n \t\treturn tw.err\n \t}"}, {"sha": "64152b4245c5366c0b3903eb4af06c7e610ff462", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,6 +7,7 @@ package zip\n import (\n \t\"bufio\"\n \t\"compress/flate\"\n+\t\"errors\"\n \t\"hash\"\n \t\"hash/crc32\"\n \t\"encoding/binary\"\n@@ -16,9 +17,9 @@ import (\n )\n \n var (\n-\tFormatError       = os.NewError(\"zip: not a valid zip file\")\n-\tUnsupportedMethod = os.NewError(\"zip: unsupported compression algorithm\")\n-\tChecksumError     = os.NewError(\"zip: checksum error\")\n+\tFormatError       = errors.New(\"zip: not a valid zip file\")\n+\tUnsupportedMethod = errors.New(\"zip: unsupported compression algorithm\")\n+\tChecksumError     = errors.New(\"zip: checksum error\")\n )\n \n type Reader struct {\n@@ -44,7 +45,7 @@ func (f *File) hasDataDescriptor() bool {\n }\n \n // OpenReader will open the Zip file specified by name and return a ReadCloser.\n-func OpenReader(name string) (*ReadCloser, os.Error) {\n+func OpenReader(name string) (*ReadCloser, error) {\n \tf, err := os.Open(name)\n \tif err != nil {\n \t\treturn nil, err\n@@ -64,15 +65,15 @@ func OpenReader(name string) (*ReadCloser, os.Error) {\n \n // NewReader returns a new Reader reading from r, which is assumed to\n // have the given size in bytes.\n-func NewReader(r io.ReaderAt, size int64) (*Reader, os.Error) {\n+func NewReader(r io.ReaderAt, size int64) (*Reader, error) {\n \tzr := new(Reader)\n \tif err := zr.init(r, size); err != nil {\n \t\treturn nil, err\n \t}\n \treturn zr, nil\n }\n \n-func (z *Reader) init(r io.ReaderAt, size int64) os.Error {\n+func (z *Reader) init(r io.ReaderAt, size int64) error {\n \tend, err := readDirectoryEnd(r, size)\n \tif err != nil {\n \t\treturn err\n@@ -110,13 +111,13 @@ func (z *Reader) init(r io.ReaderAt, size int64) os.Error {\n }\n \n // Close closes the Zip file, rendering it unusable for I/O.\n-func (rc *ReadCloser) Close() os.Error {\n+func (rc *ReadCloser) Close() error {\n \treturn rc.f.Close()\n }\n \n // Open returns a ReadCloser that provides access to the File's contents.\n // It is safe to Open and Read from files concurrently.\n-func (f *File) Open() (rc io.ReadCloser, err os.Error) {\n+func (f *File) Open() (rc io.ReadCloser, err error) {\n \tbodyOffset, err := f.findBodyOffset()\n \tif err != nil {\n \t\treturn\n@@ -148,10 +149,10 @@ type checksumReader struct {\n \tzipr io.Reader // for reading the data descriptor\n }\n \n-func (r *checksumReader) Read(b []byte) (n int, err os.Error) {\n+func (r *checksumReader) Read(b []byte) (n int, err error) {\n \tn, err = r.rc.Read(b)\n \tr.hash.Write(b[:n])\n-\tif err != os.EOF {\n+\tif err != io.EOF {\n \t\treturn\n \t}\n \tif r.f.hasDataDescriptor() {\n@@ -165,9 +166,9 @@ func (r *checksumReader) Read(b []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (r *checksumReader) Close() os.Error { return r.rc.Close() }\n+func (r *checksumReader) Close() error { return r.rc.Close() }\n \n-func readFileHeader(f *File, r io.Reader) os.Error {\n+func readFileHeader(f *File, r io.Reader) error {\n \tvar b [fileHeaderLen]byte\n \tif _, err := io.ReadFull(r, b[:]); err != nil {\n \t\treturn err\n@@ -197,7 +198,7 @@ func readFileHeader(f *File, r io.Reader) os.Error {\n \n // findBodyOffset does the minimum work to verify the file has a header\n // and returns the file body offset.\n-func (f *File) findBodyOffset() (int64, os.Error) {\n+func (f *File) findBodyOffset() (int64, error) {\n \tr := io.NewSectionReader(f.zipr, f.headerOffset, f.zipsize-f.headerOffset)\n \tvar b [fileHeaderLen]byte\n \tif _, err := io.ReadFull(r, b[:]); err != nil {\n@@ -215,7 +216,7 @@ func (f *File) findBodyOffset() (int64, os.Error) {\n // readDirectoryHeader attempts to read a directory header from r.\n // It returns io.ErrUnexpectedEOF if it cannot read a complete header,\n // and FormatError if it doesn't find a valid header signature.\n-func readDirectoryHeader(f *File, r io.Reader) os.Error {\n+func readDirectoryHeader(f *File, r io.Reader) error {\n \tvar b [directoryHeaderLen]byte\n \tif _, err := io.ReadFull(r, b[:]); err != nil {\n \t\treturn err\n@@ -250,7 +251,7 @@ func readDirectoryHeader(f *File, r io.Reader) os.Error {\n \treturn nil\n }\n \n-func readDataDescriptor(r io.Reader, f *File) os.Error {\n+func readDataDescriptor(r io.Reader, f *File) error {\n \tvar b [dataDescriptorLen]byte\n \tif _, err := io.ReadFull(r, b[:]); err != nil {\n \t\treturn err\n@@ -262,15 +263,15 @@ func readDataDescriptor(r io.Reader, f *File) os.Error {\n \treturn nil\n }\n \n-func readDirectoryEnd(r io.ReaderAt, size int64) (dir *directoryEnd, err os.Error) {\n+func readDirectoryEnd(r io.ReaderAt, size int64) (dir *directoryEnd, err error) {\n \t// look for directoryEndSignature in the last 1k, then in the last 65k\n \tvar b []byte\n \tfor i, bLen := range []int64{1024, 65 * 1024} {\n \t\tif bLen > size {\n \t\t\tbLen = size\n \t\t}\n \t\tb = make([]byte, int(bLen))\n-\t\tif _, err := r.ReadAt(b, size-bLen); err != nil && err != os.EOF {\n+\t\tif _, err := r.ReadAt(b, size-bLen); err != nil && err != io.EOF {\n \t\t\treturn nil, err\n \t\t}\n \t\tif p := findSignatureInBlock(b); p >= 0 {"}, {"sha": "4d80aab709eae1eecc165002c61dcb7db2ca310c", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"encoding/binary\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -18,7 +17,7 @@ type ZipTest struct {\n \tName    string\n \tComment string\n \tFile    []ZipTestFile\n-\tError   os.Error // the error that Opening this file should return\n+\tError   error // the error that Opening this file should return\n }\n \n type ZipTestFile struct {\n@@ -245,7 +244,7 @@ func TestInvalidFiles(t *testing.T) {\n \n type sliceReaderAt []byte\n \n-func (r sliceReaderAt) ReadAt(b []byte, off int64) (int, os.Error) {\n+func (r sliceReaderAt) ReadAt(b []byte, off int64) (int, error) {\n \tcopy(b, r[int(off):int(off)+len(b)])\n \treturn len(b), nil\n }"}, {"sha": "b862b5a6acb4ce51448fb73ea12278a188d0d896", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,7 +11,7 @@ This package does not support ZIP64 or disk spanning.\n */\n package zip\n \n-import \"os\"\n+import \"errors\"\n import \"time\"\n \n // Compression methods.\n@@ -60,9 +60,9 @@ type directoryEnd struct {\n \tcomment            string\n }\n \n-func recoverError(errp *os.Error) {\n+func recoverError(errp *error) {\n \tif e := recover(); e != nil {\n-\t\tif err, ok := e.(os.Error); ok {\n+\t\tif err, ok := e.(error); ok {\n \t\t\t*errp = err\n \t\t\treturn\n \t\t}\n@@ -96,11 +96,11 @@ func (h *FileHeader) Mtime_ns() int64 {\n \n // Mode returns the permission and mode bits for the FileHeader.\n // An error is returned in case the information is not available.\n-func (h *FileHeader) Mode() (mode uint32, err os.Error) {\n+func (h *FileHeader) Mode() (mode uint32, err error) {\n \tif h.CreatorVersion>>8 == creatorUnix {\n \t\treturn h.ExternalAttrs >> 16, nil\n \t}\n-\treturn 0, os.NewError(\"file mode not available\")\n+\treturn 0, errors.New(\"file mode not available\")\n }\n \n // SetMode changes the permission and mode bits for the FileHeader."}, {"sha": "a1530644eee64d6e222ba5f3e4f9abd51841bfe4", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,10 +8,10 @@ import (\n \t\"bufio\"\n \t\"compress/flate\"\n \t\"encoding/binary\"\n+\t\"errors\"\n \t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n-\t\"os\"\n )\n \n // TODO(adg): support zip file comments\n@@ -37,15 +37,15 @@ func NewWriter(w io.Writer) *Writer {\n \n // Close finishes writing the zip file by writing the central directory.\n // It does not (and can not) close the underlying writer.\n-func (w *Writer) Close() (err os.Error) {\n+func (w *Writer) Close() (err error) {\n \tif w.last != nil && !w.last.closed {\n \t\tif err = w.last.close(); err != nil {\n \t\t\treturn\n \t\t}\n \t\tw.last = nil\n \t}\n \tif w.closed {\n-\t\treturn os.NewError(\"zip: writer closed twice\")\n+\t\treturn errors.New(\"zip: writer closed twice\")\n \t}\n \tw.closed = true\n \n@@ -94,7 +94,7 @@ func (w *Writer) Close() (err os.Error) {\n // It returns a Writer to which the file contents should be written.\n // The file's contents must be written to the io.Writer before the next\n // call to Create, CreateHeader, or Close.\n-func (w *Writer) Create(name string) (io.Writer, os.Error) {\n+func (w *Writer) Create(name string) (io.Writer, error) {\n \theader := &FileHeader{\n \t\tName:   name,\n \t\tMethod: Deflate,\n@@ -107,7 +107,7 @@ func (w *Writer) Create(name string) (io.Writer, os.Error) {\n // It returns a Writer to which the file contents should be written.\n // The file's contents must be written to the io.Writer before the next\n // call to Create, CreateHeader, or Close.\n-func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, os.Error) {\n+func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \tif w.last != nil && !w.last.closed {\n \t\tif err := w.last.close(); err != nil {\n \t\t\treturn nil, err\n@@ -148,7 +148,7 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, os.Error) {\n \treturn fw, nil\n }\n \n-func writeHeader(w io.Writer, h *FileHeader) (err os.Error) {\n+func writeHeader(w io.Writer, h *FileHeader) (err error) {\n \tdefer recoverError(&err)\n \twrite(w, uint32(fileHeaderSignature))\n \twrite(w, h.ReaderVersion)\n@@ -176,17 +176,17 @@ type fileWriter struct {\n \tclosed    bool\n }\n \n-func (w *fileWriter) Write(p []byte) (int, os.Error) {\n+func (w *fileWriter) Write(p []byte) (int, error) {\n \tif w.closed {\n-\t\treturn 0, os.NewError(\"zip: write to closed file\")\n+\t\treturn 0, errors.New(\"zip: write to closed file\")\n \t}\n \tw.crc32.Write(p)\n \treturn w.rawCount.Write(p)\n }\n \n-func (w *fileWriter) close() (err os.Error) {\n+func (w *fileWriter) close() (err error) {\n \tif w.closed {\n-\t\treturn os.NewError(\"zip: file closed twice\")\n+\t\treturn errors.New(\"zip: file closed twice\")\n \t}\n \tw.closed = true\n \tif err = w.comp.Close(); err != nil {\n@@ -213,7 +213,7 @@ type countWriter struct {\n \tcount int64\n }\n \n-func (w *countWriter) Write(p []byte) (int, os.Error) {\n+func (w *countWriter) Write(p []byte) (int, error) {\n \tn, err := w.w.Write(p)\n \tw.count += int64(n)\n \treturn n, err\n@@ -223,7 +223,7 @@ type nopCloser struct {\n \tio.Writer\n }\n \n-func (w nopCloser) Close() os.Error {\n+func (w nopCloser) Close() error {\n \treturn nil\n }\n "}, {"sha": "2075715f3e01de96b42f30f99109729798236013", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,15 +9,15 @@ package zip\n import (\n \t\"bytes\"\n \t\"fmt\"\n-\t\"os\"\n+\t\"io\"\n \t\"testing\"\n )\n \n type stringReaderAt string\n \n-func (s stringReaderAt) ReadAt(p []byte, off int64) (n int, err os.Error) {\n+func (s stringReaderAt) ReadAt(p []byte, off int64) (n int, err error) {\n \tif off >= int64(len(s)) {\n-\t\treturn 0, os.EOF\n+\t\treturn 0, io.EOF\n \t}\n \tn = copy(p, s[off:])\n \treturn"}, {"sha": "73e733e365912b7fe7b60a2c0034509e3261be7d", "filename": "libgo/go/asn1/asn1.go", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fasn1.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -22,7 +22,6 @@ package asn1\n import (\n \t\"big\"\n \t\"fmt\"\n-\t\"os\"\n \t\"reflect\"\n \t\"time\"\n )\n@@ -33,20 +32,20 @@ type StructuralError struct {\n \tMsg string\n }\n \n-func (e StructuralError) String() string { return \"ASN.1 structure error: \" + e.Msg }\n+func (e StructuralError) Error() string { return \"ASN.1 structure error: \" + e.Msg }\n \n // A SyntaxError suggests that the ASN.1 data is invalid.\n type SyntaxError struct {\n \tMsg string\n }\n \n-func (e SyntaxError) String() string { return \"ASN.1 syntax error: \" + e.Msg }\n+func (e SyntaxError) Error() string { return \"ASN.1 syntax error: \" + e.Msg }\n \n // We start by dealing with each of the primitive types in turn.\n \n // BOOLEAN\n \n-func parseBool(bytes []byte) (ret bool, err os.Error) {\n+func parseBool(bytes []byte) (ret bool, err error) {\n \tif len(bytes) != 1 {\n \t\terr = SyntaxError{\"invalid boolean\"}\n \t\treturn\n@@ -59,7 +58,7 @@ func parseBool(bytes []byte) (ret bool, err os.Error) {\n \n // parseInt64 treats the given bytes as a big-endian, signed integer and\n // returns the result.\n-func parseInt64(bytes []byte) (ret int64, err os.Error) {\n+func parseInt64(bytes []byte) (ret int64, err error) {\n \tif len(bytes) > 8 {\n \t\t// We'll overflow an int64 in this case.\n \t\terr = StructuralError{\"integer too large\"}\n@@ -78,7 +77,7 @@ func parseInt64(bytes []byte) (ret int64, err os.Error) {\n \n // parseInt treats the given bytes as a big-endian, signed integer and returns\n // the result.\n-func parseInt(bytes []byte) (int, os.Error) {\n+func parseInt(bytes []byte) (int, error) {\n \tret64, err := parseInt64(bytes)\n \tif err != nil {\n \t\treturn 0, err\n@@ -150,7 +149,7 @@ func (b BitString) RightAlign() []byte {\n }\n \n // parseBitString parses an ASN.1 bit string from the given byte slice and returns it.\n-func parseBitString(bytes []byte) (ret BitString, err os.Error) {\n+func parseBitString(bytes []byte) (ret BitString, err error) {\n \tif len(bytes) == 0 {\n \t\terr = SyntaxError{\"zero length BIT STRING\"}\n \t\treturn\n@@ -189,7 +188,7 @@ func (oi ObjectIdentifier) Equal(other ObjectIdentifier) bool {\n // parseObjectIdentifier parses an OBJECT IDENTIFIER from the given bytes and\n // returns it. An object identifier is a sequence of variable length integers\n // that are assigned in a hierarchy.\n-func parseObjectIdentifier(bytes []byte) (s []int, err os.Error) {\n+func parseObjectIdentifier(bytes []byte) (s []int, err error) {\n \tif len(bytes) == 0 {\n \t\terr = SyntaxError{\"zero length OBJECT IDENTIFIER\"}\n \t\treturn\n@@ -227,7 +226,7 @@ type Flag bool\n \n // parseBase128Int parses a base-128 encoded int from the given offset in the\n // given byte slice. It returns the value and the new offset.\n-func parseBase128Int(bytes []byte, initOffset int) (ret, offset int, err os.Error) {\n+func parseBase128Int(bytes []byte, initOffset int) (ret, offset int, err error) {\n \toffset = initOffset\n \tfor shifted := 0; offset < len(bytes); shifted++ {\n \t\tif shifted > 4 {\n@@ -248,7 +247,7 @@ func parseBase128Int(bytes []byte, initOffset int) (ret, offset int, err os.Erro\n \n // UTCTime\n \n-func parseUTCTime(bytes []byte) (ret *time.Time, err os.Error) {\n+func parseUTCTime(bytes []byte) (ret *time.Time, err error) {\n \ts := string(bytes)\n \tret, err = time.Parse(\"0601021504Z0700\", s)\n \tif err == nil {\n@@ -260,15 +259,15 @@ func parseUTCTime(bytes []byte) (ret *time.Time, err os.Error) {\n \n // parseGeneralizedTime parses the GeneralizedTime from the given byte slice\n // and returns the resulting time.\n-func parseGeneralizedTime(bytes []byte) (ret *time.Time, err os.Error) {\n+func parseGeneralizedTime(bytes []byte) (ret *time.Time, err error) {\n \treturn time.Parse(\"20060102150405Z0700\", string(bytes))\n }\n \n // PrintableString\n \n // parsePrintableString parses a ASN.1 PrintableString from the given byte\n // array and returns it.\n-func parsePrintableString(bytes []byte) (ret string, err os.Error) {\n+func parsePrintableString(bytes []byte) (ret string, err error) {\n \tfor _, b := range bytes {\n \t\tif !isPrintable(b) {\n \t\t\terr = SyntaxError{\"PrintableString contains invalid character\"}\n@@ -300,7 +299,7 @@ func isPrintable(b byte) bool {\n \n // parseIA5String parses a ASN.1 IA5String (ASCII string) from the given\n // byte slice and returns it.\n-func parseIA5String(bytes []byte) (ret string, err os.Error) {\n+func parseIA5String(bytes []byte) (ret string, err error) {\n \tfor _, b := range bytes {\n \t\tif b >= 0x80 {\n \t\t\terr = SyntaxError{\"IA5String contains invalid character\"}\n@@ -315,15 +314,15 @@ func parseIA5String(bytes []byte) (ret string, err os.Error) {\n \n // parseT61String parses a ASN.1 T61String (8-bit clean string) from the given\n // byte slice and returns it.\n-func parseT61String(bytes []byte) (ret string, err os.Error) {\n+func parseT61String(bytes []byte) (ret string, err error) {\n \treturn string(bytes), nil\n }\n \n // UTF8String\n \n // parseUTF8String parses a ASN.1 UTF8String (raw UTF-8) from the given byte\n // array and returns it.\n-func parseUTF8String(bytes []byte) (ret string, err os.Error) {\n+func parseUTF8String(bytes []byte) (ret string, err error) {\n \treturn string(bytes), nil\n }\n \n@@ -346,7 +345,7 @@ type RawContent []byte\n // into a byte slice. It returns the parsed data and the new offset. SET and\n // SET OF (tag 17) are mapped to SEQUENCE and SEQUENCE OF (tag 16) since we\n // don't distinguish between ordered and unordered objects in this code.\n-func parseTagAndLength(bytes []byte, initOffset int) (ret tagAndLength, offset int, err os.Error) {\n+func parseTagAndLength(bytes []byte, initOffset int) (ret tagAndLength, offset int, err error) {\n \toffset = initOffset\n \tb := bytes[offset]\n \toffset++\n@@ -402,7 +401,7 @@ func parseTagAndLength(bytes []byte, initOffset int) (ret tagAndLength, offset i\n // parseSequenceOf is used for SEQUENCE OF and SET OF values. It tries to parse\n // a number of ASN.1 values from the given byte slice and returns them as a\n // slice of Go values of the given type.\n-func parseSequenceOf(bytes []byte, sliceType reflect.Type, elemType reflect.Type) (ret reflect.Value, err os.Error) {\n+func parseSequenceOf(bytes []byte, sliceType reflect.Type, elemType reflect.Type) (ret reflect.Value, err error) {\n \texpectedTag, compoundType, ok := getUniversalType(elemType)\n \tif !ok {\n \t\terr = StructuralError{\"unknown Go type for slice\"}\n@@ -466,7 +465,7 @@ func invalidLength(offset, length, sliceLength int) bool {\n // parseField is the main parsing function. Given a byte slice and an offset\n // into the array, it will try to parse a suitable ASN.1 value out and store it\n // in the given Value.\n-func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParameters) (offset int, err os.Error) {\n+func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParameters) (offset int, err error) {\n \toffset = initOffset\n \tfieldType := v.Type()\n \n@@ -649,7 +648,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\treturn\n \tcase timeType:\n \t\tvar time *time.Time\n-\t\tvar err1 os.Error\n+\t\tvar err1 error\n \t\tif universalTag == tagUTCTime {\n \t\t\ttime, err1 = parseUTCTime(innerBytes)\n \t\t} else {\n@@ -826,13 +825,13 @@ func setDefaultValue(v reflect.Value, params fieldParameters) (ok bool) {\n //\n // Other ASN.1 types are not supported; if it encounters them,\n // Unmarshal returns a parse error.\n-func Unmarshal(b []byte, val interface{}) (rest []byte, err os.Error) {\n+func Unmarshal(b []byte, val interface{}) (rest []byte, err error) {\n \treturn UnmarshalWithParams(b, val, \"\")\n }\n \n // UnmarshalWithParams allows field parameters to be specified for the\n // top-level element. The form of the params is the same as the field tags.\n-func UnmarshalWithParams(b []byte, val interface{}, params string) (rest []byte, err os.Error) {\n+func UnmarshalWithParams(b []byte, val interface{}, params string) (rest []byte, err error) {\n \tv := reflect.ValueOf(val).Elem()\n \toffset, err := parseField(v, b, 0, parseFieldParameters(params))\n \tif err != nil {"}, {"sha": "583d0104711e3bf7a28face0cffaded9e05ad63c", "filename": "libgo/go/asn1/marshal.go", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fmarshal.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n-\t\"os\"\n \t\"reflect\"\n \t\"time\"\n )\n@@ -48,7 +47,7 @@ func (f *forkableWriter) Len() (l int) {\n \treturn\n }\n \n-func (f *forkableWriter) writeTo(out io.Writer) (n int, err os.Error) {\n+func (f *forkableWriter) writeTo(out io.Writer) (n int, err error) {\n \tn, err = out.Write(f.Bytes())\n \tif err != nil {\n \t\treturn\n@@ -71,7 +70,7 @@ func (f *forkableWriter) writeTo(out io.Writer) (n int, err os.Error) {\n \treturn\n }\n \n-func marshalBase128Int(out *forkableWriter, n int64) (err os.Error) {\n+func marshalBase128Int(out *forkableWriter, n int64) (err error) {\n \tif n == 0 {\n \t\terr = out.WriteByte(0)\n \t\treturn\n@@ -97,7 +96,7 @@ func marshalBase128Int(out *forkableWriter, n int64) (err os.Error) {\n \treturn nil\n }\n \n-func marshalInt64(out *forkableWriter, i int64) (err os.Error) {\n+func marshalInt64(out *forkableWriter, i int64) (err error) {\n \tn := int64Length(i)\n \n \tfor ; n > 0; n-- {\n@@ -126,7 +125,7 @@ func int64Length(i int64) (numBytes int) {\n \treturn\n }\n \n-func marshalBigInt(out *forkableWriter, n *big.Int) (err os.Error) {\n+func marshalBigInt(out *forkableWriter, n *big.Int) (err error) {\n \tif n.Sign() < 0 {\n \t\t// A negative number has to be converted to two's-complement\n \t\t// form. So we'll subtract 1 and invert. If the\n@@ -163,7 +162,7 @@ func marshalBigInt(out *forkableWriter, n *big.Int) (err os.Error) {\n \treturn\n }\n \n-func marshalLength(out *forkableWriter, i int) (err os.Error) {\n+func marshalLength(out *forkableWriter, i int) (err error) {\n \tn := lengthLength(i)\n \n \tfor ; n > 0; n-- {\n@@ -185,7 +184,7 @@ func lengthLength(i int) (numBytes int) {\n \treturn\n }\n \n-func marshalTagAndLength(out *forkableWriter, t tagAndLength) (err os.Error) {\n+func marshalTagAndLength(out *forkableWriter, t tagAndLength) (err error) {\n \tb := uint8(t.class) << 6\n \tif t.isCompound {\n \t\tb |= 0x20\n@@ -228,7 +227,7 @@ func marshalTagAndLength(out *forkableWriter, t tagAndLength) (err os.Error) {\n \treturn nil\n }\n \n-func marshalBitString(out *forkableWriter, b BitString) (err os.Error) {\n+func marshalBitString(out *forkableWriter, b BitString) (err error) {\n \tpaddingBits := byte((8 - b.BitLength%8) % 8)\n \terr = out.WriteByte(paddingBits)\n \tif err != nil {\n@@ -238,7 +237,7 @@ func marshalBitString(out *forkableWriter, b BitString) (err os.Error) {\n \treturn\n }\n \n-func marshalObjectIdentifier(out *forkableWriter, oid []int) (err os.Error) {\n+func marshalObjectIdentifier(out *forkableWriter, oid []int) (err error) {\n \tif len(oid) < 2 || oid[0] > 6 || oid[1] >= 40 {\n \t\treturn StructuralError{\"invalid object identifier\"}\n \t}\n@@ -257,7 +256,7 @@ func marshalObjectIdentifier(out *forkableWriter, oid []int) (err os.Error) {\n \treturn\n }\n \n-func marshalPrintableString(out *forkableWriter, s string) (err os.Error) {\n+func marshalPrintableString(out *forkableWriter, s string) (err error) {\n \tb := []byte(s)\n \tfor _, c := range b {\n \t\tif !isPrintable(c) {\n@@ -269,7 +268,7 @@ func marshalPrintableString(out *forkableWriter, s string) (err os.Error) {\n \treturn\n }\n \n-func marshalIA5String(out *forkableWriter, s string) (err os.Error) {\n+func marshalIA5String(out *forkableWriter, s string) (err error) {\n \tb := []byte(s)\n \tfor _, c := range b {\n \t\tif c > 127 {\n@@ -281,15 +280,15 @@ func marshalIA5String(out *forkableWriter, s string) (err os.Error) {\n \treturn\n }\n \n-func marshalTwoDigits(out *forkableWriter, v int) (err os.Error) {\n+func marshalTwoDigits(out *forkableWriter, v int) (err error) {\n \terr = out.WriteByte(byte('0' + (v/10)%10))\n \tif err != nil {\n \t\treturn\n \t}\n \treturn out.WriteByte(byte('0' + v%10))\n }\n \n-func marshalUTCTime(out *forkableWriter, t *time.Time) (err os.Error) {\n+func marshalUTCTime(out *forkableWriter, t *time.Time) (err error) {\n \tswitch {\n \tcase 1950 <= t.Year && t.Year < 2000:\n \t\terr = marshalTwoDigits(out, int(t.Year-1900))\n@@ -364,7 +363,7 @@ func stripTagAndLength(in []byte) []byte {\n \treturn in[offset:]\n }\n \n-func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameters) (err os.Error) {\n+func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameters) (err error) {\n \tswitch value.Type() {\n \tcase timeType:\n \t\treturn marshalUTCTime(out, value.Interface().(*time.Time))\n@@ -452,7 +451,7 @@ func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameter\n \treturn StructuralError{\"unknown Go type\"}\n }\n \n-func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters) (err os.Error) {\n+func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters) (err error) {\n \t// If the field is an interface{} then recurse into it.\n \tif v.Kind() == reflect.Interface && v.Type().NumMethod() == 0 {\n \t\treturn marshalField(out, v.Elem(), params)\n@@ -535,7 +534,7 @@ func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters)\n }\n \n // Marshal returns the ASN.1 encoding of val.\n-func Marshal(val interface{}) ([]byte, os.Error) {\n+func Marshal(val interface{}) ([]byte, error) {\n \tvar out bytes.Buffer\n \tv := reflect.ValueOf(val)\n \tf := newForkableWriter()"}, {"sha": "c6affbbdaebe1929e60d0febcab3921d17870775", "filename": "libgo/go/big/int.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,9 +7,9 @@\n package big\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"os\"\n \t\"rand\"\n \t\"strings\"\n )\n@@ -432,7 +432,7 @@ func (x *Int) Format(s fmt.State, ch rune) {\n // ``0x'' or ``0X'' selects base 16; the ``0'' prefix selects base 8, and a\n // ``0b'' or ``0B'' prefix selects base 2. Otherwise the selected base is 10.\n //\n-func (z *Int) scan(r io.RuneScanner, base int) (*Int, int, os.Error) {\n+func (z *Int) scan(r io.RuneScanner, base int) (*Int, int, error) {\n \t// determine sign\n \tch, _, err := r.ReadRune()\n \tif err != nil {\n@@ -460,7 +460,7 @@ func (z *Int) scan(r io.RuneScanner, base int) (*Int, int, os.Error) {\n // Scan is a support routine for fmt.Scanner; it sets z to the value of\n // the scanned number. It accepts the formats 'b' (binary), 'o' (octal),\n // 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).\n-func (z *Int) Scan(s fmt.ScanState, ch rune) os.Error {\n+func (z *Int) Scan(s fmt.ScanState, ch rune) error {\n \ts.SkipSpace() // skip leading space characters\n \tbase := 0\n \tswitch ch {\n@@ -475,7 +475,7 @@ func (z *Int) Scan(s fmt.ScanState, ch rune) os.Error {\n \tcase 's', 'v':\n \t\t// let scan determine the base\n \tdefault:\n-\t\treturn os.NewError(\"Int.Scan: invalid verb\")\n+\t\treturn errors.New(\"Int.Scan: invalid verb\")\n \t}\n \t_, _, err := z.scan(s, base)\n \treturn err\n@@ -513,7 +513,7 @@ func (z *Int) SetString(s string, base int) (*Int, bool) {\n \t\treturn nil, false\n \t}\n \t_, _, err = r.ReadRune()\n-\tif err != os.EOF {\n+\tif err != io.EOF {\n \t\treturn nil, false\n \t}\n \treturn z, true // err == os.EOF => scan consumed all of s\n@@ -847,7 +847,7 @@ func (z *Int) Not(x *Int) *Int {\n const intGobVersion byte = 1\n \n // GobEncode implements the gob.GobEncoder interface.\n-func (z *Int) GobEncode() ([]byte, os.Error) {\n+func (z *Int) GobEncode() ([]byte, error) {\n \tbuf := make([]byte, 1+len(z.abs)*_S) // extra byte for version and sign bit\n \ti := z.abs.bytes(buf) - 1            // i >= 0\n \tb := intGobVersion << 1              // make space for sign bit\n@@ -859,13 +859,13 @@ func (z *Int) GobEncode() ([]byte, os.Error) {\n }\n \n // GobDecode implements the gob.GobDecoder interface.\n-func (z *Int) GobDecode(buf []byte) os.Error {\n+func (z *Int) GobDecode(buf []byte) error {\n \tif len(buf) == 0 {\n-\t\treturn os.NewError(\"Int.GobDecode: no data\")\n+\t\treturn errors.New(\"Int.GobDecode: no data\")\n \t}\n \tb := buf[0]\n \tif b>>1 != intGobVersion {\n-\t\treturn os.NewError(fmt.Sprintf(\"Int.GobDecode: encoding version %d not supported\", b>>1))\n+\t\treturn errors.New(fmt.Sprintf(\"Int.GobDecode: encoding version %d not supported\", b>>1))\n \t}\n \tz.neg = b&1 != 0\n \tz.abs = z.abs.setBytes(buf[1:])"}, {"sha": "a46f782ac210e2c423c71ab23de37c9fd677a344", "filename": "libgo/go/big/nat.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fnat.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -19,8 +19,8 @@ package big\n // and rationals.\n \n import (\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n \t\"rand\"\n )\n \n@@ -613,10 +613,10 @@ func hexValue(ch rune) Word {\n // ``0x'' or ``0X'' selects base 16; the ``0'' prefix selects base 8, and a\n // ``0b'' or ``0B'' prefix selects base 2. Otherwise the selected base is 10.\n //\n-func (z nat) scan(r io.RuneScanner, base int) (nat, int, os.Error) {\n+func (z nat) scan(r io.RuneScanner, base int) (nat, int, error) {\n \t// reject illegal bases\n \tif base < 0 || base == 1 || MaxBase < base {\n-\t\treturn z, 0, os.NewError(\"illegal number base\")\n+\t\treturn z, 0, errors.New(\"illegal number base\")\n \t}\n \n \t// one char look-ahead\n@@ -644,7 +644,7 @@ func (z nat) scan(r io.RuneScanner, base int) (nat, int, os.Error) {\n \t\t\t\t\t\treturn z, 0, err\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\tcase os.EOF:\n+\t\t\tcase io.EOF:\n \t\t\t\treturn z.make(0), 10, nil\n \t\t\tdefault:\n \t\t\t\treturn z, 10, err\n@@ -676,7 +676,7 @@ func (z nat) scan(r io.RuneScanner, base int) (nat, int, os.Error) {\n \t\t}\n \n \t\tif ch, _, err = r.ReadRune(); err != nil {\n-\t\t\tif err != os.EOF {\n+\t\t\tif err != io.EOF {\n \t\t\t\treturn z, int(b), err\n \t\t\t}\n \t\t\tbreak\n@@ -693,7 +693,7 @@ func (z nat) scan(r io.RuneScanner, base int) (nat, int, os.Error) {\n \t\treturn z, 10, nil\n \tcase base != 0 || b != 8:\n \t\t// there was neither a mantissa digit nor the octal prefix 0\n-\t\treturn z, int(b), os.NewError(\"syntax error scanning number\")\n+\t\treturn z, int(b), errors.New(\"syntax error scanning number\")\n \t}\n \n \treturn z.norm(), int(b), nil"}, {"sha": "041a6c4a255f884163bb8e267d70ba6535252f03", "filename": "libgo/go/big/nat_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fnat_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,7 +6,7 @@ package big\n \n import (\n \t\"fmt\"\n-\t\"os\"\n+\t\"io\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -288,7 +288,7 @@ func TestScanBase(t *testing.T) {\n \t\t\tt.Errorf(\"scan%+v\\n\\tgot b = %d; want %d\", a, b, a.base)\n \t\t}\n \t\tnext, _, err := r.ReadRune()\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\tnext = 0\n \t\t\terr = nil\n \t\t}"}, {"sha": "3a0add3236361df14a4806a8b2970ef203102ad9", "filename": "libgo/go/big/rat.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbig%2Frat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbig%2Frat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Frat.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,8 +8,8 @@ package big\n \n import (\n \t\"encoding/binary\"\n+\t\"errors\"\n \t\"fmt\"\n-\t\"os\"\n \t\"strings\"\n )\n \n@@ -255,16 +255,16 @@ func ratTok(ch rune) bool {\n \n // Scan is a support routine for fmt.Scanner. It accepts the formats\n // 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.\n-func (z *Rat) Scan(s fmt.ScanState, ch rune) os.Error {\n+func (z *Rat) Scan(s fmt.ScanState, ch rune) error {\n \ttok, err := s.Token(true, ratTok)\n \tif err != nil {\n \t\treturn err\n \t}\n \tif strings.IndexRune(\"efgEFGv\", ch) < 0 {\n-\t\treturn os.NewError(\"Rat.Scan: invalid verb\")\n+\t\treturn errors.New(\"Rat.Scan: invalid verb\")\n \t}\n \tif _, ok := z.SetString(string(tok)); !ok {\n-\t\treturn os.NewError(\"Rat.Scan: invalid syntax\")\n+\t\treturn errors.New(\"Rat.Scan: invalid syntax\")\n \t}\n \treturn nil\n }\n@@ -285,7 +285,7 @@ func (z *Rat) SetString(s string) (*Rat, bool) {\n \t\t\treturn nil, false\n \t\t}\n \t\ts = s[sep+1:]\n-\t\tvar err os.Error\n+\t\tvar err error\n \t\tif z.b, _, err = z.b.scan(strings.NewReader(s), 10); err != nil {\n \t\t\treturn nil, false\n \t\t}\n@@ -395,14 +395,14 @@ func (z *Rat) FloatString(prec int) string {\n const ratGobVersion byte = 1\n \n // GobEncode implements the gob.GobEncoder interface.\n-func (z *Rat) GobEncode() ([]byte, os.Error) {\n+func (z *Rat) GobEncode() ([]byte, error) {\n \tbuf := make([]byte, 1+4+(len(z.a.abs)+len(z.b))*_S) // extra bytes for version and sign bit (1), and numerator length (4)\n \ti := z.b.bytes(buf)\n \tj := z.a.abs.bytes(buf[0:i])\n \tn := i - j\n \tif int(uint32(n)) != n {\n \t\t// this should never happen\n-\t\treturn nil, os.NewError(\"Rat.GobEncode: numerator too large\")\n+\t\treturn nil, errors.New(\"Rat.GobEncode: numerator too large\")\n \t}\n \tbinary.BigEndian.PutUint32(buf[j-4:j], uint32(n))\n \tj -= 1 + 4\n@@ -415,13 +415,13 @@ func (z *Rat) GobEncode() ([]byte, os.Error) {\n }\n \n // GobDecode implements the gob.GobDecoder interface.\n-func (z *Rat) GobDecode(buf []byte) os.Error {\n+func (z *Rat) GobDecode(buf []byte) error {\n \tif len(buf) == 0 {\n-\t\treturn os.NewError(\"Rat.GobDecode: no data\")\n+\t\treturn errors.New(\"Rat.GobDecode: no data\")\n \t}\n \tb := buf[0]\n \tif b>>1 != ratGobVersion {\n-\t\treturn os.NewError(fmt.Sprintf(\"Rat.GobDecode: encoding version %d not supported\", b>>1))\n+\t\treturn errors.New(fmt.Sprintf(\"Rat.GobDecode: encoding version %d not supported\", b>>1))\n \t}\n \tconst j = 1 + 4\n \ti := j + binary.BigEndian.Uint32(buf[j-4:j])"}, {"sha": "f4ed91b24b4a94deadce5ddaa89fe10e040a9683", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,7 +10,6 @@ package bufio\n import (\n \t\"bytes\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n \t\"utf8\"\n )\n@@ -24,20 +23,20 @@ type Error struct {\n \tErrorString string\n }\n \n-func (err *Error) String() string { return err.ErrorString }\n+func (err *Error) Error() string { return err.ErrorString }\n \n var (\n-\tErrInvalidUnreadByte os.Error = &Error{\"bufio: invalid use of UnreadByte\"}\n-\tErrInvalidUnreadRune os.Error = &Error{\"bufio: invalid use of UnreadRune\"}\n-\tErrBufferFull        os.Error = &Error{\"bufio: buffer full\"}\n-\tErrNegativeCount     os.Error = &Error{\"bufio: negative count\"}\n-\terrInternal          os.Error = &Error{\"bufio: internal error\"}\n+\tErrInvalidUnreadByte error = &Error{\"bufio: invalid use of UnreadByte\"}\n+\tErrInvalidUnreadRune error = &Error{\"bufio: invalid use of UnreadRune\"}\n+\tErrBufferFull        error = &Error{\"bufio: buffer full\"}\n+\tErrNegativeCount     error = &Error{\"bufio: negative count\"}\n+\terrInternal          error = &Error{\"bufio: internal error\"}\n )\n \n // BufSizeError is the error representing an invalid buffer size.\n type BufSizeError int\n \n-func (b BufSizeError) String() string {\n+func (b BufSizeError) Error() string {\n \treturn \"bufio: bad buffer size \" + strconv.Itoa(int(b))\n }\n \n@@ -48,7 +47,7 @@ type Reader struct {\n \tbuf          []byte\n \trd           io.Reader\n \tr, w         int\n-\terr          os.Error\n+\terr          error\n \tlastByte     int\n \tlastRuneSize int\n }\n@@ -57,7 +56,7 @@ type Reader struct {\n // which must be greater than one.  If the argument io.Reader is already a\n // Reader with large enough size, it returns the underlying Reader.\n // It returns the Reader and any error.\n-func NewReaderSize(rd io.Reader, size int) (*Reader, os.Error) {\n+func NewReaderSize(rd io.Reader, size int) (*Reader, error) {\n \tif size <= 1 {\n \t\treturn nil, BufSizeError(size)\n \t}\n@@ -101,7 +100,7 @@ func (b *Reader) fill() {\n \t}\n }\n \n-func (b *Reader) readErr() os.Error {\n+func (b *Reader) readErr() error {\n \terr := b.err\n \tb.err = nil\n \treturn err\n@@ -111,7 +110,7 @@ func (b *Reader) readErr() os.Error {\n // being valid at the next read call. If Peek returns fewer than n bytes, it\n // also returns an error explaining why the read is short. The error is\n // ErrBufferFull if n is larger than b's buffer size.\n-func (b *Reader) Peek(n int) ([]byte, os.Error) {\n+func (b *Reader) Peek(n int) ([]byte, error) {\n \tif n < 0 {\n \t\treturn nil, ErrNegativeCount\n \t}\n@@ -137,7 +136,7 @@ func (b *Reader) Peek(n int) ([]byte, os.Error) {\n // It calls Read at most once on the underlying Reader,\n // hence n may be less than len(p).\n // At EOF, the count will be zero and err will be os.EOF.\n-func (b *Reader) Read(p []byte) (n int, err os.Error) {\n+func (b *Reader) Read(p []byte) (n int, err error) {\n \tn = len(p)\n \tif n == 0 {\n \t\treturn 0, b.readErr()\n@@ -174,7 +173,7 @@ func (b *Reader) Read(p []byte) (n int, err os.Error) {\n \n // ReadByte reads and returns a single byte.\n // If no byte is available, returns an error.\n-func (b *Reader) ReadByte() (c byte, err os.Error) {\n+func (b *Reader) ReadByte() (c byte, err error) {\n \tb.lastRuneSize = -1\n \tfor b.w == b.r {\n \t\tif b.err != nil {\n@@ -189,7 +188,7 @@ func (b *Reader) ReadByte() (c byte, err os.Error) {\n }\n \n // UnreadByte unreads the last byte.  Only the most recently read byte can be unread.\n-func (b *Reader) UnreadByte() os.Error {\n+func (b *Reader) UnreadByte() error {\n \tb.lastRuneSize = -1\n \tif b.r == b.w && b.lastByte >= 0 {\n \t\tb.w = 1\n@@ -208,7 +207,7 @@ func (b *Reader) UnreadByte() os.Error {\n \n // ReadRune reads a single UTF-8 encoded Unicode character and returns the\n // rune and its size in bytes.\n-func (b *Reader) ReadRune() (r rune, size int, err os.Error) {\n+func (b *Reader) ReadRune() (r rune, size int, err error) {\n \tfor b.r+utf8.UTFMax > b.w && !utf8.FullRune(b.buf[b.r:b.w]) && b.err == nil {\n \t\tb.fill()\n \t}\n@@ -230,7 +229,7 @@ func (b *Reader) ReadRune() (r rune, size int, err os.Error) {\n // the buffer was not a ReadRune, UnreadRune returns an error.  (In this\n // regard it is stricter than UnreadByte, which will unread the last byte\n // from any read operation.)\n-func (b *Reader) UnreadRune() os.Error {\n+func (b *Reader) UnreadRune() error {\n \tif b.lastRuneSize < 0 || b.r == 0 {\n \t\treturn ErrInvalidUnreadRune\n \t}\n@@ -253,7 +252,7 @@ func (b *Reader) Buffered() int { return b.w - b.r }\n // by the next I/O operation, most clients should use\n // ReadBytes or ReadString instead.\n // ReadSlice returns err != nil if and only if line does not end in delim.\n-func (b *Reader) ReadSlice(delim byte) (line []byte, err os.Error) {\n+func (b *Reader) ReadSlice(delim byte) (line []byte, err error) {\n \t// Look in buffer.\n \tif i := bytes.IndexByte(b.buf[b.r:b.w], delim); i >= 0 {\n \t\tline1 := b.buf[b.r : b.r+i+1]\n@@ -295,7 +294,7 @@ func (b *Reader) ReadSlice(delim byte) (line []byte, err os.Error) {\n // of the line. The returned buffer is only valid until the next call to\n // ReadLine. ReadLine either returns a non-nil line or it returns an error,\n // never both.\n-func (b *Reader) ReadLine() (line []byte, isPrefix bool, err os.Error) {\n+func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) {\n \tline, err = b.ReadSlice('\\n')\n \tif err == ErrBufferFull {\n \t\t// Handle the case where \"\\r\\n\" straddles the buffer.\n@@ -333,15 +332,15 @@ func (b *Reader) ReadLine() (line []byte, isPrefix bool, err os.Error) {\n // it returns the data read before the error and the error itself (often os.EOF).\n // ReadBytes returns err != nil if and only if the returned data does not end in\n // delim.\n-func (b *Reader) ReadBytes(delim byte) (line []byte, err os.Error) {\n+func (b *Reader) ReadBytes(delim byte) (line []byte, err error) {\n \t// Use ReadSlice to look for array,\n \t// accumulating full buffers.\n \tvar frag []byte\n \tvar full [][]byte\n \terr = nil\n \n \tfor {\n-\t\tvar e os.Error\n+\t\tvar e error\n \t\tfrag, e = b.ReadSlice(delim)\n \t\tif e == nil { // got final fragment\n \t\t\tbreak\n@@ -380,7 +379,7 @@ func (b *Reader) ReadBytes(delim byte) (line []byte, err os.Error) {\n // it returns the data read before the error and the error itself (often os.EOF).\n // ReadString returns err != nil if and only if the returned data does not end in\n // delim.\n-func (b *Reader) ReadString(delim byte) (line string, err os.Error) {\n+func (b *Reader) ReadString(delim byte) (line string, err error) {\n \tbytes, e := b.ReadBytes(delim)\n \treturn string(bytes), e\n }\n@@ -389,7 +388,7 @@ func (b *Reader) ReadString(delim byte) (line string, err os.Error) {\n \n // Writer implements buffering for an io.Writer object.\n type Writer struct {\n-\terr os.Error\n+\terr error\n \tbuf []byte\n \tn   int\n \twr  io.Writer\n@@ -399,7 +398,7 @@ type Writer struct {\n // which must be greater than zero. If the argument io.Writer is already a\n // Writer with large enough size, it returns the underlying Writer.\n // It returns the Writer and any error.\n-func NewWriterSize(wr io.Writer, size int) (*Writer, os.Error) {\n+func NewWriterSize(wr io.Writer, size int) (*Writer, error) {\n \tif size <= 0 {\n \t\treturn nil, BufSizeError(size)\n \t}\n@@ -425,7 +424,7 @@ func NewWriter(wr io.Writer) *Writer {\n }\n \n // Flush writes any buffered data to the underlying io.Writer.\n-func (b *Writer) Flush() os.Error {\n+func (b *Writer) Flush() error {\n \tif b.err != nil {\n \t\treturn b.err\n \t}\n@@ -458,7 +457,7 @@ func (b *Writer) Buffered() int { return b.n }\n // It returns the number of bytes written.\n // If nn < len(p), it also returns an error explaining\n // why the write is short.\n-func (b *Writer) Write(p []byte) (nn int, err os.Error) {\n+func (b *Writer) Write(p []byte) (nn int, err error) {\n \tfor len(p) > b.Available() && b.err == nil {\n \t\tvar n int\n \t\tif b.Buffered() == 0 {\n@@ -483,7 +482,7 @@ func (b *Writer) Write(p []byte) (nn int, err os.Error) {\n }\n \n // WriteByte writes a single byte.\n-func (b *Writer) WriteByte(c byte) os.Error {\n+func (b *Writer) WriteByte(c byte) error {\n \tif b.err != nil {\n \t\treturn b.err\n \t}\n@@ -497,7 +496,7 @@ func (b *Writer) WriteByte(c byte) os.Error {\n \n // WriteRune writes a single Unicode code point, returning\n // the number of bytes written and any error.\n-func (b *Writer) WriteRune(r rune) (size int, err os.Error) {\n+func (b *Writer) WriteRune(r rune) (size int, err error) {\n \tif r < utf8.RuneSelf {\n \t\terr = b.WriteByte(byte(r))\n \t\tif err != nil {\n@@ -528,7 +527,7 @@ func (b *Writer) WriteRune(r rune) (size int, err os.Error) {\n // It returns the number of bytes written.\n // If the count is less than len(s), it also returns an error explaining\n // why the write is short.\n-func (b *Writer) WriteString(s string) (int, os.Error) {\n+func (b *Writer) WriteString(s string) (int, error) {\n \tnn := 0\n \tfor len(s) > b.Available() && b.err == nil {\n \t\tn := copy(b.buf[b.n:], s)"}, {"sha": "0285deeb3d18c21a46a7945cdda516ffdc51417e", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -28,7 +28,7 @@ func newRot13Reader(r io.Reader) *rot13Reader {\n \treturn r13\n }\n \n-func (r13 *rot13Reader) Read(p []byte) (int, os.Error) {\n+func (r13 *rot13Reader) Read(p []byte) (int, error) {\n \tn, e := r13.r.Read(p)\n \tif e != nil {\n \t\treturn n, e\n@@ -50,14 +50,14 @@ func readBytes(buf *Reader) string {\n \tnb := 0\n \tfor {\n \t\tc, e := buf.ReadByte()\n-\t\tif e == os.EOF {\n+\t\tif e == io.EOF {\n \t\t\tbreak\n \t\t}\n \t\tif e == nil {\n \t\t\tb[nb] = c\n \t\t\tnb++\n \t\t} else if e != iotest.ErrTimeout {\n-\t\t\tpanic(\"Data: \" + e.String())\n+\t\t\tpanic(\"Data: \" + e.Error())\n \t\t}\n \t}\n \treturn string(b[0:nb])\n@@ -95,11 +95,11 @@ func readLines(b *Reader) string {\n \ts := \"\"\n \tfor {\n \t\ts1, e := b.ReadString('\\n')\n-\t\tif e == os.EOF {\n+\t\tif e == io.EOF {\n \t\t\tbreak\n \t\t}\n \t\tif e != nil && e != iotest.ErrTimeout {\n-\t\t\tpanic(\"GetLines: \" + e.String())\n+\t\t\tpanic(\"GetLines: \" + e.Error())\n \t\t}\n \t\ts += s1\n \t}\n@@ -113,7 +113,7 @@ func reads(buf *Reader, m int) string {\n \tfor {\n \t\tn, e := buf.Read(b[nb : nb+m])\n \t\tnb += n\n-\t\tif e == os.EOF {\n+\t\tif e == io.EOF {\n \t\t\tbreak\n \t\t}\n \t}\n@@ -179,13 +179,13 @@ type StringReader struct {\n \tstep int\n }\n \n-func (r *StringReader) Read(p []byte) (n int, err os.Error) {\n+func (r *StringReader) Read(p []byte) (n int, err error) {\n \tif r.step < len(r.data) {\n \t\ts := r.data[r.step]\n \t\tn = copy(p, s)\n \t\tr.step++\n \t} else {\n-\t\terr = os.EOF\n+\t\terr = io.EOF\n \t}\n \treturn\n }\n@@ -197,7 +197,7 @@ func readRuneSegments(t *testing.T, segments []string) {\n \tfor {\n \t\tr, _, err := r.ReadRune()\n \t\tif err != nil {\n-\t\t\tif err != os.EOF {\n+\t\t\tif err != io.EOF {\n \t\t\t\treturn\n \t\t\t}\n \t\t\tbreak\n@@ -235,7 +235,7 @@ func TestUnreadRune(t *testing.T) {\n \tfor {\n \t\tr1, _, err := r.ReadRune()\n \t\tif err != nil {\n-\t\t\tif err != os.EOF {\n+\t\t\tif err != io.EOF {\n \t\t\t\tt.Error(\"unexpected EOF\")\n \t\t\t}\n \t\t\tbreak\n@@ -328,7 +328,7 @@ func TestUnreadRuneAtEOF(t *testing.T) {\n \t_, _, err := r.ReadRune()\n \tif err == nil {\n \t\tt.Error(\"expected error at EOF\")\n-\t} else if err != os.EOF {\n+\t} else if err != io.EOF {\n \t\tt.Error(\"expected EOF; got\", err)\n \t}\n }\n@@ -413,11 +413,11 @@ func TestWriter(t *testing.T) {\n \n type errorWriterTest struct {\n \tn, m   int\n-\terr    os.Error\n-\texpect os.Error\n+\terr    error\n+\texpect error\n }\n \n-func (w errorWriterTest) Write(p []byte) (int, os.Error) {\n+func (w errorWriterTest) Write(p []byte) (int, error) {\n \treturn len(p) * w.n / w.m, w.err\n }\n \n@@ -559,7 +559,7 @@ func TestPeek(t *testing.T) {\n \tif s, err := buf.Peek(0); string(s) != \"\" || err != nil {\n \t\tt.Fatalf(\"want %q got %q, err=%v\", \"\", string(s), err)\n \t}\n-\tif _, err := buf.Peek(1); err != os.EOF {\n+\tif _, err := buf.Peek(1); err != io.EOF {\n \t\tt.Fatalf(\"want EOF got %v\", err)\n \t}\n }\n@@ -583,7 +583,7 @@ type testReader struct {\n \tstride int\n }\n \n-func (t *testReader) Read(buf []byte) (n int, err os.Error) {\n+func (t *testReader) Read(buf []byte) (n int, err error) {\n \tn = t.stride\n \tif n > len(t.data) {\n \t\tn = len(t.data)\n@@ -594,7 +594,7 @@ func (t *testReader) Read(buf []byte) (n int, err os.Error) {\n \tcopy(buf, t.data)\n \tt.data = t.data[n:]\n \tif len(t.data) == 0 {\n-\t\terr = os.EOF\n+\t\terr = io.EOF\n \t}\n \treturn\n }\n@@ -614,7 +614,7 @@ func testReadLine(t *testing.T, input []byte) {\n \t\t\t\tt.Errorf(\"ReadLine returned prefix\")\n \t\t\t}\n \t\t\tif err != nil {\n-\t\t\t\tif err != os.EOF {\n+\t\t\t\tif err != io.EOF {\n \t\t\t\t\tt.Fatalf(\"Got unknown error: %s\", err)\n \t\t\t\t}\n \t\t\t\tbreak\n@@ -679,7 +679,7 @@ func TestReadAfterLines(t *testing.T) {\n func TestReadEmptyBuffer(t *testing.T) {\n \tl, _ := NewReaderSize(bytes.NewBuffer(nil), 10)\n \tline, isPrefix, err := l.ReadLine()\n-\tif err != os.EOF {\n+\tif err != io.EOF {\n \t\tt.Errorf(\"expected EOF from ReadLine, got '%s' %t %s\", line, isPrefix, err)\n \t}\n }\n@@ -693,15 +693,15 @@ func TestLinesAfterRead(t *testing.T) {\n \t}\n \n \tline, isPrefix, err := l.ReadLine()\n-\tif err != os.EOF {\n+\tif err != io.EOF {\n \t\tt.Errorf(\"expected EOF from ReadLine, got '%s' %t %s\", line, isPrefix, err)\n \t}\n }\n \n type readLineResult struct {\n \tline     []byte\n \tisPrefix bool\n-\terr      os.Error\n+\terr      error\n }\n \n var readLineNewlinesTests = []struct {\n@@ -714,27 +714,27 @@ var readLineNewlinesTests = []struct {\n \t\t{nil, false, nil},\n \t\t{[]byte(\"b\"), true, nil},\n \t\t{nil, false, nil},\n-\t\t{nil, false, os.EOF},\n+\t\t{nil, false, io.EOF},\n \t}},\n \t{\"hello\\r\\nworld\\r\\n\", 6, []readLineResult{\n \t\t{[]byte(\"hello\"), true, nil},\n \t\t{nil, false, nil},\n \t\t{[]byte(\"world\"), true, nil},\n \t\t{nil, false, nil},\n-\t\t{nil, false, os.EOF},\n+\t\t{nil, false, io.EOF},\n \t}},\n \t{\"hello\\rworld\\r\", 6, []readLineResult{\n \t\t{[]byte(\"hello\"), true, nil},\n \t\t{[]byte(\"\\rworld\"), true, nil},\n \t\t{[]byte(\"\\r\"), false, nil},\n-\t\t{nil, false, os.EOF},\n+\t\t{nil, false, io.EOF},\n \t}},\n \t{\"h\\ri\\r\\n\\r\", 2, []readLineResult{\n \t\t{[]byte(\"h\"), true, nil},\n \t\t{[]byte(\"\\ri\"), true, nil},\n \t\t{nil, false, nil},\n \t\t{[]byte(\"\\r\"), false, nil},\n-\t\t{nil, false, os.EOF},\n+\t\t{nil, false, io.EOF},\n \t}},\n }\n "}, {"sha": "fbfd6210b641eda6ba0a51938fd42428dda61438", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,8 +7,8 @@ package bytes\n // Simple byte buffer for marshaling data.\n \n import (\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n \t\"utf8\"\n )\n \n@@ -94,7 +94,7 @@ func (b *Buffer) grow(n int) int {\n \n // Write appends the contents of p to the buffer.  The return\n // value n is the length of p; err is always nil.\n-func (b *Buffer) Write(p []byte) (n int, err os.Error) {\n+func (b *Buffer) Write(p []byte) (n int, err error) {\n \tb.lastRead = opInvalid\n \tm := b.grow(len(p))\n \tcopy(b.buf[m:], p)\n@@ -103,7 +103,7 @@ func (b *Buffer) Write(p []byte) (n int, err os.Error) {\n \n // WriteString appends the contents of s to the buffer.  The return\n // value n is the length of s; err is always nil.\n-func (b *Buffer) WriteString(s string) (n int, err os.Error) {\n+func (b *Buffer) WriteString(s string) (n int, err error) {\n \tb.lastRead = opInvalid\n \tm := b.grow(len(s))\n \treturn copy(b.buf[m:], s), nil\n@@ -119,7 +119,7 @@ const MinRead = 512\n // The return value n is the number of bytes read.\n // Any error except os.EOF encountered during the read\n // is also returned.\n-func (b *Buffer) ReadFrom(r io.Reader) (n int64, err os.Error) {\n+func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) {\n \tb.lastRead = opInvalid\n \t// If buffer is empty, reset to recover space.\n \tif b.off >= len(b.buf) {\n@@ -143,7 +143,7 @@ func (b *Buffer) ReadFrom(r io.Reader) (n int64, err os.Error) {\n \t\tm, e := r.Read(b.buf[len(b.buf):cap(b.buf)])\n \t\tb.buf = b.buf[0 : len(b.buf)+m]\n \t\tn += int64(m)\n-\t\tif e == os.EOF {\n+\t\tif e == io.EOF {\n \t\t\tbreak\n \t\t}\n \t\tif e != nil {\n@@ -157,7 +157,7 @@ func (b *Buffer) ReadFrom(r io.Reader) (n int64, err os.Error) {\n // occurs. The return value n is the number of bytes written; it always\n // fits into an int, but it is int64 to match the io.WriterTo interface.\n // Any error encountered during the write is also returned.\n-func (b *Buffer) WriteTo(w io.Writer) (n int64, err os.Error) {\n+func (b *Buffer) WriteTo(w io.Writer) (n int64, err error) {\n \tb.lastRead = opInvalid\n \tif b.off < len(b.buf) {\n \t\tm, e := w.Write(b.buf[b.off:])\n@@ -177,7 +177,7 @@ func (b *Buffer) WriteTo(w io.Writer) (n int64, err os.Error) {\n // WriteByte appends the byte c to the buffer.\n // The returned error is always nil, but is included\n // to match bufio.Writer's WriteByte.\n-func (b *Buffer) WriteByte(c byte) os.Error {\n+func (b *Buffer) WriteByte(c byte) error {\n \tb.lastRead = opInvalid\n \tm := b.grow(1)\n \tb.buf[m] = c\n@@ -188,7 +188,7 @@ func (b *Buffer) WriteByte(c byte) os.Error {\n // code point r to the buffer, returning its length and\n // an error, which is always nil but is included\n // to match bufio.Writer's WriteRune.\n-func (b *Buffer) WriteRune(r rune) (n int, err os.Error) {\n+func (b *Buffer) WriteRune(r rune) (n int, err error) {\n \tif r < utf8.RuneSelf {\n \t\tb.WriteByte(byte(r))\n \t\treturn 1, nil\n@@ -202,12 +202,12 @@ func (b *Buffer) WriteRune(r rune) (n int, err os.Error) {\n // is drained.  The return value n is the number of bytes read.  If the\n // buffer has no data to return, err is os.EOF even if len(p) is zero;\n // otherwise it is nil.\n-func (b *Buffer) Read(p []byte) (n int, err os.Error) {\n+func (b *Buffer) Read(p []byte) (n int, err error) {\n \tb.lastRead = opInvalid\n \tif b.off >= len(b.buf) {\n \t\t// Buffer is empty, reset to recover space.\n \t\tb.Truncate(0)\n-\t\treturn 0, os.EOF\n+\t\treturn 0, io.EOF\n \t}\n \tn = copy(p, b.buf[b.off:])\n \tb.off += n\n@@ -237,12 +237,12 @@ func (b *Buffer) Next(n int) []byte {\n \n // ReadByte reads and returns the next byte from the buffer.\n // If no byte is available, it returns error os.EOF.\n-func (b *Buffer) ReadByte() (c byte, err os.Error) {\n+func (b *Buffer) ReadByte() (c byte, err error) {\n \tb.lastRead = opInvalid\n \tif b.off >= len(b.buf) {\n \t\t// Buffer is empty, reset to recover space.\n \t\tb.Truncate(0)\n-\t\treturn 0, os.EOF\n+\t\treturn 0, io.EOF\n \t}\n \tc = b.buf[b.off]\n \tb.off++\n@@ -255,12 +255,12 @@ func (b *Buffer) ReadByte() (c byte, err os.Error) {\n // If no bytes are available, the error returned is os.EOF.\n // If the bytes are an erroneous UTF-8 encoding, it\n // consumes one byte and returns U+FFFD, 1.\n-func (b *Buffer) ReadRune() (r rune, size int, err os.Error) {\n+func (b *Buffer) ReadRune() (r rune, size int, err error) {\n \tb.lastRead = opInvalid\n \tif b.off >= len(b.buf) {\n \t\t// Buffer is empty, reset to recover space.\n \t\tb.Truncate(0)\n-\t\treturn 0, 0, os.EOF\n+\t\treturn 0, 0, io.EOF\n \t}\n \tb.lastRead = opReadRune\n \tc := b.buf[b.off]\n@@ -278,9 +278,9 @@ func (b *Buffer) ReadRune() (r rune, size int, err os.Error) {\n // not a ReadRune, UnreadRune returns an error.  (In this regard\n // it is stricter than UnreadByte, which will unread the last byte\n // from any read operation.)\n-func (b *Buffer) UnreadRune() os.Error {\n+func (b *Buffer) UnreadRune() error {\n \tif b.lastRead != opReadRune {\n-\t\treturn os.NewError(\"bytes.Buffer: UnreadRune: previous operation was not ReadRune\")\n+\t\treturn errors.New(\"bytes.Buffer: UnreadRune: previous operation was not ReadRune\")\n \t}\n \tb.lastRead = opInvalid\n \tif b.off > 0 {\n@@ -293,9 +293,9 @@ func (b *Buffer) UnreadRune() os.Error {\n // UnreadByte unreads the last byte returned by the most recent\n // read operation.  If write has happened since the last read, UnreadByte\n // returns an error.\n-func (b *Buffer) UnreadByte() os.Error {\n+func (b *Buffer) UnreadByte() error {\n \tif b.lastRead != opReadRune && b.lastRead != opRead {\n-\t\treturn os.NewError(\"bytes.Buffer: UnreadByte: previous operation was not a read\")\n+\t\treturn errors.New(\"bytes.Buffer: UnreadByte: previous operation was not a read\")\n \t}\n \tb.lastRead = opInvalid\n \tif b.off > 0 {\n@@ -310,12 +310,12 @@ func (b *Buffer) UnreadByte() os.Error {\n // it returns the data read before the error and the error itself (often os.EOF).\n // ReadBytes returns err != nil if and only if the returned data does not end in\n // delim.\n-func (b *Buffer) ReadBytes(delim byte) (line []byte, err os.Error) {\n+func (b *Buffer) ReadBytes(delim byte) (line []byte, err error) {\n \ti := IndexByte(b.buf[b.off:], delim)\n \tsize := i + 1\n \tif i < 0 {\n \t\tsize = len(b.buf) - b.off\n-\t\terr = os.EOF\n+\t\terr = io.EOF\n \t}\n \tline = make([]byte, size)\n \tcopy(line, b.buf[b.off:])\n@@ -329,7 +329,7 @@ func (b *Buffer) ReadBytes(delim byte) (line []byte, err os.Error) {\n // it returns the data read before the error and the error itself (often os.EOF).\n // ReadString returns err != nil if and only if the returned data does not end\n // in delim.\n-func (b *Buffer) ReadString(delim byte) (line string, err os.Error) {\n+func (b *Buffer) ReadString(delim byte) (line string, err error) {\n \tbytes, err := b.ReadBytes(delim)\n \treturn string(bytes), err\n }"}, {"sha": "c271b482e152d67fe7c0d0a370aabca9c8c86b88", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,7 +6,7 @@ package bytes_test\n \n import (\n \t. \"bytes\"\n-\t\"os\"\n+\t\"io\"\n \t\"rand\"\n \t\"testing\"\n \t\"utf8\"\n@@ -344,21 +344,21 @@ var readBytesTests = []struct {\n \tbuffer   string\n \tdelim    byte\n \texpected []string\n-\terr      os.Error\n+\terr      error\n }{\n-\t{\"\", 0, []string{\"\"}, os.EOF},\n+\t{\"\", 0, []string{\"\"}, io.EOF},\n \t{\"a\\x00\", 0, []string{\"a\\x00\"}, nil},\n \t{\"abbbaaaba\", 'b', []string{\"ab\", \"b\", \"b\", \"aaab\"}, nil},\n \t{\"hello\\x01world\", 1, []string{\"hello\\x01\"}, nil},\n-\t{\"foo\\nbar\", 0, []string{\"foo\\nbar\"}, os.EOF},\n+\t{\"foo\\nbar\", 0, []string{\"foo\\nbar\"}, io.EOF},\n \t{\"alpha\\nbeta\\ngamma\\n\", '\\n', []string{\"alpha\\n\", \"beta\\n\", \"gamma\\n\"}, nil},\n-\t{\"alpha\\nbeta\\ngamma\", '\\n', []string{\"alpha\\n\", \"beta\\n\", \"gamma\"}, os.EOF},\n+\t{\"alpha\\nbeta\\ngamma\", '\\n', []string{\"alpha\\n\", \"beta\\n\", \"gamma\"}, io.EOF},\n }\n \n func TestReadBytes(t *testing.T) {\n \tfor _, test := range readBytesTests {\n \t\tbuf := NewBufferString(test.buffer)\n-\t\tvar err os.Error\n+\t\tvar err error\n \t\tfor _, expected := range test.expected {\n \t\t\tvar bytes []byte\n \t\t\tbytes, err = buf.ReadBytes(test.delim)"}, {"sha": "d058c14833ba362631b0ca6db3020092bf5de0d3", "filename": "libgo/go/compress/bzip2/bit_reader.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,25 +7,24 @@ package bzip2\n import (\n \t\"bufio\"\n \t\"io\"\n-\t\"os\"\n )\n \n // bitReader wraps an io.Reader and provides the ability to read values,\n-// bit-by-bit, from it. Its Read* methods don't return the usual os.Error\n+// bit-by-bit, from it. Its Read* methods don't return the usual error\n // because the error handling was verbose. Instead, any error is kept and can\n // be checked afterwards.\n type bitReader struct {\n \tr    byteReader\n \tn    uint64\n \tbits uint\n-\terr  os.Error\n+\terr  error\n }\n \n // bitReader needs to read bytes from an io.Reader. We attempt to cast the\n // given io.Reader to this interface and, if it doesn't already fit, we wrap in\n // a bufio.Reader.\n type byteReader interface {\n-\tReadByte() (byte, os.Error)\n+\tReadByte() (byte, error)\n }\n \n func newBitReader(r io.Reader) bitReader {\n@@ -42,7 +41,7 @@ func newBitReader(r io.Reader) bitReader {\n func (br *bitReader) ReadBits64(bits uint) (n uint64) {\n \tfor bits > br.bits {\n \t\tb, err := br.r.ReadByte()\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\terr = io.ErrUnexpectedEOF\n \t\t}\n \t\tif err != nil {\n@@ -83,6 +82,6 @@ func (br *bitReader) ReadBit() bool {\n \treturn n != 0\n }\n \n-func (br *bitReader) Error() os.Error {\n+func (br *bitReader) Error() error {\n \treturn br.err\n }"}, {"sha": "343cca03e349ef51e49d87185ac0b2272e0afb8a", "filename": "libgo/go/compress/bzip2/bzip2.go", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,10 +5,7 @@\n // Package bzip2 implements bzip2 decompression.\n package bzip2\n \n-import (\n-\t\"io\"\n-\t\"os\"\n-)\n+import \"io\"\n \n // There's no RFC for bzip2. I used the Wikipedia page for reference and a lot\n // of guessing: http://en.wikipedia.org/wiki/Bzip2\n@@ -19,7 +16,7 @@ import (\n // syntactically invalid.\n type StructuralError string\n \n-func (s StructuralError) String() string {\n+func (s StructuralError) Error() string {\n \treturn \"bzip2 data invalid: \" + string(s)\n }\n \n@@ -53,7 +50,7 @@ const bzip2BlockMagic = 0x314159265359\n const bzip2FinalMagic = 0x177245385090\n \n // setup parses the bzip2 header.\n-func (bz2 *reader) setup() os.Error {\n+func (bz2 *reader) setup() error {\n \tbr := &bz2.br\n \n \tmagic := br.ReadBits(16)\n@@ -76,9 +73,9 @@ func (bz2 *reader) setup() os.Error {\n \treturn nil\n }\n \n-func (bz2 *reader) Read(buf []byte) (n int, err os.Error) {\n+func (bz2 *reader) Read(buf []byte) (n int, err error) {\n \tif bz2.eof {\n-\t\treturn 0, os.EOF\n+\t\treturn 0, io.EOF\n \t}\n \n \tif !bz2.setupDone {\n@@ -101,7 +98,7 @@ func (bz2 *reader) Read(buf []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (bz2 *reader) read(buf []byte) (n int, err os.Error) {\n+func (bz2 *reader) read(buf []byte) (n int, err error) {\n \t// bzip2 is a block based compressor, except that it has a run-length\n \t// preprocessing step. The block based nature means that we can\n \t// preallocate fixed-size buffers and reuse them. However, the RLE\n@@ -162,7 +159,7 @@ func (bz2 *reader) read(buf []byte) (n int, err os.Error) {\n \tif magic == bzip2FinalMagic {\n \t\tbr.ReadBits64(32) // ignored CRC\n \t\tbz2.eof = true\n-\t\treturn 0, os.EOF\n+\t\treturn 0, io.EOF\n \t} else if magic != bzip2BlockMagic {\n \t\treturn 0, StructuralError(\"bad magic value found\")\n \t}\n@@ -176,7 +173,7 @@ func (bz2 *reader) read(buf []byte) (n int, err os.Error) {\n }\n \n // readBlock reads a bzip2 block. The magic number should already have been consumed.\n-func (bz2 *reader) readBlock() (err os.Error) {\n+func (bz2 *reader) readBlock() (err error) {\n \tbr := &bz2.br\n \tbr.ReadBits64(32) // skip checksum. TODO: check it if we can figure out what it is.\n \trandomized := br.ReadBits(1)"}, {"sha": "7b227ac9f36f5119016257e178f74d7598785376", "filename": "libgo/go/compress/bzip2/bzip2_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"encoding/hex\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -46,7 +45,7 @@ func readerFromHex(s string) io.Reader {\n \treturn bytes.NewBuffer(data)\n }\n \n-func decompressHex(s string) (out []byte, err os.Error) {\n+func decompressHex(s string) (out []byte, err error) {\n \tr := NewReader(readerFromHex(s))\n \treturn ioutil.ReadAll(r)\n }"}, {"sha": "078c1cb895411bd601cedd718e3ba2a466ea6e94", "filename": "libgo/go/compress/bzip2/huffman.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,10 +4,7 @@\n \n package bzip2\n \n-import (\n-\t\"os\"\n-\t\"sort\"\n-)\n+import \"sort\"\n \n // A huffmanTree is a binary tree which is navigated, bit-by-bit to reach a\n // symbol.\n@@ -63,7 +60,7 @@ func (t huffmanTree) Decode(br *bitReader) (v uint16) {\n \n // newHuffmanTree builds a Huffman tree from a slice containing the code\n // lengths of each symbol. The maximum code length is 32 bits.\n-func newHuffmanTree(lengths []uint8) (huffmanTree, os.Error) {\n+func newHuffmanTree(lengths []uint8) (huffmanTree, error) {\n \t// There are many possible trees that assign the same code length to\n \t// each symbol (consider reflecting a tree down the middle, for\n \t// example). Since the code length assignments determine the\n@@ -176,7 +173,7 @@ func (n huffmanCodes) Swap(i, j int) {\n // buildHuffmanNode takes a slice of sorted huffmanCodes and builds a node in\n // the Huffman tree at the given level. It returns the index of the newly\n // constructed node.\n-func buildHuffmanNode(t *huffmanTree, codes []huffmanCode, level uint32) (nodeIndex uint16, err os.Error) {\n+func buildHuffmanNode(t *huffmanTree, codes []huffmanCode, level uint32) (nodeIndex uint16, err error) {\n \ttest := uint32(1) << (31 - level)\n \n \t// We have to search the list of codes to find the divide between the left and right sides."}, {"sha": "1f659bab71369bbd3f9cdd95587ef386aa568f26", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package flate\n import (\n \t\"io\"\n \t\"math\"\n-\t\"os\"\n )\n \n const (\n@@ -89,7 +88,7 @@ type compressor struct {\n \toffset         int\n \thash           int\n \tmaxInsertIndex int\n-\terr            os.Error\n+\terr            error\n }\n \n func (d *compressor) fillDeflate(b []byte) int {\n@@ -123,7 +122,7 @@ func (d *compressor) fillDeflate(b []byte) int {\n \treturn n\n }\n \n-func (d *compressor) writeBlock(tokens []token, index int, eof bool) os.Error {\n+func (d *compressor) writeBlock(tokens []token, index int, eof bool) error {\n \tif index > 0 || eof {\n \t\tvar window []byte\n \t\tif d.blockStart <= index {\n@@ -194,7 +193,7 @@ func (d *compressor) findMatch(pos int, prevHead int, prevLength int, lookahead\n \treturn\n }\n \n-func (d *compressor) writeStoredBlock(buf []byte) os.Error {\n+func (d *compressor) writeStoredBlock(buf []byte) error {\n \tif d.w.writeStoredHeader(len(buf), false); d.w.err != nil {\n \t\treturn d.w.err\n \t}\n@@ -365,7 +364,7 @@ func (d *compressor) store() {\n \td.windowEnd = 0\n }\n \n-func (d *compressor) write(b []byte) (n int, err os.Error) {\n+func (d *compressor) write(b []byte) (n int, err error) {\n \tn = len(b)\n \tb = b[d.fill(d, b):]\n \tfor len(b) > 0 {\n@@ -375,7 +374,7 @@ func (d *compressor) write(b []byte) (n int, err os.Error) {\n \treturn n, d.err\n }\n \n-func (d *compressor) syncFlush() os.Error {\n+func (d *compressor) syncFlush() error {\n \td.sync = true\n \td.step(d)\n \tif d.err == nil {\n@@ -387,7 +386,7 @@ func (d *compressor) syncFlush() os.Error {\n \treturn d.err\n }\n \n-func (d *compressor) init(w io.Writer, level int) (err os.Error) {\n+func (d *compressor) init(w io.Writer, level int) (err error) {\n \td.w = newHuffmanBitWriter(w)\n \n \tswitch {\n@@ -409,7 +408,7 @@ func (d *compressor) init(w io.Writer, level int) (err os.Error) {\n \treturn nil\n }\n \n-func (d *compressor) close() os.Error {\n+func (d *compressor) close() error {\n \td.sync = true\n \td.step(d)\n \tif d.err != nil {\n@@ -455,7 +454,7 @@ type dictWriter struct {\n \tenabled bool\n }\n \n-func (w *dictWriter) Write(b []byte) (n int, err os.Error) {\n+func (w *dictWriter) Write(b []byte) (n int, err error) {\n \tif w.enabled {\n \t\treturn w.w.Write(b)\n \t}\n@@ -470,7 +469,7 @@ type Writer struct {\n \n // Write writes data to w, which will eventually write the\n // compressed form of data to its underlying writer.\n-func (w *Writer) Write(data []byte) (n int, err os.Error) {\n+func (w *Writer) Write(data []byte) (n int, err error) {\n \treturn w.d.write(data)\n }\n \n@@ -481,13 +480,13 @@ func (w *Writer) Write(data []byte) (n int, err os.Error) {\n // If the underlying writer returns an error, Flush returns that error.\n //\n // In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.\n-func (w *Writer) Flush() os.Error {\n+func (w *Writer) Flush() error {\n \t// For more about flushing:\n \t// http://www.bolet.org/~pornin/deflate-flush.html\n \treturn w.d.syncFlush()\n }\n \n // Close flushes and closes the writer.\n-func (w *Writer) Close() os.Error {\n+func (w *Writer) Close() error {\n \treturn w.d.close()\n }"}, {"sha": "db2d71d735074987d2321214715bbd08b880c5b8", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"sync\"\n \t\"testing\"\n )\n@@ -102,7 +101,7 @@ func newSyncBuffer() *syncBuffer {\n \treturn &syncBuffer{ready: make(chan bool, 1)}\n }\n \n-func (b *syncBuffer) Read(p []byte) (n int, err os.Error) {\n+func (b *syncBuffer) Read(p []byte) (n int, err error) {\n \tfor {\n \t\tb.mu.RLock()\n \t\tn, err = b.buf.Read(p)\n@@ -122,7 +121,7 @@ func (b *syncBuffer) signal() {\n \t}\n }\n \n-func (b *syncBuffer) Write(p []byte) (n int, err os.Error) {\n+func (b *syncBuffer) Write(p []byte) (n int, err error) {\n \tn, err = b.buf.Write(p)\n \tb.signal()\n \treturn\n@@ -137,7 +136,7 @@ func (b *syncBuffer) ReadMode() {\n \tb.signal()\n }\n \n-func (b *syncBuffer) Close() os.Error {\n+func (b *syncBuffer) Close() error {\n \tb.closed = true\n \tb.signal()\n \treturn nil\n@@ -204,7 +203,7 @@ func testSync(t *testing.T, level int, input []byte, name string) {\n \t}\n \tbuf.ReadMode()\n \tout := make([]byte, 10)\n-\tif n, err := r.Read(out); n > 0 || err != os.EOF {\n+\tif n, err := r.Read(out); n > 0 || err != io.EOF {\n \t\tt.Errorf(\"testSync (%d, %d, %s): final Read: %d, %v (hex: %x)\", level, len(input), name, n, err, out[0:n])\n \t}\n \tif buf.buf.Len() != 0 {\n@@ -225,7 +224,7 @@ func testSync(t *testing.T, level int, input []byte, name string) {\n \t}\n }\n \n-func testToFromWithLevel(t *testing.T, level int, input []byte, name string) os.Error {\n+func testToFromWithLevel(t *testing.T, level int, input []byte, name string) error {\n \tbuffer := bytes.NewBuffer(nil)\n \tw := NewWriter(buffer, level)\n \tw.Write(input)"}, {"sha": "efd99c6b954350b9bcba3646fc2b2484a492f462", "filename": "libgo/go/compress/flate/huffman_bit_writer.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package flate\n import (\n \t\"io\"\n \t\"math\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -83,7 +82,7 @@ type huffmanBitWriter struct {\n \tliteralEncoding *huffmanEncoder\n \toffsetEncoding  *huffmanEncoder\n \tcodegenEncoding *huffmanEncoder\n-\terr             os.Error\n+\terr             error\n }\n \n type WrongValueError struct {\n@@ -106,7 +105,7 @@ func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter {\n \t}\n }\n \n-func (err WrongValueError) String() string {\n+func (err WrongValueError) Error() string {\n \treturn \"huffmanBitWriter: \" + err.name + \" should belong to [\" + strconv.Itoa64(int64(err.from)) + \";\" +\n \t\tstrconv.Itoa64(int64(err.to)) + \"] but actual value is \" + strconv.Itoa64(int64(err.value))\n }"}, {"sha": "3f0c94864a4c1d3f667d1ab9e14a38013321b8eb", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,7 +10,6 @@ package flate\n import (\n \t\"bufio\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -25,33 +24,33 @@ const (\n // A CorruptInputError reports the presence of corrupt input at a given offset.\n type CorruptInputError int64\n \n-func (e CorruptInputError) String() string {\n+func (e CorruptInputError) Error() string {\n \treturn \"flate: corrupt input before offset \" + strconv.Itoa64(int64(e))\n }\n \n // An InternalError reports an error in the flate code itself.\n type InternalError string\n \n-func (e InternalError) String() string { return \"flate: internal error: \" + string(e) }\n+func (e InternalError) Error() string { return \"flate: internal error: \" + string(e) }\n \n // A ReadError reports an error encountered while reading input.\n type ReadError struct {\n-\tOffset int64    // byte offset where error occurred\n-\tError  os.Error // error returned by underlying Read\n+\tOffset int64 // byte offset where error occurred\n+\tErr    error // error returned by underlying Read\n }\n \n-func (e *ReadError) String() string {\n-\treturn \"flate: read error at offset \" + strconv.Itoa64(e.Offset) + \": \" + e.Error.String()\n+func (e *ReadError) Error() string {\n+\treturn \"flate: read error at offset \" + strconv.Itoa64(e.Offset) + \": \" + e.Err.Error()\n }\n \n // A WriteError reports an error encountered while writing output.\n type WriteError struct {\n-\tOffset int64    // byte offset where error occurred\n-\tError  os.Error // error returned by underlying Write\n+\tOffset int64 // byte offset where error occurred\n+\tErr    error // error returned by underlying Write\n }\n \n-func (e *WriteError) String() string {\n-\treturn \"flate: write error at offset \" + strconv.Itoa64(e.Offset) + \": \" + e.Error.String()\n+func (e *WriteError) Error() string {\n+\treturn \"flate: write error at offset \" + strconv.Itoa64(e.Offset) + \": \" + e.Err.Error()\n }\n \n // Huffman decoder is based on\n@@ -190,7 +189,7 @@ var fixedHuffmanDecoder = huffmanDecoder{\n // the NewReader will introduce its own buffering.\n type Reader interface {\n \tio.Reader\n-\tReadByte() (c byte, err os.Error)\n+\tReadByte() (c byte, err error)\n }\n \n // Decompress state.\n@@ -224,7 +223,7 @@ type decompressor struct {\n \t// and decompression state.\n \tstep     func(*decompressor)\n \tfinal    bool\n-\terr      os.Error\n+\terr      error\n \ttoRead   []byte\n \thl, hd   *huffmanDecoder\n \tcopyLen  int\n@@ -237,7 +236,7 @@ func (f *decompressor) nextBlock() {\n \t\t\tf.flush((*decompressor).nextBlock)\n \t\t\treturn\n \t\t}\n-\t\tf.err = os.EOF\n+\t\tf.err = io.EOF\n \t\treturn\n \t}\n \tfor f.nb < 1+2 {\n@@ -272,7 +271,7 @@ func (f *decompressor) nextBlock() {\n \t}\n }\n \n-func (f *decompressor) Read(b []byte) (int, os.Error) {\n+func (f *decompressor) Read(b []byte) (int, error) {\n \tfor {\n \t\tif len(f.toRead) > 0 {\n \t\t\tn := copy(b, f.toRead)\n@@ -287,8 +286,8 @@ func (f *decompressor) Read(b []byte) (int, os.Error) {\n \tpanic(\"unreachable\")\n }\n \n-func (f *decompressor) Close() os.Error {\n-\tif f.err == os.EOF {\n+func (f *decompressor) Close() error {\n+\tif f.err == io.EOF {\n \t\treturn nil\n \t}\n \treturn f.err\n@@ -299,7 +298,7 @@ func (f *decompressor) Close() os.Error {\n \n var codeOrder = [...]int{16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15}\n \n-func (f *decompressor) readHuffman() os.Error {\n+func (f *decompressor) readHuffman() error {\n \t// HLIT[5], HDIST[5], HCLEN[4].\n \tfor f.nb < 5+5+4 {\n \t\tif err := f.moreBits(); err != nil {\n@@ -625,10 +624,10 @@ func (f *decompressor) setDict(dict []byte) {\n \tf.hw = f.hp\n }\n \n-func (f *decompressor) moreBits() os.Error {\n+func (f *decompressor) moreBits() error {\n \tc, err := f.r.ReadByte()\n \tif err != nil {\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\terr = io.ErrUnexpectedEOF\n \t\t}\n \t\treturn err\n@@ -640,7 +639,7 @@ func (f *decompressor) moreBits() os.Error {\n }\n \n // Read the next Huffman-encoded symbol from f according to h.\n-func (f *decompressor) huffSym(h *huffmanDecoder) (int, os.Error) {\n+func (f *decompressor) huffSym(h *huffmanDecoder) (int, error) {\n \tfor n := uint(h.min); n <= uint(h.max); n++ {\n \t\tlim := h.limit[n]\n \t\tif lim == -1 {"}, {"sha": "a23e515e0e05cb7726d3b3d4c9433366f9f37b78", "filename": "libgo/go/compress/gzip/gunzip.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,10 +9,10 @@ package gzip\n import (\n \t\"bufio\"\n \t\"compress/flate\"\n+\t\"errors\"\n \t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n-\t\"os\"\n )\n \n // BUG(nigeltao): Comments and Names don't properly map UTF-8 character codes outside of\n@@ -36,8 +36,8 @@ func makeReader(r io.Reader) flate.Reader {\n \treturn bufio.NewReader(r)\n }\n \n-var HeaderError = os.NewError(\"invalid gzip header\")\n-var ChecksumError = os.NewError(\"gzip checksum error\")\n+var HeaderError = errors.New(\"invalid gzip header\")\n+var ChecksumError = errors.New(\"gzip checksum error\")\n \n // The gzip file stores a header giving metadata about the compressed file.\n // That header is exposed as the fields of the Compressor and Decompressor structs.\n@@ -71,13 +71,13 @@ type Decompressor struct {\n \tsize         uint32\n \tflg          byte\n \tbuf          [512]byte\n-\terr          os.Error\n+\terr          error\n }\n \n // NewReader creates a new Decompressor reading the given reader.\n // The implementation buffers input and may read more data than necessary from r.\n // It is the caller's responsibility to call Close on the Decompressor when done.\n-func NewReader(r io.Reader) (*Decompressor, os.Error) {\n+func NewReader(r io.Reader) (*Decompressor, error) {\n \tz := new(Decompressor)\n \tz.r = makeReader(r)\n \tz.digest = crc32.NewIEEE()\n@@ -93,8 +93,8 @@ func get4(p []byte) uint32 {\n \treturn uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 | uint32(p[3])<<24\n }\n \n-func (z *Decompressor) readString() (string, os.Error) {\n-\tvar err os.Error\n+func (z *Decompressor) readString() (string, error) {\n+\tvar err error\n \tfor i := 0; ; i++ {\n \t\tif i >= len(z.buf) {\n \t\t\treturn \"\", HeaderError\n@@ -112,15 +112,15 @@ func (z *Decompressor) readString() (string, os.Error) {\n \tpanic(\"not reached\")\n }\n \n-func (z *Decompressor) read2() (uint32, os.Error) {\n+func (z *Decompressor) read2() (uint32, error) {\n \t_, err := io.ReadFull(z.r, z.buf[0:2])\n \tif err != nil {\n \t\treturn 0, err\n \t}\n \treturn uint32(z.buf[0]) | uint32(z.buf[1])<<8, nil\n }\n \n-func (z *Decompressor) readHeader(save bool) os.Error {\n+func (z *Decompressor) readHeader(save bool) error {\n \t_, err := io.ReadFull(z.r, z.buf[0:10])\n \tif err != nil {\n \t\treturn err\n@@ -186,7 +186,7 @@ func (z *Decompressor) readHeader(save bool) os.Error {\n \treturn nil\n }\n \n-func (z *Decompressor) Read(p []byte) (n int, err os.Error) {\n+func (z *Decompressor) Read(p []byte) (n int, err error) {\n \tif z.err != nil {\n \t\treturn 0, z.err\n \t}\n@@ -197,7 +197,7 @@ func (z *Decompressor) Read(p []byte) (n int, err os.Error) {\n \tn, err = z.decompressor.Read(p)\n \tz.digest.Write(p[0:n])\n \tz.size += uint32(n)\n-\tif n != 0 || err != os.EOF {\n+\tif n != 0 || err != io.EOF {\n \t\tz.err = err\n \t\treturn\n \t}\n@@ -227,4 +227,4 @@ func (z *Decompressor) Read(p []byte) (n int, err os.Error) {\n }\n \n // Calling Close does not close the wrapped io.Reader originally passed to NewReader.\n-func (z *Decompressor) Close() os.Error { return z.decompressor.Close() }\n+func (z *Decompressor) Close() error { return z.decompressor.Close() }"}, {"sha": "771b0b6a1b4ddc42d74e02446db715bcccdda9cc", "filename": "libgo/go/compress/gzip/gunzip_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package gzip\n import (\n \t\"bytes\"\n \t\"io\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -16,7 +15,7 @@ type gunzipTest struct {\n \tdesc string\n \traw  string\n \tgzip []byte\n-\terr  os.Error\n+\terr  error\n }\n \n var gunzipTests = []gunzipTest{"}, {"sha": "94b0f1f85e26c5342eab359e9e304802d670dba5", "filename": "libgo/go/compress/gzip/gzip.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,10 +6,10 @@ package gzip\n \n import (\n \t\"compress/flate\"\n+\t\"errors\"\n \t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n-\t\"os\"\n )\n \n // These constants are copied from the flate package, so that code that imports\n@@ -32,11 +32,11 @@ type Compressor struct {\n \tsize       uint32\n \tclosed     bool\n \tbuf        [10]byte\n-\terr        os.Error\n+\terr        error\n }\n \n // NewWriter calls NewWriterLevel with the default compression level.\n-func NewWriter(w io.Writer) (*Compressor, os.Error) {\n+func NewWriter(w io.Writer) (*Compressor, error) {\n \treturn NewWriterLevel(w, DefaultCompression)\n }\n \n@@ -47,7 +47,7 @@ func NewWriter(w io.Writer) (*Compressor, os.Error) {\n // It is the caller's responsibility to call Close on the WriteCloser when done.\n // level is the compression level, which can be DefaultCompression, NoCompression,\n // or any integer value between BestSpeed and BestCompression (inclusive).\n-func NewWriterLevel(w io.Writer, level int) (*Compressor, os.Error) {\n+func NewWriterLevel(w io.Writer, level int) (*Compressor, error) {\n \tz := new(Compressor)\n \tz.OS = 255 // unknown\n \tz.w = w\n@@ -70,9 +70,9 @@ func put4(p []byte, v uint32) {\n }\n \n // writeBytes writes a length-prefixed byte slice to z.w.\n-func (z *Compressor) writeBytes(b []byte) os.Error {\n+func (z *Compressor) writeBytes(b []byte) error {\n \tif len(b) > 0xffff {\n-\t\treturn os.NewError(\"gzip.Write: Extra data is too large\")\n+\t\treturn errors.New(\"gzip.Write: Extra data is too large\")\n \t}\n \tput2(z.buf[0:2], uint16(len(b)))\n \t_, err := z.w.Write(z.buf[0:2])\n@@ -84,12 +84,12 @@ func (z *Compressor) writeBytes(b []byte) os.Error {\n }\n \n // writeString writes a string (in ISO 8859-1 (Latin-1) format) to z.w.\n-func (z *Compressor) writeString(s string) os.Error {\n+func (z *Compressor) writeString(s string) error {\n \t// GZIP (RFC 1952) specifies that strings are NUL-terminated ISO 8859-1 (Latin-1).\n \t// TODO(nigeltao): Convert from UTF-8 to ISO 8859-1 (Latin-1).\n \tfor _, v := range s {\n \t\tif v == 0 || v > 0x7f {\n-\t\t\treturn os.NewError(\"gzip.Write: non-ASCII header string\")\n+\t\t\treturn errors.New(\"gzip.Write: non-ASCII header string\")\n \t\t}\n \t}\n \t_, err := io.WriteString(z.w, s)\n@@ -102,7 +102,7 @@ func (z *Compressor) writeString(s string) os.Error {\n \treturn err\n }\n \n-func (z *Compressor) Write(p []byte) (int, os.Error) {\n+func (z *Compressor) Write(p []byte) (int, error) {\n \tif z.err != nil {\n \t\treturn 0, z.err\n \t}\n@@ -162,7 +162,7 @@ func (z *Compressor) Write(p []byte) (int, os.Error) {\n }\n \n // Calling Close does not close the wrapped io.Writer originally passed to NewWriter.\n-func (z *Compressor) Close() os.Error {\n+func (z *Compressor) Close() error {\n \tif z.err != nil {\n \t\treturn z.err\n \t}"}, {"sha": "c787a9568b393d1502b3498e7828b9a4bce3c0eb", "filename": "libgo/go/compress/lzw/reader.go", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -16,6 +16,7 @@ package lzw\n \n import (\n \t\"bufio\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n@@ -45,9 +46,9 @@ type decoder struct {\n \tbits     uint32\n \tnBits    uint\n \twidth    uint\n-\tread     func(*decoder) (uint16, os.Error) // readLSB or readMSB\n-\tlitWidth int                               // width in bits of literal codes\n-\terr      os.Error\n+\tread     func(*decoder) (uint16, error) // readLSB or readMSB\n+\tlitWidth int                            // width in bits of literal codes\n+\terr      error\n \n \t// The first 1<<litWidth codes are literal codes.\n \t// The next two codes mean clear and EOF.\n@@ -78,7 +79,7 @@ type decoder struct {\n }\n \n // readLSB returns the next code for \"Least Significant Bits first\" data.\n-func (d *decoder) readLSB() (uint16, os.Error) {\n+func (d *decoder) readLSB() (uint16, error) {\n \tfor d.nBits < d.width {\n \t\tx, err := d.r.ReadByte()\n \t\tif err != nil {\n@@ -94,7 +95,7 @@ func (d *decoder) readLSB() (uint16, os.Error) {\n }\n \n // readMSB returns the next code for \"Most Significant Bits first\" data.\n-func (d *decoder) readMSB() (uint16, os.Error) {\n+func (d *decoder) readMSB() (uint16, error) {\n \tfor d.nBits < d.width {\n \t\tx, err := d.r.ReadByte()\n \t\tif err != nil {\n@@ -109,7 +110,7 @@ func (d *decoder) readMSB() (uint16, os.Error) {\n \treturn code, nil\n }\n \n-func (d *decoder) Read(b []byte) (int, os.Error) {\n+func (d *decoder) Read(b []byte) (int, error) {\n \tfor {\n \t\tif len(d.toRead) > 0 {\n \t\t\tn := copy(b, d.toRead)\n@@ -132,7 +133,7 @@ func (d *decoder) decode() {\n \tfor {\n \t\tcode, err := d.read(d)\n \t\tif err != nil {\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\terr = io.ErrUnexpectedEOF\n \t\t\t}\n \t\t\td.err = err\n@@ -156,7 +157,7 @@ func (d *decoder) decode() {\n \t\t\tcontinue\n \t\tcase code == d.eof:\n \t\t\td.flush()\n-\t\t\td.err = os.EOF\n+\t\t\td.err = io.EOF\n \t\t\treturn\n \t\tcase code <= d.hi:\n \t\t\tc, i := code, len(d.output)-1\n@@ -186,7 +187,7 @@ func (d *decoder) decode() {\n \t\t\t\td.prefix[d.hi] = d.last\n \t\t\t}\n \t\tdefault:\n-\t\t\td.err = os.NewError(\"lzw: invalid code\")\n+\t\t\td.err = errors.New(\"lzw: invalid code\")\n \t\t\treturn\n \t\t}\n \t\td.last, d.hi = code, d.hi+1\n@@ -211,7 +212,7 @@ func (d *decoder) flush() {\n \td.o = 0\n }\n \n-func (d *decoder) Close() os.Error {\n+func (d *decoder) Close() error {\n \td.err = os.EINVAL // in case any Reads come along\n \treturn nil\n }\n@@ -230,7 +231,7 @@ func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser {\n \tcase MSB:\n \t\td.read = (*decoder).readMSB\n \tdefault:\n-\t\td.err = os.NewError(\"lzw: unknown order\")\n+\t\td.err = errors.New(\"lzw: unknown order\")\n \t\treturn d\n \t}\n \tif litWidth < 2 || 8 < litWidth {"}, {"sha": "09821573cc03cb6db4ed9ccbfd54f6a4866f0fe6", "filename": "libgo/go/compress/lzw/reader_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"bytes\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n@@ -19,7 +18,7 @@ type lzwTest struct {\n \tdesc       string\n \traw        string\n \tcompressed string\n-\terr        os.Error\n+\terr        error\n }\n \n var lzwTests = []lzwTest{"}, {"sha": "3f380fadce2570a180b902d3ae39656f190168a3", "filename": "libgo/go/compress/lzw/writer.go", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,27 +6,28 @@ package lzw\n \n import (\n \t\"bufio\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n )\n \n // A writer is a buffered, flushable writer.\n type writer interface {\n-\tWriteByte(byte) os.Error\n-\tFlush() os.Error\n+\tWriteByte(byte) error\n+\tFlush() error\n }\n \n // An errWriteCloser is an io.WriteCloser that always returns a given error.\n type errWriteCloser struct {\n-\terr os.Error\n+\terr error\n }\n \n-func (e *errWriteCloser) Write([]byte) (int, os.Error) {\n+func (e *errWriteCloser) Write([]byte) (int, error) {\n \treturn 0, e.err\n }\n \n-func (e *errWriteCloser) Close() os.Error {\n+func (e *errWriteCloser) Close() error {\n \treturn e.err\n }\n \n@@ -50,7 +51,7 @@ type encoder struct {\n \tw writer\n \t// write, bits, nBits and width are the state for converting a code stream\n \t// into a byte stream.\n-\twrite func(*encoder, uint32) os.Error\n+\twrite func(*encoder, uint32) error\n \tbits  uint32\n \tnBits uint\n \twidth uint\n@@ -64,7 +65,7 @@ type encoder struct {\n \tsavedCode uint32\n \t// err is the first error encountered during writing. Closing the encoder\n \t// will make any future Write calls return os.EINVAL.\n-\terr os.Error\n+\terr error\n \t// table is the hash table from 20-bit keys to 12-bit values. Each table\n \t// entry contains key<<12|val and collisions resolve by linear probing.\n \t// The keys consist of a 12-bit code prefix and an 8-bit byte suffix.\n@@ -73,7 +74,7 @@ type encoder struct {\n }\n \n // writeLSB writes the code c for \"Least Significant Bits first\" data.\n-func (e *encoder) writeLSB(c uint32) os.Error {\n+func (e *encoder) writeLSB(c uint32) error {\n \te.bits |= c << e.nBits\n \te.nBits += e.width\n \tfor e.nBits >= 8 {\n@@ -87,7 +88,7 @@ func (e *encoder) writeLSB(c uint32) os.Error {\n }\n \n // writeMSB writes the code c for \"Most Significant Bits first\" data.\n-func (e *encoder) writeMSB(c uint32) os.Error {\n+func (e *encoder) writeMSB(c uint32) error {\n \te.bits |= c << (32 - e.width - e.nBits)\n \te.nBits += e.width\n \tfor e.nBits >= 8 {\n@@ -102,12 +103,12 @@ func (e *encoder) writeMSB(c uint32) os.Error {\n \n // errOutOfCodes is an internal error that means that the encoder has run out\n // of unused codes and a clear code needs to be sent next.\n-var errOutOfCodes = os.NewError(\"lzw: out of codes\")\n+var errOutOfCodes = errors.New(\"lzw: out of codes\")\n \n // incHi increments e.hi and checks for both overflow and running out of\n // unused codes. In the latter case, incHi sends a clear code, resets the\n // encoder state and returns errOutOfCodes.\n-func (e *encoder) incHi() os.Error {\n+func (e *encoder) incHi() error {\n \te.hi++\n \tif e.hi == e.overflow {\n \t\te.width++\n@@ -130,7 +131,7 @@ func (e *encoder) incHi() os.Error {\n }\n \n // Write writes a compressed representation of p to e's underlying writer.\n-func (e *encoder) Write(p []byte) (int, os.Error) {\n+func (e *encoder) Write(p []byte) (int, error) {\n \tif e.err != nil {\n \t\treturn 0, e.err\n \t}\n@@ -188,7 +189,7 @@ loop:\n \n // Close closes the encoder, flushing any pending output. It does not close or\n // flush e's underlying writer.\n-func (e *encoder) Close() os.Error {\n+func (e *encoder) Close() error {\n \tif e.err != nil {\n \t\tif e.err == os.EINVAL {\n \t\t\treturn nil\n@@ -230,14 +231,14 @@ func (e *encoder) Close() os.Error {\n // The number of bits to use for literal codes, litWidth, must be in the\n // range [2,8] and is typically 8.\n func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser {\n-\tvar write func(*encoder, uint32) os.Error\n+\tvar write func(*encoder, uint32) error\n \tswitch order {\n \tcase LSB:\n \t\twrite = (*encoder).writeLSB\n \tcase MSB:\n \t\twrite = (*encoder).writeMSB\n \tdefault:\n-\t\treturn &errWriteCloser{os.NewError(\"lzw: unknown order\")}\n+\t\treturn &errWriteCloser{errors.New(\"lzw: unknown order\")}\n \t}\n \tif litWidth < 2 || 8 < litWidth {\n \t\treturn &errWriteCloser{fmt.Errorf(\"lzw: litWidth %d out of range\", litWidth)}"}, {"sha": "154cdf8090eab035b5acfa1ace853e70fedbf617", "filename": "libgo/go/compress/lzw/writer_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -45,7 +45,7 @@ func testFile(t *testing.T, fn string, order Order, litWidth int) {\n \t\tvar b [4096]byte\n \t\tfor {\n \t\t\tn, err0 := raw.Read(b[:])\n-\t\t\tif err0 != nil && err0 != os.EOF {\n+\t\t\tif err0 != nil && err0 != io.EOF {\n \t\t\t\tt.Errorf(\"%s (order=%d litWidth=%d): %v\", fn, order, litWidth, err0)\n \t\t\t\treturn\n \t\t\t}\n@@ -58,7 +58,7 @@ func testFile(t *testing.T, fn string, order Order, litWidth int) {\n \t\t\t\tt.Errorf(\"%s (order=%d litWidth=%d): %v\", fn, order, litWidth, err1)\n \t\t\t\treturn\n \t\t\t}\n-\t\t\tif err0 == os.EOF {\n+\t\t\tif err0 == io.EOF {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}"}, {"sha": "50a1e6c357fca4cede2b1f31a146536ba9c140f5", "filename": "libgo/go/compress/zlib/reader.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -26,36 +26,36 @@ package zlib\n import (\n \t\"bufio\"\n \t\"compress/flate\"\n+\t\"errors\"\n \t\"hash\"\n \t\"hash/adler32\"\n \t\"io\"\n-\t\"os\"\n )\n \n const zlibDeflate = 8\n \n-var ChecksumError = os.NewError(\"zlib checksum error\")\n-var HeaderError = os.NewError(\"invalid zlib header\")\n-var DictionaryError = os.NewError(\"invalid zlib dictionary\")\n+var ChecksumError = errors.New(\"zlib checksum error\")\n+var HeaderError = errors.New(\"invalid zlib header\")\n+var DictionaryError = errors.New(\"invalid zlib dictionary\")\n \n type reader struct {\n \tr            flate.Reader\n \tdecompressor io.ReadCloser\n \tdigest       hash.Hash32\n-\terr          os.Error\n+\terr          error\n \tscratch      [4]byte\n }\n \n // NewReader creates a new io.ReadCloser that satisfies reads by decompressing data read from r.\n // The implementation buffers input and may read more data than necessary from r.\n // It is the caller's responsibility to call Close on the ReadCloser when done.\n-func NewReader(r io.Reader) (io.ReadCloser, os.Error) {\n+func NewReader(r io.Reader) (io.ReadCloser, error) {\n \treturn NewReaderDict(r, nil)\n }\n \n // NewReaderDict is like NewReader but uses a preset dictionary.\n // NewReaderDict ignores the dictionary if the compressed data does not refer to it.\n-func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, os.Error) {\n+func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error) {\n \tz := new(reader)\n \tif fr, ok := r.(flate.Reader); ok {\n \t\tz.r = fr\n@@ -87,7 +87,7 @@ func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, os.Error) {\n \treturn z, nil\n }\n \n-func (z *reader) Read(p []byte) (n int, err os.Error) {\n+func (z *reader) Read(p []byte) (n int, err error) {\n \tif z.err != nil {\n \t\treturn 0, z.err\n \t}\n@@ -97,7 +97,7 @@ func (z *reader) Read(p []byte) (n int, err os.Error) {\n \n \tn, err = z.decompressor.Read(p)\n \tz.digest.Write(p[0:n])\n-\tif n != 0 || err != os.EOF {\n+\tif n != 0 || err != io.EOF {\n \t\tz.err = err\n \t\treturn\n \t}\n@@ -117,7 +117,7 @@ func (z *reader) Read(p []byte) (n int, err os.Error) {\n }\n \n // Calling Close does not close the wrapped io.Reader originally passed to NewReader.\n-func (z *reader) Close() os.Error {\n+func (z *reader) Close() error {\n \tif z.err != nil {\n \t\treturn z.err\n \t}"}, {"sha": "d8f9f21478c35140a75902b86eb4694cdf04b7a8", "filename": "libgo/go/compress/zlib/reader_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package zlib\n import (\n \t\"bytes\"\n \t\"io\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -16,7 +15,7 @@ type zlibTest struct {\n \traw        string\n \tcompressed []byte\n \tdict       []byte\n-\terr        os.Error\n+\terr        error\n }\n \n // Compare-to-golden test data was generated by the ZLIB example program at"}, {"sha": "bbff6375ea1538732ee7f4e55c279baad3079c96", "filename": "libgo/go/compress/zlib/writer.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,10 +6,10 @@ package zlib\n \n import (\n \t\"compress/flate\"\n+\t\"errors\"\n \t\"hash\"\n \t\"hash/adler32\"\n \t\"io\"\n-\t\"os\"\n )\n \n // These constants are copied from the flate package, so that code that imports\n@@ -27,17 +27,17 @@ type Writer struct {\n \tw          io.Writer\n \tcompressor *flate.Writer\n \tdigest     hash.Hash32\n-\terr        os.Error\n+\terr        error\n \tscratch    [4]byte\n }\n \n // NewWriter calls NewWriterLevel with the default compression level.\n-func NewWriter(w io.Writer) (*Writer, os.Error) {\n+func NewWriter(w io.Writer) (*Writer, error) {\n \treturn NewWriterLevel(w, DefaultCompression)\n }\n \n // NewWriterLevel calls NewWriterDict with no dictionary.\n-func NewWriterLevel(w io.Writer, level int) (*Writer, os.Error) {\n+func NewWriterLevel(w io.Writer, level int) (*Writer, error) {\n \treturn NewWriterDict(w, level, nil)\n }\n \n@@ -46,7 +46,7 @@ func NewWriterLevel(w io.Writer, level int) (*Writer, os.Error) {\n // level is the compression level, which can be DefaultCompression, NoCompression,\n // or any integer value between BestSpeed and BestCompression (inclusive).\n // dict is the preset dictionary to compress with, or nil to use no dictionary.\n-func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, os.Error) {\n+func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error) {\n \tz := new(Writer)\n \t// ZLIB has a two-byte header (as documented in RFC 1950).\n \t// The first four bits is the CINFO (compression info), which is 7 for the default deflate window size.\n@@ -66,7 +66,7 @@ func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, os.Error) {\n \tcase 7, 8, 9:\n \t\tz.scratch[1] = 3 << 6\n \tdefault:\n-\t\treturn nil, os.NewError(\"level out of range\")\n+\t\treturn nil, errors.New(\"level out of range\")\n \t}\n \tif dict != nil {\n \t\tz.scratch[1] |= 1 << 5\n@@ -94,7 +94,7 @@ func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, os.Error) {\n \treturn z, nil\n }\n \n-func (z *Writer) Write(p []byte) (n int, err os.Error) {\n+func (z *Writer) Write(p []byte) (n int, err error) {\n \tif z.err != nil {\n \t\treturn 0, z.err\n \t}\n@@ -111,7 +111,7 @@ func (z *Writer) Write(p []byte) (n int, err os.Error) {\n }\n \n // Flush flushes the underlying compressor.\n-func (z *Writer) Flush() os.Error {\n+func (z *Writer) Flush() error {\n \tif z.err != nil {\n \t\treturn z.err\n \t}\n@@ -120,7 +120,7 @@ func (z *Writer) Flush() os.Error {\n }\n \n // Calling Close does not close the wrapped io.Writer originally passed to NewWriter.\n-func (z *Writer) Close() os.Error {\n+func (z *Writer) Close() error {\n \tif z.err != nil {\n \t\treturn z.err\n \t}"}, {"sha": "5ad75eccb502eada84f060a6fb770e8d05731785", "filename": "libgo/go/crypto/aes/cipher.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,10 +4,7 @@\n \n package aes\n \n-import (\n-\t\"os\"\n-\t\"strconv\"\n-)\n+import \"strconv\"\n \n // The AES block size in bytes.\n const BlockSize = 16\n@@ -20,15 +17,15 @@ type Cipher struct {\n \n type KeySizeError int\n \n-func (k KeySizeError) String() string {\n+func (k KeySizeError) Error() string {\n \treturn \"crypto/aes: invalid key size \" + strconv.Itoa(int(k))\n }\n \n // NewCipher creates and returns a new Cipher.\n // The key argument should be the AES key,\n // either 16, 24, or 32 bytes to select\n // AES-128, AES-192, or AES-256.\n-func NewCipher(key []byte) (*Cipher, os.Error) {\n+func NewCipher(key []byte) (*Cipher, error) {\n \tk := len(key)\n \tswitch k {\n \tdefault:"}, {"sha": "fc311609081849d379013a25310456fbb1a6e66a", "filename": "libgo/go/crypto/bcrypt/base64.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbase64.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,10 +4,7 @@\n \n package bcrypt\n \n-import (\n-\t\"encoding/base64\"\n-\t\"os\"\n-)\n+import \"encoding/base64\"\n \n const alphabet = \"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n \n@@ -23,7 +20,7 @@ func base64Encode(src []byte) []byte {\n \treturn dst[:n]\n }\n \n-func base64Decode(src []byte) ([]byte, os.Error) {\n+func base64Decode(src []byte) ([]byte, error) {\n \tnumOfEquals := 4 - (len(src) % 4)\n \tfor i := 0; i < numOfEquals; i++ {\n \t\tsrc = append(src, '=')"}, {"sha": "9740135622849210e8e3db8d588bcdeec65fd9cc", "filename": "libgo/go/crypto/bcrypt/bcrypt.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,9 +11,9 @@ import (\n \t\"crypto/blowfish\"\n \t\"crypto/rand\"\n \t\"crypto/subtle\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -25,30 +25,30 @@ const (\n \n // The error returned from CompareHashAndPassword when a password and hash do\n // not match.\n-var MismatchedHashAndPasswordError = os.NewError(\"crypto/bcrypt: hashedPassword is not the hash of the given password\")\n+var MismatchedHashAndPasswordError = errors.New(\"crypto/bcrypt: hashedPassword is not the hash of the given password\")\n \n // The error returned from CompareHashAndPassword when a hash is too short to\n // be a bcrypt hash.\n-var HashTooShortError = os.NewError(\"crypto/bcrypt: hashedSecret too short to be a bcrypted password\")\n+var HashTooShortError = errors.New(\"crypto/bcrypt: hashedSecret too short to be a bcrypted password\")\n \n // The error returned from CompareHashAndPassword when a hash was created with\n // a bcrypt algorithm newer than this implementation.\n type HashVersionTooNewError byte\n \n-func (hv HashVersionTooNewError) String() string {\n+func (hv HashVersionTooNewError) Error() string {\n \treturn fmt.Sprintf(\"crypto/bcrypt: bcrypt algorithm version '%c' requested is newer than current version '%c'\", byte(hv), majorVersion)\n }\n \n // The error returned from CompareHashAndPassword when a hash starts with something other than '$'\n type InvalidHashPrefixError byte\n \n-func (ih InvalidHashPrefixError) String() string {\n+func (ih InvalidHashPrefixError) Error() string {\n \treturn fmt.Sprintf(\"crypto/bcrypt: bcrypt hashes must start with '$', but hashedSecret started with '%c'\", byte(ih))\n }\n \n type InvalidCostError int\n \n-func (ic InvalidCostError) String() string {\n+func (ic InvalidCostError) Error() string {\n \treturn fmt.Sprintf(\"crypto/bcrypt: cost %d is outside allowed range (%d,%d)\", int(ic), int(MinCost), int(MaxCost))\n }\n \n@@ -85,7 +85,7 @@ type hashed struct {\n // cost. If the cost given is less than MinCost, the cost will be set to\n // MinCost, instead. Use CompareHashAndPassword, as defined in this package,\n // to compare the returned hashed password with its cleartext version.\n-func GenerateFromPassword(password []byte, cost int) ([]byte, os.Error) {\n+func GenerateFromPassword(password []byte, cost int) ([]byte, error) {\n \tp, err := newFromPassword(password, cost)\n \tif err != nil {\n \t\treturn nil, err\n@@ -96,7 +96,7 @@ func GenerateFromPassword(password []byte, cost int) ([]byte, os.Error) {\n // CompareHashAndPassword compares a bcrypt hashed password with its possible\n // plaintext equivalent. Note: Using bytes.Equal for this job is\n // insecure. Returns nil on success, or an error on failure.\n-func CompareHashAndPassword(hashedPassword, password []byte) os.Error {\n+func CompareHashAndPassword(hashedPassword, password []byte) error {\n \tp, err := newFromHash(hashedPassword)\n \tif err != nil {\n \t\treturn err\n@@ -115,7 +115,7 @@ func CompareHashAndPassword(hashedPassword, password []byte) os.Error {\n \treturn MismatchedHashAndPasswordError\n }\n \n-func newFromPassword(password []byte, cost int) (*hashed, os.Error) {\n+func newFromPassword(password []byte, cost int) (*hashed, error) {\n \tif cost < MinCost {\n \t\tcost = DefaultCost\n \t}\n@@ -144,7 +144,7 @@ func newFromPassword(password []byte, cost int) (*hashed, os.Error) {\n \treturn p, err\n }\n \n-func newFromHash(hashedSecret []byte) (*hashed, os.Error) {\n+func newFromHash(hashedSecret []byte) (*hashed, error) {\n \tif len(hashedSecret) < minHashSize {\n \t\treturn nil, HashTooShortError\n \t}\n@@ -172,7 +172,7 @@ func newFromHash(hashedSecret []byte) (*hashed, os.Error) {\n \treturn p, nil\n }\n \n-func bcrypt(password []byte, cost uint32, salt []byte) ([]byte, os.Error) {\n+func bcrypt(password []byte, cost uint32, salt []byte) ([]byte, error) {\n \tcipherData := make([]byte, len(magicCipherData))\n \tcopy(cipherData, magicCipherData)\n \n@@ -193,7 +193,7 @@ func bcrypt(password []byte, cost uint32, salt []byte) ([]byte, os.Error) {\n \treturn hsh, nil\n }\n \n-func expensiveBlowfishSetup(key []byte, cost uint32, salt []byte) (*blowfish.Cipher, os.Error) {\n+func expensiveBlowfishSetup(key []byte, cost uint32, salt []byte) (*blowfish.Cipher, error) {\n \n \tcsalt, err := base64Decode(salt)\n \tif err != nil {\n@@ -240,7 +240,7 @@ func (p *hashed) Hash() []byte {\n \treturn arr[:n]\n }\n \n-func (p *hashed) decodeVersion(sbytes []byte) (int, os.Error) {\n+func (p *hashed) decodeVersion(sbytes []byte) (int, error) {\n \tif sbytes[0] != '$' {\n \t\treturn -1, InvalidHashPrefixError(sbytes[0])\n \t}\n@@ -257,7 +257,7 @@ func (p *hashed) decodeVersion(sbytes []byte) (int, os.Error) {\n }\n \n // sbytes should begin where decodeVersion left off.\n-func (p *hashed) decodeCost(sbytes []byte) (int, os.Error) {\n+func (p *hashed) decodeCost(sbytes []byte) (int, error) {\n \tcost, err := strconv.Atoi(string(sbytes[0:2]))\n \tif err != nil {\n \t\treturn -1, err\n@@ -274,7 +274,7 @@ func (p *hashed) String() string {\n \treturn fmt.Sprintf(\"&{hash: %#v, salt: %#v, cost: %d, major: %c, minor: %c}\", string(p.hash), p.salt, p.cost, p.major, p.minor)\n }\n \n-func checkCost(cost int) os.Error {\n+func checkCost(cost int) error {\n \tif cost < MinCost || cost > MaxCost {\n \t\treturn InvalidCostError(cost)\n \t}"}, {"sha": "a3155c5cc728d933911f1d571e50a8062cc6525e", "filename": "libgo/go/crypto/bcrypt/bcrypt_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,7 +6,6 @@ package bcrypt\n \n import (\n \t\"bytes\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -68,7 +67,7 @@ func TestTooLongPasswordsWork(t *testing.T) {\n }\n \n type InvalidHashTest struct {\n-\terr  os.Error\n+\terr  error\n \thash []byte\n }\n \n@@ -81,7 +80,7 @@ var invalidTests = []InvalidHashTest{\n }\n \n func TestInvalidHashErrors(t *testing.T) {\n-\tcheck := func(name string, expected, err os.Error) {\n+\tcheck := func(name string, expected, err error) {\n \t\tif err == nil {\n \t\t\tt.Errorf(\"%s: Should have returned an error\", name)\n \t\t}"}, {"sha": "a5d56d2ebae8d63865e1b7600e0b81bfdcf02967", "filename": "libgo/go/crypto/blowfish/cipher.go", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,10 +8,7 @@ package blowfish\n // The code is a port of Bruce Schneier's C implementation.\n // See http://www.schneier.com/blowfish.html.\n \n-import (\n-\t\"os\"\n-\t\"strconv\"\n-)\n+import \"strconv\"\n \n // The Blowfish block size in bytes.\n const BlockSize = 8\n@@ -24,13 +21,13 @@ type Cipher struct {\n \n type KeySizeError int\n \n-func (k KeySizeError) String() string {\n+func (k KeySizeError) Error() string {\n \treturn \"crypto/blowfish: invalid key size \" + strconv.Itoa(int(k))\n }\n \n // NewCipher creates and returns a Cipher.\n // The key argument should be the Blowfish key, 4 to 56 bytes.\n-func NewCipher(key []byte) (*Cipher, os.Error) {\n+func NewCipher(key []byte) (*Cipher, error) {\n \tvar result Cipher\n \tk := len(key)\n \tif k < 4 || k > 56 {\n@@ -45,7 +42,7 @@ func NewCipher(key []byte) (*Cipher, os.Error) {\n // schedule. For most purposes, NewCipher, instead of NewSaltedCipher, is\n // sufficient and desirable. For bcrypt compatiblity, the key can be over 56\n // bytes.\n-func NewSaltedCipher(key, salt []byte) (*Cipher, os.Error) {\n+func NewSaltedCipher(key, salt []byte) (*Cipher, error) {\n \tvar result Cipher\n \tk := len(key)\n \tif k < 4 {"}, {"sha": "889a13cb1f7eba11e653d9338aeb3937dc5324e2", "filename": "libgo/go/crypto/cast5/cast5.go", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,9 +6,7 @@\n // OpenPGP cipher.\n package cast5\n \n-import (\n-\t\"os\"\n-)\n+import \"errors\"\n \n const BlockSize = 8\n const KeySize = 16\n@@ -18,9 +16,9 @@ type Cipher struct {\n \trotate  [16]uint8\n }\n \n-func NewCipher(key []byte) (c *Cipher, err os.Error) {\n+func NewCipher(key []byte) (c *Cipher, err error) {\n \tif len(key) != KeySize {\n-\t\treturn nil, os.NewError(\"CAST5: keys must be 16 bytes\")\n+\t\treturn nil, errors.New(\"CAST5: keys must be 16 bytes\")\n \t}\n \n \tc = new(Cipher)"}, {"sha": "9888c9806f314c55addca100987ae32d55819f35", "filename": "libgo/go/crypto/cipher/io.go", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,10 +4,7 @@\n \n package cipher\n \n-import (\n-\t\"os\"\n-\t\"io\"\n-)\n+import \"io\"\n \n // The Stream* objects are so simple that all their members are public. Users\n // can create them themselves.\n@@ -19,7 +16,7 @@ type StreamReader struct {\n \tR io.Reader\n }\n \n-func (r StreamReader) Read(dst []byte) (n int, err os.Error) {\n+func (r StreamReader) Read(dst []byte) (n int, err error) {\n \tn, err = r.R.Read(dst)\n \tr.S.XORKeyStream(dst[:n], dst[:n])\n \treturn\n@@ -31,10 +28,10 @@ func (r StreamReader) Read(dst []byte) (n int, err os.Error) {\n type StreamWriter struct {\n \tS   Stream\n \tW   io.Writer\n-\tErr os.Error\n+\tErr error\n }\n \n-func (w StreamWriter) Write(src []byte) (n int, err os.Error) {\n+func (w StreamWriter) Write(src []byte) (n int, err error) {\n \tif w.Err != nil {\n \t\treturn 0, w.Err\n \t}\n@@ -50,7 +47,7 @@ func (w StreamWriter) Write(src []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (w StreamWriter) Close() os.Error {\n+func (w StreamWriter) Close() error {\n \t// This saves us from either requiring a WriteCloser or having a\n \t// StreamWriterCloser.\n \treturn w.W.(io.Closer).Close()"}, {"sha": "fc252c8133cb13fd448572caba8848d808fae83a", "filename": "libgo/go/crypto/des/cipher.go", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,17 +4,14 @@\n \n package des\n \n-import (\n-\t\"os\"\n-\t\"strconv\"\n-)\n+import \"strconv\"\n \n // The DES block size in bytes.\n const BlockSize = 8\n \n type KeySizeError int\n \n-func (k KeySizeError) String() string {\n+func (k KeySizeError) Error() string {\n \treturn \"crypto/des: invalid key size \" + strconv.Itoa(int(k))\n }\n \n@@ -24,7 +21,7 @@ type Cipher struct {\n }\n \n // NewCipher creates and returns a new Cipher.\n-func NewCipher(key []byte) (*Cipher, os.Error) {\n+func NewCipher(key []byte) (*Cipher, error) {\n \tif len(key) != 8 {\n \t\treturn nil, KeySizeError(len(key))\n \t}\n@@ -60,7 +57,7 @@ type TripleDESCipher struct {\n }\n \n // NewCipher creates and returns a new Cipher.\n-func NewTripleDESCipher(key []byte) (*TripleDESCipher, os.Error) {\n+func NewTripleDESCipher(key []byte) (*TripleDESCipher, error) {\n \tif len(key) != 24 {\n \t\treturn nil, KeySizeError(len(key))\n \t}"}, {"sha": "692d62aa9efcce1b3f94158e0041c6a70a196dec", "filename": "libgo/go/crypto/dsa/dsa.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,8 +7,8 @@ package dsa\n \n import (\n \t\"big\"\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n )\n \n // Parameters represents the domain parameters for a key. These parameters can\n@@ -31,7 +31,7 @@ type PrivateKey struct {\n \n type invalidPublicKeyError int\n \n-func (invalidPublicKeyError) String() string {\n+func (invalidPublicKeyError) Error() string {\n \treturn \"crypto/dsa: invalid public key\"\n }\n \n@@ -58,7 +58,7 @@ const numMRTests = 64\n \n // GenerateParameters puts a random, valid set of DSA parameters into params.\n // This function takes many seconds, even on fast machines.\n-func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes) (err os.Error) {\n+func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes) (err error) {\n \t// This function doesn't follow FIPS 186-3 exactly in that it doesn't\n \t// use a verification seed to generate the primes. The verification\n \t// seed doesn't appear to be exported or used by other code and\n@@ -79,7 +79,7 @@ func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes\n \t\tL = 3072\n \t\tN = 256\n \tdefault:\n-\t\treturn os.NewError(\"crypto/dsa: invalid ParameterSizes\")\n+\t\treturn errors.New(\"crypto/dsa: invalid ParameterSizes\")\n \t}\n \n \tqBytes := make([]byte, N/8)\n@@ -156,9 +156,9 @@ GeneratePrimes:\n \n // GenerateKey generates a public&private key pair. The Parameters of the\n // PrivateKey must already be valid (see GenerateParameters).\n-func GenerateKey(priv *PrivateKey, rand io.Reader) os.Error {\n+func GenerateKey(priv *PrivateKey, rand io.Reader) error {\n \tif priv.P == nil || priv.Q == nil || priv.G == nil {\n-\t\treturn os.NewError(\"crypto/dsa: parameters not set up before generating key\")\n+\t\treturn errors.New(\"crypto/dsa: parameters not set up before generating key\")\n \t}\n \n \tx := new(big.Int)\n@@ -185,7 +185,7 @@ func GenerateKey(priv *PrivateKey, rand io.Reader) os.Error {\n // larger message) using the private key, priv. It returns the signature as a\n // pair of integers. The security of the private key depends on the entropy of\n // rand.\n-func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err os.Error) {\n+func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {\n \t// FIPS 186-3, section 4.6\n \n \tn := priv.Q.BitLen()"}, {"sha": "b7f235b3b10f819149aa073fd5aad94c9845192b", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -16,7 +16,6 @@ import (\n \t\"big\"\n \t\"crypto/elliptic\"\n \t\"io\"\n-\t\"os\"\n )\n \n // PublicKey represents an ECDSA public key.\n@@ -35,7 +34,7 @@ var one = new(big.Int).SetInt64(1)\n \n // randFieldElement returns a random element of the field underlying the given\n // curve using the procedure given in [NSA] A.2.1.\n-func randFieldElement(c *elliptic.Curve, rand io.Reader) (k *big.Int, err os.Error) {\n+func randFieldElement(c *elliptic.Curve, rand io.Reader) (k *big.Int, err error) {\n \tb := make([]byte, c.BitSize/8+8)\n \t_, err = io.ReadFull(rand, b)\n \tif err != nil {\n@@ -50,7 +49,7 @@ func randFieldElement(c *elliptic.Curve, rand io.Reader) (k *big.Int, err os.Err\n }\n \n // GenerateKey generates a public&private key pair.\n-func GenerateKey(c *elliptic.Curve, rand io.Reader) (priv *PrivateKey, err os.Error) {\n+func GenerateKey(c *elliptic.Curve, rand io.Reader) (priv *PrivateKey, err error) {\n \tk, err := randFieldElement(c, rand)\n \tif err != nil {\n \t\treturn\n@@ -86,7 +85,7 @@ func hashToInt(hash []byte, c *elliptic.Curve) *big.Int {\n // larger message) using the private key, priv. It returns the signature as a\n // pair of integers. The security of the private key depends on the entropy of\n // rand.\n-func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err os.Error) {\n+func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {\n \t// See [NSA] 3.4.1\n \tc := priv.PublicKey.Curve\n "}, {"sha": "3c3327fe030218a97d7e91dfded2617177b5eb70", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -16,7 +16,6 @@ package elliptic\n import (\n \t\"big\"\n \t\"io\"\n-\t\"os\"\n \t\"sync\"\n )\n \n@@ -249,7 +248,7 @@ var mask = []byte{0xff, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f}\n \n // GenerateKey returns a public/private key pair. The private key is generated\n // using the given reader, which must return random data.\n-func (curve *Curve) GenerateKey(rand io.Reader) (priv []byte, x, y *big.Int, err os.Error) {\n+func (curve *Curve) GenerateKey(rand io.Reader) (priv []byte, x, y *big.Int, err error) {\n \tbyteLen := (curve.BitSize + 7) >> 3\n \tpriv = make([]byte, byteLen)\n "}, {"sha": "6a17bbd44fa1451f8652b483c9e5712d752836cc", "filename": "libgo/go/crypto/hmac/hmac.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -13,7 +13,6 @@ import (\n \t\"crypto/sha1\"\n \t\"crypto/sha256\"\n \t\"hash\"\n-\t\"os\"\n )\n \n // FIPS 198:\n@@ -60,7 +59,7 @@ func (h *hmac) Sum() []byte {\n \treturn h.outer.Sum()\n }\n \n-func (h *hmac) Write(p []byte) (n int, err os.Error) {\n+func (h *hmac) Write(p []byte) (n int, err error) {\n \treturn h.inner.Write(p)\n }\n "}, {"sha": "f21cc51a21a0522d6dfc67cf37ddaa3163e7d38e", "filename": "libgo/go/crypto/md4/md4.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ package md4\n import (\n \t\"crypto\"\n \t\"hash\"\n-\t\"os\"\n )\n \n func init() {\n@@ -52,7 +51,7 @@ func New() hash.Hash {\n \n func (d *digest) Size() int { return Size }\n \n-func (d *digest) Write(p []byte) (nn int, err os.Error) {\n+func (d *digest) Write(p []byte) (nn int, err error) {\n \tnn = len(p)\n \td.len += uint64(nn)\n \tif d.nx > 0 {"}, {"sha": "20f3a1b6f7580f8167bfac1420d711f6cd03cac6", "filename": "libgo/go/crypto/md5/md5.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ package md5\n import (\n \t\"crypto\"\n \t\"hash\"\n-\t\"os\"\n )\n \n func init() {\n@@ -52,7 +51,7 @@ func New() hash.Hash {\n \n func (d *digest) Size() int { return Size }\n \n-func (d *digest) Write(p []byte) (nn int, err os.Error) {\n+func (d *digest) Write(p []byte) (nn int, err error) {\n \tnn = len(p)\n \td.len += uint64(nn)\n \tif d.nx > 0 {"}, {"sha": "f697fa170c43adf3d9b86eb2ab8f5b2c1227336e", "filename": "libgo/go/crypto/ocsp/ocsp.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -14,7 +14,6 @@ import (\n \t_ \"crypto/sha1\"\n \t\"crypto/x509\"\n \t\"crypto/x509/pkix\"\n-\t\"os\"\n \t\"time\"\n )\n \n@@ -106,15 +105,15 @@ type Response struct {\n // ParseError results from an invalid OCSP response.\n type ParseError string\n \n-func (p ParseError) String() string {\n+func (p ParseError) Error() string {\n \treturn string(p)\n }\n \n // ParseResponse parses an OCSP response in DER form. It only supports\n // responses for a single certificate and only those using RSA signatures.\n // Non-RSA responses will result in an x509.UnsupportedAlgorithmError.\n // Signature errors or parse failures will result in a ParseError.\n-func ParseResponse(bytes []byte) (*Response, os.Error) {\n+func ParseResponse(bytes []byte) (*Response, error) {\n \tvar resp responseASN1\n \trest, err := asn1.Unmarshal(bytes, &resp)\n \tif err != nil {"}, {"sha": "707bdf354b3f5c814067f70639bc6909b5416cd7", "filename": "libgo/go/crypto/openpgp/armor/armor.go", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,10 +9,9 @@ package armor\n import (\n \t\"bufio\"\n \t\"bytes\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"encoding/base64\"\n \t\"io\"\n-\t\"os\"\n )\n \n // A Block represents an OpenPGP armored structure.\n@@ -36,7 +35,7 @@ type Block struct {\n \toReader openpgpReader\n }\n \n-var ArmorCorrupt os.Error = error.StructuralError(\"armor invalid\")\n+var ArmorCorrupt error = error_.StructuralError(\"armor invalid\")\n \n const crc24Init = 0xb704ce\n const crc24Poly = 0x1864cfb\n@@ -69,9 +68,9 @@ type lineReader struct {\n \tcrc uint32\n }\n \n-func (l *lineReader) Read(p []byte) (n int, err os.Error) {\n+func (l *lineReader) Read(p []byte) (n int, err error) {\n \tif l.eof {\n-\t\treturn 0, os.EOF\n+\t\treturn 0, io.EOF\n \t}\n \n \tif len(l.buf) > 0 {\n@@ -101,15 +100,15 @@ func (l *lineReader) Read(p []byte) (n int, err os.Error) {\n \t\t\tuint32(expectedBytes[2])\n \n \t\tline, _, err = l.in.ReadLine()\n-\t\tif err != nil && err != os.EOF {\n+\t\tif err != nil && err != io.EOF {\n \t\t\treturn\n \t\t}\n \t\tif !bytes.HasPrefix(line, armorEnd) {\n \t\t\treturn 0, ArmorCorrupt\n \t\t}\n \n \t\tl.eof = true\n-\t\treturn 0, os.EOF\n+\t\treturn 0, io.EOF\n \t}\n \n \tif len(line) > 64 {\n@@ -138,11 +137,11 @@ type openpgpReader struct {\n \tcurrentCRC uint32\n }\n \n-func (r *openpgpReader) Read(p []byte) (n int, err os.Error) {\n+func (r *openpgpReader) Read(p []byte) (n int, err error) {\n \tn, err = r.b64Reader.Read(p)\n \tr.currentCRC = crc24(r.currentCRC, p[:n])\n \n-\tif err == os.EOF {\n+\tif err == io.EOF {\n \t\tif r.lReader.crc != uint32(r.currentCRC&crc24Mask) {\n \t\t\treturn 0, ArmorCorrupt\n \t\t}\n@@ -155,7 +154,7 @@ func (r *openpgpReader) Read(p []byte) (n int, err os.Error) {\n // leading garbage. If it doesn't find a block, it will return nil, os.EOF. The\n // given Reader is not usable after calling this function: an arbitrary amount\n // of data may have been read past the end of the block.\n-func Decode(in io.Reader) (p *Block, err os.Error) {\n+func Decode(in io.Reader) (p *Block, err error) {\n \tr, _ := bufio.NewReaderSize(in, 100)\n \tvar line []byte\n \tignoreNext := false"}, {"sha": "6f07582c37cea69c0f972ccd1f3d53f9a5fe1d02", "filename": "libgo/go/crypto/openpgp/armor/encode.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package armor\n import (\n \t\"encoding/base64\"\n \t\"io\"\n-\t\"os\"\n )\n \n var armorHeaderSep = []byte(\": \")\n@@ -16,7 +15,7 @@ var newline = []byte(\"\\n\")\n var armorEndOfLineOut = []byte(\"-----\\n\")\n \n // writeSlices writes its arguments to the given Writer.\n-func writeSlices(out io.Writer, slices ...[]byte) (err os.Error) {\n+func writeSlices(out io.Writer, slices ...[]byte) (err error) {\n \tfor _, s := range slices {\n \t\t_, err = out.Write(s)\n \t\tif err != nil {\n@@ -45,7 +44,7 @@ func newLineBreaker(out io.Writer, lineLength int) *lineBreaker {\n \t}\n }\n \n-func (l *lineBreaker) Write(b []byte) (n int, err os.Error) {\n+func (l *lineBreaker) Write(b []byte) (n int, err error) {\n \tn = len(b)\n \n \tif n == 0 {\n@@ -81,7 +80,7 @@ func (l *lineBreaker) Write(b []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (l *lineBreaker) Close() (err os.Error) {\n+func (l *lineBreaker) Close() (err error) {\n \tif l.used > 0 {\n \t\t_, err = l.out.Write(l.line[0:l.used])\n \t\tif err != nil {\n@@ -106,12 +105,12 @@ type encoding struct {\n \tblockType []byte\n }\n \n-func (e *encoding) Write(data []byte) (n int, err os.Error) {\n+func (e *encoding) Write(data []byte) (n int, err error) {\n \te.crc = crc24(e.crc, data)\n \treturn e.b64.Write(data)\n }\n \n-func (e *encoding) Close() (err os.Error) {\n+func (e *encoding) Close() (err error) {\n \terr = e.b64.Close()\n \tif err != nil {\n \t\treturn\n@@ -131,7 +130,7 @@ func (e *encoding) Close() (err os.Error) {\n \n // Encode returns a WriteCloser which will encode the data written to it in\n // OpenPGP armor.\n-func Encode(out io.Writer, blockType string, headers map[string]string) (w io.WriteCloser, err os.Error) {\n+func Encode(out io.Writer, blockType string, headers map[string]string) (w io.WriteCloser, err error) {\n \tbType := []byte(blockType)\n \terr = writeSlices(out, armorStart, bType, armorEndOfLineOut)\n \tif err != nil {"}, {"sha": "fe4557aafc19a943be46ce17400a531608acddc7", "filename": "libgo/go/crypto/openpgp/canonical_text.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,10 +4,7 @@\n \n package openpgp\n \n-import (\n-\t\"hash\"\n-\t\"os\"\n-)\n+import \"hash\"\n \n // NewCanonicalTextHash reformats text written to it into the canonical\n // form and then applies the hash h.  See RFC 4880, section 5.2.1.\n@@ -22,7 +19,7 @@ type canonicalTextHash struct {\n \n var newline = []byte{'\\r', '\\n'}\n \n-func (cth *canonicalTextHash) Write(buf []byte) (int, os.Error) {\n+func (cth *canonicalTextHash) Write(buf []byte) (int, error) {\n \tstart := 0\n \n \tfor i, c := range buf {"}, {"sha": "ae54f8c83ee0aeaae1bfceb6c4f22cb32eb50502", "filename": "libgo/go/crypto/openpgp/canonical_text_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,15 +6,14 @@ package openpgp\n \n import (\n \t\"bytes\"\n-\t\"os\"\n \t\"testing\"\n )\n \n type recordingHash struct {\n \tbuf *bytes.Buffer\n }\n \n-func (r recordingHash) Write(b []byte) (n int, err os.Error) {\n+func (r recordingHash) Write(b []byte) (n int, err error) {\n \treturn r.buf.Write(b)\n }\n "}, {"sha": "2ed49f621333ef0ac8eb10842a9599f7fbc47b94", "filename": "libgo/go/crypto/openpgp/elgamal/elgamal.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -16,8 +16,8 @@ import (\n \t\"big\"\n \t\"crypto/rand\"\n \t\"crypto/subtle\"\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n )\n \n // PublicKey represents an ElGamal public key.\n@@ -34,10 +34,10 @@ type PrivateKey struct {\n // Encrypt encrypts the given message to the given public key. The result is a\n // pair of integers. Errors can result from reading random, or because msg is\n // too large to be encrypted to the public key.\n-func Encrypt(random io.Reader, pub *PublicKey, msg []byte) (c1, c2 *big.Int, err os.Error) {\n+func Encrypt(random io.Reader, pub *PublicKey, msg []byte) (c1, c2 *big.Int, err error) {\n \tpLen := (pub.P.BitLen() + 7) / 8\n \tif len(msg) > pLen-11 {\n-\t\terr = os.NewError(\"elgamal: message too long\")\n+\t\terr = errors.New(\"elgamal: message too long\")\n \t\treturn\n \t}\n \n@@ -74,7 +74,7 @@ func Encrypt(random io.Reader, pub *PublicKey, msg []byte) (c1, c2 *big.Int, err\n // be used to break the cryptosystem.  See ``Chosen Ciphertext Attacks\n // Against Protocols Based on the RSA Encryption Standard PKCS #1'', Daniel\n // Bleichenbacher, Advances in Cryptology (Crypto '98),\n-func Decrypt(priv *PrivateKey, c1, c2 *big.Int) (msg []byte, err os.Error) {\n+func Decrypt(priv *PrivateKey, c1, c2 *big.Int) (msg []byte, err error) {\n \ts := new(big.Int).Exp(c1, priv.X, priv.P)\n \ts.ModInverse(s, priv.P)\n \ts.Mul(s, c2)\n@@ -97,13 +97,13 @@ func Decrypt(priv *PrivateKey, c1, c2 *big.Int) (msg []byte, err os.Error) {\n \t}\n \n \tif firstByteIsTwo != 1 || lookingForIndex != 0 || index < 9 {\n-\t\treturn nil, os.NewError(\"elgamal: decryption error\")\n+\t\treturn nil, errors.New(\"elgamal: decryption error\")\n \t}\n \treturn em[index+1:], nil\n }\n \n // nonZeroRandomBytes fills the given slice with non-zero random octets.\n-func nonZeroRandomBytes(s []byte, rand io.Reader) (err os.Error) {\n+func nonZeroRandomBytes(s []byte, rand io.Reader) (err error) {\n \t_, err = io.ReadFull(rand, s)\n \tif err != nil {\n \t\treturn"}, {"sha": "ceeb05419488b2274625d222ba7f151c28a8dc62", "filename": "libgo/go/crypto/openpgp/error/error.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -13,52 +13,52 @@ import (\n // invalid.\n type StructuralError string\n \n-func (s StructuralError) String() string {\n+func (s StructuralError) Error() string {\n \treturn \"OpenPGP data invalid: \" + string(s)\n }\n \n // UnsupportedError indicates that, although the OpenPGP data is valid, it\n // makes use of currently unimplemented features.\n type UnsupportedError string\n \n-func (s UnsupportedError) String() string {\n+func (s UnsupportedError) Error() string {\n \treturn \"OpenPGP feature unsupported: \" + string(s)\n }\n \n // InvalidArgumentError indicates that the caller is in error and passed an\n // incorrect value.\n type InvalidArgumentError string\n \n-func (i InvalidArgumentError) String() string {\n+func (i InvalidArgumentError) Error() string {\n \treturn \"OpenPGP argument invalid: \" + string(i)\n }\n \n // SignatureError indicates that a syntactically valid signature failed to\n // validate.\n type SignatureError string\n \n-func (b SignatureError) String() string {\n+func (b SignatureError) Error() string {\n \treturn \"OpenPGP signature invalid: \" + string(b)\n }\n \n type keyIncorrectError int\n \n-func (ki keyIncorrectError) String() string {\n+func (ki keyIncorrectError) Error() string {\n \treturn \"the given key was incorrect\"\n }\n \n var KeyIncorrectError = keyIncorrectError(0)\n \n type unknownIssuerError int\n \n-func (unknownIssuerError) String() string {\n+func (unknownIssuerError) Error() string {\n \treturn \"signature make by unknown entity\"\n }\n \n var UnknownIssuerError = unknownIssuerError(0)\n \n type UnknownPacketTypeError uint8\n \n-func (upte UnknownPacketTypeError) String() string {\n+func (upte UnknownPacketTypeError) Error() string {\n \treturn \"unknown OpenPGP packet type: \" + strconv.Itoa(int(upte))\n }"}, {"sha": "b705d226e1f047c9a444574a8e8f8de2de0c7730", "filename": "libgo/go/crypto/openpgp/keys.go", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,11 +7,10 @@ package openpgp\n import (\n \t\"crypto\"\n \t\"crypto/openpgp/armor\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"crypto/openpgp/packet\"\n \t\"crypto/rsa\"\n \t\"io\"\n-\t\"os\"\n \t\"time\"\n )\n \n@@ -178,36 +177,36 @@ func (el EntityList) DecryptionKeys() (keys []Key) {\n }\n \n // ReadArmoredKeyRing reads one or more public/private keys from an armor keyring file.\n-func ReadArmoredKeyRing(r io.Reader) (EntityList, os.Error) {\n+func ReadArmoredKeyRing(r io.Reader) (EntityList, error) {\n \tblock, err := armor.Decode(r)\n-\tif err == os.EOF {\n-\t\treturn nil, error.InvalidArgumentError(\"no armored data found\")\n+\tif err == io.EOF {\n+\t\treturn nil, error_.InvalidArgumentError(\"no armored data found\")\n \t}\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \tif block.Type != PublicKeyType && block.Type != PrivateKeyType {\n-\t\treturn nil, error.InvalidArgumentError(\"expected public or private key block, got: \" + block.Type)\n+\t\treturn nil, error_.InvalidArgumentError(\"expected public or private key block, got: \" + block.Type)\n \t}\n \n \treturn ReadKeyRing(block.Body)\n }\n \n // ReadKeyRing reads one or more public/private keys. Unsupported keys are\n // ignored as long as at least a single valid key is found.\n-func ReadKeyRing(r io.Reader) (el EntityList, err os.Error) {\n+func ReadKeyRing(r io.Reader) (el EntityList, err error) {\n \tpackets := packet.NewReader(r)\n-\tvar lastUnsupportedError os.Error\n+\tvar lastUnsupportedError error\n \n \tfor {\n \t\tvar e *Entity\n \t\te, err = readEntity(packets)\n \t\tif err != nil {\n-\t\t\tif _, ok := err.(error.UnsupportedError); ok {\n+\t\t\tif _, ok := err.(error_.UnsupportedError); ok {\n \t\t\t\tlastUnsupportedError = err\n \t\t\t\terr = readToNextPublicKey(packets)\n \t\t\t}\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\terr = nil\n \t\t\t\tbreak\n \t\t\t}\n@@ -228,14 +227,14 @@ func ReadKeyRing(r io.Reader) (el EntityList, err os.Error) {\n \n // readToNextPublicKey reads packets until the start of the entity and leaves\n // the first packet of the new entity in the Reader.\n-func readToNextPublicKey(packets *packet.Reader) (err os.Error) {\n+func readToNextPublicKey(packets *packet.Reader) (err error) {\n \tvar p packet.Packet\n \tfor {\n \t\tp, err = packets.Next()\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\treturn\n \t\t} else if err != nil {\n-\t\t\tif _, ok := err.(error.UnsupportedError); ok {\n+\t\t\tif _, ok := err.(error_.UnsupportedError); ok {\n \t\t\t\terr = nil\n \t\t\t\tcontinue\n \t\t\t}\n@@ -253,7 +252,7 @@ func readToNextPublicKey(packets *packet.Reader) (err os.Error) {\n \n // readEntity reads an entity (public key, identities, subkeys etc) from the\n // given Reader.\n-func readEntity(packets *packet.Reader) (*Entity, os.Error) {\n+func readEntity(packets *packet.Reader) (*Entity, error) {\n \te := new(Entity)\n \te.Identities = make(map[string]*Identity)\n \n@@ -266,21 +265,21 @@ func readEntity(packets *packet.Reader) (*Entity, os.Error) {\n \tif e.PrimaryKey, ok = p.(*packet.PublicKey); !ok {\n \t\tif e.PrivateKey, ok = p.(*packet.PrivateKey); !ok {\n \t\t\tpackets.Unread(p)\n-\t\t\treturn nil, error.StructuralError(\"first packet was not a public/private key\")\n+\t\t\treturn nil, error_.StructuralError(\"first packet was not a public/private key\")\n \t\t} else {\n \t\t\te.PrimaryKey = &e.PrivateKey.PublicKey\n \t\t}\n \t}\n \n \tif !e.PrimaryKey.PubKeyAlgo.CanSign() {\n-\t\treturn nil, error.StructuralError(\"primary key cannot be used for signatures\")\n+\t\treturn nil, error_.StructuralError(\"primary key cannot be used for signatures\")\n \t}\n \n \tvar current *Identity\n EachPacket:\n \tfor {\n \t\tp, err := packets.Next()\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\tbreak\n \t\t} else if err != nil {\n \t\t\treturn nil, err\n@@ -295,20 +294,20 @@ EachPacket:\n \n \t\t\tfor {\n \t\t\t\tp, err = packets.Next()\n-\t\t\t\tif err == os.EOF {\n+\t\t\t\tif err == io.EOF {\n \t\t\t\t\treturn nil, io.ErrUnexpectedEOF\n \t\t\t\t} else if err != nil {\n \t\t\t\t\treturn nil, err\n \t\t\t\t}\n \n \t\t\t\tsig, ok := p.(*packet.Signature)\n \t\t\t\tif !ok {\n-\t\t\t\t\treturn nil, error.StructuralError(\"user ID packet not followed by self-signature\")\n+\t\t\t\t\treturn nil, error_.StructuralError(\"user ID packet not followed by self-signature\")\n \t\t\t\t}\n \n \t\t\t\tif (sig.SigType == packet.SigTypePositiveCert || sig.SigType == packet.SigTypeGenericCert) && sig.IssuerKeyId != nil && *sig.IssuerKeyId == e.PrimaryKey.KeyId {\n \t\t\t\t\tif err = e.PrimaryKey.VerifyUserIdSignature(pkt.Id, sig); err != nil {\n-\t\t\t\t\t\treturn nil, error.StructuralError(\"user ID self-signature invalid: \" + err.String())\n+\t\t\t\t\t\treturn nil, error_.StructuralError(\"user ID self-signature invalid: \" + err.Error())\n \t\t\t\t\t}\n \t\t\t\t\tcurrent.SelfSignature = sig\n \t\t\t\t\tbreak\n@@ -317,7 +316,7 @@ EachPacket:\n \t\t\t}\n \t\tcase *packet.Signature:\n \t\t\tif current == nil {\n-\t\t\t\treturn nil, error.StructuralError(\"signature packet found before user id packet\")\n+\t\t\t\treturn nil, error_.StructuralError(\"signature packet found before user id packet\")\n \t\t\t}\n \t\t\tcurrent.Signatures = append(current.Signatures, pkt)\n \t\tcase *packet.PrivateKey:\n@@ -344,34 +343,34 @@ EachPacket:\n \t}\n \n \tif len(e.Identities) == 0 {\n-\t\treturn nil, error.StructuralError(\"entity without any identities\")\n+\t\treturn nil, error_.StructuralError(\"entity without any identities\")\n \t}\n \n \treturn e, nil\n }\n \n-func addSubkey(e *Entity, packets *packet.Reader, pub *packet.PublicKey, priv *packet.PrivateKey) os.Error {\n+func addSubkey(e *Entity, packets *packet.Reader, pub *packet.PublicKey, priv *packet.PrivateKey) error {\n \tvar subKey Subkey\n \tsubKey.PublicKey = pub\n \tsubKey.PrivateKey = priv\n \tp, err := packets.Next()\n-\tif err == os.EOF {\n+\tif err == io.EOF {\n \t\treturn io.ErrUnexpectedEOF\n \t}\n \tif err != nil {\n-\t\treturn error.StructuralError(\"subkey signature invalid: \" + err.String())\n+\t\treturn error_.StructuralError(\"subkey signature invalid: \" + err.Error())\n \t}\n \tvar ok bool\n \tsubKey.Sig, ok = p.(*packet.Signature)\n \tif !ok {\n-\t\treturn error.StructuralError(\"subkey packet not followed by signature\")\n+\t\treturn error_.StructuralError(\"subkey packet not followed by signature\")\n \t}\n \tif subKey.Sig.SigType != packet.SigTypeSubkeyBinding {\n-\t\treturn error.StructuralError(\"subkey signature with wrong type\")\n+\t\treturn error_.StructuralError(\"subkey signature with wrong type\")\n \t}\n \terr = e.PrimaryKey.VerifyKeySignature(subKey.PublicKey, subKey.Sig)\n \tif err != nil {\n-\t\treturn error.StructuralError(\"subkey signature invalid: \" + err.String())\n+\t\treturn error_.StructuralError(\"subkey signature invalid: \" + err.Error())\n \t}\n \te.Subkeys = append(e.Subkeys, subKey)\n \treturn nil\n@@ -382,10 +381,10 @@ const defaultRSAKeyBits = 2048\n // NewEntity returns an Entity that contains a fresh RSA/RSA keypair with a\n // single identity composed of the given full name, comment and email, any of\n // which may be empty but must not contain any of \"()<>\\x00\".\n-func NewEntity(rand io.Reader, currentTimeSecs int64, name, comment, email string) (*Entity, os.Error) {\n+func NewEntity(rand io.Reader, currentTimeSecs int64, name, comment, email string) (*Entity, error) {\n \tuid := packet.NewUserId(name, comment, email)\n \tif uid == nil {\n-\t\treturn nil, error.InvalidArgumentError(\"user id field contained invalid characters\")\n+\t\treturn nil, error_.InvalidArgumentError(\"user id field contained invalid characters\")\n \t}\n \tsigningPriv, err := rsa.GenerateKey(rand, defaultRSAKeyBits)\n \tif err != nil {\n@@ -442,7 +441,7 @@ func NewEntity(rand io.Reader, currentTimeSecs int64, name, comment, email strin\n // SerializePrivate serializes an Entity, including private key material, to\n // the given Writer. For now, it must only be used on an Entity returned from\n // NewEntity.\n-func (e *Entity) SerializePrivate(w io.Writer) (err os.Error) {\n+func (e *Entity) SerializePrivate(w io.Writer) (err error) {\n \terr = e.PrivateKey.Serialize(w)\n \tif err != nil {\n \t\treturn\n@@ -480,7 +479,7 @@ func (e *Entity) SerializePrivate(w io.Writer) (err os.Error) {\n \n // Serialize writes the public part of the given Entity to w. (No private\n // key material will be output).\n-func (e *Entity) Serialize(w io.Writer) os.Error {\n+func (e *Entity) Serialize(w io.Writer) error {\n \terr := e.PrimaryKey.Serialize(w)\n \tif err != nil {\n \t\treturn err\n@@ -518,16 +517,16 @@ func (e *Entity) Serialize(w io.Writer) os.Error {\n // associated with e. The provided identity must already be an element of\n // e.Identities and the private key of signer must have been decrypted if\n // necessary.\n-func (e *Entity) SignIdentity(identity string, signer *Entity) os.Error {\n+func (e *Entity) SignIdentity(identity string, signer *Entity) error {\n \tif signer.PrivateKey == nil {\n-\t\treturn error.InvalidArgumentError(\"signing Entity must have a private key\")\n+\t\treturn error_.InvalidArgumentError(\"signing Entity must have a private key\")\n \t}\n \tif signer.PrivateKey.Encrypted {\n-\t\treturn error.InvalidArgumentError(\"signing Entity's private key must be decrypted\")\n+\t\treturn error_.InvalidArgumentError(\"signing Entity's private key must be decrypted\")\n \t}\n \tident, ok := e.Identities[identity]\n \tif !ok {\n-\t\treturn error.InvalidArgumentError(\"given identity string not found in Entity\")\n+\t\treturn error_.InvalidArgumentError(\"given identity string not found in Entity\")\n \t}\n \n \tsig := &packet.Signature{"}, {"sha": "f80d798cfe6bfa16ffcb460ee3ae52d046caf062", "filename": "libgo/go/crypto/openpgp/packet/compressed.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,9 +7,8 @@ package packet\n import (\n \t\"compress/flate\"\n \t\"compress/zlib\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -19,7 +18,7 @@ type Compressed struct {\n \tBody io.Reader\n }\n \n-func (c *Compressed) parse(r io.Reader) os.Error {\n+func (c *Compressed) parse(r io.Reader) error {\n \tvar buf [1]byte\n \t_, err := readFull(r, buf[:])\n \tif err != nil {\n@@ -32,7 +31,7 @@ func (c *Compressed) parse(r io.Reader) os.Error {\n \tcase 2:\n \t\tc.Body, err = zlib.NewReader(r)\n \tdefault:\n-\t\terr = error.UnsupportedError(\"unknown compression algorithm: \" + strconv.Itoa(int(buf[0])))\n+\t\terr = error_.UnsupportedError(\"unknown compression algorithm: \" + strconv.Itoa(int(buf[0])))\n \t}\n \n \treturn err"}, {"sha": "cb2d70bd411a131bdae47e94aade6594d443b440", "filename": "libgo/go/crypto/openpgp/packet/compressed_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,7 @@ package packet\n import (\n \t\"bytes\"\n \t\"encoding/hex\"\n-\t\"os\"\n+\t\"io\"\n \t\"io/ioutil\"\n \t\"testing\"\n )\n@@ -26,7 +26,7 @@ func TestCompressed(t *testing.T) {\n \t}\n \n \tcontents, err := ioutil.ReadAll(c.Body)\n-\tif err != nil && err != os.EOF {\n+\tif err != nil && err != io.EOF {\n \t\tt.Error(err)\n \t\treturn\n \t}"}, {"sha": "d05103fcd82610959a19cd05dec329e50fe4ace2", "filename": "libgo/go/crypto/openpgp/packet/encrypted_key.go", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,12 +7,11 @@ package packet\n import (\n \t\"big\"\n \t\"crypto/openpgp/elgamal\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"crypto/rand\"\n \t\"crypto/rsa\"\n \t\"encoding/binary\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -29,14 +28,14 @@ type EncryptedKey struct {\n \tencryptedMPI1, encryptedMPI2 []byte\n }\n \n-func (e *EncryptedKey) parse(r io.Reader) (err os.Error) {\n+func (e *EncryptedKey) parse(r io.Reader) (err error) {\n \tvar buf [10]byte\n \t_, err = readFull(r, buf[:])\n \tif err != nil {\n \t\treturn\n \t}\n \tif buf[0] != encryptedKeyVersion {\n-\t\treturn error.UnsupportedError(\"unknown EncryptedKey version \" + strconv.Itoa(int(buf[0])))\n+\t\treturn error_.UnsupportedError(\"unknown EncryptedKey version \" + strconv.Itoa(int(buf[0])))\n \t}\n \te.KeyId = binary.BigEndian.Uint64(buf[1:9])\n \te.Algo = PublicKeyAlgorithm(buf[9])\n@@ -64,8 +63,8 @@ func checksumKeyMaterial(key []byte) uint16 {\n \n // Decrypt decrypts an encrypted session key with the given private key. The\n // private key must have been decrypted first.\n-func (e *EncryptedKey) Decrypt(priv *PrivateKey) os.Error {\n-\tvar err os.Error\n+func (e *EncryptedKey) Decrypt(priv *PrivateKey) error {\n+\tvar err error\n \tvar b []byte\n \n \t// TODO(agl): use session key decryption routines here to avoid\n@@ -78,7 +77,7 @@ func (e *EncryptedKey) Decrypt(priv *PrivateKey) os.Error {\n \t\tc2 := new(big.Int).SetBytes(e.encryptedMPI2)\n \t\tb, err = elgamal.Decrypt(priv.PrivateKey.(*elgamal.PrivateKey), c1, c2)\n \tdefault:\n-\t\terr = error.InvalidArgumentError(\"cannot decrypted encrypted session key with private key of type \" + strconv.Itoa(int(priv.PubKeyAlgo)))\n+\t\terr = error_.InvalidArgumentError(\"cannot decrypted encrypted session key with private key of type \" + strconv.Itoa(int(priv.PubKeyAlgo)))\n \t}\n \n \tif err != nil {\n@@ -90,15 +89,15 @@ func (e *EncryptedKey) Decrypt(priv *PrivateKey) os.Error {\n \texpectedChecksum := uint16(b[len(b)-2])<<8 | uint16(b[len(b)-1])\n \tchecksum := checksumKeyMaterial(e.Key)\n \tif checksum != expectedChecksum {\n-\t\treturn error.StructuralError(\"EncryptedKey checksum incorrect\")\n+\t\treturn error_.StructuralError(\"EncryptedKey checksum incorrect\")\n \t}\n \n \treturn nil\n }\n \n // SerializeEncryptedKey serializes an encrypted key packet to w that contains\n // key, encrypted to pub.\n-func SerializeEncryptedKey(w io.Writer, rand io.Reader, pub *PublicKey, cipherFunc CipherFunction, key []byte) os.Error {\n+func SerializeEncryptedKey(w io.Writer, rand io.Reader, pub *PublicKey, cipherFunc CipherFunction, key []byte) error {\n \tvar buf [10]byte\n \tbuf[0] = encryptedKeyVersion\n \tbinary.BigEndian.PutUint64(buf[1:9], pub.KeyId)\n@@ -117,16 +116,16 @@ func SerializeEncryptedKey(w io.Writer, rand io.Reader, pub *PublicKey, cipherFu\n \tcase PubKeyAlgoElGamal:\n \t\treturn serializeEncryptedKeyElGamal(w, rand, buf, pub.PublicKey.(*elgamal.PublicKey), keyBlock)\n \tcase PubKeyAlgoDSA, PubKeyAlgoRSASignOnly:\n-\t\treturn error.InvalidArgumentError(\"cannot encrypt to public key of type \" + strconv.Itoa(int(pub.PubKeyAlgo)))\n+\t\treturn error_.InvalidArgumentError(\"cannot encrypt to public key of type \" + strconv.Itoa(int(pub.PubKeyAlgo)))\n \t}\n \n-\treturn error.UnsupportedError(\"encrypting a key to public key of type \" + strconv.Itoa(int(pub.PubKeyAlgo)))\n+\treturn error_.UnsupportedError(\"encrypting a key to public key of type \" + strconv.Itoa(int(pub.PubKeyAlgo)))\n }\n \n-func serializeEncryptedKeyRSA(w io.Writer, rand io.Reader, header [10]byte, pub *rsa.PublicKey, keyBlock []byte) os.Error {\n+func serializeEncryptedKeyRSA(w io.Writer, rand io.Reader, header [10]byte, pub *rsa.PublicKey, keyBlock []byte) error {\n \tcipherText, err := rsa.EncryptPKCS1v15(rand, pub, keyBlock)\n \tif err != nil {\n-\t\treturn error.InvalidArgumentError(\"RSA encryption failed: \" + err.String())\n+\t\treturn error_.InvalidArgumentError(\"RSA encryption failed: \" + err.Error())\n \t}\n \n \tpacketLen := 10 /* header length */ + 2 /* mpi size */ + len(cipherText)\n@@ -142,10 +141,10 @@ func serializeEncryptedKeyRSA(w io.Writer, rand io.Reader, header [10]byte, pub\n \treturn writeMPI(w, 8*uint16(len(cipherText)), cipherText)\n }\n \n-func serializeEncryptedKeyElGamal(w io.Writer, rand io.Reader, header [10]byte, pub *elgamal.PublicKey, keyBlock []byte) os.Error {\n+func serializeEncryptedKeyElGamal(w io.Writer, rand io.Reader, header [10]byte, pub *elgamal.PublicKey, keyBlock []byte) error {\n \tc1, c2, err := elgamal.Encrypt(rand, pub, keyBlock)\n \tif err != nil {\n-\t\treturn error.InvalidArgumentError(\"ElGamal encryption failed: \" + err.String())\n+\t\treturn error_.InvalidArgumentError(\"ElGamal encryption failed: \" + err.Error())\n \t}\n \n \tpacketLen := 10 /* header length */"}, {"sha": "1a9ec6e51e81d482b056e5fb26bc8b5cd6643ee6", "filename": "libgo/go/crypto/openpgp/packet/literal.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fliteral.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fliteral.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fliteral.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package packet\n import (\n \t\"encoding/binary\"\n \t\"io\"\n-\t\"os\"\n )\n \n // LiteralData represents an encrypted file. See RFC 4880, section 5.9.\n@@ -24,7 +23,7 @@ func (l *LiteralData) ForEyesOnly() bool {\n \treturn l.FileName == \"_CONSOLE\"\n }\n \n-func (l *LiteralData) parse(r io.Reader) (err os.Error) {\n+func (l *LiteralData) parse(r io.Reader) (err error) {\n \tvar buf [256]byte\n \n \t_, err = readFull(r, buf[:2])\n@@ -55,7 +54,7 @@ func (l *LiteralData) parse(r io.Reader) (err os.Error) {\n // SerializeLiteral serializes a literal data packet to w and returns a\n // WriteCloser to which the data itself can be written and which MUST be closed\n // on completion. The fileName is truncated to 255 bytes.\n-func SerializeLiteral(w io.WriteCloser, isBinary bool, fileName string, time uint32) (plaintext io.WriteCloser, err os.Error) {\n+func SerializeLiteral(w io.WriteCloser, isBinary bool, fileName string, time uint32) (plaintext io.WriteCloser, err error) {\n \tvar buf [4]byte\n \tbuf[0] = 't'\n \tif isBinary {"}, {"sha": "13e6aa5aff8d5fa974daf98559d4bd9ff3cc7fc0", "filename": "libgo/go/crypto/openpgp/packet/one_pass_signature.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,11 +6,10 @@ package packet\n \n import (\n \t\"crypto\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"crypto/openpgp/s2k\"\n \t\"encoding/binary\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -26,21 +25,21 @@ type OnePassSignature struct {\n \n const onePassSignatureVersion = 3\n \n-func (ops *OnePassSignature) parse(r io.Reader) (err os.Error) {\n+func (ops *OnePassSignature) parse(r io.Reader) (err error) {\n \tvar buf [13]byte\n \n \t_, err = readFull(r, buf[:])\n \tif err != nil {\n \t\treturn\n \t}\n \tif buf[0] != onePassSignatureVersion {\n-\t\terr = error.UnsupportedError(\"one-pass-signature packet version \" + strconv.Itoa(int(buf[0])))\n+\t\terr = error_.UnsupportedError(\"one-pass-signature packet version \" + strconv.Itoa(int(buf[0])))\n \t}\n \n \tvar ok bool\n \tops.Hash, ok = s2k.HashIdToHash(buf[2])\n \tif !ok {\n-\t\treturn error.UnsupportedError(\"hash function: \" + strconv.Itoa(int(buf[2])))\n+\t\treturn error_.UnsupportedError(\"hash function: \" + strconv.Itoa(int(buf[2])))\n \t}\n \n \tops.SigType = SignatureType(buf[1])\n@@ -51,14 +50,14 @@ func (ops *OnePassSignature) parse(r io.Reader) (err os.Error) {\n }\n \n // Serialize marshals the given OnePassSignature to w.\n-func (ops *OnePassSignature) Serialize(w io.Writer) os.Error {\n+func (ops *OnePassSignature) Serialize(w io.Writer) error {\n \tvar buf [13]byte\n \tbuf[0] = onePassSignatureVersion\n \tbuf[1] = uint8(ops.SigType)\n \tvar ok bool\n \tbuf[2], ok = s2k.HashToHashId(ops.Hash)\n \tif !ok {\n-\t\treturn error.UnsupportedError(\"hash type: \" + strconv.Itoa(int(ops.Hash)))\n+\t\treturn error_.UnsupportedError(\"hash type: \" + strconv.Itoa(int(ops.Hash)))\n \t}\n \tbuf[3] = uint8(ops.PubKeyAlgo)\n \tbinary.BigEndian.PutUint64(buf[4:12], ops.KeyId)"}, {"sha": "f7ed3536c52502cee7a7f600c0c185d13f56eba6", "filename": "libgo/go/crypto/openpgp/packet/packet.go", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,23 +11,22 @@ import (\n \t\"crypto/aes\"\n \t\"crypto/cast5\"\n \t\"crypto/cipher\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"io\"\n-\t\"os\"\n )\n \n // readFull is the same as io.ReadFull except that reading zero bytes returns\n // ErrUnexpectedEOF rather than EOF.\n-func readFull(r io.Reader, buf []byte) (n int, err os.Error) {\n+func readFull(r io.Reader, buf []byte) (n int, err error) {\n \tn, err = io.ReadFull(r, buf)\n-\tif err == os.EOF {\n+\tif err == io.EOF {\n \t\terr = io.ErrUnexpectedEOF\n \t}\n \treturn\n }\n \n // readLength reads an OpenPGP length from r. See RFC 4880, section 4.2.2.\n-func readLength(r io.Reader) (length int64, isPartial bool, err os.Error) {\n+func readLength(r io.Reader) (length int64, isPartial bool, err error) {\n \tvar buf [4]byte\n \t_, err = readFull(r, buf[:1])\n \tif err != nil {\n@@ -68,10 +67,10 @@ type partialLengthReader struct {\n \tisPartial bool\n }\n \n-func (r *partialLengthReader) Read(p []byte) (n int, err os.Error) {\n+func (r *partialLengthReader) Read(p []byte) (n int, err error) {\n \tfor r.remaining == 0 {\n \t\tif !r.isPartial {\n-\t\t\treturn 0, os.EOF\n+\t\t\treturn 0, io.EOF\n \t\t}\n \t\tr.remaining, r.isPartial, err = readLength(r.r)\n \t\tif err != nil {\n@@ -86,7 +85,7 @@ func (r *partialLengthReader) Read(p []byte) (n int, err os.Error) {\n \n \tn, err = r.r.Read(p[:int(toRead)])\n \tr.remaining -= int64(n)\n-\tif n < int(toRead) && err == os.EOF {\n+\tif n < int(toRead) && err == io.EOF {\n \t\terr = io.ErrUnexpectedEOF\n \t}\n \treturn\n@@ -99,7 +98,7 @@ type partialLengthWriter struct {\n \tlengthByte [1]byte\n }\n \n-func (w *partialLengthWriter) Write(p []byte) (n int, err os.Error) {\n+func (w *partialLengthWriter) Write(p []byte) (n int, err error) {\n \tfor len(p) > 0 {\n \t\tfor power := uint(14); power < 32; power-- {\n \t\t\tl := 1 << power\n@@ -123,7 +122,7 @@ func (w *partialLengthWriter) Write(p []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (w *partialLengthWriter) Close() os.Error {\n+func (w *partialLengthWriter) Close() error {\n \tw.lengthByte[0] = 0\n \t_, err := w.w.Write(w.lengthByte[:])\n \tif err != nil {\n@@ -139,31 +138,31 @@ type spanReader struct {\n \tn int64\n }\n \n-func (l *spanReader) Read(p []byte) (n int, err os.Error) {\n+func (l *spanReader) Read(p []byte) (n int, err error) {\n \tif l.n <= 0 {\n-\t\treturn 0, os.EOF\n+\t\treturn 0, io.EOF\n \t}\n \tif int64(len(p)) > l.n {\n \t\tp = p[0:l.n]\n \t}\n \tn, err = l.r.Read(p)\n \tl.n -= int64(n)\n-\tif l.n > 0 && err == os.EOF {\n+\tif l.n > 0 && err == io.EOF {\n \t\terr = io.ErrUnexpectedEOF\n \t}\n \treturn\n }\n \n // readHeader parses a packet header and returns an io.Reader which will return\n // the contents of the packet. See RFC 4880, section 4.2.\n-func readHeader(r io.Reader) (tag packetType, length int64, contents io.Reader, err os.Error) {\n+func readHeader(r io.Reader) (tag packetType, length int64, contents io.Reader, err error) {\n \tvar buf [4]byte\n \t_, err = io.ReadFull(r, buf[:1])\n \tif err != nil {\n \t\treturn\n \t}\n \tif buf[0]&0x80 == 0 {\n-\t\terr = error.StructuralError(\"tag byte does not have MSB set\")\n+\t\terr = error_.StructuralError(\"tag byte does not have MSB set\")\n \t\treturn\n \t}\n \tif buf[0]&0x40 == 0 {\n@@ -209,7 +208,7 @@ func readHeader(r io.Reader) (tag packetType, length int64, contents io.Reader,\n \n // serializeHeader writes an OpenPGP packet header to w. See RFC 4880, section\n // 4.2.\n-func serializeHeader(w io.Writer, ptype packetType, length int) (err os.Error) {\n+func serializeHeader(w io.Writer, ptype packetType, length int) (err error) {\n \tvar buf [6]byte\n \tvar n int\n \n@@ -238,7 +237,7 @@ func serializeHeader(w io.Writer, ptype packetType, length int) (err os.Error) {\n // serializeStreamHeader writes an OpenPGP packet header to w where the\n // length of the packet is unknown. It returns a io.WriteCloser which can be\n // used to write the contents of the packet. See RFC 4880, section 4.2.\n-func serializeStreamHeader(w io.WriteCloser, ptype packetType) (out io.WriteCloser, err os.Error) {\n+func serializeStreamHeader(w io.WriteCloser, ptype packetType) (out io.WriteCloser, err error) {\n \tvar buf [1]byte\n \tbuf[0] = 0x80 | 0x40 | byte(ptype)\n \t_, err = w.Write(buf[:])\n@@ -252,19 +251,19 @@ func serializeStreamHeader(w io.WriteCloser, ptype packetType) (out io.WriteClos\n // Packet represents an OpenPGP packet. Users are expected to try casting\n // instances of this interface to specific packet types.\n type Packet interface {\n-\tparse(io.Reader) os.Error\n+\tparse(io.Reader) error\n }\n \n // consumeAll reads from the given Reader until error, returning the number of\n // bytes read.\n-func consumeAll(r io.Reader) (n int64, err os.Error) {\n+func consumeAll(r io.Reader) (n int64, err error) {\n \tvar m int\n \tvar buf [1024]byte\n \n \tfor {\n \t\tm, err = r.Read(buf[:])\n \t\tn += int64(m)\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\terr = nil\n \t\t\treturn\n \t\t}\n@@ -298,7 +297,7 @@ const (\n \n // Read reads a single OpenPGP packet from the given io.Reader. If there is an\n // error parsing a packet, the whole packet is consumed from the input.\n-func Read(r io.Reader) (p Packet, err os.Error) {\n+func Read(r io.Reader) (p Packet, err error) {\n \ttag, _, contents, err := readHeader(r)\n \tif err != nil {\n \t\treturn\n@@ -338,7 +337,7 @@ func Read(r io.Reader) (p Packet, err os.Error) {\n \t\tse.MDC = true\n \t\tp = se\n \tdefault:\n-\t\terr = error.UnknownPacketTypeError(tag)\n+\t\terr = error_.UnknownPacketTypeError(tag)\n \t}\n \tif p != nil {\n \t\terr = p.parse(contents)\n@@ -447,7 +446,7 @@ func (cipher CipherFunction) new(key []byte) (block cipher.Block) {\n // readMPI reads a big integer from r. The bit length returned is the bit\n // length that was specified in r. This is preserved so that the integer can be\n // reserialized exactly.\n-func readMPI(r io.Reader) (mpi []byte, bitLength uint16, err os.Error) {\n+func readMPI(r io.Reader) (mpi []byte, bitLength uint16, err error) {\n \tvar buf [2]byte\n \t_, err = readFull(r, buf[0:])\n \tif err != nil {\n@@ -469,7 +468,7 @@ func mpiLength(n *big.Int) (mpiLengthInBytes int) {\n }\n \n // writeMPI serializes a big integer to w.\n-func writeMPI(w io.Writer, bitLength uint16, mpiBytes []byte) (err os.Error) {\n+func writeMPI(w io.Writer, bitLength uint16, mpiBytes []byte) (err error) {\n \t_, err = w.Write([]byte{byte(bitLength >> 8), byte(bitLength)})\n \tif err == nil {\n \t\t_, err = w.Write(mpiBytes)\n@@ -478,6 +477,6 @@ func writeMPI(w io.Writer, bitLength uint16, mpiBytes []byte) (err os.Error) {\n }\n \n // writeBig serializes a *big.Int to w.\n-func writeBig(w io.Writer, i *big.Int) os.Error {\n+func writeBig(w io.Writer, i *big.Int) error {\n \treturn writeMPI(w, uint16(i.BitLen()), i.Bytes())\n }"}, {"sha": "53266413c86c0f2ce28d53d5ce1cec6c0d0a2a98", "filename": "libgo/go/crypto/openpgp/packet/packet_test.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,12 +6,11 @@ package packet\n \n import (\n \t\"bytes\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"encoding/hex\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -49,7 +48,7 @@ var readLengthTests = []struct {\n \thexInput  string\n \tlength    int64\n \tisPartial bool\n-\terr       os.Error\n+\terr       error\n }{\n \t{\"\", 0, false, io.ErrUnexpectedEOF},\n \t{\"1f\", 31, false, nil},\n@@ -87,7 +86,7 @@ func TestReadLength(t *testing.T) {\n \n var partialLengthReaderTests = []struct {\n \thexInput  string\n-\terr       os.Error\n+\terr       error\n \thexOutput string\n }{\n \t{\"e0\", io.ErrUnexpectedEOF, \"\"},\n@@ -153,14 +152,14 @@ func TestReadHeader(t *testing.T) {\n \tfor i, test := range readHeaderTests {\n \t\ttag, length, contents, err := readHeader(readerFromHex(test.hexInput))\n \t\tif test.structuralError {\n-\t\t\tif _, ok := err.(error.StructuralError); ok {\n+\t\t\tif _, ok := err.(error_.StructuralError); ok {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tt.Errorf(\"%d: expected StructuralError, got:%s\", i, err)\n \t\t\tcontinue\n \t\t}\n \t\tif err != nil {\n-\t\t\tif len(test.hexInput) == 0 && err == os.EOF {\n+\t\t\tif len(test.hexInput) == 0 && err == io.EOF {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tif !test.unexpectedEOF || err != io.ErrUnexpectedEOF {"}, {"sha": "742ac51e6e385243e4ee4d9a56ef4623719bd9be", "filename": "libgo/go/crypto/openpgp/packet/private_key.go", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,13 +10,12 @@ import (\n \t\"crypto/cipher\"\n \t\"crypto/dsa\"\n \t\"crypto/openpgp/elgamal\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"crypto/openpgp/s2k\"\n \t\"crypto/rsa\"\n \t\"crypto/sha1\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -40,7 +39,7 @@ func NewRSAPrivateKey(currentTimeSecs uint32, priv *rsa.PrivateKey, isSubkey boo\n \treturn pk\n }\n \n-func (pk *PrivateKey) parse(r io.Reader) (err os.Error) {\n+func (pk *PrivateKey) parse(r io.Reader) (err error) {\n \terr = (&pk.PublicKey).parse(r)\n \tif err != nil {\n \t\treturn\n@@ -72,13 +71,13 @@ func (pk *PrivateKey) parse(r io.Reader) (err os.Error) {\n \t\t\tpk.sha1Checksum = true\n \t\t}\n \tdefault:\n-\t\treturn error.UnsupportedError(\"deprecated s2k function in private key\")\n+\t\treturn error_.UnsupportedError(\"deprecated s2k function in private key\")\n \t}\n \n \tif pk.Encrypted {\n \t\tblockSize := pk.cipher.blockSize()\n \t\tif blockSize == 0 {\n-\t\t\treturn error.UnsupportedError(\"unsupported cipher in private key: \" + strconv.Itoa(int(pk.cipher)))\n+\t\t\treturn error_.UnsupportedError(\"unsupported cipher in private key: \" + strconv.Itoa(int(pk.cipher)))\n \t\t}\n \t\tpk.iv = make([]byte, blockSize)\n \t\t_, err = readFull(r, pk.iv)\n@@ -111,7 +110,7 @@ func mod64kHash(d []byte) uint16 {\n \treturn h\n }\n \n-func (pk *PrivateKey) Serialize(w io.Writer) (err os.Error) {\n+func (pk *PrivateKey) Serialize(w io.Writer) (err error) {\n \t// TODO(agl): support encrypted private keys\n \tbuf := bytes.NewBuffer(nil)\n \terr = pk.PublicKey.serializeWithoutHeaders(buf)\n@@ -126,7 +125,7 @@ func (pk *PrivateKey) Serialize(w io.Writer) (err os.Error) {\n \tcase *rsa.PrivateKey:\n \t\terr = serializeRSAPrivateKey(privateKeyBuf, priv)\n \tdefault:\n-\t\terr = error.InvalidArgumentError(\"non-RSA private key\")\n+\t\terr = error_.InvalidArgumentError(\"non-RSA private key\")\n \t}\n \tif err != nil {\n \t\treturn\n@@ -160,7 +159,7 @@ func (pk *PrivateKey) Serialize(w io.Writer) (err os.Error) {\n \treturn\n }\n \n-func serializeRSAPrivateKey(w io.Writer, priv *rsa.PrivateKey) os.Error {\n+func serializeRSAPrivateKey(w io.Writer, priv *rsa.PrivateKey) error {\n \terr := writeBig(w, priv.D)\n \tif err != nil {\n \t\treturn err\n@@ -177,7 +176,7 @@ func serializeRSAPrivateKey(w io.Writer, priv *rsa.PrivateKey) os.Error {\n }\n \n // Decrypt decrypts an encrypted private key using a passphrase.\n-func (pk *PrivateKey) Decrypt(passphrase []byte) os.Error {\n+func (pk *PrivateKey) Decrypt(passphrase []byte) error {\n \tif !pk.Encrypted {\n \t\treturn nil\n \t}\n@@ -192,34 +191,34 @@ func (pk *PrivateKey) Decrypt(passphrase []byte) os.Error {\n \n \tif pk.sha1Checksum {\n \t\tif len(data) < sha1.Size {\n-\t\t\treturn error.StructuralError(\"truncated private key data\")\n+\t\t\treturn error_.StructuralError(\"truncated private key data\")\n \t\t}\n \t\th := sha1.New()\n \t\th.Write(data[:len(data)-sha1.Size])\n \t\tsum := h.Sum()\n \t\tif !bytes.Equal(sum, data[len(data)-sha1.Size:]) {\n-\t\t\treturn error.StructuralError(\"private key checksum failure\")\n+\t\t\treturn error_.StructuralError(\"private key checksum failure\")\n \t\t}\n \t\tdata = data[:len(data)-sha1.Size]\n \t} else {\n \t\tif len(data) < 2 {\n-\t\t\treturn error.StructuralError(\"truncated private key data\")\n+\t\t\treturn error_.StructuralError(\"truncated private key data\")\n \t\t}\n \t\tvar sum uint16\n \t\tfor i := 0; i < len(data)-2; i++ {\n \t\t\tsum += uint16(data[i])\n \t\t}\n \t\tif data[len(data)-2] != uint8(sum>>8) ||\n \t\t\tdata[len(data)-1] != uint8(sum) {\n-\t\t\treturn error.StructuralError(\"private key checksum failure\")\n+\t\t\treturn error_.StructuralError(\"private key checksum failure\")\n \t\t}\n \t\tdata = data[:len(data)-2]\n \t}\n \n \treturn pk.parsePrivateKey(data)\n }\n \n-func (pk *PrivateKey) parsePrivateKey(data []byte) (err os.Error) {\n+func (pk *PrivateKey) parsePrivateKey(data []byte) (err error) {\n \tswitch pk.PublicKey.PubKeyAlgo {\n \tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoRSAEncryptOnly:\n \t\treturn pk.parseRSAPrivateKey(data)\n@@ -231,7 +230,7 @@ func (pk *PrivateKey) parsePrivateKey(data []byte) (err os.Error) {\n \tpanic(\"impossible\")\n }\n \n-func (pk *PrivateKey) parseRSAPrivateKey(data []byte) (err os.Error) {\n+func (pk *PrivateKey) parseRSAPrivateKey(data []byte) (err error) {\n \trsaPub := pk.PublicKey.PublicKey.(*rsa.PublicKey)\n \trsaPriv := new(rsa.PrivateKey)\n \trsaPriv.PublicKey = *rsaPub\n@@ -262,7 +261,7 @@ func (pk *PrivateKey) parseRSAPrivateKey(data []byte) (err os.Error) {\n \treturn nil\n }\n \n-func (pk *PrivateKey) parseDSAPrivateKey(data []byte) (err os.Error) {\n+func (pk *PrivateKey) parseDSAPrivateKey(data []byte) (err error) {\n \tdsaPub := pk.PublicKey.PublicKey.(*dsa.PublicKey)\n \tdsaPriv := new(dsa.PrivateKey)\n \tdsaPriv.PublicKey = *dsaPub\n@@ -281,7 +280,7 @@ func (pk *PrivateKey) parseDSAPrivateKey(data []byte) (err os.Error) {\n \treturn nil\n }\n \n-func (pk *PrivateKey) parseElGamalPrivateKey(data []byte) (err os.Error) {\n+func (pk *PrivateKey) parseElGamalPrivateKey(data []byte) (err error) {\n \tpub := pk.PublicKey.PublicKey.(*elgamal.PublicKey)\n \tpriv := new(elgamal.PrivateKey)\n \tpriv.PublicKey = *pub"}, {"sha": "af0bc2273f892efb67547bfbc25947f3cafc43e3", "filename": "libgo/go/crypto/openpgp/packet/public_key.go", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,14 +8,13 @@ import (\n \t\"big\"\n \t\"crypto/dsa\"\n \t\"crypto/openpgp/elgamal\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"crypto/rsa\"\n \t\"crypto/sha1\"\n \t\"encoding/binary\"\n \t\"fmt\"\n \t\"hash\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -53,15 +52,15 @@ func NewRSAPublicKey(creationTimeSecs uint32, pub *rsa.PublicKey, isSubkey bool)\n \treturn pk\n }\n \n-func (pk *PublicKey) parse(r io.Reader) (err os.Error) {\n+func (pk *PublicKey) parse(r io.Reader) (err error) {\n \t// RFC 4880, section 5.5.2\n \tvar buf [6]byte\n \t_, err = readFull(r, buf[:])\n \tif err != nil {\n \t\treturn\n \t}\n \tif buf[0] != 4 {\n-\t\treturn error.UnsupportedError(\"public key version\")\n+\t\treturn error_.UnsupportedError(\"public key version\")\n \t}\n \tpk.CreationTime = uint32(buf[1])<<24 | uint32(buf[2])<<16 | uint32(buf[3])<<8 | uint32(buf[4])\n \tpk.PubKeyAlgo = PublicKeyAlgorithm(buf[5])\n@@ -73,7 +72,7 @@ func (pk *PublicKey) parse(r io.Reader) (err os.Error) {\n \tcase PubKeyAlgoElGamal:\n \t\terr = pk.parseElGamal(r)\n \tdefault:\n-\t\terr = error.UnsupportedError(\"public key type: \" + strconv.Itoa(int(pk.PubKeyAlgo)))\n+\t\terr = error_.UnsupportedError(\"public key type: \" + strconv.Itoa(int(pk.PubKeyAlgo)))\n \t}\n \tif err != nil {\n \t\treturn\n@@ -94,7 +93,7 @@ func (pk *PublicKey) setFingerPrintAndKeyId() {\n \n // parseRSA parses RSA public key material from the given Reader. See RFC 4880,\n // section 5.5.2.\n-func (pk *PublicKey) parseRSA(r io.Reader) (err os.Error) {\n+func (pk *PublicKey) parseRSA(r io.Reader) (err error) {\n \tpk.n.bytes, pk.n.bitLength, err = readMPI(r)\n \tif err != nil {\n \t\treturn\n@@ -105,7 +104,7 @@ func (pk *PublicKey) parseRSA(r io.Reader) (err os.Error) {\n \t}\n \n \tif len(pk.e.bytes) > 3 {\n-\t\terr = error.UnsupportedError(\"large public exponent\")\n+\t\terr = error_.UnsupportedError(\"large public exponent\")\n \t\treturn\n \t}\n \trsa := &rsa.PublicKey{\n@@ -122,7 +121,7 @@ func (pk *PublicKey) parseRSA(r io.Reader) (err os.Error) {\n \n // parseDSA parses DSA public key material from the given Reader. See RFC 4880,\n // section 5.5.2.\n-func (pk *PublicKey) parseDSA(r io.Reader) (err os.Error) {\n+func (pk *PublicKey) parseDSA(r io.Reader) (err error) {\n \tpk.p.bytes, pk.p.bitLength, err = readMPI(r)\n \tif err != nil {\n \t\treturn\n@@ -151,7 +150,7 @@ func (pk *PublicKey) parseDSA(r io.Reader) (err os.Error) {\n \n // parseElGamal parses ElGamal public key material from the given Reader. See\n // RFC 4880, section 5.5.2.\n-func (pk *PublicKey) parseElGamal(r io.Reader) (err os.Error) {\n+func (pk *PublicKey) parseElGamal(r io.Reader) (err error) {\n \tpk.p.bytes, pk.p.bitLength, err = readMPI(r)\n \tif err != nil {\n \t\treturn\n@@ -199,7 +198,7 @@ func (pk *PublicKey) SerializeSignaturePrefix(h hash.Hash) {\n \treturn\n }\n \n-func (pk *PublicKey) Serialize(w io.Writer) (err os.Error) {\n+func (pk *PublicKey) Serialize(w io.Writer) (err error) {\n \tlength := 6 // 6 byte header\n \n \tswitch pk.PubKeyAlgo {\n@@ -232,7 +231,7 @@ func (pk *PublicKey) Serialize(w io.Writer) (err os.Error) {\n \n // serializeWithoutHeaders marshals the PublicKey to w in the form of an\n // OpenPGP public key packet, not including the packet header.\n-func (pk *PublicKey) serializeWithoutHeaders(w io.Writer) (err os.Error) {\n+func (pk *PublicKey) serializeWithoutHeaders(w io.Writer) (err error) {\n \tvar buf [6]byte\n \tbuf[0] = 4\n \tbuf[1] = byte(pk.CreationTime >> 24)\n@@ -254,7 +253,7 @@ func (pk *PublicKey) serializeWithoutHeaders(w io.Writer) (err os.Error) {\n \tcase PubKeyAlgoElGamal:\n \t\treturn writeMPIs(w, pk.p, pk.g, pk.y)\n \t}\n-\treturn error.InvalidArgumentError(\"bad public-key algorithm\")\n+\treturn error_.InvalidArgumentError(\"bad public-key algorithm\")\n }\n \n // CanSign returns true iff this public key can generate signatures\n@@ -264,34 +263,34 @@ func (pk *PublicKey) CanSign() bool {\n \n // VerifySignature returns nil iff sig is a valid signature, made by this\n // public key, of the data hashed into signed. signed is mutated by this call.\n-func (pk *PublicKey) VerifySignature(signed hash.Hash, sig *Signature) (err os.Error) {\n+func (pk *PublicKey) VerifySignature(signed hash.Hash, sig *Signature) (err error) {\n \tif !pk.CanSign() {\n-\t\treturn error.InvalidArgumentError(\"public key cannot generate signatures\")\n+\t\treturn error_.InvalidArgumentError(\"public key cannot generate signatures\")\n \t}\n \n \tsigned.Write(sig.HashSuffix)\n \thashBytes := signed.Sum()\n \n \tif hashBytes[0] != sig.HashTag[0] || hashBytes[1] != sig.HashTag[1] {\n-\t\treturn error.SignatureError(\"hash tag doesn't match\")\n+\t\treturn error_.SignatureError(\"hash tag doesn't match\")\n \t}\n \n \tif pk.PubKeyAlgo != sig.PubKeyAlgo {\n-\t\treturn error.InvalidArgumentError(\"public key and signature use different algorithms\")\n+\t\treturn error_.InvalidArgumentError(\"public key and signature use different algorithms\")\n \t}\n \n \tswitch pk.PubKeyAlgo {\n \tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n \t\trsaPublicKey, _ := pk.PublicKey.(*rsa.PublicKey)\n \t\terr = rsa.VerifyPKCS1v15(rsaPublicKey, sig.Hash, hashBytes, sig.RSASignature.bytes)\n \t\tif err != nil {\n-\t\t\treturn error.SignatureError(\"RSA verification failure\")\n+\t\t\treturn error_.SignatureError(\"RSA verification failure\")\n \t\t}\n \t\treturn nil\n \tcase PubKeyAlgoDSA:\n \t\tdsaPublicKey, _ := pk.PublicKey.(*dsa.PublicKey)\n \t\tif !dsa.Verify(dsaPublicKey, hashBytes, new(big.Int).SetBytes(sig.DSASigR.bytes), new(big.Int).SetBytes(sig.DSASigS.bytes)) {\n-\t\t\treturn error.SignatureError(\"DSA verification failure\")\n+\t\t\treturn error_.SignatureError(\"DSA verification failure\")\n \t\t}\n \t\treturn nil\n \tdefault:\n@@ -302,10 +301,10 @@ func (pk *PublicKey) VerifySignature(signed hash.Hash, sig *Signature) (err os.E\n \n // keySignatureHash returns a Hash of the message that needs to be signed for\n // pk to assert a subkey relationship to signed.\n-func keySignatureHash(pk, signed *PublicKey, sig *Signature) (h hash.Hash, err os.Error) {\n+func keySignatureHash(pk, signed *PublicKey, sig *Signature) (h hash.Hash, err error) {\n \th = sig.Hash.New()\n \tif h == nil {\n-\t\treturn nil, error.UnsupportedError(\"hash function\")\n+\t\treturn nil, error_.UnsupportedError(\"hash function\")\n \t}\n \n \t// RFC 4880, section 5.2.4\n@@ -318,7 +317,7 @@ func keySignatureHash(pk, signed *PublicKey, sig *Signature) (h hash.Hash, err o\n \n // VerifyKeySignature returns nil iff sig is a valid signature, made by this\n // public key, of signed.\n-func (pk *PublicKey) VerifyKeySignature(signed *PublicKey, sig *Signature) (err os.Error) {\n+func (pk *PublicKey) VerifyKeySignature(signed *PublicKey, sig *Signature) (err error) {\n \th, err := keySignatureHash(pk, signed, sig)\n \tif err != nil {\n \t\treturn err\n@@ -328,10 +327,10 @@ func (pk *PublicKey) VerifyKeySignature(signed *PublicKey, sig *Signature) (err\n \n // userIdSignatureHash returns a Hash of the message that needs to be signed\n // to assert that pk is a valid key for id.\n-func userIdSignatureHash(id string, pk *PublicKey, sig *Signature) (h hash.Hash, err os.Error) {\n+func userIdSignatureHash(id string, pk *PublicKey, sig *Signature) (h hash.Hash, err error) {\n \th = sig.Hash.New()\n \tif h == nil {\n-\t\treturn nil, error.UnsupportedError(\"hash function\")\n+\t\treturn nil, error_.UnsupportedError(\"hash function\")\n \t}\n \n \t// RFC 4880, section 5.2.4\n@@ -352,7 +351,7 @@ func userIdSignatureHash(id string, pk *PublicKey, sig *Signature) (h hash.Hash,\n \n // VerifyUserIdSignature returns nil iff sig is a valid signature, made by this\n // public key, of id.\n-func (pk *PublicKey) VerifyUserIdSignature(id string, sig *Signature) (err os.Error) {\n+func (pk *PublicKey) VerifyUserIdSignature(id string, sig *Signature) (err error) {\n \th, err := userIdSignatureHash(id, pk, sig)\n \tif err != nil {\n \t\treturn err\n@@ -382,7 +381,7 @@ type parsedMPI struct {\n \n // writeMPIs is a utility function for serializing several big integers to the\n // given Writer.\n-func writeMPIs(w io.Writer, mpis ...parsedMPI) (err os.Error) {\n+func writeMPIs(w io.Writer, mpis ...parsedMPI) (err error) {\n \tfor _, mpi := range mpis {\n \t\terr = writeMPI(w, mpi.bitLength, mpi.bytes)\n \t\tif err != nil {"}, {"sha": "e3d733cb02192e24c194c9e18a8a9ecb9b390825", "filename": "libgo/go/crypto/openpgp/packet/reader.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Freader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,9 +5,8 @@\n package packet\n \n import (\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"io\"\n-\t\"os\"\n )\n \n // Reader reads packets from an io.Reader and allows packets to be 'unread' so\n@@ -19,7 +18,7 @@ type Reader struct {\n \n // Next returns the most recently unread Packet, or reads another packet from\n // the top-most io.Reader. Unknown packet types are skipped.\n-func (r *Reader) Next() (p Packet, err os.Error) {\n+func (r *Reader) Next() (p Packet, err error) {\n \tif len(r.q) > 0 {\n \t\tp = r.q[len(r.q)-1]\n \t\tr.q = r.q[:len(r.q)-1]\n@@ -31,16 +30,16 @@ func (r *Reader) Next() (p Packet, err os.Error) {\n \t\tif err == nil {\n \t\t\treturn\n \t\t}\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\tr.readers = r.readers[:len(r.readers)-1]\n \t\t\tcontinue\n \t\t}\n-\t\tif _, ok := err.(error.UnknownPacketTypeError); !ok {\n+\t\tif _, ok := err.(error_.UnknownPacketTypeError); !ok {\n \t\t\treturn nil, err\n \t\t}\n \t}\n \n-\treturn nil, os.EOF\n+\treturn nil, io.EOF\n }\n \n // Push causes the Reader to start reading from a new io.Reader. When an EOF"}, {"sha": "4ebb906cad72e02bc41e725959099846f5777f17", "filename": "libgo/go/crypto/openpgp/packet/signature.go", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,14 +7,13 @@ package packet\n import (\n \t\"crypto\"\n \t\"crypto/dsa\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"crypto/openpgp/s2k\"\n \t\"crypto/rand\"\n \t\"crypto/rsa\"\n \t\"encoding/binary\"\n \t\"hash\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -53,15 +52,15 @@ type Signature struct {\n \toutSubpackets []outputSubpacket\n }\n \n-func (sig *Signature) parse(r io.Reader) (err os.Error) {\n+func (sig *Signature) parse(r io.Reader) (err error) {\n \t// RFC 4880, section 5.2.3\n \tvar buf [5]byte\n \t_, err = readFull(r, buf[:1])\n \tif err != nil {\n \t\treturn\n \t}\n \tif buf[0] != 4 {\n-\t\terr = error.UnsupportedError(\"signature packet version \" + strconv.Itoa(int(buf[0])))\n+\t\terr = error_.UnsupportedError(\"signature packet version \" + strconv.Itoa(int(buf[0])))\n \t\treturn\n \t}\n \n@@ -74,14 +73,14 @@ func (sig *Signature) parse(r io.Reader) (err os.Error) {\n \tswitch sig.PubKeyAlgo {\n \tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoDSA:\n \tdefault:\n-\t\terr = error.UnsupportedError(\"public key algorithm \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n+\t\terr = error_.UnsupportedError(\"public key algorithm \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n \t\treturn\n \t}\n \n \tvar ok bool\n \tsig.Hash, ok = s2k.HashIdToHash(buf[2])\n \tif !ok {\n-\t\treturn error.UnsupportedError(\"hash function \" + strconv.Itoa(int(buf[2])))\n+\t\treturn error_.UnsupportedError(\"hash function \" + strconv.Itoa(int(buf[2])))\n \t}\n \n \thashedSubpacketsLength := int(buf[3])<<8 | int(buf[4])\n@@ -144,7 +143,7 @@ func (sig *Signature) parse(r io.Reader) (err os.Error) {\n \n // parseSignatureSubpackets parses subpackets of the main signature packet. See\n // RFC 4880, section 5.2.3.1.\n-func parseSignatureSubpackets(sig *Signature, subpackets []byte, isHashed bool) (err os.Error) {\n+func parseSignatureSubpackets(sig *Signature, subpackets []byte, isHashed bool) (err error) {\n \tfor len(subpackets) > 0 {\n \t\tsubpackets, err = parseSignatureSubpacket(sig, subpackets, isHashed)\n \t\tif err != nil {\n@@ -153,7 +152,7 @@ func parseSignatureSubpackets(sig *Signature, subpackets []byte, isHashed bool)\n \t}\n \n \tif sig.CreationTime == 0 {\n-\t\terr = error.StructuralError(\"no creation time in signature\")\n+\t\terr = error_.StructuralError(\"no creation time in signature\")\n \t}\n \n \treturn\n@@ -174,7 +173,7 @@ const (\n )\n \n // parseSignatureSubpacket parses a single subpacket. len(subpacket) is >= 1.\n-func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (rest []byte, err os.Error) {\n+func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (rest []byte, err error) {\n \t// RFC 4880, section 5.2.3.1\n \tvar (\n \t\tlength     uint32\n@@ -207,7 +206,7 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \trest = subpacket[length:]\n \tsubpacket = subpacket[:length]\n \tif len(subpacket) == 0 {\n-\t\terr = error.StructuralError(\"zero length signature subpacket\")\n+\t\terr = error_.StructuralError(\"zero length signature subpacket\")\n \t\treturn\n \t}\n \tpacketType = signatureSubpacketType(subpacket[0] & 0x7f)\n@@ -217,11 +216,11 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \tswitch packetType {\n \tcase creationTimeSubpacket:\n \t\tif !isHashed {\n-\t\t\terr = error.StructuralError(\"signature creation time in non-hashed area\")\n+\t\t\terr = error_.StructuralError(\"signature creation time in non-hashed area\")\n \t\t\treturn\n \t\t}\n \t\tif len(subpacket) != 4 {\n-\t\t\terr = error.StructuralError(\"signature creation time not four bytes\")\n+\t\t\terr = error_.StructuralError(\"signature creation time not four bytes\")\n \t\t\treturn\n \t\t}\n \t\tsig.CreationTime = binary.BigEndian.Uint32(subpacket)\n@@ -231,7 +230,7 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \t\t\treturn\n \t\t}\n \t\tif len(subpacket) != 4 {\n-\t\t\terr = error.StructuralError(\"expiration subpacket with bad length\")\n+\t\t\terr = error_.StructuralError(\"expiration subpacket with bad length\")\n \t\t\treturn\n \t\t}\n \t\tsig.SigLifetimeSecs = new(uint32)\n@@ -242,7 +241,7 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \t\t\treturn\n \t\t}\n \t\tif len(subpacket) != 4 {\n-\t\t\terr = error.StructuralError(\"key expiration subpacket with bad length\")\n+\t\t\terr = error_.StructuralError(\"key expiration subpacket with bad length\")\n \t\t\treturn\n \t\t}\n \t\tsig.KeyLifetimeSecs = new(uint32)\n@@ -257,7 +256,7 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \tcase issuerSubpacket:\n \t\t// Issuer, section 5.2.3.5\n \t\tif len(subpacket) != 8 {\n-\t\t\terr = error.StructuralError(\"issuer subpacket with bad length\")\n+\t\t\terr = error_.StructuralError(\"issuer subpacket with bad length\")\n \t\t\treturn\n \t\t}\n \t\tsig.IssuerKeyId = new(uint64)\n@@ -282,7 +281,7 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \t\t\treturn\n \t\t}\n \t\tif len(subpacket) != 1 {\n-\t\t\terr = error.StructuralError(\"primary user id subpacket with bad length\")\n+\t\t\terr = error_.StructuralError(\"primary user id subpacket with bad length\")\n \t\t\treturn\n \t\t}\n \t\tsig.IsPrimaryId = new(bool)\n@@ -295,7 +294,7 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \t\t\treturn\n \t\t}\n \t\tif len(subpacket) == 0 {\n-\t\t\terr = error.StructuralError(\"empty key flags subpacket\")\n+\t\t\terr = error_.StructuralError(\"empty key flags subpacket\")\n \t\t\treturn\n \t\t}\n \t\tsig.FlagsValid = true\n@@ -314,14 +313,14 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \n \tdefault:\n \t\tif isCritical {\n-\t\t\terr = error.UnsupportedError(\"unknown critical signature subpacket type \" + strconv.Itoa(int(packetType)))\n+\t\t\terr = error_.UnsupportedError(\"unknown critical signature subpacket type \" + strconv.Itoa(int(packetType)))\n \t\t\treturn\n \t\t}\n \t}\n \treturn\n \n Truncated:\n-\terr = error.StructuralError(\"signature subpacket truncated\")\n+\terr = error_.StructuralError(\"signature subpacket truncated\")\n \treturn\n }\n \n@@ -384,7 +383,7 @@ func serializeSubpackets(to []byte, subpackets []outputSubpacket, hashed bool) {\n }\n \n // buildHashSuffix constructs the HashSuffix member of sig in preparation for signing.\n-func (sig *Signature) buildHashSuffix() (err os.Error) {\n+func (sig *Signature) buildHashSuffix() (err error) {\n \thashedSubpacketsLen := subpacketsLength(sig.outSubpackets, true)\n \n \tvar ok bool\n@@ -396,7 +395,7 @@ func (sig *Signature) buildHashSuffix() (err os.Error) {\n \tsig.HashSuffix[3], ok = s2k.HashToHashId(sig.Hash)\n \tif !ok {\n \t\tsig.HashSuffix = nil\n-\t\treturn error.InvalidArgumentError(\"hash cannot be represented in OpenPGP: \" + strconv.Itoa(int(sig.Hash)))\n+\t\treturn error_.InvalidArgumentError(\"hash cannot be represented in OpenPGP: \" + strconv.Itoa(int(sig.Hash)))\n \t}\n \tsig.HashSuffix[4] = byte(hashedSubpacketsLen >> 8)\n \tsig.HashSuffix[5] = byte(hashedSubpacketsLen)\n@@ -411,7 +410,7 @@ func (sig *Signature) buildHashSuffix() (err os.Error) {\n \treturn\n }\n \n-func (sig *Signature) signPrepareHash(h hash.Hash) (digest []byte, err os.Error) {\n+func (sig *Signature) signPrepareHash(h hash.Hash) (digest []byte, err error) {\n \terr = sig.buildHashSuffix()\n \tif err != nil {\n \t\treturn\n@@ -426,7 +425,7 @@ func (sig *Signature) signPrepareHash(h hash.Hash) (digest []byte, err os.Error)\n // Sign signs a message with a private key. The hash, h, must contain\n // the hash of the message to be signed and will be mutated by this function.\n // On success, the signature is stored in sig. Call Serialize to write it out.\n-func (sig *Signature) Sign(h hash.Hash, priv *PrivateKey) (err os.Error) {\n+func (sig *Signature) Sign(h hash.Hash, priv *PrivateKey) (err error) {\n \tsig.outSubpackets = sig.buildSubpackets()\n \tdigest, err := sig.signPrepareHash(h)\n \tif err != nil {\n@@ -446,7 +445,7 @@ func (sig *Signature) Sign(h hash.Hash, priv *PrivateKey) (err os.Error) {\n \t\t\tsig.DSASigS.bitLength = uint16(8 * len(sig.DSASigS.bytes))\n \t\t}\n \tdefault:\n-\t\terr = error.UnsupportedError(\"public key algorithm: \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n+\t\terr = error_.UnsupportedError(\"public key algorithm: \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n \t}\n \n \treturn\n@@ -455,7 +454,7 @@ func (sig *Signature) Sign(h hash.Hash, priv *PrivateKey) (err os.Error) {\n // SignUserId computes a signature from priv, asserting that pub is a valid\n // key for the identity id.  On success, the signature is stored in sig. Call\n // Serialize to write it out.\n-func (sig *Signature) SignUserId(id string, pub *PublicKey, priv *PrivateKey) os.Error {\n+func (sig *Signature) SignUserId(id string, pub *PublicKey, priv *PrivateKey) error {\n \th, err := userIdSignatureHash(id, pub, sig)\n \tif err != nil {\n \t\treturn nil\n@@ -465,7 +464,7 @@ func (sig *Signature) SignUserId(id string, pub *PublicKey, priv *PrivateKey) os\n \n // SignKey computes a signature from priv, asserting that pub is a subkey.  On\n // success, the signature is stored in sig. Call Serialize to write it out.\n-func (sig *Signature) SignKey(pub *PublicKey, priv *PrivateKey) os.Error {\n+func (sig *Signature) SignKey(pub *PublicKey, priv *PrivateKey) error {\n \th, err := keySignatureHash(&priv.PublicKey, pub, sig)\n \tif err != nil {\n \t\treturn err\n@@ -474,12 +473,12 @@ func (sig *Signature) SignKey(pub *PublicKey, priv *PrivateKey) os.Error {\n }\n \n // Serialize marshals sig to w. SignRSA or SignDSA must have been called first.\n-func (sig *Signature) Serialize(w io.Writer) (err os.Error) {\n+func (sig *Signature) Serialize(w io.Writer) (err error) {\n \tif len(sig.outSubpackets) == 0 {\n \t\tsig.outSubpackets = sig.rawSubpackets\n \t}\n \tif sig.RSASignature.bytes == nil && sig.DSASigR.bytes == nil {\n-\t\treturn error.InvalidArgumentError(\"Signature: need to call SignRSA or SignDSA before Serialize\")\n+\t\treturn error_.InvalidArgumentError(\"Signature: need to call SignRSA or SignDSA before Serialize\")\n \t}\n \n \tsigLength := 0"}, {"sha": "76d5151379a9684c1935e492bef0e17b53219583", "filename": "libgo/go/crypto/openpgp/packet/symmetric_key_encrypted.go", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,10 +7,9 @@ package packet\n import (\n \t\"bytes\"\n \t\"crypto/cipher\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"crypto/openpgp/s2k\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -30,20 +29,20 @@ type SymmetricKeyEncrypted struct {\n \n const symmetricKeyEncryptedVersion = 4\n \n-func (ske *SymmetricKeyEncrypted) parse(r io.Reader) (err os.Error) {\n+func (ske *SymmetricKeyEncrypted) parse(r io.Reader) (err error) {\n \t// RFC 4880, section 5.3.\n \tvar buf [2]byte\n \t_, err = readFull(r, buf[:])\n \tif err != nil {\n \t\treturn\n \t}\n \tif buf[0] != symmetricKeyEncryptedVersion {\n-\t\treturn error.UnsupportedError(\"SymmetricKeyEncrypted version\")\n+\t\treturn error_.UnsupportedError(\"SymmetricKeyEncrypted version\")\n \t}\n \tske.CipherFunc = CipherFunction(buf[1])\n \n \tif ske.CipherFunc.KeySize() == 0 {\n-\t\treturn error.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(buf[1])))\n+\t\treturn error_.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(buf[1])))\n \t}\n \n \tske.s2k, err = s2k.Parse(r)\n@@ -61,7 +60,7 @@ func (ske *SymmetricKeyEncrypted) parse(r io.Reader) (err os.Error) {\n \terr = nil\n \tif n != 0 {\n \t\tif n == maxSessionKeySizeInBytes {\n-\t\t\treturn error.UnsupportedError(\"oversized encrypted session key\")\n+\t\t\treturn error_.UnsupportedError(\"oversized encrypted session key\")\n \t\t}\n \t\tske.encryptedKey = encryptedKey[:n]\n \t}\n@@ -73,7 +72,7 @@ func (ske *SymmetricKeyEncrypted) parse(r io.Reader) (err os.Error) {\n \n // Decrypt attempts to decrypt an encrypted session key. If it returns nil,\n // ske.Key will contain the session key.\n-func (ske *SymmetricKeyEncrypted) Decrypt(passphrase []byte) os.Error {\n+func (ske *SymmetricKeyEncrypted) Decrypt(passphrase []byte) error {\n \tif !ske.Encrypted {\n \t\treturn nil\n \t}\n@@ -90,13 +89,13 @@ func (ske *SymmetricKeyEncrypted) Decrypt(passphrase []byte) os.Error {\n \t\tc.XORKeyStream(ske.encryptedKey, ske.encryptedKey)\n \t\tske.CipherFunc = CipherFunction(ske.encryptedKey[0])\n \t\tif ske.CipherFunc.blockSize() == 0 {\n-\t\t\treturn error.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(ske.CipherFunc)))\n+\t\t\treturn error_.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(ske.CipherFunc)))\n \t\t}\n \t\tske.CipherFunc = CipherFunction(ske.encryptedKey[0])\n \t\tske.Key = ske.encryptedKey[1:]\n \t\tif len(ske.Key)%ske.CipherFunc.blockSize() != 0 {\n \t\t\tske.Key = nil\n-\t\t\treturn error.StructuralError(\"length of decrypted key not a multiple of block size\")\n+\t\t\treturn error_.StructuralError(\"length of decrypted key not a multiple of block size\")\n \t\t}\n \t}\n \n@@ -108,10 +107,10 @@ func (ske *SymmetricKeyEncrypted) Decrypt(passphrase []byte) os.Error {\n // packet contains a random session key, encrypted by a key derived from the\n // given passphrase. The session key is returned and must be passed to\n // SerializeSymmetricallyEncrypted.\n-func SerializeSymmetricKeyEncrypted(w io.Writer, rand io.Reader, passphrase []byte, cipherFunc CipherFunction) (key []byte, err os.Error) {\n+func SerializeSymmetricKeyEncrypted(w io.Writer, rand io.Reader, passphrase []byte, cipherFunc CipherFunction) (key []byte, err error) {\n \tkeySize := cipherFunc.KeySize()\n \tif keySize == 0 {\n-\t\treturn nil, error.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(cipherFunc)))\n+\t\treturn nil, error_.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(cipherFunc)))\n \t}\n \n \ts2kBuf := new(bytes.Buffer)"}, {"sha": "87690f0b7bfca6e391ef9573259f3bb56fab5582", "filename": "libgo/go/crypto/openpgp/packet/symmetric_key_encrypted_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,8 +8,8 @@ import (\n \t\"bytes\"\n \t\"crypto/rand\"\n \t\"encoding/hex\"\n+\t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -48,7 +48,7 @@ func TestSymmetricKeyEncrypted(t *testing.T) {\n \t}\n \n \tcontents, err := ioutil.ReadAll(r)\n-\tif err != nil && err != os.EOF {\n+\tif err != nil && err != io.EOF {\n \t\tt.Error(err)\n \t\treturn\n \t}"}, {"sha": "8225db6d2f6411a066179b84420089838e2e6e48", "filename": "libgo/go/crypto/openpgp/packet/symmetrically_encrypted.go", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,13 +6,12 @@ package packet\n \n import (\n \t\"crypto/cipher\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"crypto/rand\"\n \t\"crypto/sha1\"\n \t\"crypto/subtle\"\n \t\"hash\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -27,7 +26,7 @@ type SymmetricallyEncrypted struct {\n \n const symmetricallyEncryptedVersion = 1\n \n-func (se *SymmetricallyEncrypted) parse(r io.Reader) os.Error {\n+func (se *SymmetricallyEncrypted) parse(r io.Reader) error {\n \tif se.MDC {\n \t\t// See RFC 4880, section 5.13.\n \t\tvar buf [1]byte\n@@ -36,7 +35,7 @@ func (se *SymmetricallyEncrypted) parse(r io.Reader) os.Error {\n \t\t\treturn err\n \t\t}\n \t\tif buf[0] != symmetricallyEncryptedVersion {\n-\t\t\treturn error.UnsupportedError(\"unknown SymmetricallyEncrypted version\")\n+\t\t\treturn error_.UnsupportedError(\"unknown SymmetricallyEncrypted version\")\n \t\t}\n \t}\n \tse.contents = r\n@@ -46,13 +45,13 @@ func (se *SymmetricallyEncrypted) parse(r io.Reader) os.Error {\n // Decrypt returns a ReadCloser, from which the decrypted contents of the\n // packet can be read. An incorrect key can, with high probability, be detected\n // immediately and this will result in a KeyIncorrect error being returned.\n-func (se *SymmetricallyEncrypted) Decrypt(c CipherFunction, key []byte) (io.ReadCloser, os.Error) {\n+func (se *SymmetricallyEncrypted) Decrypt(c CipherFunction, key []byte) (io.ReadCloser, error) {\n \tkeySize := c.KeySize()\n \tif keySize == 0 {\n-\t\treturn nil, error.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(c)))\n+\t\treturn nil, error_.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(c)))\n \t}\n \tif len(key) != keySize {\n-\t\treturn nil, error.InvalidArgumentError(\"SymmetricallyEncrypted: incorrect key length\")\n+\t\treturn nil, error_.InvalidArgumentError(\"SymmetricallyEncrypted: incorrect key length\")\n \t}\n \n \tif se.prefix == nil {\n@@ -62,7 +61,7 @@ func (se *SymmetricallyEncrypted) Decrypt(c CipherFunction, key []byte) (io.Read\n \t\t\treturn nil, err\n \t\t}\n \t} else if len(se.prefix) != c.blockSize()+2 {\n-\t\treturn nil, error.InvalidArgumentError(\"can't try ciphers with different block lengths\")\n+\t\treturn nil, error_.InvalidArgumentError(\"can't try ciphers with different block lengths\")\n \t}\n \n \tocfbResync := cipher.OCFBResync\n@@ -73,7 +72,7 @@ func (se *SymmetricallyEncrypted) Decrypt(c CipherFunction, key []byte) (io.Read\n \n \ts := cipher.NewOCFBDecrypter(c.new(key), se.prefix, ocfbResync)\n \tif s == nil {\n-\t\treturn nil, error.KeyIncorrectError\n+\t\treturn nil, error_.KeyIncorrectError\n \t}\n \n \tplaintext := cipher.StreamReader{S: s, R: se.contents}\n@@ -94,11 +93,11 @@ type seReader struct {\n \tin io.Reader\n }\n \n-func (ser seReader) Read(buf []byte) (int, os.Error) {\n+func (ser seReader) Read(buf []byte) (int, error) {\n \treturn ser.in.Read(buf)\n }\n \n-func (ser seReader) Close() os.Error {\n+func (ser seReader) Close() error {\n \treturn nil\n }\n \n@@ -118,13 +117,13 @@ type seMDCReader struct {\n \teof         bool\n }\n \n-func (ser *seMDCReader) Read(buf []byte) (n int, err os.Error) {\n+func (ser *seMDCReader) Read(buf []byte) (n int, err error) {\n \tif ser.error {\n \t\terr = io.ErrUnexpectedEOF\n \t\treturn\n \t}\n \tif ser.eof {\n-\t\terr = os.EOF\n+\t\terr = io.EOF\n \t\treturn\n \t}\n \n@@ -133,7 +132,7 @@ func (ser *seMDCReader) Read(buf []byte) (n int, err os.Error) {\n \tfor ser.trailerUsed < mdcTrailerSize {\n \t\tn, err = ser.in.Read(ser.trailer[ser.trailerUsed:])\n \t\tser.trailerUsed += n\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\tif ser.trailerUsed != mdcTrailerSize {\n \t\t\t\tn = 0\n \t\t\t\terr = io.ErrUnexpectedEOF\n@@ -161,7 +160,7 @@ func (ser *seMDCReader) Read(buf []byte) (n int, err os.Error) {\n \t\tcopy(ser.trailer[mdcTrailerSize-n:], ser.scratch[:])\n \t\tif n < len(buf) {\n \t\t\tser.eof = true\n-\t\t\terr = os.EOF\n+\t\t\terr = io.EOF\n \t\t}\n \t\treturn\n \t}\n@@ -171,7 +170,7 @@ func (ser *seMDCReader) Read(buf []byte) (n int, err os.Error) {\n \tser.h.Write(buf[:n])\n \tcopy(ser.trailer[:], buf[n:])\n \n-\tif err == os.EOF {\n+\tif err == io.EOF {\n \t\tser.eof = true\n \t}\n \treturn\n@@ -180,31 +179,31 @@ func (ser *seMDCReader) Read(buf []byte) (n int, err os.Error) {\n // This is a new-format packet tag byte for a type 19 (MDC) packet.\n const mdcPacketTagByte = byte(0x80) | 0x40 | 19\n \n-func (ser *seMDCReader) Close() os.Error {\n+func (ser *seMDCReader) Close() error {\n \tif ser.error {\n-\t\treturn error.SignatureError(\"error during reading\")\n+\t\treturn error_.SignatureError(\"error during reading\")\n \t}\n \n \tfor !ser.eof {\n \t\t// We haven't seen EOF so we need to read to the end\n \t\tvar buf [1024]byte\n \t\t_, err := ser.Read(buf[:])\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\tbreak\n \t\t}\n \t\tif err != nil {\n-\t\t\treturn error.SignatureError(\"error during reading\")\n+\t\t\treturn error_.SignatureError(\"error during reading\")\n \t\t}\n \t}\n \n \tif ser.trailer[0] != mdcPacketTagByte || ser.trailer[1] != sha1.Size {\n-\t\treturn error.SignatureError(\"MDC packet not found\")\n+\t\treturn error_.SignatureError(\"MDC packet not found\")\n \t}\n \tser.h.Write(ser.trailer[:2])\n \n \tfinal := ser.h.Sum()\n \tif subtle.ConstantTimeCompare(final, ser.trailer[2:]) != 1 {\n-\t\treturn error.SignatureError(\"hash mismatch\")\n+\t\treturn error_.SignatureError(\"hash mismatch\")\n \t}\n \treturn nil\n }\n@@ -217,12 +216,12 @@ type seMDCWriter struct {\n \th hash.Hash\n }\n \n-func (w *seMDCWriter) Write(buf []byte) (n int, err os.Error) {\n+func (w *seMDCWriter) Write(buf []byte) (n int, err error) {\n \tw.h.Write(buf)\n \treturn w.w.Write(buf)\n }\n \n-func (w *seMDCWriter) Close() (err os.Error) {\n+func (w *seMDCWriter) Close() (err error) {\n \tvar buf [mdcTrailerSize]byte\n \n \tbuf[0] = mdcPacketTagByte\n@@ -243,20 +242,20 @@ type noOpCloser struct {\n \tw io.Writer\n }\n \n-func (c noOpCloser) Write(data []byte) (n int, err os.Error) {\n+func (c noOpCloser) Write(data []byte) (n int, err error) {\n \treturn c.w.Write(data)\n }\n \n-func (c noOpCloser) Close() os.Error {\n+func (c noOpCloser) Close() error {\n \treturn nil\n }\n \n // SerializeSymmetricallyEncrypted serializes a symmetrically encrypted packet\n // to w and returns a WriteCloser to which the to-be-encrypted packets can be\n // written.\n-func SerializeSymmetricallyEncrypted(w io.Writer, c CipherFunction, key []byte) (contents io.WriteCloser, err os.Error) {\n+func SerializeSymmetricallyEncrypted(w io.Writer, c CipherFunction, key []byte) (contents io.WriteCloser, err error) {\n \tif c.KeySize() != len(key) {\n-\t\treturn nil, error.InvalidArgumentError(\"SymmetricallyEncrypted.Serialize: bad key length\")\n+\t\treturn nil, error_.InvalidArgumentError(\"SymmetricallyEncrypted.Serialize: bad key length\")\n \t}\n \twriteCloser := noOpCloser{w}\n \tciphertext, err := serializeStreamHeader(writeCloser, packetTypeSymmetricallyEncryptedMDC)"}, {"sha": "8eee9713983e38bca19daf10498bfe92cb369f07", "filename": "libgo/go/crypto/openpgp/packet/symmetrically_encrypted_test.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,12 +6,11 @@ package packet\n \n import (\n \t\"bytes\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"crypto/sha1\"\n \t\"encoding/hex\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -21,7 +20,7 @@ type testReader struct {\n \tstride int\n }\n \n-func (t *testReader) Read(buf []byte) (n int, err os.Error) {\n+func (t *testReader) Read(buf []byte) (n int, err error) {\n \tn = t.stride\n \tif n > len(t.data) {\n \t\tn = len(t.data)\n@@ -32,7 +31,7 @@ func (t *testReader) Read(buf []byte) (n int, err os.Error) {\n \tcopy(buf, t.data)\n \tt.data = t.data[n:]\n \tif len(t.data) == 0 {\n-\t\terr = os.EOF\n+\t\terr = io.EOF\n \t}\n \treturn\n }\n@@ -71,7 +70,7 @@ func testMDCReader(t *testing.T) {\n \terr = mdcReader.Close()\n \tif err == nil {\n \t\tt.Error(\"corruption: no error\")\n-\t} else if _, ok := err.(*error.SignatureError); !ok {\n+\t} else if _, ok := err.(*error_.SignatureError); !ok {\n \t\tt.Errorf(\"corruption: expected SignatureError, got: %s\", err)\n \t}\n }"}, {"sha": "d6bea7d4acc076fa2fc8753af6724e0fb0095e2f", "filename": "libgo/go/crypto/openpgp/packet/userid.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package packet\n import (\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"strings\"\n )\n \n@@ -65,7 +64,7 @@ func NewUserId(name, comment, email string) *UserId {\n \treturn uid\n }\n \n-func (uid *UserId) parse(r io.Reader) (err os.Error) {\n+func (uid *UserId) parse(r io.Reader) (err error) {\n \t// RFC 4880, section 5.11\n \tb, err := ioutil.ReadAll(r)\n \tif err != nil {\n@@ -78,7 +77,7 @@ func (uid *UserId) parse(r io.Reader) (err os.Error) {\n \n // Serialize marshals uid to w in the form of an OpenPGP packet, including\n // header.\n-func (uid *UserId) Serialize(w io.Writer) os.Error {\n+func (uid *UserId) Serialize(w io.Writer) error {\n \terr := serializeHeader(w, packetTypeUserId, len(uid.Id))\n \tif err != nil {\n \t\treturn err"}, {"sha": "76fb1ead9f01a0d22792d306dc3049c6ba348723", "filename": "libgo/go/crypto/openpgp/read.go", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,27 +8,26 @@ package openpgp\n import (\n \t\"crypto\"\n \t\"crypto/openpgp/armor\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"crypto/openpgp/packet\"\n \t_ \"crypto/sha256\"\n \t\"hash\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n // SignatureType is the armor type for a PGP signature.\n var SignatureType = \"PGP SIGNATURE\"\n \n // readArmored reads an armored block with the given type.\n-func readArmored(r io.Reader, expectedType string) (body io.Reader, err os.Error) {\n+func readArmored(r io.Reader, expectedType string) (body io.Reader, err error) {\n \tblock, err := armor.Decode(r)\n \tif err != nil {\n \t\treturn\n \t}\n \n \tif block.Type != expectedType {\n-\t\treturn nil, error.InvalidArgumentError(\"expected '\" + expectedType + \"', got: \" + block.Type)\n+\t\treturn nil, error_.InvalidArgumentError(\"expected '\" + expectedType + \"', got: \" + block.Type)\n \t}\n \n \treturn block.Body, nil\n@@ -56,7 +55,7 @@ type MessageDetails struct {\n \t// been consumed. Once EOF has been seen, the following fields are\n \t// valid. (An authentication code failure is reported as a\n \t// SignatureError error when reading from UnverifiedBody.)\n-\tSignatureError os.Error          // nil if the signature is good.\n+\tSignatureError error             // nil if the signature is good.\n \tSignature      *packet.Signature // the signature packet itself.\n \n \tdecrypted io.ReadCloser\n@@ -69,7 +68,7 @@ type MessageDetails struct {\n // passphrase to try. If the decrypted private key or given passphrase isn't\n // correct, the function will be called again, forever. Any error returned will\n // be passed up.\n-type PromptFunction func(keys []Key, symmetric bool) ([]byte, os.Error)\n+type PromptFunction func(keys []Key, symmetric bool) ([]byte, error)\n \n // A keyEnvelopePair is used to store a private key with the envelope that\n // contains a symmetric key, encrypted with that key.\n@@ -81,7 +80,7 @@ type keyEnvelopePair struct {\n // ReadMessage parses an OpenPGP message that may be signed and/or encrypted.\n // The given KeyRing should contain both public keys (for signature\n // verification) and, possibly encrypted, private keys for decrypting.\n-func ReadMessage(r io.Reader, keyring KeyRing, prompt PromptFunction) (md *MessageDetails, err os.Error) {\n+func ReadMessage(r io.Reader, keyring KeyRing, prompt PromptFunction) (md *MessageDetails, err error) {\n \tvar p packet.Packet\n \n \tvar symKeys []*packet.SymmetricKeyEncrypted\n@@ -131,7 +130,7 @@ ParsePackets:\n \t\tcase *packet.Compressed, *packet.LiteralData, *packet.OnePassSignature:\n \t\t\t// This message isn't encrypted.\n \t\t\tif len(symKeys) != 0 || len(pubKeys) != 0 {\n-\t\t\t\treturn nil, error.StructuralError(\"key material not followed by encrypted message\")\n+\t\t\t\treturn nil, error_.StructuralError(\"key material not followed by encrypted message\")\n \t\t\t}\n \t\t\tpackets.Unread(p)\n \t\t\treturn readSignedMessage(packets, nil, keyring)\n@@ -162,7 +161,7 @@ FindKey:\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t\tdecrypted, err = se.Decrypt(pk.encryptedKey.CipherFunc, pk.encryptedKey.Key)\n-\t\t\t\tif err != nil && err != error.KeyIncorrectError {\n+\t\t\t\tif err != nil && err != error_.KeyIncorrectError {\n \t\t\t\t\treturn nil, err\n \t\t\t\t}\n \t\t\t\tif decrypted != nil {\n@@ -180,11 +179,11 @@ FindKey:\n \t\t}\n \n \t\tif len(candidates) == 0 && len(symKeys) == 0 {\n-\t\t\treturn nil, error.KeyIncorrectError\n+\t\t\treturn nil, error_.KeyIncorrectError\n \t\t}\n \n \t\tif prompt == nil {\n-\t\t\treturn nil, error.KeyIncorrectError\n+\t\t\treturn nil, error_.KeyIncorrectError\n \t\t}\n \n \t\tpassphrase, err := prompt(candidates, len(symKeys) != 0)\n@@ -198,7 +197,7 @@ FindKey:\n \t\t\t\terr = s.Decrypt(passphrase)\n \t\t\t\tif err == nil && !s.Encrypted {\n \t\t\t\t\tdecrypted, err = se.Decrypt(s.CipherFunc, s.Key)\n-\t\t\t\t\tif err != nil && err != error.KeyIncorrectError {\n+\t\t\t\t\tif err != nil && err != error_.KeyIncorrectError {\n \t\t\t\t\t\treturn nil, err\n \t\t\t\t\t}\n \t\t\t\t\tif decrypted != nil {\n@@ -218,7 +217,7 @@ FindKey:\n // readSignedMessage reads a possibly signed message if mdin is non-zero then\n // that structure is updated and returned. Otherwise a fresh MessageDetails is\n // used.\n-func readSignedMessage(packets *packet.Reader, mdin *MessageDetails, keyring KeyRing) (md *MessageDetails, err os.Error) {\n+func readSignedMessage(packets *packet.Reader, mdin *MessageDetails, keyring KeyRing) (md *MessageDetails, err error) {\n \tif mdin == nil {\n \t\tmdin = new(MessageDetails)\n \t}\n@@ -238,7 +237,7 @@ FindLiteralData:\n \t\t\tpackets.Push(p.Body)\n \t\tcase *packet.OnePassSignature:\n \t\t\tif !p.IsLast {\n-\t\t\t\treturn nil, error.UnsupportedError(\"nested signatures\")\n+\t\t\t\treturn nil, error_.UnsupportedError(\"nested signatures\")\n \t\t\t}\n \n \t\t\th, wrappedHash, err = hashForSignature(p.Hash, p.SigType)\n@@ -279,10 +278,10 @@ FindLiteralData:\n // should be preprocessed (i.e. to normalize line endings). Thus this function\n // returns two hashes. The second should be used to hash the message itself and\n // performs any needed preprocessing.\n-func hashForSignature(hashId crypto.Hash, sigType packet.SignatureType) (hash.Hash, hash.Hash, os.Error) {\n+func hashForSignature(hashId crypto.Hash, sigType packet.SignatureType) (hash.Hash, hash.Hash, error) {\n \th := hashId.New()\n \tif h == nil {\n-\t\treturn nil, nil, error.UnsupportedError(\"hash not available: \" + strconv.Itoa(int(hashId)))\n+\t\treturn nil, nil, error_.UnsupportedError(\"hash not available: \" + strconv.Itoa(int(hashId)))\n \t}\n \n \tswitch sigType {\n@@ -292,7 +291,7 @@ func hashForSignature(hashId crypto.Hash, sigType packet.SignatureType) (hash.Ha\n \t\treturn h, NewCanonicalTextHash(h), nil\n \t}\n \n-\treturn nil, nil, error.UnsupportedError(\"unsupported signature type: \" + strconv.Itoa(int(sigType)))\n+\treturn nil, nil, error_.UnsupportedError(\"unsupported signature type: \" + strconv.Itoa(int(sigType)))\n }\n \n // checkReader wraps an io.Reader from a LiteralData packet. When it sees EOF\n@@ -302,9 +301,9 @@ type checkReader struct {\n \tmd *MessageDetails\n }\n \n-func (cr checkReader) Read(buf []byte) (n int, err os.Error) {\n+func (cr checkReader) Read(buf []byte) (n int, err error) {\n \tn, err = cr.md.LiteralData.Body.Read(buf)\n-\tif err == os.EOF {\n+\tif err == io.EOF {\n \t\tmdcErr := cr.md.decrypted.Close()\n \t\tif mdcErr != nil {\n \t\t\terr = mdcErr\n@@ -322,10 +321,10 @@ type signatureCheckReader struct {\n \tmd             *MessageDetails\n }\n \n-func (scr *signatureCheckReader) Read(buf []byte) (n int, err os.Error) {\n+func (scr *signatureCheckReader) Read(buf []byte) (n int, err error) {\n \tn, err = scr.md.LiteralData.Body.Read(buf)\n \tscr.wrappedHash.Write(buf[:n])\n-\tif err == os.EOF {\n+\tif err == io.EOF {\n \t\tvar p packet.Packet\n \t\tp, scr.md.SignatureError = scr.packets.Next()\n \t\tif scr.md.SignatureError != nil {\n@@ -334,7 +333,7 @@ func (scr *signatureCheckReader) Read(buf []byte) (n int, err os.Error) {\n \n \t\tvar ok bool\n \t\tif scr.md.Signature, ok = p.(*packet.Signature); !ok {\n-\t\t\tscr.md.SignatureError = error.StructuralError(\"LiteralData not followed by Signature\")\n+\t\t\tscr.md.SignatureError = error_.StructuralError(\"LiteralData not followed by Signature\")\n \t\t\treturn\n \t\t}\n \n@@ -356,24 +355,24 @@ func (scr *signatureCheckReader) Read(buf []byte) (n int, err os.Error) {\n // CheckDetachedSignature takes a signed file and a detached signature and\n // returns the signer if the signature is valid. If the signer isn't know,\n // UnknownIssuerError is returned.\n-func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err os.Error) {\n+func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err error) {\n \tp, err := packet.Read(signature)\n \tif err != nil {\n \t\treturn\n \t}\n \n \tsig, ok := p.(*packet.Signature)\n \tif !ok {\n-\t\treturn nil, error.StructuralError(\"non signature packet found\")\n+\t\treturn nil, error_.StructuralError(\"non signature packet found\")\n \t}\n \n \tif sig.IssuerKeyId == nil {\n-\t\treturn nil, error.StructuralError(\"signature doesn't have an issuer\")\n+\t\treturn nil, error_.StructuralError(\"signature doesn't have an issuer\")\n \t}\n \n \tkeys := keyring.KeysById(*sig.IssuerKeyId)\n \tif len(keys) == 0 {\n-\t\treturn nil, error.UnknownIssuerError\n+\t\treturn nil, error_.UnknownIssuerError\n \t}\n \n \th, wrappedHash, err := hashForSignature(sig.Hash, sig.SigType)\n@@ -382,7 +381,7 @@ func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signe\n \t}\n \n \t_, err = io.Copy(wrappedHash, signed)\n-\tif err != nil && err != os.EOF {\n+\tif err != nil && err != io.EOF {\n \t\treturn\n \t}\n \n@@ -400,12 +399,12 @@ func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signe\n \t\treturn\n \t}\n \n-\treturn nil, error.UnknownIssuerError\n+\treturn nil, error_.UnknownIssuerError\n }\n \n // CheckArmoredDetachedSignature performs the same actions as\n // CheckDetachedSignature but expects the signature to be armored.\n-func CheckArmoredDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err os.Error) {\n+func CheckArmoredDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err error) {\n \tbody, err := readArmored(signature, SignatureType)\n \tif err != nil {\n \t\treturn"}, {"sha": "e8a6bf5992e820ff0838316623aededa0415f82a", "filename": "libgo/go/crypto/openpgp/read_test.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,11 +6,10 @@ package openpgp\n \n import (\n \t\"bytes\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"encoding/hex\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -149,21 +148,21 @@ func TestSignedEncryptedMessage(t *testing.T) {\n \tfor i, test := range signedEncryptedMessageTests {\n \t\texpected := \"Signed and encrypted message\\n\"\n \t\tkring, _ := ReadKeyRing(readerFromHex(test.keyRingHex))\n-\t\tprompt := func(keys []Key, symmetric bool) ([]byte, os.Error) {\n+\t\tprompt := func(keys []Key, symmetric bool) ([]byte, error) {\n \t\t\tif symmetric {\n \t\t\t\tt.Errorf(\"prompt: message was marked as symmetrically encrypted\")\n-\t\t\t\treturn nil, error.KeyIncorrectError\n+\t\t\t\treturn nil, error_.KeyIncorrectError\n \t\t\t}\n \n \t\t\tif len(keys) == 0 {\n \t\t\t\tt.Error(\"prompt: no keys requested\")\n-\t\t\t\treturn nil, error.KeyIncorrectError\n+\t\t\t\treturn nil, error_.KeyIncorrectError\n \t\t\t}\n \n \t\t\terr := keys[0].PrivateKey.Decrypt([]byte(\"passphrase\"))\n \t\t\tif err != nil {\n \t\t\t\tt.Errorf(\"prompt: error decrypting key: %s\", err)\n-\t\t\t\treturn nil, error.KeyIncorrectError\n+\t\t\t\treturn nil, error_.KeyIncorrectError\n \t\t\t}\n \n \t\t\treturn nil, nil\n@@ -215,7 +214,7 @@ func TestUnspecifiedRecipient(t *testing.T) {\n func TestSymmetricallyEncrypted(t *testing.T) {\n \texpected := \"Symmetrically encrypted.\\n\"\n \n-\tprompt := func(keys []Key, symmetric bool) ([]byte, os.Error) {\n+\tprompt := func(keys []Key, symmetric bool) ([]byte, error) {\n \t\tif len(keys) != 0 {\n \t\t\tt.Errorf(\"prompt: len(keys) = %d (want 0)\", len(keys))\n \t\t}\n@@ -287,7 +286,7 @@ func TestReadingArmoredPrivateKey(t *testing.T) {\n \n func TestNoArmoredData(t *testing.T) {\n \t_, err := ReadArmoredKeyRing(bytes.NewBufferString(\"foo\"))\n-\tif _, ok := err.(error.InvalidArgumentError); !ok {\n+\tif _, ok := err.(error_.InvalidArgumentError); !ok {\n \t\tt.Errorf(\"error was not an InvalidArgumentError: %s\", err)\n \t}\n }"}, {"sha": "2a753db16bd8c6431f84387ee73f3efa23e1dec4", "filename": "libgo/go/crypto/openpgp/s2k/s2k.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,10 +8,9 @@ package s2k\n \n import (\n \t\"crypto\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"hash\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -76,7 +75,7 @@ func Iterated(out []byte, h hash.Hash, in []byte, salt []byte, count int) {\n \n // Parse reads a binary specification for a string-to-key transformation from r\n // and returns a function which performs that transform.\n-func Parse(r io.Reader) (f func(out, in []byte), err os.Error) {\n+func Parse(r io.Reader) (f func(out, in []byte), err error) {\n \tvar buf [9]byte\n \n \t_, err = io.ReadFull(r, buf[:2])\n@@ -86,11 +85,11 @@ func Parse(r io.Reader) (f func(out, in []byte), err os.Error) {\n \n \thash, ok := HashIdToHash(buf[1])\n \tif !ok {\n-\t\treturn nil, error.UnsupportedError(\"hash for S2K function: \" + strconv.Itoa(int(buf[1])))\n+\t\treturn nil, error_.UnsupportedError(\"hash for S2K function: \" + strconv.Itoa(int(buf[1])))\n \t}\n \th := hash.New()\n \tif h == nil {\n-\t\treturn nil, error.UnsupportedError(\"hash not available: \" + strconv.Itoa(int(hash)))\n+\t\treturn nil, error_.UnsupportedError(\"hash not available: \" + strconv.Itoa(int(hash)))\n \t}\n \n \tswitch buf[0] {\n@@ -120,12 +119,12 @@ func Parse(r io.Reader) (f func(out, in []byte), err os.Error) {\n \t\treturn f, nil\n \t}\n \n-\treturn nil, error.UnsupportedError(\"S2K function\")\n+\treturn nil, error_.UnsupportedError(\"S2K function\")\n }\n \n // Serialize salts and stretches the given passphrase and writes the resulting\n // key into key. It also serializes an S2K descriptor to w.\n-func Serialize(w io.Writer, key []byte, rand io.Reader, passphrase []byte) os.Error {\n+func Serialize(w io.Writer, key []byte, rand io.Reader, passphrase []byte) error {\n \tvar buf [11]byte\n \tbuf[0] = 3 /* iterated and salted */\n \tbuf[1], _ = HashToHashId(crypto.SHA1)"}, {"sha": "6f3450c9cdbc016cbc4cc642f9566944db8138fa", "filename": "libgo/go/crypto/openpgp/write.go", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,45 +7,44 @@ package openpgp\n import (\n \t\"crypto\"\n \t\"crypto/openpgp/armor\"\n-\t\"crypto/openpgp/error\"\n+\terror_ \"crypto/openpgp/error\"\n \t\"crypto/openpgp/packet\"\n \t\"crypto/openpgp/s2k\"\n \t\"crypto/rand\"\n \t_ \"crypto/sha256\"\n \t\"hash\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n \t\"time\"\n )\n \n // DetachSign signs message with the private key from signer (which must\n // already have been decrypted) and writes the signature to w.\n-func DetachSign(w io.Writer, signer *Entity, message io.Reader) os.Error {\n+func DetachSign(w io.Writer, signer *Entity, message io.Reader) error {\n \treturn detachSign(w, signer, message, packet.SigTypeBinary)\n }\n \n // ArmoredDetachSign signs message with the private key from signer (which\n // must already have been decrypted) and writes an armored signature to w.\n-func ArmoredDetachSign(w io.Writer, signer *Entity, message io.Reader) (err os.Error) {\n+func ArmoredDetachSign(w io.Writer, signer *Entity, message io.Reader) (err error) {\n \treturn armoredDetachSign(w, signer, message, packet.SigTypeBinary)\n }\n \n // DetachSignText signs message (after canonicalising the line endings) with\n // the private key from signer (which must already have been decrypted) and\n // writes the signature to w.\n-func DetachSignText(w io.Writer, signer *Entity, message io.Reader) os.Error {\n+func DetachSignText(w io.Writer, signer *Entity, message io.Reader) error {\n \treturn detachSign(w, signer, message, packet.SigTypeText)\n }\n \n // ArmoredDetachSignText signs message (after canonicalising the line endings)\n // with the private key from signer (which must already have been decrypted)\n // and writes an armored signature to w.\n-func ArmoredDetachSignText(w io.Writer, signer *Entity, message io.Reader) os.Error {\n+func ArmoredDetachSignText(w io.Writer, signer *Entity, message io.Reader) error {\n \treturn armoredDetachSign(w, signer, message, packet.SigTypeText)\n }\n \n-func armoredDetachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.SignatureType) (err os.Error) {\n+func armoredDetachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.SignatureType) (err error) {\n \tout, err := armor.Encode(w, SignatureType, nil)\n \tif err != nil {\n \t\treturn\n@@ -57,12 +56,12 @@ func armoredDetachSign(w io.Writer, signer *Entity, message io.Reader, sigType p\n \treturn out.Close()\n }\n \n-func detachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.SignatureType) (err os.Error) {\n+func detachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.SignatureType) (err error) {\n \tif signer.PrivateKey == nil {\n-\t\treturn error.InvalidArgumentError(\"signing key doesn't have a private key\")\n+\t\treturn error_.InvalidArgumentError(\"signing key doesn't have a private key\")\n \t}\n \tif signer.PrivateKey.Encrypted {\n-\t\treturn error.InvalidArgumentError(\"signing key is encrypted\")\n+\t\treturn error_.InvalidArgumentError(\"signing key is encrypted\")\n \t}\n \n \tsig := new(packet.Signature)\n@@ -103,7 +102,7 @@ type FileHints struct {\n // SymmetricallyEncrypt acts like gpg -c: it encrypts a file with a passphrase.\n // The resulting WriteCloser must be closed after the contents of the file have\n // been written.\n-func SymmetricallyEncrypt(ciphertext io.Writer, passphrase []byte, hints *FileHints) (plaintext io.WriteCloser, err os.Error) {\n+func SymmetricallyEncrypt(ciphertext io.Writer, passphrase []byte, hints *FileHints) (plaintext io.WriteCloser, err error) {\n \tif hints == nil {\n \t\thints = &FileHints{}\n \t}\n@@ -148,12 +147,12 @@ func hashToHashId(h crypto.Hash) uint8 {\n // it. hints contains optional information, that is also encrypted, that aids\n // the recipients in processing the message. The resulting WriteCloser must\n // be closed after the contents of the file have been written.\n-func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHints) (plaintext io.WriteCloser, err os.Error) {\n+func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHints) (plaintext io.WriteCloser, err error) {\n \tvar signer *packet.PrivateKey\n \tif signed != nil {\n \t\tsigner = signed.signingKey().PrivateKey\n \t\tif signer == nil || signer.Encrypted {\n-\t\t\treturn nil, error.InvalidArgumentError(\"signing key must be decrypted\")\n+\t\t\treturn nil, error_.InvalidArgumentError(\"signing key must be decrypted\")\n \t\t}\n \t}\n \n@@ -180,7 +179,7 @@ func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHint\n \tfor i := range to {\n \t\tencryptKeys[i] = to[i].encryptionKey()\n \t\tif encryptKeys[i].PublicKey == nil {\n-\t\t\treturn nil, error.InvalidArgumentError(\"cannot encrypt a message to key id \" + strconv.Uitob64(to[i].PrimaryKey.KeyId, 16) + \" because it has no encryption keys\")\n+\t\t\treturn nil, error_.InvalidArgumentError(\"cannot encrypt a message to key id \" + strconv.Uitob64(to[i].PrimaryKey.KeyId, 16) + \" because it has no encryption keys\")\n \t\t}\n \n \t\tsig := to[i].primaryIdentity().SelfSignature\n@@ -198,7 +197,7 @@ func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHint\n \t}\n \n \tif len(candidateCiphers) == 0 || len(candidateHashes) == 0 {\n-\t\treturn nil, error.InvalidArgumentError(\"cannot encrypt because recipient set shares no common algorithms\")\n+\t\treturn nil, error_.InvalidArgumentError(\"cannot encrypt because recipient set shares no common algorithms\")\n \t}\n \n \tcipher := packet.CipherFunction(candidateCiphers[0])\n@@ -266,12 +265,12 @@ type signatureWriter struct {\n \tsigner        *packet.PrivateKey\n }\n \n-func (s signatureWriter) Write(data []byte) (int, os.Error) {\n+func (s signatureWriter) Write(data []byte) (int, error) {\n \ts.h.Write(data)\n \treturn s.literalData.Write(data)\n }\n \n-func (s signatureWriter) Close() os.Error {\n+func (s signatureWriter) Close() error {\n \tsig := &packet.Signature{\n \t\tSigType:      packet.SigTypeBinary,\n \t\tPubKeyAlgo:   s.signer.PubKeyAlgo,\n@@ -299,10 +298,10 @@ type noOpCloser struct {\n \tw io.Writer\n }\n \n-func (c noOpCloser) Write(data []byte) (n int, err os.Error) {\n+func (c noOpCloser) Write(data []byte) (n int, err error) {\n \treturn c.w.Write(data)\n }\n \n-func (c noOpCloser) Close() os.Error {\n+func (c noOpCloser) Close() error {\n \treturn nil\n }"}, {"sha": "3cadf4cc95a927174bc003452ab14967deaa0dd6", "filename": "libgo/go/crypto/openpgp/write_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package openpgp\n import (\n \t\"bytes\"\n \t\"crypto/rand\"\n-\t\"os\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"testing\"\n@@ -106,7 +105,7 @@ func TestSymmetricEncryption(t *testing.T) {\n \t\tt.Errorf(\"error closing plaintext writer: %s\", err)\n \t}\n \n-\tmd, err := ReadMessage(buf, nil, func(keys []Key, symmetric bool) ([]byte, os.Error) {\n+\tmd, err := ReadMessage(buf, nil, func(keys []Key, symmetric bool) ([]byte, error) {\n \t\treturn []byte(\"testing\"), nil\n \t})\n \tif err != nil {"}, {"sha": "59759038ee0743d4aa68d9273e2af8bbee506773", "filename": "libgo/go/crypto/rand/rand.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,10 +6,7 @@\n // pseudorandom number generator.\n package rand\n \n-import (\n-\t\"io\"\n-\t\"os\"\n-)\n+import \"io\"\n \n // Reader is a global, shared instance of a cryptographically\n // strong pseudo-random generator.\n@@ -18,4 +15,4 @@ import (\n var Reader io.Reader\n \n // Read is a helper function that calls Reader.Read.\n-func Read(b []byte) (n int, err os.Error) { return Reader.Read(b) }\n+func Read(b []byte) (n int, err error) { return Reader.Read(b) }"}, {"sha": "09442ad283078be060a59242d027de62c391f5b2", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -30,7 +30,7 @@ type devReader struct {\n \tmu   sync.Mutex\n }\n \n-func (r *devReader) Read(b []byte) (n int, err os.Error) {\n+func (r *devReader) Read(b []byte) (n int, err error) {\n \tr.mu.Lock()\n \tdefer r.mu.Unlock()\n \tif r.f == nil {\n@@ -71,7 +71,7 @@ type reader struct {\n \ttime, seed, dst, key [aes.BlockSize]byte\n }\n \n-func (r *reader) Read(b []byte) (n int, err os.Error) {\n+func (r *reader) Read(b []byte) (n int, err error) {\n \tr.mu.Lock()\n \tdefer r.mu.Unlock()\n \tn = len(b)"}, {"sha": "590571d23f643dc3ad9528002e42cd5cc39b5a08", "filename": "libgo/go/crypto/rand/rand_windows.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -23,7 +23,7 @@ type rngReader struct {\n \tmu   sync.Mutex\n }\n \n-func (r *rngReader) Read(b []byte) (n int, err os.Error) {\n+func (r *rngReader) Read(b []byte) (n int, err error) {\n \tr.mu.Lock()\n \tif r.prov == 0 {\n \t\tconst provType = syscall.PROV_RSA_FULL"}, {"sha": "322da4aed409fad75c729a714f17da2dec2d9452", "filename": "libgo/go/crypto/rand/util.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -12,7 +12,7 @@ import (\n \n // Prime returns a number, p, of the given size, such that p is prime\n // with high probability.\n-func Prime(rand io.Reader, bits int) (p *big.Int, err os.Error) {\n+func Prime(rand io.Reader, bits int) (p *big.Int, err error) {\n \tif bits < 1 {\n \t\terr = os.EINVAL\n \t}\n@@ -48,7 +48,7 @@ func Prime(rand io.Reader, bits int) (p *big.Int, err os.Error) {\n }\n \n // Int returns a uniform random value in [0, max).\n-func Int(rand io.Reader, max *big.Int) (n *big.Int, err os.Error) {\n+func Int(rand io.Reader, max *big.Int) (n *big.Int, err error) {\n \tk := (max.BitLen() + 7) / 8\n \n \t// b is the number of bits in the most significant byte of max."}, {"sha": "1bb278f74a454db37327eaf89b9a0f175d48a3d6", "filename": "libgo/go/crypto/rc4/rc4.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,10 +9,7 @@ package rc4\n // BUG(agl): RC4 is in common use but has design weaknesses that make\n // it a poor choice for new protocols.\n \n-import (\n-\t\"os\"\n-\t\"strconv\"\n-)\n+import \"strconv\"\n \n // A Cipher is an instance of RC4 using a particular key.\n type Cipher struct {\n@@ -22,13 +19,13 @@ type Cipher struct {\n \n type KeySizeError int\n \n-func (k KeySizeError) String() string {\n+func (k KeySizeError) Error() string {\n \treturn \"crypto/rc4: invalid key size \" + strconv.Itoa(int(k))\n }\n \n // NewCipher creates and returns a new Cipher.  The key argument should be the\n // RC4 key, at least 1 byte and at most 256 bytes.\n-func NewCipher(key []byte) (*Cipher, os.Error) {\n+func NewCipher(key []byte) (*Cipher, error) {\n \tk := len(key)\n \tif k < 1 || k > 256 {\n \t\treturn nil, KeySizeError(k)"}, {"sha": "6ccfe875f5567a54d3d9ca7ef0ef5f228f04e64f", "filename": "libgo/go/crypto/ripemd160/ripemd160.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -12,7 +12,6 @@ package ripemd160\n import (\n \t\"crypto\"\n \t\"hash\"\n-\t\"os\"\n )\n \n func init() {\n@@ -56,7 +55,7 @@ func New() hash.Hash {\n \n func (d *digest) Size() int { return Size }\n \n-func (d *digest) Write(p []byte) (nn int, err os.Error) {\n+func (d *digest) Write(p []byte) (nn int, err error) {\n \tnn = len(p)\n \td.tc += uint64(nn)\n \tif d.nx > 0 {"}, {"sha": "901539df174b78ed6ba796fdf1be6a1cb15209b2", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,8 +8,8 @@ import (\n \t\"big\"\n \t\"crypto\"\n \t\"crypto/subtle\"\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n )\n \n // This file implements encryption and decryption using PKCS#1 v1.5 padding.\n@@ -18,7 +18,7 @@ import (\n // The message must be no longer than the length of the public modulus minus 11 bytes.\n // WARNING: use of this function to encrypt plaintexts other than session keys\n // is dangerous. Use RSA OAEP in new protocols.\n-func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, err os.Error) {\n+func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, err error) {\n \tk := (pub.N.BitLen() + 7) / 8\n \tif len(msg) > k-11 {\n \t\terr = MessageTooLongError{}\n@@ -44,7 +44,7 @@ func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, er\n \n // DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\n // If rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\n-func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out []byte, err os.Error) {\n+func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out []byte, err error) {\n \tvalid, out, err := decryptPKCS1v15(rand, priv, ciphertext)\n \tif err == nil && valid == 0 {\n \t\terr = DecryptionError{}\n@@ -66,7 +66,7 @@ func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out [\n // See ``Chosen Ciphertext Attacks Against Protocols Based on the RSA\n // Encryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology\n // (Crypto '98),\n-func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) (err os.Error) {\n+func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) (err error) {\n \tk := (priv.N.BitLen() + 7) / 8\n \tif k-(len(key)+3+8) < 0 {\n \t\terr = DecryptionError{}\n@@ -83,7 +83,7 @@ func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []by\n \treturn\n }\n \n-func decryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (valid int, msg []byte, err os.Error) {\n+func decryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (valid int, msg []byte, err error) {\n \tk := (priv.N.BitLen() + 7) / 8\n \tif k < 11 {\n \t\terr = DecryptionError{}\n@@ -119,7 +119,7 @@ func decryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (valid\n }\n \n // nonZeroRandomBytes fills the given slice with non-zero random octets.\n-func nonZeroRandomBytes(s []byte, rand io.Reader) (err os.Error) {\n+func nonZeroRandomBytes(s []byte, rand io.Reader) (err error) {\n \t_, err = io.ReadFull(rand, s)\n \tif err != nil {\n \t\treturn\n@@ -161,7 +161,7 @@ var hashPrefixes = map[crypto.Hash][]byte{\n // SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.\n // Note that hashed must be the result of hashing the input message using the\n // given hash function.\n-func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) (s []byte, err os.Error) {\n+func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) (s []byte, err error) {\n \thashLen, prefix, err := pkcs1v15HashInfo(hash, len(hashed))\n \tif err != nil {\n \t\treturn\n@@ -194,7 +194,7 @@ func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []b\n // hashed is the result of hashing the input message using the given hash\n // function and sig is the signature. A valid signature is indicated by\n // returning a nil error.\n-func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) (err os.Error) {\n+func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) (err error) {\n \thashLen, prefix, err := pkcs1v15HashInfo(hash, len(hashed))\n \tif err != nil {\n \t\treturn\n@@ -229,14 +229,14 @@ func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte)\n \treturn nil\n }\n \n-func pkcs1v15HashInfo(hash crypto.Hash, inLen int) (hashLen int, prefix []byte, err os.Error) {\n+func pkcs1v15HashInfo(hash crypto.Hash, inLen int) (hashLen int, prefix []byte, err error) {\n \thashLen = hash.Size()\n \tif inLen != hashLen {\n-\t\treturn 0, nil, os.NewError(\"input must be hashed message\")\n+\t\treturn 0, nil, errors.New(\"input must be hashed message\")\n \t}\n \tprefix, ok := hashPrefixes[hash]\n \tif !ok {\n-\t\treturn 0, nil, os.NewError(\"unsupported hash function\")\n+\t\treturn 0, nil, errors.New(\"unsupported hash function\")\n \t}\n \treturn\n }"}, {"sha": "c9344ffadffecf2ce22c77d648f425cccf5bd77f", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,9 +11,9 @@ import (\n \t\"big\"\n \t\"crypto/rand\"\n \t\"crypto/subtle\"\n+\t\"errors\"\n \t\"hash\"\n \t\"io\"\n-\t\"os\"\n )\n \n var bigZero = big.NewInt(0)\n@@ -55,16 +55,15 @@ type CRTValue struct {\n }\n \n // Validate performs basic sanity checks on the key.\n-// It returns nil if the key is valid, or else an os.Error describing a problem.\n-\n-func (priv *PrivateKey) Validate() os.Error {\n+// It returns nil if the key is valid, or else an error describing a problem.\n+func (priv *PrivateKey) Validate() error {\n \t// Check that the prime factors are actually prime. Note that this is\n \t// just a sanity check. Since the random witnesses chosen by\n \t// ProbablyPrime are deterministic, given the candidate number, it's\n \t// easy for an attack to generate composites that pass this test.\n \tfor _, prime := range priv.Primes {\n \t\tif !big.ProbablyPrime(prime, 20) {\n-\t\t\treturn os.NewError(\"prime factor is composite\")\n+\t\t\treturn errors.New(\"prime factor is composite\")\n \t\t}\n \t}\n \n@@ -74,7 +73,7 @@ func (priv *PrivateKey) Validate() os.Error {\n \t\tmodulus.Mul(modulus, prime)\n \t}\n \tif modulus.Cmp(priv.N) != 0 {\n-\t\treturn os.NewError(\"invalid modulus\")\n+\t\treturn errors.New(\"invalid modulus\")\n \t}\n \t// Check that e and totient(\u03a0primes) are coprime.\n \ttotient := new(big.Int).Set(bigOne)\n@@ -88,19 +87,19 @@ func (priv *PrivateKey) Validate() os.Error {\n \ty := new(big.Int)\n \tbig.GcdInt(gcd, x, y, totient, e)\n \tif gcd.Cmp(bigOne) != 0 {\n-\t\treturn os.NewError(\"invalid public exponent E\")\n+\t\treturn errors.New(\"invalid public exponent E\")\n \t}\n \t// Check that de \u2261 1 (mod totient(\u03a0primes))\n \tde := new(big.Int).Mul(priv.D, e)\n \tde.Mod(de, totient)\n \tif de.Cmp(bigOne) != 0 {\n-\t\treturn os.NewError(\"invalid private exponent D\")\n+\t\treturn errors.New(\"invalid private exponent D\")\n \t}\n \treturn nil\n }\n \n // GenerateKey generates an RSA keypair of the given bit size.\n-func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err os.Error) {\n+func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err error) {\n \treturn GenerateMultiPrimeKey(random, 2, bits)\n }\n \n@@ -114,12 +113,12 @@ func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err os.Error) {\n //\n // [1] US patent 4405829 (1972, expired)\n // [2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n-func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (priv *PrivateKey, err os.Error) {\n+func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (priv *PrivateKey, err error) {\n \tpriv = new(PrivateKey)\n \tpriv.E = 65537\n \n \tif nprimes < 2 {\n-\t\treturn nil, os.NewError(\"rsa.GenerateMultiPrimeKey: nprimes must be >= 2\")\n+\t\treturn nil, errors.New(\"rsa.GenerateMultiPrimeKey: nprimes must be >= 2\")\n \t}\n \n \tprimes := make([]*big.Int, nprimes)\n@@ -210,7 +209,7 @@ func mgf1XOR(out []byte, hash hash.Hash, seed []byte) {\n // is too large for the size of the public key.\n type MessageTooLongError struct{}\n \n-func (MessageTooLongError) String() string {\n+func (MessageTooLongError) Error() string {\n \treturn \"message too long for RSA public key size\"\n }\n \n@@ -223,7 +222,7 @@ func encrypt(c *big.Int, pub *PublicKey, m *big.Int) *big.Int {\n // EncryptOAEP encrypts the given message with RSA-OAEP.\n // The message must be no longer than the length of the public modulus less\n // twice the hash length plus 2.\n-func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err os.Error) {\n+func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err error) {\n \thash.Reset()\n \tk := (pub.N.BitLen() + 7) / 8\n \tif len(msg) > k-2*hash.Size()-2 {\n@@ -270,13 +269,13 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l\n // It is deliberately vague to avoid adaptive attacks.\n type DecryptionError struct{}\n \n-func (DecryptionError) String() string { return \"RSA decryption error\" }\n+func (DecryptionError) Error() string { return \"RSA decryption error\" }\n \n // A VerificationError represents a failure to verify a signature.\n // It is deliberately vague to avoid adaptive attacks.\n type VerificationError struct{}\n \n-func (VerificationError) String() string { return \"RSA verification error\" }\n+func (VerificationError) Error() string { return \"RSA verification error\" }\n \n // modInverse returns ia, the inverse of a in the multiplicative group of prime\n // order n. It requires that a be a member of the group (i.e. less than n).\n@@ -335,7 +334,7 @@ func (priv *PrivateKey) Precompute() {\n \n // decrypt performs an RSA decryption, resulting in a plaintext integer. If a\n // random source is given, RSA blinding is used.\n-func decrypt(random io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err os.Error) {\n+func decrypt(random io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err error) {\n \t// TODO(agl): can we get away with reusing blinds?\n \tif c.Cmp(priv.N) > 0 {\n \t\terr = DecryptionError{}\n@@ -413,7 +412,7 @@ func decrypt(random io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err os\n \n // DecryptOAEP decrypts ciphertext using RSA-OAEP.\n // If rand != nil, DecryptOAEP uses RSA blinding to avoid timing side-channel attacks.\n-func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) (msg []byte, err os.Error) {\n+func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) (msg []byte, err error) {\n \tk := (priv.N.BitLen() + 7) / 8\n \tif len(ciphertext) > k ||\n \t\tk < hash.Size()*2+2 {"}, {"sha": "4cdf5b2e989b4c706b6b82bf31f5a6a4c50f0897", "filename": "libgo/go/crypto/sha1/sha1.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ package sha1\n import (\n \t\"crypto\"\n \t\"hash\"\n-\t\"os\"\n )\n \n func init() {\n@@ -54,7 +53,7 @@ func New() hash.Hash {\n \n func (d *digest) Size() int { return Size }\n \n-func (d *digest) Write(p []byte) (nn int, err os.Error) {\n+func (d *digest) Write(p []byte) (nn int, err error) {\n \tnn = len(p)\n \td.len += uint64(nn)\n \tif d.nx > 0 {"}, {"sha": "14b8cfc7ecacf55a0e97dcb54649375dfb28c62b", "filename": "libgo/go/crypto/sha256/sha256.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,7 +9,6 @@ package sha256\n import (\n \t\"crypto\"\n \t\"hash\"\n-\t\"os\"\n )\n \n func init() {\n@@ -98,7 +97,7 @@ func (d *digest) Size() int {\n \treturn Size224\n }\n \n-func (d *digest) Write(p []byte) (nn int, err os.Error) {\n+func (d *digest) Write(p []byte) (nn int, err error) {\n \tnn = len(p)\n \td.len += uint64(nn)\n \tif d.nx > 0 {"}, {"sha": "1bd27982bb70563a768bc882779e14cb4406d92c", "filename": "libgo/go/crypto/sha512/sha512.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,7 +9,6 @@ package sha512\n import (\n \t\"crypto\"\n \t\"hash\"\n-\t\"os\"\n )\n \n func init() {\n@@ -98,7 +97,7 @@ func (d *digest) Size() int {\n \treturn Size384\n }\n \n-func (d *digest) Write(p []byte) (nn int, err os.Error) {\n+func (d *digest) Write(p []byte) (nn int, err error) {\n \tnn = len(p)\n \td.len += uint64(nn)\n \tif d.nx > 0 {"}, {"sha": "1134f36258374b24a642e8fe87b56c7229da34b4", "filename": "libgo/go/crypto/tls/cipher_suites.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -13,7 +13,6 @@ import (\n \t\"crypto/sha1\"\n \t\"crypto/x509\"\n \t\"hash\"\n-\t\"os\"\n )\n \n // a keyAgreement implements the client and server side of a TLS key agreement\n@@ -24,15 +23,15 @@ type keyAgreement interface {\n \t// In the case that the key agreement protocol doesn't use a\n \t// ServerKeyExchange message, generateServerKeyExchange can return nil,\n \t// nil.\n-\tgenerateServerKeyExchange(*Config, *clientHelloMsg, *serverHelloMsg) (*serverKeyExchangeMsg, os.Error)\n-\tprocessClientKeyExchange(*Config, *clientKeyExchangeMsg, uint16) ([]byte, os.Error)\n+\tgenerateServerKeyExchange(*Config, *clientHelloMsg, *serverHelloMsg) (*serverKeyExchangeMsg, error)\n+\tprocessClientKeyExchange(*Config, *clientKeyExchangeMsg, uint16) ([]byte, error)\n \n \t// On the client side, the next two methods are called in order.\n \n \t// This method may not be called if the server doesn't send a\n \t// ServerKeyExchange message.\n-\tprocessServerKeyExchange(*Config, *clientHelloMsg, *serverHelloMsg, *x509.Certificate, *serverKeyExchangeMsg) os.Error\n-\tgenerateClientKeyExchange(*Config, *clientHelloMsg, *x509.Certificate) ([]byte, *clientKeyExchangeMsg, os.Error)\n+\tprocessServerKeyExchange(*Config, *clientHelloMsg, *serverHelloMsg, *x509.Certificate, *serverKeyExchangeMsg) error\n+\tgenerateClientKeyExchange(*Config, *clientHelloMsg, *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error)\n }\n \n // A cipherSuite is a specific combination of key agreement, cipher and MAC"}, {"sha": "6312c34d6d75523b67ce28cd4697e4ba9240c7a6", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,9 +11,9 @@ import (\n \t\"crypto/cipher\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n+\t\"errors\"\n \t\"io\"\n \t\"net\"\n-\t\"os\"\n \t\"sync\"\n )\n \n@@ -44,7 +44,7 @@ type Conn struct {\n \n \t// first permanent error\n \terrMutex sync.Mutex\n-\terr      os.Error\n+\terr      error\n \n \t// input/output\n \tin, out  halfConn     // in.Mutex < out.Mutex\n@@ -55,7 +55,7 @@ type Conn struct {\n \ttmp [16]byte\n }\n \n-func (c *Conn) setError(err os.Error) os.Error {\n+func (c *Conn) setError(err error) error {\n \tc.errMutex.Lock()\n \tdefer c.errMutex.Unlock()\n \n@@ -65,7 +65,7 @@ func (c *Conn) setError(err os.Error) os.Error {\n \treturn err\n }\n \n-func (c *Conn) error() os.Error {\n+func (c *Conn) error() error {\n \tc.errMutex.Lock()\n \tdefer c.errMutex.Unlock()\n \n@@ -88,21 +88,21 @@ func (c *Conn) RemoteAddr() net.Addr {\n \n // SetTimeout sets the read deadline associated with the connection.\n // There is no write deadline.\n-func (c *Conn) SetTimeout(nsec int64) os.Error {\n+func (c *Conn) SetTimeout(nsec int64) error {\n \treturn c.conn.SetTimeout(nsec)\n }\n \n // SetReadTimeout sets the time (in nanoseconds) that\n // Read will wait for data before returning os.EAGAIN.\n // Setting nsec == 0 (the default) disables the deadline.\n-func (c *Conn) SetReadTimeout(nsec int64) os.Error {\n+func (c *Conn) SetReadTimeout(nsec int64) error {\n \treturn c.conn.SetReadTimeout(nsec)\n }\n \n // SetWriteTimeout exists to satisfy the net.Conn interface\n // but is not implemented by TLS.  It always returns an error.\n-func (c *Conn) SetWriteTimeout(nsec int64) os.Error {\n-\treturn os.NewError(\"TLS does not support SetWriteTimeout\")\n+func (c *Conn) SetWriteTimeout(nsec int64) error {\n+\treturn errors.New(\"TLS does not support SetWriteTimeout\")\n }\n \n // A halfConn represents one direction of the record layer\n@@ -129,7 +129,7 @@ func (hc *halfConn) prepareCipherSpec(version uint16, cipher interface{}, mac ma\n \n // changeCipherSpec changes the encryption and MAC states\n // to the ones previously passed to prepareCipherSpec.\n-func (hc *halfConn) changeCipherSpec() os.Error {\n+func (hc *halfConn) changeCipherSpec() error {\n \tif hc.nextCipher == nil {\n \t\treturn alertInternalError\n \t}\n@@ -378,7 +378,7 @@ func (b *block) reserve(n int) {\n \n // readFromUntil reads from r into b until b contains at least n bytes\n // or else returns an error.\n-func (b *block) readFromUntil(r io.Reader, n int) os.Error {\n+func (b *block) readFromUntil(r io.Reader, n int) error {\n \t// quick case\n \tif len(b.data) >= n {\n \t\treturn nil\n@@ -399,7 +399,7 @@ func (b *block) readFromUntil(r io.Reader, n int) os.Error {\n \treturn nil\n }\n \n-func (b *block) Read(p []byte) (n int, err os.Error) {\n+func (b *block) Read(p []byte) (n int, err error) {\n \tn = copy(p, b.data[b.off:])\n \tb.off += n\n \treturn\n@@ -443,7 +443,7 @@ func (hc *halfConn) splitBlock(b *block, n int) (*block, *block) {\n // readRecord reads the next TLS record from the connection\n // and updates the record layer state.\n // c.in.Mutex <= L; c.input == nil.\n-func (c *Conn) readRecord(want recordType) os.Error {\n+func (c *Conn) readRecord(want recordType) error {\n \t// Caller must be in sync with connection:\n \t// handshake data if handshake not yet completed,\n \t// else application data.  (We don't support renegotiation.)\n@@ -502,7 +502,7 @@ Again:\n \t\t}\n \t}\n \tif err := b.readFromUntil(c.conn, recordHeaderLen+n); err != nil {\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\terr = io.ErrUnexpectedEOF\n \t\t}\n \t\tif e, ok := err.(net.Error); !ok || !e.Temporary() {\n@@ -534,7 +534,7 @@ Again:\n \t\t\tbreak\n \t\t}\n \t\tif alert(data[1]) == alertCloseNotify {\n-\t\t\tc.setError(os.EOF)\n+\t\t\tc.setError(io.EOF)\n \t\t\tbreak\n \t\t}\n \t\tswitch data[0] {\n@@ -543,7 +543,7 @@ Again:\n \t\t\tc.in.freeBlock(b)\n \t\t\tgoto Again\n \t\tcase alertLevelError:\n-\t\t\tc.setError(&net.OpError{Op: \"remote error\", Error: alert(data[1])})\n+\t\t\tc.setError(&net.OpError{Op: \"remote error\", Err: alert(data[1])})\n \t\tdefault:\n \t\t\tc.sendAlert(alertUnexpectedMessage)\n \t\t}\n@@ -582,7 +582,7 @@ Again:\n \n // sendAlert sends a TLS alert message.\n // c.out.Mutex <= L.\n-func (c *Conn) sendAlertLocked(err alert) os.Error {\n+func (c *Conn) sendAlertLocked(err alert) error {\n \tc.tmp[0] = alertLevelError\n \tif err == alertNoRenegotiation {\n \t\tc.tmp[0] = alertLevelWarning\n@@ -591,14 +591,14 @@ func (c *Conn) sendAlertLocked(err alert) os.Error {\n \tc.writeRecord(recordTypeAlert, c.tmp[0:2])\n \t// closeNotify is a special case in that it isn't an error:\n \tif err != alertCloseNotify {\n-\t\treturn c.setError(&net.OpError{Op: \"local error\", Error: err})\n+\t\treturn c.setError(&net.OpError{Op: \"local error\", Err: err})\n \t}\n \treturn nil\n }\n \n // sendAlert sends a TLS alert message.\n // L < c.out.Mutex.\n-func (c *Conn) sendAlert(err alert) os.Error {\n+func (c *Conn) sendAlert(err alert) error {\n \tc.out.Lock()\n \tdefer c.out.Unlock()\n \treturn c.sendAlertLocked(err)\n@@ -607,7 +607,7 @@ func (c *Conn) sendAlert(err alert) os.Error {\n // writeRecord writes a TLS record with the given type and payload\n // to the connection and updates the record layer state.\n // c.out.Mutex <= L.\n-func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err os.Error) {\n+func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {\n \tb := c.out.newBlock()\n \tfor len(data) > 0 {\n \t\tm := len(data)\n@@ -643,7 +643,7 @@ func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err os.Error) {\n \t\t\tc.tmp[0] = alertLevelError\n \t\t\tc.tmp[1] = byte(err.(alert))\n \t\t\tc.writeRecord(recordTypeAlert, c.tmp[0:2])\n-\t\t\tc.err = &net.OpError{Op: \"local error\", Error: err}\n+\t\t\tc.err = &net.OpError{Op: \"local error\", Err: err}\n \t\t\treturn n, c.err\n \t\t}\n \t}\n@@ -653,7 +653,7 @@ func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err os.Error) {\n // readHandshake reads the next handshake message from\n // the record layer.\n // c.in.Mutex < L; c.out.Mutex < L.\n-func (c *Conn) readHandshake() (interface{}, os.Error) {\n+func (c *Conn) readHandshake() (interface{}, error) {\n \tfor c.hand.Len() < 4 {\n \t\tif c.err != nil {\n \t\t\treturn nil, c.err\n@@ -720,7 +720,7 @@ func (c *Conn) readHandshake() (interface{}, os.Error) {\n }\n \n // Write writes data to the connection.\n-func (c *Conn) Write(b []byte) (n int, err os.Error) {\n+func (c *Conn) Write(b []byte) (n int, err error) {\n \tif err = c.Handshake(); err != nil {\n \t\treturn\n \t}\n@@ -739,7 +739,7 @@ func (c *Conn) Write(b []byte) (n int, err os.Error) {\n \n // Read can be made to time out and return err == os.EAGAIN\n // after a fixed time limit; see SetTimeout and SetReadTimeout.\n-func (c *Conn) Read(b []byte) (n int, err os.Error) {\n+func (c *Conn) Read(b []byte) (n int, err error) {\n \tif err = c.Handshake(); err != nil {\n \t\treturn\n \t}\n@@ -765,8 +765,8 @@ func (c *Conn) Read(b []byte) (n int, err os.Error) {\n }\n \n // Close closes the connection.\n-func (c *Conn) Close() os.Error {\n-\tvar alertErr os.Error\n+func (c *Conn) Close() error {\n+\tvar alertErr error\n \n \tc.handshakeMutex.Lock()\n \tdefer c.handshakeMutex.Unlock()\n@@ -784,7 +784,7 @@ func (c *Conn) Close() os.Error {\n // protocol if it has not yet been run.\n // Most uses of this package need not call Handshake\n // explicitly: the first Read or Write will call it automatically.\n-func (c *Conn) Handshake() os.Error {\n+func (c *Conn) Handshake() error {\n \tc.handshakeMutex.Lock()\n \tdefer c.handshakeMutex.Unlock()\n \tif err := c.error(); err != nil {\n@@ -828,16 +828,16 @@ func (c *Conn) OCSPResponse() []byte {\n }\n \n // VerifyHostname checks that the peer certificate chain is valid for\n-// connecting to host.  If so, it returns nil; if not, it returns an os.Error\n+// connecting to host.  If so, it returns nil; if not, it returns an error\n // describing the problem.\n-func (c *Conn) VerifyHostname(host string) os.Error {\n+func (c *Conn) VerifyHostname(host string) error {\n \tc.handshakeMutex.Lock()\n \tdefer c.handshakeMutex.Unlock()\n \tif !c.isClient {\n-\t\treturn os.NewError(\"VerifyHostname called on TLS server connection\")\n+\t\treturn errors.New(\"VerifyHostname called on TLS server connection\")\n \t}\n \tif !c.handshakeComplete {\n-\t\treturn os.NewError(\"TLS handshake has not yet been performed\")\n+\t\treturn errors.New(\"TLS handshake has not yet been performed\")\n \t}\n \treturn c.peerCertificates[0].VerifyHostname(host)\n }"}, {"sha": "aed991ccd1bfb00229a382557dd00d1cba0eb8d8", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,11 +9,11 @@ import (\n \t\"crypto/rsa\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n )\n \n-func (c *Conn) clientHandshake() os.Error {\n+func (c *Conn) clientHandshake() error {\n \tfinishedHash := newFinishedHash(versionTLS10)\n \n \tif c.config == nil {\n@@ -40,7 +40,7 @@ func (c *Conn) clientHandshake() os.Error {\n \t_, err := io.ReadFull(c.config.rand(), hello.random[4:])\n \tif err != nil {\n \t\tc.sendAlert(alertInternalError)\n-\t\treturn os.NewError(\"short read from Rand\")\n+\t\treturn errors.New(\"short read from Rand\")\n \t}\n \n \tfinishedHash.Write(hello.marshal())\n@@ -69,7 +69,7 @@ func (c *Conn) clientHandshake() os.Error {\n \n \tif !hello.nextProtoNeg && serverHello.nextProtoNeg {\n \t\tc.sendAlert(alertHandshakeFailure)\n-\t\treturn os.NewError(\"server advertised unrequested NPN\")\n+\t\treturn errors.New(\"server advertised unrequested NPN\")\n \t}\n \n \tsuite, suiteId := mutualCipherSuite(c.config.cipherSuites(), serverHello.cipherSuite)\n@@ -92,7 +92,7 @@ func (c *Conn) clientHandshake() os.Error {\n \t\tcert, err := x509.ParseCertificate(asn1Data)\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\treturn os.NewError(\"failed to parse certificate from server: \" + err.String())\n+\t\t\treturn errors.New(\"failed to parse certificate from server: \" + err.Error())\n \t\t}\n \t\tcerts[i] = cert\n \t}"}, {"sha": "d5af084eda5b094c0d157e6893dae6abb31c3cd7", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,11 +9,11 @@ import (\n \t\"crypto/rsa\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n )\n \n-func (c *Conn) serverHandshake() os.Error {\n+func (c *Conn) serverHandshake() error {\n \tconfig := c.config\n \tmsg, err := c.readHandshake()\n \tif err != nil {\n@@ -177,7 +177,7 @@ FindCipherSuite:\n \t\t\tcert, err := x509.ParseCertificate(asn1Data)\n \t\t\tif err != nil {\n \t\t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\t\treturn os.NewError(\"could not parse client's certificate: \" + err.String())\n+\t\t\t\treturn errors.New(\"could not parse client's certificate: \" + err.Error())\n \t\t\t}\n \t\t\tcerts[i] = cert\n \t\t}\n@@ -186,7 +186,7 @@ FindCipherSuite:\n \t\tfor i := 1; i < len(certs); i++ {\n \t\t\tif err := certs[i-1].CheckSignatureFrom(certs[i]); err != nil {\n \t\t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\t\treturn os.NewError(\"could not validate certificate signature: \" + err.String())\n+\t\t\t\treturn errors.New(\"could not validate certificate signature: \" + err.Error())\n \t\t\t}\n \t\t}\n \n@@ -233,7 +233,7 @@ FindCipherSuite:\n \t\terr = rsa.VerifyPKCS1v15(pub, crypto.MD5SHA1, digest, certVerify.signature)\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\treturn os.NewError(\"could not validate signature of connection nonces: \" + err.String())\n+\t\t\treturn errors.New(\"could not validate signature of connection nonces: \" + err.Error())\n \t\t}\n \n \t\tfinishedHash.Write(certVerify.marshal())"}, {"sha": "f2b0a144e5e892b9dc4d31580d52ac7884a1ad49", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -12,15 +12,14 @@ import (\n \t\"flag\"\n \t\"io\"\n \t\"net\"\n-\t\"os\"\n \t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n )\n \n type zeroSource struct{}\n \n-func (zeroSource) Read(b []byte) (n int, err os.Error) {\n+func (zeroSource) Read(b []byte) (n int, err error) {\n \tfor i := range b {\n \t\tb[i] = 0\n \t}\n@@ -41,7 +40,7 @@ func init() {\n \ttestConfig.InsecureSkipVerify = true\n }\n \n-func testClientHelloFailure(t *testing.T, m handshakeMessage, expected os.Error) {\n+func testClientHelloFailure(t *testing.T, m handshakeMessage, expected error) {\n \t// Create in-memory network connection,\n \t// send message to server.  Should return\n \t// expected error.\n@@ -56,7 +55,7 @@ func testClientHelloFailure(t *testing.T, m handshakeMessage, expected os.Error)\n \t}()\n \terr := Server(s, testConfig).Handshake()\n \ts.Close()\n-\tif e, ok := err.(*net.OpError); !ok || e.Error != expected {\n+\tif e, ok := err.(*net.OpError); !ok || e.Err != expected {\n \t\tt.Errorf(\"Got error: %s; expected: %s\", err, expected)\n \t}\n }\n@@ -93,7 +92,7 @@ func TestAlertForwarding(t *testing.T) {\n \n \terr := Server(s, testConfig).Handshake()\n \ts.Close()\n-\tif e, ok := err.(*net.OpError); !ok || e.Error != os.Error(alertUnknownCA) {\n+\tif e, ok := err.(*net.OpError); !ok || e.Err != error(alertUnknownCA) {\n \t\tt.Errorf(\"Got error: %s; expected: %s\", err, alertUnknownCA)\n \t}\n }\n@@ -104,8 +103,8 @@ func TestClose(t *testing.T) {\n \n \terr := Server(s, testConfig).Handshake()\n \ts.Close()\n-\tif err != os.EOF {\n-\t\tt.Errorf(\"Got error: %s; expected: %s\", err, os.EOF)\n+\tif err != io.EOF {\n+\t\tt.Errorf(\"Got error: %s; expected: %s\", err, io.EOF)\n \t}\n }\n "}, {"sha": "ba34606eea2f214bc614df554372468478913bcc", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -12,34 +12,34 @@ import (\n \t\"crypto/rsa\"\n \t\"crypto/sha1\"\n \t\"crypto/x509\"\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n )\n \n // rsaKeyAgreement implements the standard TLS key agreement where the client\n // encrypts the pre-master secret to the server's public key.\n type rsaKeyAgreement struct{}\n \n-func (ka rsaKeyAgreement) generateServerKeyExchange(config *Config, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, os.Error) {\n+func (ka rsaKeyAgreement) generateServerKeyExchange(config *Config, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) {\n \treturn nil, nil\n }\n \n-func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKeyExchangeMsg, version uint16) ([]byte, os.Error) {\n+func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) {\n \tpreMasterSecret := make([]byte, 48)\n \t_, err := io.ReadFull(config.rand(), preMasterSecret[2:])\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n \tif len(ckx.ciphertext) < 2 {\n-\t\treturn nil, os.NewError(\"bad ClientKeyExchange\")\n+\t\treturn nil, errors.New(\"bad ClientKeyExchange\")\n \t}\n \n \tciphertext := ckx.ciphertext\n \tif version != versionSSL30 {\n \t\tciphertextLen := int(ckx.ciphertext[0])<<8 | int(ckx.ciphertext[1])\n \t\tif ciphertextLen != len(ckx.ciphertext)-2 {\n-\t\t\treturn nil, os.NewError(\"bad ClientKeyExchange\")\n+\t\t\treturn nil, errors.New(\"bad ClientKeyExchange\")\n \t\t}\n \t\tciphertext = ckx.ciphertext[2:]\n \t}\n@@ -57,11 +57,11 @@ func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKe\n \treturn preMasterSecret, nil\n }\n \n-func (ka rsaKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) os.Error {\n-\treturn os.NewError(\"unexpected ServerKeyExchange\")\n+func (ka rsaKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error {\n+\treturn errors.New(\"unexpected ServerKeyExchange\")\n }\n \n-func (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, os.Error) {\n+func (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) {\n \tpreMasterSecret := make([]byte, 48)\n \tpreMasterSecret[0] = byte(clientHello.vers >> 8)\n \tpreMasterSecret[1] = byte(clientHello.vers)\n@@ -109,7 +109,7 @@ type ecdheRSAKeyAgreement struct {\n \tx, y       *big.Int\n }\n \n-func (ka *ecdheRSAKeyAgreement) generateServerKeyExchange(config *Config, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, os.Error) {\n+func (ka *ecdheRSAKeyAgreement) generateServerKeyExchange(config *Config, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) {\n \tvar curveid uint16\n \n Curve:\n@@ -131,7 +131,7 @@ Curve:\n \t}\n \n \tvar x, y *big.Int\n-\tvar err os.Error\n+\tvar err error\n \tka.privateKey, x, y, err = ka.curve.GenerateKey(config.rand())\n \tif err != nil {\n \t\treturn nil, err\n@@ -149,7 +149,7 @@ Curve:\n \tmd5sha1 := md5SHA1Hash(clientHello.random, hello.random, serverECDHParams)\n \tsig, err := rsa.SignPKCS1v15(config.rand(), config.Certificates[0].PrivateKey, crypto.MD5SHA1, md5sha1)\n \tif err != nil {\n-\t\treturn nil, os.NewError(\"failed to sign ECDHE parameters: \" + err.String())\n+\t\treturn nil, errors.New(\"failed to sign ECDHE parameters: \" + err.Error())\n \t}\n \n \tskx := new(serverKeyExchangeMsg)\n@@ -163,13 +163,13 @@ Curve:\n \treturn skx, nil\n }\n \n-func (ka *ecdheRSAKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKeyExchangeMsg, version uint16) ([]byte, os.Error) {\n+func (ka *ecdheRSAKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) {\n \tif len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 {\n-\t\treturn nil, os.NewError(\"bad ClientKeyExchange\")\n+\t\treturn nil, errors.New(\"bad ClientKeyExchange\")\n \t}\n \tx, y := ka.curve.Unmarshal(ckx.ciphertext[1:])\n \tif x == nil {\n-\t\treturn nil, os.NewError(\"bad ClientKeyExchange\")\n+\t\treturn nil, errors.New(\"bad ClientKeyExchange\")\n \t}\n \tx, _ = ka.curve.ScalarMult(x, y, ka.privateKey)\n \tpreMasterSecret := make([]byte, (ka.curve.BitSize+7)>>3)\n@@ -179,14 +179,14 @@ func (ka *ecdheRSAKeyAgreement) processClientKeyExchange(config *Config, ckx *cl\n \treturn preMasterSecret, nil\n }\n \n-var errServerKeyExchange = os.NewError(\"invalid ServerKeyExchange\")\n+var errServerKeyExchange = errors.New(\"invalid ServerKeyExchange\")\n \n-func (ka *ecdheRSAKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) os.Error {\n+func (ka *ecdheRSAKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error {\n \tif len(skx.key) < 4 {\n \t\treturn errServerKeyExchange\n \t}\n \tif skx.key[0] != 3 { // named curve\n-\t\treturn os.NewError(\"server selected unsupported curve\")\n+\t\treturn errors.New(\"server selected unsupported curve\")\n \t}\n \tcurveid := uint16(skx.key[1])<<8 | uint16(skx.key[2])\n \n@@ -198,7 +198,7 @@ func (ka *ecdheRSAKeyAgreement) processServerKeyExchange(config *Config, clientH\n \tcase curveP521:\n \t\tka.curve = elliptic.P521()\n \tdefault:\n-\t\treturn os.NewError(\"server selected unsupported curve\")\n+\t\treturn errors.New(\"server selected unsupported curve\")\n \t}\n \n \tpublicLen := int(skx.key[3])\n@@ -225,9 +225,9 @@ func (ka *ecdheRSAKeyAgreement) processServerKeyExchange(config *Config, clientH\n \treturn rsa.VerifyPKCS1v15(cert.PublicKey.(*rsa.PublicKey), crypto.MD5SHA1, md5sha1, sig)\n }\n \n-func (ka *ecdheRSAKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, os.Error) {\n+func (ka *ecdheRSAKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) {\n \tif ka.curve == nil {\n-\t\treturn nil, nil, os.NewError(\"missing ServerKeyExchange message\")\n+\t\treturn nil, nil, errors.New(\"missing ServerKeyExchange message\")\n \t}\n \tpriv, mx, my, err := ka.curve.GenerateKey(config.rand())\n \tif err != nil {"}, {"sha": "d758f21aa8ebd8ac79d747579186f73695fa8f74", "filename": "libgo/go/crypto/tls/prf.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"crypto/md5\"\n \t\"crypto/sha1\"\n \t\"hash\"\n-\t\"os\"\n )\n \n // Split a premaster secret in two as specified in RFC 4346, section 5.\n@@ -156,7 +155,7 @@ type finishedHash struct {\n \tversion    uint16\n }\n \n-func (h finishedHash) Write(msg []byte) (n int, err os.Error) {\n+func (h finishedHash) Write(msg []byte) (n int, err error) {\n \th.clientMD5.Write(msg)\n \th.clientSHA1.Write(msg)\n \th.serverMD5.Write(msg)"}, {"sha": "3ca62407ff032dcb6f4449fa77555c78f615eb7c", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,9 +10,9 @@ import (\n \t\"crypto/rsa\"\n \t\"crypto/x509\"\n \t\"encoding/pem\"\n+\t\"errors\"\n \t\"io/ioutil\"\n \t\"net\"\n-\t\"os\"\n \t\"strings\"\n )\n \n@@ -41,7 +41,7 @@ type Listener struct {\n \n // Accept waits for and returns the next incoming TLS connection.\n // The returned connection c is a *tls.Conn.\n-func (l *Listener) Accept() (c net.Conn, err os.Error) {\n+func (l *Listener) Accept() (c net.Conn, err error) {\n \tc, err = l.listener.Accept()\n \tif err != nil {\n \t\treturn\n@@ -51,7 +51,7 @@ func (l *Listener) Accept() (c net.Conn, err os.Error) {\n }\n \n // Close closes the listener.\n-func (l *Listener) Close() os.Error { return l.listener.Close() }\n+func (l *Listener) Close() error { return l.listener.Close() }\n \n // Addr returns the listener's network address.\n func (l *Listener) Addr() net.Addr { return l.listener.Addr() }\n@@ -71,9 +71,9 @@ func NewListener(listener net.Listener, config *Config) (l *Listener) {\n // given network address using net.Listen.\n // The configuration config must be non-nil and must have\n // at least one certificate.\n-func Listen(network, laddr string, config *Config) (*Listener, os.Error) {\n+func Listen(network, laddr string, config *Config) (*Listener, error) {\n \tif config == nil || len(config.Certificates) == 0 {\n-\t\treturn nil, os.NewError(\"tls.Listen: no certificates in configuration\")\n+\t\treturn nil, errors.New(\"tls.Listen: no certificates in configuration\")\n \t}\n \tl, err := net.Listen(network, laddr)\n \tif err != nil {\n@@ -88,7 +88,7 @@ func Listen(network, laddr string, config *Config) (*Listener, os.Error) {\n // Dial interprets a nil configuration as equivalent to\n // the zero configuration; see the documentation of Config\n // for the defaults.\n-func Dial(network, addr string, config *Config) (*Conn, os.Error) {\n+func Dial(network, addr string, config *Config) (*Conn, error) {\n \traddr := addr\n \tc, err := net.Dial(network, raddr)\n \tif err != nil {\n@@ -120,7 +120,7 @@ func Dial(network, addr string, config *Config) (*Conn, os.Error) {\n \n // LoadX509KeyPair reads and parses a public/private key pair from a pair of\n // files. The files must contain PEM encoded data.\n-func LoadX509KeyPair(certFile string, keyFile string) (cert Certificate, err os.Error) {\n+func LoadX509KeyPair(certFile string, keyFile string) (cert Certificate, err error) {\n \tcertPEMBlock, err := ioutil.ReadFile(certFile)\n \tif err != nil {\n \t\treturn\n@@ -134,7 +134,7 @@ func LoadX509KeyPair(certFile string, keyFile string) (cert Certificate, err os.\n \n // X509KeyPair parses a public/private key pair from a pair of\n // PEM encoded data.\n-func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err os.Error) {\n+func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err error) {\n \tvar certDERBlock *pem.Block\n \tfor {\n \t\tcertDERBlock, certPEMBlock = pem.Decode(certPEMBlock)\n@@ -147,19 +147,19 @@ func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err os.Err\n \t}\n \n \tif len(cert.Certificate) == 0 {\n-\t\terr = os.NewError(\"crypto/tls: failed to parse certificate PEM data\")\n+\t\terr = errors.New(\"crypto/tls: failed to parse certificate PEM data\")\n \t\treturn\n \t}\n \n \tkeyDERBlock, _ := pem.Decode(keyPEMBlock)\n \tif keyDERBlock == nil {\n-\t\terr = os.NewError(\"crypto/tls: failed to parse key PEM data\")\n+\t\terr = errors.New(\"crypto/tls: failed to parse key PEM data\")\n \t\treturn\n \t}\n \n \tkey, err := x509.ParsePKCS1PrivateKey(keyDERBlock.Bytes)\n \tif err != nil {\n-\t\terr = os.NewError(\"crypto/tls: failed to parse key: \" + err.String())\n+\t\terr = errors.New(\"crypto/tls: failed to parse key: \" + err.Error())\n \t\treturn\n \t}\n \n@@ -173,7 +173,7 @@ func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err os.Err\n \t}\n \n \tif x509Cert.PublicKeyAlgorithm != x509.RSA || x509Cert.PublicKey.(*rsa.PublicKey).N.Cmp(key.PublicKey.N) != 0 {\n-\t\terr = os.NewError(\"crypto/tls: private key does not match public key\")\n+\t\terr = errors.New(\"crypto/tls: private key does not match public key\")\n \t\treturn\n \t}\n "}, {"sha": "0616e7b82863735ab646734b3c024ffd54104c13", "filename": "libgo/go/crypto/twofish/twofish.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -12,10 +12,7 @@ package twofish\n // LibTomCrypt is free for all purposes under the public domain.\n // It was heavily inspired by the go blowfish package.\n \n-import (\n-\t\"os\"\n-\t\"strconv\"\n-)\n+import \"strconv\"\n \n // BlockSize is the constant block size of Twofish.\n const BlockSize = 16\n@@ -31,13 +28,13 @@ type Cipher struct {\n \n type KeySizeError int\n \n-func (k KeySizeError) String() string {\n+func (k KeySizeError) Error() string {\n \treturn \"crypto/twofish: invalid key size \" + strconv.Itoa(int(k))\n }\n \n // NewCipher creates and returns a Cipher.\n // The key argument should be the Twofish key, 16, 24 or 32 bytes.\n-func NewCipher(key []byte) (*Cipher, os.Error) {\n+func NewCipher(key []byte) (*Cipher, error) {\n \tkeylen := len(key)\n \n \tif keylen != 16 && keylen != 24 && keylen != 32 {"}, {"sha": "0d3ade375789935882637c8b3db022249bdd68dc", "filename": "libgo/go/crypto/x509/pkcs1.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,7 @@ package x509\n import (\n \t\"asn1\"\n \t\"big\"\n-\t\"os\"\n+\t\"errors\"\n \t\"crypto/rsa\"\n )\n \n@@ -36,7 +36,7 @@ type pkcs1AdditionalRSAPrime struct {\n }\n \n // ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n-func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error) {\n+func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err error) {\n \tvar priv pkcs1PrivateKey\n \trest, err := asn1.Unmarshal(der, &priv)\n \tif len(rest) > 0 {\n@@ -48,11 +48,11 @@ func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error) {\n \t}\n \n \tif priv.Version > 1 {\n-\t\treturn nil, os.NewError(\"x509: unsupported private key version\")\n+\t\treturn nil, errors.New(\"x509: unsupported private key version\")\n \t}\n \n \tif priv.N.Sign() <= 0 || priv.D.Sign() <= 0 || priv.P.Sign() <= 0 || priv.Q.Sign() <= 0 {\n-\t\treturn nil, os.NewError(\"private key contains zero or negative value\")\n+\t\treturn nil, errors.New(\"private key contains zero or negative value\")\n \t}\n \n \tkey = new(rsa.PrivateKey)\n@@ -67,7 +67,7 @@ func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error) {\n \tkey.Primes[1] = priv.Q\n \tfor i, a := range priv.AdditionalPrimes {\n \t\tif a.Prime.Sign() <= 0 {\n-\t\t\treturn nil, os.NewError(\"private key contains zero or negative prime\")\n+\t\t\treturn nil, errors.New(\"private key contains zero or negative prime\")\n \t\t}\n \t\tkey.Primes[i+2] = a.Prime\n \t\t// We ignore the other two values because rsa will calculate"}, {"sha": "3021d20a67f154f5c03c34a48c64644fbdc97886", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,7 +5,6 @@\n package x509\n \n import (\n-\t\"os\"\n \t\"strings\"\n \t\"time\"\n )\n@@ -32,7 +31,7 @@ type CertificateInvalidError struct {\n \tReason InvalidReason\n }\n \n-func (e CertificateInvalidError) String() string {\n+func (e CertificateInvalidError) Error() string {\n \tswitch e.Reason {\n \tcase NotAuthorizedToSign:\n \t\treturn \"x509: certificate is not authorized to sign other other certificates\"\n@@ -51,7 +50,7 @@ type HostnameError struct {\n \tHost        string\n }\n \n-func (h HostnameError) String() string {\n+func (h HostnameError) Error() string {\n \tvar valid string\n \tc := h.Certificate\n \tif len(c.DNSNames) > 0 {\n@@ -67,7 +66,7 @@ type UnknownAuthorityError struct {\n \tcert *Certificate\n }\n \n-func (e UnknownAuthorityError) String() string {\n+func (e UnknownAuthorityError) Error() string {\n \treturn \"x509: certificate signed by unknown authority\"\n }\n \n@@ -87,7 +86,7 @@ const (\n )\n \n // isValid performs validity checks on the c.\n-func (c *Certificate) isValid(certType int, opts *VerifyOptions) os.Error {\n+func (c *Certificate) isValid(certType int, opts *VerifyOptions) error {\n \tif opts.CurrentTime < c.NotBefore.Seconds() ||\n \t\topts.CurrentTime > c.NotAfter.Seconds() {\n \t\treturn CertificateInvalidError{c, Expired}\n@@ -136,7 +135,7 @@ func (c *Certificate) isValid(certType int, opts *VerifyOptions) os.Error {\n // the chain is c and the last element is from opts.Roots.\n //\n // WARNING: this doesn't do any revocation checking.\n-func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err os.Error) {\n+func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error) {\n \tif opts.CurrentTime == 0 {\n \t\topts.CurrentTime = time.Seconds()\n \t}\n@@ -160,7 +159,7 @@ func appendToFreshChain(chain []*Certificate, cert *Certificate) []*Certificate\n \treturn n\n }\n \n-func (c *Certificate) buildChains(cache map[int][][]*Certificate, currentChain []*Certificate, opts *VerifyOptions) (chains [][]*Certificate, err os.Error) {\n+func (c *Certificate) buildChains(cache map[int][][]*Certificate, currentChain []*Certificate, opts *VerifyOptions) (chains [][]*Certificate, err error) {\n \tfor _, rootNum := range opts.Roots.findVerifiedParents(c) {\n \t\troot := opts.Roots.certs[rootNum]\n \t\terr = root.isValid(rootCertificate, opts)\n@@ -227,8 +226,8 @@ func matchHostnames(pattern, host string) bool {\n }\n \n // VerifyHostname returns nil if c is a valid certificate for the named host.\n-// Otherwise it returns an os.Error describing the mismatch.\n-func (c *Certificate) VerifyHostname(h string) os.Error {\n+// Otherwise it returns an error describing the mismatch.\n+func (c *Certificate) VerifyHostname(h string) error {\n \tif len(c.DNSNames) > 0 {\n \t\tfor _, match := range c.DNSNames {\n \t\t\tif matchHostnames(match, h) {"}, {"sha": "2194d15bc88b5181138618f09b85730c8fb07d97", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,7 @@ package x509\n import (\n \t\"crypto/x509/pkix\"\n \t\"encoding/pem\"\n-\t\"os\"\n+\t\"errors\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -19,7 +19,7 @@ type verifyTest struct {\n \tcurrentTime   int64\n \tdnsName       string\n \n-\terrorCallback  func(*testing.T, int, os.Error) bool\n+\terrorCallback  func(*testing.T, int, error) bool\n \texpectedChains [][]string\n }\n \n@@ -95,34 +95,34 @@ var verifyTests = []verifyTest{\n \t},\n }\n \n-func expectHostnameError(t *testing.T, i int, err os.Error) (ok bool) {\n+func expectHostnameError(t *testing.T, i int, err error) (ok bool) {\n \tif _, ok := err.(HostnameError); !ok {\n \t\tt.Errorf(\"#%d: error was not a HostnameError: %s\", i, err)\n \t\treturn false\n \t}\n \treturn true\n }\n \n-func expectExpired(t *testing.T, i int, err os.Error) (ok bool) {\n+func expectExpired(t *testing.T, i int, err error) (ok bool) {\n \tif inval, ok := err.(CertificateInvalidError); !ok || inval.Reason != Expired {\n \t\tt.Errorf(\"#%d: error was not Expired: %s\", i, err)\n \t\treturn false\n \t}\n \treturn true\n }\n \n-func expectAuthorityUnknown(t *testing.T, i int, err os.Error) (ok bool) {\n+func expectAuthorityUnknown(t *testing.T, i int, err error) (ok bool) {\n \tif _, ok := err.(UnknownAuthorityError); !ok {\n \t\tt.Errorf(\"#%d: error was not UnknownAuthorityError: %s\", i, err)\n \t\treturn false\n \t}\n \treturn true\n }\n \n-func certificateFromPEM(pemBytes string) (*Certificate, os.Error) {\n+func certificateFromPEM(pemBytes string) (*Certificate, error) {\n \tblock, _ := pem.Decode([]byte(pemBytes))\n \tif block == nil {\n-\t\treturn nil, os.NewError(\"failed to decode PEM\")\n+\t\treturn nil, errors.New(\"failed to decode PEM\")\n \t}\n \treturn ParseCertificate(block.Bytes)\n }"}, {"sha": "da8b28337ebe1d01c67251f42ab12592e38b350d", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -15,8 +15,8 @@ import (\n \t\"crypto/sha1\"\n \t\"crypto/x509/pkix\"\n \t\"encoding/pem\"\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n \t\"time\"\n )\n \n@@ -29,20 +29,20 @@ type pkixPublicKey struct {\n \n // ParsePKIXPublicKey parses a DER encoded public key. These values are\n // typically found in PEM blocks with \"BEGIN PUBLIC KEY\".\n-func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err os.Error) {\n+func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error) {\n \tvar pki publicKeyInfo\n \tif _, err = asn1.Unmarshal(derBytes, &pki); err != nil {\n \t\treturn\n \t}\n \talgo := getPublicKeyAlgorithmFromOID(pki.Algorithm.Algorithm)\n \tif algo == UnknownPublicKeyAlgorithm {\n-\t\treturn nil, os.NewError(\"ParsePKIXPublicKey: unknown public key algorithm\")\n+\t\treturn nil, errors.New(\"ParsePKIXPublicKey: unknown public key algorithm\")\n \t}\n \treturn parsePublicKey(algo, &pki)\n }\n \n // MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.\n-func MarshalPKIXPublicKey(pub interface{}) ([]byte, os.Error) {\n+func MarshalPKIXPublicKey(pub interface{}) ([]byte, error) {\n \tvar pubBytes []byte\n \n \tswitch pub := pub.(type) {\n@@ -52,7 +52,7 @@ func MarshalPKIXPublicKey(pub interface{}) ([]byte, os.Error) {\n \t\t\tE: pub.E,\n \t\t})\n \tdefault:\n-\t\treturn nil, os.NewError(\"MarshalPKIXPublicKey: unknown public key type\")\n+\t\treturn nil, errors.New(\"MarshalPKIXPublicKey: unknown public key type\")\n \t}\n \n \tpkix := pkixPublicKey{\n@@ -331,7 +331,7 @@ type Certificate struct {\n // that involves algorithms that are not currently implemented.\n type UnsupportedAlgorithmError struct{}\n \n-func (UnsupportedAlgorithmError) String() string {\n+func (UnsupportedAlgorithmError) Error() string {\n \treturn \"cannot verify signature: algorithm unimplemented\"\n }\n \n@@ -340,7 +340,7 @@ func (UnsupportedAlgorithmError) String() string {\n // certificate signing key.\n type ConstraintViolationError struct{}\n \n-func (ConstraintViolationError) String() string {\n+func (ConstraintViolationError) Error() string {\n \treturn \"invalid signature: parent certificate cannot sign this kind of certificate\"\n }\n \n@@ -350,7 +350,7 @@ func (c *Certificate) Equal(other *Certificate) bool {\n \n // CheckSignatureFrom verifies that the signature on c is a valid signature\n // from parent.\n-func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err os.Error) {\n+func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err error) {\n \t// RFC 5280, 4.2.1.9:\n \t// \"If the basic constraints extension is not present in a version 3\n \t// certificate, or the extension is present but the cA boolean is not\n@@ -376,7 +376,7 @@ func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err os.Error) {\n \n // CheckSignature verifies that signature is a valid signature over signed from\n // c's public key.\n-func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) (err os.Error) {\n+func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) (err error) {\n \tvar hashType crypto.Hash\n \n \tswitch algo {\n@@ -409,25 +409,25 @@ func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature\n \t\t\treturn err\n \t\t}\n \t\tif dsaSig.R.Sign() <= 0 || dsaSig.S.Sign() <= 0 {\n-\t\t\treturn os.NewError(\"DSA signature contained zero or negative values\")\n+\t\t\treturn errors.New(\"DSA signature contained zero or negative values\")\n \t\t}\n \t\tif !dsa.Verify(pub, digest, dsaSig.R, dsaSig.S) {\n-\t\t\treturn os.NewError(\"DSA verification failure\")\n+\t\t\treturn errors.New(\"DSA verification failure\")\n \t\t}\n \t\treturn\n \t}\n \treturn UnsupportedAlgorithmError{}\n }\n \n // CheckCRLSignature checks that the signature in crl is from c.\n-func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) (err os.Error) {\n+func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) (err error) {\n \talgo := getSignatureAlgorithmFromOID(crl.SignatureAlgorithm.Algorithm)\n \treturn c.CheckSignature(algo, crl.TBSCertList.Raw, crl.SignatureValue.RightAlign())\n }\n \n type UnhandledCriticalExtension struct{}\n \n-func (h UnhandledCriticalExtension) String() string {\n+func (h UnhandledCriticalExtension) Error() string {\n \treturn \"unhandled critical extension\"\n }\n \n@@ -454,7 +454,7 @@ type generalSubtree struct {\n \tMax  int    `asn1:\"optional,tag:1\"`\n }\n \n-func parsePublicKey(algo PublicKeyAlgorithm, keyData *publicKeyInfo) (interface{}, os.Error) {\n+func parsePublicKey(algo PublicKeyAlgorithm, keyData *publicKeyInfo) (interface{}, error) {\n \tasn1Data := keyData.PublicKey.RightAlign()\n \tswitch algo {\n \tcase RSA:\n@@ -482,7 +482,7 @@ func parsePublicKey(algo PublicKeyAlgorithm, keyData *publicKeyInfo) (interface{\n \t\t\treturn nil, err\n \t\t}\n \t\tif p.Sign() <= 0 || params.P.Sign() <= 0 || params.Q.Sign() <= 0 || params.G.Sign() <= 0 {\n-\t\t\treturn nil, os.NewError(\"zero or negative DSA parameter\")\n+\t\t\treturn nil, errors.New(\"zero or negative DSA parameter\")\n \t\t}\n \t\tpub := &dsa.PublicKey{\n \t\t\tParameters: dsa.Parameters{\n@@ -499,7 +499,7 @@ func parsePublicKey(algo PublicKeyAlgorithm, keyData *publicKeyInfo) (interface{\n \tpanic(\"unreachable\")\n }\n \n-func parseCertificate(in *certificate) (*Certificate, os.Error) {\n+func parseCertificate(in *certificate) (*Certificate, error) {\n \tout := new(Certificate)\n \tout.Raw = in.Raw\n \tout.RawTBSCertificate = in.TBSCertificate.Raw\n@@ -513,14 +513,14 @@ func parseCertificate(in *certificate) (*Certificate, os.Error) {\n \n \tout.PublicKeyAlgorithm =\n \t\tgetPublicKeyAlgorithmFromOID(in.TBSCertificate.PublicKey.Algorithm.Algorithm)\n-\tvar err os.Error\n+\tvar err error\n \tout.PublicKey, err = parsePublicKey(out.PublicKeyAlgorithm, &in.TBSCertificate.PublicKey)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n \tif in.TBSCertificate.SerialNumber.Sign() < 0 {\n-\t\treturn nil, os.NewError(\"negative serial number\")\n+\t\treturn nil, errors.New(\"negative serial number\")\n \t}\n \n \tout.Version = in.TBSCertificate.Version + 1\n@@ -737,7 +737,7 @@ func parseCertificate(in *certificate) (*Certificate, os.Error) {\n }\n \n // ParseCertificate parses a single certificate from the given ASN.1 DER data.\n-func ParseCertificate(asn1Data []byte) (*Certificate, os.Error) {\n+func ParseCertificate(asn1Data []byte) (*Certificate, error) {\n \tvar cert certificate\n \trest, err := asn1.Unmarshal(asn1Data, &cert)\n \tif err != nil {\n@@ -752,12 +752,12 @@ func ParseCertificate(asn1Data []byte) (*Certificate, os.Error) {\n \n // ParseCertificates parses one or more certificates from the given ASN.1 DER\n // data. The certificates must be concatenated with no intermediate padding.\n-func ParseCertificates(asn1Data []byte) ([]*Certificate, os.Error) {\n+func ParseCertificates(asn1Data []byte) ([]*Certificate, error) {\n \tvar v []*certificate\n \n \tfor len(asn1Data) > 0 {\n \t\tcert := new(certificate)\n-\t\tvar err os.Error\n+\t\tvar err error\n \t\tasn1Data, err = asn1.Unmarshal(asn1Data, cert)\n \t\tif err != nil {\n \t\t\treturn nil, err\n@@ -794,7 +794,7 @@ var (\n \toidExtensionNameConstraints     = []int{2, 5, 29, 30}\n )\n \n-func buildExtensions(template *Certificate) (ret []pkix.Extension, err os.Error) {\n+func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \tret = make([]pkix.Extension, 7 /* maximum number of elements. */ )\n \tn := 0\n \n@@ -910,7 +910,7 @@ var (\n // signee and priv is the private key of the signer.\n //\n // The returned slice is the certificate in DER encoding.\n-func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.PublicKey, priv *rsa.PrivateKey) (cert []byte, err os.Error) {\n+func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.PublicKey, priv *rsa.PrivateKey) (cert []byte, err error) {\n \tasn1PublicKey, err := asn1.Marshal(rsaPublicKey{\n \t\tN: pub.N,\n \t\tE: pub.E,\n@@ -984,7 +984,7 @@ var pemType = \"X509 CRL\"\n // encoded CRLs will appear where they should be DER encoded, so this function\n // will transparently handle PEM encoding as long as there isn't any leading\n // garbage.\n-func ParseCRL(crlBytes []byte) (certList *pkix.CertificateList, err os.Error) {\n+func ParseCRL(crlBytes []byte) (certList *pkix.CertificateList, err error) {\n \tif bytes.HasPrefix(crlBytes, pemCRLPrefix) {\n \t\tblock, _ := pem.Decode(crlBytes)\n \t\tif block != nil && block.Type == pemType {\n@@ -995,7 +995,7 @@ func ParseCRL(crlBytes []byte) (certList *pkix.CertificateList, err os.Error) {\n }\n \n // ParseDERCRL parses a DER encoded CRL from the given bytes.\n-func ParseDERCRL(derBytes []byte) (certList *pkix.CertificateList, err os.Error) {\n+func ParseDERCRL(derBytes []byte) (certList *pkix.CertificateList, err error) {\n \tcertList = new(pkix.CertificateList)\n \t_, err = asn1.Unmarshal(derBytes, certList)\n \tif err != nil {\n@@ -1006,7 +1006,7 @@ func ParseDERCRL(derBytes []byte) (certList *pkix.CertificateList, err os.Error)\n \n // CreateCRL returns a DER encoded CRL, signed by this Certificate, that\n // contains the given list of revoked certificates.\n-func (c *Certificate) CreateCRL(rand io.Reader, priv *rsa.PrivateKey, revokedCerts []pkix.RevokedCertificate, now, expiry *time.Time) (crlBytes []byte, err os.Error) {\n+func (c *Certificate) CreateCRL(rand io.Reader, priv *rsa.PrivateKey, revokedCerts []pkix.RevokedCertificate, now, expiry *time.Time) (crlBytes []byte, err error) {\n \ttbsCertList := pkix.TBSCertificateList{\n \t\tVersion: 2,\n \t\tSignature: pkix.AlgorithmIdentifier{"}, {"sha": "64d933c2b67eef7a3f58b3d3a4f08968b3da0dc6", "filename": "libgo/go/crypto/xtea/cipher.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,10 +8,7 @@ package xtea\n \n // For details, see http://www.cix.co.uk/~klockstone/xtea.pdf\n \n-import (\n-\t\"os\"\n-\t\"strconv\"\n-)\n+import \"strconv\"\n \n // The XTEA block size in bytes.\n const BlockSize = 8\n@@ -24,14 +21,14 @@ type Cipher struct {\n \n type KeySizeError int\n \n-func (k KeySizeError) String() string {\n+func (k KeySizeError) Error() string {\n \treturn \"crypto/xtea: invalid key size \" + strconv.Itoa(int(k))\n }\n \n // NewCipher creates and returns a new Cipher.\n // The key argument should be the XTEA key.\n // XTEA only supports 128 bit (16 byte) keys.\n-func NewCipher(key []byte) (*Cipher, os.Error) {\n+func NewCipher(key []byte) (*Cipher, error) {\n \tk := len(key)\n \tswitch k {\n \tdefault:"}, {"sha": "ae0f567b9df811c241a5a0b47cabd2dfe22e8c33", "filename": "libgo/go/csv/reader.go", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcsv%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcsv%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcsv%2Freader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -52,30 +52,30 @@ package csv\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"os\"\n \t\"unicode\"\n )\n \n // A ParseError is returned for parsing errors.\n // The first line is 1.  The first column is 0.\n type ParseError struct {\n-\tLine   int      // Line where the error occurred\n-\tColumn int      // Column (rune index) where the error occurred\n-\tError  os.Error // The actual error\n+\tLine   int   // Line where the error occurred\n+\tColumn int   // Column (rune index) where the error occurred\n+\tErr    error // The actual error\n }\n \n-func (e *ParseError) String() string {\n-\treturn fmt.Sprintf(\"line %d, column %d: %s\", e.Line, e.Column, e.Error)\n+func (e *ParseError) Error() string {\n+\treturn fmt.Sprintf(\"line %d, column %d: %s\", e.Line, e.Column, e.Err)\n }\n \n // These are the errors that can be returned in ParseError.Error\n var (\n-\tErrTrailingComma = os.NewError(\"extra delimiter at end of line\")\n-\tErrBareQuote     = os.NewError(\"bare \\\" in non-quoted-field\")\n-\tErrQuote         = os.NewError(\"extraneous \\\" in field\")\n-\tErrFieldCount    = os.NewError(\"wrong number of fields in line\")\n+\tErrTrailingComma = errors.New(\"extra delimiter at end of line\")\n+\tErrBareQuote     = errors.New(\"bare \\\" in non-quoted-field\")\n+\tErrQuote         = errors.New(\"extraneous \\\" in field\")\n+\tErrFieldCount    = errors.New(\"wrong number of fields in line\")\n )\n \n // A Reader reads records from a CSV-encoded file.\n@@ -122,17 +122,17 @@ func NewReader(r io.Reader) *Reader {\n }\n \n // error creates a new ParseError based on err.\n-func (r *Reader) error(err os.Error) os.Error {\n+func (r *Reader) error(err error) error {\n \treturn &ParseError{\n \t\tLine:   r.line,\n \t\tColumn: r.column,\n-\t\tError:  err,\n+\t\tErr:    err,\n \t}\n }\n \n // Read reads one record from r.  The record is a slice of strings with each\n // string representing one field.\n-func (r *Reader) Read() (record []string, err os.Error) {\n+func (r *Reader) Read() (record []string, err error) {\n \tfor {\n \t\trecord, err = r.parseRecord()\n \t\tif record != nil {\n@@ -156,10 +156,10 @@ func (r *Reader) Read() (record []string, err os.Error) {\n \n // ReadAll reads all the remaining records from r.\n // Each record is a slice of fields.\n-func (r *Reader) ReadAll() (records [][]string, err os.Error) {\n+func (r *Reader) ReadAll() (records [][]string, err error) {\n \tfor {\n \t\trecord, err := r.Read()\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\treturn records, nil\n \t\t}\n \t\tif err != nil {\n@@ -173,7 +173,7 @@ func (r *Reader) ReadAll() (records [][]string, err os.Error) {\n // readRune reads one rune from r, folding \\r\\n to \\n and keeping track\n // of how far into the line we have read.  r.column will point to the start\n // of this rune, not the end of this rune.\n-func (r *Reader) readRune() (rune, os.Error) {\n+func (r *Reader) readRune() (rune, error) {\n \tr1, _, err := r.r.ReadRune()\n \n \t// Handle \\r\\n here.  We make the simplifying assumption that\n@@ -199,7 +199,7 @@ func (r *Reader) unreadRune() {\n }\n \n // skip reads runes up to and including the rune delim or until error.\n-func (r *Reader) skip(delim rune) os.Error {\n+func (r *Reader) skip(delim rune) error {\n \tfor {\n \t\tr1, err := r.readRune()\n \t\tif err != nil {\n@@ -213,7 +213,7 @@ func (r *Reader) skip(delim rune) os.Error {\n }\n \n // parseRecord reads and parses a single csv record from r.\n-func (r *Reader) parseRecord() (fields []string, err os.Error) {\n+func (r *Reader) parseRecord() (fields []string, err error) {\n \t// Each record starts on a new line.  We increment our line\n \t// number (lines start at 1, not 0) and set column to -1\n \t// so as we increment in readRune it points to the character we read.\n@@ -240,7 +240,7 @@ func (r *Reader) parseRecord() (fields []string, err os.Error) {\n \t\tif haveField {\n \t\t\tfields = append(fields, r.field.String())\n \t\t}\n-\t\tif delim == '\\n' || err == os.EOF {\n+\t\tif delim == '\\n' || err == io.EOF {\n \t\t\treturn fields, err\n \t\t} else if err != nil {\n \t\t\treturn nil, err\n@@ -252,15 +252,15 @@ func (r *Reader) parseRecord() (fields []string, err os.Error) {\n // parseField parses the next field in the record.  The read field is\n // located in r.field.  Delim is the first character not part of the field\n // (r.Comma or '\\n').\n-func (r *Reader) parseField() (haveField bool, delim rune, err os.Error) {\n+func (r *Reader) parseField() (haveField bool, delim rune, err error) {\n \tr.field.Reset()\n \n \tr1, err := r.readRune()\n \tif err != nil {\n \t\t// If we have EOF and are not at the start of a line\n \t\t// then we return the empty field.  We have already\n \t\t// checked for trailing commas if needed.\n-\t\tif err == os.EOF && r.column != 0 {\n+\t\tif err == io.EOF && r.column != 0 {\n \t\t\treturn true, 0, err\n \t\t}\n \t\treturn false, 0, err\n@@ -292,7 +292,7 @@ func (r *Reader) parseField() (haveField bool, delim rune, err os.Error) {\n \t\tfor {\n \t\t\tr1, err = r.readRune()\n \t\t\tif err != nil {\n-\t\t\t\tif err == os.EOF {\n+\t\t\t\tif err == io.EOF {\n \t\t\t\t\tif r.LazyQuotes {\n \t\t\t\t\t\treturn true, 0, err\n \t\t\t\t\t}\n@@ -342,7 +342,7 @@ func (r *Reader) parseField() (haveField bool, delim rune, err os.Error) {\n \t}\n \n \tif err != nil {\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\treturn true, 0, err\n \t\t}\n \t\treturn false, 0, err\n@@ -362,7 +362,7 @@ func (r *Reader) parseField() (haveField bool, delim rune, err os.Error) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif err == os.EOF || r1 == '\\n' {\n+\t\tif err == io.EOF || r1 == '\\n' {\n \t\t\tr.column = c // report the comma\n \t\t\treturn false, 0, r.error(ErrTrailingComma)\n \t\t}"}, {"sha": "5fd84a76bdfb830db453e7d2d2674870a5846956", "filename": "libgo/go/csv/reader_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcsv%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcsv%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcsv%2Freader_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -267,7 +267,7 @@ func TestRead(t *testing.T) {\n \t\tout, err := r.ReadAll()\n \t\tperr, _ := err.(*ParseError)\n \t\tif tt.Error != \"\" {\n-\t\t\tif err == nil || !strings.Contains(err.String(), tt.Error) {\n+\t\t\tif err == nil || !strings.Contains(err.Error(), tt.Error) {\n \t\t\t\tt.Errorf(\"%s: error %v, want error %q\", tt.Name, err, tt.Error)\n \t\t\t} else if tt.Line != 0 && (tt.Line != perr.Line || tt.Column != perr.Column) {\n \t\t\t\tt.Errorf(\"%s: error at %d:%d expected %d:%d\", tt.Name, perr.Line, perr.Column, tt.Line, tt.Column)"}, {"sha": "5ea20e100e802211dc4a90f92c9d434ad536af28", "filename": "libgo/go/csv/writer.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcsv%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fcsv%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcsv%2Fwriter.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package csv\n import (\n \t\"bufio\"\n \t\"io\"\n-\t\"os\"\n \t\"strings\"\n \t\"unicode\"\n \t\"utf8\"\n@@ -38,7 +37,7 @@ func NewWriter(w io.Writer) *Writer {\n \n // Writer writes a single CSV record to w along with any necessary quoting.\n // A record is a slice of strings with each string being one field.\n-func (w *Writer) Write(record []string) (err os.Error) {\n+func (w *Writer) Write(record []string) (err error) {\n \tfor n, field := range record {\n \t\tif n > 0 {\n \t\t\tif _, err = w.w.WriteRune(w.Comma); err != nil {\n@@ -98,7 +97,7 @@ func (w *Writer) Flush() {\n }\n \n // WriteAll writes multiple CSV records to w using Write and then calls Flush.\n-func (w *Writer) WriteAll(records [][]string) (err os.Error) {\n+func (w *Writer) WriteAll(records [][]string) (err error) {\n \tfor _, record := range records {\n \t\terr = w.Write(record)\n \t\tif err != nil {"}, {"sha": "6b4af7d53dcb8ef0e006a69fe8032c3e868c7c5a", "filename": "libgo/go/debug/dwarf/buf.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fdwarf%2Fbuf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fdwarf%2Fbuf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fbuf.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ package dwarf\n \n import (\n \t\"encoding/binary\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -20,7 +19,7 @@ type buf struct {\n \toff      Offset\n \tdata     []byte\n \taddrsize int\n-\terr      os.Error\n+\terr      error\n }\n \n func makeBuf(d *Data, name string, off Offset, data []byte, addrsize int) buf {\n@@ -146,9 +145,9 @@ func (b *buf) error(s string) {\n type DecodeError struct {\n \tName   string\n \tOffset Offset\n-\tError  string\n+\tErr    string\n }\n \n-func (e DecodeError) String() string {\n-\treturn \"decoding dwarf section \" + e.Name + \" at offset 0x\" + strconv.Itob64(int64(e.Offset), 16) + \": \" + e.Error\n+func (e DecodeError) Error() string {\n+\treturn \"decoding dwarf section \" + e.Name + \" at offset 0x\" + strconv.Itob64(int64(e.Offset), 16) + \": \" + e.Err\n }"}, {"sha": "2885d8fa26cccea2f15259d2bc96da11ebd9fa69", "filename": "libgo/go/debug/dwarf/entry.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,7 +10,7 @@\n \n package dwarf\n \n-import \"os\"\n+import \"errors\"\n \n // a single entry's description: a sequence of attributes\n type abbrev struct {\n@@ -29,7 +29,7 @@ type abbrevTable map[uint32]abbrev\n \n // ParseAbbrev returns the abbreviation table that starts at byte off\n // in the .debug_abbrev section.\n-func (d *Data) parseAbbrev(off uint32) (abbrevTable, os.Error) {\n+func (d *Data) parseAbbrev(off uint32) (abbrevTable, error) {\n \tif m, ok := d.abbrevCache[off]; ok {\n \t\treturn m, nil\n \t}\n@@ -232,7 +232,7 @@ func (b *buf) entry(atab abbrevTable, ubase Offset) *Entry {\n type Reader struct {\n \tb            buf\n \td            *Data\n-\terr          os.Error\n+\terr          error\n \tunit         int\n \tlastChildren bool   // .Children of last entry returned by Next\n \tlastSibling  Offset // .Val(AttrSibling) of last entry returned by Next\n@@ -273,7 +273,7 @@ func (r *Reader) Seek(off Offset) {\n \t\t\treturn\n \t\t}\n \t}\n-\tr.err = os.NewError(\"offset out of range\")\n+\tr.err = errors.New(\"offset out of range\")\n }\n \n // maybeNextUnit advances to the next unit if this one is finished.\n@@ -289,7 +289,7 @@ func (r *Reader) maybeNextUnit() {\n // It returns nil, nil when it reaches the end of the section.\n // It returns an error if the current offset is invalid or the data at the\n // offset cannot be decoded as a valid Entry.\n-func (r *Reader) Next() (*Entry, os.Error) {\n+func (r *Reader) Next() (*Entry, error) {\n \tif r.err != nil {\n \t\treturn nil, r.err\n \t}"}, {"sha": "9543297e189cd42a2bda67602df4cbd814914f05", "filename": "libgo/go/debug/dwarf/open.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,10 +7,7 @@\n // http://dwarfstd.org/doc/dwarf-2.0.0.pdf\n package dwarf\n \n-import (\n-\t\"encoding/binary\"\n-\t\"os\"\n-)\n+import \"encoding/binary\"\n \n // Data represents the DWARF debugging information\n // loaded from an executable file (for example, an ELF or Mach-O executable).\n@@ -40,7 +37,7 @@ type Data struct {\n // The []byte arguments are the data from the corresponding debug section\n // in the object file; for example, for an ELF object, abbrev is the contents of\n // the \".debug_abbrev\" section.\n-func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Data, os.Error) {\n+func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Data, error) {\n \td := &Data{\n \t\tabbrev:      abbrev,\n \t\taranges:     aranges,"}, {"sha": "e8ce8d57b8c93019e62431bf783c2fc5d096c6d3", "filename": "libgo/go/debug/dwarf/type.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,10 +8,7 @@\n \n package dwarf\n \n-import (\n-\t\"os\"\n-\t\"strconv\"\n-)\n+import \"strconv\"\n \n // A Type conventionally represents a pointer to any of the\n // specific Type structures (CharType, StructType, etc.).\n@@ -254,7 +251,7 @@ func (t *TypedefType) String() string { return t.Name }\n \n func (t *TypedefType) Size() int64 { return t.Type.Size() }\n \n-func (d *Data) Type(off Offset) (Type, os.Error) {\n+func (d *Data) Type(off Offset) (Type, error) {\n \tif t, ok := d.typeCache[off]; ok {\n \t\treturn t, nil\n \t}"}, {"sha": "c10d75dbdc9f139c08c77ef7bcc0994ca77e0ab8", "filename": "libgo/go/debug/dwarf/unit.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fdwarf%2Funit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fdwarf%2Funit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Funit.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,10 +4,7 @@\n \n package dwarf\n \n-import (\n-\t\"os\"\n-\t\"strconv\"\n-)\n+import \"strconv\"\n \n // DWARF debug info is split into a sequence of compilation units.\n // Each unit has its own abbreviation table and address size.\n@@ -20,7 +17,7 @@ type unit struct {\n \taddrsize int\n }\n \n-func (d *Data) parseUnits() ([]unit, os.Error) {\n+func (d *Data) parseUnits() ([]unit, error) {\n \t// Count units.\n \tnunit := 0\n \tb := makeBuf(d, \"info\", 0, d.info, 0)"}, {"sha": "184ca8375b548e1f474f1392d4aa074b29f037cf", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"bytes\"\n \t\"debug/dwarf\"\n \t\"encoding/binary\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n@@ -71,17 +72,17 @@ type Section struct {\n }\n \n // Data reads and returns the contents of the ELF section.\n-func (s *Section) Data() ([]byte, os.Error) {\n+func (s *Section) Data() ([]byte, error) {\n \tdat := make([]byte, s.sr.Size())\n \tn, err := s.sr.ReadAt(dat, 0)\n \treturn dat[0:n], err\n }\n \n // stringTable reads and returns the string table given by the\n // specified link value.\n-func (f *File) stringTable(link uint32) ([]byte, os.Error) {\n+func (f *File) stringTable(link uint32) ([]byte, error) {\n \tif link <= 0 || link >= uint32(len(f.Sections)) {\n-\t\treturn nil, os.NewError(\"section has invalid string table link\")\n+\t\treturn nil, errors.New(\"section has invalid string table link\")\n \t}\n \treturn f.Sections[link].Data()\n }\n@@ -136,7 +137,7 @@ type FormatError struct {\n \tval interface{}\n }\n \n-func (e *FormatError) String() string {\n+func (e *FormatError) Error() string {\n \tmsg := e.msg\n \tif e.val != nil {\n \t\tmsg += fmt.Sprintf(\" '%v' \", e.val)\n@@ -146,7 +147,7 @@ func (e *FormatError) String() string {\n }\n \n // Open opens the named file using os.Open and prepares it for use as an ELF binary.\n-func Open(name string) (*File, os.Error) {\n+func Open(name string) (*File, error) {\n \tf, err := os.Open(name)\n \tif err != nil {\n \t\treturn nil, err\n@@ -163,8 +164,8 @@ func Open(name string) (*File, os.Error) {\n // Close closes the File.\n // If the File was created using NewFile directly instead of Open,\n // Close has no effect.\n-func (f *File) Close() os.Error {\n-\tvar err os.Error\n+func (f *File) Close() error {\n+\tvar err error\n \tif f.closer != nil {\n \t\terr = f.closer.Close()\n \t\tf.closer = nil\n@@ -185,7 +186,7 @@ func (f *File) SectionByType(typ SectionType) *Section {\n \n // NewFile creates a new File for accessing an ELF binary in an underlying reader.\n // The ELF binary is expected to start at position 0 in the ReaderAt.\n-func NewFile(r io.ReaderAt) (*File, os.Error) {\n+func NewFile(r io.ReaderAt) (*File, error) {\n \tsr := io.NewSectionReader(r, 0, 1<<63-1)\n \t// Read and decode ELF identifier\n \tvar ident [16]uint8\n@@ -381,7 +382,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \n // getSymbols returns a slice of Symbols from parsing the symbol table\n // with the given type, along with the associated string table.\n-func (f *File) getSymbols(typ SectionType) ([]Symbol, []byte, os.Error) {\n+func (f *File) getSymbols(typ SectionType) ([]Symbol, []byte, error) {\n \tswitch f.Class {\n \tcase ELFCLASS64:\n \t\treturn f.getSymbols64(typ)\n@@ -390,27 +391,27 @@ func (f *File) getSymbols(typ SectionType) ([]Symbol, []byte, os.Error) {\n \t\treturn f.getSymbols32(typ)\n \t}\n \n-\treturn nil, nil, os.NewError(\"not implemented\")\n+\treturn nil, nil, errors.New(\"not implemented\")\n }\n \n-func (f *File) getSymbols32(typ SectionType) ([]Symbol, []byte, os.Error) {\n+func (f *File) getSymbols32(typ SectionType) ([]Symbol, []byte, error) {\n \tsymtabSection := f.SectionByType(typ)\n \tif symtabSection == nil {\n-\t\treturn nil, nil, os.NewError(\"no symbol section\")\n+\t\treturn nil, nil, errors.New(\"no symbol section\")\n \t}\n \n \tdata, err := symtabSection.Data()\n \tif err != nil {\n-\t\treturn nil, nil, os.NewError(\"cannot load symbol section\")\n+\t\treturn nil, nil, errors.New(\"cannot load symbol section\")\n \t}\n \tsymtab := bytes.NewBuffer(data)\n \tif symtab.Len()%Sym32Size != 0 {\n-\t\treturn nil, nil, os.NewError(\"length of symbol section is not a multiple of SymSize\")\n+\t\treturn nil, nil, errors.New(\"length of symbol section is not a multiple of SymSize\")\n \t}\n \n \tstrdata, err := f.stringTable(symtabSection.Link)\n \tif err != nil {\n-\t\treturn nil, nil, os.NewError(\"cannot load string table section\")\n+\t\treturn nil, nil, errors.New(\"cannot load string table section\")\n \t}\n \n \t// The first entry is all zeros.\n@@ -436,24 +437,24 @@ func (f *File) getSymbols32(typ SectionType) ([]Symbol, []byte, os.Error) {\n \treturn symbols, strdata, nil\n }\n \n-func (f *File) getSymbols64(typ SectionType) ([]Symbol, []byte, os.Error) {\n+func (f *File) getSymbols64(typ SectionType) ([]Symbol, []byte, error) {\n \tsymtabSection := f.SectionByType(typ)\n \tif symtabSection == nil {\n-\t\treturn nil, nil, os.NewError(\"no symbol section\")\n+\t\treturn nil, nil, errors.New(\"no symbol section\")\n \t}\n \n \tdata, err := symtabSection.Data()\n \tif err != nil {\n-\t\treturn nil, nil, os.NewError(\"cannot load symbol section\")\n+\t\treturn nil, nil, errors.New(\"cannot load symbol section\")\n \t}\n \tsymtab := bytes.NewBuffer(data)\n \tif symtab.Len()%Sym64Size != 0 {\n-\t\treturn nil, nil, os.NewError(\"length of symbol section is not a multiple of Sym64Size\")\n+\t\treturn nil, nil, errors.New(\"length of symbol section is not a multiple of Sym64Size\")\n \t}\n \n \tstrdata, err := f.stringTable(symtabSection.Link)\n \tif err != nil {\n-\t\treturn nil, nil, os.NewError(\"cannot load string table section\")\n+\t\treturn nil, nil, errors.New(\"cannot load string table section\")\n \t}\n \n \t// The first entry is all zeros.\n@@ -506,17 +507,17 @@ func (f *File) Section(name string) *Section {\n \n // applyRelocations applies relocations to dst. rels is a relocations section\n // in RELA format.\n-func (f *File) applyRelocations(dst []byte, rels []byte) os.Error {\n+func (f *File) applyRelocations(dst []byte, rels []byte) error {\n \tif f.Class == ELFCLASS64 && f.Machine == EM_X86_64 {\n \t\treturn f.applyRelocationsAMD64(dst, rels)\n \t}\n \n-\treturn os.NewError(\"not implemented\")\n+\treturn errors.New(\"not implemented\")\n }\n \n-func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) os.Error {\n+func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) error {\n \tif len(rels)%Sym64Size != 0 {\n-\t\treturn os.NewError(\"length of relocation section is not a multiple of Sym64Size\")\n+\t\treturn errors.New(\"length of relocation section is not a multiple of Sym64Size\")\n \t}\n \n \tsymbols, _, err := f.getSymbols(SHT_SYMTAB)\n@@ -558,7 +559,7 @@ func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) os.Error {\n \treturn nil\n }\n \n-func (f *File) DWARF() (*dwarf.Data, os.Error) {\n+func (f *File) DWARF() (*dwarf.Data, error) {\n \t// There are many other DWARF sections, but these\n \t// are the required ones, and the debug/dwarf package\n \t// does not use the others, so don't bother loading them.\n@@ -596,7 +597,7 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {\n }\n \n // Symbols returns the symbol table for f.\n-func (f *File) Symbols() ([]Symbol, os.Error) {\n+func (f *File) Symbols() ([]Symbol, error) {\n \tsym, _, err := f.getSymbols(SHT_SYMTAB)\n \treturn sym, err\n }\n@@ -611,7 +612,7 @@ type ImportedSymbol struct {\n // referred to by the binary f that are expected to be\n // satisfied by other libraries at dynamic load time.\n // It does not return weak symbols.\n-func (f *File) ImportedSymbols() ([]ImportedSymbol, os.Error) {\n+func (f *File) ImportedSymbols() ([]ImportedSymbol, error) {\n \tsym, str, err := f.getSymbols(SHT_DYNSYM)\n \tif err != nil {\n \t\treturn nil, err\n@@ -721,7 +722,7 @@ func (f *File) gnuVersion(i int, sym *ImportedSymbol) {\n // ImportedLibraries returns the names of all libraries\n // referred to by the binary f that are expected to be\n // linked with the binary at dynamic link time.\n-func (f *File) ImportedLibraries() ([]string, os.Error) {\n+func (f *File) ImportedLibraries() ([]string, error) {\n \tds := f.SectionByType(SHT_DYNAMIC)\n \tif ds == nil {\n \t\t// not dynamic, so no libraries"}, {"sha": "52d7d55a339eaae491dff551d6c1a48e30e6f8ea", "filename": "libgo/go/debug/gosym/symtab.go", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -15,7 +15,6 @@ package gosym\n import (\n \t\"encoding/binary\"\n \t\"fmt\"\n-\t\"os\"\n \t\"strconv\"\n \t\"strings\"\n )\n@@ -105,7 +104,7 @@ type sym struct {\n \tname   []byte\n }\n \n-func walksymtab(data []byte, fn func(sym) os.Error) os.Error {\n+func walksymtab(data []byte, fn func(sym) error) error {\n \tvar s sym\n \tp := data\n \tfor len(p) >= 6 {\n@@ -149,9 +148,9 @@ func walksymtab(data []byte, fn func(sym) os.Error) os.Error {\n \n // NewTable decodes the Go symbol table in data,\n // returning an in-memory representation.\n-func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {\n+func NewTable(symtab []byte, pcln *LineTable) (*Table, error) {\n \tvar n int\n-\terr := walksymtab(symtab, func(s sym) os.Error {\n+\terr := walksymtab(symtab, func(s sym) error {\n \t\tn++\n \t\treturn nil\n \t})\n@@ -165,7 +164,7 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {\n \tnf := 0\n \tnz := 0\n \tlasttyp := uint8(0)\n-\terr = walksymtab(symtab, func(s sym) os.Error {\n+\terr = walksymtab(symtab, func(s sym) error {\n \t\tn := len(t.Syms)\n \t\tt.Syms = t.Syms[0 : n+1]\n \t\tts := &t.Syms[n]\n@@ -355,7 +354,7 @@ func (t *Table) PCToLine(pc uint64) (file string, line int, fn *Func) {\n // LineToPC looks up the first program counter on the given line in\n // the named file.  Returns UnknownPathError or UnknownLineError if\n // there is an error looking up this line.\n-func (t *Table) LineToPC(file string, line int) (pc uint64, fn *Func, err os.Error) {\n+func (t *Table) LineToPC(file string, line int) (pc uint64, fn *Func, err error) {\n \tobj, ok := t.Files[file]\n \tif !ok {\n \t\treturn 0, nil, UnknownFileError(file)\n@@ -466,7 +465,7 @@ pathloop:\n \treturn tos.path, aline - tos.start - tos.offset + 1\n }\n \n-func (o *Obj) alineFromLine(path string, line int) (int, os.Error) {\n+func (o *Obj) alineFromLine(path string, line int) (int, error) {\n \tif line < 1 {\n \t\treturn 0, &UnknownLineError{path, line}\n \t}\n@@ -516,7 +515,7 @@ func (o *Obj) alineFromLine(path string, line int) (int, os.Error) {\n // the symbol table.\n type UnknownFileError string\n \n-func (e UnknownFileError) String() string { return \"unknown file: \" + string(e) }\n+func (e UnknownFileError) Error() string { return \"unknown file: \" + string(e) }\n \n // UnknownLineError represents a failure to map a line to a program\n // counter, either because the line is beyond the bounds of the file\n@@ -526,7 +525,7 @@ type UnknownLineError struct {\n \tLine int\n }\n \n-func (e *UnknownLineError) String() string {\n+func (e *UnknownLineError) Error() string {\n \treturn \"no code at \" + e.File + \":\" + strconv.Itoa(e.Line)\n }\n \n@@ -538,7 +537,7 @@ type DecodingError struct {\n \tval interface{}\n }\n \n-func (e *DecodingError) String() string {\n+func (e *DecodingError) Error() string {\n \tmsg := e.msg\n \tif e.val != nil {\n \t\tmsg += fmt.Sprintf(\" '%v'\", e.val)"}, {"sha": "c7cb90526e844a36403b36f53a8ad8bb979765f2", "filename": "libgo/go/debug/macho/file.go", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"bytes\"\n \t\"debug/dwarf\"\n \t\"encoding/binary\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n@@ -71,7 +72,7 @@ type Segment struct {\n }\n \n // Data reads and returns the contents of the segment.\n-func (s *Segment) Data() ([]byte, os.Error) {\n+func (s *Segment) Data() ([]byte, error) {\n \tdat := make([]byte, s.sr.Size())\n \tn, err := s.sr.ReadAt(dat, 0)\n \treturn dat[0:n], err\n@@ -106,7 +107,7 @@ type Section struct {\n }\n \n // Data reads and returns the contents of the Mach-O section.\n-func (s *Section) Data() ([]byte, os.Error) {\n+func (s *Section) Data() ([]byte, error) {\n \tdat := make([]byte, s.sr.Size())\n \tn, err := s.sr.ReadAt(dat, 0)\n \treturn dat[0:n], err\n@@ -148,7 +149,7 @@ type FormatError struct {\n \tval interface{}\n }\n \n-func (e *FormatError) String() string {\n+func (e *FormatError) Error() string {\n \tmsg := e.msg\n \tif e.val != nil {\n \t\tmsg += fmt.Sprintf(\" '%v'\", e.val)\n@@ -158,7 +159,7 @@ func (e *FormatError) String() string {\n }\n \n // Open opens the named file using os.Open and prepares it for use as a Mach-O binary.\n-func Open(name string) (*File, os.Error) {\n+func Open(name string) (*File, error) {\n \tf, err := os.Open(name)\n \tif err != nil {\n \t\treturn nil, err\n@@ -175,8 +176,8 @@ func Open(name string) (*File, os.Error) {\n // Close closes the File.\n // If the File was created using NewFile directly instead of Open,\n // Close has no effect.\n-func (f *File) Close() os.Error {\n-\tvar err os.Error\n+func (f *File) Close() error {\n+\tvar err error\n \tif f.closer != nil {\n \t\terr = f.closer.Close()\n \t\tf.closer = nil\n@@ -186,7 +187,7 @@ func (f *File) Close() os.Error {\n \n // NewFile creates a new File for accessing a Mach-O binary in an underlying reader.\n // The Mach-O binary is expected to start at position 0 in the ReaderAt.\n-func NewFile(r io.ReaderAt) (*File, os.Error) {\n+func NewFile(r io.ReaderAt) (*File, error) {\n \tf := new(File)\n \tsr := io.NewSectionReader(r, 0, 1<<63-1)\n \n@@ -391,7 +392,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \treturn f, nil\n }\n \n-func (f *File) parseSymtab(symdat, strtab, cmddat []byte, hdr *SymtabCmd, offset int64) (*Symtab, os.Error) {\n+func (f *File) parseSymtab(symdat, strtab, cmddat []byte, hdr *SymtabCmd, offset int64) (*Symtab, error) {\n \tbo := f.ByteOrder\n \tsymtab := make([]Symbol, hdr.Nsyms)\n \tb := bytes.NewBuffer(symdat)\n@@ -463,7 +464,7 @@ func (f *File) Section(name string) *Section {\n }\n \n // DWARF returns the DWARF debug information for the Mach-O file.\n-func (f *File) DWARF() (*dwarf.Data, os.Error) {\n+func (f *File) DWARF() (*dwarf.Data, error) {\n \t// There are many other DWARF sections, but these\n \t// are the required ones, and the debug/dwarf package\n \t// does not use the others, so don't bother loading them.\n@@ -473,7 +474,7 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {\n \t\tname = \"__debug_\" + name\n \t\ts := f.Section(name)\n \t\tif s == nil {\n-\t\t\treturn nil, os.NewError(\"missing Mach-O section \" + name)\n+\t\t\treturn nil, errors.New(\"missing Mach-O section \" + name)\n \t\t}\n \t\tb, err := s.Data()\n \t\tif err != nil && uint64(len(b)) < s.Size {\n@@ -489,7 +490,7 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {\n // ImportedSymbols returns the names of all symbols\n // referred to by the binary f that are expected to be\n // satisfied by other libraries at dynamic load time.\n-func (f *File) ImportedSymbols() ([]string, os.Error) {\n+func (f *File) ImportedSymbols() ([]string, error) {\n \tif f.Dysymtab == nil || f.Symtab == nil {\n \t\treturn nil, &FormatError{0, \"missing symbol table\", nil}\n \t}\n@@ -506,7 +507,7 @@ func (f *File) ImportedSymbols() ([]string, os.Error) {\n // ImportedLibraries returns the paths of all libraries\n // referred to by the binary f that are expected to be\n // linked with the binary at dynamic link time.\n-func (f *File) ImportedLibraries() ([]string, os.Error) {\n+func (f *File) ImportedLibraries() ([]string, error) {\n \tvar all []string\n \tfor _, l := range f.Loads {\n \t\tif lib, ok := l.(*Dylib); ok {"}, {"sha": "6b98a5f45b9b9e12fb5d44b6047309b00ceb3ed0", "filename": "libgo/go/debug/pe/file.go", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,6 +8,7 @@ package pe\n import (\n \t\"debug/dwarf\"\n \t\"encoding/binary\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n@@ -59,7 +60,7 @@ type ImportDirectory struct {\n }\n \n // Data reads and returns the contents of the PE section.\n-func (s *Section) Data() ([]byte, os.Error) {\n+func (s *Section) Data() ([]byte, error) {\n \tdat := make([]byte, s.sr.Size())\n \tn, err := s.sr.ReadAt(dat, 0)\n \treturn dat[0:n], err\n@@ -74,7 +75,7 @@ type FormatError struct {\n \tval interface{}\n }\n \n-func (e *FormatError) String() string {\n+func (e *FormatError) Error() string {\n \tmsg := e.msg\n \tif e.val != nil {\n \t\tmsg += fmt.Sprintf(\" '%v'\", e.val)\n@@ -84,7 +85,7 @@ func (e *FormatError) String() string {\n }\n \n // Open opens the named file using os.Open and prepares it for use as a PE binary.\n-func Open(name string) (*File, os.Error) {\n+func Open(name string) (*File, error) {\n \tf, err := os.Open(name)\n \tif err != nil {\n \t\treturn nil, err\n@@ -101,8 +102,8 @@ func Open(name string) (*File, os.Error) {\n // Close closes the File.\n // If the File was created using NewFile directly instead of Open,\n // Close has no effect.\n-func (f *File) Close() os.Error {\n-\tvar err os.Error\n+func (f *File) Close() error {\n+\tvar err error\n \tif f.closer != nil {\n \t\terr = f.closer.Close()\n \t\tf.closer = nil\n@@ -111,7 +112,7 @@ func (f *File) Close() os.Error {\n }\n \n // NewFile creates a new File for accessing a PE binary in an underlying reader.\n-func NewFile(r io.ReaderAt) (*File, os.Error) {\n+func NewFile(r io.ReaderAt) (*File, error) {\n \tf := new(File)\n \tsr := io.NewSectionReader(r, 0, 1<<63-1)\n \n@@ -124,7 +125,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \t\tvar sign [4]byte\n \t\tr.ReadAt(sign[0:], int64(dosheader[0x3c]))\n \t\tif !(sign[0] == 'P' && sign[1] == 'E' && sign[2] == 0 && sign[3] == 0) {\n-\t\t\treturn nil, os.NewError(\"Invalid PE File Format.\")\n+\t\t\treturn nil, errors.New(\"Invalid PE File Format.\")\n \t\t}\n \t\tbase = int64(dosheader[0x3c]) + 4\n \t} else {\n@@ -135,7 +136,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \t\treturn nil, err\n \t}\n \tif f.FileHeader.Machine != IMAGE_FILE_MACHINE_UNKNOWN && f.FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64 && f.FileHeader.Machine != IMAGE_FILE_MACHINE_I386 {\n-\t\treturn nil, os.NewError(\"Invalid PE File Format.\")\n+\t\treturn nil, errors.New(\"Invalid PE File Format.\")\n \t}\n \t// get symbol string table\n \tsr.Seek(int64(f.FileHeader.PointerToSymbolTable+18*f.FileHeader.NumberOfSymbols), os.SEEK_SET)\n@@ -215,7 +216,7 @@ func (f *File) Section(name string) *Section {\n \treturn nil\n }\n \n-func (f *File) DWARF() (*dwarf.Data, os.Error) {\n+func (f *File) DWARF() (*dwarf.Data, error) {\n \t// There are many other DWARF sections, but these\n \t// are the required ones, and the debug/dwarf package\n \t// does not use the others, so don't bother loading them.\n@@ -242,7 +243,7 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {\n // referred to by the binary f that are expected to be\n // satisfied by other libraries at dynamic load time.\n // It does not return weak symbols.\n-func (f *File) ImportedSymbols() ([]string, os.Error) {\n+func (f *File) ImportedSymbols() ([]string, error) {\n \tpe64 := f.Machine == IMAGE_FILE_MACHINE_AMD64\n \tds := f.Section(\".idata\")\n \tif ds == nil {\n@@ -308,7 +309,7 @@ func (f *File) ImportedSymbols() ([]string, os.Error) {\n // ImportedLibraries returns the names of all libraries\n // referred to by the binary f that are expected to be\n // linked with the binary at dynamic link time.\n-func (f *File) ImportedLibraries() ([]string, os.Error) {\n+func (f *File) ImportedLibraries() ([]string, error) {\n \t// TODO\n \t// cgo -dynimport don't use this for windows PE, so just return.\n \treturn nil, nil"}, {"sha": "6f592f3d727764b75459dd92afc37cee5ab6c845", "filename": "libgo/go/encoding/ascii85/ascii85.go", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ package ascii85\n \n import (\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -93,14 +92,14 @@ func MaxEncodedLen(n int) int { return (n + 3) / 4 * 5 }\n func NewEncoder(w io.Writer) io.WriteCloser { return &encoder{w: w} }\n \n type encoder struct {\n-\terr  os.Error\n+\terr  error\n \tw    io.Writer\n \tbuf  [4]byte    // buffered data waiting to be encoded\n \tnbuf int        // number of bytes in buf\n \tout  [1024]byte // output buffer\n }\n \n-func (e *encoder) Write(p []byte) (n int, err os.Error) {\n+func (e *encoder) Write(p []byte) (n int, err error) {\n \tif e.err != nil {\n \t\treturn 0, e.err\n \t}\n@@ -152,7 +151,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {\n \n // Close flushes any pending output from the encoder.\n // It is an error to call Write after calling Close.\n-func (e *encoder) Close() os.Error {\n+func (e *encoder) Close() error {\n \t// If there's anything left in the buffer, flush it out\n \tif e.err == nil && e.nbuf > 0 {\n \t\tnout := Encode(e.out[0:], e.buf[0:e.nbuf])\n@@ -168,7 +167,7 @@ func (e *encoder) Close() os.Error {\n \n type CorruptInputError int64\n \n-func (e CorruptInputError) String() string {\n+func (e CorruptInputError) Error() string {\n \treturn \"illegal ascii85 data at input byte \" + strconv.Itoa64(int64(e))\n }\n \n@@ -186,7 +185,7 @@ func (e CorruptInputError) String() string {\n //\n // NewDecoder wraps an io.Reader interface around Decode.\n //\n-func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err os.Error) {\n+func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err error) {\n \tvar v uint32\n \tvar nb int\n \tfor i, b := range src {\n@@ -246,8 +245,8 @@ func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err os.Error) {\n func NewDecoder(r io.Reader) io.Reader { return &decoder{r: r} }\n \n type decoder struct {\n-\terr     os.Error\n-\treadErr os.Error\n+\terr     error\n+\treadErr error\n \tr       io.Reader\n \tend     bool       // saw end of message\n \tbuf     [1024]byte // leftover input\n@@ -256,7 +255,7 @@ type decoder struct {\n \toutbuf  [1024]byte\n }\n \n-func (d *decoder) Read(p []byte) (n int, err os.Error) {\n+func (d *decoder) Read(p []byte) (n int, err error) {\n \tif len(p) == 0 {\n \t\treturn 0, nil\n \t}"}, {"sha": "70e67d8b06e092100238ff3b7badd50a595d7bd5", "filename": "libgo/go/encoding/ascii85/ascii85_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,8 +6,8 @@ package ascii85\n \n import (\n \t\"bytes\"\n+\t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -83,11 +83,11 @@ func TestEncoderBuffering(t *testing.T) {\n \t\t\t\tend = len(input)\n \t\t\t}\n \t\t\tn, err := encoder.Write(input[pos:end])\n-\t\t\ttestEqual(t, \"Write(%q) gave error %v, want %v\", input[pos:end], err, os.Error(nil))\n+\t\t\ttestEqual(t, \"Write(%q) gave error %v, want %v\", input[pos:end], err, error(nil))\n \t\t\ttestEqual(t, \"Write(%q) gave length %v, want %v\", input[pos:end], n, end-pos)\n \t\t}\n \t\terr := encoder.Close()\n-\t\ttestEqual(t, \"Close gave error %v, want %v\", err, os.Error(nil))\n+\t\ttestEqual(t, \"Close gave error %v, want %v\", err, error(nil))\n \t\ttestEqual(t, \"Encoding/%d of %q = %q, want %q\", bs, bigtest.decoded, strip85(bb.String()), strip85(bigtest.encoded))\n \t}\n }\n@@ -96,7 +96,7 @@ func TestDecode(t *testing.T) {\n \tfor _, p := range pairs {\n \t\tdbuf := make([]byte, 4*len(p.encoded))\n \t\tndst, nsrc, err := Decode(dbuf, []byte(p.encoded), true)\n-\t\ttestEqual(t, \"Decode(%q) = error %v, want %v\", p.encoded, err, os.Error(nil))\n+\t\ttestEqual(t, \"Decode(%q) = error %v, want %v\", p.encoded, err, error(nil))\n \t\ttestEqual(t, \"Decode(%q) = nsrc %v, want %v\", p.encoded, nsrc, len(p.encoded))\n \t\ttestEqual(t, \"Decode(%q) = ndst %v, want %v\", p.encoded, ndst, len(p.decoded))\n \t\ttestEqual(t, \"Decode(%q) = %q, want %q\", p.encoded, string(dbuf[0:ndst]), p.decoded)\n@@ -113,7 +113,7 @@ func TestDecoder(t *testing.T) {\n \t\ttestEqual(t, \"Read from %q = length %v, want %v\", p.encoded, len(dbuf), len(p.decoded))\n \t\ttestEqual(t, \"Decoding of %q = %q, want %q\", p.encoded, string(dbuf), p.decoded)\n \t\tif err != nil {\n-\t\t\ttestEqual(t, \"Read from %q = %v, want %v\", p.encoded, err, os.EOF)\n+\t\t\ttestEqual(t, \"Read from %q = %v, want %v\", p.encoded, err, io.EOF)\n \t\t}\n \t}\n }\n@@ -125,7 +125,7 @@ func TestDecoderBuffering(t *testing.T) {\n \t\tvar total int\n \t\tfor total = 0; total < len(bigtest.decoded); {\n \t\t\tn, err := decoder.Read(buf[total : total+bs])\n-\t\t\ttestEqual(t, \"Read from %q at pos %d = %d, %v, want _, %v\", bigtest.encoded, total, n, err, os.Error(nil))\n+\t\t\ttestEqual(t, \"Read from %q at pos %d = %d, %v, want _, %v\", bigtest.encoded, total, n, err, error(nil))\n \t\t\ttotal += n\n \t\t}\n \t\ttestEqual(t, \"Decoding/%d of %q = %q, want %q\", bs, bigtest.encoded, string(buf[0:total]), bigtest.decoded)"}, {"sha": "494c760d87dbaa6605552af935692c2f37bda3b4", "filename": "libgo/go/encoding/base32/base32.go", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package base32\n \n import (\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -127,15 +126,15 @@ func (enc *Encoding) Encode(dst, src []byte) {\n }\n \n type encoder struct {\n-\terr  os.Error\n+\terr  error\n \tenc  *Encoding\n \tw    io.Writer\n \tbuf  [5]byte    // buffered data waiting to be encoded\n \tnbuf int        // number of bytes in buf\n \tout  [1024]byte // output buffer\n }\n \n-func (e *encoder) Write(p []byte) (n int, err os.Error) {\n+func (e *encoder) Write(p []byte) (n int, err error) {\n \tif e.err != nil {\n \t\treturn 0, e.err\n \t}\n@@ -187,7 +186,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {\n \n // Close flushes any pending output from the encoder.\n // It is an error to call Write after calling Close.\n-func (e *encoder) Close() os.Error {\n+func (e *encoder) Close() error {\n \t// If there's anything left in the buffer, flush it out\n \tif e.err == nil && e.nbuf > 0 {\n \t\te.enc.Encode(e.out[0:], e.buf[0:e.nbuf])\n@@ -216,15 +215,15 @@ func (enc *Encoding) EncodedLen(n int) int { return (n + 4) / 5 * 8 }\n \n type CorruptInputError int64\n \n-func (e CorruptInputError) String() string {\n+func (e CorruptInputError) Error() string {\n \treturn \"illegal base32 data at input byte \" + strconv.Itoa64(int64(e))\n }\n \n // decode is like Decode but returns an additional 'end' value, which\n // indicates if end-of-message padding was encountered and thus any\n // additional data is an error.  decode also assumes len(src)%8==0,\n // since it is meant for internal use.\n-func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {\n+func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err error) {\n \tfor i := 0; i < len(src)/8 && !end; i++ {\n \t\t// Decode quantum using the base32 alphabet\n \t\tvar dbuf [8]byte\n@@ -290,7 +289,7 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {\n // DecodedLen(len(src)) bytes to dst and returns the number of bytes\n // written.  If src contains invalid base32 data, it will return the\n // number of bytes successfully written and CorruptInputError.\n-func (enc *Encoding) Decode(dst, src []byte) (n int, err os.Error) {\n+func (enc *Encoding) Decode(dst, src []byte) (n int, err error) {\n \tif len(src)%8 != 0 {\n \t\treturn 0, CorruptInputError(len(src) / 8 * 8)\n \t}\n@@ -300,7 +299,7 @@ func (enc *Encoding) Decode(dst, src []byte) (n int, err os.Error) {\n }\n \n type decoder struct {\n-\terr    os.Error\n+\terr    error\n \tenc    *Encoding\n \tr      io.Reader\n \tend    bool       // saw end of message\n@@ -310,7 +309,7 @@ type decoder struct {\n \toutbuf [1024 / 8 * 5]byte\n }\n \n-func (d *decoder) Read(p []byte) (n int, err os.Error) {\n+func (d *decoder) Read(p []byte) (n int, err error) {\n \tif d.err != nil {\n \t\treturn 0, d.err\n \t}"}, {"sha": "facf5d04eeb11dbac9c05e580729bfa1d8e612ef", "filename": "libgo/go/encoding/base32/base32_test.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,8 +6,8 @@ package base32\n \n import (\n \t\"bytes\"\n+\t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -78,11 +78,11 @@ func TestEncoderBuffering(t *testing.T) {\n \t\t\t\tend = len(input)\n \t\t\t}\n \t\t\tn, err := encoder.Write(input[pos:end])\n-\t\t\ttestEqual(t, \"Write(%q) gave error %v, want %v\", input[pos:end], err, os.Error(nil))\n+\t\t\ttestEqual(t, \"Write(%q) gave error %v, want %v\", input[pos:end], err, error(nil))\n \t\t\ttestEqual(t, \"Write(%q) gave length %v, want %v\", input[pos:end], n, end-pos)\n \t\t}\n \t\terr := encoder.Close()\n-\t\ttestEqual(t, \"Close gave error %v, want %v\", err, os.Error(nil))\n+\t\ttestEqual(t, \"Close gave error %v, want %v\", err, error(nil))\n \t\ttestEqual(t, \"Encoding/%d of %q = %q, want %q\", bs, bigtest.decoded, bb.String(), bigtest.encoded)\n \t}\n }\n@@ -91,7 +91,7 @@ func TestDecode(t *testing.T) {\n \tfor _, p := range pairs {\n \t\tdbuf := make([]byte, StdEncoding.DecodedLen(len(p.encoded)))\n \t\tcount, end, err := StdEncoding.decode(dbuf, []byte(p.encoded))\n-\t\ttestEqual(t, \"Decode(%q) = error %v, want %v\", p.encoded, err, os.Error(nil))\n+\t\ttestEqual(t, \"Decode(%q) = error %v, want %v\", p.encoded, err, error(nil))\n \t\ttestEqual(t, \"Decode(%q) = length %v, want %v\", p.encoded, count, len(p.decoded))\n \t\tif len(p.encoded) > 0 {\n \t\t\ttestEqual(t, \"Decode(%q) = end %v, want %v\", p.encoded, end, (p.encoded[len(p.encoded)-1] == '='))\n@@ -107,15 +107,15 @@ func TestDecoder(t *testing.T) {\n \t\tdecoder := NewDecoder(StdEncoding, bytes.NewBufferString(p.encoded))\n \t\tdbuf := make([]byte, StdEncoding.DecodedLen(len(p.encoded)))\n \t\tcount, err := decoder.Read(dbuf)\n-\t\tif err != nil && err != os.EOF {\n+\t\tif err != nil && err != io.EOF {\n \t\t\tt.Fatal(\"Read failed\", err)\n \t\t}\n \t\ttestEqual(t, \"Read from %q = length %v, want %v\", p.encoded, count, len(p.decoded))\n \t\ttestEqual(t, \"Decoding of %q = %q, want %q\", p.encoded, string(dbuf[0:count]), p.decoded)\n-\t\tif err != os.EOF {\n+\t\tif err != io.EOF {\n \t\t\tcount, err = decoder.Read(dbuf)\n \t\t}\n-\t\ttestEqual(t, \"Read from %q = %v, want %v\", p.encoded, err, os.EOF)\n+\t\ttestEqual(t, \"Read from %q = %v, want %v\", p.encoded, err, io.EOF)\n \t}\n }\n \n@@ -126,7 +126,7 @@ func TestDecoderBuffering(t *testing.T) {\n \t\tvar total int\n \t\tfor total = 0; total < len(bigtest.decoded); {\n \t\t\tn, err := decoder.Read(buf[total : total+bs])\n-\t\t\ttestEqual(t, \"Read from %q at pos %d = %d, %v, want _, %v\", bigtest.encoded, total, n, err, os.Error(nil))\n+\t\t\ttestEqual(t, \"Read from %q at pos %d = %d, %v, want _, %v\", bigtest.encoded, total, n, err, error(nil))\n \t\t\ttotal += n\n \t\t}\n \t\ttestEqual(t, \"Decoding/%d of %q = %q, want %q\", bs, bigtest.encoded, string(buf[0:total]), bigtest.decoded)"}, {"sha": "945128947ab268be68822c73999be9f974741b45", "filename": "libgo/go/encoding/base64/base64.go", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package base64\n \n import (\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -114,15 +113,15 @@ func (enc *Encoding) EncodeToString(src []byte) string {\n }\n \n type encoder struct {\n-\terr  os.Error\n+\terr  error\n \tenc  *Encoding\n \tw    io.Writer\n \tbuf  [3]byte    // buffered data waiting to be encoded\n \tnbuf int        // number of bytes in buf\n \tout  [1024]byte // output buffer\n }\n \n-func (e *encoder) Write(p []byte) (n int, err os.Error) {\n+func (e *encoder) Write(p []byte) (n int, err error) {\n \tif e.err != nil {\n \t\treturn 0, e.err\n \t}\n@@ -174,7 +173,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {\n \n // Close flushes any pending output from the encoder.\n // It is an error to call Write after calling Close.\n-func (e *encoder) Close() os.Error {\n+func (e *encoder) Close() error {\n \t// If there's anything left in the buffer, flush it out\n \tif e.err == nil && e.nbuf > 0 {\n \t\te.enc.Encode(e.out[0:], e.buf[0:e.nbuf])\n@@ -203,15 +202,15 @@ func (enc *Encoding) EncodedLen(n int) int { return (n + 2) / 3 * 4 }\n \n type CorruptInputError int64\n \n-func (e CorruptInputError) String() string {\n+func (e CorruptInputError) Error() string {\n \treturn \"illegal base64 data at input byte \" + strconv.Itoa64(int64(e))\n }\n \n // decode is like Decode but returns an additional 'end' value, which\n // indicates if end-of-message padding was encountered and thus any\n // additional data is an error.  decode also assumes len(src)%4==0,\n // since it is meant for internal use.\n-func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {\n+func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err error) {\n \tfor i := 0; i < len(src)/4 && !end; i++ {\n \t\t// Decode quantum using the base64 alphabet\n \t\tvar dbuf [4]byte\n@@ -258,7 +257,7 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {\n // DecodedLen(len(src)) bytes to dst and returns the number of bytes\n // written.  If src contains invalid base64 data, it will return the\n // number of bytes successfully written and CorruptInputError.\n-func (enc *Encoding) Decode(dst, src []byte) (n int, err os.Error) {\n+func (enc *Encoding) Decode(dst, src []byte) (n int, err error) {\n \tif len(src)%4 != 0 {\n \t\treturn 0, CorruptInputError(len(src) / 4 * 4)\n \t}\n@@ -268,14 +267,14 @@ func (enc *Encoding) Decode(dst, src []byte) (n int, err os.Error) {\n }\n \n // DecodeString returns the bytes represented by the base64 string s.\n-func (enc *Encoding) DecodeString(s string) ([]byte, os.Error) {\n+func (enc *Encoding) DecodeString(s string) ([]byte, error) {\n \tdbuf := make([]byte, enc.DecodedLen(len(s)))\n \tn, err := enc.Decode(dbuf, []byte(s))\n \treturn dbuf[:n], err\n }\n \n type decoder struct {\n-\terr    os.Error\n+\terr    error\n \tenc    *Encoding\n \tr      io.Reader\n \tend    bool       // saw end of message\n@@ -285,7 +284,7 @@ type decoder struct {\n \toutbuf [1024 / 4 * 3]byte\n }\n \n-func (d *decoder) Read(p []byte) (n int, err os.Error) {\n+func (d *decoder) Read(p []byte) (n int, err error) {\n \tif d.err != nil {\n \t\treturn 0, d.err\n \t}"}, {"sha": "8310d8ab9e3d1a0cce7a55ce1425ec3085bc7216", "filename": "libgo/go/encoding/base64/base64_test.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,8 +6,8 @@ package base64\n \n import (\n \t\"bytes\"\n+\t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -82,11 +82,11 @@ func TestEncoderBuffering(t *testing.T) {\n \t\t\t\tend = len(input)\n \t\t\t}\n \t\t\tn, err := encoder.Write(input[pos:end])\n-\t\t\ttestEqual(t, \"Write(%q) gave error %v, want %v\", input[pos:end], err, os.Error(nil))\n+\t\t\ttestEqual(t, \"Write(%q) gave error %v, want %v\", input[pos:end], err, error(nil))\n \t\t\ttestEqual(t, \"Write(%q) gave length %v, want %v\", input[pos:end], n, end-pos)\n \t\t}\n \t\terr := encoder.Close()\n-\t\ttestEqual(t, \"Close gave error %v, want %v\", err, os.Error(nil))\n+\t\ttestEqual(t, \"Close gave error %v, want %v\", err, error(nil))\n \t\ttestEqual(t, \"Encoding/%d of %q = %q, want %q\", bs, bigtest.decoded, bb.String(), bigtest.encoded)\n \t}\n }\n@@ -95,15 +95,15 @@ func TestDecode(t *testing.T) {\n \tfor _, p := range pairs {\n \t\tdbuf := make([]byte, StdEncoding.DecodedLen(len(p.encoded)))\n \t\tcount, end, err := StdEncoding.decode(dbuf, []byte(p.encoded))\n-\t\ttestEqual(t, \"Decode(%q) = error %v, want %v\", p.encoded, err, os.Error(nil))\n+\t\ttestEqual(t, \"Decode(%q) = error %v, want %v\", p.encoded, err, error(nil))\n \t\ttestEqual(t, \"Decode(%q) = length %v, want %v\", p.encoded, count, len(p.decoded))\n \t\tif len(p.encoded) > 0 {\n \t\t\ttestEqual(t, \"Decode(%q) = end %v, want %v\", p.encoded, end, (p.encoded[len(p.encoded)-1] == '='))\n \t\t}\n \t\ttestEqual(t, \"Decode(%q) = %q, want %q\", p.encoded, string(dbuf[0:count]), p.decoded)\n \n \t\tdbuf, err = StdEncoding.DecodeString(p.encoded)\n-\t\ttestEqual(t, \"DecodeString(%q) = error %v, want %v\", p.encoded, err, os.Error(nil))\n+\t\ttestEqual(t, \"DecodeString(%q) = error %v, want %v\", p.encoded, err, error(nil))\n \t\ttestEqual(t, \"DecodeString(%q) = %q, want %q\", string(dbuf), p.decoded)\n \t}\n }\n@@ -113,15 +113,15 @@ func TestDecoder(t *testing.T) {\n \t\tdecoder := NewDecoder(StdEncoding, bytes.NewBufferString(p.encoded))\n \t\tdbuf := make([]byte, StdEncoding.DecodedLen(len(p.encoded)))\n \t\tcount, err := decoder.Read(dbuf)\n-\t\tif err != nil && err != os.EOF {\n+\t\tif err != nil && err != io.EOF {\n \t\t\tt.Fatal(\"Read failed\", err)\n \t\t}\n \t\ttestEqual(t, \"Read from %q = length %v, want %v\", p.encoded, count, len(p.decoded))\n \t\ttestEqual(t, \"Decoding of %q = %q, want %q\", p.encoded, string(dbuf[0:count]), p.decoded)\n-\t\tif err != os.EOF {\n+\t\tif err != io.EOF {\n \t\t\tcount, err = decoder.Read(dbuf)\n \t\t}\n-\t\ttestEqual(t, \"Read from %q = %v, want %v\", p.encoded, err, os.EOF)\n+\t\ttestEqual(t, \"Read from %q = %v, want %v\", p.encoded, err, io.EOF)\n \t}\n }\n \n@@ -132,7 +132,7 @@ func TestDecoderBuffering(t *testing.T) {\n \t\tvar total int\n \t\tfor total = 0; total < len(bigtest.decoded); {\n \t\t\tn, err := decoder.Read(buf[total : total+bs])\n-\t\t\ttestEqual(t, \"Read from %q at pos %d = %d, %v, want _, %v\", bigtest.encoded, total, n, err, os.Error(nil))\n+\t\t\ttestEqual(t, \"Read from %q at pos %d = %d, %v, want _, %v\", bigtest.encoded, total, n, err, error(nil))\n \t\t\ttotal += n\n \t\t}\n \t\ttestEqual(t, \"Decoding/%d of %q = %q, want %q\", bs, bigtest.encoded, string(buf[0:total]), bigtest.decoded)"}, {"sha": "65b9f013fcd71da79293f8048f6d5e3d5624db8a", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,9 +8,9 @@\n package binary\n \n import (\n+\t\"errors\"\n \t\"math\"\n \t\"io\"\n-\t\"os\"\n \t\"reflect\"\n )\n \n@@ -124,7 +124,7 @@ func (bigEndian) GoString() string { return \"binary.BigEndian\" }\n // or an array or struct containing only fixed-size values.\n // Bytes read from r are decoded using the specified byte order\n // and written to successive fields of the data.\n-func Read(r io.Reader, order ByteOrder, data interface{}) os.Error {\n+func Read(r io.Reader, order ByteOrder, data interface{}) error {\n \t// Fast path for basic types.\n \tif n := intDestSize(data); n != 0 {\n \t\tvar b [8]byte\n@@ -161,11 +161,11 @@ func Read(r io.Reader, order ByteOrder, data interface{}) os.Error {\n \tcase reflect.Slice:\n \t\tv = d\n \tdefault:\n-\t\treturn os.NewError(\"binary.Read: invalid type \" + d.Type().String())\n+\t\treturn errors.New(\"binary.Read: invalid type \" + d.Type().String())\n \t}\n \tsize := TotalSize(v)\n \tif size < 0 {\n-\t\treturn os.NewError(\"binary.Read: invalid type \" + v.Type().String())\n+\t\treturn errors.New(\"binary.Read: invalid type \" + v.Type().String())\n \t}\n \td := &decoder{order: order, buf: make([]byte, size)}\n \tif _, err := io.ReadFull(r, d.buf); err != nil {\n@@ -183,7 +183,7 @@ func Read(r io.Reader, order ByteOrder, data interface{}) os.Error {\n // or an array or struct containing only fixed-size values.\n // Bytes written to w are encoded using the specified byte order\n // and read from successive fields of the data.\n-func Write(w io.Writer, order ByteOrder, data interface{}) os.Error {\n+func Write(w io.Writer, order ByteOrder, data interface{}) error {\n \t// Fast path for basic types.\n \tvar b [8]byte\n \tvar bs []byte\n@@ -244,7 +244,7 @@ func Write(w io.Writer, order ByteOrder, data interface{}) os.Error {\n \tv := reflect.Indirect(reflect.ValueOf(data))\n \tsize := TotalSize(v)\n \tif size < 0 {\n-\t\treturn os.NewError(\"binary.Write: invalid type \" + v.Type().String())\n+\t\treturn errors.New(\"binary.Write: invalid type \" + v.Type().String())\n \t}\n \tbuf := make([]byte, size)\n \te := &encoder{order: order, buf: buf}"}, {"sha": "e753aa0b5b6aee4c9f362a5e319b02eecf528933", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,8 +7,8 @@ package binary\n import (\n \t\"bytes\"\n \t\"io\"\n+\t\"bytes\"\n \t\"math\"\n-\t\"os\"\n \t\"reflect\"\n \t\"testing\"\n )\n@@ -99,7 +99,7 @@ var little = []byte{\n var src = []byte{1, 2, 3, 4, 5, 6, 7, 8}\n var res = []int32{0x01020304, 0x05060708}\n \n-func checkResult(t *testing.T, dir string, order ByteOrder, err os.Error, have, want interface{}) {\n+func checkResult(t *testing.T, dir string, order ByteOrder, err error, have, want interface{}) {\n \tif err != nil {\n \t\tt.Errorf(\"%v %v: %v\", dir, order, err)\n \t\treturn\n@@ -166,7 +166,7 @@ type byteSliceReader struct {\n \tremain []byte\n }\n \n-func (br *byteSliceReader) Read(p []byte) (int, os.Error) {\n+func (br *byteSliceReader) Read(p []byte) (int, error) {\n \tn := copy(p, br.remain)\n \tbr.remain = br.remain[n:]\n \treturn n, nil"}, {"sha": "d4872eea2c5c1fd36ef0d21e86375d431773692c", "filename": "libgo/go/encoding/binary/varint.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -25,8 +25,8 @@ package binary\n // format incompatible with a varint encoding for larger numbers (say 128-bit).\n \n import (\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n )\n \n // MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.\n@@ -99,17 +99,17 @@ func Varint(buf []byte) (int64, int) {\n }\n \n // WriteUvarint encodes x and writes the result to w.\n-func WriteUvarint(w io.Writer, x uint64) os.Error {\n+func WriteUvarint(w io.Writer, x uint64) error {\n \tvar buf [MaxVarintLen64]byte\n \tn := PutUvarint(buf[:], x)\n \t_, err := w.Write(buf[0:n])\n \treturn err\n }\n \n-var overflow = os.NewError(\"binary: varint overflows a 64-bit integer\")\n+var overflow = errors.New(\"binary: varint overflows a 64-bit integer\")\n \n // ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.\n-func ReadUvarint(r io.ByteReader) (uint64, os.Error) {\n+func ReadUvarint(r io.ByteReader) (uint64, error) {\n \tvar x uint64\n \tvar s uint\n \tfor i := 0; ; i++ {\n@@ -130,7 +130,7 @@ func ReadUvarint(r io.ByteReader) (uint64, os.Error) {\n }\n \n // WriteVarint encodes x and writes the result to w.\n-func WriteVarint(w io.Writer, x int64) os.Error {\n+func WriteVarint(w io.Writer, x int64) error {\n \tux := uint64(x) << 1\n \tif x < 0 {\n \t\tux = ^ux\n@@ -139,7 +139,7 @@ func WriteVarint(w io.Writer, x int64) os.Error {\n }\n \n // ReadVarint reads an encoded unsigned integer from r and returns it as a uint64.\n-func ReadVarint(r io.ByteReader) (int64, os.Error) {\n+func ReadVarint(r io.ByteReader) (int64, error) {\n \tux, err := ReadUvarint(r) // ok to continue in presence of error\n \tx := int64(ux >> 1)\n \tif ux&1 != 0 {"}, {"sha": "b553d6d4eb0589af408e56a5935d4dab4844d8e5", "filename": "libgo/go/encoding/binary/varint_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,7 +6,7 @@ package binary\n \n import (\n \t\"bytes\"\n-\t\"os\"\n+\t\"io\"\n \t\"testing\"\n )\n \n@@ -131,13 +131,13 @@ func TestBufferTooSmall(t *testing.T) {\n \t\t}\n \n \t\tx, err := ReadUvarint(bytes.NewBuffer(buf))\n-\t\tif x != 0 || err != os.EOF {\n+\t\tif x != 0 || err != io.EOF {\n \t\t\tt.Errorf(\"ReadUvarint(%v): got x = %d, err = %s\", buf, x, err)\n \t\t}\n \t}\n }\n \n-func testOverflow(t *testing.T, buf []byte, n0 int, err0 os.Error) {\n+func testOverflow(t *testing.T, buf []byte, n0 int, err0 error) {\n \tx, n := Uvarint(buf)\n \tif x != 0 || n != n0 {\n \t\tt.Errorf(\"Uvarint(%v): got x = %d, n = %d; want 0, %d\", buf, x, n, n0)"}, {"sha": "b6ad6e2dd3845cebdcf777fd49fbbca47a9789f2", "filename": "libgo/go/encoding/git85/git.go", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,13 +9,12 @@ package git85\n import (\n \t\"bytes\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n type CorruptInputError int64\n \n-func (e CorruptInputError) String() string {\n+func (e CorruptInputError) Error() string {\n \treturn \"illegal git85 data at input byte \" + strconv.Itoa64(int64(e))\n }\n \n@@ -96,7 +95,7 @@ var newline = []byte{'\\n'}\n //\n // If Decode encounters invalid input, it returns a CorruptInputError.\n //\n-func Decode(dst, src []byte) (n int, err os.Error) {\n+func Decode(dst, src []byte) (n int, err error) {\n \tndst := 0\n \tnsrc := 0\n \tfor nsrc < len(src) {\n@@ -153,14 +152,14 @@ func NewEncoder(w io.Writer) io.WriteCloser { return &encoder{w: w} }\n \n type encoder struct {\n \tw    io.Writer\n-\terr  os.Error\n+\terr  error\n \tbuf  [52]byte\n \tnbuf int\n \tout  [1024]byte\n \tnout int\n }\n \n-func (e *encoder) Write(p []byte) (n int, err os.Error) {\n+func (e *encoder) Write(p []byte) (n int, err error) {\n \tif e.err != nil {\n \t\treturn 0, e.err\n \t}\n@@ -209,7 +208,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (e *encoder) Close() os.Error {\n+func (e *encoder) Close() error {\n \t// If there's anything left in the buffer, flush it out\n \tif e.err == nil && e.nbuf > 0 {\n \t\tnout := Encode(e.out[0:], e.buf[0:e.nbuf])\n@@ -224,16 +223,16 @@ func NewDecoder(r io.Reader) io.Reader { return &decoder{r: r} }\n \n type decoder struct {\n \tr       io.Reader\n-\terr     os.Error\n-\treadErr os.Error\n+\terr     error\n+\treadErr error\n \tbuf     [1024]byte\n \tnbuf    int\n \tout     []byte\n \toutbuf  [1024]byte\n \toff     int64\n }\n \n-func (d *decoder) Read(p []byte) (n int, err os.Error) {\n+func (d *decoder) Read(p []byte) (n int, err error) {\n \tif len(p) == 0 {\n \t\treturn 0, nil\n \t}"}, {"sha": "81f5b0e32993bde88ff5ae6d72dc2d2460a80925", "filename": "libgo/go/encoding/git85/git_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,8 +6,8 @@ package git85\n \n import (\n \t\"bytes\"\n+\t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -90,11 +90,11 @@ func TestEncoderBuffering(t *testing.T) {\n \t\t\t\tend = len(input)\n \t\t\t}\n \t\t\tn, err := encoder.Write(input[pos:end])\n-\t\t\ttestEqual(t, \"Write(%q) gave error %v, want %v\", input[pos:end], err, os.Error(nil))\n+\t\t\ttestEqual(t, \"Write(%q) gave error %v, want %v\", input[pos:end], err, error(nil))\n \t\t\ttestEqual(t, \"Write(%q) gave length %v, want %v\", input[pos:end], n, end-pos)\n \t\t}\n \t\terr := encoder.Close()\n-\t\ttestEqual(t, \"Close gave error %v, want %v\", err, os.Error(nil))\n+\t\ttestEqual(t, \"Close gave error %v, want %v\", err, error(nil))\n \t\ttestEqual(t, \"Encoding/%d of %q = %q, want %q\", bs, gitBigtest.decoded, bb.String(), gitBigtest.encoded)\n \t}\n }\n@@ -103,7 +103,7 @@ func TestDecode(t *testing.T) {\n \tfor _, p := range gitPairs {\n \t\tdbuf := make([]byte, 4*len(p.encoded))\n \t\tndst, err := Decode(dbuf, []byte(p.encoded))\n-\t\ttestEqual(t, \"Decode(%q) = error %v, want %v\", p.encoded, err, os.Error(nil))\n+\t\ttestEqual(t, \"Decode(%q) = error %v, want %v\", p.encoded, err, error(nil))\n \t\ttestEqual(t, \"Decode(%q) = ndst %v, want %v\", p.encoded, ndst, len(p.decoded))\n \t\ttestEqual(t, \"Decode(%q) = %q, want %q\", p.encoded, string(dbuf[0:ndst]), p.decoded)\n \t}\n@@ -119,7 +119,7 @@ func TestDecoder(t *testing.T) {\n \t\ttestEqual(t, \"Read from %q = length %v, want %v\", p.encoded, len(dbuf), len(p.decoded))\n \t\ttestEqual(t, \"Decoding of %q = %q, want %q\", p.encoded, string(dbuf), p.decoded)\n \t\tif err != nil {\n-\t\t\ttestEqual(t, \"Read from %q = %v, want %v\", p.encoded, err, os.EOF)\n+\t\t\ttestEqual(t, \"Read from %q = %v, want %v\", p.encoded, err, io.EOF)\n \t\t}\n \t}\n }\n@@ -131,7 +131,7 @@ func TestDecoderBuffering(t *testing.T) {\n \t\tvar total int\n \t\tfor total = 0; total < len(gitBigtest.decoded); {\n \t\t\tn, err := decoder.Read(buf[total : total+bs])\n-\t\t\ttestEqual(t, \"Read from %q at pos %d = %d, %v, want _, %v\", gitBigtest.encoded, total, n, err, os.Error(nil))\n+\t\t\ttestEqual(t, \"Read from %q at pos %d = %d, %v, want _, %v\", gitBigtest.encoded, total, n, err, error(nil))\n \t\t\ttotal += n\n \t\t}\n \t\ttestEqual(t, \"Decoding/%d of %q = %q, want %q\", bs, gitBigtest.encoded, string(buf[0:total]), gitBigtest.decoded)"}, {"sha": "eb7e7ca8d3878cebd044070fdd6ba84ea1dabdb8", "filename": "libgo/go/encoding/hex/hex.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ package hex\n import (\n \t\"bytes\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -33,12 +32,12 @@ func Encode(dst, src []byte) int {\n // OddLengthInputError results from decoding an odd length slice.\n type OddLengthInputError struct{}\n \n-func (OddLengthInputError) String() string { return \"odd length hex string\" }\n+func (OddLengthInputError) Error() string { return \"odd length hex string\" }\n \n // InvalidHexCharError results from finding an invalid character in a hex string.\n type InvalidHexCharError byte\n \n-func (e InvalidHexCharError) String() string {\n+func (e InvalidHexCharError) Error() string {\n \treturn \"invalid hex char: \" + strconv.Itoa(int(e))\n }\n \n@@ -49,7 +48,7 @@ func DecodedLen(x int) int { return x / 2 }\n //\n // If Decode encounters invalid input, it returns an OddLengthInputError or an\n // InvalidHexCharError.\n-func Decode(dst, src []byte) (int, os.Error) {\n+func Decode(dst, src []byte) (int, error) {\n \tif len(src)%2 == 1 {\n \t\treturn 0, OddLengthInputError{}\n \t}\n@@ -91,7 +90,7 @@ func EncodeToString(src []byte) string {\n }\n \n // DecodeString returns the bytes represented by the hexadecimal string s.\n-func DecodeString(s string) ([]byte, os.Error) {\n+func DecodeString(s string) ([]byte, error) {\n \tsrc := []byte(s)\n \tdst := make([]byte, DecodedLen(len(src)))\n \t_, err := Decode(dst, src)\n@@ -133,7 +132,7 @@ func toChar(b byte) byte {\n \treturn b\n }\n \n-func (h *dumper) Write(data []byte) (n int, err os.Error) {\n+func (h *dumper) Write(data []byte) (n int, err error) {\n \t// Output lines look like:\n \t// 00000010  2e 2f 30 31 32 33 34 35  36 37 38 39 3a 3b 3c 3d  |./0123456789:;<=|\n \t// ^ offset                          ^ extra space              ^ ASCII of line.\n@@ -185,7 +184,7 @@ func (h *dumper) Write(data []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (h *dumper) Close() (err os.Error) {\n+func (h *dumper) Close() (err error) {\n \t// See the comments in Write() for the details of this format.\n \tif h.used == 0 {\n \t\treturn"}, {"sha": "3eb7c9fa0d91a9ee0a7bd872c1d73c4d5f00a4c6", "filename": "libgo/go/encoding/pem/pem.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,7 +11,6 @@ import (\n \t\"bytes\"\n \t\"encoding/base64\"\n \t\"io\"\n-\t\"os\"\n )\n \n // A Block represents a PEM encoded structure.\n@@ -170,7 +169,7 @@ type lineBreaker struct {\n \tout  io.Writer\n }\n \n-func (l *lineBreaker) Write(b []byte) (n int, err os.Error) {\n+func (l *lineBreaker) Write(b []byte) (n int, err error) {\n \tif l.used+len(b) < pemLineLength {\n \t\tcopy(l.line[l.used:], b)\n \t\tl.used += len(b)\n@@ -197,7 +196,7 @@ func (l *lineBreaker) Write(b []byte) (n int, err os.Error) {\n \treturn l.Write(b[excess:])\n }\n \n-func (l *lineBreaker) Close() (err os.Error) {\n+func (l *lineBreaker) Close() (err error) {\n \tif l.used > 0 {\n \t\t_, err = l.out.Write(l.line[0:l.used])\n \t\tif err != nil {\n@@ -209,7 +208,7 @@ func (l *lineBreaker) Close() (err os.Error) {\n \treturn\n }\n \n-func Encode(out io.Writer, b *Block) (err os.Error) {\n+func Encode(out io.Writer, b *Block) (err error) {\n \t_, err = out.Write(pemStart[1:])\n \tif err != nil {\n \t\treturn"}, {"sha": "3085a7962c2a0b4a905100063ab0593181b9dc52", "filename": "libgo/go/errors/errors.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Ferrors%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Ferrors%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ferrors%2Ferrors.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package errors implements functions to manipulate errors.\n+package errors\n+\n+// New returns an error that formats as the given text.\n+func New(text string) error {\n+\treturn &errorString{text}\n+}\n+\n+// errorString is a trivial implementation of error.\n+type errorString struct {\n+\ts string\n+}\n+\n+func (e *errorString) Error() string {\n+\treturn e.s\n+}"}, {"sha": "c537eeb625169e3876a9f4ec72cf669bd3395391", "filename": "libgo/go/errors/errors_test.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Ferrors%2Ferrors_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Ferrors%2Ferrors_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ferrors%2Ferrors_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package errors_test\n+\n+import (\n+\t. \"errors\"\n+\t\"testing\"\n+)\n+\n+func TestNewEqual(t *testing.T) {\n+\t// Different allocations should not be equal.\n+\tif New(\"abc\") == New(\"abc\") {\n+\t\tt.Errorf(`New(\"abc\") == New(\"abc\")`)\n+\t}\n+\tif New(\"abc\") == New(\"xyz\") {\n+\t\tt.Errorf(`New(\"abc\") == New(\"xyz\")`)\n+\t}\n+\n+\t// Same allocation should be equal to itself (not crash).\n+\terr := New(\"jkl\")\n+\tif err != err {\n+\t\tt.Errorf(`err != err`)\n+\t}\n+}\n+\n+func TestErrorMethod(t *testing.T) {\n+\terr := New(\"abc\")\n+\tif err.Error() != \"abc\" {\n+\t\tt.Errorf(`New(\"abc\").Error() = %q, want %q`, err.Error(), \"abc\")\n+\t}\n+}"}, {"sha": "ebdfd54a73411da70522efaa9d14e54c61900f43", "filename": "libgo/go/exec/exec.go", "status": "modified", "additions": 52, "deletions": 42, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,6 +9,7 @@ package exec\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"io\"\n \t\"os\"\n \t\"strconv\"\n@@ -18,12 +19,12 @@ import (\n // Error records the name of a binary that failed to be be executed\n // and the reason it failed.\n type Error struct {\n-\tName  string\n-\tError os.Error\n+\tName string\n+\tErr  error\n }\n \n-func (e *Error) String() string {\n-\treturn \"exec: \" + strconv.Quote(e.Name) + \": \" + e.Error.String()\n+func (e *Error) Error() string {\n+\treturn \"exec: \" + strconv.Quote(e.Name) + \": \" + e.Err.Error()\n }\n \n // Cmd represents an external command being prepared or run.\n@@ -75,13 +76,13 @@ type Cmd struct {\n \t// Process is the underlying process, once started.\n \tProcess *os.Process\n \n-\terr             os.Error // last error (from LookPath, stdin, stdout, stderr)\n-\tfinished        bool     // when Wait was called\n+\terr             error // last error (from LookPath, stdin, stdout, stderr)\n+\tfinished        bool  // when Wait was called\n \tchildFiles      []*os.File\n \tcloseAfterStart []io.Closer\n \tcloseAfterWait  []io.Closer\n-\tgoroutine       []func() os.Error\n-\terrch           chan os.Error // one send per goroutine\n+\tgoroutine       []func() error\n+\terrch           chan error // one send per goroutine\n }\n \n // Command returns the Cmd struct to execute the named program with\n@@ -132,7 +133,7 @@ func (c *Cmd) argv() []string {\n \treturn []string{c.Path}\n }\n \n-func (c *Cmd) stdin() (f *os.File, err os.Error) {\n+func (c *Cmd) stdin() (f *os.File, err error) {\n \tif c.Stdin == nil {\n \t\tf, err = os.Open(os.DevNull)\n \t\tc.closeAfterStart = append(c.closeAfterStart, f)\n@@ -150,7 +151,7 @@ func (c *Cmd) stdin() (f *os.File, err os.Error) {\n \n \tc.closeAfterStart = append(c.closeAfterStart, pr)\n \tc.closeAfterWait = append(c.closeAfterWait, pw)\n-\tc.goroutine = append(c.goroutine, func() os.Error {\n+\tc.goroutine = append(c.goroutine, func() error {\n \t\t_, err := io.Copy(pw, c.Stdin)\n \t\tif err1 := pw.Close(); err == nil {\n \t\t\terr = err1\n@@ -160,18 +161,18 @@ func (c *Cmd) stdin() (f *os.File, err os.Error) {\n \treturn pr, nil\n }\n \n-func (c *Cmd) stdout() (f *os.File, err os.Error) {\n+func (c *Cmd) stdout() (f *os.File, err error) {\n \treturn c.writerDescriptor(c.Stdout)\n }\n \n-func (c *Cmd) stderr() (f *os.File, err os.Error) {\n+func (c *Cmd) stderr() (f *os.File, err error) {\n \tif c.Stderr != nil && interfaceEqual(c.Stderr, c.Stdout) {\n \t\treturn c.childFiles[1], nil\n \t}\n \treturn c.writerDescriptor(c.Stderr)\n }\n \n-func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err os.Error) {\n+func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err error) {\n \tif w == nil {\n \t\tf, err = os.OpenFile(os.DevNull, os.O_WRONLY, 0)\n \t\tc.closeAfterStart = append(c.closeAfterStart, f)\n@@ -189,7 +190,7 @@ func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err os.Error) {\n \n \tc.closeAfterStart = append(c.closeAfterStart, pw)\n \tc.closeAfterWait = append(c.closeAfterWait, pr)\n-\tc.goroutine = append(c.goroutine, func() os.Error {\n+\tc.goroutine = append(c.goroutine, func() error {\n \t\t_, err := io.Copy(w, pr)\n \t\treturn err\n \t})\n@@ -203,25 +204,25 @@ func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err os.Error) {\n // status.\n //\n // If the command fails to run or doesn't complete successfully, the\n-// error is of type *os.Waitmsg. Other error types may be\n+// error is of type *ExitError. Other error types may be\n // returned for I/O problems.\n-func (c *Cmd) Run() os.Error {\n+func (c *Cmd) Run() error {\n \tif err := c.Start(); err != nil {\n \t\treturn err\n \t}\n \treturn c.Wait()\n }\n \n // Start starts the specified command but does not wait for it to complete.\n-func (c *Cmd) Start() os.Error {\n+func (c *Cmd) Start() error {\n \tif c.err != nil {\n \t\treturn c.err\n \t}\n \tif c.Process != nil {\n-\t\treturn os.NewError(\"exec: already started\")\n+\t\treturn errors.New(\"exec: already started\")\n \t}\n \n-\ttype F func(*Cmd) (*os.File, os.Error)\n+\ttype F func(*Cmd) (*os.File, error)\n \tfor _, setupFd := range []F{(*Cmd).stdin, (*Cmd).stdout, (*Cmd).stderr} {\n \t\tfd, err := setupFd(c)\n \t\tif err != nil {\n@@ -231,7 +232,7 @@ func (c *Cmd) Start() os.Error {\n \t}\n \tc.childFiles = append(c.childFiles, c.ExtraFiles...)\n \n-\tvar err os.Error\n+\tvar err error\n \tc.Process, err = os.StartProcess(c.Path, c.argv(), &os.ProcAttr{\n \t\tDir:   c.Dir,\n \t\tFiles: c.childFiles,\n@@ -246,16 +247,25 @@ func (c *Cmd) Start() os.Error {\n \t\tfd.Close()\n \t}\n \n-\tc.errch = make(chan os.Error, len(c.goroutine))\n+\tc.errch = make(chan error, len(c.goroutine))\n \tfor _, fn := range c.goroutine {\n-\t\tgo func(fn func() os.Error) {\n+\t\tgo func(fn func() error) {\n \t\t\tc.errch <- fn()\n \t\t}(fn)\n \t}\n \n \treturn nil\n }\n \n+// An ExitError reports an unsuccessful exit by a command.\n+type ExitError struct {\n+\t*os.Waitmsg\n+}\n+\n+func (e *ExitError) Error() string {\n+\treturn e.Waitmsg.String()\n+}\n+\n // Wait waits for the command to exit.\n // It must have been started by Start.\n //\n@@ -264,19 +274,19 @@ func (c *Cmd) Start() os.Error {\n // status.\n //\n // If the command fails to run or doesn't complete successfully, the\n-// error is of type *os.Waitmsg. Other error types may be\n+// error is of type *ExitError. Other error types may be\n // returned for I/O problems.\n-func (c *Cmd) Wait() os.Error {\n+func (c *Cmd) Wait() error {\n \tif c.Process == nil {\n-\t\treturn os.NewError(\"exec: not started\")\n+\t\treturn errors.New(\"exec: not started\")\n \t}\n \tif c.finished {\n-\t\treturn os.NewError(\"exec: Wait was already called\")\n+\t\treturn errors.New(\"exec: Wait was already called\")\n \t}\n \tc.finished = true\n \tmsg, err := c.Process.Wait(0)\n \n-\tvar copyError os.Error\n+\tvar copyError error\n \tfor _ = range c.goroutine {\n \t\tif err := <-c.errch; err != nil && copyError == nil {\n \t\t\tcopyError = err\n@@ -290,16 +300,16 @@ func (c *Cmd) Wait() os.Error {\n \tif err != nil {\n \t\treturn err\n \t} else if !msg.Exited() || msg.ExitStatus() != 0 {\n-\t\treturn msg\n+\t\treturn &ExitError{msg}\n \t}\n \n \treturn copyError\n }\n \n // Output runs the command and returns its standard output.\n-func (c *Cmd) Output() ([]byte, os.Error) {\n+func (c *Cmd) Output() ([]byte, error) {\n \tif c.Stdout != nil {\n-\t\treturn nil, os.NewError(\"exec: Stdout already set\")\n+\t\treturn nil, errors.New(\"exec: Stdout already set\")\n \t}\n \tvar b bytes.Buffer\n \tc.Stdout = &b\n@@ -309,12 +319,12 @@ func (c *Cmd) Output() ([]byte, os.Error) {\n \n // CombinedOutput runs the command and returns its combined standard\n // output and standard error.\n-func (c *Cmd) CombinedOutput() ([]byte, os.Error) {\n+func (c *Cmd) CombinedOutput() ([]byte, error) {\n \tif c.Stdout != nil {\n-\t\treturn nil, os.NewError(\"exec: Stdout already set\")\n+\t\treturn nil, errors.New(\"exec: Stdout already set\")\n \t}\n \tif c.Stderr != nil {\n-\t\treturn nil, os.NewError(\"exec: Stderr already set\")\n+\t\treturn nil, errors.New(\"exec: Stderr already set\")\n \t}\n \tvar b bytes.Buffer\n \tc.Stdout = &b\n@@ -325,12 +335,12 @@ func (c *Cmd) CombinedOutput() ([]byte, os.Error) {\n \n // StdinPipe returns a pipe that will be connected to the command's\n // standard input when the command starts.\n-func (c *Cmd) StdinPipe() (io.WriteCloser, os.Error) {\n+func (c *Cmd) StdinPipe() (io.WriteCloser, error) {\n \tif c.Stdin != nil {\n-\t\treturn nil, os.NewError(\"exec: Stdin already set\")\n+\t\treturn nil, errors.New(\"exec: Stdin already set\")\n \t}\n \tif c.Process != nil {\n-\t\treturn nil, os.NewError(\"exec: StdinPipe after process started\")\n+\t\treturn nil, errors.New(\"exec: StdinPipe after process started\")\n \t}\n \tpr, pw, err := os.Pipe()\n \tif err != nil {\n@@ -345,12 +355,12 @@ func (c *Cmd) StdinPipe() (io.WriteCloser, os.Error) {\n // StdoutPipe returns a pipe that will be connected to the command's\n // standard output when the command starts.\n // The pipe will be closed automatically after Wait sees the command exit.\n-func (c *Cmd) StdoutPipe() (io.ReadCloser, os.Error) {\n+func (c *Cmd) StdoutPipe() (io.ReadCloser, error) {\n \tif c.Stdout != nil {\n-\t\treturn nil, os.NewError(\"exec: Stdout already set\")\n+\t\treturn nil, errors.New(\"exec: Stdout already set\")\n \t}\n \tif c.Process != nil {\n-\t\treturn nil, os.NewError(\"exec: StdoutPipe after process started\")\n+\t\treturn nil, errors.New(\"exec: StdoutPipe after process started\")\n \t}\n \tpr, pw, err := os.Pipe()\n \tif err != nil {\n@@ -365,12 +375,12 @@ func (c *Cmd) StdoutPipe() (io.ReadCloser, os.Error) {\n // StderrPipe returns a pipe that will be connected to the command's\n // standard error when the command starts.\n // The pipe will be closed automatically after Wait sees the command exit.\n-func (c *Cmd) StderrPipe() (io.ReadCloser, os.Error) {\n+func (c *Cmd) StderrPipe() (io.ReadCloser, error) {\n \tif c.Stderr != nil {\n-\t\treturn nil, os.NewError(\"exec: Stderr already set\")\n+\t\treturn nil, errors.New(\"exec: Stderr already set\")\n \t}\n \tif c.Process != nil {\n-\t\treturn nil, os.NewError(\"exec: StderrPipe after process started\")\n+\t\treturn nil, errors.New(\"exec: StderrPipe after process started\")\n \t}\n \tpr, pw, err := os.Pipe()\n \tif err != nil {"}, {"sha": "6d5e8933ff7b962009de225141043710eec4daab", "filename": "libgo/go/exec/exec_test.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -53,8 +53,8 @@ func TestCatStdin(t *testing.T) {\n func TestCatGoodAndBadFile(t *testing.T) {\n \t// Testing combined output and error values.\n \tbs, err := helperCommand(\"cat\", \"/bogus/file.foo\", \"exec_test.go\").CombinedOutput()\n-\tif _, ok := err.(*os.Waitmsg); !ok {\n-\t\tt.Errorf(\"expected Waitmsg from cat combined; got %T: %v\", err, err)\n+\tif _, ok := err.(*ExitError); !ok {\n+\t\tt.Errorf(\"expected *ExitError from cat combined; got %T: %v\", err, err)\n \t}\n \ts := string(bs)\n \tsp := strings.SplitN(s, \"\\n\", 2)\n@@ -81,17 +81,17 @@ func TestNoExistBinary(t *testing.T) {\n func TestExitStatus(t *testing.T) {\n \t// Test that exit values are returned correctly\n \terr := helperCommand(\"exit\", \"42\").Run()\n-\tif werr, ok := err.(*os.Waitmsg); ok {\n-\t\tif s, e := werr.String(), \"exit status 42\"; s != e {\n+\tif werr, ok := err.(*ExitError); ok {\n+\t\tif s, e := werr.Error(), \"exit status 42\"; s != e {\n \t\t\tt.Errorf(\"from exit 42 got exit %q, want %q\", s, e)\n \t\t}\n \t} else {\n-\t\tt.Fatalf(\"expected Waitmsg from exit 42; got %T: %v\", err, err)\n+\t\tt.Fatalf(\"expected *ExitError from exit 42; got %T: %v\", err, err)\n \t}\n }\n \n func TestPipes(t *testing.T) {\n-\tcheck := func(what string, err os.Error) {\n+\tcheck := func(what string, err error) {\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"%s: %v\", what, err)\n \t\t}\n@@ -224,7 +224,7 @@ func TestHelperProcess(*testing.T) {\n \t\tbufr := bufio.NewReader(os.Stdin)\n \t\tfor {\n \t\t\tline, _, err := bufr.ReadLine()\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\tbreak\n \t\t\t} else if err != nil {\n \t\t\t\tos.Exit(1)"}, {"sha": "d4ffc17c006cea10136315130bb5e53f16b1441d", "filename": "libgo/go/exec/lp_plan9.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexec%2Flp_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexec%2Flp_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_plan9.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,14 +5,15 @@\n package exec\n \n import (\n+\t\"errors\"\n \t\"os\"\n \t\"strings\"\n )\n \n // ErrNotFound is the error resulting if a path search failed to find an executable file.\n-var ErrNotFound = os.NewError(\"executable file not found in $path\")\n+var ErrNotFound = errors.New(\"executable file not found in $path\")\n \n-func findExecutable(file string) os.Error {\n+func findExecutable(file string) error {\n \td, err := os.Stat(file)\n \tif err != nil {\n \t\treturn err\n@@ -27,7 +28,7 @@ func findExecutable(file string) os.Error {\n // in the directories named by the path environment variable.\n // If file begins with \"/\", \"#\", \"./\", or \"../\", it is tried\n // directly and the path is not consulted.\n-func LookPath(file string) (string, os.Error) {\n+func LookPath(file string) (string, error) {\n \t// skip the path lookup for these prefixes\n \tskip := []string{\"/\", \"#\", \"./\", \"../\"}\n "}, {"sha": "d234641acc47ae073e1cbdfe438640e9c5b52bac", "filename": "libgo/go/exec/lp_unix.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexec%2Flp_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexec%2Flp_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_unix.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,14 +7,15 @@\n package exec\n \n import (\n+\t\"errors\"\n \t\"os\"\n \t\"strings\"\n )\n \n // ErrNotFound is the error resulting if a path search failed to find an executable file.\n-var ErrNotFound = os.NewError(\"executable file not found in $PATH\")\n+var ErrNotFound = errors.New(\"executable file not found in $PATH\")\n \n-func findExecutable(file string) os.Error {\n+func findExecutable(file string) error {\n \td, err := os.Stat(file)\n \tif err != nil {\n \t\treturn err\n@@ -28,7 +29,7 @@ func findExecutable(file string) os.Error {\n // LookPath searches for an executable binary named file\n // in the directories named by the PATH environment variable.\n // If file contains a slash, it is tried directly and the PATH is not consulted.\n-func LookPath(file string) (string, os.Error) {\n+func LookPath(file string) (string, error) {\n \t// NOTE(rsc): I wish we could use the Plan 9 behavior here\n \t// (only bypass the path if file begins with / or ./ or ../)\n \t// but that would not match all the Unix shells."}, {"sha": "db326236ee8698c03e06840ff61d11dac144943d", "filename": "libgo/go/exec/lp_windows.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexec%2Flp_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexec%2Flp_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_windows.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,14 +5,15 @@\n package exec\n \n import (\n+\t\"errors\"\n \t\"os\"\n \t\"strings\"\n )\n \n // ErrNotFound is the error resulting if a path search failed to find an executable file.\n-var ErrNotFound = os.NewError(\"executable file not found in %PATH%\")\n+var ErrNotFound = errors.New(\"executable file not found in %PATH%\")\n \n-func chkStat(file string) os.Error {\n+func chkStat(file string) error {\n \td, err := os.Stat(file)\n \tif err != nil {\n \t\treturn err\n@@ -23,7 +24,7 @@ func chkStat(file string) os.Error {\n \treturn os.EPERM\n }\n \n-func findExecutable(file string, exts []string) (string, os.Error) {\n+func findExecutable(file string, exts []string) (string, error) {\n \tif len(exts) == 0 {\n \t\treturn file, chkStat(file)\n \t}\n@@ -41,7 +42,7 @@ func findExecutable(file string, exts []string) (string, os.Error) {\n \treturn ``, os.ENOENT\n }\n \n-func LookPath(file string) (f string, err os.Error) {\n+func LookPath(file string) (f string, err error) {\n \tx := os.Getenv(`PATHEXT`)\n \tif x == `` {\n \t\tx = `.COM;.EXE;.BAT;.CMD`"}, {"sha": "15c199af6cbd43cbf293eada0c9938f90da6e260", "filename": "libgo/go/exp/ebnf/ebnf.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Febnf%2Febnf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Febnf%2Febnf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnf%2Febnf.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -23,8 +23,8 @@\n package ebnf\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n-\t\"os\"\n \t\"scanner\"\n \t\"unicode\"\n \t\"utf8\"\n@@ -33,27 +33,27 @@ import (\n // ----------------------------------------------------------------------------\n // Error handling\n \n-type errorList []os.Error\n+type errorList []error\n \n-func (list errorList) Error() os.Error {\n+func (list errorList) Err() error {\n \tif len(list) == 0 {\n \t\treturn nil\n \t}\n \treturn list\n }\n \n-func (list errorList) String() string {\n+func (list errorList) Error() string {\n \tswitch len(list) {\n \tcase 0:\n \t\treturn \"no errors\"\n \tcase 1:\n-\t\treturn list[0].String()\n+\t\treturn list[0].Error()\n \t}\n \treturn fmt.Sprintf(\"%s (and %d more errors)\", list[0], len(list)-1)\n }\n \n-func newError(pos scanner.Position, msg string) os.Error {\n-\treturn os.NewError(fmt.Sprintf(\"%s: %s\", pos, msg))\n+func newError(pos scanner.Position, msg string) error {\n+\treturn errors.New(fmt.Sprintf(\"%s: %s\", pos, msg))\n }\n \n // ----------------------------------------------------------------------------\n@@ -262,8 +262,8 @@ func (v *verifier) verify(grammar Grammar, start string) {\n //\n // Position information is interpreted relative to the file set fset.\n //\n-func Verify(grammar Grammar, start string) os.Error {\n+func Verify(grammar Grammar, start string) error {\n \tvar v verifier\n \tv.verify(grammar, start)\n-\treturn v.errors.Error()\n+\treturn v.errors.Err()\n }"}, {"sha": "2dad9b4c13d43cf774f2ffbad72acfe875a39525", "filename": "libgo/go/exp/ebnf/parser.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Febnf%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Febnf%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnf%2Fparser.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,7 +6,6 @@ package ebnf\n \n import (\n \t\"io\"\n-\t\"os\"\n \t\"scanner\"\n \t\"strconv\"\n )\n@@ -184,8 +183,8 @@ func (p *parser) parse(filename string, src io.Reader) Grammar {\n // more than once; the filename is used only for error\n // positions.\n //\n-func Parse(filename string, src io.Reader) (Grammar, os.Error) {\n+func Parse(filename string, src io.Reader) (Grammar, error) {\n \tvar p parser\n \tgrammar := p.parse(filename, src)\n-\treturn grammar, p.errors.Error()\n+\treturn grammar, p.errors.Err()\n }"}, {"sha": "6d6f516c905eee3a637d6081e837bfb1fa2414ae", "filename": "libgo/go/exp/ebnflint/ebnflint.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -31,7 +31,7 @@ var (\n \tclose = []byte(`</pre>`)\n )\n \n-func report(err os.Error) {\n+func report(err error) {\n \tscanner.PrintError(os.Stderr, err)\n \tos.Exit(1)\n }\n@@ -78,7 +78,7 @@ func main() {\n \tvar (\n \t\tfilename string\n \t\tsrc      []byte\n-\t\terr      os.Error\n+\t\terr      error\n \t)\n \tswitch flag.NArg() {\n \tcase 0:"}, {"sha": "bc4a112c98f3d95a41068f8e58ecc72fa8d9772d", "filename": "libgo/go/exp/gotype/gotype.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,6 +5,7 @@\n package main\n \n import (\n+\t\"errors\"\n \t\"exp/types\"\n \t\"flag\"\n \t\"fmt\"\n@@ -38,7 +39,7 @@ func usage() {\n \tos.Exit(2)\n }\n \n-func report(err os.Error) {\n+func report(err error) {\n \tscanner.PrintError(os.Stderr, err)\n \texitCode = 2\n }\n@@ -111,7 +112,7 @@ func parseFiles(fset *token.FileSet, filenames []string) (files map[string]*ast.\n \t\t}\n \t\tif file := parse(fset, filename, src); file != nil {\n \t\t\tif files[filename] != nil {\n-\t\t\t\treport(os.NewError(fmt.Sprintf(\"%q: duplicate file\", filename)))\n+\t\t\t\treport(errors.New(fmt.Sprintf(\"%q: duplicate file\", filename)))\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tfiles[filename] = file"}, {"sha": "a69f83a1f509525849a77c58957bb4e90fe5a2aa", "filename": "libgo/go/exp/gui/gui.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fgui%2Fgui.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fgui%2Fgui.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgui%2Fgui.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ package gui\n import (\n \t\"image\"\n \t\"image/draw\"\n-\t\"os\"\n )\n \n // A Window represents a single graphics window.\n@@ -21,7 +20,7 @@ type Window interface {\n \t// mouse movements and window resizes.\n \tEventChan() <-chan interface{}\n \t// Close closes the window.\n-\tClose() os.Error\n+\tClose() error\n }\n \n // A KeyEvent is sent for a key press or release.\n@@ -54,5 +53,5 @@ type ConfigEvent struct {\n \n // An ErrEvent is sent when an error occurs.\n type ErrEvent struct {\n-\tErr os.Error\n+\tErr error\n }"}, {"sha": "24e941cb36bd837290e330ecb63af81e9d527477", "filename": "libgo/go/exp/gui/x11/auth.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fauth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fauth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fauth.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,12 +6,13 @@ package x11\n \n import (\n \t\"bufio\"\n+\t\"errors\"\n \t\"io\"\n \t\"os\"\n )\n \n // readU16BE reads a big-endian uint16 from r, using b as a scratch buffer.\n-func readU16BE(r io.Reader, b []byte) (uint16, os.Error) {\n+func readU16BE(r io.Reader, b []byte) (uint16, error) {\n \t_, err := io.ReadFull(r, b[0:2])\n \tif err != nil {\n \t\treturn 0, err\n@@ -20,13 +21,13 @@ func readU16BE(r io.Reader, b []byte) (uint16, os.Error) {\n }\n \n // readStr reads a length-prefixed string from r, using b as a scratch buffer.\n-func readStr(r io.Reader, b []byte) (string, os.Error) {\n+func readStr(r io.Reader, b []byte) (string, error) {\n \tn, err := readU16BE(r, b)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n \tif int(n) > len(b) {\n-\t\treturn \"\", os.NewError(\"Xauthority entry too long for buffer\")\n+\t\treturn \"\", errors.New(\"Xauthority entry too long for buffer\")\n \t}\n \t_, err = io.ReadFull(r, b[0:n])\n \tif err != nil {\n@@ -37,7 +38,7 @@ func readStr(r io.Reader, b []byte) (string, os.Error) {\n \n // readAuth reads the X authority file and returns the name/data pair for the display.\n // displayStr is the \"12\" out of a $DISPLAY like \":12.0\".\n-func readAuth(displayStr string) (name, data string, err os.Error) {\n+func readAuth(displayStr string) (name, data string, err error) {\n \t// b is a scratch buffer to use and should be at least 256 bytes long\n \t// (i.e. it should be able to hold a hostname).\n \tvar b [256]byte\n@@ -48,7 +49,7 @@ func readAuth(displayStr string) (name, data string, err os.Error) {\n \tif fn == \"\" {\n \t\thome := os.Getenv(\"HOME\")\n \t\tif home == \"\" {\n-\t\t\terr = os.NewError(\"Xauthority not found: $XAUTHORITY, $HOME not set\")\n+\t\t\terr = errors.New(\"Xauthority not found: $XAUTHORITY, $HOME not set\")\n \t\t\treturn\n \t\t}\n \t\tfn = home + \"/.Xauthority\""}, {"sha": "15afc657ecbd6a259e6e85fcd9bf919c3b794b8b", "filename": "libgo/go/exp/gui/x11/conn.go", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,6 +10,7 @@ package x11\n \n import (\n \t\"bufio\"\n+\t\"errors\"\n \t\"exp/gui\"\n \t\"image\"\n \t\"image/draw\"\n@@ -86,7 +87,7 @@ func (c *conn) writeSocket() {\n \t\tfor y := b.Min.Y; y < b.Max.Y; y++ {\n \t\t\tsetU32LE(c.flushBuf0[16:20], uint32(y<<16))\n \t\t\tif _, err := c.w.Write(c.flushBuf0[:24]); err != nil {\n-\t\t\t\tif err != os.EOF {\n+\t\t\t\tif err != io.EOF {\n \t\t\t\t\tlog.Println(\"x11:\", err)\n \t\t\t\t}\n \t\t\t\treturn\n@@ -105,15 +106,15 @@ func (c *conn) writeSocket() {\n \t\t\t\t}\n \t\t\t\tx += nx\n \t\t\t\tif _, err := c.w.Write(c.flushBuf1[:nx]); err != nil {\n-\t\t\t\t\tif err != os.EOF {\n+\t\t\t\t\tif err != io.EOF {\n \t\t\t\t\t\tlog.Println(\"x11:\", err)\n \t\t\t\t\t}\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif err := c.w.Flush(); err != nil {\n-\t\t\tif err != os.EOF {\n+\t\t\tif err != io.EOF {\n \t\t\t\tlog.Println(\"x11:\", err)\n \t\t\t}\n \t\t\treturn\n@@ -133,7 +134,7 @@ func (c *conn) FlushImage() {\n \t}\n }\n \n-func (c *conn) Close() os.Error {\n+func (c *conn) Close() error {\n \t// Shut down the writeSocket goroutine. This will close the socket to the\n \t// X11 server, which will cause c.eventc to close.\n \tclose(c.flush)\n@@ -156,7 +157,7 @@ func (c *conn) readSocket() {\n \tfor {\n \t\t// X events are always 32 bytes long.\n \t\tif _, err := io.ReadFull(c.r, c.buf[:32]); err != nil {\n-\t\t\tif err != os.EOF {\n+\t\t\tif err != io.EOF {\n \t\t\t\tc.eventc <- gui.ErrEvent{err}\n \t\t\t}\n \t\t\treturn\n@@ -167,7 +168,7 @@ func (c *conn) readSocket() {\n \t\t\tif cookie != 1 {\n \t\t\t\t// We issued only one request (GetKeyboardMapping) with a cookie of 1,\n \t\t\t\t// so we shouldn't get any other reply from the X server.\n-\t\t\t\tc.eventc <- gui.ErrEvent{os.NewError(\"x11: unexpected cookie\")}\n+\t\t\t\tc.eventc <- gui.ErrEvent{errors.New(\"x11: unexpected cookie\")}\n \t\t\t\treturn\n \t\t\t}\n \t\t\tkeysymsPerKeycode = int(c.buf[1])\n@@ -180,7 +181,7 @@ func (c *conn) readSocket() {\n \t\t\t\tfor j := range m {\n \t\t\t\t\tu, err := readU32LE(c.r, c.buf[:4])\n \t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tif err != os.EOF {\n+\t\t\t\t\t\tif err != io.EOF {\n \t\t\t\t\t\t\tc.eventc <- gui.ErrEvent{err}\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn\n@@ -253,10 +254,10 @@ func (c *conn) readSocket() {\n //\tconnect(\"/tmp/launch-123/:0\") // calls net.Dial(\"unix\", \"\", \"/tmp/launch-123/:0\"), displayStr=\"0\"\n //\tconnect(\"hostname:2.1\")       // calls net.Dial(\"tcp\", \"\", \"hostname:6002\"), displayStr=\"2\"\n //\tconnect(\"tcp/hostname:1.0\")   // calls net.Dial(\"tcp\", \"\", \"hostname:6001\"), displayStr=\"1\"\n-func connect(display string) (conn net.Conn, displayStr string, err os.Error) {\n+func connect(display string) (conn net.Conn, displayStr string, err error) {\n \tcolonIdx := strings.LastIndex(display, \":\")\n \tif colonIdx < 0 {\n-\t\treturn nil, \"\", os.NewError(\"bad display: \" + display)\n+\t\treturn nil, \"\", errors.New(\"bad display: \" + display)\n \t}\n \t// Parse the section before the colon.\n \tvar protocol, host, socket string\n@@ -275,7 +276,7 @@ func connect(display string) (conn net.Conn, displayStr string, err os.Error) {\n \t// Parse the section after the colon.\n \tafter := display[colonIdx+1:]\n \tif after == \"\" {\n-\t\treturn nil, \"\", os.NewError(\"bad display: \" + display)\n+\t\treturn nil, \"\", errors.New(\"bad display: \" + display)\n \t}\n \tif i := strings.LastIndex(after, \".\"); i < 0 {\n \t\tdisplayStr = after\n@@ -284,7 +285,7 @@ func connect(display string) (conn net.Conn, displayStr string, err os.Error) {\n \t}\n \tdisplayInt, err := strconv.Atoi(displayStr)\n \tif err != nil || displayInt < 0 {\n-\t\treturn nil, \"\", os.NewError(\"bad display: \" + display)\n+\t\treturn nil, \"\", errors.New(\"bad display: \" + display)\n \t}\n \t// Make the connection.\n \tif socket != \"\" {\n@@ -295,21 +296,21 @@ func connect(display string) (conn net.Conn, displayStr string, err os.Error) {\n \t\tconn, err = net.Dial(\"unix\", \"/tmp/.X11-unix/X\"+displayStr)\n \t}\n \tif err != nil {\n-\t\treturn nil, \"\", os.NewError(\"cannot connect to \" + display + \": \" + err.String())\n+\t\treturn nil, \"\", errors.New(\"cannot connect to \" + display + \": \" + err.Error())\n \t}\n \treturn\n }\n \n // authenticate authenticates ourselves with the X server.\n // displayStr is the \"12\" out of \":12.0\".\n-func authenticate(w *bufio.Writer, displayStr string) os.Error {\n+func authenticate(w *bufio.Writer, displayStr string) error {\n \tkey, value, err := readAuth(displayStr)\n \tif err != nil {\n \t\treturn err\n \t}\n \t// Assume that the authentication protocol is \"MIT-MAGIC-COOKIE-1\".\n \tif len(key) != 18 || len(value) != 16 {\n-\t\treturn os.NewError(\"unsupported Xauth\")\n+\t\treturn errors.New(\"unsupported Xauth\")\n \t}\n \t// 0x006c means little-endian. 0x000b, 0x0000 means X major version 11, minor version 0.\n \t// 0x0012 and 0x0010 means the auth key and value have lengths 18 and 16.\n@@ -339,7 +340,7 @@ func authenticate(w *bufio.Writer, displayStr string) os.Error {\n }\n \n // readU8 reads a uint8 from r, using b as a scratch buffer.\n-func readU8(r io.Reader, b []byte) (uint8, os.Error) {\n+func readU8(r io.Reader, b []byte) (uint8, error) {\n \t_, err := io.ReadFull(r, b[:1])\n \tif err != nil {\n \t\treturn 0, err\n@@ -348,7 +349,7 @@ func readU8(r io.Reader, b []byte) (uint8, os.Error) {\n }\n \n // readU16LE reads a little-endian uint16 from r, using b as a scratch buffer.\n-func readU16LE(r io.Reader, b []byte) (uint16, os.Error) {\n+func readU16LE(r io.Reader, b []byte) (uint16, error) {\n \t_, err := io.ReadFull(r, b[:2])\n \tif err != nil {\n \t\treturn 0, err\n@@ -357,7 +358,7 @@ func readU16LE(r io.Reader, b []byte) (uint16, os.Error) {\n }\n \n // readU32LE reads a little-endian uint32 from r, using b as a scratch buffer.\n-func readU32LE(r io.Reader, b []byte) (uint32, os.Error) {\n+func readU32LE(r io.Reader, b []byte) (uint32, error) {\n \t_, err := io.ReadFull(r, b[:4])\n \tif err != nil {\n \t\treturn 0, err\n@@ -374,7 +375,7 @@ func setU32LE(b []byte, u uint32) {\n }\n \n // checkPixmapFormats checks that we have an agreeable X pixmap Format.\n-func checkPixmapFormats(r io.Reader, b []byte, n int) (agree bool, err os.Error) {\n+func checkPixmapFormats(r io.Reader, b []byte, n int) (agree bool, err error) {\n \tfor i := 0; i < n; i++ {\n \t\t_, err = io.ReadFull(r, b[:8])\n \t\tif err != nil {\n@@ -389,7 +390,7 @@ func checkPixmapFormats(r io.Reader, b []byte, n int) (agree bool, err os.Error)\n }\n \n // checkDepths checks that we have an agreeable X Depth (i.e. one that has an agreeable X VisualType).\n-func checkDepths(r io.Reader, b []byte, n int, visual uint32) (agree bool, err os.Error) {\n+func checkDepths(r io.Reader, b []byte, n int, visual uint32) (agree bool, err error) {\n \tfor i := 0; i < n; i++ {\n \t\tvar depth, visualsLen uint16\n \t\tdepth, err = readU16LE(r, b)\n@@ -427,7 +428,7 @@ func checkDepths(r io.Reader, b []byte, n int, visual uint32) (agree bool, err o\n }\n \n // checkScreens checks that we have an agreeable X Screen.\n-func checkScreens(r io.Reader, b []byte, n int) (root, visual uint32, err os.Error) {\n+func checkScreens(r io.Reader, b []byte, n int) (root, visual uint32, err error) {\n \tfor i := 0; i < n; i++ {\n \t\tvar root0, visual0, x uint32\n \t\troot0, err = readU32LE(r, b)\n@@ -465,14 +466,14 @@ func checkScreens(r io.Reader, b []byte, n int) (root, visual uint32, err os.Err\n \n // handshake performs the protocol handshake with the X server, and ensures\n // that the server provides a compatible Screen, Depth, etc.\n-func (c *conn) handshake() os.Error {\n+func (c *conn) handshake() error {\n \t_, err := io.ReadFull(c.r, c.buf[:8])\n \tif err != nil {\n \t\treturn err\n \t}\n \t// Byte 0 should be 1 (success), bytes 2:6 should be 0xb0000000 (major/minor version 11.0).\n \tif c.buf[0] != 1 || c.buf[2] != 11 || c.buf[3] != 0 || c.buf[4] != 0 || c.buf[5] != 0 {\n-\t\treturn os.NewError(\"unsupported X version\")\n+\t\treturn errors.New(\"unsupported X version\")\n \t}\n \t// Ignore the release number.\n \t_, err = io.ReadFull(c.r, c.buf[:4])\n@@ -490,7 +491,7 @@ func (c *conn) handshake() os.Error {\n \t\treturn err\n \t}\n \tif resourceIdMask < 256 {\n-\t\treturn os.NewError(\"X resource ID mask is too small\")\n+\t\treturn errors.New(\"X resource ID mask is too small\")\n \t}\n \t// Ignore the motion buffer size.\n \t_, err = io.ReadFull(c.r, c.buf[:4])\n@@ -510,7 +511,7 @@ func (c *conn) handshake() os.Error {\n \t\treturn err\n \t}\n \tif maxReqLen != 0xffff {\n-\t\treturn os.NewError(\"unsupported X maximum request length\")\n+\t\treturn errors.New(\"unsupported X maximum request length\")\n \t}\n \t// Read the roots length.\n \trootsLen, err := readU8(c.r, c.buf[:1])\n@@ -526,7 +527,7 @@ func (c *conn) handshake() os.Error {\n \t// imageByteOrder(1), bitmapFormatBitOrder(1), bitmapFormatScanlineUnit(1) bitmapFormatScanlinePad(1),\n \t// minKeycode(1), maxKeycode(1), padding(4), vendor (vendorLen).\n \tif 10+int(vendorLen) > cap(c.buf) {\n-\t\treturn os.NewError(\"unsupported X vendor\")\n+\t\treturn errors.New(\"unsupported X vendor\")\n \t}\n \t_, err = io.ReadFull(c.r, c.buf[:10+int(vendorLen)])\n \tif err != nil {\n@@ -538,15 +539,15 @@ func (c *conn) handshake() os.Error {\n \t\treturn err\n \t}\n \tif !agree {\n-\t\treturn os.NewError(\"unsupported X pixmap formats\")\n+\t\treturn errors.New(\"unsupported X pixmap formats\")\n \t}\n \t// Check that we have an agreeable screen.\n \troot, visual, err := checkScreens(c.r, c.buf[:24], int(rootsLen))\n \tif err != nil {\n \t\treturn err\n \t}\n \tif root == 0 || visual == 0 {\n-\t\treturn os.NewError(\"unsupported X screen\")\n+\t\treturn errors.New(\"unsupported X screen\")\n \t}\n \tc.gc = resID(resourceIdBase)\n \tc.window = resID(resourceIdBase + 1)\n@@ -556,18 +557,18 @@ func (c *conn) handshake() os.Error {\n }\n \n // NewWindow calls NewWindowDisplay with $DISPLAY.\n-func NewWindow() (gui.Window, os.Error) {\n+func NewWindow() (gui.Window, error) {\n \tdisplay := os.Getenv(\"DISPLAY\")\n \tif len(display) == 0 {\n-\t\treturn nil, os.NewError(\"$DISPLAY not set\")\n+\t\treturn nil, errors.New(\"$DISPLAY not set\")\n \t}\n \treturn NewWindowDisplay(display)\n }\n \n // NewWindowDisplay returns a new gui.Window, backed by a newly created and\n // mapped X11 window. The X server to connect to is specified by the display\n // string, such as \":1\".\n-func NewWindowDisplay(display string) (gui.Window, os.Error) {\n+func NewWindowDisplay(display string) (gui.Window, error) {\n \tsocket, displayStr, err := connect(display)\n \tif err != nil {\n \t\treturn nil, err"}, {"sha": "d6b7e8514e63b0bd1d6f7c77875368d516797382", "filename": "libgo/go/exp/inotify/inotify_linux.go", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -27,6 +27,7 @@ Example:\n package inotify\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"os\"\n \t\"strings\"\n@@ -49,14 +50,14 @@ type Watcher struct {\n \tfd       int               // File descriptor (as returned by the inotify_init() syscall)\n \twatches  map[string]*watch // Map of inotify watches (key: path)\n \tpaths    map[int]string    // Map of watched paths (key: watch descriptor)\n-\tError    chan os.Error     // Errors are sent on this channel\n+\tError    chan error        // Errors are sent on this channel\n \tEvent    chan *Event       // Events are returned on this channel\n \tdone     chan bool         // Channel for sending a \"quit message\" to the reader goroutine\n \tisClosed bool              // Set to true when Close() is first called\n }\n \n // NewWatcher creates and returns a new inotify instance using inotify_init(2)\n-func NewWatcher() (*Watcher, os.Error) {\n+func NewWatcher() (*Watcher, error) {\n \tfd, errno := syscall.InotifyInit()\n \tif fd == -1 {\n \t\treturn nil, os.NewSyscallError(\"inotify_init\", errno)\n@@ -66,7 +67,7 @@ func NewWatcher() (*Watcher, os.Error) {\n \t\twatches: make(map[string]*watch),\n \t\tpaths:   make(map[int]string),\n \t\tEvent:   make(chan *Event),\n-\t\tError:   make(chan os.Error),\n+\t\tError:   make(chan error),\n \t\tdone:    make(chan bool, 1),\n \t}\n \n@@ -77,7 +78,7 @@ func NewWatcher() (*Watcher, os.Error) {\n // Close closes an inotify watcher instance\n // It sends a message to the reader goroutine to quit and removes all watches\n // associated with the inotify instance\n-func (w *Watcher) Close() os.Error {\n+func (w *Watcher) Close() error {\n \tif w.isClosed {\n \t\treturn nil\n \t}\n@@ -94,9 +95,9 @@ func (w *Watcher) Close() os.Error {\n \n // AddWatch adds path to the watched file set.\n // The flags are interpreted as described in inotify_add_watch(2).\n-func (w *Watcher) AddWatch(path string, flags uint32) os.Error {\n+func (w *Watcher) AddWatch(path string, flags uint32) error {\n \tif w.isClosed {\n-\t\treturn os.NewError(\"inotify instance already closed\")\n+\t\treturn errors.New(\"inotify instance already closed\")\n \t}\n \n \twatchEntry, found := w.watches[path]\n@@ -117,15 +118,15 @@ func (w *Watcher) AddWatch(path string, flags uint32) os.Error {\n }\n \n // Watch adds path to the watched file set, watching all events.\n-func (w *Watcher) Watch(path string) os.Error {\n+func (w *Watcher) Watch(path string) error {\n \treturn w.AddWatch(path, IN_ALL_EVENTS)\n }\n \n // RemoveWatch removes path from the watched file set.\n-func (w *Watcher) RemoveWatch(path string) os.Error {\n+func (w *Watcher) RemoveWatch(path string) error {\n \twatch, ok := w.watches[path]\n \tif !ok {\n-\t\treturn os.NewError(fmt.Sprintf(\"can't remove non-existent inotify watch for: %s\", path))\n+\t\treturn errors.New(fmt.Sprintf(\"can't remove non-existent inotify watch for: %s\", path))\n \t}\n \tsuccess, errno := syscall.InotifyRmWatch(w.fd, watch.wd)\n \tif success == -1 {\n@@ -168,7 +169,7 @@ func (w *Watcher) readEvents() {\n \t\t\tcontinue\n \t\t}\n \t\tif n < syscall.SizeofInotifyEvent {\n-\t\t\tw.Error <- os.NewError(\"inotify: short read in readEvents()\")\n+\t\t\tw.Error <- errors.New(\"inotify: short read in readEvents()\")\n \t\t\tcontinue\n \t\t}\n "}, {"sha": "c7a3762bdeb625edee63ca31a590a839403c7d30", "filename": "libgo/go/exp/norm/maketables.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -220,7 +220,7 @@ func openReader(file string) (input io.ReadCloser) {\n \treturn\n }\n \n-func parseDecomposition(s string, skipfirst bool) (a []rune, e os.Error) {\n+func parseDecomposition(s string, skipfirst bool) (a []rune, e error) {\n \tdecomp := strings.Split(s, \" \")\n \tif len(decomp) > 0 && skipfirst {\n \t\tdecomp = decomp[1:]\n@@ -310,7 +310,7 @@ func loadUnicodeData() {\n \tfor {\n \t\tline, err := input.ReadString('\\n')\n \t\tif err != nil {\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tlogger.Fatal(err)\n@@ -350,7 +350,7 @@ func loadCompositionExclusions() {\n \tfor {\n \t\tline, err := input.ReadString('\\n')\n \t\tif err != nil {\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tlogger.Fatal(err)\n@@ -782,7 +782,7 @@ func testDerived() {\n \tfor {\n \t\tline, err := input.ReadString('\\n')\n \t\tif err != nil {\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tlogger.Fatal(err)"}, {"sha": "744bb1cd6c2c51f2923679a9efecb3a642f11c6e", "filename": "libgo/go/exp/norm/normregtest.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"flag\"\n \t\"fmt\"\n \t\"http\"\n+\t\"io\"\n \t\"log\"\n \t\"os\"\n \t\"path\"\n@@ -141,7 +142,7 @@ func loadTestData() {\n \tfor {\n \t\tline, err := input.ReadString('\\n')\n \t\tif err != nil {\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tlogger.Fatal(err)"}, {"sha": "ee58abd22de1f9e2798c1ef3ddb9a662e7bed40f", "filename": "libgo/go/exp/norm/readwriter.go", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,10 +4,7 @@\n \n package norm\n \n-import (\n-\t\"io\"\n-\t\"os\"\n-)\n+import \"io\"\n \n type normWriter struct {\n \trb  reorderBuffer\n@@ -18,7 +15,7 @@ type normWriter struct {\n // Write implements the standard write interface.  If the last characters are\n // not at a normalization boundary, the bytes will be buffered for the next\n // write. The remaining bytes will be written on close.\n-func (w *normWriter) Write(data []byte) (n int, err os.Error) {\n+func (w *normWriter) Write(data []byte) (n int, err error) {\n \t// Process data in pieces to keep w.buf size bounded.\n \tconst chunk = 4000\n \n@@ -52,7 +49,7 @@ func (w *normWriter) Write(data []byte) (n int, err os.Error) {\n }\n \n // Close forces data that remains in the buffer to be written.\n-func (w *normWriter) Close() os.Error {\n+func (w *normWriter) Close() error {\n \tif len(w.buf) > 0 {\n \t\t_, err := w.w.Write(w.buf)\n \t\tif err != nil {\n@@ -79,11 +76,11 @@ type normReader struct {\n \toutbuf       []byte\n \tbufStart     int\n \tlastBoundary int\n-\terr          os.Error\n+\terr          error\n }\n \n // Read implements the standard read interface.\n-func (r *normReader) Read(p []byte) (int, os.Error) {\n+func (r *normReader) Read(p []byte) (int, error) {\n \tfor {\n \t\tif r.lastBoundary-r.bufStart > 0 {\n \t\t\tn := copy(p, r.outbuf[r.bufStart:r.lastBoundary])\n@@ -106,7 +103,7 @@ func (r *normReader) Read(p []byte) (int, os.Error) {\n \t\tif n > 0 {\n \t\t\tr.outbuf = doAppend(&r.rb, r.outbuf)\n \t\t}\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\tr.lastBoundary = len(r.outbuf)\n \t\t} else {\n \t\t\tr.lastBoundary = lastBoundary(&r.rb.f, r.outbuf)"}, {"sha": "3b49eb0a2f08631adb454bb3c1e65da093a82fd8", "filename": "libgo/go/exp/norm/readwriter_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package norm\n import (\n \t\"bytes\"\n \t\"fmt\"\n-\t\"os\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -27,7 +26,7 @@ func readFunc(size int) appendFunc {\n \t\tr := f.Reader(bytes.NewBuffer(out))\n \t\tbuf := make([]byte, size)\n \t\tresult := []byte{}\n-\t\tfor n, err := 0, os.Error(nil); err == nil; {\n+\t\tfor n, err := 0, error(nil); err == nil; {\n \t\t\tn, err = r.Read(buf)\n \t\t\tresult = append(result, buf[:n]...)\n \t\t}"}, {"sha": "3de80c04d78412573c2a3279a753855fcadf933b", "filename": "libgo/go/exp/spdy/read.go", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fspdy%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fspdy%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspdy%2Fread.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,19 +9,18 @@ import (\n \t\"encoding/binary\"\n \t\"http\"\n \t\"io\"\n-\t\"os\"\n \t\"strings\"\n )\n \n-func (frame *SynStreamFrame) read(h ControlFrameHeader, f *Framer) os.Error {\n+func (frame *SynStreamFrame) read(h ControlFrameHeader, f *Framer) error {\n \treturn f.readSynStreamFrame(h, frame)\n }\n \n-func (frame *SynReplyFrame) read(h ControlFrameHeader, f *Framer) os.Error {\n+func (frame *SynReplyFrame) read(h ControlFrameHeader, f *Framer) error {\n \treturn f.readSynReplyFrame(h, frame)\n }\n \n-func (frame *RstStreamFrame) read(h ControlFrameHeader, f *Framer) os.Error {\n+func (frame *RstStreamFrame) read(h ControlFrameHeader, f *Framer) error {\n \tframe.CFHeader = h\n \tif err := binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {\n \t\treturn err\n@@ -32,7 +31,7 @@ func (frame *RstStreamFrame) read(h ControlFrameHeader, f *Framer) os.Error {\n \treturn nil\n }\n \n-func (frame *SettingsFrame) read(h ControlFrameHeader, f *Framer) os.Error {\n+func (frame *SettingsFrame) read(h ControlFrameHeader, f *Framer) error {\n \tframe.CFHeader = h\n \tvar numSettings uint32\n \tif err := binary.Read(f.r, binary.BigEndian, &numSettings); err != nil {\n@@ -52,32 +51,32 @@ func (frame *SettingsFrame) read(h ControlFrameHeader, f *Framer) os.Error {\n \treturn nil\n }\n \n-func (frame *NoopFrame) read(h ControlFrameHeader, f *Framer) os.Error {\n+func (frame *NoopFrame) read(h ControlFrameHeader, f *Framer) error {\n \tframe.CFHeader = h\n \treturn nil\n }\n \n-func (frame *PingFrame) read(h ControlFrameHeader, f *Framer) os.Error {\n+func (frame *PingFrame) read(h ControlFrameHeader, f *Framer) error {\n \tframe.CFHeader = h\n \tif err := binary.Read(f.r, binary.BigEndian, &frame.Id); err != nil {\n \t\treturn err\n \t}\n \treturn nil\n }\n \n-func (frame *GoAwayFrame) read(h ControlFrameHeader, f *Framer) os.Error {\n+func (frame *GoAwayFrame) read(h ControlFrameHeader, f *Framer) error {\n \tframe.CFHeader = h\n \tif err := binary.Read(f.r, binary.BigEndian, &frame.LastGoodStreamId); err != nil {\n \t\treturn err\n \t}\n \treturn nil\n }\n \n-func (frame *HeadersFrame) read(h ControlFrameHeader, f *Framer) os.Error {\n+func (frame *HeadersFrame) read(h ControlFrameHeader, f *Framer) error {\n \treturn f.readHeadersFrame(h, frame)\n }\n \n-func newControlFrame(frameType ControlFrameType) (controlFrame, os.Error) {\n+func newControlFrame(frameType ControlFrameType) (controlFrame, error) {\n \tctor, ok := cframeCtor[frameType]\n \tif !ok {\n \t\treturn nil, &Error{Err: InvalidControlFrame}\n@@ -97,7 +96,7 @@ var cframeCtor = map[ControlFrameType]func() controlFrame{\n \t// TODO(willchan): Add TypeWindowUpdate\n }\n \n-func (f *Framer) uncorkHeaderDecompressor(payloadSize int64) os.Error {\n+func (f *Framer) uncorkHeaderDecompressor(payloadSize int64) error {\n \tif f.headerDecompressor != nil {\n \t\tf.headerReader.N = payloadSize\n \t\treturn nil\n@@ -112,7 +111,7 @@ func (f *Framer) uncorkHeaderDecompressor(payloadSize int64) os.Error {\n }\n \n // ReadFrame reads SPDY encoded data and returns a decompressed Frame.\n-func (f *Framer) ReadFrame() (Frame, os.Error) {\n+func (f *Framer) ReadFrame() (Frame, error) {\n \tvar firstWord uint32\n \tif err := binary.Read(f.r, binary.BigEndian, &firstWord); err != nil {\n \t\treturn nil, err\n@@ -125,7 +124,7 @@ func (f *Framer) ReadFrame() (Frame, os.Error) {\n \treturn f.parseDataFrame(firstWord & 0x7fffffff)\n }\n \n-func (f *Framer) parseControlFrame(version uint16, frameType ControlFrameType) (Frame, os.Error) {\n+func (f *Framer) parseControlFrame(version uint16, frameType ControlFrameType) (Frame, error) {\n \tvar length uint32\n \tif err := binary.Read(f.r, binary.BigEndian, &length); err != nil {\n \t\treturn nil, err\n@@ -143,12 +142,12 @@ func (f *Framer) parseControlFrame(version uint16, frameType ControlFrameType) (\n \treturn cframe, nil\n }\n \n-func parseHeaderValueBlock(r io.Reader, streamId uint32) (http.Header, os.Error) {\n+func parseHeaderValueBlock(r io.Reader, streamId uint32) (http.Header, error) {\n \tvar numHeaders uint16\n \tif err := binary.Read(r, binary.BigEndian, &numHeaders); err != nil {\n \t\treturn nil, err\n \t}\n-\tvar e os.Error\n+\tvar e error\n \th := make(http.Header, int(numHeaders))\n \tfor i := 0; i < int(numHeaders); i++ {\n \t\tvar length uint16\n@@ -185,9 +184,9 @@ func parseHeaderValueBlock(r io.Reader, streamId uint32) (http.Header, os.Error)\n \treturn h, nil\n }\n \n-func (f *Framer) readSynStreamFrame(h ControlFrameHeader, frame *SynStreamFrame) os.Error {\n+func (f *Framer) readSynStreamFrame(h ControlFrameHeader, frame *SynStreamFrame) error {\n \tframe.CFHeader = h\n-\tvar err os.Error\n+\tvar err error\n \tif err = binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {\n \t\treturn err\n \t}\n@@ -206,7 +205,7 @@ func (f *Framer) readSynStreamFrame(h ControlFrameHeader, frame *SynStreamFrame)\n \t}\n \n \tframe.Headers, err = parseHeaderValueBlock(reader, frame.StreamId)\n-\tif !f.headerCompressionDisabled && ((err == os.EOF && f.headerReader.N == 0) || f.headerReader.N != 0) {\n+\tif !f.headerCompressionDisabled && ((err == io.EOF && f.headerReader.N == 0) || f.headerReader.N != 0) {\n \t\terr = &Error{WrongCompressedPayloadSize, 0}\n \t}\n \tif err != nil {\n@@ -223,9 +222,9 @@ func (f *Framer) readSynStreamFrame(h ControlFrameHeader, frame *SynStreamFrame)\n \treturn nil\n }\n \n-func (f *Framer) readSynReplyFrame(h ControlFrameHeader, frame *SynReplyFrame) os.Error {\n+func (f *Framer) readSynReplyFrame(h ControlFrameHeader, frame *SynReplyFrame) error {\n \tframe.CFHeader = h\n-\tvar err os.Error\n+\tvar err error\n \tif err = binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {\n \t\treturn err\n \t}\n@@ -239,7 +238,7 @@ func (f *Framer) readSynReplyFrame(h ControlFrameHeader, frame *SynReplyFrame) o\n \t\treader = f.headerDecompressor\n \t}\n \tframe.Headers, err = parseHeaderValueBlock(reader, frame.StreamId)\n-\tif !f.headerCompressionDisabled && ((err == os.EOF && f.headerReader.N == 0) || f.headerReader.N != 0) {\n+\tif !f.headerCompressionDisabled && ((err == io.EOF && f.headerReader.N == 0) || f.headerReader.N != 0) {\n \t\terr = &Error{WrongCompressedPayloadSize, 0}\n \t}\n \tif err != nil {\n@@ -256,9 +255,9 @@ func (f *Framer) readSynReplyFrame(h ControlFrameHeader, frame *SynReplyFrame) o\n \treturn nil\n }\n \n-func (f *Framer) readHeadersFrame(h ControlFrameHeader, frame *HeadersFrame) os.Error {\n+func (f *Framer) readHeadersFrame(h ControlFrameHeader, frame *HeadersFrame) error {\n \tframe.CFHeader = h\n-\tvar err os.Error\n+\tvar err error\n \tif err = binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {\n \t\treturn err\n \t}\n@@ -272,7 +271,7 @@ func (f *Framer) readHeadersFrame(h ControlFrameHeader, frame *HeadersFrame) os.\n \t\treader = f.headerDecompressor\n \t}\n \tframe.Headers, err = parseHeaderValueBlock(reader, frame.StreamId)\n-\tif !f.headerCompressionDisabled && ((err == os.EOF && f.headerReader.N == 0) || f.headerReader.N != 0) {\n+\tif !f.headerCompressionDisabled && ((err == io.EOF && f.headerReader.N == 0) || f.headerReader.N != 0) {\n \t\terr = &Error{WrongCompressedPayloadSize, 0}\n \t}\n \tif err != nil {\n@@ -296,7 +295,7 @@ func (f *Framer) readHeadersFrame(h ControlFrameHeader, frame *HeadersFrame) os.\n \treturn nil\n }\n \n-func (f *Framer) parseDataFrame(streamId uint32) (*DataFrame, os.Error) {\n+func (f *Framer) parseDataFrame(streamId uint32) (*DataFrame, error) {\n \tvar length uint32\n \tif err := binary.Read(f.r, binary.BigEndian, &length); err != nil {\n \t\treturn nil, err"}, {"sha": "87d6edbd560307a76bb37dcc81dd73643eb09b05", "filename": "libgo/go/exp/spdy/types.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fspdy%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fspdy%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspdy%2Ftypes.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"compress/zlib\"\n \t\"http\"\n \t\"io\"\n-\t\"os\"\n )\n \n //  Data Frame Format\n@@ -161,7 +160,7 @@ const MaxDataLength = 1<<24 - 1\n // Frame is a single SPDY frame in its unpacked in-memory representation. Use\n // Framer to read and write it.\n type Frame interface {\n-\twrite(f *Framer) os.Error\n+\twrite(f *Framer) error\n }\n \n // ControlFrameHeader contains all the fields in a control frame header,\n@@ -176,7 +175,7 @@ type ControlFrameHeader struct {\n \n type controlFrame interface {\n \tFrame\n-\tread(h ControlFrameHeader, f *Framer) os.Error\n+\tread(h ControlFrameHeader, f *Framer) error\n }\n \n // SynStreamFrame is the unpacked, in-memory representation of a SYN_STREAM\n@@ -321,7 +320,7 @@ type Error struct {\n \tStreamId uint32\n }\n \n-func (e *Error) String() string {\n+func (e *Error) Error() string {\n \treturn string(e.Err)\n }\n \n@@ -354,7 +353,7 @@ type Framer struct {\n // a io.Writer and io.Reader. Note that Framer will read and write individual fields \n // from/to the Reader and Writer, so the caller should pass in an appropriately \n // buffered implementation to optimize performance.\n-func NewFramer(w io.Writer, r io.Reader) (*Framer, os.Error) {\n+func NewFramer(w io.Writer, r io.Reader) (*Framer, error) {\n \tcompressBuf := new(bytes.Buffer)\n \tcompressor, err := zlib.NewWriterDict(compressBuf, zlib.BestCompression, []byte(HeaderDictionary))\n \tif err != nil {"}, {"sha": "537154fbd3d2208992716d35fc32ff04c7749baf", "filename": "libgo/go/exp/spdy/write.go", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fspdy%2Fwrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fspdy%2Fwrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspdy%2Fwrite.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,19 +8,18 @@ import (\n \t\"encoding/binary\"\n \t\"http\"\n \t\"io\"\n-\t\"os\"\n \t\"strings\"\n )\n \n-func (frame *SynStreamFrame) write(f *Framer) os.Error {\n+func (frame *SynStreamFrame) write(f *Framer) error {\n \treturn f.writeSynStreamFrame(frame)\n }\n \n-func (frame *SynReplyFrame) write(f *Framer) os.Error {\n+func (frame *SynReplyFrame) write(f *Framer) error {\n \treturn f.writeSynReplyFrame(frame)\n }\n \n-func (frame *RstStreamFrame) write(f *Framer) (err os.Error) {\n+func (frame *RstStreamFrame) write(f *Framer) (err error) {\n \tframe.CFHeader.version = Version\n \tframe.CFHeader.frameType = TypeRstStream\n \tframe.CFHeader.length = 8\n@@ -38,7 +37,7 @@ func (frame *RstStreamFrame) write(f *Framer) (err os.Error) {\n \treturn\n }\n \n-func (frame *SettingsFrame) write(f *Framer) (err os.Error) {\n+func (frame *SettingsFrame) write(f *Framer) (err error) {\n \tframe.CFHeader.version = Version\n \tframe.CFHeader.frameType = TypeSettings\n \tframe.CFHeader.length = uint32(len(frame.FlagIdValues)*8 + 4)\n@@ -62,15 +61,15 @@ func (frame *SettingsFrame) write(f *Framer) (err os.Error) {\n \treturn\n }\n \n-func (frame *NoopFrame) write(f *Framer) os.Error {\n+func (frame *NoopFrame) write(f *Framer) error {\n \tframe.CFHeader.version = Version\n \tframe.CFHeader.frameType = TypeNoop\n \n \t// Serialize frame to Writer\n \treturn writeControlFrameHeader(f.w, frame.CFHeader)\n }\n \n-func (frame *PingFrame) write(f *Framer) (err os.Error) {\n+func (frame *PingFrame) write(f *Framer) (err error) {\n \tframe.CFHeader.version = Version\n \tframe.CFHeader.frameType = TypePing\n \tframe.CFHeader.length = 4\n@@ -85,7 +84,7 @@ func (frame *PingFrame) write(f *Framer) (err os.Error) {\n \treturn\n }\n \n-func (frame *GoAwayFrame) write(f *Framer) (err os.Error) {\n+func (frame *GoAwayFrame) write(f *Framer) (err error) {\n \tframe.CFHeader.version = Version\n \tframe.CFHeader.frameType = TypeGoAway\n \tframe.CFHeader.length = 4\n@@ -100,20 +99,20 @@ func (frame *GoAwayFrame) write(f *Framer) (err os.Error) {\n \treturn nil\n }\n \n-func (frame *HeadersFrame) write(f *Framer) os.Error {\n+func (frame *HeadersFrame) write(f *Framer) error {\n \treturn f.writeHeadersFrame(frame)\n }\n \n-func (frame *DataFrame) write(f *Framer) os.Error {\n+func (frame *DataFrame) write(f *Framer) error {\n \treturn f.writeDataFrame(frame)\n }\n \n // WriteFrame writes a frame.\n-func (f *Framer) WriteFrame(frame Frame) os.Error {\n+func (f *Framer) WriteFrame(frame Frame) error {\n \treturn frame.write(f)\n }\n \n-func writeControlFrameHeader(w io.Writer, h ControlFrameHeader) os.Error {\n+func writeControlFrameHeader(w io.Writer, h ControlFrameHeader) error {\n \tif err := binary.Write(w, binary.BigEndian, 0x8000|h.version); err != nil {\n \t\treturn err\n \t}\n@@ -127,7 +126,7 @@ func writeControlFrameHeader(w io.Writer, h ControlFrameHeader) os.Error {\n \treturn nil\n }\n \n-func writeHeaderValueBlock(w io.Writer, h http.Header) (n int, err os.Error) {\n+func writeHeaderValueBlock(w io.Writer, h http.Header) (n int, err error) {\n \tn = 0\n \tif err = binary.Write(w, binary.BigEndian, uint16(len(h))); err != nil {\n \t\treturn\n@@ -156,7 +155,7 @@ func writeHeaderValueBlock(w io.Writer, h http.Header) (n int, err os.Error) {\n \treturn\n }\n \n-func (f *Framer) writeSynStreamFrame(frame *SynStreamFrame) (err os.Error) {\n+func (f *Framer) writeSynStreamFrame(frame *SynStreamFrame) (err error) {\n \t// Marshal the headers.\n \tvar writer io.Writer = f.headerBuf\n \tif !f.headerCompressionDisabled {\n@@ -194,7 +193,7 @@ func (f *Framer) writeSynStreamFrame(frame *SynStreamFrame) (err os.Error) {\n \treturn nil\n }\n \n-func (f *Framer) writeSynReplyFrame(frame *SynReplyFrame) (err os.Error) {\n+func (f *Framer) writeSynReplyFrame(frame *SynReplyFrame) (err error) {\n \t// Marshal the headers.\n \tvar writer io.Writer = f.headerBuf\n \tif !f.headerCompressionDisabled {\n@@ -229,7 +228,7 @@ func (f *Framer) writeSynReplyFrame(frame *SynReplyFrame) (err os.Error) {\n \treturn\n }\n \n-func (f *Framer) writeHeadersFrame(frame *HeadersFrame) (err os.Error) {\n+func (f *Framer) writeHeadersFrame(frame *HeadersFrame) (err error) {\n \t// Marshal the headers.\n \tvar writer io.Writer = f.headerBuf\n \tif !f.headerCompressionDisabled {\n@@ -264,7 +263,7 @@ func (f *Framer) writeHeadersFrame(frame *HeadersFrame) (err os.Error) {\n \treturn\n }\n \n-func (f *Framer) writeDataFrame(frame *DataFrame) (err os.Error) {\n+func (f *Framer) writeDataFrame(frame *DataFrame) (err error) {\n \t// Validate DataFrame\n \tif frame.StreamId&0x80000000 != 0 || len(frame.Data) >= 0x0f000000 {\n \t\treturn &Error{InvalidDataFrame, frame.StreamId}"}, {"sha": "b1feef0eb828329f2508462161ec148048c1ed1f", "filename": "libgo/go/exp/sql/convert.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fconvert.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,16 +7,16 @@\n package sql\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n-\t\"os\"\n \t\"reflect\"\n \t\"strconv\"\n )\n \n // convertAssign copies to dest the value in src, converting it if possible.\n // An error is returned if the copy would result in loss of information.\n // dest should be a pointer type.\n-func convertAssign(dest, src interface{}) os.Error {\n+func convertAssign(dest, src interface{}) error {\n \t// Common cases, without reflect.  Fall through.\n \tswitch s := src.(type) {\n \tcase string:\n@@ -56,7 +56,7 @@ func convertAssign(dest, src interface{}) os.Error {\n \n \tdpv := reflect.ValueOf(dest)\n \tif dpv.Kind() != reflect.Ptr {\n-\t\treturn os.NewError(\"destination not a pointer\")\n+\t\treturn errors.New(\"destination not a pointer\")\n \t}\n \n \tdv := reflect.Indirect(dpv)"}, {"sha": "f85ed99978d53f6a69c9428840d4d2c9b09f0ae6", "filename": "libgo/go/exp/sql/convert_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fconvert_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -68,7 +68,7 @@ func TestConversions(t *testing.T) {\n \t\terr := convertAssign(ct.d, ct.s)\n \t\terrstr := \"\"\n \t\tif err != nil {\n-\t\t\terrstr = err.String()\n+\t\t\terrstr = err.Error()\n \t\t}\n \t\terrf := func(format string, args ...interface{}) {\n \t\t\tbase := fmt.Sprintf(\"convertAssign #%d: for %v (%T) -> %T, \", n, ct.s, ct.s, ct.d)"}, {"sha": "52714e817a3007e562a40e0f8d1f00240b4e1a8e", "filename": "libgo/go/exp/sql/driver/driver.go", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -19,9 +19,7 @@\n //\n package driver\n \n-import (\n-\t\"os\"\n-)\n+import \"errors\"\n \n // Driver is the interface that must be implemented by a database\n // driver.\n@@ -31,7 +29,7 @@ type Driver interface {\n \t//\n \t// The returned connection is only used by one goroutine at a\n \t// time.\n-\tOpen(name string) (Conn, os.Error)\n+\tOpen(name string) (Conn, error)\n }\n \n // Execer is an optional interface that may be implemented by a Driver\n@@ -48,7 +46,7 @@ type Driver interface {\n //\n // All arguments are of a subset type as defined in the package docs.\n type Execer interface {\n-\tExec(query string, args []interface{}) (Result, os.Error)\n+\tExec(query string, args []interface{}) (Result, error)\n }\n \n // Conn is a connection to a database. It is not used concurrently\n@@ -57,47 +55,47 @@ type Execer interface {\n // Conn is assumed to be stateful.\n type Conn interface {\n \t// Prepare returns a prepared statement, bound to this connection.\n-\tPrepare(query string) (Stmt, os.Error)\n+\tPrepare(query string) (Stmt, error)\n \n \t// Close invalidates and potentially stops any current\n \t// prepared statements and transactions, marking this\n \t// connection as no longer in use.  The driver may cache or\n \t// close its underlying connection to its database.\n-\tClose() os.Error\n+\tClose() error\n \n \t// Begin starts and returns a new transaction.\n-\tBegin() (Tx, os.Error)\n+\tBegin() (Tx, error)\n }\n \n // Result is the result of a query execution.\n type Result interface {\n \t// LastInsertId returns the database's auto-generated ID\n \t// after, for example, an INSERT into a table with primary\n \t// key.\n-\tLastInsertId() (int64, os.Error)\n+\tLastInsertId() (int64, error)\n \n \t// RowsAffected returns the number of rows affected by the\n \t// query.\n-\tRowsAffected() (int64, os.Error)\n+\tRowsAffected() (int64, error)\n }\n \n // Stmt is a prepared statement. It is bound to a Conn and not\n // used by multiple goroutines concurrently.\n type Stmt interface {\n \t// Close closes the statement.\n-\tClose() os.Error\n+\tClose() error\n \n \t// NumInput returns the number of placeholder parameters.\n \tNumInput() int\n \n \t// Exec executes a query that doesn't return rows, such\n \t// as an INSERT or UPDATE.  The args are all of a subset\n \t// type as defined above.\n-\tExec(args []interface{}) (Result, os.Error)\n+\tExec(args []interface{}) (Result, error)\n \n \t// Exec executes a query that may return rows, such as a\n \t// SELECT.  The args of all of a subset type as defined above.\n-\tQuery(args []interface{}) (Rows, os.Error)\n+\tQuery(args []interface{}) (Rows, error)\n }\n \n // ColumnConverter may be optionally implemented by Stmt if the\n@@ -120,7 +118,7 @@ type Rows interface {\n \tColumns() []string\n \n \t// Close closes the rows iterator.\n-\tClose() os.Error\n+\tClose() error\n \n \t// Next is called to populate the next row of data into\n \t// the provided slice. The provided slice will be the same\n@@ -129,13 +127,13 @@ type Rows interface {\n \t// The dest slice may be populated with only with values\n \t// of subset types defined above, but excluding string.\n \t// All string values must be converted to []byte.\n-\tNext(dest []interface{}) os.Error\n+\tNext(dest []interface{}) error\n }\n \n // Tx is a transaction.\n type Tx interface {\n-\tCommit() os.Error\n-\tRollback() os.Error\n+\tCommit() error\n+\tRollback() error\n }\n \n // RowsAffected implements Result for an INSERT or UPDATE operation\n@@ -144,11 +142,11 @@ type RowsAffected int64\n \n var _ Result = RowsAffected(0)\n \n-func (RowsAffected) LastInsertId() (int64, os.Error) {\n-\treturn 0, os.NewError(\"no LastInsertId available\")\n+func (RowsAffected) LastInsertId() (int64, error) {\n+\treturn 0, errors.New(\"no LastInsertId available\")\n }\n \n-func (v RowsAffected) RowsAffected() (int64, os.Error) {\n+func (v RowsAffected) RowsAffected() (int64, error) {\n \treturn int64(v), nil\n }\n \n@@ -160,10 +158,10 @@ type ddlSuccess struct{}\n \n var _ Result = ddlSuccess{}\n \n-func (ddlSuccess) LastInsertId() (int64, os.Error) {\n-\treturn 0, os.NewError(\"no LastInsertId available after DDL statement\")\n+func (ddlSuccess) LastInsertId() (int64, error) {\n+\treturn 0, errors.New(\"no LastInsertId available after DDL statement\")\n }\n \n-func (ddlSuccess) RowsAffected() (int64, os.Error) {\n-\treturn 0, os.NewError(\"no RowsAffected available after DDL statement\")\n+func (ddlSuccess) RowsAffected() (int64, error) {\n+\treturn 0, errors.New(\"no RowsAffected available after DDL statement\")\n }"}, {"sha": "9faf32f671ab60dc02c8403b9099abd8d4bc4131", "filename": "libgo/go/exp/sql/driver/types.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,15 +6,14 @@ package driver\n \n import (\n \t\"fmt\"\n-\t\"os\"\n \t\"reflect\"\n \t\"strconv\"\n )\n \n // ValueConverter is the interface providing the ConvertValue method.\n type ValueConverter interface {\n \t// ConvertValue converts a value to a restricted subset type.\n-\tConvertValue(v interface{}) (interface{}, os.Error)\n+\tConvertValue(v interface{}) (interface{}, error)\n }\n \n // Bool is a ValueConverter that converts input values to bools.\n@@ -27,7 +26,7 @@ type boolType struct{}\n \n var _ ValueConverter = boolType{}\n \n-func (boolType) ConvertValue(v interface{}) (interface{}, os.Error) {\n+func (boolType) ConvertValue(v interface{}) (interface{}, error) {\n \treturn nil, fmt.Errorf(\"TODO(bradfitz): bool conversions\")\n }\n \n@@ -39,7 +38,7 @@ type int32Type struct{}\n \n var _ ValueConverter = int32Type{}\n \n-func (int32Type) ConvertValue(v interface{}) (interface{}, os.Error) {\n+func (int32Type) ConvertValue(v interface{}) (interface{}, error) {\n \trv := reflect.ValueOf(v)\n \tswitch rv.Kind() {\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n@@ -72,7 +71,7 @@ var String stringType\n \n type stringType struct{}\n \n-func (stringType) ConvertValue(v interface{}) (interface{}, os.Error) {\n+func (stringType) ConvertValue(v interface{}) (interface{}, error) {\n \tswitch v.(type) {\n \tcase string, []byte:\n \t\treturn v, nil\n@@ -137,7 +136,7 @@ type defaultConverter struct{}\n \n var _ ValueConverter = defaultConverter{}\n \n-func (defaultConverter) ConvertValue(v interface{}) (interface{}, os.Error) {\n+func (defaultConverter) ConvertValue(v interface{}) (interface{}, error) {\n \tif IsParameterSubsetType(v) {\n \t\treturn v, nil\n \t}"}, {"sha": "289294bee265a6806f6940a0a7d08cb15dcd7b0f", "filename": "libgo/go/exp/sql/fakedb_test.go", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,9 +5,10 @@\n package sql\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n+\t\"io\"\n \t\"log\"\n-\t\"os\"\n \t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n@@ -108,7 +109,7 @@ func init() {\n // Supports dsn forms:\n //    <dbname>\n //    <dbname>;wipe\n-func (d *fakeDriver) Open(dsn string) (driver.Conn, os.Error) {\n+func (d *fakeDriver) Open(dsn string) (driver.Conn, error) {\n \td.mu.Lock()\n \tdefer d.mu.Unlock()\n \td.openCount++\n@@ -117,7 +118,7 @@ func (d *fakeDriver) Open(dsn string) (driver.Conn, os.Error) {\n \t}\n \tparts := strings.Split(dsn, \";\")\n \tif len(parts) < 1 {\n-\t\treturn nil, os.NewError(\"fakedb: no database name\")\n+\t\treturn nil, errors.New(\"fakedb: no database name\")\n \t}\n \tname := parts[0]\n \tdb, ok := d.dbs[name]\n@@ -134,7 +135,7 @@ func (db *fakeDB) wipe() {\n \tdb.tables = nil\n }\n \n-func (db *fakeDB) createTable(name string, columnNames, columnTypes []string) os.Error {\n+func (db *fakeDB) createTable(name string, columnNames, columnTypes []string) error {\n \tdb.mu.Lock()\n \tdefer db.mu.Unlock()\n \tif db.tables == nil {\n@@ -175,33 +176,33 @@ func (db *fakeDB) columnType(table, column string) (typ string, ok bool) {\n \treturn \"\", false\n }\n \n-func (c *fakeConn) Begin() (driver.Tx, os.Error) {\n+func (c *fakeConn) Begin() (driver.Tx, error) {\n \tif c.currTx != nil {\n-\t\treturn nil, os.NewError(\"already in a transaction\")\n+\t\treturn nil, errors.New(\"already in a transaction\")\n \t}\n \tc.currTx = &fakeTx{c: c}\n \treturn c.currTx, nil\n }\n \n-func (c *fakeConn) Close() os.Error {\n+func (c *fakeConn) Close() error {\n \tif c.currTx != nil {\n-\t\treturn os.NewError(\"can't close; in a Transaction\")\n+\t\treturn errors.New(\"can't close; in a Transaction\")\n \t}\n \tif c.db == nil {\n-\t\treturn os.NewError(\"can't close; already closed\")\n+\t\treturn errors.New(\"can't close; already closed\")\n \t}\n \tc.db = nil\n \treturn nil\n }\n \n-func errf(msg string, args ...interface{}) os.Error {\n-\treturn os.NewError(\"fakedb: \" + fmt.Sprintf(msg, args...))\n+func errf(msg string, args ...interface{}) error {\n+\treturn errors.New(\"fakedb: \" + fmt.Sprintf(msg, args...))\n }\n \n // parts are table|selectCol1,selectCol2|whereCol=?,whereCol2=?\n // (note that where where columns must always contain ? marks,\n //  just a limitation for fakedb)\n-func (c *fakeConn) prepareSelect(stmt *fakeStmt, parts []string) (driver.Stmt, os.Error) {\n+func (c *fakeConn) prepareSelect(stmt *fakeStmt, parts []string) (driver.Stmt, error) {\n \tif len(parts) != 3 {\n \t\treturn nil, errf(\"invalid SELECT syntax with %d parts; want 3\", len(parts))\n \t}\n@@ -228,7 +229,7 @@ func (c *fakeConn) prepareSelect(stmt *fakeStmt, parts []string) (driver.Stmt, o\n }\n \n // parts are table|col=type,col2=type2\n-func (c *fakeConn) prepareCreate(stmt *fakeStmt, parts []string) (driver.Stmt, os.Error) {\n+func (c *fakeConn) prepareCreate(stmt *fakeStmt, parts []string) (driver.Stmt, error) {\n \tif len(parts) != 2 {\n \t\treturn nil, errf(\"invalid CREATE syntax with %d parts; want 2\", len(parts))\n \t}\n@@ -245,7 +246,7 @@ func (c *fakeConn) prepareCreate(stmt *fakeStmt, parts []string) (driver.Stmt, o\n }\n \n // parts are table|col=?,col2=val\n-func (c *fakeConn) prepareInsert(stmt *fakeStmt, parts []string) (driver.Stmt, os.Error) {\n+func (c *fakeConn) prepareInsert(stmt *fakeStmt, parts []string) (driver.Stmt, error) {\n \tif len(parts) != 2 {\n \t\treturn nil, errf(\"invalid INSERT syntax with %d parts; want 2\", len(parts))\n \t}\n@@ -287,7 +288,7 @@ func (c *fakeConn) prepareInsert(stmt *fakeStmt, parts []string) (driver.Stmt, o\n \treturn stmt, nil\n }\n \n-func (c *fakeConn) Prepare(query string) (driver.Stmt, os.Error) {\n+func (c *fakeConn) Prepare(query string) (driver.Stmt, error) {\n \tif c.db == nil {\n \t\tpanic(\"nil c.db; conn = \" + fmt.Sprintf(\"%#v\", c))\n \t}\n@@ -317,11 +318,11 @@ func (s *fakeStmt) ColumnConverter(idx int) driver.ValueConverter {\n \treturn s.placeholderConverter[idx]\n }\n \n-func (s *fakeStmt) Close() os.Error {\n+func (s *fakeStmt) Close() error {\n \treturn nil\n }\n \n-func (s *fakeStmt) Exec(args []interface{}) (driver.Result, os.Error) {\n+func (s *fakeStmt) Exec(args []interface{}) (driver.Result, error) {\n \tdb := s.c.db\n \tswitch s.cmd {\n \tcase \"WIPE\":\n@@ -339,7 +340,7 @@ func (s *fakeStmt) Exec(args []interface{}) (driver.Result, os.Error) {\n \treturn nil, fmt.Errorf(\"unimplemented statement Exec command type of %q\", s.cmd)\n }\n \n-func (s *fakeStmt) execInsert(args []interface{}) (driver.Result, os.Error) {\n+func (s *fakeStmt) execInsert(args []interface{}) (driver.Result, error) {\n \tdb := s.c.db\n \tif len(args) != s.placeholders {\n \t\tpanic(\"error in pkg db; should only get here if size is correct\")\n@@ -375,7 +376,7 @@ func (s *fakeStmt) execInsert(args []interface{}) (driver.Result, os.Error) {\n \treturn driver.RowsAffected(1), nil\n }\n \n-func (s *fakeStmt) Query(args []interface{}) (driver.Rows, os.Error) {\n+func (s *fakeStmt) Query(args []interface{}) (driver.Rows, error) {\n \tdb := s.c.db\n \tif len(args) != s.placeholders {\n \t\tpanic(\"error in pkg db; should only get here if size is correct\")\n@@ -438,12 +439,12 @@ func (s *fakeStmt) NumInput() int {\n \treturn s.placeholders\n }\n \n-func (tx *fakeTx) Commit() os.Error {\n+func (tx *fakeTx) Commit() error {\n \ttx.c.currTx = nil\n \treturn nil\n }\n \n-func (tx *fakeTx) Rollback() os.Error {\n+func (tx *fakeTx) Rollback() error {\n \ttx.c.currTx = nil\n \treturn nil\n }\n@@ -455,7 +456,7 @@ type rowsCursor struct {\n \tclosed bool\n }\n \n-func (rc *rowsCursor) Close() os.Error {\n+func (rc *rowsCursor) Close() error {\n \trc.closed = true\n \treturn nil\n }\n@@ -464,13 +465,13 @@ func (rc *rowsCursor) Columns() []string {\n \treturn rc.cols\n }\n \n-func (rc *rowsCursor) Next(dest []interface{}) os.Error {\n+func (rc *rowsCursor) Next(dest []interface{}) error {\n \tif rc.closed {\n-\t\treturn os.NewError(\"fakedb: cursor is closed\")\n+\t\treturn errors.New(\"fakedb: cursor is closed\")\n \t}\n \trc.pos++\n \tif rc.pos >= len(rc.rows) {\n-\t\treturn os.EOF // per interface spec\n+\t\treturn io.EOF // per interface spec\n \t}\n \tfor i, v := range rc.rows[rc.pos].cols {\n \t\t// TODO(bradfitz): convert to subset types? naah, I"}, {"sha": "4f1c539127cf51d23ebe50895315d8582431938a", "filename": "libgo/go/exp/sql/sql.go", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,8 +7,9 @@\n package sql\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n-\t\"os\"\n+\t\"io\"\n \t\"runtime\"\n \t\"sync\"\n \n@@ -50,7 +51,7 @@ type NullableString struct {\n }\n \n // ScanInto implements the ScannerInto interface.\n-func (ms *NullableString) ScanInto(value interface{}) os.Error {\n+func (ms *NullableString) ScanInto(value interface{}) error {\n \tif value == nil {\n \t\tms.String, ms.Valid = \"\", false\n \t\treturn nil\n@@ -74,13 +75,13 @@ type ScannerInto interface {\n \t//\n \t// An error should be returned if the value can not be stored\n \t// without loss of information.\n-\tScanInto(value interface{}) os.Error\n+\tScanInto(value interface{}) error\n }\n \n // ErrNoRows is returned by Scan when QueryRow doesn't return a\n // row. In such a case, QueryRow returns a placeholder *Row value that\n // defers this error until a Scan.\n-var ErrNoRows = os.NewError(\"db: no rows in result set\")\n+var ErrNoRows = errors.New(\"db: no rows in result set\")\n \n // DB is a database handle. It's safe for concurrent use by multiple\n // goroutines.\n@@ -98,7 +99,7 @@ type DB struct {\n //\n // Most users will open a database via a driver-specific connection\n // helper function that returns a *DB.\n-func Open(driverName, dataSourceName string) (*DB, os.Error) {\n+func Open(driverName, dataSourceName string) (*DB, error) {\n \tdriver, ok := drivers[driverName]\n \tif !ok {\n \t\treturn nil, fmt.Errorf(\"db: unknown driver %q (forgotten import?)\", driverName)\n@@ -114,7 +115,7 @@ func (db *DB) maxIdleConns() int {\n }\n \n // conn returns a newly-opened or cached driver.Conn\n-func (db *DB) conn() (driver.Conn, os.Error) {\n+func (db *DB) conn() (driver.Conn, error) {\n \tdb.mu.Lock()\n \tif n := len(db.freeConn); n > 0 {\n \t\tconn := db.freeConn[n-1]\n@@ -154,7 +155,7 @@ func (db *DB) closeConn(c driver.Conn) {\n }\n \n // Prepare creates a prepared statement for later execution.\n-func (db *DB) Prepare(query string) (*Stmt, os.Error) {\n+func (db *DB) Prepare(query string) (*Stmt, error) {\n \t// TODO: check if db.driver supports an optional\n \t// driver.Preparer interface and call that instead, if so,\n \t// otherwise we make a prepared statement that's bound\n@@ -179,7 +180,7 @@ func (db *DB) Prepare(query string) (*Stmt, os.Error) {\n }\n \n // Exec executes a query without returning any rows.\n-func (db *DB) Exec(query string, args ...interface{}) (Result, os.Error) {\n+func (db *DB) Exec(query string, args ...interface{}) (Result, error) {\n \t// Optional fast path, if the driver implements driver.Execer.\n \tif execer, ok := db.driver.(driver.Execer); ok {\n \t\tresi, err := execer.Exec(query, args)\n@@ -218,7 +219,7 @@ func (db *DB) Exec(query string, args ...interface{}) (Result, os.Error) {\n }\n \n // Query executes a query that returns rows, typically a SELECT.\n-func (db *DB) Query(query string, args ...interface{}) (*Rows, os.Error) {\n+func (db *DB) Query(query string, args ...interface{}) (*Rows, error) {\n \tstmt, err := db.Prepare(query)\n \tif err != nil {\n \t\treturn nil, err\n@@ -240,7 +241,7 @@ func (db *DB) QueryRow(query string, args ...interface{}) *Row {\n \n // Begin starts a transaction.  The isolation level is dependent on\n // the driver.\n-func (db *DB) Begin() (*Tx, os.Error) {\n+func (db *DB) Begin() (*Tx, error) {\n \t// TODO(bradfitz): add another method for beginning a transaction\n \t// at a specific isolation level.\n \tpanic(todo())\n@@ -257,17 +258,17 @@ type Tx struct {\n }\n \n // Commit commits the transaction.\n-func (tx *Tx) Commit() os.Error {\n+func (tx *Tx) Commit() error {\n \tpanic(todo())\n }\n \n // Rollback aborts the transaction.\n-func (tx *Tx) Rollback() os.Error {\n+func (tx *Tx) Rollback() error {\n \tpanic(todo())\n }\n \n // Prepare creates a prepared statement.\n-func (tx *Tx) Prepare(query string) (*Stmt, os.Error) {\n+func (tx *Tx) Prepare(query string) (*Stmt, error) {\n \tpanic(todo())\n }\n \n@@ -278,7 +279,7 @@ func (tx *Tx) Exec(query string, args ...interface{}) {\n }\n \n // Query executes a query that returns rows, typically a SELECT.\n-func (tx *Tx) Query(query string, args ...interface{}) (*Rows, os.Error) {\n+func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error) {\n \tpanic(todo())\n }\n \n@@ -313,7 +314,7 @@ func todo() string {\n \n // Exec executes a prepared statement with the given arguments and\n // returns a Result summarizing the effect of the statement.\n-func (s *Stmt) Exec(args ...interface{}) (Result, os.Error) {\n+func (s *Stmt) Exec(args ...interface{}) (Result, error) {\n \tci, si, err := s.connStmt()\n \tif err != nil {\n \t\treturn nil, err\n@@ -352,10 +353,10 @@ func (s *Stmt) Exec(args ...interface{}) (Result, os.Error) {\n \treturn result{resi}, nil\n }\n \n-func (s *Stmt) connStmt(args ...interface{}) (driver.Conn, driver.Stmt, os.Error) {\n+func (s *Stmt) connStmt(args ...interface{}) (driver.Conn, driver.Stmt, error) {\n \ts.mu.Lock()\n \tif s.closed {\n-\t\treturn nil, nil, os.NewError(\"db: statement is closed\")\n+\t\treturn nil, nil, errors.New(\"db: statement is closed\")\n \t}\n \tvar cs connStmt\n \tmatch := false\n@@ -391,7 +392,7 @@ func (s *Stmt) connStmt(args ...interface{}) (driver.Conn, driver.Stmt, os.Error\n \n // Query executes a prepared query statement with the given arguments\n // and returns the query results as a *Rows.\n-func (s *Stmt) Query(args ...interface{}) (*Rows, os.Error) {\n+func (s *Stmt) Query(args ...interface{}) (*Rows, error) {\n \tci, si, err := s.connStmt(args...)\n \tif err != nil {\n \t\treturn nil, err\n@@ -433,7 +434,7 @@ func (s *Stmt) QueryRow(args ...interface{}) *Row {\n }\n \n // Close closes the statement.\n-func (s *Stmt) Close() os.Error {\n+func (s *Stmt) Close() error {\n \ts.mu.Lock()\n \tdefer s.mu.Unlock() // TODO(bradfitz): move this unlock after 'closed = true'?\n \tif s.closed {\n@@ -473,7 +474,7 @@ type Rows struct {\n \n \tclosed   bool\n \tlastcols []interface{}\n-\tlasterr  os.Error\n+\tlasterr  error\n }\n \n // Next prepares the next result row for reading with the Scan method.\n@@ -495,8 +496,8 @@ func (rs *Rows) Next() bool {\n }\n \n // Error returns the error, if any, that was encountered during iteration.\n-func (rs *Rows) Error() os.Error {\n-\tif rs.lasterr == os.EOF {\n+func (rs *Rows) Error() error {\n+\tif rs.lasterr == io.EOF {\n \t\treturn nil\n \t}\n \treturn rs.lasterr\n@@ -506,15 +507,15 @@ func (rs *Rows) Error() os.Error {\n // at by dest. If dest contains pointers to []byte, the slices should\n // not be modified and should only be considered valid until the next\n // call to Next or Scan.\n-func (rs *Rows) Scan(dest ...interface{}) os.Error {\n+func (rs *Rows) Scan(dest ...interface{}) error {\n \tif rs.closed {\n-\t\treturn os.NewError(\"db: Rows closed\")\n+\t\treturn errors.New(\"db: Rows closed\")\n \t}\n \tif rs.lasterr != nil {\n \t\treturn rs.lasterr\n \t}\n \tif rs.lastcols == nil {\n-\t\treturn os.NewError(\"db: Scan called without calling Next\")\n+\t\treturn errors.New(\"db: Scan called without calling Next\")\n \t}\n \tif len(dest) != len(rs.lastcols) {\n \t\treturn fmt.Errorf(\"db: expected %d destination arguments in Scan, not %d\", len(rs.lastcols), len(dest))\n@@ -531,7 +532,7 @@ func (rs *Rows) Scan(dest ...interface{}) os.Error {\n // Close closes the Rows, preventing further enumeration. If the\n // end is encountered, the Rows are closed automatically. Close\n // is idempotent.\n-func (rs *Rows) Close() os.Error {\n+func (rs *Rows) Close() error {\n \tif rs.closed {\n \t\treturn nil\n \t}\n@@ -544,7 +545,7 @@ func (rs *Rows) Close() os.Error {\n // Row is the result of calling QueryRow to select a single row.\n type Row struct {\n \t// One of these two will be non-nil:\n-\terr  os.Error // deferred error for easy chaining\n+\terr  error // deferred error for easy chaining\n \trows *Rows\n }\n \n@@ -556,7 +557,7 @@ type Row struct {\n // If dest contains pointers to []byte, the slices should not be\n // modified and should only be considered valid until the next call to\n // Next or Scan.\n-func (r *Row) Scan(dest ...interface{}) os.Error {\n+func (r *Row) Scan(dest ...interface{}) error {\n \tif r.err != nil {\n \t\treturn r.err\n \t}\n@@ -569,8 +570,8 @@ func (r *Row) Scan(dest ...interface{}) os.Error {\n \n // A Result summarizes an executed SQL command.\n type Result interface {\n-\tLastInsertId() (int64, os.Error)\n-\tRowsAffected() (int64, os.Error)\n+\tLastInsertId() (int64, error)\n+\tRowsAffected() (int64, error)\n }\n \n type result struct {"}, {"sha": "eb1bb58966eae95ee8f8011dcf1d4669433f5681", "filename": "libgo/go/exp/sql/sql_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -40,7 +40,7 @@ func TestQuery(t *testing.T) {\n \tvar age int\n \n \terr := db.QueryRow(\"SELECT|people|age,name|age=?\", 3).Scan(&age)\n-\tif err == nil || !strings.Contains(err.String(), \"expected 2 destination arguments\") {\n+\tif err == nil || !strings.Contains(err.Error(), \"expected 2 destination arguments\") {\n \t\tt.Errorf(\"expected error from wrong number of arguments; actually got: %v\", err)\n \t}\n \n@@ -99,7 +99,7 @@ func TestBogusPreboundParameters(t *testing.T) {\n \tif err == nil {\n \t\tt.Fatalf(\"expected error\")\n \t}\n-\tif err.String() != `fakedb: invalid conversion to int32 from \"bogusconversion\"` {\n+\tif err.Error() != `fakedb: invalid conversion to int32 from \"bogusconversion\"` {\n \t\tt.Errorf(\"unexpected error: %v\", err)\n \t}\n }\n@@ -135,7 +135,7 @@ func TestDb(t *testing.T) {\n \t\t_, err := stmt.Exec(et.args...)\n \t\terrStr := \"\"\n \t\tif err != nil {\n-\t\t\terrStr = err.String()\n+\t\t\terrStr = err.Error()\n \t\t}\n \t\tif errStr != et.wantErr {\n \t\t\tt.Errorf(\"stmt.Execute #%d: for %v, got error %q, want error %q\","}, {"sha": "6ff8203ce27d6cb29f37c9317f60cd111407ca19", "filename": "libgo/go/exp/ssh/channel.go", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,27 +5,28 @@\n package ssh\n \n import (\n-\t\"os\"\n+\t\"errors\"\n+\t\"io\"\n \t\"sync\"\n )\n \n // A Channel is an ordered, reliable, duplex stream that is multiplexed over an\n // SSH connection.\n type Channel interface {\n \t// Accept accepts the channel creation request.\n-\tAccept() os.Error\n+\tAccept() error\n \t// Reject rejects the channel creation request. After calling this, no\n \t// other methods on the Channel may be called. If they are then the\n \t// peer is likely to signal a protocol error and drop the connection.\n-\tReject(reason RejectionReason, message string) os.Error\n+\tReject(reason RejectionReason, message string) error\n \n-\t// Read may return a ChannelRequest as an os.Error.\n-\tRead(data []byte) (int, os.Error)\n-\tWrite(data []byte) (int, os.Error)\n-\tClose() os.Error\n+\t// Read may return a ChannelRequest as an error.\n+\tRead(data []byte) (int, error)\n+\tWrite(data []byte) (int, error)\n+\tClose() error\n \n \t// AckRequest either sends an ack or nack to the channel request.\n-\tAckRequest(ok bool) os.Error\n+\tAckRequest(ok bool) error\n \n \t// ChannelType returns the type of the channel, as supplied by the\n \t// client.\n@@ -43,7 +44,7 @@ type ChannelRequest struct {\n \tPayload   []byte\n }\n \n-func (c ChannelRequest) String() string {\n+func (c ChannelRequest) Error() string {\n \treturn \"channel request received\"\n }\n \n@@ -72,7 +73,7 @@ type channel struct {\n \tmyId, theirId         uint32\n \tmyWindow, theirWindow uint32\n \tmaxPacketSize         uint32\n-\terr                   os.Error\n+\terr                   error\n \n \tpendingRequests []ChannelRequest\n \tpendingData     []byte\n@@ -83,7 +84,7 @@ type channel struct {\n \tcond *sync.Cond\n }\n \n-func (c *channel) Accept() os.Error {\n+func (c *channel) Accept() error {\n \tc.serverConn.lock.Lock()\n \tdefer c.serverConn.lock.Unlock()\n \n@@ -100,7 +101,7 @@ func (c *channel) Accept() os.Error {\n \treturn c.serverConn.writePacket(marshal(msgChannelOpenConfirm, confirm))\n }\n \n-func (c *channel) Reject(reason RejectionReason, message string) os.Error {\n+func (c *channel) Reject(reason RejectionReason, message string) error {\n \tc.serverConn.lock.Lock()\n \tdefer c.serverConn.lock.Unlock()\n \n@@ -167,7 +168,7 @@ func (c *channel) handleData(data []byte) {\n \tc.cond.Signal()\n }\n \n-func (c *channel) Read(data []byte) (n int, err os.Error) {\n+func (c *channel) Read(data []byte) (n int, err error) {\n \tc.lock.Lock()\n \tdefer c.lock.Unlock()\n \n@@ -187,7 +188,7 @@ func (c *channel) Read(data []byte) (n int, err os.Error) {\n \n \tfor {\n \t\tif c.theySentEOF || c.theyClosed || c.dead {\n-\t\t\treturn 0, os.EOF\n+\t\t\treturn 0, io.EOF\n \t\t}\n \n \t\tif len(c.pendingRequests) > 0 {\n@@ -223,11 +224,11 @@ func (c *channel) Read(data []byte) (n int, err os.Error) {\n \tpanic(\"unreachable\")\n }\n \n-func (c *channel) Write(data []byte) (n int, err os.Error) {\n+func (c *channel) Write(data []byte) (n int, err error) {\n \tfor len(data) > 0 {\n \t\tc.lock.Lock()\n \t\tif c.dead || c.weClosed {\n-\t\t\treturn 0, os.EOF\n+\t\t\treturn 0, io.EOF\n \t\t}\n \n \t\tif c.theirWindow == 0 {\n@@ -267,7 +268,7 @@ func (c *channel) Write(data []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (c *channel) Close() os.Error {\n+func (c *channel) Close() error {\n \tc.serverConn.lock.Lock()\n \tdefer c.serverConn.lock.Unlock()\n \n@@ -276,7 +277,7 @@ func (c *channel) Close() os.Error {\n \t}\n \n \tif c.weClosed {\n-\t\treturn os.NewError(\"ssh: channel already closed\")\n+\t\treturn errors.New(\"ssh: channel already closed\")\n \t}\n \tc.weClosed = true\n \n@@ -286,7 +287,7 @@ func (c *channel) Close() os.Error {\n \treturn c.serverConn.writePacket(marshal(msgChannelClose, closeMsg))\n }\n \n-func (c *channel) AckRequest(ok bool) os.Error {\n+func (c *channel) AckRequest(ok bool) error {\n \tc.serverConn.lock.Lock()\n \tdefer c.serverConn.lock.Unlock()\n "}, {"sha": "345e707b336a1475a83d65bde601d41c5c01b662", "filename": "libgo/go/exp/ssh/client.go", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,10 +8,10 @@ import (\n \t\"big\"\n \t\"crypto\"\n \t\"crypto/rand\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"net\"\n-\t\"os\"\n \t\"sync\"\n )\n \n@@ -26,7 +26,7 @@ type ClientConn struct {\n }\n \n // Client returns a new SSH client connection using c as the underlying transport.\n-func Client(c net.Conn, config *ClientConfig) (*ClientConn, os.Error) {\n+func Client(c net.Conn, config *ClientConfig) (*ClientConn, error) {\n \tconn := &ClientConn{\n \t\ttransport: newTransport(c, config.rand()),\n \t\tconfig:    config,\n@@ -44,7 +44,7 @@ func Client(c net.Conn, config *ClientConfig) (*ClientConn, os.Error) {\n }\n \n // handshake performs the client side key exchange. See RFC 4253 Section 7.\n-func (c *ClientConn) handshake() os.Error {\n+func (c *ClientConn) handshake() error {\n \tvar magics handshakeMagics\n \n \tif _, err := c.Write(clientVersion); err != nil {\n@@ -91,7 +91,7 @@ func (c *ClientConn) handshake() os.Error {\n \n \tkexAlgo, hostKeyAlgo, ok := findAgreedAlgorithms(c.transport, &clientKexInit, &serverKexInit)\n \tif !ok {\n-\t\treturn os.NewError(\"ssh: no common algorithms\")\n+\t\treturn errors.New(\"ssh: no common algorithms\")\n \t}\n \n \tif serverKexInit.FirstKexFollows && kexAlgo != serverKexInit.KexAlgos[0] {\n@@ -133,7 +133,7 @@ func (c *ClientConn) handshake() os.Error {\n \n // authenticate authenticates with the remote server. See RFC 4252. \n // Only \"password\" authentication is supported.\n-func (c *ClientConn) authenticate() os.Error {\n+func (c *ClientConn) authenticate() error {\n \tif err := c.writePacket(marshal(msgServiceRequest, serviceRequestMsg{serviceUserAuth})); err != nil {\n \t\treturn err\n \t}\n@@ -166,7 +166,7 @@ func (c *ClientConn) authenticate() os.Error {\n \treturn nil\n }\n \n-func (c *ClientConn) sendUserAuthReq(method string) os.Error {\n+func (c *ClientConn) sendUserAuthReq(method string) error {\n \tlength := stringLength([]byte(c.config.Password)) + 1\n \tpayload := make([]byte, length)\n \t// always false for password auth, see RFC 4252 Section 8.\n@@ -183,7 +183,7 @@ func (c *ClientConn) sendUserAuthReq(method string) os.Error {\n \n // kexDH performs Diffie-Hellman key agreement on a ClientConn. The\n // returned values are given the same names as in RFC 4253, section 8.\n-func (c *ClientConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handshakeMagics, hostKeyAlgo string) ([]byte, []byte, os.Error) {\n+func (c *ClientConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handshakeMagics, hostKeyAlgo string) ([]byte, []byte, error) {\n \tx, err := rand.Int(c.config.rand(), group.p)\n \tif err != nil {\n \t\treturn nil, nil, err\n@@ -207,7 +207,7 @@ func (c *ClientConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handsha\n \t}\n \n \tif kexDHReply.Y.Sign() == 0 || kexDHReply.Y.Cmp(group.p) >= 0 {\n-\t\treturn nil, nil, os.NewError(\"server DH parameter out of bounds\")\n+\t\treturn nil, nil, errors.New(\"server DH parameter out of bounds\")\n \t}\n \n \tkInt := new(big.Int).Exp(kexDHReply.Y, x, group.p)\n@@ -230,7 +230,7 @@ func (c *ClientConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handsha\n \n // openChan opens a new client channel. The most common session type is \"session\". \n // The full set of valid session types are listed in RFC 4250 4.9.1.\n-func (c *ClientConn) openChan(typ string) (*clientChan, os.Error) {\n+func (c *ClientConn) openChan(typ string) (*clientChan, error) {\n \tch := c.newChan(c.transport)\n \tif err := c.writePacket(marshal(msgChannelOpen, channelOpenMsg{\n \t\tChanType:      typ,\n@@ -247,10 +247,10 @@ func (c *ClientConn) openChan(typ string) (*clientChan, os.Error) {\n \t\tch.peersId = msg.MyId\n \tcase *channelOpenFailureMsg:\n \t\tc.chanlist.remove(ch.id)\n-\t\treturn nil, os.NewError(msg.Message)\n+\t\treturn nil, errors.New(msg.Message)\n \tdefault:\n \t\tc.chanlist.remove(ch.id)\n-\t\treturn nil, os.NewError(\"Unexpected packet\")\n+\t\treturn nil, errors.New(\"Unexpected packet\")\n \t}\n \treturn ch, nil\n }\n@@ -329,7 +329,7 @@ func (c *ClientConn) mainLoop() {\n \n // Dial connects to the given network address using net.Dial and \n // then initiates a SSH handshake, returning the resulting client connection.\n-func Dial(network, addr string, config *ClientConfig) (*ClientConn, os.Error) {\n+func Dial(network, addr string, config *ClientConfig) (*ClientConn, error) {\n \tconn, err := net.Dial(network, addr)\n \tif err != nil {\n \t\treturn nil, err\n@@ -382,13 +382,13 @@ func newClientChan(t *transport, id uint32) *clientChan {\n }\n \n // Close closes the channel. This does not close the underlying connection.\n-func (c *clientChan) Close() os.Error {\n+func (c *clientChan) Close() error {\n \treturn c.writePacket(marshal(msgChannelClose, channelCloseMsg{\n \t\tPeersId: c.id,\n \t}))\n }\n \n-func (c *clientChan) sendChanReq(req channelRequestMsg) os.Error {\n+func (c *clientChan) sendChanReq(req channelRequestMsg) error {\n \tif err := c.writePacket(marshal(msgChannelRequest, req)); err != nil {\n \t\treturn err\n \t}\n@@ -447,12 +447,12 @@ type chanWriter struct {\n }\n \n // Write writes data to the remote process's standard input.\n-func (w *chanWriter) Write(data []byte) (n int, err os.Error) {\n+func (w *chanWriter) Write(data []byte) (n int, err error) {\n \tfor {\n \t\tif w.rwin == 0 {\n \t\t\twin, ok := <-w.win\n \t\t\tif !ok {\n-\t\t\t\treturn 0, os.EOF\n+\t\t\t\treturn 0, io.EOF\n \t\t\t}\n \t\t\tw.rwin += win\n \t\t\tcontinue\n@@ -469,7 +469,7 @@ func (w *chanWriter) Write(data []byte) (n int, err os.Error) {\n \tpanic(\"unreachable\")\n }\n \n-func (w *chanWriter) Close() os.Error {\n+func (w *chanWriter) Close() error {\n \treturn w.writePacket(marshal(msgChannelEOF, channelEOFMsg{w.id}))\n }\n \n@@ -485,7 +485,7 @@ type chanReader struct {\n }\n \n // Read reads data from the remote process's stdout or stderr.\n-func (r *chanReader) Read(data []byte) (int, os.Error) {\n+func (r *chanReader) Read(data []byte) (int, error) {\n \tvar ok bool\n \tfor {\n \t\tif len(r.buf) > 0 {\n@@ -499,12 +499,12 @@ func (r *chanReader) Read(data []byte) (int, os.Error) {\n \t\t}\n \t\tr.buf, ok = <-r.data\n \t\tif !ok {\n-\t\t\treturn 0, os.EOF\n+\t\t\treturn 0, io.EOF\n \t\t}\n \t}\n \tpanic(\"unreachable\")\n }\n \n-func (r *chanReader) Close() os.Error {\n+func (r *chanReader) Close() error {\n \treturn r.writePacket(marshal(msgChannelEOF, channelEOFMsg{r.id}))\n }"}, {"sha": "f68c353a397b0dcd5d484e0ed23abf9e19939efe", "filename": "libgo/go/exp/ssh/common.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -53,7 +53,7 @@ type UnexpectedMessageError struct {\n \texpected, got uint8\n }\n \n-func (u UnexpectedMessageError) String() string {\n+func (u UnexpectedMessageError) Error() string {\n \treturn \"ssh: unexpected message type \" + strconv.Itoa(int(u.got)) + \" (expected \" + strconv.Itoa(int(u.expected)) + \")\"\n }\n \n@@ -62,7 +62,7 @@ type ParseError struct {\n \tmsgType uint8\n }\n \n-func (p ParseError) String() string {\n+func (p ParseError) Error() string {\n \treturn \"ssh: parse error in message type \" + strconv.Itoa(int(p.msgType))\n }\n "}, {"sha": "5eae181872a2d12a161a42f7784b52815a1b433b", "filename": "libgo/go/exp/ssh/messages.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"big\"\n \t\"bytes\"\n \t\"io\"\n-\t\"os\"\n \t\"reflect\"\n )\n \n@@ -192,7 +191,7 @@ type userAuthPubKeyOkMsg struct {\n // unmarshal parses the SSH wire data in packet into out using reflection.\n // expectedType is the expected SSH message type. It either returns nil on\n // success, or a ParseError or UnexpectedMessageError on error.\n-func unmarshal(out interface{}, packet []byte, expectedType uint8) os.Error {\n+func unmarshal(out interface{}, packet []byte, expectedType uint8) error {\n \tif len(packet) == 0 {\n \t\treturn ParseError{expectedType}\n \t}"}, {"sha": "2ae8079d2dba713fc253bf59475d453482e394b9", "filename": "libgo/go/exp/ssh/server.go", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -12,9 +12,9 @@ import (\n \t\"crypto/rsa\"\n \t\"crypto/x509\"\n \t\"encoding/pem\"\n+\t\"errors\"\n \t\"io\"\n \t\"net\"\n-\t\"os\"\n \t\"sync\"\n )\n \n@@ -53,12 +53,12 @@ func (c *ServerConfig) rand() io.Reader {\n // private key configured in order to accept connections. The private key must\n // be in the form of a PEM encoded, PKCS#1, RSA private key. The file \"id_rsa\"\n // typically contains such a key.\n-func (s *ServerConfig) SetRSAPrivateKey(pemBytes []byte) os.Error {\n+func (s *ServerConfig) SetRSAPrivateKey(pemBytes []byte) error {\n \tblock, _ := pem.Decode(pemBytes)\n \tif block == nil {\n-\t\treturn os.NewError(\"ssh: no key found\")\n+\t\treturn errors.New(\"ssh: no key found\")\n \t}\n-\tvar err os.Error\n+\tvar err error\n \ts.rsa, err = x509.ParsePKCS1PrivateKey(block.Bytes)\n \tif err != nil {\n \t\treturn err\n@@ -140,7 +140,7 @@ type ServerConn struct {\n \t// lock protects err and also allows Channels to serialise their writes\n \t// to out.\n \tlock sync.RWMutex\n-\terr  os.Error\n+\terr  error\n \n \t// cachedPubKeys contains the cache results of tests for public keys.\n \t// Since SSH clients will query whether a public key is acceptable\n@@ -162,7 +162,7 @@ func Server(c net.Conn, config *ServerConfig) *ServerConn {\n \n // kexDH performs Diffie-Hellman key agreement on a ServerConnection. The\n // returned values are given the same names as in RFC 4253, section 8.\n-func (s *ServerConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handshakeMagics, hostKeyAlgo string) (H, K []byte, err os.Error) {\n+func (s *ServerConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handshakeMagics, hostKeyAlgo string) (H, K []byte, err error) {\n \tpacket, err := s.readPacket()\n \tif err != nil {\n \t\treturn\n@@ -173,7 +173,7 @@ func (s *ServerConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handsha\n \t}\n \n \tif kexDHInit.X.Sign() == 0 || kexDHInit.X.Cmp(group.p) >= 0 {\n-\t\treturn nil, nil, os.NewError(\"client DH parameter out of bounds\")\n+\t\treturn nil, nil, errors.New(\"client DH parameter out of bounds\")\n \t}\n \n \ty, err := rand.Int(s.config.rand(), group.p)\n@@ -189,7 +189,7 @@ func (s *ServerConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handsha\n \tcase hostAlgoRSA:\n \t\tserializedHostKey = s.config.rsaSerialized\n \tdefault:\n-\t\treturn nil, nil, os.NewError(\"internal error\")\n+\t\treturn nil, nil, errors.New(\"internal error\")\n \t}\n \n \th := hashFunc.New()\n@@ -218,7 +218,7 @@ func (s *ServerConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handsha\n \t\t\treturn\n \t\t}\n \tdefault:\n-\t\treturn nil, nil, os.NewError(\"internal error\")\n+\t\treturn nil, nil, errors.New(\"internal error\")\n \t}\n \n \tserializedSig := serializeRSASignature(sig)\n@@ -279,7 +279,7 @@ func buildDataSignedForAuth(sessionId []byte, req userAuthRequestMsg, algo, pubK\n }\n \n // Handshake performs an SSH transport and client authentication on the given ServerConn.\n-func (s *ServerConn) Handshake() os.Error {\n+func (s *ServerConn) Handshake() error {\n \tvar magics handshakeMagics\n \tif _, err := s.Write(serverVersion); err != nil {\n \t\treturn err\n@@ -326,7 +326,7 @@ func (s *ServerConn) Handshake() os.Error {\n \n \tkexAlgo, hostKeyAlgo, ok := findAgreedAlgorithms(s.transport, &clientKexInit, &serverKexInit)\n \tif !ok {\n-\t\treturn os.NewError(\"ssh: no common algorithms\")\n+\t\treturn errors.New(\"ssh: no common algorithms\")\n \t}\n \n \tif clientKexInit.FirstKexFollows && kexAlgo != clientKexInit.KexAlgos[0] {\n@@ -345,7 +345,7 @@ func (s *ServerConn) Handshake() os.Error {\n \t\tdhGroup14Once.Do(initDHGroup14)\n \t\tH, K, err = s.kexDH(dhGroup14, hashFunc, &magics, hostKeyAlgo)\n \tdefault:\n-\t\terr = os.NewError(\"ssh: unexpected key exchange algorithm \" + kexAlgo)\n+\t\terr = errors.New(\"ssh: unexpected key exchange algorithm \" + kexAlgo)\n \t}\n \tif err != nil {\n \t\treturn err\n@@ -374,7 +374,7 @@ func (s *ServerConn) Handshake() os.Error {\n \t\treturn err\n \t}\n \tif serviceRequest.Service != serviceUserAuth {\n-\t\treturn os.NewError(\"ssh: requested service '\" + serviceRequest.Service + \"' before authenticating\")\n+\t\treturn errors.New(\"ssh: requested service '\" + serviceRequest.Service + \"' before authenticating\")\n \t}\n \tserviceAccept := serviceAcceptMsg{\n \t\tService: serviceUserAuth,\n@@ -420,9 +420,9 @@ func (s *ServerConn) testPubKey(user, algo string, pubKey []byte) bool {\n \treturn result\n }\n \n-func (s *ServerConn) authenticate(H []byte) os.Error {\n+func (s *ServerConn) authenticate(H []byte) error {\n \tvar userAuthReq userAuthRequestMsg\n-\tvar err os.Error\n+\tvar err error\n \tvar packet []byte\n \n userAuthLoop:\n@@ -435,7 +435,7 @@ userAuthLoop:\n \t\t}\n \n \t\tif userAuthReq.Service != serviceSSH {\n-\t\t\treturn os.NewError(\"ssh: client attempted to negotiate for unknown service: \" + userAuthReq.Service)\n+\t\t\treturn errors.New(\"ssh: client attempted to negotiate for unknown service: \" + userAuthReq.Service)\n \t\t}\n \n \t\tswitch userAuthReq.Method {\n@@ -523,7 +523,7 @@ userAuthLoop:\n \t\t\t\t\t\treturn ParseError{msgUserAuthRequest}\n \t\t\t\t\t}\n \t\t\t\tdefault:\n-\t\t\t\t\treturn os.NewError(\"ssh: isAcceptableAlgo incorrect\")\n+\t\t\t\t\treturn errors.New(\"ssh: isAcceptableAlgo incorrect\")\n \t\t\t\t}\n \t\t\t\tif s.testPubKey(userAuthReq.User, algo, pubKey) {\n \t\t\t\t\tbreak userAuthLoop\n@@ -540,7 +540,7 @@ userAuthLoop:\n \t\t}\n \n \t\tif len(failureMsg.Methods) == 0 {\n-\t\t\treturn os.NewError(\"ssh: no authentication methods configured but NoClientAuth is also false\")\n+\t\t\treturn errors.New(\"ssh: no authentication methods configured but NoClientAuth is also false\")\n \t\t}\n \n \t\tif err = s.writePacket(marshal(msgUserAuthFailure, failureMsg)); err != nil {\n@@ -560,7 +560,7 @@ const defaultWindowSize = 32768\n \n // Accept reads and processes messages on a ServerConn. It must be called\n // in order to demultiplex messages to any resulting Channels.\n-func (s *ServerConn) Accept() (Channel, os.Error) {\n+func (s *ServerConn) Accept() (Channel, error) {\n \tif s.err != nil {\n \t\treturn nil, s.err\n \t}\n@@ -660,7 +660,7 @@ func (s *ServerConn) Accept() (Channel, os.Error) {\n \t\t\tcase UnexpectedMessageError:\n \t\t\t\treturn nil, msg\n \t\t\tcase *disconnectMsg:\n-\t\t\t\treturn nil, os.EOF\n+\t\t\t\treturn nil, io.EOF\n \t\t\tdefault:\n \t\t\t\t// Unknown message. Ignore.\n \t\t\t}\n@@ -679,7 +679,7 @@ type Listener struct {\n // Accept waits for and returns the next incoming SSH connection.\n // The receiver should call Handshake() in another goroutine \n // to avoid blocking the accepter.\n-func (l *Listener) Accept() (*ServerConn, os.Error) {\n+func (l *Listener) Accept() (*ServerConn, error) {\n \tc, err := l.listener.Accept()\n \tif err != nil {\n \t\treturn nil, err\n@@ -694,13 +694,13 @@ func (l *Listener) Addr() net.Addr {\n }\n \n // Close closes the listener.\n-func (l *Listener) Close() os.Error {\n+func (l *Listener) Close() error {\n \treturn l.listener.Close()\n }\n \n // Listen creates an SSH listener accepting connections on\n // the given network address using net.Listen.\n-func Listen(network, addr string, config *ServerConfig) (*Listener, os.Error) {\n+func Listen(network, addr string, config *ServerConfig) (*Listener, error) {\n \tl, err := net.Listen(network, addr)\n \tif err != nil {\n \t\treturn nil, err"}, {"sha": "5243d0ee7f4d5ce1536bdac66efae8ced5807e85", "filename": "libgo/go/exp/ssh/server_shell.go", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,9 +4,7 @@\n \n package ssh\n \n-import (\n-\t\"os\"\n-)\n+import \"io\"\n \n // ServerShell contains the state for running a VT100 terminal that is capable\n // of reading lines of input.\n@@ -326,12 +324,12 @@ func parsePtyRequest(s []byte) (width, height int, ok bool) {\n \treturn\n }\n \n-func (ss *ServerShell) Write(buf []byte) (n int, err os.Error) {\n+func (ss *ServerShell) Write(buf []byte) (n int, err error) {\n \treturn ss.c.Write(buf)\n }\n \n // ReadLine returns a line of input from the terminal.\n-func (ss *ServerShell) ReadLine() (line string, err os.Error) {\n+func (ss *ServerShell) ReadLine() (line string, err error) {\n \tss.writeLine([]byte(ss.prompt))\n \tss.c.Write(ss.outBuf)\n \tss.outBuf = ss.outBuf[:0]\n@@ -353,7 +351,7 @@ func (ss *ServerShell) ReadLine() (line string, err os.Error) {\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t\tif key == keyCtrlD {\n-\t\t\t\t\treturn \"\", os.EOF\n+\t\t\t\t\treturn \"\", io.EOF\n \t\t\t\t}\n \t\t\t\tline, lineOk = ss.handleKey(key)\n \t\t\t}"}, {"sha": "aa69ef7fedb3c7e388c554c9d6152c29ef3867e2", "filename": "libgo/go/exp/ssh/server_shell_test.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,8 +5,8 @@\n package ssh\n \n import (\n+\t\"io\"\n \t\"testing\"\n-\t\"os\"\n )\n \n type MockChannel struct {\n@@ -15,15 +15,15 @@ type MockChannel struct {\n \treceived     []byte\n }\n \n-func (c *MockChannel) Accept() os.Error {\n+func (c *MockChannel) Accept() error {\n \treturn nil\n }\n \n-func (c *MockChannel) Reject(RejectionReason, string) os.Error {\n+func (c *MockChannel) Reject(RejectionReason, string) error {\n \treturn nil\n }\n \n-func (c *MockChannel) Read(data []byte) (n int, err os.Error) {\n+func (c *MockChannel) Read(data []byte) (n int, err error) {\n \tn = len(data)\n \tif n == 0 {\n \t\treturn\n@@ -32,7 +32,7 @@ func (c *MockChannel) Read(data []byte) (n int, err os.Error) {\n \t\tn = len(c.toSend)\n \t}\n \tif n == 0 {\n-\t\treturn 0, os.EOF\n+\t\treturn 0, io.EOF\n \t}\n \tif c.bytesPerRead > 0 && n > c.bytesPerRead {\n \t\tn = c.bytesPerRead\n@@ -42,16 +42,16 @@ func (c *MockChannel) Read(data []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (c *MockChannel) Write(data []byte) (n int, err os.Error) {\n+func (c *MockChannel) Write(data []byte) (n int, err error) {\n \tc.received = append(c.received, data...)\n \treturn len(data), nil\n }\n \n-func (c *MockChannel) Close() os.Error {\n+func (c *MockChannel) Close() error {\n \treturn nil\n }\n \n-func (c *MockChannel) AckRequest(ok bool) os.Error {\n+func (c *MockChannel) AckRequest(ok bool) error {\n \treturn nil\n }\n \n@@ -70,20 +70,20 @@ func TestClose(t *testing.T) {\n \tif line != \"\" {\n \t\tt.Errorf(\"Expected empty line but got: %s\", line)\n \t}\n-\tif err != os.EOF {\n+\tif err != io.EOF {\n \t\tt.Errorf(\"Error should have been EOF but got: %s\", err)\n \t}\n }\n \n var keyPressTests = []struct {\n \tin   string\n \tline string\n-\terr  os.Error\n+\terr  error\n }{\n \t{\n \t\t\"\",\n \t\t\"\",\n-\t\tos.EOF,\n+\t\tio.EOF,\n \t},\n \t{\n \t\t\"\\r\","}, {"sha": "77154f2c3c30f544dbc0ac5764b0d3d26377f8a9", "filename": "libgo/go/exp/ssh/session.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,8 +9,8 @@ package ssh\n \n import (\n \t\"encoding/binary\"\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n )\n \n // A Session represents a connection to a remote command or shell.\n@@ -34,7 +34,7 @@ type Session struct {\n \n // Setenv sets an environment variable that will be applied to any\n // command executed by Shell or Exec.\n-func (s *Session) Setenv(name, value string) os.Error {\n+func (s *Session) Setenv(name, value string) error {\n \tn, v := []byte(name), []byte(value)\n \tnlen, vlen := stringLength(n), stringLength(v)\n \tpayload := make([]byte, nlen+vlen)\n@@ -53,7 +53,7 @@ func (s *Session) Setenv(name, value string) os.Error {\n var emptyModeList = []byte{0, 0, 0, 1, 0}\n \n // RequestPty requests the association of a pty with the session on the remote host.\n-func (s *Session) RequestPty(term string, h, w int) os.Error {\n+func (s *Session) RequestPty(term string, h, w int) error {\n \tbuf := make([]byte, 4+len(term)+16+len(emptyModeList))\n \tb := marshalString(buf, []byte(term))\n \tbinary.BigEndian.PutUint32(b, uint32(h))\n@@ -73,9 +73,9 @@ func (s *Session) RequestPty(term string, h, w int) os.Error {\n // Exec runs cmd on the remote host. Typically, the remote \n // server passes cmd to the shell for interpretation. \n // A Session only accepts one call to Exec or Shell.\n-func (s *Session) Exec(cmd string) os.Error {\n+func (s *Session) Exec(cmd string) error {\n \tif s.started {\n-\t\treturn os.NewError(\"session already started\")\n+\t\treturn errors.New(\"session already started\")\n \t}\n \tcmdLen := stringLength([]byte(cmd))\n \tpayload := make([]byte, cmdLen)\n@@ -92,9 +92,9 @@ func (s *Session) Exec(cmd string) os.Error {\n \n // Shell starts a login shell on the remote host. A Session only \n // accepts one call to Exec or Shell.\n-func (s *Session) Shell() os.Error {\n+func (s *Session) Shell() error {\n \tif s.started {\n-\t\treturn os.NewError(\"session already started\")\n+\t\treturn errors.New(\"session already started\")\n \t}\n \ts.started = true\n \n@@ -106,7 +106,7 @@ func (s *Session) Shell() os.Error {\n }\n \n // NewSession returns a new interactive session on the remote host.\n-func (c *ClientConn) NewSession() (*Session, os.Error) {\n+func (c *ClientConn) NewSession() (*Session, error) {\n \tch, err := c.openChan(\"session\")\n \tif err != nil {\n \t\treturn nil, err"}, {"sha": "579a9d82de914604a95e918d098a3d9e9fe8c18c", "filename": "libgo/go/exp/ssh/transport.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,10 +11,10 @@ import (\n \t\"crypto/cipher\"\n \t\"crypto/hmac\"\n \t\"crypto/subtle\"\n+\t\"errors\"\n \t\"hash\"\n \t\"io\"\n \t\"net\"\n-\t\"os\"\n \t\"sync\"\n )\n \n@@ -27,7 +27,7 @@ const (\n // TODO(dfc) suggestions for a better name will be warmly received.\n type filteredConn interface {\n \t// Close closes the connection.\n-\tClose() os.Error\n+\tClose() error\n \n \t// LocalAddr returns the local network address.\n \tLocalAddr() net.Addr\n@@ -40,7 +40,7 @@ type filteredConn interface {\n // an SSH peer.\n type packetWriter interface {\n \t// Encrypt and send a packet of data to the remote peer.\n-\twritePacket(packet []byte) os.Error\n+\twritePacket(packet []byte) error\n }\n \n // transport represents the SSH connection to the remote peer.\n@@ -79,7 +79,7 @@ type common struct {\n }\n \n // Read and decrypt a single packet from the remote peer.\n-func (r *reader) readOnePacket() ([]byte, os.Error) {\n+func (r *reader) readOnePacket() ([]byte, error) {\n \tvar lengthBytes = make([]byte, 5)\n \tvar macSize uint32\n \n@@ -108,10 +108,10 @@ func (r *reader) readOnePacket() ([]byte, os.Error) {\n \tpaddingLength := uint32(lengthBytes[4])\n \n \tif length <= paddingLength+1 {\n-\t\treturn nil, os.NewError(\"invalid packet length\")\n+\t\treturn nil, errors.New(\"invalid packet length\")\n \t}\n \tif length > maxPacketSize {\n-\t\treturn nil, os.NewError(\"packet too large\")\n+\t\treturn nil, errors.New(\"packet too large\")\n \t}\n \n \tpacket := make([]byte, length-1+macSize)\n@@ -126,7 +126,7 @@ func (r *reader) readOnePacket() ([]byte, os.Error) {\n \tif r.mac != nil {\n \t\tr.mac.Write(packet[:length-1])\n \t\tif subtle.ConstantTimeCompare(r.mac.Sum(), mac) != 1 {\n-\t\t\treturn nil, os.NewError(\"ssh: MAC failure\")\n+\t\t\treturn nil, errors.New(\"ssh: MAC failure\")\n \t\t}\n \t}\n \n@@ -135,7 +135,7 @@ func (r *reader) readOnePacket() ([]byte, os.Error) {\n }\n \n // Read and decrypt next packet discarding debug and noop messages.\n-func (t *transport) readPacket() ([]byte, os.Error) {\n+func (t *transport) readPacket() ([]byte, error) {\n \tfor {\n \t\tpacket, err := t.readOnePacket()\n \t\tif err != nil {\n@@ -149,7 +149,7 @@ func (t *transport) readPacket() ([]byte, os.Error) {\n }\n \n // Encrypt and send a packet of data to the remote peer.\n-func (w *writer) writePacket(packet []byte) os.Error {\n+func (w *writer) writePacket(packet []byte) error {\n \tw.Mutex.Lock()\n \tdefer w.Mutex.Unlock()\n \n@@ -218,7 +218,7 @@ func (w *writer) writePacket(packet []byte) os.Error {\n }\n \n // Send a message to the remote peer\n-func (t *transport) sendMessage(typ uint8, msg interface{}) os.Error {\n+func (t *transport) sendMessage(typ uint8, msg interface{}) error {\n \tpacket := marshal(typ, msg)\n \treturn t.writePacket(packet)\n }\n@@ -252,7 +252,7 @@ var (\n // setupKeys sets the cipher and MAC keys from K, H and sessionId, as\n // described in RFC 4253, section 6.4. direction should either be serverKeys\n // (to setup server->client keys) or clientKeys (for client->server keys).\n-func (c *common) setupKeys(d direction, K, H, sessionId []byte, hashFunc crypto.Hash) os.Error {\n+func (c *common) setupKeys(d direction, K, H, sessionId []byte, hashFunc crypto.Hash) error {\n \th := hashFunc.New()\n \n \tblockSize := 16\n@@ -308,7 +308,7 @@ type truncatingMAC struct {\n \thmac   hash.Hash\n }\n \n-func (t truncatingMAC) Write(data []byte) (int, os.Error) {\n+func (t truncatingMAC) Write(data []byte) (int, error) {\n \treturn t.hmac.Write(data)\n }\n \n@@ -332,7 +332,7 @@ func (t truncatingMAC) Size() int {\n const maxVersionStringBytes = 1024\n \n // Read version string as specified by RFC 4253, section 4.2.\n-func readVersion(r io.Reader) ([]byte, os.Error) {\n+func readVersion(r io.Reader) ([]byte, error) {\n \tversionString := make([]byte, 0, 64)\n \tvar ok, seenCR bool\n \tvar buf [1]byte\n@@ -360,7 +360,7 @@ forEachByte:\n \t}\n \n \tif !ok {\n-\t\treturn nil, os.NewError(\"failed to read version string\")\n+\t\treturn nil, errors.New(\"failed to read version string\")\n \t}\n \n \t// We need to remove the CR from versionString"}, {"sha": "22fca9e060e6290e085298039eebcfb8c18f9e4f", "filename": "libgo/go/exp/template/html/error.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Ferror.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -197,7 +197,7 @@ const (\n \tErrSlashAmbig\n )\n \n-func (e *Error) String() string {\n+func (e *Error) Error() string {\n \tif e.Line != 0 {\n \t\treturn fmt.Sprintf(\"exp/template/html:%s:%d: %s\", e.Name, e.Line, e.Description)\n \t} else if e.Name != \"\" {"}, {"sha": "28615a93180c2761f24c074345e7006c3ae5fbb4", "filename": "libgo/go/exp/template/html/escape.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,14 +8,13 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"html\"\n-\t\"os\"\n \t\"template\"\n \t\"template/parse\"\n )\n \n // Escape rewrites each action in the template to guarantee that the output is\n // properly escaped.\n-func Escape(t *template.Template) (*template.Template, os.Error) {\n+func Escape(t *template.Template) (*template.Template, error) {\n \tvar s template.Set\n \ts.Add(t)\n \tif _, err := EscapeSet(&s, t.Name()); err != nil {\n@@ -32,7 +31,7 @@ func Escape(t *template.Template) (*template.Template, os.Error) {\n // need not include helper templates.\n // If no error is returned, then the named templates have been modified. \n // Otherwise the named templates have been rendered unusable.\n-func EscapeSet(s *template.Set, names ...string) (*template.Set, os.Error) {\n+func EscapeSet(s *template.Set, names ...string) (*template.Set, error) {\n \tif len(names) == 0 {\n \t\t// TODO: Maybe add a method to Set to enumerate template names\n \t\t// and use those instead.\n@@ -41,7 +40,7 @@ func EscapeSet(s *template.Set, names ...string) (*template.Set, os.Error) {\n \te := newEscaper(s)\n \tfor _, name := range names {\n \t\tc, _ := e.escapeTree(context{}, name, 0)\n-\t\tvar err os.Error\n+\t\tvar err error\n \t\tif c.err != nil {\n \t\t\terr, c.err.Name = c.err, name\n \t\t} else if c.state != stateText {"}, {"sha": "20599bce152d9c9ba7ed8c744b28c1a0b99b56ef", "filename": "libgo/go/exp/template/html/escape_test.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"json\"\n-\t\"os\"\n \t\"strings\"\n \t\"template\"\n \t\"template/parse\"\n@@ -17,14 +16,14 @@ import (\n \n type badMarshaler struct{}\n \n-func (x *badMarshaler) MarshalJSON() ([]byte, os.Error) {\n+func (x *badMarshaler) MarshalJSON() ([]byte, error) {\n \t// Keys in valid JSON must be double quoted as must all strings.\n \treturn []byte(\"{ foo: 'not quite valid JSON' }\"), nil\n }\n \n type goodMarshaler struct{}\n \n-func (x *goodMarshaler) MarshalJSON() ([]byte, os.Error) {\n+func (x *goodMarshaler) MarshalJSON() ([]byte, error) {\n \treturn []byte(`{ \"<foo>\": \"O'Reilly\" }`), nil\n }\n \n@@ -783,7 +782,7 @@ func TestEscapeSet(t *testing.T) {\n \n \t// pred is a template function that returns the predecessor of a\n \t// natural number for testing recursive templates.\n-\tfns := template.FuncMap{\"pred\": func(a ...interface{}) (interface{}, os.Error) {\n+\tfns := template.FuncMap{\"pred\": func(a ...interface{}) (interface{}, error) {\n \t\tif len(a) == 1 {\n \t\t\tif i, _ := a[0].(int); i > 0 {\n \t\t\t\treturn i - 1, nil\n@@ -807,7 +806,7 @@ func TestEscapeSet(t *testing.T) {\n \t\tvar b bytes.Buffer\n \n \t\tif err := s.Execute(&b, \"main\", data); err != nil {\n-\t\t\tt.Errorf(\"%q executing %v\", err.String(), s.Template(\"main\"))\n+\t\t\tt.Errorf(\"%q executing %v\", err.Error(), s.Template(\"main\"))\n \t\t\tcontinue\n \t\t}\n \t\tif got := b.String(); test.want != got {\n@@ -962,7 +961,7 @@ func TestErrors(t *testing.T) {\n \t}\n \n \tfor _, test := range tests {\n-\t\tvar err os.Error\n+\t\tvar err error\n \t\tif strings.HasPrefix(test.input, \"{{define\") {\n \t\t\tvar s template.Set\n \t\t\t_, err = s.Parse(test.input)\n@@ -977,7 +976,7 @@ func TestErrors(t *testing.T) {\n \t\t}\n \t\tvar got string\n \t\tif err != nil {\n-\t\t\tgot = err.String()\n+\t\t\tgot = err.Error()\n \t\t}\n \t\tif test.err == \"\" {\n \t\t\tif got != \"\" {\n@@ -1549,7 +1548,7 @@ func TestEnsurePipelineContains(t *testing.T) {\n \t}\n }\n \n-func expectExecuteFailure(t *testing.T, b *bytes.Buffer, err os.Error) {\n+func expectExecuteFailure(t *testing.T, b *bytes.Buffer, err error) {\n \tif err != nil {\n \t\tif b.Len() != 0 {\n \t\t\tt.Errorf(\"output on buffer: %q\", b.String())"}, {"sha": "22be4183d77d5737f82f21f2410231cf31de8598", "filename": "libgo/go/exp/template/html/js.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fjs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fjs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fjs.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -148,7 +148,7 @@ func jsValEscaper(args ...interface{}) string {\n \t\t// turning into\n \t\t//     x//* error marshalling y:\n \t\t//          second line of error message */null\n-\t\treturn fmt.Sprintf(\" /* %s */null \", strings.Replace(err.String(), \"*/\", \"* /\", -1))\n+\t\treturn fmt.Sprintf(\" /* %s */null \", strings.Replace(err.Error(), \"*/\", \"* /\", -1))\n \t}\n \n \t// TODO: maybe post-process output to prevent it from containing"}, {"sha": "5c5916755d603b844601a455c4852fcdd752488b", "filename": "libgo/go/exp/terminal/shell.go", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fterminal%2Fshell.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fterminal%2Fshell.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fshell.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,10 +4,7 @@\n \n package terminal\n \n-import (\n-\t\"os\"\n-\t\"io\"\n-)\n+import \"io\"\n \n // Shell contains the state for running a VT100 terminal that is capable of\n // reading lines of input.\n@@ -306,12 +303,12 @@ func (ss *Shell) writeLine(line []byte) {\n \t}\n }\n \n-func (ss *Shell) Write(buf []byte) (n int, err os.Error) {\n+func (ss *Shell) Write(buf []byte) (n int, err error) {\n \treturn ss.c.Write(buf)\n }\n \n // ReadLine returns a line of input from the terminal.\n-func (ss *Shell) ReadLine() (line string, err os.Error) {\n+func (ss *Shell) ReadLine() (line string, err error) {\n \tss.writeLine([]byte(ss.prompt))\n \tss.c.Write(ss.outBuf)\n \tss.outBuf = ss.outBuf[:0]\n@@ -337,7 +334,7 @@ func (ss *Shell) ReadLine() (line string, err os.Error) {\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t\tif key == keyCtrlD {\n-\t\t\t\t\treturn \"\", os.EOF\n+\t\t\t\t\treturn \"\", io.EOF\n \t\t\t\t}\n \t\t\t\tline, lineOk = ss.handleKey(key)\n \t\t\t}"}, {"sha": "8a76a85d5dcc0c211eb9ab995f21f44024ffb3da", "filename": "libgo/go/exp/terminal/shell_test.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fterminal%2Fshell_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fterminal%2Fshell_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fshell_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,8 +5,8 @@\n package terminal\n \n import (\n+\t\"io\"\n \t\"testing\"\n-\t\"os\"\n )\n \n type MockTerminal struct {\n@@ -15,7 +15,7 @@ type MockTerminal struct {\n \treceived     []byte\n }\n \n-func (c *MockTerminal) Read(data []byte) (n int, err os.Error) {\n+func (c *MockTerminal) Read(data []byte) (n int, err error) {\n \tn = len(data)\n \tif n == 0 {\n \t\treturn\n@@ -24,7 +24,7 @@ func (c *MockTerminal) Read(data []byte) (n int, err os.Error) {\n \t\tn = len(c.toSend)\n \t}\n \tif n == 0 {\n-\t\treturn 0, os.EOF\n+\t\treturn 0, io.EOF\n \t}\n \tif c.bytesPerRead > 0 && n > c.bytesPerRead {\n \t\tn = c.bytesPerRead\n@@ -34,7 +34,7 @@ func (c *MockTerminal) Read(data []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (c *MockTerminal) Write(data []byte) (n int, err os.Error) {\n+func (c *MockTerminal) Write(data []byte) (n int, err error) {\n \tc.received = append(c.received, data...)\n \treturn len(data), nil\n }\n@@ -46,20 +46,20 @@ func TestClose(t *testing.T) {\n \tif line != \"\" {\n \t\tt.Errorf(\"Expected empty line but got: %s\", line)\n \t}\n-\tif err != os.EOF {\n+\tif err != io.EOF {\n \t\tt.Errorf(\"Error should have been EOF but got: %s\", err)\n \t}\n }\n \n var keyPressTests = []struct {\n \tin   string\n \tline string\n-\terr  os.Error\n+\terr  error\n }{\n \t{\n \t\t\"\",\n \t\t\"\",\n-\t\tos.EOF,\n+\t\tio.EOF,\n \t},\n \t{\n \t\t\"\\r\","}, {"sha": "5732543ffc2772647bf363994cef4f5fa0d5eb91", "filename": "libgo/go/exp/terminal/terminal.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -15,6 +15,7 @@\n package terminal\n \n import (\n+\t\"io\"\n \t\"os\"\n \t\"syscall\"\n )\n@@ -34,7 +35,7 @@ func IsTerminal(fd int) bool {\n // MakeRaw put the terminal connected to the given file descriptor into raw\n // mode and returns the previous state of the terminal so that it can be\n // restored.\n-func MakeRaw(fd int) (*State, os.Error) {\n+func MakeRaw(fd int) (*State, error) {\n \tvar oldState State\n \tif e := syscall.Tcgetattr(fd, &oldState.termios); e != 0 {\n \t\treturn nil, os.Errno(e)\n@@ -52,15 +53,15 @@ func MakeRaw(fd int) (*State, os.Error) {\n \n // Restore restores the terminal connected to the given file descriptor to a\n // previous state.\n-func Restore(fd int, state *State) os.Error {\n+func Restore(fd int, state *State) error {\n \te := syscall.Tcsetattr(fd, syscall.TCSANOW, &state.termios)\n \treturn os.Errno(e)\n }\n \n // ReadPassword reads a line of input from a terminal without local echo.  This\n // is commonly used for inputting passwords and other sensitive data. The slice\n // returned does not include the \\n.\n-func ReadPassword(fd int) ([]byte, os.Error) {\n+func ReadPassword(fd int) ([]byte, error) {\n \tvar oldState syscall.Termios\n \tif e := syscall.Tcgetattr(fd, &oldState); e != 0 {\n \t\treturn nil, os.Errno(e)\n@@ -85,7 +86,7 @@ func ReadPassword(fd int) ([]byte, os.Error) {\n \t\t}\n \t\tif n == 0 {\n \t\t\tif len(ret) == 0 {\n-\t\t\t\treturn nil, os.EOF\n+\t\t\t\treturn nil, io.EOF\n \t\t\t}\n \t\t\tbreak\n \t\t}"}, {"sha": "09e29d1261a8854777cd5cb205c730c9d7e4afe6", "filename": "libgo/go/exp/types/check.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,7 +11,6 @@ import (\n \t\"go/ast\"\n \t\"go/scanner\"\n \t\"go/token\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -213,7 +212,7 @@ func (c *checker) checkObj(obj *ast.Object, ref bool) {\n // of types for all expression nodes in statements, and a scanner.ErrorList if\n // there are errors.\n //\n-func Check(fset *token.FileSet, pkg *ast.Package) (types map[ast.Expr]Type, err os.Error) {\n+func Check(fset *token.FileSet, pkg *ast.Package) (types map[ast.Expr]Type, err error) {\n \tvar c checker\n \tc.fset = fset\n \tc.types = make(map[ast.Expr]Type)"}, {"sha": "4a30acf23154daea9c5573be007d468a9e99f4ff", "filename": "libgo/go/exp/types/check_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -67,7 +67,7 @@ func getPos(filename string, offset int) token.Pos {\n \n // TODO(gri) Need to revisit parser interface. We should be able to use parser.ParseFiles\n //           or a similar function instead.\n-func parseFiles(t *testing.T, testname string, filenames []string) (map[string]*ast.File, os.Error) {\n+func parseFiles(t *testing.T, testname string, filenames []string) (map[string]*ast.File, error) {\n \tfiles := make(map[string]*ast.File)\n \tvar errors scanner.ErrorList\n \tfor _, filename := range filenames {\n@@ -132,7 +132,7 @@ func expectedErrors(t *testing.T, testname string, files map[string]*ast.File) m\n \treturn errors\n }\n \n-func eliminate(t *testing.T, expected map[token.Pos]string, errors os.Error) {\n+func eliminate(t *testing.T, expected map[token.Pos]string, errors error) {\n \tif errors == nil {\n \t\treturn\n \t}"}, {"sha": "fa5b6a37fe80d05c4e6f2fcb6f29650ca607a92c", "filename": "libgo/go/exp/types/exportdata.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,14 +8,15 @@ package types\n \n import (\n \t\"bufio\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n \t\"strconv\"\n \t\"strings\"\n )\n \n-func readGopackHeader(buf *bufio.Reader) (name string, size int, err os.Error) {\n+func readGopackHeader(buf *bufio.Reader) (name string, size int, err error) {\n \t// See $GOROOT/include/ar.h.\n \thdr := make([]byte, 16+12+6+6+8+10+2)\n \t_, err = io.ReadFull(buf, hdr)\n@@ -28,7 +29,7 @@ func readGopackHeader(buf *bufio.Reader) (name string, size int, err os.Error) {\n \ts := strings.TrimSpace(string(hdr[16+12+6+6+8:][:10]))\n \tsize, err = strconv.Atoi(s)\n \tif err != nil || hdr[len(hdr)-2] != '`' || hdr[len(hdr)-1] != '\\n' {\n-\t\terr = os.NewError(\"invalid archive header\")\n+\t\terr = errors.New(\"invalid archive header\")\n \t\treturn\n \t}\n \tname = strings.TrimSpace(string(hdr[:16]))\n@@ -44,7 +45,7 @@ type dataReader struct {\n // export data section of the given object/archive file, or an error.\n // It is the caller's responsibility to close the readCloser.\n //\n-func ExportData(filename string) (rc io.ReadCloser, err os.Error) {\n+func ExportData(filename string) (rc io.ReadCloser, err error) {\n \tfile, err := os.Open(filename)\n \tif err != nil {\n \t\treturn\n@@ -77,7 +78,7 @@ func ExportData(filename string) (rc io.ReadCloser, err os.Error) {\n \t\t\treturn\n \t\t}\n \t\tif name != \"__.SYMDEF\" {\n-\t\t\terr = os.NewError(\"go archive does not begin with __.SYMDEF\")\n+\t\t\terr = errors.New(\"go archive does not begin with __.SYMDEF\")\n \t\t\treturn\n \t\t}\n \t\tconst block = 4096\n@@ -99,7 +100,7 @@ func ExportData(filename string) (rc io.ReadCloser, err os.Error) {\n \t\t\treturn\n \t\t}\n \t\tif name != \"__.PKGDEF\" {\n-\t\t\terr = os.NewError(\"go archive is missing __.PKGDEF\")\n+\t\t\terr = errors.New(\"go archive is missing __.PKGDEF\")\n \t\t\treturn\n \t\t}\n \n@@ -114,7 +115,7 @@ func ExportData(filename string) (rc io.ReadCloser, err os.Error) {\n \t// Now at __.PKGDEF in archive or still at beginning of file.\n \t// Either way, line should begin with \"go object \".\n \tif !strings.HasPrefix(string(line), \"go object \") {\n-\t\terr = os.NewError(\"not a go object file\")\n+\t\terr = errors.New(\"not a go object file\")\n \t\treturn\n \t}\n "}, {"sha": "69dbd5ac5f34c2c766ef66f9f9808d3b82d4d7ae", "filename": "libgo/go/exp/types/gcimporter.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,6 +9,7 @@ package types\n \n import (\n \t\"big\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"go/ast\"\n \t\"go/token\"\n@@ -102,7 +103,7 @@ func (p *gcParser) next() {\n }\n \n // GcImporter implements the ast.Importer signature.\n-func GcImporter(imports map[string]*ast.Object, path string) (pkg *ast.Object, err os.Error) {\n+func GcImporter(imports map[string]*ast.Object, path string) (pkg *ast.Object, err error) {\n \tif path == \"unsafe\" {\n \t\treturn Unsafe, nil\n \t}\n@@ -118,7 +119,7 @@ func GcImporter(imports map[string]*ast.Object, path string) (pkg *ast.Object, e\n \n \tfilename, id := findPkg(path)\n \tif filename == \"\" {\n-\t\terr = os.NewError(\"can't find import: \" + id)\n+\t\terr = errors.New(\"can't find import: \" + id)\n \t\treturn\n \t}\n \n@@ -176,19 +177,19 @@ func (p *gcParser) declare(scope *ast.Scope, kind ast.ObjKind, name string) *ast\n // Internal errors are boxed as importErrors.\n type importError struct {\n \tpos scanner.Position\n-\terr os.Error\n+\terr error\n }\n \n-func (e importError) String() string {\n+func (e importError) Error() string {\n \treturn fmt.Sprintf(\"import error %s (byte offset = %d): %s\", e.pos, e.pos.Offset, e.err)\n }\n \n func (p *gcParser) error(err interface{}) {\n \tif s, ok := err.(string); ok {\n-\t\terr = os.NewError(s)\n+\t\terr = errors.New(s)\n \t}\n-\t// panic with a runtime.Error if err is not an os.Error\n-\tpanic(importError{p.scanner.Pos(), err.(os.Error)})\n+\t// panic with a runtime.Error if err is not an error\n+\tpanic(importError{p.scanner.Pos(), err.(error)})\n }\n \n func (p *gcParser) errorf(format string, args ...interface{}) {"}, {"sha": "780b82625f5f8208296f526074e7273a04c83858", "filename": "libgo/go/exp/types/universe.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -57,6 +57,7 @@ func init() {\n \tdefType(\"rune\") // TODO(gri) should be an alias for int\n \tdefType(\"complex64\")\n \tComplex128 = defType(\"complex128\")\n+\tdefType(\"error\")\n \tdefType(\"float32\")\n \tFloat64 = defType(\"float64\")\n \tdefType(\"int8\")"}, {"sha": "d133740304b68fc98c116fbad7602bc245d3bf7d", "filename": "libgo/go/exp/winfsnotify/winfsnotify.go", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,6 +7,7 @@\n package winfsnotify\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -36,7 +37,7 @@ type input struct {\n \top    int\n \tpath  string\n \tflags uint32\n-\treply chan os.Error\n+\treply chan error\n }\n \n type inode struct {\n@@ -65,14 +66,14 @@ type Watcher struct {\n \twatches  watchMap       // Map of watches (key: i-number)\n \tinput    chan *input    // Inputs to the reader are sent on this channel\n \tEvent    chan *Event    // Events are returned on this channel\n-\tError    chan os.Error  // Errors are sent on this channel\n+\tError    chan error     // Errors are sent on this channel\n \tisClosed bool           // Set to true when Close() is first called\n-\tquit     chan chan<- os.Error\n+\tquit     chan chan<- error\n \tcookie   uint32\n }\n \n // NewWatcher creates and returns a Watcher.\n-func NewWatcher() (*Watcher, os.Error) {\n+func NewWatcher() (*Watcher, error) {\n \tport, e := syscall.CreateIoCompletionPort(syscall.InvalidHandle, 0, 0, 0)\n \tif e != 0 {\n \t\treturn nil, os.NewSyscallError(\"CreateIoCompletionPort\", e)\n@@ -82,8 +83,8 @@ func NewWatcher() (*Watcher, os.Error) {\n \t\twatches: make(watchMap),\n \t\tinput:   make(chan *input, 1),\n \t\tEvent:   make(chan *Event, 50),\n-\t\tError:   make(chan os.Error),\n-\t\tquit:    make(chan chan<- os.Error, 1),\n+\t\tError:   make(chan error),\n+\t\tquit:    make(chan chan<- error, 1),\n \t}\n \tgo w.readEvents()\n \treturn w, nil\n@@ -92,14 +93,14 @@ func NewWatcher() (*Watcher, os.Error) {\n // Close closes a Watcher.\n // It sends a message to the reader goroutine to quit and removes all watches\n // associated with the watcher.\n-func (w *Watcher) Close() os.Error {\n+func (w *Watcher) Close() error {\n \tif w.isClosed {\n \t\treturn nil\n \t}\n \tw.isClosed = true\n \n \t// Send \"quit\" message to the reader goroutine\n-\tch := make(chan os.Error)\n+\tch := make(chan error)\n \tw.quit <- ch\n \tif err := w.wakeupReader(); err != nil {\n \t\treturn err\n@@ -108,15 +109,15 @@ func (w *Watcher) Close() os.Error {\n }\n \n // AddWatch adds path to the watched file set.\n-func (w *Watcher) AddWatch(path string, flags uint32) os.Error {\n+func (w *Watcher) AddWatch(path string, flags uint32) error {\n \tif w.isClosed {\n-\t\treturn os.NewError(\"watcher already closed\")\n+\t\treturn errors.New(\"watcher already closed\")\n \t}\n \tin := &input{\n \t\top:    opAddWatch,\n \t\tpath:  filepath.Clean(path),\n \t\tflags: flags,\n-\t\treply: make(chan os.Error),\n+\t\treply: make(chan error),\n \t}\n \tw.input <- in\n \tif err := w.wakeupReader(); err != nil {\n@@ -126,16 +127,16 @@ func (w *Watcher) AddWatch(path string, flags uint32) os.Error {\n }\n \n // Watch adds path to the watched file set, watching all events.\n-func (w *Watcher) Watch(path string) os.Error {\n+func (w *Watcher) Watch(path string) error {\n \treturn w.AddWatch(path, FS_ALL_EVENTS)\n }\n \n // RemoveWatch removes path from the watched file set.\n-func (w *Watcher) RemoveWatch(path string) os.Error {\n+func (w *Watcher) RemoveWatch(path string) error {\n \tin := &input{\n \t\top:    opRemoveWatch,\n \t\tpath:  filepath.Clean(path),\n-\t\treply: make(chan os.Error),\n+\t\treply: make(chan error),\n \t}\n \tw.input <- in\n \tif err := w.wakeupReader(); err != nil {\n@@ -144,15 +145,15 @@ func (w *Watcher) RemoveWatch(path string) os.Error {\n \treturn <-in.reply\n }\n \n-func (w *Watcher) wakeupReader() os.Error {\n+func (w *Watcher) wakeupReader() error {\n \te := syscall.PostQueuedCompletionStatus(w.port, 0, 0, nil)\n \tif e != 0 {\n \t\treturn os.NewSyscallError(\"PostQueuedCompletionStatus\", e)\n \t}\n \treturn nil\n }\n \n-func getDir(pathname string) (dir string, err os.Error) {\n+func getDir(pathname string) (dir string, err error) {\n \tattr, e := syscall.GetFileAttributes(syscall.StringToUTF16Ptr(pathname))\n \tif e != 0 {\n \t\treturn \"\", os.NewSyscallError(\"GetFileAttributes\", e)\n@@ -166,7 +167,7 @@ func getDir(pathname string) (dir string, err os.Error) {\n \treturn\n }\n \n-func getIno(path string) (ino *inode, err os.Error) {\n+func getIno(path string) (ino *inode, err error) {\n \th, e := syscall.CreateFile(syscall.StringToUTF16Ptr(path),\n \t\tsyscall.FILE_LIST_DIRECTORY,\n \t\tsyscall.FILE_SHARE_READ|syscall.FILE_SHARE_WRITE|syscall.FILE_SHARE_DELETE,\n@@ -207,7 +208,7 @@ func (m watchMap) set(ino *inode, watch *watch) {\n }\n \n // Must run within the I/O thread.\n-func (w *Watcher) addWatch(pathname string, flags uint64) os.Error {\n+func (w *Watcher) addWatch(pathname string, flags uint64) error {\n \tdir, err := getDir(pathname)\n \tif err != nil {\n \t\treturn err\n@@ -252,7 +253,7 @@ func (w *Watcher) addWatch(pathname string, flags uint64) os.Error {\n }\n \n // Must run within the I/O thread.\n-func (w *Watcher) removeWatch(pathname string) os.Error {\n+func (w *Watcher) removeWatch(pathname string) error {\n \tdir, err := getDir(pathname)\n \tif err != nil {\n \t\treturn err\n@@ -293,7 +294,7 @@ func (w *Watcher) deleteWatch(watch *watch) {\n }\n \n // Must run within the I/O thread.\n-func (w *Watcher) startRead(watch *watch) os.Error {\n+func (w *Watcher) startRead(watch *watch) error {\n \tif e := syscall.CancelIo(watch.ino.handle); e != 0 {\n \t\tw.Error <- os.NewSyscallError(\"CancelIo\", e)\n \t\tw.deleteWatch(watch)\n@@ -352,7 +353,7 @@ func (w *Watcher) readEvents() {\n \t\t\t\t\t\tw.startRead(watch)\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tvar err os.Error\n+\t\t\t\tvar err error\n \t\t\t\tif e := syscall.CloseHandle(w.port); e != 0 {\n \t\t\t\t\terr = os.NewSyscallError(\"CloseHandle\", e)\n \t\t\t\t}\n@@ -392,7 +393,7 @@ func (w *Watcher) readEvents() {\n \t\tfor {\n \t\t\tif n == 0 {\n \t\t\t\tw.Event <- &Event{Mask: FS_Q_OVERFLOW}\n-\t\t\t\tw.Error <- os.NewError(\"short read in readEvents()\")\n+\t\t\t\tw.Error <- errors.New(\"short read in readEvents()\")\n \t\t\t\tbreak\n \t\t\t}\n "}, {"sha": "9f115d592bde5d34cd2c03a13e00006b63237588", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -60,14 +60,15 @@\n package flag\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"os\"\n \t\"sort\"\n \t\"strconv\"\n )\n \n // ErrHelp is the error returned if the flag -help is invoked but no such flag is defined.\n-var ErrHelp = os.NewError(\"flag: help requested\")\n+var ErrHelp = errors.New(\"flag: help requested\")\n \n // -- Bool Value\n type boolValue bool\n@@ -580,7 +581,7 @@ func Var(value Value, name string, usage string) {\n \n // failf prints to standard error a formatted error and usage message and\n // returns the error.\n-func (f *FlagSet) failf(format string, a ...interface{}) os.Error {\n+func (f *FlagSet) failf(format string, a ...interface{}) error {\n \terr := fmt.Errorf(format, a...)\n \tfmt.Fprintln(os.Stderr, err)\n \tf.usage()\n@@ -600,7 +601,7 @@ func (f *FlagSet) usage() {\n }\n \n // parseOne parses one flag. It returns whether a flag was seen.\n-func (f *FlagSet) parseOne() (bool, os.Error) {\n+func (f *FlagSet) parseOne() (bool, error) {\n \tif len(f.args) == 0 {\n \t\treturn false, nil\n \t}\n@@ -676,7 +677,7 @@ func (f *FlagSet) parseOne() (bool, os.Error) {\n // include the command name.  Must be called after all flags in the FlagSet\n // are defined and before flags are accessed by the program.\n // The return value will be ErrHelp if -help was set but not defined.\n-func (f *FlagSet) Parse(arguments []string) os.Error {\n+func (f *FlagSet) Parse(arguments []string) error {\n \tf.parsed = true\n \tf.args = arguments\n \tfor {"}, {"sha": "13456445449b5850bb7c6c31d6a9b9d403860940", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,6 +6,7 @@ package fmt\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"io\"\n \t\"os\"\n \t\"reflect\"\n@@ -37,7 +38,7 @@ var (\n // the flags and options for the operand's format specifier.\n type State interface {\n \t// Write is the function to call to emit formatted output to be printed.\n-\tWrite(b []byte) (ret int, err os.Error)\n+\tWrite(b []byte) (ret int, err error)\n \t// Width returns the value of the width option and whether it has been set.\n \tWidth() (wid int, ok bool)\n \t// Precision returns the value of the precision option and whether it has been set.\n@@ -165,15 +166,15 @@ func (p *pp) add(c rune) {\n \n // Implement Write so we can call Fprintf on a pp (through State), for\n // recursive use in custom verbs.\n-func (p *pp) Write(b []byte) (ret int, err os.Error) {\n+func (p *pp) Write(b []byte) (ret int, err error) {\n \treturn p.buf.Write(b)\n }\n \n // These routines end in 'f' and take a format string.\n \n // Fprintf formats according to a format specifier and writes to w.\n // It returns the number of bytes written and any write error encountered.\n-func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err os.Error) {\n+func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {\n \tp := newPrinter()\n \tp.doPrintf(format, a)\n \tn64, err := p.buf.WriteTo(w)\n@@ -183,7 +184,7 @@ func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err os.Error)\n \n // Printf formats according to a format specifier and writes to standard output.\n // It returns the number of bytes written and any write error encountered.\n-func Printf(format string, a ...interface{}) (n int, err os.Error) {\n+func Printf(format string, a ...interface{}) (n int, err error) {\n \treturn Fprintf(os.Stdout, format, a...)\n }\n \n@@ -197,17 +198,17 @@ func Sprintf(format string, a ...interface{}) string {\n }\n \n // Errorf formats according to a format specifier and returns the string \n-// as a value that satisfies os.Error.\n-func Errorf(format string, a ...interface{}) os.Error {\n-\treturn os.NewError(Sprintf(format, a...))\n+// as a value that satisfies error.\n+func Errorf(format string, a ...interface{}) error {\n+\treturn errors.New(Sprintf(format, a...))\n }\n \n // These routines do not take a format string\n \n // Fprint formats using the default formats for its operands and writes to w.\n // Spaces are added between operands when neither is a string.\n // It returns the number of bytes written and any write error encountered.\n-func Fprint(w io.Writer, a ...interface{}) (n int, err os.Error) {\n+func Fprint(w io.Writer, a ...interface{}) (n int, err error) {\n \tp := newPrinter()\n \tp.doPrint(a, false, false)\n \tn64, err := p.buf.WriteTo(w)\n@@ -218,7 +219,7 @@ func Fprint(w io.Writer, a ...interface{}) (n int, err os.Error) {\n // Print formats using the default formats for its operands and writes to standard output.\n // Spaces are added between operands when neither is a string.\n // It returns the number of bytes written and any write error encountered.\n-func Print(a ...interface{}) (n int, err os.Error) {\n+func Print(a ...interface{}) (n int, err error) {\n \treturn Fprint(os.Stdout, a...)\n }\n \n@@ -239,7 +240,7 @@ func Sprint(a ...interface{}) string {\n // Fprintln formats using the default formats for its operands and writes to w.\n // Spaces are always added between operands and a newline is appended.\n // It returns the number of bytes written and any write error encountered.\n-func Fprintln(w io.Writer, a ...interface{}) (n int, err os.Error) {\n+func Fprintln(w io.Writer, a ...interface{}) (n int, err error) {\n \tp := newPrinter()\n \tp.doPrint(a, true, true)\n \tn64, err := p.buf.WriteTo(w)\n@@ -250,7 +251,7 @@ func Fprintln(w io.Writer, a ...interface{}) (n int, err os.Error) {\n // Println formats using the default formats for its operands and writes to standard output.\n // Spaces are always added between operands and a newline is appended.\n // It returns the number of bytes written and any write error encountered.\n-func Println(a ...interface{}) (n int, err os.Error) {\n+func Println(a ...interface{}) (n int, err error) {\n \treturn Fprintln(os.Stdout, a...)\n }\n \n@@ -635,11 +636,11 @@ func (p *pp) handleMethods(verb rune, plus, goSyntax bool, depth int) (wasString\n \t\t// setting wasString and handled and deferring catchPanic\n \t\t// must happen before calling the method.\n \t\tswitch v := p.field.(type) {\n-\t\tcase os.Error:\n+\t\tcase error:\n \t\t\twasString = false\n \t\t\thandled = true\n \t\t\tdefer p.catchPanic(p.field, verb)\n-\t\t\tp.printField(v.String(), verb, plus, false, depth)\n+\t\t\tp.printField(v.Error(), verb, plus, false, depth)\n \t\t\treturn\n \n \t\tcase Stringer:"}, {"sha": "54a9fe2951e04eb68dfaf14416dd9e117cfbdfb7", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,6 +6,7 @@ package fmt\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"io\"\n \t\"math\"\n \t\"os\"\n@@ -21,7 +22,7 @@ import (\n // a local buffer will be used to back up the input, but its contents\n // will be lost when Scan returns.\n type runeUnreader interface {\n-\tUnreadRune() os.Error\n+\tUnreadRune() error\n }\n \n // ScanState represents the scanner state passed to custom scanners.\n@@ -32,9 +33,9 @@ type ScanState interface {\n \t// If invoked during Scanln, Fscanln, or Sscanln, ReadRune() will\n \t// return EOF after returning the first '\\n' or when reading beyond\n \t// the specified width.\n-\tReadRune() (r rune, size int, err os.Error)\n+\tReadRune() (r rune, size int, err error)\n \t// UnreadRune causes the next call to ReadRune to return the same rune.\n-\tUnreadRune() os.Error\n+\tUnreadRune() error\n \t// SkipSpace skips space in the input. Newlines are treated as space \n \t// unless the scan operation is Scanln, Fscanln or Sscanln, in which case \n \t// a newline is treated as EOF.\n@@ -47,71 +48,71 @@ type ScanState interface {\n \t// EOF.  The returned slice points to shared data that may be overwritten\n \t// by the next call to Token, a call to a Scan function using the ScanState\n \t// as input, or when the calling Scan method returns.\n-\tToken(skipSpace bool, f func(rune) bool) (token []byte, err os.Error)\n+\tToken(skipSpace bool, f func(rune) bool) (token []byte, err error)\n \t// Width returns the value of the width option and whether it has been set.\n \t// The unit is Unicode code points.\n \tWidth() (wid int, ok bool)\n \t// Because ReadRune is implemented by the interface, Read should never be\n \t// called by the scanning routines and a valid implementation of\n \t// ScanState may choose always to return an error from Read.\n-\tRead(buf []byte) (n int, err os.Error)\n+\tRead(buf []byte) (n int, err error)\n }\n \n // Scanner is implemented by any value that has a Scan method, which scans\n // the input for the representation of a value and stores the result in the\n // receiver, which must be a pointer to be useful.  The Scan method is called\n // for any argument to Scan, Scanf, or Scanln that implements it.\n type Scanner interface {\n-\tScan(state ScanState, verb rune) os.Error\n+\tScan(state ScanState, verb rune) error\n }\n \n // Scan scans text read from standard input, storing successive\n // space-separated values into successive arguments.  Newlines count\n // as space.  It returns the number of items successfully scanned.\n // If that is less than the number of arguments, err will report why.\n-func Scan(a ...interface{}) (n int, err os.Error) {\n+func Scan(a ...interface{}) (n int, err error) {\n \treturn Fscan(os.Stdin, a...)\n }\n \n // Scanln is similar to Scan, but stops scanning at a newline and\n // after the final item there must be a newline or EOF.\n-func Scanln(a ...interface{}) (n int, err os.Error) {\n+func Scanln(a ...interface{}) (n int, err error) {\n \treturn Fscanln(os.Stdin, a...)\n }\n \n // Scanf scans text read from standard input, storing successive\n // space-separated values into successive arguments as determined by\n // the format.  It returns the number of items successfully scanned.\n-func Scanf(format string, a ...interface{}) (n int, err os.Error) {\n+func Scanf(format string, a ...interface{}) (n int, err error) {\n \treturn Fscanf(os.Stdin, format, a...)\n }\n \n // Sscan scans the argument string, storing successive space-separated\n // values into successive arguments.  Newlines count as space.  It\n // returns the number of items successfully scanned.  If that is less\n // than the number of arguments, err will report why.\n-func Sscan(str string, a ...interface{}) (n int, err os.Error) {\n+func Sscan(str string, a ...interface{}) (n int, err error) {\n \treturn Fscan(strings.NewReader(str), a...)\n }\n \n // Sscanln is similar to Sscan, but stops scanning at a newline and\n // after the final item there must be a newline or EOF.\n-func Sscanln(str string, a ...interface{}) (n int, err os.Error) {\n+func Sscanln(str string, a ...interface{}) (n int, err error) {\n \treturn Fscanln(strings.NewReader(str), a...)\n }\n \n // Sscanf scans the argument string, storing successive space-separated\n // values into successive arguments as determined by the format.  It\n // returns the number of items successfully parsed.\n-func Sscanf(str string, format string, a ...interface{}) (n int, err os.Error) {\n+func Sscanf(str string, format string, a ...interface{}) (n int, err error) {\n \treturn Fscanf(strings.NewReader(str), format, a...)\n }\n \n // Fscan scans text read from r, storing successive space-separated\n // values into successive arguments.  Newlines count as space.  It\n // returns the number of items successfully scanned.  If that is less\n // than the number of arguments, err will report why.\n-func Fscan(r io.Reader, a ...interface{}) (n int, err os.Error) {\n+func Fscan(r io.Reader, a ...interface{}) (n int, err error) {\n \ts, old := newScanState(r, true, false)\n \tn, err = s.doScan(a)\n \ts.free(old)\n@@ -120,7 +121,7 @@ func Fscan(r io.Reader, a ...interface{}) (n int, err os.Error) {\n \n // Fscanln is similar to Fscan, but stops scanning at a newline and\n // after the final item there must be a newline or EOF.\n-func Fscanln(r io.Reader, a ...interface{}) (n int, err os.Error) {\n+func Fscanln(r io.Reader, a ...interface{}) (n int, err error) {\n \ts, old := newScanState(r, false, true)\n \tn, err = s.doScan(a)\n \ts.free(old)\n@@ -130,7 +131,7 @@ func Fscanln(r io.Reader, a ...interface{}) (n int, err os.Error) {\n // Fscanf scans text read from r, storing successive space-separated\n // values into successive arguments as determined by the format.  It\n // returns the number of items successfully parsed.\n-func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err os.Error) {\n+func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) {\n \ts, old := newScanState(r, false, false)\n \tn, err = s.doScanf(format, a)\n \ts.free(old)\n@@ -140,7 +141,7 @@ func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err os.Error)\n // scanError represents an error generated by the scanning software.\n // It's used as a unique signature to identify such errors when recovering.\n type scanError struct {\n-\terr os.Error\n+\terr error\n }\n \n const eof = -1\n@@ -170,11 +171,11 @@ type ssave struct {\n // The Read method is only in ScanState so that ScanState\n // satisfies io.Reader. It will never be called when used as\n // intended, so there is no need to make it actually work.\n-func (s *ss) Read(buf []byte) (n int, err os.Error) {\n-\treturn 0, os.NewError(\"ScanState's Read should not be called. Use ReadRune\")\n+func (s *ss) Read(buf []byte) (n int, err error) {\n+\treturn 0, errors.New(\"ScanState's Read should not be called. Use ReadRune\")\n }\n \n-func (s *ss) ReadRune() (r rune, size int, err os.Error) {\n+func (s *ss) ReadRune() (r rune, size int, err error) {\n \tif s.peekRune >= 0 {\n \t\ts.count++\n \t\tr = s.peekRune\n@@ -184,15 +185,15 @@ func (s *ss) ReadRune() (r rune, size int, err os.Error) {\n \t\treturn\n \t}\n \tif s.atEOF || s.nlIsEnd && s.prevRune == '\\n' || s.count >= s.fieldLimit {\n-\t\terr = os.EOF\n+\t\terr = io.EOF\n \t\treturn\n \t}\n \n \tr, size, err = s.rr.ReadRune()\n \tif err == nil {\n \t\ts.count++\n \t\ts.prevRune = r\n-\t} else if err == os.EOF {\n+\t} else if err == io.EOF {\n \t\ts.atEOF = true\n \t}\n \treturn\n@@ -210,7 +211,7 @@ func (s *ss) Width() (wid int, ok bool) {\n func (s *ss) getRune() (r rune) {\n \tr, _, err := s.ReadRune()\n \tif err != nil {\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\treturn eof\n \t\t}\n \t\ts.error(err)\n@@ -229,7 +230,7 @@ func (s *ss) mustReadRune() (r rune) {\n \treturn\n }\n \n-func (s *ss) UnreadRune() os.Error {\n+func (s *ss) UnreadRune() error {\n \tif u, ok := s.rr.(runeUnreader); ok {\n \t\tu.UnreadRune()\n \t} else {\n@@ -240,15 +241,15 @@ func (s *ss) UnreadRune() os.Error {\n \treturn nil\n }\n \n-func (s *ss) error(err os.Error) {\n+func (s *ss) error(err error) {\n \tpanic(scanError{err})\n }\n \n func (s *ss) errorString(err string) {\n-\tpanic(scanError{os.NewError(err)})\n+\tpanic(scanError{errors.New(err)})\n }\n \n-func (s *ss) Token(skipSpace bool, f func(rune) bool) (tok []byte, err os.Error) {\n+func (s *ss) Token(skipSpace bool, f func(rune) bool) (tok []byte, err error) {\n \tdefer func() {\n \t\tif e := recover(); e != nil {\n \t\t\tif se, ok := e.(scanError); ok {\n@@ -289,7 +290,7 @@ type readRune struct {\n \n // readByte returns the next byte from the input, which may be\n // left over from a previous read if the UTF-8 was ill-formed.\n-func (r *readRune) readByte() (b byte, err os.Error) {\n+func (r *readRune) readByte() (b byte, err error) {\n \tif r.pending > 0 {\n \t\tb = r.pendBuf[0]\n \t\tcopy(r.pendBuf[0:], r.pendBuf[1:])\n@@ -308,7 +309,7 @@ func (r *readRune) unread(buf []byte) {\n \n // ReadRune returns the next UTF-8 encoded code point from the\n // io.Reader inside r.\n-func (r *readRune) ReadRune() (rr rune, size int, err os.Error) {\n+func (r *readRune) ReadRune() (rr rune, size int, err error) {\n \tr.buf[0], err = r.readByte()\n \tif err != nil {\n \t\treturn 0, 0, err\n@@ -321,7 +322,7 @@ func (r *readRune) ReadRune() (rr rune, size int, err os.Error) {\n \tfor n = 1; !utf8.FullRune(r.buf[0:n]); n++ {\n \t\tr.buf[n], err = r.readByte()\n \t\tif err != nil {\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\terr = nil\n \t\t\t\tbreak\n \t\t\t}\n@@ -435,8 +436,8 @@ func (s *ss) typeError(field interface{}, expected string) {\n \ts.errorString(\"expected field of type pointer to \" + expected + \"; found \" + reflect.TypeOf(field).String())\n }\n \n-var complexError = os.NewError(\"syntax error scanning complex number\")\n-var boolError = os.NewError(\"syntax error scanning boolean\")\n+var complexError = errors.New(\"syntax error scanning complex number\")\n+var boolError = errors.New(\"syntax error scanning boolean\")\n \n // consume reads the next rune in the input and reports whether it is in the ok string.\n // If accept is true, it puts the character into the input token.\n@@ -469,7 +470,7 @@ func (s *ss) peek(ok string) bool {\n func (s *ss) notEOF() {\n \t// Guarantee there is data to be read.\n \tif r := s.getRune(); r == eof {\n-\t\tpanic(os.EOF)\n+\t\tpanic(io.EOF)\n \t}\n \ts.UnreadRune()\n }\n@@ -874,12 +875,12 @@ const hugeWid = 1 << 30\n // scanOne scans a single value, deriving the scanner from the type of the argument.\n func (s *ss) scanOne(verb rune, field interface{}) {\n \ts.buf.Reset()\n-\tvar err os.Error\n+\tvar err error\n \t// If the parameter has its own Scan method, use that.\n \tif v, ok := field.(Scanner); ok {\n \t\terr = v.Scan(s, verb)\n \t\tif err != nil {\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\terr = io.ErrUnexpectedEOF\n \t\t\t}\n \t\t\ts.error(err)\n@@ -976,11 +977,11 @@ func (s *ss) scanOne(verb rune, field interface{}) {\n }\n \n // errorHandler turns local panics into error returns.\n-func errorHandler(errp *os.Error) {\n+func errorHandler(errp *error) {\n \tif e := recover(); e != nil {\n \t\tif se, ok := e.(scanError); ok { // catch local error\n \t\t\t*errp = se.err\n-\t\t} else if eof, ok := e.(os.Error); ok && eof == os.EOF { // out of input\n+\t\t} else if eof, ok := e.(error); ok && eof == io.EOF { // out of input\n \t\t\t*errp = eof\n \t\t} else {\n \t\t\tpanic(e)\n@@ -989,7 +990,7 @@ func errorHandler(errp *os.Error) {\n }\n \n // doScan does the real work for scanning without a format string.\n-func (s *ss) doScan(a []interface{}) (numProcessed int, err os.Error) {\n+func (s *ss) doScan(a []interface{}) (numProcessed int, err error) {\n \tdefer errorHandler(&err)\n \tfor _, field := range a {\n \t\ts.scanOne('v', field)\n@@ -1061,7 +1062,7 @@ func (s *ss) advance(format string) (i int) {\n \n // doScanf does the real work when scanning with a format string.\n //  At the moment, it handles only pointers to basic types.\n-func (s *ss) doScanf(format string, a []interface{}) (numProcessed int, err os.Error) {\n+func (s *ss) doScanf(format string, a []interface{}) (numProcessed int, err error) {\n \tdefer errorHandler(&err)\n \tend := len(format) - 1\n \t// We process one item per non-trivial format"}, {"sha": "7dd0015b270a1048e8409a525ec7f2398093bb43", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,10 +7,10 @@ package fmt_test\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t\"errors\"\n \t. \"fmt\"\n \t\"io\"\n \t\"math\"\n-\t\"os\"\n \t\"reflect\"\n \t\"regexp\"\n \t\"strings\"\n@@ -87,14 +87,14 @@ type FloatTest struct {\n // Xs accepts any non-empty run of the verb character\n type Xs string\n \n-func (x *Xs) Scan(state ScanState, verb rune) os.Error {\n+func (x *Xs) Scan(state ScanState, verb rune) error {\n \ttok, err := state.Token(true, func(r rune) bool { return r == verb })\n \tif err != nil {\n \t\treturn err\n \t}\n \ts := string(tok)\n \tif !regexp.MustCompile(\"^\" + string(verb) + \"+$\").MatchString(s) {\n-\t\treturn os.NewError(\"syntax error for xs\")\n+\t\treturn errors.New(\"syntax error for xs\")\n \t}\n \t*x = Xs(s)\n \treturn nil\n@@ -109,7 +109,7 @@ type IntString struct {\n \ts string\n }\n \n-func (s *IntString) Scan(state ScanState, verb rune) os.Error {\n+func (s *IntString) Scan(state ScanState, verb rune) error {\n \tif _, err := Fscan(state, &s.i); err != nil {\n \t\treturn err\n \t}\n@@ -130,7 +130,7 @@ type myStringReader struct {\n \tr *strings.Reader\n }\n \n-func (s *myStringReader) Read(p []byte) (n int, err os.Error) {\n+func (s *myStringReader) Read(p []byte) (n int, err error) {\n \treturn s.r.Read(p)\n }\n \n@@ -350,7 +350,7 @@ var multiTests = []ScanfMultiTest{\n \t{\"%c%c%c\", \"\\xc2X\\xc2\", args(&i, &j, &k), args(utf8.RuneError, 'X', utf8.RuneError), \"\"},\n }\n \n-func testScan(name string, t *testing.T, scan func(r io.Reader, a ...interface{}) (int, os.Error)) {\n+func testScan(name string, t *testing.T, scan func(r io.Reader, a ...interface{}) (int, error)) {\n \tfor _, test := range scanTests {\n \t\tvar r io.Reader\n \t\tif name == \"StringReader\" {\n@@ -431,7 +431,7 @@ func TestScanOverflow(t *testing.T) {\n \t\t\tt.Errorf(\"expected overflow scanning %q\", test.text)\n \t\t\tcontinue\n \t\t}\n-\t\tif !re.MatchString(err.String()) {\n+\t\tif !re.MatchString(err.Error()) {\n \t\t\tt.Errorf(\"expected overflow error scanning %q: %s\", test.text, err)\n \t\t}\n \t}\n@@ -500,7 +500,7 @@ func testScanfMulti(name string, t *testing.T) {\n \t\tif err != nil {\n \t\t\tif test.err == \"\" {\n \t\t\t\tt.Errorf(\"got error scanning (%q, %q): %q\", test.format, test.text, err)\n-\t\t\t} else if strings.Index(err.String(), test.err) < 0 {\n+\t\t\t} else if strings.Index(err.Error(), test.err) < 0 {\n \t\t\t\tt.Errorf(\"got wrong error scanning (%q, %q): %q; expected %q\", test.format, test.text, err, test.err)\n \t\t\t}\n \t\t\tcontinue\n@@ -594,7 +594,7 @@ func TestScanNotPointer(t *testing.T) {\n \t_, err := Fscan(r, a)\n \tif err == nil {\n \t\tt.Error(\"expected error scanning non-pointer\")\n-\t} else if strings.Index(err.String(), \"pointer\") < 0 {\n+\t} else if strings.Index(err.Error(), \"pointer\") < 0 {\n \t\tt.Errorf(\"expected pointer error scanning non-pointer, got: %s\", err)\n \t}\n }\n@@ -604,7 +604,7 @@ func TestScanlnNoNewline(t *testing.T) {\n \t_, err := Sscanln(\"1 x\\n\", &a)\n \tif err == nil {\n \t\tt.Error(\"expected error scanning string missing newline\")\n-\t} else if strings.Index(err.String(), \"newline\") < 0 {\n+\t} else if strings.Index(err.Error(), \"newline\") < 0 {\n \t\tt.Errorf(\"expected newline error scanning string missing newline, got: %s\", err)\n \t}\n }\n@@ -615,7 +615,7 @@ func TestScanlnWithMiddleNewline(t *testing.T) {\n \t_, err := Fscanln(r, &a, &b)\n \tif err == nil {\n \t\tt.Error(\"expected error scanning string with extra newline\")\n-\t} else if strings.Index(err.String(), \"newline\") < 0 {\n+\t} else if strings.Index(err.Error(), \"newline\") < 0 {\n \t\tt.Errorf(\"expected newline error scanning string with extra newline, got: %s\", err)\n \t}\n }\n@@ -626,7 +626,7 @@ type eofCounter struct {\n \teofCount int\n }\n \n-func (ec *eofCounter) Read(b []byte) (n int, err os.Error) {\n+func (ec *eofCounter) Read(b []byte) (n int, err error) {\n \tn, err = ec.reader.Read(b)\n \tif n == 0 {\n \t\tec.eofCount++\n@@ -670,22 +670,22 @@ func TestEOFAtEndOfInput(t *testing.T) {\n \tif n != 1 || i != 23 {\n \t\tt.Errorf(\"Sscanf expected one value of 23; got %d %d\", n, i)\n \t}\n-\tif err != os.EOF {\n+\tif err != io.EOF {\n \t\tt.Errorf(\"Sscanf expected EOF; got %q\", err)\n \t}\n \tn, err = Sscan(\"234\", &i, &j)\n \tif n != 1 || i != 234 {\n \t\tt.Errorf(\"Sscan expected one value of 234; got %d %d\", n, i)\n \t}\n-\tif err != os.EOF {\n+\tif err != io.EOF {\n \t\tt.Errorf(\"Sscan expected EOF; got %q\", err)\n \t}\n \t// Trailing space is tougher.\n \tn, err = Sscan(\"234 \", &i, &j)\n \tif n != 1 || i != 234 {\n \t\tt.Errorf(\"Sscan expected one value of 234; got %d %d\", n, i)\n \t}\n-\tif err != os.EOF {\n+\tif err != io.EOF {\n \t\tt.Errorf(\"Sscan expected EOF; got %q\", err)\n \t}\n }\n@@ -715,10 +715,10 @@ var eofTests = []struct {\n \n func TestEOFAllTypes(t *testing.T) {\n \tfor i, test := range eofTests {\n-\t\tif _, err := Sscanf(\"\", test.format, test.v); err != os.EOF {\n+\t\tif _, err := Sscanf(\"\", test.format, test.v); err != io.EOF {\n \t\t\tt.Errorf(\"#%d: %s %T not eof on empty string: %s\", i, test.format, test.v, err)\n \t\t}\n-\t\tif _, err := Sscanf(\"   \", test.format, test.v); err != os.EOF {\n+\t\tif _, err := Sscanf(\"   \", test.format, test.v); err != io.EOF {\n \t\t\tt.Errorf(\"#%d: %s %T not eof on trailing blanks: %s\", i, test.format, test.v, err)\n \t\t}\n \t}\n@@ -749,7 +749,7 @@ type TwoLines string\n \n // Attempt to read two lines into the object.  Scanln should prevent this\n // because it stops at newline; Scan and Scanf should be fine.\n-func (t *TwoLines) Scan(state ScanState, verb rune) os.Error {\n+func (t *TwoLines) Scan(state ScanState, verb rune) error {\n \tchars := make([]rune, 0, 100)\n \tfor nlCount := 0; nlCount < 2; {\n \t\tc, _, err := state.ReadRune()\n@@ -812,15 +812,15 @@ type RecursiveInt struct {\n \tnext *RecursiveInt\n }\n \n-func (r *RecursiveInt) Scan(state ScanState, verb rune) (err os.Error) {\n+func (r *RecursiveInt) Scan(state ScanState, verb rune) (err error) {\n \t_, err = Fscan(state, &r.i)\n \tif err != nil {\n \t\treturn\n \t}\n \tnext := new(RecursiveInt)\n \t_, err = Fscanf(state, \".%v\", next)\n \tif err != nil {\n-\t\tif err == os.NewError(\"input does not match format\") || err == io.ErrUnexpectedEOF {\n+\t\tif err == errors.New(\"input does not match format\") || err == io.ErrUnexpectedEOF {\n \t\t\terr = nil\n \t\t}\n \t\treturn\n@@ -832,15 +832,15 @@ func (r *RecursiveInt) Scan(state ScanState, verb rune) (err os.Error) {\n // Perform the same scanning task as RecursiveInt.Scan\n // but without recurring through scanner, so we can compare\n // performance more directly.\n-func scanInts(r *RecursiveInt, b *bytes.Buffer) (err os.Error) {\n+func scanInts(r *RecursiveInt, b *bytes.Buffer) (err error) {\n \tr.next = nil\n \t_, err = Fscan(b, &r.i)\n \tif err != nil {\n \t\treturn\n \t}\n \tc, _, err := b.ReadRune()\n \tif err != nil {\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\terr = nil\n \t\t}\n \t\treturn\n@@ -867,7 +867,7 @@ func makeInts(n int) []byte {\n \n func TestScanInts(t *testing.T) {\n \ttestScanInts(t, scanInts)\n-\ttestScanInts(t, func(r *RecursiveInt, b *bytes.Buffer) (err os.Error) {\n+\ttestScanInts(t, func(r *RecursiveInt, b *bytes.Buffer) (err error) {\n \t\t_, err = Fscan(b, r)\n \t\treturn\n \t})\n@@ -877,7 +877,7 @@ func TestScanInts(t *testing.T) {\n // platform that does not support split stack.\n const intCount = 800\n \n-func testScanInts(t *testing.T, scan func(*RecursiveInt, *bytes.Buffer) os.Error) {\n+func testScanInts(t *testing.T, scan func(*RecursiveInt, *bytes.Buffer) error) {\n \tr := new(RecursiveInt)\n \tints := makeInts(intCount)\n \tbuf := bytes.NewBuffer(ints)"}, {"sha": "fb3068e1e937af928cb9e704b100acb46096f801", "filename": "libgo/go/go/ast/print.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -36,7 +36,7 @@ func NotNilFilter(_ string, v reflect.Value) bool {\n // struct fields for which f(fieldname, fieldvalue) is true are\n // are printed; all others are filtered from the output.\n //\n-func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (n int, err os.Error) {\n+func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (n int, err error) {\n \t// setup printer\n \tp := printer{\n \t\toutput: w,\n@@ -67,7 +67,7 @@ func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (n i\n \n // Print prints x to standard output, skipping nil fields.\n // Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).\n-func Print(fset *token.FileSet, x interface{}) (int, os.Error) {\n+func Print(fset *token.FileSet, x interface{}) (int, error) {\n \treturn Fprint(os.Stdout, fset, x, NotNilFilter)\n }\n \n@@ -84,7 +84,7 @@ type printer struct {\n \n var indent = []byte(\".  \")\n \n-func (p *printer) Write(data []byte) (n int, err os.Error) {\n+func (p *printer) Write(data []byte) (n int, err error) {\n \tvar m int\n \tfor i, b := range data {\n \t\t// invariant: data[0:n] has been written\n@@ -114,10 +114,10 @@ func (p *printer) Write(data []byte) (n int, err os.Error) {\n \treturn\n }\n \n-// localError wraps locally caught os.Errors so we can distinguish\n+// localError wraps locally caught errors so we can distinguish\n // them from genuine panics which we don't want to return as errors.\n type localError struct {\n-\terr os.Error\n+\terr error\n }\n \n // printf is a convenience wrapper that takes care of print errors."}, {"sha": "b24688d2ea3960d390f951f8ade2d4d1aaab2937", "filename": "libgo/go/go/ast/resolve.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,7 +10,6 @@ import (\n \t\"fmt\"\n \t\"go/scanner\"\n \t\"go/token\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -61,7 +60,7 @@ func resolve(scope *Scope, ident *Ident) bool {\n // Importer should load the package data for the given path into \n // a new *Object (pkg), record pkg in the imports map, and then\n // return pkg.\n-type Importer func(imports map[string]*Object, path string) (pkg *Object, err os.Error)\n+type Importer func(imports map[string]*Object, path string) (pkg *Object, err error)\n \n // NewPackage creates a new Package node from a set of File nodes. It resolves\n // unresolved identifiers across files and updates each file's Unresolved list\n@@ -72,7 +71,7 @@ type Importer func(imports map[string]*Object, path string) (pkg *Object, err os\n // different package names are reported and then ignored.\n // The result is a package node and a scanner.ErrorList if there were errors.\n //\n-func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, os.Error) {\n+func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error) {\n \tvar p pkgBuilder\n \tp.fset = fset\n "}, {"sha": "282a508b3b0085327d414f4b8e83a2fd0738d72a", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,6 +7,7 @@ package build\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"exec\"\n \t\"fmt\"\n \t\"os\"\n@@ -17,7 +18,7 @@ import (\n )\n \n // Build produces a build Script for the given package.\n-func Build(tree *Tree, pkg string, info *DirInfo) (*Script, os.Error) {\n+func Build(tree *Tree, pkg string, info *DirInfo) (*Script, error) {\n \ts := &Script{}\n \tb := &build{\n \t\tscript: s,\n@@ -29,7 +30,7 @@ func Build(tree *Tree, pkg string, info *DirInfo) (*Script, os.Error) {\n \tif g := os.Getenv(\"GOARCH\"); g != \"\" {\n \t\tb.goarch = g\n \t}\n-\tvar err os.Error\n+\tvar err error\n \tb.arch, err = ArchChar(b.goarch)\n \tif err != nil {\n \t\treturn nil, err\n@@ -42,7 +43,7 @@ func Build(tree *Tree, pkg string, info *DirInfo) (*Script, os.Error) {\n \t\t\t// FindTree should always be able to suggest an import\n \t\t\t// path and tree. The path must be malformed\n \t\t\t// (for example, an absolute or relative path).\n-\t\t\treturn nil, os.NewError(\"build: invalid import: \" + pkg)\n+\t\t\treturn nil, errors.New(\"build: invalid import: \" + pkg)\n \t\t}\n \t\ts.addInput(filepath.Join(t.PkgDir(), p+\".a\"))\n \t}\n@@ -89,7 +90,7 @@ func Build(tree *Tree, pkg string, info *DirInfo) (*Script, os.Error) {\n \t}\n \n \tif len(ofiles) == 0 {\n-\t\treturn nil, os.NewError(\"make: no object files to build\")\n+\t\treturn nil, errors.New(\"make: no object files to build\")\n \t}\n \n \t// choose target file\n@@ -138,7 +139,7 @@ func (s *Script) addIntermediate(file ...string) {\n }\n \n // Run runs the Script's Cmds in order.\n-func (s *Script) Run() os.Error {\n+func (s *Script) Run() error {\n \tfor _, c := range s.Cmd {\n \t\tif err := c.Run(); err != nil {\n \t\t\treturn err\n@@ -174,7 +175,7 @@ func (s *Script) Stale() bool {\n \n // Clean removes the Script's Intermediate files.\n // It tries to remove every file and returns the first error it encounters.\n-func (s *Script) Clean() (err os.Error) {\n+func (s *Script) Clean() (err error) {\n \t// Reverse order so that directories get removed after the files they contain.\n \tfor i := len(s.Intermediate) - 1; i >= 0; i-- {\n \t\tif e := os.Remove(s.Intermediate[i]); err == nil {\n@@ -186,7 +187,7 @@ func (s *Script) Clean() (err os.Error) {\n \n // Nuke removes the Script's Intermediate and Output files.\n // It tries to remove every file and returns the first error it encounters.\n-func (s *Script) Nuke() (err os.Error) {\n+func (s *Script) Nuke() (err error) {\n \t// Reverse order so that directories get removed after the files they contain.\n \tfor i := len(s.Output) - 1; i >= 0; i-- {\n \t\tif e := os.Remove(s.Output[i]); err == nil {\n@@ -214,7 +215,7 @@ func (c *Cmd) String() string {\n }\n \n // Run executes the Cmd.\n-func (c *Cmd) Run() os.Error {\n+func (c *Cmd) Run() error {\n \tif c.Args[0] == \"mkdir\" {\n \t\tfor _, p := range c.Output {\n \t\t\tif err := os.MkdirAll(p, 0777); err != nil {\n@@ -245,7 +246,7 @@ func (c *Cmd) Run() os.Error {\n \n // ArchChar returns the architecture character for the given goarch.\n // For example, ArchChar(\"amd64\") returns \"6\".\n-func ArchChar(goarch string) (string, os.Error) {\n+func ArchChar(goarch string) (string, error) {\n \tswitch goarch {\n \tcase \"386\":\n \t\treturn \"8\", nil\n@@ -254,7 +255,7 @@ func ArchChar(goarch string) (string, os.Error) {\n \tcase \"arm\":\n \t\treturn \"5\", nil\n \t}\n-\treturn \"\", os.NewError(\"unsupported GOARCH \" + goarch)\n+\treturn \"\", errors.New(\"unsupported GOARCH \" + goarch)\n }\n \n type build struct {"}, {"sha": "0d175c75deb456b089755f18bd9a35a7bad9ae9a", "filename": "libgo/go/go/build/dir.go", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,6 +6,7 @@ package build\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"go/ast\"\n \t\"go/doc\"\n@@ -41,7 +42,7 @@ type Context struct {\n \t// describing the content of the named directory.\n \t// The dir argument is the argument to ScanDir.\n \t// If ReadDir is nil, ScanDir uses io.ReadDir.\n-\tReadDir func(dir string) (fi []*os.FileInfo, err os.Error)\n+\tReadDir func(dir string) (fi []*os.FileInfo, err error)\n \n \t// ReadFile returns the content of the file named file\n \t// in the directory named dir.  The dir argument is the\n@@ -52,17 +53,17 @@ type Context struct {\n \t//\n \t// If ReadFile is nil, ScanDir uses filepath.Join(dir, file)\n \t// as the path and ioutil.ReadFile to read the data.\n-\tReadFile func(dir, file string) (path string, content []byte, err os.Error)\n+\tReadFile func(dir, file string) (path string, content []byte, err error)\n }\n \n-func (ctxt *Context) readDir(dir string) ([]*os.FileInfo, os.Error) {\n+func (ctxt *Context) readDir(dir string) ([]*os.FileInfo, error) {\n \tif f := ctxt.ReadDir; f != nil {\n \t\treturn f(dir)\n \t}\n \treturn ioutil.ReadDir(dir)\n }\n \n-func (ctxt *Context) readFile(dir, file string) (string, []byte, os.Error) {\n+func (ctxt *Context) readFile(dir, file string) (string, []byte, error) {\n \tif f := ctxt.ReadFile; f != nil {\n \t\treturn f(dir, file)\n \t}\n@@ -116,7 +117,7 @@ func (d *DirInfo) IsCommand() bool {\n }\n \n // ScanDir calls DefaultContext.ScanDir.\n-func ScanDir(dir string) (info *DirInfo, err os.Error) {\n+func ScanDir(dir string) (info *DirInfo, err error) {\n \treturn DefaultContext.ScanDir(dir)\n }\n \n@@ -128,7 +129,7 @@ func ScanDir(dir string) (info *DirInfo, err os.Error) {\n //\t- files ending in _test.go\n //\t- files starting with _ or .\n //\n-func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err os.Error) {\n+func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \tdirs, err := ctxt.readDir(dir)\n \tif err != nil {\n \t\treturn nil, err\n@@ -364,7 +365,7 @@ func (ctxt *Context) shouldBuild(content []byte) bool {\n //\n // TODO(rsc): This duplicates code in cgo.\n // Once the dust settles, remove this code from cgo.\n-func (ctxt *Context) saveCgo(filename string, di *DirInfo, cg *ast.CommentGroup) os.Error {\n+func (ctxt *Context) saveCgo(filename string, di *DirInfo, cg *ast.CommentGroup) error {\n \ttext := doc.CommentText(cg)\n \tfor _, line := range strings.Split(text, \"\\n\") {\n \t\torig := line\n@@ -459,7 +460,7 @@ func safeName(s string) bool {\n //\n //     []string{\"a\", \"b:c d\", \"ef\", `g\"`}\n //\n-func splitQuoted(s string) (r []string, err os.Error) {\n+func splitQuoted(s string) (r []string, err error) {\n \tvar args []string\n \targ := make([]rune, len(s))\n \tescaped := false\n@@ -497,9 +498,9 @@ func splitQuoted(s string) (r []string, err os.Error) {\n \t\targs = append(args, string(arg[:i]))\n \t}\n \tif quote != 0 {\n-\t\terr = os.NewError(\"unclosed quote\")\n+\t\terr = errors.New(\"unclosed quote\")\n \t} else if escaped {\n-\t\terr = os.NewError(\"unfinished escaping\")\n+\t\terr = errors.New(\"unfinished escaping\")\n \t}\n \treturn args, err\n }"}, {"sha": "7ccb12993b306d1810d0807ec23d3fd5a1bb6389", "filename": "libgo/go/go/build/path.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,6 +5,7 @@\n package build\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"log\"\n \t\"os\"\n@@ -21,9 +22,9 @@ type Tree struct {\n \tGoroot bool\n }\n \n-func newTree(p string) (*Tree, os.Error) {\n+func newTree(p string) (*Tree, error) {\n \tif !filepath.IsAbs(p) {\n-\t\treturn nil, os.NewError(\"must be absolute\")\n+\t\treturn nil, errors.New(\"must be absolute\")\n \t}\n \tep, err := filepath.EvalSymlinks(p)\n \tif err != nil {\n@@ -84,13 +85,13 @@ func (t *Tree) HasPkg(pkg string) bool {\n }\n \n var (\n-\tErrNotFound     = os.NewError(\"go/build: package could not be found locally\")\n-\tErrTreeNotFound = os.NewError(\"go/build: no valid GOROOT or GOPATH could be found\")\n+\tErrNotFound     = errors.New(\"go/build: package could not be found locally\")\n+\tErrTreeNotFound = errors.New(\"go/build: no valid GOROOT or GOPATH could be found\")\n )\n \n // FindTree takes an import or filesystem path and returns the\n // tree where the package source should be and the package import path.\n-func FindTree(path string) (tree *Tree, pkg string, err os.Error) {\n+func FindTree(path string) (tree *Tree, pkg string, err error) {\n \tif isLocalPath(path) {\n \t\tif path, err = filepath.Abs(path); err != nil {\n \t\t\treturn"}, {"sha": "d3bab31c5a3aac16a4e0e62bf2409a942ca01e21", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,6 +8,7 @@ package parser\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"go/ast\"\n \t\"go/scanner\"\n \t\"go/token\"\n@@ -21,7 +22,7 @@ import (\n // otherwise it returns an error. If src == nil, readSource returns\n // the result of reading the file specified by filename.\n //\n-func readSource(filename string, src interface{}) ([]byte, os.Error) {\n+func readSource(filename string, src interface{}) ([]byte, error) {\n \tif src != nil {\n \t\tswitch s := src.(type) {\n \t\tcase string:\n@@ -41,14 +42,14 @@ func readSource(filename string, src interface{}) ([]byte, os.Error) {\n \t\t\t}\n \t\t\treturn buf.Bytes(), nil\n \t\tdefault:\n-\t\t\treturn nil, os.NewError(\"invalid source\")\n+\t\t\treturn nil, errors.New(\"invalid source\")\n \t\t}\n \t}\n \n \treturn ioutil.ReadFile(filename)\n }\n \n-func (p *parser) errors() os.Error {\n+func (p *parser) errors() error {\n \tmode := scanner.Sorted\n \tif p.mode&SpuriousErrors == 0 {\n \t\tmode = scanner.NoMultiples\n@@ -61,7 +62,7 @@ func (p *parser) errors() os.Error {\n // as for ParseFile. If there is an error, the result expression\n // may be nil or contain a partial AST.\n //\n-func ParseExpr(fset *token.FileSet, filename string, src interface{}) (ast.Expr, os.Error) {\n+func ParseExpr(fset *token.FileSet, filename string, src interface{}) (ast.Expr, error) {\n \tdata, err := readSource(filename, src)\n \tif err != nil {\n \t\treturn nil, err\n@@ -83,7 +84,7 @@ func ParseExpr(fset *token.FileSet, filename string, src interface{}) (ast.Expr,\n // interpretation as for ParseFile. If there is an error, the node\n // list may be nil or contain partial ASTs.\n //\n-func ParseStmtList(fset *token.FileSet, filename string, src interface{}) ([]ast.Stmt, os.Error) {\n+func ParseStmtList(fset *token.FileSet, filename string, src interface{}) ([]ast.Stmt, error) {\n \tdata, err := readSource(filename, src)\n \tif err != nil {\n \t\treturn nil, err\n@@ -102,7 +103,7 @@ func ParseStmtList(fset *token.FileSet, filename string, src interface{}) ([]ast\n // interpretation as for ParseFile. If there is an error, the node\n // list may be nil or contain partial ASTs.\n //\n-func ParseDeclList(fset *token.FileSet, filename string, src interface{}) ([]ast.Decl, os.Error) {\n+func ParseDeclList(fset *token.FileSet, filename string, src interface{}) ([]ast.Decl, error) {\n \tdata, err := readSource(filename, src)\n \tif err != nil {\n \t\treturn nil, err\n@@ -136,7 +137,7 @@ func ParseDeclList(fset *token.FileSet, filename string, src interface{}) ([]ast\n // representing the fragments of erroneous source code). Multiple errors\n // are returned via a scanner.ErrorList which is sorted by file position.\n //\n-func ParseFile(fset *token.FileSet, filename string, src interface{}, mode uint) (*ast.File, os.Error) {\n+func ParseFile(fset *token.FileSet, filename string, src interface{}, mode uint) (*ast.File, error) {\n \tdata, err := readSource(filename, src)\n \tif err != nil {\n \t\treturn nil, err\n@@ -158,7 +159,7 @@ func ParseFile(fset *token.FileSet, filename string, src interface{}, mode uint)\n // be incomplete (missing packages and/or incomplete packages) and the first\n // error encountered is returned.\n //\n-func ParseFiles(fset *token.FileSet, filenames []string, mode uint) (pkgs map[string]*ast.Package, first os.Error) {\n+func ParseFiles(fset *token.FileSet, filenames []string, mode uint) (pkgs map[string]*ast.Package, first error) {\n \tpkgs = make(map[string]*ast.Package)\n \tfor _, filename := range filenames {\n \t\tif src, err := ParseFile(fset, filename, nil, mode); err == nil {\n@@ -187,7 +188,7 @@ func ParseFiles(fset *token.FileSet, filenames []string, mode uint) (pkgs map[st\n // returned. If a parse error occurred, a non-nil but incomplete map and the\n // error are returned.\n //\n-func ParseDir(fset *token.FileSet, path string, filter func(*os.FileInfo) bool, mode uint) (map[string]*ast.Package, os.Error) {\n+func ParseDir(fset *token.FileSet, path string, filter func(*os.FileInfo) bool, mode uint) (map[string]*ast.Package, error) {\n \tfd, err := os.Open(path)\n \tif err != nil {\n \t\treturn nil, err"}, {"sha": "8f1ed1159dfb7a8ae2f580f1b5db977e9a828801", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -54,10 +54,10 @@ const (\n \tnoExtraLinebreak\n )\n \n-// local error wrapper so we can distinguish os.Errors we want to return\n+// local error wrapper so we can distinguish errors we want to return\n // as errors from genuine panics (which we don't want to return as errors)\n type osError struct {\n-\terr os.Error\n+\terr error\n }\n \n type printer struct {\n@@ -837,7 +837,7 @@ const (\n //              However, this would mess up any formatting done by\n //              the tabwriter.\n \n-func (p *trimmer) Write(data []byte) (n int, err os.Error) {\n+func (p *trimmer) Write(data []byte) (n int, err error) {\n \t// invariants:\n \t// p.state == inSpace:\n \t//\tp.space is unwritten\n@@ -925,7 +925,7 @@ type Config struct {\n }\n \n // fprint implements Fprint and takes a nodesSizes map for setting up the printer state.\n-func (cfg *Config) fprint(output io.Writer, fset *token.FileSet, node interface{}, nodeSizes map[ast.Node]int) (written int, err os.Error) {\n+func (cfg *Config) fprint(output io.Writer, fset *token.FileSet, node interface{}, nodeSizes map[ast.Node]int) (written int, err error) {\n \t// redirect output through a trimmer to eliminate trailing whitespace\n \t// (Input to a tabwriter must be untrimmed since trailing tabs provide\n \t// formatting information. The tabwriter could provide trimming\n@@ -1004,14 +1004,14 @@ func (cfg *Config) fprint(output io.Writer, fset *token.FileSet, node interface{\n // The node type must be *ast.File, or assignment-compatible to ast.Expr,\n // ast.Decl, ast.Spec, or ast.Stmt.\n //\n-func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{}) (int, os.Error) {\n+func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{}) (int, error) {\n \treturn cfg.fprint(output, fset, node, make(map[ast.Node]int))\n }\n \n // Fprint \"pretty-prints\" an AST node to output.\n // It calls Config.Fprint with default settings.\n //\n-func Fprint(output io.Writer, fset *token.FileSet, node interface{}) os.Error {\n+func Fprint(output io.Writer, fset *token.FileSet, node interface{}) error {\n \t_, err := (&Config{Tabwidth: 8}).Fprint(output, fset, node) // don't care about number of bytes written\n \treturn err\n }"}, {"sha": "cd9620b878b78f5814103399099df567655108ac", "filename": "libgo/go/go/scanner/errors.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"fmt\"\n \t\"go/token\"\n \t\"io\"\n-\t\"os\"\n \t\"sort\"\n )\n \n@@ -49,7 +48,7 @@ type Error struct {\n \tMsg string\n }\n \n-func (e *Error) String() string {\n+func (e *Error) Error() string {\n \tif e.Pos.Filename != \"\" || e.Pos.IsValid() {\n \t\t// don't print \"<unknown position>\"\n \t\t// TODO(gri) reconsider the semantics of Position.IsValid\n@@ -85,12 +84,12 @@ func (p ErrorList) Less(i, j int) bool {\n \treturn false\n }\n \n-func (p ErrorList) String() string {\n+func (p ErrorList) Error() string {\n \tswitch len(p) {\n \tcase 0:\n \t\treturn \"unspecified error\"\n \tcase 1:\n-\t\treturn p[0].String()\n+\t\treturn p[0].Error()\n \t}\n \treturn fmt.Sprintf(\"%s (and %d more errors)\", p[0], len(p)-1)\n }\n@@ -136,11 +135,11 @@ func (h *ErrorVector) GetErrorList(mode int) ErrorList {\n \treturn list\n }\n \n-// GetError is like GetErrorList, but it returns an os.Error instead\n-// so that a nil result can be assigned to an os.Error variable and\n+// GetError is like GetErrorList, but it returns an error instead\n+// so that a nil result can be assigned to an error variable and\n // remains nil.\n //\n-func (h *ErrorVector) GetError(mode int) os.Error {\n+func (h *ErrorVector) GetError(mode int) error {\n \tif len(h.errors) == 0 {\n \t\treturn nil\n \t}\n@@ -157,7 +156,7 @@ func (h *ErrorVector) Error(pos token.Position, msg string) {\n // one error per line, if the err parameter is an ErrorList. Otherwise\n // it prints the err string.\n //\n-func PrintError(w io.Writer, err os.Error) {\n+func PrintError(w io.Writer, err error) {\n \tif list, ok := err.(ErrorList); ok {\n \t\tfor _, e := range list {\n \t\t\tfmt.Fprintf(w, \"%s\\n\", e)"}, {"sha": "611b1b3be9dab5c602bc8deeae0af0acde9cc79f", "filename": "libgo/go/go/token/serialize.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package token\n import (\n \t\"gob\"\n \t\"io\"\n-\t\"os\"\n )\n \n type serializedFile struct {\n@@ -24,17 +23,17 @@ type serializedFileSet struct {\n \tFiles []serializedFile\n }\n \n-func (s *serializedFileSet) Read(r io.Reader) os.Error {\n+func (s *serializedFileSet) Read(r io.Reader) error {\n \treturn gob.NewDecoder(r).Decode(s)\n }\n \n-func (s *serializedFileSet) Write(w io.Writer) os.Error {\n+func (s *serializedFileSet) Write(w io.Writer) error {\n \treturn gob.NewEncoder(w).Encode(s)\n }\n \n // Read reads the fileset from r into s; s must not be nil.\n // If r does not also implement io.ByteReader, it will be wrapped in a bufio.Reader.\n-func (s *FileSet) Read(r io.Reader) os.Error {\n+func (s *FileSet) Read(r io.Reader) error {\n \tvar ss serializedFileSet\n \tif err := ss.Read(r); err != nil {\n \t\treturn err\n@@ -55,7 +54,7 @@ func (s *FileSet) Read(r io.Reader) os.Error {\n }\n \n // Write writes the fileset s to w.\n-func (s *FileSet) Write(w io.Writer) os.Error {\n+func (s *FileSet) Write(w io.Writer) error {\n \tvar ss serializedFileSet\n \n \ts.mutex.Lock()"}, {"sha": "a8ce30ab2f380a986a994f61d57164e9d4fed5ac", "filename": "libgo/go/go/token/serialize_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,13 +7,12 @@ package token\n import (\n \t\"bytes\"\n \t\"fmt\"\n-\t\"os\"\n \t\"testing\"\n )\n \n // equal returns nil if p and q describe the same file set;\n // otherwise it returns an error describing the discrepancy.\n-func equal(p, q *FileSet) os.Error {\n+func equal(p, q *FileSet) error {\n \tif p == q {\n \t\t// avoid deadlock if p == q\n \t\treturn nil"}, {"sha": "dc0e0078e6810d1201e21722712fdaffd7d9ad76", "filename": "libgo/go/gob/codec_test.go", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fcodec_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,8 +6,8 @@ package gob\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"math\"\n-\t\"os\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n@@ -330,7 +330,7 @@ func newDecodeStateFromData(data []byte) *decoderState {\n // Test instruction execution for decoding.\n // Do not run the machine yet; instead do individual instructions crafted by hand.\n func TestScalarDecInstructions(t *testing.T) {\n-\tovfl := os.NewError(\"overflow\")\n+\tovfl := errors.New(\"overflow\")\n \n \t// bool\n \t{\n@@ -633,7 +633,7 @@ func TestOverflow(t *testing.T) {\n \t\tMinc complex128\n \t}\n \tvar it inputT\n-\tvar err os.Error\n+\tvar err error\n \tb := new(bytes.Buffer)\n \tenc := NewEncoder(b)\n \tdec := NewDecoder(b)\n@@ -650,7 +650,7 @@ func TestOverflow(t *testing.T) {\n \tvar o1 outi8\n \tenc.Encode(it)\n \terr = dec.Decode(&o1)\n-\tif err == nil || err.String() != `value for \"Maxi\" out of range` {\n+\tif err == nil || err.Error() != `value for \"Maxi\" out of range` {\n \t\tt.Error(\"wrong overflow error for int8:\", err)\n \t}\n \tit = inputT{\n@@ -659,7 +659,7 @@ func TestOverflow(t *testing.T) {\n \tb.Reset()\n \tenc.Encode(it)\n \terr = dec.Decode(&o1)\n-\tif err == nil || err.String() != `value for \"Mini\" out of range` {\n+\tif err == nil || err.Error() != `value for \"Mini\" out of range` {\n \t\tt.Error(\"wrong underflow error for int8:\", err)\n \t}\n \n@@ -675,7 +675,7 @@ func TestOverflow(t *testing.T) {\n \tvar o2 outi16\n \tenc.Encode(it)\n \terr = dec.Decode(&o2)\n-\tif err == nil || err.String() != `value for \"Maxi\" out of range` {\n+\tif err == nil || err.Error() != `value for \"Maxi\" out of range` {\n \t\tt.Error(\"wrong overflow error for int16:\", err)\n \t}\n \tit = inputT{\n@@ -684,7 +684,7 @@ func TestOverflow(t *testing.T) {\n \tb.Reset()\n \tenc.Encode(it)\n \terr = dec.Decode(&o2)\n-\tif err == nil || err.String() != `value for \"Mini\" out of range` {\n+\tif err == nil || err.Error() != `value for \"Mini\" out of range` {\n \t\tt.Error(\"wrong underflow error for int16:\", err)\n \t}\n \n@@ -700,7 +700,7 @@ func TestOverflow(t *testing.T) {\n \tvar o3 outi32\n \tenc.Encode(it)\n \terr = dec.Decode(&o3)\n-\tif err == nil || err.String() != `value for \"Maxi\" out of range` {\n+\tif err == nil || err.Error() != `value for \"Maxi\" out of range` {\n \t\tt.Error(\"wrong overflow error for int32:\", err)\n \t}\n \tit = inputT{\n@@ -709,7 +709,7 @@ func TestOverflow(t *testing.T) {\n \tb.Reset()\n \tenc.Encode(it)\n \terr = dec.Decode(&o3)\n-\tif err == nil || err.String() != `value for \"Mini\" out of range` {\n+\tif err == nil || err.Error() != `value for \"Mini\" out of range` {\n \t\tt.Error(\"wrong underflow error for int32:\", err)\n \t}\n \n@@ -724,7 +724,7 @@ func TestOverflow(t *testing.T) {\n \tvar o4 outu8\n \tenc.Encode(it)\n \terr = dec.Decode(&o4)\n-\tif err == nil || err.String() != `value for \"Maxu\" out of range` {\n+\tif err == nil || err.Error() != `value for \"Maxu\" out of range` {\n \t\tt.Error(\"wrong overflow error for uint8:\", err)\n \t}\n \n@@ -739,7 +739,7 @@ func TestOverflow(t *testing.T) {\n \tvar o5 outu16\n \tenc.Encode(it)\n \terr = dec.Decode(&o5)\n-\tif err == nil || err.String() != `value for \"Maxu\" out of range` {\n+\tif err == nil || err.Error() != `value for \"Maxu\" out of range` {\n \t\tt.Error(\"wrong overflow error for uint16:\", err)\n \t}\n \n@@ -754,7 +754,7 @@ func TestOverflow(t *testing.T) {\n \tvar o6 outu32\n \tenc.Encode(it)\n \terr = dec.Decode(&o6)\n-\tif err == nil || err.String() != `value for \"Maxu\" out of range` {\n+\tif err == nil || err.Error() != `value for \"Maxu\" out of range` {\n \t\tt.Error(\"wrong overflow error for uint32:\", err)\n \t}\n \n@@ -770,7 +770,7 @@ func TestOverflow(t *testing.T) {\n \tvar o7 outf32\n \tenc.Encode(it)\n \terr = dec.Decode(&o7)\n-\tif err == nil || err.String() != `value for \"Maxf\" out of range` {\n+\tif err == nil || err.Error() != `value for \"Maxf\" out of range` {\n \t\tt.Error(\"wrong overflow error for float32:\", err)\n \t}\n \n@@ -786,7 +786,7 @@ func TestOverflow(t *testing.T) {\n \tvar o8 outc64\n \tenc.Encode(it)\n \terr = dec.Decode(&o8)\n-\tif err == nil || err.String() != `value for \"Maxc\" out of range` {\n+\tif err == nil || err.Error() != `value for \"Maxc\" out of range` {\n \t\tt.Error(\"wrong overflow error for complex64:\", err)\n \t}\n }\n@@ -995,7 +995,7 @@ func TestBadRecursiveType(t *testing.T) {\n \terr := NewEncoder(b).Encode(&rec)\n \tif err == nil {\n \t\tt.Error(\"expected error; got none\")\n-\t} else if strings.Index(err.String(), \"recursive\") < 0 {\n+\t} else if strings.Index(err.Error(), \"recursive\") < 0 {\n \t\tt.Error(\"expected recursive type error; got\", err)\n \t}\n \t// Can't test decode easily because we can't encode one, so we can't pass one to a Decoder.\n@@ -1014,7 +1014,7 @@ func TestInvalidField(t *testing.T) {\n \tdummyEncoder.encode(b, reflect.ValueOf(&bad0), userType(reflect.TypeOf(&bad0)))\n \tif err := dummyEncoder.err; err == nil {\n \t\tt.Error(\"expected error; got none\")\n-\t} else if strings.Index(err.String(), \"type\") < 0 {\n+\t} else if strings.Index(err.Error(), \"type\") < 0 {\n \t\tt.Error(\"expected type error; got\", err)\n \t}\n }"}, {"sha": "1515d1286d093d6a87990441195cc428ea645e75", "filename": "libgo/go/gob/decode.go", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecode.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,17 +9,17 @@ package gob\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"io\"\n \t\"math\"\n-\t\"os\"\n \t\"reflect\"\n \t\"unsafe\"\n )\n \n var (\n-\terrBadUint = os.NewError(\"gob: encoded unsigned integer out of range\")\n-\terrBadType = os.NewError(\"gob: unknown type id or corrupted data\")\n-\terrRange   = os.NewError(\"gob: bad data: field numbers out of bounds\")\n+\terrBadUint = errors.New(\"gob: encoded unsigned integer out of range\")\n+\terrBadType = errors.New(\"gob: unknown type id or corrupted data\")\n+\terrRange   = errors.New(\"gob: bad data: field numbers out of bounds\")\n )\n \n // decoderState is the execution state of an instance of the decoder. A new state\n@@ -54,13 +54,13 @@ func (dec *Decoder) freeDecoderState(d *decoderState) {\n \tdec.freeList = d\n }\n \n-func overflow(name string) os.Error {\n-\treturn os.NewError(`value for \"` + name + `\" out of range`)\n+func overflow(name string) error {\n+\treturn errors.New(`value for \"` + name + `\" out of range`)\n }\n \n // decodeUintReader reads an encoded unsigned integer from an io.Reader.\n // Used only by the Decoder to read the message length.\n-func decodeUintReader(r io.Reader, buf []byte) (x uint64, width int, err os.Error) {\n+func decodeUintReader(r io.Reader, buf []byte) (x uint64, width int, err error) {\n \twidth = 1\n \t_, err = r.Read(buf[0:width])\n \tif err != nil {\n@@ -77,7 +77,7 @@ func decodeUintReader(r io.Reader, buf []byte) (x uint64, width int, err os.Erro\n \t}\n \twidth, err = io.ReadFull(r, buf[0:n])\n \tif err != nil {\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\terr = io.ErrUnexpectedEOF\n \t\t}\n \t\treturn\n@@ -95,18 +95,18 @@ func decodeUintReader(r io.Reader, buf []byte) (x uint64, width int, err os.Erro\n func (state *decoderState) decodeUint() (x uint64) {\n \tb, err := state.b.ReadByte()\n \tif err != nil {\n-\t\terror(err)\n+\t\terror_(err)\n \t}\n \tif b <= 0x7f {\n \t\treturn uint64(b)\n \t}\n \tn := -int(int8(b))\n \tif n > uint64Size {\n-\t\terror(errBadUint)\n+\t\terror_(errBadUint)\n \t}\n \twidth, err := state.b.Read(state.buf[0:n])\n \tif err != nil {\n-\t\terror(err)\n+\t\terror_(err)\n \t}\n \t// Don't need to check error; it's safe to loop regardless.\n \t// Could check that the high byte is zero but it's not worth it.\n@@ -132,10 +132,10 @@ type decOp func(i *decInstr, state *decoderState, p unsafe.Pointer)\n // The 'instructions' of the decoding machine\n type decInstr struct {\n \top     decOp\n-\tfield  int      // field number of the wire type\n-\tindir  int      // how many pointer indirections to reach the value in the struct\n-\toffset uintptr  // offset in the structure of the field to encode\n-\tovfl   os.Error // error message for overflow/underflow (for arrays, of the elements)\n+\tfield  int     // field number of the wire type\n+\tindir  int     // how many pointer indirections to reach the value in the struct\n+\toffset uintptr // offset in the structure of the field to encode\n+\tovfl   error   // error message for overflow/underflow (for arrays, of the elements)\n }\n \n // Since the encoder writes no zeros, if we arrive at a decoder we have\n@@ -190,7 +190,7 @@ func decInt8(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t}\n \tv := state.decodeInt()\n \tif v < math.MinInt8 || math.MaxInt8 < v {\n-\t\terror(i.ovfl)\n+\t\terror_(i.ovfl)\n \t} else {\n \t\t*(*int8)(p) = int8(v)\n \t}\n@@ -206,7 +206,7 @@ func decUint8(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t}\n \tv := state.decodeUint()\n \tif math.MaxUint8 < v {\n-\t\terror(i.ovfl)\n+\t\terror_(i.ovfl)\n \t} else {\n \t\t*(*uint8)(p) = uint8(v)\n \t}\n@@ -222,7 +222,7 @@ func decInt16(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t}\n \tv := state.decodeInt()\n \tif v < math.MinInt16 || math.MaxInt16 < v {\n-\t\terror(i.ovfl)\n+\t\terror_(i.ovfl)\n \t} else {\n \t\t*(*int16)(p) = int16(v)\n \t}\n@@ -238,7 +238,7 @@ func decUint16(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t}\n \tv := state.decodeUint()\n \tif math.MaxUint16 < v {\n-\t\terror(i.ovfl)\n+\t\terror_(i.ovfl)\n \t} else {\n \t\t*(*uint16)(p) = uint16(v)\n \t}\n@@ -254,7 +254,7 @@ func decInt32(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t}\n \tv := state.decodeInt()\n \tif v < math.MinInt32 || math.MaxInt32 < v {\n-\t\terror(i.ovfl)\n+\t\terror_(i.ovfl)\n \t} else {\n \t\t*(*int32)(p) = int32(v)\n \t}\n@@ -270,7 +270,7 @@ func decUint32(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t}\n \tv := state.decodeUint()\n \tif math.MaxUint32 < v {\n-\t\terror(i.ovfl)\n+\t\terror_(i.ovfl)\n \t} else {\n \t\t*(*uint32)(p) = uint32(v)\n \t}\n@@ -323,7 +323,7 @@ func storeFloat32(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t}\n \t// +Inf is OK in both 32- and 64-bit floats.  Underflow is always OK.\n \tif math.MaxFloat32 < av && av <= math.MaxFloat64 {\n-\t\terror(i.ovfl)\n+\t\terror_(i.ovfl)\n \t} else {\n \t\t*(*float32)(p) = float32(v)\n \t}\n@@ -464,7 +464,7 @@ func allocate(rtyp reflect.Type, p uintptr, indir int) uintptr {\n // decodeSingle decodes a top-level value that is not a struct and stores it through p.\n // Such values are preceded by a zero, making them have the memory layout of a\n // struct field (although with an illegal field number).\n-func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, basep uintptr) (err os.Error) {\n+func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, basep uintptr) (err error) {\n \tstate := dec.newDecoderState(&dec.buf)\n \tstate.fieldnum = singletonField\n \tdelta := int(state.decodeUint())\n@@ -473,7 +473,7 @@ func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, basep uint\n \t}\n \tinstr := &engine.instr[singletonField]\n \tif instr.indir != ut.indir {\n-\t\treturn os.NewError(\"gob: internal error: inconsistent indirection\")\n+\t\treturn errors.New(\"gob: internal error: inconsistent indirection\")\n \t}\n \tptr := unsafe.Pointer(basep) // offset will be zero\n \tif instr.indir > 1 {\n@@ -504,7 +504,7 @@ func (dec *Decoder) decodeStruct(engine *decEngine, ut *userTypeInfo, p uintptr,\n \t\t}\n \t\tfieldnum := state.fieldnum + delta\n \t\tif fieldnum >= len(engine.instr) {\n-\t\t\terror(errRange)\n+\t\t\terror_(errRange)\n \t\t\tbreak\n \t\t}\n \t\tinstr := &engine.instr[fieldnum]\n@@ -532,7 +532,7 @@ func (dec *Decoder) ignoreStruct(engine *decEngine) {\n \t\t}\n \t\tfieldnum := state.fieldnum + delta\n \t\tif fieldnum >= len(engine.instr) {\n-\t\t\terror(errRange)\n+\t\t\terror_(errRange)\n \t\t}\n \t\tinstr := &engine.instr[fieldnum]\n \t\tinstr.op(instr, state, unsafe.Pointer(nil))\n@@ -556,7 +556,7 @@ func (dec *Decoder) ignoreSingle(engine *decEngine) {\n }\n \n // decodeArrayHelper does the work for decoding arrays and slices.\n-func (dec *Decoder) decodeArrayHelper(state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, length, elemIndir int, ovfl os.Error) {\n+func (dec *Decoder) decodeArrayHelper(state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, length, elemIndir int, ovfl error) {\n \tinstr := &decInstr{elemOp, 0, elemIndir, 0, ovfl}\n \tfor i := 0; i < length; i++ {\n \t\tup := unsafe.Pointer(p)\n@@ -571,7 +571,7 @@ func (dec *Decoder) decodeArrayHelper(state *decoderState, p uintptr, elemOp dec\n // decodeArray decodes an array and stores it through p, that is, p points to the zeroth element.\n // The length is an unsigned integer preceding the elements.  Even though the length is redundant\n // (it's part of the type), it's a useful check and is included in the encoding.\n-func (dec *Decoder) decodeArray(atyp reflect.Type, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, length, indir, elemIndir int, ovfl os.Error) {\n+func (dec *Decoder) decodeArray(atyp reflect.Type, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, length, indir, elemIndir int, ovfl error) {\n \tif indir > 0 {\n \t\tp = allocate(atyp, p, 1) // All but the last level has been allocated by dec.Indirect\n \t}\n@@ -583,7 +583,7 @@ func (dec *Decoder) decodeArray(atyp reflect.Type, state *decoderState, p uintpt\n \n // decodeIntoValue is a helper for map decoding.  Since maps are decoded using reflection,\n // unlike the other items we can't use a pointer directly.\n-func decodeIntoValue(state *decoderState, op decOp, indir int, v reflect.Value, ovfl os.Error) reflect.Value {\n+func decodeIntoValue(state *decoderState, op decOp, indir int, v reflect.Value, ovfl error) reflect.Value {\n \tinstr := &decInstr{op, 0, indir, 0, ovfl}\n \tup := unsafe.Pointer(unsafeAddr(v))\n \tif indir > 1 {\n@@ -597,7 +597,7 @@ func decodeIntoValue(state *decoderState, op decOp, indir int, v reflect.Value,\n // Maps are encoded as a length followed by key:value pairs.\n // Because the internals of maps are not visible to us, we must\n // use reflection rather than pointer magic.\n-func (dec *Decoder) decodeMap(mtyp reflect.Type, state *decoderState, p uintptr, keyOp, elemOp decOp, indir, keyIndir, elemIndir int, ovfl os.Error) {\n+func (dec *Decoder) decodeMap(mtyp reflect.Type, state *decoderState, p uintptr, keyOp, elemOp decOp, indir, keyIndir, elemIndir int, ovfl error) {\n \tif indir > 0 {\n \t\tp = allocate(mtyp, p, 1) // All but the last level has been allocated by dec.Indirect\n \t}\n@@ -620,7 +620,7 @@ func (dec *Decoder) decodeMap(mtyp reflect.Type, state *decoderState, p uintptr,\n \n // ignoreArrayHelper does the work for discarding arrays and slices.\n func (dec *Decoder) ignoreArrayHelper(state *decoderState, elemOp decOp, length int) {\n-\tinstr := &decInstr{elemOp, 0, 0, 0, os.NewError(\"no error\")}\n+\tinstr := &decInstr{elemOp, 0, 0, 0, errors.New(\"no error\")}\n \tfor i := 0; i < length; i++ {\n \t\telemOp(instr, state, nil)\n \t}\n@@ -637,8 +637,8 @@ func (dec *Decoder) ignoreArray(state *decoderState, elemOp decOp, length int) {\n // ignoreMap discards the data for a map value with no destination.\n func (dec *Decoder) ignoreMap(state *decoderState, keyOp, elemOp decOp) {\n \tn := int(state.decodeUint())\n-\tkeyInstr := &decInstr{keyOp, 0, 0, 0, os.NewError(\"no error\")}\n-\telemInstr := &decInstr{elemOp, 0, 0, 0, os.NewError(\"no error\")}\n+\tkeyInstr := &decInstr{keyOp, 0, 0, 0, errors.New(\"no error\")}\n+\telemInstr := &decInstr{elemOp, 0, 0, 0, errors.New(\"no error\")}\n \tfor i := 0; i < n; i++ {\n \t\tkeyOp(keyInstr, state, nil)\n \t\telemOp(elemInstr, state, nil)\n@@ -647,7 +647,7 @@ func (dec *Decoder) ignoreMap(state *decoderState, keyOp, elemOp decOp) {\n \n // decodeSlice decodes a slice and stores the slice header through p.\n // Slices are encoded as an unsigned length followed by the elements.\n-func (dec *Decoder) decodeSlice(atyp reflect.Type, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, indir, elemIndir int, ovfl os.Error) {\n+func (dec *Decoder) decodeSlice(atyp reflect.Type, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, indir, elemIndir int, ovfl error) {\n \tn := int(uintptr(state.decodeUint()))\n \tif indir > 0 {\n \t\tup := unsafe.Pointer(p)\n@@ -707,7 +707,7 @@ func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, p ui\n \t// Read the type id of the concrete value.\n \tconcreteId := dec.decodeTypeSequence(true)\n \tif concreteId < 0 {\n-\t\terror(dec.err)\n+\t\terror_(dec.err)\n \t}\n \t// Byte count of value is next; we don't care what it is (it's there\n \t// in case we want to ignore the value by skipping it completely).\n@@ -716,7 +716,7 @@ func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, p ui\n \tvalue := allocValue(typ)\n \tdec.decodeValue(concreteId, value)\n \tif dec.err != nil {\n-\t\terror(dec.err)\n+\t\terror_(dec.err)\n \t}\n \t// Allocate the destination interface value.\n \tif indir > 0 {\n@@ -736,11 +736,11 @@ func (dec *Decoder) ignoreInterface(state *decoderState) {\n \tb := make([]byte, state.decodeUint())\n \t_, err := state.b.Read(b)\n \tif err != nil {\n-\t\terror(err)\n+\t\terror_(err)\n \t}\n \tid := dec.decodeTypeSequence(true)\n \tif id < 0 {\n-\t\terror(dec.err)\n+\t\terror_(dec.err)\n \t}\n \t// At this point, the decoder buffer contains a delimited value. Just toss it.\n \tstate.b.Next(int(state.decodeUint()))\n@@ -753,12 +753,12 @@ func (dec *Decoder) decodeGobDecoder(state *decoderState, v reflect.Value) {\n \tb := make([]byte, state.decodeUint())\n \t_, err := state.b.Read(b)\n \tif err != nil {\n-\t\terror(err)\n+\t\terror_(err)\n \t}\n \t// We know it's a GobDecoder, so just call the method directly.\n \terr = v.Interface().(GobDecoder).GobDecode(b)\n \tif err != nil {\n-\t\terror(err)\n+\t\terror_(err)\n \t}\n }\n \n@@ -768,7 +768,7 @@ func (dec *Decoder) ignoreGobDecoder(state *decoderState) {\n \tb := make([]byte, state.decodeUint())\n \t_, err := state.b.Read(b)\n \tif err != nil {\n-\t\terror(err)\n+\t\terror_(err)\n \t}\n }\n \n@@ -868,7 +868,7 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\t// Generate a closure that calls out to the engine for the nested type.\n \t\t\tenginePtr, err := dec.getDecEnginePtr(wireId, userType(typ))\n \t\t\tif err != nil {\n-\t\t\t\terror(err)\n+\t\t\t\terror_(err)\n \t\t\t}\n \t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\t// indirect through enginePtr to delay evaluation for recursive structs.\n@@ -930,7 +930,7 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \t\t\t// Generate a closure that calls out to the engine for the nested type.\n \t\t\tenginePtr, err := dec.getIgnoreEnginePtr(wireId)\n \t\t\tif err != nil {\n-\t\t\t\terror(err)\n+\t\t\t\terror_(err)\n \t\t\t}\n \t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\t// indirect through enginePtr to delay evaluation for recursive structs\n@@ -1062,23 +1062,23 @@ func (dec *Decoder) typeString(remoteId typeId) string {\n \n // compileSingle compiles the decoder engine for a non-struct top-level value, including\n // GobDecoders.\n-func (dec *Decoder) compileSingle(remoteId typeId, ut *userTypeInfo) (engine *decEngine, err os.Error) {\n+func (dec *Decoder) compileSingle(remoteId typeId, ut *userTypeInfo) (engine *decEngine, err error) {\n \trt := ut.user\n \tengine = new(decEngine)\n \tengine.instr = make([]decInstr, 1) // one item\n \tname := rt.String()                // best we can do\n \tif !dec.compatibleType(rt, remoteId, make(map[reflect.Type]typeId)) {\n-\t\treturn nil, os.NewError(\"gob: wrong type received for local value \" + name + \": \" + dec.typeString(remoteId))\n+\t\treturn nil, errors.New(\"gob: wrong type received for local value \" + name + \": \" + dec.typeString(remoteId))\n \t}\n \top, indir := dec.decOpFor(remoteId, rt, name, make(map[reflect.Type]*decOp))\n-\tovfl := os.NewError(`value for \"` + name + `\" out of range`)\n+\tovfl := errors.New(`value for \"` + name + `\" out of range`)\n \tengine.instr[singletonField] = decInstr{*op, singletonField, indir, 0, ovfl}\n \tengine.numInstr = 1\n \treturn\n }\n \n // compileIgnoreSingle compiles the decoder engine for a non-struct top-level value that will be discarded.\n-func (dec *Decoder) compileIgnoreSingle(remoteId typeId) (engine *decEngine, err os.Error) {\n+func (dec *Decoder) compileIgnoreSingle(remoteId typeId) (engine *decEngine, err error) {\n \tengine = new(decEngine)\n \tengine.instr = make([]decInstr, 1) // one item\n \top := dec.decIgnoreOpFor(remoteId)\n@@ -1090,7 +1090,7 @@ func (dec *Decoder) compileIgnoreSingle(remoteId typeId) (engine *decEngine, err\n \n // compileDec compiles the decoder engine for a value.  If the value is not a struct,\n // it calls out to compileSingle.\n-func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEngine, err os.Error) {\n+func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEngine, err error) {\n \trt := ut.base\n \tsrt := rt\n \tif srt.Kind() != reflect.Struct ||\n@@ -1105,7 +1105,7 @@ func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEn\n \t} else {\n \t\twire := dec.wireType[remoteId]\n \t\tif wire == nil {\n-\t\t\terror(errBadType)\n+\t\t\terror_(errBadType)\n \t\t}\n \t\twireStruct = wire.StructT\n \t}\n@@ -1141,7 +1141,7 @@ func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEn\n }\n \n // getDecEnginePtr returns the engine for the specified type.\n-func (dec *Decoder) getDecEnginePtr(remoteId typeId, ut *userTypeInfo) (enginePtr **decEngine, err os.Error) {\n+func (dec *Decoder) getDecEnginePtr(remoteId typeId, ut *userTypeInfo) (enginePtr **decEngine, err error) {\n \trt := ut.base\n \tdecoderMap, ok := dec.decoderCache[rt]\n \tif !ok {\n@@ -1166,7 +1166,7 @@ type emptyStruct struct{}\n var emptyStructType = reflect.TypeOf(emptyStruct{})\n \n // getDecEnginePtr returns the engine for the specified type when the value is to be discarded.\n-func (dec *Decoder) getIgnoreEnginePtr(wireId typeId) (enginePtr **decEngine, err os.Error) {\n+func (dec *Decoder) getIgnoreEnginePtr(wireId typeId) (enginePtr **decEngine, err error) {\n \tvar ok bool\n \tif enginePtr, ok = dec.ignorerCache[wireId]; !ok {\n \t\t// To handle recursive types, mark this engine as underway before compiling."}, {"sha": "5e684d3ee7eba49ab243fc4674b8f8aa9be8bb5f", "filename": "libgo/go/gob/decoder.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fdecoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fdecoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecoder.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,8 +7,8 @@ package gob\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n \t\"reflect\"\n \t\"sync\"\n )\n@@ -25,7 +25,7 @@ type Decoder struct {\n \tfreeList     *decoderState                           // list of free decoderStates; avoids reallocation\n \tcountBuf     []byte                                  // used for decoding integers while parsing messages\n \ttmp          []byte                                  // temporary storage for i/o; saves reallocating\n-\terr          os.Error\n+\terr          error\n }\n \n // NewDecoder returns a new decoder that reads from the io.Reader.\n@@ -50,7 +50,7 @@ func NewDecoder(r io.Reader) *Decoder {\n func (dec *Decoder) recvType(id typeId) {\n \t// Have we already seen this type?  That's an error\n \tif id < firstUserId || dec.wireType[id] != nil {\n-\t\tdec.err = os.NewError(\"gob: duplicate type received\")\n+\t\tdec.err = errors.New(\"gob: duplicate type received\")\n \t\treturn\n \t}\n \n@@ -64,7 +64,7 @@ func (dec *Decoder) recvType(id typeId) {\n \tdec.wireType[id] = wire\n }\n \n-var errBadCount = os.NewError(\"invalid message length\")\n+var errBadCount = errors.New(\"invalid message length\")\n \n // recvMessage reads the next count-delimited item from the input. It is the converse\n // of Encoder.writeMessage. It returns false on EOF or other error reading the message.\n@@ -94,7 +94,7 @@ func (dec *Decoder) readMessage(nbytes int) {\n \t// Read the data\n \t_, dec.err = io.ReadFull(dec.r, dec.tmp)\n \tif dec.err != nil {\n-\t\tif dec.err == os.EOF {\n+\t\tif dec.err == io.EOF {\n \t\t\tdec.err = io.ErrUnexpectedEOF\n \t\t}\n \t\treturn\n@@ -155,7 +155,7 @@ func (dec *Decoder) decodeTypeSequence(isInterface bool) typeId {\n \t\t// will be absorbed by recvMessage.)\n \t\tif dec.buf.Len() > 0 {\n \t\t\tif !isInterface {\n-\t\t\t\tdec.err = os.NewError(\"extra data in buffer\")\n+\t\t\t\tdec.err = errors.New(\"extra data in buffer\")\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tdec.nextUint()\n@@ -169,15 +169,15 @@ func (dec *Decoder) decodeTypeSequence(isInterface bool) typeId {\n // If e is nil, the value will be discarded. Otherwise,\n // the value underlying e must be a pointer to the\n // correct type for the next data item received.\n-func (dec *Decoder) Decode(e interface{}) os.Error {\n+func (dec *Decoder) Decode(e interface{}) error {\n \tif e == nil {\n \t\treturn dec.DecodeValue(reflect.Value{})\n \t}\n \tvalue := reflect.ValueOf(e)\n \t// If e represents a value as opposed to a pointer, the answer won't\n \t// get back to the caller.  Make sure it's a pointer.\n \tif value.Type().Kind() != reflect.Ptr {\n-\t\tdec.err = os.NewError(\"gob: attempt to decode into a non-pointer\")\n+\t\tdec.err = errors.New(\"gob: attempt to decode into a non-pointer\")\n \t\treturn dec.err\n \t}\n \treturn dec.DecodeValue(value)\n@@ -187,12 +187,12 @@ func (dec *Decoder) Decode(e interface{}) os.Error {\n // If v is the zero reflect.Value (v.Kind() == Invalid), DecodeValue discards the value.\n // Otherwise, it stores the value into v.  In that case, v must represent\n // a non-nil pointer to data or be an assignable reflect.Value (v.CanSet())\n-func (dec *Decoder) DecodeValue(v reflect.Value) os.Error {\n+func (dec *Decoder) DecodeValue(v reflect.Value) error {\n \tif v.IsValid() {\n \t\tif v.Kind() == reflect.Ptr && !v.IsNil() {\n \t\t\t// That's okay, we'll store through the pointer.\n \t\t} else if !v.CanSet() {\n-\t\t\treturn os.NewError(\"gob: DecodeValue of unassignable value\")\n+\t\t\treturn errors.New(\"gob: DecodeValue of unassignable value\")\n \t\t}\n \t}\n \t// Make sure we're single-threaded through here."}, {"sha": "c7e48230c5306ebebd1cec9417ac24792ffe75c5", "filename": "libgo/go/gob/encode.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencode.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -55,7 +55,7 @@ func (state *encoderState) encodeUint(x uint64) {\n \tif x <= 0x7F {\n \t\terr := state.b.WriteByte(uint8(x))\n \t\tif err != nil {\n-\t\t\terror(err)\n+\t\t\terror_(err)\n \t\t}\n \t\treturn\n \t}\n@@ -68,7 +68,7 @@ func (state *encoderState) encodeUint(x uint64) {\n \tstate.buf[i] = uint8(i - uint64Size) // = loop count, negated\n \t_, err := state.b.Write(state.buf[i : uint64Size+1])\n \tif err != nil {\n-\t\terror(err)\n+\t\terror_(err)\n \t}\n }\n \n@@ -443,7 +443,7 @@ func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv reflect.Value) {\n \tstate.encodeUint(uint64(len(name)))\n \t_, err := state.b.WriteString(name)\n \tif err != nil {\n-\t\terror(err)\n+\t\terror_(err)\n \t}\n \t// Define the type id if necessary.\n \tenc.sendTypeDescriptor(enc.writer(), state, ut)\n@@ -456,12 +456,12 @@ func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv reflect.Value) {\n \tdata.Write(spaceForLength)\n \tenc.encode(data, iv.Elem(), ut)\n \tif enc.err != nil {\n-\t\terror(enc.err)\n+\t\terror_(enc.err)\n \t}\n \tenc.popWriter()\n \tenc.writeMessage(b, data)\n \tif enc.err != nil {\n-\t\terror(err)\n+\t\terror_(err)\n \t}\n \tenc.freeEncoderState(state)\n }\n@@ -494,7 +494,7 @@ func (enc *Encoder) encodeGobEncoder(b *bytes.Buffer, v reflect.Value) {\n \t// We know it's a GobEncoder, so just call the method directly.\n \tdata, err := v.Interface().(GobEncoder).GobEncode()\n \tif err != nil {\n-\t\terror(err)\n+\t\terror_(err)\n \t}\n \tstate := enc.newEncoderState(b)\n \tstate.fieldnum = -1\n@@ -681,7 +681,7 @@ func (enc *Encoder) compileEnc(ut *userTypeInfo) *encEngine {\n func (enc *Encoder) getEncEngine(ut *userTypeInfo) *encEngine {\n \tinfo, err1 := getTypeInfo(ut)\n \tif err1 != nil {\n-\t\terror(err1)\n+\t\terror_(err1)\n \t}\n \tif info.encoder == nil {\n \t\t// mark this engine as underway before compiling to handle recursive types."}, {"sha": "e4a48dfc4fca6804bad5bf4501d52463f49be45c", "filename": "libgo/go/gob/encoder.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencoder.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,8 +6,8 @@ package gob\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n \t\"reflect\"\n \t\"sync\"\n )\n@@ -21,7 +21,7 @@ type Encoder struct {\n \tcountState *encoderState           // stage for writing counts\n \tfreeList   *encoderState           // list of free encoderStates; avoids reallocation\n \tbyteBuf    bytes.Buffer            // buffer for top-level encoderState\n-\terr        os.Error\n+\terr        error\n }\n \n // Before we encode a message, we reserve space at the head of the\n@@ -55,10 +55,10 @@ func (enc *Encoder) popWriter() {\n }\n \n func (enc *Encoder) badType(rt reflect.Type) {\n-\tenc.setError(os.NewError(\"gob: can't encode type \" + rt.String()))\n+\tenc.setError(errors.New(\"gob: can't encode type \" + rt.String()))\n }\n \n-func (enc *Encoder) setError(err os.Error) {\n+func (enc *Encoder) setError(err error) {\n \tif enc.err == nil { // remember the first.\n \t\tenc.err = err\n \t}\n@@ -171,7 +171,7 @@ func (enc *Encoder) sendType(w io.Writer, state *encoderState, origt reflect.Typ\n \n // Encode transmits the data item represented by the empty interface value,\n // guaranteeing that all necessary type information has been transmitted first.\n-func (enc *Encoder) Encode(e interface{}) os.Error {\n+func (enc *Encoder) Encode(e interface{}) error {\n \treturn enc.EncodeValue(reflect.ValueOf(e))\n }\n \n@@ -215,7 +215,7 @@ func (enc *Encoder) sendTypeId(state *encoderState, ut *userTypeInfo) {\n \n // EncodeValue transmits the data item represented by the reflection value,\n // guaranteeing that all necessary type information has been transmitted first.\n-func (enc *Encoder) EncodeValue(value reflect.Value) os.Error {\n+func (enc *Encoder) EncodeValue(value reflect.Value) error {\n \t// Make sure we're single-threaded through here, so multiple\n \t// goroutines can share an encoder.\n \tenc.mutex.Lock()"}, {"sha": "bc5af120af3350bd975bb3075012e6dbcd1aa7ca", "filename": "libgo/go/gob/encoder_test.go", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencoder_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n-\t\"os\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n@@ -116,7 +115,7 @@ func TestWrongTypeDecoder(t *testing.T) {\n \tbadTypeCheck(new(ET4), true, \"different type of field\", t)\n }\n \n-func corruptDataCheck(s string, err os.Error, t *testing.T) {\n+func corruptDataCheck(s string, err error, t *testing.T) {\n \tb := bytes.NewBufferString(s)\n \tdec := NewDecoder(b)\n \terr1 := dec.Decode(new(ET2))\n@@ -127,7 +126,7 @@ func corruptDataCheck(s string, err os.Error, t *testing.T) {\n \n // Check that we survive bad data.\n func TestBadData(t *testing.T) {\n-\tcorruptDataCheck(\"\", os.EOF, t)\n+\tcorruptDataCheck(\"\", io.EOF, t)\n \tcorruptDataCheck(\"\\x7Fhi\", io.ErrUnexpectedEOF, t)\n \tcorruptDataCheck(\"\\x03now is the time for all good men\", errBadType, t)\n }\n@@ -149,7 +148,7 @@ func TestUnsupported(t *testing.T) {\n \t}\n }\n \n-func encAndDec(in, out interface{}) os.Error {\n+func encAndDec(in, out interface{}) error {\n \tb := new(bytes.Buffer)\n \tenc := NewEncoder(b)\n \terr := enc.Encode(in)\n@@ -225,7 +224,7 @@ func TestValueError(t *testing.T) {\n \t}\n \tt4p := &Type4{3}\n \tvar t4 Type4 // note: not a pointer.\n-\tif err := encAndDec(t4p, t4); err == nil || strings.Index(err.String(), \"pointer\") < 0 {\n+\tif err := encAndDec(t4p, t4); err == nil || strings.Index(err.Error(), \"pointer\") < 0 {\n \t\tt.Error(\"expected error about pointer; got\", err)\n \t}\n }\n@@ -333,7 +332,7 @@ func TestSingletons(t *testing.T) {\n \t\t\tt.Errorf(\"expected error decoding %v: %s\", test.in, test.err)\n \t\t\tcontinue\n \t\tcase err != nil && test.err != \"\":\n-\t\t\tif strings.Index(err.String(), test.err) < 0 {\n+\t\t\tif strings.Index(err.Error(), test.err) < 0 {\n \t\t\t\tt.Errorf(\"wrong error decoding %v: wanted %s, got %v\", test.in, test.err, err)\n \t\t\t}\n \t\t\tcontinue\n@@ -359,7 +358,7 @@ func TestStructNonStruct(t *testing.T) {\n \tvar ns NonStruct\n \tif err := encAndDec(s, &ns); err == nil {\n \t\tt.Error(\"should get error for struct/non-struct\")\n-\t} else if strings.Index(err.String(), \"type\") < 0 {\n+\t} else if strings.Index(err.Error(), \"type\") < 0 {\n \t\tt.Error(\"for struct/non-struct expected type error; got\", err)\n \t}\n \t// Now try the other way\n@@ -369,7 +368,7 @@ func TestStructNonStruct(t *testing.T) {\n \t}\n \tif err := encAndDec(ns, &s); err == nil {\n \t\tt.Error(\"should get error for non-struct/struct\")\n-\t} else if strings.Index(err.String(), \"type\") < 0 {\n+\t} else if strings.Index(err.Error(), \"type\") < 0 {\n \t\tt.Error(\"for non-struct/struct expected type error; got\", err)\n \t}\n }\n@@ -524,7 +523,7 @@ type Bug1Elem struct {\n \n type Bug1StructMap map[string]Bug1Elem\n \n-func bug1EncDec(in Bug1StructMap, out *Bug1StructMap) os.Error {\n+func bug1EncDec(in Bug1StructMap, out *Bug1StructMap) error {\n \treturn nil\n }\n \n@@ -634,7 +633,7 @@ func TestBadCount(t *testing.T) {\n \tb := []byte{0xfb, 0xa5, 0x82, 0x2f, 0xca, 0x1}\n \tif err := NewDecoder(bytes.NewBuffer(b)).Decode(nil); err == nil {\n \t\tt.Error(\"expected error from bad count\")\n-\t} else if err.String() != errBadCount.String() {\n+\t} else if err.Error() != errBadCount.Error() {\n \t\tt.Error(\"expected bad count error; got\", err)\n \t}\n }"}, {"sha": "fbae8b683da74038a930e055219246e278b6ee88", "filename": "libgo/go/gob/error.go", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ferror.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,37 +4,34 @@\n \n package gob\n \n-import (\n-\t\"fmt\"\n-\t\"os\"\n-)\n+import \"fmt\"\n \n // Errors in decoding and encoding are handled using panic and recover.\n // Panics caused by user error (that is, everything except run-time panics\n // such as \"index out of bounds\" errors) do not leave the file that caused\n-// them, but are instead turned into plain os.Error returns.  Encoding and\n-// decoding functions and methods that do not return an os.Error either use\n+// them, but are instead turned into plain error returns.  Encoding and\n+// decoding functions and methods that do not return an error either use\n // panic to report an error or are guaranteed error-free.\n \n-// A gobError wraps an os.Error and is used to distinguish errors (panics) generated in this package.\n+// A gobError is used to distinguish errors (panics) generated in this package.\n type gobError struct {\n-\terr os.Error\n+\terr error\n }\n \n-// errorf is like error but takes Printf-style arguments to construct an os.Error.\n+// errorf is like error_ but takes Printf-style arguments to construct an error.\n // It always prefixes the message with \"gob: \".\n func errorf(format string, args ...interface{}) {\n-\terror(fmt.Errorf(\"gob: \"+format, args...))\n+\terror_(fmt.Errorf(\"gob: \"+format, args...))\n }\n \n // error wraps the argument error and uses it as the argument to panic.\n-func error(err os.Error) {\n+func error_(err error) {\n \tpanic(gobError{err})\n }\n \n // catchError is meant to be used as a deferred function to turn a panic(gobError) into a\n-// plain os.Error.  It overwrites the error return of the function that deferred its call.\n-func catchError(err *os.Error) {\n+// plain error.  It overwrites the error return of the function that deferred its call.\n+func catchError(err *error) {\n \tif e := recover(); e != nil {\n \t\t*err = e.(gobError).err // Will re-panic if not one of our errors, such as a runtime error.\n \t}"}, {"sha": "eacfd842db383cd4997ed9ec623e662277f078db", "filename": "libgo/go/gob/gobencdec_test.go", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fgobencdec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Fgobencdec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fgobencdec_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,8 +8,9 @@ package gob\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n-\t\"os\"\n+\t\"io\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -34,76 +35,76 @@ type ValueGobber string // encodes with a value, decodes with a pointer.\n \n // The relevant methods\n \n-func (g *ByteStruct) GobEncode() ([]byte, os.Error) {\n+func (g *ByteStruct) GobEncode() ([]byte, error) {\n \tb := make([]byte, 3)\n \tb[0] = g.a\n \tb[1] = g.a + 1\n \tb[2] = g.a + 2\n \treturn b, nil\n }\n \n-func (g *ByteStruct) GobDecode(data []byte) os.Error {\n+func (g *ByteStruct) GobDecode(data []byte) error {\n \tif g == nil {\n-\t\treturn os.NewError(\"NIL RECEIVER\")\n+\t\treturn errors.New(\"NIL RECEIVER\")\n \t}\n \t// Expect N sequential-valued bytes.\n \tif len(data) == 0 {\n-\t\treturn os.EOF\n+\t\treturn io.EOF\n \t}\n \tg.a = data[0]\n \tfor i, c := range data {\n \t\tif c != g.a+byte(i) {\n-\t\t\treturn os.NewError(\"invalid data sequence\")\n+\t\t\treturn errors.New(\"invalid data sequence\")\n \t\t}\n \t}\n \treturn nil\n }\n \n-func (g *StringStruct) GobEncode() ([]byte, os.Error) {\n+func (g *StringStruct) GobEncode() ([]byte, error) {\n \treturn []byte(g.s), nil\n }\n \n-func (g *StringStruct) GobDecode(data []byte) os.Error {\n+func (g *StringStruct) GobDecode(data []byte) error {\n \t// Expect N sequential-valued bytes.\n \tif len(data) == 0 {\n-\t\treturn os.EOF\n+\t\treturn io.EOF\n \t}\n \ta := data[0]\n \tfor i, c := range data {\n \t\tif c != a+byte(i) {\n-\t\t\treturn os.NewError(\"invalid data sequence\")\n+\t\t\treturn errors.New(\"invalid data sequence\")\n \t\t}\n \t}\n \tg.s = string(data)\n \treturn nil\n }\n \n-func (a *ArrayStruct) GobEncode() ([]byte, os.Error) {\n+func (a *ArrayStruct) GobEncode() ([]byte, error) {\n \treturn a.a[:], nil\n }\n \n-func (a *ArrayStruct) GobDecode(data []byte) os.Error {\n+func (a *ArrayStruct) GobDecode(data []byte) error {\n \tif len(data) != len(a.a) {\n-\t\treturn os.NewError(\"wrong length in array decode\")\n+\t\treturn errors.New(\"wrong length in array decode\")\n \t}\n \tcopy(a.a[:], data)\n \treturn nil\n }\n \n-func (g *Gobber) GobEncode() ([]byte, os.Error) {\n+func (g *Gobber) GobEncode() ([]byte, error) {\n \treturn []byte(fmt.Sprintf(\"VALUE=%d\", *g)), nil\n }\n \n-func (g *Gobber) GobDecode(data []byte) os.Error {\n+func (g *Gobber) GobDecode(data []byte) error {\n \t_, err := fmt.Sscanf(string(data), \"VALUE=%d\", (*int)(g))\n \treturn err\n }\n \n-func (v ValueGobber) GobEncode() ([]byte, os.Error) {\n+func (v ValueGobber) GobEncode() ([]byte, error) {\n \treturn []byte(fmt.Sprintf(\"VALUE=%s\", v)), nil\n }\n \n-func (v *ValueGobber) GobDecode(data []byte) os.Error {\n+func (v *ValueGobber) GobDecode(data []byte) error {\n \t_, err := fmt.Sscanf(string(data), \"VALUE=%s\", (*string)(v))\n \treturn err\n }\n@@ -372,7 +373,7 @@ func TestGobEncoderFieldTypeError(t *testing.T) {\n \tif err == nil {\n \t\tt.Fatal(\"expected decode error for mismatched fields (encoder to non-decoder)\")\n \t}\n-\tif strings.Index(err.String(), \"type\") < 0 {\n+\tif strings.Index(err.Error(), \"type\") < 0 {\n \t\tt.Fatal(\"expected type error; got\", err)\n \t}\n \t// Non-encoder to GobDecoder: error\n@@ -386,7 +387,7 @@ func TestGobEncoderFieldTypeError(t *testing.T) {\n \tif err == nil {\n \t\tt.Fatal(\"expected decode error for mismatched fields (non-encoder to decoder)\")\n \t}\n-\tif strings.Index(err.String(), \"type\") < 0 {\n+\tif strings.Index(err.Error(), \"type\") < 0 {\n \t\tt.Fatal(\"expected type error; got\", err)\n \t}\n }\n@@ -497,11 +498,11 @@ func (br *gobDecoderBug0) String() string {\n \treturn br.foo + \"-\" + br.bar\n }\n \n-func (br *gobDecoderBug0) GobEncode() ([]byte, os.Error) {\n+func (br *gobDecoderBug0) GobEncode() ([]byte, error) {\n \treturn []byte(br.String()), nil\n }\n \n-func (br *gobDecoderBug0) GobDecode(b []byte) os.Error {\n+func (br *gobDecoderBug0) GobDecode(b []byte) error {\n \tbr.foo = \"foo\"\n \tbr.bar = \"bar\"\n \treturn nil"}, {"sha": "47437a607f1a3e9ec05e8da354e22d7de6ee8b5b", "filename": "libgo/go/gob/timing_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Ftiming_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Ftiming_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftiming_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -39,7 +39,7 @@ func benchmarkEndToEnd(r io.Reader, w io.Writer, b *testing.B) {\n func BenchmarkEndToEndPipe(b *testing.B) {\n \tr, w, err := os.Pipe()\n \tif err != nil {\n-\t\tpanic(\"can't get pipe:\" + err.String())\n+\t\tpanic(\"can't get pipe:\" + err.Error())\n \t}\n \tbenchmarkEndToEnd(r, w, b)\n }"}, {"sha": "c3bc7c7ffc4002583c22c6ef6bdc60a4c4815861", "filename": "libgo/go/gob/type.go", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftype.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,6 +5,7 @@\n package gob\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"os\"\n \t\"reflect\"\n@@ -36,7 +37,7 @@ var (\n // validType returns, and saves, the information associated with user-provided type rt.\n // If the user type is not valid, err will be non-nil.  To be used when the error handler\n // is not set up.\n-func validUserType(rt reflect.Type) (ut *userTypeInfo, err os.Error) {\n+func validUserType(rt reflect.Type) (ut *userTypeInfo, err error) {\n \tuserTypeLock.RLock()\n \tut = userTypeCache[rt]\n \tuserTypeLock.RUnlock()\n@@ -67,7 +68,7 @@ func validUserType(rt reflect.Type) (ut *userTypeInfo, err os.Error) {\n \t\tut.base = pt.Elem()\n \t\tif ut.base == slowpoke { // ut.base lapped slowpoke\n \t\t\t// recursive pointer type.\n-\t\t\treturn nil, os.NewError(\"can't represent recursive pointer type \" + ut.base.String())\n+\t\t\treturn nil, errors.New(\"can't represent recursive pointer type \" + ut.base.String())\n \t\t}\n \t\tif ut.indir%2 == 0 {\n \t\t\tslowpoke = slowpoke.Elem()\n@@ -125,7 +126,7 @@ func implementsInterface(typ, gobEncDecType reflect.Type) (success bool, indir i\n func userType(rt reflect.Type) *userTypeInfo {\n \tut, err := validUserType(rt)\n \tif err != nil {\n-\t\terror(err)\n+\t\terror_(err)\n \t}\n \treturn ut\n }\n@@ -396,12 +397,12 @@ func newStructType(name string) *structType {\n // of ut.\n // This is only called from the encoding side. The decoding side\n // works through typeIds and userTypeInfos alone.\n-func newTypeObject(name string, ut *userTypeInfo, rt reflect.Type) (gobType, os.Error) {\n+func newTypeObject(name string, ut *userTypeInfo, rt reflect.Type) (gobType, error) {\n \t// Does this type implement GobEncoder?\n \tif ut.isGobEncoder {\n \t\treturn newGobEncoderType(name), nil\n \t}\n-\tvar err os.Error\n+\tvar err error\n \tvar type0, type1 gobType\n \tdefer func() {\n \t\tif err != nil {\n@@ -503,7 +504,7 @@ func newTypeObject(name string, ut *userTypeInfo, rt reflect.Type) (gobType, os.\n \t\treturn st, nil\n \n \tdefault:\n-\t\treturn nil, os.NewError(\"gob NewTypeObject can't handle type: \" + rt.String())\n+\t\treturn nil, errors.New(\"gob NewTypeObject can't handle type: \" + rt.String())\n \t}\n \treturn nil, nil\n }\n@@ -516,7 +517,7 @@ func isExported(name string) bool {\n \n // getBaseType returns the Gob type describing the given reflect.Type's base type.\n // typeLock must be held.\n-func getBaseType(name string, rt reflect.Type) (gobType, os.Error) {\n+func getBaseType(name string, rt reflect.Type) (gobType, error) {\n \tut := userType(rt)\n \treturn getType(name, ut, ut.base)\n }\n@@ -526,7 +527,7 @@ func getBaseType(name string, rt reflect.Type) (gobType, os.Error) {\n // which may be pointers.  All other types are handled through the\n // base type, never a pointer.\n // typeLock must be held.\n-func getType(name string, ut *userTypeInfo, rt reflect.Type) (gobType, os.Error) {\n+func getType(name string, ut *userTypeInfo, rt reflect.Type) (gobType, error) {\n \ttyp, present := types[rt]\n \tif present {\n \t\treturn typ, nil\n@@ -609,7 +610,7 @@ type typeInfo struct {\n var typeInfoMap = make(map[reflect.Type]*typeInfo) // protected by typeLock\n \n // typeLock must be held.\n-func getTypeInfo(ut *userTypeInfo) (*typeInfo, os.Error) {\n+func getTypeInfo(ut *userTypeInfo) (*typeInfo, error) {\n \trt := ut.base\n \tif ut.isGobEncoder {\n \t\t// We want the user type, not the base type.\n@@ -658,7 +659,7 @@ func getTypeInfo(ut *userTypeInfo) (*typeInfo, os.Error) {\n func mustGetTypeInfo(rt reflect.Type) *typeInfo {\n \tt, err := getTypeInfo(userType(rt))\n \tif err != nil {\n-\t\tpanic(\"getTypeInfo: \" + err.String())\n+\t\tpanic(\"getTypeInfo: \" + err.Error())\n \t}\n \treturn t\n }\n@@ -678,7 +679,7 @@ type GobEncoder interface {\n \t// GobEncode returns a byte slice representing the encoding of the\n \t// receiver for transmission to a GobDecoder, usually of the same\n \t// concrete type.\n-\tGobEncode() ([]byte, os.Error)\n+\tGobEncode() ([]byte, error)\n }\n \n // GobDecoder is the interface describing data that provides its own\n@@ -687,7 +688,7 @@ type GobDecoder interface {\n \t// GobDecode overwrites the receiver, which must be a pointer,\n \t// with the value represented by the byte slice, which was written\n \t// by GobEncode, usually for the same concrete type.\n-\tGobDecode([]byte) os.Error\n+\tGobDecode([]byte) error\n }\n \n var ("}, {"sha": "a6ac9c420104b45be2ad822b129f80dec2fa8127", "filename": "libgo/go/gob/type_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Ftype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fgob%2Ftype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftype_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -28,7 +28,7 @@ func getTypeUnlocked(name string, rt reflect.Type) gobType {\n \tdefer typeLock.Unlock()\n \tt, err := getBaseType(name, rt)\n \tif err != nil {\n-\t\tpanic(\"getTypeUnlocked: \" + err.String())\n+\t\tpanic(\"getTypeUnlocked: \" + err.Error())\n \t}\n \treturn t\n }"}, {"sha": "10bed2f05e43626158ecf0d01eae2b861b6f9663", "filename": "libgo/go/hash/adler32/adler32.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,10 +11,7 @@\n //\tsignificant-byte first (network) order.\n package adler32\n \n-import (\n-\t\"hash\"\n-\t\"os\"\n-)\n+import \"hash\"\n \n const (\n \tmod = 65521\n@@ -67,7 +64,7 @@ func finish(a, b uint32) uint32 {\n \treturn b<<16 | a\n }\n \n-func (d *digest) Write(p []byte) (nn int, err os.Error) {\n+func (d *digest) Write(p []byte) (nn int, err error) {\n \td.a, d.b = update(d.a, d.b, p)\n \treturn len(p), nil\n }"}, {"sha": "5980ec0dc98e685f72845f83a86173bcc494b7a5", "filename": "libgo/go/hash/crc32/crc32.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,7 +9,6 @@ package crc32\n \n import (\n \t\"hash\"\n-\t\"os\"\n \t\"sync\"\n )\n \n@@ -113,7 +112,7 @@ func Update(crc uint32, tab *Table, p []byte) uint32 {\n \treturn update(crc, tab, p)\n }\n \n-func (d *digest) Write(p []byte) (n int, err os.Error) {\n+func (d *digest) Write(p []byte) (n int, err error) {\n \td.crc = Update(d.crc, d.tab, p)\n \treturn len(p), nil\n }"}, {"sha": "42e53c3a5bd0faf45d4d30abc441292286e946a8", "filename": "libgo/go/hash/crc64/crc64.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,10 +7,7 @@\n // information.\n package crc64\n \n-import (\n-\t\"hash\"\n-\t\"os\"\n-)\n+import \"hash\"\n \n // The size of a CRC-64 checksum in bytes.\n const Size = 8\n@@ -71,7 +68,7 @@ func Update(crc uint64, tab *Table, p []byte) uint64 {\n \treturn update(crc, tab, p)\n }\n \n-func (d *digest) Write(p []byte) (n int, err os.Error) {\n+func (d *digest) Write(p []byte) (n int, err error) {\n \td.crc = update(d.crc, d.tab, p)\n \treturn len(p), nil\n }"}, {"sha": "ce3ed0d0f406722fbca8f986dbd96df7f2142660", "filename": "libgo/go/hash/fnv/fnv.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,7 +10,6 @@ package fnv\n import (\n \t\"encoding/binary\"\n \t\"hash\"\n-\t\"os\"\n )\n \n type (\n@@ -61,7 +60,7 @@ func (s *sum32a) Sum32() uint32 { return uint32(*s) }\n func (s *sum64) Sum64() uint64  { return uint64(*s) }\n func (s *sum64a) Sum64() uint64 { return uint64(*s) }\n \n-func (s *sum32) Write(data []byte) (int, os.Error) {\n+func (s *sum32) Write(data []byte) (int, error) {\n \thash := *s\n \tfor _, c := range data {\n \t\thash *= prime32\n@@ -71,7 +70,7 @@ func (s *sum32) Write(data []byte) (int, os.Error) {\n \treturn len(data), nil\n }\n \n-func (s *sum32a) Write(data []byte) (int, os.Error) {\n+func (s *sum32a) Write(data []byte) (int, error) {\n \thash := *s\n \tfor _, c := range data {\n \t\thash ^= sum32a(c)\n@@ -81,7 +80,7 @@ func (s *sum32a) Write(data []byte) (int, os.Error) {\n \treturn len(data), nil\n }\n \n-func (s *sum64) Write(data []byte) (int, os.Error) {\n+func (s *sum64) Write(data []byte) (int, error) {\n \thash := *s\n \tfor _, c := range data {\n \t\thash *= prime64\n@@ -91,7 +90,7 @@ func (s *sum64) Write(data []byte) (int, os.Error) {\n \treturn len(data), nil\n }\n \n-func (s *sum64a) Write(data []byte) (int, os.Error) {\n+func (s *sum64a) Write(data []byte) (int, error) {\n \thash := *s\n \tfor _, c := range data {\n \t\thash ^= sum64a(c)"}, {"sha": "b8e6571a2921f3ef91f0d5a141ff98afda87859c", "filename": "libgo/go/html/escape.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fescape.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,7 +6,6 @@ package html\n \n import (\n \t\"bytes\"\n-\t\"os\"\n \t\"strings\"\n \t\"utf8\"\n )\n@@ -195,7 +194,7 @@ func lower(b []byte) []byte {\n \n const escapedChars = `&'<>\"`\n \n-func escape(w writer, s string) os.Error {\n+func escape(w writer, s string) error {\n \ti := strings.IndexAny(s, escapedChars)\n \tfor i != -1 {\n \t\tif _, err := w.WriteString(s[:i]); err != nil {"}, {"sha": "c9f016588d0081748f765a64a4ccc0cbeccb82f3", "filename": "libgo/go/html/parse.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,7 +6,6 @@ package html\n \n import (\n \t\"io\"\n-\t\"os\"\n \t\"strings\"\n )\n \n@@ -240,7 +239,7 @@ func (p *parser) reconstructActiveFormattingElements() {\n \n // read reads the next token. This is usually from the tokenizer, but it may\n // be the synthesized end tag implied by a self-closing tag.\n-func (p *parser) read() os.Error {\n+func (p *parser) read() error {\n \tif p.hasSelfClosingToken {\n \t\tp.hasSelfClosingToken = false\n \t\tp.tok.Type = EndTagToken\n@@ -1136,7 +1135,7 @@ func afterAfterBodyIM(p *parser) (insertionMode, bool) {\n \n // Parse returns the parse tree for the HTML from the given Reader.\n // The input is assumed to be UTF-8 encoded.\n-func Parse(r io.Reader) (*Node, os.Error) {\n+func Parse(r io.Reader) (*Node, error) {\n \tp := &parser{\n \t\ttokenizer: NewTokenizer(r),\n \t\tdoc: &Node{\n@@ -1150,7 +1149,7 @@ func Parse(r io.Reader) (*Node, os.Error) {\n \tfor {\n \t\tif consumed {\n \t\t\tif err := p.read(); err != nil {\n-\t\t\t\tif err == os.EOF {\n+\t\t\t\tif err == io.EOF {\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t\treturn nil, err"}, {"sha": "3fa40374eae34ee8c8b76d09f1e63163e0438985", "filename": "libgo/go/html/parse_test.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,6 +7,7 @@ package html\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -15,7 +16,7 @@ import (\n \t\"testing\"\n )\n \n-func pipeErr(err os.Error) io.Reader {\n+func pipeErr(err error) io.Reader {\n \tpr, pw := io.Pipe()\n \tpw.CloseWithError(err)\n \treturn pr\n@@ -76,13 +77,13 @@ func dumpIndent(w io.Writer, level int) {\n \t}\n }\n \n-func dumpLevel(w io.Writer, n *Node, level int) os.Error {\n+func dumpLevel(w io.Writer, n *Node, level int) error {\n \tdumpIndent(w, level)\n \tswitch n.Type {\n \tcase ErrorNode:\n-\t\treturn os.NewError(\"unexpected ErrorNode\")\n+\t\treturn errors.New(\"unexpected ErrorNode\")\n \tcase DocumentNode:\n-\t\treturn os.NewError(\"unexpected DocumentNode\")\n+\t\treturn errors.New(\"unexpected DocumentNode\")\n \tcase ElementNode:\n \t\tfmt.Fprintf(w, \"<%s>\", n.Data)\n \t\tfor _, a := range n.Attr {\n@@ -97,9 +98,9 @@ func dumpLevel(w io.Writer, n *Node, level int) os.Error {\n \tcase DoctypeNode:\n \t\tfmt.Fprintf(w, \"<!DOCTYPE %s>\", n.Data)\n \tcase scopeMarkerNode:\n-\t\treturn os.NewError(\"unexpected scopeMarkerNode\")\n+\t\treturn errors.New(\"unexpected scopeMarkerNode\")\n \tdefault:\n-\t\treturn os.NewError(\"unknown node type\")\n+\t\treturn errors.New(\"unknown node type\")\n \t}\n \tio.WriteString(w, \"\\n\")\n \tfor _, c := range n.Child {\n@@ -110,7 +111,7 @@ func dumpLevel(w io.Writer, n *Node, level int) os.Error {\n \treturn nil\n }\n \n-func dump(n *Node) (string, os.Error) {\n+func dump(n *Node) (string, error) {\n \tif n == nil || len(n.Child) == 0 {\n \t\treturn \"\", nil\n \t}"}, {"sha": "c815f35f1e1d9e3f6724e386ae2caefcabd19338", "filename": "libgo/go/html/render.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhtml%2Frender.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhtml%2Frender.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Frender.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,15 +6,15 @@ package html\n \n import (\n \t\"bufio\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"os\"\n )\n \n type writer interface {\n \tio.Writer\n-\tWriteByte(byte) os.Error\n-\tWriteString(string) (int, os.Error)\n+\tWriteByte(byte) error\n+\tWriteString(string) (int, error)\n }\n \n // Render renders the parse tree n to the given writer.\n@@ -41,7 +41,7 @@ type writer interface {\n // text node would become a tree containing <html>, <head> and <body> elements.\n // Another example is that the programmatic equivalent of \"a<head>b</head>c\"\n // becomes \"<html><head><head/><body>abc</body></html>\".\n-func Render(w io.Writer, n *Node) os.Error {\n+func Render(w io.Writer, n *Node) error {\n \tif x, ok := w.(writer); ok {\n \t\treturn render(x, n)\n \t}\n@@ -52,11 +52,11 @@ func Render(w io.Writer, n *Node) os.Error {\n \treturn buf.Flush()\n }\n \n-func render(w writer, n *Node) os.Error {\n+func render(w writer, n *Node) error {\n \t// Render non-element nodes; these are the easy cases.\n \tswitch n.Type {\n \tcase ErrorNode:\n-\t\treturn os.NewError(\"html: cannot render an ErrorNode node\")\n+\t\treturn errors.New(\"html: cannot render an ErrorNode node\")\n \tcase TextNode:\n \t\treturn escape(w, n.Data)\n \tcase DocumentNode:\n@@ -88,7 +88,7 @@ func render(w writer, n *Node) os.Error {\n \t\t}\n \t\treturn w.WriteByte('>')\n \tdefault:\n-\t\treturn os.NewError(\"html: unknown node type\")\n+\t\treturn errors.New(\"html: unknown node type\")\n \t}\n \n \t// Render the <xxx> opening tag."}, {"sha": "c5b8a1c710e7af94a99f837f44b88fdcfb05ce06", "filename": "libgo/go/html/token.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhtml%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhtml%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package html\n import (\n \t\"bytes\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n \t\"strings\"\n )\n@@ -127,7 +126,7 @@ type Tokenizer struct {\n \t// Next call would set z.err to os.EOF but return a TextToken, and all\n \t// subsequent Next calls would return an ErrorToken.\n \t// err is never reset. Once it becomes non-nil, it stays non-nil.\n-\terr os.Error\n+\terr error\n \t// buf[raw.start:raw.end] holds the raw bytes of the current token.\n \t// buf[raw.end:] is buffered input that will yield future tokens.\n \traw span\n@@ -152,7 +151,7 @@ type Tokenizer struct {\n \n // Error returns the error associated with the most recent ErrorToken token.\n // This is typically os.EOF, meaning the end of tokenization.\n-func (z *Tokenizer) Error() os.Error {\n+func (z *Tokenizer) Error() error {\n \tif z.tt != ErrorToken {\n \t\treturn nil\n \t}"}, {"sha": "76cc9f835da36fc3f7917c2a4f188e16156c5020", "filename": "libgo/go/html/token_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,7 +6,7 @@ package html\n \n import (\n \t\"bytes\"\n-\t\"os\"\n+\t\"io\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -438,7 +438,7 @@ loop:\n \t\t\t}\n \t\t}\n \t\tz.Next()\n-\t\tif z.Error() != os.EOF {\n+\t\tif z.Error() != io.EOF {\n \t\t\tt.Errorf(\"%s: want EOF got %q\", tt.desc, z.Error())\n \t\t}\n \t}\n@@ -543,7 +543,7 @@ loop:\n \t\ttt := z.Next()\n \t\tswitch tt {\n \t\tcase ErrorToken:\n-\t\t\tif z.Error() != os.EOF {\n+\t\t\tif z.Error() != io.EOF {\n \t\t\t\tt.Error(z.Error())\n \t\t\t}\n \t\t\tbreak loop"}, {"sha": "1618268914aeeb5bcde2b11dfdbf654f1faf631f", "filename": "libgo/go/http/cgi/child.go", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,6 +10,7 @@ package cgi\n import (\n \t\"bufio\"\n \t\"crypto/tls\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"http\"\n \t\"io\"\n@@ -25,7 +26,7 @@ import (\n // environment. This assumes the current program is being run\n // by a web server in a CGI environment.\n // The returned Request's Body is populated, if applicable.\n-func Request() (*http.Request, os.Error) {\n+func Request() (*http.Request, error) {\n \tr, err := RequestFromMap(envMap(os.Environ()))\n \tif err != nil {\n \t\treturn nil, err\n@@ -48,18 +49,18 @@ func envMap(env []string) map[string]string {\n \n // RequestFromMap creates an http.Request from CGI variables.\n // The returned Request's Body field is not populated.\n-func RequestFromMap(params map[string]string) (*http.Request, os.Error) {\n+func RequestFromMap(params map[string]string) (*http.Request, error) {\n \tr := new(http.Request)\n \tr.Method = params[\"REQUEST_METHOD\"]\n \tif r.Method == \"\" {\n-\t\treturn nil, os.NewError(\"cgi: no REQUEST_METHOD in environment\")\n+\t\treturn nil, errors.New(\"cgi: no REQUEST_METHOD in environment\")\n \t}\n \n \tr.Proto = params[\"SERVER_PROTOCOL\"]\n \tvar ok bool\n \tr.ProtoMajor, r.ProtoMinor, ok = http.ParseHTTPVersion(r.Proto)\n \tif !ok {\n-\t\treturn nil, os.NewError(\"cgi: invalid SERVER_PROTOCOL version\")\n+\t\treturn nil, errors.New(\"cgi: invalid SERVER_PROTOCOL version\")\n \t}\n \n \tr.Close = true\n@@ -71,7 +72,7 @@ func RequestFromMap(params map[string]string) (*http.Request, os.Error) {\n \tif lenstr := params[\"CONTENT_LENGTH\"]; lenstr != \"\" {\n \t\tclen, err := strconv.Atoi64(lenstr)\n \t\tif err != nil {\n-\t\t\treturn nil, os.NewError(\"cgi: bad CONTENT_LENGTH in environment: \" + lenstr)\n+\t\t\treturn nil, errors.New(\"cgi: bad CONTENT_LENGTH in environment: \" + lenstr)\n \t\t}\n \t\tr.ContentLength = clen\n \t}\n@@ -96,7 +97,7 @@ func RequestFromMap(params map[string]string) (*http.Request, os.Error) {\n \t\trawurl := \"http://\" + r.Host + params[\"REQUEST_URI\"]\n \t\turl, err := url.Parse(rawurl)\n \t\tif err != nil {\n-\t\t\treturn nil, os.NewError(\"cgi: failed to parse host and REQUEST_URI into a URL: \" + rawurl)\n+\t\t\treturn nil, errors.New(\"cgi: failed to parse host and REQUEST_URI into a URL: \" + rawurl)\n \t\t}\n \t\tr.URL = url\n \t}\n@@ -106,7 +107,7 @@ func RequestFromMap(params map[string]string) (*http.Request, os.Error) {\n \t\turiStr := params[\"REQUEST_URI\"]\n \t\turl, err := url.Parse(uriStr)\n \t\tif err != nil {\n-\t\t\treturn nil, os.NewError(\"cgi: failed to parse REQUEST_URI into a URL: \" + uriStr)\n+\t\t\treturn nil, errors.New(\"cgi: failed to parse REQUEST_URI into a URL: \" + uriStr)\n \t\t}\n \t\tr.URL = url\n \t}\n@@ -129,7 +130,7 @@ func RequestFromMap(params map[string]string) (*http.Request, os.Error) {\n // request, if any. If there's no current CGI environment\n // an error is returned. The provided handler may be nil to use\n // http.DefaultServeMux.\n-func Serve(handler http.Handler) os.Error {\n+func Serve(handler http.Handler) error {\n \treq, err := Request()\n \tif err != nil {\n \t\treturn err\n@@ -164,7 +165,7 @@ func (r *response) Header() http.Header {\n \treturn r.header\n }\n \n-func (r *response) Write(p []byte) (n int, err os.Error) {\n+func (r *response) Write(p []byte) (n int, err error) {\n \tif !r.headerSent {\n \t\tr.WriteHeader(http.StatusOK)\n \t}"}, {"sha": "8c999c0a36e57c2d53300688eb22b347d3b3d33a", "filename": "libgo/go/http/cgi/host.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -188,7 +188,7 @@ func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \t\tcwd = \".\"\n \t}\n \n-\tinternalError := func(err os.Error) {\n+\tinternalError := func(err error) {\n \t\trw.WriteHeader(http.StatusInternalServerError)\n \t\th.printf(\"CGI error: %v\", err)\n \t}\n@@ -227,7 +227,7 @@ func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \t\t\th.printf(\"cgi: long header line from subprocess.\")\n \t\t\treturn\n \t\t}\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\tbreak\n \t\t}\n \t\tif err != nil {"}, {"sha": "3227e329e0bdeff467ffbe5900375f4936ca2177", "filename": "libgo/go/http/cgi/host_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -45,7 +45,7 @@ readlines:\n \tfor {\n \t\tline, err := rw.Body.ReadString('\\n')\n \t\tswitch {\n-\t\tcase err == os.EOF:\n+\t\tcase err == io.EOF:\n \t\t\tbreak readlines\n \t\tcase err != nil:\n \t\t\tt.Fatalf(\"unexpected error reading from CGI: %v\", err)\n@@ -414,7 +414,7 @@ func TestDirWindows(t *testing.T) {\n \tcgifile, _ := filepath.Abs(\"testdata/test.cgi\")\n \n \tvar perl string\n-\tvar err os.Error\n+\tvar err error\n \tperl, err = exec.LookPath(\"perl\")\n \tif err != nil {\n \t\treturn\n@@ -456,7 +456,7 @@ func TestEnvOverride(t *testing.T) {\n \tcgifile, _ := filepath.Abs(\"testdata/test.cgi\")\n \n \tvar perl string\n-\tvar err os.Error\n+\tvar err error\n \tperl, err = exec.LookPath(\"perl\")\n \tif err != nil {\n \t\treturn"}, {"sha": "157e1c46c3b206fd3bd82de691279e92485b5702", "filename": "libgo/go/http/chunked.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fchunked.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fchunked.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fchunked.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"bufio\"\n \t\"io\"\n \t\"log\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n@@ -37,7 +36,7 @@ type chunkedWriter struct {\n // Write the contents of data as one chunk to Wire.\n // NOTE: Note that the corresponding chunk-writing procedure in Conn.Write has\n // a bug since it does not check for success of io.WriteString\n-func (cw *chunkedWriter) Write(data []byte) (n int, err os.Error) {\n+func (cw *chunkedWriter) Write(data []byte) (n int, err error) {\n \n \t// Don't send 0-length data. It looks like EOF for chunked encoding.\n \tif len(data) == 0 {\n@@ -61,7 +60,7 @@ func (cw *chunkedWriter) Write(data []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (cw *chunkedWriter) Close() os.Error {\n+func (cw *chunkedWriter) Close() error {\n \t_, err := io.WriteString(cw.Wire, \"0\\r\\n\")\n \treturn err\n }"}, {"sha": "503cc897a1044ac41ed68c4b45acef7066a864de", "filename": "libgo/go/http/client.go", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,9 +11,9 @@ package http\n \n import (\n \t\"encoding/base64\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"os\"\n \t\"strings\"\n \t\"url\"\n )\n@@ -37,7 +37,7 @@ type Client struct {\n \t//\n \t// If CheckRedirect is nil, the Client uses its default policy,\n \t// which is to stop after 10 consecutive requests.\n-\tCheckRedirect func(req *Request, via []*Request) os.Error\n+\tCheckRedirect func(req *Request, via []*Request) error\n }\n \n // DefaultClient is the default Client and is used by Get, Head, and Post.\n@@ -62,7 +62,7 @@ type RoundTripper interface {\n \t// RoundTrip should not modify the request, except for\n \t// consuming the Body.  The request's URL and Header fields\n \t// are guaranteed to be initialized.\n-\tRoundTrip(*Request) (*Response, os.Error)\n+\tRoundTrip(*Request) (*Response, error)\n }\n \n // Given a string of the form \"host\", \"host:port\", or \"[ipv6::address]:port\",\n@@ -88,25 +88,25 @@ type readClose struct {\n // connection to the server for a subsequent \"keep-alive\" request.\n //\n // Generally Get, Post, or PostForm will be used instead of Do.\n-func (c *Client) Do(req *Request) (resp *Response, err os.Error) {\n+func (c *Client) Do(req *Request) (resp *Response, err error) {\n \tif req.Method == \"GET\" || req.Method == \"HEAD\" {\n \t\treturn c.doFollowingRedirects(req)\n \t}\n \treturn send(req, c.Transport)\n }\n \n // send issues an HTTP request.  Caller should close resp.Body when done reading from it.\n-func send(req *Request, t RoundTripper) (resp *Response, err os.Error) {\n+func send(req *Request, t RoundTripper) (resp *Response, err error) {\n \tif t == nil {\n \t\tt = DefaultTransport\n \t\tif t == nil {\n-\t\t\terr = os.NewError(\"http: no Client.Transport or DefaultTransport\")\n+\t\t\terr = errors.New(\"http: no Client.Transport or DefaultTransport\")\n \t\t\treturn\n \t\t}\n \t}\n \n \tif req.URL == nil {\n-\t\treturn nil, os.NewError(\"http: nil Request.URL\")\n+\t\treturn nil, errors.New(\"http: nil Request.URL\")\n \t}\n \n \t// Most the callers of send (Get, Post, et al) don't need\n@@ -144,7 +144,7 @@ func shouldRedirect(statusCode int) bool {\n // Caller should close r.Body when done reading from it.\n //\n // Get is a convenience wrapper around DefaultClient.Get.\n-func Get(url string) (r *Response, err os.Error) {\n+func Get(url string) (r *Response, err error) {\n \treturn DefaultClient.Get(url)\n }\n \n@@ -158,15 +158,15 @@ func Get(url string) (r *Response, err os.Error) {\n //    307 (Temporary Redirect)\n //\n // Caller should close r.Body when done reading from it.\n-func (c *Client) Get(url string) (r *Response, err os.Error) {\n+func (c *Client) Get(url string) (r *Response, err error) {\n \treq, err := NewRequest(\"GET\", url, nil)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \treturn c.doFollowingRedirects(req)\n }\n \n-func (c *Client) doFollowingRedirects(ireq *Request) (r *Response, err os.Error) {\n+func (c *Client) doFollowingRedirects(ireq *Request) (r *Response, err error) {\n \t// TODO: if/when we add cookie support, the redirected request shouldn't\n \t// necessarily supply the same cookies as the original.\n \tvar base *url.URL\n@@ -177,7 +177,7 @@ func (c *Client) doFollowingRedirects(ireq *Request) (r *Response, err os.Error)\n \tvar via []*Request\n \n \tif ireq.URL == nil {\n-\t\treturn nil, os.NewError(\"http: nil Request.URL\")\n+\t\treturn nil, errors.New(\"http: nil Request.URL\")\n \t}\n \n \treq := ireq\n@@ -212,7 +212,7 @@ func (c *Client) doFollowingRedirects(ireq *Request) (r *Response, err os.Error)\n \t\tif shouldRedirect(r.StatusCode) {\n \t\t\tr.Body.Close()\n \t\t\tif urlStr = r.Header.Get(\"Location\"); urlStr == \"\" {\n-\t\t\t\terr = os.NewError(fmt.Sprintf(\"%d response missing Location header\", r.StatusCode))\n+\t\t\t\terr = errors.New(fmt.Sprintf(\"%d response missing Location header\", r.StatusCode))\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tbase = req.URL\n@@ -227,9 +227,9 @@ func (c *Client) doFollowingRedirects(ireq *Request) (r *Response, err os.Error)\n \treturn\n }\n \n-func defaultCheckRedirect(req *Request, via []*Request) os.Error {\n+func defaultCheckRedirect(req *Request, via []*Request) error {\n \tif len(via) >= 10 {\n-\t\treturn os.NewError(\"stopped after 10 redirects\")\n+\t\treturn errors.New(\"stopped after 10 redirects\")\n \t}\n \treturn nil\n }\n@@ -239,14 +239,14 @@ func defaultCheckRedirect(req *Request, via []*Request) os.Error {\n // Caller should close r.Body when done reading from it.\n //\n // Post is a wrapper around DefaultClient.Post\n-func Post(url string, bodyType string, body io.Reader) (r *Response, err os.Error) {\n+func Post(url string, bodyType string, body io.Reader) (r *Response, err error) {\n \treturn DefaultClient.Post(url, bodyType, body)\n }\n \n // Post issues a POST to the specified URL.\n //\n // Caller should close r.Body when done reading from it.\n-func (c *Client) Post(url string, bodyType string, body io.Reader) (r *Response, err os.Error) {\n+func (c *Client) Post(url string, bodyType string, body io.Reader) (r *Response, err error) {\n \treq, err := NewRequest(\"POST\", url, body)\n \tif err != nil {\n \t\treturn nil, err\n@@ -261,15 +261,15 @@ func (c *Client) Post(url string, bodyType string, body io.Reader) (r *Response,\n // Caller should close r.Body when done reading from it.\n //\n // PostForm is a wrapper around DefaultClient.PostForm\n-func PostForm(url string, data url.Values) (r *Response, err os.Error) {\n+func PostForm(url string, data url.Values) (r *Response, err error) {\n \treturn DefaultClient.PostForm(url, data)\n }\n \n // PostForm issues a POST to the specified URL, \n // with data's keys and values urlencoded as the request body.\n //\n // Caller should close r.Body when done reading from it.\n-func (c *Client) PostForm(url string, data url.Values) (r *Response, err os.Error) {\n+func (c *Client) PostForm(url string, data url.Values) (r *Response, err error) {\n \treturn c.Post(url, \"application/x-www-form-urlencoded\", strings.NewReader(data.Encode()))\n }\n \n@@ -283,7 +283,7 @@ func (c *Client) PostForm(url string, data url.Values) (r *Response, err os.Erro\n //    307 (Temporary Redirect)\n //\n // Head is a wrapper around DefaultClient.Head\n-func Head(url string) (r *Response, err os.Error) {\n+func Head(url string) (r *Response, err error) {\n \treturn DefaultClient.Head(url)\n }\n \n@@ -295,7 +295,7 @@ func Head(url string) (r *Response, err os.Error) {\n //    302 (Found)\n //    303 (See Other)\n //    307 (Temporary Redirect)\n-func (c *Client) Head(url string) (r *Response, err os.Error) {\n+func (c *Client) Head(url string) (r *Response, err error) {\n \treq, err := NewRequest(\"HEAD\", url, nil)\n \tif err != nil {\n \t\treturn nil, err"}, {"sha": "fdad2cdf54040f44f712ea06fe2f2abdba2a361d", "filename": "libgo/go/http/client_test.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,13 +8,13 @@ package http_test\n \n import (\n \t\"crypto/tls\"\n+\t\"errors\"\n \t\"fmt\"\n \t. \"http\"\n \t\"http/httptest\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"net\"\n-\t\"os\"\n \t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n@@ -60,9 +60,9 @@ type recordingTransport struct {\n \treq *Request\n }\n \n-func (t *recordingTransport) RoundTrip(req *Request) (resp *Response, err os.Error) {\n+func (t *recordingTransport) RoundTrip(req *Request) (resp *Response, err error) {\n \tt.req = req\n-\treturn nil, os.NewError(\"dummy impl\")\n+\treturn nil, errors.New(\"dummy impl\")\n }\n \n func TestGetRequestFormat(t *testing.T) {\n@@ -185,9 +185,9 @@ func TestRedirects(t *testing.T) {\n \t\tt.Errorf(\"with default client Do, expected error %q, got %q\", e, g)\n \t}\n \n-\tvar checkErr os.Error\n+\tvar checkErr error\n \tvar lastVia []*Request\n-\tc = &Client{CheckRedirect: func(_ *Request, via []*Request) os.Error {\n+\tc = &Client{CheckRedirect: func(_ *Request, via []*Request) error {\n \t\tlastVia = via\n \t\treturn checkErr\n \t}}\n@@ -203,7 +203,7 @@ func TestRedirects(t *testing.T) {\n \t\tt.Errorf(\"expected lastVia to have contained %d elements; got %d\", e, g)\n \t}\n \n-\tcheckErr = os.NewError(\"no redirects allowed\")\n+\tcheckErr = errors.New(\"no redirects allowed\")\n \tres, err = c.Get(ts.URL)\n \tfinalUrl = res.Request.URL.String()\n \tif e, g := \"Get /?n=1: no redirects allowed\", fmt.Sprintf(\"%v\", err); e != g {\n@@ -244,7 +244,7 @@ func TestStreamingGet(t *testing.T) {\n \t}\n \tclose(say)\n \t_, err = io.ReadFull(res.Body, buf[0:1])\n-\tif err != os.EOF {\n+\tif err != io.EOF {\n \t\tt.Fatalf(\"at end expected EOF, got %v\", err)\n \t}\n }\n@@ -254,7 +254,7 @@ type writeCountingConn struct {\n \tcount *int\n }\n \n-func (c *writeCountingConn) Write(p []byte) (int, os.Error) {\n+func (c *writeCountingConn) Write(p []byte) (int, error) {\n \t*c.count++\n \treturn c.Conn.Write(p)\n }\n@@ -267,7 +267,7 @@ func TestClientWrites(t *testing.T) {\n \tdefer ts.Close()\n \n \twrites := 0\n-\tdialer := func(netz string, addr string) (net.Conn, os.Error) {\n+\tdialer := func(netz string, addr string) (net.Conn, error) {\n \t\tc, err := net.Dial(netz, addr)\n \t\tif err == nil {\n \t\t\tc = &writeCountingConn{c, &writes}"}, {"sha": "9a537f90cb2c76f42cba86a4459594dca269d44d", "filename": "libgo/go/http/cookie_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fcookie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fcookie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcookie_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package http\n import (\n \t\"fmt\"\n \t\"json\"\n-\t\"os\"\n \t\"reflect\"\n \t\"testing\"\n \t\"time\"\n@@ -50,7 +49,7 @@ func (ho headerOnlyResponseWriter) Header() Header {\n \treturn Header(ho)\n }\n \n-func (ho headerOnlyResponseWriter) Write([]byte) (int, os.Error) {\n+func (ho headerOnlyResponseWriter) Write([]byte) (int, error) {\n \tpanic(\"NOIMPL\")\n }\n "}, {"sha": "b85feea3aebbc2d2bb5fc867fffb17f9b02a0dff", "filename": "libgo/go/http/dump.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fdump.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,14 +8,13 @@ import (\n \t\"bytes\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n )\n \n // One of the copies, say from b to r2, could be avoided by using a more\n // elaborate trick where the other copy is made during Request/Response.Write.\n // This would complicate things too much, given that these functions are for\n // debugging only.\n-func drainBody(b io.ReadCloser) (r1, r2 io.ReadCloser, err os.Error) {\n+func drainBody(b io.ReadCloser) (r1, r2 io.ReadCloser, err error) {\n \tvar buf bytes.Buffer\n \tif _, err = buf.ReadFrom(b); err != nil {\n \t\treturn nil, nil, err\n@@ -33,7 +32,7 @@ func drainBody(b io.ReadCloser) (r1, r2 io.ReadCloser, err os.Error) {\n // changes req.Body to refer to the in-memory copy.\n // The documentation for Request.Write details which fields\n // of req are used.\n-func DumpRequest(req *Request, body bool) (dump []byte, err os.Error) {\n+func DumpRequest(req *Request, body bool) (dump []byte, err error) {\n \tvar b bytes.Buffer\n \tsave := req.Body\n \tif !body || req.Body == nil {\n@@ -54,7 +53,7 @@ func DumpRequest(req *Request, body bool) (dump []byte, err os.Error) {\n }\n \n // DumpResponse is like DumpRequest but dumps a response.\n-func DumpResponse(resp *Response, body bool) (dump []byte, err os.Error) {\n+func DumpResponse(resp *Response, body bool) (dump []byte, err error) {\n \tvar b bytes.Buffer\n \tsave := resp.Body\n \tsavecl := resp.ContentLength"}, {"sha": "f6591e081e4c8b364153e57ad39cfe25a2d93b96", "filename": "libgo/go/http/fcgi/child.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffcgi%2Fchild.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -80,7 +80,7 @@ func (r *response) Header() http.Header {\n \treturn r.header\n }\n \n-func (r *response) Write(data []byte) (int, os.Error) {\n+func (r *response) Write(data []byte) (int, error) {\n \tif !r.wroteHeader {\n \t\tr.WriteHeader(http.StatusOK)\n \t}\n@@ -117,7 +117,7 @@ func (r *response) Flush() {\n \tr.w.Flush()\n }\n \n-func (r *response) Close() os.Error {\n+func (r *response) Close() error {\n \tr.Flush()\n \treturn r.w.Close()\n }\n@@ -214,7 +214,7 @@ func (c *child) serveRequest(req *request, body io.ReadCloser) {\n \tif err != nil {\n \t\t// there was an error reading the request\n \t\tr.WriteHeader(http.StatusInternalServerError)\n-\t\tc.conn.writeRecord(typeStderr, req.reqId, []byte(err.String()))\n+\t\tc.conn.writeRecord(typeStderr, req.reqId, []byte(err.Error()))\n \t} else {\n \t\thttpReq.Body = body\n \t\tc.handler.ServeHTTP(r, httpReq)\n@@ -234,9 +234,9 @@ func (c *child) serveRequest(req *request, body io.ReadCloser) {\n // to reply to them.\n // If l is nil, Serve accepts connections on stdin.\n // If handler is nil, http.DefaultServeMux is used.\n-func Serve(l net.Listener, handler http.Handler) os.Error {\n+func Serve(l net.Listener, handler http.Handler) error {\n \tif l == nil {\n-\t\tvar err os.Error\n+\t\tvar err error\n \t\tl, err = net.FileListener(os.Stdin)\n \t\tif err != nil {\n \t\t\treturn err"}, {"sha": "70cf781e228623aa23e904f344e5354030624b6e", "filename": "libgo/go/http/fcgi/fcgi.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -14,8 +14,8 @@ import (\n \t\"bufio\"\n \t\"bytes\"\n \t\"encoding/binary\"\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n \t\"sync\"\n )\n \n@@ -72,9 +72,9 @@ type beginRequest struct {\n \treserved [5]uint8\n }\n \n-func (br *beginRequest) read(content []byte) os.Error {\n+func (br *beginRequest) read(content []byte) error {\n \tif len(content) != 8 {\n-\t\treturn os.NewError(\"fcgi: invalid begin request record\")\n+\t\treturn errors.New(\"fcgi: invalid begin request record\")\n \t}\n \tbr.role = binary.BigEndian.Uint16(content)\n \tbr.flags = content[2]\n@@ -107,7 +107,7 @@ func newConn(rwc io.ReadWriteCloser) *conn {\n \treturn &conn{rwc: rwc}\n }\n \n-func (c *conn) Close() os.Error {\n+func (c *conn) Close() error {\n \tc.mutex.Lock()\n \tdefer c.mutex.Unlock()\n \treturn c.rwc.Close()\n@@ -118,12 +118,12 @@ type record struct {\n \tbuf [maxWrite + maxPad]byte\n }\n \n-func (rec *record) read(r io.Reader) (err os.Error) {\n+func (rec *record) read(r io.Reader) (err error) {\n \tif err = binary.Read(r, binary.BigEndian, &rec.h); err != nil {\n \t\treturn err\n \t}\n \tif rec.h.Version != 1 {\n-\t\treturn os.NewError(\"fcgi: invalid header version\")\n+\t\treturn errors.New(\"fcgi: invalid header version\")\n \t}\n \tn := int(rec.h.ContentLength) + int(rec.h.PaddingLength)\n \tif _, err = io.ReadFull(r, rec.buf[:n]); err != nil {\n@@ -137,7 +137,7 @@ func (r *record) content() []byte {\n }\n \n // writeRecord writes and sends a single record.\n-func (c *conn) writeRecord(recType uint8, reqId uint16, b []byte) os.Error {\n+func (c *conn) writeRecord(recType uint8, reqId uint16, b []byte) error {\n \tc.mutex.Lock()\n \tdefer c.mutex.Unlock()\n \tc.buf.Reset()\n@@ -155,19 +155,19 @@ func (c *conn) writeRecord(recType uint8, reqId uint16, b []byte) os.Error {\n \treturn err\n }\n \n-func (c *conn) writeBeginRequest(reqId uint16, role uint16, flags uint8) os.Error {\n+func (c *conn) writeBeginRequest(reqId uint16, role uint16, flags uint8) error {\n \tb := [8]byte{byte(role >> 8), byte(role), flags}\n \treturn c.writeRecord(typeBeginRequest, reqId, b[:])\n }\n \n-func (c *conn) writeEndRequest(reqId uint16, appStatus int, protocolStatus uint8) os.Error {\n+func (c *conn) writeEndRequest(reqId uint16, appStatus int, protocolStatus uint8) error {\n \tb := make([]byte, 8)\n \tbinary.BigEndian.PutUint32(b, uint32(appStatus))\n \tb[4] = protocolStatus\n \treturn c.writeRecord(typeEndRequest, reqId, b)\n }\n \n-func (c *conn) writePairs(recType uint8, reqId uint16, pairs map[string]string) os.Error {\n+func (c *conn) writePairs(recType uint8, reqId uint16, pairs map[string]string) error {\n \tw := newWriter(c, recType, reqId)\n \tb := make([]byte, 8)\n \tfor k, v := range pairs {\n@@ -227,7 +227,7 @@ type bufWriter struct {\n \t*bufio.Writer\n }\n \n-func (w *bufWriter) Close() os.Error {\n+func (w *bufWriter) Close() error {\n \tif err := w.Writer.Flush(); err != nil {\n \t\tw.closer.Close()\n \t\treturn err\n@@ -249,7 +249,7 @@ type streamWriter struct {\n \treqId   uint16\n }\n \n-func (w *streamWriter) Write(p []byte) (int, os.Error) {\n+func (w *streamWriter) Write(p []byte) (int, error) {\n \tnn := 0\n \tfor len(p) > 0 {\n \t\tn := len(p)\n@@ -265,7 +265,7 @@ func (w *streamWriter) Write(p []byte) (int, os.Error) {\n \treturn nn, nil\n }\n \n-func (w *streamWriter) Close() os.Error {\n+func (w *streamWriter) Close() error {\n \t// send empty record to close the stream\n \treturn w.c.writeRecord(w.recType, w.reqId, nil)\n }"}, {"sha": "e42f8efd65847a9555b35acdc8d8a70bd0a0d9d8", "filename": "libgo/go/http/fcgi/fcgi_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package fcgi\n import (\n \t\"bytes\"\n \t\"io\"\n-\t\"os\"\n \t\"testing\"\n )\n \n@@ -69,7 +68,7 @@ type nilCloser struct {\n \tio.ReadWriter\n }\n \n-func (c *nilCloser) Close() os.Error { return nil }\n+func (c *nilCloser) Close() error { return nil }\n \n func TestStreams(t *testing.T) {\n \tvar rec record"}, {"sha": "821787e0c4b2a2316fefde19db15c14feb5136c1", "filename": "libgo/go/http/filetransport.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffiletransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffiletransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffiletransport.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package http\n import (\n \t\"fmt\"\n \t\"io\"\n-\t\"os\"\n )\n \n // fileTransport implements RoundTripper for the 'file' protocol.\n@@ -32,7 +31,7 @@ func NewFileTransport(fs FileSystem) RoundTripper {\n \treturn fileTransport{fileHandler{fs}}\n }\n \n-func (t fileTransport) RoundTrip(req *Request) (resp *Response, err os.Error) {\n+func (t fileTransport) RoundTrip(req *Request) (resp *Response, err error) {\n \t// We start ServeHTTP in a goroutine, which may take a long\n \t// time if the file is large.  The newPopulateResponseWriter\n \t// call returns a channel which either ServeHTTP or finish()\n@@ -112,7 +111,7 @@ func (pr *populateResponse) WriteHeader(code int) {\n \tpr.res.Status = fmt.Sprintf(\"%d %s\", code, StatusText(code))\n }\n \n-func (pr *populateResponse) Write(p []byte) (n int, err os.Error) {\n+func (pr *populateResponse) Write(p []byte) (n int, err error) {\n \tif !pr.wroteHeader {\n \t\tpr.WriteHeader(StatusOK)\n \t}"}, {"sha": "aaee73e9c3c3b8a958ef24a714cb2160406fa469", "filename": "libgo/go/http/filetransport_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffiletransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffiletransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffiletransport_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,12 +8,11 @@ import (\n \t\"http\"\n \t\"io/ioutil\"\n \t\"path/filepath\"\n-\t\"os\"\n \t\"testing\"\n )\n \n-func checker(t *testing.T) func(string, os.Error) {\n-\treturn func(call string, err os.Error) {\n+func checker(t *testing.T) func(string, error) {\n+\treturn func(call string, err error) {\n \t\tif err == nil {\n \t\t\treturn\n \t\t}"}, {"sha": "eb0c67dfa198e8012b85618d7d5587d814c03b55", "filename": "libgo/go/http/fs.go", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,6 +7,7 @@\n package http\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"mime\"\n@@ -23,9 +24,9 @@ import (\n // system restricted to a specific directory tree.\n type Dir string\n \n-func (d Dir) Open(name string) (File, os.Error) {\n+func (d Dir) Open(name string) (File, error) {\n \tif filepath.Separator != '/' && strings.IndexRune(name, filepath.Separator) >= 0 {\n-\t\treturn nil, os.NewError(\"http: invalid character in file path\")\n+\t\treturn nil, errors.New(\"http: invalid character in file path\")\n \t}\n \tf, err := os.Open(filepath.Join(string(d), filepath.FromSlash(path.Clean(\"/\"+name))))\n \tif err != nil {\n@@ -38,17 +39,17 @@ func (d Dir) Open(name string) (File, os.Error) {\n // The elements in a file path are separated by slash ('/', U+002F)\n // characters, regardless of host operating system convention.\n type FileSystem interface {\n-\tOpen(name string) (File, os.Error)\n+\tOpen(name string) (File, error)\n }\n \n // A File is returned by a FileSystem's Open method and can be\n // served by the FileServer implementation.\n type File interface {\n-\tClose() os.Error\n-\tStat() (*os.FileInfo, os.Error)\n-\tReaddir(count int) ([]os.FileInfo, os.Error)\n-\tRead([]byte) (int, os.Error)\n-\tSeek(offset int64, whence int) (int64, os.Error)\n+\tClose() error\n+\tStat() (*os.FileInfo, error)\n+\tReaddir(count int) ([]os.FileInfo, error)\n+\tRead([]byte) (int, error)\n+\tSeek(offset int64, whence int) (int64, error)\n }\n \n // Heuristic: b is text if it is valid UTF-8 and doesn't\n@@ -194,16 +195,16 @@ func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirec\n \t// TODO(adg): handle multiple ranges\n \tranges, err := parseRange(r.Header.Get(\"Range\"), size)\n \tif err == nil && len(ranges) > 1 {\n-\t\terr = os.NewError(\"multiple ranges not supported\")\n+\t\terr = errors.New(\"multiple ranges not supported\")\n \t}\n \tif err != nil {\n-\t\tError(w, err.String(), StatusRequestedRangeNotSatisfiable)\n+\t\tError(w, err.Error(), StatusRequestedRangeNotSatisfiable)\n \t\treturn\n \t}\n \tif len(ranges) == 1 {\n \t\tra := ranges[0]\n \t\tif _, err := f.Seek(ra.start, os.SEEK_SET); err != nil {\n-\t\t\tError(w, err.String(), StatusRequestedRangeNotSatisfiable)\n+\t\t\tError(w, err.Error(), StatusRequestedRangeNotSatisfiable)\n \t\t\treturn\n \t\t}\n \t\tsize = ra.length\n@@ -269,19 +270,19 @@ type httpRange struct {\n }\n \n // parseRange parses a Range header string as per RFC 2616.\n-func parseRange(s string, size int64) ([]httpRange, os.Error) {\n+func parseRange(s string, size int64) ([]httpRange, error) {\n \tif s == \"\" {\n \t\treturn nil, nil // header not present\n \t}\n \tconst b = \"bytes=\"\n \tif !strings.HasPrefix(s, b) {\n-\t\treturn nil, os.NewError(\"invalid range\")\n+\t\treturn nil, errors.New(\"invalid range\")\n \t}\n \tvar ranges []httpRange\n \tfor _, ra := range strings.Split(s[len(b):], \",\") {\n \t\ti := strings.Index(ra, \"-\")\n \t\tif i < 0 {\n-\t\t\treturn nil, os.NewError(\"invalid range\")\n+\t\t\treturn nil, errors.New(\"invalid range\")\n \t\t}\n \t\tstart, end := ra[:i], ra[i+1:]\n \t\tvar r httpRange\n@@ -290,7 +291,7 @@ func parseRange(s string, size int64) ([]httpRange, os.Error) {\n \t\t\t// range start relative to the end of the file.\n \t\t\ti, err := strconv.Atoi64(end)\n \t\t\tif err != nil {\n-\t\t\t\treturn nil, os.NewError(\"invalid range\")\n+\t\t\t\treturn nil, errors.New(\"invalid range\")\n \t\t\t}\n \t\t\tif i > size {\n \t\t\t\ti = size\n@@ -300,7 +301,7 @@ func parseRange(s string, size int64) ([]httpRange, os.Error) {\n \t\t} else {\n \t\t\ti, err := strconv.Atoi64(start)\n \t\t\tif err != nil || i > size || i < 0 {\n-\t\t\t\treturn nil, os.NewError(\"invalid range\")\n+\t\t\t\treturn nil, errors.New(\"invalid range\")\n \t\t\t}\n \t\t\tr.start = i\n \t\t\tif end == \"\" {\n@@ -309,7 +310,7 @@ func parseRange(s string, size int64) ([]httpRange, os.Error) {\n \t\t\t} else {\n \t\t\t\ti, err := strconv.Atoi64(end)\n \t\t\t\tif err != nil || r.start > i {\n-\t\t\t\t\treturn nil, os.NewError(\"invalid range\")\n+\t\t\t\t\treturn nil, errors.New(\"invalid range\")\n \t\t\t\t}\n \t\t\t\tif i >= size {\n \t\t\t\t\ti = size - 1"}, {"sha": "76312e8bf0243f663cea8345975fb002b8845431", "filename": "libgo/go/http/fs_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -40,7 +40,7 @@ func TestServeFile(t *testing.T) {\n \t}))\n \tdefer ts.Close()\n \n-\tvar err os.Error\n+\tvar err error\n \n \tfile, err := ioutil.ReadFile(testFile)\n \tif err != nil {\n@@ -113,16 +113,16 @@ func TestFSRedirect(t *testing.T) {\n }\n \n type testFileSystem struct {\n-\topen func(name string) (File, os.Error)\n+\topen func(name string) (File, error)\n }\n \n-func (fs *testFileSystem) Open(name string) (File, os.Error) {\n+func (fs *testFileSystem) Open(name string) (File, error) {\n \treturn fs.open(name)\n }\n \n func TestFileServerCleans(t *testing.T) {\n \tch := make(chan string, 1)\n-\tfs := FileServer(&testFileSystem{func(name string) (File, os.Error) {\n+\tfs := FileServer(&testFileSystem{func(name string) (File, error) {\n \t\tch <- name\n \t\treturn nil, os.ENOENT\n \t}})"}, {"sha": "6be6016641d00a603a253fccdcd53a7909985f2d", "filename": "libgo/go/http/header.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fheader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fheader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fheader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"net/textproto\"\n-\t\"os\"\n \t\"sort\"\n \t\"strings\"\n )\n@@ -43,15 +42,15 @@ func (h Header) Del(key string) {\n }\n \n // Write writes a header in wire format.\n-func (h Header) Write(w io.Writer) os.Error {\n+func (h Header) Write(w io.Writer) error {\n \treturn h.WriteSubset(w, nil)\n }\n \n var headerNewlineToSpace = strings.NewReplacer(\"\\n\", \" \", \"\\r\", \" \")\n \n // WriteSubset writes a header in wire format.\n // If exclude is not nil, keys where exclude[key] == true are not written.\n-func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) os.Error {\n+func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error {\n \tkeys := make([]string, 0, len(h))\n \tfor k := range h {\n \t\tif exclude == nil || !exclude[k] {"}, {"sha": "f69279f7c1c037c94e0ceef9099508cd402778d4", "filename": "libgo/go/http/httptest/recorder.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fhttptest%2Frecorder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fhttptest%2Frecorder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fhttptest%2Frecorder.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,7 +8,6 @@ package httptest\n import (\n \t\"bytes\"\n \t\"http\"\n-\t\"os\"\n )\n \n // ResponseRecorder is an implementation of http.ResponseWriter that\n@@ -38,7 +37,7 @@ func (rw *ResponseRecorder) Header() http.Header {\n }\n \n // Write always succeeds and writes to rw.Body, if not nil.\n-func (rw *ResponseRecorder) Write(buf []byte) (int, os.Error) {\n+func (rw *ResponseRecorder) Write(buf []byte) (int, error) {\n \tif rw.Body != nil {\n \t\trw.Body.Write(buf)\n \t}"}, {"sha": "ea719cfbd560ef9742b606d2275d4b0c4e7a164e", "filename": "libgo/go/http/httptest/server.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fhttptest%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fhttptest%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fhttptest%2Fserver.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -36,7 +36,7 @@ type historyListener struct {\n \thistory []net.Conn\n }\n \n-func (hs *historyListener) Accept() (c net.Conn, err os.Error) {\n+func (hs *historyListener) Accept() (c net.Conn, err error) {\n \tc, err = hs.Listener.Accept()\n \tif err == nil {\n \t\ths.history = append(hs.history, c)"}, {"sha": "7d84e96f2b99270282fb72448564871622f2325f", "filename": "libgo/go/http/persist.go", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fpersist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fpersist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fpersist.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,6 +6,7 @@ package http\n \n import (\n \t\"bufio\"\n+\t\"errors\"\n \t\"io\"\n \t\"net\"\n \t\"net/textproto\"\n@@ -31,7 +32,7 @@ type ServerConn struct {\n \tlk              sync.Mutex // read-write protects the following fields\n \tc               net.Conn\n \tr               *bufio.Reader\n-\tre, we          os.Error // read/write errors\n+\tre, we          error // read/write errors\n \tlastbody        io.ReadCloser\n \tnread, nwritten int\n \tpipereq         map[*Request]uint\n@@ -63,7 +64,7 @@ func (sc *ServerConn) Hijack() (c net.Conn, r *bufio.Reader) {\n }\n \n // Close calls Hijack and then also closes the underlying connection\n-func (sc *ServerConn) Close() os.Error {\n+func (sc *ServerConn) Close() error {\n \tc, _ := sc.Hijack()\n \tif c != nil {\n \t\treturn c.Close()\n@@ -75,7 +76,7 @@ func (sc *ServerConn) Close() os.Error {\n // it is gracefully determined that there are no more requests (e.g. after the\n // first request on an HTTP/1.0 connection, or after a Connection:close on a\n // HTTP/1.1 connection).\n-func (sc *ServerConn) Read() (req *Request, err os.Error) {\n+func (sc *ServerConn) Read() (req *Request, err error) {\n \n \t// Ensure ordered execution of Reads and Writes\n \tid := sc.pipe.Next()\n@@ -160,7 +161,7 @@ func (sc *ServerConn) Pending() int {\n // Write writes resp in response to req. To close the connection gracefully, set the\n // Response.Close field to true. Write should be considered operational until\n // it returns an error, regardless of any errors returned on the Read side.\n-func (sc *ServerConn) Write(req *Request, resp *Response) os.Error {\n+func (sc *ServerConn) Write(req *Request, resp *Response) error {\n \n \t// Retrieve the pipeline ID of this request/response pair\n \tsc.lk.Lock()\n@@ -188,7 +189,7 @@ func (sc *ServerConn) Write(req *Request, resp *Response) os.Error {\n \tc := sc.c\n \tif sc.nread <= sc.nwritten {\n \t\tdefer sc.lk.Unlock()\n-\t\treturn os.NewError(\"persist server pipe count\")\n+\t\treturn errors.New(\"persist server pipe count\")\n \t}\n \tif resp.Close {\n \t\t// After signaling a keep-alive close, any pipelined unread\n@@ -221,13 +222,13 @@ type ClientConn struct {\n \tlk              sync.Mutex // read-write protects the following fields\n \tc               net.Conn\n \tr               *bufio.Reader\n-\tre, we          os.Error // read/write errors\n+\tre, we          error // read/write errors\n \tlastbody        io.ReadCloser\n \tnread, nwritten int\n \tpipereq         map[*Request]uint\n \n \tpipe     textproto.Pipeline\n-\twriteReq func(*Request, io.Writer) os.Error\n+\twriteReq func(*Request, io.Writer) error\n }\n \n // NewClientConn returns a new ClientConn reading and writing c.  If r is not\n@@ -267,7 +268,7 @@ func (cc *ClientConn) Hijack() (c net.Conn, r *bufio.Reader) {\n }\n \n // Close calls Hijack and then also closes the underlying connection\n-func (cc *ClientConn) Close() os.Error {\n+func (cc *ClientConn) Close() error {\n \tc, _ := cc.Hijack()\n \tif c != nil {\n \t\treturn c.Close()\n@@ -280,7 +281,7 @@ func (cc *ClientConn) Close() os.Error {\n // keepalive connection is logically closed after this request and the opposing\n // server is informed. An ErrUnexpectedEOF indicates the remote closed the\n // underlying TCP connection, which is usually considered as graceful close.\n-func (cc *ClientConn) Write(req *Request) (err os.Error) {\n+func (cc *ClientConn) Write(req *Request) (err error) {\n \n \t// Ensure ordered execution of Writes\n \tid := cc.pipe.Next()\n@@ -343,13 +344,13 @@ func (cc *ClientConn) Pending() int {\n // returned together with an ErrPersistEOF, which means that the remote\n // requested that this be the last request serviced. Read can be called\n // concurrently with Write, but not with another Read.\n-func (cc *ClientConn) Read(req *Request) (*Response, os.Error) {\n+func (cc *ClientConn) Read(req *Request) (*Response, error) {\n \treturn cc.readUsing(req, ReadResponse)\n }\n \n // readUsing is the implementation of Read with a replaceable\n // ReadResponse-like function, used by the Transport.\n-func (cc *ClientConn) readUsing(req *Request, readRes func(*bufio.Reader, *Request) (*Response, os.Error)) (resp *Response, err os.Error) {\n+func (cc *ClientConn) readUsing(req *Request, readRes func(*bufio.Reader, *Request) (*Response, error)) (resp *Response, err error) {\n \t// Retrieve the pipeline ID of this request/response pair\n \tcc.lk.Lock()\n \tid, ok := cc.pipereq[req]\n@@ -411,7 +412,7 @@ func (cc *ClientConn) readUsing(req *Request, readRes func(*bufio.Reader, *Reque\n }\n \n // Do is convenience method that writes a request and reads a response.\n-func (cc *ClientConn) Do(req *Request) (resp *Response, err os.Error) {\n+func (cc *ClientConn) Do(req *Request) (resp *Response, err error) {\n \terr = cc.Write(req)\n \tif err != nil {\n \t\treturn"}, {"sha": "a118a259b6ad3e4d70f413f74f43cd0772855a3c", "filename": "libgo/go/http/pprof/pprof.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fpprof%2Fpprof.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -29,6 +29,7 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"http\"\n+\t\"io\"\n \t\"os\"\n \t\"runtime\"\n \t\"runtime/pprof\"\n@@ -121,7 +122,7 @@ func Symbol(w http.ResponseWriter, r *http.Request) {\n \t\t// Wait until here to check for err; the last\n \t\t// symbol will have an err because it doesn't end in +.\n \t\tif err != nil {\n-\t\t\tif err != os.EOF {\n+\t\t\tif err != io.EOF {\n \t\t\t\tfmt.Fprintf(&buf, \"reading request: %v\\n\", err)\n \t\t\t}\n \t\t\tbreak"}, {"sha": "d62133df43dadb2cf628989d6cf640ab6a79315e", "filename": "libgo/go/http/readrequest_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Freadrequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Freadrequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Freadrequest_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -159,8 +159,8 @@ func TestReadRequest(t *testing.T) {\n \t\tbraw.WriteString(tt.Raw)\n \t\treq, err := ReadRequest(bufio.NewReader(&braw))\n \t\tif err != nil {\n-\t\t\tif err.String() != tt.Error {\n-\t\t\t\tt.Errorf(\"#%d: error %q, want error %q\", i, err.String(), tt.Error)\n+\t\t\tif err.Error() != tt.Error {\n+\t\t\t\tt.Errorf(\"#%d: error %q, want error %q\", i, err.Error(), tt.Error)\n \t\t\t}\n \t\t\tcontinue\n \t\t}"}, {"sha": "d9a04efe3eb94d1cd53618e068b401d510d5fd88", "filename": "libgo/go/http/request.go", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequest.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,13 +11,13 @@ import (\n \t\"bytes\"\n \t\"crypto/tls\"\n \t\"encoding/base64\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"mime\"\n \t\"mime/multipart\"\n \t\"net/textproto\"\n-\t\"os\"\n \t\"strconv\"\n \t\"strings\"\n \t\"url\"\n@@ -33,14 +33,14 @@ const (\n \n // ErrMissingFile is returned by FormFile when the provided file field name\n // is either not present in the request or not a file field.\n-var ErrMissingFile = os.NewError(\"http: no such file\")\n+var ErrMissingFile = errors.New(\"http: no such file\")\n \n // HTTP request parsing errors.\n type ProtocolError struct {\n \tErrorString string\n }\n \n-func (err *ProtocolError) String() string { return err.ErrorString }\n+func (err *ProtocolError) Error() string { return err.ErrorString }\n \n var (\n \tErrLineTooLong          = &ProtocolError{\"header line too long\"}\n@@ -58,7 +58,7 @@ type badStringError struct {\n \tstr  string\n }\n \n-func (e *badStringError) String() string { return fmt.Sprintf(\"%s %q\", e.what, e.str) }\n+func (e *badStringError) Error() string { return fmt.Sprintf(\"%s %q\", e.what, e.str) }\n \n // Headers that Request.Write handles itself and should be skipped.\n var reqWriteExcludeHeader = map[string]bool{\n@@ -174,11 +174,11 @@ func (r *Request) Cookies() []*Cookie {\n \treturn readCookies(r.Header, \"\")\n }\n \n-var ErrNoCookie = os.NewError(\"http: named cookied not present\")\n+var ErrNoCookie = errors.New(\"http: named cookied not present\")\n \n // Cookie returns the named cookie provided in the request or\n // ErrNoCookie if not found.\n-func (r *Request) Cookie(name string) (*Cookie, os.Error) {\n+func (r *Request) Cookie(name string) (*Cookie, error) {\n \tfor _, c := range readCookies(r.Header, name) {\n \t\treturn c, nil\n \t}\n@@ -222,18 +222,18 @@ var multipartByReader = &multipart.Form{\n // multipart/form-data POST request, else returns nil and an error.\n // Use this function instead of ParseMultipartForm to\n // process the request body as a stream.\n-func (r *Request) MultipartReader() (*multipart.Reader, os.Error) {\n+func (r *Request) MultipartReader() (*multipart.Reader, error) {\n \tif r.MultipartForm == multipartByReader {\n-\t\treturn nil, os.NewError(\"http: MultipartReader called twice\")\n+\t\treturn nil, errors.New(\"http: MultipartReader called twice\")\n \t}\n \tif r.MultipartForm != nil {\n-\t\treturn nil, os.NewError(\"http: multipart handled by ParseMultipartForm\")\n+\t\treturn nil, errors.New(\"http: multipart handled by ParseMultipartForm\")\n \t}\n \tr.MultipartForm = multipartByReader\n \treturn r.multipartReader()\n }\n \n-func (r *Request) multipartReader() (*multipart.Reader, os.Error) {\n+func (r *Request) multipartReader() (*multipart.Reader, error) {\n \tv := r.Header.Get(\"Content-Type\")\n \tif v == \"\" {\n \t\treturn nil, ErrNotMultipart\n@@ -272,7 +272,7 @@ const defaultUserAgent = \"Go http package\"\n // If Body is present, Content-Length is <= 0 and TransferEncoding\n // hasn't been set to \"identity\", Write adds \"Transfer-Encoding:\n // chunked\" to the header. Body is closed after it is sent.\n-func (req *Request) Write(w io.Writer) os.Error {\n+func (req *Request) Write(w io.Writer) error {\n \treturn req.write(w, false, nil)\n }\n \n@@ -282,11 +282,11 @@ func (req *Request) Write(w io.Writer) os.Error {\n // section 5.1.2 of RFC 2616, including the scheme and host. In\n // either case, WriteProxy also writes a Host header, using either\n // req.Host or req.URL.Host.\n-func (req *Request) WriteProxy(w io.Writer) os.Error {\n+func (req *Request) WriteProxy(w io.Writer) error {\n \treturn req.write(w, true, nil)\n }\n \n-func (req *Request) dumpWrite(w io.Writer) os.Error {\n+func (req *Request) dumpWrite(w io.Writer) error {\n \t// TODO(bradfitz): RawPath here?\n \turlStr := valueOrDefault(req.URL.EncodedPath(), \"/\")\n \tif req.URL.RawQuery != \"\" {\n@@ -332,11 +332,11 @@ func (req *Request) dumpWrite(w io.Writer) os.Error {\n }\n \n // extraHeaders may be nil\n-func (req *Request) write(w io.Writer, usingProxy bool, extraHeaders Header) os.Error {\n+func (req *Request) write(w io.Writer, usingProxy bool, extraHeaders Header) error {\n \thost := req.Host\n \tif host == \"\" {\n \t\tif req.URL == nil {\n-\t\t\treturn os.NewError(\"http: Request.Write on Request with no Host or URL set\")\n+\t\t\treturn errors.New(\"http: Request.Write on Request with no Host or URL set\")\n \t\t}\n \t\thost = req.URL.Host\n \t}\n@@ -415,11 +415,11 @@ func (req *Request) write(w io.Writer, usingProxy bool, extraHeaders Header) os.\n // Give up if the line exceeds maxLineLength.\n // The returned bytes are a pointer into storage in\n // the bufio, so they are only valid until the next bufio read.\n-func readLineBytes(b *bufio.Reader) (p []byte, err os.Error) {\n+func readLineBytes(b *bufio.Reader) (p []byte, err error) {\n \tif p, err = b.ReadSlice('\\n'); err != nil {\n \t\t// We always know when EOF is coming.\n \t\t// If the caller asked for a line, there should be a line.\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\terr = io.ErrUnexpectedEOF\n \t\t} else if err == bufio.ErrBufferFull {\n \t\t\terr = ErrLineTooLong\n@@ -441,7 +441,7 @@ func readLineBytes(b *bufio.Reader) (p []byte, err os.Error) {\n }\n \n // readLineBytes, but convert the bytes into a string.\n-func readLine(b *bufio.Reader) (s string, err os.Error) {\n+func readLine(b *bufio.Reader) (s string, err error) {\n \tp, e := readLineBytes(b)\n \tif e != nil {\n \t\treturn \"\", e\n@@ -487,7 +487,7 @@ func ParseHTTPVersion(vers string) (major, minor int, ok bool) {\n type chunkedReader struct {\n \tr   *bufio.Reader\n \tn   uint64 // unread bytes in chunk\n-\terr os.Error\n+\terr error\n }\n \n func (cr *chunkedReader) beginChunk() {\n@@ -512,11 +512,11 @@ func (cr *chunkedReader) beginChunk() {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n-\t\tcr.err = os.EOF\n+\t\tcr.err = io.EOF\n \t}\n }\n \n-func (cr *chunkedReader) Read(b []uint8) (n int, err os.Error) {\n+func (cr *chunkedReader) Read(b []uint8) (n int, err error) {\n \tif cr.err != nil {\n \t\treturn 0, cr.err\n \t}\n@@ -536,15 +536,15 @@ func (cr *chunkedReader) Read(b []uint8) (n int, err os.Error) {\n \t\tb := make([]byte, 2)\n \t\tif _, cr.err = io.ReadFull(cr.r, b); cr.err == nil {\n \t\t\tif b[0] != '\\r' || b[1] != '\\n' {\n-\t\t\t\tcr.err = os.NewError(\"malformed chunked encoding\")\n+\t\t\t\tcr.err = errors.New(\"malformed chunked encoding\")\n \t\t\t}\n \t\t}\n \t}\n \treturn n, cr.err\n }\n \n // NewRequest returns a new Request given a method, URL, and optional body.\n-func NewRequest(method, urlStr string, body io.Reader) (*Request, os.Error) {\n+func NewRequest(method, urlStr string, body io.Reader) (*Request, error) {\n \tu, err := url.Parse(urlStr)\n \tif err != nil {\n \t\treturn nil, err\n@@ -586,15 +586,15 @@ func (r *Request) SetBasicAuth(username, password string) {\n }\n \n // ReadRequest reads and parses a request from b.\n-func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {\n+func ReadRequest(b *bufio.Reader) (req *Request, err error) {\n \n \ttp := textproto.NewReader(b)\n \treq = new(Request)\n \n \t// First line: GET /index.html HTTP/1.0\n \tvar s string\n \tif s, err = tp.ReadLine(); err != nil {\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\terr = io.ErrUnexpectedEOF\n \t\t}\n \t\treturn nil, err\n@@ -690,15 +690,15 @@ type maxBytesReader struct {\n \tstopped bool\n }\n \n-func (l *maxBytesReader) Read(p []byte) (n int, err os.Error) {\n+func (l *maxBytesReader) Read(p []byte) (n int, err error) {\n \tif l.n <= 0 {\n \t\tif !l.stopped {\n \t\t\tl.stopped = true\n \t\t\tif res, ok := l.w.(*response); ok {\n \t\t\t\tres.requestTooLarge()\n \t\t\t}\n \t\t}\n-\t\treturn 0, os.NewError(\"http: request body too large\")\n+\t\treturn 0, errors.New(\"http: request body too large\")\n \t}\n \tif int64(len(p)) > l.n {\n \t\tp = p[:l.n]\n@@ -708,7 +708,7 @@ func (l *maxBytesReader) Read(p []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (l *maxBytesReader) Close() os.Error {\n+func (l *maxBytesReader) Close() error {\n \treturn l.r.Close()\n }\n \n@@ -720,7 +720,7 @@ func (l *maxBytesReader) Close() os.Error {\n //\n // ParseMultipartForm calls ParseForm automatically.\n // It is idempotent.\n-func (r *Request) ParseForm() (err os.Error) {\n+func (r *Request) ParseForm() (err error) {\n \tif r.Form != nil {\n \t\treturn\n \t}\n@@ -729,7 +729,7 @@ func (r *Request) ParseForm() (err os.Error) {\n \t}\n \tif r.Method == \"POST\" || r.Method == \"PUT\" {\n \t\tif r.Body == nil {\n-\t\t\treturn os.NewError(\"missing form body\")\n+\t\t\treturn errors.New(\"missing form body\")\n \t\t}\n \t\tct := r.Header.Get(\"Content-Type\")\n \t\tct, _, err := mime.ParseMediaType(ct)\n@@ -749,7 +749,7 @@ func (r *Request) ParseForm() (err os.Error) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tif int64(len(b)) > maxFormSize {\n-\t\t\t\treturn os.NewError(\"http: POST too large\")\n+\t\t\t\treturn errors.New(\"http: POST too large\")\n \t\t\t}\n \t\t\tvar newValues url.Values\n \t\t\tnewValues, e = url.ParseQuery(string(b))\n@@ -785,9 +785,9 @@ func (r *Request) ParseForm() (err os.Error) {\n // disk in temporary files.\n // ParseMultipartForm calls ParseForm if necessary.\n // After one call to ParseMultipartForm, subsequent calls have no effect.\n-func (r *Request) ParseMultipartForm(maxMemory int64) os.Error {\n+func (r *Request) ParseMultipartForm(maxMemory int64) error {\n \tif r.MultipartForm == multipartByReader {\n-\t\treturn os.NewError(\"http: multipart handled by MultipartReader\")\n+\t\treturn errors.New(\"http: multipart handled by MultipartReader\")\n \t}\n \tif r.Form == nil {\n \t\terr := r.ParseForm()\n@@ -832,9 +832,9 @@ func (r *Request) FormValue(key string) string {\n \n // FormFile returns the first file for the provided form key.\n // FormFile calls ParseMultipartForm and ParseForm if necessary.\n-func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, os.Error) {\n+func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error) {\n \tif r.MultipartForm == multipartByReader {\n-\t\treturn nil, nil, os.NewError(\"http: multipart handled by MultipartReader\")\n+\t\treturn nil, nil, errors.New(\"http: multipart handled by MultipartReader\")\n \t}\n \tif r.MultipartForm == nil {\n \t\terr := r.ParseMultipartForm(defaultMaxMemory)"}, {"sha": "9be9efcc87d34c1df237732c40c7cfa804ba6585", "filename": "libgo/go/http/request_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Frequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Frequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequest_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -49,7 +49,7 @@ func TestPostQuery(t *testing.T) {\n type stringMap map[string][]string\n type parseContentTypeTest struct {\n \tcontentType stringMap\n-\terror       bool\n+\terr         bool\n }\n \n var parseContentTypeTests = []parseContentTypeTest{\n@@ -58,7 +58,7 @@ var parseContentTypeTests = []parseContentTypeTest{\n \t{contentType: stringMap{\"Content-Type\": {\"text/plain; boundary=\"}}},\n \t{\n \t\tcontentType: stringMap{\"Content-Type\": {\"application/unknown\"}},\n-\t\terror:       true,\n+\t\terr:         true,\n \t},\n }\n \n@@ -70,10 +70,10 @@ func TestPostContentTypeParsing(t *testing.T) {\n \t\t\tBody:   ioutil.NopCloser(bytes.NewBufferString(\"body\")),\n \t\t}\n \t\terr := req.ParseForm()\n-\t\tif !test.error && err != nil {\n+\t\tif !test.err && err != nil {\n \t\t\tt.Errorf(\"test %d: Unexpected error: %v\", i, err)\n \t\t}\n-\t\tif test.error && err == nil {\n+\t\tif test.err && err == nil {\n \t\t\tt.Errorf(\"test %d should have returned error\", i)\n \t\t}\n \t}"}, {"sha": "16593e987aa542898b5d4ceabcad50233b43064f", "filename": "libgo/go/http/requestwrite_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,10 +6,10 @@ package http\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"strings\"\n \t\"testing\"\n \t\"url\"\n@@ -24,7 +24,7 @@ type reqWriteTest struct {\n \tWantProxy string // Request.WriteProxy\n \tWantDump  string // DumpRequest\n \n-\tWantError os.Error // wanted error from Request.Write\n+\tWantError error // wanted error from Request.Write\n }\n \n var reqWriteTests = []reqWriteTest{\n@@ -292,7 +292,7 @@ var reqWriteTests = []reqWriteTest{\n \t\t\tContentLength: 10, // but we're going to send only 5 bytes\n \t\t},\n \t\tBody:      []byte(\"12345\"),\n-\t\tWantError: os.NewError(\"http: Request.ContentLength=10 with Body length 5\"),\n+\t\tWantError: errors.New(\"http: Request.ContentLength=10 with Body length 5\"),\n \t},\n \n \t// Request with a ContentLength of 4 but an 8 byte body.\n@@ -306,7 +306,7 @@ var reqWriteTests = []reqWriteTest{\n \t\t\tContentLength: 4, // but we're going to try to send 8 bytes\n \t\t},\n \t\tBody:      []byte(\"12345678\"),\n-\t\tWantError: os.NewError(\"http: Request.ContentLength=4 with Body length 8\"),\n+\t\tWantError: errors.New(\"http: Request.ContentLength=4 with Body length 8\"),\n \t},\n \n \t// Request with a 5 ContentLength and nil body.\n@@ -319,7 +319,7 @@ var reqWriteTests = []reqWriteTest{\n \t\t\tProtoMinor:    1,\n \t\t\tContentLength: 5, // but we'll omit the body\n \t\t},\n-\t\tWantError: os.NewError(\"http: Request.ContentLength=5 with nil Body\"),\n+\t\tWantError: errors.New(\"http: Request.ContentLength=5 with nil Body\"),\n \t},\n \n \t// Verify that DumpRequest preserves the HTTP version number, doesn't add a Host,\n@@ -422,7 +422,7 @@ type closeChecker struct {\n \tclosed bool\n }\n \n-func (rc *closeChecker) Close() os.Error {\n+func (rc *closeChecker) Close() error {\n \trc.closed = true\n \treturn nil\n }"}, {"sha": "7be7150ef134ab057ccacc442a9069b379047ff1", "filename": "libgo/go/http/response.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponse.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,9 +8,9 @@ package http\n \n import (\n \t\"bufio\"\n+\t\"errors\"\n \t\"io\"\n \t\"net/textproto\"\n-\t\"os\"\n \t\"strconv\"\n \t\"strings\"\n \t\"url\"\n@@ -78,13 +78,13 @@ func (r *Response) Cookies() []*Cookie {\n \treturn readSetCookies(r.Header)\n }\n \n-var ErrNoLocation = os.NewError(\"http: no Location header in response\")\n+var ErrNoLocation = errors.New(\"http: no Location header in response\")\n \n // Location returns the URL of the response's \"Location\" header,\n // if present.  Relative redirects are resolved relative to\n // the Response's Request.  ErrNoLocation is returned if no\n // Location header is present.\n-func (r *Response) Location() (*url.URL, os.Error) {\n+func (r *Response) Location() (*url.URL, error) {\n \tlv := r.Header.Get(\"Location\")\n \tif lv == \"\" {\n \t\treturn nil, ErrNoLocation\n@@ -101,7 +101,7 @@ func (r *Response) Location() (*url.URL, os.Error) {\n // reading resp.Body.  After that call, clients can inspect\n // resp.Trailer to find key/value pairs included in the response\n // trailer.\n-func ReadResponse(r *bufio.Reader, req *Request) (resp *Response, err os.Error) {\n+func ReadResponse(r *bufio.Reader, req *Request) (resp *Response, err error) {\n \n \ttp := textproto.NewReader(r)\n \tresp = new(Response)\n@@ -112,7 +112,7 @@ func ReadResponse(r *bufio.Reader, req *Request) (resp *Response, err os.Error)\n \t// Parse the first line of the response.\n \tline, err := tp.ReadLine()\n \tif err != nil {\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\terr = io.ErrUnexpectedEOF\n \t\t}\n \t\treturn nil, err\n@@ -186,7 +186,7 @@ func (r *Response) ProtoAtLeast(major, minor int) bool {\n //  ContentLength\n //  Header, values for non-canonical keys will have unpredictable behavior\n //\n-func (resp *Response) Write(w io.Writer) os.Error {\n+func (resp *Response) Write(w io.Writer) error {\n \n \t// RequestMethod should be upper-case\n \tif resp.Request != nil {"}, {"sha": "6a141796bbbd4eb6f5b7bc8ae9960a54eca3cb43", "filename": "libgo/go/http/response_test.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fresponse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fresponse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponse_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,7 +10,6 @@ import (\n \t\"compress/gzip\"\n \t\"crypto/rand\"\n \t\"fmt\"\n-\t\"os\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"reflect\"\n@@ -301,7 +300,7 @@ func TestReadResponseCloseInMiddle(t *testing.T) {\n \t\t\targs = append([]interface{}{test.chunked, test.compressed}, args...)\n \t\t\tt.Fatalf(\"on test chunked=%v, compressed=%v: \"+format, args...)\n \t\t}\n-\t\tcheckErr := func(err os.Error, msg string) {\n+\t\tcheckErr := func(err error, msg string) {\n \t\t\tif err == nil {\n \t\t\t\treturn\n \t\t\t}\n@@ -320,7 +319,7 @@ func TestReadResponseCloseInMiddle(t *testing.T) {\n \t\t}\n \t\tif test.compressed {\n \t\t\tbuf.WriteString(\"Content-Encoding: gzip\\r\\n\")\n-\t\t\tvar err os.Error\n+\t\t\tvar err error\n \t\t\twr, err = gzip.NewWriter(wr)\n \t\t\tcheckErr(err, \"gzip.NewWriter\")\n \t\t}\n@@ -401,7 +400,7 @@ type responseLocationTest struct {\n \tlocation string // Response's Location header or \"\"\n \trequrl   string // Response.Request.URL or \"\"\n \twant     string\n-\twantErr  os.Error\n+\twantErr  error\n }\n \n var responseLocationTests = []responseLocationTest{\n@@ -417,7 +416,7 @@ func TestLocationResponse(t *testing.T) {\n \t\tres.Header.Set(\"Location\", tt.location)\n \t\tif tt.requrl != \"\" {\n \t\t\tres.Request = &Request{}\n-\t\t\tvar err os.Error\n+\t\t\tvar err error\n \t\t\tres.Request.URL, err = url.Parse(tt.requrl)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"bad test URL %q: %v\", tt.requrl, err)\n@@ -430,7 +429,7 @@ func TestLocationResponse(t *testing.T) {\n \t\t\t\tt.Errorf(\"%d. err=nil; want %q\", i, tt.wantErr)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif g, e := err.String(), tt.wantErr.String(); g != e {\n+\t\t\tif g, e := err.Error(), tt.wantErr.Error(); g != e {\n \t\t\t\tt.Errorf(\"%d. err=%q; want %q\", i, g, e)\n \t\t\t\tcontinue\n \t\t\t}"}, {"sha": "9cd359f16b9d323bde338a52f98221a76757ba61", "filename": "libgo/go/http/reverseproxy.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Freverseproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Freverseproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Freverseproxy.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,7 +10,6 @@ import (\n \t\"io\"\n \t\"log\"\n \t\"net\"\n-\t\"os\"\n \t\"strings\"\n \t\"sync\"\n \t\"time\"\n@@ -141,7 +140,7 @@ type maxLatencyWriter struct {\n \tdone chan bool\n }\n \n-func (m *maxLatencyWriter) Write(p []byte) (n int, err os.Error) {\n+func (m *maxLatencyWriter) Write(p []byte) (n int, err error) {\n \tm.lk.Lock()\n \tdefer m.lk.Unlock()\n \tif m.done == nil {"}, {"sha": "98e10d433e889ee313f03ffc9c36072c3752bea4", "filename": "libgo/go/http/serve_test.go", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserve_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -31,18 +31,18 @@ type oneConnListener struct {\n \tconn net.Conn\n }\n \n-func (l *oneConnListener) Accept() (c net.Conn, err os.Error) {\n+func (l *oneConnListener) Accept() (c net.Conn, err error) {\n \tc = l.conn\n \tif c == nil {\n-\t\terr = os.EOF\n+\t\terr = io.EOF\n \t\treturn\n \t}\n \terr = nil\n \tl.conn = nil\n \treturn\n }\n \n-func (l *oneConnListener) Close() os.Error {\n+func (l *oneConnListener) Close() error {\n \treturn nil\n }\n \n@@ -63,15 +63,15 @@ type testConn struct {\n \twriteBuf bytes.Buffer\n }\n \n-func (c *testConn) Read(b []byte) (int, os.Error) {\n+func (c *testConn) Read(b []byte) (int, error) {\n \treturn c.readBuf.Read(b)\n }\n \n-func (c *testConn) Write(b []byte) (int, os.Error) {\n+func (c *testConn) Write(b []byte) (int, error) {\n \treturn c.writeBuf.Write(b)\n }\n \n-func (c *testConn) Close() os.Error {\n+func (c *testConn) Close() error {\n \treturn nil\n }\n \n@@ -83,15 +83,15 @@ func (c *testConn) RemoteAddr() net.Addr {\n \treturn dummyAddr(\"remote-addr\")\n }\n \n-func (c *testConn) SetTimeout(nsec int64) os.Error {\n+func (c *testConn) SetTimeout(nsec int64) error {\n \treturn nil\n }\n \n-func (c *testConn) SetReadTimeout(nsec int64) os.Error {\n+func (c *testConn) SetReadTimeout(nsec int64) error {\n \treturn nil\n }\n \n-func (c *testConn) SetWriteTimeout(nsec int64) os.Error {\n+func (c *testConn) SetWriteTimeout(nsec int64) error {\n \treturn nil\n }\n \n@@ -108,7 +108,7 @@ func TestConsumingBodyOnNextConn(t *testing.T) {\n \n \treqNum := 0\n \tch := make(chan *Request)\n-\tservech := make(chan os.Error)\n+\tservech := make(chan error)\n \tlistener := &oneConnListener{conn}\n \thandler := func(res ResponseWriter, req *Request) {\n \t\treqNum++\n@@ -138,7 +138,7 @@ func TestConsumingBodyOnNextConn(t *testing.T) {\n \t\t\treq.Method, \"POST\")\n \t}\n \n-\tif serveerr := <-servech; serveerr != os.EOF {\n+\tif serveerr := <-servech; serveerr != io.EOF {\n \t\tt.Errorf(\"Serve returned %q; expected EOF\", serveerr)\n \t}\n }\n@@ -273,8 +273,8 @@ func TestServerTimeouts(t *testing.T) {\n \tbuf := make([]byte, 1)\n \tn, err := conn.Read(buf)\n \tlatency := time.Nanoseconds() - t1\n-\tif n != 0 || err != os.EOF {\n-\t\tt.Errorf(\"Read = %v, %v, wanted %v, %v\", n, err, 0, os.EOF)\n+\tif n != 0 || err != io.EOF {\n+\t\tt.Errorf(\"Read = %v, %v, wanted %v, %v\", n, err, 0, io.EOF)\n \t}\n \tif latency < second*0.20 /* fudge from 0.25 above */ {\n \t\tt.Errorf(\"got EOF after %d ns, want >= %d\", latency, second*0.20)\n@@ -753,7 +753,7 @@ func TestServerUnreadRequestBodyLarge(t *testing.T) {\n \n func TestTimeoutHandler(t *testing.T) {\n \tsendHi := make(chan bool, 1)\n-\twriteErrors := make(chan os.Error, 1)\n+\twriteErrors := make(chan error, 1)\n \tsayHi := HandlerFunc(func(w ResponseWriter, r *Request) {\n \t\t<-sendHi\n \t\t_, werr := w.Write([]byte(\"hi\"))\n@@ -992,7 +992,7 @@ func TestRequestLimit(t *testing.T) {\n \n type neverEnding byte\n \n-func (b neverEnding) Read(p []byte) (n int, err os.Error) {\n+func (b neverEnding) Read(p []byte) (n int, err error) {\n \tfor i := range p {\n \t\tp[i] = byte(b)\n \t}\n@@ -1004,7 +1004,7 @@ type countReader struct {\n \tn *int64\n }\n \n-func (cr countReader) Read(p []byte) (n int, err os.Error) {\n+func (cr countReader) Read(p []byte) (n int, err error) {\n \tn, err = cr.r.Read(p)\n \t*cr.n += int64(n)\n \treturn\n@@ -1092,19 +1092,19 @@ func goTimeout(t *testing.T, ns int64, f func()) {\n }\n \n type errorListener struct {\n-\terrs []os.Error\n+\terrs []error\n }\n \n-func (l *errorListener) Accept() (c net.Conn, err os.Error) {\n+func (l *errorListener) Accept() (c net.Conn, err error) {\n \tif len(l.errs) == 0 {\n-\t\treturn nil, os.EOF\n+\t\treturn nil, io.EOF\n \t}\n \terr = l.errs[0]\n \tl.errs = l.errs[1:]\n \treturn\n }\n \n-func (l *errorListener) Close() os.Error {\n+func (l *errorListener) Close() error {\n \treturn nil\n }\n \n@@ -1116,13 +1116,13 @@ func TestAcceptMaxFds(t *testing.T) {\n \tlog.SetOutput(ioutil.Discard) // is noisy otherwise\n \tdefer log.SetOutput(os.Stderr)\n \n-\tln := &errorListener{[]os.Error{\n+\tln := &errorListener{[]error{\n \t\t&net.OpError{\n-\t\t\tOp:    \"accept\",\n-\t\t\tError: os.Errno(syscall.EMFILE),\n+\t\t\tOp:  \"accept\",\n+\t\t\tErr: os.Errno(syscall.EMFILE),\n \t\t}}}\n \terr := Serve(ln, HandlerFunc(HandlerFunc(func(ResponseWriter, *Request) {})))\n-\tif err != os.EOF {\n+\tif err != io.EOF {\n \t\tt.Errorf(\"got error %v, want EOF\", err)\n \t}\n }\n@@ -1138,11 +1138,11 @@ func BenchmarkClientServer(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tres, err := Get(ts.URL)\n \t\tif err != nil {\n-\t\t\tpanic(\"Get: \" + err.String())\n+\t\t\tpanic(\"Get: \" + err.Error())\n \t\t}\n \t\tall, err := ioutil.ReadAll(res.Body)\n \t\tif err != nil {\n-\t\t\tpanic(\"ReadAll: \" + err.String())\n+\t\t\tpanic(\"ReadAll: \" + err.Error())\n \t\t}\n \t\tbody := string(all)\n \t\tif body != \"Hello world.\\n\" {"}, {"sha": "f2a4f01ad8f0040de35affc0e5a8afb024156d51", "filename": "libgo/go/http/server.go", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserver.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -14,12 +14,12 @@ import (\n \t\"bytes\"\n \t\"crypto/rand\"\n \t\"crypto/tls\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"log\"\n \t\"net\"\n-\t\"os\"\n \t\"path\"\n \t\"runtime/debug\"\n \t\"strconv\"\n@@ -31,10 +31,10 @@ import (\n \n // Errors introduced by the HTTP server.\n var (\n-\tErrWriteAfterFlush = os.NewError(\"Conn.Write called after Flush\")\n-\tErrBodyNotAllowed  = os.NewError(\"http: response status code does not allow body\")\n-\tErrHijacked        = os.NewError(\"Conn has been hijacked\")\n-\tErrContentLength   = os.NewError(\"Conn.Write wrote more than the declared Content-Length\")\n+\tErrWriteAfterFlush = errors.New(\"Conn.Write called after Flush\")\n+\tErrBodyNotAllowed  = errors.New(\"http: response status code does not allow body\")\n+\tErrHijacked        = errors.New(\"Conn has been hijacked\")\n+\tErrContentLength   = errors.New(\"Conn.Write wrote more than the declared Content-Length\")\n )\n \n // Objects implementing the Handler interface can be\n@@ -60,7 +60,7 @@ type ResponseWriter interface {\n \t// Write writes the data to the connection as part of an HTTP reply.\n \t// If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)\n \t// before writing the data.\n-\tWrite([]byte) (int, os.Error)\n+\tWrite([]byte) (int, error)\n \n \t// WriteHeader sends an HTTP response header with status code.\n \t// If WriteHeader is not called explicitly, the first call to Write\n@@ -90,7 +90,7 @@ type Hijacker interface {\n \t// will not do anything else with the connection.\n \t// It becomes the caller's responsibility to manage\n \t// and close the connection.\n-\tHijack() (net.Conn, *bufio.ReadWriter, os.Error)\n+\tHijack() (net.Conn, *bufio.ReadWriter, error)\n }\n \n // A conn represents the server side of an HTTP connection.\n@@ -148,7 +148,7 @@ type writerOnly struct {\n \tio.Writer\n }\n \n-func (w *response) ReadFrom(src io.Reader) (n int64, err os.Error) {\n+func (w *response) ReadFrom(src io.Reader) (n int64, err error) {\n \t// Flush before checking w.chunking, as Flush will call\n \t// WriteHeader if it hasn't been called yet, and WriteHeader\n \t// is what sets w.chunking.\n@@ -169,7 +169,7 @@ func (w *response) ReadFrom(src io.Reader) (n int64, err os.Error) {\n const noLimit int64 = (1 << 63) - 1\n \n // Create new connection from rwc.\n-func (srv *Server) newConn(rwc net.Conn) (c *conn, err os.Error) {\n+func (srv *Server) newConn(rwc net.Conn) (c *conn, err error) {\n \tc = new(conn)\n \tc.remoteAddr = rwc.RemoteAddr().String()\n \tc.server = srv\n@@ -202,9 +202,9 @@ type expectContinueReader struct {\n \tclosed     bool\n }\n \n-func (ecr *expectContinueReader) Read(p []byte) (n int, err os.Error) {\n+func (ecr *expectContinueReader) Read(p []byte) (n int, err error) {\n \tif ecr.closed {\n-\t\treturn 0, os.NewError(\"http: Read after Close on request Body\")\n+\t\treturn 0, errors.New(\"http: Read after Close on request Body\")\n \t}\n \tif !ecr.resp.wroteContinue && !ecr.resp.conn.hijacked {\n \t\tecr.resp.wroteContinue = true\n@@ -214,7 +214,7 @@ func (ecr *expectContinueReader) Read(p []byte) (n int, err os.Error) {\n \treturn ecr.readCloser.Read(p)\n }\n \n-func (ecr *expectContinueReader) Close() os.Error {\n+func (ecr *expectContinueReader) Close() error {\n \tecr.closed = true\n \treturn ecr.readCloser.Close()\n }\n@@ -225,10 +225,10 @@ func (ecr *expectContinueReader) Close() os.Error {\n // It is like time.RFC1123 but hard codes GMT as the time zone.\n const TimeFormat = \"Mon, 02 Jan 2006 15:04:05 GMT\"\n \n-var errTooLarge = os.NewError(\"http: request too large\")\n+var errTooLarge = errors.New(\"http: request too large\")\n \n // Read next request from connection.\n-func (c *conn) readRequest() (w *response, err os.Error) {\n+func (c *conn) readRequest() (w *response, err error) {\n \tif c.hijacked {\n \t\treturn nil, ErrHijacked\n \t}\n@@ -285,7 +285,7 @@ func (w *response) WriteHeader(code int) {\n \tvar hasCL bool\n \tvar contentLength int64\n \tif clenStr := w.header.Get(\"Content-Length\"); clenStr != \"\" {\n-\t\tvar err os.Error\n+\t\tvar err error\n \t\tcontentLength, err = strconv.Atoi64(clenStr)\n \t\tif err == nil {\n \t\t\thasCL = true\n@@ -439,7 +439,7 @@ func (w *response) bodyAllowed() bool {\n \treturn w.status != StatusNotModified && w.req.Method != \"HEAD\"\n }\n \n-func (w *response) Write(data []byte) (n int, err os.Error) {\n+func (w *response) Write(data []byte) (n int, err error) {\n \tif w.conn.hijacked {\n \t\tlog.Print(\"http: response.Write on hijacked connection\")\n \t\treturn 0, ErrHijacked\n@@ -663,7 +663,7 @@ func (c *conn) serve() {\n \n // Hijack implements the Hijacker.Hijack method. Our response is both a ResponseWriter\n // and a Hijacker.\n-func (w *response) Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err os.Error) {\n+func (w *response) Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err error) {\n \tif w.conn.hijacked {\n \t\treturn nil, nil, ErrHijacked\n \t}\n@@ -943,7 +943,7 @@ func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n // creating a new service thread for each.  The service threads\n // read requests and then call handler to reply to them.\n // Handler is typically nil, in which case the DefaultServeMux is used.\n-func Serve(l net.Listener, handler Handler) os.Error {\n+func Serve(l net.Listener, handler Handler) error {\n \tsrv := &Server{Handler: handler}\n \treturn srv.Serve(l)\n }\n@@ -960,7 +960,7 @@ type Server struct {\n // ListenAndServe listens on the TCP network address srv.Addr and then\n // calls Serve to handle requests on incoming connections.  If\n // srv.Addr is blank, \":http\" is used.\n-func (srv *Server) ListenAndServe() os.Error {\n+func (srv *Server) ListenAndServe() error {\n \taddr := srv.Addr\n \tif addr == \"\" {\n \t\taddr = \":http\"\n@@ -975,7 +975,7 @@ func (srv *Server) ListenAndServe() os.Error {\n // Serve accepts incoming connections on the Listener l, creating a\n // new service thread for each.  The service threads read requests and\n // then call srv.Handler to reply to them.\n-func (srv *Server) Serve(l net.Listener) os.Error {\n+func (srv *Server) Serve(l net.Listener) error {\n \tdefer l.Close()\n \tfor {\n \t\trw, e := l.Accept()\n@@ -1028,7 +1028,7 @@ func (srv *Server) Serve(l net.Listener) os.Error {\n //\t\t\tlog.Fatal(\"ListenAndServe: \", err.String())\n //\t\t}\n //\t}\n-func ListenAndServe(addr string, handler Handler) os.Error {\n+func ListenAndServe(addr string, handler Handler) error {\n \tserver := &Server{Addr: addr, Handler: handler}\n \treturn server.ListenAndServe()\n }\n@@ -1061,7 +1061,7 @@ func ListenAndServe(addr string, handler Handler) os.Error {\n //\t}\n //\n // One can use generate_cert.go in crypto/tls to generate cert.pem and key.pem.\n-func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) os.Error {\n+func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error {\n \tserver := &Server{Addr: addr, Handler: handler}\n \treturn server.ListenAndServeTLS(certFile, keyFile)\n }\n@@ -1075,7 +1075,7 @@ func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Han\n // of the server's certificate followed by the CA's certificate.\n //\n // If srv.Addr is blank, \":https\" is used.\n-func (s *Server) ListenAndServeTLS(certFile, keyFile string) os.Error {\n+func (s *Server) ListenAndServeTLS(certFile, keyFile string) error {\n \taddr := s.Addr\n \tif addr == \"\" {\n \t\taddr = \":https\"\n@@ -1086,7 +1086,7 @@ func (s *Server) ListenAndServeTLS(certFile, keyFile string) os.Error {\n \t\tNextProtos: []string{\"http/1.1\"},\n \t}\n \n-\tvar err os.Error\n+\tvar err error\n \tconfig.Certificates = make([]tls.Certificate, 1)\n \tconfig.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile)\n \tif err != nil {\n@@ -1119,7 +1119,7 @@ func TimeoutHandler(h Handler, ns int64, msg string) Handler {\n \n // ErrHandlerTimeout is returned on ResponseWriter Write calls\n // in handlers which have timed out.\n-var ErrHandlerTimeout = os.NewError(\"http: Handler timeout\")\n+var ErrHandlerTimeout = errors.New(\"http: Handler timeout\")\n \n type timeoutHandler struct {\n \thandler Handler\n@@ -1167,7 +1167,7 @@ func (tw *timeoutWriter) Header() Header {\n \treturn tw.w.Header()\n }\n \n-func (tw *timeoutWriter) Write(p []byte) (int, os.Error) {\n+func (tw *timeoutWriter) Write(p []byte) (int, error) {\n \ttw.mu.Lock()\n \ttimedOut := tw.timedOut\n \ttw.mu.Unlock()"}, {"sha": "6cb8625e7d462a9f944a6a5950e118476e49264c", "filename": "libgo/go/http/transfer.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransfer.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,10 +7,10 @@ package http\n import (\n \t\"bytes\"\n \t\"bufio\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"strconv\"\n \t\"strings\"\n )\n@@ -29,7 +29,7 @@ type transferWriter struct {\n \tTrailer          Header\n }\n \n-func newTransferWriter(r interface{}) (t *transferWriter, err os.Error) {\n+func newTransferWriter(r interface{}) (t *transferWriter, err error) {\n \tt = &transferWriter{}\n \n \t// Extract relevant fields\n@@ -133,7 +133,7 @@ func (t *transferWriter) shouldSendContentLength() bool {\n \treturn false\n }\n \n-func (t *transferWriter) WriteHeader(w io.Writer) (err os.Error) {\n+func (t *transferWriter) WriteHeader(w io.Writer) (err error) {\n \tif t.Close {\n \t\t_, err = io.WriteString(w, \"Connection: close\\r\\n\")\n \t\tif err != nil {\n@@ -181,7 +181,7 @@ func (t *transferWriter) WriteHeader(w io.Writer) (err os.Error) {\n \treturn\n }\n \n-func (t *transferWriter) WriteBody(w io.Writer) (err os.Error) {\n+func (t *transferWriter) WriteBody(w io.Writer) (err error) {\n \tvar ncopy int64\n \n \t// Write body\n@@ -254,7 +254,7 @@ func bodyAllowedForStatus(status int) bool {\n }\n \n // msg is *Request or *Response.\n-func readTransfer(msg interface{}, r *bufio.Reader) (err os.Error) {\n+func readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n \tt := &transferReader{}\n \n \t// Unify input\n@@ -360,7 +360,7 @@ func chunked(te []string) bool { return len(te) > 0 && te[0] == \"chunked\" }\n func isIdentity(te []string) bool { return len(te) == 1 && te[0] == \"identity\" }\n \n // Sanitize transfer encoding\n-func fixTransferEncoding(requestMethod string, header Header) ([]string, os.Error) {\n+func fixTransferEncoding(requestMethod string, header Header) ([]string, error) {\n \traw, present := header[\"Transfer-Encoding\"]\n \tif !present {\n \t\treturn nil, nil\n@@ -409,7 +409,7 @@ func fixTransferEncoding(requestMethod string, header Header) ([]string, os.Erro\n // Determine the expected body length, using RFC 2616 Section 4.4. This\n // function is not a method, because ultimately it should be shared by\n // ReadResponse and ReadRequest.\n-func fixLength(isResponse bool, status int, requestMethod string, header Header, te []string) (int64, os.Error) {\n+func fixLength(isResponse bool, status int, requestMethod string, header Header, te []string) (int64, error) {\n \n \t// Logic based on response type or status\n \tif noBodyExpected(requestMethod) {\n@@ -482,7 +482,7 @@ func shouldClose(major, minor int, header Header) bool {\n }\n \n // Parse the trailer header\n-func fixTrailer(header Header, te []string) (Header, os.Error) {\n+func fixTrailer(header Header, te []string) (Header, error) {\n \traw := header.Get(\"Trailer\")\n \tif raw == \"\" {\n \t\treturn nil, nil\n@@ -526,16 +526,16 @@ type body struct {\n // the body has been closed. This typically happens when the body is\n // read after an HTTP Handler calls WriteHeader or Write on its\n // ResponseWriter.\n-var ErrBodyReadAfterClose = os.NewError(\"http: invalid Read on closed request Body\")\n+var ErrBodyReadAfterClose = errors.New(\"http: invalid Read on closed request Body\")\n \n-func (b *body) Read(p []byte) (n int, err os.Error) {\n+func (b *body) Read(p []byte) (n int, err error) {\n \tif b.closed {\n \t\treturn 0, ErrBodyReadAfterClose\n \t}\n \treturn b.Reader.Read(p)\n }\n \n-func (b *body) Close() os.Error {\n+func (b *body) Close() error {\n \tif b.closed {\n \t\treturn nil\n \t}"}, {"sha": "c7041cba2e2cc7027d0df4bdca0810242020cbfb", "filename": "libgo/go/http/transport.go", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -14,6 +14,7 @@ import (\n \t\"compress/gzip\"\n \t\"crypto/tls\"\n \t\"encoding/base64\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -52,12 +53,12 @@ type Transport struct {\n \t// Request. If the function returns a non-nil error, the\n \t// request is aborted with the provided error.\n \t// If Proxy is nil or returns a nil *URL, no proxy is used.\n-\tProxy func(*Request) (*url.URL, os.Error)\n+\tProxy func(*Request) (*url.URL, error)\n \n \t// Dial specifies the dial function for creating TCP\n \t// connections.\n \t// If Dial is nil, net.Dial is used.\n-\tDial func(net, addr string) (c net.Conn, err os.Error)\n+\tDial func(net, addr string) (c net.Conn, err error)\n \n \t// TLSClientConfig specifies the TLS configuration to use with\n \t// tls.Client. If nil, the default configuration is used.\n@@ -76,7 +77,7 @@ type Transport struct {\n // given request, as indicated by the environment variables\n // $HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy).\n // Either URL or an error is returned.\n-func ProxyFromEnvironment(req *Request) (*url.URL, os.Error) {\n+func ProxyFromEnvironment(req *Request) (*url.URL, error) {\n \tproxy := getenvEitherCase(\"HTTP_PROXY\")\n \tif proxy == \"\" {\n \t\treturn nil, nil\n@@ -86,21 +87,21 @@ func ProxyFromEnvironment(req *Request) (*url.URL, os.Error) {\n \t}\n \tproxyURL, err := url.ParseRequest(proxy)\n \tif err != nil {\n-\t\treturn nil, os.NewError(\"invalid proxy address\")\n+\t\treturn nil, errors.New(\"invalid proxy address\")\n \t}\n \tif proxyURL.Host == \"\" {\n \t\tproxyURL, err = url.ParseRequest(\"http://\" + proxy)\n \t\tif err != nil {\n-\t\t\treturn nil, os.NewError(\"invalid proxy address\")\n+\t\t\treturn nil, errors.New(\"invalid proxy address\")\n \t\t}\n \t}\n \treturn proxyURL, nil\n }\n \n // ProxyURL returns a proxy function (for use in a Transport)\n // that always returns the same URL.\n-func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, os.Error) {\n-\treturn func(*Request) (*url.URL, os.Error) {\n+func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error) {\n+\treturn func(*Request) (*url.URL, error) {\n \t\treturn fixedURL, nil\n \t}\n }\n@@ -120,12 +121,12 @@ func (tr *transportRequest) extraHeaders() Header {\n }\n \n // RoundTrip implements the RoundTripper interface.\n-func (t *Transport) RoundTrip(req *Request) (resp *Response, err os.Error) {\n+func (t *Transport) RoundTrip(req *Request) (resp *Response, err error) {\n \tif req.URL == nil {\n-\t\treturn nil, os.NewError(\"http: nil Request.URL\")\n+\t\treturn nil, errors.New(\"http: nil Request.URL\")\n \t}\n \tif req.Header == nil {\n-\t\treturn nil, os.NewError(\"http: nil Request.Header\")\n+\t\treturn nil, errors.New(\"http: nil Request.Header\")\n \t}\n \tif req.URL.Scheme != \"http\" && req.URL.Scheme != \"https\" {\n \t\tt.lk.Lock()\n@@ -207,13 +208,13 @@ func getenvEitherCase(k string) string {\n \treturn os.Getenv(strings.ToLower(k))\n }\n \n-func (t *Transport) connectMethodForRequest(treq *transportRequest) (*connectMethod, os.Error) {\n+func (t *Transport) connectMethodForRequest(treq *transportRequest) (*connectMethod, error) {\n \tcm := &connectMethod{\n \t\ttargetScheme: treq.URL.Scheme,\n \t\ttargetAddr:   canonicalAddr(treq.URL),\n \t}\n \tif t.Proxy != nil {\n-\t\tvar err os.Error\n+\t\tvar err error\n \t\tcm.proxyURL, err = t.Proxy(treq.Request)\n \t\tif err != nil {\n \t\t\treturn nil, err\n@@ -285,7 +286,7 @@ func (t *Transport) getIdleConn(cm *connectMethod) (pconn *persistConn) {\n \treturn\n }\n \n-func (t *Transport) dial(network, addr string) (c net.Conn, err os.Error) {\n+func (t *Transport) dial(network, addr string) (c net.Conn, err error) {\n \tif t.Dial != nil {\n \t\treturn t.Dial(network, addr)\n \t}\n@@ -296,7 +297,7 @@ func (t *Transport) dial(network, addr string) (c net.Conn, err os.Error) {\n // specified in the connectMethod.  This includes doing a proxy CONNECT\n // and/or setting up TLS.  If this doesn't return an error, the persistConn\n // is ready to write requests to.\n-func (t *Transport) getConn(cm *connectMethod) (*persistConn, os.Error) {\n+func (t *Transport) getConn(cm *connectMethod) (*persistConn, error) {\n \tif pc := t.getIdleConn(cm); pc != nil {\n \t\treturn pc, nil\n \t}\n@@ -352,7 +353,7 @@ func (t *Transport) getConn(cm *connectMethod) (*persistConn, os.Error) {\n \t\tif resp.StatusCode != 200 {\n \t\t\tf := strings.SplitN(resp.Status, \" \", 2)\n \t\t\tconn.Close()\n-\t\t\treturn nil, os.NewError(f[1])\n+\t\t\treturn nil, errors.New(f[1])\n \t\t}\n \t}\n \n@@ -500,10 +501,10 @@ func (pc *persistConn) expectingResponse() bool {\n \treturn pc.numExpectedResponses > 0\n }\n \n-var remoteSideClosedFunc func(os.Error) bool // or nil to use default\n+var remoteSideClosedFunc func(error) bool // or nil to use default\n \n-func remoteSideClosed(err os.Error) bool {\n-\tif err == os.EOF || err == os.EINVAL {\n+func remoteSideClosed(err error) bool {\n+\tif err == io.EOF || err == os.EINVAL {\n \t\treturn true\n \t}\n \tif remoteSideClosedFunc != nil {\n@@ -532,7 +533,7 @@ func (pc *persistConn) readLoop() {\n \t\t}\n \n \t\trc := <-pc.reqch\n-\t\tresp, err := pc.cc.readUsing(rc.req, func(buf *bufio.Reader, forReq *Request) (*Response, os.Error) {\n+\t\tresp, err := pc.cc.readUsing(rc.req, func(buf *bufio.Reader, forReq *Request) (*Response, error) {\n \t\t\tresp, err := ReadResponse(buf, forReq)\n \t\t\tif err != nil || resp.ContentLength == 0 {\n \t\t\t\treturn resp, err\n@@ -599,7 +600,7 @@ func (pc *persistConn) readLoop() {\n \n type responseAndError struct {\n \tres *Response\n-\terr os.Error\n+\terr error\n }\n \n type requestAndChan struct {\n@@ -612,7 +613,7 @@ type requestAndChan struct {\n \taddedGzip bool\n }\n \n-func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err os.Error) {\n+func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err error) {\n \tif pc.mutateHeaderFunc != nil {\n \t\tpc.mutateHeaderFunc(req.extraHeaders())\n \t}\n@@ -634,7 +635,7 @@ func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err os.\n \tpc.numExpectedResponses++\n \tpc.lk.Unlock()\n \n-\tpc.cc.writeReq = func(r *Request, w io.Writer) os.Error {\n+\tpc.cc.writeReq = func(r *Request, w io.Writer) error {\n \t\treturn r.write(w, pc.isProxy, req.extra)\n \t}\n \n@@ -691,19 +692,19 @@ type bodyEOFSignal struct {\n \tisClosed bool\n }\n \n-func (es *bodyEOFSignal) Read(p []byte) (n int, err os.Error) {\n+func (es *bodyEOFSignal) Read(p []byte) (n int, err error) {\n \tn, err = es.body.Read(p)\n \tif es.isClosed && n > 0 {\n \t\tpanic(\"http: unexpected bodyEOFSignal Read after Close; see issue 1725\")\n \t}\n-\tif err == os.EOF && es.fn != nil {\n+\tif err == io.EOF && es.fn != nil {\n \t\tes.fn()\n \t\tes.fn = nil\n \t}\n \treturn\n }\n \n-func (es *bodyEOFSignal) Close() (err os.Error) {\n+func (es *bodyEOFSignal) Close() (err error) {\n \tif es.isClosed {\n \t\treturn nil\n \t}\n@@ -721,7 +722,7 @@ type readFirstCloseBoth struct {\n \tio.Closer\n }\n \n-func (r *readFirstCloseBoth) Close() os.Error {\n+func (r *readFirstCloseBoth) Close() error {\n \tif err := r.ReadCloser.Close(); err != nil {\n \t\tr.Closer.Close()\n \t\treturn err\n@@ -737,7 +738,7 @@ type discardOnCloseReadCloser struct {\n \tio.ReadCloser\n }\n \n-func (d *discardOnCloseReadCloser) Close() os.Error {\n+func (d *discardOnCloseReadCloser) Close() error {\n \tio.Copy(ioutil.Discard, d.ReadCloser) // ignore errors; likely invalid or already closed\n \treturn d.ReadCloser.Close()\n }"}, {"sha": "b2d0ebaf6b33a7558974934f6e4a8c4f83537581", "filename": "libgo/go/http/transport_test.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -15,7 +15,6 @@ import (\n \t\"http/httptest\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n@@ -77,7 +76,7 @@ func TestTransportConnectionCloseOnResponse(t *testing.T) {\n \n \t\tfetch := func(n int) string {\n \t\t\treq := new(Request)\n-\t\t\tvar err os.Error\n+\t\t\tvar err error\n \t\t\treq.URL, err = url.Parse(ts.URL + fmt.Sprintf(\"/?close=%v\", connectionClose))\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"URL parse error: %v\", err)\n@@ -119,7 +118,7 @@ func TestTransportConnectionCloseOnRequest(t *testing.T) {\n \n \t\tfetch := func(n int) string {\n \t\t\treq := new(Request)\n-\t\t\tvar err os.Error\n+\t\t\tvar err error\n \t\t\treq.URL, err = url.Parse(ts.URL)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"URL parse error: %v\", err)\n@@ -575,7 +574,7 @@ func TestTransportGzipRecursive(t *testing.T) {\n \n type fooProto struct{}\n \n-func (fooProto) RoundTrip(req *Request) (*Response, os.Error) {\n+func (fooProto) RoundTrip(req *Request) (*Response, error) {\n \tres := &Response{\n \t\tStatus:     \"200 OK\",\n \t\tStatusCode: 200,"}, {"sha": "e0dc857aa94a39f1a3d45ecb4f007635a9f4ffc6", "filename": "libgo/go/http/transport_windows.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ftransport_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fhttp%2Ftransport_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport_windows.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,9 +10,9 @@ import (\n )\n \n func init() {\n-\tremoteSideClosedFunc = func(err os.Error) (out bool) {\n+\tremoteSideClosedFunc = func(err error) (out bool) {\n \t\top, ok := err.(*net.OpError)\n-\t\tif ok && op.Op == \"WSARecv\" && op.Net == \"tcp\" && op.Error == os.Errno(10058) {\n+\t\tif ok && op.Op == \"WSARecv\" && op.Net == \"tcp\" && op.Err == os.Errno(10058) {\n \t\t\t// TODO(bradfitz): find the symbol for 10058\n \t\t\treturn true\n \t\t}"}, {"sha": "ad5686549928186753372c390d6a2329fe8ac146", "filename": "libgo/go/image/bmp/reader.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fbmp%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fbmp%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fbmp%2Freader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,15 +8,15 @@\n package bmp\n \n import (\n+\t\"errors\"\n \t\"image/color\"\n \t\"image\"\n \t\"io\"\n-\t\"os\"\n )\n \n // ErrUnsupported means that the input BMP image uses a valid but unsupported\n // feature.\n-var ErrUnsupported = os.NewError(\"bmp: unsupported BMP image\")\n+var ErrUnsupported = errors.New(\"bmp: unsupported BMP image\")\n \n func readUint16(b []byte) uint16 {\n \treturn uint16(b[0]) | uint16(b[1])<<8\n@@ -27,7 +27,7 @@ func readUint32(b []byte) uint32 {\n }\n \n // decodePaletted reads an 8 bit-per-pixel BMP image from r.\n-func decodePaletted(r io.Reader, c image.Config) (image.Image, os.Error) {\n+func decodePaletted(r io.Reader, c image.Config) (image.Image, error) {\n \tvar tmp [4]byte\n \tpaletted := image.NewPaletted(image.Rect(0, 0, c.Width, c.Height), c.ColorModel.(color.Palette))\n \t// BMP images are stored bottom-up rather than top-down.\n@@ -49,7 +49,7 @@ func decodePaletted(r io.Reader, c image.Config) (image.Image, os.Error) {\n }\n \n // decodeRGBA reads a 24 bit-per-pixel BMP image from r.\n-func decodeRGBA(r io.Reader, c image.Config) (image.Image, os.Error) {\n+func decodeRGBA(r io.Reader, c image.Config) (image.Image, error) {\n \trgba := image.NewRGBA(image.Rect(0, 0, c.Width, c.Height))\n \t// There are 3 bytes per pixel, and each row is 4-byte aligned.\n \tb := make([]byte, (3*c.Width+3)&^3)\n@@ -73,7 +73,7 @@ func decodeRGBA(r io.Reader, c image.Config) (image.Image, os.Error) {\n \n // Decode reads a BMP image from r and returns it as an image.Image.\n // Limitation: The file must be 8 or 24 bits per pixel.\n-func Decode(r io.Reader) (image.Image, os.Error) {\n+func Decode(r io.Reader) (image.Image, error) {\n \tc, err := DecodeConfig(r)\n \tif err != nil {\n \t\treturn nil, err\n@@ -87,7 +87,7 @@ func Decode(r io.Reader) (image.Image, os.Error) {\n // DecodeConfig returns the color model and dimensions of a BMP image without\n // decoding the entire image.\n // Limitation: The file must be 8 or 24 bits per pixel.\n-func DecodeConfig(r io.Reader) (config image.Config, err os.Error) {\n+func DecodeConfig(r io.Reader) (config image.Config, err error) {\n \t// We only support those BMP images that are a BITMAPFILEHEADER\n \t// immediately followed by a BITMAPINFOHEADER.\n \tconst (\n@@ -99,7 +99,7 @@ func DecodeConfig(r io.Reader) (config image.Config, err os.Error) {\n \t\treturn\n \t}\n \tif string(b[:2]) != \"BM\" {\n-\t\terr = os.NewError(\"bmp: invalid format\")\n+\t\terr = errors.New(\"bmp: invalid format\")\n \t\treturn\n \t}\n \toffset := readUint32(b[10:14])"}, {"sha": "1b7db8bade4a68feadc37661abeea916f3fa1111", "filename": "libgo/go/image/decode_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdecode_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -41,7 +41,7 @@ var imageTests = []imageTest{\n \t{\"testdata/video-005.gray.png\", \"testdata/video-005.gray.png\", 0},\n }\n \n-func decode(filename string) (image.Image, string, os.Error) {\n+func decode(filename string) (image.Image, string, error) {\n \tf, err := os.Open(filename)\n \tif err != nil {\n \t\treturn nil, \"\", err\n@@ -50,7 +50,7 @@ func decode(filename string) (image.Image, string, os.Error) {\n \treturn image.Decode(bufio.NewReader(f))\n }\n \n-func decodeConfig(filename string) (image.Config, string, os.Error) {\n+func decodeConfig(filename string) (image.Config, string, error) {\n \tf, err := os.Open(filename)\n \tif err != nil {\n \t\treturn image.Config{}, \"\", err\n@@ -83,7 +83,7 @@ loop:\n \tfor _, it := range imageTests {\n \t\tg := golden[it.goldenFilename]\n \t\tif g == nil {\n-\t\t\tvar err os.Error\n+\t\t\tvar err error\n \t\t\tg, _, err = decode(it.goldenFilename)\n \t\t\tif err != nil {\n \t\t\t\tt.Errorf(\"%s: %v\", it.goldenFilename, err)"}, {"sha": "78fc3ed619fa07ffee1c18934b3ed74e8b989376", "filename": "libgo/go/image/format.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fformat.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,18 +6,18 @@ package image\n \n import (\n \t\"bufio\"\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n )\n \n // An UnknownFormatErr indicates that decoding encountered an unknown format.\n-var UnknownFormatErr = os.NewError(\"image: unknown format\")\n+var UnknownFormatErr = errors.New(\"image: unknown format\")\n \n // A format holds an image format's name, magic header and how to decode it.\n type format struct {\n \tname, magic  string\n-\tdecode       func(io.Reader) (Image, os.Error)\n-\tdecodeConfig func(io.Reader) (Config, os.Error)\n+\tdecode       func(io.Reader) (Image, error)\n+\tdecodeConfig func(io.Reader) (Config, error)\n }\n \n // Formats is the list of registered formats.\n@@ -29,14 +29,14 @@ var formats []format\n // string can contain \"?\" wildcards that each match any one byte.\n // Decode is the function that decodes the encoded image.\n // DecodeConfig is the function that decodes just its configuration.\n-func RegisterFormat(name, magic string, decode func(io.Reader) (Image, os.Error), decodeConfig func(io.Reader) (Config, os.Error)) {\n+func RegisterFormat(name, magic string, decode func(io.Reader) (Image, error), decodeConfig func(io.Reader) (Config, error)) {\n \tformats = append(formats, format{name, magic, decode, decodeConfig})\n }\n \n // A reader is an io.Reader that can also peek ahead.\n type reader interface {\n \tio.Reader\n-\tPeek(int) ([]byte, os.Error)\n+\tPeek(int) ([]byte, error)\n }\n \n // AsReader converts an io.Reader to a reader.\n@@ -75,7 +75,7 @@ func sniff(r reader) format {\n // The string returned is the format name used during format registration.\n // Format registration is typically done by the init method of the codec-\n // specific package.\n-func Decode(r io.Reader) (Image, string, os.Error) {\n+func Decode(r io.Reader) (Image, string, error) {\n \trr := asReader(r)\n \tf := sniff(rr)\n \tif f.decode == nil {\n@@ -89,7 +89,7 @@ func Decode(r io.Reader) (Image, string, os.Error) {\n // been encoded in a registered format. The string returned is the format name\n // used during format registration. Format registration is typically done by\n // the init method of the codec-specific package.\n-func DecodeConfig(r io.Reader) (Config, string, os.Error) {\n+func DecodeConfig(r io.Reader) (Config, string, error) {\n \trr := asReader(r)\n \tf := sniff(rr)\n \tif f.decodeConfig == nil {"}, {"sha": "24b53c5b0a91a09d9f0304983f6d17a22cfdfd96", "filename": "libgo/go/image/gif/reader.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fgif%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fgif%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgif%2Freader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,11 +10,11 @@ package gif\n import (\n \t\"bufio\"\n \t\"compress/lzw\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"image\"\n \t\"image/color\"\n \t\"io\"\n-\t\"os\"\n )\n \n // If the io.Reader does not also have ReadByte, then decode will introduce its own buffering.\n@@ -97,7 +97,7 @@ type blockReader struct {\n \ttmp   [256]byte\n }\n \n-func (b *blockReader) Read(p []byte) (int, os.Error) {\n+func (b *blockReader) Read(p []byte) (int, error) {\n \tif len(p) == 0 {\n \t\treturn 0, nil\n \t}\n@@ -107,7 +107,7 @@ func (b *blockReader) Read(p []byte) (int, os.Error) {\n \t\t\treturn 0, err\n \t\t}\n \t\tif blockLen == 0 {\n-\t\t\treturn 0, os.EOF\n+\t\t\treturn 0, io.EOF\n \t\t}\n \t\tb.slice = b.tmp[0:blockLen]\n \t\tif _, err = io.ReadFull(b.r, b.slice); err != nil {\n@@ -120,7 +120,7 @@ func (b *blockReader) Read(p []byte) (int, os.Error) {\n }\n \n // decode reads a GIF image from r and stores the result in d.\n-func (d *decoder) decode(r io.Reader, configOnly bool) os.Error {\n+func (d *decoder) decode(r io.Reader, configOnly bool) error {\n \t// Add buffering if r does not provide ReadByte.\n \tif rr, ok := r.(reader); ok {\n \t\td.r = rr\n@@ -146,7 +146,7 @@ Loop:\n \tfor err == nil {\n \t\tvar c byte\n \t\tc, err = d.r.ReadByte()\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\tbreak\n \t\t}\n \t\tswitch c {\n@@ -189,7 +189,7 @@ Loop:\n \t\t\t\treturn err\n \t\t\t}\n \t\t\tif c != 0 {\n-\t\t\t\treturn os.NewError(\"gif: extra data after image\")\n+\t\t\t\treturn errors.New(\"gif: extra data after image\")\n \t\t\t}\n \n \t\t\t// Undo the interlacing if necessary.\n@@ -217,7 +217,7 @@ Loop:\n \treturn nil\n }\n \n-func (d *decoder) readHeaderAndScreenDescriptor() os.Error {\n+func (d *decoder) readHeaderAndScreenDescriptor() error {\n \t_, err := io.ReadFull(d.r, d.tmp[0:13])\n \tif err != nil {\n \t\treturn err\n@@ -236,7 +236,7 @@ func (d *decoder) readHeaderAndScreenDescriptor() os.Error {\n \treturn nil\n }\n \n-func (d *decoder) readColorMap() (color.Palette, os.Error) {\n+func (d *decoder) readColorMap() (color.Palette, error) {\n \tif d.pixelSize > 8 {\n \t\treturn nil, fmt.Errorf(\"gif: can't handle %d bits per pixel\", d.pixelSize)\n \t}\n@@ -258,7 +258,7 @@ func (d *decoder) readColorMap() (color.Palette, os.Error) {\n \treturn colorMap, nil\n }\n \n-func (d *decoder) readExtension() os.Error {\n+func (d *decoder) readExtension() error {\n \textension, err := d.r.ReadByte()\n \tif err != nil {\n \t\treturn err\n@@ -307,7 +307,7 @@ func (d *decoder) readExtension() os.Error {\n \tpanic(\"unreachable\")\n }\n \n-func (d *decoder) readGraphicControl() os.Error {\n+func (d *decoder) readGraphicControl() error {\n \tif _, err := io.ReadFull(d.r, d.tmp[0:6]); err != nil {\n \t\treturn fmt.Errorf(\"gif: can't read graphic control: %s\", err)\n \t}\n@@ -326,7 +326,7 @@ func (d *decoder) setTransparency(colorMap color.Palette) {\n \t}\n }\n \n-func (d *decoder) newImageFromDescriptor() (*image.Paletted, os.Error) {\n+func (d *decoder) newImageFromDescriptor() (*image.Paletted, error) {\n \tif _, err := io.ReadFull(d.r, d.tmp[0:9]); err != nil {\n \t\treturn nil, fmt.Errorf(\"gif: can't read image descriptor: %s\", err)\n \t}\n@@ -338,7 +338,7 @@ func (d *decoder) newImageFromDescriptor() (*image.Paletted, os.Error) {\n \treturn image.NewPaletted(image.Rect(left, top, left+width, top+height), nil), nil\n }\n \n-func (d *decoder) readBlock() (int, os.Error) {\n+func (d *decoder) readBlock() (int, error) {\n \tn, err := d.r.ReadByte()\n \tif n == 0 || err != nil {\n \t\treturn 0, err\n@@ -379,7 +379,7 @@ func uninterlace(m *image.Paletted) {\n \n // Decode reads a GIF image from r and returns the first embedded\n // image as an image.Image.\n-func Decode(r io.Reader) (image.Image, os.Error) {\n+func Decode(r io.Reader) (image.Image, error) {\n \tvar d decoder\n \tif err := d.decode(r, false); err != nil {\n \t\treturn nil, err\n@@ -396,7 +396,7 @@ type GIF struct {\n \n // DecodeAll reads a GIF image from r and returns the sequential frames\n // and timing information.\n-func DecodeAll(r io.Reader) (*GIF, os.Error) {\n+func DecodeAll(r io.Reader) (*GIF, error) {\n \tvar d decoder\n \tif err := d.decode(r, false); err != nil {\n \t\treturn nil, err\n@@ -411,7 +411,7 @@ func DecodeAll(r io.Reader) (*GIF, os.Error) {\n \n // DecodeConfig returns the global color model and dimensions of a GIF image\n // without decoding the entire image.\n-func DecodeConfig(r io.Reader) (image.Config, os.Error) {\n+func DecodeConfig(r io.Reader) (image.Config, error) {\n \tvar d decoder\n \tif err := d.decode(r, true); err != nil {\n \t\treturn image.Config{}, err"}, {"sha": "d2382490f4acbef45e30bf2a45296636705c3d1f", "filename": "libgo/go/image/jpeg/huffman.go", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fjpeg%2Fhuffman.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fjpeg%2Fhuffman.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fhuffman.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,10 +4,7 @@\n \n package jpeg\n \n-import (\n-\t\"io\"\n-\t\"os\"\n-)\n+import \"io\"\n \n // Each code is at most 16 bits long.\n const maxCodeLength = 16\n@@ -36,7 +33,7 @@ type huffman struct {\n }\n \n // Reads bytes from the io.Reader to ensure that bits.n is at least n.\n-func (d *decoder) ensureNBits(n int) os.Error {\n+func (d *decoder) ensureNBits(n int) error {\n \tfor d.b.n < n {\n \t\tc, err := d.r.ReadByte()\n \t\tif err != nil {\n@@ -64,7 +61,7 @@ func (d *decoder) ensureNBits(n int) os.Error {\n }\n \n // The composition of RECEIVE and EXTEND, specified in section F.2.2.1.\n-func (d *decoder) receiveExtend(t uint8) (int, os.Error) {\n+func (d *decoder) receiveExtend(t uint8) (int, error) {\n \terr := d.ensureNBits(int(t))\n \tif err != nil {\n \t\treturn 0, err\n@@ -81,7 +78,7 @@ func (d *decoder) receiveExtend(t uint8) (int, os.Error) {\n \n // Processes a Define Huffman Table marker, and initializes a huffman struct from its contents.\n // Specified in section B.2.4.2.\n-func (d *decoder) processDHT(n int) os.Error {\n+func (d *decoder) processDHT(n int) error {\n \tfor n > 0 {\n \t\tif n < 17 {\n \t\t\treturn FormatError(\"DHT has wrong length\")\n@@ -167,7 +164,7 @@ func (d *decoder) processDHT(n int) os.Error {\n // Returns the next Huffman-coded value from the bit stream, decoded according to h.\n // TODO(nigeltao): This decoding algorithm is simple, but slow. A lookahead table, instead of always\n // peeling off only 1 bit at at time, ought to be faster.\n-func (d *decoder) decodeHuffman(h *huffman) (uint8, os.Error) {\n+func (d *decoder) decodeHuffman(h *huffman) (uint8, error) {\n \tif h.length == 0 {\n \t\treturn 0, FormatError(\"uninitialized Huffman table\")\n \t}"}, {"sha": "c1fc2d590f5534d3fa3ad48321e281b9518f1bba", "filename": "libgo/go/image/jpeg/reader.go", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -13,7 +13,6 @@ import (\n \t\"image/color\"\n \t\"image/ycbcr\"\n \t\"io\"\n-\t\"os\"\n )\n \n // TODO(nigeltao): fix up the doc comment style so that sentences start with\n@@ -22,12 +21,12 @@ import (\n // A FormatError reports that the input is not a valid JPEG.\n type FormatError string\n \n-func (e FormatError) String() string { return \"invalid JPEG format: \" + string(e) }\n+func (e FormatError) Error() string { return \"invalid JPEG format: \" + string(e) }\n \n // An UnsupportedError reports that the input uses a valid but unimplemented JPEG feature.\n type UnsupportedError string\n \n-func (e UnsupportedError) String() string { return \"unsupported JPEG feature: \" + string(e) }\n+func (e UnsupportedError) Error() string { return \"unsupported JPEG feature: \" + string(e) }\n \n // Component specification, specified in section B.2.2.\n type component struct {\n@@ -91,7 +90,7 @@ var unzig = [blockSize]int{\n // If the passed in io.Reader does not also have ReadByte, then Decode will introduce its own buffering.\n type Reader interface {\n \tio.Reader\n-\tReadByte() (c byte, err os.Error)\n+\tReadByte() (c byte, err error)\n }\n \n type decoder struct {\n@@ -109,7 +108,7 @@ type decoder struct {\n }\n \n // Reads and ignores the next n bytes.\n-func (d *decoder) ignore(n int) os.Error {\n+func (d *decoder) ignore(n int) error {\n \tfor n > 0 {\n \t\tm := len(d.tmp)\n \t\tif m > n {\n@@ -125,7 +124,7 @@ func (d *decoder) ignore(n int) os.Error {\n }\n \n // Specified in section B.2.2.\n-func (d *decoder) processSOF(n int) os.Error {\n+func (d *decoder) processSOF(n int) error {\n \tswitch n {\n \tcase 6 + 3*nGrayComponent:\n \t\td.nComp = nGrayComponent\n@@ -172,7 +171,7 @@ func (d *decoder) processSOF(n int) os.Error {\n }\n \n // Specified in section B.2.4.1.\n-func (d *decoder) processDQT(n int) os.Error {\n+func (d *decoder) processDQT(n int) error {\n \tconst qtLength = 1 + blockSize\n \tfor ; n >= qtLength; n -= qtLength {\n \t\t_, err := io.ReadFull(d.r, d.tmp[0:qtLength])\n@@ -229,7 +228,7 @@ func (d *decoder) makeImg(h0, v0, mxx, myy int) {\n }\n \n // Specified in section B.2.3.\n-func (d *decoder) processSOS(n int) os.Error {\n+func (d *decoder) processSOS(n int) error {\n \tif d.nComp == 0 {\n \t\treturn FormatError(\"missing SOF marker\")\n \t}\n@@ -362,7 +361,7 @@ func (d *decoder) processSOS(n int) os.Error {\n }\n \n // Specified in section B.2.4.4.\n-func (d *decoder) processDRI(n int) os.Error {\n+func (d *decoder) processDRI(n int) error {\n \tif n != 2 {\n \t\treturn FormatError(\"DRI has wrong length\")\n \t}\n@@ -375,7 +374,7 @@ func (d *decoder) processDRI(n int) os.Error {\n }\n \n // decode reads a JPEG image from r and returns it as an image.Image.\n-func (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, os.Error) {\n+func (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, error) {\n \tif rr, ok := r.(Reader); ok {\n \t\td.r = rr\n \t} else {\n@@ -451,14 +450,14 @@ func (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, os.Error) {\n }\n \n // Decode reads a JPEG image from r and returns it as an image.Image.\n-func Decode(r io.Reader) (image.Image, os.Error) {\n+func Decode(r io.Reader) (image.Image, error) {\n \tvar d decoder\n \treturn d.decode(r, false)\n }\n \n // DecodeConfig returns the color model and dimensions of a JPEG image without\n // decoding the entire image.\n-func DecodeConfig(r io.Reader) (image.Config, os.Error) {\n+func DecodeConfig(r io.Reader) (image.Config, error) {\n \tvar d decoder\n \tif _, err := d.decode(r, true); err != nil {\n \t\treturn image.Config{}, err"}, {"sha": "fab0bd0bfc11ecbdc68548d03677e2799f89d8a7", "filename": "libgo/go/image/jpeg/writer.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,10 +6,10 @@ package jpeg\n \n import (\n \t\"bufio\"\n+\t\"errors\"\n \t\"image\"\n \t\"image/ycbcr\"\n \t\"io\"\n-\t\"os\"\n )\n \n // min returns the minimum of two integers.\n@@ -207,17 +207,17 @@ func init() {\n \n // writer is a buffered writer.\n type writer interface {\n-\tFlush() os.Error\n-\tWrite([]byte) (int, os.Error)\n-\tWriteByte(byte) os.Error\n+\tFlush() error\n+\tWrite([]byte) (int, error)\n+\tWriteByte(byte) error\n }\n \n // encoder encodes an image to the JPEG format.\n type encoder struct {\n \t// w is the writer to write to. err is the first error encountered during\n \t// writing. All attempted writes after the first error become no-ops.\n \tw   writer\n-\terr os.Error\n+\terr error\n \t// buf is a scratch buffer.\n \tbuf [16]byte\n \t// bits and nBits are accumulated bits to write to w.\n@@ -487,10 +487,10 @@ type Options struct {\n \n // Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given\n // options. Default parameters are used if a nil *Options is passed.\n-func Encode(w io.Writer, m image.Image, o *Options) os.Error {\n+func Encode(w io.Writer, m image.Image, o *Options) error {\n \tb := m.Bounds()\n \tif b.Dx() >= 1<<16 || b.Dy() >= 1<<16 {\n-\t\treturn os.NewError(\"jpeg: image is too large to encode\")\n+\t\treturn errors.New(\"jpeg: image is too large to encode\")\n \t}\n \tvar e encoder\n \tif ww, ok := w.(writer); ok {"}, {"sha": "72cec93b3ba42047b66dac1acc3c305d12e5d358", "filename": "libgo/go/image/jpeg/writer_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -36,7 +36,7 @@ func delta(u0, u1 uint32) int64 {\n \treturn d\n }\n \n-func readPng(filename string) (image.Image, os.Error) {\n+func readPng(filename string) (image.Image, error) {\n \tf, err := os.Open(filename)\n \tif err != nil {\n \t\treturn nil, err"}, {"sha": "7eb8cea9d567c6227b1a0db3803944f90232d5d5", "filename": "libgo/go/image/png/reader.go", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -16,7 +16,6 @@ import (\n \t\"image\"\n \t\"image/color\"\n \t\"io\"\n-\t\"os\"\n )\n \n // Color type, as per the PNG spec.\n@@ -90,14 +89,14 @@ type decoder struct {\n // A FormatError reports that the input is not a valid PNG.\n type FormatError string\n \n-func (e FormatError) String() string { return \"png: invalid format: \" + string(e) }\n+func (e FormatError) Error() string { return \"png: invalid format: \" + string(e) }\n \n var chunkOrderError = FormatError(\"chunk out of order\")\n \n // An UnsupportedError reports that the input uses a valid but unimplemented PNG feature.\n type UnsupportedError string\n \n-func (e UnsupportedError) String() string { return \"png: unsupported feature: \" + string(e) }\n+func (e UnsupportedError) Error() string { return \"png: unsupported feature: \" + string(e) }\n \n func abs(x int) int {\n \tif x < 0 {\n@@ -113,7 +112,7 @@ func min(a, b int) int {\n \treturn b\n }\n \n-func (d *decoder) parseIHDR(length uint32) os.Error {\n+func (d *decoder) parseIHDR(length uint32) error {\n \tif length != 13 {\n \t\treturn FormatError(\"bad IHDR length\")\n \t}\n@@ -189,7 +188,7 @@ func (d *decoder) parseIHDR(length uint32) os.Error {\n \treturn d.verifyChecksum()\n }\n \n-func (d *decoder) parsePLTE(length uint32) os.Error {\n+func (d *decoder) parsePLTE(length uint32) error {\n \tnp := int(length / 3) // The number of palette entries.\n \tif length%3 != 0 || np <= 0 || np > 256 || np > 1<<uint(d.depth) {\n \t\treturn FormatError(\"bad PLTE length\")\n@@ -214,7 +213,7 @@ func (d *decoder) parsePLTE(length uint32) os.Error {\n \treturn d.verifyChecksum()\n }\n \n-func (d *decoder) parsetRNS(length uint32) os.Error {\n+func (d *decoder) parsetRNS(length uint32) error {\n \tif length > 256 {\n \t\treturn FormatError(\"bad tRNS length\")\n \t}\n@@ -263,7 +262,7 @@ func paeth(a, b, c uint8) uint8 {\n // immediately before the first Read call is that d.r is positioned between the\n // first IDAT and xxx, and the decoder state immediately after the last Read\n // call is that d.r is positioned between yy and crc1.\n-func (d *decoder) Read(p []byte) (int, os.Error) {\n+func (d *decoder) Read(p []byte) (int, error) {\n \tif len(p) == 0 {\n \t\treturn 0, nil\n \t}\n@@ -294,7 +293,7 @@ func (d *decoder) Read(p []byte) (int, os.Error) {\n }\n \n // decode decodes the IDAT data into an image.\n-func (d *decoder) decode() (image.Image, os.Error) {\n+func (d *decoder) decode() (image.Image, error) {\n \tr, err := zlib.NewReader(d)\n \tif err != nil {\n \t\treturn nil, err\n@@ -517,8 +516,8 @@ func (d *decoder) decode() (image.Image, os.Error) {\n \n \t// Check for EOF, to verify the zlib checksum.\n \tn, err := r.Read(pr[:1])\n-\tif err != os.EOF {\n-\t\treturn nil, FormatError(err.String())\n+\tif err != io.EOF {\n+\t\treturn nil, FormatError(err.Error())\n \t}\n \tif n != 0 || d.idatLength != 0 {\n \t\treturn nil, FormatError(\"too much pixel data\")\n@@ -527,7 +526,7 @@ func (d *decoder) decode() (image.Image, os.Error) {\n \treturn img, nil\n }\n \n-func (d *decoder) parseIDAT(length uint32) (err os.Error) {\n+func (d *decoder) parseIDAT(length uint32) (err error) {\n \td.idatLength = length\n \td.img, err = d.decode()\n \tif err != nil {\n@@ -536,14 +535,14 @@ func (d *decoder) parseIDAT(length uint32) (err os.Error) {\n \treturn d.verifyChecksum()\n }\n \n-func (d *decoder) parseIEND(length uint32) os.Error {\n+func (d *decoder) parseIEND(length uint32) error {\n \tif length != 0 {\n \t\treturn FormatError(\"bad IEND length\")\n \t}\n \treturn d.verifyChecksum()\n }\n \n-func (d *decoder) parseChunk() os.Error {\n+func (d *decoder) parseChunk() error {\n \t// Read the length and chunk type.\n \tn, err := io.ReadFull(d.r, d.tmp[:8])\n \tif err != nil {\n@@ -598,7 +597,7 @@ func (d *decoder) parseChunk() os.Error {\n \treturn d.verifyChecksum()\n }\n \n-func (d *decoder) verifyChecksum() os.Error {\n+func (d *decoder) verifyChecksum() error {\n \tif _, err := io.ReadFull(d.r, d.tmp[:4]); err != nil {\n \t\treturn err\n \t}\n@@ -608,7 +607,7 @@ func (d *decoder) verifyChecksum() os.Error {\n \treturn nil\n }\n \n-func (d *decoder) checkHeader() os.Error {\n+func (d *decoder) checkHeader() error {\n \t_, err := io.ReadFull(d.r, d.tmp[:len(pngHeader)])\n \tif err != nil {\n \t\treturn err\n@@ -621,20 +620,20 @@ func (d *decoder) checkHeader() os.Error {\n \n // Decode reads a PNG image from r and returns it as an image.Image.\n // The type of Image returned depends on the PNG contents.\n-func Decode(r io.Reader) (image.Image, os.Error) {\n+func Decode(r io.Reader) (image.Image, error) {\n \td := &decoder{\n \t\tr:   r,\n \t\tcrc: crc32.NewIEEE(),\n \t}\n \tif err := d.checkHeader(); err != nil {\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\terr = io.ErrUnexpectedEOF\n \t\t}\n \t\treturn nil, err\n \t}\n \tfor d.stage != dsSeenIEND {\n \t\tif err := d.parseChunk(); err != nil {\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\terr = io.ErrUnexpectedEOF\n \t\t\t}\n \t\t\treturn nil, err\n@@ -645,20 +644,20 @@ func Decode(r io.Reader) (image.Image, os.Error) {\n \n // DecodeConfig returns the color model and dimensions of a PNG image without\n // decoding the entire image.\n-func DecodeConfig(r io.Reader) (image.Config, os.Error) {\n+func DecodeConfig(r io.Reader) (image.Config, error) {\n \td := &decoder{\n \t\tr:   r,\n \t\tcrc: crc32.NewIEEE(),\n \t}\n \tif err := d.checkHeader(); err != nil {\n-\t\tif err == os.EOF {\n+\t\tif err == io.EOF {\n \t\t\terr = io.ErrUnexpectedEOF\n \t\t}\n \t\treturn image.Config{}, err\n \t}\n \tfor {\n \t\tif err := d.parseChunk(); err != nil {\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\terr = io.ErrUnexpectedEOF\n \t\t\t}\n \t\t\treturn image.Config{}, err"}, {"sha": "7eb1fc21a892ad19969c3f1a6fa4d556bcaed97a", "filename": "libgo/go/image/png/reader_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -43,7 +43,7 @@ var filenamesShort = []string{\n \t\"basn6a16\",\n }\n \n-func readPNG(filename string) (image.Image, os.Error) {\n+func readPNG(filename string) (image.Image, error) {\n \tf, err := os.Open(filename)\n \tif err != nil {\n \t\treturn nil, err\n@@ -223,7 +223,7 @@ func TestReader(t *testing.T) {\n \t\tfor {\n \t\t\tps, perr := pb.ReadString('\\n')\n \t\t\tss, serr := sb.ReadString('\\n')\n-\t\t\tif perr == os.EOF && serr == os.EOF {\n+\t\t\tif perr == io.EOF && serr == io.EOF {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tif perr != nil {\n@@ -259,7 +259,7 @@ func TestReaderError(t *testing.T) {\n \t\t\tt.Errorf(\"decoding %s: missing error\", tt.file)\n \t\t\tcontinue\n \t\t}\n-\t\tif !strings.Contains(err.String(), tt.err) {\n+\t\tif !strings.Contains(err.Error(), tt.err) {\n \t\t\tt.Errorf(\"decoding %s: %s, want %s\", tt.file, err, tt.err)\n \t\t}\n \t\tif img != nil {"}, {"sha": "48089ff75c7f091c954fc4541488cb4131f30c4a", "filename": "libgo/go/image/png/writer.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -11,15 +11,14 @@ import (\n \t\"image\"\n \t\"image/color\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n )\n \n type encoder struct {\n \tw      io.Writer\n \tm      image.Image\n \tcb     int\n-\terr    os.Error\n+\terr    error\n \theader [8]byte\n \tfooter [4]byte\n \ttmp    [3 * 256]byte\n@@ -161,7 +160,7 @@ func (e *encoder) maybeWritetRNS(p color.Palette) {\n //\n // This method should only be called from writeIDATs (via writeImage).\n // No other code should treat an encoder as an io.Writer.\n-func (e *encoder) Write(b []byte) (int, os.Error) {\n+func (e *encoder) Write(b []byte) (int, error) {\n \te.writeChunk(b, \"IDAT\")\n \tif e.err != nil {\n \t\treturn 0, e.err\n@@ -263,7 +262,7 @@ func filter(cr *[nFilter][]byte, pr []byte, bpp int) int {\n \treturn filter\n }\n \n-func writeImage(w io.Writer, m image.Image, cb int) os.Error {\n+func writeImage(w io.Writer, m image.Image, cb int) error {\n \tzw, err := zlib.NewWriter(w)\n \tif err != nil {\n \t\treturn err\n@@ -424,7 +423,7 @@ func (e *encoder) writeIEND() { e.writeChunk(e.tmp[0:0], \"IEND\") }\n \n // Encode writes the Image m to w in PNG format. Any Image may be encoded, but\n // images that are not image.NRGBA might be encoded lossily.\n-func Encode(w io.Writer, m image.Image) os.Error {\n+func Encode(w io.Writer, m image.Image) error {\n \t// Obviously, negative widths and heights are invalid. Furthermore, the PNG\n \t// spec section 11.2.2 says that zero is invalid. Excessively large images are\n \t// also rejected."}, {"sha": "1757e14cada5107054bb57baf7ee42e427fc16ed", "filename": "libgo/go/image/png/writer_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -10,11 +10,10 @@ import (\n \t\"image\"\n \t\"image/color\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"testing\"\n )\n \n-func diff(m0, m1 image.Image) os.Error {\n+func diff(m0, m1 image.Image) error {\n \tb0, b1 := m0.Bounds(), m1.Bounds()\n \tif !b0.Size().Eq(b1.Size()) {\n \t\treturn fmt.Errorf(\"dimensions differ: %v vs %v\", b0, b1)\n@@ -35,7 +34,7 @@ func diff(m0, m1 image.Image) os.Error {\n \treturn nil\n }\n \n-func encodeDecode(m image.Image) (image.Image, os.Error) {\n+func encodeDecode(m image.Image) (image.Image, error) {\n \tb := bytes.NewBuffer(nil)\n \terr := Encode(b, m)\n \tif err != nil {"}, {"sha": "ce350738ed8c1fab617abe48914de9c0f269427a", "filename": "libgo/go/image/tiff/buffer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -15,7 +15,7 @@ type buffer struct {\n \tbuf []byte\n }\n \n-func (b *buffer) ReadAt(p []byte, off int64) (int, os.Error) {\n+func (b *buffer) ReadAt(p []byte, off int64) (int, error) {\n \to := int(off)\n \tend := o + len(p)\n \tif int64(end) != off+int64(len(p)) {"}, {"sha": "e13afb36192b2e71820dd0b187495dada9bea93e", "filename": "libgo/go/image/tiff/buffer_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,7 +5,7 @@\n package tiff\n \n import (\n-\t\"os\"\n+\t\"io\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -14,13 +14,13 @@ var readAtTests = []struct {\n \tn   int\n \toff int64\n \ts   string\n-\terr os.Error\n+\terr error\n }{\n \t{2, 0, \"ab\", nil},\n \t{6, 0, \"abcdef\", nil},\n \t{3, 3, \"def\", nil},\n-\t{3, 5, \"f\", os.EOF},\n-\t{3, 6, \"\", os.EOF},\n+\t{3, 5, \"f\", io.EOF},\n+\t{3, 6, \"\", io.EOF},\n }\n \n func TestReadAt(t *testing.T) {"}, {"sha": "40c7fd86c3001806423b1a7e26eeaec292d83470", "filename": "libgo/go/image/tiff/compress.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Ftiff%2Fcompress.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Ftiff%2Fcompress.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Fcompress.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package tiff\n import (\n \t\"bufio\"\n \t\"io\"\n-\t\"os\"\n )\n \n type byteReader interface {\n@@ -20,7 +19,7 @@ type byteReader interface {\n //\n // The PackBits compression format is described in section 9 (p. 42)\n // of the TIFF spec.\n-func unpackBits(r io.Reader) ([]byte, os.Error) {\n+func unpackBits(r io.Reader) ([]byte, error) {\n \tbuf := make([]byte, 128)\n \tdst := make([]byte, 0, 1024)\n \tbr, ok := r.(byteReader)\n@@ -31,7 +30,7 @@ func unpackBits(r io.Reader) ([]byte, os.Error) {\n \tfor {\n \t\tb, err := br.ReadByte()\n \t\tif err != nil {\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\treturn dst, nil\n \t\t\t}\n \t\t\treturn nil, err"}, {"sha": "00a51db9f4c6d40c4e6e006d196ca7777c05a67d", "filename": "libgo/go/image/tiff/reader.go", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -15,28 +15,27 @@ import (\n \t\"image/color\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n )\n \n // A FormatError reports that the input is not a valid TIFF image.\n type FormatError string\n \n-func (e FormatError) String() string {\n+func (e FormatError) Error() string {\n \treturn \"tiff: invalid format: \" + string(e)\n }\n \n // An UnsupportedError reports that the input uses a valid but\n // unimplemented feature.\n type UnsupportedError string\n \n-func (e UnsupportedError) String() string {\n+func (e UnsupportedError) Error() string {\n \treturn \"tiff: unsupported feature: \" + string(e)\n }\n \n // An InternalError reports that an internal error was encountered.\n type InternalError string\n \n-func (e InternalError) String() string {\n+func (e InternalError) Error() string {\n \treturn \"tiff: internal error: \" + string(e)\n }\n \n@@ -66,7 +65,7 @@ func (d *decoder) firstVal(tag int) uint {\n \n // ifdUint decodes the IFD entry in p, which must be of the Byte, Short\n // or Long type, and returns the decoded uint values.\n-func (d *decoder) ifdUint(p []byte) (u []uint, err os.Error) {\n+func (d *decoder) ifdUint(p []byte) (u []uint, err error) {\n \tvar raw []byte\n \tdatatype := d.byteOrder.Uint16(p[2:4])\n \tcount := d.byteOrder.Uint32(p[4:8])\n@@ -103,7 +102,7 @@ func (d *decoder) ifdUint(p []byte) (u []uint, err os.Error) {\n \n // parseIFD decides whether the the IFD entry in p is \"interesting\" and\n // stows away the data in the decoder.\n-func (d *decoder) parseIFD(p []byte) os.Error {\n+func (d *decoder) parseIFD(p []byte) error {\n \ttag := d.byteOrder.Uint16(p[0:2])\n \tswitch tag {\n \tcase tBitsPerSample,\n@@ -180,7 +179,7 @@ func (d *decoder) flushBits() {\n \n // decode decodes the raw data of an image.\n // It reads from d.buf and writes the strip with ymin <= y < ymax into dst.\n-func (d *decoder) decode(dst image.Image, ymin, ymax int) os.Error {\n+func (d *decoder) decode(dst image.Image, ymin, ymax int) error {\n \td.off = 0\n \n \t// Apply horizontal predictor if necessary.\n@@ -255,7 +254,7 @@ func (d *decoder) decode(dst image.Image, ymin, ymax int) os.Error {\n \treturn nil\n }\n \n-func newDecoder(r io.Reader) (*decoder, os.Error) {\n+func newDecoder(r io.Reader) (*decoder, error) {\n \td := &decoder{\n \t\tr:        newReaderAt(r),\n \t\tfeatures: make(map[int][]uint),\n@@ -350,7 +349,7 @@ func newDecoder(r io.Reader) (*decoder, os.Error) {\n \n // DecodeConfig returns the color model and dimensions of a TIFF image without\n // decoding the entire image.\n-func DecodeConfig(r io.Reader) (image.Config, os.Error) {\n+func DecodeConfig(r io.Reader) (image.Config, error) {\n \td, err := newDecoder(r)\n \tif err != nil {\n \t\treturn image.Config{}, err\n@@ -360,7 +359,7 @@ func DecodeConfig(r io.Reader) (image.Config, os.Error) {\n \n // Decode reads a TIFF image from r and returns it as an image.Image.\n // The type of Image returned depends on the contents of the TIFF.\n-func Decode(r io.Reader) (img image.Image, err os.Error) {\n+func Decode(r io.Reader) (img image.Image, err error) {\n \td, err := newDecoder(r)\n \tif err != nil {\n \t\treturn"}, {"sha": "1a3d23bbd75548b0dd2c0fc9cc551abb45de1308", "filename": "libgo/go/image/tiff/reader_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Ftiff%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fimage%2Ftiff%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Freader_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -13,7 +13,7 @@ import (\n )\n \n // Read makes *buffer implements io.Reader, so that we can pass one to Decode.\n-func (*buffer) Read([]byte) (int, os.Error) {\n+func (*buffer) Read([]byte) (int, error) {\n \tpanic(\"unimplemented\")\n }\n "}, {"sha": "c59ae6eef1fd26d32524585a5a4a0d4a08629f3b", "filename": "libgo/go/index/suffixarray/suffixarray.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -20,7 +20,6 @@ import (\n \t\"bytes\"\n \t\"encoding/binary\"\n \t\"io\"\n-\t\"os\"\n \t\"regexp\"\n \t\"sort\"\n )\n@@ -38,22 +37,22 @@ func New(data []byte) *Index {\n }\n \n // writeInt writes an int x to w using buf to buffer the write.\n-func writeInt(w io.Writer, buf []byte, x int) os.Error {\n+func writeInt(w io.Writer, buf []byte, x int) error {\n \tbinary.PutVarint(buf, int64(x))\n \t_, err := w.Write(buf[0:binary.MaxVarintLen64])\n \treturn err\n }\n \n // readInt reads an int x from r using buf to buffer the read and returns x.\n-func readInt(r io.Reader, buf []byte) (int, os.Error) {\n+func readInt(r io.Reader, buf []byte) (int, error) {\n \t_, err := io.ReadFull(r, buf[0:binary.MaxVarintLen64]) // ok to continue with error\n \tx, _ := binary.Varint(buf)\n \treturn int(x), err\n }\n \n // writeSlice writes data[:n] to w and returns n.\n // It uses buf to buffer the write.\n-func writeSlice(w io.Writer, buf []byte, data []int) (n int, err os.Error) {\n+func writeSlice(w io.Writer, buf []byte, data []int) (n int, err error) {\n \t// encode as many elements as fit into buf\n \tp := binary.MaxVarintLen64\n \tfor ; n < len(data) && p+binary.MaxVarintLen64 <= len(buf); n++ {\n@@ -70,7 +69,7 @@ func writeSlice(w io.Writer, buf []byte, data []int) (n int, err os.Error) {\n \n // readSlice reads data[:n] from r and returns n.\n // It uses buf to buffer the read.\n-func readSlice(r io.Reader, buf []byte, data []int) (n int, err os.Error) {\n+func readSlice(r io.Reader, buf []byte, data []int) (n int, err error) {\n \t// read buffer size\n \tvar size int\n \tsize, err = readInt(r, buf)\n@@ -96,7 +95,7 @@ func readSlice(r io.Reader, buf []byte, data []int) (n int, err os.Error) {\n const bufSize = 16 << 10 // reasonable for BenchmarkSaveRestore\n \n // Read reads the index from r into x; x must not be nil.\n-func (x *Index) Read(r io.Reader) os.Error {\n+func (x *Index) Read(r io.Reader) error {\n \t// buffer for all reads\n \tbuf := make([]byte, bufSize)\n \n@@ -135,7 +134,7 @@ func (x *Index) Read(r io.Reader) os.Error {\n }\n \n // Write writes the index x to w.\n-func (x *Index) Write(w io.Writer) os.Error {\n+func (x *Index) Write(w io.Writer) error {\n \t// buffer for all writes\n \tbuf := make([]byte, bufSize)\n "}, {"sha": "098d2234b4fb5aa63099a895699478fcd98c061a", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 55, "deletions": 47, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -8,25 +8,30 @@\n // abstract the functionality, plus some other related primitives.\n package io\n \n-import \"os\"\n-\n // Error represents an unexpected I/O behavior.\n type Error struct {\n \tErrorString string\n }\n \n-func (err *Error) String() string { return err.ErrorString }\n+func (err *Error) Error() string { return err.ErrorString }\n \n // ErrShortWrite means that a write accepted fewer bytes than requested\n // but failed to return an explicit error.\n-var ErrShortWrite os.Error = &Error{\"short write\"}\n+var ErrShortWrite error = &Error{\"short write\"}\n \n // ErrShortBuffer means that a read required a longer buffer than was provided.\n-var ErrShortBuffer os.Error = &Error{\"short buffer\"}\n+var ErrShortBuffer error = &Error{\"short buffer\"}\n+\n+// EOF is the error returned by Read when no more input is available.\n+// Functions should return EOF only to signal a graceful end of input.\n+// If the EOF occurs unexpectedly in a structured data stream,\n+// the appropriate error is either ErrUnexpectedEOF or some other error\n+// giving more detail.\n+var EOF error = &Error{\"EOF\"}\n \n-// ErrUnexpectedEOF means that os.EOF was encountered in the\n+// ErrUnexpectedEOF means that EOF was encountered in the\n // middle of reading a fixed-size block or data structure.\n-var ErrUnexpectedEOF os.Error = &Error{\"unexpected EOF\"}\n+var ErrUnexpectedEOF error = &Error{\"unexpected EOF\"}\n \n // Reader is the interface that wraps the basic Read method.\n //\n@@ -42,15 +47,15 @@ var ErrUnexpectedEOF os.Error = &Error{\"unexpected EOF\"}\n // or return the error (and n == 0) from a subsequent call.\n // An instance of this general case is that a Reader returning\n // a non-zero number of bytes at the end of the input stream may\n-// return either err == os.EOF or err == nil.  The next Read should\n-// return 0, os.EOF regardless.\n+// return either err == EOF or err == nil.  The next Read should\n+// return 0, EOF regardless.\n //\n // Callers should always process the n > 0 bytes returned before\n // considering the error err.  Doing so correctly handles I/O errors\n // that happen after reading some bytes and also both of the\n // allowed EOF behaviors.\n type Reader interface {\n-\tRead(p []byte) (n int, err os.Error)\n+\tRead(p []byte) (n int, err error)\n }\n \n // Writer is the interface that wraps the basic Write method.\n@@ -60,12 +65,12 @@ type Reader interface {\n // and any error encountered that caused the write to stop early.\n // Write must return a non-nil error if it returns n < len(p).\n type Writer interface {\n-\tWrite(p []byte) (n int, err os.Error)\n+\tWrite(p []byte) (n int, err error)\n }\n \n // Closer is the interface that wraps the basic Close method.\n type Closer interface {\n-\tClose() os.Error\n+\tClose() error\n }\n \n // Seeker is the interface that wraps the basic Seek method.\n@@ -76,7 +81,7 @@ type Closer interface {\n // relative to the end.  Seek returns the new offset and an Error, if\n // any.\n type Seeker interface {\n-\tSeek(offset int64, whence int) (ret int64, err os.Error)\n+\tSeek(offset int64, whence int) (ret int64, err error)\n }\n \n // ReadWriter is the interface that groups the basic Read and Write methods.\n@@ -125,12 +130,12 @@ type ReadWriteSeeker interface {\n \n // ReaderFrom is the interface that wraps the ReadFrom method.\n type ReaderFrom interface {\n-\tReadFrom(r Reader) (n int64, err os.Error)\n+\tReadFrom(r Reader) (n int64, err error)\n }\n \n // WriterTo is the interface that wraps the WriteTo method.\n type WriterTo interface {\n-\tWriteTo(w Writer) (n int64, err os.Error)\n+\tWriteTo(w Writer) (n int64, err error)\n }\n \n // ReaderAt is the interface that wraps the basic ReadAt method.\n@@ -149,13 +154,13 @@ type WriterTo interface {\n // In this respect ReadAt is different from Read.\n //\n // If the n = len(p) bytes returned by ReadAt are at the end of the\n-// input source, ReadAt may return either err == os.EOF or err == nil.\n+// input source, ReadAt may return either err == EOF or err == nil.\n //\n // If ReadAt is reading from an input source with a seek offset,\n // ReadAt should not affect nor be affected by the underlying\n // seek offset.\n type ReaderAt interface {\n-\tReadAt(p []byte, off int64) (n int, err os.Error)\n+\tReadAt(p []byte, off int64) (n int, err error)\n }\n \n // WriterAt is the interface that wraps the basic WriteAt method.\n@@ -165,15 +170,15 @@ type ReaderAt interface {\n // and any error encountered that caused the write to stop early.\n // WriteAt must return a non-nil error if it returns n < len(p).\n type WriterAt interface {\n-\tWriteAt(p []byte, off int64) (n int, err os.Error)\n+\tWriteAt(p []byte, off int64) (n int, err error)\n }\n \n // ByteReader is the interface that wraps the ReadByte method.\n //\n // ReadByte reads and returns the next byte from the input.\n // If no byte is available, err will be set.\n type ByteReader interface {\n-\tReadByte() (c byte, err os.Error)\n+\tReadByte() (c byte, err error)\n }\n \n // ByteScanner is the interface that adds the UnreadByte method to the\n@@ -185,7 +190,7 @@ type ByteReader interface {\n // call to ReadByte.\n type ByteScanner interface {\n \tByteReader\n-\tUnreadByte() os.Error\n+\tUnreadByte() error\n }\n \n // RuneReader is the interface that wraps the ReadRune method.\n@@ -194,7 +199,7 @@ type ByteScanner interface {\n // and returns the rune and its size in bytes. If no character is\n // available, err will be set.\n type RuneReader interface {\n-\tReadRune() (r rune, size int, err os.Error)\n+\tReadRune() (r rune, size int, err error)\n }\n \n // RuneScanner is the interface that adds the UnreadRune method to the\n@@ -206,16 +211,16 @@ type RuneReader interface {\n // call to ReadRune.\n type RuneScanner interface {\n \tRuneReader\n-\tUnreadRune() os.Error\n+\tUnreadRune() error\n }\n \n // stringWriter is the interface that wraps the WriteString method.\n type stringWriter interface {\n-\tWriteString(s string) (n int, err os.Error)\n+\tWriteString(s string) (n int, err error)\n }\n \n // WriteString writes the contents of the string s to w, which accepts an array of bytes.\n-func WriteString(w Writer, s string) (n int, err os.Error) {\n+func WriteString(w Writer, s string) (n int, err error) {\n \tif sw, ok := w.(stringWriter); ok {\n \t\treturn sw.WriteString(s)\n \t}\n@@ -224,11 +229,11 @@ func WriteString(w Writer, s string) (n int, err os.Error) {\n \n // ReadAtLeast reads from r into buf until it has read at least min bytes.\n // It returns the number of bytes copied and an error if fewer bytes were read.\n-// The error is os.EOF only if no bytes were read.\n+// The error is EOF only if no bytes were read.\n // If an EOF happens after reading fewer than min bytes,\n // ReadAtLeast returns ErrUnexpectedEOF.\n // If min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\n-func ReadAtLeast(r Reader, buf []byte, min int) (n int, err os.Error) {\n+func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error) {\n \tif len(buf) < min {\n \t\treturn 0, ErrShortBuffer\n \t}\n@@ -237,7 +242,7 @@ func ReadAtLeast(r Reader, buf []byte, min int) (n int, err os.Error) {\n \t\tnn, err = r.Read(buf[n:])\n \t\tn += nn\n \t}\n-\tif err == os.EOF {\n+\tif err == EOF {\n \t\tif n >= min {\n \t\t\terr = nil\n \t\t} else if n > 0 {\n@@ -249,29 +254,29 @@ func ReadAtLeast(r Reader, buf []byte, min int) (n int, err os.Error) {\n \n // ReadFull reads exactly len(buf) bytes from r into buf.\n // It returns the number of bytes copied and an error if fewer bytes were read.\n-// The error is os.EOF only if no bytes were read.\n+// The error is EOF only if no bytes were read.\n // If an EOF happens after reading some but not all the bytes,\n // ReadFull returns ErrUnexpectedEOF.\n-func ReadFull(r Reader, buf []byte) (n int, err os.Error) {\n+func ReadFull(r Reader, buf []byte) (n int, err error) {\n \treturn ReadAtLeast(r, buf, len(buf))\n }\n \n // CopyN copies n bytes (or until an error) from src to dst.\n // It returns the number of bytes copied and the earliest\n // error encountered while copying.  Because Read can\n // return the full amount requested as well as an error\n-// (including os.EOF), so can CopyN.\n+// (including EOF), so can CopyN.\n //\n // If dst implements the ReaderFrom interface,\n // the copy is implemented by calling dst.ReadFrom(src).\n-func CopyN(dst Writer, src Reader, n int64) (written int64, err os.Error) {\n+func CopyN(dst Writer, src Reader, n int64) (written int64, err error) {\n \t// If the writer has a ReadFrom method, use it to do the copy.\n \t// Avoids a buffer allocation and a copy.\n \tif rt, ok := dst.(ReaderFrom); ok {\n \t\twritten, err = rt.ReadFrom(LimitReader(src, n))\n \t\tif written < n && err == nil {\n \t\t\t// rt stopped early; must have been EOF.\n-\t\t\terr = os.EOF\n+\t\t\terr = EOF\n \t\t}\n \t\treturn\n \t}\n@@ -308,15 +313,15 @@ func CopyN(dst Writer, src Reader, n int64) (written int64, err os.Error) {\n // on src or an error occurs.  It returns the number of bytes\n // copied and the first error encountered while copying, if any.\n //\n-// A successful Copy returns err == nil, not err == os.EOF.\n+// A successful Copy returns err == nil, not err == EOF.\n // Because Copy is defined to read from src until EOF, it does\n // not treat an EOF from Read as an error to be reported.\n //\n // If dst implements the ReaderFrom interface,\n // the copy is implemented by calling dst.ReadFrom(src).\n // Otherwise, if src implements the WriterTo interface,\n // the copy is implemented by calling src.WriteTo(dst).\n-func Copy(dst Writer, src Reader) (written int64, err os.Error) {\n+func Copy(dst Writer, src Reader) (written int64, err error) {\n \t// If the writer has a ReadFrom method, use it to do the copy.\n \t// Avoids an allocation and a copy.\n \tif rt, ok := dst.(ReaderFrom); ok {\n@@ -343,7 +348,7 @@ func Copy(dst Writer, src Reader) (written int64, err os.Error) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n-\t\tif er == os.EOF {\n+\t\tif er == EOF {\n \t\t\tbreak\n \t\t}\n \t\tif er != nil {\n@@ -355,7 +360,7 @@ func Copy(dst Writer, src Reader) (written int64, err os.Error) {\n }\n \n // LimitReader returns a Reader that reads from r\n-// but stops with os.EOF after n bytes.\n+// but stops with EOF after n bytes.\n // The underlying implementation is a *LimitedReader.\n func LimitReader(r Reader, n int64) Reader { return &LimitedReader{r, n} }\n \n@@ -367,9 +372,9 @@ type LimitedReader struct {\n \tN int64  // max bytes remaining\n }\n \n-func (l *LimitedReader) Read(p []byte) (n int, err os.Error) {\n+func (l *LimitedReader) Read(p []byte) (n int, err error) {\n \tif l.N <= 0 {\n-\t\treturn 0, os.EOF\n+\t\treturn 0, EOF\n \t}\n \tif int64(len(p)) > l.N {\n \t\tp = p[0:l.N]\n@@ -380,7 +385,7 @@ func (l *LimitedReader) Read(p []byte) (n int, err os.Error) {\n }\n \n // NewSectionReader returns a SectionReader that reads from r\n-// starting at offset off and stops with os.EOF after n bytes.\n+// starting at offset off and stops with EOF after n bytes.\n func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader {\n \treturn &SectionReader{r, off, off, off + n}\n }\n@@ -394,9 +399,9 @@ type SectionReader struct {\n \tlimit int64\n }\n \n-func (s *SectionReader) Read(p []byte) (n int, err os.Error) {\n+func (s *SectionReader) Read(p []byte) (n int, err error) {\n \tif s.off >= s.limit {\n-\t\treturn 0, os.EOF\n+\t\treturn 0, EOF\n \t}\n \tif max := s.limit - s.off; int64(len(p)) > max {\n \t\tp = p[0:max]\n@@ -406,10 +411,13 @@ func (s *SectionReader) Read(p []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err os.Error) {\n+var errWhence = &Error{\"Seek: invalid whence\"}\n+var errOffset = &Error{\"Seek: invalid offset\"}\n+\n+func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err error) {\n \tswitch whence {\n \tdefault:\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, errWhence\n \tcase 0:\n \t\toffset += s.base\n \tcase 1:\n@@ -418,15 +426,15 @@ func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err os.Error)\n \t\toffset += s.limit\n \t}\n \tif offset < s.base || offset > s.limit {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, errOffset\n \t}\n \ts.off = offset\n \treturn offset - s.base, nil\n }\n \n-func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err os.Error) {\n+func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error) {\n \tif off < 0 || off >= s.limit-s.base {\n-\t\treturn 0, os.EOF\n+\t\treturn 0, EOF\n \t}\n \toff += s.base\n \tif max := s.limit - off; int64(len(p)) > max {\n@@ -452,7 +460,7 @@ type teeReader struct {\n \tw Writer\n }\n \n-func (t *teeReader) Read(p []byte) (n int, err os.Error) {\n+func (t *teeReader) Read(p []byte) (n int, err error) {\n \tn, err = t.r.Read(p)\n \tif n > 0 {\n \t\tif n, err := t.w.Write(p[:n]); err != nil {"}, {"sha": "1e671b59b3368b87f0df0daf2130d10365bbdbf6", "filename": "libgo/go/io/io_test.go", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package io_test\n import (\n \t\"bytes\"\n \t. \"io\"\n-\t\"os\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -85,7 +84,7 @@ type noReadFrom struct {\n \tw Writer\n }\n \n-func (w *noReadFrom) Write(p []byte) (n int, err os.Error) {\n+func (w *noReadFrom) Write(p []byte) (n int, err error) {\n \treturn w.w.Write(p)\n }\n \n@@ -101,7 +100,7 @@ func TestCopyNEOF(t *testing.T) {\n \t}\n \n \tn, err = CopyN(&noReadFrom{b}, strings.NewReader(\"foo\"), 4)\n-\tif n != 3 || err != os.EOF {\n+\tif n != 3 || err != EOF {\n \t\tt.Errorf(\"CopyN(noReadFrom, foo, 4) = %d, %v; want 3, EOF\", n, err)\n \t}\n \n@@ -111,7 +110,7 @@ func TestCopyNEOF(t *testing.T) {\n \t}\n \n \tn, err = CopyN(b, strings.NewReader(\"foo\"), 4) // b has read from\n-\tif n != 3 || err != os.EOF {\n+\tif n != 3 || err != EOF {\n \t\tt.Errorf(\"CopyN(bytes.Buffer, foo, 4) = %d, %v; want 3, EOF\", n, err)\n \t}\n }\n@@ -121,16 +120,16 @@ func TestReadAtLeast(t *testing.T) {\n \ttestReadAtLeast(t, &rb)\n }\n \n-// A version of bytes.Buffer that returns n > 0, os.EOF on Read\n+// A version of bytes.Buffer that returns n > 0, EOF on Read\n // when the input is exhausted.\n type dataAndEOFBuffer struct {\n \tbytes.Buffer\n }\n \n-func (r *dataAndEOFBuffer) Read(p []byte) (n int, err os.Error) {\n+func (r *dataAndEOFBuffer) Read(p []byte) (n int, err error) {\n \tn, err = r.Buffer.Read(p)\n \tif n > 0 && r.Buffer.Len() == 0 && err == nil {\n-\t\terr = os.EOF\n+\t\terr = EOF\n \t}\n \treturn\n }\n@@ -162,7 +161,7 @@ func testReadAtLeast(t *testing.T, rb ReadWriter) {\n \t\tt.Errorf(\"expected to have read 2 bytes, got %v\", n)\n \t}\n \tn, err = ReadAtLeast(rb, buf, 2)\n-\tif err != os.EOF {\n+\tif err != EOF {\n \t\tt.Errorf(\"expected EOF, got %v\", err)\n \t}\n \tif n != 0 {\n@@ -193,14 +192,14 @@ func TestTeeReader(t *testing.T) {\n \tif !bytes.Equal(wb.Bytes(), src) {\n \t\tt.Errorf(\"bytes written = %q want %q\", wb.Bytes(), src)\n \t}\n-\tif n, err := r.Read(dst); n != 0 || err != os.EOF {\n+\tif n, err := r.Read(dst); n != 0 || err != EOF {\n \t\tt.Errorf(\"r.Read at EOF = %d, %v want 0, EOF\", n, err)\n \t}\n \trb = bytes.NewBuffer(src)\n \tpr, pw := Pipe()\n \tpr.Close()\n \tr = TeeReader(rb, pw)\n-\tif n, err := ReadFull(r, dst); n != 0 || err != os.EPIPE {\n+\tif n, err := ReadFull(r, dst); n != 0 || err != ErrClosedPipe {\n \t\tt.Errorf(\"closed tee: ReadFull(r, dst) = %d, %v; want 0, EPIPE\", n, err)\n \t}\n }"}, {"sha": "f6c8cd8a87391fc69db932b6991fa01109a6ced9", "filename": "libgo/go/io/ioutil/ioutil.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -14,19 +14,19 @@ import (\n \n // readAll reads from r until an error or EOF and returns the data it read\n // from the internal buffer allocated with a specified capacity.\n-func readAll(r io.Reader, capacity int64) ([]byte, os.Error) {\n+func readAll(r io.Reader, capacity int64) ([]byte, error) {\n \tbuf := bytes.NewBuffer(make([]byte, 0, capacity))\n \t_, err := buf.ReadFrom(r)\n \treturn buf.Bytes(), err\n }\n \n // ReadAll reads from r until an error or EOF and returns the data it read.\n-func ReadAll(r io.Reader) ([]byte, os.Error) {\n+func ReadAll(r io.Reader) ([]byte, error) {\n \treturn readAll(r, bytes.MinRead)\n }\n \n // ReadFile reads the file named by filename and returns the contents.\n-func ReadFile(filename string) ([]byte, os.Error) {\n+func ReadFile(filename string) ([]byte, error) {\n \tf, err := os.Open(filename)\n \tif err != nil {\n \t\treturn nil, err\n@@ -50,7 +50,7 @@ func ReadFile(filename string) ([]byte, os.Error) {\n // WriteFile writes data to a file named by filename.\n // If the file does not exist, WriteFile creates it with permissions perm;\n // otherwise WriteFile truncates it before writing.\n-func WriteFile(filename string, data []byte, perm uint32) os.Error {\n+func WriteFile(filename string, data []byte, perm uint32) error {\n \tf, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n \tif err != nil {\n \t\treturn err\n@@ -72,7 +72,7 @@ func (f fileInfoList) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }\n \n // ReadDir reads the directory named by dirname and returns\n // a list of sorted directory entries.\n-func ReadDir(dirname string) ([]*os.FileInfo, os.Error) {\n+func ReadDir(dirname string) ([]*os.FileInfo, error) {\n \tf, err := os.Open(dirname)\n \tif err != nil {\n \t\treturn nil, err\n@@ -94,7 +94,7 @@ type nopCloser struct {\n \tio.Reader\n }\n \n-func (nopCloser) Close() os.Error { return nil }\n+func (nopCloser) Close() error { return nil }\n \n // NopCloser returns a ReadCloser with a no-op Close method wrapping\n // the provided Reader r.\n@@ -108,19 +108,19 @@ type devNull int\n // ioutil.Discard can avoid doing unnecessary work.\n var _ io.ReaderFrom = devNull(0)\n \n-func (devNull) Write(p []byte) (int, os.Error) {\n+func (devNull) Write(p []byte) (int, error) {\n \treturn len(p), nil\n }\n \n var blackHole = make([]byte, 8192)\n \n-func (devNull) ReadFrom(r io.Reader) (n int64, err os.Error) {\n+func (devNull) ReadFrom(r io.Reader) (n int64, err error) {\n \treadSize := 0\n \tfor {\n \t\treadSize, err = r.Read(blackHole)\n \t\tn += int64(readSize)\n \t\tif err != nil {\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\treturn n, nil\n \t\t\t}\n \t\t\treturn"}, {"sha": "658ea78bb7c700d52a87070710fe383a68e6328c", "filename": "libgo/go/io/ioutil/tempfile.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -40,7 +40,7 @@ func nextSuffix() string {\n // will not choose the same file.  The caller can use f.Name()\n // to find the name of the file.  It is the caller's responsibility to\n // remove the file when no longer needed.\n-func TempFile(dir, prefix string) (f *os.File, err os.Error) {\n+func TempFile(dir, prefix string) (f *os.File, err error) {\n \tif dir == \"\" {\n \t\tdir = os.TempDir()\n \t}\n@@ -49,7 +49,7 @@ func TempFile(dir, prefix string) (f *os.File, err os.Error) {\n \tfor i := 0; i < 10000; i++ {\n \t\tname := filepath.Join(dir, prefix+nextSuffix())\n \t\tf, err = os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0600)\n-\t\tif pe, ok := err.(*os.PathError); ok && pe.Error == os.EEXIST {\n+\t\tif pe, ok := err.(*os.PathError); ok && pe.Err == os.EEXIST {\n \t\t\tif nconflict++; nconflict > 10 {\n \t\t\t\trand = reseed()\n \t\t\t}\n@@ -67,7 +67,7 @@ func TempFile(dir, prefix string) (f *os.File, err os.Error) {\n // Multiple programs calling TempDir simultaneously\n // will not choose the same directory.  It is the caller's responsibility\n // to remove the directory when no longer needed.\n-func TempDir(dir, prefix string) (name string, err os.Error) {\n+func TempDir(dir, prefix string) (name string, err error) {\n \tif dir == \"\" {\n \t\tdir = os.TempDir()\n \t}\n@@ -76,7 +76,7 @@ func TempDir(dir, prefix string) (name string, err os.Error) {\n \tfor i := 0; i < 10000; i++ {\n \t\ttry := filepath.Join(dir, prefix+nextSuffix())\n \t\terr = os.Mkdir(try, 0700)\n-\t\tif pe, ok := err.(*os.PathError); ok && pe.Error == os.EEXIST {\n+\t\tif pe, ok := err.(*os.PathError); ok && pe.Err == os.EEXIST {\n \t\t\tif nconflict++; nconflict > 10 {\n \t\t\t\trand = reseed()\n \t\t\t}"}, {"sha": "2c7e816cff140266eef67c7c392be23f09f436c5", "filename": "libgo/go/io/multi.go", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fmulti.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fmulti.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fmulti.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,17 +4,15 @@\n \n package io\n \n-import \"os\"\n-\n type multiReader struct {\n \treaders []Reader\n }\n \n-func (mr *multiReader) Read(p []byte) (n int, err os.Error) {\n+func (mr *multiReader) Read(p []byte) (n int, err error) {\n \tfor len(mr.readers) > 0 {\n \t\tn, err = mr.readers[0].Read(p)\n-\t\tif n > 0 || err != os.EOF {\n-\t\t\tif err == os.EOF {\n+\t\tif n > 0 || err != EOF {\n+\t\t\tif err == EOF {\n \t\t\t\t// Don't return EOF yet. There may be more bytes\n \t\t\t\t// in the remaining readers.\n \t\t\t\terr = nil\n@@ -23,12 +21,12 @@ func (mr *multiReader) Read(p []byte) (n int, err os.Error) {\n \t\t}\n \t\tmr.readers = mr.readers[1:]\n \t}\n-\treturn 0, os.EOF\n+\treturn 0, EOF\n }\n \n // MultiReader returns a Reader that's the logical concatenation of\n // the provided input readers.  They're read sequentially.  Once all\n-// inputs are drained, Read will return os.EOF.\n+// inputs are drained, Read will return EOF.\n func MultiReader(readers ...Reader) Reader {\n \treturn &multiReader{readers}\n }\n@@ -37,7 +35,7 @@ type multiWriter struct {\n \twriters []Writer\n }\n \n-func (t *multiWriter) Write(p []byte) (n int, err os.Error) {\n+func (t *multiWriter) Write(p []byte) (n int, err error) {\n \tfor _, w := range t.writers {\n \t\tn, err = w.Write(p)\n \t\tif err != nil {"}, {"sha": "bb439f04b881a70605f91fc2a9b4dc10db8cf932", "filename": "libgo/go/io/multi_test.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fmulti_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fmulti_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fmulti_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"bytes\"\n \t\"crypto/sha1\"\n \t\"fmt\"\n-\t\"os\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -26,7 +25,7 @@ func TestMultiReader(t *testing.T) {\n \t\tbuf = make([]byte, 20)\n \t\ttests()\n \t}\n-\texpectRead := func(size int, expected string, eerr os.Error) {\n+\texpectRead := func(size int, expected string, eerr error) {\n \t\tnread++\n \t\tn, gerr := mr.Read(buf[0:size])\n \t\tif n != len(expected) {\n@@ -48,13 +47,13 @@ func TestMultiReader(t *testing.T) {\n \t\texpectRead(2, \"fo\", nil)\n \t\texpectRead(5, \"o \", nil)\n \t\texpectRead(5, \"bar\", nil)\n-\t\texpectRead(5, \"\", os.EOF)\n+\t\texpectRead(5, \"\", EOF)\n \t})\n \twithFooBar(func() {\n \t\texpectRead(4, \"foo \", nil)\n \t\texpectRead(1, \"b\", nil)\n \t\texpectRead(3, \"ar\", nil)\n-\t\texpectRead(1, \"\", os.EOF)\n+\t\texpectRead(1, \"\", EOF)\n \t})\n \twithFooBar(func() {\n \t\texpectRead(5, \"foo \", nil)"}, {"sha": "3dcff0d62a16d3f0c4b0c8184b9f8cd3aa0aba01", "filename": "libgo/go/io/pipe.go", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fpipe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fpipe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fpipe.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,14 +7,14 @@\n \n package io\n \n-import (\n-\t\"os\"\n-\t\"sync\"\n-)\n+import \"sync\"\n+\n+// ErrClosedPipe is the error used for read or write operations on a closed pipe.\n+var ErrClosedPipe = &Error{\"io: read/write on closed pipe\"}\n \n type pipeResult struct {\n \tn   int\n-\terr os.Error\n+\terr error\n }\n \n // A pipe is the shared pipe structure underlying PipeReader and PipeWriter.\n@@ -25,11 +25,11 @@ type pipe struct {\n \tdata  []byte     // data remaining in pending write\n \trwait sync.Cond  // waiting reader\n \twwait sync.Cond  // waiting writer\n-\trerr  os.Error   // if reader closed, error to give writes\n-\twerr  os.Error   // if writer closed, error to give reads\n+\trerr  error      // if reader closed, error to give writes\n+\twerr  error      // if writer closed, error to give reads\n }\n \n-func (p *pipe) read(b []byte) (n int, err os.Error) {\n+func (p *pipe) read(b []byte) (n int, err error) {\n \t// One reader at a time.\n \tp.rl.Lock()\n \tdefer p.rl.Unlock()\n@@ -38,7 +38,7 @@ func (p *pipe) read(b []byte) (n int, err os.Error) {\n \tdefer p.l.Unlock()\n \tfor {\n \t\tif p.rerr != nil {\n-\t\t\treturn 0, os.EINVAL\n+\t\t\treturn 0, ErrClosedPipe\n \t\t}\n \t\tif p.data != nil {\n \t\t\tbreak\n@@ -59,7 +59,7 @@ func (p *pipe) read(b []byte) (n int, err os.Error) {\n \n var zero [0]byte\n \n-func (p *pipe) write(b []byte) (n int, err os.Error) {\n+func (p *pipe) write(b []byte) (n int, err error) {\n \t// pipe uses nil to mean not available\n \tif b == nil {\n \t\tb = zero[:]\n@@ -82,7 +82,7 @@ func (p *pipe) write(b []byte) (n int, err os.Error) {\n \t\t\tbreak\n \t\t}\n \t\tif p.werr != nil {\n-\t\t\terr = os.EINVAL\n+\t\t\terr = ErrClosedPipe\n \t\t}\n \t\tp.wwait.Wait()\n \t}\n@@ -91,9 +91,9 @@ func (p *pipe) write(b []byte) (n int, err os.Error) {\n \treturn\n }\n \n-func (p *pipe) rclose(err os.Error) {\n+func (p *pipe) rclose(err error) {\n \tif err == nil {\n-\t\terr = os.EPIPE\n+\t\terr = ErrClosedPipe\n \t}\n \tp.l.Lock()\n \tdefer p.l.Unlock()\n@@ -102,9 +102,9 @@ func (p *pipe) rclose(err os.Error) {\n \tp.wwait.Signal()\n }\n \n-func (p *pipe) wclose(err os.Error) {\n+func (p *pipe) wclose(err error) {\n \tif err == nil {\n-\t\terr = os.EOF\n+\t\terr = EOF\n \t}\n \tp.l.Lock()\n \tdefer p.l.Unlock()\n@@ -122,20 +122,20 @@ type PipeReader struct {\n // it reads data from the pipe, blocking until a writer\n // arrives or the write end is closed.\n // If the write end is closed with an error, that error is\n-// returned as err; otherwise err is os.EOF.\n-func (r *PipeReader) Read(data []byte) (n int, err os.Error) {\n+// returned as err; otherwise err is EOF.\n+func (r *PipeReader) Read(data []byte) (n int, err error) {\n \treturn r.p.read(data)\n }\n \n // Close closes the reader; subsequent writes to the\n-// write half of the pipe will return the error os.EPIPE.\n-func (r *PipeReader) Close() os.Error {\n+// write half of the pipe will return the error ErrClosedPipe.\n+func (r *PipeReader) Close() error {\n \treturn r.CloseWithError(nil)\n }\n \n // CloseWithError closes the reader; subsequent writes\n // to the write half of the pipe will return the error err.\n-func (r *PipeReader) CloseWithError(err os.Error) os.Error {\n+func (r *PipeReader) CloseWithError(err error) error {\n \tr.p.rclose(err)\n \treturn nil\n }\n@@ -149,20 +149,20 @@ type PipeWriter struct {\n // it writes data to the pipe, blocking until readers\n // have consumed all the data or the read end is closed.\n // If the read end is closed with an error, that err is\n-// returned as err; otherwise err is os.EPIPE.\n-func (w *PipeWriter) Write(data []byte) (n int, err os.Error) {\n+// returned as err; otherwise err is ErrClosedPipe.\n+func (w *PipeWriter) Write(data []byte) (n int, err error) {\n \treturn w.p.write(data)\n }\n \n // Close closes the writer; subsequent reads from the\n-// read half of the pipe will return no bytes and os.EOF.\n-func (w *PipeWriter) Close() os.Error {\n+// read half of the pipe will return no bytes and EOF.\n+func (w *PipeWriter) Close() error {\n \treturn w.CloseWithError(nil)\n }\n \n // CloseWithError closes the writer; subsequent reads from the\n // read half of the pipe will return no bytes and the error err.\n-func (w *PipeWriter) CloseWithError(err os.Error) os.Error {\n+func (w *PipeWriter) CloseWithError(err error) error {\n \tw.p.wclose(err)\n \treturn nil\n }"}, {"sha": "fabf79bd61c3b9c9fc35e637d50c40ff0c224228", "filename": "libgo/go/io/pipe_test.go", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fpipe_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fio%2Fpipe_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fpipe_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package io_test\n import (\n \t\"fmt\"\n \t. \"io\"\n-\t\"os\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -44,7 +43,7 @@ func reader(t *testing.T, r Reader, c chan int) {\n \tvar buf = make([]byte, 64)\n \tfor {\n \t\tn, err := r.Read(buf)\n-\t\tif err == os.EOF {\n+\t\tif err == EOF {\n \t\t\tc <- 0\n \t\t\tbreak\n \t\t}\n@@ -84,7 +83,7 @@ func TestPipe2(t *testing.T) {\n \n type pipeReturn struct {\n \tn   int\n-\terr os.Error\n+\terr error\n }\n \n // Test a large write that requires multiple reads to satisfy.\n@@ -106,7 +105,7 @@ func TestPipe3(t *testing.T) {\n \ttot := 0\n \tfor n := 1; n <= 256; n *= 2 {\n \t\tnn, err := r.Read(rdat[tot : tot+n])\n-\t\tif err != nil && err != os.EOF {\n+\t\tif err != nil && err != EOF {\n \t\t\tt.Fatalf(\"read: %v\", err)\n \t\t}\n \n@@ -116,7 +115,7 @@ func TestPipe3(t *testing.T) {\n \t\t\texpect = 1\n \t\t} else if n == 256 {\n \t\t\texpect = 0\n-\t\t\tif err != os.EOF {\n+\t\t\tif err != EOF {\n \t\t\t\tt.Fatalf(\"read at end: %v\", err)\n \t\t\t}\n \t\t}\n@@ -142,13 +141,13 @@ func TestPipe3(t *testing.T) {\n // Test read after/before writer close.\n \n type closer interface {\n-\tCloseWithError(os.Error) os.Error\n-\tClose() os.Error\n+\tCloseWithError(error) error\n+\tClose() error\n }\n \n type pipeTest struct {\n \tasync          bool\n-\terr            os.Error\n+\terr            error\n \tcloseWithError bool\n }\n \n@@ -167,7 +166,7 @@ var pipeTests = []pipeTest{\n \n func delayClose(t *testing.T, cl closer, ch chan int, tt pipeTest) {\n \ttime.Sleep(1e6) // 1 ms\n-\tvar err os.Error\n+\tvar err error\n \tif tt.closeWithError {\n \t\terr = cl.CloseWithError(tt.err)\n \t} else {\n@@ -193,7 +192,7 @@ func TestPipeReadClose(t *testing.T) {\n \t\t<-c\n \t\twant := tt.err\n \t\tif want == nil {\n-\t\t\twant = os.EOF\n+\t\t\twant = EOF\n \t\t}\n \t\tif err != want {\n \t\t\tt.Errorf(\"read from closed pipe: %v want %v\", err, want)\n@@ -214,8 +213,8 @@ func TestPipeReadClose2(t *testing.T) {\n \tgo delayClose(t, r, c, pipeTest{})\n \tn, err := r.Read(make([]byte, 64))\n \t<-c\n-\tif n != 0 || err != os.EINVAL {\n-\t\tt.Errorf(\"read from closed pipe: %v, %v want %v, %v\", n, err, 0, os.EINVAL)\n+\tif n != 0 || err != ErrClosedPipe {\n+\t\tt.Errorf(\"read from closed pipe: %v, %v want %v, %v\", n, err, 0, ErrClosedPipe)\n \t}\n }\n \n@@ -234,7 +233,7 @@ func TestPipeWriteClose(t *testing.T) {\n \t\t<-c\n \t\texpect := tt.err\n \t\tif expect == nil {\n-\t\t\texpect = os.EPIPE\n+\t\t\texpect = ErrClosedPipe\n \t\t}\n \t\tif err != expect {\n \t\t\tt.Errorf(\"write on closed pipe: %v want %v\", err, expect)"}, {"sha": "8abd7b4b4cb9543523a8e6010700c83030ce6e60", "filename": "libgo/go/json/decode.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -9,7 +9,7 @@ package json\n \n import (\n \t\"encoding/base64\"\n-\t\"os\"\n+\t\"errors\"\n \t\"reflect\"\n \t\"runtime\"\n \t\"strconv\"\n@@ -50,7 +50,7 @@ import (\n // If no more serious errors are encountered, Unmarshal returns\n // an UnmarshalTypeError describing the earliest such error.\n //\n-func Unmarshal(data []byte, v interface{}) os.Error {\n+func Unmarshal(data []byte, v interface{}) error {\n \td := new(decodeState).init(data)\n \n \t// Quick check for well-formedness.\n@@ -70,7 +70,7 @@ func Unmarshal(data []byte, v interface{}) os.Error {\n // encoding.  UnmarshalJSON must copy the JSON data\n // if it wishes to retain the data after returning.\n type Unmarshaler interface {\n-\tUnmarshalJSON([]byte) os.Error\n+\tUnmarshalJSON([]byte) error\n }\n \n // An UnmarshalTypeError describes a JSON value that was\n@@ -80,7 +80,7 @@ type UnmarshalTypeError struct {\n \tType  reflect.Type // type of Go value it could not be assigned to\n }\n \n-func (e *UnmarshalTypeError) String() string {\n+func (e *UnmarshalTypeError) Error() string {\n \treturn \"json: cannot unmarshal \" + e.Value + \" into Go value of type \" + e.Type.String()\n }\n \n@@ -92,7 +92,7 @@ type UnmarshalFieldError struct {\n \tField reflect.StructField\n }\n \n-func (e *UnmarshalFieldError) String() string {\n+func (e *UnmarshalFieldError) Error() string {\n \treturn \"json: cannot unmarshal object key \" + strconv.Quote(e.Key) + \" into unexported field \" + e.Field.Name + \" of type \" + e.Type.String()\n }\n \n@@ -102,7 +102,7 @@ type InvalidUnmarshalError struct {\n \tType reflect.Type\n }\n \n-func (e *InvalidUnmarshalError) String() string {\n+func (e *InvalidUnmarshalError) Error() string {\n \tif e.Type == nil {\n \t\treturn \"json: Unmarshal(nil)\"\n \t}\n@@ -113,13 +113,13 @@ func (e *InvalidUnmarshalError) String() string {\n \treturn \"json: Unmarshal(nil \" + e.Type.String() + \")\"\n }\n \n-func (d *decodeState) unmarshal(v interface{}) (err os.Error) {\n+func (d *decodeState) unmarshal(v interface{}) (err error) {\n \tdefer func() {\n \t\tif r := recover(); r != nil {\n \t\t\tif _, ok := r.(runtime.Error); ok {\n \t\t\t\tpanic(r)\n \t\t\t}\n-\t\t\terr = r.(os.Error)\n+\t\t\terr = r.(error)\n \t\t}\n \t}()\n \n@@ -142,14 +142,14 @@ type decodeState struct {\n \toff        int // read offset in data\n \tscan       scanner\n \tnextscan   scanner // for calls to nextValue\n-\tsavedError os.Error\n+\tsavedError error\n \ttempstr    string // scratch space to avoid some allocations\n }\n \n // errPhase is used for errors that should not happen unless\n // there is a bug in the JSON decoder or something is editing\n // the data slice while the decoder executes.\n-var errPhase = os.NewError(\"JSON decoder out of sync - data changing underfoot?\")\n+var errPhase = errors.New(\"JSON decoder out of sync - data changing underfoot?\")\n \n func (d *decodeState) init(data []byte) *decodeState {\n \td.data = data\n@@ -159,13 +159,13 @@ func (d *decodeState) init(data []byte) *decodeState {\n }\n \n // error aborts the decoding by panicking with err.\n-func (d *decodeState) error(err os.Error) {\n+func (d *decodeState) error(err error) {\n \tpanic(err)\n }\n \n // saveError saves the first err it is called with,\n // for reporting at the end of the unmarshal.\n-func (d *decodeState) saveError(err os.Error) {\n+func (d *decodeState) saveError(err error) {\n \tif d.savedError == nil {\n \t\td.savedError = err\n \t}"}, {"sha": "bd4326a0cd7e828721e3f44af3212ec8a58b4d1e", "filename": "libgo/go/json/decode_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -6,7 +6,6 @@ package json\n \n import (\n \t\"bytes\"\n-\t\"os\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n@@ -30,7 +29,7 @@ type unmarshaler struct {\n \tT bool\n }\n \n-func (u *unmarshaler) UnmarshalJSON(b []byte) os.Error {\n+func (u *unmarshaler) UnmarshalJSON(b []byte) error {\n \t*u = unmarshaler{true} // All we need to see that UnmarshalJson is called.\n \treturn nil\n }\n@@ -52,7 +51,7 @@ type unmarshalTest struct {\n \tin  string\n \tptr interface{}\n \tout interface{}\n-\terr os.Error\n+\terr error\n }\n \n var unmarshalTests = []unmarshalTest{"}, {"sha": "aac8f91a4473d80d510d63a68ce160153a46d67a", "filename": "libgo/go/json/encode.go", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fencode.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -12,7 +12,6 @@ package json\n import (\n \t\"bytes\"\n \t\"encoding/base64\"\n-\t\"os\"\n \t\"reflect\"\n \t\"runtime\"\n \t\"sort\"\n@@ -96,7 +95,7 @@ import (\n // handle them.  Passing cyclic structures to Marshal will result in\n // an infinite recursion.\n //\n-func Marshal(v interface{}) ([]byte, os.Error) {\n+func Marshal(v interface{}) ([]byte, error) {\n \te := &encodeState{}\n \terr := e.marshal(v)\n \tif err != nil {\n@@ -106,7 +105,7 @@ func Marshal(v interface{}) ([]byte, os.Error) {\n }\n \n // MarshalIndent is like Marshal but applies Indent to format the output.\n-func MarshalIndent(v interface{}, prefix, indent string) ([]byte, os.Error) {\n+func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {\n \tb, err := Marshal(v)\n \tif err != nil {\n \t\treturn nil, err\n@@ -120,7 +119,7 @@ func MarshalIndent(v interface{}, prefix, indent string) ([]byte, os.Error) {\n }\n \n // MarshalForHTML is like Marshal but applies HTMLEscape to the output.\n-func MarshalForHTML(v interface{}) ([]byte, os.Error) {\n+func MarshalForHTML(v interface{}) ([]byte, error) {\n \tb, err := Marshal(v)\n \tif err != nil {\n \t\treturn nil, err\n@@ -159,32 +158,32 @@ func HTMLEscape(dst *bytes.Buffer, src []byte) {\n // Marshaler is the interface implemented by objects that\n // can marshal themselves into valid JSON.\n type Marshaler interface {\n-\tMarshalJSON() ([]byte, os.Error)\n+\tMarshalJSON() ([]byte, error)\n }\n \n type UnsupportedTypeError struct {\n \tType reflect.Type\n }\n \n-func (e *UnsupportedTypeError) String() string {\n+func (e *UnsupportedTypeError) Error() string {\n \treturn \"json: unsupported type: \" + e.Type.String()\n }\n \n type InvalidUTF8Error struct {\n \tS string\n }\n \n-func (e *InvalidUTF8Error) String() string {\n+func (e *InvalidUTF8Error) Error() string {\n \treturn \"json: invalid UTF-8 in string: \" + strconv.Quote(e.S)\n }\n \n type MarshalerError struct {\n-\tType  reflect.Type\n-\tError os.Error\n+\tType reflect.Type\n+\tErr  error\n }\n \n-func (e *MarshalerError) String() string {\n-\treturn \"json: error calling MarshalJSON for type \" + e.Type.String() + \": \" + e.Error.String()\n+func (e *MarshalerError) Error() string {\n+\treturn \"json: error calling MarshalJSON for type \" + e.Type.String() + \": \" + e.Err.Error()\n }\n \n type interfaceOrPtrValue interface {\n@@ -199,20 +198,20 @@ type encodeState struct {\n \tbytes.Buffer // accumulated output\n }\n \n-func (e *encodeState) marshal(v interface{}) (err os.Error) {\n+func (e *encodeState) marshal(v interface{}) (err error) {\n \tdefer func() {\n \t\tif r := recover(); r != nil {\n \t\t\tif _, ok := r.(runtime.Error); ok {\n \t\t\t\tpanic(r)\n \t\t\t}\n-\t\t\terr = r.(os.Error)\n+\t\t\terr = r.(error)\n \t\t}\n \t}()\n \te.reflectValue(reflect.ValueOf(v))\n \treturn nil\n }\n \n-func (e *encodeState) error(err os.Error) {\n+func (e *encodeState) error(err error) {\n \tpanic(err)\n }\n \n@@ -423,7 +422,7 @@ func (sv stringValues) Swap(i, j int)      { sv[i], sv[j] = sv[j], sv[i] }\n func (sv stringValues) Less(i, j int) bool { return sv.get(i) < sv.get(j) }\n func (sv stringValues) get(i int) string   { return sv[i].String() }\n \n-func (e *encodeState) string(s string) (int, os.Error) {\n+func (e *encodeState) string(s string) (int, error) {\n \tlen0 := e.Len()\n \te.WriteByte('\"')\n \tstart := 0"}, {"sha": "5ba19b07ac652d73564cf56463545b93f4d20e0f", "filename": "libgo/go/json/indent.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Findent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Findent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Findent.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -4,14 +4,11 @@\n \n package json\n \n-import (\n-\t\"bytes\"\n-\t\"os\"\n-)\n+import \"bytes\"\n \n // Compact appends to dst the JSON-encoded src with\n // insignificant space characters elided.\n-func Compact(dst *bytes.Buffer, src []byte) os.Error {\n+func Compact(dst *bytes.Buffer, src []byte) error {\n \torigLen := dst.Len()\n \tvar scan scanner\n \tscan.reset()\n@@ -52,7 +49,7 @@ func newline(dst *bytes.Buffer, prefix, indent string, depth int) {\n // copies of indent according to the indentation nesting.\n // The data appended to dst has no trailing newline, to make it easier\n // to embed inside other formatted JSON data.\n-func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) os.Error {\n+func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error {\n \torigLen := dst.Len()\n \tvar scan scanner\n \tscan.reset()"}, {"sha": "179690464b9f9e46cd50a64b92d104cb6f4c767e", "filename": "libgo/go/json/scanner.go", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fscanner.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -13,14 +13,11 @@ package json\n // This file starts with two simple examples using the scanner\n // before diving into the scanner itself.\n \n-import (\n-\t\"os\"\n-\t\"strconv\"\n-)\n+import \"strconv\"\n \n // checkValid verifies that data is valid JSON-encoded data.\n // scan is passed in for use by checkValid to avoid an allocation.\n-func checkValid(data []byte, scan *scanner) os.Error {\n+func checkValid(data []byte, scan *scanner) error {\n \tscan.reset()\n \tfor _, c := range data {\n \t\tscan.bytes++\n@@ -37,7 +34,7 @@ func checkValid(data []byte, scan *scanner) os.Error {\n // nextValue splits data after the next whole JSON value,\n // returning that value and the bytes that follow it as separate slices.\n // scan is passed in for use by nextValue to avoid an allocation.\n-func nextValue(data []byte, scan *scanner) (value, rest []byte, err os.Error) {\n+func nextValue(data []byte, scan *scanner) (value, rest []byte, err error) {\n \tscan.reset()\n \tfor i, c := range data {\n \t\tv := scan.step(scan, int(c))\n@@ -62,7 +59,7 @@ type SyntaxError struct {\n \tOffset int64  // error occurred after reading Offset bytes\n }\n \n-func (e *SyntaxError) String() string { return e.msg }\n+func (e *SyntaxError) Error() string { return e.msg }\n \n // A scanner is a JSON scanning state machine.\n // Callers call scan.reset() and then pass bytes in one at a time\n@@ -87,7 +84,7 @@ type scanner struct {\n \tparseState []int\n \n \t// Error that happened, if any.\n-\terr os.Error\n+\terr error\n \n \t// 1-byte redo (see undo method)\n \tredoCode  int"}, {"sha": "0b86cb537d200a4db82a619a9be7137b5999886b", "filename": "libgo/go/json/scanner_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fscanner_test.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -7,7 +7,6 @@ package json\n import (\n \t\"bytes\"\n \t\"math\"\n-\t\"os\"\n \t\"rand\"\n \t\"reflect\"\n \t\"testing\"\n@@ -140,7 +139,7 @@ func TestIndentBig(t *testing.T) {\n \n type indentErrorTest struct {\n \tin  string\n-\terr os.Error\n+\terr error\n }\n \n var indentErrorTests = []indentErrorTest{"}, {"sha": "f2476395023f74f1dfe49583f61c8ec71ba1c555", "filename": "libgo/go/json/stream.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Fstream.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fjson%2Fstream.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fstream.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -5,8 +5,8 @@\n package json\n \n import (\n+\t\"errors\"\n \t\"io\"\n-\t\"os\"\n )\n \n // A Decoder reads and decodes JSON objects from an input stream.\n@@ -15,7 +15,7 @@ type Decoder struct {\n \tbuf  []byte\n \td    decodeState\n \tscan scanner\n-\terr  os.Error\n+\terr  error\n }\n \n // NewDecoder returns a new decoder that reads from r.\n@@ -28,7 +28,7 @@ func NewDecoder(r io.Reader) *Decoder {\n //\n // See the documentation for Unmarshal for details about\n // the conversion of JSON into a Go value.\n-func (dec *Decoder) Decode(v interface{}) os.Error {\n+func (dec *Decoder) Decode(v interface{}) error {\n \tif dec.err != nil {\n \t\treturn dec.err\n \t}\n@@ -53,11 +53,11 @@ func (dec *Decoder) Decode(v interface{}) os.Error {\n \n // readValue reads a JSON value into dec.buf.\n // It returns the length of the encoding.\n-func (dec *Decoder) readValue() (int, os.Error) {\n+func (dec *Decoder) readValue() (int, error) {\n \tdec.scan.reset()\n \n \tscanp := 0\n-\tvar err os.Error\n+\tvar err error\n Input:\n \tfor {\n \t\t// Look in the buffer for a new value.\n@@ -85,7 +85,7 @@ Input:\n \t\t// Did the last read have an error?\n \t\t// Delayed until now to allow buffer scan.\n \t\tif err != nil {\n-\t\t\tif err == os.EOF {\n+\t\t\tif err == io.EOF {\n \t\t\t\tif dec.scan.step(&dec.scan, ' ') == scanEnd {\n \t\t\t\t\tbreak Input\n \t\t\t\t}\n@@ -126,7 +126,7 @@ func nonSpace(b []byte) bool {\n type Encoder struct {\n \tw   io.Writer\n \te   encodeState\n-\terr os.Error\n+\terr error\n }\n \n // NewEncoder returns a new encoder that writes to w.\n@@ -138,7 +138,7 @@ func NewEncoder(w io.Writer) *Encoder {\n //\n // See the documentation for Marshal for details about the\n // conversion of Go values to JSON.\n-func (enc *Encoder) Encode(v interface{}) os.Error {\n+func (enc *Encoder) Encode(v interface{}) error {\n \tif enc.err != nil {\n \t\treturn enc.err\n \t}\n@@ -168,14 +168,14 @@ func (enc *Encoder) Encode(v interface{}) os.Error {\n type RawMessage []byte\n \n // MarshalJSON returns *m as the JSON encoding of m.\n-func (m *RawMessage) MarshalJSON() ([]byte, os.Error) {\n+func (m *RawMessage) MarshalJSON() ([]byte, error) {\n \treturn *m, nil\n }\n \n // UnmarshalJSON sets *m to a copy of data.\n-func (m *RawMessage) UnmarshalJSON(data []byte) os.Error {\n+func (m *RawMessage) UnmarshalJSON(data []byte) error {\n \tif m == nil {\n-\t\treturn os.NewError(\"json.RawMessage: UnmarshalJSON on nil pointer\")\n+\t\treturn errors.New(\"json.RawMessage: UnmarshalJSON on nil pointer\")\n \t}\n \t*m = append((*m)[0:0], data...)\n \treturn nil"}, {"sha": "55b7e9ef9e0977b6fec67e7fa17b28007a02818f", "filename": "libgo/go/log/log.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Flog%2Flog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Flog%2Flog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Flog.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96", "patch": "@@ -132,7 +132,7 @@ func (l *Logger) formatHeader(buf *bytes.Buffer, ns int64, file string, line int\n // already a newline.  Calldepth is used to recover the PC and is\n // provided for generality, although at the moment on all pre-defined\n // paths it will be 2.\n-func (l *Logger) Output(calldepth int, s string) os.Error {\n+func (l *Logger) Output(calldepth int, s string) error {\n \tnow := time.Nanoseconds() // get this early.\n \tvar file string\n \tvar line int"}, {"sha": "95246b2fa1dd460bf2ad4a1ec009ab7b8e2597fd", "filename": "libgo/go/mail/message.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fmail%2Fmessage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fmail%2Fmessage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmail%2Fmessage.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96"}, {"sha": "2bf79788c74972e4fe6fa1938aa87e2d26803bdd", "filename": "libgo/go/mime/mediatype.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fmime%2Fmediatype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd401c8f190f1fe43e51a7f726f6ed6119a1f96/libgo%2Fgo%2Fmime%2Fmediatype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmediatype.go?ref=2fd401c8f190f1fe43e51a7f726f6ed6119a1f96"}]}