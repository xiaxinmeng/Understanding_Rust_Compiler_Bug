{"sha": "b81a2f0dbcf13e72503c05420e399d7edf23384b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgxYTJmMGRiY2YxM2U3MjUwM2MwNTQyMGUzOTlkN2VkZjIzMzg0Yg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2015-07-16T15:26:35Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2015-07-16T15:26:35Z"}, "message": "re PR rtl-optimization/66626 (gcc.dg/torture/stackalign/non-local-goto-5.c segfaults w/ -mregparm=3 or -miamcu)\n\n2015-07-16  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/66626\n\t* ira.h (emit-rtl.h): Include.\n\t(non_spilled_static_chain_regno_p): New.\n\t* ira-color.c (setup_profitable_hard_regs): Clear profitable regs\n\tunless it is non spilled static chain pseudo.\n\t(assign_hard_rego): Spill memory profitable allocno unless it is\n\tnon spilled static chain pseudo.\n\t(allocno_spill_priority_compare): Put non spilled static chain\n\tpseudo at the end of sorted array.\n\t(improve_allocation): Do nothing if we have static chain and\n\tnon-local goto.\n\t(allocno__priority_compare_func): Put non spilled static chain\n\tpseudo at the beginning of sorted array.\n\t(move_spill_restore): Ignore non spilled static chain pseudo.\n\t* ira-costs.c (find_costs_and_classes): Don't assign class NO_REGS\n\tto non spilled static chain pseudo.\n\t* lra-assigns.c (pseudo_compare_func): Put non spilled static chain\n\tpseudo at the beginning of sorted array.\n\t(spill_for): Spill non spilled static chain pseudo last.\n\t* lra-constraints.c (lra_constraints): Remove static chain pseudo\n\tcheck for equivalence.\n\n2015-07-16  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/66626\n\t* gcc.target/i386/pr66626-2.c: New.\n\nFrom-SVN: r225891", "tree": {"sha": "8007d3add2ae6117cc209d5f0d76980482f23ff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8007d3add2ae6117cc209d5f0d76980482f23ff8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b81a2f0dbcf13e72503c05420e399d7edf23384b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81a2f0dbcf13e72503c05420e399d7edf23384b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b81a2f0dbcf13e72503c05420e399d7edf23384b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81a2f0dbcf13e72503c05420e399d7edf23384b/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7d1f3fedcddc06f8f4b3d761c928fb5de3a3082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7d1f3fedcddc06f8f4b3d761c928fb5de3a3082", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7d1f3fedcddc06f8f4b3d761c928fb5de3a3082"}], "stats": {"total": 157, "additions": 137, "deletions": 20}, "files": [{"sha": "a7949ece808eb5f29ace3e8e153bd5c5afc35539", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b81a2f0dbcf13e72503c05420e399d7edf23384b", "patch": "@@ -1,3 +1,27 @@\n+2015-07-16  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/66626\n+\t* ira.h (emit-rtl.h): Include.\n+\t(non_spilled_static_chain_regno_p): New.\n+\t* ira-color.c (setup_profitable_hard_regs): Clear profitable regs\n+\tunless it is non spilled static chain pseudo.\n+\t(assign_hard_rego): Spill memory profitable allocno unless it is\n+\tnon spilled static chain pseudo.\n+\t(allocno_spill_priority_compare): Put non spilled static chain\n+\tpseudo at the end of sorted array.\n+\t(improve_allocation): Do nothing if we have static chain and\n+\tnon-local goto.\n+\t(allocno__priority_compare_func): Put non spilled static chain\n+\tpseudo at the beginning of sorted array.\n+\t(move_spill_restore): Ignore non spilled static chain pseudo.\n+\t* ira-costs.c (find_costs_and_classes): Don't assign class NO_REGS\n+\tto non spilled static chain pseudo.\n+\t* lra-assigns.c (pseudo_compare_func): Put non spilled static chain\n+\tpseudo at the beginning of sorted array.\n+\t(spill_for): Spill non spilled static chain pseudo last.\n+\t* lra-constraints.c (lra_constraints): Remove static chain pseudo\n+\tcheck for equivalence.\n+\n 2015-07-16  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/66896."}, {"sha": "74d2c2ed6081c42c6dd8e56bbd121abbf7f26099", "filename": "gcc/ira-color.c", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=b81a2f0dbcf13e72503c05420e399d7edf23384b", "patch": "@@ -1044,7 +1044,10 @@ setup_profitable_hard_regs (void)\n \tcontinue;\n       data = ALLOCNO_COLOR_DATA (a);\n       if (ALLOCNO_UPDATED_HARD_REG_COSTS (a) == NULL\n-\t  && ALLOCNO_CLASS_COST (a) > ALLOCNO_MEMORY_COST (a))\n+\t  && ALLOCNO_CLASS_COST (a) > ALLOCNO_MEMORY_COST (a)\n+\t  /* Do not empty profitable regs for static chain pointer\n+\t     pseudo when non-local goto is used.  */\n+\t  && ! non_spilled_static_chain_regno_p (ALLOCNO_REGNO (a)))\n \tCLEAR_HARD_REG_SET (data->profitable_hard_regs);\n       else\n \t{\n@@ -1126,15 +1129,21 @@ setup_profitable_hard_regs (void)\n \t      if (! TEST_HARD_REG_BIT (data->profitable_hard_regs,\n \t\t\t\t       hard_regno))\n \t\tcontinue;\n-\t      if (ALLOCNO_UPDATED_MEMORY_COST (a) < costs[j])\n+\t      if (ALLOCNO_UPDATED_MEMORY_COST (a) < costs[j]\n+\t\t  /* Do not remove HARD_REGNO for static chain pointer\n+\t\t     pseudo when non-local goto is used.  */\n+\t\t  && ! non_spilled_static_chain_regno_p (ALLOCNO_REGNO (a)))\n \t\tCLEAR_HARD_REG_BIT (data->profitable_hard_regs,\n \t\t\t\t    hard_regno);\n \t      else if (min_cost > costs[j])\n \t\tmin_cost = costs[j];\n \t    }\n \t}\n       else if (ALLOCNO_UPDATED_MEMORY_COST (a)\n-\t       < ALLOCNO_UPDATED_CLASS_COST (a))\n+\t       < ALLOCNO_UPDATED_CLASS_COST (a)\n+\t       /* Do not empty profitable regs for static chain\n+\t\t  pointer pseudo when non-local goto is used.  */\n+\t       && ! non_spilled_static_chain_regno_p (ALLOCNO_REGNO (a)))\n \tCLEAR_HARD_REG_SET (data->profitable_hard_regs);\n       if (ALLOCNO_UPDATED_CLASS_COST (a) > min_cost)\n \tALLOCNO_UPDATED_CLASS_COST (a) = min_cost;\n@@ -1854,7 +1863,10 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n \t  ira_assert (hard_regno >= 0);\n \t}\n     }\n-  if (min_full_cost > mem_cost)\n+  if (min_full_cost > mem_cost\n+      /* Do not spill static chain pointer pseudo when non-local goto\n+\t is used.  */\n+      && ! non_spilled_static_chain_regno_p (ALLOCNO_REGNO (a)))\n     {\n       if (! retry_p && internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n \tfprintf (ira_dump_file, \"(memory is more profitable %d vs %d) \",\n@@ -2480,6 +2492,12 @@ allocno_spill_priority_compare (ira_allocno_t a1, ira_allocno_t a2)\n {\n   int pri1, pri2, diff;\n \n+  /* Avoid spilling static chain pointer pseudo when non-local goto is\n+     used.  */\n+  if (non_spilled_static_chain_regno_p (ALLOCNO_REGNO (a1)))\n+    return 1;\n+  else if (non_spilled_static_chain_regno_p (ALLOCNO_REGNO (a2)))\n+    return -1;\n   if (ALLOCNO_BAD_SPILL_P (a1) && ! ALLOCNO_BAD_SPILL_P (a2))\n     return 1;\n   if (ALLOCNO_BAD_SPILL_P (a2) && ! ALLOCNO_BAD_SPILL_P (a1))\n@@ -2732,6 +2750,11 @@ improve_allocation (void)\n   ira_allocno_t a;\n   bitmap_iterator bi;\n \n+  /* Don't bother to optimize the code with static chain pointer and\n+     non-local goto in order not to spill the chain pointer\n+     pseudo.  */\n+  if (cfun->static_chain_decl && crtl->has_nonlocal_goto)\n+    return;\n   /* Clear counts used to process conflicting allocnos only once for\n      each allocno.  */\n   EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, i, bi)\n@@ -2938,6 +2961,12 @@ allocno_priority_compare_func (const void *v1p, const void *v2p)\n   ira_allocno_t a2 = *(const ira_allocno_t *) v2p;\n   int pri1, pri2;\n \n+  /* Assign hard reg to static chain pointer pseudo first when\n+     non-local goto is used.  */\n+  if (non_spilled_static_chain_regno_p (ALLOCNO_REGNO (a1)))\n+    return 1;\n+  else if (non_spilled_static_chain_regno_p (ALLOCNO_REGNO (a2)))\n+    return -1;\n   pri1 = allocno_priorities[ALLOCNO_NUM (a1)];\n   pri2 = allocno_priorities[ALLOCNO_NUM (a2)];\n   if (pri2 != pri1)\n@@ -3379,7 +3408,10 @@ move_spill_restore (void)\n \t\t by copy although the allocno will not get memory\n \t\t slot.  */\n \t      || ira_equiv_no_lvalue_p (regno)\n-\t      || !bitmap_bit_p (loop_node->border_allocnos, ALLOCNO_NUM (a)))\n+\t      || !bitmap_bit_p (loop_node->border_allocnos, ALLOCNO_NUM (a))\n+\t      /* Do not spill static chain pointer pseudo when\n+\t\t non-local goto is used.  */\n+\t      || non_spilled_static_chain_regno_p (regno))\n \t    continue;\n \t  mode = ALLOCNO_MODE (a);\n \t  rclass = ALLOCNO_CLASS (a);"}, {"sha": "eded4d9f525d48ee96e9e00f9c6f3cc13be5878e", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=b81a2f0dbcf13e72503c05420e399d7edf23384b", "patch": "@@ -1836,7 +1836,8 @@ find_costs_and_classes (FILE *dump_file)\n \t\talt_class = reg_class_subunion[alt_class][rclass];\n \t    }\n \t  alt_class = ira_allocno_class_translate[alt_class];\n-\t  if (best_cost > i_mem_cost)\n+\t  if (best_cost > i_mem_cost\n+\t      && ! non_spilled_static_chain_regno_p (i))\n \t    regno_aclass[i] = NO_REGS;\n \t  else if (!optimize && !targetm.class_likely_spilled_p (best))\n \t    /* Registers in the alternative class are likely to need\n@@ -1875,7 +1876,10 @@ find_costs_and_classes (FILE *dump_file)\n \t    }\n \t  if (pass == flag_expensive_optimizations)\n \t    {\n-\t      if (best_cost > i_mem_cost)\n+\t      if (best_cost > i_mem_cost\n+\t\t  /* Do not assign NO_REGS to static chain pointer\n+\t\t     pseudo when non-local goto is used.  */\n+\t\t  && ! non_spilled_static_chain_regno_p (i))\n \t\tbest = alt_class = NO_REGS;\n \t      else if (best == alt_class)\n \t\talt_class = NO_REGS;\n@@ -1890,7 +1894,9 @@ find_costs_and_classes (FILE *dump_file)\n \t  regno_best_class[i] = best;\n \t  if (! allocno_p)\n \t    {\n-\t      pref[i] = best_cost > i_mem_cost ? NO_REGS : best;\n+\t      pref[i] = (best_cost > i_mem_cost\n+\t\t\t && ! non_spilled_static_chain_regno_p (i)\n+\t\t\t ? NO_REGS : best);\n \t      continue;\n \t    }\n \t  for (a = ira_regno_allocno_map[i];"}, {"sha": "504b5e6a93bc1ca839be755e4d3655638dea4c86", "filename": "gcc/ira.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=b81a2f0dbcf13e72503c05420e399d7edf23384b", "patch": "@@ -22,6 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_IRA_H\n #define GCC_IRA_H\n \n+#include \"emit-rtl.h\"\n+\n /* True when we use LRA instead of reload pass for the current\n    function.  */\n extern bool ira_use_lra_p;\n@@ -209,4 +211,15 @@ extern void ira_adjust_equiv_reg_cost (unsigned, int);\n /* ira-costs.c */\n extern void ira_costs_c_finalize (void);\n \n+/* Spilling static chain pseudo may result in generation of wrong\n+   non-local goto code using frame-pointer to address saved stack\n+   pointer value after restoring old frame pointer value.  The\n+   function returns TRUE if REGNO is such a static chain pseudo.  */\n+static inline bool\n+non_spilled_static_chain_regno_p (int regno)\n+{\n+  return (cfun->static_chain_decl && crtl->has_nonlocal_goto\n+\t  && REG_EXPR (regno_reg_rtx[regno]) == cfun->static_chain_decl);\n+}\n+\n #endif /* GCC_IRA_H */"}, {"sha": "2986f5784387cccf7f5078104f6cd6bd4784f529", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=b81a2f0dbcf13e72503c05420e399d7edf23384b", "patch": "@@ -255,6 +255,13 @@ pseudo_compare_func (const void *v1p, const void *v2p)\n   int r1 = *(const int *) v1p, r2 = *(const int *) v2p;\n   int diff;\n \n+  /* Assign hard reg to static chain pointer first pseudo when\n+     non-local goto is used.  */\n+  if (non_spilled_static_chain_regno_p (r1))\n+    return -1;\n+  else if (non_spilled_static_chain_regno_p (r2))\n+    return 1;\n+\n   /* Prefer to assign more frequently used registers first.  */\n   if ((diff = lra_reg_info[r2].freq - lra_reg_info[r1].freq) != 0)\n     return diff;\n@@ -892,6 +899,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)\n {\n   int i, j, n, p, hard_regno, best_hard_regno, cost, best_cost, rclass_size;\n   int reload_hard_regno, reload_cost;\n+  bool static_p, best_static_p;\n   machine_mode mode;\n   enum reg_class rclass;\n   unsigned int spill_regno, reload_regno, uid;\n@@ -914,6 +922,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)\n     }\n   best_hard_regno = -1;\n   best_cost = INT_MAX;\n+  best_static_p = TRUE;\n   best_insn_pseudos_num = INT_MAX;\n   smallest_bad_spills_num = INT_MAX;\n   rclass_size = ira_class_hard_regs_num[rclass];\n@@ -936,6 +945,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)\n \t\t\t   &try_hard_reg_pseudos[hard_regno + j]);\n \t}\n       /* Spill pseudos.\t */\n+      static_p = false;\n       EXECUTE_IF_SET_IN_BITMAP (&spill_pseudos_bitmap, 0, spill_regno, bi)\n \tif ((pic_offset_table_rtx != NULL\n \t     && spill_regno == REGNO (pic_offset_table_rtx))\n@@ -945,6 +955,8 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)\n \t\t&& ! bitmap_bit_p (&lra_subreg_reload_pseudos, spill_regno)\n \t\t&& ! bitmap_bit_p (&lra_optional_reload_pseudos, spill_regno)))\n \t  goto fail;\n+\telse if (non_spilled_static_chain_regno_p (spill_regno))\n+\t  static_p = true;\n       insn_pseudos_num = 0;\n       bad_spills_num = 0;\n       if (lra_dump_file != NULL)\n@@ -1024,14 +1036,19 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)\n \t\t     x = x->next ())\n \t\t  cost -= REG_FREQ_FROM_BB (BLOCK_FOR_INSN (x->insn ()));\n \t    }\n-\t  if (best_insn_pseudos_num > insn_pseudos_num\n-\t      || (best_insn_pseudos_num == insn_pseudos_num\n-\t\t  && (bad_spills_num < smallest_bad_spills_num\n-\t\t      || (bad_spills_num == smallest_bad_spills_num\n-\t\t\t  && best_cost > cost))))\n+\t  /* Avoid spilling static chain pointer pseudo when non-local\n+\t     goto is used.  */\n+\t  if ((! static_p && best_static_p)\n+\t      || (static_p == best_static_p\n+\t\t  && (best_insn_pseudos_num > insn_pseudos_num\n+\t\t      || (best_insn_pseudos_num == insn_pseudos_num\n+\t\t\t  && (bad_spills_num < smallest_bad_spills_num\n+\t\t\t      || (bad_spills_num == smallest_bad_spills_num\n+\t\t\t\t  && best_cost > cost))))))\n \t    {\n \t      best_insn_pseudos_num = insn_pseudos_num;\n \t      smallest_bad_spills_num = bad_spills_num;\n+\t      best_static_p = static_p;\n \t      best_cost = cost;\n \t      best_hard_regno = hard_regno;\n \t      bitmap_copy (&best_spill_pseudos_bitmap, &spill_pseudos_bitmap);"}, {"sha": "ddb91dd49cf9aaf6a83c7ff62aa8848ba3865925", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=b81a2f0dbcf13e72503c05420e399d7edf23384b", "patch": "@@ -4306,13 +4306,7 @@ lra_constraints (bool first_p)\n \t\t    && ((CONST_POOL_OK_P (PSEUDO_REGNO_MODE (i), x)\n \t\t\t && (targetm.preferred_reload_class\n \t\t\t     (x, lra_get_allocno_class (i)) == NO_REGS))\n-\t\t\t|| contains_symbol_ref_p (x)))\n-\t\t/* Static chain equivalence may contain eliminable\n-\t\t   regs and the result of elimination might be wrong\n-\t\t   after restoring frame pointer for a nonlocal\n-\t\t   goto.  */\n-\t\t|| (cfun->static_chain_decl && crtl->has_nonlocal_goto\n-\t\t    && REG_EXPR (reg) == cfun->static_chain_decl))\n+\t\t\t|| contains_symbol_ref_p (x))))\n \t      ira_reg_equiv[i].defined_p = false;\n \t    if (contains_reg_p (x, false, true))\n \t      ira_reg_equiv[i].profitable_p = false;"}, {"sha": "527fe0ffd2139b1cb2f8e8db592ecf49ac6cd2ba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b81a2f0dbcf13e72503c05420e399d7edf23384b", "patch": "@@ -1,3 +1,8 @@\n+2015-07-16  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/66626\n+\t* gcc.target/i386/pr66626-2.c: New.\n+\n 2015-07-16  Martin Liska  <mliska@suse.cz>\n \n \t* g++.dg/ipa/pr66896.c: New test."}, {"sha": "feba6a6223c191e306a7f5bd9cd19c78bb9db542", "filename": "gcc/testsuite/gcc.target/i386/pr66626-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr66626-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81a2f0dbcf13e72503c05420e399d7edf23384b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr66626-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr66626-2.c?ref=b81a2f0dbcf13e72503c05420e399d7edf23384b", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mregparm=3\" } */\n+/* { dg-require-effective-target ia32 } */\n+extern void abort (void);\n+\n+int s (int i)\n+{\n+  __label__ l1;\n+  int f (int i)\n+  {\n+    if (i == 2)\n+      goto l1;\n+    return 0;\n+  }\n+  return f (i);\n+ l1:;\n+  return 1;\n+}\n+\n+int main ()\n+{\n+  if (s (2) != 1)\n+    abort ();\n+\n+  return 0;\n+}"}]}