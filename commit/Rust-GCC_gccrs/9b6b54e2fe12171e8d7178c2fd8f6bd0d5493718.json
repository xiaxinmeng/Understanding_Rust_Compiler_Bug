{"sha": "9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI2YjU0ZTJmZTEyMTcxZThkNzE3OGMyZmQ4ZjZiZDBkNTQ5MzcxOA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2003-02-10T11:45:26Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2003-02-10T11:45:26Z"}, "message": "Add support for Cirrus EP9312, an ARM variant.\n\nFrom-SVN: r62625", "tree": {"sha": "417f4c923c6a8ade16727e1ed1cc09fddf62b044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/417f4c923c6a8ade16727e1ed1cc09fddf62b044"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "949824fe3405af719e53f1818dcc8b6696a99d67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/949824fe3405af719e53f1818dcc8b6696a99d67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/949824fe3405af719e53f1818dcc8b6696a99d67"}], "stats": {"total": 808, "additions": 746, "deletions": 62}, "files": [{"sha": "7bd777971a86d25c6723cbe6a344d3fac36acd67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "patch": "@@ -1,3 +1,18 @@\n+2003-02-10  Nick Clifton  <nickc@redhat.com>\n+\n+\t* Contributed support for the Cirrus EP9312 \"Maverick\"\n+\tfloating point co-processor.  Written by Aldy Hernandez\n+\t<aldyh@redhat.com>. \n+\t(config/arm/arm.c): Add Cirrus support.\n+\t(config/arm/arm.h): Likewise.\n+\t(config/arm/aout.h): Likewise.\n+\t(config/arm/arm.md): Likewise.\n+\t(config/arm/arm-protos.h): Likewise.\n+\t(config.gcc): Likewise.\n+\t(doc/invoke.texi): Describe new -mcpu value and new\n+\t-mcirrus-fix-invalid-insns switch,\n+\t(cirrus.md): New file.\n+\n Mon Feb 10 11:40:18 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* combine.c (combine_simplify_rtx): Simplify using"}, {"sha": "b76fbd8326fe1f67c84843e757f84ebeb742bfd8", "filename": "gcc/config.gcc", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "patch": "@@ -259,6 +259,9 @@ strongarm*-*-*)\n arm*-*-*)\n \tcpu_type=arm\n \t;;\n+ep9312*-*-*)\n+\tcpu_type=arm\n+\t;;\n xscale-*-*)\n \tcpu_type=arm\n \t;;\n@@ -700,7 +703,7 @@ arm*-*-rtems*)\n \t  thread_file='rtems'\n \tfi\n \t;;\n-arm*-*-elf)\n+arm*-*-elf | ep9312-*-elf)\n \ttm_file=\"dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h\"\n \ttmake_file=arm/t-arm-elf\n \t;;\n@@ -2789,6 +2792,7 @@ arm*-*-*)\n \t\t| xarm7m | xarm7dm | xarm7dmi | xarm[79]tdmi \\\n \t\t| xarm7100 | xarm7500 | xarm7500fe | xarm810 \\\n \t\t| xxscale \\\n+\t\t| xep9312 \\\n \t\t| xstrongarm | xstrongarm110 | xstrongarm1100)\n \t\t\ttarget_cpu_default2=\"TARGET_CPU_$with_cpu\"\n \t\t\t;;\n@@ -2806,6 +2810,11 @@ arm*-*-*)\n \t\t\tfi\n \t\t\t;;\n \tesac\n+\tcase $machine in\n+\t\t9ep9312-*-*)\n+\t\t\ttarget_cpu_default2=\"TARGET_CPU_9ep9312\"\n+\t\t\t;;\n+\tesac\n \t;;\n \n hppa*-*-* | parisc*-*-*)"}, {"sha": "6d6e908951b3c791b5eacbe31915d142088d2219", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 69, "deletions": 2, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "patch": "@@ -73,7 +73,10 @@ Boston, MA 02111-1307, USA.  */\n   \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",  \\\n   \"r8\", \"r9\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\",  \\\n   \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\",  \\\n-  \"cc\", \"sfp\", \"afp\"\t\t   \t\t   \\\n+  \"cc\", \"sfp\", \"afp\",\t\t   \t\t   \\\n+  \"mv0\",  \"mv1\",   \"mv2\",  \"mv3\",  \"mv4\",   \"mv5\", \\\n+  \"mv6\",  \"mv7\",   \"mv8\",  \"mv9\",  \"mv10\",  \"mv11\",\\\n+  \"mv12\", \"mv13\",  \"mv14\", \"mv15\"\t\t   \\\n }\n #endif\n \n@@ -98,7 +101,71 @@ Boston, MA 02111-1307, USA.  */\n   {\"r12\", 12},\t/* ip */\t\t\t\\\n   {\"r13\", 13},\t/* sp */\t\t\t\\\n   {\"r14\", 14},\t/* lr */\t\t\t\\\n-  {\"r15\", 15}\t/* pc */\t\t\t\\\n+  {\"r15\", 15},\t/* pc */\t\t\t\\\n+  {\"mvf0\", 27},\t\t\t\t\t\\\n+  {\"mvf1\", 28},\t\t\t\t\t\\\n+  {\"mvf2\", 29},\t\t\t\t\t\\\n+  {\"mvf3\", 30},\t\t\t\t\t\\\n+  {\"mvf4\", 31},\t\t\t\t\t\\\n+  {\"mvf5\", 32},\t\t\t\t\t\\\n+  {\"mvf6\", 33},\t\t\t\t\t\\\n+  {\"mvf7\", 34},\t\t\t\t\t\\\n+  {\"mvf8\", 35},\t\t\t\t\t\\\n+  {\"mvf9\", 36},\t\t\t\t\t\\\n+  {\"mvf10\", 37},\t\t\t\t\\\n+  {\"mvf11\", 38},\t\t\t\t\\\n+  {\"mvf12\", 39},\t\t\t\t\\\n+  {\"mvf13\", 40},\t\t\t\t\\\n+  {\"mvf14\", 41},\t\t\t\t\\\n+  {\"mvf15\", 42},\t\t\t\t\\\n+  {\"mvd0\", 27},\t\t\t\t\t\\\n+  {\"mvd1\", 28},\t\t\t\t\t\\\n+  {\"mvd2\", 29},\t\t\t\t\t\\\n+  {\"mvd3\", 30},\t\t\t\t\t\\\n+  {\"mvd4\", 31},\t\t\t\t\t\\\n+  {\"mvd5\", 32},\t\t\t\t\t\\\n+  {\"mvd6\", 33},\t\t\t\t\t\\\n+  {\"mvd7\", 34},\t\t\t\t\t\\\n+  {\"mvd8\", 35},\t\t\t\t\t\\\n+  {\"mvd9\", 36},\t\t\t\t\t\\\n+  {\"mvd10\", 37},\t\t\t\t\\\n+  {\"mvd11\", 38},\t\t\t\t\\\n+  {\"mvd12\", 39},\t\t\t\t\\\n+  {\"mvd13\", 40},\t\t\t\t\\\n+  {\"mvd14\", 41},\t\t\t\t\\\n+  {\"mvd15\", 42},\t\t\t\t\\\n+  {\"mvfx0\", 27},\t\t\t\t\\\n+  {\"mvfx1\", 28},\t\t\t\t\\\n+  {\"mvfx2\", 29},\t\t\t\t\\\n+  {\"mvfx3\", 30},\t\t\t\t\\\n+  {\"mvfx4\", 31},\t\t\t\t\\\n+  {\"mvfx5\", 32},\t\t\t\t\\\n+  {\"mvfx6\", 33},\t\t\t\t\\\n+  {\"mvfx7\", 34},\t\t\t\t\\\n+  {\"mvfx8\", 35},\t\t\t\t\\\n+  {\"mvfx9\", 36},\t\t\t\t\\\n+  {\"mvfx10\", 37},\t\t\t\t\\\n+  {\"mvfx11\", 38},\t\t\t\t\\\n+  {\"mvfx12\", 39},\t\t\t\t\\\n+  {\"mvfx13\", 40},\t\t\t\t\\\n+  {\"mvfx14\", 41},\t\t\t\t\\\n+  {\"mvfx15\", 42},\t\t\t\t\\\n+  {\"mvdx0\", 27},\t\t\t\t\\\n+  {\"mvdx1\", 28},\t\t\t\t\\\n+  {\"mvdx2\", 29},\t\t\t\t\\\n+  {\"mvdx3\", 30},\t\t\t\t\\\n+  {\"mvdx4\", 31},\t\t\t\t\\\n+  {\"mvdx5\", 32},\t\t\t\t\\\n+  {\"mvdx6\", 33},\t\t\t\t\\\n+  {\"mvdx7\", 34},\t\t\t\t\\\n+  {\"mvdx8\", 35},\t\t\t\t\\\n+  {\"mvdx9\", 36},\t\t\t\t\\\n+  {\"mvdx10\", 37},\t\t\t\t\\\n+  {\"mvdx11\", 38},\t\t\t\t\\\n+  {\"mvdx12\", 39},\t\t\t\t\\\n+  {\"mvdx13\", 40},\t\t\t\t\\\n+  {\"mvdx14\", 41},\t\t\t\t\\\n+  {\"mvdx15\", 42}\t\t\t\t\\\n }\n #endif\n "}, {"sha": "0d0dba22a6cdf57e411306543aa7a0acec97909e", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "patch": "@@ -94,6 +94,11 @@ extern int    logical_binary_operator\tPARAMS ((rtx, enum machine_mode));\n extern int    multi_register_push\tPARAMS ((rtx, enum machine_mode));\n extern int    load_multiple_operation\tPARAMS ((rtx, enum machine_mode));\n extern int    store_multiple_operation\tPARAMS ((rtx, enum machine_mode));\n+extern int    cirrus_fp_register\tPARAMS ((rtx, enum machine_mode));\n+extern int    cirrus_general_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int    cirrus_register_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int    cirrus_shift_const\tPARAMS ((rtx, enum machine_mode));\n+extern int    cirrus_memory_offset\tPARAMS ((rtx));\n \n extern int    symbol_mentioned_p\tPARAMS ((rtx));\n extern int    label_mentioned_p\t\tPARAMS ((rtx));\n@@ -149,7 +154,6 @@ extern rtx    arm_va_arg                PARAMS ((tree, tree));\n extern int    arm_function_arg_pass_by_reference PARAMS ((CUMULATIVE_ARGS *,\n \t\t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t         tree, int));\n-\n #endif\n \n #if defined AOF_ASSEMBLER "}, {"sha": "c1a6f2f740673f31843a1236479efe46844bc184", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 382, "deletions": 7, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "patch": "@@ -62,6 +62,12 @@ typedef struct minipool_fixup   Mfix;\n #define Ulong    unsigned long\n #define Ccstar   const char *\n \n+const char extra_reg_names1[][16] =\n+{ \"mv0\", \"mv1\", \"mv2\",  \"mv3\",  \"mv4\",  \"mv5\",  \"mv6\",  \"mv7\",\n+  \"mv8\", \"mv9\", \"mv10\", \"mv11\", \"mv12\", \"mv13\", \"mv14\", \"mv15\"\n+};\n+#define extra_reg_names1 bogus1_regnames\n+\n const struct attribute_spec arm_attribute_table[];\n \n /* Forward function declarations.  */\n@@ -144,6 +150,9 @@ static int arm_rtx_costs_1\t\t\tPARAMS ((rtx, enum rtx_code,\n \t\t\t\t\t\t\t enum rtx_code));\n static bool arm_rtx_costs\t\t\tPARAMS ((rtx, int, int, int*));\n static int arm_address_cost\t\t\tPARAMS ((rtx));\n+static int \t is_load_address                PARAMS ((rtx));\n+static int       is_cirrus_insn                 PARAMS ((rtx));\n+static void      cirrus_reorg                   PARAMS ((rtx));\n \n #undef Hint\n #undef Mmode\n@@ -263,6 +272,7 @@ int    arm_structure_size_boundary = DEFAULT_STRUCTURE_SIZE_BOUNDARY;\n #define FL_STRONG     (1 << 8)\t      /* StrongARM */\n #define FL_ARCH5E     (1 << 9)        /* DSP extensions to v5 */\n #define FL_XSCALE     (1 << 10)\t      /* XScale */\n+#define FL_CIRRUS     (1 << 11)\t      /* Cirrus/DSP.  */\n \n /* The bits in this mask specify which\n    instructions we are allowed to generate.  */\n@@ -301,6 +311,9 @@ int arm_is_xscale = 0;\n /* Nonzero if this chip is an ARM6 or an ARM7.  */\n int arm_is_6_or_7 = 0;\n \n+/* Nonzero if this chip is a Cirrus/DSP.  */\n+int arm_is_cirrus = 0;\n+\n /* Nonzero if generating Thumb instructions.  */\n int thumb_code = 0;\n \n@@ -391,6 +404,7 @@ static const struct processors all_cores[] =\n   {\"arm940t\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED },\n   {\"arm9tdmi\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED },\n   {\"arm9e\",\t       \t      \t\t FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED },\n+  {\"ep9312\",\t   \t\t\t FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED |             FL_CIRRUS },\n   {\"strongarm\",\t             FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n   {\"strongarm110\",           FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n   {\"strongarm1100\",          FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n@@ -417,6 +431,7 @@ static const struct processors all_architectures[] =\n   { \"armv5\",     FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 },\n   { \"armv5t\",    FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 },\n   { \"armv5te\",   FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 | FL_ARCH5E },\n+  { \"ep9312\",\t\t\t\t  FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_LDSCHED | FL_CIRRUS },\n   { NULL, 0 }\n };\n \n@@ -514,6 +529,7 @@ arm_override_options ()\n \t{ TARGET_CPU_arm9,      \"arm9\" },\n \t{ TARGET_CPU_strongarm, \"strongarm\" },\n \t{ TARGET_CPU_xscale,    \"xscale\" },\n+\t{ TARGET_CPU_ep9312,    \"ep9312\" },\n \t{ TARGET_CPU_generic,   \"arm\" },\n \t{ 0, 0 }\n       };\n@@ -712,13 +728,23 @@ arm_override_options ()\n   thumb_code\t    = (TARGET_ARM == 0);\n   arm_is_6_or_7     = (((tune_flags & (FL_MODE26 | FL_MODE32))\n \t\t       && !(tune_flags & FL_ARCH4))) != 0;\n+  arm_is_cirrus\t    = (tune_flags & FL_CIRRUS) != 0;\n \n-  /* Default value for floating point code... if no co-processor\n-     bus, then schedule for emulated floating point.  Otherwise,\n-     assume the user has an FPA.\n-     Note: this does not prevent use of floating point instructions,\n-     -msoft-float does that.  */\n-  arm_fpu = (tune_flags & FL_CO_PROC) ? FP_HARD : FP_SOFT3;\n+  if (arm_is_cirrus)\n+    {\n+      arm_fpu = FP_CIRRUS;\n+\n+      /* Ignore -mhard-float if -mcpu=ep9312.  */\n+      if (TARGET_HARD_FLOAT)\n+\ttarget_flags ^= ARM_FLAG_SOFT_FLOAT;\n+    }\n+  else\n+    /* Default value for floating point code... if no co-processor\n+       bus, then schedule for emulated floating point.  Otherwise,\n+       assume the user has an FPA.\n+       Note: this does not prevent use of floating point instructions,\n+       -msoft-float does that.  */\n+    arm_fpu = (tune_flags & FL_CO_PROC) ? FP_HARD : FP_SOFT3;\n   \n   if (target_fp_name)\n     {\n@@ -733,8 +759,15 @@ arm_override_options ()\n   else\n     arm_fpu_arch = FP_DEFAULT;\n   \n-  if (TARGET_FPE && arm_fpu != FP_HARD)\n+  if (TARGET_FPE)\n+    {\n+      if (arm_fpu == FP_SOFT3)\n+\tarm_fpu = FP_SOFT2;\n+      else if (arm_fpu == FP_CIRRUS)\n+\twarning (\"-mpfpe switch not supported by ep9312 target cpu - ignored.\");\n+      else if (arm_fpu != FP_HARD)\n     arm_fpu = FP_SOFT2;\n+    }\n   \n   /* For arm2/3 there is no need to do any scheduling if there is only\n      a floating point emulator, or we are doing software floating-point.  */\n@@ -1902,6 +1935,8 @@ arm_return_in_memory (type)\n int\n arm_float_words_big_endian ()\n {\n+  if (TARGET_CIRRUS)\n+    return 0;\n \n   /* For FPA, float words are always big-endian.  For VFP, floats words\n      follow the memory system mode.  */\n@@ -2688,6 +2723,12 @@ arm_legitimate_index_p (mode, index, strict_p)\n \t    && INTVAL (index) > -1024\n \t    && (INTVAL (index) & 3) == 0);\n \n+  if (TARGET_CIRRUS\n+      && (GET_MODE_CLASS (mode) == MODE_FLOAT || mode == DImode))\n+    return (code == CONST_INT\n+\t    && INTVAL (index) < 255\n+\t    && INTVAL (index) > -255);\n+\n   if (arm_address_register_rtx_p (index, strict_p)\n       && GET_MODE_SIZE (mode) <= 4)\n     return 1;\n@@ -3856,6 +3897,262 @@ fpu_add_operand (op, mode)\n   return FALSE;\n }\n \n+/* Return nonzero if OP is a valid Cirrus memory address pattern.  */\n+\n+int\n+cirrus_memory_offset (op)\n+     rtx op;\n+{\n+  /* Reject eliminable registers.  */\n+  if (! (reload_in_progress || reload_completed)\n+      && (   reg_mentioned_p (frame_pointer_rtx, op)\n+\t  || reg_mentioned_p (arg_pointer_rtx, op)\n+\t  || reg_mentioned_p (virtual_incoming_args_rtx, op)\n+\t  || reg_mentioned_p (virtual_outgoing_args_rtx, op)\n+\t  || reg_mentioned_p (virtual_stack_dynamic_rtx, op)\n+\t  || reg_mentioned_p (virtual_stack_vars_rtx, op)))\n+    return 0;\n+\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx ind;\n+\n+      ind = XEXP (op, 0);\n+\n+      /* Match: (mem (reg)).  */\n+      if (GET_CODE (ind) == REG)\n+\treturn 1;\n+\n+      /* Match:\n+\t (mem (plus (reg)\n+\t            (const))).  */\n+      if (GET_CODE (ind) == PLUS\n+\t  && GET_CODE (XEXP (ind, 0)) == REG\n+\t  && REG_MODE_OK_FOR_BASE_P (XEXP (ind, 0), VOIDmode)\n+\t  && GET_CODE (XEXP (ind, 1)) == CONST_INT)\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return nonzero if OP is a Cirrus or general register.  */\n+\n+int\n+cirrus_register_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO_REG_CLASS (REGNO (op)) == CIRRUS_REGS\n+\t      || REGNO_REG_CLASS (REGNO (op)) == GENERAL_REGS));\n+}\n+\n+/* Return nonzero if OP is a cirrus FP register.  */\n+\n+int\n+cirrus_fp_register (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || REGNO_REG_CLASS (REGNO (op)) == CIRRUS_REGS));\n+}\n+\n+/* Return nonzero if OP is a 6bit constant (0..63).  */\n+\n+int\n+cirrus_shift_const (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && INTVAL (op) >= 0\n+\t  && INTVAL (op) < 64);\n+}\n+\n+/* Return nonzero if INSN is an LDR R0,ADDR instruction.  */\n+\n+static int\n+is_load_address (insn)\n+     rtx insn;\n+{\n+  rtx body, lhs, rhs;;\n+\n+  if (!insn)\n+    return 0;\n+\n+  if (GET_CODE (insn) != INSN)\n+    return 0;\n+\n+  body = PATTERN (insn);\n+\n+  if (GET_CODE (body) != SET)\n+    return 0;\n+\n+  lhs = XEXP (body, 0);\n+  rhs = XEXP (body, 1);\n+\n+  return (GET_CODE (lhs) == REG\n+\t  && REGNO_REG_CLASS (REGNO (lhs)) == GENERAL_REGS\n+\t  && (GET_CODE (rhs) == MEM\n+\t      || GET_CODE (rhs) == SYMBOL_REF));\n+}\n+\n+/* Return nonzero if INSN is a Cirrus instruction.  */\n+\n+static int\n+is_cirrus_insn (insn)\n+     rtx insn;\n+{\n+  enum attr_cirrus attr;\n+\n+  /* get_attr aborts on USE and CLOBBER.  */\n+  if (!insn\n+      || GET_CODE (insn) != INSN\n+      || GET_CODE (PATTERN (insn)) == USE\n+      || GET_CODE (PATTERN (insn)) == CLOBBER)\n+    return 0;\n+\n+  attr = get_attr_cirrus (insn);\n+\n+  return attr != CIRRUS_NO;\n+}\n+\n+/* Cirrus reorg for invalid instruction combinations.  */\n+\n+static void\n+cirrus_reorg (first)\n+     rtx first;\n+{\n+  enum attr_cirrus attr;\n+  rtx body = PATTERN (first);\n+  rtx t;\n+  int nops;\n+\n+  /* Any branch must be followed by 2 non Cirrus instructions.  */\n+  if (GET_CODE (first) == JUMP_INSN && GET_CODE (body) != RETURN)\n+    {\n+      nops = 0;\n+      t = next_nonnote_insn (first);\n+\n+      if (is_cirrus_insn (t))\n+\t++ nops;\n+\n+      if (is_cirrus_insn (next_nonnote_insn (t)))\n+\t++ nops;\n+\n+      while (nops --)\n+\temit_insn_after (gen_nop (), first);\n+\n+      return;\n+    }\n+\n+  /* (float (blah)) is in parallel with a clobber.  */\n+  if (GET_CODE (body) == PARALLEL && XVECLEN (body, 0) > 0)\n+    body = XVECEXP (body, 0, 0);\n+\n+  if (GET_CODE (body) == SET)\n+    {\n+      rtx lhs = XEXP (body, 0), rhs = XEXP (body, 1);\n+\n+      /* cfldrd, cfldr64, cfstrd, cfstr64 must\n+\t be followed by a non Cirrus insn.  */\n+      if (get_attr_cirrus (first) == CIRRUS_DOUBLE)\n+\t{\n+\t  if (is_cirrus_insn (next_nonnote_insn (first)))\n+\t    emit_insn_after (gen_nop (), first);\n+\n+\t  return;\n+\t}\n+      else if (is_load_address (first))\n+\t{\n+\t  unsigned int arm_regno;\n+\n+\t  /* Any ldr/cfmvdlr, ldr/cfmvdhr, ldr/cfmvsr, ldr/cfmv64lr,\n+\t     ldr/cfmv64hr combination where the Rd field is the same\n+\t     in both instructions must be split with a non Cirrus\n+\t     insn.  Example:\n+\n+\t     ldr r0, blah\n+\t     nop\n+\t     cfmvsr mvf0, r0.  */\n+\n+\t  /* Get Arm register number for ldr insn.  */\n+\t  if (GET_CODE (lhs) == REG)\n+\t    arm_regno = REGNO (lhs);\n+\t  else if (GET_CODE (rhs) == REG)\n+\t    arm_regno = REGNO (rhs);\n+\t  else\n+\t    abort ();\n+\n+\t  /* Next insn.  */\n+\t  first = next_nonnote_insn (first);\n+\n+\t  if (!is_cirrus_insn (first))\n+\t    return;\n+\n+\t  body = PATTERN (first);\n+\n+          /* (float (blah)) is in parallel with a clobber.  */\n+          if (GET_CODE (body) == PARALLEL && XVECLEN (body, 0))\n+\t    body = XVECEXP (body, 0, 0);\n+\n+\t  if (GET_CODE (body) == FLOAT)\n+\t    body = XEXP (body, 0);\n+\n+\t  if (get_attr_cirrus (first) == CIRRUS_MOVE\n+\t      && GET_CODE (XEXP (body, 1)) == REG\n+\t      && arm_regno == REGNO (XEXP (body, 1)))\n+\t    emit_insn_after (gen_nop (), first);\n+\n+\t  return;\n+\t}\n+    }\n+\n+  /* get_attr aborts on USE and CLOBBER.  */\n+  if (!first\n+      || GET_CODE (first) != INSN\n+      || GET_CODE (PATTERN (first)) == USE\n+      || GET_CODE (PATTERN (first)) == CLOBBER)\n+    return;\n+\n+  attr = get_attr_cirrus (first);\n+\n+  /* Any coprocessor compare instruction (cfcmps, cfcmpd, ...)\n+     must be followed by a non-coprocessor instruction.  */\n+  if (attr == CIRRUS_COMPARE)\n+    {\n+      nops = 0;\n+\n+      t = next_nonnote_insn (first);\n+\n+      if (is_cirrus_insn (t))\n+\t++ nops;\n+\n+      if (is_cirrus_insn (next_nonnote_insn (t)))\n+\t++ nops;\n+\n+      while (nops --)\n+\temit_insn_after (gen_nop (), first);\n+\n+      return;\n+    }\n+}\n+\n /* Return nonzero if OP is a constant power of two.  */\n \n int\n@@ -5355,6 +5652,8 @@ arm_select_cc_mode (op, x, y)\n \tcase LE:\n \tcase GT:\n \tcase GE:\n+\t  if (TARGET_CIRRUS)\n+\t    return CCFPmode;\n \t  return CCFPEmode;\n \n \tdefault:\n@@ -6678,6 +6977,12 @@ arm_reorg (first)\n   /* Scan all the insns and record the operands that will need fixing.  */\n   for (insn = next_nonnote_insn (first); insn; insn = next_nonnote_insn (insn))\n     {\n+      if (TARGET_CIRRUS_FIX_INVALID_INSNS\n+          && (is_cirrus_insn (insn)\n+\t      || GET_CODE (insn) == JUMP_INSN\n+\t      || is_load_address (insn)))\n+\tcirrus_reorg (insn);\n+\n       if (GET_CODE (insn) == BARRIER)\n \tpush_minipool_barrier (insn, address);\n       else if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN\n@@ -9168,6 +9473,16 @@ arm_print_operand (stream, x, code)\n       fprintf (stream, \"%s\", arithmetic_instr (x, 1));\n       return;\n \n+    /* Truncate Cirrus shift counts.  */\n+    case 's':\n+      if (GET_CODE (x) == CONST_INT)\n+\t{\n+\t  fprintf (stream, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) & 0x3f);\n+\t  return;\n+\t}\n+      arm_print_operand (stream, x, 0);\n+      return;\n+\n     case 'I':\n       fprintf (stream, \"%s\", arithmetic_instr (x, 0));\n       return;\n@@ -9274,6 +9589,43 @@ arm_print_operand (stream, x, code)\n \tfputs (thumb_condition_code (x, 1), stream);\n       return;\n \n+\n+    /* Cirrus registers can be accessed in a variety of ways:\n+         single floating point (f)\n+\t double floating point (d)\n+\t 32bit integer         (fx)\n+\t 64bit integer         (dx).  */\n+    case 'W':\t\t\t/* Cirrus register in F mode.  */\n+    case 'X':\t\t\t/* Cirrus register in D mode.  */\n+    case 'Y':\t\t\t/* Cirrus register in FX mode.  */\n+    case 'Z':\t\t\t/* Cirrus register in DX mode.  */\n+      if (GET_CODE (x) != REG || REGNO_REG_CLASS (REGNO (x)) != CIRRUS_REGS)\n+\tabort ();\n+\n+      fprintf (stream, \"mv%s%s\",\n+\t       code == 'W' ? \"f\"\n+\t       : code == 'X' ? \"d\"\n+\t       : code == 'Y' ? \"fx\" : \"dx\", reg_names[REGNO (x)] + 2);\n+\n+      return;\n+\n+    /* Print cirrus register in the mode specified by the register's mode.  */\n+    case 'V':\n+      {\n+\tint mode = GET_MODE (x);\n+\n+\tif (GET_CODE (x) != REG || REGNO_REG_CLASS (REGNO (x)) != CIRRUS_REGS)\n+\t  abort ();\n+\n+\tfprintf (stream, \"mv%s%s\",\n+\t\t mode == DFmode ? \"d\"\n+\t\t : mode == SImode ? \"fx\"\n+\t\t : mode == DImode ? \"dx\"\n+\t\t : \"f\", reg_names[REGNO (x)] + 2);\n+\n+\treturn;\n+      }\n+\n     default:\n       if (x == 0)\n \tabort ();\n@@ -9765,6 +10117,18 @@ arm_final_prescan_insn (insn)\n \t\t    || GET_CODE (scanbody) == PARALLEL)\n \t\t  || get_attr_conds (this_insn) != CONDS_NOCOND)\n \t\tfail = TRUE;\n+\n+\t      /* A conditional cirrus instruction must be followed by\n+\t\t a non Cirrus instruction.  However, since we\n+\t\t conditionalize instructions in this function and by\n+\t\t the time we get here we can't add instructions\n+\t\t (nops), because shorten_branches() has already been\n+\t\t called, we will disable conditionalizing Cirrus\n+\t\t instructions to be safe.  */\n+\t      if (GET_CODE (scanbody) != USE\n+\t\t  && GET_CODE (scanbody) != CLOBBER\n+\t\t  && get_attr_cirrus (this_insn) != CIRRUS_NO)\n+\t\tfail = TRUE;\n \t      break;\n \n \t    default:\n@@ -9848,6 +10212,14 @@ arm_hard_regno_mode_ok (regno, mode)\n        start of an even numbered register pair.  */\n     return (ARM_NUM_REGS (mode) < 2) || (regno < LAST_LO_REGNUM);\n \n+  if (IS_CIRRUS_REGNUM (regno))\n+    /* We have outlawed SI values in Cirrus registers because they\n+       reside in the lower 32 bits, but SF values reside in the\n+       upper 32 bits.  This causes gcc all sorts of grief.  We can't\n+       even split the registers into pairs because Cirrus SI values\n+       get sign extended to 64bits-- aldyh.  */\n+    return (GET_MODE_CLASS (mode) == MODE_FLOAT) || (mode == DImode);\n+\n   if (regno <= LAST_ARM_REGNUM)\n     /* We allow any value to be stored in the general regisetrs.  */\n     return 1;\n@@ -9887,6 +10259,9 @@ arm_regno_class (regno)\n   if (regno == CC_REGNUM)\n     return NO_REGS;\n \n+  if (IS_CIRRUS_REGNUM (regno))\n+    return CIRRUS_REGS;\n+\n   return FPU_REGS;\n }\n "}, {"sha": "5732f38c7d0f0d8b163605620379781788925d01", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 108, "deletions": 18, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "patch": "@@ -96,6 +96,7 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_CPU_arm9\t\t0x0080\n #define TARGET_CPU_arm9tdmi\t0x0080\n #define TARGET_CPU_xscale       0x0100\n+#define TARGET_CPU_ep9312\t0x0200\n /* Configure didn't specify.  */\n #define TARGET_CPU_generic\t0x8000\n \n@@ -164,13 +165,22 @@ extern GTY(()) rtx aof_pic_label;\n #if TARGET_CPU_DEFAULT == TARGET_CPU_xscale\n #define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_5TE__ -D__XSCALE__\"\n #else\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_ep9312\n+#define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_4T__ -D__MAVERICK__\"\n+/* Set TARGET_DEFAULT to the default, but without soft-float.  */\n+#ifdef  TARGET_DEFAULT\n+#undef  TARGET_DEFAULT\n+#define TARGET_DEFAULT\t(ARM_FLAG_APCS_32 | ARM_FLAG_APCS_FRAME)\n+#endif /* TARGET_CPU_DEFAULT */\n+#else\n Unrecognized value in TARGET_CPU_DEFAULT.\n #endif\n #endif\n #endif\n #endif\n #endif\n #endif\n+#endif\n \n #undef  CPP_SPEC\n #define CPP_SPEC \"%(cpp_cpu_arch) %(subtarget_cpp_spec)\t\t\t\\\n@@ -212,6 +222,8 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{march=strongarm1100:-D__ARM_ARCH_4__} \\\n %{march=xscale:-D__ARM_ARCH_5TE__} \\\n %{march=xscale:-D__XSCALE__} \\\n+%{march=ep9312:-D__ARM_ARCH_4T__} \\\n+%{march=ep9312:-D__MAVERICK__} \\\n %{march=armv2:-D__ARM_ARCH_2__} \\\n %{march=armv2a:-D__ARM_ARCH_2__} \\\n %{march=armv3:-D__ARM_ARCH_3__} \\\n@@ -251,6 +263,8 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n  %{mcpu=strongarm1100:-D__ARM_ARCH_4__} \\\n  %{mcpu=xscale:-D__ARM_ARCH_5TE__} \\\n  %{mcpu=xscale:-D__XSCALE__} \\\n+ %{mcpu=ep9312:-D__ARM_ARCH_4T__} \\\n+ %{mcpu=ep9312:-D__MAVERICK__} \\\n  %{!mcpu*:%(cpp_cpu_arch_default)}} \\\n \"\n \n@@ -376,6 +390,9 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n /* Nonzero means to use ARM/Thumb Procedure Call Standard conventions.  */\n #define ARM_FLAG_ATPCS\t\t(1 << 22)\n \n+/* Fix invalid Cirrus instruction combinations by inserting NOPs.  */\n+#define CIRRUS_FIX_INVALID_INSNS (1 << 23)\n+\n #define TARGET_APCS_FRAME\t\t(target_flags & ARM_FLAG_APCS_FRAME)\n #define TARGET_POKE_FUNCTION_NAME\t(target_flags & ARM_FLAG_POKE)\n #define TARGET_FPE\t\t\t(target_flags & ARM_FLAG_FPE)\n@@ -387,6 +404,8 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #define TARGET_MMU_TRAPS\t\t(target_flags & ARM_FLAG_MMU_TRAPS)\n #define TARGET_SOFT_FLOAT\t\t(target_flags & ARM_FLAG_SOFT_FLOAT)\n #define TARGET_HARD_FLOAT\t\t(! TARGET_SOFT_FLOAT)\n+#define TARGET_CIRRUS\t\t\t(arm_is_cirrus)\n+#define TARGET_ANY_HARD_FLOAT\t\t(TARGET_HARD_FLOAT || TARGET_CIRRUS)\n #define TARGET_VFP\t\t\t(target_flags & ARM_FLAG_VFP)\n #define TARGET_BIG_END\t\t\t(target_flags & ARM_FLAG_BIG_END)\n #define TARGET_INTERWORK\t\t(target_flags & ARM_FLAG_INTERWORK)\n@@ -403,6 +422,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #define TARGET_BACKTRACE\t        (leaf_function_p ()\t      \t\t\t\\\n \t\t\t\t         ? (target_flags & THUMB_FLAG_LEAF_BACKTRACE)\t\\\n \t\t\t\t         : (target_flags & THUMB_FLAG_BACKTRACE))\n+#define TARGET_CIRRUS_FIX_INVALID_INSNS\t(target_flags & CIRRUS_FIX_INVALID_INSNS)\n \n /* SUBTARGET_SWITCHES is used to add flags on a per-config basis.  */\n #ifndef SUBTARGET_SWITCHES\n@@ -481,6 +501,10 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n    N_(\"Thumb: Assume function pointers may go to non-Thumb aware code\") }, \\\n   {\"no-caller-super-interworking\", -THUMB_FLAG_CALLER_SUPER_INTERWORKING,  \\\n    \"\" },\t\t\t\t\t\t\t\t   \\\n+  {\"cirrus-fix-invalid-insns\",      CIRRUS_FIX_INVALID_INSNS,\t\t   \\\n+   N_(\"Cirrus: Place NOPs to avoid invalid instruction combinations\") },   \\\n+  {\"no-cirrus-fix-invalid-insns\",  -CIRRUS_FIX_INVALID_INSNS,\t\t   \\\n+   N_(\"Cirrus: Do not break up invalid instruction combinations with NOPs\") },\\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t   \\\n   {\"\",\t\t\t\tTARGET_DEFAULT, \"\" }\t\t\t   \\\n }\n@@ -530,7 +554,8 @@ enum floating_point_type\n {\n   FP_HARD,\n   FP_SOFT2,\n-  FP_SOFT3\n+  FP_SOFT3,\n+  FP_CIRRUS\n };\n \n /* Recast the floating point class to be the floating point attribute.  */\n@@ -548,6 +573,11 @@ extern enum floating_point_type arm_fpu_arch;\n #define FP_DEFAULT FP_SOFT2\n #endif\n \n+#if TARGET_CPU_DEFAULT == TARGET_CPU_ep9312\n+#undef  FP_DEFAULT\n+#define FP_DEFAULT FP_CIRRUS\n+#endif\n+\n /* Nonzero if the processor has a fast multiply insn, and one that does\n    a 64-bit multiply of two 32-bit values.  */\n extern int arm_fast_multiply;\n@@ -570,6 +600,9 @@ extern int thumb_code;\n /* Nonzero if this chip is a StrongARM.  */\n extern int arm_is_strong;\n \n+/* Nonzero if this chip is a Cirrus variant.  */\n+extern int arm_is_cirrus;\n+\n /* Nonzero if this chip is an XScale.  */\n extern int arm_is_xscale;\n \n@@ -756,6 +789,11 @@ extern const char * structure_size_string;\n \n    *: See CONDITIONAL_REGISTER_USAGE  */\n \n+/*\n+  \tmvf0\t\tCirrus floating point result\n+\tmvf1-mvf3\tCirrus floating point scratch\n+\tmvf4-mvf15   S\tCirrus floating point variable.  */\n+\n /* The stack backtrace structure is as follows:\n   fp points to here:  |  save code pointer  |      [fp]\n                       |  return link value  |      [fp, #-4]\n@@ -785,7 +823,9 @@ extern const char * structure_size_string;\n   0,0,0,0,0,0,0,0,\t \\\n   0,0,0,0,0,1,0,1,\t \\\n   0,0,0,0,0,0,0,0,\t \\\n-  1,1,1\t\t\t \\\n+  1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\\\n+  1,1,1,1,1,1,1,1\t\\\n }\n \n /* 1 for registers not available across function calls.\n@@ -801,7 +841,9 @@ extern const char * structure_size_string;\n   1,1,1,1,0,0,0,0,\t     \\\n   0,0,0,0,1,1,1,1,\t     \\\n   1,1,1,1,0,0,0,0,\t     \\\n-  1,1,1\t\t\t     \\\n+  1,1,1,\t\t     \\\n+  1,1,1,1,1,1,1,1,\t     \\\n+  1,1,1,1,1,1,1,1\t     \\\n }\n \n #ifndef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n@@ -818,6 +860,20 @@ extern const char * structure_size_string;\n \t   regno <= LAST_ARM_FP_REGNUM; ++regno)\t\t\\\n \tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  if (TARGET_CIRRUS)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      for (regno = FIRST_ARM_FP_REGNUM;\t\t\t\t\\\n+\t   regno <= LAST_ARM_FP_REGNUM; ++ regno)\t\t\\\n+\tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n+      for (regno = FIRST_CIRRUS_FP_REGNUM;\t\t\t\\\n+\t   regno <= LAST_CIRRUS_FP_REGNUM; ++ regno)\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  fixed_regs[regno] = 0;\t\t\t\t\\\n+\t  call_used_regs[regno] = regno < FIRST_CIRRUS_FP_REGNUM + 4; \\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n   if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\t\\\n     {\t\t\t\t\t\t\t\t\\\n       fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n@@ -941,8 +997,14 @@ extern const char * structure_size_string;\n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM\t26\n \n+#define FIRST_CIRRUS_FP_REGNUM\t27\n+#define LAST_CIRRUS_FP_REGNUM\t42\n+#define IS_CIRRUS_REGNUM(REGNUM) \\\n+  (((REGNUM) >= FIRST_CIRRUS_FP_REGNUM) && ((REGNUM) <= LAST_CIRRUS_FP_REGNUM))\n+\n /* The number of hard registers is 16 ARM + 8 FPU + 1 CC + 1 SFP.  */\n-#define FIRST_PSEUDO_REGISTER\t27\n+/* Cirrus registers take us up to 43... */\n+#define FIRST_PSEUDO_REGISTER\t43\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms may be accessed\n@@ -990,6 +1052,8 @@ extern const char * structure_size_string;\n      3,  2,  1,  0, 12, 14,  4,  5, \\\n      6,  7,  8, 10,  9, 11, 13, 15, \\\n     16, 17, 18, 19, 20, 21, 22, 23, \\\n+    27, 28, 29, 30, 31, 32, 33, 34, \\\n+    35, 36, 37, 38, 39, 40, 41, 42, \\\n     24, 25, 26\t\t\t    \\\n }\n \n@@ -1008,6 +1072,7 @@ enum reg_class\n {\n   NO_REGS,\n   FPU_REGS,\n+  CIRRUS_REGS,\n   LO_REGS,\n   STACK_REG,\n   BASE_REGS,\n@@ -1025,6 +1090,7 @@ enum reg_class\n {\t\t\t\\\n   \"NO_REGS\",\t\t\\\n   \"FPU_REGS\",\t\t\\\n+  \"CIRRUS_REGS\",\t\\\n   \"LO_REGS\",\t\t\\\n   \"STACK_REG\",\t\t\\\n   \"BASE_REGS\",\t\t\\\n@@ -1039,15 +1105,16 @@ enum reg_class\n    of length N_REG_CLASSES.  */\n #define REG_CLASS_CONTENTS  \t\t\\\n {\t\t\t\t\t\\\n-  { 0x0000000 }, /* NO_REGS  */\t\t\\\n-  { 0x0FF0000 }, /* FPU_REGS */\t\t\\\n-  { 0x00000FF }, /* LO_REGS */\t\t\\\n-  { 0x0002000 }, /* STACK_REG */\t\\\n-  { 0x00020FF }, /* BASE_REGS */\t\\\n-  { 0x000FF00 }, /* HI_REGS */\t\t\\\n-  { 0x1000000 }, /* CC_REG */\t\t\\\n-  { 0x200FFFF }, /* GENERAL_REGS */\t\\\n-  { 0x2FFFFFF }  /* ALL_REGS */\t\t\\\n+  { 0x00000000, 0x0 },        /* NO_REGS  */\t\\\n+  { 0x00FF0000, 0x0 },        /* FPU_REGS */\t\\\n+  { 0xF8000000, 0x000007FF }, /* CIRRUS_REGS */\t\\\n+  { 0x000000FF, 0x0 },        /* LO_REGS */\t\\\n+  { 0x00002000, 0x0 },        /* STACK_REG */\t\\\n+  { 0x000020FF, 0x0 },        /* BASE_REGS */\t\\\n+  { 0x0000FF00, 0x0 },        /* HI_REGS */\t\\\n+  { 0x01000000, 0x0 },        /* CC_REG */\t\\\n+  { 0x0200FFFF, 0x0 },        /* GENERAL_REGS */\\\n+  { 0xFAFFFFFF, 0x000007FF }  /* ALL_REGS */\t\\\n }\n \n /* The same information, inverted:\n@@ -1080,6 +1147,7 @@ enum reg_class\n    ARM, but several more letters for the Thumb.  */\n #define REG_CLASS_FROM_LETTER(C)  \t\\\n   (  (C) == 'f' ? FPU_REGS\t\t\\\n+   : (C) == 'v' ? CIRRUS_REGS\t\t\\\n    : (C) == 'l' ? (TARGET_ARM ? GENERAL_REGS : LO_REGS)\t\\\n    : TARGET_ARM ? NO_REGS\t\t\\\n    : (C) == 'h' ? HI_REGS\t\t\\\n@@ -1143,8 +1211,9 @@ enum reg_class\n    (C) == 'R' ? (GET_CODE (OP) == MEM\t\t\t\t\t    \\\n \t\t && GET_CODE (XEXP (OP, 0)) == SYMBOL_REF\t\t    \\\n \t\t && CONSTANT_POOL_ADDRESS_P (XEXP (OP, 0))) :\t\t    \\\n-   (C) == 'S' ? (optimize > 0 && CONSTANT_ADDRESS_P (OP))\t\t    \\\n-   : 0)\n+   (C) == 'S' ? (optimize > 0 && CONSTANT_ADDRESS_P (OP)) :\t\t    \\\n+   (C) == 'T' ? cirrus_memory_offset (OP) : \t\t    \t\t    \\\n+   0)\n \n #define EXTRA_CONSTRAINT_THUMB(X, C)\t\t\t\t\t\\\n   ((C) == 'Q' ? (GET_CODE (X) == MEM\t\t\t\t\t\\\n@@ -1188,13 +1257,18 @@ enum reg_class\n    \n /* If we need to load shorts byte-at-a-time, then we need a scratch. */\n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n+  /* Cannot load constants into Cirrus registers.  */\t\t\\\n+  ((TARGET_CIRRUS\t\t\t\t\t\t\\\n+     && (CLASS) == CIRRUS_REGS\t\t\t\t\t\\\n+     && (CONSTANT_P (X) || GET_CODE (X) == SYMBOL_REF))\t\t\\\n+    ? GENERAL_REGS :\t\t\t\t\t\t\\\n   (TARGET_ARM ?\t\t\t\t\t\t\t\\\n    (((MODE) == HImode && ! arm_arch4 && TARGET_MMU_TRAPS\t\\\n      && (GET_CODE (X) == MEM\t\t\t\t\t\\\n \t || ((GET_CODE (X) == REG || GET_CODE (X) == SUBREG)\t\\\n \t     && true_regnum (X) == -1)))\t\t\t\\\n     ? GENERAL_REGS : NO_REGS)\t\t\t\t\t\\\n-   : THUMB_SECONDARY_INPUT_RELOAD_CLASS (CLASS, MODE, X))\n+   : THUMB_SECONDARY_INPUT_RELOAD_CLASS (CLASS, MODE, X)))\n \n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n@@ -1217,6 +1291,9 @@ enum reg_class\n \t\t\t\t\t\t\t\t\t   \\\n \t  if (MODE == DImode || (TARGET_SOFT_FLOAT && MODE == DFmode))\t   \\\n \t    low = ((val & 0xf) ^ 0x8) - 0x8;\t\t\t\t   \\\n+\t  else if (TARGET_CIRRUS)\t\t\t\t\t   \\\n+\t    /* Need to be careful, -256 is not a valid offset.  */\t   \\\n+\t    low = val >= 0 ? (val & 0xff) : -((-val) & 0xff);\t\t   \\\n \t  else if (MODE == SImode\t\t\t\t\t   \\\n \t\t   || (MODE == SFmode && TARGET_SOFT_FLOAT)\t\t   \\\n \t\t   || ((MODE == HImode || MODE == QImode) && ! arm_arch4)) \\\n@@ -1289,13 +1366,19 @@ enum reg_class\n    needed to represent mode MODE in a register of class CLASS.\n    ARM regs are UNITS_PER_WORD bits while FPU regs can hold any FP mode */\n #define CLASS_MAX_NREGS(CLASS, MODE)  \\\n-  ((CLASS) == FPU_REGS ? 1 : ARM_NUM_REGS (MODE))\n+  (((CLASS) == FPU_REGS || (CLASS) == CIRRUS_REGS) ? 1 : ARM_NUM_REGS (MODE))\n+\n+/* If defined, gives a class of registers that cannot be used as the\n+   operand of a SUBREG that changes the mode of the object illegally.  */\n \n /* Moves between FPU_REGS and GENERAL_REGS are two memory insns.  */\n #define REGISTER_MOVE_COST(MODE, FROM, TO)\t\t\\\n   (TARGET_ARM ?\t\t\t\t\t\t\\\n    ((FROM) == FPU_REGS && (TO) != FPU_REGS ? 20 :\t\\\n-    (FROM) != FPU_REGS && (TO) == FPU_REGS ? 20 : 2)\t\\\n+    (FROM) != FPU_REGS && (TO) == FPU_REGS ? 20 :\t\\\n+    (FROM) == CIRRUS_REGS && (TO) != CIRRUS_REGS ? 20 :\t\\\n+    (FROM) != CIRRUS_REGS && (TO) == CIRRUS_REGS ? 20 :\t\\\n+   2)\t\t\t\t\t\t\t\\\n    :\t\t\t\t\t\t\t\\\n    ((FROM) == HI_REGS || (TO) == HI_REGS) ? 4 : 2)\n \f\n@@ -1347,6 +1430,8 @@ enum reg_class\n #define LIBCALL_VALUE(MODE)  \\\n   (TARGET_ARM && TARGET_HARD_FLOAT && GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n    ? gen_rtx_REG (MODE, FIRST_ARM_FP_REGNUM) \\\n+   : TARGET_ARM && TARGET_CIRRUS && GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n+   ? gen_rtx_REG (MODE, FIRST_CIRRUS_FP_REGNUM) \t\t\t\\\n    : gen_rtx_REG (MODE, ARG_REGISTER (1)))\n \n /* Define how to find the value returned by a function.\n@@ -1358,8 +1443,10 @@ enum reg_class\n \n /* 1 if N is a possible register number for a function value.\n    On the ARM, only r0 and f0 can return results.  */\n+/* On a Cirrus chip, mvf0 can return results.  */\n #define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n   ((REGNO) == ARG_REGISTER (1) \\\n+   || (TARGET_ARM && ((REGNO) == FIRST_CIRRUS_FP_REGNUM) && TARGET_CIRRUS) \\\n    || (TARGET_ARM && ((REGNO) == FIRST_ARM_FP_REGNUM) && TARGET_HARD_FLOAT))\n \n /* How large values are returned */\n@@ -2449,6 +2536,9 @@ extern int making_const_table;\n   {\"multi_register_push\", {PARALLEL}},\t\t\t\t\t\\\n   {\"cc_register\", {REG}},\t\t\t\t\t\t\\\n   {\"logical_binary_operator\", {AND, IOR, XOR}},\t\t\t\t\\\n+  {\"cirrus_register_operand\", {REG}},\t\t\t\t\t\\\n+  {\"cirrus_fp_register\", {REG}},\t\t\t\t\t\\\n+  {\"cirrus_shift_const\", {CONST_INT}},\t\t\t\t\t\\\n   {\"dominant_cc_register\", {REG}},\n \n /* Define this if you have special predicates that know special things"}, {"sha": "705d22dbf01443d86c25cf1649349b4d97883785", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 138, "deletions": 31, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "patch": "@@ -386,6 +386,8 @@\n   (and (eq_attr \"core_cycles\" \"multi\")\n        (eq_attr \"type\" \"!mult,load,store1,store2,store3,store4\")) 32 32)\n \f\n+(include \"cirrus.md\")\n+\n ;;---------------------------------------------------------------------------\n ;; Insn patterns\n ;;\n@@ -394,6 +396,8 @@\n ;; Note: For DImode insns, there is normally no reason why operands should\n ;; not be in the same register, what we don't want is for something being\n ;; written to partially overlap something that is an input.\n+;; Cirrus 64bit additions should not be split because we have a native\n+;; 64bit addition instructions.\n \n (define_expand \"adddi3\"\n  [(parallel\n@@ -403,6 +407,16 @@\n     (clobber (reg:CC CC_REGNUM))])]\n   \"TARGET_EITHER\"\n   \"\n+  if (TARGET_CIRRUS)\n+    {\n+      if (!cirrus_fp_register (operands[0], DImode))\n+        operands[0] = force_reg (DImode, operands[0]);\n+      if (!cirrus_fp_register (operands[1], DImode))\n+        operands[1] = force_reg (DImode, operands[1]);\n+      emit_insn (gen_cirrus_adddi3 (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+\n   if (TARGET_THUMB)\n     {\n       if (GET_CODE (operands[1]) != REG)\n@@ -429,7 +443,7 @@\n \t(plus:DI (match_operand:DI 1 \"s_register_operand\" \"%0, 0\")\n \t\t (match_operand:DI 2 \"s_register_operand\" \"r,  0\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && !TARGET_CIRRUS\"\n   \"#\"\n   \"TARGET_ARM && reload_completed\"\n   [(parallel [(set (reg:CC_C CC_REGNUM)\n@@ -457,7 +471,7 @@\n \t\t  (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n \t\t (match_operand:DI 1 \"s_register_operand\" \"r,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && !TARGET_CIRRUS\"\n   \"#\"\n   \"TARGET_ARM && reload_completed\"\n   [(parallel [(set (reg:CC_C CC_REGNUM)\n@@ -486,7 +500,7 @@\n \t\t  (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n \t\t (match_operand:DI 1 \"s_register_operand\" \"r,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && !TARGET_CIRRUS\"\n   \"#\"\n   \"TARGET_ARM && reload_completed\"\n   [(parallel [(set (reg:CC_C CC_REGNUM)\n@@ -789,7 +803,7 @@\n    (set_attr \"length\" \"4,8\")]\n )\n \n-(define_insn \"addsf3\"\n+(define_insn \"*arm_addsf3\"\n   [(set (match_operand:SF          0 \"s_register_operand\" \"=f,f\")\n \t(plus:SF (match_operand:SF 1 \"s_register_operand\" \"%f,f\")\n \t\t (match_operand:SF 2 \"fpu_add_operand\"    \"fG,H\")))]\n@@ -801,7 +815,7 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_insn \"adddf3\"\n+(define_insn \"*arm_adddf3\"\n   [(set (match_operand:DF          0 \"s_register_operand\" \"=f,f\")\n \t(plus:DF (match_operand:DF 1 \"s_register_operand\" \"%f,f\")\n \t\t (match_operand:DF 2 \"fpu_add_operand\"    \"fG,H\")))]\n@@ -857,6 +871,15 @@\n     (clobber (reg:CC CC_REGNUM))])]\n   \"TARGET_EITHER\"\n   \"\n+  if (TARGET_CIRRUS\n+      && TARGET_ARM\n+      && cirrus_fp_register (operands[0], DImode)\n+      && cirrus_fp_register (operands[1], DImode))\n+    {\n+      emit_insn (gen_cirrus_subdi3 (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+\n   if (TARGET_THUMB)\n     {\n       if (GET_CODE (operands[1]) != REG)\n@@ -1042,7 +1065,7 @@\n    (set_attr \"length\" \"*,8\")]\n )\n \n-(define_insn \"subsf3\"\n+(define_insn \"*arm_subsf3\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"=f,f\")\n \t(minus:SF (match_operand:SF 1 \"fpu_rhs_operand\" \"f,G\")\n \t\t  (match_operand:SF 2 \"fpu_rhs_operand\" \"fG,f\")))]\n@@ -1053,7 +1076,7 @@\n   [(set_attr \"type\" \"farith\")]\n )\n \n-(define_insn \"subdf3\"\n+(define_insn \"*arm_subdf3\"\n   [(set (match_operand:DF           0 \"s_register_operand\" \"=f,f\")\n \t(minus:DF (match_operand:DF 1 \"fpu_rhs_operand\"     \"f,G\")\n \t\t  (match_operand:DF 2 \"fpu_rhs_operand\"    \"fG,f\")))]\n@@ -1332,7 +1355,7 @@\n   \"smlalbb%?\\\\t%Q0, %R0, %2, %3\"\n [(set_attr \"type\" \"mult\")])\n \n-(define_insn \"mulsf3\"\n+(define_insn \"*arm_mulsf3\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"=f\")\n \t(mult:SF (match_operand:SF 1 \"s_register_operand\" \"f\")\n \t\t (match_operand:SF 2 \"fpu_rhs_operand\" \"fG\")))]\n@@ -1342,7 +1365,7 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_insn \"muldf3\"\n+(define_insn \"*arm_muldf3\"\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n \t(mult:DF (match_operand:DF 1 \"s_register_operand\" \"f\")\n \t\t (match_operand:DF 2 \"fpu_rhs_operand\" \"fG\")))]\n@@ -2529,6 +2552,19 @@\n   [(set_attr \"length\" \"2\")]\n )\n \n+(define_expand \"ashldi3\"\n+  [(set (match_operand:DI            0 \"s_register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"general_operand\"    \"\")\n+\t\t   (match_operand:SI 2 \"general_operand\"    \"\")))]\n+  \"TARGET_ARM && (TARGET_CIRRUS)\"\n+  \"\n+  if (! s_register_operand (operands[1], DImode))\n+    operands[1] = copy_to_mode_reg (DImode, operands[1]);\n+  if (! s_register_operand (operands[2], SImode))\n+    operands[2] = copy_to_mode_reg (SImode, operands[2]);\n+  \"\n+)\n+\n (define_insn \"*arm_shiftsi3\"\n   [(set (match_operand:SI   0 \"s_register_operand\" \"=r\")\n \t(match_operator:SI  3 \"shift_operator\"\n@@ -2702,7 +2738,7 @@\n   [(set_attr \"length\" \"2\")]\n )\n \n-(define_insn \"negsf2\"\n+(define_insn \"*arm_negsf2\"\n   [(set (match_operand:SF         0 \"s_register_operand\" \"=f\")\n \t(neg:SF (match_operand:SF 1 \"s_register_operand\" \"f\")))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n@@ -2711,7 +2747,7 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_insn \"negdf2\"\n+(define_insn \"*arm_negdf2\"\n   [(set (match_operand:DF         0 \"s_register_operand\" \"=f\")\n \t(neg:DF (match_operand:DF 1 \"s_register_operand\" \"f\")))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n@@ -2735,7 +2771,7 @@\n ;; it does, but tell the final scan operator the truth.  Similarly for\n ;; (neg (abs...))\n \n-(define_insn \"abssi2\"\n+(define_insn \"*arm_abssi2\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"=r,&r\")\n \t(abs:SI (match_operand:SI 1 \"s_register_operand\" \"0,r\")))\n    (clobber (reg:CC CC_REGNUM))]\n@@ -2763,7 +2799,7 @@\n    (set_attr \"length\" \"8\")]\n )\n \n-(define_insn \"abssf2\"\n+(define_insn \"*arm_abssf2\"\n   [(set (match_operand:SF          0 \"s_register_operand\" \"=f\")\n \t (abs:SF (match_operand:SF 1 \"s_register_operand\" \"f\")))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n@@ -2772,7 +2808,7 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_insn \"absdf2\"\n+(define_insn \"*arm_absdf2\"\n   [(set (match_operand:DF         0 \"s_register_operand\" \"=f\")\n \t(abs:DF (match_operand:DF 1 \"s_register_operand\" \"f\")))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n@@ -2884,7 +2920,7 @@\n \f\n ;; Fixed <--> Floating conversion insns\n \n-(define_insn \"floatsisf2\"\n+(define_insn \"*arm_floatsisf2\"\n   [(set (match_operand:SF           0 \"s_register_operand\" \"=f\")\n \t(float:SF (match_operand:SI 1 \"s_register_operand\" \"r\")))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n@@ -2893,7 +2929,7 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_insn \"floatsidf2\"\n+(define_insn \"*arm_floatsidf2\"\n   [(set (match_operand:DF           0 \"s_register_operand\" \"=f\")\n \t(float:DF (match_operand:SI 1 \"s_register_operand\" \"r\")))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n@@ -2902,7 +2938,7 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_insn \"fix_truncsfsi2\"\n+(define_insn \"*arm_fix_truncsfsi2\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"=r\")\n \t(fix:SI (match_operand:SF 1 \"s_register_operand\" \"f\")))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n@@ -2911,7 +2947,7 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_insn \"fix_truncdfsi2\"\n+(define_insn \"*arm_fix_truncdfsi2\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"=r\")\n \t(fix:SI (match_operand:DF 1 \"s_register_operand\" \"f\")))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n@@ -2922,7 +2958,7 @@\n \n ;; Truncation insns\n \n-(define_insn \"truncdfsf2\"\n+(define_insn \"*arm_truncdfsf2\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"=f\")\n \t(float_truncate:SF\n \t (match_operand:DF 1 \"s_register_operand\" \"f\")))]\n@@ -3654,7 +3690,7 @@\n    (set_attr \"pool_range\" \"32,32\")]\n )\n \n-(define_insn \"extendsfdf2\"\n+(define_insn \"*arm_extendsfdf2\"\n   [(set (match_operand:DF                  0 \"s_register_operand\" \"=f\")\n \t(float_extend:DF (match_operand:SF 1 \"s_register_operand\"  \"f\")))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n@@ -3743,7 +3779,7 @@\n (define_insn \"*arm_movdi\"\n   [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r, o<>\")\n \t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r\"))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && !TARGET_CIRRUS\"\n   \"*\n   return (output_move_double (operands));\n   \"\n@@ -3761,6 +3797,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=l,l,l,l,>,l, m,*r\")\n \t(match_operand:DI 1 \"general_operand\"      \"l, I,J,>,l,mi,l,*r\"))]\n   \"TARGET_THUMB\n+   && !TARGET_CIRRUS\n    && (   register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\"\n   \"*\n@@ -4769,6 +4806,7 @@\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n \t(match_operand:SF 1 \"general_operand\"  \"r,mE,r\"))]\n   \"TARGET_ARM\n+   && !TARGET_CIRRUS\n    && TARGET_SOFT_FLOAT\n    && (GET_CODE (operands[0]) != MEM\n        || register_operand (operands[1], SFmode))\"\n@@ -4909,6 +4947,7 @@\n   [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=r,r,m\")\n \t(match_operand:DF 1 \"soft_df_operand\" \"r,mF,r\"))]\n   \"TARGET_ARM && TARGET_SOFT_FLOAT\n+   && !TARGET_CIRRUS\n   \"\n   \"* return output_move_double (operands);\"\n   [(set_attr \"length\" \"8,8,8\")\n@@ -5414,8 +5453,11 @@\n (define_expand \"cmpsf\"\n   [(match_operand:SF 0 \"s_register_operand\" \"\")\n    (match_operand:SF 1 \"fpu_rhs_operand\" \"\")]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n   \"\n+  if (TARGET_CIRRUS && !cirrus_fp_register (operands[1], SFmode))\n+    operands[1] = force_reg (SFmode, operands[1]);\n+\n   arm_compare_op0 = operands[0];\n   arm_compare_op1 = operands[1];\n   DONE;\n@@ -5425,8 +5467,11 @@\n (define_expand \"cmpdf\"\n   [(match_operand:DF 0 \"s_register_operand\" \"\")\n    (match_operand:DF 1 \"fpu_rhs_operand\" \"\")]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n   \"\n+  if (TARGET_CIRRUS && !cirrus_fp_register (operands[1], DFmode))\n+    operands[1] = force_reg (DFmode, operands[1]);\n+\n   arm_compare_op0 = operands[0];\n   arm_compare_op1 = operands[1];\n   DONE;\n@@ -5531,6 +5576,65 @@\n    (set_attr \"type\" \"f_2_r\")]\n )\n \n+;; There is no CCFPE or CCFP modes in the code below so we can have\n+;; one pattern to match either one.  Besides, we're pretty sure we\n+;; have either CCFPE or CCFP because we made the patterns\n+;; (arm_gen_compare_reg).\n+\n+;; Cirrus SF compare instruction\n+(define_insn \"*cirrus_cmpsf\"\n+  [(set (reg:CCFP CC_REGNUM)\n+\t(compare:CCFP (match_operand:SF 0 \"cirrus_fp_register\" \"v\")\n+\t\t      (match_operand:SF 1 \"cirrus_fp_register\" \"v\")))]\n+  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"cfcmps%?\\\\tr15, %V0, %V1\"\n+  [(set_attr \"cirrus_type\" \"farith\")\n+   (set_attr \"cirrus\" \"compare\")]\n+)\n+\n+;; Cirrus DF compare instruction\n+(define_insn \"*cirrus_cmpdf\"\n+  [(set (reg:CCFP CC_REGNUM)\n+\t(compare:CCFP (match_operand:DF 0 \"cirrus_fp_register\" \"v\")\n+\t\t      (match_operand:DF 1 \"cirrus_fp_register\" \"v\")))]\n+  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"cfcmpd%?\\\\tr15, %V0, %V1\"\n+  [(set_attr \"cirrus_type\" \"farith\")\n+   (set_attr \"cirrus\" \"compare\")]\n+)\n+\n+;; Cirrus DI compare instruction\n+(define_expand \"cmpdi\"\n+  [(match_operand:DI 0 \"cirrus_fp_register\" \"\")\n+   (match_operand:DI 1 \"cirrus_fp_register\" \"\")]\n+  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"{\n+     arm_compare_op0 = operands[0];\n+     arm_compare_op1 = operands[1];\n+     DONE;\n+   }\")\n+\n+(define_insn \"*cirrus_cmpdi\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_operand:DI 0 \"cirrus_fp_register\" \"v\")\n+\t\t    (match_operand:DI 1 \"cirrus_fp_register\" \"v\")))]\n+  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"cfcmp64%?\\\\tr15, %V0, %V1\"\n+  [(set_attr \"cirrus_type\" \"farith\")\n+   (set_attr \"cirrus\" \"compare\")]\n+)\n+\n+;; Cirrus SI compare instruction\n+(define_insn \"*cirrus_cmpsi_1\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_operand:SI 0 \"cirrus_fp_register\" \"v\")\n+\t\t    (match_operand:SI 1 \"cirrus_fp_register\" \"v\")))]\n+  \"TARGET_ARM && TARGET_CIRRUS && 0\"\n+  \"cfcmp32%?\\\\tr15, %V0, %V1\"\n+  [(set_attr \"cirrus_type\" \"farith\")\n+   (set_attr \"cirrus\" \"compare\")]\n+)\n+\n (define_insn \"*cmpsf_trap\"\n   [(set (reg:CCFPE CC_REGNUM)\n \t(compare:CCFPE (match_operand:SF 0 \"s_register_operand\" \"f,f\")\n@@ -6347,8 +6451,8 @@\n )\n \n (define_insn \"*call_value_reg\"\n-  [(set (match_operand 0 \"\" \"=r,f\")\n-        (call (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r,r\"))\n+  [(set (match_operand 0 \"\" \"=r,f,v\")\n+        (call (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r,r,r\"))\n \t      (match_operand 2 \"\" \"\")))\n    (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI LR_REGNUM))]\n@@ -6361,8 +6465,8 @@\n )\n \n (define_insn \"*call_value_mem\"\n-  [(set (match_operand 0 \"\" \"=r,f\")\n-\t(call (mem:SI (match_operand:SI 1 \"memory_operand\" \"m,m\"))\n+  [(set (match_operand 0 \"\" \"=r,f,v\")\n+\t(call (mem:SI (match_operand:SI 1 \"memory_operand\" \"m,m,m\"))\n \t      (match_operand 2 \"\" \"\")))\n    (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI LR_REGNUM))]\n@@ -6393,8 +6497,8 @@\n )\n \n (define_insn \"*call_value_symbol\"\n-  [(set (match_operand 0 \"s_register_operand\" \"=r,f\")\n-\t(call (mem:SI (match_operand:SI 1 \"\" \"X,X\"))\n+  [(set (match_operand 0 \"s_register_operand\" \"=r,f,v\")\n+\t(call (mem:SI (match_operand:SI 1 \"\" \"X,X,X\"))\n \t(match_operand:SI 2 \"\" \"\")))\n    (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI LR_REGNUM))]\n@@ -6476,8 +6580,8 @@\n )\n \n (define_insn \"*sibcall_value_insn\"\n- [(set (match_operand 0 \"s_register_operand\" \"=r,f\")\n-       (call (mem:SI (match_operand:SI 1 \"\" \"X,X\"))\n+ [(set (match_operand 0 \"s_register_operand\" \"=r,f,v\")\n+       (call (mem:SI (match_operand:SI 1 \"\" \"X,X,X\"))\n \t     (match_operand 2 \"\" \"\")))\n   (return)\n   (use (match_operand 3 \"\" \"\"))]\n@@ -8274,6 +8378,9 @@\n    (set (reg:CC CC_REGNUM)\n \t(compare:CC (match_dup 1) (const_int 0)))]\n   \"TARGET_ARM\n+   && (!TARGET_CIRRUS\n+       || (!cirrus_fp_register (operands[0], SImode)\n+           && !cirrus_fp_register (operands[1], SImode)))\n   \"\n   [(parallel [(set (reg:CC CC_REGNUM) (compare:CC (match_dup 1) (const_int 0)))\n \t      (set (match_dup 0) (match_dup 1))])]"}, {"sha": "79506fb5a62648fdd36e9ac1fb70ff7bce429435", "filename": "gcc/config/arm/t-arm-elf", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig%2Farm%2Ft-arm-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fconfig%2Farm%2Ft-arm-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm-elf?ref=9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "patch": "@@ -24,6 +24,10 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n MULTILIB_OPTIONS     = marm/mthumb\n MULTILIB_DIRNAMES    = arm thumb\n MULTILIB_EXCEPTIONS  = \n+\n+# MULTILIB_OPTIONS    += mcpu=ep9312\n+# MULTILIB_DIRNAMES   += ep9312\n+# MULTILIB_EXCEPTIONS += *mthumb/*mcpu=ep9312*\n \t\n # MULTILIB_OPTIONS     += mlittle-endian/mbig-endian\n # MULTILIB_DIRNAMES    += le be"}, {"sha": "cfcf4dc9e0880dcccc3c5f83aadc498f41fb39d6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9b6b54e2fe12171e8d7178c2fd8f6bd0d5493718", "patch": "@@ -386,6 +386,7 @@ in the following sections.\n -msingle-pic-base  -mno-single-pic-base @gol\n -mpic-register=@var{reg} @gol\n -mnop-fun-dllimport @gol\n+-mcirrus-fix-invalid-insns -mno-cirrus-fix-invalid-insns @gol\n -mpoke-function-name @gol\n -mthumb  -marm @gol\n -mtpcs-frame  -mtpcs-leaf-frame @gol\n@@ -6132,7 +6133,7 @@ assembly code.  Permissible names are: @samp{arm2}, @samp{arm250},\n @samp{strongarm}, @samp{strongarm110}, @samp{strongarm1100},\n @samp{arm8}, @samp{arm810}, @samp{arm9}, @samp{arm9e}, @samp{arm920},\n @samp{arm920t}, @samp{arm940t}, @samp{arm9tdmi}, @samp{arm10tdmi},\n-@samp{arm1020t}, @samp{xscale}.\n+@samp{arm1020t}, @samp{xscale}, @samp{ep9312}.\n \n @itemx -mtune=@var{name}\n @opindex mtune\n@@ -6152,7 +6153,7 @@ name to determine what kind of instructions it can emit when generating\n assembly code.  This option can be used in conjunction with or instead\n of the @option{-mcpu=} option.  Permissible names are: @samp{armv2},\n @samp{armv2a}, @samp{armv3}, @samp{armv3m}, @samp{armv4}, @samp{armv4t},\n-@samp{armv5}, @samp{armv5t}, @samp{armv5te}.\n+@samp{armv5}, @samp{armv5t}, @samp{armv5te}, @samp{ep9312}.\n \n @item -mfpe=@var{number}\n @itemx -mfp=@var{number}\n@@ -6224,6 +6225,18 @@ before execution begins.\n Specify the register to be used for PIC addressing.  The default is R10\n unless stack-checking is enabled, when R9 is used.\n \n+@item -mcirrus-fix-invalid-insns\n+@opindex -mcirrus-fix-invalid-insns\n+@opindex -mno-cirrus-fix-invalid-insns\n+Insert NOPs into the instruction stream to in order to work around\n+problems with invalid Maverick instruction combinations.  This option\n+is only valid if the @option{-mcpu=ep9312} option has been used to\n+enable generation of instructions for the Cirrus Maverick floating\n+point co-processor.  This option is not enabled by default, since the\n+problem is only present in older Maverick implemenations.  The default\n+can be re-enabled by use of the @option{-mno-cirrus-fix-invalid-insns}\n+switch.\n+\n @item -mpoke-function-name\n @opindex mpoke-function-name\n Write the name of each function into the text section, directly"}]}