{"sha": "0385f644b804f4b4192b497503d0403e087137b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM4NWY2NDRiODA0ZjRiNDE5MmI0OTc1MDNkMDQwM2UwODcxMzdiMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-08T02:11:29Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-08T02:11:29Z"}, "message": "tree-ssa-phiopt.c: Update copyright.\n\n\t* tree-ssa-phiopt.c: Update copyright.  Fix indentations.\n\tRemove trailing spaces.\n\nFrom-SVN: r96078", "tree": {"sha": "bedf2e3252c484dabab59a14f78e0bcb77b63a39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bedf2e3252c484dabab59a14f78e0bcb77b63a39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0385f644b804f4b4192b497503d0403e087137b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0385f644b804f4b4192b497503d0403e087137b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0385f644b804f4b4192b497503d0403e087137b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0385f644b804f4b4192b497503d0403e087137b1/comments", "author": null, "committer": null, "parents": [{"sha": "7c14c5fe40c5762fb100d10c8bd421b0752d327c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c14c5fe40c5762fb100d10c8bd421b0752d327c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c14c5fe40c5762fb100d10c8bd421b0752d327c"}], "stats": {"total": 149, "additions": 75, "deletions": 74}, "files": [{"sha": "4840a679ec3878029ce040757d8874844ec0ec35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0385f644b804f4b4192b497503d0403e087137b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0385f644b804f4b4192b497503d0403e087137b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0385f644b804f4b4192b497503d0403e087137b1", "patch": "@@ -1,3 +1,8 @@\n+2005-03-08  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-ssa-phiopt.c: Update copyright.  Fix indentations.\n+\tRemove trailing spaces.\n+\n 2005-03-07  Per Bothner  <per@bothner.com>\n \n \t* tree.h (DECL_IS_BUILTIN): Reverted my patch from earlier today."}, {"sha": "25babaecae41c65357b2dd27423ceba68bcbbbc3", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 70, "deletions": 74, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0385f644b804f4b4192b497503d0403e087137b1/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0385f644b804f4b4192b497503d0403e087137b1/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=0385f644b804f4b4192b497503d0403e087137b1", "patch": "@@ -1,18 +1,18 @@\n /* Optimization of PHI nodes by converting them into straightline code.\n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n \n This file is part of GCC.\n-   \n+\n GCC is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n Free Software Foundation; either version 2, or (at your option) any\n later version.\n-   \n+\n GCC is distributed in the hope that it will be useful, but WITHOUT\n ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n for more details.\n-   \n+\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n@@ -57,16 +57,16 @@ static void replace_phi_edge_with_variable (basic_block, basic_block, edge,\n       x = PHI (0 (bb1), 1 (bb0)\n \n    We can rewrite that as:\n-    \n+\n      bb0:\n      bb1:\n      bb2:\n       x = cond;\n \n    bb1 will become unreachable and bb0 and bb2 will almost always\n    be merged into a single block.  This occurs often due to gimplification\n-    of conditionals. \n-   \n+    of conditionals.\n+\n    Also done is the following optimization:\n \n      bb0:\n@@ -83,9 +83,9 @@ static void replace_phi_edge_with_variable (basic_block, basic_block, edge,\n       x = b;\n \n    This can sometimes occur as a result of other optimizations.  A\n-   similar transformation is done by the ifcvt RTL optimizer. \n+   similar transformation is done by the ifcvt RTL optimizer.\n \n-   This pass also eliminates PHI nodes which are really absolute \n+   This pass also eliminates PHI nodes which are really absolute\n    values.  i.e. if we have something like:\n \n      bb0:\n@@ -104,45 +104,45 @@ static void replace_phi_edge_with_variable (basic_block, basic_block, edge,\n \n    bb1 will become unreachable and bb0 and bb2 will almost always be merged\n    into a single block.  Similar transformations are done by the ifcvt\n-   RTL optimizer.  */ \n+   RTL optimizer.  */\n \n static void\n tree_ssa_phiopt (void)\n {\n   basic_block bb;\n   bool removed_phis = false;\n \n-  /* Search every basic block for COND_EXPR we may be able to optimize in reverse\n-     order so we can find more.  */\n+  /* Search every basic block for COND_EXPR we may be able to optimize\n+     in reverse order so we can find more.  */\n   FOR_EACH_BB_REVERSE (bb)\n     {\n       tree cond_expr;\n       tree phi;\n       basic_block bb1, bb2;\n       edge e1, e2;\n-      \n+\n       cond_expr = last_stmt (bb);\n-      /* Check to see if the last statement is a COND_EXPR */\n+      /* Check to see if the last statement is a COND_EXPR.  */\n       if (!cond_expr\n           || TREE_CODE (cond_expr) != COND_EXPR)\n         continue;\n-      \n+\n       e1 = EDGE_SUCC (bb, 0);\n       bb1 = e1->dest;\n       e2 = EDGE_SUCC (bb, 1);\n       bb2 = e2->dest;\n-      \n+\n       /* We cannot do the optimization on abnormal edges.  */\n       if ((e1->flags & EDGE_ABNORMAL) != 0\n           || (e2->flags & EDGE_ABNORMAL) != 0)\n        continue;\n-      \n+\n       /* If either bb1's succ or bb2 or bb2's succ is non NULL.  */\n       if (EDGE_COUNT (bb1->succs) < 1\n           || bb2 == NULL\n \t  || EDGE_COUNT (bb2->succs) < 1)\n         continue;\n-      \n+\n       /* Find the bb which is the fall through to the other.  */\n       if (EDGE_SUCC (bb1, 0)->dest == bb2)\n         ;\n@@ -157,19 +157,19 @@ tree_ssa_phiopt (void)\n \t}\n       else\n         continue;\n-      \n+\n       e1 = EDGE_SUCC (bb1, 0);\n-      \n+\n       /* Make sure that bb1 is just a fall through.  */\n       if (EDGE_COUNT (bb1->succs) > 1\n \t  || (e1->flags & EDGE_FALLTHRU) == 0)\n         continue;\n-\t\n-      /* Also make that bb1 only have one pred and it is bb. */\n+\n+      /* Also make that bb1 only have one pred and it is bb.  */\n       if (EDGE_COUNT (bb1->preds) > 1\n           || EDGE_PRED (bb1, 0)->src != bb)\n \tcontinue;\n-      \n+\n       phi = phi_nodes (bb2);\n \n       /* Check to make sure that there is only one PHI node.\n@@ -179,23 +179,23 @@ tree_ssa_phiopt (void)\n \t{\n \t  tree arg0 = NULL, arg1 = NULL;\n \t  int i;\n-\t  \n+\n \t  arg0 = PHI_ARG_DEF_TREE (phi, e1->dest_idx);\n \t  arg1 = PHI_ARG_DEF_TREE (phi, e2->dest_idx);\n-\t   \t  \n+\n \t  /* We know something is wrong if we cannot find the edges in the PHI\n \t     node.  */\n \t  gcc_assert (arg0 != NULL && arg1 != NULL);\n-\t    \n+\n \t  /* Do the replacement of conditional if it can be done.  */\n-\t    if (conditional_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1)\n-\t\t|| value_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1)\n-\t\t|| abs_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1))\n-\t      {\n-\t\t/* We have done the replacement so we need to rebuild the\n-\t\t   cfg when this pass is complete.  */\n-\t\tremoved_phis = true;\n-\t      }\n+\t  if (conditional_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1)\n+\t      || value_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1)\n+\t      || abs_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1))\n+\t    {\n+\t      /* We have done the replacement so we need to rebuild the\n+\t\t cfg when this pass is complete.  */\n+\t      removed_phis = true;\n+\t    }\n \t}\n     }\n }\n@@ -213,7 +213,7 @@ empty_block_p (basic_block bb)\n \t  && (TREE_CODE (bsi_stmt (bsi)) == LABEL_EXPR\n \t      || IS_EMPTY_STMT (bsi_stmt (bsi))))\n     bsi_next (&bsi);\n-  \n+\n   if (!bsi_end_p (bsi))\n     return false;\n \n@@ -232,7 +232,7 @@ replace_phi_edge_with_variable (basic_block cond_block, basic_block bb,\n   int i;\n   block_stmt_iterator bsi;\n \n-  /* Change the PHI argument to new. */\n+  /* Change the PHI argument to new.  */\n   PHI_ARG_DEF_TREE (phi, e->dest_idx) = new;\n \n   /* Remove the empty basic block.  */\n@@ -252,11 +252,11 @@ replace_phi_edge_with_variable (basic_block cond_block, basic_block bb,\n       block_to_remove = EDGE_SUCC (cond_block, 0)->dest;\n     }\n   delete_basic_block (block_to_remove);\n-  \n+\n   /* Eliminate the COND_EXPR at the end of COND_BLOCK.  */\n   bsi = bsi_last (cond_block);\n   bsi_remove (&bsi);\n-  \n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file,\n \t      \"COND_EXPR in block %d and PHI in block %d converted to straightline code.\\n\",\n@@ -290,10 +290,10 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n     ;\n   else\n     return false;\n-  \n+\n   if (!empty_block_p (middle_bb))\n     return false;\n-\t\t\t\t\t\t\t\t\t\t\n+\n   /* If the condition is not a naked SSA_NAME and its type does not\n      match the type of the result, then we have to create a new\n      variable to optimize this case as it would likely create\n@@ -308,51 +308,51 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n       old_result = cond;\n       cond = new_var;\n     }\n-  \n+\n   /* If the condition was a naked SSA_NAME and the type is not the\n      same as the type of the result, then convert the type of the\n      condition.  */\n   if (!lang_hooks.types_compatible_p (TREE_TYPE (cond), TREE_TYPE (result)))\n     cond = fold_convert (TREE_TYPE (result), cond);\n-  \n+\n   /* We need to know which is the true edge and which is the false\n      edge so that we know when to invert the condition below.  */\n   extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n-      \n+\n   /* Insert our new statement at the end of condtional block before the\n      COND_EXPR.  */\n   bsi = bsi_last (cond_bb);\n   bsi_insert_before (&bsi, build_empty_stmt (), BSI_NEW_STMT);\n-  \n+\n   if (old_result)\n     {\n       tree new1;\n       if (!COMPARISON_CLASS_P (old_result))\n \treturn false;\n-      \n+\n       new1 = build (TREE_CODE (old_result), TREE_TYPE (old_result),\n \t\t    TREE_OPERAND (old_result, 0),\n \t\t    TREE_OPERAND (old_result, 1));\n-      \n+\n       new1 = build (MODIFY_EXPR, TREE_TYPE (old_result), new_var, new1);\n       bsi_insert_after (&bsi, new1, BSI_NEW_STMT);\n     }\n-    \n+\n   new_var1 = duplicate_ssa_name (PHI_RESULT (phi), NULL);\n-  \n-  \n+\n+\n   /* At this point we know we have a COND_EXPR with two successors.\n      One successor is BB, the other successor is an empty block which\n      falls through into BB.\n-  \n+\n      There is a single PHI node at the join point (BB) and its arguments\n      are constants (0, 1).\n-  \n+\n      So, given the condition COND, and the two PHI arguments, we can\n-     rewrite this PHI into non-branching code: \n-  \n+     rewrite this PHI into non-branching code:\n+\n        dest = (COND) or dest = COND'\n-  \n+\n      We use the condition as-is if the argument associated with the\n      true edge has the value one or the argument associated with the\n      false edge as the value zero.  Note that those conditions are not\n@@ -368,14 +368,14 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n   else\n     {\n       tree cond1 = invert_truthvalue (cond);\n-      \n+\n       cond = cond1;\n       /* If what we get back is a conditional expression, there is no\n \t  way that it can be gimple.  */\n       if (TREE_CODE (cond) == COND_EXPR)\n \t{\n \t  release_ssa_name (new_var1);\n-\t  return false; \n+\t  return false;\n \t}\n \n       /* If what we get back is not gimple try to create it as gimple by\n@@ -389,7 +389,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n \t  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n \t  cond = fold_convert (TREE_TYPE (result), new_var_1);\n \t}\n-      \n+\n       if (TREE_CODE (cond) == TRUTH_NOT_EXPR\n \t  &&  !is_gimple_val (TREE_OPERAND (cond, 0)))\n \t{\n@@ -399,11 +399,11 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n \n       new = build (MODIFY_EXPR, TREE_TYPE (new_var1), new_var1, cond);\n     }\n-  \n+\n   bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n-  \n+\n   SSA_NAME_DEF_STMT (new_var1) = new;\n-  \n+\n   replace_phi_edge_with_variable (cond_bb, phi_bb, e1, phi, new_var1);\n \n   /* Note that we optimized this PHI.  */\n@@ -454,7 +454,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \n      We now need to verify that the two arguments in the PHI node match\n      the two arguments to the equality comparison.  */\n-  \n+\n   if ((operand_equal_for_phi_arg_p (arg0, TREE_OPERAND (cond, 0))\n        && operand_equal_for_phi_arg_p (arg1, TREE_OPERAND (cond, 1)))\n       || (operand_equal_for_phi_arg_p (arg1, TREE_OPERAND (cond, 0))\n@@ -498,8 +498,8 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \n static bool\n abs_replacement (basic_block cond_bb, basic_block middle_bb,\n-\t\t basic_block phi_bb, edge e0 ATTRIBUTE_UNUSED, edge e1, tree phi,\n-\t\t tree arg0, tree arg1)\n+\t\t basic_block phi_bb, edge e0 ATTRIBUTE_UNUSED, edge e1,\n+\t\t tree phi, tree arg0, tree arg1)\n {\n   tree result;\n   tree new, cond;\n@@ -601,14 +601,14 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n     e = true_edge;\n   else\n     e = false_edge;\n-  \n+\n   if (e->dest == middle_bb)\n     negate = true;\n   else\n     negate = false;\n-    \n+\n   result = duplicate_ssa_name (result, NULL);\n-  \n+\n   if (negate)\n     lhs = make_rename_temp (TREE_TYPE (result), NULL);\n   else\n@@ -623,17 +623,15 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   if (negate)\n     {\n-\n-      /* Get the right BSI.  We want to insert after the recently \n+      /* Get the right BSI.  We want to insert after the recently\n \t added ABS_EXPR statement (which we know is the first statement\n \t in the block.  */\n       new = build (MODIFY_EXPR, TREE_TYPE (result),\n                    result, build1 (NEGATE_EXPR, TREE_TYPE (lhs), lhs));\n \n       bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n-      \n     }\n-    \n+\n   SSA_NAME_DEF_STMT (result) = new;\n   replace_phi_edge_with_variable (cond_bb, phi_bb, e1, phi, result);\n \n@@ -643,13 +641,13 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n \n \n /* Always do these optimizations if we have SSA\n-   trees to work on.  */\t\t\t\t\t\t\n+   trees to work on.  */\n static bool\n gate_phiopt (void)\n {\n   return 1;\n }\n-\t\t\t\t\t\t\t\t\t\t\t\t\n+\n struct tree_opt_pass pass_phiopt =\n {\n   \"phiopt\",\t\t\t\t/* name */\n@@ -668,5 +666,3 @@ struct tree_opt_pass pass_phiopt =\n     | TODO_verify_flow | TODO_verify_stmts,\n   0\t\t\t\t\t/* letter */\n };\n-\t\t\t\t\t\t\t\t\t\t\t\t\n-"}]}