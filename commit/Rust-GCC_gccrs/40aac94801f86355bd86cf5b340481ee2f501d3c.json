{"sha": "40aac94801f86355bd86cf5b340481ee2f501d3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBhYWM5NDgwMWY4NjM1NWJkODZjZjViMzQwNDgxZWUyZjUwMWQzYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2004-08-28T02:33:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-08-28T02:33:54Z"}, "message": "re PR c++/13684 (local static object variable constructed once but ctors and dtors called multiple times on same memory when called in multiple threads)\n\n        PR c++/13684\n        * cp/decl.c (expand_static_init): Use thread-safety API.\n        (register_dtor_fn): Return the call, don't expand it.\n        * cp/tree.c (add_stmt_to_compound): New fn.\n        (stabilize_call): Use it.\n        * gimplify.c (gimplify_cleanup_point_expr): Handle CLEANUP_EH_ONLY.\n        (gimple_push_cleanup): Add eh_only parm.\n        (gimplify_target_expr): Pass it.\n        * c.opt (-fno-threadsafe-statics): New option.\n        * c-opts.c (c_common_handle_option): Handle it.\n        * c-common.h (flag_threadsafe_statics): Declare it.\n        * c-common.c (flag_threadsafe_statics): Record it.\n        * doc/invoke.texi: Document it.\n        * tsystem.h (_GNU_SOURCE): Define.\n        * gthr-posix.h (__gthread_recursive_mutex_t): New typedef.\n        (__GTHREAD_RECURSIVE_MUTEX_INIT): New macro.\n        (__GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION): New macro.\n        (__gthread_recursive_mutex_init_function): New fn.\n        (__gthread_recursive_mutex_lock): New fn.\n        (__gthread_recursive_mutex_trylock): New fn.\n        (__gthread_recursive_mutex_unlock): New fn.\n        * gthr-solaris.h, gthr-single.h, gthr-dce.h: Likewise.\n        * gthr-win32.h, gthr-vxworks.h: Likewise.\n        * gthr.h: Document.\n\n        * libsupc++/guard.cc (static_mutex): Internal class implementing a\n        recursive mutex which controls initialization of local statics.\n        (__gnu_cxx::recursive_init): New exception class.\n        (__cxa_guard_acquire): Deal with locking and recursion detection.\n        (acquire_1, __cxa_guard_abort, __cxa_guard_release): Likewise.\n\nFrom-SVN: r86687", "tree": {"sha": "1f0fd6ce16170d90ee5ebfcb5972ed7af5874607", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f0fd6ce16170d90ee5ebfcb5972ed7af5874607"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40aac94801f86355bd86cf5b340481ee2f501d3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40aac94801f86355bd86cf5b340481ee2f501d3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40aac94801f86355bd86cf5b340481ee2f501d3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40aac94801f86355bd86cf5b340481ee2f501d3c/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ed3479983db246f3126c12c441659ef6b8ed027e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3479983db246f3126c12c441659ef6b8ed027e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed3479983db246f3126c12c441659ef6b8ed027e"}], "stats": {"total": 709, "additions": 655, "deletions": 54}, "files": [{"sha": "74a6b13be1663eb0a22793c7956adf64feabb589", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -1,3 +1,26 @@\n+2004-08-27  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/13684\n+\t* gimplify.c (gimplify_cleanup_point_expr): Handle CLEANUP_EH_ONLY.\n+\t(gimple_push_cleanup): Add eh_only parm.\n+\t(gimplify_target_expr): Pass it.\n+\t* c.opt (-fno-threadsafe-statics): New option.\n+\t* c-opts.c (c_common_handle_option): Handle it.\n+\t* c-common.h (flag_threadsafe_statics): Declare it.\n+\t* c-common.c (flag_threadsafe_statics): Record it.\n+\t* doc/invoke.texi: Document it.\n+\t* tsystem.h (_GNU_SOURCE): Define.\n+\t* gthr-posix.h (__gthread_recursive_mutex_t): New typedef.\n+\t(__GTHREAD_RECURSIVE_MUTEX_INIT): New macro.\n+\t(__GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION): New macro.\n+\t(__gthread_recursive_mutex_init_function): New fn.\n+\t(__gthread_recursive_mutex_lock): New fn.\n+\t(__gthread_recursive_mutex_trylock): New fn.\n+\t(__gthread_recursive_mutex_unlock): New fn.\n+\t* gthr-solaris.h, gthr-single.h, gthr-dce.h: Likewise.\n+\t* gthr-win32.h, gthr-vxworks.h: Likewise.\n+\t* gthr.h: Document.\n+\n 2004-08-27  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.c (rs6000_override_options): Increase"}, {"sha": "bd8ea6c32c383fd0b67255944186d6f24c57c6da", "filename": "gcc/c-common.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -459,6 +459,11 @@ int flag_permissive;\n \n int flag_enforce_eh_specs = 1;\n \n+/* Nonzero means to generate thread-safe code for initializing local\n+   statics.  */\n+\n+int flag_threadsafe_statics = 1;\n+\n /* Nonzero means warn about implicit declarations.  */\n \n int warn_implicit = 1;"}, {"sha": "b2da85d8188540a3eebbe4e97acab6f42baa0c8d", "filename": "gcc/c-common.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -571,6 +571,11 @@ extern int flag_permissive;\n \n extern int flag_enforce_eh_specs;\n \n+/* Nonzero (the default) means to generate thread-safe code for\n+   initializing local statics.  */\n+\n+extern int flag_threadsafe_statics;\n+\n /* Nonzero means warn about implicit declarations.  */\n \n extern int warn_implicit;"}, {"sha": "31bbb48d9b05feda9d870ec2de0d97fbc254c899", "filename": "gcc/c-opts.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -773,6 +773,10 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n       flag_weak = value;\n       break;\n \n+    case OPT_fthreadsafe_statics:\n+      flag_threadsafe_statics = value;\n+      break;\n+\n     case OPT_fzero_link:\n       flag_zero_link = value;\n       break;"}, {"sha": "c93fe7e895a538716a6e82baa17d322d17ce71d7", "filename": "gcc/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -675,6 +675,10 @@ C++ ObjC++ Joined RejectNegative UInteger\n fthis-is-variable\n C++ ObjC++\n \n+fthreadsafe-statics\n+C++ ObjC++\n+-fno-threadsafe-statics\tDo not generate thread-safe code for initializing local statics.\n+\n funsigned-bitfields\n C ObjC C++ ObjC++\n When \\\"signed\\\" or \\\"unsigned\\\" is not given make the bitfield unsigned"}, {"sha": "6fb3cf8853d53c9ede00aa073be0a617a0aa1e36", "filename": "gcc/config/i386/gthr-win32.c", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fconfig%2Fi386%2Fgthr-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fconfig%2Fi386%2Fgthr-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgthr-win32.c?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -182,3 +182,73 @@ __gthr_win32_mutex_unlock (__gthread_mutex_t *mutex)\n   else\n     return 0;\n }\n+\n+void\n+__gthr_win32_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+{\n+  mutex->counter = -1;\n+  mutex->depth = 0;\n+  mutex->owner = 0;\n+  mutex->sema = CreateSemaphore (NULL, 0, 65535, NULL);\n+}\n+\n+int\n+__gthr_win32_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+{\n+  DWORD me = GetCurrentThreadId();\n+  if (InterlockedIncrement (&mutex->counter) == 0)\n+    {\n+      mutex->depth = 1;\n+      mutex->owner = me;\n+    }\n+  else if (mutex->owner == me)\n+    {\n+      InterlockedDecrement (&mx->lock_idx);\n+      ++(mutex->depth);\n+    }\n+  else if (WaitForSingleObject (mutex->sema, INFINITE) == WAIT_OBJECT_0)\n+    {\n+      mutex->depth = 1;\n+      mutex->owner = me;\n+    }\n+  else\n+    {\n+      /* WaitForSingleObject returns WAIT_FAILED, and we can only do\n+         some best-effort cleanup here.  */\n+      InterlockedDecrement (&mutex->counter);\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int\n+__gthr_win32_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+{\n+  DWORD me = GetCurrentThreadId();\n+  if (__GTHR_W32_InterlockedCompareExchange (&mutex->counter, 0, -1) < 0)\n+    {\n+      mutex->depth = 1;\n+      mutex->owner = me;\n+    }\n+  else if (mutex->owner == me)\n+    ++(mutex->depth);\n+  else\n+    return 1;\n+\n+  return 0;\n+}\n+\n+int\n+__gthr_win32_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+{\n+  --(mutex->depth);\n+  if (mutex->depth == 0)\n+    {\n+      mutex->owner = 0;\n+\n+      if (InterlockedDecrement (&mutex->counter) >= 0)\n+\treturn ReleaseSemaphore (mutex->sema, 1, NULL) ? 0 : 1;\n+    }\n+\n+  return 0;\n+}"}, {"sha": "f1cac07a80369d4ae3d028e79194597aa3d13e46", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -1,3 +1,11 @@\n+2004-08-27  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/13684\n+\t* decl.c (expand_static_init): Use thread-safety API.\n+\t(register_dtor_fn): Return the call, don't expand it.\n+\t* tree.c (add_stmt_to_compound): New fn.\n+\t(stabilize_call): Use it.\n+\n 2004-08-27  Richard Henderson  <rth@redhat.com>\n \n \t* cp-tree.def (OFFSETOF_EXPR): New."}, {"sha": "2eba7a316e422ffc7e9ed805bd41f78c90b1483e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -3801,7 +3801,7 @@ extern tree build_target_expr_with_type         (tree, tree);\n extern int local_variable_p                     (tree);\n extern int nonstatic_local_decl_p               (tree);\n extern tree declare_global_var                  (tree, tree);\n-extern void register_dtor_fn                    (tree);\n+extern tree register_dtor_fn                    (tree);\n extern tmpl_spec_kind current_tmpl_spec_kind    (int);\n extern tree cp_fname_init\t\t\t(const char *, tree *);\n extern tree builtin_function (const char *name, tree type,\n@@ -4198,6 +4198,7 @@ extern void lang_check_failed\t\t\t(const char *, int,\n extern tree stabilize_expr\t\t\t(tree, tree *);\n extern void stabilize_call\t\t\t(tree, tree *);\n extern bool stabilize_init\t\t\t(tree, tree *);\n+extern tree add_stmt_to_compound\t\t(tree, tree);\n extern tree cxx_maybe_build_cleanup\t\t(tree);\n extern void init_tree\t\t\t        (void);\n extern int pod_type_p\t\t\t\t(tree);"}, {"sha": "c746e336fbac8cfa59efeaf6733018038d2b5442", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 82, "deletions": 37, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -5081,7 +5081,7 @@ end_cleanup_fn (void)\n /* Generate code to handle the destruction of DECL, an object with\n    static storage duration.  */\n \n-void\n+tree\n register_dtor_fn (tree decl)\n {\n   tree cleanup;\n@@ -5090,7 +5090,7 @@ register_dtor_fn (tree decl)\n   tree fcall;\n \n   if (TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n-    return;\n+    return void_zero_node;\n \n   /* Call build_cleanup before we enter the anonymous function so that\n      any access checks will be done relative to the current scope,\n@@ -5129,7 +5129,7 @@ register_dtor_fn (tree decl)\n     }\n   else\n     args = tree_cons (NULL_TREE, cleanup, NULL_TREE);\n-  finish_expr_stmt (build_function_call (get_atexit_node (), args));\n+  return build_function_call (get_atexit_node (), args);\n }\n \n /* DECL is a VAR_DECL with static storage duration.  INIT, if present,\n@@ -5151,66 +5151,111 @@ expand_static_init (tree decl, tree init)\n   if (DECL_FUNCTION_SCOPE_P (decl))\n     {\n       /* Emit code to perform this initialization but once.  */\n-      tree if_stmt;\n-      tree then_clause;\n-      tree assignment;\n-      tree guard;\n-      tree guard_init;\n+      tree if_stmt, inner_if_stmt;\n+      tree then_clause, inner_then_clause;\n+      tree guard, guard_addr, guard_addr_list;\n+      tree acquire_fn, release_fn, abort_fn;\n+      tree flag, begin;\n \n       /* Emit code to perform this initialization but once.  This code\n \t looks like:\n \n-           static int guard = 0;\n-           if (!guard) {\n-             // Do initialization.\n-\t     guard = 1;\n-\t     // Register variable for destruction at end of program.\n+           static <type> guard;\n+           if (!guard.first_byte) {\n+\t     if (__cxa_guard_acquire (&guard)) {\n+\t       bool flag = false;\n+\t       try {\n+\t         // Do initialization.\n+\t         flag = true; __cxa_guard_release (&guard);\n+\t         // Register variable for destruction at end of program.\n+\t       } catch {\n+\t         if (!flag) __cxa_guard_abort (&guard);\n+\t       }\n \t   }\n \n-\t Note that the `temp' variable is only set to 1 *after* the\n+\t Note that the `flag' variable is only set to 1 *after* the\n \t initialization is complete.  This ensures that an exception,\n \t thrown during the construction, will cause the variable to\n \t reinitialized when we pass through this code again, as per:\n \n \t   [stmt.dcl]\n \n-\t   If the initialization exits by throwing an exception, the\n+\t   If the initialization exits by throwing an exception, the  \n \t   initialization is not complete, so it will be tried again\n \t   the next time control enters the declaration.\n \n-         In theory, this process should be thread-safe, too; multiple\n-\t threads should not be able to initialize the variable more\n-\t than once.  We don't yet attempt to ensure thread-safety.  */\n+         This process should be thread-safe, too; multiple threads\n+\t should not be able to initialize the variable more than\n+\t once.  */\n \n       /* Create the guard variable.  */\n       guard = get_guard (decl);\n \n       /* Begin the conditional initialization.  */\n       if_stmt = begin_if_stmt ();\n       finish_if_stmt_cond (get_guard_cond (guard), if_stmt);\n-      then_clause = begin_compound_stmt (0);\n-\n-      /* Do the initialization itself.  */\n-      assignment = init ? init : NULL_TREE;\n-\n-      /* Once the assignment is complete, set TEMP to 1.  Since the\n-\t construction of the static object is complete at this point,\n-\t we want to make sure TEMP is set to 1 even if a temporary\n-\t constructed during the initialization throws an exception\n-\t when it is destroyed.  So, we combine the initialization and\n-\t the assignment to TEMP into a single expression, ensuring\n-\t that when we call finish_expr_stmt the cleanups will not be\n-\t run until after TEMP is set to 1.  */\n-      guard_init = set_guard (guard);\n-      if (assignment)\n-\tassignment = build_compound_expr (assignment, guard_init);\n+      then_clause = begin_compound_stmt (BCS_NO_SCOPE);\n+\n+      if (flag_threadsafe_statics)\n+\t{\n+\t  guard_addr = build_address (guard);\n+\t  guard_addr_list = build_tree_list (NULL_TREE, guard_addr);\n+\n+\t  acquire_fn = get_identifier (\"__cxa_guard_acquire\");\n+\t  release_fn = get_identifier (\"__cxa_guard_release\");\n+\t  abort_fn = get_identifier (\"__cxa_guard_abort\");\n+\t  if (!get_global_value_if_present (acquire_fn, &acquire_fn))\n+\t    {\n+\t      tree argtypes = tree_cons (NULL_TREE, TREE_TYPE (guard_addr),\n+\t\t\t\t\t void_list_node);\n+\t      tree vfntype = build_function_type (void_type_node, argtypes);\n+\t      acquire_fn = push_library_fn\n+\t\t(acquire_fn, build_function_type (integer_type_node, argtypes));\n+\t      release_fn = push_library_fn (release_fn, vfntype);\n+\t      abort_fn = push_library_fn (abort_fn, vfntype);\n+\t    }\n+\t  else\n+\t    {\n+\t      release_fn = identifier_global_value (release_fn);\n+\t      abort_fn = identifier_global_value (abort_fn);\n+\t    }\n+\n+\t  inner_if_stmt = begin_if_stmt ();\n+\t  finish_if_stmt_cond (build_call (acquire_fn, guard_addr_list),\n+\t\t\t       inner_if_stmt);\n+\n+\t  inner_then_clause = begin_compound_stmt (BCS_NO_SCOPE);\n+\t  begin = get_target_expr (boolean_false_node);\n+\t  flag = TARGET_EXPR_SLOT (begin);\n+\n+\t  TARGET_EXPR_CLEANUP (begin)\n+\t    = build (COND_EXPR, void_type_node, flag,\n+\t\t     void_zero_node,\n+\t\t     build_call (abort_fn, guard_addr_list));\n+\t  CLEANUP_EH_ONLY (begin) = 1;\n+\n+\t  /* Do the initialization itself.  */\n+\t  init = add_stmt_to_compound (begin, init);\n+\t  init = add_stmt_to_compound\n+\t    (init, build (MODIFY_EXPR, void_type_node, flag, boolean_true_node));\n+\t  init = add_stmt_to_compound\n+\t    (init, build_call (release_fn, guard_addr_list));\n+\t}\n       else\n-\tassignment = guard_init;\n-      finish_expr_stmt (assignment);\n+\tinit = add_stmt_to_compound (init, set_guard (guard));\n \n       /* Use atexit to register a function for destroying this static\n \t variable.  */\n-      register_dtor_fn (decl);\n+      init = add_stmt_to_compound (init, register_dtor_fn (decl));\n+\n+      finish_expr_stmt (init);\n+\n+      if (flag_threadsafe_statics)\n+\t{\n+\t  finish_compound_stmt (inner_then_clause);\n+\t  finish_then_clause (inner_if_stmt);\n+\t  finish_if_stmt (inner_if_stmt);\n+\t}\n \n       finish_compound_stmt (then_clause);\n       finish_then_clause (if_stmt);"}, {"sha": "2d852f71481002da1a30707200ac919b12bc3dfe", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -2446,7 +2446,7 @@ do_static_initialization (tree decl, tree init)\n   /* If we're using __cxa_atexit, register a a function that calls the\n      destructor for the object.  */\n   if (flag_use_cxa_atexit)\n-    register_dtor_fn (decl);\n+    finish_expr_stmt (register_dtor_fn (decl));\n \n   /* Finish up.  */\n   finish_static_initialization_or_destruction (guard_if_stmt);"}, {"sha": "99334678a7c252ad44aa207742d485480f751189", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -2254,6 +2254,19 @@ stabilize_expr (tree exp, tree* initp)\n   return exp;\n }\n \n+/* Add NEW, an expression whose value we don't care about, after the\n+   similar expression ORIG.  */\n+\n+tree\n+add_stmt_to_compound (tree orig, tree new)\n+{\n+  if (!new || !TREE_SIDE_EFFECTS (new))\n+    return orig;\n+  if (!orig || !TREE_SIDE_EFFECTS (orig))\n+    return new;\n+  return build2 (COMPOUND_EXPR, void_type_node, orig, new);\n+}\n+\n /* Like stabilize_expr, but for a call whose args we want to\n    pre-evaluate.  */\n \n@@ -2275,12 +2288,7 @@ stabilize_call (tree call, tree *initp)\n       {\n \ttree init;\n \tTREE_VALUE (t) = stabilize_expr (TREE_VALUE (t), &init);\n-\tif (!init)\n-\t  /* Nothing.  */;\n-\telse if (inits)\n-\t  inits = build2 (COMPOUND_EXPR, void_type_node, inits, init);\n-\telse\n-\t  inits = init;\n+\tinits = add_stmt_to_compound (inits, init);\n       }\n \n   *initp = inits;"}, {"sha": "e5e176f4dfda9be42df5af37cd7ef949b54d625f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -182,7 +182,7 @@ in the following sections.\n -fno-nonansi-builtins  -fno-operator-names @gol\n -fno-optional-diags  -fpermissive @gol\n -frepo  -fno-rtti  -fstats  -ftemplate-depth-@var{n} @gol\n--fuse-cxa-atexit  -fno-weak  -nostdinc++ @gol\n+-fno-threadsafe-statics -fuse-cxa-atexit  -fno-weak  -nostdinc++ @gol\n -fno-default-inline  -fvisibility-inlines-hidden @gol\n -Wabi  -Wctor-dtor-privacy @gol\n -Wnon-virtual-dtor  -Wreorder @gol\n@@ -1470,6 +1470,13 @@ A limit on the template instantiation depth is needed to detect\n endless recursions during template class instantiation.  ANSI/ISO C++\n conforming programs must not rely on a maximum depth greater than 17.\n \n+@item -fno-threadsafe-statics\n+@opindex fno-threadsafe-statics\n+Do not emit the extra code to use the routines specified in the C++\n+ABI for thread-safe initialization of local statics.  You can use this\n+option to reduce code size slightly in code that doesn't need to be\n+thread-safe.\n+\n @item -fuse-cxa-atexit\n @opindex fuse-cxa-atexit\n Register destructors for objects with static storage duration with the"}, {"sha": "2de6cf6e091ee9defa7e23918f28e80f7b2ad36c", "filename": "gcc/gimplify.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -3271,9 +3271,15 @@ gimplify_cleanup_point_expr (tree *expr_p, tree *pre_p)\n \t  else\n \t    {\n \t      tree sl, tfe;\n+\t      enum tree_code code;\n+\n+\t      if (CLEANUP_EH_ONLY (wce))\n+\t\tcode = TRY_CATCH_EXPR;\n+\t      else\n+\t\tcode = TRY_FINALLY_EXPR;\n \n \t      sl = tsi_split_statement_list_after (&iter);\n-\t      tfe = build (TRY_FINALLY_EXPR, void_type_node, sl, NULL_TREE);\n+\t      tfe = build (code, void_type_node, sl, NULL_TREE);\n \t      append_to_statement_list (TREE_OPERAND (wce, 0),\n \t\t\t\t        &TREE_OPERAND (tfe, 1));\n \t      *wce_p = tfe;\n@@ -3301,7 +3307,7 @@ gimplify_cleanup_point_expr (tree *expr_p, tree *pre_p)\n    is the cleanup action required.  */\n \n static void\n-gimple_push_cleanup (tree var, tree cleanup, tree *pre_p)\n+gimple_push_cleanup (tree var, tree cleanup, bool eh_only, tree *pre_p)\n {\n   tree wce;\n \n@@ -3352,6 +3358,7 @@ gimple_push_cleanup (tree var, tree cleanup, tree *pre_p)\n   else\n     {\n       wce = build (WITH_CLEANUP_EXPR, void_type_node, cleanup);\n+      CLEANUP_EH_ONLY (wce) = eh_only;\n       append_to_statement_list (wce, pre_p);\n     }\n \n@@ -3399,7 +3406,8 @@ gimplify_target_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       if (TARGET_EXPR_CLEANUP (targ))\n \t{\n \t  gimplify_stmt (&TARGET_EXPR_CLEANUP (targ));\n-\t  gimple_push_cleanup (temp, TARGET_EXPR_CLEANUP (targ), pre_p);\n+\t  gimple_push_cleanup (temp, TARGET_EXPR_CLEANUP (targ),\n+\t\t\t       CLEANUP_EH_ONLY (targ), pre_p);\n \t}\n \n       /* Only expand this once.  */"}, {"sha": "ccdf82dead8f3ef4cb9f8b73e28c3ed07a9c044b", "filename": "gcc/gthr-dce.h", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr-dce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr-dce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-dce.h?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -1,4 +1,4 @@\n-\n+/* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n /* Copyright (C) 1997, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n@@ -52,10 +52,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n typedef pthread_key_t __gthread_key_t;\n typedef pthread_once_t __gthread_once_t;\n typedef pthread_mutex_t __gthread_mutex_t;\n+typedef pthread_mutex_t __gthread_recursive_mutex_t;\n \n #define __GTHREAD_ONCE_INIT pthread_once_init\n \n #define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n+#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n \n #define __GTHREAD_MUTEX_INIT_DEFAULT pthread_once_init\n \n@@ -481,6 +483,43 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n     return 0;\n }\n \n+static inline int\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      pthread_mutexattr_t attr;\n+      int r;\n+\n+      r = pthread_mutexattr_create (&attr);\n+      if (!r)\n+\tr = pthread_mutexattr_setkind_np (&attr, MUTEX_RECURSIVE_NP);\n+      if (!r)\n+\tr = pthread_mutex_init (mutex, attr);\n+      if (!r)\n+\tr = pthread_mutexattr_delete (&attr);\n+      return r;\n+    }\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_lock (mutex);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_trylock (mutex);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_unlock (mutex);\n+}\n+\n #endif /* _LIBOBJC */\n \n #undef UNUSED"}, {"sha": "91204104658c3c5ab764cf3cee7a9094387f90ce", "filename": "gcc/gthr-posix.h", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.h?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -46,9 +46,17 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n typedef pthread_key_t __gthread_key_t;\n typedef pthread_once_t __gthread_once_t;\n typedef pthread_mutex_t __gthread_mutex_t;\n+typedef pthread_mutex_t __gthread_recursive_mutex_t;\n \n #define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER\n #define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT\n+#if defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER)\n+#define __GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER\n+#elif defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)\n+#define __GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\n+#else\n+#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n+#endif\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n \n@@ -516,6 +524,45 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n     return 0;\n }\n \n+#ifndef PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\n+static inline int\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      pthread_mutexattr_t attr;\n+      int r;\n+\n+      r = pthread_mutexattr_init (&attr);\n+      if (!r)\n+\tr = pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);\n+      if (!r)\n+\tr = pthread_mutex_init (mutex, &attr);\n+      if (!r)\n+\tr = pthread_mutexattr_destroy (&attr);\n+      return r;\n+    }\n+}\n+#endif\n+\n+static inline int\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_lock (mutex);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_trylock (mutex);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_unlock (mutex);\n+}\n+\n #endif /* _LIBOBJC */\n \n #endif /* ! GCC_GTHR_POSIX_H */"}, {"sha": "d42ee15becc2bb4752f9a4c425af8cf3fe95e926", "filename": "gcc/gthr-single.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr-single.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr-single.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-single.h?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -32,6 +32,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Just provide compatibility for mutex handling.  */\n \n typedef int __gthread_mutex_t;\n+typedef int __gthread_recursive_mutex_t;\n \n #define __GTHREAD_MUTEX_INIT 0\n \n@@ -232,6 +233,24 @@ __gthread_mutex_unlock (__gthread_mutex_t * UNUSED(mutex))\n   return 0;\n }\n \n+static inline int\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_lock (mutex);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_trylock (mutex);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_unlock (mutex);\n+}\n+\n #endif /* _LIBOBJC */\n \n #undef UNUSED"}, {"sha": "b44a4de26bf52dc011fb7f78a379227e49a7f60b", "filename": "gcc/gthr-solaris.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr-solaris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr-solaris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-solaris.h?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -44,9 +44,11 @@ typedef struct {\n   int once;\n } __gthread_once_t;\n typedef mutex_t __gthread_mutex_t;\n+typedef mutex_t __gthread_recursive_mutex_t;\n \n #define __GTHREAD_ONCE_INIT { DEFAULTMUTEX, 0 }\n #define __GTHREAD_MUTEX_INIT DEFAULTMUTEX\n+#define __GTHREAD_RECURSIVE_MUTEX_INIT RECURSIVE_ERRORCHECKMUTEX\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n \n@@ -466,6 +468,24 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n     return 0;\n }\n \n+static inline int\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_lock (mutex);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_trylock (mutex);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_unlock (mutex);\n+}\n+\n #endif /* _LIBOBJC */\n \n #endif /* ! GCC_GTHR_SOLARIS_H */"}, {"sha": "0f3ad23412ad6c81e8cad6fc3859c55883c38e9d", "filename": "gcc/gthr-vxworks.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr-vxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr-vxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-vxworks.h?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -45,7 +45,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include <semLib.h>\n \n typedef SEM_ID __gthread_mutex_t;\n+/* All VxWorks mutexes are recursive.  */\n+typedef SEM_ID __gthread_recursive_mutex_t;\n #define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n+#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n \n static inline void\n __gthread_mutex_init_function (__gthread_mutex_t *mutex)\n@@ -71,6 +74,30 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n   return semGive (*mutex);\n }\n \n+static inline void\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+{\n+  __gthread_mutex_init_function (mutex);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_lock (mutex);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_trylock (mutex);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_mutex_unlock (mutex);\n+}\n+\n /* pthread_once is complicated enough that it's implemented\n    out-of-line.  See config/vxlib.c.  */\n "}, {"sha": "3e1aac7fce093930e3ad64dc36e8c47caeb25b12", "filename": "gcc/gthr-win32.h", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr-win32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr-win32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-win32.h?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -343,9 +343,18 @@ typedef struct {\n   void *sema;\n } __gthread_mutex_t;\n \n+typedef struct {\n+  long counter;\n+  long depth;\n+  DWORD owner;\n+  void *sema;\n+} __gthread_recursive_mutex_t;\n+\n #define __GTHREAD_ONCE_INIT {0, -1}\n #define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n #define __GTHREAD_MUTEX_INIT_DEFAULT {-1, 0}\n+#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n+#define __GTHREAD_RECURSIVE_MUTEX_INIT_DEFAULT {-1, 0}\n \n #if __MINGW32_MAJOR_VERSION >= 1 || \\\n   (__MINGW32_MAJOR_VERSION == 0 && __MINGW32_MINOR_VERSION > 2)\n@@ -472,6 +481,33 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n     return 0;\n }\n \n+static inline int\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    return __gthr_win32_recursive_mutex_lock (mutex);\n+  else\n+    return 0;\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    return __gthr_win32_recursive_mutex_trylock (mutex);\n+  else\n+    return 0;\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    return __gthr_win32_recursive_mutex_unlock (mutex);\n+  else\n+    return 0;\n+}\n+\n #else /* ! __GTHREAD_HIDE_WIN32API */\n \n #include <windows.h>\n@@ -610,6 +646,83 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n   return 0;\n }\n \n+static inline void\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+{\n+  mutex->counter = -1;\n+  mutex->depth = 0;\n+  mutex->owner = 0;\n+  mutex->sema = CreateSemaphore (NULL, 0, 65535, NULL);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      DWORD me = GetCurrentThreadId();\n+      if (InterlockedIncrement (&mutex->counter) == 0)\n+\t{\n+\t  mutex->depth = 1;\n+\t  mutex->owner = me;\n+\t}\n+      else if (mutex->owner == me)\n+\t{\n+\t  InterlockedDecrement (&mx->lock_idx);\n+\t  ++(mutex->depth);\n+\t}\n+      else if (WaitForSingleObject (mutex->sema, INFINITE) == WAIT_OBJECT_0)\n+\t{\n+\t  mutex->depth = 1;\n+\t  mutex->owner = me;\n+\t}\n+      else\n+\t{\n+\t  /* WaitForSingleObject returns WAIT_FAILED, and we can only do\n+\t     some best-effort cleanup here.  */\n+\t  InterlockedDecrement (&mutex->counter);\n+\t  return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      DWORD me = GetCurrentThreadId();\n+      if (__GTHR_W32_InterlockedCompareExchange (&mutex->counter, 0, -1) < 0)\n+\t{\n+\t  mutex->depth = 1;\n+\t  mutex->owner = me;\n+\t}\n+      else if (mutex->owner == me)\n+\t++(mutex->depth);\n+      else\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      --(mutex->depth);\n+      if (mutex->depth == 0)\n+\t{\n+\t  mutex->owner = 0;\n+\n+\t  if (InterlockedDecrement (&mutex->counter) >= 0)\n+\t    return ReleaseSemaphore (mutex->sema, 1, NULL) ? 0 : 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n #endif /*  __GTHREAD_HIDE_WIN32API */\n \n #ifdef __cplusplus"}, {"sha": "42f4d1a4d3ad10d35d425d752a1aae5ef89c15c1", "filename": "gcc/gthr.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Fgthr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr.h?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -42,6 +42,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n      __gthread_key_t\n      __gthread_once_t\n      __gthread_mutex_t\n+     __gthread_recursive_mutex_t\n \n    The threads interface must define the following macros:\n \n@@ -56,6 +57,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t\tfunction which looks like this:\n \t\t  void __GTHREAD_MUTEX_INIT_FUNCTION (__gthread_mutex_t *)\n \t\tDon't define __GTHREAD_MUTEX_INIT in this case\n+     __GTHREAD_RECURSIVE_MUTEX_INIT\n+     __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION\n+     \t\tas above, but for a recursive mutex.\n \n    The threads interface must define the following static functions:\n \n@@ -71,6 +75,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n      int __gthread_mutex_trylock (__gthread_mutex_t *mutex);\n      int __gthread_mutex_unlock (__gthread_mutex_t *mutex);\n \n+     int __gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex);\n+     int __gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex);\n+     int __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex);\n+\n    All functions returning int should return zero on success or the error\n    number.  If the operation is not supported, -1 is returned.\n "}, {"sha": "d7f1ebc9a5ccc063d8f7305808da4b1d1f350147", "filename": "gcc/tsystem.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Ftsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/gcc%2Ftsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsystem.h?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -40,6 +40,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define HAVE_DECL_GETOPT 1\n #endif\n \n+/* We want everything from the glibc headers.  */\n+#define _GNU_SOURCE 1\n+\n /* GCC supplies these headers.  */\n #include <stddef.h>\n #include <float.h>"}, {"sha": "c77647b7e6a9b6b0e1f856c152aaf6a4b10a4a61", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -1,3 +1,12 @@\n+2004-08-27  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/13684\n+\t* libsupc++/guard.cc (static_mutex): Internal class implementing a\n+\trecursive mutex which controls initialization of local statics.\n+\t(__gnu_cxx::recursive_init): New exception class.\n+\t(__cxa_guard_acquire): Deal with locking and recursion detection.\n+\t(acquire_1, __cxa_guard_abort, __cxa_guard_release): Likewise.\n+\n 2004-08-27  Matthias Klose  <doko@debian.org>\n \n \t* configure.host: For mips*-*-linux* update cpu_include_dir"}, {"sha": "a9280bccdc54c548ef915b2aefe7e8f11346b6c7", "filename": "libstdc++-v3/libsupc++/guard.cc", "status": "modified", "additions": 132, "deletions": 4, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aac94801f86355bd86cf5b340481ee2f501d3c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aac94801f86355bd86cf5b340481ee2f501d3c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc?ref=40aac94801f86355bd86cf5b340481ee2f501d3c", "patch": "@@ -29,26 +29,154 @@\n // Written by Mark Mitchell, CodeSourcery LLC, <mark@codesourcery.com>\n \n #include <cxxabi.h>\n+#include <exception>\n+#include <bits/c++config.h>\n+#include <bits/gthr.h>\n \n // The IA64/generic ABI uses the first byte of the guard variable.\n // The ARM EABI uses the least significant bit.\n \n+// Thread-safe static local initialization support.\n+#ifdef __GTHREADS\n+namespace\n+{\n+  // static_mutex is a single mutex controlling all static initializations.\n+  // This is a static class--the need for a static initialization function\n+  // to pass to __gthread_once precludes creating multiple instances, though\n+  // I suppose you could achieve the same effect with a template.\n+  class static_mutex\n+  {\n+    static __gthread_recursive_mutex_t mutex;\n+\n+#ifdef __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION\n+    static void init();\n+#endif\n+\n+  public:\n+    static void lock();\n+    static void unlock();\n+  };\n+\n+  __gthread_recursive_mutex_t static_mutex::mutex\n+#ifdef __GTHREAD_RECURSIVE_MUTEX_INIT\n+  = __GTHREAD_RECURSIVE_MUTEX_INIT\n+#endif\n+  ;\n+\n+#ifdef __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION\n+  void static_mutex::init()\n+  {\n+    __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION (&mutex);\n+  }\n+#endif\n+\n+  void static_mutex::lock()\n+  {\n+#ifdef __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION\n+    static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+    __gthread_once (&once, init);\n+#endif\n+    __gthread_recursive_mutex_lock (&mutex);\n+  }\n+\n+  void static_mutex::unlock ()\n+  {\n+    __gthread_recursive_mutex_unlock (&mutex);\n+  }\n+}\n+#endif\n+\n+namespace __gnu_cxx\n+{\n+  // 6.7[stmt.dcl]/4: If control re-enters the declaration (recursively)\n+  // while the object is being initialized, the behavior is undefined.\n+\n+  // Since we already have a library function to handle locking, we might\n+  // as well check for this situation and throw an exception.\n+  // We use the second byte of the guard variable to remember that we're\n+  // in the middle of an initialization.\n+  class recursive_init: public std::exception\n+  {\n+  public:\n+    recursive_init() throw() { }\n+    virtual ~recursive_init() throw ();\n+  };\n+\n+  recursive_init::~recursive_init() throw() { }\n+}\n+\n namespace __cxxabiv1 \n {\n+  static int\n+  acquire_1 (__guard *g)\n+  {\n+    if (_GLIBCXX_GUARD_ACQUIRE (g))\n+      {\n+\tif (((char *)g)[1]++)\n+\t  {\n+#ifdef __EXCEPTIONS\n+\t    throw __gnu_cxx::recursive_init();\n+#else\n+\t    abort ();\n+#endif\n+\t  }\n+\treturn 1;\n+      }\n+    return 0;\n+  }\n+  \n   extern \"C\"\n   int __cxa_guard_acquire (__guard *g) \n   {\n-    return _GLIBCXX_GUARD_ACQUIRE (g);\n+#ifdef __GTHREADS\n+    if (__gthread_active_p ())\n+      {\n+\t// Simple wrapper for exception safety.\n+\tstruct mutex_wrapper\n+\t{\n+\t  bool unlock;\n+\t  mutex_wrapper (): unlock(true)\n+\t  {\n+\t    static_mutex::lock ();\n+\t  }\n+\t  ~mutex_wrapper ()\n+\t  {\n+\t    if (unlock)\n+\t      static_mutex::unlock ();\n+\t  }\n+\t} mw;\n+\n+\tif (acquire_1 (g))\n+\t  {\n+\t    mw.unlock = false;\n+\t    return 1;\n+\t  }\n+\n+\treturn 0;\n+      }\n+#endif\n+\n+    return acquire_1 (g);\n   }\n \n   extern \"C\"\n-  void __cxa_guard_release (__guard *g)\n+  void __cxa_guard_abort (__guard *g)\n   {\n-    _GLIBCXX_GUARD_RELEASE (g);\n+    ((char *)g)[1]--;\n+#ifdef __GTHREADS\n+    if (__gthread_active_p ())\n+      static_mutex::unlock ();\n+#endif\n   }\n \n   extern \"C\"\n-  void __cxa_guard_abort (__guard *)\n+  void __cxa_guard_release (__guard *g)\n   {\n+    ((char *)g)[1]--;\n+    _GLIBCXX_GUARD_RELEASE (g);\n+#ifdef __GTHREADS\n+    if (__gthread_active_p ())\n+      static_mutex::unlock ();\n+#endif\n   }\n }"}]}