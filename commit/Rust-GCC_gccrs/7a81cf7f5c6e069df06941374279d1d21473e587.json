{"sha": "7a81cf7f5c6e069df06941374279d1d21473e587", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E4MWNmN2Y1YzZlMDY5ZGYwNjk0MTM3NDI3OWQxZDIxNDczZTU4Nw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-05-21T15:41:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-05-21T15:41:05Z"}, "message": "add vague linkage node\n\nFrom-SVN: r42389", "tree": {"sha": "641dee74fdd323578650129d83f16691c1f92a70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/641dee74fdd323578650129d83f16691c1f92a70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a81cf7f5c6e069df06941374279d1d21473e587", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a81cf7f5c6e069df06941374279d1d21473e587", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a81cf7f5c6e069df06941374279d1d21473e587", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a81cf7f5c6e069df06941374279d1d21473e587/comments", "author": null, "committer": null, "parents": [{"sha": "1a6025b4b81a386b54678f8641fbb00b144e6ddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6025b4b81a386b54678f8641fbb00b144e6ddf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a6025b4b81a386b54678f8641fbb00b144e6ddf"}], "stats": {"total": 95, "additions": 78, "deletions": 17}, "files": [{"sha": "0d96b25555b68c424a2f74678d55f7239e20ec57", "filename": "gcc/extend.texi", "status": "modified", "additions": 78, "deletions": 17, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a81cf7f5c6e069df06941374279d1d21473e587/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a81cf7f5c6e069df06941374279d1d21473e587/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=7a81cf7f5c6e069df06941374279d1d21473e587", "patch": "@@ -3876,6 +3876,7 @@ Predefined Macros,cpp.info,The C Preprocessor}).\n * Min and Max::\t\tC++ Minimum and maximum operators.\n * Volatiles::\t\tWhat constitutes an access to a volatile object.\n * Restricted Pointers:: C99 restricted pointers and references.\n+* Vague Linkage::       Where G++ puts inlines, vtables and such.\n * C++ Interface::       You can use a single C++ header file for both\n                         declarations and definitions.\n * Template Instantiation:: Methods for ensuring that exactly one copy of\n@@ -4063,6 +4064,83 @@ ignored in function definition matching. This means you only need to\n specify @code{__restrict__} in a function definition, rather than\n in a function prototype as well.\n \n+@node Vague Linkage\n+@section Vague Linkage\n+@cindex vague linkage\n+\n+There are several constructs in C++ which require space in the object\n+file but are not clearly tied to a single translation unit.  We say that\n+these constructs have ``vague linkage''.  Typically such constructs are\n+emitted wherever they are needed, though sometimes we can be more\n+clever.\n+\n+@table @asis\n+@item Inline Functions\n+Inline functions are typically defined in a header file which can be\n+included in many different compilations.  Hopefully they can usually be\n+inlined, but sometimes an out-of-line copy is necessary, if the address\n+of the function is taken or if inlining fails.  In general, we emit an\n+out-of-line copy in all translation units where one is needed.  As an\n+exception, we only emit inline virtual functions with the vtable, since\n+it will always require a copy.\n+\n+Local static variables and string constants used in an inline function\n+are also considered to have vague linkage, since they must be shared\n+between all inlined and out-of-line instances of the function.\n+\n+@item VTables\n+@cindex vtable\n+C++ virtual functions are implemented in most compilers using a lookup\n+table, known as a vtable.  The vtable contains pointers to the virtual\n+functions provided by a class, and each object of the class contains a\n+pointer to its vtable (or vtables, in some multiple-inheritance\n+situations).  If the class declares any non-inline, non-pure virtual\n+functions, the first one is chosen as the ``key method'' for the class,\n+and the vtable is only emitted in the translation unit where the key\n+method is defined.\n+\n+@emph{Note:} If the chosen key method is later defined as inline, the\n+vtable will still be emitted in every translation unit which defines it.\n+Make sure that any inline virtuals are declared inline in the class\n+body, even if they are not defined there.\n+\n+@item type_info objects\n+@cindex type_info\n+@cindex RTTI\n+C++ requires information about types to be written out in order to\n+implement @samp{dynamic_cast}, @samp{typeid} and exception handling.\n+For polymorphic classes (classes with virtual functions), the type_info\n+object is written out along with the vtable so that @samp{dynamic_cast}\n+can determine the dynamic type of a class object at runtime.  For all\n+other types, we write out the type_info object when it is used: when\n+applying @samp{typeid} to an expression, throwing an object, or\n+referring to a type in a catch clause or exception specification.\n+\n+@item Template Instantiations\n+Most everything in this section also applies to template instantiations,\n+but there are other options as well.\n+@xref{Template Instantiation,,Where's the Template?}.\n+\n+@end table\n+\n+When used with GNU ld version 2.8 or later on an ELF system such as\n+Linux/GNU or Solaris 2, or on Microsoft Windows, duplicate copies of\n+these constructs will be discarded at link time.  This is known as\n+COMDAT support.\n+\n+On targets that don't support COMDAT, but do support weak symbols, GCC\n+will use them.  This way one copy will override all the others, but\n+the unused copies will still take up space in the executable.\n+\n+For targets which do not support either COMDAT or weak symbols,\n+most entities with vague linkage will be emitted as local symbols to\n+avoid duplicate definition errors from the linker.  This will not happen\n+for local statics in inlines, however, as having multiple copies will\n+almost certainly break things.\n+\n+@xref{C++ Interface,,Declarations and Definitions in One Header}, for\n+another way to control placement of these constructs.\n+\n @node C++ Interface\n @section Declarations and Definitions in One Header\n \n@@ -4426,23 +4504,6 @@ Some_Class  B  __attribute__ ((init_priority (543)));\n Note that the particular values of @var{priority} do not matter; only their\n relative ordering.\n \n-\n-@item com_interface\n-@cindex com_interface attribute\n-\n-@c This is based on:  1) grepping the code,\n-@c 2) http://gcc.gnu.org/ml/gcc-bugs/1999-08n/msg01212.html\n-@c 3) http://gcc.gnu.org/ml/gcc-bugs/1999-08n/msg01215.html\n-@c and 4) a lot of guesswork.  You can tell I don't use COM.  -pme 21Dec00\n-\n-This type attribute takes no parameters, and marks a class or struct as an\n-interface for communication via COM; the class will support the COM ABI\n-rather than the full C++ ABI.  Currently this means that RTTI is not possible\n-with the resulting class heirarchy.  The virtual pointer table will be\n-changed to be COM-compliant.  Also, all classes and structs derived from one\n-marked with this attribute are implicitly marked with the same attribute;\n-thus, only the base class in a COM hierarchy needs @code{com_interface}.\n-\n @item java_interface\n @cindex java_interface attribute\n "}]}