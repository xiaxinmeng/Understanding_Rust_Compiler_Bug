{"sha": "a5f00f07f195bb0012629388da827814fc0a11fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVmMDBmMDdmMTk1YmIwMDEyNjI5Mzg4ZGE4Mjc4MTRmYzBhMTFmYw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-02-27T22:44:49Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-02-27T22:44:49Z"}, "message": "(store_fixed_bit_field): Move float mode to integral\nmode conversion from near end of function to top of function.\n\nFrom-SVN: r6657", "tree": {"sha": "4bedc304f1bd13becc5cb7f8126a1689e9c8df07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bedc304f1bd13becc5cb7f8126a1689e9c8df07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5f00f07f195bb0012629388da827814fc0a11fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5f00f07f195bb0012629388da827814fc0a11fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5f00f07f195bb0012629388da827814fc0a11fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5f00f07f195bb0012629388da827814fc0a11fc/comments", "author": null, "committer": null, "parents": [{"sha": "d27c148b7639ccd374b07892b35b6d2a5d080826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d27c148b7639ccd374b07892b35b6d2a5d080826", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d27c148b7639ccd374b07892b35b6d2a5d080826"}], "stats": {"total": 22, "additions": 11, "deletions": 11}, "files": [{"sha": "b6269c654dd2476cbdf88838664046ee129383a9", "filename": "gcc/expmed.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5f00f07f195bb0012629388da827814fc0a11fc/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5f00f07f195bb0012629388da827814fc0a11fc/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=a5f00f07f195bb0012629388da827814fc0a11fc", "patch": "@@ -517,6 +517,17 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n   int all_zero = 0;\n   int all_one = 0;\n \n+  /* If VALUE is a floating-point mode, access it as an integer of the\n+     corresponding size.  This can occur on a machine with 64 bit registers\n+     that uses SFmode for float.  This can also occur for unaligned float\n+     structure fields.  */\n+  if (GET_MODE_CLASS (GET_MODE (value)) == MODE_FLOAT)\n+    {\n+      if (GET_CODE (value) != REG)\n+\tvalue = copy_to_reg (value);\n+      value = gen_rtx (SUBREG, word_mode, value, 0);\n+    }\n+\n   /* There is a case not handled here:\n      a structure with a known alignment of just a halfword\n      and a field split across two aligned halfwords within the structure.\n@@ -612,17 +623,6 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n \n       if (GET_MODE (value) != mode)\n \t{\n-\t  /* If VALUE is a floating-point mode, access it as an integer\n-\t     of the corresponding size, then convert it.  This can occur on\n-\t     a machine with 64 bit registers that uses SFmode for float.  */\n-\t  if (GET_MODE_CLASS (GET_MODE (value)) == MODE_FLOAT)\n-\t    {\n-\t      if (GET_CODE (value) != REG)\n-\t\tvalue = copy_to_reg (value);\n-\t      value\n-\t\t= gen_rtx (SUBREG, word_mode, value, 0);\n-\t    }\n-\n \t  if ((GET_CODE (value) == REG || GET_CODE (value) == SUBREG)\n \t      && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (value)))\n \t    value = gen_lowpart (mode, value);"}]}