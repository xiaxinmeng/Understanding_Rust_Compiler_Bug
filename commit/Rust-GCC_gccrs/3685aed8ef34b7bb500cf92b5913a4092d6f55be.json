{"sha": "3685aed8ef34b7bb500cf92b5913a4092d6f55be", "node_id": "C_kwDOANBUbNoAKDM2ODVhZWQ4ZWYzNGI3YmI1MDBjZjkyYjU5MTNhNDA5MmQ2ZjU1YmU", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-16T13:21:17Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-16T13:21:17Z"}, "message": "analyzer: split out checker-path.cc into a new checker-event.cc\n\ngcc/ChangeLog:\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/checker-event.o.\n\ngcc/analyzer/ChangeLog:\n\t* checker-event.cc: New file, split out from...\n\t* checker-path.cc: ...this file.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "682c063abd04297137de9fb66fdac3d5500eb731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/682c063abd04297137de9fb66fdac3d5500eb731"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3685aed8ef34b7bb500cf92b5913a4092d6f55be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3685aed8ef34b7bb500cf92b5913a4092d6f55be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3685aed8ef34b7bb500cf92b5913a4092d6f55be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3685aed8ef34b7bb500cf92b5913a4092d6f55be/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99c9cbcc3ba3e005bad790a600853266a81d95ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c9cbcc3ba3e005bad790a600853266a81d95ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99c9cbcc3ba3e005bad790a600853266a81d95ee"}], "stats": {"total": 2364, "additions": 1215, "deletions": 1149}, "files": [{"sha": "5ad638f59d81a3beaa14c3ffcac9647a5b478abd", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3685aed8ef34b7bb500cf92b5913a4092d6f55be/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3685aed8ef34b7bb500cf92b5913a4092d6f55be/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3685aed8ef34b7bb500cf92b5913a4092d6f55be", "patch": "@@ -1257,6 +1257,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/call-info.o \\\n \tanalyzer/call-string.o \\\n \tanalyzer/call-summary.o \\\n+\tanalyzer/checker-event.o \\\n \tanalyzer/checker-path.o \\\n \tanalyzer/complexity.o \\\n \tanalyzer/constraint-manager.o \\"}, {"sha": "a3e043333fed1db015839fc7a3318c1f1bf80e6c", "filename": "gcc/analyzer/checker-event.cc", "status": "added", "additions": 1213, "deletions": 0, "changes": 1213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3685aed8ef34b7bb500cf92b5913a4092d6f55be/gcc%2Fanalyzer%2Fchecker-event.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3685aed8ef34b7bb500cf92b5913a4092d6f55be/gcc%2Fanalyzer%2Fchecker-event.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-event.cc?ref=3685aed8ef34b7bb500cf92b5913a4092d6f55be", "patch": "@@ -0,0 +1,1213 @@\n+/* Subclasses of diagnostic_event for analyzer diagnostics.\n+   Copyright (C) 2019-2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#define INCLUDE_MEMORY\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"diagnostic-core.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"fold-const.h\"\n+#include \"diagnostic-path.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"sbitmap.h\"\n+#include \"bitmap.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"analyzer/checker-path.h\"\n+#include \"gimple-iterator.h\"\n+#include \"inlining-iterator.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+#include \"analyzer/constraint-manager.h\"\n+#include \"analyzer/checker-event.h\"\n+#include \"analyzer/exploded-graph.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* Get a string for EK.  */\n+\n+const char *\n+event_kind_to_string (enum event_kind ek)\n+{\n+  switch (ek)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case EK_DEBUG:\n+      return \"EK_DEBUG\";\n+    case EK_CUSTOM:\n+      return \"EK_CUSTOM\";\n+    case EK_STMT:\n+      return \"EK_STMT\";\n+    case EK_REGION_CREATION:\n+      return \"EK_REGION_CREATION\";\n+    case EK_FUNCTION_ENTRY:\n+      return \"EK_FUNCTION_ENTRY\";\n+    case EK_STATE_CHANGE:\n+      return \"EK_STATE_CHANGE\";\n+    case EK_START_CFG_EDGE:\n+      return \"EK_START_CFG_EDGE\";\n+    case EK_END_CFG_EDGE:\n+      return \"EK_END_CFG_EDGE\";\n+    case EK_CALL_EDGE:\n+      return \"EK_CALL_EDGE\";\n+    case EK_RETURN_EDGE:\n+      return \"EK_RETURN_EDGE\";\n+    case EK_START_CONSOLIDATED_CFG_EDGES:\n+      return \"EK_START_CONSOLIDATED_CFG_EDGES\";\n+    case EK_END_CONSOLIDATED_CFG_EDGES:\n+      return \"EK_END_CONSOLIDATED_CFG_EDGES\";\n+    case EK_INLINED_CALL:\n+      return \"EK_INLINED_CALL\";\n+    case EK_SETJMP:\n+      return \"EK_SETJMP\";\n+    case EK_REWIND_FROM_LONGJMP:\n+      return \"EK_REWIND_FROM_LONGJMP\";\n+    case EK_REWIND_TO_SETJMP:\n+      return \"EK_REWIND_TO_SETJMP\";\n+    case EK_WARNING:\n+      return \"EK_WARNING\";\n+    }\n+}\n+\n+/* A class for fixing up fndecls and stack depths in checker_event, based\n+   on inlining records.\n+\n+   The early inliner runs before the analyzer, which can lead to confusing\n+   output.\n+\n+   Tne base fndecl and depth within a checker_event are from call strings\n+   in program_points, which reflect the call strings after inlining.\n+   This class lets us offset the depth and fix up the reported fndecl and\n+   stack depth to better reflect the user's original code.  */\n+\n+class inlining_info\n+{\n+public:\n+  inlining_info (location_t loc)\n+  {\n+    inlining_iterator iter (loc);\n+    m_inner_fndecl = iter.get_fndecl ();\n+    int num_frames = 0;\n+    while (!iter.done_p ())\n+      {\n+\tm_outer_fndecl = iter.get_fndecl ();\n+\tnum_frames++;\n+\titer.next ();\n+      }\n+    if (num_frames > 1)\n+      m_extra_frames = num_frames - 1;\n+    else\n+      m_extra_frames = 0;\n+  }\n+\n+  tree get_inner_fndecl () const { return m_inner_fndecl; }\n+  int get_extra_frames () const { return m_extra_frames; }\n+\n+private:\n+  tree m_outer_fndecl;\n+  tree m_inner_fndecl;\n+  int m_extra_frames;\n+};\n+\n+/* class checker_event : public diagnostic_event.  */\n+\n+/* checker_event's ctor.  */\n+\n+checker_event::checker_event (enum event_kind kind,\n+\t\t\t      location_t loc, tree fndecl, int depth)\n+: m_kind (kind), m_loc (loc),\n+  m_original_fndecl (fndecl), m_effective_fndecl (fndecl),\n+  m_original_depth (depth), m_effective_depth (depth),\n+  m_pending_diagnostic (NULL), m_emission_id (),\n+  m_logical_loc (fndecl)\n+{\n+  /* Update effective fndecl and depth if inlining has been recorded.  */\n+  if (flag_analyzer_undo_inlining)\n+    {\n+      inlining_info info (loc);\n+      if (info.get_inner_fndecl ())\n+\t{\n+\t  m_effective_fndecl = info.get_inner_fndecl ();\n+\t  m_effective_depth += info.get_extra_frames ();\n+\t  m_logical_loc = tree_logical_location (m_effective_fndecl);\n+\t}\n+    }\n+}\n+\n+/* No-op implementation of diagnostic_event::get_meaning vfunc for\n+   checker_event: checker events have no meaning by default.  */\n+\n+diagnostic_event::meaning\n+checker_event::get_meaning () const\n+{\n+  return meaning ();\n+}\n+\n+/* Dump this event to PP (for debugging/logging purposes).  */\n+\n+void\n+checker_event::dump (pretty_printer *pp) const\n+{\n+  label_text event_desc (get_desc (false));\n+  pp_printf (pp, \"\\\"%s\\\" (depth %i\",\n+\t     event_desc.get (), m_effective_depth);\n+\n+  if (m_effective_depth != m_original_depth)\n+    pp_printf (pp, \" corrected from %i\",\n+\t       m_original_depth);\n+  if (m_effective_fndecl)\n+    {\n+      pp_printf (pp, \", fndecl %qE\", m_effective_fndecl);\n+      if (m_effective_fndecl != m_original_fndecl)\n+\tpp_printf (pp, \" corrected from %qE\", m_original_fndecl);\n+    }\n+  pp_printf (pp, \", m_loc=%x)\",\n+\t     get_location ());\n+}\n+\n+/* Dump this event to stderr (for debugging/logging purposes).  */\n+\n+DEBUG_FUNCTION void\n+checker_event::debug () const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump (&pp);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* Hook for being notified when this event has its final id EMISSION_ID\n+   and is about to emitted for PD.\n+\n+   Base implementation of checker_event::prepare_for_emission vfunc;\n+   subclasses that override this should chain up to it.\n+\n+   Record PD and EMISSION_ID, and call the get_desc vfunc, so that any\n+   side-effects of the call to get_desc take place before\n+   pending_diagnostic::emit is called.\n+\n+   For example, state_change_event::get_desc can call\n+   pending_diagnostic::describe_state_change; free_of_non_heap can use this\n+   to tweak the message (TODO: would be neater to simply capture the\n+   pertinent data within the sm-state).  */\n+\n+void\n+checker_event::prepare_for_emission (checker_path *,\n+\t\t\t\t     pending_diagnostic *pd,\n+\t\t\t\t     diagnostic_event_id_t emission_id)\n+{\n+  m_pending_diagnostic = pd;\n+  m_emission_id = emission_id;\n+\n+  label_text desc = get_desc (false);\n+}\n+\n+/* class debug_event : public checker_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   debug_event.\n+   Use the saved string as the event's description.  */\n+\n+label_text\n+debug_event::get_desc (bool) const\n+{\n+  return label_text::borrow (m_desc);\n+}\n+\n+/* class precanned_custom_event : public custom_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   precanned_custom_event.\n+   Use the saved string as the event's description.  */\n+\n+label_text\n+precanned_custom_event::get_desc (bool) const\n+{\n+  return label_text::borrow (m_desc);\n+}\n+\n+/* class statement_event : public checker_event.  */\n+\n+/* statement_event's ctor.  */\n+\n+statement_event::statement_event (const gimple *stmt, tree fndecl, int depth,\n+\t\t\t\t  const program_state &dst_state)\n+: checker_event (EK_STMT, gimple_location (stmt), fndecl, depth),\n+  m_stmt (stmt),\n+  m_dst_state (dst_state)\n+{\n+}\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   statement_event.\n+   Use the statement's dump form as the event's description.  */\n+\n+label_text\n+statement_event::get_desc (bool) const\n+{\n+  pretty_printer pp;\n+  pp_string (&pp, \"stmt: \");\n+  pp_gimple_stmt_1 (&pp, m_stmt, 0, (dump_flags_t)0);\n+  return label_text::take (xstrdup (pp_formatted_text (&pp)));\n+}\n+\n+/* class region_creation_event : public checker_event.  */\n+\n+region_creation_event::region_creation_event (const region *reg,\n+\t\t\t\t\t      tree capacity,\n+\t\t\t\t\t      enum rce_kind kind,\n+\t\t\t\t\t      location_t loc,\n+\t\t\t\t\t      tree fndecl,\n+\t\t\t\t\t      int depth)\n+: checker_event (EK_REGION_CREATION, loc, fndecl, depth),\n+  m_reg (reg),\n+  m_capacity (capacity),\n+  m_rce_kind (kind)\n+{\n+  if (m_rce_kind == RCE_CAPACITY)\n+    gcc_assert (capacity);\n+}\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   region_creation_event.\n+   There are effectively 3 kinds of region_region_event, to\n+   avoid combinatorial explosion by trying to convy the\n+   information in a single message.  */\n+\n+label_text\n+region_creation_event::get_desc (bool can_colorize) const\n+{\n+  if (m_pending_diagnostic)\n+    {\n+      label_text custom_desc\n+\t    = m_pending_diagnostic->describe_region_creation_event\n+\t\t(evdesc::region_creation (can_colorize, m_reg));\n+      if (custom_desc.get ())\n+\treturn custom_desc;\n+    }\n+\n+  switch (m_rce_kind)\n+    {\n+    default:\n+      gcc_unreachable ();\n+\n+    case RCE_MEM_SPACE:\n+      switch (m_reg->get_memory_space ())\n+\t{\n+\tdefault:\n+\t  return label_text::borrow (\"region created here\");\n+\tcase MEMSPACE_STACK:\n+\t  return label_text::borrow (\"region created on stack here\");\n+\tcase MEMSPACE_HEAP:\n+\t  return label_text::borrow (\"region created on heap here\");\n+\t}\n+      break;\n+\n+    case RCE_CAPACITY:\n+      gcc_assert (m_capacity);\n+      if (TREE_CODE (m_capacity) == INTEGER_CST)\n+\t{\n+\t  unsigned HOST_WIDE_INT hwi = tree_to_uhwi (m_capacity);\n+\t  if (hwi == 1)\n+\t    return make_label_text (can_colorize,\n+\t\t\t\t    \"capacity: %wu byte\", hwi);\n+\t  else\n+\t    return make_label_text (can_colorize,\n+\t\t\t\t    \"capacity: %wu bytes\", hwi);\n+\t}\n+      else\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"capacity: %qE bytes\", m_capacity);\n+\n+    case RCE_DEBUG:\n+      {\n+\tpretty_printer pp;\n+\tpp_format_decoder (&pp) = default_tree_printer;\n+\tpp_string (&pp, \"region creation: \");\n+\tm_reg->dump_to_pp (&pp, true);\n+\tif (m_capacity)\n+\t  pp_printf (&pp, \" capacity: %qE\", m_capacity);\n+\treturn label_text::take (xstrdup (pp_formatted_text (&pp)));\n+      }\n+      break;\n+    }\n+}\n+\n+/* class function_entry_event : public checker_event.  */\n+\n+function_entry_event::function_entry_event (const program_point &dst_point)\n+: checker_event (EK_FUNCTION_ENTRY,\n+\t\t dst_point.get_supernode ()->get_start_location (),\n+\t\t dst_point.get_fndecl (),\n+\t\t dst_point.get_stack_depth ())\n+{\n+}\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   function_entry_event.\n+\n+   Use a string such as \"entry to 'foo'\" as the event's description.  */\n+\n+label_text\n+function_entry_event::get_desc (bool can_colorize) const\n+{\n+  return make_label_text (can_colorize, \"entry to %qE\", m_effective_fndecl);\n+}\n+\n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   function entry.  */\n+\n+diagnostic_event::meaning\n+function_entry_event::get_meaning () const\n+{\n+  return meaning (VERB_enter, NOUN_function);\n+}\n+\n+/* class state_change_event : public checker_event.  */\n+\n+/* state_change_event's ctor.  */\n+\n+state_change_event::state_change_event (const supernode *node,\n+\t\t\t\t\tconst gimple *stmt,\n+\t\t\t\t\tint stack_depth,\n+\t\t\t\t\tconst state_machine &sm,\n+\t\t\t\t\tconst svalue *sval,\n+\t\t\t\t\tstate_machine::state_t from,\n+\t\t\t\t\tstate_machine::state_t to,\n+\t\t\t\t\tconst svalue *origin,\n+\t\t\t\t\tconst program_state &dst_state)\n+: checker_event (EK_STATE_CHANGE,\n+\t\t stmt->location, node->m_fun->decl,\n+\t\t stack_depth),\n+  m_node (node), m_stmt (stmt), m_sm (sm),\n+  m_sval (sval), m_from (from), m_to (to),\n+  m_origin (origin),\n+  m_dst_state (dst_state)\n+{\n+}\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   state_change_event.\n+\n+   Attempt to generate a nicer human-readable description.\n+   For greatest precision-of-wording, give the pending diagnostic\n+   a chance to describe this state change (in terms of the\n+   diagnostic).\n+   Note that we only have a pending_diagnostic set on the event once\n+   the diagnostic is about to being emitted, so the description for\n+   an event can change.  */\n+\n+label_text\n+state_change_event::get_desc (bool can_colorize) const\n+{\n+  if (m_pending_diagnostic)\n+    {\n+      region_model *model = m_dst_state.m_region_model;\n+      tree var = model->get_representative_tree (m_sval);\n+      tree origin = model->get_representative_tree (m_origin);\n+      label_text custom_desc\n+\t= m_pending_diagnostic->describe_state_change\n+\t    (evdesc::state_change (can_colorize, var, origin,\n+\t\t\t\t   m_from, m_to, m_emission_id, *this));\n+      if (custom_desc.get ())\n+\t{\n+\t  if (flag_analyzer_verbose_state_changes)\n+\t    {\n+\t      /* Get any \"meaning\" of event.  */\n+\t      diagnostic_event::meaning meaning = get_meaning ();\n+\t      pretty_printer meaning_pp;\n+\t      meaning.dump_to_pp (&meaning_pp);\n+\n+\t      /* Append debug version.  */\n+\t      if (m_origin)\n+\t\treturn make_label_text\n+\t\t  (can_colorize,\n+\t\t   \"%s (state of %qE: %qs -> %qs, origin: %qE, meaning: %s)\",\n+\t\t   custom_desc.get (),\n+\t\t   var,\n+\t\t   m_from->get_name (),\n+\t\t   m_to->get_name (),\n+\t\t   origin,\n+\t\t   pp_formatted_text (&meaning_pp));\n+\t      else\n+\t\treturn make_label_text\n+\t\t  (can_colorize,\n+\t\t   \"%s (state of %qE: %qs -> %qs, NULL origin, meaning: %s)\",\n+\t\t   custom_desc.get (),\n+\t\t   var,\n+\t\t   m_from->get_name (),\n+\t\t   m_to->get_name (),\n+\t\t   pp_formatted_text (&meaning_pp));\n+\t    }\n+\t  else\n+\t    return custom_desc;\n+\t}\n+    }\n+\n+  /* Fallback description.  */\n+  if (m_sval)\n+    {\n+      label_text sval_desc = m_sval->get_desc ();\n+      if (m_origin)\n+\t{\n+\t  label_text origin_desc = m_origin->get_desc ();\n+\t  return make_label_text\n+\t    (can_colorize,\n+\t     \"state of %qs: %qs -> %qs (origin: %qs)\",\n+\t     sval_desc.get (),\n+\t     m_from->get_name (),\n+\t     m_to->get_name (),\n+\t     origin_desc.get ());\n+\t}\n+      else\n+\treturn make_label_text\n+\t  (can_colorize,\n+\t   \"state of %qs: %qs -> %qs (NULL origin)\",\n+\t   sval_desc.get (),\n+\t   m_from->get_name (),\n+\t   m_to->get_name ());\n+    }\n+  else\n+    {\n+      gcc_assert (m_origin == NULL);\n+      return make_label_text\n+\t(can_colorize,\n+\t \"global state: %qs -> %qs\",\n+\t m_from->get_name (),\n+\t m_to->get_name ());\n+    }\n+}\n+\n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   state change events: delegate to the pending_diagnostic to\n+   get any meaning.  */\n+\n+diagnostic_event::meaning\n+state_change_event::get_meaning () const\n+{\n+  if (m_pending_diagnostic)\n+    {\n+      region_model *model = m_dst_state.m_region_model;\n+      tree var = model->get_representative_tree (m_sval);\n+      tree origin = model->get_representative_tree (m_origin);\n+      return m_pending_diagnostic->get_meaning_for_state_change\n+\t(evdesc::state_change (false, var, origin,\n+\t\t\t       m_from, m_to, m_emission_id, *this));\n+    }\n+  else\n+    return meaning ();\n+}\n+\n+/* class superedge_event : public checker_event.  */\n+\n+/* Get the callgraph_superedge for this superedge_event, which must be\n+   for an interprocedural edge, rather than a CFG edge.  */\n+\n+const callgraph_superedge&\n+superedge_event::get_callgraph_superedge () const\n+{\n+  gcc_assert (m_sedge->m_kind != SUPEREDGE_CFG_EDGE);\n+  return *m_sedge->dyn_cast_callgraph_superedge ();\n+}\n+\n+/* Determine if this event should be filtered at the given verbosity\n+   level.  */\n+\n+bool\n+superedge_event::should_filter_p (int verbosity) const\n+{\n+  switch (m_sedge->m_kind)\n+    {\n+    case SUPEREDGE_CFG_EDGE:\n+      {\n+\tif (verbosity < 2)\n+\t  return true;\n+\n+\tif (verbosity < 4)\n+\t  {\n+\t    /* Filter events with empty descriptions.  This ought to filter\n+\t       FALLTHRU, but retain true/false/switch edges.  */\n+\t    label_text desc = get_desc (false);\n+\t    gcc_assert (desc.get ());\n+\t    if (desc.get ()[0] == '\\0')\n+\t      return true;\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+/* superedge_event's ctor.  */\n+\n+superedge_event::superedge_event (enum event_kind kind,\n+\t\t\t\t  const exploded_edge &eedge,\n+\t\t\t\t  location_t loc, tree fndecl, int depth)\n+: checker_event (kind, loc, fndecl, depth),\n+  m_eedge (eedge), m_sedge (eedge.m_sedge),\n+  m_var (NULL_TREE), m_critical_state (0)\n+{\n+}\n+\n+/* class cfg_edge_event : public superedge_event.  */\n+\n+/* Get the cfg_superedge for this cfg_edge_event.  */\n+\n+const cfg_superedge &\n+cfg_edge_event::get_cfg_superedge () const\n+{\n+  return *m_sedge->dyn_cast_cfg_superedge ();\n+}\n+\n+/* cfg_edge_event's ctor.  */\n+\n+cfg_edge_event::cfg_edge_event (enum event_kind kind,\n+\t\t\t\tconst exploded_edge &eedge,\n+\t\t\t\tlocation_t loc, tree fndecl, int depth)\n+: superedge_event (kind, eedge, loc, fndecl, depth)\n+{\n+  gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_CFG_EDGE);\n+}\n+\n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   CFG edge events.  */\n+\n+diagnostic_event::meaning\n+cfg_edge_event::get_meaning () const\n+{\n+  const cfg_superedge& cfg_sedge = get_cfg_superedge ();\n+  if (cfg_sedge.true_value_p ())\n+    return meaning (VERB_branch, PROPERTY_true);\n+  else if (cfg_sedge.false_value_p ())\n+    return meaning (VERB_branch, PROPERTY_false);\n+  else\n+    return meaning ();\n+}\n+\n+/* class start_cfg_edge_event : public cfg_edge_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   start_cfg_edge_event.\n+\n+   If -fanalyzer-verbose-edges, then generate low-level descriptions, such\n+   as\n+     \"taking 'true' edge SN:7 -> SN:8\".\n+\n+   Otherwise, generate strings using the label of the underlying CFG if\n+   any, such as:\n+     \"following 'true' branch...\" or\n+     \"following 'case 3' branch...\"\n+     \"following 'default' branch...\"\n+\n+   For conditionals, attempt to supply a description of the condition that\n+   holds, such as:\n+     \"following 'false' branch (when 'ptr' is non-NULL)...\"\n+\n+   Failing that, return an empty description (which will lead to this event\n+   being filtered).  */\n+\n+label_text\n+start_cfg_edge_event::get_desc (bool can_colorize) const\n+{\n+  bool user_facing = !flag_analyzer_verbose_edges;\n+  label_text edge_desc (m_sedge->get_description (user_facing));\n+  if (user_facing)\n+    {\n+      if (edge_desc.get () && strlen (edge_desc.get ()) > 0)\n+\t{\n+\t  label_text cond_desc = maybe_describe_condition (can_colorize);\n+\t  label_text result;\n+\t  if (cond_desc.get ())\n+\t    return make_label_text (can_colorize,\n+\t\t\t\t    \"following %qs branch (%s)...\",\n+\t\t\t\t    edge_desc.get (), cond_desc.get ());\n+\t  else\n+\t    return make_label_text (can_colorize,\n+\t\t\t\t    \"following %qs branch...\",\n+\t\t\t\t    edge_desc.get ());\n+\t}\n+      else\n+\treturn label_text::borrow (\"\");\n+    }\n+  else\n+    {\n+      if (strlen (edge_desc.get ()) > 0)\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"taking %qs edge SN:%i -> SN:%i\",\n+\t\t\t\tedge_desc.get (),\n+\t\t\t\tm_sedge->m_src->m_index,\n+\t\t\t\tm_sedge->m_dest->m_index);\n+      else\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"taking edge SN:%i -> SN:%i\",\n+\t\t\t\tm_sedge->m_src->m_index,\n+\t\t\t\tm_sedge->m_dest->m_index);\n+    }\n+}\n+\n+/* Attempt to generate a description of any condition that holds at this edge.\n+\n+   The intent is to make the user-facing messages more clear, especially for\n+   cases where there's a single or double-negative, such as\n+   when describing the false branch of an inverted condition.\n+\n+   For example, rather than printing just:\n+\n+      |  if (!ptr)\n+      |     ~\n+      |     |\n+      |     (1) following 'false' branch...\n+\n+   it's clearer to spell out the condition that holds:\n+\n+      |  if (!ptr)\n+      |     ~\n+      |     |\n+      |     (1) following 'false' branch (when 'ptr' is non-NULL)...\n+                                          ^^^^^^^^^^^^^^^^^^^^^^\n+\n+   In the above example, this function would generate the highlighted\n+   string: \"when 'ptr' is non-NULL\".\n+\n+   If the edge is not a condition, or it's not clear that a description of\n+   the condition would be helpful to the user, return NULL.  */\n+\n+label_text\n+start_cfg_edge_event::maybe_describe_condition (bool can_colorize) const\n+{\n+  const cfg_superedge& cfg_sedge = get_cfg_superedge ();\n+\n+  if (cfg_sedge.true_value_p () || cfg_sedge.false_value_p ())\n+    {\n+      const gimple *last_stmt = m_sedge->m_src->get_last_stmt ();\n+      if (const gcond *cond_stmt = dyn_cast <const gcond *> (last_stmt))\n+\t{\n+\t  enum tree_code op = gimple_cond_code (cond_stmt);\n+\t  tree lhs = gimple_cond_lhs (cond_stmt);\n+\t  tree rhs = gimple_cond_rhs (cond_stmt);\n+\t  if (cfg_sedge.false_value_p ())\n+\t    op = invert_tree_comparison (op, false /* honor_nans */);\n+\t  return maybe_describe_condition (can_colorize,\n+\t\t\t\t\t   lhs, op, rhs);\n+\t}\n+    }\n+  return label_text::borrow (NULL);\n+}\n+\n+/* Subroutine of maybe_describe_condition above.\n+\n+   Attempt to generate a user-facing description of the condition\n+   LHS OP RHS, but only if it is likely to make it easier for the\n+   user to understand a condition.  */\n+\n+label_text\n+start_cfg_edge_event::maybe_describe_condition (bool can_colorize,\n+\t\t\t\t\t\ttree lhs,\n+\t\t\t\t\t\tenum tree_code op,\n+\t\t\t\t\t\ttree rhs)\n+{\n+  /* In theory we could just build a tree via\n+       fold_build2 (op, boolean_type_node, lhs, rhs)\n+     and print it with %qE on it, but this leads to warts such as\n+     parenthesizing vars, such as '(i) <= 9', and uses of '<unknown>'.  */\n+\n+  /* Special-case: describe testing the result of strcmp, as figuring\n+     out what the \"true\" or \"false\" path is can be confusing to the user.  */\n+  if (TREE_CODE (lhs) == SSA_NAME\n+      && zerop (rhs))\n+    {\n+      if (gcall *call = dyn_cast <gcall *> (SSA_NAME_DEF_STMT (lhs)))\n+\tif (is_special_named_call_p (call, \"strcmp\", 2))\n+\t  {\n+\t    if (op == EQ_EXPR)\n+\t      return label_text::borrow (\"when the strings are equal\");\n+\t    if (op == NE_EXPR)\n+\t      return label_text::borrow (\"when the strings are non-equal\");\n+\t  }\n+    }\n+\n+  /* Only attempt to generate text for sufficiently simple expressions.  */\n+  if (!should_print_expr_p (lhs))\n+    return label_text::borrow (NULL);\n+  if (!should_print_expr_p (rhs))\n+    return label_text::borrow (NULL);\n+\n+  /* Special cases for pointer comparisons against NULL.  */\n+  if (POINTER_TYPE_P (TREE_TYPE (lhs))\n+      && POINTER_TYPE_P (TREE_TYPE (rhs))\n+      && zerop (rhs))\n+    {\n+      if (op == EQ_EXPR)\n+\treturn make_label_text (can_colorize, \"when %qE is NULL\",\n+\t\t\t\tlhs);\n+      if (op == NE_EXPR)\n+\treturn make_label_text (can_colorize, \"when %qE is non-NULL\",\n+\t\t\t\tlhs);\n+    }\n+\n+  return make_label_text (can_colorize, \"when %<%E %s %E%>\",\n+\t\t\t  lhs, op_symbol_code (op), rhs);\n+}\n+\n+/* Subroutine of maybe_describe_condition.\n+\n+   Return true if EXPR is we will get suitable user-facing output\n+   from %E on it.  */\n+\n+bool\n+start_cfg_edge_event::should_print_expr_p (tree expr)\n+{\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    {\n+      if (SSA_NAME_VAR (expr))\n+\treturn should_print_expr_p (SSA_NAME_VAR (expr));\n+      else\n+\treturn false;\n+    }\n+\n+  if (DECL_P (expr))\n+    return true;\n+\n+  if (CONSTANT_CLASS_P (expr))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* class call_event : public superedge_event.  */\n+\n+/* call_event's ctor.  */\n+\n+call_event::call_event (const exploded_edge &eedge,\n+\t\t\tlocation_t loc, tree fndecl, int depth)\n+: superedge_event (EK_CALL_EDGE, eedge, loc, fndecl, depth)\n+{\n+  if (eedge.m_sedge)\n+    gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_CALL);\n+\n+   m_src_snode = eedge.m_src->get_supernode ();\n+   m_dest_snode = eedge.m_dest->get_supernode ();\n+}\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   call_event.\n+\n+   If this call event passes critical state for an sm-based warning,\n+   allow the diagnostic to generate a precise description, such as:\n+\n+     \"passing freed pointer 'ptr' in call to 'foo' from 'bar'\"\n+\n+   Otherwise, generate a description of the form\n+   \"calling 'foo' from 'bar'\".  */\n+\n+label_text\n+call_event::get_desc (bool can_colorize) const\n+{\n+  if (m_critical_state && m_pending_diagnostic)\n+    {\n+      gcc_assert (m_var);\n+      tree var = fixup_tree_for_diagnostic (m_var);\n+      label_text custom_desc\n+\t= m_pending_diagnostic->describe_call_with_state\n+\t    (evdesc::call_with_state (can_colorize,\n+\t\t\t\t      m_src_snode->m_fun->decl,\n+\t\t\t\t      m_dest_snode->m_fun->decl,\n+\t\t\t\t      var,\n+\t\t\t\t      m_critical_state));\n+      if (custom_desc.get ())\n+\treturn custom_desc;\n+    }\n+\n+  return make_label_text (can_colorize,\n+\t\t\t  \"calling %qE from %qE\",\n+\t\t\t  get_callee_fndecl (),\n+\t\t\t  get_caller_fndecl ());\n+}\n+\n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   function call events.  */\n+\n+diagnostic_event::meaning\n+call_event::get_meaning () const\n+{\n+  return meaning (VERB_call, NOUN_function);\n+}\n+\n+/* Override of checker_event::is_call_p for calls.  */\n+\n+bool\n+call_event::is_call_p () const\n+{\n+  return true;\n+}\n+\n+tree\n+call_event::get_caller_fndecl () const\n+{\n+  return m_src_snode->m_fun->decl;\n+}\n+\n+tree\n+call_event::get_callee_fndecl () const\n+{\n+  return m_dest_snode->m_fun->decl;\n+}\n+\n+/* class return_event : public superedge_event.  */\n+\n+/* return_event's ctor.  */\n+\n+return_event::return_event (const exploded_edge &eedge,\n+\t\t\t    location_t loc, tree fndecl, int depth)\n+: superedge_event (EK_RETURN_EDGE, eedge, loc, fndecl, depth)\n+{\n+  if (eedge.m_sedge)\n+    gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_RETURN);\n+\n+  m_src_snode = eedge.m_src->get_supernode ();\n+  m_dest_snode = eedge.m_dest->get_supernode ();\n+}\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   return_event.\n+\n+   If this return event returns critical state for an sm-based warning,\n+   allow the diagnostic to generate a precise description, such as:\n+\n+      \"possible of NULL to 'foo' from 'bar'\"\n+\n+   Otherwise, generate a description of the form\n+   \"returning to 'foo' from 'bar'.  */\n+\n+label_text\n+return_event::get_desc (bool can_colorize) const\n+{\n+  /*  For greatest precision-of-wording, if this is returning the\n+      state involved in the pending diagnostic, give the pending\n+      diagnostic a chance to describe this return (in terms of\n+      itself).  */\n+  if (m_critical_state && m_pending_diagnostic)\n+    {\n+      label_text custom_desc\n+\t= m_pending_diagnostic->describe_return_of_state\n+\t    (evdesc::return_of_state (can_colorize,\n+\t\t\t\t      m_dest_snode->m_fun->decl,\n+\t\t\t\t      m_src_snode->m_fun->decl,\n+\t\t\t\t      m_critical_state));\n+      if (custom_desc.get ())\n+\treturn custom_desc;\n+    }\n+  return make_label_text (can_colorize,\n+\t\t\t  \"returning to %qE from %qE\",\n+\t\t\t  m_dest_snode->m_fun->decl,\n+\t\t\t  m_src_snode->m_fun->decl);\n+}\n+\n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   function return events.  */\n+\n+diagnostic_event::meaning\n+return_event::get_meaning () const\n+{\n+  return meaning (VERB_return, NOUN_function);\n+}\n+\n+/* Override of checker_event::is_return_p for returns.  */\n+\n+bool\n+return_event::is_return_p () const\n+{\n+  return true;\n+}\n+\n+/* class start_consolidated_cfg_edges_event : public checker_event.  */\n+\n+label_text\n+start_consolidated_cfg_edges_event::get_desc (bool can_colorize) const\n+{\n+  return make_label_text (can_colorize,\n+\t\t\t  \"following %qs branch...\",\n+\t\t\t  m_edge_sense ? \"true\" : \"false\");\n+}\n+\n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   start_consolidated_cfg_edges_event.  */\n+\n+diagnostic_event::meaning\n+start_consolidated_cfg_edges_event::get_meaning () const\n+{\n+  return meaning (VERB_branch,\n+\t\t  (m_edge_sense ? PROPERTY_true : PROPERTY_false));\n+}\n+\n+/* class inlined_call_event : public checker_event.  */\n+\n+label_text\n+inlined_call_event::get_desc (bool can_colorize) const\n+{\n+  return make_label_text (can_colorize,\n+\t\t\t  \"inlined call to %qE from %qE\",\n+\t\t\t  m_apparent_callee_fndecl,\n+\t\t\t  m_apparent_caller_fndecl);\n+}\n+\n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   reconstructed inlined function calls.  */\n+\n+diagnostic_event::meaning\n+inlined_call_event::get_meaning () const\n+{\n+  return meaning (VERB_call, NOUN_function);\n+}\n+\n+/* class setjmp_event : public checker_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   setjmp_event.  */\n+\n+label_text\n+setjmp_event::get_desc (bool can_colorize) const\n+{\n+  return make_label_text (can_colorize,\n+\t\t\t  \"%qs called here\",\n+\t\t\t  get_user_facing_name (m_setjmp_call));\n+}\n+\n+/* Implementation of checker_event::prepare_for_emission vfunc for setjmp_event.\n+\n+   Record this setjmp's event ID into the path, so that rewind events can\n+   use it.  */\n+\n+void\n+setjmp_event::prepare_for_emission (checker_path *path,\n+\t\t\t\t    pending_diagnostic *pd,\n+\t\t\t\t    diagnostic_event_id_t emission_id)\n+{\n+  checker_event::prepare_for_emission (path, pd, emission_id);\n+  path->record_setjmp_event (m_enode, emission_id);\n+}\n+\n+/* class rewind_event : public checker_event.  */\n+\n+/* Get the fndecl containing the site of the longjmp call.  */\n+\n+tree\n+rewind_event::get_longjmp_caller () const\n+{\n+  return m_eedge->m_src->get_function ()->decl;\n+}\n+\n+/* Get the fndecl containing the site of the setjmp call.  */\n+\n+tree\n+rewind_event::get_setjmp_caller () const\n+{\n+  return m_eedge->m_dest->get_function ()->decl;\n+}\n+\n+/* rewind_event's ctor.  */\n+\n+rewind_event::rewind_event (const exploded_edge *eedge,\n+\t\t\t    enum event_kind kind,\n+\t\t\t    location_t loc, tree fndecl, int depth,\n+\t\t\t    const rewind_info_t *rewind_info)\n+: checker_event (kind, loc, fndecl, depth),\n+  m_rewind_info (rewind_info),\n+  m_eedge (eedge)\n+{\n+  gcc_assert (m_eedge->m_custom_info.get () == m_rewind_info);\n+}\n+\n+/* class rewind_from_longjmp_event : public rewind_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   rewind_from_longjmp_event.  */\n+\n+label_text\n+rewind_from_longjmp_event::get_desc (bool can_colorize) const\n+{\n+  const char *src_name\n+    = get_user_facing_name (m_rewind_info->get_longjmp_call ());\n+\n+  if (get_longjmp_caller () == get_setjmp_caller ())\n+    /* Special-case: purely intraprocedural rewind.  */\n+    return make_label_text (can_colorize,\n+\t\t\t    \"rewinding within %qE from %qs...\",\n+\t\t\t    get_longjmp_caller (),\n+\t\t\t    src_name);\n+  else\n+    return make_label_text (can_colorize,\n+\t\t\t    \"rewinding from %qs in %qE...\",\n+\t\t\t    src_name,\n+\t\t\t    get_longjmp_caller ());\n+}\n+\n+/* class rewind_to_setjmp_event : public rewind_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   rewind_to_setjmp_event.  */\n+\n+label_text\n+rewind_to_setjmp_event::get_desc (bool can_colorize) const\n+{\n+  const char *dst_name\n+    = get_user_facing_name (m_rewind_info->get_setjmp_call ());\n+\n+  /* If we can, identify the ID of the setjmp_event.  */\n+  if (m_original_setjmp_event_id.known_p ())\n+    {\n+      if (get_longjmp_caller () == get_setjmp_caller ())\n+\t/* Special-case: purely intraprocedural rewind.  */\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"...to %qs (saved at %@)\",\n+\t\t\t\tdst_name,\n+\t\t\t\t&m_original_setjmp_event_id);\n+      else\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"...to %qs in %qE (saved at %@)\",\n+\t\t\t\tdst_name,\n+\t\t\t\tget_setjmp_caller (),\n+\t\t\t\t&m_original_setjmp_event_id);\n+    }\n+  else\n+    {\n+      if (get_longjmp_caller () == get_setjmp_caller ())\n+\t/* Special-case: purely intraprocedural rewind.  */\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"...to %qs\",\n+\t\t\t\tdst_name,\n+\t\t\t\tget_setjmp_caller ());\n+      else\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"...to %qs in %qE\",\n+\t\t\t\tdst_name,\n+\t\t\t\tget_setjmp_caller ());\n+    }\n+}\n+\n+/* Implementation of checker_event::prepare_for_emission vfunc for\n+   rewind_to_setjmp_event.\n+\n+   Attempt to look up the setjmp event ID that recorded the jmp_buf\n+   for this rewind.  */\n+\n+void\n+rewind_to_setjmp_event::prepare_for_emission (checker_path *path,\n+\t\t\t\t\t      pending_diagnostic *pd,\n+\t\t\t\t\t      diagnostic_event_id_t emission_id)\n+{\n+  checker_event::prepare_for_emission (path, pd, emission_id);\n+  path->get_setjmp_event (m_rewind_info->get_enode_origin (),\n+\t\t\t  &m_original_setjmp_event_id);\n+}\n+\n+/* class warning_event : public checker_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   warning_event.\n+\n+   If the pending diagnostic implements describe_final_event, use it,\n+   generating a precise description e.g.\n+     \"second 'free' here; first 'free' was at (7)\"\n+\n+   Otherwise generate a generic description.  */\n+\n+label_text\n+warning_event::get_desc (bool can_colorize) const\n+{\n+  if (m_pending_diagnostic)\n+    {\n+      tree var = fixup_tree_for_diagnostic (m_var);\n+      label_text ev_desc\n+\t= m_pending_diagnostic->describe_final_event\n+\t    (evdesc::final_event (can_colorize, var, m_state));\n+      if (ev_desc.get ())\n+\t{\n+\t  if (m_sm && flag_analyzer_verbose_state_changes)\n+\t    {\n+\t      if (var)\n+\t\treturn make_label_text (can_colorize,\n+\t\t\t\t\t\"%s (%qE is in state %qs)\",\n+\t\t\t\t\tev_desc.get (),\n+\t\t\t\t\tvar, m_state->get_name ());\n+\t      else\n+\t\treturn make_label_text (can_colorize,\n+\t\t\t\t\t\"%s (in global state %qs)\",\n+\t\t\t\t\tev_desc.get (),\n+\t\t\t\t\tm_state->get_name ());\n+\t    }\n+\t  else\n+\t    return ev_desc;\n+\t}\n+    }\n+\n+  if (m_sm)\n+    {\n+      if (m_var)\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"here (%qE is in state %qs)\",\n+\t\t\t\tm_var, m_state->get_name ());\n+      else\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"here (in global state %qs)\",\n+\t\t\t\tm_state->get_name ());\n+    }\n+  else\n+    return label_text::borrow (\"here\");\n+}\n+\n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   warning_event.  */\n+\n+diagnostic_event::meaning\n+warning_event::get_meaning () const\n+{\n+  return meaning (VERB_danger, NOUN_unknown);\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "cbe24a2058a235536ae3c124f15a0e5f098a0ecc", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 1, "deletions": 1149, "changes": 1150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3685aed8ef34b7bb500cf92b5913a4092d6f55be/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3685aed8ef34b7bb500cf92b5913a4092d6f55be/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=3685aed8ef34b7bb500cf92b5913a4092d6f55be", "patch": "@@ -1,4 +1,4 @@\n-/* Subclasses of diagnostic_path and diagnostic_event for analyzer diagnostics.\n+/* Subclass of diagnostic_path for analyzer diagnostics.\n    Copyright (C) 2019-2022 Free Software Foundation, Inc.\n    Contributed by David Malcolm <dmalcolm@redhat.com>.\n \n@@ -62,1154 +62,6 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace ana {\n \n-/* Get a string for EK.  */\n-\n-const char *\n-event_kind_to_string (enum event_kind ek)\n-{\n-  switch (ek)\n-    {\n-    default:\n-      gcc_unreachable ();\n-    case EK_DEBUG:\n-      return \"EK_DEBUG\";\n-    case EK_CUSTOM:\n-      return \"EK_CUSTOM\";\n-    case EK_STMT:\n-      return \"EK_STMT\";\n-    case EK_REGION_CREATION:\n-      return \"EK_REGION_CREATION\";\n-    case EK_FUNCTION_ENTRY:\n-      return \"EK_FUNCTION_ENTRY\";\n-    case EK_STATE_CHANGE:\n-      return \"EK_STATE_CHANGE\";\n-    case EK_START_CFG_EDGE:\n-      return \"EK_START_CFG_EDGE\";\n-    case EK_END_CFG_EDGE:\n-      return \"EK_END_CFG_EDGE\";\n-    case EK_CALL_EDGE:\n-      return \"EK_CALL_EDGE\";\n-    case EK_RETURN_EDGE:\n-      return \"EK_RETURN_EDGE\";\n-    case EK_START_CONSOLIDATED_CFG_EDGES:\n-      return \"EK_START_CONSOLIDATED_CFG_EDGES\";\n-    case EK_END_CONSOLIDATED_CFG_EDGES:\n-      return \"EK_END_CONSOLIDATED_CFG_EDGES\";\n-    case EK_INLINED_CALL:\n-      return \"EK_INLINED_CALL\";\n-    case EK_SETJMP:\n-      return \"EK_SETJMP\";\n-    case EK_REWIND_FROM_LONGJMP:\n-      return \"EK_REWIND_FROM_LONGJMP\";\n-    case EK_REWIND_TO_SETJMP:\n-      return \"EK_REWIND_TO_SETJMP\";\n-    case EK_WARNING:\n-      return \"EK_WARNING\";\n-    }\n-}\n-\n-/* A class for fixing up fndecls and stack depths in checker_event, based\n-   on inlining records.\n-\n-   The early inliner runs before the analyzer, which can lead to confusing\n-   output.\n-\n-   Tne base fndecl and depth within a checker_event are from call strings\n-   in program_points, which reflect the call strings after inlining.\n-   This class lets us offset the depth and fix up the reported fndecl and\n-   stack depth to better reflect the user's original code.  */\n-\n-class inlining_info\n-{\n-public:\n-  inlining_info (location_t loc)\n-  {\n-    inlining_iterator iter (loc);\n-    m_inner_fndecl = iter.get_fndecl ();\n-    int num_frames = 0;\n-    while (!iter.done_p ())\n-      {\n-\tm_outer_fndecl = iter.get_fndecl ();\n-\tnum_frames++;\n-\titer.next ();\n-      }\n-    if (num_frames > 1)\n-      m_extra_frames = num_frames - 1;\n-    else\n-      m_extra_frames = 0;\n-  }\n-\n-  tree get_inner_fndecl () const { return m_inner_fndecl; }\n-  int get_extra_frames () const { return m_extra_frames; }\n-\n-private:\n-  tree m_outer_fndecl;\n-  tree m_inner_fndecl;\n-  int m_extra_frames;\n-};\n-\n-/* class checker_event : public diagnostic_event.  */\n-\n-/* checker_event's ctor.  */\n-\n-checker_event::checker_event (enum event_kind kind,\n-\t\t\t      location_t loc, tree fndecl, int depth)\n-: m_kind (kind), m_loc (loc),\n-  m_original_fndecl (fndecl), m_effective_fndecl (fndecl),\n-  m_original_depth (depth), m_effective_depth (depth),\n-  m_pending_diagnostic (NULL), m_emission_id (),\n-  m_logical_loc (fndecl)\n-{\n-  /* Update effective fndecl and depth if inlining has been recorded.  */\n-  if (flag_analyzer_undo_inlining)\n-    {\n-      inlining_info info (loc);\n-      if (info.get_inner_fndecl ())\n-\t{\n-\t  m_effective_fndecl = info.get_inner_fndecl ();\n-\t  m_effective_depth += info.get_extra_frames ();\n-\t  m_logical_loc = tree_logical_location (m_effective_fndecl);\n-\t}\n-    }\n-}\n-\n-/* No-op implementation of diagnostic_event::get_meaning vfunc for\n-   checker_event: checker events have no meaning by default.  */\n-\n-diagnostic_event::meaning\n-checker_event::get_meaning () const\n-{\n-  return meaning ();\n-}\n-\n-/* Dump this event to PP (for debugging/logging purposes).  */\n-\n-void\n-checker_event::dump (pretty_printer *pp) const\n-{\n-  label_text event_desc (get_desc (false));\n-  pp_printf (pp, \"\\\"%s\\\" (depth %i\",\n-\t     event_desc.get (), m_effective_depth);\n-\n-  if (m_effective_depth != m_original_depth)\n-    pp_printf (pp, \" corrected from %i\",\n-\t       m_original_depth);\n-  if (m_effective_fndecl)\n-    {\n-      pp_printf (pp, \", fndecl %qE\", m_effective_fndecl);\n-      if (m_effective_fndecl != m_original_fndecl)\n-\tpp_printf (pp, \" corrected from %qE\", m_original_fndecl);\n-    }\n-  pp_printf (pp, \", m_loc=%x)\",\n-\t     get_location ());\n-}\n-\n-/* Dump this event to stderr (for debugging/logging purposes).  */\n-\n-DEBUG_FUNCTION void\n-checker_event::debug () const\n-{\n-  pretty_printer pp;\n-  pp_format_decoder (&pp) = default_tree_printer;\n-  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n-  pp.buffer->stream = stderr;\n-  dump (&pp);\n-  pp_newline (&pp);\n-  pp_flush (&pp);\n-}\n-\n-/* Hook for being notified when this event has its final id EMISSION_ID\n-   and is about to emitted for PD.\n-\n-   Base implementation of checker_event::prepare_for_emission vfunc;\n-   subclasses that override this should chain up to it.\n-\n-   Record PD and EMISSION_ID, and call the get_desc vfunc, so that any\n-   side-effects of the call to get_desc take place before\n-   pending_diagnostic::emit is called.\n-\n-   For example, state_change_event::get_desc can call\n-   pending_diagnostic::describe_state_change; free_of_non_heap can use this\n-   to tweak the message (TODO: would be neater to simply capture the\n-   pertinent data within the sm-state).  */\n-\n-void\n-checker_event::prepare_for_emission (checker_path *,\n-\t\t\t\t     pending_diagnostic *pd,\n-\t\t\t\t     diagnostic_event_id_t emission_id)\n-{\n-  m_pending_diagnostic = pd;\n-  m_emission_id = emission_id;\n-\n-  label_text desc = get_desc (false);\n-}\n-\n-/* class debug_event : public checker_event.  */\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   debug_event.\n-   Use the saved string as the event's description.  */\n-\n-label_text\n-debug_event::get_desc (bool) const\n-{\n-  return label_text::borrow (m_desc);\n-}\n-\n-/* class precanned_custom_event : public custom_event.  */\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   precanned_custom_event.\n-   Use the saved string as the event's description.  */\n-\n-label_text\n-precanned_custom_event::get_desc (bool) const\n-{\n-  return label_text::borrow (m_desc);\n-}\n-\n-/* class statement_event : public checker_event.  */\n-\n-/* statement_event's ctor.  */\n-\n-statement_event::statement_event (const gimple *stmt, tree fndecl, int depth,\n-\t\t\t\t  const program_state &dst_state)\n-: checker_event (EK_STMT, gimple_location (stmt), fndecl, depth),\n-  m_stmt (stmt),\n-  m_dst_state (dst_state)\n-{\n-}\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   statement_event.\n-   Use the statement's dump form as the event's description.  */\n-\n-label_text\n-statement_event::get_desc (bool) const\n-{\n-  pretty_printer pp;\n-  pp_string (&pp, \"stmt: \");\n-  pp_gimple_stmt_1 (&pp, m_stmt, 0, (dump_flags_t)0);\n-  return label_text::take (xstrdup (pp_formatted_text (&pp)));\n-}\n-\n-/* class region_creation_event : public checker_event.  */\n-\n-region_creation_event::region_creation_event (const region *reg,\n-\t\t\t\t\t      tree capacity,\n-\t\t\t\t\t      enum rce_kind kind,\n-\t\t\t\t\t      location_t loc,\n-\t\t\t\t\t      tree fndecl,\n-\t\t\t\t\t      int depth)\n-: checker_event (EK_REGION_CREATION, loc, fndecl, depth),\n-  m_reg (reg),\n-  m_capacity (capacity),\n-  m_rce_kind (kind)\n-{\n-  if (m_rce_kind == RCE_CAPACITY)\n-    gcc_assert (capacity);\n-}\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   region_creation_event.\n-   There are effectively 3 kinds of region_region_event, to\n-   avoid combinatorial explosion by trying to convy the\n-   information in a single message.  */\n-\n-label_text\n-region_creation_event::get_desc (bool can_colorize) const\n-{\n-  if (m_pending_diagnostic)\n-    {\n-      label_text custom_desc\n-\t    = m_pending_diagnostic->describe_region_creation_event\n-\t\t(evdesc::region_creation (can_colorize, m_reg));\n-      if (custom_desc.get ())\n-\treturn custom_desc;\n-    }\n-\n-  switch (m_rce_kind)\n-    {\n-    default:\n-      gcc_unreachable ();\n-\n-    case RCE_MEM_SPACE:\n-      switch (m_reg->get_memory_space ())\n-\t{\n-\tdefault:\n-\t  return label_text::borrow (\"region created here\");\n-\tcase MEMSPACE_STACK:\n-\t  return label_text::borrow (\"region created on stack here\");\n-\tcase MEMSPACE_HEAP:\n-\t  return label_text::borrow (\"region created on heap here\");\n-\t}\n-      break;\n-\n-    case RCE_CAPACITY:\n-      gcc_assert (m_capacity);\n-      if (TREE_CODE (m_capacity) == INTEGER_CST)\n-\t{\n-\t  unsigned HOST_WIDE_INT hwi = tree_to_uhwi (m_capacity);\n-\t  if (hwi == 1)\n-\t    return make_label_text (can_colorize,\n-\t\t\t\t    \"capacity: %wu byte\", hwi);\n-\t  else\n-\t    return make_label_text (can_colorize,\n-\t\t\t\t    \"capacity: %wu bytes\", hwi);\n-\t}\n-      else\n-\treturn make_label_text (can_colorize,\n-\t\t\t\t\"capacity: %qE bytes\", m_capacity);\n-\n-    case RCE_DEBUG:\n-      {\n-\tpretty_printer pp;\n-\tpp_format_decoder (&pp) = default_tree_printer;\n-\tpp_string (&pp, \"region creation: \");\n-\tm_reg->dump_to_pp (&pp, true);\n-\tif (m_capacity)\n-\t  pp_printf (&pp, \" capacity: %qE\", m_capacity);\n-\treturn label_text::take (xstrdup (pp_formatted_text (&pp)));\n-      }\n-      break;\n-    }\n-}\n-\n-/* class function_entry_event : public checker_event.  */\n-\n-function_entry_event::function_entry_event (const program_point &dst_point)\n-: checker_event (EK_FUNCTION_ENTRY,\n-\t\t dst_point.get_supernode ()->get_start_location (),\n-\t\t dst_point.get_fndecl (),\n-\t\t dst_point.get_stack_depth ())\n-{\n-}\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   function_entry_event.\n-\n-   Use a string such as \"entry to 'foo'\" as the event's description.  */\n-\n-label_text\n-function_entry_event::get_desc (bool can_colorize) const\n-{\n-  return make_label_text (can_colorize, \"entry to %qE\", m_effective_fndecl);\n-}\n-\n-/* Implementation of diagnostic_event::get_meaning vfunc for\n-   function entry.  */\n-\n-diagnostic_event::meaning\n-function_entry_event::get_meaning () const\n-{\n-  return meaning (VERB_enter, NOUN_function);\n-}\n-\n-/* class state_change_event : public checker_event.  */\n-\n-/* state_change_event's ctor.  */\n-\n-state_change_event::state_change_event (const supernode *node,\n-\t\t\t\t\tconst gimple *stmt,\n-\t\t\t\t\tint stack_depth,\n-\t\t\t\t\tconst state_machine &sm,\n-\t\t\t\t\tconst svalue *sval,\n-\t\t\t\t\tstate_machine::state_t from,\n-\t\t\t\t\tstate_machine::state_t to,\n-\t\t\t\t\tconst svalue *origin,\n-\t\t\t\t\tconst program_state &dst_state)\n-: checker_event (EK_STATE_CHANGE,\n-\t\t stmt->location, node->m_fun->decl,\n-\t\t stack_depth),\n-  m_node (node), m_stmt (stmt), m_sm (sm),\n-  m_sval (sval), m_from (from), m_to (to),\n-  m_origin (origin),\n-  m_dst_state (dst_state)\n-{\n-}\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   state_change_event.\n-\n-   Attempt to generate a nicer human-readable description.\n-   For greatest precision-of-wording, give the pending diagnostic\n-   a chance to describe this state change (in terms of the\n-   diagnostic).\n-   Note that we only have a pending_diagnostic set on the event once\n-   the diagnostic is about to being emitted, so the description for\n-   an event can change.  */\n-\n-label_text\n-state_change_event::get_desc (bool can_colorize) const\n-{\n-  if (m_pending_diagnostic)\n-    {\n-      region_model *model = m_dst_state.m_region_model;\n-      tree var = model->get_representative_tree (m_sval);\n-      tree origin = model->get_representative_tree (m_origin);\n-      label_text custom_desc\n-\t= m_pending_diagnostic->describe_state_change\n-\t    (evdesc::state_change (can_colorize, var, origin,\n-\t\t\t\t   m_from, m_to, m_emission_id, *this));\n-      if (custom_desc.get ())\n-\t{\n-\t  if (flag_analyzer_verbose_state_changes)\n-\t    {\n-\t      /* Get any \"meaning\" of event.  */\n-\t      diagnostic_event::meaning meaning = get_meaning ();\n-\t      pretty_printer meaning_pp;\n-\t      meaning.dump_to_pp (&meaning_pp);\n-\n-\t      /* Append debug version.  */\n-\t      if (m_origin)\n-\t\treturn make_label_text\n-\t\t  (can_colorize,\n-\t\t   \"%s (state of %qE: %qs -> %qs, origin: %qE, meaning: %s)\",\n-\t\t   custom_desc.get (),\n-\t\t   var,\n-\t\t   m_from->get_name (),\n-\t\t   m_to->get_name (),\n-\t\t   origin,\n-\t\t   pp_formatted_text (&meaning_pp));\n-\t      else\n-\t\treturn make_label_text\n-\t\t  (can_colorize,\n-\t\t   \"%s (state of %qE: %qs -> %qs, NULL origin, meaning: %s)\",\n-\t\t   custom_desc.get (),\n-\t\t   var,\n-\t\t   m_from->get_name (),\n-\t\t   m_to->get_name (),\n-\t\t   pp_formatted_text (&meaning_pp));\n-\t    }\n-\t  else\n-\t    return custom_desc;\n-\t}\n-    }\n-\n-  /* Fallback description.  */\n-  if (m_sval)\n-    {\n-      label_text sval_desc = m_sval->get_desc ();\n-      if (m_origin)\n-\t{\n-\t  label_text origin_desc = m_origin->get_desc ();\n-\t  return make_label_text\n-\t    (can_colorize,\n-\t     \"state of %qs: %qs -> %qs (origin: %qs)\",\n-\t     sval_desc.get (),\n-\t     m_from->get_name (),\n-\t     m_to->get_name (),\n-\t     origin_desc.get ());\n-\t}\n-      else\n-\treturn make_label_text\n-\t  (can_colorize,\n-\t   \"state of %qs: %qs -> %qs (NULL origin)\",\n-\t   sval_desc.get (),\n-\t   m_from->get_name (),\n-\t   m_to->get_name ());\n-    }\n-  else\n-    {\n-      gcc_assert (m_origin == NULL);\n-      return make_label_text\n-\t(can_colorize,\n-\t \"global state: %qs -> %qs\",\n-\t m_from->get_name (),\n-\t m_to->get_name ());\n-    }\n-}\n-\n-/* Implementation of diagnostic_event::get_meaning vfunc for\n-   state change events: delegate to the pending_diagnostic to\n-   get any meaning.  */\n-\n-diagnostic_event::meaning\n-state_change_event::get_meaning () const\n-{\n-  if (m_pending_diagnostic)\n-    {\n-      region_model *model = m_dst_state.m_region_model;\n-      tree var = model->get_representative_tree (m_sval);\n-      tree origin = model->get_representative_tree (m_origin);\n-      return m_pending_diagnostic->get_meaning_for_state_change\n-\t(evdesc::state_change (false, var, origin,\n-\t\t\t       m_from, m_to, m_emission_id, *this));\n-    }\n-  else\n-    return meaning ();\n-}\n-\n-/* class superedge_event : public checker_event.  */\n-\n-/* Get the callgraph_superedge for this superedge_event, which must be\n-   for an interprocedural edge, rather than a CFG edge.  */\n-\n-const callgraph_superedge&\n-superedge_event::get_callgraph_superedge () const\n-{\n-  gcc_assert (m_sedge->m_kind != SUPEREDGE_CFG_EDGE);\n-  return *m_sedge->dyn_cast_callgraph_superedge ();\n-}\n-\n-/* Determine if this event should be filtered at the given verbosity\n-   level.  */\n-\n-bool\n-superedge_event::should_filter_p (int verbosity) const\n-{\n-  switch (m_sedge->m_kind)\n-    {\n-    case SUPEREDGE_CFG_EDGE:\n-      {\n-\tif (verbosity < 2)\n-\t  return true;\n-\n-\tif (verbosity < 4)\n-\t  {\n-\t    /* Filter events with empty descriptions.  This ought to filter\n-\t       FALLTHRU, but retain true/false/switch edges.  */\n-\t    label_text desc = get_desc (false);\n-\t    gcc_assert (desc.get ());\n-\t    if (desc.get ()[0] == '\\0')\n-\t      return true;\n-\t  }\n-      }\n-      break;\n-\n-    default:\n-      break;\n-    }\n-  return false;\n-}\n-\n-/* superedge_event's ctor.  */\n-\n-superedge_event::superedge_event (enum event_kind kind,\n-\t\t\t\t  const exploded_edge &eedge,\n-\t\t\t\t  location_t loc, tree fndecl, int depth)\n-: checker_event (kind, loc, fndecl, depth),\n-  m_eedge (eedge), m_sedge (eedge.m_sedge),\n-  m_var (NULL_TREE), m_critical_state (0)\n-{\n-}\n-\n-/* class cfg_edge_event : public superedge_event.  */\n-\n-/* Get the cfg_superedge for this cfg_edge_event.  */\n-\n-const cfg_superedge &\n-cfg_edge_event::get_cfg_superedge () const\n-{\n-  return *m_sedge->dyn_cast_cfg_superedge ();\n-}\n-\n-/* cfg_edge_event's ctor.  */\n-\n-cfg_edge_event::cfg_edge_event (enum event_kind kind,\n-\t\t\t\tconst exploded_edge &eedge,\n-\t\t\t\tlocation_t loc, tree fndecl, int depth)\n-: superedge_event (kind, eedge, loc, fndecl, depth)\n-{\n-  gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_CFG_EDGE);\n-}\n-\n-/* Implementation of diagnostic_event::get_meaning vfunc for\n-   CFG edge events.  */\n-\n-diagnostic_event::meaning\n-cfg_edge_event::get_meaning () const\n-{\n-  const cfg_superedge& cfg_sedge = get_cfg_superedge ();\n-  if (cfg_sedge.true_value_p ())\n-    return meaning (VERB_branch, PROPERTY_true);\n-  else if (cfg_sedge.false_value_p ())\n-    return meaning (VERB_branch, PROPERTY_false);\n-  else\n-    return meaning ();\n-}\n-\n-/* class start_cfg_edge_event : public cfg_edge_event.  */\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   start_cfg_edge_event.\n-\n-   If -fanalyzer-verbose-edges, then generate low-level descriptions, such\n-   as\n-     \"taking 'true' edge SN:7 -> SN:8\".\n-\n-   Otherwise, generate strings using the label of the underlying CFG if\n-   any, such as:\n-     \"following 'true' branch...\" or\n-     \"following 'case 3' branch...\"\n-     \"following 'default' branch...\"\n-\n-   For conditionals, attempt to supply a description of the condition that\n-   holds, such as:\n-     \"following 'false' branch (when 'ptr' is non-NULL)...\"\n-\n-   Failing that, return an empty description (which will lead to this event\n-   being filtered).  */\n-\n-label_text\n-start_cfg_edge_event::get_desc (bool can_colorize) const\n-{\n-  bool user_facing = !flag_analyzer_verbose_edges;\n-  label_text edge_desc (m_sedge->get_description (user_facing));\n-  if (user_facing)\n-    {\n-      if (edge_desc.get () && strlen (edge_desc.get ()) > 0)\n-\t{\n-\t  label_text cond_desc = maybe_describe_condition (can_colorize);\n-\t  label_text result;\n-\t  if (cond_desc.get ())\n-\t    return make_label_text (can_colorize,\n-\t\t\t\t    \"following %qs branch (%s)...\",\n-\t\t\t\t    edge_desc.get (), cond_desc.get ());\n-\t  else\n-\t    return make_label_text (can_colorize,\n-\t\t\t\t    \"following %qs branch...\",\n-\t\t\t\t    edge_desc.get ());\n-\t}\n-      else\n-\treturn label_text::borrow (\"\");\n-    }\n-  else\n-    {\n-      if (strlen (edge_desc.get ()) > 0)\n-\treturn make_label_text (can_colorize,\n-\t\t\t\t\"taking %qs edge SN:%i -> SN:%i\",\n-\t\t\t\tedge_desc.get (),\n-\t\t\t\tm_sedge->m_src->m_index,\n-\t\t\t\tm_sedge->m_dest->m_index);\n-      else\n-\treturn make_label_text (can_colorize,\n-\t\t\t\t\"taking edge SN:%i -> SN:%i\",\n-\t\t\t\tm_sedge->m_src->m_index,\n-\t\t\t\tm_sedge->m_dest->m_index);\n-    }\n-}\n-\n-/* Attempt to generate a description of any condition that holds at this edge.\n-\n-   The intent is to make the user-facing messages more clear, especially for\n-   cases where there's a single or double-negative, such as\n-   when describing the false branch of an inverted condition.\n-\n-   For example, rather than printing just:\n-\n-      |  if (!ptr)\n-      |     ~\n-      |     |\n-      |     (1) following 'false' branch...\n-\n-   it's clearer to spell out the condition that holds:\n-\n-      |  if (!ptr)\n-      |     ~\n-      |     |\n-      |     (1) following 'false' branch (when 'ptr' is non-NULL)...\n-                                          ^^^^^^^^^^^^^^^^^^^^^^\n-\n-   In the above example, this function would generate the highlighted\n-   string: \"when 'ptr' is non-NULL\".\n-\n-   If the edge is not a condition, or it's not clear that a description of\n-   the condition would be helpful to the user, return NULL.  */\n-\n-label_text\n-start_cfg_edge_event::maybe_describe_condition (bool can_colorize) const\n-{\n-  const cfg_superedge& cfg_sedge = get_cfg_superedge ();\n-\n-  if (cfg_sedge.true_value_p () || cfg_sedge.false_value_p ())\n-    {\n-      const gimple *last_stmt = m_sedge->m_src->get_last_stmt ();\n-      if (const gcond *cond_stmt = dyn_cast <const gcond *> (last_stmt))\n-\t{\n-\t  enum tree_code op = gimple_cond_code (cond_stmt);\n-\t  tree lhs = gimple_cond_lhs (cond_stmt);\n-\t  tree rhs = gimple_cond_rhs (cond_stmt);\n-\t  if (cfg_sedge.false_value_p ())\n-\t    op = invert_tree_comparison (op, false /* honor_nans */);\n-\t  return maybe_describe_condition (can_colorize,\n-\t\t\t\t\t   lhs, op, rhs);\n-\t}\n-    }\n-  return label_text::borrow (NULL);\n-}\n-\n-/* Subroutine of maybe_describe_condition above.\n-\n-   Attempt to generate a user-facing description of the condition\n-   LHS OP RHS, but only if it is likely to make it easier for the\n-   user to understand a condition.  */\n-\n-label_text\n-start_cfg_edge_event::maybe_describe_condition (bool can_colorize,\n-\t\t\t\t\t\ttree lhs,\n-\t\t\t\t\t\tenum tree_code op,\n-\t\t\t\t\t\ttree rhs)\n-{\n-  /* In theory we could just build a tree via\n-       fold_build2 (op, boolean_type_node, lhs, rhs)\n-     and print it with %qE on it, but this leads to warts such as\n-     parenthesizing vars, such as '(i) <= 9', and uses of '<unknown>'.  */\n-\n-  /* Special-case: describe testing the result of strcmp, as figuring\n-     out what the \"true\" or \"false\" path is can be confusing to the user.  */\n-  if (TREE_CODE (lhs) == SSA_NAME\n-      && zerop (rhs))\n-    {\n-      if (gcall *call = dyn_cast <gcall *> (SSA_NAME_DEF_STMT (lhs)))\n-\tif (is_special_named_call_p (call, \"strcmp\", 2))\n-\t  {\n-\t    if (op == EQ_EXPR)\n-\t      return label_text::borrow (\"when the strings are equal\");\n-\t    if (op == NE_EXPR)\n-\t      return label_text::borrow (\"when the strings are non-equal\");\n-\t  }\n-    }\n-\n-  /* Only attempt to generate text for sufficiently simple expressions.  */\n-  if (!should_print_expr_p (lhs))\n-    return label_text::borrow (NULL);\n-  if (!should_print_expr_p (rhs))\n-    return label_text::borrow (NULL);\n-\n-  /* Special cases for pointer comparisons against NULL.  */\n-  if (POINTER_TYPE_P (TREE_TYPE (lhs))\n-      && POINTER_TYPE_P (TREE_TYPE (rhs))\n-      && zerop (rhs))\n-    {\n-      if (op == EQ_EXPR)\n-\treturn make_label_text (can_colorize, \"when %qE is NULL\",\n-\t\t\t\tlhs);\n-      if (op == NE_EXPR)\n-\treturn make_label_text (can_colorize, \"when %qE is non-NULL\",\n-\t\t\t\tlhs);\n-    }\n-\n-  return make_label_text (can_colorize, \"when %<%E %s %E%>\",\n-\t\t\t  lhs, op_symbol_code (op), rhs);\n-}\n-\n-/* Subroutine of maybe_describe_condition.\n-\n-   Return true if EXPR is we will get suitable user-facing output\n-   from %E on it.  */\n-\n-bool\n-start_cfg_edge_event::should_print_expr_p (tree expr)\n-{\n-  if (TREE_CODE (expr) == SSA_NAME)\n-    {\n-      if (SSA_NAME_VAR (expr))\n-\treturn should_print_expr_p (SSA_NAME_VAR (expr));\n-      else\n-\treturn false;\n-    }\n-\n-  if (DECL_P (expr))\n-    return true;\n-\n-  if (CONSTANT_CLASS_P (expr))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* class call_event : public superedge_event.  */\n-\n-/* call_event's ctor.  */\n-\n-call_event::call_event (const exploded_edge &eedge,\n-\t\t\tlocation_t loc, tree fndecl, int depth)\n-: superedge_event (EK_CALL_EDGE, eedge, loc, fndecl, depth)\n-{\n-  if (eedge.m_sedge)\n-    gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_CALL);\n-\n-   m_src_snode = eedge.m_src->get_supernode ();\n-   m_dest_snode = eedge.m_dest->get_supernode ();\n-}\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   call_event.\n-\n-   If this call event passes critical state for an sm-based warning,\n-   allow the diagnostic to generate a precise description, such as:\n-\n-     \"passing freed pointer 'ptr' in call to 'foo' from 'bar'\"\n-\n-   Otherwise, generate a description of the form\n-   \"calling 'foo' from 'bar'\".  */\n-\n-label_text\n-call_event::get_desc (bool can_colorize) const\n-{\n-  if (m_critical_state && m_pending_diagnostic)\n-    {\n-      gcc_assert (m_var);\n-      tree var = fixup_tree_for_diagnostic (m_var);\n-      label_text custom_desc\n-\t= m_pending_diagnostic->describe_call_with_state\n-\t    (evdesc::call_with_state (can_colorize,\n-\t\t\t\t      m_src_snode->m_fun->decl,\n-\t\t\t\t      m_dest_snode->m_fun->decl,\n-\t\t\t\t      var,\n-\t\t\t\t      m_critical_state));\n-      if (custom_desc.get ())\n-\treturn custom_desc;\n-    }\n-\n-  return make_label_text (can_colorize,\n-\t\t\t  \"calling %qE from %qE\",\n-\t\t\t  get_callee_fndecl (),\n-\t\t\t  get_caller_fndecl ());\n-}\n-\n-/* Implementation of diagnostic_event::get_meaning vfunc for\n-   function call events.  */\n-\n-diagnostic_event::meaning\n-call_event::get_meaning () const\n-{\n-  return meaning (VERB_call, NOUN_function);\n-}\n-\n-/* Override of checker_event::is_call_p for calls.  */\n-\n-bool\n-call_event::is_call_p () const\n-{\n-  return true;\n-}\n-\n-tree\n-call_event::get_caller_fndecl () const\n-{\n-  return m_src_snode->m_fun->decl;\n-}\n-\n-tree\n-call_event::get_callee_fndecl () const\n-{\n-  return m_dest_snode->m_fun->decl;\n-}\n-\n-/* class return_event : public superedge_event.  */\n-\n-/* return_event's ctor.  */\n-\n-return_event::return_event (const exploded_edge &eedge,\n-\t\t\t    location_t loc, tree fndecl, int depth)\n-: superedge_event (EK_RETURN_EDGE, eedge, loc, fndecl, depth)\n-{\n-  if (eedge.m_sedge)\n-    gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_RETURN);\n-\n-  m_src_snode = eedge.m_src->get_supernode ();\n-  m_dest_snode = eedge.m_dest->get_supernode ();\n-}\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   return_event.\n-\n-   If this return event returns critical state for an sm-based warning,\n-   allow the diagnostic to generate a precise description, such as:\n-\n-      \"possible of NULL to 'foo' from 'bar'\"\n-\n-   Otherwise, generate a description of the form\n-   \"returning to 'foo' from 'bar'.  */\n-\n-label_text\n-return_event::get_desc (bool can_colorize) const\n-{\n-  /*  For greatest precision-of-wording, if this is returning the\n-      state involved in the pending diagnostic, give the pending\n-      diagnostic a chance to describe this return (in terms of\n-      itself).  */\n-  if (m_critical_state && m_pending_diagnostic)\n-    {\n-      label_text custom_desc\n-\t= m_pending_diagnostic->describe_return_of_state\n-\t    (evdesc::return_of_state (can_colorize,\n-\t\t\t\t      m_dest_snode->m_fun->decl,\n-\t\t\t\t      m_src_snode->m_fun->decl,\n-\t\t\t\t      m_critical_state));\n-      if (custom_desc.get ())\n-\treturn custom_desc;\n-    }\n-  return make_label_text (can_colorize,\n-\t\t\t  \"returning to %qE from %qE\",\n-\t\t\t  m_dest_snode->m_fun->decl,\n-\t\t\t  m_src_snode->m_fun->decl);\n-}\n-\n-/* Implementation of diagnostic_event::get_meaning vfunc for\n-   function return events.  */\n-\n-diagnostic_event::meaning\n-return_event::get_meaning () const\n-{\n-  return meaning (VERB_return, NOUN_function);\n-}\n-\n-/* Override of checker_event::is_return_p for returns.  */\n-\n-bool\n-return_event::is_return_p () const\n-{\n-  return true;\n-}\n-\n-/* class start_consolidated_cfg_edges_event : public checker_event.  */\n-\n-label_text\n-start_consolidated_cfg_edges_event::get_desc (bool can_colorize) const\n-{\n-  return make_label_text (can_colorize,\n-\t\t\t  \"following %qs branch...\",\n-\t\t\t  m_edge_sense ? \"true\" : \"false\");\n-}\n-\n-/* Implementation of diagnostic_event::get_meaning vfunc for\n-   start_consolidated_cfg_edges_event.  */\n-\n-diagnostic_event::meaning\n-start_consolidated_cfg_edges_event::get_meaning () const\n-{\n-  return meaning (VERB_branch,\n-\t\t  (m_edge_sense ? PROPERTY_true : PROPERTY_false));\n-}\n-\n-/* class inlined_call_event : public checker_event.  */\n-\n-label_text\n-inlined_call_event::get_desc (bool can_colorize) const\n-{\n-  return make_label_text (can_colorize,\n-\t\t\t  \"inlined call to %qE from %qE\",\n-\t\t\t  m_apparent_callee_fndecl,\n-\t\t\t  m_apparent_caller_fndecl);\n-}\n-\n-/* Implementation of diagnostic_event::get_meaning vfunc for\n-   reconstructed inlined function calls.  */\n-\n-diagnostic_event::meaning\n-inlined_call_event::get_meaning () const\n-{\n-  return meaning (VERB_call, NOUN_function);\n-}\n-\n-/* class setjmp_event : public checker_event.  */\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   setjmp_event.  */\n-\n-label_text\n-setjmp_event::get_desc (bool can_colorize) const\n-{\n-  return make_label_text (can_colorize,\n-\t\t\t  \"%qs called here\",\n-\t\t\t  get_user_facing_name (m_setjmp_call));\n-}\n-\n-/* Implementation of checker_event::prepare_for_emission vfunc for setjmp_event.\n-\n-   Record this setjmp's event ID into the path, so that rewind events can\n-   use it.  */\n-\n-void\n-setjmp_event::prepare_for_emission (checker_path *path,\n-\t\t\t\t    pending_diagnostic *pd,\n-\t\t\t\t    diagnostic_event_id_t emission_id)\n-{\n-  checker_event::prepare_for_emission (path, pd, emission_id);\n-  path->record_setjmp_event (m_enode, emission_id);\n-}\n-\n-/* class rewind_event : public checker_event.  */\n-\n-/* Get the fndecl containing the site of the longjmp call.  */\n-\n-tree\n-rewind_event::get_longjmp_caller () const\n-{\n-  return m_eedge->m_src->get_function ()->decl;\n-}\n-\n-/* Get the fndecl containing the site of the setjmp call.  */\n-\n-tree\n-rewind_event::get_setjmp_caller () const\n-{\n-  return m_eedge->m_dest->get_function ()->decl;\n-}\n-\n-/* rewind_event's ctor.  */\n-\n-rewind_event::rewind_event (const exploded_edge *eedge,\n-\t\t\t    enum event_kind kind,\n-\t\t\t    location_t loc, tree fndecl, int depth,\n-\t\t\t    const rewind_info_t *rewind_info)\n-: checker_event (kind, loc, fndecl, depth),\n-  m_rewind_info (rewind_info),\n-  m_eedge (eedge)\n-{\n-  gcc_assert (m_eedge->m_custom_info.get () == m_rewind_info);\n-}\n-\n-/* class rewind_from_longjmp_event : public rewind_event.  */\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   rewind_from_longjmp_event.  */\n-\n-label_text\n-rewind_from_longjmp_event::get_desc (bool can_colorize) const\n-{\n-  const char *src_name\n-    = get_user_facing_name (m_rewind_info->get_longjmp_call ());\n-\n-  if (get_longjmp_caller () == get_setjmp_caller ())\n-    /* Special-case: purely intraprocedural rewind.  */\n-    return make_label_text (can_colorize,\n-\t\t\t    \"rewinding within %qE from %qs...\",\n-\t\t\t    get_longjmp_caller (),\n-\t\t\t    src_name);\n-  else\n-    return make_label_text (can_colorize,\n-\t\t\t    \"rewinding from %qs in %qE...\",\n-\t\t\t    src_name,\n-\t\t\t    get_longjmp_caller ());\n-}\n-\n-/* class rewind_to_setjmp_event : public rewind_event.  */\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   rewind_to_setjmp_event.  */\n-\n-label_text\n-rewind_to_setjmp_event::get_desc (bool can_colorize) const\n-{\n-  const char *dst_name\n-    = get_user_facing_name (m_rewind_info->get_setjmp_call ());\n-\n-  /* If we can, identify the ID of the setjmp_event.  */\n-  if (m_original_setjmp_event_id.known_p ())\n-    {\n-      if (get_longjmp_caller () == get_setjmp_caller ())\n-\t/* Special-case: purely intraprocedural rewind.  */\n-\treturn make_label_text (can_colorize,\n-\t\t\t\t\"...to %qs (saved at %@)\",\n-\t\t\t\tdst_name,\n-\t\t\t\t&m_original_setjmp_event_id);\n-      else\n-\treturn make_label_text (can_colorize,\n-\t\t\t\t\"...to %qs in %qE (saved at %@)\",\n-\t\t\t\tdst_name,\n-\t\t\t\tget_setjmp_caller (),\n-\t\t\t\t&m_original_setjmp_event_id);\n-    }\n-  else\n-    {\n-      if (get_longjmp_caller () == get_setjmp_caller ())\n-\t/* Special-case: purely intraprocedural rewind.  */\n-\treturn make_label_text (can_colorize,\n-\t\t\t\t\"...to %qs\",\n-\t\t\t\tdst_name,\n-\t\t\t\tget_setjmp_caller ());\n-      else\n-\treturn make_label_text (can_colorize,\n-\t\t\t\t\"...to %qs in %qE\",\n-\t\t\t\tdst_name,\n-\t\t\t\tget_setjmp_caller ());\n-    }\n-}\n-\n-/* Implementation of checker_event::prepare_for_emission vfunc for\n-   rewind_to_setjmp_event.\n-\n-   Attempt to look up the setjmp event ID that recorded the jmp_buf\n-   for this rewind.  */\n-\n-void\n-rewind_to_setjmp_event::prepare_for_emission (checker_path *path,\n-\t\t\t\t\t      pending_diagnostic *pd,\n-\t\t\t\t\t      diagnostic_event_id_t emission_id)\n-{\n-  checker_event::prepare_for_emission (path, pd, emission_id);\n-  path->get_setjmp_event (m_rewind_info->get_enode_origin (),\n-\t\t\t  &m_original_setjmp_event_id);\n-}\n-\n-/* class warning_event : public checker_event.  */\n-\n-/* Implementation of diagnostic_event::get_desc vfunc for\n-   warning_event.\n-\n-   If the pending diagnostic implements describe_final_event, use it,\n-   generating a precise description e.g.\n-     \"second 'free' here; first 'free' was at (7)\"\n-\n-   Otherwise generate a generic description.  */\n-\n-label_text\n-warning_event::get_desc (bool can_colorize) const\n-{\n-  if (m_pending_diagnostic)\n-    {\n-      tree var = fixup_tree_for_diagnostic (m_var);\n-      label_text ev_desc\n-\t= m_pending_diagnostic->describe_final_event\n-\t    (evdesc::final_event (can_colorize, var, m_state));\n-      if (ev_desc.get ())\n-\t{\n-\t  if (m_sm && flag_analyzer_verbose_state_changes)\n-\t    {\n-\t      if (var)\n-\t\treturn make_label_text (can_colorize,\n-\t\t\t\t\t\"%s (%qE is in state %qs)\",\n-\t\t\t\t\tev_desc.get (),\n-\t\t\t\t\tvar, m_state->get_name ());\n-\t      else\n-\t\treturn make_label_text (can_colorize,\n-\t\t\t\t\t\"%s (in global state %qs)\",\n-\t\t\t\t\tev_desc.get (),\n-\t\t\t\t\tm_state->get_name ());\n-\t    }\n-\t  else\n-\t    return ev_desc;\n-\t}\n-    }\n-\n-  if (m_sm)\n-    {\n-      if (m_var)\n-\treturn make_label_text (can_colorize,\n-\t\t\t\t\"here (%qE is in state %qs)\",\n-\t\t\t\tm_var, m_state->get_name ());\n-      else\n-\treturn make_label_text (can_colorize,\n-\t\t\t\t\"here (in global state %qs)\",\n-\t\t\t\tm_state->get_name ());\n-    }\n-  else\n-    return label_text::borrow (\"here\");\n-}\n-\n-/* Implementation of diagnostic_event::get_meaning vfunc for\n-   warning_event.  */\n-\n-diagnostic_event::meaning\n-warning_event::get_meaning () const\n-{\n-  return meaning (VERB_danger, NOUN_unknown);\n-}\n-\n /* Print a single-line representation of this path to PP.  */\n \n void"}]}