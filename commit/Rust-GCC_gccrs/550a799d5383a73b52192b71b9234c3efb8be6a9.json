{"sha": "550a799d5383a73b52192b71b9234c3efb8be6a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwYTc5OWQ1MzgzYTczYjUyMTkyYjcxYjkyMzRjM2VmYjhiZTZhOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-05-25T23:01:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-05-25T23:01:02Z"}, "message": "re PR c++/38064 ([c++0x] operator== doesn't work for enum classes)\n\n\tPR c++/38064\n\t* typeck.c (cp_build_binary_op): Allow ENUMERAL_TYPE in\n\tarithmetic comparisons.\n\t(cp_common_type): Handle scoped enums.\n\n\t* call.c (promoted_arithmetic_type_p): Don't use INTEGRAL_TYPE_P.\n\t(add_builtin_candidate, add_builtin_candidates): Likewise.\n\t(convert_like_real): Likewise.\n\t* class.c (check_bitfield_decl): Likewise.\n\t* decl.c (check_static_variable_definition): Likewise.\n\t(compute_array_index_type): Likewise.\n\t* decl2.c (grokbitfield): Likewise.\n\t* init.c (build_new_1): Likewise.\n\t* pt.c (convert_nontype_argument): Likewise.\n\t(current_instantiation): Likewise.\n\t* tree.c (pod_type_p): Likewise.\n\t* typeck.c (build_static_cast_1): Likewise.\n\t(build_reinterpret_cast_1): Likewise.\n\nFrom-SVN: r147854", "tree": {"sha": "583bc6fb72a9ca524446f8aa253888d047949f48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/583bc6fb72a9ca524446f8aa253888d047949f48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/550a799d5383a73b52192b71b9234c3efb8be6a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550a799d5383a73b52192b71b9234c3efb8be6a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/550a799d5383a73b52192b71b9234c3efb8be6a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550a799d5383a73b52192b71b9234c3efb8be6a9/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85057983ac31039dff4e0963b789ee6684351868", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85057983ac31039dff4e0963b789ee6684351868", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85057983ac31039dff4e0963b789ee6684351868"}], "stats": {"total": 122, "additions": 89, "deletions": 33}, "files": [{"sha": "7e22a4f29687ddc459a0af34957fa9d5df707484", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=550a799d5383a73b52192b71b9234c3efb8be6a9", "patch": "@@ -1,3 +1,24 @@\n+2009-05-22  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/38064\n+\t* typeck.c (cp_build_binary_op): Allow ENUMERAL_TYPE in\n+\tarithmetic comparisons.\n+\t(cp_common_type): Handle scoped enums.\n+\n+\t* call.c (promoted_arithmetic_type_p): Don't use INTEGRAL_TYPE_P.\n+\t(add_builtin_candidate, add_builtin_candidates): Likewise.\n+\t(convert_like_real): Likewise.\n+\t* class.c (check_bitfield_decl): Likewise.\n+\t* decl.c (check_static_variable_definition): Likewise.\n+\t(compute_array_index_type): Likewise.\n+\t* decl2.c (grokbitfield): Likewise.\n+\t* init.c (build_new_1): Likewise.\n+\t* pt.c (convert_nontype_argument): Likewise.\n+\t(current_instantiation): Likewise.\n+\t* tree.c (pod_type_p): Likewise.\n+\t* typeck.c (build_static_cast_1): Likewise.\n+\t(build_reinterpret_cast_1): Likewise.\n+\n 2009-05-22  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/38964"}, {"sha": "a9c036746db7de3aa9196cc8fc41933b513a264e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=550a799d5383a73b52192b71b9234c3efb8be6a9", "patch": "@@ -1781,7 +1781,7 @@ promoted_arithmetic_type_p (tree type)\n      (including e.g.  int and long but excluding e.g.  char).\n      Similarly, the term promoted arithmetic type refers to promoted\n      integral types plus floating types.  */\n-  return ((INTEGRAL_TYPE_P (type)\n+  return ((CP_INTEGRAL_TYPE_P (type)\n \t   && same_type_p (type_promotes_to (type), type))\n \t  || TREE_CODE (type) == REAL_TYPE);\n }\n@@ -1883,7 +1883,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t     T       operator~(T);  */\n \n     case BIT_NOT_EXPR:\n-      if (INTEGRAL_TYPE_P (type1))\n+      if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type1))\n \tbreak;\n       return;\n \n@@ -1953,7 +1953,8 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n     case MINUS_EXPR:\n       if (TYPE_PTROB_P (type1) && TYPE_PTROB_P (type2))\n \tbreak;\n-      if (TYPE_PTROB_P (type1) && INTEGRAL_TYPE_P (type2))\n+      if (TYPE_PTROB_P (type1)\n+\t  && INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type2))\n \t{\n \t  type2 = ptrdiff_type_node;\n \t  break;\n@@ -2013,12 +2014,12 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n       if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n \tbreak;\n     case ARRAY_REF:\n-      if (INTEGRAL_TYPE_P (type1) && TYPE_PTROB_P (type2))\n+      if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type1) && TYPE_PTROB_P (type2))\n \t{\n \t  type1 = ptrdiff_type_node;\n \t  break;\n \t}\n-      if (TYPE_PTROB_P (type1) && INTEGRAL_TYPE_P (type2))\n+      if (TYPE_PTROB_P (type1) && INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type2))\n \t{\n \t  type2 = ptrdiff_type_node;\n \t  break;\n@@ -2042,7 +2043,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n     case BIT_XOR_EXPR:\n     case LSHIFT_EXPR:\n     case RSHIFT_EXPR:\n-      if (INTEGRAL_TYPE_P (type1) && INTEGRAL_TYPE_P (type2))\n+      if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type1) && INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type2))\n \tbreak;\n       return;\n \n@@ -2087,7 +2088,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t{\n \tcase PLUS_EXPR:\n \tcase MINUS_EXPR:\n-\t  if (TYPE_PTROB_P (type1) && INTEGRAL_TYPE_P (type2))\n+\t  if (TYPE_PTROB_P (type1) && INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type2))\n \t    {\n \t      type2 = ptrdiff_type_node;\n \t      break;\n@@ -2104,7 +2105,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \tcase BIT_XOR_EXPR:\n \tcase LSHIFT_EXPR:\n \tcase RSHIFT_EXPR:\n-\t  if (INTEGRAL_TYPE_P (type1) && INTEGRAL_TYPE_P (type2))\n+\t  if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type1) && INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type2))\n \t    break;\n \t  return;\n \n@@ -2329,7 +2330,7 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \t\t  type = TYPE_MAIN_VARIANT (type_decays_to (type));\n \t\t  if (enum_p && TREE_CODE (type) == ENUMERAL_TYPE)\n \t\t    types[i] = tree_cons (NULL_TREE, type, types[i]);\n-\t\t  if (INTEGRAL_TYPE_P (type))\n+\t\t  if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type))\n \t\t    type = type_promotes_to (type);\n \t\t}\n \n@@ -2346,9 +2347,9 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \t  if (i != 0 || ! ref1)\n \t    {\n \t      type = TYPE_MAIN_VARIANT (type_decays_to (type));\n-\t      if (enum_p && TREE_CODE (type) == ENUMERAL_TYPE)\n+\t      if (enum_p && UNSCOPED_ENUM_P (type))\n \t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n-\t      if (INTEGRAL_TYPE_P (type))\n+\t      if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type))\n \t\ttype = type_promotes_to (type);\n \t    }\n \t  types[i] = tree_cons (NULL_TREE, type, types[i]);\n@@ -4755,7 +4756,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       if (inner >= 0)\n         {   \n           expr = decl_constant_value (expr);\n-          if (expr == null_node && INTEGRAL_TYPE_P (totype))\n+          if (expr == null_node && INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (totype))\n             /* If __null has been converted to an integer type, we do not\n                want to warn about uses of EXPR as an integer, rather than\n                as a pointer.  */"}, {"sha": "20ceb6540c456c08fc1c3473e0b2323e1e40b465", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=550a799d5383a73b52192b71b9234c3efb8be6a9", "patch": "@@ -2705,7 +2705,7 @@ check_bitfield_decl (tree field)\n   DECL_INITIAL (field) = NULL_TREE;\n \n   /* Detect invalid bit-field type.  */\n-  if (!INTEGRAL_TYPE_P (type))\n+  if (!INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n     {\n       error (\"bit-field %q+#D with non-integral type\", field);\n       w = error_mark_node;"}, {"sha": "a626a71fc34210151f8f8d0ba811b0af7d27325e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=550a799d5383a73b52192b71b9234c3efb8be6a9", "patch": "@@ -7154,7 +7154,7 @@ check_static_variable_definition (tree decl, tree type)\n     error (\"ISO C++ forbids in-class initialization of non-const \"\n \t   \"static member %qD\",\n \t   decl);\n-  else if (!INTEGRAL_TYPE_P (type))\n+  else if (!INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n     pedwarn (input_location, OPT_pedantic, \"ISO C++ forbids initialization of member constant \"\n \t     \"%qD of non-integral type %qT\", decl, type);\n \n@@ -7177,7 +7177,7 @@ compute_array_index_type (tree name, tree size)\n \n   type = TREE_TYPE (size);\n   /* The array bound must be an integer type.  */\n-  if (!dependent_type_p (type) && !INTEGRAL_TYPE_P (type))\n+  if (!dependent_type_p (type) && !INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type))\n     {\n       if (name)\n \terror (\"size of array %qD has non-integral type %qT\", name, type);"}, {"sha": "d368ea803bba78f4ba9d600032843e3c1076ad62", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=550a799d5383a73b52192b71b9234c3efb8be6a9", "patch": "@@ -964,7 +964,7 @@ grokbitfield (const cp_declarator *declarator,\n   if (TREE_CODE (value) == VOID_TYPE)\n     return void_type_node;\n \n-  if (!INTEGRAL_TYPE_P (TREE_TYPE (value))\n+  if (!INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (value))\n       && (POINTER_TYPE_P (value)\n           || !dependent_type_p (TREE_TYPE (value))))\n     {"}, {"sha": "a99983e18eee941f86c9391a923b7c374840ff9d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=550a799d5383a73b52192b71b9234c3efb8be6a9", "patch": "@@ -1963,7 +1963,7 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n     {\n       tree placement_arg = CALL_EXPR_ARG (alloc_call, 1);\n \n-      if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (placement_arg)))\n+      if (INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (TREE_TYPE (placement_arg)))\n \t  || VOID_TYPE_P (TREE_TYPE (TREE_TYPE (placement_arg))))\n \t{\n \t  placement_expr = get_target_expr (placement_first);"}, {"sha": "f8a6e7ece6ee179b27bc548a6d3a44ed9b7e0853", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=550a799d5383a73b52192b71b9234c3efb8be6a9", "patch": "@@ -4415,9 +4415,9 @@ convert_nontype_argument (tree type, tree expr)\n      For a non-type template-parameter of integral or enumeration type,\n      integral promotions (_conv.prom_) and integral conversions\n      (_conv.integral_) are applied.  */\n-  if (INTEGRAL_TYPE_P (type))\n+  if (INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n     {\n-      if (!INTEGRAL_TYPE_P (expr_type))\n+      if (!INTEGRAL_OR_ENUMERATION_TYPE_P (expr_type))\n \treturn error_mark_node;\n \n       expr = fold_decl_constant_value (expr);\n@@ -16153,7 +16153,7 @@ current_instantiation (void)\n static int\n invalid_nontype_parm_type_p (tree type, tsubst_flags_t complain)\n {\n-  if (INTEGRAL_TYPE_P (type))\n+  if (INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n     return 0;\n   else if (POINTER_TYPE_P (type))\n     return 0;"}, {"sha": "dece159f4e81f4cda953730e9e3bb32e35050c9d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=550a799d5383a73b52192b71b9234c3efb8be6a9", "patch": "@@ -2156,7 +2156,7 @@ pod_type_p (const_tree t)\n \n   if (t == error_mark_node)\n     return 1;\n-  if (INTEGRAL_TYPE_P (t))\n+  if (INTEGRAL_OR_ENUMERATION_TYPE_P (t))\n     return 1;  /* integral, character or enumeral type */\n   if (FLOAT_TYPE_P (t))\n     return 1;"}, {"sha": "d7fddb1121189bacd59acea7aa6d51e9ced8e87c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=550a799d5383a73b52192b71b9234c3efb8be6a9", "patch": "@@ -260,6 +260,19 @@ cp_common_type (tree t1, tree t2)\n   enum tree_code code2 = TREE_CODE (t2);\n   tree attributes;\n \n+  /* In what follows, we slightly generalize the rules given in [expr] so\n+     as to deal with `long long' and `complex'.  First, merge the\n+     attributes.  */\n+  attributes = (*targetm.merge_type_attributes) (t1, t2);\n+\n+  if (SCOPED_ENUM_P (t1) || SCOPED_ENUM_P (t2))\n+    {\n+      if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n+\treturn build_type_attribute_variant (t1, attributes);\n+      else\n+\treturn NULL_TREE;\n+    }\n+\n   /* FIXME: Attributes.  */\n   gcc_assert (ARITHMETIC_TYPE_P (t1)\n \t      || TREE_CODE (t1) == VECTOR_TYPE\n@@ -268,11 +281,6 @@ cp_common_type (tree t1, tree t2)\n \t      || TREE_CODE (t2) == VECTOR_TYPE\n \t      || UNSCOPED_ENUM_P (t2));\n \n-  /* In what follows, we slightly generalize the rules given in [expr] so\n-     as to deal with `long long' and `complex'.  First, merge the\n-     attributes.  */\n-  attributes = (*targetm.merge_type_attributes) (t1, t2);\n-\n   /* If one type is complex, form the common type of the non-complex\n      components, then make that complex.  Use T1 or T2 if it is the\n      required type.  */\n@@ -3636,9 +3644,9 @@ cp_build_binary_op (location_t location,\n \n       build_type = boolean_type_node;\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n-\t   || code0 == COMPLEX_TYPE)\n+\t   || code0 == COMPLEX_TYPE || code0 == ENUMERAL_TYPE)\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n-\t      || code1 == COMPLEX_TYPE))\n+\t      || code1 == COMPLEX_TYPE || code1 == ENUMERAL_TYPE))\n \tshort_compare = 1;\n       else if ((code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t       || (TYPE_PTRMEM_P (type0) && TYPE_PTRMEM_P (type1)))\n@@ -3910,9 +3918,10 @@ cp_build_binary_op (location_t location,\n       break;\n     }\n \n-  if (((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE)\n+  if (((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE\n+\t|| code0 == ENUMERAL_TYPE)\n        && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n-\t   || code1 == COMPLEX_TYPE)))\n+\t   || code1 == COMPLEX_TYPE || code1 == ENUMERAL_TYPE)))\n     arithmetic_types_p = 1;\n   else\n     {\n@@ -5348,8 +5357,10 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n   /* The effect of all that is that any conversion between any two\n      types which are integral, floating, or enumeration types can be\n      performed.  */\n-  if ((INTEGRAL_TYPE_P (type) || SCALAR_FLOAT_TYPE_P (type))\n-      && (INTEGRAL_TYPE_P (intype) || SCALAR_FLOAT_TYPE_P (intype)))\n+  if ((INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n+       || SCALAR_FLOAT_TYPE_P (type))\n+      && (INTEGRAL_OR_ENUMERATION_TYPE_P (intype)\n+\t  || SCALAR_FLOAT_TYPE_P (intype)))\n     {\n       expr = ocp_convert (type, expr, CONV_C_CAST, LOOKUP_NORMAL);\n \n@@ -5649,7 +5660,8 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n     }\n   else if (TREE_CODE (type) == VECTOR_TYPE)\n     return fold_if_not_in_template (convert_to_vector (type, expr));\n-  else if (TREE_CODE (intype) == VECTOR_TYPE && INTEGRAL_TYPE_P (type))\n+  else if (TREE_CODE (intype) == VECTOR_TYPE\n+\t   && INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n     return fold_if_not_in_template (convert_to_integer (type, expr));\n   else\n     {"}, {"sha": "03aa1166e1f76e743aa75c77273fbbbf6ece9448", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=550a799d5383a73b52192b71b9234c3efb8be6a9", "patch": "@@ -1,3 +1,8 @@\n+2009-05-25  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/38064\n+\t* g++.dg/cpp0x/enum3.C: New test.\n+\n 2009-05-25  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/36327"}, {"sha": "5555ab2aac817e072b3a68fc757dcf5e9977d4f8", "filename": "gcc/testsuite/g++.dg/cpp0x/enum3.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fenum3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a799d5383a73b52192b71b9234c3efb8be6a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fenum3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fenum3.C?ref=550a799d5383a73b52192b71b9234c3efb8be6a9", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/38064\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run }\n+\n+enum class E { elem };\n+\n+template <class T>\n+void f (T t);\n+\n+bool f (bool b) { return b; }\n+\n+int main()\n+{\n+  E e = E::elem;\n+  if (!f (e == E::elem))\n+    return 1;\n+}"}]}