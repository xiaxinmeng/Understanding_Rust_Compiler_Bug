{"sha": "1a5577239fdf250e3fde521810339981d90c11c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE1NTc3MjM5ZmRmMjUwZTNmZGU1MjE4MTAzMzk5ODFkOTBjMTFjOA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-07-07T05:40:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-07-07T05:40:49Z"}, "message": "tree-vrp.c (simplify_using_ranges): Kill.\n\n        * tree-vrp.c (simplify_using_ranges): Kill.\n        (vrp_finalize): Remove call to simplify_using_ranges.\n        (simplify_stmt_using_ranges): New function extracted from\n        simplify_using_ranges.\n        (simplify_div_or_mod_using_ranges): Likewise.\n        (simplify_abs_using_ranges): Likewise.\n        (simplify_cond_using_ranges): New function.\n        * tree-flow.h (simplify_stmt_using_ranges): Prototype.\n        * tree-ssa-propagate.c (substitute_and_fold): Call\n        simplify_stmt_using_ranges if we have range information.\n\n        * gcc.dg/tree-ssa/vrp17.c: New test.\n\nFrom-SVN: r101685", "tree": {"sha": "39d0d67d3b7776dd952fdc17b8a92c3b380e47cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39d0d67d3b7776dd952fdc17b8a92c3b380e47cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a5577239fdf250e3fde521810339981d90c11c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a5577239fdf250e3fde521810339981d90c11c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a5577239fdf250e3fde521810339981d90c11c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a5577239fdf250e3fde521810339981d90c11c8/comments", "author": null, "committer": null, "parents": [{"sha": "769b009eacdbe2537a66c2d806f8830a7d00e08d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/769b009eacdbe2537a66c2d806f8830a7d00e08d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/769b009eacdbe2537a66c2d806f8830a7d00e08d"}], "stats": {"total": 358, "additions": 250, "deletions": 108}, "files": [{"sha": "13ddd5c1cb6f3574f0f0fc1bb84f5a535f495e27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5577239fdf250e3fde521810339981d90c11c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5577239fdf250e3fde521810339981d90c11c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a5577239fdf250e3fde521810339981d90c11c8", "patch": "@@ -1,3 +1,16 @@\n+2005-07-06  Jeff Law  <law@redhat.com>\n+\n+\t* tree-vrp.c (simplify_using_ranges): Kill.\n+\t(vrp_finalize): Remove call to simplify_using_ranges.\n+\t(simplify_stmt_using_ranges): New function extracted from\n+\tsimplify_using_ranges.\n+\t(simplify_div_or_mod_using_ranges): Likewise.\n+\t(simplify_abs_using_ranges): Likewise.\n+\t(simplify_cond_using_ranges): New function.\n+\t* tree-flow.h (simplify_stmt_using_ranges): Prototype.\n+\t* tree-ssa-propagate.c (substitute_and_fold): Call\n+\tsimplify_stmt_using_ranges if we have range information.\n+\n 2005-07-06  James E. Wilson  <wilson@specifixinc.com>\n \n \t* config/ia64/ia64.c (ia64_reorg): Check optimize before"}, {"sha": "7c793be17c0145feb37a72329dbd121054dee413", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5577239fdf250e3fde521810339981d90c11c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5577239fdf250e3fde521810339981d90c11c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a5577239fdf250e3fde521810339981d90c11c8", "patch": "@@ -1,3 +1,7 @@\n+2005-07-06  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/vrp17.c: New test.\n+\n 2005-07-07  Feng Wang  <fengwang@nudt.edu.cn>\n \n \tPR fortran/22327"}, {"sha": "b4e0a5bdfe0e284b140f4312d45d6cc4e5f297e1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp17.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5577239fdf250e3fde521810339981d90c11c8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5577239fdf250e3fde521810339981d90c11c8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp17.c?ref=1a5577239fdf250e3fde521810339981d90c11c8", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+extern void abort (void) __attribute__ ((__noreturn__));\n+union tree_node;\n+typedef union tree_node *tree;\n+extern const unsigned char tree_code_length[];\n+struct tree_common\n+{\n+  int code;\n+};\n+struct tree_exp\n+{\n+  tree operands[1];\n+};\n+union tree_node\n+{\n+  struct tree_common common;\n+  struct tree_exp exp;\n+};\n+int\n+gimplify_for_stmt (tree * stmt_p, tree * pre_p)\n+{\n+  tree stmt = *stmt_p;\n+  arf (({\n+\t  if (3 >= tree_code_length[stmt->common.code])\n+\t    abort ();\n+\t  stmt->exp.operands[3];\n+        }),\n+       ({\n+\t  if (2 >= tree_code_length[stmt->common.code])\n+\t    abort ();\n+          stmt->exp.operands[2];\n+        }));\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"== 3\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+"}, {"sha": "773a76f1d4a068b2fefcd8a778e4eae177260776", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5577239fdf250e3fde521810339981d90c11c8/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5577239fdf250e3fde521810339981d90c11c8/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=1a5577239fdf250e3fde521810339981d90c11c8", "patch": "@@ -626,6 +626,7 @@ tree widen_bitfield (tree, tree, tree);\n /* In tree-vrp.c  */\n bool expr_computes_nonzero (tree);\n tree vrp_evaluate_conditional (tree, bool);\n+void simplify_stmt_using_ranges (tree);\n \n /* In tree-ssa-dom.c  */\n extern void dump_dominator_optimization_stats (FILE *);"}, {"sha": "b9b308e607892db98305b610430d4e4d3b9dfec0", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5577239fdf250e3fde521810339981d90c11c8/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5577239fdf250e3fde521810339981d90c11c8/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=1a5577239fdf250e3fde521810339981d90c11c8", "patch": "@@ -1108,7 +1108,14 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t  /* If we have range information, see if we can fold\n \t     predicate expressions.  */\n \t  if (use_ranges_p)\n-\t    did_replace = fold_predicate_in (stmt);\n+\t    {\n+\t      did_replace = fold_predicate_in (stmt);\n+\n+\t      /* Some statements may be simplified using ranges.  For\n+\t\t example, division may be replaced by shifts, modulo\n+\t\t replaced with bitwise and, etc.  */\n+\t      simplify_stmt_using_ranges (stmt);\n+\t    }\n \n \t  if (prop_value)\n \t    {"}, {"sha": "91be397db2c7cb465bfb37b41ec02ef43572060c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 185, "deletions": 107, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5577239fdf250e3fde521810339981d90c11c8/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5577239fdf250e3fde521810339981d90c11c8/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=1a5577239fdf250e3fde521810339981d90c11c8", "patch": "@@ -3493,127 +3493,211 @@ vrp_visit_phi_node (tree phi)\n   return SSA_PROP_VARYING;\n }\n \n-/* Walk through the IL simplifying expressions using knowledge\n-   gathered by VRP.  */\n+/* Simplify a division or modulo operator to a right shift or\n+   bitwise and if the first operand is unsigned or is greater\n+   than zero and the second operand is an exact power of two.  */\n \n static void\n-simplify_using_ranges (void)\n+simplify_div_or_mod_using_ranges (tree stmt, tree rhs, enum tree_code rhs_code)\n {\n-  basic_block bb;\n+  tree val = NULL;\n+  tree op = TREE_OPERAND (rhs, 0);\n+  value_range_t *vr = get_value_range (TREE_OPERAND (rhs, 0));\n \n-  FOR_EACH_BB (bb)\n+  if (TYPE_UNSIGNED (TREE_TYPE (op)))\n+    {\n+      val = integer_one_node;\n+    }\n+  else\n+    {\n+      val = compare_range_with_value (GT_EXPR, vr, integer_zero_node);\n+    }\n+\n+  if (val && integer_onep (val))\n     {\n-      block_stmt_iterator bsi;\n+      tree t;\n+      tree op0 = TREE_OPERAND (rhs, 0);\n+      tree op1 = TREE_OPERAND (rhs, 1);\n+\n+      if (rhs_code == TRUNC_DIV_EXPR)\n+\t{\n+\t  t = build_int_cst (NULL_TREE, tree_log2 (op1));\n+\t  t = build (RSHIFT_EXPR, TREE_TYPE (op0), op0, t);\n+\t}\n+      else\n+\t{\n+\t  t = build_int_cst (TREE_TYPE (op1), 1);\n+\t  t = int_const_binop (MINUS_EXPR, op1, t, 0);\n+\t  t = fold_convert (TREE_TYPE (op0), t);\n+\t  t = build2 (BIT_AND_EXPR, TREE_TYPE (op0), op0, t);\n+\t}\n \n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      TREE_OPERAND (stmt, 1) = t;\n+      update_stmt (stmt);\n+    }\n+}\n+\n+/* If the operand to an ABS_EXPR is >= 0, then eliminate the\n+   ABS_EXPR.  If the operand is <= 0, then simplify the\n+   ABS_EXPR into a NEGATE_EXPR.  */\n+\n+static void\n+simplify_abs_using_ranges (tree stmt, tree rhs)\n+{\n+  tree val = NULL;\n+  tree op = TREE_OPERAND (rhs, 0);\n+  tree type = TREE_TYPE (op);\n+  value_range_t *vr = get_value_range (TREE_OPERAND (rhs, 0));\n+\n+  if (TYPE_UNSIGNED (type))\n+    {\n+      val = integer_zero_node;\n+    }\n+  else if (vr)\n+    {\n+      val = compare_range_with_value (LE_EXPR, vr, integer_zero_node);\n+      if (!val)\n \t{\n-\t  tree stmt = bsi_stmt (bsi);\n+\t  val = compare_range_with_value (GE_EXPR, vr, integer_zero_node);\n \n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t  if (val)\n \t    {\n-\t      tree rhs = TREE_OPERAND (stmt, 1);\n-\t      enum tree_code rhs_code = TREE_CODE (rhs);\n-\n-\t      /* Transform TRUNC_DIV_EXPR and TRUNC_MOD_EXPR into RSHIFT_EXPR\n-\t\t and BIT_AND_EXPR respectively if the first operand is greater\n-\t\t than zero and the second operand is an exact power of two.  */\n-\t      if ((rhs_code == TRUNC_DIV_EXPR || rhs_code == TRUNC_MOD_EXPR)\n-\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (rhs, 0)))\n-\t\t  && integer_pow2p (TREE_OPERAND (rhs, 1)))\n-\t\t{\n-\t\t  tree val = NULL;\n-\t\t  tree op = TREE_OPERAND (rhs, 0);\n-\t\t  value_range_t *vr = get_value_range (TREE_OPERAND (rhs, 0));\n-\n-\t\t  if (TYPE_UNSIGNED (TREE_TYPE (op)))\n-\t\t    {\n-\t\t      val = integer_one_node;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      val = compare_range_with_value (GT_EXPR, vr,\n-\t\t\t\t\t\t      integer_zero_node);\n-\t\t    }\n-\n-\t\t  if (val && integer_onep (val))\n-\t\t    {\n-\t\t      tree t;\n-\t\t      tree op0 = TREE_OPERAND (rhs, 0);\n-\t\t      tree op1 = TREE_OPERAND (rhs, 1);\n-\n-\t\t      if (rhs_code == TRUNC_DIV_EXPR)\n-\t\t\t{\n-\t\t\t  t = build_int_cst (NULL_TREE, tree_log2 (op1));\n-\t\t\t  t = build (RSHIFT_EXPR, TREE_TYPE (op0), op0, t);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  t = build_int_cst (TREE_TYPE (op1), 1);\n-\t\t\t  t = int_const_binop (MINUS_EXPR, op1, t, 0);\n-\t\t\t  t = fold_convert (TREE_TYPE (op0), t);\n-\t\t\t  t = build2 (BIT_AND_EXPR, TREE_TYPE (op0), op0, t);\n-\t\t\t}\n-\n-\t\t      TREE_OPERAND (stmt, 1) = t;\n-\t\t      update_stmt (stmt);\n-\t\t    }\n+\t      if (integer_zerop (val))\n+\t\tval = integer_one_node;\n+\t      else if (integer_onep (val))\n+\t\tval = integer_zero_node;\n+\t    }\n+\t}\n+\n+      if (val\n+\t  && (integer_onep (val) || integer_zerop (val)))\n+\t{\n+\t  tree t;\n \n+\t  if (integer_onep (val))\n+\t    t = build1 (NEGATE_EXPR, TREE_TYPE (op), op);\n+\t  else\n+\t    t = op;\n+\n+\t  TREE_OPERAND (stmt, 1) = t;\n+\t  update_stmt (stmt);\n+\t}\n+    }\n+}\n+\n+/* Simplify a conditional using a relational operator to an equality\n+   test if the range information indicates only one value can satisfy\n+   the original conditional.  */\n+\n+static void\n+simplify_cond_using_ranges (tree stmt)\n+{\n+  tree cond = COND_EXPR_COND (stmt);\n+  tree op0 = TREE_OPERAND (cond, 0);\n+  tree op1 = TREE_OPERAND (cond, 1);\n+  enum tree_code cond_code = TREE_CODE (cond);\n+\n+  if (cond_code != NE_EXPR\n+      && cond_code != EQ_EXPR\n+      && TREE_CODE (op0) == SSA_NAME\n+      && INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+      && is_gimple_min_invariant (op1))\n+    {\n+      value_range_t *vr = get_value_range (op0);\n+\t  \n+      /* If we have range information for OP0, then we might be\n+\t able to simplify this conditional. */\n+      if (vr->type == VR_RANGE)\n+\t{\n+\t  tree min = NULL;\n+\t  tree max = NULL;\n+\n+\t  /* Extract minimum/maximum values which satisfy the\n+\t     the conditional as it was written.  */\n+\t  if (cond_code == LE_EXPR || cond_code == LT_EXPR)\n+\t    {\n+\t      min = TYPE_MIN_VALUE (TREE_TYPE (op0));\n+\n+\t      max = op1;\n+\t      if (cond_code == LT_EXPR)\n+\t\t{\n+\t\t  tree one = build_int_cst (TREE_TYPE (op0), 1);\n+\t\t  max = fold (build (MINUS_EXPR, TREE_TYPE (op0), max, one));\n \t\t}\n+\t    }\n+\t  else if (cond_code == GE_EXPR || cond_code == GT_EXPR)\n+\t    {\n+\t      max = TYPE_MAX_VALUE (TREE_TYPE (op0));\n \n-\t      /* Transform ABS (X) into X or -X as appropriate.  */\n-\t      if (rhs_code == ABS_EXPR\n-\t\t  && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n-\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (rhs, 0))))\n+\t      min = op1;\n+\t      if (cond_code == GT_EXPR)\n \t\t{\n-\t\t  tree val = NULL;\n-\t\t  tree op = TREE_OPERAND (rhs, 0);\n-\t\t  tree type = TREE_TYPE (op);\n-\t\t  value_range_t *vr = get_value_range (TREE_OPERAND (rhs, 0));\n-\n-\t\t  if (TYPE_UNSIGNED (type))\n-\t\t    {\n-\t\t      val = integer_zero_node;\n-\t\t    }\n-\t\t  else if (vr)\n-\t\t    {\n-\t\t      val = compare_range_with_value (LE_EXPR, vr,\n-\t\t\t\t\t\t      integer_zero_node);\n-\t\t      if (!val)\n-\t\t\t{\n-\t\t\t  val = compare_range_with_value (GE_EXPR, vr,\n-\t\t\t\t\t\t\t  integer_zero_node);\n-\n-\t\t\t  if (val)\n-\t\t\t    {\n-\t\t\t      if (integer_zerop (val))\n-\t\t\t\tval = integer_one_node;\n-\t\t\t      else if (integer_onep (val))\n-\t\t\t\tval = integer_zero_node;\n-\t\t\t    }\n-\t\t\t}\n-\n-\t\t      if (val\n-\t\t\t  && (integer_onep (val) || integer_zerop (val)))\n-\t\t\t{\n-\t\t\t  tree t;\n-\n-\t\t\t  if (integer_onep (val))\n-\t\t\t    t = build1 (NEGATE_EXPR, TREE_TYPE (op), op);\n-\t\t\t  else\n-\t\t\t    t = op;\n-\n-\t\t\t  TREE_OPERAND (stmt, 1) = t;\n-\t\t\t  update_stmt (stmt);\n-\t\t\t}\n-\t\t    }\n+\t\t  tree one = build_int_cst (TREE_TYPE (op0), 1);\n+\t\t  max = fold (build (PLUS_EXPR, TREE_TYPE (op0), max, one));\n \t\t}\n \t    }\n \n-\t  /* TODO.  Simplify conditionals.   */\n+\t  /* Now refine the minimum and maximum values using any\n+\t     value range information we have for op0.  */\n+\t  if (min && max)\n+\t    {\n+\t      if (compare_values (vr->min, min) == -1)\n+\t\tmin = min;\n+\t      else\n+\t\tmin = vr->min;\n+\t      if (compare_values (vr->max, max) == 1)\n+\t\tmax = max;\n+\t      else\n+\t\tmax = vr->max;\n+\n+\t      /* If the new min/max values have converged to a\n+\t\t single value, then there is only one value which\n+\t\t can satisfy the condition.  Rewrite the condition\n+\t\t to test for equality.  */\n+\t      if (min == max\n+\t\t  && is_gimple_min_invariant (min))\n+\t\t{\n+\t\t  COND_EXPR_COND (stmt)\n+\t\t    = build (EQ_EXPR, boolean_type_node, op0, min);\n+\t\t  update_stmt (stmt);\n+\t\t}\n+\t    }\n \t}\n     }\n }\n \n+/* Simplify STMT using ranges if possible.  */\n+\n+void\n+simplify_stmt_using_ranges (tree stmt)\n+{\n+  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+    {\n+      tree rhs = TREE_OPERAND (stmt, 1);\n+      enum tree_code rhs_code = TREE_CODE (rhs);\n+\n+      /* Transform TRUNC_DIV_EXPR and TRUNC_MOD_EXPR into RSHIFT_EXPR\n+\t and BIT_AND_EXPR respectively if the first operand is greater\n+\t than zero and the second operand is an exact power of two.  */\n+      if ((rhs_code == TRUNC_DIV_EXPR || rhs_code == TRUNC_MOD_EXPR)\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (rhs, 0)))\n+\t  && integer_pow2p (TREE_OPERAND (rhs, 1)))\n+\tsimplify_div_or_mod_using_ranges (stmt, rhs, rhs_code);\n+\n+      /* Transform ABS (X) into X or -X as appropriate.  */\n+      if (rhs_code == ABS_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (rhs, 0))))\n+\tsimplify_abs_using_ranges (stmt, rhs);\n+    }\n+  else if (TREE_CODE (stmt) == COND_EXPR\n+\t   && COMPARISON_CLASS_P (COND_EXPR_COND (stmt)))\n+    {\n+      simplify_cond_using_ranges (stmt);\n+    }\n+}\n+\n+\n \n /* Traverse all the blocks folding conditionals with known ranges.  */\n \n@@ -3657,12 +3741,6 @@ vrp_finalize (void)\n \n   substitute_and_fold (single_val_range, true);\n \n-  /* One could argue all simplifications should be done here\n-     rather than using substitute_and_fold since this code\n-     is going to have to perform a complete walk through the\n-     IL anyway.  */\n-  simplify_using_ranges ();\n-\n   /* Free allocated memory.  */\n   for (i = 0; i < num_ssa_names; i++)\n     if (vr_value[i])"}]}