{"sha": "0ff959e0a2214fa553ac2d06ed66ede62602fc9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZmOTU5ZTBhMjIxNGZhNTUzYWMyZDA2ZWQ2NmVkZTYyNjAyZmM5YQ==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-07-28T02:30:26Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-07-28T02:30:26Z"}, "message": "vect: Refactor peel_iters_{pro,epi}logue cost modeling\n\nThis patch is to refactor the existing peel_iters_prologue and\npeel_iters_epilogue cost model handlings, by following the structure\nbelow suggested by Richard Sandiford:\n\n  - calculate peel_iters_prologue\n  - calculate peel_iters_epilogue\n  - add costs associated with peel_iters_prologue\n  - add costs associated with peel_iters_epilogue\n  - add costs related to branch taken/not_taken.\n\nBootstrapped/regtested on aarch64-linux-gnu.\n\ngcc/ChangeLog:\n\n\t* tree-vect-loop.c (vect_get_known_peeling_cost): Factor out some code\n\tto determine peel_iters_epilogue to...\n\t(vect_get_peel_iters_epilogue): ...this new function.\n\t(vect_estimate_min_profitable_iters): Refactor cost calculation on\n\tpeel_iters_prologue and peel_iters_epilogue.", "tree": {"sha": "8fee3106c81b62594d90dc456f868ca2c6a7965b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fee3106c81b62594d90dc456f868ca2c6a7965b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ff959e0a2214fa553ac2d06ed66ede62602fc9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff959e0a2214fa553ac2d06ed66ede62602fc9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ff959e0a2214fa553ac2d06ed66ede62602fc9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff959e0a2214fa553ac2d06ed66ede62602fc9a/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e71dab87744081714bae2b3abb2e4157beed513d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e71dab87744081714bae2b3abb2e4157beed513d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e71dab87744081714bae2b3abb2e4157beed513d"}], "stats": {"total": 267, "additions": 142, "deletions": 125}, "files": [{"sha": "185019c3305ae9495180ac06c1f3c977b3fbdccf", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 142, "deletions": 125, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff959e0a2214fa553ac2d06ed66ede62602fc9a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff959e0a2214fa553ac2d06ed66ede62602fc9a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=0ff959e0a2214fa553ac2d06ed66ede62602fc9a", "patch": "@@ -3474,42 +3474,56 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n   return NULL;\n }\n \n-/* Calculate cost of peeling the loop PEEL_ITERS_PROLOGUE times.  */\n-int\n-vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n-                             int *peel_iters_epilogue,\n-                             stmt_vector_for_cost *scalar_cost_vec,\n-\t\t\t     stmt_vector_for_cost *prologue_cost_vec,\n-\t\t\t     stmt_vector_for_cost *epilogue_cost_vec)\n+/* Estimate the number of peeled epilogue iterations for LOOP_VINFO.\n+   PEEL_ITERS_PROLOGUE is the number of peeled prologue iterations,\n+   or -1 if not known.  */\n+\n+static int\n+vect_get_peel_iters_epilogue (loop_vec_info loop_vinfo, int peel_iters_prologue)\n {\n-  int retval = 0;\n   int assumed_vf = vect_vf_for_cost (loop_vinfo);\n-\n-  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) || peel_iters_prologue == -1)\n     {\n-      *peel_iters_epilogue = assumed_vf / 2;\n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location,\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"cost model: epilogue peel iters set to vf/2 \"\n \t\t\t \"because loop iterations are unknown .\\n\");\n-\n-      /* If peeled iterations are known but number of scalar loop\n-         iterations are unknown, count a taken branch per peeled loop.  */\n-      retval = record_stmt_cost (prologue_cost_vec, 1, cond_branch_taken,\n-\t\t\t\t NULL, NULL_TREE, 0, vect_prologue);\n-      retval += record_stmt_cost (epilogue_cost_vec, 1, cond_branch_taken,\n-\t\t\t\t  NULL, NULL_TREE, 0, vect_epilogue);\n+      return assumed_vf / 2;\n     }\n   else\n     {\n       int niters = LOOP_VINFO_INT_NITERS (loop_vinfo);\n-      peel_iters_prologue = niters < peel_iters_prologue ?\n-                            niters : peel_iters_prologue;\n-      *peel_iters_epilogue = (niters - peel_iters_prologue) % assumed_vf;\n+      peel_iters_prologue = MIN (niters, peel_iters_prologue);\n+      int peel_iters_epilogue = (niters - peel_iters_prologue) % assumed_vf;\n       /* If we need to peel for gaps, but no peeling is required, we have to\n \t peel VF iterations.  */\n-      if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) && !*peel_iters_epilogue)\n-\t*peel_iters_epilogue = assumed_vf;\n+      if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) && !peel_iters_epilogue)\n+\tpeel_iters_epilogue = assumed_vf;\n+      return peel_iters_epilogue;\n+    }\n+}\n+\n+/* Calculate cost of peeling the loop PEEL_ITERS_PROLOGUE times.  */\n+int\n+vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n+\t\t\t     int *peel_iters_epilogue,\n+\t\t\t     stmt_vector_for_cost *scalar_cost_vec,\n+\t\t\t     stmt_vector_for_cost *prologue_cost_vec,\n+\t\t\t     stmt_vector_for_cost *epilogue_cost_vec)\n+{\n+  int retval = 0;\n+\n+  *peel_iters_epilogue\n+    = vect_get_peel_iters_epilogue (loop_vinfo, peel_iters_prologue);\n+\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+    {\n+      /* If peeled iterations are known but number of scalar loop\n+\t iterations are unknown, count a taken branch per peeled loop.  */\n+      retval = record_stmt_cost (prologue_cost_vec, 1, cond_branch_taken, NULL,\n+\t\t\t\t NULL_TREE, 0, vect_prologue);\n+      retval += record_stmt_cost (epilogue_cost_vec, 1, cond_branch_taken, NULL,\n+\t\t\t\t  NULL_TREE, 0, vect_epilogue);\n     }\n \n   stmt_info_for_cost *si;\n@@ -3652,24 +3666,110 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n      TODO: Build an expression that represents peel_iters for prologue and\n      epilogue to be used in a run-time test.  */\n \n+  bool prologue_need_br_taken_cost = false;\n+  bool prologue_need_br_not_taken_cost = false;\n+\n+  /* Calculate peel_iters_prologue.  */\n   if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+    peel_iters_prologue = 0;\n+  else if (npeel < 0)\n     {\n-      peel_iters_prologue = 0;\n-      peel_iters_epilogue = 0;\n+      peel_iters_prologue = assumed_vf / 2;\n+      if (dump_enabled_p ())\n+\tdump_printf (MSG_NOTE, \"cost model: \"\n+\t\t     \"prologue peel iters set to vf/2.\\n\");\n \n-      if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n-\t{\n-\t  /* We need to peel exactly one iteration.  */\n-\t  peel_iters_epilogue += 1;\n-\t  stmt_info_for_cost *si;\n-\t  int j;\n-\t  FOR_EACH_VEC_ELT (LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n-\t\t\t    j, si)\n-\t    (void) add_stmt_cost (loop_vinfo, target_cost_data, si->count,\n-\t\t\t\t  si->kind, si->stmt_info, si->vectype,\n-\t\t\t\t  si->misalign, vect_epilogue);\n-\t}\n+      /* If peeled iterations are unknown, count a taken branch and a not taken\n+\t branch per peeled loop.  Even if scalar loop iterations are known,\n+\t vector iterations are not known since peeled prologue iterations are\n+\t not known.  Hence guards remain the same.  */\n+      prologue_need_br_taken_cost = true;\n+      prologue_need_br_not_taken_cost = true;\n+    }\n+  else\n+    {\n+      peel_iters_prologue = npeel;\n+      if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+\t/* If peeled iterations are known but number of scalar loop\n+\t   iterations are unknown, count a taken branch per peeled loop.  */\n+\tprologue_need_br_taken_cost = true;\n+    }\n \n+  bool epilogue_need_br_taken_cost = false;\n+  bool epilogue_need_br_not_taken_cost = false;\n+\n+  /* Calculate peel_iters_epilogue.  */\n+  if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n+    /* We need to peel exactly one iteration for gaps.  */\n+    peel_iters_epilogue = LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) ? 1 : 0;\n+  else if (npeel < 0)\n+    {\n+      /* If peeling for alignment is unknown, loop bound of main loop\n+\t becomes unknown.  */\n+      peel_iters_epilogue = assumed_vf / 2;\n+      if (dump_enabled_p ())\n+\tdump_printf (MSG_NOTE, \"cost model: \"\n+\t\t     \"epilogue peel iters set to vf/2 because \"\n+\t\t     \"peeling for alignment is unknown.\\n\");\n+\n+      /* See the same reason above in peel_iters_prologue calculation.  */\n+      epilogue_need_br_taken_cost = true;\n+      epilogue_need_br_not_taken_cost = true;\n+    }\n+  else\n+    {\n+      peel_iters_epilogue = vect_get_peel_iters_epilogue (loop_vinfo, npeel);\n+      if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+\t/* If peeled iterations are known but number of scalar loop\n+\t   iterations are unknown, count a taken branch per peeled loop.  */\n+\tepilogue_need_br_taken_cost = true;\n+    }\n+\n+  stmt_info_for_cost *si;\n+  int j;\n+  /* Add costs associated with peel_iters_prologue.  */\n+  if (peel_iters_prologue)\n+    FOR_EACH_VEC_ELT (LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo), j, si)\n+      {\n+\t(void) add_stmt_cost (loop_vinfo, target_cost_data,\n+\t\t\t      si->count * peel_iters_prologue, si->kind,\n+\t\t\t      si->stmt_info, si->vectype, si->misalign,\n+\t\t\t      vect_prologue);\n+      }\n+\n+  /* Add costs associated with peel_iters_epilogue.  */\n+  if (peel_iters_epilogue)\n+    FOR_EACH_VEC_ELT (LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo), j, si)\n+      {\n+\t(void) add_stmt_cost (loop_vinfo, target_cost_data,\n+\t\t\t      si->count * peel_iters_epilogue, si->kind,\n+\t\t\t      si->stmt_info, si->vectype, si->misalign,\n+\t\t\t      vect_epilogue);\n+      }\n+\n+  /* Add possible cond_branch_taken/cond_branch_not_taken cost.  */\n+\n+  if (prologue_need_br_taken_cost)\n+    (void) add_stmt_cost (loop_vinfo, target_cost_data, 1, cond_branch_taken,\n+\t\t\t  NULL, NULL_TREE, 0, vect_prologue);\n+\n+  if (prologue_need_br_not_taken_cost)\n+    (void) add_stmt_cost (loop_vinfo, target_cost_data, 1,\n+\t\t\t  cond_branch_not_taken, NULL, NULL_TREE, 0,\n+\t\t\t  vect_prologue);\n+\n+  if (epilogue_need_br_taken_cost)\n+    (void) add_stmt_cost (loop_vinfo, target_cost_data, 1, cond_branch_taken,\n+\t\t\t  NULL, NULL_TREE, 0, vect_epilogue);\n+\n+  if (epilogue_need_br_not_taken_cost)\n+    (void) add_stmt_cost (loop_vinfo, target_cost_data, 1,\n+\t\t\t  cond_branch_not_taken, NULL, NULL_TREE, 0,\n+\t\t\t  vect_epilogue);\n+\n+  /* Take care of special costs for rgroup controls of partial vectors.  */\n+  if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+    {\n       /* Calculate how many masks we need to generate.  */\n       unsigned int num_masks = 0;\n       rgroup_controls *rgm;\n@@ -3691,93 +3791,10 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t simpler and safer to use the worst-case cost; if this ends up\n \t being the tie-breaker between vectorizing or not, then it's\n \t probably better not to vectorize.  */\n-      (void) add_stmt_cost (loop_vinfo,\n-\t\t\t    target_cost_data, num_masks, vector_stmt,\n-\t\t\t    NULL, NULL_TREE, 0, vect_prologue);\n-      (void) add_stmt_cost (loop_vinfo,\n-\t\t\t    target_cost_data, num_masks - 1, vector_stmt,\n-\t\t\t    NULL, NULL_TREE, 0, vect_body);\n-    }\n-  else if (LOOP_VINFO_FULLY_WITH_LENGTH_P (loop_vinfo))\n-    {\n-      peel_iters_prologue = 0;\n-      peel_iters_epilogue = 0;\n-    }\n-  else if (npeel < 0)\n-    {\n-      peel_iters_prologue = assumed_vf / 2;\n-      if (dump_enabled_p ())\n-\tdump_printf (MSG_NOTE, \"cost model: \"\n-\t\t     \"prologue peel iters set to vf/2.\\n\");\n-\n-      /* If peeling for alignment is unknown, loop bound of main loop becomes\n-         unknown.  */\n-      peel_iters_epilogue = assumed_vf / 2;\n-      if (dump_enabled_p ())\n-\tdump_printf (MSG_NOTE, \"cost model: \"\n-\t\t     \"epilogue peel iters set to vf/2 because \"\n-\t\t     \"peeling for alignment is unknown.\\n\");\n-\n-      /* If peeled iterations are unknown, count a taken branch and a not taken\n-         branch per peeled loop. Even if scalar loop iterations are known,\n-         vector iterations are not known since peeled prologue iterations are\n-         not known. Hence guards remain the same.  */\n-      (void) add_stmt_cost (loop_vinfo, target_cost_data, 1, cond_branch_taken,\n-\t\t\t    NULL, NULL_TREE, 0, vect_prologue);\n-      (void) add_stmt_cost (loop_vinfo,\n-\t\t\t    target_cost_data, 1, cond_branch_not_taken,\n-\t\t\t    NULL, NULL_TREE, 0, vect_prologue);\n-      (void) add_stmt_cost (loop_vinfo, target_cost_data, 1, cond_branch_taken,\n-\t\t\t    NULL, NULL_TREE, 0, vect_epilogue);\n-      (void) add_stmt_cost (loop_vinfo,\n-\t\t\t    target_cost_data, 1, cond_branch_not_taken,\n-\t\t\t    NULL, NULL_TREE, 0, vect_epilogue);\n-      stmt_info_for_cost *si;\n-      int j;\n-      FOR_EACH_VEC_ELT (LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo), j, si)\n-\t{\n-\t  (void) add_stmt_cost (loop_vinfo, target_cost_data,\n-\t\t\t\tsi->count * peel_iters_prologue,\n-\t\t\t\tsi->kind, si->stmt_info, si->vectype,\n-\t\t\t\tsi->misalign,\n-\t\t\t\tvect_prologue);\n-\t  (void) add_stmt_cost (loop_vinfo, target_cost_data,\n-\t\t\t\tsi->count * peel_iters_epilogue,\n-\t\t\t\tsi->kind, si->stmt_info, si->vectype,\n-\t\t\t\tsi->misalign,\n-\t\t\t\tvect_epilogue);\n-\t}\n-    }\n-  else\n-    {\n-      stmt_vector_for_cost prologue_cost_vec, epilogue_cost_vec;\n-      stmt_info_for_cost *si;\n-      int j;\n-      void *data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n-\n-      prologue_cost_vec.create (2);\n-      epilogue_cost_vec.create (2);\n-      peel_iters_prologue = npeel;\n-\n-      (void) vect_get_known_peeling_cost (loop_vinfo, peel_iters_prologue,\n-\t\t\t\t\t  &peel_iters_epilogue,\n-\t\t\t\t\t  &LOOP_VINFO_SCALAR_ITERATION_COST\n-\t\t\t\t\t    (loop_vinfo),\n-\t\t\t\t\t  &prologue_cost_vec,\n-\t\t\t\t\t  &epilogue_cost_vec);\n-\n-      FOR_EACH_VEC_ELT (prologue_cost_vec, j, si)\n-\t(void) add_stmt_cost (loop_vinfo,\n-\t\t\t      data, si->count, si->kind, si->stmt_info,\n-\t\t\t      si->vectype, si->misalign, vect_prologue);\n-\n-      FOR_EACH_VEC_ELT (epilogue_cost_vec, j, si)\n-\t(void) add_stmt_cost (loop_vinfo,\n-\t\t\t      data, si->count, si->kind, si->stmt_info,\n-\t\t\t      si->vectype, si->misalign, vect_epilogue);\n-\n-      prologue_cost_vec.release ();\n-      epilogue_cost_vec.release ();\n+      (void) add_stmt_cost (loop_vinfo, target_cost_data, num_masks,\n+\t\t\t    vector_stmt, NULL, NULL_TREE, 0, vect_prologue);\n+      (void) add_stmt_cost (loop_vinfo, target_cost_data, num_masks - 1,\n+\t\t\t    vector_stmt, NULL, NULL_TREE, 0, vect_body);\n     }\n \n   /* FORNOW: The scalar outside cost is incremented in one of the"}]}