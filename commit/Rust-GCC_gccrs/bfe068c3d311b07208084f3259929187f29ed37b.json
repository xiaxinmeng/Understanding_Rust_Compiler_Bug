{"sha": "bfe068c3d311b07208084f3259929187f29ed37b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZlMDY4YzNkMzExYjA3MjA4MDg0ZjMyNTk5MjkxODdmMjllZDM3Yg==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-03-24T08:23:39Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-03-24T08:23:39Z"}, "message": "invoke.texi (max-stores-to-sink): Document.\n\n\n        * doc/invoke.texi (max-stores-to-sink): Document.\n        * params.h (MAX_STORES_TO_SINK): Define.\n        * opts.c (finish_options): Set MAX_STORES_TO_SINK to 0\n        if either vectorization or if-conversion is disabled.\n        * tree-data-ref.c (dr_equal_offsets_p1): Moved and renamed from\n        tree-vect-data-refs.c vect_equal_offsets.\n        (dr_equal_offsets_p): New function.\n        (find_data_references_in_bb): Remove static.\n        * tree-data-ref.h (find_data_references_in_bb): Declare.\n        (dr_equal_offsets_p): Likewise.\n        * tree-vect-data-refs.c (vect_equal_offsets): Move to\n        tree-data-ref.c.\n        (vect_drs_dependent_in_basic_block): Update calls to\n        vect_equal_offsets.\n        (vect_check_interleaving): Likewise.\n        * tree-ssa-phiopt.c: Include cfgloop.h and tree-data-ref.h.\n        (cond_if_else_store_replacement): Rename to...\n        (cond_if_else_store_replacement_1): ... this.  Change arguments\n        and documentation.\n        (cond_if_else_store_replacement): New function.\n        * Makefile.in (tree-ssa-phiopt.o): Adjust dependencies.\n        * params.def (PARAM_MAX_STORES_TO_SINK): Define.\n\nFrom-SVN: r171381", "tree": {"sha": "afb8a3198cdee843553c12f114920b4078828339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afb8a3198cdee843553c12f114920b4078828339"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfe068c3d311b07208084f3259929187f29ed37b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe068c3d311b07208084f3259929187f29ed37b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfe068c3d311b07208084f3259929187f29ed37b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe068c3d311b07208084f3259929187f29ed37b/comments", "author": null, "committer": null, "parents": [{"sha": "3137991dfc4e0b6023c4b75b2ae1eb86bea32241", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3137991dfc4e0b6023c4b75b2ae1eb86bea32241", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3137991dfc4e0b6023c4b75b2ae1eb86bea32241"}], "stats": {"total": 495, "additions": 437, "deletions": 58}, "files": [{"sha": "5cd6e3def5dd61e54c927cdf96ebc20a63c9c3fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -1,3 +1,27 @@\n+2011-03-24  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* doc/invoke.texi (max-stores-to-sink): Document.\n+\t* params.h (MAX_STORES_TO_SINK): Define.\n+\t* opts.c (finish_options): Set MAX_STORES_TO_SINK to 0\n+\tif either vectorization or if-conversion is disabled.\n+\t* tree-data-ref.c (dr_equal_offsets_p1): Moved and renamed from\n+\ttree-vect-data-refs.c vect_equal_offsets.\n+\t(dr_equal_offsets_p): New function.\n+\t(find_data_references_in_bb): Remove static.\n+\t* tree-data-ref.h (find_data_references_in_bb): Declare.\n+\t(dr_equal_offsets_p): Likewise.\n+\t* tree-vect-data-refs.c (vect_equal_offsets): Move to tree-data-ref.c.\n+\t(vect_drs_dependent_in_basic_block): Update calls to\n+\tvect_equal_offsets.\n+\t(vect_check_interleaving): Likewise.\n+\t* tree-ssa-phiopt.c: Include cfgloop.h and tree-data-ref.h.\n+\t(cond_if_else_store_replacement): Rename to...\n+\t(cond_if_else_store_replacement_1): ... this.  Change arguments and\n+\tdocumentation.\n+\t(cond_if_else_store_replacement): New function.\n+\t* Makefile.in (tree-ssa-phiopt.o): Adjust dependencies.\n+\t* params.def (PARAM_MAX_STORES_TO_SINK): Define.\n+\n 2011-03-23  Chung-Lin Tang  <cltang@codesourcery.com>\n \n \tPR target/46934"}, {"sha": "5e4027e50708fcde7cd9d077dd227a94320e32fb", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -2419,7 +2419,8 @@ tree-ssa-ifcombine.o : tree-ssa-ifcombine.c $(CONFIG_H) $(SYSTEM_H) \\\n tree-ssa-phiopt.o : tree-ssa-phiopt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_DUMP_H) langhooks.h $(FLAGS_H) \\\n-   $(DIAGNOSTIC_H) $(TIMEVAR_H) pointer-set.h domwalk.h\n+   $(DIAGNOSTIC_H) $(TIMEVAR_H) pointer-set.h domwalk.h $(CFGLOOP_H) \\\n+   $(TREE_DATA_REF_H)\n tree-nrv.o : tree-nrv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) $(FUNCTION_H) $(BASIC_BLOCK_H) $(FLAGS_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TREE_DUMP_H) $(TREE_PASS_H) \\"}, {"sha": "925455d0e30e31ab50b95f734114dc2a0e1fab96", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -8868,6 +8868,11 @@ partitions.\n The maximum number of namespaces to consult for suggestions when C++\n name lookup fails for an identifier.  The default is 1000.\n \n+@item max-stores-to-sink\n+The maximum number of conditional stores paires that can be sunk.  Set to 0\n+if either vectorization (@option{-ftree-vectorize}) or if-conversion\n+(@option{-ftree-loop-if-convert}) is disabled.  The default is 2.\n+\n @end table\n @end table\n "}, {"sha": "165d7ec3a553113971b9ffe5f683ad75fa2e52f4", "filename": "gcc/opts.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -814,6 +814,12 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n \t  opts->x_flag_split_stack = 0;\n \t}\n     }\n+\n+  /* Set PARAM_MAX_STORES_TO_SINK to 0 if either vectorization or if-conversion\n+     is disabled.  */\n+  if (!opts->x_flag_tree_vectorize || !opts->x_flag_tree_loop_if_convert)\n+    maybe_set_param_value (PARAM_MAX_STORES_TO_SINK, 0,\n+                           opts->x_param_values, opts_set->x_param_values);\n }\n \n #define LEFT_COLUMN\t27"}, {"sha": "81fdfcdf500ac79c782d80a50626d62d95694fda", "filename": "gcc/params.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -873,6 +873,13 @@ DEFPARAM (CXX_MAX_NAMESPACES_FOR_DIAGNOSTIC_HELP,\n \t  \"name lookup fails\",\n \t  1000, 0, 0)\n \n+/* Maximum number of conditional store pairs that can be sunk.  */\n+DEFPARAM (PARAM_MAX_STORES_TO_SINK,\n+          \"max-stores-to-sink\",\n+          \"Maximum number of conditional store pairs that can be sunk\",\n+          2, 0, 0)\n+\n+\n /*\n Local variables:\n mode:c"}, {"sha": "98a64fd0bb16187c26891d177328e45083f93713", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -204,4 +204,6 @@ extern void init_param_values (int *params);\n   PARAM_VALUE (PARAM_PREFETCH_MIN_INSN_TO_MEM_RATIO)\n #define MIN_NONDEBUG_INSN_UID \\\n   PARAM_VALUE (PARAM_MIN_NONDEBUG_INSN_UID)\n+#define MAX_STORES_TO_SINK \\\n+  PARAM_VALUE (PARAM_MAX_STORES_TO_SINK)\n #endif /* ! GCC_PARAMS_H */"}, {"sha": "87a8da95e51283fd19f601b740d4372626a8563a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -1,3 +1,8 @@\n+2011-03-24  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* gcc.dg/vect/vect-cselim-1.c: New test.\n+\t* gcc.dg/vect/vect-cselim-2.c: New test.\n+\n 2011-03-23  Chung-Lin Tang  <cltang@codesourcery.com>\n \n \t* gcc.target/arm/pr46934.c: New."}, {"sha": "cf7e68c307ad3e59b50ac891a1532c5831710355", "filename": "gcc/testsuite/gcc.dg/vect/vect-cselim-1.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cselim-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cselim-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cselim-1.c?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 50\n+\n+typedef struct {\n+  short a;\n+  short b;\n+} data;\n+\n+data in1[N], in2[N], out[N];\n+short result[N*2] = {7,-7,9,-6,11,-5,13,-4,15,-3,17,-2,19,-1,21,0,23,1,25,2,27,3,29,4,31,5,33,6,35,7,37,8,39,9,41,10,43,11,45,12,47,13,49,14,51,15,53,16,55,17,57,18,59,19,61,20,63,21,65,22,67,23,69,24,71,25,73,26,75,27,77,28,79,29,81,30,83,31,85,32,87,33,89,34,91,35,93,36,95,37,97,38,99,39,101,40,103,41,105,42};\n+short out1[N], out2[N];\n+\n+__attribute__ ((noinline)) void\n+foo ()\n+{\n+  int i;\n+  short c, d;\n+\n+  /* Vectorizable with conditional store sinking.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      c = in1[i].b;\n+      d = in2[i].b;\n+\n+      if (c >= d)\n+        {\n+          out[i].b = c;\n+          out[i].a = d + 5;\n+        }\n+      else\n+        {\n+          out[i].b = d - 12;\n+          out[i].a = c + d;\n+        }\n+    }\n+\n+  /* Not vectorizable.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      c = in1[i].b;\n+      d = in2[i].b;\n+\n+      if (c >= d)\n+        {\n+          out1[i] = c;\n+        }\n+      else\n+        {\n+          out2[i] = c + d;\n+        }\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in1[i].a = i;\n+      in1[i].b = i + 2;\n+      in2[i].a = 5;\n+      in2[i].b = i + 5;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i].a != result[2*i] || out[i].b != result[2*i+1])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "accfcf398c6942d6a60ea95bd0c5a87aab5434e3", "filename": "gcc/testsuite/gcc.dg/vect/vect-cselim-2.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cselim-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cselim-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cselim-2.c?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 50\n+\n+int a[N], b[N], in1[N], in2[N];\n+int result[2*N] = {5,-7,7,-6,9,-5,11,-4,13,-3,15,-2,17,-1,19,0,21,1,23,2,25,3,27,4,29,5,31,6,33,7,35,8,37,9,39,10,41,11,43,12,45,13,47,14,49,15,51,16,53,17,55,18,57,19,59,20,61,21,63,22,65,23,67,24,69,25,71,26,73,27,75,28,77,29,79,30,81,31,83,32,85,33,87,34,89,35,91,36,93,37,95,38,97,39,99,40,101,41,103,42};\n+\n+__attribute__ ((noinline)) void\n+foo (int *pa, int *pb)\n+{\n+  int i;\n+  int c, d;\n+\n+  /* Store sinking should not work here since the pointers may alias.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      c = in1[i];\n+      d = in2[i];\n+\n+      if (c >= d)\n+        {\n+          *pa = c;\n+          *pb = d + 5;\n+        }\n+      else\n+        {\n+          *pb = d - 12;\n+          *pa = c + d;\n+        }\n+\n+      pa++;\n+      pb++;\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in1[i] = i;\n+      in2[i] = i + 5;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (a, b);\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (a[i] != result[2*i] || b[i] != result[2*i+1])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e01c67722f76f39225e3dd0969b818447a9fc9bc", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -991,6 +991,48 @@ create_data_ref (loop_p nest, loop_p loop, tree memref, gimple stmt,\n   return dr;\n }\n \n+/* Check if OFFSET1 and OFFSET2 (DR_OFFSETs of some data-refs) are identical\n+   expressions.  */\n+static bool\n+dr_equal_offsets_p1 (tree offset1, tree offset2)\n+{\n+  bool res;\n+\n+  STRIP_NOPS (offset1);\n+  STRIP_NOPS (offset2);\n+\n+  if (offset1 == offset2)\n+    return true;\n+\n+  if (TREE_CODE (offset1) != TREE_CODE (offset2)\n+      || (!BINARY_CLASS_P (offset1) && !UNARY_CLASS_P (offset1)))\n+    return false;\n+\n+  res = dr_equal_offsets_p1 (TREE_OPERAND (offset1, 0),\n+                             TREE_OPERAND (offset2, 0));\n+\n+  if (!res || !BINARY_CLASS_P (offset1))\n+    return res;\n+\n+  res = dr_equal_offsets_p1 (TREE_OPERAND (offset1, 1),\n+                             TREE_OPERAND (offset2, 1));\n+\n+  return res;\n+}\n+\n+/* Check if DRA and DRB have equal offsets.  */\n+bool\n+dr_equal_offsets_p (struct data_reference *dra,\n+                    struct data_reference *drb)\n+{\n+  tree offset1, offset2;\n+\n+  offset1 = DR_OFFSET (dra);\n+  offset2 = DR_OFFSET (drb);\n+\n+  return dr_equal_offsets_p1 (offset1, offset2);\n+}\n+\n /* Returns true if FNA == FNB.  */\n \n static bool\n@@ -4294,7 +4336,7 @@ graphite_find_data_references_in_stmt (loop_p nest, loop_p loop, gimple stmt,\n    DATAREFS.  Returns chrec_dont_know when failing to analyze a\n    difficult case, returns NULL_TREE otherwise.  */\n \n-static tree\n+tree\n find_data_references_in_bb (struct loop *loop, basic_block bb,\n                             VEC (data_reference_p, heap) **datarefs)\n {"}, {"sha": "0588136cb8d452dba3af49b4080e1866195156f2", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -426,10 +426,14 @@ extern bool find_loop_nest (struct loop *, VEC (loop_p, heap) **);\n extern void compute_all_dependences (VEC (data_reference_p, heap) *,\n \t\t\t\t     VEC (ddr_p, heap) **, VEC (loop_p, heap) *,\n \t\t\t\t     bool);\n+extern tree find_data_references_in_bb (struct loop *, basic_block,\n+                                        VEC (data_reference_p, heap) **);\n \n extern void create_rdg_vertices (struct graph *, VEC (gimple, heap) *);\n extern bool dr_may_alias_p (const struct data_reference *,\n \t\t\t    const struct data_reference *);\n+extern bool dr_equal_offsets_p (struct data_reference *,\n+                                struct data_reference *);\n \n \n /* Return true when the base objects of data references A and B are"}, {"sha": "77ce5b02f7baf75c195594959e51ce7e8035edb6", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 186, "deletions": 21, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -34,6 +34,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"pointer-set.h\"\n #include \"domwalk.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-data-ref.h\"\n \n static unsigned int tree_ssa_phiopt (void);\n static unsigned int tree_ssa_phiopt_worker (bool);\n@@ -1304,35 +1306,18 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n   return true;\n }\n \n-/* Do the main work of conditional store replacement.  We already know\n-   that the recognized pattern looks like so:\n-\n-   split:\n-     if (cond) goto THEN_BB; else goto ELSE_BB (edge E1)\n-   THEN_BB:\n-     X = Y;\n-     goto JOIN_BB;\n-   ELSE_BB:\n-     X = Z;\n-     fallthrough (edge E0)\n-   JOIN_BB:\n-     some more\n-\n-   We check that THEN_BB and ELSE_BB contain only one store\n-   that the stores have a \"simple\" RHS.  */\n+/* Do the main work of conditional store replacement.  */\n \n static bool\n-cond_if_else_store_replacement (basic_block then_bb, basic_block else_bb,\n-\t\t\t\tbasic_block join_bb)\n+cond_if_else_store_replacement_1 (basic_block then_bb, basic_block else_bb,\n+\t\t\t\t  basic_block join_bb, gimple then_assign,\n+\t\t\t\t  gimple else_assign)\n {\n-  gimple then_assign = last_and_only_stmt (then_bb);\n-  gimple else_assign = last_and_only_stmt (else_bb);\n   tree lhs_base, lhs, then_rhs, else_rhs;\n   source_location then_locus, else_locus;\n   gimple_stmt_iterator gsi;\n   gimple newphi, new_stmt;\n \n-  /* Check if then_bb and else_bb contain only one store each.  */\n   if (then_assign == NULL\n       || !gimple_assign_single_p (then_assign)\n       || else_assign == NULL\n@@ -1397,6 +1382,186 @@ cond_if_else_store_replacement (basic_block then_bb, basic_block else_bb,\n   return true;\n }\n \n+/* Conditional store replacement.  We already know\n+   that the recognized pattern looks like so:\n+\n+   split:\n+     if (cond) goto THEN_BB; else goto ELSE_BB (edge E1)\n+   THEN_BB:\n+     ...\n+     X = Y;\n+     ...\n+     goto JOIN_BB;\n+   ELSE_BB:\n+     ...\n+     X = Z;\n+     ...\n+     fallthrough (edge E0)\n+   JOIN_BB:\n+     some more\n+\n+   We check that it is safe to sink the store to JOIN_BB by verifying that\n+   there are no read-after-write or write-after-write dependencies in\n+   THEN_BB and ELSE_BB.  */\n+\n+static bool\n+cond_if_else_store_replacement (basic_block then_bb, basic_block else_bb,\n+                                basic_block join_bb)\n+{\n+  gimple then_assign = last_and_only_stmt (then_bb);\n+  gimple else_assign = last_and_only_stmt (else_bb);\n+  VEC (data_reference_p, heap) *then_datarefs, *else_datarefs;\n+  VEC (ddr_p, heap) *then_ddrs, *else_ddrs;\n+  gimple then_store, else_store;\n+  bool found, ok = false, res;\n+  struct data_dependence_relation *ddr;\n+  data_reference_p then_dr, else_dr;\n+  int i, j;\n+  tree then_lhs, else_lhs;\n+  VEC (gimple, heap) *then_stores, *else_stores;\n+  basic_block blocks[3];\n+\n+  if (MAX_STORES_TO_SINK == 0)\n+    return false;\n+\n+  /* Handle the case with single statement in THEN_BB and ELSE_BB.  */\n+  if (then_assign && else_assign)\n+    return cond_if_else_store_replacement_1 (then_bb, else_bb, join_bb,\n+                                             then_assign, else_assign);\n+\n+  /* Find data references.  */\n+  then_datarefs = VEC_alloc (data_reference_p, heap, 1);\n+  else_datarefs = VEC_alloc (data_reference_p, heap, 1);\n+  if ((find_data_references_in_bb (NULL, then_bb, &then_datarefs)\n+        == chrec_dont_know)\n+      || !VEC_length (data_reference_p, then_datarefs)\n+      || (find_data_references_in_bb (NULL, else_bb, &else_datarefs)\n+        == chrec_dont_know)\n+      || !VEC_length (data_reference_p, else_datarefs))\n+    {\n+      free_data_refs (then_datarefs);\n+      free_data_refs (else_datarefs);\n+      return false;\n+    }\n+\n+  /* Find pairs of stores with equal LHS.  */\n+  then_stores = VEC_alloc (gimple, heap, 1);\n+  else_stores = VEC_alloc (gimple, heap, 1);\n+  FOR_EACH_VEC_ELT (data_reference_p, then_datarefs, i, then_dr)\n+    {\n+      if (DR_IS_READ (then_dr))\n+        continue;\n+\n+      then_store = DR_STMT (then_dr);\n+      then_lhs = gimple_assign_lhs (then_store);\n+      found = false;\n+\n+      FOR_EACH_VEC_ELT (data_reference_p, else_datarefs, j, else_dr)\n+        {\n+          if (DR_IS_READ (else_dr))\n+            continue;\n+\n+          else_store = DR_STMT (else_dr);\n+          else_lhs = gimple_assign_lhs (else_store);\n+\n+          if (operand_equal_p (then_lhs, else_lhs, 0))\n+            {\n+              found = true;\n+              break;\n+            }\n+        }\n+\n+      if (!found)\n+        continue;\n+\n+      VEC_safe_push (gimple, heap, then_stores, then_store);\n+      VEC_safe_push (gimple, heap, else_stores, else_store);\n+    }\n+\n+  /* No pairs of stores found.  */\n+  if (!VEC_length (gimple, then_stores)\n+      || VEC_length (gimple, then_stores) > (unsigned) MAX_STORES_TO_SINK)\n+    {\n+      free_data_refs (then_datarefs);\n+      free_data_refs (else_datarefs);\n+      VEC_free (gimple, heap, then_stores);\n+      VEC_free (gimple, heap, else_stores);\n+      return false;\n+    }\n+\n+  /* Compute and check data dependencies in both basic blocks.  */\n+  then_ddrs = VEC_alloc (ddr_p, heap, 1);\n+  else_ddrs = VEC_alloc (ddr_p, heap, 1);\n+  compute_all_dependences (then_datarefs, &then_ddrs, NULL, false);\n+  compute_all_dependences (else_datarefs, &else_ddrs, NULL, false);\n+  free_data_refs (then_datarefs);\n+  free_data_refs (else_datarefs);\n+  blocks[0] = then_bb;\n+  blocks[1] = else_bb;\n+  blocks[2] = join_bb;\n+  renumber_gimple_stmt_uids_in_blocks (blocks, 3);\n+\n+  /* Check that there are no read-after-write or write-after-write dependencies\n+     in THEN_BB.  */\n+  FOR_EACH_VEC_ELT (ddr_p, then_ddrs, i, ddr)\n+    {\n+      struct data_reference *dra = DDR_A (ddr);\n+      struct data_reference *drb = DDR_B (ddr);\n+\n+      if (DDR_ARE_DEPENDENT (ddr) != chrec_known\n+          && ((DR_IS_READ (dra) && DR_IS_WRITE (drb)\n+               && gimple_uid (DR_STMT (dra)) > gimple_uid (DR_STMT (drb)))\n+              || (DR_IS_READ (drb) && DR_IS_WRITE (dra)\n+                  && gimple_uid (DR_STMT (drb)) > gimple_uid (DR_STMT (dra)))\n+              || (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))))\n+        {\n+          free_dependence_relations (then_ddrs);\n+          free_dependence_relations (else_ddrs);\n+          VEC_free (gimple, heap, then_stores);\n+          VEC_free (gimple, heap, else_stores);\n+          return false;\n+        }\n+    }\n+\n+  /* Check that there are no read-after-write or write-after-write dependencies\n+     in ELSE_BB.  */\n+  FOR_EACH_VEC_ELT (ddr_p, else_ddrs, i, ddr)\n+    {\n+      struct data_reference *dra = DDR_A (ddr);\n+      struct data_reference *drb = DDR_B (ddr);\n+\n+      if (DDR_ARE_DEPENDENT (ddr) != chrec_known\n+          && ((DR_IS_READ (dra) && DR_IS_WRITE (drb)\n+               && gimple_uid (DR_STMT (dra)) > gimple_uid (DR_STMT (drb)))\n+              || (DR_IS_READ (drb) && DR_IS_WRITE (dra)\n+                  && gimple_uid (DR_STMT (drb)) > gimple_uid (DR_STMT (dra)))\n+              || (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))))\n+        {\n+          free_dependence_relations (then_ddrs);\n+          free_dependence_relations (else_ddrs);\n+          VEC_free (gimple, heap, then_stores);\n+          VEC_free (gimple, heap, else_stores);\n+          return false;\n+        }\n+    }\n+\n+  /* Sink stores with same LHS.  */\n+  FOR_EACH_VEC_ELT (gimple, then_stores, i, then_store)\n+    {\n+      else_store = VEC_index (gimple, else_stores, i);\n+      res = cond_if_else_store_replacement_1 (then_bb, else_bb, join_bb,\n+                                              then_store, else_store);\n+      ok = ok || res;\n+    }\n+\n+  free_dependence_relations (then_ddrs);\n+  free_dependence_relations (else_ddrs);\n+  VEC_free (gimple, heap, then_stores);\n+  VEC_free (gimple, heap, else_stores);\n+\n+  return ok;\n+}\n+\n /* Always do these optimizations if we have SSA\n    trees to work on.  */\n static bool"}, {"sha": "d4ba704f45989b51cd25ee16f7f8cf3585784a56", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe068c3d311b07208084f3259929187f29ed37b/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=bfe068c3d311b07208084f3259929187f29ed37b", "patch": "@@ -289,39 +289,6 @@ vect_update_interleaving_chain (struct data_reference *drb,\n     }\n }\n \n-\n-/* Function vect_equal_offsets.\n-\n-   Check if OFFSET1 and OFFSET2 are identical expressions.  */\n-\n-static bool\n-vect_equal_offsets (tree offset1, tree offset2)\n-{\n-  bool res;\n-\n-  STRIP_NOPS (offset1);\n-  STRIP_NOPS (offset2);\n-\n-  if (offset1 == offset2)\n-    return true;\n-\n-  if (TREE_CODE (offset1) != TREE_CODE (offset2)\n-      || (!BINARY_CLASS_P (offset1) && !UNARY_CLASS_P (offset1)))\n-    return false;\n-\n-  res = vect_equal_offsets (TREE_OPERAND (offset1, 0),\n-\t\t\t    TREE_OPERAND (offset2, 0));\n-\n-  if (!res || !BINARY_CLASS_P (offset1))\n-    return res;\n-\n-  res = vect_equal_offsets (TREE_OPERAND (offset1, 1),\n-\t\t\t    TREE_OPERAND (offset2, 1));\n-\n-  return res;\n-}\n-\n-\n /* Check dependence between DRA and DRB for basic block vectorization.\n    If the accesses share same bases and offsets, we can compare their initial\n    constant offsets to decide whether they differ or not.  In case of a read-\n@@ -352,7 +319,7 @@ vect_drs_dependent_in_basic_block (struct data_reference *dra,\n            || TREE_CODE (DR_BASE_ADDRESS (drb)) != ADDR_EXPR\n            || TREE_OPERAND (DR_BASE_ADDRESS (dra), 0)\n            != TREE_OPERAND (DR_BASE_ADDRESS (drb),0)))\n-      || !vect_equal_offsets (DR_OFFSET (dra), DR_OFFSET (drb)))\n+      || !dr_equal_offsets_p (dra, drb))\n     return true;\n \n   /* Check the types.  */\n@@ -402,7 +369,7 @@ vect_check_interleaving (struct data_reference *dra,\n \t   || TREE_CODE (DR_BASE_ADDRESS (drb)) != ADDR_EXPR\n \t   || TREE_OPERAND (DR_BASE_ADDRESS (dra), 0)\n \t   != TREE_OPERAND (DR_BASE_ADDRESS (drb),0)))\n-      || !vect_equal_offsets (DR_OFFSET (dra), DR_OFFSET (drb))\n+      || !dr_equal_offsets_p (dra, drb)\n       || !tree_int_cst_compare (DR_INIT (dra), DR_INIT (drb))\n       || DR_IS_READ (dra) != DR_IS_READ (drb))\n     return false;"}]}