{"sha": "1ab3acf4666620a8f37107698cd01a2a4a716552", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFiM2FjZjQ2NjY2MjBhOGYzNzEwNzY5OGNkMDFhMmE0YTcxNjU1Mg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2010-11-30T21:33:32Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2010-11-30T21:33:32Z"}, "message": "PR fortran/28105 Overflow check for ALLOCATE statement\n\nFrom-SVN: r167317", "tree": {"sha": "4d19816365fd5fe94ce7042e4f39a21217df63f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d19816365fd5fe94ce7042e4f39a21217df63f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ab3acf4666620a8f37107698cd01a2a4a716552", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ab3acf4666620a8f37107698cd01a2a4a716552", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ab3acf4666620a8f37107698cd01a2a4a716552", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ab3acf4666620a8f37107698cd01a2a4a716552/comments", "author": null, "committer": null, "parents": [{"sha": "16d5e7d506d140ef004422b2cffe36b2c98403c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d5e7d506d140ef004422b2cffe36b2c98403c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16d5e7d506d140ef004422b2cffe36b2c98403c9"}], "stats": {"total": 150, "additions": 139, "deletions": 11}, "files": [{"sha": "8b761ecec2acef5c4066d2cd4503441e60cb6050", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ab3acf4666620a8f37107698cd01a2a4a716552/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ab3acf4666620a8f37107698cd01a2a4a716552/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1ab3acf4666620a8f37107698cd01a2a4a716552", "patch": "@@ -1,3 +1,12 @@\n+2010-11-30  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/28105\n+\t* trans-array.c (gfc_unlikely): Helper function to mark boolean\n+\texpr as unlikely.\n+\t(gfc_array_index_size): Check whether the size overflows.\n+\t(gfc_array_allocate): Check whether size overflows and generate\n+\terror.\n+\n 2010-11-30  Joseph Myers  <joseph@codesourcery.com>\n \n \t* trans-common.c: Don't include toplev.h."}, {"sha": "c768058a457e60547ef0196cccb88bab24c7386b", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 130, "deletions": 11, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ab3acf4666620a8f37107698cd01a2a4a716552/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ab3acf4666620a8f37107698cd01a2a4a716552/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=1ab3acf4666620a8f37107698cd01a2a4a716552", "patch": "@@ -3950,9 +3950,26 @@ gfc_conv_descriptor_size (tree desc, int rank)\n }\n \n \n-/* Fills in an array descriptor, and returns the size of the array.  The size\n-   will be a simple_val, ie a variable or a constant.  Also calculates the\n-   offset of the base.  Returns the size of the array.\n+/* Helper function for marking a boolean expression tree as unlikely.  */\n+\n+static tree\n+gfc_unlikely (tree cond)\n+{\n+  tree tmp;\n+\n+  cond = fold_convert (long_integer_type_node, cond);\n+  tmp = build_zero_cst (long_integer_type_node);\n+  cond = build_call_expr_loc (input_location,\n+\t\t\t      built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n+  cond = fold_convert (boolean_type_node, cond);\n+  return cond;\n+}\n+\n+/* Fills in an array descriptor, and returns the size of the array.\n+   The size will be a simple_val, ie a variable or a constant.  Also\n+   calculates the offset of the base.  The pointer argument overflow,\n+   which should be of integer type, will increase in value if overflow\n+   occurs during the size calculation.  Returns the size of the array.\n    {\n     stride = 1;\n     offset = 0;\n@@ -3964,22 +3981,28 @@ gfc_conv_descriptor_size (tree desc, int rank)\n \ta.ubound[n] = specified_upper_bound;\n \ta.stride[n] = stride;\n \tsize = siz >= 0 ? ubound + size : 0; //size = ubound + 1 - lbound\n+\toverflow += size == 0 ? 0: (MAX/size < stride ? 1: 0);\n \tstride = stride * size;\n       }\n+    element_size = sizeof (array element);\n+    stride = (size_t) stride;\n+    overflow += element_size == 0 ? 0: (MAX/element_size < stride ? 1: 0);\n+    stride = stride * element_size;\n     return (stride);\n    }  */\n /*GCC ARRAYS*/\n \n static tree\n gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t\t     gfc_expr ** lower, gfc_expr ** upper,\n-\t\t     stmtblock_t * pblock)\n+\t\t     stmtblock_t * pblock, tree * overflow)\n {\n   tree type;\n   tree tmp;\n   tree size;\n   tree offset;\n   tree stride;\n+  tree element_size;\n   tree or_expr;\n   tree thencase;\n   tree elsecase;\n@@ -4056,7 +4079,33 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \n       /* Calculate size and check whether extent is negative.  */\n       size = gfc_conv_array_extent_dim (conv_lbound, conv_ubound, &or_expr);\n-\n+      size = gfc_evaluate_now (size, pblock);\n+\n+      /* Check whether multiplying the stride by the number of\n+\t elements in this dimension would overflow. We must also check\n+\t whether the current dimension has zero size in order to avoid\n+\t division by zero. \n+      */\n+      tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR, \n+\t\t\t     gfc_array_index_type, \n+\t\t\t     fold_convert (gfc_array_index_type, \n+\t\t\t\t\t   TYPE_MAX_VALUE (gfc_array_index_type)),\n+\t\t\t\t\t   size);\n+      tmp = fold_build3_loc \n+\t(input_location, COND_EXPR, integer_type_node,\n+\t gfc_unlikely (fold_build2_loc (input_location, LT_EXPR, \n+\t\t\t\t\tboolean_type_node, tmp, stride)),\n+\t integer_one_node, integer_zero_node);\n+      tmp = fold_build3_loc \n+\t(input_location, COND_EXPR, integer_type_node,\n+\t gfc_unlikely (fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t\tboolean_type_node, size, \n+\t\t\t\t\tbuild_zero_cst (gfc_array_index_type))),\n+\t integer_zero_node, tmp);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n+\t\t\t     *overflow, tmp);\n+      *overflow = gfc_evaluate_now (tmp, pblock);\n+      \n       /* Multiply the stride by the number of elements in this dimension.  */\n       stride = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\tgfc_array_index_type, stride, size);\n@@ -4104,8 +4153,33 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n   /* The stride is the number of elements in the array, so multiply by the\n      size of an element to get the total size.  */\n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n-  size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n-\t\t\t  stride, fold_convert (gfc_array_index_type, tmp));\n+  /* Convert to size_t.  */\n+  element_size = fold_convert (sizetype, tmp);\n+  stride = fold_convert (sizetype, stride);\n+\n+  /* First check for overflow. Since an array of type character can\n+     have zero element_size, we must check for that before\n+     dividing.  */\n+  tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR, \n+\t\t\t sizetype, \n+\t\t\t TYPE_MAX_VALUE (sizetype), element_size);\n+  tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node,\n+\t\t\t gfc_unlikely (fold_build2_loc (input_location, LT_EXPR, \n+\t\t\t\t\t\t\tboolean_type_node, tmp, \n+\t\t\t\t\t\t\tstride)),\n+\t\t\t integer_one_node, integer_zero_node);\n+  tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node,\n+\t\t\t gfc_unlikely (fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t\t\t\tboolean_type_node, \n+\t\t\t\t\t\t\telement_size, \n+\t\t\t\t\t\t\tsize_zero_node)),\n+\t\t\t integer_zero_node, tmp);\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n+\t\t\t *overflow, tmp);\n+  *overflow = gfc_evaluate_now (tmp, pblock);\n+\n+  size = fold_build2_loc (input_location, MULT_EXPR, sizetype,\n+\t\t\t  stride, element_size);\n \n   if (poffset != NULL)\n     {\n@@ -4120,7 +4194,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \n   var = gfc_create_var (TREE_TYPE (size), \"size\");\n   gfc_start_block (&thenblock);\n-  gfc_add_modify (&thenblock, var, gfc_index_zero_node);\n+  gfc_add_modify (&thenblock, var, size_zero_node);\n   thencase = gfc_finish_block (&thenblock);\n \n   gfc_start_block (&elseblock);\n@@ -4146,6 +4220,12 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   tree pointer;\n   tree offset;\n   tree size;\n+  tree msg;\n+  tree error;\n+  tree overflow; /* Boolean storing whether size calculation overflows.  */\n+  tree var_overflow;\n+  tree cond;\n+  stmtblock_t elseblock;\n   gfc_expr **lower;\n   gfc_expr **upper;\n   gfc_ref *ref, *prev_ref = NULL;\n@@ -4213,21 +4293,60 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n       break;\n     }\n \n+  overflow = integer_zero_node;\n   size = gfc_array_init_size (se->expr, ref->u.ar.as->rank,\n \t\t\t      ref->u.ar.as->corank, &offset, lower, upper,\n-\t\t\t      &se->pre);\n+\t\t\t      &se->pre, &overflow);\n+\n+  var_overflow = gfc_create_var (integer_type_node, \"overflow\");\n+  gfc_add_modify (&se->pre, var_overflow, overflow);\n \n+  /* Generate the block of code handling overflow.  */\n+  msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n+  \t\t\t(\"Integer overflow when calculating the amount of \"\n+  \t\t\t \"memory to allocate\"));\n+  error = build_call_expr_loc (input_location,\n+  \t\t\t   gfor_fndecl_runtime_error, 1, msg);\n+\n+  if (pstat != NULL_TREE && !integer_zerop (pstat))\n+    {\n+      /* Set the status variable if it's present.  */\n+      stmtblock_t set_status_block;\n+      tree status_type = pstat ? TREE_TYPE (TREE_TYPE (pstat)) : NULL_TREE;\n+\n+      gfc_start_block (&set_status_block);\n+      gfc_add_modify (&set_status_block,\n+  \t\t      fold_build1_loc (input_location, INDIRECT_REF,\n+  \t\t\t\t       status_type, pstat),\n+  \t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n+\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+  \t\t\t     pstat, build_int_cst (TREE_TYPE (pstat), 0));\n+      error = fold_build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n+  \t\t\t       error, gfc_finish_block (&set_status_block));\n+    }\n+\n+  gfc_start_block (&elseblock);\n+  \n   /* Allocate memory to store the data.  */\n   pointer = gfc_conv_descriptor_data_get (se->expr);\n   STRIP_NOPS (pointer);\n \n   /* The allocate_array variants take the old pointer as first argument.  */\n   if (allocatable_array)\n-    tmp = gfc_allocate_array_with_status (&se->pre, pointer, size, pstat, expr);\n+    tmp = gfc_allocate_array_with_status (&elseblock, pointer, size, pstat, expr);\n   else\n-    tmp = gfc_allocate_with_status (&se->pre, size, pstat);\n+    tmp = gfc_allocate_with_status (&elseblock, size, pstat);\n   tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node, pointer,\n \t\t\t tmp);\n+\n+  gfc_add_expr_to_block (&elseblock, tmp);\n+\n+  cond = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t\tvar_overflow, integer_zero_node));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, \n+\t\t\t error, gfc_finish_block (&elseblock));\n+\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   gfc_conv_descriptor_offset_set (&se->pre, se->expr, offset);"}]}