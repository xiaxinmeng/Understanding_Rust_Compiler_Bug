{"sha": "ea2042ba818c83f7fbe56d883b4ac494ea565fe2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWEyMDQyYmE4MThjODNmN2ZiZTU2ZDg4M2I0YWM0OTRlYTU2NWZlMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-10T11:47:53Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-10T11:47:53Z"}, "message": "match.pd: Implement pattern from simplify_conversion_from_bitmask.\n\n2014-11-10  Richard Biener  <rguenther@suse.de>\n\n\t* match.pd: Implement pattern from simplify_conversion_from_bitmask.\n\t* tree-ssa-forwprop.c (simplify_conversion_from_bitmask): Remove.\n\t(pass_forwprop::execute): Do not call simplify_conversion_from_bitmask.\n\nFrom-SVN: r217284", "tree": {"sha": "9621814c43521e40189c352f06dcc0e2f29e1311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9621814c43521e40189c352f06dcc0e2f29e1311"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea2042ba818c83f7fbe56d883b4ac494ea565fe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea2042ba818c83f7fbe56d883b4ac494ea565fe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea2042ba818c83f7fbe56d883b4ac494ea565fe2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea2042ba818c83f7fbe56d883b4ac494ea565fe2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bb60d646c100b8807ed1595ef7252f9a0789e436", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb60d646c100b8807ed1595ef7252f9a0789e436", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb60d646c100b8807ed1595ef7252f9a0789e436"}], "stats": {"total": 108, "additions": 18, "deletions": 90}, "files": [{"sha": "b0b815caf61dc9a6c34308394817d26d8ca418ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2042ba818c83f7fbe56d883b4ac494ea565fe2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2042ba818c83f7fbe56d883b4ac494ea565fe2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea2042ba818c83f7fbe56d883b4ac494ea565fe2", "patch": "@@ -1,3 +1,9 @@\n+2014-11-10  Richard Biener  <rguenther@suse.de>\n+\n+\t* match.pd: Implement pattern from simplify_conversion_from_bitmask.\n+\t* tree-ssa-forwprop.c (simplify_conversion_from_bitmask): Remove.\n+\t(pass_forwprop::execute): Do not call simplify_conversion_from_bitmask.\n+\n 2014-11-10  Richard Biener  <rguenther@suse.de>\n \n \t* match.pd: Move rest of the conversion combining patterns"}, {"sha": "c88beb94b75592eebc3e83ba993c8956e5d6c664", "filename": "gcc/match.pd", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2042ba818c83f7fbe56d883b4ac494ea565fe2/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2042ba818c83f7fbe56d883b4ac494ea565fe2/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=ea2042ba818c83f7fbe56d883b4ac494ea565fe2", "patch": "@@ -431,3 +431,15 @@ along with GCC; see the file COPYING3.  If not see\n \t(unsigned) significand_size (TYPE_MODE (inter_type))\n \t>= inside_prec - !inside_unsignedp)\n     (convert @0))))))\n+\n+/* If we have a narrowing conversion to an integral type that is fed by a\n+   BIT_AND_EXPR, we might be able to remove the BIT_AND_EXPR if it merely\n+   masks off bits outside the final type (and nothing else).  */\n+(simplify\n+  (convert (bit_and @0 INTEGER_CST@1))\n+  (if (INTEGRAL_TYPE_P (type)\n+       && INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+       && TYPE_PRECISION (type) <= TYPE_PRECISION (TREE_TYPE (@0))\n+       && operand_equal_p (@1, build_low_bits_mask (TREE_TYPE (@1),\n+\t\t\t\t\t\t    TYPE_PRECISION (type)), 0))\n+   (convert @0)))"}, {"sha": "0507bc05d4e8a050d6bc0ccad0426ba54368d2f4", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2042ba818c83f7fbe56d883b4ac494ea565fe2/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2042ba818c83f7fbe56d883b4ac494ea565fe2/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=ea2042ba818c83f7fbe56d883b4ac494ea565fe2", "patch": "@@ -1214,78 +1214,6 @@ forward_propagate_comparison (gimple_stmt_iterator *defgsi)\n }\n \n \n-/* GSI_P points to a statement which performs a narrowing integral\n-   conversion.\n-\n-   Look for cases like:\n-\n-     t = x & c;\n-     y = (T) t;\n-\n-   Turn them into:\n-\n-     t = x & c;\n-     y = (T) x;\n-\n-   If T is narrower than X's type and C merely masks off bits outside\n-   of (T) and nothing else.\n-\n-   Normally we'd let DCE remove the dead statement.  But no DCE runs\n-   after the last forwprop/combine pass, so we remove the obviously\n-   dead code ourselves.\n-\n-   Return TRUE if a change was made, FALSE otherwise.  */\n-\n-static bool \n-simplify_conversion_from_bitmask (gimple_stmt_iterator *gsi_p)\n-{\n-  gimple stmt = gsi_stmt (*gsi_p);\n-  gimple rhs_def_stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));\n-\n-  /* See if the input for the conversion was set via a BIT_AND_EXPR and\n-     the only use of the BIT_AND_EXPR result is the conversion.  */\n-  if (is_gimple_assign (rhs_def_stmt)\n-      && gimple_assign_rhs_code (rhs_def_stmt) == BIT_AND_EXPR\n-      && has_single_use (gimple_assign_lhs (rhs_def_stmt)))\n-    {\n-      tree rhs_def_operand1 = gimple_assign_rhs1 (rhs_def_stmt);\n-      tree rhs_def_operand2 = gimple_assign_rhs2 (rhs_def_stmt);\n-      tree lhs_type = TREE_TYPE (gimple_assign_lhs (stmt));\n-\n-      /* Now verify suitability of the BIT_AND_EXPR's operands.\n-\t The first must be an SSA_NAME that we can propagate and the\n-\t second must be an integer constant that masks out all the\n-\t bits outside the final result's type, but nothing else.  */\n-      if (TREE_CODE (rhs_def_operand1) == SSA_NAME\n-\t  && ! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs_def_operand1)\n-\t  && TREE_CODE (rhs_def_operand2) == INTEGER_CST\n-\t  && operand_equal_p (rhs_def_operand2,\n-\t\t\t      build_low_bits_mask (TREE_TYPE (rhs_def_operand2),\n-\t\t\t       \t\t\t   TYPE_PRECISION (lhs_type)),\n-\t\t\t\t\t\t   0))\n-\t{\n-\t  /* This is an optimizable case.  Replace the source operand\n-\t     in the conversion with the first source operand of the\n-\t     BIT_AND_EXPR.  */\n-\t  gimple_assign_set_rhs1 (stmt, rhs_def_operand1);\n-\t  stmt = gsi_stmt (*gsi_p);\n-\t  update_stmt (stmt);\n-\n-\t  /* There is no DCE after the last forwprop pass.  It's\n-\t     easy to clean up the first order effects here.  */\n-\t  gimple_stmt_iterator si;\n-\t  si = gsi_for_stmt (rhs_def_stmt);\n-\t  gsi_remove (&si, true);\n-\t  fwprop_invalidate_lattice (gimple_get_lhs (rhs_def_stmt));\n-\t  release_defs (rhs_def_stmt);\n-\t  return true;\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n-\n /* Helper function for simplify_gimple_switch.  Remove case labels that\n    have values outside the range of the new type.  */\n \n@@ -2940,24 +2868,6 @@ pass_forwprop::execute (function *fun)\n \t\t\t&& maybe_clean_or_replace_eh_stmt (stmt, stmt))\n \t\t      bitmap_set_bit (to_purge, bb->index);\n \t\t  }\n-\t\telse if (CONVERT_EXPR_CODE_P (code)\n-\t\t\t || code == FLOAT_EXPR\n-\t\t\t || code == FIX_TRUNC_EXPR)\n-\t\t  {\n-\t\t    /* If we have a narrowing conversion to an integral\n-\t\t       type that is fed by a BIT_AND_EXPR, we might be\n-\t\t       able to remove the BIT_AND_EXPR if it merely\n-\t\t       masks off bits outside the final type (and nothing\n-\t\t       else.  */\n-\t\t    tree outer_type = TREE_TYPE (gimple_assign_lhs (stmt));\n-\t\t    tree inner_type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n-\t\t    if (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n-\t\t\t&& INTEGRAL_TYPE_P (outer_type)\n-\t\t\t&& INTEGRAL_TYPE_P (inner_type)\n-\t\t\t&& (TYPE_PRECISION (outer_type)\n-\t\t\t    <= TYPE_PRECISION (inner_type)))\n-\t\t      changed = simplify_conversion_from_bitmask (&gsi);\n-\t\t  }\n \t\telse if (code == VEC_PERM_EXPR)\n \t\t  {\n \t\t    int did_something = simplify_permutation (&gsi);"}]}