{"sha": "f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb", "node_id": "C_kwDOANBUbNoAKGY5YzFhMTRkYWI0YzQ3Yzc3NGY5Yzc2NjFhZmM0YmIyMTc2ZWI5YmI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-31T08:28:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-31T08:28:42Z"}, "message": "Merge #1069\n\n1069: Handle macro invocations in type contexts r=CohenArthur a=CohenArthur\n\nCloses #1067 \r\n\r\nThis highlighted two issues where parsing types is not entirely correct, which I'll raise. The code necessary to handle macro invocations in these two places should already be implemented. \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "3dd88710ab2a9e14b11af931fed15f4637ab4a48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dd88710ab2a9e14b11af931fed15f4637ab4a48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiRWY6CRBK7hj4Ov3rIwAAr6IIAJqgWMSM0XSdz9C9bQ5hCUjs\nES/O885cRVPLwNPHRKHliuAi14SzKsFvndMWvxqG0gSUrvioBJ0xyB30i5Tybq7O\nDnGCyymbNGI/V5EGC1MF9btUlGHOmRsKeJBiblKd7rEO9CcSSteX+hMqo15blWvw\nE95170SBJ9vG0HPOBqrlgi9akDtXlZTlSr4G3rT9pyu0YlX22bSpHbvlpsXjYsBV\nijI0lUdQzjP8d/xqsJy1Zf1xTImCYMuHpdChUtUarB0ljYGVWEmYUqb6Rr8mW8d0\nDsNqekq/xfjkrNciwnq/2JlLEF/59l2EPlrpOibxFfFX3F3uv+BUYLbVme2ryxY=\n=iytU\n-----END PGP SIGNATURE-----\n", "payload": "tree 3dd88710ab2a9e14b11af931fed15f4637ab4a48\nparent bd1f435b2310e61ed76d69063004c2aadb496255\nparent 6bf428379d138f0efe7e72bff11bffa348eb8932\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1648715322 +0000\ncommitter GitHub <noreply@github.com> 1648715322 +0000\n\nMerge #1069\n\n1069: Handle macro invocations in type contexts r=CohenArthur a=CohenArthur\n\nCloses #1067 \r\n\r\nThis highlighted two issues where parsing types is not entirely correct, which I'll raise. The code necessary to handle macro invocations in these two places should already be implemented. \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd1f435b2310e61ed76d69063004c2aadb496255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd1f435b2310e61ed76d69063004c2aadb496255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd1f435b2310e61ed76d69063004c2aadb496255"}, {"sha": "6bf428379d138f0efe7e72bff11bffa348eb8932", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bf428379d138f0efe7e72bff11bffa348eb8932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bf428379d138f0efe7e72bff11bffa348eb8932"}], "stats": {"total": 356, "additions": 344, "deletions": 12}, "files": [{"sha": "5817a0e8f8466040a5a9c3e2f5d6ad0364d92203", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb", "patch": "@@ -1515,6 +1515,7 @@ class SingleASTNode\n     TRAIT,\n     IMPL,\n     TRAIT_IMPL,\n+    TYPE,\n   };\n \n private:\n@@ -1528,6 +1529,7 @@ class SingleASTNode\n   std::unique_ptr<TraitItem> trait_item;\n   std::unique_ptr<InherentImplItem> impl_item;\n   std::unique_ptr<TraitImplItem> trait_impl_item;\n+  std::unique_ptr<Type> type;\n \n public:\n   SingleASTNode (std::unique_ptr<Expr> expr)\n@@ -1558,6 +1560,10 @@ class SingleASTNode\n     : kind (TRAIT_IMPL), trait_impl_item (std::move (trait_impl_item))\n   {}\n \n+  SingleASTNode (std::unique_ptr<Type> type)\n+    : kind (TYPE), type (std::move (type))\n+  {}\n+\n   SingleASTNode (SingleASTNode const &other)\n   {\n     kind = other.kind;\n@@ -1590,6 +1596,10 @@ class SingleASTNode\n       case TRAIT_IMPL:\n \ttrait_impl_item = other.trait_impl_item->clone_trait_impl_item ();\n \tbreak;\n+\n+      case TYPE:\n+\ttype = other.type->clone_type ();\n+\tbreak;\n       }\n   }\n \n@@ -1625,6 +1635,10 @@ class SingleASTNode\n       case TRAIT_IMPL:\n \ttrait_impl_item = other.trait_impl_item->clone_trait_impl_item ();\n \tbreak;\n+\n+      case TYPE:\n+\ttype = other.type->clone_type ();\n+\tbreak;\n       }\n     return *this;\n   }\n@@ -1699,6 +1713,12 @@ class SingleASTNode\n     return std::move (trait_impl_item);\n   }\n \n+  std::unique_ptr<Type> take_type ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (type);\n+  }\n+\n   void accept_vis (ASTVisitor &vis)\n   {\n     switch (kind)\n@@ -1730,6 +1750,10 @@ class SingleASTNode\n       case TRAIT_IMPL:\n \ttrait_impl_item->accept_vis (vis);\n \tbreak;\n+\n+      case TYPE:\n+\ttype->accept_vis (vis);\n+\tbreak;\n       }\n   }\n \n@@ -1751,6 +1775,8 @@ class SingleASTNode\n \treturn impl_item == nullptr;\n       case TRAIT_IMPL:\n \treturn trait_impl_item == nullptr;\n+      case TYPE:\n+\treturn type == nullptr;\n       }\n \n     gcc_unreachable ();\n@@ -1774,7 +1800,9 @@ class SingleASTNode\n       case IMPL:\n \treturn \"Impl Item: \" + impl_item->as_string ();\n       case TRAIT_IMPL:\n-\treturn \"Trait Impl Item: \" + impl_item->as_string ();\n+\treturn \"Trait Impl Item: \" + trait_impl_item->as_string ();\n+      case TYPE:\n+\treturn \"Type: \" + type->as_string ();\n       }\n \n     gcc_unreachable ();\n@@ -1799,6 +1827,18 @@ class ASTFragment\n   std::vector<SingleASTNode> nodes;\n   bool fragment_is_error;\n \n+  /**\n+   * We need to make a special case for Expression and Type fragments as only\n+   * one Node will be extracted from the `nodes` vector\n+   */\n+\n+  bool is_single_fragment () const { return nodes.size () == 1; }\n+\n+  bool is_single_fragment_kind (SingleASTNode::NodeType kind) const\n+  {\n+    return is_single_fragment () && nodes[0].get_kind () == kind;\n+  }\n+\n public:\n   ASTFragment (std::vector<SingleASTNode> nodes, bool fragment_is_error = false)\n     : nodes (std::move (nodes)), fragment_is_error (fragment_is_error)\n@@ -1839,21 +1879,16 @@ class ASTFragment\n \n   bool should_expand () const { return !is_error () && !nodes.empty (); }\n \n-  /**\n-   * We need to make a special case for Expression fragments as only one\n-   * Node will be extracted from the `nodes` vector\n-   */\n-\n-  bool is_expression_fragment () const\n+  std::unique_ptr<Expr> take_expression_fragment ()\n   {\n-    return nodes.size () == 1\n-\t   && nodes[0].get_kind () == SingleASTNode::NodeType::EXPRESSION;\n+    rust_assert (is_single_fragment_kind (SingleASTNode::NodeType::EXPRESSION));\n+    return nodes[0].take_expr ();\n   }\n \n-  std::unique_ptr<Expr> take_expression_fragment ()\n+  std::unique_ptr<Type> take_type_fragment ()\n   {\n-    rust_assert (is_expression_fragment ());\n-    return nodes[0].take_expr ();\n+    rust_assert (is_single_fragment_kind (SingleASTNode::NodeType::TYPE));\n+    return nodes[0].take_type ();\n   }\n \n   void accept_vis (ASTVisitor &vis)"}, {"sha": "859ae7e97082e6642e8e3a78d4a6e198fd8600e2", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb", "patch": "@@ -35,13 +35,22 @@ AttrVisitor::expand_struct_fields (std::vector<AST::StructField> &fields)\n \t  continue;\n \t}\n \n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       // expand sub-types of type, but can't strip type itself\n       auto &type = field.get_field_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n \n+      expander.pop_context ();\n+\n       // if nothing else happens, increment\n       ++it;\n     }\n@@ -77,6 +86,8 @@ AttrVisitor::expand_tuple_fields (std::vector<AST::TupleField> &fields)\n void\n AttrVisitor::expand_function_params (std::vector<AST::FunctionParam> &params)\n {\n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   for (auto it = params.begin (); it != params.end ();)\n     {\n       auto &param = *it;\n@@ -98,34 +109,52 @@ AttrVisitor::expand_function_params (std::vector<AST::FunctionParam> &params)\n \n       auto &type = param.get_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n \n       // increment\n       ++it;\n     }\n+\n+  expander.pop_context ();\n }\n \n void\n AttrVisitor::expand_generic_args (AST::GenericArgs &args)\n {\n   // lifetime args can't be expanded\n+  // FIXME: Can we have macro invocations for lifetimes?\n+\n+  expander.push_context (MacroExpander::ContextType::TYPE);\n \n   // expand type args - strip sub-types only\n   for (auto &type : args.get_type_args ())\n     {\n       type->accept_vis (*this);\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n     }\n \n+  expander.pop_context ();\n+\n+  // FIXME: Can we have macro invocations in generic type bindings?\n   // expand binding args - strip sub-types only\n   for (auto &binding : args.get_binding_args ())\n     {\n       auto &type = binding.get_type ();\n       type->accept_vis (*this);\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n@@ -135,8 +164,17 @@ AttrVisitor::expand_generic_args (AST::GenericArgs &args)\n void\n AttrVisitor::expand_qualified_path_type (AST::QualifiedPathType &path_type)\n {\n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   auto &type = path_type.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n+  expander.pop_context ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n@@ -174,11 +212,19 @@ AttrVisitor::AttrVisitor::expand_closure_params (\n \n       if (param.has_type_given ())\n \t{\n+\t  expander.push_context (MacroExpander::ContextType::TYPE);\n \t  auto &type = param.get_type ();\n \t  type->accept_vis (*this);\n+\n+\t  auto t_fragment = expander.take_expanded_fragment (*this);\n+\t  if (t_fragment.should_expand ())\n+\t    type = t_fragment.take_type_fragment ();\n+\n \t  if (type->is_marked_for_strip ())\n \t    rust_error_at (type->get_locus (),\n \t\t\t   \"cannot strip type in this position\");\n+\n+\t  expander.pop_context ();\n \t}\n \n       // increment if found nothing else so far\n@@ -191,11 +237,19 @@ AttrVisitor::expand_self_param (AST::SelfParam &self_param)\n {\n   if (self_param.has_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n       auto &type = self_param.get_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n   /* TODO: maybe check for invariants being violated - e.g. both type and\n    * lifetime? */\n@@ -222,11 +276,20 @@ AttrVisitor::expand_trait_function_decl (AST::TraitFunctionDecl &decl)\n \n   if (decl.has_return_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &return_type = decl.get_return_type ();\n       return_type->accept_vis (*this);\n+\n+      auto r_fragment = expander.take_expanded_fragment (*this);\n+      if (r_fragment.should_expand ())\n+\treturn_type = r_fragment.take_type_fragment ();\n+\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n \n   if (decl.has_where_clause ())\n@@ -251,11 +314,20 @@ AttrVisitor::expand_trait_method_decl (AST::TraitMethodDecl &decl)\n \n   if (decl.has_return_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &return_type = decl.get_return_type ();\n       return_type->accept_vis (*this);\n+\n+      auto r_fragment = expander.take_expanded_fragment (*this);\n+      if (r_fragment.should_expand ())\n+\treturn_type = r_fragment.take_type_fragment ();\n+\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n \n   if (decl.has_where_clause ())\n@@ -368,11 +440,20 @@ AttrVisitor::visit (AST::TypePathSegmentFunction &segment)\n \n   if (type_path_function.has_return_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &return_type = type_path_function.get_return_type ();\n       return_type->accept_vis (*this);\n+\n+      auto r_fragment = expander.take_expanded_fragment (*this);\n+      if (r_fragment.should_expand ())\n+\treturn_type = r_fragment.take_type_fragment ();\n+\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n }\n void\n@@ -1176,12 +1257,21 @@ AttrVisitor::visit (AST::ClosureExprInnerTyped &expr)\n    * allowed by spec */\n   expand_closure_params (expr.get_params ());\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   // can't strip return type, but can strip sub-types\n   auto &type = expr.get_return_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   // can't strip expression itself, but can strip sub-expressions\n   auto &definition_block = expr.get_definition_block ();\n   definition_block->accept_vis (*this);\n@@ -1928,11 +2018,19 @@ AttrVisitor::visit (AST::TypeParam &param)\n \n   if (param.has_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n       auto &type = param.get_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n }\n void\n@@ -1945,11 +2043,20 @@ AttrVisitor::visit (AST::TypeBoundWhereClauseItem &item)\n {\n   // for lifetimes shouldn't require\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   auto &type = item.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   // don't strip directly, only components of bounds\n   for (auto &bound : item.get_type_param_bounds ())\n     bound->accept_vis (*this);\n@@ -1980,11 +2087,20 @@ AttrVisitor::visit (AST::Method &method)\n \n   if (method.has_return_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &return_type = method.get_return_type ();\n       return_type->accept_vis (*this);\n+\n+      auto r_fragment = expander.take_expanded_fragment (*this);\n+      if (r_fragment.should_expand ())\n+\treturn_type = r_fragment.take_type_fragment ();\n+\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n \n   if (method.has_where_clause ())\n@@ -2093,11 +2209,20 @@ AttrVisitor::visit (AST::Function &function)\n \n   if (function.has_return_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &return_type = function.get_return_type ();\n       return_type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\treturn_type = t_fragment.take_type_fragment ();\n+\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n \n   if (function.has_where_clause ())\n@@ -2297,12 +2422,21 @@ AttrVisitor::visit (AST::ConstantItem &const_item)\n       return;\n     }\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   // strip any sub-types\n   auto &type = const_item.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   /* strip any internal sub-expressions - expression itself isn't\n    * allowed to have external attributes in this position so can't be\n    * stripped. */\n@@ -2324,12 +2458,21 @@ AttrVisitor::visit (AST::StaticItem &static_item)\n       return;\n     }\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   // strip any sub-types\n   auto &type = static_item.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   /* strip any internal sub-expressions - expression itself isn't\n    * allowed to have external attributes in this position so can't be\n    * stripped. */\n@@ -2403,12 +2546,21 @@ AttrVisitor::visit (AST::TraitItemConst &item)\n       return;\n     }\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   // strip any sub-types\n   auto &type = item.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   /* strip any internal sub-expressions - expression itself isn't\n    * allowed to have external attributes in this position so can't be\n    * stripped */\n@@ -2502,11 +2654,20 @@ AttrVisitor::visit (AST::InherentImpl &impl)\n   for (auto &param : impl.get_generic_params ())\n     param->accept_vis (*this);\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   auto &type = impl.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   if (impl.has_where_clause ())\n     expand_where_clause (impl.get_where_clause ());\n \n@@ -2539,11 +2700,20 @@ AttrVisitor::visit (AST::TraitImpl &impl)\n   for (auto &param : impl.get_generic_params ())\n     param->accept_vis (*this);\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   auto &type = impl.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   auto &trait_path = impl.get_trait_path ();\n   visit (trait_path);\n   if (trait_path.is_marked_for_strip ())\n@@ -2571,10 +2741,19 @@ AttrVisitor::visit (AST::ExternalStaticItem &item)\n       return;\n     }\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   auto &type = item.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n+\n+  expander.pop_context ();\n }\n void\n AttrVisitor::visit (AST::ExternalFunctionItem &item)\n@@ -2606,12 +2785,21 @@ AttrVisitor::visit (AST::ExternalFunctionItem &item)\n \t  continue;\n \t}\n \n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &type = param.get_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n \n+      expander.pop_context ();\n+\n       // increment if nothing else happens\n       ++it;\n     }\n@@ -2624,16 +2812,26 @@ AttrVisitor::visit (AST::ExternalFunctionItem &item)\n \n   if (item.has_return_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &return_type = item.get_return_type ();\n       return_type->accept_vis (*this);\n+\n+      auto r_fragment = expander.take_expanded_fragment (*this);\n+      if (r_fragment.should_expand ())\n+\treturn_type = r_fragment.take_type_fragment ();\n+\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n \n   if (item.has_where_clause ())\n     expand_where_clause (item.get_where_clause ());\n }\n+\n void\n AttrVisitor::visit (AST::ExternBlock &block)\n {\n@@ -2991,11 +3189,20 @@ AttrVisitor::visit (AST::LetStmt &stmt)\n   // similar for type\n   if (stmt.has_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &type = stmt.get_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n \n   /* strip any internal sub-expressions - expression itself isn't\n@@ -3190,12 +3397,21 @@ AttrVisitor::visit (AST::BareFunctionType &type)\n \t  continue;\n \t}\n \n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &type = param.get_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n \n+      expander.pop_context ();\n+\n       // increment if nothing else happens\n       ++it;\n     }\n@@ -3205,6 +3421,9 @@ AttrVisitor::visit (AST::BareFunctionType &type)\n \n   if (type.has_return_type ())\n     {\n+      // FIXME: Can we have type expansion in this position?\n+      // In that case, we need to handle AST::TypeNoBounds on top of just\n+      // AST::Types\n       auto &return_type = type.get_return_type ();\n       return_type->accept_vis (*this);\n       if (return_type->is_marked_for_strip ())"}, {"sha": "852e61920f2e2f7b2f77952275c7ec9d9b4d5962", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb", "patch": "@@ -909,6 +909,19 @@ transcribe_expression (Parser<MacroInvocLexer> &parser)\n   return {AST::SingleASTNode (std::move (expr))};\n }\n \n+/**\n+ * Transcribe one type from a macro invocation\n+ *\n+ * @param parser Parser to extract statements from\n+ */\n+static std::vector<AST::SingleASTNode>\n+transcribe_type (Parser<MacroInvocLexer> &parser)\n+{\n+  auto expr = parser.parse_type ();\n+\n+  return {AST::SingleASTNode (std::move (expr))};\n+}\n+\n static std::vector<AST::SingleASTNode>\n transcribe_on_delimiter (Parser<MacroInvocLexer> &parser, bool semicolon,\n \t\t\t AST::DelimType delimiter, TokenId last_token_id)\n@@ -957,6 +970,9 @@ transcribe_context (MacroExpander::ContextType ctx,\n     case MacroExpander::ContextType::EXTERN:\n       return transcribe_many_ext (parser, last_token_id);\n       break;\n+    case MacroExpander::ContextType::TYPE:\n+      return transcribe_type (parser);\n+      break;\n     default:\n       return transcribe_on_delimiter (parser, semicolon, delimiter,\n \t\t\t\t      last_token_id);"}, {"sha": "3cac61739a602b0327102cf206ea2ffee82b8f48", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb", "patch": "@@ -188,6 +188,7 @@ struct MacroExpander\n     ITEM,\n     BLOCK,\n     EXTERN,\n+    TYPE,\n     TRAIT,\n     IMPL,\n     TRAIT_IMPL,"}, {"sha": "7151f3a83bce7c4248d05fcda535e03ab54d2f59", "filename": "gcc/testsuite/rust/compile/macro40.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro40.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro40.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro40.rs?ref=f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb", "patch": "@@ -0,0 +1,48 @@\n+// { dg-additional-options \"-w\" }\n+\n+macro_rules! t {\n+    () => {\n+        i32\n+    };\n+}\n+\n+macro_rules! s {\n+    () => {\n+        *const i8\n+    };\n+}\n+\n+extern \"C\" {\n+    fn printf(s: s!(), ...);\n+}\n+\n+fn square(arg: t!()) -> t!() {\n+    let input: t!() = arg;\n+\n+    input * input\n+}\n+\n+trait Trait {\n+    fn f() -> t!();\n+    fn g(arg: t!());\n+}\n+\n+struct Wrapper {\n+    inner: t!(),\n+}\n+\n+impl Trait for Wrapper {\n+    fn f() -> t!() {\n+        1\n+    }\n+\n+    fn g(arg: t!()) {}\n+}\n+\n+fn id<T>(arg: T) -> T {\n+    arg\n+}\n+\n+fn main() {\n+    id::<t!()>(15);\n+}"}, {"sha": "b011f92414945671f377740648dce6058de58ebf", "filename": "gcc/testsuite/rust/execute/torture/macros28.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros28.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros28.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros28.rs?ref=f9c1a14dab4c47c774f9c7661afc4bb2176eb9bb", "patch": "@@ -0,0 +1,13 @@\n+macro_rules! t {\n+    () => {\n+        i32\n+    };\n+}\n+\n+fn id<T>(arg: T) -> T {\n+    arg\n+}\n+\n+fn main() -> i32 {\n+    id::<t!()>(15) - 15\n+}"}]}