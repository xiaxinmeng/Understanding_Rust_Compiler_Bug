{"sha": "27027a6034c9f7bbf99af08f9c618227ac0e1779", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcwMjdhNjAzNGM5ZjdiYmY5OWFmMDhmOWM2MTgyMjdhYzBlMTc3OQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-12T20:06:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-12T20:06:17Z"}, "message": "#if VMS, don't define `stat' macro to be VMS_stat.\n\n#if VMS, don't define `stat' macro to be VMS_stat.\nCompare enums explicitly to 0 to work around VAX C bug.\n\nFrom-SVN: r9660", "tree": {"sha": "e023aff275324f7bd83c353905450295ddddd7ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e023aff275324f7bd83c353905450295ddddd7ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27027a6034c9f7bbf99af08f9c618227ac0e1779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27027a6034c9f7bbf99af08f9c618227ac0e1779", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27027a6034c9f7bbf99af08f9c618227ac0e1779", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27027a6034c9f7bbf99af08f9c618227ac0e1779/comments", "author": null, "committer": null, "parents": [{"sha": "5583c64f59d34b53ade6aa47f87b20e51ffcbbb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5583c64f59d34b53ade6aa47f87b20e51ffcbbb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5583c64f59d34b53ade6aa47f87b20e51ffcbbb7"}], "stats": {"total": 33, "additions": 16, "deletions": 17}, "files": [{"sha": "7f31e78dc9656cbe446e7b9374586a7be9e64781", "filename": "gcc/cccp.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27027a6034c9f7bbf99af08f9c618227ac0e1779/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27027a6034c9f7bbf99af08f9c618227ac0e1779/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=27027a6034c9f7bbf99af08f9c618227ac0e1779", "patch": "@@ -240,7 +240,6 @@ my_bzero (b, length)\n #define freopen(fname,mode,ofile) VMS_freopen (fname,mode,ofile)\n #define strncat(dst,src,cnt) VMS_strncat (dst,src,cnt)\n #define fstat(fd,stbuf)\t\tVMS_fstat (fd,stbuf)\n-#define stat(name,stbuf)\tVMS_stat (name,stbuf)\n static int VMS_fstat (), VMS_stat ();\n static char * VMS_strncat ();\n static int VMS_read ();\n@@ -682,7 +681,7 @@ struct macrodef\n };\n \f\n enum sharp_token_type {\n-  NO_SHARP_TOKEN,\t\t/* token not present */\n+  NO_SHARP_TOKEN = 0,\t\t/* token not present */\n \n   SHARP_TOKEN = '#',\t\t/* token spelled with # only */\n   WHITE_SHARP_TOKEN,\t\t/* token spelled with # and white space */\n@@ -8155,7 +8154,7 @@ macroexpand (hp, op)\n       for (ap = defn->pattern; ap != NULL; ap = ap->next) {\n \tif (ap->stringify)\n \t  xbuf_len += args[ap->argno].stringified_length;\n-\telse if (ap->raw_before || ap->raw_after || traditional)\n+\telse if (ap->raw_before != 0 || ap->raw_after != 0 || traditional)\n \t  /* Add 4 for two newline-space markers to prevent\n \t     token concatenation.  */\n \t  xbuf_len += args[ap->argno].raw_length + 4;\n@@ -8201,9 +8200,9 @@ macroexpand (hp, op)\n \t/* If followed by an empty rest arg with concatenation,\n \t   delete the last run of nonwhite chars.  */\n \tif (rest_zero && totlen > count_before\n-\t    && ((ap->rest_args && ap->raw_before)\n+\t    && ((ap->rest_args && ap->raw_before != 0)\n \t\t|| (last_ap != NULL && last_ap->rest_args\n-\t\t    && last_ap->raw_after))) {\n+\t\t    && last_ap->raw_after != 0))) {\n \t  /* Delete final whitespace.  */\n \t  while (totlen > count_before && is_space[xbuf[totlen - 1]]) {\n \t    totlen--;\n@@ -8281,10 +8280,10 @@ macroexpand (hp, op)\n \t  }\n \t  if (!traditional)\n \t    xbuf[totlen++] = '\\\"'; /* insert ending quote */\n-\t} else if (ap->raw_before || ap->raw_after || traditional) {\n+\t} else if (ap->raw_before != 0 || ap->raw_after != 0 || traditional) {\n \t  U_CHAR *p1 = arg->raw;\n \t  U_CHAR *l1 = p1 + arg->raw_length;\n-\t  if (ap->raw_before) {\n+\t  if (ap->raw_before != 0) {\n \t    while (p1 != l1 && is_space[*p1]) p1++;\n \t    while (p1 != l1 && is_idchar[*p1])\n \t      xbuf[totlen++] = *p1++;\n@@ -8299,7 +8298,7 @@ macroexpand (hp, op)\n \t    xbuf[totlen++] = '\\n';\n \t    xbuf[totlen++] = ' ';\n \t  }\n-\t  if (ap->raw_after) {\n+\t  if (ap->raw_after != 0) {\n \t    /* Arg is concatenated after: delete trailing whitespace,\n \t       whitespace markers, and no-reexpansion markers.  */\n \t    while (p1 != l1) {\n@@ -8320,7 +8319,7 @@ macroexpand (hp, op)\n \n \t  bcopy ((char *) p1, (char *) (xbuf + totlen), l1 - p1);\n \t  totlen += l1 - p1;\n-\t  if (!traditional && !ap->raw_after) {\n+\t  if (!traditional && ap->raw_after == 0) {\n \t    /* Ordinary expanded use of the argument.\n \t       Put in newline-space markers to prevent token pasting.  */\n \t    xbuf[totlen++] = '\\n';\n@@ -8365,7 +8364,7 @@ macroexpand (hp, op)\n \tif (exp[i] == ')')\n \t  rest_zero = 0;\n \tif (! (rest_zero && last_ap != NULL && last_ap->rest_args\n-\t       && last_ap->raw_after))\n+\t       && last_ap->raw_after != 0))\n \t  xbuf[totlen++] = exp[i];\n       }\n \n@@ -9399,7 +9398,7 @@ dump_single_macro (hp, of)\n \t default: abort ();\n \t}\n       }\n-      if (ap->raw_before) {\n+      if (ap->raw_before != 0) {\n \tif (concat) {\n \t  switch (ap->raw_before) {\n \t   case WHITE_SHARP_TOKEN:\n@@ -9422,7 +9421,7 @@ dump_single_macro (hp, of)\n       concat = 0;\n     }\n     dump_arg_n (defn, ap->argno, of);\n-    if (!traditional && ap->raw_after) {\n+    if (!traditional && ap->raw_after != 0) {\n       switch (ap->raw_after) {\n        case SHARP_TOKEN: fprintf (of, \"##\"); break;\n        case WHITE_SHARP_TOKEN: fprintf (of, \" ##\"); break;\n@@ -10354,12 +10353,13 @@ extern unsigned long sys$parse(), sys$search();\n    bad enough, but then compounding the problem by reporting the reason for\n    failure as \"normal successful completion.\"  */\n \n+#undef fstat\t/* get back to library version */\n+\n static int\n-fstat (fd, statbuf)\n+VMS_fstat (fd, statbuf)\n      int fd;\n      struct stat *statbuf;\n {\n-#undef fstat\n   int result = fstat (fd, statbuf);\n \n   if (result < 0)\n@@ -10368,19 +10368,18 @@ fstat (fd, statbuf)\n       char nambuf[NAM$C_MAXRSS+1];\n \n       if ((fp = fdopen (fd, \"r\")) != 0 && fgetname (fp, nambuf) != 0)\n-\tresult = stat (nambuf, statbuf);\n+\tresult = VMS_stat (nambuf, statbuf);\n       /* No fclose(fp) here; that would close(fd) as well.  */\n     }\n \n   return result;\n }\n \n static int\n-stat (name, statbuf)\n+VMS_stat (name, statbuf)\n      const char *name;\n      struct stat *statbuf;\n {\n-#undef stat\n   int result = stat (name, statbuf);\n \n   if (result < 0)"}]}