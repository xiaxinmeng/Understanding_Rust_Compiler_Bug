{"sha": "5e777af517b3165ec4828e5ea2b9f4700f2434af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU3NzdhZjUxN2IzMTY1ZWM0ODI4ZTVlYTJiOWY0NzAwZjI0MzRhZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@wasabisystems.com", "date": "2004-01-12T19:46:31Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2004-01-12T19:46:31Z"}, "message": "demangle.h (enum demangle_component_type): Define.\n\n\t* demangle.h (enum demangle_component_type): Define.\n\t(struct demangle_operator_info): Declare.\n\t(struct demangle_builtin_type_info): Declare.\n\t(struct demangle_component): Define.\n\t(cplus_demangle_fill_component): Declare.\n\t(cplus_demangle_fill_name): Declare.\n\t(cplus_demangle_fill_builtin_type): Declare.\n\t(cplus_demangle_fill_operator): Declare.\n\t(cplus_demangle_fill_extended_operator): Declare.\n\t(cplus_demangle_fill_ctor, cplus_demangle_fill_dtor): Declare.\n\t(cplus_demangle_v3_components): Declare.\n\t(cplus_demangle_print): Declare.\n\n\t* cp-demangle.c: Include \"cp-demangle.h\".  If IN_GLIBCPP_V3 is\n\tdefined, rename some functions which are to become static via\n\t#define.\n\t(CP_STATIC_IF_GLIBCPP_V3): Define.\n\t(struct d_operator_info): Move definition to cp-demangle.h, and\n\trename to demangle_operator_info.  Change all uses.\n\t(enum d_builtin_type_print): Move definition to cp-demangle.h.\n\t(struct d_builtin_type_info): Move definition to cp-demangle.h,\n\tand rename to demangle_builtin_type_info.  Change all uses.\n\t(enum d_comp_type): Move definition to include/demangle.h, and\n\trename to demangle_component_type, and change all enums to start\n\twith DEMANGLE_COMPONENT_ instead of D_.  Change all uses.\n\t(struct d_comp): Move definition to include/demangle.h, and rename\n\tto demangle_component.  Change all uses.\n\t(struct d_info): Move definition to cp-demangle.h.\n\t(cplus_demangle_fill_name): New function.\n\t(cplus_demangle_fill_extended_operator): New function.\n\t(cplus_demangle_fill_ctor): New function.\n\t(cplus_demangle_fill_dtor): New function.\n\t(d_make_empty): Remove type parameter.  Change all callers.\n\t(d_make_name): Use cplus_demangle_fill_name.\n\t(d_make_extended_operator): Use\n\tcplus_demangle_fill_extended_operator.\n\t(d_make_ctor): Use cplus_demangle_fill_ctor.\n\t(d_make_dtor): Use cplus_demangle_fill_dtor.\n\t(cplus_demangle_mangled_name): Rename from d_mangled_name.  Make\n\tnon-static by default.  Change all callers.\n\t(cplus_demangle_operators): Rename from d_operators.  Change all\n\tuses.  Make non-static by default.  Add sentinel at end of array.\n\t(d_operator_name): Adjust initialization of high for new sentinel\n\tin cplus_demangle_operators.\n\t(cplus_demangle_builtin_types): Rename from d_builtin_types.\n\tChange all uses.  Make non-static by default.  Change initializer\n\tto use D_BUILTIN_TYPE_COUNT instead of magic number 26.\n\t(cplus_demangle_type): Rename from d_type.  Make non-static by\n\tdefault.  Change all callers.\n\t(cplus_demangle_init_info): Rename from d_init_info.  Make\n\tnon-static by default.  Change all callers.\n\t* cp-demangle.h: New file.\n\t* cp-demint.c: New file.\n\t* Makefile.in: Rebuild dependencies.\n\t(CFILES): Add cp-demint.c.\n\t(REQUIRED_OFILES): Add cp-demint.o.\n\nFrom-SVN: r75748", "tree": {"sha": "f45dbf9dc09479e568d2d563c2f643cf136a3ffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f45dbf9dc09479e568d2d563c2f643cf136a3ffe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e777af517b3165ec4828e5ea2b9f4700f2434af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e777af517b3165ec4828e5ea2b9f4700f2434af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e777af517b3165ec4828e5ea2b9f4700f2434af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e777af517b3165ec4828e5ea2b9f4700f2434af/comments", "author": null, "committer": null, "parents": [{"sha": "5c88165592ad1864b5c6cb832d6616407e031b85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c88165592ad1864b5c6cb832d6616407e031b85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c88165592ad1864b5c6cb832d6616407e031b85"}], "stats": {"total": 2514, "additions": 1660, "deletions": 854}, "files": [{"sha": "2e291cc6216f5b6eafe1a5aa181bc1a343cfc609", "filename": "include/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e777af517b3165ec4828e5ea2b9f4700f2434af/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e777af517b3165ec4828e5ea2b9f4700f2434af/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=5e777af517b3165ec4828e5ea2b9f4700f2434af", "patch": "@@ -1,3 +1,18 @@\n+2004-01-12  Ian Lance Taylor  <ian@wasabisystems.com>\n+\n+\t* demangle.h (enum demangle_component_type): Define.\n+\t(struct demangle_operator_info): Declare.\n+\t(struct demangle_builtin_type_info): Declare.\n+\t(struct demangle_component): Define.\n+\t(cplus_demangle_fill_component): Declare.\n+\t(cplus_demangle_fill_name): Declare.\n+\t(cplus_demangle_fill_builtin_type): Declare.\n+\t(cplus_demangle_fill_operator): Declare.\n+\t(cplus_demangle_fill_extended_operator): Declare.\n+\t(cplus_demangle_fill_ctor, cplus_demangle_fill_dtor): Declare.\n+\t(cplus_demangle_v3_components): Declare.\n+\t(cplus_demangle_print): Declare.\n+\n 2003-12-19  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* include/fibheap.h (fibnode): Use __extension__ for"}, {"sha": "c3fdb036d536bc184c5179fe9360b55214d9a634", "filename": "include/demangle.h", "status": "modified", "additions": 364, "deletions": 2, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e777af517b3165ec4828e5ea2b9f4700f2434af/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e777af517b3165ec4828e5ea2b9f4700f2434af/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=5e777af517b3165ec4828e5ea2b9f4700f2434af", "patch": "@@ -1,6 +1,6 @@\n /* Defs for interface to demanglers.\n-   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002\n-   Free Software Foundation, Inc.\n+   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002,\n+   2003, 2004 Free Software Foundation, Inc.\n    \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -164,6 +164,368 @@ enum gnu_v3_dtor_kinds {\n extern enum gnu_v3_dtor_kinds\n \tis_gnu_v3_mangled_dtor PARAMS ((const char *name));\n \n+/* The V3 demangler works in two passes.  The first pass builds a tree\n+   representation of the mangled name, and the second pass turns the\n+   tree representation into a demangled string.  Here we define an\n+   interface to permit a caller to build their own tree\n+   representation, which they can pass to the demangler to get a\n+   demangled string.  This can be used to canonicalize user input into\n+   something which the demangler might output.  It could also be used\n+   by other demanglers in the future.  */\n+\n+/* These are the component types which may be found in the tree.  Many\n+   component types have one or two subtrees, referred to as left and\n+   right (a component type with only one subtree puts it in the left\n+   subtree).  */\n+\n+enum demangle_component_type\n+{\n+  /* A name, with a length and a pointer to a string.  */\n+  DEMANGLE_COMPONENT_NAME,\n+  /* A qualified name.  The left subtree is a class or namespace or\n+     some such thing, and the right subtree is a name qualified by\n+     that class.  */\n+  DEMANGLE_COMPONENT_QUAL_NAME,\n+  /* A local name.  The left subtree describes a function, and the\n+     right subtree is a name which is local to that function.  */\n+  DEMANGLE_COMPONENT_LOCAL_NAME,\n+  /* A typed name.  The left subtree is a name, and the right subtree\n+     describes that name as a function.  */\n+  DEMANGLE_COMPONENT_TYPED_NAME,\n+  /* A template.  The left subtree is a template name, and the right\n+     subtree is a template argument list.  */\n+  DEMANGLE_COMPONENT_TEMPLATE,\n+  /* A template parameter.  This holds a number, which is the template\n+     parameter index.  */\n+  DEMANGLE_COMPONENT_TEMPLATE_PARAM,\n+  /* A constructor.  This holds a name and the kind of\n+     constructor.  */\n+  DEMANGLE_COMPONENT_CTOR,\n+  /* A destructor.  This holds a name and the kind of destructor.  */\n+  DEMANGLE_COMPONENT_DTOR,\n+  /* A vtable.  This has one subtree, the type for which this is a\n+     vtable.  */\n+  DEMANGLE_COMPONENT_VTABLE,\n+  /* A VTT structure.  This has one subtree, the type for which this\n+     is a VTT.  */\n+  DEMANGLE_COMPONENT_VTT,\n+  /* A construction vtable.  The left subtree is the type for which\n+     this is a vtable, and the right subtree is the derived type for\n+     which this vtable is built.  */\n+  DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE,\n+  /* A typeinfo structure.  This has one subtree, the type for which\n+     this is the tpeinfo structure.  */\n+  DEMANGLE_COMPONENT_TYPEINFO,\n+  /* A typeinfo name.  This has one subtree, the type for which this\n+     is the typeinfo name.  */\n+  DEMANGLE_COMPONENT_TYPEINFO_NAME,\n+  /* A typeinfo function.  This has one subtree, the type for which\n+     this is the tpyeinfo function.  */\n+  DEMANGLE_COMPONENT_TYPEINFO_FN,\n+  /* A thunk.  This has one subtree, the name for which this is a\n+     thunk.  */\n+  DEMANGLE_COMPONENT_THUNK,\n+  /* A virtual thunk.  This has one subtree, the name for which this\n+     is a virtual thunk.  */\n+  DEMANGLE_COMPONENT_VIRTUAL_THUNK,\n+  /* A covariant thunk.  This has one subtree, the name for which this\n+     is a covariant thunk.  */\n+  DEMANGLE_COMPONENT_COVARIANT_THUNK,\n+  /* A Java class.  This has one subtree, the type.  */\n+  DEMANGLE_COMPONENT_JAVA_CLASS,\n+  /* A guard variable.  This has one subtree, the name for which this\n+     is a guard variable.  */\n+  DEMANGLE_COMPONENT_GUARD,\n+  /* A reference temporary.  This has one subtree, the name for which\n+     this is a temporary.  */\n+  DEMANGLE_COMPONENT_REFTEMP,\n+  /* A standard substitution.  This holds the name of the\n+     substitution.  */\n+  DEMANGLE_COMPONENT_SUB_STD,\n+  /* The restrict qualifier.  The one subtree is the type which is\n+     being qualified.  */\n+  DEMANGLE_COMPONENT_RESTRICT,\n+  /* The volatile qualifier.  The one subtree is the type which is\n+     being qualified.  */\n+  DEMANGLE_COMPONENT_VOLATILE,\n+  /* The const qualifier.  The one subtree is the type which is being\n+     qualified.  */\n+  DEMANGLE_COMPONENT_CONST,\n+  /* The restrict qualifier modifying a member function.  The one\n+     subtree is the type which is being qualified.  */\n+  DEMANGLE_COMPONENT_RESTRICT_THIS,\n+  /* The volatile qualifier modifying a member function.  The one\n+     subtree is the type which is being qualified.  */\n+  DEMANGLE_COMPONENT_VOLATILE_THIS,\n+  /* The const qualifier modifying a member function.  The one subtree\n+     is the type which is being qualified.  */\n+  DEMANGLE_COMPONENT_CONST_THIS,\n+  /* A vendor qualifier.  The left subtree is the type which is being\n+     qualified, and the right subtree is the name of the\n+     qualifier.  */\n+  DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL,\n+  /* A pointer.  The one subtree is the type which is being pointed\n+     to.  */\n+  DEMANGLE_COMPONENT_POINTER,\n+  /* A reference.  The one subtree is the type which is being\n+     referenced.  */\n+  DEMANGLE_COMPONENT_REFERENCE,\n+  /* A complex type.  The one subtree is the base type.  */\n+  DEMANGLE_COMPONENT_COMPLEX,\n+  /* An imaginary type.  The one subtree is the base type.  */\n+  DEMANGLE_COMPONENT_IMAGINARY,\n+  /* A builtin type.  This holds the builtin type information.  */\n+  DEMANGLE_COMPONENT_BUILTIN_TYPE,\n+  /* A vendor's builtin type.  This holds the name of the type.  */\n+  DEMANGLE_COMPONENT_VENDOR_TYPE,\n+  /* A function type.  The left subtree is the return type.  The right\n+     subtree is a list of ARGLIST nodes.  Either or both may be\n+     NULL.  */\n+  DEMANGLE_COMPONENT_FUNCTION_TYPE,\n+  /* An array type.  The left subtree is the dimension, which may be\n+     NULL, or a string (represented as DEMANGLE_COMPONENT_NAME), or an\n+     expression.  The right subtree is the element type.  */\n+  DEMANGLE_COMPONENT_ARRAY_TYPE,\n+  /* A pointer to member type.  The left subtree is the class type,\n+     and the right subtree is the member type.  CV-qualifiers appear\n+     on the latter.  */\n+  DEMANGLE_COMPONENT_PTRMEM_TYPE,\n+  /* An argument list.  The left subtree is the current argument, and\n+     the right subtree is either NULL or another ARGLIST node.  */\n+  DEMANGLE_COMPONENT_ARGLIST,\n+  /* A template argument list.  The left subtree is the current\n+     template argument, and the right subtree is either NULL or\n+     another TEMPLATE_ARGLIST node.  */\n+  DEMANGLE_COMPONENT_TEMPLATE_ARGLIST,\n+  /* An operator.  This holds information about a standard\n+     operator.  */\n+  DEMANGLE_COMPONENT_OPERATOR,\n+  /* An extended operator.  This holds the number of arguments, and\n+     the name of the extended operator.  */\n+  DEMANGLE_COMPONENT_EXTENDED_OPERATOR,\n+  /* A typecast, represented as a unary operator.  The one subtree is\n+     the type to which the argument should be cast.  */\n+  DEMANGLE_COMPONENT_CAST,\n+  /* A unary expression.  The left subtree is the operator, and the\n+     right subtree is the single argument.  */\n+  DEMANGLE_COMPONENT_UNARY,\n+  /* A binary expression.  The left subtree is the operator, and the\n+     right subtree is a BINARY_ARGS.  */\n+  DEMANGLE_COMPONENT_BINARY,\n+  /* Arguments to a binary expression.  The left subtree is the first\n+     argument, and the right subtree is the second argument.  */\n+  DEMANGLE_COMPONENT_BINARY_ARGS,\n+  /* A trinary expression.  The left subtree is the operator, and the\n+     right subtree is a TRINARY_ARG1.  */\n+  DEMANGLE_COMPONENT_TRINARY,\n+  /* Arguments to a trinary expression.  The left subtree is the first\n+     argument, and the right subtree is a TRINARY_ARG2.  */\n+  DEMANGLE_COMPONENT_TRINARY_ARG1,\n+  /* More arguments to a trinary expression.  The left subtree is the\n+     second argument, and the right subtree is the third argument.  */\n+  DEMANGLE_COMPONENT_TRINARY_ARG2,\n+  /* A literal.  The left subtree is the type, and the right subtree\n+     is the value, represented as a DEMANGLE_COMPONENT_NAME.  */\n+  DEMANGLE_COMPONENT_LITERAL,\n+  /* A negative literal.  Like LITERAL, but the value is negated.\n+     This is a minor hack: the NAME used for LITERAL points directly\n+     to the mangled string, but since negative numbers are mangled\n+     using 'n' instead of '-', we want a way to indicate a negative\n+     number which involves neither modifying the mangled string nor\n+     allocating a new copy of the literal in memory.  */\n+  DEMANGLE_COMPONENT_LITERAL_NEG\n+};\n+\n+/* Types which are only used internally.  */\n+\n+struct demangle_operator_info;\n+struct demangle_builtin_type_info;\n+\n+/* A node in the tree representation is an instance of a struct\n+   demangle_component.  Note that the field names of the struct are\n+   not well protected against macros defined by the file including\n+   this one.  We can fix this if it ever becomes a problem.  */\n+\n+struct demangle_component\n+{\n+  /* The type of this component.  */\n+  enum demangle_component_type type;\n+\n+  union\n+  {\n+    /* For DEMANGLE_COMPONENT_NAME.  */\n+    struct\n+    {\n+      /* A pointer to the name (which need not NULL terminated) and\n+\t its length.  */\n+      const char *s;\n+      int len;\n+    } s_name;\n+\n+    /* For DEMANGLE_COMPONENT_OPERATOR.  */\n+    struct\n+    {\n+      /* Operator.  */\n+      const struct demangle_operator_info *op;\n+    } s_operator;\n+\n+    /* For DEMANGLE_COMPONENT_EXTENDED_OPERATOR.  */\n+    struct\n+    {\n+      /* Number of arguments.  */\n+      int args;\n+      /* Name.  */\n+      struct demangle_component *name;\n+    } s_extended_operator;\n+\n+    /* For DEMANGLE_COMPONENT_CTOR.  */\n+    struct\n+    {\n+      /* Kind of constructor.  */\n+      enum gnu_v3_ctor_kinds kind;\n+      /* Name.  */\n+      struct demangle_component *name;\n+    } s_ctor;\n+\n+    /* For DEMANGLE_COMPONENT_DTOR.  */\n+    struct\n+    {\n+      /* Kind of destructor.  */\n+      enum gnu_v3_dtor_kinds kind;\n+      /* Name.  */\n+      struct demangle_component *name;\n+    } s_dtor;\n+\n+    /* For DEMANGLE_COMPONENT_BUILTIN_TYPE.  */\n+    struct\n+    {\n+      /* Builtin type.  */\n+      const struct demangle_builtin_type_info *type;\n+    } s_builtin;\n+\n+    /* For DEMANGLE_COMPONENT_SUB_STD.  */\n+    struct\n+    {\n+      /* Standard substitution string.  */\n+      const char* string;\n+      /* Length of string.  */\n+      int len;\n+    } s_string;\n+\n+    /* For DEMANGLE_COMPONENT_TEMPLATE_PARAM.  */\n+    struct\n+    {\n+      /* Template parameter index.  */\n+      long number;\n+    } s_number;\n+\n+    /* For other types.  */\n+    struct\n+    {\n+      /* Left (or only) subtree.  */\n+      struct demangle_component *left;\n+      /* Right subtree.  */\n+      struct demangle_component *right;\n+    } s_binary;\n+\n+  } u;\n+};\n+\n+/* People building mangled trees are expected to allocate instances of\n+   struct demangle_component themselves.  They can then call one of\n+   the following functions to fill them in.  */\n+\n+/* Fill in most component types with a left subtree and a right\n+   subtree.  Returns non-zero on success, zero on failure, such as an\n+   unrecognized or inappropriate component type.  */\n+\n+extern int\n+cplus_demangle_fill_component PARAMS ((struct demangle_component *fill,\n+\t\t\t\t       enum demangle_component_type,\n+\t\t\t\t       struct demangle_component *left,\n+\t\t\t\t       struct demangle_component *right));\n+\n+/* Fill in a DEMANGLE_COMPONENT_NAME.  Returns non-zero on success,\n+   zero for bad arguments.  */\n+\n+extern int\n+cplus_demangle_fill_name PARAMS ((struct demangle_component *fill,\n+\t\t\t\t  const char *, int));\n+\n+/* Fill in a DEMANGLE_COMPONENT_BUILTIN_TYPE, using the name of the\n+   builtin type (e.g., \"int\", etc.).  Returns non-zero on success,\n+   zero if the type is not recognized.  */\n+\n+extern int\n+cplus_demangle_fill_builtin_type PARAMS ((struct demangle_component *fill,\n+\t\t\t\t\t  const char *typename));\n+\n+/* Fill in a DEMANGLE_COMPONENT_OPERATOR, using the name of the\n+   operator and the number of arguments which it takes (the latter is\n+   used to disambiguate operators which can be both binary and unary,\n+   such as '-').  Returns non-zero on success, zero if the operator is\n+   not recognized.  */\n+\n+extern int\n+cplus_demangle_fill_operator PARAMS ((struct demangle_component *fill,\n+\t\t\t\t      const char *opname, int args));\n+\n+/* Fill in a DEMANGLE_COMPONENT_EXTENDED_OPERATOR, providing the\n+   number of arguments and the name.  Returns non-zero on success,\n+   zero for bad arguments.  */\n+\n+extern int\n+cplus_demangle_fill_extended_operator PARAMS ((struct demangle_component *fill,\n+\t\t\t\t\t       int numargs,\n+\t\t\t\t\t       struct demangle_component *nm));\n+\n+/* Fill in a DEMANGLE_COMPONENT_CTOR.  Returns non-zero on success,\n+   zero for bad arguments.  */\n+\n+extern int\n+cplus_demangle_fill_ctor PARAMS ((struct demangle_component *fill,\n+\t\t\t\t  enum gnu_v3_ctor_kinds kind,\n+\t\t\t\t  struct demangle_component *name));\n+\n+/* Fill in a DEMANGLE_COMPONENT_DTOR.  Returns non-zero on success,\n+   zero for bad arguments.  */\n+\n+extern int\n+cplus_demangle_fill_dtor PARAMS ((struct demangle_component *fill,\n+\t\t\t\t  enum gnu_v3_dtor_kinds kind,\n+\t\t\t\t  struct demangle_component *name));\n+\n+/* This function translates a mangled name into a struct\n+   demangle_component tree.  The first argument is the mangled name.\n+   The second argument is DMGL_* options.  This returns a pointer to a\n+   tree on success, or NULL on failure.  On success, the third\n+   argument is set to a block of memory allocated by malloc.  This\n+   block should be passed to free when the tree is no longer\n+   needed.  */\n+\n+extern struct demangle_component *\n+cplus_demangle_v3_components PARAMS ((const char *mangled,\n+\t\t\t\t      int options,\n+\t\t\t\t      void **mem));\n+\n+/* This function takes a struct demangle_component tree and returns\n+   the corresponding demangled string.  The first argument is DMGL_*\n+   options.  The second is the tree to demangle.  The third is a guess\n+   at the length of the demangled string, used to initially allocate\n+   the return buffer.  The fourth is a pointer to a size_t.  On\n+   success, this function returns a buffer allocated by malloc(), and\n+   sets the size_t pointed to by the fourth argument to the size of\n+   the allocated buffer (not the length of the returned string).  On\n+   failure, this function returns NULL, and sets the size_t pointed to\n+   by the fourth argument to 0 for an invalid tree, or to 1 for a\n+   memory allocation error.  */\n+\n+extern char *\n+cplus_demangle_print PARAMS ((int options,\n+\t\t\t      const struct demangle_component *tree,\n+\t\t\t      int estimated_length,\n+\t\t\t      size_t *p_allocated_size));\n+\n #ifdef __cplusplus\n }\n #endif /* __cplusplus */"}, {"sha": "9bc2903b52c54d8eaadcc723b9685437b961b6bf", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e777af517b3165ec4828e5ea2b9f4700f2434af/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e777af517b3165ec4828e5ea2b9f4700f2434af/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=5e777af517b3165ec4828e5ea2b9f4700f2434af", "patch": "@@ -1,3 +1,49 @@\n+2004-01-12  Ian Lance Taylor  <ian@wasabisystems.com>\n+\n+\t* cp-demangle.c: Include \"cp-demangle.h\".  If IN_GLIBCPP_V3 is\n+\tdefined, rename some functions which are to become static via\n+\t#define.\n+\t(CP_STATIC_IF_GLIBCPP_V3): Define.\n+\t(struct d_operator_info): Move definition to cp-demangle.h, and\n+\trename to demangle_operator_info.  Change all uses.\n+\t(enum d_builtin_type_print): Move definition to cp-demangle.h.\n+\t(struct d_builtin_type_info): Move definition to cp-demangle.h,\n+\tand rename to demangle_builtin_type_info.  Change all uses.\n+\t(enum d_comp_type): Move definition to include/demangle.h, and\n+\trename to demangle_component_type, and change all enums to start\n+\twith DEMANGLE_COMPONENT_ instead of D_.  Change all uses.\n+\t(struct d_comp): Move definition to include/demangle.h, and rename\n+\tto demangle_component.  Change all uses.\n+\t(struct d_info): Move definition to cp-demangle.h.\n+\t(cplus_demangle_fill_name): New function.\n+\t(cplus_demangle_fill_extended_operator): New function.\n+\t(cplus_demangle_fill_ctor): New function.\n+\t(cplus_demangle_fill_dtor): New function.\n+\t(d_make_empty): Remove type parameter.  Change all callers.\n+\t(d_make_name): Use cplus_demangle_fill_name.\n+\t(d_make_extended_operator): Use\n+\tcplus_demangle_fill_extended_operator.\n+\t(d_make_ctor): Use cplus_demangle_fill_ctor.\n+\t(d_make_dtor): Use cplus_demangle_fill_dtor.\n+\t(cplus_demangle_mangled_name): Rename from d_mangled_name.  Make\n+\tnon-static by default.  Change all callers.\n+\t(cplus_demangle_operators): Rename from d_operators.  Change all\n+\tuses.  Make non-static by default.  Add sentinel at end of array.\n+\t(d_operator_name): Adjust initialization of high for new sentinel\n+\tin cplus_demangle_operators.\n+\t(cplus_demangle_builtin_types): Rename from d_builtin_types.\n+\tChange all uses.  Make non-static by default.  Change initializer\n+\tto use D_BUILTIN_TYPE_COUNT instead of magic number 26.\n+\t(cplus_demangle_type): Rename from d_type.  Make non-static by\n+\tdefault.  Change all callers.\n+\t(cplus_demangle_init_info): Rename from d_init_info.  Make\n+\tnon-static by default.  Change all callers.\n+\t* cp-demangle.h: New file.\n+\t* cp-demint.c: New file.\n+\t* Makefile.in: Rebuild dependencies.\n+\t(CFILES): Add cp-demint.c.\n+\t(REQUIRED_OFILES): Add cp-demint.o.\n+\n 2004-01-09  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* configure.in:  Rename file to ..."}, {"sha": "139cb68a11f657a1b798171f6f761b048c305475", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e777af517b3165ec4828e5ea2b9f4700f2434af/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e777af517b3165ec4828e5ea2b9f4700f2434af/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=5e777af517b3165ec4828e5ea2b9f4700f2434af", "patch": "@@ -1,6 +1,6 @@\n #\n # Makefile\n-#   Copyright (C) 1990, 91-99, 2000, 2001, 2002, 2003\n+#   Copyright (C) 1990, 91-99, 2000, 2001, 2002, 2003, 2004\n #   Free Software Foundation\n #\n # This file is part of the libiberty library.\n@@ -130,7 +130,7 @@ COMPILE.c = $(CC) -c @DEFS@ $(LIBCFLAGS) -I. -I$(INCDIR) $(HDEFINES) @ac_libiber\n CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n \tbasename.c bcmp.c bcopy.c bsearch.c bzero.c\t\t\t\\\n \tcalloc.c choose-temp.c clock.c concat.c cp-demangle.c\t\t\\\n-\t cplus-dem.c\t\t\t\t\t\t\t\\\n+\tcp-demint.c cplus-dem.c\t\t\t\t\t\t\\\n \tdyn-string.c\t\t\t\t\t\t\t\\\n \tfdmatch.c ffs.c fibheap.c floatformat.c fnmatch.c\t\t\\\n \tgetcwd.c getopt.c getopt1.c getpagesize.c getpwd.c getruntime.c\t\\\n@@ -158,7 +158,7 @@ CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n \n # These are always included in the library.  The first four are listed\n # first and by compile time to optimize parallel builds.\n-REQUIRED_OFILES = regex.o cplus-dem.o cp-demangle.o md5.o\t\t\\\n+REQUIRED_OFILES = regex.o cplus-dem.o cp-demangle.o cp-demint.o md5.o\t\\\n \talloca.o argv.o\t\t\t\t\t\t\t\\\n \tchoose-temp.o concat.o\t\t\t\t\t\t\\\n \tdyn-string.o\t\t\t\t\t\t\t\\\n@@ -428,8 +428,11 @@ choose-temp.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n clock.o: config.h\n concat.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n copysign.o: $(INCDIR)/ansidecl.h\n-cp-demangle.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/demangle.h \\\n-\t$(INCDIR)/dyn-string.h $(INCDIR)/getopt.h $(INCDIR)/libiberty.h\n+cp-demangle.o: config.h $(INCDIR)/ansidecl.h $(srcdir)/cp-demangle.h \\\n+\t$(INCDIR)/demangle.h $(INCDIR)/dyn-string.h $(INCDIR)/getopt.h \\\n+\t$(INCDIR)/libiberty.h\n+cp-demint.o: config.h $(INCDIR)/ansidecl.h $(srcdir)/cp-demangle.h \\\n+\t$(INCDIR)/demangle.h $(INCDIR)/libiberty.h\n cplus-dem.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/demangle.h \\\n \t$(INCDIR)/libiberty.h $(INCDIR)/safe-ctype.h\n dyn-string.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/dyn-string.h \\\n@@ -450,8 +453,8 @@ hashtab.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/hashtab.h \\\n \t$(INCDIR)/libiberty.h\n hex.o: $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n \t$(INCDIR)/safe-ctype.h\n-lbasename.o: $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n-\t$(INCDIR)/safe-ctype.h $(INCDIR)/filenames.h\n+lbasename.o: $(INCDIR)/ansidecl.h $(INCDIR)/filenames.h \\\n+\t$(INCDIR)/libiberty.h $(INCDIR)/safe-ctype.h\n lrealpath.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n make-relative-prefix.o: config.h $(INCDIR)/ansidecl.h \\\n \t$(INCDIR)/libiberty.h"}, {"sha": "1c43eb8bd423a2c9f65efac03760b8ebc6e37c73", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 845, "deletions": 845, "changes": 1690, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e777af517b3165ec4828e5ea2b9f4700f2434af/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e777af517b3165ec4828e5ea2b9f4700f2434af/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=5e777af517b3165ec4828e5ea2b9f4700f2434af"}, {"sha": "d3c57ce37664dfc87458fe4edc089d858c624da1", "filename": "libiberty/cp-demangle.h", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e777af517b3165ec4828e5ea2b9f4700f2434af/libiberty%2Fcp-demangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e777af517b3165ec4828e5ea2b9f4700f2434af/libiberty%2Fcp-demangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.h?ref=5e777af517b3165ec4828e5ea2b9f4700f2434af", "patch": "@@ -0,0 +1,139 @@\n+/* Internal demangler interface for g++ V3 ABI.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor <ian@wasabisystems.com>.\n+\n+   This file is part of the libiberty library, which is part of GCC.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2 of the License, or\n+   (at your option) any later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combined\n+   executable.)\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. \n+*/\n+\n+/* This file provides some definitions shared by cp-demangle.c and\n+   cp-demint.c.  It should not be included by any other files.  */\n+\n+/* Information we keep for operators.  */\n+\n+struct demangle_operator_info\n+{\n+  /* Mangled name.  */\n+  const char *code;\n+  /* Real name.  */\n+  const char *name;\n+  /* Length of real name.  */\n+  int len;\n+  /* Number of arguments.  */\n+  int args;\n+};\n+\n+/* How to print the value of a builtin type.  */\n+\n+enum d_builtin_type_print\n+{\n+  /* Print as (type)val.  */\n+  D_PRINT_DEFAULT,\n+  /* Print as integer.  */\n+  D_PRINT_INT,\n+  /* Print as long, with trailing `l'.  */\n+  D_PRINT_LONG,\n+  /* Print as bool.  */\n+  D_PRINT_BOOL,\n+  /* Print in usual way, but here to detect void.  */\n+  D_PRINT_VOID\n+};\n+\n+/* Information we keep for a builtin type.  */\n+\n+struct demangle_builtin_type_info\n+{\n+  /* Type name.  */\n+  const char *name;\n+  /* Length of type name.  */\n+  int len;\n+  /* Type name when using Java.  */\n+  const char *java_name;\n+  /* Length of java name.  */\n+  int java_len;\n+  /* How to print a value of this type.  */\n+  enum d_builtin_type_print print;\n+};\n+\n+/* The information structure we pass around.  */\n+\n+struct d_info\n+{\n+  /* The string we are demangling.  */\n+  const char *s;\n+  /* The end of the string we are demangling.  */\n+  const char *send;\n+  /* The options passed to the demangler.  */\n+  int options;\n+  /* The next character in the string to consider.  */\n+  const char *n;\n+  /* The array of components.  */\n+  struct demangle_component *comps;\n+  /* The index of the next available component.  */\n+  int next_comp;\n+  /* The number of available component structures.  */\n+  int num_comps;\n+  /* The array of substitutions.  */\n+  struct demangle_component **subs;\n+  /* The index of the next substitution.  */\n+  int next_sub;\n+  /* The number of available entries in the subs array.  */\n+  int num_subs;\n+  /* The number of substitutions which we actually made from the subs\n+     array, plus the number of template parameter references we\n+     saw.  */\n+  int did_subs;\n+  /* The last name we saw, for constructors and destructors.  */\n+  struct demangle_component *last_name;\n+  /* A running total of the length of large expansions from the\n+     mangled name to the demangled name, such as standard\n+     substitutions and builtin types.  */\n+  int expansion;\n+};\n+\n+#define d_peek_char(di) (*((di)->n))\n+#define d_peek_next_char(di) ((di)->n[1])\n+#define d_advance(di, i) ((di)->n += (i))\n+#define d_next_char(di) (*((di)->n++))\n+#define d_str(di) ((di)->n)\n+\n+/* Functions and arrays in cp-demangle.c which are referenced by\n+   functions in cp-demint.c.  */\n+\n+extern const struct demangle_operator_info cplus_demangle_operators[];\n+\n+#define D_BUILTIN_TYPE_COUNT (26)\n+\n+extern const struct demangle_builtin_type_info\n+cplus_demangle_builtin_types[D_BUILTIN_TYPE_COUNT];\n+\n+extern struct demangle_component *\n+cplus_demangle_mangled_name PARAMS ((struct d_info *, int));\n+\n+extern struct demangle_component *\n+cplus_demangle_type PARAMS ((struct d_info *));\n+\n+extern void\n+cplus_demangle_init_info PARAMS ((const char *, int, size_t, struct d_info *));"}, {"sha": "833e89e7a90c35d1fa457eb2b137fc7871a2a6ae", "filename": "libiberty/cp-demint.c", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e777af517b3165ec4828e5ea2b9f4700f2434af/libiberty%2Fcp-demint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e777af517b3165ec4828e5ea2b9f4700f2434af/libiberty%2Fcp-demint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demint.c?ref=5e777af517b3165ec4828e5ea2b9f4700f2434af", "patch": "@@ -0,0 +1,241 @@\n+/* Demangler component interface functions.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor <ian@wasabisystems.com>.\n+\n+   This file is part of the libiberty library, which is part of GCC.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2 of the License, or\n+   (at your option) any later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combined\n+   executable.)\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. \n+*/\n+\n+/* This file implements a few interface functions which are provided\n+   for use with struct demangle_component trees.  These functions are\n+   declared in demangle.h.  These functions are closely tied to the\n+   demangler code in cp-demangle.c, and other interface functions can\n+   be found in that file.  We put these functions in a separate file\n+   because they are not needed by the demangler, and so we avoid\n+   having them pulled in by programs which only need the\n+   demangler.  */\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+\n+#include \"ansidecl.h\"\n+#include \"libiberty.h\"\n+#include \"demangle.h\"\n+#include \"cp-demangle.h\"\n+\n+/* Fill in most component types.  */\n+\n+int\n+cplus_demangle_fill_component (p, type, left, right)\n+     struct demangle_component *p;\n+     enum demangle_component_type type;\n+     struct demangle_component *left;\n+     struct demangle_component *right;\n+{\n+  if (p == NULL)\n+    return 0;\n+  switch (type)\n+    {\n+    case DEMANGLE_COMPONENT_QUAL_NAME:\n+    case DEMANGLE_COMPONENT_LOCAL_NAME:\n+    case DEMANGLE_COMPONENT_TYPED_NAME:\n+    case DEMANGLE_COMPONENT_TEMPLATE:\n+    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n+    case DEMANGLE_COMPONENT_FUNCTION_TYPE:\n+    case DEMANGLE_COMPONENT_ARRAY_TYPE:\n+    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n+    case DEMANGLE_COMPONENT_ARGLIST:\n+    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n+    case DEMANGLE_COMPONENT_UNARY:\n+    case DEMANGLE_COMPONENT_BINARY:\n+    case DEMANGLE_COMPONENT_BINARY_ARGS:\n+    case DEMANGLE_COMPONENT_TRINARY:\n+    case DEMANGLE_COMPONENT_TRINARY_ARG1:\n+    case DEMANGLE_COMPONENT_TRINARY_ARG2:\n+    case DEMANGLE_COMPONENT_LITERAL:\n+    case DEMANGLE_COMPONENT_LITERAL_NEG:\n+      break;\n+\n+      /* These component types only have one subtree.  */\n+    case DEMANGLE_COMPONENT_VTABLE:\n+    case DEMANGLE_COMPONENT_VTT:\n+    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n+    case DEMANGLE_COMPONENT_TYPEINFO:\n+    case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n+    case DEMANGLE_COMPONENT_TYPEINFO_FN:\n+    case DEMANGLE_COMPONENT_THUNK:\n+    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n+    case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n+    case DEMANGLE_COMPONENT_JAVA_CLASS:\n+    case DEMANGLE_COMPONENT_GUARD:\n+    case DEMANGLE_COMPONENT_REFTEMP:\n+    case DEMANGLE_COMPONENT_RESTRICT:\n+    case DEMANGLE_COMPONENT_VOLATILE:\n+    case DEMANGLE_COMPONENT_CONST:\n+    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n+    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n+    case DEMANGLE_COMPONENT_CONST_THIS:\n+    case DEMANGLE_COMPONENT_POINTER:\n+    case DEMANGLE_COMPONENT_REFERENCE:\n+    case DEMANGLE_COMPONENT_COMPLEX:\n+    case DEMANGLE_COMPONENT_IMAGINARY:\n+    case DEMANGLE_COMPONENT_VENDOR_TYPE:\n+    case DEMANGLE_COMPONENT_CAST:\n+      if (right != NULL)\n+\treturn 0;\n+      break;\n+\n+    default:\n+      /* Other types do not use subtrees.  */\n+      return 0;\n+    }\n+\n+  p->type = type;\n+  p->u.s_binary.left = left;\n+  p->u.s_binary.right = right;\n+\n+  return 1;\n+}\n+\n+/* Fill in a DEMANGLE_COMPONENT_BUILTIN_TYPE.  */\n+\n+int\n+cplus_demangle_fill_builtin_type (p, typename)\n+     struct demangle_component *p;\n+     const char *typename;\n+{\n+  int len;\n+  unsigned int i;\n+\n+  if (p == NULL || typename == NULL)\n+    return 0;\n+  len = strlen (typename);\n+  for (i = 0; i < D_BUILTIN_TYPE_COUNT; ++i)\n+    {\n+      if (len == cplus_demangle_builtin_types[i].len\n+\t  && strcmp (typename, cplus_demangle_builtin_types[i].name) == 0)\n+\t{\n+\t  p->type = DEMANGLE_COMPONENT_BUILTIN_TYPE;\n+\t  p->u.s_builtin.type = &cplus_demangle_builtin_types[i];\n+\t  return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Fill in a DEMANGLE_COMPONENT_OPERATOR.  */\n+\n+int\n+cplus_demangle_fill_operator (p, opname, args)\n+     struct demangle_component *p;\n+     const char *opname;\n+     int args;\n+{\n+  int len;\n+  unsigned int i;\n+\n+  if (p == NULL || opname == NULL)\n+    return 0;\n+  len = strlen (opname);\n+  for (i = 0; cplus_demangle_operators[i].name != NULL; ++i)\n+    {\n+      if (len == cplus_demangle_operators[i].len\n+\t  && args == cplus_demangle_operators[i].args\n+\t  && strcmp (opname, cplus_demangle_operators[i].name) == 0)\n+\t{\n+\t  p->type = DEMANGLE_COMPONENT_OPERATOR;\n+\t  p->u.s_operator.op = &cplus_demangle_operators[i];\n+\t  return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Translate a mangled name into components.  */\n+\n+struct demangle_component *\n+cplus_demangle_v3_components (mangled, options, mem)\n+     const char *mangled;\n+     int options;\n+     void **mem;\n+{\n+  size_t len;\n+  int type;\n+  struct d_info di;\n+  struct demangle_component *dc;\n+\n+  len = strlen (mangled);\n+\n+  if (mangled[0] == '_' && mangled[1] == 'Z')\n+    type = 0;\n+  else\n+    {\n+      if ((options & DMGL_TYPES) == 0)\n+\treturn NULL;\n+      type = 1;\n+    }\n+\n+  cplus_demangle_init_info (mangled, options, len, &di);\n+\n+  di.comps = ((struct demangle_component *)\n+\t      malloc (di.num_comps * sizeof (struct demangle_component)));\n+  di.subs = ((struct demangle_component **)\n+\t     malloc (di.num_subs * sizeof (struct demangle_component *)));\n+  if (di.comps == NULL || di.subs == NULL)\n+    {\n+      if (di.comps != NULL)\n+\tfree (di.comps);\n+      if (di.subs != NULL)\n+\tfree (di.subs);\n+      return NULL;\n+    }\n+\n+  if (! type)\n+    dc = cplus_demangle_mangled_name (&di, 1);\n+  else\n+    dc = cplus_demangle_type (&di);\n+\n+  /* If DMGL_PARAMS is set, then if we didn't consume the entire\n+     mangled string, then we didn't successfully demangle it.  */\n+  if ((options & DMGL_PARAMS) != 0 && d_peek_char (&di) != '\\0')\n+    dc = NULL;\n+\n+  free (di.subs);\n+\n+  if (dc != NULL)\n+    *mem = di.comps;\n+  else\n+    free (di.comps);\n+\n+  return dc;\n+}"}]}