{"sha": "0b040072d6aa13cb46cf660307a77df7964c326f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIwNDAwNzJkNmFhMTNjYjQ2Y2Y2NjAzMDdhNzdkZjc5NjRjMzI2Zg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2009-01-16T15:18:28Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-01-16T15:18:28Z"}, "message": "graphite.c (add_conditions_to_domain): Add the loops to the dimension of the iteration domain.\n\n2009-01-16  Sebastian Pop  <sebastian.pop@amd.com>\n\t    Tobias Grosser  <tobi.grosser@amd.com>\n\n\t* graphite.c (add_conditions_to_domain): Add the loops to \n\tthe dimension of the iteration domain.  Do copy the domain\n\tonly when it exists.\n\t(build_scop_conditions_1): Do not call add_conditions_to_domain.\n\t(add_conditions_to_constraints): New.\n\t(can_generate_code_stmt, can_generate_code): Removed.\n\t(gloog): Do not call can_generate_code.\n\t(graphite_transform_loops): Call add_conditions_to_constraints\n\tafter building the iteration domain.\n\n\nCo-Authored-By: Tobias Grosser <tobi.grosser@amd.com>\n\nFrom-SVN: r143436", "tree": {"sha": "24d15bf7ca6e7d19a5b721e09654d18d061d60c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24d15bf7ca6e7d19a5b721e09654d18d061d60c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b040072d6aa13cb46cf660307a77df7964c326f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b040072d6aa13cb46cf660307a77df7964c326f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b040072d6aa13cb46cf660307a77df7964c326f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b040072d6aa13cb46cf660307a77df7964c326f/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56c6a499944339ea8748a3343c33464de188dd89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56c6a499944339ea8748a3343c33464de188dd89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56c6a499944339ea8748a3343c33464de188dd89"}], "stats": {"total": 111, "additions": 40, "deletions": 71}, "files": [{"sha": "0dd888d4519f22e448d65e1a4cda5c54f930dc15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b040072d6aa13cb46cf660307a77df7964c326f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b040072d6aa13cb46cf660307a77df7964c326f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b040072d6aa13cb46cf660307a77df7964c326f", "patch": "@@ -1,3 +1,16 @@\n+2009-01-16  Sebastian Pop  <sebastian.pop@amd.com>\n+\t    Tobias Grosser  <tobi.grosser@amd.com>\n+\n+\t* graphite.c (add_conditions_to_domain): Add the loops to \n+\tthe dimension of the iteration domain.  Do copy the domain\n+\tonly when it exists.\n+\t(build_scop_conditions_1): Do not call add_conditions_to_domain.\n+\t(add_conditions_to_constraints): New.\n+\t(can_generate_code_stmt, can_generate_code): Removed.\n+\t(gloog): Do not call can_generate_code.\n+\t(graphite_transform_loops): Call add_conditions_to_constraints\n+\tafter building the iteration domain.\n+\n 2009-01-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/38789"}, {"sha": "b90abf1fef36962d0748cab17689e5a6ac7b5b97", "filename": "gcc/graphite.c", "status": "modified", "additions": 27, "deletions": 71, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b040072d6aa13cb46cf660307a77df7964c326f/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b040072d6aa13cb46cf660307a77df7964c326f/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=0b040072d6aa13cb46cf660307a77df7964c326f", "patch": "@@ -3112,7 +3112,7 @@ add_conditions_to_domain (graphite_bb_p gb)\n   else  \n     {\n       nb_rows = 0;\n-      nb_cols = scop_nb_params (scop) + 2;\n+      nb_cols = nb_loops_around_gb (gb) + scop_nb_params (scop) + 2;\n     }\n \n   /* Count number of necessary new rows to add the conditions to the\n@@ -3161,14 +3161,18 @@ add_conditions_to_domain (graphite_bb_p gb)\n     CloogMatrix *new_domain;\n     new_domain = cloog_matrix_alloc (nb_rows + nb_new_rows, nb_cols);\n \n-    for (i = 0; i < nb_rows; i++)\n-      for (j = 0; j < nb_cols; j++)\n-          value_assign (new_domain->p[i][j], domain->p[i][j]);\n+    if (domain)\n+      {\n+\tfor (i = 0; i < nb_rows; i++)\n+\t  for (j = 0; j < nb_cols; j++)\n+\t    value_assign (new_domain->p[i][j], domain->p[i][j]);\n+\n+\tcloog_matrix_free (domain);\n+      }\n \n-    cloog_matrix_free (domain);\n     domain = new_domain;\n     GBB_DOMAIN (gb) = new_domain;\n-  }     \n+  }\n \n   /* Add the conditions to the new enlarged domain matrix.  */\n   row = nb_rows;\n@@ -3358,7 +3362,6 @@ build_scop_conditions_1 (VEC (gimple, heap) **conditions,\n     {\n       GBB_CONDITIONS (gbb) = VEC_copy (gimple, heap, *conditions);\n       GBB_CONDITION_CASES (gbb) = VEC_copy (gimple, heap, *cases);\n-      add_conditions_to_domain (gbb);\n     }\n \n   dom = get_dominated_by (CDI_DOMINATORS, bb);\n@@ -3515,6 +3518,19 @@ build_scop_conditions (scop_p scop)\n   return res;\n }\n \n+/* Traverses all the GBBs of the SCOP and add their constraints to the\n+   iteration domains.  */\n+\n+static void\n+add_conditions_to_constraints (scop_p scop)\n+{\n+  int i;\n+  graphite_bb_p gbb;\n+\n+  for (i = 0; VEC_iterate (graphite_bb_p, SCOP_BBS (scop), i, gbb); i++)\n+    add_conditions_to_domain (gbb);\n+}\n+\n /* Build the current domain matrix: the loops belonging to the current\n    SCOP, and that vary for the execution of the current basic block.\n    Returns false if there is no loop in SCOP.  */\n@@ -4895,64 +4911,6 @@ find_transform (scop_p scop)\n   return stmt;\n }\n \n-/* Returns true when it is possible to generate code for this STMT.\n-   For the moment we cannot generate code when Cloog decides to\n-   duplicate a statement, as we do not do a copy, but a move.\n-   USED_BASIC_BLOCKS records the blocks that have already been seen.\n-   We return false if we have to generate code twice for the same\n-   block.  */\n-\n-static bool \n-can_generate_code_stmt (struct clast_stmt *stmt,\n-\t\t\tstruct pointer_set_t *used_basic_blocks)\n-{\n-  if (!stmt)\n-    return true;\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_root))\n-    return can_generate_code_stmt (stmt->next, used_basic_blocks);\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_user))\n-    {\n-      CloogStatement *cs = ((struct clast_user_stmt *) stmt)->statement;\n-      graphite_bb_p gbb = (graphite_bb_p) cloog_statement_usr (cs);\n-\n-      if (pointer_set_contains (used_basic_blocks, gbb))\n-\treturn false;\n-      pointer_set_insert (used_basic_blocks, gbb);\n-      return can_generate_code_stmt (stmt->next, used_basic_blocks);\n-    }\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_for))\n-    return can_generate_code_stmt (((struct clast_for *) stmt)->body,\n-\t\t\t\t   used_basic_blocks)\n-      && can_generate_code_stmt (stmt->next, used_basic_blocks);\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_guard))\n-    return can_generate_code_stmt (((struct clast_guard *) stmt)->then,\n-\t\t\t\t   used_basic_blocks);\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_block))\n-    return can_generate_code_stmt (((struct clast_block *) stmt)->body,\n-\t\t\t\t   used_basic_blocks)\n-      && can_generate_code_stmt (stmt->next, used_basic_blocks);\n-\n-  return false;\n-}\n-\n-/* Returns true when it is possible to generate code for this STMT.  */\n-\n-static bool \n-can_generate_code (struct clast_stmt *stmt)\n-{\n-  bool result;\n-  struct pointer_set_t *used_basic_blocks = pointer_set_create ();\n-\n-  result = can_generate_code_stmt (stmt, used_basic_blocks);\n-  pointer_set_destroy (used_basic_blocks);\n-  return result;\n-}\n-\n /* Remove from the CFG the REGION.  */\n \n static inline void\n@@ -5413,12 +5371,6 @@ gloog (scop_p scop, struct clast_stmt *stmt)\n   loop_p context_loop;\n   ifsese if_region = NULL;\n \n-  if (!can_generate_code (stmt))\n-    {\n-      cloog_clast_free (stmt);\n-      return;\n-    }\n-\n   if_region = move_sese_in_condition (SCOP_REGION (scop));\n   sese_build_livein_liveouts (SCOP_REGION (scop));\n   scop_insert_phis_for_liveouts (SCOP_REGION (scop),\n@@ -6099,8 +6051,10 @@ graphite_transform_loops (void)\n \n       build_scop_canonical_schedules (scop);\n       build_bb_loops (scop);\n+\n       if (!build_scop_conditions (scop))\n \tcontinue;\n+\n       find_scop_parameters (scop);\n       build_scop_context (scop);\n \n@@ -6116,6 +6070,8 @@ graphite_transform_loops (void)\n       if (!build_scop_iteration_domain (scop))\n \tcontinue;\n \n+      add_conditions_to_constraints (scop);\n+\n       build_scop_data_accesses (scop);\n       build_scop_dynamic_schedules (scop);\n "}]}