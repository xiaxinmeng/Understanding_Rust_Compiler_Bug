{"sha": "7c821effc4714595e7923fb466946abb38055edc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M4MjFlZmZjNDcxNDU5NWU3OTIzZmI0NjY5NDZhYmIzODA1NWVkYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-17T13:50:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-17T13:50:34Z"}, "message": "[multiple changes]\n\n2013-10-17  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Validated_Access_Subprogram_Instance): According\n\tto AI05-288, actuals for access_to_subprograms must be subtype\n\tconformant with the generic formal.  Previous to AI05-288\n\tonly mode conformance was required, but the AI is a binding\n\tinterpretation that applies to previous versions of the language,\n\n2013-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_ugn.texi: Minor text correction.\n\t* ug_words: Add entry for -gnateu /IGNORE_UNRECOGNIZED.\n\t* vms_data.ads: Add /IGNORE_UNRECOGNIZED for -gnateu.\n\n2013-10-17  Tristan Gingold  <gingold@adacore.com>\n\n\t* impunit.adb (Non_Imp_File_Names_95): Add g-cppexc.\n\n2013-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Constituent): Move the check\n\tconcerning option Part_Of to routine Check_Matching_Constituent.\n\t(Check_Matching_Constituent): Verify that an abstract state\n\tthat acts as a constituent has the prope Part_Op option in\n\tits aspect/pragma Abstract_State.  Account for the case when a\n\tconstituent comes from a private child or private sibling.\n\t* sem_util.ads, sem_util.adb (Is_Child_Or_Sibling): New routine.\n\nFrom-SVN: r203760", "tree": {"sha": "417f83743832170dac8844cee4c94048bc49dd91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/417f83743832170dac8844cee4c94048bc49dd91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c821effc4714595e7923fb466946abb38055edc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c821effc4714595e7923fb466946abb38055edc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c821effc4714595e7923fb466946abb38055edc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c821effc4714595e7923fb466946abb38055edc/comments", "author": null, "committer": null, "parents": [{"sha": "c2cd3032e67390915044effcfe7d0ffd2c6fccbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2cd3032e67390915044effcfe7d0ffd2c6fccbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2cd3032e67390915044effcfe7d0ffd2c6fccbd"}], "stats": {"total": 343, "additions": 283, "deletions": 60}, "files": [{"sha": "6d8be828aaa34f01f27ffb19d266cf8d3f3c1ed4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7c821effc4714595e7923fb466946abb38055edc", "patch": "@@ -1,3 +1,31 @@\n+2013-10-17  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Validated_Access_Subprogram_Instance): According\n+\tto AI05-288, actuals for access_to_subprograms must be subtype\n+\tconformant with the generic formal.  Previous to AI05-288\n+\tonly mode conformance was required, but the AI is a binding\n+\tinterpretation that applies to previous versions of the language,\n+\n+2013-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_ugn.texi: Minor text correction.\n+\t* ug_words: Add entry for -gnateu /IGNORE_UNRECOGNIZED.\n+\t* vms_data.ads: Add /IGNORE_UNRECOGNIZED for -gnateu.\n+\n+2013-10-17  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* impunit.adb (Non_Imp_File_Names_95): Add g-cppexc.\n+\n+2013-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Constituent): Move the check\n+\tconcerning option Part_Of to routine Check_Matching_Constituent.\n+\t(Check_Matching_Constituent): Verify that an abstract state\n+\tthat acts as a constituent has the prope Part_Op option in\n+\tits aspect/pragma Abstract_State.  Account for the case when a\n+\tconstituent comes from a private child or private sibling.\n+\t* sem_util.ads, sem_util.adb (Is_Child_Or_Sibling): New routine.\n+\n 2013-10-17  Tristan Gingold  <gingold@adacore.com>\n \n \t* g-cppexc.adb, g-cppexc.ads: New files."}, {"sha": "a82f20b08c706dc80b3d90099d66901ffcc6082d", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=7c821effc4714595e7923fb466946abb38055edc", "patch": "@@ -3935,7 +3935,7 @@ TF            33  I 128 128\n @item -gnateu\n @cindex @option{-gnateu} (@command{gcc})\n Ignore unrecognized validity, warning, and style switches that\n-apppear after this switch is given. This may be useful when\n+appear after this switch is given. This may be useful when\n compiling sources developed on a later version of the compiler\n with an earlier version. Of course the earlier version must\n support this switch."}, {"sha": "6b6b45febaaf4d737be68795554d431de1828493", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=7c821effc4714595e7923fb466946abb38055edc", "patch": "@@ -253,6 +253,7 @@ package body Impunit is\n     (\"g-cgideb\", F),  -- GNAT.CGI.Debug\n     (\"g-comlin\", F),  -- GNAT.Command_Line\n     (\"g-comver\", F),  -- GNAT.Compiler_Version\n+    (\"g-cppexc\", F),  -- GNAT.CPP_Exceptions\n     (\"g-crc32 \", F),  -- GNAT.CRC32\n     (\"g-ctrl_c\", F),  -- GNAT.Ctrl_C\n     (\"g-curexc\", F),  -- GNAT.Current_Exception"}, {"sha": "1572e4ff6dc1efedd19e2e67f9f02a843d09b2fe", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=7c821effc4714595e7923fb466946abb38055edc", "patch": "@@ -10529,23 +10529,13 @@ package body Sem_Ch12 is\n          --  only mode conformance was required.\n \n          --  This is a binding interpretation that applies to previous versions\n-         --  of the language, but for now we retain the milder check in order\n-         --  to preserve ACATS tests. These will be protested eventually ???\n+         --  of the language, no need to maintain previous weaker checks.\n \n-         if Ada_Version < Ada_2012 then\n-            Check_Mode_Conformant\n-              (Designated_Type (Act_T),\n-               Designated_Type (A_Gen_T),\n-               Actual,\n-               Get_Inst => True);\n-\n-         else\n-            Check_Subtype_Conformant\n-              (Designated_Type (Act_T),\n-               Designated_Type (A_Gen_T),\n-               Actual,\n-               Get_Inst => True);\n-         end if;\n+         Check_Subtype_Conformant\n+           (Designated_Type (Act_T),\n+            Designated_Type (A_Gen_T),\n+            Actual,\n+            Get_Inst => True);\n \n          if Ekind (Base_Type (Act_T)) = E_Access_Protected_Subprogram_Type then\n             if Ekind (A_Gen_T) = E_Access_Subprogram_Type then"}, {"sha": "0830f090be92ef7bd8b9d7f837703013186294c0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 53, "deletions": 43, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=7c821effc4714595e7923fb466946abb38055edc", "patch": "@@ -21439,51 +21439,74 @@ package body Sem_Prag is\n                   Error_Msg_NE\n                     (\"duplicate use of constituent &\", Constit, Constit_Id);\n                   return;\n-               end if;\n \n-               --  The related package has no hidden states, nothing to match.\n-               --  This case arises when the constituents are states coming\n-               --  from a private child.\n+               --  A state can act as a constituent only when it is part of\n+               --  another state. This relation is expressed by option Part_Of\n+               --  of pragma Abstract_State.\n \n-               if No (Hidden_States) then\n-                  return;\n+               elsif Ekind (Constit_Id) = E_Abstract_State then\n+                  if not Is_Part_Of (Constit_Id, State_Id) then\n+                     Error_Msg_Name_1 := Chars (State_Id);\n+                     Error_Msg_NE\n+                       (\"state & is not a valid constituent of ancestor \"\n+                        & \"state %\", Constit, Constit_Id);\n+                     return;\n+\n+                  --  The constituent has the proper Part_Of option, but may\n+                  --  not appear in the immediate hidden state of the related\n+                  --  package. This case arises when the constituent comes from\n+                  --  a private child or a private sibling. Recognize these\n+                  --  scenarios to avoid generating a bogus error message.\n+\n+                  elsif Is_Child_Or_Sibling\n+                          (Pack_1        => Scope (State_Id),\n+                           Pack_2        => Scope (Constit_Id),\n+                           Private_Child => True)\n+                  then\n+                     return;\n+                  end if;\n                end if;\n \n                --  Inspect the hidden states of the related package looking for\n                --  a match.\n \n-               State_Elmt := First_Elmt (Hidden_States);\n-               while Present (State_Elmt) loop\n+               if Present (Hidden_States) then\n+                  State_Elmt := First_Elmt (Hidden_States);\n+                  while Present (State_Elmt) loop\n \n-                  --  A valid hidden state or variable participates in a\n-                  --  refinement. Add the constituent to the list of processed\n-                  --  items to aid with the detection of duplicate constituent\n-                  --  use. Remove the constituent from Hidden_States to signal\n-                  --  that it has already been used.\n+                     --  A valid hidden state or variable acts as a constituent\n \n-                  if Node (State_Elmt) = Constit_Id then\n-                     Add_Item (Constit_Id, Constituents_Seen);\n-                     Remove_Elmt (Hidden_States, State_Elmt);\n+                     if Node (State_Elmt) = Constit_Id then\n \n-                     --  Collect the constituent in the list of refinement\n-                     --  items. Establish a relation between the refined state\n-                     --  and its constituent.\n+                        --  Add the constituent to the lis of processed items\n+                        --  to aid with the detection of duplicates. Remove the\n+                        --  constituent from Hidden_States to signal that it\n+                        --  has already been matched.\n \n-                     Append_Elmt\n-                       (Constit_Id, Refinement_Constituents (State_Id));\n-                     Set_Refined_State (Constit_Id, State_Id);\n+                        Add_Item (Constit_Id, Constituents_Seen);\n+                        Remove_Elmt (Hidden_States, State_Elmt);\n \n-                     --  The state has at least one legal constituent, mark the\n-                     --  start of the refinement region. The region ends when\n-                     --  the body declarations end (see Analyze_Declarations).\n+                        --  Collect the constituent in the list of refinement\n+                        --  items. Establish a relation between the refined\n+                        --  state and its constituent.\n \n-                     Set_Has_Visible_Refinement (State_Id);\n+                        Append_Elmt\n+                          (Constit_Id, Refinement_Constituents (State_Id));\n+                        Set_Refined_State (Constit_Id, State_Id);\n \n-                     return;\n-                  end if;\n+                        --  The state has at least one legal constituent, mark\n+                        --  the start of the refinement region. The region ends\n+                        --  when the body declarations end (see routine\n+                        --  Analyze_Declarations).\n \n-                  Next_Elmt (State_Elmt);\n-               end loop;\n+                        Set_Has_Visible_Refinement (State_Id);\n+\n+                        return;\n+                     end if;\n+\n+                     Next_Elmt (State_Elmt);\n+                  end loop;\n+               end if;\n \n                --  If we get here, we are refining a state that is not hidden\n                --  with respect to the related package.\n@@ -21548,19 +21571,6 @@ package body Sem_Prag is\n                   if Ekind_In (Constit_Id, E_Abstract_State, E_Variable) then\n                      Check_Matching_Constituent (Constit_Id);\n \n-                     --  A state can act as a constituent only when it is part\n-                     --  of another state. This relation is expressed by option\n-                     --  \"Part_Of\" of pragma Abstract_State.\n-\n-                     if Ekind (Constit_Id) = E_Abstract_State\n-                       and then not Is_Part_Of (Constit_Id, State_Id)\n-                     then\n-                        Error_Msg_Name_1 := Chars (State_Id);\n-                        Error_Msg_NE\n-                          (\"state & is not a valid constituent of ancestor \"\n-                           & \"state %\", Constit, Constit_Id);\n-                     end if;\n-\n                   else\n                      Error_Msg_NE\n                        (\"constituent & must denote a variable or state\","}, {"sha": "d2d8a41554c8c20109d5099217894983794121f3", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7c821effc4714595e7923fb466946abb38055edc", "patch": "@@ -8324,6 +8324,181 @@ package body Sem_Util is\n                   Is_RTE (Root_Type (Under), RO_WW_Super_String));\n    end Is_Bounded_String;\n \n+   -------------------------\n+   -- Is_Child_Or_Sibling --\n+   -------------------------\n+\n+   function Is_Child_Or_Sibling\n+     (Pack_1        : Entity_Id;\n+      Pack_2        : Entity_Id;\n+      Private_Child : Boolean) return Boolean\n+   is\n+      function Distance_From_Standard (Pack : Entity_Id) return Nat;\n+      --  Given an arbitrary package, return the number of \"climbs\" necessary\n+      --  to reach scope Standard_Standard.\n+\n+      procedure Equalize_Depths\n+        (Pack           : in out Entity_Id;\n+         Depth          : in out Nat;\n+         Depth_To_Reach : Nat);\n+      --  Given an arbitrary package, its depth and a target depth to reach,\n+      --  climb the scope chain until the said depth is reached. The pointer\n+      --  to the package and its depth a modified during the climb.\n+\n+      function Is_Child (Pack : Entity_Id) return Boolean;\n+      --  Given a package Pack, determine whether it is a child package that\n+      --  satisfies the privacy requirement (if set).\n+\n+      ----------------------------\n+      -- Distance_From_Standard --\n+      ----------------------------\n+\n+      function Distance_From_Standard (Pack : Entity_Id) return Nat is\n+         Dist : Nat;\n+         Scop : Entity_Id;\n+\n+      begin\n+         Dist := 0;\n+         Scop := Pack;\n+         while Present (Scop) and then Scop /= Standard_Standard loop\n+            Dist := Dist + 1;\n+            Scop := Scope (Scop);\n+         end loop;\n+\n+         return Dist;\n+      end Distance_From_Standard;\n+\n+      ---------------------\n+      -- Equalize_Depths --\n+      ---------------------\n+\n+      procedure Equalize_Depths\n+        (Pack           : in out Entity_Id;\n+         Depth          : in out Nat;\n+         Depth_To_Reach : Nat)\n+      is\n+      begin\n+         --  The package must be at a greater or equal depth\n+\n+         if Depth < Depth_To_Reach then\n+            raise Program_Error;\n+         end if;\n+\n+         --  Climb the scope chain until the desired depth is reached\n+\n+         while Present (Pack) and then Depth /= Depth_To_Reach loop\n+            Pack  := Scope (Pack);\n+            Depth := Depth - 1;\n+         end loop;\n+      end Equalize_Depths;\n+\n+      --------------\n+      -- Is_Child --\n+      --------------\n+\n+      function Is_Child (Pack : Entity_Id) return Boolean is\n+      begin\n+         if Is_Child_Unit (Pack) then\n+            if Private_Child then\n+               return Is_Private_Descendant (Pack);\n+            else\n+               return True;\n+            end if;\n+\n+         --  The package is nested, it cannot act a child or a sibling\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_Child;\n+\n+      --  Local variables\n+\n+      P_1       : Entity_Id := Pack_1;\n+      P_1_Child : Boolean   := False;\n+      P_1_Depth : Nat       := Distance_From_Standard (P_1);\n+      P_2       : Entity_Id := Pack_2;\n+      P_2_Child : Boolean   := False;\n+      P_2_Depth : Nat       := Distance_From_Standard (P_2);\n+\n+   --  Start of processing for Is_Child_Or_Sibling\n+\n+   begin\n+      pragma Assert\n+        (Ekind (Pack_1) = E_Package and then Ekind (Pack_2) = E_Package);\n+\n+      --  Both packages denote the same entity, therefore they cannot be\n+      --  children or siblings.\n+\n+      if P_1 = P_2 then\n+         return False;\n+\n+      --  One of the packages is at a deeper level than the other. Note that\n+      --  both may still come from differen hierarchies.\n+\n+      --        (root)           P_2\n+      --        /    \\            :\n+      --       X     P_2    or    X\n+      --       :                  :\n+      --      P_1                P_1\n+\n+      elsif P_1_Depth > P_2_Depth then\n+         Equalize_Depths (P_1, P_1_Depth, P_2_Depth);\n+         P_1_Child := True;\n+\n+      --        (root)           P_1\n+      --        /    \\            :\n+      --      P_1     X     or    X\n+      --              :           :\n+      --             P_2         P_2\n+\n+      elsif P_2_Depth > P_1_Depth then\n+         Equalize_Depths (P_2, P_2_Depth, P_1_Depth);\n+         P_2_Child := True;\n+      end if;\n+\n+      --  At this stage the package pointers have been elevated to the same\n+      --  depth. If the related entities are the same, then one package is a\n+      --  potential child of the other:\n+\n+      --      P_1\n+      --       :\n+      --       X    became   P_1 P_2   or vica versa\n+      --       :\n+      --      P_2\n+\n+      if P_1 = P_2 then\n+         if P_1_Child then\n+            return Is_Child (Pack_1);\n+         else pragma Assert (P_2_Child);\n+            return Is_Child (Pack_2);\n+         end if;\n+\n+      --  The packages may come from the same package chain or from entirely\n+      --  different hierarcies. To determine this, climb the scope stack until\n+      --  a common root is found.\n+\n+      --        (root)      (root 1)  (root 2)\n+      --        /    \\         |         |\n+      --      P_1    P_2      P_1       P_2\n+\n+      else\n+         while Present (P_1) and then Present (P_2) loop\n+\n+            --  The two packages may be siblings\n+\n+            if P_1 = P_2 then\n+               return Is_Child (Pack_1) and then Is_Child (Pack_2);\n+            end if;\n+\n+            P_1 := Scope (P_1);\n+            P_2 := Scope (P_2);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Is_Child_Or_Sibling;\n+\n    -----------------------------\n    -- Is_Concurrent_Interface --\n    -----------------------------"}, {"sha": "ffaf661523e5bc7b98cf66b01634ebc3b5a45170", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=7c821effc4714595e7923fb466946abb38055edc", "patch": "@@ -945,6 +945,16 @@ package Sem_Util is\n    --  This is the RM definition, a type is a descendent of another type if it\n    --  is the same type or is derived from a descendent of the other type.\n \n+   function Is_Child_Or_Sibling\n+     (Pack_1        : Entity_Id;\n+      Pack_2        : Entity_Id;\n+      Private_Child : Boolean) return Boolean;\n+   --  Determine the following relations between two arbitrary packages:\n+   --    1) One package is the parent of a child package\n+   --    2) Both packages are siblings and share a common parent\n+   --  If flag Private_Child is set, then the child in case 1) or both siblings\n+   --  in case 2) must be private.\n+\n    function Is_Concurrent_Interface (T : Entity_Id) return Boolean;\n    --  First determine whether type T is an interface and then check whether\n    --  it is of protected, synchronized or task kind."}, {"sha": "1f73288481ae3919e8e153c842a9f6f1965d9cef", "filename": "gcc/ada/ug_words", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fug_words", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fug_words", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fug_words?ref=7c821effc4714595e7923fb466946abb38055edc", "patch": "@@ -74,6 +74,7 @@ gcc -c          ^ GNAT COMPILE\n -gnateS         ^ /SCO_OUTPUT\n -gnatet         ^ /WRITE_TARGET_DEPENDENT_INFO\n -gnateT         ^ /READ_TARGET_DEPENDENT_INFO\n+-gnateu         ^ /IGNORE_UNRECOGNIZED\n -gnateV         ^ /PARAMETER_VALIDITY_CHECK\n -gnateY         ^ /IGNORE_STYLE_CHECKS_PRAGMAS\n -gnatE          ^ /CHECKS=ELABORATION"}, {"sha": "aa22577efce1baa1d98308b76d71b42eb9e9d578", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c821effc4714595e7923fb466946abb38055edc/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=7c821effc4714595e7923fb466946abb38055edc", "patch": "@@ -1802,6 +1802,13 @@ package VMS_Data is\n    --   otherwise ignored. Allows style checks to be fully controlled by\n    --   command line qualifiers.\n \n+   S_GCC_IgnoreU : aliased constant S := \"/IGNORE_UNRECOGNIZED \"           &\n+                                             \"-gnateu\";\n+   --        /IGNORE_UNRECOGNIZED\n+   --\n+   --   Causes unrecognized style switches, validity switches, and warning\n+   --   switches to be ignored rather than generating an error message.\n+\n    S_GCC_Immed   : aliased constant S := \"/IMMEDIATE_ERRORS \"              &\n                                              \"-gnatdO\";\n    --        /NOIMMEDIATE_ERRORS (D)\n@@ -3706,6 +3713,7 @@ package VMS_Data is\n                      S_GCC_IdentX  'Access,\n                      S_GCC_IgnoreR 'Access,\n                      S_GCC_IgnoreS 'Access,\n+                     S_GCC_IgnoreU 'Access,\n                      S_GCC_Immed   'Access,\n                      S_GCC_Inline  'Access,\n                      S_GCC_InlineX 'Access,"}]}