{"sha": "c88cc0aa644836c361ce5d8ff5225a9c12333dea", "node_id": "C_kwDOANBUbNoAKGM4OGNjMGFhNjQ0ODM2YzM2MWNlNWQ4ZmY1MjI1YTljMTIzMzNkZWE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-06-29T09:02:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-29T09:02:29Z"}, "message": "Merge #1342\n\n1342: Refactor name-resolution pass r=philberty a=philberty\n\nThis is a patch series which cleans up the code in the name resolution pass. Prior to\r\n#1307 we used to build up canonical path segments to do name resolution of types\r\nand paths, this lead to confusing code in how we handle impl blocks Self type and\r\nin general. This fixes that confusion to make the code more maintainable.\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "7dd285e72782c02dd5b2a93abb65f66169e7a63a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7dd285e72782c02dd5b2a93abb65f66169e7a63a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c88cc0aa644836c361ce5d8ff5225a9c12333dea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJivBUlCRBK7hj4Ov3rIwAAs/cIAAxEJ6ylSaqaQvkZCJ6g+XQ1\nFVwXMiCgVPMwzNuJ/C+uuQHwZXsEprDw8LQ9lmF4xcsT7qCoruJ1oXoFrwTBXq1u\nGERODSfpDCsui5kLAluTqf/z1vltttKNnmWHl4xy8LBmCjGRHeu4cj+ZU5dfXRcd\nOpx9bDGF+WDiWfvL2iKWdZRTFoNrsw8t6/thlt2c2C7sehjUQld9NI/KY7TQx0LU\n3NV57FwSfVmahxEy5F5B4Z8rkokl7N753ijqrUeAZfVGPT2eo15UPxuPAMa6EyBI\n3MGS+SBMSLzsOKTOEb85dXSiRz7mwtHoiZUIG165hsMqoKunr8YvXHuzspXD+LI=\n=6NK6\n-----END PGP SIGNATURE-----\n", "payload": "tree 7dd285e72782c02dd5b2a93abb65f66169e7a63a\nparent 65a06a817585faf7fb44fbc1c71173a00f9a407f\nparent 5b8502d862f647edb1ab41467759177983b4ddfc\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1656493349 +0000\ncommitter GitHub <noreply@github.com> 1656493349 +0000\n\nMerge #1342\n\n1342: Refactor name-resolution pass r=philberty a=philberty\n\nThis is a patch series which cleans up the code in the name resolution pass. Prior to\r\n#1307 we used to build up canonical path segments to do name resolution of types\r\nand paths, this lead to confusing code in how we handle impl blocks Self type and\r\nin general. This fixes that confusion to make the code more maintainable.\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c88cc0aa644836c361ce5d8ff5225a9c12333dea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c88cc0aa644836c361ce5d8ff5225a9c12333dea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c88cc0aa644836c361ce5d8ff5225a9c12333dea/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65a06a817585faf7fb44fbc1c71173a00f9a407f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65a06a817585faf7fb44fbc1c71173a00f9a407f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65a06a817585faf7fb44fbc1c71173a00f9a407f"}, {"sha": "5b8502d862f647edb1ab41467759177983b4ddfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b8502d862f647edb1ab41467759177983b4ddfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b8502d862f647edb1ab41467759177983b4ddfc"}], "stats": {"total": 1626, "additions": 620, "deletions": 1006}, "files": [{"sha": "cfe23728b8dcd506229b3d8b5dca63d5372616e7", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -97,6 +97,7 @@ GRS_OBJS = \\\n     rust/rust-ast-resolve-type.o \\\n     rust/rust-ast-resolve-path.o \\\n     rust/rust-ast-resolve-stmt.o \\\n+    rust/rust-ast-resolve-struct-expr-field.o \\\n     rust/rust-hir-type-check.o \\\n     rust/rust-privacy-check.o \\\n     rust/rust-privacy-ctx.o \\"}, {"sha": "2a78918fbdbc402aa1a13ec4f557cbcf393d65b7", "filename": "gcc/rust/resolve/rust-ast-resolve-base.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.cc?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -30,7 +30,7 @@ ResolverBase::resolve_visibility (const AST::Visibility &vis)\n   if (vis.has_path ())\n     {\n       auto path = vis.get_path ();\n-      ResolvePath::go (&path, parent);\n+      ResolvePath::go (&path);\n \n       // Do we need to lookup something here?\n       // Is it just about resolving the names correctly so we can look them up"}, {"sha": "32f30bcea62508342d7e3517d48b6517636f8fa3", "filename": "gcc/rust/resolve/rust-ast-resolve-base.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -200,13 +200,11 @@ class ResolverBase : public AST::ASTVisitor\n   void visit (AST::BareFunctionType &);\n \n protected:\n-  ResolverBase (NodeId parent)\n+  ResolverBase ()\n     : resolver (Resolver::get ()), mappings (Analysis::Mappings::get ()),\n-      resolved_node (UNKNOWN_NODEID), parent (parent), locus (Location ())\n+      resolved_node (UNKNOWN_NODEID)\n   {}\n \n-  bool resolved () const { return resolved_node != UNKNOWN_NODEID; }\n-\n   /**\n    * Resolve a visibility's path through the name resolver\n    */\n@@ -215,8 +213,6 @@ class ResolverBase : public AST::ASTVisitor\n   Resolver *resolver;\n   Analysis::Mappings *mappings;\n   NodeId resolved_node;\n-  NodeId parent;\n-  Location locus;\n };\n \n } // namespace Resolver"}, {"sha": "2087bad80845c508189ef2ddcbb1686f1d298688", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "modified", "additions": 82, "deletions": 73, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -28,17 +28,17 @@ namespace Rust {\n namespace Resolver {\n \n void\n-ResolveExpr::go (AST::Expr *expr, NodeId parent, const CanonicalPath &prefix,\n+ResolveExpr::go (AST::Expr *expr, const CanonicalPath &prefix,\n \t\t const CanonicalPath &canonical_prefix)\n {\n-  ResolveExpr resolver (parent, prefix, canonical_prefix);\n+  ResolveExpr resolver (prefix, canonical_prefix);\n   expr->accept_vis (resolver);\n }\n \n void\n ResolveExpr::visit (AST::TupleIndexExpr &expr)\n {\n-  resolve_expr (expr.get_tuple_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_tuple_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n@@ -48,58 +48,58 @@ ResolveExpr::visit (AST::TupleExpr &expr)\n     return;\n \n   for (auto &elem : expr.get_tuple_elems ())\n-    resolve_expr (elem.get (), expr.get_node_id ());\n+    ResolveExpr::go (elem.get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::PathInExpression &expr)\n {\n-  ResolvePath::go (&expr, parent);\n+  ResolvePath::go (&expr);\n }\n \n void\n ResolveExpr::visit (AST::QualifiedPathInExpression &expr)\n {\n-  ResolvePath::go (&expr, parent);\n+  ResolvePath::go (&expr);\n }\n \n void\n ResolveExpr::visit (AST::ReturnExpr &expr)\n {\n   if (expr.has_returned_expr ())\n-    resolve_expr (expr.get_returned_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_returned_expr ().get (), prefix,\n+\t\t     canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::CallExpr &expr)\n {\n-  resolve_expr (expr.get_function_expr ().get (), expr.get_node_id ());\n-  auto const &in_params = expr.get_params ();\n-  for (auto &param : in_params)\n-    resolve_expr (param.get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_function_expr ().get (), prefix, canonical_prefix);\n+  for (auto &param : expr.get_params ())\n+    ResolveExpr::go (param.get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::MethodCallExpr &expr)\n {\n-  resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_receiver_expr ().get (), prefix, canonical_prefix);\n \n   if (expr.get_method_name ().has_generic_args ())\n     {\n       AST::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n-      ResolveTypeToCanonicalPath::type_resolve_generic_args (args);\n+      ResolveType::type_resolve_generic_args (args);\n     }\n \n   auto const &in_params = expr.get_params ();\n   for (auto &param : in_params)\n-    resolve_expr (param.get (), expr.get_node_id ());\n+    ResolveExpr::go (param.get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::AssignmentExpr &expr)\n {\n-  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_left_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_right_expr ().get (), prefix, canonical_prefix);\n \n   // need to verify the assignee\n   VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n@@ -130,15 +130,15 @@ ResolveExpr::visit (AST::IdentifierExpr &expr)\n void\n ResolveExpr::visit (AST::ArithmeticOrLogicalExpr &expr)\n {\n-  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_left_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_right_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::CompoundAssignmentExpr &expr)\n {\n-  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_left_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_right_expr ().get (), prefix, canonical_prefix);\n \n   // need to verify the assignee\n   VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n@@ -147,57 +147,57 @@ ResolveExpr::visit (AST::CompoundAssignmentExpr &expr)\n void\n ResolveExpr::visit (AST::ComparisonExpr &expr)\n {\n-  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_left_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_right_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::LazyBooleanExpr &expr)\n {\n-  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_left_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_right_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::NegationExpr &expr)\n {\n-  resolve_expr (expr.get_negated_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_negated_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::TypeCastExpr &expr)\n {\n-  ResolveType::go (expr.get_type_to_cast_to ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_casted_expr ().get (), expr.get_node_id ());\n+  ResolveType::go (expr.get_type_to_cast_to ().get ());\n+  ResolveExpr::go (expr.get_casted_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::IfExpr &expr)\n {\n-  resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_condition_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_if_block ().get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::IfExprConseqElse &expr)\n {\n-  resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_else_block ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_condition_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_if_block ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_else_block ().get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::IfExprConseqIf &expr)\n {\n-  resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_conseq_if_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_condition_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_if_block ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_conseq_if_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::IfLetExpr &expr)\n {\n-  resolve_expr (expr.get_value_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_value_expr ().get (), prefix, canonical_prefix);\n \n   NodeId scope_node_id = expr.get_node_id ();\n   resolver->get_name_scope ().push (scope_node_id);\n@@ -209,10 +209,10 @@ ResolveExpr::visit (AST::IfLetExpr &expr)\n \n   for (auto &pattern : expr.get_patterns ())\n     {\n-      PatternDeclaration::go (pattern.get (), expr.get_node_id ());\n+      PatternDeclaration::go (pattern.get ());\n     }\n \n-  resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_if_block ().get (), prefix, canonical_prefix);\n \n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n@@ -233,19 +233,19 @@ ResolveExpr::visit (AST::BlockExpr &expr)\n   for (auto &s : expr.get_statements ())\n     {\n       if (s->is_item ())\n-\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n+\tResolveStmt::go (s.get (), prefix, canonical_prefix,\n \t\t\t CanonicalPath::create_empty ());\n     }\n \n   for (auto &s : expr.get_statements ())\n     {\n       if (!s->is_item ())\n-\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n+\tResolveStmt::go (s.get (), prefix, canonical_prefix,\n \t\t\t CanonicalPath::create_empty ());\n     }\n \n   if (expr.has_tail_expr ())\n-    resolve_expr (expr.get_tail_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_tail_expr ().get (), prefix, canonical_prefix);\n \n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n@@ -262,7 +262,7 @@ void\n ResolveExpr::visit (AST::ArrayElemsValues &elems)\n {\n   for (auto &elem : elems.get_values ())\n-    resolve_expr (elem.get (), elems.get_node_id ());\n+    ResolveExpr::go (elem.get (), prefix, canonical_prefix);\n }\n \n void\n@@ -274,55 +274,55 @@ ResolveExpr::visit (AST::ArrayExpr &expr)\n void\n ResolveExpr::visit (AST::ArrayIndexExpr &expr)\n {\n-  resolve_expr (expr.get_array_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_index_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_array_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_index_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n-ResolveExpr::visit (AST::ArrayElemsCopied &elems)\n+ResolveExpr::visit (AST::ArrayElemsCopied &expr)\n {\n-  resolve_expr (elems.get_num_copies ().get (), elems.get_node_id ());\n-  resolve_expr (elems.get_elem_to_copy ().get (), elems.get_node_id ());\n+  ResolveExpr::go (expr.get_num_copies ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_elem_to_copy ().get (), prefix, canonical_prefix);\n }\n \n // this this an empty struct constructor like 'S {}'\n void\n ResolveExpr::visit (AST::StructExprStruct &struct_expr)\n {\n-  resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n+  ResolveExpr::go (&struct_expr.get_struct_name (), prefix, canonical_prefix);\n }\n \n // this this a struct constructor with fields\n void\n ResolveExpr::visit (AST::StructExprStructFields &struct_expr)\n {\n-  resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n+  ResolveExpr::go (&struct_expr.get_struct_name (), prefix, canonical_prefix);\n \n   if (struct_expr.has_struct_base ())\n     {\n       AST::StructBase &base = struct_expr.get_struct_base ();\n-      resolve_expr (base.get_base_struct ().get (), struct_expr.get_node_id ());\n+      ResolveExpr::go (base.get_base_struct ().get (), prefix,\n+\t\t       canonical_prefix);\n     }\n \n   auto const &struct_fields = struct_expr.get_fields ();\n   for (auto &struct_field : struct_fields)\n     {\n-      ResolveStructExprField::go (struct_field.get (),\n-\t\t\t\t  struct_expr.get_node_id (), prefix,\n+      ResolveStructExprField::go (struct_field.get (), prefix,\n \t\t\t\t  canonical_prefix);\n     }\n }\n \n void\n ResolveExpr::visit (AST::GroupedExpr &expr)\n {\n-  resolve_expr (expr.get_expr_in_parens ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_expr_in_parens ().get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::FieldAccessExpr &expr)\n {\n-  resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_receiver_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n@@ -349,7 +349,7 @@ ResolveExpr::visit (AST::LoopExpr &expr)\n \t  rust_error_at (locus, \"was defined here\");\n \t});\n     }\n-  resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_loop_block ().get (), prefix, canonical_prefix);\n }\n \n void\n@@ -379,7 +379,7 @@ ResolveExpr::visit (AST::BreakExpr &expr)\n     }\n \n   if (expr.has_break_expr ())\n-    resolve_expr (expr.get_break_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_break_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n@@ -406,8 +406,9 @@ ResolveExpr::visit (AST::WhileLoopExpr &expr)\n \t  rust_error_at (locus, \"was defined here\");\n \t});\n     }\n-  resolve_expr (expr.get_predicate_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n+\n+  ResolveExpr::go (expr.get_predicate_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_loop_block ().get (), prefix, canonical_prefix);\n }\n \n void\n@@ -445,10 +446,11 @@ ResolveExpr::visit (AST::ForLoopExpr &expr)\n   resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n \n   // resolve the expression\n-  PatternDeclaration::go (expr.get_pattern ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_iterator_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n+  PatternDeclaration::go (expr.get_pattern ().get ());\n+  ResolveExpr::go (expr.get_iterator_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_loop_block ().get (), prefix, canonical_prefix);\n \n+  // done\n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n   resolver->get_label_scope ().pop ();\n@@ -484,19 +486,20 @@ ResolveExpr::visit (AST::ContinueExpr &expr)\n void\n ResolveExpr::visit (AST::BorrowExpr &expr)\n {\n-  resolve_expr (expr.get_borrowed_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_borrowed_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::DereferenceExpr &expr)\n {\n-  resolve_expr (expr.get_dereferenced_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_dereferenced_expr ().get (), prefix,\n+\t\t   canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::MatchExpr &expr)\n {\n-  resolve_expr (expr.get_scrutinee_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_scrutinee_expr ().get (), prefix, canonical_prefix);\n   for (auto &match_case : expr.get_match_cases ())\n     {\n       // each arm is in its own scope\n@@ -511,16 +514,17 @@ ResolveExpr::visit (AST::MatchExpr &expr)\n       // resolve\n       AST::MatchArm &arm = match_case.get_arm ();\n       if (arm.has_match_arm_guard ())\n-\tresolve_expr (arm.get_guard_expr ().get (), expr.get_node_id ());\n+\tResolveExpr::go (arm.get_guard_expr ().get (), prefix,\n+\t\t\t canonical_prefix);\n \n       // insert any possible new patterns\n       for (auto &pattern : arm.get_patterns ())\n \t{\n-\t  PatternDeclaration::go (pattern.get (), expr.get_node_id ());\n+\t  PatternDeclaration::go (pattern.get ());\n \t}\n \n       // resolve the body\n-      resolve_expr (match_case.get_expr ().get (), expr.get_node_id ());\n+      ResolveExpr::go (match_case.get_expr ().get (), prefix, canonical_prefix);\n \n       // done\n       resolver->get_name_scope ().pop ();\n@@ -532,20 +536,20 @@ ResolveExpr::visit (AST::MatchExpr &expr)\n void\n ResolveExpr::visit (AST::RangeFromToExpr &expr)\n {\n-  resolve_expr (expr.get_from_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_to_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_from_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_to_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::RangeFromExpr &expr)\n {\n-  resolve_expr (expr.get_from_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_from_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n ResolveExpr::visit (AST::RangeToExpr &expr)\n {\n-  resolve_expr (expr.get_to_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_to_expr ().get (), prefix, canonical_prefix);\n }\n \n void\n@@ -557,9 +561,14 @@ ResolveExpr::visit (AST::RangeFullExpr &expr)\n void\n ResolveExpr::visit (AST::RangeFromToInclExpr &expr)\n {\n-  resolve_expr (expr.get_from_expr ().get (), expr.get_node_id ());\n-  resolve_expr (expr.get_to_expr ().get (), expr.get_node_id ());\n+  ResolveExpr::go (expr.get_from_expr ().get (), prefix, canonical_prefix);\n+  ResolveExpr::go (expr.get_to_expr ().get (), prefix, canonical_prefix);\n }\n \n+ResolveExpr::ResolveExpr (const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix)\n+  : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+{}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "11a846ac8cd87fda6031405532249c9c1dd3686e", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -30,7 +30,7 @@ class ResolveExpr : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Expr *expr, NodeId parent, const CanonicalPath &prefix,\n+  static void go (AST::Expr *expr, const CanonicalPath &prefix,\n \t\t  const CanonicalPath &canonical_prefix);\n \n   void visit (AST::TupleIndexExpr &expr) override;\n@@ -119,18 +119,9 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::RangeFromToInclExpr &expr) override;\n \n-protected:\n-  void resolve_expr (AST::Expr *e, NodeId parent)\n-  {\n-    ResolveExpr::go (e, parent, prefix, canonical_prefix);\n-  }\n-\n private:\n-  ResolveExpr (NodeId parent, const CanonicalPath &prefix,\n-\t       const CanonicalPath &canonical_prefix)\n-    : ResolverBase (parent), prefix (prefix),\n-      canonical_prefix (canonical_prefix)\n-  {}\n+  ResolveExpr (const CanonicalPath &prefix,\n+\t       const CanonicalPath &canonical_prefix);\n \n   const CanonicalPath &prefix;\n   const CanonicalPath &canonical_prefix;"}, {"sha": "192ecaf42e65f8fd5478208b0750410d5304758d", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -66,7 +66,8 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto decl = CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t\tconstant.get_identifier ());\n     auto path = prefix.append (decl);\n \n     resolver->get_name_scope ().insert (\n@@ -80,7 +81,8 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::Function &function) override\n   {\n-    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto decl = CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t\tfunction.get_function_name ());\n     auto path = prefix.append (decl);\n \n     resolver->get_name_scope ().insert (\n@@ -94,7 +96,8 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::Method &method) override\n   {\n-    auto decl = ResolveMethodItemToCanonicalPath::resolve (method);\n+    auto decl = CanonicalPath::new_seg (method.get_node_id (),\n+\t\t\t\t\tmethod.get_method_name ());\n     auto path = prefix.append (decl);\n \n     resolver->get_name_scope ().insert (\n@@ -108,7 +111,7 @@ class ResolveToplevelImplItem : public ResolverBase\n \n private:\n   ResolveToplevelImplItem (const CanonicalPath &prefix)\n-    : ResolverBase (UNKNOWN_NODEID), prefix (prefix)\n+    : ResolverBase (), prefix (prefix)\n   {\n     rust_assert (!prefix.is_empty ());\n   }\n@@ -130,7 +133,9 @@ class ResolveTopLevelTraitItems : public ResolverBase\n \n   void visit (AST::TraitItemFunc &function) override\n   {\n-    auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (function);\n+    auto decl = CanonicalPath::new_seg (\n+      function.get_node_id (),\n+      function.get_trait_function_decl ().get_identifier ());\n     auto path = prefix.append (decl);\n     auto cpath = canonical_prefix.append (decl);\n \n@@ -148,7 +153,8 @@ class ResolveTopLevelTraitItems : public ResolverBase\n \n   void visit (AST::TraitItemMethod &method) override\n   {\n-    auto decl = ResolveTraitItemMethodToCanonicalPath::resolve (method);\n+    auto decl = CanonicalPath::new_seg (\n+      method.get_node_id (), method.get_trait_method_decl ().get_identifier ());\n     auto path = prefix.append (decl);\n     auto cpath = canonical_prefix.append (decl);\n \n@@ -166,7 +172,8 @@ class ResolveTopLevelTraitItems : public ResolverBase\n \n   void visit (AST::TraitItemConst &constant) override\n   {\n-    auto decl = ResolveTraitItemConstToCanonicalPath::resolve (constant);\n+    auto decl = CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t\tconstant.get_identifier ());\n     auto path = prefix.append (decl);\n     auto cpath = canonical_prefix.append (decl);\n \n@@ -184,7 +191,8 @@ class ResolveTopLevelTraitItems : public ResolverBase\n \n   void visit (AST::TraitItemType &type) override\n   {\n-    auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n+    auto decl\n+      = CanonicalPath::new_seg (type.get_node_id (), type.get_identifier ());\n     auto path = prefix.append (decl);\n     auto cpath = canonical_prefix.append (decl);\n \n@@ -203,8 +211,7 @@ class ResolveTopLevelTraitItems : public ResolverBase\n private:\n   ResolveTopLevelTraitItems (const CanonicalPath &prefix,\n \t\t\t     const CanonicalPath &canonical_prefix)\n-    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n-      canonical_prefix (canonical_prefix)\n+    : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n   {}\n \n   const CanonicalPath &prefix;\n@@ -260,7 +267,7 @@ class ResolveToplevelExternItem : public ResolverBase\n \n private:\n   ResolveToplevelExternItem (const CanonicalPath &prefix)\n-    : ResolverBase (UNKNOWN_NODEID), prefix (prefix)\n+    : ResolverBase (), prefix (prefix)\n   {}\n \n   const CanonicalPath &prefix;"}, {"sha": "1ad91af3917c715a558d8355b296175c2b7f77f3", "filename": "gcc/rust/resolve/rust-ast-resolve-item.cc", "status": "modified", "additions": 140, "deletions": 145, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -22,6 +22,12 @@\n \n namespace Rust {\n namespace Resolver {\n+\n+ResolveTraitItems::ResolveTraitItems (const CanonicalPath &prefix,\n+\t\t\t\t      const CanonicalPath &canonical_prefix)\n+  : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+{}\n+\n void\n ResolveTraitItems::go (AST::TraitItem *item, const CanonicalPath &prefix,\n \t\t       const CanonicalPath &canonical_prefix)\n@@ -36,20 +42,22 @@ ResolveTraitItems::go (AST::TraitItem *item, const CanonicalPath &prefix,\n void\n ResolveTraitItems::visit (AST::TraitItemType &type)\n {\n-  auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n+  auto decl\n+    = CanonicalPath::new_seg (type.get_node_id (), type.get_identifier ());\n   auto path = prefix.append (decl);\n   auto cpath = canonical_prefix.append (decl);\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   type.get_node_id (), cpath);\n \n   for (auto &bound : type.get_type_param_bounds ())\n-    ResolveTypeBound::go (bound.get (), type.get_node_id ());\n+    ResolveTypeBound::go (bound.get ());\n }\n \n void\n ResolveTraitItems::visit (AST::TraitItemFunc &func)\n {\n-  auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (func);\n+  auto decl = CanonicalPath::new_seg (\n+    func.get_node_id (), func.get_trait_function_decl ().get_identifier ());\n   auto path = prefix.append (decl);\n   auto cpath = canonical_prefix.append (decl);\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n@@ -67,33 +75,26 @@ ResolveTraitItems::visit (AST::TraitItemFunc &func)\n   if (function.has_generics ())\n     {\n       for (auto &generic : function.get_generic_params ())\n-\tResolveGenericParam::go (generic.get (), func.get_node_id ());\n+\tResolveGenericParam::go (generic.get ());\n     }\n \n   if (function.has_return_type ())\n-    ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+    ResolveType::go (function.get_return_type ().get ());\n \n   // we make a new scope so the names of parameters are resolved and shadowed\n   // correctly\n   for (auto &param : function.get_function_params ())\n     {\n-      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n-      PatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t      param.get_node_id ());\n-\n-      // the mutability checker needs to verify for immutable decls the number\n-      // of assignments are <1. This marks an implicit assignment\n-      resolver->mark_assignment_to_decl (\n-\tparam.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n+      PatternDeclaration::go (param.get_pattern ().get ());\n     }\n \n   if (function.has_where_clause ())\n     ResolveWhereClause::Resolve (function.get_where_clause ());\n \n   // trait items have an optional body\n   if (func.has_definition ())\n-    ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n-\t\t     cpath);\n+    ResolveExpr::go (func.get_definition ().get (), path, cpath);\n \n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n@@ -103,7 +104,9 @@ ResolveTraitItems::visit (AST::TraitItemFunc &func)\n void\n ResolveTraitItems::visit (AST::TraitItemMethod &func)\n {\n-  auto decl = ResolveTraitItemMethodToCanonicalPath::resolve (func);\n+  auto decl\n+    = CanonicalPath::new_seg (func.get_node_id (),\n+\t\t\t      func.get_trait_method_decl ().get_identifier ());\n   auto path = prefix.append (decl);\n   auto cpath = canonical_prefix.append (decl);\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n@@ -121,11 +124,11 @@ ResolveTraitItems::visit (AST::TraitItemMethod &func)\n   if (function.has_generics ())\n     {\n       for (auto &generic : function.get_generic_params ())\n-\tResolveGenericParam::go (generic.get (), func.get_node_id ());\n+\tResolveGenericParam::go (generic.get ());\n     }\n \n   if (function.has_return_type ())\n-    ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+    ResolveType::go (function.get_return_type ().get ());\n \n   // self turns into (self: Self) as a function param\n   AST::SelfParam &self_param = function.get_self_param ();\n@@ -141,33 +144,23 @@ ResolveTraitItems::visit (AST::TraitItemMethod &func)\n \n   AST::TypePath self_type_path (std::move (segments), self_param.get_locus ());\n \n-  ResolveType::go (&self_type_path, self_param.get_node_id ());\n-  PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n-\n-  resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n-\t\t\t\t     self_pattern.get_node_id ());\n+  ResolveType::go (&self_type_path);\n+  PatternDeclaration::go (&self_pattern);\n \n   // we make a new scope so the names of parameters are resolved and shadowed\n   // correctly\n   for (auto &param : function.get_function_params ())\n     {\n-      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n-      PatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t      param.get_node_id ());\n-\n-      // the mutability checker needs to verify for immutable decls the number\n-      // of assignments are <1. This marks an implicit assignment\n-      resolver->mark_assignment_to_decl (\n-\tparam.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n+      PatternDeclaration::go (param.get_pattern ().get ());\n     }\n \n   if (function.has_where_clause ())\n     ResolveWhereClause::Resolve (function.get_where_clause ());\n \n   // trait items have an optional body\n   if (func.has_definition ())\n-    ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n-\t\t     cpath);\n+    ResolveExpr::go (func.get_definition ().get (), path, cpath);\n \n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n@@ -177,25 +170,24 @@ ResolveTraitItems::visit (AST::TraitItemMethod &func)\n void\n ResolveTraitItems::visit (AST::TraitItemConst &constant)\n {\n-  auto decl = ResolveTraitItemConstToCanonicalPath::resolve (constant);\n+  auto decl = CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t      constant.get_identifier ());\n   auto path = prefix.append (decl);\n   auto cpath = canonical_prefix.append (decl);\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   constant.get_node_id (), cpath);\n \n-  ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n+  ResolveType::go (constant.get_type ().get ());\n \n   if (constant.has_expr ())\n-    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (), path,\n-\t\t     cpath);\n-\n-  // the mutability checker needs to verify for immutable decls the number\n-  // of assignments are <1. This marks an implicit assignment\n-  resolver->mark_decl_mutability (constant.get_node_id (), false);\n-  resolver->mark_assignment_to_decl (constant.get_node_id (),\n-\t\t\t\t     constant.get_node_id ());\n+    ResolveExpr::go (constant.get_expr ().get (), path, cpath);\n }\n \n+ResolveItem::ResolveItem (const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix)\n+  : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+{}\n+\n void\n ResolveItem::go (AST::Item *item, const CanonicalPath &prefix,\n \t\t const CanonicalPath &canonical_prefix)\n@@ -220,13 +212,13 @@ ResolveItem::visit (AST::TypeAlias &alias)\n   if (alias.has_generics ())\n     {\n       for (auto &generic : alias.get_generic_params ())\n-\tResolveGenericParam::go (generic.get (), alias.get_node_id ());\n+\tResolveGenericParam::go (generic.get ());\n     }\n \n   if (alias.has_where_clause ())\n     ResolveWhereClause::Resolve (alias.get_where_clause ());\n \n-  ResolveType::go (alias.get_type_aliased ().get (), alias.get_node_id ());\n+  ResolveType::go (alias.get_type_aliased ().get ());\n \n   resolver->get_type_scope ().pop ();\n }\n@@ -285,7 +277,7 @@ ResolveItem::visit (AST::TupleStruct &struct_decl)\n     {\n       for (auto &generic : struct_decl.get_generic_params ())\n \t{\n-\t  ResolveGenericParam::go (generic.get (), struct_decl.get_node_id ());\n+\t  ResolveGenericParam::go (generic.get ());\n \t}\n     }\n \n@@ -299,8 +291,7 @@ ResolveItem::visit (AST::TupleStruct &struct_decl)\n \n       resolve_visibility (field.get_visibility ());\n \n-      ResolveType::go (field.get_field_type ().get (),\n-\t\t       struct_decl.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get ());\n     }\n \n   resolver->get_type_scope ().pop ();\n@@ -325,7 +316,7 @@ ResolveItem::visit (AST::Enum &enum_decl)\n     {\n       for (auto &generic : enum_decl.get_generic_params ())\n \t{\n-\t  ResolveGenericParam::go (generic.get (), enum_decl.get_node_id ());\n+\t  ResolveGenericParam::go (generic.get ());\n \t}\n     }\n \n@@ -369,7 +360,7 @@ ResolveItem::visit (AST::EnumItemTuple &item)\n       if (field.get_field_type ()->is_marked_for_strip ())\n \tcontinue;\n \n-      ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get ());\n     }\n }\n \n@@ -388,7 +379,7 @@ ResolveItem::visit (AST::EnumItemStruct &item)\n       if (field.get_field_type ()->is_marked_for_strip ())\n \tcontinue;\n \n-      ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get ());\n     }\n }\n \n@@ -423,7 +414,7 @@ ResolveItem::visit (AST::StructStruct &struct_decl)\n     {\n       for (auto &generic : struct_decl.get_generic_params ())\n \t{\n-\t  ResolveGenericParam::go (generic.get (), struct_decl.get_node_id ());\n+\t  ResolveGenericParam::go (generic.get ());\n \t}\n     }\n \n@@ -437,8 +428,7 @@ ResolveItem::visit (AST::StructStruct &struct_decl)\n \n       resolve_visibility (field.get_visibility ());\n \n-      ResolveType::go (field.get_field_type ().get (),\n-\t\t       struct_decl.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get ());\n     }\n \n   resolver->get_type_scope ().pop ();\n@@ -463,7 +453,7 @@ ResolveItem::visit (AST::Union &union_decl)\n     {\n       for (auto &generic : union_decl.get_generic_params ())\n \t{\n-\t  ResolveGenericParam::go (generic.get (), union_decl.get_node_id ());\n+\t  ResolveGenericParam::go (generic.get ());\n \t}\n     }\n \n@@ -475,8 +465,7 @@ ResolveItem::visit (AST::Union &union_decl)\n       if (field.get_field_type ()->is_marked_for_strip ())\n \tcontinue;\n \n-      ResolveType::go (field.get_field_type ().get (),\n-\t\t       union_decl.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get ());\n     }\n \n   resolver->get_type_scope ().pop ();\n@@ -492,40 +481,31 @@ ResolveItem::visit (AST::StaticItem &var)\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   var.get_node_id (), cpath);\n \n-  ResolveType::go (var.get_type ().get (), var.get_node_id ());\n-  ResolveExpr::go (var.get_expr ().get (), var.get_node_id (), path, cpath);\n-\n-  // the mutability checker needs to verify for immutable decls the number\n-  // of assignments are <1. This marks an implicit assignment\n-  resolver->mark_assignment_to_decl (var.get_node_id (), var.get_node_id ());\n+  ResolveType::go (var.get_type ().get ());\n+  ResolveExpr::go (var.get_expr ().get (), path, cpath);\n }\n \n void\n ResolveItem::visit (AST::ConstantItem &constant)\n {\n-  auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+  auto decl = CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t      constant.get_identifier ());\n   auto path = prefix.append (decl);\n   auto cpath = canonical_prefix.append (decl);\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   constant.get_node_id (), cpath);\n \n   resolve_visibility (constant.get_visibility ());\n \n-  ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n-  ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (), path,\n-\t\t   cpath);\n-\n-  // the mutability checker needs to verify for immutable decls the number\n-  // of assignments are <1. This marks an implicit assignment\n-  resolver->mark_decl_mutability (constant.get_node_id (), false);\n-  resolver->mark_assignment_to_decl (constant.get_node_id (),\n-\t\t\t\t     constant.get_node_id ());\n+  ResolveType::go (constant.get_type ().get ());\n+  ResolveExpr::go (constant.get_expr ().get (), path, cpath);\n }\n \n void\n ResolveItem::visit (AST::Function &function)\n {\n-  auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+  auto decl = CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t      function.get_function_name ());\n   auto path = prefix.append (decl);\n   auto cpath = canonical_prefix.append (decl);\n \n@@ -545,34 +525,29 @@ ResolveItem::visit (AST::Function &function)\n   if (function.has_generics ())\n     {\n       for (auto &generic : function.get_generic_params ())\n-\tResolveGenericParam::go (generic.get (), function.get_node_id ());\n+\tResolveGenericParam::go (generic.get ());\n     }\n \n   // resolve any where clause items\n   if (function.has_where_clause ())\n     ResolveWhereClause::Resolve (function.get_where_clause ());\n \n   if (function.has_return_type ())\n-    ResolveType::go (function.get_return_type ().get (),\n-\t\t     function.get_node_id ());\n+    ResolveType::go (function.get_return_type ().get ());\n \n   // we make a new scope so the names of parameters are resolved and shadowed\n   // correctly\n   for (auto &param : function.get_function_params ())\n     {\n-      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n-      PatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t      param.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n+      PatternDeclaration::go (param.get_pattern ().get ());\n \n       // the mutability checker needs to verify for immutable decls the number\n       // of assignments are <1. This marks an implicit assignment\n-      resolver->mark_assignment_to_decl (\n-\tparam.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n     }\n \n   // resolve the function body\n-  ResolveExpr::go (function.get_definition ().get (), function.get_node_id (),\n-\t\t   path, cpath);\n+  ResolveExpr::go (function.get_definition ().get (), path, cpath);\n \n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n@@ -594,7 +569,7 @@ ResolveItem::visit (AST::InherentImpl &impl_block)\n     {\n       for (auto &generic : impl_block.get_generic_params ())\n \t{\n-\t  ResolveGenericParam::go (generic.get (), impl_block.get_node_id ());\n+\t  ResolveGenericParam::go (generic.get ());\n \t}\n     }\n \n@@ -605,27 +580,24 @@ ResolveItem::visit (AST::InherentImpl &impl_block)\n   // FIXME this needs to be protected behind nominal type-checks see:\n   // rustc --explain E0118\n \n-  CanonicalPath self_cpath = CanonicalPath::create_empty ();\n-  bool canonicalize_type_with_generics = false;\n-  NodeId resolved_node\n-    = ResolveType::go (impl_block.get_type ().get (), impl_block.get_node_id (),\n-\t\t       canonicalize_type_with_generics, &self_cpath);\n+  NodeId resolved_node = ResolveType::go (impl_block.get_type ().get ());\n   if (resolved_node == UNKNOWN_NODEID)\n     {\n       resolver->get_type_scope ().pop ();\n       resolver->get_name_scope ().pop ();\n       return;\n     }\n-  rust_assert (!self_cpath.is_empty ());\n \n   // Setup paths\n-  bool canonicalize_type_args = !impl_block.has_generics ();\n-  bool type_resolve_generic_args = false;\n+  CanonicalPath self_cpath = CanonicalPath::create_empty ();\n+  bool ok = ResolveTypeToCanonicalPath::go (impl_block.get_type ().get (),\n+\t\t\t\t\t    self_cpath);\n+  rust_assert (ok);\n \n+  std::string raw_impl_type_path = impl_block.get_type ()->as_string ();\n   CanonicalPath impl_type\n-    = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n-\t\t\t\t\t   canonicalize_type_args,\n-\t\t\t\t\t   type_resolve_generic_args);\n+    = CanonicalPath::new_seg (impl_block.get_type ()->get_node_id (),\n+\t\t\t      raw_impl_type_path);\n   CanonicalPath impl_prefix = prefix.append (impl_type);\n \n   // see https://godbolt.org/z/a3vMbsT6W\n@@ -666,7 +638,8 @@ ResolveItem::visit (AST::InherentImpl &impl_block)\n void\n ResolveItem::visit (AST::Method &method)\n {\n-  auto decl = ResolveMethodItemToCanonicalPath::resolve (method);\n+  auto decl\n+    = CanonicalPath::new_seg (method.get_node_id (), method.get_method_name ());\n   auto path = prefix.append (decl);\n   auto cpath = canonical_prefix.append (decl);\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n@@ -686,15 +659,15 @@ ResolveItem::visit (AST::Method &method)\n   if (method.has_generics ())\n     {\n       for (auto &generic : method.get_generic_params ())\n-\tResolveGenericParam::go (generic.get (), method.get_node_id ());\n+\tResolveGenericParam::go (generic.get ());\n     }\n \n   // resolve any where clause items\n   if (method.has_where_clause ())\n     ResolveWhereClause::Resolve (method.get_where_clause ());\n \n   if (method.has_return_type ())\n-    ResolveType::go (method.get_return_type ().get (), method.get_node_id ());\n+    ResolveType::go (method.get_return_type ().get ());\n \n   // self turns into (self: Self) as a function param\n   AST::SelfParam &self_param = method.get_self_param ();\n@@ -710,33 +683,23 @@ ResolveItem::visit (AST::Method &method)\n \n   AST::TypePath self_type_path (std::move (segments), self_param.get_locus ());\n \n-  ResolveType::go (&self_type_path, self_param.get_node_id ());\n-  PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n-\n-  resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n-\t\t\t\t     self_pattern.get_node_id ());\n+  ResolveType::go (&self_type_path);\n+  PatternDeclaration::go (&self_pattern);\n \n   // we make a new scope so the names of parameters are resolved and shadowed\n   // correctly\n   for (auto &param : method.get_function_params ())\n     {\n-      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n-      PatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t      param.get_node_id ());\n-\n-      // the mutability checker needs to verify for immutable decls the number\n-      // of assignments are <1. This marks an implicit assignment\n-      resolver->mark_assignment_to_decl (\n-\tparam.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n+      PatternDeclaration::go (param.get_pattern ().get ());\n     }\n \n   // resolve any where clause items\n   if (method.has_where_clause ())\n     ResolveWhereClause::Resolve (method.get_where_clause ());\n \n   // resolve the function body\n-  ResolveExpr::go (method.get_definition ().get (), method.get_node_id (), path,\n-\t\t   cpath);\n+  ResolveExpr::go (method.get_definition ().get (), path, cpath);\n \n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n@@ -759,60 +722,65 @@ ResolveItem::visit (AST::TraitImpl &impl_block)\n     {\n       for (auto &generic : impl_block.get_generic_params ())\n \t{\n-\t  ResolveGenericParam::go (generic.get (), impl_block.get_node_id ());\n+\t  ResolveGenericParam::go (generic.get ());\n \t}\n     }\n \n   // resolve any where clause items\n   if (impl_block.has_where_clause ())\n     ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n \n-  CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n-  bool canonicalize_type_with_generics = false;\n-  NodeId trait_resolved_node\n-    = ResolveType::go (&impl_block.get_trait_path (), impl_block.get_node_id (),\n-\t\t       canonicalize_type_with_generics, &canonical_trait_type);\n+  // CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n+  NodeId trait_resolved_node = ResolveType::go (&impl_block.get_trait_path ());\n   if (trait_resolved_node == UNKNOWN_NODEID)\n     {\n       resolver->get_type_scope ().pop ();\n       resolver->get_name_scope ().pop ();\n       return;\n     }\n \n-  CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n-  NodeId type_resolved_node\n-    = ResolveType::go (impl_block.get_type ().get (), impl_block.get_node_id (),\n-\t\t       canonicalize_type_with_generics, &canonical_impl_type);\n+  //   CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n+  NodeId type_resolved_node = ResolveType::go (impl_block.get_type ().get ());\n   if (type_resolved_node == UNKNOWN_NODEID)\n     {\n       resolver->get_type_scope ().pop ();\n       resolver->get_name_scope ().pop ();\n       return;\n     }\n-  rust_assert (!canonical_impl_type.is_empty ());\n \n+  bool ok;\n   // setup paths\n-  bool canonicalize_type_args = !impl_block.has_generics ();\n-  bool type_resolve_generic_args = false;\n+  CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n+  ok = ResolveTypeToCanonicalPath::go (&impl_block.get_trait_path (),\n+\t\t\t\t       canonical_trait_type);\n+  rust_assert (ok);\n+\n+  CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n+  ok = ResolveTypeToCanonicalPath::go (impl_block.get_type ().get (),\n+\t\t\t\t       canonical_impl_type);\n+  rust_assert (ok);\n \n+  // raw paths\n+  std::string raw_impl_type_path = impl_block.get_type ()->as_string ();\n   CanonicalPath impl_type_seg\n-    = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n-\t\t\t\t\t   canonicalize_type_args,\n-\t\t\t\t\t   type_resolve_generic_args);\n+    = CanonicalPath::new_seg (impl_block.get_type ()->get_node_id (),\n+\t\t\t      raw_impl_type_path);\n+\n+  std::string raw_trait_type_path = impl_block.get_trait_path ().as_string ();\n   CanonicalPath trait_type_seg\n-    = ResolveTypeToCanonicalPath::resolve (impl_block.get_trait_path (),\n-\t\t\t\t\t   canonicalize_type_args,\n-\t\t\t\t\t   type_resolve_generic_args);\n+    = CanonicalPath::new_seg (impl_block.get_trait_path ().get_node_id (),\n+\t\t\t      raw_trait_type_path);\n \n   CanonicalPath projection\n-    = TraitImplProjection::resolve (impl_block.get_node_id (), trait_type_seg,\n-\t\t\t\t    impl_type_seg);\n+    = CanonicalPath::trait_impl_projection_seg (impl_block.get_node_id (),\n+\t\t\t\t\t\ttrait_type_seg, impl_type_seg);\n   CanonicalPath impl_prefix = prefix.append (projection);\n \n   // setup canonical-path\n   CanonicalPath canonical_projection\n-    = TraitImplProjection::resolve (impl_block.get_node_id (),\n-\t\t\t\t    canonical_trait_type, canonical_impl_type);\n+    = CanonicalPath::trait_impl_projection_seg (impl_block.get_node_id (),\n+\t\t\t\t\t\tcanonical_trait_type,\n+\t\t\t\t\t\tcanonical_impl_type);\n   CanonicalPath cpath = CanonicalPath::create_empty ();\n   if (canonical_prefix.size () <= 1)\n     {\n@@ -869,7 +837,7 @@ ResolveItem::visit (AST::Trait &trait)\n \n   for (auto &generic : trait.get_generic_params ())\n     {\n-      ResolveGenericParam::go (generic.get (), trait.get_node_id ());\n+      ResolveGenericParam::go (generic.get ());\n     }\n \n   // Self is an implicit TypeParam so lets mark it as such\n@@ -880,7 +848,7 @@ ResolveItem::visit (AST::Trait &trait)\n     {\n       for (auto &bound : trait.get_type_param_bounds ())\n \t{\n-\t  ResolveTypeBound::go (bound.get (), trait.get_node_id ());\n+\t  ResolveTypeBound::go (bound.get ());\n \t}\n     }\n \n@@ -913,6 +881,28 @@ ResolveItem::visit (AST::ExternBlock &extern_block)\n     }\n }\n \n+void\n+ResolveItem::resolve_impl_item (AST::TraitImplItem *item,\n+\t\t\t\tconst CanonicalPath &prefix,\n+\t\t\t\tconst CanonicalPath &canonical_prefix)\n+{\n+  ResolveImplItems::go (item, prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveItem::resolve_impl_item (AST::InherentImplItem *item,\n+\t\t\t\tconst CanonicalPath &prefix,\n+\t\t\t\tconst CanonicalPath &canonical_prefix)\n+{\n+  ResolveImplItems::go (item, prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveItem::resolve_extern_item (AST::ExternalItem *item)\n+{\n+  ResolveExternItem::go (item);\n+}\n+\n static void\n flatten_glob (const AST::UseTreeGlob &glob,\n \t      std::vector<AST::SimplePath> &paths);\n@@ -1037,9 +1027,14 @@ ResolveItem::visit (AST::UseDeclaration &use_item)\n   auto to_resolve = flatten_use_dec_to_paths (use_item);\n \n   for (auto &path : to_resolve)\n-    ResolvePath::go (&path, parent);\n+    ResolvePath::go (&path);\n }\n \n+ResolveImplItems::ResolveImplItems (const CanonicalPath &prefix,\n+\t\t\t\t    const CanonicalPath &canonical_prefix)\n+  : ResolveItem (prefix, canonical_prefix)\n+{}\n+\n void\n ResolveImplItems::go (AST::InherentImplItem *item, const CanonicalPath &prefix,\n \t\t      const CanonicalPath &canonical_prefix)\n@@ -1099,18 +1094,17 @@ ResolveExternItem::visit (AST::ExternalFunctionItem &function)\n   if (function.has_generics ())\n     {\n       for (auto &generic : function.get_generic_params ())\n-\tResolveGenericParam::go (generic.get (), function.get_node_id ());\n+\tResolveGenericParam::go (generic.get ());\n     }\n \n   if (function.has_return_type ())\n-    ResolveType::go (function.get_return_type ().get (),\n-\t\t     function.get_node_id ());\n+    ResolveType::go (function.get_return_type ().get ());\n \n   // we make a new scope so the names of parameters are resolved and shadowed\n   // correctly\n   for (auto &param : function.get_function_params ())\n     {\n-      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n     }\n \n   // done\n@@ -1124,7 +1118,7 @@ ResolveExternItem::visit (AST::ExternalStaticItem &item)\n {\n   resolve_visibility (item.get_visibility ());\n \n-  ResolveType::go (item.get_type ().get (), item.get_node_id ());\n+  ResolveType::go (item.get_type ().get ());\n }\n \n } // namespace Resolver\n@@ -1290,6 +1284,7 @@ rust_simple_path_resolve_test (void)\n {\n   rust_use_dec_flattening ();\n }\n+\n } // namespace selftest\n \n #endif // CHECKING_P"}, {"sha": "2824d09a11e437867620236a25d7a6fe8649d4ad", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -46,10 +46,7 @@ class ResolveTraitItems : public ResolverBase\n \n private:\n   ResolveTraitItems (const CanonicalPath &prefix,\n-\t\t     const CanonicalPath &canonical_prefix)\n-    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n-      canonical_prefix (canonical_prefix)\n-  {}\n+\t\t     const CanonicalPath &canonical_prefix);\n \n   const CanonicalPath &prefix;\n   const CanonicalPath &canonical_prefix;\n@@ -93,10 +90,7 @@ class ResolveItem : public ResolverBase\n   void resolve_extern_item (AST::ExternalItem *item);\n \n   ResolveItem (const CanonicalPath &prefix,\n-\t       const CanonicalPath &canonical_prefix)\n-    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n-      canonical_prefix (canonical_prefix)\n-  {}\n+\t       const CanonicalPath &canonical_prefix);\n \n   const CanonicalPath &prefix;\n   const CanonicalPath &canonical_prefix;\n@@ -116,9 +110,7 @@ class ResolveImplItems : public ResolveItem\n \n private:\n   ResolveImplItems (const CanonicalPath &prefix,\n-\t\t    const CanonicalPath &canonical_prefix)\n-    : ResolveItem (prefix, canonical_prefix)\n-  {}\n+\t\t    const CanonicalPath &canonical_prefix);\n };\n \n class ResolveExternItem : public ResolverBase\n@@ -132,7 +124,7 @@ class ResolveExternItem : public ResolverBase\n   void visit (AST::ExternalStaticItem &item) override;\n \n private:\n-  ResolveExternItem () : ResolverBase (UNKNOWN_NODEID) {}\n+  ResolveExternItem () : ResolverBase () {}\n };\n \n } // namespace Resolver"}, {"sha": "3c69b65f0e0546abd0e255624b2e2b9794c02170", "filename": "gcc/rust/resolve/rust-ast-resolve-path.cc", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -23,24 +23,26 @@\n namespace Rust {\n namespace Resolver {\n \n+ResolvePath::ResolvePath () : ResolverBase () {}\n+\n void\n-ResolvePath::go (AST::PathInExpression *expr, NodeId parent)\n+ResolvePath::go (AST::PathInExpression *expr)\n {\n-  ResolvePath resolver (parent);\n+  ResolvePath resolver;\n   resolver.resolve_path (expr);\n }\n \n void\n-ResolvePath::go (AST::QualifiedPathInExpression *expr, NodeId parent)\n+ResolvePath::go (AST::QualifiedPathInExpression *expr)\n {\n-  ResolvePath resolver (parent);\n+  ResolvePath resolver;\n   resolver.resolve_path (expr);\n }\n \n void\n-ResolvePath::go (AST::SimplePath *expr, NodeId parent)\n+ResolvePath::go (AST::SimplePath *expr)\n {\n-  ResolvePath resolver (parent);\n+  ResolvePath resolver;\n   resolver.resolve_path (expr);\n }\n \n@@ -86,14 +88,7 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n       // resolve any generic args\n       if (segment.has_generic_args ())\n \t{\n-\t  bool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n-\t    segment.get_generic_args ());\n-\t  if (!ok)\n-\t    {\n-\t      rust_error_at (segment.get_locus (),\n-\t\t\t     \"failed to resolve generic arguments\");\n-\t      return;\n-\t    }\n+\t  ResolveType::type_resolve_generic_args (segment.get_generic_args ());\n \t}\n \n       // logic is awkward here there are a few cases\n@@ -221,10 +216,8 @@ void\n ResolvePath::resolve_path (AST::QualifiedPathInExpression *expr)\n {\n   AST::QualifiedPathType &root_segment = expr->get_qualified_path_type ();\n-  ResolveType::go (&root_segment.get_as_type_path (),\n-\t\t   root_segment.get_node_id ());\n-  ResolveType::go (root_segment.get_type ().get (),\n-\t\t   root_segment.get_node_id ());\n+  ResolveType::go (&root_segment.get_as_type_path ());\n+  ResolveType::go (root_segment.get_type ().get ());\n \n   for (auto &segment : expr->get_segments ())\n     {\n@@ -233,14 +226,7 @@ ResolvePath::resolve_path (AST::QualifiedPathInExpression *expr)\n       // generic arguments used\n       if (segment.has_generic_args ())\n \t{\n-\t  bool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n-\t    segment.get_generic_args ());\n-\t  if (!ok)\n-\t    {\n-\t      rust_error_at (segment.get_locus (),\n-\t\t\t     \"failed to resolve generic arguments\");\n-\t      return;\n-\t    }\n+\t  ResolveType::type_resolve_generic_args (segment.get_generic_args ());\n \t}\n     }\n }"}, {"sha": "a9af0c5819c025b0d93f5b5b2cf822b69a48a1cb", "filename": "gcc/rust/resolve/rust-ast-resolve-path.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -29,12 +29,12 @@ class ResolvePath : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::PathInExpression *expr, NodeId parent);\n-  static void go (AST::QualifiedPathInExpression *expr, NodeId parent);\n-  static void go (AST::SimplePath *expr, NodeId parent);\n+  static void go (AST::PathInExpression *expr);\n+  static void go (AST::QualifiedPathInExpression *expr);\n+  static void go (AST::SimplePath *expr);\n \n private:\n-  ResolvePath (NodeId parent) : ResolverBase (parent) {}\n+  ResolvePath ();\n \n   void resolve_path (AST::PathInExpression *expr);\n   void resolve_path (AST::QualifiedPathInExpression *expr);"}, {"sha": "9386d36d25eb69f078a5f8219c997ef1d278f471", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -26,13 +26,13 @@ namespace Resolver {\n void\n PatternDeclaration::visit (AST::PathInExpression &pattern)\n {\n-  ResolvePath::go (&pattern, parent);\n+  ResolvePath::go (&pattern);\n }\n \n void\n PatternDeclaration::visit (AST::TupleStructPattern &pattern)\n {\n-  ResolvePath::go (&pattern.get_path (), parent);\n+  ResolvePath::go (&pattern.get_path ());\n \n   std::unique_ptr<AST::TupleStructItems> &items = pattern.get_items ();\n   switch (items->get_item_type ())\n@@ -49,8 +49,7 @@ PatternDeclaration::visit (AST::TupleStructPattern &pattern)\n \n \tfor (auto &inner_pattern : items_no_range.get_patterns ())\n \t  {\n-\t    PatternDeclaration::go (inner_pattern.get (),\n-\t\t\t\t    inner_pattern->get_pattern_node_id ());\n+\t    PatternDeclaration::go (inner_pattern.get ());\n \t  }\n       }\n       break;\n@@ -60,7 +59,7 @@ PatternDeclaration::visit (AST::TupleStructPattern &pattern)\n void\n PatternDeclaration::visit (AST::StructPattern &pattern)\n {\n-  ResolvePath::go (&pattern.get_path (), parent);\n+  ResolvePath::go (&pattern.get_path ());\n \n   auto &struct_pattern_elems = pattern.get_struct_pattern_elems ();\n   for (auto &field : struct_pattern_elems.get_struct_pattern_fields ())\n@@ -87,9 +86,6 @@ PatternDeclaration::visit (AST::StructPattern &pattern)\n \t      CanonicalPath::new_seg (ident.get_node_id (),\n \t\t\t\t      ident.get_identifier ()),\n \t      ident.get_node_id (), ident.get_locus ());\n-\n-\t    resolver->mark_decl_mutability (ident.get_node_id (),\n-\t\t\t\t\t    ident.is_mut ());\n \t  }\n \t  break;\n \t}\n@@ -130,7 +126,7 @@ PatternDeclaration::visit (AST::TuplePattern &pattern)\n }\n \n static void\n-resolve_range_pattern_bound (AST::RangePatternBound *bound, NodeId parent)\n+resolve_range_pattern_bound (AST::RangePatternBound *bound)\n {\n   switch (bound->get_bound_type ())\n     {\n@@ -142,15 +138,15 @@ resolve_range_pattern_bound (AST::RangePatternBound *bound, NodeId parent)\n \tAST::RangePatternBoundPath &ref\n \t  = *static_cast<AST::RangePatternBoundPath *> (bound);\n \n-\tResolvePath::go (&ref.get_path (), parent);\n+\tResolvePath::go (&ref.get_path ());\n       }\n       break;\n \n       case AST::RangePatternBound::RangePatternBoundType::QUALPATH: {\n \tAST::RangePatternBoundQualPath &ref\n \t  = *static_cast<AST::RangePatternBoundQualPath *> (bound);\n \n-\tResolvePath::go (&ref.get_qualified_path (), parent);\n+\tResolvePath::go (&ref.get_qualified_path ());\n       }\n       break;\n     }\n@@ -159,8 +155,8 @@ resolve_range_pattern_bound (AST::RangePatternBound *bound, NodeId parent)\n void\n PatternDeclaration::visit (AST::RangePattern &pattern)\n {\n-  resolve_range_pattern_bound (pattern.get_upper_bound ().get (), parent);\n-  resolve_range_pattern_bound (pattern.get_lower_bound ().get (), parent);\n+  resolve_range_pattern_bound (pattern.get_upper_bound ().get ());\n+  resolve_range_pattern_bound (pattern.get_lower_bound ().get ());\n }\n \n } // namespace Resolver"}, {"sha": "fcbb23fdf088ff5eb1be18bd16fb7c175be4ac0a", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -30,16 +30,11 @@ class ResolvePattern : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Pattern *pattern, NodeId parent)\n+  static void go (AST::Pattern *pattern)\n   {\n-    ResolvePattern resolver (parent);\n+    ResolvePattern resolver;\n     pattern->accept_vis (resolver);\n-    if (resolver.resolved_node == UNKNOWN_NODEID)\n-      {\n-\trust_error_at (resolver.locus, \"failed to resolve pattern %s\",\n-\t\t       pattern->as_string ().c_str ());\n-      }\n-  };\n+  }\n \n   void visit (AST::IdentifierPattern &pattern) override\n   {\n@@ -52,17 +47,17 @@ class ResolvePattern : public ResolverBase\n   }\n \n private:\n-  ResolvePattern (NodeId parent) : ResolverBase (parent) {}\n+  ResolvePattern () : ResolverBase () {}\n };\n \n class PatternDeclaration : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Pattern *pattern, NodeId parent)\n+  static void go (AST::Pattern *pattern)\n   {\n-    PatternDeclaration resolver (parent);\n+    PatternDeclaration resolver;\n     pattern->accept_vis (resolver);\n   };\n \n@@ -73,18 +68,13 @@ class PatternDeclaration : public ResolverBase\n     resolver->get_name_scope ().insert (\n       CanonicalPath::new_seg (pattern.get_node_id (), pattern.get_ident ()),\n       pattern.get_node_id (), pattern.get_locus ());\n-\n-    resolver->mark_decl_mutability (pattern.get_node_id (),\n-\t\t\t\t    pattern.get_is_mut ());\n   }\n \n   void visit (AST::WildcardPattern &pattern) override\n   {\n     resolver->get_name_scope ().insert (\n       CanonicalPath::new_seg (pattern.get_node_id (), \"_\"),\n       pattern.get_node_id (), pattern.get_locus ());\n-\n-    resolver->mark_decl_mutability (pattern.get_node_id (), false);\n   }\n \n   // cases in a match expression\n@@ -99,7 +89,7 @@ class PatternDeclaration : public ResolverBase\n   void visit (AST::RangePattern &pattern) override;\n \n private:\n-  PatternDeclaration (NodeId parent) : ResolverBase (parent) {}\n+  PatternDeclaration () : ResolverBase () {}\n };\n \n } // namespace Resolver"}, {"sha": "202a280bb7518e861491e517d79ef311343b10c7", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 33, "deletions": 57, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -33,32 +33,31 @@ class ResolveStmt : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Stmt *stmt, NodeId parent, const CanonicalPath &prefix,\n+  static void go (AST::Stmt *stmt, const CanonicalPath &prefix,\n \t\t  const CanonicalPath &canonical_prefix,\n \t\t  const CanonicalPath &enum_prefix)\n   {\n     if (stmt->is_marked_for_strip ())\n       return;\n \n-    ResolveStmt resolver (parent, prefix, canonical_prefix, enum_prefix);\n+    ResolveStmt resolver (prefix, canonical_prefix, enum_prefix);\n     stmt->accept_vis (resolver);\n-  };\n+  }\n \n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {\n-    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id (), prefix,\n-\t\t     canonical_prefix);\n+    ResolveExpr::go (stmt.get_expr ().get (), prefix, canonical_prefix);\n   }\n \n   void visit (AST::ExprStmtWithoutBlock &stmt) override\n   {\n-    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id (), prefix,\n-\t\t     canonical_prefix);\n+    ResolveExpr::go (stmt.get_expr ().get (), prefix, canonical_prefix);\n   }\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto decl = CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t\tconstant.get_identifier ());\n     auto path = decl; // this ensures we have the correct relative resolution\n     auto cpath = canonical_prefix.append (decl);\n     mappings->insert_canonical_path (mappings->get_current_crate (),\n@@ -72,32 +71,21 @@ class ResolveStmt : public ResolverBase\n \trust_error_at (r, \"redefined multiple times\");\n       });\n \n-    ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n-    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (),\n-\t\t     prefix, canonical_prefix);\n-\n-    // the mutability checker needs to verify for immutable decls the number\n-    // of assignments are <1. This marks an implicit assignment\n-    resolver->mark_decl_mutability (constant.get_node_id (), false);\n-    resolver->mark_assignment_to_decl (constant.get_node_id (),\n-\t\t\t\t       constant.get_node_id ());\n+    ResolveType::go (constant.get_type ().get ());\n+    ResolveExpr::go (constant.get_expr ().get (), prefix, canonical_prefix);\n   }\n \n   void visit (AST::LetStmt &stmt) override\n   {\n     if (stmt.has_init_expr ())\n       {\n-\tResolveExpr::go (stmt.get_init_expr ().get (), stmt.get_node_id (),\n-\t\t\t prefix, canonical_prefix);\n-\n-\t// mark the assignment\n-\tresolver->mark_assignment_to_decl (\n-\t  stmt.get_pattern ()->get_pattern_node_id (), stmt.get_node_id ());\n+\tResolveExpr::go (stmt.get_init_expr ().get (), prefix,\n+\t\t\t canonical_prefix);\n       }\n \n-    PatternDeclaration::go (stmt.get_pattern ().get (), stmt.get_node_id ());\n+    PatternDeclaration::go (stmt.get_pattern ().get ());\n     if (stmt.has_type ())\n-      ResolveType::go (stmt.get_type ().get (), stmt.get_node_id ());\n+      ResolveType::go (stmt.get_type ().get ());\n   }\n \n   void visit (AST::TupleStruct &struct_decl) override\n@@ -124,14 +112,12 @@ class ResolveStmt : public ResolverBase\n       {\n \tfor (auto &generic : struct_decl.get_generic_params ())\n \t  {\n-\t    ResolveGenericParam::go (generic.get (),\n-\t\t\t\t     struct_decl.get_node_id ());\n+\t    ResolveGenericParam::go (generic.get ());\n \t  }\n       }\n \n     for (AST::TupleField &field : struct_decl.get_fields ())\n-      ResolveType::go (field.get_field_type ().get (),\n-\t\t       struct_decl.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get ());\n \n     resolver->get_type_scope ().pop ();\n   }\n@@ -160,12 +146,12 @@ class ResolveStmt : public ResolverBase\n       {\n \tfor (auto &generic : enum_decl.get_generic_params ())\n \t  {\n-\t    ResolveGenericParam::go (generic.get (), enum_decl.get_node_id ());\n+\t    ResolveGenericParam::go (generic.get ());\n \t  }\n       }\n \n     for (auto &variant : enum_decl.get_variants ())\n-      ResolveStmt::go (variant.get (), parent, path, canonical_prefix, path);\n+      ResolveStmt::go (variant.get (), path, canonical_prefix, path);\n \n     resolver->get_type_scope ().pop ();\n   }\n@@ -212,7 +198,7 @@ class ResolveStmt : public ResolverBase\n \tif (field.get_field_type ()->is_marked_for_strip ())\n \t  continue;\n \n-\tResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+\tResolveType::go (field.get_field_type ().get ());\n       }\n   }\n \n@@ -238,7 +224,7 @@ class ResolveStmt : public ResolverBase\n \tif (field.get_field_type ()->is_marked_for_strip ())\n \t  continue;\n \n-\tResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+\tResolveType::go (field.get_field_type ().get ());\n       }\n   }\n \n@@ -286,8 +272,7 @@ class ResolveStmt : public ResolverBase\n       {\n \tfor (auto &generic : struct_decl.get_generic_params ())\n \t  {\n-\t    ResolveGenericParam::go (generic.get (),\n-\t\t\t\t     struct_decl.get_node_id ());\n+\t    ResolveGenericParam::go (generic.get ());\n \t  }\n       }\n \n@@ -296,8 +281,7 @@ class ResolveStmt : public ResolverBase\n \tif (field.get_field_type ()->is_marked_for_strip ())\n \t  continue;\n \n-\tResolveType::go (field.get_field_type ().get (),\n-\t\t\t struct_decl.get_node_id ());\n+\tResolveType::go (field.get_field_type ().get ());\n       }\n \n     resolver->get_type_scope ().pop ();\n@@ -327,7 +311,7 @@ class ResolveStmt : public ResolverBase\n       {\n \tfor (auto &generic : union_decl.get_generic_params ())\n \t  {\n-\t    ResolveGenericParam::go (generic.get (), union_decl.get_node_id ());\n+\t    ResolveGenericParam::go (generic.get ());\n \t  }\n       }\n \n@@ -336,16 +320,16 @@ class ResolveStmt : public ResolverBase\n \tif (field.get_field_type ()->is_marked_for_strip ())\n \t  continue;\n \n-\tResolveType::go (field.get_field_type ().get (),\n-\t\t\t union_decl.get_node_id ());\n+\tResolveType::go (field.get_field_type ().get ());\n       }\n \n     resolver->get_type_scope ().pop ();\n   }\n \n   void visit (AST::Function &function) override\n   {\n-    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto decl = CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t\tfunction.get_function_name ());\n     auto path = decl; // this ensures we have the correct relative resolution\n     auto cpath = canonical_prefix.append (decl);\n     mappings->insert_canonical_path (mappings->get_current_crate (),\n@@ -370,30 +354,22 @@ class ResolveStmt : public ResolverBase\n     if (function.has_generics ())\n       {\n \tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), function.get_node_id ());\n+\t  ResolveGenericParam::go (generic.get ());\n       }\n \n     if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (),\n-\t\t       function.get_node_id ());\n+      ResolveType::go (function.get_return_type ().get ());\n \n     // we make a new scope so the names of parameters are resolved and shadowed\n     // correctly\n     for (auto &param : function.get_function_params ())\n       {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n-\n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (\n-\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n+\tResolveType::go (param.get_type ().get ());\n+\tPatternDeclaration::go (param.get_pattern ().get ());\n       }\n \n     // resolve the function body\n-    ResolveExpr::go (function.get_definition ().get (), function.get_node_id (),\n-\t\t     path, cpath);\n+    ResolveExpr::go (function.get_definition ().get (), path, cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n@@ -403,11 +379,11 @@ class ResolveStmt : public ResolverBase\n   void visit (AST::ExternBlock &extern_block) override;\n \n private:\n-  ResolveStmt (NodeId parent, const CanonicalPath &prefix,\n+  ResolveStmt (const CanonicalPath &prefix,\n \t       const CanonicalPath &canonical_prefix,\n \t       const CanonicalPath &enum_prefix)\n-    : ResolverBase (parent), prefix (prefix),\n-      canonical_prefix (canonical_prefix), enum_prefix (enum_prefix)\n+    : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix),\n+      enum_prefix (enum_prefix)\n   {}\n \n   const CanonicalPath &prefix;"}, {"sha": "4d8b6c788f323e09efb1ea99f7a3f87236b32f25", "filename": "gcc/rust/resolve/rust-ast-resolve-struct-expr-field.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.cc?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-struct-expr-field.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+ResolveStructExprField::go (AST::StructExprField *field,\n+\t\t\t    const CanonicalPath &prefix,\n+\t\t\t    const CanonicalPath &canonical_prefix)\n+{\n+  ResolveStructExprField resolver (prefix, canonical_prefix);\n+  field->accept_vis (resolver);\n+}\n+\n+ResolveStructExprField::ResolveStructExprField (\n+  const CanonicalPath &prefix, const CanonicalPath &canonical_prefix)\n+  : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+{}\n+\n+void\n+ResolveStructExprField::visit (AST::StructExprFieldIdentifierValue &field)\n+{\n+  ResolveExpr::go (field.get_value ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveStructExprField::visit (AST::StructExprFieldIndexValue &field)\n+{\n+  ResolveExpr::go (field.get_value ().get (), prefix, canonical_prefix);\n+}\n+\n+void\n+ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n+{\n+  AST::IdentifierExpr expr (field.get_field_name (), {}, field.get_locus ());\n+  expr.set_node_id (field.get_node_id ());\n+\n+  ResolveExpr::go (&expr, prefix, canonical_prefix);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "ce60b136e4be1c4c5482b85a3dc6af04a200de7f", "filename": "gcc/rust/resolve/rust-ast-resolve-struct-expr-field.h", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -32,15 +32,8 @@ class ResolveStructExprField : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::StructExprField *field, NodeId parent,\n-\t\t  const CanonicalPath &prefix,\n-\t\t  const CanonicalPath &canonical_prefix)\n-  {\n-    ResolveStructExprField resolver (parent, prefix, canonical_prefix);\n-    field->accept_vis (resolver);\n-  }\n-\n-  virtual ~ResolveStructExprField () override {}\n+  static void go (AST::StructExprField *field, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix);\n \n   void visit (AST::StructExprFieldIdentifierValue &field) override;\n \n@@ -49,11 +42,8 @@ class ResolveStructExprField : public ResolverBase\n   void visit (AST::StructExprFieldIdentifier &field) override;\n \n private:\n-  ResolveStructExprField (NodeId parent, const CanonicalPath &prefix,\n-\t\t\t  const CanonicalPath &canonical_prefix)\n-    : ResolverBase (parent), prefix (prefix),\n-      canonical_prefix (canonical_prefix)\n-  {}\n+  ResolveStructExprField (const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix);\n \n   const CanonicalPath &prefix;\n   const CanonicalPath &canonical_prefix;"}, {"sha": "7aacc0a55906c12d56407b381dc03229d62e908a", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -45,7 +45,7 @@ class ResolveTopLevel : public ResolverBase\n     NodeId current_module = resolver.resolver->peek_current_module_scope ();\n     resolver.mappings->insert_child_item_to_parent_module_mapping (\n       item->get_node_id (), current_module);\n-  };\n+  }\n \n   void visit (AST::Module &module) override\n   {\n@@ -275,8 +275,6 @@ class ResolveTopLevel : public ResolverBase\n \trust_error_at (r, \"redefined multiple times\");\n       });\n \n-    resolver->mark_decl_mutability (var.get_node_id (), var.is_mutable ());\n-\n     NodeId current_module = resolver->peek_current_module_scope ();\n     mappings->insert_module_child_item (current_module, decl);\n     mappings->insert_canonical_path (mappings->get_current_crate (),\n@@ -285,7 +283,8 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto decl = CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t\tconstant.get_identifier ());\n     auto path = prefix.append (decl);\n     auto cpath = canonical_prefix.append (decl);\n \n@@ -305,7 +304,8 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::Function &function) override\n   {\n-    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto decl = CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t\tfunction.get_function_name ());\n     auto path = prefix.append (decl);\n     auto cpath = canonical_prefix.append (decl);\n \n@@ -325,38 +325,32 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::InherentImpl &impl_block) override\n   {\n-    bool canonicalize_type_args = !impl_block.has_generics ();\n-    bool type_resolve_generic_args = false;\n-\n+    std::string raw_impl_type_path = impl_block.get_type ()->as_string ();\n     CanonicalPath impl_type\n-      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n-\t\t\t\t\t     canonicalize_type_args,\n-\t\t\t\t\t     type_resolve_generic_args);\n+      = CanonicalPath::new_seg (impl_block.get_type ()->get_node_id (),\n+\t\t\t\traw_impl_type_path);\n     CanonicalPath impl_prefix = prefix.append (impl_type);\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n-\n-    // we cannot resolve canonical paths here until later on\n   }\n \n   void visit (AST::TraitImpl &impl_block) override\n   {\n-    bool canonicalize_type_args = !impl_block.has_generics ();\n-    bool type_resolve_generic_args = false;\n-\n+    std::string raw_impl_type_path = impl_block.get_type ()->as_string ();\n     CanonicalPath impl_type_seg\n-      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n-\t\t\t\t\t     canonicalize_type_args,\n-\t\t\t\t\t     type_resolve_generic_args);\n+      = CanonicalPath::new_seg (impl_block.get_type ()->get_node_id (),\n+\t\t\t\traw_impl_type_path);\n+\n+    std::string raw_trait_type_path = impl_block.get_trait_path ().as_string ();\n     CanonicalPath trait_type_seg\n-      = ResolveTypeToCanonicalPath::resolve (impl_block.get_trait_path (),\n-\t\t\t\t\t     canonicalize_type_args,\n-\t\t\t\t\t     type_resolve_generic_args);\n+      = CanonicalPath::new_seg (impl_block.get_trait_path ().get_node_id (),\n+\t\t\t\traw_trait_type_path);\n \n     CanonicalPath projection\n-      = TraitImplProjection::resolve (impl_block.get_node_id (), trait_type_seg,\n-\t\t\t\t      impl_type_seg);\n+      = CanonicalPath::trait_impl_projection_seg (impl_block.get_node_id (),\n+\t\t\t\t\t\t  trait_type_seg,\n+\t\t\t\t\t\t  impl_type_seg);\n     CanonicalPath impl_prefix = prefix.append (projection);\n \n     resolver->get_name_scope ().insert (\n@@ -369,8 +363,6 @@ class ResolveTopLevel : public ResolverBase\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n-\n-    // we cannot resolve canonical paths here until later on\n   }\n \n   void visit (AST::Trait &trait) override\n@@ -408,8 +400,7 @@ class ResolveTopLevel : public ResolverBase\n private:\n   ResolveTopLevel (const CanonicalPath &prefix,\n \t\t   const CanonicalPath &canonical_prefix)\n-    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n-      canonical_prefix (canonical_prefix)\n+    : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n   {}\n \n   const CanonicalPath &prefix;"}, {"sha": "5d0ceb536d5cdc351709a4abaad44aaf34844253", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 154, "deletions": 208, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -24,116 +24,18 @@ namespace Resolver {\n \n // rust-ast-resolve-type.h\n \n-std::string\n-ResolveTypeToCanonicalPath::canonicalize_generic_args (AST::GenericArgs &args)\n-{\n-  std::string buf;\n-\n-  size_t i = 0;\n-  size_t total = args.get_type_args ().size ();\n-\n-  for (auto &ty_arg : args.get_type_args ())\n-    {\n-      buf += ty_arg->as_string ();\n-      if ((i + 1) < total)\n-\tbuf += \",\";\n-\n-      i++;\n-    }\n-\n-  return \"<\" + buf + \">\";\n-}\n-\n-bool\n-ResolveTypeToCanonicalPath::type_resolve_generic_args (AST::GenericArgs &args)\n-{\n-  for (auto &gt : args.get_type_args ())\n-    {\n-      ResolveType::go (gt.get (), UNKNOWN_NODEID);\n-      // FIXME error handling here for inference variable since they do not have\n-      // a node to resolve to\n-      // if (resolved == UNKNOWN_NODEID) return false;\n-    }\n-  return true;\n-}\n-\n-void\n-ResolveTypeToCanonicalPath::visit (AST::TypePathSegmentGeneric &seg)\n-{\n-  if (seg.is_error ())\n-    {\n-      failure_flag = true;\n-      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n-\t\t     seg.as_string ().c_str ());\n-      return;\n-    }\n-\n-  if (!seg.has_generic_args ())\n-    {\n-      auto ident_segment\n-\t= CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t  seg.get_ident_segment ().as_string ());\n-      result = result.append (ident_segment);\n-      return;\n-    }\n-\n-  if (type_resolve_generic_args_flag)\n-    {\n-      bool ok = type_resolve_generic_args (seg.get_generic_args ());\n-      failure_flag = !ok;\n-    }\n-\n-  if (include_generic_args_flag)\n-    {\n-      std::string generics\n-\t= canonicalize_generic_args (seg.get_generic_args ());\n-      auto generic_segment\n-\t= CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t  seg.get_ident_segment ().as_string ()\n-\t\t\t\t    + \"::\" + generics);\n-      result = result.append (generic_segment);\n-      return;\n-    }\n-\n-  auto ident_segment\n-    = CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t      seg.get_ident_segment ().as_string ());\n-  result = result.append (ident_segment);\n-}\n-\n-void\n-ResolveTypeToCanonicalPath::visit (AST::TypePathSegment &seg)\n-{\n-  if (seg.is_error ())\n-    {\n-      failure_flag = true;\n-      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n-\t\t     seg.as_string ().c_str ());\n-      return;\n-    }\n-\n-  CanonicalPath ident_seg\n-    = CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t      seg.get_ident_segment ().as_string ());\n-  result = result.append (ident_seg);\n-}\n-\n void\n ResolveType::visit (AST::ArrayType &type)\n {\n   type.get_elem_type ()->accept_vis (*this);\n-  // FIXME\n-  // the capacity expr can contain block-expr with functions but these should be\n-  // folded via constexpr code\n-  ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id (),\n-\t\t   CanonicalPath::create_empty (),\n+  ResolveExpr::go (type.get_size_expr ().get (), CanonicalPath::create_empty (),\n \t\t   CanonicalPath::create_empty ());\n }\n \n void\n ResolveType::visit (AST::TraitObjectTypeOneBound &type)\n {\n-  ResolveTypeBound::go (&type.get_trait_bound (), type.get_node_id ());\n+  ResolveTypeBound::go (&type.get_trait_bound ());\n }\n \n void\n@@ -142,137 +44,47 @@ ResolveType::visit (AST::TraitObjectType &type)\n   for (auto &bound : type.get_type_param_bounds ())\n     {\n       /* NodeId bound_resolved_id = */\n-      ResolveTypeBound::go (bound.get (), type.get_node_id ());\n-    }\n-}\n-\n-void\n-ResolveTypeToCanonicalPath::visit (AST::ReferenceType &ref)\n-{\n-  auto inner_type\n-    = ResolveTypeToCanonicalPath::resolve (*ref.get_type_referenced ().get (),\n-\t\t\t\t\t   include_generic_args_flag,\n-\t\t\t\t\t   type_resolve_generic_args_flag);\n-\n-  std::string segment_string (\"&\");\n-  if (ref.get_has_mut ())\n-    segment_string += \"mut \";\n-\n-  segment_string += inner_type.get ();\n-\n-  auto ident_seg = CanonicalPath::new_seg (ref.get_node_id (), segment_string);\n-  result = result.append (ident_seg);\n-}\n-\n-void\n-ResolveTypeToCanonicalPath::visit (AST::RawPointerType &ref)\n-{\n-  auto inner_type\n-    = ResolveTypeToCanonicalPath::resolve (*ref.get_type_pointed_to ().get (),\n-\t\t\t\t\t   include_generic_args_flag,\n-\t\t\t\t\t   type_resolve_generic_args_flag);\n-\n-  std::string segment_string (\"*\");\n-  switch (ref.get_pointer_type ())\n-    {\n-    case AST::RawPointerType::PointerType::MUT:\n-      segment_string += \"mut \";\n-      break;\n-\n-    case AST::RawPointerType::PointerType::CONST:\n-      segment_string += \"const \";\n-      break;\n+      ResolveTypeBound::go (bound.get ());\n     }\n-\n-  segment_string += inner_type.get ();\n-\n-  auto ident_seg = CanonicalPath::new_seg (ref.get_node_id (), segment_string);\n-  result = result.append (ident_seg);\n-}\n-\n-void\n-ResolveTypeToCanonicalPath::visit (AST::SliceType &slice)\n-{\n-  auto inner_type\n-    = ResolveTypeToCanonicalPath::resolve (*slice.get_elem_type ().get (),\n-\t\t\t\t\t   include_generic_args_flag,\n-\t\t\t\t\t   type_resolve_generic_args_flag);\n-  std::string segment_string = \"[\" + inner_type.get () + \"]\";\n-  auto ident_seg\n-    = CanonicalPath::new_seg (slice.get_node_id (), segment_string);\n-  result = result.append (ident_seg);\n }\n \n void\n ResolveType::visit (AST::ReferenceType &type)\n {\n-  CanonicalPath path = CanonicalPath::create_empty ();\n-  resolved_node\n-    = ResolveType::go (type.get_type_referenced ().get (), type.get_node_id (),\n-\t\t       canonicalize_type_with_generics, &path);\n-  if (canonical_path != nullptr)\n-    {\n-      std::string ref_type_str = type.is_mut () ? \"mut\" : \"\";\n-      std::string ref_path = \"&\" + ref_type_str + \" \" + path.get ();\n-      *canonical_path = canonical_path->append (\n-\tCanonicalPath::new_seg (type.get_node_id (), ref_path));\n-    }\n+  resolved_node = ResolveType::go (type.get_type_referenced ().get ());\n }\n \n void\n ResolveType::visit (AST::RawPointerType &type)\n {\n-  CanonicalPath path = CanonicalPath::create_empty ();\n-  resolved_node\n-    = ResolveType::go (type.get_type_pointed_to ().get (), type.get_node_id (),\n-\t\t       canonicalize_type_with_generics, &path);\n-  if (canonical_path != nullptr)\n-    {\n-      std::string ptr_type_str\n-\t= type.get_pointer_type () == AST::RawPointerType::CONST ? \"const\"\n-\t\t\t\t\t\t\t\t : \"mut\";\n-      std::string ptr_path = \"*\" + ptr_type_str + \" \" + path.get ();\n-      *canonical_path = canonical_path->append (\n-\tCanonicalPath::new_seg (type.get_node_id (), ptr_path));\n-    }\n+  resolved_node = ResolveType::go (type.get_type_pointed_to ().get ());\n }\n \n void\n ResolveType::visit (AST::InferredType &type)\n-{}\n+{\n+  // FIXME\n+}\n \n void\n ResolveType::visit (AST::NeverType &type)\n-{}\n+{\n+  // FIXME\n+}\n \n void\n ResolveType::visit (AST::SliceType &type)\n {\n-  CanonicalPath path = CanonicalPath::create_empty ();\n-  resolved_node\n-    = ResolveType::go (type.get_elem_type ().get (), type.get_node_id (),\n-\t\t       canonicalize_type_with_generics, &path);\n-  if (canonical_path != nullptr)\n-    {\n-      std::string slice_path = \"[\" + path.get () + \"]\";\n-      *canonical_path = canonical_path->append (\n-\tCanonicalPath::new_seg (type.get_node_id (), slice_path));\n-    }\n+  resolved_node = ResolveType::go (type.get_elem_type ().get ());\n }\n \n-ResolveRelativeTypePath::ResolveRelativeTypePath (CanonicalPath qualified_path)\n-  : ResolveTypeToCanonicalPath (true, true)\n-{\n-  result = qualified_path;\n-}\n+// resolve relative type-paths\n \n bool\n ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n {\n-  CanonicalPath result = CanonicalPath::create_empty ();\n-  ResolveRelativeTypePath o (result);\n-  auto &resolver = o.resolver;\n-  auto &mappings = o.mappings;\n+  auto resolver = Resolver::get ();\n+  auto mappings = Analysis::Mappings::get ();\n \n   NodeId module_scope_id = resolver->peek_current_module_scope ();\n   NodeId previous_resolved_node_id = module_scope_id;\n@@ -319,7 +131,7 @@ ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n \t      {\n \t\tfor (auto &gt : s->get_generic_args ().get_type_args ())\n \t\t  {\n-\t\t    ResolveType::go (gt.get (), UNKNOWN_NODEID);\n+\t\t    ResolveType::go (gt.get ());\n \t\t  }\n \t      }\n \t  }\n@@ -429,15 +241,20 @@ ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n   return true;\n }\n \n+// qualified type paths\n+\n+ResolveRelativeQualTypePath::ResolveRelativeQualTypePath ()\n+  : failure_flag (false)\n+{}\n+\n bool\n-ResolveRelativeTypePath::go (AST::QualifiedPathInType &path)\n+ResolveRelativeQualTypePath::go (AST::QualifiedPathInType &path)\n {\n-  CanonicalPath result = CanonicalPath::create_empty ();\n-  ResolveRelativeTypePath o (result);\n+  ResolveRelativeQualTypePath o;\n \n   // resolve the type and trait path\n   auto &qualified_path = path.get_qualified_path_type ();\n-  if (!o.resolve_qual_seg (qualified_path, result))\n+  if (!o.resolve_qual_seg (qualified_path))\n     return false;\n \n   // qualified types are similar to other paths in that we cannot guarantee\n@@ -460,5 +277,134 @@ ResolveRelativeTypePath::go (AST::QualifiedPathInType &path)\n \n   return true;\n }\n+\n+bool\n+ResolveRelativeQualTypePath::resolve_qual_seg (AST::QualifiedPathType &seg)\n+{\n+  if (seg.is_error ())\n+    {\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return false;\n+    }\n+\n+  auto type = seg.get_type ().get ();\n+  NodeId type_resolved_node = ResolveType::go (type);\n+  if (type_resolved_node == UNKNOWN_NODEID)\n+    return false;\n+\n+  if (!seg.has_as_clause ())\n+    return true;\n+\n+  NodeId trait_resolved_node = ResolveType::go (&seg.get_as_type_path ());\n+  if (trait_resolved_node == UNKNOWN_NODEID)\n+    return false;\n+\n+  return true;\n+}\n+\n+void\n+ResolveRelativeQualTypePath::visit (AST::TypePathSegmentGeneric &seg)\n+{\n+  if (seg.is_error ())\n+    {\n+      failure_flag = true;\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return;\n+    }\n+\n+  ResolveType::type_resolve_generic_args (seg.get_generic_args ());\n+}\n+\n+void\n+ResolveRelativeQualTypePath::visit (AST::TypePathSegment &seg)\n+{\n+  if (seg.is_error ())\n+    {\n+      failure_flag = true;\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return;\n+    }\n+}\n+\n+// resolve to canonical path\n+\n+bool\n+ResolveTypeToCanonicalPath::go (AST::Type *type, CanonicalPath &result)\n+{\n+  ResolveTypeToCanonicalPath resolver;\n+  type->accept_vis (resolver);\n+  result = resolver.result;\n+  return !resolver.result.is_empty ();\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::TypePath &path)\n+{\n+  NodeId resolved_node = UNKNOWN_NODEID;\n+  if (!resolver->lookup_resolved_name (path.get_node_id (), &resolved_node))\n+    {\n+      resolver->lookup_resolved_type (path.get_node_id (), &resolved_node);\n+    }\n+\n+  if (resolved_node == UNKNOWN_NODEID)\n+    return;\n+\n+  const CanonicalPath *type_path = nullptr;\n+  if (mappings->lookup_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t       resolved_node, &type_path))\n+    {\n+      result = *type_path;\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::ReferenceType &type)\n+{\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  bool ok\n+    = ResolveTypeToCanonicalPath::go (type.get_type_referenced ().get (), path);\n+  if (ok)\n+    {\n+      std::string ref_type_str = type.is_mut () ? \"mut\" : \"\";\n+      std::string ref_path = \"&\" + ref_type_str + \" \" + path.get ();\n+      result = CanonicalPath::new_seg (type.get_node_id (), ref_path);\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::RawPointerType &type)\n+{\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  bool ok\n+    = ResolveTypeToCanonicalPath::go (type.get_type_pointed_to ().get (), path);\n+  if (ok)\n+    {\n+      std::string ptr_type_str\n+\t= type.get_pointer_type () == AST::RawPointerType::CONST ? \"const\"\n+\t\t\t\t\t\t\t\t : \"mut\";\n+      std::string ptr_path = \"*\" + ptr_type_str + \" \" + path.get ();\n+      result = CanonicalPath::new_seg (type.get_node_id (), ptr_path);\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::SliceType &type)\n+{\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  bool ok = ResolveTypeToCanonicalPath::go (type.get_elem_type ().get (), path);\n+  if (ok)\n+    {\n+      std::string slice_path = \"[\" + path.get () + \"]\";\n+      result = CanonicalPath::new_seg (type.get_node_id (), slice_path);\n+    }\n+}\n+\n+ResolveTypeToCanonicalPath::ResolveTypeToCanonicalPath ()\n+  : ResolverBase (), result (CanonicalPath::create_empty ())\n+{}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "965df42e6bf54ab1c4e973818081ae57faa95640", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 57, "deletions": 234, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -25,202 +25,57 @@\n namespace Rust {\n namespace Resolver {\n \n-class ResolveConstantItemToCanonicalPath\n+class ResolveRelativeTypePath\n {\n public:\n-  static CanonicalPath resolve (AST::ConstantItem &constant)\n-  {\n-    return CanonicalPath::new_seg (constant.get_node_id (),\n-\t\t\t\t   constant.get_identifier ());\n-  }\n-};\n-\n-class ResolveFunctionItemToCanonicalPath\n-{\n-public:\n-  static CanonicalPath resolve (AST::Function &function)\n-  {\n-    return CanonicalPath::new_seg (function.get_node_id (),\n-\t\t\t\t   function.get_function_name ());\n-  }\n-};\n-\n-class ResolveMethodItemToCanonicalPath\n-{\n-public:\n-  static CanonicalPath resolve (AST::Method &method)\n-  {\n-    return CanonicalPath::new_seg (method.get_node_id (),\n-\t\t\t\t   method.get_method_name ());\n-  }\n-};\n-\n-class ResolveTraitItemFunctionToCanonicalPath\n-{\n-public:\n-  static CanonicalPath resolve (AST::TraitItemFunc &function)\n-  {\n-    return CanonicalPath::new_seg (\n-      function.get_node_id (),\n-      function.get_trait_function_decl ().get_identifier ());\n-  }\n-};\n-\n-class ResolveTraitItemMethodToCanonicalPath\n-{\n-public:\n-  static CanonicalPath resolve (AST::TraitItemMethod &method)\n-  {\n-    return CanonicalPath::new_seg (\n-      method.get_node_id (), method.get_trait_method_decl ().get_identifier ());\n-  }\n-};\n-\n-class ResolveTraitItemConstToCanonicalPath\n-{\n-public:\n-  static CanonicalPath resolve (AST::TraitItemConst &constant)\n-  {\n-    return CanonicalPath::new_seg (constant.get_node_id (),\n-\t\t\t\t   constant.get_identifier ());\n-  }\n-};\n-\n-class ResolveTraitItemTypeToCanonicalPath\n-{\n-public:\n-  static CanonicalPath resolve (AST::TraitItemType &type)\n-  {\n-    return CanonicalPath::new_seg (type.get_node_id (), type.get_identifier ());\n-  }\n+  static bool go (AST::TypePath &path, NodeId &resolved_node_id);\n };\n \n-class ResolveTypeToCanonicalPath : public ResolverBase\n+class ResolveRelativeQualTypePath : public ResolverBase\n {\n-protected:\n-  using Rust::Resolver::ResolverBase::visit;\n+  using ResolverBase::visit;\n \n public:\n-  // FIXME this should really only take AST::TypeNoBounds&\n-  static CanonicalPath resolve (AST::Type &type,\n-\t\t\t\tbool include_generic_args = true,\n-\t\t\t\tbool type_resolve_generic_args = true)\n-  {\n-    ResolveTypeToCanonicalPath resolver (include_generic_args,\n-\t\t\t\t\t type_resolve_generic_args);\n-    type.accept_vis (resolver);\n-    return resolver.result;\n-  }\n-\n-  void visit (AST::TypePath &path) override\n-  {\n-    for (auto &seg : path.get_segments ())\n-      {\n-\tseg->accept_vis (*this);\n-\tif (failure_flag)\n-\t  return;\n-      }\n-  }\n-\n-  void visit (AST::SliceType &slice) override;\n-\n-  void visit (AST::RawPointerType &ptr) override;\n-\n-  void visit (AST::ReferenceType &ref) override;\n+  static bool go (AST::QualifiedPathInType &path);\n \n   void visit (AST::TypePathSegmentGeneric &seg) override;\n \n   void visit (AST::TypePathSegment &seg) override;\n \n-  static std::string canonicalize_generic_args (AST::GenericArgs &args);\n-\n-  static bool type_resolve_generic_args (AST::GenericArgs &args);\n-\n protected:\n-  ResolveTypeToCanonicalPath (bool include_generic_args,\n-\t\t\t      bool type_resolve_generic_args)\n-    : ResolverBase (UNKNOWN_NODEID), result (CanonicalPath::create_empty ()),\n-      include_generic_args_flag (include_generic_args),\n-      type_resolve_generic_args_flag (type_resolve_generic_args),\n-      failure_flag (false)\n-  {}\n-\n-  CanonicalPath result;\n-  bool include_generic_args_flag;\n-  bool type_resolve_generic_args_flag;\n-  bool failure_flag;\n-};\n-\n-class ResolvePathSegmentToCanonicalPath\n-{\n-public:\n-  static CanonicalPath resolve (AST::PathExprSegment &seg)\n-  {\n-    if (!seg.has_generic_args ())\n-      return CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t     seg.get_ident_segment ().as_string ());\n-\n-    bool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n-      seg.get_generic_args ());\n-    if (!ok)\n-      {\n-\trust_error_at (seg.get_locus (),\n-\t\t       \"failed to resolve all generic arguments\");\n-\treturn CanonicalPath::create_empty ();\n-      }\n-\n-    return CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t   seg.get_ident_segment ().as_string ());\n-  }\n-};\n-\n-class TraitImplProjection\n-{\n-public:\n-  static CanonicalPath resolve (NodeId id, const CanonicalPath &trait_seg,\n-\t\t\t\tconst CanonicalPath &impl_type_seg)\n-  {\n-    return CanonicalPath::new_seg (id, \"<\" + impl_type_seg.get () + \" as \"\n-\t\t\t\t\t + trait_seg.get () + \">\");\n-  }\n-};\n-\n-class ResolveRelativeTypePath : public ResolveTypeToCanonicalPath\n-{\n-  using ResolveTypeToCanonicalPath::visit;\n-\n-public:\n-  static bool go (AST::TypePath &path, NodeId &resolved_node_id);\n-  static bool go (AST::QualifiedPathInType &path);\n+  bool resolve_qual_seg (AST::QualifiedPathType &seg);\n \n private:\n-  ResolveRelativeTypePath (CanonicalPath qualified_path);\n+  ResolveRelativeQualTypePath ();\n \n-  bool resolve_qual_seg (AST::QualifiedPathType &seg, CanonicalPath &result);\n+  bool failure_flag;\n };\n \n class ResolveType : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static NodeId go (AST::Type *type, NodeId parent,\n-\t\t    bool canonicalize_type_with_generics = false,\n-\t\t    CanonicalPath *canonical_path = nullptr)\n+  static NodeId go (AST::Type *type)\n   {\n-    ResolveType resolver (parent, canonicalize_type_with_generics,\n-\t\t\t  canonical_path);\n+    ResolveType resolver;\n     type->accept_vis (resolver);\n     return resolver.resolved_node;\n-  };\n+  }\n+\n+  static void type_resolve_generic_args (AST::GenericArgs &args)\n+  {\n+    for (auto &gt : args.get_type_args ())\n+      ResolveType::go (gt.get ());\n+  }\n \n   void visit (AST::BareFunctionType &fntype) override\n   {\n     for (auto &param : fntype.get_function_params ())\n-      ResolveType::go (param.get_type ().get (), fntype.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n \n     if (fntype.has_return_type ())\n-      ResolveType::go (fntype.get_return_type ().get (), fntype.get_node_id ());\n+      ResolveType::go (fntype.get_return_type ().get ());\n   }\n \n   void visit (AST::TupleType &tuple) override\n@@ -232,28 +87,17 @@ class ResolveType : public ResolverBase\n       }\n \n     for (auto &elem : tuple.get_elems ())\n-      ResolveType::go (elem.get (), tuple.get_node_id ());\n+      ResolveType::go (elem.get ());\n   }\n \n   void visit (AST::TypePath &path) override\n   {\n-    if (ResolveRelativeTypePath::go (path, resolved_node))\n-      {\n-\tif (canonical_path == nullptr)\n-\t  return;\n-\n-\tconst CanonicalPath *type_path = nullptr;\n-\tif (mappings->lookup_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t\t     resolved_node, &type_path))\n-\t  {\n-\t    *canonical_path = *type_path;\n-\t  }\n-      }\n+    ResolveRelativeTypePath::go (path, resolved_node);\n   }\n \n   void visit (AST::QualifiedPathInType &path) override\n   {\n-    ResolveRelativeTypePath::go (path);\n+    ResolveRelativeQualTypePath::go (path);\n   }\n \n   void visit (AST::ArrayType &type) override;\n@@ -273,94 +117,59 @@ class ResolveType : public ResolverBase\n   void visit (AST::SliceType &type) override;\n \n private:\n-  ResolveType (NodeId parent, bool canonicalize_type_with_generics,\n-\t       CanonicalPath *canonical_path)\n-    : ResolverBase (parent),\n-      canonicalize_type_with_generics (canonicalize_type_with_generics),\n-      canonical_path (canonical_path)\n-  {}\n-\n-  bool canonicalize_type_with_generics;\n-  CanonicalPath *canonical_path;\n+  ResolveType () : ResolverBase () {}\n };\n \n class ResolveTypeBound : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static NodeId go (AST::TypeParamBound *type, NodeId parent,\n-\t\t    bool canonicalize_type_with_generics = false)\n+  static NodeId go (AST::TypeParamBound *type)\n   {\n-    ResolveTypeBound resolver (parent, canonicalize_type_with_generics);\n+    ResolveTypeBound resolver;\n     type->accept_vis (resolver);\n-    if (!resolver.ok)\n-      rust_error_at (type->get_locus (), \"unresolved type bound\");\n-\n     return resolver.resolved_node;\n   };\n \n   void visit (AST::TraitBound &bound) override\n   {\n-    resolved_node = ResolveType::go (&bound.get_type_path (), parent,\n-\t\t\t\t     canonicalize_type_with_generics);\n-    ok = resolved_node != UNKNOWN_NODEID;\n+    resolved_node = ResolveType::go (&bound.get_type_path ());\n   }\n \n-  void visit (AST::Lifetime &) override { ok = true; }\n-\n private:\n-  ResolveTypeBound (NodeId parent, bool canonicalize_type_with_generics)\n-    : ResolverBase (parent),\n-      canonicalize_type_with_generics (canonicalize_type_with_generics),\n-      ok (false)\n-  {}\n-\n-  bool canonicalize_type_with_generics;\n-  bool ok;\n+  ResolveTypeBound () : ResolverBase () {}\n };\n \n class ResolveGenericParam : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static NodeId go (AST::GenericParam *param, NodeId parent)\n+  static NodeId go (AST::GenericParam *param)\n   {\n-    ResolveGenericParam resolver (parent);\n+    ResolveGenericParam resolver;\n     param->accept_vis (resolver);\n-    if (!resolver.ok)\n-      rust_error_at (param->get_locus (), \"unresolved generic parameter\");\n-\n     return resolver.resolved_node;\n-  };\n-\n-  void visit (AST::LifetimeParam &) override\n-  {\n-    // For now do not do anything and accept everything.\n-    ok = true;\n   }\n \n   void visit (AST::ConstGenericParam &) override\n   {\n     // For now do not do anything and accept everything.\n     // FIXME: This needs to change soon!\n-    ok = true;\n   }\n \n   void visit (AST::TypeParam &param) override\n   {\n-    ok = true;\n-\n     // if it has a type lets resolve it\n     if (param.has_type ())\n-      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n \n     if (param.has_type_param_bounds ())\n       {\n \tfor (auto &bound : param.get_type_param_bounds ())\n \t  {\n-\t    ResolveTypeBound::go (bound.get (), param.get_node_id ());\n+\t    ResolveTypeBound::go (bound.get ());\n \t  }\n       }\n \n@@ -379,9 +188,7 @@ class ResolveGenericParam : public ResolverBase\n   }\n \n private:\n-  ResolveGenericParam (NodeId parent) : ResolverBase (parent), ok (false) {}\n-\n-  bool ok;\n+  ResolveGenericParam () : ResolverBase () {}\n };\n \n class ResolveWhereClause : public ResolverBase\n@@ -391,30 +198,46 @@ class ResolveWhereClause : public ResolverBase\n public:\n   static void Resolve (AST::WhereClause &where_clause)\n   {\n-    ResolveWhereClause r (where_clause.get_node_id ());\n+    ResolveWhereClause r;\n     for (auto &clause : where_clause.get_items ())\n       clause->accept_vis (r);\n   }\n \n-  void visit (AST::LifetimeWhereClauseItem &) override\n-  {\n-    // nothing to do\n-  }\n-\n   void visit (AST::TypeBoundWhereClauseItem &item) override\n   {\n-    ResolveType::go (item.get_type ().get (), item.get_node_id ());\n+    ResolveType::go (item.get_type ().get ());\n     if (item.has_type_param_bounds ())\n       {\n \tfor (auto &bound : item.get_type_param_bounds ())\n \t  {\n-\t    ResolveTypeBound::go (bound.get (), item.get_node_id ());\n+\t    ResolveTypeBound::go (bound.get ());\n \t  }\n       }\n   }\n \n private:\n-  ResolveWhereClause (NodeId parent) : ResolverBase (parent) {}\n+  ResolveWhereClause () : ResolverBase () {}\n+};\n+\n+class ResolveTypeToCanonicalPath : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static bool go (AST::Type *type, CanonicalPath &result);\n+\n+  void visit (AST::TypePath &path) override;\n+\n+  void visit (AST::ReferenceType &type) override;\n+\n+  void visit (AST::RawPointerType &type) override;\n+\n+  void visit (AST::SliceType &type) override;\n+\n+private:\n+  ResolveTypeToCanonicalPath ();\n+\n+  CanonicalPath result;\n };\n \n } // namespace Resolver"}, {"sha": "93fa7c8761c290acf51ed1de06f1c26abfb83a50", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -111,102 +111,5 @@ NameResolution::go (AST::Crate &crate)\n   resolver->pop_module_scope ();\n }\n \n-// rust-ast-resolve-struct-expr-field.h\n-\n-void\n-ResolveStructExprField::visit (AST::StructExprFieldIdentifierValue &field)\n-{\n-  ResolveExpr::go (field.get_value ().get (), field.get_node_id (), prefix,\n-\t\t   canonical_prefix);\n-}\n-\n-void\n-ResolveStructExprField::visit (AST::StructExprFieldIndexValue &field)\n-{\n-  ResolveExpr::go (field.get_value ().get (), field.get_node_id (), prefix,\n-\t\t   canonical_prefix);\n-}\n-\n-void\n-ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n-{\n-  AST::IdentifierExpr expr (field.get_field_name (), {}, field.get_locus ());\n-  expr.set_node_id (field.get_node_id ());\n-\n-  ResolveExpr::go (&expr, field.get_node_id (), prefix, canonical_prefix);\n-}\n-\n-// rust-ast-resolve-item.h\n-\n-void\n-ResolveItem::resolve_impl_item (AST::TraitImplItem *item,\n-\t\t\t\tconst CanonicalPath &prefix,\n-\t\t\t\tconst CanonicalPath &canonical_prefix)\n-{\n-  ResolveImplItems::go (item, prefix, canonical_prefix);\n-}\n-\n-void\n-ResolveItem::resolve_impl_item (AST::InherentImplItem *item,\n-\t\t\t\tconst CanonicalPath &prefix,\n-\t\t\t\tconst CanonicalPath &canonical_prefix)\n-{\n-  ResolveImplItems::go (item, prefix, canonical_prefix);\n-}\n-\n-void\n-ResolveItem::resolve_extern_item (AST::ExternalItem *item)\n-{\n-  ResolveExternItem::go (item);\n-}\n-\n-// qualified path in type\n-\n-bool\n-ResolveRelativeTypePath::resolve_qual_seg (AST::QualifiedPathType &seg,\n-\t\t\t\t\t   CanonicalPath &result)\n-{\n-  if (seg.is_error ())\n-    {\n-      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n-\t\t     seg.as_string ().c_str ());\n-      return false;\n-    }\n-\n-  auto type = seg.get_type ().get ();\n-  NodeId type_resolved_node = ResolveType::go (type, seg.get_node_id ());\n-  if (type_resolved_node == UNKNOWN_NODEID)\n-    return false;\n-\n-  const CanonicalPath *impl_type_seg = nullptr;\n-  bool ok\n-    = mappings->lookup_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t       type_resolved_node, &impl_type_seg);\n-  rust_assert (ok);\n-\n-  if (!seg.has_as_clause ())\n-    {\n-      result = result.append (*impl_type_seg);\n-      return true;\n-    }\n-\n-  NodeId trait_resolved_node\n-    = ResolveType::go (&seg.get_as_type_path (), seg.get_node_id ());\n-  if (trait_resolved_node == UNKNOWN_NODEID)\n-    return false;\n-\n-  const CanonicalPath *trait_type_seg = nullptr;\n-  ok = mappings->lookup_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t\ttrait_resolved_node, &trait_type_seg);\n-  rust_assert (ok);\n-\n-  CanonicalPath projection\n-    = TraitImplProjection::resolve (seg.get_node_id (), *trait_type_seg,\n-\t\t\t\t    *impl_type_seg);\n-\n-  result = result.append (projection);\n-  return true;\n-}\n-\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "74551cb014dcedeba4d3d82da6a9c71f82f322f9", "filename": "gcc/rust/resolve/rust-ast-verify-assignee.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -63,8 +63,6 @@ class VerifyAsignee : public ResolverBase\n       return;\n \n     ok = true;\n-    // mark the assignment to the name\n-    resolver->mark_assignment_to_decl (resolved_node, parent);\n   }\n \n   void visit (AST::DereferenceExpr &expr) override\n@@ -75,7 +73,7 @@ class VerifyAsignee : public ResolverBase\n   void visit (AST::PathInExpression &expr) override { ok = true; }\n \n private:\n-  VerifyAsignee (NodeId parent) : ResolverBase (parent), ok (false) {}\n+  VerifyAsignee (NodeId parent) : ResolverBase (), ok (false) {}\n \n   bool ok;\n };"}, {"sha": "a788914da0dec70b82a66be983be287af8b54e29", "filename": "gcc/rust/resolve/rust-name-resolver.cc", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -482,40 +482,5 @@ Resolver::lookup_resolved_macro (NodeId refId, NodeId *defId)\n   return true;\n }\n \n-void\n-Resolver::mark_decl_mutability (NodeId id, bool mut)\n-{\n-  rust_assert (decl_mutability.find (id) == decl_mutability.end ());\n-  decl_mutability[id] = mut;\n-}\n-\n-bool\n-Resolver::decl_is_mutable (NodeId id) const\n-{\n-  auto it = decl_mutability.find (id);\n-  rust_assert (it != decl_mutability.end ());\n-  return it->second;\n-}\n-\n-void\n-Resolver::mark_assignment_to_decl (NodeId id, NodeId assignment)\n-{\n-  auto it = assignment_to_decl.find (id);\n-  if (it == assignment_to_decl.end ())\n-    assignment_to_decl[id] = {};\n-\n-  assignment_to_decl[id].insert (assignment);\n-}\n-\n-size_t\n-Resolver::get_num_assignments_to_decl (NodeId id) const\n-{\n-  auto it = assignment_to_decl.find (id);\n-  if (it == assignment_to_decl.end ())\n-    return 0;\n-\n-  return it->second.size ();\n-}\n-\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "e9f7c621a47df16f91ef1e91379ab20e67435f16", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -124,11 +124,6 @@ class Resolver\n   void insert_resolved_macro (NodeId refId, NodeId defId);\n   bool lookup_resolved_macro (NodeId refId, NodeId *defId);\n \n-  void mark_decl_mutability (NodeId id, bool mut);\n-  bool decl_is_mutable (NodeId id) const;\n-  void mark_assignment_to_decl (NodeId id, NodeId assignment);\n-  size_t get_num_assignments_to_decl (NodeId id) const;\n-\n   // proxy for scoping\n   Scope &get_name_scope () { return name_scope; }\n   Scope &get_type_scope () { return type_scope; }\n@@ -205,11 +200,6 @@ class Resolver\n   std::map<NodeId, NodeId> resolved_labels;\n   std::map<NodeId, NodeId> resolved_macros;\n \n-  // map of resolved names mutability flag\n-  std::map<NodeId, bool> decl_mutability;\n-  // map of resolved names and set of assignments to the decl\n-  std::map<NodeId, std::set<NodeId>> assignment_to_decl;\n-\n   // keep track of the current module scope ids\n   std::vector<NodeId> current_module_stack;\n };"}, {"sha": "54cc0390849f6f43b4aeada35526bffcb6a460ac", "filename": "gcc/rust/util/rust-canonical-path.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Futil%2Frust-canonical-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88cc0aa644836c361ce5d8ff5225a9c12333dea/gcc%2Frust%2Futil%2Frust-canonical-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-canonical-path.h?ref=c88cc0aa644836c361ce5d8ff5225a9c12333dea", "patch": "@@ -61,6 +61,14 @@ class CanonicalPath\n \t\t\t  UNKNOWN_CREATENUM);\n   }\n \n+  static CanonicalPath\n+  trait_impl_projection_seg (NodeId id, const CanonicalPath &trait_seg,\n+\t\t\t     const CanonicalPath &impl_type_seg)\n+  {\n+    return CanonicalPath::new_seg (id, \"<\" + impl_type_seg.get () + \" as \"\n+\t\t\t\t\t + trait_seg.get () + \">\");\n+  }\n+\n   std::string get () const\n   {\n     std::string buf;"}]}