{"sha": "e36206c9940d224637083f2e91bd4c70f4b7dd20", "node_id": "C_kwDOANBUbNoAKGUzNjIwNmM5OTQwZDIyNDYzNzA4M2YyZTkxYmQ0YzcwZjRiN2RkMjA", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-10-12T10:34:06Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-10-12T10:35:45Z"}, "message": "sve: combine inverted masks into NOTs\n\nThe following example\n\nvoid f10(double * restrict z, double * restrict w, double * restrict x,\n\t double * restrict y, int n)\n{\n    for (int i = 0; i < n; i++) {\n        z[i] = (w[i] > 0) ? x[i] + w[i] : y[i] - w[i];\n    }\n}\n\ngenerates currently:\n\n        ld1d    z1.d, p1/z, [x1, x5, lsl 3]\n        fcmgt   p2.d, p1/z, z1.d, #0.0\n        fcmgt   p0.d, p3/z, z1.d, #0.0\n        ld1d    z2.d, p2/z, [x2, x5, lsl 3]\n        bic     p0.b, p3/z, p1.b, p0.b\n        ld1d    z0.d, p0/z, [x3, x5, lsl 3]\n\nwhere a BIC is generated between p1 and p0 where a NOT would be better here\nsince we won't require the use of p3 and opens the pattern up to being CSEd.\n\nAfter this patch using a 2 -> 2 split we generate:\n\n        ld1d    z1.d, p0/z, [x1, x5, lsl 3]\n        fcmgt   p2.d, p0/z, z1.d, #0.0\n        not     p1.b, p0/z, p2.b\n\nThe additional scratch is needed such that we can CSE the two operations.  If\nboth statements wrote to the same register then CSE won't be able to CSE the\nvalues if there are other statements in between that use the register.\n\nA second pattern is needed to capture the nor case as combine will match the\nlongest sequence first.  So without this pattern we end up de-optimizing nor\nand instead emit two nots.  I did not find a better way to do this.\n\ngcc/ChangeLog:\n\n\t* config/aarch64/aarch64-sve.md (*fcm<cmp_op><mode>_bic_combine,\n\t*fcm<cmp_op><mode>_nor_combine, *fcmuo<mode>_bic_combine,\n\t*fcmuo<mode>_nor_combine): New.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/sve/pred-not-gen-1.c: New test.\n\t* gcc.target/aarch64/sve/pred-not-gen-2.c: New test.\n\t* gcc.target/aarch64/sve/pred-not-gen-3.c: New test.\n\t* gcc.target/aarch64/sve/pred-not-gen-4.c: New test.", "tree": {"sha": "e790a32dfadb6a0215c07c30975ad779512291f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e790a32dfadb6a0215c07c30975ad779512291f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e36206c9940d224637083f2e91bd4c70f4b7dd20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e36206c9940d224637083f2e91bd4c70f4b7dd20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e36206c9940d224637083f2e91bd4c70f4b7dd20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e36206c9940d224637083f2e91bd4c70f4b7dd20/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1a7d094307080c3d994209457f732005f59fa6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1a7d094307080c3d994209457f732005f59fa6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1a7d094307080c3d994209457f732005f59fa6a"}], "stats": {"total": 235, "additions": 235, "deletions": 0}, "files": [{"sha": "8fe4c721313e70592d2cf0acbfbe2f07b070b51a", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e36206c9940d224637083f2e91bd4c70f4b7dd20/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e36206c9940d224637083f2e91bd4c70f4b7dd20/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=e36206c9940d224637083f2e91bd4c70f4b7dd20", "patch": "@@ -8126,6 +8126,160 @@\n \t  UNSPEC_COND_FCMUO))]\n )\n \n+;; Similar to *fcm<cmp_op><mode>_and_combine, but for BIC rather than AND.\n+;; In this case, we still need a separate NOT/BIC operation, but predicating\n+;; the comparison on the BIC operand removes the need for a PTRUE.\n+(define_insn_and_split \"*fcm<cmp_op><mode>_bic_combine\"\n+  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa\")\n+\t(and:<VPRED>\n+\t  (and:<VPRED>\n+\t    (not:<VPRED>\n+\t      (unspec:<VPRED>\n+\t        [(match_operand:<VPRED> 1)\n+\t         (const_int SVE_KNOWN_PTRUE)\n+\t         (match_operand:SVE_FULL_F 2 \"register_operand\" \"w\")\n+\t         (match_operand:SVE_FULL_F 3 \"aarch64_simd_reg_or_zero\" \"wDz\")]\n+\t        SVE_COND_FP_CMP_I0))\n+\t    (match_operand:<VPRED> 4 \"register_operand\" \"Upa\"))\n+\t  (match_dup:<VPRED> 1)))\n+   (clobber (match_scratch:<VPRED> 5 \"=&Upl\"))]\n+  \"TARGET_SVE\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 5)\n+\t(unspec:<VPRED>\n+\t  [(match_dup 4)\n+\t   (const_int SVE_MAYBE_NOT_PTRUE)\n+\t   (match_dup 2)\n+\t   (match_dup 3)]\n+\t  SVE_COND_FP_CMP_I0))\n+   (set (match_dup 0)\n+\t(and:<VPRED>\n+\t  (not:<VPRED>\n+\t    (match_dup 5))\n+\t  (match_dup 4)))]\n+{\n+  if (can_create_pseudo_p ())\n+    operands[5] = gen_reg_rtx (<VPRED>mode);\n+}\n+)\n+\n+;; Make sure that we expand to a nor when the operand 4 of\n+;; *fcm<cmp_op><mode>_bic_combine is a not.\n+(define_insn_and_split \"*fcm<cmp_op><mode>_nor_combine\"\n+  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa\")\n+\t(and:<VPRED>\n+\t  (and:<VPRED>\n+\t    (not:<VPRED>\n+\t      (unspec:<VPRED>\n+\t        [(match_operand:<VPRED> 1)\n+\t         (const_int SVE_KNOWN_PTRUE)\n+\t         (match_operand:SVE_FULL_F 2 \"register_operand\" \"w\")\n+\t         (match_operand:SVE_FULL_F 3 \"aarch64_simd_reg_or_zero\" \"wDz\")]\n+\t        SVE_COND_FP_CMP_I0))\n+\t    (not:<VPRED>\n+\t      (match_operand:<VPRED> 4 \"register_operand\" \"Upa\")))\n+\t  (match_dup:<VPRED> 1)))\n+   (clobber (match_scratch:<VPRED> 5 \"=&Upl\"))]\n+  \"TARGET_SVE\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 5)\n+\t(unspec:<VPRED>\n+\t  [(match_dup 1)\n+\t   (const_int SVE_KNOWN_PTRUE)\n+\t   (match_dup 2)\n+\t   (match_dup 3)]\n+\t  SVE_COND_FP_CMP_I0))\n+   (set (match_dup 0)\n+\t(and:<VPRED>\n+\t  (and:<VPRED>\n+\t    (not:<VPRED>\n+\t      (match_dup 5))\n+\t    (not:<VPRED>\n+\t      (match_dup 4)))\n+\t  (match_dup 1)))]\n+{\n+  if (can_create_pseudo_p ())\n+    operands[5] = gen_reg_rtx (<VPRED>mode);\n+}\n+)\n+\n+(define_insn_and_split \"*fcmuo<mode>_bic_combine\"\n+  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa\")\n+\t(and:<VPRED>\n+\t  (and:<VPRED>\n+\t    (not:<VPRED>\n+\t      (unspec:<VPRED>\n+\t        [(match_operand:<VPRED> 1)\n+\t         (const_int SVE_KNOWN_PTRUE)\n+\t         (match_operand:SVE_FULL_F 2 \"register_operand\" \"w\")\n+\t         (match_operand:SVE_FULL_F 3 \"aarch64_simd_reg_or_zero\" \"wDz\")]\n+\t        UNSPEC_COND_FCMUO))\n+\t    (match_operand:<VPRED> 4 \"register_operand\" \"Upa\"))\n+\t  (match_dup:<VPRED> 1)))\n+   (clobber (match_scratch:<VPRED> 5 \"=&Upl\"))]\n+  \"TARGET_SVE\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 5)\n+\t(unspec:<VPRED>\n+\t  [(match_dup 4)\n+\t   (const_int SVE_MAYBE_NOT_PTRUE)\n+\t   (match_dup 2)\n+\t   (match_dup 3)]\n+\t  UNSPEC_COND_FCMUO))\n+   (set (match_dup 0)\n+\t(and:<VPRED>\n+\t  (not:<VPRED>\n+\t    (match_dup 5))\n+\t  (match_dup 4)))]\n+{\n+  if (can_create_pseudo_p ())\n+    operands[5] = gen_reg_rtx (<VPRED>mode);\n+}\n+)\n+\n+;; Same for unordered comparisons.\n+(define_insn_and_split \"*fcmuo<mode>_nor_combine\"\n+  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa\")\n+\t(and:<VPRED>\n+\t  (and:<VPRED>\n+\t    (not:<VPRED>\n+\t      (unspec:<VPRED>\n+\t        [(match_operand:<VPRED> 1)\n+\t         (const_int SVE_KNOWN_PTRUE)\n+\t         (match_operand:SVE_FULL_F 2 \"register_operand\" \"w\")\n+\t         (match_operand:SVE_FULL_F 3 \"aarch64_simd_reg_or_zero\" \"wDz\")]\n+\t        UNSPEC_COND_FCMUO))\n+\t    (not:<VPRED>\n+\t      (match_operand:<VPRED> 4 \"register_operand\" \"Upa\")))\n+\t  (match_dup:<VPRED> 1)))\n+   (clobber (match_scratch:<VPRED> 5 \"=&Upl\"))]\n+  \"TARGET_SVE\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 5)\n+\t(unspec:<VPRED>\n+\t  [(match_dup 1)\n+\t   (const_int SVE_KNOWN_PTRUE)\n+\t   (match_dup 2)\n+\t   (match_dup 3)]\n+\t  UNSPEC_COND_FCMUO))\n+   (set (match_dup 0)\n+\t(and:<VPRED>\n+\t  (and:<VPRED>\n+\t    (not:<VPRED>\n+\t      (match_dup 5))\n+\t    (not:<VPRED>\n+\t      (match_dup 4)))\n+\t  (match_dup 1)))]\n+{\n+  if (can_create_pseudo_p ())\n+    operands[5] = gen_reg_rtx (<VPRED>mode);\n+}\n+)\n+\n ;; -------------------------------------------------------------------------\n ;; ---- [FP] Absolute comparisons\n ;; -------------------------------------------------------------------------"}, {"sha": "2c06564186c5a5e7917da475a9c201c81dfeb136", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pred-not-gen-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e36206c9940d224637083f2e91bd4c70f4b7dd20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-not-gen-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e36206c9940d224637083f2e91bd4c70f4b7dd20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-not-gen-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-not-gen-1.c?ref=e36206c9940d224637083f2e91bd4c70f4b7dd20", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O3 --save-temps\" } */\n+\n+/*\n+** f10:\n+** ...\n+** \tld1d\tz1.d, p0/z, \\[x1, x5, lsl 3\\]\n+** \tfcmgt\tp2.d, p0/z, z1.d, #0.0\n+** \tld1d\tz2.d, p2/z, \\[x2, x5, lsl 3\\]\n+** \tnot\tp1.b, p0/z, p2.b\n+** \tld1d\tz0.d, p1/z, \\[x3, x5, lsl 3\\]\n+** ...\n+*/\n+\n+void f10(double * restrict z, double * restrict w, double * restrict x, double * restrict y, int n)\n+{\n+    for (int i = 0; i < n; i++) {\n+        z[i] = (w[i] > 0) ? x[i] + w[i] : y[i] - w[i];\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tbic\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tnot\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b\\n} 1 } } */"}, {"sha": "0c3b78d4c67455c971e94fb2ffdd7be2d4884864", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pred-not-gen-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e36206c9940d224637083f2e91bd4c70f4b7dd20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-not-gen-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e36206c9940d224637083f2e91bd4c70f4b7dd20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-not-gen-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-not-gen-2.c?ref=e36206c9940d224637083f2e91bd4c70f4b7dd20", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O3 --save-temps\" } */\n+\n+/*\n+** f11:\n+** ...\n+** \tld1d\tz0.d, p0/z, \\[x1, x2, lsl 3\\]\n+** \tfcmgt\tp2.d, p3/z, z0.d, #0.0\n+** \tfcmgt\tp1.d, p0/z, z0.d, #0.0\n+** \tnot\tp1.b, p0/z, p1.b\n+** \tld1d\tz1.d, p1/z, \\[x3, x2, lsl 3\\]\n+** ...\n+*/\n+\n+void f11(double * restrict z, double * restrict w, double * restrict x, double * restrict y, int n)\n+{\n+    for (int i = 0; i < n; i++) {\n+        z[i] = (w[i] > 0) ? w[i] : y[i];\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tbic\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tnot\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b\\n} 1 } } */"}, {"sha": "248f8ab57191ce8a1d4c334533de8bc76aa07691", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pred-not-gen-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e36206c9940d224637083f2e91bd4c70f4b7dd20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-not-gen-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e36206c9940d224637083f2e91bd4c70f4b7dd20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-not-gen-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-not-gen-3.c?ref=e36206c9940d224637083f2e91bd4c70f4b7dd20", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O3 --save-temps\" } */\n+\n+/*\n+** f12:\n+** ...\n+** \tld1w\tz1.s, p0/z, \\[x1, x2, lsl 2\\]\n+** \tcmple\tp1.s, p0/z, z1.s, #0\n+** \tld1w\tz0.s, p1/z, \\[x3, x2, lsl 2\\]\n+** ...\n+*/\n+\n+void f12(int * restrict z, int * restrict w, int * restrict x, int * restrict y, int n)\n+{\n+    for (int i = 0; i < n; i++) {\n+        z[i] = (w[i] > 0) ? w[i] : y[i];\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tbic\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tnot\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b\\n} } } */"}, {"sha": "96200309880a91ad1db5801115c911cfdce06125", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pred-not-gen-4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e36206c9940d224637083f2e91bd4c70f4b7dd20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-not-gen-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e36206c9940d224637083f2e91bd4c70f4b7dd20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-not-gen-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-not-gen-4.c?ref=e36206c9940d224637083f2e91bd4c70f4b7dd20", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O3 --save-temps\" } */\n+\n+#include <math.h>\n+\n+void f13(double * restrict z, double * restrict w, double * restrict x, double * restrict y, int n)\n+{\n+    for (int i = 0; i < n; i++) {\n+        z[i] = (isunordered(w[i], 0)) ? x[i] + w[i] : y[i] - w[i];\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tbic\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tnot\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b\\n} 1 } } */"}]}