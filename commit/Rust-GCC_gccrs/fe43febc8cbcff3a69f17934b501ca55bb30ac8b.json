{"sha": "fe43febc8cbcff3a69f17934b501ca55bb30ac8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU0M2ZlYmM4Y2JjZmYzYTY5ZjE3OTM0YjUwMWNhNTViYjMwYWM4Yg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-08-08T09:26:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-08-08T09:26:54Z"}, "message": "modulo-sched.c (get_sched_window): Use just one loop for predecessors and one loop for successors.\n\ngcc/\n\t* modulo-sched.c (get_sched_window): Use just one loop for predecessors\n\tand one loop for successors.  Fix upper bound of memory range.\n\nFrom-SVN: r177555", "tree": {"sha": "4e1a90389ebb8d9d432a44db40b3f8d56d02dd35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e1a90389ebb8d9d432a44db40b3f8d56d02dd35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe43febc8cbcff3a69f17934b501ca55bb30ac8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe43febc8cbcff3a69f17934b501ca55bb30ac8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe43febc8cbcff3a69f17934b501ca55bb30ac8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe43febc8cbcff3a69f17934b501ca55bb30ac8b/comments", "author": null, "committer": null, "parents": [{"sha": "d855a67e7daf5e4cc7f51943f89355f41b19bc68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d855a67e7daf5e4cc7f51943f89355f41b19bc68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d855a67e7daf5e4cc7f51943f89355f41b19bc68"}], "stats": {"total": 292, "additions": 104, "deletions": 188}, "files": [{"sha": "495227fe1a5f15cd32d39989b77b96f792303c24", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe43febc8cbcff3a69f17934b501ca55bb30ac8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe43febc8cbcff3a69f17934b501ca55bb30ac8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe43febc8cbcff3a69f17934b501ca55bb30ac8b", "patch": "@@ -1,3 +1,8 @@\n+2011-08-08  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* modulo-sched.c (get_sched_window): Use just one loop for predecessors\n+\tand one loop for successors.  Fix upper bound of memory range.\n+\n 2011-08-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/50001"}, {"sha": "e3dc3aa69172847e7421a5ee6788eb6f36276572", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 99, "deletions": 188, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe43febc8cbcff3a69f17934b501ca55bb30ac8b/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe43febc8cbcff3a69f17934b501ca55bb30ac8b/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=fe43febc8cbcff3a69f17934b501ca55bb30ac8b", "patch": "@@ -1630,232 +1630,143 @@ sms_schedule (void)\n \n static int\n get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n-\t\t  sbitmap sched_nodes, int ii, int *start_p, int *step_p, int *end_p)\n+\t\t  sbitmap sched_nodes, int ii, int *start_p, int *step_p,\n+\t\t  int *end_p)\n {\n   int start, step, end;\n+  int early_start, late_start;\n   ddg_edge_ptr e;\n   sbitmap psp = sbitmap_alloc (ps->g->num_nodes);\n   sbitmap pss = sbitmap_alloc (ps->g->num_nodes);\n   sbitmap u_node_preds = NODE_PREDECESSORS (u_node);\n   sbitmap u_node_succs = NODE_SUCCESSORS (u_node);\n   int psp_not_empty;\n   int pss_not_empty;\n+  int count_preds;\n+  int count_succs;\n \n   /* 1. compute sched window for u (start, end, step).  */\n   sbitmap_zero (psp);\n   sbitmap_zero (pss);\n   psp_not_empty = sbitmap_a_and_b_cg (psp, u_node_preds, sched_nodes);\n   pss_not_empty = sbitmap_a_and_b_cg (pss, u_node_succs, sched_nodes);\n \n-  if (psp_not_empty && !pss_not_empty)\n-    {\n-      int early_start = INT_MIN;\n-\n-      end = INT_MAX;\n-      for (e = u_node->in; e != 0; e = e->next_in)\n-\t{\n-\t  ddg_node_ptr v_node = e->src;\n-\n-          if (dump_file)\n-            {\n-\t      fprintf (dump_file, \"\\nProcessing edge: \");\n-              print_ddg_edge (dump_file, e);\n-\t      fprintf (dump_file,\n-\t\t       \"\\nScheduling %d (%d) in psp_not_empty,\"\n-\t\t       \" checking p %d (%d): \", u_node->cuid,\n-\t\t       INSN_UID (u_node->insn), v_node->cuid, INSN_UID\n-\t\t       (v_node->insn));\n-            }\n-\n-\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n-\t    {\n-              int p_st = SCHED_TIME (v_node);\n-\n-              early_start =\n-                MAX (early_start, p_st + e->latency - (e->distance * ii));\n-\n-              if (dump_file)\n-                fprintf (dump_file,\n-                         \"pred st = %d; early_start = %d; latency: %d\",\n-                         p_st, early_start, e->latency);\n-\n-\t      if (e->data_type == MEM_DEP)\n-\t\tend = MIN (end, SCHED_TIME (v_node) + ii - 1);\n-\t    }\n-         else if (dump_file)\n-            fprintf (dump_file, \"the node is not scheduled\\n\");\n-\t}\n-      start = early_start;\n-      end = MIN (end, early_start + ii);\n-      /* Schedule the node close to it's predecessors.  */\n-      step = 1;\n-\n-      if (dump_file)\n-        fprintf (dump_file,\n-\t\t \"\\nScheduling %d (%d) in a window (%d..%d) with step %d\\n\",\n-\t\t u_node->cuid, INSN_UID (u_node->insn), start, end, step);\n-    }\n-\n-  else if (!psp_not_empty && pss_not_empty)\n-    {\n-      int late_start = INT_MAX;\n-\n-      end = INT_MIN;\n-      for (e = u_node->out; e != 0; e = e->next_out)\n-\t{\n-\t  ddg_node_ptr v_node = e->dest;\n-\n-          if (dump_file)\n-            {\n-              fprintf (dump_file, \"\\nProcessing edge:\");\n-              print_ddg_edge (dump_file, e);\n-              fprintf (dump_file,\n-                       \"\\nScheduling %d (%d) in pss_not_empty,\"\n-                       \" checking s %d (%d): \", u_node->cuid,\n-                       INSN_UID (u_node->insn), v_node->cuid, INSN_UID\n-                       (v_node->insn));\n-            }\n+  /* We first compute a forward range (start <= end), then decide whether\n+     to reverse it.  */\n+  early_start = INT_MIN;\n+  late_start = INT_MAX;\n+  start = INT_MIN;\n+  end = INT_MAX;\n+  step = 1;\n \n-\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n-\t    {\n-              int s_st = SCHED_TIME (v_node);\n+  count_preds = 0;\n+  count_succs = 0;\n \n-              late_start = MIN (late_start,\n-                                s_st - e->latency + (e->distance * ii));\n+  /* Calculate early_start and limit end.  Both bounds are inclusive.  */\n+  if (psp_not_empty)\n+    for (e = u_node->in; e != 0; e = e->next_in)\n+      {\n+\tddg_node_ptr v_node = e->src;\n \n-              if (dump_file)\n-                fprintf (dump_file,\n-                         \"succ st = %d; late_start = %d; latency = %d\",\n-                         s_st, late_start, e->latency);\n+\tif (dump_file)\n+\t  {\n+\t    fprintf (dump_file, \"\\nProcessing edge: \");\n+\t    print_ddg_edge (dump_file, e);\n+\t    fprintf (dump_file,\n+\t\t     \"\\nScheduling %d (%d) in psp_not_empty,\"\n+\t\t     \" checking p %d (%d): \", u_node->cuid,\n+\t\t     INSN_UID (u_node->insn), v_node->cuid, INSN_UID\n+\t\t     (v_node->insn));\n+\t  }\n \n-\t      if (e->data_type == MEM_DEP)\n-\t\tend = MAX (end, SCHED_TIME (v_node) - ii + 1);\n-             if (dump_file)\n-                 fprintf (dump_file, \"end = %d\\n\", end);\n+\tif (TEST_BIT (sched_nodes, v_node->cuid))\n+\t  {\n+\t    int p_st = SCHED_TIME (v_node);\n \n-\t    }\n-          else if (dump_file)\n-            fprintf (dump_file, \"the node is not scheduled\\n\");\n+\t    early_start = MAX (early_start,\n+\t\t\t       p_st + e->latency - (e->distance * ii));\n \n-\t}\n-      start = late_start;\n-      end = MAX (end, late_start - ii);\n-      /* Schedule the node close to it's successors.  */\n-      step = -1;\n+\t    if (e->data_type == MEM_DEP)\n+\t      end = MIN (end, p_st + ii - 1);\n \n-      if (dump_file)\n-        fprintf (dump_file,\n-                 \"\\nScheduling %d (%d) in a window (%d..%d) with step %d\\n\",\n-                 u_node->cuid, INSN_UID (u_node->insn), start, end, step);\n+\t    if (e->type == TRUE_DEP && e->data_type == REG_DEP)\n+\t      count_preds++;\n \n-    }\n-\n-  else if (psp_not_empty && pss_not_empty)\n-    {\n-      int early_start = INT_MIN;\n-      int late_start = INT_MAX;\n-      int count_preds = 0;\n-      int count_succs = 0;\n-\n-      start = INT_MIN;\n-      end = INT_MAX;\n-      for (e = u_node->in; e != 0; e = e->next_in)\n-\t{\n-\t  ddg_node_ptr v_node = e->src;\n-\n-\t  if (dump_file)\n-\t    {\n-              fprintf (dump_file, \"\\nProcessing edge:\");\n-              print_ddg_edge (dump_file, e);\n+\t    if (dump_file)\n \t      fprintf (dump_file,\n-\t\t       \"\\nScheduling %d (%d) in psp_pss_not_empty,\"\n-\t\t       \" checking p %d (%d): \", u_node->cuid, INSN_UID\n-\t\t       (u_node->insn), v_node->cuid, INSN_UID\n-\t\t       (v_node->insn));\n-\t    }\n-\n-\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n-\t    {\n-              int p_st = SCHED_TIME (v_node);\n-\n-\t      early_start = MAX (early_start,\n-\t\t\t\t p_st + e->latency\n-\t\t\t\t - (e->distance * ii));\n+\t\t       \"pred st = %d; early_start = %d; latency: %d;\"\n+\t\t       \" end: %d\\n\", p_st, early_start, e->latency, end);\n \n-              if (dump_file)\n-                fprintf (dump_file,\n-                         \"pred st = %d; early_start = %d; latency = %d\",\n-                         p_st, early_start, e->latency);\n+\t  }\n+\telse if (dump_file)\n+\t  fprintf (dump_file, \"the node is not scheduled\\n\");\n+      }\n \n-              if (e->type == TRUE_DEP && e->data_type == REG_DEP)\n-                count_preds++;\n+  /* Calculate late_start and limit start.  Both bounds are inclusive.  */\n+  if (pss_not_empty)\n+    for (e = u_node->out; e != 0; e = e->next_out)\n+      {\n+\tddg_node_ptr v_node = e->dest;\n \n-\t      if (e->data_type == MEM_DEP)\n-\t\tend = MIN (end, SCHED_TIME (v_node) + ii - 1);\n-\t    }\n-          else if (dump_file)\n-            fprintf (dump_file, \"the node is not scheduled\\n\");\n+\tif (dump_file)\n+\t  {\n+\t    fprintf (dump_file, \"\\nProcessing edge:\");\n+\t    print_ddg_edge (dump_file, e);\n+\t    fprintf (dump_file,\n+\t\t     \"\\nScheduling %d (%d) in pss_not_empty,\"\n+\t\t     \" checking s %d (%d): \", u_node->cuid,\n+\t\t     INSN_UID (u_node->insn), v_node->cuid, INSN_UID\n+\t\t     (v_node->insn));\n+\t  }\n \n-\t}\n-      for (e = u_node->out; e != 0; e = e->next_out)\n-\t{\n-\t  ddg_node_ptr v_node = e->dest;\n+\tif (TEST_BIT (sched_nodes, v_node->cuid))\n+\t  {\n+\t    int s_st = SCHED_TIME (v_node);\n \n-\t  if (dump_file)\n-\t    {\n-              fprintf (dump_file, \"\\nProcessing edge:\");\n-              print_ddg_edge (dump_file, e);\n-\t      fprintf (dump_file,\n-\t\t       \"\\nScheduling %d (%d) in psp_pss_not_empty,\"\n-\t\t       \" checking s %d (%d): \", u_node->cuid, INSN_UID\n-\t\t       (u_node->insn), v_node->cuid, INSN_UID\n-\t\t       (v_node->insn));\n-\t    }\n+\t    late_start = MIN (late_start,\n+\t\t\t      s_st - e->latency + (e->distance * ii));\n \n-\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n-\t    {\n-              int s_st = SCHED_TIME (v_node);\n+\t    if (e->data_type == MEM_DEP)\n+\t      start = MAX (start, s_st - ii + 1);\n \n-\t      late_start = MIN (late_start,\n-\t\t\t\ts_st - e->latency\n-\t\t\t\t+ (e->distance * ii));\n+\t    if (e->type == TRUE_DEP && e->data_type == REG_DEP)\n+\t      count_succs++;\n \n-              if (dump_file)\n-                fprintf (dump_file,\n-                         \"succ st = %d; late_start = %d; latency = %d\",\n-                         s_st, late_start, e->latency);\n+\t    if (dump_file)\n+\t      fprintf (dump_file,\n+\t\t       \"succ st = %d; late_start = %d; latency = %d;\"\n+\t\t       \" start=%d\", s_st, late_start, e->latency, start);\n \n-               if (e->type == TRUE_DEP && e->data_type == REG_DEP)\n-                 count_succs++;\n+\t  }\n+\telse if (dump_file)\n+\t  fprintf (dump_file, \"the node is not scheduled\\n\");\n+      }\n \n-\t      if (e->data_type == MEM_DEP)\n-\t\tstart = MAX (start, SCHED_TIME (v_node) - ii + 1);\n-\t    }\n-          else if (dump_file)\n-            fprintf (dump_file, \"the node is not scheduled\\n\");\n+  /* Get a target scheduling window no bigger than ii.  */\n+  if (early_start == INT_MIN && late_start == INT_MAX)\n+    early_start = SCHED_ASAP (u_node);\n+  else if (early_start == INT_MIN)\n+    early_start = late_start - (ii - 1);\n+  late_start = MIN (late_start, early_start + (ii - 1));\n \n-\t}\n-      start = MAX (start, early_start);\n-      end = MIN (end, MIN (early_start + ii, late_start + 1));\n-      step = 1;\n-      /* If there are more successors than predecessors schedule the\n-         node close to it's successors.  */\n-      if (count_succs >= count_preds)\n-        {\n-          int old_start = start;\n+  /* Apply memory dependence limits.  */\n+  start = MAX (start, early_start);\n+  end = MIN (end, late_start);\n \n-          start = end - 1;\n-          end = old_start - 1;\n-          step = -1;\n-        }\n-    }\n-  else /* psp is empty && pss is empty.  */\n+  /* If there are at least as many successors as predecessors, schedule the\n+     node close to its successors.  */\n+  if (pss_not_empty && count_succs >= count_preds)\n     {\n-      start = SCHED_ASAP (u_node);\n-      end = start + ii;\n-      step = 1;\n+      int tmp = end;\n+      end = start;\n+      start = tmp;\n+      step = -1;\n     }\n \n+  /* Now that we've finalized the window, make END an exclusive rather\n+     than an inclusive bound.  */\n+  end += step;\n+\n   *start_p = start;\n   *step_p = step;\n   *end_p = end;\n@@ -1867,10 +1778,10 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n       if (dump_file)\n \tfprintf (dump_file, \"\\nEmpty window: start=%d, end=%d, step=%d\\n\",\n \t\t start, end, step);\n-    return -1;\n+      return -1;\n     }\n \n-    return 0;\n+  return 0;\n }\n \n /* Calculate MUST_PRECEDE/MUST_FOLLOW bitmaps of U_NODE; which is the"}]}