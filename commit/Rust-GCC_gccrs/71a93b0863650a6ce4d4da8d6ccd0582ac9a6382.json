{"sha": "71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFhOTNiMDg2MzY1MGE2Y2U0ZDRkYThkNmNjZDA1ODJhYzlhNjM4Mg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2018-05-24T17:20:01Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2018-05-24T17:20:01Z"}, "message": "cp-tree.h (INDIRECT_TYPE_P): New.\n\n2018-05-24  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* cp-tree.h (INDIRECT_TYPE_P): New.\n\t* call.c (build_trivial_dtor_call, maybe_warn_class_memaccess,\n\tjoust): Use it instead of POINTER_TYPE_P.\n\t* class.c (update_vtable_entry_for_fn, find_flexarrays,\n\t* fixed_type_or_null, resolves_to_fixed_type_p): Likewise.\n\t* constexpr.c (cxx_eval_binary_expression, cxx_fold_indirect_ref,\n\t* cxx_eval_increment_expression, potential_constant_expression_1):\n\tLikewise.\n\t* cp-gimplify.c (cp_gimplify_expr, cp_genericize_r): Likewise.\n\t* cp-objcp-common.c (cxx_get_alias_set): Likewise.\n\t* cp-ubsan.c (cp_ubsan_maybe_instrument_member_call,\n\tcp_ubsan_maybe_instrument_downcast): Likewise.\n\t* cvt.c (cp_convert_to_pointer, ocp_convert,\n\tcp_get_fndecl_from_callee, maybe_warn_nodiscard, convert): Likewise.\n\t* cxx-pretty-print.c (cxx_pretty_printer::abstract_declarator,\n\tpp_cxx_offsetof_expression_1): Likewise.\n\t* decl.c (grokparms, static_fn_type): Likewise.\n\t* decl2.c (grokbitfield): Likewise.\n\t* error.c (dump_expr): Likewise.\n\t* except.c (initialize_handler_parm, check_noexcept_r): Likewise.\n\t* init.c (warn_placement_new_too_small): Likewise.\n\t* lambda.c (build_capture_proxy, add_capture): Likewise.\n\t* parser.c (cp_parser_omp_for_loop): Likewise.\n\t* pt.c (convert_nontype_argument, fn_type_unification,\n\tuses_deducible_template_parms, check_cv_quals_for_unify,\n\tdependent_type_p_r): Likewise.\n\t* search.c (check_final_overrider): Likewise.\n\t* semantics.c (handle_omp_array_sections, finish_omp_clauses,\n\tfinish_omp_for): Likewise.\n\t* tree.c (cp_build_qualified_type_real): Likewise.\n\t* typeck.c (build_class_member_access_expr,\n\tfinish_class_member_access_expr, build_x_indirect_ref,\n\tcp_build_indirect_ref_1, cp_build_binary_op, build_const_cast_1):\n\tLikewise.\n\nFrom-SVN: r260677", "tree": {"sha": "6a29b482ff415d2551d399f499921f5f88e1e4da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a29b482ff415d2551d399f499921f5f88e1e4da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/comments", "author": null, "committer": null, "parents": [{"sha": "25999a112f1567a841dafb22020eca17c3406f25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25999a112f1567a841dafb22020eca17c3406f25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25999a112f1567a841dafb22020eca17c3406f25"}], "stats": {"total": 167, "additions": 103, "deletions": 64}, "files": [{"sha": "10e57ee123f0ae48b577bdc4a6c41dfab69e5351", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -1,3 +1,40 @@\n+2018-05-24  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* cp-tree.h (INDIRECT_TYPE_P): New.\n+\t* call.c (build_trivial_dtor_call, maybe_warn_class_memaccess,\n+\tjoust): Use it instead of POINTER_TYPE_P.\n+\t* class.c (update_vtable_entry_for_fn, find_flexarrays,\n+\t* fixed_type_or_null, resolves_to_fixed_type_p): Likewise.\n+\t* constexpr.c (cxx_eval_binary_expression, cxx_fold_indirect_ref,\n+\t* cxx_eval_increment_expression, potential_constant_expression_1):\n+\tLikewise.\n+\t* cp-gimplify.c (cp_gimplify_expr, cp_genericize_r): Likewise.\n+\t* cp-objcp-common.c (cxx_get_alias_set): Likewise.\n+\t* cp-ubsan.c (cp_ubsan_maybe_instrument_member_call,\n+\tcp_ubsan_maybe_instrument_downcast): Likewise.\n+\t* cvt.c (cp_convert_to_pointer, ocp_convert,\n+\tcp_get_fndecl_from_callee, maybe_warn_nodiscard, convert): Likewise.\n+\t* cxx-pretty-print.c (cxx_pretty_printer::abstract_declarator,\n+\tpp_cxx_offsetof_expression_1): Likewise.\n+\t* decl.c (grokparms, static_fn_type): Likewise.\n+\t* decl2.c (grokbitfield): Likewise.\n+\t* error.c (dump_expr): Likewise.\n+\t* except.c (initialize_handler_parm, check_noexcept_r): Likewise.\n+\t* init.c (warn_placement_new_too_small): Likewise.\n+\t* lambda.c (build_capture_proxy, add_capture): Likewise.\n+\t* parser.c (cp_parser_omp_for_loop): Likewise.\n+\t* pt.c (convert_nontype_argument, fn_type_unification,\n+\tuses_deducible_template_parms, check_cv_quals_for_unify,\n+\tdependent_type_p_r): Likewise.\n+\t* search.c (check_final_overrider): Likewise.\n+\t* semantics.c (handle_omp_array_sections, finish_omp_clauses,\n+\tfinish_omp_for): Likewise.\n+\t* tree.c (cp_build_qualified_type_real): Likewise.\n+\t* typeck.c (build_class_member_access_expr,\n+\tfinish_class_member_access_expr, build_x_indirect_ref,\n+\tcp_build_indirect_ref_1, cp_build_binary_op, build_const_cast_1):\n+\tLikewise.\n+\n 2018-05-24  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/85864 - literal template and default template arg."}, {"sha": "7aadd642ebb6d4d4b465699c90fe2f16cecd6020", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -7622,7 +7622,7 @@ build_trivial_dtor_call (tree instance)\n       return fold_convert (void_type_node, instance);\n     }\n \n-  if (POINTER_TYPE_P (TREE_TYPE (instance)))\n+  if (INDIRECT_TYPE_P (TREE_TYPE (instance)))\n     {\n       if (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (instance))))\n \tgoto no_clobber;\n@@ -8511,7 +8511,7 @@ maybe_warn_class_memaccess (location_t loc, tree fndecl,\n   unsigned srcidx = !dstidx;\n \n   tree dest = (*args)[dstidx];\n-  if (!TREE_TYPE (dest) || !POINTER_TYPE_P (TREE_TYPE (dest)))\n+  if (!TREE_TYPE (dest) || !INDIRECT_TYPE_P (TREE_TYPE (dest)))\n     return;\n \n   tree srctype = NULL_TREE;\n@@ -8643,7 +8643,7 @@ maybe_warn_class_memaccess (location_t loc, tree fndecl,\n     case BUILT_IN_MEMPCPY:\n       /* Determine the type of the source object.  */\n       srctype = TREE_TYPE ((*args)[srcidx]);\n-      if (!srctype || !POINTER_TYPE_P (srctype))\n+      if (!srctype || !INDIRECT_TYPE_P (srctype))\n \tsrctype = void_type_node;\n       else\n \tsrctype = TREE_TYPE (srctype);\n@@ -10210,7 +10210,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \t  tree t = TREE_TYPE (TREE_TYPE (l->fn));\n \t  tree f = TREE_TYPE (TREE_TYPE (w->fn));\n \n-\t  if (TREE_CODE (t) == TREE_CODE (f) && POINTER_TYPE_P (t))\n+\t  if (TREE_CODE (t) == TREE_CODE (f) && INDIRECT_TYPE_P (t))\n \t    {\n \t      t = TREE_TYPE (t);\n \t      f = TREE_TYPE (f);\n@@ -10226,7 +10226,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n       else if (warn)\n \t{\n \t  tree source = source_type (w->convs[0]);\n-\t  if (POINTER_TYPE_P (source))\n+\t  if (INDIRECT_TYPE_P (source))\n \t    source = TREE_TYPE (source);\n \t  if (warning (OPT_Wconversion, \"choosing %qD over %qD\", w->fn, l->fn)\n \t      && warning (OPT_Wconversion, \"  for conversion from %qH to %qI\","}, {"sha": "a17c8ed8b4593018745dbc6429d0953c328018c9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -2445,7 +2445,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n   over_return = TREE_TYPE (TREE_TYPE (overrider_target));\n   base_return = TREE_TYPE (TREE_TYPE (target_fn));\n \n-  if (POINTER_TYPE_P (over_return)\n+  if (INDIRECT_TYPE_P (over_return)\n       && TREE_CODE (over_return) == TREE_CODE (base_return)\n       && CLASS_TYPE_P (TREE_TYPE (over_return))\n       && CLASS_TYPE_P (TREE_TYPE (base_return))\n@@ -6481,8 +6481,7 @@ find_flexarrays (tree t, flexmems_t *fmem, bool base_p,\n \t members if it hasn't been yet.  */\n       tree eltype = fldtype;\n       while (TREE_CODE (eltype) == ARRAY_TYPE\n-\t     || TYPE_PTR_P (eltype)\n-\t     || TYPE_REF_P (eltype))\n+\t     || INDIRECT_TYPE_P (eltype))\n \teltype = TREE_TYPE (eltype);\n \n       if (RECORD_OR_UNION_TYPE_P (eltype))\n@@ -7144,7 +7143,7 @@ fixed_type_or_null (tree instance, int *nonnull, int *cdtorp)\n   switch (TREE_CODE (instance))\n     {\n     case INDIRECT_REF:\n-      if (POINTER_TYPE_P (TREE_TYPE (instance)))\n+      if (INDIRECT_TYPE_P (TREE_TYPE (instance)))\n \treturn NULL_TREE;\n       else\n \treturn RECUR (TREE_OPERAND (instance, 0));\n@@ -7314,7 +7313,7 @@ resolves_to_fixed_type_p (tree instance, int* nonnull)\n   fixed = fixed_type_or_null (instance, nonnull, &cdtorp);\n   if (fixed == NULL_TREE)\n     return 0;\n-  if (POINTER_TYPE_P (t))\n+  if (INDIRECT_TYPE_P (t))\n     t = TREE_TYPE (t);\n   if (!same_type_ignoring_top_level_qualifiers_p (t, fixed))\n     return 0;"}, {"sha": "a099408dd2823bded9e8864cffa16131a2e6838f", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -2088,7 +2088,7 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n     *non_constant_p = true;\n   /* Don't VERIFY_CONSTANT if this might be dealing with a pointer to\n      a local array in a constexpr function.  */\n-  bool ptr = POINTER_TYPE_P (TREE_TYPE (lhs));\n+  bool ptr = INDIRECT_TYPE_P (TREE_TYPE (lhs));\n   if (!ptr)\n     VERIFY_CONSTANT (r);\n   return r;\n@@ -3082,7 +3082,7 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n \n   STRIP_NOPS (sub);\n   subtype = TREE_TYPE (sub);\n-  if (!POINTER_TYPE_P (subtype))\n+  if (!INDIRECT_TYPE_P (subtype))\n     return NULL_TREE;\n \n   if (TREE_CODE (sub) == ADDR_EXPR)\n@@ -3784,14 +3784,14 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t    non_constant_p, overflow_p);\n   /* Don't VERIFY_CONSTANT if this might be dealing with a pointer to\n      a local array in a constexpr function.  */\n-  bool ptr = POINTER_TYPE_P (TREE_TYPE (val));\n+  bool ptr = INDIRECT_TYPE_P (TREE_TYPE (val));\n   if (!ptr)\n     VERIFY_CONSTANT (val);\n \n   /* The modified value.  */\n   bool inc = (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR);\n   tree mod;\n-  if (POINTER_TYPE_P (type))\n+  if (INDIRECT_TYPE_P (type))\n     {\n       /* The middle end requires pointers to use POINTER_PLUS_EXPR.  */\n       offset = convert_to_ptrofftype (offset);\n@@ -4613,7 +4613,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    return cp_fold_convert (type, op);\n \t  }\n \n-\tif (POINTER_TYPE_P (type) && TREE_CODE (op) == INTEGER_CST)\n+\tif (INDIRECT_TYPE_P (type) && TREE_CODE (op) == INTEGER_CST)\n \t  {\n \t    if (integer_zerop (op))\n \t      {\n@@ -5499,7 +5499,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t may change to something more specific to type-punning (DR 1312).  */\n       {\n         tree from = TREE_OPERAND (t, 0);\n-\tif (POINTER_TYPE_P (TREE_TYPE (t))\n+\tif (INDIRECT_TYPE_P (TREE_TYPE (t))\n \t    && TREE_CODE (from) == INTEGER_CST\n \t    && !integer_zerop (from))\n \t  {"}, {"sha": "b4e23e26b862aa65a46108a65b58fd63362a6b55", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -783,7 +783,7 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t{\n \t  /* If flag_strong_eval_order, evaluate the object argument first.  */\n \t  tree fntype = TREE_TYPE (CALL_EXPR_FN (*expr_p));\n-\t  if (POINTER_TYPE_P (fntype))\n+\t  if (INDIRECT_TYPE_P (fntype))\n \t    fntype = TREE_TYPE (fntype);\n \t  if (TREE_CODE (fntype) == METHOD_TYPE)\n \t    {\n@@ -1499,7 +1499,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t  tree fn = CALL_EXPR_FN (stmt);\n \t  if (fn != NULL_TREE\n \t      && !error_operand_p (fn)\n-\t      && POINTER_TYPE_P (TREE_TYPE (fn))\n+\t      && INDIRECT_TYPE_P (TREE_TYPE (fn))\n \t      && TREE_CODE (TREE_TYPE (TREE_TYPE (fn))) == METHOD_TYPE)\n \t    {\n \t      bool is_ctor"}, {"sha": "eef7ed60519db777dd69571f64ad4e30d50cfec3", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -37,7 +37,7 @@ cxx_get_alias_set (tree t)\n \n   /* Punt on PMFs until we canonicalize functions properly.  */\n   if (TYPE_PTRMEMFUNC_P (t)\n-      || (POINTER_TYPE_P (t)\n+      || (INDIRECT_TYPE_P (t)\n \t  && TYPE_PTRMEMFUNC_P (TREE_TYPE (t))))\n     return 0;\n "}, {"sha": "e18480b28058a8a18440ce69861fec18a34dced9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -4237,6 +4237,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define TYPE_REF_P(NODE)\t\t\t\\\n   (TREE_CODE (NODE) == REFERENCE_TYPE)\n \n+/* Returns true if NODE is a pointer or a reference.  */\n+#define INDIRECT_TYPE_P(NODE)\t\t\t\\\n+  (TYPE_PTR_P (NODE) || TYPE_REF_P (NODE))\n+\n /* Returns true if NODE is an object type:\n \n      [basic.types]"}, {"sha": "0c02db48e47bc66ba8ee0c80c95e9d7cbd13c74c", "filename": "gcc/cp/cp-ubsan.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcp-ubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcp-ubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-ubsan.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -121,7 +121,7 @@ cp_ubsan_maybe_instrument_member_call (tree stmt)\n   tree *opp = &CALL_EXPR_ARG (stmt, 0);\n   tree op = *opp;\n   if (op == error_mark_node\n-      || !POINTER_TYPE_P (TREE_TYPE (op)))\n+      || !INDIRECT_TYPE_P (TREE_TYPE (op)))\n     return;\n   while (TREE_CODE (op) == COMPOUND_EXPR)\n     {\n@@ -257,9 +257,9 @@ tree\n cp_ubsan_maybe_instrument_downcast (location_t loc, tree type,\n \t\t\t\t    tree intype, tree op)\n {\n-  if (!POINTER_TYPE_P (type)\n-      || !POINTER_TYPE_P (intype)\n-      || !POINTER_TYPE_P (TREE_TYPE (op))\n+  if (!INDIRECT_TYPE_P (type)\n+      || !INDIRECT_TYPE_P (intype)\n+      || !INDIRECT_TYPE_P (TREE_TYPE (op))\n       || !CLASS_TYPE_P (TREE_TYPE (TREE_TYPE (op)))\n       || !is_properly_derived_from (TREE_TYPE (type), TREE_TYPE (intype)))\n     return NULL_TREE;"}, {"sha": "f29dacd685e89c7c137dd162b43f5ab69bd4b511", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -122,7 +122,7 @@ cp_convert_to_pointer (tree type, tree expr, bool dofold,\n \n   form = TREE_CODE (intype);\n \n-  if (POINTER_TYPE_P (intype))\n+  if (INDIRECT_TYPE_P (intype))\n     {\n       intype = TYPE_MAIN_VARIANT (intype);\n \n@@ -842,7 +842,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n       /* Ignore any integer overflow caused by the conversion.  */\n       return ignore_overflows (converted, e);\n     }\n-  if (POINTER_TYPE_P (type) || TYPE_PTRMEM_P (type))\n+  if (INDIRECT_TYPE_P (type) || TYPE_PTRMEM_P (type))\n     return cp_convert_to_pointer (type, e, dofold, complain);\n   if (code == VECTOR_TYPE)\n     {\n@@ -962,7 +962,7 @@ cp_get_fndecl_from_callee (tree fn, bool fold /* = true */)\n   tree type = TREE_TYPE (fn);\n   if (type == unknown_type_node)\n     return NULL_TREE;\n-  gcc_assert (POINTER_TYPE_P (type));\n+  gcc_assert (INDIRECT_TYPE_P (type));\n   if (fold)\n     fn = maybe_constant_init (fn);\n   STRIP_NOPS (fn);\n@@ -1009,7 +1009,7 @@ maybe_warn_nodiscard (tree expr, impl_conv_void implicit)\n   tree type = TREE_TYPE (callee);\n   if (TYPE_PTRMEMFUNC_P (type))\n     type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-  if (POINTER_TYPE_P (type))\n+  if (INDIRECT_TYPE_P (type))\n     type = TREE_TYPE (type);\n \n   tree rettype = TREE_TYPE (type);\n@@ -1602,7 +1602,7 @@ convert (tree type, tree expr)\n \n   intype = TREE_TYPE (expr);\n \n-  if (POINTER_TYPE_P (type) && POINTER_TYPE_P (intype))\n+  if (INDIRECT_TYPE_P (type) && INDIRECT_TYPE_P (intype))\n     return build_nop (type, expr);\n \n   return ocp_convert (type, expr, CONV_BACKEND_CONVERT,"}, {"sha": "df81aa37ce89965106407943b15a8f0836edf795", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -1702,7 +1702,7 @@ cxx_pretty_printer::abstract_declarator (tree t)\n {\n   if (TYPE_PTRMEM_P (t))\n     pp_cxx_right_paren (this);\n-  else if (POINTER_TYPE_P (t))\n+  else if (INDIRECT_TYPE_P (t))\n     {\n       if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE\n \t  || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n@@ -2395,7 +2395,7 @@ pp_cxx_offsetof_expression_1 (cxx_pretty_printer *pp, tree t)\n     {\n     case ARROW_EXPR:\n       if (TREE_CODE (TREE_OPERAND (t, 0)) == STATIC_CAST_EXPR\n-\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (t, 0))))\n+\t  && INDIRECT_TYPE_P (TREE_TYPE (TREE_OPERAND (t, 0))))\n \t{\n \t  pp->type_id (TREE_TYPE (TREE_TYPE (TREE_OPERAND (t, 0))));\n \t  pp_cxx_separate_with (pp, ',');"}, {"sha": "5d736e7d1ac726b0fdfa7b9b5e7d863912e8ba0f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -12783,7 +12783,7 @@ grokparms (tree parmlist, tree *parms)\n \t    }\n \t  else if (abstract_virtuals_error (decl, type))\n \t    any_error = 1;  /* Seems like a good idea.  */\n-\t  else if (cxx_dialect < cxx17 && POINTER_TYPE_P (type))\n+\t  else if (cxx_dialect < cxx17 && INDIRECT_TYPE_P (type))\n \t    {\n \t      /* Before C++17 DR 393:\n \t\t [dcl.fct]/6, parameter types cannot contain pointers\n@@ -16138,7 +16138,7 @@ static_fn_type (tree memfntype)\n \n   if (TYPE_PTRMEMFUNC_P (memfntype))\n     memfntype = TYPE_PTRMEMFUNC_FN_TYPE (memfntype);\n-  if (POINTER_TYPE_P (memfntype)\n+  if (INDIRECT_TYPE_P (memfntype)\n       || TREE_CODE (memfntype) == FUNCTION_DECL)\n     memfntype = TREE_TYPE (memfntype);\n   if (TREE_CODE (memfntype) == FUNCTION_TYPE)"}, {"sha": "e16e476c28545031e303bb9b68c90c20b740b767", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -1032,7 +1032,7 @@ grokbitfield (const cp_declarator *declarator,\n     return void_type_node;\n \n   if (!INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (value))\n-      && (POINTER_TYPE_P (value)\n+      && (INDIRECT_TYPE_P (value)\n           || !dependent_type_p (TREE_TYPE (value))))\n     {\n       error (\"bit-field %qD with non-integral type\", value);"}, {"sha": "f567c527ec88376eeacf0ab87e6e5a0c1a0b58e3", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -2412,8 +2412,8 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n \ttree optype = TREE_TYPE (op);\n \n \tif (TREE_CODE (ttype) != TREE_CODE (optype)\n-\t    && POINTER_TYPE_P (ttype)\n-\t    && POINTER_TYPE_P (optype)\n+\t    && INDIRECT_TYPE_P (ttype)\n+\t    && INDIRECT_TYPE_P (optype)\n \t    && same_type_p (TREE_TYPE (optype),\n \t\t\t    TREE_TYPE (ttype)))\n \t  {"}, {"sha": "f85ae047cfce8a39e86383916ba1f979f900622c", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -301,7 +301,7 @@ initialize_handler_parm (tree decl, tree exp)\n      adjusted by value from __cxa_begin_catch.  Others are returned by\n      reference.  */\n   init_type = TREE_TYPE (decl);\n-  if (!POINTER_TYPE_P (init_type))\n+  if (!INDIRECT_TYPE_P (init_type))\n     init_type = build_reference_type (init_type);\n \n   /* Since pointers are passed by value, initialize a reference to\n@@ -1024,7 +1024,7 @@ check_noexcept_r (tree *tp, int * /*walk_subtrees*/, void * /*data*/)\n          We could use TREE_NOTHROW (t) for !TREE_PUBLIC fns, though... */\n       tree fn = cp_get_callee (t);\n       tree type = TREE_TYPE (fn);\n-      gcc_assert (POINTER_TYPE_P (type));\n+      gcc_assert (INDIRECT_TYPE_P (type));\n       type = TREE_TYPE (type);\n \n       STRIP_NOPS (fn);"}, {"sha": "3f1e49bae21dcbdf49baa76d78e5b3fd7a55a1d6", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -2600,7 +2600,7 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n     }\n \n   tree opertype = TREE_TYPE (oper);\n-  if ((addr_expr || !POINTER_TYPE_P (opertype))\n+  if ((addr_expr || !INDIRECT_TYPE_P (opertype))\n       && (VAR_P (oper)\n \t  || TREE_CODE (oper) == FIELD_DECL\n \t  || TREE_CODE (oper) == PARM_DECL))"}, {"sha": "9c1b49b4d8e1769144c7d23dab7e8a0539e1076e", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -411,7 +411,7 @@ build_capture_proxy (tree member, tree init)\n \n   type = lambda_proxy_type (object);\n \n-  if (name == this_identifier && !POINTER_TYPE_P (type))\n+  if (name == this_identifier && !INDIRECT_TYPE_P (type))\n     {\n       type = build_pointer_type (type);\n       type = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n@@ -571,7 +571,7 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n \n       if (id == this_identifier && !by_reference_p)\n \t{\n-\t  gcc_assert (POINTER_TYPE_P (type));\n+\t  gcc_assert (INDIRECT_TYPE_P (type));\n \t  type = TREE_TYPE (type);\n \t  initializer = cp_build_fold_indirect_ref (initializer);\n \t}"}, {"sha": "c0220bf1bec5a4726fc955d2e6f7c398cde692c8", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -35348,7 +35348,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t  if (real_decl\n \t      && ((processing_template_decl\n \t\t   && (TREE_TYPE (real_decl) == NULL_TREE\n-\t\t       || !POINTER_TYPE_P (TREE_TYPE (real_decl))))\n+\t\t       || !INDIRECT_TYPE_P (TREE_TYPE (real_decl))))\n \t\t  || CLASS_TYPE_P (TREE_TYPE (real_decl))))\n \t    incr = cp_parser_omp_for_incr (parser, real_decl);\n \t  else"}, {"sha": "cfce9a9db62b21d8c4777a9c0bb7085802cbebac", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -6831,7 +6831,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t\t       \"a variable\", orig_expr, expr);\n \t      return NULL_TREE;\n \t    }\n-\t  if (POINTER_TYPE_P (expr_type))\n+\t  if (INDIRECT_TYPE_P (expr_type))\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"%qE is not a valid template argument for %qT \"\n@@ -19548,7 +19548,7 @@ fn_type_unification (tree fn,\n     {\n       /* We're deducing for a call to the result of a template conversion\n          function.  The parms we really want are in return_type.  */\n-      if (POINTER_TYPE_P (return_type))\n+      if (INDIRECT_TYPE_P (return_type))\n \treturn_type = TREE_TYPE (return_type);\n       parms = TYPE_ARG_TYPES (return_type);\n     }\n@@ -19928,7 +19928,7 @@ uses_deducible_template_parms (tree type)\n   /* T*\n      T&\n      T&&  */\n-  if (POINTER_TYPE_P (type))\n+  if (INDIRECT_TYPE_P (type))\n     return uses_deducible_template_parms (TREE_TYPE (type));\n \n   /* T[integer-constant ]\n@@ -20945,7 +20945,7 @@ check_cv_quals_for_unify (int strict, tree arg, tree parm)\n \t  && (parm_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)))\n \treturn 0;\n \n-      if ((!POINTER_TYPE_P (arg) && TREE_CODE (arg) != TEMPLATE_TYPE_PARM)\n+      if ((!INDIRECT_TYPE_P (arg) && TREE_CODE (arg) != TEMPLATE_TYPE_PARM)\n \t  && (parm_quals & TYPE_QUAL_RESTRICT))\n \treturn 0;\n     }\n@@ -24471,8 +24471,7 @@ dependent_type_p_r (tree type)\n     return (dependent_type_p (TYPE_PTRMEM_CLASS_TYPE (type))\n \t    || dependent_type_p (TYPE_PTRMEM_POINTED_TO_TYPE\n \t\t\t\t\t   (type)));\n-  else if (TYPE_PTR_P (type)\n-\t   || TYPE_REF_P (type))\n+  else if (INDIRECT_TYPE_P (type))\n     return dependent_type_p (TREE_TYPE (type));\n   else if (TREE_CODE (type) == FUNCTION_TYPE\n \t   || TREE_CODE (type) == METHOD_TYPE)"}, {"sha": "e343a15c042488a6c83d63176810bf9ca290a303", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -1868,12 +1868,12 @@ check_final_overrider (tree overrider, tree basefn)\n     /* OK */;\n   else if ((CLASS_TYPE_P (over_return) && CLASS_TYPE_P (base_return))\n \t   || (TREE_CODE (base_return) == TREE_CODE (over_return)\n-\t       && POINTER_TYPE_P (base_return)))\n+\t       && INDIRECT_TYPE_P (base_return)))\n     {\n       /* Potentially covariant.  */\n       unsigned base_quals, over_quals;\n \n-      fail = !POINTER_TYPE_P (base_return);\n+      fail = !INDIRECT_TYPE_P (base_return);\n       if (!fail)\n \t{\n \t  fail = cp_type_quals (base_return) != cp_type_quals (over_return);"}, {"sha": "e00331a3ea4a6c1aa1979f7ecaa08798f93cb56b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -5001,7 +5001,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t      tree type = build_array_type (eltype, index_type);\n \t      tree ptype = build_pointer_type (eltype);\n \t      if (TYPE_REF_P (TREE_TYPE (t))\n-\t\t  && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (t))))\n+\t\t  && INDIRECT_TYPE_P (TREE_TYPE (TREE_TYPE (t))))\n \t\tt = convert_from_reference (t);\n \t      else if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n \t\tt = build_fold_addr_expr (t);\n@@ -5076,7 +5076,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t\t\t\tptrdiff_type_node, t);\n \t  tree ptr = OMP_CLAUSE_DECL (c2);\n \t  ptr = convert_from_reference (ptr);\n-\t  if (!POINTER_TYPE_P (TREE_TYPE (ptr)))\n+\t  if (!INDIRECT_TYPE_P (TREE_TYPE (ptr)))\n \t    ptr = build_fold_addr_expr (ptr);\n \t  t = fold_build2_loc (OMP_CLAUSE_LOCATION (c), MINUS_EXPR,\n \t\t\t       ptrdiff_type_node, t,\n@@ -5088,7 +5088,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t  ptr = OMP_CLAUSE_DECL (c2);\n \t  if (OMP_CLAUSE_MAP_KIND (c2) != GOMP_MAP_FIRSTPRIVATE_POINTER\n \t      && TYPE_REF_P (TREE_TYPE (ptr))\n-\t      && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (ptr))))\n+\t      && INDIRECT_TYPE_P (TREE_TYPE (TREE_TYPE (ptr))))\n \t    {\n \t      tree c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t  OMP_CLAUSE_MAP);\n@@ -6537,7 +6537,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t   && !TYPE_PTR_P (TREE_TYPE (t))\n \t\t   && TREE_CODE (TREE_TYPE (t)) != ARRAY_TYPE\n \t\t   && (!TYPE_REF_P (TREE_TYPE (t))\n-\t\t       || (!POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (t)))\n+\t\t       || (!INDIRECT_TYPE_P (TREE_TYPE (TREE_TYPE (t)))\n \t\t\t   && (TREE_CODE (TREE_TYPE (TREE_TYPE (t)))\n \t\t\t       != ARRAY_TYPE))))\n \t    {\n@@ -6790,7 +6790,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t\t   && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FORCE_DEVICEPTR\n \t\t   && !type_dependent_expression_p (t)\n-\t\t   && !POINTER_TYPE_P (TREE_TYPE (t)))\n+\t\t   && !INDIRECT_TYPE_P (TREE_TYPE (t)))\n \t    {\n \t      error (\"%qD is not a pointer variable\", t);\n \t      remove = true;\n@@ -8283,14 +8283,14 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t    case POSTINCREMENT_EXPR:\n \t      /* c_omp_for_incr_canonicalize_ptr() should have been\n \t\t called to massage things appropriately.  */\n-\t      gcc_assert (!POINTER_TYPE_P (TREE_TYPE (decl)));\n+\t      gcc_assert (!INDIRECT_TYPE_P (TREE_TYPE (decl)));\n \t      OMP_CLAUSE_LINEAR_STEP (c) = build_int_cst (TREE_TYPE (decl), 1);\n \t      break;\n \t    case PREDECREMENT_EXPR:\n \t    case POSTDECREMENT_EXPR:\n \t      /* c_omp_for_incr_canonicalize_ptr() should have been\n \t\t called to massage things appropriately.  */\n-\t      gcc_assert (!POINTER_TYPE_P (TREE_TYPE (decl)));\n+\t      gcc_assert (!INDIRECT_TYPE_P (TREE_TYPE (decl)));\n \t      OMP_CLAUSE_LINEAR_STEP (c)\n \t\t= build_int_cst (TREE_TYPE (decl), -1);\n \t      break;\n@@ -8314,7 +8314,7 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\t  gcc_unreachable ();\n \t\t}\n \t      stept = TREE_TYPE (decl);\n-\t      if (POINTER_TYPE_P (stept))\n+\t      if (INDIRECT_TYPE_P (stept))\n \t\tstept = sizetype;\n \t      step = fold_convert (stept, step);\n \t      if (TREE_CODE (incr) == MINUS_EXPR)"}, {"sha": "9d97816029235f89f5a38b5846b22b6eaf8ef0a5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -1287,7 +1287,7 @@ cp_build_qualified_type_real (tree type,\n   if ((type_quals & TYPE_QUAL_RESTRICT)\n       && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n       && TREE_CODE (type) != TYPENAME_TYPE\n-      && !POINTER_TYPE_P (type))\n+      && !INDIRECT_TYPE_P (type))\n     {\n       bad_quals |= TYPE_QUAL_RESTRICT;\n       type_quals &= ~TYPE_QUAL_RESTRICT;"}, {"sha": "3df043e2ab4a1b3b7f0c41118126d1a3490ead31", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a93b0863650a6ce4d4da8d6ccd0582ac9a6382/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=71a93b0863650a6ce4d4da8d6ccd0582ac9a6382", "patch": "@@ -2363,7 +2363,7 @@ build_class_member_access_expr (cp_expr object, tree member,\n     {\n       if (complain & tf_error)\n \t{\n-\t  if (POINTER_TYPE_P (object_type)\n+\t  if (INDIRECT_TYPE_P (object_type)\n \t      && CLASS_TYPE_P (TREE_TYPE (object_type)))\n \t    error (\"request for member %qD in %qE, which is of pointer \"\n \t\t   \"type %qT (maybe you meant to use %<->%> ?)\",\n@@ -2804,7 +2804,7 @@ finish_class_member_access_expr (cp_expr object, tree name, bool template_p,\n     {\n       if (complain & tf_error)\n \t{\n-\t  if (POINTER_TYPE_P (object_type)\n+\t  if (INDIRECT_TYPE_P (object_type)\n \t      && CLASS_TYPE_P (TREE_TYPE (object_type)))\n \t    error (\"request for member %qD in %qE, which is of pointer \"\n \t\t   \"type %qT (maybe you meant to use %<->%> ?)\",\n@@ -3079,7 +3079,7 @@ build_x_indirect_ref (location_t loc, tree expr, ref_operator errorstring,\n   if (processing_template_decl)\n     {\n       /* Retain the type if we know the operand is a pointer.  */\n-      if (TREE_TYPE (expr) && POINTER_TYPE_P (TREE_TYPE (expr)))\n+      if (TREE_TYPE (expr) && INDIRECT_TYPE_P (TREE_TYPE (expr)))\n \treturn build_min (INDIRECT_REF, TREE_TYPE (TREE_TYPE (expr)), expr);\n       if (type_dependent_expression_p (expr))\n \treturn build_min_nt_loc (loc, INDIRECT_REF, expr);\n@@ -3130,7 +3130,7 @@ cp_build_indirect_ref_1 (tree ptr, ref_operator errorstring,\n \n   type = TREE_TYPE (pointer);\n \n-  if (POINTER_TYPE_P (type))\n+  if (INDIRECT_TYPE_P (type))\n     {\n       /* [expr.unary.op]\n \n@@ -4456,7 +4456,7 @@ cp_build_binary_op (location_t location,\n \t    type0 = TREE_TYPE (type0);\n \t  if (!TYPE_P (type1))\n \t    type1 = TREE_TYPE (type1);\n-\t  if (POINTER_TYPE_P (type0) && same_type_p (TREE_TYPE (type0), type1)\n+\t  if (INDIRECT_TYPE_P (type0) && same_type_p (TREE_TYPE (type0), type1)\n \t      && !(TREE_CODE (first_arg) == PARM_DECL\n \t\t   && DECL_ARRAY_PARAMETER_P (first_arg)\n \t\t   && warn_sizeof_array_argument)\n@@ -7552,7 +7552,7 @@ build_const_cast_1 (tree dst_type, tree expr, tsubst_flags_t complain,\n   if (valid_p)\n     *valid_p = false;\n \n-  if (!POINTER_TYPE_P (dst_type) && !TYPE_PTRDATAMEM_P (dst_type))\n+  if (!INDIRECT_TYPE_P (dst_type) && !TYPE_PTRDATAMEM_P (dst_type))\n     {\n       if (complain & tf_error)\n \terror (\"invalid use of const_cast with type %qT, \""}]}