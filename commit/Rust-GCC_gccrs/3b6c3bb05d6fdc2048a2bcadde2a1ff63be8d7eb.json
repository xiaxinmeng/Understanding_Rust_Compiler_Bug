{"sha": "3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I2YzNiYjA1ZDZmZGMyMDQ4YTJiY2FkZGUyYTFmZjYzYmU4ZDdlYg==", "commit": {"author": {"name": "James E Wilson", "email": "wilson@specifixinc.com", "date": "2003-10-30T01:40:48Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2003-10-30T01:40:48Z"}, "message": "Fix problem noticed by Dale Johannesen on the gcc list.\n\n\t* recog.c (asm_operand_ok): Add missing break after case 'X'.\n\tChange if statements to else if statements in default case.\n\t(extract_constrain_insn_cached): Fix misspelling of constrain_operands\n\tin comment.\n\t(constrain_operands_cached): Likewise.\n\t(constrain_operands): Change if statements to else if statements in\n\tdefault case.\n\t* reload.c (find_reloads): Likewise.\n\nFrom-SVN: r73074", "tree": {"sha": "c85ad91a8707ad90462a57b45f9304237ec4d72f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c85ad91a8707ad90462a57b45f9304237ec4d72f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb/comments", "author": null, "committer": null, "parents": [{"sha": "a126dc3a79761cf5f38bdb84cae67e6c47420105", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a126dc3a79761cf5f38bdb84cae67e6c47420105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a126dc3a79761cf5f38bdb84cae67e6c47420105"}], "stats": {"total": 88, "additions": 45, "deletions": 43}, "files": [{"sha": "6d6b39f4493c78dc4ba14b6bab2e1435d1e4dd87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb", "patch": "@@ -1,3 +1,14 @@\n+2003-10-29  James E Wilson  <wilson@specifixinc.com>\n+\n+\t* recog.c (asm_operand_ok): Add missing break after case 'X'.\n+\tChange if statements to else if statements in default case.\n+\t(extract_constrain_insn_cached): Fix misspelling of constrain_operands\n+\tin comment.\n+\t(constrain_operands_cached): Likewise.\n+\t(constrain_operands): Change if statements to else if statements in\n+\tdefault case.\n+\t* reload.c (find_reloads): Likewise.\n+\n 2003-10-29  Richard Henderson  <rth@redhat.com>\n \n \t* config/m68k/m68k.c (notice_update_cc): Clear cc status for"}, {"sha": "3c67bd85193109ebd73781e694f8e14aa9dc5413", "filename": "gcc/recog.c", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb", "patch": "@@ -1746,6 +1746,7 @@ asm_operand_ok (rtx op, const char *constraint)\n \n \tcase 'X':\n \t  result = 1;\n+\t  break;\n \n \tcase 'g':\n \t  if (general_operand (op, VOIDmode))\n@@ -1764,20 +1765,16 @@ asm_operand_ok (rtx op, const char *constraint)\n \t\tresult = 1;\n \t    }\n #ifdef EXTRA_CONSTRAINT_STR\n-\t  if (EXTRA_CONSTRAINT_STR (op, c, constraint))\n+\t  else if (EXTRA_CONSTRAINT_STR (op, c, constraint))\n+\t    result = 1;\n+\t  else if (EXTRA_MEMORY_CONSTRAINT (c, constraint)\n+\t\t   /* Every memory operand can be reloaded to fit.  */\n+\t\t   && memory_operand (op, VOIDmode))\n+\t    result = 1;\n+\t  else if (EXTRA_ADDRESS_CONSTRAINT (c, constraint)\n+\t\t   /* Every address operand can be reloaded to fit.  */\n+\t\t   && address_operand (op, VOIDmode))\n \t    result = 1;\n-\t  if (EXTRA_MEMORY_CONSTRAINT (c, constraint))\n-\t    {\n-\t      /* Every memory operand can be reloaded to fit.  */\n-\t      if (memory_operand (op, VOIDmode))\n-\t        result = 1;\n-\t    }\n-\t  if (EXTRA_ADDRESS_CONSTRAINT (c, constraint))\n-\t    {\n-\t      /* Every address operand can be reloaded to fit.  */\n-\t      if (address_operand (op, VOIDmode))\n-\t        result = 1;\n-\t    }\n #endif\n \t  break;\n \t}\n@@ -1970,7 +1967,7 @@ extract_insn_cached (rtx insn)\n   extract_insn (insn);\n   recog_data.insn = insn;\n }\n-/* Do cached extract_insn, constrain_operand and complain about failures.\n+/* Do cached extract_insn, constrain_operands and complain about failures.\n    Used by insn_attrtab.  */\n void\n extract_constrain_insn_cached (rtx insn)\n@@ -1980,7 +1977,7 @@ extract_constrain_insn_cached (rtx insn)\n       && !constrain_operands (reload_completed))\n     fatal_insn_not_found (insn);\n }\n-/* Do cached constrain_operand and complain about failures.  */\n+/* Do cached constrain_operands and complain about failures.  */\n int\n constrain_operands_cached (int strict)\n {\n@@ -2535,27 +2532,20 @@ constrain_operands (int strict)\n \t\t  else if (EXTRA_CONSTRAINT_STR (op, c, p))\n \t\t    win = 1;\n \n-\t\t  if (EXTRA_MEMORY_CONSTRAINT (c, p))\n-\t\t    {\n-\t\t      /* Every memory operand can be reloaded to fit.  */\n-\t\t      if (strict < 0 && GET_CODE (op) == MEM)\n-\t\t\twin = 1;\n-\n-\t\t      /* Before reload, accept what reload can turn into mem.  */\n-\t\t      if (strict < 0 && CONSTANT_P (op))\n-\t\t\twin = 1;\n-\n-\t\t      /* During reload, accept a pseudo  */\n-\t\t      if (reload_in_progress && GET_CODE (op) == REG\n-\t\t\t  && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-\t\t\twin = 1;\n-\t\t    }\n-\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n-\t\t    {\n-\t\t      /* Every address operand can be reloaded to fit.  */\n-\t\t      if (strict < 0)\n-\t\t        win = 1;\n-\t\t    }\n+\t\t  else if (EXTRA_MEMORY_CONSTRAINT (c, p)\n+\t\t\t   /* Every memory operand can be reloaded to fit.  */\n+\t\t\t   && ((strict < 0 && GET_CODE (op) == MEM)\n+\t\t\t       /* Before reload, accept what reload can turn\n+\t\t\t\t  into mem.  */\n+\t\t\t       || (strict < 0 && CONSTANT_P (op))\n+\t\t\t       /* During reload, accept a pseudo  */\n+\t\t\t       || (reload_in_progress && GET_CODE (op) == REG\n+\t\t\t\t   && REGNO (op) >= FIRST_PSEUDO_REGISTER)))\n+\t\t    win = 1;\n+\t\t  else if (EXTRA_ADDRESS_CONSTRAINT (c, p)\n+\t\t\t   /* Every address operand can be reloaded to fit.  */\n+\t\t\t   && strict < 0)\n+\t\t    win = 1;\n #endif\n \t\t  break;\n \t\t}"}, {"sha": "06bb3fb15bc54d2f904c36ef535ab4bda066a57b", "filename": "gcc/reload.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=3b6c3bb05d6fdc2048a2bcadde2a1ff63be8d7eb", "patch": "@@ -3264,17 +3264,18 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t          win = 1;\n \t\t\t/* If the address was already reloaded,\n \t\t\t   we win as well.  */\n-\t\t\tif (GET_CODE (operand) == MEM && address_reloaded[i])\n+\t\t\telse if (GET_CODE (operand) == MEM\n+\t\t\t\t && address_reloaded[i])\n \t\t\t  win = 1;\n \t\t\t/* Likewise if the address will be reloaded because\n \t\t\t   reg_equiv_address is nonzero.  For reg_equiv_mem\n \t\t\t   we have to check.  */\n-\t\t        if (GET_CODE (operand) == REG\n-\t\t\t    && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n-\t\t\t    && reg_renumber[REGNO (operand)] < 0\n-\t\t\t    && ((reg_equiv_mem[REGNO (operand)] != 0\n-\t\t\t         && EXTRA_CONSTRAINT_STR (reg_equiv_mem[REGNO (operand)], c, p))\n-\t\t\t        || (reg_equiv_address[REGNO (operand)] != 0)))\n+\t\t        else if (GET_CODE (operand) == REG\n+\t\t\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t\t\t && reg_renumber[REGNO (operand)] < 0\n+\t\t\t\t && ((reg_equiv_mem[REGNO (operand)] != 0\n+\t\t\t\t      && EXTRA_CONSTRAINT_STR (reg_equiv_mem[REGNO (operand)], c, p))\n+\t\t\t\t     || (reg_equiv_address[REGNO (operand)] != 0)))\n \t\t\t  win = 1;\n \n \t\t\t/* If we didn't already win, we can reload"}]}