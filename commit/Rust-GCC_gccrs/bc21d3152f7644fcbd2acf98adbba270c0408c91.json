{"sha": "bc21d3152f7644fcbd2acf98adbba270c0408c91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMyMWQzMTUyZjc2NDRmY2JkMmFjZjk4YWRiYmEyNzBjMDQwOGM5MQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-08-13T19:46:46Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-08-13T19:46:46Z"}, "message": "re PR fortran/40941 (gfc_typespec: put derived and cl into union)\n\n2009-08-13  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/40941\n\t* gfortran.h (gfc_typespec): Put 'derived' and 'cl' into union.\n\t* decl.c (build_struct): Make sure 'cl' is only used\n\tif type is BT_CHARACTER.\n\t* symbol.c (gfc_set_default_type): Ditto.\n\t* resolve.c (resolve_symbol, resolve_fl_derived): Ditto.\n\t(resolve_equivalence,resolve_equivalence_derived): Make sure 'derived'\n\tis only used if type is BT_DERIVED.\n\t* trans-io.c (transfer_expr): Make sure 'derived' is only used if type\n\tis BT_DERIVED or BT_INTEGER (special case: C_PTR/C_FUNPTR).\n\t* array.c: Mechanical replacements to accomodate union in gfc_typespec.\n\t* check.c: Ditto.\n\t* data.c: Ditto.\n\t* decl.c: Ditto.\n\t* dump-parse-tree.c: Ditto.\n\t* expr.c: Ditto.\n\t* interface.c: Ditto.\n\t* iresolve.c: Ditto.\n\t* match.c: Ditto.\n\t* misc.c: Ditto.\n\t* module.c: Ditto.\n\t* openmp.c: Ditto.\n\t* parse.c: Ditto.\n\t* primary.c: Ditto.\n\t* resolve.c: Ditto.\n\t* simplify.c: Ditto.\n\t* symbol.c: Ditto.\n\t* target-memory.c: Ditto.\n\t* trans-array.c: Ditto.\n\t* trans-common.c: Ditto.\n\t* trans-const.c: Ditto.\n\t* trans-decl.c: Ditto.\n\t* trans-expr.c: Ditto.\n\t* trans-intrinsic.c: Ditto.\n\t* trans-io.c: Ditto.\n\t* trans-stmt.c: Ditto.\n\t* trans-types.c: Ditto.\n\nFrom-SVN: r150725", "tree": {"sha": "7ca7b016aeb3b05df501fe81fe97a0e52abdc7b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ca7b016aeb3b05df501fe81fe97a0e52abdc7b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc21d3152f7644fcbd2acf98adbba270c0408c91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc21d3152f7644fcbd2acf98adbba270c0408c91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc21d3152f7644fcbd2acf98adbba270c0408c91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc21d3152f7644fcbd2acf98adbba270c0408c91/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f100a4a841e1247f0ea73c93368306fb86f12954", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f100a4a841e1247f0ea73c93368306fb86f12954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f100a4a841e1247f0ea73c93368306fb86f12954"}], "stats": {"total": 1501, "additions": 773, "deletions": 728}, "files": [{"sha": "f48729e34b270ae9f41fa879ad17e7b22ffcd068", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -1,3 +1,43 @@\n+2009-08-13  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/40941\n+\t* gfortran.h (gfc_typespec): Put 'derived' and 'cl' into union.\n+\t* decl.c (build_struct): Make sure 'cl' is only used\n+\tif type is BT_CHARACTER.\n+\t* symbol.c (gfc_set_default_type): Ditto.\n+\t* resolve.c (resolve_symbol, resolve_fl_derived): Ditto.\n+\t(resolve_equivalence,resolve_equivalence_derived): Make sure 'derived'\n+\tis only used if type is BT_DERIVED.\n+\t* trans-io.c (transfer_expr): Make sure 'derived' is only used if type\n+\tis BT_DERIVED or BT_INTEGER (special case: C_PTR/C_FUNPTR).\n+\t* array.c: Mechanical replacements to accomodate union in gfc_typespec.\n+\t* check.c: Ditto.\n+\t* data.c: Ditto.\n+\t* decl.c: Ditto.\n+\t* dump-parse-tree.c: Ditto.\n+\t* expr.c: Ditto.\n+\t* interface.c: Ditto.\n+\t* iresolve.c: Ditto.\n+\t* match.c: Ditto.\n+\t* misc.c: Ditto.\n+\t* module.c: Ditto.\n+\t* openmp.c: Ditto.\n+\t* parse.c: Ditto.\n+\t* primary.c: Ditto.\n+\t* resolve.c: Ditto.\n+\t* simplify.c: Ditto.\n+\t* symbol.c: Ditto.\n+\t* target-memory.c: Ditto.\n+\t* trans-array.c: Ditto.\n+\t* trans-common.c: Ditto.\n+\t* trans-const.c: Ditto.\n+\t* trans-decl.c: Ditto.\n+\t* trans-expr.c: Ditto.\n+\t* trans-intrinsic.c: Ditto.\n+\t* trans-io.c: Ditto.\n+\t* trans-stmt.c: Ditto.\n+\t* trans-types.c: Ditto.\n+\n 2009-08-13  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/40995"}, {"sha": "2e12a146ae0a8d19dc642ff22c9b5810ea43c949", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -968,8 +968,8 @@ gfc_match_array_constructor (gfc_expr **result)\n   else\n     expr->ts.type = BT_UNKNOWN;\n   \n-  if (expr->ts.cl)\n-    expr->ts.cl->length_from_typespec = seen_ts;\n+  if (expr->ts.u.cl)\n+    expr->ts.u.cl->length_from_typespec = seen_ts;\n \n   expr->where = where;\n   expr->rank = 1;\n@@ -1588,25 +1588,25 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n   gcc_assert (expr->expr_type == EXPR_ARRAY);\n   gcc_assert (expr->ts.type == BT_CHARACTER);\n \n-  if (expr->ts.cl == NULL)\n+  if (expr->ts.u.cl == NULL)\n     {\n       for (p = expr->value.constructor; p; p = p->next)\n-\tif (p->expr->ts.cl != NULL)\n+\tif (p->expr->ts.u.cl != NULL)\n \t  {\n \t    /* Ensure that if there is a char_len around that it is\n \t       used; otherwise the middle-end confuses them!  */\n-\t    expr->ts.cl = p->expr->ts.cl;\n+\t    expr->ts.u.cl = p->expr->ts.u.cl;\n \t    goto got_charlen;\n \t  }\n \n-      expr->ts.cl = gfc_new_charlen (gfc_current_ns);\n+      expr->ts.u.cl = gfc_new_charlen (gfc_current_ns);\n     }\n \n got_charlen:\n \n   found_length = -1;\n \n-  if (expr->ts.cl->length == NULL)\n+  if (expr->ts.u.cl->length == NULL)\n     {\n       /* Check that all constant string elements have the same length until\n \t we reach the end or find a variable-length one.  */\n@@ -1630,11 +1630,11 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n \t\t- mpz_get_ui (ref->u.ss.start->value.integer) + 1;\n \t      current_length = (int) j;\n \t    }\n-\t  else if (p->expr->ts.cl && p->expr->ts.cl->length\n-\t\t   && p->expr->ts.cl->length->expr_type == EXPR_CONSTANT)\n+\t  else if (p->expr->ts.u.cl && p->expr->ts.u.cl->length\n+\t\t   && p->expr->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n \t    {\n \t      long j;\n-\t      j = mpz_get_si (p->expr->ts.cl->length->value.integer);\n+\t      j = mpz_get_si (p->expr->ts.u.cl->length->value.integer);\n \t      current_length = (int) j;\n \t    }\n \t  else\n@@ -1658,18 +1658,18 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n       gcc_assert (found_length != -1);\n \n       /* Update the character length of the array constructor.  */\n-      expr->ts.cl->length = gfc_int_expr (found_length);\n+      expr->ts.u.cl->length = gfc_int_expr (found_length);\n     }\n   else \n     {\n       /* We've got a character length specified.  It should be an integer,\n \t otherwise an error is signalled elsewhere.  */\n-      gcc_assert (expr->ts.cl->length);\n+      gcc_assert (expr->ts.u.cl->length);\n \n       /* If we've got a constant character length, pad according to this.\n \t gfc_extract_int does check for BT_INTEGER and EXPR_CONSTANT and sets\n \t max_length only if they pass.  */\n-      gfc_extract_int (expr->ts.cl->length, &found_length);\n+      gfc_extract_int (expr->ts.u.cl->length, &found_length);\n \n       /* Now pad/truncate the elements accordingly to the specified character\n \t length.  This is ok inside this conditional, as in the case above\n@@ -1683,16 +1683,16 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n \t      int current_length = -1;\n \t      bool has_ts;\n \n-\t      if (p->expr->ts.cl && p->expr->ts.cl->length)\n+\t      if (p->expr->ts.u.cl && p->expr->ts.u.cl->length)\n \t      {\n-\t\tcl = p->expr->ts.cl->length;\n+\t\tcl = p->expr->ts.u.cl->length;\n \t\tgfc_extract_int (cl, &current_length);\n \t      }\n \n \t      /* If gfc_extract_int above set current_length, we implicitly\n \t\t know the type is BT_INTEGER and it's EXPR_CONSTANT.  */\n \n-\t      has_ts = (expr->ts.cl && expr->ts.cl->length_from_typespec);\n+\t      has_ts = (expr->ts.u.cl && expr->ts.u.cl->length_from_typespec);\n \n \t      if (! cl\n \t\t  || (current_length != -1 && current_length < found_length))"}, {"sha": "6e2ce4102251f085c0e89cc002c3302ab1a8c296", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -410,20 +410,20 @@ gfc_check_same_strlen (const gfc_expr *a, const gfc_expr *b, const char *name)\n    long len_a, len_b;\n    len_a = len_b = -1;\n \n-   if (a->ts.cl && a->ts.cl->length\n-       && a->ts.cl->length->expr_type == EXPR_CONSTANT)\n-     len_a = mpz_get_si (a->ts.cl->length->value.integer);\n+   if (a->ts.u.cl && a->ts.u.cl->length\n+       && a->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n+     len_a = mpz_get_si (a->ts.u.cl->length->value.integer);\n    else if (a->expr_type == EXPR_CONSTANT\n-\t    && (a->ts.cl == NULL || a->ts.cl->length == NULL))\n+\t    && (a->ts.u.cl == NULL || a->ts.u.cl->length == NULL))\n      len_a = a->value.character.length;\n    else\n      return SUCCESS;\n \n-   if (b->ts.cl && b->ts.cl->length\n-       && b->ts.cl->length->expr_type == EXPR_CONSTANT)\n-     len_b = mpz_get_si (b->ts.cl->length->value.integer);\n+   if (b->ts.u.cl && b->ts.u.cl->length\n+       && b->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n+     len_b = mpz_get_si (b->ts.u.cl->length->value.integer);\n    else if (b->expr_type == EXPR_CONSTANT\n-\t    && (b->ts.cl == NULL || b->ts.cl->length == NULL))\n+\t    && (b->ts.u.cl == NULL || b->ts.u.cl->length == NULL))\n      len_b = b->value.character.length;\n    else\n      return SUCCESS;\n@@ -1400,12 +1400,12 @@ gfc_check_ichar_iachar (gfc_expr *c, gfc_expr *kind)\n \t{\n \t  /* Check that the argument is length one.  Non-constant lengths\n \t     can't be checked here, so assume they are ok.  */\n-\t  if (c->ts.cl && c->ts.cl->length)\n+\t  if (c->ts.u.cl && c->ts.u.cl->length)\n \t    {\n \t      /* If we already have a length for this expression then use it.  */\n-\t      if (c->ts.cl->length->expr_type != EXPR_CONSTANT)\n+\t      if (c->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n \t\treturn SUCCESS;\n-\t      i = mpz_get_si (c->ts.cl->length->value.integer);\n+\t      i = mpz_get_si (c->ts.u.cl->length->value.integer);\n \t    }\n \t  else \n \t    return SUCCESS;"}, {"sha": "6cddb3c7b71cd752ff9162a5a34a7404fa749b4e", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -154,7 +154,7 @@ create_character_intializer (gfc_expr *init, gfc_typespec *ts,\n   int len, start, end;\n   gfc_char_t *dest;\n \t    \n-  gfc_extract_int (ts->cl->length, &len);\n+  gfc_extract_int (ts->u.cl->length, &len);\n \n   if (init == NULL)\n     {\n@@ -379,7 +379,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n \t      /* Setup the expression to hold the constructor.  */\n \t      expr->expr_type = EXPR_STRUCTURE;\n \t      expr->ts.type = BT_DERIVED;\n-\t      expr->ts.derived = ref->u.c.sym;\n+\t      expr->ts.u.derived = ref->u.c.sym;\n \t    }\n \t  else\n \t    gcc_assert (expr->expr_type == EXPR_STRUCTURE);\n@@ -417,7 +417,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n \n   if (ref || last_ts->type == BT_CHARACTER)\n     {\n-      if (lvalue->ts.cl->length == NULL && !(ref && ref->u.ss.length != NULL))\n+      if (lvalue->ts.u.cl->length == NULL && !(ref && ref->u.ss.length != NULL))\n \treturn FAILURE;\n       expr = create_character_intializer (init, last_ts, ref, rvalue);\n     }\n@@ -569,7 +569,7 @@ gfc_assign_data_value_range (gfc_expr *lvalue, gfc_expr *rvalue,\n \t      /* Setup the expression to hold the constructor.  */\n \t      expr->expr_type = EXPR_STRUCTURE;\n \t      expr->ts.type = BT_DERIVED;\n-\t      expr->ts.derived = ref->u.c.sym;\n+\t      expr->ts.u.derived = ref->u.c.sym;\n \t    }\n \t  else\n \t    gcc_assert (expr->expr_type == EXPR_STRUCTURE);\n@@ -716,7 +716,7 @@ formalize_structure_cons (gfc_expr *expr)\n     return;\n \n   head = tail = NULL;\n-  for (order = expr->ts.derived->components; order; order = order->next)\n+  for (order = expr->ts.u.derived->components; order; order = order->next)\n     {\n       /* Find the next component.  */\n       last = NULL;"}, {"sha": "b1c15176108119d21cc94977f368d314dc3c1bfb", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 71, "deletions": 70, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -622,8 +622,8 @@ char_len_param_value (gfc_expr **expr)\n \t      if (e->symtree->n.sym->ts.type == BT_UNKNOWN)\n \t\tgoto syntax;\n \t      if (e->symtree->n.sym->ts.type == BT_CHARACTER\n-\t\t  && e->symtree->n.sym->ts.cl\n-\t\t  && e->symtree->n.sym->ts.cl->length->ts.type == BT_UNKNOWN)\n+\t\t  && e->symtree->n.sym->ts.u.cl\n+\t\t  && e->symtree->n.sym->ts.u.cl->length->ts.type == BT_UNKNOWN)\n \t        goto syntax;\n \t    }\n \t}\n@@ -938,7 +938,7 @@ verify_c_interop_param (gfc_symbol *sym)\n \t\t\t   \"because derived type '%s' is not C interoperable\",\n \t\t\t   sym->name, &(sym->declared_at),\n \t\t\t   sym->ns->proc_name->name, \n-\t\t\t   sym->ts.derived->name);\n+\t\t\t   sym->ts.u.derived->name);\n \t      else\n \t\tgfc_warning (\"Variable '%s' at %L is a parameter to the \"\n \t\t\t     \"BIND(C) procedure '%s' but may not be C \"\n@@ -951,7 +951,7 @@ verify_c_interop_param (gfc_symbol *sym)\n              length of 1.  */\n           if (sym->ts.type == BT_CHARACTER)\n \t    {\n-\t      gfc_charlen *cl = sym->ts.cl;\n+\t      gfc_charlen *cl = sym->ts.u.cl;\n \t      if (!cl || !cl->length || cl->length->expr_type != EXPR_CONSTANT\n                   || mpz_cmp_si (cl->length->value.integer, 1) != 0)\n \t\t{\n@@ -1045,7 +1045,7 @@ build_sym (const char *name, gfc_charlen *cl,\n     return FAILURE;\n \n   if (sym->ts.type == BT_CHARACTER)\n-    sym->ts.cl = cl;\n+    sym->ts.u.cl = cl;\n \n   /* Add dimension attribute if present.  */\n   if (gfc_set_array_spec (sym, *as, var_locus) == FAILURE)\n@@ -1253,42 +1253,42 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t  && gfc_check_assign_symbol (sym, init) == FAILURE)\n \treturn FAILURE;\n \n-      if (sym->ts.type == BT_CHARACTER && sym->ts.cl\n+      if (sym->ts.type == BT_CHARACTER && sym->ts.u.cl\n \t    && init->ts.type == BT_CHARACTER)\n \t{\n \t  /* Update symbol character length according initializer.  */\n \t  if (gfc_check_assign_symbol (sym, init) == FAILURE)\n \t    return FAILURE;\n \n-\t  if (sym->ts.cl->length == NULL)\n+\t  if (sym->ts.u.cl->length == NULL)\n \t    {\n \t      int clen;\n \t      /* If there are multiple CHARACTER variables declared on the\n \t\t same line, we don't want them to share the same length.  */\n-\t      sym->ts.cl = gfc_new_charlen (gfc_current_ns);\n+\t      sym->ts.u.cl = gfc_new_charlen (gfc_current_ns);\n \n \t      if (sym->attr.flavor == FL_PARAMETER)\n \t\t{\n \t\t  if (init->expr_type == EXPR_CONSTANT)\n \t\t    {\n \t\t      clen = init->value.character.length;\n-\t\t      sym->ts.cl->length = gfc_int_expr (clen);\n+\t\t      sym->ts.u.cl->length = gfc_int_expr (clen);\n \t\t    }\n \t\t  else if (init->expr_type == EXPR_ARRAY)\n \t\t    {\n \t\t      gfc_expr *p = init->value.constructor->expr;\n \t\t      clen = p->value.character.length;\n-\t\t      sym->ts.cl->length = gfc_int_expr (clen);\n+\t\t      sym->ts.u.cl->length = gfc_int_expr (clen);\n \t\t    }\n-\t\t  else if (init->ts.cl && init->ts.cl->length)\n-\t\t    sym->ts.cl->length =\n-\t\t\t\tgfc_copy_expr (sym->value->ts.cl->length);\n+\t\t  else if (init->ts.u.cl && init->ts.u.cl->length)\n+\t\t    sym->ts.u.cl->length =\n+\t\t\t\tgfc_copy_expr (sym->value->ts.u.cl->length);\n \t\t}\n \t    }\n \t  /* Update initializer character length according symbol.  */\n-\t  else if (sym->ts.cl->length->expr_type == EXPR_CONSTANT)\n+\t  else if (sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n \t    {\n-\t      int len = mpz_get_si (sym->ts.cl->length->value.integer);\n+\t      int len = mpz_get_si (sym->ts.u.cl->length->value.integer);\n \t      gfc_constructor * p;\n \n \t      if (init->expr_type == EXPR_CONSTANT)\n@@ -1297,8 +1297,8 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t\t{\n \t\t  /* Build a new charlen to prevent simplification from\n \t\t     deleting the length before it is resolved.  */\n-\t\t  init->ts.cl = gfc_new_charlen (gfc_current_ns);\n-\t\t  init->ts.cl->length = gfc_copy_expr (sym->ts.cl->length);\n+\t\t  init->ts.u.cl = gfc_new_charlen (gfc_current_ns);\n+\t\t  init->ts.u.cl->length = gfc_copy_expr (sym->ts.u.cl->length);\n \n \t\t  for (p = init->value.constructor; p; p = p->next)\n \t\t    gfc_set_constant_character_len (len, p->expr, -1);\n@@ -1389,7 +1389,7 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n   /* If the current symbol is of the same derived type that we're\n      constructing, it must have the pointer attribute.  */\n   if (current_ts.type == BT_DERIVED\n-      && current_ts.derived == gfc_current_block ()\n+      && current_ts.u.derived == gfc_current_block ()\n       && current_attr.pointer == 0)\n     {\n       gfc_error (\"Component at %C must have the POINTER attribute\");\n@@ -1410,7 +1410,8 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n     return FAILURE;\n \n   c->ts = current_ts;\n-  c->ts.cl = cl;\n+  if (c->ts.type == BT_CHARACTER)\n+    c->ts.u.cl = cl;\n   c->attr = current_attr;\n \n   c->initializer = *init;\n@@ -1423,27 +1424,27 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \n   /* Should this ever get more complicated, combine with similar section\n      in add_init_expr_to_sym into a separate function.  */\n-  if (c->ts.type == BT_CHARACTER && !c->attr.pointer && c->initializer && c->ts.cl\n-      && c->ts.cl->length && c->ts.cl->length->expr_type == EXPR_CONSTANT)\n+  if (c->ts.type == BT_CHARACTER && !c->attr.pointer && c->initializer && c->ts.u.cl\n+      && c->ts.u.cl->length && c->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n     {\n       int len;\n \n-      gcc_assert (c->ts.cl && c->ts.cl->length);\n-      gcc_assert (c->ts.cl->length->expr_type == EXPR_CONSTANT);\n-      gcc_assert (c->ts.cl->length->ts.type == BT_INTEGER);\n+      gcc_assert (c->ts.u.cl && c->ts.u.cl->length);\n+      gcc_assert (c->ts.u.cl->length->expr_type == EXPR_CONSTANT);\n+      gcc_assert (c->ts.u.cl->length->ts.type == BT_INTEGER);\n \n-      len = mpz_get_si (c->ts.cl->length->value.integer);\n+      len = mpz_get_si (c->ts.u.cl->length->value.integer);\n \n       if (c->initializer->expr_type == EXPR_CONSTANT)\n \tgfc_set_constant_character_len (len, c->initializer, -1);\n-      else if (mpz_cmp (c->ts.cl->length->value.integer,\n-\t\t\tc->initializer->ts.cl->length->value.integer))\n+      else if (mpz_cmp (c->ts.u.cl->length->value.integer,\n+\t\t\tc->initializer->ts.u.cl->length->value.integer))\n \t{\n \t  bool has_ts;\n \t  gfc_constructor *ctor = c->initializer->value.constructor;\n \n-\t  has_ts = (c->initializer->ts.cl\n-\t\t    && c->initializer->ts.cl->length_from_typespec);\n+\t  has_ts = (c->initializer->ts.u.cl\n+\t\t    && c->initializer->ts.u.cl->length_from_typespec);\n \n \t  if (ctor)\n \t    {\n@@ -1609,14 +1610,14 @@ variable_decl (int elem)\n \t   element.  Also copy assumed lengths.  */\n \tcase MATCH_NO:\n \t  if (elem > 1\n-\t      && (current_ts.cl->length == NULL\n-\t\t  || current_ts.cl->length->expr_type != EXPR_CONSTANT))\n+\t      && (current_ts.u.cl->length == NULL\n+\t\t  || current_ts.u.cl->length->expr_type != EXPR_CONSTANT))\n \t    {\n \t      cl = gfc_new_charlen (gfc_current_ns);\n-\t      cl->length = gfc_copy_expr (current_ts.cl->length);\n+\t      cl->length = gfc_copy_expr (current_ts.u.cl->length);\n \t    }\n \t  else\n-\t    cl = current_ts.cl;\n+\t    cl = current_ts.u.cl;\n \n \t  break;\n \n@@ -1634,8 +1635,8 @@ variable_decl (int elem)\n \t{\n \t  sym->ts.type = current_ts.type;\n \t  sym->ts.kind = current_ts.kind;\n-\t  sym->ts.cl = cl;\n-\t  sym->ts.derived = current_ts.derived;\n+\t  sym->ts.u.cl = cl;\n+\t  sym->ts.u.derived = current_ts.u.derived;\n \t  sym->ts.is_c_interop = current_ts.is_c_interop;\n \t  sym->ts.is_iso_c = current_ts.is_iso_c;\n \t  m = MATCH_YES;\n@@ -1707,13 +1708,13 @@ variable_decl (int elem)\n   if (current_ts.type == BT_DERIVED\n       && gfc_current_ns->proc_name\n       && gfc_current_ns->proc_name->attr.if_source == IFSRC_IFBODY\n-      && current_ts.derived->ns != gfc_current_ns)\n+      && current_ts.u.derived->ns != gfc_current_ns)\n     {\n       gfc_symtree *st;\n-      st = gfc_find_symtree (gfc_current_ns->sym_root, current_ts.derived->name);\n-      if (!(current_ts.derived->attr.imported\n+      st = gfc_find_symtree (gfc_current_ns->sym_root, current_ts.u.derived->name);\n+      if (!(current_ts.u.derived->attr.imported\n \t\t&& st != NULL\n-\t\t&& st->n.sym == current_ts.derived)\n+\t\t&& st->n.sym == current_ts.u.derived)\n \t    && !gfc_current_ns->has_import_set)\n \t{\n \t    gfc_error (\"the type of '%s' at %C has not been declared within the \"\n@@ -2241,7 +2242,7 @@ match_char_spec (gfc_typespec *ts)\n   else\n     cl->length = len;\n \n-  ts->cl = cl;\n+  ts->u.cl = cl;\n   ts->kind = kind == 0 ? gfc_default_character_kind : kind;\n \n   /* We have to know if it was a c interoperable kind so we can\n@@ -2387,10 +2388,10 @@ gfc_match_type_spec (gfc_typespec *ts, int implicit_flag)\n      found, add it to the typespec.  */  \n   if (gfc_matching_function)\n     {\n-      ts->derived = NULL;\n+      ts->u.derived = NULL;\n       if (gfc_current_state () != COMP_INTERFACE\n \t    && !gfc_find_symbol (name, NULL, 1, &sym) && sym)\n-\tts->derived = sym;\n+\tts->u.derived = sym;\n       return MATCH_YES;\n     }\n \n@@ -2423,7 +2424,7 @@ gfc_match_type_spec (gfc_typespec *ts, int implicit_flag)\n     return MATCH_ERROR;\n \n   gfc_set_sym_referenced (sym);\n-  ts->derived = sym;\n+  ts->u.derived = sym;\n \n   return MATCH_YES;\n \n@@ -2614,11 +2615,11 @@ gfc_match_implicit (void)\n \t  if ((c == '\\n') || (c == ','))\n \t    {\n \t      /* Check for CHARACTER with no length parameter.  */\n-\t      if (ts.type == BT_CHARACTER && !ts.cl)\n+\t      if (ts.type == BT_CHARACTER && !ts.u.cl)\n \t\t{\n \t\t  ts.kind = gfc_default_character_kind;\n-\t\t  ts.cl = gfc_new_charlen (gfc_current_ns);\n-\t\t  ts.cl->length = gfc_int_expr (1);\n+\t\t  ts.u.cl = gfc_new_charlen (gfc_current_ns);\n+\t\t  ts.u.cl->length = gfc_int_expr (1);\n \t\t}\n \n \t      /* Record the Successful match.  */\n@@ -3330,8 +3331,8 @@ set_com_block_bind_c (gfc_common_head *com_block, int is_bind_c)\n gfc_try\n verify_c_interop (gfc_typespec *ts)\n {\n-  if (ts->type == BT_DERIVED && ts->derived != NULL)\n-    return (ts->derived->ts.is_c_interop ? SUCCESS : FAILURE);\n+  if (ts->type == BT_DERIVED && ts->u.derived != NULL)\n+    return (ts->u.derived->ts.is_c_interop ? SUCCESS : FAILURE);\n   else if (ts->is_c_interop != 1)\n     return FAILURE;\n   \n@@ -3473,9 +3474,9 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n \n       /* BIND(C) functions can not return a character string.  */\n       if (bind_c_function && tmp_sym->ts.type == BT_CHARACTER)\n-\tif (tmp_sym->ts.cl == NULL || tmp_sym->ts.cl->length == NULL\n-\t    || tmp_sym->ts.cl->length->expr_type != EXPR_CONSTANT\n-\t    || mpz_cmp_si (tmp_sym->ts.cl->length->value.integer, 1) != 0)\n+\tif (tmp_sym->ts.u.cl == NULL || tmp_sym->ts.u.cl->length == NULL\n+\t    || tmp_sym->ts.u.cl->length->expr_type != EXPR_CONSTANT\n+\t    || mpz_cmp_si (tmp_sym->ts.u.cl->length->value.integer, 1) != 0)\n \t  gfc_error (\"Return type of BIND(C) function '%s' at %L cannot \"\n \t\t\t \"be a character string\", tmp_sym->name,\n \t\t\t &(tmp_sym->declared_at));\n@@ -3679,15 +3680,15 @@ gfc_match_data_decl (void)\n \n   if (current_ts.type == BT_DERIVED && gfc_current_state () != COMP_DERIVED)\n     {\n-      sym = gfc_use_derived (current_ts.derived);\n+      sym = gfc_use_derived (current_ts.u.derived);\n \n       if (sym == NULL)\n \t{\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n \t}\n \n-      current_ts.derived = sym;\n+      current_ts.u.derived = sym;\n     }\n \n   m = match_attr_spec ();\n@@ -3697,21 +3698,21 @@ gfc_match_data_decl (void)\n       goto cleanup;\n     }\n \n-  if (current_ts.type == BT_DERIVED && current_ts.derived->components == NULL\n-      && !current_ts.derived->attr.zero_comp)\n+  if (current_ts.type == BT_DERIVED && current_ts.u.derived->components == NULL\n+      && !current_ts.u.derived->attr.zero_comp)\n     {\n \n       if (current_attr.pointer && gfc_current_state () == COMP_DERIVED)\n \tgoto ok;\n \n-      gfc_find_symbol (current_ts.derived->name,\n-\t\t       current_ts.derived->ns->parent, 1, &sym);\n+      gfc_find_symbol (current_ts.u.derived->name,\n+\t\t       current_ts.u.derived->ns->parent, 1, &sym);\n \n       /* Any symbol that we find had better be a type definition\n \t which has its components defined.  */\n       if (sym != NULL && sym->attr.flavor == FL_DERIVED\n-\t  && (current_ts.derived->components != NULL\n-\t      || current_ts.derived->attr.zero_comp))\n+\t  && (current_ts.u.derived->components != NULL\n+\t      || current_ts.u.derived->attr.zero_comp))\n \tgoto ok;\n \n       /* Now we have an error, which we signal, and then fix up\n@@ -6202,30 +6203,30 @@ do_parm (void)\n     }\n \n   if (sym->ts.type == BT_CHARACTER\n-      && sym->ts.cl != NULL\n-      && sym->ts.cl->length != NULL\n-      && sym->ts.cl->length->expr_type == EXPR_CONSTANT\n+      && sym->ts.u.cl != NULL\n+      && sym->ts.u.cl->length != NULL\n+      && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT\n       && init->expr_type == EXPR_CONSTANT\n       && init->ts.type == BT_CHARACTER)\n     gfc_set_constant_character_len (\n-      mpz_get_si (sym->ts.cl->length->value.integer), init, -1);\n-  else if (sym->ts.type == BT_CHARACTER && sym->ts.cl != NULL\n-\t   && sym->ts.cl->length == NULL)\n+      mpz_get_si (sym->ts.u.cl->length->value.integer), init, -1);\n+  else if (sym->ts.type == BT_CHARACTER && sym->ts.u.cl != NULL\n+\t   && sym->ts.u.cl->length == NULL)\n \t{\n \t  int clen;\n \t  if (init->expr_type == EXPR_CONSTANT)\n \t    {\n \t      clen = init->value.character.length;\n-\t      sym->ts.cl->length = gfc_int_expr (clen);\n+\t      sym->ts.u.cl->length = gfc_int_expr (clen);\n \t    }\n \t  else if (init->expr_type == EXPR_ARRAY)\n \t    {\n \t      gfc_expr *p = init->value.constructor->expr;\n \t      clen = p->value.character.length;\n-\t      sym->ts.cl->length = gfc_int_expr (clen);\n+\t      sym->ts.u.cl->length = gfc_int_expr (clen);\n \t    }\n-\t  else if (init->ts.cl && init->ts.cl->length)\n-\t    sym->ts.cl->length = gfc_copy_expr (sym->value->ts.cl->length);\n+\t  else if (init->ts.u.cl && init->ts.u.cl->length)\n+\t    sym->ts.u.cl->length = gfc_copy_expr (sym->value->ts.u.cl->length);\n \t}\n \n   sym->value = init;\n@@ -6762,7 +6763,7 @@ gfc_match_derived_decl (void)\n       gfc_set_sym_referenced (extended);\n \n       p->ts.type = BT_DERIVED;\n-      p->ts.derived = extended;\n+      p->ts.u.derived = extended;\n       p->initializer = gfc_default_initializer (&p->ts);\n \n       /* Provide the links between the extended type and its extension.  */"}, {"sha": "5802cdc8a7caf40362962de24dad231fd0dbd7d7", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -85,11 +85,11 @@ show_typespec (gfc_typespec *ts)\n   switch (ts->type)\n     {\n     case BT_DERIVED:\n-      fprintf (dumpfile, \"%s\", ts->derived->name);\n+      fprintf (dumpfile, \"%s\", ts->u.derived->name);\n       break;\n \n     case BT_CHARACTER:\n-      show_expr (ts->cl->length);\n+      show_expr (ts->u.cl->length);\n       break;\n \n     default:\n@@ -354,7 +354,7 @@ show_expr (gfc_expr *p)\n       break;\n \n     case EXPR_STRUCTURE:\n-      fprintf (dumpfile, \"%s(\", p->ts.derived->name);\n+      fprintf (dumpfile, \"%s(\", p->ts.u.derived->name);\n       show_constructor (p->value.constructor);\n       fputc (')', dumpfile);\n       break;"}, {"sha": "85c0cea644c04da04be64ebc2485afe7066e4898", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -1504,14 +1504,14 @@ simplify_const_ref (gfc_expr *p)\n \t\t      else\n \t\t\tstring_len = 0;\n \n-\t\t      if (!p->ts.cl)\n+\t\t      if (!p->ts.u.cl)\n \t\t\t{\n-\t\t\t  p->ts.cl = gfc_get_charlen ();\n-\t\t\t  p->ts.cl->next = NULL;\n-\t\t\t  p->ts.cl->length = NULL;\n+\t\t\t  p->ts.u.cl = gfc_get_charlen ();\n+\t\t\t  p->ts.u.cl->next = NULL;\n+\t\t\t  p->ts.u.cl->length = NULL;\n \t\t\t}\n-\t\t      gfc_free_expr (p->ts.cl->length);\n-\t\t      p->ts.cl->length = gfc_int_expr (string_len);\n+\t\t      gfc_free_expr (p->ts.u.cl->length);\n+\t\t      p->ts.u.cl->length = gfc_int_expr (string_len);\n \t\t    }\n \t\t}\n \t      gfc_free_ref_list (p->ref);\n@@ -1681,8 +1681,8 @@ gfc_simplify_expr (gfc_expr *p, int type)\n \t  gfc_free (p->value.character.string);\n \t  p->value.character.string = s;\n \t  p->value.character.length = end - start;\n-\t  p->ts.cl = gfc_new_charlen (gfc_current_ns);\n-\t  p->ts.cl->length = gfc_int_expr (p->value.character.length);\n+\t  p->ts.u.cl = gfc_new_charlen (gfc_current_ns);\n+\t  p->ts.u.cl->length = gfc_int_expr (p->value.character.length);\n \t  gfc_free_ref_list (p->ref);\n \t  p->ref = NULL;\n \t  p->expr_type = EXPR_CONSTANT;\n@@ -2102,7 +2102,7 @@ check_inquiry (gfc_expr *e, int not_restricted)\n \t   with LEN, as required by the standard.  */\n \tif (i == 5 && not_restricted\n \t    && ap->expr->symtree->n.sym->ts.type == BT_CHARACTER\n-\t    && ap->expr->symtree->n.sym->ts.cl->length == NULL)\n+\t    && ap->expr->symtree->n.sym->ts.u.cl->length == NULL)\n \t  {\n \t    gfc_error (\"Assumed character length variable '%s' in constant \"\n \t\t       \"expression at %L\", e->symtree->n.sym->name, &e->where);\n@@ -3337,7 +3337,7 @@ gfc_default_initializer (gfc_typespec *ts)\n   gfc_component *c;\n \n   /* See if we have a default initializer.  */\n-  for (c = ts->derived->components; c; c = c->next)\n+  for (c = ts->u.derived->components; c; c = c->next)\n     if (c->initializer || c->attr.allocatable)\n       break;\n \n@@ -3348,10 +3348,10 @@ gfc_default_initializer (gfc_typespec *ts)\n   init = gfc_get_expr ();\n   init->expr_type = EXPR_STRUCTURE;\n   init->ts = *ts;\n-  init->where = ts->derived->declared_at;\n+  init->where = ts->u.derived->declared_at;\n \n   tail = NULL;\n-  for (c = ts->derived->components; c; c = c->next)\n+  for (c = ts->u.derived->components; c; c = c->next)\n     {\n       if (tail == NULL)\n \tinit->value.constructor = tail = gfc_get_constructor ();\n@@ -3421,10 +3421,10 @@ gfc_traverse_expr (gfc_expr *expr, gfc_symbol *sym,\n     return true;\n \n   if (expr->ts.type == BT_CHARACTER\n-\t&& expr->ts.cl\n-\t&& expr->ts.cl->length\n-\t&& expr->ts.cl->length->expr_type != EXPR_CONSTANT\n-\t&& gfc_traverse_expr (expr->ts.cl->length, sym, func, f))\n+\t&& expr->ts.u.cl\n+\t&& expr->ts.u.cl->length\n+\t&& expr->ts.u.cl->length->expr_type != EXPR_CONSTANT\n+\t&& gfc_traverse_expr (expr->ts.u.cl->length, sym, func, f))\n     return true;\n \n   switch (expr->expr_type)\n@@ -3502,11 +3502,11 @@ gfc_traverse_expr (gfc_expr *expr, gfc_symbol *sym,\n \n \tcase REF_COMPONENT:\n \t  if (ref->u.c.component->ts.type == BT_CHARACTER\n-\t\t&& ref->u.c.component->ts.cl\n-\t\t&& ref->u.c.component->ts.cl->length\n-\t\t&& ref->u.c.component->ts.cl->length->expr_type\n+\t\t&& ref->u.c.component->ts.u.cl\n+\t\t&& ref->u.c.component->ts.u.cl->length\n+\t\t&& ref->u.c.component->ts.u.cl->length->expr_type\n \t\t     != EXPR_CONSTANT\n-\t\t&& gfc_traverse_expr (ref->u.c.component->ts.cl->length,\n+\t\t&& gfc_traverse_expr (ref->u.c.component->ts.u.cl->length,\n \t\t\t\t      sym, func, f))\n \t    return true;\n "}, {"sha": "17a0a5320722b4cf90da27d8340daa080359859c", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -833,13 +833,19 @@ gfc_charlen;\n \n #define gfc_get_charlen() XCNEW (gfc_charlen)\n \n-/* Type specification structure.  FIXME: derived and cl could be union???  */\n+/* Type specification structure.  */\n typedef struct\n {\n   bt type;\n   int kind;\n-  struct gfc_symbol *derived;\n-  gfc_charlen *cl;\t/* For character types only.  */\n+\n+  union\n+  {\n+    struct gfc_symbol *derived;\t/* For derived types only.  */\n+    gfc_charlen *cl;\t\t/* For character types only.  */\n+  }\n+  u;\n+\n   struct gfc_symbol *interface;\t/* For PROCEDURE declarations.  */\n   unsigned int is_class:1;\n   int is_c_interop;"}, {"sha": "60096e208284d41ddddc72f58921ed10ba7fd903", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -410,17 +410,17 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n \n       /* Make sure that link lists do not put this function into an \n \t endless recursive loop!  */\n-      if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.derived)\n-\t    && !(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.derived)\n+      if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)\n+\t    && !(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)\n \t    && gfc_compare_types (&dt1->ts, &dt2->ts) == 0)\n \treturn 0;\n \n-      else if ((dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.derived)\n-\t\t&& !(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.derived))\n+      else if ((dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)\n+\t\t&& !(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived))\n \treturn 0;\n \n-      else if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.derived)\n-\t\t&& (dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.derived))\n+      else if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)\n+\t\t&& (dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived))\n \treturn 0;\n \n       dt1 = dt1->next;\n@@ -454,10 +454,10 @@ gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)\n     return (ts1->kind == ts2->kind);\n \n   /* Compare derived types.  */\n-  if (ts1->derived == ts2->derived)\n+  if (ts1->u.derived == ts2->u.derived)\n     return 1;\n \n-  return gfc_compare_derived_types (ts1->derived ,ts2->derived);\n+  return gfc_compare_derived_types (ts1->u.derived ,ts2->u.derived);\n }\n \n \n@@ -1386,9 +1386,9 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n     return 1;\n \n   if (formal->ts.type == BT_DERIVED\n-      && formal->ts.derived && formal->ts.derived->ts.is_iso_c\n+      && formal->ts.u.derived && formal->ts.u.derived->ts.is_iso_c\n       && actual->ts.type == BT_DERIVED\n-      && actual->ts.derived && actual->ts.derived->ts.is_iso_c)\n+      && actual->ts.u.derived && actual->ts.u.derived->ts.is_iso_c)\n     return 1;\n \n   if (actual->ts.type == BT_PROCEDURE)\n@@ -1551,9 +1551,9 @@ get_sym_storage_size (gfc_symbol *sym)\n \n   if (sym->ts.type == BT_CHARACTER)\n     {\n-      if (sym->ts.cl && sym->ts.cl->length\n-          && sym->ts.cl->length->expr_type == EXPR_CONSTANT)\n-\tstrlen = mpz_get_ui (sym->ts.cl->length->value.integer);\n+      if (sym->ts.u.cl && sym->ts.u.cl->length\n+          && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n+\tstrlen = mpz_get_ui (sym->ts.u.cl->length->value.integer);\n       else\n \treturn 0;\n     }\n@@ -1599,11 +1599,11 @@ get_expr_storage_size (gfc_expr *e)\n   \n   if (e->ts.type == BT_CHARACTER)\n     {\n-      if (e->ts.cl && e->ts.cl->length\n-          && e->ts.cl->length->expr_type == EXPR_CONSTANT)\n-\tstrlen = mpz_get_si (e->ts.cl->length->value.integer);\n+      if (e->ts.u.cl && e->ts.u.cl->length\n+          && e->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n+\tstrlen = mpz_get_si (e->ts.u.cl->length->value.integer);\n       else if (e->expr_type == EXPR_CONSTANT\n-\t       && (e->ts.cl == NULL || e->ts.cl->length == NULL))\n+\t       && (e->ts.u.cl == NULL || e->ts.u.cl->length == NULL))\n \tstrlen = e->value.character.length;\n       else\n \treturn 0;\n@@ -1869,28 +1869,28 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t and assumed-shape dummies, the string length needs to match\n \t exactly.  */\n       if (a->expr->ts.type == BT_CHARACTER\n-\t   && a->expr->ts.cl && a->expr->ts.cl->length\n-\t   && a->expr->ts.cl->length->expr_type == EXPR_CONSTANT\n-\t   && f->sym->ts.cl && f->sym->ts.cl && f->sym->ts.cl->length\n-\t   && f->sym->ts.cl->length->expr_type == EXPR_CONSTANT\n+\t   && a->expr->ts.u.cl && a->expr->ts.u.cl->length\n+\t   && a->expr->ts.u.cl->length->expr_type == EXPR_CONSTANT\n+\t   && f->sym->ts.u.cl && f->sym->ts.u.cl && f->sym->ts.u.cl->length\n+\t   && f->sym->ts.u.cl->length->expr_type == EXPR_CONSTANT\n \t   && (f->sym->attr.pointer || f->sym->attr.allocatable\n \t       || (f->sym->as && f->sym->as->type == AS_ASSUMED_SHAPE))\n-\t   && (mpz_cmp (a->expr->ts.cl->length->value.integer,\n-\t\t\tf->sym->ts.cl->length->value.integer) != 0))\n+\t   && (mpz_cmp (a->expr->ts.u.cl->length->value.integer,\n+\t\t\tf->sym->ts.u.cl->length->value.integer) != 0))\n \t {\n \t   if (where && (f->sym->attr.pointer || f->sym->attr.allocatable))\n \t     gfc_warning (\"Character length mismatch (%ld/%ld) between actual \"\n \t\t\t  \"argument and pointer or allocatable dummy argument \"\n \t\t\t  \"'%s' at %L\",\n-\t\t\t  mpz_get_si (a->expr->ts.cl->length->value.integer),\n-\t\t\t  mpz_get_si (f->sym->ts.cl->length->value.integer),\n+\t\t\t  mpz_get_si (a->expr->ts.u.cl->length->value.integer),\n+\t\t\t  mpz_get_si (f->sym->ts.u.cl->length->value.integer),\n \t\t\t  f->sym->name, &a->expr->where);\n \t   else if (where)\n \t     gfc_warning (\"Character length mismatch (%ld/%ld) between actual \"\n \t\t\t  \"argument and assumed-shape dummy argument '%s' \"\n \t\t\t  \"at %L\",\n-\t\t\t  mpz_get_si (a->expr->ts.cl->length->value.integer),\n-\t\t\t  mpz_get_si (f->sym->ts.cl->length->value.integer),\n+\t\t\t  mpz_get_si (a->expr->ts.u.cl->length->value.integer),\n+\t\t\t  mpz_get_si (f->sym->ts.u.cl->length->value.integer),\n \t\t\t  f->sym->name, &a->expr->where);\n \t   return 0;\n \t }"}, {"sha": "1c180eb27b896ae6a62f9fcb8f926f40fe472cc1", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -62,16 +62,16 @@ gfc_get_string (const char *format, ...)\n static void\n check_charlen_present (gfc_expr *source)\n {\n-  if (source->ts.cl == NULL)\n-    source->ts.cl = gfc_new_charlen (gfc_current_ns);\n+  if (source->ts.u.cl == NULL)\n+    source->ts.u.cl = gfc_new_charlen (gfc_current_ns);\n \n   if (source->expr_type == EXPR_CONSTANT)\n     {\n-      source->ts.cl->length = gfc_int_expr (source->value.character.length);\n+      source->ts.u.cl->length = gfc_int_expr (source->value.character.length);\n       source->rank = 0;\n     }\n   else if (source->expr_type == EXPR_ARRAY)\n-    source->ts.cl->length =\n+    source->ts.u.cl->length =\n \tgfc_int_expr (source->value.constructor->expr->value.character.length);\n }\n \n@@ -161,8 +161,8 @@ gfc_resolve_char_achar (gfc_expr *f, gfc_expr *x, gfc_expr *kind,\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = (kind == NULL)\n \t     ? gfc_default_character_kind : mpz_get_si (kind->value.integer);\n-  f->ts.cl = gfc_new_charlen (gfc_current_ns);\n-  f->ts.cl->length = gfc_int_expr (1);\n+  f->ts.u.cl = gfc_new_charlen (gfc_current_ns);\n+  f->ts.u.cl->length = gfc_int_expr (1);\n \n   f->value.function.name = gfc_get_string (name, f->ts.kind,\n \t\t\t\t\t   gfc_type_letter (x->ts.type),\n@@ -651,8 +651,8 @@ gfc_resolve_ctime (gfc_expr *f, gfc_expr *time)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = 8;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (time, &ts, 2);\n     }\n \n@@ -1058,8 +1058,8 @@ gfc_resolve_index_func (gfc_expr *f, gfc_expr *str,\n     {\n       ts.type = BT_LOGICAL;\n       ts.kind = gfc_default_integer_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (back, &ts, 2);\n     }\n \n@@ -1125,8 +1125,8 @@ gfc_resolve_isatty (gfc_expr *f, gfc_expr *u)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_c_int_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (u, &ts, 2);\n     }\n \n@@ -2175,8 +2175,8 @@ gfc_resolve_fgetc (gfc_expr *f, gfc_expr *u, gfc_expr *c ATTRIBUTE_UNUSED)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_c_int_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (u, &ts, 2);\n     }\n \n@@ -2205,8 +2205,8 @@ gfc_resolve_fputc (gfc_expr *f, gfc_expr *u, gfc_expr *c ATTRIBUTE_UNUSED)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_c_int_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (u, &ts, 2);\n     }\n \n@@ -2235,8 +2235,8 @@ gfc_resolve_ftell (gfc_expr *f, gfc_expr *u)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_c_int_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (u, &ts, 2);\n     }\n \n@@ -2341,16 +2341,16 @@ gfc_resolve_transfer (gfc_expr *f, gfc_expr *source ATTRIBUTE_UNUSED,\n   static char transfer0[] = \"__transfer0\", transfer1[] = \"__transfer1\";\n \n   if (mold->ts.type == BT_CHARACTER\n-\t&& !mold->ts.cl->length\n+\t&& !mold->ts.u.cl->length\n \t&& gfc_is_constant_expr (mold))\n     {\n       int len;\n       if (mold->expr_type == EXPR_CONSTANT)\n-\tmold->ts.cl->length = gfc_int_expr (mold->value.character.length);\n+\tmold->ts.u.cl->length = gfc_int_expr (mold->value.character.length);\n       else\n \t{\n \t  len = mold->value.constructor->expr->value.character.length;\n-\t  mold->ts.cl->length = gfc_int_expr (len);\n+\t  mold->ts.u.cl->length = gfc_int_expr (len);\n \t}\n     }\n \n@@ -2498,8 +2498,8 @@ gfc_resolve_ttynam (gfc_expr *f, gfc_expr *unit)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_c_int_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (unit, &ts, 2);\n     }\n \n@@ -3077,8 +3077,8 @@ gfc_resolve_ctime_sub (gfc_code *c)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = 8;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (c->ext.actual->expr, &ts, 2);\n     }\n \n@@ -3180,8 +3180,8 @@ gfc_resolve_fgetc_sub (gfc_code *c)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_c_int_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (u, &ts, 2);\n     }\n \n@@ -3225,8 +3225,8 @@ gfc_resolve_fputc_sub (gfc_code *c)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_c_int_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (u, &ts, 2);\n     }\n \n@@ -3274,26 +3274,26 @@ gfc_resolve_fseek_sub (gfc_code *c)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_c_int_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (unit, &ts, 2);\n     }\n \n   if (offset->ts.kind != gfc_intio_kind)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_intio_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (offset, &ts, 2);\n     }\n \n   if (whence->ts.kind != gfc_c_int_kind)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_c_int_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (whence, &ts, 2);\n     }\n \n@@ -3316,8 +3316,8 @@ gfc_resolve_ftell_sub (gfc_code *c)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_c_int_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (unit, &ts, 2);\n     }\n \n@@ -3336,8 +3336,8 @@ gfc_resolve_ttynam_sub (gfc_code *c)\n     {\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_c_int_kind;\n-      ts.derived = NULL;\n-      ts.cl = NULL;\n+      ts.u.derived = NULL;\n+      ts.u.cl = NULL;\n       gfc_convert_type (c->ext.actual->expr, &ts, 2);\n     }\n "}, {"sha": "3c6ef49ed2b620e5779665aa7e9f9d091f617025", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -2264,7 +2264,7 @@ gfc_match_allocate (void)\n \t}\n \n       if (tail->expr->ts.type == BT_DERIVED)\n-\ttail->expr->ts.derived = gfc_use_derived (tail->expr->ts.derived);\n+\ttail->expr->ts.u.derived = gfc_use_derived (tail->expr->ts.u.derived);\n \n       /* FIXME: disable the checking on derived types and arrays.  */\n       if (!(tail->expr->ref\n@@ -3214,7 +3214,7 @@ gfc_match_namelist (void)\n \t      gfc_error_check ();\n \t    }\n \n-\t  if (sym->ts.type == BT_CHARACTER && sym->ts.cl->length == NULL)\n+\t  if (sym->ts.type == BT_CHARACTER && sym->ts.u.cl->length == NULL)\n \t    {\n \t      gfc_error (\"Assumed character length '%s' in namelist '%s' at \"\n \t\t\t \"%C is not allowed\", sym->name, group_name->name);"}, {"sha": "f80c9fa6af7d708eeada2c3ef3252414c588e5dd", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -67,9 +67,9 @@ void\n gfc_clear_ts (gfc_typespec *ts)\n {\n   ts->type = BT_UNKNOWN;\n-  ts->derived = NULL;\n+  ts->u.derived = NULL;\n   ts->kind = 0;\n-  ts->cl = NULL;\n+  ts->u.cl = NULL;\n   ts->interface = NULL;\n   ts->is_class = 0;\n   /* flag that says if the type is C interoperable */\n@@ -184,7 +184,7 @@ gfc_typename (gfc_typespec *ts)\n       sprintf (buffer, \"HOLLERITH\");\n       break;\n     case BT_DERIVED:\n-      sprintf (buffer, \"TYPE(%s)\", ts->derived->name);\n+      sprintf (buffer, \"TYPE(%s)\", ts->u.derived->name);\n       break;\n     case BT_PROCEDURE:\n       strcpy (buffer, \"PROCEDURE\");"}, {"sha": "fe05dff8299766e5d01b3eea7519e869919b7368", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -2038,7 +2038,7 @@ mio_typespec (gfc_typespec *ts)\n   if (ts->type != BT_DERIVED)\n     mio_integer (&ts->kind);\n   else\n-    mio_symbol_ref (&ts->derived);\n+    mio_symbol_ref (&ts->u.derived);\n \n   /* Add info for C interop and is_iso_c.  */\n   mio_integer (&ts->is_c_interop);\n@@ -2054,12 +2054,12 @@ mio_typespec (gfc_typespec *ts)\n \n   if (ts->type != BT_CHARACTER)\n     {\n-      /* ts->cl is only valid for BT_CHARACTER.  */\n+      /* ts->u.cl is only valid for BT_CHARACTER.  */\n       mio_lparen ();\n       mio_rparen ();\n     }\n   else\n-    mio_charlen (&ts->cl);\n+    mio_charlen (&ts->u.cl);\n \n   mio_rparen ();\n }"}, {"sha": "d60121c59291314b588ed4e734751ddeccf62b19", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -873,7 +873,7 @@ resolve_omp_clauses (gfc_code *code)\n \t\tif (!n->sym->attr.threadprivate)\n \t\t  gfc_error (\"Non-THREADPRIVATE object '%s' in COPYIN clause\"\n \t\t\t     \" at %L\", n->sym->name, &code->loc);\n-\t\tif (n->sym->ts.type == BT_DERIVED && n->sym->ts.derived->attr.alloc_comp)\n+\t\tif (n->sym->ts.type == BT_DERIVED && n->sym->ts.u.derived->attr.alloc_comp)\n \t\t  gfc_error (\"COPYIN clause object '%s' at %L has ALLOCATABLE components\",\n \t\t\t     n->sym->name, &code->loc);\n \t      }\n@@ -884,7 +884,7 @@ resolve_omp_clauses (gfc_code *code)\n \t\tif (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n \t\t  gfc_error (\"Assumed size array '%s' in COPYPRIVATE clause \"\n \t\t\t     \"at %L\", n->sym->name, &code->loc);\n-\t\tif (n->sym->ts.type == BT_DERIVED && n->sym->ts.derived->attr.alloc_comp)\n+\t\tif (n->sym->ts.type == BT_DERIVED && n->sym->ts.u.derived->attr.alloc_comp)\n \t\t  gfc_error (\"COPYPRIVATE clause object '%s' at %L has ALLOCATABLE components\",\n \t\t\t     n->sym->name, &code->loc);\n \t      }\n@@ -916,7 +916,7 @@ resolve_omp_clauses (gfc_code *code)\n \t\t\t\t n->sym->name, name, &code->loc);\n \t\t    /* Variables in REDUCTION-clauses must be of intrinsic type (flagged below).  */\n \t\t    if ((list < OMP_LIST_REDUCTION_FIRST || list > OMP_LIST_REDUCTION_LAST) &&\n-\t\t        n->sym->ts.type == BT_DERIVED && n->sym->ts.derived->attr.alloc_comp)\n+\t\t        n->sym->ts.type == BT_DERIVED && n->sym->ts.u.derived->attr.alloc_comp)\n \t\t      gfc_error (\"%s clause object '%s' has ALLOCATABLE components at %L\",\n \t\t\t\t name, n->sym->name, &code->loc);\n \t\t    if (n->sym->attr.cray_pointer)"}, {"sha": "2552fcd67886520288b2eb40dfeade6c15eccfa9", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -2049,24 +2049,24 @@ parse_derived (void)\n     {\n       /* Look for allocatable components.  */\n       if (c->attr.allocatable\n-\t  || (c->ts.type == BT_DERIVED && c->ts.derived->attr.alloc_comp))\n+\t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.alloc_comp))\n \tsym->attr.alloc_comp = 1;\n \n       /* Look for pointer components.  */\n       if (c->attr.pointer\n-\t  || (c->ts.type == BT_DERIVED && c->ts.derived->attr.pointer_comp))\n+\t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.pointer_comp))\n \tsym->attr.pointer_comp = 1;\n \n       /* Look for procedure pointer components.  */\n       if (c->attr.proc_pointer\n \t  || (c->ts.type == BT_DERIVED\n-\t      && c->ts.derived->attr.proc_pointer_comp))\n+\t      && c->ts.u.derived->attr.proc_pointer_comp))\n \tsym->attr.proc_pointer_comp = 1;\n \n       /* Look for private components.  */\n       if (sym->component_access == ACCESS_PRIVATE\n \t  || c->attr.access == ACCESS_PRIVATE\n-\t  || (c->ts.type == BT_DERIVED && c->ts.derived->attr.private_comp))\n+\t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.private_comp))\n \tsym->attr.private_comp = 1;\n     }\n \n@@ -2320,7 +2320,7 @@ match_deferred_characteristics (gfc_typespec * ts)\n     {\n       ts->kind = 0;\n \n-      if (!ts->derived || !ts->derived->components)\n+      if (!ts->u.derived || !ts->u.derived->components)\n \tm = MATCH_ERROR;\n     }\n \n@@ -2360,8 +2360,8 @@ check_function_result_typed (void)\n \n   /* Check type-parameters, at the moment only CHARACTER lengths possible.  */\n   /* TODO:  Extend when KIND type parameters are implemented.  */\n-  if (ts->type == BT_CHARACTER && ts->cl && ts->cl->length)\n-    gfc_expr_check_typed (ts->cl->length, gfc_current_ns, true);\n+  if (ts->type == BT_CHARACTER && ts->u.cl && ts->u.cl->length)\n+    gfc_expr_check_typed (ts->u.cl->length, gfc_current_ns, true);\n }\n \n \n@@ -2540,7 +2540,7 @@ parse_spec (gfc_statement st)\n \n       gfc_current_block ()->ts.kind = 0;\n       /* Keep the derived type; if it's bad, it will be discovered later.  */\n-      if (!(ts->type == BT_DERIVED && ts->derived))\n+      if (!(ts->type == BT_DERIVED && ts->u.derived))\n \tts->type = BT_UNKNOWN;\n     }\n "}, {"sha": "e0021c54b18d2169ffa9a3f8329e036c9dfa8dee", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -1770,7 +1770,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n   if (sym->ts.type != BT_DERIVED || gfc_match_char ('%') != MATCH_YES)\n     goto check_substring;\n \n-  sym = sym->ts.derived;\n+  sym = sym->ts.u.derived;\n \n   for (;;)\n     {\n@@ -1864,7 +1864,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t  || gfc_match_char ('%') != MATCH_YES)\n \tbreak;\n \n-      sym = component->ts.derived;\n+      sym = component->ts.u.derived;\n     }\n \n check_substring:\n@@ -1881,7 +1881,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \n   if (primary->ts.type == BT_CHARACTER)\n     {\n-      switch (match_substring (primary->ts.cl, equiv_flag, &substring))\n+      switch (match_substring (primary->ts.u.cl, equiv_flag, &substring))\n \t{\n \tcase MATCH_YES:\n \t  if (tail == NULL)\n@@ -1893,7 +1893,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t    primary->expr_type = EXPR_SUBSTRING;\n \n \t  if (substring)\n-\t    primary->ts.cl = NULL;\n+\t    primary->ts.u.cl = NULL;\n \n \t  break;\n \n@@ -1990,7 +1990,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n \t       follows.  */\n \t    if (ts->type == BT_CHARACTER\n \t\t&& ref->next && ref->next->type == REF_SUBSTRING)\n-\t\tts->cl = NULL;\n+\t\tts->u.cl = NULL;\n \t  }\n \n \tpointer = ref->u.c.component->attr.pointer;\n@@ -2106,7 +2106,7 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,\n \t  value->where = gfc_current_locus;\n \n \t  if (build_actual_constructor (comp_head, &value->value.constructor,\n-\t\t\t\t\tcomp->ts.derived) == FAILURE)\n+\t\t\t\t\tcomp->ts.u.derived) == FAILURE)\n \t    {\n \t      gfc_free_expr (value);\n \t      return FAILURE;\n@@ -2284,13 +2284,13 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result,\n \t\t&& sym->attr.extension\n \t\t&& (comp_tail->val->ts.type != BT_DERIVED\n \t\t      ||\n-\t\t    comp_tail->val->ts.derived != this_comp->ts.derived))\n+\t\t    comp_tail->val->ts.u.derived != this_comp->ts.u.derived))\n \t    {\n \t      gfc_current_locus = where;\n \t      gfc_free_expr (comp_tail->val);\n \t      comp_tail->val = NULL;\n \n-\t      m = gfc_match_structure_constructor (comp->ts.derived, \n+\t      m = gfc_match_structure_constructor (comp->ts.u.derived, \n \t\t\t\t\t\t   &comp_tail->val, true);\n \t      if (m == MATCH_NO)\n \t\tgoto syntax;\n@@ -2335,7 +2335,7 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result,\n   e->expr_type = EXPR_STRUCTURE;\n \n   e->ts.type = BT_DERIVED;\n-  e->ts.derived = sym;\n+  e->ts.u.derived = sym;\n   e->where = where;\n \n   e->value.constructor = ctor_head;\n@@ -2758,7 +2758,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t     that we're not sure is a variable yet.  */\n \n \t  if ((implicit_char || sym->ts.type == BT_CHARACTER)\n-\t      && match_substring (sym->ts.cl, 0, &e->ref) == MATCH_YES)\n+\t      && match_substring (sym->ts.u.cl, 0, &e->ref) == MATCH_YES)\n \t    {\n \n \t      e->expr_type = EXPR_VARIABLE;\n@@ -2780,7 +2780,7 @@ gfc_match_rvalue (gfc_expr **result)\n \n \t      e->ts = sym->ts;\n \t      if (e->ref)\n-\t\te->ts.cl = NULL;\n+\t\te->ts.u.cl = NULL;\n \t      m = MATCH_YES;\n \t      break;\n \t    }\n@@ -2957,7 +2957,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \t     type may still have to be resolved.  */\n \n \t  if (sym->ts.type == BT_DERIVED\n-\t      && gfc_use_derived (sym->ts.derived) == NULL)\n+\t      && gfc_use_derived (sym->ts.u.derived) == NULL)\n \t    return MATCH_ERROR;\n \t  break;\n \t}"}, {"sha": "9baef621eac6e13ee6368be9d411644761448758", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 179, "deletions": 182, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -103,16 +103,16 @@ is_sym_host_assoc (gfc_symbol *sym, gfc_namespace *ns)\n static gfc_try\n resolve_typespec_used (gfc_typespec* ts, locus* where, const char* name)\n {\n-  if (ts->type == BT_DERIVED && ts->derived->attr.abstract)\n+  if (ts->type == BT_DERIVED && ts->u.derived->attr.abstract)\n     {\n       if (where)\n \t{\n \t  if (name)\n \t    gfc_error (\"'%s' at %L is of the ABSTRACT type '%s'\",\n-\t\t       name, where, ts->derived->name);\n+\t\t       name, where, ts->u.derived->name);\n \t  else\n \t    gfc_error (\"ABSTRACT type '%s' used at %L\",\n-\t\t       ts->derived->name, where);\n+\t\t       ts->u.derived->name, where);\n \t}\n \n       return FAILURE;\n@@ -294,7 +294,7 @@ resolve_formal_arglist (gfc_symbol *proc)\n \n \t  if (sym->ts.type == BT_CHARACTER)\n \t    {\n-\t      gfc_charlen *cl = sym->ts.cl;\n+\t      gfc_charlen *cl = sym->ts.u.cl;\n \t      if (!cl || !cl->length || cl->length->expr_type != EXPR_CONSTANT)\n \t\t{\n \t\t  gfc_error (\"Character-valued argument '%s' of statement \"\n@@ -372,7 +372,7 @@ resolve_contained_fntype (gfc_symbol *sym, gfc_namespace *ns)\n \n   if (sym->result->ts.type == BT_CHARACTER)\n     {\n-      gfc_charlen *cl = sym->result->ts.cl;\n+      gfc_charlen *cl = sym->result->ts.u.cl;\n       if (!cl || !cl->length)\n \tgfc_error (\"Character-valued internal function '%s' at %L must \"\n \t\t   \"not be assumed length\", sym->name, &sym->declared_at);\n@@ -552,16 +552,16 @@ resolve_entries (gfc_namespace *ns)\n \t     the same string length, i.e. both len=*, or both len=4.\n \t     Having both len=<variable> is also possible, but difficult to\n \t     check at compile time.  */\n-\t  else if (ts->type == BT_CHARACTER && ts->cl && fts->cl\n-\t\t   && (((ts->cl->length && !fts->cl->length)\n-\t\t\t||(!ts->cl->length && fts->cl->length))\n-\t\t       || (ts->cl->length\n-\t\t\t   && ts->cl->length->expr_type\n-\t\t\t      != fts->cl->length->expr_type)\n-\t\t       || (ts->cl->length\n-\t\t\t   && ts->cl->length->expr_type == EXPR_CONSTANT\n-\t\t           && mpz_cmp (ts->cl->length->value.integer,\n-\t\t\t\t       fts->cl->length->value.integer) != 0)))\n+\t  else if (ts->type == BT_CHARACTER && ts->u.cl && fts->u.cl\n+\t\t   && (((ts->u.cl->length && !fts->u.cl->length)\n+\t\t\t||(!ts->u.cl->length && fts->u.cl->length))\n+\t\t       || (ts->u.cl->length\n+\t\t\t   && ts->u.cl->length->expr_type\n+\t\t\t      != fts->u.cl->length->expr_type)\n+\t\t       || (ts->u.cl->length\n+\t\t\t   && ts->u.cl->length->expr_type == EXPR_CONSTANT\n+\t\t           && mpz_cmp (ts->u.cl->length->value.integer,\n+\t\t\t\t       fts->u.cl->length->value.integer) != 0)))\n \t    gfc_notify_std (GFC_STD_GNU, \"Extension: Function %s at %L with \"\n \t\t\t    \"entries returning variables of different \"\n \t\t\t    \"string lengths\", ns->entries->sym->name,\n@@ -688,7 +688,7 @@ has_default_initializer (gfc_symbol *der)\n   for (c = der->components; c; c = c->next)\n     if ((c->ts.type != BT_DERIVED && c->initializer)\n \t|| (c->ts.type == BT_DERIVED\n-\t    && (!c->attr.pointer && has_default_initializer (c->ts.derived))))\n+\t    && (!c->attr.pointer && has_default_initializer (c->ts.u.derived))))\n       break;\n \n   return c != NULL;\n@@ -718,16 +718,16 @@ resolve_common_vars (gfc_symbol *sym, bool named_common)\n       if (csym->ts.type != BT_DERIVED)\n \tcontinue;\n \n-      if (!(csym->ts.derived->attr.sequence\n-\t    || csym->ts.derived->attr.is_bind_c))\n+      if (!(csym->ts.u.derived->attr.sequence\n+\t    || csym->ts.u.derived->attr.is_bind_c))\n \tgfc_error_now (\"Derived type variable '%s' in COMMON at %L \"\n \t\t       \"has neither the SEQUENCE nor the BIND(C) \"\n \t\t       \"attribute\", csym->name, &csym->declared_at);\n-      if (csym->ts.derived->attr.alloc_comp)\n+      if (csym->ts.u.derived->attr.alloc_comp)\n \tgfc_error_now (\"Derived type variable '%s' in COMMON at %L \"\n \t\t       \"has an ultimate component that is \"\n \t\t       \"allocatable\", csym->name, &csym->declared_at);\n-      if (has_default_initializer (csym->ts.derived))\n+      if (has_default_initializer (csym->ts.u.derived))\n \tgfc_error_now (\"Derived type variable '%s' in COMMON at %L \"\n \t\t       \"may not have default initializer\", csym->name,\n \t\t       &csym->declared_at);\n@@ -826,15 +826,15 @@ resolve_structure_cons (gfc_expr *expr)\n   if (expr->ref)\n     comp = expr->ref->u.c.sym->components;\n   else\n-    comp = expr->ts.derived->components;\n+    comp = expr->ts.u.derived->components;\n \n   /* See if the user is trying to invoke a structure constructor for one of\n      the iso_c_binding derived types.  */\n-  if (expr->ts.derived && expr->ts.derived->ts.is_iso_c && cons\n+  if (expr->ts.u.derived && expr->ts.u.derived->ts.is_iso_c && cons\n       && cons->expr != NULL)\n     {\n       gfc_error (\"Components of structure constructor '%s' at %L are PRIVATE\",\n-\t\t expr->ts.derived->name, &(expr->where));\n+\t\t expr->ts.u.derived->name, &(expr->where));\n       return FAILURE;\n     }\n \n@@ -2191,9 +2191,9 @@ is_scalar_expr_ptr (gfc_expr *expr)\n \t\t     its length is one.\t */\n \t\t  if (expr->ts.type == BT_CHARACTER)\n \t\t    {\n-\t\t      if (expr->ts.cl == NULL\n-\t\t\t  || expr->ts.cl->length == NULL\n-\t\t\t  || mpz_cmp_si (expr->ts.cl->length->value.integer, 1)\n+\t\t      if (expr->ts.u.cl == NULL\n+\t\t\t  || expr->ts.u.cl->length == NULL\n+\t\t\t  || mpz_cmp_si (expr->ts.u.cl->length->value.integer, 1)\n \t\t\t  != 0)\n                         retval = FAILURE;\n \t\t    }\n@@ -2224,9 +2224,9 @@ is_scalar_expr_ptr (gfc_expr *expr)\n   else if (expr->ts.type == BT_CHARACTER && expr->rank == 0)\n     {\n       /* Character string.  Make sure it's of length 1.  */\n-      if (expr->ts.cl == NULL\n-          || expr->ts.cl->length == NULL\n-          || mpz_cmp_si (expr->ts.cl->length->value.integer, 1) != 0)\n+      if (expr->ts.u.cl == NULL\n+          || expr->ts.u.cl->length == NULL\n+          || mpz_cmp_si (expr->ts.u.cl->length->value.integer, 1) != 0)\n         retval = FAILURE;\n     }\n   else if (expr->rank != 0)\n@@ -2376,12 +2376,12 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n                          any type should be ok if the variable is of a C\n                          interoperable type.  */\n \t\t      if (arg_ts->type == BT_CHARACTER)\n-\t\t\tif (arg_ts->cl != NULL\n-\t\t\t    && (arg_ts->cl->length == NULL\n-\t\t\t\t|| arg_ts->cl->length->expr_type\n+\t\t\tif (arg_ts->u.cl != NULL\n+\t\t\t    && (arg_ts->u.cl->length == NULL\n+\t\t\t\t|| arg_ts->u.cl->length->expr_type\n \t\t\t\t   != EXPR_CONSTANT\n \t\t\t\t|| mpz_cmp_si\n-\t\t\t\t    (arg_ts->cl->length->value.integer, 1)\n+\t\t\t\t    (arg_ts->u.cl->length->value.integer, 1)\n \t\t\t\t   != 0)\n \t\t\t    && is_scalar_expr_ptr (args->expr) != SUCCESS)\n \t\t\t  {\n@@ -2536,8 +2536,8 @@ resolve_function (gfc_expr *expr)\n \t\t\t      &expr->value.function.actual, 0);\n \n   if (sym && sym->ts.type == BT_CHARACTER\n-      && sym->ts.cl\n-      && sym->ts.cl->length == NULL\n+      && sym->ts.u.cl\n+      && sym->ts.u.cl->length == NULL\n       && !sym->attr.dummy\n       && expr->value.function.esym == NULL\n       && !sym->attr.contained)\n@@ -2687,7 +2687,7 @@ resolve_function (gfc_expr *expr)\n   if (expr->ts.type == BT_CHARACTER && expr->value.function.esym\n       && expr->value.function.esym->attr.use_assoc)\n     {\n-      gfc_expr_set_symbols_referenced (expr->ts.cl->length);\n+      gfc_expr_set_symbols_referenced (expr->ts.u.cl->length);\n     }\n \n   if (t == SUCCESS\n@@ -3396,7 +3396,7 @@ resolve_operator (gfc_expr *e)\n     case INTRINSIC_PARENTHESES:\n       e->ts = op1->ts;\n       if (e->ts.type == BT_CHARACTER)\n-\te->ts.cl = op1->ts.cl;\n+\te->ts.u.cl = op1->ts.u.cl;\n       break;\n \n     default:\n@@ -3924,7 +3924,7 @@ find_array_spec (gfc_expr *e)\n \n       case REF_COMPONENT:\n \tif (derived == NULL)\n-\t  derived = e->symtree->n.sym->ts.derived;\n+\t  derived = e->symtree->n.sym->ts.u.derived;\n \n \tc = derived->components;\n \n@@ -3933,7 +3933,7 @@ find_array_spec (gfc_expr *e)\n \t    {\n \t      /* Track the sequence of component references.  */\n \t      if (c->ts.type == BT_DERIVED)\n-\t\tderived = c->ts.derived;\n+\t\tderived = c->ts.u.derived;\n \t      break;\n \t    }\n \n@@ -4116,10 +4116,10 @@ gfc_resolve_substring_charlen (gfc_expr *e)\n \n   gcc_assert (char_ref->next == NULL);\n \n-  if (e->ts.cl)\n+  if (e->ts.u.cl)\n     {\n-      if (e->ts.cl->length)\n-\tgfc_free_expr (e->ts.cl->length);\n+      if (e->ts.u.cl->length)\n+\tgfc_free_expr (e->ts.u.cl->length);\n       else if (e->expr_type == EXPR_VARIABLE\n \t\t && e->symtree->n.sym->attr.dummy)\n \treturn;\n@@ -4128,8 +4128,8 @@ gfc_resolve_substring_charlen (gfc_expr *e)\n   e->ts.type = BT_CHARACTER;\n   e->ts.kind = gfc_default_character_kind;\n \n-  if (!e->ts.cl)\n-    e->ts.cl = gfc_new_charlen (gfc_current_ns);\n+  if (!e->ts.u.cl)\n+    e->ts.u.cl = gfc_new_charlen (gfc_current_ns);\n \n   if (char_ref->u.ss.start)\n     start = gfc_copy_expr (char_ref->u.ss.start);\n@@ -4139,23 +4139,23 @@ gfc_resolve_substring_charlen (gfc_expr *e)\n   if (char_ref->u.ss.end)\n     end = gfc_copy_expr (char_ref->u.ss.end);\n   else if (e->expr_type == EXPR_VARIABLE)\n-    end = gfc_copy_expr (e->symtree->n.sym->ts.cl->length);\n+    end = gfc_copy_expr (e->symtree->n.sym->ts.u.cl->length);\n   else\n     end = NULL;\n \n   if (!start || !end)\n     return;\n \n   /* Length = (end - start +1).  */\n-  e->ts.cl->length = gfc_subtract (end, start);\n-  e->ts.cl->length = gfc_add (e->ts.cl->length, gfc_int_expr (1));\n+  e->ts.u.cl->length = gfc_subtract (end, start);\n+  e->ts.u.cl->length = gfc_add (e->ts.u.cl->length, gfc_int_expr (1));\n \n-  e->ts.cl->length->ts.type = BT_INTEGER;\n-  e->ts.cl->length->ts.kind = gfc_charlen_int_kind;\n+  e->ts.u.cl->length->ts.type = BT_INTEGER;\n+  e->ts.u.cl->length->ts.kind = gfc_charlen_int_kind;\n \n   /* Make sure that the length is simplified.  */\n-  gfc_simplify_expr (e->ts.cl->length, 1);\n-  gfc_resolve_expr (e->ts.cl->length);\n+  gfc_simplify_expr (e->ts.u.cl->length, 1);\n+  gfc_resolve_expr (e->ts.u.cl->length);\n }\n \n \n@@ -4447,7 +4447,7 @@ resolve_variable (gfc_expr *e)\n       /* Now do the same check on the specification expressions.  */\n       specification_expr = 1;\n       if (sym->ts.type == BT_CHARACTER\n-\t  && gfc_resolve_expr (sym->ts.cl->length) == FAILURE)\n+\t  && gfc_resolve_expr (sym->ts.u.cl->length) == FAILURE)\n \tt = FAILURE;\n \n       if (sym->as)\n@@ -4592,26 +4592,26 @@ gfc_resolve_character_operator (gfc_expr *e)\n \n   gcc_assert (e->value.op.op == INTRINSIC_CONCAT);\n \n-  if (op1->ts.cl && op1->ts.cl->length)\n-    e1 = gfc_copy_expr (op1->ts.cl->length);\n+  if (op1->ts.u.cl && op1->ts.u.cl->length)\n+    e1 = gfc_copy_expr (op1->ts.u.cl->length);\n   else if (op1->expr_type == EXPR_CONSTANT)\n     e1 = gfc_int_expr (op1->value.character.length);\n \n-  if (op2->ts.cl && op2->ts.cl->length)\n-    e2 = gfc_copy_expr (op2->ts.cl->length);\n+  if (op2->ts.u.cl && op2->ts.u.cl->length)\n+    e2 = gfc_copy_expr (op2->ts.u.cl->length);\n   else if (op2->expr_type == EXPR_CONSTANT)\n     e2 = gfc_int_expr (op2->value.character.length);\n \n-  e->ts.cl = gfc_new_charlen (gfc_current_ns);\n+  e->ts.u.cl = gfc_new_charlen (gfc_current_ns);\n \n   if (!e1 || !e2)\n     return;\n \n-  e->ts.cl->length = gfc_add (e1, e2);\n-  e->ts.cl->length->ts.type = BT_INTEGER;\n-  e->ts.cl->length->ts.kind = gfc_charlen_int_kind;\n-  gfc_simplify_expr (e->ts.cl->length, 0);\n-  gfc_resolve_expr (e->ts.cl->length);\n+  e->ts.u.cl->length = gfc_add (e1, e2);\n+  e->ts.u.cl->length->ts.type = BT_INTEGER;\n+  e->ts.u.cl->length->ts.kind = gfc_charlen_int_kind;\n+  gfc_simplify_expr (e->ts.u.cl->length, 0);\n+  gfc_resolve_expr (e->ts.u.cl->length);\n \n   return;\n }\n@@ -4636,12 +4636,12 @@ fixup_charlen (gfc_expr *e)\n \tgfc_resolve_character_array_constructor (e);\n \n     case EXPR_SUBSTRING:\n-      if (!e->ts.cl && e->ref)\n+      if (!e->ts.u.cl && e->ref)\n \tgfc_resolve_substring_charlen (e);\n \n     default:\n-      if (!e->ts.cl)\n-\te->ts.cl = gfc_new_charlen (gfc_current_ns);\n+      if (!e->ts.u.cl)\n+\te->ts.u.cl = gfc_new_charlen (gfc_current_ns);\n \n       break;\n     }\n@@ -4817,10 +4817,10 @@ check_typebound_baseobject (gfc_expr* e)\n     return FAILURE;\n \n   gcc_assert (base->ts.type == BT_DERIVED);\n-  if (base->ts.derived->attr.abstract)\n+  if (base->ts.u.derived->attr.abstract)\n     {\n       gfc_error (\"Base object for type-bound procedure call at %L is of\"\n-\t\t \" ABSTRACT type '%s'\", &e->where, base->ts.derived->name);\n+\t\t \" ABSTRACT type '%s'\", &e->where, base->ts.u.derived->name);\n       return FAILURE;\n     }\n \n@@ -5111,7 +5111,7 @@ gfc_resolve_expr (gfc_expr *e)\n \t    expression_rank (e);\n \t}\n \n-      if (e->ts.type == BT_CHARACTER && e->ts.cl == NULL && e->ref\n+      if (e->ts.type == BT_CHARACTER && e->ts.u.cl == NULL && e->ref\n \t  && e->ref->type != REF_SUBSTRING)\n \tgfc_resolve_substring_charlen (e);\n \n@@ -5171,7 +5171,7 @@ gfc_resolve_expr (gfc_expr *e)\n       gfc_internal_error (\"gfc_resolve_expr(): Bad expression type\");\n     }\n \n-  if (e->ts.type == BT_CHARACTER && t == SUCCESS && !e->ts.cl)\n+  if (e->ts.type == BT_CHARACTER && t == SUCCESS && !e->ts.u.cl)\n     fixup_charlen (e);\n \n   return t;\n@@ -5414,7 +5414,7 @@ derived_inaccessible (gfc_symbol *sym)\n \n   for (c = sym->components; c; c = c->next)\n     {\n-\tif (c->ts.type == BT_DERIVED && derived_inaccessible (c->ts.derived))\n+\tif (c->ts.type == BT_DERIVED && derived_inaccessible (c->ts.u.derived))\n \t  return 1;\n     }\n \n@@ -6344,21 +6344,21 @@ resolve_transfer (gfc_code *code)\n     {\n       /* Check that transferred derived type doesn't contain POINTER\n \t components.  */\n-      if (ts->derived->attr.pointer_comp)\n+      if (ts->u.derived->attr.pointer_comp)\n \t{\n \t  gfc_error (\"Data transfer element at %L cannot have \"\n \t\t     \"POINTER components\", &code->loc);\n \t  return;\n \t}\n \n-      if (ts->derived->attr.alloc_comp)\n+      if (ts->u.derived->attr.alloc_comp)\n \t{\n \t  gfc_error (\"Data transfer element at %L cannot have \"\n \t\t     \"ALLOCATABLE components\", &code->loc);\n \t  return;\n \t}\n \n-      if (derived_inaccessible (ts->derived))\n+      if (derived_inaccessible (ts->u.derived))\n \t{\n \t  gfc_error (\"Data transfer element at %L cannot have \"\n \t\t     \"PRIVATE components\",&code->loc);\n@@ -6925,7 +6925,7 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \t and rhs is the same symbol as the lhs.  */\n       if (rhs->expr_type == EXPR_VARIABLE\n \t    && rhs->symtree->n.sym->ts.type == BT_DERIVED\n-\t    && has_default_initializer (rhs->symtree->n.sym->ts.derived)\n+\t    && has_default_initializer (rhs->symtree->n.sym->ts.u.derived)\n \t    && (lhs->symtree->n.sym == rhs->symtree->n.sym))\n         code->ext.actual->next->expr = gfc_get_parentheses (rhs);\n \n@@ -6974,18 +6974,18 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n   if (lhs->ts.type == BT_CHARACTER\n \t&& gfc_option.warn_character_truncation)\n     {\n-      if (lhs->ts.cl != NULL\n-\t    && lhs->ts.cl->length != NULL\n-\t    && lhs->ts.cl->length->expr_type == EXPR_CONSTANT)\n-\tllen = mpz_get_si (lhs->ts.cl->length->value.integer);\n+      if (lhs->ts.u.cl != NULL\n+\t    && lhs->ts.u.cl->length != NULL\n+\t    && lhs->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n+\tllen = mpz_get_si (lhs->ts.u.cl->length->value.integer);\n \n       if (rhs->expr_type == EXPR_CONSTANT)\n  \trlen = rhs->value.character.length;\n \n-      else if (rhs->ts.cl != NULL\n-\t         && rhs->ts.cl->length != NULL\n-\t\t && rhs->ts.cl->length->expr_type == EXPR_CONSTANT)\n-\trlen = mpz_get_si (rhs->ts.cl->length->value.integer);\n+      else if (rhs->ts.u.cl != NULL\n+\t         && rhs->ts.u.cl->length != NULL\n+\t\t && rhs->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n+\trlen = mpz_get_si (rhs->ts.u.cl->length->value.integer);\n \n       if (rlen && llen && rlen > llen)\n \tgfc_warning_now (\"CHARACTER expression will be truncated \"\n@@ -7022,7 +7022,7 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \n       if (lhs->ts.type == BT_DERIVED\n \t    && lhs->expr_type == EXPR_VARIABLE\n-\t    && lhs->ts.derived->attr.pointer_comp\n+\t    && lhs->ts.u.derived->attr.pointer_comp\n \t    && gfc_impure_variable (rhs->symtree->n.sym))\n \t{\n \t  gfc_error (\"The impure variable at %L is assigned to \"\n@@ -7716,7 +7716,7 @@ apply_default_init (gfc_symbol *sym)\n   if (sym->attr.flavor != FL_VARIABLE && !sym->attr.function)\n     return;\n \n-  if (sym->ts.type == BT_DERIVED && sym->ts.derived)\n+  if (sym->ts.type == BT_DERIVED && sym->ts.u.derived)\n     init = gfc_default_initializer (&sym->ts);\n \n   if (init == NULL)\n@@ -7861,10 +7861,10 @@ build_default_init_expr (gfc_symbol *sym)\n       /* For characters, the length must be constant in order to \n \t create a default initializer.  */\n       if (gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON\n-\t  && sym->ts.cl->length\n-\t  && sym->ts.cl->length->expr_type == EXPR_CONSTANT)\n+\t  && sym->ts.u.cl->length\n+\t  && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n \t{\n-\t  char_len = mpz_get_si (sym->ts.cl->length->value.integer);\n+\t  char_len = mpz_get_si (sym->ts.u.cl->length->value.integer);\n \t  init_expr->value.character.length = char_len;\n \t  init_expr->value.character.string = gfc_get_wide_string (char_len+1);\n \t  for (i = 0; i < char_len; i++)\n@@ -7977,17 +7977,17 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n      associated by the presence of another class I symbol in the same\n      namespace.  14.6.1.3 of the standard and the discussion on\n      comp.lang.fortran.  */\n-  if (sym->ns != sym->ts.derived->ns\n+  if (sym->ns != sym->ts.u.derived->ns\n       && sym->ns->proc_name->attr.if_source != IFSRC_IFBODY)\n     {\n       gfc_symbol *s;\n-      gfc_find_symbol (sym->ts.derived->name, sym->ns, 0, &s);\n+      gfc_find_symbol (sym->ts.u.derived->name, sym->ns, 0, &s);\n       if (s && s->attr.flavor != FL_DERIVED)\n \t{\n \t  gfc_error (\"The type '%s' cannot be host associated at %L \"\n \t\t     \"because it is blocked by an incompatible object \"\n \t\t     \"of the same name declared at %L\",\n-\t\t     sym->ts.derived->name, &sym->declared_at,\n+\t\t     sym->ts.u.derived->name, &sym->declared_at,\n \t\t     &s->declared_at);\n \t  return FAILURE;\n \t}\n@@ -8005,7 +8005,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n       && sym->ns->proc_name->attr.flavor == FL_MODULE\n       && !sym->ns->save_all && !sym->attr.save\n       && !sym->attr.pointer && !sym->attr.allocatable\n-      && has_default_initializer (sym->ts.derived))\n+      && has_default_initializer (sym->ts.u.derived))\n     {\n       gfc_error(\"Object '%s' at %L must have the SAVE attribute for \"\n \t\t\"default initialization of a component\",\n@@ -8016,10 +8016,10 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n   if (sym->ts.is_class)\n     {\n       /* C502.  */\n-      if (!type_is_extensible (sym->ts.derived))\n+      if (!type_is_extensible (sym->ts.u.derived))\n \t{\n \t  gfc_error (\"Type '%s' of CLASS variable '%s' at %L is not extensible\",\n-\t\t     sym->ts.derived->name, sym->name, &sym->declared_at);\n+\t\t     sym->ts.u.derived->name, sym->name, &sym->declared_at);\n \t  return FAILURE;\n \t}\n \n@@ -8083,7 +8083,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n     {\n       /* Make sure that character string variables with assumed length are\n \t dummy arguments.  */\n-      e = sym->ts.cl->length;\n+      e = sym->ts.u.cl->length;\n       if (e == NULL && !sym->attr.dummy && !sym->attr.result)\n \t{\n \t  gfc_error (\"Entity with assumed character length at %L must be a \"\n@@ -8189,7 +8189,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \n   if (sym->ts.type == BT_CHARACTER)\n     {\n-      gfc_charlen *cl = sym->ts.cl;\n+      gfc_charlen *cl = sym->ts.u.cl;\n \n       if (cl && cl->length && gfc_is_constant_expr (cl->length)\n \t     && resolve_charlen (cl) == FAILURE)\n@@ -8229,17 +8229,17 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t{\n \t  if (arg->sym\n \t      && arg->sym->ts.type == BT_DERIVED\n-\t      && !arg->sym->ts.derived->attr.use_assoc\n-\t      && !gfc_check_access (arg->sym->ts.derived->attr.access,\n-\t\t\t\t    arg->sym->ts.derived->ns->default_access)\n+\t      && !arg->sym->ts.u.derived->attr.use_assoc\n+\t      && !gfc_check_access (arg->sym->ts.u.derived->attr.access,\n+\t\t\t\t    arg->sym->ts.u.derived->ns->default_access)\n \t      && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' is of a \"\n \t\t\t\t \"PRIVATE type and cannot be a dummy argument\"\n \t\t\t\t \" of '%s', which is PUBLIC at %L\",\n \t\t\t\t arg->sym->name, sym->name, &sym->declared_at)\n \t\t == FAILURE)\n \t    {\n \t      /* Stop this message from recurring.  */\n-\t      arg->sym->ts.derived->attr.access = ACCESS_PUBLIC;\n+\t      arg->sym->ts.u.derived->attr.access = ACCESS_PUBLIC;\n \t      return FAILURE;\n \t    }\n \t}\n@@ -8252,9 +8252,9 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t    {\n \t      if (arg->sym\n \t\t  && arg->sym->ts.type == BT_DERIVED\n-\t\t  && !arg->sym->ts.derived->attr.use_assoc\n-\t\t  && !gfc_check_access (arg->sym->ts.derived->attr.access,\n-\t\t\t\t\targ->sym->ts.derived->ns->default_access)\n+\t\t  && !arg->sym->ts.u.derived->attr.use_assoc\n+\t\t  && !gfc_check_access (arg->sym->ts.u.derived->attr.access,\n+\t\t\t\t\targ->sym->ts.u.derived->ns->default_access)\n \t\t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Procedure \"\n \t\t\t\t     \"'%s' in PUBLIC interface '%s' at %L \"\n \t\t\t\t     \"takes dummy arguments of '%s' which is \"\n@@ -8263,7 +8263,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t\t\t\t     gfc_typename (&arg->sym->ts)) == FAILURE)\n \t\t{\n \t\t  /* Stop this message from recurring.  */\n-\t\t  arg->sym->ts.derived->attr.access = ACCESS_PUBLIC;\n+\t\t  arg->sym->ts.u.derived->attr.access = ACCESS_PUBLIC;\n \t\t  return FAILURE;\n \t\t}\n \t     }\n@@ -8277,9 +8277,9 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t    {\n \t      if (arg->sym\n \t\t  && arg->sym->ts.type == BT_DERIVED\n-\t\t  && !arg->sym->ts.derived->attr.use_assoc\n-\t\t  && !gfc_check_access (arg->sym->ts.derived->attr.access,\n-\t\t\t\t\targ->sym->ts.derived->ns->default_access)\n+\t\t  && !arg->sym->ts.u.derived->attr.use_assoc\n+\t\t  && !gfc_check_access (arg->sym->ts.u.derived->attr.access,\n+\t\t\t\t\targ->sym->ts.u.derived->ns->default_access)\n \t\t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Procedure \"\n \t\t\t\t     \"'%s' in PUBLIC interface '%s' at %L \"\n \t\t\t\t     \"takes dummy arguments of '%s' which is \"\n@@ -8288,7 +8288,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t\t\t\t     gfc_typename (&arg->sym->ts)) == FAILURE)\n \t\t{\n \t\t  /* Stop this message from recurring.  */\n-\t\t  arg->sym->ts.derived->attr.access = ACCESS_PUBLIC;\n+\t\t  arg->sym->ts.u.derived->attr.access = ACCESS_PUBLIC;\n \t\t  return FAILURE;\n \t\t}\n \t     }\n@@ -8330,7 +8330,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n      function - but length must be declared in calling scoping unit.  */\n   if (sym->attr.function\n       && sym->ts.type == BT_CHARACTER\n-      && sym->ts.cl && sym->ts.cl->length == NULL)\n+      && sym->ts.u.cl && sym->ts.u.cl->length == NULL)\n     {\n       if ((sym->as && sym->as->rank) || (sym->attr.pointer)\n \t  || (sym->attr.recursive) || (sym->attr.pure))\n@@ -8499,7 +8499,7 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n       arg = list->proc_sym->formal->sym;\n \n       /* This argument must be of our type.  */\n-      if (arg->ts.type != BT_DERIVED || arg->ts.derived != derived)\n+      if (arg->ts.type != BT_DERIVED || arg->ts.u.derived != derived)\n \t{\n \t  gfc_error (\"Argument of FINAL procedure at %L must be of type '%s'\",\n \t\t     &arg->declared_at, derived->name);\n@@ -9181,7 +9181,7 @@ resolve_typebound_procedure (gfc_symtree* stree)\n       /* Now check that the argument-type matches.  */\n       gcc_assert (me_arg);\n       if (me_arg->ts.type != BT_DERIVED\n-\t  || me_arg->ts.derived != resolve_bindings_derived)\n+\t  || me_arg->ts.u.derived != resolve_bindings_derived)\n \t{\n \t  gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L must be of\"\n \t\t     \" the derived-type '%s'\", me_arg->name, proc->name,\n@@ -9450,12 +9450,12 @@ resolve_fl_derived (gfc_symbol *sym)\n \t\t    }\n \t        }\n \t      /* Copy char length.  */\n-\t      if (ifc->ts.cl)\n+\t      if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)\n \t\t{\n-\t\t  c->ts.cl = gfc_new_charlen (sym->ns);\n-\t          c->ts.cl->resolved = ifc->ts.cl->resolved;\n-\t\t  c->ts.cl->length = gfc_copy_expr (ifc->ts.cl->length);\n-\t\t  /* TODO: gfc_expr_replace_symbols (c->ts.cl->length, c);*/\n+\t\t  c->ts.u.cl = gfc_new_charlen (sym->ns);\n+\t          c->ts.u.cl->resolved = ifc->ts.u.cl->resolved;\n+\t\t  c->ts.u.cl->length = gfc_copy_expr (ifc->ts.u.cl->length);\n+\t\t  /* TODO: gfc_expr_replace_symbols (c->ts.u.cl->length, c);*/\n \t\t}\n \t    }\n \t  else if (c->ts.interface->name[0] != '\\0')\n@@ -9524,7 +9524,7 @@ resolve_fl_derived (gfc_symbol *sym)\n \t  /* Now check that the argument-type matches.  */\n \t  gcc_assert (me_arg);\n \t  if (me_arg->ts.type != BT_DERIVED\n-\t      || me_arg->ts.derived != sym)\n+\t      || me_arg->ts.u.derived != sym)\n \t    {\n \t      gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L must be of\"\n \t\t\t \" the derived type '%s'\", me_arg->name, c->name,\n@@ -9585,25 +9585,25 @@ resolve_fl_derived (gfc_symbol *sym)\n \n       if (c->ts.type == BT_CHARACTER)\n \t{\n-\t if (c->ts.cl->length == NULL\n-\t     || (resolve_charlen (c->ts.cl) == FAILURE)\n-\t     || !gfc_is_constant_expr (c->ts.cl->length))\n+\t if (c->ts.u.cl->length == NULL\n+\t     || (resolve_charlen (c->ts.u.cl) == FAILURE)\n+\t     || !gfc_is_constant_expr (c->ts.u.cl->length))\n \t   {\n \t     gfc_error (\"Character length of component '%s' needs to \"\n \t\t\t\"be a constant specification expression at %L\",\n \t\t\tc->name,\n-\t\t\tc->ts.cl->length ? &c->ts.cl->length->where : &c->loc);\n+\t\t\tc->ts.u.cl->length ? &c->ts.u.cl->length->where : &c->loc);\n \t     return FAILURE;\n \t   }\n \t}\n \n       if (c->ts.type == BT_DERIVED\n \t  && sym->component_access != ACCESS_PRIVATE\n \t  && gfc_check_access (sym->attr.access, sym->ns->default_access)\n-\t  && !is_sym_host_assoc (c->ts.derived, sym->ns)\n-\t  && !c->ts.derived->attr.use_assoc\n-\t  && !gfc_check_access (c->ts.derived->attr.access,\n-\t\t\t\tc->ts.derived->ns->default_access)\n+\t  && !is_sym_host_assoc (c->ts.u.derived, sym->ns)\n+\t  && !c->ts.u.derived->attr.use_assoc\n+\t  && !gfc_check_access (c->ts.u.derived->attr.access,\n+\t\t\t\tc->ts.u.derived->ns->default_access)\n \t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: the component '%s' \"\n \t\t\t     \"is a PRIVATE type and cannot be a component of \"\n \t\t\t     \"'%s', which is PUBLIC at %L\", c->name,\n@@ -9612,18 +9612,18 @@ resolve_fl_derived (gfc_symbol *sym)\n \n       if (sym->attr.sequence)\n \t{\n-\t  if (c->ts.type == BT_DERIVED && c->ts.derived->attr.sequence == 0)\n+\t  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.sequence == 0)\n \t    {\n \t      gfc_error (\"Component %s of SEQUENCE type declared at %L does \"\n \t\t\t \"not have the SEQUENCE attribute\",\n-\t\t\t c->ts.derived->name, &sym->declared_at);\n+\t\t\t c->ts.u.derived->name, &sym->declared_at);\n \t      return FAILURE;\n \t    }\n \t}\n \n       if (c->ts.type == BT_DERIVED && c->attr.pointer\n-\t  && c->ts.derived->components == NULL\n-\t  && !c->ts.derived->attr.zero_comp)\n+\t  && c->ts.u.derived->components == NULL\n+\t  && !c->ts.u.derived->attr.zero_comp)\n \t{\n \t  gfc_error (\"The pointer component '%s' of '%s' at %L is a type \"\n \t\t     \"that has not been declared\", c->name, sym->name,\n@@ -9644,11 +9644,11 @@ resolve_fl_derived (gfc_symbol *sym)\n \t derived type list; even in formal namespaces, where derived type\n \t pointer components might not have been declared.  */\n       if (c->ts.type == BT_DERIVED\n-\t    && c->ts.derived\n-\t    && c->ts.derived->components\n+\t    && c->ts.u.derived\n+\t    && c->ts.u.derived->components\n \t    && c->attr.pointer\n-\t    && sym != c->ts.derived)\n-\tadd_dt_to_dt_list (c->ts.derived);\n+\t    && sym != c->ts.u.derived)\n+\tadd_dt_to_dt_list (c->ts.u.derived);\n \n       if (c->attr.pointer || c->attr.proc_pointer || c->attr.allocatable\n \t  || c->as == NULL)\n@@ -9716,7 +9716,7 @@ resolve_fl_namelist (gfc_symbol *sym)\n \n \t  /* Types with private components that came here by USE-association.  */\n \t  if (nl->sym->ts.type == BT_DERIVED\n-\t      && derived_inaccessible (nl->sym->ts.derived))\n+\t      && derived_inaccessible (nl->sym->ts.u.derived))\n \t    {\n \t      gfc_error (\"NAMELIST object '%s' has use-associated PRIVATE \"\n \t\t\t \"components and cannot be member of namelist '%s' at %L\",\n@@ -9726,8 +9726,8 @@ resolve_fl_namelist (gfc_symbol *sym)\n \n \t  /* Types with private components that are defined in the same module.  */\n \t  if (nl->sym->ts.type == BT_DERIVED\n-\t      && !is_sym_host_assoc (nl->sym->ts.derived, sym->ns)\n-\t      && !gfc_check_access (nl->sym->ts.derived->attr.private_comp\n+\t      && !is_sym_host_assoc (nl->sym->ts.u.derived, sym->ns)\n+\t      && !gfc_check_access (nl->sym->ts.u.derived->attr.private_comp\n \t\t\t\t\t? ACCESS_PRIVATE : ACCESS_UNKNOWN,\n \t\t\t\t\tnl->sym->ns->default_access))\n \t    {\n@@ -9762,15 +9762,15 @@ resolve_fl_namelist (gfc_symbol *sym)\n       if (nl->sym->ts.type != BT_DERIVED)\n \tcontinue;\n \n-      if (nl->sym->ts.derived->attr.alloc_comp)\n+      if (nl->sym->ts.u.derived->attr.alloc_comp)\n \t{\n \t  gfc_error (\"NAMELIST object '%s' in namelist '%s' at %L cannot \"\n \t\t     \"have ALLOCATABLE components\",\n \t\t     nl->sym->name, sym->name, &sym->declared_at);\n \t  return FAILURE;\n \t}\n \n-      if (nl->sym->ts.derived->attr.pointer_comp)\n+      if (nl->sym->ts.u.derived->attr.pointer_comp)\n \t{\n \t  gfc_error (\"NAMELIST object '%s' in namelist '%s' at %L cannot \"\n \t\t     \"have POINTER components\", \n@@ -9954,12 +9954,12 @@ resolve_symbol (gfc_symbol *sym)\n \t\t}\n \t    }\n \t  /* Copy char length.  */\n-\t  if (ifc->ts.cl)\n+\t  if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)\n \t    {\n-\t      sym->ts.cl = gfc_new_charlen (sym->ns);\n-\t      sym->ts.cl->resolved = ifc->ts.cl->resolved;\n-\t      sym->ts.cl->length = gfc_copy_expr (ifc->ts.cl->length);\n-\t      gfc_expr_replace_symbols (sym->ts.cl->length, sym);\n+\t      sym->ts.u.cl = gfc_new_charlen (sym->ns);\n+\t      sym->ts.u.cl->resolved = ifc->ts.u.cl->resolved;\n+\t      sym->ts.u.cl->length = gfc_copy_expr (ifc->ts.u.cl->length);\n+\t      gfc_expr_replace_symbols (sym->ts.u.cl->length, sym);\n \t    }\n \t}\n       else if (sym->ts.interface->name[0] != '\\0')\n@@ -10059,7 +10059,7 @@ resolve_symbol (gfc_symbol *sym)\n \n   if (sym->attr.value && sym->ts.type == BT_CHARACTER)\n     {\n-      gfc_charlen *cl = sym->ts.cl;\n+      gfc_charlen *cl = sym->ts.u.cl;\n       if (!cl || !cl->length || cl->length->expr_type != EXPR_CONSTANT)\n \t{\n \t  gfc_error (\"Character dummy variable '%s' at %L with VALUE \"\n@@ -10111,14 +10111,14 @@ resolve_symbol (gfc_symbol *sym)\n \t  /* If type() declaration, we need to verify that the components\n \t     of the given type are all C interoperable, etc.  */\n \t  if (sym->ts.type == BT_DERIVED &&\n-              sym->ts.derived->attr.is_c_interop != 1)\n+              sym->ts.u.derived->attr.is_c_interop != 1)\n             {\n               /* Make sure the user marked the derived type as BIND(C).  If\n                  not, call the verify routine.  This could print an error\n                  for the derived type more than once if multiple variables\n                  of that type are declared.  */\n-              if (sym->ts.derived->attr.is_bind_c != 1)\n-                verify_bind_c_derived_type (sym->ts.derived);\n+              if (sym->ts.u.derived->attr.is_bind_c != 1)\n+                verify_bind_c_derived_type (sym->ts.u.derived);\n               t = FAILURE;\n             }\n \t  \n@@ -10147,12 +10147,12 @@ resolve_symbol (gfc_symbol *sym)\n      the type is not declared in the scope of the implicit\n      statement. Change the type to BT_UNKNOWN, both because it is so\n      and to prevent an ICE.  */\n-  if (sym->ts.type == BT_DERIVED && sym->ts.derived->components == NULL\n-      && !sym->ts.derived->attr.zero_comp)\n+  if (sym->ts.type == BT_DERIVED && sym->ts.u.derived->components == NULL\n+      && !sym->ts.u.derived->attr.zero_comp)\n     {\n       gfc_error (\"The derived type '%s' at %L is of type '%s', \"\n \t\t \"which has not been defined\", sym->name,\n-\t\t  &sym->declared_at, sym->ts.derived->name);\n+\t\t  &sym->declared_at, sym->ts.u.derived->name);\n       sym->ts.type = BT_UNKNOWN;\n       return;\n     }\n@@ -10161,23 +10161,23 @@ resolve_symbol (gfc_symbol *sym)\n      derived type is visible in the symbol's namespace, if it is a\n      module function and is not PRIVATE.  */\n   if (sym->ts.type == BT_DERIVED\n-\t&& sym->ts.derived->attr.use_assoc\n+\t&& sym->ts.u.derived->attr.use_assoc\n \t&& sym->ns->proc_name\n \t&& sym->ns->proc_name->attr.flavor == FL_MODULE)\n     {\n       gfc_symbol *ds;\n \n-      if (resolve_fl_derived (sym->ts.derived) == FAILURE)\n+      if (resolve_fl_derived (sym->ts.u.derived) == FAILURE)\n \treturn;\n \n-      gfc_find_symbol (sym->ts.derived->name, sym->ns, 1, &ds);\n+      gfc_find_symbol (sym->ts.u.derived->name, sym->ns, 1, &ds);\n       if (!ds && sym->attr.function\n \t    && gfc_check_access (sym->attr.access, sym->ns->default_access))\n \t{\n \t  symtree = gfc_new_symtree (&sym->ns->sym_root,\n-\t\t\t\t     sym->ts.derived->name);\n-\t  symtree->n.sym = sym->ts.derived;\n-\t  sym->ts.derived->refs++;\n+\t\t\t\t     sym->ts.u.derived->name);\n+\t  symtree->n.sym = sym->ts.u.derived;\n+\t  sym->ts.u.derived->refs++;\n \t}\n     }\n \n@@ -10187,15 +10187,15 @@ resolve_symbol (gfc_symbol *sym)\n      161 in 95-006r3.  */\n   if (sym->ts.type == BT_DERIVED\n       && sym->ns->proc_name && sym->ns->proc_name->attr.flavor == FL_MODULE\n-      && !sym->ts.derived->attr.use_assoc\n+      && !sym->ts.u.derived->attr.use_assoc\n       && gfc_check_access (sym->attr.access, sym->ns->default_access)\n-      && !gfc_check_access (sym->ts.derived->attr.access,\n-\t\t\t    sym->ts.derived->ns->default_access)\n+      && !gfc_check_access (sym->ts.u.derived->attr.access,\n+\t\t\t    sym->ts.u.derived->ns->default_access)\n       && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PUBLIC %s '%s' at %L \"\n \t\t         \"of PRIVATE derived type '%s'\",\n \t\t\t (sym->attr.flavor == FL_PARAMETER) ? \"parameter\"\n \t\t\t : \"variable\", sym->name, &sym->declared_at,\n-\t\t\t sym->ts.derived->name) == FAILURE)\n+\t\t\t sym->ts.u.derived->name) == FAILURE)\n     return;\n \n   /* An assumed-size array with INTENT(OUT) shall not be of a type for which\n@@ -10206,7 +10206,7 @@ resolve_symbol (gfc_symbol *sym)\n       && sym->as\n       && sym->as->type == AS_ASSUMED_SIZE)\n     {\n-      for (c = sym->ts.derived->components; c; c = c->next)\n+      for (c = sym->ts.u.derived->components; c; c = c->next)\n \t{\n \t  if (c->initializer)\n \t    {\n@@ -10810,11 +10810,11 @@ sequence_type (gfc_typespec ts)\n   {\n     case BT_DERIVED:\n \n-      if (ts.derived->components == NULL)\n+      if (ts.u.derived->components == NULL)\n \treturn SEQ_NONDEFAULT;\n \n-      result = sequence_type (ts.derived->components->ts);\n-      for (c = ts.derived->components->next; c; c = c->next)\n+      result = sequence_type (ts.u.derived->components->ts);\n+      for (c = ts.u.derived->components->next; c; c = c->next)\n \tif (sequence_type (c->ts) != result)\n \t  return SEQ_MIXED;\n \n@@ -10862,7 +10862,6 @@ sequence_type (gfc_typespec ts)\n static gfc_try\n resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n {\n-  gfc_symbol *d;\n   gfc_component *c = derived->components;\n \n   if (!derived)\n@@ -10886,7 +10885,7 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n       return FAILURE;\n     }\n \n-  if (sym->attr.in_common && has_default_initializer (sym->ts.derived))\n+  if (sym->attr.in_common && has_default_initializer (sym->ts.u.derived))\n     {\n       gfc_error (\"Derived type variable '%s' at %L with default \"\n \t\t \"initialization cannot be in EQUIVALENCE with a variable \"\n@@ -10896,9 +10895,8 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n \n   for (; c ; c = c->next)\n     {\n-      d = c->ts.derived;\n-      if (d\n-\t  && (resolve_equivalence_derived (c->ts.derived, sym, e) == FAILURE))\n+      if (c->ts.type == BT_DERIVED\n+\t  && (resolve_equivalence_derived (c->ts.u.derived, sym, e) == FAILURE))\n \treturn FAILURE;\n \n       /* Shall not be an object of sequence derived type containing a pointer\n@@ -10932,7 +10930,6 @@ static void\n resolve_equivalence (gfc_equiv *eq)\n {\n   gfc_symbol *sym;\n-  gfc_symbol *derived;\n   gfc_symbol *first_sym;\n   gfc_expr *e;\n   gfc_ref *r;\n@@ -10996,11 +10993,11 @@ resolve_equivalence (gfc_equiv *eq)\n \t\t  if (start == NULL)\n \t\t    start = gfc_int_expr (1);\n \t\t  ref->u.ss.start = start;\n-\t\t  if (end == NULL && e->ts.cl)\n-\t\t    end = gfc_copy_expr (e->ts.cl->length);\n+\t\t  if (end == NULL && e->ts.u.cl)\n+\t\t    end = gfc_copy_expr (e->ts.u.cl->length);\n \t\t  ref->u.ss.end = end;\n-\t\t  ref->u.ss.length = e->ts.cl;\n-\t\t  e->ts.cl = NULL;\n+\t\t  ref->u.ss.length = e->ts.u.cl;\n+\t\t  e->ts.u.cl = NULL;\n \t\t}\n \t      ref = ref->next;\n \t      gfc_free (mem);\n@@ -11051,8 +11048,8 @@ resolve_equivalence (gfc_equiv *eq)\n \t  continue;\n \t}\n \n-      derived = e->ts.derived;\n-      if (derived && resolve_equivalence_derived (derived, sym, e) == FAILURE)\n+      if (e->ts.type == BT_DERIVED\n+\t  && resolve_equivalence_derived (e->ts.u.derived, sym, e) == FAILURE)\n \tcontinue;\n \n       /* Check that the types correspond correctly:\n@@ -11185,15 +11182,15 @@ resolve_fntype (gfc_namespace *ns)\n       sym->attr.untyped = 1;\n     }\n \n-  if (sym->ts.type == BT_DERIVED && !sym->ts.derived->attr.use_assoc\n+  if (sym->ts.type == BT_DERIVED && !sym->ts.u.derived->attr.use_assoc\n       && !sym->attr.contained\n-      && !gfc_check_access (sym->ts.derived->attr.access,\n-\t\t\t    sym->ts.derived->ns->default_access)\n+      && !gfc_check_access (sym->ts.u.derived->attr.access,\n+\t\t\t    sym->ts.u.derived->ns->default_access)\n       && gfc_check_access (sym->attr.access, sym->ns->default_access))\n     {\n       gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PUBLIC function '%s' at \"\n \t\t      \"%L of PRIVATE type '%s'\", sym->name,\n-\t\t      &sym->declared_at, sym->ts.derived->name);\n+\t\t      &sym->declared_at, sym->ts.u.derived->name);\n     }\n \n     if (ns->entries)\n@@ -11227,9 +11224,9 @@ check_uop_procedure (gfc_symbol *sym, locus where)\n     }\n \n   if (sym->ts.type == BT_CHARACTER\n-      && !(sym->ts.cl && sym->ts.cl->length)\n-      && !(sym->result && sym->result->ts.cl\n-\t   && sym->result->ts.cl->length))\n+      && !(sym->ts.u.cl && sym->ts.u.cl->length)\n+      && !(sym->result && sym->result->ts.u.cl\n+\t   && sym->result->ts.u.cl->length))\n     {\n       gfc_error (\"User operator procedure '%s' at %L cannot be assumed \"\n \t\t \"character length\", sym->name, &where);"}, {"sha": "fbb88a411afdfa7b423330dc96982e3bcc43db50", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -3217,12 +3217,12 @@ gfc_simplify_len (gfc_expr *e, gfc_expr *kind)\n \t}\n     }\n \n-  if (e->ts.cl != NULL && e->ts.cl->length != NULL\n-      && e->ts.cl->length->expr_type == EXPR_CONSTANT\n-      && e->ts.cl->length->ts.type == BT_INTEGER)\n+  if (e->ts.u.cl != NULL && e->ts.u.cl->length != NULL\n+      && e->ts.u.cl->length->expr_type == EXPR_CONSTANT\n+      && e->ts.u.cl->length->ts.type == BT_INTEGER)\n     {\n       result = gfc_constant_result (BT_INTEGER, k, &e->where);\n-      mpz_set (result->value.integer, e->ts.cl->length->value.integer);\n+      mpz_set (result->value.integer, e->ts.u.cl->length->value.integer);\n       if (gfc_range_check (result) == ARITH_OK)\n \treturn result;\n       else\n@@ -4102,7 +4102,7 @@ gfc_simplify_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n   gfc_array_size (result, &result->shape[0]);\n \n   if (array->ts.type == BT_CHARACTER)\n-    result->ts.cl = array->ts.cl;\n+    result->ts.u.cl = array->ts.u.cl;\n \n   return result;\n }\n@@ -4300,14 +4300,14 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n     }\n \n   /* If we don't know the character length, we can do no more.  */\n-  if (e->ts.cl && e->ts.cl->length\n-\t&& e->ts.cl->length->expr_type == EXPR_CONSTANT)\n+  if (e->ts.u.cl && e->ts.u.cl->length\n+\t&& e->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n     {\n-      len = mpz_get_si (e->ts.cl->length->value.integer);\n+      len = mpz_get_si (e->ts.u.cl->length->value.integer);\n       have_length = true;\n     }\n   else if (e->expr_type == EXPR_CONSTANT\n-\t     && (e->ts.cl == NULL || e->ts.cl->length == NULL))\n+\t     && (e->ts.u.cl == NULL || e->ts.u.cl->length == NULL))\n     {\n       len = e->value.character.length;\n     }\n@@ -4335,7 +4335,7 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n       if (have_length)\n \t{\n \t  mpz_tdiv_q (max, gfc_integer_kinds[i].huge,\n-\t\t      e->ts.cl->length->value.integer);\n+\t\t      e->ts.u.cl->length->value.integer);\n \t}\n       else\n \t{\n@@ -4364,8 +4364,8 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n     return NULL;\n \n   if (len || \n-      (e->ts.cl->length && \n-       mpz_sgn (e->ts.cl->length->value.integer)) != 0)\n+      (e->ts.u.cl->length && \n+       mpz_sgn (e->ts.u.cl->length->value.integer)) != 0)\n     {\n       const char *res = gfc_extract_int (n, &ncop);\n       gcc_assert (res == NULL);\n@@ -5267,7 +5267,7 @@ gfc_simplify_spread (gfc_expr *source, gfc_expr *dim_expr, gfc_expr *ncopies_exp\n     return NULL;\n \n   if (source->ts.type == BT_CHARACTER)\n-    result->ts.cl = source->ts.cl;\n+    result->ts.u.cl = source->ts.u.cl;\n \n   return result;\n }\n@@ -5623,7 +5623,7 @@ gfc_simplify_transpose (gfc_expr *matrix)\n   mpz_set (result->shape[1], matrix->shape[0]);\n \n   if (matrix->ts.type == BT_CHARACTER)\n-    result->ts.cl = matrix->ts.cl;\n+    result->ts.u.cl = matrix->ts.u.cl;\n \n   matrix_rows = mpz_get_si (matrix->shape[0]);\n   matrix_ctor = matrix->value.constructor;\n@@ -5706,7 +5706,7 @@ gfc_simplify_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n   result->shape = gfc_copy_shape (mask->shape, mask->rank);\n \n   if (vector->ts.type == BT_CHARACTER)\n-    result->ts.cl = vector->ts.cl;\n+    result->ts.u.cl = vector->ts.u.cl;\n \n   vector_ctor = vector->value.constructor;\n   mask_ctor = mask->value.constructor;\n@@ -6087,7 +6087,7 @@ gfc_convert_char_constant (gfc_expr *e, bt type ATTRIBUTE_UNUSED, int kind)\n       result->shape = gfc_copy_shape (e->shape, e->rank);\n       result->where = e->where;\n       result->rank = e->rank;\n-      result->ts.cl = e->ts.cl;\n+      result->ts.u.cl = e->ts.u.cl;\n \n       return result;\n     }"}, {"sha": "dc10bc69e4814309577175a0f128eb52a6ec61ee", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -269,10 +269,10 @@ gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n   sym->ts = *ts;\n   sym->attr.implicit_type = 1;\n \n-  if (ts->cl)\n+  if (ts->type == BT_CHARACTER && ts->u.cl)\n     {\n-      sym->ts.cl = gfc_get_charlen ();\n-      *sym->ts.cl = *ts->cl;\n+      sym->ts.u.cl = gfc_get_charlen ();\n+      *sym->ts.u.cl = *ts->u.cl;\n     }\n \n   if (sym->attr.is_bind_c == 1)\n@@ -1774,10 +1774,10 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n     }\n \n   if (sym->attr.extension\n-\t&& gfc_find_component (sym->components->ts.derived, name, true, true))\n+\t&& gfc_find_component (sym->components->ts.u.derived, name, true, true))\n     {\n       gfc_error (\"Component '%s' at %C already in the parent type \"\n-\t\t \"at %L\", name, &sym->components->ts.derived->declared_at);\n+\t\t \"at %L\", name, &sym->components->ts.u.derived->declared_at);\n       return FAILURE;\n     }\n \n@@ -1810,8 +1810,8 @@ switch_types (gfc_symtree *st, gfc_symbol *from, gfc_symbol *to)\n     return;\n \n   sym = st->n.sym;\n-  if (sym->ts.type == BT_DERIVED && sym->ts.derived == from)\n-    sym->ts.derived = to;\n+  if (sym->ts.type == BT_DERIVED && sym->ts.u.derived == from)\n+    sym->ts.u.derived = to;\n \n   switch_types (st->left, from, to);\n   switch_types (st->right, from, to);\n@@ -1863,8 +1863,8 @@ gfc_use_derived (gfc_symbol *sym)\n   for (i = 0; i < GFC_LETTERS; i++)\n     {\n       t = &sym->ns->default_type[i];\n-      if (t->derived == sym)\n-\tt->derived = s;\n+      if (t->u.derived == sym)\n+\tt->u.derived = s;\n     }\n \n   st = gfc_find_symtree (sym->ns->sym_root, sym->name);\n@@ -1917,7 +1917,7 @@ gfc_find_component (gfc_symbol *sym, const char *name,\n \t&& sym->attr.extension\n \t&& sym->components->ts.type == BT_DERIVED)\n     {\n-      p = gfc_find_component (sym->components->ts.derived, name,\n+      p = gfc_find_component (sym->components->ts.u.derived, name,\n \t\t\t      noaccess, silent);\n       /* Do not overwrite the error.  */\n       if (p == NULL)\n@@ -3263,8 +3263,8 @@ gfc_is_var_automatic (gfc_symbol *sym)\n     return true;\n   /* Check for non-constant length character variables.  */\n   if (sym->ts.type == BT_CHARACTER\n-      && sym->ts.cl\n-      && !gfc_is_constant_expr (sym->ts.cl->length))\n+      && sym->ts.u.cl\n+      && !gfc_is_constant_expr (sym->ts.u.cl->length))\n     return true;\n   return false;\n }\n@@ -3481,14 +3481,14 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n       \n       /* BIND(C) derived types must have interoperable components.  */\n       if (curr_comp->ts.type == BT_DERIVED\n-\t  && curr_comp->ts.derived->ts.is_iso_c != 1 \n-          && curr_comp->ts.derived != derived_sym)\n+\t  && curr_comp->ts.u.derived->ts.is_iso_c != 1 \n+          && curr_comp->ts.u.derived != derived_sym)\n         {\n           /* This should be allowed; the draft says a derived-type can not\n              have type parameters if it is has the BIND attribute.  Type\n              parameters seem to be for making parameterized derived types.\n              There's no need to verify the type if it is c_ptr/c_funptr.  */\n-          retval = verify_bind_c_derived_type (curr_comp->ts.derived);\n+          retval = verify_bind_c_derived_type (curr_comp->ts.u.derived);\n \t}\n       else\n \t{\n@@ -3587,10 +3587,10 @@ gen_special_c_interop_ptr (int ptr_id, const char *ptr_name,\n   /* The c_ptr and c_funptr derived types will provide the\n      definition for c_null_ptr and c_null_funptr, respectively.  */\n   if (ptr_id == ISOCBINDING_NULL_PTR)\n-    tmp_sym->ts.derived = get_iso_c_binding_dt (ISOCBINDING_PTR);\n+    tmp_sym->ts.u.derived = get_iso_c_binding_dt (ISOCBINDING_PTR);\n   else\n-    tmp_sym->ts.derived = get_iso_c_binding_dt (ISOCBINDING_FUNPTR);\n-  if (tmp_sym->ts.derived == NULL)\n+    tmp_sym->ts.u.derived = get_iso_c_binding_dt (ISOCBINDING_FUNPTR);\n+  if (tmp_sym->ts.u.derived == NULL)\n     {\n       /* This can occur if the user forgot to declare c_ptr or\n          c_funptr and they're trying to use one of the procedures\n@@ -3603,7 +3603,7 @@ gen_special_c_interop_ptr (int ptr_id, const char *ptr_name,\n \t\t\t\t   ? \"_gfortran_iso_c_binding_c_ptr\"\n \t\t\t\t   : \"_gfortran_iso_c_binding_c_funptr\"));\n \n-      tmp_sym->ts.derived =\n+      tmp_sym->ts.u.derived =\n         get_iso_c_binding_dt (ptr_id == ISOCBINDING_NULL_PTR\n                               ? ISOCBINDING_PTR : ISOCBINDING_FUNPTR);\n     }\n@@ -3624,7 +3624,7 @@ gen_special_c_interop_ptr (int ptr_id, const char *ptr_name,\n   tmp_sym->value = gfc_get_expr ();\n   tmp_sym->value->expr_type = EXPR_STRUCTURE;\n   tmp_sym->value->ts.type = BT_DERIVED;\n-  tmp_sym->value->ts.derived = tmp_sym->ts.derived;\n+  tmp_sym->value->ts.u.derived = tmp_sym->ts.u.derived;\n   /* Create a constructor with no expr, that way we can recognize if the user\n      tries to call the structure constructor for one of the iso_c_binding\n      derived types during resolution (resolve_structure_cons).  */\n@@ -3728,7 +3728,7 @@ gen_cptr_param (gfc_formal_arglist **head,\n       gfc_get_ha_symbol (c_ptr_type, &(c_ptr_sym));\n     }\n \n-  param_sym->ts.derived = c_ptr_sym;\n+  param_sym->ts.u.derived = c_ptr_sym;\n   param_sym->module = gfc_get_string (module_name);\n \n   /* Make new formal arg.  */\n@@ -3956,7 +3956,7 @@ gfc_copy_formal_args_intr (gfc_symbol *dest, gfc_intrinsic_sym *src)\n       formal_arg->sym->attr.dummy = 1;\n \n       if (formal_arg->sym->ts.type == BT_CHARACTER)\n-\tformal_arg->sym->ts.cl = gfc_new_charlen (gfc_current_ns);\n+\tformal_arg->sym->ts.u.cl = gfc_new_charlen (gfc_current_ns);\n \n       /* If this isn't the first arg, set up the next ptr.  For the\n         last arg built, the formal_arg->next will never get set to\n@@ -4219,8 +4219,8 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \ttmp_sym->value->value.character.string[0]\n \t  = (gfc_char_t) c_interop_kinds_table[s].value;\n \ttmp_sym->value->value.character.string[1] = '\\0';\n-\ttmp_sym->ts.cl = gfc_get_charlen ();\n-\ttmp_sym->ts.cl->length = gfc_int_expr (1);\n+\ttmp_sym->ts.u.cl = gfc_get_charlen ();\n+\ttmp_sym->ts.u.cl->length = gfc_int_expr (1);\n \n \t/* May not need this in both attr and ts, but do need in\n \t   attr for writing module file.  */\n@@ -4264,7 +4264,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \n \ttmp_sym->attr.referenced = 1;\n \n-\ttmp_sym->ts.derived = tmp_sym;\n+\ttmp_sym->ts.u.derived = tmp_sym;\n \n         /* Add the symbol created for the derived type to the current ns.  */\n         dt_list_ptr = &(gfc_derived_types);\n@@ -4349,13 +4349,13 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n                   C address of.  */\n \t\ttmp_sym->ts.type = BT_DERIVED;\n                 if (s == ISOCBINDING_LOC)\n-                  tmp_sym->ts.derived =\n+                  tmp_sym->ts.u.derived =\n                     get_iso_c_binding_dt (ISOCBINDING_PTR);\n                 else\n-                  tmp_sym->ts.derived =\n+                  tmp_sym->ts.u.derived =\n                     get_iso_c_binding_dt (ISOCBINDING_FUNPTR);\n \n-                if (tmp_sym->ts.derived == NULL)\n+                if (tmp_sym->ts.u.derived == NULL)\n                   {\n                     /* Create the necessary derived type so we can continue\n                        processing the file.  */\n@@ -4365,7 +4365,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \t\t       (const char *)(s == ISOCBINDING_FUNLOC\n                                 ? \"_gfortran_iso_c_binding_c_funptr\"\n \t\t\t\t: \"_gfortran_iso_c_binding_c_ptr\"));\n-                    tmp_sym->ts.derived =\n+                    tmp_sym->ts.u.derived =\n                       get_iso_c_binding_dt (s == ISOCBINDING_FUNLOC\n                                             ? ISOCBINDING_FUNPTR\n                                             : ISOCBINDING_PTR);\n@@ -4517,9 +4517,9 @@ gfc_get_derived_super_type (gfc_symbol* derived)\n \n   gcc_assert (derived->components);\n   gcc_assert (derived->components->ts.type == BT_DERIVED);\n-  gcc_assert (derived->components->ts.derived);\n+  gcc_assert (derived->components->ts.u.derived);\n \n-  return derived->components->ts.derived;\n+  return derived->components->ts.u.derived;\n }\n \n "}, {"sha": "e19a7d34e0a1ab0e116930ba9d9e4c8762f5019c", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -229,7 +229,7 @@ encode_derived (gfc_expr *source, unsigned char *buffer, size_t buffer_size)\n   type = gfc_typenode_for_spec (&source->ts);\n \n   ctr = source->value.constructor;\n-  cmp = source->ts.derived->components;\n+  cmp = source->ts.u.derived->components;\n   for (;ctr; ctr = ctr->next, cmp = cmp->next)\n     {\n       gcc_assert (cmp);\n@@ -435,9 +435,9 @@ gfc_interpret_character (unsigned char *buffer, size_t buffer_size,\n {\n   int i;\n \n-  if (result->ts.cl && result->ts.cl->length)\n+  if (result->ts.u.cl && result->ts.u.cl->length)\n     result->value.character.length =\n-      (int) mpz_get_ui (result->ts.cl->length->value.integer);\n+      (int) mpz_get_ui (result->ts.u.cl->length->value.integer);\n \n   gcc_assert (buffer_size >= size_character (result->value.character.length,\n \t\t\t\t\t     result->ts.kind));\n@@ -484,7 +484,7 @@ gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *resu\n   result->expr_type = EXPR_STRUCTURE;\n \n   type = gfc_typenode_for_spec (&result->ts);\n-  cmp = result->ts.derived->components;\n+  cmp = result->ts.u.derived->components;\n \n   /* Run through the derived type components.  */\n   for (;cmp; cmp = cmp->next)\n@@ -633,7 +633,7 @@ expr_to_char (gfc_expr *e, unsigned char *data, unsigned char *chk, size_t len)\n   if (e->ts.type == BT_DERIVED)\n     {\n       ctr = e->value.constructor;\n-      cmp = e->ts.derived->components;\n+      cmp = e->ts.u.derived->components;\n       for (;ctr; ctr = ctr->next, cmp = cmp->next)\n \t{\n \t  gcc_assert (cmp && cmp->backend_decl);"}, {"sha": "529a6b10495b49d576d14535e7a12f5f62db5330", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -1533,7 +1533,7 @@ get_array_ctor_var_strlen (gfc_expr * expr, tree * len)\n \t}\n     }\n \n-  *len = ts->cl->backend_decl;\n+  *len = ts->u.cl->backend_decl;\n }\n \n \n@@ -1549,12 +1549,12 @@ get_array_ctor_all_strlen (stmtblock_t *block, gfc_expr *e, tree *len)\n   if (*len && INTEGER_CST_P (*len))\n     return;\n \n-  if (!e->ref && e->ts.cl && e->ts.cl->length\n-\t&& e->ts.cl->length->expr_type == EXPR_CONSTANT)\n+  if (!e->ref && e->ts.u.cl && e->ts.u.cl->length\n+\t&& e->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n     {\n       /* This is easy.  */\n-      gfc_conv_const_charlen (e->ts.cl);\n-      *len = e->ts.cl->backend_decl;\n+      gfc_conv_const_charlen (e->ts.u.cl);\n+      *len = e->ts.u.cl->backend_decl;\n     }\n   else\n     {\n@@ -1575,7 +1575,7 @@ get_array_ctor_all_strlen (stmtblock_t *block, gfc_expr *e, tree *len)\n       gfc_add_block_to_block (block, &se.pre);\n       gfc_add_block_to_block (block, &se.post);\n \n-      e->ts.cl->backend_decl = *len;\n+      e->ts.u.cl->backend_decl = *len;\n     }\n }\n \n@@ -1825,8 +1825,8 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n \n   /* Do bounds-checking here and in gfc_trans_array_ctor_element only if no\n      typespec was given for the array constructor.  */\n-  typespec_chararray_ctor = (ss->expr->ts.cl\n-\t\t\t     && ss->expr->ts.cl->length_from_typespec);\n+  typespec_chararray_ctor = (ss->expr->ts.u.cl\n+\t\t\t     && ss->expr->ts.u.cl->length_from_typespec);\n \n   if ((gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n       && ss->expr->ts.type == BT_CHARACTER && !typespec_chararray_ctor)\n@@ -1845,14 +1845,14 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n       /* get_array_ctor_strlen walks the elements of the constructor, if a\n \t typespec was given, we already know the string length and want the one\n \t specified there.  */\n-      if (typespec_chararray_ctor && ss->expr->ts.cl->length\n-\t  && ss->expr->ts.cl->length->expr_type != EXPR_CONSTANT)\n+      if (typespec_chararray_ctor && ss->expr->ts.u.cl->length\n+\t  && ss->expr->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n \t{\n \t  gfc_se length_se;\n \n \t  const_string = false;\n \t  gfc_init_se (&length_se, NULL);\n-\t  gfc_conv_expr_type (&length_se, ss->expr->ts.cl->length,\n+\t  gfc_conv_expr_type (&length_se, ss->expr->ts.u.cl->length,\n \t\t\t      gfc_charlen_type_node);\n \t  ss->string_length = length_se.expr;\n \t  gfc_add_block_to_block (&loop->pre, &length_se.pre);\n@@ -1866,7 +1866,7 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n \t and not end up here.  */\n       gcc_assert (ss->string_length);\n \n-      ss->expr->ts.cl->backend_decl = ss->string_length;\n+      ss->expr->ts.u.cl->backend_decl = ss->string_length;\n \n       type = gfc_get_character_type_len (ss->expr->ts.kind, ss->string_length);\n       if (const_string)\n@@ -2096,11 +2096,11 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \tcase GFC_SS_CONSTRUCTOR:\n \t  if (ss->expr->ts.type == BT_CHARACTER\n \t\t&& ss->string_length == NULL\n-\t\t&& ss->expr->ts.cl\n-\t\t&& ss->expr->ts.cl->length)\n+\t\t&& ss->expr->ts.u.cl\n+\t\t&& ss->expr->ts.u.cl->length)\n \t    {\n \t      gfc_init_se (&se, NULL);\n-\t      gfc_conv_expr_type (&se, ss->expr->ts.cl->length,\n+\t      gfc_conv_expr_type (&se, ss->expr->ts.u.cl->length,\n \t\t\t\t  gfc_charlen_type_node);\n \t      ss->string_length = se.expr;\n \t      gfc_add_block_to_block (&loop->pre, &se.pre);\n@@ -4002,9 +4002,9 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   gfc_conv_descriptor_offset_set (&se->pre, se->expr, offset);\n \n   if (expr->ts.type == BT_DERIVED\n-\t&& expr->ts.derived->attr.alloc_comp)\n+\t&& expr->ts.u.derived->attr.alloc_comp)\n     {\n-      tmp = gfc_nullify_alloc_comp (expr->ts.derived, se->expr,\n+      tmp = gfc_nullify_alloc_comp (expr->ts.u.derived, se->expr,\n \t\t\t\t    ref->u.ar.as->rank);\n       gfc_add_expr_to_block (&se->pre, tmp);\n     }\n@@ -4290,9 +4290,9 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n   /* Evaluate character string length.  */\n   if (sym->ts.type == BT_CHARACTER\n-      && onstack && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n+      && onstack && !INTEGER_CST_P (sym->ts.u.cl->backend_decl))\n     {\n-      gfc_conv_string_length (sym->ts.cl, NULL, &block);\n+      gfc_conv_string_length (sym->ts.u.cl, NULL, &block);\n \n       gfc_trans_vla_type_sizes (sym, &block);\n \n@@ -4315,8 +4315,8 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n   gcc_assert (!sym->module);\n \n   if (sym->ts.type == BT_CHARACTER\n-      && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n-    gfc_conv_string_length (sym->ts.cl, NULL, &block);\n+      && !INTEGER_CST_P (sym->ts.u.cl->backend_decl))\n+    gfc_conv_string_length (sym->ts.u.cl, NULL, &block);\n \n   size = gfc_trans_array_bounds (type, sym, &offset, &block);\n \n@@ -4381,8 +4381,8 @@ gfc_trans_g77_array (gfc_symbol * sym, tree body)\n   gfc_start_block (&block);\n \n   if (sym->ts.type == BT_CHARACTER\n-      && TREE_CODE (sym->ts.cl->backend_decl) == VAR_DECL)\n-    gfc_conv_string_length (sym->ts.cl, NULL, &block);\n+      && TREE_CODE (sym->ts.u.cl->backend_decl) == VAR_DECL)\n+    gfc_conv_string_length (sym->ts.u.cl, NULL, &block);\n \n   /* Evaluate the bounds of the array.  */\n   gfc_trans_array_bounds (type, sym, &offset, &block);\n@@ -4474,8 +4474,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n   gfc_start_block (&block);\n \n   if (sym->ts.type == BT_CHARACTER\n-      && TREE_CODE (sym->ts.cl->backend_decl) == VAR_DECL)\n-    gfc_conv_string_length (sym->ts.cl, NULL, &block);\n+      && TREE_CODE (sym->ts.u.cl->backend_decl) == VAR_DECL)\n+    gfc_conv_string_length (sym->ts.u.cl, NULL, &block);\n \n   checkparm = (sym->as->type == AS_EXPLICIT\n \t       && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS));\n@@ -4867,11 +4867,11 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n   gfc_actual_arglist *arg;\n   gfc_se tse;\n \n-  if (expr->ts.cl->length\n-\t&& gfc_is_constant_expr (expr->ts.cl->length))\n+  if (expr->ts.u.cl->length\n+\t&& gfc_is_constant_expr (expr->ts.u.cl->length))\n     {\n-      if (!expr->ts.cl->backend_decl)\n-\tgfc_conv_string_length (expr->ts.cl, expr, &se->pre);\n+      if (!expr->ts.u.cl->backend_decl)\n+\tgfc_conv_string_length (expr->ts.u.cl, expr, &se->pre);\n       return;\n     }\n \n@@ -4880,11 +4880,11 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n     case EXPR_OP:\n       get_array_charlen (expr->value.op.op1, se);\n \n-      /* For parentheses the expression ts.cl is identical.  */\n+      /* For parentheses the expression ts.u.cl is identical.  */\n       if (expr->value.op.op == INTRINSIC_PARENTHESES)\n \treturn;\n \n-     expr->ts.cl->backend_decl =\n+     expr->ts.u.cl->backend_decl =\n \t\tgfc_create_var (gfc_charlen_type_node, \"sln\");\n \n       if (expr->value.op.op2)\n@@ -4895,21 +4895,21 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n \n \t  /* Add the string lengths and assign them to the expression\n \t     string length backend declaration.  */\n-\t  gfc_add_modify (&se->pre, expr->ts.cl->backend_decl,\n+\t  gfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl,\n \t\t\t  fold_build2 (PLUS_EXPR, gfc_charlen_type_node,\n-\t\t\t\texpr->value.op.op1->ts.cl->backend_decl,\n-\t\t\t\texpr->value.op.op2->ts.cl->backend_decl));\n+\t\t\t\texpr->value.op.op1->ts.u.cl->backend_decl,\n+\t\t\t\texpr->value.op.op2->ts.u.cl->backend_decl));\n \t}\n       else\n-\tgfc_add_modify (&se->pre, expr->ts.cl->backend_decl,\n-\t\t\texpr->value.op.op1->ts.cl->backend_decl);\n+\tgfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl,\n+\t\t\texpr->value.op.op1->ts.u.cl->backend_decl);\n       break;\n \n     case EXPR_FUNCTION:\n       if (expr->value.function.esym == NULL\n-\t    || expr->ts.cl->length->expr_type == EXPR_CONSTANT)\n+\t    || expr->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n \t{\n-\t  gfc_conv_string_length (expr->ts.cl, expr, &se->pre);\n+\t  gfc_conv_string_length (expr->ts.u.cl, expr, &se->pre);\n \t  break;\n \t}\n \n@@ -4932,19 +4932,19 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n       gfc_init_se (&tse, NULL);\n \n       /* Build the expression for the character length and convert it.  */\n-      gfc_apply_interface_mapping (&mapping, &tse, expr->ts.cl->length);\n+      gfc_apply_interface_mapping (&mapping, &tse, expr->ts.u.cl->length);\n \n       gfc_add_block_to_block (&se->pre, &tse.pre);\n       gfc_add_block_to_block (&se->post, &tse.post);\n       tse.expr = fold_convert (gfc_charlen_type_node, tse.expr);\n       tse.expr = fold_build2 (MAX_EXPR, gfc_charlen_type_node, tse.expr,\n \t\t\t      build_int_cst (gfc_charlen_type_node, 0));\n-      expr->ts.cl->backend_decl = tse.expr;\n+      expr->ts.u.cl->backend_decl = tse.expr;\n       gfc_free_interface_mapping (&mapping);\n       break;\n \n     default:\n-      gfc_conv_string_length (expr->ts.cl, expr, &se->pre);\n+      gfc_conv_string_length (expr->ts.u.cl, expr, &se->pre);\n       break;\n     }\n }\n@@ -5085,7 +5085,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  /* Elemental function.  */\n \t  need_tmp = 1;\n \t  if (expr->ts.type == BT_CHARACTER\n-\t\t&& expr->ts.cl->length->expr_type != EXPR_CONSTANT)\n+\t\t&& expr->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n \t    get_array_charlen (expr, se);\n \n \t  info = NULL;\n@@ -5147,13 +5147,13 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       loop.temp_ss->next = gfc_ss_terminator;\n \n       if (expr->ts.type == BT_CHARACTER\n-\t    && !expr->ts.cl->backend_decl)\n+\t    && !expr->ts.u.cl->backend_decl)\n \tget_array_charlen (expr, se);\n \n       loop.temp_ss->data.temp.type = gfc_typenode_for_spec (&expr->ts);\n \n       if (expr->ts.type == BT_CHARACTER)\n-\tloop.temp_ss->string_length = expr->ts.cl->backend_decl;\n+\tloop.temp_ss->string_length = expr->ts.u.cl->backend_decl;\n       else\n \tloop.temp_ss->string_length = NULL;\n \n@@ -5469,7 +5469,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n   if (expr->expr_type == EXPR_ARRAY && expr->ts.type == BT_CHARACTER)\n     {\n       get_array_ctor_strlen (&se->pre, expr->value.constructor, &tmp);\n-      expr->ts.cl->backend_decl = tmp;\n+      expr->ts.u.cl->backend_decl = tmp;\n       se->string_length = tmp;\n     }\n \n@@ -5486,7 +5486,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n       tmp = gfc_get_symbol_decl (sym);\n \n       if (sym->ts.type == BT_CHARACTER)\n-\tse->string_length = sym->ts.cl->backend_decl;\n+\tse->string_length = sym->ts.u.cl->backend_decl;\n       if (!sym->attr.pointer && sym->as->type != AS_ASSUMED_SHAPE \n           && !sym->attr.allocatable)\n         {\n@@ -5543,12 +5543,12 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n   /* Deallocate the allocatable components of structures that are\n      not variable.  */\n   if (expr->ts.type == BT_DERIVED\n-\t&& expr->ts.derived->attr.alloc_comp\n+\t&& expr->ts.u.derived->attr.alloc_comp\n \t&& expr->expr_type != EXPR_VARIABLE)\n     {\n       tmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t     se->expr);\n-      tmp = gfc_deallocate_alloc_comp (expr->ts.derived, tmp, expr->rank);\n+      tmp = gfc_deallocate_alloc_comp (expr->ts.u.derived, tmp, expr->rank);\n       gfc_add_expr_to_block (&se->post, tmp);\n     }\n \n@@ -5854,7 +5854,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n   for (c = der_type->components; c; c = c->next)\n     {\n       bool cmp_has_alloc_comps = (c->ts.type == BT_DERIVED)\n-\t\t\t\t    && c->ts.derived->attr.alloc_comp;\n+\t\t\t\t    && c->ts.u.derived->attr.alloc_comp;\n       cdecl = c->backend_decl;\n       ctype = TREE_TYPE (cdecl);\n \n@@ -5868,7 +5868,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      comp = fold_build3 (COMPONENT_REF, ctype,\n \t\t\t\t  decl, cdecl, NULL_TREE);\n \t      rank = c->as ? c->as->rank : 0;\n-\t      tmp = structure_alloc_comps (c->ts.derived, comp, NULL_TREE,\n+\t      tmp = structure_alloc_comps (c->ts.u.derived, comp, NULL_TREE,\n \t\t\t\t\t   rank, purpose);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n@@ -5896,7 +5896,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      comp = fold_build3 (COMPONENT_REF, ctype,\n \t\t\t\t  decl, cdecl, NULL_TREE);\n \t      rank = c->as ? c->as->rank : 0;\n-\t      tmp = structure_alloc_comps (c->ts.derived, comp, NULL_TREE,\n+\t      tmp = structure_alloc_comps (c->ts.u.derived, comp, NULL_TREE,\n \t\t\t\t\t   rank, purpose);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n@@ -5922,7 +5922,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      rank = c->as ? c->as->rank : 0;\n \t      tmp = fold_convert (TREE_TYPE (dcmp), comp);\n \t      gfc_add_modify (&fnblock, dcmp, tmp);\n-\t      tmp = structure_alloc_comps (c->ts.derived, comp, dcmp,\n+\t      tmp = structure_alloc_comps (c->ts.u.derived, comp, dcmp,\n \t\t\t\t\t   rank, purpose);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n@@ -5985,7 +5985,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n   bool sym_has_alloc_comp;\n \n   sym_has_alloc_comp = (sym->ts.type == BT_DERIVED)\n-\t\t\t  && sym->ts.derived->attr.alloc_comp;\n+\t\t\t  && sym->ts.u.derived->attr.alloc_comp;\n \n   /* Make sure the frontend gets these right.  */\n   if (!(sym->attr.pointer || sym->attr.allocatable || sym_has_alloc_comp))\n@@ -5999,9 +5999,9 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n \t\t|| TREE_CODE (sym->backend_decl) == PARM_DECL);\n \n   if (sym->ts.type == BT_CHARACTER\n-      && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n+      && !INTEGER_CST_P (sym->ts.u.cl->backend_decl))\n     {\n-      gfc_conv_string_length (sym->ts.cl, NULL, &fnblock);\n+      gfc_conv_string_length (sym->ts.u.cl, NULL, &fnblock);\n       gfc_trans_vla_type_sizes (sym, &fnblock);\n     }\n \n@@ -6035,7 +6035,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n       if (!sym->attr.save)\n \t{\n \t  rank = sym->as ? sym->as->rank : 0;\n-\t  tmp = gfc_nullify_alloc_comp (sym->ts.derived, descriptor, rank);\n+\t  tmp = gfc_nullify_alloc_comp (sym->ts.u.derived, descriptor, rank);\n \t  gfc_add_expr_to_block (&fnblock, tmp);\n \t  if (sym->value)\n \t    {\n@@ -6068,7 +6068,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n     {\n       int rank;\n       rank = sym->as ? sym->as->rank : 0;\n-      tmp = gfc_deallocate_alloc_comp (sym->ts.derived, descriptor, rank);\n+      tmp = gfc_deallocate_alloc_comp (sym->ts.u.derived, descriptor, rank);\n       gfc_add_expr_to_block (&fnblock, tmp);\n     }\n "}, {"sha": "5b1952aee4a7f911aa03885e1210a2583c0146d2", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -132,7 +132,7 @@ get_segment_info (gfc_symbol * sym, HOST_WIDE_INT offset)\n \n   /* Make sure we've got the character length.  */\n   if (sym->ts.type == BT_CHARACTER)\n-    gfc_conv_const_charlen (sym->ts.cl);\n+    gfc_conv_const_charlen (sym->ts.u.cl);\n \n   /* Create the segment_info and fill it in.  */\n   s = (segment_info *) gfc_getmem (sizeof (segment_info));\n@@ -830,7 +830,7 @@ calculate_offset (gfc_expr *e)\n           case AR_ELEMENT:\n \t    n = element_number (&reference->u.ar);\n \t    if (element_type->type == BT_CHARACTER)\n-\t      gfc_conv_const_charlen (element_type->cl);\n+\t      gfc_conv_const_charlen (element_type->u.cl);\n \t    element_size =\n               int_size_in_bytes (gfc_typenode_for_spec (element_type));\n \t    offset += n * element_size;"}, {"sha": "035f40b125cc73867f24e60c9e0b178c9399ccbf", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -342,8 +342,8 @@ gfc_conv_constant (gfc_se * se, gfc_expr * expr)\n   /* We may be receiving an expression for C_NULL_PTR or C_NULL_FUNPTR.  If\n      so, they expr_type will not yet be an EXPR_CONSTANT.  We need to make\n      it so here.  */\n-  if (expr->ts.type == BT_DERIVED && expr->ts.derived\n-      && expr->ts.derived->attr.is_iso_c)\n+  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived\n+      && expr->ts.u.derived->attr.is_iso_c)\n     {\n       if (expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_PTR \n           || expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_FUNPTR)"}, {"sha": "ceabbbe0b98921a4fd3fe1dfbbd59729ca47c075", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -796,7 +796,7 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n \n   /* Do we know the element size?  */\n   known_size = sym->ts.type != BT_CHARACTER\n-\t  || INTEGER_CST_P (sym->ts.cl->backend_decl);\n+\t  || INTEGER_CST_P (sym->ts.u.cl->backend_decl);\n   \n   if (known_size && !GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (type)))\n     {\n@@ -928,10 +928,10 @@ gfc_nonlocal_dummy_array_decl (gfc_symbol *sym)\n static tree\n gfc_create_string_length (gfc_symbol * sym)\n {\n-  gcc_assert (sym->ts.cl);\n-  gfc_conv_const_charlen (sym->ts.cl);\n+  gcc_assert (sym->ts.u.cl);\n+  gfc_conv_const_charlen (sym->ts.u.cl);\n \n-  if (sym->ts.cl->backend_decl == NULL_TREE)\n+  if (sym->ts.u.cl->backend_decl == NULL_TREE)\n     {\n       tree length;\n       char name[GFC_MAX_MANGLED_SYMBOL_LEN + 2];\n@@ -947,11 +947,11 @@ gfc_create_string_length (gfc_symbol * sym)\n       if (sym->ns->proc_name->tlink != NULL)\n \tgfc_defer_symbol_init (sym);\n \n-      sym->ts.cl->backend_decl = length;\n+      sym->ts.u.cl->backend_decl = length;\n     }\n \n-  gcc_assert (sym->ts.cl->backend_decl != NULL_TREE);\n-  return sym->ts.cl->backend_decl;\n+  gcc_assert (sym->ts.u.cl->backend_decl != NULL_TREE);\n+  return sym->ts.u.cl->backend_decl;\n }\n \n /* If a variable is assigned a label, we add another two auxiliary\n@@ -1050,10 +1050,10 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       /* Create a character length variable.  */\n       if (sym->ts.type == BT_CHARACTER)\n \t{\n-\t  if (sym->ts.cl->backend_decl == NULL_TREE)\n+\t  if (sym->ts.u.cl->backend_decl == NULL_TREE)\n \t    length = gfc_create_string_length (sym);\n \t  else\n-\t    length = sym->ts.cl->backend_decl;\n+\t    length = sym->ts.u.cl->backend_decl;\n \t  if (TREE_CODE (length) == VAR_DECL\n \t      && DECL_CONTEXT (length) == NULL_TREE)\n \t    {\n@@ -1118,7 +1118,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t  if (s && s->backend_decl)\n \t    {\n \t      if (sym->ts.type == BT_CHARACTER)\n-\t\tsym->ts.cl->backend_decl = s->ts.cl->backend_decl;\n+\t\tsym->ts.u.cl->backend_decl = s->ts.u.cl->backend_decl;\n \t      return s->backend_decl;\n \t    }\n \t}\n@@ -1171,7 +1171,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \tGFC_DECL_PACKED_ARRAY (decl) = 1;\n     }\n \n-  if (sym->ts.type == BT_DERIVED && sym->ts.derived->attr.alloc_comp)\n+  if (sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.alloc_comp)\n     gfc_defer_symbol_init (sym);\n   /* This applies a derived type default initializer.  */\n   else if (sym->ts.type == BT_DERIVED\n@@ -1696,9 +1696,9 @@ create_function_arglist (gfc_symbol * sym)\n \t\t\t       PARM_DECL,\n \t\t\t       get_identifier (\".__result\"),\n \t\t\t       len_type);\n-\t  if (!sym->ts.cl->length)\n+\t  if (!sym->ts.u.cl->length)\n \t    {\n-\t      sym->ts.cl->backend_decl = length;\n+\t      sym->ts.u.cl->backend_decl = length;\n \t      TREE_USED (length) = 1;\n \t    }\n \t  gcc_assert (TREE_CODE (length) == PARM_DECL);\n@@ -1707,21 +1707,21 @@ create_function_arglist (gfc_symbol * sym)\n \t  TREE_READONLY (length) = 1;\n \t  DECL_ARTIFICIAL (length) = 1;\n \t  gfc_finish_decl (length);\n-\t  if (sym->ts.cl->backend_decl == NULL\n-\t      || sym->ts.cl->backend_decl == length)\n+\t  if (sym->ts.u.cl->backend_decl == NULL\n+\t      || sym->ts.u.cl->backend_decl == length)\n \t    {\n \t      gfc_symbol *arg;\n \t      tree backend_decl;\n \n-\t      if (sym->ts.cl->backend_decl == NULL)\n+\t      if (sym->ts.u.cl->backend_decl == NULL)\n \t\t{\n \t\t  tree len = build_decl (input_location,\n \t\t\t\t\t VAR_DECL,\n \t\t\t\t\t get_identifier (\"..__result\"),\n \t\t\t\t\t gfc_charlen_type_node);\n \t\t  DECL_ARTIFICIAL (len) = 1;\n \t\t  TREE_USED (len) = 1;\n-\t\t  sym->ts.cl->backend_decl = len;\n+\t\t  sym->ts.u.cl->backend_decl = len;\n \t\t}\n \n \t      /* Make sure PARM_DECL type doesn't point to incomplete type.  */\n@@ -1791,38 +1791,38 @@ create_function_arglist (gfc_symbol * sym)\n \t  gfc_finish_decl (length);\n \n \t  /* Remember the passed value.  */\n-          if (f->sym->ts.cl->passed_length != NULL)\n+          if (f->sym->ts.u.cl->passed_length != NULL)\n             {\n \t      /* This can happen if the same type is used for multiple\n \t\t arguments. We need to copy cl as otherwise\n \t\t cl->passed_length gets overwritten.  */\n \t      gfc_charlen *cl, *cl2;\n-\t      cl = f->sym->ts.cl;\n-\t      f->sym->ts.cl = gfc_get_charlen();\n-\t      f->sym->ts.cl->length = cl->length;\n-\t      f->sym->ts.cl->backend_decl = cl->backend_decl;\n-\t      f->sym->ts.cl->length_from_typespec = cl->length_from_typespec;\n-\t      f->sym->ts.cl->resolved = cl->resolved;\n-\t      cl2 = f->sym->ts.cl->next;\n-\t      f->sym->ts.cl->next = cl;\n+\t      cl = f->sym->ts.u.cl;\n+\t      f->sym->ts.u.cl = gfc_get_charlen();\n+\t      f->sym->ts.u.cl->length = cl->length;\n+\t      f->sym->ts.u.cl->backend_decl = cl->backend_decl;\n+\t      f->sym->ts.u.cl->length_from_typespec = cl->length_from_typespec;\n+\t      f->sym->ts.u.cl->resolved = cl->resolved;\n+\t      cl2 = f->sym->ts.u.cl->next;\n+\t      f->sym->ts.u.cl->next = cl;\n               cl->next = cl2;\n             }\n-\t  f->sym->ts.cl->passed_length = length;\n+\t  f->sym->ts.u.cl->passed_length = length;\n \n \t  /* Use the passed value for assumed length variables.  */\n-\t  if (!f->sym->ts.cl->length)\n+\t  if (!f->sym->ts.u.cl->length)\n \t    {\n \t      TREE_USED (length) = 1;\n-\t      gcc_assert (!f->sym->ts.cl->backend_decl);\n-\t      f->sym->ts.cl->backend_decl = length;\n+\t      gcc_assert (!f->sym->ts.u.cl->backend_decl);\n+\t      f->sym->ts.u.cl->backend_decl = length;\n \t    }\n \n \t  hidden_typelist = TREE_CHAIN (hidden_typelist);\n \n-\t  if (f->sym->ts.cl->backend_decl == NULL\n-\t      || f->sym->ts.cl->backend_decl == length)\n+\t  if (f->sym->ts.u.cl->backend_decl == NULL\n+\t      || f->sym->ts.u.cl->backend_decl == length)\n \t    {\n-\t      if (f->sym->ts.cl->backend_decl == NULL)\n+\t      if (f->sym->ts.u.cl->backend_decl == NULL)\n \t\tgfc_create_string_length (f->sym);\n \n \t      /* Make sure PARM_DECL type doesn't point to incomplete type.  */\n@@ -1993,7 +1993,7 @@ build_entry_thunks (gfc_namespace * ns)\n \t\t\t\targs);\n \t      if (formal->sym->ts.type == BT_CHARACTER)\n \t\t{\n-\t\t  tmp = thunk_formal->sym->ts.cl->backend_decl;\n+\t\t  tmp = thunk_formal->sym->ts.u.cl->backend_decl;\n \t\t  string_args = tree_cons (NULL_TREE, tmp, string_args);\n \t\t}\n \t    }\n@@ -2090,15 +2090,15 @@ build_entry_thunks (gfc_namespace * ns)\n \t  {\n \t    formal->sym->backend_decl = NULL_TREE;\n \t    if (formal->sym->ts.type == BT_CHARACTER)\n-\t      formal->sym->ts.cl->backend_decl = NULL_TREE;\n+\t      formal->sym->ts.u.cl->backend_decl = NULL_TREE;\n \t  }\n \n       if (thunk_sym->attr.function)\n \t{\n \t  if (thunk_sym->ts.type == BT_CHARACTER)\n-\t    thunk_sym->ts.cl->backend_decl = NULL_TREE;\n+\t    thunk_sym->ts.u.cl->backend_decl = NULL_TREE;\n \t  if (thunk_sym->result->ts.type == BT_CHARACTER)\n-\t    thunk_sym->result->ts.cl->backend_decl = NULL_TREE;\n+\t    thunk_sym->result->ts.u.cl->backend_decl = NULL_TREE;\n \t}\n     }\n \n@@ -2207,10 +2207,10 @@ gfc_get_fake_result_decl (gfc_symbol * sym, int parent_flag)\n \n   if (sym->ts.type == BT_CHARACTER)\n     {\n-      if (sym->ts.cl->backend_decl == NULL_TREE)\n+      if (sym->ts.u.cl->backend_decl == NULL_TREE)\n \tlength = gfc_create_string_length (sym);\n       else\n-\tlength = sym->ts.cl->backend_decl;\n+\tlength = sym->ts.u.cl->backend_decl;\n       if (TREE_CODE (length) == VAR_DECL\n \t  && DECL_CONTEXT (length) == NULL_TREE)\n \tgfc_add_decl_to_function (length);\n@@ -2816,12 +2816,12 @@ gfc_trans_auto_character_variable (gfc_symbol * sym, tree fnbody)\n   tree tmp;\n \n   gcc_assert (sym->backend_decl);\n-  gcc_assert (sym->ts.cl && sym->ts.cl->length);\n+  gcc_assert (sym->ts.u.cl && sym->ts.u.cl->length);\n \n   gfc_start_block (&body);\n \n   /* Evaluate the string length expression.  */\n-  gfc_conv_string_length (sym->ts.cl, NULL, &body);\n+  gfc_conv_string_length (sym->ts.u.cl, NULL, &body);\n \n   gfc_trans_vla_type_sizes (sym, &body);\n \n@@ -3009,9 +3009,9 @@ init_intent_out_dt (gfc_symbol * proc_sym, tree body)\n \t&& !f->sym->attr.pointer\n \t&& f->sym->ts.type == BT_DERIVED)\n       {\n-\tif (f->sym->ts.derived->attr.alloc_comp)\n+\tif (f->sym->ts.u.derived->attr.alloc_comp)\n \t  {\n-\t    tmp = gfc_deallocate_alloc_comp (f->sym->ts.derived,\n+\t    tmp = gfc_deallocate_alloc_comp (f->sym->ts.u.derived,\n \t\t\t\t\t     f->sym->backend_decl,\n \t\t\t\t\t     f->sym->as ? f->sym->as->rank : 0);\n \n@@ -3022,7 +3022,7 @@ init_intent_out_dt (gfc_symbol * proc_sym, tree body)\n \t    gfc_add_expr_to_block (&fnblock, tmp);\n \t  }\n \n-\tif (!f->sym->ts.derived->attr.alloc_comp\n+\tif (!f->sym->ts.u.derived->attr.alloc_comp\n \t      && f->sym->value)\n \t  body = gfc_init_default_dt (f->sym, body);\n       }\n@@ -3073,14 +3073,14 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \n \t  /* An automatic character length, pointer array result.  */\n \t  if (proc_sym->ts.type == BT_CHARACTER\n-\t\t&& TREE_CODE (proc_sym->ts.cl->backend_decl) == VAR_DECL)\n-\t    fnbody = gfc_trans_dummy_character (proc_sym, proc_sym->ts.cl,\n+\t\t&& TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)\n+\t    fnbody = gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl,\n \t\t\t\t\t\tfnbody);\n \t}\n       else if (proc_sym->ts.type == BT_CHARACTER)\n \t{\n-\t  if (TREE_CODE (proc_sym->ts.cl->backend_decl) == VAR_DECL)\n-\t    fnbody = gfc_trans_dummy_character (proc_sym, proc_sym->ts.cl,\n+\t  if (TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)\n+\t    fnbody = gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl,\n \t\t\t\t\t\tfnbody);\n \t}\n       else\n@@ -3096,7 +3096,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n   for (sym = proc_sym->tlink; sym != proc_sym; sym = sym->tlink)\n     {\n       bool sym_has_alloc_comp = (sym->ts.type == BT_DERIVED)\n-\t\t\t\t   && sym->ts.derived->attr.alloc_comp;\n+\t\t\t\t   && sym->ts.u.derived->attr.alloc_comp;\n       if (sym->attr.dimension)\n \t{\n \t  switch (sym->as->type)\n@@ -3170,7 +3170,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t  gfc_get_backend_locus (&loc);\n \t  gfc_set_backend_locus (&sym->declared_at);\n \t  if (sym->attr.dummy || sym->attr.result)\n-\t    fnbody = gfc_trans_dummy_character (sym, sym->ts.cl, fnbody);\n+\t    fnbody = gfc_trans_dummy_character (sym, sym->ts.u.cl, fnbody);\n \t  else\n \t    fnbody = gfc_trans_auto_character_variable (sym, fnbody);\n \t  gfc_set_backend_locus (&loc);\n@@ -3197,17 +3197,17 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n     {\n       if (f->sym && f->sym->tlink == NULL && f->sym->ts.type == BT_CHARACTER)\n \t{\n-\t  gcc_assert (f->sym->ts.cl->backend_decl != NULL);\n-\t  if (TREE_CODE (f->sym->ts.cl->backend_decl) == PARM_DECL)\n+\t  gcc_assert (f->sym->ts.u.cl->backend_decl != NULL);\n+\t  if (TREE_CODE (f->sym->ts.u.cl->backend_decl) == PARM_DECL)\n \t    gfc_trans_vla_type_sizes (f->sym, &body);\n \t}\n     }\n \n   if (gfc_return_by_reference (proc_sym) && proc_sym->ts.type == BT_CHARACTER\n       && current_fake_result_decl != NULL)\n     {\n-      gcc_assert (proc_sym->ts.cl->backend_decl != NULL);\n-      if (TREE_CODE (proc_sym->ts.cl->backend_decl) == PARM_DECL)\n+      gcc_assert (proc_sym->ts.u.cl->backend_decl != NULL);\n+      if (TREE_CODE (proc_sym->ts.u.cl->backend_decl) == PARM_DECL)\n \tgfc_trans_vla_type_sizes (proc_sym, &body);\n     }\n \n@@ -3381,7 +3381,7 @@ gfc_create_module_variable (gfc_symbol * sym)\n     {\n       tree length;\n \n-      length = sym->ts.cl->backend_decl;\n+      length = sym->ts.u.cl->backend_decl;\n       if (!INTEGER_CST_P (length))\n         {\n           pushdecl (length);\n@@ -3511,7 +3511,7 @@ check_constant_initializer (gfc_expr *expr, gfc_typespec *ts, bool array,\n     case BT_DERIVED:\n       if (expr->expr_type != EXPR_STRUCTURE)\n \treturn false;\n-      cm = expr->ts.derived->components;\n+      cm = expr->ts.u.derived->components;\n       for (c = expr->value.constructor; c; c = c->next, cm = cm->next)\n \t{\n \t  if (!c->expr || cm->attr.allocatable)\n@@ -3557,12 +3557,12 @@ gfc_emit_parameter_debug_info (gfc_symbol *sym)\n \n   if (sym->ts.type == BT_CHARACTER)\n     {\n-      gfc_conv_const_charlen (sym->ts.cl);\n-      if (sym->ts.cl->backend_decl == NULL\n-\t  || TREE_CODE (sym->ts.cl->backend_decl) != INTEGER_CST)\n+      gfc_conv_const_charlen (sym->ts.u.cl);\n+      if (sym->ts.u.cl->backend_decl == NULL\n+\t  || TREE_CODE (sym->ts.u.cl->backend_decl) != INTEGER_CST)\n \treturn;\n     }\n-  else if (sym->ts.type == BT_DERIVED && sym->ts.derived->attr.alloc_comp)\n+  else if (sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.alloc_comp)\n     return;\n \n   if (sym->as)\n@@ -3690,10 +3690,10 @@ generate_dependency_declarations (gfc_symbol *sym)\n   int i;\n \n   if (sym->ts.type == BT_CHARACTER\n-      && sym->ts.cl\n-      && sym->ts.cl->length\n-      && sym->ts.cl->length->expr_type != EXPR_CONSTANT)\n-    generate_expr_decls (sym, sym->ts.cl->length);\n+      && sym->ts.u.cl\n+      && sym->ts.u.cl->length\n+      && sym->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n+    generate_expr_decls (sym, sym->ts.u.cl->length);\n \n   if (sym->as && sym->as->rank)\n     {\n@@ -3744,8 +3744,8 @@ generate_local_decl (gfc_symbol * sym)\n \t warning if requested.  */\n       if (sym->attr.dummy && !sym->attr.referenced\n \t    && sym->ts.type == BT_CHARACTER\n-\t    && sym->ts.cl->backend_decl != NULL\n-\t    && TREE_CODE (sym->ts.cl->backend_decl) == VAR_DECL)\n+\t    && sym->ts.u.cl->backend_decl != NULL\n+\t    && TREE_CODE (sym->ts.u.cl->backend_decl) == VAR_DECL)\n \t{\n \t  sym->attr.referenced = 1;\n \t  gfc_get_symbol_decl (sym);\n@@ -3756,7 +3756,7 @@ generate_local_decl (gfc_symbol * sym)\n \t generate the code for nullification and automatic lengths.  */\n       if (!sym->attr.referenced\n \t    && sym->ts.type == BT_DERIVED\n-\t    && sym->ts.derived->attr.alloc_comp\n+\t    && sym->ts.u.derived->attr.alloc_comp\n \t    && !sym->attr.pointer\n \t    && ((sym->attr.dummy && sym->attr.intent == INTENT_OUT)\n \t\t  ||\n@@ -3887,7 +3887,7 @@ add_argument_checking (stmtblock_t *block, gfc_symbol *sym)\n \tconst char *message;\n \n \tfsym = formal->sym;\n-\tcl = fsym->ts.cl;\n+\tcl = fsym->ts.u.cl;\n \n \tgcc_assert (cl);\n \tgcc_assert (cl->passed_length != NULL_TREE);\n@@ -4224,10 +4224,10 @@ gfc_generate_function_code (gfc_namespace * ns)\n       gfc_entry_list *el;\n       tree backend_decl;\n \n-      gfc_conv_const_charlen (ns->proc_name->ts.cl);\n-      backend_decl = ns->proc_name->result->ts.cl->backend_decl;\n+      gfc_conv_const_charlen (ns->proc_name->ts.u.cl);\n+      backend_decl = ns->proc_name->result->ts.u.cl->backend_decl;\n       for (el = ns->entries; el; el = el->next)\n-\tel->sym->result->ts.cl->backend_decl = backend_decl;\n+\tel->sym->result->ts.u.cl->backend_decl = backend_decl;\n     }\n \n   /* Translate COMMON blocks.  */\n@@ -4328,11 +4328,11 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n       if (result != NULL_TREE && sym->attr.function\n \t    && sym->ts.type == BT_DERIVED\n-\t    && sym->ts.derived->attr.alloc_comp\n+\t    && sym->ts.u.derived->attr.alloc_comp\n \t    && !sym->attr.pointer)\n \t{\n \t  rank = sym->as ? sym->as->rank : 0;\n-\t  tmp2 = gfc_nullify_alloc_comp (sym->ts.derived, result, rank);\n+\t  tmp2 = gfc_nullify_alloc_comp (sym->ts.u.derived, result, rank);\n \t  gfc_add_expr_to_block (&block, tmp2);\n \t}\n "}, {"sha": "51593e7ae19d689143868c94bf0555588ca7375e", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -201,20 +201,20 @@ gfc_get_expr_charlen (gfc_expr *e)\n   \n   length = NULL; /* To silence compiler warning.  */\n \n-  if (is_subref_array (e) && e->ts.cl->length)\n+  if (is_subref_array (e) && e->ts.u.cl->length)\n     {\n       gfc_se tmpse;\n       gfc_init_se (&tmpse, NULL);\n-      gfc_conv_expr_type (&tmpse, e->ts.cl->length, gfc_charlen_type_node);\n-      e->ts.cl->backend_decl = tmpse.expr;\n+      gfc_conv_expr_type (&tmpse, e->ts.u.cl->length, gfc_charlen_type_node);\n+      e->ts.u.cl->backend_decl = tmpse.expr;\n       return tmpse.expr;\n     }\n \n   /* First candidate: if the variable is of type CHARACTER, the\n      expression's length could be the length of the character\n      variable.  */\n   if (e->symtree->n.sym->ts.type == BT_CHARACTER)\n-    length = e->symtree->n.sym->ts.cl->backend_decl;\n+    length = e->symtree->n.sym->ts.u.cl->backend_decl;\n \n   /* Look through the reference chain for component references.  */\n   for (r = e->ref; r; r = r->next)\n@@ -223,7 +223,7 @@ gfc_get_expr_charlen (gfc_expr *e)\n \t{\n \tcase REF_COMPONENT:\n \t  if (r->u.c.component->ts.type == BT_CHARACTER)\n-\t    length = r->u.c.component->ts.cl->backend_decl;\n+\t    length = r->u.c.component->ts.u.cl->backend_decl;\n \t  break;\n \n \tcase REF_ARRAY:\n@@ -243,7 +243,7 @@ gfc_get_expr_charlen (gfc_expr *e)\n }\n \n \n-/* For each character array constructor subexpression without a ts.cl->length,\n+/* For each character array constructor subexpression without a ts.u.cl->length,\n    replace it by its first element (if there aren't any elements, the length\n    should already be set to zero).  */\n \n@@ -276,7 +276,7 @@ flatten_array_ctors_without_strlen (gfc_expr* e)\n     case EXPR_ARRAY:\n \n       /* We've found what we're looking for.  */\n-      if (e->ts.type == BT_CHARACTER && !e->ts.cl->length)\n+      if (e->ts.type == BT_CHARACTER && !e->ts.u.cl->length)\n \t{\n \t  gfc_expr* new_expr;\n \t  gcc_assert (e->value.constructor);\n@@ -472,7 +472,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n \n   if (c->ts.type == BT_CHARACTER)\n     {\n-      tmp = c->ts.cl->backend_decl;\n+      tmp = c->ts.u.cl->backend_decl;\n       /* Components must always be constant length.  */\n       gcc_assert (tmp && INTEGER_CST_P (tmp));\n       se->string_length = tmp;\n@@ -513,7 +513,7 @@ conv_parent_component_references (gfc_se * se, gfc_ref * ref)\n \t\n       /* Otherwise build the reference and call self.  */\n       gfc_conv_component_ref (se, &parent);\n-      parent.u.c.sym = dt->components->ts.derived;\n+      parent.u.c.sym = dt->components->ts.u.derived;\n       parent.u.c.component = c;\n       conv_parent_component_references (se, &parent);\n     }\n@@ -662,10 +662,10 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n     {\n       /* If the character length of an entry isn't set, get the length from\n          the master function instead.  */\n-      if (sym->attr.entry && !sym->ts.cl->backend_decl)\n-        se->string_length = sym->ns->proc_name->ts.cl->backend_decl;\n+      if (sym->attr.entry && !sym->ts.u.cl->backend_decl)\n+        se->string_length = sym->ns->proc_name->ts.u.cl->backend_decl;\n       else\n-        se->string_length = sym->ts.cl->backend_decl;\n+        se->string_length = sym->ts.u.cl->backend_decl;\n       gcc_assert (se->string_length);\n     }\n \n@@ -1159,7 +1159,7 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n   gfc_add_block_to_block (&se->pre, &lse.pre);\n   gfc_add_block_to_block (&se->pre, &rse.pre);\n \n-  type = gfc_get_character_type (expr->ts.kind, expr->ts.cl);\n+  type = gfc_get_character_type (expr->ts.kind, expr->ts.u.cl);\n   len = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n   if (len == NULL_TREE)\n     {\n@@ -1723,16 +1723,16 @@ gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n   if (sym->ts.type == BT_CHARACTER)\n     {\n       /* Create a copy of the dummy argument's length.  */\n-      new_sym->ts.cl = gfc_get_interface_mapping_charlen (mapping, sym->ts.cl);\n-      sm->expr->ts.cl = new_sym->ts.cl;\n+      new_sym->ts.u.cl = gfc_get_interface_mapping_charlen (mapping, sym->ts.u.cl);\n+      sm->expr->ts.u.cl = new_sym->ts.u.cl;\n \n       /* If the length is specified as \"*\", record the length that\n \t the caller is passing.  We should use the callee's length\n \t in all other cases.  */\n-      if (!new_sym->ts.cl->length && se)\n+      if (!new_sym->ts.u.cl->length && se)\n \t{\n \t  se->string_length = gfc_evaluate_now (se->string_length, &se->pre);\n-\t  new_sym->ts.cl->backend_decl = se->string_length;\n+\t  new_sym->ts.u.cl->backend_decl = se->string_length;\n \t}\n     }\n \n@@ -1764,7 +1764,7 @@ gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n \t\t\t\t     se->expr);\n   \n   /* For character(*), use the actual argument's descriptor.  */  \n-  else if (sym->ts.type == BT_CHARACTER && !new_sym->ts.cl->length)\n+  else if (sym->ts.type == BT_CHARACTER && !new_sym->ts.u.cl->length)\n     value = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t     se->expr);\n \n@@ -1809,9 +1809,9 @@ gfc_finish_interface_mapping (gfc_interface_mapping * mapping,\n \n   for (sym = mapping->syms; sym; sym = sym->next)\n     if (sym->new_sym->n.sym->ts.type == BT_CHARACTER\n-\t&& !sym->new_sym->n.sym->ts.cl->backend_decl)\n+\t&& !sym->new_sym->n.sym->ts.u.cl->backend_decl)\n       {\n-\texpr = sym->new_sym->n.sym->ts.cl->length;\n+\texpr = sym->new_sym->n.sym->ts.u.cl->length;\n \tgfc_apply_interface_mapping_to_expr (mapping, expr);\n \tgfc_init_se (&se, NULL);\n \tgfc_conv_expr (&se, expr);\n@@ -1820,7 +1820,7 @@ gfc_finish_interface_mapping (gfc_interface_mapping * mapping,\n \tgfc_add_block_to_block (pre, &se.pre);\n \tgfc_add_block_to_block (post, &se.post);\n \n-\tsym->new_sym->n.sym->ts.cl->backend_decl = se.expr;\n+\tsym->new_sym->n.sym->ts.u.cl->backend_decl = se.expr;\n       }\n }\n \n@@ -1907,12 +1907,12 @@ gfc_map_intrinsic_function (gfc_expr *expr, gfc_interface_mapping *mapping)\n     case GFC_ISYM_LEN:\n       /* TODO figure out why this condition is necessary.  */\n       if (sym->attr.function\n-\t  && (arg1->ts.cl->length == NULL\n-\t      || (arg1->ts.cl->length->expr_type != EXPR_CONSTANT\n-\t\t  && arg1->ts.cl->length->expr_type != EXPR_VARIABLE)))\n+\t  && (arg1->ts.u.cl->length == NULL\n+\t      || (arg1->ts.u.cl->length->expr_type != EXPR_CONSTANT\n+\t\t  && arg1->ts.u.cl->length->expr_type != EXPR_VARIABLE)))\n \treturn false;\n \n-      new_expr = gfc_copy_expr (arg1->ts.cl->length);\n+      new_expr = gfc_copy_expr (arg1->ts.u.cl->length);\n       break;\n \n     case GFC_ISYM_SIZE:\n@@ -2025,11 +2025,11 @@ gfc_map_fcn_formal_to_actual (gfc_expr *expr, gfc_expr *map_expr,\n \n   if (map_expr->symtree->n.sym->ts.type == BT_CHARACTER)\n     {\n-      expr->value.function.esym->ts.cl->length\n-\t= gfc_copy_expr (map_expr->symtree->n.sym->ts.cl->length);\n+      expr->value.function.esym->ts.u.cl->length\n+\t= gfc_copy_expr (map_expr->symtree->n.sym->ts.u.cl->length);\n \n       gfc_apply_interface_mapping_to_expr (mapping,\n-\t\t\texpr->value.function.esym->ts.cl->length);\n+\t\t\texpr->value.function.esym->ts.u.cl->length);\n     }\n }\n \n@@ -2050,10 +2050,10 @@ gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n     return;\n \n   /* Copying an expression does not copy its length, so do that here.  */\n-  if (expr->ts.type == BT_CHARACTER && expr->ts.cl)\n+  if (expr->ts.type == BT_CHARACTER && expr->ts.u.cl)\n     {\n-      expr->ts.cl = gfc_get_interface_mapping_charlen (mapping, expr->ts.cl);\n-      gfc_apply_interface_mapping_to_expr (mapping, expr->ts.cl->length);\n+      expr->ts.u.cl = gfc_get_interface_mapping_charlen (mapping, expr->ts.u.cl);\n+      gfc_apply_interface_mapping_to_expr (mapping, expr->ts.u.cl->length);\n     }\n \n   /* Apply the mapping to any references.  */\n@@ -2173,8 +2173,8 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,\n   gfc_conv_ss_startstride (&loop);\n \n   /* Build an ss for the temporary.  */\n-  if (expr->ts.type == BT_CHARACTER && !expr->ts.cl->backend_decl)\n-    gfc_conv_string_length (expr->ts.cl, expr, &parmse->pre);\n+  if (expr->ts.type == BT_CHARACTER && !expr->ts.u.cl->backend_decl)\n+    gfc_conv_string_length (expr->ts.u.cl, expr, &parmse->pre);\n \n   base_type = gfc_typenode_for_spec (&expr->ts);\n   if (GFC_ARRAY_TYPE_P (base_type)\n@@ -2186,7 +2186,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,\n   loop.temp_ss->data.temp.type = base_type;\n \n   if (expr->ts.type == BT_CHARACTER)\n-    loop.temp_ss->string_length = expr->ts.cl->backend_decl;\n+    loop.temp_ss->string_length = expr->ts.u.cl->backend_decl;\n   else\n     loop.temp_ss->string_length = NULL;\n \n@@ -2315,7 +2315,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,\n   rse.expr = gfc_build_array_ref (tmp, tmp_index, NULL);\n \n   if (expr->ts.type == BT_CHARACTER)\n-    rse.string_length = expr->ts.cl->backend_decl;\n+    rse.string_length = expr->ts.u.cl->backend_decl;\n \n   gfc_conv_expr (&lse, expr);\n \n@@ -2343,7 +2343,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,\n \n   /* Pass the string length to the argument expression.  */\n   if (expr->ts.type == BT_CHARACTER)\n-    parmse->string_length = expr->ts.cl->backend_decl;\n+    parmse->string_length = expr->ts.u.cl->backend_decl;\n \n   /* We want either the address for the data or the address of the descriptor,\n      depending on the mode of passing array arguments.  */\n@@ -2457,9 +2457,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t}\n       else if (sym->intmod_sym_id == ISOCBINDING_FUNLOC)\n \t{\n-\t  arg->expr->ts.type = sym->ts.derived->ts.type;\n-\t  arg->expr->ts.f90_type = sym->ts.derived->ts.f90_type;\n-\t  arg->expr->ts.kind = sym->ts.derived->ts.kind;\n+\t  arg->expr->ts.type = sym->ts.u.derived->ts.type;\n+\t  arg->expr->ts.f90_type = sym->ts.u.derived->ts.f90_type;\n+\t  arg->expr->ts.kind = sym->ts.u.derived->ts.kind;\n \t  gfc_conv_expr_reference (se, arg->expr);\n       \n \t  return 0;\n@@ -2572,8 +2572,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   gfc_init_block (&post);\n   gfc_init_interface_mapping (&mapping);\n   need_interface_mapping = ((sym->ts.type == BT_CHARACTER\n-\t\t\t\t  && sym->ts.cl->length\n-\t\t\t\t  && sym->ts.cl->length->expr_type\n+\t\t\t\t  && sym->ts.u.cl->length\n+\t\t\t\t  && sym->ts.u.cl->length->expr_type\n \t\t\t\t\t\t!= EXPR_CONSTANT)\n \t\t\t      || (comp && comp->attr.dimension)\n \t\t\t      || (!comp && sym->attr.dimension));\n@@ -2753,11 +2753,11 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      && parmse.string_length == NULL_TREE\n \t      && e->ts.type == BT_PROCEDURE\n \t      && e->symtree->n.sym->ts.type == BT_CHARACTER\n-\t      && e->symtree->n.sym->ts.cl->length != NULL\n-\t      && e->symtree->n.sym->ts.cl->length->expr_type == EXPR_CONSTANT)\n+\t      && e->symtree->n.sym->ts.u.cl->length != NULL\n+\t      && e->symtree->n.sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n \t    {\n-\t      gfc_conv_const_charlen (e->symtree->n.sym->ts.cl);\n-\t      parmse.string_length = e->symtree->n.sym->ts.cl->backend_decl;\n+\t      gfc_conv_const_charlen (e->symtree->n.sym->ts.u.cl);\n+\t      parmse.string_length = e->symtree->n.sym->ts.u.cl->backend_decl;\n \t    }\n \t}\n \n@@ -2771,7 +2771,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t deallocated for non-variable scalars.  Non-variable arrays are\n \t dealt with in trans-array.c(gfc_conv_array_parameter).  */\n       if (e && e->ts.type == BT_DERIVED\n-\t    && e->ts.derived->attr.alloc_comp\n+\t    && e->ts.u.derived->attr.alloc_comp\n \t    && !(e->symtree && e->symtree->n.sym->attr.pointer)\n \t    && (e->expr_type != EXPR_VARIABLE && !e->rank))\n         {\n@@ -2798,11 +2798,11 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    {\n \t      tree local_tmp;\n \t      local_tmp = gfc_evaluate_now (tmp, &se->pre);\n-\t      local_tmp = gfc_copy_alloc_comp (e->ts.derived, local_tmp, tmp, parm_rank);\n+\t      local_tmp = gfc_copy_alloc_comp (e->ts.u.derived, local_tmp, tmp, parm_rank);\n \t      gfc_add_expr_to_block (&se->post, local_tmp);\n \t    }\n \n-\t  tmp = gfc_deallocate_alloc_comp (e->ts.derived, tmp, parm_rank);\n+\t  tmp = gfc_deallocate_alloc_comp (e->ts.u.derived, tmp, parm_rank);\n \n \t  gfc_add_expr_to_block (&se->post, tmp);\n         }\n@@ -2912,7 +2912,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n     se->string_length = build_int_cst (gfc_charlen_type_node, 1);\n   else if (ts.type == BT_CHARACTER)\n     {\n-      if (sym->ts.cl->length == NULL)\n+      if (sym->ts.u.cl->length == NULL)\n \t{\n \t  /* Assumed character length results are not allowed by 5.1.1.5 of the\n \t     standard and are trapped in resolve.c; except in the case of SPREAD\n@@ -2927,7 +2927,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      formal = sym->ns->proc_name->formal;\n \t      for (; formal; formal = formal->next)\n \t\tif (strcmp (formal->sym->name, sym->name) == 0)\n-\t\t  cl.backend_decl = formal->sym->ts.cl->backend_decl;\n+\t\t  cl.backend_decl = formal->sym->ts.u.cl->backend_decl;\n \t    }\n         }\n         else\n@@ -2937,9 +2937,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  /* Calculate the length of the returned string.  */\n \t  gfc_init_se (&parmse, NULL);\n \t  if (need_interface_mapping)\n-\t    gfc_apply_interface_mapping (&mapping, &parmse, sym->ts.cl->length);\n+\t    gfc_apply_interface_mapping (&mapping, &parmse, sym->ts.u.cl->length);\n \t  else\n-\t    gfc_conv_expr (&parmse, sym->ts.cl->length);\n+\t    gfc_conv_expr (&parmse, sym->ts.u.cl->length);\n \t  gfc_add_block_to_block (&se->pre, &parmse.pre);\n \t  gfc_add_block_to_block (&se->post, &parmse.post);\n \t  \n@@ -2952,7 +2952,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       /* Set up a charlen structure for it.  */\n       cl.next = NULL;\n       cl.length = NULL;\n-      ts.cl = &cl;\n+      ts.u.cl = &cl;\n \n       len = cl.backend_decl;\n     }\n@@ -3025,7 +3025,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       else if (ts.type == BT_CHARACTER)\n \t{\n \t  /* Pass the string length.  */\n-\t  type = gfc_get_character_type (ts.kind, ts.cl);\n+\t  type = gfc_get_character_type (ts.kind, ts.u.cl);\n \t  type = build_pointer_type (type);\n \n \t  /* Return an address to a char[0:len-1]* temporary for\n@@ -3419,8 +3419,8 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n \t  /* Copy string arguments.  */\n           tree arglen;\n \n-          gcc_assert (fsym->ts.cl && fsym->ts.cl->length\n-\t\t      && fsym->ts.cl->length->expr_type == EXPR_CONSTANT);\n+          gcc_assert (fsym->ts.u.cl && fsym->ts.u.cl->length\n+\t\t      && fsym->ts.u.cl->length->expr_type == EXPR_CONSTANT);\n \n           arglen = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n           tmp = gfc_build_addr_expr (build_pointer_type (type),\n@@ -3457,22 +3457,22 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n \n   if (sym->ts.type == BT_CHARACTER)\n     {\n-      gfc_conv_const_charlen (sym->ts.cl);\n+      gfc_conv_const_charlen (sym->ts.u.cl);\n \n       /* Force the expression to the correct length.  */\n       if (!INTEGER_CST_P (se->string_length)\n \t  || tree_int_cst_lt (se->string_length,\n-\t\t\t      sym->ts.cl->backend_decl))\n+\t\t\t      sym->ts.u.cl->backend_decl))\n \t{\n-\t  type = gfc_get_character_type (sym->ts.kind, sym->ts.cl);\n+\t  type = gfc_get_character_type (sym->ts.kind, sym->ts.u.cl);\n \t  tmp = gfc_create_var (type, sym->name);\n \t  tmp = gfc_build_addr_expr (build_pointer_type (type), tmp);\n-\t  gfc_trans_string_copy (&se->pre, sym->ts.cl->backend_decl, tmp,\n+\t  gfc_trans_string_copy (&se->pre, sym->ts.u.cl->backend_decl, tmp,\n \t\t\t\t sym->ts.kind, se->string_length, se->expr,\n \t\t\t\t sym->ts.kind);\n \t  se->expr = tmp;\n \t}\n-      se->string_length = sym->ts.cl->backend_decl;\n+      se->string_length = sym->ts.u.cl->backend_decl;\n     }\n \n   /* Restore the original variables.  */\n@@ -3559,9 +3559,9 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n      used as initialization expressions).  If so, we need to modify\n      the 'expr' to be that for a (void *).  */\n   if (expr != NULL && expr->ts.type == BT_DERIVED\n-      && expr->ts.is_iso_c && expr->ts.derived)\n+      && expr->ts.is_iso_c && expr->ts.u.derived)\n     {\n-      gfc_symbol *derived = expr->ts.derived;\n+      gfc_symbol *derived = expr->ts.u.derived;\n \n       expr = gfc_int_expr (0);\n \n@@ -3591,7 +3591,7 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n \t  return se.expr;\n \n \tcase BT_CHARACTER:\n-\t  return gfc_conv_string_init (ts->cl->backend_decl,expr);\n+\t  return gfc_conv_string_init (ts->u.cl->backend_decl,expr);\n \n \tdefault:\n \t  gfc_init_se (&se, NULL);\n@@ -3679,7 +3679,7 @@ gfc_trans_subarray_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \n   gfc_conv_tmp_array_ref (&lse);\n   if (cm->ts.type == BT_CHARACTER)\n-    lse.string_length = cm->ts.cl->backend_decl;\n+    lse.string_length = cm->ts.u.cl->backend_decl;\n \n   gfc_conv_expr (&rse, expr);\n \n@@ -3766,8 +3766,8 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t  gfc_add_block_to_block (&block, &se.pre);\n \t  gfc_add_modify (&block, dest, se.expr);\n \n-\t  if (cm->ts.type == BT_DERIVED && cm->ts.derived->attr.alloc_comp)\n-\t    tmp = gfc_copy_alloc_comp (cm->ts.derived, se.expr, dest,\n+\t  if (cm->ts.type == BT_DERIVED && cm->ts.u.derived->attr.alloc_comp)\n+\t    tmp = gfc_copy_alloc_comp (cm->ts.u.derived, se.expr, dest,\n \t\t\t\t       cm->as->rank);\n \t  else\n \t    tmp = gfc_duplicate_allocatable (dest, se.expr,\n@@ -3872,7 +3872,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \n       gfc_conv_expr (&se, expr);\n       if (cm->ts.type == BT_CHARACTER)\n-\tlse.string_length = cm->ts.cl->backend_decl;\n+\tlse.string_length = cm->ts.u.cl->backend_decl;\n       lse.expr = dest;\n       tmp = gfc_trans_scalar_assign (&lse, &se, cm->ts, true, false);\n       gfc_add_expr_to_block (&block, tmp);\n@@ -3892,7 +3892,7 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr)\n   tree tmp;\n \n   gfc_start_block (&block);\n-  cm = expr->ts.derived->components;\n+  cm = expr->ts.u.derived->components;\n   for (c = expr->value.constructor; c; c = c->next, cm = cm->next)\n     {\n       /* Skip absent members in default initializers.  */\n@@ -3928,13 +3928,13 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n   if (!init)\n     {\n       /* Create a temporary variable and fill it in.  */\n-      se->expr = gfc_create_var (type, expr->ts.derived->name);\n+      se->expr = gfc_create_var (type, expr->ts.u.derived->name);\n       tmp = gfc_trans_structure_assign (se->expr, expr);\n       gfc_add_expr_to_block (&se->pre, tmp);\n       return;\n     }\n \n-  cm = expr->ts.derived->components;\n+  cm = expr->ts.u.derived->components;\n \n   for (c = expr->value.constructor; c; c = c->next, cm = cm->next)\n     {\n@@ -4004,8 +4004,8 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n      null_pointer_node.  C_PTR and C_FUNPTR are converted to match the\n      typespec for the C_PTR and C_FUNPTR symbols, which has already been\n      updated to be an integer with a kind equal to the size of a (void *).  */\n-  if (expr->ts.type == BT_DERIVED && expr->ts.derived\n-      && expr->ts.derived->attr.is_iso_c)\n+  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived\n+      && expr->ts.u.derived->attr.is_iso_c)\n     {\n       if (expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_PTR\n           || expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_FUNPTR)\n@@ -4018,9 +4018,9 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n         {\n           /* Update the type/kind of the expression to be what the new\n              type/kind are for the updated symbols of C_PTR/C_FUNPTR.  */\n-          expr->ts.type = expr->ts.derived->ts.type;\n-          expr->ts.f90_type = expr->ts.derived->ts.f90_type;\n-          expr->ts.kind = expr->ts.derived->ts.kind;\n+          expr->ts.type = expr->ts.u.derived->ts.type;\n+          expr->ts.f90_type = expr->ts.u.derived->ts.f90_type;\n+          expr->ts.kind = expr->ts.u.derived->ts.kind;\n         }\n     }\n   \n@@ -4389,7 +4389,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       gfc_trans_string_copy (&block, llen, lse->expr, ts.kind, rlen,\n \t\t\t     rse->expr, ts.kind);\n     }\n-  else if (ts.type == BT_DERIVED && ts.derived->attr.alloc_comp)\n+  else if (ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)\n     {\n       cond = NULL_TREE;\n \t\n@@ -4409,7 +4409,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       if (!l_is_temp)\n \t{\n \t  tmp = gfc_evaluate_now (lse->expr, &lse->pre);\n-\t  tmp = gfc_deallocate_alloc_comp (ts.derived, tmp, 0);\n+\t  tmp = gfc_deallocate_alloc_comp (ts.u.derived, tmp, 0);\n \t  if (r_is_var)\n \t    tmp = build3_v (COND_EXPR, cond, build_empty_stmt (input_location),\n \t\t\t    tmp);\n@@ -4426,7 +4426,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n \t same as the lhs.  */\n       if (r_is_var)\n \t{\n-\t  tmp = gfc_copy_alloc_comp (ts.derived, rse->expr, lse->expr, 0);\n+\t  tmp = gfc_copy_alloc_comp (ts.u.derived, rse->expr, lse->expr, 0);\n \t  tmp = build3_v (COND_EXPR, cond, build_empty_stmt (input_location),\n \t\t\t  tmp);\n \t  gfc_add_expr_to_block (&block, tmp);\n@@ -4504,16 +4504,16 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n      character lengths are the same.  */\n   if (expr2->ts.type == BT_CHARACTER && expr2->rank > 0)\n     {\n-      if (expr1->ts.cl->length == NULL\n-\t    || expr1->ts.cl->length->expr_type != EXPR_CONSTANT)\n+      if (expr1->ts.u.cl->length == NULL\n+\t    || expr1->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n \treturn NULL;\n \n-      if (expr2->ts.cl->length == NULL\n-\t    || expr2->ts.cl->length->expr_type != EXPR_CONSTANT)\n+      if (expr2->ts.u.cl->length == NULL\n+\t    || expr2->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n \treturn NULL;\n \n-      if (mpz_cmp (expr1->ts.cl->length->value.integer,\n-\t\t     expr2->ts.cl->length->value.integer) != 0)\n+      if (mpz_cmp (expr1->ts.u.cl->length->value.integer,\n+\t\t     expr2->ts.u.cl->length->value.integer) != 0)\n \treturn NULL;\n     }\n \n@@ -4887,13 +4887,13 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag)\n      to arrays must be done with a deep copy and the rhs temporary\n      must have its components deallocated afterwards.  */\n   scalar_to_array = (expr2->ts.type == BT_DERIVED\n-\t\t       && expr2->ts.derived->attr.alloc_comp\n+\t\t       && expr2->ts.u.derived->attr.alloc_comp\n \t\t       && expr2->expr_type != EXPR_VARIABLE\n \t\t       && !gfc_is_constant_expr (expr2)\n \t\t       && expr1->rank && !expr2->rank);\n   if (scalar_to_array)\n     {\n-      tmp = gfc_deallocate_alloc_comp (expr2->ts.derived, rse.expr, 0);\n+      tmp = gfc_deallocate_alloc_comp (expr2->ts.u.derived, rse.expr, 0);\n       gfc_add_expr_to_block (&loop.post, tmp);\n     }\n \n@@ -4983,7 +4983,7 @@ copyable_array_p (gfc_expr * expr)\n       return false;\n \n     case BT_DERIVED:\n-      return !expr->ts.derived->attr.alloc_comp;\n+      return !expr->ts.u.derived->attr.alloc_comp;\n \n     default:\n       break;"}, {"sha": "3b2cbd11428b0b8d16e56379e11fa457d7dc28c6", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -3479,7 +3479,7 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n \t\t&& (sym->result == sym))\n \t    decl = gfc_get_fake_result_decl (sym, 0);\n \n-\t  len = sym->ts.cl->backend_decl;\n+\t  len = sym->ts.u.cl->backend_decl;\n \t  gcc_assert (len);\n \t  break;\n \t}\n@@ -4629,7 +4629,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n       nonzero_charlen = NULL_TREE;\n       if (arg1->expr->ts.type == BT_CHARACTER)\n \tnonzero_charlen = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t       arg1->expr->ts.cl->backend_decl,\n+\t\t\t\t       arg1->expr->ts.u.cl->backend_decl,\n \t\t\t\t       integer_zero_node);\n \n       if (ss1 == gfc_ss_terminator)\n@@ -4883,7 +4883,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   dlen = fold_build2 (MULT_EXPR, gfc_charlen_type_node,\n \t\t      fold_convert (gfc_charlen_type_node, slen),\n \t\t      fold_convert (gfc_charlen_type_node, ncopies));\n-  type = gfc_get_character_type (expr->ts.kind, expr->ts.cl);\n+  type = gfc_get_character_type (expr->ts.kind, expr->ts.u.cl);\n   dest = gfc_conv_string_tmp (se, build_pointer_type (type), dlen);\n \n   /* Generate the code to do the repeat operation:"}, {"sha": "0f6e0a5a40ac07f651e1429f742f3a0c3d2dab99", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -1591,7 +1591,7 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n   dt_parm_addr = gfc_build_addr_expr (NULL_TREE, dt_parm);\n \n   if (ts->type == BT_CHARACTER)\n-    tmp = ts->cl->backend_decl;\n+    tmp = ts->u.cl->backend_decl;\n   else\n     tmp = build_int_cst (gfc_charlen_type_node, 0);\n   tmp = build_call_expr_loc (input_location,\n@@ -1624,7 +1624,7 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n       tree expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t   addr_expr);\n \n-      for (cmp = ts->derived->components; cmp; cmp = cmp->next)\n+      for (cmp = ts->u.derived->components; cmp; cmp = cmp->next)\n \t{\n \t  char *full_name = nml_full_name (var_name, cmp->name);\n \t  transfer_namelist_element (block,\n@@ -2005,23 +2005,24 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n      C_NULL_PTR or C_NULL_FUNPTR.  We could also get a user variable of\n      type C_PTR or C_FUNPTR, in which case the ts->type may no longer be\n      BT_DERIVED (could have been changed by gfc_conv_expr).  */\n-  if ((ts->type == BT_DERIVED && ts->is_iso_c == 1 && ts->derived != NULL)\n-      || (ts->derived != NULL && ts->derived->ts.is_iso_c == 1))\n+  if ((ts->type == BT_DERIVED || ts->type == BT_INTEGER)\n+      && ts->u.derived != NULL\n+      && (ts->is_iso_c == 1 || ts->u.derived->ts.is_iso_c == 1))\n     {\n       /* C_PTR and C_FUNPTR have private components which means they can not\n          be printed.  However, if -std=gnu and not -pedantic, allow\n          the component to be printed to help debugging.  */\n       if (gfc_notification_std (GFC_STD_GNU) != SILENT)\n \t{\n \t  gfc_error_now (\"Derived type '%s' at %L has PRIVATE components\",\n-\t\t\t ts->derived->name, code != NULL ? &(code->loc) : \n+\t\t\t ts->u.derived->name, code != NULL ? &(code->loc) : \n \t\t\t &gfc_current_locus);\n \t  return;\n \t}\n \n-      ts->type = ts->derived->ts.type;\n-      ts->kind = ts->derived->ts.kind;\n-      ts->f90_type = ts->derived->ts.f90_type;\n+      ts->type = ts->u.derived->ts.type;\n+      ts->kind = ts->u.derived->ts.kind;\n+      ts->f90_type = ts->u.derived->ts.f90_type;\n     }\n   \n   kind = ts->kind;\n@@ -2093,7 +2094,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n       expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t      expr);\n \n-      for (c = ts->derived->components; c; c = c->next)\n+      for (c = ts->u.derived->components; c; c = c->next)\n \t{\n \t  field = c->backend_decl;\n \t  gcc_assert (field && TREE_CODE (field) == FIELD_DECL);"}, {"sha": "935943727ab709163ddfac5f579aa937ad3134b7", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -1830,7 +1830,7 @@ check_forall_dependencies (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n      pointer components.  We therefore leave these to their\n      own devices.  */\n   if (lsym->ts.type == BT_DERIVED\n-\t&& lsym->ts.derived->attr.pointer_comp)\n+\t&& lsym->ts.u.derived->attr.pointer_comp)\n     return need_temp;\n \n   new_symtree = NULL;\n@@ -2539,17 +2539,17 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \t\t\t\t\t&lss, &rss);\n \n   /* The type of LHS. Used in function allocate_temp_for_forall_nest */\n-  if (expr1->ts.type == BT_CHARACTER && expr1->ts.cl->length)\n+  if (expr1->ts.type == BT_CHARACTER && expr1->ts.u.cl->length)\n     {\n-      if (!expr1->ts.cl->backend_decl)\n+      if (!expr1->ts.u.cl->backend_decl)\n \t{\n \t  gfc_se tse;\n \t  gfc_init_se (&tse, NULL);\n-\t  gfc_conv_expr (&tse, expr1->ts.cl->length);\n-\t  expr1->ts.cl->backend_decl = tse.expr;\n+\t  gfc_conv_expr (&tse, expr1->ts.u.cl->length);\n+\t  expr1->ts.u.cl->backend_decl = tse.expr;\n \t}\n       type = gfc_get_character_type_len (gfc_default_character_kind,\n-\t\t\t\t         expr1->ts.cl->backend_decl);\n+\t\t\t\t         expr1->ts.u.cl->backend_decl);\n     }\n   else\n     type = gfc_typenode_for_spec (&expr1->ts);\n@@ -4024,10 +4024,10 @@ gfc_trans_allocate (gfc_code * code)\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n \n-\t  if (expr->ts.type == BT_DERIVED && expr->ts.derived->attr.alloc_comp)\n+\t  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp)\n \t    {\n \t      tmp = build_fold_indirect_ref_loc (input_location, se.expr);\n-\t      tmp = gfc_nullify_alloc_comp (expr->ts.derived, tmp, 0);\n+\t      tmp = gfc_nullify_alloc_comp (expr->ts.u.derived, tmp, 0);\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n \n@@ -4130,7 +4130,7 @@ gfc_trans_deallocate (gfc_code *code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n-      if (expr->ts.type == BT_DERIVED && expr->ts.derived->attr.alloc_comp)\n+      if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp)\n         {\n \t  gfc_ref *ref;\n \t  gfc_ref *last = NULL;\n@@ -4143,7 +4143,7 @@ gfc_trans_deallocate (gfc_code *code)\n \t  if (!(last && last->u.c.component->attr.pointer)\n \t\t&& !(!last && expr->symtree->n.sym->attr.pointer))\n \t    {\n-\t      tmp = gfc_deallocate_alloc_comp (expr->ts.derived, se.expr,\n+\t      tmp = gfc_deallocate_alloc_comp (expr->ts.u.derived, se.expr,\n \t\t\t\t\t       expr->rank);\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }"}, {"sha": "8cc63c260377f197dd1db8e9b11782ccbffe7f67", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc21d3152f7644fcbd2acf98adbba270c0408c91/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=bc21d3152f7644fcbd2acf98adbba270c0408c91", "patch": "@@ -1000,8 +1000,8 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n          C_FUNPTR to simple variables that get translated to (void *).  */\n       if (spec->f90_type == BT_VOID)\n \t{\n-\t  if (spec->derived\n-\t      && spec->derived->intmod_sym_id == ISOCBINDING_PTR)\n+\t  if (spec->u.derived\n+\t      && spec->u.derived->intmod_sym_id == ISOCBINDING_PTR)\n \t    basetype = ptr_type_node;\n \t  else\n \t    basetype = pfunc_type_node;\n@@ -1023,21 +1023,21 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n       break;\n \n     case BT_CHARACTER:\n-      basetype = gfc_get_character_type (spec->kind, spec->cl);\n+      basetype = gfc_get_character_type (spec->kind, spec->u.cl);\n       break;\n \n     case BT_DERIVED:\n-      basetype = gfc_get_derived_type (spec->derived);\n+      basetype = gfc_get_derived_type (spec->u.derived);\n \n       /* If we're dealing with either C_PTR or C_FUNPTR, we modified the\n          type and kind to fit a (void *) and the basetype returned was a\n          ptr_type_node.  We need to pass up this new information to the\n          symbol that was declared of type C_PTR or C_FUNPTR.  */\n-      if (spec->derived->attr.is_iso_c)\n+      if (spec->u.derived->attr.is_iso_c)\n         {\n-          spec->type = spec->derived->ts.type;\n-          spec->kind = spec->derived->ts.kind;\n-          spec->f90_type = spec->derived->ts.f90_type;\n+          spec->type = spec->u.derived->ts.type;\n+          spec->kind = spec->u.derived->ts.kind;\n+          spec->f90_type = spec->u.derived->ts.f90_type;\n         }\n       break;\n     case BT_VOID:\n@@ -1046,8 +1046,8 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n       basetype = ptr_type_node;\n       if (spec->f90_type == BT_VOID)\n \t{\n-\t  if (spec->derived\n-\t      && spec->derived->intmod_sym_id == ISOCBINDING_PTR)\n+\t  if (spec->u.derived\n+\t      && spec->u.derived->intmod_sym_id == ISOCBINDING_PTR)\n \t    basetype = ptr_type_node;\n \t  else\n \t    basetype = pfunc_type_node;\n@@ -1765,7 +1765,7 @@ gfc_sym_type (gfc_symbol * sym)\n \t     base type.  */\n \t  if (sym->ts.type != BT_CHARACTER\n \t      || !(sym->attr.dummy || sym->attr.function)\n-\t      || sym->ts.cl->backend_decl)\n+\t      || sym->ts.u.cl->backend_decl)\n \t    {\n \t      type = gfc_get_nodesc_array_type (type, sym->as,\n \t\t\t\t\t\tbyref ? PACKED_FULL\n@@ -1879,10 +1879,10 @@ copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to,\n       to_cm->backend_decl = from_cm->backend_decl;\n       if ((!from_cm->attr.pointer || from_gsym)\n \t      && from_cm->ts.type == BT_DERIVED)\n-\tgfc_get_derived_type (to_cm->ts.derived);\n+\tgfc_get_derived_type (to_cm->ts.u.derived);\n \n       else if (from_cm->ts.type == BT_CHARACTER)\n-\tto_cm->ts.cl->backend_decl = from_cm->ts.cl->backend_decl;\n+\tto_cm->ts.u.cl->backend_decl = from_cm->ts.u.cl->backend_decl;\n     }\n \n   return 1;\n@@ -1898,7 +1898,7 @@ gfc_get_ppc_type (gfc_component* c)\n   if (c->attr.function && !c->attr.dimension)\n     {\n       if (c->ts.type == BT_DERIVED)\n-\tt = c->ts.derived->backend_decl;\n+\tt = c->ts.u.derived->backend_decl;\n       else\n \tt = gfc_typenode_for_spec (&c->ts);\n     }\n@@ -2038,17 +2038,17 @@ gfc_get_derived_type (gfc_symbol * derived)\n \tcontinue;\n \n       if ((!c->attr.pointer && !c->attr.proc_pointer)\n-\t  || c->ts.derived->backend_decl == NULL)\n-\tc->ts.derived->backend_decl = gfc_get_derived_type (c->ts.derived);\n+\t  || c->ts.u.derived->backend_decl == NULL)\n+\tc->ts.u.derived->backend_decl = gfc_get_derived_type (c->ts.u.derived);\n \n-      if (c->ts.derived && c->ts.derived->attr.is_iso_c)\n+      if (c->ts.u.derived && c->ts.u.derived->attr.is_iso_c)\n         {\n           /* Need to copy the modified ts from the derived type.  The\n              typespec was modified because C_PTR/C_FUNPTR are translated\n              into (void *) from derived types.  */\n-          c->ts.type = c->ts.derived->ts.type;\n-          c->ts.kind = c->ts.derived->ts.kind;\n-          c->ts.f90_type = c->ts.derived->ts.f90_type;\n+          c->ts.type = c->ts.u.derived->ts.type;\n+          c->ts.kind = c->ts.u.derived->ts.kind;\n+          c->ts.f90_type = c->ts.u.derived->ts.f90_type;\n \t  if (c->initializer)\n \t    {\n \t      c->initializer->ts.type = c->ts.type;\n@@ -2070,14 +2070,14 @@ gfc_get_derived_type (gfc_symbol * derived)\n       if (c->attr.proc_pointer)\n \tfield_type = gfc_get_ppc_type (c);\n       else if (c->ts.type == BT_DERIVED)\n-        field_type = c->ts.derived->backend_decl;\n+        field_type = c->ts.u.derived->backend_decl;\n       else\n \t{\n \t  if (c->ts.type == BT_CHARACTER)\n \t    {\n \t      /* Evaluate the string length.  */\n-\t      gfc_conv_const_charlen (c->ts.cl);\n-\t      gcc_assert (c->ts.cl->backend_decl);\n+\t      gfc_conv_const_charlen (c->ts.u.cl);\n+\t      gcc_assert (c->ts.u.cl->backend_decl);\n \t    }\n \n \t  field_type = gfc_typenode_for_spec (&c->ts);\n@@ -2261,7 +2261,7 @@ gfc_get_function_type (gfc_symbol * sym)\n     arg = sym;\n \n   if (arg->ts.type == BT_CHARACTER)\n-    gfc_conv_const_charlen (arg->ts.cl);\n+    gfc_conv_const_charlen (arg->ts.u.cl);\n \n   /* Some functions we use an extra parameter for the return value.  */\n   if (gfc_return_by_reference (sym))\n@@ -2286,7 +2286,7 @@ gfc_get_function_type (gfc_symbol * sym)\n \t  /* Evaluate constant character lengths here so that they can be\n \t     included in the type.  */\n \t  if (arg->ts.type == BT_CHARACTER)\n-\t    gfc_conv_const_charlen (arg->ts.cl);\n+\t    gfc_conv_const_charlen (arg->ts.u.cl);\n \n \t  if (arg->attr.flavor == FL_PROCEDURE)\n \t    {"}]}