{"sha": "91d33e36a03b16ef089e852a721a59b65bc8373d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFkMzNlMzZhMDNiMTZlZjA4OWU4NTJhNzIxYTU5YjY1YmM4MzczZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-12-30T11:09:07Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-12-30T11:09:07Z"}, "message": "(const_binop): New arg NOTRUNC.  All calls changed.\n\n(size_binop): Pass 1 for NOTRUNC.\n(force_fit_type): No longer static.\n\nFrom-SVN: r2995", "tree": {"sha": "4476a5cb52665cd5bbdac7cb6f5a730e149f9e80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4476a5cb52665cd5bbdac7cb6f5a730e149f9e80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91d33e36a03b16ef089e852a721a59b65bc8373d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d33e36a03b16ef089e852a721a59b65bc8373d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91d33e36a03b16ef089e852a721a59b65bc8373d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d33e36a03b16ef089e852a721a59b65bc8373d/comments", "author": null, "committer": null, "parents": [{"sha": "825638ba06380373fceb5269416d1bf619a14e85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825638ba06380373fceb5269416d1bf619a14e85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/825638ba06380373fceb5269416d1bf619a14e85"}], "stats": {"total": 130, "additions": 72, "deletions": 58}, "files": [{"sha": "b1054fbafc59b9395671d3fd6b19f7cf181acecc", "filename": "gcc/fold-const.c", "status": "modified", "additions": 72, "deletions": 58, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d33e36a03b16ef089e852a721a59b65bc8373d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d33e36a03b16ef089e852a721a59b65bc8373d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=91d33e36a03b16ef089e852a721a59b65bc8373d", "patch": "@@ -118,7 +118,7 @@ decode (shorts, low, hi)\n    by setting to 0 or 1 all the bits in the constant\n    that don't belong in the type.  */\n \n-static void\n+void\n force_fit_type (t)\n      tree t;\n {\n@@ -1031,12 +1031,15 @@ split_tree (in, code, varp, conp, varsignp)\n /* Combine two constants NUM and ARG2 under operation CODE\n    to produce a new constant.\n    We assume ARG1 and ARG2 have the same data type,\n-   or at least are the same kind of constant and the same machine mode.  */\n+   or at least are the same kind of constant and the same machine mode.\n+\n+   If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */\n \n static tree\n-const_binop (code, arg1, arg2)\n+const_binop (code, arg1, arg2, notrunc)\n      enum tree_code code;\n      register tree arg1, arg2;\n+     int notrunc;\n {\n   if (TREE_CODE (arg1) == INTEGER_CST)\n     {\n@@ -1269,7 +1272,8 @@ const_binop (code, arg1, arg2)\n \t}\n     got_it:\n       TREE_TYPE (t) = TREE_TYPE (arg1);\n-      force_fit_type (t);\n+      if (! notrunc)\n+\tforce_fit_type (t);\n       TREE_CONSTANT_OVERFLOW (t) = overflow;\n       return t;\n     }\n@@ -1345,40 +1349,49 @@ const_binop (code, arg1, arg2)\n       switch (code)\n \t{\n \tcase PLUS_EXPR:\n-\t  t = build_complex (const_binop (PLUS_EXPR, r1, r2),\n-\t\t\t     const_binop (PLUS_EXPR, i1, i2));\n+\t  t = build_complex (const_binop (PLUS_EXPR, r1, r2, notrunc),\n+\t\t\t     const_binop (PLUS_EXPR, i1, i2, notrunc));\n \t  break;\n \n \tcase MINUS_EXPR:\n-\t  t = build_complex (const_binop (MINUS_EXPR, r1, r2),\n-\t\t\t     const_binop (MINUS_EXPR, i1, i2));\n+\t  t = build_complex (const_binop (MINUS_EXPR, r1, r2, notrunc),\n+\t\t\t     const_binop (MINUS_EXPR, i1, i2, notrunc));\n \t  break;\n \n \tcase MULT_EXPR:\n \t  t = build_complex (const_binop (MINUS_EXPR,\n-\t\t\t\t\t  const_binop (MULT_EXPR, r1, r2),\n-\t\t\t\t\t  const_binop (MULT_EXPR, i1, i2)),\n+\t\t\t\t\t  const_binop (MULT_EXPR,\n+\t\t\t\t\t\t       r1, r2, notrunc),\n+\t\t\t\t\t  const_binop (MULT_EXPR,\n+\t\t\t\t\t\t       i1, i2, notrunc),\n+\t\t\t\t\t  notrunc),\n \t\t\t     const_binop (PLUS_EXPR,\n-\t\t\t\t\t  const_binop (MULT_EXPR, r1, i2),\n-\t\t\t\t\t  const_binop (MULT_EXPR, i1, r2)));\n+\t\t\t\t\t  const_binop (MULT_EXPR,\n+\t\t\t\t\t\t       r1, i2, notrunc),\n+\t\t\t\t\t  const_binop (MULT_EXPR,\n+\t\t\t\t\t\t       i1, r2, notrunc),\n+\t\t\t\t\t  notrunc));\n \t  break;\n \n \tcase RDIV_EXPR:\n \t  {\n \t    register tree magsquared\n \t      = const_binop (PLUS_EXPR,\n-\t\t\t     const_binop (MULT_EXPR, r2, r2),\n-\t\t\t     const_binop (MULT_EXPR, i2, i2));\n+\t\t\t     const_binop (MULT_EXPR, r2, r2, notrunc),\n+\t\t\t     const_binop (MULT_EXPR, i2, i2, notrunc),\n+\t\t\t     notrunc);\n \t    t = build_complex (const_binop (RDIV_EXPR,\n \t\t\t\t\t    const_binop (PLUS_EXPR,\n-\t\t\t\t\t\t\t const_binop (MULT_EXPR, r1, r2),\n-\t\t\t\t\t\t\t const_binop (MULT_EXPR, i1, i2)),\n-\t\t\t\t\t    magsquared),\n+\t\t\t\t\t\t\t const_binop (MULT_EXPR, r1, r2, notrunc),\n+\t\t\t\t\t\t\t const_binop (MULT_EXPR, i1, i2, notrunc),\n+\t\t\t\t\t\t\t notrunc),\n+\t\t\t\t\t    magsquared, notrunc),\n \t\t\t       const_binop (RDIV_EXPR,\n \t\t\t\t\t    const_binop (MINUS_EXPR,\n-\t\t\t\t\t\t\t const_binop (MULT_EXPR, i1, r2),\n-\t\t\t\t\t\t\t const_binop (MULT_EXPR, r1, i2)),\n-\t\t\t\t\t    magsquared));\n+\t\t\t\t\t\t\t const_binop (MULT_EXPR, i1, r2, notrunc),\n+\t\t\t\t\t\t\t const_binop (MULT_EXPR, r1, i2, notrunc),\n+\t\t\t\t\t\t\t notrunc),\n+\t\t\t\t\t    magsquared, notrunc));\n \t  }\n \t  break;\n \n@@ -1448,7 +1461,7 @@ size_binop (code, arg0, arg1)\n \t  && TREE_INT_CST_HIGH (arg0) == 0)\n \treturn arg1;\n       /* Handle general case of two integer constants.  */\n-      return const_binop (code, arg0, arg1);\n+      return const_binop (code, arg0, arg1, 1);\n     }\n \n   if (arg0 == error_mark_node || arg1 == error_mark_node)\n@@ -2239,9 +2252,9 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n \n   /* Make the mask to be used against the extracted field.  */\n   mask = convert (unsigned_type, build_int_2 (~0, ~0));\n-  mask = const_binop (LSHIFT_EXPR, mask, size_int (lnbitsize - lbitsize));\n+  mask = const_binop (LSHIFT_EXPR, mask, size_int (lnbitsize - lbitsize), 0);\n   mask = const_binop (RSHIFT_EXPR, mask,\n-\t\t      size_int (lnbitsize - lbitsize - lbitpos));\n+\t\t      size_int (lnbitsize - lbitsize - lbitpos), 0);\n \n   if (! const_p)\n     /* If not comparing with constant, just rework the comparison\n@@ -2269,7 +2282,7 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n     {\n       if (! integer_zerop (const_binop (RSHIFT_EXPR,\n \t\t\t\t\tconvert (unsigned_type, rhs),\n-\t\t\t\t\tsize_int (lbitsize))))\n+\t\t\t\t\tsize_int (lbitsize), 0)))\n \t{\n \t  warning (\"comparison is always %s due to width of bitfield\",\n \t\t   code == NE_EXPR ? \"one\" : \"zero\");\n@@ -2281,7 +2294,7 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n   else\n     {\n       tree tem = const_binop (RSHIFT_EXPR, convert (signed_type, rhs),\n-\t\t\t      size_int (lbitsize - 1));\n+\t\t\t      size_int (lbitsize - 1), 0);\n       if (! integer_zerop (tem) && ! integer_all_onesp (tem))\n \t{\n \t  warning (\"comparison is always %s due to width of bitfield\",\n@@ -2308,7 +2321,7 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n \t\t\t   const_binop (LSHIFT_EXPR,\n \t\t\t\t\tconvert (unsigned_type, rhs),\n \t\t\t\t\tsize_int (lbitpos)),\n-\t\t\t   mask));\n+\t\t\t   mask, 0));\n \n   return build (code, compare_type,\n \t\tbuild (BIT_AND_EXPR, unsigned_type, lhs, mask),\n@@ -2375,8 +2388,8 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n       int precision = TYPE_PRECISION (unsigned_type);\n \n       mask = convert (unsigned_type, build_int_2 (~0, ~0));\n-      mask = const_binop (LSHIFT_EXPR, mask, size_int (precision - *pbitsize));\n-      mask = const_binop (RSHIFT_EXPR, mask, size_int (precision - *pbitsize));\n+      mask = const_binop (LSHIFT_EXPR, mask, size_int (precision - *pbitsize), 0);\n+      mask = const_binop (RSHIFT_EXPR, mask, size_int (precision - *pbitsize), 0);\n     }\n \n   *pmask = mask;\n@@ -2400,8 +2413,9 @@ all_ones_mask_p (mask, size)\n \t\t\t\t  const_binop (LSHIFT_EXPR,\n \t\t\t\t\t       convert (signed_type (type),\n \t\t\t\t\t\t\tbuild_int_2 (~0, ~0)),\n-\t\t\t\t\t       size_int (precision - size)),\n-\t\t\t\t  size_int (precision - size)), 0);\n+\t\t\t\t\t       size_int (precision - size), 0),\n+\t\t\t\t  size_int (precision - size), 0),\n+\t\t     0);\n }\n \n /* Subroutine for fold_truthop: determine if an operand is simple enough\n@@ -2471,7 +2485,7 @@ range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n \t\t && TREE_INT_CST_LOW (hi_cst) - TREE_INT_CST_LOW (lo_cst) == 1\n \t\t && tree_int_cst_equal (integer_one_node,\n \t\t\t\t\tconst_binop (MINUS_EXPR,\n-\t\t\t\t\t\t     hi_cst, lo_cst))))\n+\t\t\t\t\t\t     hi_cst, lo_cst, 0))))\n \t    return 0;\n \n \t  rcode = GT_EXPR;\n@@ -2480,12 +2494,12 @@ range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n \tcase GT_EXPR:\n \tcase GE_EXPR:\n \t  if (hi_code == LT_EXPR)\n-\t    hi_cst = const_binop (MINUS_EXPR, hi_cst, integer_one_node);\n+\t    hi_cst = const_binop (MINUS_EXPR, hi_cst, integer_one_node, 0);\n \t  else if (hi_code != LE_EXPR)\n \t    return 0;\n \n \t  if (lo_code == GT_EXPR)\n-\t    lo_cst = const_binop (PLUS_EXPR, lo_cst, integer_one_node);\n+\t    lo_cst = const_binop (PLUS_EXPR, lo_cst, integer_one_node, 0);\n \n \t  /* We now have VAR >= LO_CST && VAR <= HI_CST.  */\n \t  rcode = LE_EXPR;\n@@ -2505,7 +2519,7 @@ range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n \t\t && TREE_INT_CST_LOW (hi_cst) - TREE_INT_CST_LOW (lo_cst) == 1\n \t\t && tree_int_cst_equal (integer_one_node,\n \t\t\t\t\tconst_binop (MINUS_EXPR,\n-\t\t\t\t\t\t     hi_cst, lo_cst))))\n+\t\t\t\t\t\t     hi_cst, lo_cst, 0))))\n \t    return 0;\n \n \t  rcode = LE_EXPR;\n@@ -2514,12 +2528,12 @@ range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n \tcase LE_EXPR:\n \tcase LT_EXPR:\n \t  if (hi_code == GE_EXPR)\n-\t    hi_cst = const_binop (MINUS_EXPR, hi_cst, integer_one_node);\n+\t    hi_cst = const_binop (MINUS_EXPR, hi_cst, integer_one_node, 0);\n \t  else if (hi_code != GT_EXPR)\n \t    return 0;\n \n \t  if (lo_code == LE_EXPR)\n-\t    lo_cst = const_binop (PLUS_EXPR, lo_cst, integer_one_node);\n+\t    lo_cst = const_binop (PLUS_EXPR, lo_cst, integer_one_node, 0);\n \n \t  /* We now have VAR < LO_CST || VAR > HI_CST.  */\n \t  rcode = GT_EXPR;\n@@ -2558,7 +2572,7 @@ range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n   return fold (convert (type,\n \t\t\tbuild (rcode, utype,\n \t\t\t       build (MINUS_EXPR, utype, var, lo_cst),\n-\t\t\t       const_binop (MINUS_EXPR, hi_cst, lo_cst))));\n+\t\t\t       const_binop (MINUS_EXPR, hi_cst, lo_cst, 0))));\n }\n \f\n /* Find ways of folding logical expressions of LHS and RHS:\n@@ -2763,9 +2777,9 @@ fold_truthop (code, truth_type, lhs, rhs)\n #endif\n \n   ll_mask = const_binop (LSHIFT_EXPR, convert (type, ll_mask),\n-\t\t\t size_int (xll_bitpos));\n+\t\t\t size_int (xll_bitpos), 0);\n   rl_mask = const_binop (LSHIFT_EXPR, convert (type, rl_mask),\n-\t\t\t size_int (xrl_bitpos));\n+\t\t\t size_int (xrl_bitpos), 0);\n \n   /* Make sure the constants are interpreted as unsigned, so we\n      don't have sign bits outside the range of their type.  */\n@@ -2774,13 +2788,13 @@ fold_truthop (code, truth_type, lhs, rhs)\n     {\n       l_const = convert (unsigned_type (TREE_TYPE (l_const)), l_const);\n       l_const = const_binop (LSHIFT_EXPR, convert (type, l_const),\n-\t\t\t     size_int (xll_bitpos));\n+\t\t\t     size_int (xll_bitpos), 0);\n     }\n   if (r_const)\n     {\n       r_const = convert (unsigned_type (TREE_TYPE (r_const)), r_const);\n       r_const = const_binop (LSHIFT_EXPR, convert (type, r_const),\n-\t\t\t     size_int (xrl_bitpos));\n+\t\t\t     size_int (xrl_bitpos), 0);\n     }\n \n   /* If the right sides are not constant, do the same for it.  Also,\n@@ -2813,16 +2827,16 @@ fold_truthop (code, truth_type, lhs, rhs)\n #endif\n \n       lr_mask = const_binop (LSHIFT_EXPR, convert (type, lr_mask),\n-\t\t\t     size_int (xlr_bitpos));\n+\t\t\t     size_int (xlr_bitpos), 0);\n       rr_mask = const_binop (LSHIFT_EXPR, convert (type, rr_mask),\n-\t\t\t     size_int (xrr_bitpos));\n+\t\t\t     size_int (xrr_bitpos), 0);\n \n       /* Make a mask that corresponds to both fields being compared.\n \t Do this for both items being compared.  If the masks agree,\n \t we can do this by masking both and comparing the masked\n \t results.  */\n-      ll_mask = const_binop (BIT_IOR_EXPR, ll_mask, rl_mask);\n-      lr_mask = const_binop (BIT_IOR_EXPR, lr_mask, rr_mask);\n+      ll_mask = const_binop (BIT_IOR_EXPR, ll_mask, rl_mask, 0);\n+      lr_mask = const_binop (BIT_IOR_EXPR, lr_mask, rr_mask, 0);\n       if (operand_equal_p (ll_mask, lr_mask, 0) && lnbitsize == rnbitsize)\n \t{\n \t  lhs = make_bit_field_ref (ll_inner, type, lnbitsize, lnbitpos,\n@@ -2861,10 +2875,10 @@ fold_truthop (code, truth_type, lhs, rhs)\n      common between the masks, those bits of the constants must be the same.\n      If not, the condition is always false.  Test for this to avoid generating\n      incorrect code below.  */\n-  result = const_binop (BIT_AND_EXPR, ll_mask, rl_mask);\n+  result = const_binop (BIT_AND_EXPR, ll_mask, rl_mask, 0);\n   if (! integer_zerop (result)\n-      && simple_cst_equal (const_binop (BIT_AND_EXPR, result, l_const),\n-\t\t\t   const_binop (BIT_AND_EXPR, result, r_const)) != 1)\n+      && simple_cst_equal (const_binop (BIT_AND_EXPR, result, l_const, 0),\n+\t\t\t   const_binop (BIT_AND_EXPR, result, r_const, 0)) != 1)\n     {\n       if (wanted_code == NE_EXPR)\n \t{\n@@ -2885,12 +2899,12 @@ fold_truthop (code, truth_type, lhs, rhs)\n   result = make_bit_field_ref (ll_inner, type, lnbitsize, lnbitpos,\n \t\t\t       ll_unsignedp || rl_unsignedp);\n \n-  ll_mask = const_binop (BIT_IOR_EXPR, ll_mask, rl_mask);\n+  ll_mask = const_binop (BIT_IOR_EXPR, ll_mask, rl_mask, 0);\n   if (! all_ones_mask_p (ll_mask, lnbitsize))\n     result = build (BIT_AND_EXPR, type, result, ll_mask);\n \n   return build (wanted_code, truth_type, result,\n-\t\tconst_binop (BIT_IOR_EXPR, l_const, r_const));\n+\t\tconst_binop (BIT_IOR_EXPR, l_const, r_const, 0));\n }\n \f\n /* Perform constant folding and related simplification of EXPR.\n@@ -3307,7 +3321,7 @@ fold (expr)\n \t      && TREE_CODE (TREE_OPERAND (arg1, 1)) == INTEGER_CST\n \t      && integer_zerop (const_binop (BIT_AND_EXPR,\n \t\t\t\t\t     TREE_OPERAND (arg0, 1),\n-\t\t\t\t\t     TREE_OPERAND (arg1, 1))))\n+\t\t\t\t\t     TREE_OPERAND (arg1, 1), 0)))\n \t    {\n \t      code = BIT_IOR_EXPR;\n \t      goto bit_ior;\n@@ -3407,7 +3421,7 @@ fold (expr)\n \treturn t;\n #endif /* REAL_IS_NOT_DOUBLE, and no REAL_ARITHMETIC */\n       if (wins)\n-\tt1 = const_binop (code, arg0, arg1);\n+\tt1 = const_binop (code, arg0, arg1, 0);\n       if (t1 != NULL_TREE)\n \t{\n \t  /* The return value should always have\n@@ -3807,14 +3821,14 @@ fold (expr)\n \t    case GE_EXPR:\n \t      code = GT_EXPR;\n \t      TREE_SET_CODE (t, code);\n-\t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node);\n+\t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n \t      TREE_OPERAND (t, 1) = arg1;\n \t      break;\n \n \t    case LT_EXPR:\n \t      code = LE_EXPR;\n \t      TREE_SET_CODE (t, code);\n-\t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node);\n+\t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n \t      TREE_OPERAND (t, 1) = arg1;\n \t    }\n \t}\n@@ -4237,7 +4251,7 @@ fold (expr)\n \t\tif (! operand_equal_p (arg2, TYPE_MAX_VALUE (type), 1)\n \t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t\tconst_binop (PLUS_EXPR, arg2,\n-\t\t\t\t\t\t     integer_one_node), 1))\n+\t\t\t\t\t\t     integer_one_node, 0), 1))\n \t\t  return fold (build (MIN_EXPR, type, arg1, arg2));\n \t\tbreak;\n \n@@ -4246,7 +4260,7 @@ fold (expr)\n \t\tif (! operand_equal_p (arg2, TYPE_MIN_VALUE (type), 1)\n \t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t\tconst_binop (MINUS_EXPR, arg2,\n-\t\t\t\t\t\t     integer_one_node), 1))\n+\t\t\t\t\t\t     integer_one_node, 0), 1))\n \t\t  return fold (build (MIN_EXPR, type, arg1, arg2));\n \t\tbreak;\n \n@@ -4255,7 +4269,7 @@ fold (expr)\n \t\tif (! operand_equal_p (arg2, TYPE_MIN_VALUE (type), 1)\n \t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t\tconst_binop (MINUS_EXPR, arg2,\n-\t\t\t\t\t\t     integer_one_node), 1))\n+\t\t\t\t\t\t     integer_one_node, 0), 1))\n \t\t  return fold (build (MAX_EXPR, type, arg1, arg2));\n \t\tbreak;\n \n@@ -4264,7 +4278,7 @@ fold (expr)\n \t\tif (! operand_equal_p (arg2, TYPE_MAX_VALUE (type), 1)\n \t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t\tconst_binop (PLUS_EXPR, arg2,\n-\t\t\t\t\t\t     integer_one_node), 1))\n+\t\t\t\t\t\t     integer_one_node, 0), 1))\n \t\t  return fold (build (MAX_EXPR, type, arg1, arg2));\n \t\tbreak;\n \t      }"}]}