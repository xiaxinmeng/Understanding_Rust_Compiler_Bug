{"sha": "f27e042c9e2fbb467e2ea6724117f51aa665d239", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI3ZTA0MmM5ZTJmYmI0NjdlMmVhNjcyNDExN2Y1MWFhNjY1ZDIzOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T14:23:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T14:23:35Z"}, "message": "[multiple changes]\n\n2010-06-21  Robert Dewar  <dewar@adacore.com>\n\n\t* g-expect.ads, g-expect.adb: Minor reformatting.\n\n2010-06-21  Emmanuel Briot  <briot@adacore.com>\n\n\t* s-regpat.adb (Next_Pointer_Bytes): New named constant. Code clean up.\n\nFrom-SVN: r161083", "tree": {"sha": "b6bb0e6193f7f63dd7ed0fae2ac346030eb75d27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6bb0e6193f7f63dd7ed0fae2ac346030eb75d27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f27e042c9e2fbb467e2ea6724117f51aa665d239", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f27e042c9e2fbb467e2ea6724117f51aa665d239", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f27e042c9e2fbb467e2ea6724117f51aa665d239", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f27e042c9e2fbb467e2ea6724117f51aa665d239/comments", "author": null, "committer": null, "parents": [{"sha": "04617fd269165e2810056b69b47f917bc4793d72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04617fd269165e2810056b69b47f917bc4793d72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04617fd269165e2810056b69b47f917bc4793d72"}], "stats": {"total": 149, "additions": 83, "deletions": 66}, "files": [{"sha": "6de23ae3505b378be4fde9e6accc10b5a3d9ebd8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27e042c9e2fbb467e2ea6724117f51aa665d239/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27e042c9e2fbb467e2ea6724117f51aa665d239/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f27e042c9e2fbb467e2ea6724117f51aa665d239", "patch": "@@ -1,3 +1,11 @@\n+2010-06-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* g-expect.ads, g-expect.adb: Minor reformatting.\n+\n+2010-06-21  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* s-regpat.adb (Next_Pointer_Bytes): New named constant. Code clean up.\n+\n 2010-06-21  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Update dependencies."}, {"sha": "c8b368fc58a92de55f4bb912b2d38ce86f5f6cb9", "filename": "gcc/ada/g-expect.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27e042c9e2fbb467e2ea6724117f51aa665d239/gcc%2Fada%2Fg-expect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27e042c9e2fbb467e2ea6724117f51aa665d239/gcc%2Fada%2Fg-expect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect.adb?ref=f27e042c9e2fbb467e2ea6724117f51aa665d239", "patch": "@@ -539,6 +539,7 @@ package body GNAT.Expect is\n \n       for J in Descriptors'Range loop\n          Descriptors (J) := Regexps (J).Descriptor;\n+\n          if Descriptors (J) /= null then\n             Reinitialize_Buffer (Regexps (J).Descriptor.all);\n          end if;"}, {"sha": "9a00cf0571e6f8d2587762b5621d9ac10ce17cb1", "filename": "gcc/ada/g-expect.ads", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27e042c9e2fbb467e2ea6724117f51aa665d239/gcc%2Fada%2Fg-expect.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27e042c9e2fbb467e2ea6724117f51aa665d239/gcc%2Fada%2Fg-expect.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect.ads?ref=f27e042c9e2fbb467e2ea6724117f51aa665d239", "patch": "@@ -180,16 +180,16 @@ package GNAT.Expect is\n    --  till Expect matches), but this is slower.\n    --\n    --  If Err_To_Out is True, then the standard error of the spawned process is\n-   --  connected to the standard output. This is the only way to get the\n-   --  Except subprograms to also match on output on standard error.\n+   --  connected to the standard output. This is the only way to get the Except\n+   --  subprograms to also match on output on standard error.\n    --\n    --  Invalid_Process is raised if the process could not be spawned.\n \n    procedure Close (Descriptor : in out Process_Descriptor);\n-   --  Terminate the process and close the pipes to it. It implicitly\n-   --  does the 'wait' command required to clean up the process table.\n-   --  This also frees the buffer associated with the process id. Raise\n-   --  Invalid_Process if the process id is invalid.\n+   --  Terminate the process and close the pipes to it. It implicitly does the\n+   --  'wait' command required to clean up the process table. This also frees\n+   --  the buffer associated with the process id. Raise Invalid_Process if the\n+   --  process id is invalid.\n \n    procedure Close\n      (Descriptor : in out Process_Descriptor;\n@@ -247,8 +247,8 @@ package GNAT.Expect is\n        (Descriptor : Process_Descriptor'Class;\n         Str        : String;\n         User_Data  : System.Address := System.Null_Address);\n-   --  Function called every time new characters are read from or written\n-   --  to the process.\n+   --  Function called every time new characters are read from or written to\n+   --  the process.\n    --\n    --  Str is a string of all these characters.\n    --\n@@ -301,9 +301,9 @@ package GNAT.Expect is\n       Empty_Buffer : Boolean := False);\n    --  Send a string to the file descriptor.\n    --\n-   --  The string is not formatted in any way, except if Add_LF is True,\n-   --  in which case an ASCII.LF is added at the end, so that Str is\n-   --  recognized as a command by the external process.\n+   --  The string is not formatted in any way, except if Add_LF is True, in\n+   --  which case an ASCII.LF is added at the end, so that Str is recognized\n+   --  as a command by the external process.\n    --\n    --  If Empty_Buffer is True, any input waiting from the process (or in the\n    --  buffer) is first discarded before the command is sent. The output\n@@ -330,8 +330,8 @@ package GNAT.Expect is\n       Regexp      : String;\n       Timeout     : Integer := 10_000;\n       Full_Buffer : Boolean := False);\n-   --  Wait till a string matching Fd can be read from Fd, and return 1\n-   --  if a match was found.\n+   --  Wait till a string matching Fd can be read from Fd, and return 1 if a\n+   --  match was found.\n    --\n    --  It consumes all the characters read from Fd until a match found, and\n    --  then sets the return values for the subprograms Expect_Out and\n@@ -402,15 +402,13 @@ package GNAT.Expect is\n    type Regexp_Array is array (Positive range <>) of GNAT.OS_Lib.String_Access;\n \n    type Pattern_Matcher_Access is access all GNAT.Regpat.Pattern_Matcher;\n-   type Compiled_Regexp_Array is array (Positive range <>)\n-     of Pattern_Matcher_Access;\n+   type Compiled_Regexp_Array is\n+     array (Positive range <>) of Pattern_Matcher_Access;\n \n    function \"+\"\n-     (P    : GNAT.Regpat.Pattern_Matcher)\n-      return Pattern_Matcher_Access;\n-   --  Allocate some memory for the pattern matcher.\n-   --  This is only a convenience function to help create the array of\n-   --  compiled regular expressions.\n+     (P : GNAT.Regpat.Pattern_Matcher) return Pattern_Matcher_Access;\n+   --  Allocate some memory for the pattern matcher. This is only a convenience\n+   --  function to help create the array of compiled regular expressions.\n \n    procedure Expect\n      (Descriptor  : in out Process_Descriptor;\n@@ -441,6 +439,7 @@ package GNAT.Expect is\n       Full_Buffer : Boolean := False);\n    --  Same as above, except that you can also access the parenthesis\n    --  groups inside the matching regular expression.\n+   --\n    --  The first index in Matched must be 0, or Constraint_Error will be\n    --  raised. The index 0 contains the indexes for the whole string that was\n    --  matched, the index 1 contains the indexes for the first parentheses\n@@ -453,9 +452,8 @@ package GNAT.Expect is\n       Matched     : out GNAT.Regpat.Match_Array;\n       Timeout     : Integer := 10_000;\n       Full_Buffer : Boolean := False);\n-   --  Same as above, but with precompiled regular expressions.\n-   --  The first index in Matched must be 0, or Constraint_Error will be\n-   --  raised.\n+   --  Same as above, but with precompiled regular expressions. The first index\n+   --  in Matched must be 0, or Constraint_Error will be raised.\n \n    -------------------------------------------\n    -- Working on the output (multi-process) --\n@@ -465,8 +463,9 @@ package GNAT.Expect is\n       Descriptor : Process_Descriptor_Access;\n       Regexp     : Pattern_Matcher_Access;\n    end record;\n-   type Multiprocess_Regexp_Array is array (Positive range <>)\n-   of Multiprocess_Regexp;\n+\n+   type Multiprocess_Regexp_Array is\n+     array (Positive range <>) of Multiprocess_Regexp;\n \n    procedure Free (Regexp : in out Multiprocess_Regexp);\n    --  Free the memory occupied by Regexp\n@@ -478,10 +477,9 @@ package GNAT.Expect is\n    function First_Dead_Process\n      (Regexp : Multiprocess_Regexp_Array) return Natural;\n    --  Find the first entry in Regexp that corresponds to a dead process that\n-   --  wasn't Free-d yet.\n-   --  This function is called in general when Expect (below) raises the\n-   --  exception Process_Died.\n-   --  This returns 0 if no process has died yet.\n+   --  wasn't Free-d yet. This function is called in general when Expect\n+   --  (below) raises the exception Process_Died. This returns 0 if no process\n+   --  has died yet.\n \n    procedure Expect\n      (Result      : out Expect_Match;\n@@ -493,6 +491,7 @@ package GNAT.Expect is\n    --  Regexps can have a null Descriptor or Regexp. Such entries will\n    --  simply be ignored. Therefore when a process terminates, you can\n    --  simply reset its entry.\n+   --\n    --  The expect loop would therefore look like:\n    --\n    --     Processes : Multiprocess_Regexp_Array (...) := ...;\n@@ -517,8 +516,8 @@ package GNAT.Expect is\n       Regexps     : Multiprocess_Regexp_Array;\n       Timeout     : Integer := 10_000;\n       Full_Buffer : Boolean := False);\n-   --  Same as the previous one, but for multiple processes.\n-   --  This procedure finds the first regexp that match the associated process.\n+   --  Same as the previous one, but for multiple processes. This procedure\n+   --  finds the first regexp that match the associated process.\n \n    ------------------------\n    -- Getting the output --\n@@ -530,22 +529,22 @@ package GNAT.Expect is\n    --  Discard all output waiting from the process.\n    --\n    --  This output is simply discarded, and no filter is called. This output\n-   --  will also not be visible by the next call to Expect, nor will any\n-   --  output currently buffered.\n+   --  will also not be visible by the next call to Expect, nor will any output\n+   --  currently buffered.\n    --\n    --  Timeout is the delay for which we wait for output to be available from\n    --  the process. If 0, we only get what is immediately available.\n \n    function Expect_Out (Descriptor : Process_Descriptor) return String;\n    --  Return the string matched by the last Expect call.\n    --\n-   --  The returned string is in fact the concatenation of all the strings\n-   --  read from the file descriptor up to, and including, the characters\n-   --  that matched the regular expression.\n+   --  The returned string is in fact the concatenation of all the strings read\n+   --  from the file descriptor up to, and including, the characters that\n+   --  matched the regular expression.\n    --\n-   --  For instance, with an input \"philosophic\", and a regular expression\n-   --  \"hi\" in the call to expect, the strings returned the first and second\n-   --  time would be respectively \"phi\" and \"losophi\".\n+   --  For instance, with an input \"philosophic\", and a regular expression \"hi\"\n+   --  in the call to expect, the strings returned the first and second time\n+   --  would be respectively \"phi\" and \"losophi\".\n \n    function Expect_Out_Match (Descriptor : Process_Descriptor) return String;\n    --  Return the string matched by the last Expect call.\n@@ -609,10 +608,9 @@ private\n       Pipe3 : in out Pipe_Type;\n       Cmd   : String;\n       Args  : System.Address);\n-   --  Finish the set up of the pipes while in the child process\n-   --  This also spawns the child process (based on Cmd).\n-   --  On systems that support fork, this procedure is executed inside the\n-   --  newly created process.\n+   --  Finish the set up of the pipes while in the child process This also\n+   --  spawns the child process (based on Cmd). On systems that support fork,\n+   --  this procedure is executed inside the newly created process.\n \n    type Process_Descriptor is tagged record\n       Pid              : aliased Process_Id := Invalid_Pid;\n@@ -640,7 +638,7 @@ private\n       Args : System.Address);\n    pragma Import (C, Portable_Execvp, \"__gnat_expect_portable_execvp\");\n    --  Executes, in a portable way, the command Cmd (full path must be\n-   --  specified), with the given Args. Args must be an array of string\n+   --  specified), with the given Args, which must be an array of string\n    --  pointers. Note that the first element in Args must be the executable\n    --  name, and the last element must be a null pointer. The returned value\n    --  in Pid is the process ID, or zero if not supported on the platform."}, {"sha": "1c0cf746a531e45bd5e8473b6c84d64d8944e309", "filename": "gcc/ada/s-regpat.adb", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27e042c9e2fbb467e2ea6724117f51aa665d239/gcc%2Fada%2Fs-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27e042c9e2fbb467e2ea6724117f51aa665d239/gcc%2Fada%2Fs-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regpat.adb?ref=f27e042c9e2fbb467e2ea6724117f51aa665d239", "patch": "@@ -182,6 +182,12 @@ package body System.Regpat is\n    --  Using two bytes for the \"next\" pointer is vast overkill for most\n    --  things, but allows patterns to get big without disasters.\n \n+   Next_Pointer_Bytes : constant := 3;\n+   --  Points after the \"next pointer\" data. An instruction is therefore:\n+   --     1 byte: instruction opcode\n+   --     2 bytes: pointer to next instruction\n+   --     * bytes: optional data for the instruction\n+\n    -----------------------\n    -- Character classes --\n    -----------------------\n@@ -347,7 +353,7 @@ package body System.Regpat is\n         (Program_Data, Character_Class);\n \n    begin\n-      Op (0 .. 31) := Convert (Program (P + 3 .. P + 34));\n+      Op (0 .. 31) := Convert (Program (P + Next_Pointer_Bytes .. P + 34));\n    end Bitmap_Operand;\n \n    -------------\n@@ -582,7 +588,7 @@ package body System.Regpat is\n             Program (Emit_Ptr + 2) := ASCII.NUL;\n          end if;\n \n-         Emit_Ptr := Emit_Ptr + 3;\n+         Emit_Ptr := Emit_Ptr + Next_Pointer_Bytes;\n          return Result;\n       end Emit_Node;\n \n@@ -660,8 +666,8 @@ package body System.Regpat is\n          Old    : Pointer;\n       begin\n          Old := Insert_Operator_Before (Op, Operand, Greedy, Opsize => 7);\n-         Emit_Natural (Old + 3, Min);\n-         Emit_Natural (Old + 5, Max);\n+         Emit_Natural (Old + Next_Pointer_Bytes, Min);\n+         Emit_Natural (Old + Next_Pointer_Bytes + 2, Max);\n       end Insert_Curly_Operator;\n \n       ----------------------------\n@@ -682,7 +688,7 @@ package body System.Regpat is\n          --  If not greedy, we have to emit another opcode first\n \n          if not Greedy then\n-            Size := Size + 3;\n+            Size := Size + Next_Pointer_Bytes;\n          end if;\n \n          --  Move the operand in the byte-compilation, so that we can insert\n@@ -700,7 +706,7 @@ package body System.Regpat is\n \n          if not Greedy then\n             Old := Emit_Node (MINMOD);\n-            Link_Tail (Old, Old + 3);\n+            Link_Tail (Old, Old + Next_Pointer_Bytes);\n          end if;\n \n          Old := Emit_Node (Op);\n@@ -720,7 +726,8 @@ package body System.Regpat is\n          Discard : Pointer;\n          pragma Warnings (Off, Discard);\n       begin\n-         Discard := Insert_Operator_Before (Op, Operand, Greedy, Opsize => 3);\n+         Discard := Insert_Operator_Before\n+            (Op, Operand, Greedy, Opsize => Next_Pointer_Bytes);\n       end Insert_Operator;\n \n       -----------------------\n@@ -803,10 +810,10 @@ package body System.Regpat is\n \n       begin\n          --  Find last node (the size of the pattern matcher might be too\n-         --  small, so don't try to read past its end)\n+         --  small, so don't try to read past its end).\n \n          Scan := P;\n-         while Scan + 3 <= PM.Size loop\n+         while Scan + Next_Pointer_Bytes <= PM.Size loop\n             Temp := Get_Next (Program, Scan);\n             exit when Temp = Scan;\n             Scan := Temp;\n@@ -1618,7 +1625,7 @@ package body System.Regpat is\n          --  is an initial string to emit, do it now.\n \n          if Has_Special_Operator\n-           and then Emit_Ptr >= Length_Ptr + 3\n+           and then Emit_Ptr >= Length_Ptr + Next_Pointer_Bytes\n          then\n             Emit_Ptr := Emit_Ptr - 1;\n             Parse_Pos := Start_Pos;\n@@ -2105,7 +2112,8 @@ package body System.Regpat is\n \n             if Op = OPEN or else Op = CLOSE or else Op = REFF then\n                Put (Image (Natural'Image\n-                            (Character'Pos (Program (Index + 3)))));\n+                            (Character'Pos\n+                               (Program (Index + Next_Pointer_Bytes)))));\n             end if;\n \n             if Next = Index then\n@@ -2165,7 +2173,7 @@ package body System.Regpat is\n                      Put_Line (\"]\");\n                   end if;\n \n-                  Index := Index + 3 + Bitmap'Length;\n+                  Index := Index + Next_Pointer_Bytes + Bitmap'Length;\n                end;\n \n             when EXACT | EXACTF =>\n@@ -2188,15 +2196,16 @@ package body System.Regpat is\n                   New_Line;\n                end if;\n \n-               Index  := Index + 3;\n+               Index  := Index + Next_Pointer_Bytes;\n                Dump_Until (Program, Index, Pointer'Min (Next, Till),\n                            Local_Indent + 1, Do_Print);\n \n             when CURLY | CURLYX =>\n                if Do_Print then\n                   Put_Line\n                     (\" {\"\n-                    & Image (Natural'Image (Read_Natural (Program, Index + 3)))\n+                    & Image (Natural'Image\n+                       (Read_Natural (Program, Index + Next_Pointer_Bytes)))\n                     & \",\"\n                     & Image (Natural'Image (Read_Natural (Program, Index + 5)))\n                     & \"}\");\n@@ -2226,7 +2235,7 @@ package body System.Regpat is\n                end if;\n \n             when others =>\n-               Index := Index + 3;\n+               Index := Index + Next_Pointer_Bytes;\n \n                if Do_Print then\n                   New_Line;\n@@ -2794,9 +2803,10 @@ package body System.Regpat is\n \n                   declare\n                      Min : constant Natural :=\n-                             Read_Natural (Program, Scan + 3);\n+                             Read_Natural (Program, Scan + Next_Pointer_Bytes);\n                      Max : constant Natural :=\n-                             Read_Natural (Program, Scan + 5);\n+                             Read_Natural\n+                                (Program, Scan + Next_Pointer_Bytes + 2);\n                      Cc  : aliased Current_Curly_Record;\n \n                      Has_Match : Boolean;\n@@ -2814,7 +2824,7 @@ package body System.Regpat is\n                      Greedy := True;\n                      Current_Curly := Cc'Unchecked_Access;\n \n-                     Has_Match := Match (Next - 3);\n+                     Has_Match := Match (Next - Next_Pointer_Bytes);\n \n                      --  Start on the WHILEM\n \n@@ -2896,8 +2906,8 @@ package body System.Regpat is\n                Operand_Code := Operand (Scan);\n \n             when others =>\n-               Min := Read_Natural (Program, Scan + 3);\n-               Max := Read_Natural (Program, Scan + 5);\n+               Min := Read_Natural (Program, Scan + Next_Pointer_Bytes);\n+               Max := Read_Natural (Program, Scan + Next_Pointer_Bytes + 2);\n                Operand_Code := Scan + 7;\n          end case;\n \n@@ -3573,7 +3583,7 @@ package body System.Regpat is\n \n    function Operand (P : Pointer) return Pointer is\n    begin\n-      return P + 3;\n+      return P + Next_Pointer_Bytes;\n    end Operand;\n \n    --------------\n@@ -3690,7 +3700,7 @@ package body System.Regpat is\n    is\n    begin\n       pragma Assert (Program (P) = EXACT or else Program (P) = EXACTF);\n-      return Character'Pos (Program (P + 3));\n+      return Character'Pos (Program (P + Next_Pointer_Bytes));\n    end String_Length;\n \n    --------------------"}]}