{"sha": "3e78238a1ec175b6f3b90ba7cd11891a6f965642", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U3ODIzOGExZWMxNzViNmYzYjkwYmE3Y2QxMTg5MWE2Zjk2NTY0Mg==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-08-26T19:48:43Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-08-26T19:48:43Z"}, "message": "re PR fortran/38936 ([F03] ASSOCIATE construct / improved SELECT TYPE (a=>expr))\n\n2010-08-26  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/38936\n\tPR fortran/44047\n\tPR fortran/45384\n\t* gfortran.h (struct gfc_association_list): New flag `dangling'.\n\t(gfc_build_block_ns): Declared here...\n\t* parse.h (gfc_build_block_ns): ...instead of here.\n\t* trans.h (gfc_process_block_locals): Expect additionally the\n\tgfc_association_list of BLOCK (if present).\n\t* match.c (select_type_set_tmp): Create sym->assoc for temporary.\n\t* resolve.c (resolve_variable): Only check for invalid *array*\n\treferences on associate-names.\n\t(resolve_assoc_var): New method with code previously in resolve_symbol.\n\t(resolve_select_type): Use association to give the selector and\n\ttemporaries their values instead of ordinary assignment.\n\t(resolve_fl_var_and_proc): Allow CLASS associate-names.\n\t(resolve_symbol): Use new `resolve_assoc_var' instead of inlining here.\n\t* trans-stmt.c (gfc_trans_block_construct): Pass association-list\n\tto `gfc_process_block_locals' to match new interface.\n\t* trans-decl.c (gfc_get_symbol_decl): Don't defer associate-names\n\there automatically.\n\t(gfc_process_block_locals): Defer them rather here when linked to\n\tfrom the BLOCK's association list.\n\n2010-08-26  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/38936\n\tPR fortran/44047\n\tPR fortran/45384\n\t* gfortran.dg/associate_8.f03: New test.\n\t* gfortran.dg/select_type_13.f03: New test.\n\t* gfortran.dg/select_type_14.f03: New test.\n\nFrom-SVN: r163572", "tree": {"sha": "3253606a72c204972630859132fcc26542c52898", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3253606a72c204972630859132fcc26542c52898"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e78238a1ec175b6f3b90ba7cd11891a6f965642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e78238a1ec175b6f3b90ba7cd11891a6f965642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e78238a1ec175b6f3b90ba7cd11891a6f965642", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e78238a1ec175b6f3b90ba7cd11891a6f965642/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "707bcb7ae4fbf293236605bf754382266f9d9220", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/707bcb7ae4fbf293236605bf754382266f9d9220", "html_url": "https://github.com/Rust-GCC/gccrs/commit/707bcb7ae4fbf293236605bf754382266f9d9220"}], "stats": {"total": 387, "additions": 282, "deletions": 105}, "files": [{"sha": "4377bd2e0dad6d3589147c0c6b20ddc661f29665", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3e78238a1ec175b6f3b90ba7cd11891a6f965642", "patch": "@@ -1,3 +1,28 @@\n+2010-08-26  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/38936\n+\tPR fortran/44047\n+\tPR fortran/45384\n+\t* gfortran.h (struct gfc_association_list): New flag `dangling'.\n+\t(gfc_build_block_ns): Declared here...\n+\t* parse.h (gfc_build_block_ns): ...instead of here.\n+\t* trans.h (gfc_process_block_locals): Expect additionally the\n+\tgfc_association_list of BLOCK (if present).\n+\t* match.c (select_type_set_tmp): Create sym->assoc for temporary.\n+\t* resolve.c (resolve_variable): Only check for invalid *array*\n+\treferences on associate-names.\n+\t(resolve_assoc_var): New method with code previously in resolve_symbol.\n+\t(resolve_select_type): Use association to give the selector and\n+\ttemporaries their values instead of ordinary assignment.\n+\t(resolve_fl_var_and_proc): Allow CLASS associate-names.\n+\t(resolve_symbol): Use new `resolve_assoc_var' instead of inlining here.\n+\t* trans-stmt.c (gfc_trans_block_construct): Pass association-list\n+\tto `gfc_process_block_locals' to match new interface.\n+\t* trans-decl.c (gfc_get_symbol_decl): Don't defer associate-names\n+\there automatically.\n+\t(gfc_process_block_locals): Defer them rather here when linked to\n+\tfrom the BLOCK's association list.\n+\n 2010-08-25  Jakub Jelinek  <jakub@redhat.com>\n \n \t* trans-decl.c (gfc_build_intrinsic_function_decls): Set"}, {"sha": "689b9df636b1569dd7992e5914573824cf464d04", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=3e78238a1ec175b6f3b90ba7cd11891a6f965642", "patch": "@@ -2007,6 +2007,12 @@ typedef struct gfc_association_list\n      lvalue.  */\n   unsigned variable:1;\n \n+  /* True if this struct is currently only linked to from a gfc_symbol rather\n+     than as part of a real list in gfc_code->ext.block.assoc.  This may\n+     happen for SELECT TYPE temporaries and must be considered\n+     for memory handling.  */\n+  unsigned dangling:1;\n+\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symtree *st; /* Symtree corresponding to name.  */\n   locus where;\n@@ -2831,6 +2837,7 @@ void gfc_dump_parse_tree (gfc_namespace *, FILE *);\n /* parse.c */\n gfc_try gfc_parse_file (void);\n void gfc_global_used (gfc_gsymbol *, locus *);\n+gfc_namespace* gfc_build_block_ns (gfc_namespace *);\n \n /* dependency.c */\n int gfc_dep_compare_expr (gfc_expr *, gfc_expr *);"}, {"sha": "21dbcde8b7b60e9d13ef27497462fa524143dc48", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=3e78238a1ec175b6f3b90ba7cd11891a6f965642", "patch": "@@ -4479,6 +4479,12 @@ select_type_set_tmp (gfc_typespec *ts)\n       tmp->n.sym->attr.class_ok = 1;\n     }\n \n+  /* Add an association for it, so the rest of the parser knows it is\n+     an associate-name.  The target will be set during resolution.  */\n+  tmp->n.sym->assoc = gfc_get_association_list ();\n+  tmp->n.sym->assoc->dangling = 1;\n+  tmp->n.sym->assoc->st = tmp;\n+\n   select_type_stack->tmp = tmp;\n }\n "}, {"sha": "3fac1c774b7fd461f88f1d1306604e02579aef99", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=3e78238a1ec175b6f3b90ba7cd11891a6f965642", "patch": "@@ -68,5 +68,4 @@ match gfc_match_enumerator_def (void);\n void gfc_free_enum_history (void);\n extern bool gfc_matching_function;\n match gfc_match_prefix (gfc_typespec *);\n-gfc_namespace* gfc_build_block_ns (gfc_namespace *);\n #endif  /* GFC_PARSE_H  */"}, {"sha": "68faf8be815df131602c0f19ad2f840b4130f6de", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 135, "deletions": 100, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=3e78238a1ec175b6f3b90ba7cd11891a6f965642", "patch": "@@ -4921,9 +4921,9 @@ resolve_variable (gfc_expr *e)\n     return FAILURE;\n   sym = e->symtree->n.sym;\n \n-  /* If this is an associate-name, it may be parsed with references in error\n-     even though the target is scalar.  Fail directly in this case.  */\n-  if (sym->assoc && !sym->attr.dimension && e->ref)\n+  /* If this is an associate-name, it may be parsed with an array reference\n+     in error even though the target is scalar.  Fail directly in this case.  */\n+  if (sym->assoc && !sym->attr.dimension && e->ref && e->ref->type == REF_ARRAY)\n     return FAILURE;\n \n   /* On the other hand, the parser may not have known this is an array;\n@@ -7551,6 +7551,88 @@ gfc_type_is_extensible (gfc_symbol *sym)\n }\n \n \n+/* Resolve an associate name:  Resolve target and ensure the type-spec is\n+   correct as well as possibly the array-spec.  */\n+\n+static void\n+resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n+{\n+  gfc_expr* target;\n+  bool to_var;\n+\n+  gcc_assert (sym->assoc);\n+  gcc_assert (sym->attr.flavor == FL_VARIABLE);\n+\n+  /* If this is for SELECT TYPE, the target may not yet be set.  In that\n+     case, return.  Resolution will be called later manually again when\n+     this is done.  */\n+  target = sym->assoc->target;\n+  if (!target)\n+    return;\n+  gcc_assert (!sym->assoc->dangling);\n+\n+  if (resolve_target && gfc_resolve_expr (target) != SUCCESS)\n+    return;\n+\n+  /* For variable targets, we get some attributes from the target.  */\n+  if (target->expr_type == EXPR_VARIABLE)\n+    {\n+      gfc_symbol* tsym;\n+\n+      gcc_assert (target->symtree);\n+      tsym = target->symtree->n.sym;\n+\n+      sym->attr.asynchronous = tsym->attr.asynchronous;\n+      sym->attr.volatile_ = tsym->attr.volatile_;\n+\n+      sym->attr.target = (tsym->attr.target || tsym->attr.pointer);\n+    }\n+\n+  sym->ts = target->ts;\n+  gcc_assert (sym->ts.type != BT_UNKNOWN);\n+\n+  /* See if this is a valid association-to-variable.  */\n+  to_var = (target->expr_type == EXPR_VARIABLE\n+\t    && !gfc_has_vector_subscript (target));\n+  if (sym->assoc->variable && !to_var)\n+    {\n+      if (target->expr_type == EXPR_VARIABLE)\n+\tgfc_error (\"'%s' at %L associated to vector-indexed target can not\"\n+\t\t   \" be used in a variable definition context\",\n+\t\t   sym->name, &sym->declared_at);\n+      else\n+\tgfc_error (\"'%s' at %L associated to expression can not\"\n+\t\t   \" be used in a variable definition context\",\n+\t\t   sym->name, &sym->declared_at);\n+\n+      return;\n+    }\n+  sym->assoc->variable = to_var;\n+\n+  /* Finally resolve if this is an array or not.  */\n+  if (sym->attr.dimension && target->rank == 0)\n+    {\n+      gfc_error (\"Associate-name '%s' at %L is used as array\",\n+\t\t sym->name, &sym->declared_at);\n+      sym->attr.dimension = 0;\n+      return;\n+    }\n+  if (target->rank > 0)\n+    sym->attr.dimension = 1;\n+\n+  if (sym->attr.dimension)\n+    {\n+      sym->as = gfc_get_array_spec ();\n+      sym->as->rank = target->rank;\n+      sym->as->type = AS_DEFERRED;\n+\n+      /* Target must not be coindexed, thus the associate-variable\n+\t has no corank.  */\n+      sym->as->corank = 0;\n+    }\n+}\n+\n+\n /* Resolve a SELECT TYPE statement.  */\n \n static void\n@@ -7628,37 +7710,42 @@ resolve_select_type (gfc_code *code)\n \t}\n     }\n     \n-  if (error>0)\n+  if (error > 0)\n     return;\n \n+  /* Transform SELECT TYPE statement to BLOCK and associate selector to\n+     target if present.  */\n+  code->op = EXEC_BLOCK;\n   if (code->expr2)\n     {\n-      /* Insert assignment for selector variable.  */\n-      new_st = gfc_get_code ();\n-      new_st->op = EXEC_ASSIGN;\n-      new_st->expr1 = gfc_copy_expr (code->expr1);\n-      new_st->expr2 = gfc_copy_expr (code->expr2);\n-      ns->code = new_st;\n+      gfc_association_list* assoc;\n+\n+      assoc = gfc_get_association_list ();\n+      assoc->st = code->expr1->symtree;\n+      assoc->target = gfc_copy_expr (code->expr2);\n+      /* assoc->variable will be set by resolve_assoc_var.  */\n+      \n+      code->ext.block.assoc = assoc;\n+      code->expr1->symtree->n.sym->assoc = assoc;\n+\n+      resolve_assoc_var (code->expr1->symtree->n.sym, false);\n     }\n+  else\n+    code->ext.block.assoc = NULL;\n \n-  /* Put SELECT TYPE statement inside a BLOCK.  */\n+  /* Add EXEC_SELECT to switch on type.  */\n   new_st = gfc_get_code ();\n   new_st->op = code->op;\n   new_st->expr1 = code->expr1;\n   new_st->expr2 = code->expr2;\n   new_st->block = code->block;\n+  code->expr1 = code->expr2 =  NULL;\n+  code->block = NULL;\n   if (!ns->code)\n     ns->code = new_st;\n   else\n     ns->code->next = new_st;\n-  code->op = EXEC_BLOCK;\n-  code->ext.block.assoc = NULL;\n-  code->expr1 = code->expr2 =  NULL;\n-  code->block = NULL;\n-\n   code = new_st;\n-\n-  /* Transform to EXEC_SELECT.  */\n   code->op = EXEC_SELECT;\n   gfc_add_component_ref (code->expr1, \"$vptr\");\n   gfc_add_component_ref (code->expr1, \"$hash\");\n@@ -7675,24 +7762,37 @@ resolve_select_type (gfc_code *code)\n       else if (c->ts.type == BT_UNKNOWN)\n \tcontinue;\n \n-      /* Assign temporary to selector.  */\n+      /* Associate temporary to selector.  This should only be done\n+\t when this case is actually true, so build a new ASSOCIATE\n+\t that does precisely this here (instead of using the\n+\t 'global' one).  */\n+\n       if (c->ts.type == BT_CLASS)\n \tsprintf (name, \"tmp$class$%s\", c->ts.u.derived->name);\n       else\n \tsprintf (name, \"tmp$type$%s\", c->ts.u.derived->name);\n       st = gfc_find_symtree (ns->sym_root, name);\n-      new_st = gfc_get_code ();\n-      new_st->expr1 = gfc_get_variable_expr (st);\n-      new_st->expr2 = gfc_get_variable_expr (code->expr1->symtree);\n+      gcc_assert (st->n.sym->assoc);\n+      st->n.sym->assoc->target = gfc_get_variable_expr (code->expr1->symtree);\n       if (c->ts.type == BT_DERIVED)\n+\tgfc_add_component_ref (st->n.sym->assoc->target, \"$data\");\n+\n+      new_st = gfc_get_code ();\n+      new_st->op = EXEC_BLOCK;\n+      new_st->ext.block.ns = gfc_build_block_ns (ns);\n+      new_st->ext.block.ns->code = body->next;\n+      body->next = new_st;\n+\n+      /* Chain in the new list only if it is marked as dangling.  Otherwise\n+\t there is a CASE label overlap and this is already used.  Just ignore,\n+\t the error is diagonsed elsewhere.  */\n+      if (st->n.sym->assoc->dangling)\n \t{\n-\t  new_st->op = EXEC_POINTER_ASSIGN;\n-\t  gfc_add_component_ref (new_st->expr2, \"$data\");\n+\t  new_st->ext.block.assoc = st->n.sym->assoc;\n+\t  st->n.sym->assoc->dangling = 0;\n \t}\n-      else\n-\tnew_st->op = EXEC_POINTER_ASSIGN;\n-      new_st->next = body->next;\n-      body->next = new_st;\n+\n+      resolve_assoc_var (st->n.sym, false);\n     }\n     \n   /* Take out CLASS IS cases for separate treatment.  */\n@@ -8405,7 +8505,7 @@ resolve_block_construct (gfc_code* code)\n   gfc_resolve (code->ext.block.ns);\n \n   /* For an ASSOCIATE block, the associations (and their targets) are already\n-     resolved during gfc_resolve_symbol.  */\n+     resolved during resolve_symbol.  */\n }\n \n \n@@ -9634,8 +9734,10 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n \t}\n \n       /* F03:C509.  */\n-      /* Assume that use associated symbols were checked in the module ns.  */ \n-      if (!sym->attr.class_ok && !sym->attr.use_assoc)\n+      /* Assume that use associated symbols were checked in the module ns.\n+\t Class-variables that are associate-names are also something special\n+\t and excepted from the test.  */\n+      if (!sym->attr.class_ok && !sym->attr.use_assoc && !sym->assoc)\n \t{\n \t  gfc_error (\"CLASS variable '%s' at %L must be dummy, allocatable \"\n \t\t     \"or pointer\", sym->name, &sym->declared_at);\n@@ -11701,76 +11803,9 @@ resolve_symbol (gfc_symbol *sym)\n       && resolve_intrinsic (sym, &sym->declared_at) == FAILURE)\n     return;\n \n-  /* For associate names, resolve corresponding expression and make sure\n-     they get their type-spec set this way.  */\n+  /* Resolve associate names.  */\n   if (sym->assoc)\n-    {\n-      gfc_expr* target;\n-      bool to_var;\n-\n-      gcc_assert (sym->attr.flavor == FL_VARIABLE);\n-\n-      target = sym->assoc->target;\n-      if (gfc_resolve_expr (target) != SUCCESS)\n-\treturn;\n-\n-      /* For variable targets, we get some attributes from the target.  */\n-      if (target->expr_type == EXPR_VARIABLE)\n-\t{\n-\t  gfc_symbol* tsym;\n-\n-\t  gcc_assert (target->symtree);\n-\t  tsym = target->symtree->n.sym;\n-\n-\t  sym->attr.asynchronous = tsym->attr.asynchronous;\n-\t  sym->attr.volatile_ = tsym->attr.volatile_;\n-\n-\t  sym->attr.target = (tsym->attr.target || tsym->attr.pointer);\n-\t}\n-\n-      sym->ts = target->ts;\n-      gcc_assert (sym->ts.type != BT_UNKNOWN);\n-\n-      /* See if this is a valid association-to-variable.  */\n-      to_var = (target->expr_type == EXPR_VARIABLE\n-\t\t&& !gfc_has_vector_subscript (target));\n-      if (sym->assoc->variable && !to_var)\n-\t{\n-\t  if (target->expr_type == EXPR_VARIABLE)\n-\t    gfc_error (\"'%s' at %L associated to vector-indexed target can not\"\n-\t\t       \" be used in a variable definition context\",\n-\t\t       sym->name, &sym->declared_at);\n-\t  else\n-\t    gfc_error (\"'%s' at %L associated to expression can not\"\n-\t\t       \" be used in a variable definition context\",\n-\t\t       sym->name, &sym->declared_at);\n-\n-\t  return;\n-\t}\n-      sym->assoc->variable = to_var;\n-\n-      /* Finally resolve if this is an array or not.  */\n-      if (sym->attr.dimension && target->rank == 0)\n-\t{\n-\t  gfc_error (\"Associate-name '%s' at %L is used as array\",\n-\t\t     sym->name, &sym->declared_at);\n-\t  sym->attr.dimension = 0;\n-\t  return;\n-\t}\n-      if (target->rank > 0)\n-\tsym->attr.dimension = 1;\n-\n-      if (sym->attr.dimension)\n-\t{\n-\t  sym->as = gfc_get_array_spec ();\n-\t  sym->as->rank = target->rank;\n-\t  sym->as->type = AS_DEFERRED;\n-\n-\t  /* Target must not be coindexed, thus the associate-variable\n-\t     has no corank.  */\n-\t  sym->as->corank = 0;\n-\t}\n-    }\n+    resolve_assoc_var (sym, true);\n \n   /* Assign default type to symbols that need one and don't have one.  */\n   if (sym->ts.type == BT_UNKNOWN)"}, {"sha": "af54a7de0045fd4dc9dacefcc3ea5a90a9bc22c2", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=3e78238a1ec175b6f3b90ba7cd11891a6f965642", "patch": "@@ -1218,7 +1218,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n     }\n \n   /* Remember this variable for allocation/cleanup.  */\n-  if (sym->attr.dimension || sym->attr.allocatable || sym->assoc\n+  if (sym->attr.dimension || sym->attr.allocatable\n       || (sym->ts.type == BT_CLASS &&\n \t  (CLASS_DATA (sym)->attr.dimension\n \t   || CLASS_DATA (sym)->attr.allocatable))\n@@ -4869,13 +4869,22 @@ gfc_generate_block_data (gfc_namespace * ns)\n /* Process the local variables of a BLOCK construct.  */\n \n void\n-gfc_process_block_locals (gfc_namespace* ns)\n+gfc_process_block_locals (gfc_namespace* ns, gfc_association_list* assoc)\n {\n   tree decl;\n \n   gcc_assert (saved_local_decls == NULL_TREE);\n   generate_local_vars (ns);\n \n+  /* Mark associate names to be initialized.  The symbol's namespace may not\n+     be the BLOCK's, we have to force this so that the deferring\n+     works as expected.  */\n+  for (; assoc; assoc = assoc->next)\n+    {\n+      assoc->st->n.sym->ns = ns;\n+      gfc_defer_symbol_init (assoc->st->n.sym);\n+    }\n+\n   decl = saved_local_decls;\n   while (decl)\n     {"}, {"sha": "747f08a20b065d6da7c2355a77e0e5df43fe6b44", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=3e78238a1ec175b6f3b90ba7cd11891a6f965642", "patch": "@@ -860,7 +860,7 @@ gfc_trans_block_construct (gfc_code* code)\n   gcc_assert (!sym->tlink);\n   sym->tlink = sym;\n \n-  gfc_process_block_locals (ns);\n+  gfc_process_block_locals (ns, code->ext.block.assoc);\n \n   gfc_start_wrapped_block (&body, gfc_trans_code (ns->code));\n   gfc_trans_deferred_vars (sym, &body);"}, {"sha": "ff91413edf559f47d5df071147052dcb466cd98e", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=3e78238a1ec175b6f3b90ba7cd11891a6f965642", "patch": "@@ -538,7 +538,7 @@ tree gfc_build_library_function_decl_with_spec (tree name, const char *spec,\n \t\t\t\t\t\ttree rettype, int nargs, ...);\n \n /* Process the local variable decls of a block construct.  */\n-void gfc_process_block_locals (gfc_namespace*);\n+void gfc_process_block_locals (gfc_namespace*, gfc_association_list*);\n \n /* Output initialization/clean-up code that was deferred.  */\n void gfc_trans_deferred_vars (gfc_symbol*, gfc_wrapped_block *);"}, {"sha": "5da1f904b1ab8677c3ab0a8b3d3444207b38aa00", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3e78238a1ec175b6f3b90ba7cd11891a6f965642", "patch": "@@ -1,3 +1,12 @@\n+2010-08-26  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/38936\n+\tPR fortran/44047\n+\tPR fortran/45384\n+\t* gfortran.dg/associate_8.f03: New test.\n+\t* gfortran.dg/select_type_13.f03: New test.\n+\t* gfortran.dg/select_type_14.f03: New test.\n+\n 2010-08-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/44485"}, {"sha": "0c95acb8c2b3ea460b666bbc7ab1cd34f3da1bb2", "filename": "gcc/testsuite/gfortran.dg/associate_8.f03", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_8.f03?ref=3e78238a1ec175b6f3b90ba7cd11891a6f965642", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do run}\n+! { dg-options \"-std=f2003 -fall-intrinsics\" }\n+\n+! PR fortran/38936\n+! Check associate to polymorphic entities.\n+\n+! Contributed by Tobias Burnus, burnus@gcc.gnu.org.\n+\n+type t\n+end type t\n+\n+type, extends(t) :: t2\n+end type t2\n+\n+class(t), allocatable :: a, b\n+allocate( t :: a)\n+allocate( t2 :: b)\n+\n+associate ( one => a, two => b)\n+  select type(two)\n+    type is (t)\n+      call abort ()\n+    type is (t2)\n+      print *, 'OK', two\n+    class default\n+      call abort ()\n+  end select\n+  select type(one)\n+    type is (t2)\n+      call abort ()\n+    type is (t)\n+      print *, 'OK', one\n+    class default\n+      call abort ()\n+  end select\n+end associate\n+end"}, {"sha": "8546ccbe825c9b62c3cfb3ca4e66e64d8d1afa66", "filename": "gcc/testsuite/gfortran.dg/select_type_13.f03", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_13.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_13.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_13.f03?ref=3e78238a1ec175b6f3b90ba7cd11891a6f965642", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+\n+! PR fortran/45384\n+! Double free happened, check that it works now.\n+\n+! Contributed by Salvatore Filippone  <salvatore.filippone@uniroma2.it>\n+\n+program bug20\n+\n+  type :: d_base_sparse_mat\n+    integer :: v(10) = 0.\n+  end type d_base_sparse_mat\n+\n+  class(d_base_sparse_mat),allocatable :: a\n+\n+  allocate (d_base_sparse_mat :: a)\n+\n+  select type(aa => a)\n+  type is (d_base_sparse_mat)\n+    write(0,*) 'NV = ',size(aa%v)\n+    if (size(aa%v) /= 10) call abort ()\n+  class default \n+    write(0,*) 'Not implemented yet '\n+  end select\n+\n+end program bug20"}, {"sha": "2d37bbc7f8bd6edde46da8cd3b4c02b232964a5c", "filename": "gcc/testsuite/gfortran.dg/select_type_14.f03", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_14.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e78238a1ec175b6f3b90ba7cd11891a6f965642/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_14.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_14.f03?ref=3e78238a1ec175b6f3b90ba7cd11891a6f965642", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+\n+! PR fortran/44047\n+! Double free happened, check that it works now.\n+\n+! Contributed by Janus Weil, janus@gcc.gnu.org.\n+\n+implicit none\n+type t0\n+ integer :: j = 42\n+end type t0\n+type t\n+ integer :: i\n+ class(t0), allocatable :: foo\n+end type t\n+type(t) :: m\n+allocate(t0 :: m%foo)\n+m%i = 5\n+select type(bar => m%foo)\n+type is(t0)\n+ print *, bar\n+ if (bar%j /= 42) call abort ()\n+end select\n+end"}]}