{"sha": "c9f4c45115dfba1d84958c1a971a333763976b7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzlmNGM0NTExNWRmYmExZDg0OTU4YzFhOTcxYTMzMzc2Mzk3NmI3Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-08-04T23:58:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-08-04T23:58:26Z"}, "message": "Describe unwinding for realigned frames explicitly.\n\nWe had been relying on some extremely fragile code within\ndwarf2out in order to guess what to do with aligned stack\nframes, which broke when we decided to perform the stores\nto the aligned stack frame via EBP instead of ESP.\n\nInstead, emit the appropriate unwinding instructions from\nthe backend.  This requires adding a new reg-note in order\nto describe a register save at an arbitrary address.\n\nFrom-SVN: r162889", "tree": {"sha": "a39862b72529e6b9992873c95bf737f8aca806dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a39862b72529e6b9992873c95bf737f8aca806dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9f4c45115dfba1d84958c1a971a333763976b7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f4c45115dfba1d84958c1a971a333763976b7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9f4c45115dfba1d84958c1a971a333763976b7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f4c45115dfba1d84958c1a971a333763976b7f/comments", "author": null, "committer": null, "parents": [{"sha": "ec7ded37e7550ed1e9f133b959fe92ff6fdf791d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec7ded37e7550ed1e9f133b959fe92ff6fdf791d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec7ded37e7550ed1e9f133b959fe92ff6fdf791d"}], "stats": {"total": 140, "additions": 130, "deletions": 10}, "files": [{"sha": "9866d8e8e749af005ec2af0063ba91ca23e517ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f4c45115dfba1d84958c1a971a333763976b7f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f4c45115dfba1d84958c1a971a333763976b7f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9f4c45115dfba1d84958c1a971a333763976b7f", "patch": "@@ -1,5 +1,16 @@\n 2010-08-04  Richard Henderson  <rth@redhat.com>\n \n+\t* reg-notes.def (CFA_EXPRESSION): New.\n+\t* dwarf2out.c (dwarf2out_frame_debug): Handle it.\n+\t(dwarf2out_frame_debug_cfa_expression): New.\n+\t(dwarf2out_frame_debug_def_cfa): Handle simple MEMs.\n+\n+\t* config/i386/i386.h (struct machine_frame_state): Add realigned flag.\n+\t* config/i386/i386.c (ix86_expand_prologue): Set it.\n+\t(ix86_expand_epilogue): Clear it.\n+\t(ix86_emit_save_reg_using_mov):\tFor registers saved in a realigned\n+\tcontext, add REG_CFA_EXPRESSION notes.\n+\n \t* config/i386/i386.h (struct machine_frame_state): Rename from\n \tmachine_cfa_state.  Add members tracking SP and FP regardless\n \tof the current CFA register.  "}, {"sha": "96897be8d94ee0a435b7a11959d1745f2de83f6f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f4c45115dfba1d84958c1a971a333763976b7f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f4c45115dfba1d84958c1a971a333763976b7f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c9f4c45115dfba1d84958c1a971a333763976b7f", "patch": "@@ -8616,8 +8616,9 @@ static void\n ix86_emit_save_reg_using_mov (enum machine_mode mode, unsigned int regno,\n \t\t\t      HOST_WIDE_INT cfa_offset)\n {\n+  struct machine_function *m = cfun->machine;\n   rtx reg = gen_rtx_REG (mode, regno);\n-  rtx mem, addr, insn;\n+  rtx mem, addr, base, insn;\n \n   addr = choose_baseaddr (cfa_offset);\n   mem = gen_frame_mem (mode, addr);\n@@ -8626,20 +8627,64 @@ ix86_emit_save_reg_using_mov (enum machine_mode mode, unsigned int regno,\n   set_mem_align (mem, GET_MODE_ALIGNMENT (mode));\n \n   insn = emit_move_insn (mem, reg);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  base = addr;\n+  if (GET_CODE (base) == PLUS)\n+    base = XEXP (base, 0);\n+  gcc_checking_assert (REG_P (base));\n+\n+  /* When saving registers into a re-aligned local stack frame, avoid\n+     any tricky guessing by dwarf2out.  */\n+  if (m->fs.realigned)\n+    {\n+      if (stack_realign_drap && regno == REGNO (crtl->drap_reg))\n+\t{\n+\t  /* A bit of a hack.  We force the DRAP register to be saved in\n+\t     the re-aligned stack frame, which provides us with a copy\n+\t     of the CFA that will last past the prologue.  Install it.  */\n+\t  gcc_checking_assert (cfun->machine->fs.fp_valid);\n+\t  addr = plus_constant (hard_frame_pointer_rtx,\n+\t\t\t\tcfun->machine->fs.fp_offset - cfa_offset);\n+\t  mem = gen_rtx_MEM (mode, addr);\n+\t  add_reg_note (insn, REG_CFA_DEF_CFA, mem);\n+\t}\n+      else if (stack_realign_fp)\n+\t{\n+\t  /* The stack pointer may or may not be varying within the\n+\t     function.  If it is, then we can't use it as a stable\n+\t     reference to the locations within the frame.  Instead,\n+\t     simply compute the location of the aligned frame from\n+\t     the frame pointer.  */\n+\t  addr = GEN_INT (-crtl->stack_alignment_needed / BITS_PER_UNIT);\n+\t  addr = gen_rtx_AND (Pmode, hard_frame_pointer_rtx, addr);\n+\t  addr = plus_constant (addr, -cfa_offset);\n+\t  mem = gen_rtx_MEM (mode, addr);\n+\t  add_reg_note (insn, REG_CFA_EXPRESSION,\n+\t\t\tgen_rtx_SET (VOIDmode, mem, reg));\n+\t}\n+      else\n+\t{\n+\t  /* The frame pointer is a stable reference within the\n+\t     aligned frame.  Use it.  */\n+\t  gcc_checking_assert (cfun->machine->fs.fp_valid);\n+\t  addr = plus_constant (hard_frame_pointer_rtx,\n+\t\t\t\tcfun->machine->fs.fp_offset - cfa_offset);\n+\t  mem = gen_rtx_MEM (mode, addr);\n+\t  add_reg_note (insn, REG_CFA_EXPRESSION,\n+\t\t\tgen_rtx_SET (VOIDmode, mem, reg));\n+\t}\n+    }\n \n   /* The memory may not be relative to the current CFA register,\n      which means that we may need to generate a new pattern for\n      use by the unwind info.  */\n-  if (GET_CODE (addr) == PLUS)\n-    addr = XEXP (addr, 0);\n-  if (addr != cfun->machine->fs.cfa_reg)\n+  else if (base != m->fs.cfa_reg)\n     {\n-      addr = plus_constant (cfun->machine->fs.cfa_reg,\n-\t\t\t    cfun->machine->fs.cfa_offset - cfa_offset);\n+      addr = plus_constant (m->fs.cfa_reg, m->fs.cfa_offset - cfa_offset);\n       mem = gen_rtx_MEM (mode, addr);\n       add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (VOIDmode, mem, reg));\n     }\n-  RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n /* Emit code to save registers using MOV insns.\n@@ -9511,6 +9556,7 @@ ix86_expand_prologue (void)\n       /* For the purposes of frame and register save area addressing,\n \t we've started over with a new frame.  */\n       m->fs.sp_offset = INCOMING_FRAME_SP_OFFSET;\n+      m->fs.realigned = true;\n     }\n \n   if (frame_pointer_needed && !m->fs.fp_valid)\n@@ -9546,8 +9592,9 @@ ix86_expand_prologue (void)\n       /* ??? There's no need to place the register save area into the\n \t aligned local stack frame.  We should do this later, after\n \t the register saves.  */\n-      m->fs.fp_valid = false;\n       m->fs.sp_offset = (m->fs.sp_offset + align_bytes - 1) & -align_bytes;\n+      m->fs.fp_valid = false;\n+      m->fs.realigned = true;\n     }\n \n   allocate = frame.to_allocate + frame.nsseregs * 16 + frame.padding0;\n@@ -10070,6 +10117,7 @@ ix86_expand_epilogue (int style)\n \t\t frame.  Thus the FP is suddenly valid and the SP isn't.  */\n \t      m->fs.fp_valid = true;\n \t      m->fs.sp_valid = false;\n+\t      m->fs.realigned = false;\n \t    }\n \n \t  /* Leave results in shorter dependency chains on CPUs that are\n@@ -10122,6 +10170,7 @@ ix86_expand_epilogue (int style)\n \t\t frame.  Thus the FP is suddenly valid and the SP isn't.  */\n \t      m->fs.fp_valid = true;\n \t      m->fs.sp_valid = false;\n+\t      m->fs.realigned = false;\n \t    }\n \n \t  /* Leave results in shorter dependency chains on CPUs that are\n@@ -10162,6 +10211,7 @@ ix86_expand_epilogue (int style)\n       m->fs.cfa_reg = stack_pointer_rtx;\n       m->fs.cfa_offset = param_ptr_offset;\n       m->fs.sp_offset = param_ptr_offset;\n+      m->fs.realigned = false;\n \n       add_reg_note (insn, REG_CFA_DEF_CFA,\n \t\t    gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n@@ -10196,6 +10246,7 @@ ix86_expand_epilogue (int style)\n   gcc_assert (m->fs.sp_offset == UNITS_PER_WORD);\n   gcc_assert (m->fs.sp_valid);\n   gcc_assert (!m->fs.fp_valid);\n+  gcc_assert (!m->fs.realigned);\n \n   /* Sibcall epilogues don't want a return instruction.  */\n   if (style == 0)"}, {"sha": "a2acc7131f7ee219de6ae1a19e0c64c7ea0e13e1", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f4c45115dfba1d84958c1a971a333763976b7f/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f4c45115dfba1d84958c1a971a333763976b7f/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c9f4c45115dfba1d84958c1a971a333763976b7f", "patch": "@@ -2323,6 +2323,11 @@ struct GTY(()) machine_frame_state\n   BOOL_BITFIELD sp_valid : 1;\n   BOOL_BITFIELD fp_valid : 1;\n   BOOL_BITFIELD drap_valid : 1;\n+\n+  /* Indicate whether the local stack frame has been re-aligned.  When\n+     set, the SP/FP offsets above are relative to the aligned frame\n+     and not the CFA.  */\n+  BOOL_BITFIELD realigned : 1;\n };\n \n struct GTY(()) machine_function {"}, {"sha": "2c79c6941377d44345350faf6a0754105a3cf18a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f4c45115dfba1d84958c1a971a333763976b7f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f4c45115dfba1d84958c1a971a333763976b7f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c9f4c45115dfba1d84958c1a971a333763976b7f", "patch": "@@ -479,6 +479,8 @@ static struct dw_loc_descr_struct *build_cfa_loc\n static struct dw_loc_descr_struct *build_cfa_aligned_loc\n   (HOST_WIDE_INT, HOST_WIDE_INT);\n static void def_cfa_1 (const char *, dw_cfa_location *);\n+static struct dw_loc_descr_struct *mem_loc_descriptor\n+  (rtx, enum machine_mode mode, enum var_init_status);\n \n /* How to start an assembler comment.  */\n #ifndef ASM_COMMENT_START\n@@ -1833,6 +1835,17 @@ dwarf2out_frame_debug_def_cfa (rtx pat, const char *label)\n       cfa.reg = REGNO (pat);\n       break;\n \n+    case MEM:\n+      cfa.indirect = 1;\n+      pat = XEXP (pat, 0);\n+      if (GET_CODE (pat) == PLUS)\n+\t{\n+\t  cfa.base_offset = INTVAL (XEXP (pat, 1));\n+\t  pat = XEXP (pat, 0);\n+\t}\n+      cfa.reg = REGNO (pat);\n+      break;\n+\n     default:\n       /* Recurse and define an expression.  */\n       gcc_unreachable ();\n@@ -1951,6 +1964,34 @@ dwarf2out_frame_debug_cfa_register (rtx set, const char *label)\n   reg_save (label, sregno, dregno, 0);\n }\n \n+/* A subroutine of dwarf2out_frame_debug, process a REG_CFA_EXPRESSION note. */\n+\n+static void\n+dwarf2out_frame_debug_cfa_expression (rtx set, const char *label)\n+{\n+  rtx src, dest, span;\n+  dw_cfi_ref cfi = new_cfi ();\n+\n+  dest = SET_DEST (set);\n+  src = SET_SRC (set);\n+\n+  gcc_assert (REG_P (src));\n+  gcc_assert (MEM_P (dest));\n+\n+  span = targetm.dwarf_register_span (src);\n+  gcc_assert (!span);\n+\n+  cfi->dw_cfi_opc = DW_CFA_expression;\n+  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = DWARF_FRAME_REGNUM (REGNO (src));\n+  cfi->dw_cfi_oprnd2.dw_cfi_loc\n+    = mem_loc_descriptor (XEXP (dest, 0), GET_MODE (dest),\n+\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n+\n+  /* ??? We'd like to use queue_reg_save, were the interface different,\n+     and, as above, we could manage flushing for epilogues.  */\n+  add_fde_cfi (label, cfi);\n+}\n+\n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_RESTORE note.  */\n \n static void\n@@ -2740,6 +2781,14 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n \thandled_one = true;\n \tbreak;\n \n+      case REG_CFA_EXPRESSION:\n+\tn = XEXP (note, 0);\n+\tif (n == NULL)\n+\t  n = single_set (insn);\n+\tdwarf2out_frame_debug_cfa_expression (n, label);\n+\thandled_one = true;\n+\tbreak;\n+\n       case REG_CFA_RESTORE:\n \tn = XEXP (note, 0);\n \tif (n == NULL)\n@@ -6181,8 +6230,6 @@ static dw_loc_descr_ref based_loc_descr (rtx, HOST_WIDE_INT,\n \t\t\t\t\t enum var_init_status);\n static int is_based_loc (const_rtx);\n static int resolve_one_addr (rtx *, void *);\n-static dw_loc_descr_ref mem_loc_descriptor (rtx, enum machine_mode mode,\n-\t\t\t\t\t    enum var_init_status);\n static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx,\n \t\t\t\t\t       enum var_init_status);\n static dw_loc_descr_ref loc_descriptor (rtx, enum machine_mode mode,"}, {"sha": "f82e7b741a03ec8b1e1c21868f144104282e11ae", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f4c45115dfba1d84958c1a971a333763976b7f/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f4c45115dfba1d84958c1a971a333763976b7f/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=c9f4c45115dfba1d84958c1a971a333763976b7f", "patch": "@@ -148,6 +148,12 @@ REG_NOTE (CFA_OFFSET)\n    or the pattern should be simple reg-reg move.  */\n REG_NOTE (CFA_REGISTER)\n \n+/* Attached to insns that are RTX_FRAME_RELATED_P, but are too complex\n+   for FRAME_RELATED_EXPR intuition.  This is a save to memory, i.e. will\n+   result in a DW_CFA_expression.  The pattern or the insn should be a\n+   store of a register to an arbitrary (non-validated) memory address.  */\n+REG_NOTE (CFA_EXPRESSION)\n+\n /* Attached to insns that are RTX_FRAME_RELATED_P, with the information\n    that this is a restore operation, i.e. will result in DW_CFA_restore\n    or the like.  Either the attached rtx, or the destination of the insn's"}]}