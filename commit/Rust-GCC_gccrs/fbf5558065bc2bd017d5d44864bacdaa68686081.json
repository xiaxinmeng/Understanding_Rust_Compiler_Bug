{"sha": "fbf5558065bc2bd017d5d44864bacdaa68686081", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJmNTU1ODA2NWJjMmJkMDE3ZDVkNDQ4NjRiYWNkYWE2ODY4NjA4MQ==", "commit": {"author": {"name": "Matt Thomas", "email": "matt@3am-software.com", "date": "2005-04-27T02:18:43Z"}, "committer": {"name": "Matt Thomas", "email": "matt@gcc.gnu.org", "date": "2005-04-27T02:18:43Z"}, "message": "vax.c (legitimate_constant_address_p): New.\n\n2005-04-27  Matt Thomas <matt@3am-software.com>\n\n        * config/vax/vax.c (legitimate_constant_address_p): New.  Formerly\n                CONSTANT_ADDRESS_P in config/vax/vax.h\n        (legitimate_constant_p): Added.  Formerly CONSTANT_P in vax.h.\n        (INDEX_REGISTER_P): New.\n        (BASE_REGISTER_P): New.\n        (indirectable_constant_address_p): New.  Adapted from\n                INDIRECTABLE_CONSTANT_ADDRESS_P in vax.h.\n                Use SYMBOL_REF_LOCAL_P.\n        (indirectable_address_p): New.  Adapted from\n                INDIRECTABLE_ADDRESS_P in vax.h.\n        (nonindexed_address_p): New.  Adapted from\n                GO_IF_NONINDEXED_ADDRESS in vax.h.\n        (index_temp_p): New.  Adapted from\n                INDEX_TERM_P in vax.h.\n        (reg_plus_index_p): New.  Adapted from\n                GO_IF_REG_PLUS_INDEX in vax.h.\n        (legitimate_address_p): New.  Adapted from\n                GO_IF_LEGITIMATE_ADDRESS in vax.h\n        (vax_mode_dependent_address_p): New.  Adapted from\n                GO_IF_MODE_DEPENDENT_ADDRESS in vax.h\n        * config/vax/vax.h (CONSTANT_ADDRESS_P): Use\n                legitimate_constant_address_p\n        (CONSTANT_P): Use legitimate_constant_p.\n        (INDIRECTABLE_CONSTANT_ADDRESS_P): Removed.\n        (INDIRECTABLE_ADDRESS_P): Removed.\n        (GO_IF_NONINDEXED_ADDRESS): Removed.\n        (INDEX_TEMP_P): Removed.\n        (GO_IF_REG_PLUS_INDEX): Removed.\n        (GO_IF_LEGITIMATE_ADDRESS): Use legitimate_address_p.\n                Two definitions, depending on whether REG_OK_STRICT is defined.\n        (GO_IF_MODE_DEPENDENT_ADDRESS): Use vax_mode_dependent_address_p.\n                Two definitions, depending on whether REG_OK_STRICT is defined.\n        * config/vax/vax-protos.h (legitimate_constant_address_p): Prototype\n                added.\n        (legitimate_constant_p): Prototype added.\n        (legitimate_address_p): Prototype added.\n        (vax_mode_dependent_address_p): Prototype added.\n\nFrom-SVN: r98814", "tree": {"sha": "f72e817f6196b693963cba7817da875ccc9d1ad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f72e817f6196b693963cba7817da875ccc9d1ad6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbf5558065bc2bd017d5d44864bacdaa68686081", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbf5558065bc2bd017d5d44864bacdaa68686081", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbf5558065bc2bd017d5d44864bacdaa68686081", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbf5558065bc2bd017d5d44864bacdaa68686081/comments", "author": null, "committer": null, "parents": [{"sha": "5dbc71f87890e49c10594e4b38309ffc0ca508d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dbc71f87890e49c10594e4b38309ffc0ca508d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dbc71f87890e49c10594e4b38309ffc0ca508d9"}], "stats": {"total": 443, "additions": 287, "deletions": 156}, "files": [{"sha": "daeb8691fdd2d95970fccc06dd906a04a626993f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf5558065bc2bd017d5d44864bacdaa68686081/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf5558065bc2bd017d5d44864bacdaa68686081/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbf5558065bc2bd017d5d44864bacdaa68686081", "patch": "@@ -1,3 +1,43 @@\n+2005-04-27  Matt Thomas <matt@3am-software.com>\n+\n+\t* config/vax/vax.c (legitimate_constant_address_p): New.  Formerly\n+\t\tCONSTANT_ADDRESS_P in config/vax/vax.h\n+\t(legitimate_constant_p): Added.  Formerly CONSTANT_P in vax.h. \n+\t(INDEX_REGISTER_P): New.\n+\t(BASE_REGISTER_P): New.\n+\t(indirectable_constant_address_p): New.  Adapted from\n+\t\tINDIRECTABLE_CONSTANT_ADDRESS_P in vax.h.\n+\t\tUse SYMBOL_REF_LOCAL_P.\n+\t(indirectable_address_p): New.  Adapted from\n+\t\tINDIRECTABLE_ADDRESS_P in vax.h.\n+\t(nonindexed_address_p): New.  Adapted from\n+\t\tGO_IF_NONINDEXED_ADDRESS in vax.h.\n+\t(index_temp_p): New.  Adapted from\n+\t\tINDEX_TERM_P in vax.h.\n+\t(reg_plus_index_p): New.  Adapted from\n+\t\tGO_IF_REG_PLUS_INDEX in vax.h.\n+\t(legitimate_address_p): New.  Adapted from\n+\t\tGO_IF_LEGITIMATE_ADDRESS in vax.h\n+\t(vax_mode_dependent_address_p): New.  Adapted from\n+\t\tGO_IF_MODE_DEPENDENT_ADDRESS in vax.h\n+\t* config/vax/vax.h (CONSTANT_ADDRESS_P): Use\n+\t\tlegitimate_constant_address_p\n+\t(CONSTANT_P): Use legitimate_constant_p.\n+\t(INDIRECTABLE_CONSTANT_ADDRESS_P): Removed.\n+\t(INDIRECTABLE_ADDRESS_P): Removed.\n+\t(GO_IF_NONINDEXED_ADDRESS): Removed.\n+\t(INDEX_TEMP_P): Removed.\n+\t(GO_IF_REG_PLUS_INDEX): Removed.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Use legitimate_address_p.\n+\t\tTwo definitions, depending on whether REG_OK_STRICT is defined.\n+\t(GO_IF_MODE_DEPENDENT_ADDRESS): Use vax_mode_dependent_address_p.\n+\t\tTwo definitions, depending on whether REG_OK_STRICT is defined.\n+\t* config/vax/vax-protos.h (legitimate_constant_address_p): Prototype\n+\t\tadded.\n+\t(legitimate_constant_p): Prototype added.\n+\t(legitimate_address_p): Prototype added.\n+\t(vax_mode_dependent_address_p): Prototype added.\n+\n 2005-04-27  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree.h (phi_arg_d): Expand a comment in phi_arg_d."}, {"sha": "7c1efcc7f7b951c7cf3160aaed36bcca7478740e", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf5558065bc2bd017d5d44864bacdaa68686081/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf5558065bc2bd017d5d44864bacdaa68686081/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=fbf5558065bc2bd017d5d44864bacdaa68686081", "patch": "@@ -20,6 +20,11 @@ Boston, MA 02111-1307, USA.  */\n \n extern void override_options (void);\n \n+extern int legitimate_constant_address_p (rtx);\n+extern int legitimate_constant_p (rtx);\n+extern int legitimate_address_p (enum machine_mode, rtx, int);\n+extern int vax_mode_dependent_address_p (rtx);\n+\n #ifdef RTX_CODE\n extern const char *rev_cond_name (rtx);\n extern void split_quadword_operands (rtx *, rtx *, int);\n@@ -34,4 +39,3 @@ extern const char * vax_output_conditional_branch (enum rtx_code);\n #ifdef REAL_VALUE_TYPE\n extern int check_float_value (enum machine_mode, REAL_VALUE_TYPE *, int);\n #endif /* REAL_VALUE_TYPE */\n-"}, {"sha": "c2396f6f1c9de2a7d0cf1daf1b138c790452f5a6", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf5558065bc2bd017d5d44864bacdaa68686081/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf5558065bc2bd017d5d44864bacdaa68686081/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=fbf5558065bc2bd017d5d44864bacdaa68686081", "patch": "@@ -1100,3 +1100,227 @@ vax_output_conditional_branch (enum rtx_code code)\n     }\n }\n \n+/* 1 if X is an rtx for a constant that is a valid address.  */\n+\n+int\n+legitimate_constant_address_p (rtx x)\n+{\n+  return (GET_CODE (x) == LABEL_REF || GET_CODE (x) == SYMBOL_REF\n+\t  || GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST\n+\t  || GET_CODE (x) == HIGH);\n+}\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+int\n+legitimate_constant_p (rtx x ATTRIBUTE_UNUSED)\n+{\n+  return 1;\n+}\n+\n+/* The other macros defined here are used only in legitimate_address_p ().  */\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or, if not strict, if it is a pseudo reg.  */\n+#define\tINDEX_REGISTER_P(X, STRICT)\n+(GET_CODE (X) == REG && (!(STRICT) || REGNO_OK_FOR_INDEX_P (REGNO (X))))\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or, if not strict, if it is a pseudo reg.  */\n+#define\tBASE_REGISTER_P(X, STRICT)\n+(GET_CODE (X) == REG && (!(STRICT) || REGNO_OK_FOR_BASE_P (REGNO (X))))\n+\n+#ifdef NO_EXTERNAL_INDIRECT_ADDRESS\n+\n+/* Re-definition of CONSTANT_ADDRESS_P, which is true only when there\n+   are no SYMBOL_REFs for external symbols present.  */\n+\n+static int\n+indirectable_constant_address_p (rtx x)\n+{\n+  if (!CONSTANT_ADDRESS_P (x))\n+    return 0;\n+  if (GET_CODE (x) == CONST && GET_CODE (XEXP ((x), 0)) == PLUS)\n+    x = XEXP (XEXP (x, 0), 0);\n+  if (GET_CODE (x) == SYMBOL_REF && !SYMBOL_REF_LOCAL_P (x))\n+    return 0;\n+\n+  return 1;\n+}\n+\n+#else /* not NO_EXTERNAL_INDIRECT_ADDRESS */\n+\n+static int\n+indirectable_constant_address_p (rtx x)\n+{\n+  return CONSTANT_ADDRESS_P (x);\n+}\n+\n+#endif /* not NO_EXTERNAL_INDIRECT_ADDRESS */\n+\n+/* Nonzero if X is an address which can be indirected.  External symbols\n+   could be in a sharable image library, so we disallow those.  */\n+\n+static int\n+indirectable_address_p(rtx x, int strict)\n+{\n+  if (indirectable_constant_address_p (x))\n+    return 1;\n+  if (BASE_REGISTER_P (x, strict))\n+    return 1;\n+  if (GET_CODE (x) == PLUS\n+      && BASE_REGISTER_P (XEXP (x, 0), strict)\n+      && indirectable_constant_address_p (XEXP (x, 1)))\n+    return 1;\n+  return 0;\n+}\n+\n+/* Return 1 if x is a valid address not using indexing.\n+   (This much is the easy part.)  */\n+static int\n+nonindexed_address_p (rtx x, int strict)\n+{\n+  rtx xfoo0;\n+  if (GET_CODE (x) == REG)\n+    {\n+      extern rtx *reg_equiv_mem;\n+      if (! reload_in_progress\n+\t  || reg_equiv_mem[REGNO (x)] == 0\n+\t  || indirectable_address_p (reg_equiv_mem[REGNO (x)], strict))\n+\treturn 1;\n+    }\n+  if (indirectable_constant_address_p (x))\n+    return 1;\n+  if (indirectable_address_p (x, strict))\n+    return 1;\n+  xfoo0 = XEXP (x, 0);\n+  if (GET_CODE (x) == MEM && indirectable_address_p (xfoo0, strict))\n+    return 1;\n+  if ((GET_CODE (x) == PRE_DEC || GET_CODE (x) == POST_INC)\n+      && BASE_REGISTER_P (xfoo0, strict))\n+    return 1;\n+  return 0;\n+}\n+\n+/* 1 if PROD is either a reg times size of mode MODE and MODE is less\n+   than or equal 8 bytes, or just a reg if MODE is one byte.  */\n+\n+static int\n+index_term_p (rtx prod, enum machine_mode mode, int strict)\n+{\n+  rtx xfoo0, xfoo1;\n+\n+  if (GET_MODE_SIZE (mode) == 1)\n+    return BASE_REGISTER_P (prod, strict);\n+\n+  if (GET_CODE (prod) != MULT || GET_MODE_SIZE (mode) > 8)\n+    return 0;\n+\n+  xfoo0 = XEXP (prod, 0);\n+  xfoo1 = XEXP (prod, 1);\n+\n+  if (GET_CODE (xfoo0) == CONST_INT\n+      && INTVAL (xfoo0) == (int)GET_MODE_SIZE (mode)\n+      && INDEX_REGISTER_P (xfoo1, strict))\n+    return 1;\n+\n+  if (GET_CODE (xfoo1) == CONST_INT\n+      && INTVAL (xfoo1) == (int)GET_MODE_SIZE (mode)\n+      && INDEX_REGISTER_P (xfoo0, strict))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return 1 if X is the sum of a register\n+   and a valid index term for mode MODE.  */\n+static int\n+reg_plus_index_p (rtx x, enum machine_mode mode, int strict)\n+{\n+  rtx xfoo0, xfoo1;\n+\n+  if (GET_CODE (x) != PLUS)\n+    return 0;\n+\n+  xfoo0 = XEXP (x, 0);\n+  xfoo1 = XEXP (x, 1);\n+\n+  if (BASE_REGISTER_P (xfoo0, strict) && index_term_p (xfoo1, mode, strict))\n+    return 1;\n+\n+  if (BASE_REGISTER_P (xfoo1, strict) && index_term_p (xfoo0, mode, strict))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* legitimate_address_p returns 1 if it recognizes an RTL expression \"x\"\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.  */\n+int\n+legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n+{\n+  rtx xfoo0, xfoo1;\n+\n+  if (nonindexed_address_p (x, strict))\n+    return 1;\n+\n+  if (GET_CODE (x) != PLUS)\n+    return 0;\n+\n+  /* Handle <address>[index] represented with index-sum outermost */\n+\n+  xfoo0 = XEXP (x, 0);\n+  xfoo1 = XEXP (x, 1);\n+\n+  if (index_term_p (xfoo0, mode, strict)\n+      && nonindexed_address_p (xfoo1, strict))\n+    return 1;\n+\n+  if (index_term_p (xfoo1, mode, strict)\n+      && nonindexed_address_p (xfoo0, strict))\n+    return 1;\n+\n+  /* Handle offset(reg)[index] with offset added outermost */\t\\\n+\n+  if (indirectable_constant_address_p (xfoo0)\n+      && (BASE_REGISTER_P (xfoo1, strict)\n+          || reg_plus_index_p (xfoo1, mode, strict)))\n+    return 1;\n+\n+  if (indirectable_constant_address_p (xfoo1)\n+      && (BASE_REGISTER_P (xfoo0, strict)\n+          || reg_plus_index_p (xfoo0, mode, strict)))\n+    return 1;\n+\n+  return 0;\n+} \n+\n+/* Return 1 if x (a legitimate address expression) has an effect that\n+   depends on the machine mode it is used for.  On the VAX, the predecrement\n+   and postincrement address depend thus (the amount of decrement or\n+   increment being the length of the operand) and all indexed address depend\n+   thus (because the index scale factor is the length of the operand).  */\n+\n+int\n+vax_mode_dependent_address_p (rtx x)\n+{\n+  rtx xfoo0, xfoo1;\n+\n+  if (GET_CODE (x) == POST_INC || GET_CODE (x) == PRE_DEC)\n+    return 1;\n+  if (GET_CODE (x) != PLUS)\n+    return 0;\n+\n+  xfoo0 = XEXP (x, 0);\n+  xfoo1 = XEXP (x, 1);\n+\n+  if (CONSTANT_ADDRESS_P (xfoo0) && GET_CODE (xfoo1) == REG)\n+    return 0;\n+  if (CONSTANT_ADDRESS_P (xfoo1) && GET_CODE (xfoo0) == REG)\n+    return 0;\n+\n+  return 1;\n+}"}, {"sha": "de8f0d61691ee5b05318be5aa0d2aac46cce78d8", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 18, "deletions": 155, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf5558065bc2bd017d5d44864bacdaa68686081/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf5558065bc2bd017d5d44864bacdaa68686081/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=fbf5558065bc2bd017d5d44864bacdaa68686081", "patch": "@@ -541,15 +541,12 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n /* 1 if X is an rtx for a constant that is a valid address.  */\n \n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n+#define CONSTANT_ADDRESS_P(X) legitimate_constant_address_p (X)\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-#define LEGITIMATE_CONSTANT_P(X) 1\n+#define LEGITIMATE_CONSTANT_P(X) legitimate_constant_p (X)\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -569,169 +566,35 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) 1\n+\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) 1\n \n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.  */\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n+{ if (legitimate_address_p ((MODE), (X), 0)) goto ADDR; }\n+\n #else\n \n /* Nonzero if X is a hard reg that can be used as an index.  */\n #define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n-#endif\n-\f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n-   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n-\n-#ifdef NO_EXTERNAL_INDIRECT_ADDRESS\n-\n-/* Zero if this contains a (CONST (PLUS (SYMBOL_REF) (...))) and the\n-   symbol in the SYMBOL_REF is an external symbol.  */\n-\n-#define INDIRECTABLE_CONSTANT_P(X) \\\n- (! (GET_CODE ((X)) == CONST\t\t\t\t\t\\\n-     && GET_CODE (XEXP ((X), 0)) == PLUS\t\t\t\\\n-     && GET_CODE (XEXP (XEXP ((X), 0), 0)) == SYMBOL_REF\t\\\n-     && SYMBOL_REF_FLAG (XEXP (XEXP ((X), 0), 0))))\n-\n-/* Re-definition of CONSTANT_ADDRESS_P, which is true only when there\n-   are no SYMBOL_REFs for external symbols present.  */\n-\n-#define INDIRECTABLE_CONSTANT_ADDRESS_P(X)   \t\t\t\t\\\n-  (GET_CODE (X) == LABEL_REF \t\t\t\t\t\t\\\n-   || (GET_CODE (X) == SYMBOL_REF && !SYMBOL_REF_FLAG (X))\t\t\\\n-   || (GET_CODE (X) == CONST && INDIRECTABLE_CONSTANT_P(X))\t\t\\\n-   || GET_CODE (X) == CONST_INT)\n-\n-\n-/* Nonzero if X is an address which can be indirected.  External symbols\n-   could be in a sharable image library, so we disallow those.  */\n-\n-#define INDIRECTABLE_ADDRESS_P(X)  \\\n-  (INDIRECTABLE_CONSTANT_ADDRESS_P (X) \t\t\t\t\t\\\n-   || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n-   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-       && INDIRECTABLE_CONSTANT_ADDRESS_P (XEXP (X, 1))))\n-\n-#else /* not NO_EXTERNAL_INDIRECT_ADDRESS */\n-\n-#define INDIRECTABLE_CONSTANT_ADDRESS_P(X) CONSTANT_ADDRESS_P(X)\n-\n-/* Nonzero if X is an address which can be indirected.  */\n-#define INDIRECTABLE_ADDRESS_P(X)  \\\n-  (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n-   || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n-   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-       && CONSTANT_ADDRESS_P (XEXP (X, 1))))\n-\n-#endif /* not NO_EXTERNAL_INDIRECT_ADDRESS */\n-\n-/* Go to ADDR if X is a valid address not using indexing.\n-   (This much is the easy part.)  */\n-#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n-{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n-  if (GET_CODE (xfoob) == REG)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      extern rtx *reg_equiv_mem;\t\t\t\t\t\\\n-      if (! reload_in_progress\t\t\t\t\t\t\\\n-\t  || reg_equiv_mem[REGNO (xfoob)] == 0\t\t\t\t\\\n-\t  || INDIRECTABLE_ADDRESS_P (reg_equiv_mem[REGNO (xfoob)]))\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (CONSTANT_ADDRESS_P (xfoob)) goto ADDR;\t\t\t\t\\\n-  if (INDIRECTABLE_ADDRESS_P (xfoob)) goto ADDR;\t\t\t\\\n-  xfoob = XEXP (X, 0);\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == MEM && INDIRECTABLE_ADDRESS_P (xfoob))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_INC)\t\t\\\n-      && GET_CODE (xfoob) == REG && REG_OK_FOR_BASE_P (xfoob))\t\t\\\n-    goto ADDR; }\n-\n-/* 1 if PROD is either a reg times size of mode MODE and MODE is less\n-   than or equal 8 bytes, or just a reg if MODE is one byte.\n-   This macro's expansion uses the temporary variables xfoo0 and xfoo1\n-   that must be declared in the surrounding context.  */\n-#define INDEX_TERM_P(PROD, MODE)   \\\n-(GET_MODE_SIZE (MODE) == 1\t\t\t\t\t\t\\\n- ? (GET_CODE (PROD) == REG && REG_OK_FOR_BASE_P (PROD))\t\t\t\\\n- : (GET_CODE (PROD) == MULT && GET_MODE_SIZE (MODE) <= 8\t\t\\\n-    &&\t\t\t\t\t\t\t\t\t\\\n-    (xfoo0 = XEXP (PROD, 0), xfoo1 = XEXP (PROD, 1),\t\t\t\\\n-     ((((GET_CODE (xfoo0) == CONST_INT\t\t\t\t\t\\\n-         && GET_CODE (xfoo1) == REG)\t\t\t\t\t\\\n-         && INTVAL (xfoo0) == (int)GET_MODE_SIZE (MODE))\t\t\\\n-         && REG_OK_FOR_INDEX_P (xfoo1))\t\t\t\t\t\\\n-        ||\t\t\t\t\t\t\t\t\\\n-      (((GET_CODE (xfoo1) == CONST_INT\t\t\t\t\t\\\n-         && GET_CODE (xfoo0) == REG)\t\t\t\t\t\\\n-         && INTVAL (xfoo1) == (int)GET_MODE_SIZE (MODE))\t\t\\\n-         && REG_OK_FOR_INDEX_P (xfoo0))))))\n-\n-/* Go to ADDR if X is the sum of a register\n-   and a valid index term for mode MODE.  */\n-#define GO_IF_REG_PLUS_INDEX(X, MODE, ADDR)\t\\\n-{ register rtx xfooa;\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    { if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-\t  && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-\t  && (xfooa = XEXP (X, 1),\t\t\t\t\t\\\n-\t      INDEX_TERM_P (xfooa, MODE)))\t\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-      if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\t\\\n-\t  && REG_OK_FOR_BASE_P (XEXP (X, 1))\t\t\t\t\\\n-\t  && (xfooa = XEXP (X, 0),\t\t\t\t\t\\\n-\t      INDEX_TERM_P (xfooa, MODE)))\t\t\t\t\\\n-\tgoto ADDR; } }\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n-{ register rtx xfoo, xfoo0, xfoo1;\t\t\t\t\t\\\n-  GO_IF_NONINDEXED_ADDRESS (X, ADDR);\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    { /* Handle <address>[index] represented with index-sum outermost */\\\n-      xfoo = XEXP (X, 0);\t\t\t\t\t\t\\\n-      if (INDEX_TERM_P (xfoo, MODE))\t\t\t\t\t\\\n-\t{ GO_IF_NONINDEXED_ADDRESS (XEXP (X, 1), ADDR); }\t\t\\\n-      xfoo = XEXP (X, 1);\t\t\t\t\t\t\\\n-      if (INDEX_TERM_P (xfoo, MODE))\t\t\t\t\t\\\n-\t{ GO_IF_NONINDEXED_ADDRESS (XEXP (X, 0), ADDR); }\t\t\\\n-      /* Handle offset(reg)[index] with offset added outermost */\t\\\n-      if (INDIRECTABLE_CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\\\n-\t{ if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n-\t      && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t  GO_IF_REG_PLUS_INDEX (XEXP (X, 1), MODE, ADDR); }\t\t\\\n-      if (INDIRECTABLE_CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\\\n-\t{ if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t      && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t  GO_IF_REG_PLUS_INDEX (XEXP (X, 0), MODE, ADDR); } } }\n-\f\n+   that is a valid memory address for an instruction.  */\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n+{ if (legitimate_address_p ((MODE), (X), 1)) goto ADDR; }\n+\n+#endif\n+\n /* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the VAX, the predecrement and postincrement address depend thus\n-   (the amount of decrement or increment being the length of the operand)\n-   and all indexed address depend thus (because the index scale factor\n-   is the length of the operand).  */\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n- { if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC)\t\\\n-     goto LABEL; \t\t\t\t\t\t\t\\\n-   if (GET_CODE (ADDR) == PLUS)\t\t\t\t\t\t\\\n-     { if (CONSTANT_ADDRESS_P (XEXP (ADDR, 0))\t\t\t\t\\\n-\t   && GET_CODE (XEXP (ADDR, 1)) == REG);\t\t\t\\\n-       else if (CONSTANT_ADDRESS_P (XEXP (ADDR, 1))\t\t\t\\\n-\t\t&& GET_CODE (XEXP (ADDR, 0)) == REG);\t\t\t\\\n-       else goto LABEL; }}\n+   has an effect that depends on the machine mode it is used for.  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL) \\\n+ { if (vax_mode_dependent_address_p (ADDR)) goto LABEL; }\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */"}]}