{"sha": "068baae1864e2a8036beec3082d384a204e24201", "node_id": "C_kwDOANBUbNoAKDA2OGJhYWUxODY0ZTJhODAzNmJlZWMzMDgyZDM4NGEyMDRlMjQyMDE", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-10-24T20:59:39Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-10-26T20:18:48Z"}, "message": "bpf: add preserve_field_info builtin\n\nAdd BPF __builtin_preserve_field_info. This builtin is used to extract\ninformation to facilitate struct and union relocations performed by the\nBPF loader, especially for bitfields.\n\nThe builtin has the following signature:\n\n  unsigned int __builtin_preserve_field_info (EXPR, unsigned int KIND);\n\nWhere EXPR is an expression accessing a field of a struct or union.\nDepending on KIND, different information is returned to the program. The\nsupported values for KIND are as follows:\n\n  enum {\n    FIELD_BYTE_OFFSET = 0,\n    FIELD_BYTE_SIZE,\n    FIELD_EXISTENCE,\n    FIELD_SIGNEDNESS,\n    FIELD_LSHIFT_U64,\n    FIELD_RSHIFT_U64\n  };\n\nIf -mco-re is in effect (explicitly or implicitly specified), a CO-RE\nrelocation is added for the access in EXPR recording the relevant\ninformation according to KIND.\n\ngcc/\n\n\t* config/bpf/bpf.cc: Support __builtin_preserve_field_info.\n\t(enum bpf_builtins): Add new builtin.\n\t(bpf_init_builtins): Likewise.\n\t(bpf_core_field_info): New function.\n\t(bpf_expand_builtin): Accomodate new builtin. Refactor adding new\n\trelocation to...\n\t(maybe_make_core_relo): ... here. New function.\n\t(bpf_resolve_overloaded_builtin): Accomodate new builtin.\n\t(bpf_core_newdecl): Likewise.\n\t(bpf_core_walk): Likewise.\n\t(bpf_core_is_maybe_aggregate_access): Improve logic.\n\t(struct core_walk_data): New.\n\t* config/bpf/coreout.cc (bpf_core_reloc_add): Allow adding different\n\trelocation kinds.\n\t* config/bpf/coreout.h: Analogous change.\n\t* doc/extend.texi: Document BPF __builtin_preserve_field_info.\n\ngcc/testsuite/\n\n\t* gcc.target/bpf/core-builtin-fieldinfo-errors-1.c: New test.\n\t* gcc.target/bpf/core-builtin-fieldinfo-errors-2.c: New test.\n\t* gcc.target/bpf/core-builtin-fieldinfo-existence-1.c: New test.\n\t* gcc.target/bpf/core-builtin-fieldinfo-lshift-1-be.c: New test.\n\t* gcc.target/bpf/core-builtin-fieldinfo-lshift-1-le.c: New test.\n\t* gcc.target/bpf/core-builtin-fieldinfo-lshift-2.c: New test.\n\t* gcc.target/bpf/core-builtin-fieldinfo-offset-1.c: New test.\n\t* gcc.target/bpf/core-builtin-fieldinfo-rshift-1.c: New test.\n\t* gcc.target/bpf/core-builtin-fieldinfo-rshift-2.c: New test.\n\t* gcc.target/bpf/core-builtin-fieldinfo-sign-1.c: New test.\n\t* gcc.target/bpf/core-builtin-fieldinfo-sign-2.c: New test.\n\t* gcc.target/bpf/core-builtin-fieldinfo-size-1.c: New test.", "tree": {"sha": "680abc541c63bb61cc0d1c31622da8cc6f19c7db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/680abc541c63bb61cc0d1c31622da8cc6f19c7db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/068baae1864e2a8036beec3082d384a204e24201", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068baae1864e2a8036beec3082d384a204e24201", "html_url": "https://github.com/Rust-GCC/gccrs/commit/068baae1864e2a8036beec3082d384a204e24201", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068baae1864e2a8036beec3082d384a204e24201/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2249cd9adf5ae638577139177a50f7e62d8abd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2249cd9adf5ae638577139177a50f7e62d8abd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2249cd9adf5ae638577139177a50f7e62d8abd9"}], "stats": {"total": 925, "additions": 850, "deletions": 75}, "files": [{"sha": "ea8ca64d1d6ee2291dd78b93abf338270903de71", "filename": "gcc/config/bpf/bpf.cc", "status": "modified", "additions": 330, "deletions": 72, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.cc?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -184,13 +184,13 @@ enum bpf_builtins\n \n   /* Compile Once - Run Everywhere (CO-RE) support.  */\n   BPF_BUILTIN_PRESERVE_ACCESS_INDEX,\n+  BPF_BUILTIN_PRESERVE_FIELD_INFO,\n \n   BPF_BUILTIN_MAX,\n };\n \n static GTY (()) tree bpf_builtins[(int) BPF_BUILTIN_MAX];\n \n-\n void bpf_register_coreattr_pass (void);\n \n /* Initialize the per-function machine status.  */\n@@ -966,6 +966,9 @@ bpf_init_builtins (void)\n   def_builtin (\"__builtin_preserve_access_index\",\n \t       BPF_BUILTIN_PRESERVE_ACCESS_INDEX,\n \t       build_function_type_list (ptr_type_node, ptr_type_node, 0));\n+  def_builtin (\"__builtin_preserve_field_info\",\n+\t       BPF_BUILTIN_PRESERVE_FIELD_INFO,\n+\t       build_function_type_list (unsigned_type_node, ptr_type_node, unsigned_type_node, 0));\n }\n \n #undef TARGET_INIT_BUILTINS\n@@ -975,6 +978,199 @@ static tree bpf_core_compute (tree, vec<unsigned int> *);\n static int bpf_core_get_index (const tree);\n static bool is_attr_preserve_access (tree);\n \n+/* BPF Compile Once - Run Everywhere (CO-RE) support. Construct a CO-RE\n+   relocation record for EXPR of kind KIND to be emitted in the .BTF.ext\n+   section. Does nothing if we are not targetting BPF CO-RE, or if the\n+   constructed relocation would be a no-op.  */\n+\n+static void\n+maybe_make_core_relo (tree expr, enum btf_core_reloc_kind kind)\n+{\n+  /* If we are not targetting BPF CO-RE, do not make a relocation. We\n+     might not be generating any debug info at all.  */\n+  if (!TARGET_BPF_CORE)\n+    return;\n+\n+  auto_vec<unsigned int, 16> accessors;\n+  tree container = bpf_core_compute (expr, &accessors);\n+\n+  /* Any valid use of the builtin must have at least one access. Otherwise,\n+     there is nothing to record and nothing to do. This is primarily a\n+     guard against optimizations leading to unexpected expressions in the\n+     argument of the builtin. For example, if the builtin is used to read\n+     a field of a structure which can be statically determined to hold a\n+     constant value, the argument to the builtin will be optimized to that\n+     constant. This is OK, and means the builtin call is superfluous.\n+     e.g.\n+     struct S foo;\n+     foo.a = 5;\n+     int x = __preserve_access_index (foo.a);\n+     ... do stuff with x\n+     'foo.a' in the builtin argument will be optimized to '5' with -01+.\n+     This sequence does not warrant recording a CO-RE relocation.  */\n+\n+  if (accessors.length () < 1)\n+    return;\n+  accessors.reverse ();\n+\n+  rtx_code_label *label = gen_label_rtx ();\n+  LABEL_PRESERVE_P (label) = 1;\n+  emit_label (label);\n+\n+  /* Determine what output section this relocation will apply to.\n+     If this function is associated with a section, use that. Otherwise,\n+     fall back on '.text'.  */\n+  const char * section_name;\n+  if (current_function_decl && DECL_SECTION_NAME (current_function_decl))\n+    section_name = DECL_SECTION_NAME (current_function_decl);\n+  else\n+    section_name = \".text\";\n+\n+  /* Add the CO-RE relocation information to the BTF container.  */\n+  bpf_core_reloc_add (TREE_TYPE (container), section_name, &accessors, label,\n+\t\t      kind);\n+}\n+\n+/* Expand a call to __builtin_preserve_field_info by evaluating the requested\n+   information about SRC according to KIND, and return a tree holding\n+   the result.  */\n+\n+static tree\n+bpf_core_field_info (tree src, enum btf_core_reloc_kind kind)\n+{\n+  unsigned int result;\n+  poly_int64 bitsize, bitpos;\n+  tree var_off = NULL_TREE;\n+  machine_mode mode;\n+  int unsignedp, reversep, volatilep;\n+  location_t loc = EXPR_LOCATION (src);\n+\n+  get_inner_reference (src, &bitsize, &bitpos, &var_off, &mode, &unsignedp,\n+\t\t       &reversep, &volatilep);\n+\n+  /* Note: Use DECL_BIT_FIELD_TYPE rather than DECL_BIT_FIELD here, because it\n+     remembers whether the field in question was originally declared as a\n+     bitfield, regardless of how it has been optimized.  */\n+  bool bitfieldp = (TREE_CODE (src) == COMPONENT_REF\n+\t\t    && DECL_BIT_FIELD_TYPE (TREE_OPERAND (src, 1)));\n+\n+  unsigned int align = TYPE_ALIGN (TREE_TYPE (src));\n+  if (TREE_CODE (src) == COMPONENT_REF)\n+    {\n+      tree field = TREE_OPERAND (src, 1);\n+      if (DECL_BIT_FIELD_TYPE (field))\n+\talign = TYPE_ALIGN (DECL_BIT_FIELD_TYPE (field));\n+      else\n+\talign = TYPE_ALIGN (TREE_TYPE (field));\n+    }\n+\n+  unsigned int start_bitpos = bitpos & ~(align - 1);\n+  unsigned int end_bitpos = start_bitpos + align;\n+\n+  switch (kind)\n+    {\n+    case BPF_RELO_FIELD_BYTE_OFFSET:\n+      {\n+\tif (var_off != NULL_TREE)\n+\t  {\n+\t    error_at (loc, \"unsupported variable field offset\");\n+\t    return error_mark_node;\n+\t  }\n+\n+\tif (bitfieldp)\n+\t  result = start_bitpos / 8;\n+\telse\n+\t  result = bitpos / 8;\n+      }\n+      break;\n+\n+    case BPF_RELO_FIELD_BYTE_SIZE:\n+      {\n+\tif (mode == BLKmode && bitsize == -1)\n+\t  {\n+\t    error_at (loc, \"unsupported variable size field access\");\n+\t    return error_mark_node;\n+\t  }\n+\n+\tif (bitfieldp)\n+\t  {\n+\t    /* To match LLVM behavior, byte size of bitfields is recorded as\n+\t       the full size of the base type. A 3-bit bitfield of type int is\n+\t       therefore recorded as having a byte size of 4 bytes. */\n+\t    result = end_bitpos - start_bitpos;\n+\t    if (result & (result - 1))\n+\t      {\n+\t\terror_at (loc, \"unsupported field expression\");\n+\t\treturn error_mark_node;\n+\t      }\n+\t    result = result / 8;\n+\t  }\n+\telse\n+\t  result = bitsize / 8;\n+      }\n+      break;\n+\n+    case BPF_RELO_FIELD_EXISTS:\n+      /* The field always exists at compile time.  */\n+      result = 1;\n+      break;\n+\n+    case BPF_RELO_FIELD_SIGNED:\n+      result = !unsignedp;\n+      break;\n+\n+    case BPF_RELO_FIELD_LSHIFT_U64:\n+    case BPF_RELO_FIELD_RSHIFT_U64:\n+      {\n+\tif (mode == BLKmode && bitsize == -1)\n+\t  {\n+\t    error_at (loc, \"unsupported variable size field access\");\n+\t    return error_mark_node;\n+\t  }\n+\tif (var_off != NULL_TREE)\n+\t  {\n+\t    error_at (loc, \"unsupported variable field offset\");\n+\t    return error_mark_node;\n+\t  }\n+\n+\tif (!bitfieldp)\n+\t  {\n+\t    if (bitsize > 64)\n+\t      {\n+\t\terror_at (loc, \"field size too large\");\n+\t\treturn error_mark_node;\n+\t      }\n+\t    result = 64 - bitsize;\n+\t    break;\n+\t  }\n+\n+\tif (end_bitpos - start_bitpos > 64)\n+\t  {\n+\t    error_at (loc, \"field size too large\");\n+\t    return error_mark_node;\n+\t  }\n+\n+\tif (kind == BPF_RELO_FIELD_LSHIFT_U64)\n+\t  {\n+\t    if (TARGET_BIG_ENDIAN)\n+\t      result = bitpos + 64 - start_bitpos - align;\n+\t    else\n+\t      result = start_bitpos + 64 - bitpos - bitsize;\n+\t  }\n+\telse /* RSHIFT_U64 */\n+\t  result = 64 - bitsize;\n+      }\n+      break;\n+\n+    default:\n+      error (\"invalid second argument to built-in function\");\n+      return error_mark_node;\n+      break;\n+    }\n+\n+  return build_int_cst (unsigned_type_node, result);\n+}\n+\n /* Expand a call to a BPF-specific built-in function that was set up\n    with bpf_init_builtins.  */\n \n@@ -1025,17 +1221,15 @@ bpf_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n       /* The result of the load is in R0.  */\n       return gen_rtx_REG (ops[0].mode, BPF_R0);\n     }\n+\n   else if (code == -1)\n     {\n-      /* A resolved overloaded builtin, e.g. __bpf_preserve_access_index_si */\n+      /* A resolved overloaded __builtin_preserve_access_index.  */\n       tree arg = CALL_EXPR_ARG (exp, 0);\n \n       if (arg == NULL_TREE)\n \treturn NULL_RTX;\n \n-      auto_vec<unsigned int, 16> accessors;\n-      tree container;\n-\n       if (TREE_CODE (arg) == SSA_NAME)\n \t{\n \t  gimple *def_stmt = SSA_NAME_DEF_STMT (arg);\n@@ -1049,51 +1243,42 @@ bpf_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n       /* Avoid double-recording information if the argument is an access to\n \t a struct/union marked __attribute__((preserve_access_index)). This\n \t Will be handled by the attribute handling pass.  */\n-      if (is_attr_preserve_access (arg))\n-\treturn expand_normal (arg);\n-\n-      container = bpf_core_compute (arg, &accessors);\n-\n-      /* Any valid use of the builtin must have at least one access. Otherwise,\n-\t there is nothing to record and nothing to do. This is primarily a\n-\t guard against optimizations leading to unexpected expressions in the\n-\t argument of the builtin. For example, if the builtin is used to read\n-\t a field of a structure which can be statically determined to hold a\n-\t constant value, the argument to the builtin will be optimized to that\n-\t constant. This is OK, and means the builtin call is superfluous.\n-\t e.g.\n-\t   struct S foo;\n-\t   foo.a = 5;\n-\t   int x = __preserve_access_index (foo.a);\n-\t   ... do stuff with x\n-\t 'foo.a' in the builtin argument will be optimized to '5' with -01+.\n-\t This sequence does not warrant recording a CO-RE relocation.  */\n-\n-      if (accessors.length () < 1)\n-\treturn expand_normal (arg);\n-\n-      accessors.reverse ();\n-\n-      container = TREE_TYPE (container);\n-\n-      rtx_code_label *label = gen_label_rtx ();\n-      LABEL_PRESERVE_P (label) = 1;\n-      emit_label (label);\n-\n-      /* Determine what output section this relocation will apply to.\n-\t If this function is associated with a section, use that. Otherwise,\n-\t fall back on '.text'.  */\n-      const char * section_name;\n-      if (current_function_decl && DECL_SECTION_NAME (current_function_decl))\n-\tsection_name = DECL_SECTION_NAME (current_function_decl);\n+      if (!is_attr_preserve_access (arg))\n+\tmaybe_make_core_relo (arg, BPF_RELO_FIELD_BYTE_OFFSET);\n+\n+      return expand_normal (arg);\n+    }\n+\n+  else if (code == -2)\n+    {\n+      /* A resolved overloaded __builtin_preserve_field_info.  */\n+      tree src = CALL_EXPR_ARG (exp, 0);\n+      tree kind_tree = CALL_EXPR_ARG (exp, 1);\n+      unsigned HOST_WIDE_INT kind_val;\n+      if (tree_fits_uhwi_p (kind_tree))\n+\tkind_val = tree_to_uhwi (kind_tree);\n       else\n-\tsection_name = \".text\";\n+\terror (\"invalid argument to built-in function\");\n \n-      /* Add the CO-RE relocation information to the BTF container.  */\n-      bpf_core_reloc_add (container, section_name, &accessors, label);\n+      enum btf_core_reloc_kind kind = (enum btf_core_reloc_kind) kind_val;\n \n-      return expand_normal (arg);\n+      if (TREE_CODE (src) == SSA_NAME)\n+\t{\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (src);\n+\t  if (is_gimple_assign (def_stmt))\n+\t    src = gimple_assign_rhs1 (def_stmt);\n+\t}\n+      if (TREE_CODE (src) == ADDR_EXPR)\n+\tsrc = TREE_OPERAND (src, 0);\n+\n+      tree result = bpf_core_field_info (src, kind);\n+\n+      if (result != error_mark_node)\n+\tmaybe_make_core_relo (src, kind);\n+\n+      return expand_normal (result);\n     }\n+\n   gcc_unreachable ();\n }\n \n@@ -1259,41 +1444,64 @@ bpf_core_get_index (const tree node)\n    __builtin_preserve_access_index.  */\n \n static tree\n-bpf_core_newdecl (tree type)\n+bpf_core_newdecl (tree type, bool is_pai)\n {\n-  tree rettype = build_function_type_list (type, type, NULL);\n+  tree rettype;\n   char name[80];\n-  int len = snprintf (name, sizeof (name), \"%s\", \"__builtin_pai_\");\n+  static unsigned long pai_count = 0;\n+  static unsigned long pfi_count = 0;\n \n-  static unsigned long cnt = 0;\n-  len = snprintf (name + len, sizeof (name) - len, \"%lu\", cnt++);\n+  if (is_pai)\n+    {\n+      rettype = build_function_type_list (type, type, NULL);\n+      int len = snprintf (name, sizeof (name), \"%s\", \"__builtin_pai_\");\n+      len = snprintf (name + len, sizeof (name) - len, \"%lu\", pai_count++);\n+    }\n+  else\n+    {\n+      rettype = build_function_type_list (unsigned_type_node, type,\n+\t\t\t\t\t  unsigned_type_node, NULL);\n+      int len = snprintf (name, sizeof (name), \"%s\", \"__builtin_pfi_\");\n+      len = snprintf (name + len, sizeof (name) - len, \"%lu\", pfi_count++);\n+    }\n \n-  return add_builtin_function_ext_scope (name, rettype, -1, BUILT_IN_MD, NULL,\n-\t\t\t\t\t NULL_TREE);\n+  return add_builtin_function_ext_scope (name, rettype, is_pai ? -1 : -2,\n+\t\t\t\t\t BUILT_IN_MD, NULL, NULL_TREE);\n }\n \n /* Return whether EXPR could access some aggregate data structure that\n    BPF CO-RE support needs to know about.  */\n \n-static int\n+static bool\n bpf_core_is_maybe_aggregate_access (tree expr)\n {\n-  enum tree_code code = TREE_CODE (expr);\n-  if (code == COMPONENT_REF || code == ARRAY_REF)\n-    return 1;\n-\n-  if (code == ADDR_EXPR)\n+  switch (TREE_CODE (expr))\n+    {\n+    case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      return true;\n+    case ADDR_EXPR:\n+    case NOP_EXPR:\n       return bpf_core_is_maybe_aggregate_access (TREE_OPERAND (expr, 0));\n-\n-  return 0;\n+    default:\n+      return false;\n+    }\n }\n \n+struct core_walk_data {\n+  location_t loc;\n+  tree arg;\n+};\n+\n /* Callback function used with walk_tree from bpf_resolve_overloaded_builtin.  */\n \n static tree\n bpf_core_walk (tree *tp, int *walk_subtrees, void *data)\n {\n-  location_t loc = *((location_t *) data);\n+  struct core_walk_data *dat = (struct core_walk_data *) data;\n+  bool is_pai = dat->arg == NULL_TREE;\n \n   /* If this is a type, don't do anything. */\n   if (TYPE_P (*tp))\n@@ -1302,10 +1510,18 @@ bpf_core_walk (tree *tp, int *walk_subtrees, void *data)\n       return NULL_TREE;\n     }\n \n+  /* Build a new function call to a resolved builtin for the desired operation.\n+     If this is a preserve_field_info call, pass along the argument to the\n+     resolved builtin call. */\n   if (bpf_core_is_maybe_aggregate_access (*tp))\n     {\n-      tree newdecl = bpf_core_newdecl (TREE_TYPE (*tp));\n-      tree newcall = build_call_expr_loc (loc, newdecl, 1, *tp);\n+      tree newdecl = bpf_core_newdecl (TREE_TYPE (*tp), is_pai);\n+      tree newcall;\n+      if (is_pai)\n+\tnewcall = build_call_expr_loc (dat->loc, newdecl, 1, *tp);\n+      else\n+\tnewcall = build_call_expr_loc (dat->loc, newdecl, 2, *tp, dat->arg);\n+\n       *tp = newcall;\n       *walk_subtrees = 0;\n     }\n@@ -1330,6 +1546,30 @@ bpf_small_register_classes_for_mode_p (machine_mode mode)\n #define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P \\\n   bpf_small_register_classes_for_mode_p\n \n+/* Return whether EXPR is a valid first argument for a call to\n+   __builtin_preserve_field_info.  */\n+\n+static bool\n+bpf_is_valid_preserve_field_info_arg (tree expr)\n+{\n+  switch (TREE_CODE (expr))\n+    {\n+    case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      return true;\n+    case NOP_EXPR:\n+      return bpf_is_valid_preserve_field_info_arg (TREE_OPERAND (expr, 0));\n+    case ADDR_EXPR:\n+      /* Do not accept ADDR_EXPRs like &foo.bar, but do accept accesses like\n+\t foo.baz where baz is an array.  */\n+      return (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == ARRAY_TYPE);\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Implement TARGET_RESOLVE_OVERLOADED_BUILTIN (see gccint manual section\n    Target Macros::Misc.).\n    We use this for the __builtin_preserve_access_index builtin for CO-RE\n@@ -1344,26 +1584,39 @@ bpf_small_register_classes_for_mode_p (machine_mode mode)\n static tree\n bpf_resolve_overloaded_builtin (location_t loc, tree fndecl, void *arglist)\n {\n-  if (DECL_MD_FUNCTION_CODE (fndecl) != BPF_BUILTIN_PRESERVE_ACCESS_INDEX)\n+  bool is_pai = DECL_MD_FUNCTION_CODE (fndecl)\n+    == BPF_BUILTIN_PRESERVE_ACCESS_INDEX;\n+  bool is_pfi = DECL_MD_FUNCTION_CODE (fndecl)\n+    == BPF_BUILTIN_PRESERVE_FIELD_INFO;\n+\n+  if (!is_pai && !is_pfi)\n     return NULL_TREE;\n \n   /* We only expect one argument, but it may be an arbitrarily-complicated\n      statement-expression. */\n   vec<tree, va_gc> *params = static_cast<vec<tree, va_gc> *> (arglist);\n   unsigned n_params = params ? params->length() : 0;\n \n-  if (n_params != 1)\n+  if ((is_pai && n_params != 1) || (is_pfi && n_params != 2))\n     {\n-      error_at (loc, \"expected exactly 1 argument\");\n-      return NULL_TREE;\n+      error_at (loc, \"wrong number of arguments\");\n+      return error_mark_node;\n     }\n \n   tree param = (*params)[0];\n \n-  /* If not generating BPF_CORE information, the builtin does nothing.  */\n-  if (!TARGET_BPF_CORE)\n+  /* If not generating BPF_CORE information, preserve_access_index does nothing,\n+     and simply \"resolves to\" the argument.  */\n+  if (!TARGET_BPF_CORE && is_pai)\n     return param;\n \n+  if (is_pfi && !bpf_is_valid_preserve_field_info_arg (param))\n+    {\n+      error_at (EXPR_LOC_OR_LOC (param, loc),\n+\t\t\"argument is not a field access\");\n+      return error_mark_node;\n+    }\n+\n   /* Do remove_c_maybe_const_expr for the arg.\n      TODO: WHY do we have to do this here? Why doesn't c-typeck take care\n      of it before or after this hook? */\n@@ -1387,7 +1640,11 @@ bpf_resolve_overloaded_builtin (location_t loc, tree fndecl, void *arglist)\n      This ensures that all the relevant information remains within the\n      expression trees the builtin finally gets.  */\n \n-  walk_tree (&param, bpf_core_walk, (void *) &loc, NULL);\n+  struct core_walk_data data;\n+  data.loc = loc;\n+  data.arg = is_pai ? NULL_TREE : (*params)[1];\n+\n+  walk_tree (&param, bpf_core_walk, (void *) &data, NULL);\n \n   return param;\n }\n@@ -1524,7 +1781,8 @@ handle_attr_preserve (function *fn)\n \t\t      emit_label (label);\n \n \t\t      /* Add the CO-RE relocation information to the BTF container.  */\n-\t\t      bpf_core_reloc_add (container, section_name, &accessors, label);\n+\t\t      bpf_core_reloc_add (container, section_name, &accessors, label,\n+\t\t\t\t\t  BPF_RELO_FIELD_BYTE_OFFSET);\n \t\t    }\n \t\t}\n \t    }"}, {"sha": "9f71040846b522ceffc7a97e0e1089b65e8e66dd", "filename": "gcc/config/bpf/coreout.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Fconfig%2Fbpf%2Fcoreout.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Fconfig%2Fbpf%2Fcoreout.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fcoreout.cc?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -152,7 +152,8 @@ static GTY (()) vec<bpf_core_section_ref, va_gc> *bpf_core_sections;\n \n void\n bpf_core_reloc_add (const tree type, const char * section_name,\n-\t\t    vec<unsigned int> *accessors, rtx_code_label *label)\n+\t\t    vec<unsigned int> *accessors, rtx_code_label *label,\n+\t\t    enum btf_core_reloc_kind kind)\n {\n   char buf[40];\n   unsigned int i, n = 0;\n@@ -173,7 +174,7 @@ bpf_core_reloc_add (const tree type, const char * section_name,\n \n   bpfcr->bpfcr_type = get_btf_id (ctf_lookup_tree_type (ctfc, type));\n   bpfcr->bpfcr_insn_label = label;\n-  bpfcr->bpfcr_kind = BPF_RELO_FIELD_BYTE_OFFSET;\n+  bpfcr->bpfcr_kind = kind;\n \n   /* Add the CO-RE reloc to the appropriate section.  */\n   bpf_core_section_ref sec;"}, {"sha": "498853f6e001240e790932e85e83802e9a376111", "filename": "gcc/config/bpf/coreout.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Fconfig%2Fbpf%2Fcoreout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Fconfig%2Fbpf%2Fcoreout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fcoreout.h?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -103,7 +103,7 @@ extern void btf_ext_init (void);\n extern void btf_ext_output (void);\n \n extern void bpf_core_reloc_add (const tree, const char *, vec<unsigned int> *,\n-\t\t\t\trtx_code_label *);\n+\t\t\t\trtx_code_label *, enum btf_core_reloc_kind);\n extern int bpf_core_get_sou_member_index (ctf_container_ref, const tree);\n \n #ifdef\t__cplusplus"}, {"sha": "77ea545bdc806462985be5f31ce8e31dd83f1371", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -15755,6 +15755,83 @@ Load 32-bits from the @code{struct sk_buff} packet data pointed by the register\n BPF Compile Once-Run Everywhere (CO-RE) support. Instruct GCC to generate CO-RE relocation records for any accesses to aggregate data structures (struct, union, array types) in @var{expr}. This builtin is otherwise transparent, the return value is whatever @var{expr} evaluates to. It is also overloaded: @var{expr} may be of any type (not necessarily a pointer), the return type is the same. Has no effect if @code{-mco-re} is not in effect (either specified or implied).\n @end deftypefn\n \n+@deftypefn {Built-in Function} unsigned int __builtin_preserve_field_info (@var{expr}, unsigned int @var{kind})\n+BPF Compile Once-Run Everywhere (CO-RE) support. This builtin is used to\n+extract information to aid in struct/union relocations.  @var{expr} is\n+an access to a field of a struct or union. Depending on @var{kind}, different\n+information is returned to the program. A CO-RE relocation for the access in\n+@var{expr} with kind @var{kind} is recorded if @code{-mco-re} is in effect.\n+\n+The following values are supported for @var{kind}:\n+@table @var\n+@item FIELD_BYTE_OFFSET = 0\n+The returned value is the offset, in bytes, of the field from the\n+beginning of the containing structure. For bitfields, the byte offset\n+of the containing word.\n+\n+@item FIELD_BYTE_SIZE = 1\n+The returned value is the size, in bytes, of the field. For bitfields,\n+the size in bytes of the containing word.\n+\n+@item FIELD_EXISTENCE = 2\n+The returned value is 1 if the field exists, 0 otherwise. Always 1 at\n+compile time.\n+\n+@item FIELD_SIGNEDNESS = 3\n+The returned value is 1 if the field is signed, 0 otherwise.\n+\n+@item FIELD_LSHIFT_U64 = 4\n+@itemx FIELD_RSHIFT_U64 = 5\n+The returned value is the number of bits of left- or right-shifting\n+respectively needed in order to recover the original value of the field,\n+after it has been loaded by a read of FIELD_BYTE_SIZE bytes into an\n+unsigned 64-bit value. Primarily useful for reading bitfield values\n+from structures which may change between kernel versions.\n+\n+@end table\n+\n+Note that the return value is a constant which is known at\n+compile-time. If the field has a variable offset then\n+FIELD_BYTE_OFFSET, FIELD_LSHIFT_U64 and FIELD_RSHIFT_U64 are not\n+supported. Similarly, if the field has a variable size then\n+FIELD_BYTE_SIZE, FIELD_LSHIFT_U64 and FIELD_RSHIFT_U64 are not\n+supported.\n+\n+For example, __builtin_preserve_field_info can be used to reliably\n+extract bitfield values from a structure which may change between\n+kernel versions:\n+\n+@example\n+struct S\n+@{\n+  short a;\n+  int x:7;\n+  int y:5;\n+@};\n+\n+int\n+read_y (struct S *arg)\n+@{\n+  unsigned long long val;\n+  unsigned int offset = __builtin_preserve_field_info (arg->y, FIELD_BYTE_OFFSET);\n+  unsigned int size = __builtin_presrve_field_info (arg->y, FIELD_BYTE_SIZE);\n+\n+  /* Read size bytes from arg + offset into val.  */\n+  bpf_probe_read (&val, size, arg + offset);\n+\n+  val <<= __builtin_preserve_field_info (arg->y, FIELD_LSHIFT_U64);\n+\n+  if (__builtin_preserve_field_info (arg->y, FIELD_SIGNEDNESS))\n+    val = ((long long) val >> __builtin_preserve_field_info (arg->y, FIELD_RSHIFT_U64));\n+  else\n+    val >>= __builtin_preserve_field_info (arg->y, FIELD_RSHIFT_U64);\n+\n+  return val;\n+@}\n+\n+@end example\n+@end deftypefn\n+\n @node FR-V Built-in Functions\n @subsection FR-V Built-in Functions\n "}, {"sha": "2c67c38400478524cbadf51af656feb405abacce", "filename": "gcc/testsuite/gcc.target/bpf/core-builtin-fieldinfo-errors-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-errors-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-errors-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-errors-1.c?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -dA -gbtf -mco-re\" } */\n+\n+struct F {\n+  int bar;\n+  char c;\n+  int baz;\n+  int arr[];\n+};\n+\n+enum {\n+  FIELD_BYTE_OFFSET = 0,\n+  FIELD_BYTE_SIZE = 1,\n+};\n+\n+unsigned int test (struct F *f) {\n+\n+  unsigned x = __builtin_preserve_field_info (f->arr, FIELD_BYTE_SIZE); /* { dg-error \"unsupported variable size field access\" } */\n+\n+  unsigned y = __builtin_preserve_field_info (f->baz, 99); /* { dg-error \"invalid second argument to built-in function\" } */\n+\n+  return x + y;\n+}"}, {"sha": "31d7a03b75791d54cb717f116900466e5a266823", "filename": "gcc/testsuite/gcc.target/bpf/core-builtin-fieldinfo-errors-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-errors-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-errors-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-errors-2.c?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -dA -gbtf -mco-re\" } */\n+\n+struct F {\n+  int bar;\n+  char c;\n+  int baz;\n+};\n+\n+enum {\n+  FIELD_BYTE_OFFSET = 0,\n+  FIELD_BYTE_SIZE = 1,\n+};\n+\n+int test (struct F *f) {\n+  int a;\n+  unsigned x = __builtin_preserve_field_info (({ a = f->bar + f->baz; }), FIELD_BYTE_OFFSET); /* { dg-error \"argument is not a field access\" } */\n+\n+  int b;\n+  unsigned y = __builtin_preserve_field_info (&(f->c), FIELD_BYTE_SIZE); /* { dg-error \"argument is not a field access\" } */\n+\n+  return a + b + x + y;\n+}"}, {"sha": "c55f21a9c11433f85057f7dd578badfce02d05fa", "filename": "gcc/testsuite/gcc.target/bpf/core-builtin-fieldinfo-existence-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-existence-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-existence-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-existence-1.c?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -dA -gbtf -mco-re\" } */\n+\n+enum {\n+  FIELD_EXISTENCE = 2,\n+};\n+\n+typedef unsigned uint;\n+\n+struct S {\n+  unsigned char c;\n+  int d;\n+  uint u;\n+  short ar[3];\n+};\n+\n+unsigned int foo (struct S *s)\n+{\n+  unsigned c  = __builtin_preserve_field_info (s->c, FIELD_EXISTENCE);\n+  unsigned d  = __builtin_preserve_field_info (s->d, FIELD_EXISTENCE);\n+  unsigned u  = __builtin_preserve_field_info (s->u, FIELD_EXISTENCE);\n+  unsigned ar = __builtin_preserve_field_info (s->ar[1], FIELD_EXISTENCE);\n+\n+  return c + d + u + ar;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],1\" 4 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:0.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:2.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:3:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"0x2\\[\\t \\]+\\[^\\n\\]*bpfcr_kind\" 4 } } */"}, {"sha": "dabf73dd259d57d2a5c1b171593db329565b28dc", "filename": "gcc/testsuite/gcc.target/bpf/core-builtin-fieldinfo-lshift-1-be.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-lshift-1-be.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-lshift-1-be.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-lshift-1-be.c?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -dA -gbtf -mco-re -mbig-endian\" } */\n+\n+struct S {\n+  int x1: 6;\n+  int x2: 3;\n+  int x3: 7;\n+  int x4: 16;\n+};\n+\n+enum {\n+  FIELD_LSHIFT_U64 = 4,\n+};\n+\n+unsigned int foo (struct S *s)\n+{\n+  /* little endian: x1=58, x2=55, x3=48, x4=32 */\n+  /* big endian:    x1=32, x2=38, x3=41, x4=48 */\n+  unsigned x1 = __builtin_preserve_field_info (s->x1, FIELD_LSHIFT_U64);\n+  unsigned x2 = __builtin_preserve_field_info (s->x2, FIELD_LSHIFT_U64);\n+  unsigned x3 = __builtin_preserve_field_info (s->x3, FIELD_LSHIFT_U64);\n+  unsigned x4 = __builtin_preserve_field_info (s->x4, FIELD_LSHIFT_U64);\n+\n+  return x1 + x2 + x3 + x4;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],32\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],38\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],41\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],48\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:0.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:2.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:3.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"0x4\\[\\t \\]+\\[^\\n\\]*bpfcr_kind\" 4 } } */"}, {"sha": "99e3982d932a716dd05aa444a60fea15bf7e65d7", "filename": "gcc/testsuite/gcc.target/bpf/core-builtin-fieldinfo-lshift-1-le.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-lshift-1-le.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-lshift-1-le.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-lshift-1-le.c?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -dA -gbtf -mco-re -mlittle-endian\" } */\n+\n+struct S {\n+  int x1: 6;\n+  int x2: 3;\n+  int x3: 7;\n+  int x4: 16;\n+};\n+\n+enum {\n+  FIELD_LSHIFT_U64 = 4,\n+};\n+\n+unsigned int foo (struct S *s)\n+{\n+  /* little endian: x1=58, x2=55, x3=48, x4=32 */\n+  /* big endian:    x1=32, x2=38, x3=41, x4=48 */\n+  unsigned x1 = __builtin_preserve_field_info (s->x1, FIELD_LSHIFT_U64);\n+  unsigned x2 = __builtin_preserve_field_info (s->x2, FIELD_LSHIFT_U64);\n+  unsigned x3 = __builtin_preserve_field_info (s->x3, FIELD_LSHIFT_U64);\n+  unsigned x4 = __builtin_preserve_field_info (s->x4, FIELD_LSHIFT_U64);\n+\n+  return x1 + x2 + x3 + x4;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],58\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],55\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],48\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],32\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:0.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:2.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:3.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"0x4\\[\\t \\]+\\[^\\n\\]*bpfcr_kind\" 4 } } */"}, {"sha": "25be969e22b1c0352ae73e0b349bfc29f503e754", "filename": "gcc/testsuite/gcc.target/bpf/core-builtin-fieldinfo-lshift-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-lshift-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-lshift-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-lshift-2.c?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -dA -gbtf -mco-re\" } */\n+\n+struct S {\n+  char c;\n+  short s;\n+  int x;\n+};\n+\n+union U {\n+  struct S s[2];\n+  long long ll;\n+};\n+\n+enum {\n+  FIELD_LSHIFT_U64 = 4,\n+};\n+\n+unsigned int foo (union U *u)\n+{\n+  /* s0s = 48, s1c = 56, ll = 0; endianness independent.  */\n+  unsigned s0s = __builtin_preserve_field_info (u->s[0].s, FIELD_LSHIFT_U64);\n+  unsigned s1c = __builtin_preserve_field_info (u->s[1].c, FIELD_LSHIFT_U64);\n+  unsigned ll  = __builtin_preserve_field_info (u->ll, FIELD_LSHIFT_U64);\n+\n+  return s0s + s1c + ll;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],48\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],56\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],0\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:0:0:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:0:1:0.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"0x4\\[\\t \\]+\\[^\\n\\]*bpfcr_kind\" 3 } } */"}, {"sha": "590eea007ae18869d3b1763f762f1e9a51a4f7da", "filename": "gcc/testsuite/gcc.target/bpf/core-builtin-fieldinfo-offset-1.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-offset-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-offset-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-offset-1.c?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -dA -gbtf -mco-re\" } */\n+\n+struct S {\n+  unsigned int a1: 7;\n+  unsigned int a2: 4;\n+  unsigned int a3: 13;\n+  unsigned int a4: 5;\n+  int x;\n+};\n+\n+struct T {\n+  unsigned int y;\n+  struct S s[2];\n+  char c;\n+  char d;\n+};\n+\n+enum {\n+  FIELD_BYTE_OFFSET = 0,\n+};\n+\n+\n+unsigned int foo (struct T *t)\n+{\n+  unsigned s0a1 = __builtin_preserve_field_info (t->s[0].a1, FIELD_BYTE_OFFSET);\n+  unsigned s0a4 = __builtin_preserve_field_info (t->s[0].a4, FIELD_BYTE_OFFSET);\n+  unsigned s0x  = __builtin_preserve_field_info (t->s[0].x, FIELD_BYTE_OFFSET);\n+\n+  unsigned s1a1 = __builtin_preserve_field_info (t->s[1].a1, FIELD_BYTE_OFFSET);\n+  unsigned s1a4 = __builtin_preserve_field_info (t->s[1].a4, FIELD_BYTE_OFFSET);\n+  unsigned s1x  = __builtin_preserve_field_info (t->s[1].x, FIELD_BYTE_OFFSET);\n+\n+  unsigned c = __builtin_preserve_field_info (t->c, FIELD_BYTE_OFFSET);\n+  unsigned d = __builtin_preserve_field_info (t->d, FIELD_BYTE_OFFSET);\n+\n+  return s0a1 + s0a4 + s0x + s1a1 + s1a4 + s1x + c + d;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],4\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],8\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],12\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],16\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],20\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],21\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:0:0.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:0:3.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:0:4.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:1:0.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:1:3.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:1:4.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:2.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:3.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"0\\[\\t \\]+\\[^\\n\\]*bpfcr_kind\" 8 } } */"}, {"sha": "d0c75d944cd01c2e37cc59ae53f3d5d10c6795e8", "filename": "gcc/testsuite/gcc.target/bpf/core-builtin-fieldinfo-rshift-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-rshift-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-rshift-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-rshift-1.c?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -dA -gbtf -mco-re\" } */\n+\n+struct S {\n+  int x1: 6;\n+  int x2: 3;\n+  int x3: 7;\n+  int x4: 16;\n+};\n+\n+enum {\n+  FIELD_RSHIFT_U64 = 5,\n+};\n+\n+unsigned int foo (struct S *s)\n+{\n+  /* x1=58, x2=61, x3=57, x4=48; endianness independent.  */\n+  unsigned x1 = __builtin_preserve_field_info (s->x1, FIELD_RSHIFT_U64);\n+  unsigned x2 = __builtin_preserve_field_info (s->x2, FIELD_RSHIFT_U64);\n+  unsigned x3 = __builtin_preserve_field_info (s->x3, FIELD_RSHIFT_U64);\n+  unsigned x4 = __builtin_preserve_field_info (s->x4, FIELD_RSHIFT_U64);\n+\n+  return x1 + x2 + x3 + x4;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],58\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],61\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],57\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],48\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:0.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:2.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:3.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"0x5\\[\\t \\]+\\[^\\n\\]*bpfcr_kind\" 4 } } */"}, {"sha": "a71ddc177284ab548e101f8054ec3199197ce6f4", "filename": "gcc/testsuite/gcc.target/bpf/core-builtin-fieldinfo-rshift-2.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-rshift-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-rshift-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-rshift-2.c?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -dA -gbtf -mco-re\" } */\n+\n+struct S {\n+  int x;\n+  char c;\n+};\n+\n+union U {\n+  int i;\n+  struct S s;\n+};\n+\n+enum {\n+  FIELD_RSHIFT_U64 = 5,\n+};\n+\n+unsigned int foo (union U *u)\n+{\n+  /* sx = 32, sc = 56, i = 32; endianness independent.  */\n+  unsigned sx = __builtin_preserve_field_info (u->s.x, FIELD_RSHIFT_U64);\n+  unsigned sc = __builtin_preserve_field_info (u->s.c, FIELD_RSHIFT_U64);\n+  unsigned i  = __builtin_preserve_field_info (u->i, FIELD_RSHIFT_U64);\n+\n+  return sx + sc + i;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],32\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],56\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:0.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:0.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"0x5\\[\\t \\]+\\[^\\n\\]*bpfcr_kind\" 3 } } */"}, {"sha": "3b2081e197ce0d397e416b4032194d7ad4e6061d", "filename": "gcc/testsuite/gcc.target/bpf/core-builtin-fieldinfo-sign-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-sign-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-sign-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-sign-1.c?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -dA -gbtf -mco-re\" } */\n+\n+enum {\n+  FIELD_SIGNEDNESS = 3,\n+};\n+\n+typedef unsigned uint;\n+\n+struct S {\n+  unsigned char c;\n+  int d;\n+  uint u;\n+  short ar[3];\n+};\n+\n+unsigned int foo (struct S *s)\n+{\n+  unsigned d  = __builtin_preserve_field_info (s->d, FIELD_SIGNEDNESS);\n+  unsigned u  = __builtin_preserve_field_info (s->u, FIELD_SIGNEDNESS);\n+  unsigned ar = __builtin_preserve_field_info (s->ar[1], FIELD_SIGNEDNESS);\n+\n+  return d + u + ar;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],1\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],0\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:2.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:3:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"0x3\\[\\t \\]+\\[^\\n\\]*bpfcr_kind\" 3 } } */"}, {"sha": "bf184299984a6f4200c606d764c3b0c0ba157294", "filename": "gcc/testsuite/gcc.target/bpf/core-builtin-fieldinfo-sign-2.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-sign-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-sign-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-sign-2.c?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -dA -gbtf -mco-re\" } */\n+\n+enum {\n+  FIELD_SIGNEDNESS = 3,\n+};\n+\n+enum Esig {\n+  SA = -1,\n+  SB,\n+  SC,\n+};\n+\n+enum Eun {\n+  UA = 0,\n+  UB,\n+};\n+\n+struct S {\n+  enum Esig sig : 3;\n+  enum Eun un : 3;\n+};\n+\n+union U {\n+  int i;\n+  struct S s;\n+};\n+\n+unsigned int foo (union U *u)\n+{\n+  unsigned i   = __builtin_preserve_field_info (u->i, FIELD_SIGNEDNESS);\n+  unsigned sig = __builtin_preserve_field_info (u->s.sig, FIELD_SIGNEDNESS);\n+  unsigned un  = __builtin_preserve_field_info (u->s.un, FIELD_SIGNEDNESS);\n+\n+  return i + sig + un;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],1\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],0\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:0.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:0.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"3\\[\\t \\]+\\[^\\n\\]*bpfcr_kind\" 3 } } */"}, {"sha": "8747bdeb9c3f03bf0383b54659068d23c99e350f", "filename": "gcc/testsuite/gcc.target/bpf/core-builtin-fieldinfo-size-1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-size-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068baae1864e2a8036beec3082d384a204e24201/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-size-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fcore-builtin-fieldinfo-size-1.c?ref=068baae1864e2a8036beec3082d384a204e24201", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -dA -gbtf -mco-re\" } */\n+\n+struct S {\n+  unsigned int a1: 7;\n+  unsigned int a2: 4;\n+  unsigned int a3: 13;\n+  unsigned int a4: 5;\n+  char carr[5][3];\n+};\n+\n+enum {\n+  FIELD_BYTE_SIZE = 1,\n+};\n+\n+union U {\n+  long long l[3];\n+  struct S s;\n+};\n+\n+unsigned int foo (union U *u)\n+{\n+  unsigned ls = __builtin_preserve_field_info (u->l, FIELD_BYTE_SIZE);\n+  unsigned s  = __builtin_preserve_field_info (u->s, FIELD_BYTE_SIZE);\n+  unsigned a2 = __builtin_preserve_field_info (u->s.a2, FIELD_BYTE_SIZE);\n+  unsigned a3 = __builtin_preserve_field_info (u->s.a3, FIELD_BYTE_SIZE);\n+  unsigned ca = __builtin_preserve_field_info (u->s.carr, FIELD_BYTE_SIZE);\n+\n+  return ls + s + a2 + a3 + ca;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],24\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],20\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],4\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]mov\\[\\t \\]%r\\[0-9\\],15\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:0.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:1.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:2.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"0:1:4.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"0x1\\[\\t \\]+\\[^\\n\\]*bpfcr_kind\" 5 } } */"}]}