{"sha": "b727ba74fbfb4fd944755de3a1f413d55ee8fbf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcyN2JhNzRmYmZiNGZkOTQ0NzU1ZGUzYTFmNDEzZDU1ZWU4ZmJmMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-05-23T18:25:41Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-23T18:25:41Z"}, "message": "lto.c (hash_canonical_type): Be sure we hash only types that need alias set.\n\n\n\t* lto.c (hash_canonical_type): Be sure we hash only types that\n\tneed alias set.\n\t(gimple_register_canonical_type_1): Do not produce canonical\n\ttypes for types that do not need alias sets.\n\t* tree.c (gimple_canonical_types_compatible_p): Sanity check that\n\twe do not try to compute canonical type for type that does not need\n\talias set.\n\t(verify_type): Drop FIXME for METHOD_TYPE, update FIXME for\n\tFUNCITON_TYPE.\n\t* tree.h (type_with_alias_set_p): New.\n\nFrom-SVN: r223608", "tree": {"sha": "08d38493f2287d801a46fd580856d47488a4d38a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08d38493f2287d801a46fd580856d47488a4d38a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1/comments", "author": null, "committer": null, "parents": [{"sha": "1d1218fb65079b0ff98ea3b7ac9cbf3a73bcf772", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d1218fb65079b0ff98ea3b7ac9cbf3a73bcf772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d1218fb65079b0ff98ea3b7ac9cbf3a73bcf772"}], "stats": {"total": 61, "additions": 60, "deletions": 1}, "files": [{"sha": "92bb91e44c4d9d8a8e399cde185dcd21fb72af52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b727ba74fbfb4fd944755de3a1f413d55ee8fbf1", "patch": "@@ -1,3 +1,12 @@\n+2015-05-22  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree.c (gimple_canonical_types_compatible_p): Sanity check that\n+\twe do not try to compute canonical type for type that does not need\n+\talias set.\n+\t(verify_type): Drop FIXME for METHOD_TYPE, update FIXME for\n+\tFUNCITON_TYPE.\n+\t* tree.h (type_with_alias_set_p): New.\n+\n 2015-05-22  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree.c (gimple_canonical_types_compatible_p):  Do not compare"}, {"sha": "5fda10033a8a85fc079d8ccad9b35ab8ea34e6b1", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=b727ba74fbfb4fd944755de3a1f413d55ee8fbf1", "patch": "@@ -1,3 +1,10 @@\n+2015-05-22  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (hash_canonical_type): Be sure we hash only types that\n+\tneed alias set.\n+\t(gimple_register_canonical_type_1): Do not produce canonical\n+\ttypes for types that do not need alias sets.\n+\n 2015-05-22  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (hash_canonical_type): Drop hashing of METHOD_BASETYPE."}, {"sha": "169b025eda5fb5a6f6b40e572bca82a98423e4d0", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=b727ba74fbfb4fd944755de3a1f413d55ee8fbf1", "patch": "@@ -309,6 +309,12 @@ hash_canonical_type (tree type)\n {\n   inchash::hash hstate;\n \n+  /* We compute alias sets only for types that needs them.\n+     Be sure we do not recurse to something else as we can not hash incomplete\n+     types in a way they would have same hash value as compatible complete\n+     types.  */\n+  gcc_checking_assert (type_with_alias_set_p (type));\n+\n   /* Combine a few common features of types so that types are grouped into\n      smaller sets; when searching for existing matching types to merge,\n      only existing types having the same features as the new type will be\n@@ -489,7 +495,7 @@ gimple_register_canonical_type_1 (tree t, hashval_t hash)\n static void\n gimple_register_canonical_type (tree t)\n {\n-  if (TYPE_CANONICAL (t))\n+  if (TYPE_CANONICAL (t) || !type_with_alias_set_p (t))\n     return;\n \n   gimple_register_canonical_type_1 (t, hash_canonical_type (t));"}, {"sha": "8b0344697f07f7b951548ea3bfcec2130a979aa6", "filename": "gcc/tree.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b727ba74fbfb4fd944755de3a1f413d55ee8fbf1", "patch": "@@ -12720,6 +12720,23 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n   if (t1 == NULL_TREE || t2 == NULL_TREE)\n     return false;\n \n+  /* We consider complete types always compatible with incomplete type.\n+     This does not make sense for canonical type calculation and thus we\n+     need to ensure that we are never called on it.\n+\n+     FIXME: For more correctness the function probably should have three modes\n+\t1) mode assuming that types are complete mathcing their structure\n+\t2) mode allowing incomplete types but producing equivalence classes\n+\t   and thus ignoring all info from complete types\n+\t3) mode allowing incomplete types to match complete but checking\n+\t   compatibility between complete types.\n+\n+     1 and 2 can be used for canonical type calculation. 3 is the real\n+     definition of type compatibility that can be used i.e. for warnings during\n+     declaration merging.  */\n+\n+  gcc_assert (!trust_type_canonical\n+\t      || (type_with_alias_set_p (t1) && type_with_alias_set_p (t2)));\n   /* If the types have been previously registered and found equal\n      they still are.  */\n   if (TYPE_CANONICAL (t1) && TYPE_CANONICAL (t2)"}, {"sha": "0b7b5239380bae2a76c097a4c01fe70228eea094", "filename": "gcc/tree.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b727ba74fbfb4fd944755de3a1f413d55ee8fbf1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b727ba74fbfb4fd944755de3a1f413d55ee8fbf1", "patch": "@@ -5090,6 +5090,26 @@ int_bit_position (const_tree field)\n \t  + wi::to_offset (DECL_FIELD_BIT_OFFSET (field))).to_shwi ();\n }\n \n+/* Return true if it makes sense to consider alias set for a type T.  */\n+\n+inline bool\n+type_with_alias_set_p (const_tree t)\n+{\n+  /* Function and method types are never accessed as memory locations.  */\n+  if (TREE_CODE (t) == FUNCTION_TYPE || TREE_CODE (t) == METHOD_TYPE)\n+    return false;\n+\n+  if (COMPLETE_TYPE_P (t))\n+    return true;\n+\n+  /* Incomplete types can not be accessed in general except for arrays\n+     where we can fetch its element despite we have no array bounds.  */\n+  if (TREE_CODE (t) == ARRAY_TYPE && COMPLETE_TYPE_P (TREE_TYPE (t)))\n+    return true;\n+\n+  return false;\n+}\n+\n extern void gt_ggc_mx (tree &);\n extern void gt_pch_nx (tree &);\n extern void gt_pch_nx (tree &, gt_pointer_operator, void *);"}]}