{"sha": "b17d5d7c3b32aba86425d412465649b34de657b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE3ZDVkN2MzYjMyYWJhODY0MjVkNDEyNDY1NjQ5YjM0ZGU2NTdiNA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-02-26T10:48:36Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-02-26T10:48:36Z"}, "message": "cse.c (count_reg_usage): Fix handling of REG_EQUAL notes.\n\n\t* cse.c (count_reg_usage): Fix handling of REG_EQUAL notes.\n\n\t* Makefile.in (loop-unroll.o): New.\n\t* cfgloop.h (UAP_PEEL, UAP_UNROLL, UAP_UNROLL_ALL): New.\n\t(unroll_and_peel_loops): Declare.\n\t* alias.c (init_alias_analysis): Flag_unroll_loops renamed to\n\tflag_old_unroll_loops.\n\t* loop.c (loop_invariant_p): Ditto.\n\t* unroll.c (unroll_loop): Flag_unroll_all_loops renamed to\n\tflag_old_unroll_all_loops.\n\t* flags.h (flag_unroll_loops): Renamed to flag_old_unroll_loops.\n\t(flag_unroll_all_loops): Renamed to flag_old_unroll_all_loops.\n\t* params.def (PARAM_MAX_UNROLLED_INSNS): Default value changed.\n\t(PARAM_MAX_AVERAGE_UNROLLED_INSNS, PARAM_MAX_UNROLL_TIMES,\n\tPARAM_MAX_PEELED_INSNS, PARAM_MAX_PEEL_TIMES,\n\tPARAM_MAX_COMPLETELY_PEELED_INSNS, PARAM_MAX_COMPLETELY_PEEL_TIMES,\n\tPARAM_MAX_ONCE_PEELED_INSNS): New.\n\t* toplev.h (flag_old_unroll_loops, flag_old_unroll_all_loops): New.\n\t(flag_unroll_loops, flag_unroll_all_loops): Used for new unroller\n\tinstead of old one.\n\t(flag_peel_loops): New.\n\t(lang_independent_options): The new flags added.\n\t(rest_of_compilation): Call new unroller.\n\t(process_options): Setup flags for coexistence of old and new unroller.\n\t* doc/invoke.texi: Document new options.\n\t* doc/passes.texi: Document new unroller pass.\n\nFrom-SVN: r63462", "tree": {"sha": "0eb271bb5e907e017194e3ff3b24e129090bdcf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0eb271bb5e907e017194e3ff3b24e129090bdcf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b17d5d7c3b32aba86425d412465649b34de657b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b17d5d7c3b32aba86425d412465649b34de657b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b17d5d7c3b32aba86425d412465649b34de657b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b17d5d7c3b32aba86425d412465649b34de657b4/comments", "author": null, "committer": null, "parents": [{"sha": "244f7aa99ae5305e090708b81d3d59660a9bfb80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/244f7aa99ae5305e090708b81d3d59660a9bfb80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/244f7aa99ae5305e090708b81d3d59660a9bfb80"}], "stats": {"total": 270, "additions": 242, "deletions": 28}, "files": [{"sha": "6e1633b45719977ee07bd24a26d151c17dbad91d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -1,3 +1,32 @@\n+2003-02-26  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* cse.c (count_reg_usage): Fix handling of REG_EQUAL notes.\n+\n+\t* Makefile.in (loop-unroll.o): New.\n+\t* cfgloop.h (UAP_PEEL, UAP_UNROLL, UAP_UNROLL_ALL): New.\n+\t(unroll_and_peel_loops): Declare.\n+\t* alias.c (init_alias_analysis): Flag_unroll_loops renamed to\n+\tflag_old_unroll_loops.\n+\t* loop.c (loop_invariant_p): Ditto.\n+\t* unroll.c (unroll_loop): Flag_unroll_all_loops renamed to\n+\tflag_old_unroll_all_loops.\n+\t* flags.h (flag_unroll_loops): Renamed to flag_old_unroll_loops.\n+\t(flag_unroll_all_loops): Renamed to flag_old_unroll_all_loops.\n+\t* params.def (PARAM_MAX_UNROLLED_INSNS): Default value changed.\n+\t(PARAM_MAX_AVERAGE_UNROLLED_INSNS, PARAM_MAX_UNROLL_TIMES,\n+\tPARAM_MAX_PEELED_INSNS, PARAM_MAX_PEEL_TIMES,\n+\tPARAM_MAX_COMPLETELY_PEELED_INSNS, PARAM_MAX_COMPLETELY_PEEL_TIMES,\n+\tPARAM_MAX_ONCE_PEELED_INSNS): New.\n+\t* toplev.h (flag_old_unroll_loops, flag_old_unroll_all_loops): New.\n+\t(flag_unroll_loops, flag_unroll_all_loops): Used for new unroller\n+\tinstead of old one.\n+\t(flag_peel_loops): New.\n+\t(lang_independent_options): The new flags added.\n+\t(rest_of_compilation): Call new unroller.\n+\t(process_options): Setup flags for coexistence of old and new unroller.\n+\t* doc/invoke.texi: Document new options.\n+\t* doc/passes.texi: Document new unroller pass.\n+\n 2003-02-26  David Billinghurst <David.Billinghurst@riotinto.com>\n \n \t* fixinc/fixincl.x: Regenerate"}, {"sha": "494a14b48d48aeddcf1fb7749a48d384cb19c322", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -74,7 +74,7 @@ XCFLAGS =\n TCFLAGS =\n CFLAGS = -g\n STAGE1_CFLAGS = -g @stage1_cflags@\n-BOOT_CFLAGS = -g -O2\n+BOOT_CFLAGS = -g -O2 -funroll-loops -fpeel-loops\n \n # Flags to determine code coverage. When coverage is disabled, this will\n # contain the optimization flags, as you normally want code coverage\n@@ -768,7 +768,7 @@ C_OBJS = c-parse.o c-lang.o c-pretty-print.o $(C_AND_OBJC_OBJS)\n \n OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n- cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o\t\t   \\\n+ cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n  cfgrtl.o combine.o conflict.o convert.o cse.o cselib.o dbxout.o\t   \\\n  debug.o df.o diagnostic.o doloop.o dominance.o\t\t                   \\\n  dwarf2asm.o dwarf2out.o dwarfout.o emit-rtl.o except.o explow.o\t   \\\n@@ -1612,6 +1612,9 @@ loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) gcov-io.h \\\n loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h params.h \\\n    output.h $(EXPR_H) coretypes.h $(TM_H)\n+loop-unroll.o: loop-unroll.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h params.h \\\n+   output.h $(EXPR_H) coretypes.h $(TM_H)\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h\n et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) et-forest.h alloc-pool.h"}, {"sha": "de8d8d7c221de78d6a02a0b74cf04dc6dc5272a0", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -2763,7 +2763,7 @@ init_alias_analysis ()\n \n   new_reg_base_value = (rtx *) xmalloc (reg_base_value_size * sizeof (rtx));\n   reg_seen = (char *) xmalloc (reg_base_value_size);\n-  if (! reload_completed && flag_unroll_loops)\n+  if (! reload_completed && flag_old_unroll_loops)\n     {\n       /* ??? Why are we realloc'ing if we're just going to zero it?  */\n       alias_invariant = (rtx *)xrealloc (alias_invariant,"}, {"sha": "ae1e5290e401e50f1e1bac15169a7cc40ce0db16", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -337,3 +337,11 @@ extern void loop_optimizer_finalize\tPARAMS ((struct loops *, FILE *));\n /* Optimization passes.  */\n extern void unswitch_loops\t\tPARAMS ((struct loops *));\n \n+enum\n+{\n+  UAP_PEEL = 1,\t\t/* Enables loop peeling.  */\n+  UAP_UNROLL = 2,\t/* Enables peeling of loops if it seems profitable.  */\n+  UAP_UNROLL_ALL = 4\t/* Enables peeling of all loops.  */\n+};\n+\n+extern void unroll_and_peel_loops\tPARAMS ((struct loops *, int));"}, {"sha": "6321c7c6dd925da56381fd23a3e65835e0f3b978", "filename": "gcc/cse.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -7459,6 +7459,7 @@ count_reg_usage (x, counts, dest, incr)\n      int incr;\n {\n   enum rtx_code code;\n+  rtx note;\n   const char *fmt;\n   int i, j;\n \n@@ -7516,16 +7517,13 @@ count_reg_usage (x, counts, dest, incr)\n       /* Things used in a REG_EQUAL note aren't dead since loop may try to\n \t use them.  */\n \n-      count_reg_usage (REG_NOTES (x), counts, NULL_RTX, incr);\n+      note = find_reg_equal_equiv_note (x);\n+      if (note)\n+        count_reg_usage (XEXP (note, 0), counts, NULL_RTX, incr);\n       return;\n \n-    case EXPR_LIST:\n     case INSN_LIST:\n-      if (REG_NOTE_KIND (x) == REG_EQUAL\n-\t  || (REG_NOTE_KIND (x) != REG_NONNEG && GET_CODE (XEXP (x,0)) == USE))\n-\tcount_reg_usage (XEXP (x, 0), counts, NULL_RTX, incr);\n-      count_reg_usage (XEXP (x, 1), counts, NULL_RTX, incr);\n-      return;\n+      abort ();\n \n     default:\n       break;"}, {"sha": "747f003695738671cb161ae4794ff917aa64f86f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -291,7 +291,8 @@ in the following sections.\n -fsched2-use-traces  -fsignaling-nans @gol\n -fsingle-precision-constant  -fssa -fssa-ccp -fssa-dce @gol\n -fstrength-reduce  -fstrict-aliasing  -ftracer -fthread-jumps @gol\n--funit-at-a-time -funroll-all-loops  -funroll-loops  -funswitch-loops @gol\n+-funroll-all-loops  -funroll-loops -fpeel-loops -funswitch-loops @gol\n+-fold-unroll-loops -fold-unroll-all-loops @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os}\n \n@@ -4292,17 +4293,50 @@ extra optimizations to take place but consumes more memory.\n \n @item -funroll-loops\n @opindex funroll-loops\n-Unroll loops whose number of iterations can be determined at compile\n-time or upon entry to the loop.  @option{-funroll-loops} implies both\n-@option{-fstrength-reduce} and @option{-frerun-cse-after-loop}.  This\n-option makes code larger, and may or may not make it run faster.\n+Unroll loops whose number of iterations can be determined at compile time or\n+upon entry to the loop.  @option{-funroll-loops} implies\n+@option{-frerun-cse-after-loop}.  It also turns on complete loop peeling\n+(i.e. complete removal of loops with small constant number of iterations).\n+This option makes code larger, and may or may not make it run faster.\n \n @item -funroll-all-loops\n @opindex funroll-all-loops\n Unroll all loops, even if their number of iterations is uncertain when\n the loop is entered.  This usually makes programs run more slowly.\n @option{-funroll-all-loops} implies the same options as\n-@option{-funroll-loops},\n+@option{-funroll-loops}.\n+\n+@item -fpeel-loops\n+@opindex fpeel-loops\n+Peels the loops for that there is enough information that they do not\n+roll much (from profile feedback).  It also turns on complete loop peeling\n+(i.e. complete removal of loops with small constant number of iterations).\n+\n+@item -funswitch-loops\n+@opindex funswitch-loops\n+Move branches with loop invariant conditions out of the loop, with duplicates\n+of the loop on both branches (modified according to result of the condition).\n+\n+@item -fold-unroll-loops\n+@opindex fold-unroll-loops\n+Unroll loops whose number of iterations can be determined at compile\n+time or upon entry to the loop, using the old loop unroller whose loop\n+recognition is based on notes from frontend.  @option{-fold-unroll-loops} implies\n+both @option{-fstrength-reduce} and @option{-frerun-cse-after-loop}.  This\n+option makes code larger, and may or may not make it run faster.\n+\n+@item -fold-unroll-all-loops\n+@opindex fold-unroll-all-loops\n+Unroll all loops, even if their number of iterations is uncertain when\n+the loop is entered. This is done using the old loop unroller whose loop\n+recognition is based on notes from frontend.  This usually makes programs run more slowly.\n+@option{-fold-unroll-all-loops} implies the same options as\n+@option{-fold-unroll-loops}.\n+ \n+@item -funswitch-loops\n+@opindex funswitch-loops\n+Move branches with loop invariant conditions out of the loop, with duplicates\n+of the loop on both branches (modified according to result of the condition).\n \n @item -funswitch-loops\n @opindex funswitch-loops\n@@ -4418,6 +4452,28 @@ The maximum number of instructions that a loop should have if that loop\n is unrolled, and if the loop is unrolled, it determines how many times\n the loop code is unrolled.\n \n+@item max-average-unrolled-insns\n+The maximum number of instructions biased by probabilities of their execution\n+that a loop should have if that loop is unrolled, and if the loop is unrolled,\n+it determines how many times the loop code is unrolled.\n+\n+@item max-unroll-times\n+The maximum number of unrollings of a single loop.\n+\n+@item max-peeled-insns\n+The maximum number of instructions that a loop should have if that loop\n+is peeled, and if the loop is peeled, it determines how many times\n+the loop code is peeled.\n+\n+@item max-peel-times\n+The maximum number of peelings of a single loop.\n+\n+@item max-completely-peeled-insns\n+The maximum number of insns of a completely peeled loop.\n+\n+@item max-completely-peel-times\n+The maximum number of iterations of a loop to be suitable for complete peeling.\n+\n @item max-unswitch-insns\n The maximum number of insns of an unswitched loop.\n "}, {"sha": "10cc3815c98575e8110aa6084088a06ea669ad27", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -334,10 +334,11 @@ some functions in @file{integrate.c} and the header @file{integrate.h}.\n Loop dependency analysis routines are contained in @file{dependence.c}.\n \n Second loop optimization pass takes care of basic block level optimalizations --\n-unswitching loops. The source files are\n+unrolling, peeling and unswitching loops. The source files are\n @file{cfgloopanal.c} and @file{cfgloopmanip.c} containing generic loop\n analysis and manipulation code, @file{loop-init.c} with initialization and\n-finalization code, @file{loop-unswitch.c} for loop unswitching.\n+finalization code, @file{loop-unswitch.c} for loop unswitching and\n+@file{loop-unroll.c} for loop unrolling and peeling.\n \n @opindex dL\n The option @option{-dL} causes a debugging dump of the RTL code after"}, {"sha": "4a8068969017533371b40f4ec2a3dcc9709f7882", "filename": "gcc/flags.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -282,12 +282,12 @@ extern int flag_strength_reduce;\n    UNROLL_MODULO) or at run-time (preconditioned to be UNROLL_MODULO) are\n    unrolled.  */\n \n-extern int flag_unroll_loops;\n+extern int flag_old_unroll_loops;\n \n /* Nonzero enables loop unrolling in unroll.c.  All loops are unrolled.\n    This is generally not a win.  */\n \n-extern int flag_unroll_all_loops;\n+extern int flag_old_unroll_all_loops;\n \n /* Nonzero forces all invariant computations in loops to be moved\n    outside the loop.  */"}, {"sha": "48ca0023863158367553a2c6e0f0b638edd9fda8", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -3245,7 +3245,7 @@ loop_invariant_p (loop, x)\n \n \t We don't know the loop bounds here though, so just fail for all\n \t labels.  */\n-      if (flag_unroll_loops)\n+      if (flag_old_unroll_loops)\n \treturn 0;\n       else\n \treturn 1;"}, {"sha": "a0744f9b3ade63e1f5ad24fd4e88cf6c5b29f650", "filename": "gcc/params.def", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -149,7 +149,43 @@ DEFPARAM(PARAM_MAX_GCSE_PASSES,\n DEFPARAM(PARAM_MAX_UNROLLED_INSNS,\n \t \"max-unrolled-insns\",\n \t \"The maximum number of instructions to consider to unroll in a loop\",\n-\t 100)\n+\t 200)\n+/* This parameter limits how many times the loop is unrolled depending\n+   on number of insns really executed in each iteration.  */\n+DEFPARAM(PARAM_MAX_AVERAGE_UNROLLED_INSNS,\n+\t \"max-average-unrolled-insns\",\n+\t \"The maximum number of instructions to consider to unroll in a loop on average\",\n+\t 80)\n+/* The maximum number of unrollings of a single loop.  */\n+DEFPARAM(PARAM_MAX_UNROLL_TIMES,\n+\t\"max-unroll-times\",\n+\t\"The maximum number of unrollings of a single loop\",\n+\t8)\n+/* The maximum number of insns of a peeled loop.  */\n+DEFPARAM(PARAM_MAX_PEELED_INSNS,\n+\t\"max-peeled-insns\",\n+\t\"The maximum number of insns of a peeled loop\",\n+\t120)\n+/* The maximum number of peelings of a single loop.  */\n+DEFPARAM(PARAM_MAX_PEEL_TIMES,\n+\t\"max-peel-times\",\n+\t\"The maximum number of peelings of a single loop\",\n+\t16)\n+/* The maximum number of insns of a peeled loop.  */\n+DEFPARAM(PARAM_MAX_COMPLETELY_PEELED_INSNS,\n+\t\"max-completely-peeled-insns\",\n+\t\"The maximum number of insns of a completely peeled loop\",\n+\t120)\n+/* The maximum number of peelings of a single loop that is peeled completely.  */\n+DEFPARAM(PARAM_MAX_COMPLETELY_PEEL_TIMES,\n+\t\"max-completely-peel-times\",\n+\t\"The maximum number of peelings of a single loop that is peeled completely\",\n+\t16)\n+/* The maximum number of insns of a peeled loop that rolls only once.  */\n+DEFPARAM(PARAM_MAX_ONCE_PEELED_INSNS,\n+\t\"max-once-peeled-insns\",\n+\t\"The maximum number of insns of a peeled loop that rolls only once\",\n+\t200)\n \n /* The maximum number of insns of an unswitched loop.  */\n DEFPARAM(PARAM_MAX_UNSWITCH_INSNS,"}, {"sha": "bcdaf536209c6af1bc002b6171faeabc96f1c700", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -1,3 +1,10 @@\n+2003-02-26  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* lib/scanasm.exp: Add support for counting numbers of\n+\toccurences.\n+\t* gcc.dg/unswitch-1.c, gcc.dg/peel-1.c, gcc.dg/unroll-1.c,\n+\tgcc.dg/unroll-2.c, gcc.dg/unroll-3.c: New tests.\n+\n 2003-02-25  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/9683"}, {"sha": "774ec4a7ecd51e27c7f691bfbf194315dc872d7c", "filename": "gcc/testsuite/lib/scanasm.exp", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Ftestsuite%2Flib%2Fscanasm.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Ftestsuite%2Flib%2Fscanasm.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fscanasm.exp?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -56,6 +56,44 @@ proc scan-assembler { args } {\n     }\n }\n \n+# Call pass if pattern is present given number of times, otherwise fail.\n+proc scan-assembler-times { args } {\n+    if { [llength $args] < 2 } {\n+\terror \"scan-assembler: too few arguments\"\n+        return\n+    }\n+    if { [llength $args] > 3 } {\n+\terror \"scan-assembler: too many arguments\"\n+\treturn\n+    }\n+    if { [llength $args] >= 3 } {\n+\tswitch [dg-process-target [lindex $args 2]] {\n+\t    \"S\" { }\n+\t    \"N\" { return }\n+\t    \"F\" { error \"scan-assembler: `xfail' not allowed here\" }\n+\t    \"P\" { error \"scan-assembler: `xfail' not allowed here\" }\n+\t}\n+    }\n+\n+    # This assumes that we are two frames down from dg-test, and that\n+    # it still stores the filename of the testcase in a local variable \"name\".\n+    # A cleaner solution would require a new dejagnu release.\n+    upvar 2 name testcase\n+\n+    # This must match the rule in gcc-dg.exp.\n+    set output_file \"[file rootname [file tail $testcase]].s\"\n+\n+    set fd [open $output_file r]\n+    set text [read $fd]\n+    close $fd\n+\n+    if { [llength [regexp -inline -all -- [lindex $args 0] $text]] == [lindex $args 1]} {\n+\tpass \"$testcase scan-assembler-times [lindex $args 0] [lindex $args 1]\"\n+    } else {\n+\tfail \"$testcase scan-assembler-times [lindex $args 0] [lindex $args 1]\"\n+    }\n+}\n+\n # Call pass if pattern is not present, otherwise fail.\n proc scan-assembler-not { args } {\n     if { [llength $args] < 1 } {"}, {"sha": "ae068d43472c09c86d6c7afda10013e6a60669db", "filename": "gcc/toplev.c", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -515,13 +515,22 @@ int flag_strength_reduce = 0;\n    UNROLL_MODULO) or at run-time (preconditioned to be UNROLL_MODULO) are\n    unrolled.  */\n \n-int flag_unroll_loops;\n+int flag_old_unroll_loops;\n \n /* Nonzero enables loop unrolling in unroll.c.  All loops are unrolled.\n    This is generally not a win.  */\n \n+int flag_old_unroll_all_loops;\n+\n+/* Enables unrolling of simple loops in loop-unroll.c.  */\n+int flag_unroll_loops;\n+\n+/* Enables unrolling of all loops in loop-unroll.c.  */\n int flag_unroll_all_loops;\n \n+/* Nonzero enables loop peeling.  */\n+int flag_peel_loops;\n+\n /* Nonzero enables loop unswitching.  */\n int flag_unswitch_loops;\n \n@@ -1016,6 +1025,12 @@ static const lang_independent_options f_options[] =\n    N_(\"Perform loop unrolling when iteration count is known\") },\n   {\"unroll-all-loops\", &flag_unroll_all_loops, 1,\n    N_(\"Perform loop unrolling for all loops\") },\n+  {\"old-unroll-loops\", &flag_old_unroll_loops, 1,\n+   N_(\"Perform loop unrolling when iteration count is known\") },\n+  {\"old-unroll-all-loops\", &flag_old_unroll_all_loops, 1,\n+   N_(\"Perform loop unrolling for all loops\") },\n+  {\"peel-loops\", &flag_peel_loops, 1,\n+   N_(\"Perform loop peeling\") },\n   {\"unswitch-loops\", &flag_unswitch_loops, 1,\n    N_(\"Perform loop unswitching\") },\n   {\"prefetch-loop-arrays\", &flag_prefetch_loop_arrays, 1,\n@@ -2950,7 +2965,10 @@ rest_of_compilation (decl)\n       /* CFG is no longer maintained up-to-date.  */\n       free_bb_for_insn ();\n \n-      do_unroll = flag_unroll_loops ? LOOP_UNROLL : LOOP_AUTO_UNROLL;\n+      if (flag_unroll_loops)\n+\tdo_unroll = 0;\t\t/* Having two unrollers is useless.  */\n+      else\n+\tdo_unroll = flag_old_unroll_loops ? LOOP_UNROLL : LOOP_AUTO_UNROLL;\n       do_prefetch = flag_prefetch_loop_arrays ? LOOP_PREFETCH : 0;\n       if (flag_rerun_loop_opt)\n \t{\n@@ -3090,7 +3108,9 @@ rest_of_compilation (decl)\n   /* Perform loop optimalizations.  It might be better to do them a bit\n      sooner, but we want the profile feedback to work more efficiently.  */\n   if (optimize > 0\n-      && flag_unswitch_loops)\n+      && (flag_unswitch_loops\n+\t  || flag_peel_loops\n+\t  || flag_unroll_loops))\n     {\n       struct loops *loops;\n       timevar_push (TV_LOOP);\n@@ -3106,6 +3126,12 @@ rest_of_compilation (decl)\n \t  if (flag_unswitch_loops)\n \t    unswitch_loops (loops);\n \n+ \t  if (flag_peel_loops || flag_unroll_loops)\n+ \t    unroll_and_peel_loops (loops,\n+\t\t(flag_peel_loops ? UAP_PEEL : 0) |\n+\t\t(flag_unroll_loops ? UAP_UNROLL : 0) |\n+\t\t(flag_unroll_all_loops ? UAP_UNROLL_ALL : 0));\n+\n \t  loop_optimizer_finalize (loops, rtl_dump_file);\n \t}\n \n@@ -5134,15 +5160,27 @@ process_options ()\n      be done.  */\n   if (flag_unroll_all_loops)\n     flag_unroll_loops = 1;\n-  /* Loop unrolling requires that strength_reduction be on also.  Silently\n+\n+  if (flag_unroll_loops)\n+    {\n+      flag_old_unroll_loops = 0;\n+      flag_old_unroll_all_loops = 0;\n+    }\n+\n+  if (flag_old_unroll_all_loops)\n+    flag_old_unroll_loops = 1;\n+\n+  /* Old loop unrolling requires that strength_reduction be on also.  Silently\n      turn on strength reduction here if it isn't already on.  Also, the loop\n      unrolling code assumes that cse will be run after loop, so that must\n      be turned on also.  */\n-  if (flag_unroll_loops)\n+  if (flag_old_unroll_loops)\n     {\n       flag_strength_reduce = 1;\n       flag_rerun_cse_after_loop = 1;\n     }\n+  if (flag_unroll_loops || flag_peel_loops)\n+    flag_rerun_cse_after_loop = 1;\n \n   if (flag_non_call_exceptions)\n     flag_asynchronous_unwind_tables = 1;"}, {"sha": "982b32dfbf2fc85f9660ed8a99edffe8ee5b4593", "filename": "gcc/unroll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17d5d7c3b32aba86425d412465649b34de657b4/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=b17d5d7c3b32aba86425d412465649b34de657b4", "patch": "@@ -1123,7 +1123,7 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \n   /* If reach here, and the loop type is UNROLL_NAIVE, then don't unroll\n      the loop unless all loops are being unrolled.  */\n-  if (unroll_type == UNROLL_NAIVE && ! flag_unroll_all_loops)\n+  if (unroll_type == UNROLL_NAIVE && ! flag_old_unroll_all_loops)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,"}]}