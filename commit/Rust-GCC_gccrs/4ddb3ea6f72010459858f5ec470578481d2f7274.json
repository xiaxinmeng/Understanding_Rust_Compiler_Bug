{"sha": "4ddb3ea6f72010459858f5ec470578481d2f7274", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRkYjNlYTZmNzIwMTA0NTk4NThmNWVjNDcwNTc4NDgxZDJmNzI3NA==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-01-07T02:53:44Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-01-07T02:53:44Z"}, "message": "c4x.c: Added space after negation operator.\n\n\t* config/c4x/c4x.c: Added space after negation operator.\n\t* config/c4x/c4x.h: Likewise.\n\t* config/c4x/c4x.md: Likewise.\n\nFrom-SVN: r24555", "tree": {"sha": "9393d6ff22dada0157d4f631e25962832b9a934d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9393d6ff22dada0157d4f631e25962832b9a934d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ddb3ea6f72010459858f5ec470578481d2f7274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ddb3ea6f72010459858f5ec470578481d2f7274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ddb3ea6f72010459858f5ec470578481d2f7274", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ddb3ea6f72010459858f5ec470578481d2f7274/comments", "author": null, "committer": null, "parents": [{"sha": "f2b15118d6587d36ec489429c46986f5b86191df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2b15118d6587d36ec489429c46986f5b86191df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2b15118d6587d36ec489429c46986f5b86191df"}], "stats": {"total": 364, "additions": 185, "deletions": 179}, "files": [{"sha": "54197b28c03fd37f90337989828e9324f10fd920", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ddb3ea6f72010459858f5ec470578481d2f7274/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ddb3ea6f72010459858f5ec470578481d2f7274/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ddb3ea6f72010459858f5ec470578481d2f7274", "patch": "@@ -1,3 +1,9 @@\n+Thu Jan  7 23:54:05 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.c: Added space after negation operator.\n+\t* config/c4x/c4x.h: Likewise.\n+\t* config/c4x/c4x.md: Likewise.\n+\n Thu Jan  7 23:39:27 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.c (c4x_preferred_reload_class): Always return class."}, {"sha": "5a6ff225d935439e4f48cb62e23afd6099564173", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ddb3ea6f72010459858f5ec470578481d2f7274/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ddb3ea6f72010459858f5ec470578481d2f7274/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=4ddb3ea6f72010459858f5ec470578481d2f7274", "patch": "@@ -204,12 +204,12 @@ c4x_override_options ()\n \n   /* We should phase out the following at some stage.\n      This provides compatibility with the old -mno-rptb option.  */\n-  if (!TARGET_RPTB && flag_branch_on_count_reg)\n+  if (! TARGET_RPTB && flag_branch_on_count_reg)\n     flag_branch_on_count_reg = 0;\n \n   /* We should phase out the following at some stage.\n      This provides compatibility with the old -mno-aliases option.  */\n-  if (!TARGET_ALIASES && !flag_argument_noalias)\n+  if (! TARGET_ALIASES && ! flag_argument_noalias)\n     flag_argument_noalias = 1;\n }\n \n@@ -282,7 +282,7 @@ c4x_output_ascii (stream, ptr, len)\n     }\n   if (s)\n     {\n-      if (!first)\n+      if (! first)\n \tfputc (',', stream);\n \n       sbuf[s] = 0;\n@@ -418,12 +418,12 @@ c4x_init_cumulative_args (cum, fntype, libname)\n \n \t  /* If the last arg doesn't have void type then we have\n \t     variable arguments.  */\n-\t  if (!next_param)\n+\t  if (! next_param)\n \t    cum->var = 1;\n \n \t  if ((mode = TYPE_MODE (type)))\n \t    {\n-\t      if (!MUST_PASS_IN_STACK (mode, type))\n+\t      if (! MUST_PASS_IN_STACK (mode, type))\n \t\t{\n \t\t  /* Look for float, double, or long double argument.  */\n \t\t  if (mode == QFmode || mode == HFmode)\n@@ -460,10 +460,10 @@ c4x_function_arg_advance (cum, mode, type, named)\n   if (TARGET_DEBUG)\n     fprintf (stderr, \"c4x_function_adv(mode=%s, named=%d)\\n\\n\",\n \t     GET_MODE_NAME (mode), named);\n-  if (!TARGET_MEMPARM \n+  if (! TARGET_MEMPARM \n       && named\n       && type\n-      && !MUST_PASS_IN_STACK (mode, type))\n+      && ! MUST_PASS_IN_STACK (mode, type))\n     {\n       /* Look for float, double, or long double argument.  */\n       if (mode == QFmode || mode == HFmode)\n@@ -472,7 +472,7 @@ c4x_function_arg_advance (cum, mode, type, named)\n       else if (mode == QImode || mode == Pmode)\n \tcum->ints++;\n     }\n-  else if (!TARGET_MEMPARM && !type)\n+  else if (! TARGET_MEMPARM && ! type)\n     {\n       /* Handle libcall arguments.  */\n       if (mode == QFmode || mode == HFmode)\n@@ -506,7 +506,7 @@ c4x_function_arg (cum, mode, type, named)\n {\n   int reg = 0;\t\t\t/* default to passing argument on stack */\n \n-  if (!cum->init)\n+  if (! cum->init)\n     {\n       /* We can handle at most 2 floats in R2, R3 */\n       cum->maxfloats = (cum->floats > 2) ? 2 : cum->floats;\n@@ -517,17 +517,17 @@ c4x_function_arg (cum, mode, type, named)\n \t6 - cum->maxfloats : cum->ints;\n \n       /* If there is no prototype, assume all the arguments are integers. */\n-      if (!cum->prototype)\n+      if (! cum->prototype)\n \tcum->maxints = 6;\n \n       cum->ints = cum->floats = 0;\n       cum->init = 1;\n     }\n \n-  if (!TARGET_MEMPARM \n+  if (! TARGET_MEMPARM \n       && named \n       && type\n-      && !MUST_PASS_IN_STACK (mode, type))\n+      && ! MUST_PASS_IN_STACK (mode, type))\n     {\n       /* Look for float, double, or long double argument.  */\n       if (mode == QFmode || mode == HFmode)\n@@ -542,7 +542,7 @@ c4x_function_arg (cum, mode, type, named)\n \t    reg = c4x_int_reglist[cum->maxfloats][cum->ints];\n \t}\n     }\n-  else if (!TARGET_MEMPARM && !type)\n+  else if (! TARGET_MEMPARM && ! type)\n     {\n       /* We could use a different argument calling model for libcalls,\n          since we're only calling functions in libgcc.  Thus we could\n@@ -587,7 +587,7 @@ c4x_isr_reg_used_p (regno)\n      We'll only save if for the big memory model or if\n      we're paranoid. ;-)  */\n   if (IS_DP_REG (regno))\n-    return !TARGET_SMALL || TARGET_PARANOID;\n+    return ! TARGET_SMALL || TARGET_PARANOID;\n \n   /* Only save/restore regs in leaf function that are used.  */\n   if (c4x_leaf_function)\n@@ -774,7 +774,7 @@ c4x_function_prologue (file, size)\n \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t{\n-\t  if (regs_ever_live[regno] && !call_used_regs[regno])\n+\t  if (regs_ever_live[regno] && ! call_used_regs[regno])\n \t    {\n \t      if ((regno == R6_REGNO) || (regno == R7_REGNO))\n \t\t{\n@@ -783,7 +783,7 @@ c4x_function_prologue (file, size)\n \t\t    fprintf (file, \"\\tpush\\t%s\\n\", reg_names[regno]);\n \t\t  fprintf (file, \"\\tpushf\\t%s\\n\", float_reg_names[regno]);\n \t\t}\n-\t      else if ((!dont_push_ar3) || (regno != AR3_REGNO))\n+\t      else if ((! dont_push_ar3) || (regno != AR3_REGNO))\n \t\t{\n \t\t  fprintf (file, \"\\tpush\\t%s\\n\", reg_names[regno]);\n \t\t}\n@@ -832,7 +832,7 @@ c4x_function_epilogue (file, size)\n     {\n       for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; --regno)\n \t{\n-\t  if (!c4x_isr_reg_used_p (regno))\n+\t  if (! c4x_isr_reg_used_p (regno))\n \t    continue;\n \t  if (IS_EXT_REG (regno))\n \t    fprintf (file, \"\\tpopf\\t%s\\n\", float_reg_names[regno]);\n@@ -887,8 +887,8 @@ c4x_function_epilogue (file, size)\n          registers.  */\n       for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n \t{\n-\t  if ((regs_ever_live[regno] && !call_used_regs[regno])\n-\t      && ((!dont_pop_ar3) || (regno != AR3_REGNO)))\n+\t  if ((regs_ever_live[regno] && ! call_used_regs[regno])\n+\t      && ((! dont_pop_ar3) || (regno != AR3_REGNO)))\n \t    {\n \t      restore_count++;\n \t      if (TARGET_PRESERVE_FLOAT\n@@ -921,7 +921,7 @@ c4x_function_epilogue (file, size)\n          where required.  */\n       for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n \t{\n-\t  if (regs_ever_live[regno] && !call_used_regs[regno])\n+\t  if (regs_ever_live[regno] && ! call_used_regs[regno])\n \t    {\n \t      if (regno == AR3_REGNO && dont_pop_ar3)\n \t\tcontinue;\n@@ -988,7 +988,7 @@ c4x_function_epilogue (file, size)\n \t  fprintf (file, \"\\tsubi\\t%d,sp\\n\", size);\n \t}\n \n-      if (!delayed_jump)\n+      if (! delayed_jump)\n \tfprintf (file, \"\\trets\\n\");\n     }\n }\n@@ -999,16 +999,16 @@ c4x_null_epilogue_p ()\n   int regno;\n \n   if (reload_completed\n-      && !c4x_assembler_function_p ()\n-      && !c4x_interrupt_function_p ()\n-      && !current_function_calls_alloca\n-      && !current_function_args_size\n-      && !(profile_block_flag == 2)\n-      && !(optimize < 2)\n-      && !get_frame_size ())\n+      && ! c4x_assembler_function_p ()\n+      && ! c4x_interrupt_function_p ()\n+      && ! current_function_calls_alloca\n+      && ! current_function_args_size\n+      && ! (profile_block_flag == 2)\n+      && ! (optimize < 2)\n+      && ! get_frame_size ())\n     {\n       for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n-\tif (regs_ever_live[regno] && !call_used_regs[regno]\n+\tif (regs_ever_live[regno] && ! call_used_regs[regno]\n \t    && (regno != AR3_REGNO))\n \t  return 0;\n       return 1;\n@@ -1148,7 +1148,7 @@ c4x_check_legit_addr (mode, addr, strict)\n     case PRE_INC:\n     case POST_INC:\n       base = XEXP (addr, 0);\n-      if (!REG_P (base))\n+      if (! REG_P (base))\n \treturn 0;\n       break;\n \n@@ -1161,7 +1161,7 @@ c4x_check_legit_addr (mode, addr, strict)\n \tif (mode != QImode && mode != QFmode)\n \t  return 0;\n \n-\tif (!REG_P (op0) \n+\tif (! REG_P (op0) \n \t    || (GET_CODE (op1) != PLUS && GET_CODE (op1) != MINUS))\n \t  return 0;\n \tbase = XEXP (op1, 0);\n@@ -1268,9 +1268,9 @@ c4x_check_legit_addr (mode, addr, strict)\n       /* Handle DP based stuff.  */\n       if (REGNO (base) == DP_REGNO)\n \treturn 1;\n-      if (strict && !REGNO_OK_FOR_BASE_P (REGNO (base)))\n+      if (strict && ! REGNO_OK_FOR_BASE_P (REGNO (base)))\n \treturn 0;\n-      else if (!strict && !IS_ADDR_OR_PSEUDO_REGNO (base))\n+      else if (! strict && ! IS_ADDR_OR_PSEUDO_REGNO (base))\n \treturn 0;\n     }\n \n@@ -1279,9 +1279,9 @@ c4x_check_legit_addr (mode, addr, strict)\n     {\n       if (GET_CODE (indx) != REG)\n \treturn 0;\n-      if (strict && !REGNO_OK_FOR_INDEX_P (REGNO (indx)))\n+      if (strict && ! REGNO_OK_FOR_INDEX_P (REGNO (indx)))\n \treturn 0;\n-      else if (!strict && !IS_INDEX_OR_PSEUDO_REGNO (indx))\n+      else if (! strict && ! IS_INDEX_OR_PSEUDO_REGNO (indx))\n \treturn 0;\n     }\n \n@@ -1293,12 +1293,12 @@ c4x_check_legit_addr (mode, addr, strict)\n       if (mode == HImode || mode == HFmode)\n \t{\n \t  /* The offset displacement must be legitimate.  */\n-\t  if (!IS_DISP8_OFF_CONST (INTVAL (disp)))\n+\t  if (! IS_DISP8_OFF_CONST (INTVAL (disp)))\n \t    return 0;\n \t}\n       else\n \t{\n-\t  if (!IS_DISP8_CONST (INTVAL (disp)))\n+\t  if (! IS_DISP8_CONST (INTVAL (disp)))\n \t    return 0;\n \t}\n       /* Can't add an index with a disp.  */\n@@ -1380,7 +1380,7 @@ rtx addr;\n \t    if (IS_DISP1_CONST (INTVAL (op1)))\n \t      return 1;\n \n-\t    if (!TARGET_C3X && IS_UINT5_CONST (INTVAL (op1)))\n+\t    if (! TARGET_C3X && IS_UINT5_CONST (INTVAL (op1)))\n \t      return 2;\n \n \t    return 3;\n@@ -1426,8 +1426,8 @@ c4x_output_cbranch (form, seq)\n   if (final_sequence)\n     {\n       delay = XVECEXP (final_sequence, 0, 1);\n-      delayed = !INSN_ANNULLED_BRANCH_P (seq);\n-      annultrue = INSN_ANNULLED_BRANCH_P (seq) && !INSN_FROM_TARGET_P (delay);\n+      delayed = ! INSN_ANNULLED_BRANCH_P (seq);\n+      annultrue = INSN_ANNULLED_BRANCH_P (seq) && ! INSN_FROM_TARGET_P (delay);\n       annulfalse = INSN_ANNULLED_BRANCH_P (seq) && INSN_FROM_TARGET_P (delay);\n     }\n   strcpy (str, form);\n@@ -1510,7 +1510,7 @@ c4x_print_operand (file, op, letter)\n       return;\n \n     case 'K':\t\t\t/* generate ldp(k) if direct address */\n-      if (!TARGET_SMALL\n+      if (! TARGET_SMALL\n \t  && code == MEM\n \t  && GET_CODE (XEXP (op, 0)) == PLUS\n \t  && GET_CODE(XEXP (XEXP (op, 0), 0)) == REG\n@@ -1527,7 +1527,7 @@ c4x_print_operand (file, op, letter)\n       return;\n \n     case 'M':\t\t\t/* generate ldp(k) if direct address */\n-      if (!TARGET_SMALL\t\t/* only used in asm statements */\n+      if (! TARGET_SMALL\t\t/* only used in asm statements */\n \t  && code == MEM\n \t  && (GET_CODE (XEXP (op, 0)) == CONST\n \t      || GET_CODE (XEXP (op, 0)) == SYMBOL_REF))\n@@ -1769,7 +1769,7 @@ c4x_print_operand_address (file, addr)\n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n-      if (!SYMBOL_REF_FLAG (addr))\n+      if (! SYMBOL_REF_FLAG (addr))\n \tfprintf (file, \"@\");\n       output_addr_const (file, addr);\n       SYMBOL_REF_FLAG (addr) = 0;\n@@ -1849,7 +1849,7 @@ c4x_scan_for_ldp (newop, insn, operand0)\n \n \tcase CONST:\n \tcase SYMBOL_REF:\n-\t  if (!TARGET_C3X && !TARGET_SMALL\n+\t  if (! TARGET_C3X && ! TARGET_SMALL\n \t      && recog_memoized (insn) == CODE_FOR_movqi_noclobber\n \t      && ((addr = find_reg_note (insn, REG_EQUAL, NULL_RTX))\n \t\t  || (addr = find_reg_note (insn, REG_EQUIV, NULL_RTX)))\n@@ -1888,7 +1888,7 @@ c4x_scan_for_ldp (newop, insn, operand0)\n \t\t  return 1;\n \t\t}\n \t    }\n-\t  if (!TARGET_SMALL)\n+\t  if (! TARGET_SMALL)\n \t    emit_insn_before (gen_set_ldp (gen_rtx_REG (Pmode, DP_REGNO),\n \t\t\t\t\t   operand), insn);\n \n@@ -1942,7 +1942,7 @@ c4x_scan_for_ldp (newop, insn, operand0)\n \t\t\t\t\t      gen_rtx_REG (Pmode, DP_REGNO)),\n \t\t\t\t\t  op0));\n       \n-      if (!TARGET_SMALL)\n+      if (! TARGET_SMALL)\n \temit_insn_before (gen_set_ldp_use (gen_rtx_REG (Pmode, DP_REGNO),\n \t\t\t\t\t   *newop, operand), insn);\n       return 0;\n@@ -2048,7 +2048,7 @@ c4x_rptb_insert (insn)\n   for (; insn; insn = PREV_INSN (insn))\n     if (insn == start_label)\n       break;\n-  if (!insn)\n+  if (! insn)\n     fatal_insn (\"c4x_rptb_insert: Cannot find start label\", start_label);\n \n   /* We'll have to update the basic blocks.  */\n@@ -2092,7 +2092,7 @@ c4x_process_after_reload (first)\n \t     is a chance that we might be accessing memory across a\n \t     page boundary.  */\n \n-\t  if (!TARGET_SMALL)\n+\t  if (! TARGET_SMALL)\n \t    {\n \t      char *template;\n \n@@ -2263,7 +2263,7 @@ c4x_Q_constraint (op)\n \trtx op0 = XEXP (op, 0);\n \trtx op1 = XEXP (op, 1);\n \n-\tif (!REG_P (op0))\n+\tif (! REG_P (op0))\n \t  return 0;\n \n \tif (REG_P (op1))\n@@ -2310,7 +2310,7 @@ c4x_R_constraint (op)\n \trtx op0 = XEXP (op, 0);\n \trtx op1 = XEXP (op, 1);\n \n-\tif (!REG_P (op0))\n+\tif (! REG_P (op0))\n \t  return 0;\n \n \tif (GET_CODE (op1) != CONST_INT)\n@@ -2417,7 +2417,7 @@ c4x_S_constraint (op)\n \tif (REG_P (op1))\n \t  return 1;\n \n-\tif (GET_CODE (op1) != CONST_INT)\n+\tif (GET_CODE (op1) ! = CONST_INT)\n \t  return 0;\n \t\n \t/* HImode and HFmode must be offsettable.  */\n@@ -2686,7 +2686,7 @@ not_modify_reg (op, mode)\n \trtx op0 = XEXP (op, 0);\n \trtx op1 = XEXP (op, 1);\n \n-\tif (!REG_P (op0))\n+\tif (! REG_P (op0))\n \t  return 0;\n \t\n \tif (REG_P (op1) || GET_CODE (op1) == CONST_INT)\n@@ -2719,7 +2719,7 @@ r0r1_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (!register_operand (op, mode))\n+  if (! register_operand (op, mode))\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -2734,7 +2734,7 @@ r2r3_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (!register_operand (op, mode))\n+  if (! register_operand (op, mode))\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -2749,7 +2749,7 @@ ext_low_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (!register_operand (op, mode))\n+  if (! register_operand (op, mode))\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -2764,11 +2764,11 @@ ext_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (!register_operand (op, mode))\n+  if (! register_operand (op, mode))\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n-  if (!REG_P (op))\n+  if (! REG_P (op))\n     return 0;\n   return IS_EXT_OR_PSEUDO_REGNO (op);\n }\n@@ -2781,7 +2781,7 @@ std_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (!register_operand (op, mode))\n+  if (! register_operand (op, mode))\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -2796,7 +2796,7 @@ addr_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (!register_operand (op, mode))\n+  if (! register_operand (op, mode))\n     return 0;\n   return c4x_a_register (op);\n }\n@@ -2809,7 +2809,7 @@ index_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (!register_operand (op, mode))\n+  if (! register_operand (op, mode))\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -3137,7 +3137,7 @@ c4x_address_conflict (op0, op1, store0, store1)\n \t have an aliased address if both locations are not marked\n \t volatile, it is probably safer to flag a potential conflict\n \t if either location is volatile.  */\n-      if (!flag_argument_noalias)\n+      if (! flag_argument_noalias)\n \t{\n \t  if (MEM_VOLATILE_P (op0) || MEM_VOLATILE_P (op1))\n \t    return 1;\n@@ -3156,7 +3156,7 @@ c4x_address_conflict (op0, op1, store0, store1)\n   /* It might be too confusing for GCC if we have use a base register\n      with a side effect and a memory reference using the same register\n      in parallel.  */\n-  if (!TARGET_DEVEL && base0 == base1 && (incdec0 || incdec1))\n+  if (! TARGET_DEVEL && base0 == base1 && (incdec0 || incdec1))\n     return 1;\n \n   /* We can not optimize the case where op1 and op2 refer to the same\n@@ -3228,22 +3228,22 @@ valid_parallel_load_store (operands, mode)\n   if (GET_CODE (op0) == REG && GET_CODE (op2) == REG)\n     return (REGNO (op0) != REGNO (op2))\n       && GET_CODE (op1) == MEM && GET_CODE (op3) == MEM\n-      && !c4x_address_conflict (op1, op3, 0, 0);\n+      && ! c4x_address_conflict (op1, op3, 0, 0);\n \n   /* STI||STI  */\n   if (GET_CODE (op1) == REG && GET_CODE (op3) == REG)\n     return GET_CODE (op0) == MEM && GET_CODE (op2) == MEM\n-      && !c4x_address_conflict (op0, op2, 1, 1);\n+      && ! c4x_address_conflict (op0, op2, 1, 1);\n \n   /* LDI||STI  */\n   if (GET_CODE (op0) == REG && GET_CODE (op3) == REG)\n     return GET_CODE (op1) == MEM && GET_CODE (op2) == MEM\n-      && !c4x_address_conflict (op1, op2, 0, 1);\n+      && ! c4x_address_conflict (op1, op2, 0, 1);\n \n   /* STI||LDI  */\n   if (GET_CODE (op1) == REG && GET_CODE (op2) == REG)\n     return GET_CODE (op0) == MEM && GET_CODE (op3) == MEM\n-      && !c4x_address_conflict (op0, op3, 1, 0);\n+      && ! c4x_address_conflict (op0, op3, 1, 0);\n \n   return 0;\n }\n@@ -3426,7 +3426,7 @@ c4x_valid_operands (code, operands, mode, force)\n \t  break;\n \t  \n \tcase CONST_DOUBLE:\n-\t  if (!c4x_H_constant (op2))\n+\t  if (! c4x_H_constant (op2))\n \t    return 0;\n \t  break;\n \n@@ -3446,7 +3446,7 @@ c4x_valid_operands (code, operands, mode, force)\n       \n       /* Check that we have a valid destination register for a two operand\n \t instruction.  */\n-      return !force || code == COMPARE || REGNO (op1) == REGNO (operands[0]);\n+      return ! force || code == COMPARE || REGNO (op1) == REGNO (operands[0]);\n     }\n \n   /* We assume MINUS is commutative since the subtract patterns\n@@ -3466,7 +3466,7 @@ c4x_valid_operands (code, operands, mode, force)\n       break;\n       \n     case CONST_DOUBLE:\n-      if (!c4x_H_constant (op1))\n+      if (! c4x_H_constant (op1))\n \treturn 0;\n       break;\n \n@@ -3486,7 +3486,7 @@ c4x_valid_operands (code, operands, mode, force)\n       \n   /* Check that we have a valid destination register for a two operand\n      instruction.  */\n-  return !force || REGNO (op1) == REGNO (operands[0]);\n+  return ! force || REGNO (op1) == REGNO (operands[0]);\n }\n \n \n@@ -3504,7 +3504,7 @@ int valid_operands (code, operands, mode)\n      operands for an insn when not optimizing.  The problem only rarely\n      occurs, for example with the C-torture program DFcmp.c  */\n \n-  return !optimize || c4x_valid_operands (code, operands, mode, 0);\n+  return ! optimize || c4x_valid_operands (code, operands, mode, 0);\n }\n \n \n@@ -3531,29 +3531,29 @@ legitimize_operands (code, operands, mode)\n \t the cost mechanism doesn't allow us to look at the other\n \t operand to decide whether the constant is expensive.  */\n       \n-      if (!reload_in_progress\n+      if (! reload_in_progress\n \t  && TARGET_HOIST\n \t  && optimize > 0\n \t  && ((GET_CODE (operands[1]) == CONST_INT \n-\t       && !c4x_J_constant (operands[1])\n+\t       && ! c4x_J_constant (operands[1])\n \t       && INTVAL (operands[1]) != 0)\n \t      || GET_CODE (operands[1]) == CONST_DOUBLE))\n \toperands[1] = force_reg (mode, operands[1]);\n       \n-      if (!reload_in_progress\n-          && !c4x_valid_operands (code, operands, mode, 0))\n+      if (! reload_in_progress\n+          && ! c4x_valid_operands (code, operands, mode, 0))\n \toperands[0] = force_reg (mode, operands[0]);\n       return 1;\n     }\n   \n   /* We cannot do this for ADDI/SUBI insns since we will\n      defeat the flow pass from finding autoincrement addressing\n      opportunities.  */\n-  if (!reload_in_progress\n-      && !((code == PLUS || code == MINUS) && mode == Pmode)\n+  if (! reload_in_progress\n+      && ! ((code == PLUS || code == MINUS) && mode == Pmode)\n       && (TARGET_HOIST && optimize > 1\n        && ((GET_CODE (operands[2]) == CONST_INT \n-\t    && !c4x_J_constant (operands[2])\n+\t    && ! c4x_J_constant (operands[2])\n \t    && INTVAL (operands[2]) != 0)\n \t   || GET_CODE (operands[2]) == CONST_DOUBLE)))\n     operands[2] = force_reg (mode, operands[2]);\n@@ -3568,8 +3568,8 @@ legitimize_operands (code, operands, mode)\n      Note that expand_binops will not try to load an expensive constant\n      into a register if it is used within a loop for a shift insn.  */\n   \n-  if (!reload_in_progress\n-      && !c4x_valid_operands (code, operands, mode, TARGET_FORCE))\n+  if (! reload_in_progress\n+      && ! c4x_valid_operands (code, operands, mode, TARGET_FORCE))\n     {\n       /* If the operand combination is invalid, we force operand1 into a\n          register, preventing reload from having doing to do this at a\n@@ -3583,7 +3583,7 @@ legitimize_operands (code, operands, mode)\n       else\n \t{\n \t  /* Just in case...  */\n-\t  if (!c4x_valid_operands (code, operands, mode, 0))\n+\t  if (! c4x_valid_operands (code, operands, mode, 0))\n \t    operands[2] = force_reg (mode, operands[2]);\n \t}\n     }\n@@ -3987,7 +3987,7 @@ c4x_handle_pragma (p_getc, p_ungetc, pname)\n \n   c = p_getc ();\n   while (c == ' ' || c == '\\t') c = p_getc ();\n-  if (!(isalpha(c) || c == '_' || c == '$' || c == '@'))\n+  if (! (isalpha(c) || c == '_' || c == '$' || c == '@'))\n     return 0;\n \n   i = 0;\n@@ -4090,8 +4090,8 @@ c4x_check_attribute(attrib, list, decl, attributes)\n      tree list, decl, *attributes;\n {\n   while (list != NULL_TREE\n-         && IDENTIFIER_POINTER (TREE_PURPOSE (list)) !=\n-\t IDENTIFIER_POINTER (DECL_NAME (decl)))\n+         && IDENTIFIER_POINTER (TREE_PURPOSE (list))\n+\t != IDENTIFIER_POINTER (DECL_NAME (decl)))\n     list = TREE_CHAIN(list);\n   if (list)\n     *attributes = chainon (*attributes,\n@@ -4212,7 +4212,7 @@ c4x_adjust_cost (insn, link, dep_insn, cost)\n {\n   /* Don't worry about this until we know what registers have been\n      assigned.  */\n-  if (!reload_completed)\n+  if (! reload_completed)\n     return 0;\n \n   /* How do we handle dependencies where a read followed by another"}, {"sha": "a2053d301c98073531a8e731457522310d87608d", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ddb3ea6f72010459858f5ec470578481d2f7274/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ddb3ea6f72010459858f5ec470578481d2f7274/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=4ddb3ea6f72010459858f5ec470578481d2f7274", "patch": "@@ -238,7 +238,7 @@ extern int target_flags;\n #define TARGET_RPTB\t\t(target_flags & RPTB_FLAG \\\n \t\t\t\t && optimize >= 2)\n #define TARGET_BK\t\t(target_flags & BK_FLAG)\n-#define TARGET_DB\t\t(!TARGET_C3X || (target_flags & DB_FLAG))\n+#define TARGET_DB\t\t(! TARGET_C3X || (target_flags & DB_FLAG))\n #define TARGET_DEBUG\t\t(target_flags & DEBUG_FLAG)\n #define TARGET_HOIST\t\t(target_flags & HOIST_FLAG)\n #define TARGET_LOOP_UNSIGNED\t(target_flags & LOOP_UNSIGNED_FLAG)\n@@ -418,7 +418,7 @@ extern void c4x_optimization_options ();\n \n /* Extended precision registers (high set) */\n \n-#define IS_EXT_HIGH_REG(r)         (!TARGET_C3X \\\n+#define IS_EXT_HIGH_REG(r)         (! TARGET_C3X \\\n \t\t\t            && ((r) >= R8_REGNO) && ((r) <= R11_REGNO))\n /* Address registers */\n \n@@ -512,7 +512,7 @@ extern void c4x_optimization_options ();\n \n #define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n-    if (!TARGET_BK)\t\t\t\t\t\\\n+    if (! TARGET_BK)\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\\\n \tfixed_regs[BK_REGNO] = 1;\t\t\t\\\n         call_used_regs[BK_REGNO] = 1;\t\t\t\\\n@@ -813,7 +813,7 @@ c4x_secondary_memory_needed(CLASS1, CLASS2, MODE)\n \n #define IS_NOT_UINT16_CONST(VAL) IS_UINT16_CONST(~(VAL))\t/* 'N' */\n \n-#define IS_HIGH_CONST(VAL) (!TARGET_C3X && (((VAL) & 0xffff) == 0)) /* 'O' */\n+#define IS_HIGH_CONST(VAL) (! TARGET_C3X && (((VAL) & 0xffff) == 0)) /* 'O' */\n \n \n #define IS_DISP1_CONST(VAL) (((VAL) <= 1) && ((VAL) >= -1)) /* 'S' */\n@@ -828,10 +828,10 @@ c4x_secondary_memory_needed(CLASS1, CLASS2, MODE)\n \n #define CONST_OK_FOR_LETTER_P(VAL, C)\t\t\t\t\t\\\n         ( ((C) == 'I') ? (IS_INT16_CONST (VAL))\t\t\t\t\\\n-\t: ((C) == 'J') ? (!TARGET_C3X && IS_INT8_CONST (VAL))\t\t\\\n-\t: ((C) == 'K') ? (!TARGET_C3X && IS_INT5_CONST (VAL))\t\t\\\n+\t: ((C) == 'J') ? (! TARGET_C3X && IS_INT8_CONST (VAL))\t\t\\\n+\t: ((C) == 'K') ? (! TARGET_C3X && IS_INT5_CONST (VAL))\t\t\\\n         : ((C) == 'L') ? (IS_UINT16_CONST (VAL))\t\t\t\\\n-\t: ((C) == 'M') ? (!TARGET_C3X && IS_UINT8_CONST (VAL))\t\t\\\n+\t: ((C) == 'M') ? (! TARGET_C3X && IS_UINT8_CONST (VAL))\t\t\\\n \t: ((C) == 'N') ? (IS_NOT_UINT16_CONST (VAL))\t\t        \\\n \t: ((C) == 'O') ? (IS_HIGH_CONST (VAL))\t\t\t        \\\n         : 0 )\t\n@@ -990,7 +990,7 @@ c4x_secondary_memory_needed(CLASS1, CLASS2, MODE)\n  int regno;\t\t\t\t\t\t\t\\\n  int offset = 0;\t\t\t\t\t\t\\\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n       offset += TARGET_PRESERVE_FLOAT\t\t\t\t\\\n \t\t&& ((regno == R6_REGNO) || (regno == R7_REGNO)) \\\n \t\t? 2 : 1;\t\t\t\t\t\\\n@@ -1002,15 +1002,15 @@ c4x_secondary_memory_needed(CLASS1, CLASS2, MODE)\n   {{ FRAME_POINTER_REGNUM, FRAME_POINTER_REGNUM }}\n \n #define\tCAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n-  (!(((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \\\n+  (! (((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \\\n   || ((FROM) == FRAME_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)))\n \n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t \t\\\n {\t\t\t\t\t\t\t\t\\\n  int regno;\t\t\t\t\t\t\t\\\n  int offset = 0;\t\t\t\t\t\t\\\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n       offset += TARGET_PRESERVE_FLOAT\t\t\t\t\\\n \t\t&& ((regno == R6_REGNO) || (regno == R7_REGNO)) \\\n \t\t? 2 : 1;\t\t\t\t\t\\\n@@ -1108,7 +1108,7 @@ extern struct rtx_def *c4x_function_arg();\n    MSBs of the address.  This is not supported by the TI assembler.  */\n \n #define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\\\n-     if (!TARGET_C3X)\t\t\t\t\t\t\\\n+     if (! TARGET_C3X)\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\\\n \tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n \tfprintf (FILE, \"\\tldhi\\t^LP%d,ar2\\n\", (LABELNO));\t\\\n@@ -1158,7 +1158,7 @@ extern struct rtx_def *c4x_function_arg();\n #define FUNCTION_BLOCK_PROFILER(FILE, BLOCKNO) \t\t\t\\\n   if (profile_block_flag == 2)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      if (!TARGET_C3X)\t\t\t\t\t\t\\\n+      if (! TARGET_C3X)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n \tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n@@ -1205,7 +1205,7 @@ extern struct rtx_def *c4x_function_arg();\n     }\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      if (!TARGET_C3X)\t\t\t\t\t\t\\\n+      if (! TARGET_C3X)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n \tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n@@ -1237,7 +1237,7 @@ extern struct rtx_def *c4x_function_arg();\n #define BLOCK_PROFILER(FILE, BLOCKNO) \t\t\t\t\\\n   if (profile_block_flag == 2)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      if (!TARGET_C3X)\t\t\t\t\t\t\\\n+      if (! TARGET_C3X)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n \tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n@@ -1293,7 +1293,7 @@ extern struct rtx_def *c4x_function_arg();\n     }\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      if (!TARGET_C3X)\t\t\t\t\t\t\\\n+      if (! TARGET_C3X)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n \tfprintf (FILE, \"\\tpush\\tar0\\n\");\t\t\t\\\n@@ -1830,7 +1830,7 @@ void\t\t\t\t\t\t\t\t\t\\\n const_section ()\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   extern void text_section();\t\t\t\t\t\t\\\n-  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n+  if (! USE_CONST_SECTION)\t\t\t\t\t\t\\\n     text_section();\t\t\t\t\t\t\t\\\n   else if (in_section != in_const)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -1910,10 +1910,10 @@ dtors_section ()\t\t\t\t\t\t\t\\\n   else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       if ((0 && RELOC)\t/* should be (flag_pic && RELOC) */\t\t\\\n-\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n-\t  || !DECL_INITIAL (DECL)\t\t\t\t\t\\\n+\t  || ! TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n+\t  || ! DECL_INITIAL (DECL)\t\t\t\t\t\\\n \t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\t\\\n-\t      && !TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\t\\\n+\t      && ! TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\t\\\n \tdata_section ();\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \tconst_section ();\t\t\t\t\t\t\\\n@@ -1965,7 +1965,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n    may have quietly changed this register on the sly. */\n \n #define ASM_IDENTIFY_GCC(FILE) \\\n-    if (!TARGET_TI) fputs (\"gcc2_compiled.:\\n\", FILE);\t\\\n+    if (! TARGET_TI) fputs (\"gcc2_compiled.:\\n\", FILE);\t\\\n       fputs (\"\\t.data\\ndata_sec:\\n\", FILE);\n \n #define ASM_COMMENT_START\t\";\""}, {"sha": "fd565a39cddfa10d8c96b7b84d30988b2bcaf6b8", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ddb3ea6f72010459858f5ec470578481d2f7274/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ddb3ea6f72010459858f5ec470578481d2f7274/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=4ddb3ea6f72010459858f5ec470578481d2f7274", "patch": "@@ -1092,7 +1092,7 @@\n (define_insn \"set_ldp\"\n   [(set (match_operand:QI 0 \"dp_reg_operand\" \"=z\")\n         (high:QI (match_operand:QI 1 \"\" \"\")))]\n-  \"!TARGET_SMALL\"\n+  \"! TARGET_SMALL\"\n   \"* return (TARGET_C3X) ? \\\"ldp\\\\t%A1\\\" : \\\"ldpk\\\\t%A1\\\";\"\n   [(set_attr \"type\" \"ldp\")])\n \n@@ -1105,15 +1105,15 @@\n   [(parallel [(set (match_operand:QI 0 \"dp_reg_operand\" \"=z\")\n                    (high:QI (match_operand:QI 1 \"\" \"\")))\n               (use (match_operand 2 \"\" \"\"))])]\n-  \"!TARGET_SMALL\"\n+  \"! TARGET_SMALL\"\n   \"* return (TARGET_C3X) ? \\\"ldp\\\\t%A1\\\" : \\\"ldpk\\\\t%A1\\\";\"\n   [(set_attr \"type\" \"ldp\")])\n \n (define_insn \"set_high_use\"\n   [(parallel [(set (match_operand:QI 0 \"std_reg_operand\" \"=c\")\n                    (high:QI (match_operand:QI 1 \"\" \"\")))\n               (use (match_operand 2 \"\" \"\"))])]\n-  \"!TARGET_C3X && !TARGET_SMALL\"\n+  \"! TARGET_C3X && ! TARGET_SMALL\"\n   \"ldhi\\\\t^%H1,%0\"\n   [(set_attr \"type\" \"unary\")])\n \n@@ -1123,7 +1123,7 @@\n                            (and:QI (match_operand:QI 1 \"\" \"\")\n                                    (const_int 65535))))\n               (use (match_operand 2 \"\" \"\"))])]\n-  \"!TARGET_C3X && !TARGET_SMALL\"\n+  \"! TARGET_C3X && ! TARGET_SMALL\"\n   \"or\\\\t#%H1,%0\"\n   [(set_attr \"type\" \"unary\")])\n \n@@ -1137,7 +1137,7 @@\n (define_insn \"*movqi_stik\"\n   [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n         (match_operand:QI 1 \"stik_const_operand\" \"K\"))]\n-  \"!TARGET_C3X\"\n+  \"! TARGET_C3X\"\n   \"stik\\\\t%1,%0\"\n   [(set_attr \"type\" \"store\")])\n \n@@ -1152,15 +1152,15 @@\n    if (which_alternative == 2)\n      return \\\"sti\\\\t%1,%0\\\";\n \n-   if (!TARGET_C3X && which_alternative == 3)\n+   if (! TARGET_C3X && which_alternative == 3)\n      {\n        operands[1] = GEN_INT ((INTVAL (operands[1]) >> 16) & 0xffff);\n        return \\\"ldhi\\\\t%1,%0\\\";\n      }\n \n    /* The lda instruction cannot use the same register as source\n       and destination.  */\n-   if (!TARGET_C3X && which_alternative == 1\n+   if (! TARGET_C3X && which_alternative == 1\n        && (   IS_ADDR_REG (REGNO (operands[0]))\n            || IS_INDEX_REG (REGNO (operands[0]))\n            || IS_SP_REG (REGNO (operands[0])))\n@@ -1230,20 +1230,20 @@\n    /* We shouldn't have to do this, since reload is supposed to\n       be able to do this if we have a memory constraint.  */\n    if (CONSTANT_P (operands[1])\n-       && !const_operand (operands[1], QImode))\n+       && ! const_operand (operands[1], QImode))\n      {\n         operands[1] = force_const_mem (QImode, operands[1]);\n-        if (!memory_address_p (QImode, XEXP (operands[1], 0))\n-            && !reload_in_progress)\n+        if (! memory_address_p (QImode, XEXP (operands[1], 0))\n+            && ! reload_in_progress)\n           operands[1] = change_address (operands[1], QImode,\n                                         XEXP (operands[1], 0));\n      }\n \n-   if (!reload_in_progress\n-       && !reg_operand (operands[0], QImode) \n-       && !reg_operand (operands[1], QImode)\n-       && !(stik_const_operand (operands[1], QImode) \n-            && !push_operand (operands[0], QImode)))\n+   if (! reload_in_progress\n+       && ! reg_operand (operands[0], QImode) \n+       && ! reg_operand (operands[1], QImode)\n+       && ! (stik_const_operand (operands[1], QImode) \n+            && ! push_operand (operands[0], QImode)))\n      operands[1] = force_reg (QImode, operands[1]);\")\n \n (define_insn \"*movqi_update\"\n@@ -2051,7 +2051,7 @@\n            (sign_extend:HI (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,JR,rS<>,g\")))\n       (const_int 32))))\n    (clobber (reg:CC_NOOV 21))]\n-  \"!TARGET_C3X && valid_operands (MULT, operands, QImode)\"\n+  \"! TARGET_C3X && valid_operands (MULT, operands, QImode)\"\n   \"@\n    mpyshi3\\\\t%2,%1,%0\n    mpyshi3\\\\t%2,%1,%0\n@@ -2092,7 +2092,7 @@\n            (zero_extend:HI (match_operand:QI 2 \"lsrc_operand\" \"JR,rS<>,g,JR,rS<>,g\")))\n           (const_int 32))))\n    (clobber (reg:CC_NOOV 21))]\n-  \"!TARGET_C3X && valid_operands (MULT, operands, QImode)\"\n+  \"! TARGET_C3X && valid_operands (MULT, operands, QImode)\"\n   \"@\n    mpyuhi3\\\\t%2,%1,%0\n    mpyuhi3\\\\t%2,%1,%0\n@@ -2675,7 +2675,7 @@\n                                     (match_operand:QI 2 \"const_int_operand\" \"\")\n                                     (match_operand:QI 3 \"const_int_operand\" \"\")))\n               (clobber (reg:CC 21))])]\n- \"!TARGET_C3X\"\n+ \"! TARGET_C3X\"\n  \"if ((INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16)\n       || (INTVAL (operands[3]) % INTVAL (operands[2]) != 0))\n         FAIL;\n@@ -2687,7 +2687,7 @@\n                          (match_operand:QI 2 \"const_int_operand\" \"n,n\")\n                          (match_operand:QI 3 \"const_int_operand\" \"n,n\")))\n    (clobber (reg:CC 21))]\n-  \"!TARGET_C3X\n+  \"! TARGET_C3X\n    && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n    && (INTVAL (operands[3]) % INTVAL (operands[2]) == 0)\"\n   \"*\n@@ -2709,7 +2709,7 @@\n                                      (match_operand:QI 3 \"const_int_operand\" \"n\"))\n    \t\t    (const_int 0)))\n    (clobber (match_scratch:QI 0 \"=d\"))]\n-  \"!TARGET_C3X\n+  \"! TARGET_C3X\n    && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n    && (INTVAL (operands[3]) % INTVAL (operands[2]) == 0)\"\n   \"*\n@@ -2734,7 +2734,7 @@\n         (sign_extract:QI (match_dup 1)\n                          (match_dup 2)\n                          (match_dup 3)))]\n-  \"!TARGET_C3X\n+  \"! TARGET_C3X\n    && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n    && (INTVAL (operands[3]) % INTVAL (operands[2]) == 0)\"\n   \"*\n@@ -2758,7 +2758,7 @@\n                                     (match_operand:QI 2 \"const_int_operand\" \"\")\n                                     (match_operand:QI 3 \"const_int_operand\" \"\")))\n               (clobber (reg:CC 21))])]\n- \"!TARGET_C3X\"\n+ \"! TARGET_C3X\"\n  \"if ((INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16)\n       || (INTVAL (operands[3]) % INTVAL (operands[2]) != 0))\n         FAIL;\n@@ -2770,7 +2770,7 @@\n                          (match_operand:QI 2 \"const_int_operand\" \"n,n\")\n                          (match_operand:QI 3 \"const_int_operand\" \"n,n\")))\n    (clobber (reg:CC 21))]\n-  \"!TARGET_C3X\n+  \"! TARGET_C3X\n    && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n    && (INTVAL (operands[3]) % INTVAL (operands[2]) == 0)\"\n   \"*\n@@ -2792,7 +2792,7 @@\n                                      (match_operand:QI 3 \"const_int_operand\" \"n\"))\n    \t\t    (const_int 0)))\n    (clobber (match_scratch:QI 0 \"=d\"))]\n-  \"!TARGET_C3X\n+  \"! TARGET_C3X\n    && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n    && (INTVAL (operands[3]) % INTVAL (operands[2]) == 0)\"\n   \"*\n@@ -2817,7 +2817,7 @@\n         (zero_extract:QI (match_dup 1)\n                          (match_dup 2)\n                          (match_dup 3)))]\n-  \"!TARGET_C3X\n+  \"! TARGET_C3X\n    && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n    && (INTVAL (operands[3]) % INTVAL (operands[2]) == 0)\"\n   \"*\n@@ -2841,8 +2841,8 @@\n                                     (match_operand:QI 2 \"const_int_operand\" \"\"))\n                    (match_operand:QI 3 \"src_operand\" \"\"))\n               (clobber (reg:CC 21))])]\n- \"!TARGET_C3X\"\n- \"if (!(((INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n+ \"! TARGET_C3X\"\n+ \"if (! (((INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n          && (INTVAL (operands[2]) % INTVAL (operands[1]) == 0))\n         || (INTVAL (operands[1]) == 24 && INTVAL (operands[2]) == 8)))\n     FAIL;\n@@ -2854,7 +2854,7 @@\n                          (match_operand:QI 2 \"const_int_operand\" \"n,n\"))\n         (match_operand:QI 3 \"src_operand\" \"g,g\"))\n    (clobber (reg:CC 21))]\n-  \"!TARGET_C3X\n+  \"! TARGET_C3X\n    && (((INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n         && (INTVAL (operands[2]) % INTVAL (operands[1]) == 0))\n        || (INTVAL (operands[1]) == 24 && INTVAL (operands[2]) == 8))\"\n@@ -2882,7 +2882,7 @@\n \t      (clobber (reg:CC 21))])\n    (set (reg:CC 21)\n         (compare:CC (match_dup 0) (const_int 0)))]\n-  \"!TARGET_C3X\n+  \"! TARGET_C3X\n    && (INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n    && (INTVAL (operands[2]) % INTVAL (operands[1]) == 0)\"\n   \"*\n@@ -2914,18 +2914,18 @@\n         (match_operand:QF 1 \"src_operand\" \"\"))]\n  \"\"\n  \"\n-  if (CONSTANT_P (operands[1]) && !const_operand (operands[1], QFmode))\n+  if (CONSTANT_P (operands[1]) && ! const_operand (operands[1], QFmode))\n     {\n       operands[1] = force_const_mem (QFmode, operands[1]);\n-      if (!memory_address_p (QFmode, XEXP (operands[1], 0))\n-          && !reload_in_progress)\n+      if (! memory_address_p (QFmode, XEXP (operands[1], 0))\n+          && ! reload_in_progress)\n         operands[1] = change_address (operands[1], QFmode,\n                                       XEXP (operands[1], 0));\n     }\n \n-  if (!reload_in_progress\n-      && !reg_operand (operands[0], QFmode)\n-      && !reg_operand (operands[1], QFmode))\n+  if (! reload_in_progress\n+      && ! reg_operand (operands[0], QFmode)\n+      && ! reg_operand (operands[1], QFmode))\n     operands[1] = force_reg (QFmode, operands[1]);\n  \")\n \n@@ -3237,7 +3237,7 @@\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n         (unspec [(match_operand:QF 1 \"src_operand\" \"fmH\")] 5))\n    (clobber (reg:CC_NOOV 21))]\n-  \"!TARGET_C3X\"\n+  \"! TARGET_C3X\"\n   \"rcpf\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n@@ -3248,7 +3248,7 @@\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n         (unspec [(match_operand:QF 1 \"src_operand\" \"fmH\")] 10))\n    (clobber (reg:CC_NOOV 21))]\n-  \"!TARGET_C3X\"\n+  \"! TARGET_C3X\"\n   \"rsqrf\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n@@ -3259,7 +3259,7 @@\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n         (unspec [(match_operand:QF 1 \"src_operand\" \"fmH\")] 6))\n    (clobber (reg:CC_NOOV 21))]\n-  \"!TARGET_C3X\"\n+  \"! TARGET_C3X\"\n   \"rnd\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n@@ -3292,9 +3292,9 @@\n    (parallel [(set (match_operand:QF 0 \"reg_operand\" \"\")\n \t           (unspec [(match_dup 4)] 6))\n \t      (clobber (reg:CC_NOOV 21))])]\n-  \"!TARGET_C3X\"\n-  \"if (!reload_in_progress\n-       && !reg_operand (operands[1], QFmode))\n+  \"! TARGET_C3X\"\n+  \"if (! reload_in_progress\n+       && ! reg_operand (operands[1], QFmode))\n      operands[1] = force_reg (QFmode, operands[1]);\n    operands[2] = gen_reg_rtx (QFmode);\n    operands[3] = gen_reg_rtx (QFmode);\n@@ -3309,7 +3309,7 @@\n                    (sqrt:QF (match_operand:QF 1 \"src_operand\" \"\")))\n               (clobber (reg:CC 21))])]\n   \"\"\n-  \"if (TARGET_C3X || !TARGET_INLINE)\n+  \"if (TARGET_C3X || ! TARGET_INLINE)\n      FAIL;\n    else\n      {\n@@ -3537,9 +3537,9 @@\n    (parallel [(set (match_operand:QF 0 \"reg_operand\" \"\")\n \t           (unspec [(match_dup 3)] 6))\n \t      (clobber (reg:CC_NOOV 21))])]\n-  \"!TARGET_C3X\"\n-  \"if (!reload_in_progress\n-      && !reg_operand (operands[2], QFmode))\n+  \"! TARGET_C3X\"\n+  \"if (! reload_in_progress\n+      && ! reg_operand (operands[2], QFmode))\n      operands[2] = force_reg (QFmode, operands[2]);\n    operands[3] = gen_reg_rtx (QFmode);\n    operands[4] = gen_reg_rtx (QFmode);\n@@ -3551,7 +3551,7 @@\n                             (match_operand:QF 2 \"src_operand\" \"\")))\n               (clobber (reg:CC 21))])]\n   \"\"\n-  \"if (TARGET_C3X || !TARGET_INLINE)\n+  \"if (TARGET_C3X || ! TARGET_INLINE)\n      {\n        c4x_emit_libcall3 (DIVQF3_LIBCALL, DIV, QFmode, operands);\n        DONE;\n@@ -4339,7 +4339,7 @@\n   (clobber (reg:QI 31))]\n   ;; Operand 1 not really used on the C4x.\n \n-  \"!TARGET_C3X\"\n+  \"! TARGET_C3X\"\n   \"*\n    if (which_alternative == 0)\n      {\n@@ -4386,7 +4386,7 @@\n   (clobber (reg:QI 31))]\n   ;; Operand 0 and 2 not really used in the C30 instruction.\n \n-  \"!TARGET_C3X\"\n+  \"! TARGET_C3X\"\n   \"*\n    if (which_alternative == 0)\n      {\n@@ -4553,7 +4553,7 @@\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n   \"*\n-   return !final_sequence && c4x_rptb_rpts_p (insn, operands[0])\n+   return ! final_sequence && c4x_rptb_rpts_p (insn, operands[0])\n \t ? \\\"rpts\\\\trc\\\" : \\\"rptb%#\\\\t%l1-1\\\";\n   \"\n   [(set_attr \"type\" \"repeat_top\")])\n@@ -4809,15 +4809,15 @@\n  \"if (CONSTANT_P (operands[1]))\n     {\n       operands[1] = force_const_mem (HFmode, operands[1]); \n-      if (!memory_address_p (HFmode, XEXP (operands[1], 0))\n-          && !reload_in_progress)\n+      if (! memory_address_p (HFmode, XEXP (operands[1], 0))\n+          && ! reload_in_progress)\n         operands[1] = change_address (operands[1], HFmode,\n                                       XEXP (operands[1], 0));\n      }\n \n   /* Memory to memory copies must go through a register.  */\n   if (GET_CODE (operands[1]) == MEM && GET_CODE (operands[0]) == MEM\n-      && !reload_in_progress)\n+      && ! reload_in_progress)\n     operands[1] = force_reg (HFmode, operands[1]); \n \")\n \n@@ -5104,7 +5104,7 @@\n   [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n         (unspec [(match_operand:HF 1 \"reg_or_const_operand\" \"hH\")] 5))\n    (clobber (reg:CC_NOOV 21))]\n-  \"!TARGET_C3X\"\n+  \"! TARGET_C3X\"\n   \"rcpf\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n@@ -5115,7 +5115,7 @@\n   [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n         (unspec [(match_operand:HF 1 \"reg_or_const_operand\" \"hH\")] 10))\n    (clobber (reg:CC_NOOV 21))]\n-  \"!TARGET_C3X\"\n+  \"! TARGET_C3X\"\n   \"rsqrf\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n@@ -5126,7 +5126,7 @@\n   [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n         (unspec [(match_operand:HF 1 \"reg_or_const_operand\" \"hH\")] 6))\n    (clobber (reg:CC_NOOV 21))]\n-  \"!TARGET_C3X\"\n+  \"! TARGET_C3X\"\n   \"rnd\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n@@ -5157,7 +5157,7 @@\n    (parallel [(set (match_operand:HF 0 \"reg_operand\" \"\")\n \t\t   (mult:HF (match_dup 2) (match_dup 1)))\n \t      (clobber (reg:CC_NOOV 21))])]\n-  \"!TARGET_C3X\"\n+  \"! TARGET_C3X\"\n   \"\n   operands[2] = gen_reg_rtx (HFmode);\n   operands[3] = gen_reg_rtx (HFmode);\n@@ -5172,7 +5172,7 @@\n                    (sqrt:HF (match_operand:HF 1 \"reg_operand\" \"\")))\n               (clobber (reg:CC 21))])]\n   \"\"\n-  \"if (TARGET_C3X || !TARGET_INLINE)\n+  \"if (TARGET_C3X || ! TARGET_INLINE)\n      FAIL;\n    else\n      {\n@@ -5309,7 +5309,7 @@\n \t\t   (mult:HF (match_operand:HF 1 \"reg_operand\" \"\")\n \t         \t    (match_dup 3)))\n \t      (clobber (reg:CC_NOOV 21))])]\n-  \"!TARGET_C3X\"\n+  \"! TARGET_C3X\"\n   \"\n   operands[3] = gen_reg_rtx (HFmode);\n   operands[4] = gen_reg_rtx (HFmode);\n@@ -5322,7 +5322,7 @@\n                            (match_operand:HF 2 \"reg_operand\" \"\")))\n               (clobber (reg:CC 21))])]\n   \"\"\n-  \"if (TARGET_C3X || !TARGET_INLINE)\n+  \"if (TARGET_C3X || ! TARGET_INLINE)\n      {\n        c4x_emit_libcall3 (DIVHF3_LIBCALL, DIV, HFmode, operands);\n        DONE;\n@@ -5350,15 +5350,15 @@\n       /* We don't need to force all constants into memory.\n          This could be improved.... */\n       operands[1] = force_const_mem (HImode, operands[1]); \n-      if (!memory_address_p (HImode, XEXP (operands[1], 0))\n-          && !reload_in_progress)\n+      if (! memory_address_p (HImode, XEXP (operands[1], 0))\n+          && ! reload_in_progress)\n         operands[1] = change_address (operands[1], HImode,\n                                       XEXP (operands[1], 0));\n      }\n \n   /* Memory to memory copies must go through a register.  */\n   if (GET_CODE (operands[1]) == MEM && GET_CODE (operands[0]) == MEM\n-      && !reload_in_progress)\n+      && ! reload_in_progress)\n     operands[1] = force_reg (HImode, operands[1]); \n \")\n \n@@ -5411,7 +5411,7 @@\n   [(set (match_operand:HI 0 \"reg_operand\" \"=?dc\")\n         (sign_extend:HI (match_operand:QI 1 \"src_operand\" \"g\")))\n    (clobber (reg:CC 21))]\n-  \"reload_completed && !TARGET_C3X\"\n+  \"reload_completed && ! TARGET_C3X\"\n   [(set (match_dup 2) (match_dup 1))\n    (parallel [(set (match_dup 3) (ashiftrt:QI (match_dup 2) (const_int 31)))\n               (clobber (reg:CC 21))])]\n@@ -5955,7 +5955,7 @@\n   [(set (reg:CC 21)\n         (compare:CC (match_operand:HI 0 \"src_operand\" \"\")\n                     (match_operand:HI 1 \"src_operand\" \"\")))]\n-  \"!reload_completed\"\n+  \"! reload_completed\"\n   [(parallel [(set (reg:CC 21)\n                    (unspec [(compare:CC (match_dup 0)\n                                         (match_dup 1))] 4))\n@@ -5967,7 +5967,7 @@\n   [(set (reg:CC_NOOV 21)\n         (compare:CC_NOOV (match_operand:HI 0 \"src_operand\" \"\")\n                          (match_operand:HI 1 \"src_operand\" \"\")))]\n-  \"!reload_completed\"\n+  \"! reload_completed\"\n   [(parallel [(set (reg:CC_NOOV 21)\n                    (unspec [(compare:CC_NOOV (match_dup 0)\n                                              (match_dup 1))] 4))\n@@ -6191,7 +6191,7 @@\n           (plus:QI (match_dup 0)\n                    (const_int -1)))\n      (clobber (reg:CC_NOOV 21))])]\n-  \"!c4x_label_conflict (insn, operands[2], operands[1])\"\n+  \"! c4x_label_conflict (insn, operands[2], operands[1])\"\n   \"db%I3\\\\t%0,%l1\\\\n\\\\tb%3\\\\t%l2\")\n \n (define_peephole\n@@ -6210,7 +6210,7 @@\n           (plus:QI (match_dup 0)\n                    (const_int -1)))\n      (clobber (reg:CC_NOOV 21))])]\n-  \"!c4x_label_conflict (insn, operands[2], operands[1])\"\n+  \"! c4x_label_conflict (insn, operands[2], operands[1])\"\n   \"db%I3\\\\t%0,%l1\\\\n\\\\tb%3\\\\t%l2\")\n \n ;\n@@ -6248,7 +6248,7 @@\n   (set (match_operand:QI 2 \"ext_low_reg_operand\" \"\")\n        (match_operand:QI 3 \"par_ind_operand\" \"\"))]\n  \"(REGNO (operands[0]) != REGNO (operands[2])) \n-  && !c4x_address_conflict (operands[1], operands[3], 0, 0)\"\n+  && ! c4x_address_conflict (operands[1], operands[3], 0, 0)\"\n  \"ldi1\\\\t%1,%0\\\\n||\\\\tldi2\\\\t%3,%2\")\n \n ; load occurs before store if 1 and 2 point to same address\n@@ -6258,7 +6258,7 @@\n   (set (match_operand:QI 2 \"par_ind_operand\" \"\")\n        (match_operand:QI 3 \"ext_low_reg_operand\" \"\"))]\n  \"(REGNO (operands[0]) != REGNO (operands[3]))\n-  && !c4x_address_conflict (operands[1], operands[2], 0, 1)\"\n+  && ! c4x_address_conflict (operands[1], operands[2], 0, 1)\"\n  \"ldi\\\\t%1,%0\\\\n||\\\\tsti\\\\t%3,%2\")\n \n ; load occurs before store if 0 and 3 point to same address\n@@ -6268,15 +6268,15 @@\n   (set (match_operand:QI 2 \"ext_low_reg_operand\" \"\")\n        (match_operand:QI 3 \"par_ind_operand\" \"\"))]\n  \"(REGNO (operands[1]) != REGNO (operands[2]))\n-  && !c4x_address_conflict (operands[0], operands[3], 1, 0)\"\n+  && ! c4x_address_conflict (operands[0], operands[3], 1, 0)\"\n  \"ldi\\\\t%3,%2\\\\n||\\\\tsti\\\\t%1,%0\")\n \n (define_peephole\n  [(set (match_operand:QI 0 \"par_ind_operand\" \"\")\n        (match_operand:QI 1 \"ext_low_reg_operand\" \"\"))\n   (set (match_operand:QI 2 \"par_ind_operand\" \"\")\n        (match_operand:QI 3 \"ext_low_reg_operand\" \"\"))]\n- \"!c4x_address_conflict (operands[0], operands[2], 1, 1)\"\n+ \"! c4x_address_conflict (operands[0], operands[2], 1, 1)\"\n  \"sti\\\\t%1,%0\\\\n||\\\\tsti\\\\t%3,%2\")\n \n ; This peephole should be unnecessary with my patches to flow.c\n@@ -6297,7 +6297,7 @@\n   (set (match_operand:QF 2 \"ext_low_reg_operand\" \"\")\n        (match_operand:QF 3 \"par_ind_operand\" \"\"))]\n  \"(REGNO (operands[0]) != REGNO (operands[2]))\n-  && !c4x_address_conflict (operands[1], operands[3], 0, 1)\"\n+  && ! c4x_address_conflict (operands[1], operands[3], 0, 1)\"\n  \"ldf1\\\\t%1,%0\\\\n||\\\\tldf2\\\\t%3,%2\")\n \n ; This peephole should be unnecessary with my patches to flow.c\n@@ -6325,15 +6325,15 @@\n        (match_operand:QF 1 \"ext_low_reg_operand\" \"\"))\n   (set (match_operand:QF 2 \"ext_low_reg_operand\" \"\")\n        (match_operand:QF 3 \"par_ind_operand\" \"\"))]\n- \"!c4x_address_conflict (operands[0], operands[3], 1, 1)\"\n+ \"! c4x_address_conflict (operands[0], operands[3], 1, 1)\"\n  \"ldf\\\\t%3,%2\\\\n||\\\\tstf\\\\t%1,%0\")\n \n (define_peephole\n  [(set (match_operand:QF 0 \"par_ind_operand\" \"\")\n        (match_operand:QF 1 \"ext_low_reg_operand\" \"\"))\n   (set (match_operand:QF 2 \"par_ind_operand\" \"\")\n        (match_operand:QF 3 \"ext_low_reg_operand\" \"\"))]\n- \"!c4x_address_conflict (operands[0], operands[2], 1, 1)\"\n+ \"! c4x_address_conflict (operands[0], operands[2], 1, 1)\"\n  \"stf1\\\\t%1,%0\\\\n||\\\\tstf2\\\\t%3,%2\")\n \n (define_peephole"}]}