{"sha": "749a2da1bae8c0c91746d37b330626485566b308", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ5YTJkYTFiYWU4YzBjOTE3NDZkMzdiMzMwNjI2NDg1NTY2YjMwOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-04-18T18:14:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-04-18T18:14:10Z"}, "message": "c-decl.c (mark_binding_level): Use 'for' instead of `while'.\n\n\t* c-decl.c (mark_binding_level): Use 'for' instead of `while'.\n\t* conflict.c: Minor cleanups.\n\t* optabs.c: Add blank line\n\t* simplify-rtx.c:\n\nFrom-SVN: r33226", "tree": {"sha": "3b114c4a2f0a4500d5c382d1a3fa41ad85ca34be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b114c4a2f0a4500d5c382d1a3fa41ad85ca34be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/749a2da1bae8c0c91746d37b330626485566b308", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749a2da1bae8c0c91746d37b330626485566b308", "html_url": "https://github.com/Rust-GCC/gccrs/commit/749a2da1bae8c0c91746d37b330626485566b308", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749a2da1bae8c0c91746d37b330626485566b308/comments", "author": null, "committer": null, "parents": [{"sha": "83c1f6283efe9b71a6ea71a3761aa2110214be5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83c1f6283efe9b71a6ea71a3761aa2110214be5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83c1f6283efe9b71a6ea71a3761aa2110214be5b"}], "stats": {"total": 504, "additions": 274, "deletions": 230}, "files": [{"sha": "7c53d5b9fcb1a7df3a08b4dfcb468a3219b5ff37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749a2da1bae8c0c91746d37b330626485566b308/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749a2da1bae8c0c91746d37b330626485566b308/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=749a2da1bae8c0c91746d37b330626485566b308", "patch": "@@ -1,3 +1,10 @@\n+Tue Apr 18 14:16:47 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* c-decl.c (mark_binding_level): Use 'for' instead of `while'.\n+\t* conflict.c: Minor cleanups.\n+\t* optabs.c: Add blank line\n+\t* simplify-rtx.c: \n+\n 2000-04-17  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cppexp.c (lex): Don't assume tokens are NUL terminated."}, {"sha": "4d175cb36dea34d877358db5e2dbc335b4f9fc5a", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749a2da1bae8c0c91746d37b330626485566b308/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749a2da1bae8c0c91746d37b330626485566b308/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=749a2da1bae8c0c91746d37b330626485566b308", "patch": "@@ -2860,21 +2860,21 @@ lookup_name_current_level (name)\n }\n \f\n /* Mark ARG for GC.  */\n+\n static void \n mark_binding_level (arg)\n      void *arg;\n {\n   struct binding_level *level = *(struct binding_level **) arg;\n \n-  while (level)\n+  for (; level != 0; level = level->level_chain)\n     {\n       ggc_mark_tree (level->names);\n       ggc_mark_tree (level->tags);\n       ggc_mark_tree (level->shadowed);\n       ggc_mark_tree (level->blocks);\n       ggc_mark_tree (level->this_block);\n       ggc_mark_tree (level->parm_order);\n-      level = level->level_chain;\n     }\n }\n "}, {"sha": "7ba50cc3c4147f3985ab4d6ec41b0bb4c1dd6af2", "filename": "gcc/conflict.c", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749a2da1bae8c0c91746d37b330626485566b308/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749a2da1bae8c0c91746d37b330626485566b308/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=749a2da1bae8c0c91746d37b330626485566b308", "patch": "@@ -2,22 +2,22 @@\n    Copyright (C) 2000 Free Software Foundation, Inc.\n    Contributed by CodeSourcery, LLC\n \n-   This file is part of GNU CC.\n+This file is part of GNU CC.\n \n-   GNU CC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-   GNU CC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n \n-   You should have received a copy of the GNU General Public License\n-   along with GNU CC; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n \n /* References:\n \n@@ -27,7 +27,6 @@\n \n #include \"config.h\"\n #include \"system.h\"\n-\n #include \"obstack.h\"\n #include \"hashtab.h\"\n #include \"rtl.h\"\n@@ -108,23 +107,18 @@ struct conflict_graph_def\n \n /* The initial capacity (number of conflict arcs) for newly-created\n    conflict graphs.  */\n-#define INITIAL_ARC_CAPACITY (64)\n+#define INITIAL_ARC_CAPACITY 64\n \n \n /* Computes the hash value of the conflict graph arc connecting regs\n-   R1__ and R2__.  R1__ is assumed to be smaller or equal to R2__.  */\n-#define CONFLICT_HASH_FN(r1__, r2__) ((r2__) * ((r2__) - 1) / 2 + (r1__))\n-\n-static unsigned arc_hash\n-  PARAMS ((const void *arcp));\n-static int arc_eq \n-  PARAMS ((const void *arcp1, const void *arcp2));\n-static int print_conflict\n-  PARAMS ((int reg1, int reg2, void *contextp));\n-static void mark_reg \n-  PARAMS ((rtx reg, rtx setter, void *data));\n-\n-\n+   R1 and R2.  R1 is assumed to be smaller or equal to R2.  */\n+#define CONFLICT_HASH_FN(R1, R2) ((R2) * ((R2) - 1) / 2 + (R1))\n+\n+static unsigned arc_hash\tPARAMS ((const void *));\n+static int arc_eq\t\tPARAMS ((const void *, const void *));\n+static int print_conflict\tPARAMS ((int, int, void *));\n+static void mark_reg\t\tPARAMS ((rtx, rtx, void *));\n+\f\n /* Callback function to compute the hash value of an arc.  Uses\n    current_graph to locate the graph to which the arc belongs. */\n \n@@ -133,6 +127,7 @@ arc_hash (arcp)\n      const void *arcp;\n {\n   conflict_graph_arc arc = (conflict_graph_arc) arcp;\n+\n   return CONFLICT_HASH_FN (arc->smaller, arc->larger);\n }\n \n@@ -146,6 +141,7 @@ arc_eq (arcp1, arcp2)\n {\n   conflict_graph_arc arc1 = (conflict_graph_arc) arcp1;\n   conflict_graph_arc arc2 = (conflict_graph_arc) arcp2;\n+\n   return arc1->smaller == arc2->smaller && arc1->larger == arc2->larger;\n }\n \n@@ -156,24 +152,23 @@ conflict_graph\n conflict_graph_new (num_regs)\n      int num_regs;\n {\n-  conflict_graph graph = \n-    (conflict_graph) xmalloc (sizeof (struct conflict_graph_def));\n+  conflict_graph graph\n+    = (conflict_graph) xmalloc (sizeof (struct conflict_graph_def));\n   graph->num_regs = num_regs;\n \n   /* Set up the hash table.  No delete action is specified; memory\n      management of arcs is through the obstack.  */\n-  graph->arc_hash_table = \n-    htab_create (INITIAL_ARC_CAPACITY, &arc_hash, &arc_eq, NULL);\n+  graph->arc_hash_table\n+    = htab_create (INITIAL_ARC_CAPACITY, &arc_hash, &arc_eq, NULL);\n \n   /* Create an obstack for allocating arcs.  */\n-  obstack_init (&(graph->arc_obstack));\n+  obstack_init (&graph->arc_obstack);\n \t     \n   /* Create and zero the lookup table by register number.  */\n-  graph->neighbor_heads = (conflict_graph_arc *) \n-    xmalloc (num_regs * sizeof (conflict_graph_arc));\n-  memset (graph->neighbor_heads, 0, \n-\t  num_regs * sizeof (conflict_graph_arc));\n+  graph->neighbor_heads\n+    = (conflict_graph_arc *) xmalloc (num_regs * sizeof (conflict_graph_arc));\n \n+  memset (graph->neighbor_heads, 0, num_regs * sizeof (conflict_graph_arc));\n   return graph;\n }\n \n@@ -183,7 +178,7 @@ void\n conflict_graph_delete (graph)\n      conflict_graph graph;\n {\n-  obstack_free (&(graph->arc_obstack), NULL);\n+  obstack_free (&graph->arc_obstack, NULL);\n   htab_delete (graph->arc_hash_table);\n   free (graph->neighbor_heads);\n   free (graph);\n@@ -218,10 +213,11 @@ conflict_graph_add (graph, reg1, reg2)\n     return 0;\n \n   /* Allocate an arc.  */\n-  arc = (conflict_graph_arc) \n-    obstack_alloc (&(graph->arc_obstack),\n-\t\t   sizeof (struct conflict_graph_arc_def));\n-\n+  arc\n+    = (conflict_graph_arc)\n+      obstack_alloc (&graph->arc_obstack,\n+\t\t     sizeof (struct conflict_graph_arc_def));\n+  \n   /* Record the reg numbers.  */\n   arc->smaller = smaller;\n   arc->larger = larger;\n@@ -299,6 +295,7 @@ conflict_graph_merge_regs (graph, target, src)\n   while (arc != NULL)\n     {\n       int other = arc->smaller;\n+\n       if (other == src)\n \tother = arc->larger;\n \n@@ -372,19 +369,22 @@ conflict_graph_print (graph, fp)\n {\n   int reg;\n   struct print_context context;\n-  context.fp = fp;\n \n+  context.fp = fp;\n   fprintf (fp, \"Conflicts:\\n\");\n+\n   /* Loop over registers supported in this graph.  */\n   for (reg = 0; reg < graph->num_regs; ++reg)\n     {\n       context.reg = reg;\n       context.started = 0;\n+\n       /* Scan the conflicts for reg, printing as we go.  A label for\n \t this line will be printed the first time a conflict is\n \t printed for the reg; we won't start a new line if this reg\n \t has no conflicts.  */\n       conflict_graph_enum (graph, reg, &print_conflict, &context);\n+\n       /* If this reg does have conflicts, end the line.  */\n       if (context.started)\n \tfputc ('\\n', fp);\n@@ -469,9 +469,7 @@ conflict_graph_compute (regs, p)\n       /* Walk the instruction stream backwards.  */\n       head = bb->head;\n       insn = bb->end;\n-      for (insn = bb->end; \n-\t   insn != head; \n-\t   insn = PREV_INSN (insn))\n+      for (insn = bb->end; insn != head; insn = PREV_INSN (insn))\n \t{\n \t  int born_reg;\n \t  int live_reg;\n@@ -497,20 +495,21 @@ conflict_graph_compute (regs, p)\n \n \t      /* For every reg born here, add a conflict with every other\n   \t         reg live coming into this insn.  */\n-\t      EXECUTE_IF_SET_IN_REG_SET (born, \n-\t\t\t\t\t FIRST_PSEUDO_REGISTER, \n-\t\t\t\t\t born_reg, {\n-\t\tEXECUTE_IF_SET_IN_REG_SET (live,\n-\t\t\t\t\t   FIRST_PSEUDO_REGISTER,\n-\t\t\t\t\t   live_reg, {\n-\t\t  /* Build the conflict graph in terms of canonical\n-\t\t     regnos.  */\n-\t\t  int b = partition_find (p, born_reg);\n-\t\t  int l = partition_find (p, live_reg);\n-\t\t  if (b != l)\n-\t\t    conflict_graph_add (graph, b, l);\n-\t\t});\n-\t      });\n+\t      EXECUTE_IF_SET_IN_REG_SET\n+\t\t(born, FIRST_PSEUDO_REGISTER, born_reg,\n+\t\t {\n+\t\t   EXECUTE_IF_SET_IN_REG_SET\n+\t\t     (live, FIRST_PSEUDO_REGISTER, live_reg,\n+\t\t      {\n+\t\t\t/* Build the conflict graph in terms of canonical\n+\t\t\t   regnos.  */\n+\t\t\tint b = partition_find (p, born_reg);\n+\t\t\tint l = partition_find (p, live_reg);\n+\n+\t\t\tif (b != l)\n+\t\t\t  conflict_graph_add (graph, b, l);\n+\t\t      });\n+\t\t });\n \n \t      /* Morgan's algorithm checks the operands of the insn\n \t         and adds them to the set of live regs.  Instead, we\n@@ -519,7 +518,8 @@ conflict_graph_compute (regs, p)\n \t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t\tif (REG_NOTE_KIND (link) == REG_DEAD)\n \t\t  {\n-\t\t    int regno = REGNO (XEXP (link, 0));\n+\t\t    unsigned int regno = REGNO (XEXP (link, 0));\n+\n \t\t    if (REGNO_REG_SET_P (regs, regno))\n \t\t      SET_REGNO_REG_SET (live, regno);\n \t\t  }"}, {"sha": "304eb7400d2b6f699a04e60e957faeb598f28e4e", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749a2da1bae8c0c91746d37b330626485566b308/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749a2da1bae8c0c91746d37b330626485566b308/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=749a2da1bae8c0c91746d37b330626485566b308", "patch": "@@ -3098,6 +3098,7 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align,\n    to be used for operand OPNUM of the insn, is converted from mode MODE to\n    WIDER_MODE (UNSIGNEDP determines whether it is a unsigned conversion), and\n    that it is accepted by the operand predicate.  Return the new value.  */\n+\n rtx\n prepare_operand (icode, x, opnum, mode, wider_mode, unsignedp)\n      int icode;"}, {"sha": "ffe7b240d1cebdf0dadc1167fa8e671c573a3c5c", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 203, "deletions": 167, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749a2da1bae8c0c91746d37b330626485566b308/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749a2da1bae8c0c91746d37b330626485566b308/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=749a2da1bae8c0c91746d37b330626485566b308", "patch": "@@ -1,4 +1,4 @@\n-/* Common subexpression elimination for GNU compiler.\n+/* RTL simplification functions for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000 Free Software Foundation, Inc.\n \n@@ -21,7 +21,6 @@ Boston, MA 02111-1307, USA.  */\n \n \n #include \"config.h\"\n-/* stdio.h must precede rtl.h for FFS.  */\n #include \"system.h\"\n #include <setjmp.h>\n \n@@ -94,10 +93,94 @@ Boston, MA 02111-1307, USA.  */\n    || GET_CODE (X) == ADDRESSOF)\n \n \n-static rtx simplify_plus_minus\tPARAMS ((enum rtx_code, enum machine_mode,\n-\t\t\t\t       rtx, rtx));\n-static void check_fold_consts\tPARAMS ((PTR));\n+static rtx simplify_plus_minus\t\tPARAMS ((enum rtx_code,\n+\t\t\t\t\t\t enum machine_mode, rtx, rtx));\n+static void check_fold_consts\t\tPARAMS ((PTR));\n+static int entry_and_rtx_equal_p\tPARAMS ((const void *, const void *));\n+static unsigned int get_value_hash\tPARAMS ((const void *));\n+static struct elt_list *new_elt_list\tPARAMS ((struct elt_list *,\n+\t\t\t\t\t\t cselib_val *));\n+static struct elt_loc_list *new_elt_loc_list PARAMS ((struct elt_loc_list *,\n+\t\t\t\t\t\t      rtx));\n+static void unchain_one_value\t\tPARAMS ((cselib_val *));\n+static void unchain_one_elt_list\tPARAMS ((struct elt_list **));\n+static void unchain_one_elt_loc_list\tPARAMS ((struct elt_loc_list **));\n+static void clear_table\t\t\tPARAMS ((void));\n+static int check_value_useless\t\tPARAMS ((cselib_val *));\n+static int discard_useless_locs\t\tPARAMS ((void **, void *));\n+static int discard_useless_values\tPARAMS ((void **, void *));\n+static void remove_useless_values\tPARAMS ((void));\n+static unsigned int hash_rtx\t\tPARAMS ((rtx, enum machine_mode, int));\n+static cselib_val *new_cselib_val\tPARAMS ((unsigned int,\n+\t\t\t\t\t\t enum machine_mode));\n+static void add_mem_for_addr\t\tPARAMS ((cselib_val *, cselib_val *,\n+\t\t\t\t\t\t rtx));\n+static cselib_val *cselib_lookup_mem\tPARAMS ((rtx, int));\n+static rtx cselib_subst_to_values\tPARAMS ((rtx));\n+static void cselib_invalidate_regno\tPARAMS ((unsigned int,\n+\t\t\t\t\t\t enum machine_mode));\n+static int cselib_mem_conflict_p\tPARAMS ((rtx, rtx));\n+static int cselib_invalidate_mem_1\tPARAMS ((void **, void *));\n+static void cselib_invalidate_mem\tPARAMS ((rtx));\n+static void cselib_invalidate_rtx\tPARAMS ((rtx, rtx, void *));\n+static void cselib_record_set\t\tPARAMS ((rtx, cselib_val *,\n+\t\t\t\t\t\t cselib_val *));\n+static void cselib_record_sets\t\tPARAMS ((rtx));\n+\n+/* There are three ways in which cselib can look up an rtx:\n+   - for a REG, the reg_values table (which is indexed by regno) is used\n+   - for a MEM, we recursively look up its address and then follow the\n+     addr_list of that value\n+   - for everything else, we compute a hash value and go through the hash\n+     table.  Since different rtx's can still have the same hash value,\n+     this involves walking the table entries for a given value and comparing\n+     the locations of the entries with the rtx we are looking up.  */\n+\n+/* A table that enables us to look up elts by their value.  */\n+static htab_t hash_table;\n+\n+/* This is a global so we don't have to pass this through every function.\n+   It is used in new_elt_loc_list to set SETTING_INSN.  */\n+static rtx cselib_current_insn;\n+\n+/* Every new unknown value gets a unique number.  */\n+static unsigned int next_unknown_value;\n \n+/* The number of registers we had when the varrays were last resized.  */\n+static unsigned int cselib_nregs;\n+\n+/* Count values without known locations.  Whenever this grows too big, we\n+   remove these useless values from the table.  */\n+static int n_useless_values;\n+\n+/* Number of useless values before we remove them from the hash table.  */\n+#define MAX_USELESS_VALUES 32\n+\n+/* This table maps from register number to values.  It does not contain\n+   pointers to cselib_val structures, but rather elt_lists.  The purpose is\n+   to be able to refer to the same register in different modes.  */\n+static varray_type reg_values;\n+#define REG_VALUES(I) VARRAY_ELT_LIST (reg_values, (I))\n+\n+/* We pass this to cselib_invalidate_mem to invalidate all of\n+   memory for a non-const call instruction.  */\n+static rtx callmem;\n+\n+/* Memory for our structures is allocated from this obstack.  */\n+static struct obstack cselib_obstack;\n+\n+/* Used to quickly free all memory.  */\n+static char *cselib_startobj;\n+\n+/* Caches for unused structures.  */\n+static cselib_val *empty_vals;\n+static struct elt_list *empty_elt_lists;\n+static struct elt_loc_list *empty_elt_loc_lists;\n+\n+/* Set by discard_useless_locs if it deleted the last location of any\n+   value.  */\n+static int values_became_useless;\n+\f\n /* Make a binary operation by properly ordering the operands and \n    seeing if the expression folds.  */\n \n@@ -1809,7 +1892,7 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n      enum machine_mode mode, op0_mode;\n      rtx op0, op1, op2;\n {\n-  int width = GET_MODE_BITSIZE (mode);\n+  unsigned int width = GET_MODE_BITSIZE (mode);\n \n   /* VOIDmode means \"infinite\" precision.  */\n   if (width == 0)\n@@ -1872,9 +1955,10 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n \treturn op2;\n       else if (GET_RTX_CLASS (GET_CODE (op0)) == '<' && ! side_effects_p (op0))\n \t{\n-\t  rtx temp;\n-\t  temp = simplify_relational_operation (GET_CODE (op0), op0_mode,\n-\t\t\t\t\t\tXEXP (op0, 0), XEXP (op0, 1));\n+\t  rtx temp\n+\t     = simplify_relational_operation (GET_CODE (op0), op0_mode,\n+\t\t\t\t\t      XEXP (op0, 0), XEXP (op0, 1));\n+\n \t  /* See if any simplifications were possible.  */\n \t  if (temp == const0_rtx)\n \t    return op2;\n@@ -1962,93 +2046,17 @@ simplify_rtx (x)\n     }\n }\n \f\n-static int entry_and_rtx_equal_p\tPARAMS ((const void *, const void *));\n-static unsigned int get_value_hash\tPARAMS ((const void *));\n-static struct elt_list *new_elt_list\tPARAMS ((struct elt_list *, cselib_val *));\n-static struct elt_loc_list *new_elt_loc_list\tPARAMS ((struct elt_loc_list *, rtx));\n-static void unchain_one_value\t\tPARAMS ((cselib_val *));\n-static void unchain_one_elt_list\tPARAMS ((struct elt_list **));\n-static void unchain_one_elt_loc_list\tPARAMS ((struct elt_loc_list **));\n-static void clear_table\t\t\tPARAMS ((void));\n-static int check_value_useless\t\tPARAMS ((cselib_val *));\n-static int discard_useless_locs\t\tPARAMS ((void **, void *));\n-static int discard_useless_values\tPARAMS ((void **, void *));\n-static void remove_useless_values\tPARAMS ((void));\n-static unsigned int hash_rtx\t\tPARAMS ((rtx, enum machine_mode, int));\n-static cselib_val *new_cselib_val\tPARAMS ((unsigned int,\n-\t\t\t\t\t\t enum machine_mode));\n-static void add_mem_for_addr\t\tPARAMS ((cselib_val *, cselib_val *,\n-\t\t\t\t\t\t rtx));\n-static cselib_val *cselib_lookup_mem\tPARAMS ((rtx, int));\n-static rtx cselib_subst_to_values\tPARAMS ((rtx));\n-static void cselib_invalidate_regno\tPARAMS ((unsigned int,\n-\t\t\t\t\t\t enum machine_mode));\n-static int cselib_mem_conflict_p\tPARAMS ((rtx, rtx));\n-static int cselib_invalidate_mem_1\tPARAMS ((void **, void *));\n-static void cselib_invalidate_mem\tPARAMS ((rtx));\n-static void cselib_invalidate_rtx\tPARAMS ((rtx, rtx, void *));\n-static void cselib_record_set\t\tPARAMS ((rtx, cselib_val *,\n-\t\t\t\t\t\t cselib_val *));\n-static void cselib_record_sets\t\tPARAMS ((rtx));\n-\n-/* There are three ways in which cselib can look up an rtx:\n-   - for a REG, the reg_values table (which is indexed by regno) is used\n-   - for a MEM, we recursively look up its address and then follow the\n-     addr_list of that value\n-   - for everything else, we compute a hash value and go through the hash\n-     table.  Since different rtx's can still have the same hash value,\n-     this involves walking the table entries for a given value and comparing\n-     the locations of the entries with the rtx we are looking up.  */\n-\n-/* A table that enables us to look up elts by their value.  */\n-static htab_t hash_table;\n-\n-/* This is a global so we don't have to pass this through every function.\n-   It is used in new_elt_loc_list to set SETTING_INSN.  */\n-static rtx cselib_current_insn;\n-\n-/* Every new unknown value gets a unique number.  */\n-static unsigned int next_unknown_value;\n-\n-/* The number of registers we had when the varrays were last resized.  */\n-static int cselib_nregs;\n-\n-/* Count values without known locations.  Whenever this grows too big, we\n-   remove these useless values from the table.  */\n-static int n_useless_values;\n-\n-/* Number of useless values before we remove them from the hash table.  */\n-#define MAX_USELESS_VALUES 32\n-\n-/* This table maps from register number to values.  It does not contain\n-   pointers to cselib_val structures, but rather elt_lists.  The purpose is\n-   to be able to refer to the same register in different modes.  */\n-static varray_type reg_values;\n-#define REG_VALUES(I) VARRAY_ELT_LIST (reg_values, (I))\n-\n-/* We pass this to cselib_invalidate_mem to invalidate all of\n-   memory for a non-const call instruction.  */\n-static rtx callmem;\n-\n-/* Memory for our structures is allocated from this obstack.  */\n-static struct obstack cselib_obstack;\n-\n-/* Used to quickly free all memory.  */\n-static char *cselib_startobj;\n-\n-/* Caches for unused structures.  */\n-static cselib_val *empty_vals;\n-static struct elt_list *empty_elt_lists;\n-static struct elt_loc_list *empty_elt_loc_lists;\n \n /* Allocate a struct elt_list and fill in its two elements with the\n    arguments.  */\n+\n static struct elt_list *\n new_elt_list (next, elt)\n      struct elt_list *next;\n      cselib_val *elt;\n {\n   struct elt_list *el = empty_elt_lists;\n+\n   if (el)\n     empty_elt_lists = el->next;\n   else\n@@ -2061,12 +2069,14 @@ new_elt_list (next, elt)\n \n /* Allocate a struct elt_loc_list and fill in its two elements with the\n    arguments.  */\n+\n static struct elt_loc_list *\n new_elt_loc_list (next, loc)\n      struct elt_loc_list *next;\n      rtx loc;\n {\n   struct elt_loc_list *el = empty_elt_loc_lists;\n+\n   if (el)\n     empty_elt_loc_lists = el->next;\n   else\n@@ -2080,29 +2090,34 @@ new_elt_loc_list (next, loc)\n \n /* The elt_list at *PL is no longer needed.  Unchain it and free its\n    storage.  */\n+\n static void\n unchain_one_elt_list (pl)\n      struct elt_list **pl;\n {\n   struct elt_list *l = *pl;\n+\n   *pl = l->next;\n   l->next = empty_elt_lists;\n   empty_elt_lists = l;\n }\n \n /* Likewise for elt_loc_lists.  */\n+\n static void\n unchain_one_elt_loc_list (pl)\n      struct elt_loc_list **pl;\n {\n   struct elt_loc_list *l = *pl;\n+\n   *pl = l->next;\n   l->next = empty_elt_loc_lists;\n   empty_elt_loc_lists = l;\n }\n \n /* Likewise for cselib_vals.  This also frees the addr_list associated with\n    V.  */\n+\n static void\n unchain_one_value (v)\n      cselib_val *v;\n@@ -2116,10 +2131,12 @@ unchain_one_value (v)\n \n /* Remove all entries from the hash table.  Also used during\n    initialization.  */\n+\n static void\n clear_table ()\n {\n-  int i;\n+  unsigned int i;\n+\n   for (i = 0; i < cselib_nregs; i++)\n     REG_VALUES (i) = 0;\n \n@@ -2136,25 +2153,28 @@ clear_table ()\n \n /* The equality test for our hash table.  The first argument ENTRY is a table\n    element (i.e. a cselib_val), while the second arg X is an rtx.  */\n+\n static int\n entry_and_rtx_equal_p (entry, x_arg)\n      const void *entry, *x_arg;\n {\n   struct elt_loc_list *l;\n-  const cselib_val *v = (const cselib_val *)entry;\n-  rtx x = (rtx)x_arg;\n+  const cselib_val *v = (const cselib_val *) entry;\n+  rtx x = (rtx) x_arg;\n \n   /* We don't guarantee that distinct rtx's have different hash values,\n      so we need to do a comparison.  */\n   for (l = v->locs; l; l = l->next)\n     if (rtx_equal_for_cselib_p (l->loc, x))\n       return 1;\n+\n   return 0;\n }\n \n /* The hash function for our hash table.  The value is always computed with\n    hash_rtx when adding an element; this function just extracts the hash\n    value from a cselib_val structure.  */\n+\n static unsigned int\n get_value_hash (entry)\n      const void *entry;\n@@ -2166,6 +2186,7 @@ get_value_hash (entry)\n /* If there are no more locations that hold a value, the value has become\n    useless.  See whether that is the case for V.  Return 1 if this has\n    just become useless.  */\n+\n static int\n check_value_useless (v)\n      cselib_val *v;\n@@ -2186,46 +2207,37 @@ check_value_useless (v)\n    only return true for values which point to a cselib_val whose value\n    element has been set to zero, which implies the cselib_val will be\n    removed.  */\n+\n int\n references_value_p (x, only_useless)\n      rtx x;\n      int only_useless;\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt = GET_RTX_FORMAT (code);\n-  int i;\n+  int i, j;\n \n   if (GET_CODE (x) == VALUE\n       && (! only_useless || CSELIB_VAL_PTR (x)->value == 0))\n     return 1;\n \n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  if (references_value_p (XEXP (x, i), only_useless))\n-\t    return 1;\n-\t}\n+      if (fmt[i] == 'e' && references_value_p (XEXP (x, i), only_useless))\n+\treturn 1;\n       else if (fmt[i] == 'E')\n-\t{\n-\t  int j;\n-\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (references_value_p (XVECEXP (x, i, j), only_useless))\n-\t      return 1;\n-\t}\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  if (references_value_p (XVECEXP (x, i, j), only_useless))\n+\t    return 1;\n     }\n \n   return 0;\n }\n \n-/* Set by discard_useless_locs if it deleted the last location of any\n-   value.  */\n-static int values_became_useless;\n-\n /* For all locations found in X, delete locations that reference useless\n    values (i.e. values without any location).  Called through\n    htab_traverse.  */\n+\n static int\n discard_useless_locs (x, info)\n      void **x;\n@@ -2241,6 +2253,7 @@ discard_useless_locs (x, info)\n       else\n \tp = &(*p)->next;\n     }\n+\n   if (check_value_useless (v))\n     values_became_useless = 1;\n \n@@ -2262,11 +2275,13 @@ discard_useless_values (x, info)\n       unchain_one_value (v);\n       n_useless_values--;\n     }\n+\n   return 1;\n }\n \n /* Clean out useless values (i.e. those which no longer have locations\n    associated with them) from the hash table.  */\n+\n static void\n remove_useless_values ()\n {\n@@ -2288,6 +2303,7 @@ remove_useless_values ()\n \n /* Return nonzero if we can prove that X and Y contain the same value, taking\n    our gathered information into account.  */\n+\n int\n rtx_equal_for_cselib_p (x, y)\n      rtx x, y;\n@@ -2299,12 +2315,15 @@ rtx_equal_for_cselib_p (x, y)\n   if (GET_CODE (x) == REG || GET_CODE (x) == MEM)\n     {\n       cselib_val *e = cselib_lookup (x, VOIDmode, 0);\n+\n       if (e)\n \tx = e->u.val_rtx;\n     }\n+\n   if (GET_CODE (y) == REG || GET_CODE (y) == MEM)\n     {\n       cselib_val *e = cselib_lookup (y, VOIDmode, 0);\n+\n       if (e)\n \ty = e->u.val_rtx;\n     }\n@@ -2327,8 +2346,7 @@ rtx_equal_for_cselib_p (x, y)\n \t  /* Avoid infinite recursion.  */\n \t  if (GET_CODE (t) == REG || GET_CODE (t) == MEM)\n \t    continue;\n-\n-\t  if (rtx_equal_for_cselib_p (t, y))\n+\t  else if (rtx_equal_for_cselib_p (t, y))\n \t    return 1;\n \t}\n       \n@@ -2346,16 +2364,14 @@ rtx_equal_for_cselib_p (x, y)\n \n \t  if (GET_CODE (t) == REG || GET_CODE (t) == MEM)\n \t    continue;\n-\n-\t  if (rtx_equal_for_cselib_p (x, t))\n+\t  else if (rtx_equal_for_cselib_p (x, t))\n \t    return 1;\n \t}\n       \n       return 0;\n     }\n \n-  if (GET_CODE (x) != GET_CODE (y)\n-      || GET_MODE (x) != GET_MODE (y))\n+  if (GET_CODE (x) != GET_CODE (y) || GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n   /* This won't be handled correctly by the code below.  */\n@@ -2368,6 +2384,7 @@ rtx_equal_for_cselib_p (x, y)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       int j;\n+\n       switch (fmt[i])\n \t{\n \tcase 'w':\n@@ -2431,6 +2448,7 @@ rtx_equal_for_cselib_p (x, y)\n    CREATE is nonzero, table elts are created for regs and mem.\n    MODE is used in hashing for CONST_INTs only;\n    otherwise the mode of X is used.  */\n+\n static unsigned int\n hash_rtx (x, mode, create)\n      rtx x;\n@@ -2455,26 +2473,21 @@ hash_rtx (x, mode, create)\n       e = cselib_lookup (x, GET_MODE (x), create);\n       if (! e)\n \treturn 0;\n+\n       hash += e->value;\n       return hash;\n \n     case CONST_INT:\n-      {\n-\tunsigned HOST_WIDE_INT tem = INTVAL (x);\n-\thash += ((unsigned) CONST_INT << 7) + (unsigned) mode + tem;\n-\treturn hash ? hash : CONST_INT;\n-      }\n+      hash += ((unsigned) CONST_INT << 7) + (unsigned) mode + INTVAL (x);\n+      return hash ? hash : CONST_INT;\n \n     case CONST_DOUBLE:\n       /* This is like the general case, except that it only counts\n \t the integers representing the constant.  */\n       hash += (unsigned) code + (unsigned) GET_MODE (x);\n       if (GET_MODE (x) != VOIDmode)\n \tfor (i = 2; i < GET_RTX_LENGTH (CONST_DOUBLE); i++)\n-\t  {\n-\t    unsigned HOST_WIDE_INT tem = XWINT (x, i);\n-\t    hash += tem;\n-\t  }\n+\t  hash += XWINT (x, i);\n       else\n \thash += ((unsigned) CONST_DOUBLE_LOW (x)\n \t\t + (unsigned) CONST_DOUBLE_HIGH (x));\n@@ -2517,8 +2530,8 @@ hash_rtx (x, mode, create)\n     {\n       if (fmt[i] == 'e')\n \t{\n-\t  unsigned int tem_hash;\n \t  rtx tem = XEXP (x, i);\n+\t  unsigned int tem_hash;\n \n \t  /* If we are about to do the last recursive call\n \t     needed at this level, change it into iteration.\n@@ -2528,57 +2541,63 @@ hash_rtx (x, mode, create)\n \t      x = tem;\n \t      goto repeat;\n \t    }\n+\n \t  tem_hash = hash_rtx (tem, 0, create);\n \t  if (tem_hash == 0)\n \t    return 0;\n+\n \t  hash += tem_hash;\n \t}\n       else if (fmt[i] == 'E')\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n \t  {\n \t    unsigned int tem_hash = hash_rtx (XVECEXP (x, i, j), 0, create);\n+\n \t    if (tem_hash == 0)\n \t      return 0;\n+\n \t    hash += tem_hash;\n \t  }\n       else if (fmt[i] == 's')\n \t{\n \t  const unsigned char *p = (const unsigned char *) XSTR (x, i);\n+\n \t  if (p)\n \t    while (*p)\n \t      hash += *p++;\n \t}\n       else if (fmt[i] == 'i')\n-\t{\n-\t  unsigned int tem = XINT (x, i);\n-\t  hash += tem;\n-\t}\n+\thash += XINT (x, i);\n       else if (fmt[i] == '0' || fmt[i] == 't')\n \t/* unused */;\n       else\n \tabort ();\n     }\n+\n   return hash ? hash : 1 + GET_CODE (x);\n }\n \n /* Create a new value structure for VALUE and initialize it.  The mode of the\n    value is MODE.  */\n+\n static cselib_val *\n new_cselib_val (value, mode)\n      unsigned int value;\n      enum machine_mode mode;\n {\n   cselib_val *e = empty_vals;\n+\n   if (e)\n     empty_vals = e->u.next_free;\n   else\n     e = (cselib_val *) obstack_alloc (&cselib_obstack, sizeof (cselib_val));\n+\n   if (value == 0)\n     abort ();\n+\n   e->value = value;\n   e->u.val_rtx = gen_rtx_VALUE (mode);\n   CSELIB_VAL_PTR (e->u.val_rtx) = e;\n-\n   e->addr_list = 0;\n   e->locs = 0;\n   return e;\n@@ -2587,6 +2606,7 @@ new_cselib_val (value, mode)\n /* ADDR_ELT is a value that is used as address.  MEM_ELT is the value that\n    contains the data at this address.  X is a MEM that represents the\n    value.  Update the two value structures to represent this situation.  */\n+\n static void\n add_mem_for_addr (addr_elt, mem_elt, x)\n      cselib_val *addr_elt, *mem_elt;\n@@ -2612,6 +2632,7 @@ add_mem_for_addr (addr_elt, mem_elt, x)\n \n /* Subroutine of cselib_lookup.  Return a value for X, which is a MEM rtx.\n    If CREATE, make a new one if we haven't seen it before.  */\n+\n static cselib_val *\n cselib_lookup_mem (x, create)\n      rtx x;\n@@ -2622,9 +2643,8 @@ cselib_lookup_mem (x, create)\n   cselib_val *mem_elt;\n   struct elt_list *l;\n \n-  if (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode)\n-    return 0;\n-  if (FLOAT_MODE_P (GET_MODE (x)) && flag_float_store)\n+  if (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode\n+      || (FLOAT_MODE_P (GET_MODE (x)) && flag_float_store))\n     return 0;\n \n   /* Look up the value for the address.  */\n@@ -2636,8 +2656,10 @@ cselib_lookup_mem (x, create)\n   for (l = addr->addr_list; l; l = l->next)\n     if (GET_MODE (l->elt->u.val_rtx) == GET_MODE (x))\n       return l->elt;\n+\n   if (! create)\n     return 0;\n+\n   mem_elt = new_cselib_val (++next_unknown_value, GET_MODE (x));\n   add_mem_for_addr (addr, mem_elt, x);\n   slot = htab_find_slot_with_hash (hash_table, x, mem_elt->value, 1);\n@@ -2650,6 +2672,7 @@ cselib_lookup_mem (x, create)\n    to registers and memory.\n    X isn't actually modified; if modifications are needed, new rtl is\n    allocated.  However, the return value can share rtl with X.  */\n+\n static rtx\n cselib_subst_to_values (x)\n      rtx x;\n@@ -2664,10 +2687,10 @@ cselib_subst_to_values (x)\n   switch (code)\n     {\n     case REG:\n-      i = REGNO (x);\n-      for (l = REG_VALUES (i); l; l = l->next)\n+      for (l = REG_VALUES (REGNO (x)); l; l = l->next)\n \tif (GET_MODE (l->elt->u.val_rtx) == GET_MODE (x))\n \t  return l->elt->u.val_rtx;\n+\n       abort ();\n \n     case MEM:\n@@ -2691,8 +2714,10 @@ cselib_subst_to_values (x)\n       if (fmt[i] == 'e')\n \t{\n \t  rtx t = cselib_subst_to_values (XEXP (x, i));\n+\n \t  if (t != XEXP (x, i) && x == copy)\n \t    copy = shallow_copy_rtx (x);\n+\n \t  XEXP (copy, i) = t;\n \t}\n       else if (fmt[i] == 'E')\n@@ -2702,25 +2727,30 @@ cselib_subst_to_values (x)\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n \t      rtx t = cselib_subst_to_values (XVECEXP (x, i, j));\n+\n \t      if (t != XVECEXP (x, i, j) && XVEC (x, i) == XVEC (copy, i))\n \t\t{\n \t\t  if (x == copy)\n \t\t    copy = shallow_copy_rtx (x);\n+\n \t\t  XVEC (copy, i) = rtvec_alloc (XVECLEN (x, i));\n \t\t  for (k = 0; k < j; k++)\n \t\t    XVECEXP (copy, i, k) = XVECEXP (x, i, k);\n \t\t}\n+\n \t      XVECEXP (copy, i, j) = t;\n \t    }\n \t}\n     }\n+\n   return copy;\n }\n \n /* Look up the rtl expression X in our tables and return the value it has.\n    If CREATE is zero, we return NULL if we don't know the value.  Otherwise,\n    we create a new one if possible, using mode MODE if X doesn't have a mode\n    (i.e. because it's a constant).  */\n+\n cselib_val *\n cselib_lookup (x, mode, create)\n      rtx x;\n@@ -2740,12 +2770,15 @@ cselib_lookup (x, mode, create)\n   if (GET_CODE (x) == REG)\n     {\n       struct elt_list *l;\n-      int i = REGNO (x);\n+      unsigned int i = REGNO (x);\n+\n       for (l = REG_VALUES (i); l; l = l->next)\n \tif (mode == GET_MODE (l->elt->u.val_rtx))\n \t  return l->elt;\n+\n       if (! create)\n \treturn 0;\n+\n       e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n       e->locs = new_elt_loc_list (e->locs, x);\n       REG_VALUES (i) = new_elt_list (REG_VALUES (i), e);\n@@ -2765,11 +2798,13 @@ cselib_lookup (x, mode, create)\n   slot = htab_find_slot_with_hash (hash_table, x, hashval, create);\n   if (slot == 0)\n     return 0;\n+\n   e = (cselib_val *) *slot;\n   if (e)\n     return e;\n \n   e = new_cselib_val (hashval, mode);\n+\n   /* We have to fill the slot before calling cselib_subst_to_values:\n      the hash table is inconsistent until we do so, and\n      cselib_subst_to_values will need to do lookups.  */\n@@ -2841,21 +2876,23 @@ cselib_invalidate_regno (regno, mode)\n \t\t  break;\n \t\t}\n \t    }\n+\n \t  check_value_useless (v);\n \t}\n     }\n }\n \n /* The memory at address MEM_BASE is being changed.\n    Return whether this change will invalidate VAL.  */\n+\n static int\n cselib_mem_conflict_p (mem_base, val)\n      rtx mem_base;\n      rtx val;\n {\n   enum rtx_code code;\n   const char *fmt;\n-  int i;\n+  int i, j;\n \n   code = GET_CODE (val);\n   switch (code)\n@@ -2874,10 +2911,10 @@ cselib_mem_conflict_p (mem_base, val)\n \n     case MEM:\n       if (GET_MODE (mem_base) == BLKmode\n-\t  || GET_MODE (val) == BLKmode)\n-\treturn 1;\n-      if (anti_dependence (val, mem_base))\n+\t  || GET_MODE (val) == BLKmode\n+\t  || anti_dependence (val, mem_base))\n \treturn 1;\n+\n       /* The address may contain nested MEMs.  */\n       break;\n \n@@ -2886,7 +2923,6 @@ cselib_mem_conflict_p (mem_base, val)\n     }\n \n   fmt = GET_RTX_FORMAT (code);\n-\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n@@ -2895,20 +2931,17 @@ cselib_mem_conflict_p (mem_base, val)\n \t    return 1;\n \t}\n       else if (fmt[i] == 'E')\n-\t{\n-\t  int j;\n-\n-\t  for (j = 0; j < XVECLEN (val, i); j++)\n-\t    if (cselib_mem_conflict_p (mem_base, XVECEXP (val, i, j)))\n-\t      return 1;\n-\t}\n+\tfor (j = 0; j < XVECLEN (val, i); j++)\n+\t  if (cselib_mem_conflict_p (mem_base, XVECEXP (val, i, j)))\n+\t    return 1;\n     }\n \n   return 0;\n }\n \n /* For the value found in SLOT, walk its locations to determine if any overlap\n    INFO (which is a MEM rtx).  */\n+\n static int\n cselib_invalidate_mem_1 (slot, info)\n      void **slot;\n@@ -2920,9 +2953,9 @@ cselib_invalidate_mem_1 (slot, info)\n \n   while (*p)\n     {\n+      rtx x = (*p)->loc;\n       cselib_val *addr;\n       struct elt_list **mem_chain;\n-      rtx x = (*p)->loc;\n \n       /* MEMs may occur in locations only at the top level; below\n \t that every MEM or REG is substituted by its VALUE.  */\n@@ -2945,17 +2978,21 @@ cselib_invalidate_mem_1 (slot, info)\n \t      unchain_one_elt_list (mem_chain);\n \t      break;\n \t    }\n+\n \t  mem_chain = &(*mem_chain)->next;\n \t}\n+\n       unchain_one_elt_loc_list (p);\n     }\n+\n   check_value_useless (v);\n   return 1;\n }\n \n /* Invalidate any locations in the table which are changed because of a\n    store to MEM_RTX.  If this is called because of a non-const call\n    instruction, MEM_RTX is (mem:BLK const0_rtx).  */\n+\n static void\n cselib_invalidate_mem (mem_rtx)\n      rtx mem_rtx;\n@@ -2966,16 +3003,15 @@ cselib_invalidate_mem (mem_rtx)\n /* Invalidate DEST, which is being assigned to or clobbered.  The second and\n    the third parameter exist so that this function can be passed to\n    note_stores; they are ignored.  */\n+\n static void\n cselib_invalidate_rtx (dest, ignore, data)\n      rtx dest;\n      rtx ignore ATTRIBUTE_UNUSED;\n      void *data ATTRIBUTE_UNUSED;\n {\n-  while (GET_CODE (dest) == STRICT_LOW_PART\n-\t || GET_CODE (dest) == SIGN_EXTRACT\n-\t || GET_CODE (dest) == ZERO_EXTRACT\n-\t || GET_CODE (dest) == SUBREG)\n+  while (GET_CODE (dest) == STRICT_LOW_PART || GET_CODE (dest) == SIGN_EXTRACT\n+\t || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SUBREG)\n     dest = XEXP (dest, 0);\n \n   if (GET_CODE (dest) == REG)\n@@ -3086,11 +3122,13 @@ cselib_record_sets (insn)\n }\n \n /* Record the effects of INSN.  */\n+\n void\n cselib_process_insn (insn)\n      rtx insn;\n {\n   int i;\n+  rtx x;\n \n   cselib_current_insn = insn;\n \n@@ -3111,6 +3149,7 @@ cselib_process_insn (insn)\n       cselib_current_insn = 0;\n       return;\n     }\n+\n   /* If this is a call instruction, forget anything stored in a\n      call clobbered register, or, if this is not a const call, in\n      memory.  */\n@@ -3130,26 +3169,17 @@ cselib_process_insn (insn)\n   /* Clobber any registers which appear in REG_INC notes.  We\n      could keep track of the changes to their values, but it is\n      unlikely to help.  */\n-  {\n-    rtx x;\n-\n-    for (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n-      if (REG_NOTE_KIND (x) == REG_INC)\n-\tcselib_invalidate_rtx (XEXP (x, 0), NULL_RTX, NULL);\n-  }\n+  for (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n+    if (REG_NOTE_KIND (x) == REG_INC)\n+      cselib_invalidate_rtx (XEXP (x, 0), NULL_RTX, NULL);\n #endif\n \n   /* Look for any CLOBBERs in CALL_INSN_FUNCTION_USAGE, but only\n      after we have processed the insn.  */\n   if (GET_CODE (insn) == CALL_INSN)\n-    {\n-      rtx x;\n-\n-      for (x = CALL_INSN_FUNCTION_USAGE (insn); x; x = XEXP (x, 1))\n-\tif (GET_CODE (XEXP (x, 0)) == CLOBBER)\n-\t  cselib_invalidate_rtx (XEXP (XEXP (x, 0), 0), NULL_RTX,\n-\t\t\t\t     NULL);\n-    }\n+    for (x = CALL_INSN_FUNCTION_USAGE (insn); x; x = XEXP (x, 1))\n+      if (GET_CODE (XEXP (x, 0)) == CLOBBER)\n+\tcselib_invalidate_rtx (XEXP (XEXP (x, 0), 0), NULL_RTX, NULL);\n \n   cselib_current_insn = 0;\n \n@@ -3159,25 +3189,30 @@ cselib_process_insn (insn)\n \n /* Make sure our varrays are big enough.  Not called from any cselib routines;\n    it must be called by the user if it allocated new registers.  */\n+\n void\n cselib_update_varray_sizes ()\n {\n-  int nregs = max_reg_num ();\n+  unsigned int nregs = max_reg_num ();\n+\n   if (nregs == cselib_nregs)\n     return;\n+\n   cselib_nregs = nregs;\n   VARRAY_GROW (reg_values, nregs);\n }\n \n /* Initialize cselib for one pass.  The caller must also call\n    init_alias_analysis.  */\n+\n void\n cselib_init ()\n {\n   /* These are only created once.  */\n   if (! callmem)\n     {\n       extern struct obstack permanent_obstack;\n+\n       gcc_obstack_init (&cselib_obstack);\n       cselib_startobj = obstack_alloc (&cselib_obstack, 0);\n \n@@ -3194,6 +3229,7 @@ cselib_init ()\n }\n \n /* Called when the current user is done with cselib.  */\n+\n void\n cselib_finish ()\n {"}]}