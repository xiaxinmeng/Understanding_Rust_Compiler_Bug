{"sha": "7df3693f745eb909aacd710613811e5951e8af3b", "node_id": "C_kwDOANBUbNoAKDdkZjM2OTNmNzQ1ZWI5MDlhYWNkNzEwNjEzODExZTU5NTFlOGFmM2I", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-01T20:49:32Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-04T07:32:41Z"}, "message": "Convert nonzero mask in irange to wide_int.\n\nThe reason the nonzero mask was kept in a tree was basically inertia,\nas everything in irange is a tree.  However, there's no need to keep\nit in a tree, as the conversions to and from wide ints are very\nannoying.  That, plus special casing NULL masks to be -1 is prone\nto error.\n\nI have not only rewritten all the uses to assume a wide int, but\nhave corrected a few places where we weren't propagating the masks, or\nrather pessimizing them to -1.  This will become more important in\nupcoming patches where we make better use of the masks.\n\nPerformance testing shows a trivial improvement in VRP, as things like\nirange::contains_p() are tied to a tree.  Ughh, can't wait for trees in\niranges to go away.\n\ngcc/ChangeLog:\n\n\t* value-range-storage.cc (irange_storage_slot::set_irange): Remove\n\tspecial case.\n\t* value-range.cc (irange::irange_set): Adjust for nonzero mask\n\tbeing a wide int.\n\t(irange::irange_set_anti_range): Same.\n\t(irange::set): Same.\n\t(irange::verify_range): Same.\n\t(irange::legacy_equal_p): Same.\n\t(irange::operator==): Same.\n\t(irange::contains_p): Same.\n\t(irange::legacy_intersect): Same.\n\t(irange::legacy_union): Same.\n\t(irange::irange_single_pair_union): Call union_nonzero_bits.\n\t(irange::irange_union): Same.\n\t(irange::irange_intersect): Call intersect_nonzero_bits.\n\t(irange::intersect): Adjust for nonzero mask being a wide int.\n\t(irange::invert): Same.\n\t(irange::set_nonzero_bits): Same.\n\t(irange::get_nonzero_bits_from_range): New.\n\t(irange::set_range_from_nonzero_bits): New.\n\t(irange::get_nonzero_bits): Adjust for nonzero mask being a wide\n\tint.\n\t(irange::intersect_nonzero_bits): Same.\n\t(irange::union_nonzero_bits): Same.\n\t(range_tests_nonzero_bits): Remove test.\n\t* value-range.h (irange::varying_compatible_p): Adjust for nonzero\n\tmask being a wide int.\n\t(gt_ggc_mx): Same.\n\t(gt_pch_nx): Same.\n\t(irange::set_undefined): Same.\n\t(irange::set_varying): Same.\n\t(irange::normalize_kind): Same.", "tree": {"sha": "5aa54b944b86540d269c31a752f910d31e6301ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5aa54b944b86540d269c31a752f910d31e6301ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7df3693f745eb909aacd710613811e5951e8af3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df3693f745eb909aacd710613811e5951e8af3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7df3693f745eb909aacd710613811e5951e8af3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df3693f745eb909aacd710613811e5951e8af3b/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f50d103183c551c7f9f9f20efaf2ebbf83d5e99f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f50d103183c551c7f9f9f20efaf2ebbf83d5e99f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f50d103183c551c7f9f9f20efaf2ebbf83d5e99f"}], "stats": {"total": 301, "additions": 130, "deletions": 171}, "files": [{"sha": "6e05462283012d8ea8b1fab8f0bc8a7f301dbcf1", "filename": "gcc/value-range-storage.cc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df3693f745eb909aacd710613811e5951e8af3b/gcc%2Fvalue-range-storage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df3693f745eb909aacd710613811e5951e8af3b/gcc%2Fvalue-range-storage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.cc?ref=7df3693f745eb909aacd710613811e5951e8af3b", "patch": "@@ -150,11 +150,7 @@ irange_storage_slot::set_irange (const irange &r)\n {\n   gcc_checking_assert (fits_p (r));\n \n-  // Avoid calling unsupported get_nonzero_bits on legacy.\n-  if (r.legacy_mode_p ())\n-    m_ints[0] = -1;\n-  else\n-    m_ints[0] = r.get_nonzero_bits ();\n+  m_ints[0] = r.get_nonzero_bits ();\n \n   unsigned pairs = r.num_pairs ();\n   for (unsigned i = 0; i < pairs; ++i)"}, {"sha": "afb26a4008386c1753cbd359b28d3bfe97d5baba", "filename": "gcc/value-range.cc", "status": "modified", "additions": 118, "deletions": 152, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df3693f745eb909aacd710613811e5951e8af3b/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df3693f745eb909aacd710613811e5951e8af3b/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=7df3693f745eb909aacd710613811e5951e8af3b", "patch": "@@ -940,7 +940,7 @@ irange::irange_set (tree min, tree max)\n   m_base[1] = max;\n   m_num_ranges = 1;\n   m_kind = VR_RANGE;\n-  m_nonzero_mask = NULL;\n+  m_nonzero_mask = wi::shwi (-1, TYPE_PRECISION (TREE_TYPE (min)));\n   normalize_kind ();\n \n   if (flag_checking)\n@@ -1014,7 +1014,7 @@ irange::irange_set_anti_range (tree min, tree max)\n     }\n \n   m_kind = VR_RANGE;\n-  m_nonzero_mask = NULL;\n+  m_nonzero_mask = wi::shwi (-1, TYPE_PRECISION (TREE_TYPE (min)));\n   normalize_kind ();\n \n   if (flag_checking)\n@@ -1071,7 +1071,7 @@ irange::set (tree min, tree max, value_range_kind kind)\n       m_base[0] = min;\n       m_base[1] = max;\n       m_num_ranges = 1;\n-      m_nonzero_mask = NULL;\n+      m_nonzero_mask = wi::shwi (-1, TYPE_PRECISION (TREE_TYPE (min)));\n       return;\n     }\n \n@@ -1121,7 +1121,7 @@ irange::set (tree min, tree max, value_range_kind kind)\n   m_base[0] = min;\n   m_base[1] = max;\n   m_num_ranges = 1;\n-  m_nonzero_mask = NULL;\n+  m_nonzero_mask = wi::shwi (-1, TYPE_PRECISION (TREE_TYPE (min)));\n   normalize_kind ();\n   if (flag_checking)\n     verify_range ();\n@@ -1136,14 +1136,11 @@ irange::verify_range ()\n   if (m_kind == VR_UNDEFINED)\n     {\n       gcc_checking_assert (m_num_ranges == 0);\n-      gcc_checking_assert (!m_nonzero_mask);\n       return;\n     }\n-  if (m_nonzero_mask)\n-    gcc_checking_assert (wi::to_wide (m_nonzero_mask) != -1);\n   if (m_kind == VR_VARYING)\n     {\n-      gcc_checking_assert (!m_nonzero_mask);\n+      gcc_checking_assert (m_nonzero_mask == -1);\n       gcc_checking_assert (m_num_ranges == 1);\n       gcc_checking_assert (varying_compatible_p ());\n       return;\n@@ -1238,7 +1235,7 @@ irange::legacy_equal_p (const irange &other) const\n \t\t\t       other.tree_lower_bound (0))\n \t  && vrp_operand_equal_p (tree_upper_bound (0),\n \t\t\t\t  other.tree_upper_bound (0))\n-\t  && vrp_operand_equal_p (m_nonzero_mask, other.m_nonzero_mask));\n+\t  && get_nonzero_bits () == other.get_nonzero_bits ());\n }\n \n bool\n@@ -1273,7 +1270,7 @@ irange::operator== (const irange &other) const\n \t  || !operand_equal_p (ub, ub_other, 0))\n \treturn false;\n     }\n-  return vrp_operand_equal_p (m_nonzero_mask, other.m_nonzero_mask);\n+  return get_nonzero_bits () == other.get_nonzero_bits ();\n }\n \n /* Return TRUE if this is a symbolic range.  */\n@@ -1416,10 +1413,11 @@ irange::contains_p (tree cst) const\n \n   gcc_checking_assert (TREE_CODE (cst) == INTEGER_CST);\n \n-  if (m_nonzero_mask)\n+  // See if we can exclude CST based on the nonzero bits.\n+  if (m_nonzero_mask != -1)\n     {\n       wide_int cstw = wi::to_wide (cst);\n-      if (cstw != 0 && wi::bit_and (wi::to_wide (m_nonzero_mask), cstw) == 0)\n+      if (cstw != 0 && wi::bit_and (m_nonzero_mask, cstw) == 0)\n \treturn false;\n     }\n \n@@ -1878,9 +1876,6 @@ irange::legacy_intersect (irange *vr0, const irange *vr1)\n   intersect_ranges (&vr0kind, &vr0min, &vr0max,\n \t\t    vr1->kind (), vr1->min (), vr1->max ());\n \n-  // Pessimize nonzero masks, as we don't support them.\n-  m_nonzero_mask = NULL;\n-\n   /* Make sure to canonicalize the result though as the inversion of a\n      VR_RANGE can still be a VR_RANGE.  */\n   if (vr0kind == VR_UNDEFINED)\n@@ -2202,9 +2197,6 @@ irange::legacy_union (irange *vr0, const irange *vr1)\n   union_ranges (&vr0kind, &vr0min, &vr0max,\n \t\tvr1->kind (), vr1->min (), vr1->max ());\n \n-  // Pessimize nonzero masks, as we don't support them.\n-  m_nonzero_mask = NULL;\n-\n   if (vr0kind == VR_UNDEFINED)\n     vr0->set_undefined ();\n   else if (vr0kind == VR_VARYING)\n@@ -2310,8 +2302,6 @@ irange::legacy_verbose_intersect (const irange *other)\n \n // Perform an efficient union with R when both ranges have only a single pair.\n // Excluded are VARYING and UNDEFINED ranges.\n-//\n-// NOTE: It is the caller's responsibility to set the nonzero mask.\n \n bool\n irange::irange_single_pair_union (const irange &r)\n@@ -2325,7 +2315,7 @@ irange::irange_single_pair_union (const irange &r)\n     {\n       // If current upper bound is new upper bound, we're done.\n       if (wi::le_p (wi::to_wide (r.m_base[1]), wi::to_wide (m_base[1]), sign))\n-\treturn false;\n+\treturn union_nonzero_bits (r);\n       // Otherwise R has the new upper bound.\n       // Check for overlap/touching ranges, or single target range.\n       if (m_max_ranges == 1\n@@ -2338,8 +2328,7 @@ irange::irange_single_pair_union (const irange &r)\n \t  m_base[3] = r.m_base[1];\n \t  m_num_ranges = 2;\n \t}\n-      if (varying_compatible_p ())\n-\tm_kind = VR_VARYING;\n+      union_nonzero_bits (r);\n       return true;\n     }\n \n@@ -2353,11 +2342,7 @@ irange::irange_single_pair_union (const irange &r)\n   // Check for overlapping ranges, or target limited to a single range.\n   else if (m_max_ranges == 1\n \t   || wi::to_widest (r.m_base[1]) + 1 >= wi::to_widest (lb))\n-    {\n-      // This has the new upper bound, just check for varying.\n-      if (varying_compatible_p ())\n-\t  m_kind = VR_VARYING;\n-    }\n+    ;\n   else\n     {\n       // Left with 2 pairs.\n@@ -2366,8 +2351,7 @@ irange::irange_single_pair_union (const irange &r)\n       m_base[3] = m_base[1];\n       m_base[1] = r.m_base[1];\n     }\n-  if (varying_compatible_p ())\n-    m_kind = VR_VARYING;\n+  union_nonzero_bits (r);\n   return true;\n }\n \n@@ -2398,27 +2382,13 @@ irange::irange_union (const irange &r)\n       return true;\n     }\n \n-  // Save the nonzero mask in case the set operations below clobber it.\n-  bool ret_nz = union_nonzero_bits (r);\n-  tree saved_nz = m_nonzero_mask;\n-\n-  // The union_nonzero_bits may have turned things into a varying.\n-  if (varying_p ())\n-    return true;\n-\n   // Special case one range union one range.\n   if (m_num_ranges == 1 && r.m_num_ranges == 1)\n-    {\n-      bool ret = irange_single_pair_union (r);\n-      set_nonzero_bits (saved_nz);\n-      if (flag_checking)\n-\tverify_range ();\n-      return ret || ret_nz;\n-    }\n+    return irange_single_pair_union (r);\n \n   // If this ranges fully contains R, then we need do nothing.\n   if (irange_contains_p (r))\n-    return ret_nz;\n+    return union_nonzero_bits (r);\n \n   // Do not worry about merging and such by reserving twice as many\n   // pairs as needed, and then simply sort the 2 ranges into this\n@@ -2506,11 +2476,7 @@ irange::irange_union (const irange &r)\n   m_num_ranges = i / 2;\n \n   m_kind = VR_RANGE;\n-  m_nonzero_mask = saved_nz;\n-  normalize_kind ();\n-\n-  if (flag_checking)\n-    verify_range ();\n+  union_nonzero_bits (r);\n   return true;\n }\n \n@@ -2576,21 +2542,11 @@ irange::irange_intersect (const irange &r)\n       set_undefined ();\n       return true;\n     }\n-\n-  // Save the nonzero mask in case the set operations below clobber it.\n-  bool ret_nz = intersect_nonzero_bits (r);\n-  tree saved_nz = m_nonzero_mask;\n-\n   if (r.varying_p ())\n-    return ret_nz;\n-\n+    return false;\n   if (varying_p ())\n     {\n       operator= (r);\n-      if (saved_nz)\n-\tset_nonzero_bits (saved_nz);\n-      if (flag_checking)\n-\tverify_range ();\n       return true;\n     }\n \n@@ -2600,13 +2556,13 @@ irange::irange_intersect (const irange &r)\n       if (undefined_p ())\n \treturn true;\n \n-      set_nonzero_bits (saved_nz);\n-      return res || saved_nz;\n+      res |= intersect_nonzero_bits (r);\n+      return res;\n     }\n \n   // If R fully contains this, then intersection will change nothing.\n   if (r.irange_contains_p (*this))\n-    return ret_nz;\n+    return intersect_nonzero_bits (r);\n \n   signop sign = TYPE_SIGN (TREE_TYPE(m_base[0]));\n   unsigned bld_pair = 0;\n@@ -2675,15 +2631,14 @@ irange::irange_intersect (const irange &r)\n   // At the exit of this loop, it is one of 2 things:\n   // ran out of r1, or r2, but either means we are done.\n   m_num_ranges = bld_pair;\n+  if (m_num_ranges == 0)\n+    {\n+      set_undefined ();\n+      return true;\n+    }\n \n   m_kind = VR_RANGE;\n-  if (!undefined_p ())\n-    m_nonzero_mask = saved_nz;\n-  normalize_kind ();\n-\n-  if (flag_checking)\n-    verify_range ();\n-\n+  intersect_nonzero_bits (r);\n   return true;\n }\n \n@@ -2749,10 +2704,15 @@ irange::intersect (const wide_int& lb, const wide_int& ub)\n     }\n \n   m_num_ranges = bld_index;\n+  if (m_num_ranges == 0)\n+    {\n+      set_undefined ();\n+      return true;\n+    }\n \n   m_kind = VR_RANGE;\n-  normalize_kind ();\n-\n+  // No need to call normalize_kind(), as the caller will do this\n+  // while intersecting the nonzero mask.\n   if (flag_checking)\n     verify_range ();\n   return true;\n@@ -2801,7 +2761,6 @@ irange::invert ()\n     }\n \n   gcc_checking_assert (!undefined_p () && !varying_p ());\n-  m_nonzero_mask = NULL;\n \n   // We always need one more set of bounds to represent an inverse, so\n   // if we're at the limit, we can't properly represent things.\n@@ -2822,6 +2781,7 @@ irange::invert ()\n   signop sign = TYPE_SIGN (ttype);\n   wide_int type_min = wi::min_value (prec, sign);\n   wide_int type_max = wi::max_value (prec, sign);\n+  m_nonzero_mask = wi::shwi (-1, prec);\n   if (m_num_ranges == m_max_ranges\n       && lower_bound () != type_min\n       && upper_bound () != type_max)\n@@ -2896,127 +2856,140 @@ irange::invert ()\n     verify_range ();\n }\n \n-void\n-irange::set_nonzero_bits (tree mask)\n+// Return the nonzero bits inherent in the range.\n+\n+wide_int\n+irange::get_nonzero_bits_from_range () const\n {\n-  gcc_checking_assert (!undefined_p ());\n+  // For legacy symbolics.\n+  if (!constant_p ())\n+    return wi::shwi (-1, TYPE_PRECISION (type ()));\n \n-  if (!mask)\n+  wide_int min = lower_bound ();\n+  wide_int max = upper_bound ();\n+  wide_int xorv = min ^ max;\n+  if (xorv != 0)\n     {\n-      if (m_nonzero_mask)\n-\t{\n-\t  m_nonzero_mask = NULL;\n-\t  // Clearing the mask may have turned a range into VARYING.\n-\t  normalize_kind ();\n-\t}\n-      return;\n+      unsigned prec = TYPE_PRECISION (type ());\n+      xorv = wi::mask (prec - wi::clz (xorv), false, prec);\n     }\n-  m_nonzero_mask = mask;\n-  // Setting the mask may have turned a VARYING into a range.\n-  if (m_kind == VR_VARYING)\n-    m_kind = VR_RANGE;\n-\n-  if (flag_checking)\n-    verify_range ();\n+  return min | xorv;\n }\n \n-void\n-irange::set_nonzero_bits (const wide_int_ref &bits)\n+// If the the nonzero mask can be trivially converted to a range, do\n+// so and return TRUE.\n+\n+bool\n+irange::set_range_from_nonzero_bits ()\n {\n   gcc_checking_assert (!undefined_p ());\n+  unsigned popcount = wi::popcount (m_nonzero_mask);\n \n-  if (bits == -1)\n-    {\n-      set_nonzero_bits (NULL);\n-      return;\n-    }\n   // If we have only one bit set in the mask, we can figure out the\n   // range immediately.\n-  if (wi::popcount (bits) == 1)\n+  if (popcount == 1)\n     {\n       // Make sure we don't pessimize the range.\n-      tree tbits = wide_int_to_tree (type (), bits);\n-      if (!contains_p (tbits))\n-\t{\n-\t  set_nonzero_bits (tbits);\n-\t  return;\n-\t}\n+      if (!contains_p (wide_int_to_tree (type (), m_nonzero_mask)))\n+\treturn false;\n \n       bool has_zero = contains_p (build_zero_cst (type ()));\n+      wide_int bits = m_nonzero_mask;\n       set (type (), bits, bits);\n+      m_nonzero_mask = bits;\n       if (has_zero)\n \t{\n \t  int_range<2> zero;\n \t  zero.set_zero (type ());\n \t  union_ (zero);\n \t}\n+      return true;\n     }\n-  set_nonzero_bits (wide_int_to_tree (type (), bits));\n+  return false;\n }\n \n-wide_int\n-irange::get_nonzero_bits () const\n+void\n+irange::set_nonzero_bits (const wide_int_ref &bits)\n {\n   gcc_checking_assert (!undefined_p ());\n+  unsigned prec = TYPE_PRECISION (type ());\n+  gcc_checking_assert (prec == bits.get_precision ());\n \n-  // In case anyone in the legacy world queries us.\n-  if (!constant_p ())\n-    {\n-      if (m_nonzero_mask)\n-\treturn wi::to_wide (m_nonzero_mask);\n-      return wi::shwi (-1, TYPE_PRECISION (type ()));\n-    }\n+  // Drop VARYINGs with a nonzero mask to a plain range.\n+  if (m_kind == VR_VARYING && bits != -1)\n+    m_kind = VR_RANGE;\n \n-  // Calculate the nonzero bits inherent in the range.\n-  wide_int min = lower_bound ();\n-  wide_int max = upper_bound ();\n-  wide_int xorv = min ^ max;\n-  if (xorv != 0)\n-    {\n-      unsigned prec = TYPE_PRECISION (type ());\n-      xorv = wi::mask (prec - wi::clz (xorv), false, prec);\n-    }\n-  wide_int mask = min | xorv;\n+  m_nonzero_mask = wide_int::from (bits, prec, TYPE_SIGN (type ()));\n+  if (set_range_from_nonzero_bits ())\n+    return;\n \n-  // Return the nonzero bits augmented by the range.\n-  if (m_nonzero_mask)\n-    return mask & wi::to_wide (m_nonzero_mask);\n+  normalize_kind ();\n+  if (flag_checking)\n+    verify_range ();\n+}\n \n-  return mask;\n+// Return the nonzero bitmask.  This will return the nonzero bits plus\n+// the nonzero bits inherent in the range.\n+\n+wide_int\n+irange::get_nonzero_bits () const\n+{\n+  gcc_checking_assert (!undefined_p ());\n+  // The nonzero mask inherent in the range is calculated on-demand.\n+  // For example, [0,255] does not have a 0xff nonzero mask by default\n+  // (unless manually set).  This saves us considerable time, because\n+  // setting it at creation incurs a large penalty for irange::set.\n+  // At the time of writing there was a 5% slowdown in VRP if we kept\n+  // the mask precisely up to date at all times.  Instead, we default\n+  // to -1 and set it when explicitly requested.  However, this\n+  // function will always return the correct mask.\n+  return m_nonzero_mask & get_nonzero_bits_from_range ();\n }\n \n-// Intersect the nonzero bits in R into THIS.\n+// Intersect the nonzero bits in R into THIS and normalize the range.\n+// Return TRUE if the intersection changed anything.\n \n bool\n irange::intersect_nonzero_bits (const irange &r)\n {\n   gcc_checking_assert (!undefined_p () && !r.undefined_p ());\n \n-  if (m_nonzero_mask || r.m_nonzero_mask)\n+  bool changed = false;\n+  if (m_nonzero_mask != r.m_nonzero_mask)\n     {\n-      wide_int nz = wi::bit_and (get_nonzero_bits (),\n-\t\t\t\t r.get_nonzero_bits ());\n-      set_nonzero_bits (nz);\n-      return true;\n+      m_nonzero_mask = get_nonzero_bits () & r.get_nonzero_bits ();\n+      if (set_range_from_nonzero_bits ())\n+\treturn true;\n+      changed = true;\n     }\n-  return false;\n+  normalize_kind ();\n+  if (flag_checking)\n+    verify_range ();\n+  return changed;\n }\n \n-// Union the nonzero bits in R into THIS.\n+// Union the nonzero bits in R into THIS and normalize the range.\n+// Return TRUE if the union changed anything.\n \n bool\n irange::union_nonzero_bits (const irange &r)\n {\n   gcc_checking_assert (!undefined_p () && !r.undefined_p ());\n \n-  if (m_nonzero_mask || r.m_nonzero_mask)\n+  bool changed = false;\n+  if (m_nonzero_mask != r.m_nonzero_mask)\n     {\n-      wide_int nz = wi::bit_or (get_nonzero_bits (),\n-\t\t\t\tr.get_nonzero_bits ());\n-      set_nonzero_bits (nz);\n-      return true;\n+      m_nonzero_mask = get_nonzero_bits () | r.get_nonzero_bits ();\n+      // No need to call set_range_from_nonzero_bits, because we'll\n+      // never narrow the range.  Besides, it would cause endless\n+      // recursion because of the union_ in\n+      // set_range_from_nonzero_bits.\n+      changed = true;\n     }\n-  return false;\n+  normalize_kind ();\n+  if (flag_checking)\n+    verify_range ();\n+  return changed;\n }\n \n void\n@@ -3605,13 +3578,6 @@ range_tests_nonzero_bits ()\n   r0.union_ (r1);\n   ASSERT_TRUE (r0.get_nonzero_bits () == 0xff);\n \n-  // Union where the mask of nonzero bits is implicit from the range.\n-  r0.set_varying (integer_type_node);\n-  r0.set_nonzero_bits (0xf00);\n-  r1.set_zero (integer_type_node); // nonzero mask is implicitly 0\n-  r0.union_ (r1);\n-  ASSERT_TRUE (r0.get_nonzero_bits () == 0xf00);\n-\n   // Intersect of nonzero bits.\n   r0.set (INT (0), INT (255));\n   r0.set_nonzero_bits (0xfe);"}, {"sha": "d16636204447034ea307bb0b3a2a707ecdcbd06c", "filename": "gcc/value-range.h", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df3693f745eb909aacd710613811e5951e8af3b/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df3693f745eb909aacd710613811e5951e8af3b/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=7df3693f745eb909aacd710613811e5951e8af3b", "patch": "@@ -207,14 +207,15 @@ class GTY((user)) irange : public vrange\n \n   void irange_set_1bit_anti_range (tree, tree);\n   bool varying_compatible_p () const;\n-  void set_nonzero_bits (tree mask);\n   bool intersect_nonzero_bits (const irange &r);\n   bool union_nonzero_bits (const irange &r);\n+  wide_int get_nonzero_bits_from_range () const;\n+  bool set_range_from_nonzero_bits ();\n \n   bool intersect (const wide_int& lb, const wide_int& ub);\n   unsigned char m_num_ranges;\n   unsigned char m_max_ranges;\n-  tree m_nonzero_mask;\n+  wide_int m_nonzero_mask;\n   tree *m_base;\n };\n \n@@ -682,10 +683,11 @@ irange::varying_compatible_p () const\n   if (INTEGRAL_TYPE_P (t))\n     return (wi::to_wide (l) == wi::min_value (prec, sign)\n \t    && wi::to_wide (u) == wi::max_value (prec, sign)\n-\t    && !m_nonzero_mask);\n+\t    && m_nonzero_mask == -1);\n   if (POINTER_TYPE_P (t))\n     return (wi::to_wide (l) == 0\n-\t    && wi::to_wide (u) == wi::max_value (prec, sign));\n+\t    && wi::to_wide (u) == wi::max_value (prec, sign)\n+\t    && m_nonzero_mask == -1);\n   return true;\n }\n \n@@ -752,8 +754,6 @@ gt_ggc_mx (irange *x)\n       gt_ggc_mx (x->m_base[i * 2]);\n       gt_ggc_mx (x->m_base[i * 2 + 1]);\n     }\n-  if (x->m_nonzero_mask)\n-    gt_ggc_mx (x->m_nonzero_mask);\n }\n \n inline void\n@@ -764,8 +764,6 @@ gt_pch_nx (irange *x)\n       gt_pch_nx (x->m_base[i * 2]);\n       gt_pch_nx (x->m_base[i * 2 + 1]);\n     }\n-  if (x->m_nonzero_mask)\n-    gt_pch_nx (x->m_nonzero_mask);\n }\n \n inline void\n@@ -776,8 +774,6 @@ gt_pch_nx (irange *x, gt_pointer_operator op, void *cookie)\n       op (&x->m_base[i * 2], NULL, cookie);\n       op (&x->m_base[i * 2 + 1], NULL, cookie);\n     }\n-  if (x->m_nonzero_mask)\n-    op (&x->m_nonzero_mask, NULL, cookie);\n }\n \n template<unsigned N>\n@@ -872,15 +868,18 @@ irange::set_undefined ()\n {\n   m_kind = VR_UNDEFINED;\n   m_num_ranges = 0;\n-  m_nonzero_mask = NULL;\n }\n \n inline void\n irange::set_varying (tree type)\n {\n   m_kind = VR_VARYING;\n   m_num_ranges = 1;\n-  m_nonzero_mask = NULL;\n+\n+  if (type == error_mark_node)\n+    m_nonzero_mask = wi::shwi (-1, 1);\n+  else\n+    m_nonzero_mask = wi::shwi (-1, TYPE_PRECISION (type));\n \n   if (INTEGRAL_TYPE_P (type))\n     {\n@@ -1002,8 +1001,6 @@ irange::normalize_kind ()\n \tm_kind = VR_VARYING;\n       else if (m_kind == VR_ANTI_RANGE)\n \tset_undefined ();\n-      else\n-\tgcc_unreachable ();\n     }\n }\n "}]}