{"sha": "2be510b87745ef8f57b584fdff4a2805783b3de7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJlNTEwYjg3NzQ1ZWY4ZjU3YjU4NGZkZmY0YTI4MDU3ODNiM2RlNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-01-04T21:18:27Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-01-04T21:18:27Z"}, "message": "Special-case tree_decl/tree_list allocations.\n\n\t* ggc-page.c (OBJECT_PER_PAGE): Reimplement.\n\t(OBJECT_SIZE): New macro.\n\t(NUM_EXTRA_ORDER): Likewise.\n\t(extra_order_size_table): New variable.\n\t(NUM_ORDERS): New macro.\n\t(objects_per_page_table): New variable.\n\t(object_size_table): New variable.\n\t(G.pages): Use NUM_ORDERS to bound the array.\n\t(G.page_tails): Likewise.\n\t(DIV_ROUND_UP): Remove.\n\t(BITMAP_SIZE): Use CEIL, instead of DIV_ROUND_UP.\n\t(alloc_page): Use OBJECT_SIZE.\n\t(size_lookup): Don't make it const.\n\t(ggc_alloc): Use OBJECT_SIZE.\n\t(ggc_set_mark): Likewise.\n\t(ggc_get_size): Likewise.\n\t(init_ggc): Set up the object_size_table, objects_per_page_table,\n\tand adjust size_lookup.\n\t(ggc_recalculate_in_use_p): Use CEIL, not DIV_ROUND_UP.\n\t(ggc_pop_context): Use NUM_ORDERS.\n\t(clear_marks): Likewise.\n\t(sweep_pages): Likewise.\n\t(poison_pages): Likewise.\n\t(ggc_print_statistics): Use OBJECT_SIZE.\n\nFrom-SVN: r38692", "tree": {"sha": "449a4a48f0fb3f1a7b657d6c17abb75165423bb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/449a4a48f0fb3f1a7b657d6c17abb75165423bb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2be510b87745ef8f57b584fdff4a2805783b3de7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be510b87745ef8f57b584fdff4a2805783b3de7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2be510b87745ef8f57b584fdff4a2805783b3de7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be510b87745ef8f57b584fdff4a2805783b3de7/comments", "author": null, "committer": null, "parents": [{"sha": "bf1aaf0ac6dc0ea6019b0181211c2f0316526aec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1aaf0ac6dc0ea6019b0181211c2f0316526aec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf1aaf0ac6dc0ea6019b0181211c2f0316526aec"}], "stats": {"total": 150, "additions": 116, "deletions": 34}, "files": [{"sha": "d422a7b06f1c0064aba55c558cd500b7fdad1788", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be510b87745ef8f57b584fdff4a2805783b3de7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be510b87745ef8f57b584fdff4a2805783b3de7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2be510b87745ef8f57b584fdff4a2805783b3de7", "patch": "@@ -1,3 +1,31 @@\n+2001-01-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tSpecial-case tree_decl/tree_list allocations.\n+\t* ggc-page.c (OBJECT_PER_PAGE): Reimplement.\n+\t(OBJECT_SIZE): New macro.\n+\t(NUM_EXTRA_ORDER): Likewise.\n+\t(extra_order_size_table): New variable.\n+\t(NUM_ORDERS): New macro.\n+\t(objects_per_page_table): New variable.\n+\t(object_size_table): New variable.\n+\t(G.pages): Use NUM_ORDERS to bound the array.\n+\t(G.page_tails): Likewise.\n+\t(DIV_ROUND_UP): Remove.\n+\t(BITMAP_SIZE): Use CEIL, instead of DIV_ROUND_UP.\n+\t(alloc_page): Use OBJECT_SIZE.\n+\t(size_lookup): Don't make it const.\n+\t(ggc_alloc): Use OBJECT_SIZE.\n+\t(ggc_set_mark): Likewise.\n+\t(ggc_get_size): Likewise.\n+\t(init_ggc): Set up the object_size_table, objects_per_page_table,\n+\tand adjust size_lookup.\n+\t(ggc_recalculate_in_use_p): Use CEIL, not DIV_ROUND_UP.\n+\t(ggc_pop_context): Use NUM_ORDERS.\n+\t(clear_marks): Likewise.\n+\t(sweep_pages): Likewise.\n+\t(poison_pages): Likewise.\n+\t(ggc_print_statistics): Use OBJECT_SIZE.\n+\n Thu Jan  4 15:54:05 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* varasm.c (output_constructor): Use HOST_WIDE_INT for sizes."}, {"sha": "e4bf283498e364a0330e5ea1c0467a3c00803818", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 88, "deletions": 34, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be510b87745ef8f57b584fdff4a2805783b3de7/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be510b87745ef8f57b584fdff4a2805783b3de7/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=2be510b87745ef8f57b584fdff4a2805783b3de7", "patch": "@@ -1,5 +1,5 @@\n /* \"Bag-of-pages\" garbage collector for the GNU compiler.\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -133,6 +133,39 @@ Boston, MA 02111-1307, USA.  */\n #define LOOKUP_L2(p) \\\n   (((size_t) (p) >> G.lg_pagesize) & ((1 << PAGE_L2_BITS) - 1))\n \n+/* The number of objects per allocation page, for objects on a page of\n+   the indicated ORDER.  */\n+#define OBJECTS_PER_PAGE(ORDER) objects_per_page_table[ORDER]\n+\n+/* The size of an object on a page of the indicated ORDER.  */\n+#define OBJECT_SIZE(ORDER) object_size_table[ORDER]\n+\n+/* The number of extra orders, not corresponding to power-of-two sized\n+   objects.  */\n+\n+#define NUM_EXTRA_ORDERS \\\n+  (sizeof (extra_order_size_table) / sizeof (extra_order_size_table[0]))\n+\n+/* The Ith entry is the maximum size of an object to be stored in the\n+   Ith extra order.  Adding a new entry to this array is the *only*\n+   thing you need to do to add a new special allocation size.  */\n+\n+static const size_t extra_order_size_table[] = {\n+  sizeof (struct tree_decl),\n+  sizeof (struct tree_list)\n+};\n+\n+/* The total number of orders.  */\n+\n+#define NUM_ORDERS (HOST_BITS_PER_PTR + NUM_EXTRA_ORDERS)\n+\n+/* The Ith entry is the number of objects on a page or order I.  */\n+\n+static unsigned objects_per_page_table[NUM_ORDERS];\n+\n+/* The Ith entry is the size of an object on a page of order I.  */\n+\n+static size_t object_size_table[NUM_ORDERS];\n \n /* A page_entry records the status of an allocation page.  This\n    structure is dynamically sized to fit the bitmap in_use_p.  */\n@@ -199,12 +232,12 @@ static struct globals\n      If there are any pages with free objects, they will be at the\n      head of the list.  NULL if there are no page-entries for this\n      object size.  */\n-  page_entry *pages[HOST_BITS_PER_PTR];\n+  page_entry *pages[NUM_ORDERS];\n \n   /* The Nth element in this array is the last page with objects of\n      size 2^N.  NULL if there are no page-entries for this object\n      size.  */\n-  page_entry *page_tails[HOST_BITS_PER_PTR];\n+  page_entry *page_tails[NUM_ORDERS];\n \n   /* Lookup table for associating allocation pages with object addresses.  */\n   page_table lookup;\n@@ -237,20 +270,10 @@ static struct globals\n   FILE *debug_file;\n } G;\n \n-\n-/* Compute DIVIDEND / DIVISOR, rounded up.  */\n-#define DIV_ROUND_UP(Dividend, Divisor) \\\n-  (((Dividend) + (Divisor) - 1) / (Divisor))\n-\n-/* The number of objects per allocation page, for objects of size\n-   2^ORDER.  */\n-#define OBJECTS_PER_PAGE(Order) \\\n-  ((Order) >= G.lg_pagesize ? 1 : G.pagesize / ((size_t)1 << (Order)))\n-\n /* The size in bytes required to maintain a bitmap for the objects\n    on a page-entry.  */\n #define BITMAP_SIZE(Num_objects) \\\n-  (DIV_ROUND_UP ((Num_objects), HOST_BITS_PER_LONG) * sizeof(long))\n+  (CEIL ((Num_objects), HOST_BITS_PER_LONG) * sizeof(long))\n \n /* Skip garbage collection if the current allocation is not at least\n    this factor times the allocation at the end of the last collection.\n@@ -459,7 +482,7 @@ alloc_page (order)\n   num_objects = OBJECTS_PER_PAGE (order);\n   bitmap_size = BITMAP_SIZE (num_objects + 1);\n   page_entry_size = sizeof (page_entry) - sizeof (long) + bitmap_size;\n-  entry_size = num_objects * (1 << order);\n+  entry_size = num_objects * OBJECT_SIZE (order);\n \n   entry = NULL;\n   page = NULL;\n@@ -529,7 +552,7 @@ alloc_page (order)\n   if (GGC_DEBUG_LEVEL >= 2)\n     fprintf (G.debug_file, \n \t     \"Allocating page at %p, object size=%d, data %p-%p\\n\",\n-\t     (PTR) entry, 1 << order, page, page + entry_size - 1);\n+\t     (PTR) entry, OBJECT_SIZE (order), page, page + entry_size - 1);\n \n   return entry;\n }\n@@ -603,7 +626,7 @@ release_pages ()\n /* This table provides a fast way to determine ceil(log_2(size)) for\n    allocation requests.  The minimum allocation size is four bytes.  */\n \n-static unsigned char const size_lookup[257] = \n+static unsigned char size_lookup[257] = \n { \n   2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, \n   4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, \n@@ -640,7 +663,7 @@ ggc_alloc (size)\n   else\n     {\n       order = 9;\n-      while (size > ((size_t) 1 << order))\n+      while (size > OBJECT_SIZE (order))\n \torder++;\n     }\n \n@@ -695,7 +718,7 @@ ggc_alloc (size)\n       /* Next time, try the next bit.  */\n       entry->next_bit_hint = hint + 1;\n \n-      object_offset = hint << order;\n+      object_offset = hint * OBJECT_SIZE (order);\n     }\n \n   /* Set the in-use bit.  */\n@@ -721,17 +744,17 @@ ggc_alloc (size)\n #ifdef GGC_POISON\n   /* `Poison' the entire allocated object, including any padding at\n      the end.  */\n-  memset (result, 0xaf, 1 << order);\n+  memset (result, 0xaf, OBJECT_SIZE (order));\n #endif\n \n   /* Keep track of how many bytes are being allocated.  This\n      information is used in deciding when to collect.  */\n-  G.allocated += (size_t) 1 << order;\n+  G.allocated += OBJECT_SIZE (order);\n \n   if (GGC_DEBUG_LEVEL >= 3)\n     fprintf (G.debug_file, \n \t     \"Allocating object, requested size=%d, actual=%d at %p on %p\\n\",\n-\t     (int) size, 1 << order, result, (PTR) entry);\n+\t     (int) size, OBJECT_SIZE (order), result, (PTR) entry);\n \n   return result;\n }\n@@ -758,7 +781,7 @@ ggc_set_mark (p)\n \n   /* Calculate the index of the object on the page; this is its bit\n      position in the in_use_p bitmap.  */\n-  bit = (((const char *) p) - entry->page) >> entry->order;\n+  bit = (((const char *) p) - entry->page) / OBJECT_SIZE (entry->order);\n   word = bit / HOST_BITS_PER_LONG;\n   mask = (unsigned long) 1 << (bit % HOST_BITS_PER_LONG);\n   \n@@ -793,14 +816,16 @@ ggc_get_size (p)\n      const void *p;\n {\n   page_entry *pe = lookup_page_table_entry (p);\n-  return 1 << pe->order;\n+  return OBJECT_SIZE (pe->order);\n }\n \f\n /* Initialize the ggc-mmap allocator.  */\n \n void\n init_ggc ()\n {\n+  unsigned order;\n+\n   G.pagesize = getpagesize();\n   G.lg_pagesize = exact_log2 (G.pagesize);\n \n@@ -837,6 +862,35 @@ init_ggc ()\n     munmap (p, G.pagesize);\n   }\n #endif\n+\n+  /* Initialize the object size table.  */\n+  for (order = 0; order < HOST_BITS_PER_PTR; ++order)\n+    object_size_table[order] = (size_t) 1 << order;\n+  for (order = HOST_BITS_PER_PTR; order < NUM_ORDERS; ++order)\n+    object_size_table[order] = \n+      extra_order_size_table[order - HOST_BITS_PER_PTR];\n+\n+  /* Initialize the objects-per-page table.  */\n+  for (order = 0; order < NUM_ORDERS; ++order)\n+    {\n+      objects_per_page_table[order] = G.pagesize / OBJECT_SIZE (order);\n+      if (objects_per_page_table[order] == 0)\n+\tobjects_per_page_table[order] = 1;\n+    }\n+\n+  /* Reset the size_lookup array to put appropriately sized objects in\n+     the special orders.  All objects bigger than the previous power\n+     of two, but no greater than the special size, should go in the\n+     new order.  */\n+  for (order = HOST_BITS_PER_PTR; order < NUM_ORDERS; ++order)\n+    {\n+      int o;\n+      int i;\n+\n+      o = size_lookup[OBJECT_SIZE (order)];\n+      for (i = OBJECT_SIZE (order); size_lookup [i] == o; --i)\n+\tsize_lookup[i] = order;\n+    }\n }\n \n /* Increment the `GC context'.  Objects allocated in an outer context\n@@ -871,8 +925,8 @@ ggc_recalculate_in_use_p (p)\n \n   /* Combine the IN_USE_P and SAVE_IN_USE_P arrays.  */\n   for (i = 0; \n-       i < DIV_ROUND_UP (BITMAP_SIZE (num_objects),\n-\t\t\t sizeof (*p->in_use_p));\n+       i < CEIL (BITMAP_SIZE (num_objects),\n+\t\t sizeof (*p->in_use_p));\n        ++i)\n     {\n       unsigned long j;\n@@ -903,7 +957,7 @@ ggc_pop_context ()\n   /* Any remaining pages in the popped context are lowered to the new\n      current context; i.e. objects allocated in the popped context and\n      left over are imported into the previous context.  */\n-  for (order = 2; order < HOST_BITS_PER_PTR; order++)\n+  for (order = 2; order < NUM_ORDERS; order++)\n     {\n       page_entry *p;\n \n@@ -931,7 +985,7 @@ clear_marks ()\n {\n   unsigned order;\n \n-  for (order = 2; order < HOST_BITS_PER_PTR; order++)\n+  for (order = 2; order < NUM_ORDERS; order++)\n     {\n       size_t num_objects = OBJECTS_PER_PAGE (order);\n       size_t bitmap_size = BITMAP_SIZE (num_objects + 1);\n@@ -975,7 +1029,7 @@ sweep_pages ()\n {\n   unsigned order;\n \n-  for (order = 2; order < HOST_BITS_PER_PTR; order++)\n+  for (order = 2; order < NUM_ORDERS; order++)\n     {\n       /* The last page-entry to consider, regardless of entries\n \t placed at the end of the list.  */\n@@ -1002,7 +1056,7 @@ sweep_pages ()\n              allocated memory.  */\n \t  live_objects = num_objects - p->num_free_objects;\n \n-\t  G.allocated += ((size_t) 1 << order) * live_objects;\n+\t  G.allocated += OBJECT_SIZE (order) * live_objects;\n \n \t  /* Only objects on pages in the topmost context should get\n \t     collected.  */\n@@ -1082,10 +1136,10 @@ poison_pages ()\n {\n   unsigned order;\n \n-  for (order = 2; order < HOST_BITS_PER_PTR; order++)\n+  for (order = 2; order < NUM_ORDERS; order++)\n     {\n       size_t num_objects = OBJECTS_PER_PAGE (order);\n-      size_t size = (size_t) 1 << order;\n+      size_t size = OBJECT_SIZE (order);\n       page_entry *p;\n \n       for (p = G.pages[order]; p != NULL; p = p->next)\n@@ -1188,7 +1242,7 @@ ggc_print_statistics ()\n      allocation.  */\n   fprintf (stderr, \"\\n%-5s %10s  %10s  %10s\\n\",\n \t   \"Log\", \"Allocated\", \"Used\", \"Overhead\");\n-  for (i = 0; i < HOST_BITS_PER_PTR; ++i)\n+  for (i = 0; i < NUM_ORDERS; ++i)\n     {\n       page_entry *p;\n       size_t allocated;\n@@ -1208,7 +1262,7 @@ ggc_print_statistics ()\n \t{\n \t  allocated += p->bytes;\n \t  in_use += \n-\t    (OBJECTS_PER_PAGE (i) - p->num_free_objects) * (1 << i);\n+\t    (OBJECTS_PER_PAGE (i) - p->num_free_objects) * OBJECT_SIZE (i);\n \n \t  overhead += (sizeof (page_entry) - sizeof (long)\n \t\t       + BITMAP_SIZE (OBJECTS_PER_PAGE (i) + 1));"}]}