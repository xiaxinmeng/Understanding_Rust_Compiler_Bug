{"sha": "36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZhM2E3YTM3MjZjOGI2NWVlY2ViNmViNGE4OTQ2ZTBjZDU2NTBhOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-03-21T22:00:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-03-21T22:00:04Z"}, "message": "hash-table.h (hash_table): Add Lazy template parameter defaulted to false...\n\n\t* hash-table.h (hash_table): Add Lazy template parameter defaulted\n\tto false, if true, don't alloc_entries during construction, but defer\n\tit to the first method that needs m_entries allocated.\n\t(hash_table::hash_table, hash_table::~hash_table,\n\thash_table::alloc_entries, hash_table::find_empty_slot_for_expand,\n\thash_table::too_empty_p, hash_table::expand, hash_table::empty_slow,\n\thash_table::clear_slot, hash_table::traverse_noresize,\n\thash_table::traverse, hash_table::iterator::slide): Adjust all methods.\n\t* hash-set.h (hash_set): Add Lazy template parameter defaulted to\n\tfalse.\n\t(hash_set::contains): If Lazy is true, use find_slot_with_hash with\n\tNO_INSERT instead of find_with_hash.\n\t(hash_set::traverse, hash_set::iterator, hash_set::iterator::m_iter,\n\thash_set::m_table): Add Lazy to template params of hash_table.\n\t(gt_ggc_mx, gt_pch_nx): Use false as Lazy in hash_set template param.\n\t* attribs.c (test_attribute_exclusions): Likewise.\n\t* hash-set-tests.c (test_set_of_strings): Add iterator tests for\n\thash_set.  Add tests for hash_set with Lazy = true.\nc-family/\n\t* c-common.c (per_file_includes_t): Use false as Lazy in hash_set\n\ttemplate param.\njit/\n\t* jit-recording.c (reproducer::m_set_identifiers): Use false as Lazy\n\tin hash_set template param.\n\nFrom-SVN: r269859", "tree": {"sha": "ce1f9656a446322fdb783d3909c677132ee5d92a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce1f9656a446322fdb783d3909c677132ee5d92a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2e4182ae07e16f30b8917af3c0581a6c8af31357", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e4182ae07e16f30b8917af3c0581a6c8af31357", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e4182ae07e16f30b8917af3c0581a6c8af31357"}], "stats": {"total": 343, "additions": 248, "deletions": 95}, "files": [{"sha": "2f1bf46158567965bc0dc9fedc2681edf222628c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "patch": "@@ -1,3 +1,24 @@\n+2019-03-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* hash-table.h (hash_table): Add Lazy template parameter defaulted\n+\tto false, if true, don't alloc_entries during construction, but defer\n+\tit to the first method that needs m_entries allocated.\n+\t(hash_table::hash_table, hash_table::~hash_table,\n+\thash_table::alloc_entries, hash_table::find_empty_slot_for_expand,\n+\thash_table::too_empty_p, hash_table::expand, hash_table::empty_slow,\n+\thash_table::clear_slot, hash_table::traverse_noresize,\n+\thash_table::traverse, hash_table::iterator::slide): Adjust all methods.\n+\t* hash-set.h (hash_set): Add Lazy template parameter defaulted to\n+\tfalse.\n+\t(hash_set::contains): If Lazy is true, use find_slot_with_hash with\n+\tNO_INSERT instead of find_with_hash.\n+\t(hash_set::traverse, hash_set::iterator, hash_set::iterator::m_iter,\n+\thash_set::m_table): Add Lazy to template params of hash_table.\n+\t(gt_ggc_mx, gt_pch_nx): Use false as Lazy in hash_set template param.\n+\t* attribs.c (test_attribute_exclusions): Likewise.\n+\t* hash-set-tests.c (test_set_of_strings): Add iterator tests for\n+\thash_set.  Add tests for hash_set with Lazy = true.\n+\n 2019-03-21  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/89779"}, {"sha": "4441922543f3c187cdf57ff7b4a66e939a68b32c", "filename": "gcc/attribs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "patch": "@@ -2075,7 +2075,7 @@ test_attribute_exclusions ()\n   const size_t ntables = ARRAY_SIZE (attribute_tables);\n \n   /* Set of pairs of mutually exclusive attributes.  */\n-  typedef hash_set<excl_pair, excl_hash_traits> exclusion_set;\n+  typedef hash_set<excl_pair, false, excl_hash_traits> exclusion_set;\n   exclusion_set excl_set;\n \n   for (size_t ti0 = 0; ti0 != ntables; ++ti0)"}, {"sha": "a597b12ce4cc978de28f554e6bc8457fa2c81b15", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "patch": "@@ -1,3 +1,8 @@\n+2019-03-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-common.c (per_file_includes_t): Use false as Lazy in hash_set\n+\ttemplate param.\n+\n 2019-03-19  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/89688"}, {"sha": "2b99842309d75188fe881183794ae897b03add2f", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "patch": "@@ -8731,7 +8731,7 @@ try_to_locate_new_include_insertion_point (const char *file, location_t loc)\n    no guarantee that two different diagnostics that are recommending\n    adding e.g. \"<stdio.h>\" are using the same buffer.  */\n \n-typedef hash_set <const char *, nofree_string_hash> per_file_includes_t;\n+typedef hash_set <const char *, false, nofree_string_hash> per_file_includes_t;\n \n /* The map itself.  We don't need string comparison for the filename keys,\n    as they come from libcpp.  */"}, {"sha": "e0d1d47805bc6de31dc3e5dab04f582c0350a1f0", "filename": "gcc/hash-set-tests.c", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fhash-set-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fhash-set-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set-tests.c?ref=36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "patch": "@@ -44,6 +44,9 @@ test_set_of_strings ()\n \n   ASSERT_EQ (false, s.contains (red));\n \n+  for (hash_set<const char *>::iterator it = s.begin (); it != s.end (); ++it)\n+    ASSERT_EQ (true, false);\n+\n   /* Populate the hash_set.  */\n   ASSERT_EQ (false, s.add (red));\n   ASSERT_EQ (false, s.add (green));\n@@ -68,6 +71,67 @@ test_set_of_strings ()\n   ASSERT_EQ (true, s.contains (green));\n   ASSERT_EQ (true, s.contains (blue));\n   ASSERT_EQ (2, s.elements ());\n+\n+  int seen = 0;\n+  for (hash_set<const char *>::iterator it = s.begin (); it != s.end (); ++it)\n+    {\n+      int n = *it == green;\n+      if (n == 0)\n+\tASSERT_EQ (*it, blue);\n+      ASSERT_EQ (seen & (1 << n), 0);\n+      seen |= 1 << n;\n+    }\n+  ASSERT_EQ (seen, 3);\n+\n+  hash_set <const char *, true> t;\n+  ASSERT_EQ (0, t.elements ());\n+\n+  ASSERT_EQ (false, t.contains (red));\n+\n+  for (hash_set<const char *, true>::iterator it = t.begin ();\n+       it != t.end (); ++it)\n+    ASSERT_EQ (true, false);\n+\n+  /* Populate the hash_set.  */\n+  ASSERT_EQ (false, t.add (red));\n+  ASSERT_EQ (false, t.add (green));\n+  ASSERT_EQ (false, t.add (blue));\n+  ASSERT_EQ (true, t.add (green));\n+\n+  /* Verify that the values are now within the set.  */\n+  ASSERT_EQ (true, t.contains (red));\n+  ASSERT_EQ (true, t.contains (green));\n+  ASSERT_EQ (true, t.contains (blue));\n+  ASSERT_EQ (3, t.elements ());\n+\n+  seen = 0;\n+  for (hash_set<const char *, true>::iterator it = t.begin ();\n+       it != t.end (); ++it)\n+    {\n+      int n = 2;\n+      if (*it == green)\n+\tn = 0;\n+      else if (*it == blue)\n+\tn = 1;\n+      else\n+\tASSERT_EQ (*it, red);\n+      ASSERT_EQ (seen & (1 << n), 0);\n+      seen |= 1 << n;\n+    }\n+  ASSERT_EQ (seen, 7);\n+\n+  /* Test removal.  */\n+  t.remove (red);\n+  ASSERT_EQ (false, t.contains (red));\n+  ASSERT_EQ (true, t.contains (green));\n+  ASSERT_EQ (true, t.contains (blue));\n+  ASSERT_EQ (2, t.elements ());\n+\n+  t.remove (red);\n+  ASSERT_EQ (false, t.contains (red));\n+  ASSERT_EQ (true, t.contains (green));\n+  ASSERT_EQ (true, t.contains (blue));\n+  ASSERT_EQ (2, t.elements ());\n }\n \n /* Run all of the selftests within this file.  */"}, {"sha": "8e1f38b1965fec920dff075702dded63fc5ccb4d", "filename": "gcc/hash-set.h", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fhash-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fhash-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set.h?ref=36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "patch": "@@ -21,7 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef hash_set_h\n #define hash_set_h\n \n-template<typename KeyId, typename Traits = default_hash_traits<KeyId> >\n+template<typename KeyId, bool Lazy = false,\n+\t typename Traits = default_hash_traits<KeyId> >\n class hash_set\n {\n public:\n@@ -32,12 +33,12 @@ class hash_set\n   /* Create a hash_set in gc memory with space for at least n elements.  */\n \n   static hash_set *\n-    create_ggc (size_t n)\n-      {\n-\thash_set *set = ggc_alloc<hash_set> ();\n-\tnew (set) hash_set (n, true);\n-\treturn set;\n-      }\n+  create_ggc (size_t n)\n+    {\n+      hash_set *set = ggc_alloc<hash_set> ();\n+      new (set) hash_set (n, true);\n+      return set;\n+    }\n \n   /* If key k isn't already in the map add it to the map, and\n      return false.  Otherwise return true.  */\n@@ -56,6 +57,9 @@ class hash_set\n \n   bool contains (const Key &k)\n     {\n+      if (Lazy)\n+\treturn (m_table.find_slot_with_hash (k, Traits::hash (k), NO_INSERT)\n+\t\t!= NULL);\n       Key &e = m_table.find_with_hash (k, Traits::hash (k));\n       return !Traits::is_empty (e);\n     }\n@@ -71,7 +75,7 @@ class hash_set\n   template<typename Arg, bool (*f)(const typename Traits::value_type &, Arg)>\n   void traverse (Arg a) const\n     {\n-      for (typename hash_table<Traits>::iterator iter = m_table.begin ();\n+      for (typename hash_table<Traits, Lazy>::iterator iter = m_table.begin ();\n \t   iter != m_table.end (); ++iter)\n \tf (*iter, a);\n     }\n@@ -87,7 +91,8 @@ class hash_set\n   class iterator\n   {\n   public:\n-    explicit iterator (const typename hash_table<Traits>::iterator &iter) :\n+    explicit iterator (const typename hash_table<Traits,\n+\t\t\t\t\t\t Lazy>::iterator &iter) :\n       m_iter (iter) {}\n \n     iterator &operator++ ()\n@@ -109,7 +114,7 @@ class hash_set\n       }\n \n   private:\n-    typename hash_table<Traits>::iterator m_iter;\n+    typename hash_table<Traits, Lazy>::iterator m_iter;\n   };\n \n   /* Standard iterator retrieval methods.  */\n@@ -120,11 +125,14 @@ class hash_set\n \n private:\n \n-  template<typename T, typename U> friend void gt_ggc_mx (hash_set<T, U> *);\n-  template<typename T, typename U> friend void gt_pch_nx (hash_set<T, U> *);\n-      template<typename T, typename U> friend void gt_pch_nx (hash_set<T, U> *, gt_pointer_operator, void *);\n+  template<typename T, typename U>\n+  friend void gt_ggc_mx (hash_set<T, false, U> *);\n+  template<typename T, typename U>\n+  friend void gt_pch_nx (hash_set<T, false, U> *);\n+  template<typename T, typename U>\n+  friend void gt_pch_nx (hash_set<T, false, U> *, gt_pointer_operator, void *);\n \n-  hash_table<Traits> m_table;\n+  hash_table<Traits, Lazy> m_table;\n };\n \n /* Generic hash_set<TYPE> debug helper.\n@@ -169,21 +177,21 @@ debug_helper (hash_set<T> &ref)\n \n template<typename K, typename H>\n static inline void\n-gt_ggc_mx (hash_set<K, H> *h)\n+gt_ggc_mx (hash_set<K, false, H> *h)\n {\n   gt_ggc_mx (&h->m_table);\n }\n \n template<typename K, typename H>\n static inline void\n-gt_pch_nx (hash_set<K, H> *h)\n+gt_pch_nx (hash_set<K, false, H> *h)\n {\n   gt_pch_nx (&h->m_table);\n }\n \n template<typename K, typename H>\n static inline void\n-gt_pch_nx (hash_set<K, H> *h, gt_pointer_operator op, void *cookie)\n+gt_pch_nx (hash_set<K, false, H> *h, gt_pointer_operator op, void *cookie)\n {\n   op (&h->m_table.m_entries, cookie);\n }"}, {"sha": "e5bbe677cecee656445634c8950903d94e85019d", "filename": "gcc/hash-table.h", "status": "modified", "additions": 125, "deletions": 75, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "patch": "@@ -167,6 +167,15 @@ along with GCC; see the file COPYING3.  If not see\n    See hash_table for details.  The interface is very similar to libiberty's\n    htab_t.\n \n+   If a hash table is used only in some rare cases, it is possible\n+   to construct the hash_table lazily before first use.  This is done\n+   through:\n+\n+      hash_table <some_type_hasher, true> some_type_hash_table;\n+\n+   which will cause whatever methods actually need the allocated entries\n+   array to allocate it later.\n+\n \n    EASY DESCRIPTORS FOR POINTERS\n \n@@ -241,7 +250,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hash-map-traits.h\"\n \n template<typename, typename, typename> class hash_map;\n-template<typename, typename> class hash_set;\n+template<typename, bool, typename> class hash_set;\n \n /* The ordinary memory allocator.  */\n /* FIXME (crowl): This allocator may be extracted for wider sharing later.  */\n@@ -353,8 +362,8 @@ class mem_usage;\n      hash table code.\n \n */\n-template <typename Descriptor,\n-\t template<typename Type> class Allocator = xcallocator>\n+template <typename Descriptor, bool Lazy = false,\n+\t  template<typename Type> class Allocator = xcallocator>\n class hash_table\n {\n   typedef typename Descriptor::value_type value_type;\n@@ -422,7 +431,7 @@ class hash_table\n      write the value you want into the returned slot.  When inserting an\n      entry, NULL may be returned if memory allocation fails. */\n   value_type *find_slot_with_hash (const compare_type &comparable,\n-\t\t\t\t    hashval_t hash, enum insert_option insert);\n+\t\t\t\t   hashval_t hash, enum insert_option insert);\n \n   /* This function deletes an element with the given COMPARABLE value\n      from hash table starting with the given HASH.  If there is no\n@@ -472,6 +481,8 @@ class hash_table\n \n   iterator begin () const\n     {\n+      if (Lazy && m_entries == NULL)\n+\treturn iterator ();\n       iterator iter (m_entries, m_entries + m_size);\n       iter.slide ();\n       return iter;\n@@ -491,9 +502,8 @@ class hash_table\n     hashtab_entry_note_pointers (void *, void *, gt_pointer_operator, void *);\n   template<typename T, typename U, typename V> friend void\n   gt_pch_nx (hash_map<T, U, V> *, gt_pointer_operator, void *);\n-  template<typename T, typename U> friend void gt_pch_nx (hash_set<T, U> *,\n-\t\t\t\t\t\t\t  gt_pointer_operator,\n-\t\t\t\t\t\t\t  void *);\n+  template<typename T, typename U>\n+  friend void gt_pch_nx (hash_set<T, false, U> *, gt_pointer_operator, void *);\n   template<typename T> friend void gt_pch_nx (hash_table<T> *,\n \t\t\t\t\t      gt_pointer_operator, void *);\n \n@@ -566,11 +576,12 @@ extern mem_alloc_description<mem_usage>& hash_table_usage (void);\n /* Support function for statistics.  */\n extern void dump_hash_table_loc_statistics (void);\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n-hash_table<Descriptor, Allocator>::hash_table (size_t size, bool ggc, bool\n-\t\t\t\t\t       gather_mem_stats,\n-\t\t\t\t\t       mem_alloc_origin origin\n-\t\t\t\t\t       MEM_STAT_DECL) :\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n+hash_table<Descriptor, Lazy, Allocator>::hash_table (size_t size, bool ggc,\n+\t\t\t\t\t\t     bool gather_mem_stats,\n+\t\t\t\t\t\t     mem_alloc_origin origin\n+\t\t\t\t\t\t     MEM_STAT_DECL) :\n   m_n_elements (0), m_n_deleted (0), m_searches (0), m_collisions (0),\n   m_ggc (ggc), m_gather_mem_stats (gather_mem_stats)\n {\n@@ -581,18 +592,23 @@ hash_table<Descriptor, Allocator>::hash_table (size_t size, bool ggc, bool\n \n   if (m_gather_mem_stats)\n     hash_table_usage ().register_descriptor (this, origin, ggc\n-\t\t\t\t\t  FINAL_PASS_MEM_STAT);\n+\t\t\t\t\t     FINAL_PASS_MEM_STAT);\n \n-  m_entries = alloc_entries (size PASS_MEM_STAT);\n+  if (Lazy)\n+    m_entries = NULL;\n+  else\n+    m_entries = alloc_entries (size PASS_MEM_STAT);\n   m_size = size;\n   m_size_prime_index = size_prime_index;\n }\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n-hash_table<Descriptor, Allocator>::hash_table (const hash_table &h, bool ggc,\n-\t\t\t\t\t       bool gather_mem_stats,\n-\t\t\t\t\t       mem_alloc_origin origin\n-\t\t\t\t\t       MEM_STAT_DECL) :\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n+hash_table<Descriptor, Lazy, Allocator>::hash_table (const hash_table &h,\n+\t\t\t\t\t\t     bool ggc,\n+\t\t\t\t\t\t     bool gather_mem_stats,\n+\t\t\t\t\t\t     mem_alloc_origin origin\n+\t\t\t\t\t\t     MEM_STAT_DECL) :\n   m_n_elements (h.m_n_elements), m_n_deleted (h.m_n_deleted),\n   m_searches (0), m_collisions (0), m_ggc (ggc),\n   m_gather_mem_stats (gather_mem_stats)\n@@ -603,43 +619,54 @@ hash_table<Descriptor, Allocator>::hash_table (const hash_table &h, bool ggc,\n     hash_table_usage ().register_descriptor (this, origin, ggc\n \t\t\t\t\t  FINAL_PASS_MEM_STAT);\n \n-  value_type *nentries = alloc_entries (size PASS_MEM_STAT);\n-  for (size_t i = 0; i < size; ++i)\n+  if (Lazy && h.m_entries == NULL)\n+    m_entries = NULL;\n+  else\n     {\n-      value_type &entry = h.m_entries[i];\n-      if (is_deleted (entry))\n-\tmark_deleted (nentries[i]);\n-      else if (!is_empty (entry))\n-\tnentries[i] = entry;\n+      value_type *nentries = alloc_entries (size PASS_MEM_STAT);\n+      for (size_t i = 0; i < size; ++i)\n+\t{\n+\t  value_type &entry = h.m_entries[i];\n+\t  if (is_deleted (entry))\n+\t    mark_deleted (nentries[i]);\n+\t  else if (!is_empty (entry))\n+\t    nentries[i] = entry;\n+\t}\n+      m_entries = nentries;\n     }\n-  m_entries = nentries;\n   m_size = size;\n   m_size_prime_index = h.m_size_prime_index;\n }\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n-hash_table<Descriptor, Allocator>::~hash_table ()\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n+hash_table<Descriptor, Lazy, Allocator>::~hash_table ()\n {\n-  for (size_t i = m_size - 1; i < m_size; i--)\n-    if (!is_empty (m_entries[i]) && !is_deleted (m_entries[i]))\n-      Descriptor::remove (m_entries[i]);\n+  if (!Lazy || m_entries)\n+    {\n+      for (size_t i = m_size - 1; i < m_size; i--)\n+\tif (!is_empty (m_entries[i]) && !is_deleted (m_entries[i]))\n+\t  Descriptor::remove (m_entries[i]);\n \n-  if (!m_ggc)\n-    Allocator <value_type> ::data_free (m_entries);\n-  else\n-    ggc_free (m_entries);\n+      if (!m_ggc)\n+\tAllocator <value_type> ::data_free (m_entries);\n+      else\n+\tggc_free (m_entries);\n+    }\n \n   if (m_gather_mem_stats)\n     hash_table_usage ().release_instance_overhead (this,\n-\t\t\t\t\t\tsizeof (value_type) * m_size,\n-\t\t\t\t\t\ttrue);\n+\t\t\t\t\t\t   sizeof (value_type)\n+\t\t\t\t\t\t   * m_size, true);\n }\n \n /* This function returns an array of empty hash table elements.  */\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n-inline typename hash_table<Descriptor, Allocator>::value_type *\n-hash_table<Descriptor, Allocator>::alloc_entries (size_t n MEM_STAT_DECL) const\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n+inline typename hash_table<Descriptor, Lazy, Allocator>::value_type *\n+hash_table<Descriptor, Lazy,\n+\t   Allocator>::alloc_entries (size_t n MEM_STAT_DECL) const\n {\n   value_type *nentries;\n \n@@ -665,9 +692,11 @@ hash_table<Descriptor, Allocator>::alloc_entries (size_t n MEM_STAT_DECL) const\n    This function also assumes there are no deleted entries in the table.\n    HASH is the hash value for the element to be inserted.  */\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n-typename hash_table<Descriptor, Allocator>::value_type *\n-hash_table<Descriptor, Allocator>::find_empty_slot_for_expand (hashval_t hash)\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n+typename hash_table<Descriptor, Lazy, Allocator>::value_type *\n+hash_table<Descriptor, Lazy,\n+\t   Allocator>::find_empty_slot_for_expand (hashval_t hash)\n {\n   hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n   size_t size = m_size;\n@@ -694,9 +723,10 @@ hash_table<Descriptor, Allocator>::find_empty_slot_for_expand (hashval_t hash)\n \n /* Return true if the current table is excessively big for ELTS elements.  */\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n inline bool\n-hash_table<Descriptor, Allocator>::too_empty_p (unsigned int elts)\n+hash_table<Descriptor, Lazy, Allocator>::too_empty_p (unsigned int elts)\n {\n   return elts * 8 < m_size && m_size > 32;\n }\n@@ -708,9 +738,10 @@ hash_table<Descriptor, Allocator>::too_empty_p (unsigned int elts)\n    table entries is changed.  If memory allocation fails, this function\n    will abort.  */\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator>::expand ()\n+hash_table<Descriptor, Lazy, Allocator>::expand ()\n {\n   value_type *oentries = m_entries;\n   unsigned int oindex = m_size_prime_index;\n@@ -769,9 +800,10 @@ hash_table<Descriptor, Allocator>::expand ()\n \n /* Implements empty() in cases where it isn't a no-op.  */\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator>::empty_slow ()\n+hash_table<Descriptor, Lazy, Allocator>::empty_slow ()\n {\n   size_t size = m_size;\n   size_t nsize = size;\n@@ -819,9 +851,10 @@ hash_table<Descriptor, Allocator>::empty_slow ()\n    useful when you've already done the lookup and don't want to do it\n    again. */\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator>::clear_slot (value_type *slot)\n+hash_table<Descriptor, Lazy, Allocator>::clear_slot (value_type *slot)\n {\n   gcc_checking_assert (!(slot < m_entries || slot >= m_entries + size ()\n \t\t         || is_empty (*slot) || is_deleted (*slot)));\n@@ -836,15 +869,18 @@ hash_table<Descriptor, Allocator>::clear_slot (value_type *slot)\n    COMPARABLE element starting with the given HASH value.  It cannot\n    be used to insert or delete an element. */\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n-typename hash_table<Descriptor, Allocator>::value_type &\n-hash_table<Descriptor, Allocator>\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n+typename hash_table<Descriptor, Lazy, Allocator>::value_type &\n+hash_table<Descriptor, Lazy, Allocator>\n ::find_with_hash (const compare_type &comparable, hashval_t hash)\n {\n   m_searches++;\n   size_t size = m_size;\n   hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n \n+  if (Lazy && m_entries == NULL)\n+    m_entries = alloc_entries (size);\n   value_type *entry = &m_entries[index];\n   if (is_empty (*entry)\n       || (!is_deleted (*entry) && Descriptor::equal (*entry, comparable)))\n@@ -873,12 +909,20 @@ ::find_with_hash (const compare_type &comparable, hashval_t hash)\n    write the value you want into the returned slot.  When inserting an\n    entry, NULL may be returned if memory allocation fails. */\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n-typename hash_table<Descriptor, Allocator>::value_type *\n-hash_table<Descriptor, Allocator>\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n+typename hash_table<Descriptor, Lazy, Allocator>::value_type *\n+hash_table<Descriptor, Lazy, Allocator>\n ::find_slot_with_hash (const compare_type &comparable, hashval_t hash,\n \t\t       enum insert_option insert)\n {\n+  if (Lazy && m_entries == NULL)\n+    {\n+      if (insert == INSERT)\n+\tm_entries = alloc_entries (m_size);\n+      else\n+\treturn NULL;\n+    }\n   if (insert == INSERT && m_size * 3 <= m_n_elements * 4)\n     expand ();\n \n@@ -934,9 +978,10 @@ ::find_slot_with_hash (const compare_type &comparable, hashval_t hash,\n    from hash table starting with the given HASH.  If there is no\n    matching element in the hash table, this function does nothing. */\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator>\n+hash_table<Descriptor, Lazy, Allocator>\n ::remove_elt_with_hash (const compare_type &comparable, hashval_t hash)\n {\n   value_type *slot = find_slot_with_hash (comparable, hash, NO_INSERT);\n@@ -953,15 +998,18 @@ ::remove_elt_with_hash (const compare_type &comparable, hashval_t hash)\n    each live entry.  If CALLBACK returns false, the iteration stops.\n    ARGUMENT is passed as CALLBACK's second argument. */\n \n-template<typename Descriptor,\n+template<typename Descriptor, bool Lazy,\n \t  template<typename Type> class Allocator>\n template<typename Argument,\n-\t  int (*Callback)\n-     (typename hash_table<Descriptor, Allocator>::value_type *slot,\n-      Argument argument)>\n+\t int (*Callback)\n+\t (typename hash_table<Descriptor, Lazy, Allocator>::value_type *slot,\n+\t Argument argument)>\n void\n-hash_table<Descriptor, Allocator>::traverse_noresize (Argument argument)\n+hash_table<Descriptor, Lazy, Allocator>::traverse_noresize (Argument argument)\n {\n+  if (Lazy && m_entries == NULL)\n+    return;\n+\n   value_type *slot = m_entries;\n   value_type *limit = slot + size ();\n \n@@ -979,26 +1027,27 @@ hash_table<Descriptor, Allocator>::traverse_noresize (Argument argument)\n /* Like traverse_noresize, but does resize the table when it is too empty\n    to improve effectivity of subsequent calls.  */\n \n-template <typename Descriptor,\n+template <typename Descriptor, bool Lazy,\n \t  template <typename Type> class Allocator>\n template <typename Argument,\n \t  int (*Callback)\n-     (typename hash_table<Descriptor, Allocator>::value_type *slot,\n-      Argument argument)>\n+\t  (typename hash_table<Descriptor, Lazy, Allocator>::value_type *slot,\n+\t  Argument argument)>\n void\n-hash_table<Descriptor, Allocator>::traverse (Argument argument)\n+hash_table<Descriptor, Lazy, Allocator>::traverse (Argument argument)\n {\n-  if (too_empty_p (elements ()))\n+  if (too_empty_p (elements ()) && (!Lazy || m_entries))\n     expand ();\n \n   traverse_noresize <Argument, Callback> (argument);\n }\n \n /* Slide down the iterator slots until an active entry is found.  */\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator>::iterator::slide ()\n+hash_table<Descriptor, Lazy, Allocator>::iterator::slide ()\n {\n   for ( ; m_slot < m_limit; ++m_slot )\n     {\n@@ -1012,9 +1061,10 @@ hash_table<Descriptor, Allocator>::iterator::slide ()\n \n /* Bump the iterator.  */\n \n-template<typename Descriptor, template<typename Type> class Allocator>\n-inline typename hash_table<Descriptor, Allocator>::iterator &\n-hash_table<Descriptor, Allocator>::iterator::operator ++ ()\n+template<typename Descriptor, bool Lazy,\n+\t template<typename Type> class Allocator>\n+inline typename hash_table<Descriptor, Lazy, Allocator>::iterator &\n+hash_table<Descriptor, Lazy, Allocator>::iterator::operator ++ ()\n {\n   ++m_slot;\n   slide ();"}, {"sha": "9958db15ee0159f5e0cccae2dc974eff29ab6b0e", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "patch": "@@ -1,3 +1,8 @@\n+2019-03-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* jit-recording.c (reproducer::m_set_identifiers): Use false as Lazy\n+\tin hash_set template param.\n+\n 2019-02-05  Andrea Corallo <andrea.corallo@arm.com>\n \n \t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_11): New ABI tag."}, {"sha": "a332fe87514cad675c2057ff5f158fb830837906", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "patch": "@@ -245,7 +245,7 @@ class reproducer : public dump\n   {\n     static void remove (const char *) {}\n   };\n-  hash_set<const char *, hash_traits> m_set_identifiers;\n+  hash_set<const char *, false, hash_traits> m_set_identifiers;\n   allocator m_allocator;\n };\n "}]}