{"sha": "afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZlM2NjNzM4OGVmYTc4ZmU5YTViZDkxNGUwYTgzYjIwZWE2YWI5ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-05-15T11:30:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-05-15T11:30:29Z"}, "message": "tree-ssa-dse.c (dse_classify_store): Remove use_stmt parameter, add by_clobber_p one.\n\n2018-05-15  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-dse.c (dse_classify_store): Remove use_stmt parameter,\n\tadd by_clobber_p one.  Change algorithm to collect all defs\n\trepresenting uses we need to walk and try reducing them to\n\ta single one before failing.\n\t(dse_dom_walker::dse_optimize_stmt): Adjust.\n\n\t* gcc.dg/tree-ssa/ssa-dse-31.c: New testcase.\n\nFrom-SVN: r260253", "tree": {"sha": "95b8bbfd9e56bfc685fc06f8401e3985b4e0e04f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95b8bbfd9e56bfc685fc06f8401e3985b4e0e04f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "35b361b1164fbef3f1ca0349302dea7177156a1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b361b1164fbef3f1ca0349302dea7177156a1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35b361b1164fbef3f1ca0349302dea7177156a1c"}], "stats": {"total": 136, "additions": 94, "deletions": 42}, "files": [{"sha": "ecb524195ba4f7880e9d35106926d35c8139dc72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e", "patch": "@@ -1,3 +1,11 @@\n+2018-05-15  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-dse.c (dse_classify_store): Remove use_stmt parameter,\n+\tadd by_clobber_p one.  Change algorithm to collect all defs\n+\trepresenting uses we need to walk and try reducing them to\n+\ta single one before failing.\n+\t(dse_dom_walker::dse_optimize_stmt): Adjust.\n+\n 2018-05-13  Mark Wielaard  <mark@klomp.org>\n \n \t* dwarf2out.c (dwarf_OP): Handle DW_OP_addrx and DW_OP_constx."}, {"sha": "fe012a4d87e07d068ad0fa371a71e5f33b862b2a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e", "patch": "@@ -1,3 +1,7 @@\n+2018-05-15  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ssa-dse-31.c: New testcase.\n+\n 2018-05-15  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \tPR tree-optimization/83648"}, {"sha": "9ea9268fe1dd7dd0ac708a883257c734850d7a43", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-31.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-31.c?ref=afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-dse1-details\" } */\n+\n+void g();\n+void f(int n, char *p)\n+{\n+  *p = 0;\n+  if (n)\n+    {\n+      *p = 1;\n+      g();\n+    }\n+  *p = 2;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Deleted dead store\" 1 \"dse1\" } } */"}, {"sha": "126592a1d13f96a9342c78a219137ec49a5211a3", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 66, "deletions": 42, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=afe3cc7388efa78fe9a5bd914e0a83b20ea6ab9e", "patch": "@@ -516,18 +516,21 @@ live_bytes_read (ao_ref use_ref, ao_ref *ref, sbitmap live)\n }\n \n /* A helper of dse_optimize_stmt.\n-   Given a GIMPLE_ASSIGN in STMT that writes to REF, find a candidate\n-   statement *USE_STMT that may prove STMT to be dead.\n-   Return TRUE if the above conditions are met, otherwise FALSE.  */\n+   Given a GIMPLE_ASSIGN in STMT that writes to REF, classify it\n+   according to downstream uses and defs.  Sets *BY_CLOBBER_P to true\n+   if only clobber statements influenced the classification result.\n+   Returns the classification.  */\n \n static dse_store_status\n-dse_classify_store (ao_ref *ref, gimple *stmt, gimple **use_stmt,\n-\t\t    bool byte_tracking_enabled, sbitmap live_bytes)\n+dse_classify_store (ao_ref *ref, gimple *stmt,\n+\t\t    bool byte_tracking_enabled, sbitmap live_bytes,\n+\t\t    bool *by_clobber_p = NULL)\n {\n   gimple *temp;\n   unsigned cnt = 0;\n \n-  *use_stmt = NULL;\n+  if (by_clobber_p)\n+    *by_clobber_p = true;\n \n   /* Find the first dominated statement that clobbers (part of) the\n      memory stmt stores to with no intermediate statement that may use\n@@ -551,7 +554,7 @@ dse_classify_store (ao_ref *ref, gimple *stmt, gimple **use_stmt,\n       else\n \tdefvar = gimple_vdef (temp);\n       defvar_def = temp;\n-      temp = NULL;\n+      auto_vec<gimple *, 10> defs;\n       FOR_EACH_IMM_USE_STMT (use_stmt, ui, defvar)\n \t{\n \t  cnt++;\n@@ -569,9 +572,8 @@ dse_classify_store (ao_ref *ref, gimple *stmt, gimple **use_stmt,\n \t     See gcc.c-torture/execute/20051110-*.c.  */\n \t  else if (gimple_code (use_stmt) == GIMPLE_PHI)\n \t    {\n-\t      if (temp\n-\t\t  /* Make sure we are not in a loop latch block.  */\n-\t\t  || gimple_bb (stmt) == gimple_bb (use_stmt)\n+\t      /* Make sure we are not in a loop latch block.  */\n+\t      if (gimple_bb (stmt) == gimple_bb (use_stmt)\n \t\t  || dominated_by_p (CDI_DOMINATORS,\n \t\t\t\t     gimple_bb (stmt), gimple_bb (use_stmt))\n \t\t  /* We can look through PHIs to regions post-dominating\n@@ -589,15 +591,16 @@ dse_classify_store (ao_ref *ref, gimple *stmt, gimple **use_stmt,\n \t\t  && !dominated_by_p (CDI_DOMINATORS,\n \t\t\t\t      gimple_bb (defvar_def),\n \t\t\t\t      gimple_bb (use_stmt)))\n-\t\ttemp = use_stmt;\n+\t\tdefs.safe_push (use_stmt);\n \t    }\n \t  /* If the statement is a use the store is not dead.  */\n \t  else if (ref_maybe_used_by_stmt_p (use_stmt, ref))\n \t    {\n \t      /* Handle common cases where we can easily build an ao_ref\n \t\t structure for USE_STMT and in doing so we find that the\n \t\t references hit non-live bytes and thus can be ignored.  */\n-\t      if (byte_tracking_enabled && (!gimple_vdef (use_stmt) || !temp))\n+\t      if (byte_tracking_enabled\n+\t\t  && (!gimple_vdef (use_stmt) || defs.is_empty ()))\n \t\t{\n \t\t  if (is_gimple_assign (use_stmt))\n \t\t    {\n@@ -613,7 +616,7 @@ dse_classify_store (ao_ref *ref, gimple *stmt, gimple **use_stmt,\n \t\t\t  /* If this statement has a VDEF, then it is the\n \t\t\t     first store we have seen, so walk through it.  */\n \t\t\t  if (gimple_vdef (use_stmt))\n-\t\t\t    temp = use_stmt;\n+\t\t\t    defs.safe_push (use_stmt);\n \t\t\t  continue;\n \t\t\t}\n \t\t    }\n@@ -622,17 +625,10 @@ dse_classify_store (ao_ref *ref, gimple *stmt, gimple **use_stmt,\n \t      fail = true;\n \t      BREAK_FROM_IMM_USE_STMT (ui);\n \t    }\n-\t  /* If this is a store, remember it or bail out if we have\n-\t     multiple ones (the will be in different CFG parts then).  */\n+\t  /* If this is a store, remember it as we possibly need to walk the\n+\t     defs uses.  */\n \t  else if (gimple_vdef (use_stmt))\n-\t    {\n-\t      if (temp)\n-\t\t{\n-\t\t  fail = true;\n-\t\t  BREAK_FROM_IMM_USE_STMT (ui);\n-\t\t}\n-\t      temp = use_stmt;\n-\t    }\n+\t    defs.safe_push (use_stmt);\n \t}\n \n       if (fail)\n@@ -647,25 +643,54 @@ dse_classify_store (ao_ref *ref, gimple *stmt, gimple **use_stmt,\n       /* If we didn't find any definition this means the store is dead\n          if it isn't a store to global reachable memory.  In this case\n \t just pretend the stmt makes itself dead.  Otherwise fail.  */\n-      if (!temp)\n+      if (defs.is_empty ())\n \t{\n \t  if (ref_may_alias_global_p (ref))\n \t    return DSE_STORE_LIVE;\n \n-\t  temp = stmt;\n-\t  break;\n+\t  if (by_clobber_p)\n+\t    *by_clobber_p = false;\n+\t  return DSE_STORE_DEAD;\n \t}\n \n-      if (byte_tracking_enabled && temp)\n-\tclear_bytes_written_by (live_bytes, temp, ref);\n-    }\n-  /* Continue walking until we reach a full kill as a single statement\n-     or there are no more live bytes.  */\n-  while (!stmt_kills_ref_p (temp, ref)\n-\t && !(byte_tracking_enabled && bitmap_empty_p (live_bytes)));\n+      /* Process defs and remove paths starting with a kill from further\n+         processing.  */\n+      for (unsigned i = 0; i < defs.length (); ++i)\n+\tif (stmt_kills_ref_p (defs[i], ref))\n+\t  {\n+\t    if (by_clobber_p && !gimple_clobber_p (defs[i]))\n+\t      *by_clobber_p = false;\n+\t    defs.unordered_remove (i);\n+\t  }\n+\n+      /* If all defs kill the ref we are done.  */\n+      if (defs.is_empty ())\n+\treturn DSE_STORE_DEAD;\n+      /* If more than one def survives fail.  */\n+      if (defs.length () > 1)\n+\t{\n+\t  /* STMT might be partially dead and we may be able to reduce\n+\t     how many memory locations it stores into.  */\n+\t  if (byte_tracking_enabled && !gimple_clobber_p (stmt))\n+\t    return DSE_STORE_MAYBE_PARTIAL_DEAD;\n+\t  return DSE_STORE_LIVE;\n+\t}\n+      temp = defs[0];\n \n-  *use_stmt = temp;\n-  return DSE_STORE_DEAD;\n+      /* Track partial kills.  */\n+      if (byte_tracking_enabled)\n+\t{\n+\t  clear_bytes_written_by (live_bytes, temp, ref);\n+\t  if (bitmap_empty_p (live_bytes))\n+\t    {\n+\t      if (by_clobber_p && !gimple_clobber_p (temp))\n+\t\t*by_clobber_p = false;\n+\t      return DSE_STORE_DEAD;\n+\t    }\n+\t}\n+    }\n+  /* Continue walking until there are no more live bytes.  */\n+  while (1);\n }\n \n \n@@ -795,11 +820,10 @@ dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \t\t  return;\n \t\t}\n \n-\t      gimple *use_stmt;\n \t      enum dse_store_status store_status;\n \t      m_byte_tracking_enabled\n \t\t= setup_live_bytes_from_ref (&ref, m_live_bytes);\n-\t      store_status = dse_classify_store (&ref, stmt, &use_stmt,\n+\t      store_status = dse_classify_store (&ref, stmt,\n \t\t\t\t\t\t m_byte_tracking_enabled,\n \t\t\t\t\t\t m_live_bytes);\n \t      if (store_status == DSE_STORE_LIVE)\n@@ -823,20 +847,20 @@ dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \n   if (is_gimple_assign (stmt))\n     {\n-      gimple *use_stmt;\n+      bool by_clobber_p = false;\n \n       /* Self-assignments are zombies.  */\n       if (operand_equal_p (gimple_assign_rhs1 (stmt),\n \t\t\t   gimple_assign_lhs (stmt), 0))\n-\tuse_stmt = stmt;\n+\t;\n       else\n \t{\n \t  m_byte_tracking_enabled\n \t    = setup_live_bytes_from_ref (&ref, m_live_bytes);\n \t  enum dse_store_status store_status;\n-\t  store_status = dse_classify_store (&ref, stmt, &use_stmt,\n+\t  store_status = dse_classify_store (&ref, stmt,\n \t\t\t\t\t     m_byte_tracking_enabled,\n-\t\t\t\t\t     m_live_bytes);\n+\t\t\t\t\t     m_live_bytes, &by_clobber_p);\n \t  if (store_status == DSE_STORE_LIVE)\n \t    return;\n \n@@ -852,7 +876,7 @@ dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n       /* But only remove *this_2(D) ={v} {CLOBBER} if killed by\n \t another clobber stmt.  */\n       if (gimple_clobber_p (stmt)\n-\t  && !gimple_clobber_p (use_stmt))\n+\t  && !by_clobber_p)\n \treturn;\n \n       delete_dead_assignment (gsi);"}]}