{"sha": "4514aa8c6728182bf47343a8acbcec44e326f78e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUxNGFhOGM2NzI4MTgyYmY0NzM0M2E4YWNiY2VjNDRlMzI2Zjc4ZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-01-05T10:02:35Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-01-05T10:02:35Z"}, "message": "re PR c++/19030 (ice on tree check)\n\ncp:\n\tPR c++/19030\n\t* cp-tree.h (start_decl): Take pointer to pushed scope, not bool.\n\t* name-lookup.h (push_scope): Return pushed scope, not flag.\n\t* name-lookup.c (push_scope): Return scope that should be popped,\n\tnot a flag.\n\t* decl.c (start_decl): Adjust.\n\t(grokfndecl): Adjust scope push and pop.\n\t* decl2.c (check_classfn): Likewise.\n\t* parser.c (cp_parser_condition, cp_parser_conversion_function_id,\n\tcp_parser_init_declarator, cp_parser_direct_declarator,\n\tcp_parser_class_specifier, cp_parser_class_head,\n\tcp_parser_lookup_name,\n\tcp_parser_constructor_declarator_p): Likewise.\n\t* pt.c (instantiate_class_template,\n\tresolve_typename_type): Likewise.\ntestsuite:\n\tPR c++/19030\n\t* g++.dg/parse/crash22.C: New\n\nFrom-SVN: r92946", "tree": {"sha": "125c8a7510120f2b97f1db6304937bded22e622d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/125c8a7510120f2b97f1db6304937bded22e622d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4514aa8c6728182bf47343a8acbcec44e326f78e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4514aa8c6728182bf47343a8acbcec44e326f78e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4514aa8c6728182bf47343a8acbcec44e326f78e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4514aa8c6728182bf47343a8acbcec44e326f78e/comments", "author": null, "committer": null, "parents": [{"sha": "c2b43d7ab2ebe17d1f68e1ba4aa99c7d5a1c06aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b43d7ab2ebe17d1f68e1ba4aa99c7d5a1c06aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b43d7ab2ebe17d1f68e1ba4aa99c7d5a1c06aa"}], "stats": {"total": 249, "additions": 145, "deletions": 104}, "files": [{"sha": "4f3e21003e8d0686e5aaeed0dff6b2f0e87d058e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4514aa8c6728182bf47343a8acbcec44e326f78e", "patch": "@@ -1,3 +1,21 @@\n+2005-01-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/19030\n+\t* cp-tree.h (start_decl): Take pointer to pushed scope, not bool.\n+\t* name-lookup.h (push_scope): Return pushed scope, not flag.\n+\t* name-lookup.c (push_scope): Return scope that should be popped,\n+\tnot a flag.\n+\t* decl.c (start_decl): Adjust.\n+\t(grokfndecl): Adjust scope push and pop.\n+\t* decl2.c (check_classfn): Likewise.\n+\t* parser.c (cp_parser_condition, cp_parser_conversion_function_id,\n+\tcp_parser_init_declarator, cp_parser_direct_declarator,\n+\tcp_parser_class_specifier, cp_parser_class_head,\n+\tcp_parser_lookup_name,\n+\tcp_parser_constructor_declarator_p): Likewise.\n+\t* pt.c (instantiate_class_template,\n+\tresolve_typename_type): Likewise.\n+\n 2005-01-03  Volker Reichelt  <reichelt@igpm.rwth-aaachen.de>\n \n \tPR c++/14136"}, {"sha": "83e4f4255c1f12173dc676a1a5f5a9ca73113473", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4514aa8c6728182bf47343a8acbcec44e326f78e", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for C++ parsing and type checking.\n    Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -3780,7 +3780,7 @@ extern int init_type_desc\t\t\t(void);\n extern tree check_tag_decl\t\t\t(cp_decl_specifier_seq *);\n extern tree shadow_tag\t\t\t\t(cp_decl_specifier_seq *);\n extern tree groktypename\t\t\t(cp_decl_specifier_seq *, const cp_declarator *);\n-extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int, tree, tree, bool *);\n+extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int, tree, tree, tree *);\n extern void start_decl_1\t\t\t(tree);\n extern void cp_finish_decl\t\t\t(tree, tree, tree, int);\n extern void finish_decl\t\t\t\t(tree, tree, tree);"}, {"sha": "07d8543d249fe3ac9f396e40af6a1e402710e800", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4514aa8c6728182bf47343a8acbcec44e326f78e", "patch": "@@ -1,6 +1,6 @@\n /* Process declarations and variables for C++ compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004,2005  Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -3687,13 +3687,13 @@ start_decl (const cp_declarator *declarator,\n             int initialized,\n             tree attributes,\n             tree prefix_attributes, \n-\t    bool *pop_scope_p)\n+\t    tree *pushed_scope_p)\n {\n   tree decl;\n   tree type, tem;\n   tree context;\n \n-  *pop_scope_p = false;\n+  *pushed_scope_p = NULL_TREE;\n  \n   /* This should only be done once on the top most decl.  */\n   if (have_extern_spec)\n@@ -3725,11 +3725,13 @@ start_decl (const cp_declarator *declarator,\n   context = DECL_CONTEXT (decl);\n \n   if (context)\n-    *pop_scope_p = push_scope (context);\n+    {\n+      *pushed_scope_p = push_scope (context);\n   \n-  /* We are only interested in class contexts, later.  */\n-  if (context && TREE_CODE (context) == NAMESPACE_DECL)\n-    context = NULL_TREE;\n+      /* We are only interested in class contexts, later.  */\n+      if (TREE_CODE (context) == NAMESPACE_DECL)\n+\tcontext = NULL_TREE;\n+    }\n \n   if (initialized)\n     /* Is it valid for this decl to have an initializer at all?\n@@ -5893,7 +5895,7 @@ grokfndecl (tree ctype,\n       if (old_decl)\n \t{\n \t  tree ok;\n-\t  bool pop_p;\n+\t  tree pushed_scope;\n \n \t  /* Since we've smashed OLD_DECL to its\n \t     DECL_TEMPLATE_RESULT, we must do the same to DECL.  */\n@@ -5902,10 +5904,10 @@ grokfndecl (tree ctype,\n \n \t  /* Attempt to merge the declarations.  This can fail, in\n \t     the case of some invalid specialization declarations.  */\n-\t  pop_p = push_scope (ctype);\n+\t  pushed_scope = push_scope (ctype);\n \t  ok = duplicate_decls (decl, old_decl);\n-\t  if (pop_p)\n-\t    pop_scope (ctype);\n+\t  if (pushed_scope)\n+\t    pop_scope (pushed_scope);\n \t  if (!ok)\n \t    {\n \t      error (\"no %q#D member function declared in class %qT\","}, {"sha": "012ec59185ec85ddde1dd33ca993a29c61a33e20", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4514aa8c6728182bf47343a8acbcec44e326f78e", "patch": "@@ -1,6 +1,6 @@\n /* Process declarations and variables for C++ compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -627,10 +627,10 @@ check_classfn (tree ctype, tree function, tree template_parms)\n       VEC(tree) *methods = CLASSTYPE_METHOD_VEC (ctype);\n       tree fndecls, fndecl = 0;\n       bool is_conv_op;\n-      bool pop_p;\n+      tree pushed_scope;\n       const char *format = NULL;\n       \n-      pop_p = push_scope (ctype);\n+      pushed_scope = push_scope (ctype);\n       for (fndecls = VEC_index (tree, methods, ix);\n \t   fndecls; fndecls = OVL_NEXT (fndecls))\n \t{\n@@ -669,8 +669,8 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \t\t      == DECL_TI_TEMPLATE (fndecl))))\n \t    break;\n \t}\n-      if (pop_p)\n-\tpop_scope (ctype);\n+      if (pushed_scope)\n+\tpop_scope (pushed_scope);\n       if (fndecls)\n \treturn OVL_CURRENT (fndecls);\n       error (\"prototype for %q#D does not match any in class %qT\","}, {"sha": "ac5ad911b2fc0097630d9f44b369b6eb468f6314", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=4514aa8c6728182bf47343a8acbcec44e326f78e", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for C++ name lookup routines.\n-   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n This file is part of GCC.\n@@ -2214,16 +2214,14 @@ is_ancestor (tree root, tree child)\n     }\n }\n \n-/* Enter the class or namespace scope indicated by T suitable for\n-   name lookup.  T can be arbitrary scope, not necessary nested inside\n-   the current scope.  Returns TRUE iff pop_scope should be called\n-   later to exit this scope.  */\n+/* Enter the class or namespace scope indicated by T suitable for name\n+   lookup.  T can be arbitrary scope, not necessary nested inside the\n+   current scope.  Returns a non-null scope to pop iff pop_scope\n+   should be called later to exit this scope.  */\n \n-bool\n+tree\n push_scope (tree t)\n {\n-  bool pop = true;\n-\n   if (TREE_CODE (t) == NAMESPACE_DECL)\n     push_decl_namespace (t);\n   else if (CLASS_TYPE_P (t))\n@@ -2236,10 +2234,10 @@ push_scope (tree t)\n \t   need to re-enter the scope.  Since we are not actually\n \t   pushing a new scope, our caller should not call\n \t   pop_scope.  */\n-\tpop = false;\n+\tt = NULL_TREE;\n     }\n \n-  return pop;\n+  return t;\n }\n \n /* Leave scope pushed by push_scope.  */"}, {"sha": "7c6f9263b193f067fed5ac43623352e8615e83fc", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=4514aa8c6728182bf47343a8acbcec44e326f78e", "patch": "@@ -1,5 +1,5 @@\n /* Declarations for C++ name lookup routines.\n-   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n This file is part of GCC.\n@@ -299,7 +299,7 @@ extern void pop_from_top_level (void);\n extern void pop_everything (void);\n extern void keep_next_level (bool);\n extern bool is_ancestor (tree, tree);\n-extern bool push_scope (tree);\n+extern tree push_scope (tree);\n extern void pop_scope (tree);\n extern tree push_inner_scope (tree);\n extern void pop_inner_scope (tree, tree);"}, {"sha": "4ca03aaa9ba8d327f1c3038167409ac276db7786", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 58, "deletions": 65, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4514aa8c6728182bf47343a8acbcec44e326f78e", "patch": "@@ -1,5 +1,6 @@\n /* C++ Parser.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004,\n+   2005  Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>.\n \n    This file is part of GCC.\n@@ -6231,13 +6232,13 @@ cp_parser_condition (cp_parser* parser)\n \t for sure.  */\n       if (cp_parser_parse_definitely (parser))\n \t{\n-\t  bool pop_p;\t\n+\t  tree pushed_scope;\t\n \n \t  /* Create the declaration.  */\n \t  decl = start_decl (declarator, &type_specifiers,\n \t\t\t     /*initialized_p=*/true,\n \t\t\t     attributes, /*prefix_attributes=*/NULL_TREE,\n-\t\t\t     &pop_p);\n+\t\t\t     &pushed_scope);\n \t  /* Parse the assignment-expression.  */\n \t  initializer = cp_parser_assignment_expression (parser);\n \n@@ -6247,8 +6248,8 @@ cp_parser_condition (cp_parser* parser)\n \t\t\t  asm_specification,\n \t\t\t  LOOKUP_ONLYCONVERTING);\n \n-\t  if (pop_p)\n-\t    pop_scope (DECL_CONTEXT (decl));\n+\t  if (pushed_scope)\n+\t    pop_scope (pushed_scope);\n \n \t  return convert_from_reference (decl);\n \t}\n@@ -7397,7 +7398,7 @@ cp_parser_conversion_function_id (cp_parser* parser)\n   tree saved_scope;\n   tree saved_qualifying_scope;\n   tree saved_object_scope;\n-  bool pop_p = false;\n+  tree pushed_scope = NULL_TREE;\n \n   /* Look for the `operator' token.  */\n   if (!cp_parser_require_keyword (parser, RID_OPERATOR, \"`operator'\"))\n@@ -7422,12 +7423,12 @@ cp_parser_conversion_function_id (cp_parser* parser)\n      In order to see that `I' is a type-name in the definition, we\n      must be in the scope of `S'.  */\n   if (saved_scope)\n-    pop_p = push_scope (saved_scope);\n+    pushed_scope = push_scope (saved_scope);\n   /* Parse the conversion-type-id.  */\n   type = cp_parser_conversion_type_id (parser);\n   /* Leave the scope of the class, if any.  */\n-  if (pop_p)\n-    pop_scope (saved_scope);\n+  if (pushed_scope)\n+    pop_scope (pushed_scope);\n   /* Restore the saved scope.  */\n   parser->scope = saved_scope;\n   parser->qualifying_scope = saved_qualifying_scope;\n@@ -10426,7 +10427,7 @@ cp_parser_init_declarator (cp_parser* parser,\n   bool is_non_constant_init;\n   int ctor_dtor_or_conv_p;\n   bool friend_p;\n-  bool pop_p = false;\n+  tree pushed_scope = NULL;\n \n   /* Gather the attributes that were provided with the\n      decl-specifiers.  */\n@@ -10583,12 +10584,12 @@ cp_parser_init_declarator (cp_parser* parser,\n \t}\n       decl = start_decl (declarator, decl_specifiers,\n \t\t\t is_initialized, attributes, prefix_attributes,\n-\t\t\t &pop_p);\n+\t\t\t &pushed_scope);\n     }\n   else if (scope)\n     /* Enter the SCOPE.  That way unqualified names appearing in the\n        initializer will be looked up in SCOPE.  */\n-    pop_p = push_scope (scope);\n+    pushed_scope = push_scope (scope);\n \n   /* Perform deferred access control checks, now that we know in which\n      SCOPE the declared entity resides.  */\n@@ -10638,10 +10639,10 @@ cp_parser_init_declarator (cp_parser* parser,\n      declaration.  */\n   if (member_p)\n     {\n-      if (pop_p)\n+      if (pushed_scope)\n \t{\n-\t  pop_scope (scope);\n-\t  pop_p = false;\n+\t  pop_scope (pushed_scope);\n+\t  pushed_scope = false;\n \t}\n       decl = grokfield (declarator, decl_specifiers,\n \t\t\tinitializer, /*asmspec=*/NULL_TREE,\n@@ -10663,9 +10664,9 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t\t `explicit' constructor cannot be used.  */\n \t\t      ((is_parenthesized_init || !is_initialized)\n \t\t     ? 0 : LOOKUP_ONLYCONVERTING));\n-      if (pop_p)\n-\tpop_scope (DECL_CONTEXT (decl));\n     }\n+  if (!friend_p && pushed_scope)\n+    pop_scope (pushed_scope);\n \n   /* Remember whether or not variables were initialized by\n      constant-expressions.  */\n@@ -10836,7 +10837,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n   bool saved_default_arg_ok_p = parser->default_arg_ok_p;\n   bool saved_in_declarator_p = parser->in_declarator_p;\n   bool first = true;\n-  bool pop_p = false;\n+  tree pushed_scope = NULL_TREE;\n \n   while (true)\n     {\n@@ -11136,7 +11137,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  if (scope)\n \t    /* Any names that appear after the declarator-id for a\n \t       member are looked up in the containing scope.  */\n-\t    pop_p = push_scope (scope);\n+\t    pushed_scope = push_scope (scope);\n \t  parser->in_declarator_p = true;\n \t  if ((ctor_dtor_or_conv_p && *ctor_dtor_or_conv_p)\n \t      || (declarator && declarator->kind == cdk_id))\n@@ -11159,8 +11160,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n     cp_parser_error (parser, \"expected declarator\");\n \n   /* If we entered a scope, we must exit it now.  */\n-  if (pop_p)\n-    pop_scope (scope);\n+  if (pushed_scope)\n+    pop_scope (pushed_scope);\n \n   parser->default_arg_ok_p = saved_default_arg_ok_p;\n   parser->in_declarator_p = saved_in_declarator_p;\n@@ -12350,8 +12351,8 @@ cp_parser_class_specifier (cp_parser* parser)\n     {\n       tree queue_entry;\n       tree fn;\n-      tree class_type;\n-      bool pop_p;\n+      tree class_type = NULL_TREE;\n+      tree pushed_scope = NULL_TREE;\n \n       /* In a first pass, parse default arguments to the functions.\n \t Then, in a second pass, parse the bodies of the functions.\n@@ -12363,8 +12364,6 @@ cp_parser_class_specifier (cp_parser* parser)\n             };\n \n          */\n-      class_type = NULL_TREE;\n-      pop_p = false;\n       for (TREE_PURPOSE (parser->unparsed_functions_queues)\n \t     = nreverse (TREE_PURPOSE (parser->unparsed_functions_queues));\n \t   (queue_entry = TREE_PURPOSE (parser->unparsed_functions_queues));\n@@ -12376,10 +12375,10 @@ cp_parser_class_specifier (cp_parser* parser)\n \t     take care of them now.  */\n \t  if (class_type != TREE_PURPOSE (queue_entry))\n \t    {\n-\t      if (pop_p)\n-\t\tpop_scope (class_type);\n+\t      if (pushed_scope)\n+\t\tpop_scope (pushed_scope);\n \t      class_type = TREE_PURPOSE (queue_entry);\n-\t      pop_p = push_scope (class_type);\n+\t      pushed_scope = push_scope (class_type);\n \t    }\n \t  /* Make sure that any template parameters are in scope.  */\n \t  maybe_begin_member_template_processing (fn);\n@@ -12388,8 +12387,8 @@ cp_parser_class_specifier (cp_parser* parser)\n \t  /* Remove any template parameters from the symbol table.  */\n \t  maybe_end_member_template_processing ();\n \t}\n-      if (pop_p)\n-\tpop_scope (class_type);\n+      if (pushed_scope)\n+\tpop_scope (pushed_scope);\n       /* Now parse the body of the functions.  */\n       for (TREE_VALUE (parser->unparsed_functions_queues)\n \t     = nreverse (TREE_VALUE (parser->unparsed_functions_queues));\n@@ -12457,7 +12456,7 @@ cp_parser_class_head (cp_parser* parser,\n   bool qualified_p = false;\n   bool invalid_nested_name_p = false;\n   bool invalid_explicit_specialization_p = false;\n-  bool pop_p = false;\n+  tree pushed_scope = NULL_TREE;\n   unsigned num_templates;\n   tree bases;\n \n@@ -12675,19 +12674,12 @@ cp_parser_class_head (cp_parser* parser,\n     {\n       type = TREE_TYPE (id);\n       maybe_process_partial_specialization (type);\n+      if (nested_name_specifier)\n+\tpushed_scope = push_scope (nested_name_specifier);\n     }\n-  else if (!nested_name_specifier)\n-    {\n-      /* If the class was unnamed, create a dummy name.  */\n-      if (!id)\n-\tid = make_anon_name ();\n-      type = xref_tag (class_key, id, /*tag_scope=*/ts_current,\n-\t\t       parser->num_template_parameter_lists);\n-    }\n-  else\n+  else if (nested_name_specifier)\n     {\n       tree class_type;\n-      bool pop_p = false;\n \n       /* Given:\n \n@@ -12713,8 +12705,7 @@ cp_parser_class_head (cp_parser* parser,\n       maybe_process_partial_specialization (TREE_TYPE (type));\n       class_type = current_class_type;\n       /* Enter the scope indicated by the nested-name-specifier.  */\n-      if (nested_name_specifier)\n-\tpop_p = push_scope (nested_name_specifier);\n+      pushed_scope = push_scope (nested_name_specifier);\n       /* Get the canonical version of this type.  */\n       type = TYPE_MAIN_DECL (TREE_TYPE (type));\n       if (PROCESSING_REAL_TEMPLATE_DECL_P ()\n@@ -12729,29 +12720,31 @@ cp_parser_class_head (cp_parser* parser,\n \t}\n       \n       type = TREE_TYPE (type);\n-      if (nested_name_specifier)\n-\t{\n-\t  *nested_name_specifier_p = true;\n-\t  if (pop_p)\n-\t    pop_scope (nested_name_specifier);\n-\t}\n+      *nested_name_specifier_p = true;\n     }\n+  else      /* The name is not a nested name.  */\n+    {\n+      /* If the class was unnamed, create a dummy name.  */\n+      if (!id)\n+\tid = make_anon_name ();\n+      type = xref_tag (class_key, id, /*tag_scope=*/ts_current,\n+\t\t       parser->num_template_parameter_lists);\n+    }\n+\n   /* Indicate whether this class was declared as a `class' or as a\n      `struct'.  */\n   if (TREE_CODE (type) == RECORD_TYPE)\n     CLASSTYPE_DECLARED_CLASS (type) = (class_key == class_type);\n   cp_parser_check_class_key (class_key, type);\n \n-  /* Enter the scope containing the class; the names of base classes\n-     should be looked up in that context.  For example, given:\n+  /* We will have entered the scope containing the class; the names of\n+     base classes should be looked up in that context.  For example,\n+     given:\n \n        struct A { struct B {}; struct C; };\n        struct A::C : B {};\n \n      is valid.  */\n-  if (nested_name_specifier)\n-    pop_p = push_scope (nested_name_specifier);\n-\n   bases = NULL_TREE;\n \n   /* Get the list of base-classes, if there is one.  */\n@@ -12761,12 +12754,12 @@ cp_parser_class_head (cp_parser* parser,\n   /* Process the base classes.  */\n   xref_basetypes (type, bases);\n \n+ done:\n   /* Leave the scope given by the nested-name-specifier.  We will\n      enter the class scope itself while processing the members.  */\n-  if (pop_p)\n-    pop_scope (nested_name_specifier);\n+  if (pushed_scope)\n+    pop_scope (pushed_scope);\n \n- done:\n   if (invalid_explicit_specialization_p)\n     {\n       end_specialization ();\n@@ -14207,24 +14200,24 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t}\n       else\n \t{\n-\t  bool pop_p = false;\n+\t  tree pushed_scope = NULL_TREE;\n \n \t  /* If PARSER->SCOPE is a dependent type, then it must be a\n \t     class type, and we must not be checking dependencies;\n \t     otherwise, we would have processed this lookup above.  So\n \t     that PARSER->SCOPE is not considered a dependent base by\n \t     lookup_member, we must enter the scope here.  */\n \t  if (dependent_p)\n-\t    pop_p = push_scope (parser->scope);\n+\t    pushed_scope = push_scope (parser->scope);\n \t  /* If the PARSER->SCOPE is a a template specialization, it\n \t     may be instantiated during name lookup.  In that case,\n \t     errors may be issued.  Even if we rollback the current\n \t     tentative parse, those errors are valid.  */\n \t  decl = lookup_qualified_name (parser->scope, name, \n \t\t\t\t\ttag_type != none_type, \n \t\t\t\t\t/*complain=*/true);\n-\t  if (pop_p)\n-\t    pop_scope (parser->scope);\n+\t  if (pushed_scope)\n+\t    pop_scope (pushed_scope);\n \t}\n       parser->qualifying_scope = parser->scope;\n       parser->object_scope = NULL_TREE;\n@@ -14600,7 +14593,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t  && !cp_parser_storage_class_specifier_opt (parser))\n \t{\n \t  tree type;\n-\t  bool pop_p = false;\n+\t  tree pushed_scope = NULL_TREE;\n \t  unsigned saved_num_template_parameter_lists;\n \n \t  /* Names appearing in the type-specifier should be looked up\n@@ -14620,7 +14613,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t\t      return false;\n \t\t    }\n \t\t}\n-\t      pop_p = push_scope (type);\n+\t      pushed_scope = push_scope (type);\n \t    }\n \n \t  /* Inside the constructor parameter list, surrounding\n@@ -14641,8 +14634,8 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t    = saved_num_template_parameter_lists;\n \n \t  /* Leave the scope of the class.  */\n-\t  if (pop_p)\n-\t    pop_scope (type);\n+\t  if (pushed_scope)\n+\t    pop_scope (pushed_scope);\n \n \t  constructor_p = !cp_parser_error_occurred (parser);\n \t}"}, {"sha": "f24865e8f108e7fc572dfbd124fb6c0748292101", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4514aa8c6728182bf47343a8acbcec44e326f78e", "patch": "@@ -1,6 +1,6 @@\n /* Handle parameterized types (templates) for GNU C++.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004  Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.\n    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.\n    Rewritten by Jason Merrill (jason@cygnus.com).\n \n@@ -5578,13 +5578,13 @@ instantiate_class_template (tree type)\n     {\n       tree pbase_binfo;\n       tree context = TYPE_CONTEXT (type);\n-      bool pop_p;\n+      tree pushed_scope;\n       int i;\n \n       /* We must enter the scope containing the type, as that is where\n \t the accessibility of types named in dependent bases are\n \t looked up from.  */\n-      pop_p = push_scope (context ? context : global_namespace);\n+      pushed_scope = push_scope (context ? context : global_namespace);\n   \n       /* Substitute into each of the bases to determine the actual\n \t basetypes.  */\n@@ -5606,8 +5606,8 @@ instantiate_class_template (tree type)\n       /* The list is now in reverse order; correct that.  */\n       base_list = nreverse (base_list);\n \n-      if (pop_p)\n-\tpop_scope (context ? context : global_namespace);\n+      if (pushed_scope)\n+\tpop_scope (pushed_scope);\n     }\n   /* Now call xref_basetypes to set up all the base-class\n      information.  */\n@@ -12286,7 +12286,7 @@ resolve_typename_type (tree type, bool only_current_p)\n   tree name;\n   tree decl;\n   int quals;\n-  bool pop_p;\n+  tree pushed_scope;\n \n   gcc_assert (TREE_CODE (type) == TYPENAME_TYPE);\n \n@@ -12315,7 +12315,7 @@ resolve_typename_type (tree type, bool only_current_p)\n   /* Enter the SCOPE so that name lookup will be resolved as if we\n      were in the class definition.  In particular, SCOPE will no\n      longer be considered a dependent type.  */\n-  pop_p = push_scope (scope);\n+  pushed_scope = push_scope (scope);\n   /* Look up the declaration.  */\n   decl = lookup_member (scope, name, /*protect=*/0, /*want_type=*/true);\n   /* Obtain the set of qualifiers applied to the TYPE.  */\n@@ -12345,8 +12345,8 @@ resolve_typename_type (tree type, bool only_current_p)\n   if (type != error_mark_node && quals)\n     type = cp_build_qualified_type (type, quals);\n   /* Leave the SCOPE.  */\n-  if (pop_p)\n-    pop_scope (scope);\n+  if (pushed_scope)\n+    pop_scope (pushed_scope);\n \n   return type;\n }"}, {"sha": "d9dc42b8ef3934d6da1105c20af9515ffe85cbd6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4514aa8c6728182bf47343a8acbcec44e326f78e", "patch": "@@ -1,3 +1,8 @@\n+2005-01-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/19030\n+\t* g++.dg/parse/crash22.C: New\n+\n 2005-01-04  Geoffrey Keating  <geoffk@apple.com>\n \n \tPR 19257"}, {"sha": "d4fe6d15a8ebf70d66d3e9aa910bb7b89e098b2b", "filename": "gcc/testsuite/g++.dg/parse/crash22.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4514aa8c6728182bf47343a8acbcec44e326f78e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash22.C?ref=4514aa8c6728182bf47343a8acbcec44e326f78e", "patch": "@@ -0,0 +1,25 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 Jan 2005 <nathan@codesourcery.com>\n+\n+// PR 19030: ICE\n+// Origin: Volker Reichelt <reichelt@gcc.gnu.org>\n+\n+struct A;\n+\n+namespace N\n+{\n+  struct A;\n+}\n+\n+using namespace N;\n+\n+int A::i; // { dg-error \"not been declared|declared here\" \"\" }\n+int A::i; // { dg-error \"not been declared|redefinition of\" \"\" }\n+\n+namespace N\n+{\n+    struct C;\n+    struct C {};\n+}\n+\n+class D : N::C {};"}]}