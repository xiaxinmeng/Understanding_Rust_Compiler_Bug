{"sha": "2005b9b888eeac078f2524b1521885f4b5453894", "node_id": "C_kwDOANBUbNoAKDIwMDViOWI4ODhlZWFjMDc4ZjI1MjRiMTUyMTg4NWY0YjU0NTM4OTQ", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2022-06-07T11:09:47Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2022-06-07T11:12:20Z"}, "message": "arm: Improve code generation for BFI and BFC [PR105090]\n\nThis patch, in response to PR105090, makes some general improvements\nto the code generation when BFI and BFC instructions are available.\nFirstly we handle more cases where the RTL does not generate an INSV\noperation due to a lack of a tie between the input and output, but we\nnevertheless need to emit BFI later on; we handle this by requiring\nthe register allocator to tie the operands.  Secondly we handle some\ncases where we were previously emitting BFC, but AND with an immediate\nwould be better; we do this by converting all BFC patterns into AND\nusing a split pattern.  And finally, we handle some cases where\npreviously we would emit multiple BIC operations to clear a value, but\ncould instead use a single BFC instruction.\n\nBFC and BFI express the mask as a pair of values, one for the number\nof bits to clear and another for the location of the least significant\nbit.  We handle these with a single new output modifier letter that\ncauses both values to be printed; we use an 'inverted' value so that\nit can be used directly with the constant used in an AND rtl\nconstruct.  We've run out of 'new' letters, so to do this we re-use\none of the long-obsoleted Maverick output modifiers.\n\ngcc/ChangeLog:\n\n\tPR target/105090\n\t* config/arm/arm.cc (arm_bfi_1_p): New function.\n\t(arm_bfi_p): New function.\n\t(arm_rtx_costs_internal): Add costs for BFI idioms.\n\t(arm_print_operand [case 'V']): Format output for BFI/BFC masks.\n\t* config/arm/constraints.md (Dj): New constraint.\n\t* config/arm/arm.md (arm_andsi3_insn): Add alternative to use BFC.\n\t(insv_zero): Convert to an insn with a split.\n\t(*bfi, *bfi_alt1, *bfi_alt2, *bfi_alt3): New patterns.", "tree": {"sha": "7feb149446b78c04b04813229950996e9beb1010", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7feb149446b78c04b04813229950996e9beb1010"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2005b9b888eeac078f2524b1521885f4b5453894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2005b9b888eeac078f2524b1521885f4b5453894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2005b9b888eeac078f2524b1521885f4b5453894", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2005b9b888eeac078f2524b1521885f4b5453894/comments", "author": null, "committer": null, "parents": [{"sha": "cd22395457f063824c839fd1c0077d15d3dccd6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd22395457f063824c839fd1c0077d15d3dccd6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd22395457f063824c839fd1c0077d15d3dccd6d"}], "stats": {"total": 229, "additions": 208, "deletions": 21}, "files": [{"sha": "2a76c7b9a72c7102295a978e09ec9d10c5406f3e", "filename": "gcc/config/arm/arm.cc", "status": "modified", "additions": 102, "deletions": 11, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2005b9b888eeac078f2524b1521885f4b5453894/gcc%2Fconfig%2Farm%2Farm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2005b9b888eeac078f2524b1521885f4b5453894/gcc%2Fconfig%2Farm%2Farm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.cc?ref=2005b9b888eeac078f2524b1521885f4b5453894", "patch": "@@ -10201,6 +10201,61 @@ arm_mem_costs (rtx x, const struct cpu_cost_table *extra_cost,\n   return true;\n }\n \n+/* Helper for arm_bfi_p.  */\n+static bool\n+arm_bfi_1_p (rtx op0, rtx op1, rtx *sub0, rtx *sub1)\n+{\n+  unsigned HOST_WIDE_INT const1;\n+  unsigned HOST_WIDE_INT const2 = 0;\n+\n+  if (!CONST_INT_P (XEXP (op0, 1)))\n+    return false;\n+\n+  const1 = XUINT (XEXP (op0, 1), 0);\n+  if (!CONST_INT_P (XEXP (op1, 1))\n+      || ~XUINT (XEXP (op1, 1), 0) != const1)\n+    return false;\n+\n+  if (GET_CODE (XEXP (op0, 0)) == ASHIFT\n+      && CONST_INT_P (XEXP (XEXP (op0, 0), 1)))\n+    {\n+      const2 = XUINT (XEXP (XEXP (op0, 0), 1), 0);\n+      *sub0 = XEXP (XEXP (op0, 0), 0);\n+    }\n+  else\n+    *sub0 = XEXP (op0, 0);\n+\n+  if (const2 >= GET_MODE_BITSIZE (GET_MODE (op0)))\n+    return false;\n+\n+  *sub1 = XEXP (op1, 0);\n+  return exact_log2 (const1 + (HOST_WIDE_INT_1U << const2)) >= 0;\n+}\n+\n+/* Recognize a BFI idiom.  Helper for arm_rtx_costs_internal.  The\n+   format looks something like:\n+\n+   (IOR (AND (reg1) (~const1))\n+\t(AND (ASHIFT (reg2) (const2))\n+\t     (const1)))\n+\n+   where const1 is a consecutive sequence of 1-bits with the\n+   least-significant non-zero bit starting at bit position const2.  If\n+   const2 is zero, then the shift will not appear at all, due to\n+   canonicalization.  The two arms of the IOR expression may be\n+   flipped.  */\n+static bool\n+arm_bfi_p (rtx x, rtx *sub0, rtx *sub1)\n+{\n+  if (GET_CODE (x) != IOR)\n+    return false;\n+  if (GET_CODE (XEXP (x, 0)) != AND\n+      || GET_CODE (XEXP (x, 1)) != AND)\n+    return false;\n+  return (arm_bfi_1_p (XEXP (x, 0), XEXP (x, 1), sub0, sub1)\n+\t  || arm_bfi_1_p (XEXP (x, 1), XEXP (x, 0), sub1, sub0));\n+}\n+\n /* RTX costs.  Make an estimate of the cost of executing the operation\n    X, which is contained within an operation with code OUTER_CODE.\n    SPEED_P indicates whether the cost desired is the performance cost,\n@@ -10959,14 +11014,28 @@ arm_rtx_costs_internal (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       *cost = LIBCALL_COST (2);\n       return false;\n     case IOR:\n-      if (mode == SImode && arm_arch6 && aarch_rev16_p (x))\n-        {\n-          if (speed_p)\n-            *cost += extra_cost->alu.rev;\n+      {\n+\trtx sub0, sub1;\n+\tif (mode == SImode && arm_arch6 && aarch_rev16_p (x))\n+\t  {\n+\t    if (speed_p)\n+\t      *cost += extra_cost->alu.rev;\n \n-          return true;\n-        }\n-    /* Fall through.  */\n+\t    return true;\n+\t  }\n+\telse if (mode == SImode && arm_arch_thumb2\n+\t\t && arm_bfi_p (x, &sub0, &sub1))\n+\t  {\n+\t    *cost += rtx_cost (sub0, mode, ZERO_EXTRACT, 1, speed_p);\n+\t    *cost += rtx_cost (sub1, mode, ZERO_EXTRACT, 0, speed_p);\n+\t    if (speed_p)\n+\t      *cost += extra_cost->alu.bfi;\n+\n+\t    return true;\n+\t  }\n+      }\n+\n+      /* Fall through.  */\n     case AND: case XOR:\n       if (mode == SImode)\n \t{\n@@ -23780,8 +23849,8 @@ arm_print_condition (FILE *stream)\n /* Globally reserved letters: acln\n    Puncutation letters currently used: @_|?().!#\n    Lower case letters currently used: bcdefhimpqtvwxyz\n-   Upper case letters currently used: ABCDEFGHIJKLMNOPQRSTU\n-   Letters previously used, but now deprecated/obsolete: sVWXYZ.\n+   Upper case letters currently used: ABCDEFGHIJKLMNOPQRSTUV\n+   Letters previously used, but now deprecated/obsolete: sWXYZ.\n \n    Note that the global reservation for 'c' is only for CONSTANT_ADDRESS_P.\n \n@@ -23797,7 +23866,10 @@ arm_print_condition (FILE *stream)\n    If CODE is 'N' then X is a floating point operand that must be negated\n    before output.\n    If CODE is 'B' then output a bitwise inverted value of X (a const int).\n-   If X is a REG and CODE is `M', output a ldm/stm style multi-reg.  */\n+   If X is a REG and CODE is `M', output a ldm/stm style multi-reg.\n+   If CODE is 'V', then the operand must be a CONST_INT representing\n+   the bits to preserve in the modified register (Rd) of a BFI or BFC\n+   instruction: print out both the width and lsb (shift) fields.  */\n static void\n arm_print_operand (FILE *stream, rtx x, int code)\n {\n@@ -24106,8 +24178,27 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t     stream);\n       return;\n \n-    case 's':\n     case 'V':\n+      {\n+\t/* Output the LSB (shift) and width for a bitmask instruction\n+\t   based on a literal mask.  The LSB is printed first,\n+\t   followed by the width.\n+\n+\t   Eg. For 0b1...1110001, the result is #1, #3.  */\n+\tif (!CONST_INT_P (x))\n+\t  {\n+\t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n+\t    return;\n+\t  }\n+\n+\tunsigned HOST_WIDE_INT val = ~XUINT (x, 0);\n+\tint lsb = exact_log2 (val & -val);\n+\tasm_fprintf (stream, \"#%d, #%d\", lsb,\n+\t\t     (exact_log2 (val + (val & -val)) - lsb));\n+      }\n+      return;\n+\n+    case 's':\n     case 'W':\n     case 'X':\n     case 'Y':"}, {"sha": "69bf343fb0ed601014979cfc1803abe84c87f179", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 97, "deletions": 9, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2005b9b888eeac078f2524b1521885f4b5453894/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2005b9b888eeac078f2524b1521885f4b5453894/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=2005b9b888eeac078f2524b1521885f4b5453894", "patch": "@@ -3002,30 +3002,36 @@\n \n ; ??? Check split length for Thumb-2\n (define_insn_and_split \"*arm_andsi3_insn\"\n-  [(set (match_operand:SI         0 \"s_register_operand\" \"=r,l,r,r,r\")\n-\t(and:SI (match_operand:SI 1 \"s_register_operand\" \"%r,0,r,r,r\")\n-\t\t(match_operand:SI 2 \"reg_or_int_operand\" \"I,l,K,r,?n\")))]\n+  [(set (match_operand:SI         0 \"s_register_operand\" \"=r,l,r,r,r,r\")\n+\t(and:SI (match_operand:SI 1 \"s_register_operand\" \"%r,0,r,r,0,r\")\n+\t\t(match_operand:SI 2 \"reg_or_int_operand\" \"I,l,K,r,Dj,?n\")))]\n   \"TARGET_32BIT\"\n   \"@\n    and%?\\\\t%0, %1, %2\n    and%?\\\\t%0, %1, %2\n    bic%?\\\\t%0, %1, #%B2\n    and%?\\\\t%0, %1, %2\n+   bfc%?\\\\t%0, %V2\n    #\"\n   \"TARGET_32BIT\n    && CONST_INT_P (operands[2])\n    && !(const_ok_for_arm (INTVAL (operands[2]))\n-\t|| const_ok_for_arm (~INTVAL (operands[2])))\"\n+\t|| const_ok_for_arm (~INTVAL (operands[2]))\n+\t|| (arm_arch_thumb2\n+\t    && satisfies_constraint_Dj (operands[2])\n+\t    && (rtx_equal_p (operands[0], operands[1])\n+\t\t|| !reload_completed)))\"\n   [(clobber (const_int 0))]\n   \"\n-  arm_split_constant  (AND, SImode, curr_insn, \n+  arm_split_constant  (AND, SImode, curr_insn,\n \t               INTVAL (operands[2]), operands[0], operands[1], 0);\n   DONE;\n   \"\n-  [(set_attr \"length\" \"4,4,4,4,16\")\n+  [(set_attr \"length\" \"4,4,4,4,4,16\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"predicable_short_it\" \"no,yes,no,no,no\")\n-   (set_attr \"type\" \"logic_imm,logic_imm,logic_reg,logic_reg,logic_imm\")]\n+   (set_attr \"predicable_short_it\" \"no,yes,no,no,no,no\")\n+   (set_attr \"arch\" \"*,*,*,*,v6t2,*\")\n+   (set_attr \"type\" \"logic_imm,logic_imm,logic_reg,logic_reg,bfm,logic_imm\")]\n )\n \n (define_insn \"*andsi3_compare0\"\n@@ -3471,13 +3477,25 @@\n   }\"\n )\n \n-(define_insn \"insv_zero\"\n+(define_insn_and_split \"insv_zero\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"s_register_operand\" \"+r\")\n                          (match_operand:SI 1 \"const_int_M_operand\" \"M\")\n                          (match_operand:SI 2 \"const_int_M_operand\" \"M\"))\n         (const_int 0))]\n   \"arm_arch_thumb2\"\n   \"bfc%?\\t%0, %2, %1\"\n+  \"\"\n+  [(set (match_dup 0) (and:SI (match_dup 0) (match_dup 1)))]\n+  {\n+    /* Convert back to a normal AND operation, so that we can take advantage\n+       of BIC and AND when appropriate; we'll still emit BFC if that's the\n+       right thing to do.  */\n+    unsigned HOST_WIDE_INT width = UINTVAL (operands[1]);\n+    unsigned HOST_WIDE_INT lsb = UINTVAL (operands[2]);\n+    unsigned HOST_WIDE_INT mask = (HOST_WIDE_INT_1U << width) - 1;\n+\n+    operands[1] = gen_int_mode (~(mask << lsb), SImode);\n+  }\n   [(set_attr \"length\" \"4\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"bfm\")]\n@@ -3495,6 +3513,76 @@\n    (set_attr \"type\" \"bfm\")]\n )\n \n+(define_insn \"*bfi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(ior:SI (and:SI (match_operand:SI 1 \"s_register_operand\" \"0\")\n+\t\t\t(match_operand 2 \"const_int_operand\" \"Dj\"))\n+\t\t(and:SI (ashift:SI\n+\t\t\t (match_operand:SI 3 \"s_register_operand\" \"r\")\n+\t\t\t (match_operand 4 \"const_int_operand\" \"i\"))\n+\t\t\t(match_operand 5 \"const_int_operand\" \"i\"))))]\n+  \"arm_arch_thumb2\n+   && UINTVAL (operands[4]) < 32\n+   && UINTVAL (operands[2]) == ~UINTVAL (operands[5])\n+   && (exact_log2 (UINTVAL (operands[5])\n+\t\t   + (HOST_WIDE_INT_1U << UINTVAL (operands[4])))\n+       >= 0)\"\n+  \"bfi%?\\t%0, %3, %V2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"bfm\")]\n+)\n+\n+(define_insn \"*bfi_alt1\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(ior:SI (and:SI (ashift:SI\n+\t\t\t (match_operand:SI 3 \"s_register_operand\" \"r\")\n+\t\t\t (match_operand 4 \"const_int_operand\" \"i\"))\n+\t\t\t(match_operand 5 \"const_int_operand\" \"i\"))\n+\t\t(and:SI (match_operand:SI 1 \"s_register_operand\" \"0\")\n+\t\t\t(match_operand 2 \"const_int_operand\" \"Dj\"))))]\n+  \"arm_arch_thumb2\n+   && UINTVAL (operands[4]) < 32\n+   && UINTVAL (operands[2]) == ~UINTVAL (operands[5])\n+   && (exact_log2 (UINTVAL (operands[5])\n+\t\t   + (HOST_WIDE_INT_1U << UINTVAL (operands[4])))\n+       >= 0)\"\n+  \"bfi%?\\t%0, %3, %V2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"bfm\")]\n+)\n+\n+(define_insn \"*bfi_alt2\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(ior:SI (and:SI (match_operand:SI 1 \"s_register_operand\" \"0\")\n+\t\t\t(match_operand 2 \"const_int_operand\" \"i\"))\n+\t\t(and:SI (match_operand:SI 3 \"s_register_operand\" \"r\")\n+\t\t\t(match_operand 4 \"const_int_operand\" \"i\"))))]\n+  \"arm_arch_thumb2\n+   && UINTVAL (operands[2]) == ~UINTVAL (operands[4])\n+   && exact_log2 (UINTVAL (operands[4]) + 1) >= 0\"\n+  \"bfi%?\\t%0, %3, %V2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"bfm\")]\n+)\n+\n+(define_insn \"*bfi_alt3\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(ior:SI (and:SI (match_operand:SI 3 \"s_register_operand\" \"r\")\n+\t\t\t(match_operand 4 \"const_int_operand\" \"i\"))\n+\t\t(and:SI (match_operand:SI 1 \"s_register_operand\" \"0\")\n+\t\t\t(match_operand 2 \"const_int_operand\" \"i\"))))]\n+  \"arm_arch_thumb2\n+   && UINTVAL (operands[2]) == ~UINTVAL (operands[4])\n+   && exact_log2 (UINTVAL (operands[4]) + 1) >= 0\"\n+  \"bfi%?\\t%0, %3, %V2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"bfm\")]\n+)\n+\n (define_insn \"andsi_notsi_si\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(and:SI (not:SI (match_operand:SI 2 \"s_register_operand\" \"r\"))"}, {"sha": "e5a36d29c7135943b9bb5ea396f70e2e4beb1e4a", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2005b9b888eeac078f2524b1521885f4b5453894/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2005b9b888eeac078f2524b1521885f4b5453894/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=2005b9b888eeac078f2524b1521885f4b5453894", "patch": "@@ -32,7 +32,7 @@\n \n ;; The following multi-letter normal constraints have been used:\n ;; in ARM/Thumb-2 state: Da, Db, Dc, Dd, Dn, DN, Dm, Dl, DL, Do, Dv, Dy, Di,\n-;;\t\t\t Ds, Dt, Dp, Dz, Tu, Te\n+;;\t\t\t Dj, Ds, Dt, Dp, Dz, Tu, Te\n ;; in Thumb-1 state: Pa, Pb, Pc, Pd, Pe\n ;; in Thumb-2 state: Ha, Pj, PJ, Ps, Pt, Pu, Pv, Pw, Px, Py, Pz, Rd, Rf, Rb, Ra,\n ;;\t\t     Rg, Ri\n@@ -354,6 +354,14 @@\n  (and (match_code \"const_double,const_int\")\n       (match_test \"TARGET_32BIT && arm_const_double_by_immediates (op)\")))\n \n+(define_constraint \"Dj\"\n+  \"@internal\n+   In cores with the v6t2 ISA, a constant with exactly one consecutive\n+   string of zero bits.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"arm_arch_thumb2\n+\t\t    && exact_log2 (~ival + (~ival & -~ival)) >= 0\")))\n+\n (define_constraint \"Dm\"\n  \"@internal\n   In ARM/Thumb-2 state a const_vector which can be loaded with a Neon vmov"}]}