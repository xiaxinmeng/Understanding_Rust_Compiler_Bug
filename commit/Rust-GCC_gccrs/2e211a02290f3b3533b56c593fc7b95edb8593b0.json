{"sha": "2e211a02290f3b3533b56c593fc7b95edb8593b0", "node_id": "C_kwDOANBUbNoAKDJlMjExYTAyMjkwZjNiMzUzM2I1NmM1OTNmYzdiOTVlZGI4NTkzYjA", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-01-25T10:55:28Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-01-25T11:22:30Z"}, "message": "tree-optimization/104214 - amend PR100740 fix for pointer compares\n\nWhen we have a pointer relational compare we have stronger guarantees\nabout overflow, in particular rewriting BASE0 + STEP0 cmp BASE1 + STEP1\nas BASE0 + STEP0 - STEP1 cmp BASE1 is always valid and the new IV0\ndoes not overflow.  The patch basically reverts the previous change\nwhen pointers are involved, keeping only the more conservative handling\nfor equality compares which can involve comparing different object\naddresses.\n\n2022-01-25  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/104214\n\t* tree-ssa-loop-niter.cc (number_of_iterations_cond): Use\n\tstronger guarantees for relational pointer compares when\n\trewriting BASE0 + STEP0 cmp BASE1 + STEP1 as\n\tBASE0 + STEP0 - STEP1 cmp BASE1.\n\n\t* gcc.dg/vect/pr81196-2.c: New variant testcase only\n\trequiring vect_int.", "tree": {"sha": "10fa414be8c6b4859f546c81295cae36bca4059c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10fa414be8c6b4859f546c81295cae36bca4059c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e211a02290f3b3533b56c593fc7b95edb8593b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e211a02290f3b3533b56c593fc7b95edb8593b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e211a02290f3b3533b56c593fc7b95edb8593b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e211a02290f3b3533b56c593fc7b95edb8593b0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab2a2457780d224343ce05e7d8e2964c6a47fd83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab2a2457780d224343ce05e7d8e2964c6a47fd83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab2a2457780d224343ce05e7d8e2964c6a47fd83"}], "stats": {"total": 31, "additions": 28, "deletions": 3}, "files": [{"sha": "8d5ce6bad536cdd973ab675fa3351d0b17459971", "filename": "gcc/testsuite/gcc.dg/vect/pr81196-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e211a02290f3b3533b56c593fc7b95edb8593b0/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr81196-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e211a02290f3b3533b56c593fc7b95edb8593b0/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr81196-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr81196-2.c?ref=2e211a02290f3b3533b56c593fc7b95edb8593b0", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+void b (int *p)\n+{\n+  p = (int *)__builtin_assume_aligned(p, __BIGGEST_ALIGNMENT__);\n+  int *q = p + 255;\n+  for(; p < q; ++p, --q)\n+    {\n+      int t = *p;\n+      *p = *q;\n+      *q = t;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "d33095b8e03dbc32dc98e66f0957c5b2e5ab52d9", "filename": "gcc/tree-ssa-loop-niter.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e211a02290f3b3533b56c593fc7b95edb8593b0/gcc%2Ftree-ssa-loop-niter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e211a02290f3b3533b56c593fc7b95edb8593b0/gcc%2Ftree-ssa-loop-niter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.cc?ref=2e211a02290f3b3533b56c593fc7b95edb8593b0", "patch": "@@ -1915,14 +1915,23 @@ number_of_iterations_cond (class loop *loop,\n \t}\n       /* If the new step of IV0 has changed sign or is of greater\n \t magnitude then we do not know whether IV0 does overflow\n-\t and thus the transform is not valid for code other than NE_EXPR  */\n+\t and thus the transform is not valid for code other than NE_EXPR.  */\n       else if (tree_int_cst_sign_bit (step) != tree_int_cst_sign_bit (iv0->step)\n \t       || wi::gtu_p (wi::abs (wi::to_widest (step)),\n \t\t\t     wi::abs (wi::to_widest (iv0->step))))\n \t{\n-\t  if (code != NE_EXPR)\n+\t  if (POINTER_TYPE_P (type) && code != NE_EXPR)\n+\t    /* For relational pointer compares we have further guarantees\n+\t       that the pointers always point to the same object (or one\n+\t       after it) and that objects do not cross the zero page.  So\n+\t       not only is the transform always valid for relational\n+\t       pointer compares, we also know the resulting IV does not\n+\t       overflow.  */\n+\t    ;\n+\t  else if (code != NE_EXPR)\n \t    return false;\n-\t  iv0->no_overflow = false;\n+\t  else\n+\t    iv0->no_overflow = false;\n \t}\n \n       iv0->step = step;"}]}