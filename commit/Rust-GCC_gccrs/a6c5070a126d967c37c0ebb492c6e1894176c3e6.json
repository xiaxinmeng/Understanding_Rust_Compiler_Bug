{"sha": "a6c5070a126d967c37c0ebb492c6e1894176c3e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZjNTA3MGExMjZkOTY3YzM3YzBlYmI0OTJjNmUxODk0MTc2YzNlNg==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2011-01-24T17:29:58Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2011-01-24T17:29:58Z"}, "message": "Visit basic blocks using the work-list based algorithm.\n\n2011-01-24  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR target/46519\n\t* config/i386/i386.c: Include sbitmap.h and fibheap.h.\n\t(block_info): Add scanned and prev.\n\t(move_or_delete_vzeroupper_2): Return if the basic block\n\thas been scanned and the upper 128bit state is unchanged\n\tfrom the last scan.\n\t(move_or_delete_vzeroupper_1): Return true if the exit\n\tstate is changed.\n\t(move_or_delete_vzeroupper): Visit basic blocks using the\n\twork-list based algorithm based on vt_find_locations in\n\tvar-tracking.c.\n\n\t* config/i386/t-i386: Also depend on sbitmap.h and $(FIBHEAP_H).\n\nFrom-SVN: r169173", "tree": {"sha": "fa6ba486fd759f5953b48a63a13be3e4eeda4749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa6ba486fd759f5953b48a63a13be3e4eeda4749"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6c5070a126d967c37c0ebb492c6e1894176c3e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c5070a126d967c37c0ebb492c6e1894176c3e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6c5070a126d967c37c0ebb492c6e1894176c3e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c5070a126d967c37c0ebb492c6e1894176c3e6/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fc722a0ea442f0b037a0aecdabc74f182b508d5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc722a0ea442f0b037a0aecdabc74f182b508d5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc722a0ea442f0b037a0aecdabc74f182b508d5c"}], "stats": {"total": 165, "additions": 143, "deletions": 22}, "files": [{"sha": "c181a54de8e4187f820098859deddd15c3f85ad4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c5070a126d967c37c0ebb492c6e1894176c3e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c5070a126d967c37c0ebb492c6e1894176c3e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6c5070a126d967c37c0ebb492c6e1894176c3e6", "patch": "@@ -1,3 +1,19 @@\n+2011-01-24  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/46519\n+\t* config/i386/i386.c: Include sbitmap.h and fibheap.h.\n+\t(block_info): Add scanned and prev.\n+\t(move_or_delete_vzeroupper_2): Return if the basic block\n+\thas been scanned and the upper 128bit state is unchanged\n+\tfrom the last scan.\n+\t(move_or_delete_vzeroupper_1): Return true if the exit\n+\tstate is changed.\n+\t(move_or_delete_vzeroupper): Visit basic blocks using the\n+\twork-list based algorithm based on vt_find_locations in\n+\tvar-tracking.c.\n+\n+\t* config/i386/t-i386: Also depend on sbitmap.h and $(FIBHEAP_H).\n+\n 2011-01-24  Nick Clifton  <nickc@redhat.com>\n \n \t* config/v850/v850.opt (mv850es): New option - alias for -mv850e1."}, {"sha": "ee1790f577a641178299f95bdfa2951d16789b68", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 126, "deletions": 21, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c5070a126d967c37c0ebb492c6e1894176c3e6/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c5070a126d967c37c0ebb492c6e1894176c3e6/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a6c5070a126d967c37c0ebb492c6e1894176c3e6", "patch": "@@ -56,6 +56,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"dwarf2out.h\"\n #include \"sched-int.h\"\n+#include \"sbitmap.h\"\n+#include \"fibheap.h\"\n \n enum upper_128bits_state\n {\n@@ -73,6 +75,10 @@ typedef struct block_info_def\n   bool unchanged;\n   /* TRUE if block has been processed.  */\n   bool processed;\n+  /* TRUE if block has been scanned.  */\n+  bool scanned;\n+  /* Previous state of the upper 128bits of AVX registers at entry.  */\n+  enum upper_128bits_state prev;\n } *block_info;\n \n #define BLOCK_INFO(B)   ((block_info) (B)->aux)\n@@ -135,6 +141,16 @@ move_or_delete_vzeroupper_2 (basic_block bb,\n       return;\n     }\n \n+  if (BLOCK_INFO (bb)->scanned && BLOCK_INFO (bb)->prev == state)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \" [bb %i] scanned: upper 128bits: %d\\n\",\n+\t\t bb->index, BLOCK_INFO (bb)->state);\n+      return;\n+    }\n+\n+  BLOCK_INFO (bb)->prev = state;\n+\n   if (dump_file)\n     fprintf (dump_file, \" [bb %i] entry: upper 128bits: %d\\n\",\n \t     bb->index, state);\n@@ -264,6 +280,7 @@ move_or_delete_vzeroupper_2 (basic_block bb,\n \n   BLOCK_INFO (bb)->state = state;\n   BLOCK_INFO (bb)->unchanged = unchanged;\n+  BLOCK_INFO (bb)->scanned = true;\n \n   if (dump_file)\n     fprintf (dump_file, \" [bb %i] exit: %s: upper 128bits: %d\\n\",\n@@ -273,9 +290,10 @@ move_or_delete_vzeroupper_2 (basic_block bb,\n \n /* Helper function for move_or_delete_vzeroupper.  Process vzeroupper\n    in BLOCK and check its predecessor blocks.  Treat UNKNOWN state\n-   as USED if UNKNOWN_IS_UNUSED is true.  */\n+   as USED if UNKNOWN_IS_UNUSED is true.  Return TRUE if the exit\n+   state is changed.  */\n \n-static void\n+static bool\n move_or_delete_vzeroupper_1 (basic_block block, bool unknown_is_unused)\n {\n   edge e;\n@@ -288,7 +306,7 @@ move_or_delete_vzeroupper_1 (basic_block block, bool unknown_is_unused)\n \t     block->index, BLOCK_INFO (block)->processed);\n \n   if (BLOCK_INFO (block)->processed)\n-    return;\n+    return false;\n \n   state = unused;\n \n@@ -324,8 +342,14 @@ move_or_delete_vzeroupper_1 (basic_block block, bool unknown_is_unused)\n \n   /* Need to rescan if the upper 128bits of AVX registers are changed\n      to USED at exit.  */\n-  if (new_state != old_state && new_state == used)\n-    cfun->machine->rescan_vzeroupper_p = 1;\n+  if (new_state != old_state)\n+    {\n+      if (new_state == used)\n+\tcfun->machine->rescan_vzeroupper_p = 1;\n+      return true;\n+    }\n+  else\n+    return false;\n }\n \n /* Go through the instruction stream looking for vzeroupper.  Delete\n@@ -338,14 +362,18 @@ move_or_delete_vzeroupper (void)\n   edge e;\n   edge_iterator ei;\n   basic_block bb;\n-  unsigned int count;\n+  fibheap_t worklist, pending, fibheap_swap;\n+  sbitmap visited, in_worklist, in_pending, sbitmap_swap;\n+  int *bb_order;\n+  int *rc_order;\n+  int i;\n \n   /* Set up block info for each basic block.  */\n   alloc_aux_for_blocks (sizeof (struct block_info_def));\n \n-  /* Process successor blocks of all entry points.  */\n+  /* Process outgoing edges of entry point.  */\n   if (dump_file)\n-    fprintf (dump_file, \"Process all entry points\\n\");\n+    fprintf (dump_file, \"Process outgoing edges of entry point\\n\");\n \n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     {\n@@ -355,25 +383,102 @@ move_or_delete_vzeroupper (void)\n       BLOCK_INFO (e->dest)->processed = true;\n     }\n \n-  /* Process all basic blocks.  */\n-  count = 0;\n-  do\n+  /* Compute reverse completion order of depth first search of the CFG\n+     so that the data-flow runs faster.  */\n+  rc_order = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n+  bb_order = XNEWVEC (int, last_basic_block);\n+  pre_and_rev_post_order_compute (NULL, rc_order, false);\n+  for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n+    bb_order[rc_order[i]] = i;\n+  free (rc_order);\n+\n+  worklist = fibheap_new ();\n+  pending = fibheap_new ();\n+  visited = sbitmap_alloc (last_basic_block);\n+  in_worklist = sbitmap_alloc (last_basic_block);\n+  in_pending = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (in_worklist);\n+\n+  /* Don't check outgoing edges of entry point.  */\n+  sbitmap_ones (in_pending);\n+  FOR_EACH_BB (bb)\n+    if (BLOCK_INFO (bb)->processed)\n+      RESET_BIT (in_pending, bb->index);\n+    else\n+      {\n+\tmove_or_delete_vzeroupper_1 (bb, false);\n+\tfibheap_insert (pending, bb_order[bb->index], bb);\n+      }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Check remaining basic blocks\\n\");\n+\n+  while (!fibheap_empty (pending))\n     {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Process all basic blocks: trip %d\\n\",\n-\t\t count);\n+      fibheap_swap = pending;\n+      pending = worklist;\n+      worklist = fibheap_swap;\n+      sbitmap_swap = in_pending;\n+      in_pending = in_worklist;\n+      in_worklist = sbitmap_swap;\n+\n+      sbitmap_zero (visited);\n+\n       cfun->machine->rescan_vzeroupper_p = 0;\n-      FOR_EACH_BB (bb)\n-\tmove_or_delete_vzeroupper_1 (bb, false);\n+\n+      while (!fibheap_empty (worklist))\n+\t{\n+\t  bb = (basic_block) fibheap_extract_min (worklist);\n+\t  RESET_BIT (in_worklist, bb->index);\n+\t  gcc_assert (!TEST_BIT (visited, bb->index));\n+\t  if (!TEST_BIT (visited, bb->index))\n+\t    {\n+\t      edge_iterator ei;\n+\n+\t      SET_BIT (visited, bb->index);\n+\n+\t      if (move_or_delete_vzeroupper_1 (bb, false))\n+\t\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t\t  {\n+\t\t    if (e->dest == EXIT_BLOCK_PTR\n+\t\t\t|| BLOCK_INFO (e->dest)->processed)\n+\t\t      continue;\n+\n+\t\t    if (TEST_BIT (visited, e->dest->index))\n+\t\t      {\n+\t\t\tif (!TEST_BIT (in_pending, e->dest->index))\n+\t\t\t  {\n+\t\t\t    /* Send E->DEST to next round.  */\n+\t\t\t    SET_BIT (in_pending, e->dest->index);\n+\t\t\t    fibheap_insert (pending,\n+\t\t\t\t\t    bb_order[e->dest->index],\n+\t\t\t\t\t    e->dest);\n+\t\t\t  }\n+\t\t      }\n+\t\t    else if (!TEST_BIT (in_worklist, e->dest->index))\n+\t\t      {\n+\t\t\t/* Add E->DEST to current round.  */\n+\t\t\tSET_BIT (in_worklist, e->dest->index);\n+\t\t\tfibheap_insert (worklist, bb_order[e->dest->index],\n+\t\t\t\t\te->dest);\n+\t\t      }\n+\t\t  }\n+\t    }\n+\t}\n+\n+      if (!cfun->machine->rescan_vzeroupper_p)\n+\tbreak;\n     }\n-  while (cfun->machine->rescan_vzeroupper_p && count++ < 20);\n \n-  /* FIXME: Is 20 big enough?  */\n-  if (count >= 20)\n-    gcc_unreachable ();\n+  free (bb_order);\n+  fibheap_delete (worklist);\n+  fibheap_delete (pending);\n+  sbitmap_free (visited);\n+  sbitmap_free (in_worklist);\n+  sbitmap_free (in_pending);\n \n   if (dump_file)\n-    fprintf (dump_file, \"Process all basic blocks\\n\");\n+    fprintf (dump_file, \"Process remaining basic blocks\\n\");\n \n   FOR_EACH_BB (bb)\n     move_or_delete_vzeroupper_1 (bb, true);"}, {"sha": "1c658a149dfe616092d83f69f97f681395f2acae", "filename": "gcc/config/i386/t-i386", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c5070a126d967c37c0ebb492c6e1894176c3e6/gcc%2Fconfig%2Fi386%2Ft-i386", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c5070a126d967c37c0ebb492c6e1894176c3e6/gcc%2Fconfig%2Fi386%2Ft-i386", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-i386?ref=a6c5070a126d967c37c0ebb492c6e1894176c3e6", "patch": "@@ -23,7 +23,7 @@ i386.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(RECOG_H) $(EXPR_H) $(OPTABS_H) toplev.h $(BASIC_BLOCK_H) \\\n   $(GGC_H) $(TARGET_H) $(TARGET_DEF_H) langhooks.h $(CGRAPH_H) \\\n   $(TREE_GIMPLE_H) $(DWARF2_H) $(DF_H) tm-constrs.h $(PARAMS_H) \\\n-  i386-builtin-types.inc debug.h dwarf2out.h\n+  i386-builtin-types.inc debug.h dwarf2out.h sbitmap.h $(FIBHEAP_H)\n \n i386-c.o: $(srcdir)/config/i386/i386-c.c \\\n   $(srcdir)/config/i386/i386-protos.h $(CONFIG_H) $(SYSTEM_H) coretypes.h \\"}]}