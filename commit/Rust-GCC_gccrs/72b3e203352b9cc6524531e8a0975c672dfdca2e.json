{"sha": "72b3e203352b9cc6524531e8a0975c672dfdca2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJiM2UyMDMzNTJiOWNjNjUyNDUzMWU4YTA5NzVjNjcyZGZkY2EyZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-07-08T21:32:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-07-08T21:32:18Z"}, "message": "Use lvalue_p instead of real_lvalue_p.\n\n\t* cp-tree.h: Unpoison lvalue_p.\n\t* call.c, class.c, constexpr.c, cvt.c, init.c, lambda.c, pt.c,\n\ttree.c, typeck.c, typeck2.c: Use lvalue_p instead of\n\treal_lvalue_p.\n\nFrom-SVN: r238183", "tree": {"sha": "59e43b83b4fec4f63807d14fe011dac7bab36407", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59e43b83b4fec4f63807d14fe011dac7bab36407"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72b3e203352b9cc6524531e8a0975c672dfdca2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b3e203352b9cc6524531e8a0975c672dfdca2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72b3e203352b9cc6524531e8a0975c672dfdca2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b3e203352b9cc6524531e8a0975c672dfdca2e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bb19d4af73a6e29dde443976f3119d01a5491f8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb19d4af73a6e29dde443976f3119d01a5491f8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb19d4af73a6e29dde443976f3119d01a5491f8d"}], "stats": {"total": 81, "additions": 40, "deletions": 41}, "files": [{"sha": "e70e102c6e35d93138dad5e0fdc5da3bb43be0f4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=72b3e203352b9cc6524531e8a0975c672dfdca2e", "patch": "@@ -1,5 +1,10 @@\n 2016-07-08  Jason Merrill  <jason@redhat.com>\n \n+\t* cp-tree.h: Unpoison lvalue_p.\n+\t* call.c, class.c, constexpr.c, cvt.c, init.c, lambda.c, pt.c,\n+\ttree.c, typeck.c, typeck2.c: Use lvalue_p instead of\n+\treal_lvalue_p.\n+\n \t* tree.c (obvalue_p): Rename from lvalue_p.\n \t(lvalue_p): Define for c-common.\n \t* call.c, cp-tree.h, cvt.c, init.c: Adjust."}, {"sha": "9b028144aaa6f27faff66e086a47fdbf26271476", "filename": "gcc/cp/call.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=72b3e203352b9cc6524531e8a0975c672dfdca2e", "patch": "@@ -2925,7 +2925,7 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \n \t  if (code == COND_EXPR)\n \t    {\n-\t      if (real_lvalue_p (args[i]))\n+\t      if (lvalue_p (args[i]))\n \t\tvec_safe_push (types[i], build_reference_type (argtypes[i]));\n \n \t      vec_safe_push (types[i], TYPE_MAIN_VARIANT (argtypes[i]));\n@@ -2962,7 +2962,7 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \t}\n       else\n \t{\n-\t  if (code == COND_EXPR && real_lvalue_p (args[i]))\n+\t  if (code == COND_EXPR && lvalue_p (args[i]))\n \t    vec_safe_push (types[i], build_reference_type (argtypes[i]));\n \t  type = non_reference (argtypes[i]);\n \t  if (i != 0 || ! ref1)\n@@ -4554,7 +4554,7 @@ conditional_conversion (tree e1, tree e2, tsubst_flags_t complain)\n      the constraint that the reference must bind directly.  */\n   if (glvalue_p (e2))\n     {\n-      tree rtype = cp_build_reference_type (t2, !real_lvalue_p (e2));\n+      tree rtype = cp_build_reference_type (t2, !lvalue_p (e2));\n       conv = implicit_conversion (rtype,\n \t\t\t\t  t1,\n \t\t\t\t  e1,\n@@ -4619,7 +4619,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n   tree arg3_type;\n   tree result = NULL_TREE;\n   tree result_type = NULL_TREE;\n-  bool lvalue_p = true;\n+  bool is_lvalue = true;\n   struct z_candidate *candidates = 0;\n   struct z_candidate *cand;\n   void *p;\n@@ -4636,7 +4636,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \t\t \"ISO C++ forbids omitting the middle term of a ?: expression\");\n \n       /* Make sure that lvalues remain lvalues.  See g++.oliva/ext1.C.  */\n-      if (real_lvalue_p (arg1))\n+      if (lvalue_p (arg1))\n \targ2 = arg1 = cp_stabilize_reference (arg1);\n       else\n \targ2 = arg1 = save_expr (arg1);\n@@ -4871,7 +4871,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \t  return error_mark_node;\n \t}\n \n-      lvalue_p = false;\n+      is_lvalue = false;\n       goto valid_operands;\n     }\n   /* [expr.cond]\n@@ -4886,7 +4886,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \t\t|| (same_type_ignoring_top_level_qualifiers_p (arg2_type,\n \t\t\t\t\t\t\t       arg3_type)\n \t\t    && glvalue_p (arg2) && glvalue_p (arg3)\n-\t\t    && real_lvalue_p (arg2) == real_lvalue_p (arg3))))\n+\t\t    && lvalue_p (arg2) == lvalue_p (arg3))))\n     {\n       conversion *conv2;\n       conversion *conv3;\n@@ -4984,7 +4984,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n      If the second and third operands are glvalues of the same value\n      category and have the same type, the result is of that type and\n      value category.  */\n-  if (((real_lvalue_p (arg2) && real_lvalue_p (arg3))\n+  if (((lvalue_p (arg2) && lvalue_p (arg3))\n        || (xvalue_p (arg2) && xvalue_p (arg3)))\n       && same_type_p (arg2_type, arg3_type))\n     {\n@@ -5001,7 +5001,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n      cv-qualified) class type, overload resolution is used to\n      determine the conversions (if any) to be applied to the operands\n      (_over.match.oper_, _over.built_).  */\n-  lvalue_p = false;\n+  is_lvalue = false;\n   if (!same_type_p (arg2_type, arg3_type)\n       && (CLASS_TYPE_P (arg2_type) || CLASS_TYPE_P (arg3_type)))\n     {\n@@ -5187,7 +5187,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n   /* We can't use result_type below, as fold might have returned a\n      throw_expr.  */\n \n-  if (!lvalue_p)\n+  if (!is_lvalue)\n     {\n       /* Expand both sides into the same slot, hopefully the target of\n \t the ?: expression.  We used to check for TARGET_EXPRs here,\n@@ -6694,10 +6694,10 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  {\n \t    tree extype = TREE_TYPE (expr);\n \t    if (TYPE_REF_IS_RVALUE (ref_type)\n-\t\t&& real_lvalue_p (expr))\n+\t\t&& lvalue_p (expr))\n \t      error_at (loc, \"cannot bind %qT lvalue to %qT\",\n \t\t\textype, totype);\n-\t    else if (!TYPE_REF_IS_RVALUE (ref_type) && !real_lvalue_p (expr)\n+\t    else if (!TYPE_REF_IS_RVALUE (ref_type) && !lvalue_p (expr)\n \t\t     && !CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (ref_type)))\n \t      error_at (loc, \"invalid initialization of non-const reference of \"\n \t\t\t\"type %qT from an rvalue of type %qT\", totype, extype);\n@@ -10042,7 +10042,7 @@ initialize_reference (tree type, tree expr,\n \t    convert_like (conv, expr, complain);\n \t  else if (!CP_TYPE_CONST_P (TREE_TYPE (type))\n \t\t   && !TYPE_REF_IS_RVALUE (type)\n-\t\t   && !real_lvalue_p (expr))\n+\t\t   && !lvalue_p (expr))\n \t    error_at (loc, \"invalid initialization of non-const reference of \"\n \t\t      \"type %qT from an rvalue of type %qT\",\n \t\t      type, TREE_TYPE (expr));"}, {"sha": "b2db7f8aab83e0687c69308ff36495e677ba34f8", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=72b3e203352b9cc6524531e8a0975c672dfdca2e", "patch": "@@ -347,7 +347,7 @@ build_base_path (enum tree_code code,\n \n   if (!want_pointer)\n     {\n-      rvalue = !real_lvalue_p (expr);\n+      rvalue = !lvalue_p (expr);\n       /* This must happen before the call to save_expr.  */\n       expr = cp_build_addr_expr (expr, complain);\n     }"}, {"sha": "b9834a7e734dd938ad2e55a79df4c6e991529ab7", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=72b3e203352b9cc6524531e8a0975c672dfdca2e", "patch": "@@ -2620,7 +2620,7 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t\t      (atype, TREE_TYPE (init)));\n \t  eltinit = cp_build_array_ref (input_location, init, idx,\n \t\t\t\t\ttf_warning_or_error);\n-\t  if (!real_lvalue_p (init))\n+\t  if (!lvalue_p (init))\n \t    eltinit = move (eltinit);\n \t  eltinit = force_rvalue (eltinit, tf_warning_or_error);\n \t  eltinit = (cxx_eval_constant_expression"}, {"sha": "74b8c7c7963ca5a2c2519c03b0711c69fe14d520", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=72b3e203352b9cc6524531e8a0975c672dfdca2e", "patch": "@@ -6516,10 +6516,6 @@ extern int member_p\t\t\t\t(const_tree);\n extern cp_lvalue_kind real_lvalue_p\t\t(const_tree);\n extern cp_lvalue_kind lvalue_kind\t\t(const_tree);\n extern bool glvalue_p\t\t\t\t(const_tree);\n-/* obvalue_p used to be named lvalue_p, but that didn't match the C++\n-   definition of lvalue.  For now, let's not use the name lvalue_p in the front\n-   end; later we can rename real_lvalue_p to lvalue_p.  */\n-#define lvalue_p(T) syntax error, use real_lvalue_p\n extern bool obvalue_p\t\t\t\t(const_tree);\n extern bool xvalue_p\t                        (const_tree);\n extern tree cp_stabilize_reference\t\t(tree);"}, {"sha": "85b3047d9f138d08f9c94ca2116d4293cb6c3608", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=72b3e203352b9cc6524531e8a0975c672dfdca2e", "patch": "@@ -317,7 +317,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl,\n \n   gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n \n-  if ((flags & DIRECT_BIND) && ! real_lvalue_p (arg))\n+  if ((flags & DIRECT_BIND) && ! lvalue_p (arg))\n     {\n       /* Create a new temporary variable.  We can't just use a TARGET_EXPR\n \t here because it needs to live as long as DECL.  */\n@@ -439,7 +439,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \t= build_type_conversion (reftype, expr);\n \n       if (rval_as_conversion && rval_as_conversion != error_mark_node\n-\t  && real_lvalue_p (rval_as_conversion))\n+\t  && lvalue_p (rval_as_conversion))\n \t{\n \t  expr = rval_as_conversion;\n \t  rval_as_conversion = NULL_TREE;\n@@ -457,7 +457,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \ttree ttr = lvalue_type (expr);\n \n \tif ((complain & tf_error)\n-\t    && ! real_lvalue_p (expr))\n+\t    && ! lvalue_p (expr))\n \t  diagnose_ref_binding (loc, reftype, intype, decl);\n \n \tif (! (convtype & CONV_CONST)"}, {"sha": "b4a4388d705b9f3616aacda527228210edb19d6f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=72b3e203352b9cc6524531e8a0975c672dfdca2e", "patch": "@@ -3750,7 +3750,7 @@ static bool\n vec_copy_assign_is_trivial (tree inner_elt_type, tree init)\n {\n   tree fromtype = inner_elt_type;\n-  if (real_lvalue_p (init))\n+  if (lvalue_p (init))\n     fromtype = cp_build_reference_type (fromtype, /*rval*/false);\n   return is_trivially_xible (MODIFY_EXPR, inner_elt_type, fromtype);\n }"}, {"sha": "4d6d80fe128ddb6b95285f598a40f0fa2b738b58", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=72b3e203352b9cc6524531e8a0975c672dfdca2e", "patch": "@@ -489,7 +489,7 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n       if (by_reference_p)\n \t{\n \t  type = build_reference_type (type);\n-\t  if (!dependent_type_p (type) && !real_lvalue_p (initializer))\n+\t  if (!dependent_type_p (type) && !lvalue_p (initializer))\n \t    error (\"cannot capture %qE by reference\", initializer);\n \t}\n       else"}, {"sha": "a1b0ca9a85858cb2293d95a54afc25cec9683f01", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=72b3e203352b9cc6524531e8a0975c672dfdca2e", "patch": "@@ -6533,7 +6533,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t  return NULL_TREE;\n \t}\n \n-      if (!real_lvalue_p (expr))\n+      if (!lvalue_p (expr))\n \t{\n \t  if (complain & tf_error)\n \t    error (\"%qE is not a valid template argument for type %qT \"\n@@ -18046,7 +18046,7 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n       && TYPE_REF_IS_RVALUE (*parm)\n       && TREE_CODE (TREE_TYPE (*parm)) == TEMPLATE_TYPE_PARM\n       && cp_type_quals (TREE_TYPE (*parm)) == TYPE_UNQUALIFIED\n-      && (arg_expr ? real_lvalue_p (arg_expr)\n+      && (arg_expr ? lvalue_p (arg_expr)\n \t  /* try_one_overload doesn't provide an arg_expr, but\n \t     functions are always lvalues.  */\n \t  : TREE_CODE (*arg) == FUNCTION_TYPE))"}, {"sha": "4cbf6215a13a294e911f8737f62f2c5a46aa927e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=72b3e203352b9cc6524531e8a0975c672dfdca2e", "patch": "@@ -252,9 +252,7 @@ lvalue_kind (const_tree ref)\n   return op1_lvalue_kind;\n }\n \n-/* Returns the kind of lvalue that REF is, in the sense of\n-   [basic.lval].  This function should really be named lvalue_p; it\n-   computes the C++ definition of lvalue.  */\n+/* Returns the kind of lvalue that REF is, in the sense of [basic.lval].  */\n \n cp_lvalue_kind\n real_lvalue_p (const_tree ref)\n@@ -266,15 +264,15 @@ real_lvalue_p (const_tree ref)\n     return kind;\n }\n \n-/* Defined for c-common; the front end should use real_lvalue_p.  */\n+/* c-common wants us to return bool.  */\n \n bool\n-(lvalue_p) (const_tree t)\n+lvalue_p (const_tree t)\n {\n   return real_lvalue_p (t);\n }\n \n-/* This differs from real_lvalue_p in that xvalues are included.  */\n+/* This differs from lvalue_p in that xvalues are included.  */\n \n bool\n glvalue_p (const_tree ref)\n@@ -615,7 +613,7 @@ build_vec_init_elt (tree type, tree init, tsubst_flags_t complain)\n     {\n       tree init_type = strip_array_types (TREE_TYPE (init));\n       tree dummy = build_dummy_object (init_type);\n-      if (!real_lvalue_p (init))\n+      if (!lvalue_p (init))\n \tdummy = move (dummy);\n       argvec->quick_push (dummy);\n     }\n@@ -3331,7 +3329,7 @@ error_type (tree arg)\n     ;\n   else if (TREE_CODE (type) == ERROR_MARK)\n     ;\n-  else if (real_lvalue_p (arg))\n+  else if (lvalue_p (arg))\n     type = build_reference_type (lvalue_type (arg));\n   else if (MAYBE_CLASS_TYPE_P (type))\n     type = lvalue_type (arg);\n@@ -4278,7 +4276,7 @@ stabilize_expr (tree exp, tree* initp)\n     }\n   else\n     {\n-      bool xval = !real_lvalue_p (exp);\n+      bool xval = !lvalue_p (exp);\n       exp = cp_build_addr_expr (exp, tf_warning_or_error);\n       init_expr = get_target_expr (exp);\n       exp = TARGET_EXPR_SLOT (init_expr);"}, {"sha": "2f2beead74cbc60f83014e20403deca977e3c146", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=72b3e203352b9cc6524531e8a0975c672dfdca2e", "patch": "@@ -6296,7 +6296,7 @@ build_x_conditional_expr (location_t loc, tree ifexp, tree op1, tree op2,\n       /* Remember that the result is an lvalue or xvalue.  */\n       if (glvalue_p (expr) && !glvalue_p (min))\n \tTREE_TYPE (min) = cp_build_reference_type (TREE_TYPE (min),\n-\t\t\t\t\t\t   !real_lvalue_p (expr));\n+\t\t\t\t\t\t   !lvalue_p (expr));\n       expr = convert_from_reference (min);\n     }\n   return expr;\n@@ -6535,7 +6535,7 @@ maybe_warn_about_useless_cast (tree type, tree expr, tsubst_flags_t complain)\n     {\n       if ((TREE_CODE (type) == REFERENCE_TYPE\n \t   && (TYPE_REF_IS_RVALUE (type)\n-\t       ? xvalue_p (expr) : real_lvalue_p (expr))\n+\t       ? xvalue_p (expr) : lvalue_p (expr))\n \t   && same_type_p (TREE_TYPE (expr), TREE_TYPE (type)))\n \t  || same_type_p (TREE_TYPE (expr), type))\n \twarning (OPT_Wuseless_cast, \"useless cast to type %qT\", type);\n@@ -6637,7 +6637,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n   if (TREE_CODE (type) == REFERENCE_TYPE\n       && CLASS_TYPE_P (TREE_TYPE (type))\n       && CLASS_TYPE_P (intype)\n-      && (TYPE_REF_IS_RVALUE (type) || real_lvalue_p (expr))\n+      && (TYPE_REF_IS_RVALUE (type) || lvalue_p (expr))\n       && DERIVED_FROM_P (intype, TREE_TYPE (type))\n       && can_convert (build_pointer_type (TYPE_MAIN_VARIANT (intype)),\n \t\t      build_pointer_type (TYPE_MAIN_VARIANT\n@@ -6984,7 +6984,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n      reinterpret_cast.  */\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n-      if (! real_lvalue_p (expr))\n+      if (! lvalue_p (expr))\n \t{\n           if (complain & tf_error)\n             error (\"invalid cast of an rvalue expression of type \"\n@@ -7231,7 +7231,7 @@ build_const_cast_1 (tree dst_type, tree expr, tsubst_flags_t complain,\n     {\n       reference_type = dst_type;\n       if (!TYPE_REF_IS_RVALUE (dst_type)\n-\t  ? real_lvalue_p (expr)\n+\t  ? lvalue_p (expr)\n \t  : obvalue_p (expr))\n \t/* OK.  */;\n       else"}, {"sha": "b1206c09a0e35551a42f831ff3eab0d8220fb970", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3e203352b9cc6524531e8a0975c672dfdca2e/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=72b3e203352b9cc6524531e8a0975c672dfdca2e", "patch": "@@ -1895,7 +1895,7 @@ build_m_component_ref (tree datum, tree component, tsubst_flags_t complain)\n \t operand is a pointer to member function with ref-qualifier &&.  */\n       if (FUNCTION_REF_QUALIFIED (type))\n \t{\n-\t  bool lval = real_lvalue_p (datum);\n+\t  bool lval = lvalue_p (datum);\n \t  if (lval && FUNCTION_RVALUE_QUALIFIED (type))\n \t    {\n \t      if (complain & tf_error)"}]}