{"sha": "8c352fa8edadc62089e29ade8fd59e0a281645fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMzNTJmYThlZGFkYzYyMDg5ZTI5YWRlOGZkNTllMGEyODE2NDVmYQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-07-20T17:23:28Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-07-20T17:23:28Z"}, "message": "re PR target/36467 ([avr] Missed optimization with pointer arithmetic and mul*)\n\n\n\tPR target/36467\n\tPR target/49687\n\t* config/avr/avr.md (mulhi3): Use register_or_s9_operand for\n\toperand2 and expand appropriately if there is a CONST_INT in\n\toperand2.\n\t(usmulqihi3): New insn.\n\t(*sumulqihi3): New insn.\n\t(*osmulqihi3): New insn.\n\t(*oumulqihi3): New insn.\n\t(*muluqihi3.uconst): New insn_and_split.\n\t(*muluqihi3.sconst): New insn_and_split.\n\t(*mulsqihi3.sconst): New insn_and_split.\n\t(*mulsqihi3.uconst): New insn_and_split.\n\t(*mulsqihi3.oconst): New insn_and_split.\n\t(*ashifthi3.signx.const): New insn_and_split.\n\t(*ashifthi3.signx.const7): New insn_and_split.\n\t(*ashifthi3.zerox.const): New insn_and_split.\n\t(mulsqihi3): New insn.\n\t(muluqihi3): New insn.\n\t(muloqihi3): New insn.\n\t* config/avr/predicates.md (const_2_to_7_operand): New.\n\t(const_2_to_6_operand): New.\n\t(u8_operand): New.\n\t(s8_operand): New.\n\t(o8_operand): New.\n\t(s9_operand): New.\n\t(register_or_s9_operand): New.\n\nFrom-SVN: r176527", "tree": {"sha": "cc1a6877a75e72f56f45065794005876f10ea76d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc1a6877a75e72f56f45065794005876f10ea76d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c352fa8edadc62089e29ade8fd59e0a281645fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c352fa8edadc62089e29ade8fd59e0a281645fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c352fa8edadc62089e29ade8fd59e0a281645fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c352fa8edadc62089e29ade8fd59e0a281645fa/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be31603aad66140822c345a93f5e1ae3d4fa9300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be31603aad66140822c345a93f5e1ae3d4fa9300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be31603aad66140822c345a93f5e1ae3d4fa9300"}], "stats": {"total": 413, "additions": 402, "deletions": 11}, "files": [{"sha": "1b47598ca6be2f7b91e4953e167cc712fd20afef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c352fa8edadc62089e29ade8fd59e0a281645fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c352fa8edadc62089e29ade8fd59e0a281645fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c352fa8edadc62089e29ade8fd59e0a281645fa", "patch": "@@ -1,3 +1,33 @@\n+2011-07-20  Georg-Johann Lay  <avr@gjlay.de>\n+\t\n+\tPR target/36467\n+\tPR target/49687\n+\t* config/avr/avr.md (mulhi3): Use register_or_s9_operand for\n+\toperand2 and expand appropriately if there is a CONST_INT in\n+\toperand2.\n+\t(usmulqihi3): New insn.\n+\t(*sumulqihi3): New insn.\n+\t(*osmulqihi3): New insn.\n+\t(*oumulqihi3): New insn.\n+\t(*muluqihi3.uconst): New insn_and_split.\n+\t(*muluqihi3.sconst): New insn_and_split.\n+\t(*mulsqihi3.sconst): New insn_and_split.\n+\t(*mulsqihi3.uconst): New insn_and_split.\n+\t(*mulsqihi3.oconst): New insn_and_split.\n+\t(*ashifthi3.signx.const): New insn_and_split.\n+\t(*ashifthi3.signx.const7): New insn_and_split.\n+\t(*ashifthi3.zerox.const): New insn_and_split.\n+\t(mulsqihi3): New insn.\n+\t(muluqihi3): New insn.\n+\t(muloqihi3): New insn.\n+\t* config/avr/predicates.md (const_2_to_7_operand): New.\n+\t(const_2_to_6_operand): New.\n+\t(u8_operand): New.\n+\t(s8_operand): New.\n+\t(o8_operand): New.\n+\t(s9_operand): New.\n+\t(register_or_s9_operand): New.\n+\n 2011-07-20  Kai Tietz  <ktietz@redhat.com>\n \n \t* builtins.c (fold_builtin_expect): See through the cast"}, {"sha": "15ad9a164fd7cfb52fecbdee5e7cc6aaa4fede29", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c352fa8edadc62089e29ade8fd59e0a281645fa/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c352fa8edadc62089e29ade8fd59e0a281645fa/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=8c352fa8edadc62089e29ade8fd59e0a281645fa", "patch": "@@ -5464,7 +5464,42 @@ avr_rtx_costs (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED, int *total,\n \n \tcase HImode:\n \t  if (AVR_HAVE_MUL)\n-\t    *total = COSTS_N_INSNS (!speed ? 7 : 10);\n+            {\n+              rtx op0 = XEXP (x, 0);\n+              rtx op1 = XEXP (x, 1);\n+              enum rtx_code code0 = GET_CODE (op0);\n+              enum rtx_code code1 = GET_CODE (op1);\n+              bool ex0 = SIGN_EXTEND == code0 || ZERO_EXTEND == code0;\n+              bool ex1 = SIGN_EXTEND == code1 || ZERO_EXTEND == code1;\n+\n+              if (ex0\n+                  && (u8_operand (op1, HImode)\n+                      || s8_operand (op1, HImode)))\n+                {\n+                  *total = COSTS_N_INSNS (!speed ? 4 : 6);\n+                  return true;\n+                }\n+              if (ex0\n+                  && register_operand (op1, HImode))\n+                {\n+                  *total = COSTS_N_INSNS (!speed ? 5 : 8);\n+                  return true;\n+                }\n+              else if (ex0 || ex1)\n+                {\n+                  *total = COSTS_N_INSNS (!speed ? 3 : 5);\n+                  return true;\n+                }\n+              else if (register_operand (op0, HImode)\n+                       && (u8_operand (op1, HImode)\n+                           || s8_operand (op1, HImode)))\n+                {\n+                  *total = COSTS_N_INSNS (!speed ? 6 : 9);\n+                  return true;\n+                }\n+              else\n+                *total = COSTS_N_INSNS (!speed ? 7 : 10);\n+            }\n \t  else if (!speed)\n \t    *total = COSTS_N_INSNS (AVR_HAVE_JMP_CALL ? 2 : 1);\n \t  else\n@@ -5547,6 +5582,17 @@ avr_rtx_costs (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED, int *total,\n \t  break;\n \n \tcase HImode:\n+          if (AVR_HAVE_MUL)\n+            {\n+              if (const_2_to_7_operand (XEXP (x, 1), HImode)\n+                  && (SIGN_EXTEND == GET_CODE (XEXP (x, 0))\n+                      || ZERO_EXTEND == GET_CODE (XEXP (x, 0))))\n+                {\n+                  *total = COSTS_N_INSNS (!speed ? 4 : 6);\n+                  return true;\n+                }\n+            }\n+          \n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n \t      *total = COSTS_N_INSNS (!speed ? 5 : 41);"}, {"sha": "250133e5ebbb95f5882ca1ef37e05cab5ea909ce", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 292, "deletions": 10, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c352fa8edadc62089e29ade8fd59e0a281645fa/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c352fa8edadc62089e29ade8fd59e0a281645fa/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=8c352fa8edadc62089e29ade8fd59e0a281645fa", "patch": "@@ -1017,19 +1017,301 @@\n   [(set_attr \"length\" \"3\")\n    (set_attr \"cc\" \"clobber\")])\n \n+(define_insn \"usmulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\"                         \"=r\")\n+        (mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"a\"))\n+                 (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"a\"))))]\n+  \"AVR_HAVE_MUL\"\n+  \"mulsu %2,%1\n+\tmovw %0,r0\n+\tclr __zero_reg__\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Above insn is not canonicalized by insn combine, so here is a version with\n+;; operands swapped.\n+\n+(define_insn \"*sumulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\"                         \"=r\")\n+        (mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"a\"))\n+                 (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"a\"))))]\n+  \"AVR_HAVE_MUL\"\n+  \"mulsu %1,%2\n+\tmovw %0,r0\n+\tclr __zero_reg__\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; One-extend operand 1\n+\n+(define_insn \"*osmulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\"                                        \"=&r\")\n+        (mult:HI (not:HI (zero_extend:HI (not:QI (match_operand:QI 1 \"register_operand\" \"a\"))))\n+                 (sign_extend:HI (match_operand:QI 2 \"register_operand\"                 \"a\"))))]\n+  \"AVR_HAVE_MUL\"\n+  \"mulsu %2,%1\n+\tmovw %0,r0\n+\tsub %B0,%2\n+\tclr __zero_reg__\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*oumulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\"                                        \"=&r\")\n+        (mult:HI (not:HI (zero_extend:HI (not:QI (match_operand:QI 1 \"register_operand\" \"r\"))))\n+                 (zero_extend:HI (match_operand:QI 2 \"register_operand\"                 \"r\"))))]\n+  \"AVR_HAVE_MUL\"\n+  \"mul %2,%1\n+\tmovw %0,r0\n+\tsub %B0,%2\n+\tclr __zero_reg__\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+\n+;******************************************************************************\n+; mul HI: $1 = sign/zero-extend, $2 = small constant\n+;******************************************************************************\n+\n+(define_insn_and_split \"*muluqihi3.uconst\"\n+  [(set (match_operand:HI 0 \"register_operand\"                         \"=r\")\n+        (mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"r\"))\n+                 (match_operand:HI 2 \"u8_operand\"                       \"M\")))\n+   (clobber (match_scratch:QI 3                                       \"=&d\"))]\n+  \"AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+        (match_dup 2))\n+   ; umulqihi3\n+   (set (match_dup 0)\n+        (mult:HI (zero_extend:HI (match_dup 1))\n+                 (zero_extend:HI (match_dup 3))))]\n+  {\n+    operands[2] = gen_int_mode (INTVAL (operands[2]), QImode);\n+  })\n+\n+(define_insn_and_split \"*muluqihi3.sconst\"\n+  [(set (match_operand:HI 0 \"register_operand\"                         \"=r\")\n+        (mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"a\"))\n+                 (match_operand:HI 2 \"s8_operand\"                       \"n\")))\n+   (clobber (match_scratch:QI 3                                       \"=&a\"))]\n+  \"AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+        (match_dup 2))\n+   ; usmulqihi3\n+   (set (match_dup 0)\n+        (mult:HI (zero_extend:HI (match_dup 1))\n+                 (sign_extend:HI (match_dup 3))))]\n+  {\n+    operands[2] = gen_int_mode (INTVAL (operands[2]), QImode);\n+  })\n+\n+(define_insn_and_split \"*mulsqihi3.sconst\"\n+  [(set (match_operand:HI 0 \"register_operand\"                         \"=r\")\n+        (mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"d\"))\n+                 (match_operand:HI 2 \"s8_operand\"                       \"n\")))\n+   (clobber (match_scratch:QI 3                                       \"=&d\"))]\n+  \"AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+        (match_dup 2))\n+   ; mulqihi3\n+   (set (match_dup 0)\n+        (mult:HI (sign_extend:HI (match_dup 1))\n+                 (sign_extend:HI (match_dup 3))))]\n+  {\n+    operands[2] = gen_int_mode (INTVAL (operands[2]), QImode);\n+  })\n+\n+(define_insn_and_split \"*mulsqihi3.uconst\"\n+  [(set (match_operand:HI 0 \"register_operand\"                         \"=r\")\n+        (mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"a\"))\n+                 (match_operand:HI 2 \"u8_operand\"                       \"M\")))\n+   (clobber (match_scratch:QI 3                                       \"=&a\"))]\n+  \"AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+        (match_dup 2))\n+   ; usmulqihi3\n+   (set (match_dup 0)\n+        (mult:HI (zero_extend:HI (match_dup 3))\n+                 (sign_extend:HI (match_dup 1))))]\n+  {\n+    operands[2] = gen_int_mode (INTVAL (operands[2]), QImode);\n+  })\n+\n+(define_insn_and_split \"*mulsqihi3.oconst\"\n+  [(set (match_operand:HI 0 \"register_operand\"                        \"=&r\")\n+        (mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"a\"))\n+                 (match_operand:HI 2 \"o8_operand\"                       \"n\")))\n+   (clobber (match_scratch:QI 3                                       \"=&a\"))]\n+  \"AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+        (match_dup 2))\n+   ; *osmulqihi3\n+   (set (match_dup 0)\n+        (mult:HI (not:HI (zero_extend:HI (not:QI (match_dup 3))))\n+                 (sign_extend:HI (match_dup 1))))]\n+  {\n+    operands[2] = gen_int_mode (INTVAL (operands[2]), QImode);\n+  })\n+\n+;; The EXTEND of $1 only appears in combine, we don't see it in expand so that\n+;; expand decides to use ASHIFT instead of MUL because ASHIFT costs are cheaper\n+;; at that time.  Fix that.\n+\n+(define_insn_and_split \"*ashifthi3.signx.const\"\n+  [(set (match_operand:HI 0 \"register_operand\"                           \"=r\")\n+        (ashift:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"d\"))\n+                   (match_operand:HI 2 \"const_2_to_6_operand\"             \"I\")))\n+   (clobber (match_scratch:QI 3                                         \"=&d\"))]\n+  \"AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+        (match_dup 2))\n+   ; mulqihi3\n+   (set (match_dup 0)\n+        (mult:HI (sign_extend:HI (match_dup 1))\n+                 (sign_extend:HI (match_dup 3))))]\n+  {\n+    operands[2] = GEN_INT (1 << INTVAL (operands[2]));\n+  })\n+\n+(define_insn_and_split \"*ashifthi3.signx.const7\"\n+  [(set (match_operand:HI 0 \"register_operand\"                           \"=r\")\n+        (ashift:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"a\"))\n+                   (const_int 7)))\n+   (clobber (match_scratch:QI 2                                         \"=&a\"))]\n+  \"AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 2)\n+        (match_dup 3))\n+   ; usmulqihi3\n+   (set (match_dup 0)\n+        (mult:HI (zero_extend:HI (match_dup 2))\n+                 (sign_extend:HI (match_dup 1))))]\n+  {\n+    operands[3] = gen_int_mode (1 << 7, QImode);\n+  })\n+\n+(define_insn_and_split \"*ashifthi3.zerox.const\"\n+  [(set (match_operand:HI 0 \"register_operand\"                           \"=r\")\n+        (ashift:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"r\"))\n+                   (match_operand:HI 2 \"const_2_to_7_operand\"             \"I\")))\n+   (clobber (match_scratch:QI 3                                         \"=&d\"))]\n+  \"AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+        (match_dup 2))\n+   ; umulqihi3\n+   (set (match_dup 0)\n+        (mult:HI (zero_extend:HI (match_dup 1))\n+                 (zero_extend:HI (match_dup 3))))]\n+  {\n+    operands[2] = gen_int_mode (1 << INTVAL (operands[2]), QImode);\n+  })\n+\n+;******************************************************************************\n+; mul HI: $1 = sign-/zero-/one-extend, $2 = reg\n+;******************************************************************************\n+\n+(define_insn \"mulsqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\"                        \"=&r\")\n+        (mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"a\"))\n+                 (match_operand:HI 2 \"register_operand\"                 \"a\")))]\n+  \"AVR_HAVE_MUL\"\n+  \"mulsu %1,%A2\n+\tmovw %0,r0\n+\tmul %1,%B2\n+\tadd %B0,r0\n+\tclr __zero_reg__\"\n+  [(set_attr \"length\" \"5\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"muluqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\"                        \"=&r\")\n+        (mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"r\"))\n+                 (match_operand:HI 2 \"register_operand\"                 \"r\")))]\n+  \"AVR_HAVE_MUL\"\n+  \"mul %1,%A2\n+\tmovw %0,r0\n+\tmul %1,%B2\n+\tadd %B0,r0\n+\tclr __zero_reg__\"\n+  [(set_attr \"length\" \"5\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; one-extend operand 1\n+\n+(define_insn \"muloqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\"                                        \"=&r\")\n+        (mult:HI (not:HI (zero_extend:HI (not:QI (match_operand:QI 1 \"register_operand\" \"r\"))))\n+                 (match_operand:HI 2 \"register_operand\"                                 \"r\")))]\n+  \"AVR_HAVE_MUL\"\n+  \"mul %1,%A2\n+\tmovw %0,r0\n+\tmul %1,%B2\n+\tadd %B0,r0\n+\tsub %B0,%A2\n+\tclr __zero_reg__\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;******************************************************************************\n+\n (define_expand \"mulhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(mult:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t (match_operand:HI 2 \"register_operand\" \"\")))]\n+        (mult:HI (match_operand:HI 1 \"register_operand\" \"\")\n+                 (match_operand:HI 2 \"register_or_s9_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  if (!AVR_HAVE_MUL)\n-    {\n-      emit_insn (gen_mulhi3_call (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-}\")\n+  {\n+    if (!AVR_HAVE_MUL)\n+      {\n+        if (!register_operand (operands[2], HImode))\n+          operands[2] = force_reg (HImode, operands[2]);\n+\n+        emit_insn (gen_mulhi3_call (operands[0], operands[1], operands[2]));\n+        DONE;\n+      }\n+\n+    /* For small constants we can do better by extending them on the fly.\n+       The constant can be loaded in one instruction and the widening\n+       multiplication is shorter.  First try the unsigned variant because it\n+       allows constraint \"d\" instead of \"a\" for the signed version.  */\n+\n+    if (s9_operand (operands[2], HImode))\n+      {\n+        rtx reg = force_reg (QImode, gen_int_mode (INTVAL (operands[2]), QImode));\n+\n+        if (u8_operand (operands[2], HImode))\n+          {\n+            emit_insn (gen_muluqihi3 (operands[0], reg, operands[1]));\n+          } \n+        else if (s8_operand (operands[2], HImode))\n+          {\n+            emit_insn (gen_mulsqihi3 (operands[0], reg, operands[1]));\n+          }\n+        else\n+          {\n+            emit_insn (gen_muloqihi3 (operands[0], reg, operands[1]));\n+          }\n+\n+        DONE;\n+      }\n+\n+    if (!register_operand (operands[2], HImode))\n+      operands[2] = force_reg (HImode, operands[2]);\n+  })\n \n (define_insn \"*mulhi3_enh\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=&r\")"}, {"sha": "6646cb5461007c0ccc231389f589de386b22f4f4", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c352fa8edadc62089e29ade8fd59e0a281645fa/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c352fa8edadc62089e29ade8fd59e0a281645fa/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=8c352fa8edadc62089e29ade8fd59e0a281645fa", "patch": "@@ -73,6 +73,16 @@\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (INTVAL (op), 0, 7)\")))\n \n+;; Return 1 if OP is constant integer 2..7 for MODE.\n+(define_predicate \"const_2_to_7_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 2, 7)\")))\n+\n+;; Return 1 if OP is constant integer 2..6 for MODE.\n+(define_predicate \"const_2_to_6_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 2, 6)\")))\n+\n ;; Returns true if OP is either the constant zero or a register.\n (define_predicate \"reg_or_0_operand\"\n   (ior (match_operand 0 \"register_operand\")\n@@ -156,3 +166,26 @@\n   (and (match_code \"const_int\")\n        (match_test \"8 == INTVAL(op) || 16 == INTVAL(op) || 24 == INTVAL(op)\")))\n \n+;; Unsigned CONST_INT that fits in 8 bits, i.e. 0..255.\n+(define_predicate \"u8_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 255)\")))\n+\n+;; Signed CONST_INT that fits in 8 bits, i.e. -128..127.\n+(define_predicate \"s8_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), -128, 127)\")))\n+\n+;; One-extended CONST_INT that fits in 8 bits, i.e. -256..-1.\n+(define_predicate \"o8_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), -256, -1)\")))\n+\n+;; Signed CONST_INT that fits in 9 bits, i.e. -256..255.\n+(define_predicate \"s9_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), -256, 255)\")))\n+\n+(define_predicate \"register_or_s9_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"s9_operand\")))"}]}