{"sha": "b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE5ZWU0YmQyNGJiMmVmMDY5MTFmZGY2MDlhMTU2MTcxZTJhNGUwZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2003-10-27T10:52:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2003-10-27T10:52:48Z"}, "message": "reload1.c (struct elim_table): Change offset, initial_offset and previous_offset fields to HOST_WIDE_INT.\n\n\t* reload1.c (struct elim_table): Change offset, initial_offset and\n\tprevious_offset fields to HOST_WIDE_INT.\n\t(offsets_at): Change from int to HOST_WIDE_INT.\n\t(reload): Adjust offsets_at initialization.\n\t(eliminate_regs_in_insn): Change type of offset to HOST_WIDE_INT.\n\t(verify_initial_elim_offsets): Change type of t to HOST_WIDE_INT.\n\t* config/i386/i386.c (ix86_compute_frame_layout): Change offset type\n\tto HOST_WIDE_INT.  Don't save regs using mov for huge frame sizes\n\tif TARGET_64BIT.\n\t(pro_epilogue_adjust_stack): New function.\n\t(ix86_expand_prologue, ix86_expand_epilogue): Use it.\n\t* config/i386/i386.md (pro_epilogue_adjust_stack): Remove.\n\t(pro_epilogue_adjust_stack_1): Remove * in front of name.\n\t(pro_epilogue_adjust_stack_rex64): Handle -2147483648 properly.\n\t(pro_epilogue_adjust_stack_rex64_2): New insn.\n\n\t* config/i386/i386.c (ix86_expand_epilogue): Fix comment typo.\n\n\t* config/i386/i386.c (ix86_expand_call): Replace 40 with\n\tFIRST_REX_INT_REG + 3 /* R11 */.\n\n\t* gcc.c-torture/compile/20031023-1.c: New test.\n\t* gcc.c-torture/compile/20031023-2.c: New test.\n\t* gcc.c-torture/compile/20031023-3.c: New test.\n\t* gcc.c-torture/compile/20031023-4.c: New test.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r72975", "tree": {"sha": "cf433ef961eba9a9d96687e329ae8e19971b3acd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf433ef961eba9a9d96687e329ae8e19971b3acd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "501e79efe738024b9c01a2bbb931226e181e2620", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/501e79efe738024b9c01a2bbb931226e181e2620", "html_url": "https://github.com/Rust-GCC/gccrs/commit/501e79efe738024b9c01a2bbb931226e181e2620"}], "stats": {"total": 244, "additions": 194, "deletions": 50}, "files": [{"sha": "6bac39831e92292f1dac2e2f6d720838b8395dd3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "patch": "@@ -1,3 +1,27 @@\n+2003-10-27  Jakub Jelinek  <jakub@redhat.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\n+\t* reload1.c (struct elim_table): Change offset, initial_offset and\n+\tprevious_offset fields to HOST_WIDE_INT.\n+\t(offsets_at): Change from int to HOST_WIDE_INT.\n+\t(reload): Adjust offsets_at initialization.\n+\t(eliminate_regs_in_insn): Change type of offset to HOST_WIDE_INT.\n+\t(verify_initial_elim_offsets): Change type of t to HOST_WIDE_INT.\n+\t* config/i386/i386.c (ix86_compute_frame_layout): Change offset type\n+\tto HOST_WIDE_INT.  Don't save regs using mov for huge frame sizes\n+\tif TARGET_64BIT.\n+\t(pro_epilogue_adjust_stack): New function.\n+\t(ix86_expand_prologue, ix86_expand_epilogue): Use it.\n+\t* config/i386/i386.md (pro_epilogue_adjust_stack): Remove.\n+\t(pro_epilogue_adjust_stack_1): Remove * in front of name.\n+\t(pro_epilogue_adjust_stack_rex64): Handle -2147483648 properly.\n+\t(pro_epilogue_adjust_stack_rex64_2): New insn.\n+\n+\t* config/i386/i386.c (ix86_expand_epilogue): Fix comment typo.\n+\n+\t* config/i386/i386.c (ix86_expand_call): Replace 40 with\n+\tFIRST_REX_INT_REG + 3 /* R11 */.\n+\n 2003-10-26  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.md (attr cannot_copy): New."}, {"sha": "25240acc9d7d65e00a3b9738faab258957e20fa7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 56, "deletions": 25, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "patch": "@@ -4882,7 +4882,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n {\n   HOST_WIDE_INT total_size;\n   int stack_alignment_needed = cfun->stack_alignment_needed / BITS_PER_UNIT;\n-  int offset;\n+  HOST_WIDE_INT offset;\n   int preferred_alignment = cfun->preferred_stack_boundary / BITS_PER_UNIT;\n   HOST_WIDE_INT size = get_frame_size ();\n \n@@ -4998,7 +4998,8 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n     (size + frame->padding1 + frame->padding2\n      + frame->outgoing_arguments_size + frame->va_arg_size);\n \n-  if (!frame->to_allocate && frame->nregs <= 1)\n+  if ((!frame->to_allocate && frame->nregs <= 1)\n+      || (TARGET_64BIT && frame->to_allocate >= (HOST_WIDE_INT) 0x80000000))\n     frame->save_regs_using_mov = false;\n \n   if (TARGET_RED_ZONE && current_function_sp_is_unchanging\n@@ -5065,6 +5066,41 @@ ix86_emit_save_regs_using_mov (rtx pointer, HOST_WIDE_INT offset)\n       }\n }\n \n+/* Expand prologue or epilogue stack adjustement.\n+   The pattern exist to put a dependency on all ebp-based memory accesses.\n+   STYLE should be negative if instructions should be marked as frame related,\n+   zero if %r11 register is live and cannot be freely used and positive\n+   otherwise.  */\n+\n+static void\n+pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset, int style)\n+{\n+  rtx insn;\n+\n+  if (! TARGET_64BIT)\n+    insn = emit_insn (gen_pro_epilogue_adjust_stack_1 (dest, src, offset));\n+  else if (x86_64_immediate_operand (offset, DImode))\n+    insn = emit_insn (gen_pro_epilogue_adjust_stack_rex64 (dest, src, offset));\n+  else\n+    {\n+      rtx r11;\n+      /* r11 is used by indirect sibcall return as well, set before the\n+\t epilogue and used after the epilogue.  ATM indirect sibcall\n+\t shouldn't be used together with huge frame sizes in one\n+\t function because of the frame_size check in sibcall.c.  */\n+      if (style == 0)\n+\tabort ();\n+      r11 = gen_rtx_REG (DImode, FIRST_REX_INT_REG + 3 /* R11 */);\n+      insn = emit_insn (gen_rtx_SET (DImode, r11, offset));\n+      if (style < 0)\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+      insn = emit_insn (gen_pro_epilogue_adjust_stack_rex64_2 (dest, src, r11,\n+\t\t\t\t\t\t\t       offset));\n+    }\n+  if (style < 0)\n+    RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n@@ -5106,12 +5142,8 @@ ix86_expand_prologue (void)\n   if (allocate == 0)\n     ;\n   else if (! TARGET_STACK_PROBE || allocate < CHECK_STACK_LIMIT)\n-    {\n-      insn = emit_insn (gen_pro_epilogue_adjust_stack\n-\t\t\t(stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t GEN_INT (-allocate)));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-    }\n+    pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t       GEN_INT (-allocate), -1);\n   else\n     {\n       /* Only valid for Win32.  */\n@@ -5266,8 +5298,8 @@ ix86_expand_epilogue (int style)\n \t      tmp = gen_rtx_MEM (Pmode, hard_frame_pointer_rtx);\n \t      emit_move_insn (hard_frame_pointer_rtx, tmp);\n \n-\t      emit_insn (gen_pro_epilogue_adjust_stack\n-\t\t\t (stack_pointer_rtx, sa, const0_rtx));\n+\t      pro_epilogue_adjust_stack (stack_pointer_rtx, sa,\n+\t\t\t\t\t const0_rtx, style);\n \t    }\n \t  else\n \t    {\n@@ -5278,19 +5310,19 @@ ix86_expand_epilogue (int style)\n \t    }\n \t}\n       else if (!frame_pointer_needed)\n-\temit_insn (gen_pro_epilogue_adjust_stack\n-\t\t   (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t    GEN_INT (frame.to_allocate\n-\t\t\t     + frame.nregs * UNITS_PER_WORD)));\n+\tpro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t   GEN_INT (frame.to_allocate\n+\t\t\t\t\t    + frame.nregs * UNITS_PER_WORD),\n+\t\t\t\t   style);\n       /* If not an i386, mov & pop is faster than \"leave\".  */\n       else if (TARGET_USE_LEAVE || optimize_size\n \t       || !cfun->machine->use_fast_prologue_epilogue)\n \temit_insn (TARGET_64BIT ? gen_leave_rex64 () : gen_leave ());\n       else\n \t{\n-\t  emit_insn (gen_pro_epilogue_adjust_stack (stack_pointer_rtx,\n-\t\t\t\t\t\t    hard_frame_pointer_rtx,\n-\t\t\t\t\t\t    const0_rtx));\n+\t  pro_epilogue_adjust_stack (stack_pointer_rtx,\n+\t\t\t\t     hard_frame_pointer_rtx,\n+\t\t\t\t     const0_rtx, style);\n \t  if (TARGET_64BIT)\n \t    emit_insn (gen_popdi1 (hard_frame_pointer_rtx));\n \t  else\n@@ -5305,14 +5337,13 @@ ix86_expand_epilogue (int style)\n \t{\n \t  if (!frame_pointer_needed)\n \t    abort ();\n-          emit_insn (gen_pro_epilogue_adjust_stack (stack_pointer_rtx,\n-\t\t\t\t\t\t    hard_frame_pointer_rtx,\n-\t\t\t\t\t\t    GEN_INT (offset)));\n+\t  pro_epilogue_adjust_stack (stack_pointer_rtx,\n+\t\t\t\t     hard_frame_pointer_rtx,\n+\t\t\t\t     GEN_INT (offset), style);\n \t}\n       else if (frame.to_allocate)\n-\temit_insn (gen_pro_epilogue_adjust_stack\n-\t\t   (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t    GEN_INT (frame.to_allocate)));\n+\tpro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t   GEN_INT (frame.to_allocate), style);\n \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \tif (ix86_save_reg (regno, false))\n@@ -5351,7 +5382,7 @@ ix86_expand_epilogue (int style)\n \t{\n \t  rtx ecx = gen_rtx_REG (SImode, 2);\n \n-\t  /* There are is no \"pascal\" calling convention in 64bit ABI.  */\n+\t  /* There is no \"pascal\" calling convention in 64bit ABI.  */\n \t  if (TARGET_64BIT)\n \t    abort ();\n \n@@ -11594,7 +11625,7 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1, rtx callarg2,\n     {\n       rtx addr;\n       addr = copy_to_mode_reg (Pmode, XEXP (fnaddr, 0));\n-      fnaddr = gen_rtx_REG (Pmode, 40);\n+      fnaddr = gen_rtx_REG (Pmode, FIRST_REX_INT_REG + 3 /* R11 */);\n       emit_move_insn (fnaddr, addr);\n       fnaddr = gen_rtx_MEM (QImode, fnaddr);\n     }"}, {"sha": "f9acc04ec7b56c23817bf530c34890e0d97abb77", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "patch": "@@ -17772,23 +17772,7 @@\n ;; [(set (mem (plus (reg ebp) (const_int -160000))) (const_int 0))]\n ;;\n ;; in proper program order.\n-(define_expand \"pro_epilogue_adjust_stack\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t\t   (plus:SI (match_operand:SI 1 \"register_operand\" \"0,r\")\n-\t\t\t    (match_operand:SI 2 \"immediate_operand\" \"i,i\")))\n-\t      (clobber (reg:CC 17))\n-\t      (clobber (mem:BLK (scratch)))])]\n- \"\"\n-{\n-  if (TARGET_64BIT)\n-    {\n-      emit_insn (gen_pro_epilogue_adjust_stack_rex64\n-\t\t (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-})\n-\n-(define_insn \"*pro_epilogue_adjust_stack_1\"\n+(define_insn \"pro_epilogue_adjust_stack_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"0,r\")\n \t         (match_operand:SI 2 \"immediate_operand\" \"i,i\")))\n@@ -17844,6 +17828,8 @@\n \n     case TYPE_ALU:\n       if (GET_CODE (operands[2]) == CONST_INT\n+\t  /* Avoid overflows.  */\n+\t  && ((INTVAL (operands[2]) & ((((unsigned int) 1) << 31) - 1)))\n           && (INTVAL (operands[2]) == 128\n \t      || (INTVAL (operands[2]) < 0\n \t          && INTVAL (operands[2]) != -128)))\n@@ -17870,6 +17856,30 @@\n \t      (const_string \"lea\")))\n    (set_attr \"mode\" \"DI\")])\n \n+(define_insn \"pro_epilogue_adjust_stack_rex64_2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"0,r\")\n+\t\t (match_operand:DI 3 \"immediate_operand\" \"i,i\")))\n+   (use (match_operand:DI 2 \"register_operand\" \"r,r\"))\n+   (clobber (reg:CC 17))\n+   (clobber (mem:BLK (scratch)))]\n+  \"TARGET_64BIT\"\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_ALU:\n+      return \"add{q}\\t{%2, %0|%0, %2}\";\n+\n+    case TYPE_LEA:\n+      operands[2] = gen_rtx_PLUS (DImode, operands[1], operands[2]);\n+      return \"lea{q}\\t{%a2, %0|%0, %a2}\";\n+\n+    default:\n+      abort ();\n+    }\n+}\n+  [(set_attr \"type\" \"alu,lea\")\n+   (set_attr \"mode\" \"DI\")])\n \n ;; Placeholder for the conditional moves.  This one is split either to SSE\n ;; based moves emulation or to usual cmove sequence.  Little bit unfortunate"}, {"sha": "717489f3216c216612261e94abf991282f0123df", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "patch": "@@ -293,12 +293,12 @@ struct elim_table\n {\n   int from;\t\t\t/* Register number to be eliminated.  */\n   int to;\t\t\t/* Register number used as replacement.  */\n-  int initial_offset;\t\t/* Initial difference between values.  */\n+  HOST_WIDE_INT initial_offset;\t/* Initial difference between values.  */\n   int can_eliminate;\t\t/* Nonzero if this elimination can be done.  */\n   int can_eliminate_previous;\t/* Value of CAN_ELIMINATE in previous scan over\n \t\t\t\t   insns made by reload.  */\n-  int offset;\t\t\t/* Current offset between the two regs.  */\n-  int previous_offset;\t\t/* Offset at end of previous insn.  */\n+  HOST_WIDE_INT offset;\t\t/* Current offset between the two regs.  */\n+  HOST_WIDE_INT previous_offset;/* Offset at end of previous insn.  */\n   int ref_outside_mem;\t\t/* \"to\" has been referenced outside a MEM.  */\n   rtx from_rtx;\t\t\t/* REG rtx for the register to be eliminated.\n \t\t\t\t   We cannot simply compare the number since\n@@ -352,7 +352,7 @@ static int num_eliminable_invariants;\n \n static int first_label_num;\n static char *offsets_known_at;\n-static int (*offsets_at)[NUM_ELIMINABLE_REGS];\n+static HOST_WIDE_INT (*offsets_at)[NUM_ELIMINABLE_REGS];\n \n /* Number of labels in the current function.  */\n \n@@ -816,7 +816,7 @@ reload (rtx first, int global)\n      allocate would occasionally cause it to exceed the stack limit and\n      cause a core dump.  */\n   offsets_known_at = xmalloc (num_labels);\n-  offsets_at = xmalloc (num_labels * NUM_ELIMINABLE_REGS * sizeof (int));\n+  offsets_at = xmalloc (num_labels * NUM_ELIMINABLE_REGS * sizeof (HOST_WIDE_INT));\n \n   /* Alter each pseudo-reg rtx to contain its hard reg number.\n      Assign stack slots to the pseudos that lack hard regs or equivalents.\n@@ -2897,7 +2897,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t      {\n \t\trtx base = SET_SRC (old_set);\n \t\trtx base_insn = insn;\n-\t\tint offset = 0;\n+\t\tHOST_WIDE_INT offset = 0;\n \n \t\twhile (base != ep->to_rtx)\n \t\t  {\n@@ -2980,7 +2980,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n       && REGNO (XEXP (SET_SRC (old_set), 0)) < FIRST_PSEUDO_REGISTER)\n     {\n       rtx reg = XEXP (SET_SRC (old_set), 0);\n-      int offset = INTVAL (XEXP (SET_SRC (old_set), 1));\n+      HOST_WIDE_INT offset = INTVAL (XEXP (SET_SRC (old_set), 1));\n \n       for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n \tif (ep->from_rtx == reg && ep->can_eliminate)\n@@ -3263,7 +3263,7 @@ mark_not_eliminable (rtx dest, rtx x, void *data ATTRIBUTE_UNUSED)\n static void\n verify_initial_elim_offsets (void)\n {\n-  int t;\n+  HOST_WIDE_INT t;\n \n #ifdef ELIMINABLE_REGS\n   struct elim_table *ep;"}, {"sha": "516383756332deaa870ad6b09223ddbd254bae8a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "patch": "@@ -1,3 +1,10 @@\n+2003-10-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/compile/20031023-1.c: New test.\n+\t* gcc.c-torture/compile/20031023-2.c: New test.\n+\t* gcc.c-torture/compile/20031023-3.c: New test.\n+\t* gcc.c-torture/compile/20031023-4.c: New test.\n+\n 2003-10-26  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/10371"}, {"sha": "67f8ea9181ada88786a0b046b54676be362505e2", "filename": "gcc/testsuite/gcc.c-torture/compile/20031023-1.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031023-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031023-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031023-1.c?ref=b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "patch": "@@ -0,0 +1,66 @@\n+#ifndef ASIZE\n+# define ASIZE 0x10000000000UL\n+#endif\n+\n+#include <limits.h>\n+\n+#if LONG_MAX < 8 * ASIZE\n+# undef ASIZE\n+# define ASIZE 4096\n+#endif\n+\n+extern void abort (void);\n+\n+int __attribute__((noinline))\n+foo (const char *s)\n+{\n+  if (!s)\n+    return 1;\n+  if (s[0] != 'a')\n+    abort ();\n+  s += ASIZE - 1;\n+  if (s[0] != 'b')\n+    abort ();\n+  return 0;\n+}\n+\n+int (*fn) (const char *) = foo;\n+\n+int __attribute__((noinline))\n+bar (void)\n+{\n+  char s[ASIZE];\n+  s[0] = 'a';\n+  s[ASIZE - 1] = 'b';\n+  foo (s);\n+  foo (s);\n+  return 0;\n+}\n+\n+int __attribute__((noinline))\n+baz (long i)\n+{\n+  if (i)\n+    return fn (0);\n+  else\n+    {\n+      char s[ASIZE];\n+      s[0] = 'a';\n+      s[ASIZE - 1] = 'b';\n+      foo (s);\n+      foo (s);\n+      return fn (0);\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  if (bar ())\n+    abort ();\n+  if (baz (0) != 1)\n+    abort ();\n+  if (baz (1) != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "663e447157e77acd456b150ec6ad85ec6748c82f", "filename": "gcc/testsuite/gcc.c-torture/compile/20031023-2.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031023-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031023-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031023-2.c?ref=b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "patch": "@@ -0,0 +1,2 @@\n+#define ASIZE 0x1000000000UL\n+#include \"20031023-1.c\""}, {"sha": "f4a16c73c0df8c4a9a2a2d5d0c5460d4e548b289", "filename": "gcc/testsuite/gcc.c-torture/compile/20031023-3.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031023-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031023-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031023-3.c?ref=b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "patch": "@@ -0,0 +1,2 @@\n+#define ASIZE 0x100000000UL\n+#include \"20031023-1.c\""}, {"sha": "5c61f3743d4f994aabd7c93901fc5b839aa352ee", "filename": "gcc/testsuite/gcc.c-torture/compile/20031023-4.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031023-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19ee4bd24bb2ef06911fdf609a156171e2a4e0d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031023-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20031023-4.c?ref=b19ee4bd24bb2ef06911fdf609a156171e2a4e0d", "patch": "@@ -0,0 +1,2 @@\n+#define ASIZE 0x80000000UL\n+#include \"20031023-1.c\""}]}