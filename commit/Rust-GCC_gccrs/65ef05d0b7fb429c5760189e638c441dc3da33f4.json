{"sha": "65ef05d0b7fb429c5760189e638c441dc3da33f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVlZjA1ZDBiN2ZiNDI5YzU3NjAxODllNjM4YzQ0MWRjM2RhMzNmNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-30T18:50:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-30T18:50:06Z"}, "message": "[C] Add a target hook that allows targets to verify type usage\n\nThis patch adds a new target hook to check whether there are any\ntarget-specific reasons why a type cannot be used in a certain\nsource-language context.  It works in a similar way to existing\nhooks like TARGET_INVALID_CONVERSION and TARGET_INVALID_UNARY_OP.\n\nThe reason for adding the hook is to report invalid uses of SVE types.\nThroughout a TU, the SVE vector and predicate types represent values\nthat can be stored in an SVE vector or predicate register.  At certain\npoints in the TU we might be able to generate code that assumes the\nregisters have a particular size, but often we can't.  In some cases\nwe might even make multiple different assumptions in the same TU\n(e.g. when implementing an ifunc for multiple vector lengths).\n\nBut SVE types themselves are the same type throughout.  The register\nsize assumptions change how we generate code, but they don't change\nthe definition of the types.\n\nThis means that the types do not have a fixed size at the C level\neven when -msve-vector-bits=N is in effect.  It also means that the\nsize does not work in the same way as for C VLAs, where the abstract\nmachine evaluates the size at a particular point and then carries that\nsize forward to later code.\n\nThe SVE ACLE deals with this by making it invalid to use C and C++\nconstructs that depend on the size or layout of SVE types.  The spec\nrefers to the types as \"sizeless\" types and defines their semantics as\nedits to the standards.  See:\n\n  https://gcc.gnu.org/ml/gcc-patches/2018-10/msg00868.html\n\nfor a fuller description and:\n\n  https://gcc.gnu.org/ml/gcc/2019-11/msg00088.html\n\nfor a recent update on the status.\n\nHowever, since all current sizeless types are target-specific built-in\ntypes, there's no real reason for the frontends to handle them directly.\nThey can just hand off the checks to target code instead.  It's then\npossible for the errors to refer to \"SVE types\" rather than \"sizeless\ntypes\", which is likely to be more meaningful to users.\n\nThere is a slight overlap between the new tests and the ones for\ngnu_vector_type_p in r277950, but here the emphasis is on testing\nsizelessness.\n\n2019-11-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.h (type_context_kind): New enum.\n\t(verify_type_context): Declare.\n\t* target.def (verify_type_context): New target hook.\n\t* doc/tm.texi.in (TARGET_VERIFY_TYPE_CONTEXT): Likewise.\n\t* doc/tm.texi: Regenerate.\n\t* tree.c (verify_type_context): New function.\n\t* config/aarch64/aarch64-protos.h (aarch64_sve::verify_type_context):\n\tDeclare.\n\t* config/aarch64/aarch64-sve-builtins.cc (verify_type_context):\n\tNew function.\n\t* config/aarch64/aarch64.c (aarch64_verify_type_context): Likewise.\n\t(TARGET_VERIFY_TYPE_CONTEXT): Define.\n\ngcc/c-family/\n\t* c-common.c (pointer_int_sum): Use verify_type_context to check\n\twhether the target allows pointer arithmetic for the types involved.\n\t(c_sizeof_or_alignof_type, c_alignof_expr): Use verify_type_context\n\tto check whether the target allows sizeof and alignof operations\n\tfor the types involved.\n\ngcc/c/\n\t* c-decl.c (start_decl): Allow initialization of variables whose\n\tsize is a POLY_INT_CST.\n\t(finish_decl): Use verify_type_context to check whether the target\n\tallows variables with a particular type to have static or thread-local\n\tstorage duration.  Don't raise a second error if such variables do\n\tnot have a constant size.\n\t(grokdeclarator): Use verify_type_context to check whether the\n\ttarget allows fields or array elements to have a particular type.\n\t* c-typeck.c (pointer_diff): Use verify_type_context to test whether\n\tthe target allows pointer difference for the types involved.\n\t(build_unary_op): Likewise for pointer increment and decrement.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/acle/general-c/sizeless-1.c: New test.\n\t* gcc.target/aarch64/sve/acle/general-c/sizeless-2.c: Likewise.\n\nFrom-SVN: r278877", "tree": {"sha": "0f798da78b2315a23be7f7f79b6a7fa0380a0ecf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f798da78b2315a23be7f7f79b6a7fa0380a0ecf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65ef05d0b7fb429c5760189e638c441dc3da33f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65ef05d0b7fb429c5760189e638c441dc3da33f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65ef05d0b7fb429c5760189e638c441dc3da33f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65ef05d0b7fb429c5760189e638c441dc3da33f4/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b74d8dc4cf11da599b5c18d77a5039bc800d6871", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b74d8dc4cf11da599b5c18d77a5039bc800d6871", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b74d8dc4cf11da599b5c18d77a5039bc800d6871"}], "stats": {"total": 667, "additions": 664, "deletions": 3}, "files": [{"sha": "72c8d2e03d4134df05a23f8e2ec08cf49b8dbf64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -1,3 +1,18 @@\n+2019-11-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.h (type_context_kind): New enum.\n+\t(verify_type_context): Declare.\n+\t* target.def (verify_type_context): New target hook.\n+\t* doc/tm.texi.in (TARGET_VERIFY_TYPE_CONTEXT): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\t* tree.c (verify_type_context): New function.\n+\t* config/aarch64/aarch64-protos.h (aarch64_sve::verify_type_context):\n+\tDeclare.\n+\t* config/aarch64/aarch64-sve-builtins.cc (verify_type_context):\n+\tNew function.\n+\t* config/aarch64/aarch64.c (aarch64_verify_type_context): Likewise.\n+\t(TARGET_VERIFY_TYPE_CONTEXT): Define.\n+\n 2019-11-30  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cgraph.c (cgraph_node::dump): Dump unit_id and merged_extern_inline."}, {"sha": "763e5a269f6546cc1432e3855737a901a98e1378", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -1,3 +1,11 @@\n+2019-11-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* c-common.c (pointer_int_sum): Use verify_type_context to check\n+\twhether the target allows pointer arithmetic for the types involved.\n+\t(c_sizeof_or_alignof_type, c_alignof_expr): Use verify_type_context\n+\tto check whether the target allows sizeof and alignof operations\n+\tfor the types involved.\n+\n 2019-11-27  Jason Merrill  <jason@redhat.com>\n \n \t* c-cppbuiltin.c (c_cpp_builtins): Update __cpp_deduction_guides."}, {"sha": "2f389d2895aff1922ae634173381795dcbc3b026", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -3146,6 +3146,9 @@ pointer_int_sum (location_t loc, enum tree_code resultcode,\n \treturn error_mark_node;\n       size_exp = integer_one_node;\n     }\n+  else if (!verify_type_context (loc, TCTX_POINTER_ARITH,\n+\t\t\t\t TREE_TYPE (result_type)))\n+    size_exp = integer_one_node;\n   else\n     size_exp = size_in_bytes_loc (loc, TREE_TYPE (result_type));\n \n@@ -3691,6 +3694,13 @@ c_sizeof_or_alignof_type (location_t loc,\n \t\t  \"incomplete element type\", op_name, type);\n       return error_mark_node;\n     }\n+  else if (!verify_type_context (loc, is_sizeof ? TCTX_SIZEOF : TCTX_ALIGNOF,\n+\t\t\t\t type, !complain))\n+    {\n+      if (!complain)\n+\treturn error_mark_node;\n+      value = size_one_node;\n+    }\n   else\n     {\n       if (is_sizeof)\n@@ -3723,7 +3733,10 @@ c_alignof_expr (location_t loc, tree expr)\n {\n   tree t;\n \n-  if (VAR_OR_FUNCTION_DECL_P (expr))\n+  if (!verify_type_context (loc, TCTX_ALIGNOF, TREE_TYPE (expr)))\n+    t = size_one_node;\n+\n+  else if (VAR_OR_FUNCTION_DECL_P (expr))\n     t = size_int (DECL_ALIGN_UNIT (expr));\n \n   else if (TREE_CODE (expr) == COMPONENT_REF"}, {"sha": "8fee474346f1bd20c61dd7a9b36bfc90bd5c2662", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -1,3 +1,17 @@\n+2019-11-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* c-decl.c (start_decl): Allow initialization of variables whose\n+\tsize is a POLY_INT_CST.\n+\t(finish_decl): Use verify_type_context to check whether the target\n+\tallows variables with a particular type to have static or thread-local\n+\tstorage duration.  Don't raise a second error if such variables do\n+\tnot have a constant size.\n+\t(grokdeclarator): Use verify_type_context to check whether the\n+\ttarget allows fields or array elements to have a particular type.\n+\t* c-typeck.c (pointer_diff): Use verify_type_context to test whether\n+\tthe target allows pointer difference for the types involved.\n+\t(build_unary_op): Likewise for pointer increment and decrement.\n+\n 2019-11-29  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-parser.c (struct c_parser): Add members raw_tokens and"}, {"sha": "fa7dea5afb5f8d24a4fff3cb10c6a7909eb4349c", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -5021,7 +5021,7 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n \t  {\n \t    /* A complete type is ok if size is fixed.  */\n \n-\t    if (TREE_CODE (TYPE_SIZE (TREE_TYPE (decl))) != INTEGER_CST\n+\t    if (!poly_int_tree_p (TYPE_SIZE (TREE_TYPE (decl)))\n \t\t|| C_DECL_VARIABLE_SIZE (decl))\n \t      {\n \t\terror (\"variable-sized object may not be initialized\");\n@@ -5304,6 +5304,15 @@ finish_decl (tree decl, location_t init_loc, tree init,\n \n       complete_flexible_array_elts (DECL_INITIAL (decl));\n \n+      if (is_global_var (decl))\n+\t{\n+\t  type_context_kind context = (DECL_THREAD_LOCAL_P (decl)\n+\t\t\t\t       ? TCTX_THREAD_STORAGE\n+\t\t\t\t       : TCTX_STATIC_STORAGE);\n+\t  if (!verify_type_context (input_location, context, TREE_TYPE (decl)))\n+\t    TREE_TYPE (decl) = error_mark_node;\n+\t}\n+\n       if (DECL_SIZE (decl) == NULL_TREE && TREE_TYPE (decl) != error_mark_node\n \t  && COMPLETE_TYPE_P (TREE_TYPE (decl)))\n \tlayout_decl (decl, 0);\n@@ -5333,7 +5342,9 @@ finish_decl (tree decl, location_t init_loc, tree init,\n \t  && TREE_STATIC (decl))\n \tincomplete_record_decls.safe_push (decl);\n \n-      if (is_global_var (decl) && DECL_SIZE (decl) != NULL_TREE)\n+      if (is_global_var (decl)\n+\t  && DECL_SIZE (decl) != NULL_TREE\n+\t  && TREE_TYPE (decl) != error_mark_node)\n \t{\n \t  if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)\n \t    constant_expression_warning (DECL_SIZE (decl));\n@@ -5653,6 +5664,10 @@ build_compound_literal (location_t loc, tree type, tree init, bool non_const,\n       return error_mark_node;\n     }\n \n+  if (TREE_STATIC (decl)\n+      && !verify_type_context (loc, TCTX_STATIC_STORAGE, type))\n+    return error_mark_node;\n+\n   stmt = build_stmt (DECL_SOURCE_LOCATION (decl), DECL_EXPR, decl);\n   complit = build1 (COMPOUND_LITERAL_EXPR, type, stmt);\n   TREE_SIDE_EFFECTS (complit) = 1;\n@@ -6370,6 +6385,12 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    if (type == error_mark_node)\n \t      continue;\n \n+\t    if (!verify_type_context (loc, TCTX_ARRAY_ELEMENT, type))\n+\t      {\n+\t\ttype = error_mark_node;\n+\t\tcontinue;\n+\t      }\n+\n \t    /* If size was specified, set ITYPE to a range-type for\n \t       that size.  Otherwise, ITYPE remains null.  finish_decl\n \t       may figure it out from an initial value.  */\n@@ -7217,6 +7238,10 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    if (orig_qual_indirect == 0)\n \t      orig_qual_type = NULL_TREE;\n \t  }\n+\tif (type != error_mark_node\n+\t    && !verify_type_context (loc, TCTX_FIELD, type))\n+\t  type = error_mark_node;\n+\n \ttype = c_build_qualified_type (type, type_quals, orig_qual_type,\n \t\t\t\t       orig_qual_indirect);\n \tdecl = build_decl (declarator->id_loc,"}, {"sha": "f9ab1e38b4268ccbeb950eca73bf626a9c791aa1", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -3892,6 +3892,7 @@ pointer_diff (location_t loc, tree op0, tree op1, tree *instrument_expr)\n   addr_space_t as0 = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (op0)));\n   addr_space_t as1 = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (op1)));\n   tree target_type = TREE_TYPE (TREE_TYPE (op0));\n+  tree orig_op0 = op0;\n   tree orig_op1 = op1;\n \n   /* If the operands point into different address spaces, we need to\n@@ -3962,6 +3963,10 @@ pointer_diff (location_t loc, tree op0, tree op1, tree *instrument_expr)\n   /* This generates an error if op1 is pointer to incomplete type.  */\n   if (!COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (TREE_TYPE (orig_op1))))\n     error_at (loc, \"arithmetic on pointer to an incomplete type\");\n+  else if (verify_type_context (loc, TCTX_POINTER_ARITH,\n+\t\t\t\tTREE_TYPE (TREE_TYPE (orig_op0))))\n+    verify_type_context (loc, TCTX_POINTER_ARITH,\n+\t\t\t TREE_TYPE (TREE_TYPE (orig_op1)));\n \n   op1 = c_size_in_bytes (target_type);\n \n@@ -4614,6 +4619,9 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n \t\t  pedwarn (location, OPT_Wpointer_arith,\n \t\t\t   \"wrong type argument to decrement\");\n \t      }\n+\t    else\n+\t      verify_type_context (location, TCTX_POINTER_ARITH,\n+\t\t\t\t   TREE_TYPE (argtype));\n \n \t    inc = c_size_in_bytes (TREE_TYPE (argtype));\n \t    inc = convert_to_ptrofftype_loc (location, inc);"}, {"sha": "c16b9362ea986ff221755bfc4d10bae674a67ed4", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -715,6 +715,9 @@ namespace aarch64_sve {\n \t\t\t   tree, unsigned int, tree *);\n   gimple *gimple_fold_builtin (unsigned int, gimple_stmt_iterator *, gcall *);\n   rtx expand_builtin (unsigned int, tree, rtx);\n+#ifdef GCC_TARGET_H\n+  bool verify_type_context (location_t, type_context_kind, const_tree, bool);\n+#endif\n }\n \n extern void aarch64_split_combinev16qi (rtx operands[3]);"}, {"sha": "5dd7ccb74ff41fd97513772f7bc05541a906a17f", "filename": "gcc/config/aarch64/aarch64-sve-builtins.cc", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -3296,6 +3296,55 @@ builtin_type_p (const_tree type)\n   return svbool_type_p (type) || nvectors_if_data_type (type) > 0;\n }\n \n+/* Implement TARGET_VERIFY_TYPE_CONTEXT for SVE types.  */\n+bool\n+verify_type_context (location_t loc, type_context_kind context,\n+\t\t     const_tree type, bool silent_p)\n+{\n+  if (!builtin_type_p (type))\n+    return true;\n+\n+  switch (context)\n+    {\n+    case TCTX_SIZEOF:\n+    case TCTX_STATIC_STORAGE:\n+      if (!silent_p)\n+\terror_at (loc, \"SVE type %qT does not have a fixed size\", type);\n+      return false;\n+\n+    case TCTX_ALIGNOF:\n+      if (!silent_p)\n+\terror_at (loc, \"SVE type %qT does not have a defined alignment\", type);\n+      return false;\n+\n+    case TCTX_THREAD_STORAGE:\n+      if (!silent_p)\n+\terror_at (loc, \"variables of type %qT cannot have thread-local\"\n+\t\t  \" storage duration\", type);\n+      return false;\n+\n+    case TCTX_POINTER_ARITH:\n+      if (!silent_p)\n+\terror_at (loc, \"arithmetic on pointer to SVE type %qT\", type);\n+      return false;\n+\n+    case TCTX_FIELD:\n+      if (silent_p)\n+\t;\n+      else if (lang_GNU_CXX ())\n+\terror_at (loc, \"member variables cannot have SVE type %qT\", type);\n+      else\n+\terror_at (loc, \"fields cannot have SVE type %qT\", type);\n+      return false;\n+\n+    case TCTX_ARRAY_ELEMENT:\n+      if (!silent_p)\n+\terror_at (loc, \"array elements cannot have SVE type %qT\", type);\n+      return false;\n+    }\n+  gcc_unreachable ();\n+}\n+\n }\n \n using namespace aarch64_sve;"}, {"sha": "d0cbe13273f78ebac6f3facc983ca0dec1a43966", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -16200,6 +16200,15 @@ aarch64_mangle_type (const_tree type)\n   return NULL;\n }\n \n+/* Implement TARGET_VERIFY_TYPE_CONTEXT.  */\n+\n+static bool\n+aarch64_verify_type_context (location_t loc, type_context_kind context,\n+\t\t\t     const_tree type, bool silent_p)\n+{\n+  return aarch64_sve::verify_type_context (loc, context, type, silent_p);\n+}\n+\n /* Find the first rtx_insn before insn that will generate an assembly\n    instruction.  */\n \n@@ -21860,6 +21869,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_MANGLE_TYPE\n #define TARGET_MANGLE_TYPE aarch64_mangle_type\n \n+#undef TARGET_VERIFY_TYPE_CONTEXT\n+#define TARGET_VERIFY_TYPE_CONTEXT aarch64_verify_type_context\n+\n #undef TARGET_MEMORY_MOVE_COST\n #define TARGET_MEMORY_MOVE_COST aarch64_memory_move_cost\n "}, {"sha": "5b8b68bd710fd591bfe7a07e2d113d39178bfad7", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -11976,6 +11976,19 @@ conversion rules.\n This is currently used only by the C and C++ front ends.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_VERIFY_TYPE_CONTEXT (location_t @var{loc}, type_context_kind @var{context}, const_tree @var{type}, bool @var{silent_p})\n+If defined, this hook returns false if there is a target-specific reason\n+why type @var{type} cannot be used in the source language context described\n+by @var{context}.  When @var{silent_p} is false, the hook also reports an\n+error against @var{loc} for invalid uses of @var{type}.\n+\n+Calls to this hook should be made through the global function\n+@code{verify_type_context}, which makes the @var{silent_p} parameter\n+default to false and also handles @code{error_mark_node}.\n+\n+The default implementation always returns true.\n+@end deftypefn\n+\n @defmac OBJC_JBLEN\n This macro determines the size of the objective C jump buffer for the\n NeXT runtime. By default, OBJC_JBLEN is defined to an innocuous value."}, {"sha": "1b061d7012792ac8f7984118efd03ef21280a3b6", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -8087,6 +8087,8 @@ and scanf formatter settings.\n \n @hook TARGET_CONVERT_TO_TYPE\n \n+@hook TARGET_VERIFY_TYPE_CONTEXT\n+\n @defmac OBJC_JBLEN\n This macro determines the size of the objective C jump buffer for the\n NeXT runtime. By default, OBJC_JBLEN is defined to an innocuous value."}, {"sha": "e0e856979a988a5aee005611f97e35bf06ad6c69", "filename": "gcc/target.def", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -5286,6 +5286,22 @@ This is currently used only by the C and C++ front ends.\",\n  tree, (tree type, tree expr),\n  hook_tree_tree_tree_null)\n \n+DEFHOOK\n+(verify_type_context,\n+ \"If defined, this hook returns false if there is a target-specific reason\\n\\\n+why type @var{type} cannot be used in the source language context described\\n\\\n+by @var{context}.  When @var{silent_p} is false, the hook also reports an\\n\\\n+error against @var{loc} for invalid uses of @var{type}.\\n\\\n+\\n\\\n+Calls to this hook should be made through the global function\\n\\\n+@code{verify_type_context}, which makes the @var{silent_p} parameter\\n\\\n+default to false and also handles @code{error_mark_node}.\\n\\\n+\\n\\\n+The default implementation always returns true.\",\n+ bool, (location_t loc, type_context_kind context, const_tree type,\n+\tbool silent_p),\n+ NULL)\n+\n DEFHOOK\n (can_change_mode_class,\n  \"This hook returns true if it is possible to bitcast values held in\\n\\"}, {"sha": "973d743a371e6e9926b0788b3fe94b2cb637a22d", "filename": "gcc/target.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -226,6 +226,35 @@ enum omp_device_kind_arch_isa {\n        will choose the first mode that works.  */\n const unsigned int VECT_COMPARE_COSTS = 1U << 0;\n \n+/* The contexts in which the use of a type T can be checked by\n+   TARGET_VERIFY_TYPE_CONTEXT.  */\n+enum type_context_kind {\n+  /* Directly measuring the size of T.  */\n+  TCTX_SIZEOF,\n+\n+  /* Directly measuring the alignment of T.  */\n+  TCTX_ALIGNOF,\n+\n+  /* Creating objects of type T with static storage duration.  */\n+  TCTX_STATIC_STORAGE,\n+\n+  /* Creating objects of type T with thread-local storage duration.  */\n+  TCTX_THREAD_STORAGE,\n+\n+  /* Creating a field of type T.  */\n+  TCTX_FIELD,\n+\n+  /* Creating an array with elements of type T.  */\n+  TCTX_ARRAY_ELEMENT,\n+\n+  /* Adding to or subtracting from a pointer to T, or computing the\n+     difference between two pointers when one of them is a pointer to T.  */\n+  TCTX_POINTER_ARITH\n+};\n+\n+extern bool verify_type_context (location_t, type_context_kind, const_tree,\n+\t\t\t\t bool = false);\n+\n /* The target structure.  This holds all the backend hooks.  */\n #define DEFHOOKPOD(NAME, DOC, TYPE, INIT) TYPE NAME;\n #define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) TYPE (* NAME) PARAMS;"}, {"sha": "34d5a75a200435a05ba8aa026a71157456fd7c86", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -1,3 +1,8 @@\n+2019-11-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/acle/general-c/sizeless-1.c: New test.\n+\t* gcc.target/aarch64/sve/acle/general-c/sizeless-2.c: Likewise.\n+\n 2019-11-30  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* g++.dg/lto/inline-crossmodule-1.h: New testcase."}, {"sha": "ec892a3fc83ca18b40b67b97d31443d5bfccaaca", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/sizeless-1.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fsizeless-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fsizeless-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fsizeless-1.c?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -0,0 +1,217 @@\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include <arm_sve.h>\n+\n+typedef signed char int8x32_t __attribute__((__vector_size__ (32)));\n+\n+/* Sizeless objects with global scope.  */\n+\n+svint8_t global_sve_sc; /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+static svint8_t local_sve_sc; /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+extern svint8_t extern_sve_sc; /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+__thread svint8_t tls_sve_sc; /* { dg-error {variables of type 'svint8_t' cannot have thread-local storage duration} } */\n+_Atomic svint8_t atomic_sve_sc; /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+\n+/* Sizeless arrays.  */\n+\n+typedef svint8_t array_type[2]; /* { dg-error {array elements cannot have SVE type 'svint8_t'} } */\n+extern svint8_t extern_array[]; /* { dg-error {array elements cannot have SVE type 'svint8_t'} } */\n+\n+/* Sizeless fields.  */\n+\n+struct struct1 {\n+  svint8_t a; /* { dg-error {fields cannot have SVE type 'svint8_t'} } */\n+};\n+\n+union union1 {\n+  svint8_t a; /* { dg-error {fields cannot have SVE type 'svint8_t'} } */\n+};\n+\n+/* Pointers to sizeless types.  */\n+\n+svint8_t *global_sve_sc_ptr;\n+svint8_t *invalid_sve_sc_ptr = &(svint8_t) { *global_sve_sc_ptr }; /* { dg-error {initializer element is not constant} } */\n+  /* { dg-error {SVE type 'svint8_t' does not have a fixed size} \"\" { target *-*-* } .-1 } */\n+\n+/* Sizeless arguments and return values.  */\n+\n+void ext_consume_sve_sc (svint8_t);\n+void ext_consume_varargs (int, ...);\n+svint8_t ext_produce_sve_sc ();\n+\n+/* Main tests for statements and expressions.  */\n+\n+void\n+statements (int n)\n+{\n+  /* Local declarations.  */\n+\n+  unsigned char va __attribute__((__vector_size__(2)));\n+  svint8_t sve_sc1, sve_sc2;\n+  _Atomic svint8_t atomic_sve_sc;\n+  int8x32_t gnu_sc1;\n+  svint16_t sve_sh1;\n+  static svint8_t local_static_sve_sc; /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+\n+  /* Layout queries.  */\n+\n+  sizeof (svint8_t); /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+  sizeof (sve_sc1); /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+  sizeof (ext_produce_sve_sc ()); /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+  _Alignof (svint8_t); /* { dg-error {SVE type 'svint8_t' does not have a defined alignment} } */\n+  _Alignof (sve_sc1); /* { dg-error {SVE type 'svint8_t' does not have a defined alignment} } */\n+  _Alignof (ext_produce_sve_sc ()); /* { dg-error {SVE type 'svint8_t' does not have a defined alignment} } */\n+\n+  /* Initialization.  */\n+\n+  svint8_t init_sve_sc1 = sve_sc1;\n+  svint8_t init_sve_sc2 = sve_sh1; /* { dg-error {incompatible types when initializing type 'svint8_t' using type 'svint16_t'} } */\n+  svint8_t init_sve_sc3 = {}; /* { dg-error {empty scalar initializer} } */\n+\n+  int initi_a = sve_sc1; /* { dg-error {incompatible types when initializing type 'int' using type 'svint8_t'} } */\n+  int initi_b = { sve_sc1 }; /* { dg-error {incompatible types when initializing type 'int' using type 'svint8_t'} } */\n+\n+  /* Compound literals.  */\n+\n+  (svint8_t) {}; /* { dg-error {empty scalar initializer} } */\n+  (svint8_t) { sve_sc1 };\n+\n+  (int) { sve_sc1 }; /* { dg-error {incompatible types when initializing type 'int' using type 'svint8_t'} } */\n+\n+  /* Arrays.  */\n+\n+  svint8_t array[2]; /* { dg-error {array elements cannot have SVE type 'svint8_t'} } */\n+  svint8_t zero_length_array[0]; /* { dg-error {array elements cannot have SVE type 'svint8_t'} } */\n+  svint8_t empty_init_array[] = {}; /* { dg-error {array elements cannot have SVE type 'svint8_t'} } */\n+  \t\t\t\t    /* { dg-error {empty scalar initializer} \"\" { target *-*-* } .-1 } */\n+  typedef svint8_t vla_type[n]; /* { dg-error {array elements cannot have SVE type 'svint8_t'} } */\n+\n+  /* Assignment.  */\n+\n+  n = sve_sc1; /* { dg-error {incompatible types when assigning to type 'int' from type 'svint8_t'} } */\n+\n+  sve_sc1 = 0; /* { dg-error {incompatible types when assigning to type 'svint8_t' from type 'int'} } */\n+  sve_sc1 = sve_sc2;\n+  sve_sc1 = sve_sh1; /* { dg-error {incompatible types when assigning to type 'svint8_t' from type 'svint16_t'} } */\n+\n+  /* Casting.  */\n+\n+  (void) sve_sc1;\n+  (svint8_t) sve_sc1;\n+\n+  /* Addressing and dereferencing.  */\n+\n+  svint8_t *sve_sc_ptr = &sve_sc1;\n+  int8x32_t *gnu_sc_ptr = &gnu_sc1;\n+  sve_sc1 = *sve_sc_ptr;\n+\n+  /* Pointer assignment.  */\n+\n+  gnu_sc_ptr = sve_sc_ptr; /* { dg-warning {assignment to [^\\n]* from incompatible pointer type} } */\n+  sve_sc_ptr = gnu_sc_ptr; /* { dg-warning {assignment to [^\\n]* from incompatible pointer type} } */\n+\n+  /* Pointer arithmetic.  */\n+\n+  ++sve_sc_ptr; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  --sve_sc_ptr; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr++; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr--; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr += 0; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr += 1; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr -= 0; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr -= 1; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr - sve_sc_ptr; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  gnu_sc_ptr - sve_sc_ptr; /* { dg-error {invalid operands to binary -} } */\n+  sve_sc_ptr - gnu_sc_ptr; /* { dg-error {invalid operands to binary -} } */\n+  sve_sc1 = sve_sc_ptr[0]; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc1 = sve_sc_ptr[1]; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+\n+  /* Pointer comparison.  */\n+\n+  sve_sc_ptr == &sve_sc1;\n+  sve_sc_ptr != &sve_sc1;\n+  sve_sc_ptr < &sve_sc1;\n+  sve_sc_ptr <= &sve_sc1;\n+  sve_sc_ptr > &sve_sc1;\n+  sve_sc_ptr >= &sve_sc1;\n+  gnu_sc_ptr == sve_sc_ptr; /* { dg-warning {comparison of distinct pointer types lacks a cast} } */\n+  gnu_sc_ptr != sve_sc_ptr; /* { dg-warning {comparison of distinct pointer types lacks a cast} } */\n+  gnu_sc_ptr < sve_sc_ptr; /* { dg-warning {comparison of distinct pointer types lacks a cast} } */\n+  gnu_sc_ptr <= sve_sc_ptr; /* { dg-warning {comparison of distinct pointer types lacks a cast} } */\n+  gnu_sc_ptr > sve_sc_ptr; /* { dg-warning {comparison of distinct pointer types lacks a cast} } */\n+  gnu_sc_ptr >= sve_sc_ptr; /* { dg-warning {comparison of distinct pointer types lacks a cast} } */\n+  sve_sc_ptr == gnu_sc_ptr; /* { dg-warning {comparison of distinct pointer types lacks a cast} } */\n+  sve_sc_ptr != gnu_sc_ptr; /* { dg-warning {comparison of distinct pointer types lacks a cast} } */\n+  sve_sc_ptr < gnu_sc_ptr; /* { dg-warning {comparison of distinct pointer types lacks a cast} } */\n+  sve_sc_ptr <= gnu_sc_ptr; /* { dg-warning {comparison of distinct pointer types lacks a cast} } */\n+  sve_sc_ptr > gnu_sc_ptr; /* { dg-warning {comparison of distinct pointer types lacks a cast} } */\n+  sve_sc_ptr >= gnu_sc_ptr; /* { dg-warning {comparison of distinct pointer types lacks a cast} } */\n+\n+  /* Conditional expressions.  */\n+\n+  0 ? sve_sc1 : sve_sc1;\n+  0 ? sve_sc1 : sve_sh1; /* { dg-error {type mismatch in conditional expression} } */\n+  0 ? sve_sc1 : 0; /* { dg-error {type mismatch in conditional expression} } */\n+  0 ? 0 : sve_sc1; /* { dg-error {type mismatch in conditional expression} } */\n+  0 ?: sve_sc1; /* { dg-error {type mismatch in conditional expression} } */\n+  0 ? sve_sc_ptr : sve_sc_ptr;\n+  0 ? sve_sc_ptr : gnu_sc_ptr; /* { dg-warning {pointer type mismatch in conditional expression} } */\n+  0 ? gnu_sc_ptr : sve_sc_ptr; /* { dg-warning {pointer type mismatch in conditional expression} } */\n+\n+  /* Generic associations.  */\n+\n+  _Generic (sve_sc1, default: 100);\n+  _Generic (1, svint8_t: 10, default: 20);\n+\n+  /* Function arguments.  */\n+\n+  ext_consume_sve_sc (sve_sc1);\n+  ext_consume_sve_sc (sve_sh1); /* { dg-error {incompatible type for argument 1 of 'ext_consume_sve_sc'} } */\n+  ext_consume_varargs (sve_sc1); /* { dg-error {incompatible type for argument 1 of 'ext_consume_varargs'} } */\n+  ext_consume_varargs (1, sve_sc1);\n+\n+  /* Function returns.  */\n+\n+  ext_produce_sve_sc ();\n+  sve_sc1 = ext_produce_sve_sc ();\n+  sve_sh1 = ext_produce_sve_sc (); /* { dg-error {incompatible types when assigning to type 'svint16_t' from type 'svint8_t'} } */\n+\n+  /* Varargs processing.  */\n+\n+  __builtin_va_list valist;\n+  __builtin_va_arg (valist, svint8_t);\n+\n+  /* Statement expressions.  */\n+\n+  ({ sve_sc1; });\n+  ({ svint8_t another_sve_sc = *sve_sc_ptr; another_sve_sc; });\n+}\n+\n+/* Function parameters in definitions.  */\n+\n+void\n+old_style (input_sve_sc) /* { dg-error {SVE type 'svint8_t' cannot be passed to an unprototyped function} } */\n+     svint8_t input_sve_sc;\n+{\n+  svint8_t sve_sc1 = input_sve_sc;\n+}\n+\n+void\n+new_style_param (svint8_t input_sve_sc)\n+{\n+  svint8_t sve_sc1 = input_sve_sc;\n+}\n+\n+/* Function return values in definitions.  */\n+\n+svint8_t\n+good_return_sve_sc (svint8_t param)\n+{\n+  return param;\n+}\n+\n+svint8_t\n+bad_return_sve_sc (svint16_t param)\n+{\n+  return param; /* { dg-error {incompatible types when returning type 'svint16_t' but 'svint8_t' was expected} } */\n+}"}, {"sha": "71743930098cd99921fd2e307f8ea01d08a6ebca", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/sizeless-2.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fsizeless-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fsizeless-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fsizeless-2.c?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -0,0 +1,217 @@\n+/* { dg-options \"-std=gnu99 -msve-vector-bits=256\" } */\n+\n+#include <arm_sve.h>\n+\n+typedef signed char int8x32_t __attribute__((__vector_size__ (32)));\n+\n+/* Sizeless objects with global scope.  */\n+\n+svint8_t global_sve_sc; /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+static svint8_t local_sve_sc; /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+extern svint8_t extern_sve_sc; /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+__thread svint8_t tls_sve_sc; /* { dg-error {variables of type 'svint8_t' cannot have thread-local storage duration} } */\n+_Atomic svint8_t atomic_sve_sc; /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+\n+/* Sizeless arrays.  */\n+\n+typedef svint8_t array_type[2]; /* { dg-error {array elements cannot have SVE type 'svint8_t'} } */\n+extern svint8_t extern_array[]; /* { dg-error {array elements cannot have SVE type 'svint8_t'} } */\n+\n+/* Sizeless fields.  */\n+\n+struct struct1 {\n+  svint8_t a; /* { dg-error {fields cannot have SVE type 'svint8_t'} } */\n+};\n+\n+union union1 {\n+  svint8_t a; /* { dg-error {fields cannot have SVE type 'svint8_t'} } */\n+};\n+\n+/* Pointers to sizeless types.  */\n+\n+svint8_t *global_sve_sc_ptr;\n+svint8_t *invalid_sve_sc_ptr = &(svint8_t) { *global_sve_sc_ptr }; /* { dg-error {initializer element is not constant} } */\n+  /* { dg-error {SVE type 'svint8_t' does not have a fixed size} \"\" { target *-*-* } .-1 } */\n+\n+/* Sizeless arguments and return values.  */\n+\n+void ext_consume_sve_sc (svint8_t);\n+void ext_consume_varargs (int, ...);\n+svint8_t ext_produce_sve_sc ();\n+\n+/* Main tests for statements and expressions.  */\n+\n+void\n+statements (int n)\n+{\n+  /* Local declarations.  */\n+\n+  unsigned char va __attribute__((__vector_size__(2)));\n+  svint8_t sve_sc1, sve_sc2;\n+  _Atomic svint8_t atomic_sve_sc;\n+  int8x32_t gnu_sc1;\n+  svint16_t sve_sh1;\n+  static svint8_t local_static_sve_sc; /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+\n+  /* Layout queries.  */\n+\n+  sizeof (svint8_t); /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+  sizeof (sve_sc1); /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+  sizeof (ext_produce_sve_sc ()); /* { dg-error {SVE type 'svint8_t' does not have a fixed size} } */\n+  _Alignof (svint8_t); /* { dg-error {SVE type 'svint8_t' does not have a defined alignment} } */\n+  _Alignof (sve_sc1); /* { dg-error {SVE type 'svint8_t' does not have a defined alignment} } */\n+  _Alignof (ext_produce_sve_sc ()); /* { dg-error {SVE type 'svint8_t' does not have a defined alignment} } */\n+\n+  /* Initialization.  */\n+\n+  svint8_t init_sve_sc1 = sve_sc1;\n+  svint8_t init_sve_sc2 = sve_sh1; /* { dg-error {incompatible types when initializing type 'svint8_t' using type 'svint16_t'} } */\n+  svint8_t init_sve_sc3 = {}; /* { dg-error {empty scalar initializer} } */\n+\n+  int initi_a = sve_sc1; /* { dg-error {incompatible types when initializing type 'int' using type 'svint8_t'} } */\n+  int initi_b = { sve_sc1 }; /* { dg-error {incompatible types when initializing type 'int' using type 'svint8_t'} } */\n+\n+  /* Compound literals.  */\n+\n+  (svint8_t) {}; /* { dg-error {empty scalar initializer} } */\n+  (svint8_t) { sve_sc1 };\n+\n+  (int) { sve_sc1 }; /* { dg-error {incompatible types when initializing type 'int' using type 'svint8_t'} } */\n+\n+  /* Arrays.  */\n+\n+  svint8_t array[2]; /* { dg-error {array elements cannot have SVE type 'svint8_t'} } */\n+  svint8_t zero_length_array[0]; /* { dg-error {array elements cannot have SVE type 'svint8_t'} } */\n+  svint8_t empty_init_array[] = {}; /* { dg-error {array elements cannot have SVE type 'svint8_t'} } */\n+  \t\t\t\t    /* { dg-error {empty scalar initializer} \"\" { target *-*-* } .-1 } */\n+  typedef svint8_t vla_type[n]; /* { dg-error {array elements cannot have SVE type 'svint8_t'} } */\n+\n+  /* Assignment.  */\n+\n+  n = sve_sc1; /* { dg-error {incompatible types when assigning to type 'int' from type 'svint8_t'} } */\n+\n+  sve_sc1 = 0; /* { dg-error {incompatible types when assigning to type 'svint8_t' from type 'int'} } */\n+  sve_sc1 = sve_sc2;\n+  sve_sc1 = sve_sh1; /* { dg-error {incompatible types when assigning to type 'svint8_t' from type 'svint16_t'} } */\n+\n+  /* Casting.  */\n+\n+  (void) sve_sc1;\n+  (svint8_t) sve_sc1;\n+\n+  /* Addressing and dereferencing.  */\n+\n+  svint8_t *sve_sc_ptr = &sve_sc1;\n+  int8x32_t *gnu_sc_ptr = &gnu_sc1;\n+  sve_sc1 = *sve_sc_ptr;\n+\n+  /* Pointer assignment.  */\n+\n+  gnu_sc_ptr = sve_sc_ptr;\n+  sve_sc_ptr = gnu_sc_ptr;\n+\n+  /* Pointer arithmetic.  */\n+\n+  ++sve_sc_ptr; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  --sve_sc_ptr; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr++; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr--; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr += 0; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr += 1; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr -= 0; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr -= 1; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr - sve_sc_ptr; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  gnu_sc_ptr - sve_sc_ptr; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc_ptr - gnu_sc_ptr; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc1 = sve_sc_ptr[0]; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+  sve_sc1 = sve_sc_ptr[1]; /* { dg-error {arithmetic on pointer to SVE type 'svint8_t'} } */\n+\n+  /* Pointer comparison.  */\n+\n+  sve_sc_ptr == &sve_sc1;\n+  sve_sc_ptr != &sve_sc1;\n+  sve_sc_ptr < &sve_sc1;\n+  sve_sc_ptr <= &sve_sc1;\n+  sve_sc_ptr > &sve_sc1;\n+  sve_sc_ptr >= &sve_sc1;\n+  gnu_sc_ptr == sve_sc_ptr;\n+  gnu_sc_ptr != sve_sc_ptr;\n+  gnu_sc_ptr < sve_sc_ptr;\n+  gnu_sc_ptr <= sve_sc_ptr;\n+  gnu_sc_ptr > sve_sc_ptr;\n+  gnu_sc_ptr >= sve_sc_ptr;\n+  sve_sc_ptr == gnu_sc_ptr;\n+  sve_sc_ptr != gnu_sc_ptr;\n+  sve_sc_ptr < gnu_sc_ptr;\n+  sve_sc_ptr <= gnu_sc_ptr;\n+  sve_sc_ptr > gnu_sc_ptr;\n+  sve_sc_ptr >= gnu_sc_ptr;\n+\n+  /* Conditional expressions.  */\n+\n+  0 ? sve_sc1 : sve_sc1;\n+  0 ? sve_sc1 : sve_sh1; /* { dg-error {type mismatch in conditional expression} } */\n+  0 ? sve_sc1 : 0; /* { dg-error {type mismatch in conditional expression} } */\n+  0 ? 0 : sve_sc1; /* { dg-error {type mismatch in conditional expression} } */\n+  0 ?: sve_sc1; /* { dg-error {type mismatch in conditional expression} } */\n+  0 ? sve_sc_ptr : sve_sc_ptr;\n+  0 ? sve_sc_ptr : gnu_sc_ptr;\n+  0 ? gnu_sc_ptr : sve_sc_ptr;\n+\n+  /* Generic associations.  */\n+\n+  _Generic (sve_sc1, default: 100);\n+  _Generic (1, svint8_t: 10, default: 20);\n+\n+  /* Function arguments.  */\n+\n+  ext_consume_sve_sc (sve_sc1);\n+  ext_consume_sve_sc (sve_sh1); /* { dg-error {incompatible type for argument 1 of 'ext_consume_sve_sc'} } */\n+  ext_consume_varargs (sve_sc1); /* { dg-error {incompatible type for argument 1 of 'ext_consume_varargs'} } */\n+  ext_consume_varargs (1, sve_sc1);\n+\n+  /* Function returns.  */\n+\n+  ext_produce_sve_sc ();\n+  sve_sc1 = ext_produce_sve_sc ();\n+  sve_sh1 = ext_produce_sve_sc (); /* { dg-error {incompatible types when assigning to type 'svint16_t' from type 'svint8_t'} } */\n+\n+  /* Varargs processing.  */\n+\n+  __builtin_va_list valist;\n+  __builtin_va_arg (valist, svint8_t);\n+\n+  /* Statement expressions.  */\n+\n+  ({ sve_sc1; });\n+  ({ svint8_t another_sve_sc = *sve_sc_ptr; another_sve_sc; });\n+}\n+\n+/* Function parameters in definitions.  */\n+\n+void\n+old_style (input_sve_sc) /* { dg-error {SVE type 'svint8_t' cannot be passed to an unprototyped function} } */\n+     svint8_t input_sve_sc;\n+{\n+  svint8_t sve_sc1 = input_sve_sc;\n+}\n+\n+void\n+new_style_param (svint8_t input_sve_sc)\n+{\n+  svint8_t sve_sc1 = input_sve_sc;\n+}\n+\n+/* Function return values in definitions.  */\n+\n+svint8_t\n+good_return_sve_sc (svint8_t param)\n+{\n+  return param;\n+}\n+\n+svint8_t\n+bad_return_sve_sc (svint16_t param)\n+{\n+  return param; /* { dg-error {incompatible types when returning type 'svint16_t' but 'svint8_t' was expected} } */\n+}"}, {"sha": "1bb37679f5429718eb550781b7f56957f6a84b22", "filename": "gcc/tree.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ef05d0b7fb429c5760189e638c441dc3da33f4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=65ef05d0b7fb429c5760189e638c441dc3da33f4", "patch": "@@ -15123,6 +15123,21 @@ max_object_size (void)\n   return TYPE_MAX_VALUE (ptrdiff_type_node);\n }\n \n+/* A wrapper around TARGET_VERIFY_TYPE_CONTEXT that makes the silent_p\n+   parameter default to false and that weeds out error_mark_node.  */\n+\n+bool\n+verify_type_context (location_t loc, type_context_kind context,\n+\t\t     const_tree type, bool silent_p)\n+{\n+  if (type == error_mark_node)\n+    return true;\n+\n+  gcc_assert (TYPE_P (type));\n+  return (!targetm.verify_type_context\n+\t  || targetm.verify_type_context (loc, context, type, silent_p));\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}]}