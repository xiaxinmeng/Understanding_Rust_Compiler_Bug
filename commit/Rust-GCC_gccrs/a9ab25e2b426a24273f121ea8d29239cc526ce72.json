{"sha": "a9ab25e2b426a24273f121ea8d29239cc526ce72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlhYjI1ZTJiNDI2YTI0MjczZjEyMWVhOGQyOTIzOWNjNTI2Y2U3Mg==", "commit": {"author": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-07-27T13:24:08Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-07-27T13:24:08Z"}, "message": "re PR target/35491 (wrong ABI for some struct passing with vector code)\n\n\n\tPR target/35491\n\tPR target/29090\n\n\tMerge from Apple local 4.2.1.\n\t2005-05-11  Stan Shebs  <shebs@apple.com>\n\tFix 64-bit varargs for Darwin (Radar 4028089).\n\t* config/rs6000/rs6000.h (rs6000_args): New field floats_in_gpr.\n\t* config/rs6000/rs6000.c (rs6000_darwin64_record_arg_advance_flush):\n\tAdd argument, add case for 8-byte register half-filled with a float.\n\t(rs6000_darwin64_record_arg_advance_recurse): Detect and handle\n\tsingle-precision floats specially.\n\nFrom-SVN: r162567", "tree": {"sha": "9b26b6fd9fa9453b9d4d73c5556d893d11f1a53f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b26b6fd9fa9453b9d4d73c5556d893d11f1a53f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9ab25e2b426a24273f121ea8d29239cc526ce72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ab25e2b426a24273f121ea8d29239cc526ce72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9ab25e2b426a24273f121ea8d29239cc526ce72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ab25e2b426a24273f121ea8d29239cc526ce72/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2200fc4965ca0bc01566d48949eecf5d99a15801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2200fc4965ca0bc01566d48949eecf5d99a15801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2200fc4965ca0bc01566d48949eecf5d99a15801"}], "stats": {"total": 92, "additions": 86, "deletions": 6}, "files": [{"sha": "3fcf579c87bdfa75b4025fc7cf349015e04c3810", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ab25e2b426a24273f121ea8d29239cc526ce72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ab25e2b426a24273f121ea8d29239cc526ce72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9ab25e2b426a24273f121ea8d29239cc526ce72", "patch": "@@ -1,3 +1,17 @@\n+2010-07-27  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tPR target/35491\n+\tPR target/29090\n+\n+\tMerge from Apple local 4.2.1.\n+\t2005-05-11  Stan Shebs  <shebs@apple.com>\n+\tFix 64-bit varargs for Darwin (Radar 4028089).\n+\t* config/rs6000/rs6000.h (rs6000_args): New field floats_in_gpr.\n+\t* config/rs6000/rs6000.c (rs6000_darwin64_record_arg_advance_flush):\n+\tAdd argument, add case for 8-byte register half-filled with a float.\n+\t(rs6000_darwin64_record_arg_advance_recurse): Detect and handle\n+\tsingle-precision floats specially.\n+\n 2010-07-27  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/44152"}, {"sha": "e8fad12caadac5dc8c69e2098879fecd31b08611", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ab25e2b426a24273f121ea8d29239cc526ce72/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ab25e2b426a24273f121ea8d29239cc526ce72/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a9ab25e2b426a24273f121ea8d29239cc526ce72", "patch": "@@ -1154,7 +1154,7 @@ static rtx rs6000_complex_function_value (enum machine_mode);\n static rtx rs6000_spe_function_arg (CUMULATIVE_ARGS *,\n \t\t\t\t    enum machine_mode, tree);\n static void rs6000_darwin64_record_arg_advance_flush (CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t      HOST_WIDE_INT);\n+\t\t\t\t\t\t      HOST_WIDE_INT, int);\n static void rs6000_darwin64_record_arg_advance_recurse (CUMULATIVE_ARGS *,\n \t\t\t\t\t\t\ttree, HOST_WIDE_INT);\n static void rs6000_darwin64_record_arg_flush (CUMULATIVE_ARGS *,\n@@ -7542,17 +7542,31 @@ rs6000_arg_size (enum machine_mode mode, tree type)\n \n static void\n rs6000_darwin64_record_arg_advance_flush (CUMULATIVE_ARGS *cum,\n-\t\t\t\t\t  HOST_WIDE_INT bitpos)\n+\t\t\t\t\t  HOST_WIDE_INT bitpos, int final)\n {\n   unsigned int startbit, endbit;\n   int intregs, intoffset;\n   enum machine_mode mode;\n \n+  /* Handle the situations where a float is taking up the first half\n+     of the GPR, and the other half is empty (typically due to\n+     alignment restrictions). We can detect this by a 8-byte-aligned\n+     int field, or by seeing that this is the final flush for this\n+     argument. Count the word and continue on.  */\n+  if (cum->floats_in_gpr == 1\n+      && (cum->intoffset % 64 == 0\n+\t  || (cum->intoffset == -1 && final)))\n+    {\n+      cum->words++;\n+      cum->floats_in_gpr = 0;\n+    }\n+\n   if (cum->intoffset == -1)\n     return;\n \n   intoffset = cum->intoffset;\n   cum->intoffset = -1;\n+  cum->floats_in_gpr = 0;\n \n   if (intoffset % BITS_PER_WORD != 0)\n     {\n@@ -7572,6 +7586,12 @@ rs6000_darwin64_record_arg_advance_flush (CUMULATIVE_ARGS *cum,\n   endbit = (bitpos + BITS_PER_WORD - 1) & -BITS_PER_WORD;\n   intregs = (endbit - startbit) / BITS_PER_WORD;\n   cum->words += intregs;\n+  /* words should be unsigned. */\n+  if ((unsigned)cum->words < (endbit/BITS_PER_WORD))\n+    {\n+      int pad = (endbit/BITS_PER_WORD) - cum->words;\n+      cum->words += pad;\n+    }\n }\n \n /* The darwin64 ABI calls for us to recurse down through structs,\n@@ -7606,13 +7626,47 @@ rs6000_darwin64_record_arg_advance_recurse (CUMULATIVE_ARGS *cum,\n \t  rs6000_darwin64_record_arg_advance_recurse (cum, ftype, bitpos);\n \telse if (USE_FP_FOR_ARG_P (cum, mode, ftype))\n \t  {\n-\t    rs6000_darwin64_record_arg_advance_flush (cum, bitpos);\n+\t    rs6000_darwin64_record_arg_advance_flush (cum, bitpos, 0);\n \t    cum->fregno += (GET_MODE_SIZE (mode) + 7) >> 3;\n-\t    cum->words += (GET_MODE_SIZE (mode) + 7) >> 3;\n+\t    /* Single-precision floats present a special problem for\n+\t       us, because they are smaller than an 8-byte GPR, and so\n+\t       the structure-packing rules combined with the standard\n+\t       varargs behavior mean that we want to pack float/float\n+\t       and float/int combinations into a single register's\n+\t       space. This is complicated by the arg advance flushing,\n+\t       which works on arbitrarily large groups of int-type\n+\t       fields.  */\n+\t    if (mode == SFmode)\n+\t      {\n+\t\tif (cum->floats_in_gpr == 1)\n+\t\t  {\n+\t\t    /* Two floats in a word; count the word and reset\n+\t\t       the float count.  */\n+\t\t    cum->words++;\n+\t\t    cum->floats_in_gpr = 0;\n+\t\t  }\n+\t\telse if (bitpos % 64 == 0)\n+\t\t  {\n+\t\t    /* A float at the beginning of an 8-byte word;\n+\t\t       count it and put off adjusting cum->words until\n+\t\t       we see if a arg advance flush is going to do it\n+\t\t       for us.  */\n+\t\t    cum->floats_in_gpr++;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* The float is at the end of a word, preceded\n+\t\t       by integer fields, so the arg advance flush\n+\t\t       just above has already set cum->words and\n+\t\t       everything is taken care of.  */\n+\t\t  }\n+\t      }\n+\t    else\n+\t      cum->words += (GET_MODE_SIZE (mode) + 7) >> 3;\n \t  }\n \telse if (USE_ALTIVEC_FOR_ARG_P (cum, mode, type, 1))\n \t  {\n-\t    rs6000_darwin64_record_arg_advance_flush (cum, bitpos);\n+\t    rs6000_darwin64_record_arg_advance_flush (cum, bitpos, 0);\n \t    cum->vregno++;\n \t    cum->words += 2;\n \t  }\n@@ -7718,10 +7772,20 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t     { int; double; int; } [powerpc alignment].  We have to\n \t     grovel through the fields for these too.  */\n \t  cum->intoffset = 0;\n+\t  cum->floats_in_gpr = 0;\n \t  rs6000_darwin64_record_arg_advance_recurse (cum, type, 0);\n \t  rs6000_darwin64_record_arg_advance_flush (cum,\n-\t\t\t\t\t\t    size * BITS_PER_UNIT);\n+\t\t\t\t\t\t    size * BITS_PER_UNIT, 1);\n \t}\n+\t  if (TARGET_DEBUG_ARG)\n+\t    {\n+\t      fprintf (stderr, \"function_adv: words = %2d, align=%d, size=%d\",\n+\t\t       cum->words, TYPE_ALIGN (type), size);\n+\t      fprintf (stderr, \n+\t           \"nargs = %4d, proto = %d, mode = %4s (darwin64 abi BLK)\\n\",\n+\t\t       cum->nargs_prototype, cum->prototype,\n+\t\t       GET_MODE_NAME (mode));\n+\t    }\n     }\n   else if (DEFAULT_ABI == ABI_V4)\n     {"}, {"sha": "6065463691b13bbde221a664b45e494aee6b3773", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ab25e2b426a24273f121ea8d29239cc526ce72/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ab25e2b426a24273f121ea8d29239cc526ce72/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=a9ab25e2b426a24273f121ea8d29239cc526ce72", "patch": "@@ -1673,6 +1673,8 @@ typedef struct rs6000_args\n   int sysv_gregno;\t\t/* next available GP register */\n   int intoffset;\t\t/* running offset in struct (darwin64) */\n   int use_stack;\t\t/* any part of struct on stack (darwin64) */\n+  int floats_in_gpr;\t\t/* count of SFmode floats taking up\n+\t\t\t\t   GPR space (darwin64) */\n   int named;\t\t\t/* false for varargs params */\n } CUMULATIVE_ARGS;\n "}]}