{"sha": "08346abd1968a14666f6a99ae8be09914d9ed088", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgzNDZhYmQxOTY4YTE0NjY2ZjZhOTlhZThiZTA5OTE0ZDllZDA4OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-06-11T22:41:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-06-11T22:41:54Z"}, "message": "c-common.c (handle_alias_ifunc_attribute): Do not set DECL_EXTERNAL for weakref variables.\n\n\t* c-family/c-common.c (handle_alias_ifunc_attribute): Do not set\n\tDECL_EXTERNAL for weakref variables.\n\t* c-family/c-pragma.c (handle_pragma_weak): Make sure aliases\n\tare not declared as external.\n\t* cgraph.c (cgraph_create_function_alias): Set weakref flag.\n\t* cgraph.h (symtab_node_base): Add weakref flag.\n\t* cgraphunit.c (cgraph_reset_node): Clear weakref flag.\n\t(handle_alias_pairs): Set weakref flag, do not set DECL_EXTERNAL.\n\t(output_weakrefs): Use weakref flag.\n\t* fold-const.c (simple_operand_p): Handle WEAK.\n\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Drop weakref.\n\t* ipa.c (varpool_externally_visible_p): Drop weakref.\n\t(function_and_variable_visibility): Update comment; fix weakref\n\tsanity checks; do not clear DECL_WEAK on them.\n\t* lto-cgraph.c (lto_output_node): update.\n\t(lto_output_varpool_node): Update.\n\t(input_overwrite_node): Update.\n\t(input_node): Update.\n\t(input_varpool_node): Update.\n\t* lto-symtab.c (lto_symtab_symbol_p): Do not special case weakrefs.\n\t(lto_symtab_merge_symbols): Add sanity check.\n\t(lto_symtab_prevailing_decl): Do not special case weakrefs.\n\t* passes.c (rest_of_decl_compilation): Set static flag, too.\n\t* symtab.c (dump_symtab_base): Dump weakref.\n\t(verify_symtab_base): Sanity check weakrefs.\n\t(symtab_make_decl_local): Remove duplicated code.\n\t(symtab_alias_ultimate_target): Simplify.\n\t* varpool.c (varpool_create_variable_alias): Set weakref flag.\n\n\t* lto-partition.c (get_symbol_class): Simplify weakref handling.\n\t(add_symbol_to_partition_1): Likewise.\n\t(contained_in_symbol): Likewise.\n\t(lto_balanced_map): Likewise.\n\t(rename_statics): Drop weakref.\n\nFrom-SVN: r199971", "tree": {"sha": "686df94f949e2cec6e2a798766deecbc25911199", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/686df94f949e2cec6e2a798766deecbc25911199"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08346abd1968a14666f6a99ae8be09914d9ed088", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08346abd1968a14666f6a99ae8be09914d9ed088", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08346abd1968a14666f6a99ae8be09914d9ed088", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08346abd1968a14666f6a99ae8be09914d9ed088/comments", "author": null, "committer": null, "parents": [{"sha": "e1745b439ebf2196d30206e4473a4844f5e06c6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1745b439ebf2196d30206e4473a4844f5e06c6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1745b439ebf2196d30206e4473a4844f5e06c6d"}], "stats": {"total": 175, "additions": 101, "deletions": 74}, "files": [{"sha": "486b77ff4a31539c92e6b21d5ffef9e926161a7f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -1,3 +1,30 @@\n+2013-06-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_create_function_alias): Set weakref flag.\n+\t* cgraph.h (symtab_node_base): Add weakref flag.\n+\t* cgraphunit.c (cgraph_reset_node): Clear weakref flag.\n+\t(handle_alias_pairs): Set weakref flag, do not set DECL_EXTERNAL.\n+\t(output_weakrefs): Use weakref flag.\n+\t* fold-const.c (simple_operand_p): Handle WEAK.\n+\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Drop weakref.\n+\t* ipa.c (varpool_externally_visible_p): Drop weakref.\n+\t(function_and_variable_visibility): Update comment; fix weakref\n+\tsanity checks; do not clear DECL_WEAK on them.\n+\t* lto-cgraph.c (lto_output_node): update.\n+\t(lto_output_varpool_node): Update.\n+\t(input_overwrite_node): Update.\n+\t(input_node): Update.\n+\t(input_varpool_node): Update.\n+\t* lto-symtab.c (lto_symtab_symbol_p): Do not special case weakrefs.\n+\t(lto_symtab_merge_symbols): Add sanity check.\n+\t(lto_symtab_prevailing_decl): Do not special case weakrefs.\n+\t* passes.c (rest_of_decl_compilation): Set static flag, too.\n+\t* symtab.c (dump_symtab_base): Dump weakref.\n+\t(verify_symtab_base): Sanity check weakrefs.\n+\t(symtab_make_decl_local): Remove duplicated code.\n+\t(symtab_alias_ultimate_target): Simplify.\n+\t* varpool.c (varpool_create_variable_alias): Set weakref flag.\n+\t\n 2013-06-11  DJ Delorie  <dj@redhat.com>\n \n \t* config/rl78/rl78.c (TARGET_UNWIND_WORD_MODE): Define."}, {"sha": "3d8f68f7d310b669eda7b8bc211916e0ebecade7", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -1,3 +1,10 @@\n+2013-06-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* c-common.c (handle_alias_ifunc_attribute): Do not set\n+\tDECL_EXTERNAL for weakref variables.\n+\t* c-pragma.c (handle_pragma_weak): Make sure aliases\n+\tare not declared as external.\n+\n 2013-06-07  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* array-notation-common.c (length_mismatch_in_expr_p): Moved this"}, {"sha": "7cb87345a808329fce6db220700e4508130ade00", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -7576,13 +7576,7 @@ handle_alias_ifunc_attribute (bool is_alias, tree *node, tree name, tree args,\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \tDECL_INITIAL (decl) = error_mark_node;\n       else\n-\t{\n-\t  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n-\t    DECL_EXTERNAL (decl) = 1;\n-\t  else\n-\t    DECL_EXTERNAL (decl) = 0;\n-\t  TREE_STATIC (decl) = 1;\n-\t}\n+\tTREE_STATIC (decl) = 1;\n \n       if (!is_alias)\n \t/* ifuncs are also aliases, so set that attribute too. */"}, {"sha": "309859fc8ec4cee702a5e0e93ef975a342c90854", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -367,7 +367,12 @@ handle_pragma_weak (cpp_reader * ARG_UNUSED (dummy))\n     {\n       apply_pragma_weak (decl, value);\n       if (value)\n-\tassemble_alias (decl, value);\n+\t{\n+\t  DECL_EXTERNAL (decl) = 0;\n+\t  if (TREE_CODE (decl) == VAR_DECL)\n+\t    TREE_STATIC (decl) = 1;\n+\t  assemble_alias (decl, value);\n+\t}\n     }\n   else\n     {"}, {"sha": "9ebe905c27bf48b8299e62728afe5095994a1805", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -568,6 +568,8 @@ cgraph_create_function_alias (tree alias, tree target)\n   alias_node->symbol.alias_target = target;\n   alias_node->symbol.definition = true;\n   alias_node->symbol.alias = true;\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (alias)) != NULL)\n+    alias_node->symbol.weakref = true;\n   return alias_node;\n }\n "}, {"sha": "c67506d42f5eb75186b88ce06370b28fc9b3b888", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -56,6 +56,8 @@ struct GTY(()) symtab_node_base\n   /* True when symbol is an alias.  \n      Set by assemble_alias.  */\n   unsigned alias : 1;\n+  /* True when alias is a weakref.  */\n+  unsigned weakref : 1;\n   /* C++ frontend produce same body aliases and extra name aliases for\n      virutal functions and vtables that are obviously equivalent.\n      Those aliases are bit special, especially because C++ frontend"}, {"sha": "016a6e43fa98e1b9be695eb43b694de4f52277f2", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -379,6 +379,7 @@ cgraph_reset_node (struct cgraph_node *node)\n   node->symbol.analyzed = false;\n   node->symbol.definition = false;\n   node->symbol.alias = false;\n+  node->symbol.weakref = false;\n   node->symbol.cpp_implicit_alias = false;\n \n   cgraph_node_remove_callees (node);\n@@ -1021,9 +1022,9 @@ handle_alias_pairs (void)\n \t  if (node)\n \t    {\n \t      node->symbol.alias_target = p->target;\n+\t      node->symbol.weakref = true;\n \t      node->symbol.alias = true;\n \t    }\n-\t  DECL_EXTERNAL (p->decl) = 1;\n \t  alias_pairs->unordered_remove (i);\n \t  continue;\n \t}\n@@ -1034,16 +1035,6 @@ handle_alias_pairs (void)\n \t  continue;\n \t}\n \n-      /* Normally EXTERNAL flag is used to mark external inlines,\n-\t however for aliases it seems to be allowed to use it w/o\n-\t any meaning. See gcc.dg/attr-alias-3.c  \n-\t However for weakref we insist on EXTERNAL flag being set.\n-\t See gcc.dg/attr-alias-5.c  */\n-      if (DECL_EXTERNAL (p->decl))\n-\tDECL_EXTERNAL (p->decl)\n-\t  = lookup_attribute (\"weakref\",\n-\t\t\t      DECL_ATTRIBUTES (p->decl)) != NULL;\n-\n       if (DECL_EXTERNAL (target_node->symbol.decl)\n \t  /* We use local aliases for C++ thunks to force the tailcall\n \t     to bind locally.  This is a hack - to keep it working do\n@@ -1885,9 +1876,9 @@ output_weakrefs (void)\n {\n   symtab_node node;\n   FOR_EACH_SYMBOL (node)\n-    if (node->symbol.alias && DECL_EXTERNAL (node->symbol.decl)\n+    if (node->symbol.alias\n         && !TREE_ASM_WRITTEN (node->symbol.decl)\n-\t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n+\t&& node->symbol.weakref)\n       {\n \ttree target;\n "}, {"sha": "a59e7c867f8dd5797aefea378f993133a133bd4c", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -21973,7 +21973,7 @@ else\n   then gcc_cv_as_weakref=yes\n fi\n   elif test x$gcc_cv_as != x; then\n-    $as_echo '\t.weakref foobar, barfnot' > conftest.s\n+    $as_echo '\t.weakref2 foobar, barfnot' > conftest.s\n     if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'\n   { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n   (eval $ac_try) 2>&5"}, {"sha": "66e565ced9040803ffe0b575678a971c481fbc02", "filename": "gcc/fold-const.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -3755,6 +3755,10 @@ simple_operand_p (const_tree exp)\n \t\t #pragma weak, etc).  */\n \t      && ! TREE_PUBLIC (exp)\n \t      && ! DECL_EXTERNAL (exp)\n+\t      /* Weakrefs are not safe to be read, since they can be NULL.\n+ \t\t They are !TREE_PUBLIC && !DECL_EXTERNAL but still\n+\t\t have DECL_WEAK flag set.  */\n+\t      && (! VAR_OR_FUNCTION_DECL_P (exp) || ! DECL_WEAK (exp))\n \t      /* Loading a static variable is unduly expensive, but global\n \t\t registers aren't expensive.  */\n \t      && (! TREE_STATIC (exp) || DECL_REGISTER (exp))));"}, {"sha": "60fca6bc28541c7833b8b0ea870ec5e748212959", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -73,11 +73,6 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n   if ((!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n       || (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL))\n     return true;\n-  /* Weakrefs have somewhat confusing DECL_EXTERNAL flag set; they\n-     are always safe.  */\n-  if (DECL_EXTERNAL (decl)\n-      && lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n-    return true;\n   /* We are folding reference from external vtable.  The vtable may reffer\n      to a symbol keyed to other compilation unit.  The other compilation\n      unit may be in separate DSO and the symbol may be hidden.  */"}, {"sha": "98a7b07841690dc803b58078fc8fdcb74f7a58e9", "filename": "gcc/ipa.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -664,12 +664,6 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n bool\n varpool_externally_visible_p (struct varpool_node *vnode)\n {\n-  /* Do not touch weakrefs; while they are not externally visible,\n-     dropping their DECL_EXTERNAL flags confuse most\n-     of code handling them.  */\n-  if (vnode->symbol.alias && DECL_EXTERNAL (vnode->symbol.decl))\n-    return true;\n-\n   if (DECL_EXTERNAL (vnode->symbol.decl))\n     return true;\n \n@@ -784,9 +778,9 @@ function_and_variable_visibility (bool whole_program)\n \t happy.  Clear the flag here to avoid confusion in middle-end.  */\n       if (DECL_COMDAT (node->symbol.decl) && !TREE_PUBLIC (node->symbol.decl))\n         DECL_COMDAT (node->symbol.decl) = 0;\n-      /* For external decls stop tracking same_comdat_group, it doesn't matter\n-\t what comdat group they are in when they won't be emitted in this TU,\n-\t and simplifies later passes.  */\n+\n+      /* For external decls stop tracking same_comdat_group. It doesn't matter\n+\t what comdat group they are in when they won't be emitted in this TU.  */\n       if (node->symbol.same_comdat_group && DECL_EXTERNAL (node->symbol.decl))\n \t{\n #ifdef ENABLE_CHECKING\n@@ -804,6 +798,7 @@ function_and_variable_visibility (bool whole_program)\n       gcc_assert ((!DECL_WEAK (node->symbol.decl)\n \t\t  && !DECL_COMDAT (node->symbol.decl))\n       \t          || TREE_PUBLIC (node->symbol.decl)\n+\t\t  || node->symbol.weakref\n \t\t  || DECL_EXTERNAL (node->symbol.decl));\n       if (cgraph_externally_visible_p (node, whole_program))\n         {\n@@ -815,7 +810,8 @@ function_and_variable_visibility (bool whole_program)\n \t  node->symbol.externally_visible = false;\n \t  node->symbol.forced_by_abi = false;\n \t}\n-      if (!node->symbol.externally_visible && node->symbol.definition\n+      if (!node->symbol.externally_visible\n+\t  && node->symbol.definition && !node->symbol.weakref\n \t  && !DECL_EXTERNAL (node->symbol.decl))\n \t{\n \t  gcc_assert (whole_program || in_lto_p\n@@ -860,6 +856,7 @@ function_and_variable_visibility (bool whole_program)\n     {\n       /* weak flag makes no sense on local variables.  */\n       gcc_assert (!DECL_WEAK (vnode->symbol.decl)\n+\t\t  || vnode->symbol.weakref\n       \t\t  || TREE_PUBLIC (vnode->symbol.decl)\n \t\t  || DECL_EXTERNAL (vnode->symbol.decl));\n       /* In several cases declarations can not be common:\n@@ -897,7 +894,8 @@ function_and_variable_visibility (bool whole_program)\n           vnode->symbol.externally_visible = false;\n \t  vnode->symbol.forced_by_abi = false;\n \t}\n-      if (!vnode->symbol.externally_visible)\n+      if (!vnode->symbol.externally_visible\n+\t  && !vnode->symbol.weakref)\n \t{\n \t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->symbol.decl));\n \t  symtab_make_decl_local (vnode->symbol.decl);"}, {"sha": "63a9ddb222738232a954997e5bbe52888c80210a", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -487,8 +487,9 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n      defined in other unit, we may use the info on aliases to resolve \n      symbol1 != symbol2 type tests that we can do only for locally defined objects\n      otherwise.  */\n-  alias_p = node->symbol.alias && (!boundary_p || DECL_EXTERNAL (node->symbol.decl));\n+  alias_p = node->symbol.alias && (!boundary_p || node->symbol.weakref);\n   bp_pack_value (&bp, alias_p, 1);\n+  bp_pack_value (&bp, node->symbol.weakref, 1);\n   bp_pack_value (&bp, node->frequency, 2);\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n   bp_pack_value (&bp, node->only_called_at_exit, 1);\n@@ -531,8 +532,9 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   bp_pack_value (&bp, node->symbol.forced_by_abi, 1);\n   bp_pack_value (&bp, node->symbol.unique_name, 1);\n   bp_pack_value (&bp, node->symbol.definition, 1);\n-  alias_p = node->symbol.alias && (!boundary_p || DECL_EXTERNAL (node->symbol.decl));\n+  alias_p = node->symbol.alias && (!boundary_p || node->symbol.weakref);\n   bp_pack_value (&bp, alias_p, 1);\n+  bp_pack_value (&bp, node->symbol.weakref, 1);\n   bp_pack_value (&bp, node->symbol.analyzed && !boundary_p, 1);\n   gcc_assert (node->symbol.definition || !node->symbol.analyzed);\n   /* Constant pool initializers can be de-unified into individual ltrans units.\n@@ -906,6 +908,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n       TREE_STATIC (node->symbol.decl) = 0;\n     }\n   node->symbol.alias = bp_unpack_value (bp, 1);\n+  node->symbol.weakref = bp_unpack_value (bp, 1);\n   node->frequency = (enum node_frequency)bp_unpack_value (bp, 2);\n   node->only_called_at_startup = bp_unpack_value (bp, 1);\n   node->only_called_at_exit = bp_unpack_value (bp, 1);\n@@ -1010,8 +1013,7 @@ input_node (struct lto_file_decl_data *file_data,\n       node->thunk.virtual_value = virtual_value;\n       node->thunk.virtual_offset_p = (type & 4);\n     }\n-  if (node->symbol.alias && !node->symbol.analyzed\n-      && lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n+  if (node->symbol.alias && !node->symbol.analyzed && node->symbol.weakref)\n     node->symbol.alias_target = get_alias_symbol (node->symbol.decl);\n   return node;\n }\n@@ -1046,6 +1048,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->symbol.unique_name = bp_unpack_value (&bp, 1);\n   node->symbol.definition = bp_unpack_value (&bp, 1);\n   node->symbol.alias = bp_unpack_value (&bp, 1);\n+  node->symbol.weakref = bp_unpack_value (&bp, 1);\n   node->symbol.analyzed = bp_unpack_value (&bp, 1);\n   node->symbol.used_from_other_partition = bp_unpack_value (&bp, 1);\n   node->symbol.in_other_partition = bp_unpack_value (&bp, 1);\n@@ -1054,8 +1057,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n       DECL_EXTERNAL (node->symbol.decl) = 1;\n       TREE_STATIC (node->symbol.decl) = 0;\n     }\n-  if (node->symbol.alias && !node->symbol.analyzed\n-      && lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n+  if (node->symbol.alias && !node->symbol.analyzed && node->symbol.weakref)\n     node->symbol.alias_target = get_alias_symbol (node->symbol.decl);\n   ref = streamer_read_hwi (ib);\n   /* Store a reference for now, and fix up later to be a pointer.  */"}, {"sha": "5f0b97165560690f4aa7d44e7c3b613619ac06ec", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -235,9 +235,6 @@ lto_symtab_symbol_p (symtab_node e)\n {\n   if (!TREE_PUBLIC (e->symbol.decl) && !DECL_EXTERNAL (e->symbol.decl))\n     return false;\n-  /* weakrefs are really static variables that are made external by a hack.  */\n-  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (e->symbol.decl)))\n-    return false;\n   return symtab_real_symbol_p (e);\n }\n \n@@ -589,6 +586,7 @@ lto_symtab_merge_symbols (void)\n \t  if (!node->symbol.analyzed && node->symbol.alias_target)\n \t    {\n \t      symtab_node tgt = symtab_node_for_asm (node->symbol.alias_target);\n+\t      gcc_assert (node->symbol.weakref);\n \t      if (tgt)\n \t\tsymtab_resolve_alias (node, tgt);\n \t    }\n@@ -617,11 +615,6 @@ lto_symtab_prevailing_decl (tree decl)\n   if (TREE_CODE (decl) == FUNCTION_DECL && DECL_BUILT_IN (decl))\n     return decl;\n \n-  /* As an anoying special cases weakrefs are really static variables with\n-     EXTERNAL flag.  */\n-  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n-    return decl;\n-\n   /* Ensure DECL_ASSEMBLER_NAME will not set assembler name.  */\n   gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n "}, {"sha": "153f023b4a13ddc9ce15b0e5f192ed8ac84accb2", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -1,3 +1,11 @@\n+2013-06-11 Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-partition.c (get_symbol_class): Simplify weakref handling.\n+\t(add_symbol_to_partition_1): Likewise.\n+\t(contained_in_symbol): Likewise.\n+\t(lto_balanced_map): Likewise.\n+\t(rename_statics): Drop weakref.\n+\n 2013-06-05  Richard Biener  <rguenther@suse.de>\n \n \t* lto.c (num_merged_types): New global variable."}, {"sha": "6f4538061558766dd331af71da5464f83f0fce2c", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -60,7 +60,7 @@ get_symbol_class (symtab_node node)\n     return SYMBOL_DUPLICATE;\n \n   /* Weakref aliases are always duplicated.  */\n-  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n+  if (node->symbol.weakref)\n     return SYMBOL_DUPLICATE;\n \n   /* External declarations are external.  */\n@@ -218,10 +218,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node node)\n \n   /* Add all aliases associated with the symbol.  */\n   for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS\n-\t&& !lookup_attribute (\"weakref\",\n-\t\t\t      DECL_ATTRIBUTES\n-\t\t\t\t(ref->referring->symbol.decl)))\n+    if (ref->use == IPA_REF_ALIAS && !node->symbol.weakref)\n       add_symbol_to_partition_1 (part, ref->referring);\n \n   /* Ensure that SAME_COMDAT_GROUP lists all allways added in a group.  */\n@@ -243,8 +240,7 @@ static symtab_node\n contained_in_symbol (symtab_node node)\n {\n   /* Weakrefs are never contained in anything.  */\n-  if (lookup_attribute (\"weakref\",\n-\t\t\tDECL_ATTRIBUTES (node->symbol.decl)))\n+  if (node->symbol.weakref)\n     return node;\n   if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n     {\n@@ -561,8 +557,7 @@ lto_balanced_map (void)\n \n \t      last_visited_node++;\n \n-\t      gcc_assert (node->symbol.definition\n-\t\t\t  || lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)));\n+\t      gcc_assert (node->symbol.definition || node->symbol.weakref);\n \n \t      /* Compute boundary cost of callgraph edges.  */\n \t      for (edge = node->callees; edge; edge = edge->next_callee)\n@@ -871,8 +866,7 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node node)\n \t once this is fixed.  */\n         || DECL_EXTERNAL (node->symbol.decl)\n         || !symtab_real_symbol_p (node))\n-       && !may_need_named_section_p (encoder, node)\n-       && !lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n+       && !may_need_named_section_p (encoder, node))\n     return;\n \n   /* Now walk symbols sharing the same name and see if there are any conflicts.\n@@ -897,11 +891,9 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node node)\n   /* Assign every symbol in the set that shares the same ASM name an unique\n      mangled name.  */\n   for (s = symtab_node_for_asm (name); s;)\n-    if ((!s->symbol.externally_visible\n-\t || lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n+    if (!s->symbol.externally_visible\n \t&& ((symtab_real_symbol_p (s)\n-             && (!DECL_EXTERNAL (node->symbol.decl)\n-\t         || lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n+             && !DECL_EXTERNAL (node->symbol.decl)\n \t     && !TREE_PUBLIC (node->symbol.decl))\n  \t    || may_need_named_section_p (encoder, s))\n \t&& (!encoder"}, {"sha": "c8b03eef133532246afc2f0d4cd9bff6e0f0e811", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -136,8 +136,8 @@ rest_of_decl_compilation (tree decl,\n \t/* A quirk of the initial implementation of aliases required that the\n \t   user add \"extern\" to all of them.  Which is silly, but now\n \t   historical.  Do note that the symbol is in fact locally defined.  */\n-\tif (!lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n-\t  DECL_EXTERNAL (decl) = 0;\n+\tDECL_EXTERNAL (decl) = 0;\n+\tTREE_STATIC (decl) = 1;\n \tassemble_alias (decl, alias);\n       }\n   }"}, {"sha": "7a02270c2578f7a57377334f33a98a087bf34288", "filename": "gcc/symtab.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -481,6 +481,8 @@ dump_symtab_base (FILE *f, symtab_node node)\n     fprintf (f, \" analyzed\");\n   if (node->symbol.alias)\n     fprintf (f, \" alias\");\n+  if (node->symbol.weakref)\n+    fprintf (f, \" weakref\");\n   if (node->symbol.cpp_implicit_alias)\n     fprintf (f, \" cpp_implicit_alias\");\n   if (node->symbol.alias_target)\n@@ -682,11 +684,16 @@ verify_symtab_base (symtab_node node)\n       error_found = true;\n     }\n   if (node->symbol.alias && !node->symbol.definition\n-      && !lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n+      && !node->symbol.weakref)\n     {\n       error (\"node is alias but not definition\");\n       error_found = true;\n     }\n+  if (node->symbol.weakref && !node->symbol.alias)\n+    {\n+      error (\"node is weakref but not an alias\");\n+      error_found = true;\n+    }\n   if (node->symbol.same_comdat_group)\n     {\n       symtab_node n = node->symbol.same_comdat_group;\n@@ -799,8 +806,6 @@ symtab_make_decl_local (tree decl)\n   DECL_VISIBILITY_SPECIFIED (decl) = 0;\n   DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n   TREE_PUBLIC (decl) = 0;\n-  DECL_VISIBILITY_SPECIFIED (decl) = 0;\n-  DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n   if (!DECL_RTL_SET_P (decl))\n     return;\n \n@@ -861,7 +866,7 @@ symtab_alias_ultimate_target (symtab_node node, enum availability *availability)\n \n   if (availability)\n     {\n-      weakref_p = DECL_EXTERNAL (node->symbol.decl) && node->symbol.alias;\n+      weakref_p = node->symbol.weakref;\n       if (!weakref_p)\n         *availability = symtab_node_availability (node);\n       else\n@@ -893,7 +898,7 @@ symtab_alias_ultimate_target (symtab_node node, enum availability *availability)\n \t  enum availability a = symtab_node_availability (node);\n \t  if (a < *availability)\n \t    *availability = a;\n-          weakref_p = DECL_EXTERNAL (node->symbol.decl) && node->symbol.alias;\n+          weakref_p = node->symbol.weakref;\n \t}\n     }\n   if (availability)"}, {"sha": "4b238843aea940a46c49482489b468fbfe47184d", "filename": "gcc/varpool.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08346abd1968a14666f6a99ae8be09914d9ed088/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=08346abd1968a14666f6a99ae8be09914d9ed088", "patch": "@@ -452,6 +452,8 @@ varpool_create_variable_alias (tree alias, tree decl)\n   alias_node->symbol.alias = true;\n   alias_node->symbol.definition = true;\n   alias_node->symbol.alias_target = decl;\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (alias)) != NULL)\n+    alias_node->symbol.weakref = true;\n   return alias_node;\n }\n "}]}