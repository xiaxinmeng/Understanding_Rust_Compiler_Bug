{"sha": "e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk2YjRkN2E0NGQ4M2RjMmQ1Y2JmMmY2YTEyZDljNDZhNzY4ODZmNA==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1998-11-25T21:32:27Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1998-11-25T21:32:27Z"}, "message": "loop.h (precondition_loop_p): Added new mode argument.\n\n \t* loop.h (precondition_loop_p): Added new mode argument.\n\t* unroll.c (precondition_loop_p): Likewise.\n\t(approx_final_value): Function deleted and subsumed\n \tinto loop_iterations.\n\t(loop_find_equiv_value): New function.\n\t(loop_iterations): Use loop_find_equiv_value to find increments\n\ttoo large to be immediate constants.  Also use it to find terms\n\tcommon to initial and final iteration values that can be removed.\n\nFrom-SVN: r23885", "tree": {"sha": "cd0eae0716d026df7c60885348c56a4214b633aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd0eae0716d026df7c60885348c56a4214b633aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4/comments", "author": null, "committer": null, "parents": [{"sha": "302670f3f00ef8b555278b4216e3c1e1544352c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/302670f3f00ef8b555278b4216e3c1e1544352c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/302670f3f00ef8b555278b4216e3c1e1544352c2"}], "stats": {"total": 431, "additions": 273, "deletions": 158}, "files": [{"sha": "08456eee6d3c6a9bc8cb0008cf5a5ee9d39a5a91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4", "patch": "@@ -1,3 +1,15 @@\n+Thu Nov 26 18:26:21 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+ \t* loop.h (precondition_loop_p): Added new mode argument.\n+\t* unroll.c (precondition_loop_p): Likewise.\n+\t(approx_final_value): Function deleted and subsumed\n+ \tinto loop_iterations.\n+\t(loop_find_equiv_value): New function.\n+\t(loop_iterations): Use loop_find_equiv_value to find increments\n+\ttoo large to be immediate constants.  Also use it to find terms\n+\tcommon to initial and final iteration values that can be removed.\n+\n+\n Thu Nov 26 18:05:04 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* loop.h (struct loop_info): Define new structure."}, {"sha": "c47fa414868d242bd6a798a34b9a0fe0b5781048", "filename": "gcc/loop.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4", "patch": "@@ -215,7 +215,8 @@ void unroll_loop PROTO((rtx, int, rtx, rtx, struct loop_info *, int));\n rtx biv_total_increment PROTO((struct iv_class *, rtx, rtx));\n unsigned HOST_WIDE_INT loop_iterations PROTO((rtx, rtx, struct loop_info *));\n int precondition_loop_p PROTO((rtx, struct loop_info *, \n-\t\t\t       rtx *, rtx *, rtx *));\n+\t\t\t       rtx *, rtx *, rtx *, \n+\t\t\t       enum machine_mode *mode));\n rtx final_biv_value PROTO((struct iv_class *, rtx, rtx,\n \t\t\t   unsigned HOST_WIDE_INT));\n rtx final_giv_value PROTO((struct induction *, rtx, rtx,"}, {"sha": "0e616f5154d064758d14665774abaaadccb41380", "filename": "gcc/unroll.c", "status": "modified", "additions": 259, "deletions": 157, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=e96b4d7a44d83dc2d5cbf2f6a12d9c46a76886f4", "patch": "@@ -195,7 +195,6 @@ static void final_reg_note_copy PROTO((rtx, struct inline_remap *));\n static void copy_loop_body PROTO((rtx, rtx, struct inline_remap *, rtx, int,\n \t\t\t\t  enum unroll_types, rtx, rtx, rtx, rtx));\n void iteration_info PROTO((rtx, rtx *, rtx *, rtx, rtx));\n-static rtx approx_final_value PROTO((enum rtx_code, rtx, int *, int *));\n static int find_splittable_regs PROTO((enum unroll_types, rtx, rtx, rtx, int,\n \t\t\t\t       unsigned HOST_WIDE_INT));\n static int find_splittable_givs PROTO((struct iv_class *, enum unroll_types,\n@@ -849,12 +848,13 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   if (unroll_type == UNROLL_NAIVE && ! splitting_not_safe && strength_reduce_p)\n     {\n       rtx initial_value, final_value, increment;\n+      enum machine_mode mode;\n \n       if (precondition_loop_p (loop_start, loop_info,\n-\t\t\t       &initial_value, &final_value, &increment))\n+\t\t\t       &initial_value, &final_value, &increment,\n+\t\t\t       &mode))\n \t{\n \t  register rtx diff ;\n-\t  enum machine_mode mode;\n \t  rtx *labels;\n \t  int abs_inc, neg_inc;\n \n@@ -886,21 +886,6 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n \t  start_sequence ();\n \n-\t  /* Decide what mode to do these calculations in.  Choose the larger\n-\t     of final_value's mode and initial_value's mode, or a full-word if\n-\t     both are constants.  */\n-\t  mode = GET_MODE (final_value);\n-\t  if (mode == VOIDmode)\n-\t    {\n-\t      mode = GET_MODE (initial_value);\n-\t      if (mode == VOIDmode)\n-\t\tmode = word_mode;\n-\t    }\n-\t  else if (mode != GET_MODE (initial_value)\n-\t\t   && (GET_MODE_SIZE (mode)\n-\t\t       < GET_MODE_SIZE (GET_MODE (initial_value))))\n-\t    mode = GET_MODE (initial_value);\n-\n \t  /* Calculate the difference between the final and initial values.\n \t     Final value may be a (plus (reg x) (const_int 1)) rtx.\n \t     Let the following cse pass simplify this if initial value is\n@@ -1314,17 +1299,19 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n int\n precondition_loop_p (loop_start, loop_info,\n-\t\t     initial_value, final_value, increment)\n+\t\t     initial_value, final_value, increment, mode)\n      rtx loop_start;\n      struct loop_info *loop_info;\n      rtx *initial_value, *final_value, *increment;\n+     enum machine_mode *mode;\n {\n \n   if (loop_info->n_iterations > 0)\n     {\n       *initial_value = const0_rtx;\n       *increment = const1_rtx;\n       *final_value = GEN_INT (loop_info->n_iterations);\n+      *mode = word_mode;\n \n       if (loop_dump_stream)\n \t{\n@@ -1430,6 +1417,21 @@ precondition_loop_p (loop_start, loop_info,\n   *increment = loop_info->increment;\n   *final_value = loop_info->final_value;\n \n+  /* Decide what mode to do these calculations in.  Choose the larger\n+     of final_value's mode and initial_value's mode, or a full-word if\n+     both are constants.  */\n+  *mode = GET_MODE (*final_value);\n+  if (*mode == VOIDmode)\n+    {\n+      *mode = GET_MODE (*initial_value);\n+      if (*mode == VOIDmode)\n+\t*mode = word_mode;\n+    }\n+  else if (*mode != GET_MODE (*initial_value)\n+\t   && (GET_MODE_SIZE (*mode)\n+\t       < GET_MODE_SIZE (GET_MODE (*initial_value))))\n+    *mode = GET_MODE (*initial_value);\n+\n   /* Success! */\n   if (loop_dump_stream)\n     fprintf (loop_dump_stream, \"Preconditioning: Successful.\\n\");\n@@ -2421,60 +2423,6 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n     }\n }\n \n-/* Calculate the approximate final value of the iteration variable\n-   which has an loop exit test with code COMPARISON_CODE and comparison value\n-   of COMPARISON_VALUE.  Also returns an indication of whether the comparison\n-   was signed or unsigned, and the direction of the comparison.  This info is\n-   needed to calculate the number of loop iterations.  */\n-\n-static rtx\n-approx_final_value (comparison_code, comparison_value, unsigned_p, compare_dir)\n-     enum rtx_code comparison_code;\n-     rtx comparison_value;\n-     int *unsigned_p;\n-     int *compare_dir;\n-{\n-  /* Calculate the final value of the induction variable.\n-     The exact final value depends on the branch operator, and increment sign.\n-     This is only an approximate value.  It will be wrong if the iteration\n-     variable is not incremented by one each time through the loop, and\n-     approx final value - start value % increment != 0.  */\n-\n-  *unsigned_p = 0;\n-  switch (comparison_code)\n-    {\n-    case LEU:\n-      *unsigned_p = 1;\n-    case LE:\n-      *compare_dir = 1;\n-      return plus_constant (comparison_value, 1);\n-    case GEU:\n-      *unsigned_p = 1;\n-    case GE:\n-      *compare_dir = -1;\n-      return plus_constant (comparison_value, -1);\n-    case EQ:\n-      /* Can not calculate a final value for this case.  */\n-      *compare_dir = 0;\n-      return 0;\n-    case LTU:\n-      *unsigned_p = 1;\n-    case LT:\n-      *compare_dir = 1;\n-      return comparison_value;\n-      break;\n-    case GTU:\n-      *unsigned_p = 1;\n-    case GT:\n-      *compare_dir = -1;\n-      return comparison_value;\n-    case NE:\n-      *compare_dir = 0;\n-      return comparison_value;\n-    default:\n-      abort ();\n-    }\n-}\n \n /* For each biv and giv, determine whether it can be safely split into\n    a different variable for each unrolled copy of the loop body.  If it\n@@ -3398,6 +3346,51 @@ final_giv_value (v, loop_start, loop_end, n_iterations)\n }\n \n \n+/* Look back before LOOP_START for then insn that sets REG and return\n+   the equivalent constant if there is a REG_EQUAL note otherwise just\n+   the SET_SRC of REG.  */\n+\n+static rtx\n+loop_find_equiv_value (loop_start, reg)\n+     rtx loop_start;\n+     rtx reg;\n+{\n+  rtx insn, set;\n+  rtx ret;\n+  \n+  ret = reg;\n+  for (insn = PREV_INSN (loop_start); insn ; insn = PREV_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\tbreak;\n+      \n+      else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t       && reg_set_p (reg, insn))\n+\t{\n+\t  /* We found the last insn before the loop that sets the register.\n+\t     If it sets the entire register, and has a REG_EQUAL note,\n+\t     then use the value of the REG_EQUAL note.  */\n+\t  if ((set = single_set (insn))\n+\t\t  && (SET_DEST (set) == reg))\n+\t    {\n+\t      rtx note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n+\t      \n+\t      /* Only use the REG_EQUAL note if it is a constant.\n+\t\t Other things, divide in particular, will cause\n+\t\t problems later if we use them.  */\n+\t      if (note && GET_CODE (XEXP (note, 0)) != EXPR_LIST\n+\t\t  && CONSTANT_P (XEXP (note, 0)))\n+\t\tret = XEXP (note, 0);\n+\t      else\n+\t\tret = SET_SRC (set);\n+\t    }\n+\t  break;\n+\t}\n+    }\n+  return ret;\n+}\n+\n+\n /* Calculate the number of loop iterations.  Returns the exact number of loop\n    iterations if it can be calculated, otherwise returns zero.  */\n \n@@ -3409,23 +3402,28 @@ loop_iterations (loop_start, loop_end, loop_info)\n   rtx comparison, comparison_value;\n   rtx iteration_var, initial_value, increment, final_value;\n   enum rtx_code comparison_code;\n-  HOST_WIDE_INT i;\n+  HOST_WIDE_INT abs_inc;\n+  unsigned HOST_WIDE_INT abs_diff;\n+  int off_by_one;\n   int increment_dir;\n-  int unsigned_compare, compare_dir, final_larger;\n-  unsigned long tempu;\n+  int unsigned_p, compare_dir, final_larger;\n   rtx last_loop_insn;\n \n-  /* First find the iteration variable.  If the last insn is a conditional\n-     branch, and the insn before tests a register value, make that the\n-     iteration variable.  */\n-  \n+  loop_info->n_iterations = 0;\n   loop_info->initial_value = 0;\n-  loop_info->increment = 0;\n+  loop_info->initial_equiv_value = 0;\n+  loop_info->comparison_value = 0;\n   loop_info->final_value = 0;\n+  loop_info->final_equiv_value = 0;\n+  loop_info->increment = 0;\n   loop_info->iteration_var = 0;\n-  loop_info->unroll_number = 2;\n+  loop_info->unroll_number = 1;\n \n-  /* We used to use pren_nonnote_insn here, but that fails because it might\n+  /* First find the iteration variable.  If the last insn is a conditional\n+     branch, and the insn before tests a register value, make that the\n+     iteration variable.  */\n+  \n+  /* We used to use prev_nonnote_insn here, but that fails because it might\n      accidentally get the branch for a contained loop if the branch for this\n      loop was deleted.  We can only trust branches immediately before the\n      loop_end.  */\n@@ -3436,7 +3434,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: No final conditional branch found.\\n\");\n+\t\t \"Loop iterations: No final conditional branch found.\\n\");\n       return 0;\n     }\n \n@@ -3451,7 +3449,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: Comparison not against register.\\n\");\n+\t\t \"Loop iterations: Comparison not against register.\\n\");\n       return 0;\n     }\n \n@@ -3467,102 +3465,201 @@ loop_iterations (loop_start, loop_end, loop_info)\n     /* iteration_info already printed a message.  */\n     return 0;\n \n+  unsigned_p = 0;\n+  off_by_one = 0;\n+  switch (comparison_code)\n+    {\n+    case LEU:\n+      unsigned_p = 1;\n+    case LE:\n+      compare_dir = 1;\n+      off_by_one = 1;\n+      break;\n+    case GEU:\n+      unsigned_p = 1;\n+    case GE:\n+      compare_dir = -1;\n+      off_by_one = -1;\n+      break;\n+    case EQ:\n+      /* Cannot determine loop iterations with this case.  */\n+      compare_dir = 0;\n+      break;\n+    case LTU:\n+      unsigned_p = 1;\n+    case LT:\n+      compare_dir = 1;\n+      break;\n+    case GTU:\n+      unsigned_p = 1;\n+    case GT:\n+      compare_dir = -1;\n+    case NE:\n+      compare_dir = 0;\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n   /* If the comparison value is an invariant register, then try to find\n      its value from the insns before the start of the loop.  */\n \n+  final_value = comparison_value;\n   if (GET_CODE (comparison_value) == REG && invariant_p (comparison_value))\n     {\n-      rtx insn, set;\n-    \n-      for (insn = PREV_INSN (loop_start); insn ; insn = PREV_INSN (insn))\n-\t{\n-\t  if (GET_CODE (insn) == CODE_LABEL)\n-\t    break;\n-\n-\t  else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t\t   && reg_set_p (comparison_value, insn))\n-\t    {\n-\t      /* We found the last insn before the loop that sets the register.\n-\t\t If it sets the entire register, and has a REG_EQUAL note,\n-\t\t then use the value of the REG_EQUAL note.  */\n-\t      if ((set = single_set (insn))\n-\t\t  && (SET_DEST (set) == comparison_value))\n-\t\t{\n-\t\t  rtx note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-\n-\t\t  /* Only use the REG_EQUAL note if it is a constant.\n-\t\t     Other things, divide in particular, will cause\n-\t\t     problems later if we use them.  */\n-\t\t  if (note && GET_CODE (XEXP (note, 0)) != EXPR_LIST\n-\t\t      && CONSTANT_P (XEXP (note, 0)))\n-\t\t    comparison_value = XEXP (note, 0);\n-\t\t}\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  final_value = approx_final_value (comparison_code, comparison_value,\n-\t\t\t\t    &unsigned_compare, &compare_dir);\n+      final_value = loop_find_equiv_value (loop_start, comparison_value);\n+      /* If we don't get an invariant final value, we are better\n+\t off with the original register.  */\n+      if (!invariant_p (final_value))\n+\tfinal_value = comparison_value;\n+    }\n+\n+  /* Calculate the approximate final value of the induction variable\n+     (on the last successful iteration).  The exact final value\n+     depends on the branch operator, and increment sign.  It will be\n+     wrong if the iteration variable is not incremented by one each\n+     time through the loop and (comparison_value + off_by_one -\n+     initial_value) % increment != 0.\n+     ??? Note that the final_value may overflow and thus final_larger\n+     will be bogus.  A potentially infinite loop will be classified\n+     as immediate, e.g. for (i = 0x7ffffff0; i <= 0x7fffffff; i++)  */\n+  if (off_by_one)\n+    final_value = plus_constant (final_value, off_by_one);\n \n   /* Save the calculated values describing this loop's bounds, in case\n      precondition_loop_p will need them later.  These values can not be\n      recalculated inside precondition_loop_p because strength reduction\n-     optimizations may obscure the loop's structure.  */\n+     optimizations may obscure the loop's structure.  \n \n-  loop_info->iteration_var = iteration_var;\n+     These values are only required by precondition_loop_p and insert_bct\n+     whenever the number of iterations cannot be computed at compile time.\n+     Only the difference between final_value and initial_value is\n+     important.  Note that final_value is only approximate.  */\n   loop_info->initial_value = initial_value;\n+  loop_info->comparison_value = comparison_value;\n+  loop_info->final_value = plus_constant (comparison_value, off_by_one);\n   loop_info->increment = increment;\n-  loop_info->final_value = final_value;\n+  loop_info->iteration_var = iteration_var;\n   loop_info->comparison_code = comparison_code;\n \n+  if (REG_P (initial_value))\n+    {\n+      rtx temp = final_value;\n+\n+      /* initial_value = reg1, final_value = reg2 + const, where reg1\n+\t != reg2.  Try to find what reg1 is equivalent to.  Hopefully\n+\t it will either be reg2 or reg2 plus a constant.  */\n+      if (GET_CODE (temp) == PLUS)\n+\ttemp = XEXP (temp, 0);\n+      if (REG_P (temp) && REGNO (temp) != REGNO (initial_value))\n+\tinitial_value = loop_find_equiv_value (loop_start, initial_value);\n+    }\n+\n+  /* If have initial_value = reg + const1 and final_value = reg +\n+     const2, then replace initial_value with const1 and final_value\n+     with const2.  This should be safe since we are protected by the\n+     initial comparison before entering the loop.  */\n+  if ((GET_CODE (initial_value) == REG || GET_CODE (initial_value) == PLUS)\n+      && (GET_CODE (final_value) == REG || GET_CODE (final_value) == PLUS))\n+    {\n+      rtx init_op0;\n+      rtx fini_op0;\n+      rtx init_op1;\n+      rtx fini_op1;\n+\n+      if (GET_CODE (initial_value) == PLUS)\n+\tinit_op1 = XEXP (initial_value, 1), init_op0 = XEXP (initial_value, 0);\n+      else\n+\tinit_op1 = const0_rtx, init_op0 = initial_value;\n+\n+      if (GET_CODE (final_value) == PLUS)\n+\tfini_op1 = XEXP (final_value, 1), fini_op0 = XEXP (final_value, 0);\n+      else\n+\tfini_op1 = const0_rtx, fini_op0 = final_value;\n+\n+      /* Remove register common factor if present.  */\n+      if (REG_P (init_op0) && init_op0 == fini_op0)\n+\t{\n+\t  initial_value = init_op1;\n+\t  final_value = fini_op1;\n+\t}\n+      else if (REG_P (init_op0) && init_op0 == fini_op1)\n+\t{\n+\t  initial_value = init_op1;\n+\t  final_value = fini_op0;\n+\t}\n+      else if (REG_P (init_op1) && init_op1 == fini_op0)\n+\t{\n+\t  initial_value = init_op0;\n+\t  final_value = fini_op1;\n+\t}\n+      else if (REG_P (init_op1) && init_op1 == fini_op1)\n+\t{\n+\t  initial_value = init_op0;\n+\t  final_value = fini_op0;\n+\t}\n+    }\n+  loop_info->initial_equiv_value = initial_value;\n+  loop_info->final_equiv_value = final_value;\n+  \n   if (increment == 0)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: Increment value can't be calculated.\\n\");\n+\t\t \"Loop iterations: Increment value can't be calculated.\\n\");\n       return 0;\n     }\n-  else if (GET_CODE (increment) != CONST_INT)\n+\n+  if (GET_CODE (increment) != CONST_INT)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: Increment value not constant.\\n\");\n-      return 0;\n+      increment = loop_find_equiv_value (loop_start, increment);\n+\n+      if (GET_CODE (increment) != CONST_INT)\n+\t{\n+\t  if (loop_dump_stream)\n+\t    {\n+\t      fprintf (loop_dump_stream,\n+\t\t       \"Loop iterations: Increment value not constant \");\n+\t      print_rtl (loop_dump_stream, increment);\n+\t      fprintf (loop_dump_stream, \".\\n\");\n+\t    }\n+\t  return 0;\n+\t}\n+      loop_info->increment = increment;\n     }\n-  else if (GET_CODE (initial_value) != CONST_INT)\n+\n+  if (GET_CODE (initial_value) != CONST_INT)\n     {\n       if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: Initial value not constant.\\n\");\n+\t{\n+\t  fprintf (loop_dump_stream,\n+\t\t   \"Loop iterations: Initial value not constant \");\n+\t  print_rtl (loop_dump_stream, initial_value);\n+\t  fprintf (loop_dump_stream, \".\\n\");\n+\t}\n       return 0;\n     }\n-  else if (final_value == 0)\n+  else if (comparison_code == EQ)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: EQ comparison loop.\\n\");\n+\t\t \"Loop iterations: EQ comparison loop.\\n\");\n       return 0;\n     }\n   else if (GET_CODE (final_value) != CONST_INT)\n     {\n       if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: Final value not constant.\\n\");\n+\t{\n+\t  fprintf (loop_dump_stream,\n+\t\t   \"Loop iterations: Final value not constant \");\n+\t  print_rtl (loop_dump_stream, final_value);\n+\t  fprintf (loop_dump_stream, \".\\n\");\n+\t}\n       return 0;\n     }\n \n-  /* ?? Final value and initial value do not have to be constants.\n-     Only their difference has to be constant.  When the iteration variable\n-     is an array address, the final value and initial value might both\n-     be addresses with the same base but different constant offsets.\n-     Final value must be invariant for this to work.\n-\n-     To do this, need some way to find the values of registers which are\n-     invariant.  */\n-\n   /* Final_larger is 1 if final larger, 0 if they are equal, otherwise -1.  */\n-  if (unsigned_compare)\n+  if (unsigned_p)\n     final_larger\n       = ((unsigned HOST_WIDE_INT) INTVAL (final_value)\n \t > (unsigned HOST_WIDE_INT) INTVAL (initial_value))\n@@ -3614,35 +3711,40 @@ loop_iterations (loop_start, loop_end, loop_info)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: Not normal loop.\\n\");\n+\t\t \"Loop iterations: Not normal loop.\\n\");\n       return 0;\n     }\n \n   /* Calculate the number of iterations, final_value is only an approximation,\n-     so correct for that.  Note that tempu and loop_info->n_iterations are\n+     so correct for that.  Note that abs_diff and n_iterations are\n      unsigned, because they can be as large as 2^n - 1.  */\n \n-  i = INTVAL (increment);\n-  if (i > 0)\n-    tempu = INTVAL (final_value) - INTVAL (initial_value);\n-  else if (i < 0)\n+  abs_inc = INTVAL (increment);\n+  if (abs_inc > 0)\n+    abs_diff = INTVAL (final_value) - INTVAL (initial_value);\n+  else if (abs_inc < 0)\n     {\n-      tempu = INTVAL (initial_value) - INTVAL (final_value);\n-      i = -i;\n+      abs_diff = INTVAL (initial_value) - INTVAL (final_value);\n+      abs_inc = -abs_inc;\n     }\n   else\n     abort ();\n \n-  /* For NE tests, make sure that the iteration variable won't miss the\n-     final value.  If tempu mod i is not zero, then the iteration variable\n-     will overflow before the loop exits, and we can not calculate the\n-     number of iterations.  */\n-  if (compare_dir == 0 && (tempu % i) != 0)\n+  /* For NE tests, make sure that the iteration variable won't miss\n+     the final value.  If abs_diff mod abs_incr is not zero, then the\n+     iteration variable will overflow before the loop exits, and we\n+     can not calculate the number of iterations.  */\n+  if (compare_dir == 0 && (abs_diff % abs_inc) != 0)\n     return 0;\n \n-  return tempu / i + ((tempu % i) != 0);\n+  /* Note that the number of iterations could be calculated using\n+     (abs_diff + abs_inc - 1) / abs_inc, provided care was taken to\n+     handle potential overflow of the summation.  */\n+  loop_info->n_iterations = abs_diff / abs_inc + ((abs_diff % abs_inc) != 0);\n+  return loop_info->n_iterations;\n }\n \n+\n /* Replace uses of split bivs with their split pseudo register.  This is\n    for original instructions which remain after loop unrolling without\n    copying.  */"}]}