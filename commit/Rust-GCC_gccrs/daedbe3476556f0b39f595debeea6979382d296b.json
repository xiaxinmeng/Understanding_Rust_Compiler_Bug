{"sha": "daedbe3476556f0b39f595debeea6979382d296b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFlZGJlMzQ3NjU1NmYwYjM5ZjU5NWRlYmVlYTY5NzkzODJkMjk2Yg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-09-08T11:43:37Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:20Z"}, "message": "Potential modifications to buffered_queue to move when resizing instead of copying - test if works properly\n\nAdded messages to buffered_queue to debug assertion failure\n\nAttempt to fix the buffered_queue issue\n\nRemoved some debug in buffered_queue", "tree": {"sha": "66fb0606ad0337b4cd7650055b6f69a980d4c40d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66fb0606ad0337b4cd7650055b6f69a980d4c40d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/daedbe3476556f0b39f595debeea6979382d296b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daedbe3476556f0b39f595debeea6979382d296b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daedbe3476556f0b39f595debeea6979382d296b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daedbe3476556f0b39f595debeea6979382d296b/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7"}], "stats": {"total": 175, "additions": 60, "deletions": 115}, "files": [{"sha": "632d5fef56caf0d49ce82e92c5b350b824dd8549", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daedbe3476556f0b39f595debeea6979382d296b/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daedbe3476556f0b39f595debeea6979382d296b/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=daedbe3476556f0b39f595debeea6979382d296b", "patch": "@@ -97,9 +97,10 @@ is_whitespace (char character)\n \n // this compiles fine, so any intellisense saying otherwise is fake news\n Lexer::Lexer (const char *filename, RAIIFile file_input, Linemap *linemap)\n-  : input (std::move (file_input)), current_line (1), current_column (1), line_map (linemap),\n+  : input (std::move (file_input)), current_line (1), current_column (1),\n+    line_map (linemap),\n     /*input_source (input.get_raw ()), */\n-    input_queue {InputSource (input.get_raw ())},\n+    input_queue{InputSource (input.get_raw ())},\n     /*token_source (this),*/\n     token_queue (TokenSource (this))\n {\n@@ -160,13 +161,14 @@ Lexer::replace_current_token (TokenPtr replacement)\n {\n   token_queue.replace_current_value (replacement);\n \n-  fprintf(stderr, \"called 'replace_current_token' - this is deprecated\");\n+  fprintf (stderr, \"called 'replace_current_token' - this is deprecated\");\n }\n \n /* shitty anonymous namespace that can only be accessed inside the compilation\n- * unit - used for classify_keyword Binary search in sorted array of keywords\n+ * unit - used for classify_keyword binary search in sorted array of keywords\n  * created with x-macros. */\n namespace {\n+// TODO: make constexpr when update to c++20\n const std::string keyword_index[] = {\n #define RS_TOKEN(x, y)\n #define RS_TOKEN_KEYWORD(name, keyword) keyword,\n@@ -175,15 +177,15 @@ const std::string keyword_index[] = {\n #undef RS_TOKEN\n };\n \n-TokenId keyword_keys[] = {\n+constexpr TokenId keyword_keys[] = {\n #define RS_TOKEN(x, y)\n #define RS_TOKEN_KEYWORD(name, keyword) name,\n   RS_TOKEN_LIST\n #undef RS_TOKEN_KEYWORD\n #undef RS_TOKEN\n };\n \n-const int num_keywords = sizeof (keyword_index) / sizeof (*keyword_index);\n+constexpr int num_keywords = sizeof (keyword_index) / sizeof (*keyword_index);\n } // namespace\n \n /* Determines whether the string passed in is a keyword or not. If it is, it\n@@ -1988,7 +1990,7 @@ Lexer::parse_char_or_lifetime (Location loc)\n \t{\n \t  rust_error_at (get_current_location (),\n \t\t\t \"expected ' after character constant in char literal\");\n-    return nullptr;\n+\t  return nullptr;\n \t}\n     }\n }\n@@ -2296,10 +2298,12 @@ Lexer::test_peek_codepoint_input (int n)\n \t  }*/\n }\n \n-void \n-Lexer::split_current_token (TokenId new_left, TokenId new_right) {\n-  // TODO: assert that this TokenId is a \"simple token\" like punctuation and not like \"IDENTIFIER\"?\n-  Location current_loc = peek_token ()->get_locus();\n+void\n+Lexer::split_current_token (TokenId new_left, TokenId new_right)\n+{\n+  // TODO: assert that this TokenId is a \"simple token\" like punctuation and not\n+  // like \"IDENTIFIER\"?\n+  Location current_loc = peek_token ()->get_locus ();\n   TokenPtr new_left_tok = Token::make (new_left, current_loc);\n   TokenPtr new_right_tok = Token::make (new_right, current_loc + 1);\n "}, {"sha": "ae002c07c5e656b82b88d101e98a74c6b2c6594b", "filename": "gcc/rust/rust-buffered-queue.h", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daedbe3476556f0b39f595debeea6979382d296b/gcc%2Frust%2Frust-buffered-queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daedbe3476556f0b39f595debeea6979382d296b/gcc%2Frust%2Frust-buffered-queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-buffered-queue.h?ref=daedbe3476556f0b39f595debeea6979382d296b", "patch": "@@ -2,10 +2,9 @@\n #define RUST_BUFFERED_QUEUE_H\n \n #include <vector>\n+#include <utility>\n \n-#include \"config.h\"\n-#include \"system.h\"\n-// order: config, system\n+#include \"rust-system.h\"\n \n namespace Rust {\n /* Buffered queue implementation. Items are of type T, queue source is of type\n@@ -32,7 +31,7 @@ template <typename T, typename Source> class buffered_queue\n   T peek (int n)\n   {\n     // n should not be behind\n-    gcc_assert (n >= 0);\n+    rust_assert (n >= 0);\n \n     int num_queued_items = end - start;\n     int num_items_required = n + 1;\n@@ -50,20 +49,39 @@ template <typename T, typename Source> class buffered_queue\n \t    int new_size = (buffer.size () + num_items_to_read);\n \t    new_size += (new_size >> 1);\n \n-\t    // create new queue buffer with new size\n-\t    std::vector<T> new_queue (new_size);\n-\t    std::copy (buffer.begin () + start, buffer.begin () + end,\n-\t\t       new_queue.begin ());\n+\t    // old method:\n+\t    /*\n+\t\t  // create new queue buffer with new size\n+\t\t  std::vector<T> new_queue (new_size);\n+\t\t  std::copy (buffer.begin () + start, buffer.begin () + end,\n+\t\t\t     new_queue.begin ());\n+\t\t  start = 0;\n+\t\t  end = num_queued_items;\n+\t\t  // TODO: would move be better here? optimisation for move with\n+\t\t  // shared pointer?\n+\n+\t\t  // swap member buffer and new queue buffer\n+\t\t  std::swap (buffer, new_queue);\n+\t    */\n+\n+\t    // TODO: determine overhead of this approach vs copy. Should be lower.\n+\t    std::vector<T> new_queue;\n+\t    new_queue.reserve (new_size);\n+\t    new_queue.insert (new_queue.begin (),\n+\t\t\t      std::make_move_iterator (buffer.begin () + start),\n+\t\t\t      std::make_move_iterator (buffer.begin () + end));\n \t    start = 0;\n \t    end = num_queued_items;\n-\t    // TODO: would move be better here? optimisation for move with\n-\t    // shared pointer?\n+      // fill up rest of vector with junk so that indexing can work\n+      new_queue.insert (new_queue.begin () + end, new_size - new_queue.size(), T ());\n \n-\t    // swap member buffer and new queue buffer\n-\t    std::swap (buffer, new_queue);\n+\t    buffer = std::move (new_queue);\n+\t    /* this should be best method - std::move(range) would have\n+\t     * allocation problems; initial construction would require\n+\t     * reallocation upon resizing */\n \n \t    // validate that buffer is large enough now\n-\t    gcc_assert (end + num_queued_items < (int) buffer.size ());\n+\t    rust_assert (end + num_queued_items < (int) buffer.size ());\n \t  }\n \n \t/* iterate through buffer and invoke operator () on source on values\n@@ -75,11 +93,11 @@ template <typename T, typename Source> class buffered_queue\n \tend += num_items_to_read;\n       }\n \n-    gcc_assert (0 <= start);\n-    gcc_assert (start <= end);\n-    gcc_assert (end <= (int) buffer.size ());\n+    rust_assert (0 <= start);\n+    rust_assert (start <= end);\n+    rust_assert (end <= (int) buffer.size ());\n \n-    gcc_assert (start + n < end);\n+    rust_assert (start + n < end);\n \n     // return value at start + n in buffer\n     return buffer[start + n];\n@@ -96,14 +114,14 @@ template <typename T, typename Source> class buffered_queue\n \n     // Clear queue values from start to n (inclusive).\n     for (int i = 0; i < (n + 1); i++)\n-\tbuffer[start + i] = T ();\n+      buffer[start + i] = T ();\n \n     // Move start forward by n + 1.\n     start += (n + 1);\n \n     // Ensure start is not impossible somehow\n-    gcc_assert (0 <= start);\n-    gcc_assert (start <= end);\n+    rust_assert (0 <= start);\n+    rust_assert (start <= end);\n \n     // Compact buffer if empty\n     if (start == end)\n@@ -125,12 +143,12 @@ template <typename T, typename Source> class buffered_queue\n   }\n \n   // Insert at arbitrary position (attempt)\n-  void insert (int index, T elem_to_insert) \n+  void insert (int index, T elem_to_insert)\n   {\n     // TODO: test as this may not work properly\n \n     // n should not be behind\n-    gcc_assert (index >= 0);\n+    rust_assert (index >= 0);\n \n     // call peek to ensure that the items behind this (at least) are in queue\n     if (index >= 1)"}, {"sha": "a711fdc82f03f98f9eae965bc8432ff0f94fe616", "filename": "gcc/rust/rust-system.h", "status": "modified", "additions": 5, "deletions": 82, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daedbe3476556f0b39f595debeea6979382d296b/gcc%2Frust%2Frust-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daedbe3476556f0b39f595debeea6979382d296b/gcc%2Frust%2Frust-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-system.h?ref=daedbe3476556f0b39f595debeea6979382d296b", "patch": "@@ -41,91 +41,14 @@\n #include <deque>\n #include <functional>\n \n-/* TODO: strictly speaking, as AST move semantics make frontend C++11-and-up\n- * only, unordered map should always be definable (i.e. don't have to resort to\n- * tr1 like in C++03), so don't need to have this macro switch - just include\n- * <unordered_map> and <unordered_set>. */\n-#if defined(HAVE_UNORDERED_MAP)\n-\n+// Rust frontend requires C++11 minimum, so will have unordered_map and set\n #include <unordered_map>\n #include <unordered_set>\n \n-#define Unordered_map(KEYTYPE, VALTYPE) std::unordered_map<KEYTYPE, VALTYPE>\n-\n-#define Unordered_map_hash(KEYTYPE, VALTYPE, HASHFN, EQFN)                     \\\n-  std::unordered_map<KEYTYPE, VALTYPE, HASHFN, EQFN>\n-\n-#define Unordered_set(KEYTYPE) std::unordered_set<KEYTYPE>\n-\n-#define Unordered_set_hash(KEYTYPE, HASHFN, EQFN)                              \\\n-  std::unordered_set<KEYTYPE, HASHFN, EQFN>\n-\n-#elif defined(HAVE_TR1_UNORDERED_MAP)\n-\n-#include <tr1/unordered_map>\n-#include <tr1/unordered_set>\n-\n-#define Unordered_map(KEYTYPE, VALTYPE)                                        \\\n-  std::tr1::unordered_map<KEYTYPE, VALTYPE>\n-\n-#define Unordered_map_hash(KEYTYPE, VALTYPE, HASHFN, EQFN)                     \\\n-  std::tr1::unordered_map<KEYTYPE, VALTYPE, HASHFN, EQFN>\n-\n-#define Unordered_set(KEYTYPE) std::tr1::unordered_set<KEYTYPE>\n-\n-#define Unordered_set_hash(KEYTYPE, HASHFN, EQFN)                              \\\n-  std::tr1::unordered_set<KEYTYPE, HASHFN, EQFN>\n-\n-#elif defined(HAVE_EXT_HASH_MAP)\n-\n-#include <ext/hash_map>\n-#include <ext/hash_set>\n-\n-#define Unordered_map(KEYTYPE, VALTYPE) __gnu_cxx::hash_map<KEYTYPE, VALTYPE>\n-\n-#define Unordered_map_hash(KEYTYPE, VALTYPE, HASHFN, EQFN)                     \\\n-  __gnu_cxx::hash_map<KEYTYPE, VALTYPE, HASHFN, EQFN>\n-\n-#define Unordered_set(KEYTYPE) __gnu_cxx::hash_set<KEYTYPE>\n-\n-#define Unordered_set_hash(KEYTYPE, HASHFN, EQFN)                              \\\n-  __gnu_cxx::hash_set<KEYTYPE, HASHFN, EQFN>\n-\n-// Provide hash functions for strings and pointers.\n-\n-namespace __gnu_cxx {\n-\n-template <> struct hash<std::string>\n-{\n-  size_t operator() (std::string s) const\n-  {\n-    return __stl_hash_string (s.c_str ());\n-  }\n-};\n-\n-template <typename T> struct hash<T *>\n-{\n-  size_t operator() (T *p) const { return reinterpret_cast<size_t> (p); }\n-};\n-\n-} // namespace __gnu_cxx\n-\n-#else\n-\n-#define Unordered_map(KEYTYPE, VALTYPE) std::map<KEYTYPE, VALTYPE>\n-\n-#define Unordered_set(KEYTYPE) std::set<KEYTYPE>\n-\n-// We could make this work by writing an adapter class which\n-// implemented operator< in terms of the hash function.\n-#error \"requires hash table type\"\n-\n-#endif\n-\n-// We don't really need iostream, but some versions of gmp.h include\n-// it when compiled with C++, which means that we need to include it\n-// before the macro magic of safe-ctype.h, which is included by\n-// system.h.\n+/* We don't really need iostream, but some versions of gmp.h include\n+ * it when compiled with C++, which means that we need to include it\n+ * before the macro magic of safe-ctype.h, which is included by\n+ * system.h. */\n #include <iostream>\n \n #include \"system.h\""}]}