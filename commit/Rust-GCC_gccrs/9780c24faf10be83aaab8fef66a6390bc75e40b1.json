{"sha": "9780c24faf10be83aaab8fef66a6390bc75e40b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc4MGMyNGZhZjEwYmU4M2FhYWI4ZmVmNjZhNjM5MGJjNzVlNDBiMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-02-04T08:55:43Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-02-04T08:55:43Z"}, "message": "xref.c: Remove.\n\n        * xref.c: Remove.\n        * Make-lang.in (CXX_OBJS): Remove cp/xref.o\n        (cp/xref.o): Remove dependencies.\n        * class.c (finish_struct_1, check_methods): Don't call xref fns.\n        (finish_struct_1): Likewise.\n        * friend.c (make_friend_class): Likewise.\n        * lex.c (cxx_init, cxx_finish, extract_interface_info): Likewise.\n        * spew.c (read_process_identifier): Likewise.\n\nFrom-SVN: r49472", "tree": {"sha": "5e3b6ed2d6d74714731b9f2986290a2932ca24e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e3b6ed2d6d74714731b9f2986290a2932ca24e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9780c24faf10be83aaab8fef66a6390bc75e40b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9780c24faf10be83aaab8fef66a6390bc75e40b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9780c24faf10be83aaab8fef66a6390bc75e40b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9780c24faf10be83aaab8fef66a6390bc75e40b1/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fecaac3765895574348015a1794de65c2e2a64c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fecaac3765895574348015a1794de65c2e2a64c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fecaac3765895574348015a1794de65c2e2a64c6"}], "stats": {"total": 923, "additions": 15, "deletions": 908}, "files": [{"sha": "6787e883553e6aa8c54954a49bc3ab8a427686e3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9780c24faf10be83aaab8fef66a6390bc75e40b1", "patch": "@@ -1,3 +1,14 @@\n+2002-02-03  Jason Merrill  <jason@redhat.com>\n+\n+\t* xref.c: Remove.\n+\t* Make-lang.in (CXX_OBJS): Remove cp/xref.o\n+\t(cp/xref.o): Remove dependencies.\n+\t* class.c (finish_struct_1, check_methods): Don't call xref fns.\n+\t(finish_struct_1): Likewise.\n+\t* friend.c (make_friend_class): Likewise.\n+\t* lex.c (cxx_init, cxx_finish, extract_interface_info): Likewise.\n+\t* spew.c (read_process_identifier): Likewise.\n+\n 2002-02-01  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/4872"}, {"sha": "6123612a35826e7969364e4ae004a228c79176ae", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=9780c24faf10be83aaab8fef66a6390bc75e40b1", "patch": "@@ -102,7 +102,7 @@ CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n CXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\\n  cp/class.o cp/decl2.o cp/error.o cp/lex.o cp/parse.o cp/ptree.o cp/rtti.o \\\n  cp/spew.o cp/typeck.o cp/cvt.o cp/except.o cp/friend.o cp/init.o cp/method.o \\\n- cp/search.o cp/semantics.o cp/tree.o cp/xref.o cp/repo.o cp/dump.o \\\n+ cp/search.o cp/semantics.o cp/tree.o cp/repo.o cp/dump.o \\\n  cp/optimize.o cp/mangle.o cp/cp-lang.o\n \n # Use loose warnings for this front end.\n@@ -280,7 +280,6 @@ cp/except.o: cp/except.c $(CXX_TREE_H) flags.h $(RTL_H) except.h toplev.h \\\n   cp/cfns.h $(EXPR_H) libfuncs.h cp/decl.h $(OBSTACK_H)\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(RTL_H) flags.h $(EXPR_H) toplev.h \\\n   except.h $(TM_P_H)\n-cp/xref.o: cp/xref.c $(CXX_TREE_H) input.h toplev.h\n cp/pt.o: cp/pt.c $(CXX_TREE_H) cp/decl.h cp/parse.h cp/lex.h toplev.h \\\n   $(GGC_H) $(RTL_H) except.h tree-inline.h\n cp/error.o: cp/error.c $(CXX_TREE_H) toplev.h diagnostic.h flags.h real.h"}, {"sha": "1e62c5928173693e0c843ad98985391f2e375358", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9780c24faf10be83aaab8fef66a6390bc75e40b1", "patch": "@@ -3284,8 +3284,6 @@ check_field_decls (t, access_decls, empty_p,\n       tree x = *field;\n       tree type = TREE_TYPE (x);\n \n-      GNU_xref_member (current_class_name, x);\n-\n       next = &TREE_CHAIN (x);\n \n       if (TREE_CODE (x) == FIELD_DECL)\n@@ -3925,8 +3923,6 @@ check_methods (t)\n \n   for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n     {\n-      GNU_xref_member (current_class_name, x);\n-\n       /* If this was an evil function, don't keep it in class.  */\n       if (DECL_ASSEMBLER_NAME_SET_P (x) \n \t  && IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (x)))\n@@ -5049,8 +5045,6 @@ finish_struct_1 (t)\n       return;\n     }\n \n-  GNU_xref_decl (current_function_decl, t);\n-\n   /* If this type was previously laid out as a forward reference,\n      make sure we lay it out again.  */\n   TYPE_SIZE (t) = NULL_TREE;"}, {"sha": "8b242e5072411b1b78b8b3b79ee575e650e89c3e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9780c24faf10be83aaab8fef66a6390bc75e40b1", "patch": "@@ -932,10 +932,6 @@ extern int flag_no_gnu_keywords;\n \n extern int flag_operator_names;\n \n-/* For cross referencing.  */\n-\n-extern int flag_gnu_xref;\n-\n /* For environments where you can use GNU binutils (as, ld in particular).  */\n \n extern int flag_gnu_binutils;\n@@ -4370,20 +4366,6 @@ extern void check_for_new_type\t\t\tPARAMS ((const char *, flagged_type_tree));\n extern tree add_exception_specifier             PARAMS ((tree, tree, int));\n extern tree merge_exception_specifiers          PARAMS ((tree, tree));\n \n-/* in xref.c */\n-extern void GNU_xref_begin\t\t\tPARAMS ((const char *));\n-extern void GNU_xref_end\t\t\tPARAMS ((int));\n-extern void GNU_xref_file\t\t\tPARAMS ((const char *));\n-extern void GNU_xref_start_scope\t\tPARAMS ((HOST_WIDE_INT));\n-extern void GNU_xref_end_scope\t\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT, int, int));\n-extern void GNU_xref_ref\t\t\tPARAMS ((tree, const char *));\n-extern void GNU_xref_decl\t\t\tPARAMS ((tree, tree));\n-extern void GNU_xref_call\t\t\tPARAMS ((tree, const char *));\n-extern void GNU_xref_function\t\t\tPARAMS ((tree, tree));\n-extern void GNU_xref_assign\t\t\tPARAMS ((tree));\n-extern void GNU_xref_hier\t\t\tPARAMS ((tree, tree, int, int, int));\n-extern void GNU_xref_member\t\t\tPARAMS ((tree, tree));\n-\n /* in mangle.c */\n extern void init_mangle                         PARAMS ((void));\n extern void mangle_decl                         PARAMS ((tree));"}, {"sha": "49099855196cdf531e330718ab291b141a08259d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9780c24faf10be83aaab8fef66a6390bc75e40b1", "patch": "@@ -842,7 +842,6 @@ pushlevel (tag_transparent)\n     newlevel = make_binding_level ();\n \n   push_binding_level (newlevel, tag_transparent, keep_next_level_flag);\n-  GNU_xref_start_scope ((size_t) newlevel);\n   keep_next_level_flag = 0;\n }\n \n@@ -1301,11 +1300,6 @@ poplevel (keep, reverse, functionbody)\n      rather than the end.  This hack is no longer used.  */\n   my_friendly_assert (keep == 0 || keep == 1, 0);\n \n-  GNU_xref_end_scope ((size_t) current_binding_level,\n-\t\t      (size_t) current_binding_level->level_chain,\n-\t\t      current_binding_level->parm_flag,\n-\t\t      current_binding_level->keep);\n-\n   if (current_binding_level->keep == 1)\n     keep = 1;\n \n@@ -1727,11 +1721,6 @@ poplevel_class ()\n        shadowed = TREE_CHAIN (shadowed))\n     pop_binding (TREE_PURPOSE (shadowed), TREE_TYPE (shadowed));\n \n-  GNU_xref_end_scope ((size_t) class_binding_level,\n-\t\t      (size_t) class_binding_level->level_chain,\n-\t\t      class_binding_level->parm_flag,\n-\t\t      class_binding_level->keep);\n-\n   /* Now, pop out of the binding level which we created up in the\n      `pushlevel_class' routine.  */\n #if defined(DEBUG_CP_BINDING_LEVELS)\n@@ -8130,7 +8119,6 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \t  set_identifier_type_value (DECL_NAME (decl), type);\n \t  CLASSTYPE_GOT_SEMICOLON (type) = 1;\n \t}\n-      GNU_xref_decl (current_function_decl, decl);\n \n       /* If we have installed this as the canonical typedef for this\n \t type, and that type has not been defined yet, delay emitting\n@@ -8171,8 +8159,6 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n   init = check_initializer (decl, init);\n   maybe_deduce_size_from_array_init (decl, init);\n \n-  GNU_xref_decl (current_function_decl, decl);\n-\n   /* Add this declaration to the statement-tree.  This needs to happen\n      after the call to check_initializer so that the DECL_STMT for a\n      reference temp is added before the DECL_STMT for the reference itself.  */\n@@ -12914,7 +12900,8 @@ xref_tag_from_type (old, id, globalize)\n void\n xref_basetypes (code_type_node, name, ref, binfo)\n      tree code_type_node;\n-     tree name, ref;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree ref;\n      tree binfo;\n {\n   /* In the declaration `A : X, Y, ... Z' we mark all the types\n@@ -12985,8 +12972,6 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t  continue;\n \t}\n \n-      GNU_xref_hier (name, basetype, via_public, via_virtual, 0);\n-\n       /* This code replaces similar code in layout_basetypes.\n          We put the complete_type first for implicit `typename'.  */\n       if (!COMPLETE_TYPE_P (basetype)\n@@ -13127,7 +13112,6 @@ start_enum (name)\n   if (current_class_type)\n     TREE_ADDRESSABLE (b->tags) = 1;\n \n-  GNU_xref_decl (current_function_decl, enumtype);\n   return enumtype;\n }\n \n@@ -13373,10 +13357,7 @@ build_enumerator (name, value, enumtype)\n       things like `S::i' later.)  */\n     finish_member_declaration (decl);\n   else\n-    {\n-      pushdecl (decl);\n-      GNU_xref_decl (current_function_decl, decl);\n-    }\n+    pushdecl (decl);\n \n   /* Add this enumeration constant to the list for this type.  */\n   TYPE_VALUES (enumtype) = tree_cons (name, decl, TYPE_VALUES (enumtype));\n@@ -14419,11 +14400,6 @@ finish_method (decl)\n       DECL_CONTEXT (link) = NULL_TREE;\n     }\n \n-  GNU_xref_end_scope ((size_t) current_binding_level,\n-\t\t      (size_t) current_binding_level->level_chain,\n-\t\t      current_binding_level->parm_flag,\n-\t\t      current_binding_level->keep);\n-\n   poplevel (0, 0, 0);\n \n   DECL_INITIAL (fndecl) = old_initial;"}, {"sha": "7a9a21edf083b5be79eb1a87df63c9d9625bfc2b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9780c24faf10be83aaab8fef66a6390bc75e40b1", "patch": "@@ -1702,8 +1702,6 @@ grokbitfield (declarator, declspecs, width)\n       return void_type_node;\n     }\n \n-  GNU_xref_member (current_class_name, value);\n-\n   if (TREE_STATIC (value))\n     {\n       error (\"static member `%D' cannot be a bit-field\", value);"}, {"sha": "441be67cfb086a550aa92a88fc32359b6df16c1c", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=9780c24faf10be83aaab8fef66a6390bc75e40b1", "patch": "@@ -252,8 +252,6 @@ make_friend_class (type, friend_type)\n       return;\n     }\n \n-  GNU_xref_hier (type, friend_type, 0, 0, 1);\n-\n   if (is_template_friend)\n     friend_type = CLASSTYPE_TI_TEMPLATE (friend_type);\n "}, {"sha": "885002a97934f0f74ef4f0ccc5256a822571fd8d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=9780c24faf10be83aaab8fef66a6390bc75e40b1", "patch": "@@ -263,8 +263,6 @@ cxx_init_options ()\n void\n cxx_finish ()\n {\n-  if (flag_gnu_xref)\n-    GNU_xref_end (errorcount + sorrycount);\n   c_common_finish ();\n }\n \n@@ -733,8 +731,6 @@ cxx_init (filename)\n \n   init_cp_pragma ();\n \n-  if (flag_gnu_xref)\n-    GNU_xref_begin (filename);\n   init_repo (filename);\n \n   return filename;\n@@ -931,9 +927,6 @@ extract_interface_info ()\n \n   interface_only = finfo->interface_only;\n   interface_unknown = finfo->interface_unknown;\n-\n-  /* This happens to be a convenient place to put this.  */\n-  if (flag_gnu_xref) GNU_xref_file (input_filename);\n }\n \n /* Return nonzero if S is not considered part of an"}, {"sha": "7ac47a18b90f68b8394e63dc7398bd4257861b4e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9780c24faf10be83aaab8fef66a6390bc75e40b1", "patch": "@@ -2526,10 +2526,6 @@ genrtl_start_function (fn)\n       DECL_SAVED_FUNCTION_DATA (fn) = NULL;\n     }\n \n-  /* Tell the cross-reference machinery that we're defining this\n-     function.  */\n-  GNU_xref_function (fn, DECL_ARGUMENTS (fn));\n-\n   /* Keep track of how many functions we're presently expanding.  */\n   ++function_depth;\n "}, {"sha": "212dada088c2c2254a5c48639c47723b64333bd3", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=9780c24faf10be83aaab8fef66a6390bc75e40b1", "patch": "@@ -221,16 +221,11 @@ read_process_identifier (pyylval)\n \tcase RID_NOT_EQ: pyylval->code = NE_EXPR;\treturn EQCOMPARE;\n \n \tdefault:\n-\t  if (C_RID_YYCODE (id) == TYPESPEC)\n-\t    GNU_xref_ref (current_function_decl, IDENTIFIER_POINTER (id));\n-\n \t  pyylval->ttype = ridpointers[C_RID_CODE (id)];\n \t  return C_RID_YYCODE (id);\n \t}\n     }\n \n-  GNU_xref_ref (current_function_decl, IDENTIFIER_POINTER (id));\n-\n   /* Make sure that user does not collide with our internal naming\n      scheme.  This is not necessary if '.' is used to remove them from\n      the user's namespace, but is if '$' or double underscores are.  */"}, {"sha": "4cc576b75795ce722ee001e4299726cb56ded8b7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9780c24faf10be83aaab8fef66a6390bc75e40b1/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9780c24faf10be83aaab8fef66a6390bc75e40b1", "patch": "@@ -3013,10 +3013,6 @@ build_function_call_real (function, params, require_complete, flags)\n       name = DECL_NAME (function);\n       assembler_name = DECL_ASSEMBLER_NAME (function);\n \n-      GNU_xref_call (current_function_decl,\n-\t\t     IDENTIFIER_POINTER (name ? name\n-\t\t\t\t\t : TYPE_IDENTIFIER (DECL_CLASS_CONTEXT\n-\t\t\t\t\t\t\t    (function))));\n       mark_used (function);\n       fndecl = function;\n \n@@ -5748,8 +5744,6 @@ build_modify_expr (lhs, modifycode, rhs)\n   if (!lvalue_or_else (lhs, \"assignment\"))\n     return error_mark_node;\n \n-  GNU_xref_assign (lhs);\n-\n   /* Warn about modifying something that is `const'.  Don't warn if\n      this is initialization.  */\n   if (modifycode != INIT_EXPR"}, {"sha": "4560c4a2c6f38040ea6b6fe06d56c04269796720", "filename": "gcc/cp/xref.c", "status": "removed", "additions": 0, "deletions": 829, "changes": 829, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecaac3765895574348015a1794de65c2e2a64c6/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecaac3765895574348015a1794de65c2e2a64c6/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=fecaac3765895574348015a1794de65c2e2a64c6", "patch": "@@ -1,829 +0,0 @@\n-/* Code for handling XREF output from GNU C++.\n-   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   2000, 2002 Free Software Foundation, Inc.\n-   Contributed by Michael Tiemann (tiemann@cygnus.com)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"tree.h\"\n-#include \"cp-tree.h\"\n-#include \"input.h\"\n-#include \"toplev.h\"\n-\n-/* The character(s) used to join a directory specification (obtained with\n-   getwd or equivalent) with a non-absolute file name.  */\n-\n-#ifndef FILE_NAME_JOINER\n-#define FILE_NAME_JOINER \"/\"\n-#endif\n-\n-/* Nonzero if NAME as a file name is absolute.  */\n-#ifndef FILE_NAME_ABSOLUTE_P\n-#define FILE_NAME_ABSOLUTE_P(NAME) ((NAME)[0] == '/')\n-#endif\n-\n-/* For cross referencing.  */\n-\n-int flag_gnu_xref;\n-\n-/************************************************************************/\n-/*\t\t\t\t\t\t\t\t\t*/\n-/*\tCommon definitions\t\t\t\t\t\t*/\n-/*\t\t\t\t\t\t\t\t\t*/\n-/************************************************************************/\n-\n-#ifndef TRUE\n-#define TRUE 1\n-#endif\n-#ifndef FALSE\n-#define FALSE 0\n-#endif\n-\n-#define PALLOC(TYP) ((TYP *) xcalloc (1, sizeof (TYP)))\n-\n-\n-/* Return a malloc'd copy of STR.  */\n-#define SALLOC(STR) ((char *) ((STR) == NULL ? NULL : xstrdup (STR)))\n-#define SFREE(STR) ((STR) != NULL && (free (STR), 0))\n-\n-#define STREQL(S1,S2) (strcmp ((S1), (S2)) == 0)\n-#define STRNEQ(S1,S2) (strcmp ((S1), (S2)) != 0)\n-#define STRLSS(S1,S2) (strcmp ((S1), (S2)) < 0)\n-#define STRLEQ(S1,S2) (strcmp ((S1), (S2)) <= 0)\n-#define STRGTR(S1,S2) (strcmp ((S1), (S2)) > 0)\n-#define STRGEQ(S1,S2) (strcmp ((S1), (S2)) >= 0)\n-\n-/************************************************************************/\n-/*\t\t\t\t\t\t\t\t\t*/\n-/*\tType definitions\t\t\t\t\t\t*/\n-/*\t\t\t\t\t\t\t\t\t*/\n-/************************************************************************/\n-\n-\n-typedef struct _XREF_FILE *\tXREF_FILE;\n-typedef struct _XREF_SCOPE *\tXREF_SCOPE;\n-\n-typedef struct _XREF_FILE\n-{\n-  const char *name;\n-  const char *outname;\n-  XREF_FILE next;\n-} XREF_FILE_INFO;\n-\n-typedef struct _XREF_SCOPE\n-{\n-  int gid;\n-  int lid;\n-  XREF_FILE file;\n-  int start;\n-  XREF_SCOPE outer;\n-} XREF_SCOPE_INFO;\n-\n-/************************************************************************/\n-/*\t\t\t\t\t\t\t\t\t*/\n-/*\tLocal storage\t\t\t\t\t\t\t*/\n-/*\t\t\t\t\t\t\t\t\t*/\n-/************************************************************************/\n-\n-static\tchar\t\tdoing_xref = 0;\n-static\tFILE *\t\txref_file = NULL;\n-static\tchar\t\txref_name[1024];\n-static\tXREF_FILE\tall_files = NULL;\n-static\tchar *\t\twd_name = NULL;\n-static\tXREF_SCOPE\tcur_scope = NULL;\n-static\tint \tscope_ctr = 0;\n-static\tXREF_FILE\tlast_file = NULL;\n-static\ttree\t\tlast_fndecl = NULL;\n-\n-/************************************************************************/\n-/*\t\t\t\t\t\t\t\t\t*/\n-/*\tForward definitions\t\t\t\t\t\t*/\n-/*\t\t\t\t\t\t\t\t\t*/\n-/************************************************************************/\n-static\tvoid\t\tgen_assign PARAMS ((XREF_FILE, tree));\n-static\tXREF_FILE\tfind_file PARAMS ((const char *));\n-static\tconst char *\tfilename PARAMS ((XREF_FILE));\n-static\tconst char *\tfctname PARAMS ((tree));\n-static\tconst char *\tdeclname PARAMS ((tree));\n-static\tvoid\t\tsimplify_type PARAMS ((char *));\n-static\tconst char *\tfixname PARAMS ((const char *, char *));\n-static\tvoid\t\topen_xref_file PARAMS ((const char *));\n-static  const char *\tclassname PARAMS ((tree));\n-\n-/* Start cross referencing.  FILE is the name of the file we xref.  */\n-\n-void\n-GNU_xref_begin (file)\n-   const char *file;\n-{\n-  doing_xref = 1;\n-\n-  if (file != NULL && STRNEQ (file,\"-\"))\n-    {\n-      open_xref_file(file);\n-      GNU_xref_file(file);\n-    }\n-}\n-\n-/* Finish cross-referencing.  ERRCNT is the number of errors\n-   we encountered.  */\n-\n-void\n-GNU_xref_end (ect)\n-   int ect;\n-{\n-  XREF_FILE xf;\n-\n-  if (!doing_xref) return;\n-\n-  xf = find_file (input_filename);\n-  if (xf == NULL) return;\n-\n-  while (cur_scope != NULL)\n-    GNU_xref_end_scope(cur_scope->gid,0,0,0);\n-\n-  doing_xref = 0;\n-\n-  if (xref_file == NULL) return;\n-\n-  fclose (xref_file);\n-\n-  xref_file = NULL;\n-  all_files = NULL;\n-\n-  if (ect > 0) unlink (xref_name);\n-}\n-\n-/* Write out xref for file named NAME.  */\n-\n-void\n-GNU_xref_file (name)\n-   const char *name;\n-{\n-  XREF_FILE xf;\n-\n-  if (!doing_xref || name == NULL) return;\n-\n-  if (xref_file == NULL)\n-    {\n-      open_xref_file (name);\n-      if (!doing_xref) return;\n-    }\n-\n-  if (all_files == NULL)\n-    fprintf(xref_file,\"SCP * 0 0 0 0 RESET\\n\");\n-\n-  xf = find_file (name);\n-  if (xf != NULL) return;\n-\n-  xf = PALLOC (XREF_FILE_INFO);\n-  xf->name = SALLOC (name);\n-  xf->next = all_files;\n-  all_files = xf;\n-\n-  if (wd_name == NULL)\n-    wd_name = getpwd ();\n-\n-  if (FILE_NAME_ABSOLUTE_P (name) || ! wd_name)\n-    xf->outname = xf->name;\n-  else\n-    xf->outname = name = concat (wd_name, FILE_NAME_JOINER, name, NULL);\n-\n-  fprintf (xref_file, \"FIL %s %s 0\\n\", name, wd_name);\n-\n-  filename (xf);\n-  fctname (NULL);\n-}\n-\n-/* Start a scope identified at level ID.  */\n-\n-void\n-GNU_xref_start_scope (id)\n-   HOST_WIDE_INT id;\n-{\n-  XREF_SCOPE xs;\n-  XREF_FILE xf;\n-\n-  if (!doing_xref) return;\n-  xf = find_file (input_filename);\n-\n-  xs = PALLOC (XREF_SCOPE_INFO);\n-  xs->file = xf;\n-  xs->start = lineno;\n-  if (xs->start <= 0) xs->start = 1;\n-  xs->gid = id;\n-  xs->lid = ++scope_ctr;\n-  xs->outer = cur_scope;\n-  cur_scope = xs;\n-}\n-\n-/* Finish a scope at level ID.\n-   INID is ???\n-   PRM is ???\n-   KEEP is nonzero iff this scope is retained (nonzero if it's\n-   a compiler-generated invisible scope).\n-   TRNS is ???  */\n-\n-void\n-GNU_xref_end_scope (id,inid,prm,keep)\n-   HOST_WIDE_INT id;\n-   HOST_WIDE_INT inid;\n-   int prm,keep;\n-{\n-  XREF_FILE xf;\n-  XREF_SCOPE xs,lxs,oxs;\n-  const char *stype;\n-\n-  if (!doing_xref) return;\n-  xf = find_file (input_filename);\n-  if (xf == NULL) return;\n-\n-  lxs = NULL;\n-  for (xs = cur_scope; xs != NULL; xs = xs->outer)\n-    {\n-      if (xs->gid == id) break;\n-      lxs = xs;\n-    }\n-  if (xs == NULL) return;\n-\n-  if (inid != 0) {\n-    for (oxs = cur_scope; oxs != NULL; oxs = oxs->outer) {\n-      if (oxs->gid == inid) break;\n-    }\n-    if (oxs == NULL) return;\n-    inid = oxs->lid;\n-  }\n-\n-  if (prm == 2) stype = \"SUE\";\n-  else if (prm != 0) stype = \"ARGS\";\n-  else if (keep == 2 || inid != 0) stype = \"INTERN\";\n-  else stype = \"EXTERN\";\n-\n-  fprintf (xref_file, \"SCP %s %d %d %d \",\n-\t   filename (xf), xs->start, lineno,xs->lid);\n-  fprintf (xref_file, HOST_WIDE_INT_PRINT_DEC, inid);\n-  fprintf (xref_file, \" %s\\n\", stype);\n-\n-  if (lxs == NULL) cur_scope = xs->outer;\n-  else lxs->outer = xs->outer;\n-\n-  free (xs);\n-}\n-\n-/* Output a reference to NAME in FNDECL.  */\n-\n-void\n-GNU_xref_ref (fndecl,name)\n-   tree fndecl;\n-   const char *name;\n-{\n-  XREF_FILE xf;\n-\n-  if (!doing_xref) return;\n-  xf = find_file (input_filename);\n-  if (xf == NULL) return;\n-\n-  fprintf (xref_file, \"REF %s %d %s %s\\n\",\n-\t   filename (xf), lineno, fctname (fndecl), name);\n-}\n-\n-/* Output a reference to DECL in FNDECL.  */\n-\n-void\n-GNU_xref_decl (fndecl,decl)\n-   tree fndecl;\n-   tree decl;\n-{\n-  XREF_FILE xf,xf1;\n-  const char *cls = 0;\n-  const char *name;\n-  char buf[10240];\n-  int uselin;\n-\n-  if (!doing_xref) return;\n-  xf = find_file (input_filename);\n-  if (xf == NULL) return;\n-\n-  uselin = FALSE;\n-\n-  if (TREE_CODE (decl) == TYPE_DECL) cls = \"TYPEDEF\";\n-  else if (TREE_CODE (decl) == FIELD_DECL) cls = \"FIELD\";\n-  else if (TREE_CODE (decl) == VAR_DECL)\n-    {\n-      if (fndecl == NULL && TREE_STATIC(decl)\n-\t  && TREE_READONLY(decl) && DECL_INITIAL(decl) != 0\n-\t  && !TREE_PUBLIC(decl) && !DECL_EXTERNAL(decl)\n-\t  && DECL_MODE(decl) != BLKmode) cls = \"CONST\";\n-      else if (DECL_EXTERNAL(decl)) cls = \"EXTERN\";\n-      else if (TREE_PUBLIC(decl)) cls = \"EXTDEF\";\n-      else if (TREE_STATIC(decl)) cls = \"STATIC\";\n-      else if (DECL_REGISTER(decl)) cls = \"REGISTER\";\n-      else cls = \"AUTO\";\n-    }\n-  else if (TREE_CODE (decl) == PARM_DECL) cls = \"PARAM\";\n-  else if (TREE_CODE (decl) == FIELD_DECL) cls = \"FIELD\";\n-  else if (TREE_CODE (decl) == CONST_DECL) cls = \"CONST\";\n-  else if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      if (DECL_EXTERNAL (decl)) cls = \"EXTERN\";\n-      else if (TREE_PUBLIC (decl)) cls = \"EFUNCTION\";\n-      else cls = \"SFUNCTION\";\n-    }\n-  else if (TREE_CODE (decl) == LABEL_DECL) cls = \"LABEL\";\n-  else if (TREE_CODE (decl) == UNION_TYPE)\n-    {\n-      cls = \"UNIONID\";\n-      decl = TYPE_NAME (decl);\n-      uselin = TRUE;\n-    }\n-  else if (TREE_CODE (decl) == RECORD_TYPE)\n-    {\n-      if (CLASSTYPE_DECLARED_CLASS (decl)) cls = \"CLASSID\";\n-      else cls = \"STRUCTID\";\n-      decl = TYPE_NAME (decl);\n-      uselin = TRUE;\n-    }\n-  else if (TREE_CODE (decl) == ENUMERAL_TYPE)\n-    {\n-      cls = \"ENUMID\";\n-      decl = TYPE_NAME (decl);\n-      uselin = TRUE;\n-    }\n-  else if (TREE_CODE (decl) == TEMPLATE_DECL)\n-    {\n-      if (TREE_CODE (DECL_RESULT (decl)) == TYPE_DECL)\n-\tcls = \"CLASSTEMP\";\n-      else if (TREE_CODE (DECL_RESULT (decl)) == FUNCTION_DECL)\n-\tcls = \"FUNCTEMP\";\n-      else if (TREE_CODE (DECL_RESULT (decl)) == VAR_DECL)\n-\tcls = \"VARTEMP\";\n-      else\n-\tabort ();\n-      uselin = TRUE;\n-    }\n-  else cls = \"UNKNOWN\";\n-\n-  if (decl == NULL || DECL_NAME (decl) == NULL) return;\n-\n-  if (uselin && decl->decl.linenum > 0 && decl->decl.filename != NULL)\n-    {\n-      xf1 = find_file (decl->decl.filename);\n-      if (xf1 != NULL)\n-\t{\n-\t  lineno = decl->decl.linenum;\n-\t  xf = xf1;\n-\t}\n-    }\n-\n-  if (DECL_ASSEMBLER_NAME (decl))\n-    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-  else\n-    name = IDENTIFIER_POINTER (DECL_NAME (decl));\n-\n-  strcpy (buf, type_as_string (TREE_TYPE (decl), 0));\n-  simplify_type (buf);\n-\n-  fprintf (xref_file, \"DCL %s %d %s %d %s %s %s\\n\",\n-\t   filename(xf), lineno, name,\n-\t   (cur_scope != NULL ? cur_scope->lid : 0),\n-\t   cls, fctname(fndecl), buf);\n-\n-  if (STREQL (cls, \"STRUCTID\") || STREQL (cls, \"UNIONID\"))\n-    {\n-      cls = \"CLASSID\";\n-      fprintf (xref_file, \"DCL %s %d %s %d %s %s %s\\n\",\n-\t       filename(xf), lineno,name,\n-\t       (cur_scope != NULL ? cur_scope->lid : 0),\n-\t       cls, fctname(fndecl), buf);\n-    }\n-}\n-\n-/* Output a reference to a call to NAME in FNDECL.  */\n-\n-void\n-GNU_xref_call (fndecl, name)\n-   tree fndecl;\n-   const char *name;\n-{\n-  XREF_FILE xf;\n-  char buf[1024];\n-  const char *s;\n-\n-  if (!doing_xref) return;\n-  xf = find_file (input_filename);\n-  if (xf == NULL) return;\n-  name = fixname (name, buf);\n-\n-  for (s = name; *s != 0; ++s)\n-    if (*s == '_' && s[1] == '_') break;\n-  if (*s != 0) GNU_xref_ref (fndecl, name);\n-\n-  fprintf (xref_file, \"CAL %s %d %s %s\\n\",\n-\t   filename (xf), lineno, name, fctname (fndecl));\n-}\n-\n-/* Output cross-reference info about FNDECL.  If non-NULL,\n-   ARGS are the arguments for the function (i.e., before the FUNCTION_DECL\n-   has been fully built).  */\n-\n-void\n-GNU_xref_function (fndecl, args)\n-   tree fndecl;\n-   tree args;\n-{\n-  XREF_FILE xf;\n-  int ct;\n-  char buf[1024];\n-\n-  if (!doing_xref) return;\n-  xf = find_file (input_filename);\n-  if (xf == NULL) return;\n-\n-  ct = 0;\n-  buf[0] = 0;\n-  if (args == NULL) args = DECL_ARGUMENTS (fndecl);\n-\n-  GNU_xref_decl (NULL, fndecl);\n-\n-  for ( ; args != NULL; args = TREE_CHAIN (args))\n-    {\n-      GNU_xref_decl (fndecl,args);\n-      if (ct != 0) strcat (buf,\",\");\n-      strcat (buf, declname (args));\n-      ++ct;\n-    }\n-\n-  fprintf (xref_file, \"PRC %s %d %s %d %d %s\\n\",\n-\t   filename(xf), lineno, declname(fndecl),\n-\t   (cur_scope != NULL ? cur_scope->lid : 0),\n-\t   ct, buf);\n-}\n-\n-/* Output cross-reference info about an assignment to NAME.  */\n-\n-void\n-GNU_xref_assign(name)\n-   tree name;\n-{\n-  XREF_FILE xf;\n-\n-  if (!doing_xref) return;\n-  xf = find_file(input_filename);\n-  if (xf == NULL) return;\n-\n-  gen_assign(xf, name);\n-}\n-\n-static void\n-gen_assign(xf, name)\n-   XREF_FILE xf;\n-   tree name;\n-{\n-  const char *s;\n-\n-  s = NULL;\n-\n-  switch (TREE_CODE (name))\n-    {\n-    case IDENTIFIER_NODE :\n-      s = IDENTIFIER_POINTER(name);\n-      break;\n-    case VAR_DECL :\n-      s = declname(name);\n-      break;\n-    case COMPONENT_REF :\n-      gen_assign(xf, TREE_OPERAND(name, 0));\n-      gen_assign(xf, TREE_OPERAND(name, 1));\n-      break;\n-    case INDIRECT_REF :\n-    case OFFSET_REF :\n-    case ARRAY_REF :\n-    case BUFFER_REF :\n-      gen_assign(xf, TREE_OPERAND(name, 0));\n-      break;\n-    case COMPOUND_EXPR :\n-      gen_assign(xf, TREE_OPERAND(name, 1));\n-      break;\n-      default :\n-      break;\n-    }\n-\n-  if (s != NULL)\n-    fprintf(xref_file, \"ASG %s %d %s\\n\", filename(xf), lineno, s);\n-}\n-\n-static const char *\n-classname (cls)\n-     tree cls;\n-{\n-  if (cls && TYPE_P (cls))\n-    cls = TYPE_NAME (cls);\n-  if (cls && DECL_P (cls))\n-    cls = DECL_NAME (cls);\n-  if (cls && TREE_CODE (cls) == IDENTIFIER_NODE)\n-    return IDENTIFIER_POINTER (cls);\n-  return \"?\";\n-}\n-\n-/* Output cross-reference info about a class hierarchy.\n-   CLS is the class type of interest.  BASE is a baseclass\n-   for CLS.  PUB and VIRT give the access info about\n-   the class derivation.  FRND is nonzero iff BASE is a friend\n-   of CLS.\n-\n-   ??? Needs to handle nested classes.  */\n-\n-void\n-GNU_xref_hier(cls, base, pub, virt, frnd)\n-   tree cls;\n-   tree base;\n-   int pub;\n-   int virt;\n-   int frnd;\n-{\n-  XREF_FILE xf;\n-\n-  if (!doing_xref) return;\n-  xf = find_file(input_filename);\n-  if (xf == NULL) return;\n-\n-  fprintf(xref_file, \"HIE %s %d %s %s %d %d %d\\n\",\n-\t  filename(xf), lineno, classname (cls), classname (base), \n-\t  pub, virt, frnd);\n-}\n-\n-/* Output cross-reference info about class members.  CLS\n-   is the containing type; FLD is the class member.  */\n-\n-void\n-GNU_xref_member(cls, fld)\n-   tree cls;\n-   tree fld;\n-{\n-  XREF_FILE xf;\n-  const char *prot;\n-  int confg, pure;\n-  const char *d;\n-#ifdef XREF_SHORT_MEMBER_NAMES\n-  int i;\n-#endif\n-  char buf[1024], bufa[1024];\n-\n-  if (!doing_xref) return;\n-  xf = find_file(fld->decl.filename);\n-  if (xf == NULL) return;\n-\n-  if (TREE_PRIVATE (fld)) prot = \"PRIVATE\";\n-  else if (TREE_PROTECTED(fld)) prot = \"PROTECTED\";\n-  else prot = \"PUBLIC\";\n-\n-  confg = 0;\n-  if (TREE_CODE (fld) == FUNCTION_DECL && DECL_CONST_MEMFUNC_P(fld))\n-    confg = 1;\n-  else if (TREE_CODE (fld) == CONST_DECL)\n-    confg = 1;\n-\n-  pure = 0;\n-  if (TREE_CODE (fld) == FUNCTION_DECL && DECL_PURE_VIRTUAL_P(fld))\n-    pure = 1;\n-\n-  d = IDENTIFIER_POINTER(cls);\n-  sprintf(buf, \"%d%s\", (int) strlen(d), d);\n-#ifdef XREF_SHORT_MEMBER_NAMES\n-  i = strlen(buf);\n-#endif\n-  strcpy(bufa, declname(fld));\n-\n-#ifdef XREF_SHORT_MEMBER_NAMES\n-  for (p = &bufa[1]; *p != 0; ++p)\n-    {\n-      if (p[0] == '_' && p[1] == '_' && ISDIGIT (p[2])) {\n-\tif (strncmp(&p[2], buf, i) == 0) *p = 0;\n-\tbreak;\n-      }\n-      else if (p[0] == '_' && p[1] == '_' && p[2] == 'C' && ISDIGIT (p[3])) {\n-\tif (strncmp(&p[3], buf, i) == 0) *p = 0;\n-\tbreak;\n-      }\n-    }\n-#endif\n-\n-  fprintf(xref_file, \"MEM %s %d %s %s %s %d %d %d %d %d %d %d\\n\",\n-\t  filename(xf), fld->decl.linenum, d,  bufa,  prot,\n-\t  (TREE_CODE (fld) == FUNCTION_DECL ? 0 : 1),\n-\t  (DECL_INLINE (fld) ? 1 : 0),\n-\t  (DECL_LANG_SPECIFIC(fld) && DECL_FRIEND_P(fld) ? 1 : 0),\n-\t  (DECL_VINDEX(fld) ? 1 : 0),\n-\t  (TREE_STATIC(fld) ? 1 : 0),\n-\t  pure, confg);\n-}\n-\n-/* Find file entry given name.  */\n-\n-static XREF_FILE\n-find_file(name)\n-   const char *name;\n-{\n-  XREF_FILE xf;\n-\n-  for (xf = all_files; xf != NULL; xf = xf->next) {\n-    if (STREQL(name, xf->name)) break;\n-  }\n-\n-  return xf;\n-}\n-\n-/* Return filename for output purposes.  */\n-\n-static const char *\n-filename(xf)\n-   XREF_FILE xf;\n-{\n-  if (xf == NULL) {\n-    last_file = NULL;\n-    return \"*\";\n-  }\n-\n-  if (last_file == xf) return \"*\";\n-\n-  last_file = xf;\n-\n-  return xf->outname;\n-}\n-\n-/* Return function name for output purposes.  */\n-\n-static const char *\n-fctname(fndecl)\n-   tree fndecl;\n-{\n-  static char fctbuf[1024];\n-  const char *s;\n-\n-  if (fndecl == NULL && last_fndecl == NULL) return \"*\";\n-\n-  if (fndecl == NULL)\n-    {\n-      last_fndecl = NULL;\n-      return \"*TOP*\";\n-    }\n-\n-  if (fndecl == last_fndecl) return \"*\";\n-\n-  last_fndecl = fndecl;\n-\n-  s = declname(fndecl);\n-  s = fixname(s, fctbuf);\n-\n-  return s;\n-}\n-\n-/* Return decl name for output purposes.  */\n-\n-static const char *\n-declname(dcl)\n-   tree dcl;\n-{\n-  if (DECL_NAME (dcl) == NULL) return \"?\";\n-\n-  if (DECL_ASSEMBLER_NAME (dcl))\n-    return IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (dcl));\n-  else\n-    return IDENTIFIER_POINTER (DECL_NAME (dcl));\n-}\n-\n-/* Simplify a type string by removing unneeded parenthesis.  */\n-\n-static void\n-simplify_type(typ)\n-   char *typ;\n-{\n-  char *s;\n-  int lvl, i;\n-\n-  i = strlen(typ);\n-  while (i > 0 && ISSPACE((unsigned char) typ[i-1])) typ[--i] = 0;\n-\n-  if (i > 7 && STREQL(&typ[i-5], \"const\"))\n-    {\n-      typ[i-5] = 0;\n-      i -= 5;\n-    }\n-\n-  if (typ[i-1] != ')') return;\n-\n-  s = &typ[i-2];\n-  lvl = 1;\n-  while (*s != 0) {\n-    if (*s == ')') ++lvl;\n-    else if (*s == '(')\n-      {\n-\t--lvl;\n-\tif (lvl == 0)\n-\t  {\n-\t    s[1] = ')';\n-\t    s[2] = 0;\n-\t    break;\n-\t  }\n-      }\n-    --s;\n-  }\n-\n-  if (*s != 0 && s[-1] == ')')\n-    {\n-      --s;\n-      --s;\n-      if (*s == '(') s[2] = 0;\n-      else if (*s == ':') {\n-\twhile (*s != '(') --s;\n-\ts[1] = ')';\n-\ts[2] = 0;\n-      }\n-    }\n-}\n-\n-/* Fixup a function name (take care of embedded spaces).  */\n-\n-static const char *\n-fixname(nam, buf)\n-   const char *nam;\n-   char *buf;\n-{\n-  const char *s;\n-  char *t;\n-  int fg;\n-\n-  s = nam;\n-  t = buf;\n-  fg = 0;\n-\n-  while (*s != 0)\n-    {\n-      if (*s == ' ')\n-\t{\n-\t  *t++ = '\\36';\n-\t  ++fg;\n-\t}\n-      else *t++ = *s;\n-      ++s;\n-    }\n-  *t = 0;\n-\n-  if (fg == 0) return nam;\n-\n-  return buf;\n-}\n-\n-/* Open file for xreffing.  */\n-\n-static void\n-open_xref_file(file)\n-   const char *file;\n-{\n-  const char *s;\n-  char *t;\n-\n-#ifdef XREF_FILE_NAME\n-  XREF_FILE_NAME (xref_name, file);\n-#else\n-  s = strrchr (file, '/');\n-  if (s == NULL)\n-    sprintf (xref_name, \".%s.gxref\", file);\n-  else\n-    {\n-      ++s;\n-      strcpy (xref_name, file);\n-      t = strrchr (xref_name, '/');\n-      ++t;\n-      *t++ = '.';\n-      strcpy (t, s);\n-      strcat (t, \".gxref\");\n-    }\n-#endif /* no XREF_FILE_NAME */\n-\n-  xref_file = fopen(xref_name, \"w\");\n-\n-  if (xref_file == NULL)\n-    {\n-      error(\"can't create cross-reference file `%s'\", xref_name);\n-      doing_xref = 0;\n-    }\n-}"}]}