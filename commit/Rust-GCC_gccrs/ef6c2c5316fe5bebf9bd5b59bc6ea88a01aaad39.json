{"sha": "ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY2YzJjNTMxNmZlNWJlYmY5YmQ1YjU5YmM2ZWE4OGEwMWFhYWQzOQ==", "commit": {"author": {"name": "Walter Lee", "email": "walt@tilera.com", "date": "2012-03-07T20:05:52Z"}, "committer": {"name": "Walter Lee", "email": "walt@gcc.gnu.org", "date": "2012-03-07T20:05:52Z"}, "message": "Rename some internal atomic macros to have a less generic prefix.\n\nFrom-SVN: r185074", "tree": {"sha": "140e7e8af0f2a26e8530ee111fefb6e38030c5ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/140e7e8af0f2a26e8530ee111fefb6e38030c5ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39/comments", "author": {"login": "walt-tilera", "id": 6602917, "node_id": "MDQ6VXNlcjY2MDI5MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/6602917?v=4", "gravatar_id": "", "url": "https://api.github.com/users/walt-tilera", "html_url": "https://github.com/walt-tilera", "followers_url": "https://api.github.com/users/walt-tilera/followers", "following_url": "https://api.github.com/users/walt-tilera/following{/other_user}", "gists_url": "https://api.github.com/users/walt-tilera/gists{/gist_id}", "starred_url": "https://api.github.com/users/walt-tilera/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/walt-tilera/subscriptions", "organizations_url": "https://api.github.com/users/walt-tilera/orgs", "repos_url": "https://api.github.com/users/walt-tilera/repos", "events_url": "https://api.github.com/users/walt-tilera/events{/privacy}", "received_events_url": "https://api.github.com/users/walt-tilera/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca538e973f03b1ad5bf044a8e45f4dcfb13a22f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca538e973f03b1ad5bf044a8e45f4dcfb13a22f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca538e973f03b1ad5bf044a8e45f4dcfb13a22f5"}], "stats": {"total": 156, "additions": 85, "deletions": 71}, "files": [{"sha": "4d8294b44f63a4e4d44e50d7c7aaeeef1354d02b", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39", "patch": "@@ -1,3 +1,15 @@\n+2012-03-07  Walter Lee  <walt@tilera.com>\n+\n+\t* config/tilepro/atomic.c: Rename \"atomic_\" prefix to\n+\t\"arch_atomic_\".\n+\t(atomic_xor): Rename and move definition to\n+\tconfig/tilepro/atomic.h.\n+\t(atomic_nand): Ditto.\n+\t* config/tilepro/atomic.h: Rename \"atomic_\" prefix to\n+\t\"arch_atomic_\".\n+\t(arch_atomic_xor): Move from config/tilepro/atomic.c.\n+\t(arch_atomic_nand): Ditto.\n+\n 2012-03-07  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/52507"}, {"sha": "bdf809807be3980ec6532dbbe7d04730ee94c8ba", "filename": "libgcc/config/tilepro/atomic.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39/libgcc%2Fconfig%2Ftilepro%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39/libgcc%2Fconfig%2Ftilepro%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fatomic.c?ref=ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39", "patch": "@@ -63,18 +63,12 @@ post_atomic_barrier (int model)\n \n #define __unused __attribute__((unused))\n \n-/* Provide additional methods not implemented by atomic.h. */\n-#define atomic_xor(mem, mask) \\\n-  __atomic_update_cmpxchg(mem, mask, __old ^ __value)\n-#define atomic_nand(mem, mask) \\\n-  __atomic_update_cmpxchg(mem, mask, ~(__old & __value))\n-\n #define __atomic_fetch_and_do(type, size, opname)\t\t\\\n type\t\t\t\t\t\t\t\t\\\n __atomic_fetch_##opname##_##size(type* p, type i, int model)\t\\\n {\t\t\t\t\t\t\t\t\\\n   pre_atomic_barrier(model);\t\t\t\t\t\\\n-  type rv = atomic_##opname(p, i);\t\t\t\t\\\n+  type rv = arch_atomic_##opname(p, i);\t\t\t\t\\\n   post_atomic_barrier(model);\t\t\t\t\t\\\n   return rv;\t\t\t\t\t\t\t\\\n }\n@@ -96,7 +90,7 @@ type\t\t\t\t\t\t\t\t\\\n __atomic_##opname##_fetch_##size(type* p, type i, int model)\t\\\n {\t\t\t\t\t\t\t\t\\\n   pre_atomic_barrier(model);\t\t\t\t\t\\\n-  type rv = atomic_##opname(p, i) op i;\t\t\t\t\\\n+  type rv = arch_atomic_##opname(p, i) op i;\t\t\t\\\n   post_atomic_barrier(model);\t\t\t\t\t\\\n   return rv;\t\t\t\t\t\t\t\\\n }\n@@ -120,7 +114,7 @@ __atomic_compare_exchange_##size(volatile type* ptr, type* oldvalp,\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   type oldval = *oldvalp;\t\t\t\t\t\t\\\n   pre_atomic_barrier(models);\t\t\t\t\t\t\\\n-  type retval = atomic_val_compare_and_exchange(ptr, oldval, newval);\t\\\n+  type retval = arch_atomic_val_compare_and_exchange(ptr, oldval, newval); \\\n   post_atomic_barrier(models);\t\t\t\t\t\t\\\n   bool success = (retval == oldval);\t\t\t\t\t\\\n   *oldvalp = retval;\t\t\t\t\t\t\t\\\n@@ -131,7 +125,7 @@ type\t\t\t\t\t\t\t\t\t\\\n __atomic_exchange_##size(volatile type* ptr, type val, int model)\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   pre_atomic_barrier(model);\t\t\t\t\t\t\\\n-  type retval = atomic_exchange(ptr, val);\t\t\t\t\\\n+  type retval = arch_atomic_exchange(ptr, val);\t\t\t\t\\\n   post_atomic_barrier(model);\t\t\t\t\t\t\\\n   return retval;\t\t\t\t\t\t\t\\\n }\n@@ -159,7 +153,7 @@ __atomic_compare_exchange_##size(volatile type* ptr, type* guess,\t\\\n   type oldval = (oldword >> shift) & valmask;\t\t\t\t\\\n   if (__builtin_expect((oldval == *guess), 1)) {\t\t\t\\\n     unsigned int word = (oldword & bgmask) | ((val & valmask) << shift); \\\n-    oldword = atomic_val_compare_and_exchange(p, oldword, word);\t\\\n+    oldword = arch_atomic_val_compare_and_exchange(p, oldword, word);\t\\\n     oldval = (oldword >> shift) & valmask;\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n   post_atomic_barrier(models);\t\t\t\t\t\t\\\n@@ -187,7 +181,7 @@ proto\t\t\t\t\t\t\t\t\t\\\n     oldval = (oldword >> shift) & valmask;\t\t\t\t\\\n     val = expr;\t\t\t\t\t\t\t\t\\\n     unsigned int word = (oldword & bgmask) | ((val & valmask) << shift); \\\n-    xword = atomic_val_compare_and_exchange(p, oldword, word);          \\\n+    xword = arch_atomic_val_compare_and_exchange(p, oldword, word);\t\\\n   } while (__builtin_expect(xword != oldword, 0));\t\t\t\\\n   bottom\t\t\t\t\t\t\t\t\\\n }"}, {"sha": "d49d13b3fb019ef9c713ea9974f0f9286047d62c", "filename": "libgcc/config/tilepro/atomic.h", "status": "modified", "additions": 67, "deletions": 59, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39/libgcc%2Fconfig%2Ftilepro%2Fatomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39/libgcc%2Fconfig%2Ftilepro%2Fatomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fatomic.h?ref=ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39", "patch": "@@ -104,8 +104,8 @@\n \n /* 32-bit integer compare-and-exchange.  */\n static __inline __attribute__ ((always_inline))\n-     int atomic_val_compare_and_exchange_4 (volatile int *mem,\n-\t\t\t\t\t    int oldval, int newval)\n+     int arch_atomic_val_compare_and_exchange_4 (volatile int *mem,\n+\t\t\t\t\t\t int oldval, int newval)\n {\n #ifdef __tilegx__\n   __insn_mtspr (SPR_CMPEXCH_VALUE, oldval);\n@@ -123,9 +123,9 @@ static __inline __attribute__ ((always_inline))\n \n /* 64-bit integer compare-and-exchange.  */\n static __inline __attribute__ ((always_inline))\n-     int64_t atomic_val_compare_and_exchange_8 (volatile int64_t * mem,\n-\t\t\t\t\t\tint64_t oldval,\n-\t\t\t\t\t\tint64_t newval)\n+     int64_t arch_atomic_val_compare_and_exchange_8 (volatile int64_t * mem,\n+\t\t\t\t\t\t     int64_t oldval,\n+\t\t\t\t\t\t     int64_t newval)\n {\n #ifdef __tilegx__\n   __insn_mtspr (SPR_CMPEXCH_VALUE, oldval);\n@@ -146,41 +146,41 @@ static __inline __attribute__ ((always_inline))\n \n /* This non-existent symbol is called for sizes other than \"4\" and \"8\",\n    indicating a bug in the caller.  */\n-extern int __atomic_error_bad_argument_size (void)\n+extern int __arch_atomic_error_bad_argument_size (void)\n   __attribute__ ((warning (\"sizeof atomic argument not 4 or 8\")));\n \n \n-#define atomic_val_compare_and_exchange(mem, o, n)                      \\\n+#define arch_atomic_val_compare_and_exchange(mem, o, n)                 \\\n   ({                                                                    \\\n     (__typeof(*(mem)))(__typeof(*(mem)-*(mem)))                         \\\n       ((sizeof(*(mem)) == 8) ?                                          \\\n-       atomic_val_compare_and_exchange_8(                               \\\n+       arch_atomic_val_compare_and_exchange_8(                          \\\n          (volatile int64_t*)(mem), (__typeof((o)-(o)))(o),              \\\n          (__typeof((n)-(n)))(n)) :                                      \\\n        (sizeof(*(mem)) == 4) ?                                          \\\n-       atomic_val_compare_and_exchange_4(                               \\\n+       arch_atomic_val_compare_and_exchange_4(                          \\\n          (volatile int*)(mem), (__typeof((o)-(o)))(o),                  \\\n          (__typeof((n)-(n)))(n)) :                                      \\\n-       __atomic_error_bad_argument_size());                             \\\n+       __arch_atomic_error_bad_argument_size());                        \\\n   })\n \n-#define atomic_bool_compare_and_exchange(mem, o, n)                     \\\n+#define arch_atomic_bool_compare_and_exchange(mem, o, n)                \\\n   ({                                                                    \\\n     __typeof(o) __o = (o);                                              \\\n     __builtin_expect(                                                   \\\n-      __o == atomic_val_compare_and_exchange((mem), __o, (n)), 1);      \\\n+      __o == arch_atomic_val_compare_and_exchange((mem), __o, (n)), 1); \\\n   })\n \n \n /* Loop with compare_and_exchange until we guess the correct value.\n    Normally \"expr\" will be an expression using __old and __value.  */\n-#define __atomic_update_cmpxchg(mem, value, expr)                       \\\n+#define __arch_atomic_update_cmpxchg(mem, value, expr)                  \\\n   ({                                                                    \\\n     __typeof(value) __value = (value);                                  \\\n     __typeof(*(mem)) *__mem = (mem), __old = *__mem, __guess;           \\\n     do {                                                                \\\n       __guess = __old;                                                  \\\n-      __old = atomic_val_compare_and_exchange(__mem, __old, (expr));    \\\n+      __old = arch_atomic_val_compare_and_exchange(__mem, __old, (expr));    \\\n     } while (__builtin_expect(__old != __guess, 0));                    \\\n     __old;                                                              \\\n   })\n@@ -189,14 +189,14 @@ extern int __atomic_error_bad_argument_size (void)\n \n /* Generic atomic op with 8- or 4-byte variant.\n    The _mask, _addend, and _expr arguments are ignored on tilegx.  */\n-#define __atomic_update(mem, value, op, _mask, _addend, _expr)          \\\n+#define __arch_atomic_update(mem, value, op, _mask, _addend, _expr)     \\\n   ({                                                                    \\\n     ((__typeof(*(mem)))                                                 \\\n      ((sizeof(*(mem)) == 8) ? (__typeof(*(mem)-*(mem)))__insn_##op(     \\\n         (void *)(mem), (int64_t)(__typeof((value)-(value)))(value)) :   \\\n       (sizeof(*(mem)) == 4) ? (int)__insn_##op##4(                      \\\n         (void *)(mem), (int32_t)(__typeof((value)-(value)))(value)) :   \\\n-      __atomic_error_bad_argument_size()));                             \\\n+      __arch_atomic_error_bad_argument_size()));                        \\\n   })\n \n #else\n@@ -211,7 +211,7 @@ extern int __atomic_error_bad_argument_size (void)\n    Only 32-bit support is provided.  */\n static __inline __attribute__ ((always_inline))\n      int\n-     __atomic_update_4 (volatile int *mem, int mask, int addend)\n+     __arch_atomic_update_4 (volatile int *mem, int mask, int addend)\n {\n   int result;\n   __asm__ __volatile__ (\"swint1\":\"=R00\" (result),\n@@ -224,48 +224,55 @@ static __inline __attribute__ ((always_inline))\n \n /* Generic atomic op with 8- or 4-byte variant.\n    The _op argument is ignored on tilepro.  */\n-#define __atomic_update(mem, value, _op, mask, addend, expr)            \\\n+#define __arch_atomic_update(mem, value, _op, mask, addend, expr)       \\\n   ({                                                                    \\\n     (__typeof(*(mem)))(__typeof(*(mem)-*(mem)))                         \\\n       ((sizeof(*(mem)) == 8) ?                                          \\\n-       __atomic_update_cmpxchg((mem), (value), (expr)) :                \\\n+       __arch_atomic_update_cmpxchg((mem), (value), (expr)) :           \\\n        (sizeof(*(mem)) == 4) ?                                          \\\n-       __atomic_update_4((volatile int*)(mem), (__typeof((mask)-(mask)))(mask), \\\n-                         (__typeof((addend)-(addend)))(addend)) :       \\\n-       __atomic_error_bad_argument_size());                             \\\n+       __arch_atomic_update_4((volatile int*)(mem),                     \\\n+                              (__typeof((mask)-(mask)))(mask),          \\\n+                              (__typeof((addend)-(addend)))(addend)) :  \\\n+       __arch_atomic_error_bad_argument_size());                        \\\n   })\n \n #endif /* __tilegx__ */\n \n \n-#define atomic_exchange(mem, newvalue) \\\n-  __atomic_update(mem, newvalue, exch, 0, newvalue, __value)\n+#define arch_atomic_exchange(mem, newvalue) \\\n+  __arch_atomic_update(mem, newvalue, exch, 0, newvalue, __value)\n \n-#define atomic_add(mem, value) \\\n-  __atomic_update(mem, value, fetchadd, -1, value, __old + __value)\n+#define arch_atomic_add(mem, value) \\\n+  __arch_atomic_update(mem, value, fetchadd, -1, value, __old + __value)\n \n-#define atomic_sub(mem, value) atomic_add((mem), -(value))\n+#define arch_atomic_sub(mem, value) arch_atomic_add((mem), -(value))\n \n-#define atomic_increment(mem) atomic_add((mem), 1)\n+#define arch_atomic_increment(mem) arch_atomic_add((mem), 1)\n \n-#define atomic_decrement(mem) atomic_add((mem), -1)\n+#define arch_atomic_decrement(mem) arch_atomic_add((mem), -1)\n \n-#define atomic_and(mem, mask) \\\n-  __atomic_update(mem, mask, fetchand, mask, 0, __old & __value)\n+#define arch_atomic_and(mem, mask) \\\n+  __arch_atomic_update(mem, mask, fetchand, mask, 0, __old & __value)\n \n-#define atomic_or(mem, mask) \\\n-  __atomic_update(mem, mask, fetchor, ~mask, mask, __old | __value)\n+#define arch_atomic_or(mem, mask) \\\n+  __arch_atomic_update(mem, mask, fetchor, ~mask, mask, __old | __value)\n \n-#define atomic_bit_set(mem, bit)                                        \\\n+#define arch_atomic_xor(mem, mask) \\\n+  __arch_atomic_update_cmpxchg(mem, mask, __old ^ __value)\n+\n+#define arch_atomic_nand(mem, mask) \\\n+  __arch_atomic_update_cmpxchg(mem, mask, ~(__old & __value))\n+\n+#define arch_atomic_bit_set(mem, bit)                                   \\\n   ({                                                                    \\\n     __typeof(*(mem)) __mask = (__typeof(*(mem)))1 << (bit);             \\\n-    __mask & atomic_or((mem), __mask);                                  \\\n+    __mask & arch_atomic_or((mem), __mask);                             \\\n   })\n \n-#define atomic_bit_clear(mem, bit)                                      \\\n+#define arch_atomic_bit_clear(mem, bit)                                 \\\n   ({                                                                    \\\n     __typeof(*(mem)) __mask = (__typeof(*(mem)))1 << (bit);             \\\n-    __mask & atomic_and((mem), ~__mask);                                \\\n+    __mask & arch_atomic_and((mem), ~__mask);                           \\\n   })\n \n #ifdef __tilegx__\n@@ -275,36 +282,36 @@ static __inline __attribute__ ((always_inline))\n    This accessor is provided for compatibility with TILEPro, which\n    required an explicit atomic operation for stores that needed\n    to be atomic with respect to other atomic methods in this header.  */\n-#define atomic_write(mem, value) ((void) (*(mem) = (value)))\n+#define arch_atomic_write(mem, value) ((void) (*(mem) = (value)))\n #else\n-#define atomic_write(mem, value)                                        \\\n+#define arch_atomic_write(mem, value)                                   \\\n   do {                                                                  \\\n     __typeof(mem) __aw_mem = (mem);                                     \\\n     __typeof(value) __aw_val = (value);                                 \\\n     unsigned int *__aw_mem32, __aw_intval, __aw_val32, __aw_off, __aw_mask; \\\n     __aw_intval = (__typeof((value) - (value)))__aw_val;                \\\n     switch (sizeof(*__aw_mem)) {                                        \\\n     case 8:                                                             \\\n-      __atomic_update_cmpxchg(__aw_mem, __aw_val, __value);             \\\n+      __arch_atomic_update_cmpxchg(__aw_mem, __aw_val, __value);        \\\n       break;                                                            \\\n     case 4:                                                             \\\n-      __atomic_update_4((int *)__aw_mem, 0, __aw_intval);               \\\n+      __arch_atomic_update_4((int *)__aw_mem, 0, __aw_intval);          \\\n       break;                                                            \\\n     case 2:                                                             \\\n       __aw_off = 8 * ((long)__aw_mem & 0x2);                            \\\n       __aw_mask = 0xffffU << __aw_off;                                  \\\n       __aw_mem32 = (unsigned int *)((long)__aw_mem & ~0x2);             \\\n       __aw_val32 = (__aw_intval << __aw_off) & __aw_mask;               \\\n-      __atomic_update_cmpxchg(__aw_mem32, __aw_val32,                   \\\n-                              (__old & ~__aw_mask) | __value);          \\\n+      __arch_atomic_update_cmpxchg(__aw_mem32, __aw_val32,              \\\n+                                   (__old & ~__aw_mask) | __value);     \\\n       break;                                                            \\\n     case 1:                                                             \\\n       __aw_off = 8 * ((long)__aw_mem & 0x3);                            \\\n       __aw_mask = 0xffU << __aw_off;                                    \\\n       __aw_mem32 = (unsigned int *)((long)__aw_mem & ~0x3);             \\\n       __aw_val32 = (__aw_intval << __aw_off) & __aw_mask;               \\\n-      __atomic_update_cmpxchg(__aw_mem32, __aw_val32,                   \\\n-                              (__old & ~__aw_mask) | __value);          \\\n+      __arch_atomic_update_cmpxchg(__aw_mem32, __aw_val32,              \\\n+                                   (__old & ~__aw_mask) | __value);     \\\n       break;                                                            \\\n     }                                                                   \\\n   } while (0)\n@@ -315,15 +322,15 @@ static __inline __attribute__ ((always_inline))\n    This macro prevents loads or stores from being moved by the compiler\n    across the macro.  Any loaded value that was loaded before this\n    macro must then be reloaded by the compiler.  */\n-#define atomic_compiler_barrier() __asm__ __volatile__(\"\" ::: \"memory\")\n+#define arch_atomic_compiler_barrier() __asm__ __volatile__(\"\" ::: \"memory\")\n \n /* Full memory barrier.\n \n-   This macro has the semantics of atomic_compiler_barrer(), but also\n+   This macro has the semantics of arch_atomic_compiler_barrer(), but also\n    ensures that previous stores are visible to other cores, and that\n    all previous loaded values have been placed into their target\n    register on this core.  */\n-#define atomic_full_barrier() __insn_mf()\n+#define arch_atomic_full_barrier() __insn_mf()\n \n /* Read memory barrier.\n \n@@ -335,9 +342,9 @@ static __inline __attribute__ ((always_inline))\n    On current TILE chips a read barrier is implemented as a full barrier,\n    but this may not be true in later versions of the architecture.\n \n-   See also atomic_acquire_barrier() for the appropriate idiom to use\n+   See also arch_atomic_acquire_barrier() for the appropriate idiom to use\n    to ensure no reads are lifted above an atomic lock instruction.  */\n-#define atomic_read_barrier() atomic_full_barrier()\n+#define arch_atomic_read_barrier() arch_atomic_full_barrier()\n \n /* Write memory barrier.\n \n@@ -349,9 +356,9 @@ static __inline __attribute__ ((always_inline))\n    On current TILE chips a write barrier is implemented as a full barrier,\n    but this may not be true in later versions of the architecture.\n \n-   See also atomic_release_barrier() for the appropriate idiom to use\n+   See also arch_atomic_release_barrier() for the appropriate idiom to use\n    to ensure all writes are complete prior to an atomic unlock instruction.  */\n-#define atomic_write_barrier() atomic_full_barrier()\n+#define arch_atomic_write_barrier() arch_atomic_full_barrier()\n \n /* Lock acquisition barrier.\n \n@@ -367,10 +374,10 @@ static __inline __attribute__ ((always_inline))\n    This should be done after the atomic operation that actually\n    acquires the lock, and in conjunction with a \"control dependency\"\n    that checks the atomic operation result to see if the lock was\n-   in fact acquired.  See the atomic_read_barrier() macro\n+   in fact acquired.  See the arch_atomic_read_barrier() macro\n    for a heavier-weight barrier to use in certain unusual constructs,\n-   or atomic_acquire_barrier_value() if no control dependency exists.  */\n-#define atomic_acquire_barrier() atomic_compiler_barrier()\n+   or arch_atomic_acquire_barrier_value() if no control dependency exists.  */\n+#define arch_atomic_acquire_barrier() arch_atomic_compiler_barrier()\n \n /* Lock release barrier.\n \n@@ -383,7 +390,7 @@ static __inline __attribute__ ((always_inline))\n    for locking, that is, when leaving a critical section.  This should\n    be done before the operation (such as a store of zero) that\n    actually releases the lock.  */\n-#define atomic_release_barrier() atomic_write_barrier()\n+#define arch_atomic_release_barrier() arch_atomic_write_barrier()\n \n /* Barrier until the read of a particular value is complete.\n \n@@ -400,7 +407,7 @@ static __inline __attribute__ ((always_inline))\n    atomic instruction, even if the value itself is not checked.  This\n    guarantees that if the atomic instruction succeeded in taking the lock,\n    the lock was held before any reads in the critical section issued.  */\n-#define atomic_acquire_barrier_value(val) \\\n+#define arch_atomic_acquire_barrier_value(val) \\\n   __asm__ __volatile__(\"move %0, %0\" :: \"r\"(val))\n \n /* Access the given variable in memory exactly once.\n@@ -421,8 +428,9 @@ static __inline __attribute__ ((always_inline))\n \n    Note that multiple uses of this macro are guaranteed to be ordered,\n    i.e. the compiler will not reorder stores or loads that are wrapped\n-   in atomic_access_once().  */\n-#define atomic_access_once(x) (*(volatile __typeof(x) *)&(x))\n+   in arch_atomic_access_once().  */\n+#define arch_atomic_access_once(x) (*(volatile __typeof(x) *)&(x))\n+\n \n \n #endif /* !_ATOMIC_H_ */"}]}