{"sha": "ceafcb987730eaf5c4191afab12550ffc13ce89e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VhZmNiOTg3NzMwZWFmNWM0MTkxYWZhYjEyNTUwZmZjMTNjZTg5ZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-06-09T23:08:24Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-06-09T23:08:24Z"}, "message": "New test.\n\nFrom-SVN: r43121", "tree": {"sha": "c19c36de2f6350a290127341eee6c06cce19f5ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c19c36de2f6350a290127341eee6c06cce19f5ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceafcb987730eaf5c4191afab12550ffc13ce89e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceafcb987730eaf5c4191afab12550ffc13ce89e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceafcb987730eaf5c4191afab12550ffc13ce89e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceafcb987730eaf5c4191afab12550ffc13ce89e/comments", "author": null, "committer": null, "parents": [{"sha": "e69decfd36cabe29f106ff1c277706ac621e690f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e69decfd36cabe29f106ff1c277706ac621e690f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e69decfd36cabe29f106ff1c277706ac621e690f"}], "stats": {"total": 350, "additions": 350, "deletions": 0}, "files": [{"sha": "910629d353e4920df536ed08b41239d96f906f84", "filename": "gcc/testsuite/g++.old-deja/g++.other/stepanov_v1p2.C", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceafcb987730eaf5c4191afab12550ffc13ce89e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstepanov_v1p2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceafcb987730eaf5c4191afab12550ffc13ce89e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstepanov_v1p2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstepanov_v1p2.C?ref=ceafcb987730eaf5c4191afab12550ffc13ce89e", "patch": "@@ -0,0 +1,350 @@\n+// Special g++ Options: -O2\n+\n+/* KAI's version of Stepanov Benchmark -- Version 1.2\n+\n+   Version 1.2 -- removed some special code for GNU systems that\n+\t\t  GNU complained about without -O\n+\n+To verify how efficiently C++ (and in particular STL) is compiled by\n+the present day compilers, I composed a little benchmark. It outputs\n+13 numbers. In the ideal world these numbers should be the same. In\n+the real world, however, ...\n+\n+The final number printed by the benchmark is a geometric mean of the\n+performance degradation factors of individual tests. It claims to\n+represent the factor by which you will be punished by your\n+compiler if you attempt to use C++ data abstraction features. I call\n+this number \"Abstraction Penalty.\"\n+\n+As with any benchmark it is hard to prove such a claim; some people\n+told me that it does not represent typical C++ usage. It is, however,\n+a noteworthy fact that majority of the people who so object are\n+responsible for C++ compilers with disproportionatly large Abstraction\n+Penalty.\n+\n+The structure of the benchmark is really quite simple. It adds 2000\n+doubles in an array 25000 times. It does it in 13 different ways that\n+introduce more and more abstract ways of doing it:\n+\n+0 - uses simple Fortran-like for loop.\n+1 - 12 use STL style accumulate template function with plus function object.\n+1, 3, 5, 7 ,9, 11 use doubles.\n+2, 4, 6, 8, 10, 12 use Double - double wrapped in a class.\n+1, 2 - use regular pointers.\n+3, 4 - use pointers wrapped in a class.\n+5, 6 - use pointers wrapped in a reverse-iterator adaptor.\n+7, 8 - use wrapped pointers wrapped in a reverse-iterator adaptor.\n+9, 10 - use pointers wrapped in a reverse-iterator adaptor wrapped in a\n+  reverse-iterator adaptor.\n+11, 12 - use wrapped pointers wrapped in a reverse-iterator adaptor wrapped\n+  in a reverse-iterator adaptor.\n+\n+All the operators on Double and different pointer-like classes are\n+declared inline. The only thing that is really measured is the penalty\n+for data abstraction. While templates are used, they do not cause any\n+performance degradation. They are used only to simplify the code.\n+\n+Since many of you are interested in the C++ performance issues, I\n+decided to post the benchmark here. I would appreciate if you run it\n+and (if possible) send me the results indicating what you have\n+compiled it with (CPU, clock rate, compiler, optimization level). It\n+is self contained and written so that it could be compiled even with\n+those compilers that at present cannot compile STL at all.\n+\n+It takes a fairly long time to run - on a really slow machine it might\n+take a full hour. (For those of you who want to run it faster - give\n+it a command line argument that specifies the number of\n+iterations. The default is 25000, but it gives an accurate predictions\n+even with 500 or a thousand.)\n+\n+\n+Alex Stepanov\n+stepanov@mti.sgi.com\n+\n+*/\n+\n+\n+#include <stddef.h>\n+#include <stdio.h>\n+#include <time.h>\n+#include <math.h>\n+#include <stdlib.h>\n+\n+template <class T>\n+inline int operator!=(const T& x, const T& y) {\n+  return !(x == y);\n+}\n+\n+struct Double {\n+  double value;\n+  Double() {}\n+  Double(const double& x) : value(x) {}\n+  operator double() { return value; }\n+};\n+\n+inline Double operator+(const Double& x, const Double& y) {\n+  return Double(x.value + y.value);\n+}\n+\n+struct double_pointer {\n+    double* current;\n+    double_pointer() {}\n+    double_pointer(double* x) : current(x) {}\n+    double& operator*() const { return *current; }\n+    double_pointer& operator++() {\n+\t++current;\n+\treturn *this;\n+    }\n+    double_pointer operator++(int) {\n+\tdouble_pointer tmp = *this;\n+\t++*this;\n+\treturn tmp;\n+    }\n+    double_pointer& operator--() {\n+\t--current;\n+\treturn *this;\n+    }\n+    double_pointer operator--(int) {\n+\tdouble_pointer tmp = *this;\n+\t--*this;\n+\treturn tmp;\n+    }\n+};\n+\n+\n+inline int operator==(const double_pointer& x,\n+\t\t      const double_pointer& y) {\n+    return x.current == y.current;\n+}\n+\n+struct Double_pointer {\n+    Double* current;\n+    Double_pointer() {}\n+    Double_pointer(Double* x) : current(x) {}\n+    Double& operator*() const { return *current; }\n+    Double_pointer& operator++() {\n+\t++current;\n+\treturn *this;\n+    }\n+    Double_pointer operator++(int) {\n+\tDouble_pointer tmp = *this;\n+\t++*this;\n+\treturn tmp;\n+    }\n+    Double_pointer& operator--() {\n+\t--current;\n+\treturn *this;\n+    }\n+    Double_pointer operator--(int) {\n+\tDouble_pointer tmp = *this;\n+\t--*this;\n+\treturn tmp;\n+    }\n+};\n+\n+\n+inline int operator==(const Double_pointer& x,\n+\t\t       const Double_pointer& y) {\n+    return x.current == y.current;\n+}\n+\n+template <class RandomAccessIterator, class T>\n+struct reverse_iterator {\n+    RandomAccessIterator current;\n+    reverse_iterator(RandomAccessIterator x) : current(x) {}\n+    T& operator*() const {\n+      RandomAccessIterator tmp = current;\n+      return *(--tmp);\n+    }\n+    reverse_iterator<RandomAccessIterator, T>& operator++() {\n+\t--current;\n+\treturn *this;\n+    }\n+    reverse_iterator<RandomAccessIterator, T> operator++(int) {\n+      reverse_iterator<RandomAccessIterator, T> tmp = *this;\n+\t++*this;\n+\treturn tmp;\n+    }\n+    reverse_iterator<RandomAccessIterator, T>& operator--() {\n+\t++current;\n+\treturn *this;\n+    }\n+    reverse_iterator<RandomAccessIterator, T> operator--(int) {\n+      reverse_iterator<RandomAccessIterator, T> tmp = *this;\n+\t--*this;\n+\treturn tmp;\n+    }\n+};\n+\n+template <class RandomAccessIterator, class T>\n+inline int operator==(const reverse_iterator<RandomAccessIterator, T>& x,\n+\t\t      const reverse_iterator<RandomAccessIterator, T>& y) {\n+    return x.current == y.current;\n+}\n+\n+struct {\n+  double operator()(const double& x, const double& y) {return x + y; }\n+  Double operator()(const Double& x, const Double& y) {return x + y; }\n+} plus;\n+\n+\n+template <class Iterator, class Number>\n+Number accumulate(Iterator first, Iterator last, Number result) {\n+  while (first != last) result =  plus(result, *first++);\n+  return result;\n+}\n+\n+int iterations = 25000;\n+#define SIZE 2000\n+\n+int current_test = 0;\n+\n+double result_times[20];\n+\n+void summarize() {\n+  printf(\"\\ntest      absolute   additions      ratio with\\n\");\n+  printf(\"number    time       per second     test0\\n\\n\");\n+  int i;\n+  double millions = (double(SIZE) * iterations)/1000000.;\n+  for (i = 0; i < current_test; ++i)\n+    {\n+      printf(\"%2i       %5.2fsec    %5.2fM         %.2f\\n\",\n+\t     i,\n+\t     result_times[i],\n+\t     millions/result_times[i],\n+\t     result_times[i]/result_times[0]);\n+      // To make the benchmark into a test-case we check that no\n+      // version has a severe abstraction penalty.  There will always\n+      // be measurement errors, and we don't presently avoid all\n+      // abstraction penalty.  As the compiler improves, 1.2 should\n+      // gradually be replaced with a smaller value.\n+      if (result_times[i]/result_times[0] > 1.2)\n+\tabort ();\n+    }\n+  double gmean_times = 0.;\n+  double total_absolute_times = 0.;  // sam added 12/05/95\n+  double gmean_rate = 0.;\n+  double gmean_ratio = 0.;\n+  for (i = 0; i < current_test; ++i) {\n+    total_absolute_times += result_times[i];  // sam added 12/05/95\n+    gmean_times += log(result_times[i]);\n+    gmean_rate  += log(millions/result_times[i]);\n+    gmean_ratio += log(result_times[i]/result_times[0]);\n+  } \n+  printf(\"mean:    %5.2fsec    %5.2fM         %.2f\\n\",\n+\t exp(gmean_times/current_test),\n+\t exp(gmean_rate/current_test),\n+\t exp(gmean_ratio/current_test));\n+  printf(\"\\nTotal absolute time: %.2f sec\\n\", total_absolute_times);  // sam added 12/05/95\n+  printf(\"\\nAbstraction Penalty: %.2f\\n\\n\", exp(gmean_ratio/current_test));\n+}\n+\n+clock_t start_time, end_time;\n+\n+inline void start_timer() { start_time = clock(); }\n+\n+inline double timer() {\n+  end_time = clock();\n+  return (end_time - start_time)/double(CLOCKS_PER_SEC);\n+}\n+\n+const double init_value = 3.;\n+\n+\n+\n+double data[SIZE];\n+\n+Double Data[SIZE];\n+\n+inline void check(double result) {\n+  if (result != SIZE * init_value) printf(\"test %i failed\\n\", current_test);\n+}\n+\n+void test0(double* first, double* last) {\n+  start_timer();\n+  for(int i = 0; i < iterations; ++i) {\n+    double result = 0;\n+    for (int n = 0; n < last - first; ++n) result += first[n];\n+    check(result);\n+  }\n+  result_times[current_test++] = timer();\n+}\n+\n+\n+template <class Iterator, class T>\n+void test(Iterator first, Iterator last, T zero) {\n+  int i;\n+  start_timer();\n+  for(i = 0; i < iterations; ++i)\n+    check(double(accumulate(first, last, zero)));\n+  result_times[current_test++] = timer();\n+}\n+\n+template <class Iterator, class T>\n+void fill(Iterator first, Iterator last, T value) {\n+  while (first != last) *first++ = value;\n+}\n+\n+\n+double d = 0.;\n+Double D = 0.;\n+typedef double* dp;\n+dp dpb = data;\n+dp dpe = data + SIZE;\n+typedef Double* Dp;\n+Dp Dpb = Data;\n+Dp Dpe = Data + SIZE;\n+typedef double_pointer dP;\n+dP dPb(dpb);\n+dP dPe(dpe);\n+typedef Double_pointer DP;\n+DP DPb(Dpb);\n+DP DPe(Dpe);\n+typedef reverse_iterator<dp, double> rdp;\n+rdp rdpb(dpe);\n+rdp rdpe(dpb);\n+typedef reverse_iterator<Dp, Double> rDp;\n+rDp rDpb(Dpe);\n+rDp rDpe(Dpb);\n+typedef reverse_iterator<dP, double> rdP;\n+rdP rdPb(dPe);\n+rdP rdPe(dPb);\n+typedef reverse_iterator<DP, Double> rDP;\n+rDP rDPb(DPe);\n+rDP rDPe(DPb);\n+typedef reverse_iterator<rdp, double> rrdp;\n+rrdp rrdpb(rdpe);\n+rrdp rrdpe(rdpb);\n+typedef reverse_iterator<rDp, Double> rrDp;\n+rrDp rrDpb(rDpe);\n+rrDp rrDpe(rDpb);\n+typedef reverse_iterator<rdP, double> rrdP;\n+rrdP rrdPb(rdPe);\n+rrdP rrdPe(rdPb);\n+typedef reverse_iterator<rDP, Double> rrDP;\n+rrDP rrDPb(rDPe);\n+rrDP rrDPe(rDPb);\n+\n+int main(int argv, char** argc) {\n+  if (argv > 1) iterations = atoi(argc[1]);\n+  fill(dpb, dpe, double(init_value));\n+  fill(Dpb, Dpe, Double(init_value));\n+  test0(dpb, dpe);\n+  test(dpb, dpe, d);\n+  test(Dpb, Dpe, D);\n+  test(dPb, dPe, d);\n+  test(DPb, DPe, D);\n+  test(rdpb, rdpe, d);\n+  test(rDpb, rDpe, D);\n+  test(rdPb, rdPe, d);\n+  test(rDPb, rDPe, D);\n+  test(rrdpb, rrdpe, d);\n+  test(rrDpb, rrDpe, D);\n+  test(rrdPb, rrdPe, d);\n+  test(rrDPb, rrDPe, D);\n+  summarize();\n+  return 0;\n+}\n+\n+\n+"}]}