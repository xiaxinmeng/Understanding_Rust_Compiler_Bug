{"sha": "1b7c4a3727aa3c5c6abaefeacb8641b8487c3992", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI3YzRhMzcyN2FhM2M1YzZhYmFlZmVhY2I4NjQxYjg0ODdjMzk5Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-12-04T13:21:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-12-04T13:21:53Z"}, "message": "regmove.c (copy_src_to_dest): Remove loop_depth parameter.\n\n\t* regmove.c (copy_src_to_dest): Remove loop_depth parameter.\n\t(optimize_reg_copy_1): Remove REG_N_REFS updating code.\n\t(optimize_reg_copy_2, copy_src_to_dest, fixup_match_2): Likewise.\n\t(regmove_optimize, fixup_match_1): Likewise.\n\nFrom-SVN: r30774", "tree": {"sha": "fec8b0843f9929d788bbadc1b0e7ff1e10e11b09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fec8b0843f9929d788bbadc1b0e7ff1e10e11b09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b7c4a3727aa3c5c6abaefeacb8641b8487c3992", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b7c4a3727aa3c5c6abaefeacb8641b8487c3992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b7c4a3727aa3c5c6abaefeacb8641b8487c3992", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b7c4a3727aa3c5c6abaefeacb8641b8487c3992/comments", "author": null, "committer": null, "parents": [{"sha": "b760c4b1478efa55eae9e0d216bd100036cef2ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b760c4b1478efa55eae9e0d216bd100036cef2ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b760c4b1478efa55eae9e0d216bd100036cef2ef"}], "stats": {"total": 105, "additions": 14, "deletions": 91}, "files": [{"sha": "f833a383152cbcc16c7aecc47ad9f0426d4ada7a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b7c4a3727aa3c5c6abaefeacb8641b8487c3992/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b7c4a3727aa3c5c6abaefeacb8641b8487c3992/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b7c4a3727aa3c5c6abaefeacb8641b8487c3992", "patch": "@@ -1,3 +1,10 @@\n+Sat Dec  4 14:13:38 MET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* regmove.c (copy_src_to_dest): Remove loop_depth parameter.\n+\t(optimize_reg_copy_1): Remove REG_N_REFS updating code.\n+\t(optimize_reg_copy_2, copy_src_to_dest, fixup_match_2): Likewise.\n+\t(regmove_optimize, fixup_match_1): Likewise.\n+\n 1999-12-05  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* flow.c (flow_loops_dump): Add missing argument when calling"}, {"sha": "b4647816679fd2cfab2a9defd82317d5c2f7a79a", "filename": "gcc/regmove.c", "status": "modified", "additions": 7, "deletions": 91, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b7c4a3727aa3c5c6abaefeacb8641b8487c3992/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b7c4a3727aa3c5c6abaefeacb8641b8487c3992/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=1b7c4a3727aa3c5c6abaefeacb8641b8487c3992", "patch": "@@ -45,7 +45,7 @@ static int optimize_reg_copy_1\tPROTO((rtx, rtx, rtx));\n static void optimize_reg_copy_2\tPROTO((rtx, rtx, rtx));\n static void optimize_reg_copy_3\tPROTO((rtx, rtx, rtx));\n static rtx gen_add3_insn\tPROTO((rtx, rtx, rtx));\n-static void copy_src_to_dest\tPROTO((rtx, rtx, rtx, int, int));\n+static void copy_src_to_dest\tPROTO((rtx, rtx, rtx, int));\n static int *regmove_bb_head;\n \n struct match {\n@@ -68,7 +68,6 @@ static int stable_and_no_regs_but_for_p PROTO((rtx, rtx, rtx));\n static int regclass_compatible_p PROTO((int, int));\n static int replacement_quality PROTO((rtx));\n static int fixup_match_2 PROTO((rtx, rtx, rtx, rtx, FILE *));\n-static int loop_depth;\n \n /* Return non-zero if registers with CLASS1 and CLASS2 can be merged without\n    causing too much register allocation problems.  */\n@@ -465,20 +464,7 @@ optimize_reg_copy_1 (insn, dest, src)\n \t\t\t   && (sregno >= FIRST_PSEUDO_REGISTER\n \t\t\t       || ! reg_overlap_mentioned_p (src,\n \t\t\t\t\t\t\t     PATTERN (q))))\n-\t\t    {\n-\t\t      /* We assume that a register is used exactly once per\n-\t\t\t insn in the REG_N_REFS updates below.  If this is not\n-\t\t\t correct, no great harm is done.\n-\n-\t\t\t Since we do not know if we will change the lifetime of\n-\t\t\t SREGNO or DREGNO, we must not update REG_LIVE_LENGTH\n-\t\t\t or REG_N_CALLS_CROSSED at this time.   */\n-\t\t      if (sregno >= FIRST_PSEUDO_REGISTER)\n-\t\t\tREG_N_REFS (sregno) -= loop_depth;\n-\n-\t\t      if (dregno >= FIRST_PSEUDO_REGISTER)\n-\t\t\tREG_N_REFS (dregno) += loop_depth;\n-\t\t    }\n+\t\t    ;\n \t\t  else\n \t\t    {\n \t\t      validate_replace_rtx (dest, src, q);\n@@ -626,15 +612,7 @@ optimize_reg_copy_2 (insn, dest, src)\n \t    if (GET_RTX_CLASS (GET_CODE (q)) == 'i')\n \t      {\n \t\tif (reg_mentioned_p (dest, PATTERN (q)))\n-\t\t  {\n-\t\t    PATTERN (q) = replace_rtx (PATTERN (q), dest, src);\n-\n-\t\t    /* We assume that a register is used exactly once per\n-\t\t       insn in the updates below.  If this is not correct,\n-\t\t       no great harm is done.  */\n-\t\t    REG_N_REFS (dregno) -= loop_depth;\n-\t\t    REG_N_REFS (sregno) += loop_depth;\n-\t\t  }\n+\t\t  PATTERN (q) = replace_rtx (PATTERN (q), dest, src);\n \n \n \t      if (GET_CODE (q) == CALL_INSN)\n@@ -755,11 +733,10 @@ optimize_reg_copy_3 (insn, dest, src)\n    instead moving the value to dest directly before the operation.  */\n \n static void\n-copy_src_to_dest (insn, src, dest, loop_depth, old_max_uid)\n+copy_src_to_dest (insn, src, dest, old_max_uid)\n      rtx insn;\n      rtx src;\n      rtx dest;\n-     int loop_depth;\n      int old_max_uid;\n {\n   rtx seq;\n@@ -844,8 +821,7 @@ copy_src_to_dest (insn, src, dest, loop_depth, old_max_uid)\n \n       /* Update the various register tables.  */\n       dest_regno = REGNO (dest);\n-      REG_N_SETS (dest_regno) += loop_depth;\n-      REG_N_REFS (dest_regno) += loop_depth;\n+      REG_N_SETS (dest_regno) ++;\n       REG_LIVE_LENGTH (dest_regno)++;\n       if (REGNO_FIRST_UID (dest_regno) == insn_uid)\n \tREGNO_FIRST_UID (dest_regno) = move_uid;\n@@ -1007,9 +983,6 @@ fixup_match_2 (insn, dst, src, offset, regmove_dump_file)\n \t\t  REG_N_CALLS_CROSSED (REGNO (dst)) += num_calls;\n \t\t}\n \n-\t      REG_N_REFS (REGNO (dst)) += loop_depth;\n-\t      REG_N_REFS (REGNO (src)) -= loop_depth;\n-\n \t      if (regmove_dump_file)\n \t\tfprintf (regmove_dump_file,\n \t\t\t \"Fixed operand of insn %d.\\n\",\n@@ -1109,8 +1082,6 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \n   /* A forward/backward pass.  Replace output operands with input operands.  */\n \n-  loop_depth = 1;\n-\n   for (pass = 0; pass <= 2; pass++)\n     {\n       if (! flag_regmove && pass >= flag_expensive_optimizations)\n@@ -1126,14 +1097,6 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t  rtx set;\n \t  int op_no, match_no;\n \n-\t  if (GET_CODE (insn) == NOTE)\n-\t    {\n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t\tloop_depth++;\n-\t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\t\tloop_depth--;\n-\t    }\n-\n \t  set = single_set (insn);\n \t  if (! set)\n \t    continue;\n@@ -1269,17 +1232,8 @@ regmove_optimize (f, nregs, regmove_dump_file)\n   if (regmove_dump_file)\n     fprintf (regmove_dump_file, \"Starting backward pass...\\n\");\n \n-  loop_depth = 1;\n-\n   for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n     {\n-      if (GET_CODE (insn) == NOTE)\n-\t{\n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\t    loop_depth++;\n-\t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t    loop_depth--;\n-\t}\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n \t  int op_no, match_no;\n@@ -1528,22 +1482,6 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t\tREG_LIVE_LENGTH (srcno) = 2;\n \t\t    }\n \n-\t\t  /* We assume that a register is used exactly once per\n-\t\t     insn in the updates above.  If this is not correct,\n-\t\t     no great harm is done.  */\n-\n-\t\t  REG_N_REFS (dstno) += 2 * loop_depth;\n-\t\t  REG_N_REFS (srcno) -= 2 * loop_depth;\n-\n-                  /* If that was the only time src was set,\n-                     and src was not live at the start of the\n-                     function, we know that we have no more\n-                     references to src; clear REG_N_REFS so it\n-                     won't make reload do any work.  */\n-                  if (REG_N_SETS (REGNO (src)) == 0\n-                      && ! regno_uninitialized (REGNO (src)))\n-                    REG_N_REFS (REGNO (src)) = 0;\n-\n \t\t  if (regmove_dump_file)\n \t\t    fprintf (regmove_dump_file,\n \t\t\t     \"Fixed operand %d of insn %d matching operand %d.\\n\",\n@@ -1556,8 +1494,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t  /* If we weren't able to replace any of the alternatives, try an\n \t     alternative appoach of copying the source to the destination.  */\n \t  if (!success && copy_src != NULL_RTX)\n-\t    copy_src_to_dest (insn, copy_src, copy_dst, loop_depth,\n-\t\t\t      old_max_uid);\n+\t    copy_src_to_dest (insn, copy_src, copy_dst, old_max_uid);\n \n \t}\n     }\n@@ -1683,7 +1620,7 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n   HOST_WIDE_INT insn_const, newconst;\n   rtx overlap = 0; /* need to move insn ? */\n   rtx src_note = find_reg_note (insn, REG_DEAD, src), dst_note;\n-  int length, s_length, true_loop_depth;\n+  int length, s_length;\n \n   /* If SRC is marked as unchanging, we may not change it.\n      ??? Maybe we could get better code by removing the unchanging bit\n@@ -1905,8 +1842,6 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n   if (! success)\n     return 0;\n \n-  true_loop_depth = backward ? 2 - loop_depth : loop_depth;\n-\n   /* Remove the death note for DST from P.  */\n   remove_note (p, dst_note);\n   if (code == MINUS)\n@@ -1918,7 +1853,6 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n \tpost_inc = 0;\n       validate_change (insn, &XEXP (SET_SRC (set), 1), GEN_INT (insn_const), 0);\n       REG_N_SETS (REGNO (src))++;\n-      REG_N_REFS (REGNO (src)) += true_loop_depth;\n       REG_LIVE_LENGTH (REGNO (src))++;\n     }\n   if (overlap)\n@@ -2010,7 +1944,6 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n \t      NOTE_SOURCE_FILE (q) = 0;\n \t      REG_N_SETS (REGNO (src))--;\n \t      REG_N_CALLS_CROSSED (REGNO (src)) -= num_calls2;\n-\t      REG_N_REFS (REGNO (src)) -= true_loop_depth;\n \t      REG_LIVE_LENGTH (REGNO (src)) -= s_length2;\n \t      insn_const = 0;\n \t    }\n@@ -2104,23 +2037,6 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n       if (REG_LIVE_LENGTH (REGNO (dst)) < 2)\n \tREG_LIVE_LENGTH (REGNO (dst)) = 2;\n     }\n-\n-  /* We assume that a register is used exactly once per\n-      insn in the updates above.  If this is not correct,\n-      no great harm is done.  */\n-\n-  REG_N_REFS (REGNO (src)) += 2 * true_loop_depth;\n-  REG_N_REFS (REGNO (dst)) -= 2 * true_loop_depth;\n-\n-  /* If that was the only time dst was set,\n-     and dst was not live at the start of the\n-     function, we know that we have no more\n-     references to dst; clear REG_N_REFS so it\n-     won't make reload do any work.  */\n-  if (REG_N_SETS (REGNO (dst)) == 0\n-      && ! regno_uninitialized (REGNO (dst)))\n-    REG_N_REFS (REGNO (dst)) = 0;\n-\n   if (regmove_dump_file)\n     fprintf (regmove_dump_file,\n \t     \"Fixed operand %d of insn %d matching operand %d.\\n\","}]}