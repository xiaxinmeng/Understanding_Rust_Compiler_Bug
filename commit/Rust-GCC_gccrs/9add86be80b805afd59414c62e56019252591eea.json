{"sha": "9add86be80b805afd59414c62e56019252591eea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFkZDg2YmU4MGI4MDVhZmQ1OTQxNGM2MmU1NjAxOTI1MjU5MWVlYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2017-10-05T17:20:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-10-05T17:20:30Z"}, "message": "compiler: centralize all symbol name handling\n    \n    Consolidate all symbol name handling into the new file names.cc.  This\n    is intended to define all the names that will appear in the generated\n    assembly code.  Names that will not appear in the assembly code, such\n    as local variable names or label names, remain where they are.\n    \n    This consolidation is not intended to change any of the existing\n    symbol names.  Tested by building without and without this patch and\n    comparing the libgo symbol table.\n    \n    Reviewed-on: https://go-review.googlesource.com/68310\n\n\t* Make-lang.in (GO_OBJS): Add go/names.o.\n\nFrom-SVN: r253458", "tree": {"sha": "97cc7dbe9cd1f0eea5636c8d326c1e4e0badb327", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97cc7dbe9cd1f0eea5636c8d326c1e4e0badb327"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9add86be80b805afd59414c62e56019252591eea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9add86be80b805afd59414c62e56019252591eea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9add86be80b805afd59414c62e56019252591eea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9add86be80b805afd59414c62e56019252591eea/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a978e26b8338e044dbc5e0f4624f2fe047eec5df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a978e26b8338e044dbc5e0f4624f2fe047eec5df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a978e26b8338e044dbc5e0f4624f2fe047eec5df"}], "stats": {"total": 1951, "additions": 1145, "deletions": 806}, "files": [{"sha": "3918fa814d7357abb7c9c9b8afbd2e16188f7aac", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=9add86be80b805afd59414c62e56019252591eea", "patch": "@@ -1,3 +1,7 @@\n+2017-10-05  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* Make-lang.in (GO_OBJS): Add go/names.o.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "60fecad0c8fab1f36872704032d3d91656e45cfa", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=9add86be80b805afd59414c62e56019252591eea", "patch": "@@ -68,6 +68,7 @@ GO_OBJS = \\\n \tgo/import.o \\\n \tgo/import-archive.o \\\n \tgo/lex.o \\\n+\tgo/names.o \\\n \tgo/parse.o \\\n \tgo/runtime.o \\\n \tgo/statements.o \\"}, {"sha": "3e33c626cc8ad5846aee1551208fdea8d75b70df", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=9add86be80b805afd59414c62e56019252591eea", "patch": "@@ -1,4 +1,4 @@\n-5989ef1cd0add98f107839759a5bc57f34354d39\n+048914caa26b34eebabd0423ed48ee3ac34c919c\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "dea21188c92eef041547033fe06cc144d39037c4", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=9add86be80b805afd59414c62e56019252591eea", "patch": "@@ -575,7 +575,7 @@ debug_function_name(Named_object* fn)\n \n   // Extract #.\n   std::string name = Gogo::unpack_hidden_name(fn->name());\n-  int closure_num = (int)strtol(name.substr(6).c_str(), NULL, 0);\n+  int closure_num = Gogo::nested_function_num(fn->name());\n   closure_num++;\n \n   name = Gogo::unpack_hidden_name(enclosing->name());"}, {"sha": "8337cbeb60246b850a8bc087176fe5cd19931651", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=9add86be80b805afd59414c62e56019252591eea", "patch": "@@ -1299,28 +1299,12 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n     return context->backend()->var_expression(this->dvar_, VE_rvalue, loc);\n \n   Gogo* gogo = context->gogo();\n-  std::string var_name;\n+  std::string var_name(gogo->function_descriptor_name(no));\n   bool is_descriptor = false;\n   if (no->is_function_declaration()\n       && !no->func_declaration_value()->asm_name().empty()\n       && Linemap::is_predeclared_location(no->location()))\n-    {\n-      if (no->func_declaration_value()->asm_name().substr(0, 8) != \"runtime.\")\n-\tvar_name = no->func_declaration_value()->asm_name() + \"_descriptor\";\n-      else\n-\tvar_name = no->func_declaration_value()->asm_name() + \"$descriptor\";\n-      is_descriptor = true;\n-    }\n-  else\n-    {\n-      if (no->package() == NULL)\n-\tvar_name = gogo->pkgpath_symbol();\n-      else\n-\tvar_name = no->package()->pkgpath_symbol();\n-      var_name.push_back('.');\n-      var_name.append(Gogo::unpack_hidden_name(no->name()));\n-      var_name.append(\"$descriptor\");\n-    }\n+    is_descriptor = true;\n \n   Btype* btype = this->type()->get_backend(gogo);\n \n@@ -4348,27 +4332,23 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t    }\n \t}\n \n-      static unsigned int counter;\n-      char buf[100];\n       if (this->is_gc_root_ || this->is_slice_init_)\n \t{\n+\t  std::string var_name;\n \t  bool copy_to_heap = false;\n \t  if (this->is_gc_root_)\n \t    {\n \t      // Build a decl for a GC root variable.  GC roots are mutable, so\n \t      // they cannot be represented as an immutable_struct in the\n \t      // backend.\n-\t      static unsigned int root_counter;\n-\t      snprintf(buf, sizeof buf, \"gc%u\", root_counter);\n-\t      ++root_counter;\n+\t      var_name = gogo->gc_root_name();\n \t    }\n \t  else\n \t    {\n \t      // Build a decl for a slice value initializer.  An immutable slice\n \t      // value initializer may have to be copied to the heap if it\n \t      // contains pointers in a non-constant context.\n-\t      snprintf(buf, sizeof buf, \"C%u\", counter);\n-\t      ++counter;\n+\t      var_name = gogo->initializer_name();\n \n \t      Array_type* at = this->expr_->type()->array_type();\n \t      go_assert(at != NULL);\n@@ -4379,12 +4359,12 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t      // read-only, because the program is permitted to change it.\n \t      copy_to_heap = context->function() != NULL;\n \t    }\n-          std::string asm_name(go_selectively_encode_id(buf));\n+\t  std::string asm_name(go_selectively_encode_id(var_name));\n \t  Bvariable* implicit =\n-              gogo->backend()->implicit_variable(buf, asm_name,\n+              gogo->backend()->implicit_variable(var_name, asm_name,\n                                                  btype, true, copy_to_heap,\n                                                  false, 0);\n-\t  gogo->backend()->implicit_variable_set_init(implicit, buf, btype,\n+\t  gogo->backend()->implicit_variable_set_init(implicit, var_name, btype,\n \t\t\t\t\t\t      true, copy_to_heap, false,\n \t\t\t\t\t\t      bexpr);\n \t  bexpr = gogo->backend()->var_expression(implicit, VE_rvalue, loc);\n@@ -4407,16 +4387,13 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t\t|| this->expr_->string_expression() != NULL)\n \t       && this->expr_->is_static_initializer())\n         {\n-\t  // Build a decl for a constant constructor.\n-          snprintf(buf, sizeof buf, \"C%u\", counter);\n-          ++counter;\n-\n-          std::string asm_name(go_selectively_encode_id(buf));\n+\t  std::string var_name(gogo->initializer_name());\n+\t  std::string asm_name(go_selectively_encode_id(var_name));\n           Bvariable* decl =\n-              gogo->backend()->immutable_struct(buf, asm_name,\n+              gogo->backend()->immutable_struct(var_name, asm_name,\n                                                 true, false, btype, loc);\n-          gogo->backend()->immutable_struct_set_init(decl, buf, true, false,\n-                                                     btype, loc, bexpr);\n+          gogo->backend()->immutable_struct_set_init(decl, var_name, true,\n+\t\t\t\t\t\t     false, btype, loc, bexpr);\n           bexpr = gogo->backend()->var_expression(decl, VE_rvalue, loc);\n         }\n \n@@ -15403,10 +15380,9 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n   const Typed_identifier_list* interface_methods = this->itype_->methods();\n   go_assert(!interface_methods->empty());\n \n-  std::string mangled_name = ((this->is_pointer_ ? \"__go_pimt__\" : \"__go_imt_\")\n-\t\t\t      + this->itype_->mangled_name(gogo)\n-\t\t\t      + \"__\"\n-\t\t\t      + this->type_->mangled_name(gogo));\n+  std::string mangled_name =\n+    gogo->interface_method_table_name(this->itype_, this->type_,\n+\t\t\t\t      this->is_pointer_);\n \n   // Set is_public if we are converting a named type to an interface\n   // type that is defined in the same package as the named type, and"}, {"sha": "da8f3c584eb995dce86534343d1e75d536303ee4", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 26, "deletions": 175, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=9add86be80b805afd59414c62e56019252591eea", "patch": "@@ -868,32 +868,6 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n   init_stmts.push_back(this->backend()->expression_statement(init_bfn, bcall));\n }\n \n-// Get the name to use for the import control function.  If there is a\n-// global function or variable, then we know that that name must be\n-// unique in the link, and we use it as the basis for our name.\n-\n-const std::string&\n-Gogo::get_init_fn_name()\n-{\n-  if (this->init_fn_name_.empty())\n-    {\n-      go_assert(this->package_ != NULL);\n-      if (this->is_main_package())\n-\t{\n-\t  // Use a name which the runtime knows.\n-\t  this->init_fn_name_ = \"__go_init_main\";\n-\t}\n-      else\n-\t{\n-\t  std::string s = this->pkgpath_symbol();\n-\t  s.append(\"..import\");\n-\t  this->init_fn_name_ = s;\n-\t}\n-    }\n-\n-  return this->init_fn_name_;\n-}\n-\n // Build the decl for the initialization function.\n \n Named_object*\n@@ -1774,11 +1748,7 @@ Gogo::start_function(const std::string& name, Function_type* type,\n \t\t    \"func init must have no arguments and no return values\");\n       // There can be multiple \"init\" functions, so give them each a\n       // different name.\n-      static int init_count;\n-      char buf[30];\n-      snprintf(buf, sizeof buf, \".$init%d\", init_count);\n-      ++init_count;\n-      nested_name = buf;\n+      nested_name = this->init_function_name();\n       pname = &nested_name;\n       is_init = true;\n     }\n@@ -1787,22 +1757,15 @@ Gogo::start_function(const std::string& name, Function_type* type,\n   else\n     {\n       // Invent a name for a nested function.\n-      static int nested_count;\n-      char buf[30];\n-      snprintf(buf, sizeof buf, \".$nested%d\", nested_count);\n-      ++nested_count;\n-      nested_name = buf;\n+      nested_name = this->nested_function_name();\n       pname = &nested_name;\n     }\n \n   Named_object* ret;\n   if (Gogo::is_sink_name(*pname))\n     {\n-      static int sink_count;\n-      char buf[30];\n-      snprintf(buf, sizeof buf, \".$sink%d\", sink_count);\n-      ++sink_count;\n-      ret = Named_object::make_function(buf, NULL, function);\n+      std::string sname(this->sink_function_name());\n+      ret = Named_object::make_function(sname, NULL, function);\n       ret->func_value()->set_is_sink();\n \n       if (!type->is_method())\n@@ -1845,11 +1808,8 @@ Gogo::start_function(const std::string& name, Function_type* type,\n \t{\n \t  // Redefinition error.  Invent a name to avoid knockon\n \t  // errors.\n-\t  static int redefinition_count;\n-\t  char buf[30];\n-\t  snprintf(buf, sizeof buf, \".$redefined%d\", redefinition_count);\n-\t  ++redefinition_count;\n-\t  ret = this->package_->bindings()->add_function(buf, NULL, function);\n+\t  std::string rname(this->redefined_function_name());\n+\t  ret = this->package_->bindings()->add_function(rname, NULL, function);\n \t}\n     }\n   else\n@@ -2274,47 +2234,6 @@ Gogo::record_interface_type(Interface_type* itype)\n   this->interface_types_.push_back(itype);\n }\n \n-// Return an erroneous name that indicates that an error has already\n-// been reported.\n-\n-std::string\n-Gogo::erroneous_name()\n-{\n-  static int erroneous_count;\n-  char name[50];\n-  snprintf(name, sizeof name, \"$erroneous%d\", erroneous_count);\n-  ++erroneous_count;\n-  return name;\n-}\n-\n-// Return whether a name is an erroneous name.\n-\n-bool\n-Gogo::is_erroneous_name(const std::string& name)\n-{\n-  return name.compare(0, 10, \"$erroneous\") == 0;\n-}\n-\n-// Return a name for a thunk object.\n-\n-std::string\n-Gogo::thunk_name()\n-{\n-  static int thunk_count;\n-  char thunk_name[50];\n-  snprintf(thunk_name, sizeof thunk_name, \"$thunk%d\", thunk_count);\n-  ++thunk_count;\n-  return thunk_name;\n-}\n-\n-// Return whether a function is a thunk.\n-\n-bool\n-Gogo::is_thunk(const Named_object* no)\n-{\n-  return no->name().compare(0, 6, \"$thunk\") == 0;\n-}\n-\n // Define the global names.  We do this only after parsing all the\n // input files, because the program might define the global names\n // itself.\n@@ -4195,10 +4114,10 @@ Build_recover_thunks::function(Named_object* orig_no)\n   if (orig_fntype->is_varargs())\n     new_fntype->set_is_varargs();\n \n-  std::string name = orig_no->name();\n+  Type* rtype = NULL;\n   if (orig_fntype->is_method())\n-    name += \"$\" + orig_fntype->receiver()->type()->mangled_name(gogo);\n-  name += \"$recover\";\n+    rtype = orig_fntype->receiver()->type();\n+  std::string name(gogo->recover_thunk_name(orig_no->name(), rtype));\n   Named_object *new_no = gogo->start_function(name, new_fntype, false,\n \t\t\t\t\t      location);\n   Function *new_func = new_no->func_value();\n@@ -5449,29 +5368,10 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n         {\n \t  if (!this->is_unnamed_type_stub_method_)\n \t    is_visible = true;\n-          std::string pkgpath = gogo->pkgpath_symbol();\n-          if (this->type_->is_method()\n-              && Gogo::is_hidden_name(no->name())\n-              && Gogo::hidden_name_pkgpath(no->name()) != gogo->pkgpath())\n-            {\n-              // This is a method we created for an unexported\n-              // method of an imported embedded type.  We need to\n-              // use the pkgpath of the imported package to avoid\n-              // a possible name collision.  See bug478 for a test\n-              // case.\n-\t      std::string p = Gogo::hidden_name_pkgpath(no->name());\n-\t      pkgpath = gogo->pkgpath_symbol_for_package(p);\n-            }\n-\n-          asm_name = pkgpath;\n-          asm_name.append(1, '.');\n-          asm_name.append(Gogo::unpack_hidden_name(no->name()));\n-          if (this->type_->is_method())\n-            {\n-              asm_name.append(1, '.');\n-              Type* rtype = this->type_->receiver()->type();\n-              asm_name.append(rtype->mangled_name(gogo));\n-            }\n+\t  Type* rtype = NULL;\n+\t  if (this->type_->is_method())\n+\t    rtype = this->type_->receiver()->type();\n+\t  asm_name = gogo->function_asm_name(no->name(), NULL, rtype);\n         }\n \n       if (!this->asm_name_.empty())\n@@ -5510,8 +5410,8 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n \tdisable_split_stack = true;\n \n       // Encode name if asm_name not already set at this point\n-      if (asm_name.empty() && go_id_needs_encoding(no->get_id(gogo)))\n-        asm_name = go_encode_id(no->get_id(gogo));\n+      if (asm_name.empty())\n+\tasm_name = gogo->unexported_function_asm_name(no->name());\n \n       // This should go into a unique section if that has been\n       // requested elsewhere, or if this is a nointerface function.\n@@ -5553,30 +5453,12 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n \n       std::string asm_name;\n       if (this->asm_name_.empty())\n-        {\n-          asm_name = (no->package() == NULL\n-\t\t      ? gogo->pkgpath_symbol()\n-\t\t      : no->package()->pkgpath_symbol());\n-\t  if (this->fntype_->is_method()\n-\t      && Gogo::is_hidden_name(no->name())\n-\t      && Gogo::hidden_name_pkgpath(no->name()) != gogo->pkgpath())\n-\t    {\n-\t      // This is a method created for an unexported method of\n-\t      // an imported embedded type.  Use the pkgpath of the\n-\t      // imported package.  This matches code in\n-\t      // Function::get_or_make_decl, above.\n-\t      std::string p = Gogo::hidden_name_pkgpath(no->name());\n-\t      asm_name = gogo->pkgpath_symbol_for_package(p);\n-\t    }\n-          asm_name.append(1, '.');\n-          asm_name.append(Gogo::unpack_hidden_name(no->name()));\n-          if (this->fntype_->is_method())\n-            {\n-              asm_name.append(1, '.');\n-              Type* rtype = this->fntype_->receiver()->type();\n-              asm_name.append(rtype->mangled_name(gogo));\n-            }\n-        }\n+\t{\n+\t  Type* rtype = NULL;\n+\t  if (this->fntype_->is_method())\n+\t    rtype = this->fntype_->receiver()->type();\n+\t  asm_name = gogo->function_asm_name(no->name(), no->package(), rtype);\n+\t}\n       else if (go_id_needs_encoding(no->get_id(gogo)))\n         asm_name = go_encode_id(no->get_id(gogo));\n \n@@ -6815,18 +6697,8 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t\t\t\t   : gogo->package_name());\n \t      var_name.push_back('.');\n \t      var_name.append(n);\n-              std::string asm_name;\n-              if (Gogo::is_hidden_name(name))\n-                asm_name = var_name;\n-              else\n-                {\n-                  asm_name = package != NULL\n-                      ? package->pkgpath_symbol()\n-                      : gogo->pkgpath_symbol();\n-                  asm_name.push_back('.');\n-                  asm_name.append(n);\n-                }\n-\t      asm_name = go_encode_id(asm_name);\n+\n+              std::string asm_name(gogo->global_var_asm_name(name, package));\n \n \t      bool is_hidden = Gogo::is_hidden_name(name);\n \t      // Hack to export runtime.writeBarrier.  FIXME.\n@@ -7416,23 +7288,18 @@ Named_object::get_backend_variable(Gogo* gogo, Named_object* function)\n     go_unreachable();\n }\n \n-\n // Return the external identifier for this object.\n \n std::string\n Named_object::get_id(Gogo* gogo)\n {\n-  go_assert(!this->is_variable() && !this->is_result_variable());\n+  go_assert(!this->is_variable()\n+\t    && !this->is_result_variable()\n+\t    && !this->is_type());\n   std::string decl_name;\n   if (this->is_function_declaration()\n       && !this->func_declaration_value()->asm_name().empty())\n     decl_name = this->func_declaration_value()->asm_name();\n-  else if (this->is_type()\n-\t   && Linemap::is_predeclared_location(this->type_value()->location()))\n-    {\n-      // We don't need the package name for builtin types.\n-      decl_name = Gogo::unpack_hidden_name(this->name_);\n-    }\n   else\n     {\n       std::string package_name;\n@@ -7466,22 +7333,6 @@ Named_object::get_id(Gogo* gogo)\n \t  decl_name.append(fntype->receiver()->type()->mangled_name(gogo));\n \t}\n     }\n-  if (this->is_type())\n-    {\n-      unsigned int index;\n-      const Named_object* in_function = this->type_value()->in_function(&index);\n-      if (in_function != NULL)\n-\t{\n-\t  decl_name += '$' + Gogo::unpack_hidden_name(in_function->name());\n-\t  if (index > 0)\n-\t    {\n-\t      char buf[30];\n-\t      snprintf(buf, sizeof buf, \"%u\", index);\n-\t      decl_name += '$';\n-\t      decl_name += buf;\n-\t    }\n-\t}\n-    }\n   return decl_name;\n }\n "}, {"sha": "018aca5e2ef20cdfa6adfdc96701f03e8cbeeb73", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 102, "deletions": 20, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=9add86be80b805afd59414c62e56019252591eea", "patch": "@@ -506,26 +506,6 @@ class Gogo\n   void\n   mark_locals_used();\n \n-  // Return a name to use for an error case.  This should only be used\n-  // after reporting an error, and is used to avoid useless knockon\n-  // errors.\n-  static std::string\n-  erroneous_name();\n-\n-  // Return whether the name indicates an error.\n-  static bool\n-  is_erroneous_name(const std::string&);\n-\n-  // Return a name to use for a thunk function.  A thunk function is\n-  // one we create during the compilation, for a go statement or a\n-  // defer statement or a method expression.\n-  static std::string\n-  thunk_name();\n-\n-  // Return whether an object is a thunk.\n-  static bool\n-  is_thunk(const Named_object*);\n-\n   // Note that we've seen an interface type.  This is used to build\n   // all required interface method tables.\n   void\n@@ -781,10 +761,112 @@ class Gogo\n   Expression*\n   allocate_memory(Type *type, Location);\n \n+  // Return the assembler name to use for an exported function, a\n+  // method, or a function/method declaration.\n+  std::string\n+  function_asm_name(const std::string& go_name, const Package*,\n+\t\t    const Type* receiver);\n+\n+  // Return the assembler name to use for an unexported function.\n+  std::string\n+  unexported_function_asm_name(const std::string& go_name);\n+\n+  // Return the name to use for a function descriptor.\n+  std::string\n+  function_descriptor_name(Named_object*);\n+\n+  // Return the name to use for a generated stub method.\n+  std::string\n+  stub_method_name(const std::string& method_name);\n+\n+  // Return the names of the hash and equality functions for TYPE.\n+  void\n+  specific_type_function_names(const Type*, const Named_type*,\n+\t\t\t       std::string* hash_name,\n+\t\t\t       std::string* equal_name);\n+\n+  // Return the assembler name to use for a global variable.\n+  std::string\n+  global_var_asm_name(const std::string& go_name, const Package*);\n+\n+  // Return a name to use for an error case.  This should only be used\n+  // after reporting an error, and is used to avoid useless knockon\n+  // errors.\n+  static std::string\n+  erroneous_name();\n+\n+  // Return whether the name indicates an error.\n+  static bool\n+  is_erroneous_name(const std::string&);\n+\n+  // Return a name to use for a thunk function.  A thunk function is\n+  // one we create during the compilation, for a go statement or a\n+  // defer statement or a method expression.\n+  static std::string\n+  thunk_name();\n+\n+  // Return whether an object is a thunk.\n+  static bool\n+  is_thunk(const Named_object*);\n+\n+  // Return the name to use for an init function.\n+  std::string\n+  init_function_name();\n+\n+  // Return the name to use for a nested function.\n+  static std::string\n+  nested_function_name();\n+\n+  // Return the index of a nested function name.\n+  static int\n+  nested_function_num(const std::string&);\n+\n+  // Return the name to use for a sink funciton.\n+  std::string\n+  sink_function_name();\n+\n+  // Return the name to use for an (erroneous) redefined function.\n+  std::string\n+  redefined_function_name();\n+\n+  // Return the name for use for a recover thunk.\n+  std::string\n+  recover_thunk_name(const std::string& name, const Type* rtype);\n+\n+  // Return the name to use for the GC root variable.\n+  std::string\n+  gc_root_name();\n+\n+  // Return the name to use for a composite literal or string\n+  // initializer.\n+  std::string\n+  initializer_name();\n+\n+  // Return the name of the variable used to represent the zero value\n+  // of a map.\n+  std::string\n+  map_zero_value_name();\n+\n   // Get the name of the magic initialization function.\n   const std::string&\n   get_init_fn_name();\n \n+  // Return the name for a type descriptor symbol.\n+  std::string\n+  type_descriptor_name(Type*, Named_type*);\n+\n+  // Return the assembler name for the GC symbol for a type.\n+  std::string\n+  gc_symbol_name(Type*);\n+\n+  // Return the assembler name for a ptrmask variable.\n+  std::string\n+  ptrmask_symbol_name(const std::string& ptrmask_sym_name);\n+\n+  // Return the name to use for an interface method table.\n+  std::string\n+  interface_method_table_name(Interface_type*, Type*, bool is_pointer);\n+\n  private:\n   // During parsing, we keep a stack of functions.  Each function on\n   // the stack is one that we are currently parsing.  For each"}, {"sha": "48ffec08d9e0ceb7db93a48671caeaacbe3e71d8", "filename": "gcc/go/gofrontend/names.cc", "status": "added", "additions": 825, "deletions": 0, "changes": 825, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fnames.cc?ref=9add86be80b805afd59414c62e56019252591eea", "patch": "@@ -0,0 +1,825 @@\n+// names.cc -- Names used by gofrontend generated code.\n+\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"gogo.h\"\n+#include \"go-encode-id.h\"\n+#include \"types.h\"\n+#include \"expressions.h\"\n+\n+// This file contains functions that generate names that appear in the\n+// assembly code.  This is not used for names that appear only in the\n+// debug info.\n+\n+// Return the assembler name to use for an exported function, a\n+// method, or a function/method declaration.  This is not called if\n+// the function has been given an explicit name via a magic //extern\n+// or //go:linkname comment.  GO_NAME is the name that appears in the\n+// Go code.  PACKAGE is the package where the function is defined, and\n+// is NULL for the package being compiled.  For a method, RTYPE is\n+// the method's receiver type; for a function, RTYPE is NULL.\n+\n+std::string\n+Gogo::function_asm_name(const std::string& go_name, const Package* package,\n+\t\t\tconst Type* rtype)\n+{\n+  std::string ret = (package == NULL\n+\t\t     ? this->pkgpath_symbol()\n+\t\t     : package->pkgpath_symbol());\n+\n+  if (rtype != NULL\n+      && Gogo::is_hidden_name(go_name)\n+      && Gogo::hidden_name_pkgpath(go_name) != this->pkgpath())\n+    {\n+      // This is a method created for an unexported method of an\n+      // imported embedded type.  Use the pkgpath of the imported\n+      // package.\n+      std::string p = Gogo::hidden_name_pkgpath(go_name);\n+      ret = this->pkgpath_symbol_for_package(p);\n+    }\n+\n+  ret.append(1, '.');\n+  ret.append(Gogo::unpack_hidden_name(go_name));\n+\n+  if (rtype != NULL)\n+    {\n+      ret.append(1, '.');\n+      ret.append(rtype->mangled_name(this));\n+    }\n+\n+  return go_encode_id(ret);\n+}\n+\n+// Return the assembler name to use for an unexported function.\n+// FIXME: This should probably be removed and the callers changed to\n+// simply call function_name.\n+\n+std::string\n+Gogo::unexported_function_asm_name(const std::string& go_name)\n+{\n+  std::string ret = this->package_name();\n+  ret.append(1, '.');\n+  ret.append(Gogo::unpack_hidden_name(go_name));\n+  return go_encode_id(ret);\n+}\n+\n+// Return the name to use for a function descriptor.  These symbols\n+// are globally visible.\n+\n+std::string\n+Gogo::function_descriptor_name(Named_object* no)\n+{\n+  std::string var_name;\n+  if (no->is_function_declaration()\n+      && !no->func_declaration_value()->asm_name().empty()\n+      && Linemap::is_predeclared_location(no->location()))\n+    {\n+      if (no->func_declaration_value()->asm_name().substr(0, 8) != \"runtime.\")\n+\tvar_name = no->func_declaration_value()->asm_name() + \"_descriptor\";\n+      else\n+\tvar_name = no->func_declaration_value()->asm_name() + \"$descriptor\";\n+    }\n+  else\n+    {\n+      if (no->package() == NULL)\n+\tvar_name = this->pkgpath_symbol();\n+      else\n+\tvar_name = no->package()->pkgpath_symbol();\n+      var_name.push_back('.');\n+      var_name.append(Gogo::unpack_hidden_name(no->name()));\n+      var_name.append(\"$descriptor\");\n+    }\n+  return var_name;\n+}\n+\n+// Return the name to use for a generated stub method.  MNAME is the\n+// method name.  These functions are globally visible.  Note that this\n+// is the function name that corresponds to the name used for the\n+// method in Go source code, if this stub method were written in Go.\n+// The assembler name will be generated by Gogo::function_asm_name,\n+// and because this is a method that name will include the receiver\n+// type.\n+\n+std::string\n+Gogo::stub_method_name(const std::string& mname)\n+{\n+  return mname + \"$stub\";\n+}\n+\n+// Return the names of the hash and equality functions for TYPE.  If\n+// NAME is not NULL it is the name of the type.  Set *HASH_NAME and\n+// *EQUAL_NAME.\n+\n+void\n+Gogo::specific_type_function_names(const Type* type, const Named_type* name,\n+\t\t\t\t   std::string *hash_name,\n+\t\t\t\t   std::string *equal_name)\n+{\n+  std::string base_name;\n+  if (name == NULL)\n+    {\n+      // Mangled names can have '.' if they happen to refer to named\n+      // types in some way.  That's fine if this is simply a named\n+      // type, but otherwise it will confuse the code that builds\n+      // function identifiers.  Remove '.' when necessary.\n+      base_name = type->mangled_name(this);\n+      size_t i;\n+      while ((i = base_name.find('.')) != std::string::npos)\n+\tbase_name[i] = '$';\n+      base_name = this->pack_hidden_name(base_name, false);\n+    }\n+  else\n+    {\n+      // This name is already hidden or not as appropriate.\n+      base_name = name->name();\n+      unsigned int index;\n+      const Named_object* in_function = name->in_function(&index);\n+      if (in_function != NULL)\n+\t{\n+\t  base_name.append(1, '$');\n+\t  const Typed_identifier* rcvr =\n+\t    in_function->func_value()->type()->receiver();\n+\t  if (rcvr != NULL)\n+\t    {\n+\t      Named_type* rcvr_type = rcvr->type()->deref()->named_type();\n+\t      base_name.append(Gogo::unpack_hidden_name(rcvr_type->name()));\n+\t      base_name.append(1, '$');\n+\t    }\n+\t  base_name.append(Gogo::unpack_hidden_name(in_function->name()));\n+\t  if (index > 0)\n+\t    {\n+\t      char buf[30];\n+\t      snprintf(buf, sizeof buf, \"%u\", index);\n+\t      base_name += '$';\n+\t      base_name += buf;\n+\t    }\n+\t}\n+    }\n+  *hash_name = base_name + \"$hash\";\n+  *equal_name = base_name + \"$equal\";\n+}\n+\n+// Return the assembler name to use for a global variable.  GO_NAME is\n+// the name that appears in the Go code.  PACKAGE is the package where\n+// the variable is defined, and is NULL for the package being\n+// compiled.\n+\n+std::string\n+Gogo::global_var_asm_name(const std::string& go_name, const Package* package)\n+{\n+  // FIXME: Using package_name for hidden names and pkgpath_symbol for\n+  // non-hidden names doesn't make sense, but it dates back to the\n+  // first public commit of the gofrontend repo.\n+  std::string ret;\n+  if (Gogo::is_hidden_name(go_name))\n+    ret = (package != NULL\n+\t   ? package->package_name()\n+\t   : this->package_name());\n+  else\n+    ret = (package != NULL\n+\t   ? package->pkgpath_symbol()\n+\t   : this->pkgpath_symbol());\n+  ret.push_back('.');\n+  ret.append(Gogo::unpack_hidden_name(go_name));\n+  return go_encode_id(ret);\n+}\n+\n+// Return an erroneous name that indicates that an error has already\n+// been reported.\n+\n+std::string\n+Gogo::erroneous_name()\n+{\n+  static int erroneous_count;\n+  char name[50];\n+  snprintf(name, sizeof name, \"$erroneous%d\", erroneous_count);\n+  ++erroneous_count;\n+  return name;\n+}\n+\n+// Return whether a name is an erroneous name.\n+\n+bool\n+Gogo::is_erroneous_name(const std::string& name)\n+{\n+  return name.compare(0, 10, \"$erroneous\") == 0;\n+}\n+\n+// Return a name for a thunk object.\n+\n+std::string\n+Gogo::thunk_name()\n+{\n+  static int thunk_count;\n+  char thunk_name[50];\n+  snprintf(thunk_name, sizeof thunk_name, \"$thunk%d\", thunk_count);\n+  ++thunk_count;\n+  return thunk_name;\n+}\n+\n+// Return whether a function is a thunk.\n+\n+bool\n+Gogo::is_thunk(const Named_object* no)\n+{\n+  return no->name().compare(0, 6, \"$thunk\") == 0;\n+}\n+\n+// Return the name to use for an init function.  There can be multiple\n+// functions named \"init\" so each one needs a different name.\n+\n+std::string\n+Gogo::init_function_name()\n+{\n+  static int init_count;\n+  char buf[30];\n+  snprintf(buf, sizeof buf, \".$init%d\", init_count);\n+  ++init_count;\n+  return buf;\n+}\n+\n+// Return the name to use for a nested function.\n+\n+std::string\n+Gogo::nested_function_name()\n+{\n+  static int nested_count;\n+  char buf[30];\n+  snprintf(buf, sizeof buf, \".$nested%d\", nested_count);\n+  ++nested_count;\n+  return buf;\n+}\n+\n+// Return the index of a nested function name.\n+\n+int\n+Gogo::nested_function_num(const std::string& name)\n+{\n+  std::string n(Gogo::unpack_hidden_name(name));\n+  go_assert(n.compare(0, 8, \".$nested\") == 0);\n+  return strtol(n.substr(8).c_str(), NULL, 0);\n+}\n+\n+// Return the name to use for a sink function, a function whose name\n+// is simply underscore.  We don't really need these functions but we\n+// do have to generate them for error checking.\n+\n+std::string\n+Gogo::sink_function_name()\n+{\n+  static int sink_count;\n+  char buf[30];\n+  snprintf(buf, sizeof buf, \".$sink%d\", sink_count);\n+  ++sink_count;\n+  return buf;\n+}\n+\n+// Return the name to use for a redefined function.  These functions\n+// are erroneous but we still generate them for further error\n+// checking.\n+\n+std::string\n+Gogo::redefined_function_name()\n+{\n+  static int redefinition_count;\n+  char buf[30];\n+  snprintf(buf, sizeof buf, \".$redefined%d\", redefinition_count);\n+  ++redefinition_count;\n+  return buf;\n+}\n+\n+// Return the name to use for a recover thunk for the function NAME.\n+// If the function is a method, RTYPE is the receiver type.\n+\n+std::string\n+Gogo::recover_thunk_name(const std::string& name, const Type* rtype)\n+{\n+  std::string ret(name);\n+  if (rtype != NULL)\n+    {\n+      ret.push_back('$');\n+      ret.append(rtype->mangled_name(this));\n+    }\n+  ret.append(\"$recover\");\n+  return ret;\n+}\n+\n+// Return the name to use for a GC root variable.  The GC root\n+// variable is a composite literal that is passed to\n+// runtime.registerGCRoots.  There is at most one of these variables\n+// per compilation.\n+\n+std::string\n+Gogo::gc_root_name()\n+{\n+  return \"gc0\";\n+}\n+\n+// Return the name to use for a composite literal or string\n+// initializer.  This is a local name never referenced outside of this\n+// file.\n+\n+std::string\n+Gogo::initializer_name()\n+{\n+  static unsigned int counter;\n+  char buf[30];\n+  snprintf(buf, sizeof buf, \"C%u\", counter);\n+  ++counter;\n+  return buf;\n+}\n+\n+// Return the name of the variable used to represent the zero value of\n+// a map.  This is a globally visible common symbol.\n+\n+std::string\n+Gogo::map_zero_value_name()\n+{\n+  return \"go$zerovalue\";\n+}\n+\n+// Return the name to use for the import control function.\n+\n+const std::string&\n+Gogo::get_init_fn_name()\n+{\n+  if (this->init_fn_name_.empty())\n+    {\n+      go_assert(this->package_ != NULL);\n+      if (this->is_main_package())\n+\t{\n+\t  // Use a name that the runtime knows.\n+\t  this->init_fn_name_ = \"__go_init_main\";\n+\t}\n+      else\n+\t{\n+\t  std::string s = this->pkgpath_symbol();\n+\t  s.append(\"..import\");\n+\t  this->init_fn_name_ = s;\n+\t}\n+    }\n+\n+  return this->init_fn_name_;\n+}\n+\n+// Return a mangled name for a type.  These names appear in symbol\n+// names in the assembler file for things like type descriptors and\n+// methods.\n+\n+std::string\n+Type::mangled_name(Gogo* gogo) const\n+{\n+  std::string ret;\n+\n+  // The do_mangled_name virtual function should set RET to the\n+  // mangled name.  For a composite type it should append a code for\n+  // the composition and then call do_mangled_name on the components.\n+  this->do_mangled_name(gogo, &ret);\n+\n+  return ret;\n+}\n+\n+// The mangled name is implemented as a method on each instance of\n+// Type.\n+\n+void\n+Error_type::do_mangled_name(Gogo*, std::string* ret) const\n+{\n+  ret->push_back('E');\n+}\n+\n+void\n+Void_type::do_mangled_name(Gogo*, std::string* ret) const\n+{\n+  ret->push_back('v');\n+}\n+\n+void\n+Boolean_type::do_mangled_name(Gogo*, std::string* ret) const\n+{\n+  ret->push_back('b');\n+}\n+\n+void\n+Integer_type::do_mangled_name(Gogo*, std::string* ret) const\n+{\n+  char buf[100];\n+  snprintf(buf, sizeof buf, \"i%s%s%de\",\n+\t   this->is_abstract_ ? \"a\" : \"\",\n+\t   this->is_unsigned_ ? \"u\" : \"\",\n+\t   this->bits_);\n+  ret->append(buf);\n+}\n+\n+void\n+Float_type::do_mangled_name(Gogo*, std::string* ret) const\n+{\n+  char buf[100];\n+  snprintf(buf, sizeof buf, \"f%s%de\",\n+\t   this->is_abstract_ ? \"a\" : \"\",\n+\t   this->bits_);\n+  ret->append(buf);\n+}\n+\n+void\n+Complex_type::do_mangled_name(Gogo*, std::string* ret) const\n+{\n+  char buf[100];\n+  snprintf(buf, sizeof buf, \"c%s%de\",\n+\t   this->is_abstract_ ? \"a\" : \"\",\n+\t   this->bits_);\n+  ret->append(buf);\n+}\n+\n+void\n+String_type::do_mangled_name(Gogo*, std::string* ret) const\n+{\n+  ret->push_back('z');\n+}\n+\n+void\n+Function_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n+{\n+  ret->push_back('F');\n+\n+  if (this->receiver_ != NULL)\n+    {\n+      ret->push_back('m');\n+      this->append_mangled_name(this->receiver_->type(), gogo, ret);\n+    }\n+\n+  const Typed_identifier_list* params = this->parameters();\n+  if (params != NULL)\n+    {\n+      ret->push_back('p');\n+      for (Typed_identifier_list::const_iterator p = params->begin();\n+\t   p != params->end();\n+\t   ++p)\n+\tthis->append_mangled_name(p->type(), gogo, ret);\n+      if (this->is_varargs_)\n+\tret->push_back('V');\n+      ret->push_back('e');\n+    }\n+\n+  const Typed_identifier_list* results = this->results();\n+  if (results != NULL)\n+    {\n+      ret->push_back('r');\n+      for (Typed_identifier_list::const_iterator p = results->begin();\n+\t   p != results->end();\n+\t   ++p)\n+\tthis->append_mangled_name(p->type(), gogo, ret);\n+      ret->push_back('e');\n+    }\n+\n+  ret->push_back('e');\n+}\n+\n+void\n+Pointer_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n+{\n+  ret->push_back('p');\n+  this->append_mangled_name(this->to_type_, gogo, ret);\n+}\n+\n+void\n+Nil_type::do_mangled_name(Gogo*, std::string* ret) const\n+{\n+  ret->push_back('n');\n+}\n+\n+void\n+Struct_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n+{\n+  ret->push_back('S');\n+\n+  const Struct_field_list* fields = this->fields_;\n+  if (fields != NULL)\n+    {\n+      for (Struct_field_list::const_iterator p = fields->begin();\n+\t   p != fields->end();\n+\t   ++p)\n+\t{\n+\t  if (p->is_anonymous())\n+\t    ret->append(\"0_\");\n+\t  else\n+            {\n+\n+              std::string n(Gogo::mangle_possibly_hidden_name(p->field_name()));\n+\t      char buf[20];\n+\t      snprintf(buf, sizeof buf, \"%u_\",\n+\t\t       static_cast<unsigned int>(n.length()));\n+\t      ret->append(buf);\n+\t      ret->append(n);\n+\t    }\n+\n+\t  // For an anonymous field with an alias type, the field name\n+\t  // is the alias name.\n+\t  if (p->is_anonymous()\n+\t      && p->type()->named_type() != NULL\n+\t      && p->type()->named_type()->is_alias())\n+\t    p->type()->named_type()->append_mangled_type_name(gogo, true, ret);\n+\t  else\n+\t    this->append_mangled_name(p->type(), gogo, ret);\n+\t  if (p->has_tag())\n+\t    {\n+\t      const std::string& tag(p->tag());\n+\t      std::string out;\n+\t      for (std::string::const_iterator p = tag.begin();\n+\t\t   p != tag.end();\n+\t\t   ++p)\n+\t\t{\n+\t\t  if (ISALNUM(*p) || *p == '_')\n+\t\t    out.push_back(*p);\n+\t\t  else\n+\t\t    {\n+\t\t      char buf[20];\n+\t\t      snprintf(buf, sizeof buf, \".%x.\",\n+\t\t\t       static_cast<unsigned int>(*p));\n+\t\t      out.append(buf);\n+\t\t    }\n+\t\t}\n+\t      char buf[20];\n+\t      snprintf(buf, sizeof buf, \"T%u_\",\n+\t\t       static_cast<unsigned int>(out.length()));\n+\t      ret->append(buf);\n+\t      ret->append(out);\n+\t    }\n+\t}\n+    }\n+\n+  if (this->is_struct_incomparable_)\n+    ret->push_back('x');\n+\n+  ret->push_back('e');\n+}\n+\n+void\n+Array_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n+{\n+  ret->push_back('A');\n+  this->append_mangled_name(this->element_type_, gogo, ret);\n+  if (this->length_ != NULL)\n+    {\n+      Numeric_constant nc;\n+      if (!this->length_->numeric_constant_value(&nc))\n+\t{\n+\t  go_assert(saw_errors());\n+\t  return;\n+\t}\n+      mpz_t val;\n+      if (!nc.to_int(&val))\n+\t{\n+\t  go_assert(saw_errors());\n+\t  return;\n+\t}\n+      char *s = mpz_get_str(NULL, 10, val);\n+      ret->append(s);\n+      free(s);\n+      mpz_clear(val);\n+      if (this->is_array_incomparable_)\n+\tret->push_back('x');\n+    }\n+  ret->push_back('e');\n+}\n+\n+void\n+Map_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n+{\n+  ret->push_back('M');\n+  this->append_mangled_name(this->key_type_, gogo, ret);\n+  ret->append(\"__\");\n+  this->append_mangled_name(this->val_type_, gogo, ret);\n+}\n+\n+void\n+Channel_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n+{\n+  ret->push_back('C');\n+  this->append_mangled_name(this->element_type_, gogo, ret);\n+  if (this->may_send_)\n+    ret->push_back('s');\n+  if (this->may_receive_)\n+    ret->push_back('r');\n+  ret->push_back('e');\n+}\n+\n+void\n+Interface_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n+{\n+  go_assert(this->methods_are_finalized_);\n+\n+  ret->push_back('I');\n+\n+  const Typed_identifier_list* methods = this->all_methods_;\n+  if (methods != NULL && !this->seen_)\n+    {\n+      this->seen_ = true;\n+      for (Typed_identifier_list::const_iterator p = methods->begin();\n+\t   p != methods->end();\n+\t   ++p)\n+\t{\n+\t  if (!p->name().empty())\n+\t    {\n+\t      std::string n(Gogo::mangle_possibly_hidden_name(p->name()));\n+\t      char buf[20];\n+\t      snprintf(buf, sizeof buf, \"%u_\",\n+\t\t       static_cast<unsigned int>(n.length()));\n+\t      ret->append(buf);\n+\t      ret->append(n);\n+\t    }\n+\t  this->append_mangled_name(p->type(), gogo, ret);\n+\t}\n+      this->seen_ = false;\n+    }\n+\n+  ret->push_back('e');\n+}\n+\n+void\n+Named_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n+{\n+  this->append_mangled_type_name(gogo, false, ret);\n+}\n+\n+void\n+Forward_declaration_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n+{\n+  if (this->is_defined())\n+    this->append_mangled_name(this->real_type(), gogo, ret);\n+  else\n+    {\n+      const Named_object* no = this->named_object();\n+      std::string name;\n+      if (no->package() == NULL)\n+\tname = gogo->pkgpath_symbol();\n+      else\n+\tname = no->package()->pkgpath_symbol();\n+      name += '.';\n+      name += Gogo::unpack_hidden_name(no->name());\n+      char buf[20];\n+      snprintf(buf, sizeof buf, \"N%u_\",\n+\t       static_cast<unsigned int>(name.length()));\n+      ret->append(buf);\n+      ret->append(name);\n+    }\n+}\n+\n+// Append the mangled name for a named type to RET.  For an alias we\n+// normally use the real name, but if USE_ALIAS is true we use the\n+// alias name itself.\n+\n+void\n+Named_type::append_mangled_type_name(Gogo* gogo, bool use_alias,\n+\t\t\t\t     std::string* ret) const\n+{\n+  if (this->is_error_)\n+    return;\n+  if (this->is_alias_ && !use_alias)\n+    {\n+      if (this->seen_alias_)\n+\treturn;\n+      this->seen_alias_ = true;\n+      this->append_mangled_name(this->type_, gogo, ret);\n+      this->seen_alias_ = false;\n+      return;\n+    }\n+  Named_object* no = this->named_object_;\n+  std::string name;\n+  if (this->is_builtin())\n+    go_assert(this->in_function_ == NULL);\n+  else\n+    {\n+      const std::string& pkgpath(no->package() == NULL\n+\t\t\t\t ? gogo->pkgpath_symbol()\n+\t\t\t\t : no->package()->pkgpath_symbol());\n+      name = pkgpath;\n+      name.append(1, '.');\n+      if (this->in_function_ != NULL)\n+\t{\n+\t  const Typed_identifier* rcvr =\n+\t    this->in_function_->func_value()->type()->receiver();\n+\t  if (rcvr != NULL)\n+\t    {\n+\t      Named_type* rcvr_type = rcvr->type()->deref()->named_type();\n+\t      name.append(Gogo::unpack_hidden_name(rcvr_type->name()));\n+\t      name.append(1, '.');\n+\t    }\n+\t  name.append(Gogo::unpack_hidden_name(this->in_function_->name()));\n+\t  name.append(1, '$');\n+\t  if (this->in_function_index_ > 0)\n+\t    {\n+\t      char buf[30];\n+\t      snprintf(buf, sizeof buf, \"%u\", this->in_function_index_);\n+\t      name.append(buf);\n+\t      name.append(1, '$');\n+\t    }\n+\t}\n+    }\n+  name.append(Gogo::unpack_hidden_name(no->name()));\n+  char buf[20];\n+  snprintf(buf, sizeof buf, \"N%u_\", static_cast<unsigned int>(name.length()));\n+  ret->append(buf);\n+  ret->append(name);\n+}\n+\n+// Return the name for the type descriptor symbol for TYPE.  This can\n+// be a global, common, or local symbol, depending.  NT is not NULL if\n+// it is the name to use.\n+\n+std::string\n+Gogo::type_descriptor_name(Type* type, Named_type* nt)\n+{\n+  // The type descriptor symbol for the unsafe.Pointer type is defined\n+  // in libgo/runtime/go-unsafe-pointer.c, so just use a reference to\n+  // that symbol.\n+  if (type->is_unsafe_pointer_type())\n+    return \"__go_tdn_unsafe.Pointer\";\n+\n+  if (nt == NULL)\n+    return \"__go_td_\" + type->mangled_name(this);\n+\n+  Named_object* no = nt->named_object();\n+  unsigned int index;\n+  const Named_object* in_function = nt->in_function(&index);\n+  std::string ret = \"__go_tdn_\";\n+  if (nt->is_builtin())\n+    go_assert(in_function == NULL);\n+  else\n+    {\n+      const std::string& pkgpath(no->package() == NULL\n+\t\t\t\t ? this->pkgpath_symbol()\n+\t\t\t\t : no->package()->pkgpath_symbol());\n+      ret.append(pkgpath);\n+      ret.append(1, '.');\n+      if (in_function != NULL)\n+\t{\n+\t  const Typed_identifier* rcvr =\n+\t    in_function->func_value()->type()->receiver();\n+\t  if (rcvr != NULL)\n+\t    {\n+\t      Named_type* rcvr_type = rcvr->type()->deref()->named_type();\n+\t      ret.append(Gogo::unpack_hidden_name(rcvr_type->name()));\n+\t      ret.append(1, '.');\n+\t    }\n+\t  ret.append(Gogo::unpack_hidden_name(in_function->name()));\n+\t  ret.append(1, '.');\n+\t  if (index > 0)\n+\t    {\n+\t      char buf[30];\n+\t      snprintf(buf, sizeof buf, \"%u\", index);\n+\t      ret.append(buf);\n+\t      ret.append(1, '.');\n+\t    }\n+\t}\n+    }\n+\n+  std::string mname(Gogo::mangle_possibly_hidden_name(no->name()));\n+  ret.append(mname);\n+\n+  return ret;\n+}\n+\n+// Return the name for the GC symbol for a type.  This is used to\n+// initialize the gcdata field of a type descriptor.  This is a local\n+// name never referenced outside of this assembly file.  (Note that\n+// some type descriptors will initialize the gcdata field with a name\n+// generated by ptrmask_symbol_name rather than this method.)\n+\n+std::string\n+Gogo::gc_symbol_name(Type* type)\n+{\n+  return this->type_descriptor_name(type, type->named_type()) + \"$gc\";\n+}\n+\n+// Return the name for a ptrmask variable.  PTRMASK_SYM_NAME is a\n+// base64 string encoding the ptrmask (as returned by Ptrmask::symname\n+// in types.cc).  This name is used to intialize the gcdata field of a\n+// type descriptor.  These names are globally visible.  (Note that\n+// some type descriptors will initialize the gcdata field with a name\n+// generated by gc_symbol_name rather than this method.)\n+\n+std::string\n+Gogo::ptrmask_symbol_name(const std::string& ptrmask_sym_name)\n+{\n+  return \"runtime.gcbits.\" + ptrmask_sym_name;\n+}\n+\n+// Return the name to use for an interface method table used for the\n+// ordinary type TYPE converted to the interface type ITYPE.\n+// IS_POINTER is true if this is for the method set for a pointer\n+// receiver.\n+\n+std::string\n+Gogo::interface_method_table_name(Interface_type* itype, Type* type,\n+\t\t\t\t  bool is_pointer)\n+{\n+  return ((is_pointer ? \"__go_pimt__\" : \"__go_imt_\")\n+\t  + itype->mangled_name(this)\n+\t  + \"__\"\n+\t  + type->mangled_name(this));\n+}"}, {"sha": "5b0c84a0f56bf9ee6ad079fb5a5366e2f08c32c8", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 52, "deletions": 564, "changes": 616, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=9add86be80b805afd59414c62e56019252591eea", "patch": "@@ -1257,7 +1257,7 @@ Type::make_type_descriptor_var(Gogo* gogo)\n \n       Type* td_type = Type::make_type_descriptor_type();\n       Btype* td_btype = td_type->get_backend(gogo);\n-      const char *name = \"__go_tdn_unsafe.Pointer\";\n+      std::string name = gogo->type_descriptor_name(this, nt);\n       std::string asm_name(go_selectively_encode_id(name));\n       this->type_descriptor_var_ =\n \t  gogo->backend()->immutable_struct_reference(name, asm_name,\n@@ -1269,7 +1269,7 @@ Type::make_type_descriptor_var(Gogo* gogo)\n       return;\n     }\n \n-  std::string var_name = this->type_descriptor_var_name(gogo, nt);\n+  std::string var_name = gogo->type_descriptor_name(this, nt);\n \n   // Build the contents of the type descriptor.\n   Expression* initializer = this->do_type_descriptor(gogo, NULL);\n@@ -1331,56 +1331,6 @@ Type::make_type_descriptor_var(Gogo* gogo)\n \t\t\t\t\t     binitializer);\n }\n \n-// Return the name of the type descriptor variable.  If NT is not\n-// NULL, use it to get the name.  Otherwise this is an unnamed type.\n-\n-std::string\n-Type::type_descriptor_var_name(Gogo* gogo, Named_type* nt)\n-{\n-  if (nt == NULL)\n-    return \"__go_td_\" + this->mangled_name(gogo);\n-\n-  Named_object* no = nt->named_object();\n-  unsigned int index;\n-  const Named_object* in_function = nt->in_function(&index);\n-  std::string ret = \"__go_tdn_\";\n-  if (nt->is_builtin())\n-    go_assert(in_function == NULL);\n-  else\n-    {\n-      const std::string& pkgpath(no->package() == NULL\n-\t\t\t\t ? gogo->pkgpath_symbol()\n-\t\t\t\t : no->package()->pkgpath_symbol());\n-      ret.append(pkgpath);\n-      ret.append(1, '.');\n-      if (in_function != NULL)\n-\t{\n-\t  const Typed_identifier* rcvr =\n-\t    in_function->func_value()->type()->receiver();\n-\t  if (rcvr != NULL)\n-\t    {\n-\t      Named_type* rcvr_type = rcvr->type()->deref()->named_type();\n-\t      ret.append(Gogo::unpack_hidden_name(rcvr_type->name()));\n-\t      ret.append(1, '.');\n-\t    }\n-\t  ret.append(Gogo::unpack_hidden_name(in_function->name()));\n-\t  ret.append(1, '.');\n-\t  if (index > 0)\n-\t    {\n-\t      char buf[30];\n-\t      snprintf(buf, sizeof buf, \"%u\", index);\n-\t      ret.append(buf);\n-\t      ret.append(1, '.');\n-\t    }\n-\t}\n-    }\n-\n-  std::string mname(Gogo::mangle_possibly_hidden_name(no->name()));\n-  ret.append(mname);\n-\n-  return ret;\n-}\n-\n // Return true if this type descriptor is defined in a different\n // package.  If this returns true it sets *PACKAGE to the package.\n \n@@ -1967,48 +1917,9 @@ Type::specific_type_functions(Gogo* gogo, Named_type* name, int64_t size,\n       return;\n     }\n \n-  std::string base_name;\n-  if (name == NULL)\n-    {\n-      // Mangled names can have '.' if they happen to refer to named\n-      // types in some way.  That's fine if this is simply a named\n-      // type, but otherwise it will confuse the code that builds\n-      // function identifiers.  Remove '.' when necessary.\n-      base_name = this->mangled_name(gogo);\n-      size_t i;\n-      while ((i = base_name.find('.')) != std::string::npos)\n-\tbase_name[i] = '$';\n-      base_name = gogo->pack_hidden_name(base_name, false);\n-    }\n-  else\n-    {\n-      // This name is already hidden or not as appropriate.\n-      base_name = name->name();\n-      unsigned int index;\n-      const Named_object* in_function = name->in_function(&index);\n-      if (in_function != NULL)\n-\t{\n-\t  base_name.append(1, '$');\n-\t  const Typed_identifier* rcvr =\n-\t    in_function->func_value()->type()->receiver();\n-\t  if (rcvr != NULL)\n-\t    {\n-\t      Named_type* rcvr_type = rcvr->type()->deref()->named_type();\n-\t      base_name.append(Gogo::unpack_hidden_name(rcvr_type->name()));\n-\t      base_name.append(1, '$');\n-\t    }\n-\t  base_name.append(Gogo::unpack_hidden_name(in_function->name()));\n-\t  if (index > 0)\n-\t    {\n-\t      char buf[30];\n-\t      snprintf(buf, sizeof buf, \"%u\", index);\n-\t      base_name += '$';\n-\t      base_name += buf;\n-\t    }\n-\t}\n-    }\n-  std::string hash_name = base_name + \"$hash\";\n-  std::string equal_name = base_name + \"$equal\";\n+  std::string hash_name;\n+  std::string equal_name;\n+  gogo->specific_type_function_names(this, name, &hash_name, &equal_name);\n \n   Location bloc = Linemap::predeclared_location();\n \n@@ -2525,7 +2436,7 @@ Type::make_gc_symbol_var(Gogo* gogo)\n       return;\n     }\n \n-  std::string sym_name = this->type_descriptor_var_name(gogo, nt) + \"$gc\";\n+  std::string sym_name = gogo->gc_symbol_name(this);\n \n   // Build the contents of the gc symbol.\n   Expression* sym_init = this->gcprog_constructor(gogo, ptrsize, ptrdata);\n@@ -2818,7 +2729,8 @@ Type::gc_ptrmask_var(Gogo* gogo, int64_t ptrsize, int64_t ptrdata)\n       // This can happen in error cases.  Just build an empty gcbits.\n       go_assert(saw_errors());\n     }\n-  std::string sym_name = \"runtime.gcbits.\" + ptrmask.symname();\n+\n+  std::string sym_name = gogo->ptrmask_symbol_name(ptrmask.symname());\n   Bvariable* bvnull = NULL;\n   std::pair<GC_gcbits_vars::iterator, bool> ins =\n     Type::gc_gcbits_vars.insert(std::make_pair(sym_name, bvnull));\n@@ -3462,21 +3374,6 @@ Type::reflection(Gogo* gogo) const\n   return ret;\n }\n \n-// Return a mangled name for the type.\n-\n-std::string\n-Type::mangled_name(Gogo* gogo) const\n-{\n-  std::string ret;\n-\n-  // The do_mangled_name virtual function should set RET to the\n-  // mangled name.  For a composite type it should append a code for\n-  // the composition and then call do_mangled_name on the components.\n-  this->do_mangled_name(gogo, &ret);\n-\n-  return ret;\n-}\n-\n // Return whether the backend size of the type is known.\n \n bool\n@@ -3796,37 +3693,32 @@ Type::import_type(Import* imp)\n     }\n }\n \n-// A type used to indicate a parsing error.  This exists to simplify\n-// later error detection.\n+// Class Error_type.\n+\n+// Return the backend representation of an Error type.\n \n-class Error_type : public Type\n+Btype*\n+Error_type::do_get_backend(Gogo* gogo)\n {\n- public:\n-  Error_type()\n-    : Type(TYPE_ERROR)\n-  { }\n+  return gogo->backend()->error_type();\n+}\n \n- protected:\n-  bool\n-  do_compare_is_identity(Gogo*)\n-  { return false; }\n+// Return an expression for the type descriptor for an error type.\n \n-  Btype*\n-  do_get_backend(Gogo* gogo)\n-  { return gogo->backend()->error_type(); }\n \n-  Expression*\n-  do_type_descriptor(Gogo*, Named_type*)\n-  { return Expression::make_error(Linemap::predeclared_location()); }\n+Expression*\n+Error_type::do_type_descriptor(Gogo*, Named_type*)\n+{\n+  return Expression::make_error(Linemap::predeclared_location());\n+}\n \n-  void\n-  do_reflection(Gogo*, std::string*) const\n-  { go_assert(saw_errors()); }\n+// We should not be asked for the reflection string for an error type.\n \n-  void\n-  do_mangled_name(Gogo*, std::string* ret) const\n-  { ret->push_back('E'); }\n-};\n+void\n+Error_type::do_reflection(Gogo*, std::string*) const\n+{\n+  go_assert(saw_errors());\n+}\n \n Type*\n Type::make_error_type()\n@@ -3835,36 +3727,15 @@ Type::make_error_type()\n   return &singleton_error_type;\n }\n \n-// The void type.\n-\n-class Void_type : public Type\n-{\n- public:\n-  Void_type()\n-    : Type(TYPE_VOID)\n-  { }\n-\n- protected:\n-  bool\n-  do_compare_is_identity(Gogo*)\n-  { return false; }\n-\n-  Btype*\n-  do_get_backend(Gogo* gogo)\n-  { return gogo->backend()->void_type(); }\n-\n-  Expression*\n-  do_type_descriptor(Gogo*, Named_type*)\n-  { go_unreachable(); }\n+// Class Void_type.\n \n-  void\n-  do_reflection(Gogo*, std::string*) const\n-  { }\n+// Get the backend representation of a void type.\n \n-  void\n-  do_mangled_name(Gogo*, std::string* ret) const\n-  { ret->push_back('v'); }\n-};\n+Btype*\n+Void_type::do_get_backend(Gogo* gogo)\n+{\n+  return gogo->backend()->void_type();\n+}\n \n Type*\n Type::make_void_type()\n@@ -3873,36 +3744,15 @@ Type::make_void_type()\n   return &singleton_void_type;\n }\n \n-// The boolean type.\n-\n-class Boolean_type : public Type\n-{\n- public:\n-  Boolean_type()\n-    : Type(TYPE_BOOLEAN)\n-  { }\n+// Class Boolean_type.\n \n- protected:\n-  bool\n-  do_compare_is_identity(Gogo*)\n-  { return true; }\n+// Return the backend representation of the boolean type.\n \n-  Btype*\n-  do_get_backend(Gogo* gogo)\n-  { return gogo->backend()->bool_type(); }\n-\n-  Expression*\n-  do_type_descriptor(Gogo*, Named_type* name);\n-\n-  // We should not be asked for the reflection string of a basic type.\n-  void\n-  do_reflection(Gogo*, std::string* ret) const\n-  { ret->append(\"bool\"); }\n-\n-  void\n-  do_mangled_name(Gogo*, std::string* ret) const\n-  { ret->push_back('b'); }\n-};\n+Btype*\n+Boolean_type::do_get_backend(Gogo* gogo)\n+{\n+  return gogo->backend()->bool_type();\n+}\n \n // Make the type descriptor.\n \n@@ -4069,19 +3919,6 @@ Integer_type::do_reflection(Gogo*, std::string*) const\n   go_assert(saw_errors());\n }\n \n-// Mangled name.\n-\n-void\n-Integer_type::do_mangled_name(Gogo*, std::string* ret) const\n-{\n-  char buf[100];\n-  snprintf(buf, sizeof buf, \"i%s%s%de\",\n-\t   this->is_abstract_ ? \"a\" : \"\",\n-\t   this->is_unsigned_ ? \"u\" : \"\",\n-\t   this->bits_);\n-  ret->append(buf);\n-}\n-\n // Make an integer type.\n \n Named_type*\n@@ -4204,18 +4041,6 @@ Float_type::do_reflection(Gogo*, std::string*) const\n   go_assert(saw_errors());\n }\n \n-// Mangled name.\n-\n-void\n-Float_type::do_mangled_name(Gogo*, std::string* ret) const\n-{\n-  char buf[100];\n-  snprintf(buf, sizeof buf, \"f%s%de\",\n-\t   this->is_abstract_ ? \"a\" : \"\",\n-\t   this->bits_);\n-  ret->append(buf);\n-}\n-\n // Make a floating point type.\n \n Named_type*\n@@ -4331,18 +4156,6 @@ Complex_type::do_reflection(Gogo*, std::string*) const\n   go_assert(saw_errors());\n }\n \n-// Mangled name.\n-\n-void\n-Complex_type::do_mangled_name(Gogo*, std::string* ret) const\n-{\n-  char buf[100];\n-  snprintf(buf, sizeof buf, \"c%s%de\",\n-\t   this->is_abstract_ ? \"a\" : \"\",\n-\t   this->bits_);\n-  ret->append(buf);\n-}\n-\n // Make a complex type.\n \n Named_type*\n@@ -4428,14 +4241,6 @@ String_type::do_reflection(Gogo*, std::string* ret) const\n   ret->append(\"string\");\n }\n \n-// Mangled name of a string type.\n-\n-void\n-String_type::do_mangled_name(Gogo*, std::string* ret) const\n-{\n-  ret->push_back('z');\n-}\n-\n // Make a string type.\n \n Type*\n@@ -5082,46 +4887,6 @@ Function_type::do_reflection(Gogo* gogo, std::string* ret) const\n     }\n }\n \n-// Mangled name.\n-\n-void\n-Function_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n-{\n-  ret->push_back('F');\n-\n-  if (this->receiver_ != NULL)\n-    {\n-      ret->push_back('m');\n-      this->append_mangled_name(this->receiver_->type(), gogo, ret);\n-    }\n-\n-  const Typed_identifier_list* params = this->parameters();\n-  if (params != NULL)\n-    {\n-      ret->push_back('p');\n-      for (Typed_identifier_list::const_iterator p = params->begin();\n-\t   p != params->end();\n-\t   ++p)\n-\tthis->append_mangled_name(p->type(), gogo, ret);\n-      if (this->is_varargs_)\n-\tret->push_back('V');\n-      ret->push_back('e');\n-    }\n-\n-  const Typed_identifier_list* results = this->results();\n-  if (results != NULL)\n-    {\n-      ret->push_back('r');\n-      for (Typed_identifier_list::const_iterator p = results->begin();\n-\t   p != results->end();\n-\t   ++p)\n-\tthis->append_mangled_name(p->type(), gogo, ret);\n-      ret->push_back('e');\n-    }\n-\n-  ret->push_back('e');\n-}\n-\n // Export a function type.\n \n void\n@@ -5484,13 +5249,6 @@ Pointer_type::do_reflection(Gogo* gogo, std::string* ret) const\n   this->append_reflection(this->to_type_, gogo, ret);\n }\n \n-void\n-Pointer_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n-{\n-  ret->push_back('p');\n-  this->append_mangled_name(this->to_type_, gogo, ret);\n-}\n-\n // Export.\n \n void\n@@ -5572,38 +5330,16 @@ Type::finish_pointer_types(Gogo* gogo)\n     }\n }\n \n-// The nil type.  We use a special type for nil because it is not the\n-// same as any other type.  In C term nil has type void*, but there is\n-// no such type in Go.\n-\n-class Nil_type : public Type\n-{\n- public:\n-  Nil_type()\n-    : Type(TYPE_NIL)\n-  { }\n-\n- protected:\n-  bool\n-  do_compare_is_identity(Gogo*)\n-  { return false; }\n-\n-  Btype*\n-  do_get_backend(Gogo* gogo)\n-  { return gogo->backend()->pointer_type(gogo->backend()->void_type()); }\n+// Class Nil_type.\n \n-  Expression*\n-  do_type_descriptor(Gogo*, Named_type*)\n-  { go_unreachable(); }\n+// Get the backend representation of a nil type.  FIXME: Is this ever\n+// actually called?\n \n-  void\n-  do_reflection(Gogo*, std::string*) const\n-  { go_unreachable(); }\n-\n-  void\n-  do_mangled_name(Gogo*, std::string* ret) const\n-  { ret->push_back('n'); }\n-};\n+Btype*\n+Nil_type::do_get_backend(Gogo* gogo)\n+{\n+  return gogo->backend()->pointer_type(gogo->backend()->void_type());\n+}\n \n // Make the nil type.\n \n@@ -6692,74 +6428,6 @@ Struct_type::do_reflection(Gogo* gogo, std::string* ret) const\n   ret->push_back('}');\n }\n \n-// Mangled name.\n-\n-void\n-Struct_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n-{\n-  ret->push_back('S');\n-\n-  const Struct_field_list* fields = this->fields_;\n-  if (fields != NULL)\n-    {\n-      for (Struct_field_list::const_iterator p = fields->begin();\n-\t   p != fields->end();\n-\t   ++p)\n-\t{\n-\t  if (p->is_anonymous())\n-\t    ret->append(\"0_\");\n-\t  else\n-            {\n-\n-              std::string n(Gogo::mangle_possibly_hidden_name(p->field_name()));\n-\t      char buf[20];\n-\t      snprintf(buf, sizeof buf, \"%u_\",\n-\t\t       static_cast<unsigned int>(n.length()));\n-\t      ret->append(buf);\n-\t      ret->append(n);\n-\t    }\n-\n-\t  // For an anonymous field with an alias type, the field name\n-\t  // is the alias name.\n-\t  if (p->is_anonymous()\n-\t      && p->type()->named_type() != NULL\n-\t      && p->type()->named_type()->is_alias())\n-\t    p->type()->named_type()->append_mangled_type_name(gogo, true, ret);\n-\t  else\n-\t    this->append_mangled_name(p->type(), gogo, ret);\n-\t  if (p->has_tag())\n-\t    {\n-\t      const std::string& tag(p->tag());\n-\t      std::string out;\n-\t      for (std::string::const_iterator p = tag.begin();\n-\t\t   p != tag.end();\n-\t\t   ++p)\n-\t\t{\n-\t\t  if (ISALNUM(*p) || *p == '_')\n-\t\t    out.push_back(*p);\n-\t\t  else\n-\t\t    {\n-\t\t      char buf[20];\n-\t\t      snprintf(buf, sizeof buf, \".%x.\",\n-\t\t\t       static_cast<unsigned int>(*p));\n-\t\t      out.append(buf);\n-\t\t    }\n-\t\t}\n-\t      char buf[20];\n-\t      snprintf(buf, sizeof buf, \"T%u_\",\n-\t\t       static_cast<unsigned int>(out.length()));\n-\t      ret->append(buf);\n-\t      ret->append(out);\n-\t    }\n-\t}\n-    }\n-\n-  if (this->is_struct_incomparable_)\n-    ret->push_back('x');\n-\n-  ret->push_back('e');\n-}\n-\n // If the offset of field INDEX in the backend implementation can be\n // determined, set *POFFSET to the offset in bytes and return true.\n // Otherwise, return false.\n@@ -7951,37 +7619,6 @@ Array_type::do_reflection(Gogo* gogo, std::string* ret) const\n   this->append_reflection(this->element_type_, gogo, ret);\n }\n \n-// Mangled name.\n-\n-void\n-Array_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n-{\n-  ret->push_back('A');\n-  this->append_mangled_name(this->element_type_, gogo, ret);\n-  if (this->length_ != NULL)\n-    {\n-      Numeric_constant nc;\n-      if (!this->length_->numeric_constant_value(&nc))\n-\t{\n-\t  go_assert(saw_errors());\n-\t  return;\n-\t}\n-      mpz_t val;\n-      if (!nc.to_int(&val))\n-\t{\n-\t  go_assert(saw_errors());\n-\t  return;\n-\t}\n-      char *s = mpz_get_str(NULL, 10, val);\n-      ret->append(s);\n-      free(s);\n-      mpz_clear(val);\n-      if (this->is_array_incomparable_)\n-\tret->push_back('x');\n-    }\n-  ret->push_back('e');\n-}\n-\n // Make an array type.\n \n Array_type*\n@@ -8037,8 +7674,8 @@ Map_type::fat_zero_value(Gogo* gogo)\n       Array_type* array_type = Type::make_array_type(uint8_type, size);\n       array_type->set_is_array_incomparable();\n       Variable* var = new Variable(array_type, NULL, true, false, false, bloc);\n-      Map_type::zero_value = Named_object::make_variable(\"go$zerovalue\", NULL,\n-\t\t\t\t\t\t\t var);\n+      std::string name = gogo->map_zero_value_name();\n+      Map_type::zero_value = Named_object::make_variable(name, NULL, var);\n     }\n \n   Expression* z = Expression::make_var_reference(Map_type::zero_value, bloc);\n@@ -8582,17 +8219,6 @@ Map_type::do_reflection(Gogo* gogo, std::string* ret) const\n   this->append_reflection(this->val_type_, gogo, ret);\n }\n \n-// Mangled name for a map.\n-\n-void\n-Map_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n-{\n-  ret->push_back('M');\n-  this->append_mangled_name(this->key_type_, gogo, ret);\n-  ret->append(\"__\");\n-  this->append_mangled_name(this->val_type_, gogo, ret);\n-}\n-\n // Export a map type.\n \n void\n@@ -8765,20 +8391,6 @@ Channel_type::do_reflection(Gogo* gogo, std::string* ret) const\n   this->append_reflection(this->element_type_, gogo, ret);\n }\n \n-// Mangled name.\n-\n-void\n-Channel_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n-{\n-  ret->push_back('C');\n-  this->append_mangled_name(this->element_type_, gogo, ret);\n-  if (this->may_send_)\n-    ret->push_back('s');\n-  if (this->may_receive_)\n-    ret->push_back('r');\n-  ret->push_back('e');\n-}\n-\n // Export.\n \n void\n@@ -9702,40 +9314,6 @@ Interface_type::do_reflection(Gogo* gogo, std::string* ret) const\n   ret->append(\"}\");\n }\n \n-// Mangled name.\n-\n-void\n-Interface_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n-{\n-  go_assert(this->methods_are_finalized_);\n-\n-  ret->push_back('I');\n-\n-  const Typed_identifier_list* methods = this->all_methods_;\n-  if (methods != NULL && !this->seen_)\n-    {\n-      this->seen_ = true;\n-      for (Typed_identifier_list::const_iterator p = methods->begin();\n-\t   p != methods->end();\n-\t   ++p)\n-\t{\n-\t  if (!p->name().empty())\n-\t    {\n-\t      std::string n(Gogo::mangle_possibly_hidden_name(p->name()));\n-\t      char buf[20];\n-\t      snprintf(buf, sizeof buf, \"%u_\",\n-\t\t       static_cast<unsigned int>(n.length()));\n-\t      ret->append(buf);\n-\t      ret->append(n);\n-\t    }\n-\t  this->append_mangled_name(p->type(), gogo, ret);\n-\t}\n-      this->seen_ = false;\n-    }\n-\n-  ret->push_back('e');\n-}\n-\n // Export.\n \n void\n@@ -11178,71 +10756,6 @@ Named_type::append_reflection_type_name(Gogo* gogo, bool use_alias,\n   ret->append(Gogo::unpack_hidden_name(this->named_object_->name()));\n }\n \n-// Get the mangled name.\n-\n-void\n-Named_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n-{\n-  this->append_mangled_type_name(gogo, false, ret);\n-}\n-\n-// Get the mangled name.  For an alias we normally get the real name,\n-// but if USE_ALIAS is true we use the alias name itself.\n-\n-void\n-Named_type::append_mangled_type_name(Gogo* gogo, bool use_alias,\n-\t\t\t\t     std::string* ret) const\n-{\n-  if (this->is_error_)\n-    return;\n-  if (this->is_alias_ && !use_alias)\n-    {\n-      if (this->seen_alias_)\n-\treturn;\n-      this->seen_alias_ = true;\n-      this->append_mangled_name(this->type_, gogo, ret);\n-      this->seen_alias_ = false;\n-      return;\n-    }\n-  Named_object* no = this->named_object_;\n-  std::string name;\n-  if (this->is_builtin())\n-    go_assert(this->in_function_ == NULL);\n-  else\n-    {\n-      const std::string& pkgpath(no->package() == NULL\n-\t\t\t\t ? gogo->pkgpath_symbol()\n-\t\t\t\t : no->package()->pkgpath_symbol());\n-      name = pkgpath;\n-      name.append(1, '.');\n-      if (this->in_function_ != NULL)\n-\t{\n-\t  const Typed_identifier* rcvr =\n-\t    this->in_function_->func_value()->type()->receiver();\n-\t  if (rcvr != NULL)\n-\t    {\n-\t      Named_type* rcvr_type = rcvr->type()->deref()->named_type();\n-\t      name.append(Gogo::unpack_hidden_name(rcvr_type->name()));\n-\t      name.append(1, '.');\n-\t    }\n-\t  name.append(Gogo::unpack_hidden_name(this->in_function_->name()));\n-\t  name.append(1, '$');\n-\t  if (this->in_function_index_ > 0)\n-\t    {\n-\t      char buf[30];\n-\t      snprintf(buf, sizeof buf, \"%u\", this->in_function_index_);\n-\t      name.append(buf);\n-\t      name.append(1, '$');\n-\t    }\n-\t}\n-    }\n-  name.append(Gogo::unpack_hidden_name(no->name()));\n-  char buf[20];\n-  snprintf(buf, sizeof buf, \"N%u_\", static_cast<unsigned int>(name.length()));\n-  ret->append(buf);\n-  ret->append(name);\n-}\n-\n // Export the type.  This is called to export a global type.\n \n void\n@@ -11623,7 +11136,7 @@ Type::build_stub_methods(Gogo* gogo, const Type* type, const Methods* methods,\n \tpackage = NULL;\n       else\n \tpackage = type->named_type()->named_object()->package();\n-      std::string stub_name = name + \"$stub\";\n+      std::string stub_name = gogo->stub_method_name(name);\n       Named_object* stub;\n       if (package != NULL)\n \tstub = Named_object::make_function_declaration(stub_name, package,\n@@ -12453,31 +11966,6 @@ Forward_declaration_type::do_reflection(Gogo* gogo, std::string* ret) const\n   this->append_reflection(this->real_type(), gogo, ret);\n }\n \n-// The mangled name.\n-\n-void\n-Forward_declaration_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n-{\n-  if (this->is_defined())\n-    this->append_mangled_name(this->real_type(), gogo, ret);\n-  else\n-    {\n-      const Named_object* no = this->named_object();\n-      std::string name;\n-      if (no->package() == NULL)\n-\tname = gogo->pkgpath_symbol();\n-      else\n-\tname = no->package()->pkgpath_symbol();\n-      name += '.';\n-      name += Gogo::unpack_hidden_name(no->name());\n-      char buf[20];\n-      snprintf(buf, sizeof buf, \"N%u_\",\n-\t       static_cast<unsigned int>(name.length()));\n-      ret->append(buf);\n-      ret->append(name);\n-    }\n-}\n-\n // Export a forward declaration.  This can happen when a defined type\n // refers to a type which is only declared (and is presumably defined\n // in some other file in the same package)."}, {"sha": "a1e388414c2c95fa2676ef4d8e6ce2f4ea84d2e0", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 117, "deletions": 5, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9add86be80b805afd59414c62e56019252591eea/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=9add86be80b805afd59414c62e56019252591eea", "patch": "@@ -1213,11 +1213,6 @@ class Type\n   void\n   make_gc_symbol_var(Gogo*);\n \n-  // Return the name of the type descriptor variable.  If NAME is not\n-  // NULL, it is the name to use.\n-  std::string\n-  type_descriptor_var_name(Gogo*, Named_type* name);\n-\n   // Return true if the type descriptor for this type should be\n   // defined in some other package.  If NAME is not NULL, it is the\n   // name of this type.  If this returns true it sets *PACKAGE to the\n@@ -1558,6 +1553,92 @@ class Typed_identifier_list\n   std::vector<Typed_identifier> entries_;\n };\n \n+// A type used to indicate a parsing error.  This exists to simplify\n+// later error detection.\n+\n+class Error_type : public Type\n+{\n+ public:\n+  Error_type()\n+    : Type(TYPE_ERROR)\n+  { }\n+\n+ protected:\n+  bool\n+  do_compare_is_identity(Gogo*)\n+  { return false; }\n+\n+  Btype*\n+  do_get_backend(Gogo* gogo);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string* ret) const;\n+};\n+\n+// The void type.\n+\n+class Void_type : public Type\n+{\n+ public:\n+  Void_type()\n+    : Type(TYPE_VOID)\n+  { }\n+\n+ protected:\n+  bool\n+  do_compare_is_identity(Gogo*)\n+  { return false; }\n+\n+  Btype*\n+  do_get_backend(Gogo* gogo);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*)\n+  { go_unreachable(); }\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const\n+  { }\n+\n+  void\n+  do_mangled_name(Gogo*, std::string* ret) const;\n+};\n+\n+// The boolean type.\n+\n+class Boolean_type : public Type\n+{\n+ public:\n+  Boolean_type()\n+    : Type(TYPE_BOOLEAN)\n+  { }\n+\n+ protected:\n+  bool\n+  do_compare_is_identity(Gogo*)\n+  { return true; }\n+\n+  Btype*\n+  do_get_backend(Gogo* gogo);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type* name);\n+\n+  // We should not be asked for the reflection string of a basic type.\n+  void\n+  do_reflection(Gogo*, std::string* ret) const\n+  { ret->append(\"bool\"); }\n+\n+  void\n+  do_mangled_name(Gogo*, std::string* ret) const;\n+};\n+\n // The type of an integer.\n \n class Integer_type : public Type\n@@ -2143,6 +2224,37 @@ class Pointer_type : public Type\n   Type* to_type_;\n };\n \n+// The nil type.  We use a special type for nil because it is not the\n+// same as any other type.  In C term nil has type void*, but there is\n+// no such type in Go.\n+\n+class Nil_type : public Type\n+{\n+ public:\n+  Nil_type()\n+    : Type(TYPE_NIL)\n+  { }\n+\n+ protected:\n+  bool\n+  do_compare_is_identity(Gogo*)\n+  { return false; }\n+\n+  Btype*\n+  do_get_backend(Gogo* gogo);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*)\n+  { go_unreachable(); }\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const\n+  { go_unreachable(); }\n+\n+  void\n+  do_mangled_name(Gogo*, std::string* ret) const;\n+};\n+\n // The type of a field in a struct.\n \n class Struct_field"}]}