{"sha": "cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JiZjY1ZTAxMmFkNDUzMmVmOWUzMTJmM2RkOGQ2Yjg5ZmJlYjk5Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-03-18T19:01:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-03-18T19:01:04Z"}, "message": "i386.c (call_insn_operand): Always allow SYMBOL_REF, care for HALF_PIC_P.\n\n        * i386.c (call_insn_operand): Always allow SYMBOL_REF,\n        care for HALF_PIC_P.\n        (expander_call_insn_operand): Remove.\n        (ix86_expand_epilogue): New arg `emit_return' to control return insn.\n        * i386.h (PREDICATE_CODES): Update.\n        * i386.md (all call expanders): Remove predicates, remove special\n        handling for half-pic.\n        (*call_1, *call_value_1): Handle SIBLING_CALL_P insns.\n        (*call_pop_pic2, *call_pic2, *call_value_pop_2, *call_value_2): Remove.\n        (sibcall_epilogue): New.\n\nFrom-SVN: r32620", "tree": {"sha": "2d7cd0a26caa8a38b483ebc5d56f363e55ce10a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d7cd0a26caa8a38b483ebc5d56f363e55ce10a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992/comments", "author": null, "committer": null, "parents": [{"sha": "b6c5a81ce3c1ddc364f57dda8ab3ff45203f4c61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c5a81ce3c1ddc364f57dda8ab3ff45203f4c61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6c5a81ce3c1ddc364f57dda8ab3ff45203f4c61"}], "stats": {"total": 210, "additions": 91, "deletions": 119}, "files": [{"sha": "f9aa222dacdc6c22dfe1f08157223d6b4c66b261", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992", "patch": "@@ -1,3 +1,16 @@\n+2000-03-18  Richard Henderson  <rth@cygnus.com>\n+\n+\t* i386.c (call_insn_operand): Always allow SYMBOL_REF,\n+\tcare for HALF_PIC_P.\n+\t(expander_call_insn_operand): Remove.\n+\t(ix86_expand_epilogue): New arg `emit_return' to control return insn.\n+\t* i386.h (PREDICATE_CODES): Update.\n+\t* i386.md (all call expanders): Remove predicates, remove special       \n+\thandling for half-pic.\n+\t(*call_1, *call_value_1): Handle SIBLING_CALL_P insns.\n+\t(*call_pop_pic2, *call_pic2, *call_value_pop_2, *call_value_2): Remove.\n+\t(sibcall_epilogue): New.\n+\n 2000-03-17  Richard Henderson  <rth@cygnus.com>\n \n \t* rtlanal.c (single_set): Reject if the parallel has anything"}, {"sha": "81afd7b6469b0041586c3f53e189f20f76d2cd6a", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992", "patch": "@@ -30,7 +30,7 @@ extern void asm_output_function_prefix PARAMS ((FILE *, const char *));\n extern void load_pic_register PARAMS ((void));\n extern HOST_WIDE_INT ix86_initial_elimination_offset PARAMS((int, int));\n extern void ix86_expand_prologue PARAMS ((void));\n-extern void ix86_expand_epilogue PARAMS ((void));\n+extern void ix86_expand_epilogue PARAMS ((int));\n \n extern void ix86_output_function_block_profiler PARAMS ((FILE *, int));\n extern void ix86_output_block_profiler PARAMS ((FILE *, int));\n@@ -44,7 +44,6 @@ extern int symbolic_reference_mentioned_p PARAMS ((rtx));\n extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int pic_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int call_insn_operand PARAMS ((rtx, enum machine_mode));\n-extern int expander_call_insn_operand PARAMS ((rtx, enum machine_mode));\n extern int constant_call_address_operand PARAMS ((rtx, enum machine_mode));\n extern int const0_operand PARAMS ((rtx, enum machine_mode));\n extern int const1_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "9fc4425eba10f0cf37aa0e669d4fe9c44fcdfe9a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992", "patch": "@@ -1067,32 +1067,27 @@ call_insn_operand (op, mode)\n   if (GET_CODE (op) == CONST_INT)\n     return 0;\n \n-  /* Otherwise we can allow any general_operand in the address.  */\n-  return general_operand (op, Pmode);\n-}\n-\n-/* Like call_insn_operand but allow (mem (symbol_ref ...)) even if pic.  */\n-\n-int\n-expander_call_insn_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == MEM\n-      && GET_CODE (XEXP (op, 0)) == SYMBOL_REF)\n+  /* Explicitly allow SYMBOL_REF even if pic.  */\n+  if (GET_CODE (op) == SYMBOL_REF)\n     return 1;\n \n-  return call_insn_operand (op, mode);\n+  /* Half-pic doesn't allow anything but registers and constants.\n+     We've just taken care of the later.  */\n+  if (HALF_PIC_P ())\n+    return register_operand (op, Pmode);\n+\n+  /* Otherwise we can allow any general_operand in the address.  */\n+  return general_operand (op, Pmode);\n }\n \n int\n constant_call_address_operand (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  return GET_CODE (op) == MEM && \n-\t CONSTANT_ADDRESS_P (XEXP (op, 0)) && \n-\t GET_CODE (XEXP (op, 0)) !=  CONST_INT;\n+  return (GET_CODE (op) == MEM\n+\t  && CONSTANT_ADDRESS_P (XEXP (op, 0))\n+\t  && GET_CODE (XEXP (op, 0)) !=  CONST_INT);\n }\n \n /* Match exactly zero and one.  */\n@@ -1997,7 +1992,8 @@ ix86_emit_restore_regs_using_mov (pointer, offset)\n /* Restore function stack, frame, and registers. */\n \n void\n-ix86_expand_epilogue ()\n+ix86_expand_epilogue (emit_return)\n+     int emit_return;\n {\n   int nregs;\n   int regno;\n@@ -2082,6 +2078,10 @@ ix86_expand_epilogue ()\n \t  emit_insn (gen_popsi1 (gen_rtx_REG (SImode, regno)));\n     }\n \n+  /* Sibcall epilogues don't want a return instruction.  */\n+  if (! emit_return)\n+    return;\n+\n   if (current_function_pops_args && current_function_args_size)\n     {\n       rtx popc = GEN_INT (current_function_pops_args);"}, {"sha": "2b81e8c0628b878a1a811c48ae6098e82e43f4b9", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992", "patch": "@@ -1230,6 +1230,11 @@ typedef struct ix86_args {\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n+/* If PIC, we cannot optimize sibling calls to global functions\n+   because the PLT requires %ebx live.  */\n+#define FUNCTION_OK_FOR_SIBCALL(DECL) \\\n+  (DECL && (! flag_pic || ! TREE_PUBLIC (DECL)))\n+\n /* This macro is invoked just before the start of a function.\n    It is used here to output code for -fpic that will load the\n    return address into %ebx.  */\n@@ -2457,7 +2462,6 @@ do { long l;\t\t\t\t\t\t\\\n \t\t       LABEL_REF, SUBREG, REG, MEM}},\t\t\t\\\n   {\"pic_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n   {\"call_insn_operand\", {MEM}},\t\t\t\t\t\t\\\n-  {\"expander_call_insn_operand\", {MEM}},\t\t\t\t\\\n   {\"constant_call_address_operand\", {MEM}},\t\t\t\t\\\n   {\"const0_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\\\n   {\"const1_operand\", {CONST_INT}},\t\t\t\t\t\\"}, {"sha": "b188d915f31376d57793e4369b1b37e1e0fe6901", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 54, "deletions": 98, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=cbbf65e012ad4532ef9e312f3dd8d6b89fbeb992", "patch": "@@ -7010,47 +7010,36 @@\n \f\n ;; Call instructions.\n \n-;; If generating PIC code, the predicate indirect_operand will fail\n-;; for operands[0] containing symbolic references on all of the named\n-;; call* patterns.  Each named pattern is followed by an unnamed pattern\n-;; that matches any call to a symbolic CONST (ie, a symbol_ref).  The\n-;; unnamed patterns are only used while generating PIC code, because\n-;; otherwise the named patterns match.\n+;; The predicates normally associated with named expanders are not properly\n+;; checked for calls.  This is a bug in the generic code, but it isn't that\n+;; easy to fix.  Ignore it for now and be prepared to fix things up.\n \n ;; Call subroutine returning no value.\n \n (define_expand \"call_pop\"\n-  [(parallel [(call (match_operand:QI 0 \"indirect_operand\" \"\")\n-\t\t    (match_operand:SI 1 \"general_operand\" \"\"))\n+  [(parallel [(call (match_operand:QI 0 \"\" \"\")\n+\t\t    (match_operand:SI 1 \"\" \"\"))\n \t      (set (reg:SI 7)\n \t\t   (plus:SI (reg:SI 7)\n-\t\t\t    (match_operand:SI 3 \"immediate_operand\" \"\")))])]\n+\t\t\t    (match_operand:SI 3 \"\" \"\")))])]\n   \"\"\n   \"\n {\n-  rtx addr;\n-\n   if (operands[3] == const0_rtx)\n     {\n       emit_insn (gen_call (operands[0], operands[1]));\n       DONE;\n     }\n \n+  /* ??? Not true for calls to static functions.  */\n   if (flag_pic)\n     current_function_uses_pic_offset_table = 1;\n \n-  /* With half-pic, force the address into a register.  */\n-  addr = XEXP (operands[0], 0);\n-  if (GET_CODE (addr) != REG && HALF_PIC_P () && !CONSTANT_ADDRESS_P (addr))\n-    XEXP (operands[0], 0) = force_reg (Pmode, addr);\n-\n-  if (! expander_call_insn_operand (operands[0], QImode))\n-    operands[0]\n-      = change_address (operands[0], VOIDmode,\n-\t\t\tcopy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n+  if (! call_insn_operand (operands[0], QImode))\n+    XEXP (operands[0], 0) = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n }\")\n \n-(define_insn \"*call_pop_pic\"\n+(define_insn \"*call_pop_1\"\n   [(call (match_operand:QI 0 \"call_insn_operand\" \"m\")\n \t (match_operand:SI 1 \"general_operand\" \"g\"))\n    (set (reg:SI 7) (plus:SI (reg:SI 7)\n@@ -7066,70 +7055,54 @@\n }\"\n   [(set_attr \"type\" \"call\")])\n \n-(define_insn \"*call_pop_pic2\"\n-  [(call (match_operand:QI 0 \"constant_call_address_operand\" \"\")\n-         (match_operand:SI 1 \"general_operand\" \"g\"))\n-   (set (reg:SI 7) (plus:SI (reg:SI 7)\n-                            (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n-  \"!HALF_PIC_P ()\"\n-  \"call\\\\t%P0\"\n-  [(set_attr \"type\" \"call\")])\n-\n (define_expand \"call\"\n-  [(call (match_operand:QI 0 \"indirect_operand\" \"\")\n-\t (match_operand:SI 1 \"general_operand\" \"\"))]\n+  [(call (match_operand:QI 0 \"\" \"\")\n+\t (match_operand:SI 1 \"\" \"\"))]\n   ;; Operand 1 not used on the i386.\n   \"\"\n   \"\n {\n-  rtx addr;\n-\n+  /* ??? Not true for calls to static functions.  */\n   if (flag_pic)\n     current_function_uses_pic_offset_table = 1;\n \n-  /* With half-pic, force the address into a register.  */\n-  addr = XEXP (operands[0], 0);\n-  if (GET_CODE (addr) != REG && HALF_PIC_P () && !CONSTANT_ADDRESS_P (addr))\n-    XEXP (operands[0], 0) = force_reg (Pmode, addr);\n-\n-  if (! expander_call_insn_operand (operands[0], QImode))\n-    operands[0]\n-      = change_address (operands[0], VOIDmode,\n-\t\t\tcopy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n+  if (! call_insn_operand (operands[0], QImode))\n+    XEXP (operands[0], 0) = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n }\")\n \n-(define_insn \"*call_pic\"\n+(define_insn \"*call_1\"\n   [(call (match_operand:QI 0 \"call_insn_operand\" \"m\")\n \t (match_operand:SI 1 \"general_operand\" \"g\"))]\n   ;; Operand 1 not used on the i386.\n   \"\"\n   \"*\n {\n   if (constant_call_address_operand (operands[0], GET_MODE (operands[0])))\n-    return \\\"call\\\\t%P0\\\";\n-  \n+    {\n+      if (SIBLING_CALL_P (insn))\n+\treturn \\\"jmp\\\\t%P0\\\";\n+      else\n+\treturn \\\"call\\\\t%P0\\\";\n+    }\n+\n   operands[0] = XEXP (operands[0], 0);\n-  return \\\"call\\\\t%*%0\\\";\n+  if (SIBLING_CALL_P (insn))\n+    return \\\"jmp\\\\t%*%0\\\";\n+  else\n+    return \\\"call\\\\t%*%0\\\";\n }\"\n   [(set_attr \"type\" \"call\")])\n \n-(define_insn \"*call_pic2\"\n-  [(call (match_operand:QI 0 \"constant_call_address_operand\" \"\")\n-         (match_operand:SI 1 \"general_operand\" \"g\"))]\n-  \"!HALF_PIC_P ()\"\n-  \"call\\\\t%P0\"\n-  [(set_attr \"type\" \"call\")])\n-\n ;; Call subroutine, returning value in operand 0\n ;; (which must be a hard register).\n \n (define_expand \"call_value_pop\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (call (match_operand:QI 1 \"indirect_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"\")))\n+\t\t   (call (match_operand:QI 1 \"\" \"\")\n+\t\t\t (match_operand:SI 2 \"\" \"\")))\n \t      (set (reg:SI 7)\n \t\t   (plus:SI (reg:SI 7)\n-\t\t\t    (match_operand:SI 4 \"immediate_operand\" \"\")))])]\n+\t\t\t    (match_operand:SI 4 \"\" \"\")))])]\n   \"\"\n   \"\n {\n@@ -7141,42 +7114,30 @@\n       DONE;\n     }\n \n+  /* ??? Not true for calls to static functions.  */\n   if (flag_pic)\n     current_function_uses_pic_offset_table = 1;\n \n-  /* With half-pic, force the address into a register.  */\n-  addr = XEXP (operands[1], 0);\n-  if (GET_CODE (addr) != REG && HALF_PIC_P () && !CONSTANT_ADDRESS_P (addr))\n-    XEXP (operands[1], 0) = force_reg (Pmode, addr);\n-\n-  if (! expander_call_insn_operand (operands[1], QImode))\n-    operands[1]\n-      = change_address (operands[1], VOIDmode,\n-\t\t\tcopy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n+  if (! call_insn_operand (operands[1], QImode))\n+    XEXP (operands[1], 0) = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n }\")\n \n (define_expand \"call_value\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (match_operand:QI 1 \"indirect_operand\" \"\")\n-\t      (match_operand:SI 2 \"general_operand\" \"\")))]\n+\t(call (match_operand:QI 1 \"\" \"\")\n+\t      (match_operand:SI 2 \"\" \"\")))]\n   ;; Operand 2 not used on the i386.\n   \"\"\n   \"\n {\n   rtx addr;\n \n+  /* ??? Not true for calls to static functions.  */\n   if (flag_pic)\n     current_function_uses_pic_offset_table = 1;\n \n-  /* With half-pic, force the address into a register.  */\n-  addr = XEXP (operands[1], 0);\n-  if (GET_CODE (addr) != REG && HALF_PIC_P () && !CONSTANT_ADDRESS_P (addr))\n-    XEXP (operands[1], 0) = force_reg (Pmode, addr);\n-\n-  if (! expander_call_insn_operand (operands[1], QImode))\n-    operands[1]\n-      = change_address (operands[1], VOIDmode,\n-\t\t\tcopy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n+  if (! call_insn_operand (operands[1], QImode))\n+    XEXP (operands[1], 0) = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n }\")\n \n ;; Call subroutine returning any type.\n@@ -7309,7 +7270,12 @@\n (define_expand \"epilogue\"\n   [(const_int 1)]\n   \"\"\n-  \"ix86_expand_epilogue (); DONE;\")\n+  \"ix86_expand_epilogue (1); DONE;\")\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"ix86_expand_epilogue (0); DONE;\")\n \n (define_insn \"leave\"\n   [(set (reg:SI 7) (reg:SI 6))\n@@ -9414,16 +9380,6 @@\n }\"\n   [(set_attr \"type\" \"callv\")])\n \n-(define_insn \"*call_value_pop_2\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (match_operand:QI 1 \"constant_call_address_operand\" \"\")\n-\t      (match_operand:SI 2 \"general_operand\" \"g\")))\n-   (set (reg:SI 7) (plus:SI (reg:SI 7)\n-\t\t\t    (match_operand:SI 4 \"immediate_operand\" \"i\")))]\n-  \"!HALF_PIC_P ()\"\n-  \"call\\\\t%P1\"\n-  [(set_attr \"type\" \"callv\")])\n-\n (define_insn \"*call_value_1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (match_operand:QI 1 \"call_insn_operand\" \"m\")\n@@ -9433,17 +9389,17 @@\n   \"*\n {\n   if (constant_call_address_operand (operands[1], GET_MODE (operands[1])))\n-    return \\\"call\\\\t%P1\\\";\n+    {\n+      if (SIBLING_CALL_P (insn))\n+\treturn \\\"jmp\\\\t%P1\\\";\n+      else\n+\treturn \\\"call\\\\t%P1\\\";\n+    }\n   \n   operands[1] = XEXP (operands[1], 0);\n-  return \\\"call\\\\t%*%1\\\";\n+  if (SIBLING_CALL_P (insn))\n+    return \\\"jmp\\\\t%*%1\\\";\n+  else\n+    return \\\"call\\\\t%*%1\\\";\n }\"\n   [(set_attr \"type\" \"callv\")])\n-\n-(define_insn \"*call_value_2\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (match_operand:QI 1 \"constant_call_address_operand\" \"\")\n-\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n-  \"!HALF_PIC_P ()\"\n-  \"call\\\\t%P1\"\n-  [(set_attr \"type\" \"callv\")])"}]}