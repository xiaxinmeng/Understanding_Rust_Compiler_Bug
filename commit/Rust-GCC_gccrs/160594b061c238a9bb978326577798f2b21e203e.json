{"sha": "160594b061c238a9bb978326577798f2b21e203e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYwNTk0YjA2MWMyMzhhOWJiOTc4MzI2NTc3Nzk4ZjJiMjFlMjAzZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-10-28T18:39:36Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-10-28T18:39:36Z"}, "message": "Core issue 812, 861\n\n\tCore issue 812, 861\n\t* name-lookup.c (set_decl_namespace): Deal properly with inline\n\tnamespaces.\n\t(qualified_lookup_using_namespace): Overhaul.\n\t* pt.c (print_candidates): Handle getting an OVERLOAD.\n\nchange lookup algorithm\n\nFrom-SVN: r153682", "tree": {"sha": "f1d540d090314ee8a7349bfac90bf363738aaa57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1d540d090314ee8a7349bfac90bf363738aaa57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/160594b061c238a9bb978326577798f2b21e203e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/160594b061c238a9bb978326577798f2b21e203e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/160594b061c238a9bb978326577798f2b21e203e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/160594b061c238a9bb978326577798f2b21e203e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "34ad94d88cc7646f1d1eceea20a4451100265fd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34ad94d88cc7646f1d1eceea20a4451100265fd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34ad94d88cc7646f1d1eceea20a4451100265fd5"}], "stats": {"total": 268, "additions": 206, "deletions": 62}, "files": [{"sha": "83fdfe3b18189c5ffcb617f254a33c9e4cfdd45d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160594b061c238a9bb978326577798f2b21e203e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160594b061c238a9bb978326577798f2b21e203e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=160594b061c238a9bb978326577798f2b21e203e", "patch": "@@ -1,3 +1,11 @@\n+2009-10-28  Jason Merrill  <jason@redhat.com>\n+\n+\tCore issue 812, 861\n+\t* name-lookup.c (set_decl_namespace): Deal properly with inline\n+\tnamespaces.\n+\t(qualified_lookup_using_namespace): Overhaul.\n+\t* pt.c (print_candidates): Handle getting an OVERLOAD.\n+\n 2009-10-28  Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (cp_fname_init): Correct build_string argument."}, {"sha": "9a6991269f8f7853345c9df1bd70b34f37f52c6e", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 120, "deletions": 58, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160594b061c238a9bb978326577798f2b21e203e/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160594b061c238a9bb978326577798f2b21e203e/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=160594b061c238a9bb978326577798f2b21e203e", "patch": "@@ -3062,7 +3062,7 @@ set_namespace_binding (tree name, tree scope, tree val)\n void\n set_decl_namespace (tree decl, tree scope, bool friendp)\n {\n-  tree old, fn;\n+  tree old;\n \n   /* Get rid of namespace aliases.  */\n   scope = ORIGINAL_NAMESPACE (scope);\n@@ -3087,17 +3087,25 @@ set_decl_namespace (tree decl, tree scope, bool friendp)\n   if (old == error_mark_node)\n     /* No old declaration at all.  */\n     goto complain;\n+  /* If it's a TREE_LIST, the result of the lookup was ambiguous.  */\n+  if (TREE_CODE (old) == TREE_LIST)\n+    {\n+      error (\"reference to %qD is ambiguous\", decl);\n+      print_candidates (old);\n+      return;\n+    }\n   if (!is_overloaded_fn (decl))\n-    /* Don't compare non-function decls with decls_match here, since\n-       it can't check for the correct constness at this\n-       point. pushdecl will find those errors later.  */\n-    return;\n+    {\n+      /* We might have found OLD in an inline namespace inside SCOPE.  */\n+      DECL_CONTEXT (decl) = DECL_CONTEXT (old);\n+      /* Don't compare non-function decls with decls_match here, since\n+\t it can't check for the correct constness at this\n+\t point. pushdecl will find those errors later.  */\n+      return;\n+    }\n   /* Since decl is a function, old should contain a function decl.  */\n   if (!is_overloaded_fn (old))\n     goto complain;\n-  fn = OVL_CURRENT (old);\n-  if (!is_associated_namespace (scope, CP_DECL_CONTEXT (fn)))\n-    goto complain;\n   /* A template can be explicitly specialized in any namespace.  */\n   if (processing_explicit_instantiation)\n     return;\n@@ -3113,12 +3121,43 @@ set_decl_namespace (tree decl, tree scope, bool friendp)\n     return;\n   if (is_overloaded_fn (old))\n     {\n-      for (; old; old = OVL_NEXT (old))\n-\tif (decls_match (decl, OVL_CURRENT (old)))\n+      tree found = NULL_TREE;\n+      tree elt = old;\n+      for (; elt; elt = OVL_NEXT (elt))\n+\t{\n+\t  tree ofn = OVL_CURRENT (elt);\n+\t  /* Adjust DECL_CONTEXT first so decls_match will return true\n+\t     if DECL will match a declaration in an inline namespace.  */\n+\t  DECL_CONTEXT (decl) = DECL_CONTEXT (ofn);\n+\t  if (decls_match (decl, ofn))\n+\t    {\n+\t      if (found && !decls_match (found, ofn))\n+\t\t{\n+\t\t  DECL_CONTEXT (decl) = FROB_CONTEXT (scope);\n+\t\t  error (\"reference to %qD is ambiguous\", decl);\n+\t\t  print_candidates (old);\n+\t\t  return;\n+\t\t}\n+\t      found = ofn;\n+\t    }\n+\t}\n+      if (found)\n+\t{\n+\t  if (!is_associated_namespace (scope, CP_DECL_CONTEXT (found)))\n+\t    goto complain;\n+\t  DECL_CONTEXT (decl) = DECL_CONTEXT (found);\n \t  return;\n+\t}\n     }\n-  else if (decls_match (decl, old))\n-      return;\n+  else\n+    {\n+      DECL_CONTEXT (decl) = DECL_CONTEXT (old);\n+      if (decls_match (decl, old))\n+\treturn;\n+    }\n+\n+  /* It didn't work, go back to the explicit scope.  */\n+  DECL_CONTEXT (decl) = FROB_CONTEXT (scope);\n  complain:\n   error (\"%qD should have been declared inside %qD\", decl, scope);\n }\n@@ -3925,6 +3964,19 @@ lookup_using_namespace (tree name, struct scope_binding *val,\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val->value != error_mark_node);\n }\n \n+/* Returns true iff VEC contains TARGET.  */\n+\n+static bool\n+tree_vec_contains (VEC(tree,gc)* vec, tree target)\n+{\n+  unsigned int i;\n+  tree elt;\n+  for (i = 0; VEC_iterate(tree,vec,i,elt); ++i)\n+    if (elt == target)\n+      return true;\n+  return false;\n+}\n+\n /* [namespace.qual]\n    Accepts the NAME to lookup and its qualifying SCOPE.\n    Returns the name/type pair found into the cxx_binding *RESULT,\n@@ -3935,62 +3987,72 @@ qualified_lookup_using_namespace (tree name, tree scope,\n \t\t\t\t  struct scope_binding *result, int flags)\n {\n   /* Maintain a list of namespaces visited...  */\n-  tree seen = NULL_TREE;\n+  VEC(tree,gc) *seen = NULL;\n+  VEC(tree,gc) *seen_inline = NULL;\n   /* ... and a list of namespace yet to see.  */\n-  tree todo = NULL_TREE;\n-  tree todo_maybe = NULL_TREE;\n-  tree *todo_weak = &todo_maybe;\n+  VEC(tree,gc) *todo = NULL;\n+  VEC(tree,gc) *todo_maybe = NULL;\n+  VEC(tree,gc) *todo_inline = NULL;\n   tree usings;\n   timevar_push (TV_NAME_LOOKUP);\n   /* Look through namespace aliases.  */\n   scope = ORIGINAL_NAMESPACE (scope);\n-  while (scope && result->value != error_mark_node)\n+\n+  /* Algorithm: Starting with SCOPE, walk through the the set of used\n+     namespaces.  For each used namespace, look through its inline\n+     namespace set for any bindings and usings.  If no bindings are found,\n+     add any usings seen to the set of used namespaces.  */\n+  VEC_safe_push (tree, gc, todo, scope);\n+\n+  while (VEC_length (tree, todo))\n     {\n-      cxx_binding *binding =\n-\tcxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n-      seen = tree_cons (scope, NULL_TREE, seen);\n-      if (binding)\n-\tambiguous_decl (result, binding, flags);\n-\n-      /* Consider strong using directives always, and non-strong ones\n-\t if we haven't found a binding yet.  */\n-      for (usings = DECL_NAMESPACE_USING (scope); usings;\n-\t   usings = TREE_CHAIN (usings))\n-\t/* If this was a real directive, and we have not seen it.  */\n-\tif (!TREE_INDIRECT_USING (usings))\n-\t  {\n-\t    /* Try to avoid queuing the same namespace more than once,\n-\t       the exception being when a namespace was already\n-\t       enqueued for todo_maybe and then a strong using is\n-\t       found for it.  We could try to remove it from\n-\t       todo_maybe, but it's probably not worth the effort.  */\n-\t    if (is_associated_namespace (scope, TREE_PURPOSE (usings))\n-\t\t&& !purpose_member (TREE_PURPOSE (usings), seen)\n-\t\t&& !purpose_member (TREE_PURPOSE (usings), todo))\n-\t      todo = tree_cons (TREE_PURPOSE (usings), NULL_TREE, todo);\n-\t    else if (!binding\n-\t\t     && !purpose_member (TREE_PURPOSE (usings), seen)\n-\t\t     && !purpose_member (TREE_PURPOSE (usings), todo)\n-\t\t     && !purpose_member (TREE_PURPOSE (usings), todo_maybe))\n-\t      *todo_weak = tree_cons (TREE_PURPOSE (usings), NULL_TREE,\n-\t\t\t\t      *todo_weak);\n-\t  }\n-      if (todo)\n+      bool found_here;\n+      scope = VEC_pop (tree, todo);\n+      if (tree_vec_contains (seen, scope))\n+\tcontinue;\n+      VEC_safe_push (tree, gc, seen, scope);\n+      VEC_safe_push (tree, gc, todo_inline, scope);\n+\n+      found_here = false;\n+      while (VEC_length (tree, todo_inline))\n \t{\n-\t  scope = TREE_PURPOSE (todo);\n-\t  todo = TREE_CHAIN (todo);\n-\t}\n-      else if (todo_maybe\n-\t       && (!result->value && !result->type))\n-\t{\n-\t  scope = TREE_PURPOSE (todo_maybe);\n-\t  todo = TREE_CHAIN (todo_maybe);\n-\t  todo_maybe = NULL_TREE;\n-\t  todo_weak = &todo;\n+\t  cxx_binding *binding;\n+\n+\t  scope = VEC_pop (tree, todo_inline);\n+\t  if (tree_vec_contains (seen_inline, scope))\n+\t    continue;\n+\t  VEC_safe_push (tree, gc, seen_inline, scope);\n+\n+\t  binding =\n+\t    cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+\t  if (binding)\n+\t    {\n+\t      found_here = true;\n+\t      ambiguous_decl (result, binding, flags);\n+\t    }\n+\n+\t  for (usings = DECL_NAMESPACE_USING (scope); usings;\n+\t       usings = TREE_CHAIN (usings))\n+\t    if (!TREE_INDIRECT_USING (usings))\n+\t      {\n+\t\tif (is_associated_namespace (scope, TREE_PURPOSE (usings)))\n+\t\t  VEC_safe_push (tree, gc, todo_inline, TREE_PURPOSE (usings));\n+\t\telse\n+\t\t  VEC_safe_push (tree, gc, todo_maybe, TREE_PURPOSE (usings));\n+\t      }\n \t}\n+\n+      if (found_here)\n+\tVEC_truncate (tree, todo_maybe, 0);\n       else\n-\tscope = NULL_TREE; /* If there never was a todo list.  */\n+\twhile (VEC_length (tree, todo_maybe))\n+\t  VEC_safe_push (tree, gc, todo, VEC_pop (tree, todo_maybe));\n     }\n+  VEC_free (tree,gc,todo);\n+  VEC_free (tree,gc,todo_maybe);\n+  VEC_free (tree,gc,todo_inline);\n+  VEC_free (tree,gc,seen);\n+  VEC_free (tree,gc,seen_inline);\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result->value != error_mark_node);\n }\n "}, {"sha": "ace340eeb3f339326e88b5bc4f8560cd8616e523", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160594b061c238a9bb978326577798f2b21e203e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160594b061c238a9bb978326577798f2b21e203e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=160594b061c238a9bb978326577798f2b21e203e", "patch": "@@ -1640,13 +1640,20 @@ void\n print_candidates (tree fns)\n {\n   tree fn;\n+  tree f;\n \n   const char *str = \"candidates are:\";\n \n-  for (fn = fns; fn != NULL_TREE; fn = TREE_CHAIN (fn))\n+  if (is_overloaded_fn (fns))\n+    {\n+      for (f = fns; f; f = OVL_NEXT (f))\n+\t{\n+\t  error (\"%s %+#D\", str, OVL_CURRENT (f));\n+\t  str = \"               \";\n+\t}\n+    }\n+  else for (fn = fns; fn != NULL_TREE; fn = TREE_CHAIN (fn))\n     {\n-      tree f;\n-\n       for (f = TREE_VALUE (fn); f; f = OVL_NEXT (f))\n \terror (\"%s %+#D\", str, OVL_CURRENT (f));\n       str = \"               \";"}, {"sha": "b1568461dc5ba03d4021e106b3ea1a1f6ca8994f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160594b061c238a9bb978326577798f2b21e203e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160594b061c238a9bb978326577798f2b21e203e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=160594b061c238a9bb978326577798f2b21e203e", "patch": "@@ -1,3 +1,9 @@\n+2009-10-28  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/inline-ns1.C: New.\n+\t* g++.dg/cpp0x/inline-ns2.C: New.\n+\t* g++.dg/cpp0x/inline-ns3.C: New.\n+\n 2009-10-28  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR rtl-optimization/39715"}, {"sha": "e422d8970f1630704f6bd3d1086b6645351ebe97", "filename": "gcc/testsuite/g++.dg/cpp0x/inline-ns1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160594b061c238a9bb978326577798f2b21e203e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finline-ns1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160594b061c238a9bb978326577798f2b21e203e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finline-ns1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finline-ns1.C?ref=160594b061c238a9bb978326577798f2b21e203e", "patch": "@@ -0,0 +1,12 @@\n+// { dg-options -std=c++0x }\n+// { dg-final { scan-assembler \"_ZN1Q2V11fEv\" } }\n+// { dg-final { scan-assembler \"_ZN1Q2V11iE\" } }\n+\n+namespace Q {\n+  inline namespace V1 {\n+    extern int i;\n+    void f();\n+  }\n+}\n+int Q::i = 1;\n+void Q::f() { }"}, {"sha": "03851725bbd2edf104d4fe39f65402ccd3d71004", "filename": "gcc/testsuite/g++.dg/cpp0x/inline-ns2.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160594b061c238a9bb978326577798f2b21e203e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finline-ns2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160594b061c238a9bb978326577798f2b21e203e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finline-ns2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finline-ns2.C?ref=160594b061c238a9bb978326577798f2b21e203e", "patch": "@@ -0,0 +1,25 @@\n+// { dg-options -std=c++0x }\n+\n+namespace Q {\n+  inline namespace V1 {\n+    extern int i;\t\t// { dg-error \"\" }\n+    extern int j;\t\t// { dg-error \"\" }\n+    void f();\t\t\t// { dg-error \"\" }\n+    void g();\t\t\t// { dg-error \"\" }\n+  }\n+  inline namespace V2 {\n+    extern int j;\t\t// { dg-error \"\" }\n+    void g();\t\t\t// { dg-error \"\" }\n+  }\n+  extern int i;\t\t\t// { dg-error \"\" }\n+  void f();\t\t\t// { dg-error \"\" }\n+  void h();\n+}\n+namespace R {\n+  using namespace Q;\n+}\n+int Q::i = 1;\t\t\t// { dg-error \"ambiguous\" }\n+int Q::j = 1;\t\t\t// { dg-error \"ambiguous\" }\n+void Q::f() { }\t\t\t// { dg-error \"ambiguous\" }\n+void Q::g() { }\t\t\t// { dg-error \"ambiguous\" }\n+void R::h() { }\t\t\t// { dg-error \"\" }"}, {"sha": "8981a57ac4c4f5b43bbf05c2c3a3c970d04b8cfd", "filename": "gcc/testsuite/g++.dg/cpp0x/inline-ns3.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160594b061c238a9bb978326577798f2b21e203e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finline-ns3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160594b061c238a9bb978326577798f2b21e203e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finline-ns3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finline-ns3.C?ref=160594b061c238a9bb978326577798f2b21e203e", "patch": "@@ -0,0 +1,24 @@\n+namespace C\n+{\n+  void f();\n+}\n+\n+namespace B\n+{\n+  using namespace C;\n+\n+  inline namespace B1\n+  {\n+    void f();\n+  }\n+}\n+\n+namespace A\n+{\n+  using namespace B;\n+}\n+\n+int main()\n+{\n+  A::f();\n+}"}, {"sha": "a396afb973cd61d7071b05c81ef148db8d947ded", "filename": "gcc/testsuite/g++.dg/lookup/using16.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160594b061c238a9bb978326577798f2b21e203e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160594b061c238a9bb978326577798f2b21e203e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing16.C?ref=160594b061c238a9bb978326577798f2b21e203e", "patch": "@@ -3,7 +3,7 @@\n // { dg-do compile }\n \n namespace M {\n-  struct S {}; // { dg-error \"candidates are: struct M::S\" \"candidate 1\" }\n+  struct S {}; // { dg-error \"struct M::S\" \"candidate 1\" }\n }\n \n namespace N {"}]}