{"sha": "f7c1d73d8d8886f67f7f5c62e25ccc47979114e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdjMWQ3M2Q4ZDg4ODZmNjdmN2Y1YzYyZTI1Y2NjNDc5NzkxMTRlNA==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-04-18T11:53:37Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-04-18T11:53:37Z"}, "message": "tree-vect-transform.c (get_initial_def_for_reduction): Clean away the unused code for reduction without adjust-in-epilog to simplify...\n\n        * tree-vect-transform.c (get_initial_def_for_reduction): Clean away\n        the unused code for reduction without adjust-in-epilog to simplify the\n        function.\n\nFrom-SVN: r123948", "tree": {"sha": "d80e677d6f36caafb1249fecb1e64ac15366a88a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d80e677d6f36caafb1249fecb1e64ac15366a88a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7c1d73d8d8886f67f7f5c62e25ccc47979114e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7c1d73d8d8886f67f7f5c62e25ccc47979114e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7c1d73d8d8886f67f7f5c62e25ccc47979114e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7c1d73d8d8886f67f7f5c62e25ccc47979114e4/comments", "author": null, "committer": null, "parents": [{"sha": "638e37c250ae9f757e9c949148b084aa4b510f22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638e37c250ae9f757e9c949148b084aa4b510f22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/638e37c250ae9f757e9c949148b084aa4b510f22"}], "stats": {"total": 88, "additions": 32, "deletions": 56}, "files": [{"sha": "38bbf7c1e7d0985973752292ac5a31abaddbe6d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7c1d73d8d8886f67f7f5c62e25ccc47979114e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7c1d73d8d8886f67f7f5c62e25ccc47979114e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7c1d73d8d8886f67f7f5c62e25ccc47979114e4", "patch": "@@ -1,3 +1,9 @@\n+2007-04-18  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vect-transform.c (get_initial_def_for_reduction): Clean away\n+\tthe unused code for reduction without adjust-in-epilog to simplify the\n+\tfunction.\n+\n 2007-04-18  Wolfgang Gellerich  <gellerich@de.ibm.com>\n \n \t* config/s390/s390.h (S390_TDC_POSITIVE_ZERO): New constant."}, {"sha": "b2c17899d0587327a0ae6746d2530e0e6e9e5b96", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 26, "deletions": 56, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7c1d73d8d8886f67f7f5c62e25ccc47979114e4/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7c1d73d8d8886f67f7f5c62e25ccc47979114e4/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=f7c1d73d8d8886f67f7f5c62e25ccc47979114e4", "patch": "@@ -940,27 +940,25 @@ vect_finish_stmt_generation (tree stmt, tree vec_stmt,\n }\n \n \n-#define ADJUST_IN_EPILOG 1\n-\n /* Function get_initial_def_for_reduction\n \n    Input:\n    STMT - a stmt that performs a reduction operation in the loop.\n    INIT_VAL - the initial value of the reduction variable\n \n    Output:\n-   SCALAR_DEF - a tree that holds a value to be added to the final result\n-\tof the reduction (used for \"ADJUST_IN_EPILOG\" - see below).\n+   ADJUSTMENT_DEF - a tree that holds a value to be added to the final result\n+        of the reduction (used for adjusting the epilog - see below).\n    Return a vector variable, initialized according to the operation that STMT\n-\tperforms. This vector will be used as the initial value of the\n-\tvector of partial results.\n+        performs. This vector will be used as the initial value of the\n+        vector of partial results.\n \n-   Option1 (\"ADJUST_IN_EPILOG\"): Initialize the vector as follows:\n+   Option1 (adjust in epilog): Initialize the vector as follows:\n      add:         [0,0,...,0,0]\n      mult:        [1,1,...,1,1]\n      min/max:     [init_val,init_val,..,init_val,init_val]\n      bit and/or:  [init_val,init_val,..,init_val,init_val]\n-   and when necessary (e.g. add/mult case) let the caller know \n+   and when necessary (e.g. add/mult case) let the caller know\n    that it needs to adjust the result by init_val.\n \n    Option2: Initialize the vector as follows:\n@@ -981,84 +979,56 @@ vect_finish_stmt_generation (tree stmt, tree vec_stmt,\n    or [0,0,0,0] and let the caller know that it needs to adjust\n    the result at the end by 'init_val'.\n \n-   FORNOW: We use the \"ADJUST_IN_EPILOG\" scheme.\n-   TODO: Use some cost-model to estimate which scheme is more profitable.\n-*/\n+   FORNOW, we are using the 'adjust in epilog' scheme, because this way the\n+   initialization vector is simpler (same element in all entries).\n+   A cost model should help decide between these two schemes.  */\n \n static tree\n-get_initial_def_for_reduction (tree stmt, tree init_val, tree *scalar_def)\n+get_initial_def_for_reduction (tree stmt, tree init_val, tree *adjustment_def)\n {\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n   int nunits =  TYPE_VECTOR_SUBPARTS (vectype);\n-  int nelements;\n   enum tree_code code = TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1));\n   tree type = TREE_TYPE (init_val);\n-  tree def;\n-  tree vec, t = NULL_TREE;\n-  bool need_epilog_adjust;\n+  tree vecdef;\n+  tree def_for_init;\n+  tree init_def;\n+  tree t = NULL_TREE;\n   int i;\n   tree vector_type;\n \n   gcc_assert (INTEGRAL_TYPE_P (type) || SCALAR_FLOAT_TYPE_P (type));\n+  vecdef = vect_get_vec_def_for_operand (init_val, stmt, NULL);\n \n   switch (code)\n   {\n   case WIDEN_SUM_EXPR:\n   case DOT_PROD_EXPR:\n   case PLUS_EXPR:\n+    *adjustment_def = init_val;\n+    /* Create a vector of zeros for init_def.  */\n     if (INTEGRAL_TYPE_P (type))\n-      def = build_int_cst (type, 0);\n+      def_for_init = build_int_cst (type, 0);\n     else\n-      def = build_real (type, dconst0);\n-\n-#ifdef ADJUST_IN_EPILOG\n-    /* All the 'nunits' elements are set to 0. The final result will be\n-       adjusted by 'init_val' at the loop epilog.  */\n-    nelements = nunits;\n-    need_epilog_adjust = true;\n-#else\n-    /* 'nunits - 1' elements are set to 0; The last element is set to \n-        'init_val'.  No further adjustments at the epilog are needed.  */\n-    nelements = nunits - 1;\n-    need_epilog_adjust = false;\n-#endif\n+      def_for_init = build_real (type, dconst0);\n+      for (i = nunits - 1; i >= 0; --i)\n+    t = tree_cons (NULL_TREE, def_for_init, t);\n+    vector_type = get_vectype_for_scalar_type (TREE_TYPE (def_for_init));\n+    init_def = build_vector (vector_type, t);\n     break;\n \n   case MIN_EXPR:\n   case MAX_EXPR:\n-    def = init_val;\n-    nelements = nunits;\n-    need_epilog_adjust = false;\n+    *adjustment_def = NULL_TREE;\n+    init_def = vecdef;\n     break;\n \n   default:\n     gcc_unreachable ();\n   }\n \n-  for (i = nelements - 1; i >= 0; --i)\n-    t = tree_cons (NULL_TREE, def, t);\n-\n-  if (nelements == nunits - 1)\n-    {\n-      /* Set the last element of the vector.  */\n-      t = tree_cons (NULL_TREE, init_val, t);\n-      nelements += 1;\n-    }\n-  gcc_assert (nelements == nunits);\n-\n-  vector_type = get_vectype_for_scalar_type (TREE_TYPE (def));\n-  if (TREE_CODE (init_val) == INTEGER_CST || TREE_CODE (init_val) == REAL_CST)\n-    vec = build_vector (vector_type, t);\n-  else\n-    vec = build_constructor_from_list (vector_type, t);\n-    \n-  if (!need_epilog_adjust)\n-    *scalar_def = NULL_TREE;\n-  else\n-    *scalar_def = init_val;\n-\n-  return vect_init_vector (stmt, vec, vector_type);\n+  return init_def;\n }\n \n "}]}