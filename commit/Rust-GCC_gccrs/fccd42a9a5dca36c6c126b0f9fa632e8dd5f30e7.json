{"sha": "fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNjZDQyYTlhNWRjYTM2YzZjMTI2YjBmOWZhNjMyZThkZDVmMzBlNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T15:27:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T15:27:54Z"}, "message": "[multiple changes]\n\n2011-08-03  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Conditional_Expression): only allow boolean\n\tconditional expression in ALFA.\n\t* sem_res.adb (Resolve_Conditional_Expression): mark non-boolean\n\texpressions as not in ALFA.\n\n2011-08-03  Robert Dewar  <dewar@adacore.com>\n\n\t* a-cofove.adb: Minor reformatting.\n\n2011-08-03  Emmanuel Briot  <briot@adacore.com>\n\n\t* make.adb, prj.adb, prj.ads, makeutl.adb, makeutl.ads\n\t(Insert_Project_Sources, Insert_withed_Sources_For): moved from the\n\tgprbuild sources.\n\tThese packages are more logically placed in the Queue package, since\n\tthey manipulate the queue. It is also likely that they can be adapted\n\tfor gnatmake, thus sharing more code.\n\t(Finish_Program, Fail_Program): moved from the gprbuild sources, so\n\tthat we could move the above.\n\n2011-08-03  Emmanuel Briot  <briot@adacore.com>\n\n\t* errutil.adb (Finalize): clean up the list of error messages on exit.\n\tCalling this subprogram multiple times will no longer show duplicate\n\terror messages on stderr.\n\n2011-08-03  Emmanuel Briot  <briot@adacore.com>\n\n\t* g-comlin.adb, g-comlin.ads (Set_Command_Line): ignore the parameter\n\tGetopt_Switches when we have already define a command line\n\tconfiguration.\n\nFrom-SVN: r177286", "tree": {"sha": "691e535ad779aa9a344f9ae0bfad919b3ee6b0a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/691e535ad779aa9a344f9ae0bfad919b3ee6b0a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/comments", "author": null, "committer": null, "parents": [{"sha": "5e8c8e4457de992f8f7081f20aaf11778656d344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8c8e4457de992f8f7081f20aaf11778656d344", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e8c8e4457de992f8f7081f20aaf11778656d344"}], "stats": {"total": 1205, "additions": 894, "deletions": 311}, "files": [{"sha": "f7498abff7c56e8191bcd253fdc05671240b931f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "patch": "@@ -1,3 +1,37 @@\n+2011-08-03  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Conditional_Expression): only allow boolean\n+\tconditional expression in ALFA.\n+\t* sem_res.adb (Resolve_Conditional_Expression): mark non-boolean\n+\texpressions as not in ALFA.\n+\n+2011-08-03  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-cofove.adb: Minor reformatting.\n+\n+2011-08-03  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* make.adb, prj.adb, prj.ads, makeutl.adb, makeutl.ads\n+\t(Insert_Project_Sources, Insert_withed_Sources_For): moved from the\n+\tgprbuild sources.\n+\tThese packages are more logically placed in the Queue package, since\n+\tthey manipulate the queue. It is also likely that they can be adapted\n+\tfor gnatmake, thus sharing more code.\n+\t(Finish_Program, Fail_Program): moved from the gprbuild sources, so\n+\tthat we could move the above.\n+\n+2011-08-03  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* errutil.adb (Finalize): clean up the list of error messages on exit.\n+\tCalling this subprogram multiple times will no longer show duplicate\n+\terror messages on stderr.\n+\n+2011-08-03  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* g-comlin.adb, g-comlin.ads (Set_Command_Line): ignore the parameter\n+\tGetopt_Switches when we have already define a command line\n+\tconfiguration.\n+\n 2011-08-03  Yannick Moy  <moy@adacore.com>\n \n \t* sem_ch11.adb (Analyze_Raise_xxx_Error): do not mark such nodes as not"}, {"sha": "3533c2a409694d72084933e143c099f5ca0d0463", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 51, "deletions": 110, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "patch": "@@ -44,31 +44,28 @@ package body Ada.Containers.Formal_Vectors is\n    function \"&\" (Left, Right : Vector) return Vector is\n       LN : constant Count_Type := Length (Left);\n       RN : constant Count_Type := Length (Right);\n-   begin\n \n+   begin\n       if LN = 0 then\n          if RN = 0 then\n             return Empty_Vector;\n          end if;\n \n          declare\n             E : constant Elements_Array (1 .. Length (Right)) :=\n-              Right.Elements (1 .. RN);\n+                  Right.Elements (1 .. RN);\n          begin\n-            return (Length (Right), E,\n-                    Last => Right.Last, others => <>);\n+            return (Length (Right), E, Last => Right.Last, others => <>);\n          end;\n       end if;\n \n       if RN = 0 then\n          declare\n             E : constant Elements_Array (1 .. Length (Left)) :=\n-              Left.Elements (1 .. LN);\n+                  Left.Elements (1 .. LN);\n          begin\n-            return (Length (Left), E,\n-                    Last => Left.Last, others => <>);\n+            return (Length (Left), E, Last => Left.Last, others => <>);\n          end;\n-\n       end if;\n \n       declare\n@@ -91,16 +88,13 @@ package body Ada.Containers.Formal_Vectors is\n          declare\n             Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-            LE : constant Elements_Array (1 .. LN) :=\n-              Left.Elements (1 .. LN);\n-\n+            LE : constant Elements_Array (1 .. LN) := Left.Elements (1 .. LN);\n             RE : Elements_Array renames Right.Elements (1 .. RN);\n \n             Capacity : constant Count_Type := Length (Left) + Length (Right);\n \n          begin\n-            return (Capacity, LE & RE,\n-                    Last => Last, others => <>);\n+            return (Capacity, LE & RE, Last => Last, others => <>);\n          end;\n       end;\n    end \"&\";\n@@ -111,8 +105,7 @@ package body Ada.Containers.Formal_Vectors is\n \n    begin\n       if LN = 0 then\n-         return (1, (1 .. 1 => Right),\n-                 Index_Type'First, others => <>);\n+         return (1, (1 .. 1 => Right), Index_Type'First, others => <>);\n       end if;\n \n       if Int (Index_Type'First) > Int'Last - Int (LN) then\n@@ -127,17 +120,13 @@ package body Ada.Containers.Formal_Vectors is\n \n       declare\n          Last : constant Index_Type := Index_Type (Last_As_Int);\n-\n-         LE : constant Elements_Array (1 .. LN) :=\n-           Left.Elements (1 .. LN);\n+         LE   : constant Elements_Array (1 .. LN) := Left.Elements (1 .. LN);\n \n          Capacity : constant Count_Type := Length (Left) + 1;\n \n       begin\n-         return (Capacity, LE & Right,\n-                 Last => Last, others => <>);\n+         return (Capacity, LE & Right, Last => Last, others => <>);\n       end;\n-\n    end \"&\";\n \n    function \"&\" (Left  : Element_Type; Right : Vector) return Vector is\n@@ -161,15 +150,11 @@ package body Ada.Containers.Formal_Vectors is\n       end if;\n \n       declare\n-         Last : constant Index_Type := Index_Type (Last_As_Int);\n-\n-         RE : Elements_Array renames Right.Elements (1 .. RN);\n-\n+         Last     : constant Index_Type := Index_Type (Last_As_Int);\n+         RE       : Elements_Array renames Right.Elements (1 .. RN);\n          Capacity : constant Count_Type := 1 + Length (Right);\n-\n       begin\n-         return (Capacity, Left & RE,\n-                 Last => Last, others => <>);\n+         return (Capacity, Left & RE, Last => Last, others => <>);\n       end;\n    end \"&\";\n \n@@ -181,10 +166,8 @@ package body Ada.Containers.Formal_Vectors is\n \n       declare\n          Last : constant Index_Type := Index_Type'First + 1;\n-\n       begin\n-         return (2, (Left, Right),\n-                 Last => Last, others => <>);\n+         return (2, (Left, Right), Last => Last, others => <>);\n       end;\n    end \"&\";\n \n@@ -217,7 +200,6 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Append (Container : in out Vector; New_Item : Vector) is\n    begin\n-\n       if Is_Empty (New_Item) then\n          return;\n       end if;\n@@ -226,10 +208,7 @@ package body Ada.Containers.Formal_Vectors is\n          raise Constraint_Error with \"vector is already at its maximum length\";\n       end if;\n \n-      Insert\n-        (Container,\n-         Container.Last + 1,\n-         New_Item);\n+      Insert (Container, Container.Last + 1, New_Item);\n    end Append;\n \n    procedure Append\n@@ -238,7 +217,6 @@ package body Ada.Containers.Formal_Vectors is\n       Count     : Count_Type := 1)\n    is\n    begin\n-\n       if Count = 0 then\n          return;\n       end if;\n@@ -249,11 +227,7 @@ package body Ada.Containers.Formal_Vectors is\n \n       --  TODO: should check whether length > max capacity (cnt_t'last)  ???\n \n-      Insert\n-        (Container,\n-         Container.Last + 1,\n-         New_Item,\n-         Count);\n+      Insert (Container, Container.Last + 1, New_Item, Count);\n    end Append;\n \n    ------------\n@@ -262,8 +236,8 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Assign (Target : in out Vector; Source : Vector) is\n       LS : constant Count_Type := Length (Source);\n-   begin\n \n+   begin\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -274,10 +248,8 @@ package body Ada.Containers.Formal_Vectors is\n \n       Target.Clear;\n \n-         Target.Elements (1 .. LS) :=\n-           Source.Elements (1 .. LS);\n-         Target.Last := Source.Last;\n-\n+      Target.Elements (1 .. LS) := Source.Elements (1 .. LS);\n+      Target.Last := Source.Last;\n    end Assign;\n \n    --------------\n@@ -295,7 +267,6 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Clear (Container : in out Vector) is\n    begin\n-\n       if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is busy)\";\n@@ -330,19 +301,15 @@ package body Ada.Containers.Formal_Vectors is\n    begin\n       if Capacity = 0 then\n          C := LS;\n-\n       elsif Capacity >= LS then\n          C := Capacity;\n-\n       else\n          raise Constraint_Error;\n       end if;\n \n-      return Target                   : Vector (C) do\n-         Target.Elements (1 .. LS) :=\n-           Source.Elements (1 .. LS);\n+      return Target : Vector (C) do\n+         Target.Elements (1 .. LS) := Source.Elements (1 .. LS);\n          Target.Last := Source.Last;\n-\n       end return;\n    end Copy;\n \n@@ -356,7 +323,6 @@ package body Ada.Containers.Formal_Vectors is\n       Count     : Count_Type := 1)\n    is\n    begin\n-\n       if Index < Index_Type'First then\n          raise Constraint_Error with \"Index is out of range (too small)\";\n       end if;\n@@ -380,8 +346,7 @@ package body Ada.Containers.Formal_Vectors is\n \n       declare\n          I_As_Int        : constant Int := Int (Index);\n-         Old_Last_As_Int : constant Int :=\n-                             Index_Type'Pos (Container.Last);\n+         Old_Last_As_Int : constant Int := Index_Type'Pos (Container.Last);\n \n          Count1 : constant Int'Base := Count_Type'Pos (Count);\n          Count2 : constant Int'Base := Old_Last_As_Int - I_As_Int + 1;\n@@ -424,7 +389,6 @@ package body Ada.Containers.Formal_Vectors is\n       Count     : Count_Type := 1)\n    is\n    begin\n-\n       if not Position.Valid then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -446,7 +410,6 @@ package body Ada.Containers.Formal_Vectors is\n       Count     : Count_Type := 1)\n    is\n    begin\n-\n       if Count = 0 then\n          return;\n       end if;\n@@ -470,7 +433,6 @@ package body Ada.Containers.Formal_Vectors is\n       Index : Int'Base;\n \n    begin\n-\n       if Count = 0 then\n          return;\n       end if;\n@@ -505,9 +467,7 @@ package body Ada.Containers.Formal_Vectors is\n       declare\n          II : constant Int'Base := Int (Index) - Int (No_Index);\n          I  : constant Count_Type := Count_Type (II);\n-\n       begin\n-\n          return Get_Element (Container, I);\n       end;\n    end Element;\n@@ -517,6 +477,7 @@ package body Ada.Containers.Formal_Vectors is\n       Position  : Cursor) return Element_Type\n    is\n       Lst : constant Index_Type := Last_Index (Container);\n+\n    begin\n       if not Position.Valid then\n          raise Constraint_Error with \"Position cursor has no element\";\n@@ -529,9 +490,7 @@ package body Ada.Containers.Formal_Vectors is\n       declare\n          II : constant Int'Base := Int (Position.Index) - Int (No_Index);\n          I  : constant Count_Type := Count_Type (II);\n-\n       begin\n-\n          return Get_Element (Container, I);\n       end;\n    end Element;\n@@ -549,7 +508,6 @@ package body Ada.Containers.Formal_Vectors is\n       Last : constant Index_Type := Last_Index (Container);\n \n    begin\n-\n       if Position.Valid then\n          if Position.Index > Last_Index (Container) then\n             raise Program_Error with \"Position index is out of range\";\n@@ -562,11 +520,11 @@ package body Ada.Containers.Formal_Vectors is\n          if Get_Element (Container, K) = Item then\n             return Cursor'(Index => J, others => <>);\n          end if;\n+\n          K := K + 1;\n       end loop;\n \n       return No_Element;\n-\n    end Find;\n \n    ----------------\n@@ -588,6 +546,7 @@ package body Ada.Containers.Formal_Vectors is\n          if Get_Element (Container, K) = Item then\n             return Indx;\n          end if;\n+\n          K := K + 1;\n       end loop;\n \n@@ -642,19 +601,19 @@ package body Ada.Containers.Formal_Vectors is\n \n       function Is_Sorted (Container : Vector) return Boolean is\n          Last : constant Index_Type := Last_Index (Container);\n-      begin\n \n+      begin\n          if Container.Last <= Last then\n             return True;\n          end if;\n \n          declare\n             L : constant Capacity_Subtype := Length (Container);\n          begin\n-\n             for J in Count_Type range 1 .. L - 1 loop\n-               if Get_Element (Container, J + 1)\n-                 < Get_Element (Container, J) then\n+               if Get_Element (Container, J + 1) <\n+                  Get_Element (Container, J)\n+               then\n                   return False;\n                end if;\n             end loop;\n@@ -692,6 +651,7 @@ package body Ada.Containers.Formal_Vectors is\n             end if;\n \n             --  I think we're missing this check in a-convec.adb...  ???\n+\n             if Target.Busy > 0 then\n                raise Program_Error with\n                  \"attempt to tamper with elements (vector is busy)\";\n@@ -717,8 +677,7 @@ package body Ada.Containers.Formal_Vectors is\n                   return;\n                end if;\n \n-               pragma Assert (I <= 1\n-                              or else not (TA (I) < TA (I - 1)));\n+               pragma Assert (I <= 1 or else not (TA (I) < TA (I - 1)));\n \n                if SA (Length (Source)) < TA (I) then\n                   TA (J) := TA (I);\n@@ -746,8 +705,8 @@ package body Ada.Containers.Formal_Vectors is\n               Element_Type => Element_Type,\n               Array_Type   => Elements_Array,\n               \"<\"          => \"<\");\n-      begin\n \n+      begin\n          if Container.Last <= Index_Type'First then\n             return;\n          end if;\n@@ -768,11 +727,10 @@ package body Ada.Containers.Formal_Vectors is\n \n    function Get_Element\n      (Container : Vector;\n-      Position  : Count_Type) return Element_Type is\n+      Position  : Count_Type) return Element_Type\n+   is\n    begin\n-\n       return Container.Elements (Position);\n-\n    end Get_Element;\n \n    -----------------\n@@ -781,13 +739,14 @@ package body Ada.Containers.Formal_Vectors is\n \n    function Has_Element\n      (Container : Vector;\n-      Position  : Cursor) return Boolean is\n+      Position  : Cursor) return Boolean\n+   is\n    begin\n       if not Position.Valid then\n          return False;\n+      else\n+         return Position.Index <= Last_Index (Container);\n       end if;\n-\n-      return Position.Index <= Last_Index (Container);\n    end Has_Element;\n \n    ------------\n@@ -809,7 +768,6 @@ package body Ada.Containers.Formal_Vectors is\n       Max_Length      : constant UInt := UInt (Container.Capacity);\n \n    begin\n-\n       if Before < Index_Type'First then\n          raise Constraint_Error with\n            \"Before index is out of range (too small)\";\n@@ -870,7 +828,6 @@ package body Ada.Containers.Formal_Vectors is\n             declare\n                II : constant Int'Base := BB + N;\n                I  : constant Count_Type := Count_Type (II);\n-\n             begin\n                EA (I .. L) := EA (B .. Length (Container));\n                EA (B .. I - 1) := (others => New_Item);\n@@ -892,7 +849,6 @@ package body Ada.Containers.Formal_Vectors is\n       N : constant Count_Type := Length (New_Item);\n \n    begin\n-\n       if Before < Index_Type'First then\n          raise Constraint_Error with\n            \"Before index is out of range (too small)\";\n@@ -921,11 +877,8 @@ package body Ada.Containers.Formal_Vectors is\n          B  : constant Count_Type := Count_Type (BB);\n \n       begin\n-\n          if Container'Address /= New_Item'Address then\n-            Container.Elements (B .. Dst_Last) :=\n-              New_Item.Elements (1 .. N);\n-\n+            Container.Elements (B .. Dst_Last) := New_Item.Elements (1 .. N);\n             return;\n          end if;\n \n@@ -948,8 +901,7 @@ package body Ada.Containers.Formal_Vectors is\n \n          declare\n             Src : Elements_Array renames\n-                    Container.Elements\n-                      (Dst_Last + 1 .. Length (Container));\n+                    Container.Elements (Dst_Last + 1 .. Length (Container));\n \n             Index_As_Int : constant Int'Base :=\n                              Dst_Last_As_Int - Src'Length + 1;\n@@ -973,7 +925,6 @@ package body Ada.Containers.Formal_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-\n       if Is_Empty (New_Item) then\n          return;\n       end if;\n@@ -1004,7 +955,6 @@ package body Ada.Containers.Formal_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-\n       if Is_Empty (New_Item) then\n          if not Before.Valid\n            or else Before.Index > Container.Last\n@@ -1045,7 +995,6 @@ package body Ada.Containers.Formal_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-\n       if Count = 0 then\n          return;\n       end if;\n@@ -1077,7 +1026,6 @@ package body Ada.Containers.Formal_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-\n       if Count = 0 then\n          if not Before.Valid\n            or else Before.Index > Container.Last\n@@ -1129,7 +1077,6 @@ package body Ada.Containers.Formal_Vectors is\n    is\n       New_Item : Element_Type;  -- Default-initialized value\n       pragma Warnings (Off, New_Item);\n-\n    begin\n       Insert (Container, Before, New_Item, Position, Count);\n    end Insert;\n@@ -1152,7 +1099,6 @@ package body Ada.Containers.Formal_Vectors is\n       Max_Length      : constant UInt := UInt (Count_Type'Last);\n \n    begin\n-\n       if Before < Index_Type'First then\n          raise Constraint_Error with\n            \"Before index is out of range (too small)\";\n@@ -1213,7 +1159,6 @@ package body Ada.Containers.Formal_Vectors is\n             declare\n                II : constant Int'Base := BB + N;\n                I  : constant Count_Type := Count_Type (II);\n-\n             begin\n                EA (I .. L) := EA (B .. Length (Container));\n             end;\n@@ -1232,7 +1177,6 @@ package body Ada.Containers.Formal_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-\n       if Count = 0 then\n          if not Before.Valid\n            or else Before.Index > Container.Last\n@@ -1354,12 +1298,13 @@ package body Ada.Containers.Formal_Vectors is\n    ----------\n \n    function Left (Container : Vector; Position : Cursor) return Vector is\n-      C : Vector (Container.Capacity) :=\n-        Copy (Container, Container.Capacity);\n+      C : Vector (Container.Capacity) := Copy (Container, Container.Capacity);\n+\n    begin\n       if Position = No_Element then\n          return C;\n       end if;\n+\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error;\n       end if;\n@@ -1640,7 +1585,6 @@ package body Ada.Containers.Formal_Vectors is\n       declare\n          II : constant Int'Base := Int (Position.Index) - Int (No_Index);\n          I  : constant Count_Type := Count_Type (II);\n-\n       begin\n          Container.Elements (I) := New_Item;\n       end;\n@@ -1655,7 +1599,6 @@ package body Ada.Containers.Formal_Vectors is\n       Capacity  : Capacity_Subtype)\n    is\n    begin\n-\n       if Capacity > Container.Capacity then\n          raise Constraint_Error;  -- ???\n       end if;\n@@ -1667,7 +1610,6 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Reverse_Elements (Container : in out Vector) is\n    begin\n-\n       if Length (Container) <= 1 then\n          return;\n       end if;\n@@ -1687,7 +1629,6 @@ package body Ada.Containers.Formal_Vectors is\n          while I < J loop\n             declare\n                EI : constant Element_Type := E (I);\n-\n             begin\n                E (I) := E (J);\n                E (J) := EI;\n@@ -1712,7 +1653,6 @@ package body Ada.Containers.Formal_Vectors is\n       K    : Count_Type;\n \n    begin\n-\n       if not Position.Valid\n         or else Position.Index > Last_Index (Container)\n       then\n@@ -1726,6 +1666,7 @@ package body Ada.Containers.Formal_Vectors is\n          if Get_Element (Container, K) = Item then\n             return (True, Indx);\n          end if;\n+\n          K := K - 1;\n       end loop;\n \n@@ -1756,6 +1697,7 @@ package body Ada.Containers.Formal_Vectors is\n          if Get_Element (Container, K) = Item then\n             return Indx;\n          end if;\n+\n          K := K - 1;\n       end loop;\n \n@@ -1768,8 +1710,8 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Reverse_Iterate\n      (Container : Vector;\n-      Process   :\n-        not null access procedure (Container : Vector; Position : Cursor))\n+      Process   : not null access procedure (Container : Vector;\n+                                             Position : Cursor))\n    is\n       V : Vector renames Container'Unrestricted_Access.all;\n       B : Natural renames V.Busy;\n@@ -1795,20 +1737,22 @@ package body Ada.Containers.Formal_Vectors is\n    -----------\n \n    function Right (Container : Vector; Position : Cursor) return Vector is\n-      C : Vector (Container.Capacity) :=\n-        Copy (Container, Container.Capacity);\n+      C : Vector (Container.Capacity) := Copy (Container, Container.Capacity);\n+\n    begin\n       if Position = No_Element then\n          Clear (C);\n          return C;\n       end if;\n+\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error;\n       end if;\n \n       while C.Last /= Container.Last - Position.Index + 1 loop\n          Delete_First (C);\n       end loop;\n+\n       return C;\n    end Right;\n \n@@ -1821,7 +1765,6 @@ package body Ada.Containers.Formal_Vectors is\n       Length    : Capacity_Subtype)\n    is\n    begin\n-\n       if Length = Formal_Vectors.Length (Container) then\n          return;\n       end if;\n@@ -1849,7 +1792,6 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Swap (Container : in out Vector; I, J : Index_Type) is\n    begin\n-\n       if I > Container.Last then\n          raise Constraint_Error with \"I index is out of range\";\n       end if;\n@@ -1884,7 +1826,6 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Swap (Container : in out Vector; I, J : Cursor) is\n    begin\n-\n       if not I.Valid then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;"}, {"sha": "cf6e9ef2b3d6a801aef41ccccbfccfaf8f61af77", "filename": "gcc/ada/errutil.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Ferrutil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Ferrutil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrutil.adb?ref=fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1991-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1991-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -571,6 +571,10 @@ package body Errutil is\n          Total_Errors_Detected := Total_Errors_Detected + Warnings_Detected;\n          Warnings_Detected := 0;\n       end if;\n+\n+      --  Prevent displaying the same messages again in the future\n+\n+      First_Error_Msg := No_Error_Msg;\n    end Finalize;\n \n    ----------------"}, {"sha": "51321b56694b9856aae804c886d3c388777cea3b", "filename": "gcc/ada/g-comlin.adb", "status": "modified", "additions": 56, "deletions": 26, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -19,10 +19,10 @@\n -- additional permissions described in the GCC Runtime Library Exception,   --\n -- version 3.1, as published by the Free Software Foundation.               --\n --                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n+-- In particular,  you can freely  distribute your programs  built with the --\n+-- GNAT Pro compiler, including any required library run-time units,  using --\n+-- any licensing terms  of your choosing.  See the AdaCore Software License --\n+-- for full details.                                                        --\n --                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --\n@@ -200,7 +200,8 @@ package body GNAT.Command_Line is\n      (Config   : Command_Line_Configuration;\n       Section  : String);\n    --  Iterate over all switches defined in Config, for a specific section.\n-   --  Index is set to the index in Config.Switches\n+   --  Index is set to the index in Config.Switches.\n+   --  Stop iterating when Callback returns False.\n \n    --------------\n    -- Argument --\n@@ -1238,6 +1239,10 @@ package body GNAT.Command_Line is\n          Unchecked_Free (Tmp);\n       end if;\n \n+      if Switch.Switch /= null and then Switch.Switch.all = \"*\" then\n+         Config.Star_Switch := True;\n+      end if;\n+\n       Config.Switches (Config.Switches'Last) := Switch;\n    end Add;\n \n@@ -1592,9 +1597,28 @@ package body GNAT.Command_Line is\n \n          loop\n             begin\n-               S := Getopt (Switches    => \"* \" & Getopt_Description,\n-                            Concatenate => False,\n-                            Parser      => Parser);\n+               if Cmd.Config /= null then\n+                  --  Do not use Getopt_Description in this case. Otherwise,\n+                  --  if we have defined a prefix -gnaty, and two switches\n+                  --  -gnatya and -gnatyL!, we would have a different behavior\n+                  --  depending on the order of switches:\n+                  --      -gnatyL1a   =>  -gnatyL with argument \"1a\"\n+                  --      -gnatyaL1   =>  -gnatya and -gnatyL with argument \"1\"\n+                  --  This is because the call to Getopt below knows nothing\n+                  --  about prefixes, and in the first case finds a valid\n+                  --  switch with arguments, so returns it without analyzing\n+                  --  the argument. In the second case, the switch matches \"*\",\n+                  --  and is then decomposed below.\n+\n+                  S := Getopt (Switches    => \"*\",\n+                               Concatenate => False,\n+                               Parser      => Parser);\n+               else\n+                  S := Getopt (Switches    => \"* \" & Getopt_Description,\n+                               Concatenate => False,\n+                               Parser      => Parser);\n+               end if;\n+\n                exit when S = ASCII.NUL;\n \n                declare\n@@ -1761,6 +1785,8 @@ package body GNAT.Command_Line is\n \n          function Analyze_Simple_Switch\n            (Switch : String; Index : Integer) return Boolean;\n+         --  \"Switches\" is one of the switch definitions passed to the\n+         --  configuration, not one of the switches found on the command line.\n \n          ---------------------------\n          -- Analyze_Simple_Switch --\n@@ -1772,26 +1798,26 @@ package body GNAT.Command_Line is\n             pragma Unreferenced (Index);\n \n             Full  : constant String := Prefix & Group (Idx .. Group'Last);\n+\n             Sw    : constant String := Actual_Switch (Switch);\n+            --  Switches definition minus argument definition\n+\n             Last  : Natural;\n             Param : Natural;\n \n          begin\n-            if Sw'Length >= Prefix'Length\n-\n-            --  Verify that sw starts with Prefix\n-\n-              and then Looking_At (Sw, Sw'First, Prefix)\n-\n-            --  Verify that the group starts with sw\n+            if\n+               --  Verify that sw starts with Prefix\n+               Looking_At (Sw, Sw'First, Prefix)\n \n+               --  Verify that the group starts with sw\n               and then Looking_At (Full, Full'First, Sw)\n+\n             then\n                Last  := Idx + Sw'Length - Prefix'Length - 1;\n                Param := Last + 1;\n \n                if Can_Have_Parameter (Switch) then\n-\n                   --  Include potential parameter to the recursive call.\n                   --  Only numbers are allowed.\n \n@@ -1989,8 +2015,10 @@ package body GNAT.Command_Line is\n       --  First determine if the switch corresponds to one belonging to the\n       --  configuration. If so, run callback and exit.\n \n-      Foreach_In_Config (Config, Section);\n+      --  ??? Is this necessary. On simple tests, we seem to have the same\n+      --  results with or without this call.\n \n+      Foreach_In_Config (Config, Section);\n       if Found_In_Config then\n          return;\n       end if;\n@@ -2127,10 +2155,17 @@ package body GNAT.Command_Line is\n          Param     : String;\n          Index     : Integer)\n       is\n-         pragma Unreferenced (Index);\n          Sep : Character;\n \n       begin\n+         if Index = -1\n+           and then Cmd.Config /= null\n+           and then not Cmd.Config.Star_Switch\n+         then\n+            raise Invalid_Switch\n+              with \"Invalid switch \" & Simple;\n+         end if;\n+\n          if Separator = \"\" then\n             Sep := ASCII.NUL;\n          else\n@@ -2808,13 +2843,8 @@ package body GNAT.Command_Line is\n       if Iter.List = null then\n          Iter.Current := Integer'Last;\n       else\n-         Iter.Current := Iter.List'First;\n-\n-         while Iter.Current <= Iter.List'Last\n-           and then Iter.List (Iter.Current) = null\n-         loop\n-            Iter.Current := Iter.Current + 1;\n-         end loop;\n+         Iter.Current := Iter.List'First - 1;\n+         Next (Iter);\n       end if;\n    end Start;\n "}, {"sha": "0544854d52e6c94b75944d5eaee0047612b41ddc", "filename": "gcc/ada/g-comlin.ads", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fg-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fg-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.ads?ref=fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1999-2010, AdaCore                     --\n+--                     Copyright (C) 1999-2011, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -583,6 +583,10 @@ package GNAT.Command_Line is\n    --  assumed that the remainder of the switch (\"uv\") is a set of characters\n    --  whose order is irrelevant. In fact, this package will sort them\n    --  alphabetically.\n+   --  When grouping switches that accept arguments (for instance \"-gnatyL!\"\n+   --  as the definition, and \"-gnatyaL12b\" as the command line), only\n+   --  numerical arguments are accepted. The above is equivalent to\n+   --  \"-gnatya -gnatyL12 -gnatyb\".\n \n    procedure Define_Switch\n      (Config      : in out Command_Line_Configuration;\n@@ -768,7 +772,9 @@ package GNAT.Command_Line is\n       Config : Command_Line_Configuration);\n    function Get_Configuration\n      (Cmd : Command_Line) return Command_Line_Configuration;\n-   --  Set or retrieve the configuration used for that command line\n+   --  Set or retrieve the configuration used for that command line.\n+   --  The Config must have been initialized first, by calling one of the\n+   --  Define_Switches subprograms.\n \n    procedure Set_Command_Line\n      (Cmd                : in out Command_Line;\n@@ -781,6 +787,8 @@ package GNAT.Command_Line is\n    --  The parsing of Switches is done through calls to Getopt, by passing\n    --  Getopt_Description as an argument. (A \"*\" is automatically prepended so\n    --  that all switches and command line arguments are accepted).\n+   --  If a config was defined via Set_Configuration, the Getopt_Description\n+   --  parameter will be ignored.\n    --\n    --  To properly handle switches that take parameters, you should document\n    --  them in Getopt_Description. Otherwise, the switch and its parameter will\n@@ -792,6 +800,12 @@ package GNAT.Command_Line is\n    --  should be listed in the Sections parameter (as \"-bargs -cargs\").\n    --\n    --  This function can be used to reset Cmd by passing an empty string.\n+   --\n+   --  If an invalid switch is found on the command line (ie wasn't defined in\n+   --  the configuration via Define_Switch), and the configuration wasn't set\n+   --  to accept all switches (by defining \"*\" as a valid switch), then an\n+   --  exception Invalid_Switch is raised. The exception message indicates the\n+   --  invalid switch.\n \n    procedure Add_Switch\n      (Cmd        : in out Command_Line;\n@@ -1084,6 +1098,11 @@ private\n       Sections : GNAT.OS_Lib.Argument_List_Access;\n       --  The list of sections\n \n+      Star_Switch : Boolean := False;\n+      --  Whether switches not described in this configuration should be\n+      --  returned to the user (True). If False, an exception Invalid_Switch\n+      --  is raised.\n+\n       Aliases  : Alias_Definitions_List;\n       Usage    : GNAT.OS_Lib.String_Access;\n       Help     : GNAT.OS_Lib.String_Access;"}, {"sha": "684bccfd9365a78288fda5937cc8d8d9f7e572d4", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 10, "deletions": 80, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "patch": "@@ -411,6 +411,8 @@ package body Make is\n    --  Delete all temp files created by Gnatmake and call Osint.Fail, with the\n    --  parameter S (see osint.ads). This is called from the Prj hierarchy and\n    --  the MLib hierarchy.\n+   --  This subprogram also prints current error messages on stdout (ie\n+   --  finalizes errout)\n \n    --------------------------\n    -- Obsolete Executables --\n@@ -795,15 +797,6 @@ package body Make is\n    --  mappings, when using project file(s). The out parameter File_Index is\n    --  the index to the name of the file in the array The_Mapping_File_Names.\n \n-   procedure Delete_Temp_Config_Files;\n-   --  Delete all temporary config files. Must not be called if Debug_Flag_N\n-   --  is False.\n-\n-   procedure Delete_All_Temp_Files;\n-   --  Delete all temp files (config files, mapping files, path files), unless\n-   --  Debug_Flag_N is True (in which case all temp files are left for user\n-   --  examination).\n-\n    -------------------------------------------------\n    -- Subprogram declarations moved from the spec --\n    -------------------------------------------------\n@@ -1267,7 +1260,6 @@ package body Make is\n                            \"\"\" is not a gnatmake switch. Consider moving \" &\n                            \"it to Global_Compilation_Switches.\",\n                            Element.Location);\n-                        Errutil.Finalize;\n                         Make_Failed (\"*** illegal switch \"\"\" & Argv & \"\"\"\");\n                      end if;\n                   end;\n@@ -3719,7 +3711,7 @@ package body Make is\n       --  Delete any temporary configuration pragma file\n \n       if not Debug.Debug_Flag_N then\n-         Delete_Temp_Config_Files;\n+         Delete_Temp_Config_Files (Project_Tree);\n       end if;\n    end Compile_Sources;\n \n@@ -3911,53 +3903,6 @@ package body Make is\n       Debug_Msg (S, Name_Id (N));\n    end Debug_Msg;\n \n-   ---------------------------\n-   -- Delete_All_Temp_Files --\n-   ---------------------------\n-\n-   procedure Delete_All_Temp_Files is\n-   begin\n-      if not Debug.Debug_Flag_N then\n-         Delete_Temp_Config_Files;\n-         Prj.Delete_All_Temp_Files (Project_Tree.Shared);\n-      end if;\n-   end Delete_All_Temp_Files;\n-\n-   ------------------------------\n-   -- Delete_Temp_Config_Files --\n-   ------------------------------\n-\n-   procedure Delete_Temp_Config_Files is\n-      Success : Boolean;\n-      Proj    : Project_List;\n-      pragma Warnings (Off, Success);\n-\n-   begin\n-      --  The caller is responsible for ensuring that Debug_Flag_N is False\n-\n-      pragma Assert (not Debug.Debug_Flag_N);\n-\n-      if Main_Project /= No_Project then\n-         Proj := Project_Tree.Projects;\n-         while Proj /= null loop\n-            if Proj.Project.Config_File_Temp then\n-               Delete_Temporary_File\n-                 (Project_Tree.Shared, Proj.Project.Config_File_Name);\n-\n-               --  Make sure that we don't have a config file for this project,\n-               --  in case there are several mains. In this case, we will\n-               --  recreate another config file: we cannot reuse the one that\n-               --  we just deleted!\n-\n-               Proj.Project.Config_Checked   := False;\n-               Proj.Project.Config_File_Name := No_Path;\n-               Proj.Project.Config_File_Temp := False;\n-            end if;\n-            Proj := Proj.Next;\n-         end loop;\n-      end if;\n-   end Delete_Temp_Config_Files;\n-\n    -------------\n    -- Display --\n    -------------\n@@ -4470,8 +4415,7 @@ package body Make is\n                            Write_Line (\": no sources to compile\");\n                         end if;\n \n-                        Delete_All_Temp_Files;\n-                        Exit_Program (E_Success);\n+                        Finish_Program (Project_Tree, E_Success);\n                      end if;\n                   end if;\n \n@@ -4619,8 +4563,7 @@ package body Make is\n                Bind          => Bind_Only,\n                Link          => Link_Only);\n \n-            Delete_All_Temp_Files;\n-            Exit_Program (E_Success);\n+            Finish_Program (Project_Tree, E_Success);\n \n          else\n             --  Call Get_Target_Parameters to ensure that VM_Target and\n@@ -4631,7 +4574,7 @@ package body Make is\n             --  Output usage information if no files to compile\n \n             Usage;\n-            Exit_Program (E_Fatal);\n+            Finish_Program (Project_Tree, E_Success);\n          end if;\n       end if;\n \n@@ -4809,7 +4752,6 @@ package body Make is\n                      \"Global_Compilation_Switches. Use Switches instead.\",\n                      Project_Tree.Shared.Arrays.Table\n                        (Default_Switches_Array).Location);\n-                  Errutil.Finalize;\n                   Make_Failed\n                     (\"*** illegal combination of Builder attributes\");\n                end if;\n@@ -6505,14 +6447,7 @@ package body Make is\n          Report_Compilation_Failed;\n       end if;\n \n-      --  Delete the temporary mapping file that was created if we are\n-      --  using project files.\n-\n-      Delete_All_Temp_Files;\n-\n-      --  Output Namet statistics\n-\n-      Namet.Finalize;\n+      Finish_Program (Project_Tree, E_Success);\n \n    exception\n       when X : others =>\n@@ -7292,8 +7227,7 @@ package body Make is\n \n    procedure Make_Failed (S : String) is\n    begin\n-      Delete_All_Temp_Files;\n-      Osint.Fail (S);\n+      Fail_Program (Project_Tree, S);\n    end Make_Failed;\n \n    --------------------\n@@ -7531,8 +7465,7 @@ package body Make is\n \n    procedure Report_Compilation_Failed is\n    begin\n-      Delete_All_Temp_Files;\n-      Exit_Program (E_Fatal);\n+      Fail_Program (Project_Tree, \"\");\n    end Report_Compilation_Failed;\n \n    ------------------------\n@@ -7552,10 +7485,7 @@ package body Make is\n          Kill (Running_Compile (J).Pid, SIGINT, 1);\n       end loop;\n \n-      Delete_All_Temp_Files;\n-      OS_Exit (1);\n-      --  ??? OS_Exit (1) is equivalent to Exit_Program (E_No_Compile),\n-      --  shouldn't that be Exit_Program (E_Abort) instead?\n+      Finish_Program (Project_Tree, E_No_Compile);\n    end Sigint_Intercepted;\n \n    -------------------"}, {"sha": "e253d35eee1ceb3bec3339f7496d0e7a629cf556", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 565, "deletions": 64, "changes": 629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "patch": "@@ -25,13 +25,16 @@\n \n with ALI;      use ALI;\n with Debug;\n+with Err_Vars; use Err_Vars;\n+with Errutil;\n with Fname;\n with Hostparm;\n with Osint;    use Osint;\n with Output;   use Output;\n with Opt;      use Opt;\n with Prj.Ext;\n with Prj.Util;\n+with Sinput.P;\n with Snames;   use Snames;\n with Table;\n with Tempdir;\n@@ -580,6 +583,58 @@ package body Makeutl is\n       end;\n    end Executable_Prefix_Path;\n \n+   ------------------\n+   -- Fail_Program --\n+   ------------------\n+\n+   procedure Fail_Program\n+     (Project_Tree   : Project_Tree_Ref;\n+      S              : String;\n+      Flush_Messages : Boolean := True)\n+   is\n+   begin\n+      if Flush_Messages then\n+         if Total_Errors_Detected /= 0 or else Warnings_Detected /= 0 then\n+            Errutil.Finalize;\n+         end if;\n+      end if;\n+\n+      Finish_Program (Project_Tree, E_Fatal, S => S);\n+   end Fail_Program;\n+\n+   --------------------\n+   -- Finish_Program --\n+   --------------------\n+\n+   procedure Finish_Program\n+     (Project_Tree : Project_Tree_Ref;\n+      Exit_Code    : Osint.Exit_Code_Type := Osint.E_Success;\n+      S            : String := \"\")\n+   is\n+   begin\n+      if not Debug.Debug_Flag_N then\n+         Delete_Temp_Config_Files (Project_Tree);\n+\n+         if Project_Tree /= null then\n+            Delete_All_Temp_Files (Project_Tree.Shared);\n+         end if;\n+      end if;\n+\n+      if S'Length > 0 then\n+         if Exit_Code /= E_Success then\n+            Osint.Fail (S);\n+         else\n+            Write_Str (S);\n+         end if;\n+      end if;\n+\n+      --  Output Namet statistics\n+\n+      Namet.Finalize;\n+\n+      Exit_Program (Exit_Code);\n+   end Finish_Program;\n+\n    --------------------------\n    -- File_Not_A_Source_Of --\n    --------------------------\n@@ -819,6 +874,169 @@ package body Makeutl is\n       Write_Eol;\n    end Inform;\n \n+   ------------------------------\n+   -- Initialize_Source_Record --\n+   ------------------------------\n+\n+   procedure Initialize_Source_Record (Source : Prj.Source_Id) is\n+      procedure Set_Object_Project\n+        (Obj_Dir : String; Obj_Proj : Project_Id; Obj_Path : Path_Name_Type;\n+         Stamp   : Time_Stamp_Type);\n+      --  Update information about object file, switches file,...\n+\n+      ------------------------\n+      -- Set_Object_Project --\n+      ------------------------\n+\n+      procedure Set_Object_Project\n+        (Obj_Dir : String; Obj_Proj : Project_Id; Obj_Path : Path_Name_Type;\n+         Stamp   : Time_Stamp_Type) is\n+      begin\n+         Source.Object_Project := Obj_Proj;\n+         Source.Object_Path    := Obj_Path;\n+         Source.Object_TS      := Stamp;\n+\n+         if Source.Language.Config.Dependency_Kind /= None then\n+            declare\n+               Dep_Path : constant String :=\n+                 Normalize_Pathname\n+                   (Name          => Get_Name_String (Source.Dep_Name),\n+                    Resolve_Links => Opt.Follow_Links_For_Files,\n+                    Directory     => Obj_Dir);\n+            begin\n+               Source.Dep_Path := Create_Name (Dep_Path);\n+               Source.Dep_TS   := Osint.Unknown_Attributes;\n+            end;\n+         end if;\n+\n+         --  Get the path of the switches file, even if Opt.Check_Switches is\n+         --  not set, as switch -s may be in the Builder switches that have not\n+         --  been scanned yet.\n+\n+         declare\n+            Switches_Path : constant String :=\n+              Normalize_Pathname\n+                (Name          => Get_Name_String (Source.Switches),\n+                 Resolve_Links => Opt.Follow_Links_For_Files,\n+                 Directory     => Obj_Dir);\n+         begin\n+            Source.Switches_Path := Create_Name (Switches_Path);\n+\n+            if Stamp /= Empty_Time_Stamp then\n+               Source.Switches_TS := File_Stamp (Source.Switches_Path);\n+            end if;\n+         end;\n+      end Set_Object_Project;\n+\n+      Obj_Proj : Project_Id;\n+\n+   begin\n+      --  Nothing to do if source record has already been fully initialized\n+\n+      if Source.Initialized then\n+         return;\n+      end if;\n+\n+      --  Systematically recompute the time stamp\n+\n+      Source.Source_TS := File_Stamp (Source.Path.Display_Name);\n+\n+      --  Parse the source file to check whether we have a subunit\n+\n+      if Source.Language.Config.Kind = Unit_Based\n+        and then Source.Kind = Impl\n+        and then Is_Subunit (Source)\n+      then\n+         Source.Kind := Sep;\n+      end if;\n+\n+      if Source.Language.Config.Object_Generated\n+        and then Is_Compilable (Source)\n+      then\n+         --  First, get the correct object file name and dependency file name\n+         --  if the source is in a multi-unit file.\n+\n+         if Source.Index /= 0 then\n+            Source.Object :=\n+              Object_Name\n+                (Source_File_Name   => Source.File,\n+                 Source_Index       => Source.Index,\n+                 Index_Separator    =>\n+                   Source.Language.Config.Multi_Unit_Object_Separator,\n+                 Object_File_Suffix =>\n+                   Source.Language.Config.Object_File_Suffix);\n+\n+            Source.Dep_Name :=\n+              Dependency_Name\n+                (Source.Object, Source.Language.Config.Dependency_Kind);\n+         end if;\n+\n+         --  Find the object file for that source. It could be either in\n+         --  the current project or in an extended project (it might actually\n+         --  not exist yet in the ultimate extending project, but if not found\n+         --  elsewhere that's where we'll expect to find it).\n+\n+         Obj_Proj := Source.Project;\n+         while Obj_Proj /= No_Project loop\n+            declare\n+               Dir  : constant String := Get_Name_String\n+                 (Obj_Proj.Object_Directory.Display_Name);\n+\n+               Object_Path     : constant String :=\n+                                   Normalize_Pathname\n+                                     (Name          =>\n+                                        Get_Name_String (Source.Object),\n+                                      Resolve_Links =>\n+                                        Opt.Follow_Links_For_Files,\n+                                      Directory     => Dir);\n+\n+               Obj_Path : constant Path_Name_Type := Create_Name (Object_Path);\n+               Stamp : Time_Stamp_Type := Empty_Time_Stamp;\n+\n+            begin\n+               --  For specs, we do not check object files if there is a body.\n+               --  This saves a system call. On the other hand, we do need to\n+               --  know the object_path, in case the user has passed the .ads\n+               --  on the command line to compile the spec only\n+\n+               if Source.Kind /= Spec\n+                 or else Source.Unit = No_Unit_Index\n+                 or else Source.Unit.File_Names (Impl) = No_Source\n+               then\n+                  Stamp := File_Stamp (Obj_Path);\n+               end if;\n+\n+               if Stamp /= Empty_Time_Stamp\n+                 or else (Obj_Proj.Extended_By = No_Project\n+                          and then Source.Object_Project = No_Project)\n+               then\n+                  Set_Object_Project (Dir, Obj_Proj, Obj_Path, Stamp);\n+               end if;\n+\n+               Obj_Proj := Obj_Proj.Extended_By;\n+            end;\n+         end loop;\n+\n+      elsif Source.Language.Config.Dependency_Kind = Makefile then\n+         declare\n+            Object_Dir : constant String :=\n+                           Get_Name_String\n+                             (Source.Project.Object_Directory.Display_Name);\n+            Dep_Path   : constant String :=\n+                           Normalize_Pathname\n+                             (Name        => Get_Name_String (Source.Dep_Name),\n+                              Resolve_Links =>\n+                                Opt.Follow_Links_For_Files,\n+                              Directory     => Object_Dir);\n+         begin\n+            Source.Dep_Path := Create_Name (Dep_Path);\n+            Source.Dep_TS   := Osint.Unknown_Attributes;\n+         end;\n+      end if;\n+\n+      Source.Initialized := True;\n+   end Initialize_Source_Record;\n+\n    ----------------------------\n    -- Is_External_Assignment --\n    ----------------------------\n@@ -851,6 +1069,36 @@ package body Makeutl is\n          Declaration => Argv (Start .. Finish));\n    end Is_External_Assignment;\n \n+   ----------------\n+   -- Is_Subunit --\n+   ----------------\n+\n+   function Is_Subunit (Source : Prj.Source_Id) return Boolean is\n+      Src_Ind : Source_File_Index;\n+   begin\n+      if Source.Kind = Sep then\n+         return True;\n+\n+      --  A Spec, a file based language source or a body with a spec cannot be\n+      --  a subunit.\n+\n+      elsif Source.Kind = Spec or else\n+        Source.Unit = No_Unit_Index or else\n+        Other_Part (Source) /= No_Source\n+      then\n+         return False;\n+      end if;\n+\n+      --  Here, we are assuming that the language is Ada, as it is the only\n+      --  unit based language that we know.\n+\n+      Src_Ind :=\n+        Sinput.P.Load_Project_File\n+          (Get_Name_String (Source.Path.Display_Name));\n+\n+      return Sinput.P.Source_File_Is_Subunit (Src_Ind);\n+   end Is_Subunit;\n+\n    -----------------------------\n    -- Linker_Options_Switches --\n    -----------------------------\n@@ -963,14 +1211,8 @@ package body Makeutl is\n \n    package body Mains is\n \n-      type File_And_Loc is record\n-         File_Name : File_Name_Type;\n-         Index     : Int := 0;\n-         Location  : Source_Ptr := No_Location;\n-      end record;\n-\n       package Names is new Table.Table\n-        (Table_Component_Type => File_And_Loc,\n+        (Table_Component_Type => Main_Info,\n          Table_Index_Type     => Integer,\n          Table_Low_Bound      => 1,\n          Table_Initial        => 10,\n@@ -985,14 +1227,46 @@ package body Makeutl is\n       -- Add_Main --\n       --------------\n \n-      procedure Add_Main (Name : String) is\n+      procedure Add_Main\n+        (Name     : String;\n+         Index    : Int := 0;\n+         Location : Source_Ptr := No_Location)\n+      is\n       begin\n          Name_Len := 0;\n          Add_Str_To_Name_Buffer (Name);\n+         Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+\n          Names.Increment_Last;\n-         Names.Table (Names.Last) := (Name_Find, 0, No_Location);\n+         Names.Table (Names.Last) := (Name_Find, Index, Location, No_Source);\n       end Add_Main;\n \n+      --------------------------\n+      -- Set_Multi_Unit_Index --\n+      --------------------------\n+\n+      procedure Set_Multi_Unit_Index\n+        (Project_Tree : Project_Tree_Ref := null;\n+         Index        : Int := 0) is\n+      begin\n+         if Index /= 0 then\n+            if Names.Last = 0 then\n+               Fail_Program\n+                 (Project_Tree,\n+                  \"cannot specify a multi-unit index but no main \" &\n+                  \"on the command line\");\n+\n+            elsif Names.Last > 1 then\n+               Fail_Program\n+                 (Project_Tree,\n+                  \"cannot specify several mains with a multi-unit index\");\n+\n+            else\n+               Names.Table (Names.Last).Index := Index;\n+            end if;\n+         end if;\n+      end Set_Multi_Unit_Index;\n+\n       ------------\n       -- Delete --\n       ------------\n@@ -1003,43 +1277,167 @@ package body Makeutl is\n          Mains.Reset;\n       end Delete;\n \n-      ---------------\n-      -- Get_Index --\n-      ---------------\n+      -----------------------\n+      -- FIll_From_Project --\n+      -----------------------\n \n-      function Get_Index return Int is\n+      procedure Fill_From_Project\n+        (Root_Project : Project_Id;\n+         Project_Tree : Project_Tree_Ref) is\n       begin\n-         if Current in Names.First .. Names.Last then\n-            return Names.Table (Current).Index;\n-         else\n-            return 0;\n+         if Number_Of_Mains = 0 then\n+            declare\n+               List    : String_List_Id := Root_Project.Mains;\n+               Element : String_Element;\n+\n+            begin\n+               if List /= Prj.Nil_String then\n+                  --  The attribute Main is not an empty list.\n+                  --  Get the mains in the list\n+\n+                  while List /= Prj.Nil_String loop\n+                     Element :=\n+                       Project_Tree.Shared.String_Elements.Table (List);\n+\n+                     Add_Main (Name     => Get_Name_String (Element.Value),\n+                               Index    => Element.Index,\n+                               Location => Element.Location);\n+                     List := Element.Next;\n+                  end loop;\n+               end if;\n+            end;\n          end if;\n-      end Get_Index;\n \n-      ------------------\n-      -- Get_Location --\n-      ------------------\n+         --  If there are mains, check that they are sources of the main\n+         --  project\n+\n+         if Mains.Number_Of_Mains > 0 then\n+            for J in Names.First .. Names.Last loop\n+               declare\n+                  File       : constant Main_Info := Names.Table (J);\n+                  Main_Id    : File_Name_Type := File.File;\n+                  Main       : constant String := Get_Name_String (Main_Id);\n+                  Project    : Project_Id;\n+                  Source     : Prj.Source_Id := No_Source;\n+                  Suffix     : File_Name_Type;\n+                  Iter       : Source_Iterator;\n+\n+               begin\n+                  if Base_Name (Main) /= Main then\n+                     if Is_Absolute_Path (Main) then\n+                        Main_Id := Create_Name (Base_Name (Main));\n \n-      function Get_Location return Source_Ptr is\n+                     else\n+                        Fail_Program\n+                          (Project_Tree,\n+                           \"mains cannot include directory information (\"\"\" &\n+                           Main & \"\"\")\");\n+                     end if;\n+                  end if;\n+\n+                  --  First, look for the main as specified.\n+\n+                  Source := Find_Source\n+                    (In_Tree   => Project_Tree,\n+                     Project   => Project,\n+                     Base_Name => File.File,\n+                     Index     => File.Index);\n+\n+                  if Source = No_Source then\n+                     --  Now look for the main with a body suffix\n+\n+                     declare\n+                        --  Main already has a canonical casing\n+                        Main : constant String := Get_Name_String (Main_Id);\n+                     begin\n+                        Project := Root_Project;\n+                        while Source = No_Source\n+                          and then Project /= No_Project\n+                        loop\n+                           Iter := For_Each_Source (Project_Tree, Project);\n+                           loop\n+                              Source := Prj.Element (Iter);\n+                              exit when Source = No_Source;\n+\n+                              --  Only consider bodies\n+\n+                              if Source.Kind = Impl then\n+                                 Get_Name_String (Source.File);\n+\n+                                 if Name_Len > Main'Length\n+                                   and then\n+                                     Name_Buffer (1 .. Main'Length) = Main\n+                                 then\n+                                    Suffix :=\n+                                      Source.Language\n+                                        .Config.Naming_Data.Body_Suffix;\n+\n+                                    exit when Suffix /= No_File and then\n+                                      Name_Buffer (Main'Length + 1 .. Name_Len)\n+                                      = Get_Name_String (Suffix);\n+                                 end if;\n+                              end if;\n+\n+                              Next (Iter);\n+                           end loop;\n+\n+                           Project := Project.Extends;\n+                        end loop;\n+                     end;\n+                  end if;\n+\n+                  if Source /= No_Source then\n+                     Names.Table (J).File := Source.File;\n+                     Names.Table (J).Source := Source;\n+\n+                  elsif File.Location /= No_Location then\n+                     --  If the main is declared in package Builder of the\n+                     --  main project, report an error. If the main is on\n+                     --  the command line, it may be a main from another\n+                     --  project, so do nothing: if the main does not exist\n+                     --  in another project, an error will be reported\n+                     --  later.\n+\n+                     Error_Msg_File_1 := Main_Id;\n+                     Error_Msg_Name_1 := Root_Project.Name;\n+                     Errutil.Error_Msg (\"{ is not a source of project %%\",\n+                                        File.Location);\n+                  end if;\n+               end;\n+            end loop;\n+         end if;\n+\n+         if Total_Errors_Detected > 0 then\n+            Fail_Program (Project_Tree, \"problems with main sources\");\n+         end if;\n+      end Fill_From_Project;\n+\n+      ---------------\n+      -- Next_Main --\n+      ---------------\n+\n+      function Next_Main return String is\n+         Info : Main_Info;\n       begin\n-         if Current in Names.First .. Names.Last then\n-            return Names.Table (Current).Location;\n+         Info := Next_Main;\n+         if Info = No_Main_Info then\n+            return \"\";\n          else\n-            return No_Location;\n+            return Get_Name_String (Info.File);\n          end if;\n-      end Get_Location;\n+      end Next_Main;\n \n       ---------------\n       -- Next_Main --\n       ---------------\n \n-      function Next_Main return String is\n+      function Next_Main return Main_Info is\n       begin\n          if Current >= Names.Last then\n-            return \"\";\n+            return No_Main_Info;\n          else\n             Current := Current + 1;\n-            return Get_Name_String (Names.Table (Current).File_Name);\n+            return Names.Table (Current);\n          end if;\n       end Next_Main;\n \n@@ -1060,41 +1458,6 @@ package body Makeutl is\n       begin\n          Current := 0;\n       end Reset;\n-\n-      ---------------\n-      -- Set_Index --\n-      ---------------\n-\n-      procedure Set_Index (Index : Int) is\n-      begin\n-         if Names.Last > 0 then\n-            Names.Table (Names.Last).Index := Index;\n-         end if;\n-      end Set_Index;\n-\n-      ------------------\n-      -- Set_Location --\n-      ------------------\n-\n-      procedure Set_Location (Location : Source_Ptr) is\n-      begin\n-         if Names.Last > 0 then\n-            Names.Table (Names.Last).Location := Location;\n-         end if;\n-      end Set_Location;\n-\n-      -----------------\n-      -- Update_Main --\n-      -----------------\n-\n-      procedure Update_Main (Name : String) is\n-      begin\n-         if Current in Names.First .. Names.Last then\n-            Name_Len := 0;\n-            Add_Str_To_Name_Buffer (Name);\n-            Names.Table (Current).File_Name := Name_Find;\n-         end if;\n-      end Update_Main;\n    end Mains;\n \n    -----------------------\n@@ -1727,6 +2090,144 @@ package body Makeutl is\n          Marks.Reset;\n       end Remove_Marks;\n \n+      ----------------------------\n+      -- Insert_Project_Sources --\n+      ----------------------------\n+\n+      procedure Insert_Project_Sources\n+        (Project      : Project_Id;\n+         Project_Tree : Project_Tree_Ref;\n+         All_Projects : Boolean;\n+         Unit_Based   : Boolean)\n+      is\n+         Iter   : Source_Iterator;\n+         Source : Prj.Source_Id;\n+      begin\n+         Iter := For_Each_Source (Project_Tree);\n+         loop\n+            Source := Prj.Element (Iter);\n+            exit when Source = No_Source;\n+\n+            if Is_Compilable (Source)\n+              and then\n+                (All_Projects\n+                 or else Is_Extending (Project, Source.Project))\n+              and then not Source.Locally_Removed\n+              and then Source.Replaced_By = No_Source\n+              and then\n+                (not Source.Project.Externally_Built\n+                 or else\n+                   (Is_Extending (Project, Source.Project)\n+                    and then not Project.Externally_Built))\n+              and then Source.Kind /= Sep\n+              and then Source.Path /= No_Path_Information\n+            then\n+               if Source.Kind = Impl\n+                 or else (Source.Unit /= No_Unit_Index\n+                          and then Source.Kind = Spec\n+                          and then (Other_Part (Source) = No_Source\n+                                    or else\n+                                      Other_Part (Source).Locally_Removed))\n+               then\n+                  if (Unit_Based\n+                      or else Source.Unit = No_Unit_Index\n+                      or else Source.Project.Library)\n+                    and then not Is_Subunit (Source)\n+                  then\n+                     Queue.Insert\n+                       (Source => (Format => Format_Gprbuild,\n+                                   Id     => Source));\n+                  end if;\n+               end if;\n+            end if;\n+\n+            Next (Iter);\n+         end loop;\n+      end Insert_Project_Sources;\n+\n+      -------------------------------\n+      -- Insert_Withed_Sources_For --\n+      -------------------------------\n+\n+      procedure Insert_Withed_Sources_For\n+        (The_ALI               : ALI.ALI_Id;\n+         Project_Tree          : Project_Tree_Ref;\n+         Excluding_Shared_SALs : Boolean := False)\n+      is\n+         Sfile     : File_Name_Type;\n+         Afile     : File_Name_Type;\n+         Src_Id    : Prj.Source_Id;\n+\n+      begin\n+         --  Insert in the queue the unmarked source files (i.e. those which\n+         --  have never been inserted in the queue and hence never considered).\n+\n+         for J in ALI.ALIs.Table (The_ALI).First_Unit ..\n+           ALI.ALIs.Table (The_ALI).Last_Unit\n+         loop\n+            for K in ALI.Units.Table (J).First_With ..\n+              ALI.Units.Table (J).Last_With\n+            loop\n+               Sfile := ALI.Withs.Table (K).Sfile;\n+\n+               --  Skip generics\n+\n+               if Sfile /= No_File then\n+                  Afile := ALI.Withs.Table (K).Afile;\n+                  Src_Id := Source_Files_Htable.Get\n+                    (Project_Tree.Source_Files_HT, Sfile);\n+\n+                  while Src_Id /= No_Source loop\n+                     Initialize_Source_Record (Src_Id);\n+\n+                     if Is_Compilable (Src_Id)\n+                       and then Src_Id.Dep_Name = Afile\n+                     then\n+                        case Src_Id.Kind is\n+                        when Spec =>\n+                           declare\n+                              Bdy : constant Prj.Source_Id :=\n+                                Other_Part (Src_Id);\n+                           begin\n+                              if Bdy /= No_Source\n+                                and then not Bdy.Locally_Removed\n+                              then\n+                                 Src_Id := Other_Part (Src_Id);\n+                              end if;\n+                           end;\n+\n+                        when Impl =>\n+                           if Is_Subunit (Src_Id) then\n+                              Src_Id := No_Source;\n+                           end if;\n+\n+                        when Sep =>\n+                           Src_Id := No_Source;\n+                        end case;\n+\n+                        exit;\n+                     end if;\n+\n+                     Src_Id := Src_Id.Next_With_File_Name;\n+                  end loop;\n+\n+                  --  If Excluding_Shared_SALs is True, do not insert in the\n+                  --  queue the sources of a shared Stand-Alone Library.\n+\n+                  if Src_Id /= No_Source and then\n+                    (not Excluding_Shared_SALs or else\n+                       not Src_Id.Project.Standalone_Library or else\n+                         Src_Id.Project.Library_Kind = Static)\n+                  then\n+                     Queue.Insert\n+                       (Source => (Format => Format_Gprbuild,\n+                                   Id     => Src_Id));\n+                  end if;\n+               end if;\n+            end loop;\n+         end loop;\n+      end Insert_Withed_Sources_For;\n+\n    end Queue;\n \n end Makeutl;"}, {"sha": "52ee9001a6fd78277618ec9e004ff5ffe023109d", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 93, "deletions": 23, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "patch": "@@ -30,7 +30,8 @@\n with ALI;\n with Namet;    use Namet;\n with Opt;\n-with Prj;      use Prj;\n+with Osint;\n+with Prj;         use Prj;\n with Prj.Tree;\n with Types;    use Types;\n \n@@ -111,6 +112,13 @@ package Makeutl is\n    --  source files are still associated with the same units). Return True\n    --  if everything is still valid.\n \n+   function Is_Subunit (Source : Source_Id) return Boolean;\n+   --  Return True if source is a subunit\n+\n+   procedure Initialize_Source_Record (Source : Source_Id);\n+   --  Get information either about the source file, the object and\n+   --  dependency file, as well as their timestamps. This includes timestamps.\n+\n    function Is_External_Assignment\n      (Env  : Prj.Tree.Environment;\n       Argv : String) return Boolean;\n@@ -204,6 +212,24 @@ package Makeutl is\n    function Path_Or_File_Name (Path : Path_Name_Type) return String;\n    --  Returns a file name if -df is used, otherwise return a path name\n \n+   -------------------------\n+   -- Program termination --\n+   -------------------------\n+\n+   procedure Fail_Program\n+     (Project_Tree   : Project_Tree_Ref;\n+      S              : String;\n+      Flush_Messages : Boolean := True);\n+   --  Terminate program with a message and a fatal status code\n+\n+   procedure Finish_Program\n+     (Project_Tree : Project_Tree_Ref;\n+      Exit_Code    : Osint.Exit_Code_Type := Osint.E_Success;\n+      S            : String := \"\");\n+   --  Terminate program, with or without a message, setting the status code\n+   --  according to Fatal.\n+   --  This properly removes all temporary files\n+\n    -----------\n    -- Mains --\n    -----------\n@@ -215,38 +241,62 @@ package Makeutl is\n    --  Mains are stored in a table. An index is used to retrieve the mains\n    --  from the table.\n \n-   package Mains is\n-\n-      procedure Add_Main (Name : String);\n-      --  Add one main to the table\n+   type Main_Info is record\n+      File      : File_Name_Type;  --  Always canonical casing\n+      Index     : Int := 0;\n+      Location  : Source_Ptr := No_Location;\n+      Source    : Prj.Source_Id := No_Source;\n+   end record;\n+   No_Main_Info : constant Main_Info := (No_File, 0, No_Location, No_Source);\n \n-      procedure Set_Index (Index : Int);\n-\n-      procedure Set_Location (Location : Source_Ptr);\n-      --  Set the location of the last main added. By default, the location is\n-      --  No_Location.\n+   package Mains is\n+      procedure Add_Main\n+        (Name     : String;\n+         Index    : Int := 0;\n+         Location : Source_Ptr := No_Location);\n+      --  Add one main to the table.\n+      --  This is in general used to add the main files specified on the\n+      --  command line.\n+      --  Index is used for multi-unit source files, and indicates which unit\n+      --  within the source is concerned.\n+      --  Location is the location within the project file (if a project file\n+      --  is used).\n \n       procedure Delete;\n       --  Empty the table\n \n       procedure Reset;\n-      --  Reset the index to the beginning of the table\n-\n-      function Next_Main return String;\n-      --  Increase the index and return the next main. If table is exhausted,\n-      --  return an empty string.\n+      --  Reset the cursor to the beginning of the table\n \n-      function Get_Index return Int;\n+      procedure Set_Multi_Unit_Index\n+        (Project_Tree : Project_Tree_Ref := null;\n+         Index        : Int := 0);\n+      --  If a single main file was defined, this subprogram indicates which\n+      --  unit inside it is the main (case of a multi-unit source files).\n+      --  Errors are raised if zero or more than one main file was defined,\n+      --  and Index is not 0.\n+      --  This subprogram is used for the handling of the command line switch.\n \n-      function Get_Location return Source_Ptr;\n-      --  Get the location of the current main\n-\n-      procedure Update_Main (Name : String);\n-      --  Update the file name of the current main\n+      function Next_Main return String;\n+      function Next_Main return Main_Info;\n+      --  Moves the cursor forward and returns the new current entry.\n+      --  Returns No_File_And_Loc if there are no more mains in the table.\n \n       function Number_Of_Mains return Natural;\n-      --  Returns the number of mains added with Add_Main since the last call\n-      --  to Delete.\n+      --  Returns the number of mains in the table.\n+\n+      procedure Fill_From_Project\n+        (Root_Project : Project_Id;\n+         Project_Tree : Project_Tree_Ref);\n+      --  If no main was already added (presumably from the command line), add\n+      --  the main units from root_project (or in the case of an aggregate\n+      --  project from all the\n+      --  aggregated projects).\n+      --\n+      --  If some main units were already added from the command line, check\n+      --  that they all belong to the root project, and that they are full\n+      --  full paths rather than (partial) base names (e.g. no body suffix was\n+      --  specified).\n \n    end Mains;\n \n@@ -308,6 +358,26 @@ package Makeutl is\n       --  The second version returns False if the Source was already marked in\n       --  the queue.\n \n+      procedure Insert_Project_Sources\n+        (Project      : Project_Id;\n+         Project_Tree : Project_Tree_Ref;\n+         All_Projects : Boolean;\n+         Unit_Based   : Boolean);\n+      --  Insert all the compilable sources of the project in the queue. If\n+      --  All_Project is true, then all sources from imported projects are also\n+      --  inserted.\n+      --  When Unit_Based is True, put in the queue all compilable sources\n+      --  including the unit based (Ada) one. When Unit_Based is False, put the\n+      --  Ada sources only when they are in a library project.\n+\n+      procedure Insert_Withed_Sources_For\n+        (The_ALI               : ALI.ALI_Id;\n+         Project_Tree          : Project_Tree_Ref;\n+         Excluding_Shared_SALs : Boolean := False);\n+      --  Insert in the queue those sources withed by The_ALI, if there are not\n+      --  already in the queue and Only_Interfaces is False or they are part of\n+      --  the interfaces of their project.\n+\n       procedure Extract\n         (Found  : out Boolean;\n          Source : out Source_Info);"}, {"sha": "7640bcfcdbb140192cfb0ffce1f951781c259ab4", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "patch": "@@ -144,6 +144,39 @@ package body Prj is\n       end if;\n    end Delete_Temporary_File;\n \n+   ------------------------------\n+   -- Delete_Temp_Config_Files --\n+   ------------------------------\n+\n+   procedure Delete_Temp_Config_Files (Project_Tree : Project_Tree_Ref) is\n+      Success : Boolean;\n+      Proj    : Project_List;\n+      pragma Warnings (Off, Success);\n+\n+   begin\n+      if not Debug.Debug_Flag_N then\n+         if Project_Tree /= null then\n+            Proj := Project_Tree.Projects;\n+            while Proj /= null loop\n+               if Proj.Project.Config_File_Temp then\n+                  Delete_Temporary_File\n+                    (Project_Tree.Shared, Proj.Project.Config_File_Name);\n+\n+                  --  Make sure that we don't have a config file for this\n+                  --  project, in case there are several mains. In this case,\n+                  --  we will recreate another config file: we cannot reuse the\n+                  --  one that we just deleted!\n+\n+                  Proj.Project.Config_Checked   := False;\n+                  Proj.Project.Config_File_Name := No_Path;\n+                  Proj.Project.Config_File_Temp := False;\n+               end if;\n+               Proj := Proj.Next;\n+            end loop;\n+         end if;\n+      end if;\n+   end Delete_Temp_Config_Files;\n+\n    ---------------------------\n    -- Delete_All_Temp_Files --\n    ---------------------------\n@@ -493,7 +526,8 @@ package body Prj is\n       Project          : Project_Id;\n       In_Imported_Only : Boolean := False;\n       In_Extended_Only : Boolean := False;\n-      Base_Name        : File_Name_Type) return Source_Id\n+      Base_Name        : File_Name_Type;\n+      Index            : Int := 0) return Source_Id\n    is\n       Result : Source_Id  := No_Source;\n \n@@ -517,7 +551,9 @@ package body Prj is\n       begin\n          Iterator := For_Each_Source (In_Tree => Tree, Project => Proj);\n          while Element (Iterator) /= No_Source loop\n-            if Element (Iterator).File = Base_Name then\n+            if Element (Iterator).File = Base_Name\n+              and then (Index = 0 or else Element (Iterator).Index = Index)\n+            then\n                Src := Element (Iterator);\n                return;\n             end if;"}, {"sha": "c57f37246e4738dc9a744f0faf8c3cc680ef9669", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "patch": "@@ -1380,11 +1380,13 @@ package Prj is\n       Project          : Project_Id;\n       In_Imported_Only : Boolean := False;\n       In_Extended_Only : Boolean := False;\n-      Base_Name        : File_Name_Type) return Source_Id;\n+      Base_Name        : File_Name_Type;\n+      Index            : Int := 0) return Source_Id;\n    --  Find the first source file with the given name either in the whole tree\n    --  (if In_Imported_Only is False) or in the projects imported or extended\n    --  by Project otherwise. In_Extended_Only implies In_Imported_Only, and\n-   --  will only look in Project and the projects it extends\n+   --  will only look in Project and the projects it extends.\n+   --  If Index is specified, this only search for a source with that index.\n \n    -----------------------\n    -- Project_Tree_Data --\n@@ -1647,6 +1649,12 @@ package Prj is\n    --  Delete all recorded temporary files.\n    --  Does nothing if Debug.Debug_Flag_N is set\n \n+   procedure Delete_Temp_Config_Files (Project_Tree : Project_Tree_Ref);\n+   --  Delete all temporary config files.\n+   --  Does nothing if Debug.Debug_Flag_N is set or if Project_Tree is null.\n+   --  This initially came from gnatmake\n+   --  ??? Should this be combined with Delete_All_Temp_Files above\n+\n    procedure Delete_Temporary_File\n      (Shared : Shared_Project_Tree_Data_Access := null;\n       Path   : Path_Name_Type);"}, {"sha": "e04773a1a4498dca7d0dd725e5eeed9bb8ba4272", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "patch": "@@ -1524,15 +1524,21 @@ package body Sem_Ch4 is\n \n       Else_Expr := Next (Then_Expr);\n \n-      --  In ALFA, conditional expressions are allowed:\n+      --  In ALFA, boolean conditional expressions are allowed:\n       --    * if they have no ELSE part, in which case the expression is\n       --      equivalent to\n+\n       --        NOT Condition OR ELSE Then_Expr\n+\n       --    * in pre- and postconditions, where the Condition cannot have side-\n       --      effects (in ALFA) and thus the expression is equivalent to\n+\n       --        (Condition AND THEN Then_Expr)\n       --          and (NOT Condition AND THEN Then_Expr)\n \n+      --  Non-boolean conditional expressions are marked as not in ALFA during\n+      --  resolution.\n+\n       if Present (Else_Expr) and then not In_Pre_Post_Expression then\n          Mark_Non_ALFA_Subprogram;\n       end if;"}, {"sha": "3286e3aa57c68956dde3ce8d6119b0dd5998909d", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=fccd42a9a5dca36c6c126b0f9fa632e8dd5f30e7", "patch": "@@ -5860,6 +5860,10 @@ package body Sem_Res is\n          Append_To (Expressions (N), Error);\n       end if;\n \n+      if Root_Type (Typ) /= Standard_Boolean then\n+         Mark_Non_ALFA_Subprogram;\n+      end if;\n+\n       Set_Etype (N, Typ);\n       Eval_Conditional_Expression (N);\n    end Resolve_Conditional_Expression;"}]}