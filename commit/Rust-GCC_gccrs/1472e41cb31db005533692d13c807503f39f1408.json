{"sha": "1472e41cb31db005533692d13c807503f39f1408", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ3MmU0MWNiMzFkYjAwNTUzMzY5MmQxM2M4MDc1MDNmMzlmMTQwOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-09-17T01:28:50Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-09-17T01:28:50Z"}, "message": "builtin-types.def (BT_FN_FLOAT_CONST_STRING): New.\n\ngcc/\n        * builtin-types.def (BT_FN_FLOAT_CONST_STRING): New.\n        (BT_FN_DOUBLE_CONST_STRING, BT_FN_LONG_DOUBLE_CONST_STRING): New.\n        * builtins.def (__builtin_nan, __builtin_nanf, __builtin_nanl): New.\n        (__builtin_nans, __builtin_nansf, __builtin_nansl): New.\n        * builtins.c (fold_builtin_nan): New.\n        (fold_builtin): Call it.\n        * real.c (real_nan): Parse a non-empty string.\n        (round_for_format): Fix NaN significand truncation.\n        * real.h (real_nan): Return bool.\n        * doc/extend.texi: Document new builtins.\n\nlibstdc++/\n        * include/std/std_limits.h (__glibcpp_f32_QNaN_bytes,\n        __glibcpp_f32_has_QNaN, __glibcpp_f32_SNaN_bytes,\n        __glibcpp_f32_has_SNaN, __glibcpp_f64_QNaN_bytes,\n        __glibcpp_f64_has_QNaN, __glibcpp_f64_SNaN_bytes,\n        __glibcpp_f64_has_SNaN, __glibcpp_f80_QNaN_bytes,\n        __glibcpp_f80_has_QNaN, __glibcpp_f80_SNaN_bytes,\n        __glibcpp_f80_has_SNaN, __glibcpp_f96_QNaN_bytes,\n        __glibcpp_f96_has_QNaN, __glibcpp_f96_SNaN_bytes,\n        __glibcpp_f96_has_SNaN, __glibcpp_f128_QNaN_bytes,\n        __glibcpp_f128_has_QNaN, __glibcpp_f128_SNaN_bytes,\n        __glibcpp_f128_has_SNaN, __glibcpp_float_QNaN_bytes,\n        __glibcpp_float_has_QNaN, __glibcpp_float_SNaN_bytes,\n        __glibcpp_float_has_SNaN, __glibcpp_double_QNaN_bytes,\n        __glibcpp_double_has_QNaN, __glibcpp_double_SNaN_bytes,\n        __glibcpp_double_has_SNaN, __glibcpp_long_double_QNaN_bytes,\n        __glibcpp_long_double_has_QNaN, __glibcpp_long_double_SNaN_bytes,\n        __glibcpp_long_double_has_SNaN): Remove.\n        (__glibcpp_f128_is_iec559): True if IEEE.\n        (__glibcpp_float_QNaN, __glibcpp_float_SNaN): Remove.\n        (__glibcpp_double_QNaN, __glibcpp_double_SNaN): Remove.\n        (__glibcpp_long_double_QNaN, __glibcpp_long_double_SNaN): Remove.\n        (std::numeric_limits<float>::has_quiet_NaN): Use __builtin_nanf.\n        (std::numeric_limits<float>::has_signaling_NaN): Mirror has_quiet_NaN.\n        (std::numeric_limits<float>::quiet_NaN): Use __builtin_nanf.\n        (std::numeric_limits<float>::signaling_NaN): Use __builtin_nansf.\n        (std::numeric_limits<double>): Similarly.\n        (std::numeric_limits<long double>): Similarly.\n        * src/limits.cc (__glibcpp_float_QNaN, __glibcpp_float_SNaN): Remove.\n        (__glibcpp_double_QNaN, __glibcpp_double_SNaN): Remove.\n        (__glibcpp_long_double_QNaN, __glibcpp_long_double_SNaN): Remove.\n\n        * testsuite/18_support/numeric_limits.cc (test_infinity): New.\n        (test_denorm_min, test_qnan, test_is_iec559): New.\n\nFrom-SVN: r57221", "tree": {"sha": "13b37fe93a02d7ab652503bcdc4b3b55cdb5e3d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13b37fe93a02d7ab652503bcdc4b3b55cdb5e3d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1472e41cb31db005533692d13c807503f39f1408", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1472e41cb31db005533692d13c807503f39f1408", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1472e41cb31db005533692d13c807503f39f1408", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1472e41cb31db005533692d13c807503f39f1408/comments", "author": null, "committer": null, "parents": [{"sha": "f354b82835d441a9430484561f45ad2cfff6d0bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f354b82835d441a9430484561f45ad2cfff6d0bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f354b82835d441a9430484561f45ad2cfff6d0bc"}], "stats": {"total": 573, "additions": 359, "deletions": 214}, "files": [{"sha": "85a32f95b38cfe808681ead441a121aa0681d99b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1472e41cb31db005533692d13c807503f39f1408/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1472e41cb31db005533692d13c807503f39f1408/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1472e41cb31db005533692d13c807503f39f1408", "patch": "@@ -1,3 +1,16 @@\n+2002-09-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* builtin-types.def (BT_FN_FLOAT_CONST_STRING): New.\n+\t(BT_FN_DOUBLE_CONST_STRING, BT_FN_LONG_DOUBLE_CONST_STRING): New.\n+\t* builtins.def (__builtin_nan, __builtin_nanf, __builtin_nanl): New.\n+\t(__builtin_nans, __builtin_nansf, __builtin_nansl): New.\n+\t* builtins.c (fold_builtin_nan): New.\n+\t(fold_builtin): Call it.\n+\t* real.c (real_nan): Parse a non-empty string.\n+\t(round_for_format): Fix NaN significand truncation.\n+\t* real.h (real_nan): Return bool.\n+\t* doc/extend.texi: Document new builtins.\n+\n 2002-09-16  Jason Merrill  <jason@redhat.com>\n \t    Danny Smith  <dannysmith@users.sourceforge.net>\n "}, {"sha": "be52392b49b43765c14777390d6a3c056085c325", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1472e41cb31db005533692d13c807503f39f1408/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1472e41cb31db005533692d13c807503f39f1408/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=1472e41cb31db005533692d13c807503f39f1408", "patch": "@@ -117,6 +117,10 @@ DEF_FUNCTION_TYPE_1 (BT_FN_INT_CONST_STRING, BT_INT, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_PTR_PTR, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_VALIST_REF, BT_VOID, BT_VALIST_REF)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_INT, BT_VOID, BT_INT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_CONST_STRING, BT_FLOAT, BT_CONST_STRING)\n+DEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_CONST_STRING, BT_DOUBLE, BT_CONST_STRING)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LONG_DOUBLE_CONST_STRING,\n+\t\t     BT_LONG_DOUBLE, BT_CONST_STRING)\n \n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_INT, BT_VOID, BT_PTR, BT_INT)\n DEF_FUNCTION_TYPE_2 (BT_FN_STRING_STRING_CONST_STRING, "}, {"sha": "25fadab0e21612a20118bd0e3373082ad7ddaeb1", "filename": "gcc/builtins.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1472e41cb31db005533692d13c807503f39f1408/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1472e41cb31db005533692d13c807503f39f1408/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1472e41cb31db005533692d13c807503f39f1408", "patch": "@@ -149,6 +149,7 @@ static rtx expand_builtin_expect\tPARAMS ((tree, rtx));\n static tree fold_builtin_constant_p\tPARAMS ((tree));\n static tree fold_builtin_classify_type\tPARAMS ((tree));\n static tree fold_builtin_inf\t\tPARAMS ((tree, int));\n+static tree fold_builtin_nan\t\tPARAMS ((tree, tree, int));\n static tree build_function_call_expr\tPARAMS ((tree, tree));\n static int validate_arglist\t\tPARAMS ((tree, ...));\n \n@@ -4149,6 +4150,28 @@ fold_builtin_inf (type, warn)\n   return build_real (type, real);\n }\n \n+/* Fold a call to __builtin_nan or __builtin_nans.  */\n+\n+static tree\n+fold_builtin_nan (arglist, type, quiet)\n+     tree arglist, type;\n+     int quiet;\n+{\n+  REAL_VALUE_TYPE real;\n+  const char *str;\n+\n+  if (!validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))\n+    return 0;\n+  str = c_getstr (TREE_VALUE (arglist));\n+  if (!str)\n+    return 0;\n+\n+  if (!real_nan (&real, str, quiet, TYPE_MODE (type)))\n+    return 0;\n+\n+  return build_real (type, real);\n+}\n+\n /* Used by constant folding to eliminate some builtin calls early.  EXP is\n    the CALL_EXPR of a call to a builtin function.  */\n \n@@ -4190,6 +4213,16 @@ fold_builtin (exp)\n     case BUILT_IN_HUGE_VALL:\n       return fold_builtin_inf (TREE_TYPE (TREE_TYPE (fndecl)), false);\n \n+    case BUILT_IN_NAN:\n+    case BUILT_IN_NANF:\n+    case BUILT_IN_NANL:\n+      return fold_builtin_nan (arglist, TREE_TYPE (TREE_TYPE (fndecl)), true);\n+\n+    case BUILT_IN_NANS:\n+    case BUILT_IN_NANSF:\n+    case BUILT_IN_NANSL:\n+      return fold_builtin_nan (arglist, TREE_TYPE (TREE_TYPE (fndecl)), false);\n+\n     default:\n       break;\n     }"}, {"sha": "8a3dac332364437d98b302b6be43cc190cb14a4c", "filename": "gcc/builtins.def", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1472e41cb31db005533692d13c807503f39f1408/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1472e41cb31db005533692d13c807503f39f1408/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=1472e41cb31db005533692d13c807503f39f1408", "patch": "@@ -427,6 +427,32 @@ DEF_GCC_BUILTIN(BUILT_IN_HUGE_VALL,\n \t\tBT_FN_LONG_DOUBLE,\n \t\tATTR_CONST_NOTHROW_LIST)\n \n+DEF_LIB_BUILTIN(BUILT_IN_NAN,\n+\t\t\"__builtin_nan\",\n+\t\tBT_FN_DOUBLE_CONST_STRING,\n+\t\tATTR_CONST_NOTHROW_LIST)\n+DEF_LIB_BUILTIN(BUILT_IN_NANF,\n+\t\t\"__builtin_nanf\",\n+\t\tBT_FN_FLOAT_CONST_STRING,\n+\t\tATTR_CONST_NOTHROW_LIST)\n+DEF_LIB_BUILTIN(BUILT_IN_NANL,\n+\t\t\"__builtin_nanl\",\n+\t\tBT_FN_LONG_DOUBLE_CONST_STRING,\n+\t\tATTR_CONST_NOTHROW_LIST)\n+\n+DEF_LIB_BUILTIN(BUILT_IN_NANS,\n+\t\t\"__builtin_nans\",\n+\t\tBT_FN_DOUBLE_CONST_STRING,\n+\t\tATTR_CONST_NOTHROW_LIST)\n+DEF_LIB_BUILTIN(BUILT_IN_NANSF,\n+\t\t\"__builtin_nansf\",\n+\t\tBT_FN_FLOAT_CONST_STRING,\n+\t\tATTR_CONST_NOTHROW_LIST)\n+DEF_LIB_BUILTIN(BUILT_IN_NANSL,\n+\t\t\"__builtin_nansl\",\n+\t\tBT_FN_LONG_DOUBLE_CONST_STRING,\n+\t\tATTR_CONST_NOTHROW_LIST)\n+\n DEF_GCC_BUILTIN(BUILT_IN_SAVEREGS,\n \t\t\"__builtin_saveregs\",\n \t\tBT_FN_PTR_VAR,"}, {"sha": "d3e3eceff894299c7f498a606a6aadc946b58a92", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1472e41cb31db005533692d13c807503f39f1408/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1472e41cb31db005533692d13c807503f39f1408/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=1472e41cb31db005533692d13c807503f39f1408", "patch": "@@ -4863,6 +4863,44 @@ Similar to @code{__builtin_inf}, except the return\n type is @code{long double}.\n @end deftypefn\n \n+@deftypefn {Built-in Function} double __builtin_nan (const char *str)\n+This is an implementation of the ISO C99 function @code{nan}.\n+\n+Since ISO C99 defines this function in terms of @code{strtod}, which we\n+do not implement, a desription of the parsing is in order.  The string\n+is parsed as by @code{strtol}; that is, the base is recognized by\n+leading @samp{0} or @samp{0x} prefixes.  The number parsed is placed\n+in the significand such that the least significant bit of the number\n+is at the least significant bit of the significand.  The number is \n+truncated to fit the significand field provided.  The significand is\n+forced to be a quiet NaN.\n+\n+This function, if given a string literal, is evaluated early enough\n+that it is considered a compile-time constant.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} float __builtin_nanf (const char *str)\n+Similar to @code{__builtin_nan}, except the return type is @code{float}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} long double __builtin_nanl (const char *str)\n+Similar to @code{__builtin_nan}, except the return type is @code{long double}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} double __builtin_nans (const char *str)\n+Similar to @code{__builtin_nan}, except the significand is forced \n+to be a signaling NaN.  The @code{nans} function is proposed by\n+@uref{http://std.dkuug.dk/JTC1/SC22/WG14/www/docs/n965.htm,,WG14 N956}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} float __builtin_nansf (const char *str)\n+Similar to @code{__builtin_nans}, except the return type is @code{float}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} long double __builtin_nansl (const char *str)\n+Similar to @code{__builtin_nans}, except the return type is @code{long double}.\n+@end deftypefn\n+\n @node Target Builtins\n @section Built-in Functions Specific to Particular Target Machines\n "}, {"sha": "5859f0ff87807522975d50f85774c9be311453ba", "filename": "gcc/real.c", "status": "modified", "additions": 94, "deletions": 7, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1472e41cb31db005533692d13c807503f39f1408/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1472e41cb31db005533692d13c807503f39f1408/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=1472e41cb31db005533692d13c807503f39f1408", "patch": "@@ -1946,16 +1946,22 @@ real_inf (tr)\n \n /* Fills R with a NaN whose significand is described by STR.  If QUIET,\n    we force a QNaN, else we force an SNaN.  The string, if not empty,\n-   is parsed as a number and placed in the significand.  */\n+   is parsed as a number and placed in the significand.  Return true\n+   if the string was successfully parsed.  */\n \n-void\n+bool\n real_nan (tr, str, quiet, mode)\n      REAL_VALUE_TYPE *tr;\n      const char *str;\n      int quiet;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode;\n {\n   struct real_value *r = (struct real_value *) tr;\n+  const struct real_format *fmt;\n+\n+  fmt = fmt_for_mode[mode - QFmode];\n+  if (fmt == NULL)\n+    abort ();\n \n   if (*str == 0)\n     {\n@@ -1965,8 +1971,89 @@ real_nan (tr, str, quiet, mode)\n \tget_canonical_snan (r, 0);\n     }\n   else\n-    /* FIXME */\n-    abort ();\n+    {\n+      int base = 10, d;\n+      bool neg = false;\n+\n+      memset (r, 0, sizeof (*r));\n+      r->class = rvc_nan;\n+\n+      /* Parse akin to strtol into the significand of R.  */\n+\n+      while (ISSPACE (*str))\n+\tstr++;\n+      if (*str == '-')\n+\tstr++, neg = true;\n+      else if (*str == '+')\n+\tstr++;\n+      if (*str == '0')\n+\t{\n+\t  if (*++str == 'x')\n+\t    str++, base = 16;\n+\t  else\n+\t    base = 8;\n+\t}\n+\n+      while ((d = hex_value (*str)) < base)\n+\t{\n+\t  struct real_value u;\n+\n+\t  switch (base)\n+\t    {\n+\t    case 8:\n+\t      lshift_significand (r, r, 3);\n+\t      break;\n+\t    case 16:\n+\t      lshift_significand (r, r, 4);\n+\t      break;\n+\t    case 10:\n+\t      lshift_significand_1 (&u, r);\n+\t      lshift_significand (r, r, 3);\n+\t      add_significands (r, r, &u);\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t    }\n+\n+\t  get_zero (&u, 0);\n+\t  u.sig[0] = d;\n+\t  add_significands (r, r, &u);\n+\n+\t  str++;\n+\t}\n+\n+      /* Must have consumed the entire string for success.  */\n+      if (*str != 0)\n+\treturn false;\n+\n+      /* Shift the significand into place such that the bits\n+\t are in the most significant bits for the format.  */\n+      lshift_significand (r, r, SIGNIFICAND_BITS - fmt->p);\n+\n+      /* Our MSB is always unset for NaNs.  */\n+      r->sig[SIGSZ-1] &= ~SIG_MSB;\n+\n+      /* Force quiet or signalling NaN.  */\n+      if (quiet)\n+\tr->sig[SIGSZ-1] |= SIG_MSB >> 1;\n+      else\n+\tr->sig[SIGSZ-1] &= ~(SIG_MSB >> 1);\n+\n+      /* Force at least one bit of the significand set.  */\n+      for (d = 0; d < SIGSZ; ++d)\n+\tif (r->sig[d])\n+\t  break;\n+      if (d == SIGSZ)\n+\tr->sig[SIGSZ-1] |= SIG_MSB >> 2;\n+\n+      /* Our intermediate format forces QNaNs to have MSB-1 set.\n+\t If the target format has QNaNs with the top bit unset,\n+\t mirror the output routines and invert the top two bits.  */\n+      if (!fmt->qnan_msb_set)\n+\tr->sig[SIGSZ-1] ^= (SIG_MSB >> 1) | (SIG_MSB >> 2);\n+    }\n+\n+  return true;\n }\n \n /* Fills R with 2**N.  */\n@@ -2023,15 +2110,15 @@ round_for_format (fmt, r)\n       return;\n \n     case rvc_nan:\n-      clear_significand_below (r, np2 + 1);\n+      clear_significand_below (r, np2);\n \n       /* If we've cleared the entire significand, we need one bit\n \t set for this to continue to be a NaN.  */\n       for (i = 0; i < SIGSZ; ++i)\n \tif (r->sig[i])\n \t  break;\n       if (i == SIGSZ)\n-\tr->sig[SIGSZ-1] = SIG_MSB >> 1;\n+\tr->sig[SIGSZ-1] = SIG_MSB >> 2;\n       return;\n \n     case rvc_normal:"}, {"sha": "24df216ec536a586c933f8151138b3fa18d9713a", "filename": "gcc/real.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1472e41cb31db005533692d13c807503f39f1408/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1472e41cb31db005533692d13c807503f39f1408/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=1472e41cb31db005533692d13c807503f39f1408", "patch": "@@ -143,7 +143,7 @@ extern void real_from_target\tPARAMS ((REAL_VALUE_TYPE *, const long *,\n \n extern void real_inf\t\tPARAMS ((REAL_VALUE_TYPE *));\n \n-extern void real_nan\t\tPARAMS ((REAL_VALUE_TYPE *, const char *,\n+extern bool real_nan\t\tPARAMS ((REAL_VALUE_TYPE *, const char *,\n \t\t\t\t\t int, enum machine_mode));\n \n extern void real_2expN\t\tPARAMS ((REAL_VALUE_TYPE *, int));"}, {"sha": "ac58d513809da5f1ef3162468d0a5cb5d23042fa", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1472e41cb31db005533692d13c807503f39f1408/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1472e41cb31db005533692d13c807503f39f1408/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1472e41cb31db005533692d13c807503f39f1408", "patch": "@@ -1,3 +1,39 @@\n+2002-09-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* include/std/std_limits.h (__glibcpp_f32_QNaN_bytes,\n+\t__glibcpp_f32_has_QNaN, __glibcpp_f32_SNaN_bytes,\n+\t__glibcpp_f32_has_SNaN, __glibcpp_f64_QNaN_bytes,\n+\t__glibcpp_f64_has_QNaN, __glibcpp_f64_SNaN_bytes,\n+\t__glibcpp_f64_has_SNaN, __glibcpp_f80_QNaN_bytes,\n+\t__glibcpp_f80_has_QNaN, __glibcpp_f80_SNaN_bytes,\n+\t__glibcpp_f80_has_SNaN, __glibcpp_f96_QNaN_bytes,\n+\t__glibcpp_f96_has_QNaN, __glibcpp_f96_SNaN_bytes,\n+\t__glibcpp_f96_has_SNaN, __glibcpp_f128_QNaN_bytes,\n+\t__glibcpp_f128_has_QNaN, __glibcpp_f128_SNaN_bytes,\n+\t__glibcpp_f128_has_SNaN, __glibcpp_float_QNaN_bytes,\n+\t__glibcpp_float_has_QNaN, __glibcpp_float_SNaN_bytes,\n+\t__glibcpp_float_has_SNaN, __glibcpp_double_QNaN_bytes,\n+\t__glibcpp_double_has_QNaN, __glibcpp_double_SNaN_bytes,\n+\t__glibcpp_double_has_SNaN, __glibcpp_long_double_QNaN_bytes,\n+\t__glibcpp_long_double_has_QNaN, __glibcpp_long_double_SNaN_bytes,\n+\t__glibcpp_long_double_has_SNaN): Remove.\n+\t(__glibcpp_f128_is_iec559): True if IEEE.\n+\t(__glibcpp_float_QNaN, __glibcpp_float_SNaN): Remove.\n+\t(__glibcpp_double_QNaN, __glibcpp_double_SNaN): Remove.\n+\t(__glibcpp_long_double_QNaN, __glibcpp_long_double_SNaN): Remove.\n+\t(std::numeric_limits<float>::has_quiet_NaN): Use __builtin_nanf.\n+\t(std::numeric_limits<float>::has_signaling_NaN): Mirror has_quiet_NaN.\n+\t(std::numeric_limits<float>::quiet_NaN): Use __builtin_nanf.\n+\t(std::numeric_limits<float>::signaling_NaN): Use __builtin_nansf.\n+\t(std::numeric_limits<double>): Similarly.\n+\t(std::numeric_limits<long double>): Similarly.\n+\t* src/limits.cc (__glibcpp_float_QNaN, __glibcpp_float_SNaN): Remove.\n+\t(__glibcpp_double_QNaN, __glibcpp_double_SNaN): Remove.\n+\t(__glibcpp_long_double_QNaN, __glibcpp_long_double_SNaN): Remove.\n+\n+\t* testsuite/18_support/numeric_limits.cc (test_infinity): New.\n+\t(test_denorm_min, test_qnan, test_is_iec559): New.\n+\n 2002-09-16  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* testsuite/abi_check.cc:  Pull shell fragments out into..."}, {"sha": "a1d42244bf84789fcc407c28418e1ba41799e43b", "filename": "libstdc++-v3/include/std/std_limits.h", "status": "modified", "additions": 16, "deletions": 194, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1472e41cb31db005533692d13c807503f39f1408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_limits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1472e41cb31db005533692d13c807503f39f1408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_limits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_limits.h?ref=1472e41cb31db005533692d13c807503f39f1408", "patch": "@@ -152,115 +152,32 @@\n \n #define __glibcpp_f32_round_error 1.0F\n #if __GCC_FLOAT_FORMAT__ == __IEEE_FORMAT__\n-#  define __glibcpp_f32_QNaN_bytes { 0x7fc00000 }\n-#  define __glibcpp_f32_has_QNaN true\n-#  define __glibcpp_f32_SNaN_bytes { 0x7f800001 }\n-#  define __glibcpp_f32_has_SNaN true\n #  define __glibcpp_f32_is_iec559  true\n #endif\n-#ifndef __glibcpp_f32_QNaN_bytes\n-#  define __glibcpp_f32_QNaN_bytes { }\n-#  define __glibcpp_f32_has_QNaN false\n-#endif\n-#ifndef __glibcpp_f32_SNaN_bytes\n-#  define __glibcpp_f32_SNaN_bytes { }\n-#  define __glibcpp_f32_has_SNaN false\n-#endif\n #ifndef __glibcpp_f32_is_iec559\n #  define __glibcpp_f32_is_iec559 false\n #endif \n #define __glibcpp_f64_round_error 1.0\n #if __GCC_FLOAT_FORMAT__ == __IEEE_FORMAT__\n-#  if __TARGET_FLOAT_WORDS_ORDER__ == __GCC_BIG_ENDIAN__\n-#    define __glibcpp_f64_QNaN_bytes { 0x7ff80000, 0x0 }\n-#    define __glibcpp_f64_SNaN_bytes { 0x7ff00000, 0x1 }\n-#  else\n-#    define __glibcpp_f64_QNaN_bytes { 0x0, 0x7ff80000 }\n-#    define __glibcpp_f64_SNaN_bytes { 0x1, 0x7ff00000 }\n-#  endif\n-#  define __glibcpp_f64_has_QNaN true\n-#  define __glibcpp_f64_has_SNaN true\n #  define __glibcpp_f64_is_iec559 true\n #endif\n-#ifndef __glibcpp_f64_QNaN_bytes\n-#  define __glibcpp_f64_QNaN_bytes { }\n-#  define __glibcpp_f64_has_QNaN false\n-#endif\n-#ifndef __glibcpp_f64_SNaN_bytes\n-#  define __glibcpp_f64_SNaN_bytes { }\n-#  define __glibcpp_f64_has_SNaN false\n-#endif\n #ifndef __glibcpp_f64_is_iec559\n #  define __glibcpp_f64_is_iec559 false\n #endif \n #define __glibcpp_f80_round_error 1.0L\n #if __GCC_FLOAT_FORMAT__ == __IEEE_FORMAT__\n-#  if __TARGET_BYTES_ORDER__ == __GCC_BIG_ENDIAN__\n-#    define __glibcpp_f80_QNaN_bytes       \\\n-       { 0x7f, 0xff, 0xC0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }\n-#    define __glibcpp_f80_SNaN_bytes       \\\n-       { 0x7f, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1 }\n-#  else\n-#    define __glibcpp_f80_QNaN_bytes       \\\n-       { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xC0, 0xff, 0x7f }\n-#    define __glibcpp_f80_SNaN_bytes       \\\n-       { 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0xff, 0x7f }\n-#  endif\n-#  define __glibcpp_f80_has_QNaN true\n-#  define __glibcpp_f80_has_SNaN true\n #  define __glibcpp_f80_is_iec559 true\n #endif\n-#ifndef __glibcpp_f80_QNaN_bytes\n-#  define __glibcpp_f80_QNaN_bytes { }\n-#  define __glibcpp_f80_has_QNaN false\n-#endif\n-#ifndef __glibcpp_f80_SNaN_bytes\n-#  define __glibcpp_f80_SNaN_bytes { }\n-#  define __glibcpp_f80_has_SNaN false\n-#endif\n #ifndef __glibcpp_f80_is_iec559\n #  define __glibcpp_f80_is_iec559 false\n #endif \n #define __glibcpp_f96_round_error 1.0L\n #if __GCC_FLOAT_FORMAT__ == __IEEE_FORMAT__\n-#  if __TARGET_BYTES_ORDER__ == __GCC_BIG_ENDIAN__\n-#    define __glibcpp_f96_QNaN_bytes { 0x7ff80000, 0x0, 0x0 }\n-#    define __glibcpp_f96_SNaN_bytes { 0x7ff00000, 0x0, 0x1 }\n-#  else\n-#    define __glibcpp_f96_QNaN_bytes { 0x0, 0x0, 0x7ff80000 }\n-#    define __glibcpp_f96_SNaN_bytes { 0x1, 0x0, 0x7ff00000 }\n-#  endif\n-#  define __glibcpp_f96_has_QNaN true\n-#  define __glibcpp_f96_has_SNaN true\n #  define __glibcpp_f96_is_iec559 true\n #endif\n-#ifndef __glibcpp_f96_QNaN_bytes\n-#  define __glibcpp_f96_QNaN_bytes { }\n-#  define __glibcpp_f96_has_QNaN false\n-#endif\n-#ifndef __glibcpp_f96_SNaN_bytes\n-#  define __glibcpp_f96_SNaN_bytes { }\n-#  define __glibcpp_f96_has_SNaN false\n-#endif\n #define __glibcpp_f128_round_error 1.0L\n #if __GCC_FLOAT_FORMAT__ == __IEEE_FORMAT__\n-#  if __TARGET_FLOAT_WORDS_ORDER__ == __GCC_BIG_ENDIAN__\n-#    define __glibcpp_f128_QNaN_bytes { 0x7fff0800, 0x0, 0x0, 0x0 }\n-#    define __glibcpp_f128_SNaN_bytes { 0x7fff0000, 0x0, 0x0, 0x1 }\n-#  else\n-#    define __glibcpp_f128_QNaN_bytes { 0x0, 0x0, 0x0, 0x7fff0800 }\n-#    define __glibcpp_f128_SNaN_bytes { 0x1, 0x0, 0x0, 0x7fff0000 }\n-#  endif\n-#  define __glibcpp_f128_has_QNaN true\n-#  define __glibcpp_f128_has_SNaN true\n-#endif\n-#ifndef __glibcpp_f128_QNaN_bytes\n-#  define __glibcpp_f128_QNaN_bytes { }\n-#  define __glibcpp_f128_has_QNaN false\n-#endif\n-#ifndef __glibcpp_f128_SNaN_bytes\n-#  define __glibcpp_f128_SNaN_bytes { }\n-#  define __glibcpp_f128_has_SNaN false\n+#  define __glibcpp_f128_is_iec559 true\n #endif\n #ifndef __glibcpp_f128_is_iec559\n #  define __glibcpp_f128_is_iec559 false\n@@ -587,41 +504,19 @@\n \n #if __FLOAT_BIT__ == 32\n #  define __glibcpp_float_round_error __glibcpp_f32_round_error\n-#  define __glibcpp_float_QNaN_bytes  __glibcpp_f32_QNaN_bytes\n-#  define __glibcpp_float_SNaN_bytes  __glibcpp_f32_SNaN_bytes\n-#  define __glibcpp_float_has_QNaN __glibcpp_f32_has_QNaN\n-#  define __glibcpp_float_has_SNaN __glibcpp_f32_has_SNaN\n #  define __glibcpp_float_is_iec559 __glibcpp_f32_is_iec559\n #elif __FLOAT_BIT__ == 64\n #  define __glibcpp_float_round_error __glibcpp_f64_round_error\n-#  define __glibcpp_float_QNaN_bytes  __glibcpp_f64_QNaN_bytes\n-#  define __glibcpp_float_SNaN_bytes  __glibcpp_f64_SNaN_bytes\n-#  define __glibcpp_float_has_QNaN __glibcpp_f64_has_QNaN\n-#  define __glibcpp_float_has_SNaN __glibcpp_f64_has_SNaN\n #  define __glibcpp_float_is_iec559 __glibcpp_f64_is_iec559\n #elif __FLOAT_BIT__ == 80\n #  define __glibcpp_float_round_error __glibcpp_f80_round_error\n-#  define __glibcpp_float_QNaN_bytes  __glibcpp_f80_QNaN_bytes\n-#  define __glibcpp_float_SNaN_bytes  __glibcpp_f80_SNaN_bytes\n-#  define __glibcpp_float_has_QNaN __glibcpp_f80_has_QNaN\n-#  define __glibcpp_float_has_SNaN __glibcpp_f80_has_SNaN\n #  define __glibcpp_float_is_iec559 __glibcpp_f80_is_iec559\n #else\n // You must define these macros in the configuration file.\n #endif\n \n // Default values.  Should be overriden in configuration files if necessary.\n \n-#ifndef __glibcpp_float_QNaN_bytes\n-#  define __glibcpp_float_QNaN_bytes { }\n-#  define __glibcpp_float_has_QNaN false\n-#endif\n-\n-#ifndef __glibcpp_float_SNaN_bytes\n-#  define __glibcpp_float_SNaN_bytes { }\n-#  define __glibcpp_float_has_SNaN false\n-#endif\n-\n #ifndef __glibcpp_float_has_denorm_loss\n #  define __glibcpp_float_has_denorm_loss false\n #endif\n@@ -654,41 +549,19 @@\n \n #if __DOUBLE_BIT__ == 32\n #  define __glibcpp_double_round_error __glibcpp_f32_round_error\n-#  define __glibcpp_double_QNaN_bytes __glibcpp_f32_QNaN_bytes\n-#  define __glibcpp_double_SNaN_bytes __glibcpp_f32_SNaN_bytes\n-#  define __glibcpp_double_has_QNaN __glibcpp_f32_has_QNaN\n-#  define __glibcpp_double_has_SNaN __glibcpp_f32_has_SNaN\n #  define __glibcpp_double_is_iec559 __glibcpp_f32_is_iec559\n #elif __DOUBLE_BIT__ == 64\n #  define __glibcpp_double_round_error __glibcpp_f64_round_error\n-#  define __glibcpp_double_QNaN_bytes __glibcpp_f64_QNaN_bytes\n-#  define __glibcpp_double_SNaN_bytes __glibcpp_f64_SNaN_bytes\n-#  define __glibcpp_double_has_QNaN __glibcpp_f64_has_QNaN\n-#  define __glibcpp_double_has_SNaN __glibcpp_f64_has_SNaN\n #  define __glibcpp_double_is_iec559 __glibcpp_f64_is_iec559\n #elif __DOUBLE_BIT__ == 80\n #  define __glibcpp_double_round_error __glibcpp_f80_round_error\n-#  define __glibcpp_double_QNaN_bytes __glibcpp_f80_QNaN_bytes\n-#  define __glibcpp_double_SNaN_bytes __glibcpp_f80_SNaN_bytes\n-#  define __glibcpp_double_has_QNaN __glibcpp_f80_has_QNaN\n-#  define __glibcpp_double_has_SNaN __glibcpp_f80_has_SNaN\n #  define __glibcpp_double_is_iec559 __glibcpp_f80_is_iec559\n #else\n // You must define these macros in the configuration file.\n #endif\n \n // Default values.  Should be overriden in configuration files if necessary.\n \n-#ifndef __glibcpp_double_QNaN_bytes\n-#  define __glibcpp_double_QNaN_bytes { }\n-#  define __glibcpp_double_has_QNaN false\n-#endif\n-\n-#ifndef __glibcpp_double_SNaN_bytes\n-#  define __glibcpp_double_SNaN_bytes { }\n-#  define __glibcpp_double_has_SNaN false\n-#endif\n-\n #ifndef __glibcpp_double_has_denorm_loss\n #  define __glibcpp_double_has_denorm_loss false\n #endif\n@@ -721,55 +594,25 @@\n \n #if __LONG_DOUBLE_BIT__ == 32\n #  define __glibcpp_long_double_round_error __glibcpp_f32_round_error\n-#  define __glibcpp_long_double_QNaN_bytes __glibcpp_f32_QNaN_bytes\n-#  define __glibcpp_long_double_SNaN_bytes __glibcpp_f32_SNaN_bytes\n-#  define __glibcpp_long_double_has_QNaN __glibcpp_f32_has_QNaN\n-#  define __glibcpp_long_double_has_SNaN __glibcpp_f32_has_SNaN\n #  define __glibcpp_long_double_is_iec559 __glibcpp_f32_is_iec559\n #elif __LONG_DOUBLE_BIT__ == 64\n #  define __glibcpp_long_double_round_error __glibcpp_f64_round_error\n-#  define __glibcpp_long_double_QNaN_bytes __glibcpp_f64_QNaN_bytes\n-#  define __glibcpp_long_double_SNaN_bytes __glibcpp_f64_SNaN_bytes\n-#  define __glibcpp_long_double_has_QNaN __glibcpp_f64_has_QNaN\n-#  define __glibcpp_long_double_has_SNaN __glibcpp_f64_has_SNaN\n #  define __glibcpp_long_double_is_iec559 __glibcpp_f64_is_iec559\n #elif __LONG_DOUBLE_BIT__ == 80\n #  define __glibcpp_long_double_round_error __glibcpp_f80_round_error\n-#  define __glibcpp_long_double_QNaN_bytes __glibcpp_f80_QNaN_bytes\n-#  define __glibcpp_long_double_SNaN_bytes __glibcpp_f80_SNaN_bytes\n-#  define __glibcpp_long_double_has_QNaN __glibcpp_f80_has_QNaN\n-#  define __glibcpp_long_double_has_SNaN __glibcpp_f80_has_SNaN\n #  define __glibcpp_long_double_is_iec559 __glibcpp_f80_is_iec559\n #elif __LONG_DOUBLE_BIT__ == 96\n #  define __glibcpp_long_double_round_error __glibcpp_f96_round_error\n-#  define __glibcpp_long_double_QNaN_bytes __glibcpp_f96_QNaN_bytes\n-#  define __glibcpp_long_double_SNaN_bytes __glibcpp_f96_SNaN_bytes\n-#  define __glibcpp_long_double_has_QNaN __glibcpp_f96_has_QNaN\n-#  define __glibcpp_long_double_has_SNaN __glibcpp_f96_has_SNaN\n #  define __glibcpp_long_double_is_iec559 __glibcpp_f96_is_iec559\n #elif __LONG_DOUBLE_BIT__ == 128\n #  define __glibcpp_long_double_round_error __glibcpp_f128_round_error\n-#  define __glibcpp_long_double_QNaN_bytes __glibcpp_f128_QNaN_bytes\n-#  define __glibcpp_long_double_SNaN_bytes __glibcpp_f128_SNaN_bytes\n-#  define __glibcpp_long_double_has_QNaN __glibcpp_f128_has_QNaN\n-#  define __glibcpp_long_double_has_SNaN __glibcpp_f128_has_SNaN\n #  define __glibcpp_long_double_is_iec559 __glibcpp_f128_is_iec559\n #else\n // You must define these macros in the configuration file.\n #endif\n \n // Default values.  Should be overriden in configuration files if necessary.\n \n-#ifndef __glibcpp_long_double_QNaN_bytes\n-#  define __glibcpp_long_double_QNaN_bytes { }\n-#  define __glibcpp_long_double_has_QNaN false\n-#endif\n-\n-#ifndef __glibcpp_long_double_SNaN_bytes\n-#  define __glibcpp_long_double_SNaN_bytes { }\n-#  define __glibcpp_long_double_has_SNaN false\n-#endif\n-\n #ifndef __glibcpp_long_double_has_denorm_loss\n #  define __glibcpp_long_double_has_denorm_loss false\n #endif\n@@ -843,15 +686,6 @@ namespace std\n #endif  \n     __attribute__((__aligned__(__alignof__(long double))));\n \n-  extern const __float_storage __glibcpp_float_QNaN;\n-  extern const __float_storage __glibcpp_float_SNaN;\n-  \n-  extern const __double_storage __glibcpp_double_QNaN;\n-  extern const __double_storage __glibcpp_double_SNaN;\n-\n-  extern const __long_double_storage __glibcpp_long_double_QNaN;\n-  extern const __long_double_storage __glibcpp_long_double_SNaN;\n-  \n   enum float_round_style \n   {\n     round_indeterminate       = -1,\n@@ -1680,18 +1514,19 @@ namespace std\n \n       static const bool has_infinity\n \t= __builtin_huge_valf () / 2 == __builtin_huge_valf ();\n-      static const bool has_quiet_NaN = __glibcpp_float_has_QNaN;\n-      static const bool has_signaling_NaN = __glibcpp_float_has_SNaN;\n+      static const bool has_quiet_NaN\n+\t= __builtin_nanf (\"\") != __builtin_nanf (\"\");\n+      static const bool has_signaling_NaN = has_quiet_NaN;\n       static const float_denorm_style has_denorm\n \t= __FLT_DENORM_MIN__ ? denorm_present : denorm_absent;\n       static const bool has_denorm_loss = __glibcpp_float_has_denorm_loss;\n \n       static float infinity() throw()\n       { return __builtin_huge_valf (); }\n       static float quiet_NaN() throw()\n-      { return *reinterpret_cast<const float*>(__glibcpp_float_QNaN); }\n+      { return __builtin_nanf (\"\"); }\n       static float signaling_NaN() throw()\n-      { return *reinterpret_cast<const float*>(__glibcpp_float_SNaN); }\n+      { return __builtin_nansf (\"\"); }\n       static float denorm_min() throw()\n       { return __FLT_DENORM_MIN__; }\n \n@@ -1705,8 +1540,6 @@ namespace std\n     };\n \n #undef __glibcpp_float_round_error\n-#undef __glibcpp_float_has_QNaN\n-#undef __glibcpp_float_has_SNaN\n #undef __glibcpp_float_has_denorm_loss\n #undef __glibcpp_float_is_iec559\n #undef __glibcpp_float_is_bounded\n@@ -1743,18 +1576,19 @@ namespace std\n \n       static const bool has_infinity\n \t= __builtin_huge_val () / 2 == __builtin_huge_val ();\n-      static const bool has_quiet_NaN = __glibcpp_double_has_QNaN;\n-      static const bool has_signaling_NaN = __glibcpp_double_has_SNaN;\n+      static const bool has_quiet_NaN\n+\t= __builtin_nan (\"\") != __builtin_nan (\"\");\n+      static const bool has_signaling_NaN = has_quiet_NaN;\n       static const float_denorm_style has_denorm\n \t= __DBL_DENORM_MIN__ ? denorm_present : denorm_absent;\n       static const bool has_denorm_loss = __glibcpp_double_has_denorm_loss;\n \n       static double infinity() throw()\n       { return __builtin_huge_val(); }\n       static double quiet_NaN() throw()\n-      { return *reinterpret_cast<const double*>(__glibcpp_double_QNaN); }\n+      { return __builtin_nan (\"\"); }\n       static double signaling_NaN() throw()\n-      { return *reinterpret_cast<const double*>(__glibcpp_double_SNaN); }\n+      { return __builtin_nans (\"\"); }\n       static double denorm_min() throw()\n       { return __DBL_DENORM_MIN__; }\n \n@@ -1769,8 +1603,6 @@ namespace std\n     };\n \n #undef __glibcpp_double_round_error\n-#undef __glibcpp_double_has_QNaN\n-#undef __glibcpp_double_has_SNaN\n #undef __glibcpp_double_has_denorm_loss\n #undef __glibcpp_double_is_iec559\n #undef __glibcpp_double_is_bounded\n@@ -1808,28 +1640,20 @@ namespace std\n \n       static const bool has_infinity\n \t= __builtin_huge_vall () / 2 == __builtin_huge_vall ();\n-      static const bool has_quiet_NaN = __glibcpp_long_double_has_SNaN;\n-      static const bool has_signaling_NaN = __glibcpp_long_double_has_SNaN;\n+      static const bool has_quiet_NaN\n+\t= __builtin_nanl (\"\") != __builtin_nanl (\"\");\n+      static const bool has_signaling_NaN = has_quiet_NaN;\n       static const float_denorm_style has_denorm\n \t= __LDBL_DENORM_MIN__ ? denorm_present : denorm_absent;\n       static const bool has_denorm_loss\n \t= __glibcpp_long_double_has_denorm_loss;\n \n       static long double infinity() throw()\n       { return __builtin_huge_vall (); } \n-\n       static long double quiet_NaN() throw()\n-      {\n-        return *reinterpret_cast<const long double*>\n-          (__glibcpp_long_double_QNaN);\n-      }\n-\n+      { return __builtin_nanl (\"\"); }\n       static long double signaling_NaN() throw()\n-      {\n-        return *reinterpret_cast<const long double*>\n-          (__glibcpp_long_double_SNaN);\n-      }\n-      \n+      { return __builtin_nansl (\"\"); }\n       static long double denorm_min() throw()\n       { return __LDBL_DENORM_MIN__; }\n \n@@ -1844,8 +1668,6 @@ namespace std\n     };\n \n #undef __glibcpp_long_double_round_error\n-#undef __glibcpp_long_double_has_QNaN\n-#undef __glibcpp_long_double_has_SNaN\n #undef __glibcpp_long_double_has_denorm_loss\n #undef __glibcpp_long_double_is_iec559\n #undef __glibcpp_long_double_is_bounded"}, {"sha": "294673ea186999dd92e9268693e1121f944bbab5", "filename": "libstdc++-v3/src/limits.cc", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1472e41cb31db005533692d13c807503f39f1408/libstdc%2B%2B-v3%2Fsrc%2Flimits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1472e41cb31db005533692d13c807503f39f1408/libstdc%2B%2B-v3%2Fsrc%2Flimits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flimits.cc?ref=1472e41cb31db005533692d13c807503f39f1408", "patch": "@@ -38,17 +38,6 @@\n \n namespace std \n {\n-  const __float_storage __glibcpp_float_QNaN = __glibcpp_float_QNaN_bytes;\n-  const __float_storage __glibcpp_float_SNaN = __glibcpp_float_SNaN_bytes;\n-\n-  const __double_storage __glibcpp_double_QNaN = __glibcpp_double_QNaN_bytes;\n-  const __double_storage __glibcpp_double_SNaN = __glibcpp_double_SNaN_bytes;\n-\n-  const __long_double_storage __glibcpp_long_double_QNaN =\n-    __glibcpp_long_double_QNaN_bytes;\n-  const __long_double_storage __glibcpp_long_double_SNaN =\n-    __glibcpp_long_double_SNaN_bytes;\n-\n   const bool __numeric_limits_base::is_specialized;\n   const int  __numeric_limits_base::digits;\n   const int  __numeric_limits_base::digits10;"}, {"sha": "75c70277ff60939c0f9a85a90440d232296b7ee8", "filename": "libstdc++-v3/testsuite/18_support/numeric_limits.cc", "status": "modified", "additions": 98, "deletions": 1, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1472e41cb31db005533692d13c807503f39f1408/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1472e41cb31db005533692d13c807503f39f1408/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits.cc?ref=1472e41cb31db005533692d13c807503f39f1408", "patch": "@@ -116,6 +116,83 @@ void test_sign()\n }\n \n \n+template<typename T>\n+void\n+test_infinity()\n+{\n+  bool test;\n+\n+  if (std::numeric_limits<T>::has_infinity)\n+    {\n+      T inf = std::numeric_limits<T>::infinity();\n+      test = (inf + inf == inf);\n+    }\n+  else\n+    test = true;\n+\n+  VERIFY (test);\n+}\n+\n+template<typename T>\n+void\n+test_denorm_min()\n+{\n+  bool test;\n+\n+  if (std::numeric_limits<T>::has_denorm == std::denorm_present)\n+    {\n+      T denorm = std::numeric_limits<T>::denorm_min();\n+      test = (denorm > 0);\n+    }\n+  else\n+    test = true;\n+\n+  VERIFY (test);\n+}\n+\n+template<typename T>\n+void\n+test_qnan()\n+{\n+  bool test;\n+\n+  if (std::numeric_limits<T>::has_quiet_NaN)\n+    {\n+      T nan = std::numeric_limits<T>::quiet_NaN();\n+      test = (nan != nan);\n+    }\n+  else\n+    test = true;\n+\n+  VERIFY (test);\n+}\n+\n+\n+template<typename T>\n+void\n+test_is_iec559()\n+{\n+  bool test;\n+\n+  if (std::numeric_limits<T>::is_iec559)\n+    {\n+      // IEC 559 requires all of the following.\n+      test = (std::numeric_limits<T>::has_infinity\n+\t      && std::numeric_limits<T>::has_quiet_NaN\n+\t      && std::numeric_limits<T>::has_signaling_NaN);\n+    }\n+  else\n+    {\n+      // If we had all of the following, why didn't we set IEC 559?\n+      test = (!std::numeric_limits<T>::has_infinity\n+\t      || !std::numeric_limits<T>::has_quiet_NaN\n+\t      || !std::numeric_limits<T>::has_signaling_NaN);\n+    }\n+\n+  VERIFY (test);\n+}\n+\n+\n template<typename T>\n   struct A \n   {\n@@ -237,5 +314,25 @@ int main()\n \n   test_sign();\n \n-    return 0;\n+  test_infinity<float>();\n+  test_infinity<double>();\n+  test_infinity<long double>();\n+\n+  test_denorm_min<float>();\n+  test_denorm_min<double>();\n+  test_denorm_min<long double>();\n+\n+  test_qnan<float>();\n+  test_qnan<double>();\n+  test_qnan<long double>();\n+\n+  // ??? How to test SNaN?  We'd perhaps have to be prepared\n+  // to catch SIGFPE.  Can't rely on a signal getting through\n+  // since the exception can be disabled in the FPU.\n+\n+  test_is_iec559<float>();\n+  test_is_iec559<double>();\n+  test_is_iec559<long double>();\n+\n+  return 0;\n }"}]}