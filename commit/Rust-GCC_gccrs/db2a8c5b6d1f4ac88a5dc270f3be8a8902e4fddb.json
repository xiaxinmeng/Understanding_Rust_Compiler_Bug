{"sha": "db2a8c5b6d1f4ac88a5dc270f3be8a8902e4fddb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIyYThjNWI2ZDFmNGFjODhhNWRjMjcwZjNiZThhODkwMmU0ZmRkYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-06T17:29:33Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-06T17:29:33Z"}, "message": "Initial revision\n\nFrom-SVN: r16981", "tree": {"sha": "04c4f9ebbebba4b9aa1aa3fe8bdddfcda4ba4c10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04c4f9ebbebba4b9aa1aa3fe8bdddfcda4ba4c10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db2a8c5b6d1f4ac88a5dc270f3be8a8902e4fddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db2a8c5b6d1f4ac88a5dc270f3be8a8902e4fddb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db2a8c5b6d1f4ac88a5dc270f3be8a8902e4fddb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db2a8c5b6d1f4ac88a5dc270f3be8a8902e4fddb/comments", "author": null, "committer": null, "parents": [{"sha": "d62541ec15206f9704d88326e214631f5da7692a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d62541ec15206f9704d88326e214631f5da7692a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d62541ec15206f9704d88326e214631f5da7692a"}], "stats": {"total": 211, "additions": 211, "deletions": 0}, "files": [{"sha": "c8c84ee9b9147a93621ea1ab2d7b5b8dc60cf099", "filename": "gcc/ginclude/va-mips.h.hold", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db2a8c5b6d1f4ac88a5dc270f3be8a8902e4fddb/gcc%2Fginclude%2Fva-mips.h.hold", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db2a8c5b6d1f4ac88a5dc270f3be8a8902e4fddb/gcc%2Fginclude%2Fva-mips.h.hold", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-mips.h.hold?ref=db2a8c5b6d1f4ac88a5dc270f3be8a8902e4fddb", "patch": "@@ -0,0 +1,211 @@\n+/* ---------------------------------------- */\n+/*           VARARGS  for MIPS/GNU CC       */\n+/*                                          */\n+/*                                          */\n+/*                                          */\n+/*                                          */\n+/* ---------------------------------------- */\n+\n+\n+/* These macros implement varargs for GNU C--either traditional or ANSI.  */\n+\n+/* Define __gnuc_va_list.  */\n+\n+#ifndef __GNUC_VA_LIST\n+#define __GNUC_VA_LIST\n+#if defined (__mips_eabi) && ! defined (__mips_soft_float)\n+\n+typedef struct {\n+  /* Pointer to FP regs.  */\n+  char *__fp_regs;\n+  /* Number of FP regs remaining.  */\n+  int __fp_left;\n+  /* Pointer to GP regs followed by stack parameters.  */\n+  char *__gp_regs;\n+} __gnuc_va_list;\n+\n+#ifdef __mips64\n+#define __va_reg_size 8\n+#else\n+#define __va_reg_size 4\n+#endif\n+\n+enum {\n+  __no_type_class = -1,\n+  __void_type_class,\n+  __integer_type_class,\n+  __char_type_class,\n+  __enumeral_type_class,\n+  __boolean_type_class,\n+  __pointer_type_class,\n+  __reference_type_class,\n+  __offset_type_class,\n+  __real_type_class,\n+  __complex_type_class,\n+  __function_type_class,\n+  __method_type_class,\n+  __record_type_class,\n+  __union_type_class,\n+  __array_type_class,\n+  __string_type_class,\n+  __set_type_class,\n+  __file_type_class,\n+  __lang_type_class\n+};\n+\n+#else /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n+\n+typedef char * __gnuc_va_list;\n+\n+#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n+#endif /* not __GNUC_VA_LIST */\n+\n+/* If this is for internal libc use, don't define anything but\n+   __gnuc_va_list.  */\n+#if defined (_STDARG_H) || defined (_VARARGS_H)\n+\n+/* In GCC version 2, we want an ellipsis at the end of the declaration\n+   of the argument list.  GCC version 1 can't parse it.  */\n+\n+#if __GNUC__ > 1\n+#define __va_ellipsis ...\n+#else\n+#define __va_ellipsis\n+#endif\n+\n+#ifdef __mips64\n+#define __va_rounded_size(__TYPE)  \\\n+  (((sizeof (__TYPE) + 8 - 1) / 8) * 8)\n+#else\n+#define __va_rounded_size(__TYPE)  \\\n+  (((sizeof (__TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n+#endif\n+\n+/* Get definitions for _MIPS_SIM_ABI64 etc.  */\n+#ifdef _MIPS_SIM\n+#include <sgidefs.h>\n+#endif\n+\n+#ifdef _STDARG_H\n+#if defined (__mips_eabi) && ! defined (__mips_soft_float)\n+#define va_start(__AP, __LASTARG)\t\t\t\t\t\\\n+  (__AP.__gp_regs = ((char *) __builtin_next_arg (__LASTARG)\t\t\\\n+\t\t     - (__builtin_args_info (2) < 8\t\t\t\\\n+\t\t\t? (8 - __builtin_args_info (2)) * __va_reg_size\t\\\n+\t\t\t: 0)),\t\t\t\t\t\t\\\n+   __AP.__fp_left = 8 - __builtin_args_info (3),\t\t\t\\\n+   __AP.__fp_regs = __AP.__gp_regs - __AP.__fp_left * __va_reg_size)\n+#else /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n+#define va_start(__AP, __LASTARG) \\\n+  (__AP = (__gnuc_va_list) __builtin_next_arg (__LASTARG))\n+#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n+#else /* ! _STDARG_H */\n+#define va_alist  __builtin_va_alist\n+#ifdef __mips64\n+/* This assumes that `long long int' is always a 64 bit type.  */\n+#define va_dcl    long long int __builtin_va_alist; __va_ellipsis\n+#else\n+#define va_dcl    int __builtin_va_alist; __va_ellipsis\n+#endif\n+#if defined (__mips_eabi) && ! defined (__mips_soft_float)\n+#define va_start(__AP)\t\t\t\t\t\t\t\\\n+  (__AP.__gp_regs = ((char *) __builtin_next_arg ()\t\t\t\\\n+\t\t     - (__builtin_args_info (2) < 8\t\t\t\\\n+\t\t\t? (8 - __builtin_args_info (2)) * __va_reg_size\t\\\n+\t\t\t: 8)),\t\t\t\t\t\t\\\n+   __AP.__fp_left = 8 - __builtin_args_info (3),\t\t\t\\\n+   __AP.__fp_regs = __AP.__gp_regs - __AP.__fp_left * __va_reg_size)\n+/* Need alternate code for _MIPS_SIM_ABI64.  */\n+#elif defined(_MIPS_SIM) && (_MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32)\n+#define va_start(__AP)\t\t\t\t\t\t\t\\\n+  (__AP = (__gnuc_va_list) __builtin_next_arg ()\t\t\t\\\n+   + (__builtin_args_info (2) >= 8 ? -8 : 0))\n+#else\n+#define va_start(__AP)  __AP = (char *) &__builtin_va_alist\n+#endif\n+#endif /* ! _STDARG_H */\n+\n+#ifndef va_end\n+void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n+#endif\n+#define va_end(__AP)\t((void)0)\n+\n+#if defined (__mips_eabi) && ! defined (__mips_soft_float)\n+\n+#ifdef __mips64\n+#define __va_next_addr(__AP, __type)\t\t\t\t\t\\\n+  ((__builtin_classify_type (*(__type *) 0) == __real_type_class\t\\\n+    && __AP.__fp_left > 0)\t\t\t\t\t\t\\\n+   ? (--__AP.__fp_left, (__AP.__fp_regs += 8) - 8)\t\t\t\\\n+   : (__AP.__gp_regs += __va_reg_size) - __va_reg_size)\n+#else\n+#define __va_next_addr(__AP, __type)\t\t\t\t\t\\\n+  ((__builtin_classify_type (*(__type *) 0) == __real_type_class\t\\\n+    && __AP.__fp_left > 0)\t\t\t\t\t\t\\\n+   ? (--__AP.__fp_left, (__AP.__fp_regs += 8) - 8)\t\t\t\\\n+   : (((__builtin_classify_type (* (__type *) 0) < record_type_class\t\\\n+\t&& __alignof__ (__type) > 4)\t\t\t\t\t\\\n+       ? __AP.__gp_regs = (__AP.__gp_regs + 8 - 1) & -8),\t\t\\\n+      (__AP.__gp_regs += __va_reg_size) - __va_reg_size))\n+#endif\n+\n+#ifdef __MIPSEB__\n+#define va_arg(__AP, __type)\t\t\t\t\t\t\\\n+  ((__va_rounded_size (__type) <= __va_reg_size)\t\t\t\\\n+   ? *(__type *) (void *) (__va_next_addr (__AP, __type)\t\t\\\n+\t\t\t   + __va_reg_size\t\t\t\t\\\n+\t\t\t   - sizeof (__type))\t\t\t\t\\\n+   : (__builtin_classify_type (*(__type *) 0) >= __record_type_class\t\\\n+      ? **(__type **) (void *) (__va_next_addr (__AP, __type)\t\t\\\n+\t\t\t\t+ __va_reg_size\t\t\t\t\\\n+\t\t\t\t- sizeof (char *))\t\t\t\\\n+      : *(__type *) (void *) __va_next_addr (__AP, __type)))\n+#else\n+#define va_arg(__AP, __type)\t\t\t\t\t\t\\\n+  (__builtin_classify_type (* (__type *) 0) >= __record_type_class\t\\\n+   ? **(__type **) (void *) __va_next_addr (__AP, __type)\t\t\\\n+   : *(__type *) (void *) __va_next_addr (__AP, __type))\n+#endif\n+\n+#else /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n+\n+/* We cast to void * and then to TYPE * because this avoids\n+   a warning about increasing the alignment requirement.  */\n+/* The __mips64 cases are reversed from the 32 bit cases, because the standard\n+   32 bit calling convention left-aligns all parameters smaller than a word,\n+   whereas the __mips64 calling convention does not (and hence they are\n+   right aligned).  */\n+#ifdef __mips64\n+#ifdef __MIPSEB__\n+#define va_arg(__AP, __type)                                    \\\n+  ((__type *) (void *) (__AP = (char *) ((((__PTRDIFF_TYPE__)__AP + 8 - 1) & -8) \\\n+\t\t\t\t\t + __va_rounded_size (__type))))[-1]\n+#else\n+#define va_arg(__AP, __type)                                    \\\n+  ((__AP = (char *) ((((__PTRDIFF_TYPE__)__AP + 8 - 1) & -8)\t\\\n+\t\t     + __va_rounded_size (__type))),\t\t\\\n+   *(__type *) (void *) (__AP - __va_rounded_size (__type)))\n+#endif\n+\n+#else /* not __mips64 */\n+\n+#ifdef __MIPSEB__\n+/* For big-endian machines.  */\n+#define va_arg(__AP, __type)\t\t\t\t\t\\\n+  ((__AP = (char *) ((__alignof__ (__type) > 4\t\t\t\\\n+\t\t      ? ((int)__AP + 8 - 1) & -8\t\t\\\n+\t\t      : ((int)__AP + 4 - 1) & -4)\t\t\\\n+\t\t     + __va_rounded_size (__type))),\t\t\\\n+   *(__type *) (void *) (__AP - __va_rounded_size (__type)))\n+#else\n+/* For little-endian machines.  */\n+#define va_arg(__AP, __type)\t\t\t\t\t\t    \\\n+  ((__type *) (void *) (__AP = (char *) ((__alignof__(__type) > 4\t    \\\n+\t\t\t\t\t  ? ((int)__AP + 8 - 1) & -8\t    \\\n+\t\t\t\t\t  : ((int)__AP + 4 - 1) & -4)\t    \\\n+\t\t\t\t\t + __va_rounded_size(__type))))[-1]\n+#endif\n+#endif\n+#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n+\n+#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}]}