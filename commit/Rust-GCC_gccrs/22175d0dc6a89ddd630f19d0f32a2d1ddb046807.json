{"sha": "22175d0dc6a89ddd630f19d0f32a2d1ddb046807", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIxNzVkMGRjNmE4OWRkZDYzMGYxOWQwZjMyYTJkMWRkYjA0NjgwNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-05T11:34:42Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-06T14:00:37Z"}, "message": "tree-optimization/97706 - handle PHIs in pattern recog mask precison\n\nThis adds handling of PHIs to mask precision compute which is\neventually needed to detect a bool pattern when the def chain\ncontains such a PHI node.\n\n2020-11-06  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97706\n\t* tree-vect-patterns.c (possible_vector_mask_operation_p):\n\tPHIs are possible mask operations.\n\t(vect_determine_mask_precision): Handle PHIs.\n\t(vect_determine_precisions): Walk PHIs in BB analysis.\n\n\t* gcc.dg/vect/bb-slp-pr97706.c: New testcase.", "tree": {"sha": "aed64ec1f9738c46975c3ab1d927346e2b4b9bfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aed64ec1f9738c46975c3ab1d927346e2b4b9bfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22175d0dc6a89ddd630f19d0f32a2d1ddb046807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22175d0dc6a89ddd630f19d0f32a2d1ddb046807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22175d0dc6a89ddd630f19d0f32a2d1ddb046807", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22175d0dc6a89ddd630f19d0f32a2d1ddb046807/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1db815f4f38be2028ab386b2a5e5e43a88280d21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1db815f4f38be2028ab386b2a5e5e43a88280d21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1db815f4f38be2028ab386b2a5e5e43a88280d21"}], "stats": {"total": 170, "additions": 135, "deletions": 35}, "files": [{"sha": "228ae700e8c3736dd37a445ed33fab618d1ab6a1", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr97706.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22175d0dc6a89ddd630f19d0f32a2d1ddb046807/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr97706.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22175d0dc6a89ddd630f19d0f32a2d1ddb046807/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr97706.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr97706.c?ref=22175d0dc6a89ddd630f19d0f32a2d1ddb046807", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile } */\n+\n+_Bool arr[16];\n+void bar();\n+void foo(int n, char *p)\n+{\n+  _Bool b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;\n+  do\n+    {\n+      b0 = p[0] != 0;\n+      b1 = p[1] != 0;\n+      b2 = p[2] != 0;\n+      b3 = p[3] != 0;\n+      b4 = p[4] != 0;\n+      b5 = p[5] != 0;\n+      b6 = p[6] != 0;\n+      b7 = p[7] != 0;\n+      b8 = p[8] != 0;\n+      b9 = p[9] != 0;\n+      b10 = p[10] != 0;\n+      b11 = p[11] != 0;\n+      b12 = p[12] != 0;\n+      b13 = p[13] != 0;\n+      b14 = p[14] != 0;\n+      b15 = p[15] != 0;\n+      arr[0] = b0;\n+      arr[1] = b1;\n+      arr[2] = b2;\n+      arr[3] = b3;\n+      arr[4] = b4;\n+      arr[5] = b5;\n+      arr[6] = b6;\n+      arr[7] = b7;\n+      arr[8] = b8;\n+      arr[9] = b9;\n+      arr[10] = b10;\n+      arr[11] = b11;\n+      arr[12] = b12;\n+      arr[13] = b13;\n+      arr[14] = b14;\n+      arr[15] = b15;\n+      bar ();\n+    }\n+  while (--n);\n+  arr[0] = b0;\n+  arr[1] = b1;\n+  arr[2] = b2;\n+  arr[3] = b3;\n+  arr[4] = b4;\n+  arr[5] = b5;\n+  arr[6] = b6;\n+  arr[7] = b7;\n+  arr[8] = b8;\n+  arr[9] = b9;\n+  arr[10] = b10;\n+  arr[11] = b11;\n+  arr[12] = b12;\n+  arr[13] = b13;\n+  arr[14] = b14;\n+  arr[15] = b15;\n+}"}, {"sha": "eefa7cf6799a7d846303aa6274d28bcc0a841158", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 74, "deletions": 35, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22175d0dc6a89ddd630f19d0f32a2d1ddb046807/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22175d0dc6a89ddd630f19d0f32a2d1ddb046807/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=22175d0dc6a89ddd630f19d0f32a2d1ddb046807", "patch": "@@ -5007,6 +5007,8 @@ possible_vector_mask_operation_p (stmt_vec_info stmt_info)\n \t  return TREE_CODE_CLASS (rhs_code) == tcc_comparison;\n \t}\n     }\n+  else if (is_a <gphi *> (stmt_info->stmt))\n+    return true;\n   return false;\n }\n \n@@ -5049,41 +5051,63 @@ vect_determine_mask_precision (vec_info *vinfo, stmt_vec_info stmt_info)\n      The number of operations are equal, but M16 would have given\n      a shorter dependency chain and allowed more ILP.  */\n   unsigned int precision = ~0U;\n-  gassign *assign = as_a <gassign *> (stmt_info->stmt);\n-  unsigned int nops = gimple_num_ops (assign);\n-  for (unsigned int i = 1; i < nops; ++i)\n+  if (gassign *assign = dyn_cast <gassign *> (stmt_info->stmt))\n     {\n-      tree rhs = gimple_op (assign, i);\n-      if (!VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (rhs)))\n-\tcontinue;\n+      unsigned int nops = gimple_num_ops (assign);\n+      for (unsigned int i = 1; i < nops; ++i)\n+\t{\n+\t  tree rhs = gimple_op (assign, i);\n+\t  if (!VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (rhs)))\n+\t    continue;\n \n-      stmt_vec_info def_stmt_info = vinfo->lookup_def (rhs);\n-      if (!def_stmt_info)\n-\t/* Don't let external or constant operands influence the choice.\n-\t   We can convert them to whichever vector type we pick.  */\n-\tcontinue;\n+\t  stmt_vec_info def_stmt_info = vinfo->lookup_def (rhs);\n+\t  if (!def_stmt_info)\n+\t    /* Don't let external or constant operands influence the choice.\n+\t       We can convert them to whichever vector type we pick.  */\n+\t    continue;\n+\n+\t  if (def_stmt_info->mask_precision)\n+\t    {\n+\t      if (precision > def_stmt_info->mask_precision)\n+\t\tprecision = def_stmt_info->mask_precision;\n+\t    }\n+\t}\n \n-      if (def_stmt_info->mask_precision)\n+      /* If the statement compares two values that shouldn't use vector masks,\n+\t try comparing the values as normal scalars instead.  */\n+      tree_code rhs_code = gimple_assign_rhs_code (assign);\n+      if (precision == ~0U\n+\t  && TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n \t{\n-\t  if (precision > def_stmt_info->mask_precision)\n-\t    precision = def_stmt_info->mask_precision;\n+\t  tree rhs1_type = TREE_TYPE (gimple_assign_rhs1 (assign));\n+\t  scalar_mode mode;\n+\t  tree vectype, mask_type;\n+\t  if (is_a <scalar_mode> (TYPE_MODE (rhs1_type), &mode)\n+\t      && (vectype = get_vectype_for_scalar_type (vinfo, rhs1_type))\n+\t      && (mask_type = get_mask_type_for_scalar_type (vinfo, rhs1_type))\n+\t      && expand_vec_cmp_expr_p (vectype, mask_type, rhs_code))\n+\t    precision = GET_MODE_BITSIZE (mode);\n \t}\n     }\n-\n-  /* If the statement compares two values that shouldn't use vector masks,\n-     try comparing the values as normal scalars instead.  */\n-  tree_code rhs_code = gimple_assign_rhs_code (assign);\n-  if (precision == ~0U\n-      && TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n+  else\n     {\n-      tree rhs1_type = TREE_TYPE (gimple_assign_rhs1 (assign));\n-      scalar_mode mode;\n-      tree vectype, mask_type;\n-      if (is_a <scalar_mode> (TYPE_MODE (rhs1_type), &mode)\n-\t  && (vectype = get_vectype_for_scalar_type (vinfo, rhs1_type))\n-\t  && (mask_type = get_mask_type_for_scalar_type (vinfo, rhs1_type))\n-\t  && expand_vec_cmp_expr_p (vectype, mask_type, rhs_code))\n-\tprecision = GET_MODE_BITSIZE (mode);\n+      gphi *phi = as_a <gphi *> (stmt_info->stmt);\n+      for (unsigned i = 0; i < gimple_phi_num_args (phi); ++i)\n+\t{\n+\t  tree rhs = gimple_phi_arg_def (phi, i);\n+\n+\t  stmt_vec_info def_stmt_info = vinfo->lookup_def (rhs);\n+\t  if (!def_stmt_info)\n+\t    /* Don't let external or constant operands influence the choice.\n+\t       We can convert them to whichever vector type we pick.  */\n+\t    continue;\n+\n+\t  if (def_stmt_info->mask_precision)\n+\t    {\n+\t      if (precision > def_stmt_info->mask_precision)\n+\t\tprecision = def_stmt_info->mask_precision;\n+\t    }\n+\t}\n     }\n \n   if (dump_enabled_p ())\n@@ -5164,15 +5188,30 @@ vect_determine_precisions (vec_info *vinfo)\n \t      if (stmt_info && STMT_VINFO_VECTORIZABLE (stmt_info))\n \t\tvect_determine_mask_precision (vinfo, stmt_info);\n \t    }\n+\t  for (auto gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      stmt_vec_info stmt_info = vinfo->lookup_stmt (gsi.phi ());\n+\t      if (stmt_info && STMT_VINFO_VECTORIZABLE (stmt_info))\n+\t\tvect_determine_mask_precision (vinfo, stmt_info);\n+\t    }\n \t}\n       for (int i = bb_vinfo->bbs.length () - 1; i != -1; --i)\n-\tfor (gimple_stmt_iterator gsi = gsi_last_bb (bb_vinfo->bbs[i]);\n-\t     !gsi_end_p (gsi); gsi_prev (&gsi))\n-\t  {\n-\t    stmt_vec_info stmt_info = vinfo->lookup_stmt (gsi_stmt (gsi));\n-\t    if (stmt_info && STMT_VINFO_VECTORIZABLE (stmt_info))\n-\t      vect_determine_stmt_precisions (vinfo, stmt_info);\n-\t  }\n+\t{\n+\t  for (gimple_stmt_iterator gsi = gsi_last_bb (bb_vinfo->bbs[i]);\n+\t       !gsi_end_p (gsi); gsi_prev (&gsi))\n+\t    {\n+\t      stmt_vec_info stmt_info = vinfo->lookup_stmt (gsi_stmt (gsi));\n+\t      if (stmt_info && STMT_VINFO_VECTORIZABLE (stmt_info))\n+\t\tvect_determine_stmt_precisions (vinfo, stmt_info);\n+\t    }\n+\t  for (auto gsi = gsi_start_phis (bb_vinfo->bbs[i]);\n+\t       !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      stmt_vec_info stmt_info = vinfo->lookup_stmt (gsi.phi ());\n+\t      if (stmt_info && STMT_VINFO_VECTORIZABLE (stmt_info))\n+\t\tvect_determine_stmt_precisions (vinfo, stmt_info);\n+\t    }\n+\t}\n     }\n }\n "}]}