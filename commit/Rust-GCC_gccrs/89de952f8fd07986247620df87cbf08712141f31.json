{"sha": "89de952f8fd07986247620df87cbf08712141f31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlkZTk1MmY4ZmQwNzk4NjI0NzYyMGRmODdjYmYwODcxMjE0MWYzMQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-11-03T01:11:03Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-11-03T01:11:03Z"}, "message": "configure: Rebuilt.\n\n\t* configure: Rebuilt.\n\t* configure.in: Don't create boehm-config.h.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (libgcjgc_la_SOURCES): Reference gcconfig.h, not\n\tconfig.h.\n\t($(all_objs)): Depend on gcconfig.h.\n\t* gc_priv.h: Reference GCCONFIG_H, not CONFIG_H.\n\t* gcconfig.h: Define GCCONFIG_H, not CONFIG_H.\n\t* config.h: Removed.\n\nFrom-SVN: r30358", "tree": {"sha": "876c7fff5693520a285274c0cfcfb8580e9d84f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/876c7fff5693520a285274c0cfcfb8580e9d84f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89de952f8fd07986247620df87cbf08712141f31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89de952f8fd07986247620df87cbf08712141f31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89de952f8fd07986247620df87cbf08712141f31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89de952f8fd07986247620df87cbf08712141f31/comments", "author": null, "committer": null, "parents": [{"sha": "925fa22749429efecfea554835a596f04caf7a6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/925fa22749429efecfea554835a596f04caf7a6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/925fa22749429efecfea554835a596f04caf7a6a"}], "stats": {"total": 1078, "additions": 19, "deletions": 1059}, "files": [{"sha": "4f39062df30f72d1236b4ce15b44992a10684463", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=89de952f8fd07986247620df87cbf08712141f31", "patch": "@@ -1,3 +1,15 @@\n+1999-11-02  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* configure: Rebuilt.\n+\t* configure.in: Don't create boehm-config.h.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (libgcjgc_la_SOURCES): Reference gcconfig.h, not\n+\tconfig.h.\n+\t($(all_objs)): Depend on gcconfig.h.\n+\t* gc_priv.h: Reference GCCONFIG_H, not CONFIG_H.\n+\t* gcconfig.h: Define GCCONFIG_H, not CONFIG_H.\n+\t* config.h: Removed.\n+\n 1999-11-01  Tom Tromey  <tromey@cygnus.com>\n \n \t* Makefile.in: Rebuilt."}, {"sha": "be15848ac9dd202154dec28be2ab29a44204dacb", "filename": "boehm-gc/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.am?ref=89de952f8fd07986247620df87cbf08712141f31", "patch": "@@ -26,7 +26,7 @@ endif\n toolexeclib_LTLIBRARIES = $(target_all)\n EXTRA_LTLIBRARIES = libgcjgc.la\n libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c\t\\\n-config.h dbg_mlc.c dyn_load.c finalize.c gc.h gc_alloc.h gc_cpp.h \\\n+gcconfig.h dbg_mlc.c dyn_load.c finalize.c gc.h gc_alloc.h gc_cpp.h \\\n gc_hdrs.h gc_mark.h gc_priv.h gc_private.h gc_typed.h headers.c\t\\\n irix_threads.c linux_threads.c malloc.c mallocx.c mark.c mark_rts.c \\\n misc.c new_hblk.c obj_map.c os_dep.c pcr_interface.c ptr_chck.c\t\\\n@@ -52,7 +52,7 @@ TESTS = gctest\n \n ## FIXME: relies on internal code generated by automake.\n all_objs = @addobjs@ $(libgcjgc_la_OBJECTS)\n-$(all_objs) : config.h gc_priv.h gc_hdrs.h gc.h gc_mark.h\n+$(all_objs) : gcconfig.h gc_priv.h gc_hdrs.h gc.h gc_mark.h\n \n ## FIXME: we shouldn't have to do this, but automake forces us to.\n .s.lo:"}, {"sha": "08686c74c508d49829e2211be76fbf6855096ebd", "filename": "boehm-gc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.in?ref=89de952f8fd07986247620df87cbf08712141f31", "patch": "@@ -109,7 +109,7 @@ MULTICLEAN = true\n toolexeclib_LTLIBRARIES = $(target_all)\n EXTRA_LTLIBRARIES = libgcjgc.la\n libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c\t\\\n-config.h dbg_mlc.c dyn_load.c finalize.c gc.h gc_alloc.h gc_cpp.h \\\n+gcconfig.h dbg_mlc.c dyn_load.c finalize.c gc.h gc_alloc.h gc_cpp.h \\\n gc_hdrs.h gc_mark.h gc_priv.h gc_private.h gc_typed.h headers.c\t\\\n irix_threads.c linux_threads.c malloc.c mallocx.c mark.c mark_rts.c \\\n misc.c new_hblk.c obj_map.c os_dep.c pcr_interface.c ptr_chck.c\t\\\n@@ -513,7 +513,7 @@ install-am install uninstall-am uninstall all-redirect all-am all \\\n installdirs mostlyclean-generic distclean-generic clean-generic \\\n maintainer-clean-generic clean mostlyclean distclean maintainer-clean\n \n-$(all_objs) : config.h gc_priv.h gc_hdrs.h gc.h gc_mark.h\n+$(all_objs) : gcconfig.h gc_priv.h gc_hdrs.h gc.h gc_mark.h\n \n .s.lo:\n \t$(LTCOMPILE) -Wp,-P -x assembler-with-cpp -c $<"}, {"sha": "d3370ba6c1440ae02a01c9acf25edf97e243aa8b", "filename": "boehm-gc/config.h", "status": "removed", "additions": 0, "deletions": 999, "changes": 999, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/925fa22749429efecfea554835a596f04caf7a6a/boehm-gc%2Fconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/925fa22749429efecfea554835a596f04caf7a6a/boehm-gc%2Fconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfig.h?ref=925fa22749429efecfea554835a596f04caf7a6a", "patch": "@@ -1,999 +0,0 @@\n-/* \n- * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n- * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n- \n-#ifndef CONFIG_H\n-\n-# define CONFIG_H\n-\n-/* Machine dependent parameters.  Some tuning parameters can be found\t*/\n-/* near the top of gc_private.h.\t\t\t\t\t*/\n-\n-/* Machine specific parts contributed by various people.  See README file. */\n-\n-/* Determine the machine type: */\n-# if defined(sun) && defined(mc68000)\n-#    define M68K\n-#    define SUNOS4\n-#    define mach_type_known\n-# endif\n-# if defined(hp9000s300)\n-#    define M68K\n-#    define HP\n-#    define mach_type_known\n-# endif\n-# if defined(__NetBSD__) && defined(m68k)\n-#    define M68K\n-#    define NETBSD\n-#    define mach_type_known\n-# endif\n-# if defined(vax)\n-#    define VAX\n-#    ifdef ultrix\n-#\tdefine ULTRIX\n-#    else\n-#\tdefine BSD\n-#    endif\n-#    define mach_type_known\n-# endif\n-# if defined(mips) || defined(__mips)\n-#    define MIPS\n-#    if defined(ultrix) || defined(__ultrix) || defined(__NetBSD__)\n-#\tdefine ULTRIX\n-#    else\n-#\tif defined(_SYSTYPE_SVR4) || defined(SYSTYPE_SVR4) || defined(__SYSTYPE_SVR4__)\n-#\t  define IRIX5   /* or IRIX 6.X */\n-#\telse\n-#\t  define RISCOS  /* or IRIX 4.X */\n-#\tendif\n-#    endif\n-#    define mach_type_known\n-# endif\n-# if defined(sequent) && defined(i386)\n-#    define I386\n-#    define SEQUENT\n-#    define mach_type_known\n-# endif\n-# if defined(sun) && defined(i386)\n-#    define I386\n-#    define SUNOS5\n-#    define mach_type_known\n-# endif\n-# if (defined(__OS2__) || defined(__EMX__)) && defined(__32BIT__)\n-#    define I386\n-#    define OS2\n-#    define mach_type_known\n-# endif\n-# if defined(ibm032)\n-#   define RT\n-#   define mach_type_known\n-# endif\n-# if defined(sun) && (defined(sparc) || defined(__sparc))\n-#   define SPARC\n-    /* Test for SunOS 5.x */\n-#     include <errno.h>\n-#     ifdef ECHRNG\n-#       define SUNOS5\n-#     else\n-#\tdefine SUNOS4\n-#     endif\n-#   define mach_type_known\n-# endif\n-# if defined(sparc) && defined(unix) && !defined(sun)\n-#   define SPARC\n-#   define DRSNX\n-#   define mach_type_known\n-# endif\n-# if defined(_IBMR2)\n-#   define RS6000\n-#   define mach_type_known\n-# endif\n-# if defined(_M_XENIX) && defined(_M_SYSV) && defined(_M_I386)\n-\t/* The above test may need refinement\t*/\n-#   define I386\n-#   if defined(_SCO_ELF)\n-#     define SCO_ELF\n-#   else\n-#     define SCO\n-#   endif\n-#   define mach_type_known\n-# endif\n-# if defined(_AUX_SOURCE)\n-#   define M68K\n-#   define SYSV\n-#   define mach_type_known\n-# endif\n-# if defined(_PA_RISC1_0) || defined(_PA_RISC1_1)\n-#   define HP_PA\n-#   define mach_type_known\n-# endif\n-# if defined(linux) && defined(i386)\n-#    define I386\n-#    define LINUX\n-#    define mach_type_known\n-# endif\n-# if defined(linux) && defined(powerpc)\n-#    define POWERPC\n-#    define LINUX\n-#    define mach_type_known\n-# endif\n-# if defined(__alpha) || defined(__alpha__)\n-#   define ALPHA\n-#   if defined(linux) || defined(__linux__)\n-#     define LINUX\n-#   else\n-#     define OSF1\t/* a.k.a Digital Unix */\n-#   endif\n-#   define mach_type_known\n-# endif\n-# if defined(_AMIGA)\n-#   define M68K\n-#   define AMIGA\n-#   define mach_type_known\n-# endif\n-# if defined(THINK_C) || defined(__MWERKS__) && !defined(__powerc)\n-#   define M68K\n-#   define MACOS\n-#   define mach_type_known\n-# endif\n-# if defined(__MWERKS__) && defined(__powerc)\n-#   define POWERPC\n-#   define MACOS\n-#   define mach_type_known\n-# endif\n-# if defined(NeXT) && defined(mc68000)\n-#   define M68K\n-#   define NEXT\n-#   define mach_type_known\n-# endif\n-# if defined(NeXT) && defined(i386)\n-#   define I386\n-#   define NEXT\n-#   define mach_type_known\n-# endif\n-# if defined(__FreeBSD__) && defined(i386)\n-#   define I386\n-#   define FREEBSD\n-#   define mach_type_known\n-# endif\n-# if defined(__NetBSD__) && defined(i386)\n-#   define I386\n-#   define NETBSD\n-#   define mach_type_known\n-# endif\n-# if defined(bsdi) && defined(i386)\n-#    define I386\n-#    define BSDI\n-#    define mach_type_known\n-# endif\n-# if !defined(mach_type_known) && defined(__386BSD__)\n-#   define I386\n-#   define THREE86BSD\n-#   define mach_type_known\n-# endif\n-# if defined(_CX_UX) && defined(_M88K)\n-#   define M88K\n-#   define CX_UX\n-#   define mach_type_known\n-# endif\n-# if defined(DGUX)\n-#   define M88K\n-    /* DGUX defined */\n-#   define mach_type_known\n-# endif\n-# if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300)\n-#   define I386\n-#   define MSWIN32\t/* or Win32s */\n-#   define mach_type_known\n-# endif\n-# if defined(__DJGPP__)\n-#   define I386\n-#   ifndef DJGPP\n-#     define DJGPP  /* MSDOS running the DJGPP port of GCC */\n-#   endif\n-#   define mach_type_known\n-# endif\n-# if defined(__CYGWIN32__)\n-#   define I386\n-#   define CYGWIN32\n-#   define mach_type_known\n-# endif\n-# if defined(__BORLANDC__)\n-#   define I386\n-#   define MSWIN32\n-#   define mach_type_known\n-# endif\n-# if defined(_UTS) && !defined(mach_type_known)\n-#   define S370\n-#   define UTS4\n-#   define mach_type_known\n-# endif\n-/* Ivan Demakov */\n-# if defined(__WATCOMC__) && defined(__386__)\n-#   define I386\n-#   if !defined(OS2) && !defined(MSWIN32) && !defined(DOS4GW)\n-#     if defined(__OS2__)\n-#       define OS2\n-#     else\n-#       if defined(__WINDOWS_386__) || defined(__NT__)\n-#         define MSWIN32\n-#       else\n-#         define DOS4GW\n-#       endif\n-#     endif\n-#   endif\n-#   define mach_type_known\n-# endif\n-# if defined(__pj__)\n-#   define PJ\n-#   define mach_type_known\n-# endif\n-\n-/* Feel free to add more clauses here */\n-\n-/* Or manually define the machine type here.  A machine type is \t*/\n-/* characterized by the architecture.  Some\t\t\t\t*/\n-/* machine types are further subdivided by OS.\t\t\t\t*/\n-/* the macros ULTRIX, RISCOS, and BSD to distinguish.\t\t\t*/\n-/* Note that SGI IRIX is treated identically to RISCOS.\t\t\t*/\n-/* SYSV on an M68K actually means A/UX.\t\t\t\t\t*/\n-/* The distinction in these cases is usually the stack starting address */\n-# ifndef mach_type_known\n-\t--> unknown machine type\n-# endif\n-\t\t    /* Mapping is: M68K       ==> Motorola 680X0\t*/\n-\t\t    /*\t\t   (SUNOS4,HP,NEXT, and SYSV (A/UX),\t*/\n-\t\t    /*\t\t   MACOS and AMIGA variants)\t\t*/\n-\t\t    /*             I386       ==> Intel 386\t \t*/\n-\t\t    /*\t\t    (SEQUENT, OS2, SCO, LINUX, NETBSD,\t*/\n-\t\t    /*\t\t     FREEBSD, THREE86BSD, MSWIN32,\t*/\n-\t\t    /* \t\t     BSDI, SUNOS5, NEXT\tvariants)\t*/\n-                    /*             NS32K      ==> Encore Multimax \t*/\n-                    /*             MIPS       ==> R2000 or R3000\t*/\n-                    /*\t\t\t(RISCOS, ULTRIX variants)\t*/\n-                    /*\t\t   VAX\t      ==> DEC VAX\t\t*/\n-                    /*\t\t\t(BSD, ULTRIX variants)\t\t*/\n-                    /*\t\t   RS6000     ==> IBM RS/6000 AIX3.X\t*/\n-                    /*\t\t   RT\t      ==> IBM PC/RT\t\t*/\n-                    /*\t\t   HP_PA      ==> HP9000/700 & /800\t*/\n-                    /*\t\t\t\t  HP/UX\t\t\t*/\n-\t\t    /*\t\t   SPARC      ==> SPARC under SunOS\t*/\n-\t\t    /*\t\t\t(SUNOS4, SUNOS5,\t\t*/\n-\t\t    /*\t\t\t DRSNX variants)\t\t*/\n-\t\t    /* \t\t   ALPHA      ==> DEC Alpha \t\t*/\n-\t\t    /*\t\t\t(OSF1 and LINUX variants)\t*/\n-\t\t    /* \t\t   M88K       ==> Motorola 88XX0        */\n-\t\t    /* \t\t        (CX_UX and DGUX)\t\t*/\n-\t\t    /* \t\t   S370\t      ==> 370-like machine\t*/\n-\t\t    /* \t\t\trunning Amdahl UTS4\t\t*/\n-\n-\n-/*\n- * For each architecture and OS, the following need to be defined:\n- *\n- * CPP_WORD_SZ is a simple integer constant representing the word size.\n- * in bits.  We assume byte addressibility, where a byte has 8 bits.\n- * We also assume CPP_WORD_SZ is either 32 or 64.\n- * (We care about the length of pointers, not hardware\n- * bus widths.  Thus a 64 bit processor with a C compiler that uses\n- * 32 bit pointers should use CPP_WORD_SZ of 32, not 64. Default is 32.)\n- *\n- * MACH_TYPE is a string representation of the machine type.\n- * OS_TYPE is analogous for the OS.\n- *\n- * ALIGNMENT is the largest N, such that\n- * all pointer are guaranteed to be aligned on N byte boundaries.\n- * defining it to be 1 will always work, but perform poorly.\n- *\n- * DATASTART is the beginning of the data segment.\n- * On UNIX systems, the collector will scan the area between DATASTART\n- * and DATAEND for root pointers.\n- *\n- * DATAEND, if not &end.\n- *\n- * ALIGN_DOUBLE of GC_malloc should return blocks aligned to twice\n- * the pointer size.\n- *\n- * STACKBOTTOM is the cool end of the stack, which is usually the\n- * highest address in the stack.\n- * Under PCR or OS/2, we have other ways of finding thread stacks.\n- * For each machine, the following should:\n- * 1) define STACK_GROWS_UP if the stack grows toward higher addresses, and\n- * 2) define exactly one of\n- *\tSTACKBOTTOM (should be defined to be an expression)\n- *\tHEURISTIC1\n- *\tHEURISTIC2\n- * If either of the last two macros are defined, then STACKBOTTOM is computed\n- * during collector startup using one of the following two heuristics:\n- * HEURISTIC1:  Take an address inside GC_init's frame, and round it up to\n- *\t\tthe next multiple of STACK_GRAN.\n- * HEURISTIC2:  Take an address inside GC_init's frame, increment it repeatedly\n- *\t\tin small steps (decrement if STACK_GROWS_UP), and read the value\n- *\t\tat each location.  Remember the value when the first\n- *\t\tSegmentation violation or Bus error is signalled.  Round that\n- *\t\tto the nearest plausible page boundary, and use that instead\n- *\t\tof STACKBOTTOM.\n- *\n- * If no expression for STACKBOTTOM can be found, and neither of the above\n- * heuristics are usable, the collector can still be used with all of the above\n- * undefined, provided one of the following is done:\n- * 1) GC_mark_roots can be changed to somehow mark from the correct stack(s)\n- *    without reference to STACKBOTTOM.  This is appropriate for use in\n- *    conjunction with thread packages, since there will be multiple stacks.\n- *    (Allocating thread stacks in the heap, and treating them as ordinary\n- *    heap data objects is also possible as a last resort.  However, this is\n- *    likely to introduce significant amounts of excess storage retention\n- *    unless the dead parts of the thread stacks are periodically cleared.)\n- * 2) Client code may set GC_stackbottom before calling any GC_ routines.\n- *    If the author of the client code controls the main program, this is\n- *    easily accomplished by introducing a new main program, setting\n- *    GC_stackbottom to the address of a local variable, and then calling\n- *    the original main program.  The new main program would read something\n- *    like:\n- *\n- *\t\t# include \"gc_private.h\"\n- *\n- *\t\tmain(argc, argv, envp)\n- *\t\tint argc;\n- *\t\tchar **argv, **envp;\n- *\t\t{\n- *\t\t    int dummy;\n- *\n- *\t\t    GC_stackbottom = (ptr_t)(&dummy);\n- *\t\t    return(real_main(argc, argv, envp));\n- *\t\t}\n- *\n- *\n- * Each architecture may also define the style of virtual dirty bit\n- * implementation to be used:\n- *   MPROTECT_VDB: Write protect the heap and catch faults.\n- *   PROC_VDB: Use the SVR4 /proc primitives to read dirty bits.\n- *\n- * An architecture may define DYNAMIC_LOADING if dynamic_load.c\n- * defined GC_register_dynamic_libraries() for the architecture.\n- */\n-\n-\n-# define STACK_GRAN 0x1000000\n-# ifdef M68K\n-#   define MACH_TYPE \"M68K\"\n-#   define ALIGNMENT 2\n-#   ifdef NETBSD\n-#\tdefine OS_TYPE \"NETBSD\"\n-#\tdefine HEURISTIC2\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)(&etext))\n-#   endif\n-#   ifdef SUNOS4\n-#\tdefine OS_TYPE \"SUNOS4\"\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x1ffff) & ~0x1ffff))\n-#\tdefine HEURISTIC1\t/* differs\t*/\n-#\tdefine DYNAMIC_LOADING\n-#   endif\n-#   ifdef HP\n-#\tdefine OS_TYPE \"HP\"\n-\textern char etext;\n-#       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n-#       define STACKBOTTOM ((ptr_t) 0xffeffffc)\n-\t\t\t      /* empirically determined.  seems to work. */\n-#  \tinclude <unistd.h>\n-#\tdefine GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n-#   endif\n-#   ifdef SYSV\n-#\tdefine OS_TYPE \"SYSV\"\n-\textern etext;\n-#   \tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x3fffff) \\\n-\t\t\t\t   & ~0x3fffff) \\\n-\t\t\t\t  +((word)&etext & 0x1fff))\n-\t/* This only works for shared-text binaries with magic number 0413.\n-\t   The other sorts of SysV binaries put the data at the end of the text,\n-\t   in which case the default of &etext would work.  Unfortunately,\n-\t   handling both would require having the magic-number available.\n-\t   \t   \t\t-- Parag\n-\t   */\n-#\tdefine STACKBOTTOM ((ptr_t)0xFFFFFFFE)\n-\t\t\t/* The stack starts at the top of memory, but   */\n-\t\t\t/* 0x0 cannot be used as setjump_test complains */\n-\t\t\t/* that the stack direction is incorrect.  Two  */\n-\t\t\t/* bytes down from 0x0 should be safe enough.   */\n-\t\t\t/* \t\t--Parag\t\t\t\t*/\n-#   \tinclude <sys/mmu.h>\n-#\tdefine GETPAGESIZE() PAGESIZE\t/* Is this still right? */\n-#   endif\n-#   ifdef AMIGA\n-#\tdefine OS_TYPE \"AMIGA\"\n- \t    \t/* STACKBOTTOM and DATASTART handled specially\t*/\n- \t    \t/* in os_dep.c\t\t\t\t\t*/\n-# \tdefine DATAEND\t/* not needed */\n-#\tdefine GETPAGESIZE() 4096\n-#   endif\n-#   ifdef MACOS\n-#     ifndef __LOWMEM__\n-#     include <LowMem.h>\n-#     endif\n-#     define OS_TYPE \"MACOS\"\n-\t\t\t/* see os_dep.c for details of global data segments. */\n-#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())\n-#     define DATAEND\t/* not needed */\n-#     define GETPAGESIZE() 4096\n-#   endif\n-#   ifdef NEXT\n-#\tdefine OS_TYPE \"NEXT\"\n-#\tdefine DATASTART ((ptr_t) get_etext())\n-#\tdefine STACKBOTTOM ((ptr_t) 0x4000000)\n-#\tdefine DATAEND\t/* not needed */\n-#   endif\n-# endif\n-\n-# ifdef POWERPC\n-#   define MACH_TYPE \"POWERPC\"\n-#   define ALIGNMENT 2\n-#   ifdef MACOS\n-#     ifndef __LOWMEM__\n-#     include <LowMem.h>\n-#     endif\n-#     define OS_TYPE \"MACOS\"\n-\t\t\t/* see os_dep.c for details of global data segments. */\n-#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())\n-#     define DATAEND  /* not needed */\n-#   endif\n-#   ifdef LINUX\n-#     define OS_TYPE \"LINUX\"\n-#     define STACKBOTTOM ((ptr_t)0x80000000)\n-#     define DATASTART GC_data_start\n-      extern int _end;\n-#     define DATAEND (&_end)\n-#   endif\n-# endif\n-\n-# ifdef VAX\n-#   define MACH_TYPE \"VAX\"\n-#   define ALIGNMENT 4\t/* Pointers are longword aligned by 4.2 C compiler */\n-    extern char etext;\n-#   define DATASTART ((ptr_t)(&etext))\n-#   ifdef BSD\n-#\tdefine OS_TYPE \"BSD\"\n-#\tdefine HEURISTIC1\n-\t\t\t/* HEURISTIC2 may be OK, but it's hard to test. */\n-#   endif\n-#   ifdef ULTRIX\n-#\tdefine OS_TYPE \"ULTRIX\"\n-#\tdefine STACKBOTTOM ((ptr_t) 0x7fffc800)\n-#   endif\n-# endif\n-\n-# ifdef RT\n-#   define MACH_TYPE \"RT\"\n-#   define ALIGNMENT 4\n-#   define DATASTART ((ptr_t) 0x10000000)\n-#   define STACKBOTTOM ((ptr_t) 0x1fffd800)\n-# endif\n-\n-# ifdef SPARC\n-#   define MACH_TYPE \"SPARC\"\n-#   define ALIGNMENT 4\t/* Required by hardware\t*/\n-#   define ALIGN_DOUBLE\n-    extern int etext;\n-#   ifdef SUNOS5\n-#\tdefine OS_TYPE \"SUNOS5\"\n-\textern int _etext;\n-\textern int _end;\n-\textern char * GC_SysVGetDataStart();\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n-#\tdefine DATAEND (&_end)\n-#\tifndef USE_MMAP\n-#\t    define USE_MMAP\n-#\tendif\n-#       ifdef USE_MMAP\n-#         define HEAP_START (ptr_t)0x40000000\n-#       else\n-#\t  define HEAP_START DATAEND\n-#       endif\n-#\tdefine PROC_VDB\n-#\tdefine HEURISTIC1\n-#\tinclude <unistd.h>\n-#       define GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n-\t\t/* getpagesize() appeared to be missing from at least one */\n-\t\t/* Solaris 5.4 installation.  Weird.\t\t\t  */\n-#   endif\n-#   ifdef SUNOS4\n-#\tdefine OS_TYPE \"SUNOS4\"\n-\t/* [If you have a weak stomach, don't read this.]\t\t*/\n-\t/* We would like to use:\t\t\t\t\t*/\n-/* #       define DATASTART ((ptr_t)((((word) (&etext)) + 0x1fff) & ~0x1fff)) */\n-\t/* This fails occasionally, due to an ancient, but very \t*/\n-\t/* persistent ld bug.  &etext is set 32 bytes too high.\t\t*/\n-\t/* We instead read the text segment size from the a.out\t\t*/\n-\t/* header, which happens to be mapped into our address space\t*/\n-\t/* at the start of the text segment.  The detective work here\t*/\n-\t/* was done by Robert Ehrlich, Manuel Serrano, and Bernard\t*/\n-\t/* Serpette of INRIA.\t\t\t\t\t\t*/\n-\t/* This assumes ZMAGIC, i.e. demand-loadable executables.\t*/\n-#\tdefine TEXTSTART 0x2000\n-#       define DATASTART ((ptr_t)(*(int *)(TEXTSTART+0x4)+TEXTSTART))\n-#\tdefine MPROTECT_VDB\n-#\tdefine HEURISTIC1\n-#   endif\n-#   ifdef DRSNX\n-#       define CPP_WORDSZ 32\n-#\tdefine OS_TYPE \"DRSNX\"\n-\textern char * GC_SysVGetDataStart();\n-\textern int etext;\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &etext)\n-#\tdefine MPROTECT_VDB\n-#       define STACKBOTTOM ((ptr_t) 0xdfff0000)\n-#   endif\n-#   define DYNAMIC_LOADING\n-# endif\n-\n-# ifdef I386\n-#   define MACH_TYPE \"I386\"\n-#   define ALIGNMENT 4\t/* Appears to hold for all \"32 bit\" compilers\t*/\n-\t\t\t/* except Borland.  The -a4 option fixes \t*/\n-\t\t\t/* Borland.\t\t\t\t\t*/\n-                        /* Ivan Demakov: For Watcom the option is -zp4. */\n-#   ifndef SMALL_CONFIG\n-#     define ALIGN_DOUBLE /* Not strictly necessary, but may give speed   */\n-\t\t\t  /* improvement on Pentiums.\t\t\t  */\n-#   endif\n-#   ifdef SEQUENT\n-#\tdefine OS_TYPE \"SEQUENT\"\n-\textern int etext;\n-#       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n-#       define STACKBOTTOM ((ptr_t) 0x3ffff000) \n-#   endif\n-#   ifdef SUNOS5\n-#\tdefine OS_TYPE \"SUNOS5\"\n-  \textern int etext, _start;\n-  \textern char * GC_SysVGetDataStart();\n-#       define DATASTART GC_SysVGetDataStart(0x1000, &etext)\n-#\tdefine STACKBOTTOM ((ptr_t)(&_start))\n-/** At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */\n-/*#\tdefine PROC_VDB*/\n-#\tdefine DYNAMIC_LOADING\n-#\tifndef USE_MMAP\n-#\t    define USE_MMAP\n-#\tendif\n-#       ifdef USE_MMAP\n-#         define HEAP_START (ptr_t)0x40000000\n-#       else\n-#\t  define HEAP_START DATAEND\n-#       endif\n-#   endif\n-#   ifdef SCO\n-#\tdefine OS_TYPE \"SCO\"\n-\textern int etext;\n-#   \tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x3fffff) \\\n-\t\t\t\t  & ~0x3fffff) \\\n-\t\t\t\t +((word)&etext & 0xfff))\n-#\tdefine STACKBOTTOM ((ptr_t) 0x7ffffffc)\n-#   endif\n-#   ifdef SCO_ELF\n-#       define OS_TYPE \"SCO_ELF\"\n-        extern int etext;\n-#       define DATASTART ((ptr_t)(&etext))\n-#       define STACKBOTTOM ((ptr_t) 0x08048000)\n-#       define DYNAMIC_LOADING\n-#\tdefine ELF_CLASS ELFCLASS32\n-#   endif\n-#   ifdef LINUX\n-#\tdefine OS_TYPE \"LINUX\"\n-#\tdefine STACKBOTTOM ((ptr_t)0xc0000000)\n-\t/* Appears to be 0xe0000000 for at least one 2.1.91 kernel.\t*/\n-\t/* Probably needs to be more flexible, but I don't yet \t\t*/\n-\t/* fully understand how flexible.\t\t\t\t*/\n-\n-\t/* Linux threads don't interact well with the read() wrapper.\n-\t   Not defining MPROTECT_VDB fixes this.  */\n-\t/* #\tdefine MPROTECT_VDB*/\n-#       ifdef __ELF__\n-#            define DYNAMIC_LOADING\n-#\t     ifdef UNDEFINED\t/* includes ro data */\n-\t       extern int _etext;\n-#              define DATASTART ((ptr_t)((((word) (&_etext)) + 0xfff) & ~0xfff))\n-#\t     endif\n-#\t     include <linux/version.h>\n-#\t     include <features.h>\n-#\t     if LINUX_VERSION_CODE >= 0x20000 && defined(__GLIBC__) && __GLIBC__ >= 2\n-\t\t extern int __data_start;\n-#\t\t define DATASTART ((ptr_t)(&__data_start))\n-#\t     else\n-     \t         extern char **__environ;\n-#                define DATASTART ((ptr_t)(&__environ))\n-\t\t\t      /* hideous kludge: __environ is the first */\n-\t\t\t      /* word in crt0.o, and delimits the start */\n-\t\t\t      /* of the data segment, no matter which   */\n-\t\t\t      /* ld options were passed through.        */\n-\t\t\t      /* We could use _etext instead, but that  */\n-\t\t\t      /* would include .rodata, which may       */\n-\t\t\t      /* contain large read-only data tables    */\n-\t\t\t      /* that we'd rather not scan.\t\t*/\n-#\t     endif\n-\t     extern int _end;\n-#\t     define DATAEND (&_end)\n-#\telse\n-\t     extern int etext;\n-#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n-#       endif\n-#   endif\n-#   ifdef CYGWIN32\n-          extern int _data_start__;\n-          extern int _data_end__;\n-          extern int _bss_start__;\n-          extern int _bss_end__;\n-  \t/* For binutils 2.9.1, we have\t\t\t*/\n-  \t/*\tDATASTART   = _data_start__\t\t*/\n-  \t/*\tDATAEND\t    = _bss_end__\t\t*/\n-  \t/* whereas for some earlier versions it was\t*/\n-  \t/*\tDATASTART   = _bss_start__\t\t*/\n-  \t/*\tDATAEND\t    = _data_end__\t\t*/\n-  \t/* To get it right for both, we take the\t*/\n-  \t/* minumum/maximum of the two.\t\t\t*/\n-#   \tdefine MAX(x,y) ((x) > (y) ? (x) : (y))\n-#   \tdefine MIN(x,y) ((x) < (y) ? (x) : (y))\n-#       define DATASTART ((ptr_t) MIN(_data_start__, _bss_start__))\n-#       define DATAEND\t ((ptr_t) MAX(_data_end__, _bss_end__))\n-#\tundef STACK_GRAN\n-#       define STACK_GRAN 0x10000\n-#       define HEURISTIC1\n-#   endif\n-#   ifdef OS2\n-#\tdefine OS_TYPE \"OS2\"\n- \t    \t/* STACKBOTTOM and DATASTART are handled specially in \t*/\n-\t\t/* os_dep.c. OS2 actually has the right\t\t\t*/\n-\t\t/* system call!\t\t\t\t\t\t*/\n-#\tdefine DATAEND\t/* not needed */\n-#   endif\n-#   ifdef MSWIN32\n-#\tdefine OS_TYPE \"MSWIN32\"\n-\t\t/* STACKBOTTOM and DATASTART are handled specially in \t*/\n-\t\t/* os_dep.c.\t\t\t\t\t\t*/\n-#       ifndef __WATCOMC__\n-#\t  define MPROTECT_VDB\n-#\tendif\n-#       define DATAEND  /* not needed */\n-#   endif\n-#   ifdef DJGPP\n-#       define OS_TYPE \"DJGPP\"\n-#       include \"stubinfo.h\"\n-        extern int etext;\n-        extern int _stklen;\n-#       define DATASTART ((ptr_t)((((word) (&etext)) + 0x1ff) & ~0x1ff))\n-#       define STACKBOTTOM ((ptr_t)((word) _stubinfo + _stubinfo->size \\\n-                                                     + _stklen))\n-\t\t/* This may not be right.  */\n-#   endif\n-#   ifdef FREEBSD\n-#\tdefine OS_TYPE \"FREEBSD\"\n-#\tdefine MPROTECT_VDB\n-#   endif\n-#   ifdef NETBSD\n-#\tdefine OS_TYPE \"NETBSD\"\n-#   endif\n-#   ifdef THREE86BSD\n-#\tdefine OS_TYPE \"THREE86BSD\"\n-#   endif\n-#   ifdef BSDI\n-#\tdefine OS_TYPE \"BSDI\"\n-#   endif\n-#   if defined(FREEBSD) || defined(NETBSD) \\\n-        || defined(THREE86BSD) || defined(BSDI)\n-#\tdefine HEURISTIC2\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)(&etext))\n-#   endif\n-#   ifdef NEXT\n-#\tdefine OS_TYPE \"NEXT\"\n-#\tdefine DATASTART ((ptr_t) get_etext())\n-#\tdefine STACKBOTTOM ((ptr_t)0xc0000000)\n-#\tdefine DATAEND\t/* not needed */\n-#   endif\n-#   ifdef DOS4GW\n-#     define OS_TYPE \"DOS4GW\"\n-      /* Get_DATASTART, Get_DATAEND, Get_STACKBOTTOM\n-       *      Defined in gc-watcom.asm\n-       */\n-      extern char* Get_DATASTART (void);\n-      extern char* Get_DATAEND (void);\n-      extern char* Get_STACKBOTTOM (void);\n-#     pragma aux Get_DATASTART \"*\" value [eax];\n-#     pragma aux Get_DATAEND \"*\" value [eax];\n-#     pragma aux Get_STACKBOTTOM \"*\" value [eax];\n-#     define DATASTART ((ptr_t) Get_DATASTART())\n-#     define STACKBOTTOM ((ptr_t) Get_STACKBOTTOM())\n-#     define DATAEND ((ptr_t) Get_DATAEND())\n-#   endif\n-# endif\n-\n-# ifdef NS32K\n-#   define MACH_TYPE \"NS32K\"\n-#   define ALIGNMENT 4\n-    extern char **environ;\n-#   define DATASTART ((ptr_t)(&environ))\n-\t\t\t      /* hideous kludge: environ is the first   */\n-\t\t\t      /* word in crt0.o, and delimits the start */\n-\t\t\t      /* of the data segment, no matter which   */\n-\t\t\t      /* ld options were passed through.        */\n-#   define STACKBOTTOM ((ptr_t) 0xfffff000) /* for Encore */\n-# endif\n-\n-# ifdef MIPS\n-# ifndef ECOS\n-#   define MACH_TYPE \"MIPS\"\n-\t/* CYGNUS LOCAL: respect predefined DATASTART_IS_ETEXT.  */\n-#   ifdef DATASTART_IS_ETEXT\n-        extern int _etext;\n-#     define DATASTART ((ptr_t)(&_etext))\n-#   else\n-#     ifndef IRIX5\n-#       define DATASTART (ptr_t)0x10000000\n-\t\t\t      /* Could probably be slightly higher since */\n-\t\t\t      /* startup code allocates lots of stuff.   */\n-#     else\n-        extern int _fdata;\n-#       define DATASTART ((ptr_t)(&_fdata))\n-#       ifdef USE_MMAP\n-#           define HEAP_START (ptr_t)0x30000000\n-#       else\n-#\t    define HEAP_START DATASTART\n-#       endif\n-\t\t\t      /* Lowest plausible heap address.\t\t*/\n-\t\t\t      /* In the MMAP case, we map there.\t*/\n-\t\t\t      /* In either case it is used to identify\t*/\n-\t\t\t      /* heap sections so they're not \t\t*/\n-\t\t\t      /* considered as roots.\t\t\t*/\n-#     endif /* IRIX5 */\n-#   endif /* DATASTART_IS_ETEXT */\n-#   define HEURISTIC2\n-/* #   define STACKBOTTOM ((ptr_t)0x7fff8000)  sometimes also works.  */\n-#   ifdef ULTRIX\n-#\tdefine OS_TYPE \"ULTRIX\"\n-#       define ALIGNMENT 4\n-#   endif\n-#   ifdef RISCOS\n-#\tdefine OS_TYPE \"RISCOS\"\n-#   \tdefine ALIGNMENT 4  /* Required by hardware */\n-#   endif\n-#   ifdef IRIX5\n-#\tdefine OS_TYPE \"IRIX5\"\n-#       define MPROTECT_VDB\n-#       ifdef _MIPS_SZPTR\n-#\t  define CPP_WORDSZ _MIPS_SZPTR\n-#\t  define ALIGNMENT (_MIPS_SZPTR/8)\n-#\t  if CPP_WORDSZ != 64\n-#\t    define ALIGN_DOUBLE\n-#\t  endif\n-#\telse\n-#         define ALIGNMENT 4\n-#\t  define ALIGN_DOUBLE\n-#\tendif\n-#\tdefine DYNAMIC_LOADING\n-#   endif\n-#   endif /* ECOS */\n-# ifdef ECOS\n-    extern char __ram_data_start;\n-    extern char __ram_data_end;\n-#   define MACH_TYPE \"MIPS\"\n-#   define DATASTART (ptr_t)(&__ram_data_start)\n-#   define DATAEND (ptr_t)(&__ram_data_end)\n-\n-#   define HEURISTIC2\n-#   define ALIGNMENT 4\n-#   define ALIGN_DOUBLE\n-#   endif /* ECOS */\n-# endif\n-\n-# ifdef RS6000\n-#   define MACH_TYPE \"RS6000\"\n-#   define ALIGNMENT 4\n-#   define DATASTART ((ptr_t)0x20000000)\n-    extern int errno;\n-#   define STACKBOTTOM ((ptr_t)((ulong)&errno))\n-#   define DYNAMIC_LOADING\n-\t/* For really old versions of AIX, this may have to be removed. */\n-# endif\n-\n-# ifdef HP_PA\n-#   define MACH_TYPE \"HP_PA\"\n-#   define ALIGNMENT 4\n-#   define ALIGN_DOUBLE\n-    extern int __data_start;\n-#   define DATASTART ((ptr_t)(&__data_start))\n-#   if 0\n-\t/* The following appears to work for 7xx systems running HP/UX\t*/\n-\t/* 9.xx Furthermore, it might result in much faster\t\t*/\n-\t/* collections than HEURISTIC2, which may involve scanning\t*/\n-\t/* segments that directly precede the stack.  It is not the\t*/\n-\t/* default, since it may not work on older machine/OS\t\t*/\n-\t/* combinations. (Thanks to Raymond X.T. Nijssen for uncovering\t*/\n-\t/* this.)\t\t\t\t\t\t\t*/\n-#       define STACKBOTTOM ((ptr_t) 0x7b033000)  /* from /etc/conf/h/param.h */\n-#   else\n-#       define HEURISTIC2\n-#   endif\n-#   define STACK_GROWS_UP\n-#   define DYNAMIC_LOADING\n-#   include <unistd.h>\n-#   define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n-\t/* They misspelled the Posix macro?\t*/\n-# endif\n-\n-# ifdef ALPHA\n-#   define MACH_TYPE \"ALPHA\"\n-#   define ALIGNMENT 8\n-#   ifdef OSF1\n-#\tdefine OS_TYPE \"OSF1\"\n-#   \tdefine DATASTART ((ptr_t) 0x140000000)\n-#   \tdefine HEURISTIC2\n-\t/* Normally HEURISTIC2 is too conervative, since\t\t*/\n-\t/* the text segment immediately follows the stack.\t\t*/\n-\t/* Hence we give an upper pound.\t\t\t\t*/\n-    \textern int __start;\n-#   \tdefine HEURISTIC2_LIMIT ((ptr_t)((word)(&__start) & ~(getpagesize()-1)))\n-#   \tdefine CPP_WORDSZ 64\n-#   \tdefine MPROTECT_VDB\n-#   \tdefine DYNAMIC_LOADING\n-#   endif\n-#   ifdef LINUX\n-#       define OS_TYPE \"LINUX\"\n-#       define CPP_WORDSZ 64\n-#       define STACKBOTTOM ((ptr_t) 0x120000000)\n-#       ifdef __ELF__\n-#           define DATASTART GC_data_start\n-#           define USE_PROC\n-#           define DYNAMIC_LOADING\n-#       else\n-#           define DATASTART ((ptr_t) 0x140000000)\n-#       endif\n-\textern int _end;\n-#\tdefine DATAEND (&_end)\n-\t/* As of 1.3.90, I couldn't find a way to retrieve the correct\t*/\n-\t/* fault address from a signal handler.\t\t\t\t*/\n-\t/* Hence MPROTECT_VDB is broken.\t\t\t\t*/\n-#   endif\n-# endif\n-\n-# ifdef M88K\n-#   define MACH_TYPE \"M88K\"\n-#   define ALIGNMENT 4\n-#   define ALIGN_DOUBLE\n-    extern int etext;\n-#   ifdef CX_UX\n-#\tdefine OS_TYPE \"CX_UX\"\n-#       define DATASTART ((((word)&etext + 0x3fffff) & ~0x3fffff) + 0x10000)\n-#   endif\n-#   ifdef  DGUX\n-#\tdefine OS_TYPE \"DGUX\"\n-\textern char * GC_SysVGetDataStart();\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &etext)\n-#   endif\n-#   define STACKBOTTOM ((char*)0xf0000000) /* determined empirically */\n-# endif\n-\n-# ifdef S370\n-#   define MACH_TYPE \"S370\"\n-#   define OS_TYPE \"UTS4\"\n-#   define ALIGNMENT 4\t/* Required by hardware\t*/\n-    extern int etext;\n-\textern int _etext;\n-\textern int _end;\n-\textern char * GC_SysVGetDataStart();\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n-#\tdefine DATAEND (&_end)\n-#\tdefine HEURISTIC2\n-# endif\n-\n-# ifndef STACK_GROWS_UP\n-#   define STACK_GROWS_DOWN\n-# endif\n-\n-# ifndef CPP_WORDSZ\n-#   define CPP_WORDSZ 32\n-# endif\n-\n-# ifndef OS_TYPE\n-#   define OS_TYPE \"\"\n-# endif\n-\n-# ifndef DATAEND\n-    extern int end;\n-#   define DATAEND (&end)\n-# endif\n-\n-# if defined(SVR4) && !defined(GETPAGESIZE)\n-#    include <unistd.h>\n-#    define GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n-# endif\n-\n-# ifndef GETPAGESIZE\n-#   if defined(SUNOS5) || defined(IRIX5)\n-#\tinclude <unistd.h>\n-#   endif\n-#   define GETPAGESIZE() getpagesize()\n-# endif\n-\n-# if defined(SUNOS5) || defined(DRSNX) || defined(UTS4)\n-    /* OS has SVR4 generic features.  Probably others also qualify.\t*/\n-#   define SVR4\n-# endif\n-\n-# if defined(SUNOS5) || defined(DRSNX)\n-    /* OS has SUNOS5 style semi-undocumented interface to dynamic \t*/\n-    /* loader.\t\t\t\t\t\t\t\t*/\n-#   define SUNOS5DL\n-    /* OS has SUNOS5 style signal handlers.\t\t\t\t*/\n-#   define SUNOS5SIGS\n-# endif\n-\n-# if CPP_WORDSZ != 32 && CPP_WORDSZ != 64\n-   -> bad word size\n-# endif\n-\n-# ifdef PCR\n-#   undef DYNAMIC_LOADING\n-#   undef STACKBOTTOM\n-#   undef HEURISTIC1\n-#   undef HEURISTIC2\n-#   undef PROC_VDB\n-#   undef MPROTECT_VDB\n-#   define PCR_VDB\n-# endif\n-\n-# ifdef SRC_M3\n-/* Postponed for now. */\n-#   undef PROC_VDB\n-#   undef MPROTECT_VDB\n-# endif\n-\n-# ifdef SMALL_CONFIG\n-/* Presumably not worth the space it takes. */\n-#   undef PROC_VDB\n-#   undef MPROTECT_VDB\n-# endif\n-\n-# if !defined(PCR_VDB) && !defined(PROC_VDB) && !defined(MPROTECT_VDB)\n-#   define DEFAULT_VDB\n-# endif\n-\n-# if defined(IRIX_THREADS) && !defined(IRIX5)\n---> inconsistent configuration\n-# endif\n-# if defined(LINUX_THREADS) && !defined(LINUX)\n---> inconsistent configuration\n-# endif\n-# if defined(SOLARIS_THREADS) && !defined(SUNOS5)\n---> inconsistent configuration\n-# endif\n-# if defined(PCR) || defined(SRC_M3) || \\\n-\tdefined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n-\tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n-\tdefined(QUICK_THREADS)\n-#   define THREADS\n-# endif\n-\n-# if defined(SPARC)\n-#   define SAVE_CALL_CHAIN\n-#   define ASM_CLEAR_CODE\t/* Stack clearing is crucial, and we \t*/\n-\t\t\t\t/* include assembly code to do it well.\t*/\n-# endif\n-\n-# if defined(PJ)\n-#   define ALIGNMENT 4\n-    extern int _etext;\n-#   define DATASTART ((ptr_t)(&_etext))\n-#   define HEURISTIC1\n-# endif\n-\n-# endif"}, {"sha": "ef5960c100fa49d0f809d7637439e8e9fc4aa173", "filename": "boehm-gc/configure", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=89de952f8fd07986247620df87cbf08712141f31", "patch": "@@ -2251,8 +2251,6 @@ cat >> confdefs.h <<\\EOF\n EOF\n \n \n-\n-\n if test -n \"${with_cross_host}\"; then\n    cat >> confdefs.h <<\\EOF\n #define NO_SIGSET 1\n@@ -2578,51 +2576,6 @@ s%@INSTALL@%$INSTALL%g\n fi; done\n rm -f conftest.s*\n \n-EOF\n-\n-cat >> $CONFIG_STATUS <<EOF\n-ac_sources=\"config.h\"\n-ac_dests=\"boehm-config.h\"\n-EOF\n-\n-cat >> $CONFIG_STATUS <<\\EOF\n-srcdir=$ac_given_srcdir\n-while test -n \"$ac_sources\"; do\n-  set $ac_dests; ac_dest=$1; shift; ac_dests=$*\n-  set $ac_sources; ac_source=$1; shift; ac_sources=$*\n-\n-  echo \"linking $srcdir/$ac_source to $ac_dest\"\n-\n-  if test ! -r $srcdir/$ac_source; then\n-    { echo \"configure: error: $srcdir/$ac_source: File not found\" 1>&2; exit 1; }\n-  fi\n-  rm -f $ac_dest\n-\n-  # Make relative symlinks.\n-  # Remove last slash and all that follows it.  Not all systems have dirname.\n-  ac_dest_dir=`echo $ac_dest|sed 's%/[^/][^/]*$%%'`\n-  if test \"$ac_dest_dir\" != \"$ac_dest\" && test \"$ac_dest_dir\" != .; then\n-    # The dest file is in a subdirectory.\n-    test ! -d \"$ac_dest_dir\" && mkdir \"$ac_dest_dir\"\n-    ac_dest_dir_suffix=\"/`echo $ac_dest_dir|sed 's%^\\./%%'`\"\n-    # A \"../\" for each directory in $ac_dest_dir_suffix.\n-    ac_dots=`echo $ac_dest_dir_suffix|sed 's%/[^/]*%../%g'`\n-  else\n-    ac_dest_dir_suffix= ac_dots=\n-  fi\n-\n-  case \"$srcdir\" in\n-  [/$]*) ac_rel_source=\"$srcdir/$ac_source\" ;;\n-  *) ac_rel_source=\"$ac_dots$srcdir/$ac_source\" ;;\n-  esac\n-\n-  # Make a symlink if possible; otherwise try a hard link.\n-  if ln -s $ac_rel_source $ac_dest 2>/dev/null ||\n-    ln $srcdir/$ac_source $ac_dest; then :\n-  else\n-    { echo \"configure: error: can not link $ac_dest to $srcdir/$ac_source\" 1>&2; exit 1; }\n-  fi\n-done\n EOF\n cat >> $CONFIG_STATUS <<EOF\n srcdir=${srcdir}"}, {"sha": "0d2331fe6170772813cc61c71f8799e7d644272b", "filename": "boehm-gc/configure.in", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.in?ref=89de952f8fd07986247620df87cbf08712141f31", "patch": "@@ -195,12 +195,6 @@ AC_DEFINE(NO_SIGNALS)\n AC_DEFINE(NO_DEBUGGING)\n AC_DEFINE(JAVA_FINALIZATION)\n \n-dnl Create boehm-config.h so that libjava can find it.\n-dnl It is required to use gc_priv.h, which is required to write\n-dnl a new marking function.  So config.h in this package is\n-dnl poorly named.\n-AC_LINK_FILES(config.h, boehm-config.h)\n-\n dnl This is something of a hack.  When cross-compiling we turn off\n dnl some functionality.  We also enable the \"small\" configuration.\n dnl These is only correct when targetting an embedded system.  FIXME."}, {"sha": "cd554d1a914f9294f839525a357597ae04679ff9", "filename": "boehm-gc/gc_priv.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_priv.h?ref=89de952f8fd07986247620df87cbf08712141f31", "patch": "@@ -44,7 +44,7 @@\n typedef GC_word word;\n typedef GC_signed_word signed_word;\n \n-# ifndef CONFIG_H\n+# ifndef GCCONFIG_H\n #   include \"gcconfig.h\"\n # endif\n "}, {"sha": "47219095f33d2e5ea0f2648e37b58eb67cca3b68", "filename": "boehm-gc/gcconfig.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89de952f8fd07986247620df87cbf08712141f31/boehm-gc%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcconfig.h?ref=89de952f8fd07986247620df87cbf08712141f31", "patch": "@@ -13,9 +13,9 @@\n  * modified is included with the above copyright notice.\n  */\n  \n-#ifndef CONFIG_H\n+#ifndef GCCONFIG_H\n \n-# define CONFIG_H\n+# define GCCONFIG_H\n \n /* Machine dependent parameters.  Some tuning parameters can be found\t*/\n /* near the top of gc_private.h.\t\t\t\t\t*/"}]}