{"sha": "4001900fb3dd67c055a9350244fd4a644c6d7c7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAwMTkwMGZiM2RkNjdjMDU1YTkzNTAyNDRmZDRhNjQ0YzZkN2M3YQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-08-09T14:03:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-09T14:03:10Z"}, "message": "tree-vrp.c (zero_nonzero_bits_from_vr): Also return precise information for ranges with only negative values.\n\n2011-08-09  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (zero_nonzero_bits_from_vr): Also return precise\n\tinformation for ranges with only negative values.\n\t(extract_range_from_binary_expr_1): Adjust BIT_IOR_EXPR and\n\tBIT_AND_EXPR handling to handle ranges with negative values.\n\n\t* gcc.dg/tree-ssa/vrp57.c: Disable CCP.\n\t* gcc.dg/tree-ssa/vrp60.c: New testcase.\n\t* gcc.dg/tree-ssa/vrp61.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp62.c: Likewise.\n\nFrom-SVN: r177597", "tree": {"sha": "65bbb1ea81207fe1b61b32ed9e44238c8a15c344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65bbb1ea81207fe1b61b32ed9e44238c8a15c344"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4001900fb3dd67c055a9350244fd4a644c6d7c7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4001900fb3dd67c055a9350244fd4a644c6d7c7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4001900fb3dd67c055a9350244fd4a644c6d7c7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4001900fb3dd67c055a9350244fd4a644c6d7c7a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd812873753fafce7590211420a116534461689f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd812873753fafce7590211420a116534461689f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd812873753fafce7590211420a116534461689f"}], "stats": {"total": 328, "additions": 255, "deletions": 73}, "files": [{"sha": "6adde4a9c5bba4b368b31170c1526d940f419462", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4001900fb3dd67c055a9350244fd4a644c6d7c7a", "patch": "@@ -1,3 +1,10 @@\n+2011-08-09  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (zero_nonzero_bits_from_vr): Also return precise\n+\tinformation for ranges with only negative values.\n+\t(extract_range_from_binary_expr_1): Adjust BIT_IOR_EXPR and\n+\tBIT_AND_EXPR handling to handle ranges with negative values.\n+\n 2011-08-09  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n        * config/i386/i386.c: Remove traling spaces."}, {"sha": "ba435362e6f017edba57d1d17c61531f0c7dbf6d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4001900fb3dd67c055a9350244fd4a644c6d7c7a", "patch": "@@ -1,3 +1,10 @@\n+2011-08-09  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/vrp57.c: Disable CCP.\n+\t* gcc.dg/tree-ssa/vrp60.c: New testcase.\n+\t* gcc.dg/tree-ssa/vrp61.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp62.c: Likewise.\n+\n 2011-08-09  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* gfortran.dg/scratch_1.f90: Skip on spu-*-*."}, {"sha": "cac37835dac3848483160ee72fbf5d615d77e7e0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp57.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp57.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp57.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp57.c?ref=4001900fb3dd67c055a9350244fd4a644c6d7c7a", "patch": "@@ -1,6 +1,6 @@\n /* PR40052 */\n /* { dg-do compile } */\n-/* { dg-options \"-O -ftree-vrp -fdump-tree-optimized\" } */\n+/* { dg-options \"-O -ftree-vrp -fno-tree-ccp -fdump-tree-optimized\" } */\n \n int foo(_Bool b)\n {"}, {"sha": "9b34e3d492d0c70c3a469839a47da55170606505", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp60.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp60.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp60.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp60.c?ref=4001900fb3dd67c055a9350244fd4a644c6d7c7a", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\r\n+/* { dg-options \"-O2 -fno-tree-ccp -fno-tree-dominator-opts -fdump-tree-vrp1\" } */\r\n+\r\n+int foo (int x, int b)\r\n+{\r\n+  int cst;\r\n+  if (b)\r\n+    cst = -__INT_MAX__ - 1;\r\n+  else\r\n+    cst = -__INT_MAX__;\r\n+  x = x | cst;\r\n+  if (x >= 0)\r\n+    return 12345;\r\n+  return x;\r\n+}\r\n+\r\n+int bar (int x, int b)\r\n+{\r\n+  int cst;\r\n+  if (b)\r\n+    cst = __INT_MAX__;\r\n+  else\r\n+    cst = __INT_MAX__ - 1;\r\n+  x = x & cst;\r\n+  if (x < 0)\r\n+    return 12345;\r\n+  return x;\r\n+}\r\n+\r\n+/* { dg-final { scan-tree-dump-not \"12345\" \"vrp1\" } } */\r\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */\r"}, {"sha": "93bcbc9151da2ab0e4241215254c0a124050c8e8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp61.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp61.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp61.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp61.c?ref=4001900fb3dd67c055a9350244fd4a644c6d7c7a", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+int f (int x, int y)\n+{\n+  if (x > -1024 && x < 0 && y > -1024 && y < 0)\n+    {\n+      x = x ^ y;\n+      if (x < 0 || x > 1023)\n+\treturn 1234;\n+    }\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"1234\" \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "139195b1e51eb860a622fb7cc8d49f4fcf092540", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp62.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp62.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp62.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp62.c?ref=4001900fb3dd67c055a9350244fd4a644c6d7c7a", "patch": "@@ -0,0 +1,110 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-tree-ccp -fno-tree-dominator-opts\" } */\n+\n+/* Tests generated via  */\n+\n+#if 0\n+#include <stdio.h>\n+int main(int argc, char **argv)\n+{\n+  int amin, amax, bmin, bmax, a, b;\n+  int testno = 0;\n+  int min = atoi (argv[1]);\n+  int max = atoi (argv[2]);\n+  char op = argv[3][0];\n+  printf (\"/* Testing range [%d, %d] with operator %c.  */\\n\", min, max, op);\n+  printf (\"extern void abort (void);\\n\");\n+  for (amin = min; amin <= max; ++amin)\n+    for (amax = amin; amax <= max; ++amax)\n+      for (bmin = min; bmin <= max; ++bmin)\n+\tfor (bmax = bmin; bmax <= max; ++bmax)\n+\t  {\n+\t    ++testno;\n+\t    printf (\"int test%d (int a, int b)\\n\"\n+\t\t    \"{\\n\"\n+\t\t    \"  if (a >= %d && a <= %d && b >= %d && b <= %d)\\n\"\n+\t\t    \"   {\\n\"\n+\t\t    \"      int x = a %c b;\\n\"\n+\t\t    \"      if (0\\n\", testno, amin, amax, bmin, bmax, op);\n+\t    for (a = amin; a <= amax; ++a)\n+\t      for (b = bmin; b <= bmax; ++b)\n+\t\tprintf (\"|| x == (%d %c %d)\\n\", a, op, b);\n+\t    printf (\"         ) return 0;\\n\"\n+\t\t    \"      abort ();\\n\"\n+\t\t    \"   }\\n\"\n+\t\t    \"  return 0;\\n\"\n+\t\t    \"}\\n\");\n+\t  }\n+  printf (\"int main()\\n\"\n+\t  \"{\\n\"\n+\t  \"  int a, b;\\n\"\n+\t  \"  for (a = %d; a <= %d; ++a)\\n\"\n+\t  \"    for (b = %d; b <= %d; ++b)\\n\"\n+\t  \"      {\\n\", min, max, min, max);\n+  for (; testno > 0; --testno)\n+    printf (\"      test%d (a, b);\\n\", testno);\n+  printf (\"      }\\n\"\n+\t  \"  return 0;\\n\"\n+\t  \"}\\n\");\n+  return 0;\n+}\n+#endif\n+\n+extern void abort (void);\n+\n+int test381 (int a, int b)\n+{\n+  if (a >= -3 && a <= -1 && b >= -2 && b <= 3)\n+    {\n+      int x = a | b;\n+      if (x == (-3 | -2)\n+\t  || x == (-3 | -1)\n+\t  || x == (-3 | 0)\n+\t  || x == (-3 | 1)\n+\t  || x == (-3 | 2)\n+\t  || x == (-3 | 3)\n+\t  || x == (-2 | -2)\n+\t  || x == (-2 | -1)\n+\t  || x == (-2 | 0)\n+\t  || x == (-2 | 1)\n+\t  || x == (-2 | 2)\n+\t  || x == (-2 | 3)\n+\t  || x == (-1 | -2)\n+\t  || x == (-1 | -1)\n+\t  || x == (-1 | 0)\n+\t  || x == (-1 | 1)\n+\t  || x == (-1 | 2)\n+\t  || x == (-1 | 3))\n+\treturn 0;\n+      abort ();\n+    }\n+  return 0;\n+}\n+\n+int test900 (int a, int b)\n+{\n+  if (a >= -1 && a <= 2 && b >= 3 && b <= 3)\n+    {\n+      int x = a & b;\n+      if (x == (-1 & 3)\n+\t  || x == (0 & 3)\n+\t  || x == (1 & 3)\n+\t  || x == (2 & 3))\n+\treturn 0;\n+      abort ();\n+    }\n+  return 0;\n+}\n+\n+int main()\n+{\n+  int a, b;\n+  for (a = -4; a < 4; ++a)\n+    for (b = -4; b < 4; ++b)\n+      {\n+\ttest381 (a, b);\n+\ttest900 (a, b);\n+      }\n+\n+  return 0;\n+}"}, {"sha": "0faf53aa98534dd23b1ea9dd74e4a26b1a4b461e", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 83, "deletions": 72, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4001900fb3dd67c055a9350244fd4a644c6d7c7a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=4001900fb3dd67c055a9350244fd4a644c6d7c7a", "patch": "@@ -2138,49 +2138,49 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n    the bit is 1, otherwise it might be 0 or 1.  */\n \n static bool\n-zero_nonzero_bits_from_vr (value_range_t *vr, double_int *may_be_nonzero,\n+zero_nonzero_bits_from_vr (value_range_t *vr,\n+\t\t\t   double_int *may_be_nonzero,\n \t\t\t   double_int *must_be_nonzero)\n {\n-  may_be_nonzero->low = ALL_ONES;\n-  may_be_nonzero->high = ALL_ONES;\n-  must_be_nonzero->low = 0;\n-  must_be_nonzero->high = 0;\n-  if (range_int_cst_p (vr))\n+  *may_be_nonzero = double_int_minus_one;\n+  *must_be_nonzero = double_int_zero;\n+  if (!range_int_cst_p (vr))\n+    return false;\n+\n+  if (range_int_cst_singleton_p (vr))\n+    {\n+      *may_be_nonzero = tree_to_double_int (vr->min);\n+      *must_be_nonzero = *may_be_nonzero;\n+    }\n+  else if (tree_int_cst_sgn (vr->min) >= 0\n+\t   || tree_int_cst_sgn (vr->max) < 0)\n     {\n-      if (range_int_cst_singleton_p (vr))\n+      double_int dmin = tree_to_double_int (vr->min);\n+      double_int dmax = tree_to_double_int (vr->max);\n+      double_int xor_mask = double_int_xor (dmin, dmax);\n+      *may_be_nonzero = double_int_ior (dmin, dmax);\n+      *must_be_nonzero = double_int_and (dmin, dmax);\n+      if (xor_mask.high != 0)\n \t{\n-\t  *may_be_nonzero = tree_to_double_int (vr->min);\n-\t  *must_be_nonzero = *may_be_nonzero;\n+\t  unsigned HOST_WIDE_INT mask\n+\t      = ((unsigned HOST_WIDE_INT) 1\n+\t\t << floor_log2 (xor_mask.high)) - 1;\n+\t  may_be_nonzero->low = ALL_ONES;\n+\t  may_be_nonzero->high |= mask;\n+\t  must_be_nonzero->low = 0;\n+\t  must_be_nonzero->high &= ~mask;\n \t}\n-      else if (tree_int_cst_sgn (vr->min) >= 0)\n+      else if (xor_mask.low != 0)\n \t{\n-\t  double_int dmin = tree_to_double_int (vr->min);\n-\t  double_int dmax = tree_to_double_int (vr->max);\n-\t  double_int xor_mask = double_int_xor (dmin, dmax);\n-\t  *may_be_nonzero = double_int_ior (dmin, dmax);\n-\t  *must_be_nonzero = double_int_and (dmin, dmax);\n-\t  if (xor_mask.high != 0)\n-\t    {\n-\t      unsigned HOST_WIDE_INT mask\n-\t\t= ((unsigned HOST_WIDE_INT) 1\n-\t\t   << floor_log2 (xor_mask.high)) - 1;\n-\t      may_be_nonzero->low = ALL_ONES;\n-\t      may_be_nonzero->high |= mask;\n-\t      must_be_nonzero->low = 0;\n-\t      must_be_nonzero->high &= ~mask;\n-\t    }\n-\t  else if (xor_mask.low != 0)\n-\t    {\n-\t      unsigned HOST_WIDE_INT mask\n-\t\t= ((unsigned HOST_WIDE_INT) 1\n-\t\t   << floor_log2 (xor_mask.low)) - 1;\n-\t      may_be_nonzero->low |= mask;\n-\t      must_be_nonzero->low &= ~mask;\n-\t    }\n+\t  unsigned HOST_WIDE_INT mask\n+\t      = ((unsigned HOST_WIDE_INT) 1\n+\t\t << floor_log2 (xor_mask.low)) - 1;\n+\t  may_be_nonzero->low |= mask;\n+\t  must_be_nonzero->low &= ~mask;\n \t}\n-      return true;\n     }\n-  return false;\n+\n+  return true;\n }\n \n \n@@ -2650,50 +2650,63 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n       type = VR_RANGE;\n       if (code == BIT_AND_EXPR)\n \t{\n+\t  double_int dmax;\n \t  min = double_int_to_tree (expr_type,\n \t\t\t\t    double_int_and (must_be_nonzero0,\n \t\t\t\t\t\t    must_be_nonzero1));\n-\t  max = double_int_to_tree (expr_type,\n-\t\t\t\t    double_int_and (may_be_nonzero0,\n-\t\t\t\t\t\t    may_be_nonzero1));\n-\t  if (tree_int_cst_sgn (min) < 0)\n-\t    min = NULL_TREE;\n-\t  if (tree_int_cst_sgn (max) < 0)\n-\t    max = NULL_TREE;\n-\t  if (int_cst_range0 && tree_int_cst_sgn (vr0.min) >= 0)\n+\t  dmax = double_int_and (may_be_nonzero0, may_be_nonzero1);\n+\t  /* If both input ranges contain only negative values we can\n+\t     truncate the result range maximum to the minimum of the\n+\t     input range maxima.  */\n+\t  if (int_cst_range0 && int_cst_range1\n+\t      && tree_int_cst_sgn (vr0.max) < 0\n+\t      && tree_int_cst_sgn (vr1.max) < 0)\n \t    {\n-\t      if (min == NULL_TREE)\n-\t\tmin = build_int_cst (expr_type, 0);\n-\t      if (max == NULL_TREE || tree_int_cst_lt (vr0.max, max))\n-\t\tmax = vr0.max;\n+\t      dmax = double_int_min (dmax, tree_to_double_int (vr0.max),\n+\t\t\t\t     TYPE_UNSIGNED (expr_type));\n+\t      dmax = double_int_min (dmax, tree_to_double_int (vr1.max),\n+\t\t\t\t     TYPE_UNSIGNED (expr_type));\n \t    }\n+\t  /* If either input range contains only non-negative values\n+\t     we can truncate the result range maximum to the respective\n+\t     maximum of the input range.  */\n+\t  if (int_cst_range0 && tree_int_cst_sgn (vr0.min) >= 0)\n+\t    dmax = double_int_min (dmax, tree_to_double_int (vr0.max),\n+\t\t\t\t   TYPE_UNSIGNED (expr_type));\n \t  if (int_cst_range1 && tree_int_cst_sgn (vr1.min) >= 0)\n-\t    {\n-\t      if (min == NULL_TREE)\n-\t\tmin = build_int_cst (expr_type, 0);\n-\t      if (max == NULL_TREE || tree_int_cst_lt (vr1.max, max))\n-\t\tmax = vr1.max;\n-\t    }\n+\t    dmax = double_int_min (dmax, tree_to_double_int (vr1.max),\n+\t\t\t\t   TYPE_UNSIGNED (expr_type));\n+\t  max = double_int_to_tree (expr_type, dmax);\n \t}\n       else if (code == BIT_IOR_EXPR)\n \t{\n-\t  min = double_int_to_tree (expr_type,\n-\t\t\t\t    double_int_ior (must_be_nonzero0,\n-\t\t\t\t\t\t    must_be_nonzero1));\n+\t  double_int dmin;\n \t  max = double_int_to_tree (expr_type,\n \t\t\t\t    double_int_ior (may_be_nonzero0,\n \t\t\t\t\t\t    may_be_nonzero1));\n-\t  if (tree_int_cst_sgn (max) < 0)\n-\t    max = NULL_TREE;\n-\t  if (int_cst_range0)\n+\t  dmin = double_int_ior (must_be_nonzero0, must_be_nonzero1);\n+\t  /* If the input ranges contain only positive values we can\n+\t     truncate the minimum of the result range to the maximum\n+\t     of the input range minima.  */\n+\t  if (int_cst_range0 && int_cst_range1\n+\t      && tree_int_cst_sgn (vr0.min) >= 0\n+\t      && tree_int_cst_sgn (vr1.min) >= 0)\n \t    {\n-\t      if (tree_int_cst_sgn (min) < 0)\n-\t\tmin = vr0.min;\n-\t      else\n-\t\tmin = vrp_int_const_binop (MAX_EXPR, min, vr0.min);\n+\t      dmin = double_int_max (dmin, tree_to_double_int (vr0.min),\n+\t\t\t\t     TYPE_UNSIGNED (expr_type));\n+\t      dmin = double_int_max (dmin, tree_to_double_int (vr1.min),\n+\t\t\t\t     TYPE_UNSIGNED (expr_type));\n \t    }\n-\t  if (int_cst_range1)\n-\t    min = vrp_int_const_binop (MAX_EXPR, min, vr1.min);\n+\t  /* If either input range contains only negative values\n+\t     we can truncate the minimum of the result range to the\n+\t     respective minimum range.  */\n+\t  if (int_cst_range0 && tree_int_cst_sgn (vr0.max) < 0)\n+\t    dmin = double_int_max (dmin, tree_to_double_int (vr0.min),\n+\t\t\t\t   TYPE_UNSIGNED (expr_type));\n+\t  if (int_cst_range1 && tree_int_cst_sgn (vr1.max) < 0)\n+\t    dmin = double_int_max (dmin, tree_to_double_int (vr1.min),\n+\t\t\t\t   TYPE_UNSIGNED (expr_type));\n+\t  min = double_int_to_tree (expr_type, dmin);\n \t}\n       else if (code == BIT_XOR_EXPR)\n \t{\n@@ -2714,14 +2727,12 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t  max = double_int_to_tree (expr_type,\n \t\t\t\t    double_int_not (result_zero_bits));\n \t  min = double_int_to_tree (expr_type, result_one_bits);\n-\t  /* Return a [min, max] range if we know the\n-\t     result range is either positive or negative.  */\n-\t  if (tree_int_cst_sgn (max) >= 0)\n-\t    /* The range is bound by a lower value of 0.  */;\n-\t  else if (tree_int_cst_sgn (min) < 0)\n-\t    /* The range is bound by an upper value of -1.  */;\n+\t  /* If the range has all positive or all negative values the\n+\t     result is better than VARYING.  */\n+\t  if (tree_int_cst_sgn (min) < 0\n+\t      || tree_int_cst_sgn (max) >= 0)\n+\t    ;\n \t  else\n-\t    /* We don't know whether the sign bit is set or not.  */\n \t    max = min = NULL_TREE;\n \t}\n       else"}]}