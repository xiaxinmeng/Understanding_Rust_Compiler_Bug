{"sha": "092231a8d635d601a3d05a284f279286f59cab9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkyMjMxYThkNjM1ZDYwMWEzZDA1YTI4NGYyNzkyODZmNTljYWI5ZQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2009-05-26T21:19:57Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-05-26T21:19:57Z"}, "message": "re PR fortran/39178 (Generate main() rather than using a main in libgfortran/fmain.c)\n\nfortran/\n2009-05-26  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/39178\n        * gfortranspec.c (lang_specific_driver): Stop linking\n        libgfortranbegin.\n        * trans-decl.c (gfc_build_builtin_function_decls): Stop\n        making MAIN__ publicly visible.\n        (gfc_build_builtin_function_decls): Add\n        gfor_fndecl_set_args.\n        (create_main_function) New function.\n        (gfc_generate_function_code): Use it.\n\nlibgfortran/\n2009-05-26  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/39178\n        * runtime/main.c (store_exe_path): Make static\n        and multiple-times callable.\n        (set_args): Call store_exe_path.\n        * libgfortran.h: Remove store_exe_path prototype.\n        * fmain.c (main): Remove store_exe_path call.\n\nFrom-SVN: r147883", "tree": {"sha": "43a6fbb9dd54816b1c1a284ffc7fba3adac67337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43a6fbb9dd54816b1c1a284ffc7fba3adac67337"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/092231a8d635d601a3d05a284f279286f59cab9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/092231a8d635d601a3d05a284f279286f59cab9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/092231a8d635d601a3d05a284f279286f59cab9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/092231a8d635d601a3d05a284f279286f59cab9e/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9a0bab0be682be2aaee5f1146518c4d94d44ac8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0bab0be682be2aaee5f1146518c4d94d44ac8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0bab0be682be2aaee5f1146518c4d94d44ac8e"}], "stats": {"total": 409, "additions": 253, "deletions": 156}, "files": [{"sha": "805596293e22bf58b27eb9ab64f1a9b7005c3f23", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092231a8d635d601a3d05a284f279286f59cab9e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092231a8d635d601a3d05a284f279286f59cab9e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=092231a8d635d601a3d05a284f279286f59cab9e", "patch": "@@ -1,3 +1,15 @@\n+2009-05-26  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/39178\n+\t* gfortranspec.c (lang_specific_driver): Stop linking\n+\tlibgfortranbegin.\n+\t* trans-decl.c (gfc_build_builtin_function_decls): Stop\n+\tmaking MAIN__ publicly visible.\n+\t(gfc_build_builtin_function_decls): Add\n+\tgfor_fndecl_set_args.\n+\t(create_main_function) New function.\n+\t(gfc_generate_function_code): Use it.\n+\n 2009-05-26  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/40246"}, {"sha": "a6f9b42b4747c2ed2941b8eb9f692f973eebce9c", "filename": "gcc/fortran/gfortranspec.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092231a8d635d601a3d05a284f279286f59cab9e/gcc%2Ffortran%2Fgfortranspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092231a8d635d601a3d05a284f279286f59cab9e/gcc%2Ffortran%2Fgfortranspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortranspec.c?ref=092231a8d635d601a3d05a284f279286f59cab9e", "patch": "@@ -58,10 +58,6 @@ along with GCC; see the file COPYING3.  If not see\n #define MATH_LIBRARY \"-lm\"\n #endif\n \n-#ifndef FORTRAN_INIT\n-#define FORTRAN_INIT \"-lgfortranbegin\"\n-#endif\n-\n #ifndef FORTRAN_LIBRARY\n #define FORTRAN_LIBRARY \"-lgfortran\"\n #endif\n@@ -278,10 +274,6 @@ lang_specific_driver (int *in_argc, const char *const **in_argv,\n      2 => last two args were -l<library> -lm.  */\n   int saw_library = 0;\n \n-  /* 0 => initial/reset state\n-     1 => FORTRAN_INIT linked in */\n-  int use_init = 0;\n-\n   /* By default, we throw on the math library if we have one.  */\n   int need_math = (MATH_LIBRARY[0] != '\\0');\n \n@@ -505,12 +497,6 @@ For more information about these matters, see the file named COPYING\\n\\n\"));\n \t\tsaw_library = 2;\t/* -l<library> -lm.  */\n \t      else\n \t\t{\n-\t\t  if (0 == use_init)\n-\t\t    {\n-\t\t      append_arg (FORTRAN_INIT);\n-\t\t      use_init = 1;\n-\t\t    }\n-\n \t\t  ADD_ARG_LIBGFORTRAN (FORTRAN_LIBRARY);\n \t\t}\n \t    }\n@@ -540,11 +526,6 @@ For more information about these matters, see the file named COPYING\\n\\n\"));\n       switch (saw_library)\n \t{\n \tcase 0:\n-\t  if (0 == use_init)\n-\t    {\n-\t      append_arg (FORTRAN_INIT);\n-\t      use_init = 1;\n-\t    }\n \t  ADD_ARG_LIBGFORTRAN (library);\n \t  /* Fall through.  */\n "}, {"sha": "3695555204203a0c52837068289318b007626ef7", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 203, "deletions": 109, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092231a8d635d601a3d05a284f279286f59cab9e/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092231a8d635d601a3d05a284f279286f59cab9e/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=092231a8d635d601a3d05a284f279286f59cab9e", "patch": "@@ -86,6 +86,7 @@ tree gfor_fndecl_runtime_error_at;\n tree gfor_fndecl_runtime_warning_at;\n tree gfor_fndecl_os_error;\n tree gfor_fndecl_generate_error;\n+tree gfor_fndecl_set_args;\n tree gfor_fndecl_set_fpe;\n tree gfor_fndecl_set_options;\n tree gfor_fndecl_set_convert;\n@@ -1525,7 +1526,7 @@ build_function_decl (gfc_symbol * sym)\n   /* This specifies if a function is globally visible, i.e. it is\n      the opposite of declaring static in C.  */\n   if (DECL_CONTEXT (fndecl) == NULL_TREE\n-      && !sym->attr.entry_master)\n+      && !sym->attr.entry_master && !sym->attr.is_main_program)\n     TREE_PUBLIC (fndecl) = 1;\n \n   /* TREE_STATIC means the function body is defined here.  */\n@@ -1544,12 +1545,6 @@ build_function_decl (gfc_symbol * sym)\n       TREE_SIDE_EFFECTS (fndecl) = 0;\n     }\n \n-  /* For -fwhole-program to work well, the main program needs to have the\n-     \"externally_visible\" attribute.  */\n-  if (attr.is_main_program)\n-    DECL_ATTRIBUTES (fndecl)\n-      = tree_cons (get_identifier(\"externally_visible\"), NULL_TREE, NULL_TREE);\n-\n   /* Layout the function declaration and put it in the binding level\n      of the current function.  */\n   pushdecl (fndecl);\n@@ -2635,6 +2630,11 @@ gfc_build_builtin_function_decls (void)\n   /* The runtime_error function does not return.  */\n   TREE_THIS_VOLATILE (gfor_fndecl_os_error) = 1;\n \n+  gfor_fndecl_set_args =\n+    gfc_build_library_function_decl (get_identifier (PREFIX(\"set_args\")),\n+\t\t\t\t     void_type_node, 2, integer_type_node,\n+\t\t\t\t     build_pointer_type (pchar_type_node));\n+\n   gfor_fndecl_set_fpe =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"set_fpe\")),\n \t\t\t\t    void_type_node, 1, integer_type_node);\n@@ -2643,7 +2643,7 @@ gfc_build_builtin_function_decls (void)\n   gfor_fndecl_set_options =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"set_options\")),\n \t\t\t\t    void_type_node, 2, integer_type_node,\n-\t\t\t\t    pvoid_type_node);\n+\t\t\t\t    build_pointer_type (integer_type_node));\n \n   gfor_fndecl_set_convert =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"set_convert\")),\n@@ -3835,6 +3835,197 @@ add_argument_checking (stmtblock_t *block, gfc_symbol *sym)\n }\n \n \n+static void\n+create_main_function (tree fndecl)\n+{\n+\n+  tree ftn_main;\n+  tree tmp, decl, result_decl, argc, argv, typelist, arglist;\n+  stmtblock_t body;\n+\n+  /* main() function must be declared with global scope.  */\n+  gcc_assert (current_function_decl == NULL_TREE);\n+\n+  /* Declare the function.  */\n+  tmp =  build_function_type_list (integer_type_node, integer_type_node,\n+\t\t\t\t   build_pointer_type (pchar_type_node),\n+\t\t\t\t   NULL_TREE);\n+  ftn_main = build_decl (FUNCTION_DECL, get_identifier (\"main\"), tmp);\n+  DECL_EXTERNAL (ftn_main) = 0;\n+  TREE_PUBLIC (ftn_main) = 1;\n+  TREE_STATIC (ftn_main) = 1;\n+  DECL_ATTRIBUTES (ftn_main)\n+      = tree_cons (get_identifier(\"externally_visible\"), NULL_TREE, NULL_TREE);\n+\n+  /* Setup the result declaration (for \"return 0\").  */\n+  result_decl = build_decl (RESULT_DECL, NULL_TREE, integer_type_node);\n+  DECL_ARTIFICIAL (result_decl) = 1;\n+  DECL_IGNORED_P (result_decl) = 1;\n+  DECL_CONTEXT (result_decl) = ftn_main;\n+  DECL_RESULT (ftn_main) = result_decl;\n+\n+  pushdecl (ftn_main);\n+\n+  /* Get the arguments.  */\n+\n+  arglist = NULL_TREE;\n+  typelist = TYPE_ARG_TYPES (TREE_TYPE (ftn_main));\n+\n+  tmp = TREE_VALUE (typelist);\n+  argc = build_decl (PARM_DECL, get_identifier (\"argc\"), tmp);\n+  DECL_CONTEXT (argc) = ftn_main;\n+  DECL_ARG_TYPE (argc) = TREE_VALUE (typelist);\n+  TREE_READONLY (argc) = 1;\n+  gfc_finish_decl (argc);\n+  arglist = chainon (arglist, argc);\n+\n+  typelist = TREE_CHAIN (typelist);\n+  tmp = TREE_VALUE (typelist);\n+  argv = build_decl (PARM_DECL, get_identifier (\"argv\"), tmp);\n+  DECL_CONTEXT (argv) = ftn_main;\n+  DECL_ARG_TYPE (argv) = TREE_VALUE (typelist);\n+  TREE_READONLY (argv) = 1;\n+  DECL_BY_REFERENCE (argv) = 1;\n+  gfc_finish_decl (argv);\n+  arglist = chainon (arglist, argv);\n+\n+  DECL_ARGUMENTS (ftn_main) = arglist;\n+  current_function_decl = ftn_main;\n+  announce_function (ftn_main);\n+\n+  rest_of_decl_compilation (ftn_main, 1, 0);\n+  make_decl_rtl (ftn_main);\n+  init_function_start (ftn_main);\n+  pushlevel (0);\n+\n+  gfc_init_block (&body);\n+\n+  /* Call some libgfortran initialization routines, call then MAIN__(). */\n+\n+  /* Call _gfortran_set_args (argc, argv).  */\n+  tmp = build_call_expr (gfor_fndecl_set_args, 2, argc, argv);\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+  /* Add a call to set_options to set up the runtime library Fortran\n+     language standard parameters.  */\n+  {\n+    tree array_type, array, var;\n+\n+    /* Passing a new option to the library requires four modifications:\n+     + add it to the tree_cons list below\n+          + change the array size in the call to build_array_type\n+          + change the first argument to the library call\n+            gfor_fndecl_set_options\n+          + modify the library (runtime/compile_options.c)!  */\n+\n+    array = tree_cons (NULL_TREE, build_int_cst (integer_type_node,\n+\t\t       gfc_option.warn_std), NULL_TREE);\n+    array = tree_cons (NULL_TREE, build_int_cst (integer_type_node,\n+\t\t       gfc_option.allow_std), array);\n+    array = tree_cons (NULL_TREE, build_int_cst (integer_type_node, pedantic),\n+\t\t       array);\n+    array = tree_cons (NULL_TREE, build_int_cst (integer_type_node,\n+\t\t       gfc_option.flag_dump_core), array);\n+    array = tree_cons (NULL_TREE, build_int_cst (integer_type_node,\n+\t\t       gfc_option.flag_backtrace), array);\n+    array = tree_cons (NULL_TREE, build_int_cst (integer_type_node,\n+\t\t       gfc_option.flag_sign_zero), array);\n+\n+    array = tree_cons (NULL_TREE, build_int_cst (integer_type_node,\n+\t\t       (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)), array);\n+\n+    array = tree_cons (NULL_TREE, build_int_cst (integer_type_node,\n+\t\t       gfc_option.flag_range_check), array);\n+\n+    array_type = build_array_type (integer_type_node,\n+\t\t       build_index_type (build_int_cst (NULL_TREE, 7)));\n+    array = build_constructor_from_list (array_type, nreverse (array));\n+    TREE_CONSTANT (array) = 1;\n+    TREE_STATIC (array) = 1;\n+\n+    /* Create a static variable to hold the jump table.  */\n+    var = gfc_create_var (array_type, \"options\");\n+    TREE_CONSTANT (var) = 1;\n+    TREE_STATIC (var) = 1;\n+    TREE_READONLY (var) = 1;\n+    DECL_INITIAL (var) = array;\n+    var = gfc_build_addr_expr (build_pointer_type (integer_type_node), var);\n+\n+    tmp = build_call_expr (gfor_fndecl_set_options, 2,\n+\t\t\t   build_int_cst (integer_type_node, 8), var);\n+    gfc_add_expr_to_block (&body, tmp);\n+  }\n+\n+  /* If -ffpe-trap option was provided, add a call to set_fpe so that\n+     the library will raise a FPE when needed.  */\n+  if (gfc_option.fpe != 0)\n+    {\n+      tmp = build_call_expr (gfor_fndecl_set_fpe, 1,\n+\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t    gfc_option.fpe));\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n+  /* If this is the main program and an -fconvert option was provided,\n+     add a call to set_convert.  */\n+\n+  if (gfc_option.convert != GFC_CONVERT_NATIVE)\n+    {\n+      tmp = build_call_expr (gfor_fndecl_set_convert, 1,\n+\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t    gfc_option.convert));\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n+  /* If this is the main program and an -frecord-marker option was provided,\n+     add a call to set_record_marker.  */\n+\n+  if (gfc_option.record_marker != 0)\n+    {\n+      tmp = build_call_expr (gfor_fndecl_set_record_marker, 1,\n+\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t    gfc_option.record_marker));\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n+  if (gfc_option.max_subrecord_length != 0)\n+    {\n+      tmp = build_call_expr (gfor_fndecl_set_max_subrecord_length, 1,\n+\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t    gfc_option.max_subrecord_length));\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n+  /* Call MAIN__().  */\n+  tmp = build_call_expr (fndecl, 0);\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+  /* \"return 0\".  */\n+  tmp = fold_build2 (MODIFY_EXPR, integer_type_node, DECL_RESULT (ftn_main),\n+\t\t     build_int_cst (integer_type_node, 0));\n+  tmp = build1_v (RETURN_EXPR, tmp);\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+\n+  DECL_SAVED_TREE (ftn_main) = gfc_finish_block (&body);\n+  decl = getdecls ();\n+\n+  /* Finish off this function and send it for code generation.  */\n+  poplevel (1, 0, 1);\n+  BLOCK_SUPERCONTEXT (DECL_INITIAL (ftn_main)) = ftn_main;\n+\n+  DECL_SAVED_TREE (ftn_main)\n+    = build3_v (BIND_EXPR, decl, DECL_SAVED_TREE (ftn_main),\n+\t\tDECL_INITIAL (ftn_main));\n+\n+  /* Output the GENERIC tree.  */\n+  dump_function (TDI_original, ftn_main);\n+\n+  gfc_gimplify_function (ftn_main);\n+  cgraph_finalize_function (ftn_main, false);\n+}\n+\n+\n /* Generate code for a function.  */\n \n void\n@@ -3919,107 +4110,6 @@ gfc_generate_function_code (gfc_namespace * ns)\n   /* Now generate the code for the body of this function.  */\n   gfc_init_block (&body);\n \n-  /* If this is the main program, add a call to set_options to set up the\n-     runtime library Fortran language standard parameters.  */\n-  if (sym->attr.is_main_program)\n-    {\n-      tree array_type, array, var;\n-\n-      /* Passing a new option to the library requires four modifications:\n-\t   + add it to the tree_cons list below\n-\t   + change the array size in the call to build_array_type\n-\t   + change the first argument to the library call\n-\t     gfor_fndecl_set_options\n-\t   + modify the library (runtime/compile_options.c)!  */\n-      array = tree_cons (NULL_TREE,\n-\t\t\t build_int_cst (integer_type_node,\n-\t\t\t\t\tgfc_option.warn_std), NULL_TREE);\n-      array = tree_cons (NULL_TREE,\n-\t\t\t build_int_cst (integer_type_node,\n-\t\t\t\t\tgfc_option.allow_std), array);\n-      array = tree_cons (NULL_TREE,\n-\t\t\t build_int_cst (integer_type_node, pedantic), array);\n-      array = tree_cons (NULL_TREE,\n-\t\t\t build_int_cst (integer_type_node,\n-\t\t\t\t\tgfc_option.flag_dump_core), array);\n-      array = tree_cons (NULL_TREE,\n-\t\t\t build_int_cst (integer_type_node,\n-\t\t\t\t\tgfc_option.flag_backtrace), array);\n-      array = tree_cons (NULL_TREE,\n-\t\t\t build_int_cst (integer_type_node,\n-\t\t\t\t\tgfc_option.flag_sign_zero), array);\n-\n-      array = tree_cons (NULL_TREE,\n-\t\t\t build_int_cst (integer_type_node,\n-\t\t\t\t\t(gfc_option.rtcheck\n-\t\t\t\t\t & GFC_RTCHECK_BOUNDS)), array);\n-\n-      array = tree_cons (NULL_TREE,\n-\t\t\t build_int_cst (integer_type_node,\n-\t\t\t\t\tgfc_option.flag_range_check), array);\n-\n-      array_type = build_array_type (integer_type_node,\n-\t\t\t\t     build_index_type (build_int_cst (NULL_TREE,\n-\t\t\t\t\t\t\t\t      7)));\n-      array = build_constructor_from_list (array_type, nreverse (array));\n-      TREE_CONSTANT (array) = 1;\n-      TREE_STATIC (array) = 1;\n-\n-      /* Create a static variable to hold the jump table.  */\n-      var = gfc_create_var (array_type, \"options\");\n-      TREE_CONSTANT (var) = 1;\n-      TREE_STATIC (var) = 1;\n-      TREE_READONLY (var) = 1;\n-      DECL_INITIAL (var) = array;\n-      var = gfc_build_addr_expr (pvoid_type_node, var);\n-\n-      tmp = build_call_expr (gfor_fndecl_set_options, 2,\n-\t\t\t     build_int_cst (integer_type_node, 8), var);\n-      gfc_add_expr_to_block (&body, tmp);\n-    }\n-\n-  /* If this is the main program and a -ffpe-trap option was provided,\n-     add a call to set_fpe so that the library will raise a FPE when\n-     needed.  */\n-  if (sym->attr.is_main_program && gfc_option.fpe != 0)\n-    {\n-      tmp = build_call_expr (gfor_fndecl_set_fpe, 1,\n-\t\t\t     build_int_cst (integer_type_node,\n-\t\t\t\t\t    gfc_option.fpe));\n-      gfc_add_expr_to_block (&body, tmp);\n-    }\n-\n-  /* If this is the main program and an -fconvert option was provided,\n-     add a call to set_convert.  */\n-\n-  if (sym->attr.is_main_program && gfc_option.convert != GFC_CONVERT_NATIVE)\n-    {\n-      tmp = build_call_expr (gfor_fndecl_set_convert, 1,\n-\t\t\t     build_int_cst (integer_type_node,\n-\t\t\t\t\t    gfc_option.convert));\n-      gfc_add_expr_to_block (&body, tmp);\n-    }\n-\n-  /* If this is the main program and an -frecord-marker option was provided,\n-     add a call to set_record_marker.  */\n-\n-  if (sym->attr.is_main_program && gfc_option.record_marker != 0)\n-    {\n-      tmp = build_call_expr (gfor_fndecl_set_record_marker, 1,\n-\t\t\t     build_int_cst (integer_type_node,\n-\t\t\t\t\t    gfc_option.record_marker));\n-      gfc_add_expr_to_block (&body, tmp);\n-    }\n-\n-  if (sym->attr.is_main_program && gfc_option.max_subrecord_length != 0)\n-    {\n-      tmp = build_call_expr (gfor_fndecl_set_max_subrecord_length,\n-\t\t\t     1,\n-\t\t\t     build_int_cst (integer_type_node,\n-\t\t\t\t\t    gfc_option.max_subrecord_length));\n-      gfc_add_expr_to_block (&body, tmp);\n-    }\n-\n    is_recursive = sym->attr.recursive\n \t\t  || (sym->attr.entry_master\n \t\t      && sym->ns->entries->sym->attr.recursive);\n@@ -4203,8 +4293,12 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n   gfc_trans_use_stmts (ns);\n   gfc_traverse_ns (ns, gfc_emit_parameter_debug_info);\n+\n+  if (sym->attr.is_main_program)\n+    create_main_function (fndecl);\n }\n \n+\n void\n gfc_generate_constructors (void)\n {"}, {"sha": "e6516066b8fbce1b922654d6db839e0c39b6fa02", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092231a8d635d601a3d05a284f279286f59cab9e/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092231a8d635d601a3d05a284f279286f59cab9e/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=092231a8d635d601a3d05a284f279286f59cab9e", "patch": "@@ -1,3 +1,12 @@\n+2009-05-26  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/39178\n+\t* runtime/main.c (store_exe_path): Make static\n+\tand multiple-times callable.\n+\t(set_args): Call store_exe_path.\n+\t* libgfortran.h: Remove store_exe_path prototype.\n+\t* fmain.c (main): Remove store_exe_path call.\n+\n 2009-05-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/37754"}, {"sha": "2e8ed885778d94b7be72a2b370305da479f9aa06", "filename": "libgfortran/fmain.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092231a8d635d601a3d05a284f279286f59cab9e/libgfortran%2Ffmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092231a8d635d601a3d05a284f279286f59cab9e/libgfortran%2Ffmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Ffmain.c?ref=092231a8d635d601a3d05a284f279286f59cab9e", "patch": "@@ -9,12 +9,8 @@ void MAIN__ (void);\n int\n main (int argc, char *argv[])\n {\n-  /* Store the path of the executable file.  */\n-  store_exe_path (argv[0]);\n-\n   /* Set up the runtime environment.  */\n-  set_args (argc, argv);\n-\n+  PREFIX(set_args) (argc, argv);\n \n   /* Call the Fortran main program.  Internally this is a function\n      called MAIN__ */"}, {"sha": "85b454d1c3253fcc838820f00806a8c8887a2115", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092231a8d635d601a3d05a284f279286f59cab9e/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092231a8d635d601a3d05a284f279286f59cab9e/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=092231a8d635d601a3d05a284f279286f59cab9e", "patch": "@@ -610,9 +610,6 @@ export_proto(set_args);\n extern void get_args (int *, char ***);\n internal_proto(get_args);\n \n-extern void store_exe_path (const char *);\n-export_proto(store_exe_path);\n-\n extern char * full_exe_path (void);\n internal_proto(full_exe_path);\n "}, {"sha": "6df2775d26e24f16cbf3d74b4b1d6ccd891c2465", "filename": "libgfortran/runtime/main.c", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092231a8d635d601a3d05a284f279286f59cab9e/libgfortran%2Fruntime%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092231a8d635d601a3d05a284f279286f59cab9e/libgfortran%2Fruntime%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fmain.c?ref=092231a8d635d601a3d05a284f279286f59cab9e", "patch": "@@ -69,31 +69,12 @@ determine_endianness (void)\n static int argc_save;\n static char **argv_save;\n \n-/* Set the saved values of the command line arguments.  */\n-\n-void\n-set_args (int argc, char **argv)\n-{\n-  argc_save = argc;\n-  argv_save = argv;\n-}\n-\n-/* Retrieve the saved values of the command line arguments.  */\n-\n-void\n-get_args (int *argc, char ***argv)\n-{\n-  *argc = argc_save;\n-  *argv = argv_save;\n-}\n-\n-\n static const char *exe_path;\n static int please_free_exe_path_when_done;\n \n /* Save the path under which the program was called, for use in the\n    backtrace routines.  */\n-void\n+static void\n store_exe_path (const char * argv0)\n {\n #ifndef PATH_MAX\n@@ -106,6 +87,10 @@ store_exe_path (const char * argv0)\n \n   char buf[PATH_MAX], *cwd, *path;\n \n+  /* This can only happen if store_exe_path is called multiple times.  */\n+  if (please_free_exe_path_when_done)\n+    free ((char *) exe_path);\n+\n   /* On the simulator argv is not set.  */\n   if (argv0 == NULL || argv0[0] == '/')\n     {\n@@ -128,13 +113,36 @@ store_exe_path (const char * argv0)\n   please_free_exe_path_when_done = 1;\n }\n \n+\n /* Return the full path of the executable.  */\n char *\n full_exe_path (void)\n {\n   return (char *) exe_path;\n }\n \n+\n+/* Set the saved values of the command line arguments.  */\n+\n+void\n+set_args (int argc, char **argv)\n+{\n+  argc_save = argc;\n+  argv_save = argv;\n+  store_exe_path (argv[0]);\n+}\n+\n+\n+/* Retrieve the saved values of the command line arguments.  */\n+\n+void\n+get_args (int *argc, char ***argv)\n+{\n+  *argc = argc_save;\n+  *argv = argv_save;\n+}\n+\n+\n /* Initialize the runtime library.  */\n \n static void __attribute__((constructor))"}]}