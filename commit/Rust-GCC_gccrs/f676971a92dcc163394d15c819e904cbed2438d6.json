{"sha": "f676971a92dcc163394d15c819e904cbed2438d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY3Njk3MWE5MmRjYzE2MzM5NGQxNWM4MTllOTA0Y2JlZDI0MzhkNg==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-08-24T00:30:52Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-08-24T00:30:52Z"}, "message": "defaults.h (VECTOR_MODE_SUPPORTED_P): Remove macro.\n\n2004-08-23  Eric Christopher  <echristo@redhat.com>\n\n\t* defaults.h (VECTOR_MODE_SUPPORTED_P): Remove macro.\n\t* system.h (VECTOR_MODE_SUPPORTED_P): Poison.\n\t* target-def.h (TARGET_VECTOR_MODE_SUPPORTED_P): Define.\n\t* target.h: Ditto.\n\t* hooks.h: Include machmode.h.\n\t(hook_bool_mode_false): Declare.\n\t* hooks.c (hook_bool_mode_false): Define.\n\t* expr.c (vector_mode_valid_p): Use targetm.vector_mode_supported_p.\n\t* stor-layout.c (layout_type): Ditto.\n\t* config/alpha/alpha.c (alpha_vector_mode_supported_p): New function.\n\tDefine to target macro.\n\t* config/alpha/alpha.h (VECTOR_MODE_SUPPORTED_P): Delete.\n\t* config/arm/arm.c: Ditto. Use.\n\t* config/arm/arm.h: Ditto.\n\t* config/arm/arm-protos.h: Ditto.\n\t* config/i386/i386.c: Ditto.\n\t* config/i386/i386.h: Ditto.\n\t* config/rs6000/rs6000.c: Ditto.\n\t* config/rs6000/rs6000.h: Ditto.\n\t* config/sh/sh.c: Ditto.\n\t* config/sh/sh.h: Ditto.\n\t* config/sh/sh-protos.h: Ditto.\n\t* config/sh/sh.md: Use.\n\t* doc/tm.texi: Move documentation for VECTOR_MODE_SUPPORTED_P\n\tto TARGET_VECTOR_MODE_SUPPORTED_P.\n\n2004-08-23  Eric Christopher  <echristo@redhat.com>\n\n\t* trans-types.c (gfc_type_for_mode): Remove VECTOR_TYPE_SUPPORTED_P\n\tusage. Use build_vector_type_for_mode for vector types.\n\nFrom-SVN: r86453", "tree": {"sha": "7636aad680528291a6fa22918ea3a0c18c83943b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7636aad680528291a6fa22918ea3a0c18c83943b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f676971a92dcc163394d15c819e904cbed2438d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f676971a92dcc163394d15c819e904cbed2438d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f676971a92dcc163394d15c819e904cbed2438d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f676971a92dcc163394d15c819e904cbed2438d6/comments", "author": null, "committer": null, "parents": [{"sha": "a43b7e0fd7e33918218b26302e1bac209f76cd07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a43b7e0fd7e33918218b26302e1bac209f76cd07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a43b7e0fd7e33918218b26302e1bac209f76cd07"}], "stats": {"total": 2621, "additions": 1354, "deletions": 1267}, "files": [{"sha": "796a655c24693813d891c5c25dc0a4a3b1a41cb7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -1,3 +1,31 @@\n+2004-08-23  Eric Christopher  <echristo@redhat.com>\n+\n+\t* defaults.h (VECTOR_MODE_SUPPORTED_P): Remove macro.\n+\t* system.h (VECTOR_MODE_SUPPORTED_P): Poison.\n+\t* target-def.h (TARGET_VECTOR_MODE_SUPPORTED_P): Define.\n+\t* target.h: Ditto.\n+\t* hooks.h: Include machmode.h.\n+\t(hook_bool_mode_false): Declare.\n+\t* hooks.c (hook_bool_mode_false): Define.\n+\t* expr.c (vector_mode_valid_p): Use targetm.vector_mode_supported_p.\n+\t* stor-layout.c (layout_type): Ditto.\n+\t* config/alpha/alpha.c (alpha_vector_mode_supported_p): New function.\n+\tDefine to target macro.\n+\t* config/alpha/alpha.h (VECTOR_MODE_SUPPORTED_P): Delete.\n+\t* config/arm/arm.c: Ditto. Use.\n+\t* config/arm/arm.h: Ditto.\n+\t* config/arm/arm-protos.h: Ditto.\n+\t* config/i386/i386.c: Ditto.\n+\t* config/i386/i386.h: Ditto.\n+\t* config/rs6000/rs6000.c: Ditto.\n+\t* config/rs6000/rs6000.h: Ditto.\n+\t* config/sh/sh.c: Ditto.\n+\t* config/sh/sh.h: Ditto.\n+\t* config/sh/sh-protos.h: Ditto.\n+\t* config/sh/sh.md: Use.\n+\t* doc/tm.texi: Move documentation for VECTOR_MODE_SUPPORTED_P\n+\tto TARGET_VECTOR_MODE_SUPPORTED_P.\n+\n 2004-08-23  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* Makefile.in (BUILD_ERRORS): Set to build-errors.\n@@ -418,7 +446,7 @@\n \t(copyprop_hardreg_forward_1): Update call to kill_value_regno.\n \n 2004-08-20  Daniel Berlin  <dberlin@dberlin.org>\n-\t\n+\n \tFix PR tree-optimization/17111\n \t* tree-ssa-pre.c (create_value_expr_from): Don't change the types\n \tof non-value_handles.\n@@ -605,8 +633,8 @@\n \t(override_options): Added checks for the new options.\n \t(s390_emit_prologue): Emit stack check and trap code and perform\n \tcompile time stack size checking.\n-\t\n-\t* config/s390/s390.h (TARGET_OPTIONS): Added new options \n+\n+\t* config/s390/s390.h (TARGET_OPTIONS): Added new options\n \t\"warn-framesize\", \"warn-dynamicstack\", \"stack-size\" and\n \t\"stack-guard\".\n "}, {"sha": "a92adeb5de3d9f189da67a401fad4c134f666556", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 122, "deletions": 108, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on the DEC Alpha.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc. \n+   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GCC.\n@@ -57,7 +57,7 @@ Boston, MA 02111-1307, USA.  */\n /* Specify which cpu to schedule for.  */\n \n enum processor_type alpha_cpu;\n-static const char * const alpha_cpu_name[] = \n+static const char * const alpha_cpu_name[] =\n {\n   \"ev4\", \"ev5\", \"ev6\"\n };\n@@ -247,7 +247,7 @@ override_options (void)\n     { \"21264a\",\tPROCESSOR_EV6, EV6_MASK|MASK_CIX },\n     { 0, 0, 0 }\n   };\n-                  \n+\n   /* Unicos/Mk doesn't have shared libraries.  */\n   if (TARGET_ABI_UNICOSMK && flag_pic)\n     {\n@@ -256,7 +256,7 @@ override_options (void)\n       flag_pic = 0;\n     }\n \n-  /* On Unicos/Mk, the native compiler consistently generates /d suffices for \n+  /* On Unicos/Mk, the native compiler consistently generates /d suffices for\n      floating-point instructions.  Make that the default for this target.  */\n   if (TARGET_ABI_UNICOSMK)\n     alpha_fprm = ALPHA_FPRM_DYN;\n@@ -266,7 +266,7 @@ override_options (void)\n   alpha_tp = ALPHA_TP_PROG;\n   alpha_fptm = ALPHA_FPTM_N;\n \n-  /* We cannot use su and sui qualifiers for conversion instructions on \n+  /* We cannot use su and sui qualifiers for conversion instructions on\n      Unicos/Mk.  I'm not sure if this is due to assembler or hardware\n      limitations.  Right now, we issue a warning if -mieee is specified\n      and then ignore it; eventually, we should either get it right or\n@@ -432,7 +432,7 @@ override_options (void)\n \t     && ISDIGIT ((unsigned char)alpha_mlat_string[1])\n \t     && alpha_mlat_string[2] == '\\0')\n       {\n-\tstatic int const cache_latency[][4] = \n+\tstatic int const cache_latency[][4] =\n \t{\n \t  { 3, 30, -1 },\t/* ev4 -- Bcache is a guess */\n \t  { 2, 12, 38 },\t/* ev5 -- Bcache from PC164 LMbench numbers */\n@@ -519,7 +519,7 @@ zap_mask (HOST_WIDE_INT value)\n   return 1;\n }\n \n-/* Return true if OP is valid for a particular TLS relocation. \n+/* Return true if OP is valid for a particular TLS relocation.\n    We are already guaranteed that OP is a CONST.  */\n \n int\n@@ -670,6 +670,19 @@ alpha_extra_constraint (rtx value, int c)\n     }\n }\n \n+/* Implements target hook vector_mode_supported_p.  */\n+static bool\n+alpha_vector_mode_supported_p (enum machine_mode mode)\n+{\n+  if (TARGET_MAX\n+      && ((mode == V8QImode)\n+\t  || (mode == V4HImode)\n+\t  || (mode == V2SImode)))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Return 1 if this function can directly return via $26.  */\n \n int\n@@ -1015,7 +1028,7 @@ alpha_legitimize_address (rtx x, rtx scratch,\n \t  tga = get_tls_get_addr ();\n \t  dest = gen_reg_rtx (Pmode);\n \t  seq = GEN_INT (alpha_next_sequence_number++);\n-\t  \n+\n \t  emit_insn (gen_movdi_er_tlsgd (r16, pic_offset_table_rtx, x, seq));\n \t  insn = gen_call_value_osf_tlsgd (r0, tga, seq);\n \t  insn = emit_call_insn (insn);\n@@ -1157,7 +1170,7 @@ alpha_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n    small symbolic operand until after reload.  At which point we need\n    to replace (mem (symbol_ref)) with (mem (lo_sum $29 symbol_ref))\n    so that sched2 has the proper dependency information.  */\n-/* \n+/*\n   {\"some_small_symbolic_operand\", {SET, PARALLEL, PREFETCH, UNSPEC,\t\\\n \t\t\t\t   UNSPEC_VOLATILE}},\n */\n@@ -1232,10 +1245,10 @@ alpha_cannot_copy_insn_p (rtx insn)\n     return false;\n }\n \n-  \n+\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and return the new rtx.  */\n-   \n+\n rtx\n alpha_legitimize_reload_address (rtx x,\n \t\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n@@ -1331,7 +1344,7 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n       else\n \t*total = COSTS_N_INSNS (2);\n       return true;\n-      \n+\n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n@@ -1347,7 +1360,7 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t/* Otherwise we do a load from the GOT.  */\n \t*total = COSTS_N_INSNS (optimize_size ? 1 : alpha_memory_latency);\n       return true;\n-    \n+\n     case PLUS:\n     case MINUS:\n       if (float_mode_p)\n@@ -1477,7 +1490,7 @@ get_aligned_mem (rtx ref, rtx *paligned_mem, rtx *pbitnum)\n     *pbitnum = GEN_INT ((offset & 3) * 8);\n }\n \n-/* Similar, but just get the address.  Handle the two reload cases.  \n+/* Similar, but just get the address.  Handle the two reload cases.\n    Add EXTRA_OFFSET to the address we return.  */\n \n rtx\n@@ -1509,7 +1522,7 @@ get_unaligned_address (rtx ref, int extra_offset)\n }\n \n /* On the Alpha, all (non-symbolic) constants except zero go into\n-   a floating-point register via memory.  Note that we cannot \n+   a floating-point register via memory.  Note that we cannot\n    return anything that is not a subset of CLASS, and that some\n    symbolic constants cannot be dropped to memory.  */\n \n@@ -1542,10 +1555,10 @@ alpha_preferred_reload_class(rtx x, enum reg_class class)\n /* Loading and storing HImode or QImode values to and from memory\n    usually requires a scratch register.  The exceptions are loading\n    QImode and HImode from an aligned address to a general register\n-   unless byte instructions are permitted. \n+   unless byte instructions are permitted.\n \n    We also cannot load an unaligned address or a paradoxical SUBREG\n-   into an FP register. \n+   into an FP register.\n \n    We also cannot do integral arithmetic into FP regs, as might result\n    from register elimination into a DImode fp register.  */\n@@ -1626,7 +1639,7 @@ alpha_set_memflags (rtx insn, rtx ref)\n   if (GET_CODE (ref) != MEM)\n     return;\n \n-  /* This is only called from alpha.md, after having had something \n+  /* This is only called from alpha.md, after having had something\n      generated from one of the insn patterns.  So if everything is\n      zero, the pattern is already up-to-date.  */\n   if (!MEM_VOLATILE_P (ref)\n@@ -1682,7 +1695,7 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n \t{\n \t  /* We used to use copy_to_suggested_reg (GEN_INT (c), target, mode)\n \t     but that meant that we can't handle INT_MIN on 32-bit machines\n-\t     (like NT/Alpha), because we recurse indefinitely through \n+\t     (like NT/Alpha), because we recurse indefinitely through\n \t     emit_move_insn to gen_movdi.  So instead, since we know exactly\n \t     what we want, create it explicitly.  */\n \n@@ -2333,7 +2346,7 @@ alpha_emit_conditional_branch (enum rtx_code code)\n       else\n \t{\n \t  /* ??? We mark the branch mode to be CCmode to prevent the\n-\t     compare and branch from being combined, since the compare \n+\t     compare and branch from being combined, since the compare\n \t     insn follows IEEE rules that the branch does not.  */\n \t  branch_mode = CCmode;\n \t}\n@@ -2738,7 +2751,7 @@ struct xfloating_op GTY(())\n   rtx libcall;\n };\n \n-static GTY(()) struct xfloating_op xfloating_ops[] = \n+static GTY(()) struct xfloating_op xfloating_ops[] =\n {\n   { PLUS,\t\t\"_OtsAddX\", \"OTS$ADD_X\", 0 },\n   { MINUS,\t\t\"_OtsSubX\", \"OTS$SUB_X\", 0 },\n@@ -2832,7 +2845,7 @@ alpha_compute_xfloating_mode_arg (enum rtx_code code,\n \n    Note that these functions do not follow normal calling conventions:\n    TFmode arguments are passed in two integer registers (as opposed to\n-   indirect); TFmode return values appear in R16+R17. \n+   indirect); TFmode return values appear in R16+R17.\n \n    FUNC is the function to call.\n    TARGET is where the output belongs.\n@@ -2923,7 +2936,7 @@ alpha_emit_xfloating_arith (enum rtx_code code, rtx operands[])\n   out_operands[0] = operands[1];\n   out_operands[1] = operands[2];\n   out_operands[2] = GEN_INT (mode);\n-  alpha_emit_xfloating_libcall (func, operands[0], out_operands, 3,  \n+  alpha_emit_xfloating_libcall (func, operands[0], out_operands, 3,\n \t\t\t\tgen_rtx_fmt_ee (code, TFmode, operands[1],\n \t\t\t\t\t\toperands[2]));\n }\n@@ -3025,8 +3038,8 @@ alpha_split_tfmode_pair (rtx operands[4])\n     abort ();\n }\n \n-/* Implement negtf2 or abstf2.  Op0 is destination, op1 is source, \n-   op2 is a register containing the sign bit, operation is the \n+/* Implement negtf2 or abstf2.  Op0 is destination, op1 is source,\n+   op2 is a register containing the sign bit, operation is the\n    logical operation to be performed.  */\n \n void\n@@ -3114,18 +3127,18 @@ alpha_expand_unaligned_load (rtx tgt, rtx mem, HOST_WIDE_INT size,\n     mema = force_reg (Pmode, mema);\n \n   /* AND addresses cannot be in any alias set, since they may implicitly\n-     alias surrounding code.  Ideally we'd have some alias set that \n+     alias surrounding code.  Ideally we'd have some alias set that\n      covered all types except those with alignment 8 or higher.  */\n \n   tmp = change_address (mem, DImode,\n-\t\t\tgen_rtx_AND (DImode, \n+\t\t\tgen_rtx_AND (DImode,\n \t\t\t\t     plus_constant (mema, ofs),\n \t\t\t\t     GEN_INT (-8)));\n   set_mem_alias_set (tmp, 0);\n   emit_move_insn (meml, tmp);\n \n   tmp = change_address (mem, DImode,\n-\t\t\tgen_rtx_AND (DImode, \n+\t\t\tgen_rtx_AND (DImode,\n \t\t\t\t     plus_constant (mema, ofs + size - 1),\n \t\t\t\t     GEN_INT (-8)));\n   set_mem_alias_set (tmp, 0);\n@@ -3153,7 +3166,7 @@ alpha_expand_unaligned_load (rtx tgt, rtx mem, HOST_WIDE_INT size,\n \t addr for the target, because addr is marked as a pointer and combine\n \t knows that pointers are always sign-extended 32 bit values.  */\n       addr = expand_binop (DImode, ior_optab, extl, exth, tgt, 1, OPTAB_WIDEN);\n-      addr = expand_binop (DImode, ashr_optab, addr, GEN_INT (48), \n+      addr = expand_binop (DImode, ashr_optab, addr, GEN_INT (48),\n \t\t\t   addr, 1, OPTAB_WIDEN);\n     }\n   else\n@@ -3225,7 +3238,7 @@ alpha_expand_unaligned_store (rtx dst, rtx src,\n \t\t\t      HOST_WIDE_INT size, HOST_WIDE_INT ofs)\n {\n   rtx dstl, dsth, addr, insl, insh, meml, memh, dsta;\n-  \n+\n   dstl = gen_reg_rtx (DImode);\n   dsth = gen_reg_rtx (DImode);\n   insl = gen_reg_rtx (DImode);\n@@ -3236,17 +3249,17 @@ alpha_expand_unaligned_store (rtx dst, rtx src,\n     dsta = force_reg (Pmode, dsta);\n \n   /* AND addresses cannot be in any alias set, since they may implicitly\n-     alias surrounding code.  Ideally we'd have some alias set that \n+     alias surrounding code.  Ideally we'd have some alias set that\n      covered all types except those with alignment 8 or higher.  */\n \n   meml = change_address (dst, DImode,\n-\t\t\t gen_rtx_AND (DImode, \n+\t\t\t gen_rtx_AND (DImode,\n \t\t\t\t      plus_constant (dsta, ofs),\n \t\t\t\t      GEN_INT (-8)));\n   set_mem_alias_set (meml, 0);\n \n   memh = change_address (dst, DImode,\n-\t\t\t gen_rtx_AND (DImode, \n+\t\t\t gen_rtx_AND (DImode,\n \t\t\t\t      plus_constant (dsta, ofs + size - 1),\n \t\t\t\t      GEN_INT (-8)));\n   set_mem_alias_set (memh, 0);\n@@ -3340,7 +3353,7 @@ alpha_expand_unaligned_store (rtx dst, rtx src,\n       dsth = expand_binop (DImode, ior_optab, insh, dsth, dsth, 0, OPTAB_WIDEN);\n       dstl = expand_binop (DImode, ior_optab, insl, dstl, dstl, 0, OPTAB_WIDEN);\n     }\n- \n+\n   if (WORDS_BIG_ENDIAN)\n     {\n       emit_move_insn (meml, dstl);\n@@ -3388,7 +3401,7 @@ alpha_expand_unaligned_load_words (rtx *out_regs, rtx smem,\n \n   if (ofs != 0)\n     smem = adjust_address (smem, GET_MODE (smem), ofs);\n-  \n+\n   /* Load up all of the source data.  */\n   for (i = 0; i < words; ++i)\n     {\n@@ -3408,11 +3421,11 @@ alpha_expand_unaligned_load_words (rtx *out_regs, rtx smem,\n   emit_move_insn (data_regs[words], tmp);\n \n   /* Extract the half-word fragments.  Unfortunately DEC decided to make\n-     extxh with offset zero a noop instead of zeroing the register, so \n+     extxh with offset zero a noop instead of zeroing the register, so\n      we must take care of that edge condition ourselves with cmov.  */\n \n   sreg = copy_addr_to_reg (smema);\n-  areg = expand_binop (DImode, and_optab, sreg, GEN_INT (7), NULL, \n+  areg = expand_binop (DImode, and_optab, sreg, GEN_INT (7), NULL,\n \t\t       1, OPTAB_WIDEN);\n   if (WORDS_BIG_ENDIAN)\n     emit_move_insn (sreg, plus_constant (sreg, 7));\n@@ -3467,7 +3480,7 @@ alpha_expand_unaligned_store_words (rtx *data_regs, rtx dmem,\n       ins_tmps[i] = gen_reg_rtx(DImode);\n   st_tmp_1 = gen_reg_rtx(DImode);\n   st_tmp_2 = gen_reg_rtx(DImode);\n-  \n+\n   if (ofs != 0)\n     dmem = adjust_address (dmem, GET_MODE (dmem), ofs);\n \n@@ -3575,7 +3588,7 @@ alpha_expand_block_move (rtx operands[])\n   rtx data_regs[2 * MAX_MOVE_WORDS + 16];\n   rtx tmp;\n   unsigned int i, words, ofs, nregs = 0;\n-  \n+\n   if (orig_bytes <= 0)\n     return 1;\n   else if (orig_bytes > MAX_MOVE_WORDS * UNITS_PER_WORD)\n@@ -3603,7 +3616,7 @@ alpha_expand_block_move (rtx operands[])\n \t    src_align = 16;\n \t}\n     }\n-\t\n+\n   tmp = XEXP (orig_dst, 0);\n   if (GET_CODE (tmp) == REG)\n     dst_align = MAX (dst_align, REGNO_POINTER_ALIGN (REGNO (tmp)));\n@@ -3767,7 +3780,7 @@ alpha_expand_block_move (rtx operands[])\n       else\n         alpha_expand_unaligned_store_words (data_regs + i, orig_dst,\n \t\t\t\t\t    words, ofs);\n-     \n+\n       i += words;\n       ofs += words * 8;\n     }\n@@ -3822,7 +3835,7 @@ alpha_expand_block_clear (rtx operands[])\n   rtx orig_dst = operands[0];\n   rtx tmp;\n   int i, words, ofs = 0;\n-  \n+\n   if (orig_bytes <= 0)\n     return 1;\n   if (orig_bytes > MAX_MOVE_WORDS * UNITS_PER_WORD)\n@@ -4229,7 +4242,7 @@ struct machine_function GTY(())\n static struct machine_function *\n alpha_init_machine_status (void)\n {\n-  return ((struct machine_function *) \n+  return ((struct machine_function *)\n \t\tggc_alloc_cleared (sizeof (struct machine_function)));\n }\n \n@@ -4372,7 +4385,7 @@ get_round_mode_suffix (void)\n \t{\n \tcase ALPHA_FPRM_NORM:\n \t  return NULL;\n-\tcase ALPHA_FPRM_MINF: \n+\tcase ALPHA_FPRM_MINF:\n \t  return \"m\";\n \tcase ALPHA_FPRM_CHOP:\n \t  return \"c\";\n@@ -4661,7 +4674,7 @@ print_operand (FILE *file, rtx x, int code)\n       if (GET_CODE (x) != CONST_INT\n \t  || (unsigned HOST_WIDE_INT) INTVAL (x) >= (WORDS_BIG_ENDIAN\n \t\t\t\t\t\t     ? 56\n-\t\t\t\t\t\t     : 64)  \n+\t\t\t\t\t\t     : 64)\n \t  || (INTVAL (x) & 7) != 0)\n \toutput_operand_lossage (\"invalid %%s value\");\n \n@@ -4825,7 +4838,7 @@ print_operand_address (FILE *file, rtx addr)\n \n       if (offset)\n \tfprintf (file, \"+\" HOST_WIDE_INT_PRINT_DEC, offset);\n-      \n+\n       addr = XEXP (addr, 0);\n       if (GET_CODE (addr) == REG)\n \tbasereg = REGNO (addr);\n@@ -4876,7 +4889,7 @@ print_operand_address (FILE *file, rtx addr)\n    code.  CXT is an RTX for the static chain value for the function.\n \n    The three offset parameters are for the individual template's\n-   layout.  A JMPOFS < 0 indicates that the trampoline does not \n+   layout.  A JMPOFS < 0 indicates that the trampoline does not\n    contain instructions at all.\n \n    We assume here that a function will be called many more times than\n@@ -5110,7 +5123,7 @@ alpha_return_in_memory (tree type, tree fndecl ATTRIBUTE_UNUSED)\n       break;\n \n     default:\n-      /* ??? We get called on all sorts of random stuff from \n+      /* ??? We get called on all sorts of random stuff from\n \t aggregate_value_p.  We can't abort, but it's not clear\n \t what's safe to return.  Pretend it's a struct I guess.  */\n       return true;\n@@ -5190,7 +5203,7 @@ function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n   return gen_rtx_REG (mode, regnum);\n }\n \n-/* TCmode complex values are passed by invisible reference.  We \n+/* TCmode complex values are passed by invisible reference.  We\n    should not split these values.  */\n \n static bool\n@@ -5336,7 +5349,7 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n      in order to account for the integer arg registers which are counted\n      in argsize above, but which are not actually stored on the stack.\n      Must further be careful here about structures straddling the last\n-     integer argument register; that futzes with pretend_args_size, \n+     integer argument register; that futzes with pretend_args_size,\n      which changes the meaning of AP.  */\n \n   if (NUM_ARGS <= 6)\n@@ -5869,7 +5882,7 @@ alpha_sa_mask (unsigned long *imaskP, unsigned long *fmaskP)\n \t zero in the prologue of _Unwind_RaiseException et al.  */\n       imask |= 1UL << 31;\n     }\n-     \n+\n   /* If any register spilled, then spill the return address also.  */\n   /* ??? This is required by the Digital stack unwind specification\n      and isn't needed if we're doing Dwarf2 unwinding.  */\n@@ -6070,7 +6083,7 @@ alpha_does_function_need_gp (void)\n   if (current_function_has_nonlocal_goto)\n     return 1;\n \n-  /* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first. \n+  /* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first.\n      Even if we are a static function, we still need to do this in case\n      our address is taken and passed to something like qsort.  */\n \n@@ -6159,7 +6172,7 @@ alpha_expand_prologue (void)\n \n   frame_size = get_frame_size ();\n   if (TARGET_ABI_OPEN_VMS)\n-    frame_size = ALPHA_ROUND (sa_size \n+    frame_size = ALPHA_ROUND (sa_size\n \t\t\t      + (alpha_procedure_type == PT_STACK ? 8 : 0)\n \t\t\t      + frame_size\n \t\t\t      + current_function_pretend_args_size);\n@@ -6205,7 +6218,7 @@ alpha_expand_prologue (void)\n      4096 bytes (we can probably get away without the latter test) and\n      every 8192 bytes in between.  If the frame size is > 32768, we\n      do this in a loop.  Otherwise, we generate the explicit probe\n-     instructions. \n+     instructions.\n \n      Note that we are only allowed to adjust sp once in the prologue.  */\n \n@@ -6266,7 +6279,7 @@ alpha_expand_prologue (void)\n \t  /* For NT stack unwind (done by 'reverse execution'), it's\n \t     not OK to take the result of a loop, even though the value\n \t     is already in ptr, so we reload it via a single operation\n-\t     and subtract it to sp. \n+\t     and subtract it to sp.\n \n \t     Yes, that's correct -- we have to reload the whole constant\n \t     into a temporary via ldah+lda then subtract from sp.  */\n@@ -6311,14 +6324,14 @@ alpha_expand_prologue (void)\n \n \t  if (low + sa_size <= 0x8000)\n \t    bias = reg_offset - low, reg_offset = low;\n-\t  else \n+\t  else\n \t    bias = reg_offset, reg_offset = 0;\n \n \t  sa_reg = gen_rtx_REG (DImode, 24);\n \t  FRP (emit_insn (gen_adddi3 (sa_reg, stack_pointer_rtx,\n \t\t\t\t      GEN_INT (bias))));\n \t}\n-    \n+\n       /* Save regs in stack order.  Beginning with VMS PV.  */\n       if (TARGET_ABI_OPEN_VMS && alpha_procedure_type == PT_STACK)\n \t{\n@@ -6421,12 +6434,12 @@ alpha_expand_prologue (void)\n       if (current_function_outgoing_args_size != 0)\n \t{\n \t  rtx seq\n-\t    = emit_move_insn (stack_pointer_rtx, \n+\t    = emit_move_insn (stack_pointer_rtx,\n \t\t\t      plus_constant\n \t\t\t      (hard_frame_pointer_rtx,\n \t\t\t       - (ALPHA_ROUND\n \t\t\t\t  (current_function_outgoing_args_size))));\n-\t  \n+\n \t  /* Only set FRAME_RELATED_P on the stack adjustment we just emitted\n \t     if ! frame_pointer_needed. Setting the bit will change the CFA\n \t     computation rule to use sp again, which would be wrong if we had\n@@ -6466,7 +6479,7 @@ alpha_expand_prologue (void)\n      (clobber:BLK (scratch)), but this doesn't work for fp insns.  So we\n      have to prevent all such scheduling with a blockage.\n \n-     Linux, on the other hand, never bothered to implement OSF/1's \n+     Linux, on the other hand, never bothered to implement OSF/1's\n      exception handling, and so doesn't care about such things.  Anyone\n      planning to use dwarf2 frame-unwind info can also omit the blockage.  */\n \n@@ -6504,7 +6517,7 @@ alpha_start_function (FILE *file, const char *fnname,\n \n   frame_size = get_frame_size ();\n   if (TARGET_ABI_OPEN_VMS)\n-    frame_size = ALPHA_ROUND (sa_size \n+    frame_size = ALPHA_ROUND (sa_size\n \t\t\t      + (alpha_procedure_type == PT_STACK ? 8 : 0)\n \t\t\t      + frame_size\n \t\t\t      + current_function_pretend_args_size);\n@@ -6675,7 +6688,7 @@ alpha_output_function_end_prologue (FILE *file)\n \n /* Write function epilogue.  */\n \n-/* ??? At some point we will want to support full unwind, and so will \n+/* ??? At some point we will want to support full unwind, and so will\n    need to mark the epilogue as well.  At the moment, we just confuse\n    dwarf2out.  */\n #undef FRP\n@@ -6703,7 +6716,7 @@ alpha_expand_epilogue (void)\n \n   frame_size = get_frame_size ();\n   if (TARGET_ABI_OPEN_VMS)\n-    frame_size = ALPHA_ROUND (sa_size \n+    frame_size = ALPHA_ROUND (sa_size\n \t\t\t      + (alpha_procedure_type == PT_STACK ? 8 : 0)\n \t\t\t      + frame_size\n \t\t\t      + current_function_pretend_args_size);\n@@ -6757,15 +6770,15 @@ alpha_expand_epilogue (void)\n \n \t  if (low + sa_size <= 0x8000)\n \t    bias = reg_offset - low, reg_offset = low;\n-\t  else \n+\t  else\n \t    bias = reg_offset, reg_offset = 0;\n \n \t  sa_reg = gen_rtx_REG (DImode, 22);\n \t  sa_reg_exp = plus_constant (stack_pointer_rtx, bias);\n \n \t  FRP (emit_move_insn (sa_reg, sa_reg_exp));\n \t}\n-\t  \n+\n       /* Restore registers in order, excepting a true frame pointer.  */\n \n       mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n@@ -6920,7 +6933,7 @@ alpha_expand_epilogue (void)\n \tFRP (emit_move_insn (stack_pointer_rtx,\n \t\t\t     gen_rtx_PLUS (DImode, sp_adj1, sp_adj2)));\n     }\n-  else \n+  else\n     {\n       if (TARGET_ABI_OPEN_VMS && alpha_procedure_type == PT_REGISTER)\n         {\n@@ -7266,7 +7279,7 @@ summarize_insn (rtx x, struct shadow_summary *sum, int set)\n     case NEG:  case NOT:  case SIGN_EXTEND:  case ZERO_EXTEND:\n     case TRUNCATE:  case FLOAT_EXTEND:  case FLOAT_TRUNCATE:  case FLOAT:\n     case FIX:  case UNSIGNED_FLOAT:  case UNSIGNED_FIX:  case ABS:\n-    case SQRT:  case FFS: \n+    case SQRT:  case FFS:\n       summarize_insn (XEXP (x, 0), sum, 0);\n       break;\n \n@@ -7339,7 +7352,7 @@ alpha_handle_trap_shadows (void)\n   shadow.used.fp = 0;\n   shadow.used.mem = 0;\n   shadow.defd = shadow.used;\n-  \n+\n   for (i = get_insns (); i ; i = NEXT_INSN (i))\n     {\n       if (GET_CODE (i) == NOTE)\n@@ -7571,9 +7584,9 @@ alphaev5_insn_pipe (rtx insn)\n     }\n }\n \n-/* IN_USE is a mask of the slots currently filled within the insn group. \n+/* IN_USE is a mask of the slots currently filled within the insn group.\n    The mask bits come from alphaev4_pipe above.  If EV4_IBX is set, then\n-   the insn in EV4_IB0 can be swapped by the hardware into EV4_IB1. \n+   the insn in EV4_IB0 can be swapped by the hardware into EV4_IB1.\n \n    LEN is, of course, the length of the group in bytes.  */\n \n@@ -7641,7 +7654,7 @@ alphaev4_next_group (rtx insn, int *pin_use, int *plen)\n \t  abort();\n \t}\n       len += 4;\n-      \n+\n       /* Haifa doesn't do well scheduling branches.  */\n       if (GET_CODE (insn) == JUMP_INSN)\n \tgoto next_and_done;\n@@ -7669,9 +7682,9 @@ alphaev4_next_group (rtx insn, int *pin_use, int *plen)\n   return insn;\n }\n \n-/* IN_USE is a mask of the slots currently filled within the insn group. \n+/* IN_USE is a mask of the slots currently filled within the insn group.\n    The mask bits come from alphaev5_pipe above.  If EV5_E01 is set, then\n-   the insn in EV5_E0 can be swapped by the hardware into EV5_E1. \n+   the insn in EV5_E0 can be swapped by the hardware into EV5_E1.\n \n    LEN is, of course, the length of the group in bytes.  */\n \n@@ -7708,9 +7721,9 @@ alphaev5_next_group (rtx insn, int *pin_use, int *plen)\n \t    len = get_attr_length (insn);\n \t  goto next_and_done;\n \n-\t/* ??? Most of the places below, we would like to abort, as \n-\t   it would indicate an error either in Haifa, or in the \n-\t   scheduling description.  Unfortunately, Haifa never \n+\t/* ??? Most of the places below, we would like to abort, as\n+\t   it would indicate an error either in Haifa, or in the\n+\t   scheduling description.  Unfortunately, Haifa never\n \t   schedules the last instruction of the BB, so we don't\n \t   have an accurate TI bit to go off.  */\n \tcase EV5_E01:\n@@ -7770,7 +7783,7 @@ alphaev5_next_group (rtx insn, int *pin_use, int *plen)\n \t  abort();\n \t}\n       len += 4;\n-      \n+\n       /* Haifa doesn't do well scheduling branches.  */\n       /* ??? If this is predicted not-taken, slotting continues, except\n \t that no more IBR, FBR, or JSR insns may be slotted.  */\n@@ -7969,7 +7982,7 @@ alpha_align_insns (unsigned int max_align,\n \t  else\n \t    where = i;\n \n-\t  do \n+\t  do\n \t    emit_insn_before ((*next_nop)(&prev_in_use), where);\n \t  while (--nop_count);\n \t  ofs = 0;\n@@ -8033,7 +8046,7 @@ alpha_file_start (void)\n   if (TARGET_SUPPORT_ARCH | TARGET_BWX | TARGET_MAX | TARGET_FIX | TARGET_CIX)\n     fprintf (asm_out_file,\n \t     \"\\t.arch %s\\n\",\n-\t     TARGET_CPU_EV6 ? \"ev6\"\t   \n+\t     TARGET_CPU_EV6 ? \"ev6\"\n \t     : (TARGET_CPU_EV5\n \t\t? (TARGET_MAX ? \"pca56\" : TARGET_BWX ? \"ev56\" : \"ev5\")\n \t\t: \"ev4\"));\n@@ -8141,7 +8154,7 @@ alpha_need_linkage (const char *name, int is_local)\n       if (!alpha_funcs_tree)\n         alpha_funcs_tree = splay_tree_new_ggc ((splay_tree_compare_fn)\n \t\t\t\t\t       splay_tree_compare_pointers);\n-    \n+\n       cfaf = (struct alpha_funcs *) ggc_alloc (sizeof (struct alpha_funcs));\n \n       cfaf->links = 0;\n@@ -8271,7 +8284,7 @@ alpha_use_linkage (rtx linkage, tree cfundecl, int lflag, int rflag)\n     al->rkind = KIND_CODEADDR;\n   else\n     al->rkind = KIND_LINKAGE;\n-      \n+\n   if (lflag)\n     return gen_rtx_MEM (Pmode, plus_constant (al->linkage, 8));\n   else\n@@ -8394,7 +8407,7 @@ vms_asm_named_section (const char *name, unsigned int flags)\n \n /* Record an element in the table of global constructors.  SYMBOL is\n    a SYMBOL_REF of the function to be called; PRIORITY is a number\n-   between 0 and MAX_INIT_PRIORITY.  \n+   between 0 and MAX_INIT_PRIORITY.\n \n    Differs from default_ctors_section_asm_out_constructor in that the\n    width of the .ctors entry is always 64 bits, rather than the 32 bits\n@@ -8462,21 +8475,21 @@ int\n unicosmk_initial_elimination_offset (int from, int to)\n {\n   int fixed_size;\n-  \n+\n   fixed_size = alpha_sa_size();\n   if (fixed_size != 0)\n     fixed_size += 48;\n \n   if (from == FRAME_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n-    return -fixed_size; \n+    return -fixed_size;\n   else if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n     return 0;\n   else if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return (ALPHA_ROUND (current_function_outgoing_args_size)\n \t    + ALPHA_ROUND (get_frame_size()));\n   else if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return (ALPHA_ROUND (fixed_size)\n-\t    + ALPHA_ROUND (get_frame_size() \n+\t    + ALPHA_ROUND (get_frame_size()\n \t\t\t   + current_function_outgoing_args_size));\n   else\n     abort ();\n@@ -8493,7 +8506,7 @@ unicosmk_output_module_name (FILE *file)\n   unsigned len = strlen (name);\n   char *clean_name = alloca (len + 2);\n   char *ptr = clean_name;\n-  \n+\n   /* CAM only accepts module names that start with a letter or '$'. We\n      prefix the module name with a '$' if necessary.  */\n \n@@ -8563,7 +8576,7 @@ unicosmk_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n   const char *name;\n   int len;\n \n-  if (!decl) \n+  if (!decl)\n     abort ();\n \n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n@@ -8574,8 +8587,8 @@ unicosmk_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n     {\n       char *string;\n \n-      /* It is essential that we prefix the section name here because \n-\t otherwise the section names generated for constructors and \n+      /* It is essential that we prefix the section name here because\n+\t otherwise the section names generated for constructors and\n \t destructors confuse collect2.  */\n \n       string = alloca (len + 6);\n@@ -8636,7 +8649,7 @@ unicosmk_insert_attributes (tree decl, tree *attr_ptr ATTRIBUTE_UNUSED)\n \n /* Output an alignment directive. We have to use the macro 'gcc@code@align'\n    in code sections because .align fill unused space with zeroes.  */\n-      \n+\n void\n unicosmk_output_align (FILE *file, int align)\n {\n@@ -8654,10 +8667,10 @@ void\n unicosmk_defer_case_vector (rtx lab, rtx vec)\n {\n   struct machine_function *machine = cfun->machine;\n-  \n+\n   vec = gen_rtx_EXPR_LIST (VOIDmode, lab, vec);\n   machine->addr_list = gen_rtx_EXPR_LIST (VOIDmode, vec,\n-\t\t\t\t\t  machine->addr_list); \n+\t\t\t\t\t  machine->addr_list);\n }\n \n /* Output a case vector.  */\n@@ -8703,7 +8716,7 @@ unicosmk_output_deferred_case_vectors (FILE *file)\n static const char *\n unicosmk_ssib_name (void)\n {\n-  /* This is ok since CAM won't be able to deal with names longer than that \n+  /* This is ok since CAM won't be able to deal with names longer than that\n      anyway.  */\n \n   static char name[256];\n@@ -8731,8 +8744,8 @@ unicosmk_ssib_name (void)\n   return name;\n }\n \n-/* Set up the dynamic subprogram information block (DSIB) and update the \n-   frame pointer register ($15) for subroutines which have a frame. If the \n+/* Set up the dynamic subprogram information block (DSIB) and update the\n+   frame pointer register ($15) for subroutines which have a frame. If the\n    subroutine doesn't have a frame, simply increment $15.  */\n \n static void\n@@ -8889,7 +8902,7 @@ char *\n unicosmk_text_section (void)\n {\n   static int count = 0;\n-  sprintf (unicosmk_section_buf, \"\\t.endp\\n\\n\\t.psect\\tgcc@text___%d,code\", \n+  sprintf (unicosmk_section_buf, \"\\t.endp\\n\\n\\t.psect\\tgcc@text___%d,code\",\n \t\t\t\t count++);\n   return unicosmk_section_buf;\n }\n@@ -8898,7 +8911,7 @@ char *\n unicosmk_data_section (void)\n {\n   static int count = 1;\n-  sprintf (unicosmk_section_buf, \"\\t.endp\\n\\n\\t.psect\\tgcc@data___%d,data\", \n+  sprintf (unicosmk_section_buf, \"\\t.endp\\n\\n\\t.psect\\tgcc@data___%d,data\",\n \t\t\t\t count++);\n   return unicosmk_section_buf;\n }\n@@ -8952,14 +8965,14 @@ unicosmk_output_externs (FILE *file)\n   len = strlen (user_label_prefix);\n   for (p = unicosmk_extern_head; p != 0; p = p->next)\n     {\n-      /* We have to strip the encoding and possibly remove user_label_prefix \n+      /* We have to strip the encoding and possibly remove user_label_prefix\n \t from the identifier in order to handle -fleading-underscore and\n \t explicit asm names correctly (cf. gcc.dg/asm-names-1.c).  */\n       real_name = default_strip_name_encoding (p->name);\n       if (len && p->name[0] == '*'\n \t  && !memcmp (real_name, user_label_prefix, len))\n \treal_name += len;\n-\t\n+\n       name_tree = get_identifier (real_name);\n       if (! TREE_ASM_WRITTEN (name_tree))\n \t{\n@@ -8970,7 +8983,7 @@ unicosmk_output_externs (FILE *file)\n \t}\n     }\n }\n-      \n+\n /* Record an extern.  */\n \n void\n@@ -8998,10 +9011,10 @@ struct unicosmk_dex {\n   const char *name;\n };\n \n-/* List of identifiers which have been replaced by DEX expressions. The DEX \n+/* List of identifiers which have been replaced by DEX expressions. The DEX\n    number is determined by the position in the list.  */\n \n-static struct unicosmk_dex *unicosmk_dex_list = NULL; \n+static struct unicosmk_dex *unicosmk_dex_list = NULL;\n \n /* The number of elements in the DEX list.  */\n \n@@ -9044,7 +9057,7 @@ unicosmk_need_dex (rtx x)\n   struct unicosmk_dex *dex;\n   const char *name;\n   int i;\n-  \n+\n   if (GET_CODE (x) != SYMBOL_REF)\n     return 0;\n \n@@ -9059,7 +9072,7 @@ unicosmk_need_dex (rtx x)\n         return i;\n       --i;\n     }\n-      \n+\n   dex = (struct unicosmk_dex *) xmalloc (sizeof (struct unicosmk_dex));\n   dex->name = name;\n   dex->next = unicosmk_dex_list;\n@@ -9090,13 +9103,13 @@ unicosmk_output_dex (FILE *file)\n       putc ('\\n', file);\n       --i;\n     }\n-  \n+\n   fprintf (file, \"\\t.dexend\\n\");\n }\n \n /* Output text that to appear at the beginning of an assembler file.  */\n \n-static void \n+static void\n unicosmk_file_start (void)\n {\n   int i;\n@@ -9159,7 +9172,7 @@ unicosmk_file_end (void)\n \n   unicosmk_output_externs (asm_out_file);\n \n-  /* Output dex definitions used for functions whose names conflict with \n+  /* Output dex definitions used for functions whose names conflict with\n      register names.  */\n \n   unicosmk_output_dex (asm_out_file);\n@@ -9349,6 +9362,8 @@ alpha_init_libfuncs (void)\n #define TARGET_SPLIT_COMPLEX_ARG alpha_split_complex_arg\n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR alpha_gimplify_va_arg\n+#undef TARGET_VECTOR_MODE_SUPPORTED_P\n+#define TARGET_VECTOR_MODE_SUPPORTED_P alpha_vector_mode_supported_p\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST alpha_build_builtin_va_list\n@@ -9357,4 +9372,3 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f\n #include \"gt-alpha.h\"\n-"}, {"sha": "fd2754bd05af8701fac27236f8a454b60110d753", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -231,7 +231,7 @@ extern int alpha_tls_size;\n #define MASK_SMALL_TEXT (1 << 15)\n #define TARGET_SMALL_TEXT (target_flags & MASK_SMALL_TEXT)\n \n-/* This means use IEEE quad-format for long double.  Assumes the \n+/* This means use IEEE quad-format for long double.  Assumes the\n    presence of the GEM support library routines.  */\n #define MASK_LONG_DOUBLE_128 (1 << 16)\n #define TARGET_LONG_DOUBLE_128 (target_flags & MASK_LONG_DOUBLE_128)\n@@ -466,7 +466,7 @@ extern const char *alpha_tls_size_string; /* For -mtls-size= */\n #define\tWCHAR_TYPE_SIZE 32\n \n /* Define this macro if it is advisable to hold scalars in registers\n-   in a wider mode than that declared by the program.  In such cases, \n+   in a wider mode than that declared by the program.  In such cases,\n    the value is constrained to be within the bounds of the declared\n    type, but kept valid in the wider mode.  The signedness of the\n    extension may differ from that of the type.\n@@ -572,7 +572,7 @@ extern const char *alpha_tls_size_string; /* For -mtls-size= */\n    We define all 32 integer registers, even though $31 is always zero,\n    and all 32 floating-point registers, even though $f31 is also\n    always zero.  We do not bother defining the FP status register and\n-   there are no other registers. \n+   there are no other registers.\n \n    Since $31 is always zero, we will use register number 31 as the\n    argument pointer.  It will never appear in the generated code\n@@ -649,12 +649,6 @@ extern const char *alpha_tls_size_string; /* For -mtls-size= */\n    ? (MODE) == SFmode || (MODE) == DFmode || (MODE) == DImode\t\t\\\n    : 1)\n \n-/* Value is 1 if MODE is a supported vector mode.  */\n-\n-#define VECTOR_MODE_SUPPORTED_P(MODE) \\\n-  (TARGET_MAX \\\n-   && ((MODE) == V8QImode || (MODE) == V4HImode || (MODE) == V2SImode))\n-\n /* A C expression that is nonzero if a value of mode\n    MODE1 is accessible in mode MODE2 without copying.\n \n@@ -690,7 +684,7 @@ extern const char *alpha_tls_size_string; /* For -mtls-size= */\n /* Base register for access to local variables of function.  */\n #define FRAME_POINTER_REGNUM 63\n \n-/* Register in which static-chain is passed to a function. \n+/* Register in which static-chain is passed to a function.\n \n    For the Alpha, this is based on an example; the calling sequence\n    doesn't seem to specify this.  */\n@@ -727,7 +721,7 @@ extern const char *alpha_tls_size_string; /* For -mtls-size= */\n \n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n-   \n+\n enum reg_class {\n   NO_REGS, R0_REG, R24_REG, R25_REG, R27_REG,\n   GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n@@ -820,7 +814,7 @@ enum reg_class {\n    `R' is a SYMBOL_REF that has SYMBOL_REF_FLAG set or is the current\n    function.\n \n-   'S' is a 6-bit constant (valid for a shift insn).  \n+   'S' is a 6-bit constant (valid for a shift insn).\n \n    'T' is a HIGH.\n \n@@ -880,7 +874,7 @@ enum reg_class {\n    ? reg_classes_intersect_p (FLOAT_REGS, CLASS) : 0)\n \n /* Define the cost of moving between registers of various classes.  Moving\n-   between FLOAT_REGS and anything else except float regs is expensive. \n+   between FLOAT_REGS and anything else except float regs is expensive.\n    In fact, we make it quite expensive because we really don't want to\n    do these moves unless it is clearly worth it.  Optimizations may\n    reduce the impact of not being able to allocate a pseudo to a\n@@ -1111,7 +1105,7 @@ extern struct alpha_compare alpha_compare;\n \n #define ASM_DECLARE_FUNCTION_SIZE(FILE,NAME,DECL) \\\n   alpha_end_function(FILE,NAME,DECL)\n-   \n+\n /* Output any profiling code before the prologue.  */\n \n #define PROFILE_BEFORE_PROLOGUE 1\n@@ -1141,7 +1135,7 @@ extern struct alpha_compare alpha_compare;\n    of a trampoline, leaving space for the variable parts.\n \n    The trampoline should set the static chain pointer to value placed\n-   into the trampoline and should branch to the specified routine.  \n+   into the trampoline and should branch to the specified routine.\n    Note that $27 has been set to the address of the trampoline, so we can\n    use it for addressability of the two data items.  */\n \n@@ -1301,7 +1295,7 @@ do {\t\t\t\t\t\t\t\t\\\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n    macro is used in only one place: `find_reloads_address' in reload.c.  */\n-   \n+\n #define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_L,WIN)\t\t     \\\n do {\t\t\t\t\t\t\t\t\t     \\\n   rtx new_x = alpha_legitimize_reload_address (X, MODE, OPNUM, TYPE, IND_L); \\\n@@ -1356,7 +1350,7 @@ do {\t\t\t\t\t\t\t\t\t     \\\n \n /* Nonzero if access to memory by bytes is no faster than for words.\n    Also nonzero if doing byte operations (specifically shifts) in registers\n-   is undesirable. \n+   is undesirable.\n \n    On the Alpha, we want to not use the byte operation and instead use\n    masking operations to access fields; these will save instructions.  */"}, {"sha": "efe12074a170c053b4ed95158a731ea3c85463e3", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -44,6 +44,7 @@ extern int arm_return_in_memory (tree);\n extern void arm_encode_call_attribute (tree, int);\n #endif\n #ifdef RTX_CODE\n+extern bool arm_vector_mode_supported_p (enum machine_mode);\n extern int arm_hard_regno_mode_ok (unsigned int, enum machine_mode);\n extern int const_ok_for_arm (HOST_WIDE_INT);\n extern int arm_split_constant (RTX_CODE, enum machine_mode, rtx,\n@@ -162,7 +163,7 @@ extern bool arm_needs_doubleword_align (enum machine_mode, tree);\n extern rtx arm_function_value(tree, tree);\n #endif\n \n-#if defined AOF_ASSEMBLER \n+#if defined AOF_ASSEMBLER\n extern rtx aof_pic_entry (rtx);\n extern char *aof_text_section (void);\n extern char *aof_data_section (void);"}, {"sha": "63dc8499d10bc6b179e062f1cd19c1f4370cddce", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 460, "deletions": 446, "changes": 906, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f676971a92dcc163394d15c819e904cbed2438d6"}, {"sha": "dea88f1ee8c513ebbfb994550c8b891f70a9900d", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 41, "deletions": 44, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -229,7 +229,7 @@ extern GTY(()) rtx aof_pic_label;\n /* Nonzero if we need to protect the prolog from scheduling */\n #define ARM_FLAG_NO_SCHED_PRO\t(1 << 12)\n \n-/* Nonzero if a call to abort should be generated if a noreturn \n+/* Nonzero if a call to abort should be generated if a noreturn\n    function tries to return.  */\n #define ARM_FLAG_ABORT_NORETURN\t(1 << 13)\n \n@@ -238,7 +238,7 @@ extern GTY(()) rtx aof_pic_label;\n \n /* Nonzero if all call instructions should be indirect.  */\n #define ARM_FLAG_LONG_CALLS\t(1 << 15)\n-  \n+\n /* Nonzero means that the target ISA is the THUMB, not the ARM.  */\n #define ARM_FLAG_THUMB          (1 << 16)\n \n@@ -302,7 +302,7 @@ extern GTY(()) rtx aof_pic_label;\n    etc., in addition to just the AAPCS calling conventions.  */\n #ifndef TARGET_BPABI\n #define TARGET_BPABI false\n-#endif \n+#endif\n \n /* SUBTARGET_SWITCHES is used to add flags on a per-config basis.  */\n #ifndef SUBTARGET_SWITCHES\n@@ -537,7 +537,7 @@ extern int arm_tune_xscale;\n extern int arm_is_6_or_7;\n \n /* Nonzero if we should define __THUMB_INTERWORK__ in the\n-   preprocessor.  \n+   preprocessor.\n    XXX This is a bit of a hack, it's intended to help work around\n    problems in GLD which doesn't understand that armv5t code is\n    interworking clean.  */\n@@ -566,13 +566,13 @@ extern int arm_cpp_interwork;\n /* Nonzero if we need to refer to the GOT with a PC-relative\n    offset.  In other words, generate\n \n-   .word\t_GLOBAL_OFFSET_TABLE_ - [. - (.Lxx + 8)]  \n+   .word\t_GLOBAL_OFFSET_TABLE_ - [. - (.Lxx + 8)]\n \n    rather than\n \n    .word\t_GLOBAL_OFFSET_TABLE_ - (.Lxx + 8)\n \n-   The default is true, which matches NetBSD.  Subtargets can \n+   The default is true, which matches NetBSD.  Subtargets can\n    override this if required.  */\n #ifndef GOT_PCREL\n #define GOT_PCREL   1\n@@ -609,7 +609,7 @@ extern int arm_cpp_interwork;\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN  0\n \n-/* Define this if most significant byte of a word is the lowest numbered.  \n+/* Define this if most significant byte of a word is the lowest numbered.\n    Most ARM processors are run in little endian mode, so that is the default.\n    If you want to have it run-time selectable, change the definition in a\n    cover file to be TARGET_BIG_ENDIAN.  */\n@@ -667,7 +667,7 @@ extern int arm_cpp_interwork;\n \n /* Make strings word-aligned so strcpy from constants will be faster.  */\n #define CONSTANT_ALIGNMENT_FACTOR (TARGET_THUMB || ! arm_tune_xscale ? 1 : 2)\n-    \n+\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\t\t\t\\\n    ((TREE_CODE (EXP) == STRING_CST\t\t\t\t\\\n      && (ALIGN) < BITS_PER_WORD * CONSTANT_ALIGNMENT_FACTOR)\t\\\n@@ -725,7 +725,7 @@ extern const char * structure_size_string;\n \n \tr4-r8\t     S\tregister variable\n \tr9\t     S\t(rfp) register variable (real frame pointer)\n-\t\n+\n \tr10  \t   F S\t(sl) stack limit (used by -mapcs-stack-check)\n \tr11 \t   F S\t(fp) argument pointer\n \tr12\t\t(ip) temp workspace\n@@ -809,7 +809,7 @@ extern const char * structure_size_string;\n    The latter must include the registers where values are returned\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.\n-   The CC is not preserved over function calls on the ARM 6, so it is \n+   The CC is not preserved over function calls on the ARM 6, so it is\n    easier to assume this for all.  SFP is preserved, since FP is.  */\n #define CALL_USED_REGISTERS  \\\n {                            \\\n@@ -922,7 +922,7 @@ extern const char * structure_size_string;\n     }\t\t\t\t\t\t\t\t\\\n   SUBTARGET_CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n }\n-    \n+\n /* These are a couple of extensions to the formats accepted\n    by asm_fprintf:\n      %@ prints out ASM_COMMENT_START\n@@ -975,7 +975,7 @@ extern const char * structure_size_string;\n #define MUST_USE_SJLJ_EXCEPTIONS 1\n /* We can generate DWARF2 Unwind info, even though we don't use it.  */\n #define DWARF2_UNWIND_INFO 1\n-\t\t\t     \n+\n /* Use r0 and r1 to pass exception handling information.  */\n #define EH_RETURN_DATA_REGNO(N) (((N) < 2) ? N : INVALID_REGNUM)\n \n@@ -1054,7 +1054,7 @@ extern const char * structure_size_string;\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms may be accessed\n-   via the stack pointer) in functions that seem suitable.  \n+   via the stack pointer) in functions that seem suitable.\n    If we have to have a frame pointer we might as well make use of it.\n    APCS says that the frame pointer does not need to be pushed in leaf\n    functions, or simple tail call functions.  */\n@@ -1088,16 +1088,13 @@ extern const char * structure_size_string;\n #define MODES_TIEABLE_P(MODE1, MODE2)  \\\n   (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n \n-#define VECTOR_MODE_SUPPORTED_P(MODE) \\\n- ((MODE) == V2SImode || (MODE) == V4HImode || (MODE) == V8QImode)\n-\n #define VALID_IWMMXT_REG_MODE(MODE) \\\n- (VECTOR_MODE_SUPPORTED_P (MODE) || (MODE) == DImode)\n+ (arm_vector_mode_supported_p (MODE) || (MODE) == DImode)\n \n /* The order in which register should be allocated.  It is good to use ip\n    since no saving is required (though calls clobber it) and it never contains\n    function parameters.  It is quite good to use lr since other calls may\n-   clobber it anyway.  Allocate r0 through r3 in reverse order since r3 is \n+   clobber it anyway.  Allocate r0 through r3 in reverse order since r3 is\n    least likely to contain a function parameter; in addition results are\n    returned in r0.  */\n \n@@ -1212,7 +1209,7 @@ enum reg_class\n #define CLASS_LIKELY_SPILLED_P(CLASS)\t\\\n     ((TARGET_THUMB && (CLASS) == LO_REGS)\t\\\n      || (CLASS) == CC_REG)\n-\t\t\t\t      \n+\n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS  (TARGET_THUMB ? LO_REGS : GENERAL_REGS)\n #define BASE_REG_CLASS   (TARGET_THUMB ? LO_REGS : GENERAL_REGS)\n@@ -1255,9 +1252,9 @@ enum reg_class\n    C is the letter, and VALUE is a constant value.\n    Return 1 if VALUE is in the range specified by C.\n \tI: immediate arithmetic operand (i.e. 8 bits shifted as required).\n-\tJ: valid indexing constants.  \n+\tJ: valid indexing constants.\n \tK: ~value ok in rhs argument of data operand.\n-\tL: -value ok in rhs argument of data operand. \n+\tL: -value ok in rhs argument of data operand.\n         M: 0..32, or a power of 2  (for shifts, or mult done by shift).  */\n #define CONST_OK_FOR_ARM_LETTER(VALUE, C)  \t\t\\\n   ((C) == 'I' ? const_ok_for_arm (VALUE) :\t\t\\\n@@ -1282,7 +1279,7 @@ enum reg_class\n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n   (TARGET_ARM ?\t\t\t\t\t\t\t\t\\\n    CONST_OK_FOR_ARM_LETTER (VALUE, C) : CONST_OK_FOR_THUMB_LETTER (VALUE, C))\n-     \n+\n /* Constant letter 'G' for the FP immediate constants.\n    'H' means the same constant negated.  */\n #define CONST_DOUBLE_OK_FOR_ARM_LETTER(X, C)\t\t\t\\\n@@ -1294,13 +1291,13 @@ enum reg_class\n    CONST_DOUBLE_OK_FOR_ARM_LETTER (X, C) : 0)\n \n /* For the ARM, `Q' means that this is a memory operand that is just\n-   an offset from a register.  \n+   an offset from a register.\n    `S' means any symbol that has the SYMBOL_REF_FLAG set or a CONSTANT_POOL\n    address.  This means that the symbol is in the text segment and can be\n    accessed without using a load.\n    'U' Prefixes an extended memory constraint where:\n-   'Uv' is an address valid for VFP load/store insns.  \n-   'Uy' is an address valid for iwmmxt load/store insns.  \n+   'Uv' is an address valid for VFP load/store insns.\n+   'Uy' is an address valid for iwmmxt load/store insns.\n    'Uq' is an address valid for ldrsb.  */\n \n #define EXTRA_CONSTRAINT_STR_ARM(OP, C, STR)\t\t\t\\\n@@ -1366,7 +1363,7 @@ enum reg_class\n    ? (((MODE) == HImode && ! arm_arch4 && true_regnum (X) == -1) \\\n     ? GENERAL_REGS : NO_REGS)\t\t\t\t\t\\\n    : THUMB_SECONDARY_OUTPUT_RELOAD_CLASS (CLASS, MODE, X))\n-   \n+\n /* If we need to load shorts byte-at-a-time, then we need a scratch.  */\n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n   /* Restrict which direct reloads are allowed for VFP regs.  */ \\\n@@ -1480,7 +1477,7 @@ enum reg_class\n     ARM_LEGITIMIZE_RELOAD_ADDRESS (X, MODE, OPNUM, TYPE, IND_LEVELS, WIN); \\\n   else\t\t\t\t\t\t\t\t\t   \\\n     THUMB_LEGITIMIZE_RELOAD_ADDRESS (X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)\n-  \n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n    ARM regs are UNITS_PER_WORD bits while FPA regs can hold any FP mode */\n@@ -1558,7 +1555,7 @@ enum reg_class\n    : TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\t\t\t\\\n      && GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n    ? gen_rtx_REG (MODE, FIRST_CIRRUS_FP_REGNUM) \t\t\t\\\n-   : TARGET_IWMMXT_ABI && VECTOR_MODE_SUPPORTED_P (MODE)\t\\\n+   : TARGET_IWMMXT_ABI && arm_vector_mode_supported_p (MODE)    \t\\\n    ? gen_rtx_REG (MODE, FIRST_IWMMXT_REGNUM) \t\t\t\t\\\n    : gen_rtx_REG (MODE, ARG_REGISTER (1)))\n \n@@ -1709,11 +1706,11 @@ typedef struct\n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n-  (VECTOR_MODE_SUPPORTED_P (MODE) ? 0 :\t\t\t\t\\\n-       NUM_ARG_REGS > (CUM).nregs\t\t\t\t\\\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t        \\\n+  (arm_vector_mode_supported_p (MODE) ? 0 :\t\t\t\t\\\n+       NUM_ARG_REGS > (CUM).nregs\t\t\t\t        \\\n    && (NUM_ARG_REGS < ((CUM).nregs + ARM_NUM_REGS2 (MODE, TYPE))\t\\\n-   && (CUM).can_split)\t\t\t\t\t\t\\\n+   && (CUM).can_split)\t\t\t\t\t\t        \\\n    ?   NUM_ARG_REGS - (CUM).nregs : 0)\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n@@ -1728,7 +1725,7 @@ typedef struct\n    (TYPE is null for libcalls where that information may not be available.)  */\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n   (CUM).nargs += 1;\t\t\t\t\t\\\n-  if (VECTOR_MODE_SUPPORTED_P (MODE)\t\t\t\\\n+  if (arm_vector_mode_supported_p (MODE)\t       \t\\\n       && (CUM).named_count > (CUM).nargs)\t\t\\\n     (CUM).iwmmxt_nregs += 1;\t\t\t\t\\\n   else\t\t\t\t\t\t\t\\\n@@ -1867,7 +1864,7 @@ typedef struct\n \n /* Special case handling of the location of arguments passed on the stack.  */\n #define DEBUGGER_ARG_OFFSET(value, addr) value ? value : arm_debugger_arg_offset (value, addr)\n-     \n+\n /* Initialize data used by insn expanders.  This is called from insn_emit,\n    once for every function before code is generated.  */\n #define INIT_EXPANDERS  arm_init_expanders ()\n@@ -1920,7 +1917,7 @@ typedef struct\n     ARM_TRAMPOLINE_TEMPLATE (FILE)\t\t\\\n   else\t\t\t\t\t\t\\\n     THUMB_TRAMPOLINE_TEMPLATE (FILE)\n-       \n+\n /* Length in units of the trampoline for entering a nested function.  */\n #define TRAMPOLINE_SIZE  (TARGET_ARM ? 16 : 24)\n \n@@ -2013,7 +2010,7 @@ typedef struct\n    On the ARM, allow any integer (invalid ones are removed later by insn\n    patterns), nice doubles and symbol_refs which refer to the function's\n    constant pool XXX.\n-   \n+\n    When generating pic allow anything.  */\n #define ARM_LEGITIMATE_CONSTANT_P(X)\t(flag_pic || ! label_mentioned_p (X))\n \n@@ -2050,7 +2047,7 @@ typedef struct\n   case SHORT_CALL_FLAG_CHAR: return 1;\t\t\\\n   case LONG_CALL_FLAG_CHAR:  return 1;\t\t\\\n   case '*':  return 1;\t\t\t\t\\\n-  SUBTARGET_NAME_ENCODING_LENGTHS\t\t\n+  SUBTARGET_NAME_ENCODING_LENGTHS\n \n /* This is how to output a reference to a user-level label named NAME.\n    `assemble_name' uses this.  */\n@@ -2129,7 +2126,7 @@ typedef struct\n    that is a valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression\n    that wants to use this address.  */\n-     \n+\n #define ARM_BASE_REGISTER_RTX_P(X)  \\\n   (GET_CODE (X) == REG && ARM_REG_OK_FOR_BASE_P (X))\n \n@@ -2152,7 +2149,7 @@ typedef struct\n   if (TARGET_ARM)\t\t\t\t\t\t\t\\\n     ARM_GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN)  \t\t\t\\\n   else /* if (TARGET_THUMB) */\t\t\t\t\t\t\\\n-    THUMB_GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN)\t\n+    THUMB_GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN)\n \n \f\n /* Try machine-dependent ways of modifying an illegitimate address\n@@ -2177,7 +2174,7 @@ do {\t\t\t\t\t\t\t\\\n   if (memory_address_p (MODE, X))\t\t\t\\\n     goto WIN;\t\t\t\t\t\t\\\n } while (0)\n-     \n+\n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */\n #define ARM_GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)  \t\t\t\\\n@@ -2190,7 +2187,7 @@ do {\t\t\t\t\t\t\t\\\n /* Nothing helpful to do for the Thumb */\n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\\\n   if (TARGET_ARM)\t\t\t\t\t\\\n-    ARM_GO_IF_MODE_DEPENDENT_ADDRESS (ADDR, LABEL)  \t\t\t\n+    ARM_GO_IF_MODE_DEPENDENT_ADDRESS (ADDR, LABEL)\n \f\n \n /* Specify the machine mode that this machine uses\n@@ -2227,7 +2224,7 @@ do {\t\t\t\t\t\t\t\\\n #define SLOW_BYTE_ACCESS 0\n \n #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1\n-     \n+\n /* Immediate shift counts are truncated by the output routines (or was it\n    the assembler?).  Shift counts in a register are truncated by ARM.  Note\n    that the native compiler puts too large (> 32) immediate shift counts\n@@ -2258,7 +2255,7 @@ do {\t\t\t\t\t\t\t\\\n   (TARGET_ARM ? 10 :\t\t\t\t\t\\\n    ((GET_MODE_SIZE (M) < 4 ? 8 : 2 * GET_MODE_SIZE (M))\t\\\n     * (CLASS == LO_REGS ? 1 : 2)))\n- \n+\n /* Try to generate sequences that don't involve branches, we can then use\n    conditional instructions */\n #define BRANCH_COST \\\n@@ -2573,7 +2570,7 @@ extern int making_const_table;\n #define RETURN_ADDR_RTX(COUNT, FRAME) \\\n   arm_return_addr (COUNT, FRAME)\n \n-/* Mask of the bits in the PC that contain the real return address \n+/* Mask of the bits in the PC that contain the real return address\n    when running in 26-bit mode.  */\n #define RETURN_ADDR_MASK26 (0x03fffffc)\n "}, {"sha": "22a062d6fd7283121b9d7b40e9b8872f237e5a03", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -875,6 +875,7 @@ static tree ix86_build_builtin_va_list (void);\n static void ix86_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n static tree ix86_gimplify_va_arg (tree, tree, tree *, tree *);\n+static bool ix86_vector_mode_supported_p (enum machine_mode);\n \n static int ix86_address_cost (rtx);\n static bool ix86_cannot_force_const_mem (rtx);\n@@ -1065,6 +1066,9 @@ static void init_ext_80387_constants (void);\n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR ix86_gimplify_va_arg\n \n+#undef TARGET_VECTOR_MODE_SUPPORTED_P\n+#define TARGET_VECTOR_MODE_SUPPORTED_P ix86_vector_mode_supported_p\n+\n #ifdef SUBTARGET_INSERT_ATTRIBUTES\n #undef TARGET_INSERT_ATTRIBUTES\n #define TARGET_INSERT_ATTRIBUTES SUBTARGET_INSERT_ATTRIBUTES\n@@ -1815,7 +1819,7 @@ ix86_function_regparm (tree type, tree decl)\n   return regparm;\n }\n \n-/* Return true if EAX is live at the start of the function.  Used by \n+/* Return true if EAX is live at the start of the function.  Used by\n    ix86_expand_prologue to determine if we need special help before\n    calling allocate_stack_worker.  */\n \n@@ -3406,7 +3410,7 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t  t = build1 (ADDR_EXPR, build_pointer_type (type), temp);\n \t  t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n \t  gimplify_and_add (t, pre_p);\n-\t  \n+\n \t  for (i = 0; i < XVECLEN (container, 0); i++)\n \t    {\n \t      rtx slot = XVECEXP (container, 0, i);\n@@ -10173,7 +10177,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n \t\t\t\t       GEN_INT ((count >> (size == 4 ? 2 : 3))\n \t\t\t\t\t\t& (TARGET_64BIT ? -1 : 0x3fffffff)));\n \t  countreg = ix86_zero_extend_to_Pmode (countreg);\n-\t  \n+\n \t  destexp = gen_rtx_ASHIFT (Pmode, countreg,\n \t\t\t\t    GEN_INT (size == 4 ? 2 : 3));\n \t  srcexp = gen_rtx_PLUS (Pmode, destexp, srcreg);\n@@ -14034,7 +14038,7 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t      if (is_mulwiden)\n \t        op0 = XEXP (op0, 0), mode = GET_MODE (op0);\n \t    }\n-  \n+\n   \t  *total = COSTS_N_INSNS (ix86_cost->mult_init[MODE_INDEX (mode)]\n \t\t\t          + nbits * ix86_cost->mult_bit)\n \t           + rtx_cost (op0, outer_code) + rtx_cost (op1, outer_code);\n@@ -14511,8 +14515,8 @@ x86_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n \tif (TARGET_MACHO)\n \t  {\n \t    rtx sym_ref = XEXP (DECL_RTL (function), 0);\n-\t    tmp = (gen_rtx_SYMBOL_REF \n-\t\t   (Pmode, \n+\t    tmp = (gen_rtx_SYMBOL_REF\n+\t\t   (Pmode,\n \t\t    machopic_indirection_name (sym_ref, /*stub_p=*/true)));\n \t    tmp = gen_rtx_MEM (QImode, tmp);\n \t    xops[0] = tmp;\n@@ -14851,13 +14855,13 @@ ix86_expand_vector_init (rtx target, rtx vals)\n   int elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n   int n_elts = (GET_MODE_SIZE (mode) / elt_size);\n   int i;\n-  \n+\n   for (i = n_elts - 1; i >= 0; i--)\n     if (GET_CODE (XVECEXP (vals, 0, i)) != CONST_INT\n \t&& GET_CODE (XVECEXP (vals, 0, i)) != CONST_DOUBLE)\n       break;\n \n-  /* Few special cases first...  \n+  /* Few special cases first...\n      ... constants are best loaded from constant pool.  */\n   if (i < 0)\n     {\n@@ -14931,6 +14935,26 @@ ix86_expand_vector_init (rtx target, rtx vals)\n     }\n }\n \n+/* Implements target hook vector_mode_supported_p.  */\n+static bool\n+ix86_vector_mode_supported_p (enum machine_mode mode)\n+{\n+  if (TARGET_SSE\n+      && VALID_SSE_REG_MODE (mode))\n+    return true;\n+\n+  else if (TARGET_MMX\n+\t   && VALID_MMX_REG_MODE (mode))\n+    return true;\n+\n+  else if (TARGET_3DNOW\n+\t   && VALID_MMX_REG_MODE_3DNOW (mode))\n+    return true;\n+\n+  else\n+    return false;\n+}\n+\n /* Worker function for TARGET_MD_ASM_CLOBBERS.\n \n    We do this in the new i386 backend to maintain source compatibility\n@@ -14939,12 +14963,12 @@ ix86_expand_vector_init (rtx target, rtx vals)\n static tree\n ix86_md_asm_clobbers (tree clobbers)\n {\n-  clobbers = tree_cons (NULL_TREE, build_string (5, \"flags\"),\t\n-\t\t\tclobbers);\t\t\t\t\n-  clobbers = tree_cons (NULL_TREE, build_string (4, \"fpsr\"),\t\n-\t\t\tclobbers);\t\t\t\t\n-  clobbers = tree_cons (NULL_TREE, build_string (7, \"dirflag\"),\t\n-\t\t\tclobbers);\t\t\t\t\n+  clobbers = tree_cons (NULL_TREE, build_string (5, \"flags\"),\n+\t\t\tclobbers);\n+  clobbers = tree_cons (NULL_TREE, build_string (4, \"fpsr\"),\n+\t\t\tclobbers);\n+  clobbers = tree_cons (NULL_TREE, build_string (7, \"dirflag\"),\n+\t\t\tclobbers);\n   return clobbers;\n }\n \n@@ -14992,17 +15016,17 @@ ix86_emit_fp_unordered_jump (rtx label)\n     {\n       emit_insn (gen_x86_sahf_1 (reg));\n \n-      temp = gen_rtx_REG (CCmode, FLAGS_REG); \n+      temp = gen_rtx_REG (CCmode, FLAGS_REG);\n       temp = gen_rtx_UNORDERED (VOIDmode, temp, const0_rtx);\n     }\n   else\n     {\n       emit_insn (gen_testqi_ext_ccno_0 (reg, GEN_INT (0x04)));\n \n-      temp = gen_rtx_REG (CCNOmode, FLAGS_REG); \n+      temp = gen_rtx_REG (CCNOmode, FLAGS_REG);\n       temp = gen_rtx_NE (VOIDmode, temp, const0_rtx);\n     }\n-  \n+\n   temp = gen_rtx_IF_THEN_ELSE (VOIDmode, temp,\n \t\t\t      gen_rtx_LABEL_REF (VOIDmode, label),\n \t\t\t      pc_rtx);\n@@ -15039,5 +15063,5 @@ void ix86_emit_i387_log1p (rtx op0, rtx op1)\n \n   emit_label (label2);\n }\n-     \n+\n #include \"gt-i386.h\""}, {"sha": "38d507574a15c90932cd833551250d42e9fc80f7", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -41,10 +41,10 @@ struct processor_costs {\n   const int lea;\t\t/* cost of a lea instruction */\n   const int shift_var;\t\t/* variable shift costs */\n   const int shift_const;\t/* constant shift costs */\n-  const int mult_init[5];\t/* cost of starting a multiply \n+  const int mult_init[5];\t/* cost of starting a multiply\n \t\t\t\t   in QImode, HImode, SImode, DImode, TImode*/\n   const int mult_bit;\t\t/* cost of multiply per each bit set */\n-  const int divide[5];\t\t/* cost of a divide/mod \n+  const int divide[5];\t\t/* cost of a divide/mod\n \t\t\t\t   in QImode, HImode, SImode, DImode, TImode*/\n   int movsx;\t\t\t/* The cost of movsx operation.  */\n   int movzx;\t\t\t/* The cost of movzx operation.  */\n@@ -1081,11 +1081,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n     ((MODE) == DImode || (MODE) == V8QImode || (MODE) == V4HImode\t\\\n      || (MODE) == V2SImode || (MODE) == SImode)\n \n-#define VECTOR_MODE_SUPPORTED_P(MODE)\t\t\t\t\t\\\n-    (VALID_SSE_REG_MODE (MODE) && TARGET_SSE ? 1\t\t\t\\\n-     : VALID_MMX_REG_MODE (MODE) && TARGET_MMX ? 1\t\t\t\\\n-     : VALID_MMX_REG_MODE_3DNOW (MODE) && TARGET_3DNOW ? 1 : 0)\n-\n #define UNITS_PER_SIMD_WORD \\\n     (TARGET_SSE ? 16 : TARGET_MMX || TARGET_3DNOW ? 8 : 0)\n \n@@ -1595,7 +1590,7 @@ enum reg_class\n    || ((CLASS) == FP_SECOND_REG))\n \n /* Return a class of registers that cannot change FROM mode to TO mode.\n-  \n+\n    x87 registers can't do subreg as all values are reformated to extended\n    precision.  XMM registers does not support with nonzero offsets equal\n    to 4, 8 and 12 otherwise valid for integer registers. Since we can't"}, {"sha": "9da6d2636ae6b9b98dd6835510e366bcf0461282", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 392, "deletions": 373, "changes": 765, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on IBM RS/6000.\n-   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, \n+   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n    2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n@@ -130,7 +130,7 @@ static GTY(()) bool rs6000_always_hint;\n /* Schedule instructions for group formation.  */\n static GTY(()) bool rs6000_sched_groups;\n \n-/* Support adjust_priority scheduler hook \n+/* Support adjust_priority scheduler hook\n    and -mprioritize-restricted-insns= option.  */\n const char *rs6000_sched_restricted_insns_priority_str;\n int rs6000_sched_restricted_insns_priority;\n@@ -709,7 +709,7 @@ static rtx altivec_expand_ld_builtin (tree, rtx, bool *);\n static rtx altivec_expand_st_builtin (tree, rtx, bool *);\n static rtx altivec_expand_dst_builtin (tree, rtx, bool *);\n static rtx altivec_expand_abs_builtin (enum insn_code, tree, rtx);\n-static rtx altivec_expand_predicate_builtin (enum insn_code, \n+static rtx altivec_expand_predicate_builtin (enum insn_code,\n \t\t\t\t\t    const char *, tree, rtx);\n static rtx altivec_expand_lv_builtin (enum insn_code, tree, rtx);\n static rtx altivec_expand_stv_builtin (enum insn_code, tree);\n@@ -753,6 +753,7 @@ static tree get_prev_label (tree function_name);\n static tree rs6000_build_builtin_va_list (void);\n static tree rs6000_gimplify_va_arg (tree, tree, tree *, tree *);\n static bool rs6000_must_pass_in_stack (enum machine_mode, tree);\n+static bool rs6000_vector_mode_supported_p (enum machine_mode);\n \n static enum machine_mode rs6000_eh_return_filter_mode (void);\n \n@@ -896,7 +897,7 @@ static const char alt_reg_names[][8] =\n #define TARGET_SCHED_ADJUST_COST rs6000_adjust_cost\n #undef TARGET_SCHED_ADJUST_PRIORITY\n #define TARGET_SCHED_ADJUST_PRIORITY rs6000_adjust_priority\n-#undef TARGET_SCHED_IS_COSTLY_DEPENDENCE      \n+#undef TARGET_SCHED_IS_COSTLY_DEPENDENCE\n #define TARGET_SCHED_IS_COSTLY_DEPENDENCE rs6000_is_costly_dependence\n #undef TARGET_SCHED_FINISH\n #define TARGET_SCHED_FINISH rs6000_sched_finish\n@@ -975,6 +976,9 @@ static const char alt_reg_names[][8] =\n #undef TARGET_EH_RETURN_FILTER_MODE\n #define TARGET_EH_RETURN_FILTER_MODE rs6000_eh_return_filter_mode\n \n+#undef TARGET_VECTOR_MODE_SUPPORTED_P\n+#define TARGET_VECTOR_MODE_SUPPORTED_P rs6000_vector_mode_supported_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -1056,7 +1060,7 @@ rs6000_override_options (const char *default_cpu)\n   /* This table occasionally claims that a processor does not support\n      a particular feature even though it does, but the feature is slower\n      than the alternative.  Thus, it shouldn't be relied on as a\n-     complete description of the processor's support.  \n+     complete description of the processor's support.\n \n      Please keep this list in order, and don't forget to update the\n      documentation in invoke.texi when adding a new processor or\n@@ -1134,7 +1138,7 @@ rs6000_override_options (const char *default_cpu)\n \n   enum {\n     POWER_MASKS = MASK_POWER | MASK_POWER2 | MASK_MULTIPLE | MASK_STRING,\n-    POWERPC_MASKS = (POWERPC_BASE_MASK | MASK_PPC_GPOPT \n+    POWERPC_MASKS = (POWERPC_BASE_MASK | MASK_PPC_GPOPT\n \t\t     | MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_ALTIVEC\n \t\t     | MASK_MFCRF)\n   };\n@@ -1362,15 +1366,15 @@ rs6000_override_options (const char *default_cpu)\n     = (rs6000_sched_groups ? store_to_load_dep_costly : no_dep_costly);\n   if (rs6000_sched_costly_dep_str)\n     {\n-      if (! strcmp (rs6000_sched_costly_dep_str, \"no\"))  \n+      if (! strcmp (rs6000_sched_costly_dep_str, \"no\"))\n         rs6000_sched_costly_dep = no_dep_costly;\n       else if (! strcmp (rs6000_sched_costly_dep_str, \"all\"))\n         rs6000_sched_costly_dep = all_deps_costly;\n       else if (! strcmp (rs6000_sched_costly_dep_str, \"true_store_to_load\"))\n         rs6000_sched_costly_dep = true_store_to_load_dep_costly;\n       else if (! strcmp (rs6000_sched_costly_dep_str, \"store_to_load\"))\n         rs6000_sched_costly_dep = store_to_load_dep_costly;\n-      else \n+      else\n         rs6000_sched_costly_dep = atoi (rs6000_sched_costly_dep_str);\n     }\n \n@@ -1414,7 +1418,7 @@ rs6000_override_options (const char *default_cpu)\n   /* Allocate an alias set for register saves & restores from stack.  */\n   rs6000_sr_alias_set = new_alias_set ();\n \n-  if (TARGET_TOC) \n+  if (TARGET_TOC)\n     ASM_GENERATE_INTERNAL_LABEL (toc_label_name, \"LCTOC\", 1);\n \n   /* We can only guarantee the availability of DI pseudo-ops when\n@@ -1556,7 +1560,7 @@ rs6000_parse_abi_options (void)\n       if (!TARGET_SPE_ABI)\n \terror (\"not configured for ABI: '%s'\", rs6000_abi_string);\n     }\n-  \n+\n   else if (! strcmp (rs6000_abi_string, \"no-spe\"))\n     rs6000_spe_abi = 0;\n   else\n@@ -1681,7 +1685,7 @@ direct_return (void)\n /* Returns 1 always.  */\n \n int\n-any_operand (rtx op ATTRIBUTE_UNUSED, \n+any_operand (rtx op ATTRIBUTE_UNUSED,\n \t     enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return 1;\n@@ -1690,7 +1694,7 @@ any_operand (rtx op ATTRIBUTE_UNUSED,\n /* Returns 1 always.  */\n \n int\n-any_parallel_operand (rtx op ATTRIBUTE_UNUSED, \n+any_parallel_operand (rtx op ATTRIBUTE_UNUSED,\n \t\t      enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return 1;\n@@ -1718,7 +1722,7 @@ count_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n int\n altivec_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  \n+\n   return (register_operand (op, mode)\n \t  && (GET_CODE (op) != REG\n \t      || REGNO (op) > FIRST_PSEUDO_REGISTER\n@@ -1793,7 +1797,7 @@ gpc_reg_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  && (GET_CODE (op) != REG\n-\t      || (REGNO (op) >= ARG_POINTER_REGNUM \n+\t      || (REGNO (op) >= ARG_POINTER_REGNUM\n \t\t  && !XER_REGNO_P (REGNO (op)))\n \t      || REGNO (op) < MQ_REGNO));\n }\n@@ -1958,7 +1962,7 @@ reg_or_logical_cint_operand (rtx op, enum machine_mode mode)\n \n       return CONST_DOUBLE_HIGH (op) == 0;\n     }\n-  else \n+  else\n     return gpc_reg_operand (op, mode);\n }\n \n@@ -2172,27 +2176,27 @@ easy_fp_constant (rtx op, enum machine_mode mode)\n static int\n easy_vector_splat_const (int cst, enum machine_mode mode)\n {\n-  switch (mode) \n+  switch (mode)\n     {\n     case V4SImode:\n-      if (EASY_VECTOR_15 (cst) \n-\t  || EASY_VECTOR_15_ADD_SELF (cst)) \n+      if (EASY_VECTOR_15 (cst)\n+\t  || EASY_VECTOR_15_ADD_SELF (cst))\n \treturn cst;\n       if ((cst & 0xffff) != ((cst >> 16) & 0xffff))\n \tbreak;\n       cst = cst >> 16;\n     case V8HImode:\n-      if (EASY_VECTOR_15 (cst) \n-\t  || EASY_VECTOR_15_ADD_SELF (cst)) \n+      if (EASY_VECTOR_15 (cst)\n+\t  || EASY_VECTOR_15_ADD_SELF (cst))\n \treturn cst;\n       if ((cst & 0xff) != ((cst >> 8) & 0xff))\n \tbreak;\n       cst = cst >> 8;\n     case V16QImode:\n-\t  if (EASY_VECTOR_15 (cst) \n-\t      || EASY_VECTOR_15_ADD_SELF (cst)) \n+\t  if (EASY_VECTOR_15 (cst)\n+\t      || EASY_VECTOR_15_ADD_SELF (cst))\n \t    return cst;\n-    default: \n+    default:\n       break;\n     }\n   return 0;\n@@ -2258,14 +2262,14 @@ easy_vector_constant (rtx op, enum machine_mode mode)\n       && cst2 >= -0x7fff && cst2 <= 0x7fff)\n     return 1;\n \n-  if (TARGET_ALTIVEC \n+  if (TARGET_ALTIVEC\n       && easy_vector_same (op, mode))\n     {\n       cst = easy_vector_splat_const (cst, mode);\n-      if (EASY_VECTOR_15_ADD_SELF (cst) \n+      if (EASY_VECTOR_15_ADD_SELF (cst)\n \t  || EASY_VECTOR_15 (cst))\n \treturn 1;\n-    }  \n+    }\n   return 0;\n }\n \n@@ -2281,14 +2285,14 @@ easy_vector_constant_add_self (rtx op, enum machine_mode mode)\n     {\n       cst = easy_vector_splat_const (INTVAL (CONST_VECTOR_ELT (op, 0)), mode);\n       if (EASY_VECTOR_15_ADD_SELF (cst))\n-\treturn 1;  \n+\treturn 1;\n     }\n   return 0;\n }\n \n /* Generate easy_vector_constant out of a easy_vector_constant_add_self.  */\n \n-rtx \n+rtx\n gen_easy_vector_constant_add_self (rtx op)\n {\n   int i, units;\n@@ -2297,7 +2301,7 @@ gen_easy_vector_constant_add_self (rtx op)\n   v = rtvec_alloc (units);\n \n   for (i = 0; i < units; i++)\n-    RTVEC_ELT (v, i) = \n+    RTVEC_ELT (v, i) =\n       GEN_INT (INTVAL (CONST_VECTOR_ELT (op, i)) >> 1);\n   return gen_rtx_raw_CONST_VECTOR (GET_MODE (op), v);\n }\n@@ -2789,7 +2793,7 @@ lwa_operand (rtx op, enum machine_mode mode)\n \n   if (reload_completed && GET_CODE (inner) == SUBREG)\n     inner = SUBREG_REG (inner);\n-    \n+\n   return gpc_reg_operand (inner, mode)\n     || (memory_operand (inner, mode)\n \t&& GET_CODE (XEXP (inner, 0)) != PRE_INC\n@@ -2831,7 +2835,7 @@ call_operand (rtx op, enum machine_mode mode)\n    this file.  */\n \n int\n-current_file_function_operand (rtx op, \n+current_file_function_operand (rtx op,\n                               enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == SYMBOL_REF\n@@ -2919,7 +2923,7 @@ rs6000_special_round_type_align (tree type, int computed, int specified)\n /* Return 1 for an operand in small memory on V.4/eabi.  */\n \n int\n-small_data_operand (rtx op ATTRIBUTE_UNUSED, \n+small_data_operand (rtx op ATTRIBUTE_UNUSED,\n \t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n #if TARGET_ELF\n@@ -2993,10 +2997,10 @@ gpr_or_gpr_p (rtx op0, rtx op1)\n \f\n /* Subroutines of rs6000_legitimize_address and rs6000_legitimate_address.  */\n \n-static int \n-constant_pool_expr_1 (rtx op, int *have_sym, int *have_toc) \n+static int\n+constant_pool_expr_1 (rtx op, int *have_sym, int *have_toc)\n {\n-  switch (GET_CODE(op)) \n+  switch (GET_CODE(op))\n     {\n     case SYMBOL_REF:\n       if (RS6000_SYMBOL_REF_TLS_P (op))\n@@ -3238,11 +3242,11 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \treturn rs6000_legitimize_tls_address (x, model);\n     }\n \n-  if (GET_CODE (x) == PLUS \n+  if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == REG\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && (unsigned HOST_WIDE_INT) (INTVAL (XEXP (x, 1)) + 0x8000) >= 0x10000)\n-    { \n+    {\n       HOST_WIDE_INT high_int, low_int;\n       rtx sum;\n       low_int = ((INTVAL (XEXP (x, 1)) & 0xffff) ^ 0x8000) - 0x8000;\n@@ -3251,7 +3255,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t\t\t\t GEN_INT (high_int)), 0);\n       return gen_rtx_PLUS (Pmode, sum, GEN_INT (low_int));\n     }\n-  else if (GET_CODE (x) == PLUS \n+  else if (GET_CODE (x) == PLUS\n \t   && GET_CODE (XEXP (x, 0)) == REG\n \t   && GET_CODE (XEXP (x, 1)) != CONST_INT\n \t   && GET_MODE_NUNITS (mode) == 1\n@@ -3302,7 +3306,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && TARGET_NO_TOC\n \t   && ! flag_pic\n \t   && GET_CODE (x) != CONST_INT\n-\t   && GET_CODE (x) != CONST_DOUBLE \n+\t   && GET_CODE (x) != CONST_DOUBLE\n \t   && CONSTANT_P (x)\n \t   && GET_MODE_NUNITS (mode) == 1\n \t   && (GET_MODE_BITSIZE (mode) <= 32\n@@ -3318,17 +3322,17 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && ! MACHO_DYNAMIC_NO_PIC_P\n #endif\n \t   && GET_CODE (x) != CONST_INT\n-\t   && GET_CODE (x) != CONST_DOUBLE \n+\t   && GET_CODE (x) != CONST_DOUBLE\n \t   && CONSTANT_P (x)\n \t   && ((TARGET_HARD_FLOAT && TARGET_FPRS) || mode != DFmode)\n-\t   && mode != DImode \n+\t   && mode != DImode\n \t   && mode != TImode)\n     {\n       rtx reg = gen_reg_rtx (Pmode);\n       emit_insn (gen_macho_high (reg, x));\n       return gen_rtx_LO_SUM (Pmode, reg, x);\n     }\n-  else if (TARGET_TOC \n+  else if (TARGET_TOC\n \t   && constant_pool_expr_p (x)\n \t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x), Pmode))\n     {\n@@ -3382,7 +3386,7 @@ rs6000_got_sym (void)\n       rs6000_got_symbol = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n       SYMBOL_REF_FLAGS (rs6000_got_symbol) |= SYMBOL_FLAG_LOCAL;\n       SYMBOL_REF_FLAGS (rs6000_got_symbol) |= SYMBOL_FLAG_EXTERNAL;\n-    }     \n+    }\n \n   return rs6000_got_symbol;\n }\n@@ -3622,10 +3626,10 @@ rs6000_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n    The Darwin code is inside #if TARGET_MACHO because only then is\n    machopic_function_base_name() defined.  */\n rtx\n-rs6000_legitimize_reload_address (rtx x, enum machine_mode mode, \n+rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n \tint opnum, int type, int ind_levels ATTRIBUTE_UNUSED, int *win)\n {\n-  /* We must recognize output that we have already generated ourselves.  */ \n+  /* We must recognize output that we have already generated ourselves.  */\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n@@ -3732,7 +3736,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n     }\n   *win = 0;\n   return x;\n-}    \n+}\n \n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n@@ -3799,7 +3803,7 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n \n    ??? Except that due to conceptual problems in offsettable_address_p\n    we can't really report the problems of integral offsets.  So leave\n-   this assuming that the adjustable offset must be valid for the \n+   this assuming that the adjustable offset must be valid for the\n    sub-words of a TFmode operand, which is what we had before.  */\n \n bool\n@@ -3933,7 +3937,7 @@ rs6000_conditional_register_usage (void)\n    insns, zero is returned and no insns and emitted.  */\n \n rtx\n-rs6000_emit_set_const (rtx dest, enum machine_mode mode, \n+rs6000_emit_set_const (rtx dest, enum machine_mode mode,\n \t\t       rtx source, int n ATTRIBUTE_UNUSED)\n {\n   rtx result, insn, set;\n@@ -4021,7 +4025,7 @@ rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n       ud3 = c2 & 0xffff;\n       ud4 = (c2 & 0xffff0000) >> 16;\n \n-      if ((ud4 == 0xffff && ud3 == 0xffff && ud2 == 0xffff && (ud1 & 0x8000)) \n+      if ((ud4 == 0xffff && ud3 == 0xffff && ud2 == 0xffff && (ud1 & 0x8000))\n \t  || (ud4 == 0 && ud3 == 0 && ud2 == 0 && ! (ud1 & 0x8000)))\n \t{\n \t  if (ud1 & 0x8000)\n@@ -4030,22 +4034,22 @@ rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n \t    emit_move_insn (dest, GEN_INT (ud1));\n \t}\n \n-      else if ((ud4 == 0xffff && ud3 == 0xffff && (ud2 & 0x8000)) \n+      else if ((ud4 == 0xffff && ud3 == 0xffff && (ud2 & 0x8000))\n \t       || (ud4 == 0 && ud3 == 0 && ! (ud2 & 0x8000)))\n \t{\n \t  if (ud2 & 0x8000)\n-\t    emit_move_insn (dest, GEN_INT (((ud2 << 16) ^ 0x80000000) \n+\t    emit_move_insn (dest, GEN_INT (((ud2 << 16) ^ 0x80000000)\n \t\t\t\t\t   - 0x80000000));\n \t  else\n \t    emit_move_insn (dest, GEN_INT (ud2 << 16));\n \t  if (ud1 != 0)\n \t    emit_move_insn (dest, gen_rtx_IOR (DImode, dest, GEN_INT (ud1)));\n \t}\n-      else if ((ud4 == 0xffff && (ud3 & 0x8000)) \n+      else if ((ud4 == 0xffff && (ud3 & 0x8000))\n \t       || (ud4 == 0 && ! (ud3 & 0x8000)))\n \t{\n \t  if (ud3 & 0x8000)\n-\t    emit_move_insn (dest, GEN_INT (((ud3 << 16) ^ 0x80000000) \n+\t    emit_move_insn (dest, GEN_INT (((ud3 << 16) ^ 0x80000000)\n \t\t\t\t\t   - 0x80000000));\n \t  else\n \t    emit_move_insn (dest, GEN_INT (ud3 << 16));\n@@ -4056,10 +4060,10 @@ rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n \t  if (ud1 != 0)\n \t    emit_move_insn (dest, gen_rtx_IOR (DImode, dest, GEN_INT (ud1)));\n \t}\n-      else \n+      else\n \t{\n \t  if (ud4 & 0x8000)\n-\t    emit_move_insn (dest, GEN_INT (((ud4 << 16) ^ 0x80000000) \n+\t    emit_move_insn (dest, GEN_INT (((ud4 << 16) ^ 0x80000000)\n \t\t\t\t\t   - 0x80000000));\n \t  else\n \t    emit_move_insn (dest, GEN_INT (ud4 << 16));\n@@ -4069,8 +4073,8 @@ rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n \n \t  emit_move_insn (dest, gen_rtx_ASHIFT (DImode, dest, GEN_INT (32)));\n \t  if (ud2 != 0)\n-\t    emit_move_insn (dest, gen_rtx_IOR (DImode, dest, \n-\t\t\t\t\t       GEN_INT (ud2 << 16)));\t\n+\t    emit_move_insn (dest, gen_rtx_IOR (DImode, dest,\n+\t\t\t\t\t       GEN_INT (ud2 << 16)));\n \t  if (ud1 != 0)\n \t    emit_move_insn (dest, gen_rtx_IOR (DImode, dest, GEN_INT (ud1)));\n \t}\n@@ -4106,7 +4110,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n   rtx operands[2];\n   operands[0] = dest;\n   operands[1] = source;\n-  \n+\n   /* Sanity checks.  Check that we get CONST_DOUBLE only when we should.  */\n   if (GET_CODE (operands[1]) == CONST_DOUBLE\n       && ! FLOAT_MODE_P (mode)\n@@ -4135,7 +4139,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n       && ! (SLOW_UNALIGNED_ACCESS (SImode, (MEM_ALIGN (operands[0]) > 32\n \t\t\t\t\t    ? 32 : MEM_ALIGN (operands[0])))\n \t    || SLOW_UNALIGNED_ACCESS (SImode, (MEM_ALIGN (operands[1]) > 32\n-\t\t\t\t\t       ? 32 \n+\t\t\t\t\t       ? 32\n \t\t\t\t\t       : MEM_ALIGN (operands[1]))))\n       && ! MEM_VOLATILE_P (operands [0])\n       && ! MEM_VOLATILE_P (operands [1]))\n@@ -4176,7 +4180,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \tregnum = REGNO (operands[1]);\n       else\n \tregnum = -1;\n-      \n+\n       /* If operands[1] is a register, on POWER it may have\n \t double-precision data in it, so truncate it to single\n \t precision.  */\n@@ -4241,11 +4245,11 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \n     case DFmode:\n     case SFmode:\n-      if (CONSTANT_P (operands[1]) \n+      if (CONSTANT_P (operands[1])\n \t  && ! easy_fp_constant (operands[1], mode))\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n-      \n+\n     case V16QImode:\n     case V8HImode:\n     case V4SFmode:\n@@ -4258,14 +4262,14 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t  && !easy_vector_constant (operands[1], mode))\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n-      \n+\n     case SImode:\n     case DImode:\n       /* Use default pattern for address of ELF small data */\n       if (TARGET_ELF\n \t  && mode == Pmode\n \t  && DEFAULT_ABI == ABI_V4\n-\t  && (GET_CODE (operands[1]) == SYMBOL_REF \n+\t  && (GET_CODE (operands[1]) == SYMBOL_REF\n \t      || GET_CODE (operands[1]) == CONST)\n \t  && small_data_operand (operands[1], mode))\n \t{\n@@ -4413,7 +4417,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \n \t  operands[1] = force_const_mem (mode, operands[1]);\n \n-\t  if (TARGET_TOC \n+\t  if (TARGET_TOC\n \t      && constant_pool_expr_p (XEXP (operands[1], 0))\n \t      && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (\n \t\t\tget_pool_constant (XEXP (operands[1], 0)),\n@@ -4510,7 +4514,7 @@ rs6000_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n    so we never return a PARALLEL.  */\n \n void\n-init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype, \n+init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \t\t      rtx libname ATTRIBUTE_UNUSED, int incoming,\n \t\t      int libcall, int n_named_args)\n {\n@@ -4555,9 +4559,9 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n       fprintf (stderr, \" proto = %d, nargs = %d\\n\",\n \t       cum->prototype, cum->nargs_prototype);\n     }\n-  \n-    if (fntype \n-\t&& !TARGET_ALTIVEC \n+\n+    if (fntype\n+\t&& !TARGET_ALTIVEC\n \t&& TARGET_ALTIVEC_ABI\n         && ALTIVEC_VECTOR_MODE (TYPE_MODE (TREE_TYPE (fntype))))\n       {\n@@ -4637,9 +4641,9 @@ function_arg_padding (enum machine_mode mode, tree type)\n }\n \n /* If defined, a C expression that gives the alignment boundary, in bits,\n-   of an argument with the specified mode and type.  If it is not defined, \n+   of an argument with the specified mode and type.  If it is not defined,\n    PARM_BOUNDARY is used for all arguments.\n-   \n+\n    V.4 wants long longs to be double word aligned.  */\n \n int\n@@ -4682,7 +4686,7 @@ rs6000_arg_size (enum machine_mode mode, tree type)\n    itself.  */\n \n void\n-function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n+function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t      tree type, int named)\n {\n   cum->nargs_prototype--;\n@@ -4700,7 +4704,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t   \" to enable them.\");\n \n \t  /* PowerPC64 Linux and AIX allocate GPRs for a vector argument\n-\t     even if it is going to be passed in a vector register.  \n+\t     even if it is going to be passed in a vector register.\n \t     Darwin does the same for variable-argument functions.  */\n \t  if ((DEFAULT_ABI == ABI_AIX && TARGET_64BIT)\n \t      || (cum->stdarg && DEFAULT_ABI != ABI_V4))\n@@ -4712,7 +4716,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       if (stack)\n         {\n \t  int align;\n-\t  \n+\n \t  /* Vector parameters must be 16-byte aligned.  This places\n \t     them at 2 mod 4 in terms of words in 32-bit mode, since\n \t     the parameter save area starts at offset 24 from the\n@@ -4725,13 +4729,13 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  else\n \t    align = cum->words & 1;\n \t  cum->words += align + rs6000_arg_size (mode, type);\n-\t  \n+\n \t  if (TARGET_DEBUG_ARG)\n \t    {\n-\t      fprintf (stderr, \"function_adv: words = %2d, align=%d, \", \n+\t      fprintf (stderr, \"function_adv: words = %2d, align=%d, \",\n \t\t       cum->words, align);\n \t      fprintf (stderr, \"nargs = %4d, proto = %d, mode = %4s\\n\",\n-\t\t       cum->nargs_prototype, cum->prototype, \n+\t\t       cum->nargs_prototype, cum->prototype,\n \t\t       GET_MODE_NAME (mode));\n \t    }\n \t}\n@@ -4823,7 +4827,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n /* Determine where to put a SIMD argument on the SPE.  */\n \n static rtx\n-rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n+rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t tree type)\n {\n   if (cum->stdarg)\n@@ -4934,7 +4938,7 @@ rs6000_mixed_function_arg (enum machine_mode mode, tree type, int align_words)\n    itself.  */\n \n struct rtx_def *\n-function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n+function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t      tree type, int named)\n {\n   enum rs6000_abi abi = DEFAULT_ABI;\n@@ -5162,7 +5166,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    number of registers used by the first element of the PARALLEL.  */\n \n int\n-function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n+function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t    tree type, int named)\n {\n   int ret = 0;\n@@ -5222,8 +5226,8 @@ function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    reference.  */\n \n static bool\n-rs6000_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED, \n-\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED, \n+rs6000_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  tree type, bool named ATTRIBUTE_UNUSED)\n {\n   if ((DEFAULT_ABI == ABI_V4\n@@ -5257,7 +5261,7 @@ rs6000_move_block_from_reg (int regno, rtx x, int nregs)\n \tif (! strict_memory_address_p (reg_mode, XEXP (tem, 0)))\n \t  tem = NULL_RTX;\n \telse\n-\t  tem = simplify_gen_subreg (reg_mode, x, BLKmode, \n+\t  tem = simplify_gen_subreg (reg_mode, x, BLKmode,\n \t\t\t\t     i * GET_MODE_SIZE(reg_mode));\n       }\n       else\n@@ -5272,7 +5276,7 @@ rs6000_move_block_from_reg (int regno, rtx x, int nregs)\n \n \f\n /* Perform any needed actions needed for a function that is receiving a\n-   variable number of arguments. \n+   variable number of arguments.\n \n    CUM is as above.\n \n@@ -5286,7 +5290,7 @@ rs6000_move_block_from_reg (int regno, rtx x, int nregs)\n    stack and set PRETEND_SIZE to the length of the registers pushed.  */\n \n static void\n-setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n+setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\ttree type, int *pretend_size ATTRIBUTE_UNUSED, int no_rtl)\n {\n   CUMULATIVE_ARGS next_cum;\n@@ -5327,7 +5331,7 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       set_mem_alias_set (mem, set);\n       set_mem_align (mem, BITS_PER_WORD);\n \n-      rs6000_move_block_from_reg (GP_ARG_MIN_REG + first_reg_offset, mem, \n+      rs6000_move_block_from_reg (GP_ARG_MIN_REG + first_reg_offset, mem,\n \t\t\t          GP_ARG_NUM_REG - first_reg_offset);\n     }\n \n@@ -5378,9 +5382,9 @@ rs6000_build_builtin_va_list (void)\n   record = (*lang_hooks.types.make_type) (RECORD_TYPE);\n   type_decl = build_decl (TYPE_DECL, get_identifier (\"__va_list_tag\"), record);\n \n-  f_gpr = build_decl (FIELD_DECL, get_identifier (\"gpr\"), \n+  f_gpr = build_decl (FIELD_DECL, get_identifier (\"gpr\"),\n \t\t      unsigned_char_type_node);\n-  f_fpr = build_decl (FIELD_DECL, get_identifier (\"fpr\"), \n+  f_fpr = build_decl (FIELD_DECL, get_identifier (\"fpr\"),\n \t\t      unsigned_char_type_node);\n   /* Give the two bytes of padding a name, so that -Wpadded won't warn on\n      every user file.  */\n@@ -5673,7 +5677,7 @@ static const struct builtin_description bdesc_3arg[] =\n   { MASK_ALTIVEC, CODE_FOR_altivec_vmsumshm, \"__builtin_altivec_vmsumshm\", ALTIVEC_BUILTIN_VMSUMSHM },\n   { MASK_ALTIVEC, CODE_FOR_altivec_vmsumuhs, \"__builtin_altivec_vmsumuhs\", ALTIVEC_BUILTIN_VMSUMUHS },\n   { MASK_ALTIVEC, CODE_FOR_altivec_vmsumshs, \"__builtin_altivec_vmsumshs\", ALTIVEC_BUILTIN_VMSUMSHS },\n-  { MASK_ALTIVEC, CODE_FOR_altivec_vnmsubfp, \"__builtin_altivec_vnmsubfp\", ALTIVEC_BUILTIN_VNMSUBFP }, \n+  { MASK_ALTIVEC, CODE_FOR_altivec_vnmsubfp, \"__builtin_altivec_vnmsubfp\", ALTIVEC_BUILTIN_VNMSUBFP },\n   { MASK_ALTIVEC, CODE_FOR_altivec_vperm_4sf, \"__builtin_altivec_vperm_4sf\", ALTIVEC_BUILTIN_VPERM_4SF },\n   { MASK_ALTIVEC, CODE_FOR_altivec_vperm_4si, \"__builtin_altivec_vperm_4si\", ALTIVEC_BUILTIN_VPERM_4SI },\n   { MASK_ALTIVEC, CODE_FOR_altivec_vperm_8hi, \"__builtin_altivec_vperm_8hi\", ALTIVEC_BUILTIN_VPERM_8HI },\n@@ -6251,7 +6255,7 @@ rs6000_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target)\n }\n \n static rtx\n-altivec_expand_predicate_builtin (enum insn_code icode, const char *opcode, \n+altivec_expand_predicate_builtin (enum insn_code icode, const char *opcode,\n \t\t\t\t  tree arglist, rtx target)\n {\n   rtx pat, scratch;\n@@ -6353,7 +6357,7 @@ altivec_expand_lv_builtin (enum insn_code icode, tree arglist, rtx target)\n       || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n     target = gen_reg_rtx (tmode);\n \n-  op1 = copy_to_mode_reg (mode1, op1); \n+  op1 = copy_to_mode_reg (mode1, op1);\n \n   if (op0 == const0_rtx)\n     {\n@@ -6430,7 +6434,7 @@ altivec_expand_stv_builtin (enum insn_code icode, tree arglist)\n   if (! (*insn_data[icode].operand[1].predicate) (op0, tmode))\n     op0 = copy_to_mode_reg (tmode, op0);\n \n-  op2 = copy_to_mode_reg (mode2, op2); \n+  op2 = copy_to_mode_reg (mode2, op2);\n \n   if (op1 == const0_rtx)\n     {\n@@ -6563,7 +6567,7 @@ altivec_expand_ld_builtin (tree exp, rtx target, bool *expandedp)\n \n /* Expand the stvx builtins.  */\n static rtx\n-altivec_expand_st_builtin (tree exp, rtx target ATTRIBUTE_UNUSED, \n+altivec_expand_st_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \t\t\t   bool *expandedp)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n@@ -6615,7 +6619,7 @@ altivec_expand_st_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \n /* Expand the dst builtins.  */\n static rtx\n-altivec_expand_dst_builtin (tree exp, rtx target ATTRIBUTE_UNUSED, \n+altivec_expand_dst_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \t\t\t    bool *expandedp)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n@@ -6725,7 +6729,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n \t  || GET_MODE (target) != tmode\n \t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n \ttarget = gen_reg_rtx (tmode);\n-      \n+\n       pat = GEN_FCN (icode) (target);\n       if (! pat)\n \treturn 0;\n@@ -6777,7 +6781,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n \n       emit_insn (gen_altivec_dss (op0));\n       return NULL_RTX;\n-      \n+\n     case ALTIVEC_BUILTIN_COMPILETIME_ERROR:\n       arg0 = TREE_VALUE (arglist);\n       while (TREE_CODE (arg0) == NOP_EXPR || TREE_CODE (arg0) == ADDR_EXPR)\n@@ -6969,7 +6973,7 @@ spe_expand_builtin (tree exp, rtx target, bool *expandedp)\n \t  || GET_MODE (target) != tmode\n \t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n \ttarget = gen_reg_rtx (tmode);\n-      \n+\n       pat = GEN_FCN (icode) (target);\n       if (! pat)\n \treturn 0;\n@@ -7167,7 +7171,7 @@ spe_expand_evsel_builtin (enum insn_code icode, tree arglist, rtx target)\n \n static rtx\n rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t      enum machine_mode mode ATTRIBUTE_UNUSED, \n+\t\t      enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t      int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n@@ -7177,7 +7181,7 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   size_t i;\n   rtx ret;\n   bool success;\n-  \n+\n   if (TARGET_ALTIVEC)\n     {\n       ret = altivec_expand_builtin (exp, target, &success);\n@@ -7324,7 +7328,7 @@ rs6000_init_builtins (void)\n    END is the builtin enum at which to end.  */\n static void\n enable_mask_for_builtins (struct builtin_description *desc, int size,\n-\t\t\t  enum rs6000_builtins start, \n+\t\t\t  enum rs6000_builtins start,\n \t\t\t  enum rs6000_builtins end)\n {\n   int i;\n@@ -7477,7 +7481,7 @@ spe_init_builtins (void)\n \t\t opaque_V2SI_type_node));\n \n   /* Initialize irregular SPE builtins.  */\n-  \n+\n   def_builtin (target_flags, \"__builtin_spe_mtspefscr\", void_ftype_int, SPE_BUILTIN_MTSPEFSCR);\n   def_builtin (target_flags, \"__builtin_spe_mfspefscr\", int_ftype_void, SPE_BUILTIN_MFSPEFSCR);\n   def_builtin (target_flags, \"__builtin_spe_evstddx\", void_ftype_v2si_pv2si_int, SPE_BUILTIN_EVSTDDX);\n@@ -7735,7 +7739,7 @@ altivec_init_builtins (void)\n \tdefault:\n \t  abort ();\n \t}\n-      \n+\n       def_builtin (dp->mask, dp->name, type, dp->code);\n     }\n \n@@ -7765,7 +7769,7 @@ altivec_init_builtins (void)\n \tdefault:\n \t  abort ();\n \t}\n-      \n+\n       def_builtin (d->mask, d->name, type, d->code);\n     }\n }\n@@ -7825,7 +7829,7 @@ rs6000_common_init_builtins (void)\n   tree v2sf_ftype_v2sf\n     = build_function_type_list (opaque_V2SF_type_node,\n \t\t\t\topaque_V2SF_type_node, NULL_TREE);\n-  \n+\n   tree v2sf_ftype_v2si\n     = build_function_type_list (opaque_V2SF_type_node,\n \t\t\t\topaque_V2SI_type_node, NULL_TREE);\n@@ -7897,7 +7901,7 @@ rs6000_common_init_builtins (void)\n     = build_function_type_list (V4SF_type_node,\n \t\t\t\tV4SF_type_node, V4SF_type_node,\n \t\t\t\tV4SF_type_node, NULL_TREE);\n-  tree v4si_ftype_v4si_v4si_v4si \n+  tree v4si_ftype_v4si_v4si_v4si\n     = build_function_type_list (V4SI_type_node,\n \t\t\t\tV4SI_type_node, V4SI_type_node,\n \t\t\t\tV4SI_type_node, NULL_TREE);\n@@ -7962,18 +7966,18 @@ rs6000_common_init_builtins (void)\n   d = (struct builtin_description *) bdesc_3arg;\n   for (i = 0; i < ARRAY_SIZE (bdesc_3arg); i++, d++)\n     {\n-      \n+\n       enum machine_mode mode0, mode1, mode2, mode3;\n       tree type;\n \n       if (d->name == 0 || d->icode == CODE_FOR_nothing)\n \tcontinue;\n-      \n+\n       mode0 = insn_data[d->icode].operand[0].mode;\n       mode1 = insn_data[d->icode].operand[1].mode;\n       mode2 = insn_data[d->icode].operand[2].mode;\n       mode3 = insn_data[d->icode].operand[3].mode;\n-      \n+\n       /* When all four are of the same mode.  */\n       if (mode0 == mode1 && mode1 == mode2 && mode2 == mode3)\n \t{\n@@ -7987,12 +7991,12 @@ rs6000_common_init_builtins (void)\n \t      break;\n \t    case V8HImode:\n \t      type = v8hi_ftype_v8hi_v8hi_v8hi;\n-\t      break;\t      \n+\t      break;\n \t    case V16QImode:\n \t      type = v16qi_ftype_v16qi_v16qi_v16qi;\n-\t      break;\t      \n+\t      break;\n \t    default:\n-\t      abort();\t      \n+\t      abort();\n \t    }\n \t}\n       else if (mode0 == mode1 && mode1 == mode2 && mode3 == V16QImode)\n@@ -8007,21 +8011,21 @@ rs6000_common_init_builtins (void)\n \t      break;\n \t    case V8HImode:\n \t      type = v8hi_ftype_v8hi_v8hi_v16qi;\n-\t      break;\t      \n+\t      break;\n \t    case V16QImode:\n \t      type = v16qi_ftype_v16qi_v16qi_v16qi;\n-\t      break;\t      \n+\t      break;\n \t    default:\n-\t      abort();\t      \n+\t      abort();\n \t    }\n \t}\n-      else if (mode0 == V4SImode && mode1 == V16QImode && mode2 == V16QImode \n+      else if (mode0 == V4SImode && mode1 == V16QImode && mode2 == V16QImode\n \t       && mode3 == V4SImode)\n \ttype = v4si_ftype_v16qi_v16qi_v4si;\n-      else if (mode0 == V4SImode && mode1 == V8HImode && mode2 == V8HImode \n+      else if (mode0 == V4SImode && mode1 == V8HImode && mode2 == V8HImode\n \t       && mode3 == V4SImode)\n \ttype = v4si_ftype_v8hi_v8hi_v4si;\n-      else if (mode0 == V4SFmode && mode1 == V4SFmode && mode2 == V4SFmode \n+      else if (mode0 == V4SFmode && mode1 == V4SFmode && mode2 == V4SFmode\n \t       && mode3 == V4SImode)\n \ttype = v4sf_ftype_v4sf_v4sf_v4si;\n \n@@ -8060,7 +8064,7 @@ rs6000_common_init_builtins (void)\n \n       if (d->name == 0 || d->icode == CODE_FOR_nothing)\n \tcontinue;\n-      \n+\n       mode0 = insn_data[d->icode].operand[0].mode;\n       mode1 = insn_data[d->icode].operand[1].mode;\n       mode2 = insn_data[d->icode].operand[2].mode;\n@@ -8129,23 +8133,23 @@ rs6000_common_init_builtins (void)\n       /* vint, vshort, vint.  */\n       else if (mode0 == V4SImode && mode1 == V8HImode && mode2 == V4SImode)\n \ttype = v4si_ftype_v8hi_v4si;\n-      \n+\n       /* vint, vint, 5 bit literal.  */\n       else if (mode0 == V4SImode && mode1 == V4SImode && mode2 == QImode)\n \ttype = v4si_ftype_v4si_int;\n-      \n+\n       /* vshort, vshort, 5 bit literal.  */\n       else if (mode0 == V8HImode && mode1 == V8HImode && mode2 == QImode)\n \ttype = v8hi_ftype_v8hi_int;\n-      \n+\n       /* vchar, vchar, 5 bit literal.  */\n       else if (mode0 == V16QImode && mode1 == V16QImode && mode2 == QImode)\n \ttype = v16qi_ftype_v16qi_int;\n \n       /* vfloat, vint, 5 bit literal.  */\n       else if (mode0 == V4SFmode && mode1 == V4SImode && mode2 == QImode)\n \ttype = v4sf_ftype_v4si_int;\n-      \n+\n       /* vint, vfloat, 5 bit literal.  */\n       else if (mode0 == V4SImode && mode1 == V4SFmode && mode2 == QImode)\n \ttype = v4si_ftype_v4sf_int;\n@@ -8196,7 +8200,7 @@ rs6000_common_init_builtins (void)\n \n       if (d->name == 0 || d->icode == CODE_FOR_nothing)\n \tcontinue;\n-      \n+\n       mode0 = insn_data[d->icode].operand[0].mode;\n       mode1 = insn_data[d->icode].operand[1].mode;\n \n@@ -8326,7 +8330,7 @@ expand_block_clear (rtx operands[])\n       rtx (*mov) (rtx, rtx);\n       enum machine_mode mode = BLKmode;\n       rtx dest;\n-      \n+\n       if (bytes >= 8 && TARGET_POWERPC64\n \t       /* 64-bit loads and stores require word-aligned\n \t\t  displacements.  */\n@@ -8354,9 +8358,9 @@ expand_block_clear (rtx operands[])\n \t  mode = QImode;\n \t  mov = gen_movqi;\n \t}\n-      \n+\n       dest = adjust_address (orig_dest, mode, offset);\n-      \n+\n       emit_insn ((*mov) (dest, const0_rtx));\n     }\n \n@@ -8404,7 +8408,7 @@ expand_block_move (rtx operands[])\n     return 1;\n \n   /* store_one_arg depends on expand_block_move to handle at least the size of\n-     reg_parm_stack_space.  */\t\n+     reg_parm_stack_space.  */\n   if (bytes > (TARGET_POWERPC64 ? 64 : 32))\n     return 0;\n \n@@ -8416,7 +8420,7 @@ expand_block_move (rtx operands[])\n       } gen_func;\n       enum machine_mode mode = BLKmode;\n       rtx src, dest;\n-      \n+\n       if (TARGET_STRING\n \t  && bytes > 24\t\t/* move up to 32 bytes at a time */\n \t  && ! fixed_regs[5]\n@@ -8490,14 +8494,14 @@ expand_block_move (rtx operands[])\n \t  mode = QImode;\n \t  gen_func.mov = gen_movqi;\n \t}\n-      \n+\n       src = adjust_address (orig_src, mode, offset);\n       dest = adjust_address (orig_dest, mode, offset);\n-      \n-      if (mode != BLKmode) \n+\n+      if (mode != BLKmode)\n \t{\n \t  rtx tmp_reg = gen_reg_rtx (mode);\n-\t  \n+\n \t  emit_insn ((*gen_func.mov) (tmp_reg, src));\n \t  stores[num_reg++] = (*gen_func.mov) (dest, tmp_reg);\n \t}\n@@ -8520,14 +8524,14 @@ expand_block_move (rtx operands[])\n \t      src = replace_equiv_address (src, src_reg);\n \t    }\n \t  set_mem_size (src, GEN_INT (move_bytes));\n-\t  \n+\n \t  if (!REG_P (XEXP (dest, 0)))\n \t    {\n \t      rtx dest_reg = copy_addr_to_reg (XEXP (dest, 0));\n \t      dest = replace_equiv_address (dest, dest_reg);\n \t    }\n \t  set_mem_size (dest, GEN_INT (move_bytes));\n-\t  \n+\n \t  emit_insn ((*gen_func.movmemsi) (dest, src,\n \t\t\t\t\t   GEN_INT (move_bytes & 31),\n \t\t\t\t\t   align_rtx));\n@@ -8912,7 +8916,7 @@ mtcrf_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n       || XVECLEN (SET_SRC (XVECEXP (op, 0, 0)), 0) != 2)\n     return 0;\n   src_reg = XVECEXP (SET_SRC (XVECEXP (op, 0, 0)), 0, 0);\n-  \n+\n   if (GET_CODE (src_reg) != REG\n       || GET_MODE (src_reg) != SImode\n       || ! INT_REGNO_P (REGNO (src_reg)))\n@@ -8923,15 +8927,15 @@ mtcrf_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n       rtx exp = XVECEXP (op, 0, i);\n       rtx unspec;\n       int maskval;\n-      \n+\n       if (GET_CODE (exp) != SET\n \t  || GET_CODE (SET_DEST (exp)) != REG\n \t  || GET_MODE (SET_DEST (exp)) != CCmode\n \t  || ! CR_REGNO_P (REGNO (SET_DEST (exp))))\n \treturn 0;\n       unspec = SET_SRC (exp);\n       maskval = 1 << (MAX_CR_REGNO - REGNO (SET_DEST (exp)));\n-      \n+\n       if (GET_CODE (unspec) != UNSPEC\n \t  || XINT (unspec, 1) != UNSPEC_MOVESI_TO_CR\n \t  || XVECLEN (unspec, 0) != 2\n@@ -9122,8 +9126,8 @@ validate_condition_mode (enum rtx_code code, enum machine_mode mode)\n \t  || code == UNGT || code == UNLT\n \t  || code == UNGE || code == UNLE))\n     abort ();\n-  \n-  /* These should never be generated except for \n+\n+  /* These should never be generated except for\n      flag_finite_math_only.  */\n   if (mode == CCFPmode\n       && ! flag_finite_math_only\n@@ -9133,7 +9137,7 @@ validate_condition_mode (enum rtx_code code, enum machine_mode mode)\n     abort ();\n \n   /* These are invalid; the information is not there.  */\n-  if (mode == CCEQmode \n+  if (mode == CCEQmode\n       && code != EQ && code != NE)\n     abort ();\n }\n@@ -9431,9 +9435,9 @@ int\n registers_ok_for_quad_peep (rtx reg1, rtx reg2)\n {\n   /* We might have been passed a SUBREG.  */\n-  if (GET_CODE (reg1) != REG || GET_CODE (reg2) != REG) \n+  if (GET_CODE (reg1) != REG || GET_CODE (reg2) != REG)\n     return 0;\n-    \n+\n   /* We might have been passed non floating point registers.  */\n   if (!FP_REGNO_P (REGNO (reg1))\n       || !FP_REGNO_P (REGNO (reg2)))\n@@ -9456,7 +9460,7 @@ mems_ok_for_quad_peep (rtx mem1, rtx mem2)\n   /* The mems cannot be volatile.  */\n   if (MEM_VOLATILE_P (mem1) || MEM_VOLATILE_P (mem2))\n     return 0;\n-  \n+\n   addr1 = XEXP (mem1, 0);\n   addr2 = XEXP (mem2, 0);\n \n@@ -9485,7 +9489,7 @@ mems_ok_for_quad_peep (rtx mem1, rtx mem2)\n     }\n \n   /* Make sure the second address is a (mem (plus (reg) (const_int)))\n-     or if it is (mem (reg)) then make sure that offset1 is -8 and the same \n+     or if it is (mem (reg)) then make sure that offset1 is -8 and the same\n      register as addr1.  */\n   if (offset1 == -8 && GET_CODE (addr2) == REG && reg1 == REGNO (addr2))\n     return 1;\n@@ -9513,7 +9517,7 @@ mems_ok_for_quad_peep (rtx mem1, rtx mem2)\n    NO_REGS is returned.  */\n \n enum reg_class\n-secondary_reload_class (enum reg_class class, \n+secondary_reload_class (enum reg_class class,\n \t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\trtx in)\n {\n@@ -9529,7 +9533,7 @@ secondary_reload_class (enum reg_class class,\n          other than BASE_REGS for TARGET_ELF.  So indicate that a\n          register from BASE_REGS is needed as an intermediate\n          register.\n-         \n+\n \t On Darwin, pic addresses require a load from memory, which\n \t needs a base register.  */\n       if (class != BASE_REGS\n@@ -9585,7 +9589,7 @@ secondary_reload_class (enum reg_class class,\n }\n \f\n /* Given a comparison operation, return the bit number in CCR to test.  We\n-   know this is a valid comparison.  \n+   know this is a valid comparison.\n \n    SCC_P is 1 if this is for an scc.  That means that %D will have been\n    used instead of %C, so the bits will be in different places.\n@@ -9621,7 +9625,7 @@ ccr_bit (rtx op, int scc_p)\n   if (scc_p && code != EQ && code != GT && code != LT && code != UNORDERED\n       && code != GTU && code != LTU)\n     abort ();\n-  \n+\n   switch (code)\n     {\n     case NE:\n@@ -10038,7 +10042,7 @@ print_operand (FILE *file, rtx x, int code)\n \t\t     reg_names[SMALL_DATA_REG]);\n \t}\n       return;\n-\t\t\t    \n+\n     case 'm':\n       /* MB value for a mask operand.  */\n       if (! mask_operand (x, SImode))\n@@ -10126,7 +10130,7 @@ print_operand (FILE *file, rtx x, int code)\n \t    else\n \t      s = t[1];\n \t  }\n-\t\n+\n \tfputs (s, file);\n       }\n       return;\n@@ -10213,7 +10217,7 @@ print_operand (FILE *file, rtx x, int code)\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%u value\");\n       else\n-\tfprintf (file, HOST_WIDE_INT_PRINT_HEX, \n+\tfprintf (file, HOST_WIDE_INT_PRINT_HEX,\n \t\t (INT_LOWPART (x) >> 16) & 0xffff);\n       return;\n \n@@ -10277,7 +10281,7 @@ print_operand (FILE *file, rtx x, int code)\n       /* If constant, low-order 16 bits of constant, signed.  Otherwise, write\n \t normally.  */\n       if (INT_P (x))\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, \n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC,\n \t\t ((INT_LOWPART (x) & 0xffff) ^ 0x8000) - 0x8000);\n       else\n \tprint_operand (file, x, 0);\n@@ -10338,7 +10342,7 @@ print_operand (FILE *file, rtx x, int code)\n \t\t     reg_names[SMALL_DATA_REG]);\n \t}\n       return;\n-\t\t\t    \n+\n     case 'z':\n       /* X is a SYMBOL_REF.  Write out the name preceded by a\n \t period and without any trailing data in brackets.  Used for function\n@@ -10435,7 +10439,7 @@ print_operand (FILE *file, rtx x, int code)\n \t  abort ();\n \tbreak;\n       }\n-\t\t\t    \n+\n     case 0:\n       if (GET_CODE (x) == REG)\n \tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n@@ -10518,7 +10522,7 @@ print_operand_address (FILE *file, rtx x)\n \t  rtx contains_minus = XEXP (x, 1);\n \t  rtx minus, symref;\n \t  const char *name;\n-\t  \n+\n \t  /* Find the (minus (sym) (toc)) buried in X, and temporarily\n \t     turn it into (sym) for output_addr_const.  */\n \t  while (GET_CODE (XEXP (contains_minus, 0)) != MINUS)\n@@ -10565,7 +10569,7 @@ rs6000_assemble_integer (rtx x, unsigned int size, int aligned_p)\n     {\n       extern int in_toc_section (void);\n       static int recurse = 0;\n-      \n+\n       /* For -mrelocatable, we mark all addresses that need to be fixed up\n \t in the .fixup section.  */\n       if (TARGET_RELOCATABLE\n@@ -10649,7 +10653,7 @@ rs6000_reverse_condition (enum machine_mode mode, enum rtx_code code)\n {\n   /* Reversal of FP compares takes care -- an ordered compare\n      becomes an unordered compare and vice versa.  */\n-  if (mode == CCFPmode \n+  if (mode == CCFPmode\n       && (!flag_finite_math_only\n \t  || code == UNLT || code == UNLE || code == UNGT || code == UNGE\n \t  || code == UNEQ || code == LTGT))\n@@ -10765,9 +10769,9 @@ rs6000_generate_compare (enum rtx_code code)\n   else\n     emit_insn (gen_rtx_SET (VOIDmode, compare_result,\n \t\t\t    gen_rtx_COMPARE (comp_mode,\n-\t\t\t\t\t     rs6000_compare_op0, \n+\t\t\t\t\t     rs6000_compare_op0,\n \t\t\t\t\t     rs6000_compare_op1)));\n-  \n+\n   /* Some kinds of FP comparisons need an OR operation;\n      under flag_finite_math_only we don't bother.  */\n   if (rs6000_compare_fp_p\n@@ -10780,7 +10784,7 @@ rs6000_generate_compare (enum rtx_code code)\n       enum rtx_code or1, or2;\n       rtx or1_rtx, or2_rtx, compare2_rtx;\n       rtx or_result = gen_reg_rtx (CCEQmode);\n-      \n+\n       switch (code)\n \t{\n \tcase LE: or1 = LT;  or2 = EQ;  break;\n@@ -10805,7 +10809,7 @@ rs6000_generate_compare (enum rtx_code code)\n     }\n \n   validate_condition_mode (code, GET_MODE (compare_result));\n-  \n+\n   return gen_rtx_fmt_ee (code, VOIDmode, compare_result, const0_rtx);\n }\n \n@@ -10848,7 +10852,7 @@ rs6000_emit_sCOND (enum rtx_code code, rtx result)\n       rtx not_result = gen_reg_rtx (CCEQmode);\n       rtx not_op, rev_cond_rtx;\n       enum machine_mode cc_mode;\n-      \n+\n       cc_mode = GET_MODE (XEXP (condition_rtx, 0));\n \n       rev_cond_rtx = gen_rtx_fmt_ee (rs6000_reverse_condition (cc_mode, cond_code),\n@@ -10890,7 +10894,7 @@ rs6000_emit_cbranch (enum rtx_code code, rtx loc)\n \n /* Return the string to output a conditional branch to LABEL, which is\n    the operand number of the label, or -1 if the branch is really a\n-   conditional return.  \n+   conditional return.\n \n    OP is the conditional expression.  XEXP (OP, 0) is assumed to be a\n    condition code register and its mode specifies what kind of\n@@ -10951,13 +10955,13 @@ output_cbranch (rtx op, const char *label, int reversed, rtx insn)\n       ccode = \"ne\"; break;\n     case EQ: case UNEQ:\n       ccode = \"eq\"; break;\n-    case GE: case GEU: \n+    case GE: case GEU:\n       ccode = \"ge\"; break;\n-    case GT: case GTU: case UNGT: \n+    case GT: case GTU: case UNGT:\n       ccode = \"gt\"; break;\n-    case LE: case LEU: \n+    case LE: case LEU:\n       ccode = \"le\"; break;\n-    case LT: case LTU: case UNLT: \n+    case LT: case LTU: case UNLT:\n       ccode = \"lt\"; break;\n     case UNORDERED: ccode = \"un\"; break;\n     case ORDERED: ccode = \"nu\"; break;\n@@ -10966,8 +10970,8 @@ output_cbranch (rtx op, const char *label, int reversed, rtx insn)\n     default:\n       abort ();\n     }\n-  \n-  /* Maybe we have a guess as to how likely the branch is.  \n+\n+  /* Maybe we have a guess as to how likely the branch is.\n      The old mnemonics don't have a way to specify this information.  */\n   pred = \"\";\n   note = find_reg_note (insn, REG_BR_PROB, NULL_RTX);\n@@ -10981,7 +10985,7 @@ output_cbranch (rtx op, const char *label, int reversed, rtx insn)\n \t prediction.  For older cpus we may as well always hint, but\n \t assume not taken for branches that are very close to 50% as a\n \t mispredicted taken branch is more expensive than a\n-\t mispredicted not-taken branch.  */ \n+\t mispredicted not-taken branch.  */\n       if (rs6000_always_hint\n \t  || abs (prob) > REG_BR_PROB_BASE / 100 * 48)\n \t{\n@@ -11089,10 +11093,10 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n      it'll probably be faster to use a branch here too.  */\n   if (code == UNEQ && HONOR_NANS (compare_mode))\n     return 0;\n-  \n+\n   if (GET_CODE (op1) == CONST_DOUBLE)\n     REAL_VALUE_FROM_CONST_DOUBLE (c1, op1);\n-    \n+\n   /* We're going to try to implement comparisons by performing\n      a subtract, then comparing against zero.  Unfortunately,\n      Inf - Inf is NaN which is not zero, and so if we don't\n@@ -11103,7 +11107,7 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n       && (GET_CODE (op1) != CONST_DOUBLE || real_isinf (&c1))\n       /* Constructs of the form (a OP b ? a : b) are safe.  */\n       && ((! rtx_equal_p (op0, false_cond) && ! rtx_equal_p (op1, false_cond))\n-\t  || (! rtx_equal_p (op0, true_cond) \n+\t  || (! rtx_equal_p (op0, true_cond)\n \t      && ! rtx_equal_p (op1, true_cond))))\n     return 0;\n   /* At this point we know we can use fsel.  */\n@@ -11156,7 +11160,7 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n \n     case EQ:\n       temp = gen_reg_rtx (compare_mode);\n-      emit_insn (gen_rtx_SET (VOIDmode, temp, \n+      emit_insn (gen_rtx_SET (VOIDmode, temp,\n \t\t\t      gen_rtx_NEG (compare_mode,\n \t\t\t\t\t   gen_rtx_ABS (compare_mode, op0))));\n       op0 = temp;\n@@ -11182,7 +11186,7 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n       /* a GT 0 <-> (a GE 0 && -a UNLT 0) */\n       temp = gen_reg_rtx (result_mode);\n       emit_insn (gen_rtx_SET (VOIDmode, temp,\n-\t\t\t      gen_rtx_IF_THEN_ELSE (result_mode, \n+\t\t\t      gen_rtx_IF_THEN_ELSE (result_mode,\n \t\t\t\t\t\t    gen_rtx_GE (VOIDmode,\n \t\t\t\t\t\t\t\top0, op1),\n \t\t\t\t\t\t    true_cond, false_cond)));\n@@ -11261,10 +11265,10 @@ rs6000_emit_minmax (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n     c = GEU;\n \n   if (code == SMAX || code == UMAX)\n-    target = emit_conditional_move (dest, c, op0, op1, mode, \n+    target = emit_conditional_move (dest, c, op0, op1, mode,\n \t\t\t\t    op0, op1, mode, 0);\n   else\n-    target = emit_conditional_move (dest, c, op0, op1, mode, \n+    target = emit_conditional_move (dest, c, op0, op1, mode,\n \t\t\t\t    op1, op0, mode, 0);\n   if (target == NULL_RTX)\n     abort ();\n@@ -11301,17 +11305,17 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n   else\n     reg_mode = word_mode;\n   reg_mode_size = GET_MODE_SIZE (reg_mode);\n-  \n+\n   if (reg_mode_size * nregs != GET_MODE_SIZE (mode))\n     abort ();\n-  \n+\n   if (REG_P (src) && REG_P (dst) && (REGNO (src) < REGNO (dst)))\n     {\n       /* Move register range backwards, if we might have destructive\n \t overlap.  */\n       int i;\n       for (i = nregs - 1; i >= 0; i--)\n-\temit_insn (gen_rtx_SET (VOIDmode, \n+\temit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\tsimplify_gen_subreg (reg_mode, dst, mode,\n \t\t\t\t\t\t     i * reg_mode_size),\n \t\t\t\tsimplify_gen_subreg (reg_mode, src, mode,\n@@ -11332,9 +11336,9 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t    {\n \t      rtx delta_rtx;\n \t      breg = XEXP (XEXP (src, 0), 0);\n-\t      delta_rtx =  GET_CODE (XEXP (src, 0)) == PRE_INC \n-\t\t  ? GEN_INT (GET_MODE_SIZE (GET_MODE (src))) \n-\t\t  : GEN_INT (-GET_MODE_SIZE (GET_MODE (src))); \n+\t      delta_rtx =  GET_CODE (XEXP (src, 0)) == PRE_INC\n+\t\t  ? GEN_INT (GET_MODE_SIZE (GET_MODE (src)))\n+\t\t  : GEN_INT (-GET_MODE_SIZE (GET_MODE (src)));\n \t      emit_insn (TARGET_32BIT\n \t\t\t ? gen_addsi3 (breg, breg, delta_rtx)\n \t\t\t : gen_adddi3 (breg, breg, delta_rtx));\n@@ -11351,7 +11355,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t    }\n \n \t  /* We have now address involving an base register only.\n-\t     If we use one of the registers to address memory, \n+\t     If we use one of the registers to address memory,\n \t     we have change that register last.  */\n \n \t  breg = (GET_CODE (XEXP (src, 0)) == PLUS\n@@ -11361,7 +11365,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t  if (!REG_P (breg))\n \t      abort();\n \n-\t  if (REGNO (breg) >= REGNO (dst) \n+\t  if (REGNO (breg) >= REGNO (dst)\n \t      && REGNO (breg) < REGNO (dst) + nregs)\n \t    j = REGNO (breg) - REGNO (dst);\n         }\n@@ -11375,9 +11379,9 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t    {\n \t      rtx delta_rtx;\n \t      breg = XEXP (XEXP (dst, 0), 0);\n-\t      delta_rtx = GET_CODE (XEXP (dst, 0)) == PRE_INC \n-\t\t? GEN_INT (GET_MODE_SIZE (GET_MODE (dst))) \n-\t\t: GEN_INT (-GET_MODE_SIZE (GET_MODE (dst))); \n+\t      delta_rtx = GET_CODE (XEXP (dst, 0)) == PRE_INC\n+\t\t? GEN_INT (GET_MODE_SIZE (GET_MODE (dst)))\n+\t\t: GEN_INT (-GET_MODE_SIZE (GET_MODE (dst)));\n \n \t      /* We have to update the breg before doing the store.\n \t\t Use store with update, if available.  */\n@@ -11401,17 +11405,17 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t}\n \n       for (i = 0; i < nregs; i++)\n-\t{  \n+\t{\n \t  /* Calculate index to next subword.  */\n \t  ++j;\n-\t  if (j == nregs) \n+\t  if (j == nregs)\n \t    j = 0;\n \n-\t  /* If compiler already emited move of first word by \n+\t  /* If compiler already emited move of first word by\n \t     store with update, no need to do anything.  */\n \t  if (j == 0 && used_update)\n \t    continue;\n-\t  \n+\n \t  emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t  simplify_gen_subreg (reg_mode, dst, mode,\n \t\t\t\t\t\t       j * reg_mode_size),\n@@ -11435,7 +11439,7 @@ first_reg_to_save (void)\n \n   /* Find lowest numbered live register.  */\n   for (first_reg = 13; first_reg <= 31; first_reg++)\n-    if (regs_ever_live[first_reg] \n+    if (regs_ever_live[first_reg]\n \t&& (! call_used_regs[first_reg]\n \t    || (first_reg == RS6000_PIC_OFFSET_TABLE_REGNUM\n \t\t&& ((DEFAULT_ABI == ABI_V4 && flag_pic != 0)\n@@ -11537,21 +11541,21 @@ compute_save_world_info(rs6000_stack_t *info_ptr)\n     && info_ptr->first_gp_reg_save == FIRST_SAVED_GP_REGNO\n     && info_ptr->first_altivec_reg_save == FIRST_SAVED_ALTIVEC_REGNO\n     && info_ptr->cr_save_p;\n-  \n+\n   /* This will not work in conjunction with sibcalls.  Make sure there\n      are none.  (This check is expensive, but seldom executed.) */\n   if ( info_ptr->world_save_p )\n-    { \n+    {\n       rtx insn;\n       for ( insn = get_last_insn_anywhere (); insn; insn = PREV_INSN (insn))\n         if ( GET_CODE (insn) == CALL_INSN\n              && SIBLING_CALL_P (insn))\n-          { \n+          {\n             info_ptr->world_save_p = 0;\n             break;\n           }\n     }\n-  \n+\n   if (info_ptr->world_save_p)\n     {\n       /* Even if we're not touching VRsave, make sure there's room on the\n@@ -11566,11 +11570,11 @@ compute_save_world_info(rs6000_stack_t *info_ptr)\n       /* Because the Darwin register save/restore routines only handle\n          F14 .. F31 and V20 .. V31 as per the ABI, perform a consistancy\n          check and abort if there's something worng.  */\n-      if (info_ptr->first_fp_reg_save < FIRST_SAVED_FP_REGNO \n+      if (info_ptr->first_fp_reg_save < FIRST_SAVED_FP_REGNO\n           || info_ptr->first_altivec_reg_save < FIRST_SAVED_ALTIVEC_REGNO)\n         abort ();\n     }\n-  return; \n+  return;\n }\n \n \n@@ -11637,11 +11641,11 @@ is_altivec_return_reg (rtx reg, void *xyes)\n \t\t| Parameter save area (P)\t\t| 8\n \t\t+---------------------------------------+\n \t\t| Alloca space (A)\t\t\t| 8+P\n-\t\t+---------------------------------------+    \n+\t\t+---------------------------------------+\n \t\t| Varargs save area (V)\t\t\t| 8+P+A\n-\t\t+---------------------------------------+    \n+\t\t+---------------------------------------+\n \t\t| Local variable space (L)\t\t| 8+P+A+V\n-\t\t+---------------------------------------+    \n+\t\t+---------------------------------------+\n \t\t| Float/int conversion temporary (X)\t| 8+P+A+V+L\n \t\t+---------------------------------------+\n \t\t| Save area for AltiVec registers (W)\t| 8+P+A+V+L+X\n@@ -11655,9 +11659,9 @@ is_altivec_return_reg (rtx reg, void *xyes)\n                 | SPE alignment padding                 |\n                 +---------------------------------------+\n \t\t| saved CR (C)\t\t\t\t| 8+P+A+V+L+X+W+Y+Z\n-\t\t+---------------------------------------+    \n+\t\t+---------------------------------------+\n \t\t| Save area for GP registers (G)\t| 8+P+A+V+L+X+W+Y+Z+C\n-\t\t+---------------------------------------+    \n+\t\t+---------------------------------------+\n \t\t| Save area for FP registers (F)\t| 8+P+A+V+L+X+W+Y+Z+C+G\n \t\t+---------------------------------------+\n \told SP->| back chain to caller's caller\t\t|\n@@ -11707,7 +11711,7 @@ rs6000_stack_info (void)\n \n   /* Calculate which registers need to be saved & save area size.  */\n   info_ptr->first_gp_reg_save = first_reg_to_save ();\n-  /* Assume that we will have to save RS6000_PIC_OFFSET_TABLE_REGNUM, \n+  /* Assume that we will have to save RS6000_PIC_OFFSET_TABLE_REGNUM,\n      even if it currently looks like we won't.  */\n   if (((TARGET_TOC && TARGET_MINIMAL_TOC)\n        || (flag_pic == 1 && DEFAULT_ABI == ABI_V4)\n@@ -11765,7 +11769,7 @@ rs6000_stack_info (void)\n     }\n \n   /* Determine if we need to save the condition code registers.  */\n-  if (regs_ever_live[CR2_REGNO] \n+  if (regs_ever_live[CR2_REGNO]\n       || regs_ever_live[CR3_REGNO]\n       || regs_ever_live[CR4_REGNO])\n     {\n@@ -12249,7 +12253,7 @@ rs6000_ra_ever_killed (void)\n \n      When we're called from the epilogue, we need to avoid counting\n      this as a store.  */\n-         \n+\n   push_topmost_sequence ();\n   top = get_insns ();\n   pop_topmost_sequence ();\n@@ -12261,7 +12265,7 @@ rs6000_ra_ever_killed (void)\n \t{\n \t  if (FIND_REG_INC_NOTE (insn, reg))\n \t    return 1;\n-\t  else if (GET_CODE (insn) == CALL_INSN \n+\t  else if (GET_CODE (insn) == CALL_INSN\n \t\t   && !SIBLING_CALL_P (insn))\n \t    return 1;\n \t  else if (set_of (reg, insn) != NULL_RTX\n@@ -12422,20 +12426,20 @@ rs6000_emit_eh_reg_restore (rtx source, rtx scratch)\n \n static GTY(()) int set = -1;\n \n-int   \n+int\n get_TOC_alias_set (void)\n {\n   if (set == -1)\n     set = new_alias_set ();\n   return set;\n-}   \n+}\n \n /* This returns nonzero if the current function uses the TOC.  This is\n    determined by the presence of (use (unspec ... UNSPEC_TOC)), which\n    is generated by the ABI_V4 load_toc_* patterns.  */\n #if TARGET_ELF\n static int\n-uses_TOC (void) \n+uses_TOC (void)\n {\n   rtx insn;\n \n@@ -12445,7 +12449,7 @@ uses_TOC (void)\n \trtx pat = PATTERN (insn);\n \tint i;\n \n-\tif (GET_CODE (pat) == PARALLEL) \n+\tif (GET_CODE (pat) == PARALLEL)\n \t  for (i = 0; i < XVECLEN (pat, 0); i++)\n \t    {\n \t      rtx sub = XVECEXP (pat, 0, i);\n@@ -12463,12 +12467,12 @@ uses_TOC (void)\n #endif\n \n rtx\n-create_TOC_reference (rtx symbol) \n+create_TOC_reference (rtx symbol)\n {\n-  return gen_rtx_PLUS (Pmode, \n+  return gen_rtx_PLUS (Pmode,\n \t   gen_rtx_REG (Pmode, TOC_REGISTER),\n-\t     gen_rtx_CONST (Pmode, \n-\t       gen_rtx_MINUS (Pmode, symbol, \n+\t     gen_rtx_CONST (Pmode,\n+\t       gen_rtx_MINUS (Pmode, symbol,\n \t\t gen_rtx_SYMBOL_REF (Pmode, toc_label_name))));\n }\n \n@@ -12535,7 +12539,7 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n   if (current_function_limit_stack)\n     {\n       if (REG_P (stack_limit_rtx)\n-\t  && REGNO (stack_limit_rtx) > 1 \n+\t  && REGNO (stack_limit_rtx) > 1\n \t  && REGNO (stack_limit_rtx) <= 31)\n \t{\n \t  emit_insn (TARGET_32BIT\n@@ -12554,8 +12558,8 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n \t       && DEFAULT_ABI == ABI_V4)\n \t{\n \t  rtx toload = gen_rtx_CONST (VOIDmode,\n-\t\t\t\t      gen_rtx_PLUS (Pmode, \n-\t\t\t\t\t\t    stack_limit_rtx, \n+\t\t\t\t      gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t    stack_limit_rtx,\n \t\t\t\t\t\t    GEN_INT (size)));\n \n \t  emit_insn (gen_elf_high (tmp_reg, toload));\n@@ -12585,7 +12589,7 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n       insn = emit_insn (TARGET_32BIT\n \t\t\t? gen_movsi_update (stack_reg, stack_reg,\n \t\t\t\t\t    todec, stack_reg)\n-\t\t\t: gen_movdi_update (stack_reg, stack_reg, \n+\t\t\t: gen_movdi_update (stack_reg, stack_reg,\n \t\t\t\t\t    todec, stack_reg));\n     }\n   else\n@@ -12596,11 +12600,11 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n       emit_move_insn (gen_rtx_MEM (Pmode, stack_reg),\n \t\t      gen_rtx_REG (Pmode, 12));\n     }\n- \n+\n   RTX_FRAME_RELATED_P (insn) = 1;\n-  REG_NOTES (insn) = \n+  REG_NOTES (insn) =\n     gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t       gen_rtx_SET (VOIDmode, stack_reg, \n+\t\t       gen_rtx_SET (VOIDmode, stack_reg,\n \t\t\t\t    gen_rtx_PLUS (Pmode, stack_reg,\n \t\t\t\t\t\t  GEN_INT (-size))),\n \t\t       REG_NOTES (insn));\n@@ -12613,7 +12617,7 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n    its hand so much.  */\n \n static void\n-rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val, \n+rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n \t\t      rtx reg2, rtx rreg)\n {\n   rtx real, temp;\n@@ -12630,20 +12634,20 @@ rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n \n   if (reg2 != NULL_RTX)\n     real = replace_rtx (real, reg2, rreg);\n-  \n-  real = replace_rtx (real, reg, \n+\n+  real = replace_rtx (real, reg,\n \t\t      gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode,\n \t\t\t\t\t\t\tSTACK_POINTER_REGNUM),\n \t\t\t\t    GEN_INT (val)));\n-  \n+\n   /* We expect that 'real' is either a SET or a PARALLEL containing\n      SETs (and possibly other stuff).  In a PARALLEL, all the SETs\n      are important so they all have to be marked RTX_FRAME_RELATED_P.  */\n \n   if (GET_CODE (real) == SET)\n     {\n       rtx set = real;\n-      \n+\n       temp = simplify_rtx (SET_SRC (set));\n       if (temp)\n \tSET_SRC (set) = temp;\n@@ -12664,7 +12668,7 @@ rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n \tif (GET_CODE (XVECEXP (real, 0, i)) == SET)\n \t  {\n \t    rtx set = XVECEXP (real, 0, i);\n-\t    \n+\n \t    temp = simplify_rtx (SET_SRC (set));\n \t    if (temp)\n \t      SET_SRC (set) = temp;\n@@ -12818,7 +12822,7 @@ generate_set_vrsave (rtx reg, rs6000_stack_t *info, int epiloguep)\n    Save REGNO into [FRAME_REG + OFFSET] in mode MODE.  */\n \n static void\n-emit_frame_save (rtx frame_reg, rtx frame_ptr, enum machine_mode mode, \n+emit_frame_save (rtx frame_reg, rtx frame_ptr, enum machine_mode mode,\n \t\t unsigned int regno, int offset, HOST_WIDE_INT total_size)\n {\n   rtx reg, offset_rtx, insn, mem, addr, int_rtx;\n@@ -12898,7 +12902,7 @@ rs6000_emit_prologue (void)\n   int saving_FPRs_inline;\n   int using_store_multiple;\n   HOST_WIDE_INT sp_offset = 0;\n-  \n+\n   if (TARGET_FIX_AND_CONTINUE)\n     {\n       /* gdb on darwin arranges to forward a function from the old\n@@ -12936,7 +12940,7 @@ rs6000_emit_prologue (void)\n \tsp_offset = info->total_size;\n       else\n \tframe_reg_rtx = frame_ptr_rtx;\n-      rs6000_emit_allocate_stack (info->total_size, \n+      rs6000_emit_allocate_stack (info->total_size,\n \t\t\t\t  (frame_reg_rtx != sp_reg_rtx\n \t\t\t\t   && (info->cr_save_p\n \t\t\t\t       || info->lr_save_p\n@@ -13091,7 +13095,7 @@ rs6000_emit_prologue (void)\n \t    /* AltiVec addressing mode is [reg+reg].  */\n \t    mem = gen_rtx_MEM (V4SImode,\n \t\t\t       gen_rtx_PLUS (Pmode, frame_reg_rtx, areg));\n-\t\t\t       \n+\n \t    set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t    insn = emit_move_insn (mem, savereg);\n@@ -13148,7 +13152,7 @@ rs6000_emit_prologue (void)\n   if (! info->world_save_p && info->cr_save_p && frame_reg_rtx != frame_ptr_rtx)\n     {\n       rtx set;\n-      \n+\n       cr_save_rtx = gen_rtx_REG (SImode, 12);\n       insn = emit_insn (gen_movesi_from_cr (cr_save_rtx));\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -13171,7 +13175,7 @@ rs6000_emit_prologue (void)\n     {\n       int i;\n       for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n-\tif ((regs_ever_live[info->first_fp_reg_save+i] \n+\tif ((regs_ever_live[info->first_fp_reg_save+i]\n \t     && ! call_used_regs[info->first_fp_reg_save+i]))\n \t  emit_frame_save (frame_reg_rtx, frame_ptr_rtx, DFmode,\n \t\t\t   info->first_fp_reg_save + i,\n@@ -13185,9 +13189,9 @@ rs6000_emit_prologue (void)\n       const char *alloc_rname;\n       rtvec p;\n       p = rtvec_alloc (2 + 64 - info->first_fp_reg_save);\n-      \n-      RTVEC_ELT (p, 0) = gen_rtx_CLOBBER (VOIDmode, \n-\t\t\t\t\t  gen_rtx_REG (Pmode, \n+\n+      RTVEC_ELT (p, 0) = gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (Pmode,\n \t\t\t\t\t\t       LINK_REGISTER_REGNUM));\n       sprintf (rname, \"%s%d%s\", SAVE_FP_PREFIX,\n \t       info->first_fp_reg_save - 32, SAVE_FP_SUFFIX);\n@@ -13200,15 +13204,15 @@ rs6000_emit_prologue (void)\n \t  rtx addr, reg, mem;\n \t  reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n \t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t       GEN_INT (info->fp_save_offset \n+\t\t\t       GEN_INT (info->fp_save_offset\n \t\t\t\t\t+ sp_offset + 8*i));\n \t  mem = gen_rtx_MEM (DFmode, addr);\n \t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t  RTVEC_ELT (p, i + 2) = gen_rtx_SET (VOIDmode, mem, reg);\n \t}\n       insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n-      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n+      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t    NULL_RTX, NULL_RTX);\n     }\n \n@@ -13223,24 +13227,24 @@ rs6000_emit_prologue (void)\n \t{\n \t  rtx addr, reg, mem;\n \t  reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n-\t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, \n-\t\t\t       GEN_INT (info->gp_save_offset \n-\t\t\t\t\t+ sp_offset \n+\t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t       GEN_INT (info->gp_save_offset\n+\t\t\t\t\t+ sp_offset\n \t\t\t\t\t+ reg_size * i));\n \t  mem = gen_rtx_MEM (reg_mode, addr);\n \t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t  RTVEC_ELT (p, i) = gen_rtx_SET (VOIDmode, mem, reg);\n \t}\n       insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n-      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n+      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t    NULL_RTX, NULL_RTX);\n     }\n   else if (! info->world_save_p)\n     {\n       int i;\n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-\tif ((regs_ever_live[info->first_gp_reg_save+i] \n+\tif ((regs_ever_live[info->first_gp_reg_save+i]\n \t     && (! call_used_regs[info->first_gp_reg_save+i]\n \t\t || (i+info->first_gp_reg_save\n \t\t     == RS6000_PIC_OFFSET_TABLE_REGNUM\n@@ -13279,15 +13283,15 @@ rs6000_emit_prologue (void)\n \t      }\n \t    else\n \t      {\n-\t\taddr = gen_rtx_PLUS (Pmode, frame_reg_rtx, \n-\t\t\t\t     GEN_INT (info->gp_save_offset \n-\t\t\t\t\t      + sp_offset \n+\t\taddr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t     GEN_INT (info->gp_save_offset\n+\t\t\t\t\t      + sp_offset\n \t\t\t\t\t      + reg_size * i));\n \t\tmem = gen_rtx_MEM (reg_mode, addr);\n \t\tset_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t\tinsn = emit_move_insn (mem, reg);\n-\t\trs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n+\t\trs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t\t      NULL_RTX, NULL_RTX);\n \t      }\n \t  }\n@@ -13311,7 +13315,7 @@ rs6000_emit_prologue (void)\n \t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t  insn = emit_move_insn (mem, reg);\n-\t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n+\t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t\tNULL_RTX, NULL_RTX);\n \t  PATTERN (insn) = gen_blockage ();\n \t}\n@@ -13338,9 +13342,9 @@ rs6000_emit_prologue (void)\n       rtx mem = gen_rtx_MEM (Pmode, addr);\n       /* This should not be of rs6000_sr_alias_set, because of\n \t __builtin_return_address.  */\n-      \n+\n       insn = emit_move_insn (mem, reg);\n-      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n+      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t    NULL_RTX, NULL_RTX);\n     }\n \n@@ -13368,15 +13372,15 @@ rs6000_emit_prologue (void)\n \t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n \t\t\t\t\t\tset,\n \t\t\t\t\t\tREG_NOTES (insn));\n-\t  \n+\n \t}\n       insn = emit_move_insn (mem, cr_save_rtx);\n \n-      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n+      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t    NULL_RTX, NULL_RTX);\n     }\n \n-  /* Update stack and set back pointer unless this is V.4, \n+  /* Update stack and set back pointer unless this is V.4,\n      for which it was done previously.  */\n   if (! info->world_save_p && info->push_p\n       && !(DEFAULT_ABI == ABI_V4 || current_function_calls_eh_return))\n@@ -13385,7 +13389,7 @@ rs6000_emit_prologue (void)\n   /* Set frame pointer, if needed.  */\n   if (frame_pointer_needed)\n     {\n-      insn = emit_move_insn (gen_rtx_REG (Pmode, FRAME_POINTER_REGNUM), \n+      insn = emit_move_insn (gen_rtx_REG (Pmode, FRAME_POINTER_REGNUM),\n \t\t\t     sp_reg_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n@@ -13431,7 +13435,7 @@ rs6000_emit_prologue (void)\n \n       rs6000_maybe_dead (emit_insn (gen_load_macho_picbase (lr, src)));\n \n-      insn = emit_move_insn (gen_rtx_REG (Pmode, \n+      insn = emit_move_insn (gen_rtx_REG (Pmode,\n \t\t\t\t\t  RS6000_PIC_OFFSET_TABLE_REGNUM),\n \t\t\t     lr);\n       rs6000_maybe_dead (insn);\n@@ -13442,7 +13446,7 @@ rs6000_emit_prologue (void)\n /* Write function prologue.  */\n \n static void\n-rs6000_output_function_prologue (FILE *file, \n+rs6000_output_function_prologue (FILE *file,\n \t\t\t\t HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   rs6000_stack_t *info = rs6000_stack_info ();\n@@ -13500,7 +13504,7 @@ rs6000_output_function_prologue (FILE *file,\n \n   rs6000_pic_labelno++;\n }\n-  \n+\n /* Emit function epilogue as insns.\n \n    At present, dwarf2out_frame_debug_expr doesn't understand\n@@ -13539,7 +13543,7 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t   || current_function_calls_eh_return\n \t\t\t   || info->first_fp_reg_save == 64\n \t\t\t   || FP_SAVE_INLINE (info->first_fp_reg_save));\n-  use_backchain_to_restore_sp = (frame_pointer_needed \n+  use_backchain_to_restore_sp = (frame_pointer_needed\n \t\t\t\t || current_function_calls_alloca\n \t\t\t\t || info->total_size > 32767);\n   using_mfcr_multiple = (rs6000_cpu == PROCESSOR_PPC601\n@@ -13563,7 +13567,7 @@ rs6000_emit_epilogue (int sibcall)\n \n       p = rtvec_alloc (9\n \t\t       + 1\n-\t\t       + 32 - info->first_gp_reg_save \n+\t\t       + 32 - info->first_gp_reg_save\n                        + LAST_ALTIVEC_REGNO + 1 - info->first_altivec_reg_save\n                        + 63 + 1 - info->first_fp_reg_save);\n \n@@ -13654,7 +13658,7 @@ rs6000_emit_epilogue (int sibcall)\n \n       emit_move_insn (frame_reg_rtx,\n \t\t      gen_rtx_MEM (Pmode, sp_reg_rtx));\n-      \n+\n     }\n   else if (info->push_p)\n     {\n@@ -13670,7 +13674,7 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t\t   GEN_INT (info->total_size)));\n \t}\n     }\n-  \n+\n   /* Restore AltiVec registers if needed.  */\n   if (TARGET_ALTIVEC_ABI && info->altivec_size != 0)\n     {\n@@ -13722,7 +13726,7 @@ rs6000_emit_epilogue (int sibcall)\n \n       emit_move_insn (gen_rtx_REG (Pmode, 0), mem);\n     }\n-  \n+\n   /* Get the old cr if we saved it.  */\n   if (info->cr_save_p)\n     {\n@@ -13734,12 +13738,12 @@ rs6000_emit_epilogue (int sibcall)\n \n       emit_move_insn (gen_rtx_REG (SImode, 12), mem);\n     }\n-  \n+\n   /* Set LR here to try to overlap restores below.  */\n   if (info->lr_save_p)\n     emit_move_insn (gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM),\n \t\t    gen_rtx_REG (Pmode, 0));\n-  \n+\n   /* Load exception handler data registers, if needed.  */\n   if (current_function_calls_eh_return)\n     {\n@@ -13772,7 +13776,7 @@ rs6000_emit_epilogue (int sibcall)\n \t  emit_move_insn (gen_rtx_REG (reg_mode, regno), mem);\n \t}\n     }\n-  \n+\n   /* Restore GPRs.  This is done as a PARALLEL if we are using\n      the load-multiple instructions.  */\n   if (using_load_multiple)\n@@ -13781,15 +13785,15 @@ rs6000_emit_epilogue (int sibcall)\n       p = rtvec_alloc (32 - info->first_gp_reg_save);\n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n \t{\n-\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, \n-\t\t\t\t   GEN_INT (info->gp_save_offset \n-\t\t\t\t\t    + sp_offset \n+\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t   GEN_INT (info->gp_save_offset\n+\t\t\t\t\t    + sp_offset\n \t\t\t\t\t    + reg_size * i));\n \t  rtx mem = gen_rtx_MEM (reg_mode, addr);\n \n \t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n-\t  RTVEC_ELT (p, i) = \n+\t  RTVEC_ELT (p, i) =\n \t    gen_rtx_SET (VOIDmode,\n \t\t\t gen_rtx_REG (reg_mode, info->first_gp_reg_save + i),\n \t\t\t mem);\n@@ -13798,17 +13802,17 @@ rs6000_emit_epilogue (int sibcall)\n     }\n   else\n     for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-      if ((regs_ever_live[info->first_gp_reg_save+i] \n+      if ((regs_ever_live[info->first_gp_reg_save+i]\n \t   && (! call_used_regs[info->first_gp_reg_save+i]\n \t       || (i+info->first_gp_reg_save == RS6000_PIC_OFFSET_TABLE_REGNUM\n \t\t   && TARGET_TOC && TARGET_MINIMAL_TOC)))\n \t  || (i+info->first_gp_reg_save == RS6000_PIC_OFFSET_TABLE_REGNUM\n \t      && ((DEFAULT_ABI == ABI_V4 && flag_pic != 0)\n \t\t  || (DEFAULT_ABI == ABI_DARWIN && flag_pic))))\n \t{\n-\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, \n-\t\t\t\t   GEN_INT (info->gp_save_offset \n-\t\t\t\t\t    + sp_offset \n+\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t   GEN_INT (info->gp_save_offset\n+\t\t\t\t\t    + sp_offset\n \t\t\t\t\t    + reg_size * i));\n \t  rtx mem = gen_rtx_MEM (reg_mode, addr);\n \n@@ -13832,25 +13836,25 @@ rs6000_emit_epilogue (int sibcall)\n \n \t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n-\t  emit_move_insn (gen_rtx_REG (reg_mode, \n+\t  emit_move_insn (gen_rtx_REG (reg_mode,\n \t\t\t\t       info->first_gp_reg_save + i), mem);\n \t}\n \n   /* Restore fpr's if we need to do it without calling a function.  */\n   if (restoring_FPRs_inline)\n     for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n-      if ((regs_ever_live[info->first_fp_reg_save+i] \n+      if ((regs_ever_live[info->first_fp_reg_save+i]\n \t   && ! call_used_regs[info->first_fp_reg_save+i]))\n \t{\n \t  rtx addr, mem;\n \t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t       GEN_INT (info->fp_save_offset \n-\t\t\t\t\t+ sp_offset \n+\t\t\t       GEN_INT (info->fp_save_offset\n+\t\t\t\t\t+ sp_offset\n \t\t\t\t\t+ 8 * i));\n \t  mem = gen_rtx_MEM (DFmode, addr);\n \t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n-\t  emit_move_insn (gen_rtx_REG (DFmode, \n+\t  emit_move_insn (gen_rtx_REG (DFmode,\n \t\t\t\t       info->first_fp_reg_save + i),\n \t\t\t  mem);\n \t}\n@@ -13860,7 +13864,7 @@ rs6000_emit_epilogue (int sibcall)\n     {\n       rtx r12_rtx = gen_rtx_REG (SImode, 12);\n       int count = 0;\n-      \n+\n       if (using_mfcr_multiple)\n \t{\n \t  for (i = 0; i < 8; i++)\n@@ -13874,7 +13878,7 @@ rs6000_emit_epilogue (int sibcall)\n \t{\n \t  rtvec p;\n \t  int ndx;\n-\t  \n+\n \t  p = rtvec_alloc (count);\n \n \t  ndx = 0;\n@@ -13885,7 +13889,7 @@ rs6000_emit_epilogue (int sibcall)\n \t\tRTVEC_ELT (r, 0) = r12_rtx;\n \t\tRTVEC_ELT (r, 1) = GEN_INT (1 << (7-i));\n \t\tRTVEC_ELT (p, ndx) =\n-\t\t  gen_rtx_SET (VOIDmode, gen_rtx_REG (CCmode, CR0_REGNO+i), \n+\t\t  gen_rtx_SET (VOIDmode, gen_rtx_REG (CCmode, CR0_REGNO+i),\n \t\t\t       gen_rtx_UNSPEC (CCmode, r, UNSPEC_MOVESI_TO_CR));\n \t\tndx++;\n \t      }\n@@ -13897,7 +13901,7 @@ rs6000_emit_epilogue (int sibcall)\n \tfor (i = 0; i < 8; i++)\n \t  if (regs_ever_live[CR0_REGNO+i] && ! call_used_regs[CR0_REGNO+i])\n \t    {\n-\t      emit_insn (gen_movsi_to_cr_one (gen_rtx_REG (CCmode, \n+\t      emit_insn (gen_movsi_to_cr_one (gen_rtx_REG (CCmode,\n \t\t\t\t\t\t\t   CR0_REGNO+i),\n \t\t\t\t\t      r12_rtx));\n \t    }\n@@ -13946,8 +13950,8 @@ rs6000_emit_epilogue (int sibcall)\n \tp = rtvec_alloc (2);\n \n       RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);\n-      RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode, \n-\t\t\t\t      gen_rtx_REG (Pmode, \n+      RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode,\n+\t\t\t\t      gen_rtx_REG (Pmode,\n \t\t\t\t\t\t   LINK_REGISTER_REGNUM));\n \n       /* If we have to restore more than two FP registers, branch to the\n@@ -13958,7 +13962,7 @@ rs6000_emit_epilogue (int sibcall)\n \t  char rname[30];\n \t  const char *alloc_rname;\n \n-\t  sprintf (rname, \"%s%d%s\", RESTORE_FP_PREFIX, \n+\t  sprintf (rname, \"%s%d%s\", RESTORE_FP_PREFIX,\n \t\t   info->first_fp_reg_save - 32, RESTORE_FP_SUFFIX);\n \t  alloc_rname = ggc_strdup (rname);\n \t  RTVEC_ELT (p, 2) = gen_rtx_USE (VOIDmode,\n@@ -13973,21 +13977,21 @@ rs6000_emit_epilogue (int sibcall)\n \t      mem = gen_rtx_MEM (DFmode, addr);\n \t      set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n-\t      RTVEC_ELT (p, i+3) = \n+\t      RTVEC_ELT (p, i+3) =\n \t\tgen_rtx_SET (VOIDmode,\n \t\t\t     gen_rtx_REG (DFmode, info->first_fp_reg_save + i),\n \t\t\t     mem);\n \t    }\n \t}\n-      \n+\n       emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n     }\n }\n \n /* Write function epilogue.  */\n \n static void\n-rs6000_output_function_epilogue (FILE *file, \n+rs6000_output_function_epilogue (FILE *file,\n \t\t\t\t HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   rs6000_stack_t *info = rs6000_stack_info ();\n@@ -14039,8 +14043,8 @@ rs6000_output_function_epilogue (FILE *file,\n \t   && NOTE_P (insn)\n \t   && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED_LABEL)\n       insn = PREV_INSN (insn);\n-    if (insn \n-\t&& (LABEL_P (insn) \n+    if (insn\n+\t&& (LABEL_P (insn)\n \t    || (NOTE_P (insn)\n \t\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED_LABEL)))\n       fputs (\"\\tnop\\n\", file);\n@@ -14302,8 +14306,8 @@ rs6000_output_function_epilogue (FILE *file,\n    not support varargs.  */\n \n static void\n-rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED, \n-\t\t\tHOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset, \n+rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n+\t\t\tHOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n \t\t\ttree function)\n {\n   rtx this, insn, funexp;\n@@ -14405,7 +14409,7 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n /* A quick summary of the various types of 'constant-pool tables'\n    under PowerPC:\n \n-   Target\tFlags\t\tName\t\tOne table per\t\n+   Target\tFlags\t\tName\t\tOne table per\n    AIX\t\t(none)\t\tAIX TOC\t\tobject file\n    AIX\t\t-mfull-toc\tAIX TOC\t\tobject file\n    AIX\t\t-mminimal-toc\tAIX minimal TOC\ttranslation unit\n@@ -14414,7 +14418,7 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n    SVR4/EABI\t-fPIC\t\tSVR4 PIC\ttranslation unit\n    SVR4/EABI\t-mrelocatable\tEABI TOC\tfunction\n    SVR4/EABI\t-maix\t\tAIX TOC\t\tobject file\n-   SVR4/EABI\t-maix -mminimal-toc \n+   SVR4/EABI\t-maix -mminimal-toc\n \t\t\t\tAIX minimal TOC\ttranslation unit\n \n    Name\t\t\tReg.\tSet by\tentries\t      contains:\n@@ -14439,7 +14443,7 @@ rs6000_hash_constant (rtx k)\n   unsigned result = (code << 3) ^ mode;\n   const char *format;\n   int flen, fidx;\n-  \n+\n   format = GET_RTX_FORMAT (code);\n   flen = strlen (format);\n   fidx = 0;\n@@ -14507,7 +14511,7 @@ rs6000_hash_constant (rtx k)\n static unsigned\n toc_hash_function (const void *hash_entry)\n {\n-  const struct toc_hash_struct *thc = \n+  const struct toc_hash_struct *thc =\n     (const struct toc_hash_struct *) hash_entry;\n   return rs6000_hash_constant (thc->key) ^ thc->key_mode;\n }\n@@ -14537,20 +14541,20 @@ toc_hash_eq (const void *h1, const void *h2)\n   || strncmp (\"_ZTV\", name, strlen (\"_ZTV\")) == 0\t\\\n   || strncmp (\"_ZTT\", name, strlen (\"_ZTT\")) == 0\t\\\n   || strncmp (\"_ZTI\", name, strlen (\"_ZTI\")) == 0\t\\\n-  || strncmp (\"_ZTC\", name, strlen (\"_ZTC\")) == 0) \n+  || strncmp (\"_ZTC\", name, strlen (\"_ZTC\")) == 0)\n \n void\n rs6000_output_symbol_ref (FILE *file, rtx x)\n {\n   /* Currently C++ toc references to vtables can be emitted before it\n      is decided whether the vtable is public or private.  If this is\n      the case, then the linker will eventually complain that there is\n-     a reference to an unknown section.  Thus, for vtables only, \n+     a reference to an unknown section.  Thus, for vtables only,\n      we emit the TOC reference to reference the symbol and not the\n      section.  */\n   const char *name = XSTR (x, 0);\n \n-  if (VTABLE_NAME_P (name)) \n+  if (VTABLE_NAME_P (name))\n     {\n       RS6000_OUTPUT_BASENAME (file, name);\n     }\n@@ -14581,29 +14585,29 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n     {\n       struct toc_hash_struct *h;\n       void * * found;\n-      \n+\n       /* Create toc_hash_table.  This can't be done at OVERRIDE_OPTIONS\n          time because GGC is not initialized at that point.  */\n       if (toc_hash_table == NULL)\n-\ttoc_hash_table = htab_create_ggc (1021, toc_hash_function, \n+\ttoc_hash_table = htab_create_ggc (1021, toc_hash_function,\n \t\t\t\t\t  toc_hash_eq, NULL);\n \n       h = ggc_alloc (sizeof (*h));\n       h->key = x;\n       h->key_mode = mode;\n       h->labelno = labelno;\n-      \n+\n       found = htab_find_slot (toc_hash_table, h, 1);\n       if (*found == NULL)\n \t*found = h;\n-      else  /* This is indeed a duplicate.  \n+      else  /* This is indeed a duplicate.\n \t       Set this label equal to that label.  */\n \t{\n \t  fputs (\"\\t.set \", file);\n \t  ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LC\");\n \t  fprintf (file, \"%d,\", labelno);\n \t  ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LC\");\n-\t  fprintf (file, \"%d\\n\", ((*(const struct toc_hash_struct **) \n+\t  fprintf (file, \"%d\\n\", ((*(const struct toc_hash_struct **)\n \t\t\t\t\t      found)->labelno));\n \t  return;\n \t}\n@@ -14809,7 +14813,7 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n       base = XEXP (XEXP (x, 0), 0);\n       offset = INTVAL (XEXP (XEXP (x, 0), 1));\n     }\n-  \n+\n   if (GET_CODE (base) == SYMBOL_REF)\n     name = XSTR (base, 0);\n   else if (GET_CODE (base) == LABEL_REF)\n@@ -14933,7 +14937,7 @@ output_ascii (FILE *file, const char *p, int n)\n    the name.  */\n \n void\n-rs6000_gen_section_name (char **buf, const char *filename, \n+rs6000_gen_section_name (char **buf, const char *filename,\n \t\t         const char *section_desc)\n {\n   const char *q, *after_last_slash, *last_period = 0;\n@@ -14987,7 +14991,7 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n #ifndef NO_PROFILE_COUNTERS\n # define NO_PROFILE_COUNTERS 0\n #endif\n-      if (NO_PROFILE_COUNTERS)  \n+      if (NO_PROFILE_COUNTERS)\n \temit_library_call (init_one_libfunc (RS6000_MCOUNT), 0, VOIDmode, 0);\n       else\n \t{\n@@ -15065,7 +15069,7 @@ output_function_profiler (FILE *file, int labelno)\n \t  assemble_name (file, buf);\n \t  fputs (\"-.\\n1:\", file);\n \t  asm_fprintf (file, \"\\tmflr %s\\n\", reg_names[11]);\n-\t  asm_fprintf (file, \"\\t{l|lwz} %s,0(%s)\\n\", \n+\t  asm_fprintf (file, \"\\t{l|lwz} %s,0(%s)\\n\",\n \t\t       reg_names[0], reg_names[11]);\n \t  asm_fprintf (file, \"\\t{cax|add} %s,%s,%s\\n\",\n \t\t       reg_names[0], reg_names[0], reg_names[11]);\n@@ -15124,8 +15128,8 @@ output_function_profiler (FILE *file, int labelno)\n    instructions to issue in this cycle.  */\n \n static int\n-rs6000_variable_issue (FILE *stream ATTRIBUTE_UNUSED, \n-\t\t       int verbose ATTRIBUTE_UNUSED, \n+rs6000_variable_issue (FILE *stream ATTRIBUTE_UNUSED,\n+\t\t       int verbose ATTRIBUTE_UNUSED,\n \t\t       rtx insn, int more)\n {\n   if (GET_CODE (PATTERN (insn)) == USE\n@@ -15147,7 +15151,7 @@ rs6000_variable_issue (FILE *stream ATTRIBUTE_UNUSED,\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n static int\n-rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn ATTRIBUTE_UNUSED, \n+rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn ATTRIBUTE_UNUSED,\n \t\t    int cost)\n {\n   if (! recog_memoized (insn))\n@@ -15314,7 +15318,7 @@ is_branch_slot_insn (rtx insn)\n     {\n       enum attr_type type = get_attr_type (insn);\n       if (type == TYPE_BRANCH || type == TYPE_JMPREG)\n-\treturn true;\t \n+\treturn true;\n       return false;\n     }\n \n@@ -15362,22 +15366,22 @@ rs6000_adjust_priority (rtx insn ATTRIBUTE_UNUSED, int priority)\n \n   if (is_dispatch_slot_restricted (insn)\n       && reload_completed\n-      && current_sched_info->sched_max_insns_priority \n+      && current_sched_info->sched_max_insns_priority\n       && rs6000_sched_restricted_insns_priority)\n     {\n \n       /* Prioritize insns that can be dispatched only in the first dispatch slot.  */\n       if (rs6000_sched_restricted_insns_priority == 1)\n-\t/* Attach highest priority to insn. This means that in \n-\t   haifa-sched.c:ready_sort(), dispatch-slot restriction considerations \n+\t/* Attach highest priority to insn. This means that in\n+\t   haifa-sched.c:ready_sort(), dispatch-slot restriction considerations\n \t   precede 'priority' (critical path) considerations.  */\n-\treturn current_sched_info->sched_max_insns_priority; \n+\treturn current_sched_info->sched_max_insns_priority;\n       else if (rs6000_sched_restricted_insns_priority == 2)\n-\t/* Increase priority of insn by a minimal amount. This means that in \n+\t/* Increase priority of insn by a minimal amount. This means that in\n \t   haifa-sched.c:ready_sort(), only 'priority' (critical path) considerations\n \t   precede dispatch-slot restriction considerations.  */\n-\treturn (priority + 1); \n-    } \n+\treturn (priority + 1);\n+    }\n \n   return priority;\n }\n@@ -15402,7 +15406,7 @@ rs6000_issue_rate (void)\n   case CPU_PPC750:\n   case CPU_PPC7400:\n   case CPU_PPC8540:\n-    return 2; \n+    return 2;\n   case CPU_RIOS2:\n   case CPU_PPC604:\n   case CPU_PPC604E:\n@@ -15456,7 +15460,7 @@ is_mem_ref (rtx pat)\n }\n \n /* Determine if PAT is a PATTERN of a load insn.  */\n- \n+\n static bool\n is_load_insn1 (rtx pat)\n {\n@@ -15531,33 +15535,33 @@ is_store_insn (rtx insn)\n \n static bool\n rs6000_is_costly_dependence (rtx insn, rtx next, rtx link, int cost, int distance)\n-{      \n+{\n   /* If the flag is not enbled - no dependence is considered costly;\n-     allow all dependent insns in the same group. \n+     allow all dependent insns in the same group.\n      This is the most aggressive option.  */\n   if (rs6000_sched_costly_dep == no_dep_costly)\n     return false;\n \n-  /* If the flag is set to 1 - a dependence is always considered costly; \n+  /* If the flag is set to 1 - a dependence is always considered costly;\n      do not allow dependent instructions in the same group.\n      This is the most conservative option.  */\n   if (rs6000_sched_costly_dep == all_deps_costly)\n-    return true;       \n+    return true;\n \n-  if (rs6000_sched_costly_dep == store_to_load_dep_costly \n-      && is_load_insn (next) \n+  if (rs6000_sched_costly_dep == store_to_load_dep_costly\n+      && is_load_insn (next)\n       && is_store_insn (insn))\n     /* Prevent load after store in the same group.  */\n     return true;\n \n   if (rs6000_sched_costly_dep == true_store_to_load_dep_costly\n-      && is_load_insn (next) \n+      && is_load_insn (next)\n       && is_store_insn (insn)\n       && (!link || (int) REG_NOTE_KIND (link) == 0))\n      /* Prevent load after store in the same group if it is a true dependence.  */\n      return true;\n-    \n-  /* The flag is set to X; dependences with latency >= X are considered costly, \n+\n+  /* The flag is set to X; dependences with latency >= X are considered costly,\n      and will not be scheduled in the same group.  */\n   if (rs6000_sched_costly_dep <= max_dep_latency\n       && ((cost - distance) >= (int)rs6000_sched_costly_dep))\n@@ -15566,7 +15570,7 @@ rs6000_is_costly_dependence (rtx insn, rtx next, rtx link, int cost, int distanc\n   return false;\n }\n \n-/* Return the next insn after INSN that is found before TAIL is reached, \n+/* Return the next insn after INSN that is found before TAIL is reached,\n    skipping any \"non-active\" insns - insns that will not actually occupy\n    an issue slot.  Return NULL_RTX if such an insn is not found.  */\n \n@@ -15668,20 +15672,20 @@ is_costly_group (rtx *group_insns, rtx next_insn)\n   return false;\n }\n \n-/* Utility of the function redefine_groups. \n+/* Utility of the function redefine_groups.\n    Check if it is too costly to schedule NEXT_INSN together with GROUP_INSNS\n    in the same dispatch group.  If so, insert nops before NEXT_INSN, in order\n    to keep it \"far\" (in a separate group) from GROUP_INSNS, following\n    one of the following schemes, depending on the value of the flag\n    -minsert_sched_nops = X:\n    (1) X == sched_finish_regroup_exact: insert exactly as many nops as needed\n        in order to force NEXT_INSN into a separate group.\n-   (2) X < sched_finish_regroup_exact: insert exactly X nops.  \n-   GROUP_END, CAN_ISSUE_MORE and GROUP_COUNT record the state after nop \n+   (2) X < sched_finish_regroup_exact: insert exactly X nops.\n+   GROUP_END, CAN_ISSUE_MORE and GROUP_COUNT record the state after nop\n    insertion (has a group just ended, how many vacant issue slots remain in the\n    last group, and how many dispatch groups were encountered so far).  */\n \n-static int \n+static int\n force_new_group (int sched_verbose, FILE *dump, rtx *group_insns, rtx next_insn,\n \t\t bool *group_end, int can_issue_more, int *group_count)\n {\n@@ -15727,13 +15731,13 @@ force_new_group (int sched_verbose, FILE *dump, rtx *group_insns, rtx next_insn,\n \n       *group_end = true;\n       return 0;\n-    } \n+    }\n \n   if (rs6000_sched_insert_nops < sched_finish_regroup_exact)\n     {\n       int n_nops = rs6000_sched_insert_nops;\n \n-      /* Nops can't be issued from the branch slot, so the effective \n+      /* Nops can't be issued from the branch slot, so the effective\n          issue_rate for nops is 'issue_rate - 1'.  */\n       if (can_issue_more == 0)\n         can_issue_more = issue_rate;\n@@ -15764,16 +15768,16 @@ force_new_group (int sched_verbose, FILE *dump, rtx *group_insns, rtx next_insn,\n               for (i = 0; i < issue_rate; i++)\n                 {\n                   group_insns[i] = 0;\n-                } \n-            }\t\n+                }\n+            }\n           n_nops--;\n         }\n \n       /* Scale back relative to 'issue_rate' (instead of 'issue_rate - 1').  */\n-      can_issue_more++; \n+      can_issue_more++;\n \n       *group_end = /* Is next_insn going to start a new group?  */\n-\t  (end \n+\t  (end\n \t   || (can_issue_more == 1 && !is_branch_slot_insn (next_insn))\n \t   || (can_issue_more <= 2 && is_cracked_insn (next_insn))\n \t   || (can_issue_more < issue_rate &&\n@@ -15784,14 +15788,14 @@ force_new_group (int sched_verbose, FILE *dump, rtx *group_insns, rtx next_insn,\n       if (sched_verbose > 6)\n         fprintf (dump, \"done force: group count = %d, can_issue_more = %d\\n\",\n \t\t\t*group_count, can_issue_more);\n-      return can_issue_more;\t\n-    } \n+      return can_issue_more;\n+    }\n \n   return can_issue_more;\n }\n \n /* This function tries to synch the dispatch groups that the compiler \"sees\"\n-   with the dispatch groups that the processor dispatcher is expected to \n+   with the dispatch groups that the processor dispatcher is expected to\n    form in practice.  It tries to achieve this synchronization by forcing the\n    estimated processor grouping on the compiler (as opposed to the function\n    'pad_goups' which tries to force the scheduler's grouping on the processor).\n@@ -15815,7 +15819,7 @@ force_new_group (int sched_verbose, FILE *dump, rtx *group_insns, rtx next_insn,\n    - only the last 2 or less issue slots, including the branch slot, are vacant,\n      which means that a cracked insn (which occupies two issue slots) can't be\n      issued in this group.\n-   - less than 'issue_rate' slots are vacant, and the next insn always needs to \n+   - less than 'issue_rate' slots are vacant, and the next insn always needs to\n      start a new group.  */\n \n static int\n@@ -15832,7 +15836,7 @@ redefine_groups (FILE *dump, int sched_verbose, rtx prev_head_insn, rtx tail)\n   /* Initialize.  */\n   issue_rate = rs6000_issue_rate ();\n   group_insns = alloca (issue_rate * sizeof (rtx));\n-  for (i = 0; i < issue_rate; i++) \n+  for (i = 0; i < issue_rate; i++)\n     {\n       group_insns[i] = 0;\n     }\n@@ -15861,7 +15865,7 @@ redefine_groups (FILE *dump, int sched_verbose, rtx prev_head_insn, rtx tail)\n          || (can_issue_more < issue_rate &&\n              insn_terminates_group_p (next_insn, previous_group)));\n \n-      can_issue_more = force_new_group (sched_verbose, dump, group_insns, \n+      can_issue_more = force_new_group (sched_verbose, dump, group_insns,\n \t\t\tnext_insn, &group_end, can_issue_more, &group_count);\n \n       if (group_end)\n@@ -16075,7 +16079,7 @@ const struct attribute_spec rs6000_attribute_table[] =\n \n /* Handle the \"altivec\" attribute.  The attribute may have\n    arguments as follows:\n-   \n+\n \t__attribute__((altivec(vector__)))\n \t__attribute__((altivec(pixel__)))\t(always followed by 'unsigned short')\n \t__attribute__((altivec(bool__)))\t(always followed by 'unsigned')\n@@ -16095,7 +16099,7 @@ rs6000_handle_altivec_attribute (tree *node, tree name, tree args,\n     = ((args && TREE_CODE (args) == TREE_LIST && TREE_VALUE (args)\n \t&& TREE_CODE (TREE_VALUE (args)) == IDENTIFIER_NODE)\n        ? *IDENTIFIER_POINTER (TREE_VALUE (args))\n-       : '?'); \n+       : '?');\n \n   while (POINTER_TYPE_P (type)\n \t || TREE_CODE (type) == FUNCTION_TYPE\n@@ -16182,9 +16186,9 @@ rs6000_mangle_fundamental_type (tree type)\n    struct attribute_spec.handler.  */\n \n static tree\n-rs6000_handle_longcall_attribute (tree *node, tree name, \n-\t\t\t\t  tree args ATTRIBUTE_UNUSED, \n-\t\t\t\t  int flags ATTRIBUTE_UNUSED, \n+rs6000_handle_longcall_attribute (tree *node, tree name,\n+\t\t\t\t  tree args ATTRIBUTE_UNUSED,\n+\t\t\t\t  int flags ATTRIBUTE_UNUSED,\n \t\t\t\t  bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_TYPE\n@@ -16250,7 +16254,7 @@ rs6000_longcall_ref (rtx call_ref)\n    data section.  */\n \n static void\n-rs6000_elf_select_rtx_section (enum machine_mode mode, rtx x, \n+rs6000_elf_select_rtx_section (enum machine_mode mode, rtx x,\n \t\t\t       unsigned HOST_WIDE_INT align)\n {\n   if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x, mode))\n@@ -16265,7 +16269,7 @@ rs6000_elf_select_rtx_section (enum machine_mode mode, rtx x,\n    the initial value of DECL requires link-time relocations.  */\n \n static void\n-rs6000_elf_select_section (tree decl, int reloc, \n+rs6000_elf_select_section (tree decl, int reloc,\n \t\t\t   unsigned HOST_WIDE_INT align)\n {\n   /* Pretend that we're always building for a shared library when\n@@ -16424,7 +16428,7 @@ static tree branch_island_list = 0;\n /* Remember to generate a branch island for far calls to the given\n    function.  */\n \n-static void \n+static void\n add_compiler_branch_island (tree label_name, tree function_name, int line_number)\n {\n   tree branch_island = build_tree_list (function_name, label_name);\n@@ -16481,21 +16485,21 @@ macho_branch_islands (void)\n \t  strcat (tmp_buf, \"_pic\\n\");\n \t  strcat (tmp_buf, label);\n \t  strcat (tmp_buf, \"_pic:\\n\\tmflr r11\\n\");\n- \n+\n \t  strcat (tmp_buf, \"\\taddis r11,r11,ha16(\");\n \t  strcat (tmp_buf, name_buf);\n \t  strcat (tmp_buf, \" - \");\n \t  strcat (tmp_buf, label);\n \t  strcat (tmp_buf, \"_pic)\\n\");\n- \t\t   \n+\n \t  strcat (tmp_buf, \"\\tmtlr r0\\n\");\n-  \n+\n \t  strcat (tmp_buf, \"\\taddi r12,r11,lo16(\");\n \t  strcat (tmp_buf, name_buf);\n \t  strcat (tmp_buf, \" - \");\n \t  strcat (tmp_buf, label);\n \t  strcat (tmp_buf, \"_pic)\\n\");\n- \n+\n \t  strcat (tmp_buf, \"\\tmtctr r12\\n\\tbctr\\n\");\n \t}\n       else\n@@ -16548,7 +16552,7 @@ get_prev_label (tree function_name)\n }\n \n /* INSN is either a function call or a millicode call.  It may have an\n-   unconditional jump in its delay slot.  \n+   unconditional jump in its delay slot.\n \n    CALL_DEST is the routine we are calling.  */\n \n@@ -16561,7 +16565,7 @@ output_call (rtx insn, rtx *operands, int dest_operand_number, int cookie_operan\n     {\n       tree labelname;\n       tree funname = get_identifier (XSTR (operands[dest_operand_number], 0));\n-      \n+\n       if (no_previous_def (funname))\n \t{\n \t  int line_number = 0;\n@@ -16630,7 +16634,7 @@ machopic_output_stub (FILE *file, const char *symb, const char *stub)\n       label++;\n       local_label_0 = alloca (sizeof(\"\\\"L0000000000$spb\\\"\"));\n       sprintf (local_label_0, \"\\\"L%011d$spb\\\"\", label);\n-    \n+\n       fprintf (file, \"\\tmflr r0\\n\");\n       fprintf (file, \"\\tbcl 20,31,%s\\n\", local_label_0);\n       fprintf (file, \"%s:\\n\\tmflr r11\\n\", local_label_0);\n@@ -16654,7 +16658,7 @@ machopic_output_stub (FILE *file, const char *symb, const char *stub)\n       fprintf (file, \"\\tmtctr r12\\n\");\n       fprintf (file, \"\\tbctr\\n\");\n     }\n-  \n+\n   machopic_lazy_symbol_ptr_section ();\n   fprintf (file, \"%s:\\n\", lazy_ptr_name);\n   fprintf (file, \"\\t.indirect_symbol %s\\n\", symbol_name);\n@@ -16670,7 +16674,7 @@ machopic_output_stub (FILE *file, const char *symb, const char *stub)\n #define SMALL_INT(X) ((unsigned) (INTVAL(X) + 0x8000) < 0x10000)\n \n rtx\n-rs6000_machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, \n+rs6000_machopic_legitimize_pic_address (rtx orig, enum machine_mode mode,\n \t\t\t\t\trtx reg)\n {\n   rtx base, offset;\n@@ -16908,7 +16912,7 @@ rs6000_xcoff_asm_named_section (const char *name, unsigned int flags)\n }\n \n static void\n-rs6000_xcoff_select_section (tree decl, int reloc, \n+rs6000_xcoff_select_section (tree decl, int reloc,\n \t\t\t    unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   if (decl_readonly_section_1 (decl, reloc, 1))\n@@ -16953,7 +16957,7 @@ rs6000_xcoff_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n    toc entry.  */\n \n static void\n-rs6000_xcoff_select_rtx_section (enum machine_mode mode, rtx x, \n+rs6000_xcoff_select_rtx_section (enum machine_mode mode, rtx x,\n \t\t\t\tunsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x, mode))\n@@ -17062,7 +17066,7 @@ rs6000_binds_local_p (tree decl)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, \n+rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n \t\t  int *total)\n {\n   enum machine_mode mode = GET_MODE (x);\n@@ -17382,7 +17386,7 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n    CLASS1 to one of CLASS2.  */\n \n int\n-rs6000_register_move_cost (enum machine_mode mode, \n+rs6000_register_move_cost (enum machine_mode mode,\n \t\t\t   enum reg_class from, enum reg_class to)\n {\n   /*  Moves from/to GENERAL_REGS.  */\n@@ -17411,15 +17415,15 @@ rs6000_register_move_cost (enum machine_mode mode,\n \n /* Everything else has to go through GENERAL_REGS.  */\n   else\n-    return (rs6000_register_move_cost (mode, GENERAL_REGS, to) \n+    return (rs6000_register_move_cost (mode, GENERAL_REGS, to)\n \t    + rs6000_register_move_cost (mode, from, GENERAL_REGS));\n }\n \n /* A C expressions returning the cost of moving data of MODE from a register to\n    or from memory.  */\n \n int\n-rs6000_memory_move_cost (enum machine_mode mode, enum reg_class class, \n+rs6000_memory_move_cost (enum machine_mode mode, enum reg_class class,\n \t\t\t int in ATTRIBUTE_UNUSED)\n {\n   if (reg_classes_intersect_p (class, GENERAL_REGS))\n@@ -17629,10 +17633,25 @@ rs6000_dbx_register_number (unsigned int regno)\n }\n \n /* target hook eh_return_filter_mode */\n-static enum machine_mode \n+static enum machine_mode\n rs6000_eh_return_filter_mode (void)\n {\n   return TARGET_32BIT ? SImode : word_mode;\n }\n \n+/* Target hook for vector_mode_supported_p.  */\n+static bool\n+rs6000_vector_mode_supported_p (enum machine_mode mode)\n+{\n+\n+  if (TARGET_SPE && SPE_VECTOR_MODE (mode))\n+    return true;\n+\n+  else if (TARGET_ALTIVEC && ALTIVEC_VECTOR_MODE (mode))\n+    return true;\n+\n+  else\n+    return false;\n+}\n+\n #include \"gt-rs6000.h\""}, {"sha": "182b5f1d66ffb7b07b275a1d3d7eaff1caedcaff", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -550,7 +550,7 @@ extern const char *rs6000_warn_altivec_long_switch;\n    Override the macro definitions when compiling libobjc to avoid undefined\n    reference to rs6000_alignment_flags due to library's use of GCC alignment\n    macros which use the macros below.  */\n-   \n+\n #ifndef IN_TARGET_LIBS\n #define MASK_ALIGN_POWER   0x00000000\n #define MASK_ALIGN_NATURAL 0x00000001\n@@ -835,7 +835,7 @@ extern const char *rs6000_warn_altivec_long_switch;\n    avoid invalidating older SPE eh_frame info.\n \n    We must map them here to avoid huge unwinder tables mostly consisting\n-   of unused space.  */ \n+   of unused space.  */\n #define DWARF_REG_TO_UNWIND_COLUMN(r) \\\n   ((r) > 1200 ? ((r) - 1200 + FIRST_PSEUDO_REGISTER) : (r))\n \n@@ -890,7 +890,7 @@ extern const char *rs6000_warn_altivec_long_switch;\n    (`CALL_USED_REGISTERS' must be a superset of `FIXED_REGISTERS').\n    This macro is optional.  If not specified, it defaults to the value\n    of `CALL_USED_REGISTERS'.  */\n-\t\t       \n+\n #define CALL_REALLY_USED_REGISTERS  \\\n   {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, FIXED_R13, 0, 0, \\\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n@@ -955,7 +955,7 @@ extern const char *rs6000_warn_altivec_long_switch;\n \tv19 - v14       (not saved or used for anything)\n \tv31 - v20       (saved; order given to save least number)\n */\n-\t\t\t\t\t\t\n+\n #if FIXED_R2 == 1\n #define MAYBE_R2_AVAILABLE\n #define MAYBE_R2_FIXED 2,\n@@ -1031,14 +1031,6 @@ extern const char *rs6000_warn_altivec_long_switch;\n          || (MODE) == V1DImode          \\\n          || (MODE) == V2SImode)\n \n-/* Define this macro to be nonzero if the port is prepared to handle\n-   insns involving vector mode MODE.  At the very least, it must have\n-   move patterns for this mode.  */\n-\n-#define VECTOR_MODE_SUPPORTED_P(MODE)\t\t\t\\\n-        ((TARGET_SPE && SPE_VECTOR_MODE (MODE))\t\t\\\n-\t || (TARGET_ALTIVEC && ALTIVEC_VECTOR_MODE (MODE)))\n-\n #define UNITS_PER_SIMD_WORD     \\\n         (TARGET_ALTIVEC ? 16 : (TARGET_SPE ? 8 : 0) )\n \n@@ -1352,7 +1344,7 @@ enum reg_class\n    'T' is a constant that can be placed into a 32-bit mask operand\n    'U' is for V.4 small data references.\n    'W' is a vector constant that can be easily generated (no mem refs).\n-   'Y' is a indexed or word-aligned displacement memory operand. \n+   'Y' is a indexed or word-aligned displacement memory operand.\n    't' is for AND masks that can be performed by two rldic{l,r} insns.  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n@@ -1371,7 +1363,7 @@ enum reg_class\n    : 0)\n \n /* Define which constraints are memory constraints.  Tell reload\n-   that any memory address can be reloaded by copying the \n+   that any memory address can be reloaded by copying the\n    memory address into a base register if required.  */\n \n #define EXTRA_MEMORY_CONSTRAINT(C, STR)\t\t\t\t\\\n@@ -1383,7 +1375,7 @@ enum reg_class\n    in some cases it is preferable to use a more restrictive class.\n \n    On the RS/6000, we have to return NO_REGS when we want to reload a\n-   floating-point CONST_DOUBLE to force it to be copied to memory.  \n+   floating-point CONST_DOUBLE to force it to be copied to memory.\n \n    We also don't want to reload integer values into floating-point\n    registers if we can at all help it.  In fact, this can\n@@ -2024,9 +2016,9 @@ typedef struct rs6000_args\n    operand.  If we find one, push the reload and jump to WIN.  This\n    macro is used in only one place: `find_reloads_address' in reload.c.\n \n-   Implemented on rs6000 by rs6000_legitimize_reload_address.  \n+   Implemented on rs6000 by rs6000_legitimize_reload_address.\n    Note that (X) is evaluated twice; this is safe in current usage.  */\n-   \n+\n #define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t     \\\n do {\t\t\t\t\t\t\t\t\t     \\\n   int win;\t\t\t\t\t\t\t\t     \\"}, {"sha": "a3a19f64d609ee2715aa0d1dfd96733d0d7f51c9", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -101,6 +101,7 @@ extern int sh_can_redirect_branch (rtx, rtx);\n extern void sh_expand_unop_v2sf (enum rtx_code, rtx, rtx);\n extern void sh_expand_binop_v2sf (enum rtx_code, rtx, rtx, rtx);\n extern int sh_expand_t_scc (enum rtx_code code, rtx target);\n+extern bool sh_vector_mode_supported_p (enum machine_mode);\n #ifdef TREE_CODE\n extern void sh_va_start (tree, rtx);\n #endif /* TREE_CODE */"}, {"sha": "1c539e880a3c3e27e76f7b6ce798fe09a273127d", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 115, "deletions": 92, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -2,7 +2,7 @@\n    Copyright (C) 1993, 1994, 1995, 1997, 1997, 1998, 1999, 2000, 2001, 2002,\n    2003, 2004 Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n-   Improved by Jim Wilson (wilson@cygnus.com). \n+   Improved by Jim Wilson (wilson@cygnus.com).\n \n This file is part of GCC.\n \n@@ -242,7 +242,7 @@ static int sh_reorder (FILE *, int, rtx *, int *, int);\n static int sh_reorder2 (FILE *, int, rtx *, int *, int);\n static void sh_md_init (FILE *, int, int);\n static int sh_variable_issue (FILE *, int, rtx, int);\n-  \n+\n static bool sh_function_ok_for_sibcall (tree, tree);\n \n static bool sh_cannot_modify_jumps_p (void);\n@@ -326,11 +326,11 @@ static bool sh_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \n /* The next 5 hooks have been implemented for reenabling sched1.  With the\n    help of these macros we are limiting the movement of insns in sched1 to\n-   reduce the register pressure.  The overall idea is to keep count of SImode \n+   reduce the register pressure.  The overall idea is to keep count of SImode\n    and SFmode regs required by already scheduled insns. When these counts\n    cross some threshold values; give priority to insns that free registers.\n    The insn that frees registers is most likely to be the insn with lowest\n-   LUID (original insn order); but such an insn might be there in the stalled \n+   LUID (original insn order); but such an insn might be there in the stalled\n    queue (Q) instead of the ready queue (R).  To solve this, we skip cycles\n    upto a max of 8 cycles so that such insns may move from Q -> R.\n \n@@ -340,7 +340,7 @@ static bool sh_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n    scheduler; it is called inside the sched_init function just after\n    find_insn_reg_weights function call. It is used to calculate the SImode\n    and SFmode weights of insns of basic blocks; much similar to what\n-   find_insn_reg_weights does. \n+   find_insn_reg_weights does.\n    TARGET_SCHED_FINISH_GLOBAL: Corresponding cleanup hook.\n \n    TARGET_SCHED_DFA_NEW_CYCLE: Skip cycles if high register pressure is\n@@ -444,6 +444,9 @@ static bool sh_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR sh_gimplify_va_arg_expr\n \n+#undef TARGET_VECTOR_MODE_SUPPORTED_P\n+#define TARGET_VECTOR_MODE_SUPPORTED_P sh_vector_mode_supported_p\n+\n #undef TARGET_PCH_VALID_P\n #define TARGET_PCH_VALID_P sh_pch_valid_p\n \n@@ -658,7 +661,7 @@ print_operand (FILE *stream, rtx x, int code)\n \n       fprintf ((stream), \"d%s\", reg_names[REGNO (x)] + 1);\n       break;\n-      \n+\n     case 'N':\n       if (x == CONST0_RTX (GET_MODE (x)))\n \t{\n@@ -711,7 +714,7 @@ print_operand (FILE *stream, rtx x, int code)\n \tcase MEM:\n \t  output_address (XEXP (x, 0));\n \t  break;\n-\t  \n+\n \tcase CONST:\n \t  if (TARGET_SHMEDIA\n \t      && GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n@@ -1003,7 +1006,7 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n \t{\n \t  rtx tga_op1, tga_ret, tmp, tmp2;\n \n-\t  \n+\n \t  switch (tls_kind)\n \t    {\n \t    case TLS_MODEL_GLOBAL_DYNAMIC:\n@@ -1370,11 +1373,11 @@ output_branch (int logic, rtx insn, rtx *operands)\n \t  int label = lf++;\n \t  /* The call to print_slot will clobber the operands.  */\n \t  rtx op0 = operands[0];\n-    \n+\n \t  /* If the instruction in the delay slot is annulled (true), then\n \t     there is no delay slot where we can put it now.  The only safe\n \t     place for it is after the label.  final will do that by default.  */\n-    \n+\n \t  if (final_sequence\n \t      && ! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0)))\n \t    {\n@@ -1384,11 +1387,11 @@ output_branch (int logic, rtx insn, rtx *operands)\n \t    }\n \t  else\n \t    asm_fprintf (asm_out_file, \"\\tb%s\\t%LLF%d\\n\", logic ? \"f\" : \"t\", label);\n-    \n+\n \t  output_asm_insn (\"bra\\t%l0\", &op0);\n \t  fprintf (asm_out_file, \"\\tnop\\n\");\n \t  (*targetm.asm_out.internal_label) (asm_out_file, \"LF\", label);\n-    \n+\n \t  return \"\";\n \t}\n       /* When relaxing, handle this like a short branch.  The linker\n@@ -1420,7 +1423,7 @@ output_branch (int logic, rtx insn, rtx *operands)\n     case 4:\n       {\n \tchar buffer[10];\n-\t\n+\n \tsprintf (buffer, \"b%s%ss\\t%%l0\",\n \t\t logic ? \"t\" : \"f\",\n \t\t ASSEMBLER_DIALECT ? \"/\" : \".\");\n@@ -1495,7 +1498,7 @@ sh_file_start (void)\n   fputs (\"\\t.section .directive, \\\"SM\\\", @progbits, 1\\n\", asm_out_file);\n   fputs (\"\\t.asciz \\\"#<SYMEDIT>#\\\\n\\\"\\n\", asm_out_file);\n #endif\n-  \n+\n   if (TARGET_ELF)\n     /* We need to show the text section with the proper\n        attributes as in TEXT_SECTION_ASM_OP, before dwarf2out\n@@ -1599,7 +1602,7 @@ static const short shift_amounts[32][5] = {\n /* Likewise, but for shift amounts < 16, up to three highmost bits\n    might be clobbered.  This is typically used when combined with some\n    kind of sign or zero extension.  */\n-   \n+\n static const char ext_shift_insns[]    =\n   { 0,1,1,2,2,3,2,2,1,2,2,3,3,3,2,2,1,2,2,3,3,4,3,3,2,3,3,4,4,4,3,3};\n \n@@ -1963,7 +1966,7 @@ gen_ashift_hi (int type, int n, rtx reg)\n \n /* Output RTL to split a constant shift into its component SH constant\n    shift instructions.  */\n-   \n+\n void\n gen_shifty_op (int code, rtx *operands)\n {\n@@ -1972,7 +1975,7 @@ gen_shifty_op (int code, rtx *operands)\n \n   /* Truncate the shift count in case it is out of bounds.  */\n   value = value & 0x1f;\n- \n+\n   if (value == 31)\n     {\n       if (code == LSHIFTRT)\n@@ -2006,7 +2009,7 @@ gen_shifty_op (int code, rtx *operands)\n   for (i = 0; i < max; i++)\n     gen_ashift (code, shift_amounts[value][i], operands[0]);\n }\n-   \n+\n /* Same as above, but optimized for values where the topmost bits don't\n    matter.  */\n \n@@ -2359,7 +2362,7 @@ gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n \t  || reload_in_progress || reload_completed)\n \t{\n \t  rtx operands[3];\n-  \n+\n \t  /* Cases 3 and 4 should be handled by this split\n \t     only while combining  */\n \t  if (kind > 2)\n@@ -2658,7 +2661,7 @@ gen_datalabel_ref (rtx sym)\n \t\t\t  gen_rtx_UNSPEC (GET_MODE (sym),\n \t\t\t\t\t  gen_rtvec (1, sym),\n \t\t\t\t\t  UNSPEC_DATALABEL));\n-    \n+\n   if (GET_CODE (sym) != SYMBOL_REF)\n     abort ();\n \n@@ -2955,7 +2958,7 @@ dump_table (rtx start, rtx barrier)\n \n       pool_size = 0;\n     }\n-  \n+\n   for (i = 0; i < pool_size; i++)\n     {\n       pool_node *p = &pool_vector[i];\n@@ -3513,7 +3516,7 @@ regs_used (rtx x, int is_dest)\n     case SUBREG:\n       {\n \trtx y = SUBREG_REG (x);\n-     \n+\n \tif (GET_CODE (y) != REG)\n \t  break;\n \tif (REGNO (y) < 16)\n@@ -3568,7 +3571,7 @@ regs_used (rtx x, int is_dest)\n    pass 1.  Pass 2 if a definite blocking insn is needed.\n    -1 is used internally to avoid deep recursion.\n    If a blocking instruction is made or recognized, return it.  */\n-   \n+\n static rtx\n gen_block_redirect (rtx jump, int addr, int need_block)\n {\n@@ -3611,11 +3614,11 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n \t it would cause trouble if an interrupt occurred.  */\n       unsigned try = 0x7fff, used;\n       int jump_left = flag_expensive_optimizations + 1;\n-    \n+\n       /* It is likely that the most recent eligible instruction is wanted for\n \t the delay slot.  Therefore, find out which registers it uses, and\n \t try to avoid using them.  */\n-\t \n+\n       for (scan = jump; (scan = PREV_INSN (scan)); )\n \t{\n \t  enum rtx_code code;\n@@ -3670,7 +3673,7 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n      threading with a jump beyond the delay slot insn.\n      Don't check if we are called recursively; the jump has been or will be\n      checked in a different invocation then.  */\n-\t\n+\n   else if (optimize && need_block >= 0)\n     {\n       rtx next = next_active_insn (next_active_insn (dest));\n@@ -3705,7 +3708,7 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n \t Hence, after delay slot scheduling, we'll have to expect\n \t NOTE_INSN_BLOCK_END notes between the indirect_jump_scratch and\n \t the jump.  */\n-\t \n+\n       INSN_LOCATOR (insn) = INSN_LOCATOR (jump);\n       INSN_CODE (insn) = CODE_FOR_indirect_jump_scratch;\n       return insn;\n@@ -3833,7 +3836,7 @@ barrier_align (rtx barrier_or_label)\n {\n   rtx next = next_real_insn (barrier_or_label), pat, prev;\n   int slot, credit, jump_to_next = 0;\n- \n+\n   if (! next)\n     return 0;\n \n@@ -3875,11 +3878,11 @@ barrier_align (rtx barrier_or_label)\n \t an alignment, against that of fetching unneeded insn in front of the\n \t branch target when there is no alignment.  */\n \n-      /* There are two delay_slot cases to consider.  One is the simple case \n-\t where the preceding branch is to the insn beyond the barrier (simple \n-\t delay slot filling), and the other is where the preceding branch has \n-\t a delay slot that is a duplicate of the insn after the barrier \n-\t (fill_eager_delay_slots) and the branch is to the insn after the insn \n+      /* There are two delay_slot cases to consider.  One is the simple case\n+\t where the preceding branch is to the insn beyond the barrier (simple\n+\t delay slot filling), and the other is where the preceding branch has\n+\t a delay slot that is a duplicate of the insn after the barrier\n+\t (fill_eager_delay_slots) and the branch is to the insn after the insn\n \t after the barrier.  */\n \n       /* PREV is presumed to be the JUMP_INSN for the barrier under\n@@ -3897,7 +3900,7 @@ barrier_align (rtx barrier_or_label)\n \t  if (GET_CODE (PATTERN (prev)) == SEQUENCE)\n \t    {\n \t      prev = XVECEXP (PATTERN (prev), 0, 1);\n-\t      if (INSN_UID (prev) == INSN_UID (next)) \n+\t      if (INSN_UID (prev) == INSN_UID (next))\n \t\t{\n \t  \t  /* Delay slot was filled with insn at jump target.  */\n \t\t  jump_to_next = 1;\n@@ -3924,8 +3927,8 @@ barrier_align (rtx barrier_or_label)\n \t      /* There is no upper bound on redundant instructions\n \t\t that might have been skipped, but we must not put an\n \t\t alignment where none had been before.  */\n-\t      || (x = (NEXT_INSN (NEXT_INSN (PREV_INSN (prev)))),\t    \n-\t\t  (INSN_P (x) \n+\t      || (x = (NEXT_INSN (NEXT_INSN (PREV_INSN (prev)))),\n+\t\t  (INSN_P (x)\n \t\t   && (INSN_CODE (x) == CODE_FOR_block_branch_redirect\n \t\t       || INSN_CODE (x) == CODE_FOR_indirect_jump_scratch\n \t\t       || INSN_CODE (x) == CODE_FOR_stuff_delay_slot))))\n@@ -3938,7 +3941,7 @@ barrier_align (rtx barrier_or_label)\n \t    }\n \t}\n     }\n-  \n+\n   return align_jumps_log;\n }\n \n@@ -4501,7 +4504,7 @@ split_branches (rtx first)\n \tif (type == TYPE_CBRANCH)\n \t  {\n \t    rtx next, beyond;\n-    \n+\n \t    if (get_attr_length (insn) > 4)\n \t      {\n \t\trtx src = SET_SRC (PATTERN (insn));\n@@ -4510,7 +4513,7 @@ split_branches (rtx first)\n \t\trtx label = 0;\n \t\tint dest_uid = get_dest_uid (olabel, max_uid);\n \t\tstruct far_branch *bp = uid_branch[dest_uid];\n-    \n+\n \t\t/* redirect_jump needs a valid JUMP_LABEL, and it might delete\n \t\t   the label if the LABEL_NUSES count drops to zero.  There is\n \t\t   always a jump_optimize pass that sets these values, but it\n@@ -4578,7 +4581,7 @@ split_branches (rtx first)\n \t\tbeyond\n \t\t  = next_active_insn (XEXP (XEXP (SET_SRC (PATTERN (insn)), 1),\n \t\t\t\t\t    0));\n-\t\n+\n \t\tif (beyond\n \t\t    && (GET_CODE (beyond) == JUMP_INSN\n \t\t\t|| ((beyond = next_active_insn (beyond))\n@@ -4592,7 +4595,7 @@ split_branches (rtx first)\n \t\t  gen_block_redirect (beyond,\n \t\t\t\t      INSN_ADDRESSES (INSN_UID (beyond)), 1);\n \t      }\n-    \n+\n \t    next = next_active_insn (insn);\n \n \t    if ((GET_CODE (next) == JUMP_INSN\n@@ -4995,7 +4998,7 @@ pop (int rn)\n     x = gen_pop_e (gen_rtx_REG (SFmode, rn));\n   else\n     x = gen_pop (gen_rtx_REG (SImode, rn));\n-    \n+\n   x = emit_insn (x);\n   REG_NOTES (x)\n     = gen_rtx_EXPR_LIST (REG_INC,\n@@ -5056,7 +5059,7 @@ shmedia_target_regs_stack_space (HARD_REG_SET *live_regs_mask)\n       stack_space += GET_MODE_SIZE (REGISTER_NATURAL_MODE (reg));\n   return stack_space;\n }\n-   \n+\n /* Decide whether we should reserve space for callee-save target registers,\n    in case target register allocation wants to use them.  REGS_SAVED is\n    the space, in bytes, that is already required for register saves.\n@@ -5298,7 +5301,7 @@ typedef struct save_schedule_s\n    use reverse order.  Returns the last entry written to (not counting\n    the delimiter).  OFFSET_BASE is a number to be added to all offset\n    entries.  */\n-   \n+\n static save_entry *\n sh5_schedule_saves (HARD_REG_SET *live_regs_mask, save_schedule *schedule,\n \t\t    int offset_base)\n@@ -5478,7 +5481,7 @@ sh_expand_prologue (void)\n \t      int rn = NPARM_REGS(SImode) + FIRST_PARM_REG - i - 1;\n \t      rtx insn;\n \n-\t      if (i >= (NPARM_REGS(SImode) \n+\t      if (i >= (NPARM_REGS(SImode)\n \t\t\t- current_function_args_info.arg_count[(int) SH_ARG_INT]\n \t\t\t))\n \t\tbreak;\n@@ -5497,7 +5500,7 @@ sh_expand_prologue (void)\n      that already happens to be at the function start into the prologue.  */\n   if (target_flags != save_flags && ! current_function_interrupt)\n     emit_insn (gen_toggle_sz ());\n-    \n+\n   if (TARGET_SH5)\n     {\n       int offset_base, offset;\n@@ -5605,7 +5608,7 @@ sh_expand_prologue (void)\n \t\t\t       GEN_INT (offset - offset_in_r0)));\n \t      offset_in_r0 += offset - offset_in_r0;\n \t    }\n-\t\t\t\t\t      \n+\n \t  if (pre_dec != NULL_RTX)\n \t    {\n \t      if (! sp_in_r0)\n@@ -5667,7 +5670,7 @@ sh_expand_prologue (void)\n \t    insn = emit_move_insn (mem_rtx, reg_rtx);\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n \n-\t    if (TARGET_SHCOMPACT && (offset_in_r0 != -1)) \n+\t    if (TARGET_SHCOMPACT && (offset_in_r0 != -1))\n \t      {\n \t\trtx reg_rtx = gen_rtx_REG (mode, reg);\n \t\trtx set, note_rtx;\n@@ -5880,12 +5883,12 @@ sh_expand_epilogue (bool sibcall_p)\n \t\tpost_inc = NULL_RTX;\n \n \t\tbreak;\n-\t\t\n+\n \t      post_inc_ok:\n \t\tmem_rtx = NULL_RTX;\n \t      }\n \t  while (0);\n-\t  \n+\n \t  if (mem_rtx != NULL_RTX)\n \t    goto addr_ok;\n \n@@ -5902,7 +5905,7 @@ sh_expand_epilogue (bool sibcall_p)\n \t\t\t       GEN_INT (offset - offset_in_r0)));\n \t      offset_in_r0 += offset - offset_in_r0;\n \t    }\n-\t      \n+\n \t  if (post_inc != NULL_RTX)\n \t    {\n \t      if (! sp_in_r0)\n@@ -5912,7 +5915,7 @@ sh_expand_epilogue (bool sibcall_p)\n \t\t\t\t  (Pmode, r0, stack_pointer_rtx));\n \t\t  sp_in_r0 = 1;\n \t\t}\n-\t      \n+\n \t      mem_rtx = post_inc;\n \n \t      offset_in_r0 += GET_MODE_SIZE (mode);\n@@ -5967,7 +5970,7 @@ sh_expand_epilogue (bool sibcall_p)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t{\n \t  int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n-  \n+\n \t  if (j == FPSCR_REG && current_function_interrupt && TARGET_FMOVD\n \t      && hard_regs_intersect_p (&live_regs_mask,\n \t\t\t\t\t&reg_class_contents[DF_REGS]))\n@@ -6064,7 +6067,7 @@ sh_set_return_address (rtx ra, rtx tmp)\n       int offset;\n       save_schedule schedule;\n       save_entry *entry;\n-      \n+\n       entry = sh5_schedule_saves (&live_regs_mask, &schedule, 0);\n       offset = entry[1].offset;\n       for (; entry->mode != VOIDmode; entry--)\n@@ -6146,7 +6149,7 @@ sh_builtin_saveregs (void)\n       if (TARGET_SHCOMPACT)\n \treturn const0_rtx;\n     }\n-  \n+\n   if (! TARGET_SH2E && ! TARGET_SH4 && ! TARGET_SH5)\n     {\n       error (\"__builtin_saveregs not supported by this subtarget\");\n@@ -6212,7 +6215,7 @@ sh_builtin_saveregs (void)\n \t\t\t\t GEN_INT (-2 * UNITS_PER_WORD)));\n \t  mem = gen_rtx_MEM (DFmode, fpregs);\n \t  set_mem_alias_set (mem, alias_set);\n-\t  emit_move_insn (mem, \n+\t  emit_move_insn (mem,\n \t\t\t  gen_rtx_REG (DFmode, BASE_ARG_REG (DFmode) + regno));\n \t}\n       regno = first_floatreg;\n@@ -6668,7 +6671,7 @@ sh_function_arg (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n       return gen_rtx_REG (mode, regno);\n \n     }\n-  \n+\n   if (TARGET_SH5)\n     {\n       if (mode == VOIDmode && TARGET_SHCOMPACT)\n@@ -6706,7 +6709,7 @@ sh_function_arg (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n \n   return 0;\n }\n- \n+\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be\n@@ -6983,7 +6986,7 @@ initial_elimination_offset (int from, int to)\n \t  int pr_reg = TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG;\n \t  save_schedule schedule;\n \t  save_entry *entry;\n-\t  \n+\n \t  n += total_auto_space;\n \n \t  /* If it wasn't saved, there's not much we can do.  */\n@@ -7074,7 +7077,7 @@ const struct attribute_spec sh_attribute_table[] =\n   /* Symbian support adds three new attributes:\n      dllexport - for exporting a function/variable that will live in a dll\n      dllimport - for importing a function/variable from a dll\n-     \n+\n      Microsoft allows multiple declspecs in one __declspec, separating\n      them with spaces.  We do NOT support this.  Instead, use __declspec\n      multiple times.  */\n@@ -7237,7 +7240,7 @@ sh_pch_valid_p (const void *data_p, size_t len)\n   int flag_mask\n     = (SH1_BIT | SH2_BIT | SH3_BIT | SH_E_BIT | HARD_SH4_BIT | FPU_SINGLE_BIT\n        | SH4_BIT | HITACHI_BIT | LITTLE_ENDIAN_BIT);\n-  \n+\n   /* -fpic and -fpie also usually make a PCH invalid.  */\n   if (data[0] != flag_pic)\n     return _(\"created and used with different settings of -fpic\");\n@@ -7267,7 +7270,7 @@ sh_pch_valid_p (const void *data_p, size_t len)\n     }\n   data += sizeof (target_flags);\n   len -= sizeof (target_flags);\n-  \n+\n   /* Check string options.  */\n #ifdef TARGET_OPTIONS\n   for (i = 0; i < ARRAY_SIZE (target_options); i++)\n@@ -7288,7 +7291,7 @@ sh_pch_valid_p (const void *data_p, size_t len)\n #endif\n \n   return NULL;\n-  \n+\n  make_message:\n   {\n     char *r;\n@@ -7903,7 +7906,7 @@ sh_const_vec (rtx v, enum machine_mode mode)\n }\n \f\n /* Return the destination address of a branch.  */\n-   \n+\n static int\n branch_dest (rtx branch)\n {\n@@ -8093,7 +8096,7 @@ f(double a)\n    remove assignments that are dead due to a following assignment in the\n    same basic block.  */\n \n-static void \n+static void\n mark_use (rtx x, rtx *reg_set_block)\n {\n   enum rtx_code code;\n@@ -8176,7 +8179,7 @@ get_free_reg (HARD_REG_SET regs_live)\n   abort ();\n }\n \n-/* This function will set the fpscr from memory. \n+/* This function will set the fpscr from memory.\n    MODE is the mode we are setting it to.  */\n void\n fpscr_set_from_mem (int mode, HARD_REG_SET regs_live)\n@@ -8222,7 +8225,7 @@ sh_insn_length_adjustment (rtx insn)\n     return 2;\n \n   /* sh-dsp parallel processing insn take four bytes instead of two.  */\n-     \n+\n   if (GET_CODE (insn) == INSN)\n     {\n       int sum = 0;\n@@ -8418,29 +8421,29 @@ mark_constant_pool_use (rtx x)\n /* Return true if it's possible to redirect BRANCH1 to the destination\n    of an unconditional jump BRANCH2.  We only want to do this if the\n    resulting branch will have a short displacement.  */\n-int \n+int\n sh_can_redirect_branch (rtx branch1, rtx branch2)\n {\n   if (flag_expensive_optimizations && simplejump_p (branch2))\n     {\n       rtx dest = XEXP (SET_SRC (single_set (branch2)), 0);\n       rtx insn;\n       int distance;\n-      \n-      for (distance = 0, insn = NEXT_INSN (branch1); \n-\t   insn && distance < 256; \n+\n+      for (distance = 0, insn = NEXT_INSN (branch1);\n+\t   insn && distance < 256;\n \t   insn = PREV_INSN (insn))\n \t{\n-\t  if (insn == dest)    \n+\t  if (insn == dest)\n \t    return 1;\n \t  else\n \t    distance += get_attr_length (insn);\n \t}\n-      for (distance = 0, insn = NEXT_INSN (branch1); \n-\t   insn && distance < 256; \n+      for (distance = 0, insn = NEXT_INSN (branch1);\n+\t   insn && distance < 256;\n \t   insn = NEXT_INSN (insn))\n \t{\n-\t  if (insn == dest)    \n+\t  if (insn == dest)\n \t    return 1;\n \t  else\n \t    distance += get_attr_length (insn);\n@@ -8706,7 +8709,7 @@ rank_for_reorder (const void *x, const void *y)\n   if (SCHED_GROUP_P (tmp) != SCHED_GROUP_P (tmp2))\n     return SCHED_GROUP_P (tmp2) ? 1 : -1;\n \n-  /* If insns are equally good, sort by INSN_LUID (original insn order), This \n+  /* If insns are equally good, sort by INSN_LUID (original insn order), This\n      minimizes instruction movement, thus minimizing sched's effect on\n      register pressure.  */\n   return INSN_LUID (tmp) - INSN_LUID (tmp2);\n@@ -8861,7 +8864,7 @@ sh_reorder (FILE *dump ATTRIBUTE_UNUSED,\n }\n \n /* Skip cycles if the current register pressure is high.  */\n-static int \n+static int\n sh_reorder2 (FILE *dump ATTRIBUTE_UNUSED,\n \t     int sched_verbose ATTRIBUTE_UNUSED,\n \t     rtx *ready ATTRIBUTE_UNUSED,\n@@ -8871,19 +8874,19 @@ sh_reorder2 (FILE *dump ATTRIBUTE_UNUSED,\n   if (reload_completed)\n     return cached_can_issue_more;\n \n-  if (high_pressure(SFmode) || high_pressure (SImode)) \n+  if (high_pressure(SFmode) || high_pressure (SImode))\n     skip_cycles = 1;\n \n   return cached_can_issue_more;\n }\n \n /* Skip cycles without sorting the ready queue. This will move insn from\n    Q->R. If this is the last cycle we are skipping; allow sorting of ready\n-   queue by sh_reorder.  */ \n+   queue by sh_reorder.  */\n \n-/* Generally, skipping these many cycles are sufficient for all insns to move \n-   from Q -> R.  */ \n-#define MAX_SKIPS 8 \n+/* Generally, skipping these many cycles are sufficient for all insns to move\n+   from Q -> R.  */\n+#define MAX_SKIPS 8\n \n static int\n sh_dfa_new_cycle (FILE *sched_dump ATTRIBUTE_UNUSED,\n@@ -8896,7 +8899,7 @@ sh_dfa_new_cycle (FILE *sched_dump ATTRIBUTE_UNUSED,\n   if (reload_completed)\n     return 0;\n \n-  if (skip_cycles) \n+  if (skip_cycles)\n     {\n       if ((clock_var - last_clock_var) < MAX_SKIPS)\n \t{\n@@ -8943,7 +8946,7 @@ sh_ms_bitfield_layout_p (tree record_type ATTRIBUTE_UNUSED)\n   return (TARGET_SH5 || TARGET_HITACHI || sh_attr_renesas_p (record_type));\n }\n \f\n-/* \n+/*\n    On the SH1..SH4, the trampoline looks like\n    2 0002 D202     \t   \tmov.l\tl2,r2\n    1 0000 D301     \t\tmov.l\tl1,r3\n@@ -9037,7 +9040,7 @@ sh_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n       emit_move_insn (gen_rtx_MEM (Pmode,\n \t\t\t\t   plus_constant (tramp,\n \t\t\t\t\t\t  fixed_len\n-\t\t\t\t\t\t  + GET_MODE_SIZE (Pmode))), \n+\t\t\t\t\t\t  + GET_MODE_SIZE (Pmode))),\n \t\t      cxt);\n       emit_insn (gen_ic_invalidate_line (tramp));\n       return;\n@@ -9119,7 +9122,7 @@ sh_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n static bool\n sh_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n-  return (decl \n+  return (decl\n \t  && (! TARGET_SHCOMPACT\n \t      || current_function_args_info.stack_regs == 0)\n \t  && ! sh_cfun_interrupt_handler_p ());\n@@ -9338,6 +9341,26 @@ sh_media_init_builtins (void)\n     }\n }\n \n+/* Implements target hook vector_mode_supported_p.  */\n+bool\n+sh_vector_mode_supported_p (enum machine_mode mode)\n+{\n+  if (TARGET_FPU_ANY\n+      && ((mode == V2SFmode)\n+\t  || (mode == V4SFmode)\n+\t  || (mode == V16SFmode)))\n+    return true;\n+\n+  else if (TARGET_SHMEDIA\n+\t   && ((mode == V8QImode)\n+\t       || (mode == V2HImode)\n+\t       || (mode == V4HImode)\n+\t       || (mode == V2SImode)))\n+    return true;\n+\n+  return false;\n+}\n+\n static void\n sh_init_builtins (void)\n {\n@@ -9538,7 +9561,7 @@ sh_register_move_cost (enum machine_mode mode,\n \n   if ((dstclass == FPUL_REGS\n        && (srcclass == PR_REGS || srcclass == MAC_REGS || srcclass == T_REGS))\n-      || (srcclass == FPUL_REGS\t\t\n+      || (srcclass == FPUL_REGS\n \t  && (dstclass == PR_REGS || dstclass == MAC_REGS)))\n     return 7;\n \n@@ -9613,15 +9636,15 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   /* Find the \"this\" pointer.  We have such a wide range of ABIs for the\n      SH that it's best to do this completely machine independently.\n-     \"this\" is passed as first argument, unless a structure return pointer \n+     \"this\" is passed as first argument, unless a structure return pointer\n      comes first, in which case \"this\" comes second.  */\n   INIT_CUMULATIVE_ARGS (cum, funtype, NULL_RTX, 0, 1);\n #ifndef PCC_STATIC_STRUCT_RETURN\n   if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n     structure_value_byref = 1;\n #endif /* not PCC_STATIC_STRUCT_RETURN */\n   if (structure_value_byref && sh_struct_value_rtx (function, 0) == 0)\n-    { \n+    {\n       tree ptype = build_pointer_type (TREE_TYPE (funtype));\n \n       FUNCTION_ARG_ADVANCE (cum, Pmode, ptype, 1);\n@@ -9877,7 +9900,7 @@ check_use_sfunc_addr (rtx insn, rtx reg)\n \tbreak;\n       if (! INSN_P (insn))\n \tcontinue;\n-\t\n+\n       if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n \tinsn = XVECEXP (PATTERN (insn), 0, 0);\n       if (GET_CODE (PATTERN (insn)) != PARALLEL\n@@ -9929,7 +9952,7 @@ sh_fsca_sf2int (void)\n \n   return sh_fsca_sf2int_rtx;\n }\n-  \n+\n /* This function returns a constant rtx that represents pi / 2**15 in\n    DFmode.  it's used to scale DFmode angles, in radians, to a\n    fixed-point signed 16.16-bit fraction of a full circle, i.e., 2*pi\n@@ -9950,7 +9973,7 @@ sh_fsca_df2int (void)\n \n   return sh_fsca_df2int_rtx;\n }\n-  \n+\n /* This function returns a constant rtx that represents 2**15 / pi in\n    SFmode.  it's used to scale a fixed-point signed 16.16-bit fraction\n    of a full circle back to a SFmode value, i.e., 0x10000 maps to"}, {"sha": "c249661452983c2286e0472fd0d2197a36d2e1f5", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -1303,14 +1303,6 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    : (REGNO) == FPSCR_REG ? (MODE) == PSImode \\\n    : 1)\n \n-/* Value is 1 if MODE is a supported vector mode.  */\n-#define VECTOR_MODE_SUPPORTED_P(MODE) \\\n-  ((TARGET_FPU_ANY \\\n-    && ((MODE) == V2SFmode || (MODE) == V4SFmode || (MODE) == V16SFmode)) \\\n-   || (TARGET_SHMEDIA \\\n-       && ((MODE) == V8QImode || (MODE) == V2HImode || (MODE) == V4HImode \\\n-\t   || (MODE) == V2SImode)))\n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,"}, {"sha": "a21a2a4b869790a21fde415e4dddd61e8bc9fc70", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -9666,7 +9666,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t(match_operand 1 \"sh_rep_vec\" \"\"))]\n   \"TARGET_SHMEDIA && reload_completed\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n-   && VECTOR_MODE_SUPPORTED_P (GET_MODE (operands[0]))\n+   && sh_vector_mode_supported_p (GET_MODE (operands[0]))\n    && GET_MODE_SIZE (GET_MODE (operands[0])) == 8\n    && (XVECEXP (operands[1], 0, 0) != const0_rtx\n        || XVECEXP (operands[1], 0, 1) != const0_rtx)\n@@ -9710,7 +9710,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t(match_operand 1 \"sh_const_vec\" \"\"))]\n   \"TARGET_SHMEDIA && reload_completed\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n-   && VECTOR_MODE_SUPPORTED_P (GET_MODE (operands[0]))\n+   && sh_vector_mode_supported_p (GET_MODE (operands[0]))\n    && operands[1] != CONST0_RTX (GET_MODE (operands[1]))\"\n   [(set (match_dup 0) (match_dup 1))]\n   \"\n@@ -10946,4 +10946,3 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   return \\\"\\\";\n }\"\n   [(set_attr \"type\" \"other\")])\n-"}, {"sha": "7f110d6c3e9c2884d9a27b51398dc6e9d1c9f5c7", "filename": "gcc/defaults.h", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -243,7 +243,7 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n    archive's table of contents.  Defining this macro to be nonzero has\n    the consequence that certain symbols will not be made weak that\n    otherwise would be.  The C++ ABI requires this macro to be zero;\n-   see the documentation. */ \n+   see the documentation. */\n #ifndef TARGET_WEAK_NOT_IN_ARCHIVE_TOC\n #define TARGET_WEAK_NOT_IN_ARCHIVE_TOC 0\n #endif\n@@ -259,7 +259,7 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n #endif\n \n /* If the target supports weak symbols, define TARGET_ATTRIBUTE_WEAK to\n-   provide a weak attribute.  Else define it to nothing. \n+   provide a weak attribute.  Else define it to nothing.\n \n    This would normally belong in ansidecl.h, but SUPPORTS_WEAK is\n    not available at that time.\n@@ -331,7 +331,7 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n \n /* By default, we generate a label at the beginning and end of the\n    text section, and compute the size of the text section by\n-   subtracting the two.  However, on some platforms that doesn't \n+   subtracting the two.  However, on some platforms that doesn't\n    work, and we use the section itself, rather than a label at the\n    beginning of it, to indicate the start of the section.  On such\n    platforms, define this to zero.  */\n@@ -479,7 +479,7 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n /* By default, the C++ compiler will use function addresses in the\n    vtable entries.  Setting this nonzero tells the compiler to use\n    function descriptors instead.  The value of this macro says how\n-   many words wide the descriptor is (normally 2).  It is assumed \n+   many words wide the descriptor is (normally 2).  It is assumed\n    that the address of a function descriptor may be treated as a\n    pointer to a function.  */\n #ifndef TARGET_VTABLE_USES_DESCRIPTORS\n@@ -660,10 +660,6 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #define HAS_LONG_UNCOND_BRANCH 0\n #endif\n \n-#ifndef VECTOR_MODE_SUPPORTED_P\n-#define VECTOR_MODE_SUPPORTED_P(MODE) 0\n-#endif\n-\n #ifndef UNITS_PER_SIMD_WORD\n #define UNITS_PER_SIMD_WORD 0\n #endif\n@@ -724,10 +720,10 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #endif\n \n /* Indicate that CLZ and CTZ are undefined at zero.  */\n-#ifndef CLZ_DEFINED_VALUE_AT_ZERO \n+#ifndef CLZ_DEFINED_VALUE_AT_ZERO\n #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  0\n #endif\n-#ifndef CTZ_DEFINED_VALUE_AT_ZERO \n+#ifndef CTZ_DEFINED_VALUE_AT_ZERO\n #define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  0\n #endif\n "}, {"sha": "7240d19e83784a473bf7d81d26011257961f66b3", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -1357,12 +1357,6 @@ appropriate sizes.  If this macro is undefined, @code{GET_MODE_BITSIZE\n (DImode)} is assumed.\n @end defmac\n \n-@defmac VECTOR_MODE_SUPPORTED_P (@var{mode})\n-Define this macro to be nonzero if the port is prepared to handle insns\n-involving vector mode @var{mode}.  At the very least, it must have move\n-patterns for this mode.\n-@end defmac\n-\n @defmac STACK_SAVEAREA_MODE (@var{save_level})\n If defined, an expression of type @code{enum machine_mode} that\n specifies the mode of the save area operand of a\n@@ -3370,7 +3364,7 @@ should return the .eh_frame register number.  The default is\n Define this macro to map register numbers held in the call frame info\n that GCC has collected using @code{DWARF_FRAME_REGNUM} to those that\n should be output in .debug_frame (@code{@var{for_eh}} is zero) and\n-.eh_frame (@code{@var{for_eh}} is nonzero).  The default is to \n+.eh_frame (@code{@var{for_eh}} is nonzero).  The default is to\n return @code{@var{regno}}.\n \n @end defmac\n@@ -3723,9 +3717,9 @@ register to be used by the caller for this argument; likewise\n @end defmac\n \n @deftypefn {Target Hook} bool TARGET_PASS_BY_REFERENCE (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})\n-This target hook should return @code{true} if an argument at the \n+This target hook should return @code{true} if an argument at the\n position indicated by @var{cum} should be passed by reference.  This\n-predicate is queried after target independent reasons for being \n+predicate is queried after target independent reasons for being\n passed by reference, such as @code{TREE_ADDRESSABLE (type)}.\n \n If the hook returns true, a copy of that argument is made in memory and a\n@@ -3884,6 +3878,12 @@ arguments to @code{va_arg}; the latter two are as in\n @code{gimplify.c:gimplify_expr}.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_VECTOR_MODE_SUPPORTED_P (enum machine_mode @var{mode})\n+Define this to return nonzero if the port is prepared to handle\n+insns involving vector mode @var{mode}.  At the very least, it\n+must have move patterns for this mode.\n+@end deftypefn\n+\n @node Scalar Return\n @subsection How Scalar Function Values Are Returned\n @cindex return values in registers\n@@ -6754,7 +6754,7 @@ hidden, protected or internal visibility as specified by @var{visibility}.\n @defmac TARGET_WEAK_NOT_IN_ARCHIVE_TOC\n A C expression that evaluates to true if the target's linker expects\n that weak symbols do not appear in a static archive's table of contents.\n-The default is @code{0}.  \n+The default is @code{0}.\n \n Leaving weak symbols out of an archive's table of contents means that,\n if a symbol will only have a definition in one translation unit and\n@@ -8482,7 +8482,7 @@ default is long_long_integer_type_node.\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_CXX_GUARD_MASK_BIT (void)\n-This hook determines how guard variables are used.  It should return \n+This hook determines how guard variables are used.  It should return\n @code{false} (the default) if first byte should be used.  A return value of\n @code{true} indicates the least significant bit should be used.\n @end deftypefn"}, {"sha": "72ba4cdeaaa2a17d5da485a213a4fa408aa50d6a", "filename": "gcc/expr.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -7836,17 +7836,17 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  tree pred = TREE_OPERAND (exp, 0);\n   \t  tree then_ = TREE_OPERAND (exp, 1);\n   \t  tree else_ = TREE_OPERAND (exp, 2);\n-  \n+\n \t  if (TREE_CODE (then_) != GOTO_EXPR\n \t      || TREE_CODE (GOTO_DESTINATION (then_)) != LABEL_DECL\n \t      || TREE_CODE (else_) != GOTO_EXPR\n \t      || TREE_CODE (GOTO_DESTINATION (else_)) != LABEL_DECL)\n \t    abort ();\n-  \n+\n \t  jumpif (pred, label_rtx (GOTO_DESTINATION (then_)));\n \t  return expand_expr (else_, const0_rtx, VOIDmode, 0);\n   \t}\n-  \n+\n         /* Note that COND_EXPRs whose type is a structure or union\n   \t are required to be constructed to contain assignments of\n   \t a temporary variable, so that we can evaluate them here\n@@ -7857,12 +7857,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n  \t  || TREE_TYPE (TREE_OPERAND (exp, 1)) == void_type_node\n  \t  || TREE_TYPE (TREE_OPERAND (exp, 2)) == void_type_node)\n  \tabort ();\n-       \n+\n        /* If we are not to produce a result, we have no target.  Otherwise,\n  \t if a target was specified use it; it will not be used as an\n  \t intermediate target unless it is safe.  If no target, use a\n  \t temporary.  */\n-       \n+\n        if (modifier != EXPAND_STACK_PARM\n  \t  && original_target\n  \t  && safe_from_p (original_target, TREE_OPERAND (exp, 0), 1)\n@@ -7875,25 +7875,25 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n  \ttemp = original_target;\n        else\n  \ttemp = assign_temp (type, 0, 0, 1);\n-       \n+\n        do_pending_stack_adjust ();\n        NO_DEFER_POP;\n        op0 = gen_label_rtx ();\n        op1 = gen_label_rtx ();\n        jumpifnot (TREE_OPERAND (exp, 0), op0);\n        store_expr (TREE_OPERAND (exp, 1), temp,\n  \t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n-       \n+\n        emit_jump_insn (gen_jump (op1));\n        emit_barrier ();\n        emit_label (op0);\n        store_expr (TREE_OPERAND (exp, 2), temp,\n  \t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n-       \n+\n        emit_label (op1);\n        OK_DEFER_POP;\n        return temp;\n-  \n+\n     case MODIFY_EXPR:\n       {\n \t/* If lhs is complex, expand calls in rhs before computing it.\n@@ -8791,7 +8791,7 @@ vector_mode_valid_p (enum machine_mode mode)\n     return 0;\n \n   /* Hardware support.  Woo hoo!  */\n-  if (VECTOR_MODE_SUPPORTED_P (mode))\n+  if (targetm.vector_mode_supported_p (mode))\n     return 1;\n \n   innermode = GET_MODE_INNER (mode);"}, {"sha": "7501e6134625d568be5317238e2e56cdb9883e67", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -1,3 +1,8 @@\n+2004-08-23  Eric Christopher  <echristo@redhat.com>\n+\n+\t* trans-types.c (gfc_type_for_mode): Remove VECTOR_TYPE_SUPPORTED_P\n+\tusage. Use build_vector_type_for_mode for vector types.\n+\n 2004-08-22  Richard Henderson  <rth@redhat.com>\n \n \tPR 13465\n@@ -18,7 +23,7 @@\n 2004-08-22  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* check.c (gfc_check_reduction): Rename to ...\n-\t(check_reduction): ... this. Make static. Don't check type of \n+\t(check_reduction): ... this. Make static. Don't check type of\n \tfirst argument.\n \t(gfc_check_minval_maxval, gfc_check_prodcut_sum): New functions.\n \t* intrinsic.c (add_functions): Change MAXVAL, MINVAL, PRODUCT and\n@@ -46,7 +51,7 @@\n \t(gfc_match_simple_where, match_forall_header,\n \tgfc_match_simple_forall): New functions.\n \t(gfc_match_forall): Use match_forall_header.\n-\t\n+\n 2004-08-19  Paul Brook  <paul@codesourcery.com>\n \n \tPR fortran/17091\n@@ -56,7 +61,7 @@\n 2004-08-19  Paul Brook  <paul@codesourcery.com>\n \n \tPR fortran/14976\n-\tPR fortran/16228 \n+\tPR fortran/16228\n \t* data.c (assign_substring_data_value): Remove.\n \t(create_character_intializer): New function.\n \t(gfc_assign_data_value): Track the typespec for the current\n@@ -144,27 +149,27 @@\n \tPR fortran/17030\n \t* f95-lang.c (gfc_init_builtin_functions): Initialize the builtins\n \tfor cabs{,f} and copysign{,f}.\n-\t* trans-decl.c (gfor_fndecl_math_cabsf): Delete. \n-\t(gfor_fndecl_math_cabs): Delete. \n-\t(gfor_fndecl_math_sign4): Delete. \n-\t(gfor_fndecl_math_sign8): Delete. \n+\t* trans-decl.c (gfor_fndecl_math_cabsf): Delete.\n+\t(gfor_fndecl_math_cabs): Delete.\n+\t(gfor_fndecl_math_sign4): Delete.\n+\t(gfor_fndecl_math_sign8): Delete.\n \t(gfc_build_intrinsic_function_decls): Remove the\n \tinitializing of cabs{,f} and copysign{,f} functions.\n \t* trans-intrinsic.c (gfc_conv_intrinsic_abs): Use the builtins\n \tinstead of the functions definitions.\n \t(gfc_conv_intrinsic_sign): Likewise.\n-\t* trans.h (gfor_fndecl_math_cabsf): Delete. \n-\t(gfor_fndecl_math_cabs): Delete. \n-\t(gfor_fndecl_math_sign4): Delete. \n-\t(gfor_fndecl_math_sign8): Delete. \n+\t* trans.h (gfor_fndecl_math_cabsf): Delete.\n+\t(gfor_fndecl_math_cabs): Delete.\n+\t(gfor_fndecl_math_sign4): Delete.\n+\t(gfor_fndecl_math_sign8): Delete.\n \n 2004-08-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* trans-array.c (gfc_trans_array_constructor_value): Use\n-\tbuild_int_cst. \n+\tbuild_int_cst.\n \t* trans-const.c (gfc_build_string_const,\n \tgfc_init_constants, gfc_conv_mpz_to_tree,\n-\tgfc_conv_constant_to_tree): Likewise. \n+\tgfc_conv_constant_to_tree): Likewise.\n \t* trans-decl.c (gfc_get_symbol_decl): Likewise.\n \t* trans-intrinsic.c (gfc_conv_intrinsic_ibits,\n \tgfc_conv_intrinsic_len, prepare_arg_info): Likewise.\n@@ -467,7 +472,7 @@\n \t* trans-expr.c (gfc_conv_structure): Handle array pointers.\n \n 2004-07-10  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n-\t\n+\n \tPR fortran/16336\n \t* decl.c (gfc_match_save): Use-associated common block\n \tdoesn't collide.\n@@ -502,7 +507,7 @@\n \n \t* trans-decl.c (generate_local_decl): Remove workaround obsoleted\n \tby fix for PR 15481.\n-\t\n+\n 2004-07-10  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* trans-common.c: Fix whitespace issues, make variable names\n@@ -521,13 +526,13 @@\n \t* trans-types.c: Update comment.\n \n 2004-07-09  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n-\t\n+\n \tPR fortran/14077\n \t* moduele.c (mio_symbol): Don't I/O initial values unless\n \tsymbol is a parameter.\n \n 2004-07-09  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n-\t\n+\n \tPR fortran/13201\n \t* resolve.c (resolve_symbol): Verify that the shape of a\n \tparameter array is not only explicit, but also constant.\n@@ -548,7 +553,7 @@\n \tgfc_set_default_type to issue error if no implicit type\n \tcan be found.\n \t* trans-decl.c (gfc_create_module_variable): Remove workaround.\n-\t\n+\n 2004-07-08  Paul Brook  <paul@codesourcery.com>\n \n \t* intrinsic.c (add_sym_4s): New function.\n@@ -633,7 +638,7 @@\n \n 2004-06-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n-\t* decl.c, interface.c, symbol.c, trans-common.c: Add 2004 to \n+\t* decl.c, interface.c, symbol.c, trans-common.c: Add 2004 to\n \tcopyright years.\n \n 2004-06-29  Steven Bosscher  <stevenb@suse.de>\n@@ -726,7 +731,7 @@\n \t(gfc_clear_attr): Don't set removed attributes.\n \t(gfc_copy_attr): Don't copy removed attributes.\n \t(traverse_symtree): Remove.\n-\t(gfc_traverse_symtree): Don't traverse symbol \n+\t(gfc_traverse_symtree): Don't traverse symbol\n \ttree of the passed namespace, but require a symtree to be passed\n \tinstead. Unify with traverse_symtree.\n \t(gfc_traverse_ns): Call gfc_traverse_symtree according to new\n@@ -743,7 +748,7 @@\n \tcreate_common.\n \t(named_common): take 'gfc_symtree' instead of 'gfc_symbol'.\n \t(gfc_trans_common): Adapt to new data structures.\n-\t* trans-decl.c (gfc_create_module_variables): Remove test for \n+\t* trans-decl.c (gfc_create_module_variables): Remove test for\n \tremoved attribute.\n \n 2004-06-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n@@ -829,7 +834,7 @@\n \t* scanner.c (load_line): Don't truncate preprocessor lines.\n \tReformat error message.\n \t(preprocessor_line): Issue warning in case of malformed\n-\tpreprocessor line. \n+\tpreprocessor line.\n \n 2004-06-21  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n@@ -841,7 +846,7 @@\n \n \t* array.c (gfc_insert_constructor): Avoid redundant call to\n \tmpz_comp. Add 2004 to copyright years.\n-\t\n+\n 2004-06-21  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* trans.h (stmtblock_t): Change has_scope to unsigned int.\n@@ -863,7 +868,7 @@\n \n \tPR fortran/15211\n \t* trans-intrinsic.c (gfc_conv_intrinsic_len): Deal with arrays\n-\tof strings. \n+\tof strings.\n \n 2004-06-14  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n@@ -881,7 +886,7 @@\n \t* intrinsic.h (gfc_check_minloc_maxloc): ... adapt prototype.\n \t* intrinsic.c (add_sym_3ml): New function.\n \t(add_functions): Change to add_sym_3ml for MINLOC, MAXLOC.\n-\t(check_specific): Catch special case MINLOC, MAXLOC. \n+\t(check_specific): Catch special case MINLOC, MAXLOC.\n \n 2004-06-14  Paul Brook  <paul@codesourcery.com>\n \n@@ -902,22 +907,22 @@\n \t* intrinsic.c (add_sym_2s): New function.\n \t* intrinsic.c: Add etime, dtime, irand, rand, second, srand.\n \t* intrinsic.h: Function prototypes.\n-\t* iresolve.c (gfc_resolve_etime_sub, gfc_resolve_second_sub \n+\t* iresolve.c (gfc_resolve_etime_sub, gfc_resolve_second_sub\n \tgfc_resolve_srand):  New functions.\n \n 2004-06-12  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/14957\n \t* decl.c (gfc_match_end): Require END {SUBROUTINE|FUNCTION} for\n \tcontained procedure.\n-\t\n+\n 2004-06-12  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/12841\n \t* interface.c (compare_parameter, compare_actual_formal): Don't\n \tcheck types and array shapes for NULL()\n \t* trans-expr.c (conv_function_call): No double indirection for\n-\tNULL() \n+\tNULL()\n \n 2004-06-09  Toon Moene  <toon@moene.indiv.nluug.nl>\n \n@@ -949,7 +954,7 @@\n \n 2004-06-05  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n-\t* intrinsic.c (sort_actual): Keep track of type of missing \n+\t* intrinsic.c (sort_actual): Keep track of type of missing\n \targuments. (Missing from previous commit.)\n \n 2004-06-03  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n@@ -1225,8 +1230,8 @@\n 2004-05-17  Steve Kargl  <kargls@comcast.net>\n \n \t* arith.c (gfc_real2complex): Range checking wrong part of complex\n-        number. \n-\t\n+        number.\n+\n 2004-05-16  Paul Brook  <paul@codesourcery.com>\n \n \t* options.c (gfc_handle_module_path_options): Fix buffer overrun.\n@@ -1246,7 +1251,7 @@\n \tnot initialized in a disallowed fashion.\n \t* match.c (gfc_match_common): Likewise.\n \t(var_element): Verify that variable is not in the blank COMMON,\n-\tif it is in a common. \n+\tif it is in a common.\n \n 2004-05-15  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n@@ -1280,7 +1285,7 @@\n \n 2004-05-15  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n-\tPR fortran/13702 \n+\tPR fortran/13702\n \t(Port from g95)\n \t* gfortran.h (gfc_linebuf): New typedef.\n \t(linebuf): Remove.\n@@ -1364,7 +1369,7 @@\n \t* intrinsic.h: ... declare it here.\n \t* intrinsic.c (add_functions): ... add it as resolving function\n \tfor NEAREST.\n-\t\n+\n 2004-05-14  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n         PR fortran/14066\n@@ -1397,7 +1402,7 @@\n \n \tPR fortran/14568\n \t* trans-decl.c (generate_local_decl): Don't warn for unused\n-        variables which are in common blocks. \n+        variables which are in common blocks.\n \n 2004-05-13  Diego Novillo  <dnovillo@redhat.com>\n \n@@ -1494,7 +1499,7 @@\n \n 2004-04-11  Feng Wang  <fengwang@nudt.edu.cn>\n \n-\tPR 14394 \n+\tPR 14394\n \t* trans-const.c (gfc_conv_mpf_to_tree): Loosen the maximum digits of\n \tthe real value when converting mpf to string.\n \n@@ -1517,7 +1522,7 @@\n \n \t* Make-lang.in (GFORTRAN_TEXI): Set it.\n \t(fortran/dfortran.dvi): Use it.  Add fortran to include paths.\n-\t(fortran/gfortran.info): Ditto. \n+\t(fortran/gfortran.info): Ditto.\n \t* gfortran.texi: Major update.\n \t* invoke.texi: New file.\n \n@@ -1682,7 +1687,7 @@\n \t* gfortran.texi: Fix typos.\n \n 2004-02-07  Bud Davis  <bdavis9659@comcast.net>\n- \n+\n \tPR gfortran/13909\n \t* intrinsic.c (add_conversions) Use logical conversion instead\n \tof real.\n@@ -1842,7 +1847,7 @@\n 2003-12-31  Huang Chun <chunhuang73@hotmail.com>\n \n \tPR fortran/13434\n-\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxval): Fixed bug in \n+\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxval): Fixed bug in\n \tminval/maxval.\n \n 2003-12-22  Toon Moene  <toon@moene.indiv.nluug.nl>\n@@ -1861,9 +1866,9 @@\n \t* primary.c (match_substring): Fix substring bug for start point\n \tor end point is NULL.\n \t* trans-expr.c (gfc_conv_substring): Ditto\n-\t* trans-types.c (gfc_sym_type): Get correct type of scalar \n+\t* trans-types.c (gfc_sym_type): Get correct type of scalar\n \tcharacter variables.\n-\t* trans-intrinsic.c (gfc_conv_intrinsic_len): Handle character in \n+\t* trans-intrinsic.c (gfc_conv_intrinsic_len): Handle character in\n \tderived type.\n \n 2003-12-10  Richard Henderson  <rth@redhat.com>\n@@ -2049,7 +2054,7 @@\n \tannotate_all_with_locus.\n \n 2003-11-11  Canqun Yang  <canqun@nudt.edu.cn>\n- \n+\n \t* options.c (gfc_init_options): Set flag_max_stack_var_size as 32768.\n \t* trans-decl.c (gfc_finish_var_decl): Modified.\n \n@@ -2236,7 +2241,7 @@\n \t* data.c: New file.\n \n 2003-09-20  Kejia Zhao  <kejia_zh@yahoo.com.cn>\n- \n+\n \t* trans.h: Add declarations for gfor_fndecl_si_kind and\n \tgfor_fndecl_sr_kind.\n \t* trans-decl.c (g95_build_intrinsic_function_decls): Build them.\n@@ -2308,7 +2313,7 @@\n \n 2003-08-24 XiaoQiang Zhang  (zhangapache@yahoo.com>\n \n-\t* trans-const.c (gfc_conv_mpz_to_tree): Fix bug, parameter for \n+\t* trans-const.c (gfc_conv_mpz_to_tree): Fix bug, parameter for\n \tbuild_int_2 changed from (high, low) to (low, high).\n \t* trans-io.c (ioparm_namelist_name, ioparm_namelist_name_len,\n \tioparm_namelist_read_mode, iocall_set_nml_val_int,\n@@ -2326,13 +2331,13 @@\n \n 2003-09-07  Kejia Zhao  <kejia_zh@yahoo.com.cn>\n \n-\t* trans-intrinsic.c (gfc_conv_intrinsic_aint): Fix two bugs. One is \n-\tabout case_switch's break. The other is about building the condition \n-\tstatement tree, which judges the argument in the range of the \n+\t* trans-intrinsic.c (gfc_conv_intrinsic_aint): Fix two bugs. One is\n+\tabout case_switch's break. The other is about building the condition\n+\tstatement tree, which judges the argument in the range of the\n \tcorresponding integer type.\n \t* trans-intrinsic.c (gfc_conv_intrinsic_mod): MOD and MODULO can work\n \tfor the large values.\n- \n+\n 2003-09-05  Paul Brook  <paul@nowt.org>\n \n \t* f95-lang.c (expand_function_body): Gimplify the function.\n@@ -2436,7 +2441,7 @@\n \ttype components.\n \n 2003-08-10  Chun Huang  <compiler@sohu.com>\n- \n+\n \t* resolve.c (resolve_formal_arglist): Resolve STATEMENT function.\n \t(resolve_symbol): Ditto.\n \t* trans-expr.c (gfc_conv_statement_function): New function.\n@@ -2523,7 +2528,7 @@\n \tRename g95_* to gfc_*.\n \n 2003-07-25  Paul Brook  <paul@nowt.org>\n-\t\n+\n \t* gfortran.h: Rename from g95.h.\n \t* trans-types.c (boolean_type_node, booelan_true_node,\n \tboolean_false_node): Remove.\n@@ -4483,4 +4488,3 @@\n \t(g95_conv_intrinsic_anyall): New function.\n \t* iresolve.c (g95_resolve_any, g95_resolve_all): Include rank in\n \tmangled name\n-"}, {"sha": "8f0749d0fe2a2aaa6a8041600c487a6168e9cb4d", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -588,7 +588,7 @@ gfc_get_dtype (tree type, int rank)\n \n   assert (rank <= GFC_DTYPE_RANK_MASK);\n   size = TYPE_SIZE_UNIT (type);\n-    \n+\n   i = rank | (n << GFC_DTYPE_TYPE_SHIFT);\n   if (size && INTEGER_CST_P (size))\n     {\n@@ -1360,38 +1360,13 @@ gfc_type_for_mode (enum machine_mode mode, int unsignedp)\n   if (mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n     return build_pointer_type (integer_type_node);\n \n-#ifdef VECTOR_MODE_SUPPORTED_P\n-  if (VECTOR_MODE_SUPPORTED_P (mode))\n+  if (VECTOR_MODE_P (mode))\n     {\n-      switch (mode)\n-\t{\n-\tcase V16QImode:\n-\t  return unsignedp ? unsigned_V16QI_type_node : V16QI_type_node;\n-\tcase V8HImode:\n-\t  return unsignedp ? unsigned_V8HI_type_node : V8HI_type_node;\n-\tcase V4SImode:\n-\t  return unsignedp ? unsigned_V4SI_type_node : V4SI_type_node;\n-\tcase V2DImode:\n-\t  return unsignedp ? unsigned_V2DI_type_node : V2DI_type_node;\n-\tcase V2SImode:\n-\t  return unsignedp ? unsigned_V2SI_type_node : V2SI_type_node;\n-\tcase V4HImode:\n-\t  return unsignedp ? unsigned_V4HI_type_node : V4HI_type_node;\n-\tcase V8QImode:\n-\t  return unsignedp ? unsigned_V8QI_type_node : V8QI_type_node;\n-\tcase V16SFmode:\n-\t  return V16SF_type_node;\n-\tcase V4SFmode:\n-\t  return V4SF_type_node;\n-\tcase V2SFmode:\n-\t  return V2SF_type_node;\n-\tcase V2DFmode:\n-\t  return V2DF_type_node;\n-\tdefault:\n-\t  break;\n-\t}\n+      enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+      tree inner_type = gfc_type_for_mode (inner_mode, unsignedp);\n+      if (inner_type != NULL_TREE)\n+        return build_vector_type_for_mode (inner_type, mode);\n     }\n-#endif\n \n   return 0;\n }"}, {"sha": "077f9bf8e0e0b17ae8a08d83dd48727b222e4733", "filename": "gcc/hooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -62,6 +62,13 @@ hook_bool_bool_false (bool a ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+/* Generic hook that takes (enum machine_mode) and returns false.  */\n+bool\n+hook_bool_mode_false (enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n /* Generic hook that takes (FILE *, const char *) and does nothing.  */\n void\n hook_void_FILEptr_constcharptr (FILE *a ATTRIBUTE_UNUSED, const char *b ATTRIBUTE_UNUSED)"}, {"sha": "a611ba198deda6907b9fb1aeb7fb2aedd1b72f5c", "filename": "gcc/hooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -22,8 +22,11 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #ifndef GCC_HOOKS_H\n #define GCC_HOOKS_H\n \n+#include \"machmode.h\"\n+\n extern bool hook_bool_void_false (void);\n extern bool hook_bool_bool_false (bool);\n+extern bool hook_bool_mode_false (enum machine_mode);\n extern bool hook_bool_tree_false (tree);\n extern bool hook_bool_tree_true (tree);\n extern bool hook_bool_tree_hwi_hwi_tree_false (tree, HOST_WIDE_INT, HOST_WIDE_INT,"}, {"sha": "acbba5535475aa916e903afcf993c21fa2b4bb33", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -384,7 +384,7 @@ layout_decl (tree decl, unsigned int known_align)\n \t      enum machine_mode xmode\n \t\t= mode_for_size_tree (DECL_SIZE (decl), MODE_INT, 1);\n \n-\t      if (xmode != BLKmode \n+\t      if (xmode != BLKmode\n \t\t  && (known_align == 0\n \t\t      || known_align >= GET_MODE_ALIGNMENT (xmode)))\n \t\t{\n@@ -1559,7 +1559,7 @@ layout_type (tree type)\n \t    for (; mode != VOIDmode ; mode = GET_MODE_WIDER_MODE (mode))\n \t      if (GET_MODE_NUNITS (mode) == nunits\n \t  \t  && GET_MODE_INNER (mode) == innermode\n-\t  \t  && VECTOR_MODE_SUPPORTED_P (mode))\n+\t  \t  && targetm.vector_mode_supported_p (mode))\n \t        break;\n \n \t    /* For integers, try mapping it to a same-sized scalar mode.  */\n@@ -1977,7 +1977,7 @@ set_min_and_max_values_for_integral_type (tree type,\n   if (is_unsigned)\n     {\n       min_value = build_int_cst (type, 0, 0);\n-      max_value \n+      max_value\n \t= build_int_cst (type, precision - HOST_BITS_PER_WIDE_INT >= 0\n \t\t\t ? -1 : ((HOST_WIDE_INT) 1 << precision) - 1,\n \t\t\t precision - HOST_BITS_PER_WIDE_INT > 0\n@@ -1988,14 +1988,14 @@ set_min_and_max_values_for_integral_type (tree type,\n     }\n   else\n     {\n-      min_value \n+      min_value\n \t= build_int_cst (type,\n \t\t\t (precision - HOST_BITS_PER_WIDE_INT > 0\n \t\t\t  ? 0 : (HOST_WIDE_INT) (-1) << (precision - 1)),\n \t\t\t (((HOST_WIDE_INT) (-1)\n \t\t\t   << (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n \t\t\t       ? precision - HOST_BITS_PER_WIDE_INT - 1\n-\t\t\t       : 0))));    \n+\t\t\t       : 0))));\n       max_value\n \t= build_int_cst (type,\n \t\t\t (precision - HOST_BITS_PER_WIDE_INT > 0\n@@ -2026,7 +2026,7 @@ fixup_signed_type (tree type)\n   if (precision > HOST_BITS_PER_WIDE_INT * 2)\n     precision = HOST_BITS_PER_WIDE_INT * 2;\n \n-  set_min_and_max_values_for_integral_type (type, precision, \n+  set_min_and_max_values_for_integral_type (type, precision,\n \t\t\t\t\t    /*is_unsigned=*/false);\n \n   /* Lay out the type: set its alignment, size, etc.  */\n@@ -2049,8 +2049,8 @@ fixup_unsigned_type (tree type)\n     precision = HOST_BITS_PER_WIDE_INT * 2;\n \n   TYPE_UNSIGNED (type) = 1;\n-  \n-  set_min_and_max_values_for_integral_type (type, precision, \n+\n+  set_min_and_max_values_for_integral_type (type, precision,\n \t\t\t\t\t    /*is_unsigned=*/true);\n \n   /* Lay out the type: set its alignment, size, etc.  */"}, {"sha": "14dd1de4bcdc29604a79adbc3b492978b840abbf", "filename": "gcc/system.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -507,7 +507,7 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \n /* Provide a fake boolean type.  We make no attempt to use the\n    C99 _Bool, as it may not be available in the bootstrap compiler,\n-   and even if it is, it is liable to be buggy.  \n+   and even if it is, it is liable to be buggy.\n    This must be after all inclusion of system headers, as some of\n    them will mess us up.  */\n \n@@ -600,7 +600,8 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tSETUP_INCOMING_VARARGS EXPAND_BUILTIN_SAVEREGS\t\t\t\\\n \tDEFAULT_SHORT_ENUMS SPLIT_COMPLEX_ARGS MD_ASM_CLOBBERS\t\t\\\n \tHANDLE_PRAGMA_REDEFINE_EXTNAME HANDLE_PRAGMA_EXTERN_PREFIX\t\\\n-\tMUST_PASS_IN_STACK FUNCTION_ARG_PASS_BY_REFERENCE\n+\tMUST_PASS_IN_STACK FUNCTION_ARG_PASS_BY_REFERENCE               \\\n+        VECTOR_MODE_SUPPORTED_P\n \n /* Other obsolete target macros, or macros that used to be in target\n    headers and were not used, and may be obsolete or may never have"}, {"sha": "4d8fea0c8dd8dece3e77c6b3e8479cb2653297e4", "filename": "gcc/target-def.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -305,11 +305,15 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_VALID_POINTER_MODE default_valid_pointer_mode\n #endif\n \n+#ifndef TARGET_VECTOR_MODE_SUPPORTED_P\n+#define TARGET_VECTOR_MODE_SUPPORTED_P hook_bool_mode_false\n+#endif\n+\n #ifndef TARGET_VECTOR_OPAQUE_P\n #define TARGET_VECTOR_OPAQUE_P hook_bool_tree_false\n #endif\n \n-/* In hook.c.  */\n+/* In hooks.c.  */\n #define TARGET_CANNOT_MODIFY_JUMPS_P hook_bool_void_false\n #define TARGET_BRANCH_TARGET_REGISTER_CLASS hook_int_void_no_regs\n #define TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED hook_bool_bool_false\n@@ -471,6 +475,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_ENCODE_SECTION_INFO,\t\t\t\\\n   TARGET_STRIP_NAME_ENCODING,\t\t\t\\\n   TARGET_VALID_POINTER_MODE,                    \\\n+  TARGET_VECTOR_MODE_SUPPORTED_P,               \\\n   TARGET_VECTOR_OPAQUE_P,\t\t\t\\\n   TARGET_RTX_COSTS,\t\t\t\t\\\n   TARGET_ADDRESS_COST,\t\t\t\t\\"}, {"sha": "2c3798eaa5df70c9ab7f094aed24dce2d717030f", "filename": "gcc/target.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f676971a92dcc163394d15c819e904cbed2438d6/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=f676971a92dcc163394d15c819e904cbed2438d6", "patch": "@@ -134,7 +134,7 @@ struct gcc_target\n \n     /* Tell assembler to switch to the readonly data section associated\n        with function DECL.  */\n-    void (* function_rodata_section) (tree); \n+    void (* function_rodata_section) (tree);\n \n     /* Output a constructor for a symbol with a given priority.  */\n     void (* constructor) (rtx, int);\n@@ -270,12 +270,12 @@ struct gcc_target\n \n     /* The following member value is a pointer to a function called\n        by the insn scheduler.  It should return true if there exists a\n-       dependence which is considered costly by the target, between \n-       the insn passed as the first parameter, and the insn passed as \n-       the second parameter.  The third parameter is the INSN_DEPEND \n+       dependence which is considered costly by the target, between\n+       the insn passed as the first parameter, and the insn passed as\n+       the second parameter.  The third parameter is the INSN_DEPEND\n        link that represents the dependence between the two insns.  The\n        fourth argument is the cost of the dependence as estimated by\n-       the scheduler.  The last argument is the distance in cycles \n+       the scheduler.  The last argument is the distance in cycles\n        between the already scheduled insn (first parameter) and the\n        the second insn (second parameter).  */\n     bool (* is_costly_dependence) (rtx, rtx, rtx, int, int);\n@@ -381,6 +381,9 @@ struct gcc_target\n   /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n   bool (* valid_pointer_mode) (enum machine_mode mode);\n \n+  /* True if MODE is valid for a vector.  */\n+  bool (* vector_mode_supported_p) (enum machine_mode mode);\n+\n   /* True if a vector is opaque.  */\n   bool (* vector_opaque_p) (tree);\n "}]}