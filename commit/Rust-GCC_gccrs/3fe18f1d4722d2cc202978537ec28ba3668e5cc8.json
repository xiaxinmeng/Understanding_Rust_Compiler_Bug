{"sha": "3fe18f1d4722d2cc202978537ec28ba3668e5cc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZlMThmMWQ0NzIyZDJjYzIwMjk3ODUzN2VjMjhiYTM2NjhlNWNjOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-06-26T00:07:09Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-06-26T00:07:09Z"}, "message": "re PR c++/10931 (valid conversion static_cast<const unsigned int&>(lvalue-of-type-int) is rejected)\n\n\tPR c++/10931\n\t* g++.dg/expr/static_cast1.C: New test.\n\n\tPR c++/10931\n\t* call.c (convert_like): Pass issue_conversion_warnings.\n\t(convert_like_with_context): Likewise.\n\t(convert_like_real): Add issue_conversion_warnings parameter.\n\t(perform_direct_initialization_if_possible): New function.\n\t* cp-tree.h (perform_direct_initialization_if_possible): Declare it.\n\t* typeck.c (check_for_casting_away_constness): New function.\n\t(build_static_cast): Rewrite.\n\nFrom-SVN: r68506", "tree": {"sha": "281a1acd47d7c8c8c2b28917010ced8fb26b4b98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/281a1acd47d7c8c8c2b28917010ced8fb26b4b98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fe18f1d4722d2cc202978537ec28ba3668e5cc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe18f1d4722d2cc202978537ec28ba3668e5cc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fe18f1d4722d2cc202978537ec28ba3668e5cc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/comments", "author": null, "committer": null, "parents": [{"sha": "22c7c85ebc1408ab528f400094e5dc513e51dcdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22c7c85ebc1408ab528f400094e5dc513e51dcdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22c7c85ebc1408ab528f400094e5dc513e51dcdc"}], "stats": {"total": 295, "additions": 209, "deletions": 86}, "files": [{"sha": "d6244467df1dbe87bce2b317ec16456b20ec763a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3fe18f1d4722d2cc202978537ec28ba3668e5cc8", "patch": "@@ -1,3 +1,14 @@\n+2003-06-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/10931\n+\t* call.c (convert_like): Pass issue_conversion_warnings.\n+\t(convert_like_with_context): Likewise.\n+\t(convert_like_real): Add issue_conversion_warnings parameter.\n+\t(perform_direct_initialization_if_possible): New function.\n+\t* cp-tree.h (perform_direct_initialization_if_possible): Declare it.\n+\t* typeck.c (check_for_casting_away_constness): New function.\n+\t(build_static_cast): Rewrite.\n+\t\n 2003-06-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* call.c (enforce_access): Assert we get a binfo."}, {"sha": "41ad02dba71129e17896b25052d5790036f6b633", "filename": "gcc/cp/call.c", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3fe18f1d4722d2cc202978537ec28ba3668e5cc8", "patch": "@@ -45,11 +45,13 @@ static int joust (struct z_candidate *, struct z_candidate *, bool);\n static int compare_ics (tree, tree);\n static tree build_over_call (struct z_candidate *, int);\n static tree build_java_interface_fn_ref (tree, tree);\n-#define convert_like(CONV, EXPR) \\\n-  convert_like_real ((CONV), (EXPR), NULL_TREE, 0, 0)\n-#define convert_like_with_context(CONV, EXPR, FN, ARGNO) \\\n-  convert_like_real ((CONV), (EXPR), (FN), (ARGNO), 0)\n-static tree convert_like_real (tree, tree, tree, int, int);\n+#define convert_like(CONV, EXPR)\t\t\t\t\\\n+  convert_like_real ((CONV), (EXPR), NULL_TREE, 0, 0, \t\t\\\n+\t\t     /*issue_conversion_warnings=*/true)\n+#define convert_like_with_context(CONV, EXPR, FN, ARGNO)\t\\\n+  convert_like_real ((CONV), (EXPR), (FN), (ARGNO), 0, \t\t\\\n+\t\t     /*issue_conversion_warnings=*/true)\n+static tree convert_like_real (tree, tree, tree, int, int, bool);\n static void op_error (enum tree_code, enum tree_code, tree, tree,\n \t\t\t    tree, const char *);\n static tree build_object_call (tree, tree);\n@@ -4115,14 +4117,17 @@ enforce_access (tree basetype_path, tree decl)\n   return true;\n }\n \n-/* Perform the conversions in CONVS on the expression EXPR. \n-   FN and ARGNUM are used for diagnostics.  ARGNUM is zero based, -1\n+/* Perform the conversions in CONVS on the expression EXPR.  FN and\n+   ARGNUM are used for diagnostics.  ARGNUM is zero based, -1\n    indicates the `this' argument of a method.  INNER is nonzero when\n    being called to continue a conversion chain. It is negative when a\n-   reference binding will be applied, positive otherwise.  */\n+   reference binding will be applied, positive otherwise.  If\n+   ISSUE_CONVERSION_WARNINGS is true, warnings about suspicious\n+   conversions will be emitted if appropriate.  */\n \n static tree\n-convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner)\n+convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner,\n+\t\t   bool issue_conversion_warnings)\n {\n   int savew, savee;\n \n@@ -4138,11 +4143,13 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner)\n \t{\n \t  if (TREE_CODE (t) == USER_CONV || !ICS_BAD_FLAG (t))\n \t    {\n-\t      expr = convert_like_real (t, expr, fn, argnum, 1);\n+\t      expr = convert_like_real (t, expr, fn, argnum, 1,\n+\t\t\t\t\t/*issue_conversion_warnings=*/false);\n \t      break;\n \t    }\n \t  else if (TREE_CODE (t) == AMBIG_CONV)\n-\t    return convert_like_real (t, expr, fn, argnum, 1);\n+\t    return convert_like_real (t, expr, fn, argnum, 1,\n+\t\t\t\t      /*issue_conversion_warnings=*/false);\n \t  else if (TREE_CODE (t) == IDENTITY_CONV)\n \t    break;\n \t}\n@@ -4152,7 +4159,7 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner)\n       return cp_convert (totype, expr);\n     }\n   \n-  if (!inner)\n+  if (issue_conversion_warnings)\n     expr = dubious_conversion_warnings\n              (totype, expr, \"argument\", fn, argnum);\n   switch (TREE_CODE (convs))\n@@ -4250,7 +4257,8 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner)\n     };\n \n   expr = convert_like_real (TREE_OPERAND (convs, 0), expr, fn, argnum,\n-                            TREE_CODE (convs) == REF_BIND ? -1 : 1);\n+                            TREE_CODE (convs) == REF_BIND ? -1 : 1,\n+\t\t\t    /*issue_conversion_warnings=*/false);\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n@@ -6058,6 +6066,25 @@ perform_implicit_conversion (tree type, tree expr)\n   return convert_like (conv, expr);\n }\n \n+/* Convert EXPR to TYPE (as a direct-initialization) if that is\n+   permitted.  If the conversion is valid, the converted expression is\n+   returned.  Otherwise, NULL_TREE is returned.  */\n+\n+tree\n+perform_direct_initialization_if_possible (tree type, tree expr)\n+{\n+  tree conv;\n+  \n+  if (type == error_mark_node || error_operand_p (expr))\n+    return error_mark_node;\n+  conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n+\t\t\t      LOOKUP_NORMAL);\n+  if (!conv || ICS_BAD_FLAG (conv))\n+    return NULL_TREE;\n+  return convert_like_real (conv, expr, NULL_TREE, 0, 0, \n+\t\t\t    /*issue_conversion_warnings=*/false);\n+}\n+\n /* DECL is a VAR_DECL whose type is a REFERENCE_TYPE.  The reference\n    is being bound to a temporary.  Create and return a new VAR_DECL\n    with the indicated TYPE; this variable will store the value to"}, {"sha": "0e3a97115f407c853af3cada50993cfd561fa16a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3fe18f1d4722d2cc202978537ec28ba3668e5cc8", "patch": "@@ -3525,6 +3525,7 @@ extern tree initialize_reference (tree, tree, tree);\n extern tree make_temporary_var_for_ref_to_temp (tree, tree);\n extern tree strip_top_quals (tree);\n extern tree perform_implicit_conversion (tree, tree);\n+extern tree perform_direct_initialization_if_possible (tree, tree);\n extern tree in_charge_arg_for_name (tree);\n extern tree build_cxx_call (tree, tree, tree);\n "}, {"sha": "c84cc84f7dd18409539ba7004d6e8e6efc2d7ef3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 147, "deletions": 73, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3fe18f1d4722d2cc202978537ec28ba3668e5cc8", "patch": "@@ -4766,11 +4766,24 @@ build_compound_expr (tree list)\n   return build (COMPOUND_EXPR, TREE_TYPE (rest), first, rest);\n }\n \n+/* Issue an error message if casting from SRC_TYPE to DEST_TYPE casts\n+   away constness.  */\n+\n+static void\n+check_for_casting_away_constness (tree src_type, tree dest_type)\n+{\n+  if (casts_away_constness (src_type, dest_type))\n+    error (\"static_cast from type `%T' to type `%T' casts away constness\",\n+\t   src_type, dest_type);\n+}\n+\n+/* Return an expression representing static_cast<TYPE>(EXPR).  */\n+\n tree\n build_static_cast (tree type, tree expr)\n {\n   tree intype;\n-  int ok;\n+  tree result;\n \n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n@@ -4791,88 +4804,149 @@ build_static_cast (tree type, tree expr)\n       && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n     expr = TREE_OPERAND (expr, 0);\n \n-  if (TREE_CODE (type) == VOID_TYPE)\n-    {\n-      expr = convert_to_void (expr, /*implicit=*/NULL);\n-      return expr;\n-    }\n+  intype = TREE_TYPE (expr);\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    return (convert_from_reference\n-\t    (convert_to_reference (type, expr, CONV_STATIC|CONV_IMPLICIT,\n-\t\t\t\t   LOOKUP_COMPLAIN, NULL_TREE)));\n+  /* [expr.static.cast]\n \n-  if (IS_AGGR_TYPE (type))\n-    return build_cplus_new (type, (build_special_member_call\n-\t\t\t\t   (NULL_TREE, complete_ctor_identifier, \n-\t\t\t\t    build_tree_list (NULL_TREE, expr),\n-\t\t\t\t    TYPE_BINFO (type), LOOKUP_NORMAL)));\n+     An expression e can be explicitly converted to a type T using a\n+     static_cast of the form static_cast<T>(e) if the declaration T\n+     t(e);\" is well-formed, for some invented temporary variable\n+     t.  */\n+  result = perform_direct_initialization_if_possible (type, expr);\n+  if (result)\n+    return result;\n   \n-  intype = TREE_TYPE (expr);\n+  /* [expr.static.cast]\n \n-  /* FIXME handle casting to array type.  */\n+     Any expression can be explicitly converted to type cv void.  */\n+  if (TREE_CODE (type) == VOID_TYPE)\n+    return convert_to_void (expr, /*implicit=*/NULL);\n \n-  ok = 0;\n-  if (IS_AGGR_TYPE (intype)\n-      ? can_convert_arg (type, intype, expr)\n-      : can_convert_arg (strip_all_pointer_quals (type),\n-                         strip_all_pointer_quals (intype), expr))\n-    /* This is a standard conversion.  */\n-    ok = 1;\n-  else if (TYPE_PTROB_P (type) && TYPE_PTROB_P (intype))\n-    {\n-      /* They're pointers to objects. They must be aggregates that\n-         are related non-virtually.  */\n-      base_kind kind;\n-      \n-      if (IS_AGGR_TYPE (TREE_TYPE (type)) && IS_AGGR_TYPE (TREE_TYPE (intype))\n-\t  && lookup_base (TREE_TYPE (type), TREE_TYPE (intype),\n-\t\t\t  ba_ignore | ba_quiet, &kind)\n-\t  && kind != bk_via_virtual)\n-\tok = 1;\n-    }\n-  else if (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n-    {\n-      /* They're pointers to members. The pointed to objects must be\n-\t the same (ignoring CV qualifiers), and the containing classes\n-\t must be related non-virtually.  */\n-      base_kind kind;\n-      \n-      if (same_type_p\n-\t  (strip_all_pointer_quals (TREE_TYPE (TREE_TYPE (type))),\n-\t   strip_all_pointer_quals (TREE_TYPE (TREE_TYPE (intype))))\n- \t  && (lookup_base (TYPE_OFFSET_BASETYPE (TREE_TYPE (intype)),\n-\t\t\t   TYPE_OFFSET_BASETYPE (TREE_TYPE (type)),\n-\t\t\t   ba_ignore | ba_quiet, &kind))\n- \t  && kind != bk_via_virtual)\n-  \tok = 1;\n-    }\n-  else if (TREE_CODE (intype) != BOOLEAN_TYPE\n-\t   && TREE_CODE (type) != ARRAY_TYPE\n-\t   && TREE_CODE (type) != FUNCTION_TYPE\n-\t   && can_convert (intype, strip_all_pointer_quals (type)))\n-    ok = 1;\n-  else if (TREE_CODE (intype) == ENUMERAL_TYPE\n-           && TREE_CODE (type) == ENUMERAL_TYPE)\n-    /* DR 128: \"A value of integral _or enumeration_ type can be explicitly\n-       converted to an enumeration type.\"\n-       The integral to enumeration will be accepted by the previous clause.\n-       We need to explicitly check for enumeration to enumeration.  */\n-    ok = 1;\n+  /* [expr.static.cast]\n+\n+     An lvalue of type \"cv1 B\", where B is a class type, can be cast\n+     to type \"reference to cv2 D\", where D is a class derived (clause\n+     _class.derived_) from B, if a valid standard conversion from\n+     \"pointer to D\" to \"pointer to B\" exists (_conv.ptr_), cv2 is the\n+     same cv-qualification as, or greater cv-qualification than, cv1,\n+     and B is not a virtual base class of D.  */\n+  if (TREE_CODE (type) == REFERENCE_TYPE\n+      && CLASS_TYPE_P (TREE_TYPE (type))\n+      && CLASS_TYPE_P (intype)\n+      && real_non_cast_lvalue_p (expr)\n+      && DERIVED_FROM_P (intype, TREE_TYPE (type))\n+      && can_convert (build_pointer_type (TYPE_MAIN_VARIANT (intype)),\n+\t\t      build_pointer_type (TYPE_MAIN_VARIANT \n+\t\t\t\t\t  (TREE_TYPE (type))))\n+      && at_least_as_qualified_p (TREE_TYPE (type), intype))\n+    {\n+      /* At this point we have checked all of the conditions except\n+\t that B is not a virtual base class of D.  That will be\n+\t checked by build_base_path.  */\n+      tree base = lookup_base (TREE_TYPE (type), intype, ba_any, NULL);\n+\n+      /* Convert from B* to D*.  */\n+      expr = build_base_path (MINUS_EXPR, build_address (expr), \n+\t\t\t      base, /*nonnull=*/false);\n+      /* Convert the pointer to a reference.  */\n+      return build_nop (type, expr);\n+    }\n \n   /* [expr.static.cast]\n \n-     The static_cast operator shall not be used to cast away\n-     constness.  */\n-  if (ok && casts_away_constness (intype, type))\n-    {\n-      error (\"static_cast from type `%T' to type `%T' casts away constness\",\n-\t\tintype, type);\n-      return error_mark_node;\n+     The inverse of any standard conversion sequence (clause _conv_),\n+     other than the lvalue-to-rvalue (_conv.lval_), array-to-pointer\n+     (_conv.array_), function-to-pointer (_conv.func_), and boolean\n+     (_conv.bool_) conversions, can be performed explicitly using\n+     static_cast subject to the restriction that the explicit\n+     conversion does not cast away constness (_expr.const.cast_), and\n+     the following additional rules for specific cases:  */\n+  /* For reference, the conversions not excluded are: integral\n+     promotions, floating point promotion, integral conversions,\n+     floating point conversions, floating-integral conversions,\n+     pointer conversions, and pointer to member conversions.  */\n+  if ((ARITHMETIC_TYPE_P (type) && ARITHMETIC_TYPE_P (intype))\n+      /* DR 128\n+\n+         A value of integral _or enumeration_ type can be explicitly\n+\t converted to an enumeration type.  */\n+      || (INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n+\t  && INTEGRAL_OR_ENUMERATION_TYPE_P (intype)))\n+      /* Really, build_c_cast should defer to this function rather\n+\t than the other way around.  */\n+      return build_c_cast (type, expr);\n+  if (TYPE_PTR_P (type) && TYPE_PTR_P (intype)\n+      && CLASS_TYPE_P (TREE_TYPE (type))\n+      && CLASS_TYPE_P (TREE_TYPE (intype))\n+      && can_convert (build_pointer_type (TYPE_MAIN_VARIANT \n+\t\t\t\t\t  (TREE_TYPE (intype))), \n+\t\t      build_pointer_type (TYPE_MAIN_VARIANT \n+\t\t\t\t\t  (TREE_TYPE (type)))))\n+    {\n+      tree base;\n+\n+      check_for_casting_away_constness (intype, type);\n+      base = lookup_base (TREE_TYPE (type), TREE_TYPE (intype), \n+\t\t\t  ba_check | ba_quiet, NULL);\n+      return build_base_path (MINUS_EXPR, expr, base, /*nonnull=*/false);\n+    }\n+  if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n+      || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n+    {\n+      tree c1;\n+      tree c2;\n+      tree t1;\n+      tree t2;\n+\n+      c1 = TYPE_PTRMEM_CLASS_TYPE (intype);\n+      c2 = TYPE_PTRMEM_CLASS_TYPE (type);\n+\n+      if (TYPE_PTRMEM_P (type))\n+\t{\n+\t  t1 = (build_ptrmem_type \n+\t\t(c1,\n+\t\t TYPE_MAIN_VARIANT (TYPE_PTRMEM_POINTED_TO_TYPE (intype))));\n+\t  t2 = (build_ptrmem_type \n+\t\t(c2,\n+\t\t TYPE_MAIN_VARIANT (TYPE_PTRMEM_POINTED_TO_TYPE (type))));\n+\t}\n+      else\n+\t{\n+\t  t1 = intype;\n+\t  t2 = type;\n+\t}\n+      if (can_convert (t1, t2))\n+\t{\n+\t  check_for_casting_away_constness (intype, type);\n+\t  if (TYPE_PTRMEM_P (type))\n+\t    {\n+\t      if (TREE_CODE (expr) == PTRMEM_CST)\n+\t\texpr = cplus_expand_constant (expr);\n+\t      expr = cp_build_binary_op (PLUS_EXPR, \n+\t\t\t\t\t cp_convert (ptrdiff_type_node, expr),\n+\t\t\t\t\t get_delta_difference (c1, c2, \n+\t\t\t\t\t\t\t       /*force=*/1));\n+\t      return build_nop (type, expr);\n+\t    }\n+\t  else\n+\t    return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, \n+\t\t\t\t     /*force=*/1);\n+\t}\n     }\n+    \n+  /* [expr.static.cast]\n \n-  if (ok)\n-    return build_c_cast (type, expr);\n+     An rvalue of type \"pointer to cv void\" can be explicitly\n+     converted to a pointer to object type.  A value of type pointer\n+     to object converted to \"pointer to cv void\" and back to the\n+     original pointer type will have its original value.  */\n+  if (TREE_CODE (intype) == POINTER_TYPE \n+      && VOID_TYPE_P (TREE_TYPE (intype))\n+      && TYPE_PTROB_P (type))\n+    {\n+      check_for_casting_away_constness (intype, type);\n+      return build_nop (type, expr);\n+    }\n \n   error (\"invalid static_cast from type `%T' to type `%T'\", intype, type);\n   return error_mark_node;"}, {"sha": "8ae01588818711def0fc25c5294822042ae227d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3fe18f1d4722d2cc202978537ec28ba3668e5cc8", "patch": "@@ -1,3 +1,8 @@\n+2003-06-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/10931\n+\t* g++.dg/expr/static_cast1.C: New test.\n+\t\n 2003-06-25  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* gcc.dg/20030625-1.c: New test."}, {"sha": "f1d88bff3635d01288c7865a4d18dac7ffb93b1d", "filename": "gcc/testsuite/g++.dg/expr/static_cast1.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fstatic_cast1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe18f1d4722d2cc202978537ec28ba3668e5cc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fstatic_cast1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fstatic_cast1.C?ref=3fe18f1d4722d2cc202978537ec28ba3668e5cc8", "patch": "@@ -0,0 +1,5 @@\n+void foo(int x)\n+{\n+    static_cast<const unsigned int&>(x);\n+}\n+"}]}