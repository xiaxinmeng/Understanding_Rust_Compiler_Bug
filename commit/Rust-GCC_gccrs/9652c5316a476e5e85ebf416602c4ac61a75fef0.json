{"sha": "9652c5316a476e5e85ebf416602c4ac61a75fef0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY1MmM1MzE2YTQ3NmU1ZTg1ZWJmNDE2NjAyYzRhYzYxYTc1ZmVmMA==", "commit": {"author": {"name": "Roman Zippel", "email": "zippel@linux-m68k.org", "date": "2004-08-06T07:14:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-06T07:14:56Z"}, "message": "m68k.c (post_inc_operand,pre_dec_operand): New.\n\n        * config/m68k/m68k.c (post_inc_operand,pre_dec_operand): New.\n        * config/m68k/m68k.h (PREDICATE_CODES): add post_inc_operand,\n        pre_dec_operand.\n        * config/m68k/m68k.md (zero_extend*2): delay the splitting of the\n        pattern until reload is finished to allow better code generation\n        and split them completely into separate instrunctions.\n        (*andsi3_split): New pattern.\n\nFrom-SVN: r85631", "tree": {"sha": "7f79d73b2213c45dae68d04784ca43a1df49250f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f79d73b2213c45dae68d04784ca43a1df49250f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9652c5316a476e5e85ebf416602c4ac61a75fef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9652c5316a476e5e85ebf416602c4ac61a75fef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9652c5316a476e5e85ebf416602c4ac61a75fef0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9652c5316a476e5e85ebf416602c4ac61a75fef0/comments", "author": null, "committer": null, "parents": [{"sha": "3589b69e2dcc9e2adecc779679dd8aff97b60874", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3589b69e2dcc9e2adecc779679dd8aff97b60874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3589b69e2dcc9e2adecc779679dd8aff97b60874"}], "stats": {"total": 357, "additions": 154, "deletions": 203}, "files": [{"sha": "b35bb6a8367a8c2de48b28b13ba85ac6d73c5f47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9652c5316a476e5e85ebf416602c4ac61a75fef0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9652c5316a476e5e85ebf416602c4ac61a75fef0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9652c5316a476e5e85ebf416602c4ac61a75fef0", "patch": "@@ -1,3 +1,13 @@\n+2004-08-06  Roman Zippel  <zippel@linux-m68k.org>\n+ \n+        * config/m68k/m68k.c (post_inc_operand,pre_dec_operand): New.\n+        * config/m68k/m68k.h (PREDICATE_CODES): add post_inc_operand,\n+        pre_dec_operand.\n+        * config/m68k/m68k.md (zero_extend*2): delay the splitting of the\n+        pattern until reload is finished to allow better code generation\n+        and split them completely into separate instrunctions.\n+        (*andsi3_split): New pattern.\n+\n 2004-08-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tree.c (handle_dll_attribute): Move here from i383/winnt.c."}, {"sha": "e44f490c5a6c4332d7ab409fdaf4afc843d98c25", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9652c5316a476e5e85ebf416602c4ac61a75fef0/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9652c5316a476e5e85ebf416602c4ac61a75fef0/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=9652c5316a476e5e85ebf416602c4ac61a75fef0", "patch": "@@ -3185,6 +3185,18 @@ memory_src_operand (rtx op, enum machine_mode mode)\n   return memory_operand (op, mode);\n }\n \n+int\n+post_inc_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return MEM_P (op) && GET_CODE (XEXP (op, 0)) == POST_INC;\n+}\n+\n+int\n+pre_dec_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return MEM_P (op) && GET_CODE (XEXP (op, 0)) == PRE_DEC;\n+}\n+\n /* Predicate that accepts only a pc-relative address.  This is needed\n    because pc-relative addresses don't satisfy the predicate\n    \"general_src_operand\".  */"}, {"sha": "6af7116f78b37218e09ddc33da314dabea913d46", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9652c5316a476e5e85ebf416602c4ac61a75fef0/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9652c5316a476e5e85ebf416602c4ac61a75fef0/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=9652c5316a476e5e85ebf416602c4ac61a75fef0", "patch": "@@ -1271,4 +1271,6 @@ extern int m68k_last_compare_had_fp_operands;\n   {\"valid_dbcc_comparison_p\", {EQ, NE, GTU, LTU, GEU, LEU,\t\t\\\n \t\t\t       GT, LT, GE, LE}},\t\t\t\\\n   {\"extend_operator\", {SIGN_EXTEND, ZERO_EXTEND}},\t\t\t\\\n-  {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\n+  {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n+  {\"post_inc_operand\", {MEM}},\t\t\t\t\t\t\\\n+  {\"pre_dec_operand\", {MEM}},"}, {"sha": "57ddd4a78f32aeb24984cf4c8cb94df37757476f", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 129, "deletions": 202, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9652c5316a476e5e85ebf416602c4ac61a75fef0/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9652c5316a476e5e85ebf416602c4ac61a75fef0/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=9652c5316a476e5e85ebf416602c4ac61a75fef0", "patch": "@@ -1136,236 +1136,153 @@\n \f\n ;; zero extension instructions\n \n-(define_insn \"zero_extendqidi2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&d\")\n-\t(zero_extend:DI (match_operand:QI 1 \"general_operand\" \"dm\")))]\n+;; two special patterns to match various post_inc/pre_dec patterns\n+(define_insn_and_split \"*zero_extend_inc\"\n+  [(set (match_operand 0 \"post_inc_operand\" \"\")\n+\t(zero_extend (match_operand 1 \"register_operand\" \"\")))]\n+  \"GET_MODE_CLASS (GET_MODE (operands[0])) == MODE_INT &&\n+   GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT &&\n+   GET_MODE_SIZE (GET_MODE (operands[0])) == GET_MODE_SIZE (GET_MODE (operands[1])) * 2\"\n+  \"#\"\n+  \"\"\n+  [(set (match_dup 0)\n+\t(const_int 0))\n+   (set (match_dup 0)\n+\t(match_dup 1))]\n+{\n+  operands[0] = adjust_address (operands[0], GET_MODE (operands[1]), 0);\n+})\n+\n+(define_insn_and_split \"*zero_extend_dec\"\n+  [(set (match_operand 0 \"pre_dec_operand\" \"\")\n+\t(zero_extend (match_operand 1 \"register_operand\" \"\")))]\n+  \"(GET_MODE (operands[0]) != HImode || XEXP (XEXP (operands[0], 0), 0) != stack_pointer_rtx) &&\n+   GET_MODE_CLASS (GET_MODE (operands[0])) == MODE_INT &&\n+   GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT &&\n+   GET_MODE_SIZE (GET_MODE (operands[0])) == GET_MODE_SIZE (GET_MODE (operands[1])) * 2\"\n+  \"#\"\n   \"\"\n+  [(set (match_dup 0)\n+\t(match_dup 1))\n+   (set (match_dup 0)\n+\t(const_int 0))]\n {\n-  CC_STATUS_INIT;\n-  operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  return \"moveq #0,%0\\;moveq #0,%2\\;move%.b %1,%2\";\n+  operands[0] = adjust_address (operands[0], GET_MODE (operands[1]), 0);\n })\n \n-(define_insn \"zero_extendhidi2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&d\")\n-\t(zero_extend:DI (match_operand:HI 1 \"general_operand\" \"rm\")))]\n+(define_insn_and_split \"zero_extendqidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI (match_operand:QI 1 \"nonimmediate_src_operand\" \"\")))]\n+  \"\"\n+  \"#\"\n   \"\"\n+  [(set (match_dup 2)\n+\t(zero_extend:SI (match_dup 1)))\n+   (set (match_dup 3)\n+\t(const_int 0))]\n {\n-  CC_STATUS_INIT;\n-  operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  return \"moveq #0,%0\\;moveq #0,%2\\;move%.w %1,%2\";\n+  operands[2] = gen_lowpart (SImode, operands[0]);\n+  operands[3] = gen_highpart (SImode, operands[0]);\n+})\n+\n+(define_insn_and_split \"zero_extendhidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI (match_operand:HI 1 \"nonimmediate_src_operand\" \"\")))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(set (match_dup 2)\n+\t(zero_extend:SI (match_dup 1)))\n+   (set (match_dup 3)\n+\t(const_int 0))]\n+{\n+  operands[2] = gen_lowpart (SImode, operands[0]);\n+  operands[3] = gen_highpart (SImode, operands[0]);\n })\n \n-;; this is the canonical form for (lshiftrt:DI x 32)\n (define_expand \"zero_extendsidi2\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-    (zero_extend:DI (match_operand:SI 1 \"general_operand\" \"\")))]\n+\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"*zero_extendsidi2_cf\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,m\")\n-    (zero_extend:DI (match_operand:SI 1 \"general_operand\" \"rm,r\")))]\n-  \"TARGET_COLDFIRE\"\n+(define_insn_and_split \"*zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_src_operand\" \"\")))]\n+  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n+  \"#\"\n+  \"\"\n+  [(set (match_dup 2)\n+\t(match_dup 1))\n+   (set (match_dup 3)\n+\t(const_int 0))]\n {\n-  CC_STATUS_INIT;\n-  if (GET_CODE (operands[0]) == REG)\n-    operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    return \"move%.l %1,%0\\;clr%.l %0\";\n-  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    return \"clr%.l %0\\;move%.l %1,%0\";\n-  else\n-    operands[2] = adjust_address (operands[0], SImode, 4);\n-  if (GET_CODE (operands[1]) != REG || GET_CODE (operands[2]) != REG\n-      || REGNO (operands[1]) != REGNO (operands[2]))\n-    output_asm_insn (\"move%.l %1,%2\", operands);\n-  if (ADDRESS_REG_P (operands[0]))\n-    return \"sub%.l %0,%0\";\n-  else\n-    return \"clr%.l %0\";\n+  operands[2] = gen_lowpart (SImode, operands[0]);\n+  operands[3] = gen_highpart (SImode, operands[0]);\n })\n \n-(define_insn \"*zero_extendsidi2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-    (zero_extend:DI (match_operand:SI 1 \"general_operand\" \"rm\")))]\n-  \"!TARGET_COLDFIRE\"\n-{\n-  CC_STATUS_INIT;\n-  if (GET_CODE (operands[0]) == REG)\n-    operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    return \"move%.l %1,%0\\;clr%.l %0\";\n-  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    return \"clr%.l %0\\;move%.l %1,%0\";\n-  else\n-    operands[2] = adjust_address (operands[0], SImode, 4);\n-  if (GET_CODE (operands[1]) != REG || GET_CODE (operands[2]) != REG\n-      || REGNO (operands[1]) != REGNO (operands[2]))\n-    output_asm_insn (\"move%.l %1,%2\", operands);\n-  if (ADDRESS_REG_P (operands[0]))\n-    return \"sub%.l %0,%0\";\n-  else\n-    return \"clr%.l %0\";\n-})\n+(define_insn \"*zero_extendhisi2_cf\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_src_operand\" \"rmS\")))]\n+  \"TARGET_CFV4\"\n+  \"mvz%.w %1,%0\")\n \n-(define_expand \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(const_int 0))\n-   (set (strict_low_part (match_dup 2))\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_src_operand\" \"rmS\")))]\n   \"\"\n-  \"\n-{\n-  operands[1] = make_safe_from (operands[1], operands[0]);\n-  operands[2] = gen_lowpart_SUBREG (HImode, operands[0]);\n-}\")\n+  \"#\")\n \n (define_expand \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(const_int 0))\n-   (set (strict_low_part (match_dup 2))\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = make_safe_from (operands[1], operands[0]);\n-  operands[2] = gen_lowpart_SUBREG (QImode, operands[0]);\n-}\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_src_operand\" \"\")))]\n+  \"!TARGET_COLDFIRE\"\n+  \"\")\n \n-(define_expand \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(const_int 0))\n-   (set (strict_low_part (match_dup 2))\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = make_safe_from (operands[1], operands[0]);\n-  operands[2] = gen_lowpart_SUBREG (QImode, operands[0]);\n-}\")\n-\f\n-;; Patterns to recognize zero-extend insns produced by the combiner.\n-;; We don't allow both operands in memory, because of aliasing problems.\n-;; Explicitly disallow two memory operands via the condition since reloading\n-;; of this case will result in worse code than the uncombined patterns.\n+(define_insn \"*zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_src_operand\" \"dmS\")))]\n+  \"!TARGET_COLDFIRE\"\n+  \"#\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=do<>,d<\")\n-\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_src_operand\" \"r,mS\")))]\n-  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n-{\n-  if (DATA_REG_P (operands[0]))\n-    {\n-      if (TARGET_CFV4)\n-        return \"mvz%.w %1,%0\";\n-      if (GET_CODE (operands[1]) == REG\n-\t  && REGNO (operands[0]) == REGNO (operands[1]))\n-\treturn \"and%.l #0xFFFF,%0\";\n-      if (reg_mentioned_p (operands[0], operands[1]))\n-        return \"move%.w %1,%0\\;and%.l #0xFFFF,%0\";\n-      return \"clr%.l %0\\;move%.w %1,%0\";\n-    }\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    return \"move%.w %1,%0\\;clr%.w %0\";\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    return \"clr%.w %0\\;move%.w %1,%0\";\n-  else\n-    {\n-      output_asm_insn (\"clr%.w %0\", operands);\n-      operands[0] = adjust_address (operands[0], HImode, 2);\n-      return \"move%.w %1,%0\";\n-    }\n-})\n+(define_insn \"*zero_extendqisi2_cfv4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_src_operand\" \"dmS\")))]\n+  \"TARGET_CFV4\"\n+  \"mvz%.b %1,%0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=do<>,d\")\n-\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_src_operand\" \"d,mS\")))]\n-  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_src_operand\" \"dmS\")))]\n+  \"\"\n+  \"#\")\n+\n+;; these two pattern split everything else which isn't matched by\n+;; something else above\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(zero_extend (match_operand 1 \"nonimmediate_src_operand\" \"\")))]\n+  \"!TARGET_CFV4 && reload_completed && reg_mentioned_p (operands[0], operands[1])\"\n+  [(set (strict_low_part (match_dup 2))\n+\t(match_dup 1))\n+   (set (match_dup 0)\n+\t(match_op_dup 4 [(match_dup 0) (match_dup 3)]))]\n {\n-  if (DATA_REG_P (operands[0]))\n-    {\n-      if (GET_CODE (operands[1]) == REG\n-\t  && REGNO (operands[0]) == REGNO (operands[1]))\n-\t{\n-\t  if (TARGET_CFV4)\n-\t    return \"mvz%.b %0,%0\";\t\n-\t  return (!TARGET_COLDFIRE ? \"and%.w #0xFF,%0\" : \"and%.l #0xFF,%0\");\n-\t}\n-      if (reg_mentioned_p (operands[0], operands[1]))\n-        {\n-\t  if (TARGET_CFV4)\n-\t    return \"mvz%.b %1,%0\";\t\n-\t  return (!TARGET_COLDFIRE ? \"move%.b %1,%0\\;and%.w #0xFF,%0\" \n-\t\t\t       : \"move%.b %1,%0\\;and%.l #0xFF,%0\");\n-\t}\n-      return \"clr%.w %0\\;move%.b %1,%0\";\n-    }\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    {\n-      if (REGNO (XEXP (XEXP (operands[0], 0), 0))\n-\t  == STACK_POINTER_REGNUM)\n-\t{\n-\t  output_asm_insn (\"clr%.w %-\", operands);\n-\t  operands[0] = gen_rtx_MEM (GET_MODE (operands[0]),\n-\t\t\t\t     plus_constant (stack_pointer_rtx, 1));\n-\t  return \"move%.b %1,%0\";\n-\t}\n-      else\n-\treturn \"move%.b %1,%0\\;clr%.b %0\";\n-    }\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    return \"clr%.b %0\\;move%.b %1,%0\";\n-  else\n-    {\n-      output_asm_insn (\"clr%.b %0\", operands);\n-      operands[0] = adjust_address (operands[0], QImode, 1);\n-      return \"move%.b %1,%0\";\n-    }\n+  operands[2] = gen_lowpart (GET_MODE (operands[1]), operands[0]);\n+  operands[3] = GEN_INT (GET_MODE_MASK (GET_MODE (operands[1])));\n+  operands[4] = gen_rtx_AND (GET_MODE (operands[0]), operands[0], operands[3]);\n })\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=do<>,d\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_src_operand\" \"d,mS\")))]\n-  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(zero_extend (match_operand 1 \"nonimmediate_src_operand\" \"\")))]\n+  \"!TARGET_CFV4 && reload_completed\"\n+  [(set (match_dup 0)\n+\t(const_int 0))\n+   (set (strict_low_part (match_dup 2))\n+\t(match_dup 1))]\n {\n-  if (DATA_REG_P (operands[0]))\n-    {\n-      if (TARGET_CFV4)\n-        return \"mvz%.b %1,%0\";\n-      if (GET_CODE (operands[1]) == REG\n-\t  && REGNO (operands[0]) == REGNO (operands[1]))\n-\treturn \"and%.l #0xFF,%0\";\n-      if (reg_mentioned_p (operands[0], operands[1]))\n-        return \"move%.b %1,%0\\;and%.l #0xFF,%0\";\n-      return \"clr%.l %0\\;move%.b %1,%0\";\n-    }\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    {\n-      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-      return MOTOROLA ?\n-\t\"clr%.l -(%0)\\;move%.b %1,(3,%0)\" :\n-\t\"clrl %0@-\\;moveb %1,%0@(3)\";\n-    }\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    {\n-      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-      return MOTOROLA ?\n-\t\"clr%.l (%0)+\\;move%.b %1,(-1,%0)\" :\n-\t\"clrl %0@+\\;moveb %1,%0@(-1)\";\n-    }\n-  else\n-    {\n-      output_asm_insn (\"clr%.l %0\", operands);\n-      operands[0] = adjust_address (operands[0], QImode, 3);\n-      return \"move%.b %1,%0\";\n-    }\n+  operands[2] = gen_lowpart (GET_MODE (operands[1]), operands[0]);\n })\n \f\n ;; sign extension instructions\n@@ -3131,6 +3048,16 @@\n   \"\"\n   \"\")\n \n+;; produced by split operations after reload finished\n+(define_insn \"*andsi3_split\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"const_int_operand\" \"i\")))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+{\n+  return output_andsi3 (operands);\n+})\n+\n (define_insn \"andsi3_internal\"\n   [(set (match_operand:SI 0 \"not_sp_operand\" \"=m,d\")\n \t(and:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")"}]}