{"sha": "80007176a59e43c10d3c6db1f42804863771a0ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAwMDcxNzZhNTllNDNjMTBkM2M2ZGIxZjQyODA0ODYzNzcxYTBjZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-22T10:35:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-22T10:35:28Z"}, "message": "[multiple changes]\n\n2016-06-22  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* lib-xref-spark_specific.adb, checks.adb, sem_ch13.adb: Minor\n\treformatting.\n\t* exp_ch7.adb: Minor typo fix.\n\t* lib.ads (Get_Top_Level_Code_Unit): Add comment.\n\n2016-06-22  Bob Duff  <duff@adacore.com>\n\n\t* s-tassta.adb (Task_Wrapper): Fix handling of Fall_Back_Handler\n\twrt independent tasks.\n\n2016-06-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_dim.adb (Analyze_Dimension): Propagate dimension for\n\texplicit_dereference nodes when they do not come from source,\n\tto handle correctly dimensional analysis on iterators over\n\tcontainers whose elements have declared dimensions.\n\nFrom-SVN: r237691", "tree": {"sha": "1ba93e25b52de304d7303fe6d4182f918c9493e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ba93e25b52de304d7303fe6d4182f918c9493e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80007176a59e43c10d3c6db1f42804863771a0ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80007176a59e43c10d3c6db1f42804863771a0ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80007176a59e43c10d3c6db1f42804863771a0ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80007176a59e43c10d3c6db1f42804863771a0ce/comments", "author": null, "committer": null, "parents": [{"sha": "7ffbef99665102871af334c1e6d2c8f1e77fd6b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffbef99665102871af334c1e6d2c8f1e77fd6b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ffbef99665102871af334c1e6d2c8f1e77fd6b7"}], "stats": {"total": 479, "additions": 260, "deletions": 219}, "files": [{"sha": "6d4bf1ed76d8aff13b637857b5dc6aef8f0bf955", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=80007176a59e43c10d3c6db1f42804863771a0ce", "patch": "@@ -1,3 +1,22 @@\n+2016-06-22  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* lib-xref-spark_specific.adb, checks.adb, sem_ch13.adb: Minor\n+\treformatting.\n+\t* exp_ch7.adb: Minor typo fix.\n+\t* lib.ads (Get_Top_Level_Code_Unit): Add comment.\n+\n+2016-06-22  Bob Duff  <duff@adacore.com>\n+\n+\t* s-tassta.adb (Task_Wrapper): Fix handling of Fall_Back_Handler\n+\twrt independent tasks.\n+\n+2016-06-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_dim.adb (Analyze_Dimension): Propagate dimension for\n+\texplicit_dereference nodes when they do not come from source,\n+\tto handle correctly dimensional analysis on iterators over\n+\tcontainers whose elements have declared dimensions.\n+\n 2016-06-22  Arnaud Charlet  <charlet@adacore.com>\n \n \t* spark_xrefs.ads (Scope_Num): type refined to positive integers."}, {"sha": "cde455f7b5114a386b5362d2b43725352c2b231c", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=80007176a59e43c10d3c6db1f42804863771a0ce", "patch": "@@ -635,17 +635,15 @@ package body Checks is\n    procedure Apply_Address_Clause_Check (E : Entity_Id; N : Node_Id) is\n       pragma Assert (Nkind (N) = N_Freeze_Entity);\n \n-      AC   : constant Node_Id    := Address_Clause (E);\n-      Loc  : constant Source_Ptr := Sloc (AC);\n-      Typ  : constant Entity_Id  := Etype (E);\n+      AC  : constant Node_Id    := Address_Clause (E);\n+      Loc : constant Source_Ptr := Sloc (AC);\n+      Typ : constant Entity_Id  := Etype (E);\n \n       Expr : Node_Id;\n       --  Address expression (not necessarily the same as Aexp, for example\n       --  when Aexp is a reference to a constant, in which case Expr gets\n       --  reset to reference the value expression of the constant).\n \n-   --  Start of processing for Apply_Address_Clause_Check\n-\n    begin\n       --  See if alignment check needed. Note that we never need a check if the\n       --  maximum alignment is one, since the check will always succeed.\n@@ -679,8 +677,8 @@ package body Checks is\n             AL : Uint := Alignment (Typ);\n \n          begin\n-            --  The object alignment might be more restrictive than the\n-            --  type alignment.\n+            --  The object alignment might be more restrictive than the type\n+            --  alignment.\n \n             if Known_Alignment (E) then\n                AL := Alignment (E);\n@@ -718,9 +716,9 @@ package body Checks is\n       --  Generate a check to raise PE if alignment may be inappropriate\n \n       else\n-         --  If the original expression is a non-static constant, use the\n-         --  name of the constant itself rather than duplicating its\n-         --  defining expression, which was extracted above.\n+         --  If the original expression is a non-static constant, use the name\n+         --  of the constant itself rather than duplicating its initialization\n+         --  expression, which was extracted above.\n \n          --  Note: Expr is empty if the address-clause is applied to in-mode\n          --  actuals (allowed by 13.1(22)).\n@@ -729,8 +727,8 @@ package body Checks is\n            or else\n              (Is_Entity_Name (Expression (AC))\n                and then Ekind (Entity (Expression (AC))) = E_Constant\n-               and then Nkind (Parent (Entity (Expression (AC))))\n-                                 = N_Object_Declaration)\n+               and then Nkind (Parent (Entity (Expression (AC)))) =\n+                          N_Object_Declaration)\n          then\n             Expr := New_Copy_Tree (Expression (AC));\n          else\n@@ -745,17 +743,17 @@ package body Checks is\n            Make_Raise_Program_Error (Loc,\n              Condition =>\n                Make_Op_Ne (Loc,\n-                 Left_Opnd =>\n+                 Left_Opnd  =>\n                    Make_Op_Mod (Loc,\n-                     Left_Opnd =>\n+                     Left_Opnd  =>\n                        Unchecked_Convert_To\n                          (RTE (RE_Integer_Address), Expr),\n                      Right_Opnd =>\n                        Make_Attribute_Reference (Loc,\n                          Prefix         => New_Occurrence_Of (E, Loc),\n                          Attribute_Name => Name_Alignment)),\n                  Right_Opnd => Make_Integer_Literal (Loc, Uint_0)),\n-                       Reason    => PE_Misaligned_Address_Value));\n+             Reason    => PE_Misaligned_Address_Value));\n \n          Warning_Msg := No_Error_Msg;\n          Analyze (First (Actions (N)), Suppress => All_Checks);\n@@ -765,6 +763,7 @@ package body Checks is\n          --  No_Exception_Propagation).\n \n          if Warning_Msg /= No_Error_Msg then\n+\n             --  If the expression has a known at compile time value, then\n             --  once we know the alignment of the type, we can check if the\n             --  exception will be raised or not, and if not, we don't need\n@@ -773,19 +772,21 @@ package body Checks is\n             if Compile_Time_Known_Value (Expr) then\n                Alignment_Warnings.Append\n                  ((E => E, A => Expr_Value (Expr), W => Warning_Msg));\n-            else\n-               --  Add explanation of the warning generated by the check\n \n+            --  Add explanation of the warning generated by the check\n+\n+            else\n                Error_Msg_N\n-                 (\"\\address value may be incompatible with alignment \"\n-                  & \"of object?X?\", AC);\n+                 (\"\\address value may be incompatible with alignment of \"\n+                  & \"object?X?\", AC);\n             end if;\n          end if;\n \n          return;\n       end if;\n \n    exception\n+\n       --  If we have some missing run time component in configurable run time\n       --  mode then just skip the check (it is not required in any case).\n "}, {"sha": "f46f57ec321d0d0fbdb8bc4a3b90991be403eff6", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=80007176a59e43c10d3c6db1f42804863771a0ce", "patch": "@@ -4616,7 +4616,7 @@ package body Exp_Ch7 is\n       Set_Ghost_Mode_From_Entity (Work_Typ);\n \n       --  Emulate the environment of the invariant procedure by installing\n-      --  its scope and formal parameters. Note that this is not need, but\n+      --  its scope and formal parameters. Note that this is not needed, but\n       --  having the scope of the invariant procedure installed helps with\n       --  the detection of invariant-related errors.\n "}, {"sha": "28b167cea5a75c1f48d2344c5f279ccfc7b9121b", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 199, "deletions": 193, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=80007176a59e43c10d3c6db1f42804863771a0ce", "patch": "@@ -54,9 +54,9 @@ package body SPARK_Specific is\n    --  True for each reference type used in SPARK\n \n    SPARK_References : constant array (Character) of Boolean :=\n-     ('m' => True,\n-      'r' => True,\n-      's' => True,\n+     ('m'    => True,\n+      'r'    => True,\n+      's'    => True,\n       others => False);\n \n    type Entity_Hashed_Range is range 0 .. 255;\n@@ -102,9 +102,9 @@ package body SPARK_Specific is\n    generic\n       with procedure Process (N : Node_Id) is <>;\n    procedure Traverse_Compilation_Unit (CU : Node_Id; Inside_Stubs : Boolean);\n-   --  Call Process on all declarations in compilation unit CU. If\n-   --  Inside_Stubs is True, then the body of stubs is also traversed.\n-   --  Generic declarations are ignored.\n+   --  Call Process on all declarations within compilation unit CU. If flag\n+   --  Inside_Stubs is True, then the body of stubs is also traversed. Generic\n+   --  declarations are ignored.\n \n    --------------------\n    -- Add_SPARK_File --\n@@ -114,9 +114,6 @@ package body SPARK_Specific is\n       File : constant Source_File_Index := Source_Index (Uspec);\n       From : constant Scope_Index       := SPARK_Scope_Table.Last + 1;\n \n-      File_Name      : String_Ptr;\n-      Unit_File_Name : String_Ptr;\n-\n       Scope_Id : Pos := 1;\n \n       procedure Add_SPARK_Scope (N : Node_Id);\n@@ -147,49 +144,46 @@ package body SPARK_Specific is\n          end if;\n \n          case Ekind (E) is\n-         when E_Entry\n-            | E_Entry_Family\n-            | E_Generic_Function\n-            | E_Generic_Package\n-            | E_Generic_Procedure\n-            | E_Package\n-            | E_Protected_Type\n-            | E_Task_Type\n-            =>\n-            Typ := Xref_Entity_Letters (Ekind (E));\n-\n-         when E_Function\n-            | E_Procedure\n-            =>\n-            --  In SPARK we need to distinguish protected functions and\n-            --  procedures from ordinary subprograms, but there are no special\n-            --  Xref letters for them. Since this distiction is only needed to\n-            --  detect protected calls, we pretend that such calls are entry\n-            --  calls.\n-\n-            if Ekind (Scope (E)) = E_Protected_Type then\n-               Typ := Xref_Entity_Letters (E_Entry);\n-            else\n+            when E_Entry             |\n+                 E_Entry_Family      |\n+                 E_Generic_Function  |\n+                 E_Generic_Package   |\n+                 E_Generic_Procedure |\n+                 E_Package           |\n+                 E_Protected_Type    |\n+                 E_Task_Type         =>\n                Typ := Xref_Entity_Letters (Ekind (E));\n-            end if;\n \n-         when E_Package_Body\n-            | E_Protected_Body\n-            | E_Subprogram_Body\n-            | E_Task_Body\n-            =>\n-            Typ := Xref_Entity_Letters (Ekind (Unique_Entity (E)));\n+            when E_Function | E_Procedure =>\n \n-         when E_Void =>\n+               --  In SPARK we need to distinguish protected functions and\n+               --  procedures from ordinary subprograms, but there are no\n+               --  special Xref letters for them. Since this distiction is\n+               --  only needed to detect protected calls, we pretend that\n+               --  such calls are entry calls.\n \n-            --  Compilation of prj-attr.adb with -gnatn creates a node with\n-            --  entity E_Void for the package defined at a-charac.ads16:13.\n-            --  ??? TBD\n+               if Ekind (Scope (E)) = E_Protected_Type then\n+                  Typ := Xref_Entity_Letters (E_Entry);\n+               else\n+                  Typ := Xref_Entity_Letters (Ekind (E));\n+               end if;\n \n-            return;\n+            when E_Package_Body    |\n+                 E_Protected_Body  |\n+                 E_Subprogram_Body |\n+                 E_Task_Body       =>\n+               Typ := Xref_Entity_Letters (Ekind (Unique_Entity (E)));\n+\n+            when E_Void =>\n+\n+               --  Compilation of prj-attr.adb with -gnatn creates a node with\n+               --  entity E_Void for the package defined at a-charac.ads16:13.\n+               --  ??? TBD\n \n-         when others =>\n-            raise Program_Error;\n+               return;\n+\n+            when others =>\n+               raise Program_Error;\n          end case;\n \n          --  File_Num and Scope_Num are filled later. From_Xref and To_Xref\n@@ -218,24 +212,32 @@ package body SPARK_Specific is\n \n       procedure Detect_And_Add_SPARK_Scope (N : Node_Id) is\n       begin\n-         if Nkind_In (N, N_Entry_Body,             --  entries\n-                      N_Entry_Declaration)\n-           or else\n-             Nkind_In (N, N_Package_Body,           --  packages\n-                       N_Package_Body_Stub,\n-                       N_Package_Declaration)\n-           or else\n-             Nkind_In (N, N_Protected_Body,         --  protected objects\n-                       N_Protected_Body_Stub,\n-                       N_Protected_Type_Declaration)\n-           or else\n-             Nkind_In (N, N_Subprogram_Body,        --  subprograms\n-                       N_Subprogram_Body_Stub,\n-                       N_Subprogram_Declaration)\n-           or else\n-             Nkind_In (N, N_Task_Body,              --  tasks\n-                       N_Task_Body_Stub,\n-                       N_Task_Type_Declaration)\n+         --  Entries\n+\n+         if Nkind_In (N, N_Entry_Body, N_Entry_Declaration)\n+\n+           --  Packages\n+\n+           or else Nkind_In (N, N_Package_Body,\n+                                N_Package_Body_Stub,\n+                                N_Package_Declaration)\n+           --  Protected units\n+\n+           or else Nkind_In (N, N_Protected_Body,\n+                                N_Protected_Body_Stub,\n+                                N_Protected_Type_Declaration)\n+\n+           --  Subprograms\n+\n+           or else Nkind_In (N, N_Subprogram_Body,\n+                                N_Subprogram_Body_Stub,\n+                                N_Subprogram_Declaration)\n+\n+           --  Task units\n+\n+           or else Nkind_In (N, N_Task_Body,\n+                                N_Task_Body_Stub,\n+                                N_Task_Type_Declaration)\n          then\n             Add_SPARK_Scope (N);\n          end if;\n@@ -244,6 +246,11 @@ package body SPARK_Specific is\n       procedure Traverse_Scopes is new\n         Traverse_Compilation_Unit (Detect_And_Add_SPARK_Scope);\n \n+      --  Local variables\n+\n+      File_Name      : String_Ptr;\n+      Unit_File_Name : String_Ptr;\n+\n    --  Start of processing for Add_SPARK_File\n \n    begin\n@@ -307,6 +314,9 @@ package body SPARK_Specific is\n       function Get_Entity_Type (E : Entity_Id) return Character;\n       --  Return a character representing the type of entity\n \n+      function Get_Scope_Num (N : Entity_Id) return Nat;\n+      --  Return the scope number associated to entity N\n+\n       function Is_Constant_Object_Without_Variable_Input\n         (E : Entity_Id) return Boolean;\n       --  Return True if E is known to have no variable input, as defined in\n@@ -333,6 +343,9 @@ package body SPARK_Specific is\n       procedure Move (From : Natural; To : Natural);\n       --  Move procedure for Sort call\n \n+      procedure Set_Scope_Num (N : Entity_Id; Num : Nat);\n+      --  Associate entity N to scope number Num\n+\n       procedure Update_Scope_Range\n         (S    : Scope_Index;\n          From : Xref_Index;\n@@ -341,12 +354,6 @@ package body SPARK_Specific is\n \n       package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n \n-      function Get_Scope_Num (N : Entity_Id) return Nat;\n-      --  Return the scope number associated to entity N\n-\n-      procedure Set_Scope_Num (N : Entity_Id; Num : Nat);\n-      --  Associate entity N to scope number Num\n-\n       No_Scope : constant Nat := 0;\n       --  Initial scope counter\n \n@@ -551,7 +558,7 @@ package body SPARK_Specific is\n       -- Lt --\n       --------\n \n-      function Lt (Op1, Op2 : Natural) return Boolean is\n+      function Lt (Op1 : Natural; Op2 : Natural) return Boolean is\n          T1 : constant Xref_Entry := Xrefs.Table (Rnums (Nat (Op1)));\n          T2 : constant Xref_Entry := Xrefs.Table (Rnums (Nat (Op2)));\n \n@@ -767,9 +774,7 @@ package body SPARK_Specific is\n          Nrefs     := 1;\n \n          for Index in 2 .. Ref_Count loop\n-            if Xrefs.Table (Rnums (Index)) /=\n-               Xrefs.Table (Rnums (Nrefs))\n-            then\n+            if Xrefs.Table (Rnums (Index)) /= Xrefs.Table (Rnums (Nrefs)) then\n                Nrefs := Nrefs + 1;\n                Rnums (Nrefs) := Rnums (Index);\n             end if;\n@@ -900,15 +905,17 @@ package body SPARK_Specific is\n      (Sdep_Table : Unit_Ref_Table;\n       Num_Sdep   : Nat)\n    is\n-      Sdep, Sdep_Next : Pos;\n+      Sdep      : Pos;\n+      Sdep_Next : Pos;\n       --  Index of the current and next source dependency\n \n       Sdep_File : Pos;\n       --  Index of the file to which the scopes need to be assigned; for\n       --  library-level instances of generic units this points to the unit\n       --  of the body, because this is where references are assigned to.\n \n-      Uspec, Ubody : Unit_Number_Type;\n+      Ubody : Unit_Number_Type;\n+      Uspec : Unit_Number_Type;\n       --  Unit numbers for the dependency spec and possibly its body (only in\n       --  the case of library-level instance of a generic package).\n \n@@ -936,20 +943,22 @@ package body SPARK_Specific is\n             declare\n                Cunit1 : Node_Id renames Cunit (Sdep_Table (Sdep));\n                Cunit2 : Node_Id renames Cunit (Sdep_Table (Sdep + 1));\n+\n             begin\n                --  Both Cunit point to compilation unit nodes\n-               pragma Assert (Nkind (Cunit1) = N_Compilation_Unit\n-                                and then\n-                              Nkind (Cunit2) = N_Compilation_Unit);\n+\n+               pragma Assert\n+                 (Nkind (Cunit1) = N_Compilation_Unit\n+                   and then Nkind (Cunit2) = N_Compilation_Unit);\n \n                --  Do not depend on the sorting order, which is based on\n                --  Unit_Name and for library-level instances of nested\n                --  generic-packages they are equal.\n \n                --  If declaration comes before the body\n+\n                if Nkind (Unit (Cunit1)) = N_Package_Declaration\n-                 and then\n-                  Nkind (Unit (Cunit2)) = N_Package_Body\n+                 and then Nkind (Unit (Cunit2)) = N_Package_Body\n                then\n                   Uspec := Sdep_Table (Sdep);\n                   Ubody := Sdep_Table (Sdep + 1);\n@@ -959,8 +968,7 @@ package body SPARK_Specific is\n                --  If body comes before declaration\n \n                elsif Nkind (Unit (Cunit1)) = N_Package_Body\n-                       and then\n-                     Nkind (Unit (Cunit2)) = N_Package_Declaration\n+                 and then Nkind (Unit (Cunit2)) = N_Package_Declaration\n                then\n                   Uspec := Sdep_Table (Sdep + 1);\n                   Ubody := Sdep_Table (Sdep);\n@@ -970,18 +978,19 @@ package body SPARK_Specific is\n                --  Otherwise it is an error\n \n                else\n-\n                   raise Program_Error;\n                end if;\n \n                Sdep_Next := Sdep + 2;\n             end;\n+\n+         --  ??? otherwise?\n+\n          else\n             Uspec := Sdep_Table (Sdep);\n             Ubody := No_Unit;\n \n             Sdep_File := Sdep;\n-\n             Sdep_Next := Sdep + 1;\n          end if;\n \n@@ -1191,7 +1200,6 @@ package body SPARK_Specific is\n    --  Start of processing for Generate_Dereference\n \n    begin\n-\n       if Loc > No_Location then\n          Drefs.Increment_Last;\n \n@@ -1234,11 +1242,9 @@ package body SPARK_Specific is\n      (CU           : Node_Id;\n       Inside_Stubs : Boolean)\n    is\n-      Lu : Node_Id;\n-\n       procedure Traverse_Block                      (N : Node_Id);\n-      procedure Traverse_Declarations_And_HSS       (N : Node_Id);\n       procedure Traverse_Declaration_Or_Statement   (N : Node_Id);\n+      procedure Traverse_Declarations_And_HSS       (N : Node_Id);\n       procedure Traverse_Declarations_Or_Statements (L : List_Id);\n       procedure Traverse_Handled_Statement_Sequence (N : Node_Id);\n       procedure Traverse_Package_Body               (N : Node_Id);\n@@ -1260,142 +1266,137 @@ package body SPARK_Specific is\n       -- Traverse_Declaration_Or_Statement --\n       ---------------------------------------\n \n-      procedure Traverse_Declaration_Or_Statement (N : Node_Id)\n-      is\n+      procedure Traverse_Declaration_Or_Statement (N : Node_Id) is\n       begin\n          case Nkind (N) is\n-         when N_Package_Declaration =>\n-            Traverse_Visible_And_Private_Parts (Specification (N));\n+            when N_Package_Declaration =>\n+               Traverse_Visible_And_Private_Parts (Specification (N));\n \n-         when N_Package_Body =>\n-            if Ekind (Defining_Entity (N)) /= E_Generic_Package then\n-               Traverse_Package_Body (N);\n-            end if;\n+            when N_Package_Body =>\n+               if Ekind (Defining_Entity (N)) /= E_Generic_Package then\n+                  Traverse_Package_Body (N);\n+               end if;\n \n-         when N_Package_Body_Stub =>\n-            if Present (Library_Unit (N)) then\n-               declare\n-                  Body_N : constant Node_Id := Get_Body_From_Stub (N);\n-               begin\n-                  if Inside_Stubs\n-                    and then\n-                      Ekind (Defining_Entity (Body_N)) /= E_Generic_Package\n-                  then\n-                     Traverse_Package_Body (Body_N);\n-                  end if;\n-               end;\n-            end if;\n+            when N_Package_Body_Stub =>\n+               if Present (Library_Unit (N)) then\n+                  declare\n+                     Body_N : constant Node_Id := Get_Body_From_Stub (N);\n+                  begin\n+                     if Inside_Stubs\n+                       and then Ekind (Defining_Entity (Body_N)) /=\n+                                  E_Generic_Package\n+                     then\n+                        Traverse_Package_Body (Body_N);\n+                     end if;\n+                  end;\n+               end if;\n \n-         when N_Subprogram_Body =>\n-            if not Is_Generic_Subprogram (Defining_Entity (N)) then\n-               Traverse_Subprogram_Body (N);\n-            end if;\n+            when N_Subprogram_Body =>\n+               if not Is_Generic_Subprogram (Defining_Entity (N)) then\n+                  Traverse_Subprogram_Body (N);\n+               end if;\n \n-         when N_Entry_Body =>\n-            Traverse_Subprogram_Body (N);\n+            when N_Entry_Body =>\n+               Traverse_Subprogram_Body (N);\n \n-         when N_Subprogram_Body_Stub =>\n-            if Present (Library_Unit (N)) then\n-               declare\n-                  Body_N : constant Node_Id := Get_Body_From_Stub (N);\n-               begin\n-                  if Inside_Stubs\n-                    and then\n-                      not Is_Generic_Subprogram (Defining_Entity (Body_N))\n-                  then\n-                     Traverse_Subprogram_Body (Body_N);\n-                  end if;\n-               end;\n-            end if;\n+            when N_Subprogram_Body_Stub =>\n+               if Present (Library_Unit (N)) then\n+                  declare\n+                     Body_N : constant Node_Id := Get_Body_From_Stub (N);\n+                  begin\n+                     if Inside_Stubs\n+                       and then\n+                         not Is_Generic_Subprogram (Defining_Entity (Body_N))\n+                     then\n+                        Traverse_Subprogram_Body (Body_N);\n+                     end if;\n+                  end;\n+               end if;\n \n-         when N_Protected_Body =>\n-            Traverse_Protected_Body (N);\n+            when N_Protected_Body =>\n+               Traverse_Protected_Body (N);\n \n-         when N_Protected_Body_Stub =>\n-            if Present (Library_Unit (N)) then\n-               if Inside_Stubs then\n+            when N_Protected_Body_Stub =>\n+               if Present (Library_Unit (N)) and then Inside_Stubs then\n                   Traverse_Protected_Body (Get_Body_From_Stub (N));\n                end if;\n-            end if;\n \n-         when N_Protected_Type_Declaration | N_Single_Protected_Declaration =>\n-            Traverse_Visible_And_Private_Parts (Protected_Definition (N));\n+            when N_Protected_Type_Declaration   |\n+                 N_Single_Protected_Declaration =>\n+               Traverse_Visible_And_Private_Parts (Protected_Definition (N));\n \n-         when N_Task_Definition =>\n-            Traverse_Visible_And_Private_Parts (N);\n+            when N_Task_Definition =>\n+               Traverse_Visible_And_Private_Parts (N);\n \n-         when N_Task_Body =>\n-            Traverse_Task_Body (N);\n+            when N_Task_Body =>\n+               Traverse_Task_Body (N);\n \n-         when N_Task_Body_Stub =>\n-            if Present (Library_Unit (N)) then\n-               if Inside_Stubs then\n+            when N_Task_Body_Stub =>\n+               if Present (Library_Unit (N)) and then Inside_Stubs then\n                   Traverse_Task_Body (Get_Body_From_Stub (N));\n                end if;\n-            end if;\n \n-         when N_Block_Statement =>\n-            Traverse_Block (N);\n+            when N_Block_Statement =>\n+               Traverse_Block (N);\n \n-         when N_If_Statement =>\n+            when N_If_Statement =>\n \n-            --  Traverse the statements in the THEN part\n+               --  Traverse the statements in the THEN part\n \n-            Traverse_Declarations_Or_Statements (Then_Statements (N));\n+               Traverse_Declarations_Or_Statements (Then_Statements (N));\n \n-            --  Loop through ELSIF parts if present\n+               --  Loop through ELSIF parts if present\n \n-            if Present (Elsif_Parts (N)) then\n-               declare\n-                  Elif : Node_Id := First (Elsif_Parts (N));\n+               if Present (Elsif_Parts (N)) then\n+                  declare\n+                     Elif : Node_Id := First (Elsif_Parts (N));\n \n-               begin\n-                  while Present (Elif) loop\n-                     Traverse_Declarations_Or_Statements\n-                       (Then_Statements (Elif));\n-                     Next (Elif);\n-                  end loop;\n-               end;\n-            end if;\n+                  begin\n+                     while Present (Elif) loop\n+                        Traverse_Declarations_Or_Statements\n+                          (Then_Statements (Elif));\n+                        Next (Elif);\n+                     end loop;\n+                  end;\n+               end if;\n \n-            --  Finally traverse the ELSE statements if present\n+               --  Finally traverse the ELSE statements if present\n \n-            Traverse_Declarations_Or_Statements (Else_Statements (N));\n+               Traverse_Declarations_Or_Statements (Else_Statements (N));\n \n-         when N_Case_Statement =>\n+            when N_Case_Statement =>\n \n-            --  Process case branches\n+               --  Process case branches\n \n-            declare\n-               Alt : Node_Id;\n-            begin\n-               Alt := First (Alternatives (N));\n-               while Present (Alt) loop\n-                  Traverse_Declarations_Or_Statements (Statements (Alt));\n-                  Next (Alt);\n-               end loop;\n-            end;\n+               declare\n+                  Alt : Node_Id;\n+               begin\n+                  Alt := First (Alternatives (N));\n+                  while Present (Alt) loop\n+                     Traverse_Declarations_Or_Statements (Statements (Alt));\n+                     Next (Alt);\n+                  end loop;\n+               end;\n \n-         when N_Extended_Return_Statement =>\n-            Traverse_Handled_Statement_Sequence\n-              (Handled_Statement_Sequence (N));\n+            when N_Extended_Return_Statement =>\n+               Traverse_Handled_Statement_Sequence\n+                 (Handled_Statement_Sequence (N));\n \n-         when N_Loop_Statement =>\n-            Traverse_Declarations_Or_Statements (Statements (N));\n+            when N_Loop_Statement =>\n+               Traverse_Declarations_Or_Statements (Statements (N));\n \n-            --  Generic declarations are ignored\n+               --  Generic declarations are ignored\n \n-         when others =>\n-            null;\n+            when others =>\n+               null;\n          end case;\n       end Traverse_Declaration_Or_Statement;\n \n       -----------------------------------\n       -- Traverse_Declarations_And_HSS --\n       -----------------------------------\n \n-      procedure Traverse_Declarations_And_HSS (N : Node_Id)\n-      is\n+      procedure Traverse_Declarations_And_HSS (N : Node_Id) is\n       begin\n          Traverse_Declarations_Or_Statements (Declarations (N));\n          Traverse_Handled_Statement_Sequence (Handled_Statement_Sequence (N));\n@@ -1405,22 +1406,20 @@ package body SPARK_Specific is\n       -- Traverse_Declarations_Or_Statements --\n       -----------------------------------------\n \n-      procedure Traverse_Declarations_Or_Statements (L : List_Id)\n-      is\n+      procedure Traverse_Declarations_Or_Statements (L : List_Id) is\n          N : Node_Id;\n \n       begin\n          --  Loop through statements or declarations\n \n          N := First (L);\n          while Present (N) loop\n+\n             --  Call Process on all declarations\n \n             if Nkind (N) in N_Declaration\n-              or else\n-                Nkind (N) in N_Later_Decl_Item\n-              or else\n-                Nkind (N) = N_Entry_Body\n+              or else Nkind (N) in N_Later_Decl_Item\n+              or else Nkind (N) = N_Entry_Body\n             then\n                Process (N);\n             end if;\n@@ -1435,8 +1434,7 @@ package body SPARK_Specific is\n       -- Traverse_Handled_Statement_Sequence --\n       -----------------------------------------\n \n-      procedure Traverse_Handled_Statement_Sequence (N : Node_Id)\n-      is\n+      procedure Traverse_Handled_Statement_Sequence (N : Node_Id) is\n          Handler : Node_Id;\n \n       begin\n@@ -1483,12 +1481,20 @@ package body SPARK_Specific is\n       procedure Traverse_Task_Body (N : Node_Id) renames\n         Traverse_Declarations_And_HSS;\n \n+      ----------------------------------------\n+      -- Traverse_Visible_And_Private_Parts --\n+      ----------------------------------------\n+\n       procedure Traverse_Visible_And_Private_Parts (N : Node_Id) is\n       begin\n          Traverse_Declarations_Or_Statements (Visible_Declarations (N));\n          Traverse_Declarations_Or_Statements (Private_Declarations (N));\n       end Traverse_Visible_And_Private_Parts;\n \n+      --  Local variables\n+\n+      Lu : Node_Id;\n+\n    --  Start of processing for Traverse_Compilation_Unit\n \n    begin"}, {"sha": "c54e2ca180aba62ad56ffc29a31f4b28fbbe7956", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=80007176a59e43c10d3c6db1f42804863771a0ce", "patch": "@@ -548,6 +548,12 @@ package Lib is\n    --  This is like Get_Code_Unit, except that in the case of subunits, it\n    --  returns the top-level unit to which the subunit belongs instead of\n    --  the subunit.\n+   --\n+   --  Note: for nodes and slocs in declarations of library-level instances of\n+   --  generics these routines wrongly return the unit number corresponding to\n+   --  the body of the instance. In effect, locations of SPARK references in\n+   --  ALI files are bogus. However, fixing this is not worth the effort, since\n+   --  these references are only used for debugging.\n \n    function In_Extended_Main_Code_Unit\n      (N : Node_Or_Entity_Id) return Boolean;"}, {"sha": "7566629ebe0d170dd9ebbd42e09c82c0dfa01c49", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=80007176a59e43c10d3c6db1f42804863771a0ce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2014, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2016, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1339,7 +1339,13 @@ package body System.Tasking.Stages is\n \n       if Self_ID.Common.Specific_Handler /= null then\n          TH := Self_ID.Common.Specific_Handler;\n-      else\n+\n+      --  Independent tasks should not call the Fall_Back_Handler (of the\n+      --  environment task), because they are implementation artifacts that\n+      --  should be invisible to Ada programs.\n+\n+      elsif Self_ID.Master_of_Task /= Independent_Task_Level then\n+\n          --  Look for a fall-back handler following the master relationship\n          --  for the task. As specified in ARM C.7.3 par. 9/2, \"the fall-back\n          --  handler applies only to the dependent tasks of the task\". Hence,"}, {"sha": "6896dac2586ce8904d4858f976bfb361b65b773e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=80007176a59e43c10d3c6db1f42804863771a0ce", "patch": "@@ -13204,11 +13204,11 @@ package body Sem_Ch13 is\n                --  Get alignments, sizes and offset, if any\n \n                X_Alignment := Alignment (ACCR.X);\n-               X_Size := Esize (ACCR.X);\n+               X_Size      := Esize (ACCR.X);\n \n                if Present (ACCR.Y) then\n                   Y_Alignment := Alignment (ACCR.Y);\n-                  Y_Size := Esize (ACCR.Y);\n+                  Y_Size      := Esize (ACCR.Y);\n                end if;\n \n                if ACCR.Off"}, {"sha": "2bdf9e5a2c49785bc75d70605056df04288d3294", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80007176a59e43c10d3c6db1f42804863771a0ce/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=80007176a59e43c10d3c6db1f42804863771a0ce", "patch": "@@ -1121,13 +1121,15 @@ package body Sem_Dim is\n    begin\n       --  Aspect is an Ada 2012 feature. Note that there is no need to check\n       --  dimensions for nodes that don't come from source, except for subtype\n-      --  declarations where the dimensions are inherited from the base type.\n+      --  declarations where the dimensions are inherited from the base type,\n+      --  and for explicit dereferences generated when expanding iterators.\n \n       if Ada_Version < Ada_2012 then\n          return;\n \n       elsif not Comes_From_Source (N)\n         and then Nkind (N) /= N_Subtype_Declaration\n+        and then Nkind (N) /= N_Explicit_Dereference\n       then\n          return;\n       end if;\n@@ -2015,7 +2017,8 @@ package body Sem_Dim is\n          end if;\n       end if;\n \n-      --  Removal of dimensions in expression\n+      --  Remove dimensions from inner expressions, to prevent dimensions\n+      --  table from growing uselessly.\n \n       case Nkind (N) is\n          when N_Attribute_Reference |"}]}