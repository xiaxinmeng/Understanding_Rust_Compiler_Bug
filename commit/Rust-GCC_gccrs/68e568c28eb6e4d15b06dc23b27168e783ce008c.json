{"sha": "68e568c28eb6e4d15b06dc23b27168e783ce008c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhlNTY4YzI4ZWI2ZTRkMTViMDZkYzIzYjI3MTY4ZTc4M2NlMDA4Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-03-19T18:53:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-03-19T18:53:04Z"}, "message": "cse.c (find_comparison_args): Update documentation.\n\n\t* cse.c (find_comparison_args): Update documentation.  Fix\n\tmishandling of COMPARE operations.\n\n\t* tree.def (ABS_EXPR): Add documentation.\n\t* fold-const.c (fold): Improve folding of ABS_EXPRs.\n\nFrom-SVN: r40630", "tree": {"sha": "b54bc88743a41fe139d4d714ef19b50f51dcb79b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b54bc88743a41fe139d4d714ef19b50f51dcb79b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68e568c28eb6e4d15b06dc23b27168e783ce008c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e568c28eb6e4d15b06dc23b27168e783ce008c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68e568c28eb6e4d15b06dc23b27168e783ce008c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e568c28eb6e4d15b06dc23b27168e783ce008c/comments", "author": null, "committer": null, "parents": [{"sha": "d4b6faf649a1b8f5d84e1e1711a8e66476250de3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4b6faf649a1b8f5d84e1e1711a8e66476250de3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4b6faf649a1b8f5d84e1e1711a8e66476250de3"}], "stats": {"total": 104, "additions": 71, "deletions": 33}, "files": [{"sha": "0eb39de722a1ce73387847f8e991aa954117c041", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e568c28eb6e4d15b06dc23b27168e783ce008c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e568c28eb6e4d15b06dc23b27168e783ce008c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68e568c28eb6e4d15b06dc23b27168e783ce008c", "patch": "@@ -1,3 +1,11 @@\n+2001-03-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cse.c (find_comparison_args): Update documentation.  Fix\n+\tmishandling of COMPARE operations.\n+\n+\t* tree.def (ABS_EXPR): Add documentation.\n+\t* fold-const.c (fold): Improve folding of ABS_EXPRs.\n+\n 2001-03-19  Zack Weinberg  <zackw@stanford.edu>\n \n \t* Makefile.in (hash.o): Depend on $(GCONFIG_H), not $(CONFIG_H)."}, {"sha": "9ba7f72d409b8050beccf733e05a83ac9f3ece16", "filename": "gcc/cse.c", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e568c28eb6e4d15b06dc23b27168e783ce008c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e568c28eb6e4d15b06dc23b27168e783ce008c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=68e568c28eb6e4d15b06dc23b27168e783ce008c", "patch": "@@ -3086,17 +3086,25 @@ find_best_addr (insn, loc, mode)\n #endif\n }\n \f\n-/* Given an operation (CODE, *PARG1, *PARG2), where code is a comparison\n-   operation (EQ, NE, GT, etc.), follow it back through the hash table and\n-   what values are being compared.\n+/* This routine accepts a comparison as input and attempts to return a\n+   comparision that is cheaper to compute.\n \n-   *PARG1 and *PARG2 are updated to contain the rtx representing the values\n-   actually being compared.  For example, if *PARG1 was (cc0) and *PARG2\n-   was (const_int 0), *PARG1 and *PARG2 will be set to the objects that were\n-   compared to produce cc0.\n+   On input, *PARG1 and *PARG2 should be set to the first and second\n+   arguments to the comparison, respectively.  CODE is the comparision\n+   code.  For example, if the comparison is:\n \n-   The return value is the comparison operator and is either the code of\n-   A or the code corresponding to the inverse of the comparison.  */\n+     (ne:SI (reg:CC 24 cc)\n+            (const_int 0 [0x0])))\n+\n+   The CODE should be NE, *PARG1 should be `(reg:CC 24 cc)' and \n+   *PARG2 should be `(const_int 0)'.\n+\n+   Upon return, *PARG1 and and *PARG2 may have new values, indicating\n+   arguments to a cheaper comparison.  *PMODE1 and *PMODE2 will be the\n+   modes that should be used for those arguments.  The return value\n+   itself will be the comparison code that should be used to compare\n+   *PARG1 and *PARG2 in order to obtain a value equivalent to that\n+   given by the original comparison.  */\n \n static enum rtx_code\n find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n@@ -3187,30 +3195,38 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n \t  if (! exp_equiv_p (p->exp, p->exp, 1, 0))\n \t    continue;\n \n-\t  if (GET_CODE (p->exp) == COMPARE\n-\t      /* Another possibility is that this machine has a compare insn\n-\t\t that includes the comparison code.  In that case, ARG1 would\n-\t\t be equivalent to a comparison operation that would set ARG1 to\n-\t\t either STORE_FLAG_VALUE or zero.  If this is an NE operation,\n-\t\t ORIG_CODE is the actual comparison being done; if it is an EQ,\n-\t\t we must reverse ORIG_CODE.  On machine with a negative value\n-\t\t for STORE_FLAG_VALUE, also look at LT and GE operations.  */\n-\t      || ((code == NE\n-\t\t   || (code == LT\n-\t\t       && GET_MODE_CLASS (inner_mode) == MODE_INT\n-\t\t       && (GET_MODE_BITSIZE (inner_mode)\n-\t\t\t   <= HOST_BITS_PER_WIDE_INT)\n-\t\t       && (STORE_FLAG_VALUE\n-\t\t\t   & ((HOST_WIDE_INT) 1\n-\t\t\t      << (GET_MODE_BITSIZE (inner_mode) - 1))))\n+\t  /* `(COMPARE A B) != 0)' is equivalent to `(COMPARE A B)'.\n+\t     If CODE is EQ, rather than NE, then we are out of luck;\n+\t     there is no way to reverse the sense of a COMPARE.  */\n+\t  if (code == NE && GET_CODE (p->exp) == COMPARE)\n+\t    {\n+\t      x = p->exp;\n+\t      break;\n+\t    }\n+\t  /* Another possibility is that this machine has a compare\n+\t     insn that includes the comparison code.  In that case,\n+\t     ARG1 would be equivalent to a comparison operation that\n+\t     would set ARG1 to either STORE_FLAG_VALUE or zero.  If\n+\t     this is an NE operation, ORIG_CODE is the actual\n+\t     comparison being done; if it is an EQ, we must reverse\n+\t     ORIG_CODE.  On machine with a negative value for\n+\t     STORE_FLAG_VALUE, also look at LT and GE operations.  */\n+\t  else if ((code == NE\n+\t\t    || (code == LT\n+\t\t\t&& GET_MODE_CLASS (inner_mode) == MODE_INT\n+\t\t\t&& (GET_MODE_BITSIZE (inner_mode)\n+\t\t\t    <= HOST_BITS_PER_WIDE_INT)\n+\t\t\t&& (STORE_FLAG_VALUE\n+\t\t\t    & ((HOST_WIDE_INT) 1\n+\t\t\t       << (GET_MODE_BITSIZE (inner_mode) - 1))))\n #ifdef FLOAT_STORE_FLAG_VALUE\n-\t\t   || (code == LT\n-\t\t       && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n-\t\t       && (REAL_VALUE_NEGATIVE\n-\t\t\t   (FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)))))\n+\t\t    || (code == LT\n+\t\t\t&& GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n+\t\t\t&& (REAL_VALUE_NEGATIVE\n+\t\t\t    (FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)))))\n #endif\n-\t\t   )\n-\t\t  && GET_RTX_CLASS (GET_CODE (p->exp)) == '<'))\n+\t\t    )\n+\t\t   && GET_RTX_CLASS (GET_CODE (p->exp)) == '<')\n \t    {\n \t      x = p->exp;\n \t      break;"}, {"sha": "ed988222d4b19b7cdd4e85e323874ccd05632257", "filename": "gcc/fold-const.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e568c28eb6e4d15b06dc23b27168e783ce008c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e568c28eb6e4d15b06dc23b27168e783ce008c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=68e568c28eb6e4d15b06dc23b27168e783ce008c", "patch": "@@ -5275,8 +5275,16 @@ fold (expr)\n \t{\n \t  if (TREE_CODE (arg0) == INTEGER_CST)\n \t    {\n-\t      if (! TREE_UNSIGNED (type)\n-\t\t  && TREE_INT_CST_HIGH (arg0) < 0)\n+\t      /* If the value is unsigned, then the absolute value is\n+\t\t the same as the ordinary value.  */\n+\t      if (TREE_UNSIGNED (type))\n+\t\treturn arg0;\n+\t      /* Similarly, if the value is non-negative.  */\n+\t      else if (INT_CST_LT (integer_minus_one_node, arg0))\n+\t\treturn arg0;\n+\t      /* If the value is negative, then the absolute value is\n+\t\t its negation.  */\n+\t      else\n \t\t{\n \t\t  unsigned HOST_WIDE_INT low;\n \t\t  HOST_WIDE_INT high;"}, {"sha": "399e05706a818a43490ac12edf0e74bca55230a8", "filename": "gcc/tree.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e568c28eb6e4d15b06dc23b27168e783ce008c/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e568c28eb6e4d15b06dc23b27168e783ce008c/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=68e568c28eb6e4d15b06dc23b27168e783ce008c", "patch": "@@ -602,7 +602,13 @@ DEFTREECODE (NEGATE_EXPR, \"negate_expr\", '1', 1)\n \n DEFTREECODE (MIN_EXPR, \"min_expr\", '2', 2)\n DEFTREECODE (MAX_EXPR, \"max_expr\", '2', 2)\n+\n+/* Represents the absolute value of the operand.\n+\n+   An ABS_EXPR must have either an INTEGER_TYPE or a REAL_TYPE.  The\n+   operand of the ABS_EXPR must have the same type.  */\n DEFTREECODE (ABS_EXPR, \"abs_expr\", '1', 1)\n+\n DEFTREECODE (FFS_EXPR, \"ffs_expr\", '1', 1)\n \n /* Shift operations for shift and rotate."}]}