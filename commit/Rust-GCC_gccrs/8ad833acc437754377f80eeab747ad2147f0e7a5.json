{"sha": "8ad833acc437754377f80eeab747ad2147f0e7a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFkODMzYWNjNDM3NzU0Mzc3ZjgwZWVhYjc0N2FkMjE0N2YwZTdhNQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2005-02-12T12:57:12Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-02-12T12:57:12Z"}, "message": "tree-vectorizer.c (vect_get_base_and_offset): Remove.\n\n        * tree-vectorizer.c (vect_get_base_and_offset): Remove.\n        (vect_is_simple_iv_evolution): Remove redundant parameter\n        and step check.\n        (vect_analyze_scalar_cycles): Call vect_is_simple_iv_evolution\n        without last parameter.\n        (vect_analyze_pointer_ref_access): Get access_fn as parameter.\n        Return pointer step. Call vect_is_simple_iv_evolution without\n        last parameter. Check only that the step is multiple of size\n        type. Remove stmt_vinfo updates.\n        (vect_get_memtag_and_dr): Remove.\n        (vect_get_memtag): New function.\n        (vect_address_analysis): New function.\n        (vect_object_analysis): New function.\n        (vect_analyze_data_refs): Call vect_object_analysis and\n        vect_get_memtag. Update stmt_vinfo fields.\n\nFrom-SVN: r94934", "tree": {"sha": "cc1ff61e96bfcc34a8540c4eaead32f16637f1dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc1ff61e96bfcc34a8540c4eaead32f16637f1dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ad833acc437754377f80eeab747ad2147f0e7a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad833acc437754377f80eeab747ad2147f0e7a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ad833acc437754377f80eeab747ad2147f0e7a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad833acc437754377f80eeab747ad2147f0e7a5/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794"}], "stats": {"total": 937, "additions": 502, "deletions": 435}, "files": [{"sha": "51fa9d803123b1a4d527eec5fe1444299b5c57d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad833acc437754377f80eeab747ad2147f0e7a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad833acc437754377f80eeab747ad2147f0e7a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ad833acc437754377f80eeab747ad2147f0e7a5", "patch": "@@ -1,3 +1,21 @@\n+2005-02-12  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.c (vect_get_base_and_offset): Remove.\n+\t(vect_is_simple_iv_evolution): Remove redundant parameter\n+\tand step check.\n+\t(vect_analyze_scalar_cycles): Call vect_is_simple_iv_evolution\n+\twithout last parameter.\n+\t(vect_analyze_pointer_ref_access): Get access_fn as parameter.\n+\tReturn pointer step. Call vect_is_simple_iv_evolution without\n+\tlast parameter. Check only that the step is multiple of size\n+\ttype. Remove stmt_vinfo updates.\n+\t(vect_get_memtag_and_dr): Remove.\n+\t(vect_get_memtag): New function.\n+\t(vect_address_analysis): New function.\n+\t(vect_object_analysis): New function.\n+\t(vect_analyze_data_refs): Call vect_object_analysis and\n+\tvect_get_memtag. Update stmt_vinfo fields.\n+\n 2005-02-12  Ira Rosen  <irar@il.ibm.com>\n \n \t* tree-data-ref.c (array_base_name_differ_p): Check that the bases"}, {"sha": "d0caedd841d466300cf21313f006c7289b07057e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad833acc437754377f80eeab747ad2147f0e7a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad833acc437754377f80eeab747ad2147f0e7a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ad833acc437754377f80eeab747ad2147f0e7a5", "patch": "@@ -1,3 +1,7 @@\n+2005-02-12  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-97.c: New test.\n+\n 2005-02-12  Ira Rosen  <irar@il.ibm.com>\n \n \t* gcc.dg/vect/vect-96.c: New test."}, {"sha": "661b482a658cd1f6ae7fad327647033585f4f2e9", "filename": "gcc/testsuite/gcc.dg/vect/vect-97.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad833acc437754377f80eeab747ad2147f0e7a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-97.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad833acc437754377f80eeab747ad2147f0e7a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-97.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-97.c?ref=8ad833acc437754377f80eeab747ad2147f0e7a5", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+typedef char achar __attribute__ ((__aligned__(16)));\n+\n+#define N 16\n+ \n+int main1 ()\n+{  \n+  struct {\n+    achar *p;\n+    achar *q;\n+  } s;\n+  int i;\n+  achar x[N];\n+  achar cb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+\n+  s.p = x;\n+  for (i = 0; i < N; i++)\n+    {\n+      s.p[i] = cb[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (s.p[i] != cb[i])\n+        abort ();\n+    }\n+\n+  s.q = cb;\n+  for (i = 0; i < N; i++)\n+    {\n+      s.p[i] = s.q[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (s.p[i] != s.q[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */"}, {"sha": "1b01ac2a110c9bb078918cdd59c0b1d2db93a617", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 422, "deletions": 435, "changes": 857, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad833acc437754377f80eeab747ad2147f0e7a5/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad833acc437754377f80eeab747ad2147f0e7a5/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=8ad833acc437754377f80eeab747ad2147f0e7a5", "patch": "@@ -215,28 +215,29 @@ static void vect_enhance_data_refs_alignment (loop_vec_info);\n /* Utility functions for the analyses.  */\n static bool vect_is_simple_use (tree , loop_vec_info, tree *);\n static bool exist_non_indexing_operands_for_use_p (tree, tree);\n-static bool vect_is_simple_iv_evolution (unsigned, tree, tree *, tree *, bool);\n+static bool vect_is_simple_iv_evolution (unsigned, tree, tree *, tree *);\n static void vect_mark_relevant (varray_type *, tree);\n static bool vect_stmt_relevant_p (tree, loop_vec_info);\n static tree vect_get_loop_niters (struct loop *, tree *);\n static bool vect_compute_data_ref_alignment (struct data_reference *);\n static bool vect_analyze_data_ref_access (struct data_reference *);\n static bool vect_can_force_dr_alignment_p (tree, unsigned int);\n static struct data_reference * vect_analyze_pointer_ref_access \n-  (tree, tree, bool, tree*);\n+  (tree, tree, bool, tree, tree *, tree *);\n static bool vect_can_advance_ivs_p (loop_vec_info);\n-static tree vect_get_base_and_offset (struct data_reference *, tree, tree, \n-\t\t\t\t      loop_vec_info, tree *, tree *, tree *,\n-\t\t\t\t      bool*);\n static tree vect_get_ptr_offset (tree, tree, tree *);\n-static tree vect_get_memtag_and_dr\n-  (tree, tree, bool, loop_vec_info, tree, struct data_reference **);\n static bool vect_analyze_offset_expr (tree, struct loop *, tree, tree *, \n \t\t\t\t      tree *, tree *);\n static tree vect_strip_conversion (tree);\n static bool vect_base_addr_differ_p (struct data_reference *,\n \t\t\t\t     struct data_reference *drb, bool *);\n-\n+static tree vect_object_analysis (tree, tree, bool, tree, \n+\t\t\t\t  struct data_reference **, tree *, tree *, \n+\t\t\t\t  tree *, bool *);\n+static tree vect_address_analysis (tree, tree, bool, tree, \n+\t\t\t\t   struct data_reference *, tree *, tree *, \n+\t\t\t\t   tree *, bool *);\n+static tree vect_get_memtag (tree, struct data_reference *);\n \n /* Utility functions for the code transformation.  */\n static tree vect_create_destination_var (tree, tree);\n@@ -1621,209 +1622,6 @@ vect_analyze_offset_expr (tree expr,\n }\n \n \n-/* Function vect_get_base_and_offset\n-\n-   Return the BASE of the data reference EXPR.\n-   If VECTYPE is given, also compute the INITIAL_OFFSET from BASE, MISALIGN and \n-   STEP.\n-   E.g., for EXPR a.b[i] + 4B, BASE is a, and OFFSET is the overall offset  \n-   'a.b[i] + 4B' from a (can be an expression), MISALIGN is an OFFSET \n-   instantiated with initial_conditions of access_functions of variables, \n-   modulo alignment, and STEP is the evolution of the DR_REF in this loop.\n-\n-   Function get_inner_reference is used for the above in case of ARRAY_REF and\n-   COMPONENT_REF.\n-\n-   Input:\n-   EXPR - the memory reference that is being analyzed\n-   DR - the data_reference struct of the _original_ memory reference\n-        (Note: DR_REF (DR) is not necessarily EXPR)\n-   VECTYPE - the type that defines the alignment (i.e, we compute\n-             alignment relative to TYPE_ALIGN(VECTYPE))\n-   \n-   Output:\n-   BASE (returned value) - the base of the data reference EXPR.\n-                           E.g, if EXPR is a.b[k].c[i][j] the returned\n-\t\t\t   base is a.\n-   INITIAL_OFFSET - initial offset of EXPR from BASE (an expression)\n-   MISALIGN - offset of EXPR from BASE in bytes (a constant) or NULL_TREE if the\n-              computation is impossible\n-   STEP - evolution of the DR_REF in the loop\n-   BASE_ALIGNED_P - indicates if BASE is aligned\n- \n-   If something unexpected is encountered (an unsupported form of data-ref),\n-   then NULL_TREE is returned.  */\n-\n-static tree \n-vect_get_base_and_offset (struct data_reference *dr, \n-\t\t\t  tree expr, \n-\t\t\t  tree vectype, \n-\t\t\t  loop_vec_info loop_vinfo,\n-\t\t\t  tree *initial_offset,\n-\t\t\t  tree *misalign,\n-\t\t\t  tree *step,\n-\t\t\t  bool *base_aligned_p)\n-{\n-  tree this_offset = ssize_int (0);\n-  tree this_misalign = ssize_int (0);\n-  tree this_step = ssize_int (0);\n-  tree base = NULL_TREE;\n-  tree next_ref;\n-  tree oprnd0, oprnd1;\n-  enum tree_code code = TREE_CODE (expr);\n-  HOST_WIDE_INT pbitsize;\n-  HOST_WIDE_INT pbitpos;\n-  tree poffset;\n-  enum machine_mode pmode;\n-  int punsignedp, pvolatilep;\n-  tree bit_pos_in_bytes;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-\n-  *base_aligned_p = false;\n-\n-  switch (code)\n-    {\n-    /* These cases end the recursion:  */\n-    case VAR_DECL:\n-    case PARM_DECL:\n-      *initial_offset = ssize_int (0);\n-      *step = ssize_int (0);\n-      *misalign = ssize_int (0);\n-      if (DECL_ALIGN (expr) >= TYPE_ALIGN (vectype))\n-\t*base_aligned_p = true;\n-      return build_fold_addr_expr (expr);\n-\n-    case SSA_NAME:\n-      if (TREE_CODE (TREE_TYPE (expr)) != POINTER_TYPE)\n-\treturn NULL_TREE;\n-      \n-      if (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (expr))) < TYPE_ALIGN (vectype)) \n-\t{\n-\t  base = vect_get_ptr_offset (expr, vectype, misalign);\n-\t  if (base)\n-\t    *base_aligned_p = true;\n-\t}\n-      else\n-\t{\t  \n-\t  *base_aligned_p = true;\n-\t  *misalign = ssize_int (0);\n-\t}\n-      *initial_offset = ssize_int (0);\n-      *step = ssize_int (0);\n-      return expr;\n-      \n-    case INTEGER_CST:      \n-      *initial_offset = fold_convert (ssizetype, expr);\n-      *misalign = fold_convert (ssizetype, expr);\n-      *step = ssize_int (0);\n-      return expr;\n-\n-    /* These cases continue the recursion:  */\n-    case ADDR_EXPR:\n-      oprnd0 = TREE_OPERAND (expr, 0);\n-      next_ref = oprnd0;\n-      break;\n-\n-    case INDIRECT_REF:\n-      oprnd0 = TREE_OPERAND (expr, 0);\n-      next_ref = oprnd0;\n-      break;\n-\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-      oprnd0 = TREE_OPERAND (expr, 0);\n-      oprnd1 = TREE_OPERAND (expr, 1);\n-\n-      /* In case we have a PLUS_EXPR of the form\n-\t (oprnd0 + oprnd1), we assume that only oprnd0 determines the base.  \n-\t This is verified in vect_get_memtag_and_dr.  */\n-      base = vect_get_base_and_offset (dr, oprnd1, vectype, loop_vinfo, \n-\t\t\t\t       &this_offset, &this_misalign, \n-\t\t\t\t       &this_step, base_aligned_p);  \n-      /* Offset was already computed in vect_analyze_pointer_ref_access.  */\n-      this_offset = ssize_int (0);\n-\n-      if (!base) \n-\tthis_misalign = NULL_TREE;\n-      else\n-\tthis_misalign = size_binop (TREE_CODE (expr), ssize_int (0),\n-\t\t\t\t    this_misalign);\n-      next_ref = oprnd0;\n-      break;\n-\n-    default:\n-      if (!handled_component_p (expr))\n-\t/* Unsupported expression.  */\n-\treturn NULL_TREE;\n-\n-      /* Find the base and the offset from it.  */\n-      next_ref = get_inner_reference (expr, &pbitsize, &pbitpos, &poffset,\n-\t\t\t\t      &pmode, &punsignedp, &pvolatilep, false);\n-      if (!next_ref)\n-\treturn NULL_TREE;\n-\n-      if (poffset \n-\t  && !vect_analyze_offset_expr (poffset, loop, TYPE_SIZE_UNIT (vectype), \n-\t\t\t\t\t&this_offset, &this_misalign, \n-\t\t\t\t\t&this_step))\n-\t{\n-\t  /* Failed to compute offset or step.  */\n-\t  *step = NULL_TREE;\n-\t  *initial_offset = NULL_TREE;\n-\t  *misalign = NULL_TREE;\n-\t  return NULL_TREE;\n-\t}\n-\n-      /* Add bit position to OFFSET and MISALIGN.  */\n-\n-      bit_pos_in_bytes = ssize_int (pbitpos/BITS_PER_UNIT);\n-      /* Check that there is no remainder in bits.  */\n-      if (pbitpos%BITS_PER_UNIT)\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\t    fprintf (vect_dump, \"bit offset alignment.\");\n-\t  return NULL_TREE;\n-\t}\n-      this_offset = size_binop (PLUS_EXPR, bit_pos_in_bytes, \n-\t\t\t\tfold_convert (ssizetype, this_offset));     \n-      if (this_misalign) \n-\tthis_misalign = size_binop (PLUS_EXPR, this_misalign, bit_pos_in_bytes); \n-\n-      /* Continue the recursion to refine the base (get_inner_reference returns \n-\t &a for &a[i], and not a).  */\n-      break;\n-    }\n-\n-  base = vect_get_base_and_offset (dr, next_ref, vectype, loop_vinfo, \n-\t\t\t\t   initial_offset, misalign, step, \n-\t\t\t\t   base_aligned_p);  \n-  if (base)\n-    {\n-      /* Combine the results.  */\n-      if (this_misalign && *misalign)\n-\t*misalign = size_binop (PLUS_EXPR, *misalign, this_misalign);\n-      else \n-\t*misalign = NULL_TREE;\n-\n-      *step = size_binop (PLUS_EXPR, *step, this_step);\n-\n-      *initial_offset = size_binop (PLUS_EXPR, *initial_offset, this_offset);\n-\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-        {\n-          print_generic_expr (vect_dump, expr, TDF_SLIM);\n-          fprintf (vect_dump, \"\\n --> total offset for ref: \");\n-          print_generic_expr (vect_dump, *initial_offset, TDF_SLIM);\n-          fprintf (vect_dump, \"\\n --> total misalign for ref: \");\n-          print_generic_expr (vect_dump, *misalign, TDF_SLIM);\n-          fprintf (vect_dump, \"\\n --> total step for ref: \");\n-          print_generic_expr (vect_dump, *step, TDF_SLIM);\n-        }\n-    }    \n-  return base;\n-}\n-\n-\n /* Function vect_force_dr_alignment_p.\n \n    Returns whether the alignment of a DECL can be forced to be aligned\n@@ -3929,7 +3727,7 @@ exist_non_indexing_operands_for_use_p (tree use, tree stmt)\n \n static bool\n vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init, \n-\t\t\t\ttree * step, bool strict)\n+\t\t\t     tree * step)\n {\n   tree init_expr;\n   tree step_expr;\n@@ -3968,14 +3766,6 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n       return false;\n     }\n \n-  if (strict)\n-    if (!integer_onep (step_expr))\n-      {\n-        if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\t  print_generic_expr (vect_dump, step_expr, TDF_SLIM);\n-        return false;\n-      }\n-\n   return true;\n }\n \n@@ -4077,8 +3867,7 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n            print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n         }\n \n-      if (!vect_is_simple_iv_evolution (loop->num, access_fn, &dummy, \n-\t\t\t\t\t&dummy, false))\n+      if (!vect_is_simple_iv_evolution (loop->num, access_fn, &dummy, &dummy))\n \t{\n \t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n \t\t\t\t    LOOP_LOC (loop_vinfo)))\n@@ -4710,54 +4499,44 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n /* Function vect_analyze_pointer_ref_access.\n \n    Input:\n-   STMT - a stmt that contains a data-ref\n+   STMT - a stmt that contains a data-ref.\n    MEMREF - a data-ref in STMT, which is an INDIRECT_REF.\n+   ACCESS_FN - the access function of MEMREF.\n \n+   Output:\n    If the data-ref access is vectorizable, return a data_reference structure\n-   that represents it (DR). Otherwise - return NULL.  */\n+   that represents it (DR). Otherwise - return NULL.  \n+   STEP - the stride of MEMREF in the loop.\n+   INIT - the initial condition of MEMREF in the loop.\n+*/\n \n static struct data_reference *\n vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read, \n-\t\t\t\t tree *ptr_init)\n+\t\t\t\t tree access_fn, tree *ptr_init, tree *ptr_step)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  tree access_fn = analyze_scalar_evolution (loop, TREE_OPERAND (memref, 0));\n-  tree init, step;\t\n+  tree step, init;\t\n   tree reftype, innertype;\n   tree indx_access_fn; \n   int loopnum = loop->num;\n   struct data_reference *dr;\n \n-  if (!access_fn)\n-    {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo)))\n-        fprintf (vect_dump, \"not vectorized: complicated pointer access.\");\t\n-      return NULL;\n-    }\n-\n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-    {\n-      fprintf (vect_dump, \"Access function of ptr: \");\n-      print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n-    }\n-\n-  if (!vect_is_simple_iv_evolution (loopnum, access_fn, &init, &step, false))\n+  if (!vect_is_simple_iv_evolution (loopnum, access_fn, &init, &step))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS, \n+\t\t\t\tLOOP_LOC (loop_vinfo))) \n \tfprintf (vect_dump, \"not vectorized: pointer access is not simple.\");\t\n       return NULL;\n     }\n-\t\t\n+\n   STRIP_NOPS (init);\n \n   if (!expr_invariant_in_loop_p (loop, init))\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\t\t\t\tLOOP_LOC (loop_vinfo))) \n \tfprintf (vect_dump, \n \t\t \"not vectorized: initial condition is not loop invariant.\");\t\n       return NULL;\n@@ -4766,7 +4545,7 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read,\n   if (TREE_CODE (step) != INTEGER_CST)\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\t\t\t\tLOOP_LOC (loop_vinfo))) \n \tfprintf (vect_dump, \n \t\t\"not vectorized: non constant step for pointer access.\");\t\n       return NULL;\n@@ -4785,30 +4564,23 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read,\n   if (TREE_CODE (reftype) != POINTER_TYPE) \n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\t\t\t\tLOOP_LOC (loop_vinfo))) \n \tfprintf (vect_dump, \"not vectorized: unexpected pointer access form.\");\n       return NULL;\n     }\n \n+  *ptr_step = fold_convert (ssizetype, step);\n   innertype = TREE_TYPE (reftype);\n-  if (tree_int_cst_compare (TYPE_SIZE_UNIT (innertype), step))\n+  /* Check that STEP is a multiple of type size.  */\n+  if (!integer_zerop (size_binop (TRUNC_MOD_EXPR, *ptr_step, \n+ \t\t        fold_convert (ssizetype, TYPE_SIZE_UNIT (innertype)))))\n     {\n-      /* FORNOW: support only consecutive access */\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\t\t\t\tLOOP_LOC (loop_vinfo))) \n \tfprintf (vect_dump, \"not vectorized: non consecutive access.\");\t\n       return NULL;\n     }\n-\n-  STMT_VINFO_VECT_STEP (stmt_info) = fold_convert (ssizetype, step);\n-  if (TREE_CODE (init) == PLUS_EXPR \n-      || TREE_CODE (init) == MINUS_EXPR)\n-    STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = \n-      size_binop (TREE_CODE (init), ssize_int (0),  \n-\t\t  fold_convert (ssizetype, TREE_OPERAND (init, 1)));\n-  else\n-    STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = ssize_int (0);\n-\n+   \n   indx_access_fn = \n \tbuild_polynomial_chrec (loopnum, integer_zero_node, integer_one_node);\n   if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n@@ -4822,193 +4594,389 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read,\n }\n \n \n-/* Function vect_get_memtag_and_dr.  \n+/* Function vect_get_memtag.  \n \n    The function returns the relevant variable for memory tag (for aliasing \n-   purposes). Also data reference structure DR is created.  \n+   purposes).  */\n \n-   This function handles three kinds of MEMREF:\n+static tree\n+vect_get_memtag (tree memref, struct data_reference *dr)\n+{\n+  tree symbl, tag;\n \n-   It is called from vect_analyze_data_refs with a MEMREF that is either an \n-   ARRAY_REF or an INDIRECT_REF (this is category 1 - \"recursion begins\"). \n-   It builds a DR for them using vect_get_base_and_offset, and calls itself \n-   recursively to retrieve the relevant memtag for the MEMREF, \"peeling\" the \n-   MEMREF along the way. During the recursive calls, the function may be called \n-   with a MEMREF for which the recursion has to continue - PLUS_EXPR, \n-   MINUS_EXPR, INDIRECT_REF (category 2 - \"recursion continues\"), \n-   and/or with a MEMREF for which a memtag can be trivially obtained - VAR_DECL \n-   and SSA_NAME (this is category 3 - \"recursion stop condition\"). \n+  switch (TREE_CODE (memref))\n+    {\n+    case SSA_NAME:\n+      symbl = SSA_NAME_VAR (memref);\n+      tag = get_var_ann (symbl)->type_mem_tag;\n+      if (!tag)\n+\t{\n+\t  tree ptr = TREE_OPERAND (DR_REF (dr), 0);\n+\t  if (TREE_CODE (ptr) == SSA_NAME)\n+\t    tag = get_var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n+\t}\n+      return tag;\n+\n+    case ADDR_EXPR:\n+      return TREE_OPERAND (memref, 0);\n+\n+    default:\n+      return NULL_TREE;\n+    }  \n+}\n \n-   When the MEMREF falls into category 1 there is still no data reference struct \n-   (DR) available. It is created by this function, and then, along the \n-   recursion, MEMREF will fall into category 2 or 3, in which case a DR will \n-   have already been created, but the analysis continues to retrieve the MEMTAG.\n+\n+/* Function vect_address_analysis\n+\n+   Return the BASE of the address expression EXPR.\n+   Also compute the INITIAL_OFFSET from BASE, MISALIGN and STEP.\n \n    Input:\n-   MEMREF - data reference in STMT\n+   EXPR - the address expression that is being analyzed\n+   STMT - the statement that contains EXPR or its original memory reference\n+   IS_READ - TRUE if STMT reads from EXPR, FALSE if writes to EXPR\n+   VECTYPE - the type that defines the alignment (i.e, we compute\n+             alignment relative to TYPE_ALIGN(VECTYPE))\n+   DR - data_reference struct for the original memory reference\n+\n+   Output:\n+   BASE (returned value) - the base of the data reference EXPR.\n+   INITIAL_OFFSET - initial offset of EXPR from BASE (an expression)\n+   MISALIGN - offset of EXPR from BASE in bytes (a constant) or NULL_TREE if the\n+              computation is impossible\n+   STEP - evolution of EXPR in the loop\n+   BASE_ALIGNED - indicates if BASE is aligned\n+ \n+   If something unexpected is encountered (an unsupported form of data-ref),\n+   then NULL_TREE is returned.  \n+ */\n+\n+static tree\n+vect_address_analysis (tree expr, tree stmt, bool is_read, tree vectype, \n+\t\t       struct data_reference *dr, tree *offset, tree *misalign,\n+\t\t       tree *step, bool *base_aligned)\n+{\n+  tree oprnd0, oprnd1, base_address, offset_expr, base_addr0, base_addr1;\n+  tree address_offset = ssize_int (0), address_misalign = ssize_int (0);\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      /* EXPR is of form {base +/- offset} (or {offset +/- base}).  */\n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      oprnd1 = TREE_OPERAND (expr, 1);\n+\n+      STRIP_NOPS (oprnd0);\n+      STRIP_NOPS (oprnd1);\n+      \n+      /* Recursively try to find the base of the address contained in EXPR.\n+\t For offset, the returned base will be NULL.  */\n+      base_addr0 = vect_address_analysis (oprnd0, stmt, is_read, vectype, dr, \n+\t\t\t\t     &address_offset, &address_misalign, step, \n+\t\t\t\t     base_aligned);\n+\n+      base_addr1 = vect_address_analysis (oprnd1, stmt, is_read, vectype, dr, \n+\t\t\t\t     &address_offset, &address_misalign, step, \n+\t\t\t\t     base_aligned);\n+\n+      /* We support cases where only one of the operands contains an \n+\t address.  */\n+      if ((base_addr0 && base_addr1) || (!base_addr0 && !base_addr1))\n+\treturn NULL_TREE;\n+\n+      /* To revert STRIP_NOPS.  */\n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      oprnd1 = TREE_OPERAND (expr, 1);\n+      \n+      offset_expr = base_addr0 ? \n+\tfold_convert (ssizetype, oprnd1) : fold_convert (ssizetype, oprnd0);\n+\n+      /* EXPR is of form {base +/- offset} (or {offset +/- base}). If offset is \n+\t a number, we can add it to the misalignment value calculated for base,\n+\t otherwise, misalignment is NULL.  */\n+      if (TREE_CODE (offset_expr) == INTEGER_CST && address_misalign)\n+\t*misalign = size_binop (TREE_CODE (expr), address_misalign, \n+\t\t\t\toffset_expr);\n+      else\n+\t*misalign = NULL_TREE;\n+\n+      /* Combine offset (from EXPR {base + offset}) with the offset calculated\n+\t for base.  */\n+      *offset = size_binop (TREE_CODE (expr), address_offset, offset_expr);\n+      return base_addr0 ? base_addr0 : base_addr1;\n+\n+    case ADDR_EXPR:\n+      base_address = vect_object_analysis (TREE_OPERAND (expr, 0), stmt, is_read, \n+\t\t\t\t   vectype, &dr, offset, misalign, step, \n+\t\t\t\t   base_aligned);\n+      return base_address;\n+\n+    case SSA_NAME:\n+      if (TREE_CODE (TREE_TYPE (expr)) != POINTER_TYPE)\n+\treturn NULL_TREE;\n+      \n+      if (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (expr))) < TYPE_ALIGN (vectype)) \n+\t{\n+\t  if (vect_get_ptr_offset (expr, vectype, misalign))\n+\t    *base_aligned = true;\t  \n+\t  else\n+\t    *base_aligned = false;\n+\t}\n+      else\n+\t{\t  \n+\t  *base_aligned = true;\n+\t  *misalign = ssize_int (0);\n+\t}\n+      *offset = ssize_int (0);\n+      *step = ssize_int (0);\n+      return expr;\n+      \n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+\n+/* Function vect_object_analysis\n+\n+   Return the BASE of the data reference MEMREF.\n+   Also compute the INITIAL_OFFSET from BASE, MISALIGN and STEP.\n+   E.g., for EXPR a.b[i] + 4B, BASE is a, and OFFSET is the overall offset  \n+   'a.b[i] + 4B' from a (can be an expression), MISALIGN is an OFFSET \n+   instantiated with initial_conditions of access_functions of variables, \n+   modulo alignment, and STEP is the evolution of the DR_REF in this loop.\n+\n+   Function get_inner_reference is used for the above in case of ARRAY_REF and\n+   COMPONENT_REF.\n+\n+   The structure of the function is as follows:\n+   Part 1:\n+   Case 1. For handled_component_p refs \n+          1.1 call get_inner_reference\n+            1.1.1 analyze offset expr received from get_inner_reference\n+\t  1.2. build data-reference structure for MEMREF\n+        (fall through with BASE)\n+   Case 2. For declarations \n+          2.1 check alignment\n+          2.2 update DR_BASE_NAME if necessary for alias\n+   Case 3. For INDIRECT_REFs \n+          3.1 get the access function\n+\t  3.2 analyze evolution of MEMREF\n+\t  3.3 set data-reference structure for MEMREF\n+          3.4 call vect_address_analysis to analyze INIT of the access function\n+\n+   Part 2:\n+   Combine the results of object and address analysis to calculate \n+   INITIAL_OFFSET, STEP and misalignment info.   \n+\n+   Input:\n+   MEMREF - the memory reference that is being analyzed\n+   STMT - the statement that contains MEMREF\n    IS_READ - TRUE if STMT reads from MEMREF, FALSE if writes to MEMREF\n+   VECTYPE - the type that defines the alignment (i.e, we compute\n+             alignment relative to TYPE_ALIGN(VECTYPE))\n    \n    Output:\n+   BASE_ADDRESS (returned value) - the base address of the data reference MEMREF\n+                                   E.g, if MEMREF is a.b[k].c[i][j] the returned\n+\t\t\t           base is &a.\n    DR - data_reference struct for MEMREF\n-   return value - the relevant variable for memory tag (for aliasing purposes).\n-\n-*/ \n+   INITIAL_OFFSET - initial offset of MEMREF from BASE (an expression)\n+   MISALIGN - offset of MEMREF from BASE in bytes (a constant) or NULL_TREE if \n+              the computation is impossible\n+   STEP - evolution of the DR_REF in the loop\n+   BASE_ALIGNED - indicates if BASE is aligned\n+ \n+   If something unexpected is encountered (an unsupported form of data-ref),\n+   then NULL_TREE is returned.  */\n \n static tree\n-vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read, \n-\t\t\tloop_vec_info loop_vinfo, \n-\t\t\ttree vectype, struct data_reference **dr)\n+vect_object_analysis (tree memref, tree stmt, bool is_read,\n+\t\t      tree vectype, struct data_reference **dr,\n+\t\t      tree *offset, tree *misalign, tree *step,\n+\t\t      bool *base_aligned)\n {\n-  tree symbl, oprnd0, oprnd1;\n+  tree base = NULL_TREE, base_address = NULL_TREE;\n+  tree object_offset = ssize_int (0), object_misalign = ssize_int (0);\n+  tree object_step = ssize_int (0), address_step = ssize_int (0);\n+  bool object_base_aligned = true, address_base_aligned = true;\n+  tree address_offset = ssize_int (0), address_misalign = ssize_int (0);\n+  HOST_WIDE_INT pbitsize, pbitpos;\n+  tree poffset, bit_pos_in_bytes;\n+  enum machine_mode pmode;\n+  int punsignedp, pvolatilep;\n+  tree ptr_step = ssize_int (0), ptr_init = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  tree offset, misalign, step;\n-  tree ref_to_be_analyzed, tag, dr_base;\n-  struct data_reference *new_dr;\n-  bool base_aligned_p;\n-  tree ptr_init;\n-\n-  if (*dr)\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct data_reference *ptr_dr = NULL;\n+  tree access_fn, evolution_part, address_to_analyze;\n+   \n+  /* Part 1: */\n+  /* Case 1. handled_component_p refs.  */\n+  if (handled_component_p (memref))\n     {\n-      /* Category 3: recursion stop condition.  */\n-      /* (1) A DR already exists. We only need to get the relevant memtag for\n-\t MEMREF, the rest of the data was already initialized.  */\n+      /* 1.1 call get_inner_reference.  */\n+      /* Find the base and the offset from it.  */\n+      base = get_inner_reference (memref, &pbitsize, &pbitpos, &poffset,\n+\t\t\t\t  &pmode, &punsignedp, &pvolatilep, false);\n+      if (!base)\n+\treturn NULL_TREE;\n \n-      switch (TREE_CODE (memref))\n+      /* 1.1.1 analyze offset expr received from get_inner_reference.  */\n+      if (poffset \n+\t  && !vect_analyze_offset_expr (poffset, loop, TYPE_SIZE_UNIT (vectype), \n+\t\t\t\t&object_offset, &object_misalign, &object_step))\n \t{\n-\t  /* (1.1) Stop condition: find the relevant memtag and return.  */\n-\tcase SSA_NAME:\n-\t  symbl = SSA_NAME_VAR (memref);\n-\t  tag = get_var_ann (symbl)->type_mem_tag;\n-\t  if (!tag)\n-\t    {\n-\t      tree ptr = TREE_OPERAND (DR_REF ((*dr)), 0);\n-\t      if (TREE_CODE (ptr) == SSA_NAME)\n-\t\ttag = get_var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n-\t    }\n-\t  if (!tag)\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                         UNKNOWN_LOC))\n-\t\tfprintf (vect_dump, \"not vectorized: no memtag for ref.\");\n-\t      return NULL_TREE;\n+\t      fprintf (vect_dump, \"failed to compute offset or step for \");\n+\t      print_generic_expr (vect_dump, memref, TDF_SLIM);\n \t    }\n-\t  return tag;\n-\n-\tcase VAR_DECL:\n-\tcase PARM_DECL:\n-\t  return memref;\n-\n-\t  /* Category 2: recursion continues.  */\n-\t  /* (1.2) A recursive call to find the relevant memtag is required.  */\n-\tcase INDIRECT_REF:\n-\t  symbl = TREE_OPERAND (memref, 0); \n-\t  break; /* For recursive call.  */\n-\n-\tcase COMPONENT_REF:\n-\t  /* Could have recorded more accurate information - \n-\t     i.e, the actual FIELD_DECL that is being referenced -\n-\t     but later passes expect VAR_DECL as the nmt.  */\n-\t  /* Fall through.  */\n-\t\n-\tcase ADDR_EXPR:\n-\t  symbl = build_fold_indirect_ref (\n-\t\t       STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info));\n-\t  break; /* For recursive call.  */\n-\n-\tcase PLUS_EXPR:\n-\tcase MINUS_EXPR:\n-\t  /* Although DR exists, we have to call the function recursively to \n-\t     build MEMTAG for such expression. This is handled below.  */\n-\t  oprnd0 = TREE_OPERAND (memref, 0);\n-\t  oprnd1 = TREE_OPERAND (memref, 1);\n-      \n-\t  STRIP_NOPS (oprnd1); \n-\t   /* Supported plus/minus expressions are of the form \n-\t     {address_base + offset}, such that address_base is of type \n-\t     POINTER/ARRAY, and offset is either an INTEGER_CST of type POINTER, \n-\t     or it's not of type POINTER/ARRAY. \n-\t     TODO: swap operands if {offset + address_base}.  */\n-\t  if ((TREE_CODE (TREE_TYPE (oprnd1)) == POINTER_TYPE \n-\t       && TREE_CODE (oprnd1) != INTEGER_CST)\n-\t      || TREE_CODE (TREE_TYPE (oprnd1)) == ARRAY_TYPE)\n-\t    return NULL_TREE;\n-      \n-\t  symbl = oprnd0;\t \n-\t  break; /* For recursive call.  */\n-\n-\tdefault:\n \t  return NULL_TREE;\n \t}\n-    }  \n-  else\n-    {\n-      /* Category 1: recursion begins.  */\n-      /* (2) A DR does not exist yet and must be built, followed by a\n-\t recursive call to get the relevant memtag for MEMREF.  */\n \n-      switch (TREE_CODE (memref))\n-\t{      \n-\tcase INDIRECT_REF:\n-\t  new_dr = vect_analyze_pointer_ref_access (memref, stmt, is_read, \n-\t\t\t\t\t\t    &ptr_init);\n-\t  if (!new_dr)\n-\t    return NULL_TREE; \n-\t  *dr = new_dr;\n-\t  symbl = ptr_init;\n-\t  ref_to_be_analyzed = ptr_init;\n-\t  break;\n-      \n-\tcase ARRAY_REF:\n-\t  new_dr = analyze_array (stmt, memref, is_read);\n-\t  *dr = new_dr;\n-\t  symbl = DR_BASE_NAME (new_dr);\n-\t  ref_to_be_analyzed = memref;\n-\t  break;\n+      /* Add bit position to OFFSET and MISALIGN.  */\n \n-\tdefault:\n-\t  /* TODO: Support data-refs of form a[i].p for unions and single\n-\t     field structures.  */\n+      bit_pos_in_bytes = ssize_int (pbitpos/BITS_PER_UNIT);\n+      /* Check that there is no remainder in bits.  */\n+      if (pbitpos%BITS_PER_UNIT)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"bit offset alignment.\");\n \t  return NULL_TREE;\n-\t}  \n-\n-      offset = ssize_int (0);\n-      misalign = ssize_int (0);\n-      step = ssize_int (0);\n-\n-      /* Analyze data-ref, find its base, initial offset from the base, step,\n-\t and alignment.  */\n-      dr_base = vect_get_base_and_offset (new_dr, ref_to_be_analyzed, \n-\t\t\t\t\t  vectype, loop_vinfo, &offset, \n-\t\t\t\t\t  &misalign, &step, &base_aligned_p);\n-      if (!dr_base)\n-\treturn NULL_TREE;\n-    \n-      /* Initialize information according to above analysis.  */\n-      /* Since offset and step of a pointer can be also set in\n-\t vect_analyze_pointer_ref_access, we combine the values here. */\n-      if (STMT_VINFO_VECT_INIT_OFFSET (stmt_info))\n-\tSTMT_VINFO_VECT_INIT_OFFSET (stmt_info) = \n-\t  size_binop (PLUS_EXPR, offset, \n-\t\t      STMT_VINFO_VECT_INIT_OFFSET (stmt_info));\t\t  \n-      else\n-\tSTMT_VINFO_VECT_INIT_OFFSET (stmt_info) = offset;\n+\t}\n+      object_offset = size_binop (PLUS_EXPR, bit_pos_in_bytes, object_offset);     \n+      if (object_misalign) \n+\tobject_misalign = size_binop (PLUS_EXPR, object_misalign, \n+\t\t\t\t      bit_pos_in_bytes); \n+\n+      /* Create data-reference for MEMREF. TODO: handle COMPONENT_REFs.  */\n+      if (!(*dr))\n+\t{ \n+\t  if (TREE_CODE (memref) == ARRAY_REF)\n+\t    *dr = analyze_array (stmt, memref, is_read);\n+\t  else\n+\t    /* FORNOW.  */\n+\t    return NULL_TREE;\n+\t}\n+      memref = base; /* To continue analysis of BASE.  */\n+      /* fall through  */\n+    }\n+  \n+  /*  Part 1: Case 2. Declarations.  */ \n+  if (DECL_P (memref))\n+    {\n+      /* We expect to get a decl only if we already have a DR.  */\n+      if (!(*dr))\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    {\n+\t      fprintf (vect_dump, \"unhandled decl \");\n+\t      print_generic_expr (vect_dump, memref, TDF_SLIM);\n+\t    }\n+\t  return NULL_TREE;\n+\t}\n \n-      if (step && STMT_VINFO_VECT_STEP (stmt_info))\n-\tSTMT_VINFO_VECT_STEP (stmt_info) = \n-\t  size_binop (PLUS_EXPR, step, STMT_VINFO_VECT_STEP (stmt_info));\n+      /* 2.1 check the alignment.  */\n+      if (DECL_ALIGN (memref) >= TYPE_ALIGN (vectype))\n+\tobject_base_aligned = true;\n       else\n-\tSTMT_VINFO_VECT_STEP (stmt_info) = step;\n+\tobject_base_aligned = false;\n \n-      STMT_VINFO_VECT_BASE_ALIGNED_P (stmt_info) = base_aligned_p;\n-      STMT_VINFO_VECT_MISALIGNMENT (stmt_info) = misalign;\n-      STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info) = dr_base;\t     \n+      /* 2.2 update DR_BASE_NAME if necessary.  */\n+      if (!DR_BASE_NAME ((*dr)))\n+\t/* For alias analysis.  In case the analysis of INDIRECT_REF brought \n+\t   us to object.  */\n+\tDR_BASE_NAME ((*dr)) = memref;\n+\n+      base_address = build_fold_addr_expr (memref);\n     }\n \n-  if (!symbl)\n+  /* Part 1:  Case 3. INDIRECT_REFs.  */\n+  else if (TREE_CODE (memref) == INDIRECT_REF)\n+    {      \n+      /* 3.1 get the access function.  */\n+      access_fn = analyze_scalar_evolution (loop, TREE_OPERAND (memref, 0));\n+      if (!access_fn)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t    fprintf (vect_dump, \"not vectorized: complicated pointer access.\");\t\n+\t  return NULL_TREE;\n+\t}\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t{\n+\t  fprintf (vect_dump, \"Access function of ptr: \");\n+\t  print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n+\t}\n+\n+      /* 3.2 analyze evolution of MEMREF.  */\n+      evolution_part = evolution_part_in_loop_num (access_fn, loop->num);\n+      if (evolution_part)\n+\t{\n+\t  ptr_dr = vect_analyze_pointer_ref_access (memref, stmt, is_read, \n+\t\t\t\t         access_fn, &ptr_init, &ptr_step);\n+\t  if (!(ptr_dr))\n+\t    return NULL_TREE; \n+\t  \n+\t  object_step = size_binop (PLUS_EXPR, object_step, ptr_step);\n+\t  address_to_analyze = ptr_init;\n+\t}\n+      else\n+\t{\n+\t  if (!(*dr))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t\tLOOP_LOC (loop_vinfo))) \n+\t\tfprintf (vect_dump, \"not vectorized: ptr is loop invariant.\");\t\n+\t      return NULL_TREE;\n+\t    }\n+\t  /* Since there exists DR for MEMREF, we are analyzing the base of\n+\t     handled component, which not necessary has evolution in the \n+\t     loop.  */\n+\t  address_to_analyze = TREE_OPERAND (base, 0);\n+\t}\n+      \n+      /* 3.3 set data-reference structure for MEMREF.  */\n+      *dr = (*dr) ? *dr : ptr_dr;\n+\n+      /* 3.4 call vect_address_analysis to analyze INIT of the access \n+\t function.  */\n+      base_address = vect_address_analysis (address_to_analyze, stmt, is_read, \n+\t\t\t       vectype, *dr, &address_offset, &address_misalign, \n+\t\t\t       &address_step, &address_base_aligned);\n+    }\n+    \t    \n+  if (!base_address)\n+    /* MEMREF cannot be analyzed.  */\n     return NULL_TREE;\n-  /* Recursive call to retrieve the relevant memtag.  */\n-  tag = vect_get_memtag_and_dr (symbl, stmt, is_read, loop_vinfo, vectype, dr);\n-  return tag;\n+\n+  /* Part 2: Combine the results of object and address analysis to calculate \n+     INITIAL_OFFSET, STEP and misalignment info. */\n+  *offset = size_binop (PLUS_EXPR, object_offset, address_offset);\n+  if (object_misalign && address_misalign)\n+    *misalign = size_binop (PLUS_EXPR, object_misalign, address_misalign);\n+  else\n+    *misalign = NULL_TREE;\n+  *step = size_binop (PLUS_EXPR, object_step, address_step); \n+  *base_aligned = object_base_aligned && address_base_aligned;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    {\n+      fprintf (vect_dump, \"Results of object analysis for: \");\n+      print_generic_expr (vect_dump, memref, TDF_SLIM);\n+      fprintf (vect_dump, \"\\n\\tbase: \");\n+      print_generic_expr (vect_dump, base, TDF_SLIM);\n+      fprintf (vect_dump, \"\\n\\toffset: \");\n+      print_generic_expr (vect_dump, *offset, TDF_SLIM);\n+      fprintf (vect_dump, \"\\n\\tstep: \");\n+      print_generic_expr (vect_dump, *step, TDF_SLIM);\n+      fprintf (vect_dump, \"\\n\\tbase aligned %d\\n\\tmisalign: \", *base_aligned);\n+      print_generic_expr (vect_dump, *misalign, TDF_SLIM);\n+    }\n+  return base_address;\n }\n \n \n@@ -5021,15 +4989,15 @@ vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read,\n    1- vect_analyze_data_refs(loop): \n       Find and analyze all data-refs in the loop:\n           foreach ref\n-             ref_stmt.memtag =  vect_get_memtag_and_dr (ref)\n-   1.1- vect_get_memtag_and_dr(ref): \n-      Analyze ref, and build a DR (data_referece struct) for it;\n-      call vect_get_base_and_offset to compute base, initial_offset, \n-      step and alignment. Set ref_stmt.base, ref_stmt.initial_offset,\n-      ref_stmt.alignment, and ref_stmt.step accordingly. \n-   1.1.1- vect_get_base_and_offset():\n-      Calculate base, initial_offset, step and alignment.      \n-      For ARRAY_REFs and COMPONENT_REFs use call get_inner_reference.\n+\t     base_address = vect_object_analysis(ref)\n+             ref_stmt.memtag =  vect_get_memtag(base)\n+      1.1- vect_object_analysis(ref): \n+           Analyze ref, and build a DR (data_referece struct) for it;\n+           compute base, initial_offset, step and alignment. \n+           Call get_inner_reference for refs handled in this function.\n+           Call vect_addr_analysis(addr) to analyze pointer type expressions.\n+      Set ref_stmt.base, ref_stmt.initial_offset, ref_stmt.alignment, and \n+      ref_stmt.step accordingly. \n    2- vect_analyze_dependences(): apply dependence testing using ref_stmt.DR\n    3- vect_analyze_drs_alignment(): check that ref_stmt.alignment is ok.\n    4- vect_analyze_drs_access(): check that ref_stmt.step is ok.\n@@ -5065,8 +5033,9 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  varray_type *datarefs = NULL;\n \t  int nvuses, nv_may_defs, nv_must_defs;\n \t  tree memref = NULL;\n-\t  tree symbl;\n-\t  tree scalar_type, vectype;\n+\t  tree scalar_type, vectype;\t  \n+\t  tree base, offset, misalign, step, tag;\n+\t  bool base_aligned;\n \n \t  /* Assumption: there exists a data-ref in stmt, if and only if \n              it has vuses/vdefs.  */\n@@ -5125,12 +5094,13 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t      /* It is not possible to vectorize this data reference.  */\n \t      return false;\n \t    }\n-\t  /* Analyze MEMREF. If it is of a supported form, build data_reference\n-\t     struct for it (DR) and find memtag for aliasing purposes.  */\n-\t  dr = NULL;\n-\t  symbl = vect_get_memtag_and_dr (memref, stmt, is_read, loop_vinfo, \n-\t\t\t\t\t  vectype, &dr);\n-\t  if (!symbl)\n+\t /* Analyze MEMREF. If it is of a supported form, build data_reference\n+\t     struct for it (DR).  */\n+\t  dr = NULL; \n+\t  base = vect_object_analysis (memref, stmt, is_read, vectype, &dr, \n+\t\t\t\t       &offset, &misalign, &step, \n+\t\t\t\t       &base_aligned);\n+\t  if (!base)\n \t    {\n \t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n \t\t\t\t\tLOOP_LOC (loop_vinfo)))\n@@ -5140,7 +5110,24 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t\t}\n \t      return false;\n \t    }\n-\t  STMT_VINFO_MEMTAG (stmt_info) = symbl;\n+\t  /*  Find memtag for aliasing purposes.  */\n+\t  tag = vect_get_memtag (base, dr);\n+\t  if (!tag)\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\t\t{\n+\t\t  fprintf (vect_dump, \"not vectorized: no memtag ref: \"); \n+\t\t  print_generic_expr (vect_dump, memref, TDF_SLIM);\n+\t\t}\n+\t      return false;\n+\t    }\n+\t  STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info) = base;\n+\t  STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = offset;\n+\t  STMT_VINFO_VECT_STEP (stmt_info) = step;\n+\t  STMT_VINFO_VECT_MISALIGNMENT (stmt_info) = misalign;\n+\t  STMT_VINFO_VECT_BASE_ALIGNED_P (stmt_info) = base_aligned;\n+\t  STMT_VINFO_MEMTAG (stmt_info) = tag;\n \t  STMT_VINFO_VECTYPE (stmt_info) = vectype;\n \t  VARRAY_PUSH_GENERIC_PTR (*datarefs, dr);\n \t  STMT_VINFO_DATA_REF (stmt_info) = dr;"}]}