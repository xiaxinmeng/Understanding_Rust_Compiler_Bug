{"sha": "ba6e17e78db543b336c196b55fa6430e513f1941", "node_id": "C_kwDOANBUbNoAKGJhNmUxN2U3OGRiNTQzYjMzNmMxOTZiNTVmYTY0MzBlNTEzZjE5NDE", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-11-16T16:18:25Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-11-16T16:18:25Z"}, "message": "Avoid assuming maximum string length is constant [PR102960].\n\nResolves:\nPR tree-optimization/102960 - ICE: in sign_mask, at wide-int.h:855 in GCC 10.3.0\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/102960\n\t* gimple-fold.c (get_range_strlen): Take bitmap as an argument rather\n\tthan a pointer to it.\n\t(get_range_strlen_tree): Same.  Remove bitmap allocation.  Use\n\tan auto_bitmap.\n\t(get_maxval_strlen): Use an auto_bitmap.\n\t* tree-ssa-strlen.c (get_range_strlen_dynamic): Factor out PHI\n\thandling...\n\t(get_range_strlen_phi): ...into this function.\n\tAvoid assuming maximum string length is constant\n\t(printf_strlen_execute): Dump pointer query cache contents when\n\tdetails are requisted.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/102960\n\t* gcc.dg/Wstringop-overflow-84.c: New test.", "tree": {"sha": "834fa5781c510ed696423f889b3bcc46572f9729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/834fa5781c510ed696423f889b3bcc46572f9729"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba6e17e78db543b336c196b55fa6430e513f1941", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba6e17e78db543b336c196b55fa6430e513f1941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba6e17e78db543b336c196b55fa6430e513f1941", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba6e17e78db543b336c196b55fa6430e513f1941/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0002a8a1997c7beb3c4facc17ed0d1294e3dce14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0002a8a1997c7beb3c4facc17ed0d1294e3dce14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0002a8a1997c7beb3c4facc17ed0d1294e3dce14"}], "stats": {"total": 191, "additions": 102, "deletions": 89}, "files": [{"sha": "ad9703ee471e548ece5427ced36a92c3a7c96264", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba6e17e78db543b336c196b55fa6430e513f1941/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba6e17e78db543b336c196b55fa6430e513f1941/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=ba6e17e78db543b336c196b55fa6430e513f1941", "patch": "@@ -86,7 +86,7 @@ enum strlen_range_kind {\n };\n \n static bool\n-get_range_strlen (tree, bitmap *, strlen_range_kind, c_strlen_data *, unsigned);\n+get_range_strlen (tree, bitmap, strlen_range_kind, c_strlen_data *, unsigned);\n \n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n@@ -1525,7 +1525,7 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n /* Helper of get_range_strlen for ARG that is not an SSA_NAME.  */\n \n static bool\n-get_range_strlen_tree (tree arg, bitmap *visited, strlen_range_kind rkind,\n+get_range_strlen_tree (tree arg, bitmap visited, strlen_range_kind rkind,\n \t\t       c_strlen_data *pdata, unsigned eltsize)\n {\n   gcc_assert (TREE_CODE (arg) != SSA_NAME);\n@@ -1849,7 +1849,7 @@ get_range_strlen_tree (tree arg, bitmap *visited, strlen_range_kind rkind,\n    Return true if *PDATA was successfully populated and false otherwise.  */\n \n static bool\n-get_range_strlen (tree arg, bitmap *visited,\n+get_range_strlen (tree arg, bitmap visited,\n \t\t  strlen_range_kind rkind,\n \t\t  c_strlen_data *pdata, unsigned eltsize)\n {\n@@ -1863,9 +1863,7 @@ get_range_strlen (tree arg, bitmap *visited,\n     return false;\n \n   /* If we were already here, break the infinite cycle.  */\n-  if (!*visited)\n-    *visited = BITMAP_ALLOC (NULL);\n-  if (!bitmap_set_bit (*visited, SSA_NAME_VERSION (arg)))\n+  if (!bitmap_set_bit (visited, SSA_NAME_VERSION (arg)))\n     return true;\n \n   tree var = arg;\n@@ -1962,10 +1960,10 @@ get_range_strlen (tree arg, bitmap *visited,\n bool\n get_range_strlen (tree arg, c_strlen_data *pdata, unsigned eltsize)\n {\n-  bitmap visited = NULL;\n+  auto_bitmap visited;\n   tree maxbound = pdata->maxbound;\n \n-  if (!get_range_strlen (arg, &visited, SRK_LENRANGE, pdata, eltsize))\n+  if (!get_range_strlen (arg, visited, SRK_LENRANGE, pdata, eltsize))\n     {\n       /* On failure extend the length range to an impossible maximum\n \t (a valid MAXLEN must be less than PTRDIFF_MAX - 1).  Other\n@@ -1981,9 +1979,6 @@ get_range_strlen (tree arg, c_strlen_data *pdata, unsigned eltsize)\n   if (maxbound && pdata->maxbound == maxbound)\n     pdata->maxbound = build_all_ones_cst (size_type_node);\n \n-  if (visited)\n-    BITMAP_FREE (visited);\n-\n   return !integer_all_onesp (pdata->maxlen);\n }\n \n@@ -2005,19 +2000,16 @@ get_maxval_strlen (tree arg, strlen_range_kind rkind, tree *nonstr = NULL)\n   /* ARG must have an integral type when RKIND says so.  */\n   gcc_assert (rkind != SRK_INT_VALUE || INTEGRAL_TYPE_P (TREE_TYPE (arg)));\n \n-  bitmap visited = NULL;\n+  auto_bitmap visited;\n \n   /* Reset DATA.MAXLEN if the call fails or when DATA.MAXLEN\n      is unbounded.  */\n   c_strlen_data lendata = { };\n-  if (!get_range_strlen (arg, &visited, rkind, &lendata, /* eltsize = */1))\n+  if (!get_range_strlen (arg, visited, rkind, &lendata, /* eltsize = */1))\n     lendata.maxlen = NULL_TREE;\n   else if (lendata.maxlen && integer_all_onesp (lendata.maxlen))\n     lendata.maxlen = NULL_TREE;\n \n-  if (visited)\n-    BITMAP_FREE (visited);\n-\n   if (nonstr)\n     {\n       /* For callers prepared to handle unterminated arrays set"}, {"sha": "2c0f507a0ed17fd5a786bbd52e86b588cb43c07e", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-84.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba6e17e78db543b336c196b55fa6430e513f1941/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-84.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba6e17e78db543b336c196b55fa6430e513f1941/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-84.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-84.c?ref=ba6e17e78db543b336c196b55fa6430e513f1941", "patch": "@@ -0,0 +1,15 @@\n+/* PR middle-end/102960 - ICE: in sign_mask, at wide-int.h:855 in GCC 10.3.0\n+   { dg-do compile }\n+   { dg-options \"-Og -Wall\" } */\n+\n+void f (int i)\n+{\n+  const char *s;\n+  if (i)\n+    s = &\"abcd\"[i];\n+\n+  __builtin_printf (\"%s\", s);\n+}\n+\n+/* The use of s in the call to sprintf should result in:\n+   { dg-prune-output \"-Wmaybe-uninitialized\" } */"}, {"sha": "536f796f82bd7b9d72ff05a61a4ecb7d55273562", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 79, "deletions": 73, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba6e17e78db543b336c196b55fa6430e513f1941/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba6e17e78db543b336c196b55fa6430e513f1941/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=ba6e17e78db543b336c196b55fa6430e513f1941", "patch": "@@ -193,6 +193,8 @@ struct laststmt_struct\n } laststmt;\n \n static int get_stridx_plus_constant (strinfo *, unsigned HOST_WIDE_INT, tree);\n+static bool get_range_strlen_dynamic (tree, gimple *s, c_strlen_data *,\n+\t\t\t\t      bitmap, range_query *, unsigned *);\n \n /* Sets MINMAX to either the constant value or the range VAL is in\n    and returns either the constant value or VAL on success or null\n@@ -1087,6 +1089,76 @@ dump_strlen_info (FILE *fp, gimple *stmt, range_query *rvals)\n     }\n }\n \n+/* Helper of get_range_strlen_dynamic().  See below.  */\n+\n+static bool\n+get_range_strlen_phi (tree src, gphi *phi,\n+\t\t      c_strlen_data *pdata, bitmap visited,\n+\t\t      range_query *rvals, unsigned *pssa_def_max)\n+{\n+  if (!bitmap_set_bit (visited, SSA_NAME_VERSION (src)))\n+    return true;\n+\n+  if (*pssa_def_max == 0)\n+    return false;\n+\n+  --*pssa_def_max;\n+\n+  /* Iterate over the PHI arguments and determine the minimum and maximum\n+     length/size of each and incorporate them into the overall result.  */\n+  for (unsigned i = 0; i != gimple_phi_num_args (phi); ++i)\n+    {\n+      tree arg = gimple_phi_arg_def (phi, i);\n+      if (arg == gimple_phi_result (phi))\n+\tcontinue;\n+\n+      c_strlen_data argdata = { };\n+      if (!get_range_strlen_dynamic (arg, phi, &argdata, visited, rvals,\n+\t\t\t\t     pssa_def_max))\n+\t{\n+\t  pdata->maxlen = build_all_ones_cst (size_type_node);\n+\t  continue;\n+\t}\n+\n+      /* Set the DECL of an unterminated array this argument refers to\n+\t if one hasn't been found yet.  */\n+      if (!pdata->decl && argdata.decl)\n+\tpdata->decl = argdata.decl;\n+\n+      if (!argdata.minlen\n+\t  || (integer_zerop (argdata.minlen)\n+\t      && (!argdata.maxbound\n+\t\t  || integer_all_onesp (argdata.maxbound))\n+\t      && integer_all_onesp (argdata.maxlen)))\n+\t{\n+\t  /* Set the upper bound of the length to unbounded.  */\n+\t  pdata->maxlen = build_all_ones_cst (size_type_node);\n+\t  continue;\n+\t}\n+\n+      /* Adjust the minimum and maximum length determined so far and\n+\t the upper bound on the array size.  */\n+      if (!pdata->minlen\n+\t  || tree_int_cst_lt (argdata.minlen, pdata->minlen))\n+\tpdata->minlen = argdata.minlen;\n+\n+      if (!pdata->maxlen\n+\t  || (argdata.maxlen\n+\t      && TREE_CODE (argdata.maxlen) == INTEGER_CST\n+\t      && tree_int_cst_lt (pdata->maxlen, argdata.maxlen)))\n+\tpdata->maxlen = argdata.maxlen;\n+\n+      if (!pdata->maxbound\n+\t  || TREE_CODE (pdata->maxbound) != INTEGER_CST\n+\t  || (argdata.maxbound\n+\t      && tree_int_cst_lt (pdata->maxbound, argdata.maxbound)\n+\t      && !integer_all_onesp (argdata.maxbound)))\n+\tpdata->maxbound = argdata.maxbound;\n+    }\n+\n+  return true;\n+}\n+\n /* Attempt to determine the length of the string SRC.  On success, store\n    the length in *PDATA and return true.  Otherwise, return false.\n    VISITED is a bitmap of visited PHI nodes.  RVALS points to the valuation\n@@ -1095,7 +1167,7 @@ dump_strlen_info (FILE *fp, gimple *stmt, range_query *rvals)\n \n static bool\n get_range_strlen_dynamic (tree src, gimple *stmt,\n-\t\t\t  c_strlen_data *pdata, bitmap *visited,\n+\t\t\t  c_strlen_data *pdata, bitmap visited,\n \t\t\t  range_query *rvals, unsigned *pssa_def_max)\n {\n   int idx = get_stridx (src, stmt);\n@@ -1104,72 +1176,9 @@ get_range_strlen_dynamic (tree src, gimple *stmt,\n       if (TREE_CODE (src) == SSA_NAME)\n \t{\n \t  gimple *def_stmt = SSA_NAME_DEF_STMT (src);\n-\t  if (gimple_code (def_stmt) == GIMPLE_PHI)\n-\t    {\n-\t      if (!*visited)\n-\t\t*visited = BITMAP_ALLOC (NULL);\n-\n-\t      if (!bitmap_set_bit (*visited, SSA_NAME_VERSION (src)))\n-\t\treturn true;\n-\n-\t      if (*pssa_def_max == 0)\n-\t\treturn false;\n-\n-\t      --*pssa_def_max;\n-\n-\t      /* Iterate over the PHI arguments and determine the minimum\n-\t\t and maximum length/size of each and incorporate them into\n-\t\t the overall result.  */\n-\t      gphi *phi = as_a <gphi *> (def_stmt);\n-\t      for (unsigned i = 0; i != gimple_phi_num_args (phi); ++i)\n-\t\t{\n-\t\t  tree arg = gimple_phi_arg_def (phi, i);\n-\t\t  if (arg == gimple_phi_result (def_stmt))\n-\t\t    continue;\n-\n-\t\t  c_strlen_data argdata = { };\n-\t\t  if (get_range_strlen_dynamic (arg, phi, &argdata, visited,\n-\t\t\t\t\t\trvals, pssa_def_max))\n-\t\t    {\n-\t\t      /* Set the DECL of an unterminated array this argument\n-\t\t\t refers to if one hasn't been found yet.  */\n-\t\t      if (!pdata->decl && argdata.decl)\n-\t\t\tpdata->decl = argdata.decl;\n-\n-\t\t      if (!argdata.minlen\n-\t\t\t  || (integer_zerop (argdata.minlen)\n-\t\t\t      && (!argdata.maxbound\n-\t\t\t\t  || integer_all_onesp (argdata.maxbound))\n-\t\t\t      && integer_all_onesp (argdata.maxlen)))\n-\t\t\t{\n-\t\t\t  /* Set the upper bound of the length to unbounded.  */\n-\t\t\t  pdata->maxlen = build_all_ones_cst (size_type_node);\n-\t\t\t  continue;\n-\t\t\t}\n-\n-\t\t      /* Adjust the minimum and maximum length determined\n-\t\t\t so far and the upper bound on the array size.  */\n-\t\t      if (!pdata->minlen\n-\t\t\t  || tree_int_cst_lt (argdata.minlen, pdata->minlen))\n-\t\t\tpdata->minlen = argdata.minlen;\n-\t\t      if (!pdata->maxlen\n-\t\t\t  || (argdata.maxlen\n-\t\t\t      && tree_int_cst_lt (pdata->maxlen, argdata.maxlen)))\n-\t\t\tpdata->maxlen = argdata.maxlen;\n-\t\t      if (!pdata->maxbound\n-\t\t\t  || TREE_CODE (pdata->maxbound) != INTEGER_CST\n-\t\t\t  || (argdata.maxbound\n-\t\t\t      && tree_int_cst_lt (pdata->maxbound,\n-\t\t\t\t\t\t  argdata.maxbound)\n-\t\t\t      && !integer_all_onesp (argdata.maxbound)))\n-\t\t\tpdata->maxbound = argdata.maxbound;\n-\t\t    }\n-\t\t  else\n-\t\t    pdata->maxlen = build_all_ones_cst (size_type_node);\n-\t\t}\n-\n-\t      return true;\n-\t    }\n+\t  if (gphi *phi = dyn_cast<gphi *>(def_stmt))\n+\t    return get_range_strlen_phi (src, phi, pdata, visited, rvals,\n+\t\t\t\t\t pssa_def_max);\n \t}\n \n       /* Return success regardless of the result and handle *PDATA\n@@ -1286,11 +1295,11 @@ void\n get_range_strlen_dynamic (tree src, gimple *stmt, c_strlen_data *pdata,\n \t\t\t  range_query *rvals)\n {\n-  bitmap visited = NULL;\n+  auto_bitmap visited;\n   tree maxbound = pdata->maxbound;\n \n   unsigned limit = param_ssa_name_def_chain_limit;\n-  if (!get_range_strlen_dynamic (src, stmt, pdata, &visited, rvals, &limit))\n+  if (!get_range_strlen_dynamic (src, stmt, pdata, visited, rvals, &limit))\n     {\n       /* On failure extend the length range to an impossible maximum\n \t (a valid MAXLEN must be less than PTRDIFF_MAX - 1).  Other\n@@ -1305,9 +1314,6 @@ get_range_strlen_dynamic (tree src, gimple *stmt, c_strlen_data *pdata,\n      MAXBOUND to SIZE_MAX.  Otherwise leave it null (if it is null).  */\n   if (maxbound && pdata->maxbound == maxbound)\n     pdata->maxbound = build_all_ones_cst (size_type_node);\n-\n-  if (visited)\n-    BITMAP_FREE (visited);\n }\n \n /* Invalidate string length information for strings whose length might\n@@ -5831,7 +5837,7 @@ printf_strlen_execute (function *fun, bool warn_only)\n   walker.walk (ENTRY_BLOCK_PTR_FOR_FN (fun));\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    walker.ptr_qry.dump (dump_file);\n+    walker.ptr_qry.dump (dump_file, true);\n \n   ssa_ver_to_stridx.release ();\n   strinfo_pool.release ();"}]}