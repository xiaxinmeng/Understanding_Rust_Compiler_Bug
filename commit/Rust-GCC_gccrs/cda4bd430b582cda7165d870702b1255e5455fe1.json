{"sha": "cda4bd430b582cda7165d870702b1255e5455fe1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RhNGJkNDMwYjU4MmNkYTcxNjVkODcwNzAyYjEyNTVlNTQ1NWZlMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-04T07:07:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-04T07:07:55Z"}, "message": "h8300.c (function_prologue): Rearrange code for conciseness.\n\n        * h8300.c (function_prologue): Rearrange code for conciseness.\n        (function_epilogue): Likewise.\n        * hh8300.h (OK_FOR_U): Fix formatting.\n\nFrom-SVN: r35474", "tree": {"sha": "6421f19cdc6786f14429db780df5782252102a32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6421f19cdc6786f14429db780df5782252102a32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cda4bd430b582cda7165d870702b1255e5455fe1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cda4bd430b582cda7165d870702b1255e5455fe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cda4bd430b582cda7165d870702b1255e5455fe1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cda4bd430b582cda7165d870702b1255e5455fe1/comments", "author": null, "committer": null, "parents": [{"sha": "024a650bcb3afda9403402d398b897102c1b53a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/024a650bcb3afda9403402d398b897102c1b53a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/024a650bcb3afda9403402d398b897102c1b53a7"}], "stats": {"total": 236, "additions": 91, "deletions": 145}, "files": [{"sha": "bb6cdc005a4664dac85fa8a7f4afb48ae5781897", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda4bd430b582cda7165d870702b1255e5455fe1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda4bd430b582cda7165d870702b1255e5455fe1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cda4bd430b582cda7165d870702b1255e5455fe1", "patch": "@@ -5,6 +5,10 @@\n \n 2000-08-04  Kazu Hirata  <kazu@hxi.com>\n \n+\t* h8300.c (function_prologue): Rearrange code for conciseness.\n+\t(function_epilogue): Likewise.\n+\t* h8300.h (OK_FOR_U): Fix formatting.\n+\n \t* cse.c: Fix a comment typo. Fix formatting.\n \n 2000-08-03  Richard Henderson  <rth@cygnus.com>"}, {"sha": "9bb802ab0c6eb926c7b938fc833a32379aafc9a2", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 74, "deletions": 132, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda4bd430b582cda7165d870702b1255e5455fe1/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda4bd430b582cda7165d870702b1255e5455fe1/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=cda4bd430b582cda7165d870702b1255e5455fe1", "patch": "@@ -239,6 +239,8 @@ function_prologue (file, size)\n {\n   int fsize = (size + STACK_BOUNDARY / 8 - 1) & -STACK_BOUNDARY / 8;\n   int idx;\n+  int push_regs[FIRST_PSEUDO_REGISTER];\n+  int n_regs;\n \n   /* Note a function with the interrupt attribute and set interrupt_handler\n      accordingly.  */\n@@ -292,83 +294,52 @@ function_prologue (file, size)\n   /* Leave room for locals.  */\n   dosize (file, \"sub\", fsize);\n \n-  /* Push the rest of the registers.  */\n+  /* Compute which registers to push.  */\n   for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n     {\n       int regno = push_order[idx];\n \n       if (regno >= 0\n \t  && WORD_REG_USED (regno)\n \t  && (!frame_pointer_needed || regno != FRAME_POINTER_REGNUM))\n+\tpush_regs[idx] = regno;\n+      else\n+\tpush_regs[idx] = -1;\n+    }\n+\n+  /* Push the rest of the registers.  */\n+  for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx += n_regs)\n+    {\n+      int regno = push_regs[idx];\n+\n+      n_regs = 1;\n+      if (regno >= 0)\n \t{\n \t  if (TARGET_H8300S)\n \t    {\n-\t      /* Try to push multiple registers.  */\n-\t      if (regno == 0 || regno == 4)\n-\t\t{\n-\t\t  int second_regno = push_order[idx + 1];\n-\t\t  int third_regno = push_order[idx + 2];\n-\t\t  int fourth_regno = push_order[idx + 3];\n-\n-\t\t  if (fourth_regno >= 0\n-\t\t      && WORD_REG_USED (fourth_regno)\n-\t\t      && (!frame_pointer_needed\n-\t\t\t  || fourth_regno != FRAME_POINTER_REGNUM)\n-\t\t      && third_regno >= 0\n-\t\t      && WORD_REG_USED (third_regno)\n-\t\t      && (!frame_pointer_needed\n-\t\t\t  || third_regno != FRAME_POINTER_REGNUM)\n-\t\t      && second_regno >= 0\n-\t\t      && WORD_REG_USED (second_regno)\n-\t\t      && (!frame_pointer_needed\n-\t\t\t  || second_regno != FRAME_POINTER_REGNUM))\n-\t\t    {\n-\t\t      fprintf (file, \"\\tstm.l %s-%s,@-sp\\n\",\n-\t\t\t       h8_reg_names[regno],\n-\t\t\t       h8_reg_names[fourth_regno]);\n-\t\t      idx += 3;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t      if (regno == 0 || regno == 4)\n-\t\t{\n-\t\t  int second_regno = push_order[idx + 1];\n-\t\t  int third_regno = push_order[idx + 2];\n-\n-\t\t  if (third_regno >= 0\n-\t\t      && WORD_REG_USED (third_regno)\n-\t\t      && (!frame_pointer_needed\n-\t\t\t  || third_regno != FRAME_POINTER_REGNUM)\n-\t\t      && second_regno >= 0\n-\t\t      && WORD_REG_USED (second_regno)\n-\t\t      && (!frame_pointer_needed\n-\t\t\t  || second_regno != FRAME_POINTER_REGNUM))\n-\t\t    {\n-\t\t      fprintf (file, \"\\tstm.l %s-%s,@-sp\\n\",\n-\t\t\t       h8_reg_names[regno],\n-\t\t\t       h8_reg_names[third_regno]);\n-\t\t      idx += 2;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t      if (regno == 0 || regno == 2 || regno == 4 || regno == 6)\n-\t\t{\n-\t\t  int second_regno = push_order[idx + 1];\n-\n-\t\t  if (second_regno >= 0\n-\t\t      && WORD_REG_USED (second_regno)\n-\t\t      && (!frame_pointer_needed\n-\t\t\t  || second_regno != FRAME_POINTER_REGNUM))\n-\t\t    {\n-\t\t      fprintf (file, \"\\tstm.l %s-%s,@-sp\\n\",\n-\t\t\t       h8_reg_names[regno],\n-\t\t\t       h8_reg_names[second_regno]);\n-\t\t      idx += 1;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n+\t      /* See how many registers we can push at the same time.  */\n+\t      if ((regno == 0 || regno == 4)\n+\t\t  && push_regs[idx + 1] >= 0\n+\t\t  && push_regs[idx + 2] >= 0\n+\t\t  && push_regs[idx + 3] >= 0)\n+\t\tn_regs = 4;\n+\n+\t      else if ((regno == 0 || regno == 4)\n+\t\t       && push_regs[idx + 1] >= 0\n+\t\t       && push_regs[idx + 2] >= 0)\n+\t\tn_regs = 3;\n+\n+\t      else if ((regno == 0 || regno == 2 || regno == 4 || regno == 6)\n+\t\t       && push_regs[idx + 1] >= 0)\n+\t\tn_regs = 2;\n \t    }\n-\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[regno]);\n+\n+\t  if (n_regs == 1)\n+\t    fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[regno]);\n+\t  else\n+\t    fprintf (file, \"\\tstm.l\\t%s-%s,@-sp\\n\",\n+\t\t     h8_reg_names[regno],\n+\t\t     h8_reg_names[regno + (n_regs - 1)]);\n \t}\n     }\n }\n@@ -383,6 +354,8 @@ function_epilogue (file, size)\n   int fsize = (size + STACK_BOUNDARY / 8 - 1) & -STACK_BOUNDARY / 8;\n   int idx;\n   rtx insn = get_last_insn ();\n+  int pop_regs[FIRST_PSEUDO_REGISTER];\n+  int n_regs;\n \n   if (os_task)\n     {\n@@ -404,83 +377,52 @@ function_epilogue (file, size)\n   if (insn && GET_CODE (insn) == BARRIER)\n     goto out;\n \n-  /* Pop the saved registers.  */\n+  /* Compute which registers to pop.  */\n   for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n     {\n       int regno = pop_order[idx];\n \n       if (regno >= 0\n \t  && WORD_REG_USED (regno)\n \t  && (!frame_pointer_needed || regno != FRAME_POINTER_REGNUM))\n+\tpop_regs[idx] = regno;\n+      else\n+\tpop_regs[idx] = -1;\n+    }\n+\n+  /* Pop the saved registers.  */\n+  for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx += n_regs)\n+    {\n+      int regno = pop_regs[idx];\n+\n+      n_regs = 1;\n+      if (regno >= 0)\n \t{\n \t  if (TARGET_H8300S)\n \t    {\n-\t      /* Try to pop multiple registers.  */\n-\t      if (regno == 7 || regno == 3)\n-\t\t{\n-\t\t  int second_regno = pop_order[idx + 1];\n-\t\t  int third_regno = pop_order[idx + 2];\n-\t\t  int fourth_regno = pop_order[idx + 3];\n-\n-\t\t  if (fourth_regno >= 0\n-\t\t      && WORD_REG_USED (fourth_regno)\n-\t\t      && (!frame_pointer_needed\n-\t\t\t  || fourth_regno != FRAME_POINTER_REGNUM)\n-\t\t      && third_regno >= 0\n-\t\t      && WORD_REG_USED (third_regno)\n-\t\t      && (!frame_pointer_needed\n-\t\t\t  || third_regno != FRAME_POINTER_REGNUM)\n-\t\t      && second_regno >= 0\n-\t\t      && WORD_REG_USED (second_regno)\n-\t\t      && (!frame_pointer_needed\n-\t\t\t  || second_regno != FRAME_POINTER_REGNUM))\n-\t\t    {\n-\t\t      fprintf (file, \"\\tldm.l @sp+,%s-%s\\n\",\n-\t\t\t       h8_reg_names[fourth_regno],\n-\t\t\t       h8_reg_names[regno]);\n-\t\t      idx += 3;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t      if (regno == 6 || regno == 2)\n-\t\t{\n-\t\t  int second_regno = pop_order[idx + 1];\n-\t\t  int third_regno = pop_order[idx + 2];\n-\n-\t\t  if (third_regno >= 0\n-\t\t      && WORD_REG_USED (third_regno)\n-\t\t      && (!frame_pointer_needed\n-\t\t\t  || third_regno != FRAME_POINTER_REGNUM)\n-\t\t      && second_regno >= 0\n-\t\t      && WORD_REG_USED (second_regno)\n-\t\t      && (!frame_pointer_needed\n-\t\t\t  || second_regno != FRAME_POINTER_REGNUM))\n-\t\t    {\n-\t\t      fprintf (file, \"\\tldm.l @sp+,%s-%s\\n\",\n-\t\t\t       h8_reg_names[third_regno],\n-\t\t\t       h8_reg_names[regno]);\n-\t\t      idx += 2;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t      if (regno == 7 || regno == 5 || regno == 3 || regno == 1)\n-\t\t{\n-\t\t  int second_regno = pop_order[idx + 1];\n-\n-\t\t  if (second_regno >= 0\n-\t\t      && WORD_REG_USED (second_regno)\n-\t\t      && (!frame_pointer_needed\n-\t\t\t  || second_regno != FRAME_POINTER_REGNUM))\n-\t\t    {\n-\t\t      fprintf (file, \"\\tldm.l @sp+,%s-%s\\n\",\n-\t\t\t       h8_reg_names[second_regno],\n-\t\t\t       h8_reg_names[regno]);\n-\t\t      idx += 1;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n+\t      /* See how many registers we can pop at the same time.  */\n+\t      if ((regno == 7 || regno == 3)\n+\t\t  && pop_regs[idx + 1] >= 0\n+\t\t  && pop_regs[idx + 2] >= 0\n+\t\t  && pop_regs[idx + 3] >= 0)\n+\t\tn_regs = 4;\n+\n+\t      else if ((regno == 6 || regno == 2)\n+\t\t       && pop_regs[idx + 1] >= 0\n+\t\t       && pop_regs[idx + 2] >= 0)\n+\t\tn_regs = 3;\n+\n+\t      else if ((regno == 7 || regno == 5 || regno == 3 || regno == 1)\n+\t\t       && pop_regs[idx + 1] >= 0)\n+\t\tn_regs = 2;\n \t    }\n-\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[regno]);\n+\n+\t  if (n_regs == 1)\n+\t    fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[regno]);\n+\t  else\n+\t    fprintf (file, \"\\tldm.l\\t@sp+,%s-%s\\n\",\n+\t\t     h8_reg_names[regno - (n_regs - 1)],\n+\t\t     h8_reg_names[regno]);\n \t}\n     }\n "}, {"sha": "c82ce55eae4815cc11b07268250f44c0e45a068d", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda4bd430b582cda7165d870702b1255e5455fe1/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda4bd430b582cda7165d870702b1255e5455fe1/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=cda4bd430b582cda7165d870702b1255e5455fe1", "patch": "@@ -854,20 +854,20 @@ struct cum_arg\n    (a SYMBOL_REF with an SYMBOL_REF_FLAG set).\n \n    On the H8/S 'U' can also be a 16bit or 32bit absolute.  */\n-#define OK_FOR_U(OP) \\\n-  ((GET_CODE (OP) == REG && REG_OK_FOR_BASE_P (OP)) \\\n-   || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG \\\n-       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))  \\\n-   || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == SYMBOL_REF \\\n-       && (TARGET_H8300S || SYMBOL_REF_FLAG (XEXP (OP, 0)))) \\\n-   || ((GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == CONST \\\n-        && GET_CODE (XEXP (XEXP (OP, 0), 0)) == PLUS \\\n-        && GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 0)) == SYMBOL_REF \\\n-        && GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 1)) == CONST_INT) \\\n-        && (TARGET_H8300S || SYMBOL_REF_FLAG (XEXP (XEXP (OP, 0), 0)))) \\\n+#define OK_FOR_U(OP)\t\t\t\t\t\t\t\\\n+  ((GET_CODE (OP) == REG && REG_OK_FOR_BASE_P (OP))\t\t\t\\\n+   || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))\t\t\t\t\\\n+   || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == SYMBOL_REF\t\\\n+       && (TARGET_H8300S || SYMBOL_REF_FLAG (XEXP (OP, 0))))\t\t\\\n+   || ((GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == CONST\t\\\n+        && GET_CODE (XEXP (XEXP (OP, 0), 0)) == PLUS\t\t\t\\\n+        && GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 0)) == SYMBOL_REF\t\\\n+        && GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 1)) == CONST_INT)\t\\\n+        && (TARGET_H8300S || SYMBOL_REF_FLAG (XEXP (XEXP (OP, 0), 0))))\t\\\n    || (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n-       && EIGHTBIT_CONSTANT_ADDRESS_P (XEXP (OP, 0)))\t\\\n-   || (GET_CODE (OP) == MEM && TARGET_H8300S\t\t\\\n+       && EIGHTBIT_CONSTANT_ADDRESS_P (XEXP (OP, 0)))\t\t\t\\\n+   || (GET_CODE (OP) == MEM && TARGET_H8300S\t\t\t\t\\\n        && GET_CODE (XEXP (OP, 0)) == CONST_INT))\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\\"}]}