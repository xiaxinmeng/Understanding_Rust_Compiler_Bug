{"sha": "b3b9f3d0a808a2e0773e90d70dff2048270cc359", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNiOWYzZDBhODA4YTJlMDc3M2U5MGQ3MGRmZjIwNDgyNzBjYzM1OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-10-04T20:59:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-10-04T20:59:07Z"}, "message": "gimple-fold.c (static_object_in_other_unit_p): Rename to...\n\n\n\t* gimple-fold.c (static_object_in_other_unit_p): Rename to...\n\t(can_refer_decl_in_current_unit_p): ... this one; reverse return\n\tvalue; handle comdats too.\n\t(canonicalize_constructor_val): Use it; handle function_decls\n\tcorrectly.\n\t(gimple_fold_obj_type_ref_known_binfo): Likewise.\n\t* gimple.c (get_base_address): Accept all kinds of decls.\n\nFrom-SVN: r164961", "tree": {"sha": "1d98e516244d02c9fedbab147a5e449884c9d35c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d98e516244d02c9fedbab147a5e449884c9d35c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3b9f3d0a808a2e0773e90d70dff2048270cc359", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b9f3d0a808a2e0773e90d70dff2048270cc359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3b9f3d0a808a2e0773e90d70dff2048270cc359", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b9f3d0a808a2e0773e90d70dff2048270cc359/comments", "author": null, "committer": null, "parents": [{"sha": "fa37ed29b9a77b698c67548a82484c5fab584b07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa37ed29b9a77b698c67548a82484c5fab584b07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa37ed29b9a77b698c67548a82484c5fab584b07"}], "stats": {"total": 76, "additions": 53, "deletions": 23}, "files": [{"sha": "4511232acf237b0e413a241aff51bd75d6d38bab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b9f3d0a808a2e0773e90d70dff2048270cc359/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b9f3d0a808a2e0773e90d70dff2048270cc359/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3b9f3d0a808a2e0773e90d70dff2048270cc359", "patch": "@@ -1,3 +1,13 @@\n+2010-10-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gimple-fold.c (static_object_in_other_unit_p): Rename to...\n+\t(can_refer_decl_in_current_unit_p): ... this one; reverse return\n+\tvalue; handle comdats too.\n+\t(canonicalize_constructor_val): Use it; handle function_decls\n+\tcorrectly.\n+\t(gimple_fold_obj_type_ref_known_binfo): Likewise.\n+\t* gimple.c (get_base_address): Accept all kinds of decls.\n+\n 2010-10-04  Joseph Myers  <joseph@codesourcery.com>\n \n \t* flags.h (g_switch_value, g_switch_set): Remove."}, {"sha": "0a6c746d380b4b6de90556fdcaf1f6b4d885d789", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b9f3d0a808a2e0773e90d70dff2048270cc359/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b9f3d0a808a2e0773e90d70dff2048270cc359/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=b3b9f3d0a808a2e0773e90d70dff2048270cc359", "patch": "@@ -31,11 +31,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-propagate.h\"\n #include \"target.h\"\n \n-/* Return true when DECL is static object in other partition.\n-   In that case we must prevent folding as we can't refer to\n-   the symbol.\n+/* Return true when DECL can be referenced from current unit.\n+   We can get declarations that are not possible to reference for\n+   various reasons:\n \n-   We can get into it in two ways:\n      1) When analyzing C++ virtual tables.\n \tC++ virtual tables do have known constructors even\n \twhen they are keyed to other compilation unit.\n@@ -46,45 +45,64 @@ along with GCC; see the file COPYING3.  If not see\n \tto method that was partitioned elsehwere.\n \tIn this case we have static VAR_DECL or FUNCTION_DECL\n \tthat has no corresponding callgraph/varpool node\n-\tdeclaring the body.  */\n-\t\n+\tdeclaring the body.  \n+     3) COMDAT functions referred by external vtables that\n+        we devirtualize only during final copmilation stage.\n+        At this time we already decided that we will not output\n+        the function body and thus we can't reference the symbol\n+        directly.  */\n+\n static bool\n-static_object_in_other_unit_p (tree decl)\n+can_refer_decl_in_current_unit_p (tree decl)\n {\n   struct varpool_node *vnode;\n   struct cgraph_node *node;\n \n-  if (!TREE_STATIC (decl) || DECL_COMDAT (decl))\n-    return false;\n+  if (!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n+    return true;\n   /* External flag is set, so we deal with C++ reference\n      to static object from other file.  */\n-  if (DECL_EXTERNAL (decl) && TREE_CODE (decl) == VAR_DECL)\n+  if (DECL_EXTERNAL (decl) && TREE_STATIC (decl)\n+      && TREE_CODE (decl) == VAR_DECL)\n     {\n       /* Just be sure it is not big in frontend setting\n \t flags incorrectly.  Those variables should never\n \t be finalized.  */\n       gcc_checking_assert (!(vnode = varpool_get_node (decl))\n \t\t\t   || !vnode->finalized);\n-      return true;\n+      return false;\n     }\n-  if (TREE_PUBLIC (decl))\n-    return false;\n-  /* We are not at ltrans stage; so don't worry about WHOPR.  */\n-  if (!flag_ltrans)\n-    return false;\n+  /* When function is public, we always can introduce new reference.\n+     Exception are the COMDAT functions where introducing a direct\n+     reference imply need to include function body in the curren tunit.  */\n+  if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl))\n+    return true;\n+  /* We are not at ltrans stage; so don't worry about WHOPR.\n+     Also when still gimplifying all referred comdat functions will be\n+     produced.  */\n+  if (!flag_ltrans && (!DECL_COMDAT (decl) || !cgraph_function_flags_ready))\n+    return true;\n+  /* If we already output the function body, we are safe.  */\n+  if (TREE_ASM_WRITTEN (decl))\n+    return true;\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       node = cgraph_get_node (decl);\n-      if (!node || !node->analyzed)\n-\treturn true;\n+      /* Check that we still have function body and that we didn't took\n+         the decision to eliminate offline copy of the function yet.\n+         The second is important when devirtualization happens during final\n+         compilation stage when making a new reference no longer makes callee\n+         to be compiled.  */\n+      if (!node || !node->analyzed || node->global.inlined_to)\n+\treturn false;\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n       vnode = varpool_get_node (decl);\n       if (!vnode || !vnode->finalized)\n-\treturn true;\n+\treturn false;\n     }\n-  return false;\n+  return true;\n }\n \n /* CVAL is value taken from DECL_INITIAL of variable.  Try to transorm it into\n@@ -106,10 +124,11 @@ canonicalize_constructor_val (tree cval)\n   if (TREE_CODE (cval) == ADDR_EXPR)\n     {\n       tree base = get_base_address (TREE_OPERAND (cval, 0));\n+\n       if (base\n \t  && (TREE_CODE (base) == VAR_DECL\n \t      || TREE_CODE (base) == FUNCTION_DECL)\n-\t  && static_object_in_other_unit_p (base))\n+\t  && !can_refer_decl_in_current_unit_p (base))\n \treturn NULL_TREE;\n       if (base && TREE_CODE (base) == VAR_DECL)\n \tadd_referenced_var (base);\n@@ -1446,7 +1465,7 @@ gimple_fold_obj_type_ref_known_binfo (HOST_WIDE_INT token, tree known_binfo)\n      devirtualize.  This can happen in WHOPR when the actual method\n      ends up in other partition, because we found devirtualization\n      possibility too late.  */\n-  if (static_object_in_other_unit_p (fndecl))\n+  if (!can_refer_decl_in_current_unit_p (fndecl))\n     return NULL;\n   return build_fold_addr_expr (fndecl);\n }"}, {"sha": "54e68571c7a3f5406c329127fad58ace3343526e", "filename": "gcc/gimple.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b9f3d0a808a2e0773e90d70dff2048270cc359/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b9f3d0a808a2e0773e90d70dff2048270cc359/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=b3b9f3d0a808a2e0773e90d70dff2048270cc359", "patch": "@@ -3013,7 +3013,8 @@ get_base_address (tree t)\n       && TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR)\n     t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n \n-  if (SSA_VAR_P (t)\n+  if (TREE_CODE (t) == SSA_NAME\n+      || DECL_P (t)\n       || TREE_CODE (t) == STRING_CST\n       || TREE_CODE (t) == CONSTRUCTOR\n       || INDIRECT_REF_P (t)"}]}