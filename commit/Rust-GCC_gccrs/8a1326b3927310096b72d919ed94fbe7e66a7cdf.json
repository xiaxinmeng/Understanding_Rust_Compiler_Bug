{"sha": "8a1326b3927310096b72d919ed94fbe7e66a7cdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGExMzI2YjM5MjczMTAwOTZiNzJkOTE5ZWQ5NGZiZTdlNjZhN2NkZg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-10-29T12:40:48Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-10-29T12:40:48Z"}, "message": "re PR tree-optimization/41775 (IPA-SRA: ice in rewrite_stmt, at tree-into-ssa.c:1302)\n\n2009-10-29  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/41775\n\t* tree-sra.c (build_ref_for_offset): Unshare *expr if not NULL.\n\t(generate_subtree_copies): Do not unshare agg.\n\t(load_assign_lhs_subreplacements): Do not unshare rhs.\n\t(sra_modify_assign): Do not unshare exprs.\n\t(propagate_subacesses_accross_link): Renamed to\n\tpropagate_subaccesses_across_link.\n\n\t* testsuite/g++.dg/torture/pr41775.C: New testcase.\n\nFrom-SVN: r153699", "tree": {"sha": "ee7ef26536e47de8b26bc3f301d655b2c9530064", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee7ef26536e47de8b26bc3f301d655b2c9530064"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a1326b3927310096b72d919ed94fbe7e66a7cdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a1326b3927310096b72d919ed94fbe7e66a7cdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a1326b3927310096b72d919ed94fbe7e66a7cdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a1326b3927310096b72d919ed94fbe7e66a7cdf/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "162e4591aa3f1a7cfb5198bc504dc110bee5a5ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162e4591aa3f1a7cfb5198bc504dc110bee5a5ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/162e4591aa3f1a7cfb5198bc504dc110bee5a5ca"}], "stats": {"total": 321, "additions": 312, "deletions": 9}, "files": [{"sha": "7e51dc6f108f77b7abb5a3a63933815706de790a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a1326b3927310096b72d919ed94fbe7e66a7cdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a1326b3927310096b72d919ed94fbe7e66a7cdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a1326b3927310096b72d919ed94fbe7e66a7cdf", "patch": "@@ -1,3 +1,13 @@\n+2009-10-29  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/41775\n+\t* tree-sra.c (build_ref_for_offset): Unshare *expr if not NULL.\n+\t(generate_subtree_copies): Do not unshare agg.\n+\t(load_assign_lhs_subreplacements): Do not unshare rhs.\n+\t(sra_modify_assign): Do not unshare exprs.\n+\t(propagate_subacesses_accross_link): Renamed to\n+\tpropagate_subaccesses_across_link.\n+\n 2009-10-29  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.c (count_insns_for_constant): Rework to support counting for"}, {"sha": "895feaae0a401b6d95bd73cff90e0e88b5c4706f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a1326b3927310096b72d919ed94fbe7e66a7cdf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a1326b3927310096b72d919ed94fbe7e66a7cdf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8a1326b3927310096b72d919ed94fbe7e66a7cdf", "patch": "@@ -1,3 +1,8 @@\n+2009-10-29  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/41775\n+\t* testsuite/g++.dg/torture/pr41775.C: New testcase.\n+\n 2009-10-28  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/inline-ns1.C: New."}, {"sha": "3d8548e3fb0972027b0614965ccf504e83a64489", "filename": "gcc/testsuite/g++.dg/torture/pr41775.C", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a1326b3927310096b72d919ed94fbe7e66a7cdf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr41775.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a1326b3927310096b72d919ed94fbe7e66a7cdf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr41775.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr41775.C?ref=8a1326b3927310096b72d919ed94fbe7e66a7cdf", "patch": "@@ -0,0 +1,284 @@\n+/* { dg-do compile } */\n+/* { dg-require-visibility \"\" } */\n+\n+typedef unsigned int size_t;\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template < typename _Iterator > struct iterator_traits\n+  {\n+  };\n+  template < typename _Tp > struct iterator_traits <_Tp * >\n+  {\n+    typedef _Tp & reference;\n+  };\n+}\n+\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\")))\n+{\n+  using std::iterator_traits;\n+  template < typename _Iterator, typename _Container > class __normal_iterator\n+  {\n+  public:typedef _Iterator iterator_type;\n+    typedef typename iterator_traits < _Iterator >::reference reference;\n+    reference operator* () const\n+    {\n+    }\n+    __normal_iterator operator++ (int)\n+    {\n+    }\n+  };\n+  template < typename _IteratorL, typename _IteratorR,\n+    typename _Container > inline bool operator!= (const __normal_iterator <\n+\t\t\t\t\t\t  _IteratorL,\n+\t\t\t\t\t\t  _Container > &__lhs,\n+\t\t\t\t\t\t  const __normal_iterator <\n+\t\t\t\t\t\t  _IteratorR,\n+\t\t\t\t\t\t  _Container > &__rhs)\n+  {\n+  }\n+}\n+\n+extern \"C\"\n+{\n+  extern \"C\"\n+  {\n+    __extension__ typedef __SIZE_TYPE__ __intptr_t;\n+  }\n+}\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template < typename _Tp > class new_allocator\n+  {\n+  public:typedef size_t size_type;\n+    typedef _Tp *pointer;\n+    template < typename _Tp1 > struct rebind\n+    {\n+      typedef new_allocator < _Tp1 > other;\n+    };\n+  };\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+template < typename _Tp > class allocator:public __gnu_cxx::new_allocator <\n+    _Tp >\n+  {\n+  };\n+}\n+\n+extern \"C\"\n+{\n+  typedef __intptr_t intptr_t;\n+}\n+namespace llvm\n+{\n+  template < typename NodeTy > class ilist_half_node\n+  {\n+  };\n+template < typename NodeTy > class ilist_node:private ilist_half_node <\n+    NodeTy >\n+  {\n+  };\n+  class MachineBasicBlock;\n+  class MachineOperand\n+  {\n+  public:enum MachineOperandType\n+    {\n+    }\n+    Contents;\n+    unsigned getReg () const\n+    {\n+    }\n+  };\n+  class TargetRegisterInfo;\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template < typename _Tp, typename _Alloc > struct _Vector_base\n+  {\n+    typedef typename _Alloc::template rebind < _Tp >::other _Tp_alloc_type;\n+  };\n+template < typename _Tp, typename _Alloc = std::allocator < _Tp > >class vector:protected _Vector_base < _Tp,\n+    _Alloc\n+    >\n+  {\n+    typedef _Vector_base < _Tp, _Alloc > _Base;\n+    typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;\n+  public:typedef _Tp value_type;\n+    typedef typename _Tp_alloc_type::pointer pointer;\n+    typedef __gnu_cxx::__normal_iterator < pointer, vector > iterator;\n+    iterator begin ()\n+    {\n+    }\n+    iterator end ()\n+    {\n+    }\n+  };\n+}\n+\n+namespace llvm\n+{\n+  class MachineFunction;\n+  class MachineInstr:public ilist_node < MachineInstr >\n+  {\n+  public:const MachineBasicBlock *getParent () const\n+    {\n+    }\n+    const MachineOperand & getOperand (unsigned i) const\n+    {\n+    }\n+    bool registerDefIsDead (unsigned Reg, const TargetRegisterInfo * TRI =\n+\t\t\t    __null) const\n+    {\n+    }\n+  };\n+  class AnalysisResolver;\n+  class Pass\n+  {\n+    AnalysisResolver *Resolver;\n+    intptr_t PassID;\n+  public:  explicit Pass (intptr_t pid):Resolver (0), PassID (pid)\n+    {\n+    }\n+    explicit Pass (const void *pid):Resolver (0), PassID ((intptr_t) pid)\n+    {\n+    }\n+    template < typename AnalysisType > AnalysisType & getAnalysis () const;\n+  };\n+  class FunctionPass:public Pass\n+  {\n+  public:explicit FunctionPass (intptr_t pid):Pass (pid)\n+    {\n+    }\n+    explicit FunctionPass (const void *pid):Pass (pid)\n+    {\n+    }\n+  };\n+  class PassInfo\n+  {\n+  public:typedef Pass *(*NormalCtor_t) ();\n+  private:const char *const PassName;\n+    const char *const PassArgument;\n+    const intptr_t PassID;\n+    const bool IsCFGOnlyPass;\n+    const bool IsAnalysis;\n+    const bool IsAnalysisGroup;\n+    NormalCtor_t NormalCtor;\n+  public:   PassInfo (const char *name, const char *arg, intptr_t pi, NormalCtor_t normal = 0, bool isCFGOnly = false, bool is_analysis = false):PassName (name), PassArgument (arg), PassID (pi),\n+      IsCFGOnlyPass (isCFGOnly), IsAnalysis (is_analysis),\n+      IsAnalysisGroup (false), NormalCtor (normal)\n+    {\n+    }\n+  };\n+  template < typename PassName > Pass * callDefaultCtor ()\n+  {\n+    return new PassName ();\n+  }\n+  template < typename passName > struct RegisterPass:public PassInfo\n+  {\n+  RegisterPass (const char *PassArg, const char *Name, bool CFGOnly = false, bool is_analysis = false):PassInfo (Name, PassArg, intptr_t (&passName::ID),\n+\t      PassInfo::NormalCtor_t (callDefaultCtor < passName >), CFGOnly,\n+\t      is_analysis)\n+    {\n+    }\n+  };\n+  template < typename T > class SmallVectorImpl\n+  {\n+  };\n+  template < typename T,\n+    unsigned N > class SmallVector:public SmallVectorImpl < T >\n+  {\n+  };\n+  class MachineFunctionPass:public FunctionPass\n+  {\n+  protected:explicit MachineFunctionPass (intptr_t ID):FunctionPass (ID)\n+    {\n+    }\n+    explicit MachineFunctionPass (void *ID):FunctionPass (ID)\n+    {\n+    }\n+    virtual bool runOnMachineFunction (MachineFunction & MF) = 0;\n+  };\n+  class LiveIndex\n+  {\n+  private:unsigned index;\n+  };\n+  class VNInfo\n+  {\n+  };\n+  struct LiveRange\n+  {\n+    LiveIndex start;\n+    LiveIndex end;\n+    VNInfo *valno;\n+  };\n+  class LiveInterval\n+  {\n+  public:typedef SmallVector < LiveRange, 4 > Ranges;\n+    bool containsOneValue () const\n+    {\n+    }\n+    LiveRange *getLiveRangeContaining (LiveIndex Idx)\n+    {\n+    }\n+    void removeRange (LiveIndex Start, LiveIndex End, bool RemoveDeadValNo =\n+\t\t      false);\n+    void removeRange (LiveRange LR, bool RemoveDeadValNo = false)\n+    {\n+      removeRange (LR.start, LR.end, RemoveDeadValNo);\n+    }\n+  };\n+  class LiveIntervals:public MachineFunctionPass\n+  {\n+  public:static char ID;\n+    LiveIndex getDefIndex (LiveIndex index)\n+    {\n+    }\n+    LiveInterval & getInterval (unsigned reg)\n+    {\n+    }\n+    LiveIndex getInstructionIndex (const MachineInstr * instr) const\n+    {\n+    }\n+  };\n+}\n+\n+using namespace llvm;\n+namespace\n+{\n+struct __attribute__ ((visibility (\"hidden\"))) StrongPHIElimination:public\n+    MachineFunctionPass\n+  {\n+    static char ID;\n+  StrongPHIElimination ():MachineFunctionPass (&ID)\n+    {\n+    }\n+    bool runOnMachineFunction (MachineFunction & Fn);\n+  };\n+}\n+\n+static RegisterPass < StrongPHIElimination > X (\"strong-phi-node-elimination\",\n+\t\t\t\t\t\t\"Eliminate PHI nodes for register allocation, intelligently\");\n+bool\n+StrongPHIElimination::runOnMachineFunction (MachineFunction & Fn)\n+{\n+  LiveIntervals & LI = getAnalysis < LiveIntervals > ();\n+  std::vector < MachineInstr * >phis;\n+  for (std::vector < MachineInstr * >::iterator I = phis.begin (), E =\n+       phis.end (); I != E;)\n+    {\n+      MachineInstr *PInstr = *(I++);\n+      unsigned DestReg = PInstr->getOperand (0).getReg ();\n+      LiveInterval & PI = LI.getInterval (DestReg);\n+      if (PInstr->registerDefIsDead (DestReg))\n+\t{\n+\t  if (PI.containsOneValue ())\n+\t    {\n+\t      LiveIndex idx =\n+\t\tLI.getDefIndex (LI.getInstructionIndex (PInstr));\n+\t      PI.removeRange (*PI.getLiveRangeContaining (idx), true);\n+\t    }\n+\t}\n+    }\n+}"}, {"sha": "a86a4416ec864cd6a756ab26e4cfbf83685cc37b", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a1326b3927310096b72d919ed94fbe7e66a7cdf/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a1326b3927310096b72d919ed94fbe7e66a7cdf/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=8a1326b3927310096b72d919ed94fbe7e66a7cdf", "patch": "@@ -1304,7 +1304,8 @@ build_ref_for_offset_1 (tree *res, tree type, HOST_WIDE_INT offset,\n /* Construct an expression that would reference a part of aggregate *EXPR of\n    type TYPE at the given OFFSET of the type EXP_TYPE.  If EXPR is NULL, the\n    function only determines whether it can build such a reference without\n-   actually doing it.\n+   actually doing it, otherwise, the tree it points to is unshared first and\n+   then used as a base for furhter sub-references.\n \n    FIXME: Eventually this should be replaced with\n    maybe_fold_offset_to_reference() from tree-ssa-ccp.c but that requires a\n@@ -1317,6 +1318,9 @@ build_ref_for_offset (tree *expr, tree type, HOST_WIDE_INT offset,\n {\n   location_t loc = expr ? EXPR_LOCATION (*expr) : UNKNOWN_LOCATION;\n \n+  if (expr)\n+    *expr = unshare_expr (*expr);\n+\n   if (allow_ptr && POINTER_TYPE_P (type))\n     {\n       type = TREE_TYPE (type);\n@@ -1759,7 +1763,7 @@ create_artificial_child_access (struct access *parent, struct access *model,\n    access but LACC is not, change the type of the latter, if possible.  */\n \n static bool\n-propagate_subacesses_accross_link (struct access *lacc, struct access *racc)\n+propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n {\n   struct access *rchild;\n   HOST_WIDE_INT norm_delta = lacc->offset - racc->offset;\n@@ -1800,7 +1804,7 @@ propagate_subacesses_accross_link (struct access *lacc, struct access *racc)\n \t      rchild->grp_hint = 1;\n \t      new_acc->grp_hint |= new_acc->grp_read;\n \t      if (rchild->first_child)\n-\t\tret |= propagate_subacesses_accross_link (new_acc, rchild);\n+\t\tret |= propagate_subaccesses_across_link (new_acc, rchild);\n \t    }\n \t  continue;\n \t}\n@@ -1818,7 +1822,7 @@ propagate_subacesses_accross_link (struct access *lacc, struct access *racc)\n \t{\n \t  ret = true;\n \t  if (racc->first_child)\n-\t    propagate_subacesses_accross_link (new_acc, rchild);\n+\t    propagate_subaccesses_across_link (new_acc, rchild);\n \t}\n     }\n \n@@ -1844,7 +1848,7 @@ propagate_all_subaccesses (void)\n \t  if (!bitmap_bit_p (candidate_bitmap, DECL_UID (lacc->base)))\n \t    continue;\n \t  lacc = lacc->group_representative;\n-\t  if (propagate_subacesses_accross_link (lacc, racc)\n+\t  if (propagate_subaccesses_across_link (lacc, racc)\n \t      && lacc->first_link)\n \t    add_access_to_work_queue (lacc);\n \t}\n@@ -1960,7 +1964,7 @@ generate_subtree_copies (struct access *access, tree agg,\n {\n   do\n     {\n-      tree expr = unshare_expr (agg);\n+      tree expr = agg;\n \n       if (chunk_size && access->offset >= start_offset + chunk_size)\n \treturn;\n@@ -2235,7 +2239,7 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \t\trhs = unshare_expr (lacc->expr);\n \t      else\n \t\t{\n-\t\t  rhs = unshare_expr (top_racc->base);\n+\t\t  rhs = top_racc->base;\n \t\t  repl_found = build_ref_for_offset (&rhs,\n \t\t\t\t\t\t     TREE_TYPE (top_racc->base),\n \t\t\t\t\t\t     offset, lacc->type, false);\n@@ -2372,7 +2376,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  if (AGGREGATE_TYPE_P (TREE_TYPE (lhs))\n \t      && !access_has_children_p (lacc))\n \t    {\n-\t      tree expr = unshare_expr (lhs);\n+\t      tree expr = lhs;\n \t      if (build_ref_for_offset (&expr, TREE_TYPE (lhs), 0,\n \t\t\t\t\tTREE_TYPE (rhs), false))\n \t\t{\n@@ -2383,7 +2387,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  else if (AGGREGATE_TYPE_P (TREE_TYPE (rhs))\n \t\t   && !access_has_children_p (racc))\n \t    {\n-\t      tree expr = unshare_expr (rhs);\n+\t      tree expr = rhs;\n \t      if (build_ref_for_offset (&expr, TREE_TYPE (rhs), 0,\n \t\t\t\t\tTREE_TYPE (lhs), false))\n \t\trhs = expr;"}]}