{"sha": "fc14ff611181c274584c7963bc597a6ca50c20a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMxNGZmNjExMTgxYzI3NDU4NGM3OTYzYmM1OTdhNmNhNTBjMjBhMQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2020-10-01T16:11:02Z"}, "committer": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2021-04-29T12:37:32Z"}, "message": "[omp, simt] Handle alternative IV\n\nConsider the test-case libgomp.c/pr81778.c added in this commit, with\nthis core loop (note: CANARY_SIZE set to 0 for simplicity):\n...\n  int s = 1;\n  #pragma omp target simd\n  for (int i = N - 1; i > -1; i -= s)\n    a[i] = 1;\n...\nwhich, given that N is 32, sets a[0..31] to 1.\n\nAfter omp-expand, this looks like:\n...\n  <bb 5> :\n  simduid.7 = .GOMP_SIMT_ENTER (simduid.7);\n  .omp_simt.8 = .GOMP_SIMT_ENTER_ALLOC (simduid.7);\n  D.3193 = -s;\n  s.9 = s;\n  D.3204 = .GOMP_SIMT_LANE ();\n  D.3205 = -s.9;\n  D.3206 = (int) D.3204;\n  D.3207 = D.3205 * D.3206;\n  i = D.3207 + 31;\n  D.3209 = 0;\n  D.3210 = -s.9;\n  D.3211 = D.3210 - i;\n  D.3210 = -s.9;\n  D.3212 = D.3211 / D.3210;\n  D.3213 = (unsigned int) D.3212;\n  D.3213 = i >= 0 ? D.3213 : 0;\n\n  <bb 19> :\n  if (D.3209 < D.3213)\n    goto <bb 6>; [87.50%]\n  else\n    goto <bb 7>; [12.50%]\n\n  <bb 6> :\n  a[i] = 1;\n  D.3215 = -s.9;\n  D.3219 = .GOMP_SIMT_VF ();\n  D.3216 = (int) D.3219;\n  D.3220 = D.3215 * D.3216;\n  i = D.3220 + i;\n  D.3209 = D.3209 + 1;\n  goto <bb 19>; [100.00%]\n...\n\nOn nvptx, the first time bb6 is executed, i is in the 0..31 range (depending\non the lane that is executing) at bb entry.\n\nSo we have the following sequence:\n- a[0..31] is set to 1\n- i is updated to -32..-1\n- D.3209 is updated to 1 (being 0 initially)\n- bb19 is executed, and if condition (D.3209 < D.3213) == (1 < 32) evaluates\n  to true\n- bb6 is once more executed, which should not happen because all the elements\n  that needed to be handled were already handled.\n- consequently, elements that should not be written are written\n- with CANARY_SIZE == 0, we may run into a libgomp error:\n  ...\n  libgomp: cuCtxSynchronize error: an illegal memory access was encountered\n  ...\n  and with CANARY_SIZE unmodified, we run into:\n  ...\n  Expected 0, got 1 at base[-961]\n  Aborted (core dumped)\n  ...\n\nThe cause of this is as follows:\n- because the step s is a variable rather than a constant, an alternative\n  IV (D.3209 in our example) is generated in expand_omp_simd, and the\n  loop condition is tested in terms of the alternative IV rather than\n  the original IV (i in our example).\n- the SIMT code in expand_omp_simd works by modifying step and initial value.\n- The initial value fd->loop.n1 is loaded into a variable n1, which is\n  modified by the SIMT code and then used there-after.\n- The step fd->loop.step is loaded into a variable step, which is modified\n  by the SIMT code, but afterwards there are uses of both step and\n  fd->loop.step.\n- There are uses of fd->loop.step in the alternative IV handling code,\n  which should use step instead.\n\nFix this by introducing an additional variable orig_step, which is not\nmodified by the SIMT code and replacing all remaining uses of fd->loop.step\nby either step or orig_step.\n\nBuild on x86_64-linux with nvptx accelerator, tested libgomp.\n\nThis fixes for-5.c and for-6.c FAILs I'm currently seeing on a quadro m1200\nwith driver 450.66.\n\ngcc/ChangeLog:\n\n2020-10-02  Tom de Vries  <tdevries@suse.de>\n\n\t* omp-expand.c (expand_omp_simd): Add step_orig, and replace uses of\n\tfd->loop.step by either step or orig_step.\n\nlibgomp/ChangeLog:\n\n2020-10-02  Tom de Vries  <tdevries@suse.de>\n\n\t* testsuite/libgomp.c/pr81778.c: New test.", "tree": {"sha": "60aa3f984f115703a7bba3e06765f50b8208b7ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60aa3f984f115703a7bba3e06765f50b8208b7ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc14ff611181c274584c7963bc597a6ca50c20a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc14ff611181c274584c7963bc597a6ca50c20a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc14ff611181c274584c7963bc597a6ca50c20a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc14ff611181c274584c7963bc597a6ca50c20a1/comments", "author": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d6f7aa409ebe37ea9eac25cc131f4a8f03acfa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d6f7aa409ebe37ea9eac25cc131f4a8f03acfa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d6f7aa409ebe37ea9eac25cc131f4a8f03acfa3"}], "stats": {"total": 59, "additions": 54, "deletions": 5}, "files": [{"sha": "0f843bad79a29864df8ba25398d43a71033d7491", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc14ff611181c274584c7963bc597a6ca50c20a1/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc14ff611181c274584c7963bc597a6ca50c20a1/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=fc14ff611181c274584c7963bc597a6ca50c20a1", "patch": "@@ -6360,6 +6360,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n       n2 = OMP_CLAUSE_DECL (innerc);\n     }\n   tree step = fd->loop.step;\n+  tree orig_step = step; /* May be different from step if is_simt.  */\n \n   bool is_simt = omp_find_clause (gimple_omp_for_clauses (fd->for_stmt),\n \t\t\t\t  OMP_CLAUSE__SIMT_);\n@@ -6510,7 +6511,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n   tree altv = NULL_TREE, altn2 = NULL_TREE;\n   if (fd->collapse == 1\n       && !broken_loop\n-      && TREE_CODE (fd->loops[0].step) != INTEGER_CST)\n+      && TREE_CODE (orig_step) != INTEGER_CST)\n     {\n       /* The vectorizer currently punts on loops with non-constant steps\n \t for the main IV (can't compute number of iterations and gives up\n@@ -6526,18 +6527,18 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \titype = signed_type_for (itype);\n       t = build_int_cst (itype, (fd->loop.cond_code == LT_EXPR ? -1 : 1));\n       t = fold_build2 (PLUS_EXPR, itype,\n-\t\t       fold_convert (itype, fd->loop.step), t);\n+\t\t       fold_convert (itype, step), t);\n       t = fold_build2 (PLUS_EXPR, itype, t, fold_convert (itype, n2));\n       t = fold_build2 (MINUS_EXPR, itype, t,\n \t\t       fold_convert (itype, fd->loop.v));\n       if (TYPE_UNSIGNED (itype) && fd->loop.cond_code == GT_EXPR)\n \tt = fold_build2 (TRUNC_DIV_EXPR, itype,\n \t\t\t fold_build1 (NEGATE_EXPR, itype, t),\n \t\t\t fold_build1 (NEGATE_EXPR, itype,\n-\t\t\t\t      fold_convert (itype, fd->loop.step)));\n+\t\t\t\t      fold_convert (itype, step)));\n       else\n \tt = fold_build2 (TRUNC_DIV_EXPR, itype, t,\n-\t\t\t fold_convert (itype, fd->loop.step));\n+\t\t\t fold_convert (itype, step));\n       t = fold_convert (TREE_TYPE (altv), t);\n       altn2 = create_tmp_var (TREE_TYPE (altv));\n       expand_omp_build_assign (&gsi, altn2, t);\n@@ -6685,7 +6686,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n   if (is_simt)\n     {\n       gsi = gsi_start_bb (l2_bb);\n-      step = fold_build2 (MINUS_EXPR, TREE_TYPE (step), fd->loop.step, step);\n+      step = fold_build2 (MINUS_EXPR, TREE_TYPE (step), orig_step, step);\n       if (POINTER_TYPE_P (type))\n \tt = fold_build_pointer_plus (fd->loop.v, step);\n       else"}, {"sha": "571668eb36a96ce8290a677f7d5ae8e4bb5a86db", "filename": "libgomp/testsuite/libgomp.c/pr81778.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc14ff611181c274584c7963bc597a6ca50c20a1/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr81778.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc14ff611181c274584c7963bc597a6ca50c20a1/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr81778.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr81778.c?ref=fc14ff611181c274584c7963bc597a6ca50c20a1", "patch": "@@ -0,0 +1,48 @@\n+/* Minimized from for-5.c.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+/* Size of array we want to write.  */\n+#define N 32\n+\n+/* Size of extra space before and after.  */\n+#define CANARY_SIZE (N * 32)\n+\n+/* Start of array we want to write.  */\n+#define BASE (CANARY_SIZE)\n+\n+// Total size to be allocated.\n+#define ALLOC_SIZE (CANARY_SIZE + N + CANARY_SIZE)\n+\n+#pragma omp declare target\n+int a[ALLOC_SIZE];\n+#pragma omp end declare target\n+\n+int\n+main (void)\n+{\n+  /* Use variable step in for loop.  */\n+  int s = 1;\n+\n+#pragma omp target update to(a)\n+\n+  /* Write a[BASE] .. a[BASE + N - 1].  */\n+#pragma omp target simd\n+  for (int i = N - 1; i > -1; i -= s)\n+    a[BASE + i] = 1;\n+\n+#pragma omp target update from(a)\n+\n+  for (int i = 0; i < ALLOC_SIZE; i++)\n+    {\n+      int expected = (BASE <= i && i < BASE + N) ? 1 : 0;\n+      if (a[i] == expected)\n+\tcontinue;\n+\n+      printf (\"Expected %d, got %d at base[%d]\\n\", expected, a[i], i - BASE);\n+      abort ();\n+    }\n+\n+  return 0;\n+}"}]}