{"sha": "511dcace074c36f4c8d7fcf835ba795fa82268c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTExZGNhY2UwNzRjMzZmNGM4ZDdmY2Y4MzViYTc5NWZhODIyNjhjMA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-01-09T17:02:11Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-01-09T17:02:11Z"}, "message": "PR rtl-optimization/pr55829\n\n2013-01-09  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/pr55829\n\t* lra-constraints.c (match_reload): Add code for absent output.\n\t(curr_insn_transform): Add code for reloads of matched inputs\n\twithout output.\n\n2013-01-09  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/pr55829\n\t* gcc.target/i386/pr55829.c: New.\n\nFrom-SVN: r195057", "tree": {"sha": "4dc6d2190928cecfc3a5fdb3cae0d0ea9df303f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4dc6d2190928cecfc3a5fdb3cae0d0ea9df303f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/511dcace074c36f4c8d7fcf835ba795fa82268c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/511dcace074c36f4c8d7fcf835ba795fa82268c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/511dcace074c36f4c8d7fcf835ba795fa82268c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/511dcace074c36f4c8d7fcf835ba795fa82268c0/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b0fe4f42113a4028e50d5882166be975b421657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b0fe4f42113a4028e50d5882166be975b421657", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b0fe4f42113a4028e50d5882166be975b421657"}], "stats": {"total": 90, "additions": 76, "deletions": 14}, "files": [{"sha": "cbdc1adca959422b75878099ddb8cb2fc6911c5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/511dcace074c36f4c8d7fcf835ba795fa82268c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/511dcace074c36f4c8d7fcf835ba795fa82268c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=511dcace074c36f4c8d7fcf835ba795fa82268c0", "patch": "@@ -1,3 +1,10 @@\n+2013-01-09  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/pr55829\n+\t* lra-constraints.c (match_reload): Add code for absent output.\n+\t(curr_insn_transform): Add code for reloads of matched inputs\n+\twithout output.\n+\n 2013-01-09  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (*vec_interleave_highv2df): Change mode"}, {"sha": "fcece42970433b076fc566a4ec8c891d28f41ee8", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/511dcace074c36f4c8d7fcf835ba795fa82268c0/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/511dcace074c36f4c8d7fcf835ba795fa82268c0/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=511dcace074c36f4c8d7fcf835ba795fa82268c0", "patch": "@@ -658,8 +658,9 @@ narrow_reload_pseudo_class (rtx reg, enum reg_class cl)\n \n /* Generate reloads for matching OUT and INS (array of input operand\n    numbers with end marker -1) with reg class GOAL_CLASS.  Add input\n-   and output reloads correspondingly to the lists *BEFORE and\n-   *AFTER.  */\n+   and output reloads correspondingly to the lists *BEFORE and *AFTER.\n+   OUT might be negative.  In this case we generate input reloads for\n+   matched input operands INS.  */\n static void\n match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t      rtx *before, rtx *after)\n@@ -668,10 +669,10 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n   rtx new_in_reg, new_out_reg, reg, clobber;\n   enum machine_mode inmode, outmode;\n   rtx in_rtx = *curr_id->operand_loc[ins[0]];\n-  rtx out_rtx = *curr_id->operand_loc[out];\n+  rtx out_rtx = out < 0 ? in_rtx : *curr_id->operand_loc[out];\n \n-  outmode = curr_operand_mode[out];\n   inmode = curr_operand_mode[ins[0]];\n+  outmode = out < 0 ? inmode : curr_operand_mode[out];\n   push_to_sequence (*before);\n   if (inmode != outmode)\n     {\n@@ -746,14 +747,13 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t= lra_create_new_reg_with_unique_value (outmode, out_rtx,\n \t\t\t\t\t\tgoal_class, \"\");\n     }\n-  /* In and out operand can be got from transformations before\n-     processing insn constraints.  One example of such transformations\n-     is subreg reloading (see function simplify_operand_subreg).  The\n-     new pseudos created by the transformations might have inaccurate\n+  /* In operand can be got from transformations before processing insn\n+     constraints.  One example of such transformations is subreg\n+     reloading (see function simplify_operand_subreg).  The new\n+     pseudos created by the transformations might have inaccurate\n      class (ALL_REGS) and we should make their classes more\n      accurate.  */\n   narrow_reload_pseudo_class (in_rtx, goal_class);\n-  narrow_reload_pseudo_class (out_rtx, goal_class);\n   lra_emit_move (copy_rtx (new_in_reg), in_rtx);\n   *before = get_insns ();\n   end_sequence ();\n@@ -765,6 +765,10 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n       *curr_id->operand_loc[in] = new_in_reg;\n     }\n   lra_update_dups (curr_id, ins);\n+  if (out < 0)\n+    return;\n+  /* See a comment for the input operand above.  */\n+  narrow_reload_pseudo_class (out_rtx, goal_class);\n   if (find_reg_note (curr_insn, REG_UNUSED, out_rtx) == NULL_RTX)\n     {\n       start_sequence ();\n@@ -2597,6 +2601,7 @@ curr_insn_transform (void)\n   int n_alternatives;\n   int commutative;\n   signed char goal_alt_matched[MAX_RECOG_OPERANDS][MAX_RECOG_OPERANDS];\n+  signed char match_inputs[MAX_RECOG_OPERANDS + 1];\n   rtx before, after;\n   bool alt_p = false;\n   /* Flag that the insn has been changed through a transformation.  */\n@@ -3052,17 +3057,28 @@ curr_insn_transform (void)\n \t       && (curr_static_id->operand[goal_alt_matched[i][0]].type\n \t\t   == OP_OUT))\n \t{\n-\t  signed char arr[2];\n-\n-\t  arr[0] = i;\n-\t  arr[1] = -1;\n-\t  match_reload (goal_alt_matched[i][0], arr,\n+\t  /* generate reloads for input and matched outputs.  */\n+\t  match_inputs[0] = i;\n+\t  match_inputs[1] = -1;\n+\t  match_reload (goal_alt_matched[i][0], match_inputs,\n \t\t\tgoal_alt[i], &before, &after);\n \t}\n       else if (curr_static_id->operand[i].type == OP_OUT\n \t       && (curr_static_id->operand[goal_alt_matched[i][0]].type\n \t\t   == OP_IN))\n+\t/* Generate reloads for output and matched inputs.  */\n \tmatch_reload (i, goal_alt_matched[i], goal_alt[i], &before, &after);\n+      else if (curr_static_id->operand[i].type == OP_IN\n+\t       && (curr_static_id->operand[goal_alt_matched[i][0]].type\n+\t\t   == OP_IN))\n+\t{\n+\t  /* Generate reloads for matched inputs.  */\n+\t  match_inputs[0] = i;\n+\t  for (j = 0; (k = goal_alt_matched[i][j]) >= 0; j++)\n+\t    match_inputs[j + 1] = k;\n+\t  match_inputs[j + 1] = -1;\n+\t  match_reload (-1, match_inputs, goal_alt[i], &before, &after);\n+\t}\n       else\n \t/* We must generate code in any case when function\n \t   process_alt_operands decides that it is possible.  */"}, {"sha": "b545fe1b8dbe54e83e79d6e9f580a87c1e52ed32", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/511dcace074c36f4c8d7fcf835ba795fa82268c0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/511dcace074c36f4c8d7fcf835ba795fa82268c0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=511dcace074c36f4c8d7fcf835ba795fa82268c0", "patch": "@@ -1,3 +1,8 @@\n+2013-01-09  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/pr55829\n+\t* gcc.target/i386/pr55829.c: New.\n+\n 2013-01-09  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/55758"}, {"sha": "be70ba2f24f91ba4d2b0ac4b108f27acb446996c", "filename": "gcc/testsuite/gcc.target/i386/pr55829.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/511dcace074c36f4c8d7fcf835ba795fa82268c0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55829.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/511dcace074c36f4c8d7fcf835ba795fa82268c0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55829.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55829.c?ref=511dcace074c36f4c8d7fcf835ba795fa82268c0", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse3 -fno-expensive-optimizations\" } */\n+\n+typedef double __m128d __attribute__ ((__vector_size__ (16)));\n+\n+extern double p1[];\n+extern double p2[];\n+extern double ck[];\n+extern int n;\n+\n+__attribute__((__noinline__, __noclone__)) int chk_pd (double *v1, double *v2)\n+{\n+  return v2[n] != v1[n];\n+}\n+\n+static inline void sse3_test_movddup_reg_subsume_ldsd (double *i1, double *r)\n+{\n+  __m128d t1 = (__m128d){*i1, 0};\n+  __m128d t2 = __builtin_ia32_shufpd (t1, t1, 0);\n+  __builtin_ia32_storeupd (r, t2);\n+}\n+\n+int sse3_test (void)\n+{\n+  int i = 0;\n+  int fail = 0;\n+  for (; i < 80; i += 1)\n+    {\n+      ck[0] = p1[0];\n+      fail += chk_pd (ck, p2);\n+      sse3_test_movddup_reg_subsume_ldsd (p1, p2);\n+    }\n+  return fail;\n+}"}]}