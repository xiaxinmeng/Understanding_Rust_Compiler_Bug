{"sha": "ffd454b92ba6ff5499cf57f82a2b0f4cee59978c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZkNDU0YjkyYmE2ZmY1NDk5Y2Y1N2Y4MmEyYjBmNGNlZTU5OTc4Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-22T19:18:10Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-22T19:18:10Z"}, "message": "c++: Handle array members in build_comparison_op [PR93480]\n\nhttp://eel.is/c++draft/class.compare.default#6 says for the\nexpanded list of subobjects:\n\"In that list, any subobject of array type is recursively expanded\nto the sequence of its elements, in the order of increasing subscript.\"\nbut build_comparison_op just tried to compare the whole arrays, which\nfailed and therefore the defaulted comparison was deleted.\n\nThe following patch instead compares the array elements, and\nif info.defining, adds runtime loops around it so that it iterates\nover increasing subscripts.\n\nFor flexible array members it punts, we don't know how large those will be,\nfor zero sized arrays it doesn't even try to compare the elements,\nbecause if there are no elements, there is nothing to compare, and\nfor [1] arrays it will not emit a loop because it is enough to use\n[0] array ref to cover everything.\n\n2020-12-21  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/93480\n\t* method.c (common_comparison_type): If comps[i] is a TREE_LIST,\n\tuse its TREE_VALUE instead.\n\t(build_comparison_op): Handle array members.\n\n\t* g++.dg/cpp2a/spaceship-synth10.C: New test.\n\t* g++.dg/cpp2a/spaceship-synth-neg5.C: New test.", "tree": {"sha": "8e9be7258613548484c6d7e387cea7c9c66b4862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e9be7258613548484c6d7e387cea7c9c66b4862"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffd454b92ba6ff5499cf57f82a2b0f4cee59978c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffd454b92ba6ff5499cf57f82a2b0f4cee59978c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffd454b92ba6ff5499cf57f82a2b0f4cee59978c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffd454b92ba6ff5499cf57f82a2b0f4cee59978c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae27ce51e4860388d2b4129e2a80cc7f292368b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae27ce51e4860388d2b4129e2a80cc7f292368b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae27ce51e4860388d2b4129e2a80cc7f292368b5"}], "stats": {"total": 167, "additions": 162, "deletions": 5}, "files": [{"sha": "dd351734b5e3fef1a61bbf3cc9ce5ba50dd64575", "filename": "gcc/cp/method.c", "status": "modified", "additions": 89, "deletions": 5, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd454b92ba6ff5499cf57f82a2b0f4cee59978c/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd454b92ba6ff5499cf57f82a2b0f4cee59978c/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=ffd454b92ba6ff5499cf57f82a2b0f4cee59978c", "patch": "@@ -1230,6 +1230,8 @@ common_comparison_type (vec<tree> &comps)\n   for (unsigned i = 0; i < comps.length(); ++i)\n     {\n       tree comp = comps[i];\n+      if (TREE_CODE (comp) == TREE_LIST)\n+\tcomp = TREE_VALUE (comp);\n       tree ctype = TREE_TYPE (comp);\n       comp_cat_tag tag = cat_tag_for (ctype);\n       /* build_comparison_op already checked this.  */\n@@ -1419,10 +1421,47 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t      continue;\n \t    }\n \n-\t  tree lhs_mem = build3 (COMPONENT_REF, expr_type, lhs, field,\n-\t\t\t\t NULL_TREE);\n-\t  tree rhs_mem = build3 (COMPONENT_REF, expr_type, rhs, field,\n-\t\t\t\t NULL_TREE);\n+\t  tree lhs_mem = build3_loc (field_loc, COMPONENT_REF, expr_type, lhs,\n+\t\t\t\t     field, NULL_TREE);\n+\t  tree rhs_mem = build3_loc (field_loc, COMPONENT_REF, expr_type, rhs,\n+\t\t\t\t     field, NULL_TREE);\n+\t  tree loop_indexes = NULL_TREE;\n+\t  while (TREE_CODE (expr_type) == ARRAY_TYPE)\n+\t    {\n+\t      /* Flexible array member.  */\n+\t      if (TYPE_DOMAIN (expr_type) == NULL_TREE\n+\t\t  || TYPE_MAX_VALUE (TYPE_DOMAIN (expr_type)) == NULL_TREE)\n+\t\t{\n+\t\t  if (complain & tf_error)\n+\t\t    inform (field_loc, \"cannot default compare \"\n+\t\t\t\t       \"flexible array member\");\n+\t\t  bad = true;\n+\t\t  break;\n+\t\t}\n+\t      tree maxval = TYPE_MAX_VALUE (TYPE_DOMAIN (expr_type));\n+\t      /* [0] array.  No subobjects to compare, just skip it.  */\n+\t      if (integer_all_onesp (maxval))\n+\t\tbreak;\n+\t      tree idx;\n+\t      /* [1] array, no loop needed, just add [0] ARRAY_REF.\n+\t\t Similarly if !info.defining.  */\n+\t      if (integer_zerop (maxval) || !info.defining)\n+\t\tidx = size_zero_node;\n+\t      /* Some other array, will need runtime loop.  */\n+\t      else\n+\t\t{\n+\t\t  idx = force_target_expr (sizetype, maxval, complain);\n+\t\t  loop_indexes = tree_cons (idx, NULL_TREE, loop_indexes);\n+\t\t}\n+\t      expr_type = TREE_TYPE (expr_type);\n+\t      lhs_mem = build4_loc (field_loc, ARRAY_REF, expr_type, lhs_mem,\n+\t\t\t\t    idx, NULL_TREE, NULL_TREE);\n+\t      rhs_mem = build4_loc (field_loc, ARRAY_REF, expr_type, rhs_mem,\n+\t\t\t\t    idx, NULL_TREE, NULL_TREE);\n+\t    }\n+\t  if (TREE_CODE (expr_type) == ARRAY_TYPE)\n+\t    continue;\n+\n \t  tree overload = NULL_TREE;\n \t  tree comp = build_new_op (field_loc, code, flags, lhs_mem, rhs_mem,\n \t\t\t\t    NULL_TREE, &overload,\n@@ -1486,6 +1525,18 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t      bad = true;\n \t      continue;\n \t    }\n+\t  /* Most of the time, comp is the expression that should be evaluated\n+\t     to compare the two members.  If the expression needs to be\n+\t     evaluated more than once in a loop, it will be a TREE_LIST\n+\t     instead, whose TREE_VALUE is the expression for one array element,\n+\t     TREE_PURPOSE is innermost iterator temporary and if the array\n+\t     is multidimensional, TREE_CHAIN will contain another TREE_LIST\n+\t     with second innermost iterator in its TREE_PURPOSE and so on.  */\n+\t  if (loop_indexes)\n+\t    {\n+\t      TREE_VALUE (loop_indexes) = comp;\n+\t      comp = loop_indexes;\n+\t    }\n \t  comps.safe_push (comp);\n \t}\n       if (code == SPACESHIP_EXPR && is_auto (rettype))\n@@ -1502,8 +1553,38 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t{\n \t  tree comp = comps[i];\n \t  tree eq, retval = NULL_TREE, if_ = NULL_TREE;\n+\t  tree loop_indexes = NULL_TREE;\n \t  if (info.defining)\n-\t    if_ = begin_if_stmt ();\n+\t    {\n+\t      if (TREE_CODE (comp) == TREE_LIST)\n+\t\t{\n+\t\t  loop_indexes = comp;\n+\t\t  comp = TREE_VALUE (comp);\n+\t\t  loop_indexes = nreverse (loop_indexes);\n+\t\t  for (tree loop_index = loop_indexes; loop_index;\n+\t\t       loop_index = TREE_CHAIN (loop_index))\n+\t\t    {\n+\t\t      tree for_stmt = begin_for_stmt (NULL_TREE, NULL_TREE);\n+\t\t      tree idx = TREE_PURPOSE (loop_index);\n+\t\t      tree maxval = TARGET_EXPR_INITIAL (idx);\n+\t\t      TARGET_EXPR_INITIAL (idx) = size_zero_node;\n+\t\t      add_stmt (idx);\n+\t\t      finish_init_stmt (for_stmt);\n+\t\t      finish_for_cond (build2 (LE_EXPR, boolean_type_node, idx,\n+\t\t\t\t\t       maxval), for_stmt, false, 0);\n+\t\t      finish_for_expr (cp_build_unary_op (PREINCREMENT_EXPR,\n+\t\t\t\t\t\t\t  TARGET_EXPR_SLOT (idx),\n+\t\t\t\t\t\t\t  false, complain),\n+\t\t\t\t\t\t\t  for_stmt);\n+\t\t      /* Store in TREE_VALUE the for_stmt tree, so that we can\n+\t\t\t later on call finish_for_stmt on it (in the reverse\n+\t\t\t order).  */\n+\t\t      TREE_VALUE (loop_index) = for_stmt;\n+\t\t    }\n+\t\t  loop_indexes = nreverse (loop_indexes);\n+\t\t}\n+\t      if_ = begin_if_stmt ();\n+\t    }\n \t  /* Spaceship is specified to use !=, but for the comparison category\n \t     types, != is equivalent to !(==), so let's use == directly.  */\n \t  if (code == EQ_EXPR)\n@@ -1542,6 +1623,9 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t      finish_return_stmt (retval);\n \t      finish_else_clause (if_);\n \t      finish_if_stmt (if_);\n+\t      for (tree loop_index = loop_indexes; loop_index;\n+\t\t   loop_index = TREE_CHAIN (loop_index))\n+\t\tfinish_for_stmt (TREE_VALUE (loop_index));\n \t    }\n \t}\n       if (info.defining)"}, {"sha": "a01d3d3ead3ff6d3cb2d98deabd6fde9eab0469e", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth-neg5.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd454b92ba6ff5499cf57f82a2b0f4cee59978c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth-neg5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd454b92ba6ff5499cf57f82a2b0f4cee59978c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth-neg5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth-neg5.C?ref=ffd454b92ba6ff5499cf57f82a2b0f4cee59978c", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile { target c++20 } }\n+// { dg-options \"\" }\n+\n+#include <compare>\n+\n+struct C {\n+  int y;\n+  int x[];\t\t\t\t\t// { dg-message \"cannot default compare flexible array member\" }\n+  auto operator<=>(C const&) const = default;\t// { dg-message \"is implicitly deleted because the default definition would be ill-formed\" }\n+};\n+\n+bool\n+foo (C &c1, C &c2)\n+{\n+  return c1 > c2;\t// { dg-error \"use of deleted function\" }\n+}"}, {"sha": "235e0020caf25f82c57d4c189724de23ce011723", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth10.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd454b92ba6ff5499cf57f82a2b0f4cee59978c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd454b92ba6ff5499cf57f82a2b0f4cee59978c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth10.C?ref=ffd454b92ba6ff5499cf57f82a2b0f4cee59978c", "patch": "@@ -0,0 +1,57 @@\n+// { dg-do run { target c++20 } }\n+// { dg-options \"\" }\n+\n+#include <compare>\n+\n+struct C {\n+  int y;\n+  int x[4];\n+  auto operator<=>(C const&) const = default;\n+};\n+\n+struct D {\n+  int y;\n+  int x[1];\n+  auto operator<=>(D const&) const = default;\n+};\n+\n+struct E {\n+  int y;\n+  int x[0];\n+  auto operator<=>(E const&) const = default;\n+};\n+\n+int\n+main ()\n+{\n+  constexpr C c1 = { 1, { 2, 3, 4, 5 } };\n+  constexpr C c2 = { 1, { 2, 3, 5, 4 } };\n+  constexpr C c3 = { 1, { 2, 2, 6, 7 } };\n+  static_assert (c1 < c2);\n+  static_assert (c3 < c1);\n+  constexpr D d1 = { 1, { 2 } };\n+  constexpr D d2 = { 1, { 3 } };\n+  constexpr D d3 = { 1, { 1 } };\n+  static_assert (d1 < d2);\n+  static_assert (d3 < d1);\n+  constexpr E e1 = { 1, {} };\n+  constexpr E e2 = { 2, {} };\n+  constexpr E e3 = { 1, {} };\n+  static_assert (e1 < e2);\n+  static_assert (e1 == e3);\n+  C c4 = { 1, { 2, 3, 4, 5 } };\n+  C c5 = { 1, { 2, 3, 5, 4 } };\n+  C c6 = { 1, { 2, 2, 6, 7 } };\n+  if (c4 >= c5 || c6 >= c4)\n+    __builtin_abort ();\n+  D d4 = { 1, { 2 } };\n+  D d5 = { 1, { 3 } };\n+  D d6 = { 1, { 1 } };\n+  if (d4 >= d5 || d6 >= d4)\n+    __builtin_abort ();\n+  E e4 = { 1, {} };\n+  E e5 = { 2, {} };\n+  E e6 = { 1, {} };\n+  if (e4 >= e5 || e4 != e6)\n+    __builtin_abort ();\n+}"}]}