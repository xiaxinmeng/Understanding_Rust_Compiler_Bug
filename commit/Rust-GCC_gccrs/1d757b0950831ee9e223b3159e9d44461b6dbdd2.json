{"sha": "1d757b0950831ee9e223b3159e9d44461b6dbdd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ3NTdiMDk1MDgzMWVlOWUyMjNiMzE1OWU5ZDQ0NDYxYjZkYmRkMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-02-14T23:11:04Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-02-14T23:13:18Z"}, "message": "Fix duplicates for anonymous structures with -fdump-ada-spec\n\nThis fixes a weakness in the way -fdump-ada-spec builds names for\nanonymous structures in the C/C++ code, resulting in duplicate\nidentifiers under specific circumstances.\n\nc-family/\n\t* c-ada-spec.c: Include bitmap.h.\n\t(dump_ada_double_name): Rename into...\n\t(dump_anonymous_type_name): ...this.  Always use the TYPE_UID.\n\t(dump_ada_array_type): Adjust to above renaming.  Robustify.\n\t(dump_nested_types_1): New function copied from...  Add\n\tdumped_types parameter and pass it down to dump_nested_type.\n\t(dump_nested_types): ...this.  Remove parent parameter.  Just\n\tcall dump_nested_types_1 on an automatic bitmap.\n\t(dump_nested_type): Add dumped_types parameter.\n\t<ARRAY_TYPE>: Do not dump it if already present in dumped_types.\n\tAdjust recursive calls and adjust to above renaming.\n\t(dump_ada_declaration): Adjust call to dump_nested_types.\n\tTidy up and adjust to above renaming.\n\t(dump_ada_specs): Initialize and release bitmap obstack.", "tree": {"sha": "37aacbe9a28f7d755d8ae49bb049be25ff6b3ae4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37aacbe9a28f7d755d8ae49bb049be25ff6b3ae4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d757b0950831ee9e223b3159e9d44461b6dbdd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d757b0950831ee9e223b3159e9d44461b6dbdd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d757b0950831ee9e223b3159e9d44461b6dbdd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d757b0950831ee9e223b3159e9d44461b6dbdd2/comments", "author": null, "committer": null, "parents": [{"sha": "c26007ab17278729b8ba8eedd621cfb64b7e13d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c26007ab17278729b8ba8eedd621cfb64b7e13d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c26007ab17278729b8ba8eedd621cfb64b7e13d2"}], "stats": {"total": 155, "additions": 88, "deletions": 67}, "files": [{"sha": "e4250724e84f315de6fdccc97ff7b55fdc699f37", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d757b0950831ee9e223b3159e9d44461b6dbdd2/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d757b0950831ee9e223b3159e9d44461b6dbdd2/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=1d757b0950831ee9e223b3159e9d44461b6dbdd2", "patch": "@@ -1,3 +1,20 @@\n+2020-02-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-ada-spec.c: Include bitmap.h.\n+\t(dump_ada_double_name): Rename into...\n+\t(dump_anonymous_type_name): ...this.  Always use the TYPE_UID.\n+\t(dump_ada_array_type): Adjust to above renaming.  Robustify.\n+\t(dump_nested_types_1): New function copied from...  Add dumped_types\n+\tparameter and pass it down to dump_nested_type.\n+\t(dump_nested_types): ...this.  Remove parent parameter.  Just call\n+\tdump_nested_types_1 on an automatic bitmap.\n+\t(dump_nested_type): Add dumped_types parameter.\n+\t<ARRAY_TYPE>: Do not dump it if already present in dumped_types.\n+\tAdjust recursive calls and adjust to above renaming.\n+\t(dump_ada_declaration): Adjust call to dump_nested_types.\n+\tTidy up and adjust to above renaming.\n+\t(dump_ada_specs): Initialize and release bitmap obstack.\n+\n 2020-02-10  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/93640"}, {"sha": "6d9192f2a266bde53d0238259f0db52273a3b4d0", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 71, "deletions": 67, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d757b0950831ee9e223b3159e9d44461b6dbdd2/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d757b0950831ee9e223b3159e9d44461b6dbdd2/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=1d757b0950831ee9e223b3159e9d44461b6dbdd2", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"bitmap.h\"\n \n /* Local functions, macros and variables.  */\n static int  dump_ada_node (pretty_printer *, tree, tree, int, bool, bool);\n@@ -1475,30 +1476,21 @@ dump_ada_decl_name (pretty_printer *buffer, tree decl, bool limited_access)\n     }\n }\n \n-/* Dump in BUFFER a name based on both T1 and T2 followed by a suffix.  */\n+/* Dump in BUFFER a name for the type T, which is a _TYPE without TYPE_NAME.\n+   PARENT is the parent node of T.  */\n \n static void\n-dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2)\n+dump_anonymous_type_name (pretty_printer *buffer, tree t, tree parent)\n {\n-  if (DECL_NAME (t1))\n-    pp_ada_tree_identifier (buffer, DECL_NAME (t1), t1, false);\n+  if (DECL_NAME (parent))\n+    pp_ada_tree_identifier (buffer, DECL_NAME (parent), parent, false);\n   else\n     {\n       pp_string (buffer, \"anon\");\n-      pp_scalar (buffer, \"%d\", TYPE_UID (TREE_TYPE (t1)));\n+      pp_scalar (buffer, \"%d\", TYPE_UID (TREE_TYPE (parent)));\n     }\n \n-  pp_underscore (buffer);\n-\n-  if (DECL_NAME (t2))\n-    pp_ada_tree_identifier (buffer, DECL_NAME (t2), t2, false);\n-  else\n-    {\n-      pp_string (buffer, \"anon\");\n-      pp_scalar (buffer, \"%d\", TYPE_UID (TREE_TYPE (t2)));\n-    }\n-\n-  switch (TREE_CODE (TREE_TYPE (t2)))\n+  switch (TREE_CODE (t))\n     {\n     case ARRAY_TYPE:\n       pp_string (buffer, \"_array\");\n@@ -1516,6 +1508,8 @@ dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2)\n       pp_string (buffer, \"_unknown\");\n       break;\n     }\n+\n+  pp_scalar (buffer, \"%d\", TYPE_UID (t));\n }\n \n /* Dump in BUFFER aspect Import on a given node T.  SPC is the current\n@@ -1816,10 +1810,9 @@ dump_ada_array_type (pretty_printer *buffer, tree node, tree type, int spc)\n   /* Print the dimensions.  */\n   dump_ada_array_domains (buffer, node, spc);\n \n-  /* Print array's type.  */\n+  /* Print the component type.  */\n   if (!char_array)\n     {\n-      /* Retrieve the element type.  */\n       tree tmp = node;\n       while (TREE_CODE (tmp) == ARRAY_TYPE)\n \ttmp = TREE_TYPE (tmp);\n@@ -1829,10 +1822,12 @@ dump_ada_array_type (pretty_printer *buffer, tree node, tree type, int spc)\n       if (TREE_CODE (tmp) != POINTER_TYPE)\n \tpp_string (buffer, \"aliased \");\n \n-      if (TYPE_NAME (tmp) || !RECORD_OR_UNION_TYPE_P (tmp))\n+      if (TYPE_NAME (tmp)\n+\t  || (!RECORD_OR_UNION_TYPE_P (tmp)\n+\t      && TREE_CODE (tmp) != ENUMERAL_TYPE))\n \tdump_ada_node (buffer, tmp, node, spc, false, true);\n-      else\n-\tdump_ada_double_name (buffer, type, get_underlying_decl (tmp));\n+      else if (type)\n+\tdump_anonymous_type_name (buffer, tmp, type);\n     }\n }\n \n@@ -2469,10 +2464,11 @@ dump_forward_type (pretty_printer *buffer, tree type, tree t, int spc)\n   TREE_VISITED (decl) = 1;\n }\n \n-static void dump_nested_type (pretty_printer *, tree, tree, tree, int);\n+static void dump_nested_type (pretty_printer *, tree, tree, tree, bitmap, int);\n \n-/* Dump in BUFFER anonymous types nested inside T's definition.\n-   PARENT is the parent node of T.  SPC is the indentation level.\n+/* Dump in BUFFER anonymous types nested inside T's definition.  PARENT is the\n+   parent node of T.  DUMPED_TYPES is the bitmap of already dumped types.  SPC\n+   is the indentation level.\n \n    In C anonymous nested tagged types have no name whereas in C++ they have\n    one.  In C their TYPE_DECL is at top level whereas in C++ it is nested.\n@@ -2484,33 +2480,46 @@ static void dump_nested_type (pretty_printer *, tree, tree, tree, int);\n    pass on the nested TYPE_DECLs and a second pass on the unnamed types.  */\n \n static void\n-dump_nested_types (pretty_printer *buffer, tree t, tree parent, int spc)\n+dump_nested_types_1 (pretty_printer *buffer, tree t, tree parent,\n+\t\t     bitmap dumped_types, int spc)\n {\n   tree type, field;\n \n   /* Find possible anonymous pointers/arrays/structs/unions recursively.  */\n   type = TREE_TYPE (t);\n-  if (type == NULL_TREE)\n+  if (!type)\n     return;\n \n   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n     if (TREE_CODE (field) == TYPE_DECL\n \t&& DECL_NAME (field) != DECL_NAME (t)\n \t&& !DECL_ORIGINAL_TYPE (field)\n \t&& TYPE_NAME (TREE_TYPE (field)) != TYPE_NAME (type))\n-      dump_nested_type (buffer, field, t, parent, spc);\n+      dump_nested_type (buffer, field, t, parent, dumped_types, spc);\n \n   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n     if (TREE_CODE (field) == FIELD_DECL && !TYPE_NAME (TREE_TYPE (field)))\n-      dump_nested_type (buffer, field, t, parent, spc);\n+      dump_nested_type (buffer, field, t, parent, dumped_types, spc);\n }\n \n-/* Dump in BUFFER the anonymous type of FIELD inside T.\n-   PARENT is the parent node of T.  SPC is the indentation level.  */\n+/* Likewise, but to be invoked only at top level.  We dump each anonymous type\n+   nested inside T's definition exactly once, even if it is referenced several\n+   times in it (typically an array type), with a name prefixed by that of T.  */\n+\n+static void\n+dump_nested_types (pretty_printer *buffer, tree t, int spc)\n+{\n+  auto_bitmap dumped_types;\n+  dump_nested_types_1 (buffer, t, t, dumped_types, spc);\n+}\n+\n+/* Dump in BUFFER the anonymous type of FIELD inside T.  PARENT is the parent\n+   node of T.  DUMPED_TYPES is the bitmap of already dumped types.  SPC is the\n+   indentation level.  */\n \n static void\n dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n-\t\t  int spc)\n+\t\t  bitmap dumped_types, int spc)\n {\n   tree field_type = TREE_TYPE (field);\n   tree decl, tmp;\n@@ -2523,6 +2532,11 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n       break;\n \n     case ARRAY_TYPE:\n+      /* Anonymous array types are shared.  */\n+      if (!bitmap_set_bit (dumped_types, TYPE_UID (field_type)))\n+\treturn;\n+\n+      /* Recurse on the element type if need be.  */\n       tmp = TREE_TYPE (field_type);\n       while (TREE_CODE (tmp) == ARRAY_TYPE)\n \ttmp = TREE_TYPE (tmp);\n@@ -2533,7 +2547,7 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n \t  && !TREE_VISITED (decl))\n \t{\n \t  /* Generate full declaration.  */\n-\t  dump_nested_type (buffer, decl, t, parent, spc);\n+\t  dump_nested_type (buffer, decl, t, parent, dumped_types, spc);\n \t  TREE_VISITED (decl) = 1;\n \t}\n       else if (!decl && TREE_CODE (tmp) == POINTER_TYPE)\n@@ -2545,7 +2559,7 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n       else\n \tpp_string (buffer, \"type \");\n \n-      dump_ada_double_name (buffer, parent, field);\n+      dump_anonymous_type_name (buffer, field_type, parent);\n       pp_string (buffer, \" is \");\n       dump_ada_array_type (buffer, field_type, parent, spc);\n       pp_semicolon (buffer);\n@@ -2561,7 +2575,7 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n       if (TYPE_NAME (field_type))\n \tdump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n       else\n-\tdump_ada_double_name (buffer, parent, field);\n+\tdump_anonymous_type_name (buffer, field_type, parent);\n       pp_string (buffer, \" is \");\n       dump_ada_enum_type (buffer, field_type, spc);\n       pp_semicolon (buffer);\n@@ -2570,14 +2584,14 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n-      dump_nested_types (buffer, field, t, spc);\n+      dump_nested_types_1 (buffer, field, parent, dumped_types, spc);\n \n       pp_string (buffer, \"type \");\n \n       if (TYPE_NAME (field_type))\n \tdump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n       else\n-\tdump_ada_double_name (buffer, parent, field);\n+\tdump_anonymous_type_name (buffer, field_type, parent);\n \n       if (TREE_CODE (field_type) == UNION_TYPE)\n \tpp_string (buffer, \" (discr : unsigned := 0)\");\n@@ -2843,7 +2857,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t      pp_string (buffer, \"subtype \");\n \t    else\n \t      {\n-\t\tdump_nested_types (buffer, t, t, spc);\n+\t\tdump_nested_types (buffer, t, spc);\n \n                 if (separate_class_package (t))\n \t\t  {\n@@ -2920,8 +2934,6 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t}\n       else\n \t{\n-\t  tree tmp = TYPE_NAME (TREE_TYPE (t));\n-\n \t  if (spc == INDENT_INCR || TREE_STATIC (t))\n \t    is_var = true;\n \n@@ -2930,10 +2942,10 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  if (TREE_CODE (TREE_TYPE (TREE_TYPE (t))) != POINTER_TYPE)\n \t    pp_string (buffer, \"aliased \");\n \n-\t  if (tmp)\n-\t    dump_ada_node (buffer, tmp, type, spc, false, true);\n+\t  if (TYPE_NAME (TREE_TYPE (t)))\n+\t    dump_ada_node (buffer, TREE_TYPE (t), type, spc, false, true);\n \t  else if (type)\n-\t    dump_ada_double_name (buffer, type, t);\n+\t    dump_anonymous_type_name (buffer, TREE_TYPE (t), type);\n \t  else\n \t    dump_ada_array_type (buffer, TREE_TYPE (t), type, spc);\n \t}\n@@ -3152,33 +3164,21 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \n \t  pp_string (buffer, \" : \");\n \n-\t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (t))\n-\t      || TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE)\n-\t    {\n-\t      if (TYPE_NAME (TREE_TYPE (t))\n-\t\t  || TREE_CODE (TREE_TYPE (t)) != ENUMERAL_TYPE)\n-\t\tpp_string (buffer, \"aliased \");\n-\n-\t      if (TREE_READONLY (t) && TREE_CODE (t) != FIELD_DECL)\n-\t\tpp_string (buffer, \"constant \");\n-\n-\t      if (TYPE_NAME (TREE_TYPE (t)))\n-\t\tdump_ada_node (buffer, TREE_TYPE (t), t, spc, false, true);\n-\t      else if (type)\n-\t\tdump_ada_double_name (buffer, type, t);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE\n-\t\t  && (TYPE_NAME (TREE_TYPE (t))\n-\t\t      || TREE_CODE (TREE_TYPE (t)) != INTEGER_TYPE))\n-\t\tpp_string (buffer, \"aliased \");\n+\t  if (TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE\n+\t      && (TYPE_NAME (TREE_TYPE (t))\n+\t\t  || (TREE_CODE (TREE_TYPE (t)) != INTEGER_TYPE\n+\t\t      && TREE_CODE (TREE_TYPE (t)) != ENUMERAL_TYPE)))\n+\t    pp_string (buffer, \"aliased \");\n \n-\t      if (TREE_READONLY (t) && TREE_CODE (t) != FIELD_DECL)\n-\t\tpp_string (buffer, \"constant \");\n+\t  if (TREE_READONLY (t) && TREE_CODE (t) != FIELD_DECL)\n+\t    pp_string (buffer, \"constant \");\n \n-\t      dump_ada_node (buffer, TREE_TYPE (t), t, spc, false, true);\n-\t    }\n+\t  if (TYPE_NAME (TREE_TYPE (t))\n+\t      || (!RECORD_OR_UNION_TYPE_P (TREE_TYPE (t))\n+\t\t  && TREE_CODE (TREE_TYPE (t)) != ENUMERAL_TYPE))\n+\t    dump_ada_node (buffer, TREE_TYPE (t), t, spc, false, true);\n+\t  else if (type)\n+\t    dump_anonymous_type_name (buffer, TREE_TYPE (t), type);\n \t}\n     }\n \n@@ -3474,11 +3474,15 @@ void\n dump_ada_specs (void (*collect_all_refs)(const char *),\n \t\tint (*check)(tree, cpp_operation))\n {\n+  bitmap_obstack_initialize (NULL);\n+\n   /* Iterate over the list of files to dump specs for.  */\n   for (int i = 0; i < source_refs_used; i++)\n     dump_ads (source_refs[i], collect_all_refs, check);\n \n   /* Free various tables.  */\n   free (source_refs);\n   delete overloaded_names;\n+\n+  bitmap_obstack_release (NULL);\n }"}]}