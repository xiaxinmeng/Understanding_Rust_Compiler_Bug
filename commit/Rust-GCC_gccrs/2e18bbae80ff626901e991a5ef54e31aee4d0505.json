{"sha": "2e18bbae80ff626901e991a5ef54e31aee4d0505", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUxOGJiYWU4MGZmNjI2OTAxZTk5MWE1ZWY1NGUzMWFlZTRkMDUwNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-11-26T00:12:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-26T00:12:42Z"}, "message": "dwarf2out.c (file_table, [...]): Remove.\n\n        * dwarf2out.c (file_table, file_table_allocated): Remove.\n        (file_table_allocated): Remove.\n        (struct file_table): New.\n        (decl_file_table, line_file_table): New.\n        (print_dwarf_line_table): Use them.\n        (size_of_line_prolog): Likewise.\n        (output_line_info): Likewise.\n        (add_src_coords_attributes): Likewise.\n        (gen_subprogram_die): Likewise.\n        (gen_variable_die): Likewise.\n        (dwarf2out_add_library_unit_info): Likewise.\n        (dwarf2out_line): Likewise.\n        (lookup_filename): Take a struct file_table argument.\n        (init_file_table): New.\n        (dwarf2out_init): Use it.\n\nFrom-SVN: r37746", "tree": {"sha": "120b1bc449bd0ffea964d8c2bb95260fdcd6e812", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/120b1bc449bd0ffea964d8c2bb95260fdcd6e812"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e18bbae80ff626901e991a5ef54e31aee4d0505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e18bbae80ff626901e991a5ef54e31aee4d0505", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e18bbae80ff626901e991a5ef54e31aee4d0505", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e18bbae80ff626901e991a5ef54e31aee4d0505/comments", "author": null, "committer": null, "parents": [{"sha": "9399bad37b8792cf22b5d90b7ca91ea11b6eedc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9399bad37b8792cf22b5d90b7ca91ea11b6eedc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9399bad37b8792cf22b5d90b7ca91ea11b6eedc1"}], "stats": {"total": 155, "additions": 101, "deletions": 54}, "files": [{"sha": "8aabe9ea75e5c54c06f4069ffc586539faf7dc56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e18bbae80ff626901e991a5ef54e31aee4d0505/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e18bbae80ff626901e991a5ef54e31aee4d0505/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e18bbae80ff626901e991a5ef54e31aee4d0505", "patch": "@@ -1,3 +1,21 @@\n+2000-11-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2out.c (file_table, file_table_allocated): Remove.\n+\t(file_table_allocated): Remove.\n+\t(struct file_table): New.\n+\t(decl_file_table, line_file_table): New.\n+\t(print_dwarf_line_table): Use them.\n+\t(size_of_line_prolog): Likewise.\n+\t(output_line_info): Likewise.\n+\t(add_src_coords_attributes): Likewise.\n+\t(gen_subprogram_die): Likewise.\n+\t(gen_variable_die): Likewise.\n+\t(dwarf2out_add_library_unit_info): Likewise.\n+\t(dwarf2out_line): Likewise.\n+\t(lookup_filename): Take a struct file_table argument.\n+\t(init_file_table): New.\n+\t(dwarf2out_init): Use it.\n+\n 2000-11-25  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* invoke.texi: Update sequence points references."}, {"sha": "93ab3c2daac04d95b497af2907821b099a4c0fe1", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 83, "deletions": 54, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e18bbae80ff626901e991a5ef54e31aee4d0505/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e18bbae80ff626901e991a5ef54e31aee4d0505/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2e18bbae80ff626901e991a5ef54e31aee4d0505", "patch": "@@ -3173,21 +3173,25 @@ static dw_die_ref comp_unit_die;\n /* A list of DIEs with a NULL parent waiting to be relocated.  */\n static limbo_die_node *limbo_die_list = 0;\n \n-/* Pointer to an array of filenames referenced by this compilation unit.  */\n-static char **file_table;\n-\n-/* Total number of entries in the table (i.e. array) pointed to by\n-   `file_table'.  This is the *total* and includes both used and unused\n-   slots.  */\n-static unsigned file_table_allocated;\n-\n-/* Number of entries in the file_table which are actually in use.  */\n-static unsigned file_table_in_use;\n+/* Structure used by lookup_filename to manage sets of filenames.  */\n+struct file_table\n+{\n+  char **table;\n+  unsigned allocated;\n+  unsigned in_use;\n+  unsigned last_lookup_index;\n+};\n \n /* Size (in elements) of increments by which we may expand the filename\n    table.  */\n #define FILE_TABLE_INCREMENT 64\n \n+/* Filenames referenced by declarations this compilation unit.  */\n+static struct file_table decl_file_table;\n+\n+/* Filenames referenced by line numbers in this compilation unit.  */\n+static struct file_table line_file_table;\n+\n /* Local pointer to the name of the main input file.  Initialized in\n    dwarf2out_init.  */\n static const char *primary_filename;\n@@ -3516,7 +3520,9 @@ static void gen_block_die\t\tPARAMS ((tree, dw_die_ref, int));\n static void decls_for_scope\t\tPARAMS ((tree, dw_die_ref, int));\n static int is_redundant_typedef\t\tPARAMS ((tree));\n static void gen_decl_die\t\tPARAMS ((tree, dw_die_ref));\n-static unsigned lookup_filename\t\tPARAMS ((const char *));\n+static unsigned lookup_filename\t\tPARAMS ((struct file_table *,\n+\t\t\t\t\t\t const char *));\n+static void init_file_table\t\tPARAMS ((struct file_table *));\n static void add_incomplete_type\t\tPARAMS ((tree));\n static void retry_incomplete_types\tPARAMS ((void));\n static void gen_type_die_for_member\tPARAMS ((tree, tree, dw_die_ref));\n@@ -4978,7 +4984,7 @@ print_dwarf_line_table (outfile)\n     {\n       line_info = &line_info_table[i];\n       fprintf (outfile, \"%5d: \", i);\n-      fprintf (outfile, \"%-20s\", file_table[line_info->dw_file_num]);\n+      fprintf (outfile, \"%-20s\", line_file_table.table[line_info->dw_file_num]);\n       fprintf (outfile, \"%6ld\", line_info->dw_line_num);\n       fprintf (outfile, \"\\n\");\n     }\n@@ -5662,10 +5668,10 @@ size_of_line_prolog ()\n      null byte used to terminate the table.  */\n   size += 1;\n \n-  for (ft_index = 1; ft_index < file_table_in_use; ++ft_index)\n+  for (ft_index = 1; ft_index < decl_file_table.in_use; ++ft_index)\n     {\n       /* File name entry.  */\n-      size += size_of_string (file_table[ft_index]);\n+      size += size_of_string (decl_file_table.table[ft_index]);\n \n       /* Include directory index.  */\n       size += size_of_uleb128 (0);\n@@ -6482,19 +6488,20 @@ output_line_info ()\n   if (flag_debug_asm)\n     fprintf (asm_out_file, \"%s File Name Table\\n\", ASM_COMMENT_START);\n \n-  for (ft_index = 1; ft_index < file_table_in_use; ++ft_index)\n+  for (ft_index = 1; ft_index < line_file_table.in_use; ++ft_index)\n     {\n       if (flag_debug_asm)\n \t{\n-\t  ASM_OUTPUT_DWARF_STRING (asm_out_file, file_table[ft_index]);\n+\t  ASM_OUTPUT_DWARF_STRING (asm_out_file,\n+\t\t\t\t   line_file_table.table[ft_index]);\n \t  fprintf (asm_out_file, \"%s File Entry: 0x%lx\",\n \t\t   ASM_COMMENT_START, ft_index);\n \t}\n       else\n \t{\n \t  ASM_OUTPUT_ASCII (asm_out_file,\n-\t\t\t    file_table[ft_index],\n-\t\t\t    (int) strlen (file_table[ft_index]) + 1);\n+\t\t\t    line_file_table.table[ft_index],\n+\t\t\t    (int) strlen (line_file_table.table[ft_index]) + 1);\n \t}\n \n       fputc ('\\n', asm_out_file);\n@@ -6595,7 +6602,8 @@ output_line_info ()\n \t  fputc ('\\n', asm_out_file);\n \t  output_uleb128 (current_file);\n \t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \" (\\\"%s\\\")\", file_table[current_file]);\n+\t    fprintf (asm_out_file, \" (\\\"%s\\\")\",\n+\t\t     line_file_table.table[current_file]);\n \n \t  fputc ('\\n', asm_out_file);\n \t}\n@@ -6767,7 +6775,8 @@ output_line_info ()\n \t  fputc ('\\n', asm_out_file);\n \t  output_uleb128 (current_file);\n \t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \" (\\\"%s\\\")\", file_table[current_file]);\n+\t    fprintf (asm_out_file, \" (\\\"%s\\\")\",\n+\t\t     line_file_table.table[current_file]);\n \n \t  fputc ('\\n', asm_out_file);\n \t}\n@@ -8770,7 +8779,8 @@ add_src_coords_attributes (die, decl)\n      register dw_die_ref die;\n      register tree decl;\n {\n-  register unsigned file_index = lookup_filename (DECL_SOURCE_FILE (decl));\n+  register unsigned file_index = lookup_filename (&decl_file_table,\n+\t\t\t\t\t\t  DECL_SOURCE_FILE (decl));\n \n   add_AT_unsigned (die, DW_AT_decl_file, file_index);\n   add_AT_unsigned (die, DW_AT_decl_line, DECL_SOURCE_LINE (decl));\n@@ -9507,7 +9517,7 @@ gen_subprogram_die (decl, context_die)\n   else if (old_die)\n     {\n       register unsigned file_index\n-\t= lookup_filename (DECL_SOURCE_FILE (decl));\n+\t= lookup_filename (&decl_file_table, DECL_SOURCE_FILE (decl));\n \n       if (get_AT_flag (old_die, DW_AT_declaration) != 1)\n \t{\n@@ -9764,7 +9774,7 @@ gen_variable_die (decl, context_die)\n       if (DECL_NAME (decl))\n \t{\n \t  register unsigned file_index\n-\t    = lookup_filename (DECL_SOURCE_FILE (decl));\n+\t    = lookup_filename (&decl_file_table, DECL_SOURCE_FILE (decl));\n \n \t  if (get_AT_unsigned (old_die, DW_AT_decl_file) != file_index)\n \t    add_AT_unsigned (var_die, DW_AT_decl_file, file_index);\n@@ -10799,7 +10809,7 @@ dwarf2out_add_library_unit_info (filename, context_list)\n \n       TREE_PUBLIC (context_list_decl) = TRUE;\n       add_name_attribute (unit_die, context_list);\n-      file_index = lookup_filename (filename);\n+      file_index = lookup_filename (&decl_file_table, filename);\n       add_AT_unsigned (unit_die, DW_AT_decl_file, file_index);\n       add_pubname (context_list_decl, unit_die);\n     }\n@@ -10973,41 +10983,54 @@ dwarf2out_ignore_block (block)\n    was looked up last.  This handles the majority of all searches.  */\n \n static unsigned\n-lookup_filename (file_name)\n+lookup_filename (t, file_name)\n+     struct file_table *t;\n      const char *file_name;\n {\n-  static unsigned last_file_lookup_index = 0;\n   register unsigned i;\n \n-  /* Check to see if the file name that was searched on the previous call\n-     matches this file name. If so, return the index.  */\n-  if (last_file_lookup_index != 0)\n-    if (strcmp (file_name, file_table[last_file_lookup_index]) == 0)\n-      return last_file_lookup_index;\n+  /* Check to see if the file name that was searched on the previous\n+     call matches this file name.  If so, return the index.  */\n+  if (t->last_lookup_index != 0)\n+    if (strcmp (file_name, t->table[t->last_lookup_index]) == 0)\n+      return t->last_lookup_index;\n \n   /* Didn't match the previous lookup, search the table */\n-  for (i = 1; i < file_table_in_use; ++i)\n-    if (strcmp (file_name, file_table[i]) == 0)\n+  for (i = 1; i < t->in_use; ++i)\n+    if (strcmp (file_name, t->table[i]) == 0)\n       {\n-\tlast_file_lookup_index = i;\n+\tt->last_lookup_index = i;\n \treturn i;\n       }\n \n   /* Prepare to add a new table entry by making sure there is enough space in\n      the table to do so.  If not, expand the current table.  */\n-  if (file_table_in_use == file_table_allocated)\n+  if (i == t->allocated)\n     {\n-      file_table_allocated += FILE_TABLE_INCREMENT;\n-      file_table\n-\t= (char **) xrealloc (file_table,\n-\t\t\t      file_table_allocated * sizeof (char *));\n+      t->allocated = i + FILE_TABLE_INCREMENT;\n+      t->table = (char **)\n+\txrealloc (t->table, t->allocated * sizeof (char *));\n     }\n \n   /* Add the new entry to the end of the filename table.  */\n-  file_table[file_table_in_use] = xstrdup (file_name);\n-  last_file_lookup_index = file_table_in_use++;\n+  t->table[i] = xstrdup (file_name);\n+  t->in_use = i + 1;\n+  t->last_lookup_index = i;\n+\n+  return i;\n+}\n+\n+static void\n+init_file_table (t)\n+     struct file_table *t;\n+{\n+  /* Allocate the initial hunk of the file_table.  */\n+  t->table = (char **) xcalloc (FILE_TABLE_INCREMENT, sizeof (char *));\n+  t->allocated = FILE_TABLE_INCREMENT;\n \n-  return last_file_lookup_index;\n+  /* Skip the first entry - file numbers begin at 1.  */\n+  t->in_use = 1;\n+  t->last_lookup_index = 0;\n }\n \n /* Output a label to mark the beginning of a source code line entry\n@@ -11025,16 +11048,26 @@ dwarf2out_line (filename, line)\n \n       if (DWARF2_ASM_LINE_DEBUG_INFO)\n \t{\n-\t  static const char *lastfile;\n+\t  unsigned old_in_use = line_file_table.in_use;\n+\t  unsigned file_num = lookup_filename (&line_file_table, filename);\n \n \t  /* Emit the .file and .loc directives understood by GNU as.  */\n-\t  if (lastfile == 0 || strcmp (filename, lastfile))\n+#if 0\n+\t  /* ??? As of 2000-11-25, gas has a bug in which it doesn't \n+\t     actually use the file number argument.  It merely remembers\n+\t     the last .file directive emitted.  */\n+\t  if (file_num >= old_in_use)\n+\t    fprintf (asm_out_file, \"\\t.file %d \\\"%s\\\"\\n\", file_num, filename);\n+\t  fprintf (asm_out_file, \"\\t.loc %d %d 0\\n\", file_num, line);\n+#else\n+\t  static int last_file_num;\n+\t  if (file_num != last_file_num)\n \t    {\n+\t      last_file_num = file_num;\n \t      fprintf (asm_out_file, \"\\t.file 0 \\\"%s\\\"\\n\", filename);\n-\t      lastfile = filename;\n \t    }\n-\n \t  fprintf (asm_out_file, \"\\t.loc 0 %d 0\\n\", line);\n+#endif\n \n \t  /* Indicate that line number info exists.  */\n \t  ++line_info_table_in_use;\n@@ -11067,7 +11100,7 @@ dwarf2out_line (filename, line)\n \t  /* Add the new entry at the end of the line_info_table.  */\n \t  line_info\n \t    = &separate_line_info_table[separate_line_info_table_in_use++];\n-\t  line_info->dw_file_num = lookup_filename (filename);\n+\t  line_info->dw_file_num = lookup_filename (&line_file_table, filename);\n \t  line_info->dw_line_num = line;\n \t  line_info->function = current_funcdef_number;\n \t}\n@@ -11094,7 +11127,7 @@ dwarf2out_line (filename, line)\n \n \t  /* Add the new entry at the end of the line_info_table.  */\n \t  line_info = &line_info_table[line_info_table_in_use++];\n-\t  line_info->dw_file_num = lookup_filename (filename);\n+\t  line_info->dw_file_num = lookup_filename (&line_file_table, filename);\n \t  line_info->dw_line_num = line;\n \t}\n     }\n@@ -11166,12 +11199,8 @@ dwarf2out_init (asm_out_file, main_input_filename)\n   /* Remember the name of the primary input file.  */\n   primary_filename = main_input_filename;\n \n-  /* Allocate the initial hunk of the file_table.  */\n-  file_table = (char **) xcalloc (FILE_TABLE_INCREMENT, sizeof (char *));\n-  file_table_allocated = FILE_TABLE_INCREMENT;\n-\n-  /* Skip the first entry - file numbers begin at 1.  */\n-  file_table_in_use = 1;\n+  init_file_table (&decl_file_table);\n+  init_file_table (&line_file_table);\n \n   /* Allocate the initial hunk of the decl_die_table.  */\n   decl_die_table"}]}