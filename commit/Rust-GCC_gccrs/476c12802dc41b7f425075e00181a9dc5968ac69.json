{"sha": "476c12802dc41b7f425075e00181a9dc5968ac69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc2YzEyODAyZGM0MWI3ZjQyNTA3NWUwMDE4MWE5ZGM1OTY4YWM2OQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-05-22T09:08:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-05-22T09:08:46Z"}, "message": "re PR ipa/65701 (r221530 makes 187.facerec drop with -Ofast -flto on bdver2)\n\n2015-05-22  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/65701\n\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment):\n\tMove peeling cost models into one place.  Peel for alignment\n\tfor single loads only if an aligned load is cheaper than\n\tan unaligned load.\n\nFrom-SVN: r223528", "tree": {"sha": "bcc628fc3118356acfe35676fdfd6ecb40271f91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcc628fc3118356acfe35676fdfd6ecb40271f91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/476c12802dc41b7f425075e00181a9dc5968ac69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476c12802dc41b7f425075e00181a9dc5968ac69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/476c12802dc41b7f425075e00181a9dc5968ac69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476c12802dc41b7f425075e00181a9dc5968ac69/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd5c817a2457050649c2aadd8657091b2f6bbdaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd5c817a2457050649c2aadd8657091b2f6bbdaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd5c817a2457050649c2aadd8657091b2f6bbdaf"}], "stats": {"total": 50, "additions": 29, "deletions": 21}, "files": [{"sha": "ce6173cf1ff5d2961595b450010655373f793f8a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476c12802dc41b7f425075e00181a9dc5968ac69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476c12802dc41b7f425075e00181a9dc5968ac69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=476c12802dc41b7f425075e00181a9dc5968ac69", "patch": "@@ -1,3 +1,11 @@\n+2015-05-22  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/65701\n+\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment):\n+\tMove peeling cost models into one place.  Peel for alignment\n+\tfor single loads only if an aligned load is cheaper than\n+\tan unaligned load.\n+\n 2015-05-22  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/47043"}, {"sha": "eb35d6270f8f81c9983565076bc9fe56bf46e5a7", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476c12802dc41b7f425075e00181a9dc5968ac69/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476c12802dc41b7f425075e00181a9dc5968ac69/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=476c12802dc41b7f425075e00181a9dc5968ac69", "patch": "@@ -1541,16 +1541,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       || !slpeel_can_duplicate_loop_p (loop, single_exit (loop)))\n     do_peeling = false;\n \n-  /* If we don't know how many times the peeling loop will run\n-     assume it will run VF-1 times and disable peeling if the remaining\n-     iters are less than the vectorization factor.  */\n-  if (do_peeling\n-      && all_misalignments_unknown\n-      && LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && (LOOP_VINFO_INT_NITERS (loop_vinfo)\n-\t  < 2 * (unsigned) LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1))\n-    do_peeling = false;\n-\n   if (do_peeling\n       && all_misalignments_unknown\n       && vect_supportable_dr_alignment (dr0, false))\n@@ -1619,12 +1609,17 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n         }\n \n       /* In case there are only loads with different unknown misalignments, use\n-         peeling only if it may help to align other accesses in the loop.  */\n+         peeling only if it may help to align other accesses in the loop or\n+\t if it may help improving load bandwith when we'd end up using\n+\t unaligned loads.  */\n+      tree dr0_vt = STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr0)));\n       if (!first_store\n \t  && !STMT_VINFO_SAME_ALIGN_REFS (\n \t\t  vinfo_for_stmt (DR_STMT (dr0))).length ()\n-          && vect_supportable_dr_alignment (dr0, false)\n-              != dr_unaligned_supported)\n+\t  && (vect_supportable_dr_alignment (dr0, false)\n+\t      != dr_unaligned_supported\n+\t      || (builtin_vectorization_cost (vector_load, dr0_vt, 0)\n+\t\t  == builtin_vectorization_cost (unaligned_load, dr0_vt, -1))))\n         do_peeling = false;\n     }\n \n@@ -1641,14 +1636,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t\t\t\t\t   &body_cost_vec);\n       if (!dr0 || !npeel)\n         do_peeling = false;\n-\n-      /* If peeling by npeel will result in a remaining loop not iterating\n-         enough to be vectorized then do not peel.  */\n-      if (do_peeling\n-\t  && LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-\t  && (LOOP_VINFO_INT_NITERS (loop_vinfo)\n-\t      < LOOP_VINFO_VECT_FACTOR (loop_vinfo) + npeel))\n-\tdo_peeling = false;\n     }\n \n   if (do_peeling)\n@@ -1733,6 +1720,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t    }\n         }\n \n+      /* Cost model #1 - honor --param vect-max-peeling-for-alignment.  */\n       if (do_peeling)\n         {\n           unsigned max_allowed_peel\n@@ -1757,6 +1745,18 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n             }\n         }\n \n+      /* Cost model #2 - if peeling may result in a remaining loop not\n+\t iterating enough to be vectorized then do not peel.  */\n+      if (do_peeling\n+\t  && LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+\t{\n+\t  unsigned max_peel\n+\t    = npeel == 0 ? LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1 : npeel;\n+\t  if (LOOP_VINFO_INT_NITERS (loop_vinfo)\n+\t      < LOOP_VINFO_VECT_FACTOR (loop_vinfo) + max_peel)\n+\t    do_peeling = false;\n+\t}\n+\n       if (do_peeling)\n         {\n           /* (1.2) Update the DR_MISALIGNMENT of each data reference DR_i."}]}