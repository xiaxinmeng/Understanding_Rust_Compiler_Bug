{"sha": "6e5fba0ef6cc1b784f0a11f89e362973e706c602", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU1ZmJhMGVmNmNjMWI3ODRmMGExMWY4OWUzNjI5NzNlNzA2YzYwMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-05-20T21:34:29Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-05-20T21:34:29Z"}, "message": "re PR c++/57102 (ICE: SIGSEGV in fndecl_declared_return_type with -fdump-final-insns=...)\n\n\tPR c++/57102\n\t* decl.c (fndecl_declared_return_type): Also look in\n\tDECL_SAVED_FUNCTION_DATA.\n\nFrom-SVN: r199125", "tree": {"sha": "0fd046509989883d5e478782cabdd7021e04f45d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fd046509989883d5e478782cabdd7021e04f45d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e5fba0ef6cc1b784f0a11f89e362973e706c602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e5fba0ef6cc1b784f0a11f89e362973e706c602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e5fba0ef6cc1b784f0a11f89e362973e706c602", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e5fba0ef6cc1b784f0a11f89e362973e706c602/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "77f8682b0524f6b534b1da716ee2565757ec7b86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77f8682b0524f6b534b1da716ee2565757ec7b86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77f8682b0524f6b534b1da716ee2565757ec7b86"}], "stats": {"total": 786, "additions": 782, "deletions": 4}, "files": [{"sha": "27ab94ef37cfd5abbdffbddbc446c5bfd47a131d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e5fba0ef6cc1b784f0a11f89e362973e706c602/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e5fba0ef6cc1b784f0a11f89e362973e706c602/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6e5fba0ef6cc1b784f0a11f89e362973e706c602", "patch": "@@ -1,3 +1,9 @@\n+2013-05-20  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/57102\n+\t* decl.c (fndecl_declared_return_type): Also look in\n+\tDECL_SAVED_FUNCTION_DATA.\n+\n 2013-05-20  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/12288"}, {"sha": "c37b4fe55927115082f04813ccc77eeac81844f6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e5fba0ef6cc1b784f0a11f89e362973e706c602/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e5fba0ef6cc1b784f0a11f89e362973e706c602/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6e5fba0ef6cc1b784f0a11f89e362973e706c602", "patch": "@@ -14417,10 +14417,15 @@ fndecl_declared_return_type (tree fn)\n {\n   fn = STRIP_TEMPLATE (fn);\n   if (FNDECL_USED_AUTO (fn))\n-    return (DECL_STRUCT_FUNCTION (fn)->language\n-\t    ->x_auto_return_pattern);\n-  else\n-    return TREE_TYPE (TREE_TYPE (fn));\n+    {\n+      struct language_function *f = NULL;\n+      if (DECL_STRUCT_FUNCTION (fn))\n+\tf = DECL_STRUCT_FUNCTION (fn)->language;\n+      if (f == NULL)\n+\tf = DECL_SAVED_FUNCTION_DATA (fn);\n+      return f->x_auto_return_pattern;\n+    }\n+  return TREE_TYPE (TREE_TYPE (fn));\n }\n \n /* Returns true iff DECL was declared with an auto return type and it has"}, {"sha": "b77c1d58cb6a31ed82a9826d5a2950c45cd80620", "filename": "gcc/testsuite/g++.dg/opt/dump1.C", "status": "added", "additions": 767, "deletions": 0, "changes": 767, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e5fba0ef6cc1b784f0a11f89e362973e706c602/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdump1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e5fba0ef6cc1b784f0a11f89e362973e706c602/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdump1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdump1.C?ref=6e5fba0ef6cc1b784f0a11f89e362973e706c602", "patch": "@@ -0,0 +1,767 @@\n+// PR c++/57102\n+// { dg-options \"-std=gnu++0x -O2 -fno-inline -fdump-final-insns\" }\n+// { dg-final cleanup-saved-temps }\n+\n+namespace std\n+{\n+  typedef __SIZE_TYPE__ size_t;\n+  typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+}\n+extern \"C++\" {\n+  void* operator new(std::size_t, void* __p) noexcept;\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template<typename _Tp, _Tp __v>\n+    struct integral_constant\n+    {\n+      static constexpr _Tp value = __v;\n+      typedef integral_constant<_Tp, __v> type;\n+    };\n+  typedef integral_constant<bool, true> true_type;\n+  typedef integral_constant<bool, false> false_type;\n+  template<bool, typename, typename>\n+    struct conditional;\n+  template<typename...>\n+    struct __or_;\n+  template<typename _B1, typename _B2>\n+    struct __or_<_B1, _B2>\n+    : public conditional<_B1::value, _B1, _B2>::type\n+    {};\n+  template<typename _B1, typename _B2, typename _B3, typename... _Bn>\n+    struct __or_<_B1, _B2, _B3, _Bn...>\n+    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type\n+    {};\n+  template<typename...>\n+    struct __and_;\n+  template<typename _B1, typename _B2>\n+    struct __and_<_B1, _B2>\n+    : public conditional<_B1::value, _B2, _B1>::type\n+    {};\n+  template<typename _Pp>\n+    struct __not_\n+    : public integral_constant<bool, !_Pp::value>\n+    {};\n+  template<typename _Tp>\n+    struct __success_type\n+    { typedef _Tp type; };\n+  template<typename>\n+    struct remove_cv;\n+  template<typename>\n+    struct __is_void_helper\n+    : public false_type {};\n+  template<typename _Tp>\n+    struct is_void\n+    : public __is_void_helper<typename remove_cv<_Tp>::type>::type\n+    {};\n+  template<typename>\n+    struct __is_integral_helper\n+    : public true_type {};\n+  template<typename _Tp>\n+    struct is_integral\n+    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type\n+    {};\n+  template<typename>\n+    struct is_array\n+    : public false_type {};\n+  template<typename>\n+    struct is_lvalue_reference\n+    : public false_type {};\n+  template<typename>\n+    struct is_rvalue_reference\n+    : public false_type {};\n+  template<typename>\n+    struct __is_member_object_pointer_helper\n+    : public false_type {};\n+  template<typename _Tp>\n+    struct is_member_object_pointer\n+    : public __is_member_object_pointer_helper<\n+    typename remove_cv<_Tp>::type>::type\n+    {};\n+  template<typename>\n+    struct __is_member_function_pointer_helper\n+    : public false_type {};\n+  template<typename _Tp>\n+    struct is_member_function_pointer\n+    : public __is_member_function_pointer_helper<\n+    typename remove_cv<_Tp>::type>::type\n+    {};\n+  template<typename _Tp>\n+    struct is_enum\n+    : public integral_constant<bool, __is_enum(_Tp)>\n+    {};\n+  template<typename>\n+    struct is_function\n+    : public false_type {};\n+  template<typename _Tp>\n+    struct is_reference\n+    : public __or_<is_lvalue_reference<_Tp>,\n+                   is_rvalue_reference<_Tp>>::type\n+    {};\n+  template<typename _Tp>\n+    struct __is_member_pointer_helper\n+    : public false_type {};\n+  template<typename _Tp>\n+    struct is_member_pointer\n+    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type\n+    {};\n+  template<typename>\n+    struct is_const\n+    : public false_type {};\n+  template<typename>\n+    struct is_volatile\n+    : public false_type {};\n+  template<typename>\n+    struct add_rvalue_reference;\n+  template<typename _Tp>\n+    typename add_rvalue_reference<_Tp>::type declval() noexcept;\n+  struct __do_is_nary_constructible_impl\n+  {\n+    template<typename _Tp, typename... _Args, typename\n+             = decltype(_Tp(declval<_Args>()...))>\n+      static true_type __test(int);\n+  };\n+  template<typename _Tp, typename... _Args>\n+    struct __is_nary_constructible_impl\n+    : public __do_is_nary_constructible_impl\n+    {\n+      typedef decltype(__test<_Tp, _Args...>(0)) type;\n+    };\n+  template<typename _Tp, typename... _Args>\n+    struct __is_nary_constructible\n+    : public __is_nary_constructible_impl<_Tp, _Args...>::type\n+    {};\n+  template<typename _Tp, typename... _Args>\n+    struct __is_constructible_impl\n+    : public __is_nary_constructible<_Tp, _Args...>\n+    {};\n+  template<typename _Tp, typename... _Args>\n+    struct is_constructible\n+    : public __is_constructible_impl<_Tp, _Args...>::type\n+    {};\n+  template<typename, typename>\n+    struct is_same\n+    : public true_type {};\n+  template<typename _From, typename _To,\n+           bool = __or_<is_void<_From>, is_function<_To>,\n+                        is_array<_To>>::value>\n+    struct __is_convertible_helper\n+    {\n+       template<typename _To1>\n+ static void __test_aux(_To1);\n+      template<typename _From1, typename _To1,\n+        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>\n+ static true_type\n+ __test(int);\n+      typedef decltype(__test<_From, _To>(0)) type;\n+    };\n+  template<typename _From, typename _To>\n+    struct is_convertible\n+    : public __is_convertible_helper<_From, _To>::type\n+    {};\n+  template<typename _Tp>\n+    struct remove_const\n+    { typedef _Tp type; };\n+  template<typename _Tp>\n+    struct remove_volatile\n+    { typedef _Tp type; };\n+  template<typename _Tp>\n+    struct remove_cv\n+    {\n+      typedef typename\n+      remove_const<typename remove_volatile<_Tp>::type>::type type;\n+    };\n+  template<typename _Tp>\n+    struct remove_reference\n+    { typedef _Tp type; };\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&>\n+    { typedef _Tp type; };\n+  template<typename _Tp,\n+           bool = __and_<__not_<is_reference<_Tp>>,\n+                         __not_<is_void<_Tp>>>::value>\n+    struct __add_rvalue_reference_helper\n+    { typedef _Tp type; };\n+  template<typename _Tp>\n+    struct add_rvalue_reference\n+    : public __add_rvalue_reference_helper<_Tp>\n+    {};\n+  template<typename _Unqualified, bool _IsConst, bool _IsVol>\n+    struct __cv_selector;\n+  template<typename _Unqualified>\n+    struct __cv_selector<_Unqualified, false, false>\n+    { typedef _Unqualified __type; };\n+  template<typename _Qualified, typename _Unqualified,\n+    bool _IsConst = is_const<_Qualified>::value,\n+    bool _IsVol = is_volatile<_Qualified>::value>\n+    class __match_cv_qualifiers\n+    {\n+      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;\n+    public:\n+      typedef typename __match::__type __type;\n+    };\n+  template<typename _Tp>\n+    struct __make_unsigned\n+    { typedef _Tp __type; };\n+  template<typename _Tp,\n+    bool _IsInt = is_integral<_Tp>::value,\n+    bool _IsEnum = is_enum<_Tp>::value>\n+    class __make_unsigned_selector;\n+  template<typename _Tp>\n+    class __make_unsigned_selector<_Tp, true, false>\n+    {\n+      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;\n+      typedef typename __unsignedt::__type __unsigned_type;\n+      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;\n+    public:\n+      typedef typename __cv_unsigned::__type __type;\n+    };\n+  template<typename _Tp>\n+    struct make_unsigned\n+    { typedef typename __make_unsigned_selector<_Tp>::__type type; };\n+  template<typename _Tp, typename>\n+    struct __remove_pointer_helper\n+    { typedef _Tp type; };\n+  template<typename _Tp>\n+    struct remove_pointer\n+    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>\n+    {};\n+  template<typename _Up,\n+    bool _IsArray = is_array<_Up>::value,\n+    bool _IsFunction = is_function<_Up>::value>\n+    struct __decay_selector;\n+  template<typename _Up>\n+    struct __decay_selector<_Up, false, false>\n+    { typedef typename remove_cv<_Up>::type __type; };\n+  template<typename _Tp>\n+    class decay\n+    {\n+      typedef typename remove_reference<_Tp>::type __remove_type;\n+    public:\n+      typedef typename __decay_selector<__remove_type>::__type type;\n+    };\n+  template<bool, typename _Tp = void>\n+    struct enable_if\n+    { typedef _Tp type; };\n+  template<typename... _Cond>\n+    using _Require = typename enable_if<__and_<_Cond...>::value>::type;\n+  template<bool _Cond, typename _Iftrue, typename _Iffalse>\n+    struct conditional\n+    { typedef _Iftrue type; };\n+  template<typename _Signature>\n+    class result_of;\n+  template<bool, bool, typename _Functor, typename... _ArgTypes>\n+    struct __result_of_impl\n+    ;\n+  struct __result_of_other_impl\n+  {\n+    template<typename _Fn, typename... _Args>\n+      static __success_type<decltype(\n+      std::declval<_Fn>()(std::declval<_Args>()...)\n+      )> _S_test(int);\n+  };\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct __result_of_impl<false, false, _Functor, _ArgTypes...>\n+    : private __result_of_other_impl\n+    {\n+      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;\n+    };\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct result_of<_Functor(_ArgTypes...)>\n+    : public __result_of_impl<\n+        is_member_object_pointer<\n+          typename remove_reference<_Functor>::type\n+        >::value,\n+        is_member_function_pointer<\n+          typename remove_reference<_Functor>::type\n+        >::value,\n+     _Functor, _ArgTypes...\n+      >::type\n+    {};\n+  template<typename _Tp>\n+    constexpr _Tp&&\n+    forward(typename std::remove_reference<_Tp>::type& __t) noexcept\n+    { return static_cast<_Tp&&>(__t); }\n+  template<typename _Tp>\n+    constexpr typename std::remove_reference<_Tp>::type&&\n+    move(_Tp&& __t) noexcept\n+    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }\n+  template<std::size_t _Int, class _Tp>\n+    class tuple_element;\n+  struct allocator_arg_t {};\n+  constexpr allocator_arg_t allocator_arg = allocator_arg_t();\n+  template<typename _Tp>\n+    struct __add_ref\n+    { typedef _Tp& type; };\n+  template<std::size_t _Idx, typename... _Elements>\n+    struct _Tuple_impl;\n+  template<std::size_t _Idx, typename _Head, typename... _Tail>\n+    struct _Tuple_impl<_Idx, _Head, _Tail...>\n+    {};\n+  template<typename... _Elements>\n+    class tuple : public _Tuple_impl<0, _Elements...>\n+    {};\n+  template<typename _Head, typename... _Tail>\n+    struct tuple_element<0, tuple<_Head, _Tail...> >\n+    {\n+      typedef _Head type;\n+    };\n+  template<std::size_t __i, typename... _Elements>\n+    typename __add_ref<\n+                      typename tuple_element<__i, tuple<_Elements...>>::type\n+                    >::type\n+    get(tuple<_Elements...>& __t) noexcept;\n+  template<std::size_t... _Indexes>\n+    struct _Index_tuple\n+    {};\n+  template<std::size_t _Num>\n+    struct _Build_index_tuple\n+    {\n+      typedef _Index_tuple<> __type;\n+    };\n+  template<typename _Functor, typename... _Args>\n+    typename enable_if<\n+      (!is_member_pointer<_Functor>::value\n+       && !is_function<typename remove_pointer<_Functor>::type>::value),\n+      typename result_of<_Functor(_Args&&...)>::type\n+    >::type\n+    __invoke(_Functor& __f, _Args&&... __args)\n+    {\n+      return __f(std::forward<_Args>(__args)...);\n+    }\n+\n+  template<typename _Tp>\n+    class reference_wrapper\n+    {\n+    public:\n+      _Tp&\n+      get() const noexcept\n+      {}\n+      template<typename... _Args>\n+ typename result_of<_Tp&(_Args&&...)>::type\n+ operator()(_Args&&... __args) const\n+ {\n+   return __invoke(get(), std::forward<_Args>(__args)...);\n+ }\n+    };\n+  template<typename _Tp>\n+    inline reference_wrapper<_Tp>\n+    ref(_Tp& __t) noexcept\n+    {}\n+  template<typename _Tp>\n+    struct _Maybe_wrap_member_pointer\n+    {\n+      typedef _Tp type;\n+    };\n+  template<typename _Signature>\n+    struct _Bind_simple;\n+  template<typename _Callable, typename... _Args>\n+    struct _Bind_simple<_Callable(_Args...)>\n+    {\n+      typedef typename result_of<_Callable(_Args...)>::type result_type;\n+      result_type\n+      operator()()\n+      {\n+        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indices;\n+        return _M_invoke(_Indices());\n+      }\n+      template<std::size_t... _Indices>\n+        typename result_of<_Callable(_Args...)>::type\n+        _M_invoke(_Index_tuple<_Indices...>)\n+        {\n+          return std::forward<_Callable>(std::get<0>(_M_bound))(\n+              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);\n+        }\n+      std::tuple<_Callable, _Args...> _M_bound;\n+    };\n+  template<typename _Func, typename... _BoundArgs>\n+    struct _Bind_simple_helper\n+    {\n+      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>\n+        __maybe_type;\n+      typedef typename __maybe_type::type __func_type;\n+      typedef _Bind_simple<__func_type(typename decay<_BoundArgs>::type...)>\n+        __type;\n+    };\n+  template<typename _Callable, typename... _Args>\n+    typename _Bind_simple_helper<_Callable, _Args...>::__type\n+    __bind_simple(_Callable&& __callable, _Args&&... __args)\n+  ;\n+  union _Any_data\n+  ;\n+  template<typename _Functor>\n+    inline _Functor&\n+    __callable_functor(_Functor& __f)\n+    ;\n+  template<typename _Signature>\n+    class function;\n+  class _Function_base\n+  {\n+    template<typename _Functor>\n+      class _Base_manager\n+      {\n+      protected:\n+ static _Functor*\n+ _M_get_pointer(const _Any_data& __source)\n+ ;\n+      };\n+  };\n+  template<typename _Signature, typename _Functor>\n+    class _Function_handler;\n+  template<typename _Res, typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), _Functor>\n+    : public _Function_base::_Base_manager<_Functor>\n+    {\n+      typedef _Function_base::_Base_manager<_Functor> _Base;\n+    public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+ return (*_Base::_M_get_pointer(__functor))(\n+     std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+  template<typename _Res, typename... _ArgTypes>\n+    class function<_Res(_ArgTypes...)>\n+    {\n+      typedef _Res _Signature_type(_ArgTypes...);\n+      template<typename _Functor>\n+ using _Invoke = decltype(__callable_functor(std::declval<_Functor&>())\n+     (std::declval<_ArgTypes>()...) );\n+      template<typename _CallRes, typename _Res1>\n+ struct _CheckResult\n+ : is_convertible<_CallRes, _Res1> {};\n+      template<typename _Functor>\n+ using _Callable = _CheckResult<_Invoke<_Functor>, _Res>;\n+      template<typename _Cond, typename _Tp>\n+ using _Requires = typename enable_if<_Cond::value, _Tp>::type;\n+    public:\n+      template<typename _Functor,\n+        typename = _Requires<_Callable<_Functor>, void>>\n+ function(_Functor);\n+      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);\n+      _Invoker_type _M_invoker;\n+  };\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor, typename>\n+      function<_Res(_ArgTypes...)>::\n+      function(_Functor __f)\n+      {\n+ typedef _Function_handler<_Signature_type, _Functor> _My_handler;\n+{\n+     _M_invoker = &_My_handler::_M_invoke;\n+   }\n+      }\n+  template<typename _Ptr>\n+    class __ptrtr_pointer_to\n+    ;\n+  template<typename _Ptr>\n+    struct pointer_traits : __ptrtr_pointer_to<_Ptr>\n+    {};\n+  template<typename _Tp>\n+    struct pointer_traits<_Tp*>\n+    {\n+      typedef ptrdiff_t difference_type;\n+    };\n+  template<typename _Alloc, typename _Tp>\n+    class __alloctr_rebind_helper\n+    {\n+      template<typename, typename>\n+        static constexpr bool\n+        _S_chk(...)\n+        { return false; }\n+    public:\n+      static const bool __value = _S_chk<_Alloc, _Tp>(nullptr);\n+    };\n+  template<typename _Alloc, typename _Tp,\n+           bool = __alloctr_rebind_helper<_Alloc, _Tp>::__value>\n+    struct __alloctr_rebind;\n+  template<template<typename, typename...> class _Alloc, typename _Tp,\n+            typename _Up, typename... _Args>\n+    struct __alloctr_rebind<_Alloc<_Up, _Args...>, _Tp, false>\n+    {\n+      typedef _Alloc<_Tp, _Args...> __type;\n+    };\n+  template<typename _Alloc>\n+    struct allocator_traits\n+    {\n+      typedef _Alloc allocator_type;\n+      typedef typename _Alloc::value_type value_type; static value_type* _S_pointer_helper(...); typedef decltype(_S_pointer_helper((_Alloc*)0)) __pointer; public:\n+      typedef __pointer pointer; static typename pointer_traits<pointer>::difference_type _S_difference_type_helper(...); typedef decltype(_S_difference_type_helper((_Alloc*)0)) __difference_type; public:\n+      typedef __difference_type difference_type; static typename make_unsigned<difference_type>::type _S_size_type_helper(...); typedef decltype(_S_size_type_helper((_Alloc*)0)) __size_type; public:\n+      typedef __size_type size_type; public:\n+      template<typename _Tp>\n+        using rebind_alloc = typename __alloctr_rebind<_Alloc, _Tp>::__type;\n+      template<typename _Tp>\n+        using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n+      template<typename _Tp, typename... _Args>\n+ struct __construct_helper\n+ {\n+   template<typename>\n+     static false_type __test(...);\n+   typedef decltype(__test<_Alloc>(0)) type;\n+   static const bool value = type::value;\n+ };\n+      template<typename _Tp, typename... _Args>\n+ static typename\n+ enable_if<__and_<__not_<__construct_helper<_Tp, _Args...>>,\n+    is_constructible<_Tp, _Args...>>::value, void>::type\n+        _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)\n+ { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }\n+      static pointer\n+      allocate(_Alloc& __a, size_type __n)\n+      ;\n+      template<typename _Tp, typename... _Args>\n+ static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n+ -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))\n+ { _S_construct(__a, __p, std::forward<_Args>(__args)...); }\n+    };\n+}\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\")))\n+{\n+  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };\n+  static const _Lock_policy __default_lock_policy =\n+  _S_atomic;\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template<typename _Tp>\n+    struct default_delete\n+    ;\n+  template <typename _Tp, typename _Dp = default_delete<_Tp> >\n+    class unique_ptr\n+    {\n+      class _Pointer\n+      {\n+ template<typename _Up>\n+   static _Tp* __test(...);\n+ typedef typename remove_reference<_Dp>::type _Del;\n+      public:\n+ typedef decltype(__test<_Del>(0)) type;\n+      };\n+    public:\n+      typedef typename _Pointer::type pointer;\n+      typedef _Tp element_type;\n+      template<typename _Up, typename _Ep, typename = _Require<\n+        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,\n+        typename conditional<is_reference<_Dp>::value,\n+        is_same<_Ep, _Dp>,\n+        is_convertible<_Ep, _Dp>>::type>>\n+ unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n+      ;\n+  };\n+}\n+namespace __gnu_cxx\n+{\n+  template<typename _Tp>\n+    struct __aligned_buffer\n+    {};\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  using __gnu_cxx::_Lock_policy;\n+  using __gnu_cxx::__default_lock_policy;\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class _Sp_counted_base\n+    {};\n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+    class __shared_ptr;\n+  struct _Sp_make_shared_tag {};\n+  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>\n+    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>\n+    {\n+      struct _Impl\n+      : public _Alloc\n+      {\n+ _Impl(_Alloc __a) : _Alloc(__a), _M_ptr() {}\n+ _Tp* _M_ptr;\n+      };\n+    public:\n+      template<typename... _Args>\n+ _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)\n+ : _M_impl(__a), _M_storage()\n+ {\n+   allocator_traits<_Alloc>::construct(__a, _M_impl._M_ptr,\n+       std::forward<_Args>(__args)...);\n+ }\n+      _Impl _M_impl;\n+      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;\n+    };\n+  template<_Lock_policy _Lp>\n+    class __shared_count\n+    {\n+    public:\n+      template<typename _Tp, typename _Alloc, typename... _Args>\n+ __shared_count(_Sp_make_shared_tag, _Tp*, const _Alloc& __a,\n+         _Args&&... __args)\n+ {\n+   typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;\n+   typedef typename allocator_traits<_Alloc>::template\n+     rebind_traits<_Sp_cp_type> _Alloc_traits;\n+   typename _Alloc_traits::allocator_type __a2(__a);\n+   _Sp_cp_type* __mem = _Alloc_traits::allocate(__a2, 1);\n+   try\n+     {\n+       _Alloc_traits::construct(__a2, __mem, std::move(__a),\n+      std::forward<_Args>(__args)...);\n+     }\n+   catch(...)\n+     {}\n+ }\n+    };\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __shared_ptr\n+    {\n+    public:\n+      template<typename _Tp1, typename = typename\n+        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>\n+ __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n+ : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n+ {}\n+      template<typename _Alloc, typename... _Args>\n+ __shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,\n+       _Args&&... __args)\n+ : _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,\n+    std::forward<_Args>(__args)...)\n+ {}\n+      _Tp* _M_ptr;\n+      __shared_count<_Lp> _M_refcount;\n+    };\n+  template<typename _Tp>\n+    class shared_ptr : public __shared_ptr<_Tp>\n+    {\n+    public:\n+      template<typename _Tp1, typename = typename\n+        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>\n+ shared_ptr(const shared_ptr<_Tp1>& __r) noexcept\n+        : __shared_ptr<_Tp>(__r) {}\n+      template<typename _Alloc, typename... _Args>\n+ shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,\n+     _Args&&... __args)\n+ : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)\n+ {}\n+    };\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    inline shared_ptr<_Tp>\n+    allocate_shared(const _Alloc& __a, _Args&&... __args)\n+    {\n+      return shared_ptr<_Tp>(_Sp_make_shared_tag(), __a,\n+        std::forward<_Args>(__args)...);\n+    }\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template<typename _Signature>\n+    class packaged_task;\n+  struct __future_base\n+  {\n+    struct _Result_base\n+    {\n+      struct _Deleter\n+      ;\n+    };\n+    template<typename _Res>\n+      struct _Result : _Result_base\n+      {\n+ typedef _Res result_type;\n+    };\n+    template<typename _Res>\n+      using _Ptr = unique_ptr<_Res, _Result_base::_Deleter>;\n+    template<typename _Res, typename _Alloc>\n+      struct _Result_alloc final : _Result<_Res>, _Alloc\n+      {};\n+    template<typename _Res, typename _Allocator>\n+      static _Ptr<_Result_alloc<_Res, _Allocator>>\n+      _S_allocate_result(const _Allocator& __a)\n+    ;\n+    template<typename _Signature>\n+      class _Task_state_base;\n+    template<typename _Fn, typename _Alloc, typename _Signature>\n+      class _Task_state;\n+    template<typename _Res_ptr,\n+      typename _Res = typename _Res_ptr::element_type::result_type>\n+      struct _Task_setter;\n+    template<typename _Res_ptr, typename _BoundFn>\n+      static _Task_setter<_Res_ptr>\n+      _S_task_setter(_Res_ptr& __ptr, _BoundFn&& __call)\n+      {\n+ return _Task_setter<_Res_ptr>{ __ptr, std::ref(__call) };\n+      }\n+  };\n+  template<typename _Ptr_type, typename _Res>\n+    struct __future_base::_Task_setter\n+    {\n+      _Ptr_type& _M_result;\n+      std::function<_Res()> _M_fn;\n+    };\n+  template<typename _Res, typename... _Args>\n+    struct __future_base::_Task_state_base<_Res(_Args...)>\n+    {\n+      template<typename _Alloc>\n+ _Task_state_base(const _Alloc& __a)\n+ : _M_result(_S_allocate_result<_Res>(__a))\n+ {}\n+      typedef __future_base::_Ptr<_Result<_Res>> _Ptr_type;\n+      _Ptr_type _M_result;\n+    };\n+  template<typename _Fn, typename _Alloc, typename _Res, typename... _Args>\n+    struct __future_base::_Task_state<_Fn, _Alloc, _Res(_Args...)> final\n+    : __future_base::_Task_state_base<_Res(_Args...)>\n+    {\n+      _Task_state(_Fn&& __fn, const _Alloc& __a)\n+      : _Task_state_base<_Res(_Args...)>(__a), _M_impl(std::move(__fn), __a)\n+      {}\n+      virtual void\n+      _M_run(_Args... __args)\n+      {\n+ auto __boundfn = std::__bind_simple(std::ref(_M_impl._M_fn),\n+     _S_maybe_wrap_ref(std::forward<_Args>(__args))...);\n+ auto __setter = _S_task_setter(this->_M_result, std::move(__boundfn));\n+      }\n+      struct _Impl : _Alloc\n+      {\n+ _Impl(_Fn&& __fn, const _Alloc& __a)\n+   : _Alloc(__a), _M_fn(std::move(__fn)) {}\n+ _Fn _M_fn;\n+      } _M_impl;\n+    };\n+    template<typename _Signature, typename _Fn, typename _Alloc>\n+      static shared_ptr<__future_base::_Task_state_base<_Signature>>\n+      __create_task_state(_Fn&& __fn, const _Alloc& __a)\n+      {\n+ typedef __future_base::_Task_state<_Fn, _Alloc, _Signature> _State;\n+ return std::allocate_shared<_State>(__a, std::move(__fn), __a);\n+      }\n+  template<typename _Task, typename _Fn, bool\n+    = is_same<_Task, typename decay<_Fn>::type>::value>\n+    struct __constrain_pkgdtask\n+    { typedef void __type; };\n+  template<typename _Res, typename... _ArgTypes>\n+    class packaged_task<_Res(_ArgTypes...)>\n+    {\n+      typedef __future_base::_Task_state_base<_Res(_ArgTypes...)> _State_type;\n+      shared_ptr<_State_type> _M_state;\n+    public:\n+      template<typename _Fn, typename _Alloc, typename = typename\n+        __constrain_pkgdtask<packaged_task, _Fn>::__type>\n+ packaged_task(allocator_arg_t, const _Alloc& __a, _Fn&& __fn)\n+ : _M_state(__create_task_state<_Res(_ArgTypes...)>(\n+      std::forward<_Fn>(__fn), __a))\n+ {}\n+    };\n+}\n+namespace __gnu_test\n+{\n+  template <class Tp>\n+    struct SimpleAllocator\n+    {\n+      typedef Tp value_type;\n+      SimpleAllocator() ;\n+      template <class T>\n+        SimpleAllocator(const SimpleAllocator<T>& other) ;\n+    };\n+}\n+using std::packaged_task;\n+using std::allocator_arg;\n+__gnu_test::SimpleAllocator<int> a;\n+packaged_task<int()> p(allocator_arg, a, []() { return 1; });"}]}