{"sha": "eafa9d969237fd8f712c4b25a8c58932c01f44b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFmYTlkOTY5MjM3ZmQ4ZjcxMmM0YjI1YThjNTg5MzJjMDFmNDRiNA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-08-30T22:36:31Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-08-30T22:36:31Z"}, "message": "analyzer: support \"bifurcation\"; reimplement realloc [PR99260]\n\nMost of the state-management code in the analyzer involves\nmodifying state objects in-place, which implies a single outcome.\n(I originally implemented in-place modification because I wanted\nto avoid having to create copies of state objects, and it's now\nvery difficult to change this aspect of the analyzer's design)\n\nHowever, there are various special-cases such as \"realloc\" for which\nit's best to split the state into multiple outcomes.\n\nThis patch adds a mechanism for \"bifurcating\" the analysis in places\nwhere there isn't a split in the CFG, and uses it to implement realloc,\nin this case treating it as having 3 possible outcomes:\n- failure, returning NULL\n- success, growing the buffer in-place without moving it\n- success, allocating a new buffer, copying the content of the old\n  buffer to it, and freeing the old buffer.\n\ngcc/ChangeLog:\n\tPR analyzer/99260\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/call-info.o.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/99260\n\t* analyzer.h (class custom_edge_info): New class, adapted from\n\texploded_edge::custom_info_t.  Make member functions const.\n\tMake update_model return bool, converting edge param from\n\treference to a pointer, and adding a ctxt param.\n\t(class path_context): New class.\n\t* call-info.cc: New file.\n\t* call-info.h: New file.\n\t* engine.cc: Include \"analyzer/call-info.h\" and <memory>.\n\t(impl_region_model_context::impl_region_model_context): Update for\n\tnew m_path_ctxt field.\n\t(impl_region_model_context::bifurcate): New.\n\t(impl_region_model_context::terminate_path): New.\n\t(impl_region_model_context::get_malloc_map): New.\n\t(impl_sm_context::impl_sm_context): Update for new m_path_ctxt\n\tfield.\n\t(impl_sm_context::get_fndecl_for_call): Likewise.\n\t(impl_sm_context::set_next_state): Likewise.\n\t(impl_sm_context::warn): Likewise.\n\t(impl_sm_context::is_zero_assignment): Likewise.\n\t(impl_sm_context::get_path_context): New.\n\t(impl_sm_context::m_path_ctxt): New.\n\t(impl_region_model_context::on_condition): Update for new\n\tpath_ctxt param.  Handle m_enode_for_diag being NULL.\n\t(impl_region_model_context::on_phi): Update for new path_ctxt\n\tparam.\n\t(exploded_node::on_stmt): Add path_ctxt param, updating ctor calls\n\tto use it as necessary.  Use it to bail out after sm-handling,\n\tif needed.\n\t(exploded_node::detect_leaks): Update for new path_ctxt param.\n\t(dynamic_call_info_t::update_model): Update for conversion of\n\texploded_edge::custom_info_t to custom_edge_info.\n\t(dynamic_call_info_t::add_events_to_path): Likewise.\n\t(rewind_info_t::update_model): Likewise.\n\t(rewind_info_t::add_events_to_path): Likewise.\n\t(exploded_edge::exploded_edge): Likewise.\n\t(exploded_graph::add_edge): Likewise.\n\t(exploded_graph::maybe_process_run_of_before_supernode_enodes):\n\tUpdate for new path_ctxt param.\n\t(class impl_path_context): New.\n\t(exploded_graph::process_node): Update for new path_ctxt param.\n\tCreate an impl_path_context and pass it to exploded_node::on_stmt.\n\tUse it to terminate iterating stmts if terminate_path is called\n\ton it.  After processing a run of stmts, query path_ctxt to\n\tpotentially terminate the analysis path, and/or to \"bifurcate\" the\n\tanalysis into multiple additional paths.\n\t(feasibility_state::maybe_update_for_edge): Update for new\n\tupdate_model ctxt param.\n\t* exploded-graph.h\n\t(impl_region_model_context::impl_region_model_context): Add\n\tpath_ctxt param.\n\t(impl_region_model_context::bifurcate): New.\n\t(impl_region_model_context::terminate_path): New\n\t(impl_region_model_context::get_ext_state): New.\n\t(impl_region_model_context::get_malloc_map): New.\n\t(impl_region_model_context::m_path_ctxt): New field.\n\t(exploded_node::on_stmt): Add path_ctxt param.\n\t(class exploded_edge::custom_info_t): Move to analyzer.h, renaming\n\tto custom_edge_info, and making the changes as noted in analyzer.h\n\tabove.\n\t(exploded_edge::exploded_edge): Update for these changes to\n\texploded_edge::custom_info_t.\n\t(exploded_edge::m_custom_info): Likewise.\n\t(class dynamic_call_info_t): Likewise.\n\t(class rewind_info_t): Likewise.\n\t(exploded_graph::add_edge): Likewise.\n\t* program-state.cc (program_state::on_edge): Update for new\n\tpath_ctxt param.\n\t(program_state::push_call): Likewise.\n\t(program_state::returning_call): Likewise.\n\t(program_state::prune_for_point): Likewise.\n\t* region-model-impl-calls.cc: Include \"analyzer/call-info.h\".\n\t(call_details::get_fndecl_for_call): New.\n\t(region_model::impl_call_realloc): Reimplement.\n\t* region-model.cc (region_model::on_call_pre): Move call to\n\timpl_call_realloc to...\n\t(region_model::on_call_post): ...here.  Consolidate creation\n\tof call_details instance.\n\t(noop_region_model_context::bifurcate): New.\n\t(noop_region_model_context::terminate_path): New.\n\t* region-model.h (call_details::get_call_stmt): New.\n\t(call_details::get_fndecl_for_call): New.\n\t(region_model::on_realloc_with_move): New.\n\t(region_model_context::bifurcate): New.\n\t(region_model_context::terminate_path): New.\n\t(region_model_context::get_ext_state): New.\n\t(region_model_context::get_malloc_map): New.\n\t(noop_region_model_context::bifurcate): New.\n\t(noop_region_model_context::terminate_path): New.\n\t(noop_region_model_context::get_ext_state): New.\n\t(noop_region_model_context::get_malloc_map): New.\n\t* sm-malloc.cc: Include \"analyzer/program-state.h\".\n\t(malloc_state_machine::on_realloc_call): Reimplement.\n\t(malloc_state_machine::on_realloc_with_move): New.\n\t(region_model::on_realloc_with_move): New.\n\t* sm-signal.cc (class signal_delivery_edge_info_t): Update for\n\tconversion from exploded_edge::custom_info_t to custom_edge_info.\n\t* sm.h (sm_context::get_path_context): New.\n\t* svalue.cc (svalue::maybe_get_constant): Call\n\tunwrap_any_unmergeable.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/99260\n\t* gcc.dg/analyzer/capacity-2.c: Update for changes to realloc\n\tanalysis.\n\t* gcc.dg/analyzer/pr99193-1.c: Likewise.\n\t* gcc.dg/analyzer/pr99193-3.c: Likewise.\n\t* gcc.dg/analyzer/realloc-1.c: Likewise.  Add test coverage for\n\trealloc of non-heap pointer, realloc from mismatching allocator,\n\tand realloc on a freed pointer.\n\t* gcc.dg/analyzer/realloc-2.c: New test.", "tree": {"sha": "8a9552d0878eabb878aa338625f6008291ee7a0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a9552d0878eabb878aa338625f6008291ee7a0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eafa9d969237fd8f712c4b25a8c58932c01f44b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eafa9d969237fd8f712c4b25a8c58932c01f44b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eafa9d969237fd8f712c4b25a8c58932c01f44b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eafa9d969237fd8f712c4b25a8c58932c01f44b4/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8960a29b18b830ff0490b7f52051903fba472e45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8960a29b18b830ff0490b7f52051903fba472e45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8960a29b18b830ff0490b7f52051903fba472e45"}], "stats": {"total": 1174, "additions": 1042, "deletions": 132}, "files": [{"sha": "f0c560fe45b7751af76b5d3a9a6a236e9e15ff10", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -1249,6 +1249,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/analyzer-pass.o \\\n \tanalyzer/analyzer-selftests.o \\\n \tanalyzer/bar-chart.o \\\n+\tanalyzer/call-info.o \\\n \tanalyzer/call-string.o \\\n \tanalyzer/checker-path.o \\\n \tanalyzer/complexity.o \\"}, {"sha": "7ad1081ca6cf02db61e9dc6d20be2bd7b07bae1e", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -220,6 +220,57 @@ enum access_direction\n   DIR_WRITE\n };\n \n+/* Abstract base class for associating custom data with an\n+   exploded_edge, for handling non-standard edges such as\n+   rewinding from a longjmp, signal handlers, etc.\n+   Also used when \"bifurcating\" state: splitting the execution\n+   path in non-standard ways (e.g. for simulating the various\n+   outcomes of \"realloc\").  */\n+\n+class custom_edge_info\n+{\n+public:\n+  virtual ~custom_edge_info () {}\n+\n+  /* Hook for making .dot label more readable.  */\n+  virtual void print (pretty_printer *pp) const = 0;\n+\n+  /* Hook for updating MODEL within exploded_path::feasible_p\n+     and when handling bifurcation.  */\n+  virtual bool update_model (region_model *model,\n+\t\t\t     const exploded_edge *eedge,\n+\t\t\t     region_model_context *ctxt) const = 0;\n+\n+  virtual void add_events_to_path (checker_path *emission_path,\n+\t\t\t\t   const exploded_edge &eedge) const = 0;\n+};\n+\n+/* Abstract base class for splitting state.\n+\n+   Most of the state-management code in the analyzer involves\n+   modifying state objects in-place, which assumes a single outcome.\n+\n+   This class provides an escape hatch to allow for multiple outcomes\n+   for such updates e.g. for modelling multiple outcomes from function\n+   calls, such as the various outcomes of \"realloc\".  */\n+\n+class path_context\n+{\n+public:\n+  virtual ~path_context () {}\n+\n+  /* Hook for clients to split state with a non-standard path.\n+     Take ownership of INFO.  */\n+  virtual void bifurcate (custom_edge_info *info) = 0;\n+\n+  /* Hook for clients to terminate the standard path.  */\n+  virtual void terminate_path () = 0;\n+\n+  /* Hook for clients to determine if the standard path has been\n+     terminated.  */\n+  virtual bool terminate_path_p () const = 0;\n+};\n+\n } // namespace ana\n \n extern bool is_special_named_call_p (const gcall *call, const char *funcname,"}, {"sha": "1d44cb8822180ee9e6f1ae6ab7ae741921207f36", "filename": "gcc/analyzer/call-info.cc", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fcall-info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fcall-info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-info.cc?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -0,0 +1,162 @@\n+/* Subclasses of custom_edge_info for describing outcomes of function calls.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"diagnostic-core.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"tristate.h\"\n+#include \"bitmap.h\"\n+#include \"selftest.h\"\n+#include \"function.h\"\n+#include \"json.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"sbitmap.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/constraint-manager.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/region-model-reachability.h\"\n+#include \"analyzer/analyzer-selftests.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"diagnostic-path.h\"\n+#include \"analyzer/checker-path.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"shortest-paths.h\"\n+#include \"analyzer/exploded-graph.h\"\n+#include \"analyzer/call-info.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* class call_info : public custom_eedge_info_t.  */\n+\n+/* Implementation of custom_edge_info::print vfunc for call_info:\n+   use get_desc to get a label_text, and print it to PP.  */\n+\n+void\n+call_info::print (pretty_printer *pp) const\n+{\n+  label_text desc (get_desc (pp_show_color (pp)));\n+  pp_string (pp, desc.m_buffer);\n+  desc.maybe_free ();\n+}\n+\n+/* Implementation of custom_edge_info::add_events_to_path vfunc for\n+   call_info: add a custom_event using call_info::get_desc as its\n+   description.  */\n+\n+void\n+call_info::add_events_to_path (checker_path *emission_path,\n+\t\t\t       const exploded_edge &eedge) const\n+{\n+  class call_event : public custom_event\n+  {\n+  public:\n+    call_event (location_t loc, tree fndecl, int depth,\n+\t\tconst call_info *call_info)\n+      : custom_event (loc, fndecl, depth),\n+\tm_call_info (call_info)\n+    {}\n+\n+    label_text get_desc (bool can_colorize) const\n+    {\n+      return m_call_info->get_desc (can_colorize);\n+    }\n+\n+  private:\n+    const call_info *m_call_info;\n+  };\n+\n+  const exploded_node *src_node = eedge.m_src;\n+  const program_point &src_point = src_node->get_point ();\n+  tree caller_fndecl = src_point.get_fndecl ();\n+  const int stack_depth = src_point.get_stack_depth ();\n+\n+  emission_path->add_event (new call_event (get_call_stmt ()->location,\n+\t\t\t\t\t    caller_fndecl,\n+\t\t\t\t\t    stack_depth,\n+\t\t\t\t\t    this));\n+}\n+\n+/* Recreate a call_details instance from this call_info.  */\n+\n+call_details\n+call_info::get_call_details (region_model *model,\n+\t\t\t     region_model_context *ctxt) const\n+{\n+  return call_details (m_call_stmt, model, ctxt);\n+}\n+\n+/* call_info's ctor.\n+\n+   The call_info instance will outlive the call_details instance;\n+   call_details instances are typically created on the stack.  */\n+\n+call_info::call_info (const call_details &cd)\n+: m_call_stmt (cd.get_call_stmt ()),\n+  m_fndecl (cd.get_fndecl_for_call ())\n+{\n+  gcc_assert (m_fndecl);\n+}\n+\n+/* class success_call_info : public call_info.  */\n+\n+/* Implementation of call_info::get_desc vfunc for success_call_info.  */\n+\n+label_text\n+success_call_info::get_desc (bool can_colorize) const\n+{\n+  return make_label_text (can_colorize, \"when %qE succeeds\", get_fndecl ());\n+}\n+\n+/* class failed_call_info : public call_info.  */\n+\n+/* Implementation of call_info::get_desc vfunc for failed_call_info.  */\n+\n+label_text\n+failed_call_info::get_desc (bool can_colorize) const\n+{\n+  return make_label_text (can_colorize, \"when %qE fails\", get_fndecl ());\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "369d217a22f5f2600725e98a3b7e746eaf46991d", "filename": "gcc/analyzer/call-info.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fcall-info.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fcall-info.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-info.h?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -0,0 +1,83 @@\n+/* Subclasses of custom_edge_info for describing outcomes of function calls.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_CALL_INFO_H\n+#define GCC_ANALYZER_CALL_INFO_H\n+\n+namespace ana {\n+\n+/* Subclass of custom_edge_info for an outcome of a call.\n+   This is still abstract; the update_model and get_desc vfuncs must be\n+   implemented.  */\n+\n+class call_info : public custom_edge_info\n+{\n+public:\n+  void print (pretty_printer *pp) const FINAL OVERRIDE;\n+  void add_events_to_path (checker_path *emission_path,\n+\t\t\t   const exploded_edge &eedge) const FINAL OVERRIDE;\n+\n+  const gcall *get_call_stmt () const { return m_call_stmt; }\n+  tree get_fndecl () const { return m_fndecl; }\n+\n+  virtual label_text get_desc (bool can_colorize) const = 0;\n+\n+  call_details get_call_details (region_model *model,\n+\t\t\t\t region_model_context *ctxt) const;\n+\n+protected:\n+  call_info (const call_details &cd);\n+\n+private:\n+  const gcall *m_call_stmt;\n+  tree m_fndecl;\n+};\n+\n+/* Subclass of call_info for a \"success\" outcome of a call,\n+   adding a \"when `FNDECL' succeeds\" message.\n+   This is still abstract: the custom_edge_info::update_model vfunc\n+   must be implemented.  */\n+\n+class success_call_info : public call_info\n+{\n+public:\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+\n+protected:\n+  success_call_info (const call_details &cd) : call_info (cd) {}\n+};\n+\n+/* Subclass of call_info for a \"failure\" outcome of a call,\n+   adding a \"when `FNDECL' fails\" message.\n+   This is still abstract: the custom_edge_info::update_model vfunc\n+   must be implemented.  */\n+\n+class failed_call_info : public call_info\n+{\n+public:\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+\n+protected:\n+  failed_call_info (const call_details &cd) : call_info (cd) {}\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_CALL_INFO_H */"}, {"sha": "24f0931197dde4b626a159e71491e0973d9214b7", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 230, "deletions": 41, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -62,9 +62,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/checker-path.h\"\n #include \"analyzer/state-purge.h\"\n #include \"analyzer/bar-chart.h\"\n+#include \"analyzer/call-info.h\"\n #include <zlib.h>\n #include \"plugin.h\"\n #include \"target.h\"\n+#include <memory>\n \n /* For an overview, see gcc/doc/analyzer.texi.  */\n \n@@ -80,6 +82,7 @@ impl_region_model_context (exploded_graph &eg,\n \t\t\t   const program_state *old_state,\n \t\t\t   program_state *new_state,\n \t\t\t   uncertainty_t *uncertainty,\n+\t\t\t   path_context *path_ctxt,\n \t\t\t   const gimple *stmt,\n \t\t\t   stmt_finder *stmt_finder)\n : m_eg (&eg), m_logger (eg.get_logger ()),\n@@ -89,7 +92,8 @@ impl_region_model_context (exploded_graph &eg,\n   m_stmt (stmt),\n   m_stmt_finder (stmt_finder),\n   m_ext_state (eg.get_ext_state ()),\n-  m_uncertainty (uncertainty)\n+  m_uncertainty (uncertainty),\n+  m_path_ctxt (path_ctxt)\n {\n }\n \n@@ -104,7 +108,8 @@ impl_region_model_context (program_state *state,\n   m_stmt (NULL),\n   m_stmt_finder (NULL),\n   m_ext_state (ext_state),\n-  m_uncertainty (uncertainty)\n+  m_uncertainty (uncertainty),\n+  m_path_ctxt (NULL)\n {\n }\n \n@@ -183,6 +188,37 @@ impl_region_model_context::purge_state_involving (const svalue *sval)\n     smap->purge_state_involving (sval, m_ext_state);\n }\n \n+void\n+impl_region_model_context::bifurcate (custom_edge_info *info)\n+{\n+  if (m_path_ctxt)\n+    m_path_ctxt->bifurcate (info);\n+  else\n+    delete info;\n+}\n+\n+void\n+impl_region_model_context::terminate_path ()\n+{\n+  if (m_path_ctxt)\n+    return m_path_ctxt->terminate_path ();\n+}\n+\n+bool\n+impl_region_model_context::get_malloc_map (sm_state_map **out_smap,\n+\t\t\t\t\t   const state_machine **out_sm,\n+\t\t\t\t\t   unsigned *out_sm_idx)\n+{\n+  unsigned malloc_sm_idx;\n+  if (!m_ext_state.get_sm_idx_by_name (\"malloc\", &malloc_sm_idx))\n+    return false;\n+\n+  *out_smap = m_new_state->m_checker_states[malloc_sm_idx];\n+  *out_sm = &m_ext_state.get_sm (malloc_sm_idx);\n+  *out_sm_idx = malloc_sm_idx;\n+  return true;\n+}\n+\n /* struct setjmp_record.  */\n \n int\n@@ -237,12 +273,14 @@ class impl_sm_context : public sm_context\n \t\t   program_state *new_state,\n \t\t   const sm_state_map *old_smap,\n \t\t   sm_state_map *new_smap,\n+\t\t   path_context *path_ctxt,\n \t\t   stmt_finder *stmt_finder = NULL)\n   : sm_context (sm_idx, sm),\n     m_logger (eg.get_logger ()),\n     m_eg (eg), m_enode_for_diag (enode_for_diag),\n     m_old_state (old_state), m_new_state (new_state),\n     m_old_smap (old_smap), m_new_smap (new_smap),\n+    m_path_ctxt (path_ctxt),\n     m_stmt_finder (stmt_finder)\n   {\n   }\n@@ -252,7 +290,7 @@ class impl_sm_context : public sm_context\n   tree get_fndecl_for_call (const gcall *call) FINAL OVERRIDE\n   {\n     impl_region_model_context old_ctxt\n-      (m_eg, m_enode_for_diag, NULL, NULL/*m_enode->get_state ()*/,\n+      (m_eg, m_enode_for_diag, NULL, NULL, NULL/*m_enode->get_state ()*/,\n        NULL, call);\n     region_model *model = m_new_state->m_region_model;\n     return model->get_fndecl_for_call (call, &old_ctxt);\n@@ -292,7 +330,7 @@ class impl_sm_context : public sm_context\n     LOG_FUNC (logger);\n     impl_region_model_context new_ctxt (m_eg, m_enode_for_diag,\n \t\t\t\t\tm_old_state, m_new_state,\n-\t\t\t\t\tNULL,\n+\t\t\t\t\tNULL, NULL,\n \t\t\t\t\tstmt);\n     const svalue *var_new_sval\n       = m_new_state->m_region_model->get_rvalue (var, &new_ctxt);\n@@ -320,12 +358,12 @@ class impl_sm_context : public sm_context\n     logger * const logger = get_logger ();\n     LOG_FUNC (logger);\n     impl_region_model_context old_ctxt\n-      (m_eg, m_enode_for_diag, NULL, NULL/*m_enode->get_state ()*/,\n+      (m_eg, m_enode_for_diag, NULL, NULL, NULL/*m_enode->get_state ()*/,\n        NULL, stmt);\n \n     impl_region_model_context new_ctxt (m_eg, m_enode_for_diag,\n \t\t\t\t\tm_old_state, m_new_state,\n-\t\t\t\t\tNULL,\n+\t\t\t\t\tNULL, NULL,\n \t\t\t\t\tstmt);\n     const svalue *origin_new_sval\n       = m_new_state->m_region_model->get_rvalue (origin, &new_ctxt);\n@@ -353,7 +391,7 @@ class impl_sm_context : public sm_context\n     LOG_FUNC (get_logger ());\n     gcc_assert (d); // take ownership\n     impl_region_model_context old_ctxt\n-      (m_eg, m_enode_for_diag, m_old_state, m_new_state, NULL, NULL);\n+      (m_eg, m_enode_for_diag, m_old_state, m_new_state, NULL, NULL, NULL);\n \n     const svalue *var_old_sval\n       = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n@@ -418,7 +456,7 @@ class impl_sm_context : public sm_context\n     if (!assign_stmt)\n      return NULL_TREE;\n     impl_region_model_context old_ctxt\n-      (m_eg, m_enode_for_diag, m_old_state, m_new_state, NULL, stmt);\n+      (m_eg, m_enode_for_diag, m_old_state, m_new_state, NULL, NULL, stmt);\n     if (const svalue *sval\n \t= m_new_state->m_region_model->get_gassign_result (assign_stmt,\n \t\t\t\t\t\t\t    &old_ctxt))\n@@ -428,13 +466,19 @@ class impl_sm_context : public sm_context\n     return NULL_TREE;\n   }\n \n+  path_context *get_path_context () const FINAL OVERRIDE\n+  {\n+    return m_path_ctxt;\n+  }\n+\n   log_user m_logger;\n   exploded_graph &m_eg;\n   exploded_node *m_enode_for_diag;\n   const program_state *m_old_state;\n   program_state *m_new_state;\n   const sm_state_map *m_old_smap;\n   sm_state_map *m_new_smap;\n+  path_context *m_path_ctxt;\n   stmt_finder *m_stmt_finder;\n };\n \n@@ -751,9 +795,13 @@ impl_region_model_context::on_condition (const svalue *lhs,\n       impl_sm_context sm_ctxt (*m_eg, sm_idx, sm, m_enode_for_diag,\n \t\t\t       m_old_state, m_new_state,\n \t\t\t       m_old_state->m_checker_states[sm_idx],\n-\t\t\t       m_new_state->m_checker_states[sm_idx]);\n+\t\t\t       m_new_state->m_checker_states[sm_idx],\n+\t\t\t       m_path_ctxt);\n       sm.on_condition (&sm_ctxt,\n-\t\t       m_enode_for_diag->get_supernode (), m_stmt,\n+\t\t       (m_enode_for_diag\n+\t\t\t? m_enode_for_diag->get_supernode ()\n+\t\t\t: NULL),\n+\t\t       m_stmt,\n \t\t       lhs, op, rhs);\n     }\n }\n@@ -773,7 +821,8 @@ impl_region_model_context::on_phi (const gphi *phi, tree rhs)\n       impl_sm_context sm_ctxt (*m_eg, sm_idx, sm, m_enode_for_diag,\n \t\t\t       m_old_state, m_new_state,\n \t\t\t       m_old_state->m_checker_states[sm_idx],\n-\t\t\t       m_new_state->m_checker_states[sm_idx]);\n+\t\t\t       m_new_state->m_checker_states[sm_idx],\n+\t\t\t       m_path_ctxt);\n       sm.on_phi (&sm_ctxt, m_enode_for_diag->get_supernode (), phi, rhs);\n     }\n }\n@@ -1190,7 +1239,8 @@ exploded_node::on_stmt (exploded_graph &eg,\n \t\t\tconst supernode *snode,\n \t\t\tconst gimple *stmt,\n \t\t\tprogram_state *state,\n-\t\t\tuncertainty_t *uncertainty)\n+\t\t\tuncertainty_t *uncertainty,\n+\t\t\tpath_context *path_ctxt)\n {\n   logger *logger = eg.get_logger ();\n   LOG_SCOPE (logger);\n@@ -1215,7 +1265,7 @@ exploded_node::on_stmt (exploded_graph &eg,\n \n   impl_region_model_context ctxt (eg, this,\n \t\t\t\t  &old_state, state, uncertainty,\n-\t\t\t\t  stmt);\n+\t\t\t\t  path_ctxt, stmt);\n \n   bool unknown_side_effects = false;\n   bool terminate_path = false;\n@@ -1235,13 +1285,16 @@ exploded_node::on_stmt (exploded_graph &eg,\n \t= old_state.m_checker_states[sm_idx];\n       sm_state_map *new_smap = state->m_checker_states[sm_idx];\n       impl_sm_context sm_ctxt (eg, sm_idx, sm, this, &old_state, state,\n-\t\t\t       old_smap, new_smap);\n+\t\t\t       old_smap, new_smap, path_ctxt);\n \n       /* Allow the state_machine to handle the stmt.  */\n       if (sm.on_stmt (&sm_ctxt, snode, stmt))\n \tunknown_side_effects = false;\n     }\n \n+  if (path_ctxt->terminate_path_p ())\n+    return on_stmt_flags::terminate_path ();\n+\n   on_stmt_post (stmt, state, unknown_side_effects, &ctxt);\n \n   return on_stmt_flags ();\n@@ -1592,7 +1645,7 @@ exploded_node::detect_leaks (exploded_graph &eg)\n \n   uncertainty_t uncertainty;\n   impl_region_model_context ctxt (eg, this,\n-\t\t\t\t  &old_state, &new_state, &uncertainty,\n+\t\t\t\t  &old_state, &new_state, &uncertainty, NULL,\n \t\t\t\t  get_stmt ());\n   const svalue *result = NULL;\n   new_state.m_region_model->pop_frame (NULL, &result, &ctxt);\n@@ -1627,27 +1680,30 @@ exploded_node::dump_succs_and_preds (FILE *outf) const\n   }\n }\n \n-/* class dynamic_call_info_t : public exploded_edge::custom_info_t.  */\n+/* class dynamic_call_info_t : public custom_edge_info.  */\n \n-/* Implementation of exploded_edge::custom_info_t::update_model vfunc\n+/* Implementation of custom_edge_info::update_model vfunc\n    for dynamic_call_info_t.\n \n    Update state for the dynamically discorverd calls */\n \n-void\n+bool\n dynamic_call_info_t::update_model (region_model *model,\n-\t\t\t\t   const exploded_edge &eedge)\n+\t\t\t\t   const exploded_edge *eedge,\n+\t\t\t\t   region_model_context *) const\n {\n-  const program_state &dest_state = eedge.m_dest->get_state ();\n+  gcc_assert (eedge);\n+  const program_state &dest_state = eedge->m_dest->get_state ();\n   *model = *dest_state.m_region_model;\n+  return true;\n }\n \n-/* Implementation of exploded_edge::custom_info_t::add_events_to_path vfunc\n+/* Implementation of custom_edge_info::add_events_to_path vfunc\n    for dynamic_call_info_t.  */\n \n void\n dynamic_call_info_t::add_events_to_path (checker_path *emission_path,\n-\t\t\t\t   const exploded_edge &eedge)\n+\t\t\t\t   const exploded_edge &eedge) const\n {\n   const exploded_node *src_node = eedge.m_src;\n   const program_point &src_point = src_node->get_point ();\n@@ -1671,36 +1727,39 @@ dynamic_call_info_t::add_events_to_path (checker_path *emission_path,\n \n }\n \n-/* class rewind_info_t : public exploded_edge::custom_info_t.  */\n+/* class rewind_info_t : public custom_edge_info.  */\n \n-/* Implementation of exploded_edge::custom_info_t::update_model vfunc\n+/* Implementation of custom_edge_info::update_model vfunc\n    for rewind_info_t.\n \n    Update state for the special-case of a rewind of a longjmp\n    to a setjmp (which doesn't have a superedge, but does affect\n    state).  */\n \n-void\n+bool\n rewind_info_t::update_model (region_model *model,\n-\t\t\t     const exploded_edge &eedge)\n+\t\t\t     const exploded_edge *eedge,\n+\t\t\t     region_model_context *) const\n {\n-  const program_point &longjmp_point = eedge.m_src->get_point ();\n-  const program_point &setjmp_point = eedge.m_dest->get_point ();\n+  gcc_assert (eedge);\n+  const program_point &longjmp_point = eedge->m_src->get_point ();\n+  const program_point &setjmp_point = eedge->m_dest->get_point ();\n \n   gcc_assert (longjmp_point.get_stack_depth ()\n \t      >= setjmp_point.get_stack_depth ());\n \n   model->on_longjmp (get_longjmp_call (),\n \t\t     get_setjmp_call (),\n \t\t     setjmp_point.get_stack_depth (), NULL);\n+  return true;\n }\n \n-/* Implementation of exploded_edge::custom_info_t::add_events_to_path vfunc\n+/* Implementation of custom_edge_info::add_events_to_path vfunc\n    for rewind_info_t.  */\n \n void\n rewind_info_t::add_events_to_path (checker_path *emission_path,\n-\t\t\t\t   const exploded_edge &eedge)\n+\t\t\t\t   const exploded_edge &eedge) const\n {\n   const exploded_node *src_node = eedge.m_src;\n   const program_point &src_point = src_node->get_point ();\n@@ -1727,7 +1786,7 @@ rewind_info_t::add_events_to_path (checker_path *emission_path,\n \n exploded_edge::exploded_edge (exploded_node *src, exploded_node *dest,\n \t\t\t      const superedge *sedge,\n-\t\t\t      custom_info_t *custom_info)\n+\t\t\t      custom_edge_info *custom_info)\n : dedge<eg_traits> (src, dest), m_sedge (sedge),\n   m_custom_info (custom_info)\n {\n@@ -2432,7 +2491,7 @@ exploded_graph::get_or_create_node (const program_point &point,\n exploded_edge *\n exploded_graph::add_edge (exploded_node *src, exploded_node *dest,\n \t\t\t  const superedge *sedge,\n-\t\t\t  exploded_edge::custom_info_t *custom_info)\n+\t\t\t  custom_edge_info *custom_info)\n {\n   if (get_logger ())\n     get_logger ()->log (\"creating edge EN: %i -> EN: %i\",\n@@ -2866,7 +2925,7 @@ maybe_process_run_of_before_supernode_enodes (exploded_node *enode)\n \t  uncertainty_t uncertainty;\n \t  impl_region_model_context ctxt (*this, iter_enode,\n \t\t\t\t\t  &state, next_state,\n-\t\t\t\t\t  &uncertainty, NULL);\n+\t\t\t\t\t  &uncertainty, NULL, NULL);\n \t  const cfg_superedge *last_cfg_superedge\n \t    = iter_sedge->dyn_cast_cfg_superedge ();\n \t  if (last_cfg_superedge)\n@@ -3095,6 +3154,72 @@ exploded_graph::maybe_create_dynamic_call (const gcall *call,\n   return false;\n }\n \n+/* Subclass of path_context for use within exploded_graph::process_node,\n+   so that we can split states e.g. at \"realloc\" calls.  */\n+\n+class impl_path_context : public path_context\n+{\n+public:\n+  impl_path_context (const program_state *cur_state)\n+  : m_cur_state (cur_state),\n+    m_terminate_path (false)\n+  {\n+  }\n+\n+  bool bifurcation_p () const\n+  {\n+    return m_custom_eedge_infos.length () > 0;\n+  }\n+\n+  const program_state &get_state_at_bifurcation () const\n+  {\n+    gcc_assert (m_state_at_bifurcation);\n+    return *m_state_at_bifurcation;\n+  }\n+\n+  void\n+  bifurcate (custom_edge_info *info) FINAL OVERRIDE\n+  {\n+    if (m_state_at_bifurcation)\n+      /* Verify that the state at bifurcation is consistent when we\n+\t split into multiple out-edges.  */\n+      gcc_assert (*m_state_at_bifurcation == *m_cur_state);\n+    else\n+      /* Take a copy of the cur_state at the moment when bifurcation\n+\t happens.  */\n+      m_state_at_bifurcation\n+\t= std::unique_ptr<program_state> (new program_state (*m_cur_state));\n+\n+    /* Take ownership of INFO.  */\n+    m_custom_eedge_infos.safe_push (info);\n+  }\n+\n+  void terminate_path () FINAL OVERRIDE\n+  {\n+    m_terminate_path = true;\n+  }\n+\n+  bool terminate_path_p () const FINAL OVERRIDE\n+  {\n+    return m_terminate_path;\n+  }\n+\n+  const vec<custom_edge_info *> & get_custom_eedge_infos ()\n+  {\n+    return m_custom_eedge_infos;\n+  }\n+\n+private:\n+  const program_state *m_cur_state;\n+\n+  /* Lazily-created copy of the state before the split.  */\n+  std::unique_ptr<program_state> m_state_at_bifurcation;\n+\n+  auto_vec <custom_edge_info *> m_custom_eedge_infos;\n+\n+  bool m_terminate_path;\n+};\n+\n /* The core of exploded_graph::process_worklist (the main analysis loop),\n    handling one node in the worklist.\n \n@@ -3150,7 +3275,7 @@ exploded_graph::process_node (exploded_node *node)\n \t  {\n \t    impl_region_model_context ctxt (*this, node,\n \t\t\t\t\t    &state, &next_state,\n-\t\t\t\t\t    &uncertainty, NULL);\n+\t\t\t\t\t    &uncertainty, NULL, NULL);\n \t    const cfg_superedge *last_cfg_superedge\n \t      = point.get_from_edge ()->dyn_cast_cfg_superedge ();\n \t    if (last_cfg_superedge)\n@@ -3188,6 +3313,9 @@ exploded_graph::process_node (exploded_node *node)\n \t   the sm-state-change occurs on an edge where the src enode has\n \t   exactly one stmt, the one that caused the change. */\n \tprogram_state next_state (state);\n+\n+\timpl_path_context path_ctxt (&next_state);\n+\n \tuncertainty_t uncertainty;\n \tconst supernode *snode = point.get_supernode ();\n \tunsigned stmt_idx;\n@@ -3210,7 +3338,8 @@ exploded_graph::process_node (exploded_node *node)\n \n \t    /* Process the stmt.  */\n \t    exploded_node::on_stmt_flags flags\n-\t      = node->on_stmt (*this, snode, stmt, &next_state, &uncertainty);\n+\t      = node->on_stmt (*this, snode, stmt, &next_state, &uncertainty,\n+\t\t\t       &path_ctxt);\n \t    node->m_num_processed_stmts++;\n \n \t    /* If flags.m_terminate_path, stop analyzing; any nodes/edges\n@@ -3222,7 +3351,7 @@ exploded_graph::process_node (exploded_node *node)\n \t      {\n \t\timpl_region_model_context ctxt (*this, node,\n \t\t\t\t\t\t&old_state, &next_state,\n-\t\t\t\t\t\t&uncertainty, stmt);\n+\t\t\t\t\t\t&uncertainty, NULL, stmt);\n \t\tprogram_state::detect_leaks (old_state, next_state, NULL,\n \t\t\t\t\t     get_ext_state (), &ctxt);\n \t      }\n@@ -3238,7 +3367,9 @@ exploded_graph::process_node (exploded_node *node)\n \t\t\t\t\t\t     &uncertainty);\n \n \t    if (flag_analyzer_fine_grained\n-\t\t|| state_change_requires_new_enode_p (old_state, next_state))\n+\t\t|| state_change_requires_new_enode_p (old_state, next_state)\n+\t\t|| path_ctxt.bifurcation_p ()\n+\t\t|| path_ctxt.terminate_path_p ())\n \t      {\n \t\tprogram_point split_point\n \t\t  = program_point::before_stmt (point.get_supernode (),\n@@ -3282,9 +3413,66 @@ exploded_graph::process_node (exploded_node *node)\n \t\t\t\t\t   point.get_call_string ())\n \t     : program_point::after_supernode (point.get_supernode (),\n \t\t\t\t\t       point.get_call_string ()));\n-\texploded_node *next = get_or_create_node (next_point, next_state, node);\n-\tif (next)\n-\t  add_edge (node, next, NULL);\n+\tif (path_ctxt.terminate_path_p ())\n+\t  {\n+\t    if (logger)\n+\t      logger->log (\"not adding node: terminating path\");\n+\t  }\n+\telse\n+\t  {\n+\t    exploded_node *next\n+\t      = get_or_create_node (next_point, next_state, node);\n+\t    if (next)\n+\t      add_edge (node, next, NULL);\n+\t  }\n+\n+\t/* If we have custom edge infos, \"bifurcate\" the state\n+\t   accordingly, potentially creating a new state/enode/eedge\n+\t   instances.  For example, to handle a \"realloc\" call, we\n+\t   might split into 3 states, for the \"failure\",\n+\t   \"resizing in place\", and \"moving to a new buffer\" cases.  */\n+\tfor (auto edge_info : path_ctxt.get_custom_eedge_infos ())\n+\t  {\n+\t    if (logger)\n+\t      {\n+\t\tlogger->start_log_line ();\n+\t\tlogger->log_partial (\"bifurcating for edge: \");\n+\t\tedge_info->print (logger->get_printer ());\n+\t\tlogger->end_log_line ();\n+\t      }\n+\t    program_state bifurcated_new_state\n+\t      (path_ctxt.get_state_at_bifurcation ());\n+\n+\t    /* Apply edge_info to state.  */\n+\t    impl_region_model_context\n+\t      bifurcation_ctxt (*this,\n+\t\t\t\tNULL, // enode_for_diag\n+\t\t\t\t&path_ctxt.get_state_at_bifurcation (),\n+\t\t\t\t&bifurcated_new_state,\n+\t\t\t\tNULL, // uncertainty_t *uncertainty\n+\t\t\t\tNULL, // path_context *path_ctxt\n+\t\t\t\tstmt);\n+\t    if (edge_info->update_model (bifurcated_new_state.m_region_model,\n+\t\t\t\t\t NULL, /* no exploded_edge yet.  */\n+\t\t\t\t\t &bifurcation_ctxt))\n+\t      {\n+\t\texploded_node *next2\n+\t\t  = get_or_create_node (next_point, bifurcated_new_state, node);\n+\t\tif (next2)\n+\t\t  {\n+\t\t    /* Take ownership of edge_info.  */\n+\t\t    add_edge (node, next2, NULL, edge_info);\n+\t\t  }\n+\t\telse\n+\t\t  delete edge_info;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (logger)\n+\t\t  logger->log (\"infeasible state, not adding node\");\n+\t\tdelete edge_info;\n+\t      }\n+\t  }\n       }\n       break;\n     case PK_AFTER_SUPERNODE:\n@@ -3351,6 +3539,7 @@ exploded_graph::process_node (exploded_node *node)\n                                                 &state,\n                                                 &next_state,\n                                                 &uncertainty,\n+\t\t\t\t\t\tNULL,\n                                                 point.get_stmt());\n \n                 region_model *model = state.m_region_model;\n@@ -3968,7 +4157,7 @@ feasibility_state::maybe_update_for_edge (logger *logger,\n \t}\n       else if (eedge->m_custom_info)\n \t{\n-\t  eedge->m_custom_info->update_model (&m_model, *eedge);\n+\t  eedge->m_custom_info->update_model (&m_model, eedge, NULL);\n \t}\n     }\n "}, {"sha": "b9c17672aecb3b9ee68240e36607edfb715a77f4", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -37,6 +37,7 @@ class impl_region_model_context : public region_model_context\n \t\t\t     const program_state *old_state,\n \t\t\t     program_state *new_state,\n \t\t\t     uncertainty_t *uncertainty,\n+\t\t\t     path_context *path_ctxt,\n \n \t\t\t     const gimple *stmt,\n \t\t\t     stmt_finder *stmt_finder = NULL);\n@@ -76,6 +77,16 @@ class impl_region_model_context : public region_model_context\n \n   void purge_state_involving (const svalue *sval) FINAL OVERRIDE;\n \n+  void bifurcate (custom_edge_info *info) FINAL OVERRIDE;\n+  void terminate_path () FINAL OVERRIDE;\n+  const extrinsic_state *get_ext_state () const FINAL OVERRIDE\n+  {\n+    return &m_ext_state;\n+  }\n+  bool get_malloc_map (sm_state_map **out_smap,\n+\t\t       const state_machine **out_sm,\n+\t\t       unsigned *out_sm_idx) FINAL OVERRIDE;\n+\n   exploded_graph *m_eg;\n   log_user m_logger;\n   exploded_node *m_enode_for_diag;\n@@ -85,6 +96,7 @@ class impl_region_model_context : public region_model_context\n   stmt_finder *m_stmt_finder;\n   const extrinsic_state &m_ext_state;\n   uncertainty_t *m_uncertainty;\n+  path_context *m_path_ctxt;\n };\n \n /* A <program_point, program_state> pair, used internally by\n@@ -224,7 +236,8 @@ class exploded_node : public dnode<eg_traits>\n \t\t\t const supernode *snode,\n \t\t\t const gimple *stmt,\n \t\t\t program_state *state,\n-\t\t\t uncertainty_t *uncertainty);\n+\t\t\t uncertainty_t *uncertainty,\n+\t\t\t path_context *path_ctxt);\n   void on_stmt_pre (exploded_graph &eg,\n \t\t    const gimple *stmt,\n \t\t    program_state *state,\n@@ -319,28 +332,9 @@ class exploded_node : public dnode<eg_traits>\n class exploded_edge : public dedge<eg_traits>\n {\n  public:\n-  /* Abstract base class for associating custom data with an\n-     exploded_edge, for handling non-standard edges such as\n-     rewinding from a longjmp, signal handlers, etc.  */\n-  class custom_info_t\n-  {\n-  public:\n-    virtual ~custom_info_t () {}\n-\n-    /* Hook for making .dot label more readable .  */\n-    virtual void print (pretty_printer *pp) = 0;\n-\n-    /* Hook for updating MODEL within exploded_path::feasible_p.  */\n-    virtual void update_model (region_model *model,\n-\t\t\t       const exploded_edge &eedge) = 0;\n-\n-    virtual void add_events_to_path (checker_path *emission_path,\n-\t\t\t\t     const exploded_edge &eedge) = 0;\n-  };\n-\n   exploded_edge (exploded_node *src, exploded_node *dest,\n \t\t const superedge *sedge,\n-\t\t custom_info_t *custom_info);\n+\t\t custom_edge_info *custom_info);\n   ~exploded_edge ();\n   void dump_dot (graphviz_out *gv, const dump_args_t &args)\n     const FINAL OVERRIDE;\n@@ -356,7 +350,7 @@ class exploded_edge : public dedge<eg_traits>\n      a signal is delivered to a signal-handler.\n \n      Owned by this class.  */\n-  custom_info_t *m_custom_info;\n+  custom_edge_info *m_custom_info;\n \n private:\n   DISABLE_COPY_AND_ASSIGN (exploded_edge);\n@@ -365,7 +359,7 @@ class exploded_edge : public dedge<eg_traits>\n /* Extra data for an exploded_edge that represents dynamic call info ( calls\n    that doesn't have an underlying superedge representing the call ).  */\n \n-class dynamic_call_info_t : public exploded_edge::custom_info_t\n+class dynamic_call_info_t : public custom_edge_info\n {\n public:\n   dynamic_call_info_t (const gcall *dynamic_call,\n@@ -374,19 +368,20 @@ class dynamic_call_info_t : public exploded_edge::custom_info_t\n     m_is_returning_call (is_returning_call)\n   {}\n \n-  void print (pretty_printer *pp) FINAL OVERRIDE\n+  void print (pretty_printer *pp) const FINAL OVERRIDE\n   {\n     if (m_is_returning_call)\n       pp_string (pp, \"dynamic_return\");\n     else\n       pp_string (pp, \"dynamic_call\");\n   }\n \n-  void update_model (region_model *model,\n-\t\t     const exploded_edge &eedge) FINAL OVERRIDE;\n+  bool update_model (region_model *model,\n+\t\t     const exploded_edge *eedge,\n+\t\t     region_model_context *ctxt) const FINAL OVERRIDE;\n \n   void add_events_to_path (checker_path *emission_path,\n-\t\t\t   const exploded_edge &eedge) FINAL OVERRIDE;\n+\t\t\t   const exploded_edge &eedge) const FINAL OVERRIDE;\n private:\n   const gcall *m_dynamic_call;\n   const bool m_is_returning_call;\n@@ -396,7 +391,7 @@ class dynamic_call_info_t : public exploded_edge::custom_info_t\n /* Extra data for an exploded_edge that represents a rewind from a\n    longjmp to a setjmp (or from a siglongjmp to a sigsetjmp).  */\n \n-class rewind_info_t : public exploded_edge::custom_info_t\n+class rewind_info_t : public custom_edge_info\n {\n public:\n   rewind_info_t (const setjmp_record &setjmp_record,\n@@ -405,16 +400,17 @@ class rewind_info_t : public exploded_edge::custom_info_t\n     m_longjmp_call (longjmp_call)\n   {}\n \n-  void print (pretty_printer *pp) FINAL OVERRIDE\n+  void print (pretty_printer *pp) const FINAL OVERRIDE\n   {\n     pp_string (pp, \"rewind\");\n   }\n \n-  void update_model (region_model *model,\n-\t\t     const exploded_edge &eedge) FINAL OVERRIDE;\n+  bool update_model (region_model *model,\n+\t\t     const exploded_edge *eedge,\n+\t\t     region_model_context *ctxt) const FINAL OVERRIDE;\n \n   void add_events_to_path (checker_path *emission_path,\n-\t\t\t   const exploded_edge &eedge) FINAL OVERRIDE;\n+\t\t\t   const exploded_edge &eedge) const FINAL OVERRIDE;\n \n   const program_point &get_setjmp_point () const\n   {\n@@ -829,7 +825,7 @@ class exploded_graph : public digraph<eg_traits>\n \t\t\t\t     exploded_node *enode_for_diag);\n   exploded_edge *add_edge (exploded_node *src, exploded_node *dest,\n \t\t\t   const superedge *sedge,\n-\t\t\t   exploded_edge::custom_info_t *custom = NULL);\n+\t\t\t   custom_edge_info *custom = NULL);\n \n   per_program_point_data *\n   get_or_create_per_program_point_data (const program_point &);"}, {"sha": "c1ff0d88bb85a03194e396c087205b4f52e13b0a", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -1013,7 +1013,7 @@ program_state::on_edge (exploded_graph &eg,\n   impl_region_model_context ctxt (eg, enode,\n \t\t\t\t  &enode->get_state (),\n \t\t\t\t  this,\n-\t\t\t\t  uncertainty,\n+\t\t\t\t  uncertainty, NULL,\n \t\t\t\t  last_stmt);\n   if (!m_region_model->maybe_update_for_edge (*succ,\n \t\t\t\t\t      last_stmt,\n@@ -1052,6 +1052,7 @@ program_state::push_call (exploded_graph &eg,\n                                   &enode->get_state (),\n                                   this,\n                                   uncertainty,\n+\t\t\t\t  NULL,\n                                   last_stmt);\n   m_region_model->update_for_gcall (call_stmt, &ctxt);\n }\n@@ -1074,6 +1075,7 @@ program_state::returning_call (exploded_graph &eg,\n                                   &enode->get_state (),\n                                   this,\n                                   uncertainty,\n+\t\t\t\t  NULL,\n                                   last_stmt);\n   m_region_model->update_for_return_gcall (call_stmt, &ctxt);\n }\n@@ -1152,7 +1154,7 @@ program_state::prune_for_point (exploded_graph &eg,\n \t  impl_region_model_context ctxt (eg, enode_for_diag,\n \t\t\t\t\t  this,\n \t\t\t\t\t  &new_state,\n-\t\t\t\t\t  uncertainty,\n+\t\t\t\t\t  uncertainty, NULL,\n \t\t\t\t\t  point.get_stmt ());\n \t  detect_leaks (*this, new_state, NULL, eg.get_ext_state (), &ctxt);\n \t}"}, {"sha": "875719f998901318543ee96a7b7a08b7a945be76", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 170, "deletions": 6, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n+#include \"analyzer/call-info.h\"\n #include \"gimple-pretty-print.h\"\n \n #if ENABLE_ANALYZER\n@@ -158,6 +159,15 @@ call_details::get_arg_string_literal (unsigned idx) const\n   return NULL;\n }\n \n+/* Attempt to get the fndecl used at this call, if known, or NULL_TREE\n+   otherwise.  */\n+\n+tree\n+call_details::get_fndecl_for_call () const\n+{\n+  return m_model->get_fndecl_for_call (m_call, m_ctxt);\n+}\n+\n /* Dump a multiline representation of this call to PP.  */\n \n void\n@@ -486,15 +496,169 @@ region_model::impl_call_operator_delete (const call_details &cd)\n     }\n }\n \n-/* Handle the on_call_pre part of \"realloc\".  */\n+/* Handle the on_call_post part of \"realloc\":\n+\n+     void *realloc(void *ptr, size_t size);\n+\n+   realloc(3) is awkward, since it has various different outcomes\n+   that are best modelled as separate exploded nodes/edges.\n+\n+   We first check for sm-state, in\n+   malloc_state_machine::on_realloc_call, so that we\n+   can complain about issues such as realloc of a non-heap\n+   pointer, and terminate the path for such cases (and issue\n+   the complaints at the call's exploded node).\n+\n+   Assuming that these checks pass, we split the path here into\n+   three special cases (and terminate the \"standard\" path):\n+   (A) failure, returning NULL\n+   (B) success, growing the buffer in-place without moving it\n+   (C) success, allocating a new buffer, copying the content\n+   of the old buffer to it, and freeing the old buffer.\n+\n+   Each of these has a custom_edge_info subclass, which updates\n+   the region_model and sm-state of the destination state.  */\n \n void\n-region_model::impl_call_realloc (const call_details &)\n+region_model::impl_call_realloc (const call_details &cd)\n {\n-  /* Currently we don't support bifurcating state, so there's no good\n-     way to implement realloc(3).\n-     For now, malloc_state_machine::on_realloc_call has a minimal\n-     implementation to suppress false positives.  */\n+  /* Three custom subclasses of custom_edge_info, for handling the various\n+     outcomes of \"realloc\".  */\n+\n+  /* Concrete custom_edge_info: a realloc call that fails, returning NULL.  */\n+  class failure : public failed_call_info\n+  {\n+  public:\n+    failure (const call_details &cd)\n+    : failed_call_info (cd)\n+    {\n+    }\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const FINAL OVERRIDE\n+    {\n+      /* Return NULL; everything else is unchanged.  */\n+      const call_details cd (get_call_details (model, ctxt));\n+      const svalue *zero\n+\t= model->m_mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n+      model->set_value (cd.get_lhs_region (),\n+\t\t\tzero,\n+\t\t\tcd.get_ctxt ());\n+      return true;\n+    }\n+  };\n+\n+  /* Concrete custom_edge_info: a realloc call that succeeds, growing\n+     the existing buffer without moving it.  */\n+  class success_no_move : public call_info\n+  {\n+  public:\n+    success_no_move (const call_details &cd)\n+    : call_info (cd)\n+    {\n+    }\n+\n+    label_text get_desc (bool can_colorize) const FINAL OVERRIDE\n+    {\n+      return make_label_text (can_colorize,\n+\t\t\t      \"when %qE succeeds, without moving buffer\",\n+\t\t\t      get_fndecl ());\n+    }\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const FINAL OVERRIDE\n+    {\n+      /* Update size of buffer and return the ptr unchanged.  */\n+      const call_details cd (get_call_details (model, ctxt));\n+      const svalue *ptr_sval = cd.get_arg_svalue (0);\n+      const svalue *size_sval = cd.get_arg_svalue (1);\n+      if (const region *buffer_reg = ptr_sval->maybe_get_region ())\n+\tmodel->set_dynamic_extents (buffer_reg, size_sval);\n+      model->set_value (cd.get_lhs_region (), ptr_sval, cd.get_ctxt ());\n+      const svalue *zero\n+\t= model->m_mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n+      return model->add_constraint (ptr_sval, NE_EXPR, zero, cd.get_ctxt ());\n+    }\n+  };\n+\n+  /* Concrete custom_edge_info: a realloc call that succeeds, freeing\n+     the existing buffer and moving the content to a freshly allocated\n+     buffer.  */\n+  class success_with_move : public call_info\n+  {\n+  public:\n+    success_with_move (const call_details &cd)\n+    : call_info (cd)\n+    {\n+    }\n+\n+    label_text get_desc (bool can_colorize) const FINAL OVERRIDE\n+    {\n+      return make_label_text (can_colorize,\n+\t\t\t      \"when %qE succeeds, moving buffer\",\n+\t\t\t      get_fndecl ());\n+    }\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const FINAL OVERRIDE\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+      const svalue *old_ptr_sval = cd.get_arg_svalue (0);\n+      const svalue *new_size_sval = cd.get_arg_svalue (1);\n+\n+      /* Create the new region.  */\n+      const region *new_reg\n+\t= model->create_region_for_heap_alloc (new_size_sval);\n+      const svalue *new_ptr_sval\n+\t= model->m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n+      if (cd.get_lhs_type ())\n+\tcd.maybe_set_lhs (new_ptr_sval);\n+\n+      if (const region *freed_reg = old_ptr_sval->maybe_get_region ())\n+\t{\n+\t  /* Copy the data.  */\n+\t  const svalue *old_size_sval = model->get_dynamic_extents (freed_reg);\n+\t  if (old_size_sval)\n+\t    {\n+\t      const region *sized_old_reg\n+\t\t= model->m_mgr->get_sized_region (freed_reg, NULL,\n+\t\t\t\t\t\t  old_size_sval);\n+\t      const svalue *buffer_content_sval\n+\t\t= model->get_store_value (sized_old_reg, cd.get_ctxt ());\n+\t      model->set_value (new_reg, buffer_content_sval, cd.get_ctxt ());\n+\t    }\n+\n+\t  /* Free the old region, so that pointers to the old buffer become\n+\t     invalid.  */\n+\n+\t  /* If the ptr points to an underlying heap region, delete it,\n+\t     poisoning pointers.  */\n+\t  model->unbind_region_and_descendents (freed_reg, POISON_KIND_FREED);\n+\t  model->m_dynamic_extents.remove (freed_reg);\n+\t}\n+\n+      /* Update the sm-state: mark the old_ptr_sval as \"freed\",\n+\t and the new_ptr_sval as \"nonnull\".  */\n+      model->on_realloc_with_move (cd, old_ptr_sval, new_ptr_sval);\n+\n+      const svalue *zero\n+\t= model->m_mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n+      return model->add_constraint (new_ptr_sval, NE_EXPR, zero,\n+\t\t\t\t    cd.get_ctxt ());\n+    }\n+  };\n+\n+  /* Body of region_model::impl_call_realloc.  */\n+\n+  if (cd.get_ctxt ())\n+    {\n+      cd.get_ctxt ()->bifurcate (new failure (cd));\n+      cd.get_ctxt ()->bifurcate (new success_no_move (cd));\n+      cd.get_ctxt ()->bifurcate (new success_with_move (cd));\n+      cd.get_ctxt ()->terminate_path ();\n+    }\n }\n \n /* Handle the on_call_pre part of \"strcpy\" and \"__builtin_strcpy_chk\".  */"}, {"sha": "3bfc4ba53eebc70773015a983afb63599db49e71", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -1132,7 +1132,6 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t    return false;\n \t    break;\n \t  case BUILT_IN_REALLOC:\n-\t    impl_call_realloc (cd);\n \t    return false;\n \t  case BUILT_IN_STRCPY:\n \t  case BUILT_IN_STRCPY_CHK:\n@@ -1276,28 +1275,36 @@ region_model::on_call_post (const gcall *call,\n {\n   if (tree callee_fndecl = get_fndecl_for_call (call, ctxt))\n     {\n+      call_details cd (call, this, ctxt);\n       if (is_named_call_p (callee_fndecl, \"free\", call, 1))\n \t{\n-\t  call_details cd (call, this, ctxt);\n \t  impl_call_free (cd);\n \t  return;\n \t}\n       if (is_named_call_p (callee_fndecl, \"operator delete\", call, 1)\n \t  || is_named_call_p (callee_fndecl, \"operator delete\", call, 2)\n \t  || is_named_call_p (callee_fndecl, \"operator delete []\", call, 1))\n \t{\n-\t  call_details cd (call, this, ctxt);\n \t  impl_call_operator_delete (cd);\n \t  return;\n \t}\n       /* Was this fndecl referenced by\n \t __attribute__((malloc(FOO)))?  */\n       if (lookup_attribute (\"*dealloc\", DECL_ATTRIBUTES (callee_fndecl)))\n \t{\n-\t  call_details cd (call, this, ctxt);\n \t  impl_deallocation_call (cd);\n \t  return;\n \t}\n+      if (fndecl_built_in_p (callee_fndecl, BUILT_IN_NORMAL)\n+\t  && gimple_builtin_call_types_compatible_p (call, callee_fndecl))\n+\tswitch (DECL_UNCHECKED_FUNCTION_CODE (callee_fndecl))\n+\t  {\n+\t  default:\n+\t    break;\n+\t  case BUILT_IN_REALLOC:\n+\t    impl_call_realloc (cd);\n+\t    return;\n+\t  }\n     }\n \n   if (unknown_side_effects)\n@@ -3765,6 +3772,19 @@ region_model::unset_dynamic_extents (const region *reg)\n   m_dynamic_extents.remove (reg);\n }\n \n+/* class noop_region_model_context : public region_model_context.  */\n+\n+void\n+noop_region_model_context::bifurcate (custom_edge_info *info)\n+{\n+  delete info;\n+}\n+\n+void\n+noop_region_model_context::terminate_path ()\n+{\n+}\n+\n /* struct model_merger.  */\n \n /* Dump a multiline representation of this merger to PP.  */"}, {"sha": "5fabf7881e2405350576220adee0d31f7b5dd130", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -487,11 +487,15 @@ class call_details\n \n   unsigned num_args () const;\n \n+  const gcall *get_call_stmt () const { return m_call; }\n+\n   tree get_arg_tree (unsigned idx) const;\n   tree get_arg_type (unsigned idx) const;\n   const svalue *get_arg_svalue (unsigned idx) const;\n   const char *get_arg_string_literal (unsigned idx) const;\n \n+  tree get_fndecl_for_call () const;\n+\n   void dump_to_pp (pretty_printer *pp, bool simple) const;\n   void dump (bool simple) const;\n \n@@ -732,6 +736,11 @@ class region_model\n \n   const svalue *get_capacity (const region *reg) const;\n \n+  /* Implemented in sm-malloc.cc  */\n+  void on_realloc_with_move (const call_details &cd,\n+\t\t\t     const svalue *old_ptr_sval,\n+\t\t\t     const svalue *new_ptr_sval);\n+\n  private:\n   const region *get_lvalue_1 (path_var pv, region_model_context *ctxt) const;\n   const svalue *get_rvalue_1 (path_var pv, region_model_context *ctxt) const;\n@@ -867,6 +876,21 @@ class region_model_context\n \n   /* Hook for clients to purge state involving SVAL.  */\n   virtual void purge_state_involving (const svalue *sval) = 0;\n+\n+  /* Hook for clients to split state with a non-standard path.\n+     Take ownership of INFO.  */\n+  virtual void bifurcate (custom_edge_info *info) = 0;\n+\n+  /* Hook for clients to terminate the standard path.  */\n+  virtual void terminate_path () = 0;\n+\n+  virtual const extrinsic_state *get_ext_state () const = 0;\n+\n+  /* Hook for clients to access the \"malloc\" state machine in\n+     any underlying program_state.  */\n+  virtual bool get_malloc_map (sm_state_map **out_smap,\n+\t\t\t       const state_machine **out_sm,\n+\t\t\t       unsigned *out_sm_idx) = 0;\n };\n \n /* A \"do nothing\" subclass of region_model_context.  */\n@@ -899,6 +923,18 @@ class noop_region_model_context : public region_model_context\n   uncertainty_t *get_uncertainty () OVERRIDE { return NULL; }\n \n   void purge_state_involving (const svalue *sval ATTRIBUTE_UNUSED) OVERRIDE {}\n+\n+  void bifurcate (custom_edge_info *info) OVERRIDE;\n+  void terminate_path () OVERRIDE;\n+\n+  const extrinsic_state *get_ext_state () const OVERRIDE { return NULL; }\n+\n+  bool get_malloc_map (sm_state_map **,\n+\t\t       const state_machine **,\n+\t\t       unsigned *) OVERRIDE\n+  {\n+    return false;\n+  }\n };\n \n /* A subclass of region_model_context for determining if operations fail"}, {"sha": "bf5e3c365b444b57eac836d4c065d2a36bd5b646", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 106, "deletions": 30, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"analyzer/function-set.h\"\n+#include \"analyzer/program-state.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -387,6 +388,12 @@ class malloc_state_machine : public state_machine\n \n   static bool unaffected_by_call_p (tree fndecl);\n \n+  void on_realloc_with_move (region_model *model,\n+\t\t\t     sm_state_map *smap,\n+\t\t\t     const svalue *old_ptr_sval,\n+\t\t\t     const svalue *new_ptr_sval,\n+\t\t\t     const extrinsic_state &ext_state) const;\n+\n   standard_deallocator_set m_free;\n   standard_deallocator_set m_scalar_delete;\n   standard_deallocator_set m_vector_delete;\n@@ -1836,54 +1843,65 @@ malloc_state_machine::on_deallocator_call (sm_context *sm_ctxt,\n     }\n }\n \n-/* Implementation of realloc(3):\n-\n-     void *realloc(void *ptr, size_t size);\n-\n-   realloc(3) is awkward.\n+/* Handle a call to \"realloc\".\n+   Check for free of non-heap or mismatching allocators,\n+   transitioning to the \"stop\" state for such cases.\n \n-   We currently don't have a way to express multiple possible outcomes\n-   from a function call, \"bifurcating\" the state such as:\n-   - success: non-NULL is returned\n-   - failure: NULL is returned, existing buffer is not freed.\n-   or even an N-way state split e.g.:\n-   - buffer grew successfully in-place\n-   - buffer was successfully moved to a larger allocation\n-   - buffer was successfully contracted\n-   - realloc failed, returning NULL, without freeing existing buffer.\n-   (PR analyzer/99260 tracks this)\n-\n-   Given that we can currently only express one outcome, eliminate\n-   false positives by dropping state from the buffer.  */\n+   Otherwise, region_model::impl_call_realloc will later\n+   get called (which will handle other sm-state transitions\n+   when the state is bifurcated).  */\n \n void\n malloc_state_machine::on_realloc_call (sm_context *sm_ctxt,\n-\t\t\t\t       const supernode *node ATTRIBUTE_UNUSED,\n+\t\t\t\t       const supernode *node,\n \t\t\t\t       const gcall *call) const\n {\n-  tree ptr = gimple_call_arg (call, 0);\n+  const unsigned argno = 0;\n+  const deallocator *d = &m_realloc;\n+\n+  tree arg = gimple_call_arg (call, argno);\n \n-  state_t state = sm_ctxt->get_state (call, ptr);\n+  state_t state = sm_ctxt->get_state (call, arg);\n \n-  /* Detect mismatches.  */\n   if (unchecked_p (state) || nonnull_p (state))\n     {\n       const allocation_state *astate = as_a_allocation_state (state);\n       gcc_assert (astate->m_deallocators);\n-      if (astate->m_deallocators != &m_free)\n+      if (!astate->m_deallocators->contains_p (&m_free.m_deallocator))\n \t{\n \t  /* Wrong allocator.  */\n-\t  tree diag_ptr = sm_ctxt->get_diagnostic_tree (ptr);\n+\t  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \t  pending_diagnostic *pd\n-\t    = new mismatching_deallocation (*this, diag_ptr,\n+\t    = new mismatching_deallocation (*this, diag_arg,\n \t\t\t\t\t    astate->m_deallocators,\n-\t\t\t\t\t    &m_realloc);\n-\t  sm_ctxt->warn (node, call, ptr, pd);\n+\t\t\t\t\t    d);\n+\t  sm_ctxt->warn (node, call, arg, pd);\n+\t  sm_ctxt->set_next_state (call, arg, m_stop);\n+\t  if (path_context *path_ctxt = sm_ctxt->get_path_context ())\n+\t    path_ctxt->terminate_path ();\n \t}\n     }\n-\n-  /* Transition ptr to \"stop\" state.  */\n-  sm_ctxt->set_next_state (call, ptr, m_stop);\n+  else if (state == m_free.m_deallocator.m_freed)\n+    {\n+      /* freed -> stop, with warning.  */\n+      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n+      sm_ctxt->warn (node, call, arg,\n+\t\t     new double_free (*this, diag_arg, \"free\"));\n+      sm_ctxt->set_next_state (call, arg, m_stop);\n+      if (path_context *path_ctxt = sm_ctxt->get_path_context ())\n+\tpath_ctxt->terminate_path ();\n+    }\n+  else if (state == m_non_heap)\n+    {\n+      /* non-heap -> stop, with warning.  */\n+      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n+      sm_ctxt->warn (node, call, arg,\n+\t\t     new free_of_non_heap (*this, diag_arg,\n+\t\t\t\t\t   d->m_name));\n+      sm_ctxt->set_next_state (call, arg, m_stop);\n+      if (path_context *path_ctxt = sm_ctxt->get_path_context ())\n+\tpath_ctxt->terminate_path ();\n+    }\n }\n \n /* Implementation of state_machine::on_phi vfunc for malloc_state_machine.  */\n@@ -2015,6 +2033,30 @@ malloc_state_machine::on_zero_assignment (sm_context *sm_ctxt,\n     sm_ctxt->set_next_state (stmt, lhs, m_null);\n }\n \n+/* Special-case hook for handling realloc, for the \"success with move to\n+   a new buffer\" case, marking OLD_PTR_SVAL as freed and NEW_PTR_SVAL as\n+   non-null.\n+\n+   This is similar to on_deallocator_call and on_allocator_call,\n+   but the checks happen in on_realloc_call, and by splitting the states.  */\n+\n+void\n+malloc_state_machine::\n+on_realloc_with_move (region_model *model,\n+\t\t      sm_state_map *smap,\n+\t\t      const svalue *old_ptr_sval,\n+\t\t      const svalue *new_ptr_sval,\n+\t\t      const extrinsic_state &ext_state) const\n+{\n+  smap->set_state (model, old_ptr_sval,\n+\t\t   m_free.m_deallocator.m_freed,\n+\t\t   NULL, ext_state);\n+\n+  smap->set_state (model, new_ptr_sval,\n+\t\t   m_free.m_nonnull,\n+\t\t   NULL, ext_state);\n+}\n+\n } // anonymous namespace\n \n /* Internal interface to this file. */\n@@ -2025,6 +2067,40 @@ make_malloc_state_machine (logger *logger)\n   return new malloc_state_machine (logger);\n }\n \n+/* Specialcase hook for handling realloc, for use by\n+   region_model::impl_call_realloc::success_with_move::update_model.  */\n+\n+void\n+region_model::on_realloc_with_move (const call_details &cd,\n+\t\t\t\t    const svalue *old_ptr_sval,\n+\t\t\t\t    const svalue *new_ptr_sval)\n+{\n+  region_model_context *ctxt = cd.get_ctxt ();\n+  if (!ctxt)\n+    return;\n+  const extrinsic_state *ext_state = ctxt->get_ext_state ();\n+  if (!ext_state)\n+    return;\n+\n+  sm_state_map *smap;\n+  const state_machine *sm;\n+  unsigned sm_idx;\n+  if (!ctxt->get_malloc_map (&smap, &sm, &sm_idx))\n+    return;\n+\n+  gcc_assert (smap);\n+  gcc_assert (sm);\n+\n+  const malloc_state_machine &malloc_sm\n+    = (const malloc_state_machine &)*sm;\n+\n+  malloc_sm.on_realloc_with_move (this,\n+\t\t\t\t  smap,\n+\t\t\t\t  old_ptr_sval,\n+\t\t\t\t  new_ptr_sval,\n+\t\t\t\t  *ext_state);\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "e8cbe2d3f82a8711c1c72f89a18e0811a334ac67", "filename": "gcc/analyzer/sm-signal.cc", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fsm-signal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fsm-signal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-signal.cc?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -206,10 +206,10 @@ update_model_for_signal_handler (region_model *model,\n \n /* Custom exploded_edge info: entry into a signal-handler.  */\n \n-class signal_delivery_edge_info_t : public exploded_edge::custom_info_t\n+class signal_delivery_edge_info_t : public custom_edge_info\n {\n public:\n-  void print (pretty_printer *pp) FINAL OVERRIDE\n+  void print (pretty_printer *pp) const FINAL OVERRIDE\n   {\n     pp_string (pp, \"signal delivered\");\n   }\n@@ -220,15 +220,18 @@ class signal_delivery_edge_info_t : public exploded_edge::custom_info_t\n     return custom_obj;\n   }\n \n-  void update_model (region_model *model,\n-\t\t     const exploded_edge &eedge) FINAL OVERRIDE\n+  bool update_model (region_model *model,\n+\t\t     const exploded_edge *eedge,\n+\t\t     region_model_context *) const FINAL OVERRIDE\n   {\n-    update_model_for_signal_handler (model, eedge.m_dest->get_function ());\n+    gcc_assert (eedge);\n+    update_model_for_signal_handler (model, eedge->m_dest->get_function ());\n+    return true;\n   }\n \n   void add_events_to_path (checker_path *emission_path,\n \t\t\t   const exploded_edge &eedge ATTRIBUTE_UNUSED)\n-    FINAL OVERRIDE\n+    const FINAL OVERRIDE\n   {\n     emission_path->add_event\n       (new precanned_custom_event"}, {"sha": "02faffbff99f6ed6460f466108b7e0d009000f0c", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -257,6 +257,11 @@ class sm_context\n      Otherwise return NULL_TREE.  */\n   virtual tree is_zero_assignment (const gimple *stmt) = 0;\n \n+  virtual path_context *get_path_context () const\n+  {\n+    return NULL;\n+  }\n+\n protected:\n   sm_context (int sm_idx, const state_machine &sm)\n   : m_sm_idx (sm_idx), m_sm (sm) {}"}, {"sha": "5f2fe4c644922e3c4858fa3d8eff61044c800dd0", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -105,7 +105,8 @@ svalue::to_json () const\n tree\n svalue::maybe_get_constant () const\n {\n-  if (const constant_svalue *cst_sval = dyn_cast_constant_svalue ())\n+  const svalue *sval = unwrap_any_unmergeable ();\n+  if (const constant_svalue *cst_sval = sval->dyn_cast_constant_svalue ())\n     return cst_sval->get_constant ();\n   else\n     return NULL_TREE;"}, {"sha": "2db1b3fa200a1cb1d024b3da9d55fcf39e5a79e8", "filename": "gcc/testsuite/gcc.dg/analyzer/capacity-2.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcapacity-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcapacity-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcapacity-2.c?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -8,7 +8,8 @@ void *\n test_realloc_1 (void *p, size_t new_sz)\n {\n   void *q = realloc (p, new_sz);\n-  __analyzer_dump_capacity (q); /* { dg-warning \"capacity: 'UNKNOWN\\\\(sizetype\\\\)'\" } */\n+  __analyzer_dump_capacity (q); /* { dg-warning \"capacity: 'UNKNOWN\\\\(sizetype\\\\)'\" \"failure\" } */\n+  /* { dg-warning \"capacity: 'INIT_VAL\\\\(new_sz\\[^\\n\\r\\]*\\\\)'\" \"success\" { target *-*-* } .-1 } */\n   return q;\n }\n \n@@ -18,8 +19,9 @@ test_realloc_2 (size_t sz_a, size_t sz_b)\n   void *p = malloc (sz_a);\n   __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'INIT_VAL\\\\(sz_a_\\[^\\n\\r\\]*\\\\)'\" } */\n   void *q = realloc (p, sz_b);\n-  __analyzer_dump_capacity (q); /* { dg-warning \"capacity: 'UNKNOWN\\\\(sizetype\\\\)'\" } */\n-  return p;  \n+  __analyzer_dump_capacity (q); /* { dg-warning \"capacity: 'UNKNOWN\\\\(sizetype\\\\)'\" \"failure\" } */\n+  /* { dg-warning \"capacity: 'INIT_VAL\\\\(sz_b\\[^\\n\\r\\]*\\\\)'\" \"success\" { target *-*-* } .-1 } */\n+  return q; /* { dg-warning \"leak of 'p'\" } */\n }\n \n void *"}, {"sha": "459357cf13813e987e728c60f9f0c6cbab72d3bf", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99193-1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-1.c?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -1,3 +1,5 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n /* Verify absence of false positive from -Wanalyzer-mismatching-deallocation\n    on realloc(3).\n    Based on https://github.com/libguestfs/libguestfs/blob/f19fd566f6387ce7e4d82409528c9dde374d25e0/daemon/command.c#L115"}, {"sha": "d64b0458e9eb6ac13baf58ea73a5ba06b25c5175", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99193-3.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99193-3.c?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -1,3 +1,5 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n /* Verify absence of false positive from -Wanalyzer-mismatching-deallocation\n    on realloc(3).\n    Based on https://github.com/libguestfs/libguestfs/blob/f19fd566f6387ce7e4d82409528c9dde374d25e0/daemon/debug.c#L115"}, {"sha": "606a19abe779d1ff54080cfdddc1f57873ce6495", "filename": "gcc/testsuite/gcc.dg/analyzer/realloc-1.c", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-1.c?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -1,3 +1,5 @@\n+/* { dg-additional-options \"-Wno-free-nonheap-object\" } */\n+\n typedef __SIZE_TYPE__ size_t;\n \n #define NULL ((void *)0)\n@@ -20,11 +22,10 @@ void *test_1 (void *ptr)\n \n void *test_2 (void *ptr)\n {\n-  void *p = malloc (1024);\n-  p = realloc (p, 4096);\n-  /* TODO: should warn about the leak when the above call fails (PR analyzer/99260).  */\n+  void *p = malloc (1024); /* { dg-message \"allocated here\" } */\n+  p = realloc (p, 4096); /* { dg-message \"when 'realloc' fails\" } */\n   free (p);\n-}\n+} /* { dg-warning \"leak of 'p'\" } */ // ideally this would be on the realloc stmt\n \n void *test_3 (void *ptr)\n {\n@@ -44,12 +45,46 @@ void *test_4 (void)\n int *test_5 (int *p)\n {\n   *p = 42;\n-  int *q = realloc (p, sizeof(int) * 4);\n-  *q = 43; /* { dg-warning \"possibly-NULL 'q'\" \"PR analyzer/99260\" { xfail *-*-* } } */\n+  int *q = realloc (p, sizeof(int) * 4); /* { dg-message \"when 'realloc' fails\" } */\n+  *q = 43; /* { dg-warning \"dereference of NULL 'q'\" } */\n   return q;\n }\n \n void test_6 (size_t sz)\n {\n   void *p = realloc (NULL, sz);\n } /* { dg-warning \"leak of 'p'\" } */\n+\n+/* The analyzer should complain about realloc of non-heap.  */\n+\n+void *test_7 (size_t sz)\n+{\n+  char buf[100];\n+  void *p = realloc (&buf, sz); /* { dg-warning \"'realloc' of '&buf' which points to memory not on the heap\" } */\n+  return p;  \n+}\n+\n+/* Mismatched allocator.  */\n+\n+struct foo\n+{\n+  int m_int;\n+};\n+\n+extern void foo_release (struct foo *);\n+extern struct foo *foo_acquire (void)\n+  __attribute__ ((malloc (foo_release)));\n+\n+void test_8 (void)\n+{\n+  struct foo *p = foo_acquire ();\n+  void *q = realloc (p, 1024); /* { dg-warning \"'p' should have been deallocated with 'foo_release' but was deallocated with 'realloc'\" } */\n+}\n+\n+/* We should complain about realloc on a freed pointer.  */\n+\n+void test_9 (void *p)\n+{\n+  free (p);\n+  void *q = realloc (p, 1024); /* { dg-warning \"double-'free' of 'p'\" } */\n+}"}, {"sha": "a39775354a33b1b91b4ea1a2225045d5ddccc8b3", "filename": "gcc/testsuite/gcc.dg/analyzer/realloc-2.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa9d969237fd8f712c4b25a8c58932c01f44b4/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-2.c?ref=eafa9d969237fd8f712c4b25a8c58932c01f44b4", "patch": "@@ -0,0 +1,80 @@\n+#include \"analyzer-decls.h\"\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define NULL ((void *)0)\n+\n+extern void *malloc (size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__malloc__))\n+  __attribute__ ((__alloc_size__ (1)));\n+extern void *realloc (void *__ptr, size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__warn_unused_result__))\n+  __attribute__ ((__alloc_size__ (2)));\n+extern void free (void *__ptr)\n+  __attribute__ ((__nothrow__ , __leaf__));\n+\n+char *test_8 (size_t sz)\n+{\n+  char *p, *q;\n+\n+  p = malloc (3);\n+  if (!p)\n+    return NULL;\n+\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: '\\\\(size_t\\\\)3'\" } */\n+\n+  p[0] = 'a';\n+  p[1] = 'b';\n+  p[2] = 'c';\n+\n+  __analyzer_eval (p[0] == 'a'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p[1] == 'b'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p[2] == 'c'); /* { dg-warning \"TRUE\" } */\n+\n+  q = realloc (p, 6);\n+\n+  /* We should have 3 nodes, corresponding to \"failure\",\n+     \"success without moving\", and \"success with moving\".  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n+  \n+  if (q)\n+    {\n+      __analyzer_dump_capacity (q); /* { dg-warning \"capacity: '\\\\(size_t\\\\)6'\" } */\n+      q[3] = 'd';\n+      q[4] = 'e';\n+      q[5] = 'f';\n+      if (q == p)\n+\t{\n+\t  /* \"realloc\" success, growing the buffer in-place.  */\n+\t  __analyzer_eval (p[0] == 'a'); /* { dg-warning \"TRUE\" } */\n+\t  __analyzer_eval (p[1] == 'b'); /* { dg-warning \"TRUE\" } */\n+\t  __analyzer_eval (p[2] == 'c'); /* { dg-warning \"TRUE\" } */\n+\t  // TODO\n+\t}\n+      else\n+\t{\n+\t  /* \"realloc\" success, moving the buffer (and thus freeing \"p\").  */\n+\t  __analyzer_eval (q[0] == 'a'); /* { dg-warning \"TRUE\" } */\n+\t  __analyzer_eval (q[1] == 'b'); /* { dg-warning \"TRUE\" } */\n+\t  __analyzer_eval (q[2] == 'c'); /* { dg-warning \"TRUE\" } */\n+\t  __analyzer_eval (p[0] == 'a'); /* { dg-warning \"UNKNOWN\" \"unknown\" } */\n+\t  /* { dg-warning \"use after 'free' of 'p'\" \"use after free\" { target *-*-* } .-1 } */\n+\t}\n+      __analyzer_eval (q[3] == 'd'); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (q[4] == 'e'); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (q[5] == 'f'); /* { dg-warning \"TRUE\" } */\n+    }\n+  else\n+    {\n+      /* \"realloc\" failure.  p should be unchanged.  */\n+      __analyzer_dump_capacity (p); /* { dg-warning \"capacity: '\\\\(size_t\\\\)3'\" } */\n+      __analyzer_eval (p[0] == 'a'); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (p[1] == 'b'); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (p[2] == 'c'); /* { dg-warning \"TRUE\" } */\n+      return p;\n+    }\n+\n+  return q;\n+}"}]}