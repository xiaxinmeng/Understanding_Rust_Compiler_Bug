{"sha": "013cc86f9abb27c545e61c6a3e872ca147040be7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEzY2M4NmY5YWJiMjdjNTQ1ZTYxYzZhM2U4NzJjYTE0NzA0MGJlNw==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-03-21T19:27:00Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-03-21T19:27:00Z"}, "message": "re PR tree-optimization/20542 (Bootstrap failure at -Os)\n\n2005-03-18  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/20542\n\n\t* tree-flow-inline.h (overlap_subvar): Move to here.\n\t* tree-ssa-operands.c: From here.\n\t* tree-flow.h (overlap_subvar): Declare.\n\t* tree-ssa-alias.c (add_pointed_to_var): Use overlap_subvar here.\n\t* tree-ssa-loop-im.c (is_call_clobbered_ref): Return proper answer\n\tfor variables with subvars.\n\nFrom-SVN: r96829", "tree": {"sha": "fa074c6a524b35099d5e619373b0066febd064c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa074c6a524b35099d5e619373b0066febd064c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/013cc86f9abb27c545e61c6a3e872ca147040be7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/013cc86f9abb27c545e61c6a3e872ca147040be7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/013cc86f9abb27c545e61c6a3e872ca147040be7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/013cc86f9abb27c545e61c6a3e872ca147040be7/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d331e204024e2a74124880dd0dee8f4952fc9b26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d331e204024e2a74124880dd0dee8f4952fc9b26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d331e204024e2a74124880dd0dee8f4952fc9b26"}], "stats": {"total": 136, "additions": 86, "deletions": 50}, "files": [{"sha": "571faaeda0f564d0abb85f72b9c8e1b34bb9461e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013cc86f9abb27c545e61c6a3e872ca147040be7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013cc86f9abb27c545e61c6a3e872ca147040be7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=013cc86f9abb27c545e61c6a3e872ca147040be7", "patch": "@@ -1,3 +1,14 @@\n+2005-03-18  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\tFix PR tree-optimization/20542\n+\n+\t* tree-flow-inline.h (overlap_subvar): Move to here.\n+\t* tree-ssa-operands.c: From here.\n+\t* tree-flow.h (overlap_subvar): Declare.\n+\t* tree-ssa-alias.c (add_pointed_to_var): Use overlap_subvar here.\n+\t* tree-ssa-loop-im.c (is_call_clobbered_ref): Return proper answer\n+\tfor variables with subvars.\n+\t\n 2005-03-21 Mostafa Hagog <mustafa@il.ibm.com>\n \n \tPR middle-end/20177"}, {"sha": "4d6f5cb148524ee77440535661ade848dcff699b", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013cc86f9abb27c545e61c6a3e872ca147040be7/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013cc86f9abb27c545e61c6a3e872ca147040be7/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=013cc86f9abb27c545e61c6a3e872ca147040be7", "patch": "@@ -933,5 +933,48 @@ var_can_have_subvars (tree v)\n }\n \n   \n+/* Return true if OFFSET and SIZE define a range that overlaps with some\n+   portion of the range of SV, a subvar.  If there was an exact overlap,\n+   *EXACT will be set to true upon return. */\n+\n+static inline bool\n+overlap_subvar (HOST_WIDE_INT offset, HOST_WIDE_INT size,\n+\t\tsubvar_t sv,  bool *exact)\n+{\n+  /* There are three possible cases of overlap.\n+     1. We can have an exact overlap, like so:   \n+     |offset, offset + size             |\n+     |sv->offset, sv->offset + sv->size |\n+     \n+     2. We can have offset starting after sv->offset, like so:\n+     \n+           |offset, offset + size              |\n+     |sv->offset, sv->offset + sv->size  |\n+\n+     3. We can have offset starting before sv->offset, like so:\n+     \n+     |offset, offset + size    |\n+       |sv->offset, sv->offset + sv->size|\n+  */\n+\n+  if (exact)\n+    *exact = false;\n+  if (offset == sv->offset && size == sv->size)\n+    {\n+      if (exact)\n+\t*exact = true;\n+      return true;\n+    }\n+  else if (offset >= sv->offset && offset < (sv->offset + sv->size))\n+    {\n+      return true;\n+    }\n+  else if (offset < sv->offset && (offset + size > sv->offset))\n+    {\n+      return true;\n+    }\n+  return false;\n+\n+}\n \n #endif /* _TREE_FLOW_INLINE_H  */"}, {"sha": "abca6593ba35cdd0958cc05f0fe1e6f8b2b9c63f", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013cc86f9abb27c545e61c6a3e872ca147040be7/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013cc86f9abb27c545e61c6a3e872ca147040be7/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=013cc86f9abb27c545e61c6a3e872ca147040be7", "patch": "@@ -596,6 +596,9 @@ static inline bool ref_contains_array_ref (tree);\n extern tree okay_component_ref_for_subvars (tree, HOST_WIDE_INT *,\n \t\t\t\t\t    HOST_WIDE_INT *);\n static inline bool var_can_have_subvars (tree);\n+static inline bool overlap_subvar (HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t   subvar_t, bool *);\n+\n /* Call-back function for walk_use_def_chains().  At each reaching\n    definition, a function with this prototype is called.  */\n typedef bool (*walk_use_def_chains_fn) (tree, tree, void *);"}, {"sha": "12a432b79a3c2aa120c4b7f6854b32eb93cbd6a9", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013cc86f9abb27c545e61c6a3e872ca147040be7/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013cc86f9abb27c545e61c6a3e872ca147040be7/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=013cc86f9abb27c545e61c6a3e872ca147040be7", "patch": "@@ -1992,12 +1992,7 @@ add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n \n       for (sv = svars; sv; sv = sv->next)\n \t{\n-\t  if (offset == sv->offset && size == sv->size)\n-\t    bitmap_set_bit (pi->pt_vars, var_ann (sv->var)->uid);\n-\t  else if (offset >= sv->offset && offset < (sv->offset + sv->size))\n-\t    bitmap_set_bit (pi->pt_vars, var_ann (sv->var)->uid);\n-\t  else if (offset < sv->offset \n-\t\t   && (offset + size > sv->offset))\n+\t  if (overlap_subvar (offset, size, sv, NULL))\n \t    bitmap_set_bit (pi->pt_vars, var_ann (sv->var)->uid);\n \t}\n     }"}, {"sha": "51ada3d8056b7cde2db36665e2e3fe6e48633029", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013cc86f9abb27c545e61c6a3e872ca147040be7/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013cc86f9abb27c545e61c6a3e872ca147040be7/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=013cc86f9abb27c545e61c6a3e872ca147040be7", "patch": "@@ -1146,13 +1146,40 @@ static bool\n is_call_clobbered_ref (tree ref)\n {\n   tree base;\n+  HOST_WIDE_INT offset, size;\n+  subvar_t sv;\n+  subvar_t svars;\n+  tree sref = ref;\n \n+  if (TREE_CODE (sref) == COMPONENT_REF\n+      && (sref = okay_component_ref_for_subvars (sref, &offset, &size)))\n+    {\n+      svars = get_subvars_for_var (sref);\n+      for (sv = svars; sv; sv = sv->next)\n+\t{\n+\t  if (overlap_subvar (offset, size, sv, NULL)\n+\t      && is_call_clobbered (sv->var))\n+\t    return true;\n+\t}\n+    }\n+\t      \n   base = get_base_address (ref);\n   if (!base)\n     return true;\n \n   if (DECL_P (base))\n-    return is_call_clobbered (base);\n+    {\n+      if (var_can_have_subvars (base)\n+\t  && (svars = get_subvars_for_var (base)))\n+\t{\n+\t  for (sv = svars; sv; sv = sv->next)\n+\t    if (is_call_clobbered (sv->var))\n+\t      return true;\n+\t  return false;\n+\t}\n+      else\n+\treturn is_call_clobbered (base);\n+    }\n \n   if (INDIRECT_REF_P (base))\n     {"}, {"sha": "1ef06db602f1851f66b5b4803a29e35f083228d9", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013cc86f9abb27c545e61c6a3e872ca147040be7/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013cc86f9abb27c545e61c6a3e872ca147040be7/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=013cc86f9abb27c545e61c6a3e872ca147040be7", "patch": "@@ -1024,49 +1024,6 @@ get_stmt_operands (tree stmt)\n }\n \n \n-/* Return true if OFFSET and SIZE define a range that overlaps with some\n-   portion of the range of SV, a subvar.  If there was an exact overlap,\n-   *EXACT will be set to true upon return. */\n-\n-static bool\n-overlap_subvar (HOST_WIDE_INT offset, HOST_WIDE_INT size,\n-\t\tsubvar_t sv,  bool *exact)\n-{\n-  /* There are three possible cases of overlap.\n-     1. We can have an exact overlap, like so:   \n-     |offset, offset + size             |\n-     |sv->offset, sv->offset + sv->size |\n-     \n-     2. We can have offset starting after sv->offset, like so:\n-     \n-           |offset, offset + size              |\n-     |sv->offset, sv->offset + sv->size  |\n-\n-     3. We can have offset starting before sv->offset, like so:\n-     \n-     |offset, offset + size    |\n-       |sv->offset, sv->offset + sv->size|\n-  */\n-\n-  if (exact)\n-    *exact = false;\n-  if (offset == sv->offset && size == sv->size)\n-    {\n-      if (exact)\n-\t*exact = true;\n-      return true;\n-    }\n-  else if (offset >= sv->offset && offset < (sv->offset + sv->size))\n-    {\n-      return true;\n-    }\n-  else if (offset < sv->offset && (offset + size > sv->offset))\n-    {\n-      return true;\n-    }\n-  return false;\n-\n-}\n /* Recursively scan the expression pointed by EXPR_P in statement referred to\n    by INFO.  FLAGS is one of the OPF_* constants modifying how to interpret the\n    operands found.  */"}]}