{"sha": "7ce67fbe42c85071c99837def6395f131cfdcc61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NlNjdmYmU0MmM4NTA3MWM5OTgzN2RlZjYzOTVmMTMxY2ZkY2M2MQ==", "commit": {"author": {"name": "Devang Patel", "email": "dpatel@apple.com", "date": "2004-09-28T00:13:12Z"}, "committer": {"name": "Devang Patel", "email": "dpatel@gcc.gnu.org", "date": "2004-09-28T00:13:12Z"}, "message": "expr.c (expand_expr_real_1): Handle VEC_COND_EXPR.\n\n        * expr.c (expand_expr_real_1): Handle VEC_COND_EXPR.\n        * genopinit.c (optabs): New entry for vcond_gen_code and\n        vcondu_gen_code.\n        * optabs.c (vcond_gen_code, vcondu_gen_code): New optabs.\n        (get_rtx_code): New function.\n        (vector_compare_rtx): New function.\n        (init_optabs): Initialize vcond_gen_code and vcondu_gen_code.\n        (expand_vec_cond_expr_p): New function.\n        (expand_vec_cond_expr): New function.\n        (get_vcond_icode): New function.\n        * optabs.h (expand_vec_cond_expr, expand_vec_cond_expr_p): New externs.\n        (vcond_gen_code, vcondu_gen_code): Same.\n\nFrom-SVN: r88209", "tree": {"sha": "d499fabff1893bbf2a9b76b6065afdd79d7c845b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d499fabff1893bbf2a9b76b6065afdd79d7c845b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ce67fbe42c85071c99837def6395f131cfdcc61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ce67fbe42c85071c99837def6395f131cfdcc61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ce67fbe42c85071c99837def6395f131cfdcc61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ce67fbe42c85071c99837def6395f131cfdcc61/comments", "author": null, "committer": null, "parents": [{"sha": "55040e7a24ca7a4d07644ab93976fb8f3a6d1b1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55040e7a24ca7a4d07644ab93976fb8f3a6d1b1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55040e7a24ca7a4d07644ab93976fb8f3a6d1b1c"}], "stats": {"total": 215, "additions": 212, "deletions": 3}, "files": [{"sha": "f392069de66b252e602c64f8c9964fb8ac63bec0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ce67fbe42c85071c99837def6395f131cfdcc61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ce67fbe42c85071c99837def6395f131cfdcc61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ce67fbe42c85071c99837def6395f131cfdcc61", "patch": "@@ -1,3 +1,18 @@\n+2004-09-27  Devang Patel  <dpatel@apple.com>\n+\n+\t* expr.c (expand_expr_real_1): Handle VEC_COND_EXPR.\n+\t* genopinit.c (optabs): New entry for vcond_gen_code and\n+\tvcondu_gen_code.\n+\t* optabs.c (vcond_gen_code, vcondu_gen_code): New optabs.\n+\t(get_rtx_code): New function.\n+\t(vector_compare_rtx): New function.\n+\t(init_optabs): Initialize vcond_gen_code and vcondu_gen_code.\n+\t(expand_vec_cond_expr_p): New function.\n+\t(expand_vec_cond_expr): New function.\n+\t(get_vcond_icode): New function.\n+\t* optabs.h (expand_vec_cond_expr, expand_vec_cond_expr_p): New externs.\n+\t(vcond_gen_code, vcondu_gen_code): Same.\n+\n 2004-09-27  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* Makefile.in (STAGESTUFF): Split into ...\n@@ -45,7 +60,6 @@\n \n \t* tree-pretty-print.c (dump_generic_node): Print VEC_COND_EXPR.\n \t(print_call_name): Do not print VEC_COND_EXPR.\n-\t\n \n 2004-09-27  Devang Patel  <dpatel@apple.com>\n "}, {"sha": "ff8355bc7380528b3c81567f7c694aafea9f0b3d", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ce67fbe42c85071c99837def6395f131cfdcc61/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ce67fbe42c85071c99837def6395f131cfdcc61/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7ce67fbe42c85071c99837def6395f131cfdcc61", "patch": "@@ -8053,6 +8053,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n        OK_DEFER_POP;\n        return temp;\n \n+    case VEC_COND_EXPR:\n+\ttarget = expand_vec_cond_expr (exp, target);\n+\treturn target;\n+\n     case MODIFY_EXPR:\n       {\n \t/* If lhs is complex, expand calls in rhs before computing it."}, {"sha": "8c6c8feb2928573e51b0c4ac66d6eae6b4bda80b", "filename": "gcc/genopinit.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ce67fbe42c85071c99837def6395f131cfdcc61/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ce67fbe42c85071c99837def6395f131cfdcc61/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=7ce67fbe42c85071c99837def6395f131cfdcc61", "patch": "@@ -171,7 +171,9 @@ static const char * const optabs[] =\n   \"vec_extract_optab->handlers[$A].insn_code = CODE_FOR_$(vec_extract$a$)\",\n   \"vec_init_optab->handlers[$A].insn_code = CODE_FOR_$(vec_init$a$)\",\n   \"vec_realign_store_optab->handlers[$A].insn_code = CODE_FOR_$(vec_realign_store_$a$)\",\n-  \"vec_realign_load_optab->handlers[$A].insn_code = CODE_FOR_$(vec_realign_load_$a$)\" };\n+  \"vec_realign_load_optab->handlers[$A].insn_code = CODE_FOR_$(vec_realign_load_$a$)\",\n+  \"vcond_gen_code[$A] = CODE_FOR_$(vcond$a$)\",\n+  \"vcondu_gen_code[$A] = CODE_FOR_$(vcondu$a$)\" };\n \n static void gen_insn (rtx);\n "}, {"sha": "8354f7878fc63c07c6ee362cd2e0726eb19c03de", "filename": "gcc/optabs.c", "status": "modified", "additions": 178, "deletions": 1, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ce67fbe42c85071c99837def6395f131cfdcc61/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ce67fbe42c85071c99837def6395f131cfdcc61/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=7ce67fbe42c85071c99837def6395f131cfdcc61", "patch": "@@ -84,6 +84,12 @@ enum insn_code setcc_gen_code[NUM_RTX_CODE];\n enum insn_code movcc_gen_code[NUM_MACHINE_MODES];\n #endif\n \n+/* Indexed by the machine mode, gives the insn code for vector conditional\n+   operation.  */\n+\n+enum insn_code vcond_gen_code[NUM_MACHINE_MODES];\n+enum insn_code vcondu_gen_code[NUM_MACHINE_MODES];\n+\n /* The insn generating function can not take an rtx_code argument.\n    TRAP_RTX is used as an rtx argument.  Its code is replaced with\n    the code to be used in the trap insn and all other fields are ignored.  */\n@@ -116,6 +122,8 @@ static void prepare_float_lib_cmp (rtx *, rtx *, enum rtx_code *,\n \t\t\t\t   enum machine_mode *, int *);\n static rtx widen_clz (enum machine_mode, rtx, rtx);\n static rtx expand_parity (enum machine_mode, rtx, rtx);\n+static enum rtx_code get_rtx_code (enum tree_code, bool);\n+static rtx vector_compare_rtx (tree, bool, enum insn_code);\n \n #ifndef HAVE_conditional_trap\n #define HAVE_conditional_trap 0\n@@ -2982,7 +2990,6 @@ can_compare_p (enum rtx_code code, enum machine_mode mode,\n       if (purpose == ccp_store_flag\n \t  && cstore_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \treturn 1;\n-\n       mode = GET_MODE_WIDER_MODE (mode);\n     }\n   while (mode != VOIDmode);\n@@ -4649,6 +4656,12 @@ init_optabs (void)\n     movcc_gen_code[i] = CODE_FOR_nothing;\n #endif\n \n+  for (i = 0; i < NUM_MACHINE_MODES; i++)\n+    {\n+      vcond_gen_code[i] = CODE_FOR_nothing;\n+      vcondu_gen_code[i] = CODE_FOR_nothing;\n+    }\n+\n   add_optab = init_optab (PLUS);\n   addv_optab = init_optabv (PLUS);\n   sub_optab = init_optab (MINUS);\n@@ -4992,4 +5005,168 @@ gen_cond_trap (enum rtx_code code ATTRIBUTE_UNUSED, rtx op1,\n   return insn;\n }\n \n+/* Return rtx code for TCODE. Use UNSIGNEDP to select signed\n+   or unsigned operation code.  */\n+\n+static enum rtx_code\n+get_rtx_code (enum tree_code tcode, bool unsignedp)\n+{\n+  enum rtx_code code;\n+  switch (tcode)\n+    {\n+    case EQ_EXPR:\n+      code = EQ;\n+      break;\n+    case NE_EXPR:\n+      code = NE;\n+      break;\n+    case LT_EXPR:\n+      code = unsignedp ? LTU : LT;\n+      break;\n+    case LE_EXPR:\n+      code = unsignedp ? LEU : LE;\n+      break;\n+    case GT_EXPR:\n+      code = unsignedp ? GTU : GT;\n+      break;\n+    case GE_EXPR:\n+      code = unsignedp ? GEU : GE;\n+      break;\n+      \n+    case UNORDERED_EXPR:\n+      code = UNORDERED;\n+      break;\n+    case ORDERED_EXPR:\n+      code = ORDERED;\n+      break;\n+    case UNLT_EXPR:\n+      code = UNLT;\n+      break;\n+    case UNLE_EXPR:\n+      code = UNLE;\n+      break;\n+    case UNGT_EXPR:\n+      code = UNGT;\n+      break;\n+    case UNGE_EXPR:\n+      code = UNGE;\n+      break;\n+    case UNEQ_EXPR:\n+      code = UNEQ;\n+      break;\n+    case LTGT_EXPR:\n+      code = LTGT;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+  return code;\n+}\n+\n+/* Return comparison rtx for COND. Use UNSIGNEDP to select signed or\n+   unsigned operators. Do not generate compare instruction.  */\n+\n+static rtx\n+vector_compare_rtx (tree cond, bool unsignedp, enum insn_code icode)\n+{\n+  enum rtx_code rcode;\n+  tree t_op0, t_op1;\n+  rtx rtx_op0, rtx_op1;\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (cond)) != '<')\n+    {\n+      /* This is unlikely. While generating VEC_COND_EXPR,\n+\t auto vectorizer ensures that condition is a relational\n+\t operation.  */\n+      abort ();\n+    }\n+  else\n+    {\n+      rcode = get_rtx_code (TREE_CODE (cond), unsignedp); \n+      t_op0 = TREE_OPERAND (cond, 0);\n+      t_op1 = TREE_OPERAND (cond, 1);\n+    }\n+\n+  /* Expand operands.  */\n+  rtx_op0 = expand_expr (t_op0, NULL_RTX, TYPE_MODE (TREE_TYPE (t_op0)), 1);\n+  rtx_op1 = expand_expr (t_op1, NULL_RTX, TYPE_MODE (TREE_TYPE (t_op1)), 1);\n+\n+  if (!(*insn_data[icode].operand[4].predicate) (rtx_op0, GET_MODE (rtx_op0))\n+      && GET_MODE (rtx_op0) != VOIDmode)\n+    rtx_op0 = force_reg (GET_MODE (rtx_op0), rtx_op0);\n+  \n+  if (!(*insn_data[icode].operand[5].predicate) (rtx_op1, GET_MODE (rtx_op1))\n+      && GET_MODE (rtx_op1) != VOIDmode)\n+    rtx_op1 = force_reg (GET_MODE (rtx_op1), rtx_op1);\n+\n+  return gen_rtx_fmt_ee (rcode, VOIDmode, rtx_op0, rtx_op1);\n+}\n+\n+/* Return insn code for VEC_COND_EXPR EXPR.  */\n+  \n+static inline enum insn_code \n+get_vcond_icode (tree expr, enum machine_mode mode)\n+{\n+  enum insn_code icode = CODE_FOR_nothing;\n+\n+  if (TYPE_UNSIGNED (TREE_TYPE (expr)))\n+    icode = vcondu_gen_code[mode];\n+  else\n+    icode = vcond_gen_code[mode];\n+  return icode;\n+}\n+\n+/* Return TRUE iff, appropriate vector insns are available\n+   for vector cond expr expr in VMODE mode.  */\n+\n+bool\n+expand_vec_cond_expr_p (tree expr, enum machine_mode vmode)\n+{\n+  if (get_vcond_icode (expr, vmode) == CODE_FOR_nothing)\n+    return false;\n+  return true;\n+}\n+\n+/* Generate insns for VEC_COND_EXPR.  */\n+\n+rtx\n+expand_vec_cond_expr (tree vec_cond_expr, rtx target)\n+{\n+  enum insn_code icode;\n+  rtx comparison, rtx_op1, rtx_op2, cc_op0, cc_op1;\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (vec_cond_expr));\n+  bool unsignedp = TYPE_UNSIGNED (TREE_TYPE (vec_cond_expr));\n+\n+  icode = get_vcond_icode (vec_cond_expr, mode);\n+  if (icode == CODE_FOR_nothing)\n+    return 0;\n+\n+  if (!target)\n+    target = gen_reg_rtx (mode);\n+\n+  /* Get comparision rtx. First expand both cond expr operands.  */\n+  comparison = vector_compare_rtx (TREE_OPERAND (vec_cond_expr, 0), \n+\t\t\t\t   unsignedp, icode);\n+  cc_op0 = XEXP (comparison, 0);\n+  cc_op1 = XEXP (comparison, 1);\n+  /* Expand both operands and force them in reg, if required.  */\n+  rtx_op1 = expand_expr (TREE_OPERAND (vec_cond_expr, 1),\n+\t\t\t NULL_RTX, VOIDmode, 1);\n+  if (!(*insn_data[icode].operand[1].predicate) (rtx_op1, mode)\n+      && mode != VOIDmode)\n+    rtx_op1 = force_reg (mode, rtx_op1);\n+\n+  rtx_op2 = expand_expr (TREE_OPERAND (vec_cond_expr, 2),\n+\t\t\t NULL_RTX, VOIDmode, 1);\n+  if (!(*insn_data[icode].operand[2].predicate) (rtx_op2, mode)\n+      && mode != VOIDmode)\n+    rtx_op2 = force_reg (mode, rtx_op2);\n+\n+  /* Emit instruction! */\n+  emit_insn (GEN_FCN (icode) (target, rtx_op1, rtx_op2, \n+\t\t\t      comparison, cc_op0,  cc_op1));\n+\n+  return target;\n+}\n #include \"gt-optabs.h\""}, {"sha": "68be8d35e7ffbbdd318f2c452d2a74e839e16b3b", "filename": "gcc/optabs.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ce67fbe42c85071c99837def6395f131cfdcc61/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ce67fbe42c85071c99837def6395f131cfdcc61/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=7ce67fbe42c85071c99837def6395f131cfdcc61", "patch": "@@ -398,6 +398,12 @@ extern enum insn_code setcc_gen_code[NUM_RTX_CODE];\n extern enum insn_code movcc_gen_code[NUM_MACHINE_MODES];\n #endif\n \n+/* Indexed by the machine mode, gives the insn code for vector conditional\n+   operation.  */\n+\n+extern enum insn_code vcond_gen_code[NUM_MACHINE_MODES];\n+extern enum insn_code vcondu_gen_code[NUM_MACHINE_MODES];\n+\n /* This array records the insn_code of insns to perform block moves.  */\n extern enum insn_code movmem_optab[NUM_MACHINE_MODES];\n \n@@ -498,4 +504,10 @@ extern void expand_float (rtx, rtx, int);\n /* Generate code for a FIX_EXPR.  */\n extern void expand_fix (rtx, rtx, int);\n \n+/* Return tree if target supports vector operatiosn for COND_EXPR.  */\n+bool expand_vec_cond_expr_p (tree, enum machine_mode);\n+\n+/* Generate code for VEC_COND_EXPR.  */\n+extern rtx expand_vec_cond_expr (tree, rtx);\n+\n #endif /* GCC_OPTABS_H */"}]}