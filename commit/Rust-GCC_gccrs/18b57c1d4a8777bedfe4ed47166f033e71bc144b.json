{"sha": "18b57c1d4a8777bedfe4ed47166f033e71bc144b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThiNTdjMWQ0YTg3NzdiZWRmZTRlZDQ3MTY2ZjAzM2U3MWJjMTQ0Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-09-17T18:18:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-09-18T02:43:00Z"}, "message": "c++: improve lookup of member-qualified names\n\nI've been working on the resolution of CWG1835 by P1787, which among many\nother things clarified that a name after -> or . is looked up first in the\nclass of the object expression even if it's dependent.  This patch does not\nmake that change; this is a smaller change extracted from that work in\nprogress to make the lookup in the object type work better in cases where\nunqualified lookup doesn't find anything.\n\nBasically, if we see \"t.foo::\" we know that looking up foo in t needs to\nfind a type, so we build an implicit TYPENAME_TYPE for it.\n\nThis also implements the change from P1787 to assume that a name followed by\n< in a type-only context names a template, since the less-than operator\ncan't appear in a type context.  This makes some of the lines in dtor11.C\nwork.\n\nI introduce the predicate 'dependentish_scope_p' for the case where the\ncurrent instantiation has dependent bases, so even though we can perform\nname lookup, we can't conclude that a lookup failure is conclusive.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (dependentish_scope_p): Declare.\n\t* pt.c (dependentish_scope_p): New.\n\t* parser.c (cp_parser_lookup_name): Return a TYPENAME_TYPE\n\tfor lookup of a type in a dependent object.\n\t(cp_parser_template_id): Handle TYPENAME_TYPE.\n\t(cp_parser_template_name): If we're looking for a type,\n\ta name followed by < names a template.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/dtor5.C: Adjust expected error.\n\t* g++.dg/cpp23/lookup2.C: New test.\n\t* g++.dg/template/dtor11.C: New test.", "tree": {"sha": "77d10eab04edfa1319754c9df851a29dc500a866", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77d10eab04edfa1319754c9df851a29dc500a866"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18b57c1d4a8777bedfe4ed47166f033e71bc144b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18b57c1d4a8777bedfe4ed47166f033e71bc144b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18b57c1d4a8777bedfe4ed47166f033e71bc144b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18b57c1d4a8777bedfe4ed47166f033e71bc144b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8618f9e58c475389adbdfdb4127ebb8c18caba4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8618f9e58c475389adbdfdb4127ebb8c18caba4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8618f9e58c475389adbdfdb4127ebb8c18caba4c"}], "stats": {"total": 109, "additions": 92, "deletions": 17}, "files": [{"sha": "1fcd50c64fd9befc016e4affabbbf56acef057ae", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b57c1d4a8777bedfe4ed47166f033e71bc144b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b57c1d4a8777bedfe4ed47166f033e71bc144b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=18b57c1d4a8777bedfe4ed47166f033e71bc144b", "patch": "@@ -7263,6 +7263,7 @@ extern tree maybe_get_template_decl_from_type_decl (tree);\n extern int processing_template_parmlist;\n extern bool dependent_type_p\t\t\t(tree);\n extern bool dependent_scope_p\t\t\t(tree);\n+extern bool dependentish_scope_p\t\t(tree);\n extern bool any_dependent_template_arguments_p  (const_tree);\n extern bool any_erroneous_template_args_p       (const_tree);\n extern bool dependent_template_p\t\t(tree);"}, {"sha": "31bae6d89838f57739c073d08db249c62d3b0011", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b57c1d4a8777bedfe4ed47166f033e71bc144b/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b57c1d4a8777bedfe4ed47166f033e71bc144b/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=18b57c1d4a8777bedfe4ed47166f033e71bc144b", "patch": "@@ -18187,6 +18187,16 @@ cp_parser_template_id (cp_parser *parser,\n       if (TREE_CODE (template_id) == TEMPLATE_ID_EXPR)\n \tSET_EXPR_LOCATION (template_id, combined_loc);\n     }\n+  else if (TREE_CODE (templ) == TYPE_DECL\n+\t   && TREE_CODE (TREE_TYPE (templ)) == TYPENAME_TYPE)\n+    {\n+      /* Some type template in dependent scope.  */\n+      tree &name = TYPENAME_TYPE_FULLNAME (TREE_TYPE (templ));\n+      name = build_min_nt_loc (combined_loc,\n+\t\t\t       TEMPLATE_ID_EXPR,\n+\t\t\t       name, arguments);\n+      template_id = templ;\n+    }\n   else\n     {\n       /* If it's not a class-template or a template-template, it should be\n@@ -18413,8 +18423,8 @@ cp_parser_template_name (cp_parser* parser,\n     }\n \n   /* cp_parser_lookup_name clears OBJECT_TYPE.  */\n-  const bool scoped_p = ((parser->scope ? parser->scope\n-\t\t\t  : parser->context->object_type) != NULL_TREE);\n+  tree scope = (parser->scope ? parser->scope\n+\t\t: parser->context->object_type);\n \n   /* Look up the name.  */\n   decl = cp_parser_lookup_name (parser, identifier,\n@@ -18427,6 +18437,19 @@ cp_parser_template_name (cp_parser* parser,\n \n   decl = strip_using_decl (decl);\n \n+  /* 13.3 [temp.names] A < is interpreted as the delimiter of a\n+    template-argument-list if it follows a name that is not a\n+    conversion-function-id and\n+    - that follows the keyword template or a ~ after a nested-name-specifier or\n+    in a class member access expression, or\n+    - for which name lookup finds the injected-class-name of a class template\n+    or finds any declaration of a template, or\n+    - that is an unqualified name for which name lookup either finds one or\n+    more functions or finds nothing, or\n+    - that is a terminal name in a using-declarator (9.9), in a declarator-id\n+    (9.3.4), or in a type-only context other than a nested-name-specifier\n+    (13.8).  */\n+\n   /* If DECL is a template, then the name was a template-name.  */\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n@@ -18454,46 +18477,49 @@ cp_parser_template_name (cp_parser* parser,\n     }\n   else\n     {\n-      /* The standard does not explicitly indicate whether a name that\n-\t names a set of overloaded declarations, some of which are\n-\t templates, is a template-name.  However, such a name should\n-\t be a template-name; otherwise, there is no way to form a\n-\t template-id for the overloaded templates.  */\n+      /* Look through an overload set for any templates.  */\n       bool found = false;\n \n       for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (decl));\n \t   !found && iter; ++iter)\n \tif (TREE_CODE (*iter) == TEMPLATE_DECL)\n \t  found = true;\n \n+      /* \"an unqualified name for which name lookup either finds one or more\n+\t functions or finds nothing\".  */\n       if (!found\n \t  && (cxx_dialect > cxx17)\n-\t  && !scoped_p\n+\t  && !scope\n \t  && cp_lexer_next_token_is (parser->lexer, CPP_LESS)\n \t  && tag_type == none_type)\n \t{\n-\t  /* [temp.names] says \"A name is also considered to refer to a template\n-\t     if it is an unqualified-id followed by a < and name lookup finds\n-\t     either one or more functions or finds nothing.\"  */\n-\n \t  /* The \"more functions\" case.  Just use the OVERLOAD as normally.\n \t     We don't use is_overloaded_fn here to avoid considering\n \t     BASELINKs.  */\n \t  if (TREE_CODE (decl) == OVERLOAD\n \t      /* Name lookup found one function.  */\n-\t      || TREE_CODE (decl) == FUNCTION_DECL)\n+\t      || TREE_CODE (decl) == FUNCTION_DECL\n+\t      /* Name lookup found nothing.  */\n+\t      || decl == error_mark_node)\n \t    found = true;\n-\t  /* Name lookup found nothing.  */\n-\t  else if (decl == error_mark_node)\n-\t    return identifier;\n \t}\n \n+      /* \"in a type-only context\" */\n+      if (!found && scope\n+\t  && tag_type != none_type\n+\t  && dependentish_scope_p (scope)\n+\t  && cp_parser_nth_token_starts_template_argument_list_p (parser, 1))\n+\tfound = true;\n+\n       if (!found)\n \t{\n \t  /* The name does not name a template.  */\n \t  cp_parser_error (parser, \"expected template-name\");\n \t  return error_mark_node;\n \t}\n+      else if (decl == error_mark_node)\n+\t/* Repeat the lookup at instantiation time.  */\n+\tdecl = identifier;\n     }\n \n   return decl;\n@@ -30373,6 +30399,17 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t\t       consider class templates.  */\n \t\t\t    : is_template ? LOOK_want::TYPE\n \t\t\t    : prefer_type_arg (tag_type));\n+\n+      /* If we know we're looking for a type (e.g. A in p->A::x),\n+\t mock up a typename.  */\n+      if (!decl && object_type && tag_type != none_type\n+\t  && dependentish_scope_p (object_type))\n+\t{\n+\t  tree type = build_typename_type (object_type, name, name,\n+\t\t\t\t\t   typename_type);\n+\t  decl = TYPE_NAME (type);\n+\t}\n+\n       parser->object_scope = object_type;\n       parser->qualifying_scope = NULL_TREE;\n     }"}, {"sha": "4d42899f28d45f91a605138e7364611f1d83343e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b57c1d4a8777bedfe4ed47166f033e71bc144b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b57c1d4a8777bedfe4ed47166f033e71bc144b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=18b57c1d4a8777bedfe4ed47166f033e71bc144b", "patch": "@@ -26970,6 +26970,15 @@ dependent_scope_p (tree scope)\n \t  && !currently_open_class (scope));\n }\n \n+/* True if we might find more declarations in SCOPE during instantiation than\n+   we can when parsing the template.  */\n+\n+bool\n+dependentish_scope_p (tree scope)\n+{\n+  return dependent_scope_p (scope) || any_dependent_bases_p (scope);\n+}\n+\n /* T is a SCOPE_REF.  Return whether it represents a non-static member of\n    an unknown base of 'this' (and is therefore instantiation-dependent).  */\n "}, {"sha": "a16afbe219615c78235805c40842dac591862373", "filename": "gcc/testsuite/g++.dg/cpp23/lookup2.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b57c1d4a8777bedfe4ed47166f033e71bc144b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Flookup2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b57c1d4a8777bedfe4ed47166f033e71bc144b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Flookup2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Flookup2.C?ref=18b57c1d4a8777bedfe4ed47166f033e71bc144b", "patch": "@@ -0,0 +1,6 @@\n+// DR 1835\n+\n+template <class T> void f(T t) { t.foo::bar(); }\n+struct foo { void bar(); };\n+struct baz : foo { };\n+int main() { f(baz()); }"}, {"sha": "9bb58b41d47fc83bfbe312619f73521bfb4a9a12", "filename": "gcc/testsuite/g++.dg/template/dtor11.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b57c1d4a8777bedfe4ed47166f033e71bc144b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdtor11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b57c1d4a8777bedfe4ed47166f033e71bc144b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdtor11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdtor11.C?ref=18b57c1d4a8777bedfe4ed47166f033e71bc144b", "patch": "@@ -0,0 +1,22 @@\n+template <class T>\n+struct B\n+{\n+  void f(T *p)\n+  {\n+    p->template A<int>::~A<int>();\n+    p->A::~A();\n+    p->~A<int>();\n+    p->~A();\n+    p->~T();\n+    p->T::~T();\n+  }\n+};\n+\n+template <class T>\n+struct A\n+{ };\n+\n+int main()\n+{\n+  B<A<int> >().f(0);\n+}"}, {"sha": "d9a1c692a34cd618572f4f31af528de0baaa99fc", "filename": "gcc/testsuite/g++.dg/template/dtor5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b57c1d4a8777bedfe4ed47166f033e71bc144b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdtor5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b57c1d4a8777bedfe4ed47166f033e71bc144b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdtor5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdtor5.C?ref=18b57c1d4a8777bedfe4ed47166f033e71bc144b", "patch": "@@ -11,7 +11,7 @@ template <class T> void f(A<T> *ap) {\n } \n \n template <class T> void g(A<T> *ap) {\n-  ap->~B(); \t\t\t// { dg-error \"destructor name\" }\n+  ap->~B(); \t\t\t// { dg-error \"\" }\n } \n \n int main()"}]}