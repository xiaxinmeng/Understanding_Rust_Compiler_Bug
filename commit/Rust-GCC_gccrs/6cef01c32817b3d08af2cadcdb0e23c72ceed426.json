{"sha": "6cef01c32817b3d08af2cadcdb0e23c72ceed426", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNlZjAxYzMyODE3YjNkMDhhZjJjYWRjZGIwZTIzYzcyY2VlZDQyNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-06T09:23:58Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-06T09:23:58Z"}, "message": "Add fnspec handling to ipa mode of ipa-modef.\n\ngcc/:\n\n\t* attr-fnspec.h (attr_fnspec::get_str): New accessor\n\t* ipa-fnsummary.c (read_ipa_call_summary): Store also parm info\n\tfor builtins.\n\t* ipa-modref.c (class fnspec_summary): New type.\n\t(class fnspec_summaries_t): New type.\n\t(modref_summary::modref_summary): Initialize writes_errno.\n\t(struct modref_summary_lto): Add writes_errno.\n\t(modref_summary_lto::modref_summary_lto): Initialize writes_errno.\n\t(modref_summary::dump): Check for NULL pointers.\n\t(modref_summary_lto::dump): Dump writes_errno.\n\t(collapse_loads): Move up in source file.\n\t(collapse_stores): New function.\n\t(process_fnspec): Handle also internal calls.\n\t(analyze_call): Likewise.\n\t(analyze_stmt): Store fnspec string if needed.\n\t(analyze_function): Initialize fnspec_sumarries.\n\t(modref_summaries_lto::duplicate): Copy writes_errno.\n\t(modref_write): Store writes_errno and fnspec summaries.\n\t(read_section): Read writes_errno and fnspec summaries.\n\t(modref_read): Initialize fnspec summaries.\n\t(update_signature): Fix formating.\n\t(compute_parm_map): Return true if sucessful.\n\t(get_parm_type): New function.\n\t(get_access_for_fnspec): New function.\n\t(propagate_unknown_call): New function.\n\t(modref_propagate_in_scc): Use it.\n\t(pass_ipa_modref::execute): Delete fnspec_summaries.\n\t(ipa_modref_c_finalize): Delete fnspec_summaries.\n\t* ipa-prop.c: Include attr-fnspec.h.\n\t(ipa_compute_jump_functions_for_bb):  Also compute jump functions\n\tfor functions with fnspecs.\n\t(ipa_read_edge_info): Read jump functions for builtins.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/ipa/modref-2.c: New test.\n\t* gcc.dg/lto/modref-2_0.c: New test.", "tree": {"sha": "8d0c62cd340e8857600008968c18df33092174e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d0c62cd340e8857600008968c18df33092174e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cef01c32817b3d08af2cadcdb0e23c72ceed426", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cef01c32817b3d08af2cadcdb0e23c72ceed426", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cef01c32817b3d08af2cadcdb0e23c72ceed426", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cef01c32817b3d08af2cadcdb0e23c72ceed426/comments", "author": null, "committer": null, "parents": [{"sha": "366099ff0823c3c9929dd7fb911f4af04e63baef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/366099ff0823c3c9929dd7fb911f4af04e63baef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/366099ff0823c3c9929dd7fb911f4af04e63baef"}], "stats": {"total": 649, "additions": 501, "deletions": 148}, "files": [{"sha": "281353284379a4ec150daed12b7be83651aa28e1", "filename": "gcc/attr-fnspec.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cef01c32817b3d08af2cadcdb0e23c72ceed426/gcc%2Fattr-fnspec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cef01c32817b3d08af2cadcdb0e23c72ceed426/gcc%2Fattr-fnspec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattr-fnspec.h?ref=6cef01c32817b3d08af2cadcdb0e23c72ceed426", "patch": "@@ -246,6 +246,13 @@ class attr_fnspec\n \n   /* Check validity of the string.  */\n   void verify ();\n+\n+  /* Return the fnspec string.  */\n+  const char *\n+  get_str ()\n+  {\n+    return str;\n+  }\n };\n \n extern attr_fnspec gimple_call_fnspec (const gcall *stmt);"}, {"sha": "b8f4a0a9091674ac964efa05f10253b8f1d8cde9", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cef01c32817b3d08af2cadcdb0e23c72ceed426/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cef01c32817b3d08af2cadcdb0e23c72ceed426/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=6cef01c32817b3d08af2cadcdb0e23c72ceed426", "patch": "@@ -4301,7 +4301,11 @@ read_ipa_call_summary (class lto_input_block *ib, struct cgraph_edge *e,\n   if (es)\n     edge_set_predicate (e, &p);\n   length = streamer_read_uhwi (ib);\n-  if (length && es && e->possibly_call_in_translation_unit_p ())\n+  if (length && es\n+      && (e->possibly_call_in_translation_unit_p ()\n+\t  /* Also stream in jump functions to builtins in hope that they\n+\t     will get fnspecs.  */\n+\t  || fndecl_built_in_p (e->callee->decl, BUILT_IN_NORMAL)))\n     {\n       es->param.safe_grow_cleared (length, true);\n       for (i = 0; i < length; i++)"}, {"sha": "95109825b39eb521af9155a287e9b01a8c4f08cf", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 439, "deletions": 145, "changes": 584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cef01c32817b3d08af2cadcdb0e23c72ceed426/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cef01c32817b3d08af2cadcdb0e23c72ceed426/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=6cef01c32817b3d08af2cadcdb0e23c72ceed426", "patch": "@@ -62,8 +62,47 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attr-fnspec.h\"\n #include \"symtab-clones.h\"\n \n+/* We record fnspec specifiers for call edges since they depends on actual\n+   gimple statements.  */\n+\n+class fnspec_summary\n+{\n+public:\n+  char *fnspec;\n+\n+  fnspec_summary ()\n+  : fnspec (NULL)\n+  {\n+  }\n+\n+  ~fnspec_summary ()\n+  {\n+    free (fnspec);\n+  }\n+};\n+\n+/* Summary holding fnspec string for a given call.  */\n+\n+class fnspec_summaries_t : public call_summary <fnspec_summary *>\n+{\n+public:\n+  fnspec_summaries_t (symbol_table *symtab)\n+      : call_summary <fnspec_summary *> (symtab) {}\n+  /* Hook that is called by summary when an edge is duplicated.  */\n+  virtual void duplicate (cgraph_edge *,\n+\t\t\t  cgraph_edge *,\n+\t\t\t  fnspec_summary *src,\n+\t\t\t  fnspec_summary *dst)\n+  {\n+    dst->fnspec = xstrdup (src->fnspec);\n+  }\n+};\n+\n+static fnspec_summaries_t *fnspec_summaries = NULL;\n+\n /* Class (from which there is one global instance) that holds modref summaries\n    for all analyzed functions.  */\n+\n class GTY((user)) modref_summaries\n   : public fast_function_summary <modref_summary *, va_gc>\n {\n@@ -86,6 +125,7 @@ class modref_summary_lto;\n \n /* Class (from which there is one global instance) that holds modref summaries\n    for all analyzed functions.  */\n+\n class GTY((user)) modref_summaries_lto\n   : public fast_function_summary <modref_summary_lto *, va_gc>\n {\n@@ -108,23 +148,26 @@ class GTY((user)) modref_summaries_lto\n \n /* Global variable holding all modref summaries\n    (from analysis to IPA propagation time).  */\n+\n static GTY(()) fast_function_summary <modref_summary *, va_gc>\n \t *summaries;\n \n /* Global variable holding all modref optimizaiton summaries\n    (from IPA propagation time or used by local optimization pass).  */\n+\n static GTY(()) fast_function_summary <modref_summary *, va_gc>\n \t *optimization_summaries;\n \n /* LTO summaries hold info from analysis to LTO streaming or from LTO\n    stream-in through propagation to LTO stream-out.  */\n+\n static GTY(()) fast_function_summary <modref_summary_lto *, va_gc>\n \t *summaries_lto;\n \n /* Summary for a single function which this pass produces.  */\n \n modref_summary::modref_summary ()\n-  : loads (NULL), stores (NULL)\n+  : loads (NULL), stores (NULL), writes_errno (NULL)\n {\n }\n \n@@ -161,6 +204,7 @@ struct GTY(()) modref_summary_lto\n      more verbose and thus more likely to hit the limits.  */\n   modref_records_lto *loads;\n   modref_records_lto *stores;\n+  bool writes_errno;\n \n   modref_summary_lto ();\n   ~modref_summary_lto ();\n@@ -171,7 +215,7 @@ struct GTY(()) modref_summary_lto\n /* Summary for a single function which this pass produces.  */\n \n modref_summary_lto::modref_summary_lto ()\n-  : loads (NULL), stores (NULL)\n+  : loads (NULL), stores (NULL), writes_errno (NULL)\n {\n }\n \n@@ -316,10 +360,16 @@ dump_lto_records (modref_records_lto *tt, FILE *out)\n void\n modref_summary::dump (FILE *out)\n {\n-  fprintf (out, \"  loads:\\n\");\n-  dump_records (loads, out);\n-  fprintf (out, \"  stores:\\n\");\n-  dump_records (stores, out);\n+  if (loads)\n+    {\n+      fprintf (out, \"  loads:\\n\");\n+      dump_records (loads, out);\n+    }\n+  if (stores)\n+    {\n+      fprintf (out, \"  stores:\\n\");\n+      dump_records (stores, out);\n+    }\n   if (writes_errno)\n     fprintf (out, \"  Writes errno\\n\");\n }\n@@ -333,6 +383,8 @@ modref_summary_lto::dump (FILE *out)\n   dump_lto_records (loads, out);\n   fprintf (out, \"  stores:\\n\");\n   dump_lto_records (stores, out);\n+  if (writes_errno)\n+    fprintf (out, \"  Writes errno\\n\");\n }\n \n /* Get function summary for FUNC if it exists, return NULL otherwise.  */\n@@ -653,12 +705,59 @@ get_access_for_fnspec (gcall *call, attr_fnspec &fnspec,\n   return a;\n }\n \n+/* Collapse loads and return true if something changed.  */\n+\n+static bool\n+collapse_loads (modref_summary *cur_summary,\n+\t\tmodref_summary_lto *cur_summary_lto)\n+{\n+  bool changed = false;\n+\n+  if (cur_summary && !cur_summary->loads->every_base)\n+    {\n+      cur_summary->loads->collapse ();\n+      changed = true;\n+    }\n+  if (cur_summary_lto\n+      && !cur_summary_lto->loads->every_base)\n+    {\n+      cur_summary_lto->loads->collapse ();\n+      changed = true;\n+    }\n+  return changed;\n+}\n+\n+/* Collapse loads and return true if something changed.  */\n+\n+static bool\n+collapse_stores (modref_summary *cur_summary,\n+\t\tmodref_summary_lto *cur_summary_lto)\n+{\n+  bool changed = false;\n+\n+  if (cur_summary && !cur_summary->stores->every_base)\n+    {\n+      cur_summary->stores->collapse ();\n+      changed = true;\n+    }\n+  if (cur_summary_lto\n+      && !cur_summary_lto->stores->every_base)\n+    {\n+      cur_summary_lto->stores->collapse ();\n+      changed = true;\n+    }\n+  return changed;\n+}\n+\n+\n /* Apply side effects of call STMT to CUR_SUMMARY using FNSPEC.\n    If IGNORE_STORES is true ignore them.\n    Return false if no useful summary can be produced.   */\n \n static bool\n-process_fnspec (modref_summary *cur_summary, gcall *call, bool ignore_stores)\n+process_fnspec (modref_summary *cur_summary,\n+\t\tmodref_summary_lto *cur_summary_lto,\n+\t\tgcall *call, bool ignore_stores)\n {\n   attr_fnspec fnspec = gimple_call_fnspec (call);\n   if (!fnspec.known_p ())\n@@ -668,13 +767,13 @@ process_fnspec (modref_summary *cur_summary, gcall *call, bool ignore_stores)\n \t\t IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl (call))));\n       if (ignore_stores)\n \t{\n-\t  cur_summary->loads->collapse ();\n+\t  collapse_loads (cur_summary, cur_summary_lto);\n \t  return true;\n \t}\n       return false;\n     }\n   if (fnspec.global_memory_read_p ())\n-    cur_summary->loads->collapse ();\n+    collapse_loads (cur_summary, cur_summary_lto);\n   else\n     {\n       for (unsigned int i = 0; i < gimple_call_num_args (call); i++)\n@@ -689,18 +788,25 @@ process_fnspec (modref_summary *cur_summary, gcall *call, bool ignore_stores)\n \t      continue;\n \t    if (map.parm_index == -1)\n \t      {\n-\t\tcur_summary->loads->collapse ();\n+\t\tcollapse_loads (cur_summary, cur_summary_lto);\n \t\tbreak;\n \t      }\n-\t    cur_summary->loads->insert (0, 0,\n-\t\t\t\t\tget_access_for_fnspec (call,\n-\t\t\t\t\t\t\t       fnspec, i, map));\n+\t    if (cur_summary)\n+\t      cur_summary->loads->insert (0, 0,\n+\t\t\t\t\t  get_access_for_fnspec (call,\n+\t\t\t\t\t\t\t\t fnspec, i,\n+\t\t\t\t\t\t\t\t map));\n+\t    if (cur_summary_lto)\n+\t      cur_summary_lto->loads->insert (0, 0,\n+\t\t\t\t\t      get_access_for_fnspec (call,\n+\t\t\t\t\t\t\t\t     fnspec, i,\n+\t\t\t\t\t\t\t\t     map));\n \t  }\n     }\n   if (ignore_stores)\n     return true;\n   if (fnspec.global_memory_written_p ())\n-    cur_summary->stores->collapse ();\n+    collapse_stores (cur_summary, cur_summary_lto);\n   else\n     {\n       for (unsigned int i = 0; i < gimple_call_num_args (call); i++)\n@@ -715,16 +821,27 @@ process_fnspec (modref_summary *cur_summary, gcall *call, bool ignore_stores)\n \t      continue;\n \t    if (map.parm_index == -1)\n \t      {\n-\t\tcur_summary->stores->collapse ();\n+\t\tcollapse_stores (cur_summary, cur_summary_lto);\n \t\tbreak;\n \t      }\n-\t    cur_summary->stores->insert (0, 0,\n-\t\t\t\t\t get_access_for_fnspec (call,\n-\t\t\t\t\t\t\t\tfnspec, i,\n-\t\t\t\t\t\t\t\tmap));\n+\t    if (cur_summary)\n+\t      cur_summary->stores->insert (0, 0,\n+\t\t\t\t\t   get_access_for_fnspec (call,\n+\t\t\t\t\t\t\t\t  fnspec, i,\n+\t\t\t\t\t\t\t\t  map));\n+\t    if (cur_summary_lto)\n+\t      cur_summary_lto->stores->insert (0, 0,\n+\t\t\t\t\t       get_access_for_fnspec (call,\n+\t\t\t\t\t\t\t\t      fnspec, i,\n+\t\t\t\t\t\t\t\t      map));\n \t  }\n       if (fnspec.errno_maybe_written_p () && flag_errno_math)\n-\tcur_summary->writes_errno = true;\n+\t{\n+\t  if (cur_summary)\n+\t    cur_summary->writes_errno = true;\n+\t  if (cur_summary_lto)\n+\t    cur_summary_lto->writes_errno = true;\n+\t}\n     }\n   return true;\n }\n@@ -733,7 +850,7 @@ process_fnspec (modref_summary *cur_summary, gcall *call, bool ignore_stores)\n    Remember recursive calls in RECURSIVE_CALLS.  */\n \n static bool\n-analyze_call (modref_summary *cur_summary,\n+analyze_call (modref_summary *cur_summary, modref_summary_lto *cur_summary_lto,\n \t      gcall *stmt, vec <gimple *> *recursive_calls)\n {\n   /* Check flags on the function call.  In certain cases, analysis can be\n@@ -759,21 +876,13 @@ analyze_call (modref_summary *cur_summary,\n   /* Check if this is an indirect call.  */\n   if (!callee)\n     {\n-      /* If the indirect call does not write memory, our store summary is\n-\t unaffected, but we have to discard our loads summary (we don't know\n-\t anything about the loads that the called function performs).  */\n-      if (ignore_stores)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \" - Indirect call which does not write memory, \"\n-\t\t    \"discarding loads.\\n\");\n-\t  cur_summary->loads->collapse ();\n-\t  return true;\n-\t}\n       if (dump_file)\n-\tfprintf (dump_file, \" - Indirect call.\\n\");\n-      return false;\n+\tfprintf (dump_file, gimple_call_internal_p (stmt)\n+\t\t ? \" - Internal call\" : \" - Indirect call.\\n\");\n+      return process_fnspec (cur_summary, cur_summary_lto, stmt, ignore_stores);\n     }\n+  /* We only need to handle internal calls in IPA mode.  */\n+  gcc_checking_assert (!cur_summary_lto);\n \n   struct cgraph_node *callee_node = cgraph_node::get_create (callee);\n \n@@ -796,7 +905,7 @@ analyze_call (modref_summary *cur_summary,\n     {\n       if (dump_file)\n \tfprintf (dump_file, \" - Function availability <= AVAIL_INTERPOSABLE.\\n\");\n-      return process_fnspec (cur_summary, stmt, ignore_stores);\n+      return process_fnspec (cur_summary, cur_summary_lto, stmt, ignore_stores);\n     }\n \n   /* Get callee's modref summary.  As above, if there's no summary, we either\n@@ -806,7 +915,7 @@ analyze_call (modref_summary *cur_summary,\n     {\n       if (dump_file)\n \tfprintf (dump_file, \" - No modref summary available for callee.\\n\");\n-      return process_fnspec (cur_summary, stmt, ignore_stores);\n+      return process_fnspec (cur_summary, cur_summary_lto, stmt, ignore_stores);\n     }\n \n   merge_call_side_effects (cur_summary, stmt, callee_summary, ignore_stores,\n@@ -911,8 +1020,24 @@ analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n \t       \"which clobbers memory.\\n\");\n      return false;\n    case GIMPLE_CALL:\n-     if (!ipa)\n-       return analyze_call (summary, as_a <gcall *> (stmt), recursive_calls);\n+     if (!ipa || gimple_call_internal_p (stmt))\n+       return analyze_call (summary, summary_lto,\n+\t\t\t    as_a <gcall *> (stmt), recursive_calls);\n+     else\n+      {\n+\tattr_fnspec fnspec = gimple_call_fnspec (as_a <gcall *>(stmt));\n+\n+\tif (fnspec.known_p ()\n+\t    && (!fnspec.global_memory_read_p ()\n+\t\t|| !fnspec.global_memory_written_p ()))\n+\t  {\n+\t    fnspec_summaries->get_create\n+\t\t (cgraph_node::get (current_function_decl)->get_edge (stmt))\n+\t\t\t->fnspec = xstrdup (fnspec.get_str ());\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \"  Recorded fnspec %s\\n\", fnspec.get_str ());\n+\t  }\n+      }\n      return true;\n    default:\n      /* Nothing to do for other types of statements.  */\n@@ -1015,6 +1140,8 @@ analyze_function (function *f, bool ipa)\n \t    summaries_lto->remove (cgraph_node::get (f->decl));\n \t  summary_lto = summaries_lto->get_create (cgraph_node::get (f->decl));\n \t}\n+      if (!fnspec_summaries)\n+\tfnspec_summaries = new fnspec_summaries_t (symtab);\n      }\n \n \n@@ -1045,6 +1172,7 @@ analyze_function (function *f, bool ipa)\n \t\t\t\t (param_modref_max_bases,\n \t\t\t\t  param_modref_max_refs,\n \t\t\t\t  param_modref_max_accesses);\n+      summary_lto->writes_errno = false;\n     }\n   int ecf_flags = flags_from_decl_or_type (current_function_decl);\n   auto_vec <gimple *, 32> recursive_calls;\n@@ -1221,6 +1349,7 @@ modref_summaries_lto::duplicate (cgraph_node *, cgraph_node *,\n \t\t\t src_data->loads->max_refs,\n \t\t\t src_data->loads->max_accesses);\n   dst_data->loads->copy_from (src_data->loads);\n+  dst_data->writes_errno = src_data->writes_errno;\n }\n \n namespace\n@@ -1484,7 +1613,6 @@ modref_write ()\n \n       if (cnode && cnode->definition && !cnode->alias)\n \t{\n-\n \t  modref_summary_lto *r = summaries_lto->get (cnode);\n \n \t  if (!r || !r->useful_p (flags_from_decl_or_type (cnode->decl)))\n@@ -1494,6 +1622,28 @@ modref_write ()\n \n \t  write_modref_records (r->loads, ob);\n \t  write_modref_records (r->stores, ob);\n+\n+\t  struct bitpack_d bp = bitpack_create (ob->main_stream);\n+\t  bp_pack_value (&bp, r->writes_errno, 1);\n+\t  if (!flag_wpa)\n+\t    {\n+\t      for (cgraph_edge *e = cnode->indirect_calls;\n+\t\t   e; e = e->next_callee)\n+\t\t{\n+\t\t  class fnspec_summary *sum = fnspec_summaries->get (e);\n+\t\t  bp_pack_value (&bp, sum != NULL, 1);\n+\t\t  if (sum)\n+\t\t    bp_pack_string (ob, &bp, sum->fnspec, true);\n+\t\t}\n+\t      for (cgraph_edge *e = cnode->callees; e; e = e->next_callee)\n+\t\t{\n+\t\t  class fnspec_summary *sum = fnspec_summaries->get (e);\n+\t\t  bp_pack_value (&bp, sum != NULL, 1);\n+\t\t  if (sum)\n+\t\t    bp_pack_string (ob, &bp, sum->fnspec, true);\n+\t\t}\n+\t    }\n+\t  streamer_write_bitpack (&bp);\n \t}\n     }\n   streamer_write_char_stream (ob->main_stream, 0);\n@@ -1541,6 +1691,8 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \n       if (modref_sum)\n \tmodref_sum->writes_errno = false;\n+      if (modref_sum_lto)\n+\tmodref_sum_lto->writes_errno = false;\n \n       gcc_assert (!modref_sum || (!modref_sum->loads\n \t\t\t\t  && !modref_sum->stores));\n@@ -1552,6 +1704,33 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n       read_modref_records (&ib, data_in,\n \t\t\t   modref_sum ? &modref_sum->stores : NULL,\n \t\t\t   modref_sum_lto ? &modref_sum_lto->stores : NULL);\n+      struct bitpack_d bp = streamer_read_bitpack (&ib);\n+      if (bp_unpack_value (&bp, 1))\n+\t{\n+\t  if (modref_sum)\n+\t    modref_sum->writes_errno = true;\n+\t  if (modref_sum_lto)\n+\t    modref_sum_lto->writes_errno = true;\n+\t}\n+      if (!flag_ltrans)\n+\t{\n+\t  for (cgraph_edge *e = node->indirect_calls; e; e = e->next_callee)\n+\t    {\n+\t      if (bp_unpack_value (&bp, 1))\n+\t\t{\n+\t\t  class fnspec_summary *sum = fnspec_summaries->get_create (e);\n+\t\t  sum->fnspec = xstrdup (bp_unpack_string (data_in, &bp));\n+\t\t}\n+\t    }\n+\t  for (cgraph_edge *e = node->callees; e; e = e->next_callee)\n+\t    {\n+\t      if (bp_unpack_value (&bp, 1))\n+\t\t{\n+\t\t  class fnspec_summary *sum = fnspec_summaries->get_create (e);\n+\t\t  sum->fnspec = xstrdup (bp_unpack_string (data_in, &bp));\n+\t\t}\n+\t    }\n+\t}\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"Read modref for %s\\n\",\n@@ -1588,6 +1767,8 @@ modref_read (void)\n \t  || (flag_incremental_link == INCREMENTAL_LINK_LTO\n \t      && flag_fat_lto_objects))\n \tsummaries = modref_summaries::create_ggc (symtab);\n+      if (!fnspec_summaries)\n+\tfnspec_summaries = new fnspec_summaries_t (symtab);\n     }\n \n   while ((file_data = file_data_vec[j++]))\n@@ -1664,9 +1845,9 @@ update_signature (struct cgraph_node *node)\n     {\n       fprintf (dump_file, \"to:\\n\");\n       if (r)\n-        r->dump (dump_file);\n+\tr->dump (dump_file);\n       if (r_lto)\n-        r_lto->dump (dump_file);\n+\tr_lto->dump (dump_file);\n     }\n   return;\n }\n@@ -1755,7 +1936,7 @@ ignore_edge (struct cgraph_edge *e)\n \n /* Compute parm_map for CALLE_EDGE.  */\n \n-static void\n+static bool\n compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n {\n   class ipa_edge_args *args;\n@@ -1837,7 +2018,9 @@ compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n \t    fprintf (dump_file, \" %i\", (*parm_map)[i].parm_index);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n+      return true;\n     }\n+  return false;\n }\n \n /* Call EDGE was inlined; merge summary from callee to the caller.  */\n@@ -1948,26 +2131,171 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n   return;\n }\n \n-/* Collapse loads and return true if something changed.  */\n+/* Get parameter type from DECL.  This is only safe for special cases\n+   like builtins we create fnspec for because the type match is checked\n+   at fnspec creation time.  */\n \n-bool\n-collapse_loads (modref_summary *cur_summary,\n-\t\tmodref_summary_lto *cur_summary_lto)\n+static tree\n+get_parm_type (tree decl, unsigned int i)\n {\n-  bool changed = false;\n+  tree t = TYPE_ARG_TYPES (TREE_TYPE (decl));\n \n-  if (cur_summary && !cur_summary->loads->every_base)\n+  for (unsigned int p = 0; p < i; p++)\n+    t = TREE_CHAIN (t);\n+  return TREE_VALUE (t);\n+}\n+\n+/* Return access mode for argument I of call E with FNSPEC.  */\n+\n+static modref_access_node\n+get_access_for_fnspec (cgraph_edge *e, attr_fnspec &fnspec,\n+\t\t       unsigned int i, modref_parm_map &map)\n+{\n+  tree size = NULL_TREE;\n+  unsigned int size_arg;\n+\n+  if (!fnspec.arg_specified_p (i))\n+    ;\n+  else if (fnspec.arg_max_access_size_given_by_arg_p (i, &size_arg))\n     {\n-      cur_summary->loads->collapse ();\n-      changed = true;\n+      cgraph_node *node = e->caller->inlined_to\n+\t\t\t  ? e->caller->inlined_to : e->caller;\n+      class ipa_node_params *caller_parms_info = IPA_NODE_REF (node);\n+      class ipa_edge_args *args = IPA_EDGE_REF (e);\n+      struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, size_arg);\n+\n+      if (jf)\n+\tsize = ipa_value_from_jfunc (caller_parms_info, jf,\n+\t\t\t\t     get_parm_type (e->callee->decl, size_arg));\n     }\n-  if (cur_summary_lto\n-      && !cur_summary_lto->loads->every_base)\n+  else if (fnspec.arg_access_size_given_by_type_p (i))\n+    size = TYPE_SIZE_UNIT (get_parm_type (e->callee->decl, i));\n+  modref_access_node a = {0, -1, -1,\n+\t\t\t  map.parm_offset, map.parm_index,\n+\t\t\t  map.parm_offset_known};\n+  poly_int64 size_hwi;\n+  if (size\n+      && poly_int_tree_p (size, &size_hwi)\n+      && coeffs_in_range_p (size_hwi, 0,\n+\t\t\t    HOST_WIDE_INT_MAX / BITS_PER_UNIT))\n     {\n-      cur_summary_lto->loads->collapse ();\n-      changed = true;\n+      a.size = -1;\n+      a.max_size = size_hwi << LOG2_BITS_PER_UNIT;\n     }\n-  return changed;\n+  return a;\n+}\n+\n+/* Call E in NODE with ECF_FLAGS has no summary; update MODREF_SUMMARY and\n+   CUR_SUMMARY_LTO accordingly.  Return true if something changed.  */\n+\n+static bool\n+propagate_unknown_call (cgraph_node *node,\n+\t\t\tcgraph_edge *e, int ecf_flags,\n+\t\t\tmodref_summary **cur_summary_ptr,\n+\t\t\tmodref_summary_lto **cur_summary_lto_ptr)\n+{\n+  bool changed = false;\n+  modref_summary *cur_summary = cur_summary_ptr ? *cur_summary_ptr : NULL;\n+  modref_summary_lto *cur_summary_lto = cur_summary_lto_ptr\n+\t\t\t\t\t? *cur_summary_lto_ptr : NULL;\n+  class fnspec_summary *fnspec_sum = fnspec_summaries->get (e);\n+  auto_vec <modref_parm_map, 32> parm_map;\n+  if (fnspec_sum\n+      && compute_parm_map (e, &parm_map))\n+    {\n+      attr_fnspec fnspec (fnspec_sum->fnspec);\n+\n+      gcc_checking_assert (fnspec.known_p ());\n+      if (fnspec.global_memory_read_p ())\n+\tcollapse_loads (cur_summary, cur_summary_lto);\n+      else\n+\t{\n+\t  tree t = TYPE_ARG_TYPES (TREE_TYPE (e->callee->decl));\n+\t  for (unsigned i = 0; i < parm_map.length () && t;\n+\t       i++, t = TREE_CHAIN (t))\n+\t    if (!POINTER_TYPE_P (TREE_VALUE (t)))\n+\t      ;\n+\t  else if (!fnspec.arg_specified_p (i)\n+\t\t   || fnspec.arg_maybe_read_p (i))\n+\t    {\n+\t      modref_parm_map map = parm_map[i];\n+\t      if (map.parm_index == -2)\n+\t\tcontinue;\n+\t      if (map.parm_index == -1)\n+\t\t{\n+\t\t  collapse_loads (cur_summary, cur_summary_lto);\n+\t\t  break;\n+\t\t}\n+\t      if (cur_summary)\n+\t\tchanged |= cur_summary->loads->insert\n+\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map));\n+\t      if (cur_summary_lto)\n+\t\tchanged |= cur_summary_lto->loads->insert\n+\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map));\n+\t    }\n+\t}\n+      if (ignore_stores_p (node->decl, ecf_flags))\n+\t;\n+      else if (fnspec.global_memory_written_p ())\n+\tcollapse_stores (cur_summary, cur_summary_lto);\n+      else\n+\t{\n+\t  tree t = TYPE_ARG_TYPES (TREE_TYPE (e->callee->decl));\n+\t  for (unsigned i = 0; i < parm_map.length () && t;\n+\t       i++, t = TREE_CHAIN (t))\n+\t    if (!POINTER_TYPE_P (TREE_VALUE (t)))\n+\t      ;\n+\t  else if (!fnspec.arg_specified_p (i)\n+\t\t   || fnspec.arg_maybe_written_p (i))\n+\t    {\n+\t      modref_parm_map map = parm_map[i];\n+\t      if (map.parm_index == -2)\n+\t\tcontinue;\n+\t      if (map.parm_index == -1)\n+\t\t{\n+\t\t  collapse_stores (cur_summary, cur_summary_lto);\n+\t\t  break;\n+\t\t}\n+\t      if (cur_summary)\n+\t\tchanged |= cur_summary->stores->insert\n+\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map));\n+\t      if (cur_summary_lto)\n+\t\tchanged |= cur_summary_lto->stores->insert\n+\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map));\n+\t    }\n+\t}\n+      if (fnspec.errno_maybe_written_p () && flag_errno_math)\n+\t{\n+\t  if (cur_summary && !cur_summary->writes_errno)\n+\t    {\n+\t      cur_summary->writes_errno = true;\n+\t      changed = true;\n+\t    }\n+\t  if (cur_summary_lto && !cur_summary_lto->writes_errno)\n+\t    {\n+\t      cur_summary_lto->writes_errno = true;\n+\t      changed = true;\n+\t    }\n+\t}\n+      return changed;\n+    }\n+  if (ignore_stores_p (node->decl, ecf_flags))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"      collapsing loads\\n\");\n+      return collapse_loads (cur_summary, cur_summary_lto);\n+    }\n+  if (optimization_summaries)\n+    optimization_summaries->remove (node);\n+  if (summaries_lto)\n+    summaries_lto->remove (node);\n+  if (cur_summary_ptr)\n+    *cur_summary_ptr = NULL;\n+  if (cur_summary_lto_ptr)\n+    *cur_summary_lto_ptr = NULL;\n+  if (dump_file)\n+    fprintf (dump_file, \"    Giving up\\n\");\n+  return true;\n }\n \n /* Perform iterative dataflow on SCC component starting in COMPONENT_NODE.  */\n@@ -2005,26 +2333,14 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t    {\n \t      if (e->indirect_info->ecf_flags & (ECF_CONST | ECF_NOVOPS))\n \t\tcontinue;\n-\t      if (ignore_stores_p (cur->decl, e->indirect_info->ecf_flags))\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"    Indirect call: \"\n-\t\t\t     \"collapsing loads\\n\");\n-\t\t  changed |= collapse_loads (cur_summary, cur_summary_lto);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"    Indirect call: giving up\\n\");\n-\t\t  if (optimization_summaries)\n-\t\t    optimization_summaries->remove (node);\n-\t\t  if (summaries_lto)\n-\t\t    summaries_lto->remove (node);\n-\t\t  changed = true;\n-\t\t  cur_summary = NULL;\n-\t\t  cur_summary_lto = NULL;\n-\t\t  break;\n-\t\t}\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"    Indirect call\"\n+\t\t\t \"collapsing loads\\n\");\n+\t      changed |= propagate_unknown_call\n+\t\t\t   (node, e, e->indirect_info->ecf_flags,\n+\t\t\t    &cur_summary, &cur_summary_lto);\n+\t      if (!cur_summary && !cur_summary_lto)\n+\t\tbreak;\n \t    }\n \n \t  if (!cur_summary && !cur_summary_lto)\n@@ -2063,30 +2379,15 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \n \t      if (avail <= AVAIL_INTERPOSABLE)\n \t\t{\n-\t\t  if (!ignore_stores)\n-\t\t    {\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"      Call target interposable\"\n-\t\t\t\t \" or not available\\n\");\n-\n-\t\t      if (optimization_summaries)\n-\t\t\toptimization_summaries->remove (node);\n-\t\t      if (summaries_lto)\n-\t\t\tsummaries_lto->remove (node);\n-\t\t      cur_summary = NULL;\n-\t\t      cur_summary_lto = NULL;\n-\t\t      changed = true;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"      Call target interposable\"\n-\t\t\t\t \" or not available; collapsing loads\\n\");\n-\n-\t\t      changed |= collapse_loads (cur_summary, cur_summary_lto);\n-\t\t      continue;\n-\t\t    }\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"      Call target interposable\"\n+\t\t\t     \" or not available\\n\");\n+\t\t  changed |= propagate_unknown_call\n+\t\t\t       (node, callee_edge, flags,\n+\t\t\t\t&cur_summary, &cur_summary_lto);\n+\t\t  if (!cur_summary && !cur_summary_lto)\n+\t\t    break;\n+\t\t  continue;\n \t\t}\n \n \t      /* We don't know anything about CALLEE, hence we cannot tell\n@@ -2095,52 +2396,24 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t      if (cur_summary\n \t\t  && !(callee_summary = optimization_summaries->get (callee)))\n \t\t{\n-\t\t  if (!ignore_stores)\n-\t\t    {\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"      No call target summary\\n\");\n-\n-\t\t      optimization_summaries->remove (node);\n-\t\t      cur_summary = NULL;\n-\t\t      changed = true;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"      No call target summary;\"\n-\t\t\t\t \" collapsing loads\\n\");\n-\n-\t\t      if (!cur_summary->loads->every_base)\n-\t\t\t{\n-\t\t\t  cur_summary->loads->collapse ();\n-\t\t\t  changed = true;\n-\t\t\t}\n-\t\t    }\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"      No call target summary\\n\");\n+\t\t  changed |= propagate_unknown_call\n+\t\t\t       (node, callee_edge, flags,\n+\t\t\t\t&cur_summary, NULL);\n+\t\t  if (!cur_summary && !cur_summary_lto)\n+\t\t    break;\n \t\t}\n \t      if (cur_summary_lto\n \t\t  && !(callee_summary_lto = summaries_lto->get (callee)))\n \t\t{\n-\t\t  if (!ignore_stores)\n-\t\t    {\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"      No call target summary\\n\");\n-\n-\t\t      summaries_lto->remove (node);\n-\t\t      cur_summary_lto = NULL;\n-\t\t      changed = true;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"      No call target summary;\"\n-\t\t\t\t \" collapsing loads\\n\");\n-\n-\t\t      if (!cur_summary_lto->loads->every_base)\n-\t\t\t{\n-\t\t\t  cur_summary_lto->loads->collapse ();\n-\t\t\t  changed = true;\n-\t\t\t}\n-\t\t    }\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"      No call target summary\\n\");\n+\t\t  changed |= propagate_unknown_call\n+\t\t\t       (node, callee_edge, flags,\n+\t\t\t\tNULL, &cur_summary_lto);\n+\t\t  if (!cur_summary && !cur_summary_lto)\n+\t\t    break;\n \t\t}\n \n \t      /* We can not safely optimize based on summary of callee if it\n@@ -2166,16 +2439,32 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t  changed |= cur_summary->loads->merge\n \t\t\t\t  (callee_summary->loads, &parm_map);\n \t\t  if (!ignore_stores)\n-\t\t    changed |= cur_summary->stores->merge\n-\t\t\t\t    (callee_summary->stores, &parm_map);\n+\t\t    {\n+\t\t      changed |= cur_summary->stores->merge\n+\t\t\t\t      (callee_summary->stores, &parm_map);\n+\t\t      if (!cur_summary->writes_errno\n+\t\t\t  && callee_summary->writes_errno)\n+\t\t\t{\n+\t\t\t  cur_summary->writes_errno = true;\n+\t\t\t  changed = true;\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t      if (callee_summary_lto)\n \t\t{\n \t\t  changed |= cur_summary_lto->loads->merge\n \t\t\t\t  (callee_summary_lto->loads, &parm_map);\n \t\t  if (!ignore_stores)\n-\t\t    changed |= cur_summary_lto->stores->merge\n-\t\t\t\t    (callee_summary_lto->stores, &parm_map);\n+\t\t    {\n+\t\t      changed |= cur_summary_lto->stores->merge\n+\t\t\t\t      (callee_summary_lto->stores, &parm_map);\n+\t\t      if (!cur_summary_lto->writes_errno\n+\t\t\t  && callee_summary_lto->writes_errno)\n+\t\t\t{\n+\t\t\t  cur_summary_lto->writes_errno = true;\n+\t\t\t  changed = true;\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t      if (dump_file && changed)\n \t\t{\n@@ -2266,6 +2555,8 @@ pass_ipa_modref::execute (function *)\n     ((modref_summaries_lto *)summaries_lto)->propagated = true;\n   ipa_free_postorder_info ();\n   free (order);\n+  delete fnspec_summaries;\n+  fnspec_summaries = NULL;\n   return 0;\n }\n \n@@ -2283,6 +2574,9 @@ ipa_modref_c_finalize ()\n       ggc_delete (summaries_lto);\n       summaries_lto = NULL;\n     }\n+  if (fnspec_summaries)\n+    delete fnspec_summaries;\n+  fnspec_summaries = NULL;\n }\n \n #include \"gt-ipa-modref.h\""}, {"sha": "7a5fa59ecec0c1a076881fa3156775eb7c07e5d4", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cef01c32817b3d08af2cadcdb0e23c72ceed426/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cef01c32817b3d08af2cadcdb0e23c72ceed426/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=6cef01c32817b3d08af2cadcdb0e23c72ceed426", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfgcleanup.h\"\n #include \"options.h\"\n #include \"symtab-clones.h\"\n+#include \"attr-fnspec.h\"\n \n /* Function summary where the parameter infos are actually stored. */\n ipa_node_params_t *ipa_node_params_sum = NULL;\n@@ -2364,7 +2365,8 @@ ipa_compute_jump_functions_for_bb (struct ipa_func_body_info *fbi, basic_block b\n \t  callee = callee->ultimate_alias_target ();\n \t  /* We do not need to bother analyzing calls to unknown functions\n \t     unless they may become known during lto/whopr.  */\n-\t  if (!callee->definition && !flag_lto)\n+\t  if (!callee->definition && !flag_lto\n+\t      && !gimple_call_fnspec (cs->call_stmt).known_p ())\n \t    continue;\n \t}\n       ipa_compute_jump_functions_for_edge (fbi, cs);\n@@ -4974,7 +4976,11 @@ ipa_read_edge_info (class lto_input_block *ib,\n   count /= 2;\n   if (!count)\n     return;\n-  if (prevails && e->possibly_call_in_translation_unit_p ())\n+  if (prevails\n+      && (e->possibly_call_in_translation_unit_p ()\n+\t  /* Also stream in jump functions to builtins in hope that they\n+\t     will get fnspecs.  */\n+\t  || fndecl_built_in_p (e->callee->decl, BUILT_IN_NORMAL)))\n     {\n       class ipa_edge_args *args = IPA_EDGE_REF_GET_CREATE (e);\n       vec_safe_grow_cleared (args->jump_functions, count, true);"}, {"sha": "5ac2c65aff49ee08b7506f0ba087b89f916123e3", "filename": "gcc/testsuite/gcc.dg/ipa/modref-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cef01c32817b3d08af2cadcdb0e23c72ceed426/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodref-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cef01c32817b3d08af2cadcdb0e23c72ceed426/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodref-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodref-2.c?ref=6cef01c32817b3d08af2cadcdb0e23c72ceed426", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-O2 -fdump-ipa-modref\"  } */\n+/* { dg-do compile } */\n+void\n+test (int *a, int size)\n+{\n+ __builtin_memset (a, 0, 321);\n+}\n+void\n+test2 (double x, double *y)\n+{\n+ __builtin_modf (x,y);\n+}\n+/* 321*8 */\n+/* { dg-final { scan-ipa-dump \"Parm 0 param offset:0 offset:0 size:-1 max_size:2568\" \"modref\"  } } */\n+/* { dg-final { scan-ipa-dump \"Parm 1 param offset:0 offset:0 size:-1 max_size:64\" \"modref\"  } } */"}, {"sha": "cf84ed95e775568a1aec480eec3990e65305e087", "filename": "gcc/testsuite/gcc.dg/lto/modref-2_0.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cef01c32817b3d08af2cadcdb0e23c72ceed426/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fmodref-2_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cef01c32817b3d08af2cadcdb0e23c72ceed426/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fmodref-2_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fmodref-2_0.c?ref=6cef01c32817b3d08af2cadcdb0e23c72ceed426", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-lto-do run } */\n+/* { dg-lto-options {\"-O2 -flto-partition=max -flto -fno-ipa-sra\"}  } */\n+__attribute__ ((noinline))\n+void\n+test (char *a)\n+{\n+ __builtin_memset (a,0,321);\n+}\n+__attribute__ ((noinline))\n+void\n+test2 (double *x, double *y)\n+{\n+ __builtin_modf (*x,y);\n+}\n+int\n+main (void)\n+{\n+  char array[321];\n+  double x=1, y=2;\n+  char arrayz[321];\n+  arrayz[0]=1;\n+  test (array);\n+  test2 (&x,&y);\n+  if (!__builtin_constant_p (x==2) || !__builtin_constant_p (arrayz[0]==1))\n+    __builtin_abort ();\n+  return 0;\n+}"}]}