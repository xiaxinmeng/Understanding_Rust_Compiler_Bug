{"sha": "4b671e64d4d84a4090ce484e638c6032ed5ba17a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI2NzFlNjRkNGQ4NGE0MDkwY2U0ODRlNjM4YzYwMzJlZDViYTE3YQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2012-10-23T16:29:03Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-10-23T16:29:03Z"}, "message": "tree-ssa-operands.h (struct def_optype_d, [...]): Remove.\n\n\t* tree-ssa-operands.h (struct def_optype_d, def_optype_p): Remove.\n\t(ssa_operands.free_defs): Remove.\n\t(DEF_OP_PTR, DEF_OP): Remove.\n\t(struct ssa_operand_iterator_d): Remove 'defs', add 'flags'\n\tmembers, rename 'phi_stmt' to 'stmt', 'phi_i' to 'i' and 'num_phi'\n\tto 'numops'.\n\t* gimple.h (gimple_statement_with_ops.def_ops): Remove.\n\t(gimple_def_ops, gimple_set_def_ops): Remove.\n\t(gimple_vdef_op): Don't take const gimple, adjust.\n\t(gimple_asm_input_op, gimple_asm_input_op_ptr,\n\tgimple_asm_set_input_op, gimple_asm_output_op,\n\tgimple_asm_output_op_ptr, gimple_asm_set_output_op): Adjust asserts,\n\tand rewrite to move def operands to front.\n\t(gimple_asm_clobber_op, gimple_asm_set_clobber_op,\n\tgimple_asm_label_op, gimple_asm_set_label_op): Correct asserts.\n\t* tree-ssa-operands.c (build_defs): Remove.\n\t(init_ssa_operands): Don't initialize it.\n\t(fini_ssa_operands): Don't free it.\n\t(cleanup_build_arrays): Don't truncate it.\n\t(finalize_ssa_stmt_operands): Don't assert on it.\n\t(alloc_def, add_def_op, append_def): Remove.\n\t(finalize_ssa_defs): Remove building of def_ops list.\n\t(finalize_ssa_uses): Don't mark for SSA renaming here, ...\n\t(add_stmt_operand): ... but here, don't call append_def.\n\t(get_indirect_ref_operands): Remove recurse_on_base argument.\n\t(get_expr_operands): Adjust call to get_indirect_ref_operands.\n\t(verify_ssa_operands): Don't check def operands.\n\t(free_stmt_operands): Don't free def operands.\n\t* gimple.c (gimple_copy): Don't clear def operands.\n\t* tree-flow-inline.h (op_iter_next_use): Adjust to explicitely\n\thandle def operand.\n\t(op_iter_next_tree, op_iter_next_def): Ditto.\n\t(clear_and_done_ssa_iter): Clear new fields.\n\t(op_iter_init): Adjust to setup new iterator structure.\n\t(op_iter_init_phiuse): Adjust.\n\nFrom-SVN: r192721", "tree": {"sha": "dfe78d2bb02f7a92114b50acf3f8662a56351922", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfe78d2bb02f7a92114b50acf3f8662a56351922"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b671e64d4d84a4090ce484e638c6032ed5ba17a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b671e64d4d84a4090ce484e638c6032ed5ba17a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b671e64d4d84a4090ce484e638c6032ed5ba17a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b671e64d4d84a4090ce484e638c6032ed5ba17a/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85fc19ad7e950cd015f02b0a4ae8c756727f1398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85fc19ad7e950cd015f02b0a4ae8c756727f1398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85fc19ad7e950cd015f02b0a4ae8c756727f1398"}], "stats": {"total": 415, "additions": 165, "deletions": 250}, "files": [{"sha": "0a9707a76a7026f0059cc736e70966d6b9407ea6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b671e64d4d84a4090ce484e638c6032ed5ba17a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b671e64d4d84a4090ce484e638c6032ed5ba17a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b671e64d4d84a4090ce484e638c6032ed5ba17a", "patch": "@@ -1,3 +1,41 @@\n+2012-10-23  Michael Matz  <matz@suse.de>\n+\n+\t* tree-ssa-operands.h (struct def_optype_d, def_optype_p): Remove.\n+\t(ssa_operands.free_defs): Remove.\n+\t(DEF_OP_PTR, DEF_OP): Remove.\n+\t(struct ssa_operand_iterator_d): Remove 'defs', add 'flags'\n+\tmembers, rename 'phi_stmt' to 'stmt', 'phi_i' to 'i' and 'num_phi'\n+\tto 'numops'.\n+\t* gimple.h (gimple_statement_with_ops.def_ops): Remove.\n+\t(gimple_def_ops, gimple_set_def_ops): Remove.\n+\t(gimple_vdef_op): Don't take const gimple, adjust.\n+\t(gimple_asm_input_op, gimple_asm_input_op_ptr,\n+\tgimple_asm_set_input_op, gimple_asm_output_op,\n+\tgimple_asm_output_op_ptr, gimple_asm_set_output_op): Adjust asserts,\n+\tand rewrite to move def operands to front.\n+\t(gimple_asm_clobber_op, gimple_asm_set_clobber_op,\n+\tgimple_asm_label_op, gimple_asm_set_label_op): Correct asserts.\n+\t* tree-ssa-operands.c (build_defs): Remove.\n+\t(init_ssa_operands): Don't initialize it.\n+\t(fini_ssa_operands): Don't free it.\n+\t(cleanup_build_arrays): Don't truncate it.\n+\t(finalize_ssa_stmt_operands): Don't assert on it.\n+\t(alloc_def, add_def_op, append_def): Remove.\n+\t(finalize_ssa_defs): Remove building of def_ops list.\n+\t(finalize_ssa_uses): Don't mark for SSA renaming here, ...\n+\t(add_stmt_operand): ... but here, don't call append_def.\n+\t(get_indirect_ref_operands): Remove recurse_on_base argument.\n+\t(get_expr_operands): Adjust call to get_indirect_ref_operands.\n+\t(verify_ssa_operands): Don't check def operands.\n+\t(free_stmt_operands): Don't free def operands.\n+\t* gimple.c (gimple_copy): Don't clear def operands.\n+\t* tree-flow-inline.h (op_iter_next_use): Adjust to explicitely\n+\thandle def operand.\n+\t(op_iter_next_tree, op_iter_next_def): Ditto.\n+\t(clear_and_done_ssa_iter): Clear new fields.\n+\t(op_iter_init): Adjust to setup new iterator structure.\n+\t(op_iter_init_phiuse): Adjust.\n+\n 2012-10-23  Greta Yorsh  <Greta.Yorsh@arm.com>\n \n \t* config/arm/arm.c (offset_ok_for_ldrd_strd): Return false for"}, {"sha": "a5c16da29caf7814fa1a5420c297467e805218af", "filename": "gcc/gimple.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b671e64d4d84a4090ce484e638c6032ed5ba17a/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b671e64d4d84a4090ce484e638c6032ed5ba17a/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=4b671e64d4d84a4090ce484e638c6032ed5ba17a", "patch": "@@ -2345,7 +2345,6 @@ gimple_copy (gimple stmt)\n   /* Clear out SSA operand vectors on COPY.  */\n   if (gimple_has_ops (stmt))\n     {\n-      gimple_set_def_ops (copy, NULL);\n       gimple_set_use_ops (copy, NULL);\n \n       /* SSA operands need to be updated.  */"}, {"sha": "bca1e1492270dcdac2305acee67124415b0d5243", "filename": "gcc/gimple.h", "status": "modified", "additions": 37, "deletions": 62, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b671e64d4d84a4090ce484e638c6032ed5ba17a/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b671e64d4d84a4090ce484e638c6032ed5ba17a/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=4b671e64d4d84a4090ce484e638c6032ed5ba17a", "patch": "@@ -220,12 +220,11 @@ struct GTY(()) gimple_statement_with_ops_base\n   /* [ WORD 1-6 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* [ WORD 7-8 ]\n+  /* [ WORD 7 ]\n      SSA operand vectors.  NOTE: It should be possible to\n      amalgamate these vectors with the operand vector OP.  However,\n      the SSA operand vectors are organized differently and contain\n      more information (like immediate use chaining).  */\n-  struct def_optype_d GTY((skip (\"\"))) *def_ops;\n   struct use_optype_d GTY((skip (\"\"))) *use_ops;\n };\n \n@@ -234,10 +233,10 @@ struct GTY(()) gimple_statement_with_ops_base\n \n struct GTY(()) gimple_statement_with_ops\n {\n-  /* [ WORD 1-8 ]  */\n+  /* [ WORD 1-7 ]  */\n   struct gimple_statement_with_ops_base opbase;\n \n-  /* [ WORD 9 ]\n+  /* [ WORD 8 ]\n      Operand vector.  NOTE!  This must always be the last field\n      of this structure.  In particular, this means that this\n      structure cannot be embedded inside another one.  */\n@@ -249,10 +248,10 @@ struct GTY(()) gimple_statement_with_ops\n \n struct GTY(()) gimple_statement_with_memory_ops_base\n {\n-  /* [ WORD 1-8 ]  */\n+  /* [ WORD 1-7 ]  */\n   struct gimple_statement_with_ops_base opbase;\n \n-  /* [ WORD 9-10 ]\n+  /* [ WORD 8-9 ]\n      Virtual operands for this statement.  The GC will pick them\n      up via the ssa_names array.  */\n   tree GTY((skip (\"\"))) vdef;\n@@ -264,10 +263,10 @@ struct GTY(()) gimple_statement_with_memory_ops_base\n \n struct GTY(()) gimple_statement_with_memory_ops\n {\n-  /* [ WORD 1-10 ]  */\n+  /* [ WORD 1-9 ]  */\n   struct gimple_statement_with_memory_ops_base membase;\n \n-  /* [ WORD 11 ]\n+  /* [ WORD 10 ]\n      Operand vector.  NOTE!  This must always be the last field\n      of this structure.  In particular, this means that this\n      structure cannot be embedded inside another one.  */\n@@ -279,20 +278,20 @@ struct GTY(()) gimple_statement_with_memory_ops\n \n struct GTY(()) gimple_statement_call\n {\n-  /* [ WORD 1-10 ]  */\n+  /* [ WORD 1-9 ]  */\n   struct gimple_statement_with_memory_ops_base membase;\n \n-  /* [ WORD 11-14 ]  */\n+  /* [ WORD 10-13 ]  */\n   struct pt_solution call_used;\n   struct pt_solution call_clobbered;\n \n-  /* [ WORD 15 ]  */\n+  /* [ WORD 14 ]  */\n   union GTY ((desc (\"%1.membase.opbase.gsbase.subcode & GF_CALL_INTERNAL\"))) {\n     tree GTY ((tag (\"0\"))) fntype;\n     enum internal_fn GTY ((tag (\"GF_CALL_INTERNAL\"))) internal_fn;\n   } u;\n \n-  /* [ WORD 16 ]\n+  /* [ WORD 15 ]\n      Operand vector.  NOTE!  This must always be the last field\n      of this structure.  In particular, this means that this\n      structure cannot be embedded inside another one.  */\n@@ -464,21 +463,21 @@ struct GTY(()) gimple_statement_wce {\n \n struct GTY(()) gimple_statement_asm\n {\n-  /* [ WORD 1-10 ]  */\n+  /* [ WORD 1-9 ]  */\n   struct gimple_statement_with_memory_ops_base membase;\n \n-  /* [ WORD 11 ]\n+  /* [ WORD 10 ]\n      __asm__ statement.  */\n   const char *string;\n \n-  /* [ WORD 12 ]\n+  /* [ WORD 11 ]\n        Number of inputs, outputs, clobbers, labels.  */\n   unsigned char ni;\n   unsigned char no;\n   unsigned char nc;\n   unsigned char nl;\n \n-  /* [ WORD 13 ]\n+  /* [ WORD 12 ]\n      Operand vector.  NOTE!  This must always be the last field\n      of this structure.  In particular, this means that this\n      structure cannot be embedded inside another one.  */\n@@ -669,13 +668,13 @@ struct GTY(()) gimple_statement_omp_atomic_store {\n \n struct GTY(()) gimple_statement_transaction\n {\n-  /* [ WORD 1-10 ]  */\n+  /* [ WORD 1-9 ]  */\n   struct gimple_statement_with_memory_ops_base gsbase;\n \n-  /* [ WORD 11 ] */\n+  /* [ WORD 10 ] */\n   gimple_seq body;\n \n-  /* [ WORD 12 ] */\n+  /* [ WORD 11 ] */\n   tree label;\n };\n \n@@ -1372,27 +1371,6 @@ gimple_has_mem_ops (const_gimple g)\n }\n \n \n-/* Return the set of DEF operands for statement G.  */\n-\n-static inline struct def_optype_d *\n-gimple_def_ops (const_gimple g)\n-{\n-  if (!gimple_has_ops (g))\n-    return NULL;\n-  return g->gsops.opbase.def_ops;\n-}\n-\n-\n-/* Set DEF to be the set of DEF operands for statement G.  */\n-\n-static inline void\n-gimple_set_def_ops (gimple g, struct def_optype_d *def)\n-{\n-  gcc_gimple_checking_assert (gimple_has_ops (g));\n-  g->gsops.opbase.def_ops = def;\n-}\n-\n-\n /* Return the set of USE operands for statement G.  */\n \n static inline struct use_optype_d *\n@@ -1432,15 +1410,12 @@ gimple_vuse_op (const_gimple g)\n /* Return the set of VDEF operand for statement G.  */\n \n static inline def_operand_p\n-gimple_vdef_op (const_gimple g)\n+gimple_vdef_op (gimple g)\n {\n-  struct def_optype_d *ops;\n   if (!gimple_has_mem_ops (g))\n     return NULL_DEF_OPERAND_P;\n-  ops = g->gsops.opbase.def_ops;\n-  if (ops\n-      && DEF_OP_PTR (ops) == &g->gsmembase.vdef)\n-    return DEF_OP_PTR (ops);\n+  if (g->gsmembase.vdef)\n+    return &g->gsmembase.vdef;\n   return NULL_DEF_OPERAND_P;\n }\n \n@@ -2941,8 +2916,8 @@ static inline tree\n gimple_asm_input_op (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_gimple_checking_assert (index <= gs->gimple_asm.ni);\n-  return gimple_op (gs, index);\n+  gcc_gimple_checking_assert (index < gs->gimple_asm.ni);\n+  return gimple_op (gs, index + gs->gimple_asm.no);\n }\n \n /* Return a pointer to input operand INDEX of GIMPLE_ASM GS.  */\n@@ -2951,8 +2926,8 @@ static inline tree *\n gimple_asm_input_op_ptr (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_gimple_checking_assert (index <= gs->gimple_asm.ni);\n-  return gimple_op_ptr (gs, index);\n+  gcc_gimple_checking_assert (index < gs->gimple_asm.ni);\n+  return gimple_op_ptr (gs, index + gs->gimple_asm.no);\n }\n \n \n@@ -2962,9 +2937,9 @@ static inline void\n gimple_asm_set_input_op (gimple gs, unsigned index, tree in_op)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_gimple_checking_assert (index <= gs->gimple_asm.ni\n+  gcc_gimple_checking_assert (index < gs->gimple_asm.ni\n \t\t\t      && TREE_CODE (in_op) == TREE_LIST);\n-  gimple_set_op (gs, index, in_op);\n+  gimple_set_op (gs, index + gs->gimple_asm.no, in_op);\n }\n \n \n@@ -2974,8 +2949,8 @@ static inline tree\n gimple_asm_output_op (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_gimple_checking_assert (index <= gs->gimple_asm.no);\n-  return gimple_op (gs, index + gs->gimple_asm.ni);\n+  gcc_gimple_checking_assert (index < gs->gimple_asm.no);\n+  return gimple_op (gs, index);\n }\n \n /* Return a pointer to output operand INDEX of GIMPLE_ASM GS.  */\n@@ -2984,8 +2959,8 @@ static inline tree *\n gimple_asm_output_op_ptr (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_gimple_checking_assert (index <= gs->gimple_asm.no);\n-  return gimple_op_ptr (gs, index + gs->gimple_asm.ni);\n+  gcc_gimple_checking_assert (index < gs->gimple_asm.no);\n+  return gimple_op_ptr (gs, index);\n }\n \n \n@@ -2995,9 +2970,9 @@ static inline void\n gimple_asm_set_output_op (gimple gs, unsigned index, tree out_op)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_gimple_checking_assert (index <= gs->gimple_asm.no\n+  gcc_gimple_checking_assert (index < gs->gimple_asm.no\n \t\t\t      && TREE_CODE (out_op) == TREE_LIST);\n-  gimple_set_op (gs, index + gs->gimple_asm.ni, out_op);\n+  gimple_set_op (gs, index, out_op);\n }\n \n \n@@ -3007,7 +2982,7 @@ static inline tree\n gimple_asm_clobber_op (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_gimple_checking_assert (index <= gs->gimple_asm.nc);\n+  gcc_gimple_checking_assert (index < gs->gimple_asm.nc);\n   return gimple_op (gs, index + gs->gimple_asm.ni + gs->gimple_asm.no);\n }\n \n@@ -3018,7 +2993,7 @@ static inline void\n gimple_asm_set_clobber_op (gimple gs, unsigned index, tree clobber_op)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_gimple_checking_assert (index <= gs->gimple_asm.nc\n+  gcc_gimple_checking_assert (index < gs->gimple_asm.nc\n \t\t\t      && TREE_CODE (clobber_op) == TREE_LIST);\n   gimple_set_op (gs, index + gs->gimple_asm.ni + gs->gimple_asm.no, clobber_op);\n }\n@@ -3029,7 +3004,7 @@ static inline tree\n gimple_asm_label_op (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_gimple_checking_assert (index <= gs->gimple_asm.nl);\n+  gcc_gimple_checking_assert (index < gs->gimple_asm.nl);\n   return gimple_op (gs, index + gs->gimple_asm.ni + gs->gimple_asm.nc);\n }\n \n@@ -3039,7 +3014,7 @@ static inline void\n gimple_asm_set_label_op (gimple gs, unsigned index, tree label_op)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_gimple_checking_assert (index <= gs->gimple_asm.nl\n+  gcc_gimple_checking_assert (index < gs->gimple_asm.nl\n \t\t\t      && TREE_CODE (label_op) == TREE_LIST);\n   gimple_set_op (gs, index + gs->gimple_asm.ni + gs->gimple_asm.nc, label_op);\n }"}, {"sha": "64177ce87d7e02ab7847f06e9e91273f888d739c", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 75, "deletions": 26, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b671e64d4d84a4090ce484e638c6032ed5ba17a/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b671e64d4d84a4090ce484e638c6032ed5ba17a/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=4b671e64d4d84a4090ce484e638c6032ed5ba17a", "patch": "@@ -580,9 +580,9 @@ op_iter_next_use (ssa_op_iter *ptr)\n       ptr->uses = ptr->uses->next;\n       return use_p;\n     }\n-  if (ptr->phi_i < ptr->num_phi)\n+  if (ptr->i < ptr->numops)\n     {\n-      return PHI_ARG_DEF_PTR (ptr->phi_stmt, (ptr->phi_i)++);\n+      return PHI_ARG_DEF_PTR (ptr->stmt, (ptr->i)++);\n     }\n   ptr->done = true;\n   return NULL_USE_OPERAND_P;\n@@ -592,14 +592,33 @@ op_iter_next_use (ssa_op_iter *ptr)\n static inline def_operand_p\n op_iter_next_def (ssa_op_iter *ptr)\n {\n-  def_operand_p def_p;\n   gcc_checking_assert (ptr->iter_type == ssa_op_iter_def);\n-  if (ptr->defs)\n+  if (ptr->flags & SSA_OP_VDEF)\n     {\n-      def_p = DEF_OP_PTR (ptr->defs);\n-      ptr->defs = ptr->defs->next;\n-      return def_p;\n+      tree *p;\n+      ptr->flags &= ~SSA_OP_VDEF;\n+      p = gimple_vdef_ptr (ptr->stmt);\n+      if (p && *p)\n+\treturn p;\n     }\n+  if (ptr->flags & SSA_OP_DEF)\n+    {\n+      while (ptr->i < ptr->numops)\n+\t{\n+\t  tree *val = gimple_op_ptr (ptr->stmt, ptr->i);\n+\t  ptr->i++;\n+\t  if (*val)\n+\t    {\n+\t      if (TREE_CODE (*val) == TREE_LIST)\n+\t\tval = &TREE_VALUE (*val);\n+\t      if (TREE_CODE (*val) == SSA_NAME\n+\t\t  || is_gimple_reg (*val))\n+\t\treturn val;\n+\t    }\n+\t}\n+      ptr->flags &= ~SSA_OP_DEF;\n+    }\n+\n   ptr->done = true;\n   return NULL_DEF_OPERAND_P;\n }\n@@ -616,16 +635,32 @@ op_iter_next_tree (ssa_op_iter *ptr)\n       ptr->uses = ptr->uses->next;\n       return val;\n     }\n-  if (ptr->defs)\n+  if (ptr->flags & SSA_OP_VDEF)\n     {\n-      val = DEF_OP (ptr->defs);\n-      ptr->defs = ptr->defs->next;\n-      return val;\n+      ptr->flags &= ~SSA_OP_VDEF;\n+      if ((val = gimple_vdef (ptr->stmt)))\n+\treturn val;\n+    }\n+  if (ptr->flags & SSA_OP_DEF)\n+    {\n+      while (ptr->i < ptr->numops)\n+\t{\n+\t  val = gimple_op (ptr->stmt, ptr->i);\n+\t  ptr->i++;\n+\t  if (val)\n+\t    {\n+\t      if (TREE_CODE (val) == TREE_LIST)\n+\t\tval = TREE_VALUE (val);\n+\t      if (TREE_CODE (val) == SSA_NAME\n+\t\t  || is_gimple_reg (val))\n+\t\treturn val;\n+\t    }\n+\t}\n+      ptr->flags &= ~SSA_OP_DEF;\n     }\n \n   ptr->done = true;\n   return NULL_TREE;\n-\n }\n \n \n@@ -636,13 +671,13 @@ op_iter_next_tree (ssa_op_iter *ptr)\n static inline void\n clear_and_done_ssa_iter (ssa_op_iter *ptr)\n {\n-  ptr->defs = NULL;\n+  ptr->i = 0;\n+  ptr->numops = 0;\n   ptr->uses = NULL;\n   ptr->iter_type = ssa_op_iter_none;\n-  ptr->phi_i = 0;\n-  ptr->num_phi = 0;\n-  ptr->phi_stmt = NULL;\n+  ptr->stmt = NULL;\n   ptr->done = true;\n+  ptr->flags = 0;\n }\n \n /* Initialize the iterator PTR to the virtual defs in STMT.  */\n@@ -655,21 +690,34 @@ op_iter_init (ssa_op_iter *ptr, gimple stmt, int flags)\n   gcc_checking_assert (gimple_code (stmt) != GIMPLE_PHI\n \t\t       && (!(flags & SSA_OP_VDEF) || (flags & SSA_OP_DEF))\n \t\t       && (!(flags & SSA_OP_VUSE) || (flags & SSA_OP_USE)));\n-  ptr->defs = (flags & (SSA_OP_DEF|SSA_OP_VDEF)) ? gimple_def_ops (stmt) : NULL;\n-  if (!(flags & SSA_OP_VDEF)\n-      && ptr->defs\n-      && gimple_vdef (stmt) != NULL_TREE)\n-    ptr->defs = ptr->defs->next;\n+  ptr->numops = 0;\n+  if (flags & (SSA_OP_DEF | SSA_OP_VDEF))\n+    {\n+      switch (gimple_code (stmt))\n+\t{\n+\t  case GIMPLE_ASSIGN:\n+\t  case GIMPLE_CALL:\n+\t    ptr->numops = 1;\n+\t    break;\n+\t  case GIMPLE_ASM:\n+\t    ptr->numops = gimple_asm_noutputs (stmt);\n+\t    break;\n+\t  default:\n+\t    ptr->numops = 0;\n+\t    flags &= ~(SSA_OP_DEF | SSA_OP_VDEF);\n+\t    break;\n+\t}\n+    }\n   ptr->uses = (flags & (SSA_OP_USE|SSA_OP_VUSE)) ? gimple_use_ops (stmt) : NULL;\n   if (!(flags & SSA_OP_VUSE)\n       && ptr->uses\n       && gimple_vuse (stmt) != NULL_TREE)\n     ptr->uses = ptr->uses->next;\n   ptr->done = false;\n+  ptr->i = 0;\n \n-  ptr->phi_i = 0;\n-  ptr->num_phi = 0;\n-  ptr->phi_stmt = NULL;\n+  ptr->stmt = stmt;\n+  ptr->flags = flags;\n }\n \n /* Initialize iterator PTR to the use operands in STMT based on FLAGS. Return\n@@ -839,9 +887,10 @@ op_iter_init_phiuse (ssa_op_iter *ptr, gimple phi, int flags)\n       return NULL_USE_OPERAND_P;\n     }\n \n-  ptr->phi_stmt = phi;\n-  ptr->num_phi = gimple_phi_num_args (phi);\n+  ptr->stmt = phi;\n+  ptr->numops = gimple_phi_num_args (phi);\n   ptr->iter_type = ssa_op_iter_use;\n+  ptr->flags = flags;\n   return op_iter_next_use (ptr);\n }\n "}, {"sha": "ef4dba56b1b0a2f5230354530732a78b91ea399b", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 10, "deletions": 144, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b671e64d4d84a4090ce484e638c6032ed5ba17a/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b671e64d4d84a4090ce484e638c6032ed5ba17a/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=4b671e64d4d84a4090ce484e638c6032ed5ba17a", "patch": "@@ -106,9 +106,6 @@ along with GCC; see the file COPYING3.  If not see\n /* Operand is in a place where opf_non_addressable does not apply.  */\n #define opf_not_non_addressable (1 << 4)\n \n-/* Array for building all the def operands.  */\n-static VEC(tree,heap) *build_defs;\n-\n /* Array for building all the use operands.  */\n static VEC(tree,heap) *build_uses;\n \n@@ -185,7 +182,6 @@ init_ssa_operands (struct function *fn)\n {\n   if (!n_initialized++)\n     {\n-      build_defs = VEC_alloc (tree, heap, 5);\n       build_uses = VEC_alloc (tree, heap, 10);\n       build_vuse = NULL_TREE;\n       build_vdef = NULL_TREE;\n@@ -210,13 +206,11 @@ fini_ssa_operands (void)\n \n   if (!--n_initialized)\n     {\n-      VEC_free (tree, heap, build_defs);\n       VEC_free (tree, heap, build_uses);\n       build_vdef = NULL_TREE;\n       build_vuse = NULL_TREE;\n     }\n \n-  gimple_ssa_operands (cfun)->free_defs = NULL;\n   gimple_ssa_operands (cfun)->free_uses = NULL;\n \n   while ((ptr = gimple_ssa_operands (cfun)->operand_memory) != NULL)\n@@ -242,8 +236,7 @@ ssa_operand_alloc (unsigned size)\n {\n   char *ptr;\n \n-  gcc_assert (size == sizeof (struct use_optype_d)\n-\t      || size == sizeof (struct def_optype_d));\n+  gcc_assert (size == sizeof (struct use_optype_d));\n \n   if (gimple_ssa_operands (cfun)->operand_memory_index + size\n       >= gimple_ssa_operands (cfun)->ssa_operand_mem_size)\n@@ -282,25 +275,6 @@ ssa_operand_alloc (unsigned size)\n }\n \n \n-/* Allocate a DEF operand.  */\n-\n-static inline struct def_optype_d *\n-alloc_def (void)\n-{\n-  struct def_optype_d *ret;\n-  if (gimple_ssa_operands (cfun)->free_defs)\n-    {\n-      ret = gimple_ssa_operands (cfun)->free_defs;\n-      gimple_ssa_operands (cfun)->free_defs\n-\t= gimple_ssa_operands (cfun)->free_defs->next;\n-    }\n-  else\n-    ret = (struct def_optype_d *)\n-\t  ssa_operand_alloc (sizeof (struct def_optype_d));\n-  return ret;\n-}\n-\n-\n /* Allocate a USE operand.  */\n \n static inline struct use_optype_d *\n@@ -320,21 +294,6 @@ alloc_use (void)\n }\n \n \n-/* Adds OP to the list of defs after LAST.  */\n-\n-static inline def_optype_p\n-add_def_op (tree *op, def_optype_p last)\n-{\n-  def_optype_p new_def;\n-\n-  new_def = alloc_def ();\n-  DEF_OP_PTR (new_def) = op;\n-  last->next = new_def;\n-  new_def->next = NULL;\n-  return new_def;\n-}\n-\n-\n /* Adds OP to the list of uses of statement STMT after LAST.  */\n \n static inline use_optype_p\n@@ -358,14 +317,6 @@ add_use_op (gimple stmt, tree *op, use_optype_p last)\n static inline void\n finalize_ssa_defs (gimple stmt)\n {\n-  unsigned new_i;\n-  struct def_optype_d new_list;\n-  def_optype_p old_ops, last;\n-  unsigned int num = VEC_length (tree, build_defs);\n-\n-  /* There should only be a single real definition per assignment.  */\n-  gcc_assert ((stmt && gimple_code (stmt) != GIMPLE_ASSIGN) || num <= 1);\n-\n   /* Pre-pend the vdef we may have built.  */\n   if (build_vdef != NULL_TREE)\n     {\n@@ -375,17 +326,8 @@ finalize_ssa_defs (gimple stmt)\n \toldvdef = SSA_NAME_VAR (oldvdef);\n       if (oldvdef != build_vdef)\n \tgimple_set_vdef (stmt, build_vdef);\n-      VEC_safe_insert (tree, heap, build_defs, 0, (tree)gimple_vdef_ptr (stmt));\n-      ++num;\n     }\n \n-  new_list.next = NULL;\n-  last = &new_list;\n-\n-  old_ops = gimple_def_ops (stmt);\n-\n-  new_i = 0;\n-\n   /* Clear and unlink a no longer necessary VDEF.  */\n   if (build_vdef == NULL_TREE\n       && gimple_vdef (stmt) != NULL_TREE)\n@@ -405,30 +347,6 @@ finalize_ssa_defs (gimple stmt)\n       cfun->gimple_df->rename_vops = 1;\n       cfun->gimple_df->ssa_renaming_needed = 1;\n     }\n-\n-  /* Check for the common case of 1 def that hasn't changed.  */\n-  if (old_ops && old_ops->next == NULL && num == 1\n-      && (tree *) VEC_index (tree, build_defs, 0) == DEF_OP_PTR (old_ops))\n-    return;\n-\n-  /* If there is anything in the old list, free it.  */\n-  if (old_ops)\n-    {\n-      old_ops->next = gimple_ssa_operands (cfun)->free_defs;\n-      gimple_ssa_operands (cfun)->free_defs = old_ops;\n-    }\n-\n-  /* If there is anything remaining in the build_defs list, simply emit it.  */\n-  for ( ; new_i < num; new_i++)\n-    {\n-      tree *op = (tree *) VEC_index (tree, build_defs, new_i);\n-      if (DECL_P (*op))\n-\tcfun->gimple_df->ssa_renaming_needed = 1;\n-      last = add_def_op (op, last);\n-    }\n-\n-  /* Now set the stmt's operands.  */\n-  gimple_set_def_ops (stmt, new_list.next);\n }\n \n \n@@ -488,8 +406,6 @@ finalize_ssa_uses (gimple stmt)\n   for (new_i = 0; new_i < VEC_length (tree, build_uses); new_i++)\n     {\n       tree *op = (tree *) VEC_index (tree, build_uses, new_i);\n-      if (DECL_P (*op))\n-\tcfun->gimple_df->ssa_renaming_needed = 1;\n       last = add_use_op (stmt, op, last);\n     }\n \n@@ -506,7 +422,6 @@ cleanup_build_arrays (void)\n {\n   build_vdef = NULL_TREE;\n   build_vuse = NULL_TREE;\n-  VEC_truncate (tree, build_defs, 0);\n   VEC_truncate (tree, build_uses, 0);\n }\n \n@@ -527,22 +442,12 @@ finalize_ssa_stmt_operands (gimple stmt)\n static inline void\n start_ssa_stmt_operands (void)\n {\n-  gcc_assert (VEC_length (tree, build_defs) == 0);\n   gcc_assert (VEC_length (tree, build_uses) == 0);\n   gcc_assert (build_vuse == NULL_TREE);\n   gcc_assert (build_vdef == NULL_TREE);\n }\n \n \n-/* Add DEF_P to the list of pointers to operands.  */\n-\n-static inline void\n-append_def (tree *def_p)\n-{\n-  VEC_safe_push (tree, heap, build_defs, (tree) def_p);\n-}\n-\n-\n /* Add USE_P to the list of pointers to operands.  */\n \n static inline void\n@@ -620,9 +525,11 @@ add_stmt_operand (tree *var_p, gimple stmt, int flags)\n     {\n       /* The variable is a GIMPLE register.  Add it to real operands.  */\n       if (flags & opf_def)\n-\tappend_def (var_p);\n+\t;\n       else\n \tappend_use (var_p);\n+      if (DECL_P (*var_p))\n+\tcfun->gimple_df->ssa_renaming_needed = 1;\n     }\n   else\n     {\n@@ -669,15 +576,10 @@ mark_address_taken (tree ref)\n    STMT is the statement being processed, EXPR is the MEM_REF\n       that got us here.\n \n-   FLAGS is as in get_expr_operands.\n-\n-   RECURSE_ON_BASE should be set to true if we want to continue\n-      calling get_expr_operands on the base pointer, and false if\n-      something else will do it for us.  */\n+   FLAGS is as in get_expr_operands.  */\n \n static void\n-get_indirect_ref_operands (gimple stmt, tree expr, int flags,\n-\t\t\t   bool recurse_on_base)\n+get_indirect_ref_operands (gimple stmt, tree expr, int flags)\n {\n   tree *pptr = &TREE_OPERAND (expr, 0);\n \n@@ -689,10 +591,9 @@ get_indirect_ref_operands (gimple stmt, tree expr, int flags,\n   add_virtual_operand (stmt, flags);\n \n   /* If requested, add a USE operand for the base pointer.  */\n-  if (recurse_on_base)\n-    get_expr_operands (stmt, pptr,\n-\t\t       opf_non_addressable | opf_use\n-\t\t       | (flags & (opf_no_vops|opf_not_non_addressable)));\n+  get_expr_operands (stmt, pptr,\n+\t\t     opf_non_addressable | opf_use\n+\t\t     | (flags & (opf_no_vops|opf_not_non_addressable)));\n }\n \n \n@@ -853,7 +754,7 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n       return;\n \n     case MEM_REF:\n-      get_indirect_ref_operands (stmt, expr, flags, true);\n+      get_indirect_ref_operands (stmt, expr, flags);\n       return;\n \n     case TARGET_MEM_REF:\n@@ -1126,31 +1027,6 @@ verify_ssa_operands (gimple stmt)\n \treturn true;\n       }\n \n-  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_DEF)\n-    {\n-      FOR_EACH_VEC_ELT (tree, build_defs, i, def)\n-\t{\n-\t  if (def_p == (tree *)def)\n-\t    {\n-\t      VEC_replace (tree, build_defs, i, NULL_TREE);\n-\t      break;\n-\t    }\n-\t}\n-      if (i == VEC_length (tree, build_defs))\n-\t{\n-\t  error (\"excess def operand for stmt\");\n-\t  debug_generic_expr (DEF_FROM_PTR (def_p));\n-\t  return true;\n-\t}\n-    }\n-  FOR_EACH_VEC_ELT (tree, build_defs, i, def)\n-    if (def != NULL_TREE)\n-      {\n-\terror (\"def operand missing for stmt\");\n-\tdebug_generic_expr (*(tree *)def);\n-\treturn true;\n-      }\n-\n   if (gimple_has_volatile_ops (stmt) != volatile_p)\n     {\n       error (\"stmt volatile flag not up-to-date\");\n@@ -1168,18 +1044,8 @@ verify_ssa_operands (gimple stmt)\n void\n free_stmt_operands (gimple stmt)\n {\n-  def_optype_p defs = gimple_def_ops (stmt), last_def;\n   use_optype_p uses = gimple_use_ops (stmt), last_use;\n \n-  if (defs)\n-    {\n-      for (last_def = defs; last_def->next; last_def = last_def->next)\n-\tcontinue;\n-      last_def->next = gimple_ssa_operands (cfun)->free_defs;\n-      gimple_ssa_operands (cfun)->free_defs = defs;\n-      gimple_set_def_ops (stmt, NULL);\n-    }\n-\n   if (uses)\n     {\n       for (last_use = uses; last_use->next; last_use = last_use->next)"}, {"sha": "ccacd280b72dfffca8791ed0fc3cffc174db6683", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b671e64d4d84a4090ce484e638c6032ed5ba17a/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b671e64d4d84a4090ce484e638c6032ed5ba17a/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=4b671e64d4d84a4090ce484e638c6032ed5ba17a", "patch": "@@ -34,14 +34,6 @@ typedef ssa_use_operand_t *use_operand_p;\n #define NULL_USE_OPERAND_P \t\t((use_operand_p)NULL)\n #define NULL_DEF_OPERAND_P \t\t((def_operand_p)NULL)\n \n-/* This represents the DEF operands of a stmt.  */\n-struct def_optype_d\n-{\n-  struct def_optype_d *next;\n-  tree *def_ptr;\n-};\n-typedef struct def_optype_d *def_optype_p;\n-\n /* This represents the USE operands of a stmt.  */\n struct use_optype_d\n {\n@@ -68,7 +60,6 @@ struct GTY(()) ssa_operands {\n \n    bool ops_active;\n \n-   struct def_optype_d * GTY ((skip (\"\"))) free_defs;\n    struct use_optype_d * GTY ((skip (\"\"))) free_uses;\n };\n \n@@ -82,9 +73,6 @@ struct GTY(()) ssa_operands {\n #define USE_OP_PTR(OP)\t\t(&((OP)->use_ptr))\n #define USE_OP(OP)\t\t(USE_FROM_PTR (USE_OP_PTR (OP)))\n \n-#define DEF_OP_PTR(OP)\t\t((OP)->def_ptr)\n-#define DEF_OP(OP)\t\t(DEF_FROM_PTR (DEF_OP_PTR (OP)))\n-\n #define PHI_RESULT_PTR(PHI)\tgimple_phi_result_ptr (PHI)\n #define PHI_RESULT(PHI)\t\tDEF_FROM_PTR (PHI_RESULT_PTR (PHI))\n #define SET_PHI_RESULT(PHI, V)\tSET_DEF (PHI_RESULT_PTR (PHI), (V))\n@@ -133,13 +121,13 @@ enum ssa_op_iter_type {\n \n typedef struct ssa_operand_iterator_d\n {\n-  bool done;\n   enum ssa_op_iter_type iter_type;\n-  def_optype_p defs;\n+  bool done;\n+  int flags;\n+  unsigned i;\n+  unsigned numops;\n   use_optype_p uses;\n-  int phi_i;\n-  int num_phi;\n-  gimple phi_stmt;\n+  gimple stmt;\n } ssa_op_iter;\n \n /* These flags are used to determine which operands are returned during"}]}