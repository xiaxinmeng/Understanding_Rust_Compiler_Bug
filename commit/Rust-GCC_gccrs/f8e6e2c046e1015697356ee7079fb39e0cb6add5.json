{"sha": "f8e6e2c046e1015697356ee7079fb39e0cb6add5", "node_id": "C_kwDOANBUbNoAKGY4ZTZlMmMwNDZlMTAxNTY5NzM1NmVlNzA3OWZiMzllMGNiNmFkZDU", "commit": {"author": {"name": "Immad Mir", "email": "mirimmad@outlook.com", "date": "2022-07-23T05:14:23Z"}, "committer": {"name": "Immad Mir", "email": "mirimmad@outlook.com", "date": "2022-07-23T05:16:17Z"}, "message": "Adding three new function attributes for static analysis of file descriptors\n\nThis patch adds three new function attributes to GCC that\nare used for static analysis of usage of file descriptors:\n\n1) __attribute__ ((fd_arg(N))): The attributes may be applied to a function that\ntakes an open file descriptor at refrenced argument N.\n\nIt indicates that the passed filedescriptor must not have been closed.\nTherefore, when the analyzer is enabled with -fanalyzer, the\nanalyzer may emit a -Wanalyzer-fd-use-after-close diagnostic\nif it detects a code path in which a function with this attribute is\ncalled with a closed file descriptor.\n\nThe attribute also indicates that the file descriptor must have been checked for\nvalidity before usage. Therefore, analyzer may emit\n-Wanalyzer-fd-use-without-check diagnostic if it detects a code path in\nwhich a function with this attribute is called with a file descriptor that has\nnot been checked for validity.\n\n2) __attribute__((fd_arg_read(N))): The attribute is identical to\nfd_arg, but with the additional requirement that it might read from\nthe file descriptor, and thus, the file descriptor must not have been opened\nas write-only.\n\nThe analyzer may emit a -Wanalyzer-access-mode-mismatch\ndiagnostic if it detects a code path in which a function with this\nattribute is called on a file descriptor opened with O_WRONLY.\n\n3) __attribute__((fd_arg_write(N))): The attribute is identical to fd_arg_read\nexcept that the analyzer may emit a -Wanalyzer-access-mode-mismatch diagnostic if\nit detects a code path in which a function with this attribute is called on a\nfile descriptor opened with O_RDONLY.\n\ngcc/analyzer/ChangeLog:\n\t* sm-fd.cc (fd_param_diagnostic): New diagnostic class.\n\t(fd_access_mode_mismatch): Change inheritance from fd_diagnostic\n\tto fd_param_diagnostic. Add new overloaded constructor.\n\t(fd_use_after_close): Likewise.\n\t(unchecked_use_of_fd): Likewise and also change name to fd_use_without_check.\n\t(double_close): Change name to fd_double_close.\n\t(enum access_directions): New.\n\t(fd_state_machine::on_stmt): Handle calls to function with the\n\tnew three function attributes.\n\t(fd_state_machine::check_for_fd_attrs): New.\n\t(fd_state_machine::on_open): Use the new overloaded constructors\n\tof diagnostic classes.\n\ngcc/c-family/ChangeLog:\n\t* c-attribs.cc: (c_common_attribute_table): add three new attributes\n\tnamely: fd_arg, fd_arg_read and fd_arg_write.\n\t(handle_fd_arg_attribute): New.\n\ngcc/ChangeLog:\n\t* doc/extend.texi: Add fd_arg, fd_arg_read and fd_arg_write under\n\t\"Common Function Attributes\" section.\n\t* doc/invoke.texi: Add docs to -Wanalyzer-fd-access-mode-mismatch,\n\t-Wanalyzer-use-after-close, -Wanalyzer-fd-use-without-check that these\n\twarnings may be emitted through usage of three function attributes used\n\tfor static analysis of file descriptors namely fd_arg, fd_arg_read and\n\tfd_arg_write.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/fd-5.c: New test.\n\t* gcc.dg/analyzer/fd-4.c: Remove quotes around 'read-only' and\n\t'write-only'.\n\t* c-c++-common/attr-fd.c: New test.\n\nSigned-off-by: Immad Mir <mirimmad17@gmail.com>", "tree": {"sha": "6c80cfd9cbd9b8e145ad3704dffbaabd8cb5abdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c80cfd9cbd9b8e145ad3704dffbaabd8cb5abdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8e6e2c046e1015697356ee7079fb39e0cb6add5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e6e2c046e1015697356ee7079fb39e0cb6add5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8e6e2c046e1015697356ee7079fb39e0cb6add5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e6e2c046e1015697356ee7079fb39e0cb6add5/comments", "author": null, "committer": null, "parents": [{"sha": "b563a8dd3fcdeaeab5e1b73cec70cd341d867940", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b563a8dd3fcdeaeab5e1b73cec70cd341d867940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b563a8dd3fcdeaeab5e1b73cec70cd341d867940"}], "stats": {"total": 503, "additions": 429, "deletions": 74}, "files": [{"sha": "c3dac48509e05404ba615db5090256f1e6ccb2c3", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 269, "deletions": 69, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=f8e6e2c046e1015697356ee7079fb39e0cb6add5", "patch": "@@ -39,10 +39,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/analyzer-selftests.h\"\r\n #include \"tristate.h\"\r\n #include \"selftest.h\"\r\n+#include \"stringpool.h\"\r\n+#include \"attribs.h\"\r\n #include \"analyzer/call-string.h\"\r\n #include \"analyzer/program-point.h\"\r\n #include \"analyzer/store.h\"\r\n #include \"analyzer/region-model.h\"\r\n+#include \"bitmap.h\"\r\n \r\n #if ENABLE_ANALYZER\r\n \r\n@@ -59,6 +62,13 @@ enum access_mode\n   WRITE_ONLY\r\n };\r\n \r\n+enum access_directions\r\n+{\r\n+  DIRS_READ_WRITE,\r\n+  DIRS_READ,\r\n+  DIRS_WRITE\r\n+};\r\n+\r\n class fd_state_machine : public state_machine\r\n {\r\n public:\r\n@@ -146,7 +156,7 @@ class fd_state_machine : public state_machine\n   void check_for_open_fd (sm_context *sm_ctxt, const supernode *node,\r\n                           const gimple *stmt, const gcall *call,\r\n                           const tree callee_fndecl,\r\n-                          enum access_direction access_fn) const;\r\n+                          enum access_directions access_fn) const;\r\n \r\n   void make_valid_transitions_on_condition (sm_context *sm_ctxt,\r\n                                             const supernode *node,\r\n@@ -156,6 +166,10 @@ class fd_state_machine : public state_machine\n                                               const supernode *node,\r\n                                               const gimple *stmt,\r\n                                               const svalue *lhs) const;\r\n+  void check_for_fd_attrs (sm_context *sm_ctxt, const supernode *node,\r\n+                           const gimple *stmt, const gcall *call,\r\n+                           const tree callee_fndecl, const char *attr_name,\r\n+                           access_directions fd_attr_access_dir) const;\r\n };\r\n \r\n /* Base diagnostic class relative to fd_state_machine. */\r\n@@ -220,6 +234,70 @@ class fd_diagnostic : public pending_diagnostic\n   tree m_arg;\r\n };\r\n \r\n+class fd_param_diagnostic : public fd_diagnostic\r\n+{\r\n+public:\r\n+  fd_param_diagnostic (const fd_state_machine &sm, tree arg, tree callee_fndecl,\r\n+                       const char *attr_name, int arg_idx)\r\n+      : fd_diagnostic (sm, arg), m_callee_fndecl (callee_fndecl),\r\n+        m_attr_name (attr_name), m_arg_idx (arg_idx)\r\n+  {\r\n+  }\r\n+\r\n+  fd_param_diagnostic (const fd_state_machine &sm, tree arg, tree callee_fndecl)\r\n+      : fd_diagnostic (sm, arg), m_callee_fndecl (callee_fndecl),\r\n+        m_attr_name (NULL), m_arg_idx (-1)\r\n+  {\r\n+  }\r\n+ \r\n+  bool\r\n+  subclass_equal_p (const pending_diagnostic &base_other) const override\r\n+  {\r\n+    const fd_param_diagnostic &sub_other\r\n+        = (const fd_param_diagnostic &)base_other;\r\n+    return (same_tree_p (m_arg, sub_other.m_arg)\r\n+            && same_tree_p (m_callee_fndecl, sub_other.m_callee_fndecl)\r\n+            && m_arg_idx == sub_other.m_arg_idx\r\n+            && ((m_attr_name)\r\n+                    ? (strcmp (m_attr_name, sub_other.m_attr_name) == 0)\r\n+                    : true));\r\n+  }\r\n+\r\n+  void\r\n+  inform_filedescriptor_attribute (access_directions fd_dir)\r\n+  {\r\n+\r\n+    if (m_attr_name)\r\n+      switch (fd_dir)\r\n+        {\r\n+        case DIRS_READ_WRITE:\r\n+          inform (DECL_SOURCE_LOCATION (m_callee_fndecl),\r\n+                  \"argument %d of %qD must be an open file descriptor, due to \"\r\n+                  \"%<__attribute__((%s(%d)))%>\",\r\n+                  m_arg_idx + 1, m_callee_fndecl, m_attr_name, m_arg_idx + 1);\r\n+          break;\r\n+        case DIRS_WRITE:\r\n+          inform (DECL_SOURCE_LOCATION (m_callee_fndecl),\r\n+                  \"argument %d of %qD must be a readable file descriptor, due \"\r\n+                  \"to %<__attribute__((%s(%d)))%>\",\r\n+                  m_arg_idx + 1, m_callee_fndecl, m_attr_name, m_arg_idx + 1);\r\n+          break;\r\n+        case DIRS_READ:\r\n+          inform (DECL_SOURCE_LOCATION (m_callee_fndecl),\r\n+                  \"argument %d of %qD must be a writable file descriptor, due \"\r\n+                  \"to %<__attribute__((%s(%d)))%>\",\r\n+                  m_arg_idx + 1, m_callee_fndecl, m_attr_name, m_arg_idx + 1);\r\n+          break;\r\n+        }\r\n+  }\r\n+\r\n+protected:\r\n+  tree m_callee_fndecl;\r\n+  const char *m_attr_name;\r\n+  /* ARG_IDX is 0-based. */\r\n+  int m_arg_idx;\r\n+};\r\n+\r\n class fd_leak : public fd_diagnostic\r\n {\r\n public:\r\n@@ -290,18 +368,26 @@ class fd_leak : public fd_diagnostic\n   diagnostic_event_id_t m_open_event;\r\n };\r\n \r\n-class fd_access_mode_mismatch : public fd_diagnostic\r\n+class fd_access_mode_mismatch : public fd_param_diagnostic\r\n {\r\n public:\r\n   fd_access_mode_mismatch (const fd_state_machine &sm, tree arg,\r\n-                           enum access_direction fd_dir,\r\n-                           const tree callee_fndecl)\r\n-      : fd_diagnostic (sm, arg), m_fd_dir (fd_dir),\r\n-        m_callee_fndecl (callee_fndecl)\r\n+                           enum access_directions fd_dir,\r\n+                           const tree callee_fndecl, const char *attr_name,\r\n+                           int arg_idx)\r\n+      : fd_param_diagnostic (sm, arg, callee_fndecl, attr_name, arg_idx),\r\n+        m_fd_dir (fd_dir)\r\n \r\n   {\r\n   }\r\n \r\n+  fd_access_mode_mismatch (const fd_state_machine &sm, tree arg,\r\n+                           enum access_directions fd_dir,\r\n+                           const tree callee_fndecl)\r\n+      : fd_param_diagnostic (sm, arg, callee_fndecl), m_fd_dir (fd_dir)\r\n+  {\r\n+  }\r\n+  \r\n   const char *\r\n   get_kind () const final override\r\n   {\r\n@@ -317,63 +403,58 @@ class fd_access_mode_mismatch : public fd_diagnostic\n   bool\r\n   emit (rich_location *rich_loc) final override\r\n   {\r\n+    bool warned;\r\n     switch (m_fd_dir)\r\n       {\r\n-      case DIR_READ:\r\n-        return warning_at (rich_loc, get_controlling_option (),\r\n-                           \"%qE on %<read-only%> file descriptor %qE\",\r\n+      case DIRS_READ:\r\n+        warned =  warning_at (rich_loc, get_controlling_option (),\r\n+                           \"%qE on read-only file descriptor %qE\",\r\n                            m_callee_fndecl, m_arg);\r\n-      case DIR_WRITE:\r\n-        return warning_at (rich_loc, get_controlling_option (),\r\n-                           \"%qE on %<write-only%> file descriptor %qE\",\r\n+        break;\r\n+      case DIRS_WRITE:\r\n+        warned = warning_at (rich_loc, get_controlling_option (),\r\n+                           \"%qE on write-only file descriptor %qE\",\r\n                            m_callee_fndecl, m_arg);\r\n+        break;\r\n       default:\r\n         gcc_unreachable ();\r\n       }\r\n-  }\r\n-\r\n-  bool\r\n-  subclass_equal_p (const pending_diagnostic &base_other) const override\r\n-  {\r\n-    const fd_access_mode_mismatch &sub_other\r\n-        = (const fd_access_mode_mismatch &)base_other;\r\n-    return (same_tree_p (m_arg, sub_other.m_arg)\r\n-            && m_callee_fndecl == sub_other.m_callee_fndecl\r\n-            && m_fd_dir == sub_other.m_fd_dir);\r\n+      if (warned)\r\n+        inform_filedescriptor_attribute (m_fd_dir);\r\n+      return warned;\r\n   }\r\n \r\n   label_text\r\n   describe_final_event (const evdesc::final_event &ev) final override\r\n   {\r\n     switch (m_fd_dir)\r\n       {\r\n-      case DIR_READ:\r\n-        return ev.formatted_print (\"%qE on %<read-only%> file descriptor %qE\",\r\n+      case DIRS_READ:\r\n+        return ev.formatted_print (\"%qE on read-only file descriptor %qE\",\r\n                                    m_callee_fndecl, m_arg);\r\n-      case DIR_WRITE:\r\n-        return ev.formatted_print (\"%qE on %<write-only%> file descriptor %qE\",\r\n+      case DIRS_WRITE:\r\n+        return ev.formatted_print (\"%qE on write-only file descriptor %qE\",\r\n                                    m_callee_fndecl, m_arg);\r\n       default:\r\n         gcc_unreachable ();\r\n       }\r\n   }\r\n \r\n private:\r\n-  enum access_direction m_fd_dir;\r\n-  const tree m_callee_fndecl;\r\n+  enum access_directions m_fd_dir;\r\n };\r\n \r\n-class double_close : public fd_diagnostic\r\n+class fd_double_close : public fd_diagnostic\r\n {\r\n public:\r\n-  double_close (const fd_state_machine &sm, tree arg) : fd_diagnostic (sm, arg)\r\n+  fd_double_close (const fd_state_machine &sm, tree arg) : fd_diagnostic (sm, arg)\r\n   {\r\n   }\r\n \r\n   const char *\r\n   get_kind () const final override\r\n   {\r\n-    return \"double_close\";\r\n+    return \"fd_double_close\";\r\n   }\r\n \r\n   int\r\n@@ -418,12 +499,19 @@ class double_close : public fd_diagnostic\n   diagnostic_event_id_t m_first_close_event;\r\n };\r\n \r\n-class fd_use_after_close : public fd_diagnostic\r\n+class fd_use_after_close : public fd_param_diagnostic\r\n {\r\n public:\r\n+  fd_use_after_close (const fd_state_machine &sm, tree arg,\r\n+                      const tree callee_fndecl, const char *attr_name,\r\n+                      int arg_idx)\r\n+      : fd_param_diagnostic (sm, arg, callee_fndecl, attr_name, arg_idx)\r\n+  {\r\n+  }\r\n+\r\n   fd_use_after_close (const fd_state_machine &sm, tree arg,\r\n                       const tree callee_fndecl)\r\n-      : fd_diagnostic (sm, arg), m_callee_fndecl (callee_fndecl)\r\n+      : fd_param_diagnostic (sm, arg, callee_fndecl)\r\n   {\r\n   }\r\n \r\n@@ -442,9 +530,13 @@ class fd_use_after_close : public fd_diagnostic\n   bool\r\n   emit (rich_location *rich_loc) final override\r\n   {\r\n-    return warning_at (rich_loc, get_controlling_option (),\r\n+    bool warned;\r\n+    warned = warning_at (rich_loc, get_controlling_option (),\r\n                        \"%qE on closed file descriptor %qE\", m_callee_fndecl,\r\n                        m_arg);\r\n+    if (warned)\r\n+      inform_filedescriptor_attribute (DIRS_READ_WRITE);\r\n+    return warned;\r\n   }\r\n \r\n   label_text\r\n@@ -466,32 +558,38 @@ class fd_use_after_close : public fd_diagnostic\n   describe_final_event (const evdesc::final_event &ev) final override\r\n   {\r\n     if (m_first_close_event.known_p ())\r\n-      return ev.formatted_print (\r\n-          \"%qE on closed file descriptor %qE; %qs was at %@\", m_callee_fndecl,\r\n-          m_arg, \"close\", &m_first_close_event);\r\n-    else\r\n-      return ev.formatted_print (\"%qE on closed file descriptor %qE\",\r\n-                                 m_callee_fndecl, m_arg);\r\n+        return ev.formatted_print (\r\n+            \"%qE on closed file descriptor %qE; %qs was at %@\", m_callee_fndecl,\r\n+            m_arg, \"close\", &m_first_close_event);\r\n+      else\r\n+        return ev.formatted_print (\"%qE on closed file descriptor %qE\",\r\n+                                  m_callee_fndecl, m_arg);\r\n   }\r\n \r\n private:\r\n   diagnostic_event_id_t m_first_close_event;\r\n-  const tree m_callee_fndecl;\r\n };\r\n \r\n-class unchecked_use_of_fd : public fd_diagnostic\r\n+class fd_use_without_check : public fd_param_diagnostic\r\n {\r\n public:\r\n-  unchecked_use_of_fd (const fd_state_machine &sm, tree arg,\r\n-                       const tree callee_fndecl)\r\n-      : fd_diagnostic (sm, arg), m_callee_fndecl (callee_fndecl)\r\n+  fd_use_without_check (const fd_state_machine &sm, tree arg,\r\n+                        const tree callee_fndecl, const char *attr_name,\r\n+                        int arg_idx)\r\n+      : fd_param_diagnostic (sm, arg, callee_fndecl, attr_name, arg_idx)\r\n+  {\r\n+  }\r\n+\r\n+  fd_use_without_check (const fd_state_machine &sm, tree arg,\r\n+                        const tree callee_fndecl)\r\n+      : fd_param_diagnostic (sm, arg, callee_fndecl)\r\n   {\r\n   }\r\n \r\n   const char *\r\n   get_kind () const final override\r\n   {\r\n-    return \"unchecked_use_of_fd\";\r\n+    return \"fd_use_without_check\";\r\n   }\r\n \r\n   int\r\n@@ -503,18 +601,13 @@ class unchecked_use_of_fd : public fd_diagnostic\n   bool\r\n   emit (rich_location *rich_loc) final override\r\n   {\r\n-    return warning_at (rich_loc, get_controlling_option (),\r\n-                       \"%qE on possibly invalid file descriptor %qE\",\r\n-                       m_callee_fndecl, m_arg);\r\n-  }\r\n-\r\n-  bool\r\n-  subclass_equal_p (const pending_diagnostic &base_other) const override\r\n-  {\r\n-    const unchecked_use_of_fd &sub_other\r\n-        = (const unchecked_use_of_fd &)base_other;\r\n-    return (same_tree_p (m_arg, sub_other.m_arg)\r\n-            && m_callee_fndecl == sub_other.m_callee_fndecl);\r\n+    bool warned;\r\n+    warned = warning_at (rich_loc, get_controlling_option (),\r\n+                        \"%qE on possibly invalid file descriptor %qE\",\r\n+                        m_callee_fndecl, m_arg);\r\n+    if (warned)\r\n+     inform_filedescriptor_attribute (DIRS_READ_WRITE);\r\n+    return warned;\r\n   }\r\n \r\n   label_text\r\n@@ -541,8 +634,7 @@ class unchecked_use_of_fd : public fd_diagnostic\n   }\r\n \r\n private:\r\n-  diagnostic_event_id_t m_first_open_event;\r\n-  const tree m_callee_fndecl;\r\n+  diagnostic_event_id_t m_first_open_event;  \r\n };\r\n \r\n fd_state_machine::fd_state_machine (logger *logger)\r\n@@ -647,11 +739,117 @@ fd_state_machine::on_stmt (sm_context *sm_ctxt, const supernode *node,\n             on_read (sm_ctxt, node, stmt, call, callee_fndecl);\r\n             return true;\r\n           } // \"read\"\r\n+\r\n+          \r\n+        {\r\n+          // Handle __attribute__((fd_arg))\r\n+\r\n+          check_for_fd_attrs (sm_ctxt, node, stmt, call, callee_fndecl,\r\n+                              \"fd_arg\", DIRS_READ_WRITE);\r\n+\r\n+          // Handle __attribute__((fd_arg_read))\r\n+\r\n+          check_for_fd_attrs (sm_ctxt, node, stmt, call, callee_fndecl,\r\n+                              \"fd_arg_read\", DIRS_READ);\r\n+\r\n+          // Handle __attribute__((fd_arg_write))\r\n+\r\n+          check_for_fd_attrs (sm_ctxt, node, stmt, call, callee_fndecl,\r\n+                              \"fd_arg_write\", DIRS_WRITE);\r\n+        }          \r\n       }\r\n \r\n   return false;\r\n }\r\n \r\n+void\r\n+fd_state_machine::check_for_fd_attrs (\r\n+    sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n+    const gcall *call, const tree callee_fndecl, const char *attr_name,\r\n+    access_directions fd_attr_access_dir) const\r\n+{\r\n+\r\n+  tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (callee_fndecl));\r\n+  attrs = lookup_attribute (attr_name, attrs);\r\n+  if (!attrs)\r\n+    return;\r\n+\r\n+  if (!TREE_VALUE (attrs))\r\n+    return;\r\n+\r\n+  auto_bitmap argmap;\r\n+\r\n+  for (tree idx = TREE_VALUE (attrs); idx; idx = TREE_CHAIN (idx))\r\n+    {\r\n+      unsigned int val = TREE_INT_CST_LOW (TREE_VALUE (idx)) - 1;\r\n+      bitmap_set_bit (argmap, val);\r\n+    }\r\n+  if (bitmap_empty_p (argmap))\r\n+    return;\r\n+\r\n+  for (unsigned arg_idx = 0; arg_idx < gimple_call_num_args (call); arg_idx++)\r\n+    {\r\n+      tree arg = gimple_call_arg (call, arg_idx);\r\n+      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n+      state_t state = sm_ctxt->get_state (stmt, arg);\r\n+      bool bit_set = bitmap_bit_p (argmap, arg_idx);\r\n+      if (TREE_CODE (TREE_TYPE (arg)) != INTEGER_TYPE)\r\n+        continue;\r\n+      if (bit_set) // Check if arg_idx is marked by any of the file descriptor\r\n+                   // attributes\r\n+        {\r\n+\r\n+          if (is_closed_fd_p (state))\r\n+            {\r\n+\r\n+              sm_ctxt->warn (node, stmt, arg,\r\n+                             new fd_use_after_close (*this, diag_arg,\r\n+                                                     callee_fndecl, attr_name,\r\n+                                                     arg_idx));\r\n+              continue;\r\n+            }\r\n+\r\n+          if (!(is_valid_fd_p (state) || (state == m_stop)))\r\n+            {\r\n+              if (!is_constant_fd_p (state))\r\n+                sm_ctxt->warn (node, stmt, arg,\r\n+                               new fd_use_without_check (*this, diag_arg,\r\n+                                                        callee_fndecl, attr_name,\r\n+                                                        arg_idx));\r\n+            }\r\n+\r\n+          switch (fd_attr_access_dir)\r\n+            {\r\n+            case DIRS_READ_WRITE:\r\n+              break;\r\n+            case DIRS_READ:\r\n+\r\n+              if (is_writeonly_fd_p (state))\r\n+                {\r\n+                  sm_ctxt->warn (\r\n+                      node, stmt, arg,\r\n+                      new fd_access_mode_mismatch (*this, diag_arg, DIRS_WRITE,\r\n+                                                   callee_fndecl, attr_name, arg_idx));\r\n+                }\r\n+\r\n+              break;\r\n+            case DIRS_WRITE:\r\n+\r\n+              if (is_readonly_fd_p (state))\r\n+                {\r\n+                  sm_ctxt->warn (\r\n+                      node, stmt, arg,\r\n+                      new fd_access_mode_mismatch (*this, diag_arg, DIRS_READ,\r\n+                                                   callee_fndecl, attr_name, arg_idx));\r\n+                }\r\n+\r\n+              break;\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+\r\n void\r\n fd_state_machine::on_open (sm_context *sm_ctxt, const supernode *node,\r\n                            const gimple *stmt, const gcall *call) const\r\n@@ -706,7 +904,7 @@ fd_state_machine::on_close (sm_context *sm_ctxt, const supernode *node,\n \r\n   if (is_closed_fd_p (state))\r\n     {\r\n-      sm_ctxt->warn (node, stmt, arg, new double_close (*this, diag_arg));\r\n+      sm_ctxt->warn (node, stmt, arg, new fd_double_close (*this, diag_arg));\r\n       sm_ctxt->set_next_state (stmt, arg, m_stop);\r\n     }\r\n }\r\n@@ -715,21 +913,21 @@ fd_state_machine::on_read (sm_context *sm_ctxt, const supernode *node,\n                            const gimple *stmt, const gcall *call,\r\n                            const tree callee_fndecl) const\r\n {\r\n-  check_for_open_fd (sm_ctxt, node, stmt, call, callee_fndecl, DIR_READ);\r\n+  check_for_open_fd (sm_ctxt, node, stmt, call, callee_fndecl, DIRS_READ);\r\n }\r\n void\r\n fd_state_machine::on_write (sm_context *sm_ctxt, const supernode *node,\r\n                             const gimple *stmt, const gcall *call,\r\n                             const tree callee_fndecl) const\r\n {\r\n-  check_for_open_fd (sm_ctxt, node, stmt, call, callee_fndecl, DIR_WRITE);\r\n+  check_for_open_fd (sm_ctxt, node, stmt, call, callee_fndecl, DIRS_WRITE);\r\n }\r\n \r\n void\r\n fd_state_machine::check_for_open_fd (\r\n     sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n     const gcall *call, const tree callee_fndecl,\r\n-    enum access_direction callee_fndecl_dir) const\r\n+    enum access_directions callee_fndecl_dir) const\r\n {\r\n   tree arg = gimple_call_arg (call, 0);\r\n   tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n@@ -748,30 +946,32 @@ fd_state_machine::check_for_open_fd (\n           if (!is_constant_fd_p (state))\r\n             sm_ctxt->warn (\r\n                 node, stmt, arg,\r\n-                new unchecked_use_of_fd (*this, diag_arg, callee_fndecl));\r\n+                new fd_use_without_check (*this, diag_arg, callee_fndecl));\r\n         }\r\n       switch (callee_fndecl_dir)\r\n         {\r\n-        case DIR_READ:\r\n+        case DIRS_READ:\r\n           if (is_writeonly_fd_p (state))\r\n             {\r\n               tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n               sm_ctxt->warn (node, stmt, arg,\r\n                              new fd_access_mode_mismatch (\r\n-                                 *this, diag_arg, DIR_WRITE, callee_fndecl));\r\n+                                 *this, diag_arg, DIRS_WRITE, callee_fndecl));\r\n             }\r\n \r\n           break;\r\n-        case DIR_WRITE:\r\n+        case DIRS_WRITE:\r\n \r\n           if (is_readonly_fd_p (state))\r\n             {\r\n               tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n               sm_ctxt->warn (node, stmt, arg,\r\n                              new fd_access_mode_mismatch (\r\n-                                 *this, diag_arg, DIR_READ, callee_fndecl));\r\n+                                 *this, diag_arg, DIRS_READ, callee_fndecl));\r\n             }\r\n           break;\r\n+        default:\r\n+          gcc_unreachable ();\r\n         }\r\n     }\r\n }\r"}, {"sha": "e4f1d3542f37867208da03aaec0563a9f67c9974", "filename": "gcc/c-family/c-attribs.cc", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Fc-family%2Fc-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Fc-family%2Fc-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.cc?ref=f8e6e2c046e1015697356ee7079fb39e0cb6add5", "patch": "@@ -173,6 +173,7 @@ static tree handle_objc_nullability_attribute (tree *, tree, tree, int, bool *);\n static tree handle_signed_bool_precision_attribute (tree *, tree, tree, int,\n \t\t\t\t\t\t    bool *);\n static tree handle_retain_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_fd_arg_attribute (tree *, tree, tree, int, bool *);\n \n /* Helper to define attribute exclusions.  */\n #define ATTR_EXCL(name, function, type, variable)\t\\\n@@ -555,6 +556,12 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_dealloc_attribute, NULL },\n   { \"tainted_args\",\t      0, 0, true,  false, false, false,\n \t\t\t      handle_tainted_args_attribute, NULL },\n+  { \"fd_arg\",             1, 1, false, true, true, false,\n+            handle_fd_arg_attribute, NULL},      \n+  { \"fd_arg_read\",        1, 1, false, true, true, false,\n+            handle_fd_arg_attribute, NULL},\n+  { \"fd_arg_write\",       1, 1, false, true, true, false,\n+            handle_fd_arg_attribute, NULL},         \n   { NULL,                     0, 0, false, false, false, false, NULL, NULL }\n };\n \n@@ -4521,6 +4528,30 @@ handle_nonnull_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle the \"fd_arg\", \"fd_arg_read\" and \"fd_arg_write\" attributes */\n+\n+static tree\n+handle_fd_arg_attribute (tree *node, tree name, tree args,\n+                              int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  tree type = *node;\n+  if (!args)\n+    {\n+      if (!prototype_p (type))\n+        {\n+          error (\"%qE attribute without arguments on a non-prototype\", name);\n+          *no_add_attrs = true;\n+        }\n+      return NULL_TREE;\n+    }\n+\n+  if (positional_argument (*node, name, TREE_VALUE (args), INTEGER_TYPE))\n+      return NULL_TREE;\n+\n+  *no_add_attrs = true;  \n+  return NULL_TREE;\n+}\n+\n /* Handle the \"nonstring\" variable attribute.  */\n \n static tree"}, {"sha": "71897b84a1b3de6e432fb8551f79ed6fbe2e7ced", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f8e6e2c046e1015697356ee7079fb39e0cb6add5", "patch": "@@ -3007,6 +3007,43 @@ produced by @command{gold}.\n For other linkers that cannot generate resolution file,\n explicit @code{externally_visible} attributes are still necessary.\n \n+@item fd_arg \n+@itemx fd_arg (@var{N})\n+@cindex @code{fd_arg} function attribute\n+The @code{fd_arg} attribute may be applied to a function that takes an open \n+file descriptor at referenced argument @var{N}.\n+\n+It indicates that the passed filedescriptor must not have been closed.\n+Therefore, when the analyzer is enabled with @option{-fanalyzer}, the \n+analyzer may emit a @option{-Wanalyzer-fd-use-after-close} diagnostic \n+if it detects a code path in which a function with this attribute is\n+called with a closed file descriptor.\n+\n+The attribute also indicates that the file descriptor must have been checked for\n+validity before usage. Therefore, analyzer may emit\n+@option{-Wanalyzer-fd-use-without-check} diagnostic if it detects a code path in\n+which a function with this attribute is called with a file descriptor that has\n+not been checked for validity.\n+\n+@item fd_arg_read\n+@itemx fd_arg_read (@var{N})\n+@cindex @code{fd_arg_read} function attribute\n+The @code{fd_arg_read} is identical to @code{fd_arg}, but with the additional\n+requirement that it might read from the file descriptor, and thus, the file\n+descriptor must not have been opened as write-only.\n+\n+The analyzer may emit a @option{-Wanalyzer-access-mode-mismatch}\n+diagnostic if it detects a code path in which a function with this\n+attribute is called on a file descriptor opened with @code{O_WRONLY}.\n+\n+@item fd_arg_write\n+@itemx fd_arg_write (@var{N})\n+@cindex @code{fd_arg_write} function attribute\n+The @code{fd_arg_write} is identical to @code{fd_arg_read} except that the\n+analyzer may emit a @option{-Wanalyzer-access-mode-mismatch} diagnostic if \n+it detects a code path in which a function with this attribute is called on a \n+file descriptor opened with @code{O_RDONLY}.\n+\n @item flatten\n @cindex @code{flatten} function attribute\n Generally, inlining into a function is limited.  For a function marked with"}, {"sha": "b1a9f50bfc73bad48e705f6a2963a6b4a24f90af", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f8e6e2c046e1015697356ee7079fb39e0cb6add5", "patch": "@@ -9848,7 +9848,13 @@ This warning requires @option{-fanalyzer}, which enables it; use\n to disable it.\n \n This diagnostic warns for paths through code in which a \n-@code{read} on a write-only file descriptor is attempted, or vice versa\n+@code{read} on a write-only file descriptor is attempted, or vice versa.\n+\n+This diagnostic also warns for code paths in a which a function with attribute\n+@code{fd_arg_read (N)} is called with a file descriptor opened with\n+@code{O_WRONLY} at referenced argument @code{N} or a function with attribute\n+@code{fd_arg_write (N)} is called with a file descriptor opened with\n+@code{O_RDONLY} at referenced argument @var{N}.\n \n @item -Wno-analyzer-fd-double-close\n @opindex Wanalyzer-fd-double-close\n@@ -9880,6 +9886,11 @@ to disable it.\n This diagnostic warns for paths through code in which a \n read or write is called on a closed file descriptor.\n \n+This diagnostic also warns for paths through code in which\n+a function with attribute @code{fd_arg (N)} or @code{fd_arg_read (N)}\n+or @code{fd_arg_write (N)} is called with a closed file descriptor at\n+referenced argument @code{N}.\n+\n @item -Wno-analyzer-fd-use-without-check\n @opindex Wanalyzer-fd-use-without-check\n @opindex Wno-analyzer-fd-use-without-check\n@@ -9890,6 +9901,11 @@ to disable it.\n This diagnostic warns for paths through code in which a \n file descriptor is used without being checked for validity.\n \n+This diagnostic also warns for paths through code in which\n+a function with attribute @code{fd_arg (N)} or @code{fd_arg_read (N)}\n+or @code{fd_arg_write (N)} is called with a file descriptor, at referenced\n+argument @code{N}, without being checked for validity.\n+\n @item -Wno-analyzer-file-leak\n @opindex Wanalyzer-file-leak\n @opindex Wno-analyzer-file-leak"}, {"sha": "e4bb4ed03748e4db02a7376f160126b2a338ccd2", "filename": "gcc/testsuite/c-c++-common/attr-fd.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-fd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-fd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-fd.c?ref=f8e6e2c046e1015697356ee7079fb39e0cb6add5", "patch": "@@ -0,0 +1,18 @@\n+\r\n+int not_a_fn __attribute__ ((fd_arg(1))); /* { dg-warning \"'fd_arg' attribute only applies to function types\" } */\r\n+\r\n+void f (char *p) __attribute__ ((fd_arg(1))); /* { dg-warning \"'fd_arg' attribute argument value '1' refers to parameter type 'char ?\\\\\\*'\" } */\r\n+\r\n+\r\n+int not_a_fn_b __attribute__ ((fd_arg_read(1))); /* { dg-warning \"'fd_arg_read' attribute only applies to function types\" } */\r\n+\r\n+void g (char *p) __attribute__ ((fd_arg_read(1))); /* { dg-warning \"'fd_arg_read' attribute argument value '1' refers to parameter type 'char ?\\\\\\*'\" } */\r\n+\r\n+\r\n+int not_a_fn_c __attribute__ ((fd_arg_write(1))); /* { dg-warning \"'fd_arg_write' attribute only applies to function types\" } */\r\n+\r\n+void f (char *p) __attribute__ ((fd_arg_write(1))); /* { dg-warning \"'fd_arg_write' attribute argument value '1' refers to parameter type 'char ?\\\\\\*'\" } */\r\n+\r\n+\r\n+void fn_a (int fd) __attribute__ ((fd_arg(0))); /* { dg-warning \"'fd_arg' attribute argument value '0' does not refer to a function parameter\" } */\r\n+void fd_a_1 (int fd) __attribute__ ((fd_arg(\"notint\"))); /* { dg-warning \"'fd_arg' attribute argument has type ('char\\\\\\[7\\\\\\]'|'const char\\\\\\*')\" } */\r"}, {"sha": "41263468a6c12ab8323578e65d4780a4d144ef74", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-4.c?ref=f8e6e2c046e1015697356ee7079fb39e0cb6add5", "patch": "@@ -17,9 +17,9 @@ test_1 (const char *path, void *buf)\n     if (fd >= 0) /* { dg-message \"assuming 'fd' is a valid file descriptor \\\\(>= 0\\\\)\" \"event1\" } */\r\n     /* { dg-message \"following 'true' branch \\\\(when 'fd >= 0'\\\\)...\" \"event2\" { target *-*-* } .-1 } */\r\n     {\r\n-        write (fd, buf, 1); /* { dg-warning \"'write' on 'read-only' file descriptor 'fd'\" \"warning\" } */\r\n+        write (fd, buf, 1); /* { dg-warning \"'write' on read-only file descriptor 'fd'\" \"warning\" } */\r\n         /* { dg-message \"\\\\(4\\\\) ...to here\" \"event1\" { target *-*-* } .-1 } */\r\n-        /* { dg-message \"\\\\(5\\\\) 'write' on 'read-only' file descriptor 'fd'\" \"event2\" { target *-*-* } .-2 } */\r\n+        /* { dg-message \"\\\\(5\\\\) 'write' on read-only file descriptor 'fd'\" \"event2\" { target *-*-* } .-2 } */\r\n         close (fd);\r\n     }\r\n }\r\n@@ -31,9 +31,9 @@ test_2 (const char *path, void *buf)\n     if (fd >= 0) /* { dg-message \"assuming 'fd' is a valid file descriptor \\\\(>= 0\\\\)\" \"event1\" } */\r\n     /* { dg-message \"following 'true' branch \\\\(when 'fd >= 0'\\\\)...\" \"event2\" { target *-*-* } .-1 } */\r\n     {\r\n-        read (fd, buf, 1); /* { dg-warning \"'read' on 'write-only' file descriptor 'fd'\" \"warning\" } */\r\n+        read (fd, buf, 1); /* { dg-warning \"'read' on write-only file descriptor 'fd'\" \"warning\" } */\r\n         /* { dg-message \"\\\\(4\\\\) ...to here\" \"event1\" { target *-*-* } .-1 } */\r\n-        /* { dg-message \"\\\\(5\\\\) 'read' on 'write-only' file descriptor 'fd'\" \"event2\" { target *-*-* } .-2 } */\r\n+        /* { dg-message \"\\\\(5\\\\) 'read' on write-only file descriptor 'fd'\" \"event2\" { target *-*-* } .-2 } */\r\n         close (fd);\r\n     }\r\n }\r"}, {"sha": "8f29c11b3e81c0cd3de799209d3b7f8cd727ce9f", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-5.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e6e2c046e1015697356ee7079fb39e0cb6add5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-5.c?ref=f8e6e2c046e1015697356ee7079fb39e0cb6add5", "patch": "@@ -0,0 +1,53 @@\n+int open(const char *, int mode);\r\n+void close(int fd);\r\n+int write (int fd, void *buf, int nbytes);\r\n+int read (int fd, void *buf, int nbytes);\r\n+\r\n+#define O_RDONLY 0\r\n+#define O_WRONLY 1\r\n+#define O_RDWR 2\r\n+\r\n+void f (int fd) __attribute__((fd_arg(1))); /* { dg-message \"argument 1 of 'f' must be an open file descriptor, due to '__attribute__\\\\(\\\\(fd_arg\\\\(1\\\\)\\\\)\\\\)'\" } */\r\n+\r\n+void\r\n+test_1 (const char *path)\r\n+{\r\n+    int fd = open (path, O_RDWR);\r\n+    close(fd);\r\n+    f(fd); /* { dg-warning \"'f' on closed file descriptor 'fd'\" } */\r\n+      /* { dg-message \"\\\\(3\\\\) 'f' on closed file descriptor 'fd'; 'close' was at \\\\(2\\\\)\" \"\" { target *-*-* } .-1 } */\r\n+}\r\n+\r\n+void g (int fd) __attribute__((fd_arg_read(1))); /* { dg-message \"argument 1 of 'g' must be a readable file descriptor, due to '__attribute__\\\\(\\\\(fd_arg_read\\\\(1\\\\)\\\\)\\\\)'\" } */\r\n+\r\n+void\r\n+test_2 (const char *path)\r\n+{\r\n+  int fd = open (path, O_WRONLY);\r\n+  if (fd != -1)\r\n+  {\r\n+    g (fd); /* { dg-warning \"'g' on write-only file descriptor 'fd'\" } */\r\n+  }\r\n+  close (fd);\r\n+}\r\n+\r\n+void h (int fd) __attribute__((fd_arg_write(1))); /* { dg-message \"argument 1 of 'h' must be a writable file descriptor, due to '__attribute__\\\\(\\\\(fd_arg_write\\\\(1\\\\)\\\\)\\\\)'\" } */\r\n+void\r\n+test_3 (const char *path)\r\n+{\r\n+  int fd = open (path, O_RDONLY);\r\n+  if (fd != -1)\r\n+  {\r\n+    h (fd); /* { dg-warning \"'h' on read-only file descriptor 'fd'\" } */\r\n+  }\r\n+  close(fd);\r\n+}\r\n+\r\n+void ff (int fd) __attribute__((fd_arg(1))); /* { dg-message \"argument 1 of 'ff' must be an open file descriptor, due to '__attribute__\\\\(\\\\(fd_arg\\\\(1\\\\)\\\\)\\\\)'\" } */\r\n+\r\n+void test_4 (const char *path)\r\n+{\r\n+  int fd = open (path, O_RDWR);\r\n+  ff (fd); /* { dg-warning \"'ff' on possibly invalid file descriptor 'fd'\" } */\r\n+  close(fd);\r\n+}\n\\ No newline at end of file"}]}