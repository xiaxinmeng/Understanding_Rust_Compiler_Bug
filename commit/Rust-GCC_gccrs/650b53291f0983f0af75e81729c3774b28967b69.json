{"sha": "650b53291f0983f0af75e81729c3774b28967b69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUwYjUzMjkxZjA5ODNmMGFmNzVlODE3MjljMzc3NGIyODk2N2I2OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-07-21T18:50:02Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-07-21T18:50:02Z"}, "message": "Eliminate the computed goto in x64 varargs.\n\nUse a simple test and branch vs 0 instead.  Which also allows us\nto avoid funny code emission problems as well.\n\nFrom-SVN: r162384", "tree": {"sha": "aae10bc1cfc234f7f78cfb44a5ed92e958601efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aae10bc1cfc234f7f78cfb44a5ed92e958601efd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/650b53291f0983f0af75e81729c3774b28967b69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/650b53291f0983f0af75e81729c3774b28967b69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/650b53291f0983f0af75e81729c3774b28967b69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/650b53291f0983f0af75e81729c3774b28967b69/comments", "author": null, "committer": null, "parents": [{"sha": "5634254ce52c520f6215ed02d87f362bab1a6fdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5634254ce52c520f6215ed02d87f362bab1a6fdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5634254ce52c520f6215ed02d87f362bab1a6fdd"}], "stats": {"total": 251, "additions": 46, "deletions": 205}, "files": [{"sha": "2e84ab15b92aa5ae9bc65748cd54cf258663ebf1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/650b53291f0983f0af75e81729c3774b28967b69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/650b53291f0983f0af75e81729c3774b28967b69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=650b53291f0983f0af75e81729c3774b28967b69", "patch": "@@ -1,3 +1,13 @@\n+2010-07-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (setup_incoming_varargs_64): Emit a simple\n+\tcomparison for avoiding xmm register saves.  Emit the xmm register\n+\tsaves explicitly.\n+\t* config/i386/i386.md (UNSPEC_SSE_PROLOGUE_SAVE): Remove.\n+\t(UNSPEC_SSE_PROLOGUE_SAVE_LOW): Remove.\n+\t(sse_prologue_save, sse_prologue_save_insn1, sse_prologue_save_insn):\n+\tRemove patterns and the associated splitters.\n+\n 2010-07-21  Changpeng Fang  <changpeng.fang@amd.com>\n \n \t* tree-ssa-loop-prefetch.c (analyze_ref): Strip off the real"}, {"sha": "d9dc571dbfe48653aad5124faa9b9829aa2e25dc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/650b53291f0983f0af75e81729c3774b28967b69/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/650b53291f0983f0af75e81729c3774b28967b69/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=650b53291f0983f0af75e81729c3774b28967b69", "patch": "@@ -7062,11 +7062,8 @@ static void\n setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n {\n   rtx save_area, mem;\n-  rtx label;\n-  rtx tmp_reg;\n-  rtx nsse_reg;\n   alias_set_type set;\n-  int i;\n+  int i, max;\n \n   /* GPR size of varargs save area.  */\n   if (cfun->va_list_gpr_size)\n@@ -7087,10 +7084,11 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n   save_area = frame_pointer_rtx;\n   set = get_varargs_alias_set ();\n \n-  for (i = cum->regno;\n-       i < X86_64_REGPARM_MAX\n-       && i < cum->regno + cfun->va_list_gpr_size / UNITS_PER_WORD;\n-       i++)\n+  max = cum->regno + cfun->va_list_gpr_size / UNITS_PER_WORD;\n+  if (max > X86_64_REGPARM_MAX)\n+    max = X86_64_REGPARM_MAX;\n+\n+  for (i = cum->regno; i < max; i++)\n     {\n       mem = gen_rtx_MEM (Pmode,\n \t\t\t plus_constant (save_area, i * UNITS_PER_WORD));\n@@ -7102,33 +7100,41 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n \n   if (ix86_varargs_fpr_size)\n     {\n+      enum machine_mode smode;\n+      rtx label, test;\n+\n       /* Now emit code to save SSE registers.  The AX parameter contains number\n-\t of SSE parameter registers used to call this function.  We use\n-\t sse_prologue_save insn template that produces computed jump across\n-\t SSE saves.  We need some preparation work to get this working.  */\n+\t of SSE parameter registers used to call this function, though all we\n+\t actually check here is the zero/non-zero status.  */\n \n       label = gen_label_rtx ();\n+      test = gen_rtx_EQ (VOIDmode, gen_rtx_REG (QImode, AX_REG), const0_rtx);\n+      emit_jump_insn (gen_cbranchqi4 (test, XEXP (test, 0), XEXP (test, 1),\n+\t\t\t\t      label));\n+\n+      /* If we've determined that we're only loading scalars (and not\n+\t vector data) then we can store doubles instead.  */\n+      if (crtl->stack_alignment_needed < 128)\n+\tsmode = DFmode;\n+      else\n+\tsmode = V4SFmode;\n \n-      nsse_reg = gen_reg_rtx (Pmode);\n-      emit_insn (gen_zero_extendqidi2 (nsse_reg, gen_rtx_REG (QImode, AX_REG)));\n-\n-      /* Compute address of memory block we save into.  We always use pointer\n-\t pointing 127 bytes after first byte to store - this is needed to keep\n-\t instruction size limited by 4 bytes (5 bytes for AVX) with one\n-\t byte displacement.  */\n-      tmp_reg = gen_reg_rtx (Pmode);\n-      emit_insn (gen_rtx_SET (VOIDmode, tmp_reg,\n-\t\t\t      plus_constant (save_area,\n-\t\t\t\t\t     ix86_varargs_gpr_size + 127)));\n-      mem = gen_rtx_MEM (BLKmode, plus_constant (tmp_reg, -127));\n-      MEM_NOTRAP_P (mem) = 1;\n-      set_mem_alias_set (mem, set);\n-      set_mem_align (mem, 64);\n+      max = cum->sse_regno + cfun->va_list_fpr_size / 16;\n+      if (max > X86_64_SSE_REGPARM_MAX)\n+\tmax = X86_64_SSE_REGPARM_MAX;\n \n-      /* And finally do the dirty job!  */\n-      emit_insn (gen_sse_prologue_save (mem, nsse_reg,\n-\t\t\t\t\tGEN_INT (cum->sse_regno), label,\n-\t\t\t\t\tgen_reg_rtx (Pmode)));\n+      for (i = cum->sse_regno; i < max; ++i)\n+\t{\n+\t  mem = plus_constant (save_area, i * 16 + ix86_varargs_gpr_size);\n+\t  mem = gen_rtx_MEM (smode, mem);\n+\t  MEM_NOTRAP_P (mem) = 1;\n+\t  set_mem_alias_set (mem, set);\n+\t  set_mem_align (mem, GET_MODE_ALIGNMENT (smode));\n+\n+\t  emit_move_insn (mem, gen_rtx_REG (smode, SSE_REGNO (i)));\n+\t}\n+\n+      emit_label (label);\n     }\n }\n "}, {"sha": "6616da2e729eac2e8bb43fb55abf01577a22358b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/650b53291f0983f0af75e81729c3774b28967b69/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/650b53291f0983f0af75e81729c3774b28967b69/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=650b53291f0983f0af75e81729c3774b28967b69", "patch": "@@ -79,13 +79,11 @@\n   ;; Prologue support\n   UNSPEC_STACK_ALLOC\n   UNSPEC_SET_GOT\n-  UNSPEC_SSE_PROLOGUE_SAVE\n   UNSPEC_REG_SAVE\n   UNSPEC_DEF_CFA\n   UNSPEC_SET_RIP\n   UNSPEC_SET_GOT_OFFSET\n   UNSPEC_MEMORY_BLOCKAGE\n-  UNSPEC_SSE_PROLOGUE_SAVE_LOW\n \n   ;; TLS support\n   UNSPEC_TP\n@@ -17825,179 +17823,6 @@\n   { return ASM_SHORT \"0x0b0f\"; }\n   [(set_attr \"length\" \"2\")])\n \n-(define_expand \"sse_prologue_save\"\n-  [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n-\t\t   (unspec:BLK [(reg:DI XMM0_REG)\n-\t\t\t\t(reg:DI XMM1_REG)\n-\t\t\t\t(reg:DI XMM2_REG)\n-\t\t\t\t(reg:DI XMM3_REG)\n-\t\t\t\t(reg:DI XMM4_REG)\n-\t\t\t\t(reg:DI XMM5_REG)\n-\t\t\t\t(reg:DI XMM6_REG)\n-\t\t\t\t(reg:DI XMM7_REG)] UNSPEC_SSE_PROLOGUE_SAVE))\n-\t      (clobber (reg:CC FLAGS_REG))\n-\t      (clobber (match_operand:DI 1 \"register_operand\" \"\"))\n-\t      (use (match_operand:DI 2 \"immediate_operand\" \"\"))\n-\t      (use (label_ref:DI (match_operand 3 \"\" \"\")))\n-\t      (clobber (match_operand:DI 4 \"register_operand\" \"\"))\n-\t      (use (match_dup 1))])]\n-  \"TARGET_64BIT\"\n-  \"\")\n-\n-;; Pre-reload version of prologue save.  Until after prologue generation we don't know\n-;; what the size of save instruction will be.\n-;; Operand 0+operand 6 is the memory save area\n-;; Operand 1 is number of registers to save (will get overwritten to operand 5)\n-;; Operand 2 is number of non-vaargs SSE arguments\n-;; Operand 3 is label starting the save block\n-;; Operand 4 is used for temporary computation of jump address\n-(define_insn \"*sse_prologue_save_insn1\"\n-  [(set (mem:BLK (plus:DI (match_operand:DI 0 \"register_operand\" \"R\")\n-\t\t\t  (match_operand:DI 6 \"const_int_operand\" \"n\")))\n-\t(unspec:BLK [(reg:DI XMM0_REG)\n-\t\t     (reg:DI XMM1_REG)\n-\t\t     (reg:DI XMM2_REG)\n-\t\t     (reg:DI XMM3_REG)\n-\t\t     (reg:DI XMM4_REG)\n-\t\t     (reg:DI XMM5_REG)\n-\t\t     (reg:DI XMM6_REG)\n-\t\t     (reg:DI XMM7_REG)] UNSPEC_SSE_PROLOGUE_SAVE))\n-   (clobber (reg:CC FLAGS_REG))\n-   (clobber (match_operand:DI 1 \"register_operand\" \"=r\"))\n-   (use (match_operand:DI 2 \"const_int_operand\" \"i\"))\n-   (use (label_ref:DI (match_operand 3 \"\" \"X\")))\n-   (clobber (match_operand:DI 4 \"register_operand\" \"=&r\"))\n-   (use (match_operand:DI 5 \"register_operand\" \"1\"))]\n-  \"TARGET_64BIT\n-   && INTVAL (operands[6]) + X86_64_SSE_REGPARM_MAX * 16 - 16 < 128\n-   && INTVAL (operands[6]) + INTVAL (operands[2]) * 16 >= -128\"\n-  \"#\"\n-  [(set_attr \"type\" \"other\")\n-   (set_attr \"memory\" \"store\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-;; We know size of save instruction; expand the computation of jump address\n-;; in the jumptable.\n-(define_split\n-  [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n-\t\t    (unspec:BLK [(reg:DI XMM0_REG)\n-\t\t\t\t (reg:DI XMM1_REG)\n-\t\t\t\t (reg:DI XMM2_REG)\n-\t\t\t\t (reg:DI XMM3_REG)\n-\t\t\t\t (reg:DI XMM4_REG)\n-\t\t\t\t (reg:DI XMM5_REG)\n-\t\t\t\t (reg:DI XMM6_REG)\n-\t\t\t\t (reg:DI XMM7_REG)] UNSPEC_SSE_PROLOGUE_SAVE))\n-\t       (clobber (reg:CC FLAGS_REG))\n-\t       (clobber (match_operand:DI 1 \"register_operand\" \"\"))\n-\t       (use (match_operand:DI 2 \"const_int_operand\" \"\"))\n-\t       (use (match_operand 3 \"\" \"\"))\n-\t       (clobber (match_operand:DI 4 \"register_operand\" \"\"))\n-\t       (use (match_operand:DI 5 \"register_operand\" \"\"))])]\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (unspec:BLK [(reg:DI XMM0_REG)\n-\t\t\t\t(reg:DI XMM1_REG)\n-\t\t\t\t(reg:DI XMM2_REG)\n-\t\t\t\t(reg:DI XMM3_REG)\n-\t\t\t\t(reg:DI XMM4_REG)\n-\t\t\t\t(reg:DI XMM5_REG)\n-\t\t\t\t(reg:DI XMM6_REG)\n-\t\t\t\t(reg:DI XMM7_REG)]\n-\t\t\t       UNSPEC_SSE_PROLOGUE_SAVE_LOW))\n-\t      (use (match_dup 1))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (use (match_dup 5))])]\n-{\n-  /* Movaps is 4 bytes, AVX and movsd is 5 bytes.  */\n-  int size = 4 + (TARGET_AVX || crtl->stack_alignment_needed < 128);\n-\n-  /* Compute address to jump to:\n-     label - eax*size + nnamed_sse_arguments*size. */\n-  if (size == 5)\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[4],\n-\t\t\t    gen_rtx_PLUS\n-\t\t\t      (Pmode,\n-\t\t\t       gen_rtx_MULT (Pmode, operands[1],\n-\t\t\t\t\t     GEN_INT (4)),\n-\t\t\t       operands[1])));\n-  else  if (size == 4)\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[4],\n-\t\t\t    gen_rtx_MULT (Pmode, operands[1],\n-\t\t\t\t\t  GEN_INT (4))));\n-  else\n-    gcc_unreachable ();\n-  if (INTVAL (operands[2]))\n-    emit_move_insn\n-      (operands[1],\n-       gen_rtx_CONST (DImode,\n-\t\t      gen_rtx_PLUS (DImode,\n-\t\t\t\t    operands[3],\n-\t\t\t\t    GEN_INT (INTVAL (operands[2])\n-\t\t\t\t\t     * size))));\n-  else\n-    emit_move_insn (operands[1], operands[3]);\n-  emit_insn (gen_subdi3 (operands[1], operands[1], operands[4]));\n-  operands[5] = GEN_INT (size);\n-})\n-\n-(define_insn \"sse_prologue_save_insn\"\n-  [(set (mem:BLK (plus:DI (match_operand:DI 0 \"register_operand\" \"R\")\n-\t\t\t  (match_operand:DI 4 \"const_int_operand\" \"n\")))\n-\t(unspec:BLK [(reg:DI XMM0_REG)\n-\t\t     (reg:DI XMM1_REG)\n-\t\t     (reg:DI XMM2_REG)\n-\t\t     (reg:DI XMM3_REG)\n-\t\t     (reg:DI XMM4_REG)\n-\t\t     (reg:DI XMM5_REG)\n-\t\t     (reg:DI XMM6_REG)\n-\t\t     (reg:DI XMM7_REG)] UNSPEC_SSE_PROLOGUE_SAVE_LOW))\n-   (use (match_operand:DI 1 \"register_operand\" \"r\"))\n-   (use (match_operand:DI 2 \"const_int_operand\" \"i\"))\n-   (use (label_ref:DI (match_operand 3 \"\" \"X\")))\n-   (use (match_operand:DI 5 \"const_int_operand\" \"i\"))]\n-  \"TARGET_64BIT\n-   && INTVAL (operands[4]) + X86_64_SSE_REGPARM_MAX * 16 - 16 < 128\n-   && INTVAL (operands[4]) + INTVAL (operands[2]) * 16 >= -128\"\n-{\n-  int i;\n-  operands[0] = gen_rtx_MEM (Pmode,\n-\t\t\t     gen_rtx_PLUS (Pmode, operands[0], operands[4]));\n-  /* VEX instruction with a REX prefix will #UD.  */\n-  if (TARGET_AVX && GET_CODE (XEXP (operands[0], 0)) != PLUS)\n-    gcc_unreachable ();\n-\n-  output_asm_insn (\"jmp\\t%A1\", operands);\n-  for (i = X86_64_SSE_REGPARM_MAX - 1; i >= INTVAL (operands[2]); i--)\n-    {\n-      operands[4] = adjust_address (operands[0], DImode, i*16);\n-      operands[5] = gen_rtx_REG (TImode, SSE_REGNO (i));\n-      PUT_MODE (operands[4], TImode);\n-      if (GET_CODE (XEXP (operands[0], 0)) != PLUS)\n-        output_asm_insn (\"rex\", operands);\n-      if (crtl->stack_alignment_needed < 128)\n-        output_asm_insn (\"%vmovsd\\t{%5, %4|%4, %5}\", operands);\n-      else\n-        output_asm_insn (\"%vmovaps\\t{%5, %4|%4, %5}\", operands);\n-    }\n-  targetm.asm_out.internal_label (asm_out_file, \"L\",\n-\t\t\t\t  CODE_LABEL_NUMBER (operands[3]));\n-  return \"\";\n-}\n-  [(set_attr \"type\" \"other\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"length_address\" \"0\")\n-   ;; 2 bytes for jump and opernds[4] bytes for each save.\n-   (set (attr \"length\")\n-     (plus (const_int 2)\n-\t   (mult (symbol_ref (\"INTVAL (operands[5])\"))\n-\t\t (symbol_ref (\"X86_64_SSE_REGPARM_MAX - INTVAL (operands[2])\")))))\n-   (set_attr \"memory\" \"store\")\n-   (set_attr \"modrm\" \"0\")\n-   (set_attr \"prefix\" \"maybe_vex\")\n-   (set_attr \"mode\" \"DI\")])\n-\n (define_expand \"prefetch\"\n   [(prefetch (match_operand 0 \"address_operand\" \"\")\n \t     (match_operand:SI 1 \"const_int_operand\" \"\")"}]}