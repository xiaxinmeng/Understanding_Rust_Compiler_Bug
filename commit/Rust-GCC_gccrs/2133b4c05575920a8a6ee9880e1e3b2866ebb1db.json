{"sha": "2133b4c05575920a8a6ee9880e1e3b2866ebb1db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEzM2I0YzA1NTc1OTIwYThhNmVlOTg4MGUxZTNiMjg2NmViYjFkYg==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2007-06-11T06:41:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-11T06:41:43Z"}, "message": "g-stsifd-sockets.adb (Create): Work around strange behavior of 'bind' on windows that causes 'connect' to fail...\n\n2007-06-11  Bob Duff  <duff@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\n\t* g-stsifd-sockets.adb (Create): Work around strange behavior of\n\t'bind' on windows that causes 'connect' to fail intermittently, by\n\tretrying the 'bind'.\n\t(GNAT.Sockets.Thin.Signalling_Fds): New procedure Close.\n\nFrom-SVN: r125612", "tree": {"sha": "2c8b8470053f9d536715e8afa970de1988516cd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c8b8470053f9d536715e8afa970de1988516cd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2133b4c05575920a8a6ee9880e1e3b2866ebb1db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2133b4c05575920a8a6ee9880e1e3b2866ebb1db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2133b4c05575920a8a6ee9880e1e3b2866ebb1db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2133b4c05575920a8a6ee9880e1e3b2866ebb1db/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85e053e9726e3639c11213295645e979e8dfff61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85e053e9726e3639c11213295645e979e8dfff61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85e053e9726e3639c11213295645e979e8dfff61"}], "stats": {"total": 159, "additions": 101, "deletions": 58}, "files": [{"sha": "02c852cad8685cf1f966e1e5705627cb8197215c", "filename": "gcc/ada/g-stsifd-sockets.adb", "status": "modified", "additions": 101, "deletions": 58, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2133b4c05575920a8a6ee9880e1e3b2866ebb1db/gcc%2Fada%2Fg-stsifd-sockets.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2133b4c05575920a8a6ee9880e1e3b2866ebb1db/gcc%2Fada%2Fg-stsifd-sockets.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-stsifd-sockets.adb?ref=2133b4c05575920a8a6ee9880e1e3b2866ebb1db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2006, AdaCore                     --\n+--                     Copyright (C) 2001-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,10 +37,23 @@\n --  Note: this code used to be in GNAT.Sockets, but has been moved to a\n --  platform-specific file. It is now used only for non-UNIX platforms.\n \n-separate\n-  (GNAT.Sockets.Thin)\n+separate (GNAT.Sockets.Thin)\n package body Signalling_Fds is\n \n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (Sig : C.int) is\n+      Res : C.int;\n+      pragma Unreferenced (Res);\n+      --  Res is assigned but never read, because we purposefully ignore\n+      --  any error returned by the C_Close system call, as per the spec\n+      --  of this procedure.\n+   begin\n+      Res := C_Close (Sig);\n+   end Close;\n+\n    ------------\n    -- Create --\n    ------------\n@@ -50,83 +63,111 @@ package body Signalling_Fds is\n       --  Listening socket, read socket and write socket\n \n       Sin : aliased Sockaddr_In;\n-      Len : aliased C.int := Sin'Size / 8;\n+      Len : aliased C.int;\n       --  Address of listening socket\n \n       Res : C.int;\n       --  Return status of system calls\n \n-      Err : Integer;\n-      --  Saved errno value\n-\n    begin\n-      Fds (Read_End)  := Failure;\n-      Fds (Write_End) := Failure;\n+      Fds.all := (Read_End | Write_End => Failure);\n \n       --  We open two signalling sockets. One of them is used to send data\n       --  to the other, which is included in a C_Select socket set. The\n       --  communication is used to force the call to C_Select to complete,\n       --  and the waiting task to resume its execution.\n \n-      --  Create a listening socket\n+      loop\n+         --  Retry loop, in case the C_Connect below fails\n \n-      L_Sock := C_Socket (Constants.AF_INET, Constants.SOCK_STREAM, 0);\n+         --  Create a listening socket\n \n-      if L_Sock = Failure then\n-         goto Fail;\n-      end if;\n+         L_Sock := C_Socket (Constants.AF_INET, Constants.SOCK_STREAM, 0);\n \n-      --  Bind the socket to an available port on localhost\n+         if L_Sock = Failure then\n+            goto Fail;\n+         end if;\n \n-      Sin.Sin_Addr.S_B1 := 127;\n-      Sin.Sin_Addr.S_B2 := 0;\n-      Sin.Sin_Addr.S_B3 := 0;\n-      Sin.Sin_Addr.S_B4 := 1;\n-      Sin.Sin_Port := 0;\n+         --  Bind the socket to an available port on localhost\n \n-      Res := C_Bind (L_Sock, Sin'Address, Len);\n+         Len := Sin'Size / 8;\n+         Set_Length (Sin'Unchecked_Access, Len);\n+         Sin.Sin_Family    := Constants.AF_INET;\n+         Sin.Sin_Addr.S_B1 := 127;\n+         Sin.Sin_Addr.S_B2 := 0;\n+         Sin.Sin_Addr.S_B3 := 0;\n+         Sin.Sin_Addr.S_B4 := 1;\n+         Sin.Sin_Port      := 0;\n \n-      if Res = Failure then\n-         goto Fail;\n-      end if;\n+         Res := C_Bind (L_Sock, Sin'Address, Len);\n \n-      --  Get assigned port\n+         if Res = Failure then\n+            goto Fail;\n+         end if;\n \n-      Res := C_Getsockname (L_Sock, Sin'Address, Len'Access);\n-      if Res = Failure then\n-         goto Fail;\n-      end if;\n+         --  Get assigned port\n \n-      --  Set socket to listen mode, with a backlog of 1 to guarantee that\n-      --  exactly one call to connect(2) succeeds.\n+         Res := C_Getsockname (L_Sock, Sin'Address, Len'Access);\n+         if Res = Failure then\n+            goto Fail;\n+         end if;\n \n-      Res := C_Listen (L_Sock, 1);\n+         --  Set socket to listen mode, with a backlog of 1 to guarantee that\n+         --  exactly one call to connect(2) succeeds.\n \n-      if Res = Failure then\n-         goto Fail;\n-      end if;\n+         Res := C_Listen (L_Sock, 1);\n \n-      --  Create read end (client) socket\n+         if Res = Failure then\n+            goto Fail;\n+         end if;\n \n-      R_Sock := C_Socket (Constants.AF_INET, Constants.SOCK_STREAM, 0);\n+         --  Create read end (client) socket\n \n-      if R_Sock = Failure then\n-         goto Fail;\n-      end if;\n+         R_Sock := C_Socket (Constants.AF_INET, Constants.SOCK_STREAM, 0);\n \n-      --  Connect listening socket\n+         if R_Sock = Failure then\n+            goto Fail;\n+         end if;\n \n-      Res := C_Connect (R_Sock, Sin'Address, Len);\n+         --  Connect listening socket\n \n-      if Res = Failure then\n-         goto Fail;\n-      end if;\n+         Res := C_Connect (R_Sock, Sin'Address, Len);\n+\n+         exit when Res /= Failure;\n+\n+         if Socket_Errno /= Constants.EADDRINUSE then\n+            goto Fail;\n+         end if;\n+\n+         --  In rare cases, the above C_Bind chooses a port that is still\n+         --  marked \"in use\", even though it has been closed (perhaps by some\n+         --  other process that has already exited). This causes the above\n+         --  C_Connect to fail with EADDRINUSE. In this case, we close the\n+         --  ports, and loop back to try again. This mysterious windows\n+         --  behavior is documented. See, for example:\n+         --    http://msdn2.microsoft.com/en-us/library/ms737625.aspx\n+         --  In an experiment with 2000 calls, 21 required exactly one retry, 7\n+         --  required two, and none required three or more. Note that no delay\n+         --  is needed between retries; retrying C_Bind will typically produce\n+         --  a different port.\n+\n+         pragma Assert (Res = Failure\n+                          and then\n+                        Socket_Errno = Constants.EADDRINUSE);\n+         pragma Warnings (Off); -- useless assignment to \"Res\"\n+         Res := C_Close (W_Sock);\n+         pragma Warnings (On);\n+         W_Sock := Failure;\n+         Res := C_Close (R_Sock);\n+         R_Sock := Failure;\n+      end loop;\n \n       --  Since the call to connect(2) has suceeded and the backlog limit on\n       --  the listening socket is 1, we know that there is now exactly one\n       --  pending connection on L_Sock, which is the one from R_Sock.\n \n       W_Sock := C_Accept (L_Sock, Sin'Address, Len'Access);\n+\n       if W_Sock = Failure then\n          goto Fail;\n       end if;\n@@ -143,27 +184,29 @@ package body Signalling_Fds is\n \n       Res := C_Close (L_Sock);\n \n-      Fds (Read_End)  := R_Sock;\n-      Fds (Write_End) := W_Sock;\n+      Fds.all := (Read_End => R_Sock, Write_End => W_Sock);\n \n       return Success;\n \n    <<Fail>>\n-      Err := Socket_Errno;\n+      declare\n+         Saved_Errno : constant Integer := Socket_Errno;\n \n-      if W_Sock /= Failure then\n-         Res := C_Close (W_Sock);\n-      end if;\n+      begin\n+         if W_Sock /= Failure then\n+            Res := C_Close (W_Sock);\n+         end if;\n \n-      if R_Sock /= Failure then\n-         Res := C_Close (R_Sock);\n-      end if;\n+         if R_Sock /= Failure then\n+            Res := C_Close (R_Sock);\n+         end if;\n \n-      if L_Sock /= Failure then\n-         Res := C_Close (L_Sock);\n-      end if;\n+         if L_Sock /= Failure then\n+            Res := C_Close (L_Sock);\n+         end if;\n \n-      Set_Socket_Errno (Err);\n+         Set_Socket_Errno (Saved_Errno);\n+      end;\n \n       return Failure;\n    end Create;"}]}