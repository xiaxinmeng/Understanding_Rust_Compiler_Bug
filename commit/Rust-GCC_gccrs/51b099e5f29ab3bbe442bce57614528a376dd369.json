{"sha": "51b099e5f29ab3bbe442bce57614528a376dd369", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFiMDk5ZTVmMjlhYjNiYmU0NDJiY2U1NzYxNDUyOGEzNzZkZDM2OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-10-18T05:56:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-10-18T05:56:04Z"}, "message": "re PR c++/21908 (poor diagnostic with vitrual base classes)\n\n\tPR c++/21908\n\t* call.c (build_new_method_call): Do not show VTT parameters to\n\tthe user.\n\nFrom-SVN: r105542", "tree": {"sha": "0aa343dc27966640e6f942efa2a498c8c6b7b947", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0aa343dc27966640e6f942efa2a498c8c6b7b947"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51b099e5f29ab3bbe442bce57614528a376dd369", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b099e5f29ab3bbe442bce57614528a376dd369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b099e5f29ab3bbe442bce57614528a376dd369", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b099e5f29ab3bbe442bce57614528a376dd369/comments", "author": null, "committer": null, "parents": [{"sha": "1630e763dc5319fd41fa5befde95173439d14de7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1630e763dc5319fd41fa5befde95173439d14de7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1630e763dc5319fd41fa5befde95173439d14de7"}], "stats": {"total": 72, "additions": 36, "deletions": 36}, "files": [{"sha": "e000b55716ce3193eaa0e166e33348f794275969", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b099e5f29ab3bbe442bce57614528a376dd369/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b099e5f29ab3bbe442bce57614528a376dd369/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=51b099e5f29ab3bbe442bce57614528a376dd369", "patch": "@@ -1,3 +1,9 @@\n+2005-10-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/21908\n+\t* call.c (build_new_method_call): Do not show VTT parameters to\n+\tthe user.\n+\n 2005-10-17  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/23440"}, {"sha": "77cbe2a5ae5171312a79b159fb8d329e6be5cca6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b099e5f29ab3bbe442bce57614528a376dd369/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b099e5f29ab3bbe442bce57614528a376dd369/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=51b099e5f29ab3bbe442bce57614528a376dd369", "patch": "@@ -5262,75 +5262,69 @@ build_new_method_call (tree instance, tree fns, tree args,\n       || args == error_mark_node)\n     return error_mark_node;\n \n-  orig_instance = instance;\n-  orig_fns = fns;\n-  orig_args = args;\n-\n-  if (processing_template_decl)\n-    {\n-      instance = build_non_dependent_expr (instance);\n-      if (!BASELINK_P (fns)\n-\t  && TREE_CODE (fns) != PSEUDO_DTOR_EXPR\n-\t  && TREE_TYPE (fns) != unknown_type_node)\n-\tfns = build_non_dependent_expr (fns);\n-      args = build_non_dependent_args (orig_args);\n-    }\n-\n-  /* Process the argument list.  */\n-  user_args = args;\n-  args = resolve_args (args);\n-  if (args == error_mark_node)\n-    return error_mark_node;\n-\n-  basetype = TYPE_MAIN_VARIANT (TREE_TYPE (instance));\n-  instance_ptr = build_this (instance);\n-\n   if (!BASELINK_P (fns))\n     {\n       error (\"call to non-function %qD\", fns);\n       return error_mark_node;\n     }\n \n+  orig_instance = instance;\n+  orig_fns = fns;\n+  orig_args = args;\n+\n+  /* Dismantle the baselink to collect all the information we need.  */  \n   if (!conversion_path)\n     conversion_path = BASELINK_BINFO (fns);\n   access_binfo = BASELINK_ACCESS_BINFO (fns);\n   optype = BASELINK_OPTYPE (fns);\n   fns = BASELINK_FUNCTIONS (fns);\n-\n   if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n     {\n       explicit_targs = TREE_OPERAND (fns, 1);\n       fns = TREE_OPERAND (fns, 0);\n       template_only = 1;\n     }\n-\n   gcc_assert (TREE_CODE (fns) == FUNCTION_DECL\n \t      || TREE_CODE (fns) == TEMPLATE_DECL\n \t      || TREE_CODE (fns) == OVERLOAD);\n+  fn = get_first_fn (fns);\n+  name = DECL_NAME (fn);\n \n-  /* XXX this should be handled before we get here.  */\n-  if (! IS_AGGR_TYPE (basetype))\n-    {\n-      if ((flags & LOOKUP_COMPLAIN) && basetype != error_mark_node)\n-\terror (\"request for member %qD in %qE, which is of non-aggregate \"\n-\t       \"type %qT\",\n-\t       fns, instance, basetype);\n+  basetype = TYPE_MAIN_VARIANT (TREE_TYPE (instance));\n+  gcc_assert (CLASS_TYPE_P (basetype));\n \n-      return error_mark_node;\n+  if (processing_template_decl)\n+    {\n+      instance = build_non_dependent_expr (instance);\n+      args = build_non_dependent_args (orig_args);\n     }\n \n-  fn = get_first_fn (fns);\n-  name = DECL_NAME (fn);\n-\n+  /* The USER_ARGS are the arguments we will display to users if an\n+     error occurs.  The USER_ARGS should not include any\n+     compiler-generated arguments.  The \"this\" pointer hasn't been\n+     added yet.  However, we must remove the VTT pointer if this is a\n+     call to a base-class constructor or destructor.  */\n+  user_args = args;\n   if (IDENTIFIER_CTOR_OR_DTOR_P (name))\n     {\n       /* Callers should explicitly indicate whether they want to construct\n \t the complete object or just the part without virtual bases.  */\n       gcc_assert (name != ctor_identifier);\n       /* Similarly for destructors.  */\n       gcc_assert (name != dtor_identifier);\n+      /* Remove the VTT pointer, if present.  */\n+      if ((name == base_ctor_identifier || name == base_dtor_identifier)\n+\t  && CLASSTYPE_VBASECLASSES (basetype))\n+\tuser_args = TREE_CHAIN (user_args);\n     }\n \n+  /* Process the argument list.  */\n+  args = resolve_args (args);\n+  if (args == error_mark_node)\n+    return error_mark_node;\n+\n+  instance_ptr = build_this (instance);\n+\n   /* It's OK to call destructors on cv-qualified objects.  Therefore,\n      convert the INSTANCE_PTR to the unqualified type, if necessary.  */\n   if (DECL_DESTRUCTOR_P (fn))"}]}