{"sha": "6adcb793611207a5b6aeb30c9670ab083f2ed03c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFkY2I3OTM2MTEyMDdhNWI2YWViMzBjOTY3MGFiMDgzZjJlZDAzYw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-08T12:14:57Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-08T12:14:57Z"}, "message": "Use symtab_summary in ipa-reference.c.\n\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* ipa-reference.c (remove_node_data): Remove.\n\t(duplicate_node_data): Likewise.\n\t(class ipa_ref_var_info_summary_t): New class.\n\t(class ipa_ref_opt_summary_t): Likewise.\n\t(get_reference_vars_info): Use ipa_ref_var_info_summaries.\n\t(get_reference_optimization_summary): Use\n\tipa_ref_opt_sum_summaries.\n\t(set_reference_vars_info): Remove.\n\t(set_reference_optimization_summary): Likewise.\n\t(ipa_init): Create summaries.\n\t(init_function_info): Use function summary.\n\t(ipa_ref_opt_summary_t::duplicate): New function.\n\t(ipa_ref_opt_summary_t::remove): New function.\n\t(get_read_write_all_from_node): Fix GNU coding style.\n\t(propagate): Use function summary.\n\t(write_node_summary_p): Fix GNU coding style.\n\t(stream_out_bitmap): Likewise.\n\t(ipa_reference_read_optimization_summary): Use function summary.\n\t(ipa_reference_c_finalize): Do not release hooks.\n\nFrom-SVN: r261312", "tree": {"sha": "a0345614b20ee7168fae4e18fe8e85ef7c030e7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0345614b20ee7168fae4e18fe8e85ef7c030e7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6adcb793611207a5b6aeb30c9670ab083f2ed03c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6adcb793611207a5b6aeb30c9670ab083f2ed03c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6adcb793611207a5b6aeb30c9670ab083f2ed03c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6adcb793611207a5b6aeb30c9670ab083f2ed03c/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf9b0b5fce429ec34dbda16f5e284420ac6d0fae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf9b0b5fce429ec34dbda16f5e284420ac6d0fae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf9b0b5fce429ec34dbda16f5e284420ac6d0fae"}], "stats": {"total": 227, "additions": 117, "deletions": 110}, "files": [{"sha": "5d10daed4050595c02e165daf5a776faf2b3a6fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adcb793611207a5b6aeb30c9670ab083f2ed03c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adcb793611207a5b6aeb30c9670ab083f2ed03c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6adcb793611207a5b6aeb30c9670ab083f2ed03c", "patch": "@@ -1,3 +1,25 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-reference.c (remove_node_data): Remove.\n+\t(duplicate_node_data): Likewise.\n+\t(class ipa_ref_var_info_summary_t): New class.\n+\t(class ipa_ref_opt_summary_t): Likewise.\n+\t(get_reference_vars_info): Use ipa_ref_var_info_summaries.\n+\t(get_reference_optimization_summary): Use\n+\tipa_ref_opt_sum_summaries.\n+\t(set_reference_vars_info): Remove.\n+\t(set_reference_optimization_summary): Likewise.\n+\t(ipa_init): Create summaries.\n+\t(init_function_info): Use function summary.\n+\t(ipa_ref_opt_summary_t::duplicate): New function.\n+\t(ipa_ref_opt_summary_t::remove): New function.\n+\t(get_read_write_all_from_node): Fix GNU coding style.\n+\t(propagate): Use function summary.\n+\t(write_node_summary_p): Fix GNU coding style.\n+\t(stream_out_bitmap): Likewise.\n+\t(ipa_reference_read_optimization_summary): Use function summary.\n+\t(ipa_reference_c_finalize): Do not release hooks.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-fnsummary.c (dump_ipa_call_summary): Use ::get method."}, {"sha": "9a9e94c3414637d4c4a8babbde10e5d8b987cc0c", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 95, "deletions": 110, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adcb793611207a5b6aeb30c9670ab083f2ed03c/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adcb793611207a5b6aeb30c9670ab083f2ed03c/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=6adcb793611207a5b6aeb30c9670ab083f2ed03c", "patch": "@@ -49,12 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"splay-tree.h\"\n #include \"ipa-utils.h\"\n #include \"ipa-reference.h\"\n-\n-static void remove_node_data (struct cgraph_node *node,\n-\t\t\t      void *data ATTRIBUTE_UNUSED);\n-static void duplicate_node_data (struct cgraph_node *src,\n-\t\t\t\t struct cgraph_node *dst,\n-\t\t\t\t void *data ATTRIBUTE_UNUSED);\n+#include \"symbol-summary.h\"\n \n /* The static variables defined within the compilation unit that are\n    loaded or stored directly by function that owns this structure.  */\n@@ -84,9 +79,10 @@ struct ipa_reference_optimization_summary_d\n   bitmap statics_not_written;\n };\n \n-typedef struct ipa_reference_local_vars_info_d *ipa_reference_local_vars_info_t;\n-typedef struct ipa_reference_global_vars_info_d *ipa_reference_global_vars_info_t;\n-typedef struct ipa_reference_optimization_summary_d *ipa_reference_optimization_summary_t;\n+typedef ipa_reference_local_vars_info_d *ipa_reference_local_vars_info_t;\n+typedef ipa_reference_global_vars_info_d *ipa_reference_global_vars_info_t;\n+typedef ipa_reference_optimization_summary_d *\n+  ipa_reference_optimization_summary_t;\n \n struct ipa_reference_vars_info_d\n {\n@@ -114,57 +110,55 @@ static bitmap_obstack local_info_obstack;\n /* Obstack holding global analysis live forever.  */\n static bitmap_obstack optimization_summary_obstack;\n \n-/* Holders of ipa cgraph hooks: */\n-static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n-static struct cgraph_node_hook_list *node_removal_hook_holder;\n+class ipa_ref_var_info_summary_t: public function_summary\n+\t\t\t  <ipa_reference_vars_info_d *>\n+{\n+public:\n+  ipa_ref_var_info_summary_t (symbol_table *symtab):\n+    function_summary <ipa_reference_vars_info_d *> (symtab) {}\n+};\n \n-/* Vector where the reference var infos are actually stored. \n-   Indexed by UID of call graph nodes.  */\n-static vec<ipa_reference_vars_info_t> ipa_reference_vars_vector;\n+static ipa_ref_var_info_summary_t *ipa_ref_var_info_summaries = NULL;\n \n-/* TODO: find a place where we should release the vector.  */\n-static vec<ipa_reference_optimization_summary_t> ipa_reference_opt_sum_vector;\n+class ipa_ref_opt_summary_t: public function_summary\n+\t\t\t     <ipa_reference_optimization_summary_d *>\n+{\n+public:\n+  ipa_ref_opt_summary_t (symbol_table *symtab):\n+    function_summary <ipa_reference_optimization_summary_d *> (symtab) {}\n+\n+\n+  virtual void remove (cgraph_node *src_node,\n+\t\t       ipa_reference_optimization_summary_d *data);\n+  virtual void duplicate (cgraph_node *src_node, cgraph_node *dst_node,\n+\t\t\t  ipa_reference_optimization_summary_d *src_data,\n+\t\t\t  ipa_reference_optimization_summary_d *dst_data);\n+};\n+\n+static ipa_ref_opt_summary_t *ipa_ref_opt_sum_summaries = NULL;\n \n /* Return the ipa_reference_vars structure starting from the cgraph NODE.  */\n static inline ipa_reference_vars_info_t\n get_reference_vars_info (struct cgraph_node *node)\n {\n-  if (!ipa_reference_vars_vector.exists ()\n-      || ipa_reference_vars_vector.length () <= (unsigned int) node->uid)\n+  if (ipa_ref_var_info_summaries == NULL)\n     return NULL;\n-  return ipa_reference_vars_vector[node->uid];\n+\n+  ipa_reference_vars_info_t v = ipa_ref_var_info_summaries->get (node);\n+  return v == NULL ? NULL : v;\n }\n \n /* Return the ipa_reference_vars structure starting from the cgraph NODE.  */\n static inline ipa_reference_optimization_summary_t\n get_reference_optimization_summary (struct cgraph_node *node)\n {\n-  if (!ipa_reference_opt_sum_vector.exists ()\n-      || (ipa_reference_opt_sum_vector.length () <= (unsigned int) node->uid))\n+  if (ipa_ref_opt_sum_summaries == NULL)\n     return NULL;\n-  return ipa_reference_opt_sum_vector[node->uid];\n-}\n \n-/* Return the ipa_reference_vars structure starting from the cgraph NODE.  */\n-static inline void\n-set_reference_vars_info (struct cgraph_node *node,\n-\t\t\t ipa_reference_vars_info_t info)\n-{\n-  if (!ipa_reference_vars_vector.exists ()\n-      || ipa_reference_vars_vector.length () <= (unsigned int) node->uid)\n-    ipa_reference_vars_vector.safe_grow_cleared (node->uid + 1);\n-  ipa_reference_vars_vector[node->uid] = info;\n-}\n+  ipa_reference_optimization_summary_t v\n+    = ipa_ref_opt_sum_summaries->get (node);\n \n-/* Return the ipa_reference_vars structure starting from the cgraph NODE.  */\n-static inline void\n-set_reference_optimization_summary (struct cgraph_node *node,\n-\t\t\t\t    ipa_reference_optimization_summary_t info)\n-{\n-  if (!ipa_reference_opt_sum_vector.exists ()\n-      || (ipa_reference_opt_sum_vector.length () <= (unsigned int) node->uid))\n-    ipa_reference_opt_sum_vector.safe_grow_cleared (node->uid + 1);\n-  ipa_reference_opt_sum_vector[node->uid] = info;\n+  return v == NULL ? NULL : v;\n }\n \n /* Return a bitmap indexed by ipa_reference_var_uid for the static variables\n@@ -430,10 +424,14 @@ ipa_init (void)\n   all_module_statics = BITMAP_ALLOC (&optimization_summary_obstack);\n   ignore_module_statics = BITMAP_ALLOC (&optimization_summary_obstack);\n \n-  node_removal_hook_holder =\n-      symtab->add_cgraph_removal_hook (&remove_node_data, NULL);\n-  node_duplication_hook_holder =\n-      symtab->add_cgraph_duplication_hook (&duplicate_node_data, NULL);\n+  if (ipa_ref_var_info_summaries == NULL)\n+    ipa_ref_var_info_summaries = new ipa_ref_var_info_summary_t (symtab);\n+\n+  if (ipa_ref_opt_sum_summaries != NULL)\n+    {\n+      delete ipa_ref_opt_sum_summaries;\n+      ipa_ref_opt_sum_summaries = NULL;\n+    }\n }\n \n \n@@ -443,10 +441,7 @@ static ipa_reference_local_vars_info_t\n init_function_info (struct cgraph_node *fn)\n {\n   ipa_reference_vars_info_t info\n-    = XCNEW (struct ipa_reference_vars_info_d);\n-\n-  /* Add the info to the tree's annotation.  */\n-  set_reference_vars_info (fn, info);\n+    = ipa_ref_var_info_summaries->get_create (fn);\n \n   info->local.statics_read = BITMAP_ALLOC (&local_info_obstack);\n   info->local.statics_written = BITMAP_ALLOC (&local_info_obstack);\n@@ -510,18 +505,12 @@ analyze_function (struct cgraph_node *fn)\n \n /* Called when new clone is inserted to callgraph late.  */\n \n-static void\n-duplicate_node_data (struct cgraph_node *src, struct cgraph_node *dst,\n-\t \t     void *data ATTRIBUTE_UNUSED)\n+void\n+ipa_ref_opt_summary_t::duplicate (cgraph_node *, cgraph_node *,\n+\t\t\t\t  ipa_reference_optimization_summary_d *ginfo,\n+\t\t\t\t  ipa_reference_optimization_summary_d\n+\t\t\t\t  *dst_ginfo)\n {\n-  ipa_reference_optimization_summary_t ginfo;\n-  ipa_reference_optimization_summary_t dst_ginfo;\n-\n-  ginfo = get_reference_optimization_summary (src);\n-  if (!ginfo)\n-    return;\n-  dst_ginfo = XCNEW (struct ipa_reference_optimization_summary_d);\n-  set_reference_optimization_summary (dst, dst_ginfo);\n   dst_ginfo->statics_not_read =\n     copy_static_var_set (ginfo->statics_not_read);\n   dst_ginfo->statics_not_written =\n@@ -530,23 +519,17 @@ duplicate_node_data (struct cgraph_node *src, struct cgraph_node *dst,\n \n /* Called when node is removed.  */\n \n-static void\n-remove_node_data (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+void\n+ipa_ref_opt_summary_t::remove (cgraph_node *,\n+\t\t\t       ipa_reference_optimization_summary_d *ginfo)\n {\n-  ipa_reference_optimization_summary_t ginfo;\n-  ginfo = get_reference_optimization_summary (node);\n-  if (ginfo)\n-    {\n-      if (ginfo->statics_not_read\n-\t  && ginfo->statics_not_read != all_module_statics)\n-\tBITMAP_FREE (ginfo->statics_not_read);\n-\n-      if (ginfo->statics_not_written\n-\t  && ginfo->statics_not_written != all_module_statics)\n-\tBITMAP_FREE (ginfo->statics_not_written);\n-      free (ginfo);\n-      set_reference_optimization_summary (node, NULL);\n-    }\n+  if (ginfo->statics_not_read\n+      && ginfo->statics_not_read != all_module_statics)\n+    BITMAP_FREE (ginfo->statics_not_read);\n+\n+  if (ginfo->statics_not_written\n+      && ginfo->statics_not_written != all_module_statics)\n+    BITMAP_FREE (ginfo->statics_not_written);\n }\n \n /* Analyze each function in the cgraph to see which global or statics\n@@ -671,7 +654,8 @@ get_read_write_all_from_node (struct cgraph_node *node,\n       struct cgraph_node *callee = e->callee->function_symbol (&avail);\n       gcc_checking_assert (callee);\n       if (avail <= AVAIL_INTERPOSABLE\n-          || (callee->analyzed && !opt_for_fn (callee->decl, flag_ipa_reference)))\n+\t  || (callee->analyzed && !opt_for_fn (callee->decl,\n+\t\t\t\t\t       flag_ipa_reference)))\n \tread_write_all_from_decl (callee, read_all, write_all);\n     }\n \n@@ -849,12 +833,14 @@ propagate (void)\n \t}\n     }\n \n+  if (ipa_ref_opt_sum_summaries == NULL)\n+    ipa_ref_opt_sum_summaries = new ipa_ref_opt_summary_t (symtab);\n+\n   /* Cleanup. */\n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       ipa_reference_vars_info_t node_info;\n       ipa_reference_global_vars_info_t node_g;\n-      ipa_reference_optimization_summary_t opt;\n \n       node_info = get_reference_vars_info (node);\n       if (!node->alias && opt_for_fn (node->decl, flag_ipa_reference)\n@@ -863,8 +849,8 @@ propagate (void)\n \t{\n \t  node_g = &node_info->global;\n \n-\t  opt = XCNEW (struct ipa_reference_optimization_summary_d);\n-\t  set_reference_optimization_summary (node, opt);\n+\t  ipa_reference_optimization_summary_d *opt\n+\t    = ipa_ref_opt_sum_summaries->get_create (node);\n \n \t  /* Create the complimentary sets.  */\n \n@@ -892,14 +878,20 @@ propagate (void)\n \t\t\t\t  node_g->statics_written);\n \t    }\n \t}\n-      free (node_info);\n    }\n \n   ipa_free_postorder_info ();\n   free (order);\n \n   bitmap_obstack_release (&local_info_obstack);\n-  ipa_reference_vars_vector.release ();\n+\n+  if (ipa_ref_var_info_summaries == NULL)\n+    {\n+      delete ipa_ref_var_info_summaries;\n+      ipa_ref_var_info_summaries = NULL;\n+    }\n+\n+  ipa_ref_var_info_summaries = NULL;\n   if (dump_file)\n     splay_tree_delete (reference_vars_to_consider);\n   reference_vars_to_consider = NULL;\n@@ -919,8 +911,9 @@ write_node_summary_p (struct cgraph_node *node,\n   if (!node->definition || node->global.inlined_to)\n     return false;\n   info = get_reference_optimization_summary (node);\n-  if (!info || (bitmap_empty_p (info->statics_not_read)\n-\t\t&& bitmap_empty_p (info->statics_not_written)))\n+  if (!info\n+      || (bitmap_empty_p (info->statics_not_read)\n+\t  && bitmap_empty_p (info->statics_not_written)))\n     return false;\n \n   /* See if we want to encode it.\n@@ -970,7 +963,8 @@ stream_out_bitmap (struct lto_simple_output_block *ob,\n     return;\n   EXECUTE_IF_AND_IN_BITMAP (bits, ltrans_statics, 0, index, bi)\n     {\n-      tree decl = (tree)splay_tree_lookup (reference_vars_to_consider, index)->value;\n+      tree decl = (tree)splay_tree_lookup (reference_vars_to_consider,\n+\t\t\t\t\t   index)->value;\n       lto_output_var_decl_index (ob->decl_state, ob->main_stream, decl);\n     }\n }\n@@ -1060,10 +1054,9 @@ ipa_reference_read_optimization_summary (void)\n   unsigned int j = 0;\n   bitmap_obstack_initialize (&optimization_summary_obstack);\n \n-  node_removal_hook_holder =\n-      symtab->add_cgraph_removal_hook (&remove_node_data, NULL);\n-  node_duplication_hook_holder =\n-      symtab->add_cgraph_duplication_hook (&duplicate_node_data, NULL);\n+  if (ipa_ref_opt_sum_summaries == NULL)\n+    ipa_ref_opt_sum_summaries = new ipa_ref_opt_summary_t (symtab);\n+\n   all_module_statics = BITMAP_ALLOC (&optimization_summary_obstack);\n \n   while ((file_data = file_data_vec[j++]))\n@@ -1099,18 +1092,21 @@ ipa_reference_read_optimization_summary (void)\n \t    {\n \t      unsigned int j, index;\n \t      struct cgraph_node *node;\n-\t      ipa_reference_optimization_summary_t info;\n \t      int v_count;\n \t      lto_symtab_encoder_t encoder;\n \n \t      index = streamer_read_uhwi (ib);\n \t      encoder = file_data->symtab_node_encoder;\n \t      node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref\n \t\t(encoder, index));\n-\t      info = XCNEW (struct ipa_reference_optimization_summary_d);\n-\t      set_reference_optimization_summary (node, info);\n-\t      info->statics_not_read = BITMAP_ALLOC (&optimization_summary_obstack);\n-\t      info->statics_not_written = BITMAP_ALLOC (&optimization_summary_obstack);\n+\n+\t      ipa_reference_optimization_summary_d *info\n+\t\t= ipa_ref_opt_sum_summaries->get_create (node);\n+\n+\t      info->statics_not_read = BITMAP_ALLOC\n+\t\t(&optimization_summary_obstack);\n+\t      info->statics_not_written = BITMAP_ALLOC\n+\t\t(&optimization_summary_obstack);\n \t      if (dump_file)\n \t\tfprintf (dump_file,\n \t\t\t \"\\nFunction name:%s:\\n  static not read:\",\n@@ -1167,9 +1163,9 @@ ipa_reference_read_optimization_summary (void)\n \t\t\t\t\t  ib, data, len);\n \t}\n       else\n-\t/* Fatal error here.  We do not want to support compiling ltrans units with\n-\t   different version of compiler or different flags than the WPA unit, so\n-\t   this should never happen.  */\n+\t/* Fatal error here.  We do not want to support compiling ltrans units\n+\t   with different version of compiler or different flags than\n+\t   the WPA unit, so this should never happen.  */\n \tfatal_error (input_location,\n \t\t     \"ipa reference summary is missing in ltrans unit\");\n     }\n@@ -1239,15 +1235,4 @@ ipa_reference_c_finalize (void)\n       bitmap_obstack_release (&optimization_summary_obstack);\n       ipa_init_p = false;\n     }\n-\n-  if (node_removal_hook_holder)\n-    {\n-      symtab->remove_cgraph_removal_hook (node_removal_hook_holder);\n-      node_removal_hook_holder = NULL;\n-    }\n-  if (node_duplication_hook_holder)\n-    {\n-      symtab->remove_cgraph_duplication_hook (node_duplication_hook_holder);\n-      node_duplication_hook_holder = NULL;\n-    }\n }"}]}