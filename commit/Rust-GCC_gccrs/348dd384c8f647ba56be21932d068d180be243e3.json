{"sha": "348dd384c8f647ba56be21932d068d180be243e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ4ZGQzODRjOGY2NDdiYTU2YmUyMTkzMmQwNjhkMTgwYmUyNDNlMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2019-04-29T15:22:41Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2019-04-29T15:22:41Z"}, "message": "[C++ PATCH] some cleanups\n\nhttps://gcc.gnu.org/ml/gcc-patches/2019-04/msg01174.html\n\t* decl.c (duplicate_decls): Add whitespace, move comments into\n\tconditional blocks.\n\t* method.c (explain_implicit_non_constexpr): Refactor.\n\t* pt.c (check_explicit_specialization): Fix indentation.\n\t* semantics.c (process_outer_var_ref): Reformat.\n\t(finish_id_expression_1): Use STRIP_TEMPLATE.\n\nFrom-SVN: r270655", "tree": {"sha": "d90b262f2e2e18807b5a05fa37174d4ad1ceb35b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d90b262f2e2e18807b5a05fa37174d4ad1ceb35b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/348dd384c8f647ba56be21932d068d180be243e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348dd384c8f647ba56be21932d068d180be243e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/348dd384c8f647ba56be21932d068d180be243e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348dd384c8f647ba56be21932d068d180be243e3/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "074084767c9d7c4d52d919c343b65bb61c564096", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/074084767c9d7c4d52d919c343b65bb61c564096", "html_url": "https://github.com/Rust-GCC/gccrs/commit/074084767c9d7c4d52d919c343b65bb61c564096"}], "stats": {"total": 65, "additions": 34, "deletions": 31}, "files": [{"sha": "56503247233607177bcf07855675fbd9e5a97a49", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348dd384c8f647ba56be21932d068d180be243e3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348dd384c8f647ba56be21932d068d180be243e3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=348dd384c8f647ba56be21932d068d180be243e3", "patch": "@@ -1,3 +1,12 @@\n+2019-04-29  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* decl.c (duplicate_decls): Add whitespace, move comments into\n+\tconditional blocks.\n+\t* method.c (explain_implicit_non_constexpr): Refactor.\n+\t* pt.c (check_explicit_specialization): Fix indentation.\n+\t* semantics.c (process_outer_var_ref): Reformat.\n+\t(finish_id_expression_1): Use STRIP_TEMPLATE.\n+\n 2019-04-26  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR c++/90243 - orphaned note in uninstantiated constexpr function"}, {"sha": "5c4a38e7980408a3157a83651869ea89d094777e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348dd384c8f647ba56be21932d068d180be243e3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348dd384c8f647ba56be21932d068d180be243e3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=348dd384c8f647ba56be21932d068d180be243e3", "patch": "@@ -1,4 +1,4 @@\n-/* Process declarations and variables for C++ compiler.\n+/* Process declarations and variables for -*- C++ -*- compiler.\n    Copyright (C) 1988-2019 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -1476,7 +1476,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \n \t\t  if (! same_type_p (TREE_VALUE (t1), TREE_VALUE (t2)))\n \t\t    break;\n-next_arg:;\n+\t\tnext_arg:;\n \t\t}\n \n \t      warning_at (newdecl_loc,\n@@ -2386,9 +2386,10 @@ next_arg:;\n \t    }\n \t  DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n \t}\n-      /* Only functions have these fields.  */\n+\n       if (DECL_DECLARES_FUNCTION_P (newdecl))\n \t{\n+\t  /* Only functions have these fields.  */\n \t  DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);\n \t  DECL_BEFRIENDING_CLASSES (newdecl)\n \t    = chainon (DECL_BEFRIENDING_CLASSES (newdecl),\n@@ -2398,10 +2399,12 @@ next_arg:;\n \t  if (DECL_VIRTUAL_P (newdecl))\n \t    SET_DECL_THUNKS (newdecl, DECL_THUNKS (olddecl));\n \t}\n-      /* Only variables have this field.  */\n-      else if (VAR_P (newdecl)\n-\t       && VAR_HAD_UNKNOWN_BOUND (olddecl))\n-\tSET_VAR_HAD_UNKNOWN_BOUND (newdecl);\n+      else if (VAR_P (newdecl))\n+\t{\n+\t  /* Only variables have this field.  */\n+\t  if (VAR_HAD_UNKNOWN_BOUND (olddecl))\n+\t    SET_VAR_HAD_UNKNOWN_BOUND (newdecl);\n+\t}\n     }\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)"}, {"sha": "d92da09a74cc5d1e80d21d745cd85ead1a95a331", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348dd384c8f647ba56be21932d068d180be243e3/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348dd384c8f647ba56be21932d068d180be243e3/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=348dd384c8f647ba56be21932d068d180be243e3", "patch": "@@ -1884,15 +1884,14 @@ maybe_explain_implicit_delete (tree decl)\n void\n explain_implicit_non_constexpr (tree decl)\n {\n-  tree parm_type = TREE_VALUE (FUNCTION_FIRST_USER_PARMTYPE (decl));\n-  bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));\n+  tree parms = FUNCTION_FIRST_USER_PARMTYPE (decl);\n+  bool const_p = CP_TYPE_CONST_P (non_reference (TREE_VALUE (parms)));\n   tree inh = DECL_INHERITED_CTOR (decl);\n   bool dummy;\n   synthesized_method_walk (DECL_CLASS_CONTEXT (decl),\n \t\t\t   special_function_p (decl), const_p,\n \t\t\t   NULL, NULL, NULL, &dummy, true,\n-\t\t\t   &inh,\n-\t\t\t   FUNCTION_FIRST_USER_PARMTYPE (decl));\n+\t\t\t   &inh, parms);\n }\n \n /* DECL is an instantiation of an inheriting constructor template.  Deduce"}, {"sha": "3e8c70b0d154537d57d09238626c83291d89dfe0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348dd384c8f647ba56be21932d068d180be243e3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348dd384c8f647ba56be21932d068d180be243e3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=348dd384c8f647ba56be21932d068d180be243e3", "patch": "@@ -3026,7 +3026,7 @@ check_explicit_specialization (tree declarator,\n \t     `operator T'.  Grab all the conversion operators, and\n \t     then select from them.  */\n \t  tree fns = get_class_binding (ctype, IDENTIFIER_CONV_OP_P (name)\n-\t\t\t\t      ? conv_op_identifier : name);\n+\t\t\t\t\t? conv_op_identifier : name);\n \n \t  if (fns == NULL_TREE)\n \t    {"}, {"sha": "c919365733321895fecc055e26e1d855d38474e0", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348dd384c8f647ba56be21932d068d180be243e3/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348dd384c8f647ba56be21932d068d180be243e3/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=348dd384c8f647ba56be21932d068d180be243e3", "patch": "@@ -3482,16 +3482,12 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain, bool odr_use)\n \t/* A lambda in an NSDMI (c++/64496).  */\n \tbreak;\n \n-      if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr)\n-\t  == CPLD_NONE)\n+      if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) == CPLD_NONE)\n \tbreak;\n \n-      lambda_stack = tree_cons (NULL_TREE,\n-\t\t\t\tlambda_expr,\n-\t\t\t\tlambda_stack);\n+      lambda_stack = tree_cons (NULL_TREE, lambda_expr, lambda_stack);\n \n-      containing_function\n-\t= decl_function_context (containing_function);\n+      containing_function = decl_function_context (containing_function);\n     }\n \n   /* In a lambda within a template, wait until instantiation time to implicitly\n@@ -3502,8 +3498,7 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain, bool odr_use)\n       && DECL_PACK_P (decl))\n     return decl;\n \n-  if (lambda_expr && VAR_P (decl)\n-      && DECL_ANON_UNION_VAR_P (decl))\n+  if (lambda_expr && VAR_P (decl) && DECL_ANON_UNION_VAR_P (decl))\n     {\n       if (complain & tf_error)\n \terror (\"cannot capture member %qD of anonymous union\", decl);\n@@ -3512,11 +3507,8 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain, bool odr_use)\n   /* Do lambda capture when processing the id-expression, not when\n      odr-using a variable.  */\n   if (!odr_use && context == containing_function)\n-    {\n-      decl = add_default_capture (lambda_stack,\n-\t\t\t\t  /*id=*/DECL_NAME (decl),\n-\t\t\t\t  initializer);\n-    }\n+    decl = add_default_capture (lambda_stack,\n+\t\t\t\t/*id=*/DECL_NAME (decl), initializer);\n   /* Only an odr-use of an outer automatic variable causes an\n      error, and a constant variable can decay to a prvalue\n      constant without odr-use.  So don't complain yet.  */\n@@ -3528,8 +3520,7 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain, bool odr_use)\n \t{\n \t  error (\"%qD is not captured\", decl);\n \t  tree closure = LAMBDA_EXPR_CLOSURE (lambda_expr);\n-\t  if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr)\n-\t      == CPLD_NONE)\n+\t  if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) == CPLD_NONE)\n \t    inform (location_of (closure),\n \t\t    \"the lambda has no capture-default\");\n \t  else if (TYPE_CLASS_SCOPE_P (closure))\n@@ -3844,10 +3835,11 @@ finish_id_expression_1 (tree id_expression,\n \t}\n       else if (is_overloaded_fn (decl))\n \t{\n+\t  /* We only need to look at the first function,\n+\t     because all the fns share the attribute we're\n+\t     concerned with (all member fns or all non-members).  */\n \t  tree first_fn = get_first_fn (decl);\n-\n-\t  if (TREE_CODE (first_fn) == TEMPLATE_DECL)\n-\t    first_fn = DECL_TEMPLATE_RESULT (first_fn);\n+\t  first_fn = STRIP_TEMPLATE (first_fn);\n \n \t  /* [basic.def.odr]: \"A function whose name appears as a\n \t     potentially-evaluated expression is odr-used if it is the unique"}]}