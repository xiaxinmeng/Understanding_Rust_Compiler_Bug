{"sha": "90376fadb87083f9990804ce6b6588004241be77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTAzNzZmYWRiODcwODNmOTk5MDgwNGNlNmI2NTg4MDA0MjQxYmU3Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2011-12-15T15:28:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-15T15:28:47Z"}, "message": "a-numaux-vms.ads, [...]: New files.\n\n2011-12-15  Arnaud Charlet  <charlet@adacore.com>\n\n        * a-numaux-vms.ads, s-asthan-vms-ia64.adb, s-auxdec-vms-ia64.adb,       \n        s-memory-vms_64.adb, s-memory-vms_64.ads, s-osinte-vms-ia64.adb,\n        s-osinte-vms-ia64.ads, s-tasdeb-vms.adb: New files.\n\nFrom-SVN: r182374", "tree": {"sha": "24bda10610cfd6725c0ec72e45209ee9f204e755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24bda10610cfd6725c0ec72e45209ee9f204e755"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90376fadb87083f9990804ce6b6588004241be77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90376fadb87083f9990804ce6b6588004241be77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90376fadb87083f9990804ce6b6588004241be77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90376fadb87083f9990804ce6b6588004241be77/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c5c7b003e8dec16f3cb887aa08c7f5241ee6fcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5c7b003e8dec16f3cb887aa08c7f5241ee6fcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c5c7b003e8dec16f3cb887aa08c7f5241ee6fcc"}], "stats": {"total": 4521, "additions": 4521, "deletions": 0}, "files": [{"sha": "5c936f2fc6a8798e35dda52283415c9bf7324b42", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=90376fadb87083f9990804ce6b6588004241be77", "patch": "@@ -1,3 +1,9 @@\n+2011-12-15  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* a-numaux-vms.ads, s-asthan-vms-ia64.adb, s-auxdec-vms-ia64.adb,\n+\ts-memory-vms_64.adb, s-memory-vms_64.ads, s-osinte-vms-ia64.adb,\n+\ts-osinte-vms-ia64.ads, s-tasdeb-vms.adb: New files.\n+\n 2011-12-15  Vincent Pucci  <pucci@adacore.com>\n \n \t* aspects.adb, aspects.ads Aspect_Dimension and"}, {"sha": "7cd7cfeb255ed2e39871a38f26b695a4cbb3b2fa", "filename": "gcc/ada/a-numaux-vms.ads", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fa-numaux-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fa-numaux-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-numaux-vms.ads?ref=90376fadb87083f9990804ce6b6588004241be77", "patch": "@@ -0,0 +1,104 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                     A D A . N U M E R I C S . A U X                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                             (VMS Version)                                --\n+--                                                                          --\n+--          Copyright (C) 2003-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides the basic computational interface for the generic\n+--  elementary functions. The C library version interfaces with the routines\n+--  in the C mathematical library, and is thus quite portable, although it may\n+--  not necessarily meet the requirements for accuracy in the numerics annex.\n+\n+--  This is the VMS version\n+\n+package Ada.Numerics.Aux is\n+   pragma Pure;\n+\n+   type Double is digits 15;\n+   pragma Float_Representation (IEEE_Float, Double);\n+   --  Type Double is the type used to call the C routines. Note that this\n+   --  is IEEE format even when running on VMS with VAX_Native representation\n+   --  since we use the IEEE version of the C library with VMS.\n+\n+   --  We import these functions directly from C. Note that we label them\n+   --  all as pure functions, because indeed all of them are in fact pure!\n+\n+   function Sin (X : Double) return Double;\n+   pragma Import (C, Sin, \"MATH$SIN_T\");\n+   pragma Pure_Function (Sin);\n+\n+   function Cos (X : Double) return Double;\n+   pragma Import (C, Cos, \"MATH$COS_T\");\n+   pragma Pure_Function (Cos);\n+\n+   function Tan (X : Double) return Double;\n+   pragma Import (C, Tan, \"MATH$TAN_T\");\n+   pragma Pure_Function (Tan);\n+\n+   function Exp (X : Double) return Double;\n+   pragma Import (C, Exp, \"MATH$EXP_T\");\n+   pragma Pure_Function (Exp);\n+\n+   function Sqrt (X : Double) return Double;\n+   pragma Import (C, Sqrt, \"MATH$SQRT_T\");\n+   pragma Pure_Function (Sqrt);\n+\n+   function Log (X : Double) return Double;\n+   pragma Import (C, Log, \"DECC$TLOG_2\");\n+   pragma Pure_Function (Log);\n+\n+   function Acos (X : Double) return Double;\n+   pragma Import (C, Acos, \"MATH$ACOS_T\");\n+   pragma Pure_Function (Acos);\n+\n+   function Asin (X : Double) return Double;\n+   pragma Import (C, Asin, \"MATH$ASIN_T\");\n+   pragma Pure_Function (Asin);\n+\n+   function Atan (X : Double) return Double;\n+   pragma Import (C, Atan, \"MATH$ATAN_T\");\n+   pragma Pure_Function (Atan);\n+\n+   function Sinh (X : Double) return Double;\n+   pragma Import (C, Sinh, \"MATH$SINH_T\");\n+   pragma Pure_Function (Sinh);\n+\n+   function Cosh (X : Double) return Double;\n+   pragma Import (C, Cosh, \"MATH$COSH_T\");\n+   pragma Pure_Function (Cosh);\n+\n+   function Tanh (X : Double) return Double;\n+   pragma Import (C, Tanh, \"MATH$TANH_T\");\n+   pragma Pure_Function (Tanh);\n+\n+   function Pow (X, Y : Double) return Double;\n+   pragma Import (C, Pow, \"DECC$TPOW_2\");\n+   pragma Pure_Function (Pow);\n+\n+end Ada.Numerics.Aux;"}, {"sha": "e5cdfaeee672600eeb88d6cf1e7930d1b2f54b85", "filename": "gcc/ada/s-asthan-vms-ia64.adb", "status": "added", "additions": 608, "deletions": 0, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-asthan-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-asthan-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-asthan-vms-ia64.adb?ref=90376fadb87083f9990804ce6b6588004241be77", "patch": "@@ -0,0 +1,608 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                  S Y S T E M . A S T _ H A N D L I N G                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--         Copyright (C) 1996-2010, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the OpenVMS/IA64 version\n+\n+with System; use System;\n+\n+with System.IO;\n+\n+with System.Machine_Code;\n+with System.Parameters;\n+\n+with System.Tasking;\n+with System.Tasking.Rendezvous;\n+with System.Tasking.Initialization;\n+with System.Tasking.Utilities;\n+\n+with System.Task_Primitives;\n+with System.Task_Primitives.Operations;\n+with System.Task_Primitives.Operations.DEC;\n+\n+with Ada.Finalization;\n+with Ada.Task_Attributes;\n+\n+with Ada.Exceptions; use Ada.Exceptions;\n+\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n+\n+package body System.AST_Handling is\n+\n+   package ATID renames Ada.Task_Identification;\n+\n+   package SP   renames System.Parameters;\n+   package ST   renames System.Tasking;\n+   package STR  renames System.Tasking.Rendezvous;\n+   package STI  renames System.Tasking.Initialization;\n+   package STU  renames System.Tasking.Utilities;\n+\n+   package STPO renames System.Task_Primitives.Operations;\n+   package STPOD renames System.Task_Primitives.Operations.DEC;\n+\n+   AST_Lock : aliased System.Task_Primitives.RTS_Lock;\n+   --  This is a global lock; it is used to execute in mutual exclusion\n+   --  from all other AST tasks.  It is only used by Lock_AST and\n+   --  Unlock_AST.\n+\n+   procedure Lock_AST (Self_ID : ST.Task_Id);\n+   --  Locks out other AST tasks. Preceding a section of code by Lock_AST and\n+   --  following it by Unlock_AST creates a critical region.\n+\n+   procedure Unlock_AST (Self_ID : ST.Task_Id);\n+   --  Releases lock previously set by call to Lock_AST.\n+   --  All nested locks must be released before other tasks competing for the\n+   --  tasking lock are released.\n+\n+   --------------\n+   -- Lock_AST --\n+   --------------\n+\n+   procedure Lock_AST (Self_ID : ST.Task_Id) is\n+   begin\n+      STI.Defer_Abort_Nestable (Self_ID);\n+      STPO.Write_Lock (AST_Lock'Access, Global_Lock => True);\n+   end Lock_AST;\n+\n+   ----------------\n+   -- Unlock_AST --\n+   ----------------\n+\n+   procedure Unlock_AST (Self_ID : ST.Task_Id) is\n+   begin\n+      STPO.Unlock (AST_Lock'Access, Global_Lock => True);\n+      STI.Undefer_Abort_Nestable (Self_ID);\n+   end Unlock_AST;\n+\n+   ---------------------------------\n+   -- AST_Handler Data Structures --\n+   ---------------------------------\n+\n+   --  As noted in the private part of the spec of System.Aux_DEC, the\n+   --  AST_Handler type is simply a pointer to a procedure that takes\n+   --  a single 64bit parameter. The following is a local copy\n+   --  of that definition.\n+\n+   --  We need our own copy because we need to get our hands on this\n+   --  and we cannot see the private part of System.Aux_DEC. We don't\n+   --  want to be a child of Aux_Dec because of complications resulting\n+   --  from the use of pragma Extend_System. We will use unchecked\n+   --  conversions between the two versions of the declarations.\n+\n+   type AST_Handler is access procedure (Param : Long_Integer);\n+\n+   --  However, this declaration is somewhat misleading, since the values\n+   --  referenced by AST_Handler values (all produced in this package by\n+   --  calls to Create_AST_Handler) are highly stylized.\n+\n+   --  The first point is that in VMS/I64, procedure pointers do not in\n+   --  fact point to code, but rather to a procedure descriptor.\n+   --  So a value of type AST_Handler is in fact a pointer to one of\n+   --  descriptors.\n+\n+   type Descriptor_Type is\n+   record\n+      Entry_Point : System.Address;\n+      GP_Value    : System.Address;\n+   end record;\n+   for  Descriptor_Type'Alignment use Standard'Maximum_Alignment;\n+   --  pragma Warnings (Off, Descriptor_Type);\n+   --  Suppress harmless warnings about alignment.\n+   --  Should explain why this warning is harmless ???\n+\n+   type Descriptor_Ref is access all Descriptor_Type;\n+\n+   --  Normally, there is only one such descriptor for a given procedure, but\n+   --  it works fine to make a copy of the single allocated descriptor, and\n+   --  use the copy itself, and we take advantage of this in the design here.\n+   --  The idea is that AST_Handler values will all point to a record with the\n+   --  following structure:\n+\n+   --  Note: When we say it works fine, there is one delicate point, which\n+   --  is that the code for the AST procedure itself requires the original\n+   --  descriptor address.  We handle this by saving the orignal descriptor\n+   --  address in this structure and restoring in Process_AST.\n+\n+   type AST_Handler_Data is record\n+      Descriptor              : Descriptor_Type;\n+      Original_Descriptor_Ref : Descriptor_Ref;\n+      Taskid                  : ATID.Task_Id;\n+      Entryno                 : Natural;\n+   end record;\n+\n+   type AST_Handler_Data_Ref is access all AST_Handler_Data;\n+\n+   function To_AST_Handler is new Ada.Unchecked_Conversion\n+     (AST_Handler_Data_Ref, System.Aux_DEC.AST_Handler);\n+\n+   --  Each time Create_AST_Handler is called, a new value of this record\n+   --  type is created, containing a copy of the procedure descriptor for\n+   --  the routine used to handle all AST's (Process_AST), and the Task_Id\n+   --  and entry number parameters identifying the task entry involved.\n+\n+   --  The AST_Handler value returned is a pointer to this record. Since\n+   --  the record starts with the procedure descriptor, it can be used\n+   --  by the system in the normal way to call the procedure. But now\n+   --  when the procedure gets control, it can determine the address of\n+   --  the procedure descriptor used to call it (since the ABI specifies\n+   --  that this is left sitting in register r27 on entry), and then use\n+   --  that address to retrieve the Task_Id and entry number so that it\n+   --  knows on which entry to queue the AST request.\n+\n+   --  The next issue is where are these records placed. Since we intend\n+   --  to pass pointers to these records to asynchronous system service\n+   --  routines, they have to be on the heap, which means we have to worry\n+   --  about when to allocate them and deallocate them.\n+\n+   --  We solve this problem by introducing a task attribute that points to\n+   --  a vector, indexed by the entry number, of AST_Handler_Data records\n+   --  for a given task. The pointer itself is a controlled object allowing\n+   --  us to write a finalization routine that frees the referenced vector.\n+\n+   --  An entry in this vector is either initialized (Entryno non-zero) and\n+   --  can be used for any subsequent reference to the same entry, or it is\n+   --  unused, marked by the Entryno value being zero.\n+\n+   type AST_Handler_Vector is array (Natural range <>) of AST_Handler_Data;\n+   type AST_Handler_Vector_Ref is access all AST_Handler_Vector;\n+\n+   type AST_Vector_Ptr is new Ada.Finalization.Controlled with record\n+      Vector : AST_Handler_Vector_Ref;\n+   end record;\n+\n+   procedure Finalize (Obj : in out AST_Vector_Ptr);\n+   --  Override Finalize so that the AST Vector gets freed.\n+\n+   procedure Finalize (Obj : in out AST_Vector_Ptr) is\n+      procedure Free is new\n+       Ada.Unchecked_Deallocation (AST_Handler_Vector, AST_Handler_Vector_Ref);\n+   begin\n+      if Obj.Vector /= null then\n+         Free (Obj.Vector);\n+      end if;\n+   end Finalize;\n+\n+   AST_Vector_Init : AST_Vector_Ptr;\n+   --  Initial value, treated as constant, Vector will be null\n+\n+   package AST_Attribute is new Ada.Task_Attributes\n+     (Attribute     => AST_Vector_Ptr,\n+      Initial_Value => AST_Vector_Init);\n+\n+   use AST_Attribute;\n+\n+   -----------------------\n+   -- AST Service Queue --\n+   -----------------------\n+\n+   --  The following global data structures are used to queue pending\n+   --  AST requests. When an AST is signalled, the AST service routine\n+   --  Process_AST is called, and it makes an entry in this structure.\n+\n+   type AST_Instance is record\n+      Taskid  : ATID.Task_Id;\n+      Entryno : Natural;\n+      Param   : Long_Integer;\n+   end record;\n+   --  The Taskid and Entryno indicate the entry on which this AST is to\n+   --  be queued, and Param is the parameter provided from the AST itself.\n+\n+   AST_Service_Queue_Size  : constant := 256;\n+   AST_Service_Queue_Limit : constant := 250;\n+   type AST_Service_Queue_Index is mod AST_Service_Queue_Size;\n+   --  Index used to refer to entries in the circular buffer which holds\n+   --  active AST_Instance values. The upper bound reflects the maximum\n+   --  number of AST instances that can be stored in the buffer. Since\n+   --  these entries are immediately serviced by the high priority server\n+   --  task that does the actual entry queuing, it is very unusual to have\n+   --  any significant number of entries simulaneously queued.\n+\n+   AST_Service_Queue : array (AST_Service_Queue_Index) of AST_Instance;\n+   pragma Volatile_Components (AST_Service_Queue);\n+   --  The circular buffer used to store active AST requests\n+\n+   AST_Service_Queue_Put : AST_Service_Queue_Index := 0;\n+   AST_Service_Queue_Get : AST_Service_Queue_Index := 0;\n+   pragma Atomic (AST_Service_Queue_Put);\n+   pragma Atomic (AST_Service_Queue_Get);\n+   --  These two variables point to the next slots in the AST_Service_Queue\n+   --  to be used for putting a new entry in and taking an entry out. This\n+   --  is a circular buffer, so these pointers wrap around. If the two values\n+   --  are equal the buffer is currently empty. The pointers are atomic to\n+   --  ensure proper synchronization between the single producer (namely the\n+   --  Process_AST procedure), and the single consumer (the AST_Service_Task).\n+\n+   --------------------------------\n+   -- AST Server Task Structures --\n+   --------------------------------\n+\n+   --  The basic approach is that when an AST comes in, a call is made to\n+   --  the Process_AST procedure. It queues the request in the service queue\n+   --  and then wakes up an AST server task to perform the actual call to the\n+   --  required entry. We use this intermediate server task, since the AST\n+   --  procedure itself cannot wait to return, and we need some caller for\n+   --  the rendezvous so that we can use the normal rendezvous mechanism.\n+\n+   --  It would work to have only one AST server task, but then we would lose\n+   --  all overlap in AST processing, and furthermore, we could get priority\n+   --  inversion effects resulting in starvation of AST requests.\n+\n+   --  We therefore maintain a small pool of AST server tasks. We adjust\n+   --  the size of the pool dynamically to reflect traffic, so that we have\n+   --  a sufficient number of server tasks to avoid starvation.\n+\n+   Max_AST_Servers : constant Natural := 16;\n+   --  Maximum number of AST server tasks that can be allocated\n+\n+   Num_AST_Servers : Natural := 0;\n+   --  Number of AST server tasks currently active\n+\n+   Num_Waiting_AST_Servers : Natural := 0;\n+   --  This is the number of AST server tasks that are either waiting for\n+   --  work, or just about to go to sleep and wait for work.\n+\n+   Is_Waiting : array (1 .. Max_AST_Servers) of Boolean := (others => False);\n+   --  An array of flags showing which AST server tasks are currently waiting\n+\n+   AST_Task_Ids : array (1 .. Max_AST_Servers) of ST.Task_Id;\n+   --  Task Id's of allocated AST server tasks\n+\n+   task type AST_Server_Task (Num : Natural) is\n+      pragma Priority (Priority'Last);\n+   end AST_Server_Task;\n+   --  Declaration for AST server task. This task has no entries, it is\n+   --  controlled by sleep and wakeup calls at the task primitives level.\n+\n+   type AST_Server_Task_Ptr is access all AST_Server_Task;\n+   --  Type used to allocate server tasks\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Allocate_New_AST_Server;\n+   --  Allocate an additional AST server task\n+\n+   procedure Process_AST (Param : Long_Integer);\n+   --  This is the central routine for processing all AST's, it is referenced\n+   --  as the code address of all created AST_Handler values. See detailed\n+   --  description in body to understand how it works to have a single such\n+   --  procedure for all AST's even though it does not get any indication of\n+   --  the entry involved passed as an explicit parameter. The single explicit\n+   --  parameter Param is the parameter passed by the system with the AST.\n+\n+   -----------------------------\n+   -- Allocate_New_AST_Server --\n+   -----------------------------\n+\n+   procedure Allocate_New_AST_Server is\n+      Dummy : AST_Server_Task_Ptr;\n+      pragma Unreferenced (Dummy);\n+\n+   begin\n+      if Num_AST_Servers = Max_AST_Servers then\n+         return;\n+\n+      else\n+         --  Note: it is safe to increment Num_AST_Servers immediately, since\n+         --  no one will try to activate this task until it indicates that it\n+         --  is sleeping by setting its entry in Is_Waiting to True.\n+\n+         Num_AST_Servers := Num_AST_Servers + 1;\n+         Dummy := new AST_Server_Task (Num_AST_Servers);\n+      end if;\n+   end Allocate_New_AST_Server;\n+\n+   ---------------------\n+   -- AST_Server_Task --\n+   ---------------------\n+\n+   task body AST_Server_Task is\n+      Taskid  : ATID.Task_Id;\n+      Entryno : Natural;\n+      Param   : aliased Long_Integer;\n+      Self_Id : constant ST.Task_Id := ST.Self;\n+\n+      pragma Volatile (Param);\n+\n+   begin\n+      --  By making this task independent of master, when the environment\n+      --  task is finalizing, the AST_Server_Task will be notified that it\n+      --  should terminate.\n+\n+      STU.Make_Independent;\n+\n+      --  Record our task Id for access by Process_AST\n+\n+      AST_Task_Ids (Num) := Self_Id;\n+\n+      --  Note: this entire task operates with the main task lock set, except\n+      --  when it is sleeping waiting for work, or busy doing a rendezvous\n+      --  with an AST server. This lock protects the data structures that\n+      --  are shared by multiple instances of the server task.\n+\n+      Lock_AST (Self_Id);\n+\n+      --  This is the main infinite loop of the task. We go to sleep and\n+      --  wait to be woken up by Process_AST when there is some work to do.\n+\n+      loop\n+         Num_Waiting_AST_Servers := Num_Waiting_AST_Servers + 1;\n+\n+         Unlock_AST (Self_Id);\n+\n+         STI.Defer_Abort (Self_Id);\n+\n+         if SP.Single_Lock then\n+            STPO.Lock_RTS;\n+         end if;\n+\n+         STPO.Write_Lock (Self_Id);\n+\n+         Is_Waiting (Num) := True;\n+\n+         Self_Id.Common.State := ST.AST_Server_Sleep;\n+         STPO.Sleep (Self_Id, ST.AST_Server_Sleep);\n+         Self_Id.Common.State := ST.Runnable;\n+\n+         STPO.Unlock (Self_Id);\n+\n+         if SP.Single_Lock then\n+            STPO.Unlock_RTS;\n+         end if;\n+\n+         --  If the process is finalizing, Undefer_Abort will simply end\n+         --  this task.\n+\n+         STI.Undefer_Abort (Self_Id);\n+\n+         --  We are awake, there is something to do!\n+\n+         Lock_AST (Self_Id);\n+         Num_Waiting_AST_Servers := Num_Waiting_AST_Servers - 1;\n+\n+         --  Loop here to service outstanding requests. We are always\n+         --  locked on entry to this loop.\n+\n+         while AST_Service_Queue_Get /= AST_Service_Queue_Put loop\n+            Taskid  := AST_Service_Queue (AST_Service_Queue_Get).Taskid;\n+            Entryno := AST_Service_Queue (AST_Service_Queue_Get).Entryno;\n+            Param   := AST_Service_Queue (AST_Service_Queue_Get).Param;\n+\n+            AST_Service_Queue_Get := AST_Service_Queue_Get + 1;\n+\n+            --  This is a manual expansion of the normal call simple code\n+\n+            declare\n+               type AA is access all Long_Integer;\n+               P : AA := Param'Unrestricted_Access;\n+\n+               function To_ST_Task_Id is new Ada.Unchecked_Conversion\n+                 (ATID.Task_Id, ST.Task_Id);\n+\n+            begin\n+               Unlock_AST (Self_Id);\n+               STR.Call_Simple\n+                 (Acceptor           => To_ST_Task_Id (Taskid),\n+                  E                  => ST.Task_Entry_Index (Entryno),\n+                  Uninterpreted_Data => P'Address);\n+\n+            exception\n+               when E : others =>\n+                  System.IO.Put_Line (\"%Debugging event\");\n+                  System.IO.Put_Line (Exception_Name (E) &\n+                    \" raised when trying to deliver an AST.\");\n+\n+                  if Exception_Message (E)'Length /= 0 then\n+                     System.IO.Put_Line (Exception_Message (E));\n+                  end if;\n+\n+                  System.IO.Put_Line (\"Task type is \" & \"Receiver_Type\");\n+                  System.IO.Put_Line (\"Task id is \" & ATID.Image (Taskid));\n+            end;\n+\n+            Lock_AST (Self_Id);\n+         end loop;\n+      end loop;\n+   end AST_Server_Task;\n+\n+   ------------------------\n+   -- Create_AST_Handler --\n+   ------------------------\n+\n+   function Create_AST_Handler\n+     (Taskid  : ATID.Task_Id;\n+      Entryno : Natural) return System.Aux_DEC.AST_Handler\n+   is\n+      Attr_Ref : Attribute_Handle;\n+\n+      Process_AST_Ptr : constant AST_Handler := Process_AST'Access;\n+      --  Reference to standard procedure descriptor for Process_AST\n+\n+      function To_Descriptor_Ref is new Ada.Unchecked_Conversion\n+        (AST_Handler, Descriptor_Ref);\n+\n+      Original_Descriptor_Ref : constant Descriptor_Ref :=\n+                                  To_Descriptor_Ref (Process_AST_Ptr);\n+\n+   begin\n+      if ATID.Is_Terminated (Taskid) then\n+         raise Program_Error;\n+      end if;\n+\n+      Attr_Ref := Reference (Taskid);\n+\n+      --  Allocate another server if supply is getting low\n+\n+      if Num_Waiting_AST_Servers < 2 then\n+         Allocate_New_AST_Server;\n+      end if;\n+\n+      --  No point in creating more if we have zillions waiting to\n+      --  be serviced.\n+\n+      while AST_Service_Queue_Put - AST_Service_Queue_Get\n+         > AST_Service_Queue_Limit\n+      loop\n+         delay 0.01;\n+      end loop;\n+\n+      --  If no AST vector allocated, or the one we have is too short, then\n+      --  allocate one of right size and initialize all entries except the\n+      --  one we will use to unused. Note that the assignment automatically\n+      --  frees the old allocated table if there is one.\n+\n+      if Attr_Ref.Vector = null\n+        or else Attr_Ref.Vector'Length < Entryno\n+      then\n+         Attr_Ref.Vector := new AST_Handler_Vector (1 .. Entryno);\n+\n+         for E in 1 .. Entryno loop\n+            Attr_Ref.Vector (E).Descriptor.Entry_Point :=\n+              Original_Descriptor_Ref.Entry_Point;\n+            Attr_Ref.Vector (E).Descriptor.GP_Value :=\n+              Attr_Ref.Vector (E)'Address;\n+            Attr_Ref.Vector (E).Original_Descriptor_Ref :=\n+              Original_Descriptor_Ref;\n+            Attr_Ref.Vector (E).Taskid  := Taskid;\n+            Attr_Ref.Vector (E).Entryno := E;\n+         end loop;\n+      end if;\n+\n+      return To_AST_Handler (Attr_Ref.Vector (Entryno)'Unrestricted_Access);\n+   end Create_AST_Handler;\n+\n+   ----------------------------\n+   -- Expand_AST_Packet_Pool --\n+   ----------------------------\n+\n+   procedure Expand_AST_Packet_Pool\n+     (Requested_Packets : Natural;\n+      Actual_Number     : out Natural;\n+      Total_Number      : out Natural)\n+   is\n+      pragma Unreferenced (Requested_Packets);\n+   begin\n+      --  The AST implementation of GNAT does not permit dynamic expansion\n+      --  of the pool, so we simply add no entries and return the total. If\n+      --  it is necessary to expand the allocation, then this package body\n+      --  must be recompiled with a larger value for AST_Service_Queue_Size.\n+\n+      Actual_Number := 0;\n+      Total_Number := AST_Service_Queue_Size;\n+   end Expand_AST_Packet_Pool;\n+\n+   -----------------\n+   -- Process_AST --\n+   -----------------\n+\n+   procedure Process_AST (Param : Long_Integer) is\n+\n+      Handler_Data_Ptr : AST_Handler_Data_Ref;\n+      --  This variable is set to the address of the descriptor through\n+      --  which Process_AST is called. Since the descriptor is part of\n+      --  an AST_Handler value, this is also the address of this value,\n+      --  from which we can obtain the task and entry number information.\n+\n+      function To_Address is new Ada.Unchecked_Conversion\n+        (ST.Task_Id, System.Task_Primitives.Task_Address);\n+\n+   begin\n+      --  Move the contrived GP into place so Taskid and Entryno\n+      --  become available, then restore the true GP.\n+\n+      System.Machine_Code.Asm\n+        (Template => \"mov %0 = r1\",\n+         Outputs  => AST_Handler_Data_Ref'Asm_Output\n+          (\"=r\", Handler_Data_Ptr),\n+         Volatile => True);\n+\n+      System.Machine_Code.Asm\n+        (Template => \"ld8 r1 = %0;;\",\n+         Inputs => System.Address'Asm_Input\n+           (\"m\", Handler_Data_Ptr.Original_Descriptor_Ref.GP_Value),\n+         Volatile => True);\n+\n+      AST_Service_Queue (AST_Service_Queue_Put) := AST_Instance'\n+        (Taskid  => Handler_Data_Ptr.Taskid,\n+         Entryno => Handler_Data_Ptr.Entryno,\n+         Param   => Param);\n+\n+      --  OpenVMS Programming Concepts manual, chapter 8.2.3:\n+      --  \"Implicit synchronization can be achieved for data that is shared\n+      --   for write by using only AST routines to write the data, since only\n+      --   one AST can be running at any one time.\"\n+\n+      --  This subprogram runs at AST level so is guaranteed to be\n+      --  called sequentially at a given access level.\n+\n+      AST_Service_Queue_Put := AST_Service_Queue_Put + 1;\n+\n+      --  Need to wake up processing task. If there is no waiting server\n+      --  then we have temporarily run out, but things should still be\n+      --  OK, since one of the active ones will eventually pick up the\n+      --  service request queued in the AST_Service_Queue.\n+\n+      for J in 1 .. Num_AST_Servers loop\n+         if Is_Waiting (J) then\n+            Is_Waiting (J) := False;\n+\n+            --  Sleeps are handled by ASTs on VMS, so don't call Wakeup\n+\n+            STPOD.Interrupt_AST_Handler (To_Address (AST_Task_Ids (J)));\n+            exit;\n+         end if;\n+      end loop;\n+   end Process_AST;\n+\n+begin\n+   STPO.Initialize_Lock (AST_Lock'Access, STPO.Global_Task_Level);\n+end System.AST_Handling;"}, {"sha": "86bec06f2a9266603eb42a2e2d22f212c096e12d", "filename": "gcc/ada/s-auxdec-vms-ia64.adb", "status": "added", "additions": 576, "deletions": 0, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-auxdec-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-auxdec-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec-vms-ia64.adb?ref=90376fadb87083f9990804ce6b6588004241be77", "patch": "@@ -0,0 +1,576 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . A U X _ D E C                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Itanium/VMS version.\n+\n+--  The Add,Clear_Interlocked subprograms are dubiously implmented due to\n+--  the lack of a single bit sync_lock_test_and_set builtin.\n+\n+--  The \"Retry\" parameter is ignored due to the lack of retry builtins making\n+--  the subprograms identical to the non-retry versions.\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off alpha ordering check on subprograms, this unit is laid\n+--  out to correspond to the declarations in the DEC 83 System unit.\n+\n+with Interfaces;\n+package body System.Aux_DEC is\n+\n+   use type Interfaces.Unsigned_8;\n+\n+   ------------------------\n+   -- Fetch_From_Address --\n+   ------------------------\n+\n+   function Fetch_From_Address (A : Address) return Target is\n+      type T_Ptr is access all Target;\n+      function To_T_Ptr is new Ada.Unchecked_Conversion (Address, T_Ptr);\n+      Ptr : constant T_Ptr := To_T_Ptr (A);\n+   begin\n+      return Ptr.all;\n+   end Fetch_From_Address;\n+\n+   -----------------------\n+   -- Assign_To_Address --\n+   -----------------------\n+\n+   procedure Assign_To_Address (A : Address; T : Target) is\n+      type T_Ptr is access all Target;\n+      function To_T_Ptr is new Ada.Unchecked_Conversion (Address, T_Ptr);\n+      Ptr : constant T_Ptr := To_T_Ptr (A);\n+   begin\n+      Ptr.all := T;\n+   end Assign_To_Address;\n+\n+   -----------------------\n+   -- Clear_Interlocked --\n+   -----------------------\n+\n+   procedure Clear_Interlocked\n+     (Bit       : in out Boolean;\n+      Old_Value : out Boolean)\n+   is\n+      Clr_Bit : Boolean := Bit;\n+      Old_Uns : Interfaces.Unsigned_8;\n+\n+      function Sync_Lock_Test_And_Set\n+        (Ptr   : Address;\n+         Value : Interfaces.Unsigned_8) return Interfaces.Unsigned_8;\n+      pragma Import (Intrinsic, Sync_Lock_Test_And_Set,\n+                     \"__sync_lock_test_and_set_1\");\n+\n+   begin\n+      Old_Uns := Sync_Lock_Test_And_Set (Clr_Bit'Address, 0);\n+      Bit := Clr_Bit;\n+      Old_Value := Old_Uns /= 0;\n+   end Clear_Interlocked;\n+\n+   procedure Clear_Interlocked\n+     (Bit          : in out Boolean;\n+      Old_Value    : out Boolean;\n+      Retry_Count  : Natural;\n+      Success_Flag : out Boolean)\n+   is\n+      pragma Unreferenced (Retry_Count);\n+\n+      Clr_Bit : Boolean := Bit;\n+      Old_Uns : Interfaces.Unsigned_8;\n+\n+      function Sync_Lock_Test_And_Set\n+        (Ptr   : Address;\n+         Value : Interfaces.Unsigned_8) return Interfaces.Unsigned_8;\n+      pragma Import (Intrinsic, Sync_Lock_Test_And_Set,\n+                     \"__sync_lock_test_and_set_1\");\n+\n+   begin\n+      Old_Uns := Sync_Lock_Test_And_Set (Clr_Bit'Address, 0);\n+      Bit := Clr_Bit;\n+      Old_Value := Old_Uns /= 0;\n+      Success_Flag := True;\n+   end Clear_Interlocked;\n+\n+   ---------------------\n+   -- Set_Interlocked --\n+   ---------------------\n+\n+   procedure Set_Interlocked\n+     (Bit       : in out Boolean;\n+      Old_Value : out Boolean)\n+   is\n+      Set_Bit : Boolean := Bit;\n+      Old_Uns : Interfaces.Unsigned_8;\n+\n+      function Sync_Lock_Test_And_Set\n+        (Ptr   : Address;\n+         Value : Interfaces.Unsigned_8) return Interfaces.Unsigned_8;\n+      pragma Import (Intrinsic, Sync_Lock_Test_And_Set,\n+                     \"__sync_lock_test_and_set_1\");\n+\n+   begin\n+      Old_Uns := Sync_Lock_Test_And_Set (Set_Bit'Address, 1);\n+      Bit := Set_Bit;\n+      Old_Value := Old_Uns /= 0;\n+   end Set_Interlocked;\n+\n+   procedure Set_Interlocked\n+     (Bit          : in out Boolean;\n+      Old_Value    : out Boolean;\n+      Retry_Count  : Natural;\n+      Success_Flag : out Boolean)\n+   is\n+      pragma Unreferenced (Retry_Count);\n+\n+      Set_Bit : Boolean := Bit;\n+      Old_Uns : Interfaces.Unsigned_8;\n+\n+      function Sync_Lock_Test_And_Set\n+        (Ptr   : Address;\n+         Value : Interfaces.Unsigned_8) return Interfaces.Unsigned_8;\n+      pragma Import (Intrinsic, Sync_Lock_Test_And_Set,\n+                     \"__sync_lock_test_and_set_1\");\n+   begin\n+      Old_Uns := Sync_Lock_Test_And_Set (Set_Bit'Address, 1);\n+      Bit := Set_Bit;\n+      Old_Value := Old_Uns /= 0;\n+      Success_Flag := True;\n+   end Set_Interlocked;\n+\n+   ---------------------\n+   -- Add_Interlocked --\n+   ---------------------\n+\n+   procedure Add_Interlocked\n+     (Addend : Short_Integer;\n+      Augend : in out Aligned_Word;\n+      Sign   : out Integer)\n+   is\n+      Overflowed : Boolean := False;\n+      Former     : Aligned_Word;\n+\n+      function Sync_Fetch_And_Add\n+        (Ptr   : Address;\n+         Value : Short_Integer) return Short_Integer;\n+      pragma Import (Intrinsic, Sync_Fetch_And_Add, \"__sync_fetch_and_add_2\");\n+\n+   begin\n+      Former.Value := Sync_Fetch_And_Add (Augend.Value'Address, Addend);\n+\n+      if Augend.Value < 0 then\n+         Sign := -1;\n+      elsif Augend.Value > 0 then\n+         Sign := 1;\n+      else\n+         Sign := 0;\n+      end if;\n+\n+      if Former.Value > 0 and then Augend.Value <= 0 then\n+         Overflowed := True;\n+      end if;\n+\n+      if Overflowed then\n+         raise Constraint_Error;\n+      end if;\n+   end Add_Interlocked;\n+\n+   ----------------\n+   -- Add_Atomic --\n+   ----------------\n+\n+   procedure Add_Atomic\n+     (To     : in out Aligned_Integer;\n+      Amount : Integer)\n+   is\n+      procedure Sync_Add_And_Fetch\n+        (Ptr   : Address;\n+         Value : Integer);\n+      pragma Import (Intrinsic, Sync_Add_And_Fetch, \"__sync_add_and_fetch_4\");\n+   begin\n+      Sync_Add_And_Fetch (To.Value'Address, Amount);\n+   end Add_Atomic;\n+\n+   procedure Add_Atomic\n+     (To           : in out Aligned_Integer;\n+      Amount       : Integer;\n+      Retry_Count  : Natural;\n+      Old_Value    : out Integer;\n+      Success_Flag : out Boolean)\n+   is\n+      pragma Unreferenced (Retry_Count);\n+\n+      function Sync_Fetch_And_Add\n+        (Ptr   : Address;\n+         Value : Integer) return Integer;\n+      pragma Import (Intrinsic, Sync_Fetch_And_Add, \"__sync_fetch_and_add_4\");\n+\n+   begin\n+      Old_Value := Sync_Fetch_And_Add (To.Value'Address, Amount);\n+      Success_Flag := True;\n+   end Add_Atomic;\n+\n+   procedure Add_Atomic\n+     (To     : in out Aligned_Long_Integer;\n+      Amount : Long_Integer)\n+   is\n+      procedure Sync_Add_And_Fetch\n+        (Ptr   : Address;\n+         Value : Long_Integer);\n+      pragma Import (Intrinsic, Sync_Add_And_Fetch, \"__sync_add_and_fetch_8\");\n+   begin\n+      Sync_Add_And_Fetch (To.Value'Address, Amount);\n+   end Add_Atomic;\n+\n+   procedure Add_Atomic\n+     (To           : in out Aligned_Long_Integer;\n+      Amount       : Long_Integer;\n+      Retry_Count  : Natural;\n+      Old_Value    : out Long_Integer;\n+      Success_Flag : out Boolean)\n+   is\n+      pragma Unreferenced (Retry_Count);\n+\n+      function Sync_Fetch_And_Add\n+        (Ptr   : Address;\n+         Value : Long_Integer) return Long_Integer;\n+      pragma Import (Intrinsic, Sync_Fetch_And_Add, \"__sync_fetch_and_add_8\");\n+      --  Why do we keep importing this over and over again???\n+\n+   begin\n+      Old_Value := Sync_Fetch_And_Add (To.Value'Address, Amount);\n+      Success_Flag := True;\n+   end Add_Atomic;\n+\n+   ----------------\n+   -- And_Atomic --\n+   ----------------\n+\n+   procedure And_Atomic\n+     (To   : in out Aligned_Integer;\n+      From : Integer)\n+   is\n+      procedure Sync_And_And_Fetch\n+        (Ptr   : Address;\n+         Value : Integer);\n+      pragma Import (Intrinsic, Sync_And_And_Fetch, \"__sync_and_and_fetch_4\");\n+   begin\n+      Sync_And_And_Fetch (To.Value'Address, From);\n+   end And_Atomic;\n+\n+   procedure And_Atomic\n+     (To           : in out Aligned_Integer;\n+      From         : Integer;\n+      Retry_Count  : Natural;\n+      Old_Value    : out Integer;\n+      Success_Flag : out Boolean)\n+   is\n+      pragma Unreferenced (Retry_Count);\n+\n+      function Sync_Fetch_And_And\n+        (Ptr   : Address;\n+         Value : Integer) return Integer;\n+      pragma Import (Intrinsic, Sync_Fetch_And_And, \"__sync_fetch_and_and_4\");\n+\n+   begin\n+      Old_Value := Sync_Fetch_And_And (To.Value'Address, From);\n+      Success_Flag := True;\n+   end And_Atomic;\n+\n+   procedure And_Atomic\n+     (To   : in out Aligned_Long_Integer;\n+      From : Long_Integer)\n+   is\n+      procedure Sync_And_And_Fetch\n+        (Ptr   : Address;\n+         Value : Long_Integer);\n+      pragma Import (Intrinsic, Sync_And_And_Fetch, \"__sync_and_and_fetch_8\");\n+   begin\n+      Sync_And_And_Fetch (To.Value'Address, From);\n+   end And_Atomic;\n+\n+   procedure And_Atomic\n+     (To           : in out Aligned_Long_Integer;\n+      From         : Long_Integer;\n+      Retry_Count  : Natural;\n+      Old_Value    : out Long_Integer;\n+      Success_Flag : out Boolean)\n+   is\n+      pragma Unreferenced (Retry_Count);\n+\n+      function Sync_Fetch_And_And\n+        (Ptr   : Address;\n+         Value : Long_Integer) return Long_Integer;\n+      pragma Import (Intrinsic, Sync_Fetch_And_And, \"__sync_fetch_and_and_8\");\n+\n+   begin\n+      Old_Value := Sync_Fetch_And_And (To.Value'Address, From);\n+      Success_Flag := True;\n+   end And_Atomic;\n+\n+   ---------------\n+   -- Or_Atomic --\n+   ---------------\n+\n+   procedure Or_Atomic\n+     (To   : in out Aligned_Integer;\n+      From : Integer)\n+   is\n+      procedure Sync_Or_And_Fetch\n+        (Ptr   : Address;\n+         Value : Integer);\n+      pragma Import (Intrinsic, Sync_Or_And_Fetch, \"__sync_or_and_fetch_4\");\n+\n+   begin\n+      Sync_Or_And_Fetch (To.Value'Address, From);\n+   end Or_Atomic;\n+\n+   procedure Or_Atomic\n+     (To           : in out Aligned_Integer;\n+      From         : Integer;\n+      Retry_Count  : Natural;\n+      Old_Value    : out Integer;\n+      Success_Flag : out Boolean)\n+   is\n+      pragma Unreferenced (Retry_Count);\n+\n+      function Sync_Fetch_And_Or\n+        (Ptr   : Address;\n+         Value : Integer) return Integer;\n+      pragma Import (Intrinsic, Sync_Fetch_And_Or, \"__sync_fetch_and_or_4\");\n+\n+   begin\n+      Old_Value := Sync_Fetch_And_Or (To.Value'Address, From);\n+      Success_Flag := True;\n+   end Or_Atomic;\n+\n+   procedure Or_Atomic\n+     (To   : in out Aligned_Long_Integer;\n+      From : Long_Integer)\n+   is\n+      procedure Sync_Or_And_Fetch\n+        (Ptr   : Address;\n+         Value : Long_Integer);\n+      pragma Import (Intrinsic, Sync_Or_And_Fetch, \"__sync_or_and_fetch_8\");\n+   begin\n+      Sync_Or_And_Fetch (To.Value'Address, From);\n+   end Or_Atomic;\n+\n+   procedure Or_Atomic\n+     (To           : in out Aligned_Long_Integer;\n+      From         : Long_Integer;\n+      Retry_Count  : Natural;\n+      Old_Value    : out Long_Integer;\n+      Success_Flag : out Boolean)\n+   is\n+      pragma Unreferenced (Retry_Count);\n+\n+      function Sync_Fetch_And_Or\n+        (Ptr   : Address;\n+         Value : Long_Integer) return Long_Integer;\n+      pragma Import (Intrinsic, Sync_Fetch_And_Or, \"__sync_fetch_and_or_8\");\n+\n+   begin\n+      Old_Value := Sync_Fetch_And_Or (To.Value'Address, From);\n+      Success_Flag := True;\n+   end Or_Atomic;\n+\n+   ------------\n+   -- Insqhi --\n+   ------------\n+\n+   procedure Insqhi\n+     (Item   : Address;\n+      Header : Address;\n+      Status : out Insq_Status) is\n+\n+      procedure SYS_PAL_INSQHIL\n+        (STATUS : out Integer; Header : Address; ITEM : Address);\n+      pragma Interface (External, SYS_PAL_INSQHIL);\n+      pragma Import_Valued_Procedure (SYS_PAL_INSQHIL, \"SYS$PAL_INSQHIL\",\n+         (Integer, Address, Address),\n+         (Value, Value, Value));\n+\n+      Istat : Integer;\n+\n+   begin\n+      SYS_PAL_INSQHIL (Istat, Header, Item);\n+\n+      if Istat = 0 then\n+         Status := OK_Not_First;\n+      elsif Istat = 1 then\n+         Status := OK_First;\n+\n+      else\n+         --  This status is never returned on IVMS\n+\n+         Status := Fail_No_Lock;\n+      end if;\n+   end Insqhi;\n+\n+   ------------\n+   -- Remqhi --\n+   ------------\n+\n+   procedure Remqhi\n+     (Header : Address;\n+      Item   : out Address;\n+      Status : out Remq_Status)\n+   is\n+      --  The removed item is returned in the second function return register,\n+      --  R9 on IVMS. The VMS ABI calls for \"small\" records to be returned in\n+      --  these registers, so inventing this odd looking record type makes that\n+      --  all work.\n+\n+      type Remq is record\n+         Status : Long_Integer;\n+         Item   : Address;\n+      end record;\n+\n+      procedure SYS_PAL_REMQHIL\n+        (Remret : out Remq; Header : Address);\n+      pragma Interface (External, SYS_PAL_REMQHIL);\n+      pragma Import_Valued_Procedure\n+        (SYS_PAL_REMQHIL, \"SYS$PAL_REMQHIL\",\n+         (Remq, Address),\n+         (Value, Value));\n+\n+      --  Following variables need documentation???\n+\n+      Rstat  : Long_Integer;\n+      Remret : Remq;\n+\n+   begin\n+      SYS_PAL_REMQHIL (Remret, Header);\n+\n+      Rstat := Remret.Status;\n+      Item := Remret.Item;\n+\n+      if Rstat = 0 then\n+         Status := Fail_Was_Empty;\n+\n+      elsif Rstat = 1 then\n+         Status := OK_Not_Empty;\n+\n+      elsif Rstat = 2 then\n+         Status := OK_Empty;\n+\n+      else\n+         --  This status is never returned on IVMS\n+\n+         Status := Fail_No_Lock;\n+      end if;\n+\n+   end Remqhi;\n+\n+   ------------\n+   -- Insqti --\n+   ------------\n+\n+   procedure Insqti\n+     (Item   : Address;\n+      Header : Address;\n+      Status : out Insq_Status) is\n+\n+      procedure SYS_PAL_INSQTIL\n+        (STATUS : out Integer; Header : Address; ITEM : Address);\n+      pragma Interface (External, SYS_PAL_INSQTIL);\n+      pragma Import_Valued_Procedure (SYS_PAL_INSQTIL, \"SYS$PAL_INSQTIL\",\n+         (Integer, Address, Address),\n+         (Value, Value, Value));\n+\n+      Istat : Integer;\n+\n+   begin\n+      SYS_PAL_INSQTIL (Istat, Header, Item);\n+\n+      if Istat = 0 then\n+         Status := OK_Not_First;\n+\n+      elsif Istat = 1 then\n+         Status := OK_First;\n+\n+      else\n+         --  This status is never returned on IVMS\n+\n+         Status := Fail_No_Lock;\n+      end if;\n+   end Insqti;\n+\n+   ------------\n+   -- Remqti --\n+   ------------\n+\n+   procedure Remqti\n+     (Header : Address;\n+      Item   : out Address;\n+      Status : out Remq_Status)\n+   is\n+      --  The removed item is returned in the second function return register,\n+      --  R9 on IVMS. The VMS ABI calls for \"small\" records to be returned in\n+      --  these registers, so inventing (where is rest of this comment???)\n+\n+      type Remq is record\n+         Status : Long_Integer;\n+         Item   : Address;\n+      end record;\n+\n+      procedure SYS_PAL_REMQTIL\n+        (Remret : out Remq; Header : Address);\n+      pragma Interface (External, SYS_PAL_REMQTIL);\n+      pragma Import_Valued_Procedure (SYS_PAL_REMQTIL, \"SYS$PAL_REMQTIL\",\n+         (Remq, Address),\n+         (Value, Value));\n+\n+      Rstat  : Long_Integer;\n+      Remret : Remq;\n+\n+   begin\n+      SYS_PAL_REMQTIL (Remret, Header);\n+\n+      Rstat := Remret.Status;\n+      Item := Remret.Item;\n+\n+      --  Wouldn't case be nicer here, and in previous similar cases ???\n+\n+      if Rstat = 0 then\n+         Status := Fail_Was_Empty;\n+\n+      elsif Rstat = 1 then\n+         Status := OK_Not_Empty;\n+\n+      elsif Rstat = 2 then\n+         Status := OK_Empty;\n+      else\n+         --  This status is never returned on IVMS\n+\n+         Status := Fail_No_Lock;\n+      end if;\n+   end Remqti;\n+\n+end System.Aux_DEC;"}, {"sha": "d725e31a83a9f99670ee057960a93d97b2e1d120", "filename": "gcc/ada/s-memory-vms_64.adb", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-memory-vms_64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-memory-vms_64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-memory-vms_64.adb?ref=90376fadb87083f9990804ce6b6588004241be77", "patch": "@@ -0,0 +1,230 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                         S Y S T E M . M E M O R Y                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2001-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the VMS 64 bit implementation of this package\n+\n+--  This implementation assumes that the underlying malloc/free/realloc\n+--  implementation is thread safe, and thus, no additional lock is required.\n+--  Note that we still need to defer abort because on most systems, an\n+--  asynchronous signal (as used for implementing asynchronous abort of\n+--  task) cannot safely be handled while malloc is executing.\n+\n+--  If you are not using Ada constructs containing the \"abort\" keyword, then\n+--  you can remove the calls to Abort_Defer.all and Abort_Undefer.all from\n+--  this unit.\n+\n+pragma Compiler_Unit;\n+\n+with Ada.Exceptions;\n+with System.Soft_Links;\n+with System.Parameters;\n+with System.CRTL;\n+\n+package body System.Memory is\n+\n+   use Ada.Exceptions;\n+   use System.Soft_Links;\n+\n+   function c_malloc (Size : System.CRTL.size_t) return System.Address\n+    renames System.CRTL.malloc;\n+\n+   procedure c_free (Ptr : System.Address)\n+     renames System.CRTL.free;\n+\n+   function c_realloc\n+     (Ptr : System.Address; Size : System.CRTL.size_t) return System.Address\n+     renames System.CRTL.realloc;\n+\n+   Gnat_Heap_Size : Integer;\n+   pragma Import (C, Gnat_Heap_Size, \"__gl_heap_size\");\n+   --  Set by Feature logical GNAT$NO_MALLOC_64 and/or Binder switch -Hnn\n+\n+   -----------\n+   -- Alloc --\n+   -----------\n+\n+   function Alloc (Size : size_t) return System.Address is\n+      Result      : System.Address;\n+      Actual_Size : size_t := Size;\n+\n+   begin\n+      if Gnat_Heap_Size = 32 then\n+         return Alloc32 (Size);\n+      end if;\n+\n+      if Size = size_t'Last then\n+         Raise_Exception (Storage_Error'Identity, \"object too large\");\n+      end if;\n+\n+      --  Change size from zero to non-zero. We still want a proper pointer\n+      --  for the zero case because pointers to zero length objects have to\n+      --  be distinct, but we can't just go ahead and allocate zero bytes,\n+      --  since some malloc's return zero for a zero argument.\n+\n+      if Size = 0 then\n+         Actual_Size := 1;\n+      end if;\n+\n+      if Parameters.No_Abort then\n+         Result := c_malloc (System.CRTL.size_t (Actual_Size));\n+      else\n+         Abort_Defer.all;\n+         Result := c_malloc (System.CRTL.size_t (Actual_Size));\n+         Abort_Undefer.all;\n+      end if;\n+\n+      if Result = System.Null_Address then\n+         Raise_Exception (Storage_Error'Identity, \"heap exhausted\");\n+      end if;\n+\n+      return Result;\n+   end Alloc;\n+\n+   -------------\n+   -- Alloc32 --\n+   -------------\n+\n+   function Alloc32 (Size : size_t) return System.Address is\n+      Result      : System.Address;\n+      Actual_Size : size_t := Size;\n+\n+   begin\n+      if Size = size_t'Last then\n+         Raise_Exception (Storage_Error'Identity, \"object too large\");\n+      end if;\n+\n+      --  Change size from zero to non-zero. We still want a proper pointer\n+      --  for the zero case because pointers to zero length objects have to\n+      --  be distinct, but we can't just go ahead and allocate zero bytes,\n+      --  since some malloc's return zero for a zero argument.\n+\n+      if Size = 0 then\n+         Actual_Size := 1;\n+      end if;\n+\n+      if Parameters.No_Abort then\n+         Result := C_malloc32 (Actual_Size);\n+      else\n+         Abort_Defer.all;\n+         Result := C_malloc32 (Actual_Size);\n+         Abort_Undefer.all;\n+      end if;\n+\n+      if Result = System.Null_Address then\n+         Raise_Exception (Storage_Error'Identity, \"heap exhausted\");\n+      end if;\n+\n+      return Result;\n+   end Alloc32;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (Ptr : System.Address) is\n+   begin\n+      if Parameters.No_Abort then\n+         c_free (Ptr);\n+      else\n+         Abort_Defer.all;\n+         c_free (Ptr);\n+         Abort_Undefer.all;\n+      end if;\n+   end Free;\n+\n+   -------------\n+   -- Realloc --\n+   -------------\n+\n+   function Realloc\n+     (Ptr  : System.Address;\n+      Size : size_t)\n+      return System.Address\n+   is\n+      Result      : System.Address;\n+      Actual_Size : constant size_t := Size;\n+\n+   begin\n+      if Gnat_Heap_Size = 32 then\n+         return Realloc32 (Ptr, Size);\n+      end if;\n+\n+      if Size = size_t'Last then\n+         Raise_Exception (Storage_Error'Identity, \"object too large\");\n+      end if;\n+\n+      if Parameters.No_Abort then\n+         Result := c_realloc (Ptr, System.CRTL.size_t (Actual_Size));\n+      else\n+         Abort_Defer.all;\n+         Result := c_realloc (Ptr, System.CRTL.size_t (Actual_Size));\n+         Abort_Undefer.all;\n+      end if;\n+\n+      if Result = System.Null_Address then\n+         Raise_Exception (Storage_Error'Identity, \"heap exhausted\");\n+      end if;\n+\n+      return Result;\n+   end Realloc;\n+\n+   ---------------\n+   -- Realloc32 --\n+   ---------------\n+\n+   function Realloc32\n+     (Ptr  : System.Address;\n+      Size : size_t)\n+      return System.Address\n+   is\n+      Result      : System.Address;\n+      Actual_Size : constant size_t := Size;\n+\n+   begin\n+      if Size = size_t'Last then\n+         Raise_Exception (Storage_Error'Identity, \"object too large\");\n+      end if;\n+\n+      if Parameters.No_Abort then\n+         Result := C_realloc32 (Ptr, Actual_Size);\n+      else\n+         Abort_Defer.all;\n+         Result := C_realloc32 (Ptr, Actual_Size);\n+         Abort_Undefer.all;\n+      end if;\n+\n+      if Result = System.Null_Address then\n+         Raise_Exception (Storage_Error'Identity, \"heap exhausted\");\n+      end if;\n+\n+      return Result;\n+   end Realloc32;\n+end System.Memory;"}, {"sha": "c07a9dcfc4b23ec4e29b1eb1c1324b9243a95c92", "filename": "gcc/ada/s-memory-vms_64.ads", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-memory-vms_64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-memory-vms_64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-memory-vms_64.ads?ref=90376fadb87083f9990804ce6b6588004241be77", "patch": "@@ -0,0 +1,129 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                         S Y S T E M . M E M O R Y                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2001-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides the low level memory allocation/deallocation\n+--  mechanisms used by GNAT for VMS 64 bit.\n+\n+--  To provide an alternate implementation, simply recompile the modified\n+--  body of this package with gnatmake -u -a -g s-memory.adb and make sure\n+--  that the ali and object files for this unit are found in the object\n+--  search path.\n+\n+--  This unit may be used directly from an application program by providing\n+--  an appropriate WITH, and the interface can be expected to remain stable.\n+\n+pragma Compiler_Unit;\n+\n+package System.Memory is\n+   pragma Elaborate_Body;\n+\n+   type size_t is mod 2 ** Standard'Address_Size;\n+   --  Note: the reason we redefine this here instead of using the\n+   --  definition in Interfaces.C is that we do not want to drag in\n+   --  all of Interfaces.C just because System.Memory is used.\n+\n+   function Alloc (Size : size_t) return System.Address;\n+   --  This is the low level allocation routine. Given a size in storage\n+   --  units, it returns the address of a maximally aligned block of\n+   --  memory. The implementation of this routine is guaranteed to be\n+   --  task safe, and also aborts are deferred if necessary.\n+   --\n+   --  If size_t is set to size_t'Last on entry, then a Storage_Error\n+   --  exception is raised with a message \"object too large\".\n+   --\n+   --  If size_t is set to zero on entry, then a minimal (but non-zero)\n+   --  size block is allocated.\n+   --\n+   --  Note: this is roughly equivalent to the standard C malloc call\n+   --  with the additional semantics as described above.\n+\n+   function Alloc32 (Size : size_t) return System.Address;\n+   --  Equivalent to Alloc except on VMS 64 bit where it invokes\n+   --  32 bit malloc.\n+\n+   procedure Free (Ptr : System.Address);\n+   --  This is the low level free routine. It frees a block previously\n+   --  allocated with a call to Alloc. As in the case of Alloc, this\n+   --  call is guaranteed task safe, and aborts are deferred.\n+   --\n+   --  Note: this is roughly equivalent to the standard C free call\n+   --  with the additional semantics as described above.\n+\n+   function Realloc\n+     (Ptr  : System.Address;\n+      Size : size_t) return System.Address;\n+   --  This is the low level reallocation routine. It takes an existing\n+   --  block address returned by a previous call to Alloc or Realloc,\n+   --  and reallocates the block. The size can either be increased or\n+   --  decreased. If possible the reallocation is done in place, so that\n+   --  the returned result is the same as the value of Ptr on entry.\n+   --  However, it may be necessary to relocate the block to another\n+   --  address, in which case the information is copied to the new\n+   --  block, and the old block is freed. The implementation of this\n+   --  routine is guaranteed to be task safe, and also aborts are\n+   --  deferred as necessary.\n+   --\n+   --  If size_t is set to size_t'Last on entry, then a Storage_Error\n+   --  exception is raised with a message \"object too large\".\n+   --\n+   --  If size_t is set to zero on entry, then a minimal (but non-zero)\n+   --  size block is allocated.\n+   --\n+   --  Note: this is roughly equivalent to the standard C realloc call\n+   --  with the additional semantics as described above.\n+\n+   function Realloc32\n+     (Ptr  : System.Address;\n+      Size : size_t) return System.Address;\n+   --  Equivalent to Realloc except on VMS 64 bit where it invokes\n+   --  32 bit realloc.\n+\n+private\n+\n+   --  The following names are used from the generated compiler code\n+\n+   pragma Export (C, Alloc,   \"__gnat_malloc\");\n+   pragma Export (C, Alloc32, \"__gnat_malloc32\");\n+   pragma Export (C, Free,    \"__gnat_free\");\n+   pragma Export (C, Realloc, \"__gnat_realloc\");\n+   pragma Export (C, Realloc32, \"__gnat_realloc32\");\n+\n+   function C_malloc32 (Size : size_t) return System.Address;\n+   pragma Import (C, C_malloc32, \"_malloc32\");\n+   --  An alias for malloc for allocating 32bit memory on 64bit VMS\n+\n+   function C_realloc32\n+     (Ptr  : System.Address;\n+      Size : size_t) return System.Address;\n+   pragma Import (C, C_realloc32, \"_realloc32\");\n+   --  An alias for realloc for allocating 32bit memory on 64bit VMS\n+\n+end System.Memory;"}, {"sha": "e37d3d20b2f06e2dd416ebd45bbbc3234ae03b1c", "filename": "gcc/ada/s-osinte-vms-ia64.adb", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-osinte-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-osinte-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vms-ia64.adb?ref=90376fadb87083f9990804ce6b6588004241be77", "patch": "@@ -0,0 +1,58 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 2003-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a OpenVMS/IA64 version of this package\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with Interfaces.C; use Interfaces.C;\n+\n+package body System.OS_Interface is\n+\n+   -----------------\n+   -- sched_yield --\n+   -----------------\n+\n+   function sched_yield return int is\n+      procedure sched_yield_base;\n+      pragma Import (C, sched_yield_base, \"PTHREAD_YIELD_NP\");\n+\n+   begin\n+      sched_yield_base;\n+      return 0;\n+   end sched_yield;\n+\n+end System.OS_Interface;"}, {"sha": "99b91aa345577db5082ccbb70d85405f56e86d87", "filename": "gcc/ada/s-osinte-vms-ia64.ads", "status": "added", "additions": 652, "deletions": 0, "changes": 652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-osinte-vms-ia64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-osinte-vms-ia64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vms-ia64.ads?ref=90376fadb87083f9990804ce6b6588004241be77", "patch": "@@ -0,0 +1,652 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--             Copyright (C) 1991-1994, Florida State University            --\n+--          Copyright (C) 1995-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a OpenVMS/IA64 version of this package\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by the tasking run-time (libgnarl).\n+\n+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+\n+with Ada.Unchecked_Conversion;\n+\n+with System.Aux_DEC;\n+\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+\n+   pragma Linker_Options (\"--for-linker=ia64$library:pthread$rtl.exe\");\n+   --  Link in the DEC threads library\n+\n+   --  pragma Linker_Options (\"--for-linker=/threads_enable\");\n+   --  Enable upcalls and multiple kernel threads.\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+\n+   -----------------------------\n+   -- Signals (Interrupt IDs) --\n+   -----------------------------\n+\n+   --  Type signal has an arbitrary limit of 31\n+\n+   Max_Interrupt : constant := 31;\n+   type Signal is new unsigned range 0 .. Max_Interrupt;\n+   for Signal'Size use unsigned'Size;\n+\n+   type sigset_t is array (Signal) of Boolean;\n+   pragma Pack (sigset_t);\n+\n+   --  Interrupt_Number_Type\n+   --  Unsigned long integer denoting the number of an interrupt\n+\n+   subtype Interrupt_Number_Type is unsigned_long;\n+\n+   --  OpenVMS system services return values of type Cond_Value_Type\n+\n+   subtype Cond_Value_Type is unsigned_long;\n+   subtype Short_Cond_Value_Type is unsigned_short;\n+\n+   type IO_Status_Block_Type is record\n+      Status   : Short_Cond_Value_Type;\n+      Count    : unsigned_short;\n+      Dev_Info : unsigned_long;\n+   end record;\n+\n+   type AST_Handler is access procedure (Param : Address);\n+   pragma Convention (C, AST_Handler);\n+   No_AST_Handler : constant AST_Handler := null;\n+\n+   CMB_M_READONLY  : constant := 16#00000001#;\n+   CMB_M_WRITEONLY : constant := 16#00000002#;\n+   AGN_M_READONLY  : constant := 16#00000001#;\n+   AGN_M_WRITEONLY : constant := 16#00000002#;\n+\n+   IO_WRITEVBLK : constant := 48;  --  WRITE VIRTUAL BLOCK\n+   IO_READVBLK  : constant := 49;  --  READ VIRTUAL BLOCK\n+\n+   ----------------\n+   -- Sys_Assign --\n+   ----------------\n+   --\n+   --  Assign I/O Channel\n+   --\n+   --  Status = returned status\n+   --  Devnam = address  of  device  name  or  logical  name   string\n+   --               descriptor\n+   --  Chan   = address of word to receive channel number assigned\n+   --  Acmode = access mode associated with channel\n+   --  Mbxnam = address of mailbox logical name string descriptor, if\n+   --               mailbox associated with device\n+   --  Flags  = optional channel flags longword for specifying options\n+   --           for the $ASSIGN operation\n+   --\n+\n+   procedure Sys_Assign\n+     (Status : out Cond_Value_Type;\n+      Devnam : String;\n+      Chan   : out unsigned_short;\n+      Acmode : unsigned_short := 0;\n+      Mbxnam : String := String'Null_Parameter;\n+      Flags  : unsigned_long := 0);\n+   pragma Interface (External, Sys_Assign);\n+   pragma Import_Valued_Procedure\n+     (Sys_Assign, \"SYS$ASSIGN\",\n+      (Cond_Value_Type, String,         unsigned_short,\n+       unsigned_short,  String,         unsigned_long),\n+      (Value,           Descriptor (s), Reference,\n+       Value,           Descriptor (s), Value),\n+      Flags);\n+\n+   ----------------\n+   -- Sys_Cantim --\n+   ----------------\n+   --\n+   --  Cancel Timer\n+   --\n+   --  Status  = returned status\n+   --  Reqidt  = ID of timer to be cancelled\n+   --  Acmode  = Access mode\n+   --\n+   procedure Sys_Cantim\n+     (Status : out Cond_Value_Type;\n+      Reqidt : Address;\n+      Acmode : unsigned);\n+   pragma Interface (External, Sys_Cantim);\n+   pragma Import_Valued_Procedure\n+     (Sys_Cantim, \"SYS$CANTIM\",\n+      (Cond_Value_Type, Address, unsigned),\n+      (Value,           Value,   Value));\n+\n+   ----------------\n+   -- Sys_Crembx --\n+   ----------------\n+   --\n+   --  Create mailbox\n+   --\n+   --     Status  = returned status\n+   --     Prmflg  = permanent flag\n+   --     Chan    = channel\n+   --     Maxmsg  = maximum message\n+   --     Bufquo  = buufer quote\n+   --     Promsk  = protection mast\n+   --     Acmode  = access mode\n+   --     Lognam  = logical name\n+   --     Flags   = flags\n+   --\n+   procedure Sys_Crembx\n+     (Status : out Cond_Value_Type;\n+      Prmflg : unsigned_char;\n+      Chan   : out unsigned_short;\n+      Maxmsg : unsigned_long := 0;\n+      Bufquo : unsigned_long := 0;\n+      Promsk : unsigned_short := 0;\n+      Acmode : unsigned_short := 0;\n+      Lognam : String;\n+      Flags  : unsigned_long := 0);\n+   pragma Interface (External, Sys_Crembx);\n+   pragma Import_Valued_Procedure\n+     (Sys_Crembx, \"SYS$CREMBX\",\n+      (Cond_Value_Type, unsigned_char,  unsigned_short,\n+       unsigned_long,   unsigned_long,  unsigned_short,\n+       unsigned_short,  String,         unsigned_long),\n+      (Value,           Value,          Reference,\n+       Value,           Value,          Value,\n+       Value,           Descriptor (s), Value));\n+\n+   -------------\n+   -- Sys_QIO --\n+   -------------\n+   --\n+   --    Queue I/O\n+   --\n+   --     Status = Returned status of call\n+   --     EFN    = event flag to be set when I/O completes\n+   --     Chan   = channel\n+   --     Func   = function\n+   --     Iosb   = I/O status block\n+   --     Astadr = system trap to be generated when I/O completes\n+   --     Astprm = AST parameter\n+   --     P1-6   = optional parameters\n+\n+   procedure Sys_QIO\n+     (Status : out Cond_Value_Type;\n+      EFN    : unsigned_long := 0;\n+      Chan   : unsigned_short;\n+      Func   : unsigned_long := 0;\n+      Iosb   : out IO_Status_Block_Type;\n+      Astadr : AST_Handler := No_AST_Handler;\n+      Astprm : Address := Null_Address;\n+      P1     : unsigned_long := 0;\n+      P2     : unsigned_long := 0;\n+      P3     : unsigned_long := 0;\n+      P4     : unsigned_long := 0;\n+      P5     : unsigned_long := 0;\n+      P6     : unsigned_long := 0);\n+\n+   procedure Sys_QIO\n+     (Status : out Cond_Value_Type;\n+      EFN    : unsigned_long := 0;\n+      Chan   : unsigned_short;\n+      Func   : unsigned_long := 0;\n+      Iosb   : Address := Null_Address;\n+      Astadr : AST_Handler := No_AST_Handler;\n+      Astprm : Address := Null_Address;\n+      P1     : unsigned_long := 0;\n+      P2     : unsigned_long := 0;\n+      P3     : unsigned_long := 0;\n+      P4     : unsigned_long := 0;\n+      P5     : unsigned_long := 0;\n+      P6     : unsigned_long := 0);\n+\n+   pragma Interface (External, Sys_QIO);\n+   pragma Import_Valued_Procedure\n+     (Sys_QIO, \"SYS$QIO\",\n+      (Cond_Value_Type,      unsigned_long, unsigned_short, unsigned_long,\n+       IO_Status_Block_Type, AST_Handler,   Address,\n+       unsigned_long,        unsigned_long, unsigned_long,\n+       unsigned_long,        unsigned_long, unsigned_long),\n+      (Value,                Value,         Value,          Value,\n+       Reference,            Value,         Value,\n+       Value,                Value,         Value,\n+       Value,                Value,         Value));\n+\n+   pragma Import_Valued_Procedure\n+     (Sys_QIO, \"SYS$QIO\",\n+      (Cond_Value_Type, unsigned_long, unsigned_short, unsigned_long,\n+       Address,         AST_Handler,   Address,\n+       unsigned_long,   unsigned_long, unsigned_long,\n+       unsigned_long,   unsigned_long, unsigned_long),\n+      (Value,           Value,         Value,          Value,\n+       Value,           Value,         Value,\n+       Value,           Value,         Value,\n+       Value,           Value,         Value));\n+\n+   ----------------\n+   -- Sys_Setimr --\n+   ----------------\n+   --\n+   --    Set Timer\n+   --\n+   --     Status = Returned status of call\n+   --     EFN    = event flag to be set when timer expires\n+   --     Tim    = expiration time\n+   --     AST    = system trap to be generated when timer expires\n+   --     Redidt = returned ID of timer (e.g. to cancel timer)\n+   --     Flags  = flags\n+   --\n+   procedure Sys_Setimr\n+     (Status : out Cond_Value_Type;\n+      EFN    : unsigned_long;\n+      Tim    : Long_Integer;\n+      AST    : AST_Handler;\n+      Reqidt : Address;\n+      Flags  : unsigned_long);\n+   pragma Interface (External, Sys_Setimr);\n+   pragma Import_Valued_Procedure\n+     (Sys_Setimr, \"SYS$SETIMR\",\n+      (Cond_Value_Type, unsigned_long,     Long_Integer,\n+       AST_Handler,     Address,           unsigned_long),\n+      (Value,           Value,             Reference,\n+       Value,           Value,             Value));\n+\n+   Interrupt_ID_0   : constant  := 0;\n+   Interrupt_ID_1   : constant  := 1;\n+   Interrupt_ID_2   : constant  := 2;\n+   Interrupt_ID_3   : constant  := 3;\n+   Interrupt_ID_4   : constant  := 4;\n+   Interrupt_ID_5   : constant  := 5;\n+   Interrupt_ID_6   : constant  := 6;\n+   Interrupt_ID_7   : constant  := 7;\n+   Interrupt_ID_8   : constant  := 8;\n+   Interrupt_ID_9   : constant  := 9;\n+   Interrupt_ID_10  : constant  := 10;\n+   Interrupt_ID_11  : constant  := 11;\n+   Interrupt_ID_12  : constant  := 12;\n+   Interrupt_ID_13  : constant  := 13;\n+   Interrupt_ID_14  : constant  := 14;\n+   Interrupt_ID_15  : constant  := 15;\n+   Interrupt_ID_16  : constant  := 16;\n+   Interrupt_ID_17  : constant  := 17;\n+   Interrupt_ID_18  : constant  := 18;\n+   Interrupt_ID_19  : constant  := 19;\n+   Interrupt_ID_20  : constant  := 20;\n+   Interrupt_ID_21  : constant  := 21;\n+   Interrupt_ID_22  : constant  := 22;\n+   Interrupt_ID_23  : constant  := 23;\n+   Interrupt_ID_24  : constant  := 24;\n+   Interrupt_ID_25  : constant  := 25;\n+   Interrupt_ID_26  : constant  := 26;\n+   Interrupt_ID_27  : constant  := 27;\n+   Interrupt_ID_28  : constant  := 28;\n+   Interrupt_ID_29  : constant  := 29;\n+   Interrupt_ID_30  : constant  := 30;\n+   Interrupt_ID_31  : constant  := 31;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EINTR  : constant := 4;   --  Interrupted system call\n+   EAGAIN : constant := 11;  --  No more processes\n+   ENOMEM : constant := 12;  --  Not enough core\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_FIFO  : constant := 1;\n+   SCHED_RR    : constant := 2;\n+   SCHED_OTHER : constant := 3;\n+   SCHED_BG    : constant := 4;\n+   SCHED_LFI   : constant := 5;\n+   SCHED_LRR   : constant := 6;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill);\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid);\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n+\n+   function Thread_Body_Access is new\n+     Ada.Unchecked_Conversion (System.Aux_DEC.Short_Address, Thread_Body);\n+\n+   type pthread_t           is private;\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   PTHREAD_CREATE_JOINABLE     : constant := 0;\n+   PTHREAD_CREATE_DETACHED     : constant := 1;\n+\n+   PTHREAD_CANCEL_DISABLE      : constant := 0;\n+   PTHREAD_CANCEL_ENABLE       : constant := 1;\n+\n+   PTHREAD_CANCEL_DEFERRED     : constant := 0;\n+   PTHREAD_CANCEL_ASYNCHRONOUS : constant := 1;\n+\n+   --  Don't use ERRORCHECK mutexes, they don't work when a thread is not\n+   --  the owner.  AST's, at least, unlock others threads mutexes. Even\n+   --  if the error is ignored, they don't work.\n+   PTHREAD_MUTEX_NORMAL_NP     : constant := 0;\n+   PTHREAD_MUTEX_RECURSIVE_NP  : constant := 1;\n+   PTHREAD_MUTEX_ERRORCHECK_NP : constant := 2;\n+\n+   PTHREAD_INHERIT_SCHED       : constant := 0;\n+   PTHREAD_EXPLICIT_SCHED      : constant := 1;\n+\n+   function pthread_cancel (thread : pthread_t) return int;\n+   pragma Import (C, pthread_cancel, \"PTHREAD_CANCEL\");\n+\n+   procedure pthread_testcancel;\n+   pragma Import (C, pthread_testcancel, \"PTHREAD_TESTCANCEL\");\n+\n+   function pthread_setcancelstate\n+     (newstate : int; oldstate : access int) return int;\n+   pragma Import (C, pthread_setcancelstate, \"PTHREAD_SETCANCELSTATE\");\n+\n+   function pthread_setcanceltype\n+     (newtype : int; oldtype : access int) return int;\n+   pragma Import (C, pthread_setcanceltype, \"PTHREAD_SETCANCELTYPE\");\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function pthread_lock_global_np return int;\n+   pragma Import (C, pthread_lock_global_np, \"PTHREAD_LOCK_GLOBAL_NP\");\n+\n+   function pthread_unlock_global_np return int;\n+   pragma Import (C, pthread_unlock_global_np, \"PTHREAD_UNLOCK_GLOBAL_NP\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_init, \"PTHREAD_MUTEXATTR_INIT\");\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy, \"PTHREAD_MUTEXATTR_DESTROY\");\n+\n+   function pthread_mutexattr_settype_np\n+     (attr      : access pthread_mutexattr_t;\n+      mutextype : int) return int;\n+   pragma Import (C, pthread_mutexattr_settype_np,\n+                     \"PTHREAD_MUTEXATTR_SETTYPE_NP\");\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"PTHREAD_MUTEX_INIT\");\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"PTHREAD_MUTEX_DESTROY\");\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_lock, \"PTHREAD_MUTEX_LOCK\");\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_unlock, \"PTHREAD_MUTEX_UNLOCK\");\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init, \"PTHREAD_CONDATTR_INIT\");\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy, \"PTHREAD_CONDATTR_DESTROY\");\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"PTHREAD_COND_INIT\");\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"PTHREAD_COND_DESTROY\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"PTHREAD_COND_SIGNAL\");\n+\n+   function pthread_cond_signal_int_np\n+     (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal_int_np,\n+                  \"PTHREAD_COND_SIGNAL_INT_NP\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_cond_wait, \"PTHREAD_COND_WAIT\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 13 --\n+   --------------------------\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr : access pthread_mutexattr_t; protocol : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprotocol,\n+                     \"PTHREAD_MUTEXATTR_SETPROTOCOL\");\n+\n+   type struct_sched_param is record\n+      sched_priority : int;  --  scheduling priority\n+   end record;\n+   for struct_sched_param'Size use 8*4;\n+   pragma Convention (C, struct_sched_param);\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int;\n+   pragma Import (C, pthread_setschedparam, \"PTHREAD_SETSCHEDPARAM\");\n+\n+   function pthread_attr_setscope\n+     (attr            : access pthread_attr_t;\n+      contentionscope : int) return int;\n+   pragma Import (C, pthread_attr_setscope, \"PTHREAD_ATTR_SETSCOPE\");\n+\n+   function pthread_attr_setinheritsched\n+     (attr            : access pthread_attr_t;\n+      inheritsched : int) return int;\n+   pragma Import (C, pthread_attr_setinheritsched,\n+                     \"PTHREAD_ATTR_SETINHERITSCHED\");\n+\n+   function pthread_attr_setschedpolicy\n+     (attr : access pthread_attr_t; policy : int) return int;\n+   pragma Import (C, pthread_attr_setschedpolicy,\n+                     \"PTHREAD_ATTR_SETSCHEDPOLICY\");\n+\n+   function pthread_attr_setschedparam\n+     (attr        : access pthread_attr_t;\n+      sched_param : int) return int;\n+   pragma Import (C, pthread_attr_setschedparam, \"PTHREAD_ATTR_SETSCHEDPARAM\");\n+\n+   function sched_yield return int;\n+\n+   --------------------------\n+   -- P1003.1c  Section 16 --\n+   --------------------------\n+\n+   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init, \"PTHREAD_ATTR_INIT\");\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy, \"PTHREAD_ATTR_DESTROY\");\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   pragma Import (C, pthread_attr_setdetachstate,\n+                     \"PTHREAD_ATTR_SETDETACHSTATE\");\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize, \"PTHREAD_ATTR_SETSTACKSIZE\");\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Import (C, pthread_create, \"PTHREAD_CREATE\");\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"PTHREAD_EXIT\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"PTHREAD_SELF\");\n+   --  ??? This can be inlined, see pthread.h\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return  int;\n+   pragma Import (C, pthread_setspecific, \"PTHREAD_SETSPECIFIC\");\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   pragma Import (C, pthread_getspecific, \"PTHREAD_GETSPECIFIC\");\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Import (C, pthread_key_create, \"PTHREAD_KEY_CREATE\");\n+\n+private\n+\n+   type pid_t is new int;\n+\n+   type pthreadLongAddr_p is mod 2 ** Long_Integer'Size;\n+\n+   type pthreadLongAddr_t is mod 2 ** Long_Integer'Size;\n+   type pthreadLongAddr_t_ptr is mod 2 ** Long_Integer'Size;\n+\n+   type pthreadLongString_t is mod 2 ** Long_Integer'Size;\n+\n+   type pthreadLongUint_t is mod 2 ** Long_Integer'Size;\n+   type pthreadLongUint_array is array (Natural range <>)\n+     of pthreadLongUint_t;\n+\n+   type pthread_t is mod 2 ** Long_Integer'Size;\n+\n+   type pthread_cond_t is record\n+      state    : unsigned;\n+      valid    : unsigned;\n+      name     : pthreadLongString_t;\n+      arg      : unsigned;\n+      sequence : unsigned;\n+      block    : pthreadLongAddr_t_ptr;\n+   end record;\n+   for pthread_cond_t'Size use 8*32;\n+   pragma Convention (C, pthread_cond_t);\n+\n+   type pthread_attr_t is record\n+      valid    : long;\n+      name     : pthreadLongString_t;\n+      arg      : pthreadLongUint_t;\n+      reserved : pthreadLongUint_array (0 .. 18);\n+   end record;\n+   for pthread_attr_t'Size use 8*176;\n+   pragma Convention (C, pthread_attr_t);\n+\n+   type pthread_mutex_t is record\n+      lock     : unsigned;\n+      valid    : unsigned;\n+      name     : pthreadLongString_t;\n+      arg      : unsigned;\n+      sequence : unsigned;\n+      block    : pthreadLongAddr_p;\n+      owner    : unsigned;\n+      depth    : unsigned;\n+   end record;\n+   for pthread_mutex_t'Size use 8*40;\n+   pragma Convention (C, pthread_mutex_t);\n+\n+   type pthread_mutexattr_t is record\n+      valid    : long;\n+      reserved : pthreadLongUint_array (0 .. 14);\n+   end record;\n+   for pthread_mutexattr_t'Size use 8*128;\n+   pragma Convention (C, pthread_mutexattr_t);\n+\n+   type pthread_condattr_t is record\n+      valid    : long;\n+      reserved : pthreadLongUint_array (0 .. 12);\n+   end record;\n+   for pthread_condattr_t'Size use 8*112;\n+   pragma Convention (C, pthread_condattr_t);\n+\n+   type pthread_key_t is new unsigned;\n+\n+   pragma Inline (pthread_self);\n+\n+end System.OS_Interface;"}, {"sha": "d0cb60f9687be01c5cba499fca51ecbbb325aaea", "filename": "gcc/ada/s-tasdeb-vms.adb", "status": "added", "additions": 2158, "deletions": 0, "changes": 2158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-tasdeb-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90376fadb87083f9990804ce6b6588004241be77/gcc%2Fada%2Fs-tasdeb-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasdeb-vms.adb?ref=90376fadb87083f9990804ce6b6588004241be77", "patch": "@@ -0,0 +1,2158 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                                                                          --\n+--                  S Y S T E M . T A S K I N G . D E B U G                 --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 2008-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  OpenVMS Version\n+\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n+with System.Aux_DEC;\n+with System.CRTL;\n+with System.Task_Primitives.Operations;\n+package body System.Tasking.Debug is\n+\n+   package OSI renames System.OS_Interface;\n+   package STPO renames System.Task_Primitives.Operations;\n+\n+   use System.Aux_DEC;\n+\n+   --  Condition value type\n+\n+   subtype Cond_Value_Type is Unsigned_Longword;\n+\n+   type Trace_Flag_Set is array (Character) of Boolean;\n+\n+   Trace_On : Trace_Flag_Set := ('A' .. 'Z' => False, others => True);\n+\n+   --  Print_Routine fuction codes\n+\n+   type Print_Functions is\n+     (No_Print, Print_Newline, Print_Control,\n+      Print_String, Print_Symbol, Print_FAO);\n+   for Print_Functions use\n+     (No_Print => 0, Print_Newline => 1, Print_Control => 2,\n+      Print_String => 3, Print_Symbol => 4, Print_FAO => 5);\n+\n+   --  Counted ascii type declarations\n+\n+   subtype Count_Type is Natural range 0 .. 255;\n+   for Count_Type'Object_Size use 8;\n+\n+   type ASCIC (Count : Count_Type) is record\n+      Text  : String (1 .. Count);\n+   end record;\n+\n+   for ASCIC use record\n+      Count at 0 range 0 .. 7;\n+   end record;\n+   pragma Pack (ASCIC);\n+\n+   type AASCIC is access ASCIC;\n+   for AASCIC'Size use 32;\n+\n+   type AASCIC_Array is array (Positive range <>) of AASCIC;\n+\n+   type ASCIC127 is record\n+      Count : Count_Type;\n+      Text  : String (1 .. 127);\n+   end record;\n+\n+   for ASCIC127 use record\n+      Count at 0 range 0 .. 7;\n+      Text  at 1 range 0 .. 127 * 8 - 1;\n+   end record;\n+\n+   --  DEBUG Event record types used to signal DEBUG about Ada events\n+\n+   type Debug_Event_Record is record\n+      Code     : Unsigned_Word; --  Event code that uniquely identifies event\n+      Flags    : Bit_Array_8;   --  Flag bits\n+      --                            Bit 0: This event allows a parameter list\n+      --                            Bit 1: Parameters are address expressions\n+      Sentinal : Unsigned_Byte; --  Sentinal valuye: Always K_EVENT_SENT\n+      TS_Kind  : Unsigned_Byte; --  DST type specification: Always K_TS_TASK\n+      DType    : Unsigned_Byte; --  DTYPE of parameter if of atomic data type\n+      --                            Always K_DTYPE_TASK\n+      MBZ      : Unsigned_Byte; --  Unused (must be zero)\n+      Minchr   : Count_Type;    --  Minimum chars needed to identify event\n+      Name     : ASCIC (31);    --  Event name uppercase only\n+      Help     : AASCIC;        --  Event description\n+   end record;\n+\n+   for Debug_Event_Record use record\n+      Code     at 0 range 0 .. 15;\n+      Flags    at 2 range 0 .. 7;\n+      Sentinal at 3 range 0 .. 7;\n+      TS_Kind  at 4 range 0 .. 7;\n+      Dtype    at 5 range 0 .. 7;\n+      MBZ      at 6 range 0 .. 7;\n+      Minchr   at 7 range 0 .. 7;\n+      Name     at 8 range 0 .. 32 * 8 - 1;\n+      Help     at 40 range 0 .. 31;\n+   end record;\n+\n+   type Ada_Event_Control_Block_Type is record\n+      Code      : Unsigned_Word;     --  Reserved and defined by DEBUG\n+      Unused1   : Unsigned_Byte;     --  Reserved and defined by DEBUG\n+      Sentinal  : Unsigned_Byte;     --  Reserved and defined by DEBUG\n+      Facility  : Unsigned_Word;     --  Reserved and defined by DEBUG\n+      Flags     : Unsigned_Word;     --  Reserved and defined by DEBUG\n+      Value     : Unsigned_Longword; --  Reserved and defined by DEBUG\n+      Unused2   : Unsigned_Longword; --  Reserved and defined by DEBUG\n+      Sigargs   : Unsigned_Longword;\n+      P1        : Unsigned_Longword;\n+      Sub_Event : Unsigned_Longword;\n+   end record;\n+\n+   for Ada_Event_Control_Block_Type use record\n+      Code      at 0 range 0 .. 15;\n+      Unused1   at 2 range 0 .. 7;\n+      Sentinal  at 3 range 0 .. 7;\n+      Facility  at 4 range 0 .. 15;\n+      Flags     at 6 range 0 .. 15;\n+      Value     at 8 range 0 .. 31;\n+      Unused2   at 12 range 0 .. 31;\n+      Sigargs   at 16 range 0 .. 31;\n+      P1        at 20 range 0 .. 31;\n+      Sub_Event at 24 range 0 .. 31;\n+   end record;\n+\n+   type Ada_Event_Control_Block_Access is access Ada_Event_Control_Block_Type;\n+   for Ada_Event_Control_Block_Access'Size use 32;\n+\n+   --  Print_Routine_Type with max optional parameters\n+\n+   type Print_Routine_Type is access procedure\n+     (Print_Function    : Print_Functions;\n+      Print_Subfunction : Print_Functions;\n+      P1                : Unsigned_Longword := 0;\n+      P2                : Unsigned_Longword := 0;\n+      P3                : Unsigned_Longword := 0;\n+      P4                : Unsigned_Longword := 0;\n+      P5                : Unsigned_Longword := 0;\n+      P6                : Unsigned_Longword := 0);\n+   for Print_Routine_Type'Size use 32;\n+\n+   ---------------\n+   -- Constants --\n+   ---------------\n+\n+   --  These are used to obtain and convert task values\n+   K_CVT_VALUE_NUM  : constant := 1;\n+   K_CVT_NUM_VALUE  : constant := 2;\n+   K_NEXT_TASK      : constant := 3;\n+\n+   --  These are used to ask ADA to display task information\n+   K_SHOW_TASK     : constant := 4;\n+   K_SHOW_STAT     : constant := 5;\n+   K_SHOW_DEADLOCK : constant := 6;\n+\n+   --  These are used to get and set various attributes of one or more tasks\n+   --    Task state\n+   --  K_GET_STATE  : constant := 7;\n+   --  K_GET_ACTIVE : constant := 8;\n+   --  K_SET_ACTIVE : constant := 9;\n+   K_SET_ABORT  : constant := 10;\n+   --  K_SET_HOLD   : constant := 11;\n+\n+   --    Task priority\n+   K_GET_PRIORITY      : constant := 12;\n+   K_SET_PRIORITY      : constant := 13;\n+   K_RESTORE_PRIORITY  : constant := 14;\n+\n+   --    Task registers\n+   --  K_GET_REGISTERS     : constant := 15;\n+   --  K_SET_REGISTERS     : constant := 16;\n+\n+   --  These are used to control definable events\n+   K_ENABLE_EVENT   : constant := 17;\n+   K_DISABLE_EVENT  : constant := 18;\n+   K_ANNOUNCE_EVENT : constant := 19;\n+\n+   --  These are used to control time-slicing.\n+   --  K_SHOW_TIME_SLICE : constant := 20;\n+   --  K_SET_TIME_SLICE  : constant := 21;\n+\n+   --  This is used to symbolize task stack addresses.\n+   --  K_SYMBOLIZE_ADDRESS : constant := 22;\n+\n+   K_GET_CALLER : constant := 23;\n+   --  This is used to obtain the task value of the caller task\n+\n+   --  Miscellaneous functions - see below for details\n+\n+   K_CLEANUP_EVENT  : constant := 24;\n+   K_SHOW_EVENT_DEF : constant := 25;\n+   --  K_CHECK_TASK_STACK : constant := 26;  --  why commented out ???\n+\n+   --  This is used to obtain the DBGEXT-interface revision level\n+   --  K_GET_DBGEXT_REV : constant := 27; -- why commented out ???\n+\n+   K_GET_STATE_1 : constant := 28;\n+   --  This is used to obtain additional state info, primarily for PCA\n+\n+   K_FIND_EVENT_BY_CODE : constant := 29;\n+   K_FIND_EVENT_BY_NAME : constant := 30;\n+   --  These are used to search for user-defined event entries\n+\n+   --  This is used to stop task schedulding. Why commented out ???\n+   --  K_STOP_ALL_OTHER_TASKS : constant := 31;\n+\n+   --  Debug event constants\n+\n+   K_TASK_NOT_EXIST  : constant := 3;\n+   K_SUCCESS         : constant := 1;\n+   K_EVENT_SENT      : constant := 16#9A#;\n+   K_TS_TASK         : constant := 18;\n+   K_DTYPE_TASK      : constant := 44;\n+\n+   --  Status signal constants\n+\n+   SS_BADPARAM       : constant := 20;\n+   SS_NORMAL         : constant := 1;\n+\n+   --  Miscellaneous mask constants\n+\n+   V_EVNT_ALL        : constant := 0;\n+   V_Full_Display    : constant := 11;\n+   V_Suppress_Header : constant := 13;\n+\n+   --  CMA constants (why are some commented out???)\n+\n+   CMA_C_DEBGET_GUARDSIZE     : constant := 1;\n+   CMA_C_DEBGET_IS_HELD       : constant := 2;\n+--   CMA_C_DEBGET_IS_INITIAL    : constant := 3;\n+--   CMA_C_DEBGET_NUMBER        : constant := 4;\n+   CMA_C_DEBGET_STACKPTR      : constant := 5;\n+   CMA_C_DEBGET_STACK_BASE    : constant := 6;\n+   CMA_C_DEBGET_STACK_TOP     : constant := 7;\n+   CMA_C_DEBGET_SCHED_STATE   : constant := 8;\n+   CMA_C_DEBGET_YELLOWSIZE    : constant := 9;\n+--   CMA_C_DEBGET_BASE_PRIO     : constant := 10;\n+--   CMA_C_DEBGET_REGS          : constant := 11;\n+--   CMA_C_DEBGET_ALT_PENDING   : constant := 12;\n+--   CMA_C_DEBGET_ALT_A_ENABLE  : constant := 13;\n+--   CMA_C_DEBGET_ALT_G_ENABLE  : constant := 14;\n+--   CMA_C_DEBGET_SUBSTATE      : constant := 15;\n+--   CMA_C_DEBGET_OBJECT_ADDR   : constant := 16;\n+--   CMA_C_DEBGET_THKIND        : constant := 17;\n+--   CMA_C_DEBGET_DETACHED      : constant := 18;\n+   CMA_C_DEBGET_TCB_SIZE      : constant := 19;\n+--   CMA_C_DEBGET_START_PC      : constant := 20;\n+--   CMA_C_DEBGET_NEXT_PC       : constant := 22;\n+--   CMA_C_DEBGET_POLICY        : constant := 23;\n+--   CMA_C_DEBGET_STACK_YELLOW  : constant := 24;\n+--   CMA_C_DEBGET_STACK_DEFAULT : constant := 25;\n+\n+   --  Miscellaneous counted ascii constants\n+\n+   Star     : constant AASCIC := new ASCIC'(2, (\"* \"));\n+   NoStar   : constant AASCIC := new ASCIC'(2, (\"  \"));\n+   Hold     : constant AASCIC := new ASCIC'(4, (\"HOLD\"));\n+   NoHold   : constant AASCIC := new ASCIC'(4, (\"    \"));\n+   Header   : constant AASCIC := new ASCIC '\n+     (60, (\"  task id     pri hold state   substate          task object\"));\n+   Empty_Text : constant AASCIC := new ASCIC (0);\n+\n+   --  DEBUG Ada tasking states equated to their GNAT tasking equivalents\n+\n+   Ada_State_Invalid_State     : constant AASCIC :=\n+     new ASCIC'(17, \"Invalid state    \");\n+--   Ada_State_Abnormal          : constant AASCIC :=\n+--     new ASCIC'(17, \"Abnormal         \");\n+   Ada_State_Aborting          : constant AASCIC :=\n+     new ASCIC'(17, \"Aborting         \"); --  Aborting (new)\n+--   Ada_State_Completed_Abn     : constant AASCIC :=\n+--     new ASCIC'(17, \"Completed  [abn] \");\n+--   Ada_State_Completed_Exc     : constant AASCIC :=\n+--     new ASCIC'(17, \"Completed  [exc] \");\n+   Ada_State_Completed         : constant AASCIC :=\n+     new ASCIC'(17, \"Completed        \"); --  Master_Completion_Sleep\n+   Ada_State_Runnable          : constant AASCIC :=\n+     new ASCIC'(17, \"Runnable         \"); --  Runnable\n+   Ada_State_Activating        : constant AASCIC :=\n+     new ASCIC'(17, \"Activating       \");\n+   Ada_State_Accept            : constant AASCIC :=\n+     new ASCIC'(17, \"Accept           \"); --  Acceptor_Sleep\n+   Ada_State_Select_or_Delay   : constant AASCIC :=\n+     new ASCIC'(17, \"Select or delay  \"); --  Acceptor_Delay_Sleep\n+   Ada_State_Select_or_Term    : constant AASCIC :=\n+     new ASCIC'(17, \"Select or term.  \"); -- Terminate_Alternative\n+   Ada_State_Select_or_Abort   : constant AASCIC :=\n+     new ASCIC'(17, \"Select or abort  \"); --  Async_Select_Sleep (new)\n+--   Ada_State_Select            : constant AASCIC :=\n+--     new ASCIC'(17, \"Select           \");\n+   Ada_State_Activating_Tasks  : constant AASCIC :=\n+     new ASCIC'(17, \"Activating tasks \"); --  Activator_Sleep\n+   Ada_State_Delay             : constant AASCIC :=\n+     new ASCIC'(17, \"Delay            \"); --  AST_Pending\n+--   Ada_State_Dependents        : constant AASCIC :=\n+--     new ASCIC'(17, \"Dependents       \");\n+   Ada_State_Entry_Call        : constant AASCIC :=\n+     new ASCIC'(17, \"Entry call       \"); --  Entry_Caller_Sleep\n+   Ada_State_Cond_Entry_Call   : constant AASCIC :=\n+     new ASCIC'(17, \"Cond. entry call \"); --  Call.Mode.Conditional_Call\n+   Ada_State_Timed_Entry_Call  : constant AASCIC :=\n+     new ASCIC'(17, \"Timed entry call \"); --  Call.Mode.Timed_Call\n+   Ada_State_Async_Entry_Call  : constant AASCIC :=\n+     new ASCIC'(17, \"Async entry call \"); --  Call.Mode.Asynchronous_Call (new)\n+--   Ada_State_Dependents_Exc    : constant AASCIC :=\n+--     new ASCIC'(17, \"Dependents [exc] \");\n+   Ada_State_IO_or_AST         : constant AASCIC :=\n+     new ASCIC'(17, \"I/O or AST       \"); --  AST_Server_Sleep\n+--   Ada_State_Shared_Resource   : constant AASCIC :=\n+--     new ASCIC'(17, \"Shared resource  \");\n+   Ada_State_Not_Yet_Activated : constant AASCIC :=\n+     new ASCIC'(17, \"Not yet activated\"); --  Unactivated\n+--   Ada_State_Terminated_Abn    : constant AASCIC :=\n+--     new ASCIC'(17, \"Terminated [abn] \");\n+--   Ada_State_Terminated_Exc    : constant AASCIC :=\n+--     new ASCIC'(17, \"Terminated [exc] \");\n+   Ada_State_Terminated        : constant AASCIC :=\n+     new ASCIC'(17, \"Terminated       \"); --  Terminated\n+   Ada_State_Server            : constant AASCIC :=\n+     new ASCIC'(17, \"Server           \"); --  Servers\n+   Ada_State_Async_Hold        : constant AASCIC :=\n+     new ASCIC'(17, \"Async_Hold       \"); --  Async_Hold\n+\n+   --  Task state counted ascii constants\n+\n+   Debug_State_Emp : constant AASCIC := new ASCIC'(5, \"     \");\n+   Debug_State_Run : constant AASCIC := new ASCIC'(5, \"RUN  \");\n+   Debug_State_Rea : constant AASCIC := new ASCIC'(5, \"READY\");\n+   Debug_State_Sus : constant AASCIC := new ASCIC'(5, \"SUSP \");\n+   Debug_State_Ter : constant AASCIC := new ASCIC'(5, \"TERM \");\n+\n+   --  Priority order of event display\n+\n+   Global_Event_Display_Order : constant array (Event_Kind_Type)\n+     of Event_Kind_Type := (\n+      Debug_Event_Abort_Terminated,\n+      Debug_Event_Activating,\n+      Debug_Event_Dependents_Exception,\n+      Debug_Event_Exception_Terminated,\n+      Debug_Event_Handled,\n+      Debug_Event_Handled_Others,\n+      Debug_Event_Preempted,\n+      Debug_Event_Rendezvous_Exception,\n+      Debug_Event_Run,\n+      Debug_Event_Suspended,\n+      Debug_Event_Terminated);\n+\n+   --  Constant array defining all debug events\n+\n+   Event_Directory : constant array (Event_Kind_Type)\n+     of Debug_Event_Record := (\n+      (Debug_Event_Activating,\n+       (False, False, False, False, False, False, False, True),\n+       K_EVENT_SENT,\n+       K_TS_TASK,\n+       K_DTYPE_TASK,\n+       0,\n+       2,\n+       (31, \"ACTIVATING                     \"),\n+       new ASCIC'(41, \"!_a task is about to begin its activation\")),\n+\n+      (Debug_Event_Run,\n+       (False, False, False, False, False, False, False, True),\n+       K_EVENT_SENT,\n+       K_TS_TASK,\n+       K_DTYPE_TASK,\n+       0,\n+       2,\n+       (31, \"RUN                            \"),\n+       new ASCIC'(24, \"!_a task is about to run\")),\n+\n+      (Debug_Event_Suspended,\n+       (False, False, False, False, False, False, False, True),\n+       K_EVENT_SENT,\n+       K_TS_TASK,\n+       K_DTYPE_TASK,\n+       0,\n+       1,\n+       (31, \"SUSPENDED                      \"),\n+       new ASCIC'(33, \"!_a task is about to be suspended\")),\n+\n+      (Debug_Event_Preempted,\n+       (False, False, False, False, False, False, False, True),\n+       K_EVENT_SENT,\n+       K_TS_TASK,\n+       K_DTYPE_TASK,\n+       0,\n+       1,\n+       (31, \"PREEMPTED                      \"),\n+       new ASCIC'(33, \"!_a task is about to be preempted\")),\n+\n+      (Debug_Event_Terminated,\n+       (False, False, False, False, False, False, False, True),\n+       K_EVENT_SENT,\n+       K_TS_TASK,\n+       K_DTYPE_TASK,\n+       0,\n+       1,\n+       (31, \"TERMINATED                     \"),\n+       new ASCIC'(57,\n+        \"!_a task is terminating (including by abort or exception)\")),\n+\n+      (Debug_Event_Abort_Terminated,\n+       (False, False, False, False, False, False, False, True),\n+       K_EVENT_SENT,\n+       K_TS_TASK,\n+       K_DTYPE_TASK,\n+       0,\n+       2,\n+       (31, \"ABORT_TERMINATED               \"),\n+       new ASCIC'(40, \"!_a task is terminating because of abort\")),\n+\n+      (Debug_Event_Exception_Terminated,\n+       (False, False, False, False, False, False, False, True),\n+       K_EVENT_SENT,\n+       K_TS_TASK,\n+       K_DTYPE_TASK,\n+       0,\n+       1,\n+       (31, \"EXCEPTION_TERMINATED           \"),\n+       new ASCIC'(47, \"!_a task is terminating because of an exception\")),\n+\n+      (Debug_Event_Rendezvous_Exception,\n+       (False, False, False, False, False, False, False, True),\n+       K_EVENT_SENT,\n+       K_TS_TASK,\n+       K_DTYPE_TASK,\n+       0,\n+       3,\n+       (31, \"RENDEZVOUS_EXCEPTION           \"),\n+       new ASCIC'(49, \"!_an exception is propagating out of a rendezvous\")),\n+\n+      (Debug_Event_Handled,\n+       (False, False, False, False, False, False, False, True),\n+       K_EVENT_SENT,\n+       K_TS_TASK,\n+       K_DTYPE_TASK,\n+       0,\n+       1,\n+       (31, \"HANDLED                        \"),\n+       new ASCIC'(37, \"!_an exception is about to be handled\")),\n+\n+      (Debug_Event_Dependents_Exception,\n+       (False, False, False, False, False, False, False, True),\n+       K_EVENT_SENT,\n+       K_TS_TASK,\n+       K_DTYPE_TASK,\n+       0,\n+       1,\n+       (31, \"DEPENDENTS_EXCEPTION           \"),\n+       new ASCIC'(64,\n+        \"!_an exception is about to cause a task to await dependent tasks\")),\n+\n+      (Debug_Event_Handled_Others,\n+       (False, False, False, False, False, False, False, True),\n+       K_EVENT_SENT,\n+       K_TS_TASK,\n+       K_DTYPE_TASK,\n+       0,\n+       1,\n+       (31, \"HANDLED_OTHERS                 \"),\n+       new ASCIC'(58,\n+        \"!_an exception is about to be handled in an OTHERS handler\")));\n+\n+   --  Help on events displayed in DEBUG\n+\n+   Event_Def_Help : constant AASCIC_Array := (\n+     new ASCIC'(0,  \"\"),\n+     new ASCIC'(65,\n+      \"  The general forms of commands to set a breakpoint or tracepoint\"),\n+     new ASCIC'(22, \"  on an Ada event are:\"),\n+     new ASCIC'(73, \"    SET BREAK/EVENT=event [task[, ... ]] \" &\n+                    \"[WHEN(expr)] [DO(comnd[; ... ])]\"),\n+     new ASCIC'(73, \"    SET TRACE/EVENT=event [task[, ... ]] \" &\n+                    \"[WHEN(expr)] [DO(comnd[; ... ])]\"),\n+     new ASCIC'(0,  \"\"),\n+     new ASCIC'(65,\n+      \"  If tasks are specified, the breakpoint will trigger only if the\"),\n+     new ASCIC'(40, \"  event occurs for those specific tasks.\"),\n+     new ASCIC'(0,  \"\"),\n+     new ASCIC'(39, \"  Ada event names and their definitions\"),\n+     new ASCIC'(0,  \"\"));\n+\n+   -----------------------\n+   -- Package Variables --\n+   -----------------------\n+\n+   AC_Buffer : ASCIC127;\n+\n+   Events_Enabled_Count : Integer := 0;\n+\n+   Print_Routine_Bufsiz : constant := 132;\n+   Print_Routine_Bufcnt : Integer := 0;\n+   Print_Routine_Linbuf : String (1 .. Print_Routine_Bufsiz);\n+\n+   Global_Task_Debug_Events : Debug_Event_Array :=\n+     (False, False, False, False, False, False, False, False,\n+      False, False, False, False, False, False, False, False);\n+   --  Global table of task debug events set by the debugger\n+\n+   --------------------------\n+   -- Exported Subprograms --\n+   --------------------------\n+\n+   procedure Default_Print_Routine\n+     (Print_Function    : Print_Functions;\n+      Print_Subfunction : Print_Functions;\n+      P1                : Unsigned_Longword := 0;\n+      P2                : Unsigned_Longword := 0;\n+      P3                : Unsigned_Longword := 0;\n+      P4                : Unsigned_Longword := 0;\n+      P5                : Unsigned_Longword := 0;\n+      P6                : Unsigned_Longword := 0);\n+   --  The default print routine if not overridden.\n+   --  Print_Function determines option argument formatting.\n+   --  Print_Subfunction buffers output if No_Print, calls Put_Output if\n+   --  Print_Newline\n+\n+   pragma Export_Procedure\n+     (Default_Print_Routine,\n+      Mechanism => (Value, Value, Reference, Reference, Reference));\n+\n+   --------------------------\n+   -- Imported Subprograms --\n+   --------------------------\n+\n+   procedure Debug_Get\n+     (Thread_Id : OSI.Thread_Id;\n+      Item_Req  : Unsigned_Word;\n+      Out_Buff  : System.Address;\n+      Buff_Siz  : Unsigned_Word);\n+\n+   procedure Debug_Get\n+     (Thread_Id : OSI.Thread_Id;\n+      Item_Req  : Unsigned_Word;\n+      Out_Buff  : Unsigned_Longword;\n+      Buff_Siz  : Unsigned_Word);\n+   pragma Interface (External, Debug_Get);\n+\n+   pragma Import_Procedure (Debug_Get, \"CMA$DEBUG_GET\",\n+     (OSI.Thread_Id, Unsigned_Word, System.Address, Unsigned_Word),\n+     (Reference, Value, Reference, Value));\n+\n+   pragma Import_Procedure (Debug_Get, \"CMA$DEBUG_GET\",\n+     (OSI.Thread_Id, Unsigned_Word, Unsigned_Longword, Unsigned_Word),\n+     (Reference, Value, Reference, Value));\n+\n+   procedure FAOL\n+     (Status : out Cond_Value_Type;\n+      Ctrstr : String;\n+      Outlen : out Unsigned_Word;\n+      Outbuf : out String;\n+      Prmlst : Unsigned_Longword_Array);\n+   pragma Interface (External, FAOL);\n+\n+   pragma Import_Valued_Procedure (FAOL, \"SYS$FAOL\",\n+     (Cond_Value_Type, String, Unsigned_Word, String, Unsigned_Longword_Array),\n+     (Value, Descriptor (S), Reference, Descriptor (S), Reference));\n+\n+   procedure Put_Output (\n+     Status         : out Cond_Value_Type;\n+     Message_String : String);\n+\n+   procedure Put_Output (Message_String : String);\n+   pragma Interface (External, Put_Output);\n+\n+   pragma Import_Valued_Procedure (Put_Output, \"LIB$PUT_OUTPUT\",\n+     (Cond_Value_Type, String),\n+     (Value, Short_Descriptor (S)));\n+\n+   pragma Import_Procedure (Put_Output, \"LIB$PUT_OUTPUT\",\n+     (String),\n+     (Short_Descriptor (S)));\n+\n+   procedure Signal\n+     (Condition_Value     : Cond_Value_Type;\n+      Number_Of_Arguments : Integer := Integer'Null_Parameter;\n+      FAO_Argument_1      : Unsigned_Longword :=\n+                              Unsigned_Longword'Null_Parameter);\n+   pragma Interface (External, Signal);\n+\n+   pragma Import_Procedure (Signal, \"LIB$SIGNAL\",\n+      (Cond_Value_Type, Integer, Unsigned_Longword),\n+      (Value, Value, Value),\n+       Number_Of_Arguments);\n+\n+   ----------------------------\n+   -- Generic Instantiations --\n+   ----------------------------\n+\n+   function Fetch is new Fetch_From_Address (Unsigned_Longword);\n+   pragma Unreferenced (Fetch);\n+\n+   procedure Free is new Ada.Unchecked_Deallocation\n+     (Object => Ada_Event_Control_Block_Type,\n+      Name   => Ada_Event_Control_Block_Access);\n+\n+   function To_AASCIC is new\n+     Ada.Unchecked_Conversion (Unsigned_Longword, AASCIC);\n+\n+   function To_Addr is new\n+     Ada.Unchecked_Conversion (Task_Procedure_Access, Address);\n+   pragma Unreferenced (To_Addr);\n+\n+   function To_EVCB is new\n+     Ada.Unchecked_Conversion\n+      (Unsigned_Longword, Ada_Event_Control_Block_Access);\n+\n+   function To_Integer is new\n+     Ada.Unchecked_Conversion (Task_Id, System.Task_Primitives.Task_Address);\n+\n+   function To_Print_Routine_Type is new\n+     Ada.Unchecked_Conversion (Short_Address, Print_Routine_Type);\n+\n+   --  Optional argumements passed to Print_Routine have to be\n+   --  Unsigned_Longwords so define the required Unchecked_Conversions\n+\n+   function To_UL is new\n+     Ada.Unchecked_Conversion (AASCIC, Unsigned_Longword);\n+\n+   function To_UL is new\n+     Ada.Unchecked_Conversion (Integer, Unsigned_Longword);\n+\n+   function To_UL is new\n+     Ada.Unchecked_Conversion (Task_Id, Unsigned_Longword);\n+\n+   pragma Warnings (Off); --  Different sizes\n+   function To_UL is new\n+     Ada.Unchecked_Conversion (Task_Entry_Index, Unsigned_Longword);\n+   pragma Warnings (On);\n+\n+   function To_UL is new\n+     Ada.Unchecked_Conversion (Short_Address, Unsigned_Longword);\n+\n+   function To_UL is new\n+     Ada.Unchecked_Conversion\n+      (Ada_Event_Control_Block_Access, Unsigned_Longword);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   subtype Function_Codes is System.Aux_DEC.Unsigned_Word range 1 .. 31;\n+   --  The 31 function codes sent by the debugger needed to implement\n+   --  tasking support, enumerated below.\n+\n+   type Register_Array is array (Natural range 0 .. 16) of\n+     System.Aux_DEC.Unsigned_Longword;\n+   --  The register array is a holdover from VAX and not used\n+   --  on Alpha or I64 but is kept as a filler below.\n+\n+   type DBGEXT_Control_Block (Function_Code : Function_Codes) is record\n+      Facility_ID         : System.Aux_DEC.Unsigned_Word;\n+      --  For GNAT use the \"Ada\" facility ID\n+      Status              : System.Aux_DEC.Unsigned_Longword;\n+      --  Successful or otherwise returned status\n+      Flags               : System.Aux_DEC.Bit_Array_32;\n+      --   Used to flag event as global\n+      Print_Routine       : System.Aux_DEC.Short_Address;\n+      --  The print subprogram the caller wants to use for output\n+      Event_Code_or_EVCB  : System.Aux_DEC.Unsigned_Longword;\n+      --  Dual use Event Code or EVent Control Block\n+      Event_Value_or_Name : System.Aux_DEC.Unsigned_Longword;\n+      --  Dual use Event Value or Event Name string pointer\n+      Event_Entry         : System.Aux_DEC.Unsigned_Longword;\n+      Task_Value          : Task_Id;\n+      Task_Number         : Integer;\n+      Ada_Flags           : System.Aux_DEC.Bit_Array_32;\n+      Priority            : System.Aux_DEC.Bit_Array_32;\n+      Active_Registers    : System.Aux_DEC.Short_Address;\n+\n+      case Function_Code is\n+         when K_GET_STATE_1 =>\n+            Base_Priority       : System.Aux_DEC.Bit_Array_32;\n+            Task_Type_Name      : System.Aux_DEC.Short_Address;\n+            Creation_PC         : System.Aux_DEC.Short_Address;\n+            Parent_Task_ID      : Task_Id;\n+\n+         when others =>\n+            Ignored_Unused      : Register_Array;\n+\n+      end case;\n+   end record;\n+\n+   for DBGEXT_Control_Block use record\n+      Function_Code       at 0  range 0 .. 15;\n+      Facility_ID         at 2  range 0 .. 15;\n+      Status              at 4  range 0 .. 31;\n+      Flags               at 8  range 0 .. 31;\n+      Print_Routine       at 12 range 0 .. 31;\n+      Event_Code_or_EVCB  at 16 range 0 .. 31;\n+      Event_Value_or_Name at 20 range 0 .. 31;\n+      Event_Entry         at 24 range 0 .. 31;\n+      Task_Value          at 28 range 0 .. 31;\n+      Task_Number         at 32 range 0 .. 31;\n+      Ada_Flags           at 36 range 0 .. 31;\n+      Priority            at 40 range 0 .. 31;\n+      Active_Registers    at 44 range 0 .. 31;\n+      Ignored_Unused      at 48 range 0 .. 17 * 32 - 1;\n+      Base_Priority       at 48 range 0 .. 31;\n+      Task_Type_Name      at 52 range 0 .. 31;\n+      Creation_PC         at 56 range 0 .. 31;\n+      Parent_Task_ID      at 60 range 0 .. 31;\n+   end record;\n+\n+   type DBGEXT_Control_Block_Access is access all DBGEXT_Control_Block;\n+\n+   function DBGEXT (Control_Block : DBGEXT_Control_Block_Access)\n+     return System.Aux_DEC.Unsigned_Word;\n+   --  Exported to s-taprop.adb to avoid having a VMS specific s-tasdeb.ads\n+   pragma Convention (C, DBGEXT);\n+   pragma Export_Function (DBGEXT, \"GNAT$DBGEXT\");\n+   --  This routine is called by CMA when VMS DEBUG wants the Gnat RTL\n+   --  to give it some assistance (primarily when tasks are debugged).\n+   --\n+   --  The single parameter is an \"external control block\". On input to\n+   --  the Gnat RTL this control block determines the debugging function\n+   --  to be performed, and supplies parameters.  This routine cases on\n+   --  the function code, and calls the appropriate Gnat RTL routine,\n+   --  which returns values by modifying the external control block.\n+\n+   procedure Announce_Event\n+      (Event_EVCB    : Unsigned_Longword;\n+       Print_Routine : Print_Routine_Type := Default_Print_Routine'Access);\n+   --  Announce the occurence of a DEBUG tasking event\n+\n+   procedure Cleanup_Event (Event_EVCB : Unsigned_Longword);\n+   --  After DEBUG has processed an event that has signalled, the signaller\n+   --  must cleanup. Cleanup consists of freeing the event control block.\n+\n+   procedure Disable_Event\n+      (Flags       : Bit_Array_32;\n+       Event_Value : Unsigned_Longword;\n+       Event_Code  : Unsigned_Longword;\n+       Status      : out Cond_Value_Type);\n+   --  Disable a DEBUG tasking event\n+\n+   function DoAC (S : String) return Address;\n+   --  Convert a string to the address of an internal buffer containing\n+   --  the counted ASCII.\n+\n+   procedure Enable_Event\n+      (Flags       : Bit_Array_32;\n+       Event_Value : Unsigned_Longword;\n+       Event_Code  : Unsigned_Longword;\n+       Status      : out Cond_Value_Type);\n+   --  Enable a requested DEBUG tasking event\n+\n+   procedure Find_Event_By_Code\n+      (Event_Code  : Unsigned_Longword;\n+       Event_Entry : out Unsigned_Longword;\n+       Status      : out Cond_Value_Type);\n+   --  Convert an event code to the address of the event entry\n+\n+   procedure Find_Event_By_Name\n+      (Event_Name  : Unsigned_Longword;\n+       Event_Entry : out Unsigned_Longword;\n+       Status      : out Cond_Value_Type);\n+   --  Find an event entry given the event name\n+\n+   procedure List_Entry_Waiters\n+     (Task_Value      : Task_Id;\n+      Full_Display    : Boolean := False;\n+      Suppress_Header : Boolean := False;\n+      Print_Routine   : Print_Routine_Type := Default_Print_Routine'Access);\n+   --  List information about tasks waiting on an entry\n+\n+   procedure Put (S : String);\n+   --  Display S on standard output\n+\n+   procedure Put_Line (S : String := \"\");\n+   --  Display S on standard output with an additional line terminator\n+\n+   procedure Show_Event\n+      (Print_Routine : Print_Routine_Type := Default_Print_Routine'Access);\n+   --  Show what events are available\n+\n+   procedure Show_One_Task\n+     (Task_Value      : Task_Id;\n+      Full_Display    : Boolean := False;\n+      Suppress_Header : Boolean := False;\n+      Print_Routine   : Print_Routine_Type := Default_Print_Routine'Access);\n+   --  Display information about one task\n+\n+   procedure Show_Rendezvous\n+     (Task_Value      : Task_Id;\n+      Ada_State       : AASCIC := Empty_Text;\n+      Full_Display    : Boolean := False;\n+      Suppress_Header : Boolean := False;\n+      Print_Routine   : Print_Routine_Type := Default_Print_Routine'Access);\n+   --  Display information about a task rendezvous\n+\n+   procedure Trace_Output (Message_String : String);\n+   --  Call Put_Output if Trace_on (\"VMS\")\n+\n+   procedure Write (Fd : Integer; S : String; Count : Integer);\n+\n+   --------------------\n+   -- Announce_Event --\n+   --------------------\n+\n+   procedure Announce_Event\n+      (Event_EVCB    : Unsigned_Longword;\n+       Print_Routine : Print_Routine_Type := Default_Print_Routine'Access)\n+   is\n+      EVCB : constant Ada_Event_Control_Block_Access := To_EVCB (Event_EVCB);\n+\n+      Event_Kind : constant Event_Kind_Type :=\n+                     (if EVCB.Sub_Event /= 0\n+                      then Event_Kind_Type (EVCB.Sub_Event)\n+                      else Event_Kind_Type (EVCB.Code));\n+\n+      TI : constant String := \"   Task %TASK !UI is \";\n+      --  Announce prefix\n+\n+   begin\n+      Trace_Output (\"Announce called\");\n+\n+      case Event_Kind is\n+         when Debug_Event_Activating =>\n+            Print_Routine (Print_FAO, Print_Newline,\n+              To_UL (DoAC (TI & \"about to begin its activation\")),\n+              EVCB.Value);\n+         when Debug_Event_Exception_Terminated =>\n+            Print_Routine (Print_FAO, Print_Newline,\n+              To_UL (DoAC (TI & \"terminating because of an exception\")),\n+              EVCB.Value);\n+         when Debug_Event_Run =>\n+            Print_Routine (Print_FAO, Print_Newline,\n+              To_UL (DoAC (TI & \"about to run\")),\n+              EVCB.Value);\n+         when Debug_Event_Abort_Terminated =>\n+            Print_Routine (Print_FAO, Print_Newline,\n+              To_UL (DoAC (TI & \"terminating because of abort\")),\n+              EVCB.Value);\n+         when Debug_Event_Terminated =>\n+            Print_Routine (Print_FAO, Print_Newline,\n+              To_UL (DoAC (TI & \"terminating normally\")),\n+              EVCB.Value);\n+         when others => null;\n+      end case;\n+   end Announce_Event;\n+\n+   -------------------\n+   -- Cleanup_Event --\n+   -------------------\n+\n+   procedure Cleanup_Event (Event_EVCB  : Unsigned_Longword) is\n+      EVCB : Ada_Event_Control_Block_Access := To_EVCB (Event_EVCB);\n+   begin\n+      Free (EVCB);\n+   end Cleanup_Event;\n+\n+   ------------------------\n+   -- Continue_All_Tasks --\n+   ------------------------\n+\n+   procedure Continue_All_Tasks is\n+   begin\n+      null; --  VxWorks\n+   end Continue_All_Tasks;\n+\n+   ------------\n+   -- DBGEXT --\n+   ------------\n+\n+   function DBGEXT\n+     (Control_Block : DBGEXT_Control_Block_Access)\n+      return System.Aux_DEC.Unsigned_Word\n+   is\n+      Print_Routine : Print_Routine_Type := Default_Print_Routine'Access;\n+   begin\n+      Trace_Output (\"DBGEXT called\");\n+\n+      if Control_Block.Print_Routine /= Address_Zero then\n+         Print_Routine := To_Print_Routine_Type (Control_Block.Print_Routine);\n+      end if;\n+\n+      case Control_Block.Function_Code is\n+\n+         --  Convert a task value to a task number.\n+         --  The output results are stored in the CONTROL_BLOCK.\n+\n+         when K_CVT_VALUE_NUM =>\n+            Trace_Output (\"DBGEXT param 1 - CVT Value to NUM\");\n+            Control_Block.Task_Number :=\n+              Control_Block.Task_Value.Known_Tasks_Index + 1;\n+            Control_Block.Status := K_SUCCESS;\n+            Trace_Output (\"Task Number: \");\n+            Trace_Output (Integer'Image (Control_Block.Task_Number));\n+            return SS_NORMAL;\n+\n+         --  Convert a task number to a task value.\n+         --  The output results are stored in the CONTROL_BLOCK.\n+\n+         when K_CVT_NUM_VALUE =>\n+            Trace_Output (\"DBGEXT param 2 - CVT NUM to Value\");\n+            Trace_Output (\"Task Number: \");\n+            Trace_Output (Integer'Image (Control_Block.Task_Number));\n+            Control_Block.Task_Value :=\n+              Known_Tasks (Control_Block.Task_Number - 1);\n+            Control_Block.Status := K_SUCCESS;\n+            Trace_Output (\"Task Value: \");\n+            Trace_Output (Unsigned_Longword'Image\n+              (To_UL (Control_Block.Task_Value)));\n+            return SS_NORMAL;\n+\n+         --  Obtain the \"next\" task after a specified task.\n+         --  ??? To do: If specified check the PRIORITY, STATE, and HOLD\n+         --  fields to restrict the selection of the next task.\n+         --  The output results are stored in the CONTROL_BLOCK.\n+\n+         when K_NEXT_TASK =>\n+            Trace_Output (\"DBGEXT param 3 - Next Task\");\n+            Trace_Output (\"Task Value: \");\n+            Trace_Output (Unsigned_Longword'Image\n+              (To_UL (Control_Block.Task_Value)));\n+\n+            if Control_Block.Task_Value = null then\n+               Control_Block.Task_Value := Known_Tasks (Known_Tasks'First);\n+            else\n+               Control_Block.Task_Value :=\n+                 Known_Tasks (Control_Block.Task_Value.Known_Tasks_Index + 1);\n+            end if;\n+\n+            if Control_Block.Task_Value = null then\n+               Control_Block.Task_Value := Known_Tasks (Known_Tasks'First);\n+            end if;\n+\n+            Control_Block.Status := K_SUCCESS;\n+            return SS_NORMAL;\n+\n+         --  Display the state of a task. The FULL bit is checked to decide if\n+         --  a full or brief task display is desired. The output results are\n+         --  stored in the CONTROL_BLOCK.\n+\n+         when K_SHOW_TASK =>\n+            Trace_Output (\"DBGEXT param 4 - Show Task\");\n+\n+            if Control_Block.Task_Value = null then\n+               Control_Block.Status := K_TASK_NOT_EXIST;\n+            else\n+               Show_One_Task\n+                 (Control_Block.Task_Value,\n+                  Control_Block.Ada_Flags (V_Full_Display),\n+                  Control_Block.Ada_Flags (V_Suppress_Header),\n+                  Print_Routine);\n+\n+               Control_Block.Status := K_SUCCESS;\n+            end if;\n+\n+            return SS_NORMAL;\n+\n+         --  Enable a requested DEBUG tasking event\n+\n+         when K_ENABLE_EVENT =>\n+            Trace_Output (\"DBGEXT param 17 - Enable Event\");\n+            Enable_Event\n+              (Control_Block.Flags,\n+               Control_Block.Event_Value_or_Name,\n+               Control_Block.Event_Code_or_EVCB,\n+               Control_Block.Status);\n+\n+            return SS_NORMAL;\n+\n+         --  Disable a DEBUG tasking event\n+\n+         when K_DISABLE_EVENT =>\n+            Trace_Output (\"DBGEXT param 18 - Disable Event\");\n+            Disable_Event\n+              (Control_Block.Flags,\n+               Control_Block.Event_Value_or_Name,\n+               Control_Block.Event_Code_or_EVCB,\n+               Control_Block.Status);\n+\n+            return SS_NORMAL;\n+\n+         --  Announce the occurence of a DEBUG tasking event\n+\n+         when K_ANNOUNCE_EVENT =>\n+            Trace_Output (\"DBGEXT param 19 - Announce Event\");\n+            Announce_Event\n+              (Control_Block.Event_Code_or_EVCB,\n+               Print_Routine);\n+\n+            Control_Block.Status := K_SUCCESS;\n+            return SS_NORMAL;\n+\n+         --  After DEBUG has processed an event that has signalled,\n+         --  the signaller must cleanup.\n+         --  Cleanup consists of freeing the event control block.\n+\n+         when K_CLEANUP_EVENT =>\n+            Trace_Output (\"DBGEXT param 24 - Cleanup Event\");\n+            Cleanup_Event (Control_Block.Event_Code_or_EVCB);\n+\n+            Control_Block.Status := K_SUCCESS;\n+            return SS_NORMAL;\n+\n+         --  Show what events are available\n+\n+         when K_SHOW_EVENT_DEF =>\n+            Trace_Output (\"DBGEXT param 25 - Show Event Def\");\n+            Show_Event (Print_Routine);\n+\n+            Control_Block.Status := K_SUCCESS;\n+            return SS_NORMAL;\n+\n+         --  Convert an event code to the address of the event entry\n+\n+         when K_FIND_EVENT_BY_CODE =>\n+            Trace_Output (\"DBGEXT param 29 - Find Event by Code\");\n+            Find_Event_By_Code\n+              (Control_Block.Event_Code_or_EVCB,\n+               Control_Block.Event_Entry,\n+               Control_Block.Status);\n+\n+            return SS_NORMAL;\n+\n+         --  Find an event entry given the event name\n+\n+         when K_FIND_EVENT_BY_NAME =>\n+            Trace_Output (\"DBGEXT param 30 - Find Event by Name\");\n+            Find_Event_By_Name\n+              (Control_Block.Event_Value_or_Name,\n+               Control_Block.Event_Entry,\n+               Control_Block.Status);\n+            return SS_NORMAL;\n+\n+         --  ??? To do: Implement priority events\n+         --  Get, set or restore a task's priority\n+\n+         when K_GET_PRIORITY or K_SET_PRIORITY or K_RESTORE_PRIORITY =>\n+            Trace_Output (\"DBGEXT priority param - Not yet implemented\");\n+            Trace_Output (Function_Codes'Image\n+             (Control_Block.Function_Code));\n+            return SS_BADPARAM;\n+\n+         --  ??? To do: Implement show statistics event\n+         --  Display task statistics\n+\n+         when K_SHOW_STAT =>\n+            Trace_Output (\"DBGEXT show stat param - Not yet implemented\");\n+            Trace_Output (Function_Codes'Image\n+             (Control_Block.Function_Code));\n+            return SS_BADPARAM;\n+\n+         --  ??? To do: Implement get caller event\n+         --  Obtain the caller of a task in a rendezvous. If no rendezvous,\n+         --  null is returned\n+\n+         when K_GET_CALLER =>\n+            Trace_Output (\"DBGEXT get caller param - Not yet implemented\");\n+            Trace_Output (Function_Codes'Image\n+             (Control_Block.Function_Code));\n+            return SS_BADPARAM;\n+\n+         --  ??? To do: Implement set terminate event\n+         --  Terminate a task\n+\n+         when K_SET_ABORT =>\n+            Trace_Output (\"DBGEXT set terminate param - Not yet implemented\");\n+            Trace_Output (Function_Codes'Image\n+             (Control_Block.Function_Code));\n+            return SS_BADPARAM;\n+\n+         --  ??? To do: Implement show deadlock event\n+         --  Detect a deadlock\n+\n+         when K_SHOW_DEADLOCK =>\n+            Trace_Output (\"DBGEXT show deadlock param - Not yet implemented\");\n+            Trace_Output (Function_Codes'Image\n+             (Control_Block.Function_Code));\n+            return SS_BADPARAM;\n+\n+         when others =>\n+            Trace_Output (\"DBGEXT bad param: \");\n+            Trace_Output (Function_Codes'Image\n+             (Control_Block.Function_Code));\n+            return SS_BADPARAM;\n+\n+      end case;\n+   end DBGEXT;\n+\n+   ---------------------------\n+   -- Default_Print_Routine --\n+   ---------------------------\n+\n+   procedure Default_Print_Routine\n+     (Print_Function    : Print_Functions;\n+      Print_Subfunction : Print_Functions;\n+      P1                : Unsigned_Longword := 0;\n+      P2                : Unsigned_Longword := 0;\n+      P3                : Unsigned_Longword := 0;\n+      P4                : Unsigned_Longword := 0;\n+      P5                : Unsigned_Longword := 0;\n+      P6                : Unsigned_Longword := 0)\n+   is\n+      Status    : Cond_Value_Type;\n+      Linlen    : Unsigned_Word;\n+      Item_List : Unsigned_Longword_Array (1 .. 17) :=\n+        (1 .. 17 => 0);\n+   begin\n+\n+      case Print_Function is\n+         when Print_Control | Print_String =>\n+            null;\n+\n+         --  Formatted Ascii Output\n+\n+         when Print_FAO =>\n+            Item_List (1) := P2;\n+            Item_List (2) := P3;\n+            Item_List (3) := P4;\n+            Item_List (4) := P5;\n+            Item_List (5) := P6;\n+            FAOL\n+              (Status,\n+               To_AASCIC (P1).Text,\n+               Linlen,\n+               Print_Routine_Linbuf\n+                 (1 + Print_Routine_Bufcnt .. Print_Routine_Bufsiz),\n+               Item_List);\n+\n+            Print_Routine_Bufcnt := Print_Routine_Bufcnt + Integer (Linlen);\n+\n+         --  Symbolic output\n+\n+         when Print_Symbol =>\n+            Item_List (1) := P1;\n+            FAOL\n+              (Status,\n+               \"!XI\",\n+               Linlen,\n+               Print_Routine_Linbuf\n+                 (1 + Print_Routine_Bufcnt .. Print_Routine_Bufsiz),\n+               Item_List);\n+\n+            Print_Routine_Bufcnt := Print_Routine_Bufcnt + Integer (Linlen);\n+\n+         when others =>\n+            null;\n+      end case;\n+\n+      case Print_Subfunction is\n+\n+         --  Output buffer with a terminating newline\n+\n+         when Print_Newline =>\n+            Put_Output (Status,\n+              Print_Routine_Linbuf (1 .. Print_Routine_Bufcnt));\n+            Print_Routine_Bufcnt := 0;\n+\n+         --  Buffer the output\n+\n+         when No_Print =>\n+            null;\n+\n+         when others =>\n+            null;\n+      end case;\n+\n+   end Default_Print_Routine;\n+\n+   -------------------\n+   -- Disable_Event --\n+   -------------------\n+\n+   procedure Disable_Event\n+      (Flags       : Bit_Array_32;\n+       Event_Value : Unsigned_Longword;\n+       Event_Code  : Unsigned_Longword;\n+       Status      : out Cond_Value_Type)\n+   is\n+      Task_Value : Task_Id;\n+      Task_Index : constant Integer := Integer (Event_Value) - 1;\n+   begin\n+\n+      Events_Enabled_Count := Events_Enabled_Count - 1;\n+\n+      if Flags (V_EVNT_ALL) then\n+         Global_Task_Debug_Events (Integer (Event_Code)) := False;\n+         Status := K_SUCCESS;\n+      else\n+         if Task_Index in Known_Tasks'Range then\n+            Task_Value := Known_Tasks (Task_Index);\n+            if Task_Value /= null then\n+               Task_Value.Common.Debug_Events (Integer (Event_Code)) := False;\n+               Status := K_SUCCESS;\n+            else\n+               Status := K_TASK_NOT_EXIST;\n+            end if;\n+         else\n+            Status := K_TASK_NOT_EXIST;\n+         end if;\n+      end if;\n+\n+      --  Keep count of events for efficiency\n+\n+      if Events_Enabled_Count <= 0 then\n+         Events_Enabled_Count := 0;\n+         Global_Task_Debug_Event_Set := False;\n+      end if;\n+\n+   end Disable_Event;\n+\n+   ----------\n+   -- DoAC --\n+   ----------\n+\n+   function DoAC (S : String) return Address is\n+   begin\n+      AC_Buffer.Count := S'Length;\n+      AC_Buffer.Text (1 .. AC_Buffer.Count) := S;\n+      return AC_Buffer'Address;\n+   end DoAC;\n+\n+   ------------------\n+   -- Enable_Event --\n+   ------------------\n+\n+   procedure Enable_Event\n+      (Flags       : Bit_Array_32;\n+       Event_Value : Unsigned_Longword;\n+       Event_Code  : Unsigned_Longword;\n+       Status      : out Cond_Value_Type)\n+   is\n+      Task_Value : Task_Id;\n+      Task_Index : constant Integer := Integer (Event_Value) - 1;\n+   begin\n+\n+      --  At least one event enabled, any and all events will cause a\n+      --  condition to be raised and checked. Major tasking slowdown!\n+\n+      Global_Task_Debug_Event_Set := True;\n+      Events_Enabled_Count := Events_Enabled_Count + 1;\n+\n+      if Flags (V_EVNT_ALL) then\n+         Global_Task_Debug_Events (Integer (Event_Code)) := True;\n+         Status := K_SUCCESS;\n+      else\n+         if Task_Index in Known_Tasks'Range then\n+            Task_Value := Known_Tasks (Task_Index);\n+            if Task_Value /= null then\n+               Task_Value.Common.Debug_Events (Integer (Event_Code)) := True;\n+               Status := K_SUCCESS;\n+            else\n+               Status := K_TASK_NOT_EXIST;\n+            end if;\n+         else\n+            Status := K_TASK_NOT_EXIST;\n+         end if;\n+      end if;\n+\n+   end Enable_Event;\n+\n+   ------------------------\n+   -- Find_Event_By_Code --\n+   ------------------------\n+\n+   procedure Find_Event_By_Code\n+      (Event_Code  : Unsigned_Longword;\n+       Event_Entry : out Unsigned_Longword;\n+       Status      : out Cond_Value_Type)\n+   is\n+      K_SUCCESS        : constant := 1;\n+      K_NO_SUCH_EVENT  : constant := 9;\n+\n+   begin\n+      Trace_Output (\"Looking for Event: \");\n+      Trace_Output (Unsigned_Longword'Image (Event_Code));\n+\n+      for I in Event_Kind_Type'Range loop\n+         if Event_Code = Unsigned_Longword (Event_Directory (I).Code) then\n+            Event_Entry := To_UL (Event_Directory (I)'Address);\n+            Trace_Output (\"Found Event # \");\n+            Trace_Output (Integer'Image (I));\n+            Status := K_SUCCESS;\n+            return;\n+         end if;\n+      end loop;\n+\n+      Status := K_NO_SUCH_EVENT;\n+   end Find_Event_By_Code;\n+\n+   ------------------------\n+   -- Find_Event_By_Name --\n+   ------------------------\n+\n+   procedure Find_Event_By_Name\n+      (Event_Name  : Unsigned_Longword;\n+       Event_Entry : out Unsigned_Longword;\n+       Status      : out Cond_Value_Type)\n+   is\n+      K_SUCCESS        : constant := 1;\n+      K_NO_SUCH_EVENT  : constant := 9;\n+\n+      Event_Name_Cstr : constant ASCIC := To_AASCIC (Event_Name).all;\n+   begin\n+      Trace_Output (\"Looking for Event: \");\n+      Trace_Output (Event_Name_Cstr.Text);\n+\n+      for I in Event_Kind_Type'Range loop\n+         if Event_Name_Cstr.Count >= Event_Directory (I).Minchr\n+            and then Event_Name_Cstr.Count <= Event_Directory (I).Name.Count\n+            and then Event_Name_Cstr.Text (1 .. Event_Directory (I).Minchr) =\n+                Event_Directory (I).Name.Text (1 .. Event_Directory (I).Minchr)\n+         then\n+            Event_Entry := To_UL (Event_Directory (I)'Address);\n+            Trace_Output (\"Found Event # \");\n+            Trace_Output (Integer'Image (I));\n+            Status := K_SUCCESS;\n+            return;\n+         end if;\n+      end loop;\n+\n+      Status := K_NO_SUCH_EVENT;\n+   end Find_Event_By_Name;\n+\n+   --------------------\n+   -- Get_User_State --\n+   --------------------\n+\n+   function Get_User_State return Long_Integer is\n+   begin\n+      return STPO.Self.User_State;\n+   end Get_User_State;\n+\n+   ------------------------\n+   -- List_Entry_Waiters --\n+   ------------------------\n+\n+   procedure List_Entry_Waiters\n+     (Task_Value      : Task_Id;\n+      Full_Display    : Boolean := False;\n+      Suppress_Header : Boolean := False;\n+      Print_Routine   : Print_Routine_Type := Default_Print_Routine'Access)\n+   is\n+      pragma Unreferenced (Suppress_Header);\n+\n+      Entry_Call : Entry_Call_Link;\n+      Have_Some  : Boolean := False;\n+   begin\n+      if not Full_Display then\n+         return;\n+      end if;\n+\n+      if Task_Value.Entry_Queues'Length > 0 then\n+         Print_Routine (Print_FAO, Print_Newline,\n+           To_UL (DoAC (\"        Waiting entry callers:\")));\n+      end if;\n+      for I in Task_Value.Entry_Queues'Range loop\n+         Entry_Call := Task_Value.Entry_Queues (I).Head;\n+         if Entry_Call /= null then\n+            Have_Some := True;\n+\n+            Print_Routine (Print_FAO, Print_Newline,\n+              To_UL (DoAC (\"          Waiters for entry !UI:\")),\n+              To_UL (I));\n+\n+            loop\n+               declare\n+                  Task_Image : ASCIC :=\n+                   (Entry_Call.Self.Common.Task_Image_Len,\n+                    Entry_Call.Self.Common.Task_Image\n+                     (1 .. Entry_Call.Self.Common.Task_Image_Len));\n+               begin\n+                  Print_Routine (Print_FAO, Print_Newline,\n+                    To_UL (DoAC (\"              %TASK !UI, type: !AC\")),\n+                    To_UL (Entry_Call.Self.Known_Tasks_Index + 1),\n+                    To_UL (Task_Image'Address));\n+                  if Entry_Call = Task_Value.Entry_Queues (I).Tail then\n+                     exit;\n+                  end if;\n+                  Entry_Call := Entry_Call.Next;\n+               end;\n+            end loop;\n+         end if;\n+      end loop;\n+      if not Have_Some then\n+         Print_Routine (Print_FAO, Print_Newline,\n+           To_UL (DoAC (\"          none.\")));\n+      end if;\n+   end List_Entry_Waiters;\n+\n+   ----------------\n+   -- List_Tasks --\n+   ----------------\n+\n+   procedure List_Tasks is\n+      C : Task_Id;\n+   begin\n+      C := All_Tasks_List;\n+\n+      while C /= null loop\n+         Print_Task_Info (C);\n+         C := C.Common.All_Tasks_Link;\n+      end loop;\n+   end List_Tasks;\n+\n+   ------------------------\n+   -- Print_Current_Task --\n+   ------------------------\n+\n+   procedure Print_Current_Task is\n+   begin\n+      Print_Task_Info (STPO.Self);\n+   end Print_Current_Task;\n+\n+   ---------------------\n+   -- Print_Task_Info --\n+   ---------------------\n+\n+   procedure Print_Task_Info (T : Task_Id) is\n+      Entry_Call : Entry_Call_Link;\n+      Parent     : Task_Id;\n+\n+   begin\n+      if T = null then\n+         Put_Line (\"null task\");\n+         return;\n+      end if;\n+\n+      Put (T.Common.Task_Image (1 .. T.Common.Task_Image_Len) & \": \" &\n+           Task_States'Image (T.Common.State));\n+\n+      Parent := T.Common.Parent;\n+\n+      if Parent = null then\n+         Put (\", parent: <none>\");\n+      else\n+         Put (\", parent: \" &\n+              Parent.Common.Task_Image (1 .. Parent.Common.Task_Image_Len));\n+      end if;\n+\n+      Put (\", prio:\" & T.Common.Current_Priority'Img);\n+\n+      if not T.Callable then\n+         Put (\", not callable\");\n+      end if;\n+\n+      if T.Aborting then\n+         Put (\", aborting\");\n+      end if;\n+\n+      if T.Deferral_Level /= 0 then\n+         Put (\", abort deferred\");\n+      end if;\n+\n+      if T.Common.Call /= null then\n+         Entry_Call := T.Common.Call;\n+         Put (\", serving:\");\n+\n+         while Entry_Call /= null loop\n+            Put (To_Integer (Entry_Call.Self)'Img);\n+            Entry_Call := Entry_Call.Acceptor_Prev_Call;\n+         end loop;\n+      end if;\n+\n+      if T.Open_Accepts /= null then\n+         Put (\", accepting:\");\n+\n+         for J in T.Open_Accepts'Range loop\n+            Put (T.Open_Accepts (J).S'Img);\n+         end loop;\n+\n+         if T.Terminate_Alternative then\n+            Put (\" or terminate\");\n+         end if;\n+      end if;\n+\n+      if T.User_State /= 0 then\n+         Put (\", state:\" & T.User_State'Img);\n+      end if;\n+\n+      Put_Line;\n+   end Print_Task_Info;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put (S : String) is\n+   begin\n+      Write (2, S, S'Length);\n+   end Put;\n+\n+   --------------\n+   -- Put_Line --\n+   --------------\n+\n+   procedure Put_Line (S : String := \"\") is\n+   begin\n+      Write (2, S & ASCII.LF, S'Length + 1);\n+   end Put_Line;\n+\n+   ----------------------\n+   -- Resume_All_Tasks --\n+   ----------------------\n+\n+   procedure Resume_All_Tasks (Thread_Self : OS_Interface.Thread_Id) is\n+      pragma Unreferenced (Thread_Self);\n+   begin\n+      null; --  VxWorks\n+   end Resume_All_Tasks;\n+\n+   ---------------\n+   -- Set_Trace --\n+   ---------------\n+\n+   procedure Set_Trace (Flag  : Character; Value : Boolean := True) is\n+   begin\n+      Trace_On (Flag) := Value;\n+   end Set_Trace;\n+\n+   --------------------\n+   -- Set_User_State --\n+   --------------------\n+\n+   procedure Set_User_State (Value : Long_Integer) is\n+   begin\n+      STPO.Self.User_State := Value;\n+   end Set_User_State;\n+\n+   ----------------\n+   -- Show_Event --\n+   ----------------\n+\n+   procedure Show_Event\n+      (Print_Routine : Print_Routine_Type := Default_Print_Routine'Access)\n+   is\n+   begin\n+      for I in Event_Def_Help'Range loop\n+         Print_Routine (Print_FAO, Print_Newline, To_UL (Event_Def_Help (I)));\n+      end loop;\n+\n+      for I in Event_Kind_Type'Range loop\n+         Print_Routine (Print_FAO, Print_Newline,\n+           To_UL (Event_Directory\n+                   (Global_Event_Display_Order (I)).Name'Address));\n+         Print_Routine (Print_FAO, Print_Newline,\n+           To_UL (Event_Directory (Global_Event_Display_Order (I)).Help));\n+      end loop;\n+   end Show_Event;\n+\n+   --------------------\n+   -- Show_One_Task --\n+   --------------------\n+\n+   procedure Show_One_Task\n+     (Task_Value      : Task_Id;\n+      Full_Display    : Boolean := False;\n+      Suppress_Header : Boolean := False;\n+      Print_Routine   : Print_Routine_Type := Default_Print_Routine'Access)\n+   is\n+      Task_SP            : System.Address := Address_Zero;\n+      Stack_Base         : System.Address := Address_Zero;\n+      Stack_Top          : System.Address := Address_Zero;\n+      TCB_Size           : Unsigned_Longword := 0;\n+      CMA_TCB_Size       : Unsigned_Longword := 0;\n+      Stack_Guard_Size   : Unsigned_Longword := 0;\n+      Total_Task_Storage : Unsigned_Longword := 0;\n+      Stack_In_Use       : Unsigned_Longword := 0;\n+      Reserved_Size      : Unsigned_Longword := 0;\n+      Hold_Flag          : Unsigned_Longword := 0;\n+      Sched_State        : Unsigned_Longword := 0;\n+      User_Prio          : Unsigned_Longword := 0;\n+      Stack_Size         : Unsigned_Longword := 0;\n+      Run_State          : Boolean := False;\n+      Rea_State          : Boolean := False;\n+      Sus_State          : Boolean := False;\n+      Ter_State          : Boolean := False;\n+\n+      Current_Flag : AASCIC := NoStar;\n+      Hold_String  : AASCIC := NoHold;\n+      Ada_State    : AASCIC := Ada_State_Invalid_State;\n+      Debug_State  : AASCIC := Debug_State_Emp;\n+\n+      Ada_State_Len   : constant Unsigned_Longword := 17;\n+      Debug_State_Len : constant Unsigned_Longword := 5;\n+\n+      Entry_Call : Entry_Call_Record;\n+\n+   begin\n+\n+      --  Initialize local task info variables\n+\n+      Task_SP := Address_Zero;\n+      Stack_Base := Address_Zero;\n+      Stack_Top := Address_Zero;\n+      CMA_TCB_Size := 0;\n+      Stack_Guard_Size := 0;\n+      Reserved_Size := 0;\n+      Hold_Flag := 0;\n+      Sched_State := 0;\n+      TCB_Size := Unsigned_Longword (Task_Id'Size);\n+\n+      if not Suppress_Header or else Full_Display then\n+         Print_Routine (Print_FAO, Print_Newline, To_UL (Empty_Text));\n+         Print_Routine (Print_FAO, Print_Newline, To_UL (Header));\n+      end if;\n+\n+      Trace_Output (\"Show_One_Task Task Value: \");\n+      Trace_Output (Unsigned_Longword'Image (To_UL (Task_Value)));\n+\n+      --  Callback to DEBUG to get some task info\n+\n+      if Task_Value.Common.State /= Terminated then\n+         Debug_Get\n+           (STPO.Get_Thread_Id (Task_Value),\n+            CMA_C_DEBGET_STACKPTR,\n+            Task_SP,\n+            8);\n+\n+         Debug_Get\n+           (STPO.Get_Thread_Id (Task_Value),\n+            CMA_C_DEBGET_TCB_SIZE,\n+            CMA_TCB_Size,\n+            4);\n+\n+         Debug_Get\n+           (STPO.Get_Thread_Id (Task_Value),\n+            CMA_C_DEBGET_GUARDSIZE,\n+            Stack_Guard_Size,\n+            4);\n+\n+         Debug_Get\n+           (STPO.Get_Thread_Id (Task_Value),\n+            CMA_C_DEBGET_YELLOWSIZE,\n+            Reserved_Size,\n+            4);\n+\n+         Debug_Get\n+           (STPO.Get_Thread_Id (Task_Value),\n+            CMA_C_DEBGET_STACK_BASE,\n+            Stack_Base,\n+            8);\n+\n+         Debug_Get\n+           (STPO.Get_Thread_Id (Task_Value),\n+            CMA_C_DEBGET_STACK_TOP,\n+            Stack_Top,\n+            8);\n+\n+         Stack_Size := Unsigned_Longword (Stack_Base - Stack_Top)\n+           - Reserved_Size - Stack_Guard_Size;\n+         Stack_In_Use := Unsigned_Longword (Stack_Base - Task_SP) + 4;\n+         Total_Task_Storage := TCB_Size + Stack_Size + Stack_Guard_Size\n+           + Reserved_Size + CMA_TCB_Size;\n+\n+         Debug_Get\n+           (STPO.Get_Thread_Id (Task_Value),\n+            CMA_C_DEBGET_IS_HELD,\n+            Hold_Flag,\n+            4);\n+\n+         Hold_String := (if Hold_Flag /= 0 then Hold else NoHold);\n+\n+         Debug_Get\n+           (STPO.Get_Thread_Id (Task_Value),\n+            CMA_C_DEBGET_SCHED_STATE,\n+            Sched_State,\n+            4);\n+      end if;\n+\n+      Run_State := False;\n+      Rea_State := False;\n+      Sus_State := Task_Value.Common.State = Unactivated;\n+      Ter_State := Task_Value.Common.State = Terminated;\n+\n+      if not Ter_State then\n+         Run_State := Sched_State = 0;\n+         Rea_State := Sched_State = 1;\n+         Sus_State := Sched_State /= 0 and Sched_State /= 1;\n+      end if;\n+\n+      --  Set the debug state\n+\n+      if Run_State then\n+         Debug_State := Debug_State_Run;\n+      elsif Rea_State then\n+         Debug_State := Debug_State_Rea;\n+      elsif Sus_State then\n+         Debug_State := Debug_State_Sus;\n+      elsif Ter_State then\n+         Debug_State := Debug_State_Ter;\n+      end if;\n+\n+      Trace_Output (\"Before case State: \");\n+      Trace_Output (Task_States'Image (Task_Value.Common.State));\n+\n+      --  Set the Ada state\n+\n+      case Task_Value.Common.State is\n+         when Unactivated =>\n+            Ada_State := Ada_State_Not_Yet_Activated;\n+\n+         when Activating =>\n+            Ada_State := Ada_State_Activating;\n+\n+         when Runnable =>\n+            Ada_State := Ada_State_Runnable;\n+\n+         when Terminated =>\n+            Ada_State := Ada_State_Terminated;\n+\n+         when Activator_Sleep =>\n+            Ada_State := Ada_State_Activating_Tasks;\n+\n+         when Acceptor_Sleep =>\n+            Ada_State := Ada_State_Accept;\n+\n+         when Acceptor_Delay_Sleep =>\n+            Ada_State := Ada_State_Select_or_Delay;\n+\n+         when Entry_Caller_Sleep =>\n+            Entry_Call :=\n+              Task_Value.Entry_Calls (Task_Value.ATC_Nesting_Level);\n+\n+            case Entry_Call.Mode is\n+               when Simple_Call =>\n+                  Ada_State := Ada_State_Entry_Call;\n+               when Conditional_Call =>\n+                  Ada_State := Ada_State_Cond_Entry_Call;\n+               when Timed_Call =>\n+                  Ada_State := Ada_State_Timed_Entry_Call;\n+               when Asynchronous_Call =>\n+                  Ada_State := Ada_State_Async_Entry_Call;\n+            end case;\n+\n+         when Async_Select_Sleep =>\n+            Ada_State := Ada_State_Select_or_Abort;\n+\n+         when Delay_Sleep =>\n+            Ada_State := Ada_State_Delay;\n+\n+         when Master_Completion_Sleep =>\n+            Ada_State := Ada_State_Completed;\n+\n+         when Master_Phase_2_Sleep =>\n+            Ada_State := Ada_State_Completed;\n+\n+         when Interrupt_Server_Idle_Sleep |\n+              Interrupt_Server_Blocked_Interrupt_Sleep |\n+              Timer_Server_Sleep |\n+              Interrupt_Server_Blocked_On_Event_Flag =>\n+            Ada_State := Ada_State_Server;\n+\n+         when AST_Server_Sleep =>\n+            Ada_State := Ada_State_IO_or_AST;\n+\n+         when Asynchronous_Hold =>\n+            Ada_State := Ada_State_Async_Hold;\n+\n+      end case;\n+\n+      if Task_Value.Terminate_Alternative then\n+         Ada_State := Ada_State_Select_or_Term;\n+      end if;\n+\n+      if Task_Value.Aborting then\n+         Ada_State := Ada_State_Aborting;\n+      end if;\n+\n+      User_Prio := To_UL (Task_Value.Common.Current_Priority);\n+      Trace_Output (\"After user_prio\");\n+\n+      --  Flag the current task\n+\n+      Current_Flag := (if Task_Value = Self then Star else NoStar);\n+\n+      --  Show task info\n+\n+      Print_Routine (Print_FAO, No_Print, To_UL (DoAC (\"!AC%TASK !5<!UI!>\")),\n+        To_UL (Current_Flag), To_UL (Task_Value.Known_Tasks_Index + 1));\n+\n+      Print_Routine (Print_FAO, No_Print, To_UL (DoAC (\"!2UB\")), User_Prio);\n+\n+      Print_Routine (Print_FAO, No_Print, To_UL (DoAC (\" !AC !5AD !17AD \")),\n+        To_UL (Hold_String), Debug_State_Len, To_UL (Debug_State),\n+        Ada_State_Len, To_UL (Ada_State));\n+\n+--      Print_Routine (Print_Symbol, Print_Newline,\n+--         Fetch (To_Addr (Task_Value.Common.Task_Entry_Point)));\n+\n+      Print_Routine (Print_FAO, Print_Newline, To_UL (Empty_Text));\n+\n+      --  If /full qualfier passed, show detailed info\n+\n+      if Full_Display then\n+         Show_Rendezvous (Task_Value, Ada_State, Full_Display,\n+           Suppress_Header, Print_Routine);\n+\n+         List_Entry_Waiters (Task_Value, Full_Display,\n+           Suppress_Header, Print_Routine);\n+\n+         Print_Routine (Print_FAO, Print_Newline, To_UL (Empty_Text));\n+\n+         declare\n+            Task_Image : ASCIC := (Task_Value.Common.Task_Image_Len,\n+              Task_Value.Common.Task_Image\n+               (1 .. Task_Value.Common.Task_Image_Len));\n+         begin\n+            Print_Routine (Print_FAO, Print_Newline,\n+              To_UL (DoAC (\"        Task type:      !AC\")),\n+              To_UL (Task_Image'Address));\n+         end;\n+\n+         --  How to find Creation_PC ???\n+--         Print_Routine (Print_FAO, No_Print,\n+--           To_UL (DoAC (\"        Created at PC:  \")),\n+--         Print_Routine (Print_FAO, Print_Newline, Creation_PC);\n+\n+         if Task_Value.Common.Parent /= null then\n+            Print_Routine (Print_FAO, Print_Newline,\n+              To_UL (DoAC (\"        Parent task:    %TASK !UI\")),\n+              To_UL (Task_Value.Common.Parent.Known_Tasks_Index + 1));\n+         else\n+            Print_Routine (Print_FAO, Print_Newline,\n+             To_UL (DoAC (\"        Parent task:    none\")));\n+         end if;\n+\n+--         Print_Routine (Print_FAO, No_Print,\n+--           To_UL (DoAC (\"        Start PC:       \")));\n+--         Print_Routine (Print_Symbol, Print_Newline,\n+--            Fetch (To_Addr (Task_Value.Common.Task_Entry_Point)));\n+\n+         Print_Routine (Print_FAO, Print_Newline,\n+          To_UL (DoAC (\n+           \"        Task control block:             Stack storage (bytes):\")));\n+\n+         Print_Routine (Print_FAO, Print_Newline,\n+          To_UL (DoAC (\n+           \"          Task value:   !10<!UI!>        RESERVED_BYTES:  !10UI\")),\n+          To_UL (Task_Value), Reserved_Size);\n+\n+         Print_Routine (Print_FAO, Print_Newline,\n+          To_UL (DoAC (\n+           \"          Entries:      !10<!UI!>        TOP_GUARD_SIZE:  !10UI\")),\n+          To_UL (Task_Value.Entry_Num), Stack_Guard_Size);\n+\n+         Print_Routine (Print_FAO, Print_Newline,\n+          To_UL (DoAC (\n+           \"          Size:         !10<!UI!>        STORAGE_SIZE:    !10UI\")),\n+          TCB_Size + CMA_TCB_Size, Stack_Size);\n+\n+         Print_Routine (Print_FAO, Print_Newline,\n+          To_UL (DoAC (\n+           \"        Stack addresses:                 Bytes in use:    !10UI\")),\n+          Stack_In_Use);\n+\n+         Print_Routine (Print_FAO, Print_Newline,\n+          To_UL (DoAC (\"          Top address:  !10<!XI!>\")),\n+          To_UL (Stack_Top));\n+\n+         Print_Routine (Print_FAO, Print_Newline,\n+          To_UL (DoAC (\n+           \"          Base address: !10<!XI!>      Total storage:     !10UI\")),\n+          To_UL (Stack_Base), Total_Task_Storage);\n+      end if;\n+\n+   end Show_One_Task;\n+\n+   ---------------------\n+   -- Show_Rendezvous --\n+   ---------------------\n+\n+   procedure Show_Rendezvous\n+     (Task_Value      : Task_Id;\n+      Ada_State       : AASCIC := Empty_Text;\n+      Full_Display    : Boolean := False;\n+      Suppress_Header : Boolean := False;\n+      Print_Routine   : Print_Routine_Type := Default_Print_Routine'Access)\n+   is\n+      pragma Unreferenced (Ada_State);\n+      pragma Unreferenced (Suppress_Header);\n+\n+      Temp_Entry  : Entry_Index;\n+      Entry_Call  : Entry_Call_Record;\n+      Called_Task : Task_Id;\n+      AWR         : constant String := \"        Awaiting rendezvous at: \";\n+      --  Common prefix\n+\n+      procedure Print_Accepts;\n+      --  Display information about task rendezvous accepts\n+\n+      procedure Print_Accepts is\n+      begin\n+         if Task_Value.Open_Accepts /= null then\n+            for I in Task_Value.Open_Accepts'Range loop\n+               Temp_Entry := Entry_Index (Task_Value.Open_Accepts (I).S);\n+               declare\n+                  Entry_Name_Image : ASCIC :=\n+                    (Task_Value.Entry_Names (Temp_Entry).all'Length,\n+                     Task_Value.Entry_Names (Temp_Entry).all);\n+               begin\n+                  Trace_Output (\"Accept at: \" & Entry_Name_Image.Text);\n+                  Print_Routine (Print_FAO, Print_Newline,\n+                    To_UL (DoAC (\"             accept at: !AC\")),\n+                    To_UL (Entry_Name_Image'Address));\n+               end;\n+            end loop;\n+         end if;\n+      end Print_Accepts;\n+   begin\n+      if not Full_Display then\n+         return;\n+      end if;\n+\n+      Trace_Output (\"Show_Rendezvous Task Value: \");\n+      Trace_Output (Unsigned_Longword'Image (To_UL (Task_Value)));\n+\n+      if Task_Value.Common.State = Acceptor_Sleep and then\n+         not Task_Value.Terminate_Alternative\n+      then\n+         if Task_Value.Open_Accepts /= null then\n+            Temp_Entry := Entry_Index (Task_Value.Open_Accepts\n+              (Task_Value.Open_Accepts'First).S);\n+            declare\n+               Entry_Name_Image : ASCIC :=\n+                 (Task_Value.Entry_Names (Temp_Entry).all'Length,\n+                  Task_Value.Entry_Names (Temp_Entry).all);\n+            begin\n+               Trace_Output (AWR & \"accept \" & Entry_Name_Image.Text);\n+               Print_Routine (Print_FAO, Print_Newline,\n+                 To_UL (DoAC (AWR & \"accept !AC\")),\n+                 To_UL (Entry_Name_Image'Address));\n+            end;\n+\n+         else\n+            Print_Routine (Print_FAO, Print_Newline,\n+              To_UL (DoAC (\"        entry name unavailable\")));\n+         end if;\n+      else\n+         case Task_Value.Common.State is\n+            when Acceptor_Sleep =>\n+               Print_Routine (Print_FAO, Print_Newline,\n+                 To_UL (DoAC (AWR & \"select with terminate.\")));\n+               Print_Accepts;\n+\n+            when Async_Select_Sleep =>\n+               Print_Routine (Print_FAO, Print_Newline,\n+                 To_UL (DoAC (AWR & \"select.\")));\n+               Print_Accepts;\n+\n+            when Acceptor_Delay_Sleep =>\n+               Print_Routine (Print_FAO, Print_Newline,\n+                 To_UL (DoAC (AWR & \"select with delay.\")));\n+               Print_Accepts;\n+\n+            when Entry_Caller_Sleep =>\n+               Entry_Call :=\n+                 Task_Value.Entry_Calls (Task_Value.ATC_Nesting_Level);\n+\n+               case Entry_Call.Mode is\n+                  when Simple_Call =>\n+                     Print_Routine (Print_FAO, Print_Newline,\n+                       To_UL (DoAC (AWR & \"entry call\")));\n+                  when Conditional_Call =>\n+                     Print_Routine (Print_FAO, Print_Newline,\n+                       To_UL (DoAC (AWR & \"entry call with else\")));\n+                  when Timed_Call =>\n+                     Print_Routine (Print_FAO, Print_Newline,\n+                       To_UL (DoAC (AWR & \"entry call with delay\")));\n+                  when Asynchronous_Call =>\n+                     Print_Routine (Print_FAO, Print_Newline,\n+                        To_UL (DoAC (AWR & \"entry call with abort\")));\n+               end case;\n+               Called_Task := Entry_Call.Called_Task;\n+               declare\n+                  Task_Image : ASCIC := (Called_Task.Common.Task_Image_Len,\n+                    Called_Task.Common.Task_Image\n+                     (1 .. Called_Task.Common.Task_Image_Len));\n+                  Entry_Name_Image : ASCIC :=\n+                    (Called_Task.Entry_Names (Entry_Call.E).all'Length,\n+                     Called_Task.Entry_Names (Entry_Call.E).all);\n+               begin\n+                  Print_Routine (Print_FAO, Print_Newline,\n+                    To_UL (DoAC\n+                     (\"        for entry !AC in %TASK !UI type !AC\")),\n+                    To_UL (Entry_Name_Image'Address),\n+                    To_UL (Called_Task.Known_Tasks_Index),\n+                    To_UL (Task_Image'Address));\n+               end;\n+\n+            when others =>\n+               return;\n+         end case;\n+      end if;\n+\n+   end Show_Rendezvous;\n+\n+   ------------------------\n+   -- Signal_Debug_Event --\n+   ------------------------\n+\n+   procedure Signal_Debug_Event\n+    (Event_Kind : Event_Kind_Type; Task_Value : Task_Id)\n+   is\n+      Do_Signal : Boolean;\n+      EVCB      : Ada_Event_Control_Block_Access;\n+\n+      EVCB_Sent    : constant := 16#9B#;\n+      Ada_Facility : constant := 49;\n+      SS_DBGEVENT  : constant := 1729;\n+   begin\n+      Do_Signal := Global_Task_Debug_Events (Event_Kind);\n+\n+      if not Do_Signal then\n+         if Task_Value /= null then\n+            Do_Signal := Do_Signal\n+              or else Task_Value.Common.Debug_Events (Event_Kind);\n+         end if;\n+      end if;\n+\n+      if Do_Signal then\n+         --  Build an a tasking event control block and signal DEBUG\n+\n+         EVCB := new Ada_Event_Control_Block_Type;\n+         EVCB.Code := Unsigned_Word (Event_Kind);\n+         EVCB.Sentinal := EVCB_Sent;\n+         EVCB.Facility := Ada_Facility;\n+\n+         if Task_Value /= null then\n+            EVCB.Value := Unsigned_Longword (Task_Value.Known_Tasks_Index + 1);\n+         else\n+            EVCB.Value := 0;\n+         end if;\n+\n+         EVCB.Sub_Event := 0;\n+         EVCB.P1 := 0;\n+         EVCB.Sigargs := 0;\n+         EVCB.Flags := 0;\n+         EVCB.Unused1 := 0;\n+         EVCB.Unused2 := 0;\n+\n+         Signal (SS_DBGEVENT, 1, To_UL (EVCB));\n+      end if;\n+   end Signal_Debug_Event;\n+\n+   --------------------\n+   -- Stop_All_Tasks --\n+   --------------------\n+\n+   procedure Stop_All_Tasks is\n+   begin\n+      null; --  VxWorks\n+   end Stop_All_Tasks;\n+\n+   ----------------------------\n+   -- Stop_All_Tasks_Handler --\n+   ----------------------------\n+\n+   procedure Stop_All_Tasks_Handler is\n+   begin\n+      null; --  VxWorks\n+   end Stop_All_Tasks_Handler;\n+\n+   -----------------------\n+   -- Suspend_All_Tasks --\n+   -----------------------\n+\n+   procedure Suspend_All_Tasks (Thread_Self : OS_Interface.Thread_Id) is\n+      pragma Unreferenced (Thread_Self);\n+   begin\n+      null; --  VxWorks\n+   end Suspend_All_Tasks;\n+\n+   ------------------------\n+   -- Task_Creation_Hook --\n+   ------------------------\n+\n+   procedure Task_Creation_Hook (Thread : OS_Interface.Thread_Id) is\n+      pragma Unreferenced (Thread);\n+   begin\n+      null; --  VxWorks\n+   end Task_Creation_Hook;\n+\n+   ---------------------------\n+   -- Task_Termination_Hook --\n+   ---------------------------\n+\n+   procedure Task_Termination_Hook is\n+   begin\n+      null; --  VxWorks\n+   end Task_Termination_Hook;\n+\n+   -----------\n+   -- Trace --\n+   -----------\n+\n+   procedure Trace\n+     (Self_Id  : Task_Id;\n+      Msg      : String;\n+      Flag     : Character;\n+      Other_Id : Task_Id := null)\n+   is\n+   begin\n+      if Trace_On (Flag) then\n+         Put (To_Integer (Self_Id)'Img &\n+              ':' & Flag & ':' &\n+              Self_Id.Common.Task_Image (1 .. Self_Id.Common.Task_Image_Len) &\n+              ':');\n+\n+         if Other_Id /= null then\n+            Put (To_Integer (Other_Id)'Img & ':');\n+         end if;\n+\n+         Put_Line (Msg);\n+      end if;\n+   end Trace;\n+\n+   ------------------\n+   -- Trace_Output --\n+   ------------------\n+\n+   procedure Trace_Output (Message_String : String) is\n+   begin\n+      if Trace_On ('V') and Trace_On ('M') and Trace_On ('S') then\n+         Put_Output (Message_String);\n+      end if;\n+   end Trace_Output;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write (Fd : Integer; S : String; Count : Integer) is\n+      Discard : System.CRTL.ssize_t;\n+      pragma Unreferenced (Discard);\n+   begin\n+      Discard := System.CRTL.write (Fd, S (S'First)'Address,\n+                                    System.CRTL.size_t (Count));\n+      --  Is it really right to ignore write errors here ???\n+   end Write;\n+\n+end System.Tasking.Debug;"}]}