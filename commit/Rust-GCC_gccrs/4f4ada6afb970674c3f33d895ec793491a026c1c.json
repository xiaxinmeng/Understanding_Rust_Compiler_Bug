{"sha": "4f4ada6afb970674c3f33d895ec793491a026c1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY0YWRhNmFmYjk3MDY3NGMzZjMzZDg5NWVjNzkzNDkxYTAyNmMxYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-03-10T16:11:14Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-03-10T16:11:14Z"}, "message": "re PR ipa/69589 (ICE in initialize_node_lattices, at ipa-cp.c:971)\n\n\n\tPR lto/69589\n\t* cgraph.c (cgraph_node::dump): Dump split_part and indirect_call_target.\n\t* cgraph.h (cgraph_node): Add indirect_call_target flag.\n\t* ipa.c (has_addr_references_p): Cleanup.\n\t(is_indirect_call_target_p): New.\n\t(walk_polymorphic_call_targets): Do not mark virtuals that may be\n\tcalled indirectly as local.\n\t(symbol_table::remove_unreachable_nodes): Compute indirect_call_target.\n\n\t* g++.dg/lto/pr69589_0.C: New testcase\n\t* g++.dg/lto/pr69589_1.C: New testcase\n\nFrom-SVN: r234115", "tree": {"sha": "75330395a11be8ce2a0a3af9dc620e72f851a88a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75330395a11be8ce2a0a3af9dc620e72f851a88a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f4ada6afb970674c3f33d895ec793491a026c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4ada6afb970674c3f33d895ec793491a026c1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f4ada6afb970674c3f33d895ec793491a026c1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4ada6afb970674c3f33d895ec793491a026c1c/comments", "author": null, "committer": null, "parents": [{"sha": "079cd8548b540ceda89887711f6f7fb3a8fa49ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079cd8548b540ceda89887711f6f7fb3a8fa49ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/079cd8548b540ceda89887711f6f7fb3a8fa49ec"}], "stats": {"total": 159, "additions": 143, "deletions": 16}, "files": [{"sha": "ba9f5b5795edcbc7ad57e0d2f1e81ca88bdcc2a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f4ada6afb970674c3f33d895ec793491a026c1c", "patch": "@@ -1,3 +1,14 @@\n+2016-03-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/69589\n+\t* cgraph.c (cgraph_node::dump): Dump split_part and indirect_call_target.\n+\t* cgraph.h (cgraph_node): Add indirect_call_target flag.\n+\t* ipa.c (has_addr_references_p): Cleanup.\n+\t(is_indirect_call_target_p): New.\n+\t(walk_polymorphic_call_targets): Do not mark virtuals that may be\n+\tcalled indirectly as local.\n+\t(symbol_table::remove_unreachable_nodes): Compute indirect_call_target.\n+\n 2016-03-10  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/69630"}, {"sha": "871ed62fd615373c0a4a759bac7df04e7a66f64f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=4f4ada6afb970674c3f33d895ec793491a026c1c", "patch": "@@ -2061,6 +2061,10 @@ cgraph_node::dump (FILE *f)\n     fprintf (f, \" icf_merged\");\n   if (merged_comdat)\n     fprintf (f, \" merged_comdat\");\n+  if (split_part)\n+    fprintf (f, \" split_part\");\n+  if (indirect_call_target)\n+    fprintf (f, \" indirect_call_target\");\n   if (nonfreeing_fn)\n     fprintf (f, \" nonfreeing_fn\");\n   if (DECL_STATIC_CONSTRUCTOR (decl))"}, {"sha": "d0345c698c5139b2409c84da6ad02e5c5134c404", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=4f4ada6afb970674c3f33d895ec793491a026c1c", "patch": "@@ -1366,6 +1366,8 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   unsigned parallelized_function : 1;\n   /* True if function is part split out by ipa-split.  */\n   unsigned split_part : 1;\n+  /* True if the function appears as possible target of indirect call.  */\n+  unsigned indirect_call_target : 1;\n \n private:\n   /* Worker for call_for_symbol_and_aliases.  */"}, {"sha": "6722d3b806ed55b0f1aeaeeb1a612bfbbaa6a73e", "filename": "gcc/ipa.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=4f4ada6afb970674c3f33d895ec793491a026c1c", "patch": "@@ -41,7 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n \n static bool\n has_addr_references_p (struct cgraph_node *node,\n-\t\t       void *data ATTRIBUTE_UNUSED)\n+\t\t       void *)\n {\n   int i;\n   struct ipa_ref *ref = NULL;\n@@ -52,6 +52,14 @@ has_addr_references_p (struct cgraph_node *node,\n   return false;\n }\n \n+/* Return true when NODE can be target of an indirect call.  */\n+\n+static bool\n+is_indirect_call_target_p (struct cgraph_node *node, void *)\n+{\n+  return node->indirect_call_target;\n+}\n+\n /* Look for all functions inlined to NODE and update their inlined_to pointers\n    to INLINED_TO.  */\n \n@@ -172,23 +180,24 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t\t    (TYPE_METHOD_BASETYPE (TREE_TYPE (n->decl))))\n \t    continue;\n \n-\t   symtab_node *body = n->function_symbol ();\n+\t  n->indirect_call_target = true;\n+\t  symtab_node *body = n->function_symbol ();\n \n \t  /* Prior inlining, keep alive bodies of possible targets for\n \t     devirtualization.  */\n-\t   if (n->definition\n-\t       && (before_inlining_p\n-\t\t   && opt_for_fn (body->decl, optimize)\n-\t\t   && opt_for_fn (body->decl, flag_devirtualize)))\n-\t      {\n-\t\t /* Be sure that we will not optimize out alias target\n-\t\t    body.  */\n-\t\t if (DECL_EXTERNAL (n->decl)\n-\t\t     && n->alias\n-\t\t     && before_inlining_p)\n-\t\t   reachable->add (body);\n-\t\treachable->add (n);\n-\t      }\n+\t  if (n->definition\n+\t      && (before_inlining_p\n+\t\t  && opt_for_fn (body->decl, optimize)\n+\t\t  && opt_for_fn (body->decl, flag_devirtualize)))\n+\t     {\n+\t\t/* Be sure that we will not optimize out alias target\n+\t\t   body.  */\n+\t\tif (DECL_EXTERNAL (n->decl)\n+\t\t    && n->alias\n+\t\t    && before_inlining_p)\n+\t\t  reachable->add (body);\n+\t       reachable->add (n);\n+\t     }\n \t  /* Even after inlining we want to keep the possible targets in the\n \t     boundary, so late passes can still produce direct call even if\n \t     the chance for inlining is lost.  */\n@@ -323,6 +332,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n   FOR_EACH_FUNCTION (node)\n     {\n       node->used_as_abstract_origin = false;\n+      node->indirect_call_target = false;\n       if (node->definition\n \t  && !node->global.inlined_to\n \t  && !node->in_other_partition\n@@ -659,7 +669,14 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t      fprintf (file, \" %s\", node->name ());\n \t    node->address_taken = false;\n \t    changed = true;\n-\t    if (node->local_p ())\n+\t    if (node->local_p ()\n+\t\t/* Virtual functions may be kept in cgraph just because\n+\t\t   of possible later devirtualization.  Do not mark them as\n+\t\t   local too early so we won't optimize them out before\n+\t\t   we are done with polymorphic call analysis.  */\n+\t\t&& (!before_inlining_p\n+\t\t    || !node->call_for_symbol_and_aliases\n+\t\t       (is_indirect_call_target_p, NULL, true)))\n \t      {\n \t\tnode->local.local = true;\n \t\tif (file)"}, {"sha": "c6ffcf3885373220429444a2966061861b9056c9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f4ada6afb970674c3f33d895ec793491a026c1c", "patch": "@@ -1,3 +1,9 @@\n+2016-03-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/69589\n+\t* g++.dg/lto/pr69589_0.C: New testcase\n+\t* g++.dg/lto/pr69589_1.C: New testcase\n+\n 2016-03-10  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/70153"}, {"sha": "bbdcb73dfc748c6969ef4e7eb663a1e4393ea3b0", "filename": "gcc/testsuite/g++.dg/lto/pr69589_0.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr69589_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr69589_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr69589_0.C?ref=4f4ada6afb970674c3f33d895ec793491a026c1c", "patch": "@@ -0,0 +1,26 @@\n+// { dg-lto-do link }\n+// { dg-lto-options \"-O2 -rdynamic\" } \n+// { dg-extra-ld-options \"-r -nostdlib\" }\n+#pragma GCC visibility push(hidden)\n+struct A { int &operator[] (long); };\n+template <typename> struct B;\n+template <typename T, typename = B<T> >\n+using Z = int;\n+template <typename> struct C;\n+struct S {\n+  int e;\n+  virtual ~S () {}\n+};\n+struct D : S {\n+  A a;\n+  long i;\n+  D() { { e ? &a[i] : nullptr; } }\n+};\n+template <>\n+struct C<int> { Z<S> m8 () const; };\n+Z<S>\n+C<int>::m8 () const\n+{\n+  D ();\n+}\n+"}, {"sha": "01c16208fb5f1e767f270e13e01d827b1fd80a13", "filename": "gcc/testsuite/g++.dg/lto/pr69589_1.C", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr69589_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4ada6afb970674c3f33d895ec793491a026c1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr69589_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr69589_1.C?ref=4f4ada6afb970674c3f33d895ec793491a026c1c", "patch": "@@ -0,0 +1,61 @@\n+struct A;\n+template <class T>\n+struct Q { Q (T); };\n+template<typename T, class D>\n+struct U {\n+  ~U () { m1 (nullptr); }\n+  D m2 ();\n+  T *u;\n+  void m1 (T *) { m2 () (u); }\n+};\n+struct F { F (int *); };\n+template <class, class T = F>\n+using W = Q<T>;\n+int a, b;\n+void fn1 (void *);\n+template <class T>\n+void\n+fn2 (T *x)\n+{\n+  if (x)\n+    x->~T();\n+  fn1 (x);\n+}\n+template <typename T>\n+struct C {\n+  void operator() (T *x) { fn2 (x); }\n+};\n+struct D;\n+template <typename T, typename D = C<T> >\n+using V = U<T, D>;\n+struct A {\n+  A (int *);\n+};\n+struct S;\n+struct G {\n+  V<S> m3 ();\n+};\n+struct S {\n+  int e;\n+  virtual ~S () {}\n+};\n+template<typename T>\n+struct H {\n+  H (int, T x, int) : h(x) {}\n+  G g;\n+  void m4 () { g.m3 (); }\n+  T h;\n+};\n+struct I {\n+  I(A, W<D>);\n+};\n+void\n+test ()\n+{\n+  A c (&b);\n+  W<D> d (&b);\n+  I e (c, d);\n+  H<I> f (0, e, a);\n+  f.m4 ();\n+}\n+"}]}