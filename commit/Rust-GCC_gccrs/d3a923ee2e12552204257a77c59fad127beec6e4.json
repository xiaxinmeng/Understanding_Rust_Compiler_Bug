{"sha": "d3a923ee2e12552204257a77c59fad127beec6e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNhOTIzZWUyZTEyNTUyMjA0MjU3YTc3YzU5ZmFkMTI3YmVlYzZlNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-09T19:47:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-09T19:47:18Z"}, "message": "Makefile.in (flow.o): Depend on TREE_H.\n\n\t* Makefile.in (flow.o): Depend on TREE_H.\n\t* basic-block.h (REG_SET_EQUAL_P): New.\n\t(XOR_REG_SET): New.\n\t(n_edges): Declare.\n\t(free_regset_vector): Remove declaration.\n\t(flow_delete_insn_chain): Declare.\n\t(enum update_life_extent): New.\n\t(update_life_info, count_or_remove_death_notes): Declare.\n\t* combine.c (distribute_notes) [REG_DEAD]: Stop search at bb->head.\n\tVerify register live at bb->global_live_at_start before adding USE.\n\t* flow.c (HAVE_epilogue, HAVE_prologue): Provide default.\n\t(CLEAN_ALLOCA): New.\n\t(n_edges): New.\n\t(PROP_*): New flags.\n\t(find_basic_blocks_1): Use alloc_EXPR_LIST.\n\t(clear_edges): Zero n_edges.\n\t(make_edge): Increment n_edges.\n\t(split_edge): Don't allocate bb->local_set.  Increment n_edges.\n\t(flow_delete_insn_chain): Export.\n\t(delete_block): Decrement n_edges.\n\t(merge_blocks_nomove): Likewise.\n\t(life_analysis): Give life_analysis_1 PROP flags.\n\t(verify_wide_reg_1, verify_wide_reg): New.\n\t(verify_local_live_at_start): New.\n\t(update_life_info): Rewrite to call into propogate_block.\n\t(mark_reg): New.\n\t(mark_regs_live_at_end): After reload, if epilogue as rtl,\n\talways mark stack pointer.  Conditionally mark PIC register.\n\tAfter reload, mark call-saved registers, return regsiters.\n\t(life_analysis_1): Accept PROP flags not remove_dead_code.\n\tCall mark_regs_live_at_end before zeroing regs_ever_live.\n\tUse calculate_global_regs_live.  Copy global_live_at_end before\n\tcalling final propagate_block.  Zero reg_next_use on exit.\n\t(calculate_global_regs_live): New.\n\t(allocate_bb_life_data): Don't allocate bb->local_set.\n\t(init_regset_vector, free_regset_vector): Remove.\n\t(propagate_block): Accept FLAGS not FINAL or REMOVE_DEAD_CODE.\n\tTest flags before every operation.  Warn if prologue/epilogue insn\n\twould have been deleted.\n\t(mark_set_regs, mark_set_1): Accept and use FLAGS.\n\tUse alloc_EXPR_LIST.\n\t(mark_used_regs): Accept and use FLAGS, not FINAL.\n\tRemove special handling for RETURN.\n\t(try_pre_increment): Use alloc_EXPR_LIST.\n\t(dump_flow_info): Dump n_edges.\n\t(unlink_insn_chain, split_hard_reg_notes): Remove.\n\t(maybe_add_dead_note, maybe_add_dead_note_use): Remove.\n\t(find_insn_with_note, new_insn_dead_notes): Remove.\n\t(update_n_sets, sets_reg_or_subreg_1, sets_reg_or_subreg): Remove.\n\t(maybe_remove_dead_notes, prepend_reg_notes): Remove.\n\t(replace_insns): Remove.\n\t(count_or_remove_death_notes): New.\n\t(verify_flow_info): Abort on error after all checks.\n\t(remove_edge): Decrement n_edges.\n\t(remove_fake_edges): Tweek format.\n\t* haifa-sched.c (schedule_insns): Use split_all_insns.\n\t* output.h (update_life_info): Remove declaration.\n\t* recog.c (split_all_insns): From the corpse of split_block_insns,\n\tdo the whole function block by block.  Use update_life_info.\n\t(recog_last_allowed_insn): New.\n\t(recog_next_insn): Mind it.\n\t(peephole2_optimize): Set it.  Walk backwards through blocks.\n\tUse update_life_info.\n\t* rtl.h (update_flow_info, replace_insns): Remove declarations.\n\t(split_all_insns): Declare.\n\t* toplev.c (rest_of_compilation): Thread prologue before flow2.\n\tUse split_all_insns.\n\n\t* i386.md (or -1 peep2s): Disable.\n\nFrom-SVN: r29877", "tree": {"sha": "979c66605d3637bf2f02aa8e816c05810e05aa54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/979c66605d3637bf2f02aa8e816c05810e05aa54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3a923ee2e12552204257a77c59fad127beec6e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a923ee2e12552204257a77c59fad127beec6e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3a923ee2e12552204257a77c59fad127beec6e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a923ee2e12552204257a77c59fad127beec6e4/comments", "author": null, "committer": null, "parents": [{"sha": "1640ef3802ce93dd63448f315b5923eb1e495665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1640ef3802ce93dd63448f315b5923eb1e495665", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1640ef3802ce93dd63448f315b5923eb1e495665"}], "stats": {"total": 2929, "additions": 1184, "deletions": 1745}, "files": [{"sha": "985530d86ef9c10453ebf881b108ab7de7d7923f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3a923ee2e12552204257a77c59fad127beec6e4", "patch": "@@ -1,3 +1,75 @@\n+Sat Oct  9 12:18:16 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* Makefile.in (flow.o): Depend on TREE_H.\n+\t* basic-block.h (REG_SET_EQUAL_P): New.\n+\t(XOR_REG_SET): New.\n+\t(n_edges): Declare.\n+\t(free_regset_vector): Remove declaration.\n+\t(flow_delete_insn_chain): Declare.\n+\t(enum update_life_extent): New.\n+\t(update_life_info, count_or_remove_death_notes): Declare.\n+\t* combine.c (distribute_notes) [REG_DEAD]: Stop search at bb->head.\n+\tVerify register live at bb->global_live_at_start before adding USE.\n+\t* flow.c (HAVE_epilogue, HAVE_prologue): Provide default.\n+\t(CLEAN_ALLOCA): New.\n+\t(n_edges): New.\t\n+\t(PROP_*): New flags.\n+\t(find_basic_blocks_1): Use alloc_EXPR_LIST.\n+\t(clear_edges): Zero n_edges.\n+\t(make_edge): Increment n_edges.\n+\t(split_edge): Don't allocate bb->local_set.  Increment n_edges.\n+\t(flow_delete_insn_chain): Export.\n+\t(delete_block): Decrement n_edges.\n+\t(merge_blocks_nomove): Likewise.\n+\t(life_analysis): Give life_analysis_1 PROP flags.\n+\t(verify_wide_reg_1, verify_wide_reg): New.\n+\t(verify_local_live_at_start): New.\n+\t(update_life_info): Rewrite to call into propogate_block.\n+\t(mark_reg): New.\n+\t(mark_regs_live_at_end): After reload, if epilogue as rtl, \n+\talways mark stack pointer.  Conditionally mark PIC register.\n+\tAfter reload, mark call-saved registers, return regsiters.\n+\t(life_analysis_1): Accept PROP flags not remove_dead_code.\n+\tCall mark_regs_live_at_end before zeroing regs_ever_live.\n+\tUse calculate_global_regs_live.  Copy global_live_at_end before\n+\tcalling final propagate_block.  Zero reg_next_use on exit.\n+\t(calculate_global_regs_live): New.\n+\t(allocate_bb_life_data): Don't allocate bb->local_set.\n+\t(init_regset_vector, free_regset_vector): Remove.\n+\t(propagate_block): Accept FLAGS not FINAL or REMOVE_DEAD_CODE.\n+\tTest flags before every operation.  Warn if prologue/epilogue insn\n+\twould have been deleted.\n+\t(mark_set_regs, mark_set_1): Accept and use FLAGS. \n+\tUse alloc_EXPR_LIST.\n+\t(mark_used_regs): Accept and use FLAGS, not FINAL.\n+\tRemove special handling for RETURN.\n+\t(try_pre_increment): Use alloc_EXPR_LIST.\n+\t(dump_flow_info): Dump n_edges.\n+\t(unlink_insn_chain, split_hard_reg_notes): Remove.\n+\t(maybe_add_dead_note, maybe_add_dead_note_use): Remove.\n+\t(find_insn_with_note, new_insn_dead_notes): Remove.\n+\t(update_n_sets, sets_reg_or_subreg_1, sets_reg_or_subreg): Remove.\n+\t(maybe_remove_dead_notes, prepend_reg_notes): Remove.\n+\t(replace_insns): Remove.\n+\t(count_or_remove_death_notes): New.\n+\t(verify_flow_info): Abort on error after all checks.\n+\t(remove_edge): Decrement n_edges.\n+\t(remove_fake_edges): Tweek format.\n+\t* haifa-sched.c (schedule_insns): Use split_all_insns.\n+\t* output.h (update_life_info): Remove declaration.\n+\t* recog.c (split_all_insns): From the corpse of split_block_insns,\n+\tdo the whole function block by block.  Use update_life_info.\n+\t(recog_last_allowed_insn): New.\n+\t(recog_next_insn): Mind it.\n+\t(peephole2_optimize): Set it.  Walk backwards through blocks.\n+\tUse update_life_info.\n+\t* rtl.h (update_flow_info, replace_insns): Remove declarations.\n+\t(split_all_insns): Declare.\n+\t* toplev.c (rest_of_compilation): Thread prologue before flow2.\n+\tUse split_all_insns.\n+\n+\t* i386.md (or -1 peep2s): Disable.\n+\n Fri Oct  8 17:49:08 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* config/mips/mips.md (movstrsi+[123]) : Combine these into"}, {"sha": "d9d5e1f1cb1899dbc51f3342e82784be062b58bb", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d3a923ee2e12552204257a77c59fad127beec6e4", "patch": "@@ -1549,7 +1549,7 @@ loop.o : loop.c $(CONFIG_H) system.h $(RTL_H) flags.h loop.h insn-config.h \\\n    function.h toplev.h varray.h\n unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h function.h \\\n    integrate.h $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) loop.h toplev.h varray.h\n-flow.o : flow.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-config.h \\\n+flow.o : flow.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h recog.h \\\n    insn-flags.h function.h\n combine.o : combine.c $(CONFIG_H) system.h $(RTL_H) flags.h function.h \\"}, {"sha": "ca63f73e25e68c01485101bc200dbdf415ae7426", "filename": "gcc/basic-block.h", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=d3a923ee2e12552204257a77c59fad127beec6e4", "patch": "@@ -31,6 +31,9 @@ typedef bitmap regset;\t\t/* Head of register set linked list.  */\n /* Copy a register set to another register set.  */\n #define COPY_REG_SET(TO, FROM) bitmap_copy (TO, FROM)\n \n+/* Compare two register sets.  */\n+#define REG_SET_EQUAL_P(A, B) bitmap_equal_p (A, B)\n+\n /* `and' a register set with a second register set.  */\n #define AND_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_AND)\n \n@@ -41,6 +44,9 @@ typedef bitmap regset;\t\t/* Head of register set linked list.  */\n /* Inclusive or a register set with a second register set.  */\n #define IOR_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_IOR)\n \n+/* Exclusive or a register set with a second register set.  */\n+#define XOR_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_XOR)\n+\n /* Or into TO the register set FROM1 `and'ed with the complement of FROM2.  */\n #define IOR_AND_COMPL_REG_SET(TO, FROM1, FROM2) \\\n   bitmap_ior_and_compl (TO, FROM1, FROM2)\n@@ -153,6 +159,10 @@ typedef struct basic_block_def {\n \n extern int n_basic_blocks;\n \n+/* Number of edges in the current function.  */\n+\n+extern int n_edges;\n+\n /* Index by basic block number, get basic block struct info.  */\n \n extern varray_type basic_block_info;\n@@ -229,9 +239,6 @@ extern struct basic_block_def entry_exit_blocks[2];\n #define ENTRY_BLOCK_PTR\t(&entry_exit_blocks[0])\n #define EXIT_BLOCK_PTR\t(&entry_exit_blocks[1])\n \n-/* from flow.c */\n-extern void free_regset_vector\t\tPROTO ((regset *, int nelts));\n-\n extern varray_type basic_block_for_insn;\n #define BLOCK_FOR_INSN(INSN)  VARRAY_BB (basic_block_for_insn, INSN_UID (INSN))\n #define BLOCK_NUM(INSN)\t      (BLOCK_FOR_INSN (INSN)->index + 0)\n@@ -249,6 +256,7 @@ extern void insert_insn_on_edge\t\tPROTO ((rtx, edge));\n extern void commit_edge_insertions\tPROTO ((void));\n extern void remove_fake_edges\t\tPROTO ((void));\n extern void add_noreturn_fake_exit_edges\tPROTO ((void));\n+extern void flow_delete_insn_chain\tPROTO((rtx, rtx));\n \n /* This structure maintains an edge list vector.  */\n struct edge_list \n@@ -291,6 +299,15 @@ extern void compute_dominators\t\tPROTO ((sbitmap *, sbitmap *,\n extern void compute_flow_dominators\tPROTO ((sbitmap *, sbitmap *));\n extern void compute_immediate_dominators\tPROTO ((int *, sbitmap *));\n \n+enum update_life_extent\n+{\n+  UPDATE_LIFE_GLOBAL = 0,\n+  UPDATE_LIFE_LOCAL = 1\n+};\n+\n+extern void update_life_info\tPROTO ((sbitmap, enum update_life_extent));\n+extern int count_or_remove_death_notes\tPROTO ((sbitmap, int));\n+\n /* In lcm.c */\n extern void pre_lcm \t\t\tPROTO ((int, int, int_list_ptr *,\n \t\t\t\t\t\tint_list_ptr *,"}, {"sha": "0e634aeb22f35032ea074c04c5337d6ea858ce60", "filename": "gcc/combine.c", "status": "modified", "additions": 68, "deletions": 46, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=d3a923ee2e12552204257a77c59fad127beec6e4", "patch": "@@ -11721,11 +11721,17 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \n \t  if (place == 0)\n \t    {\n-\t      for (tem = prev_nonnote_insn (i3);\n-\t\t   place == 0 && tem\n-\t\t   && (GET_CODE (tem) == INSN || GET_CODE (tem) == CALL_INSN);\n-\t\t   tem = prev_nonnote_insn (tem))\n+\t      basic_block bb = BASIC_BLOCK (this_basic_block);\n+\n+\t      for (tem = PREV_INSN (i3); place == 0; tem = PREV_INSN (tem))\n \t\t{\n+\t\t  if (GET_RTX_CLASS (GET_CODE (tem)) != 'i')\n+\t\t    {\n+\t\t      if (tem == bb->head)\n+\t\t\tbreak;\n+\t\t      continue;\n+\t\t    }\n+\n \t\t  /* If the register is being set at TEM, see if that is all\n \t\t     TEM is doing.  If so, delete TEM.  Otherwise, make this\n \t\t     into a REG_UNUSED note instead.  */\n@@ -11740,8 +11746,8 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t      if (set != 0)\n \t\t\tfor (inner_dest = SET_DEST (set);\n \t\t\t     GET_CODE (inner_dest) == STRICT_LOW_PART\n-\t\t\t     || GET_CODE (inner_dest) == SUBREG\n-\t\t\t     || GET_CODE (inner_dest) == ZERO_EXTRACT;\n+\t\t\t       || GET_CODE (inner_dest) == SUBREG\n+\t\t\t       || GET_CODE (inner_dest) == ZERO_EXTRACT;\n \t\t\t     inner_dest = XEXP (inner_dest, 0))\n \t\t\t  ;\n \n@@ -11789,7 +11795,8 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\t      distribute_links (LOG_LINKS (cc0_setter));\n \n \t\t\t      PUT_CODE (cc0_setter, NOTE);\n-\t\t\t      NOTE_LINE_NUMBER (cc0_setter) = NOTE_INSN_DELETED;\n+\t\t\t      NOTE_LINE_NUMBER (cc0_setter)\n+\t\t\t\t= NOTE_INSN_DELETED;\n \t\t\t      NOTE_SOURCE_FILE (cc0_setter) = 0;\n \t\t\t    }\n #endif\n@@ -11818,48 +11825,64 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\t\t\t\t REGNO (XEXP (note, 0))))\n \t\t\t    place = tem;\n \t\t\t  break;\n-\t\t      }\n-\t\t  }\n-\t\telse if (reg_referenced_p (XEXP (note, 0), PATTERN (tem))\n-\t\t\t || (GET_CODE (tem) == CALL_INSN\n-\t\t\t     && find_reg_fusage (tem, USE, XEXP (note, 0))))\n-\t\t  {\n-\t\t    place = tem;\n-\n-\t\t    /* If we are doing a 3->2 combination, and we have a\n-\t\t       register which formerly died in i3 and was not used\n-\t\t       by i2, which now no longer dies in i3 and is used in\n-\t\t       i2 but does not die in i2, and place is between i2\n-\t\t       and i3, then we may need to move a link from place to\n-\t\t       i2.  */\n-\t\t    if (i2 && INSN_UID (place) <= max_uid_cuid\n-\t\t\t&& INSN_CUID (place) > INSN_CUID (i2)\n-\t\t\t&& from_insn && INSN_CUID (from_insn) > INSN_CUID (i2)\n-\t\t\t&& reg_referenced_p (XEXP (note, 0), PATTERN (i2)))\n-\t\t      {\n-\t\t\trtx links = LOG_LINKS (place);\n-\t\t\tLOG_LINKS (place) = 0;\n-\t\t\tdistribute_links (links);\n-\t\t      }\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (reg_referenced_p (XEXP (note, 0), PATTERN (tem))\n+\t\t\t   || (GET_CODE (tem) == CALL_INSN\n+\t\t\t       && find_reg_fusage (tem, USE, XEXP (note, 0))))\n+\t\t    {\n+\t\t      place = tem;\n+\n+\t\t      /* If we are doing a 3->2 combination, and we have a\n+\t\t\t register which formerly died in i3 and was not used\n+\t\t\t by i2, which now no longer dies in i3 and is used in\n+\t\t\t i2 but does not die in i2, and place is between i2\n+\t\t\t and i3, then we may need to move a link from place to\n+\t\t\t i2.  */\n+\t\t      if (i2 && INSN_UID (place) <= max_uid_cuid\n+\t\t\t  && INSN_CUID (place) > INSN_CUID (i2)\n+\t\t\t  && from_insn && INSN_CUID (from_insn) > INSN_CUID (i2)\n+\t\t\t  && reg_referenced_p (XEXP (note, 0), PATTERN (i2)))\n+\t\t\t{\n+\t\t\t  rtx links = LOG_LINKS (place);\n+\t\t\t  LOG_LINKS (place) = 0;\n+\t\t\t  distribute_links (links);\n+\t\t\t}\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  if (tem == bb->head)\n \t\t    break;\n-\t\t  }\n \t\t}\n \t      \n-\t      /* If we haven't found an insn for the death note and it\n-\t\t is still a REG_DEAD note, but we have hit a CODE_LABEL,\n-\t\t insert a USE insn for the register at that label and\n-\t\t put the death node there.  This prevents problems with\n-\t\t call-state tracking in caller-save.c.  */\n-\t      if (REG_NOTE_KIND (note) == REG_DEAD && place == 0 && tem != 0)\n+\t      /* We haven't found an insn for the death note and it\n+\t\t is still a REG_DEAD note, but we have hit the beginning\n+\t\t of the block.  If the existing life info says the reg\n+\t\t was dead, there's nothing left to do.\n+\n+\t\t ??? If the register was live, we ought to mark for later\n+\t\t global life update.  Cop out like the previous code and\n+\t\t just add a hook for the death note to live on.  */\n+\t      if (REG_NOTE_KIND (note) == REG_DEAD && place == 0)\n \t\t{\n-\t\t  place\n-\t\t    = emit_insn_after (gen_rtx_USE (VOIDmode, XEXP (note, 0)),\n-\t\t\t\t       tem);\n-\n-\t\t  /* If this insn was emitted between blocks, then update\n-\t\t     BLOCK_HEAD of the current block to include it.  */\n-\t\t  if (BLOCK_END (this_basic_block - 1) == tem)\n-\t\t    BLOCK_HEAD (this_basic_block) = place;\n+\t\t  int regno = REGNO (XEXP (note, 0));\n+\n+\t\t  if (REGNO_REG_SET_P (bb->global_live_at_start, regno))\n+\t\t    {\n+\t\t      rtx die = gen_rtx_USE (VOIDmode, XEXP (note, 0));\n+\n+\t\t      place = bb->head;\n+\t\t      if (GET_CODE (place) != CODE_LABEL\n+\t\t\t  && GET_CODE (place) != NOTE)\n+\t\t\t{\n+\t\t\t  place = emit_insn_before (die, place);\n+\t\t\t  bb->head = place;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  place = emit_insn_after (die, place);\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -11869,7 +11892,6 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t     which is what `dead_or_set_p' checks, so also check for it being\n \t     set partially.  */\n \n-\n \t  if (place && REG_NOTE_KIND (note) == REG_DEAD)\n \t    {\n \t      int regno = REGNO (XEXP (note, 0));"}, {"sha": "1a90d1fe35bd5d4418811206461e7cae37f50b2e", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d3a923ee2e12552204257a77c59fad127beec6e4", "patch": "@@ -8146,11 +8146,14 @@\n \t      (clobber (reg:CC 17))])]\n   \"\")\n \n+;; ??? Rewrite these to not introduce the false dependancy.  \n+;; Currently they'll trip update_life_info's sanity checks.\n+\n ;; For HI and SI modes, or $-1,reg is smaller than mov $-1,reg.\n (define_peephole2\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(const_int -1))]\n-  \"(optimize_size || TARGET_PENTIUM)\n+  \"0 && (optimize_size || TARGET_PENTIUM)\n    && reg_dead_p (insn, gen_rtx_REG (CCmode, FLAGS_REG))\"\n   [(parallel [(set (match_dup 0)\n \t\t   (ior:SI (match_dup 0) (const_int -1)))\n@@ -8160,7 +8163,7 @@\n (define_peephole2\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(const_int -1))]\n-  \"(optimize_size || TARGET_PENTIUM)\n+  \"0 && (optimize_size || TARGET_PENTIUM)\n    && reg_dead_p (insn, gen_rtx_REG (CCmode, FLAGS_REG))\"\n   [(parallel [(set (match_dup 0)\n \t\t   (ior:HI (match_dup 0) (const_int -1)))"}, {"sha": "9418b8b0bf33e69563cefdfc416f3a2bbd565ece", "filename": "gcc/flow.c", "status": "modified", "additions": 873, "deletions": 1569, "changes": 2442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=d3a923ee2e12552204257a77c59fad127beec6e4"}, {"sha": "1c1ffad746dcb181e994422b65c6dcd9f00e6507", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=d3a923ee2e12552204257a77c59fad127beec6e4", "patch": "@@ -7773,9 +7773,7 @@ schedule_insns (dump_file)\n   /* Initialize issue_rate.  */\n   issue_rate = ISSUE_RATE;\n \n-  /* Do the splitting first for all blocks.  */\n-  for (b = 0; b < n_basic_blocks; b++)\n-    split_block_insns (b, 1);\n+  split_all_insns (1);\n \n   max_uid = (get_max_uid () + 1);\n "}, {"sha": "a0f24623df0a85f0141294f943540a9f88000998", "filename": "gcc/output.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=d3a923ee2e12552204257a77c59fad127beec6e4", "patch": "@@ -135,7 +135,6 @@ extern void find_basic_blocks         PROTO((rtx, int, FILE *, int));\n extern void free_basic_block_vars     PROTO((int));\n extern void set_block_num             PROTO((rtx, int));\n extern void life_analysis             PROTO((rtx, int, FILE *, int));\n-extern void update_life_info\t        PROTO((rtx, rtx, rtx, rtx, rtx));\n #endif\n \n /* Functions in varasm.c.  */"}, {"sha": "1d277304e2a65863204a871efe98bf4feef6c64d", "filename": "gcc/recog.c", "status": "modified", "additions": 135, "deletions": 90, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=d3a923ee2e12552204257a77c59fad127beec6e4", "patch": "@@ -2562,88 +2562,104 @@ reg_fits_class_p (operand, class, offset, mode)\n   return 0;\n }\n \f\n-/* Do the splitting of insns in the block B. Only try to actually split if\n-   DO_SPLIT is true; otherwise, just remove nops. */ \n+/* Split all insns in the function.  If UPD_LIFE, update life info after.  */\n \n void\n-split_block_insns (b, do_split)\n-     int b;\n-     int do_split;\n+split_all_insns (upd_life)\n+     int upd_life;\n {\n-  rtx insn, next;\n+  sbitmap blocks;\n+  int changed;\n+  int i;\n+\n+  blocks = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (blocks);\n+  changed = 0;\n \n-  for (insn = BLOCK_HEAD (b);; insn = next)\n+  for (i = n_basic_blocks - 1; i >= 0; --i)\n     {\n-      rtx set;\n+      basic_block bb = BASIC_BLOCK (i);\n+      rtx insn, next;\n \n-      /* Can't use `next_real_insn' because that\n-         might go across CODE_LABELS and short-out basic blocks.  */\n-      next = NEXT_INSN (insn);\n-      if (GET_CODE (insn) != INSN)\n+      for (insn = bb->head; insn ; insn = next)\n \t{\n-\t  if (insn == BLOCK_END (b))\n-\t    break;\n+\t  rtx set;\n \n-\t  continue;\n-\t}\n+\t  /* Can't use `next_real_insn' because that might go across\n+\t     CODE_LABELS and short-out basic blocks.  */\n+\t  next = NEXT_INSN (insn);\n+\t  if (GET_CODE (insn) != INSN)\n+\t    ;\n \n-      /* Don't split no-op move insns.  These should silently disappear\n-         later in final.  Splitting such insns would break the code\n-         that handles REG_NO_CONFLICT blocks.  */\n-      set = single_set (insn);\n-      if (set && rtx_equal_p (SET_SRC (set), SET_DEST (set)))\n-\t{\n-\t  if (insn == BLOCK_END (b))\n-\t    break;\n+\t  /* Don't split no-op move insns.  These should silently\n+\t     disappear later in final.  Splitting such insns would\n+\t     break the code that handles REG_NO_CONFLICT blocks.  */\n \n-\t  /* Nops get in the way while scheduling, so delete them now if\n-\t     register allocation has already been done.  It is too risky\n-\t     to try to do this before register allocation, and there are\n-\t     unlikely to be very many nops then anyways.  */\n-\t  if (reload_completed)\n+\t  else if ((set = single_set (insn)) != NULL\n+\t\t   && rtx_equal_p (SET_SRC (set), SET_DEST (set)))\n \t    {\n-\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n+\t      /* Nops get in the way while scheduling, so delete them\n+\t\t now if register allocation has already been done.  It\n+\t\t is too risky to try to do this before register\n+\t\t allocation, and there are unlikely to be very many\n+\t\t nops then anyways.  */\n+\t      if (reload_completed)\n+\t\t{\n+\t\t  PUT_CODE (insn, NOTE);\n+\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t\t}\n \t    }\n-\n-\t  continue;\n-\t}\n-\n-      if (do_split)\n-\t{\n-\t  /* Split insns here to get max fine-grain parallelism.  */\n-\t  rtx first = PREV_INSN (insn);\n-\t  rtx notes = REG_NOTES (insn);\n-\t  rtx last = try_split (PATTERN (insn), insn, 1);\n-\n-\t  if (last != insn)\n+\t  else\n \t    {\n-\t      /* try_split returns the NOTE that INSN became.  */\n-\t      first = NEXT_INSN (first);\n-#ifdef INSN_SCHEDULING\n-\t      update_life_info (notes, first, last, insn, insn);\n-#endif\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t      if (insn == BLOCK_HEAD (b))\n-\t\tBLOCK_HEAD (b) = first;\n-\t      if (insn == BLOCK_END (b))\n+\t      /* Split insns here to get max fine-grain parallelism.  */\n+\t      rtx first = PREV_INSN (insn);\n+\t      rtx last = try_split (PATTERN (insn), insn, 1);\n+\n+\t      if (last != insn)\n \t\t{\n-\t\t  BLOCK_END (b) = last;\n-\t\t  break;\n+\t\t  SET_BIT (blocks, i);\n+\t\t  changed = 1;\n+\n+\t\t  /* try_split returns the NOTE that INSN became.  */\n+\t\t  first = NEXT_INSN (first);\n+\t\t  PUT_CODE (insn, NOTE);\n+\t\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\n+\t\t  if (insn == bb->end)\n+\t\t    {\n+\t\t      bb->end = last;\n+\t\t      break;\n+\t\t    }\n \t\t}\n \t    }\n+\n+\t  if (insn == bb->end)\n+\t    break;\n \t}\n \n-      if (insn == BLOCK_END (b))\n-\tbreak;\n+      /* ??? When we're called from just after reload, the CFG is in bad\n+\t shape, and we may have fallen off the end.  This could be fixed\n+\t by having reload not try to delete unreachable code.  Otherwise\n+\t assert we found the end insn.  */\n+      if (insn == NULL && upd_life)\n+\tabort ();\n     }\n+\n+  if (changed && upd_life)\n+    {\n+      count_or_remove_death_notes (blocks, 1);\n+      update_life_info (blocks, UPDATE_LIFE_LOCAL);\n+    }\n+\n+  sbitmap_free (blocks);\n }\n \f\n #ifdef HAVE_peephole2\n+/* This is the last insn we'll allow recog_next_insn to consider.  */\n+static rtx recog_last_allowed_insn;\n+\n /* Return the Nth non-note insn after INSN, or return NULL_RTX if it does\n    not exist.  Used by the recognizer to find the next insn to match in a\n    multi-insn pattern.  */\n@@ -2652,17 +2668,20 @@ recog_next_insn (insn, n)\n      rtx insn;\n      int n;\n {\n-  while (insn != NULL_RTX && n > 0)\n+  if (insn != NULL_RTX)\n     {\n-      insn = next_nonnote_insn (insn);\n-\n-      if (insn == NULL_RTX)\n-\treturn insn;\n+      while (n > 0)\n+\t{\n+\t  if (insn == recog_last_allowed_insn)\n+\t    return NULL_RTX;\n \n-      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n-\treturn NULL_RTX;\n+\t  insn = NEXT_INSN (insn);\n+\t  if (insn == NULL_RTX)\n+\t    break;\n \n-      n--;\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t    n -= 1;\n+\t}\n     }\n \n   return insn;\n@@ -2673,38 +2692,64 @@ void\n peephole2_optimize (dump_file)\n      FILE *dump_file ATTRIBUTE_UNUSED;\n {\n-  rtx insn;\n-  rtx epilogue_insn = 0;\n+  rtx insn, prev;\n+  int i, changed;\n+  sbitmap blocks;\n \n-  for (insn = get_last_insn (); insn != NULL_RTX; insn = PREV_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n-\t{\n-\t  epilogue_insn = insn;\n-\t  break;\n-\t}\n-    }\n+  /* ??? TODO: Arrange with resource.c to start at bb->global_live_at_end\n+     and backtrack insn by insn as we proceed through the block.  In this\n+     way we'll not need to keep searching forward from the beginning of \n+     basic blocks to find register life info.  */\n \n-  init_resource_info (epilogue_insn);\n+  init_resource_info (NULL);\n \n-  for (insn = get_insns (); insn != NULL;\n-       insn = next_nonnote_insn (insn))\n+  blocks = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (blocks);\n+  changed = 0;\n+\n+  for (i = n_basic_blocks - 1; i >= 0; --i)\n     {\n-      if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n-\t{\n-\t  rtx last_insn;\n-\t  rtx before = PREV_INSN (insn);\n+      basic_block bb = BASIC_BLOCK (i);\n+\n+      /* Since we don't update life info until the very end, we can't\n+\t allow matching instructions that we've replaced before.  Walk\n+\t backward through the basic block so that we don't have to \n+\t care about subsequent life info; recog_last_allowed_insn to\n+\t restrict how far forward we will allow the match to proceed.  */\n \n-\t  rtx try = peephole2_insns (PATTERN (insn), insn, &last_insn);\n-\t  if (try != NULL)\n+      recog_last_allowed_insn = bb->end;\n+      for (insn = bb->end; ; insn = prev)\n+\t{\n+\t  prev = PREV_INSN (insn);\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t    {\n-\t      replace_insns (insn, last_insn, try, NULL_RTX);\n-\t      insn = NEXT_INSN (before);\n+\t      rtx try, last_insn;\n+\n+\t      try = peephole2_insns (PATTERN (insn), insn, &last_insn);\n+\t      if (try != NULL)\n+\t\t{\n+\t\t  flow_delete_insn_chain (insn, last_insn);\n+\t\t  try = emit_insn_after (try, prev);\n+\n+\t\t  if (last_insn == bb->end)\n+\t\t    bb->end = try;\n+\t\t  if (insn == bb->head)\n+\t\t    bb->head = NEXT_INSN (prev);\n+\n+\t\t  recog_last_allowed_insn = prev;\n+\t\t  SET_BIT (blocks, i);\n+\t\t  changed = 1;\n+\t\t}\n \t    }\n+\n+\t  if (insn == bb->head)\n+\t    break;\n \t}\n     }\n \n   free_resource_info ();\n+\n+  count_or_remove_death_notes (blocks, 1);\n+  update_life_info (blocks, UPDATE_LIFE_LOCAL);\n }\n #endif"}, {"sha": "8bd4871bf90749f51d8e54d9fbfaab3ad1be0051", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d3a923ee2e12552204257a77c59fad127beec6e4", "patch": "@@ -1168,8 +1168,7 @@ extern enum reg_class reg_alternate_class PROTO((int));\n \n extern rtx get_first_nonparm_insn\tPROTO((void));\n \n-extern void split_block_insns\t\tPROTO((int, int));\n-extern void update_flow_info\t\tPROTO((rtx, rtx, rtx, rtx));\n+extern void split_all_insns\t\tPROTO((int));\n \n #define MAX_SAVED_CONST_INT 64\n extern rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n@@ -1542,7 +1541,6 @@ extern void print_rtl_with_bb\t\tPROTO ((FILE *, rtx));\n extern void dump_flow_info\t\tPROTO ((FILE *));\n #endif\n extern void free_bb_mem\t\t\tPROTO ((void));\n-extern void replace_insns               PROTO ((rtx, rtx, rtx, rtx));\n \n /* In expmed.c */\n extern void init_expmed\t\t\tPROTO ((void));"}, {"sha": "2e5a508ce55d949bd0c9a012dea1468e2d03cf2c", "filename": "gcc/toplev.c", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a923ee2e12552204257a77c59fad127beec6e4/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d3a923ee2e12552204257a77c59fad127beec6e4", "patch": "@@ -4149,33 +4149,21 @@ rest_of_compilation (decl)\n   if (rebuild_label_notes_after_reload)\n     TIMEVAR (jump_time, rebuild_jump_labels (insns));\n \n+  /* On some machines, the prologue and epilogue code, or parts thereof,\n+     can be represented as RTL.  Doing so lets us schedule insns between\n+     it and the rest of the code and also allows delayed branch\n+     scheduling to operate in the epilogue.  */\n+\n+  thread_prologue_and_epilogue_insns (insns);\n+\n   /* If optimizing and we are performing instruction scheduling after\n      reload, then go ahead and split insns now since we are about to\n      recompute flow information anyway.\n \n      reload_cse_regs may expose more splitting opportunities, expecially\n      for double-word operations.  */\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n-    {\n-      rtx insn;\n-\n-      for (insn = insns; insn; insn = NEXT_INSN (insn))\n-\t{\n-\t  rtx last;\n-\n-\t  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n-\t    continue;\n-\n-\t  last = try_split (PATTERN (insn), insn, 1);\n-\n-\t  if (last != insn)\n-\t    {\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t    }\n-\t}\n-    }\n+    split_all_insns (0);\n \n   if (global_reg_dump)\n     {\n@@ -4204,13 +4192,6 @@ rest_of_compilation (decl)\n \n   flow2_completed = 1;\n \n-  /* On some machines, the prologue and epilogue code, or parts thereof,\n-     can be represented as RTL.  Doing so lets us schedule insns between\n-     it and the rest of the code and also allows delayed branch\n-     scheduling to operate in the epilogue.  */\n-\n-  thread_prologue_and_epilogue_insns (insns);\n-\n   if (flow2_dump)\n     {\n       close_dump_file (print_rtl_with_bb, insns);"}]}