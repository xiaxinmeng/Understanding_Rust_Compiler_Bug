{"sha": "35cbb299153f4c8e604c000c68b139da156585fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVjYmIyOTkxNTNmNGM4ZTYwNGMwMDBjNjhiMTM5ZGExNTY1ODVmZA==", "commit": {"author": {"name": "Kai Tietz", "email": "kai.tietz@onevision.com", "date": "2008-07-06T14:51:58Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2008-07-06T14:51:58Z"}, "message": "config.gcc (extra_headers): Add cross-stdarg.h for target x86_64-*-* and i?86-*-*.\n\n2008-07-06  Kai Tietz  <kai.tietz@onevision.com>\n\n\t* config.gcc (extra_headers): Add cross-stdarg.h for target\n\tx86_64-*-* and i?86-*-*.\n\t* config/i386/cross-stdarg.h: New.\n\t* builtins.c (std_fn_abi_va_list): New.\n\t(std_canonical_va_list_type): New.\n\t(stabilize_va_list): Replace va_list_type_node use by\n\tmtarget.canonical_va_list_type.\n\t(gimplify_va_arg_expr): Likewise.\n\t(expand_builtin_va_copy): Replace va_list_type_node use by\n\tmtarget.fn_abi_va_list.\n\t* tree-sra.c (is_va_list_type): New helper.\n\t(decl_can_be_decomposed_p): Replace\n\tva_list_type_node use by is_va_list_type.\n\t* tree-ssa-ccp.c (optimize_stdarg_builtin): Likewise.\n\t* tree-stdarg.c (execute_optimize_stdarg): Likewise.\n\t* c-common.c (c_common_nodes_and_builtins): Use TARGET_ENUM_VA_LIST.\n\t* config/i386/i386-protos.h (ix86_get_valist_type): New.\n\t(ix86_enum_va_list): New.\n\t* config/i386/i386.c (sysv_va_list_type_node): New.\n\t(ms_va_list_type_node): New.\n\t(ix86_function_type_abi): Remove sorry.\n\t(ix86_build_builtin_va_list_abi): New.\n\t(ix86_build_builtin_va_list): Call ix86_build_builtin_va_list_abi\n\tfor 64-bit targets.\n\t(ix86_va_start): Replace va_list_type_node by sysv_va_list_type_node.\n\t(ix86_init_builtins_va_builtins_abi): New.\n\t(ix86_init_builtins): Use ix86_init_builtins_va_builtins_abi\n\tfor 64-bit targets.\n\t(ix86_handle_abi_attribute): New.\n\t(attribute_spec): Add sysv_abi and ms_abi.\n\t(ix86_fn_abi_va_list): New.\n\t(ix86_canonical_va_list_type): New.\n\t(ix86_enum_va_list): New.\n\t(TARGET_FN_ABI_VA_LIST): New.\n\t(TARGET_CANONICAL_VA_LIST_TYPE): New.\n\t* config/i386/i386.h (TARGET_ENUM_VA_LIST): New.\n\t* doc/tm.texi (TARGET_FN_ABI_VA_LIST): New.\n\t(TARGET_CANONICAL_VA_LIST_TYPE): New.\n\t(TARGET_ENUM_VA_LIST): New.\n\t* expr.h (std_fn_abi_va_list): New.\n\t(std_canonical_va_list_type): New.\n\t* target-def.h (TARGET_FN_ABI_VA_LIST): New.\n\t(TARGET_CANONICAL_VA_LIST_TYPE): New.\n\t(TARGET_INITIALIZER): Add TARGET_FN_ABI_VA_LIST and\n\tTARGET_CANONICAL_VA_LIST_TYPE.\n\t* target.h (struct gcc_target): Add fn_abi_va_list hook\n\tand canonical_va_list_type hook.\n\nFrom-SVN: r137525", "tree": {"sha": "62ff1d086ba0f6eecd1677d770c67586ca43fdd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62ff1d086ba0f6eecd1677d770c67586ca43fdd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35cbb299153f4c8e604c000c68b139da156585fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35cbb299153f4c8e604c000c68b139da156585fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35cbb299153f4c8e604c000c68b139da156585fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35cbb299153f4c8e604c000c68b139da156585fd/comments", "author": null, "committer": null, "parents": [{"sha": "b6b02c5528b662733f3555dec2a397b3269c22d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6b02c5528b662733f3555dec2a397b3269c22d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6b02c5528b662733f3555dec2a397b3269c22d6"}], "stats": {"total": 654, "additions": 588, "deletions": 66}, "files": [{"sha": "9ee63476e12a240150736db933e3b20c2b37ffb6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -1,3 +1,53 @@\n+2008-07-06  Kai Tietz  <kai.tietz@onevision.com>\n+\n+\t* config.gcc (extra_headers): Add cross-stdarg.h for target\n+\tx86_64-*-* and i?86-*-*.\n+\t* config/i386/cross-stdarg.h: New.\n+\t* builtins.c (std_fn_abi_va_list): New.\n+\t(std_canonical_va_list_type): New.\n+\t(stabilize_va_list): Replace va_list_type_node use by\n+\tmtarget.canonical_va_list_type.\n+\t(gimplify_va_arg_expr): Likewise.\n+\t(expand_builtin_va_copy): Replace va_list_type_node use by\n+\tmtarget.fn_abi_va_list.\n+\t* tree-sra.c (is_va_list_type): New helper.\n+\t(decl_can_be_decomposed_p): Replace\n+\tva_list_type_node use by is_va_list_type.\n+\t* tree-ssa-ccp.c (optimize_stdarg_builtin): Likewise.\n+\t* tree-stdarg.c (execute_optimize_stdarg): Likewise.\n+\t* c-common.c (c_common_nodes_and_builtins): Use TARGET_ENUM_VA_LIST.\n+\t* config/i386/i386-protos.h (ix86_get_valist_type): New.\n+\t(ix86_enum_va_list): New.\n+\t* config/i386/i386.c (sysv_va_list_type_node): New.\n+\t(ms_va_list_type_node): New.\n+\t(ix86_function_type_abi): Remove sorry.\n+\t(ix86_build_builtin_va_list_abi): New.\n+\t(ix86_build_builtin_va_list): Call ix86_build_builtin_va_list_abi\n+\tfor 64-bit targets.\n+\t(ix86_va_start): Replace va_list_type_node by sysv_va_list_type_node.\n+\t(ix86_init_builtins_va_builtins_abi): New.\n+\t(ix86_init_builtins): Use ix86_init_builtins_va_builtins_abi\n+\tfor 64-bit targets.\n+\t(ix86_handle_abi_attribute): New.\n+\t(attribute_spec): Add sysv_abi and ms_abi.\n+\t(ix86_fn_abi_va_list): New.\n+\t(ix86_canonical_va_list_type): New.\n+\t(ix86_enum_va_list): New.\n+\t(TARGET_FN_ABI_VA_LIST): New.\n+\t(TARGET_CANONICAL_VA_LIST_TYPE): New.\n+\t* config/i386/i386.h (TARGET_ENUM_VA_LIST): New.\n+\t* doc/tm.texi (TARGET_FN_ABI_VA_LIST): New.\n+\t(TARGET_CANONICAL_VA_LIST_TYPE): New.\n+\t(TARGET_ENUM_VA_LIST): New.\n+\t* expr.h (std_fn_abi_va_list): New.\n+\t(std_canonical_va_list_type): New.\n+\t* target-def.h (TARGET_FN_ABI_VA_LIST): New.\n+\t(TARGET_CANONICAL_VA_LIST_TYPE): New.\n+\t(TARGET_INITIALIZER): Add TARGET_FN_ABI_VA_LIST and\n+\tTARGET_CANONICAL_VA_LIST_TYPE.\n+\t* target.h (struct gcc_target): Add fn_abi_va_list hook\n+\tand canonical_va_list_type hook.\n+\n 2008-07-05  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* fold-const.c (fold_convert_const): Treat OFFSET_TYPE the same as"}, {"sha": "2d6ad2a1a34eed1d21fe5b9524ad32fdc27c1d44", "filename": "gcc/builtins.c", "status": "modified", "additions": 66, "deletions": 34, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -4623,18 +4623,22 @@ expand_builtin_next_arg (void)\n static tree\n stabilize_va_list (tree valist, int needs_lvalue)\n {\n-  if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n+  tree vatype = targetm.canonical_va_list_type (TREE_TYPE (valist));\n+\n+  gcc_assert (vatype != NULL_TREE);\n+\n+  if (TREE_CODE (vatype) == ARRAY_TYPE)\n     {\n       if (TREE_SIDE_EFFECTS (valist))\n \tvalist = save_expr (valist);\n \n       /* For this case, the backends will be expecting a pointer to\n-\t TREE_TYPE (va_list_type_node), but it's possible we've\n-\t actually been given an array (an actual va_list_type_node).\n+\t vatype, but it's possible we've actually been given an array\n+\t (an actual TARGET_CANONICAL_VA_LIST_TYPE (valist)).\n \t So fix it.  */\n       if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n \t{\n-\t  tree p1 = build_pointer_type (TREE_TYPE (va_list_type_node));\n+\t  tree p1 = build_pointer_type (TREE_TYPE (vatype));\n \t  valist = build_fold_addr_expr_with_type (valist, p1);\n \t}\n     }\n@@ -4647,7 +4651,7 @@ stabilize_va_list (tree valist, int needs_lvalue)\n \t  if (! TREE_SIDE_EFFECTS (valist))\n \t    return valist;\n \n-\t  pt = build_pointer_type (va_list_type_node);\n+\t  pt = build_pointer_type (vatype);\n \t  valist = fold_build1 (ADDR_EXPR, pt, valist);\n \t  TREE_SIDE_EFFECTS (valist) = 1;\n \t}\n@@ -4668,6 +4672,47 @@ std_build_builtin_va_list (void)\n   return ptr_type_node;\n }\n \n+/* The \"standard\" abi va_list is va_list_type_node.  */\n+\n+tree\n+std_fn_abi_va_list (tree fndecl ATTRIBUTE_UNUSED)\n+{\n+  return va_list_type_node;\n+}\n+\n+/* The \"standard\" type of va_list is va_list_type_node.  */\n+\n+tree\n+std_canonical_va_list_type (tree type)\n+{\n+  tree wtype, htype;\n+\n+  if (INDIRECT_REF_P (type))\n+    type = TREE_TYPE (type);\n+  else if (POINTER_TYPE_P (type) && POINTER_TYPE_P (TREE_TYPE(type)))\n+    type = TREE_TYPE (type);\n+\n+  wtype = va_list_type_node;\n+  htype = type;\n+  if (TREE_CODE (wtype) == ARRAY_TYPE)\n+    {\n+      /* If va_list is an array type, the argument may have decayed\n+\t to a pointer type, e.g. by being passed to another function.\n+\t In that case, unwrap both types so that we can compare the\n+\t underlying records.  */\n+      if (TREE_CODE (htype) == ARRAY_TYPE\n+\t  || POINTER_TYPE_P (htype))\n+\t{\n+\t  wtype = TREE_TYPE (wtype);\n+\t  htype = TREE_TYPE (htype);\n+\t}\n+    }\n+  if (TYPE_MAIN_VARIANT (wtype) == TYPE_MAIN_VARIANT (htype))\n+    return va_list_type_node;\n+\n+  return NULL_TREE;\n+}\n+\n /* The \"standard\" implementation of va_start: just assign `nextarg' to\n    the variable.  */\n \n@@ -4823,41 +4868,26 @@ dummy_object (tree type)\n enum gimplify_status\n gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n {\n-  tree promoted_type, want_va_type, have_va_type;\n+  tree promoted_type, have_va_type;\n   tree valist = TREE_OPERAND (*expr_p, 0);\n   tree type = TREE_TYPE (*expr_p);\n   tree t;\n \n   /* Verify that valist is of the proper type.  */\n-  want_va_type = va_list_type_node;\n   have_va_type = TREE_TYPE (valist);\n-\n   if (have_va_type == error_mark_node)\n     return GS_ERROR;\n+  have_va_type = targetm.canonical_va_list_type (have_va_type);\n \n-  if (TREE_CODE (want_va_type) == ARRAY_TYPE)\n-    {\n-      /* If va_list is an array type, the argument may have decayed\n-\t to a pointer type, e.g. by being passed to another function.\n-\t In that case, unwrap both types so that we can compare the\n-\t underlying records.  */\n-      if (TREE_CODE (have_va_type) == ARRAY_TYPE\n-\t  || POINTER_TYPE_P (have_va_type))\n-\t{\n-\t  want_va_type = TREE_TYPE (want_va_type);\n-\t  have_va_type = TREE_TYPE (have_va_type);\n-\t}\n-    }\n-\n-  if (TYPE_MAIN_VARIANT (want_va_type) != TYPE_MAIN_VARIANT (have_va_type))\n+  if (have_va_type == NULL_TREE)\n     {\n       error (\"first argument to %<va_arg%> not of type %<va_list%>\");\n       return GS_ERROR;\n     }\n \n   /* Generate a diagnostic for requesting data of a type that cannot\n      be passed through `...' due to type promotion at the call site.  */\n-  else if ((promoted_type = lang_hooks.types.type_promotes_to (type))\n+  if ((promoted_type = lang_hooks.types.type_promotes_to (type))\n \t   != type)\n     {\n       static bool gave_help;\n@@ -4889,15 +4919,15 @@ gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n     {\n       /* Make it easier for the backends by protecting the valist argument\n \t from multiple evaluations.  */\n-      if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n+      if (TREE_CODE (have_va_type) == ARRAY_TYPE)\n \t{\n \t  /* For this case, the backends will be expecting a pointer to\n-\t     TREE_TYPE (va_list_type_node), but it's possible we've\n-\t     actually been given an array (an actual va_list_type_node).\n+\t     TREE_TYPE (abi), but it's possible we've\n+\t     actually been given an array (an actual TARGET_FN_ABI_VA_LIST).\n \t     So fix it.  */\n \t  if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n \t    {\n-\t      tree p1 = build_pointer_type (TREE_TYPE (va_list_type_node));\n+\t      tree p1 = build_pointer_type (TREE_TYPE (have_va_type));\n \t      valist = build_fold_addr_expr_with_type (valist, p1);\n \t    }\n \t  gimplify_expr (&valist, pre_p, post_p, is_gimple_val, fb_rvalue);\n@@ -4945,9 +4975,11 @@ expand_builtin_va_copy (tree exp)\n   dst = stabilize_va_list (dst, 1);\n   src = stabilize_va_list (src, 0);\n \n-  if (TREE_CODE (va_list_type_node) != ARRAY_TYPE)\n+  gcc_assert (cfun != NULL && cfun->decl != NULL_TREE);\n+\n+  if (TREE_CODE (targetm.fn_abi_va_list (cfun->decl)) != ARRAY_TYPE)\n     {\n-      t = build2 (MODIFY_EXPR, va_list_type_node, dst, src);\n+      t = build2 (MODIFY_EXPR, targetm.fn_abi_va_list (cfun->decl), dst, src);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -4958,19 +4990,19 @@ expand_builtin_va_copy (tree exp)\n       /* Evaluate to pointers.  */\n       dstb = expand_expr (dst, NULL_RTX, Pmode, EXPAND_NORMAL);\n       srcb = expand_expr (src, NULL_RTX, Pmode, EXPAND_NORMAL);\n-      size = expand_expr (TYPE_SIZE_UNIT (va_list_type_node), NULL_RTX,\n-\t\t\t  VOIDmode, EXPAND_NORMAL);\n+      size = expand_expr (TYPE_SIZE_UNIT (targetm.fn_abi_va_list (cfun->decl)),\n+      \t\t  NULL_RTX, VOIDmode, EXPAND_NORMAL);\n \n       dstb = convert_memory_address (Pmode, dstb);\n       srcb = convert_memory_address (Pmode, srcb);\n \n       /* \"Dereference\" to BLKmode memories.  */\n       dstb = gen_rtx_MEM (BLKmode, dstb);\n       set_mem_alias_set (dstb, get_alias_set (TREE_TYPE (TREE_TYPE (dst))));\n-      set_mem_align (dstb, TYPE_ALIGN (va_list_type_node));\n+      set_mem_align (dstb, TYPE_ALIGN (targetm.fn_abi_va_list (cfun->decl)));\n       srcb = gen_rtx_MEM (BLKmode, srcb);\n       set_mem_alias_set (srcb, get_alias_set (TREE_TYPE (TREE_TYPE (src))));\n-      set_mem_align (srcb, TYPE_ALIGN (va_list_type_node));\n+      set_mem_align (srcb, TYPE_ALIGN (targetm.fn_abi_va_list (cfun->decl)));\n \n       /* Copy.  */\n       emit_block_move (dstb, srcb, size, BLOCK_OP_NORMAL);"}, {"sha": "2224a21f0efec9521d752ec15be683cf63bc1c9b", "filename": "gcc/c-common.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -4002,6 +4002,20 @@ c_common_nodes_and_builtins (void)\n   lang_hooks.decls.pushdecl\n     (build_decl (TYPE_DECL, get_identifier (\"__builtin_va_list\"),\n \t\t va_list_type_node));\n+#ifdef TARGET_ENUM_VA_LIST\n+  {\n+    int l;\n+    const char *pname;\n+    tree ptype;\n+    for (l = 0; TARGET_ENUM_VA_LIST (l, &pname, &ptype); ++l)\n+      {\n+\tlang_hooks.decls.pushdecl\n+\t  (build_decl (TYPE_DECL, get_identifier (pname),\n+\t  \t       ptype));\n+\n+      }\n+  }\n+#endif\n \n   if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n     {"}, {"sha": "eda2812120411cc20cf4697cdb91d5a369653ea5", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -281,14 +281,14 @@ i[34567]86-*-*)\n \textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n \t\t       nmmintrin.h bmmintrin.h mmintrin-common.h\n-\t\t       wmmintrin.h\"\n+\t\t       wmmintrin.h cross-stdarg.h\"\n \t;;\n x86_64-*-*)\n \tcpu_type=i386\n \textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n \t\t       nmmintrin.h bmmintrin.h mmintrin-common.h\n-\t\t       wmmintrin.h\"\n+\t\t       wmmintrin.h cross-stdarg.h\"\n \tneed_64bit_hwint=yes\n \t;;\n ia64-*-*)"}, {"sha": "98ac1ecd5cc5b988880f325ea2b09c8280a0e596", "filename": "gcc/config/i386/cross-stdarg.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fconfig%2Fi386%2Fcross-stdarg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fconfig%2Fi386%2Fcross-stdarg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcross-stdarg.h?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -0,0 +1,76 @@\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you include this header file into source\n+   files compiled by GCC, this header file does not by itself cause\n+   the resulting executable to be covered by the GNU General Public\n+   License.  This exception does not however invalidate any other\n+   reasons why the executable file might be covered by the GNU General\n+   Public License.  */\n+\n+#ifndef __CROSS_STDARG_H_INCLUDED\n+#define __CROSS_STDARG_H_INCLUDED\n+\n+/* Make sure that for non x64 targets cross builtins are defined.  */\n+#ifndef __x86_64__\n+/* Call abi ms_abi.  */\n+#define __builtin_ms_va_list __builtin_va_list\n+#define __builtin_ms_va_copy __builtin_va_copy\n+#define __builtin_ms_va_start __builtin_va_start\n+#define __builtin_ms_va_end __builtin_va_end\n+\n+/* Call abi sysv_abi.  */\n+#define __builtin_sysv_va_list __builtin_va_list\n+#define __builtin_sysv_va_copy __builtin_va_copy\n+#define __builtin_sysv_va_start __builtin_va_start\n+#define __builtin_sysv_va_end __builtin_va_end\n+#endif\n+\n+#define __ms_va_copy(__d,__s) __builtin_ms_va_copy(__d,__s)\n+#define __ms_va_start(__v,__l) __builtin_ms_va_start(__v,__l)\n+#define __ms_va_arg(__v,__l)\t__builtin_va_arg(__v,__l)\n+#define __ms_va_end(__v) __builtin_ms_va_end(__v)\n+\n+#define __sysv_va_copy(__d,__s) __builtin_sysv_va_copy(__d,__s)\n+#define __sysv_va_start(__v,__l) __builtin_sysv_va_start(__v,__l)\n+#define __sysv_va_arg(__v,__l)\t__builtin_va_arg(__v,__l)\n+#define __sysv_va_end(__v) __builtin_sysv_va_end(__v)\n+\n+#ifndef __GNUC_SYSV_VA_LIST\n+#define __GNUC_SYSV_VA_LIST\n+  typedef __builtin_sysv_va_list __gnuc_sysv_va_list;\n+#endif\n+\n+#ifndef _SYSV_VA_LIST_DEFINED\n+#define _SYSV_VA_LIST_DEFINED\n+  typedef __gnuc_sysv_va_list sysv_va_list;\n+#endif\n+\n+#ifndef __GNUC_MS_VA_LIST\n+#define __GNUC_MS_VA_LIST\n+  typedef __builtin_ms_va_list __gnuc_ms_va_list;\n+#endif\n+\n+#ifndef _MS_VA_LIST_DEFINED\n+#define _MS_VA_LIST_DEFINED\n+  typedef __gnuc_ms_va_list ms_va_list;\n+#endif\n+\n+#endif /* __CROSS_STDARG_H_INCLUDED */"}, {"sha": "9719ec2886f9065f58a18407f3a35050b7cd7f5a", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -141,6 +141,9 @@ extern int ix86_cfun_abi (void);\n extern int ix86_function_abi (const_tree);\n extern int ix86_function_type_abi (const_tree);\n extern void ix86_call_abi_override (const_tree);\n+extern tree ix86_fn_abi_va_list (tree);\n+extern tree ix86_canonical_va_list_type (tree);\n+extern int ix86_enum_va_list (int, const char **, tree *);\n extern int ix86_reg_parm_stack_space (const_tree);\n \n extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx,"}, {"sha": "7bedb76ce99848ce8b1e26c7c8ae583215858f58", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 294, "deletions": 13, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -1716,6 +1716,10 @@ unsigned int ix86_preferred_stack_boundary;\n /* Values 1-5: see jump.c */\n int ix86_branch_cost;\n \n+/* Calling abi specific va_list type nodes.  */\n+static GTY(()) tree sysv_va_list_type_node;\n+static GTY(()) tree ms_va_list_type_node;\n+\n /* Variables which are this size or smaller are put in the data/bss\n    or ldata/lbss sections.  */\n \n@@ -2774,9 +2778,8 @@ override_options (void)\n     set_param_value (\"l2-cache-size\", ix86_cost->l2_cache_size);\n \n   /* If using typedef char *va_list, signal that __builtin_va_start (&ap, 0)\n-     can be optimized to ap = __builtin_next_arg (0).\n-     For abi switching it should be corrected.  */\n-  if (!TARGET_64BIT || DEFAULT_ABI == MS_ABI)\n+     can be optimized to ap = __builtin_next_arg (0).  */\n+  if (!TARGET_64BIT)\n     targetm.expand_builtin_va_start = NULL;\n \n   if (TARGET_64BIT)\n@@ -3201,7 +3204,7 @@ ix86_handle_cconv_attribute (tree *node, tree name,\n   if (TARGET_64BIT)\n     {\n       /* Do not warn when emulating the MS ABI.  */\n-      if (TREE_CODE (*node) != FUNCTION_TYPE || !ix86_function_type_abi (*node))\n+      if (TREE_CODE (*node) != FUNCTION_TYPE || ix86_function_type_abi (*node)!=MS_ABI)\n \twarning (OPT_Wattributes, \"%qs attribute ignored\",\n \t         IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n@@ -3604,9 +3607,6 @@ ix86_function_type_abi (const_tree fntype)\n       else\n         abi = lookup_attribute (\"sysv_abi\", TYPE_ATTRIBUTES (fntype)) ? SYSV_ABI : MS_ABI;\n \n-      if (DEFAULT_ABI == MS_ABI && abi == SYSV_ABI)\n-        sorry (\"using sysv calling convention on target w64 is not supported\");\n-\n       return abi;\n     }\n   return DEFAULT_ABI;\n@@ -5174,13 +5174,16 @@ ix86_struct_value_rtx (tree type, int incoming ATTRIBUTE_UNUSED)\n \f\n /* Create the va_list data type.  */\n \n+/* Returns the calling convention specific va_list date type.\n+   The argument ABI can be DEFAULT_ABI, MS_ABI, or SYSV_ABI.  */\n+\n static tree\n-ix86_build_builtin_va_list (void)\n+ix86_build_builtin_va_list_abi (enum calling_abi abi)\n {\n   tree f_gpr, f_fpr, f_ovf, f_sav, record, type_decl;\n \n   /* For i386 we use plain pointer to argument area.  */\n-  if (!TARGET_64BIT || ix86_cfun_abi () == MS_ABI)\n+  if (!TARGET_64BIT || abi == MS_ABI)\n     return build_pointer_type (char_type_node);\n \n   record = (*lang_hooks.types.make_type) (RECORD_TYPE);\n@@ -5216,6 +5219,51 @@ ix86_build_builtin_va_list (void)\n   return build_array_type (record, build_index_type (size_zero_node));\n }\n \n+/* Setup the builtin va_list data type and for 64-bit the additional\n+   calling convention specific va_list data types.  */\n+\n+static tree\n+ix86_build_builtin_va_list (void)\n+{\n+  tree ret = ix86_build_builtin_va_list_abi (DEFAULT_ABI);\n+\n+  /* Initialize abi specific va_list builtin types.  */\n+  if (TARGET_64BIT)\n+    {\n+      tree t;\n+      if (DEFAULT_ABI == MS_ABI)\n+        {\n+          t = ix86_build_builtin_va_list_abi (SYSV_ABI);\n+          if (TREE_CODE (t) != RECORD_TYPE)\n+            t = build_variant_type_copy (t);\n+          sysv_va_list_type_node = t;\n+        }\n+      else\n+        {\n+          t = ret;\n+          if (TREE_CODE (t) != RECORD_TYPE)\n+            t = build_variant_type_copy (t);\n+          sysv_va_list_type_node = t;\n+        }\n+      if (DEFAULT_ABI != MS_ABI)\n+        {\n+          t = ix86_build_builtin_va_list_abi (MS_ABI);\n+          if (TREE_CODE (t) != RECORD_TYPE)\n+            t = build_variant_type_copy (t);\n+          ms_va_list_type_node = t;\n+        }\n+      else\n+        {\n+          t = ret;\n+          if (TREE_CODE (t) != RECORD_TYPE)\n+            t = build_variant_type_copy (t);\n+          ms_va_list_type_node = t;\n+        }\n+    }\n+\n+  return ret;\n+}\n+\n /* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n@@ -5371,13 +5419,14 @@ ix86_va_start (tree valist, rtx nextarg)\n   tree type;\n \n   /* Only 64bit target needs something special.  */\n-  if (!TARGET_64BIT || cfun->machine->call_abi == MS_ABI)\n+  if (!TARGET_64BIT ||\n+      ix86_canonical_va_list_type (TREE_TYPE (valist)) == ms_va_list_type_node)\n     {\n       std_expand_builtin_va_start (valist, nextarg);\n       return;\n     }\n \n-  f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n+  f_gpr = TYPE_FIELDS (TREE_TYPE (sysv_va_list_type_node));\n   f_fpr = TREE_CHAIN (f_gpr);\n   f_ovf = TREE_CHAIN (f_fpr);\n   f_sav = TREE_CHAIN (f_ovf);\n@@ -5450,10 +5499,11 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   enum machine_mode nat_mode;\n \n   /* Only 64bit target needs something special.  */\n-  if (!TARGET_64BIT || cfun->machine->call_abi == MS_ABI)\n+  if (!TARGET_64BIT ||\n+      ix86_canonical_va_list_type (TREE_TYPE (valist)) == ms_va_list_type_node)\n     return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n \n-  f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n+  f_gpr = TYPE_FIELDS (TREE_TYPE (sysv_va_list_type_node));\n   f_fpr = TREE_CHAIN (f_gpr);\n   f_ovf = TREE_CHAIN (f_fpr);\n   f_sav = TREE_CHAIN (f_ovf);\n@@ -20216,6 +20266,55 @@ ix86_init_mmx_sse_builtins (void)\n     }\n }\n \n+/* Internal method for ix86_init_builtins.  */\n+\n+static void\n+ix86_init_builtins_va_builtins_abi (void)\n+{\n+  tree ms_va_ref, sysv_va_ref;\n+  tree fnvoid_va_end_ms, fnvoid_va_end_sysv;\n+  tree fnvoid_va_start_ms, fnvoid_va_start_sysv;\n+  tree fnvoid_va_copy_ms, fnvoid_va_copy_sysv;\n+  tree fnattr_ms = NULL_TREE, fnattr_sysv = NULL_TREE;\n+\n+  if (!TARGET_64BIT)\n+    return;\n+  fnattr_ms = build_tree_list (get_identifier (\"ms_abi\"), NULL_TREE);\n+  fnattr_sysv = build_tree_list (get_identifier (\"sysv_abi\"), NULL_TREE);\n+  ms_va_ref = build_reference_type (ms_va_list_type_node);\n+  sysv_va_ref =\n+    build_pointer_type (TREE_TYPE (sysv_va_list_type_node));\n+\n+  fnvoid_va_end_ms =\n+    build_function_type_list (void_type_node, ms_va_ref, NULL_TREE);\n+  fnvoid_va_start_ms =\n+    build_varargs_function_type_list (void_type_node, ms_va_ref, NULL_TREE);\n+  fnvoid_va_end_sysv =\n+    build_function_type_list (void_type_node, sysv_va_ref, NULL_TREE);\n+  fnvoid_va_start_sysv =\n+    build_varargs_function_type_list (void_type_node, sysv_va_ref,\n+    \t\t\t\t       NULL_TREE);\n+  fnvoid_va_copy_ms =\n+    build_function_type_list (void_type_node, ms_va_ref, ms_va_list_type_node,\n+    \t\t\t      NULL_TREE);\n+  fnvoid_va_copy_sysv =\n+    build_function_type_list (void_type_node, sysv_va_ref,\n+    \t\t\t      sysv_va_ref, NULL_TREE);\n+\n+  add_builtin_function (\"__builtin_ms_va_start\", fnvoid_va_start_ms,\n+  \t\t\tBUILT_IN_VA_START, BUILT_IN_NORMAL, NULL, fnattr_ms);\n+  add_builtin_function (\"__builtin_ms_va_end\", fnvoid_va_end_ms,\n+  \t\t\tBUILT_IN_VA_END, BUILT_IN_NORMAL, NULL, fnattr_ms);\n+  add_builtin_function (\"__builtin_ms_va_copy\", fnvoid_va_copy_ms,\n+\t\t\tBUILT_IN_VA_COPY, BUILT_IN_NORMAL, NULL, fnattr_ms);\n+  add_builtin_function (\"__builtin_sysv_va_start\", fnvoid_va_start_sysv,\n+  \t\t\tBUILT_IN_VA_START, BUILT_IN_NORMAL, NULL, fnattr_sysv);\n+  add_builtin_function (\"__builtin_sysv_va_end\", fnvoid_va_end_sysv,\n+  \t\t\tBUILT_IN_VA_END, BUILT_IN_NORMAL, NULL, fnattr_sysv);\n+  add_builtin_function (\"__builtin_sysv_va_copy\", fnvoid_va_copy_sysv,\n+\t\t\tBUILT_IN_VA_COPY, BUILT_IN_NORMAL, NULL, fnattr_sysv);\n+}\n+\n static void\n ix86_init_builtins (void)\n {\n@@ -20273,6 +20372,8 @@ ix86_init_builtins (void)\n \n   if (TARGET_MMX)\n     ix86_init_mmx_sse_builtins ();\n+  if (TARGET_64BIT)\n+    ix86_init_builtins_va_builtins_abi ();\n }\n \n /* Errors in the source file can cause expand_expr to return const0_rtx\n@@ -23097,6 +23198,54 @@ x86_order_regs_for_local_alloc (void)\n      reg_alloc_order [pos++] = 0;\n }\n \n+/* Handle a \"ms_abi\" or \"sysv\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+ix86_handle_abi_attribute (tree *node, tree name,\n+\t\t\t      tree args ATTRIBUTE_UNUSED,\n+\t\t\t      int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_TYPE\n+      && TREE_CODE (*node) != METHOD_TYPE\n+      && TREE_CODE (*node) != FIELD_DECL\n+      && TREE_CODE (*node) != TYPE_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qs attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+  if (!TARGET_64BIT)\n+    {\n+      warning (OPT_Wattributes, \"%qs attribute only available for 64-bit\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  /* Can combine regparm with all attributes but fastcall.  */\n+  if (is_attribute_p (\"ms_abi\", name))\n+    {\n+      if (lookup_attribute (\"sysv_abi\", TYPE_ATTRIBUTES (*node)))\n+        {\n+\t  error (\"ms_abi and sysv_abi attributes are not compatible\");\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+  else if (is_attribute_p (\"sysv_abi\", name))\n+    {\n+      if (lookup_attribute (\"ms_abi\", TYPE_ATTRIBUTES (*node)))\n+        {\n+\t  error (\"ms_abi and sysv_abi attributes are not compatible\");\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"ms_struct\" or \"gcc_struct\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n@@ -25906,6 +26055,10 @@ static const struct attribute_spec ix86_attribute_table[] =\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n   SUBTARGET_ATTRIBUTE_TABLE,\n #endif\n+  /* ms_abi and sysv_abi calling convention function attributes.  */\n+  { \"ms_abi\", 0, 0, false, true, true, ix86_handle_abi_attribute },\n+  { \"sysv_abi\", 0, 0, false, true, true, ix86_handle_abi_attribute },\n+  /* End element.  */\n   { NULL,        0, 0, false, false, false, NULL }\n };\n \n@@ -25933,6 +26086,128 @@ x86_builtin_vectorization_cost (bool runtime_test)\n     return 0;\n }\n \n+/* This function returns the calling abi specific va_list type node.\n+   It returns  the FNDECL specific va_list type.  */\n+\n+tree\n+ix86_fn_abi_va_list (tree fndecl)\n+{\n+  int abi;\n+\n+  if (!TARGET_64BIT)\n+    return va_list_type_node;\n+  gcc_assert (fndecl != NULL_TREE);\n+  abi = ix86_function_abi ((const_tree) fndecl);\n+\n+  if (abi == MS_ABI)\n+    return ms_va_list_type_node;\n+  else\n+    return sysv_va_list_type_node;\n+}\n+\n+/* Returns the canonical va_list type specified by TYPE. If there\n+   is no valid TYPE provided, it return NULL_TREE.  */\n+\n+tree\n+ix86_canonical_va_list_type (tree type)\n+{\n+  tree wtype, htype;\n+\n+  /* Resolve references and pointers to va_list type.  */\n+  if (INDIRECT_REF_P (type))\n+    type = TREE_TYPE (type);\n+  else if (POINTER_TYPE_P (type) && POINTER_TYPE_P (TREE_TYPE(type)))\n+    type = TREE_TYPE (type);\n+\n+  if (TARGET_64BIT)\n+    {\n+      wtype = va_list_type_node;\n+\t  gcc_assert (wtype != NULL_TREE);\n+      htype = type;\n+      if (TREE_CODE (wtype) == ARRAY_TYPE)\n+\t{\n+\t  /* If va_list is an array type, the argument may have decayed\n+\t     to a pointer type, e.g. by being passed to another function.\n+\t     In that case, unwrap both types so that we can compare the\n+\t     underlying records.  */\n+\t  if (TREE_CODE (htype) == ARRAY_TYPE\n+\t      || POINTER_TYPE_P (htype))\n+\t    {\n+\t      wtype = TREE_TYPE (wtype);\n+\t      htype = TREE_TYPE (htype);\n+\t    }\n+\t}\n+      if (TYPE_MAIN_VARIANT (wtype) == TYPE_MAIN_VARIANT (htype))\n+\treturn va_list_type_node;\n+      wtype = sysv_va_list_type_node;\n+\t  gcc_assert (wtype != NULL_TREE);\n+      htype = type;\n+      if (TREE_CODE (wtype) == ARRAY_TYPE)\n+\t{\n+\t  /* If va_list is an array type, the argument may have decayed\n+\t     to a pointer type, e.g. by being passed to another function.\n+\t     In that case, unwrap both types so that we can compare the\n+\t     underlying records.  */\n+\t  if (TREE_CODE (htype) == ARRAY_TYPE\n+\t      || POINTER_TYPE_P (htype))\n+\t    {\n+\t      wtype = TREE_TYPE (wtype);\n+\t      htype = TREE_TYPE (htype);\n+\t    }\n+\t}\n+      if (TYPE_MAIN_VARIANT (wtype) == TYPE_MAIN_VARIANT (htype))\n+\treturn sysv_va_list_type_node;\n+      wtype = ms_va_list_type_node;\n+\t  gcc_assert (wtype != NULL_TREE);\n+      htype = type;\n+      if (TREE_CODE (wtype) == ARRAY_TYPE)\n+\t{\n+\t  /* If va_list is an array type, the argument may have decayed\n+\t     to a pointer type, e.g. by being passed to another function.\n+\t     In that case, unwrap both types so that we can compare the\n+\t     underlying records.  */\n+\t  if (TREE_CODE (htype) == ARRAY_TYPE\n+\t      || POINTER_TYPE_P (htype))\n+\t    {\n+\t      wtype = TREE_TYPE (wtype);\n+\t      htype = TREE_TYPE (htype);\n+\t    }\n+\t}\n+      if (TYPE_MAIN_VARIANT (wtype) == TYPE_MAIN_VARIANT (htype))\n+\treturn ms_va_list_type_node;\n+      return NULL_TREE;\n+    }\n+  return std_canonical_va_list_type (type);\n+}\n+\n+/* Iterate through the target-specific builtin types for va_list.\n+    IDX denotes the iterator, *PTREE is set to the result type of\n+    the va_list builtin, and *PNAME to its internal type.\n+    Returns zero if there is no element for this index, otherwise\n+    IDX should be increased upon the next call.\n+    Note, do not iterate a base builtin's name like __builtin_va_list.\n+    Used from c_common_nodes_and_builtins.  */\n+\n+int\n+ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n+{\n+  if (!TARGET_64BIT)\n+    return 0;\n+  switch (idx) {\n+  case 0:\n+    *ptree = ms_va_list_type_node;\n+    *pname = \"__builtin_ms_va_list\";\n+    break;\n+  case 1:\n+    *ptree = sysv_va_list_type_node;\n+    *pname = \"__builtin_sysv_va_list\";\n+    break;\n+  default:\n+    return 0;\n+  }\n+  return 1;\n+}\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY ix86_return_in_memory\n@@ -26061,6 +26336,12 @@ x86_builtin_vectorization_cost (bool runtime_test)\n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST ix86_build_builtin_va_list\n \n+#undef TARGET_FN_ABI_VA_LIST\n+#define TARGET_FN_ABI_VA_LIST ix86_fn_abi_va_list\n+\n+#undef TARGET_CANONICAL_VA_LIST_TYPE\n+#define TARGET_CANONICAL_VA_LIST_TYPE ix86_canonical_va_list_type\n+\n #undef TARGET_EXPAND_BUILTIN_VA_START\n #define TARGET_EXPAND_BUILTIN_VA_START ix86_va_start\n "}, {"sha": "d17e414eb5ffe8e53cd0d5e2896de9ac24b1591b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -453,7 +453,7 @@ extern tree x86_mfence;\n #define TARGET_64BIT_MS_ABI (TARGET_64BIT && ix86_cfun_abi () == MS_ABI)\n \n /* Available call abi.  */\n-enum\n+enum calling_abi\n {\n   SYSV_ABI = 0,\n   MS_ABI = 1\n@@ -2556,6 +2556,11 @@ struct machine_function GTY(())\n #undef TARG_COND_BRANCH_COST\n #define TARG_COND_BRANCH_COST           ix86_cost->branch_cost\n \n+/* Enum through the target specific extra va_list types. Please, do not\n+   iterate the base va_list type name.  */\n+#define TARGET_ENUM_VA_LIST(IDX, PNAME, PTYPE) \\\n+  (!TARGET_64BIT ? 0 : ix86_enum_va_list (IDX, PNAME, PTYPE))\n+\n /* Cost of any scalar operation, excluding load and store.  */\n #undef TARG_SCALAR_STMT_COST\n #define TARG_SCALAR_STMT_COST           ix86_cost->scalar_stmt_cost"}, {"sha": "b5418a3f465d16e541132cfea37c82a4d0851d90", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -4187,6 +4187,18 @@ This hook returns a type node for @code{va_list} for the target.\n The default version of the hook returns @code{void*}.\n @end deftypefn\n \n+@deftypefn {Target Hook} tree TARGET_FN_ABI_VA_LIST (tree @var{fndecl})\n+This hook returns the va_list type of the calling convention specified by\n+@var{fndecl}.\n+The default version of this hook returns @code{va_list_type_node}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} tree TARGET_CANONICAL_VA_LIST_TYPE (tree @var{type})\n+This hook returns the va_list type of the calling convention specified by the\n+type of @var{type}. If @var{type} is not a valid va_list type, it returns\n+@code{NULL_TREE}.\n+@end deftypefn\n+\n @deftypefn {Target Hook} tree TARGET_GIMPLIFY_VA_ARG_EXPR (tree @var{valist}, tree @var{type}, tree *@var{pre_p}, tree *@var{post_p})\n This hook performs target-specific gimplification of\n @code{VA_ARG_EXPR}.  The first two parameters correspond to the\n@@ -4317,6 +4329,20 @@ function use different registers for the return value, this macro\n should recognize only the caller's register numbers.\n @end defmac\n \n+@defmac TARGET_ENUM_VA_LIST (@var{idx}, @var{pname}, @var{ptype})\n+This target macro is used in function @code{c_common_nodes_and_builtins}\n+to iterate through the target specific builtin types for va_list. The\n+variable @var{idx} is used as iterator. @var{pname} has to be a pointer\n+to a @code{const char *} and @var{ptype} a pointer to a @code{tree} typed\n+variable.\n+The arguments @var{pname} and @var{ptype} are used to store the result of\n+this macro and are set to the name of the va_list builtin type and its\n+internal type.\n+If the return value of this macro is zero, then there is no more element.\n+Otherwise the @var{IDX} should be increased for the next call of this\n+macro to iterate through all types.\n+@end defmac\n+\n @defmac APPLY_RESULT_SIZE\n Define this macro if @samp{untyped_call} and @samp{untyped_return}\n need more space than is implied by @code{FUNCTION_VALUE_REGNO_P} for"}, {"sha": "39a51fcfe1334551a2da9d0fbad9d290f7761fda", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -342,6 +342,9 @@ extern rtx emit_store_flag_force (rtx, enum rtx_code, rtx, rtx,\n /* Functions from builtins.c:  */\n extern rtx expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n extern tree std_build_builtin_va_list (void);\n+extern tree std_fn_abi_va_list (tree);\n+extern tree std_canonical_va_list_type (tree);\n+\n extern void std_expand_builtin_va_start (tree, rtx);\n extern rtx default_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n extern void expand_builtin_setjmp_setup (rtx, rtx);"}, {"sha": "7ffb134602183224af829a9e6bc26f33652496a8", "filename": "gcc/target-def.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -520,6 +520,8 @@\n #define TARGET_MACHINE_DEPENDENT_REORG 0\n \n #define TARGET_BUILD_BUILTIN_VA_LIST std_build_builtin_va_list\n+#define TARGET_FN_ABI_VA_LIST std_fn_abi_va_list\n+#define TARGET_CANONICAL_VA_LIST_TYPE std_canonical_va_list_type\n #define TARGET_EXPAND_BUILTIN_VA_START 0\n \n #define TARGET_GET_PCH_VALIDITY default_get_pch_validity\n@@ -820,6 +822,8 @@\n   TARGET_CC_MODES_COMPATIBLE,\t\t\t\\\n   TARGET_MACHINE_DEPENDENT_REORG,\t\t\\\n   TARGET_BUILD_BUILTIN_VA_LIST,\t\t\t\\\n+  TARGET_FN_ABI_VA_LIST,\t\t\t\\\n+  TARGET_CANONICAL_VA_LIST_TYPE,\t\t\t\\\n   TARGET_EXPAND_BUILTIN_VA_START,\t\t\\\n   TARGET_GIMPLIFY_VA_ARG_EXPR,\t\t\t\\\n   TARGET_GET_PCH_VALIDITY,\t\t\t\\"}, {"sha": "11852430c8d3642d6dbb74334af3fc62fee3c585", "filename": "gcc/target.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -697,6 +697,12 @@ struct gcc_target\n   /* Create the __builtin_va_list type.  */\n   tree (* build_builtin_va_list) (void);\n \n+  /* Get the cfun/fndecl calling abi __builtin_va_list type.  */\n+  tree (* fn_abi_va_list) (tree);\n+\n+  /* Get the __builtin_va_list type dependent on input type.  */\n+  tree (* canonical_va_list_type) (tree);\n+\n   /* Expand the __builtin_va_start builtin.  */\n   void (* expand_builtin_va_start) (tree valist, rtx nextarg);\n "}, {"sha": "c50c6cd225bfee00e6f25af585a415d9e88f2cfa", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -308,6 +308,26 @@ sra_type_can_be_decomposed_p (tree type)\n   return false;\n }\n \n+/* Returns true if the TYPE is one of the available va_list types.\n+   Otherwise it returns false.\n+   Note, that for multiple calling conventions there can be more\n+   than just one va_list type present.  */\n+\n+static bool\n+is_va_list_type (tree type)\n+{\n+  tree h;\n+\n+  if (type == NULL_TREE)\n+    return false;\n+  h = targetm.canonical_va_list_type (type);\n+  if (h == NULL_TREE)\n+    return false;\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (h))\n+\t return true;\n+  return false;\n+}\n+\n /* Return true if DECL can be decomposed into a set of independent\n    (though not necessarily scalar) variables.  */\n \n@@ -360,9 +380,7 @@ decl_can_be_decomposed_p (tree var)\n      tree-stdarg.c, as the decomposition is truly a win.  This could also\n      be fixed if the stdarg pass ran early, but this can't be done until\n      we've aliasing information early too.  See PR 30791.  */\n-  if (early_sra\n-      && TYPE_MAIN_VARIANT (TREE_TYPE (var))\n-\t == TYPE_MAIN_VARIANT (va_list_type_node))\n+  if (early_sra && is_va_list_type (TREE_TYPE (var)))\n     return false;\n \n   return true;"}, {"sha": "da6b7855a81a44804a336ea44c618beecb1f5469", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -2748,17 +2748,19 @@ optimize_stack_restore (basic_block bb, tree call, block_stmt_iterator i)\n static tree\n optimize_stdarg_builtin (tree call)\n {\n-  tree callee, lhs, rhs;\n+  tree callee, lhs, rhs, cfun_va_list;\n   bool va_list_simple_ptr;\n \n   if (TREE_CODE (call) != CALL_EXPR)\n     return NULL_TREE;\n \n-  va_list_simple_ptr = POINTER_TYPE_P (va_list_type_node)\n-\t\t       && (TREE_TYPE (va_list_type_node) == void_type_node\n-\t\t\t   || TREE_TYPE (va_list_type_node) == char_type_node);\n-\n   callee = get_callee_fndecl (call);\n+\n+  cfun_va_list = targetm.fn_abi_va_list (callee);\n+  va_list_simple_ptr = POINTER_TYPE_P (cfun_va_list)\n+\t\t       && (TREE_TYPE (cfun_va_list) == void_type_node\n+\t\t\t   || TREE_TYPE (cfun_va_list) == char_type_node);\n+\n   switch (DECL_FUNCTION_CODE (callee))\n     {\n     case BUILT_IN_VA_START:\n@@ -2773,7 +2775,7 @@ optimize_stdarg_builtin (tree call)\n       lhs = CALL_EXPR_ARG (call, 0);\n       if (!POINTER_TYPE_P (TREE_TYPE (lhs))\n \t  || TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (lhs)))\n-\t     != TYPE_MAIN_VARIANT (va_list_type_node))\n+\t     != TYPE_MAIN_VARIANT (cfun_va_list))\n \treturn NULL_TREE;\n \n       lhs = build_fold_indirect_ref (lhs);\n@@ -2792,13 +2794,13 @@ optimize_stdarg_builtin (tree call)\n       lhs = CALL_EXPR_ARG (call, 0);\n       if (!POINTER_TYPE_P (TREE_TYPE (lhs))\n \t  || TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (lhs)))\n-\t     != TYPE_MAIN_VARIANT (va_list_type_node))\n+\t     != TYPE_MAIN_VARIANT (cfun_va_list))\n \treturn NULL_TREE;\n \n       lhs = build_fold_indirect_ref (lhs);\n       rhs = CALL_EXPR_ARG (call, 1);\n       if (TYPE_MAIN_VARIANT (TREE_TYPE (rhs))\n-\t  != TYPE_MAIN_VARIANT (va_list_type_node))\n+\t  != TYPE_MAIN_VARIANT (cfun_va_list))\n \treturn NULL_TREE;\n \n       rhs = fold_convert (TREE_TYPE (lhs), rhs);"}, {"sha": "f9228872dc2c6379c240f61dad51c68b7f7cdb7f", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35cbb299153f4c8e604c000c68b139da156585fd/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=35cbb299153f4c8e604c000c68b139da156585fd", "patch": "@@ -605,6 +605,7 @@ execute_optimize_stdarg (void)\n   bool va_list_simple_ptr;\n   struct stdarg_info si;\n   const char *funcname = NULL;\n+  tree cfun_va_list;\n \n   cfun->va_list_gpr_size = 0;\n   cfun->va_list_fpr_size = 0;\n@@ -615,10 +616,11 @@ execute_optimize_stdarg (void)\n   if (dump_file)\n     funcname = lang_hooks.decl_printable_name (current_function_decl, 2);\n \n-  va_list_simple_ptr = POINTER_TYPE_P (va_list_type_node)\n-\t\t       && (TREE_TYPE (va_list_type_node) == void_type_node\n-\t\t\t   || TREE_TYPE (va_list_type_node) == char_type_node);\n-  gcc_assert (is_gimple_reg_type (va_list_type_node) == va_list_simple_ptr);\n+  cfun_va_list = targetm.fn_abi_va_list (cfun->decl);\n+  va_list_simple_ptr = POINTER_TYPE_P (cfun_va_list)\n+\t\t       && (TREE_TYPE (cfun_va_list) == void_type_node\n+\t\t\t   || TREE_TYPE (cfun_va_list) == char_type_node);\n+  gcc_assert (is_gimple_reg_type (cfun_va_list) == va_list_simple_ptr);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -671,7 +673,7 @@ execute_optimize_stdarg (void)\n \t      ap = TREE_OPERAND (ap, 0);\n \t    }\n \t  if (TYPE_MAIN_VARIANT (TREE_TYPE (ap))\n-\t      != TYPE_MAIN_VARIANT (va_list_type_node)\n+\t      != TYPE_MAIN_VARIANT (targetm.fn_abi_va_list (cfun->decl))\n \t      || TREE_CODE (ap) != VAR_DECL)\n \t    {\n \t      va_list_escapes = true;"}]}