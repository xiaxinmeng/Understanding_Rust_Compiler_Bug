{"sha": "c13fde0599c2f8dbbbdc625dba0bf7b610a2d597", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEzZmRlMDU5OWMyZjhkYmJiZGM2MjVkYmEwYmY3YjYxMGEyZDU5Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-02-04T21:30:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-02-04T21:30:22Z"}, "message": "function.c (diddle_return_value): Rework to use a callback function.\n\n        * function.c (diddle_return_value): Rework to use a callback function.\n        Use current_function_return_rtx if it's been set up.\n        (do_clobber_return_reg, clobber_return_register): New.\n        (do_use_return_reg, use_return_register): New.\n        (expand_function_end): Use them.\n        * stmt.c (expand_null_return): Likewise.\n        * function.h: Declare them.\n        * flow.c (mark_regs_live_at_end): Use diddle_return_value.\n        (mark_reg): Change arguments as appropriate for callback.\n        * integrate.c (expand_inline_function): Revert 19 Jan change.\n\nFrom-SVN: r31791", "tree": {"sha": "8cc10637d86506360d6941e5b27c2b2ee19fca50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cc10637d86506360d6941e5b27c2b2ee19fca50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/comments", "author": null, "committer": null, "parents": [{"sha": "facc279fc19a31c23323ce3eeac869eb14d07bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/facc279fc19a31c23323ce3eeac869eb14d07bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/facc279fc19a31c23323ce3eeac869eb14d07bda"}], "stats": {"total": 177, "additions": 103, "deletions": 74}, "files": [{"sha": "c708a029b7577686d717620584ff5be90af5b1d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c13fde0599c2f8dbbbdc625dba0bf7b610a2d597", "patch": "@@ -1,3 +1,16 @@\n+2000-02-04  Richard Henderson  <rth@cygnus.com>\n+\n+\t* function.c (diddle_return_value): Rework to use a callback function.\n+\tUse current_function_return_rtx if it's been set up.\n+\t(do_clobber_return_reg, clobber_return_register): New.\n+\t(do_use_return_reg, use_return_register): New.\n+\t(expand_function_end): Use them.\n+\t* stmt.c (expand_null_return): Likewise.\n+\t* function.h: Declare them.\n+\t* flow.c (mark_regs_live_at_end): Use diddle_return_value.\n+\t(mark_reg): Change arguments as appropriate for callback.\n+\t* integrate.c (expand_inline_function): Revert 19 Jan change.\n+\n Fri Feb  4 20:25:42 2000  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* tm.texi (Values in Registers): Fix typo: \"fo\" \"for\"."}, {"sha": "aa8745181abf141504884131962f21eec684a108", "filename": "gcc/flow.c", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=c13fde0599c2f8dbbbdc625dba0bf7b610a2d597", "patch": "@@ -320,7 +320,7 @@ static int set_noop_p\t\t\tPARAMS ((rtx));\n static int noop_move_p\t\t\tPARAMS ((rtx));\n static void notice_stack_pointer_modification PARAMS ((rtx, rtx, void *));\n static void record_volatile_insns\tPARAMS ((rtx));\n-static void mark_reg\t\t\tPARAMS ((regset, rtx));\n+static void mark_reg\t\t\tPARAMS ((rtx, void *));\n static void mark_regs_live_at_end\tPARAMS ((regset));\n static void life_analysis_1\t\tPARAMS ((rtx, int, int));\n static void calculate_global_regs_live\tPARAMS ((sbitmap, sbitmap, int));\n@@ -2788,12 +2788,16 @@ record_volatile_insns (f)\n /* Mark a register in SET.  Hard registers in large modes get all\n    of their component registers set as well.  */\n static void\n-mark_reg (set, reg)\n-     regset set;\n+mark_reg (reg, xset)\n      rtx reg;\n+     void *xset;\n {\n+  regset set = (regset) xset;\n   int regno = REGNO (reg);\n \n+  if (GET_MODE (reg) == BLKmode)\n+    abort ();\n+\n   SET_REGNO_REG_SET (set, regno);\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n@@ -2867,44 +2871,7 @@ mark_regs_live_at_end (set)\n     }\n \n   /* Mark function return value.  */\n-\n-  result = DECL_RESULT (current_function_decl);\n-  type = TREE_TYPE (result);\n-  if (type != void_type_node)\n-    {\n-      rtx outgoing;\n-\n-      /* ??? Share this code with expand_function_end.  */\n-#ifdef FUNCTION_OUTGOING_VALUE\n-      outgoing = FUNCTION_OUTGOING_VALUE (type, current_function_decl);\n-#else\n-      outgoing = FUNCTION_VALUE (type, current_function_decl);\n-#endif\n-      /* If this is a BLKmode structure being returned in registers,\n-\t then use the mode computed in expand_return.  */\n-      if (GET_MODE (outgoing) == BLKmode)\n-\tPUT_MODE (outgoing, GET_MODE (DECL_RTL (result)));\n-\n-      if (GET_CODE (outgoing) == REG)\n-\tmark_reg (set, outgoing);\n-      else if (GET_CODE (outgoing) == PARALLEL)\n-\t{\n-\t  int len = XVECLEN (outgoing, 0);\n-\n-\t  /* Check for a NULL entry, used to indicate that the parameter\n-\t     goes on the stack and in registers.  */\n-\t  i = (XEXP (XVECEXP (outgoing, 0, 0), 0) ? 0 : 1);\n-\n-\t  for ( ; i < len; ++i)\n-\t    {\n-\t      rtx r = XVECEXP (outgoing, 0, i);\n-\t      if (GET_CODE (r) == REG)\n-\t\tmark_reg (set, r);\n-\t    }\n-\t}\n-      else\n-\tabort ();\n-    }\n+  diddle_return_value (mark_reg, set);\n }\n \n /* Determine which registers are live at the start of each"}, {"sha": "d466db848b794db219fd7640e2ad08db63090931", "filename": "gcc/function.c", "status": "modified", "additions": 71, "deletions": 29, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c13fde0599c2f8dbbbdc625dba0bf7b610a2d597", "patch": "@@ -286,7 +286,8 @@ static void mark_temp_slot PARAMS ((struct temp_slot *));\n static void mark_function_status PARAMS ((struct function *));\n static void mark_function_chain PARAMS ((void *));\n static void prepare_function_start PARAMS ((void));\n-\n+static void do_clobber_return_reg PARAMS ((rtx, void *));\n+static void do_use_return_reg PARAMS ((rtx, void *));\n \f\n /* Pointer to chain of `struct function' for containing functions.  */\n struct function *outer_function_chain;\n@@ -6120,44 +6121,79 @@ expand_dummy_function_end ()\n   cfun = 0;\n }\n \n-/* Emit CODE for each register of the return value.  Useful values for\n-   code are USE and CLOBBER.  */\n+/* Call DOIT for each hard register used as a return value from\n+   the current function.  */\n \n void\n-diddle_return_value (code)\n-     enum rtx_code code;\n+diddle_return_value (doit, arg)\n+     void (*doit) PARAMS ((rtx, void *));\n+     void *arg;\n {\n-  tree decl_result = DECL_RESULT (current_function_decl);\n-  rtx return_reg = DECL_RTL (decl_result);\n+  rtx outgoing = current_function_return_rtx;\n \n-  if (return_reg)\n+  if (! outgoing)\n+    return;\n+\n+  if (GET_CODE (outgoing) == REG\n+      && REGNO (outgoing) >= FIRST_PSEUDO_REGISTER)\n     {\n-      if (GET_CODE (return_reg) == REG\n-\t  && REGNO (return_reg) < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  /* Use hard_function_value to avoid creating a reference to a BLKmode \n-\t     register in the USE/CLOBBER insn.  */\n-\t  return_reg = hard_function_value (TREE_TYPE (decl_result),\n-\t\t\t\t\t    current_function_decl, 1);\n-\t  REG_FUNCTION_VALUE_P (return_reg) = 1;\n-\t  emit_insn (gen_rtx_fmt_e (code, VOIDmode, return_reg));\n-\t}\n-      else if (GET_CODE (return_reg) == PARALLEL)\n-\t{\n-\t  int i;\n+      tree type = TREE_TYPE (DECL_RESULT (current_function_decl));\n+#ifdef FUNCTION_OUTGOING_VALUE\n+      outgoing = FUNCTION_OUTGOING_VALUE (type, current_function_decl);\n+#else\n+      outgoing = FUNCTION_VALUE (type, current_function_decl);\n+#endif\n+      /* If this is a BLKmode structure being returned in registers, then use\n+\t the mode computed in expand_return.  */\n+      if (GET_MODE (outgoing) == BLKmode)\n+\tPUT_MODE (outgoing,\n+\t\t  GET_MODE (DECL_RTL (DECL_RESULT (current_function_decl))));\n+    }\n \n-\t  for (i = 0; i < XVECLEN (return_reg, 0); i++)\n-\t    {\n-\t      rtx x = XEXP (XVECEXP (return_reg, 0, i), 0);\n+  if (GET_CODE (outgoing) == REG)\n+    (*doit) (outgoing, arg);\n+  else if (GET_CODE (outgoing) == PARALLEL)\n+    {\n+      int i;\n \n-\t      if (GET_CODE (x) == REG\n-\t\t  && REGNO (x) < FIRST_PSEUDO_REGISTER)\n-\t\temit_insn (gen_rtx_fmt_e (code, VOIDmode, x));\n-\t    }\n+      for (i = 0; i < XVECLEN (outgoing, 0); i++)\n+\t{\n+\t  rtx x = XEXP (XVECEXP (outgoing, 0, i), 0);\n+\n+\t  if (GET_CODE (x) == REG && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\t    (*doit) (x, arg);\n \t}\n     }\n }\n \n+static void\n+do_clobber_return_reg (reg, arg)\n+     rtx reg;\n+     void *arg ATTRIBUTE_UNUSED;\n+{\n+  emit_insn (gen_rtx_CLOBBER (VOIDmode, reg));\n+}\n+\n+void\n+clobber_return_register ()\n+{\n+  diddle_return_value (do_clobber_return_reg, NULL);\n+}\n+\n+static void\n+do_use_return_reg (reg, arg)\n+     rtx reg;\n+     void *arg ATTRIBUTE_UNUSED;\n+{\n+  emit_insn (gen_rtx_USE (VOIDmode, reg));\n+}\n+\n+void\n+use_return_register ()\n+{\n+  diddle_return_value (do_use_return_reg, NULL);\n+}\n+\n /* Generate RTL for the end of the current function.\n    FILENAME and LINE are the current position in the source file. \n \n@@ -6324,7 +6360,7 @@ expand_function_end (filename, line, end_bindings)\n \t can only happen with functions that drop through; if there had\n \t been a return statement, there would have either been a return\n \t rtx, or a jump to the return label.  */\n-      diddle_return_value (CLOBBER);\n+      clobber_return_register ();\n \n       emit_label (return_label);\n     }\n@@ -6444,6 +6480,12 @@ expand_function_end (filename, line, end_bindings)\n       emit_move_insn (outgoing, value_address);\n     }\n \n+  /* ??? This should no longer be necessary since stupid is no longer with\n+     us, but there are some parts of the compiler (eg reload_combine, and\n+     sh mach_dep_reorg) that still try and compute their own lifetime info\n+     instead of using the general framework.  */\n+  use_return_register ();\n+\n   /* If this is an implementation of __throw, do what's necessary to \n      communicate between __builtin_eh_return and the epilogue.  */\n   expand_eh_return ();"}, {"sha": "1a94f948c6960d37cc2bb617a7a071db54d24e83", "filename": "gcc/function.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=c13fde0599c2f8dbbbdc625dba0bf7b610a2d597", "patch": "@@ -585,7 +585,9 @@ extern void free_expr_status\t\tPARAMS ((struct function *));\n extern rtx get_first_block_beg\t\tPARAMS ((void));\n \n #ifdef RTX_CODE\n-extern void diddle_return_value\t\tPARAMS ((enum rtx_code));\n+extern void diddle_return_value\t\tPARAMS ((void (*)(rtx, void*), void*));\n+extern void clobber_return_register\tPARAMS ((void));\n+extern void use_return_register\t\tPARAMS ((void));\n #endif\n \n extern void init_virtual_regs\t\tPARAMS ((struct emit_status *));"}, {"sha": "0cbff9d05f391c93070aa370cf6363f5514ee73d", "filename": "gcc/integrate.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=c13fde0599c2f8dbbbdc625dba0bf7b610a2d597", "patch": "@@ -1099,6 +1099,13 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t  pattern = PATTERN (insn);\n \t  set = single_set (insn);\n \t  copy = 0;\n+\t  if (GET_CODE (pattern) == USE\n+\t      && GET_CODE (XEXP (pattern, 0)) == REG\n+\t      && REG_FUNCTION_VALUE_P (XEXP (pattern, 0)))\n+\t    /* The (USE (REG n)) at return from the function should\n+\t       be ignored since we are changing (REG n) into\n+\t       inline_target.  */\n+\t    break;\n \n \t  /* If the inline fn needs eh context, make sure that\n \t     the current fn has one. */"}, {"sha": "8c76b3b57e4d40c5ed91ddab5c8f6b059a87d69c", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13fde0599c2f8dbbbdc625dba0bf7b610a2d597/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=c13fde0599c2f8dbbbdc625dba0bf7b610a2d597", "patch": "@@ -2676,11 +2676,9 @@ expand_null_return ()\n   /* If this function was declared to return a value, but we \n      didn't, clobber the return registers so that they are not\n      propogated live to the rest of the function.  */\n-\n-  diddle_return_value (CLOBBER);\n+  clobber_return_register ();\n \n   /* Does any pending block have cleanups?  */\n-\n   while (block && block->data.block.cleanups == 0)\n     block = block->next;\n "}]}