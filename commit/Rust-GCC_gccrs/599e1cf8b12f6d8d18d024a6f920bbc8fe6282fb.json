{"sha": "599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk5ZTFjZjhiMTJmNmQ4ZDE4ZDAyNGE2ZjkyMGJiYzhmZTYyODJmYg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2015-10-02T15:04:59Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2015-10-02T15:04:59Z"}, "message": "re PR rtl-optimization/67756 (ICE compiling Linux Kernel fs/namei.c on ARM)\n\n2015-10-02  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/67756\n\t* lra-constraints.c (match_reload): Add a new parameter.  Use it\n\tfor creating a pseudo with the same value.\n\t(curr_insn_transform): Pass a new argument to match_reload.\n\n2015-10-02  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/67756\n\t* gcc.target/arm/pr67756.c: New.\n\nFrom-SVN: r228396", "tree": {"sha": "bed07ca8773ef9aac9f9297b536e0ffa68a96e83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bed07ca8773ef9aac9f9297b536e0ffa68a96e83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ff3ac5f445bb1b94a85e0cf765213eb713e87e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff3ac5f445bb1b94a85e0cf765213eb713e87e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ff3ac5f445bb1b94a85e0cf765213eb713e87e3"}], "stats": {"total": 106, "additions": 94, "deletions": 12}, "files": [{"sha": "b0856aae16c761adb396fb58990807ed61fb74f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb", "patch": "@@ -1,3 +1,10 @@\n+2015-10-02  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/67756\n+\t* lra-constraints.c (match_reload): Add a new parameter.  Use it\n+\tfor creating a pseudo with the same value.\n+\t(curr_insn_transform): Pass a new argument to match_reload.\n+\n 2015-10-02  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* config/i386/i386.c (expand_vec_perm_even_odd_trunc): New."}, {"sha": "2c27f1abfe44600f0b910dbcf8f8649724185eb2", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb", "patch": "@@ -855,10 +855,11 @@ narrow_reload_pseudo_class (rtx reg, enum reg_class cl)\n    numbers with end marker -1) with reg class GOAL_CLASS.  Add input\n    and output reloads correspondingly to the lists *BEFORE and *AFTER.\n    OUT might be negative.  In this case we generate input reloads for\n-   matched input operands INS.  */\n+   matched input operands INS.  EARLY_CLOBBER_P is a flag that the\n+   output operand is early clobbered for chosen alternative.  */\n static void\n match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n-\t      rtx_insn **before, rtx_insn **after)\n+\t      rtx_insn **before, rtx_insn **after, bool early_clobber_p)\n {\n   int i, in;\n   rtx new_in_reg, new_out_reg, reg;\n@@ -939,17 +940,19 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t have a situation like \"a <- a op b\", where the constraints\n \t force the second input operand (\"b\") to match the output\n \t operand (\"a\").  \"b\" must then be copied into a new register\n-\t so that it doesn't clobber the current value of \"a\".  */\n+\t so that it doesn't clobber the current value of \"a\".\n+\n+\t We can not use the same value if the output pseudo is\n+\t early clobbered or the input pseudo is mentioned in the\n+\t output, e.g. as an address part in memory, because\n+\t output reload will actually extend the pseudo liveness.\n+\t We don't care about eliminable hard regs here as we are\n+\t interesting only in pseudos.  */\n \n       new_in_reg = new_out_reg\n-\t= (ins[1] < 0 && REG_P (in_rtx)\n+\t= (! early_clobber_p && ins[1] < 0 && REG_P (in_rtx)\n \t   && (int) REGNO (in_rtx) < lra_new_regno_start\n \t   && find_regno_note (curr_insn, REG_DEAD, REGNO (in_rtx))\n-\t   /* We can not use the same value if the pseudo is mentioned\n-\t      in the output, e.g. as an address part in memory,\n-\t      becuase output reload will actually extend the pseudo\n-\t      liveness.  We don't care about eliminable hard regs here\n-\t      as we are interesting only in pseudos.  */\n \t   && (out < 0 || regno_use_in (REGNO (in_rtx), out_rtx) == NULL_RTX)\n \t   ? lra_create_new_reg (inmode, in_rtx, goal_class, \"\")\n \t   : lra_create_new_reg_with_unique_value (outmode, out_rtx,\n@@ -3867,13 +3870,18 @@ curr_insn_transform (bool check_only_p)\n \t  match_inputs[0] = i;\n \t  match_inputs[1] = -1;\n \t  match_reload (goal_alt_matched[i][0], match_inputs,\n-\t\t\tgoal_alt[i], &before, &after);\n+\t\t\tgoal_alt[i], &before, &after,\n+\t\t\tcurr_static_id->operand_alternative\n+\t\t\t[goal_alt_number * n_operands + goal_alt_matched[i][0]]\n+\t\t\t.earlyclobber);\n \t}\n       else if (curr_static_id->operand[i].type == OP_OUT\n \t       && (curr_static_id->operand[goal_alt_matched[i][0]].type\n \t\t   == OP_IN))\n \t/* Generate reloads for output and matched inputs.  */\n-\tmatch_reload (i, goal_alt_matched[i], goal_alt[i], &before, &after);\n+\tmatch_reload (i, goal_alt_matched[i], goal_alt[i], &before, &after,\n+\t\t      curr_static_id->operand_alternative\n+\t\t      [goal_alt_number * n_operands + i].earlyclobber);\n       else if (curr_static_id->operand[i].type == OP_IN\n \t       && (curr_static_id->operand[goal_alt_matched[i][0]].type\n \t\t   == OP_IN))\n@@ -3883,7 +3891,7 @@ curr_insn_transform (bool check_only_p)\n \t  for (j = 0; (k = goal_alt_matched[i][j]) >= 0; j++)\n \t    match_inputs[j + 1] = k;\n \t  match_inputs[j + 1] = -1;\n-\t  match_reload (-1, match_inputs, goal_alt[i], &before, &after);\n+\t  match_reload (-1, match_inputs, goal_alt[i], &before, &after, false);\n \t}\n       else\n \t/* We must generate code in any case when function"}, {"sha": "bceeaaa8b313433b66f2f854917e047543e99e2e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb", "patch": "@@ -1,3 +1,8 @@\n+2015-10-02  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/67756\n+\t* gcc.target/arm/pr67756.c: New.\n+\n 2015-10-02  Jiong Wang  <jiong.wang@arm.com>\n \n \t* gcc.target/aarch64/tlsle12_tiny_1.c: New testcase for tiny model."}, {"sha": "9314ff51e46c4fed4efecf158e9b4bf42c3d12e5", "filename": "gcc/testsuite/gcc.target/arm/pr67756.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr67756.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr67756.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr67756.c?ref=599e1cf8b12f6d8d18d024a6f920bbc8fe6282fb", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-options \"-O2 -mapcs -march=armv7-a -mfloat-abi=hard -mfpu=vfpv3-d16\" } */\n+\n+struct mutex\n+{\n+};\n+struct dentry\n+{\n+  struct inode *d_inode;\n+};\n+struct inode\n+{\n+  const struct inode_operations *i_op;\n+  struct super_block *i_sb;\n+    union\n+    {\n+      const unsigned int i_nlink;\n+    };\n+  unsigned long i_state;\n+  struct mutex i_mutex;\n+};\n+struct super_block\n+{\n+  unsigned int s_max_links;\n+};\n+struct inode_operations\n+{\n+  int (*link) (struct dentry *, struct inode *, struct dentry *);\n+} __attribute__ ((__aligned__ ((1 << 6))));\n+static inline __attribute__ ((always_inline))\n+__attribute__ ((no_instrument_function))\n+int may_create (struct inode *dir, struct dentry *child)\n+{\n+  if (child->d_inode)\n+    return -17;\n+  return inode_permission (dir, 0x00000002 | 0x00000001);\n+}\n+\n+int\n+vfs_link (struct dentry *old_dentry, struct inode *dir,\n+\t  struct dentry *new_dentry, struct inode **delegated_inode)\n+{\n+  struct inode *inode = old_dentry->d_inode;\n+  unsigned max_links = dir->i_sb->s_max_links;\n+  int error;\n+  error = may_create (dir, new_dentry);\n+  if (error)\n+    return error;\n+  mutex_lock (&inode->i_mutex);\n+  if (inode->i_nlink == 0 && !(inode->i_state & (1 << 10)))\n+    error = -2;\n+  else if (max_links && inode->i_nlink >= max_links)\n+    error = -31;\n+  else\n+    {\n+      error = try_break_deleg (inode, delegated_inode);\n+      error = dir->i_op->link (old_dentry, dir, new_dentry);\n+    }\n+  mutex_unlock (&inode->i_mutex);\n+  return error;\n+}"}]}