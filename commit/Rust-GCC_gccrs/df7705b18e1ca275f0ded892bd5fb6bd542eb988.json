{"sha": "df7705b18e1ca275f0ded892bd5fb6bd542eb988", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY3NzA1YjE4ZTFjYTI3NWYwZGVkODkyYmQ1ZmI2YmQ1NDJlYjk4OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-11-16T18:15:17Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-11-16T18:15:17Z"}, "message": "cgraph.h (+varpool_can_remove_if_no_refs): Move here from ......\n\n\n\t* cgraph.h (+varpool_can_remove_if_no_refs): Move here from ...;\n\twhen !flag_toplevel_reorder do not remove unless variable is\n\tCOMDAT or ARTIFICIAL.\n\t* ipa.c (varpool_can_remove_if_no_refs): ... here.\n\t(cgraph_remove_unreachable_nodes): Only analyzed nodes needs to stay.\n\t* cgraphunit.c (cgraph_analyze_functions): Dump varpool, too.\n\t* varpool.c (decide_is_variable_needed): Do not handle visibility issues.\n\t(varpool_finalize_decl): Likewise.\n\t(varpool_remove_unreferenced_decls): Use varpool_mark_needed_node; update\n\toutdated comment on DECL_RTL_SET_P check.\n\nFrom-SVN: r166812", "tree": {"sha": "b9cf407f17bdb390a410566498c603ef34073ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9cf407f17bdb390a410566498c603ef34073ef6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df7705b18e1ca275f0ded892bd5fb6bd542eb988", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7705b18e1ca275f0ded892bd5fb6bd542eb988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df7705b18e1ca275f0ded892bd5fb6bd542eb988", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7705b18e1ca275f0ded892bd5fb6bd542eb988/comments", "author": null, "committer": null, "parents": [{"sha": "3e794bfe4393d5398c21658837c7437f1a1cbc5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e794bfe4393d5398c21658837c7437f1a1cbc5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e794bfe4393d5398c21658837c7437f1a1cbc5c"}], "stats": {"total": 79, "additions": 41, "deletions": 38}, "files": [{"sha": "30a45df910b9e667cae3a9568d8fd8941e090bca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7705b18e1ca275f0ded892bd5fb6bd542eb988/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7705b18e1ca275f0ded892bd5fb6bd542eb988/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df7705b18e1ca275f0ded892bd5fb6bd542eb988", "patch": "@@ -1,3 +1,16 @@\n+2010-11-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (+varpool_can_remove_if_no_refs): Move here from ...;\n+\twhen !flag_toplevel_reorder do not remove unless variable is\n+\tCOMDAT or ARTIFICIAL.\n+\t* ipa.c (varpool_can_remove_if_no_refs): ... here.\n+\t(cgraph_remove_unreachable_nodes): Only analyzed nodes needs to stay.\n+\t* cgraphunit.c (cgraph_analyze_functions): Dump varpool, too.\n+\t* varpool.c (decide_is_variable_needed): Do not handle visibility issues.\n+\t(varpool_finalize_decl): Likewise.\n+\t(varpool_remove_unreferenced_decls): Use varpool_mark_needed_node; update\n+\toutdated comment on DECL_RTL_SET_P check.\n+\n 2010-11-16  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config/sol2.h (NM_FLAGS): Define."}, {"sha": "0334a154824c5dff2944049a13f7080fbb5fe320", "filename": "gcc/cgraph.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7705b18e1ca275f0ded892bd5fb6bd542eb988/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7705b18e1ca275f0ded892bd5fb6bd542eb988/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=df7705b18e1ca275f0ded892bd5fb6bd542eb988", "patch": "@@ -928,6 +928,18 @@ cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n   return !node->address_taken && cgraph_can_remove_if_no_direct_calls_and_refs_p (node);\n }\n \n+/* Return true when function NODE can be removed from callgraph\n+   if all direct calls are eliminated.  */\n+\n+static inline bool\n+varpool_can_remove_if_no_refs (struct varpool_node *node)\n+{\n+  return (!node->force_output && !node->used_from_other_partition\n+\t  && (flag_toplevel_reorder || DECL_COMDAT (node->decl)\n+\t      || DECL_ARTIFICIAL (node->decl))\n+  \t  && (DECL_COMDAT (node->decl) || !node->externally_visible));\n+}\n+\n /* Return true when all references to VNODE must be visible in ipa_ref_list.\n    i.e. if the variable is not externally visible or not used in some magic\n    way (asm statement or such)."}, {"sha": "dd7c0fbffce4b46b138f76f765d0710481285e8e", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7705b18e1ca275f0ded892bd5fb6bd542eb988/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7705b18e1ca275f0ded892bd5fb6bd542eb988/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=df7705b18e1ca275f0ded892bd5fb6bd542eb988", "patch": "@@ -943,6 +943,7 @@ cgraph_analyze_functions (void)\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\\nInitial \");\n       dump_cgraph (cgraph_dump_file);\n+      dump_varpool (cgraph_dump_file);\n     }\n \n   if (cgraph_dump_file)\n@@ -972,6 +973,7 @@ cgraph_analyze_functions (void)\n     {\n       fprintf (cgraph_dump_file, \"\\n\\nReclaimed \");\n       dump_cgraph (cgraph_dump_file);\n+      dump_varpool (cgraph_dump_file);\n     }\n   bitmap_obstack_release (NULL);\n   first_analyzed = cgraph_nodes;\n@@ -1816,6 +1818,7 @@ cgraph_optimize (void)\n     {\n       fprintf (cgraph_dump_file, \"\\nFinal \");\n       dump_cgraph (cgraph_dump_file);\n+      dump_varpool (cgraph_dump_file);\n     }\n #ifdef ENABLE_CHECKING\n   verify_cgraph ();"}, {"sha": "3742f84e53b26dc7b07d6ffb9fb49a4aa4795054", "filename": "gcc/ipa.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7705b18e1ca275f0ded892bd5fb6bd542eb988/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7705b18e1ca275f0ded892bd5fb6bd542eb988/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=df7705b18e1ca275f0ded892bd5fb6bd542eb988", "patch": "@@ -188,16 +188,6 @@ process_references (struct ipa_ref_list *list,\n     }\n }\n \n-/* Return true when function NODE can be removed from callgraph\n-   if all direct calls are eliminated.  */\n-\n-static inline bool\n-varpool_can_remove_if_no_refs (struct varpool_node *node)\n-{\n-  return (!node->force_output && !node->used_from_other_partition\n-  \t  && (DECL_COMDAT (node->decl) || !node->externally_visible));\n-}\n-\n /* Return true when function can be marked local.  */\n \n static bool\n@@ -269,7 +259,8 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     {\n       vnode->next_needed = NULL;\n       vnode->prev_needed = NULL;\n-      if (!varpool_can_remove_if_no_refs (vnode))\n+      if (vnode->analyzed\n+\t  && !varpool_can_remove_if_no_refs (vnode))\n \t{\n \t  vnode->needed = false;\n \t  varpool_mark_needed_node (vnode);"}, {"sha": "88226601302fd4ffb6de026020ce0e27d83f0801", "filename": "gcc/varpool.c", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7705b18e1ca275f0ded892bd5fb6bd542eb988/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7705b18e1ca275f0ded892bd5fb6bd542eb988/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=df7705b18e1ca275f0ded892bd5fb6bd542eb988", "patch": "@@ -331,31 +331,24 @@ varpool_reset_queue (void)\n bool\n decide_is_variable_needed (struct varpool_node *node, tree decl)\n {\n-  if (node->used_from_other_partition)\n-    return true;\n   /* If the user told us it is used, then it must be so.  */\n-  if ((node->externally_visible && !DECL_COMDAT (decl))\n-      || node->force_output)\n+  if (node->force_output)\n     return true;\n \n+  gcc_assert (!DECL_EXTERNAL (decl));\n+\n   /* Externally visible variables must be output.  The exception is\n      COMDAT variables that must be output only when they are needed.  */\n   if (TREE_PUBLIC (decl)\n-      && !flag_whole_program\n-      && !flag_lto\n       && !DECL_COMDAT (decl)\n       && !DECL_EXTERNAL (decl))\n     return true;\n \n   /* When not reordering top level variables, we have to assume that\n      we are going to keep everything.  */\n-  if (flag_toplevel_reorder)\n-    return false;\n-\n-  /* We want to emit COMDAT variables only when absolutely necessary.  */\n-  if (DECL_COMDAT (decl))\n-    return false;\n-  return true;\n+  if (!flag_toplevel_reorder)\n+    return true;\n+  return false;\n }\n \n /* Return if DECL is constant and its initial value is known (so we can do\n@@ -427,11 +420,6 @@ varpool_finalize_decl (tree decl)\n \n   if (decide_is_variable_needed (node, decl))\n     varpool_mark_needed_node (node);\n-  /* Since we reclaim unreachable nodes at the end of every language\n-     level unit, we need to be conservative about possible entry points\n-     there.  */\n-  else if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n-    varpool_mark_needed_node (node);\n   if (cgraph_global_info_ready)\n     varpool_assemble_pending_decls ();\n }\n@@ -557,18 +545,14 @@ varpool_remove_unreferenced_decls (void)\n \n   while (node)\n     {\n-      tree decl = node->decl;\n       next = node->next_needed;\n       node->needed = 0;\n \n-      if (node->finalized\n-\t  && (decide_is_variable_needed (node, decl)\n-\t      /* ??? Cgraph does not yet rule the world with an iron hand,\n-\t\t and does not control the emission of debug information.\n-\t\t After a variable has its DECL_RTL set, we must assume that\n-\t\t it may be referenced by the debug information, and we can\n-\t\t no longer elide it.  */\n-\t      || DECL_RTL_SET_P (decl)))\n+      if (node->analyzed\n+\t  && (!varpool_can_remove_if_no_refs (node)\n+\t      /* We just expanded all function bodies.  See if any of\n+\t\t them needed the variable.  */\n+\t      || DECL_RTL_SET_P (node->decl)))\n \tvarpool_mark_needed_node (node);\n \n       node = next;"}]}