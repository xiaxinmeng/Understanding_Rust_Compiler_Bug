{"sha": "792c4e744099b705a889e0676b8f1f71fb467343", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkyYzRlNzQ0MDk5YjcwNWE4ODllMDY3NmI4ZjFmNzFmYjQ2NzM0Mw==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@gnat.com", "date": "2002-03-28T15:21:33Z"}, "committer": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2002-03-28T15:21:33Z"}, "message": "prj-pp.adb: New file.\n\n\t* prj-pp.adb : New file.\n\n\t* prj-pp.ads : New file.\n\nFrom-SVN: r51512", "tree": {"sha": "795001cac0dd5309101e64ddc941a039f470b144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/795001cac0dd5309101e64ddc941a039f470b144"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/792c4e744099b705a889e0676b8f1f71fb467343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792c4e744099b705a889e0676b8f1f71fb467343", "html_url": "https://github.com/Rust-GCC/gccrs/commit/792c4e744099b705a889e0676b8f1f71fb467343", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792c4e744099b705a889e0676b8f1f71fb467343/comments", "author": null, "committer": null, "parents": [{"sha": "915e8bada343b9357346af3bfb3308f8edecfa2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/915e8bada343b9357346af3bfb3308f8edecfa2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/915e8bada343b9357346af3bfb3308f8edecfa2b"}], "stats": {"total": 733, "additions": 733, "deletions": 0}, "files": [{"sha": "9246f26e09d544937447061e619e3b2b8086366d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792c4e744099b705a889e0676b8f1f71fb467343/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792c4e744099b705a889e0676b8f1f71fb467343/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=792c4e744099b705a889e0676b8f1f71fb467343", "patch": "@@ -1,3 +1,9 @@\n+2002-03-28   Geert Bosch <bosch@gnat.com>\n+\n+\t* prj-pp.adb : New file.\n+\n+\t* prj-pp.ads : New file.\n+\n 2002-03-28  Andreas Jaeger  <aj@suse.de>\n \n \t* Makefile.in (stamp-sdefault): Fix path for Makefile."}, {"sha": "707417b0e0fcefd6c5190d35ce95e1115b94d4b6", "filename": "gcc/ada/prj-pp.adb", "status": "added", "additions": 647, "deletions": 0, "changes": 647, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792c4e744099b705a889e0676b8f1f71fb467343/gcc%2Fada%2Fprj-pp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792c4e744099b705a889e0676b8f1f71fb467343/gcc%2Fada%2Fprj-pp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.adb?ref=792c4e744099b705a889e0676b8f1f71fb467343", "patch": "@@ -0,0 +1,647 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               P R J . P P                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--             Copyright (C) 2001-2002 Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Characters.Handling; use Ada.Characters.Handling;\n+\n+with Hostparm;\n+with Namet;     use Namet;\n+with Output;    use Output;\n+with Stringt;   use Stringt;\n+\n+package body Prj.PP is\n+\n+   use Prj.Tree;\n+\n+   Not_Tested : array (Project_Node_Kind) of Boolean := (others => True);\n+\n+   Max_Line_Length : constant := Hostparm.Max_Line_Length - 5;\n+   --  Maximum length of a line.\n+\n+   Column : Natural := 0;\n+   --  Column number of the last character in the line. Used to avoid\n+   --  outputing lines longer than Max_Line_Length.\n+\n+   procedure Indicate_Tested (Kind : Project_Node_Kind);\n+   --  Set the corresponding component of array Not_Tested to False.\n+   --  Only called by pragmas Debug.\n+   --\n+\n+   ---------------------\n+   -- Indicate_Tested --\n+   ---------------------\n+\n+   procedure Indicate_Tested (Kind : Project_Node_Kind) is\n+   begin\n+      Not_Tested (Kind) := False;\n+   end Indicate_Tested;\n+\n+   ------------------\n+   -- Pretty_Print --\n+   ------------------\n+\n+   procedure Pretty_Print\n+     (Project                            : Prj.Tree.Project_Node_Id;\n+      Increment                          : Positive      := 3;\n+      Eliminate_Empty_Case_Constructions : Boolean       := False;\n+      Minimize_Empty_Lines               : Boolean       := False;\n+      W_Char                             : Write_Char_Ap := null;\n+      W_Eol                              : Write_Eol_Ap  := null;\n+      W_Str                              : Write_Str_Ap  := null) is\n+\n+      procedure Print (Node : Project_Node_Id; Indent : Natural);\n+      --  A recursive procedure that traverses a project file tree\n+      --  and outputs its source.\n+      --  Current_Prj is the project that we are printing. This\n+      --  is used when printing attributes, since in nested packages they need\n+      --  to use a fully qualified name.\n+\n+      procedure Output_Name (Name : Name_Id; Capitalize : Boolean := True);\n+      --  Outputs a name\n+\n+      procedure Start_Line (Indent : Natural);\n+      --  Outputs the indentation at the beginning of the line.\n+\n+      procedure Output_String (S : String_Id);\n+      --  Outputs a string using the default output procedures\n+\n+      procedure Write_Empty_Line (Always : Boolean := False);\n+      --  Outputs an empty line, only if the previous line was not\n+      --  empty already and either Always is True or Minimize_Empty_Lines\n+      --  is False.\n+\n+      procedure Write_Line (S : String);\n+      --  Outputs S followed by a new line\n+\n+      procedure Write_String (S : String);\n+      --  Outputs S using Write_Str, starting a new line if line would\n+      --  become too long.\n+\n+      Write_Char : Write_Char_Ap := Output.Write_Char'Access;\n+      Write_Eol  : Write_Eol_Ap  := Output.Write_Eol'Access;\n+      Write_Str  : Write_Str_Ap  := Output.Write_Str'Access;\n+      --  These two access to procedure values are used for the output.\n+\n+      Last_Line_Is_Empty : Boolean := False;\n+      --  Used to avoid two consecutive empty lines.\n+\n+      -----------------\n+      -- Output_Name --\n+      -----------------\n+\n+      procedure Output_Name (Name : Name_Id; Capitalize : Boolean := True) is\n+         Capital : Boolean := Capitalize;\n+\n+      begin\n+         Get_Name_String (Name);\n+\n+         --  If line would become too long, create new line\n+\n+         if Column + Name_Len > Max_Line_Length then\n+            Write_Eol.all;\n+            Column := 0;\n+         end if;\n+\n+         for J in 1 .. Name_Len loop\n+            if Capital then\n+               Write_Char (To_Upper (Name_Buffer (J)));\n+            else\n+               Write_Char (Name_Buffer (J));\n+            end if;\n+\n+            if Capitalize then\n+               Capital :=\n+                 Name_Buffer (J) = '_'\n+                 or else Is_Digit (Name_Buffer (J));\n+            end if;\n+         end loop;\n+      end Output_Name;\n+\n+      -------------------\n+      -- Output_String --\n+      -------------------\n+\n+      procedure Output_String (S : String_Id) is\n+      begin\n+         String_To_Name_Buffer (S);\n+\n+         --  If line could become too long, create new line.\n+         --  Note that the number of characters on the line could be\n+         --  twice the number of character in the string (if every\n+         --  character is a '\"') plus two (the initial and final '\"').\n+\n+         if Column + Name_Len + Name_Len + 2 > Max_Line_Length then\n+            Write_Eol.all;\n+            Column := 0;\n+         end if;\n+\n+         Write_Char ('\"');\n+         Column := Column + 1;\n+         String_To_Name_Buffer (S);\n+\n+         for J in 1 .. Name_Len loop\n+            if Name_Buffer (J) = '\"' then\n+               Write_Char ('\"');\n+               Write_Char ('\"');\n+               Column := Column + 2;\n+            else\n+               Write_Char (Name_Buffer (J));\n+               Column := Column + 1;\n+            end if;\n+\n+            --  If the string does not fit on one line, cut it in parts\n+            --  and concatenate.\n+\n+            if J < Name_Len and then Column >= Max_Line_Length then\n+               Write_Str (\"\"\" &\");\n+               Write_Eol.all;\n+               Write_Char ('\"');\n+               Column := 1;\n+            end if;\n+         end loop;\n+\n+         Write_Char ('\"');\n+         Column := Column + 1;\n+      end Output_String;\n+\n+      ----------------\n+      -- Start_Line --\n+      ----------------\n+\n+      procedure Start_Line (Indent : Natural) is\n+      begin\n+         if not Minimize_Empty_Lines then\n+            Write_Str ((1 .. Indent => ' '));\n+            Column := Column + Indent;\n+         end if;\n+      end Start_Line;\n+\n+      ----------------------\n+      -- Write_Empty_Line --\n+      ----------------------\n+\n+      procedure Write_Empty_Line (Always : Boolean := False) is\n+      begin\n+         if (Always or else not Minimize_Empty_Lines)\n+           and then not Last_Line_Is_Empty then\n+            Write_Eol.all;\n+            Column := 0;\n+            Last_Line_Is_Empty := True;\n+         end if;\n+      end Write_Empty_Line;\n+\n+      ----------------\n+      -- Write_Line --\n+      ----------------\n+\n+      procedure Write_Line (S : String) is\n+      begin\n+         Write_String (S);\n+         Last_Line_Is_Empty := False;\n+         Write_Eol.all;\n+         Column := 0;\n+      end Write_Line;\n+\n+      ------------------\n+      -- Write_String --\n+      ------------------\n+\n+      procedure Write_String (S : String) is\n+      begin\n+         --  If the string would not fit on the line,\n+         --  start a new line.\n+\n+         if Column + S'Length > Max_Line_Length then\n+            Write_Eol.all;\n+            Column := 0;\n+         end if;\n+\n+         Write_Str (S);\n+         Column := Column + S'Length;\n+      end Write_String;\n+\n+      -----------\n+      -- Print --\n+      -----------\n+\n+      procedure Print (Node   : Project_Node_Id; Indent : Natural) is\n+      begin\n+         if Node /= Empty_Node then\n+\n+            case Kind_Of (Node) is\n+\n+               when N_Project  =>\n+                  pragma Debug (Indicate_Tested (N_Project));\n+                  if First_With_Clause_Of (Node) /= Empty_Node then\n+\n+                     --  with clause(s)\n+\n+                     Print (First_With_Clause_Of (Node), Indent);\n+                     Write_Empty_Line (Always => True);\n+                  end if;\n+\n+                  Start_Line (Indent);\n+                  Write_String (\"project \");\n+                  Output_Name (Name_Of (Node));\n+\n+                  --  Check if this project modifies another project\n+\n+                  if Modified_Project_Path_Of (Node) /= No_String then\n+                     Write_String (\" extends \");\n+                     Output_String (Modified_Project_Path_Of (Node));\n+                  end if;\n+\n+                  Write_Line (\" is\");\n+                  Write_Empty_Line (Always => True);\n+\n+                  --  Output all of the declarations in the project\n+\n+                  Print (Project_Declaration_Of (Node), Indent);\n+                  Start_Line (Indent);\n+                  Write_String (\"end \");\n+                  Output_Name (Name_Of (Node));\n+                  Write_Line (\";\");\n+\n+               when N_With_Clause =>\n+                  pragma Debug (Indicate_Tested (N_With_Clause));\n+\n+                  if Name_Of (Node) /= No_Name then\n+                     Start_Line (Indent);\n+                     Write_String (\"with \");\n+                     Output_String (String_Value_Of (Node));\n+                     Write_Line (\";\");\n+                  end if;\n+\n+                  Print (Next_With_Clause_Of (Node), Indent);\n+\n+               when N_Project_Declaration =>\n+                  pragma Debug (Indicate_Tested (N_Project_Declaration));\n+\n+                  if First_Declarative_Item_Of (Node) /= Empty_Node then\n+                     Print\n+                       (First_Declarative_Item_Of (Node), Indent + Increment);\n+                     Write_Empty_Line (Always => True);\n+                  end if;\n+\n+               when N_Declarative_Item =>\n+                  pragma Debug (Indicate_Tested (N_Declarative_Item));\n+                  Print (Current_Item_Node (Node), Indent);\n+                  Print (Next_Declarative_Item (Node), Indent);\n+\n+               when N_Package_Declaration =>\n+                  pragma Debug (Indicate_Tested (N_Package_Declaration));\n+                  Write_Empty_Line (Always => True);\n+                  Start_Line (Indent);\n+                  Write_String (\"package \");\n+                  Output_Name (Name_Of (Node));\n+\n+                  if Project_Of_Renamed_Package_Of (Node) /= Empty_Node then\n+                     Write_String (\" renames \");\n+                     Output_Name\n+                       (Name_Of (Project_Of_Renamed_Package_Of (Node)));\n+                     Write_String (\".\");\n+                     Output_Name (Name_Of (Node));\n+                     Write_Line (\";\");\n+\n+                  else\n+                     Write_Line (\" is\");\n+\n+                     if First_Declarative_Item_Of (Node) /= Empty_Node then\n+                        Print\n+                          (First_Declarative_Item_Of (Node),\n+                           Indent + Increment);\n+                     end if;\n+\n+                     Start_Line (Indent);\n+                     Write_String (\"end \");\n+                     Output_Name (Name_Of (Node));\n+                     Write_Line (\";\");\n+                     Write_Empty_Line;\n+                  end if;\n+\n+               when N_String_Type_Declaration =>\n+                  pragma Debug (Indicate_Tested (N_String_Type_Declaration));\n+                  Start_Line (Indent);\n+                  Write_String (\"type \");\n+                  Output_Name (Name_Of (Node));\n+                  Write_Line (\" is\");\n+                  Start_Line (Indent + Increment);\n+                  Write_String (\"(\");\n+\n+                  declare\n+                     String_Node : Project_Node_Id :=\n+                       First_Literal_String (Node);\n+\n+                  begin\n+                     while String_Node /= Empty_Node loop\n+                        Output_String (String_Value_Of (String_Node));\n+                        String_Node := Next_Literal_String (String_Node);\n+\n+                        if String_Node /= Empty_Node then\n+                           Write_String (\", \");\n+                        end if;\n+                     end loop;\n+                  end;\n+\n+                  Write_Line (\");\");\n+\n+               when N_Literal_String =>\n+                  pragma Debug (Indicate_Tested (N_Literal_String));\n+                  Output_String (String_Value_Of (Node));\n+\n+               when N_Attribute_Declaration =>\n+                  pragma Debug (Indicate_Tested (N_Attribute_Declaration));\n+                  Start_Line (Indent);\n+                  Write_String (\"for \");\n+                  Output_Name (Name_Of (Node));\n+\n+                  if Associative_Array_Index_Of (Node) /= No_String then\n+                     Write_String (\" (\");\n+                     Output_String (Associative_Array_Index_Of (Node));\n+                     Write_String (\")\");\n+                  end if;\n+\n+                  Write_String (\" use \");\n+                  Print (Expression_Of (Node), Indent);\n+                  Write_Line (\";\");\n+\n+               when N_Typed_Variable_Declaration =>\n+                  pragma Debug\n+                    (Indicate_Tested (N_Typed_Variable_Declaration));\n+                  Start_Line (Indent);\n+                  Output_Name (Name_Of (Node));\n+                  Write_String (\" : \");\n+                  Output_Name (Name_Of (String_Type_Of (Node)));\n+                  Write_String (\" := \");\n+                  Print (Expression_Of (Node), Indent);\n+                  Write_Line (\";\");\n+\n+               when N_Variable_Declaration =>\n+                  pragma Debug (Indicate_Tested (N_Variable_Declaration));\n+                  Start_Line (Indent);\n+                  Output_Name (Name_Of (Node));\n+                  Write_String (\" := \");\n+                  Print (Expression_Of (Node), Indent);\n+                  Write_Line (\";\");\n+\n+               when N_Expression =>\n+                  pragma Debug (Indicate_Tested (N_Expression));\n+                  declare\n+                     Term : Project_Node_Id := First_Term (Node);\n+\n+                  begin\n+                     while Term /= Empty_Node loop\n+                        Print (Term, Indent);\n+                        Term := Next_Term (Term);\n+\n+                        if Term /= Empty_Node then\n+                           Write_String (\" & \");\n+                        end if;\n+                     end loop;\n+                  end;\n+\n+               when N_Term =>\n+                  pragma Debug (Indicate_Tested (N_Term));\n+                  Print (Current_Term (Node), Indent);\n+\n+               when N_Literal_String_List =>\n+                  pragma Debug (Indicate_Tested (N_Literal_String_List));\n+                  Write_String (\"(\");\n+\n+                  declare\n+                     Expression : Project_Node_Id :=\n+                       First_Expression_In_List (Node);\n+\n+                  begin\n+                     while Expression /= Empty_Node loop\n+                        Print (Expression, Indent);\n+                        Expression := Next_Expression_In_List (Expression);\n+\n+                        if Expression /= Empty_Node then\n+                           Write_String (\", \");\n+                        end if;\n+                     end loop;\n+                  end;\n+\n+                  Write_String (\")\");\n+\n+               when N_Variable_Reference =>\n+                  pragma Debug (Indicate_Tested (N_Variable_Reference));\n+                  if Project_Node_Of (Node) /= Empty_Node then\n+                     Output_Name (Name_Of (Project_Node_Of (Node)));\n+                     Write_String (\".\");\n+                  end if;\n+\n+                  if Package_Node_Of (Node) /= Empty_Node then\n+                     Output_Name (Name_Of (Package_Node_Of (Node)));\n+                     Write_String (\".\");\n+                  end if;\n+\n+                  Output_Name (Name_Of (Node));\n+\n+               when N_External_Value =>\n+                  pragma Debug (Indicate_Tested (N_External_Value));\n+                  Write_String (\"external (\");\n+                  Print (External_Reference_Of (Node), Indent);\n+\n+                  if External_Default_Of (Node) /= Empty_Node then\n+                     Write_String (\", \");\n+                     Print (External_Default_Of (Node), Indent);\n+                  end if;\n+\n+                  Write_String (\")\");\n+\n+               when N_Attribute_Reference =>\n+                  pragma Debug (Indicate_Tested (N_Attribute_Reference));\n+\n+                  if Project_Node_Of (Node) /= Empty_Node\n+                    and then Project_Node_Of (Node) /= Project\n+                  then\n+                     Output_Name (Name_Of (Project_Node_Of (Node)));\n+\n+                     if Package_Node_Of (Node) /= Empty_Node then\n+                        Write_String (\".\");\n+                        Output_Name (Name_Of (Package_Node_Of (Node)));\n+                     end if;\n+\n+                  elsif Package_Node_Of (Node) /= Empty_Node then\n+                     Output_Name (Name_Of (Package_Node_Of (Node)));\n+\n+                  else\n+                     Write_String (\"project\");\n+                  end if;\n+\n+                  Write_String (\"'\");\n+                  Output_Name (Name_Of (Node));\n+\n+                  declare\n+                     Index : constant String_Id :=\n+                       Associative_Array_Index_Of (Node);\n+\n+                  begin\n+                     if Index /= No_String then\n+                        Write_String (\" (\");\n+                        Output_String (Index);\n+                        Write_String (\")\");\n+                     end if;\n+                  end;\n+\n+               when N_Case_Construction =>\n+                  pragma Debug (Indicate_Tested (N_Case_Construction));\n+\n+                  declare\n+                     Case_Item : Project_Node_Id := First_Case_Item_Of (Node);\n+                     Is_Non_Empty : Boolean := False;\n+                  begin\n+                     while Case_Item /= Empty_Node loop\n+                        if First_Declarative_Item_Of (Case_Item) /= Empty_Node\n+                          or else not Eliminate_Empty_Case_Constructions\n+                        then\n+                           Is_Non_Empty := True;\n+                           exit;\n+                        end if;\n+                        Case_Item := Next_Case_Item (Case_Item);\n+                     end loop;\n+\n+                     if Is_Non_Empty then\n+                        Write_Empty_Line;\n+                        Start_Line (Indent);\n+                        Write_String (\"case \");\n+                        Print (Case_Variable_Reference_Of (Node), Indent);\n+                        Write_Line (\" is\");\n+\n+                        declare\n+                           Case_Item : Project_Node_Id :=\n+                             First_Case_Item_Of (Node);\n+\n+                        begin\n+                           while Case_Item /= Empty_Node loop\n+                              pragma Assert\n+                                (Kind_Of (Case_Item) = N_Case_Item);\n+                              Print (Case_Item, Indent + Increment);\n+                              Case_Item := Next_Case_Item (Case_Item);\n+                           end loop;\n+                        end;\n+\n+                        Start_Line (Indent);\n+                        Write_Line (\"end case;\");\n+                     end if;\n+                  end;\n+\n+               when N_Case_Item =>\n+                  pragma Debug (Indicate_Tested (N_Case_Item));\n+\n+                  if First_Declarative_Item_Of (Node) /= Empty_Node\n+                    or else not Eliminate_Empty_Case_Constructions\n+                  then\n+                     Write_Empty_Line;\n+                     Start_Line (Indent);\n+                     Write_String (\"when \");\n+\n+                     if First_Choice_Of (Node) = Empty_Node then\n+                        Write_String (\"others\");\n+\n+                     else\n+                        declare\n+                           Label : Project_Node_Id := First_Choice_Of (Node);\n+\n+                        begin\n+                           while Label /= Empty_Node loop\n+                              Print (Label, Indent);\n+                              Label := Next_Literal_String (Label);\n+\n+                              if Label /= Empty_Node then\n+                                 Write_String (\" | \");\n+                              end if;\n+                           end loop;\n+                        end;\n+                     end if;\n+\n+                     Write_Line (\" =>\");\n+\n+                     declare\n+                        First : Project_Node_Id :=\n+                          First_Declarative_Item_Of (Node);\n+\n+                     begin\n+                        if First = Empty_Node then\n+                           Write_Eol.all;\n+\n+                        else\n+                           Print (First, Indent + Increment);\n+                        end if;\n+                     end;\n+                  end if;\n+            end case;\n+         end if;\n+      end Print;\n+\n+   begin\n+      if W_Char = null then\n+         Write_Char := Output.Write_Char'Access;\n+      else\n+         Write_Char := W_Char;\n+      end if;\n+\n+      if W_Eol = null then\n+         Write_Eol := Output.Write_Eol'Access;\n+      else\n+         Write_Eol := W_Eol;\n+      end if;\n+\n+      if W_Str = null then\n+         Write_Str := Output.Write_Str'Access;\n+      else\n+         Write_Str := W_Str;\n+      end if;\n+\n+      Print (Project, 0);\n+\n+      if W_Char = null or else W_Str = null then\n+         Output.Write_Eol;\n+      end if;\n+   end Pretty_Print;\n+\n+   -----------------------\n+   -- Output_Statistics --\n+   -----------------------\n+\n+   procedure Output_Statistics is\n+   begin\n+      Output.Write_Line (\"Project_Node_Kinds not tested:\");\n+\n+      for Kind in Project_Node_Kind loop\n+         if Not_Tested (Kind) then\n+            Output.Write_Str (\"   \");\n+            Output.Write_Line (Project_Node_Kind'Image (Kind));\n+         end if;\n+      end loop;\n+\n+      Output.Write_Eol;\n+   end Output_Statistics;\n+\n+end Prj.PP;"}, {"sha": "b70ff47262467342edbed794e5ee822f763f0f20", "filename": "gcc/ada/prj-pp.ads", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792c4e744099b705a889e0676b8f1f71fb467343/gcc%2Fada%2Fprj-pp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792c4e744099b705a889e0676b8f1f71fb467343/gcc%2Fada%2Fprj-pp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.ads?ref=792c4e744099b705a889e0676b8f1f71fb467343", "patch": "@@ -0,0 +1,80 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               P R J . P P                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+--\n+--  This package is the Project File Pretty Printer.\n+--  It is used to output a project file from a project file tree.\n+--  It is used by gnatname to update or create project files.\n+--  It is also used GLIDE2 to display project file trees.\n+--  It can also be used for debugging purposes for tools that create project\n+--  file trees.\n+\n+with Prj.Tree;\n+\n+package Prj.PP is\n+\n+   --  The following access to procedure types are used\n+   --  to redirect output when calling Pretty_Print.\n+\n+   type Write_Char_Ap is access procedure (C : Character);\n+\n+   type Write_Eol_Ap  is access procedure;\n+\n+   type Write_Str_Ap is access procedure (S : String);\n+\n+   procedure Pretty_Print\n+     (Project                            : Prj.Tree.Project_Node_Id;\n+      Increment                          : Positive      := 3;\n+      Eliminate_Empty_Case_Constructions : Boolean       := False;\n+      Minimize_Empty_Lines               : Boolean       := False;\n+      W_Char                             : Write_Char_Ap := null;\n+      W_Eol                              : Write_Eol_Ap  := null;\n+      W_Str                              : Write_Str_Ap  := null);\n+   --  Output a project file, using either the default output\n+   --  routines, or the ones specified by W_Char, W_Eol and W_Str.\n+   --\n+   --  Increment is the number of spaces for each indentation level.\n+   --\n+   --  W_Char, W_Eol and W_Str can be used to change the default output\n+   --  procedures. The default values force the output to Standard_Output.\n+   --\n+   --  If Eliminate_Empty_Case_Constructions is True, then case constructions\n+   --  and case items that do not include any declarations will not be output.\n+   --\n+   --  If Minimize_Empty_Lines is True, empty lines will be output only\n+   --  after the last with clause, after the line declaring the project name,\n+   --  after the last declarative item of the project and before each\n+   --  package declaration. Otherwise, more empty lines are output.\n+\n+private\n+\n+   procedure Output_Statistics;\n+   --  This procedure can be used after one or more calls to Pretty_Print\n+   --  to display what Project_Node_Kinds have not been exercised by the\n+   --  call(s) to Pretty_Print. It is used only for testing purposes.\n+\n+end Prj.PP;"}]}