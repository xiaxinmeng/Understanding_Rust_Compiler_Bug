{"sha": "2d88904a41a16649193d96b42ccd415c57e08b71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ4ODkwNGE0MWExNjY0OTE5M2Q5NmI0MmNjZDQxNWM1N2UwOGI3MQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2015-08-21T20:03:14Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2015-08-21T20:03:14Z"}, "message": "fix sched compare regression\n\nfor  gcc/ChangeLog\n\n\tPR rtl-optimization/64164\n\tPR rtl-optimization/67227\n\t* alias.c (memrefs_conflict_p): Handle VALUEs in PLUS better.\n\t(nonoverlapping_memrefs_p): Test offsets and sizes when given\n\tidentical gimple_reg exprs.\n\nFrom-SVN: r227085", "tree": {"sha": "04034272b68fd7bb4a52600de902cf6c0e66ea0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04034272b68fd7bb4a52600de902cf6c0e66ea0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d88904a41a16649193d96b42ccd415c57e08b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d88904a41a16649193d96b42ccd415c57e08b71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d88904a41a16649193d96b42ccd415c57e08b71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d88904a41a16649193d96b42ccd415c57e08b71/comments", "author": null, "committer": null, "parents": [{"sha": "18c05628a6a75bce5be48547edb9c75e3f6dab76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c05628a6a75bce5be48547edb9c75e3f6dab76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18c05628a6a75bce5be48547edb9c75e3f6dab76"}], "stats": {"total": 31, "additions": 30, "deletions": 1}, "files": [{"sha": "11f616a705e8ea735fb2c25e42c0e1fb72302c34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d88904a41a16649193d96b42ccd415c57e08b71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d88904a41a16649193d96b42ccd415c57e08b71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d88904a41a16649193d96b42ccd415c57e08b71", "patch": "@@ -1,3 +1,11 @@\n+2015-08-21  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR rtl-optimization/67227\n+\tPR rtl-optimization/64164\n+\t* alias.c (memrefs_conflict_p): Handle VALUEs in PLUS better.\n+\t(nonoverlapping_memrefs_p): Test offsets and sizes when given\n+\tidentical gimple_reg exprs.\n+\n 2015-08-21  Nathan Sidwell  <nathan@acm.org>\n \n \t* config/nvptx/nvptx.md (allocate_stack): Emit sorry during"}, {"sha": "f12d9d12a2bc16bf2ca65f60005a03c313cad971", "filename": "gcc/alias.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d88904a41a16649193d96b42ccd415c57e08b71/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d88904a41a16649193d96b42ccd415c57e08b71/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=2d88904a41a16649193d96b42ccd415c57e08b71", "patch": "@@ -2228,13 +2228,25 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n       rtx x0 = XEXP (x, 0);\n       rtx x1 = XEXP (x, 1);\n \n+      /* However, VALUEs might end up in different positions even in\n+\t canonical PLUSes.  Comparing their addresses is enough.  */\n+      if (x0 == y)\n+\treturn memrefs_conflict_p (xsize, x1, ysize, const0_rtx, c);\n+      else if (x1 == y)\n+\treturn memrefs_conflict_p (xsize, x0, ysize, const0_rtx, c);\n+\n       if (GET_CODE (y) == PLUS)\n \t{\n \t  /* The fact that Y is canonicalized means that this\n \t     PLUS rtx is canonicalized.  */\n \t  rtx y0 = XEXP (y, 0);\n \t  rtx y1 = XEXP (y, 1);\n \n+\t  if (x0 == y1)\n+\t    return memrefs_conflict_p (xsize, x1, ysize, y0, c);\n+\t  if (x1 == y0)\n+\t    return memrefs_conflict_p (xsize, x0, ysize, y1, c);\n+\n \t  if (rtx_equal_for_memref_p (x1, y1))\n \t    return memrefs_conflict_p (xsize, x0, ysize, y0, c);\n \t  if (rtx_equal_for_memref_p (x0, y0))\n@@ -2263,6 +2275,11 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n       rtx y0 = XEXP (y, 0);\n       rtx y1 = XEXP (y, 1);\n \n+      if (x == y0)\n+\treturn memrefs_conflict_p (xsize, const0_rtx, ysize, y1, c);\n+      if (x == y1)\n+\treturn memrefs_conflict_p (xsize, const0_rtx, ysize, y0, c);\n+\n       if (CONST_INT_P (y1))\n \treturn memrefs_conflict_p (xsize, x, ysize, y0, c + INTVAL (y1));\n       else\n@@ -2518,7 +2535,11 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n      able to do anything about them since no SSA information will have\n      remained to guide it.  */\n   if (is_gimple_reg (exprx) || is_gimple_reg (expry))\n-    return exprx != expry;\n+    return exprx != expry\n+      || (moffsetx_known_p && moffsety_known_p\n+\t  && MEM_SIZE_KNOWN_P (x) && MEM_SIZE_KNOWN_P (y)\n+\t  && !offset_overlap_p (moffsety - moffsetx,\n+\t\t\t\tMEM_SIZE (x), MEM_SIZE (y)));\n \n   /* With invalid code we can end up storing into the constant pool.\n      Bail out to avoid ICEing when creating RTL for this."}]}