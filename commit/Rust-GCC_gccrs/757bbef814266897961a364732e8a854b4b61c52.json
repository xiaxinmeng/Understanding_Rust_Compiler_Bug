{"sha": "757bbef814266897961a364732e8a854b4b61c52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU3YmJlZjgxNDI2Njg5Nzk2MWEzNjQ3MzJlOGE4NTRiNGI2MWM1Mg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-12-17T22:57:04Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-12-17T22:57:04Z"}, "message": "cselib.c (struct cselib_val_struct): Make val_rtx its own field, remove the union that contained it.\n\n\t* cselib.c (struct cselib_val_struct): Make val_rtx its\n\town field, remove the union that contained it.\n\t* cselib.c: Update accordingly where necessary.\n\nFrom-SVN: r119994", "tree": {"sha": "123927bfb812fd36f881f54a758390c31565d62c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/123927bfb812fd36f881f54a758390c31565d62c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/757bbef814266897961a364732e8a854b4b61c52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/757bbef814266897961a364732e8a854b4b61c52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/757bbef814266897961a364732e8a854b4b61c52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/757bbef814266897961a364732e8a854b4b61c52/comments", "author": null, "committer": null, "parents": [{"sha": "a7582f7c6dd1b3b7cbc302cff8a9c839859c9567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7582f7c6dd1b3b7cbc302cff8a9c839859c9567", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7582f7c6dd1b3b7cbc302cff8a9c839859c9567"}], "stats": {"total": 55, "additions": 29, "deletions": 26}, "files": [{"sha": "a83625b9d854bd89bf1765c08348f79f5e2dcbf8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bbef814266897961a364732e8a854b4b61c52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bbef814266897961a364732e8a854b4b61c52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=757bbef814266897961a364732e8a854b4b61c52", "patch": "@@ -1,3 +1,9 @@\n+2006-12-17  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cselib.c (struct cselib_val_struct): Make val_rtx its\n+\town field, remove the union that contained it.\n+\t* cselib.c: Update accordingly where necessary.\n+\n 2006-12-17  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cse.c (have_eh_succ_edges): New function."}, {"sha": "39b948a42465de3386b1da6caa0f2a6184a6c37b", "filename": "gcc/cselib.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bbef814266897961a364732e8a854b4b61c52/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bbef814266897961a364732e8a854b4b61c52/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=757bbef814266897961a364732e8a854b4b61c52", "patch": "@@ -237,7 +237,7 @@ entry_and_rtx_equal_p (const void *entry, const void *x_arg)\n   gcc_assert (GET_CODE (x) != CONST_INT\n \t      && (mode != VOIDmode || GET_CODE (x) != CONST_DOUBLE));\n   \n-  if (mode != GET_MODE (v->u.val_rtx))\n+  if (mode != GET_MODE (v->val_rtx))\n     return 0;\n \n   /* Unwrap X if necessary.  */\n@@ -331,7 +331,7 @@ discard_useless_values (void **x, void *info ATTRIBUTE_UNUSED)\n \n   if (v->locs == 0)\n     {\n-      CSELIB_VAL_PTR (v->u.val_rtx) = NULL;\n+      CSELIB_VAL_PTR (v->val_rtx) = NULL;\n       htab_clear_slot (cselib_hash_table, x);\n       unchain_one_value (v);\n       n_useless_values--;\n@@ -387,7 +387,7 @@ cselib_reg_set_mode (rtx x)\n       || REG_VALUES (REGNO (x))->elt == NULL)\n     return VOIDmode;\n \n-  return GET_MODE (REG_VALUES (REGNO (x))->elt->u.val_rtx);\n+  return GET_MODE (REG_VALUES (REGNO (x))->elt->val_rtx);\n }\n \n /* Return nonzero if we can prove that X and Y contain the same value, taking\n@@ -405,15 +405,15 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n       cselib_val *e = cselib_lookup (x, GET_MODE (x), 0);\n \n       if (e)\n-\tx = e->u.val_rtx;\n+\tx = e->val_rtx;\n     }\n \n   if (REG_P (y) || MEM_P (y))\n     {\n       cselib_val *e = cselib_lookup (y, GET_MODE (y), 0);\n \n       if (e)\n-\ty = e->u.val_rtx;\n+\ty = e->val_rtx;\n     }\n \n   if (x == y)\n@@ -748,11 +748,11 @@ new_cselib_val (unsigned int value, enum machine_mode mode)\n      precisely when we can have VALUE RTXen (when cselib is active)\n      so we don't need to put them in garbage collected memory.\n      ??? Why should a VALUE be an RTX in the first place?  */\n-  e->u.val_rtx = pool_alloc (value_pool);\n-  memset (e->u.val_rtx, 0, RTX_HDR_SIZE);\n-  PUT_CODE (e->u.val_rtx, VALUE);\n-  PUT_MODE (e->u.val_rtx, mode);\n-  CSELIB_VAL_PTR (e->u.val_rtx) = e;\n+  e->val_rtx = pool_alloc (value_pool);\n+  memset (e->val_rtx, 0, RTX_HDR_SIZE);\n+  PUT_CODE (e->val_rtx, VALUE);\n+  PUT_MODE (e->val_rtx, mode);\n+  CSELIB_VAL_PTR (e->val_rtx) = e;\n   e->addr_list = 0;\n   e->locs = 0;\n   e->next_containing_mem = 0;\n@@ -777,7 +777,7 @@ add_mem_for_addr (cselib_val *addr_elt, cselib_val *mem_elt, rtx x)\n   addr_elt->addr_list = new_elt_list (addr_elt->addr_list, mem_elt);\n   mem_elt->locs\n     = new_elt_loc_list (mem_elt->locs,\n-\t\t\treplace_equiv_address_nv (x, addr_elt->u.val_rtx));\n+\t\t\treplace_equiv_address_nv (x, addr_elt->val_rtx));\n   if (mem_elt->next_containing_mem == NULL)\n     {\n       mem_elt->next_containing_mem = first_containing_mem;\n@@ -809,7 +809,7 @@ cselib_lookup_mem (rtx x, int create)\n \n   /* Find a value that describes a value of our mode at that address.  */\n   for (l = addr->addr_list; l; l = l->next)\n-    if (GET_MODE (l->elt->u.val_rtx) == mode)\n+    if (GET_MODE (l->elt->val_rtx) == mode)\n       return l->elt;\n \n   if (! create)\n@@ -846,8 +846,8 @@ cselib_subst_to_values (rtx x)\n       if (l && l->elt == NULL)\n \tl = l->next;\n       for (; l; l = l->next)\n-\tif (GET_MODE (l->elt->u.val_rtx) == GET_MODE (x))\n-\t  return l->elt->u.val_rtx;\n+\tif (GET_MODE (l->elt->val_rtx) == GET_MODE (x))\n+\t  return l->elt->val_rtx;\n \n       gcc_unreachable ();\n \n@@ -859,7 +859,7 @@ cselib_subst_to_values (rtx x)\n \t     match any other.  */\n \t  e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n \t}\n-      return e->u.val_rtx;\n+      return e->val_rtx;\n \n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n@@ -873,7 +873,7 @@ cselib_subst_to_values (rtx x)\n     case POST_MODIFY:\n     case PRE_MODIFY:\n       e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n-      return e->u.val_rtx;\n+      return e->val_rtx;\n \n     default:\n       break;\n@@ -943,7 +943,7 @@ cselib_lookup (rtx x, enum machine_mode mode, int create)\n       if (l && l->elt == NULL)\n \tl = l->next;\n       for (; l; l = l->next)\n-\tif (mode == GET_MODE (l->elt->u.val_rtx))\n+\tif (mode == GET_MODE (l->elt->val_rtx))\n \t  return l->elt;\n \n       if (! create)\n@@ -1050,7 +1050,7 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n \t  unsigned int this_last = i;\n \n \t  if (i < FIRST_PSEUDO_REGISTER && v != NULL)\n-\t    this_last += hard_regno_nregs[i][GET_MODE (v->u.val_rtx)] - 1;\n+\t    this_last += hard_regno_nregs[i][GET_MODE (v->val_rtx)] - 1;\n \n \t  if (this_last < regno || v == NULL)\n \t    {\n@@ -1422,7 +1422,7 @@ cselib_process_insn (rtx insn)\n \tif (call_used_regs[i]\n \t    || (REG_VALUES (i) && REG_VALUES (i)->elt\n \t\t&& HARD_REGNO_CALL_PART_CLOBBERED (i, \n-\t\t      GET_MODE (REG_VALUES (i)->elt->u.val_rtx))))\n+\t\t      GET_MODE (REG_VALUES (i)->elt->val_rtx))))\n \t  cselib_invalidate_regno (i, reg_raw_mode[i]);\n \n       if (! CONST_OR_PURE_CALL_P (insn))"}, {"sha": "47bcb994751266add0d91430f0bf19564d5463ab", "filename": "gcc/cselib.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bbef814266897961a364732e8a854b4b61c52/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bbef814266897961a364732e8a854b4b61c52/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=757bbef814266897961a364732e8a854b4b61c52", "patch": "@@ -24,17 +24,14 @@ typedef struct cselib_val_struct GTY(())\n {\n   /* The hash value.  */\n   unsigned int value;\n-  union cselib_val_u\n-  {\n-    /* A VALUE rtx that points back to this structure.  */\n-    rtx GTY ((tag (\"1\"))) val_rtx;\n-    /* Used to keep a list of free cselib_val structures.  */\n-    struct cselib_val_struct * GTY ((skip)) next_free;\n-  } GTY ((desc (\"1\"))) u;\n+\n+  /* A VALUE rtx that points back to this structure.  */\n+  rtx val_rtx;\n \n   /* All rtl expressions that hold this value at the current time during a\n      scan.  */\n   struct elt_loc_list *locs;\n+\n   /* If this value is used as an address, points to a list of values that\n      use it as an address in a MEM.  */\n   struct elt_list *addr_list;"}]}