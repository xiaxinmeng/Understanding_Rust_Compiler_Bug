{"sha": "5e4505e162d069ca58ce43d62770b81cb36137c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU0NTA1ZTE2MmQwNjljYTU4Y2U0M2Q2Mjc3MGI4MWNiMzYxMzdjMA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-07-01T14:53:09Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-07-01T14:53:09Z"}, "message": "Remove HIR::Method this finishes the desugaring of methods into HIR\n\nMethods are just functions with a self param. This simplifies typecheck\nand GENERIC generation code.\n\nAddresses #470 #473", "tree": {"sha": "e3df7cf10a523c2f9320d152b0d799c0693131e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3df7cf10a523c2f9320d152b0d799c0693131e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e4505e162d069ca58ce43d62770b81cb36137c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e4505e162d069ca58ce43d62770b81cb36137c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e4505e162d069ca58ce43d62770b81cb36137c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e4505e162d069ca58ce43d62770b81cb36137c0/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0"}], "stats": {"total": 829, "additions": 86, "deletions": 743}, "files": [{"sha": "6a05c1cf42450d072c02b18579d4d1615642e197", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -121,7 +121,6 @@ class HIRCompileBase : public HIR::HIRVisitor\n   // virtual void visit(WhereClauseItem& item) {}\n   virtual void visit (HIR::LifetimeWhereClauseItem &item) {}\n   virtual void visit (HIR::TypeBoundWhereClauseItem &item) {}\n-  virtual void visit (HIR::Method &method) {}\n   virtual void visit (HIR::ModuleBodied &module) {}\n   virtual void visit (HIR::ModuleNoBody &module) {}\n   virtual void visit (HIR::ExternCrate &crate) {}"}, {"sha": "83af5deab178a646fc0ccde6fa6ef0ff7b121f54", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 38, "deletions": 202, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -135,212 +135,48 @@ class CompileInherentImplItem : public HIRCompileBase\n     TyTy::BaseType *tyret = fntype->get_return_type ();\n     std::vector<Bvariable *> param_vars;\n \n-    size_t i = 0;\n-    for (auto &it : fntype->get_params ())\n+    if (function.is_method ())\n       {\n-\tHIR::FunctionParam &referenced_param\n-\t  = function.get_function_params ().at (i);\n-\tauto param_tyty = it.second;\n-\tauto compiled_param_type\n-\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n-\n-\tLocation param_locus\n-\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n-\tBvariable *compiled_param_var\n-\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n-\t\t\t\t     compiled_param_type, param_locus);\n-\tif (compiled_param_var == nullptr)\n+\t// insert self\n+\tTyTy::BaseType *self_tyty_lookup = nullptr;\n+\tif (!ctx->get_tyctx ()->lookup_type (\n+\t      function.get_self_param ().get_mappings ().get_hirid (),\n+\t      &self_tyty_lookup))\n \t  {\n-\t    rust_error_at (param_locus, \"failed to compile parameter variable\");\n+\t    rust_error_at (function.get_self_param ().get_locus (),\n+\t\t\t   \"failed to lookup self param type\");\n \t    return;\n \t  }\n \n-\tparam_vars.push_back (compiled_param_var);\n-\n-\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n-\t\t\t      compiled_param_var);\n-\ti++;\n-      }\n-\n-    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to setup parameter variables\");\n-\treturn;\n-      }\n-\n-    // lookup locals\n-    auto block_expr = function.get_definition ().get ();\n-    auto body_mappings = block_expr->get_mappings ();\n-\n-    Resolver::Rib *rib = nullptr;\n-    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n-\t\t\t\t\t      &rib))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to setup locals per block\");\n-\treturn;\n-      }\n-\n-    std::vector<Bvariable *> locals;\n-    bool ok = compile_locals_for_block (*rib, fndecl, locals);\n-    rust_assert (ok);\n-\n-    Bblock *enclosing_scope = NULL;\n-    HIR::BlockExpr *function_body = function.get_definition ().get ();\n-    Location start_location = function_body->get_locus ();\n-    Location end_location = function_body->get_closing_locus ();\n-\n-    Bblock *code_block\n-      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t    start_location, end_location);\n-    ctx->push_block (code_block);\n-\n-    Bvariable *return_address = nullptr;\n-    if (function.has_function_return_type ())\n-      {\n-\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n-\n-\tbool address_is_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n-\n-\treturn_address = ctx->get_backend ()->temporary_variable (\n-\t  fndecl, code_block, return_type, NULL, address_is_taken,\n-\t  function.get_locus (), &ret_var_stmt);\n-\n-\tctx->add_statement (ret_var_stmt);\n-      }\n-\n-    ctx->push_fn (fndecl, return_address);\n-\n-    compile_function_body (fndecl, function.get_definition (),\n-\t\t\t   function.has_function_return_type ());\n-\n-    ctx->pop_block ();\n-    auto body = ctx->get_backend ()->block_statement (code_block);\n-    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n-      {\n-\trust_error_at (function.get_locus (), \"failed to set body to function\");\n-\treturn;\n-      }\n-\n-    ctx->pop_fn ();\n-\n-    ctx->push_function (fndecl);\n-  }\n-\n-  void visit (HIR::Method &method) override\n-  {\n-    if (!compile_fns)\n-      return;\n-\n-    TyTy::BaseType *fntype_tyty;\n-    if (!ctx->get_tyctx ()->lookup_type (method.get_mappings ().get_hirid (),\n-\t\t\t\t\t &fntype_tyty))\n-      {\n-\trust_fatal_error (method.get_locus (),\n-\t\t\t  \"failed to lookup function type\");\n-\treturn;\n-      }\n-\n-    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// we cant do anything for this only when it is used and a concrete type\n-\t// is given\n-\tif (concrete == nullptr)\n-\t  return;\n-\telse\n+\tBtype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+\tif (self_type == nullptr)\n \t  {\n-\t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n-\t    fntype = static_cast<TyTy::FnType *> (concrete);\n+\t    rust_error_at (function.get_self_param ().get_locus (),\n+\t\t\t   \"failed to compile self param type\");\n+\t    return;\n \t  }\n-      }\n \n-    // items can be forward compiled which means we may not need to invoke this\n-    // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n+\tBvariable *compiled_self_param\n+\t  = CompileSelfParam::compile (ctx, fndecl, function.get_self_param (),\n+\t\t\t\t       self_type,\n+\t\t\t\t       function.get_self_param ().get_locus ());\n+\tif (compiled_self_param == nullptr)\n \t  {\n-\t    Bfunction *dummy = nullptr;\n-\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n-\n+\t    rust_error_at (function.get_self_param ().get_locus (),\n+\t\t\t   \"failed to compile self param variable\");\n \t    return;\n \t  }\n-      }\n-\n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// override the Hir Lookups for the substituions in this context\n-\tfntype->override_context ();\n-      }\n-\n-    // convert to the actual function type\n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n-\n-    unsigned int flags = 0;\n-\n-    // if its the main fn or pub visibility mark its as DECL_PUBLIC\n-    // please see https://github.com/Rust-GCC/gccrs/pull/137\n-    if (method.has_visibility ())\n-      flags |= Backend::function_is_visible;\n-\n-    std::string fn_identifier\n-      = self->get_name () + \"_\" + method.get_method_name ();\n-    std::string asm_name\n-      = ctx->mangle_impl_item (self, fntype, method.get_method_name ());\n-\n-    Bfunction *fndecl\n-      = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n-\t\t\t\t       asm_name, flags, method.get_locus ());\n-    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n-\n-    // setup the params\n-    TyTy::BaseType *tyret = fntype->get_return_type ();\n-    std::vector<Bvariable *> param_vars;\n \n-    // insert self\n-    TyTy::BaseType *self_tyty_lookup = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (\n-\t  method.get_self_param ().get_mappings ().get_hirid (),\n-\t  &self_tyty_lookup))\n-      {\n-\trust_error_at (method.get_self_param ().get_locus (),\n-\t\t       \"failed to lookup self param type\");\n-\treturn;\n-      }\n-\n-    Btype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n-    if (self_type == nullptr)\n-      {\n-\trust_error_at (method.get_self_param ().get_locus (),\n-\t\t       \"failed to compile self param type\");\n-\treturn;\n-      }\n-\n-    Bvariable *compiled_self_param\n-      = CompileSelfParam::compile (ctx, fndecl, method.get_self_param (),\n-\t\t\t\t   self_type,\n-\t\t\t\t   method.get_self_param ().get_locus ());\n-    if (compiled_self_param == nullptr)\n-      {\n-\trust_error_at (method.get_self_param ().get_locus (),\n-\t\t       \"failed to compile self param variable\");\n-\treturn;\n+\tparam_vars.push_back (compiled_self_param);\n+\tctx->insert_var_decl (\n+\t  function.get_self_param ().get_mappings ().get_hirid (),\n+\t  compiled_self_param);\n       }\n \n-    param_vars.push_back (compiled_self_param);\n-    ctx->insert_var_decl (method.get_self_param ().get_mappings ().get_hirid (),\n-\t\t\t  compiled_self_param);\n-\n-    // offset from + 1 for the TyTy::FnType being used\n-    size_t i = 1;\n-    for (auto referenced_param : method.get_function_params ())\n+    // offset from + 1 for the TyTy::FnType being used when this is a method to\n+    // skip over Self on the FnType\n+    size_t i = function.is_method () ? 1 : 0;\n+    for (auto referenced_param : function.get_function_params ())\n       {\n \tauto tyty_param = fntype->param_at (i);\n \tauto param_tyty = tyty_param.second;\n@@ -361,7 +197,7 @@ class CompileInherentImplItem : public HIRCompileBase\n \t\t\t\t     compiled_param_type, param_locus);\n \tif (compiled_param_var == nullptr)\n \t  {\n-\t    rust_error_at (param_locus, \"failed to compile parameter variable\");\n+\t    rust_error_at (param_locus, \"Failed to compile parameter variable\");\n \t    return;\n \t  }\n \n@@ -374,20 +210,20 @@ class CompileInherentImplItem : public HIRCompileBase\n \n     if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n       {\n-\trust_fatal_error (method.get_locus (),\n+\trust_fatal_error (function.get_locus (),\n \t\t\t  \"failed to setup parameter variables\");\n \treturn;\n       }\n \n     // lookup locals\n-    auto block_expr = method.get_function_body ().get ();\n+    auto block_expr = function.get_definition ().get ();\n     auto body_mappings = block_expr->get_mappings ();\n \n     Resolver::Rib *rib = nullptr;\n     if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n \t\t\t\t\t      &rib))\n       {\n-\trust_fatal_error (method.get_locus (),\n+\trust_fatal_error (function.get_locus (),\n \t\t\t  \"failed to setup locals per block\");\n \treturn;\n       }\n@@ -397,7 +233,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     rust_assert (ok);\n \n     Bblock *enclosing_scope = NULL;\n-    HIR::BlockExpr *function_body = method.get_function_body ().get ();\n+    HIR::BlockExpr *function_body = function.get_definition ().get ();\n     Location start_location = function_body->get_locus ();\n     Location end_location = function_body->get_closing_locus ();\n \n@@ -407,7 +243,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     ctx->push_block (code_block);\n \n     Bvariable *return_address = nullptr;\n-    if (method.has_function_return_type ())\n+    if (function.has_function_return_type ())\n       {\n \tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n@@ -416,21 +252,21 @@ class CompileInherentImplItem : public HIRCompileBase\n \n \treturn_address = ctx->get_backend ()->temporary_variable (\n \t  fndecl, code_block, return_type, NULL, address_is_taken,\n-\t  method.get_locus (), &ret_var_stmt);\n+\t  function.get_locus (), &ret_var_stmt);\n \n \tctx->add_statement (ret_var_stmt);\n       }\n \n     ctx->push_fn (fndecl, return_address);\n \n-    compile_function_body (fndecl, method.get_function_body (),\n-\t\t\t   method.has_function_return_type ());\n+    compile_function_body (fndecl, function.get_definition (),\n+\t\t\t   function.has_function_return_type ());\n \n     ctx->pop_block ();\n     auto body = ctx->get_backend ()->block_statement (code_block);\n     if (!ctx->get_backend ()->function_set_body (fndecl, body))\n       {\n-\trust_error_at (method.get_locus (), \"failed to set body to function\");\n+\trust_error_at (function.get_locus (), \"failed to set body to function\");\n \treturn;\n       }\n "}, {"sha": "16c5aa043b4d326209f9d8c47cadea76b97dc6c9", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -142,7 +142,8 @@ class ASTLowerImplItem : public ASTLoweringBase\n \t\t\t   std::move (qualifiers), std::move (generic_params),\n \t\t\t   std::move (function_params), std::move (return_type),\n \t\t\t   std::move (where_clause), std::move (function_body),\n-\t\t\t   std::move (vis), function.get_outer_attrs (), locus);\n+\t\t\t   std::move (vis), function.get_outer_attrs (),\n+\t\t\t   HIR::SelfParam::error (), locus);\n \n     mappings->insert_hir_implitem (mapping.get_crate_num (),\n \t\t\t\t   mapping.get_hirid (), parent_impl_id, fn);\n@@ -217,12 +218,12 @@ class ASTLowerImplItem : public ASTLoweringBase\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n     auto mth\n-      = new HIR::Method (mapping, std::move (method_name),\n-\t\t\t std::move (qualifiers), std::move (generic_params),\n-\t\t\t std::move (self_param), std::move (function_params),\n-\t\t\t std::move (return_type), std::move (where_clause),\n-\t\t\t std::move (method_body), std::move (vis),\n-\t\t\t method.get_outer_attrs (), locus);\n+      = new HIR::Function (mapping, std::move (method_name),\n+\t\t\t   std::move (qualifiers), std::move (generic_params),\n+\t\t\t   std::move (function_params), std::move (return_type),\n+\t\t\t   std::move (where_clause), std::move (method_body),\n+\t\t\t   std::move (vis), method.get_outer_attrs (),\n+\t\t\t   std::move (self_param), locus);\n \n     mappings->insert_hir_implitem (mapping.get_crate_num (),\n \t\t\t\t   mapping.get_hirid (), parent_impl_id, mth);"}, {"sha": "b2a4d5fa9c814c87320e845121890a0a61d2e59b", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -308,7 +308,8 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t   std::move (qualifiers), std::move (generic_params),\n \t\t\t   std::move (function_params), std::move (return_type),\n \t\t\t   std::move (where_clause), std::move (function_body),\n-\t\t\t   std::move (vis), function.get_outer_attrs (), locus);\n+\t\t\t   std::move (vis), function.get_outer_attrs (),\n+\t\t\t   HIR::SelfParam::error (), locus);\n \n     mappings->insert_defid_mapping (mapping.get_defid (), translated);\n     mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),"}, {"sha": "771c3adcf1f86e3ebe7ae995c5496e2e4911212e", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -294,7 +294,8 @@ class ASTLoweringStmt : public ASTLoweringBase\n \t\t\t   std::move (qualifiers), std::move (generic_params),\n \t\t\t   std::move (function_params), std::move (return_type),\n \t\t\t   std::move (where_clause), std::move (function_body),\n-\t\t\t   std::move (vis), function.get_outer_attrs (), locus);\n+\t\t\t   std::move (vis), function.get_outer_attrs (),\n+\t\t\t   HIR::SelfParam::error (), locus);\n \n     mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n \t\t\t       fn);"}, {"sha": "58a110e6359a909981bcd85d45ce6da6ab5036e5", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -160,7 +160,6 @@ struct SelfParam;\n struct FunctionQualifiers;\n struct FunctionParam;\n struct Visibility;\n-class Method;\n class VisItem;\n class Module;\n class ModuleBodied;"}, {"sha": "261b3af672aa5860d56b39e9622ffb4374c0a9e5", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -450,79 +450,6 @@ ImplBlock::as_string () const\n   return str;\n }\n \n-std::string\n-Method::as_string () const\n-{\n-  std::string str (\"Method: \\n \");\n-\n-  str += vis.as_string () + \" \" + qualifiers.as_string ();\n-\n-  str += \" fn \" + method_name;\n-\n-  // generic params\n-  str += \"\\n Generic params: \";\n-  if (generic_params.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &param : generic_params)\n-\t{\n-\t  // DEBUG: null pointer check\n-\t  if (param == nullptr)\n-\t    {\n-\t      rust_debug (\n-\t\t\"something really terrible has gone wrong - null pointer \"\n-\t\t\"generic param in method.\");\n-\t      return \"nullptr_POINTER_MARK\";\n-\t    }\n-\n-\t  str += \"\\n  \" + param->as_string ();\n-\t}\n-    }\n-\n-  str += \"\\n Self param: \" + self_param.as_string ();\n-\n-  str += \"\\n Function params: \";\n-  if (function_params.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &param : function_params)\n-\t{\n-\t  str += \"\\n  \" + param.as_string ();\n-\t}\n-    }\n-\n-  str += \"\\n Return type: \";\n-  if (has_return_type ())\n-    {\n-      str += return_type->as_string ();\n-    }\n-  else\n-    {\n-      str += \"none (void)\";\n-    }\n-\n-  str += \"\\n Where clause: \";\n-  if (has_where_clause ())\n-    {\n-      str += where_clause.as_string ();\n-    }\n-  else\n-    {\n-      str += \"none\";\n-    }\n-\n-  str += \"\\n Block expr (body): \\n  \";\n-  str += function_body->as_string ();\n-\n-  return str;\n-}\n-\n std::string\n StructStruct::as_string () const\n {\n@@ -4360,12 +4287,6 @@ TypeBoundWhereClauseItem::accept_vis (HIRVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-Method::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n ModuleBodied::accept_vis (HIRVisitor &vis)\n {"}, {"sha": "a5069b7f044a8d3674a8b688a33f6b44c421fd34", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 16, "deletions": 213, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -592,192 +592,6 @@ struct Visibility\n   }\n };\n \n-// A method (function belonging to a type)\n-class Method : public ImplItem\n-{\n-  Analysis::NodeMapping mappings;\n-\n-  // moved from impl items for consistency\n-  AST::AttrVec outer_attrs;\n-  Visibility vis;\n-\n-  FunctionQualifiers qualifiers;\n-  Identifier method_name;\n-\n-  // bool has_generics;\n-  // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n-\n-  SelfParam self_param;\n-\n-  // bool has_params;\n-  // FunctionParams function_params;\n-  std::vector<FunctionParam> function_params; // inlined\n-\n-  // bool has_return_type;\n-  // FunctionReturnType return_type;\n-  std::unique_ptr<Type> return_type; // inlined\n-\n-  // bool has_where_clause;\n-  WhereClause where_clause;\n-\n-  std::unique_ptr<BlockExpr> function_body;\n-\n-  Location locus;\n-\n-public:\n-  // Returns whether the method has generic parameters.\n-  bool has_generics () const { return !generic_params.empty (); }\n-\n-  // Returns whether the method has parameters.\n-  bool has_params () const { return !function_params.empty (); }\n-\n-  // Returns whether the method has a return type (void otherwise).\n-  bool has_return_type () const { return return_type != nullptr; }\n-\n-  // Returns whether the where clause exists (i.e. has items)\n-  bool has_where_clause () const { return !where_clause.is_empty (); }\n-\n-  // Returns whether method has a non-default visibility.\n-  bool has_visibility () const { return !vis.is_error (); }\n-\n-  // Mega-constructor with all possible fields\n-  Method (Analysis::NodeMapping mappings, Identifier method_name,\n-\t  FunctionQualifiers qualifiers,\n-\t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n-\t  SelfParam self_param, std::vector<FunctionParam> function_params,\n-\t  std::unique_ptr<Type> return_type, WhereClause where_clause,\n-\t  std::unique_ptr<BlockExpr> function_body, Visibility vis,\n-\t  AST::AttrVec outer_attrs, Location locus = Location ())\n-    : mappings (mappings), outer_attrs (std::move (outer_attrs)),\n-      vis (std::move (vis)), qualifiers (std::move (qualifiers)),\n-      method_name (std::move (method_name)),\n-      generic_params (std::move (generic_params)),\n-      self_param (std::move (self_param)),\n-      function_params (std::move (function_params)),\n-      return_type (std::move (return_type)),\n-      where_clause (std::move (where_clause)),\n-      function_body (std::move (function_body)), locus (locus)\n-  {}\n-\n-  // TODO: add constructor with less fields\n-\n-  // Copy constructor with clone\n-  Method (Method const &other)\n-    : mappings (other.mappings), outer_attrs (other.outer_attrs),\n-      vis (other.vis), qualifiers (other.qualifiers),\n-      method_name (other.method_name), self_param (other.self_param),\n-      function_params (other.function_params),\n-      return_type (other.return_type->clone_type ()),\n-      where_clause (other.where_clause),\n-      function_body (other.function_body->clone_block_expr ()),\n-      locus (other.locus)\n-  {\n-    generic_params.reserve (other.generic_params.size ());\n-    for (const auto &e : other.generic_params)\n-      generic_params.push_back (e->clone_generic_param ());\n-  }\n-\n-  // Overloaded assignment operator to clone\n-  Method &operator= (Method const &other)\n-  {\n-    mappings = other.mappings;\n-    method_name = other.method_name;\n-    outer_attrs = other.outer_attrs;\n-    vis = other.vis;\n-    qualifiers = other.qualifiers;\n-    self_param = other.self_param;\n-    function_params = other.function_params;\n-    return_type = other.return_type->clone_type ();\n-    where_clause = other.where_clause;\n-    function_body = other.function_body->clone_block_expr ();\n-    locus = other.locus;\n-\n-    generic_params.reserve (other.generic_params.size ());\n-    for (const auto &e : other.generic_params)\n-      generic_params.push_back (e->clone_generic_param ());\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  Method (Method &&other) = default;\n-  Method &operator= (Method &&other) = default;\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  Analysis::NodeMapping get_mappings () const { return mappings; };\n-\n-  Analysis::NodeMapping get_impl_mappings () const override\n-  {\n-    return get_mappings ();\n-  };\n-\n-  // Returns whether function has return type - if not, it is void.\n-  bool has_function_return_type () const { return return_type != nullptr; }\n-\n-  std::vector<FunctionParam> &get_function_params () { return function_params; }\n-  const std::vector<FunctionParam> &get_function_params () const\n-  {\n-    return function_params;\n-  }\n-\n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n-  {\n-    return generic_params;\n-  }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n-  {\n-    return generic_params;\n-  }\n-\n-  // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_definition ()\n-  {\n-    rust_assert (function_body != nullptr);\n-    return function_body;\n-  }\n-\n-  SelfParam &get_self_param () { return self_param; }\n-  const SelfParam &get_self_param () const { return self_param; }\n-\n-  // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_return_type ()\n-  {\n-    rust_assert (has_return_type ());\n-    return return_type;\n-  }\n-\n-  // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n-\n-  Identifier get_method_name () const { return method_name; }\n-\n-  Location get_locus () const { return locus; }\n-\n-  Location get_impl_locus () const final { return get_locus (); }\n-\n-  std::unique_ptr<BlockExpr> &get_function_body () { return function_body; }\n-  const std::unique_ptr<BlockExpr> &get_function_body () const\n-  {\n-    return function_body;\n-  }\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  Method *clone_inherent_impl_item_impl () const override\n-  {\n-    return new Method (*this);\n-  }\n-};\n-\n // Item that supports visibility - abstract base class\n class VisItem : public Item\n {\n@@ -1267,35 +1081,19 @@ class UseDeclaration : public VisItem\n   }*/\n };\n \n-// Parameters used in a function - TODO inline?\n-/*struct FunctionParams {\n-    std::vector<FunctionParam> function_params;\n-};*/\n-\n class LetStmt;\n \n // Rust function declaration HIR node\n class Function : public VisItem, public ImplItem\n {\n   FunctionQualifiers qualifiers;\n   Identifier function_name;\n-\n-  // bool has_generics;\n-  // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n-\n-  // bool has_function_params;\n-  // FunctionParams function_params;\n-  std::vector<FunctionParam> function_params; // inlined\n-\n-  // bool has_function_return_type;\n+  std::vector<std::unique_ptr<GenericParam> > generic_params;\n+  std::vector<FunctionParam> function_params;\n   std::unique_ptr<Type> return_type;\n-\n-  // bool has_where_clause;\n   WhereClause where_clause;\n-\n   std::unique_ptr<BlockExpr> function_body;\n-\n+  SelfParam self;\n   Location locus;\n \n public:\n@@ -1320,19 +1118,18 @@ class Function : public VisItem, public ImplItem\n \t    std::vector<FunctionParam> function_params,\n \t    std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t    std::unique_ptr<BlockExpr> function_body, Visibility vis,\n-\t    AST::AttrVec outer_attrs, Location locus)\n+\t    AST::AttrVec outer_attrs, SelfParam self, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       qualifiers (std::move (qualifiers)),\n       function_name (std::move (function_name)),\n       generic_params (std::move (generic_params)),\n       function_params (std::move (function_params)),\n       return_type (std::move (return_type)),\n       where_clause (std::move (where_clause)),\n-      function_body (std::move (function_body)), locus (locus)\n+      function_body (std::move (function_body)), self (std::move (self)),\n+      locus (locus)\n   {}\n \n-  // TODO: add constructor with less fields\n-\n   // Copy constructor with clone\n   Function (Function const &other)\n     : VisItem (other), qualifiers (other.qualifiers),\n@@ -1341,7 +1138,7 @@ class Function : public VisItem, public ImplItem\n       return_type (other.return_type->clone_type ()),\n       where_clause (other.where_clause),\n       function_body (other.function_body->clone_block_expr ()),\n-      locus (other.locus)\n+      self (other.self), locus (other.locus)\n   {\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n@@ -1354,14 +1151,12 @@ class Function : public VisItem, public ImplItem\n     VisItem::operator= (other);\n     function_name = other.function_name;\n     qualifiers = other.qualifiers;\n-    // generic_params = other.generic_params;\n     function_params = other.function_params;\n     return_type = other.return_type->clone_type ();\n     where_clause = other.where_clause;\n     function_body = other.function_body->clone_block_expr ();\n-    // visibility = other.visibility->clone_visibility();\n-    // outer_attrs = other.outer_attrs;\n     locus = other.locus;\n+    self = other.self;\n \n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n@@ -1427,6 +1222,14 @@ class Function : public VisItem, public ImplItem\n     return return_type;\n   }\n \n+  bool is_method () const { return !self.is_error (); }\n+\n+  SelfParam &get_self_param ()\n+  {\n+    rust_assert (is_method ());\n+    return self;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "8204a4196fd095dc781562846afc08e02ea7767c", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -102,7 +102,6 @@ class HIRVisitor\n   virtual void visit (TypeParam &param) = 0;\n   virtual void visit (LifetimeWhereClauseItem &item) = 0;\n   virtual void visit (TypeBoundWhereClauseItem &item) = 0;\n-  virtual void visit (Method &method) = 0;\n   virtual void visit (ModuleBodied &module) = 0;\n   virtual void visit (ModuleNoBody &module) = 0;\n   virtual void visit (ExternCrate &crate) = 0;"}, {"sha": "661dfe9e5e8d0b56659f883e3e70f2ba08ec78f7", "filename": "gcc/rust/lint/rust-lint-marklive-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -117,7 +117,6 @@ class MarkLiveBase : public HIR::HIRVisitor\n \n   virtual void visit (HIR::LifetimeWhereClauseItem &) override {}\n   virtual void visit (HIR::TypeBoundWhereClauseItem &) override {}\n-  virtual void visit (HIR::Method &) override {}\n   virtual void visit (HIR::ModuleBodied &) override {}\n   virtual void visit (HIR::ModuleNoBody &) override {}\n   virtual void visit (HIR::ExternCrate &) override {}"}, {"sha": "2db52940b589a2ec5854d84040b1ea595f09e257", "filename": "gcc/rust/lint/rust-lint-marklive.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -175,11 +175,6 @@ class MarkLive : public MarkLiveBase\n     expr.visit_rhs (*this);\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    method.get_definition ().get ()->accept_vis (*this);\n-  }\n-\n   void visit (HIR::TraitItemFunc &item) override\n   {\n     item.get_block_expr ()->accept_vis (*this);"}, {"sha": "5a59e706ec42b64bc8b7b4bf3fe835f6c04fa531", "filename": "gcc/rust/typecheck/rust-hir-const-fold-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -120,7 +120,6 @@ class ConstFoldBase : public HIR::HIRVisitor\n \n   virtual void visit (HIR::LifetimeWhereClauseItem &) override {}\n   virtual void visit (HIR::TypeBoundWhereClauseItem &) override {}\n-  virtual void visit (HIR::Method &) override {}\n   virtual void visit (HIR::ModuleBodied &) override {}\n   virtual void visit (HIR::ModuleNoBody &) override {}\n   virtual void visit (HIR::ExternCrate &) override {}"}, {"sha": "47894b1b3542d138332c77667e98fdec4f16e1e5", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -37,12 +37,6 @@ class ImplItemToName : public TypeCheckBase\n     return resolver.ok;\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    ok = true;\n-    result.assign (method.get_method_name ());\n-  }\n-\n   void visit (HIR::Function &function) override\n   {\n     ok = true;\n@@ -88,12 +82,6 @@ class GetLocusFromImplItem : public TypeCheckBase\n     locus = function.get_locus ();\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    ok = true;\n-    locus = method.get_locus ();\n-  }\n-\n private:\n   GetLocusFromImplItem (Location &locus)\n     : TypeCheckBase (), ok (false), locus (locus)"}, {"sha": "0e26778d64c17a9f3390199d3dcc886ed528bbe6", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -95,21 +95,6 @@ class PathProbeType : public TypeCheckBase\n       }\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    Identifier name = method.get_method_name ();\n-    if (search.as_string ().compare (name) == 0)\n-      {\n-\tHirId tyid = method.get_mappings ().get_hirid ();\n-\tTyTy::BaseType *ty = nullptr;\n-\tbool ok = context->lookup_type (tyid, &ty);\n-\trust_assert (ok);\n-\n-\tPathProbeCandidate candidate{&method, ty};\n-\tcandidates.push_back (std::move (candidate));\n-      }\n-  }\n-\n private:\n   PathProbeType (TyTy::BaseType *receiver, const HIR::PathIdentSegment &query)\n     : TypeCheckBase (), receiver (receiver), search (query)\n@@ -147,11 +132,6 @@ class ReportMultipleCandidateError : private TypeCheckBase\n     r.add_range (function.get_locus ());\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    r.add_range (method.get_locus ());\n-  }\n-\n private:\n   ReportMultipleCandidateError (RichLocation &r) : TypeCheckBase (), r (r) {}\n "}, {"sha": "6d926f7ca03112c9dab66ff495e0b5fdc8af93a6", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -162,9 +162,9 @@ class ResolveTraitItemToRef : public TypeCheckBase\n \t  }\n \n \tty = new TyTy::FnType (fn.get_mappings ().get_hirid (),\n-\t\t\t       function.get_function_name (), false,\n-\t\t\t       std::move (params), ret_type,\n-\t\t\t       std::move (substitutions));\n+\t\t\t       function.get_function_name (),\n+\t\t\t       function.is_method (), std::move (params),\n+\t\t\t       ret_type, std::move (substitutions));\n \tcontext->insert_type (fn.get_mappings (), ty);\n       }\n "}, {"sha": "ae71611d9535b64daf7ded5969144e7ab8ce892e", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -119,7 +119,6 @@ class TypeCheckBase : public HIR::HIRVisitor\n \n   virtual void visit (HIR::LifetimeWhereClauseItem &) override {}\n   virtual void visit (HIR::TypeBoundWhereClauseItem &) override {}\n-  virtual void visit (HIR::Method &) override {}\n   virtual void visit (HIR::ModuleBodied &) override {}\n   virtual void visit (HIR::ModuleNoBody &) override {}\n   virtual void visit (HIR::ExternCrate &) override {}"}, {"sha": "d16158654b8acca3ca31ec81b4edefaa1748af74", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 17, "deletions": 182, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -100,87 +100,22 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n       }\n \n     std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n-    for (auto &param : function.get_function_params ())\n+    if (function.is_method ())\n       {\n-\t// get the name as well required for later on\n-\tauto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+\t// add the synthetic self param at the front, this is a placeholder for\n+\t// compilation to know parameter names. The types are ignored but we\n+\t// reuse the HIR identifier pattern which requires it\n+\tHIR::SelfParam &self_param = function.get_self_param ();\n+\tHIR::IdentifierPattern *self_pattern = new HIR::IdentifierPattern (\n+\t  \"self\", self_param.get_locus (), self_param.is_ref (),\n+\t  self_param.is_mut (), std::unique_ptr<HIR::Pattern> (nullptr));\n+\tcontext->insert_type (self_param.get_mappings (), self->clone ());\n \tparams.push_back (\n-\t  std::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n-\t\t\t\t\t\t       param_tyty));\n-\n-\tcontext->insert_type (param.get_mappings (), param_tyty);\n-      }\n-\n-    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    function.get_function_name (), false,\n-\t\t\t\t    std::move (params), ret_type,\n-\t\t\t\t    std::move (substitutions));\n-    context->insert_type (function.get_mappings (), fnType);\n-  }\n-\n-  void visit (HIR::Method &method) override\n-  {\n-    if (method.has_generics ())\n-      {\n-\tfor (auto &generic_param : method.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n+\t  std::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n+\t\t\t\t\t\t       self->clone ()));\n       }\n \n-    TyTy::BaseType *ret_type = nullptr;\n-    if (!method.has_function_return_type ())\n-      ret_type = new TyTy::TupleType (method.get_mappings ().get_hirid ());\n-    else\n-      {\n-\tauto resolved\n-\t  = TypeCheckType::Resolve (method.get_return_type ().get ());\n-\tif (resolved == nullptr)\n-\t  {\n-\t    rust_error_at (method.get_locus (),\n-\t\t\t   \"failed to resolve return type\");\n-\t    return;\n-\t  }\n-\n-\tret_type = resolved->clone ();\n-\tret_type->set_ref (\n-\t  method.get_return_type ()->get_mappings ().get_hirid ());\n-      }\n-\n-    // hold all the params to the fndef\n-    std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n-\n-    // add the synthetic self param at the front, this is a placeholder for\n-    // compilation to know parameter names. The types are ignored but we reuse\n-    // the HIR identifier pattern which requires it\n-    HIR::SelfParam &self_param = method.get_self_param ();\n-    HIR::IdentifierPattern *self_pattern\n-      = new HIR::IdentifierPattern (\"self\", self_param.get_locus (),\n-\t\t\t\t    self_param.is_ref (), self_param.is_mut (),\n-\t\t\t\t    std::unique_ptr<HIR::Pattern> (nullptr));\n-    context->insert_type (self_param.get_mappings (), self->clone ());\n-    params.push_back (\n-      std::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n-\t\t\t\t\t\t   self->clone ()));\n-\n-    for (auto &param : method.get_function_params ())\n+    for (auto &param : function.get_function_params ())\n       {\n \t// get the name as well required for later on\n \tauto param_tyty = TypeCheckType::Resolve (param.get_type ());\n@@ -191,11 +126,11 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \tcontext->insert_type (param.get_mappings (), param_tyty);\n       }\n \n-    auto fnType\n-      = new TyTy::FnType (method.get_mappings ().get_hirid (),\n-\t\t\t  method.get_method_name (), true, std::move (params),\n-\t\t\t  ret_type, std::move (substitutions));\n-    context->insert_type (method.get_mappings (), fnType);\n+    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t    function.get_function_name (),\n+\t\t\t\t    function.is_method (), std::move (params),\n+\t\t\t\t    ret_type, std::move (substitutions));\n+    context->insert_type (function.get_mappings (), fnType);\n   }\n \n private:\n@@ -249,36 +184,6 @@ class TypeCheckImplItem : public TypeCheckBase\n     expected_ret_tyty->unify (block_expr_ty);\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (method.get_mappings ().get_hirid (), &lookup))\n-      {\n-\trust_error_at (method.get_locus (), \"failed to lookup function type\");\n-\treturn;\n-      }\n-\n-    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n-      {\n-\trust_error_at (method.get_locus (),\n-\t\t       \"found invalid type for function [%s]\",\n-\t\t       lookup->as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    // need to get the return type from this\n-    TyTy::FnType *resolve_fn_type = (TyTy::FnType *) lookup;\n-    auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n-    context->push_return_type (expected_ret_tyty);\n-\n-    auto block_expr_ty\n-      = TypeCheckExpr::Resolve (method.get_definition ().get (), false);\n-\n-    context->pop_return_type ();\n-\n-    expected_ret_tyty->unify (block_expr_ty);\n-  }\n-\n protected:\n   TypeCheckImplItem (TyTy::BaseType *self) : TypeCheckBase (), self (self) {}\n \n@@ -303,76 +208,6 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n   void visit (HIR::TypeAlias &type) override { gcc_unreachable (); }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    TypeCheckImplItem::visit (method);\n-\n-    // we get the error checking from the base method here\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (method.get_mappings ().get_hirid (), &lookup))\n-      return;\n-\n-    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n-      return;\n-\n-    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n-    const TraitItemReference &trait_item_ref\n-      = trait_reference.lookup_trait_item (\n-\tfntype->get_identifier (), TraitItemReference::TraitItemType::FN);\n-\n-    // unknown trait item\n-    if (trait_item_ref.is_error ())\n-      {\n-\tRichLocation r (method.get_locus ());\n-\tr.add_range (trait_reference.get_locus ());\n-\trust_error_at (r, \"method %<%s%> is not a member of trait %<%s%>\",\n-\t\t       fntype->get_identifier ().c_str (),\n-\t\t       trait_reference.get_name ().c_str ());\n-\treturn;\n-      }\n-\n-    rust_assert (trait_item_ref.get_tyty ()->get_kind ()\n-\t\t == TyTy::TypeKind::FNDEF);\n-    TyTy::FnType *trait_item_fntype\n-      = static_cast<TyTy::FnType *> (trait_item_ref.get_tyty ());\n-\n-    // sets substitute self into the trait_item_ref->tyty\n-    TyTy::SubstitutionParamMapping *self_mapping = nullptr;\n-    for (auto &param_mapping : trait_item_fntype->get_substs ())\n-      {\n-\tconst HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n-\tif (type_param.get_type_representation ().compare (\"Self\") == 0)\n-\t  {\n-\t    self_mapping = &param_mapping;\n-\t    break;\n-\t  }\n-      }\n-    rust_assert (self_mapping != nullptr);\n-\n-    std::vector<TyTy::SubstitutionArg> mappings;\n-    mappings.push_back (TyTy::SubstitutionArg (self_mapping, self));\n-\n-    TyTy::SubstitutionArgumentMappings implicit_self_substs (\n-      mappings, method.get_locus ());\n-    trait_item_fntype\n-      = trait_item_fntype->handle_substitions (implicit_self_substs);\n-\n-    // check the types are compatible\n-    if (!trait_item_fntype->can_eq (fntype))\n-      {\n-\tRichLocation r (method.get_locus ());\n-\tr.add_range (trait_item_ref.get_locus ());\n-\n-\trust_error_at (\n-\t  r, \"method %<%s%> has an incompatible type for trait %<%s%>\",\n-\t  fntype->get_identifier ().c_str (),\n-\t  trait_reference.get_name ().c_str ());\n-\treturn;\n-      }\n-\n-    resolved_trait_item = trait_item_ref;\n-  }\n-\n   void visit (HIR::Function &function) override\n   {\n     TypeCheckImplItem::visit (function);"}, {"sha": "b80372b2a9c1d4a7b82bea06a515f7bc9ed0eb23", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4505e162d069ca58ce43d62770b81cb36137c0/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=5e4505e162d069ca58ce43d62770b81cb36137c0", "patch": "@@ -84,18 +84,6 @@ class TypeResolverDump : public TypeCheckBase\n     dump += indent () + \"}\\n\";\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    dump += indent () + \"fn \" + method.get_method_name () + \" \"\n-\t    + type_string (method.get_mappings ()) + \"\\n\";\n-    dump += indent () + \"{\\n\";\n-\n-    HIR::BlockExpr *function_body = method.get_function_body ().get ();\n-    function_body->accept_vis (*this);\n-\n-    dump += indent () + \"}\\n\";\n-  }\n-\n   void visit (HIR::BlockExpr &expr) override\n   {\n     indentation_level++;"}]}