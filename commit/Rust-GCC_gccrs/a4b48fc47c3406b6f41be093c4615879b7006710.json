{"sha": "a4b48fc47c3406b6f41be093c4615879b7006710", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRiNDhmYzQ3YzM0MDZiNmY0MWJlMDkzYzQ2MTU4NzliNzAwNjcxMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-18T14:05:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-19T05:59:51Z"}, "message": "cost invariant nodes from vect_slp_analyze_node_operations SLP walk\n\n2020-05-19  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_slp_tree::vectype): Add field.\n\t(SLP_TREE_VECTYPE): New.\n\t* tree-vect-slp.c (vect_create_new_slp_node): Initialize\n\tSLP_TREE_VECTYPE.\n\t(vect_create_new_slp_node): Likewise.\n\t(vect_prologue_cost_for_slp): Move here from tree-vect-stmts.c\n\tand simplify.\n\t(vect_slp_analyze_node_operations): Walk nodes children for\n\tinvariant costing.\n\t(vect_get_constant_vectors): Use local scope op variable.\n\t* tree-vect-stmts.c (vect_prologue_cost_for_slp_op): Remove here.\n\t(vect_model_simple_cost): Adjust.\n\t(vect_model_store_cost): Likewise.\n\t(vectorizable_store): Likewise.", "tree": {"sha": "09caa8ff7272487ac96d1da0ef0b63c150f2efab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09caa8ff7272487ac96d1da0ef0b63c150f2efab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4b48fc47c3406b6f41be093c4615879b7006710", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4b48fc47c3406b6f41be093c4615879b7006710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4b48fc47c3406b6f41be093c4615879b7006710", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4b48fc47c3406b6f41be093c4615879b7006710/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "573e5f0500968dcf4025b8fc0ae5fb367f9c70d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/573e5f0500968dcf4025b8fc0ae5fb367f9c70d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/573e5f0500968dcf4025b8fc0ae5fb367f9c70d9"}], "stats": {"total": 196, "additions": 107, "deletions": 89}, "files": [{"sha": "56c056f9226b212041fed44d795b423845efe6fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b48fc47c3406b6f41be093c4615879b7006710/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b48fc47c3406b6f41be093c4615879b7006710/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4b48fc47c3406b6f41be093c4615879b7006710", "patch": "@@ -1,3 +1,20 @@\n+2020-05-19  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (_slp_tree::vectype): Add field.\n+\t(SLP_TREE_VECTYPE): New.\n+\t* tree-vect-slp.c (vect_create_new_slp_node): Initialize\n+\tSLP_TREE_VECTYPE.\n+\t(vect_create_new_slp_node): Likewise.\n+\t(vect_prologue_cost_for_slp): Move here from tree-vect-stmts.c\n+\tand simplify.\n+\t(vect_slp_analyze_node_operations): Walk nodes children for\n+\tinvariant costing.\n+\t(vect_get_constant_vectors): Use local scope op variable.\n+\t* tree-vect-stmts.c (vect_prologue_cost_for_slp_op): Remove here.\n+\t(vect_model_simple_cost): Adjust.\n+\t(vect_model_store_cost): Likewise.\n+\t(vectorizable_store): Likewise.\n+\n 2020-05-18  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/92815"}, {"sha": "69a2002717f2eb3e9d82a5711d3f8120d54cc35f", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b48fc47c3406b6f41be093c4615879b7006710/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b48fc47c3406b6f41be093c4615879b7006710/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=a4b48fc47c3406b6f41be093c4615879b7006710", "patch": "@@ -129,6 +129,7 @@ vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts)\n   SLP_TREE_LOAD_PERMUTATION (node) = vNULL;\n   SLP_TREE_TWO_OPERATORS (node) = false;\n   SLP_TREE_DEF_TYPE (node) = vect_internal_def;\n+  SLP_TREE_VECTYPE (node) = NULL_TREE;\n   node->refcnt = 1;\n   node->max_nunits = 1;\n \n@@ -155,6 +156,7 @@ vect_create_new_slp_node (vec<tree> ops)\n   SLP_TREE_LOAD_PERMUTATION (node) = vNULL;\n   SLP_TREE_TWO_OPERATORS (node) = false;\n   SLP_TREE_DEF_TYPE (node) = vect_external_def;\n+  SLP_TREE_VECTYPE (node) = NULL_TREE;\n   node->refcnt = 1;\n   node->max_nunits = 1;\n \n@@ -2720,6 +2722,66 @@ vect_slp_convert_to_external (vec_info *vinfo, slp_tree node,\n   return true;\n }\n \n+/* Compute the prologue cost for invariant or constant operands represented\n+   by NODE.  */\n+\n+static void\n+vect_prologue_cost_for_slp (vec_info *vinfo,\n+\t\t\t    slp_tree node,\n+\t\t\t    stmt_vector_for_cost *cost_vec)\n+{\n+  /* Without looking at the actual initializer a vector of\n+     constants can be implemented as load from the constant pool.\n+     When all elements are the same we can use a splat.  */\n+  tree vectype = SLP_TREE_VECTYPE (node);\n+  /* ???  Ideally we'd want all invariant nodes to have a vectype.  */\n+  if (!vectype)\n+    vectype = get_vectype_for_scalar_type (vinfo,\n+\t\t\t\t\t   TREE_TYPE (SLP_TREE_SCALAR_OPS\n+\t\t\t\t\t\t\t      (node)[0]), node);\n+  unsigned group_size = SLP_TREE_SCALAR_OPS (node).length ();\n+  unsigned num_vects_to_check;\n+  unsigned HOST_WIDE_INT const_nunits;\n+  unsigned nelt_limit;\n+  if (TYPE_VECTOR_SUBPARTS (vectype).is_constant (&const_nunits)\n+      && ! multiple_p (const_nunits, group_size))\n+    {\n+      num_vects_to_check = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n+      nelt_limit = const_nunits;\n+    }\n+  else\n+    {\n+      /* If either the vector has variable length or the vectors\n+\t are composed of repeated whole groups we only need to\n+\t cost construction once.  All vectors will be the same.  */\n+      num_vects_to_check = 1;\n+      nelt_limit = group_size;\n+    }\n+  tree elt = NULL_TREE;\n+  unsigned nelt = 0;\n+  for (unsigned j = 0; j < num_vects_to_check * nelt_limit; ++j)\n+    {\n+      unsigned si = j % group_size;\n+      if (nelt == 0)\n+\telt = SLP_TREE_SCALAR_OPS (node)[si];\n+      /* ???  We're just tracking whether all operands of a single\n+\t vector initializer are the same, ideally we'd check if\n+\t we emitted the same one already.  */\n+      else if (elt != SLP_TREE_SCALAR_OPS (node)[si])\n+\telt = NULL_TREE;\n+      nelt++;\n+      if (nelt == nelt_limit)\n+\t{\n+\t  record_stmt_cost (cost_vec, 1,\n+\t\t\t    SLP_TREE_DEF_TYPE (node) == vect_external_def\n+\t\t\t    ? (elt ? scalar_to_vec : vec_construct)\n+\t\t\t    : vector_load,\n+\t\t\t    NULL, vectype, 0, vect_prologue);\n+\t  nelt = 0;\n+\t}\n+    }\n+}\n+\n /* Analyze statements contained in SLP tree NODE after recursively analyzing\n    the subtree.  NODE_INSTANCE contains NODE and VINFO contains INSTANCE.\n \n@@ -2735,6 +2797,7 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n   int i, j;\n   slp_tree child;\n \n+  /* Assume we can code-generate all invariants.  */\n   if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n     return true;\n \n@@ -2798,6 +2861,26 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n     if (SLP_TREE_SCALAR_STMTS (child).length () != 0)\n       STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0]) = dt[j];\n \n+  /* When the node can be vectorized cost invariant nodes it references.\n+     This is not done in DFS order to allow the refering node\n+     vectorizable_* calls to nail down the invariant nodes vector type\n+     and possibly unshare it if it needs a different vector type than\n+     other referrers.  */\n+  if (res)\n+    FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n+      if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n+\t{\n+\t  /* ???  After auditing more code paths make a \"default\"\n+\t     and push the vector type from NODE to all children\n+\t     if it is not already set.  */\n+\t  /* Perform usual caching, note code-generation still\n+\t     code-gens these nodes multiple times but we expect\n+\t     to CSE them later.  */\n+\t  if (!visited.contains (child)\n+\t      && !lvisited.add (child))\n+\t    vect_prologue_cost_for_slp (vinfo, child, cost_vec);\n+\t}\n+\n   /* If this node can't be vectorized, try pruning the tree here rather\n      than felling the whole thing.  */\n   if (!res && vect_slp_convert_to_external (vinfo, node, node_instance))\n@@ -3600,6 +3683,7 @@ vect_get_constant_vectors (vec_info *vinfo,\n   stmt_vec_info insert_after = NULL;\n   for (j = 0; j < number_of_copies; j++)\n     {\n+      tree op;\n       for (i = group_size - 1; op_node->ops.iterate (i, &op); i--)\n         {\n           /* Create 'vect_ = {op0,op1,...,opn}'.  */"}, {"sha": "82750a975aa7d3ba36229fa9b359df69d11a5365", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 4, "deletions": 89, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b48fc47c3406b6f41be093c4615879b7006710/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b48fc47c3406b6f41be093c4615879b7006710/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=a4b48fc47c3406b6f41be093c4615879b7006710", "patch": "@@ -786,76 +786,14 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo, bool *fatal)\n   return opt_result::success ();\n }\n \n-/* Compute the prologue cost for invariant or constant operands.  */\n-\n-static unsigned\n-vect_prologue_cost_for_slp_op (vec_info *vinfo,\n-\t\t\t       slp_tree node,\n-\t\t\t       unsigned opno, enum vect_def_type dt,\n-\t\t\t       stmt_vector_for_cost *cost_vec)\n-{\n-  gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0]->stmt;\n-  tree op = gimple_op (stmt, opno);\n-  unsigned prologue_cost = 0;\n-\n-  /* Without looking at the actual initializer a vector of\n-     constants can be implemented as load from the constant pool.\n-     When all elements are the same we can use a splat.  */\n-  tree vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op), node);\n-  unsigned group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n-  unsigned num_vects_to_check;\n-  unsigned HOST_WIDE_INT const_nunits;\n-  unsigned nelt_limit;\n-  if (TYPE_VECTOR_SUBPARTS (vectype).is_constant (&const_nunits)\n-      && ! multiple_p (const_nunits, group_size))\n-    {\n-      num_vects_to_check = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n-      nelt_limit = const_nunits;\n-    }\n-  else\n-    {\n-      /* If either the vector has variable length or the vectors\n-\t are composed of repeated whole groups we only need to\n-\t cost construction once.  All vectors will be the same.  */\n-      num_vects_to_check = 1;\n-      nelt_limit = group_size;\n-    }\n-  tree elt = NULL_TREE;\n-  unsigned nelt = 0;\n-  for (unsigned j = 0; j < num_vects_to_check * nelt_limit; ++j)\n-    {\n-      unsigned si = j % group_size;\n-      if (nelt == 0)\n-\telt = gimple_op (SLP_TREE_SCALAR_STMTS (node)[si]->stmt, opno);\n-      /* ???  We're just tracking whether all operands of a single\n-\t vector initializer are the same, ideally we'd check if\n-\t we emitted the same one already.  */\n-      else if (elt != gimple_op (SLP_TREE_SCALAR_STMTS (node)[si]->stmt,\n-\t\t\t\t opno))\n-\telt = NULL_TREE;\n-      nelt++;\n-      if (nelt == nelt_limit)\n-\t{\n-\t  prologue_cost += record_stmt_cost\n-\t      (cost_vec, 1,\n-\t       dt == vect_external_def\n-\t       ? (elt ? scalar_to_vec : vec_construct) : vector_load,\n-\t       NULL, vectype, 0, vect_prologue);\n-\t  nelt = 0;\n-\t}\n-    }\n-\n-  return prologue_cost;\n-}\n-\n /* Function vect_model_simple_cost.\n \n    Models cost for simple operations, i.e. those that only emit ncopies of a\n    single op.  Right now, this does not account for multiple insns that could\n    be generated for the single vector op.  We will handle that shortly.  */\n \n static void\n-vect_model_simple_cost (vec_info *vinfo,\n+vect_model_simple_cost (vec_info *,\n \t\t\tstmt_vec_info stmt_info, int ncopies,\n \t\t\tenum vect_def_type *dt,\n \t\t\tint ndts,\n@@ -871,26 +809,7 @@ vect_model_simple_cost (vec_info *vinfo,\n   if (node)\n     ncopies = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n \n-  if (node)\n-    {\n-      /* Scan operands and account for prologue cost of constants/externals.\n-\t ???  This over-estimates cost for multiple uses and should be\n-\t re-engineered.  */\n-      gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0]->stmt;\n-      tree lhs = gimple_get_lhs (stmt);\n-      for (unsigned i = 0; i < gimple_num_ops (stmt); ++i)\n-\t{\n-\t  tree op = gimple_op (stmt, i);\n-\t  enum vect_def_type dt;\n-\t  if (!op || op == lhs)\n-\t    continue;\n-\t  if (vect_is_simple_use (op, vinfo, &dt)\n-\t      && (dt == vect_constant_def || dt == vect_external_def))\n-\t    prologue_cost += vect_prologue_cost_for_slp_op (vinfo, node,\n-\t\t\t\t\t\t\t    i, dt, cost_vec);\n-\t}\n-    }\n-  else\n+  if (!node)\n     /* Cost the \"broadcast\" of a scalar operand in to a vector operand.\n        Use scalar_to_vec to cost the broadcast, as elsewhere in the vector\n        cost model.  */\n@@ -991,7 +910,6 @@ cfun_returns (tree decl)\n \n static void\n vect_model_store_cost (vec_info *vinfo, stmt_vec_info stmt_info, int ncopies,\n-\t\t       enum vect_def_type dt,\n \t\t       vect_memory_access_type memory_access_type,\n \t\t       vec_load_store_type vls_type, slp_tree slp_node,\n \t\t       stmt_vector_for_cost *cost_vec)\n@@ -1006,10 +924,7 @@ vect_model_store_cost (vec_info *vinfo, stmt_vec_info stmt_info, int ncopies,\n \n   if (vls_type == VLS_STORE_INVARIANT)\n     {\n-      if (slp_node)\n-\tprologue_cost += vect_prologue_cost_for_slp_op (vinfo, slp_node,\n-\t\t\t\t\t\t\t1, dt, cost_vec);\n-      else\n+      if (!slp_node)\n \tprologue_cost += record_stmt_cost (cost_vec, 1, scalar_to_vec,\n \t\t\t\t\t   stmt_info, 0, vect_prologue);\n     }\n@@ -7565,7 +7480,7 @@ vectorizable_store (vec_info *vinfo,\n \t\t\t\t  memory_access_type, &gs_info, mask);\n \n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n-      vect_model_store_cost (vinfo, stmt_info, ncopies, rhs_dt,\n+      vect_model_store_cost (vinfo, stmt_info, ncopies,\n \t\t\t     memory_access_type, vls_type, slp_node, cost_vec);\n       return true;\n     }"}, {"sha": "38a0a1d278bef5983fdcf23f3ca29b79d5e0d672", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b48fc47c3406b6f41be093c4615879b7006710/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b48fc47c3406b6f41be093c4615879b7006710/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a4b48fc47c3406b6f41be093c4615879b7006710", "patch": "@@ -130,6 +130,7 @@ struct _slp_tree {\n      permutation.  */\n   vec<unsigned> load_permutation;\n \n+  tree vectype;\n   /* Vectorized stmt/s.  */\n   vec<stmt_vec_info> vec_stmts;\n   /* Number of vector stmts that are created to replace the group of scalar\n@@ -186,6 +187,7 @@ typedef class _slp_instance {\n #define SLP_TREE_LOAD_PERMUTATION(S)             (S)->load_permutation\n #define SLP_TREE_TWO_OPERATORS(S)\t\t (S)->two_operators\n #define SLP_TREE_DEF_TYPE(S)\t\t\t (S)->def_type\n+#define SLP_TREE_VECTYPE(S)\t\t\t (S)->vectype\n \n /* Key for map that records association between\n    scalar conditions and corresponding loop mask, and"}]}