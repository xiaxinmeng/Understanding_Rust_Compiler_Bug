{"sha": "057469588864b2566f89e3a548a80d7517b34c98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU3NDY5NTg4ODY0YjI1NjZmODllM2E1NDhhODBkNzUxN2IzNGM5OA==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2020-06-24T21:22:58Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-16T07:31:18Z"}, "message": "[Ada] GNAT-LLVM unnesting issues in elaboration code\n\ngcc/ada/\n\n\t* exp_ch7.adb (Check_Unnesting_In_Decls_Or_Stmts): In the case\n\tof an if-statement, call Unnest_If_Statement to determine\n\twhether there are nested subprograms in any of the statement\n\tlists of the \"if\" parts that require a wrapping procedure to\n\thandle possible up-level refeferences.\n\t(Unnest_Block): Call Check_Unnesting_In_Handlers to do unnesting\n\tof subprograms in exception handlers of the block statement.\n\t(Unnest_If_Statement): New procedure to traverse the parts of an\n\tif-statement and create wrapper procedures as needed to\n\tencapsulate nested subprograms that may make up-level\n\treferences.\n\t(Check_Stmts_For_Subp_Unnesting): New support procedure in\n\tUnnest_If_Statement to traverse a statement list looking for\n\ttop-level subprogram bodies that require wrapping inside a\n\tprocedure (via Unnest_Statement_List) as well as possibly having\n\tother statements (block, loop, if) that may themselves require\n\tan unnesting transformation (via\n\tCheck_Unnesting_In_Decls_Or_Stmts).\n\t(Unnest_Statement_List): New support procedure to traverse the\n\tstatements of a statement list that contains subprogram bodies\n\tat the top level and replace the statement list with a wrapper\n\tprocedure body encapsulating the statements and a call to the\n\tprocedure.", "tree": {"sha": "fb7e401d915d75f160e107b5f54595e7f00045aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb7e401d915d75f160e107b5f54595e7f00045aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/057469588864b2566f89e3a548a80d7517b34c98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/057469588864b2566f89e3a548a80d7517b34c98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/057469588864b2566f89e3a548a80d7517b34c98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/057469588864b2566f89e3a548a80d7517b34c98/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f238680dd3091f7431f3e1b571ea3c51f8ce2b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f238680dd3091f7431f3e1b571ea3c51f8ce2b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f238680dd3091f7431f3e1b571ea3c51f8ce2b4"}], "stats": {"total": 198, "additions": 198, "deletions": 0}, "files": [{"sha": "6e9266a2b562f35f6f7b3e99f5d6e1ae59151b61", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/057469588864b2566f89e3a548a80d7517b34c98/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/057469588864b2566f89e3a548a80d7517b34c98/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=057469588864b2566f89e3a548a80d7517b34c98", "patch": "@@ -398,6 +398,31 @@ package body Exp_Ch7 is\n    --  actions or secondary-stack management, in which case the nested\n    --  subprogram is a finalizer.\n \n+   procedure Unnest_If_Statement (If_Stmt : Node_Id);\n+   --  The separate statement lists associated with an if-statement (then part,\n+   --  elsif parts, else part) may require unnesting if they directly contain\n+   --  a subprogram body that references up-level objects. Each statement list\n+   --  is traversed to locate such subprogram bodies, and if a part's statement\n+   --  list contains a body, then the list is replaced with a new procedure\n+   --  containing the part's statements followed by a call to the procedure.\n+   --  Furthermore, any nested blocks, loops, or if statements will also be\n+   --  traversed to determine the need for further unnesting transformations.\n+\n+   procedure Unnest_Statement_List (Stmts : in out List_Id);\n+   --  A list of statements that directly contains a subprogram at its outer\n+   --  level, that may reference objects declared in that same statement list,\n+   --  is rewritten as a procedure containing the statement list Stmts (which\n+   --  includes any such objects as well as the nested subprogram), followed by\n+   --  a call to the new procedure, and Stmts becomes the list containing the\n+   --  procedure and the call. This ensures that Unnest_Subprogram will later\n+   --  properly handle up-level references from the nested subprogram to\n+   --  objects declared earlier in statement list, by creating an activation\n+   --  record and passing it to the nested subprogram. This procedure also\n+   --  resets the Scope of objects declared in the statement list, as well as\n+   --  the Scope of the nested subprogram, to refer to the new procedure.\n+   --  Also, the new procedure is marked Has_Nested_Subprogram, so this should\n+   --  only be called when known that the statement list contains a subprogram.\n+\n    procedure Unnest_Loop (Loop_Stmt : Node_Id);\n    --  Top-level Loops that contain nested subprograms with up-level references\n    --  need to have activation records. We do this by rewriting the loop as a\n@@ -4233,6 +4258,17 @@ package body Exp_Ch7 is\n             then\n                Unnest_Block (Decl_Or_Stmt);\n \n+            --  If-statements may contain subprogram bodies at the outer level\n+            --  of their statement lists, and the subprograms may make up-level\n+            --  references (such as to objects declared in the same statement\n+            --  list). Unlike block and loop cases, however, we don't have an\n+            --  entity on which to test the Contains_Subprogram flag, so\n+            --  Unnest_If_Statement must traverse the statement lists to\n+            --  determine whether there are nested subprograms present.\n+\n+            elsif Nkind (Decl_Or_Stmt) = N_If_Statement then\n+               Unnest_If_Statement (Decl_Or_Stmt);\n+\n             elsif Nkind (Decl_Or_Stmt) = N_Loop_Statement then\n                declare\n                   Id : constant Entity_Id :=\n@@ -9261,6 +9297,11 @@ package body Exp_Ch7 is\n           Handled_Statement_Sequence =>\n             Handled_Statement_Sequence (Decl));\n \n+      --  Handlers in the block may contain nested subprograms that require\n+      --  unnesting.\n+\n+      Check_Unnesting_In_Handlers (Local_Body);\n+\n       Rewrite (Decl, Local_Body);\n       Analyze (Decl);\n       Set_Has_Nested_Subprogram (Local_Proc);\n@@ -9288,6 +9329,94 @@ package body Exp_Ch7 is\n       end loop;\n    end Unnest_Block;\n \n+   -------------------------\n+   -- Unnest_If_Statement --\n+   -------------------------\n+\n+   procedure Unnest_If_Statement (If_Stmt : Node_Id) is\n+\n+      procedure Check_Stmts_For_Subp_Unnesting (Stmts : in out List_Id);\n+      --  A list of statements (that may be a list associated with a then,\n+      --  elsif, or else part of an if-statement) is traversed at the top\n+      --  level to determine whether it contains a subprogram body, and if so,\n+      --  the statements will be replaced with a new procedure body containing\n+      --  the statements followed by a call to the procedure. The individual\n+      --  statements may also be blocks, loops, or other if statements that\n+      --  themselves may require contain nested subprograms needing unnesting.\n+\n+      procedure Check_Stmts_For_Subp_Unnesting (Stmts : in out List_Id) is\n+         Subp_Found : Boolean := False;\n+\n+      begin\n+         if Is_Empty_List (Stmts) then\n+            return;\n+         end if;\n+\n+         declare\n+            Stmt : Node_Id := First (Stmts);\n+         begin\n+            while Present (Stmt) loop\n+               if Nkind (Stmt) = N_Subprogram_Body then\n+                  Subp_Found := True;\n+                  exit;\n+               end if;\n+\n+               Next (Stmt);\n+            end loop;\n+         end;\n+\n+         --  The statements themselves may be blocks, loops, etc. that in turn\n+         --  contain nested subprograms requiring an unnesting transformation.\n+         --  We perform this traversal after looking for subprogram bodies, to\n+         --  avoid considering procedures created for one of those statements\n+         --  (such as a block rewritten as a procedure) as a nested subprogram\n+         --  of the statement list (which could result in an unneeded wrapper\n+         --  procedure).\n+\n+         Check_Unnesting_In_Decls_Or_Stmts (Stmts);\n+\n+         --  If there was a top-level subprogram body in the statement list,\n+         --  then perform an unnesting transformation on the list by replacing\n+         --  the statements with a wrapper procedure body containing the\n+         --  original statements followed by a call to that procedure.\n+\n+         if Subp_Found then\n+            Unnest_Statement_List (Stmts);\n+         end if;\n+      end Check_Stmts_For_Subp_Unnesting;\n+\n+      --  Local variables\n+\n+      Then_Stmts : List_Id := Then_Statements (If_Stmt);\n+      Else_Stmts : List_Id := Else_Statements (If_Stmt);\n+\n+   --  Start of processing for Unnest_If_Statement\n+\n+   begin\n+      Check_Stmts_For_Subp_Unnesting (Then_Stmts);\n+      Set_Then_Statements (If_Stmt, Then_Stmts);\n+\n+      if not Is_Empty_List (Elsif_Parts (If_Stmt)) then\n+         declare\n+            Elsif_Part  : Node_Id :=\n+                            First (Elsif_Parts (If_Stmt));\n+            Elsif_Stmts : List_Id;\n+         begin\n+            while Present (Elsif_Part) loop\n+               Elsif_Stmts := Then_Statements (Elsif_Part);\n+\n+               Check_Stmts_For_Subp_Unnesting (Elsif_Stmts);\n+               Set_Then_Statements (Elsif_Part, Elsif_Stmts);\n+\n+               Next (Elsif_Part);\n+            end loop;\n+         end;\n+      end if;\n+\n+      Check_Stmts_For_Subp_Unnesting (Else_Stmts);\n+      Set_Else_Statements (If_Stmt, Else_Stmts);\n+   end Unnest_If_Statement;\n+\n    -----------------\n    -- Unnest_Loop --\n    -----------------\n@@ -9349,6 +9478,75 @@ package body Exp_Ch7 is\n       --  same loop entity that now belongs to the copied loop statement.\n    end Unnest_Loop;\n \n+   ---------------------------\n+   -- Unnest_Statement_List --\n+   ---------------------------\n+\n+   procedure Unnest_Statement_List (Stmts : in out List_Id) is\n+      Loc        : constant Source_Ptr := Sloc (First (Stmts));\n+      Local_Body : Node_Id;\n+      Local_Call : Node_Id;\n+      Local_Proc : Entity_Id;\n+      New_Stmts  : constant List_Id := Empty_List;\n+\n+   begin\n+      Local_Proc :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_Internal_Name ('P'));\n+\n+      Local_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Make_Procedure_Specification (Loc,\n+              Defining_Unit_Name => Local_Proc),\n+          Declarations               => Empty_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => Stmts));\n+\n+      Append_To (New_Stmts, Local_Body);\n+\n+      Analyze (Local_Body);\n+\n+      Set_Has_Nested_Subprogram (Local_Proc);\n+\n+      Local_Call :=\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => New_Occurrence_Of (Local_Proc, Loc));\n+\n+      Append_To (New_Stmts, Local_Call);\n+      Analyze (Local_Call);\n+\n+      --  Traverse the statements, and for any that are declarations or\n+      --  subprogram bodies that have entities, set the Scope of those\n+      --  entities to the new procedure's Entity_Id.\n+\n+      declare\n+         Stmt : Node_Id := First (Stmts);\n+\n+      begin\n+         while Present (Stmt) loop\n+            case Nkind (Stmt) is\n+               when N_Declaration\n+                  | N_Renaming_Declaration\n+               =>\n+                  Set_Scope (Defining_Identifier (Stmt), Local_Proc);\n+\n+               when N_Subprogram_Body =>\n+                  Set_Scope\n+                    (Defining_Unit_Name (Specification (Stmt)), Local_Proc);\n+\n+               when others =>\n+                  null;\n+            end case;\n+\n+            Next (Stmt);\n+         end loop;\n+      end;\n+\n+      Stmts := New_Stmts;\n+   end Unnest_Statement_List;\n+\n    --------------------------------\n    -- Wrap_Transient_Declaration --\n    --------------------------------"}]}