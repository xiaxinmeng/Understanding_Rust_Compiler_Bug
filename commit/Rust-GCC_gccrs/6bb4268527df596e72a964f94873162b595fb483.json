{"sha": "6bb4268527df596e72a964f94873162b595fb483", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJiNDI2ODUyN2RmNTk2ZTcyYTk2NGY5NDg3MzE2MmI1OTVmYjQ4Mw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-12-13T22:52:19Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-12-13T22:52:19Z"}, "message": "extend.texi: Consistently use @code for const and volatile qualifiers...\n\ngcc/ChangeLog:\n\t* doc/extend.texi: Consistently use @code for const and volatile\n\tqualifiers, the true and false constants, and asm statements.\n\nFrom-SVN: r267111", "tree": {"sha": "04ab20c161a22e8925469a62fd3deda8739561a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04ab20c161a22e8925469a62fd3deda8739561a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bb4268527df596e72a964f94873162b595fb483", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bb4268527df596e72a964f94873162b595fb483", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bb4268527df596e72a964f94873162b595fb483", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bb4268527df596e72a964f94873162b595fb483/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11067dee85df4812303ebda57642675a0b89ef67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11067dee85df4812303ebda57642675a0b89ef67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11067dee85df4812303ebda57642675a0b89ef67"}], "stats": {"total": 226, "additions": 125, "deletions": 101}, "files": [{"sha": "98c6fc02dd01531ecf0f8ff57f82c7b022962344", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bb4268527df596e72a964f94873162b595fb483/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bb4268527df596e72a964f94873162b595fb483/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6bb4268527df596e72a964f94873162b595fb483", "patch": "@@ -1,3 +1,8 @@\n+2018-12-13  Martin Sebor  <msebor@redhat.com>\n+\n+\t* doc/extend.texi: Consistently use @code for const and volatile\n+\tqualifiers, the true and false constants, and asm statements.\n+\n 2018-12-13  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/88414"}, {"sha": "3889ecb543191650296884a2ae693091fa3312bf", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 120, "deletions": 101, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bb4268527df596e72a964f94873162b595fb483/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bb4268527df596e72a964f94873162b595fb483/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=6bb4268527df596e72a964f94873162b595fb483", "patch": "@@ -8483,7 +8483,8 @@ All basic @code{asm} blocks are implicitly volatile.\n \n @item inline\n If you use the @code{inline} qualifier, then for inlining purposes the size\n-of the asm is taken as the smallest size possible (@pxref{Size of an asm}).\n+of the @code{asm} statement is taken as the smallest size possible (@pxref{Size\n+of an asm}).\n @end table\n \n @subsubheading Parameters\n@@ -8629,7 +8630,8 @@ qualifier to disable certain optimizations. @xref{Volatile}.\n \n @item inline\n If you use the @code{inline} qualifier, then for inlining purposes the size\n-of the asm is taken as the smallest size possible (@pxref{Size of an asm}).\n+of the @code{asm} statement is taken as the smallest size possible\n+(@pxref{Size of an asm}).\n \n @item goto\n This qualifier informs the compiler that the @code{asm} statement may \n@@ -8741,7 +8743,7 @@ void DoCheck(uint32_t dwSomeValue)\n The next example shows a case where the optimizers can recognize that the input \n (@code{dwSomeValue}) never changes during the execution of the function and can \n therefore move the @code{asm} outside the loop to produce more efficient code. \n-Again, using @code{volatile} disables this type of optimization.\n+Again, using the @code{volatile} qualifier disables this type of optimization.\n \n @example\n void do_print(uint32_t dwSomeValue)\n@@ -8797,20 +8799,21 @@ GCC's optimizers do not treat this code like the non-volatile code in the\n earlier examples. They do not move it out of loops or omit it on the \n assumption that the result from a previous call is still valid.\n \n-Note that the compiler can move even volatile @code{asm} instructions relative \n+Note that the compiler can move even @code{volatile asm} instructions relative\n to other code, including across jump instructions. For example, on many \n targets there is a system register that controls the rounding mode of \n-floating-point operations. Setting it with a volatile @code{asm}, as in the \n-following PowerPC example, does not work reliably.\n+floating-point operations. Setting it with a @code{volatile asm} statement,\n+as in the following PowerPC example, does not work reliably.\n \n @example\n asm volatile(\"mtfsf 255, %0\" : : \"f\" (fpenv));\n sum = x + y;\n @end example\n \n-The compiler may move the addition back before the volatile @code{asm}. To \n-make it work as expected, add an artificial dependency to the @code{asm} by \n-referencing a variable in the subsequent code, for example: \n+The compiler may move the addition back before the @code{volatile asm}\n+statement. To make it work as expected, add an artificial dependency to\n+the @code{asm} by referencing a variable in the subsequent code, for\n+example:\n \n @example\n asm volatile (\"mtfsf 255,%1\" : \"=X\" (sum) : \"f\" (fpenv));\n@@ -8819,7 +8822,7 @@ sum = x + y;\n \n Under certain circumstances, GCC may duplicate (or remove duplicates of) your \n assembly code when optimizing. This can lead to unexpected duplicate symbol \n-errors during compilation if your asm code defines symbols or labels. \n+errors during compilation if your @code{asm} code defines symbols or labels. \n Using @samp{%=} \n (@pxref{AssemblerTemplate}) may help resolve this problem.\n \n@@ -8848,7 +8851,7 @@ that some assembler dialects use semicolons to start a comment.\n Do not expect a sequence of @code{asm} statements to remain perfectly \n consecutive after compilation, even when you are using the @code{volatile} \n qualifier. If certain instructions need to remain consecutive in the output, \n-put them in a single multi-instruction asm statement.\n+put them in a single multi-instruction @code{asm} statement.\n \n Accessing data from C programs without using input/output operands (such as \n by using global symbols directly from the assembler template) may not work as \n@@ -9041,7 +9044,8 @@ The code generated by GCC to access the memory address in @var{b} can contain\n registers which @emph{might} be shared by @var{a}, and GCC considers those \n registers to be inputs to the asm. As above, GCC assumes that such input\n registers are consumed before any outputs are written. This assumption may \n-result in incorrect behavior if the asm writes to @var{a} before using \n+result in incorrect behavior if the @code{asm} statement writes to @var{a}\n+before using\n @var{b}. Combining the @samp{&} modifier with the register constraint on @var{a}\n ensures that modifying @var{a} does not affect the address referenced by \n @var{b}. Otherwise, the location of @var{b} \n@@ -9123,8 +9127,8 @@ for @code{d} by specifying both constraints.\n \n Some targets have a special register that holds the ``flags'' for the\n result of an operation or comparison.  Normally, the contents of that\n-register are either unmodifed by the asm, or the asm is considered to\n-clobber the contents.\n+register are either unmodifed by the asm, or the @code{asm} statement is\n+considered to clobber the contents.\n \n On some targets, a special form of output operand exists by which\n conditions in the flags register may be outputs of the asm.  The set of\n@@ -10630,7 +10634,7 @@ That is, if the current\n value of @code{*@var{ptr}} is @var{oldval}, then write @var{newval} into\n @code{*@var{ptr}}.\n \n-The ``bool'' version returns true if the comparison is successful and\n+The ``bool'' version returns @code{true} if the comparison is successful and\n @var{newval} is written.  The ``val'' version returns the contents\n of @code{*@var{ptr}} before the operation.\n \n@@ -10831,18 +10835,18 @@ This compares the contents of @code{*@var{ptr}} with the contents of\n @code{*@var{expected}}. If equal, the operation is a @emph{read-modify-write}\n operation that writes @var{desired} into @code{*@var{ptr}}.  If they are not\n equal, the operation is a @emph{read} and the current contents of\n-@code{*@var{ptr}} are written into @code{*@var{expected}}.  @var{weak} is true\n-for weak compare_exchange, which may fail spuriously, and false for\n+@code{*@var{ptr}} are written into @code{*@var{expected}}.  @var{weak} is @code{true}\n+for weak compare_exchange, which may fail spuriously, and @code{false} for\n the strong variation, which never fails spuriously.  Many targets\n only offer the strong variation and ignore the parameter.  When in doubt, use\n the strong variation.\n \n-If @var{desired} is written into @code{*@var{ptr}} then true is returned\n+If @var{desired} is written into @code{*@var{ptr}} then @code{true} is returned\n and memory is affected according to the\n memory order specified by @var{success_memorder}.  There are no\n restrictions on what memory order can be used here.\n \n-Otherwise, false is returned and memory is affected according\n+Otherwise, @code{false} is returned and memory is affected according\n to @var{failure_memorder}. This memory order cannot be\n @code{__ATOMIC_RELEASE} nor @code{__ATOMIC_ACQ_REL}.  It also cannot be a\n stronger order than that specified by @var{success_memorder}.\n@@ -10946,7 +10950,7 @@ All memory orders are valid.\n \n @deftypefn {Built-in Function} bool __atomic_always_lock_free (size_t size,  void *ptr)\n \n-This built-in function returns true if objects of @var{size} bytes always\n+This built-in function returns @code{true} if objects of @var{size} bytes always\n generate lock-free atomic instructions for the target architecture.\n @var{size} must resolve to a compile-time constant and the result also\n resolves to a compile-time constant.\n@@ -10963,7 +10967,7 @@ if (__atomic_always_lock_free (sizeof (long long), 0))\n \n @deftypefn {Built-in Function} bool __atomic_is_lock_free (size_t size, void *ptr)\n \n-This built-in function returns true if objects of @var{size} bytes always\n+This built-in function returns @code{true} if objects of @var{size} bytes always\n generate lock-free atomic instructions for the target architecture.  If\n the built-in function is not known to be lock-free, a call is made to a\n runtime routine named @code{__atomic_is_lock_free}.\n@@ -10991,7 +10995,7 @@ These built-in functions promote the first two operands into infinite precision\n type and perform addition on those promoted operands.  The result is then\n cast to the type the third pointer argument points to and stored there.\n If the stored result is equal to the infinite precision result, the built-in\n-functions return false, otherwise they return true.  As the addition is\n+functions return @code{false}, otherwise they return @code{true}.  As the addition is\n performed in infinite signed precision, these built-in functions have fully defined\n behavior for all argument values.\n \n@@ -11048,7 +11052,7 @@ than enumerated or boolean type.\n The built-in functions promote the first two operands into infinite precision signed type\n and perform addition on those promoted operands. The result is then\n cast to the type of the third argument.  If the cast result is equal to the infinite\n-precision result, the built-in functions return false, otherwise they return true.\n+precision result, the built-in functions return @code{false}, otherwise they return @code{true}.\n The value of the third argument is ignored, just the side effects in the third argument\n are evaluated, and no integral argument promotions are performed on the last argument.\n If the third argument is a bit-field, the type used for the result cast has the\n@@ -12120,7 +12124,7 @@ integer constant expression, is nonzero.  Otherwise it returns @var{exp2}.\n This built-in function is analogous to the @samp{? :} operator in C,\n except that the expression returned has its type unaltered by promotion\n rules.  Also, the built-in function does not evaluate the expression\n-that is not chosen.  For example, if @var{const_exp} evaluates to true,\n+that is not chosen.  For example, if @var{const_exp} evaluates to @code{true},\n @var{exp2} is not evaluated even if it has side effects.\n \n This built-in function can return an lvalue if the chosen argument is an\n@@ -12306,7 +12310,7 @@ if (__builtin_expect (ptr != NULL, 1))\n when testing pointer or floating-point values.\n \n For the purposes of branch prediction optimizations, the probability that\n-a @code{__builtin_expect} expression is true is controlled by GCC's\n+a @code{__builtin_expect} expression is @code{true} is controlled by GCC's\n @code{builtin-expect-probability} parameter, which defaults to 90%.  \n You can also use @code{__builtin_expect_with_probability} to explicitly \n assign a probability value to individual expressions.\n@@ -14934,8 +14938,8 @@ Comparison of two paired-single values\n @code{bc1any2t}/@code{bc1any2f}).\n \n These functions compare @var{a} and @var{b} using @code{c.@var{cond}.ps}\n-or @code{cabs.@var{cond}.ps}.  The @code{any} forms return true if either\n-result is true and the @code{all} forms return true if both results are true.\n+or @code{cabs.@var{cond}.ps}.  The @code{any} forms return @code{true} if either\n+result is @code{true} and the @code{all} forms return @code{true} if both results are @code{true}.\n For example:\n \n @smallexample\n@@ -14961,8 +14965,8 @@ Comparison of four paired-single values\n \n These functions use @code{c.@var{cond}.ps} or @code{cabs.@var{cond}.ps}\n to compare @var{a} with @var{b} and to compare @var{c} with @var{d}.\n-The @code{any} forms return true if any of the four results are true\n-and the @code{all} forms return true if all four results are true.\n+The @code{any} forms return @code{true} if any of the four results are @code{true}\n+and the @code{all} forms return @code{true} if all four results are @code{true}.\n For example:\n \n @smallexample\n@@ -16126,7 +16130,8 @@ add 32.  Hence these instructions only modify the FPSCR[32:63] bits by\n changing the specified bit to a zero or one respectively.  The\n @code{__builtin_set_fpscr_rn} builtin allows changing both of the floating\n point rounding mode bits.  The argument is a 2-bit value.  The argument can\n-either be a const int or stored in a variable. The builtin uses the ISA 3.0\n+either be a @code{const int} or stored in a variable. The builtin uses\n+the ISA 3.0\n instruction @code{mffscrn} if available, otherwise it reads the FPSCR, masks\n the current rounding mode bits out and OR's in the new value.\n \n@@ -16182,7 +16187,8 @@ unsigned long long __builtin_unpack_dec128 (_Decimal128, int);\n \n The @code{__builtin_set_fpscr_drn} builtin allows changing the three decimal\n floating point rounding mode bits.  The argument is a 3-bit value.  The\n-argument can either be a const int or the value can be stored in a variable.\n+argument can either be a @code{const int} or the value can be stored in\n+a variable.\n The builtin uses the ISA 3.0 instruction @code{mffscdrn} if available.\n Otherwise the builtin reads the FPSCR, masks the current decimal rounding\n mode bits out and OR's in the new value.\n@@ -19573,7 +19579,7 @@ The HTM builtins (with the exception of @code{__builtin_tbegin}) return\n the full 4-bit condition register value set by their associated hardware\n instruction.  The header file @code{htmintrin.h} defines some macros that can\n be used to decipher the return value.  The @code{__builtin_tbegin} builtin\n-returns a simple true or false value depending on whether a transaction was\n+returns a simple @code{true} or @code{false} value depending on whether a transaction was\n successfully started or not.  The arguments of the builtins match exactly the\n type and order of the associated hardware instruction's operands, except for\n the @code{__builtin_tcheck} builtin, which does not take any input arguments.\n@@ -22533,15 +22539,15 @@ This pragma gives the C function @var{oldname} the assembly symbol\n is defined if this pragma is available (currently on all platforms).\n @end table\n \n-This pragma and the asm labels extension interact in a complicated\n+This pragma and the @code{asm} labels extension interact in a complicated\n manner.  Here are some corner cases you may want to be aware of:\n \n @enumerate\n @item This pragma silently applies only to declarations with external\n-linkage.  Asm labels do not have this restriction.\n+linkage.  The @code{asm} label feature does not have this restriction.\n \n @item In C++, this pragma silently applies only to declarations with\n-``C'' linkage.  Again, asm labels do not have this restriction.\n+``C'' linkage.  Again, @code{asm} labels do not have this restriction.\n \n @item If either of the ways of changing the assembly name of a\n declaration are applied to a declaration whose assembly name has\n@@ -23924,130 +23930,143 @@ pair of types).\n \n @table @code\n @item __has_nothrow_assign (type)\n-If @code{type} is const qualified or is a reference type then the trait is\n-false.  Otherwise if @code{__has_trivial_assign (type)} is true then the trait\n-is true, else if @code{type} is a cv class or union type with copy assignment\n-operators that are known not to throw an exception then the trait is true,\n-else it is false.  Requires: @code{type} shall be a complete type,\n-(possibly cv-qualified) @code{void}, or an array of unknown bound.\n+If @code{type} is @code{const}-qualified or is a reference type then\n+the trait is @code{false}.  Otherwise if @code{__has_trivial_assign (type)}\n+is @code{true} then the trait is @code{true}, else if @code{type} is\n+a cv-qualified class or union type with copy assignment operators that are\n+known not to throw an exception then the trait is @code{true}, else it is\n+@code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n+@code{void}, or an array of unknown bound.\n \n @item __has_nothrow_copy (type)\n-If @code{__has_trivial_copy (type)} is true then the trait is true, else if\n-@code{type} is a cv class or union type with copy constructors that\n-are known not to throw an exception then the trait is true, else it is false.\n+If @code{__has_trivial_copy (type)} is @code{true} then the trait is\n+@code{true}, else if @code{type} is a cv-qualified class or union type\n+with copy constructors that are known not to throw an exception then\n+the trait is @code{true}, else it is @code{false}.\n Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n @code{void}, or an array of unknown bound.\n \n @item __has_nothrow_constructor (type)\n-If @code{__has_trivial_constructor (type)} is true then the trait is\n-true, else if @code{type} is a cv class or union type (or array\n+If @code{__has_trivial_constructor (type)} is @code{true} then the trait\n+is @code{true}, else if @code{type} is a cv class or union type (or array\n thereof) with a default constructor that is known not to throw an\n-exception then the trait is true, else it is false.  Requires:\n-@code{type} shall be a complete type, (possibly cv-qualified)\n+exception then the trait is @code{true}, else it is @code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n @code{void}, or an array of unknown bound.\n \n @item __has_trivial_assign (type)\n-If @code{type} is const qualified or is a reference type then the trait is\n-false.  Otherwise if @code{__is_pod (type)} is true then the trait is\n-true, else if @code{type} is a cv class or union type with a trivial\n-copy assignment ([class.copy]) then the trait is true, else it is\n-false.  Requires: @code{type} shall be a complete type, (possibly\n-cv-qualified) @code{void}, or an array of unknown bound.\n+If @code{type} is @code{const}- qualified or is a reference type then\n+the trait is @code{false}.  Otherwise if @code{__is_pod (type)} is\n+@code{true} then the trait is @code{true}, else if @code{type} is\n+a cv-qualified class or union type with a trivial copy assignment\n+([class.copy]) then the trait is @code{true}, else it is @code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n+@code{void}, or an array of unknown bound.\n \n @item __has_trivial_copy (type)\n-If @code{__is_pod (type)} is true or @code{type} is a reference type\n-then the trait is true, else if @code{type} is a cv class or union type\n-with a trivial copy constructor ([class.copy]) then the trait\n-is true, else it is false.  Requires: @code{type} shall be a complete\n-type, (possibly cv-qualified) @code{void}, or an array of unknown bound.\n+If @code{__is_pod (type)} is @code{true} or @code{type} is a reference\n+type then the trait is @code{true}, else if @code{type} is a cv class\n+or union type with a trivial copy constructor ([class.copy]) then the trait\n+is @code{true}, else it is @code{false}.  Requires: @code{type} shall be\n+a complete type, (possibly cv-qualified) @code{void}, or an array of unknown\n+bound.\n \n @item __has_trivial_constructor (type)\n-If @code{__is_pod (type)} is true then the trait is true, else if\n-@code{type} is a cv class or union type (or array thereof) with a\n-trivial default constructor ([class.ctor]) then the trait is true,\n-else it is false.  Requires: @code{type} shall be a complete\n-type, (possibly cv-qualified) @code{void}, or an array of unknown bound.\n+If @code{__is_pod (type)} is @code{true} then the trait is @code{true},\n+else if @code{type} is a cv-qualified class or union type (or array thereof)\n+with a trivial default constructor ([class.ctor]) then the trait is @code{true},\n+else it is @code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n+@code{void}, or an array of unknown bound.\n \n @item __has_trivial_destructor (type)\n-If @code{__is_pod (type)} is true or @code{type} is a reference type then\n-the trait is true, else if @code{type} is a cv class or union type (or\n-array thereof) with a trivial destructor ([class.dtor]) then the trait\n-is true, else it is false.  Requires: @code{type} shall be a complete\n-type, (possibly cv-qualified) @code{void}, or an array of unknown bound.\n+If @code{__is_pod (type)} is @code{true} or @code{type} is a reference type\n+then the trait is @code{true}, else if @code{type} is a cv class or union\n+type (or array thereof) with a trivial destructor ([class.dtor]) then\n+the trait is @code{true}, else it is @code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n+@code{void}, or an array of unknown bound.\n \n @item __has_virtual_destructor (type)\n If @code{type} is a class type with a virtual destructor\n-([class.dtor]) then the trait is true, else it is false.  Requires:\n-@code{type} shall be a complete type, (possibly cv-qualified)\n+([class.dtor]) then the trait is @code{true}, else it is @code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n @code{void}, or an array of unknown bound.\n \n @item __is_abstract (type)\n If @code{type} is an abstract class ([class.abstract]) then the trait\n-is true, else it is false.  Requires: @code{type} shall be a complete\n-type, (possibly cv-qualified) @code{void}, or an array of unknown bound.\n+is @code{true}, else it is @code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n+@code{void}, or an array of unknown bound.\n \n @item __is_base_of (base_type, derived_type)\n If @code{base_type} is a base class of @code{derived_type}\n-([class.derived]) then the trait is true, otherwise it is false.\n-Top-level cv qualifications of @code{base_type} and\n+([class.derived]) then the trait is @code{true}, otherwise it is @code{false}.\n+Top-level cv-qualifications of @code{base_type} and\n @code{derived_type} are ignored.  For the purposes of this trait, a\n-class type is considered is own base.  Requires: if @code{__is_class\n-(base_type)} and @code{__is_class (derived_type)} are true and\n-@code{base_type} and @code{derived_type} are not the same type\n-(disregarding cv-qualifiers), @code{derived_type} shall be a complete\n+class type is considered is own base.\n+Requires: if @code{__is_class (base_type)} and @code{__is_class (derived_type)}\n+are @code{true} and @code{base_type} and @code{derived_type} are not the same\n+type (disregarding cv-qualifiers), @code{derived_type} shall be a complete\n type.  A diagnostic is produced if this requirement is not met.\n \n @item __is_class (type)\n-If @code{type} is a cv class type, and not a union type\n-([basic.compound]) the trait is true, else it is false.\n+If @code{type} is a cv-qualified class type, and not a union type\n+([basic.compound]) the trait is @code{true}, else it is @code{false}.\n \n @item __is_empty (type)\n-If @code{__is_class (type)} is false then the trait is false.\n+If @code{__is_class (type)} is @code{false} then the trait is @code{false}.\n Otherwise @code{type} is considered empty if and only if: @code{type}\n has no non-static data members, or all non-static data members, if\n any, are bit-fields of length 0, and @code{type} has no virtual\n members, and @code{type} has no virtual base classes, and @code{type}\n has no base classes @code{base_type} for which\n-@code{__is_empty (base_type)} is false.  Requires: @code{type} shall\n-be a complete type, (possibly cv-qualified) @code{void}, or an array\n-of unknown bound.\n+@code{__is_empty (base_type)} is @code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n+@code{void}, or an array of unknown bound.\n \n @item __is_enum (type)\n If @code{type} is a cv enumeration type ([basic.compound]) the trait is\n-true, else it is false.\n+@code{true}, else it is @code{false}.\n \n @item __is_literal_type (type)\n If @code{type} is a literal type ([basic.types]) the trait is\n-true, else it is false.  Requires: @code{type} shall be a complete type,\n-(possibly cv-qualified) @code{void}, or an array of unknown bound.\n+@code{true}, else it is @code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n+@code{void}, or an array of unknown bound.\n \n @item __is_pod (type)\n-If @code{type} is a cv POD type ([basic.types]) then the trait is true,\n-else it is false.  Requires: @code{type} shall be a complete type,\n-(possibly cv-qualified) @code{void}, or an array of unknown bound.\n+If @code{type} is a cv POD type ([basic.types]) then the trait is @code{true},\n+else it is @code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n+@code{void}, or an array of unknown bound.\n \n @item __is_polymorphic (type)\n If @code{type} is a polymorphic class ([class.virtual]) then the trait\n-is true, else it is false.  Requires: @code{type} shall be a complete\n-type, (possibly cv-qualified) @code{void}, or an array of unknown bound.\n+is @code{true}, else it is @code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n+@code{void}, or an array of unknown bound.\n \n @item __is_standard_layout (type)\n If @code{type} is a standard-layout type ([basic.types]) the trait is\n-true, else it is false.  Requires: @code{type} shall be a complete\n-type, (possibly cv-qualified) @code{void}, or an array of unknown bound.\n+@code{true}, else it is @code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n+@code{void}, or an array of unknown bound.\n \n @item __is_trivial (type)\n If @code{type} is a trivial type ([basic.types]) the trait is\n-true, else it is false.  Requires: @code{type} shall be a complete\n-type, (possibly cv-qualified) @code{void}, or an array of unknown bound.\n+@code{true}, else it is @code{false}.\n+Requires: @code{type} shall be a complete type, (possibly cv-qualified)\n+@code{void}, or an array of unknown bound.\n \n @item __is_union (type)\n If @code{type} is a cv union type ([basic.compound]) the trait is\n-true, else it is false.\n+@code{true}, else it is @code{false}.\n \n @item __underlying_type (type)\n-The underlying type of @code{type}.  Requires: @code{type} shall be\n-an enumeration type ([dcl.enum]).\n+The underlying type of @code{type}.\n+Requires: @code{type} shall be an enumeration type ([dcl.enum]).\n \n @item __integer_pack (length)\n When used as the pattern of a pack expansion within a template\n@@ -24098,7 +24117,7 @@ likely to be removed in the future.\n \n @table @code\n @item __is_same (type1, type2)\n-A binary type trait: true whenever the type arguments are the same.\n+A binary type trait: @code{true} whenever the type arguments are the same.\n \n @end table\n "}]}