{"sha": "4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRiNmJjMGY2ZWE2NWQzZGU0ZDE3MDAyYzYyODRjYjBiYzI5MDlhYQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2008-05-07T00:55:51Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2008-05-07T00:55:51Z"}, "message": "mutex (mutex::mutex): Fix usage of initializing macro.\n\n2008-05-06  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/std/mutex (mutex::mutex): Fix usage of initializing macro.\n\t(recursive_mutex::recursive_mutex): Same.\n\t(once_flag::once_flag): Same.\n\t* testsuite/30_threads/mutex/cons/assign_neg.cc: Fix line numbers.\n\t* testsuite/30_threads/mutex/cons/copy_neg.cc: Same.\n\t* testsuite/30_threads/recursive_mutex/cons/assign_neg.cc: Same.\n\t* testsuite/30_threads/recursive_mutex/cons/copy_neg.cc: Same.\n\nFrom-SVN: r135015", "tree": {"sha": "743bcb298509e77f61730a922ec8bd8e9c53f5b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/743bcb298509e77f61730a922ec8bd8e9c53f5b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/comments", "author": null, "committer": null, "parents": [{"sha": "77fa554dfcdd97a1036f510f4261598539f06742", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77fa554dfcdd97a1036f510f4261598539f06742", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77fa554dfcdd97a1036f510f4261598539f06742"}], "stats": {"total": 170, "additions": 90, "deletions": 80}, "files": [{"sha": "ecba4a379a9a707b80c21bff6d28f371866dc7fb", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa", "patch": "@@ -1,3 +1,13 @@\n+2008-05-06  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/std/mutex (mutex::mutex): Fix usage of initializing macro.\n+\t(recursive_mutex::recursive_mutex): Same.\n+\t(once_flag::once_flag): Same.\n+\t* testsuite/30_threads/mutex/cons/assign_neg.cc: Fix line numbers.\n+\t* testsuite/30_threads/mutex/cons/copy_neg.cc: Same.\n+\t* testsuite/30_threads/recursive_mutex/cons/assign_neg.cc: Same.\n+\t* testsuite/30_threads/recursive_mutex/cons/copy_neg.cc: Same.\n+\t\n 2008-05-06  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/std/condition_variable: New."}, {"sha": "935b16e57c29435c9b32e340c3ff717ed72e81cb", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa", "patch": "@@ -1,6 +1,6 @@\n // <mutex> -*- C++ -*-\n \n-// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 \n+// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -44,9 +44,9 @@\n #include <exception>\n #include <cstddef>\n #include <bits/functexcept.h>\n-#include <bits/gthr.h> \n+#include <bits/gthr.h>\n \n-namespace std \n+namespace std\n {\n   // XXX\n   class system_time;\n@@ -63,47 +63,45 @@ namespace std\n       native_handle_type __tmp = __GTHREAD_MUTEX_INIT;\n       _M_mutex = __tmp;\n #else\n-      int __e = __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex); \n+      __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);\n+#endif\n \n       // EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)\n-      if ( __e)\n-       __throw_system_error(__e);      \n-#endif\n     }\n \n-    void \n+    void\n     lock()\n     {\n       int __e = __gthread_mutex_lock(&_M_mutex);\n \n       // EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)\n-     if ( __e)\n+     if (__e)\n        __throw_system_error(__e);\n     }\n- \n-    bool \n+\n+    bool\n     try_lock()\n     {\n       int __e = __gthread_mutex_trylock(&_M_mutex);\n \n       // EINVAL, EAGAIN, EBUSY\n-     if ( __e)\n+     if (__e)\n        __throw_system_error(__e);\n      else\n        return true;\n     }\n \n-    void \n+    void\n     unlock()\n     {\n       int __e = __gthread_mutex_unlock(&_M_mutex);\n \n       // EINVAL, EAGAIN, EPERM\n-     if ( __e)\n+     if (__e)\n        __throw_system_error(__e);\n     }\n \n-    native_handle_type \n+    native_handle_type\n     native_handle()\n     { return _M_mutex; }\n \n@@ -121,53 +119,51 @@ namespace std\n     typedef __gthread_recursive_mutex_t native_handle_type;\n \n     recursive_mutex()\n-    { \n+    {\n #if defined __GTHREAD_RECURSIVE_MUTEX_INIT\n       native_handle_type __tmp = __GTHREAD_RECURSIVE_MUTEX_INIT;\n       _M_mutex = __tmp;\n #else\n-      int __e = __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(&_M_mutex);\n+      __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(&_M_mutex);\n+#endif\n \n       // EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)\n-      if ( __e)\n-       __throw_system_error(__e);      \n-#endif\n     }\n \n \n-    void \n+    void\n     lock()\n-    { \n+    {\n       int __e = __gthread_recursive_mutex_lock(&_M_mutex);\n \n       // EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)\n-     if ( __e)\n+     if (__e)\n        __throw_system_error(__e);\n     }\n-  \n-    bool \n+\n+    bool\n     try_lock()\n     {\n       int __e = __gthread_recursive_mutex_trylock(&_M_mutex);\n \n       // EINVAL, EAGAIN, EBUSY\n-     if ( __e)\n+     if (__e)\n        __throw_system_error(__e);\n      else\n        return true;\n     }\n \n-    void \n+    void\n     unlock()\n-    { \n+    {\n       int __e = __gthread_recursive_mutex_unlock(&_M_mutex);\n \n       // EINVAL, EAGAIN, EBUSY\n-     if ( __e)\n+     if (__e)\n        __throw_system_error(__e);\n     }\n \n-    native_handle_type \n+    native_handle_type\n     native_handle() { return _M_mutex; }\n \n   private:\n@@ -191,22 +187,22 @@ namespace std\n   /// and manage it.\n   struct adopt_lock_t { };\n \n-  extern const defer_lock_t \tdefer_lock;\n-  extern const try_to_lock_t \ttry_to_lock;\n-  extern const adopt_lock_t \tadopt_lock;\n+  extern const defer_lock_t\tdefer_lock;\n+  extern const try_to_lock_t\ttry_to_lock;\n+  extern const adopt_lock_t\tadopt_lock;\n \n   /// Thrown to indicate errors with lock operations.\n   class lock_error : public exception\n   {\n   public:\n-    virtual const char* \n+    virtual const char*\n     what() const throw();\n   };\n-  \n+\n   /// @brief  Scoped lock idiom.\n   // Acquire the mutex here with a constructor call, then release with\n   // the destructor call in accordance with RAII style.\n-  template<typename _Mutex> \n+  template<typename _Mutex>\n     class lock_guard\n     {\n     public:\n@@ -228,7 +224,7 @@ namespace std\n     };\n \n   /// unique_lock\n-  template<typename _Mutex> \n+  template<typename _Mutex>\n     class unique_lock\n     {\n     public:\n@@ -237,18 +233,18 @@ namespace std\n       unique_lock() : _M_device(NULL), _M_owns(false) { }\n \n       explicit unique_lock(mutex_type& __m) : _M_device(&__m)\n-      { \n-\tlock(); \n+      {\n+\tlock();\n \t_M_owns = true;\n       }\n-      \n-      unique_lock(mutex_type& __m, defer_lock_t) \n+\n+      unique_lock(mutex_type& __m, defer_lock_t)\n       : _M_device(&__m), _M_owns(false) { }\n \n-      unique_lock(mutex_type& __m, try_to_lock_t) \n+      unique_lock(mutex_type& __m, try_to_lock_t)\n       : _M_device(&__m), _M_owns(_M_device->try_lock()) { }\n \n-      unique_lock(mutex_type& __m, adopt_lock_t) \n+      unique_lock(mutex_type& __m, adopt_lock_t)\n       : _M_device(&__m), _M_owns(true)\n       {\n \t// XXX calling thread owns mutex\n@@ -257,7 +253,7 @@ namespace std\n       unique_lock(mutex_type& __m, const system_time& abs_time);\n \n       template<typename _Duration>\n-        unique_lock(mutex_type& __m, const _Duration& rel_time);\n+\tunique_lock(mutex_type& __m, const _Duration& rel_time);\n \n       ~unique_lock()\n       {\n@@ -270,97 +266,101 @@ namespace std\n       unique_lock& operator=(unique_lock&&);\n \n \n-      void \n+      void\n       lock()\n-      { \n+      {\n \tif (_M_device && !_M_owns)\n-\t  _M_device->lock(); \n+\t  _M_device->lock();\n \telse\n \t  throw lock_error();\n       }\n \n-      bool \n+      bool\n       try_lock()\n-      { \n+      {\n \tbool __ret = false;\n \tif (_M_device && !_M_owns)\n-\t  __ret = _M_device->try_lock(); \n+\t  __ret = _M_device->try_lock();\n \telse\n \t  throw lock_error();\n \treturn __ret;\n       }\n \n-      void \n+      void\n       unlock()\n-      { \n+      {\n \tif (_M_device && _M_owns)\n-\t  _M_device->unlock(); \n+\t  _M_device->unlock();\n \telse\n \t  throw lock_error();\n       }\n \n \n       template<typename _Duration>\n-        bool timed_lock(const _Duration& rel_time);\n+\tbool timed_lock(const _Duration& rel_time);\n \n-      bool \n+      bool\n       timed_lock(const system_time& abs_time);\n \n-      void \n+      void\n       swap(unique_lock&& __u);\n \n-      mutex_type* \n-      release() \n-      { \n-\tmutex_type* __ret = _M_device; \n+      mutex_type*\n+      release()\n+      {\n+\tmutex_type* __ret = _M_device;\n \t_M_device = NULL;\n \t_M_owns = false;\n \treturn __ret;\n       }\n \n-      bool \n+      bool\n       owns_lock() const { return _M_owns; }\n \n       operator bool () const { return owns_lock(); }\n \n-      mutex_type* \n+      mutex_type*\n       mutex() const\n       { return _M_device; }\n \n     private:\n       unique_lock(unique_lock const&);\n       unique_lock& operator=(unique_lock const&);\n \n-      mutex_type* \t_M_device;\n-      bool \t\t_M_owns; // XXX use atomic_bool\n+      mutex_type*\t_M_device;\n+      bool\t\t_M_owns; // XXX use atomic_bool\n     };\n \n   template<typename _Mutex>\n-    void \n+    void\n     swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y);\n \n   template<typename _Mutex>\n-    void \n+    void\n     swap(unique_lock<_Mutex>&& __x, unique_lock<_Mutex>& __y);\n \n   template<typename _Mutex>\n-    void \n+    void\n     swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>&& __y);\n \n-  template<typename _L1, typename _L2, typename ..._L3> \n-    int \n+  template<typename _L1, typename _L2, typename ..._L3>\n+    int\n     try_lock(_L1&, _L2&, _L3&...);\n \n-  template<typename _L1, typename _L2, typename ..._L3> \n-    void \n+  template<typename _L1, typename _L2, typename ..._L3>\n+    void\n     lock(_L1&, _L2&, _L3&...);\n \n   /// once_flag\n-  struct once_flag \n+  struct once_flag\n   {\n     typedef __gthread_once_t __native_type;\n \n-    once_flag() : _M_once(__GTHREAD_ONCE_INIT) { }\n+    once_flag()\n+    {\n+      __native_type __tmp = __GTHREAD_ONCE_INIT;\n+      _M_once = __tmp;\n+    }\n \n     __native_type&\n     _M_get() { return _M_once; }\n@@ -372,11 +372,11 @@ namespace std\n   };\n \n   template<typename _Callable, typename... _Args>\n-    void \n+    void\n     call_once(once_flag& __once, _Callable __f, _Args&&... __args)\n     {\n-      int __e = __gthread_once(&(__once._M_get()), __f(__args...)); \n-      if ( __e)\n+      int __e = __gthread_once(&(__once._M_get()), __f(__args...));\n+      if (__e)\n \t__throw_system_error(__e);\n     }\n }"}, {"sha": "8a4d413c58693d28135557e00897b2f2c0ede9b7", "filename": "libstdc++-v3/testsuite/30_threads/mutex/cons/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fmutex%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fmutex%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fmutex%2Fcons%2Fassign_neg.cc?ref=4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa", "patch": "@@ -39,4 +39,4 @@ void test01()\n   m1 = m2;\n }\n // { dg-error \"within this context\" \"\" { target *-*-* } 39 } \n-// { dg-error \"is private\" \"\" { target *-*-* } 113 } \n+// { dg-error \"is private\" \"\" { target *-*-* } 111 } "}, {"sha": "76bc7614391f13e452338a3629232ea8c9d891a1", "filename": "libstdc++-v3/testsuite/30_threads/mutex/cons/copy_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fmutex%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fmutex%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fmutex%2Fcons%2Fcopy_neg.cc?ref=4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa", "patch": "@@ -38,4 +38,4 @@ void test01()\n   mutex_type m2(m1);\n }\n // { dg-error \"within this context\" \"\" { target *-*-* } 38 } \n-// { dg-error \"is private\" \"\" { target *-*-* } 112 } \n+// { dg-error \"is private\" \"\" { target *-*-* } 110 } "}, {"sha": "54877e427e19523125fe13629b2bc56086d3db55", "filename": "libstdc++-v3/testsuite/30_threads/recursive_mutex/cons/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Frecursive_mutex%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Frecursive_mutex%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Frecursive_mutex%2Fcons%2Fassign_neg.cc?ref=4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa", "patch": "@@ -39,4 +39,4 @@ void test01()\n   m1 = m2;\n }\n // { dg-error \"within this context\" \"\" { target *-*-* } 39 } \n-// { dg-error \"is private\" \"\" { target *-*-* } 177 } \n+// { dg-error \"is private\" \"\" { target *-*-* } 173 } "}, {"sha": "80a38b3e6eb71c475ab2dc408049f6bf4b71ca2d", "filename": "libstdc++-v3/testsuite/30_threads/recursive_mutex/cons/copy_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Frecursive_mutex%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Frecursive_mutex%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Frecursive_mutex%2Fcons%2Fcopy_neg.cc?ref=4db6bc0f6ea65d3de4d17002c6284cb0bc2909aa", "patch": "@@ -38,4 +38,4 @@ void test01()\n   mutex_type m2(m1);\n }\n // { dg-error \"within this context\" \"\" { target *-*-* } 38 } \n-// { dg-error \"is private\" \"\" { target *-*-* } 176 } \n+// { dg-error \"is private\" \"\" { target *-*-* } 172 } "}]}