{"sha": "062b827975180b9b278666e5a08f6e55bb120010", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYyYjgyNzk3NTE4MGI5YjI3ODY2NmU1YTA4ZjZlNTViYjEyMDAxMA==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2009-06-12T15:57:58Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2009-06-12T15:57:58Z"}, "message": "[multiple changes]\n\n2009-06-12  Andrew Haley  <aph@redhat.com>\n\n\t* ChangeLog.libffi: testsuite/libffi.call/cls_align_sint64.c,\n\ttestsuite/libffi.call/cls_align_uint64.c,\n\ttestsuite/libffi.call/cls_ulonglong.c,\n\ttestsuite/libffi.call/return_ll1.c,\n\ttestsuite/libffi.call/stret_medium2.c: Fix printf format\n\tspecifiers.\n\ttestsuite/libffi.special/unwindtest.cc: include stdint.h.\n\n2009-06-11  Timothy Wall  <twall@users.sf.net>\n\n\t* Makefile.am,\n        configure.ac,\n        include/ffi.h.in,\n        include/ffi_common.h,\n        src/closures.c,\n        src/dlmalloc.c,\n        src/x86/ffi.c,\n        src/x86/ffitarget.h,\n        src/x86/win64.S (new),\n\tREADME: Added win64 support (mingw or MSVC)\n        * Makefile.in,\n        include/Makefile.in,\n        man/Makefile.in,\n        testsuite/Makefile.in,\n        configure,\n        aclocal.m4: Regenerated\n        * ltcf-c.sh: properly escape cygwin/w32 path\n        * man/ffi_call.3: Clarify size requirements for return value.\n        * src/x86/ffi64.c: Fix filename in comment.\n        * src/x86/win32.S: Remove unused extern.\n\n        * testsuite/libffi.call/closure_fn0.c,\n        testsuite/libffi.call/closure_fn1.c,\n        testsuite/libffi.call/closure_fn2.c,\n        testsuite/libffi.call/closure_fn3.c,\n        testsuite/libffi.call/closure_fn4.c,\n        testsuite/libffi.call/closure_fn5.c,\n        testsuite/libffi.call/closure_fn6.c,\n\ttestsuite/libffi.call/closure_stdcall.c,\n\ttestsuite/libffi.call/cls_12byte.c,\n\ttestsuite/libffi.call/cls_16byte.c,\n\ttestsuite/libffi.call/cls_18byte.c,\n\ttestsuite/libffi.call/cls_19byte.c,\n\ttestsuite/libffi.call/cls_1_1byte.c,\n\ttestsuite/libffi.call/cls_20byte.c,\n\ttestsuite/libffi.call/cls_20byte1.c,\n\ttestsuite/libffi.call/cls_24byte.c,\n\ttestsuite/libffi.call/cls_2byte.c,\n\ttestsuite/libffi.call/cls_3_1byte.c,\n\ttestsuite/libffi.call/cls_3byte1.c,\n \ttestsuite/libffi.call/cls_3byte2.c,\n \ttestsuite/libffi.call/cls_4_1byte.c,\n \ttestsuite/libffi.call/cls_4byte.c,\n \ttestsuite/libffi.call/cls_5_1_byte.c,\n \ttestsuite/libffi.call/cls_5byte.c,\n \ttestsuite/libffi.call/cls_64byte.c,\n \ttestsuite/libffi.call/cls_6_1_byte.c,\n \ttestsuite/libffi.call/cls_6byte.c,\n \ttestsuite/libffi.call/cls_7_1_byte.c,\n \ttestsuite/libffi.call/cls_7byte.c,\n \ttestsuite/libffi.call/cls_8byte.c,\n \ttestsuite/libffi.call/cls_9byte1.c,\n \ttestsuite/libffi.call/cls_9byte2.c,\n \ttestsuite/libffi.call/cls_align_double.c,\n \ttestsuite/libffi.call/cls_align_float.c,\n \ttestsuite/libffi.call/cls_align_longdouble.c,\n \ttestsuite/libffi.call/cls_align_longdouble_split.c,\n \ttestsuite/libffi.call/cls_align_longdouble_split2.c,\n \ttestsuite/libffi.call/cls_align_pointer.c,\n \ttestsuite/libffi.call/cls_align_sint16.c,\n \ttestsuite/libffi.call/cls_align_sint32.c,\n \ttestsuite/libffi.call/cls_align_sint64.c,\n \ttestsuite/libffi.call/cls_align_uint16.c,\n \ttestsuite/libffi.call/cls_align_uint32.c,\n \ttestsuite/libffi.call/cls_align_uint64.c,\n \ttestsuite/libffi.call/cls_dbls_struct.c,\n \ttestsuite/libffi.call/cls_double.c,\n \ttestsuite/libffi.call/cls_double_va.c,\n \ttestsuite/libffi.call/cls_float.c,\n \ttestsuite/libffi.call/cls_longdouble.c,\n \ttestsuite/libffi.call/cls_longdouble_va.c,\n \ttestsuite/libffi.call/cls_multi_schar.c,\n \ttestsuite/libffi.call/cls_multi_sshort.c,\n \ttestsuite/libffi.call/cls_multi_sshortchar.c,\n \ttestsuite/libffi.call/cls_multi_uchar.c,\n \ttestsuite/libffi.call/cls_multi_ushort.c,\n \ttestsuite/libffi.call/cls_multi_ushortchar.c,\n \ttestsuite/libffi.call/cls_pointer.c,\n \ttestsuite/libffi.call/cls_pointer_stack.c,\n \ttestsuite/libffi.call/cls_schar.c,\n \ttestsuite/libffi.call/cls_sint.c,\n \ttestsuite/libffi.call/cls_sshort.c,\n \ttestsuite/libffi.call/cls_uchar.c,\n \ttestsuite/libffi.call/cls_uint.c,\n \ttestsuite/libffi.call/cls_ulonglong.c,\n \ttestsuite/libffi.call/cls_ushort.c,\n \ttestsuite/libffi.call/err_bad_abi.c,\n \ttestsuite/libffi.call/err_bad_typedef.c,\n \ttestsuite/libffi.call/float2.c,\n \ttestsuite/libffi.call/huge_struct.c,\n \ttestsuite/libffi.call/nested_struct.c,\n \ttestsuite/libffi.call/nested_struct1.c,\n \ttestsuite/libffi.call/nested_struct10.c,\n \ttestsuite/libffi.call/nested_struct2.c,\n \ttestsuite/libffi.call/nested_struct3.c,\n \ttestsuite/libffi.call/nested_struct4.c,\n \ttestsuite/libffi.call/nested_struct5.c,\n \ttestsuite/libffi.call/nested_struct6.c,\n \ttestsuite/libffi.call/nested_struct7.c,\n \ttestsuite/libffi.call/nested_struct8.c,\n \ttestsuite/libffi.call/nested_struct9.c,\n \ttestsuite/libffi.call/problem1.c,\n \ttestsuite/libffi.call/return_ldl.c,\n \ttestsuite/libffi.call/return_ll1.c,\n \ttestsuite/libffi.call/stret_large.c,\n \ttestsuite/libffi.call/stret_large2.c,\n \ttestsuite/libffi.call/stret_medium.c,\n \ttestsuite/libffi.call/stret_medium2.c,\n        testsuite/libffi.special/unwindtest.cc: use ffi_closure_alloc instead\n        of checking for MMAP.  Use intptr_t instead of long casts.\n\n2009-06-12  Andrew Haley  <aph@redhat.com>\n\n\t* Makefile.am: Remove info_TEXINFOS.\n\nFrom-SVN: r148433", "tree": {"sha": "efc26880d57fcef907b242e65358738dc2e71d97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efc26880d57fcef907b242e65358738dc2e71d97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/062b827975180b9b278666e5a08f6e55bb120010", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/062b827975180b9b278666e5a08f6e55bb120010", "html_url": "https://github.com/Rust-GCC/gccrs/commit/062b827975180b9b278666e5a08f6e55bb120010", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/062b827975180b9b278666e5a08f6e55bb120010/comments", "author": null, "committer": null, "parents": [{"sha": "e39a546c5d03b42256bd637ee0e287cb7107afdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e39a546c5d03b42256bd637ee0e287cb7107afdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e39a546c5d03b42256bd637ee0e287cb7107afdd"}], "stats": {"total": 2936, "additions": 1558, "deletions": 1378}, "files": [{"sha": "02e16ea35aea036e9be85fd953c128f3e7a85ef2", "filename": "libffi/ChangeLog", "status": "modified", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -1,3 +1,253 @@\n+2009-06-12  Andrew Haley  <aph@redhat.com>\n+\n+\t* ChangeLog.libffi: testsuite/libffi.call/cls_align_sint64.c,\n+\ttestsuite/libffi.call/cls_align_uint64.c,\n+\ttestsuite/libffi.call/cls_ulonglong.c,\n+\ttestsuite/libffi.call/return_ll1.c,\n+\ttestsuite/libffi.call/stret_medium2.c: Fix printf format\n+\tspecifiers.\n+\ttestsuite/libffi.special/unwindtest.cc: include stdint.h.\n+\n+2009-06-11  Timothy Wall  <twall@users.sf.net>\n+\n+\t* Makefile.am,\n+        configure.ac,\n+        include/ffi.h.in,\n+        include/ffi_common.h,\n+        src/closures.c,\n+        src/dlmalloc.c,\n+        src/x86/ffi.c,\n+        src/x86/ffitarget.h,\n+        src/x86/win64.S (new),\n+\tREADME: Added win64 support (mingw or MSVC)\n+        * Makefile.in,\n+        include/Makefile.in,\n+        man/Makefile.in,\n+        testsuite/Makefile.in,\n+        configure,\n+        aclocal.m4: Regenerated\n+        * ltcf-c.sh: properly escape cygwin/w32 path\n+        * man/ffi_call.3: Clarify size requirements for return value.\n+        * src/x86/ffi64.c: Fix filename in comment.\n+        * src/x86/win32.S: Remove unused extern.\n+\n+        * testsuite/libffi.call/closure_fn0.c,\n+        testsuite/libffi.call/closure_fn1.c,\n+        testsuite/libffi.call/closure_fn2.c,\n+        testsuite/libffi.call/closure_fn3.c,\n+        testsuite/libffi.call/closure_fn4.c,\n+        testsuite/libffi.call/closure_fn5.c,\n+        testsuite/libffi.call/closure_fn6.c,\n+\ttestsuite/libffi.call/closure_stdcall.c,\n+\ttestsuite/libffi.call/cls_12byte.c,\n+\ttestsuite/libffi.call/cls_16byte.c,\n+\ttestsuite/libffi.call/cls_18byte.c,\n+\ttestsuite/libffi.call/cls_19byte.c,\n+\ttestsuite/libffi.call/cls_1_1byte.c,\n+\ttestsuite/libffi.call/cls_20byte.c,\n+\ttestsuite/libffi.call/cls_20byte1.c,\n+\ttestsuite/libffi.call/cls_24byte.c,\n+\ttestsuite/libffi.call/cls_2byte.c,\n+\ttestsuite/libffi.call/cls_3_1byte.c,\n+\ttestsuite/libffi.call/cls_3byte1.c,\n+ \ttestsuite/libffi.call/cls_3byte2.c,\n+ \ttestsuite/libffi.call/cls_4_1byte.c,\n+ \ttestsuite/libffi.call/cls_4byte.c,\n+ \ttestsuite/libffi.call/cls_5_1_byte.c,\n+ \ttestsuite/libffi.call/cls_5byte.c,\n+ \ttestsuite/libffi.call/cls_64byte.c,\n+ \ttestsuite/libffi.call/cls_6_1_byte.c,\n+ \ttestsuite/libffi.call/cls_6byte.c,\n+ \ttestsuite/libffi.call/cls_7_1_byte.c,\n+ \ttestsuite/libffi.call/cls_7byte.c,\n+ \ttestsuite/libffi.call/cls_8byte.c,\n+ \ttestsuite/libffi.call/cls_9byte1.c,\n+ \ttestsuite/libffi.call/cls_9byte2.c,\n+ \ttestsuite/libffi.call/cls_align_double.c,\n+ \ttestsuite/libffi.call/cls_align_float.c,\n+ \ttestsuite/libffi.call/cls_align_longdouble.c,\n+ \ttestsuite/libffi.call/cls_align_longdouble_split.c,\n+ \ttestsuite/libffi.call/cls_align_longdouble_split2.c,\n+ \ttestsuite/libffi.call/cls_align_pointer.c,\n+ \ttestsuite/libffi.call/cls_align_sint16.c,\n+ \ttestsuite/libffi.call/cls_align_sint32.c,\n+ \ttestsuite/libffi.call/cls_align_sint64.c,\n+ \ttestsuite/libffi.call/cls_align_uint16.c,\n+ \ttestsuite/libffi.call/cls_align_uint32.c,\n+ \ttestsuite/libffi.call/cls_align_uint64.c,\n+ \ttestsuite/libffi.call/cls_dbls_struct.c,\n+ \ttestsuite/libffi.call/cls_double.c,\n+ \ttestsuite/libffi.call/cls_double_va.c,\n+ \ttestsuite/libffi.call/cls_float.c,\n+ \ttestsuite/libffi.call/cls_longdouble.c,\n+ \ttestsuite/libffi.call/cls_longdouble_va.c,\n+ \ttestsuite/libffi.call/cls_multi_schar.c,\n+ \ttestsuite/libffi.call/cls_multi_sshort.c,\n+ \ttestsuite/libffi.call/cls_multi_sshortchar.c,\n+ \ttestsuite/libffi.call/cls_multi_uchar.c,\n+ \ttestsuite/libffi.call/cls_multi_ushort.c,\n+ \ttestsuite/libffi.call/cls_multi_ushortchar.c,\n+ \ttestsuite/libffi.call/cls_pointer.c,\n+ \ttestsuite/libffi.call/cls_pointer_stack.c,\n+ \ttestsuite/libffi.call/cls_schar.c,\n+ \ttestsuite/libffi.call/cls_sint.c,\n+ \ttestsuite/libffi.call/cls_sshort.c,\n+ \ttestsuite/libffi.call/cls_uchar.c,\n+ \ttestsuite/libffi.call/cls_uint.c,\n+ \ttestsuite/libffi.call/cls_ulonglong.c,\n+ \ttestsuite/libffi.call/cls_ushort.c,\n+ \ttestsuite/libffi.call/err_bad_abi.c,\n+ \ttestsuite/libffi.call/err_bad_typedef.c,\n+ \ttestsuite/libffi.call/float2.c,\n+ \ttestsuite/libffi.call/huge_struct.c,\n+ \ttestsuite/libffi.call/nested_struct.c,\n+ \ttestsuite/libffi.call/nested_struct1.c,\n+ \ttestsuite/libffi.call/nested_struct10.c,\n+ \ttestsuite/libffi.call/nested_struct2.c,\n+ \ttestsuite/libffi.call/nested_struct3.c,\n+ \ttestsuite/libffi.call/nested_struct4.c,\n+ \ttestsuite/libffi.call/nested_struct5.c,\n+ \ttestsuite/libffi.call/nested_struct6.c,\n+ \ttestsuite/libffi.call/nested_struct7.c,\n+ \ttestsuite/libffi.call/nested_struct8.c,\n+ \ttestsuite/libffi.call/nested_struct9.c,\n+ \ttestsuite/libffi.call/problem1.c,\n+ \ttestsuite/libffi.call/return_ldl.c,\n+ \ttestsuite/libffi.call/return_ll1.c,\n+ \ttestsuite/libffi.call/stret_large.c,\n+ \ttestsuite/libffi.call/stret_large2.c,\n+ \ttestsuite/libffi.call/stret_medium.c,\n+ \ttestsuite/libffi.call/stret_medium2.c,\n+        testsuite/libffi.special/unwindtest.cc: use ffi_closure_alloc instead\n+        of checking for MMAP.  Use intptr_t instead of long casts.\n+\n+2009-06-12  Andrew Haley  <aph@redhat.com>\n+\n+\t* Makefile.am: Remove info_TEXINFOS.\n+\n+2009-06-12  Andrew Haley  <aph@redhat.com>\n+\n+\t* ChangeLog.libffi: testsuite/libffi.call/cls_align_sint64.c,\n+\ttestsuite/libffi.call/cls_align_uint64.c,\n+\ttestsuite/libffi.call/cls_ulonglong.c,\n+\ttestsuite/libffi.call/return_ll1.c,\n+\ttestsuite/libffi.call/stret_medium2.c: Fix printf format\n+\tspecifiers.\n+\ttestsuite/libffi.special/unwindtest.cc: include stdint.h.\n+\n+2009-06-11  Timothy Wall  <twall@users.sf.net>\n+\n+\t* Makefile.am,\n+        configure.ac,\n+        include/ffi.h.in,\n+        include/ffi_common.h,\n+        src/closures.c,\n+        src/dlmalloc.c,\n+        src/x86/ffi.c,\n+        src/x86/ffitarget.h,\n+        src/x86/win64.S (new),\n+\tREADME: Added win64 support (mingw or MSVC)\n+        * Makefile.in,\n+        include/Makefile.in,\n+        man/Makefile.in,\n+        testsuite/Makefile.in,\n+        configure,\n+        aclocal.m4: Regenerated\n+        * ltcf-c.sh: properly escape cygwin/w32 path\n+        * man/ffi_call.3: Clarify size requirements for return value.\n+        * src/x86/ffi64.c: Fix filename in comment.\n+        * src/x86/win32.S: Remove unused extern.\n+\n+        * testsuite/libffi.call/closure_fn0.c,\n+        testsuite/libffi.call/closure_fn1.c,\n+        testsuite/libffi.call/closure_fn2.c,\n+        testsuite/libffi.call/closure_fn3.c,\n+        testsuite/libffi.call/closure_fn4.c,\n+        testsuite/libffi.call/closure_fn5.c,\n+        testsuite/libffi.call/closure_fn6.c,\n+\ttestsuite/libffi.call/closure_stdcall.c,\n+\ttestsuite/libffi.call/cls_12byte.c,\n+\ttestsuite/libffi.call/cls_16byte.c,\n+\ttestsuite/libffi.call/cls_18byte.c,\n+\ttestsuite/libffi.call/cls_19byte.c,\n+\ttestsuite/libffi.call/cls_1_1byte.c,\n+\ttestsuite/libffi.call/cls_20byte.c,\n+\ttestsuite/libffi.call/cls_20byte1.c,\n+\ttestsuite/libffi.call/cls_24byte.c,\n+\ttestsuite/libffi.call/cls_2byte.c,\n+\ttestsuite/libffi.call/cls_3_1byte.c,\n+\ttestsuite/libffi.call/cls_3byte1.c,\n+ \ttestsuite/libffi.call/cls_3byte2.c,\n+ \ttestsuite/libffi.call/cls_4_1byte.c,\n+ \ttestsuite/libffi.call/cls_4byte.c,\n+ \ttestsuite/libffi.call/cls_5_1_byte.c,\n+ \ttestsuite/libffi.call/cls_5byte.c,\n+ \ttestsuite/libffi.call/cls_64byte.c,\n+ \ttestsuite/libffi.call/cls_6_1_byte.c,\n+ \ttestsuite/libffi.call/cls_6byte.c,\n+ \ttestsuite/libffi.call/cls_7_1_byte.c,\n+ \ttestsuite/libffi.call/cls_7byte.c,\n+ \ttestsuite/libffi.call/cls_8byte.c,\n+ \ttestsuite/libffi.call/cls_9byte1.c,\n+ \ttestsuite/libffi.call/cls_9byte2.c,\n+ \ttestsuite/libffi.call/cls_align_double.c,\n+ \ttestsuite/libffi.call/cls_align_float.c,\n+ \ttestsuite/libffi.call/cls_align_longdouble.c,\n+ \ttestsuite/libffi.call/cls_align_longdouble_split.c,\n+ \ttestsuite/libffi.call/cls_align_longdouble_split2.c,\n+ \ttestsuite/libffi.call/cls_align_pointer.c,\n+ \ttestsuite/libffi.call/cls_align_sint16.c,\n+ \ttestsuite/libffi.call/cls_align_sint32.c,\n+ \ttestsuite/libffi.call/cls_align_sint64.c,\n+ \ttestsuite/libffi.call/cls_align_uint16.c,\n+ \ttestsuite/libffi.call/cls_align_uint32.c,\n+ \ttestsuite/libffi.call/cls_align_uint64.c,\n+ \ttestsuite/libffi.call/cls_dbls_struct.c,\n+ \ttestsuite/libffi.call/cls_double.c,\n+ \ttestsuite/libffi.call/cls_double_va.c,\n+ \ttestsuite/libffi.call/cls_float.c,\n+ \ttestsuite/libffi.call/cls_longdouble.c,\n+ \ttestsuite/libffi.call/cls_longdouble_va.c,\n+ \ttestsuite/libffi.call/cls_multi_schar.c,\n+ \ttestsuite/libffi.call/cls_multi_sshort.c,\n+ \ttestsuite/libffi.call/cls_multi_sshortchar.c,\n+ \ttestsuite/libffi.call/cls_multi_uchar.c,\n+ \ttestsuite/libffi.call/cls_multi_ushort.c,\n+ \ttestsuite/libffi.call/cls_multi_ushortchar.c,\n+ \ttestsuite/libffi.call/cls_pointer.c,\n+ \ttestsuite/libffi.call/cls_pointer_stack.c,\n+ \ttestsuite/libffi.call/cls_schar.c,\n+ \ttestsuite/libffi.call/cls_sint.c,\n+ \ttestsuite/libffi.call/cls_sshort.c,\n+ \ttestsuite/libffi.call/cls_uchar.c,\n+ \ttestsuite/libffi.call/cls_uint.c,\n+ \ttestsuite/libffi.call/cls_ulonglong.c,\n+ \ttestsuite/libffi.call/cls_ushort.c,\n+ \ttestsuite/libffi.call/err_bad_abi.c,\n+ \ttestsuite/libffi.call/err_bad_typedef.c,\n+ \ttestsuite/libffi.call/float2.c,\n+ \ttestsuite/libffi.call/huge_struct.c,\n+ \ttestsuite/libffi.call/nested_struct.c,\n+ \ttestsuite/libffi.call/nested_struct1.c,\n+ \ttestsuite/libffi.call/nested_struct10.c,\n+ \ttestsuite/libffi.call/nested_struct2.c,\n+ \ttestsuite/libffi.call/nested_struct3.c,\n+ \ttestsuite/libffi.call/nested_struct4.c,\n+ \ttestsuite/libffi.call/nested_struct5.c,\n+ \ttestsuite/libffi.call/nested_struct6.c,\n+ \ttestsuite/libffi.call/nested_struct7.c,\n+ \ttestsuite/libffi.call/nested_struct8.c,\n+ \ttestsuite/libffi.call/nested_struct9.c,\n+ \ttestsuite/libffi.call/problem1.c,\n+ \ttestsuite/libffi.call/return_ldl.c,\n+ \ttestsuite/libffi.call/return_ll1.c,\n+ \ttestsuite/libffi.call/stret_large.c,\n+ \ttestsuite/libffi.call/stret_large2.c,\n+ \ttestsuite/libffi.call/stret_medium.c,\n+ \ttestsuite/libffi.call/stret_medium2.c,\n+        testsuite/libffi.special/unwindtest.cc: use ffi_closure_alloc instead\n+        of checking for MMAP.  Use intptr_t instead of long casts.\n+\n 2009-06-11  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* testsuite/libffi.call/cls_longdouble_va.c: Add xfail sh*-*-linux-*."}, {"sha": "9705c8f4a9e55b3ffb814c19847116be8adb86f5", "filename": "libffi/Makefile.am", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -31,8 +31,6 @@ EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host \\\n \tsrc/pa/ffitarget.h src/pa/ffi.c src/pa/linux.S src/pa/hpux32.S \\\n \tsrc/frv/ffi.c src/frv/eabi.S src/frv/ffitarget.h src/dlmalloc.c\n \n-info_TEXINFOS = doc/libffi.texi\n-\n ## ################################################################\n \n ##\n@@ -98,6 +96,9 @@ endif\n if X86_WIN32\n nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/win32.S\n endif\n+if X86_WIN64\n+nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/win64.S\n+endif\n if X86_DARWIN\n nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/darwin.S src/x86/ffi64.c src/x86/darwin64.S\n endif"}, {"sha": "32f1ebbfa6296ff372b8627b7f336ce62db3c935", "filename": "libffi/Makefile.in", "status": "modified", "additions": 85, "deletions": 249, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -41,33 +41,33 @@ target_triplet = @target@\n @X86_TRUE@am__append_2 = src/x86/ffi.c src/x86/sysv.S\n @X86_FREEBSD_TRUE@am__append_3 = src/x86/ffi.c src/x86/freebsd.S\n @X86_WIN32_TRUE@am__append_4 = src/x86/ffi.c src/x86/win32.S\n-@X86_DARWIN_TRUE@am__append_5 = src/x86/ffi.c src/x86/darwin.S src/x86/ffi64.c src/x86/darwin64.S\n-@SPARC_TRUE@am__append_6 = src/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S\n-@ALPHA_TRUE@am__append_7 = src/alpha/ffi.c src/alpha/osf.S\n-@IA64_TRUE@am__append_8 = src/ia64/ffi.c src/ia64/unix.S\n-@M32R_TRUE@am__append_9 = src/m32r/sysv.S src/m32r/ffi.c\n-@M68K_TRUE@am__append_10 = src/m68k/ffi.c src/m68k/sysv.S\n-@POWERPC_TRUE@am__append_11 = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S src/powerpc/linux64.S src/powerpc/linux64_closure.S\n-@POWERPC_AIX_TRUE@am__append_12 = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closure.S\n-@POWERPC_DARWIN_TRUE@am__append_13 = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n-@POWERPC_FREEBSD_TRUE@am__append_14 = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n-@ARM_TRUE@am__append_15 = src/arm/sysv.S src/arm/ffi.c\n-@LIBFFI_CRIS_TRUE@am__append_16 = src/cris/sysv.S src/cris/ffi.c\n-@FRV_TRUE@am__append_17 = src/frv/eabi.S src/frv/ffi.c\n-@S390_TRUE@am__append_18 = src/s390/sysv.S src/s390/ffi.c\n-@X86_64_TRUE@am__append_19 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S\n-@SH_TRUE@am__append_20 = src/sh/sysv.S src/sh/ffi.c\n-@SH64_TRUE@am__append_21 = src/sh64/sysv.S src/sh64/ffi.c\n-@PA_LINUX_TRUE@am__append_22 = src/pa/linux.S src/pa/ffi.c\n-@PA_HPUX_TRUE@am__append_23 = src/pa/hpux32.S src/pa/ffi.c\n+@X86_WIN64_TRUE@am__append_5 = src/x86/ffi.c src/x86/win64.S\n+@X86_DARWIN_TRUE@am__append_6 = src/x86/ffi.c src/x86/darwin.S src/x86/ffi64.c src/x86/darwin64.S\n+@SPARC_TRUE@am__append_7 = src/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S\n+@ALPHA_TRUE@am__append_8 = src/alpha/ffi.c src/alpha/osf.S\n+@IA64_TRUE@am__append_9 = src/ia64/ffi.c src/ia64/unix.S\n+@M32R_TRUE@am__append_10 = src/m32r/sysv.S src/m32r/ffi.c\n+@M68K_TRUE@am__append_11 = src/m68k/ffi.c src/m68k/sysv.S\n+@POWERPC_TRUE@am__append_12 = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S src/powerpc/linux64.S src/powerpc/linux64_closure.S\n+@POWERPC_AIX_TRUE@am__append_13 = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closure.S\n+@POWERPC_DARWIN_TRUE@am__append_14 = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n+@POWERPC_FREEBSD_TRUE@am__append_15 = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n+@ARM_TRUE@am__append_16 = src/arm/sysv.S src/arm/ffi.c\n+@LIBFFI_CRIS_TRUE@am__append_17 = src/cris/sysv.S src/cris/ffi.c\n+@FRV_TRUE@am__append_18 = src/frv/eabi.S src/frv/ffi.c\n+@S390_TRUE@am__append_19 = src/s390/sysv.S src/s390/ffi.c\n+@X86_64_TRUE@am__append_20 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S\n+@SH_TRUE@am__append_21 = src/sh/sysv.S src/sh/ffi.c\n+@SH64_TRUE@am__append_22 = src/sh64/sysv.S src/sh64/ffi.c\n+@PA_LINUX_TRUE@am__append_23 = src/pa/linux.S src/pa/ffi.c\n+@PA_HPUX_TRUE@am__append_24 = src/pa/hpux32.S src/pa/ffi.c\n DIST_COMMON = README $(am__configure_deps) $(srcdir)/../compile \\\n \t$(srcdir)/../config.guess $(srcdir)/../config.sub \\\n \t$(srcdir)/../depcomp $(srcdir)/../install-sh \\\n \t$(srcdir)/../ltmain.sh $(srcdir)/../missing \\\n \t$(srcdir)/../mkinstalldirs $(srcdir)/Makefile.am \\\n-\t$(srcdir)/Makefile.in $(srcdir)/doc/stamp-vti \\\n-\t$(srcdir)/doc/version.texi $(srcdir)/fficonfig.h.in \\\n-\t$(top_srcdir)/configure ChangeLog mdate-sh texinfo.tex\n+\t$(srcdir)/Makefile.in $(srcdir)/fficonfig.h.in \\\n+\t$(top_srcdir)/configure ChangeLog\n subdir = .\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n@@ -92,7 +92,7 @@ am__vpath_adj = case $$p in \\\n     *) f=$$p;; \\\n   esac;\n am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;\n-am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\"\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\"\n toolexeclibLTLIBRARIES_INSTALL = $(INSTALL)\n LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)\n libffi_la_LIBADD =\n@@ -104,60 +104,62 @@ am_libffi_la_OBJECTS = src/debug.lo src/prep_cif.lo src/types.lo \\\n @X86_TRUE@am__objects_2 = src/x86/ffi.lo src/x86/sysv.lo\n @X86_FREEBSD_TRUE@am__objects_3 = src/x86/ffi.lo src/x86/freebsd.lo\n @X86_WIN32_TRUE@am__objects_4 = src/x86/ffi.lo src/x86/win32.lo\n-@X86_DARWIN_TRUE@am__objects_5 = src/x86/ffi.lo src/x86/darwin.lo \\\n+@X86_WIN64_TRUE@am__objects_5 = src/x86/ffi.lo src/x86/win64.lo\n+@X86_DARWIN_TRUE@am__objects_6 = src/x86/ffi.lo src/x86/darwin.lo \\\n @X86_DARWIN_TRUE@\tsrc/x86/ffi64.lo src/x86/darwin64.lo\n-@SPARC_TRUE@am__objects_6 = src/sparc/ffi.lo src/sparc/v8.lo \\\n+@SPARC_TRUE@am__objects_7 = src/sparc/ffi.lo src/sparc/v8.lo \\\n @SPARC_TRUE@\tsrc/sparc/v9.lo\n-@ALPHA_TRUE@am__objects_7 = src/alpha/ffi.lo src/alpha/osf.lo\n-@IA64_TRUE@am__objects_8 = src/ia64/ffi.lo src/ia64/unix.lo\n-@M32R_TRUE@am__objects_9 = src/m32r/sysv.lo src/m32r/ffi.lo\n-@M68K_TRUE@am__objects_10 = src/m68k/ffi.lo src/m68k/sysv.lo\n-@POWERPC_TRUE@am__objects_11 = src/powerpc/ffi.lo src/powerpc/sysv.lo \\\n+@ALPHA_TRUE@am__objects_8 = src/alpha/ffi.lo src/alpha/osf.lo\n+@IA64_TRUE@am__objects_9 = src/ia64/ffi.lo src/ia64/unix.lo\n+@M32R_TRUE@am__objects_10 = src/m32r/sysv.lo src/m32r/ffi.lo\n+@M68K_TRUE@am__objects_11 = src/m68k/ffi.lo src/m68k/sysv.lo\n+@POWERPC_TRUE@am__objects_12 = src/powerpc/ffi.lo src/powerpc/sysv.lo \\\n @POWERPC_TRUE@\tsrc/powerpc/ppc_closure.lo \\\n @POWERPC_TRUE@\tsrc/powerpc/linux64.lo \\\n @POWERPC_TRUE@\tsrc/powerpc/linux64_closure.lo\n-@POWERPC_AIX_TRUE@am__objects_12 = src/powerpc/ffi_darwin.lo \\\n+@POWERPC_AIX_TRUE@am__objects_13 = src/powerpc/ffi_darwin.lo \\\n @POWERPC_AIX_TRUE@\tsrc/powerpc/aix.lo \\\n @POWERPC_AIX_TRUE@\tsrc/powerpc/aix_closure.lo\n-@POWERPC_DARWIN_TRUE@am__objects_13 = src/powerpc/ffi_darwin.lo \\\n+@POWERPC_DARWIN_TRUE@am__objects_14 = src/powerpc/ffi_darwin.lo \\\n @POWERPC_DARWIN_TRUE@\tsrc/powerpc/darwin.lo \\\n @POWERPC_DARWIN_TRUE@\tsrc/powerpc/darwin_closure.lo\n-@POWERPC_FREEBSD_TRUE@am__objects_14 = src/powerpc/ffi.lo \\\n+@POWERPC_FREEBSD_TRUE@am__objects_15 = src/powerpc/ffi.lo \\\n @POWERPC_FREEBSD_TRUE@\tsrc/powerpc/sysv.lo \\\n @POWERPC_FREEBSD_TRUE@\tsrc/powerpc/ppc_closure.lo\n-@ARM_TRUE@am__objects_15 = src/arm/sysv.lo src/arm/ffi.lo\n-@LIBFFI_CRIS_TRUE@am__objects_16 = src/cris/sysv.lo src/cris/ffi.lo\n-@FRV_TRUE@am__objects_17 = src/frv/eabi.lo src/frv/ffi.lo\n-@S390_TRUE@am__objects_18 = src/s390/sysv.lo src/s390/ffi.lo\n-@X86_64_TRUE@am__objects_19 = src/x86/ffi64.lo src/x86/unix64.lo \\\n+@ARM_TRUE@am__objects_16 = src/arm/sysv.lo src/arm/ffi.lo\n+@LIBFFI_CRIS_TRUE@am__objects_17 = src/cris/sysv.lo src/cris/ffi.lo\n+@FRV_TRUE@am__objects_18 = src/frv/eabi.lo src/frv/ffi.lo\n+@S390_TRUE@am__objects_19 = src/s390/sysv.lo src/s390/ffi.lo\n+@X86_64_TRUE@am__objects_20 = src/x86/ffi64.lo src/x86/unix64.lo \\\n @X86_64_TRUE@\tsrc/x86/ffi.lo src/x86/sysv.lo\n-@SH_TRUE@am__objects_20 = src/sh/sysv.lo src/sh/ffi.lo\n-@SH64_TRUE@am__objects_21 = src/sh64/sysv.lo src/sh64/ffi.lo\n-@PA_LINUX_TRUE@am__objects_22 = src/pa/linux.lo src/pa/ffi.lo\n-@PA_HPUX_TRUE@am__objects_23 = src/pa/hpux32.lo src/pa/ffi.lo\n+@SH_TRUE@am__objects_21 = src/sh/sysv.lo src/sh/ffi.lo\n+@SH64_TRUE@am__objects_22 = src/sh64/sysv.lo src/sh64/ffi.lo\n+@PA_LINUX_TRUE@am__objects_23 = src/pa/linux.lo src/pa/ffi.lo\n+@PA_HPUX_TRUE@am__objects_24 = src/pa/hpux32.lo src/pa/ffi.lo\n nodist_libffi_la_OBJECTS = $(am__objects_1) $(am__objects_2) \\\n \t$(am__objects_3) $(am__objects_4) $(am__objects_5) \\\n \t$(am__objects_6) $(am__objects_7) $(am__objects_8) \\\n \t$(am__objects_9) $(am__objects_10) $(am__objects_11) \\\n \t$(am__objects_12) $(am__objects_13) $(am__objects_14) \\\n \t$(am__objects_15) $(am__objects_16) $(am__objects_17) \\\n \t$(am__objects_18) $(am__objects_19) $(am__objects_20) \\\n-\t$(am__objects_21) $(am__objects_22) $(am__objects_23)\n+\t$(am__objects_21) $(am__objects_22) $(am__objects_23) \\\n+\t$(am__objects_24)\n libffi_la_OBJECTS = $(am_libffi_la_OBJECTS) \\\n \t$(nodist_libffi_la_OBJECTS)\n libffi_convenience_la_LIBADD =\n-am__objects_24 = src/debug.lo src/prep_cif.lo src/types.lo \\\n+am__objects_25 = src/debug.lo src/prep_cif.lo src/types.lo \\\n \tsrc/raw_api.lo src/java_raw_api.lo src/closures.lo\n-am_libffi_convenience_la_OBJECTS = $(am__objects_24)\n-am__objects_25 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \\\n+am_libffi_convenience_la_OBJECTS = $(am__objects_25)\n+am__objects_26 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \\\n \t$(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_7) $(am__objects_8) $(am__objects_9) \\\n \t$(am__objects_10) $(am__objects_11) $(am__objects_12) \\\n \t$(am__objects_13) $(am__objects_14) $(am__objects_15) \\\n \t$(am__objects_16) $(am__objects_17) $(am__objects_18) \\\n \t$(am__objects_19) $(am__objects_20) $(am__objects_21) \\\n-\t$(am__objects_22) $(am__objects_23)\n-nodist_libffi_convenience_la_OBJECTS = $(am__objects_25)\n+\t$(am__objects_22) $(am__objects_23) $(am__objects_24)\n+nodist_libffi_convenience_la_OBJECTS = $(am__objects_26)\n libffi_convenience_la_OBJECTS = $(am_libffi_convenience_la_OBJECTS) \\\n \t$(nodist_libffi_convenience_la_OBJECTS)\n DEFAULT_INCLUDES = -I. -I$(srcdir) -I.\n@@ -184,18 +186,6 @@ MULTIDIRS =\n MULTISUBDIR = \n MULTIDO = true\n MULTICLEAN = true\n-INFO_DEPS = $(srcdir)/doc/libffi.info\n-am__TEXINFO_TEX_DIR = $(srcdir)\n-DVIS = doc/libffi.dvi\n-PDFS = doc/libffi.pdf\n-PSS = doc/libffi.ps\n-HTMLS = doc/libffi.html\n-TEXINFOS = doc/libffi.texi\n-TEXI2DVI = texi2dvi\n-TEXI2PDF = $(TEXI2DVI) --pdf --batch\n-MAKEINFOHTML = $(MAKEINFO) --html\n-AM_MAKEINFOHTMLFLAGS = $(AM_MAKEINFOFLAGS)\n-DVIPS = dvips\n RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n \thtml-recursive info-recursive install-data-recursive \\\n \tinstall-exec-recursive install-info-recursive \\\n@@ -333,6 +323,8 @@ X86_FREEBSD_TRUE = @X86_FREEBSD_TRUE@\n X86_TRUE = @X86_TRUE@\n X86_WIN32_FALSE = @X86_WIN32_FALSE@\n X86_WIN32_TRUE = @X86_WIN32_TRUE@\n+X86_WIN64_FALSE = @X86_WIN64_FALSE@\n+X86_WIN64_TRUE = @X86_WIN64_TRUE@\n ac_ct_AR = @ac_ct_AR@\n ac_ct_CC = @ac_ct_CC@\n ac_ct_DSYMUTIL = @ac_ct_DSYMUTIL@\n@@ -414,10 +406,8 @@ EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host \\\n \tsrc/x86/ffi.c src/x86/sysv.S src/x86/win32.S src/x86/darwin.S \\\n \tsrc/x86/ffi64.c src/x86/unix64.S src/x86/ffitarget.h \\\n \tsrc/pa/ffitarget.h src/pa/ffi.c src/pa/linux.S src/pa/hpux32.S \\\n-\tsrc/frv/ffi.c src/frv/eabi.S src/frv/ffitarget.h src/dlmalloc.c \\\n-\tlibtool-version ChangeLog.libffi\n+\tsrc/frv/ffi.c src/frv/eabi.S src/frv/ffitarget.h src/dlmalloc.c\n \n-info_TEXINFOS = doc/libffi.texi\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and\n@@ -469,7 +459,8 @@ nodist_libffi_la_SOURCES = $(am__append_1) $(am__append_2) \\\n \t$(am__append_12) $(am__append_13) $(am__append_14) \\\n \t$(am__append_15) $(am__append_16) $(am__append_17) \\\n \t$(am__append_18) $(am__append_19) $(am__append_20) \\\n-\t$(am__append_21) $(am__append_22) $(am__append_23)\n+\t$(am__append_21) $(am__append_22) $(am__append_23) \\\n+\t$(am__append_24)\n libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)\n nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)\n AM_CFLAGS = -Wall -g -fexceptions\n@@ -481,7 +472,7 @@ all: fficonfig.h\n \t$(MAKE) $(AM_MAKEFLAGS) all-recursive\n \n .SUFFIXES:\n-.SUFFIXES: .S .c .dvi .lo .o .obj .ps\n+.SUFFIXES: .S .c .lo .o .obj\n am--refresh:\n \t@:\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n@@ -606,6 +597,8 @@ src/x86/freebsd.lo: src/x86/$(am__dirstamp) \\\n \tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n src/x86/win32.lo: src/x86/$(am__dirstamp) \\\n \tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n+src/x86/win64.lo: src/x86/$(am__dirstamp) \\\n+\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n src/x86/darwin.lo: src/x86/$(am__dirstamp) \\\n \tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n src/x86/ffi64.lo: src/x86/$(am__dirstamp) \\\n@@ -875,6 +868,8 @@ mostlyclean-compile:\n \t-rm -f src/x86/unix64.lo\n \t-rm -f src/x86/win32.$(OBJEXT)\n \t-rm -f src/x86/win32.lo\n+\t-rm -f src/x86/win64.$(OBJEXT)\n+\t-rm -f src/x86/win64.lo\n \n distclean-compile:\n \t-rm -f *.tab.c\n@@ -977,127 +972,7 @@ distclean-multi:\n \t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n maintainer-clean-multi:\n \t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n-doc/$(am__dirstamp):\n-\t@$(mkdir_p) doc\n-\t@: > doc/$(am__dirstamp)\n-\n-$(srcdir)/doc/libffi.info: doc/libffi.texi $(srcdir)/doc/version.texi\n-\trestore=: && backupdir=\"$(am__leading_dot)am$$$$\" && \\\n-\tam__cwd=`pwd` && cd $(srcdir) && \\\n-\trm -rf $$backupdir && mkdir $$backupdir && \\\n-\tif ($(MAKEINFO) --version) >/dev/null 2>&1; then \\\n-\t  for f in $@ $@-[0-9] $@-[0-9][0-9] $(@:.info=).i[0-9] $(@:.info=).i[0-9][0-9]; do \\\n-\t    if test -f $$f; then mv $$f $$backupdir; restore=mv; else :; fi; \\\n-\t  done; \\\n-\telse :; fi && \\\n-\tcd \"$$am__cwd\"; \\\n-\tif $(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I doc -I $(srcdir)/doc \\\n-\t -o $@ $(srcdir)/doc/libffi.texi; \\\n-\tthen \\\n-\t  rc=0; \\\n-\t  cd $(srcdir); \\\n-\telse \\\n-\t  rc=$$?; \\\n-\t  cd $(srcdir) && \\\n-\t  $$restore $$backupdir/* `echo \"./$@\" | sed 's|[^/]*$$||'`; \\\n-\tfi; \\\n-\trm -rf $$backupdir; exit $$rc\n-\n-doc/libffi.dvi: doc/libffi.texi $(srcdir)/doc/version.texi doc/$(am__dirstamp)\n-\tTEXINPUTS=\"$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS\" \\\n-\tMAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I doc -I $(srcdir)/doc' \\\n-\t$(TEXI2DVI) -o $@ `test -f 'doc/libffi.texi' || echo '$(srcdir)/'`doc/libffi.texi\n-\n-doc/libffi.pdf: doc/libffi.texi $(srcdir)/doc/version.texi doc/$(am__dirstamp)\n-\tTEXINPUTS=\"$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS\" \\\n-\tMAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I doc -I $(srcdir)/doc' \\\n-\t$(TEXI2PDF) -o $@ `test -f 'doc/libffi.texi' || echo '$(srcdir)/'`doc/libffi.texi\n-\n-doc/libffi.html: doc/libffi.texi $(srcdir)/doc/version.texi doc/$(am__dirstamp)\n-\trm -rf $(@:.html=.htp)\n-\tif $(MAKEINFOHTML) $(AM_MAKEINFOHTMLFLAGS) $(MAKEINFOFLAGS) -I doc -I $(srcdir)/doc \\\n-\t -o $(@:.html=.htp) `test -f 'doc/libffi.texi' || echo '$(srcdir)/'`doc/libffi.texi; \\\n-\tthen \\\n-\t  rm -rf $@; \\\n-\t  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \\\n-\t    mv $(@:.html=) $@; else mv $(@:.html=.htp) $@; fi; \\\n-\telse \\\n-\t  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \\\n-\t    rm -rf $(@:.html=); else rm -Rf $(@:.html=.htp) $@; fi; \\\n-\t  exit 1; \\\n-\tfi\n-$(srcdir)/doc/version.texi: @MAINTAINER_MODE_TRUE@ $(srcdir)/doc/stamp-vti\n-$(srcdir)/doc/stamp-vti: doc/libffi.texi $(top_srcdir)/configure\n-\ttest -f doc/$(am__dirstamp) || $(MAKE) doc/$(am__dirstamp)\n-\t@(dir=.; test -f ./doc/libffi.texi || dir=$(srcdir); \\\n-\tset `$(SHELL) $(srcdir)/mdate-sh $$dir/doc/libffi.texi`; \\\n-\techo \"@set UPDATED $$1 $$2 $$3\"; \\\n-\techo \"@set UPDATED-MONTH $$2 $$3\"; \\\n-\techo \"@set EDITION $(VERSION)\"; \\\n-\techo \"@set VERSION $(VERSION)\") > vti.tmp\n-\t@cmp -s vti.tmp $(srcdir)/doc/version.texi \\\n-\t  || (echo \"Updating $(srcdir)/doc/version.texi\"; \\\n-\t      cp vti.tmp $(srcdir)/doc/version.texi)\n-\t-@rm -f vti.tmp\n-\t@cp $(srcdir)/doc/version.texi $@\n-\n-mostlyclean-vti:\n-\t-rm -f vti.tmp\n-\n-maintainer-clean-vti:\n-@MAINTAINER_MODE_TRUE@\t-rm -f $(srcdir)/doc/stamp-vti $(srcdir)/doc/version.texi\n-.dvi.ps:\n-\tTEXINPUTS=\"$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS\" \\\n-\t$(DVIPS) -o $@ $<\n-\n uninstall-info-am:\n-\t@$(PRE_UNINSTALL)\n-\t@if (install-info --version && \\\n-\t     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \\\n-\t  list='$(INFO_DEPS)'; \\\n-\t  for file in $$list; do \\\n-\t    relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n-\t    echo \" install-info --info-dir='$(DESTDIR)$(infodir)' --remove '$(DESTDIR)$(infodir)/$$relfile'\"; \\\n-\t    install-info --info-dir=\"$(DESTDIR)$(infodir)\" --remove \"$(DESTDIR)$(infodir)/$$relfile\"; \\\n-\t  done; \\\n-\telse :; fi\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(INFO_DEPS)'; \\\n-\tfor file in $$list; do \\\n-\t  relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n-\t  relfile_i=`echo \"$$relfile\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n-\t  (if cd \"$(DESTDIR)$(infodir)\"; then \\\n-\t     echo \" cd '$(DESTDIR)$(infodir)' && rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]\"; \\\n-\t     rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]; \\\n-\t   else :; fi); \\\n-\tdone\n-\n-dist-info: $(INFO_DEPS)\n-\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n-\tlist='$(INFO_DEPS)'; \\\n-\tfor base in $$list; do \\\n-\t  case $$base in \\\n-\t    $(srcdir)/*) base=`echo \"$$base\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-\t  esac; \\\n-\t  if test -f $$base; then d=.; else d=$(srcdir); fi; \\\n-\t  for file in $$d/$$base*; do \\\n-\t    relfile=`expr \"$$file\" : \"$$d/\\(.*\\)\"`; \\\n-\t    test -f $(distdir)/$$relfile || \\\n-\t      cp -p $$file $(distdir)/$$relfile; \\\n-\t  done; \\\n-\tdone\n-\n-mostlyclean-aminfo:\n-\t-rm -rf libffi.aux libffi.cp libffi.cps libffi.fn libffi.ky libffi.log \\\n-\t  libffi.pg libffi.tmp libffi.toc libffi.tp libffi.vr \\\n-\t  doc/libffi.dvi doc/libffi.pdf doc/libffi.ps doc/libffi.html\n-\n-maintainer-clean-aminfo:\n-\t@list='$(INFO_DEPS)'; for i in $$list; do \\\n-\t  i_i=`echo \"$$i\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n-\t  echo \" rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]\"; \\\n-\t  rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]; \\\n-\tdone\n \n # This directory's subdirectories are mostly independent; you can cd\n # into them and run `make' without going through this Makefile.\n@@ -1234,7 +1109,7 @@ distclean-tags:\n distdir: $(DISTFILES)\n \t$(am__remove_distdir)\n \tmkdir $(distdir)\n-\t$(mkdir_p) $(distdir)/.. $(distdir)/../config $(distdir)/doc $(distdir)/include $(distdir)/src $(distdir)/src/alpha $(distdir)/src/arm $(distdir)/src/cris $(distdir)/src/frv $(distdir)/src/ia64 $(distdir)/src/m32r $(distdir)/src/m68k $(distdir)/src/mips $(distdir)/src/pa $(distdir)/src/powerpc $(distdir)/src/s390 $(distdir)/src/sh $(distdir)/src/sh64 $(distdir)/src/sparc $(distdir)/src/x86\n+\t$(mkdir_p) $(distdir)/.. $(distdir)/../config $(distdir)/include $(distdir)/src $(distdir)/src/alpha $(distdir)/src/arm $(distdir)/src/cris $(distdir)/src/frv $(distdir)/src/ia64 $(distdir)/src/m32r $(distdir)/src/m68k $(distdir)/src/mips $(distdir)/src/pa $(distdir)/src/powerpc $(distdir)/src/s390 $(distdir)/src/sh $(distdir)/src/sh64 $(distdir)/src/sparc $(distdir)/src/x86\n \t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n \ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's|.|.|g'`; \\\n \tlist='$(DISTFILES)'; for file in $$list; do \\\n@@ -1276,9 +1151,6 @@ distdir: $(DISTFILES)\n \t      || exit 1; \\\n \t  fi; \\\n \tdone\n-\t$(MAKE) $(AM_MAKEFLAGS) \\\n-\t  top_distdir=\"$(top_distdir)\" distdir=\"$(distdir)\" \\\n-\t  dist-info\n \t-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \\; -o \\\n \t  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \\; -o \\\n \t  ! -type d ! -perm -400 -exec chmod a+r {} \\; -o \\\n@@ -1378,10 +1250,10 @@ distcleancheck: distclean\n \t       exit 1; } >&2\n check-am: all-am\n check: check-recursive\n-all-am: Makefile $(INFO_DEPS) $(LTLIBRARIES) all-multi fficonfig.h\n+all-am: Makefile $(LTLIBRARIES) all-multi fficonfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n \t  test -z \"$$dir\" || $(mkdir_p) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -1404,7 +1276,6 @@ clean-generic:\n \n distclean-generic:\n \t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n-\t-rm -f doc/$(am__dirstamp)\n \t-rm -f src/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f src/$(am__dirstamp)\n \t-rm -f src/alpha/$(DEPDIR)/$(am__dirstamp)\n@@ -1455,52 +1326,20 @@ distclean-am: clean-am distclean-compile distclean-generic \\\n \n dvi: dvi-recursive\n \n-dvi-am: $(DVIS)\n+dvi-am:\n \n html: html-recursive\n \n-html-am: $(HTMLS)\n-\n info: info-recursive\n \n-info-am: $(INFO_DEPS)\n+info-am:\n \n-install-data-am: install-info-am\n+install-data-am:\n \n install-exec-am: install-multi install-toolexeclibLTLIBRARIES\n \n install-info: install-info-recursive\n \n-install-info-am: $(INFO_DEPS)\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(infodir)\" || $(mkdir_p) \"$(DESTDIR)$(infodir)\"\n-\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n-\tlist='$(INFO_DEPS)'; \\\n-\tfor file in $$list; do \\\n-\t  case $$file in \\\n-\t    $(srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-\t  esac; \\\n-\t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n-\t  file_i=`echo \"$$file\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n-\t  for ifile in $$d/$$file $$d/$$file-[0-9] $$d/$$file-[0-9][0-9] \\\n-                       $$d/$$file_i[0-9] $$d/$$file_i[0-9][0-9] ; do \\\n-\t    if test -f $$ifile; then \\\n-\t      relfile=`echo \"$$ifile\" | sed 's|^.*/||'`; \\\n-\t      echo \" $(INSTALL_DATA) '$$ifile' '$(DESTDIR)$(infodir)/$$relfile'\"; \\\n-\t      $(INSTALL_DATA) \"$$ifile\" \"$(DESTDIR)$(infodir)/$$relfile\"; \\\n-\t    else : ; fi; \\\n-\t  done; \\\n-\tdone\n-\t@$(POST_INSTALL)\n-\t@if (install-info --version && \\\n-\t     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \\\n-\t  list='$(INFO_DEPS)'; \\\n-\t  for file in $$list; do \\\n-\t    relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n-\t    echo \" install-info --info-dir='$(DESTDIR)$(infodir)' '$(DESTDIR)$(infodir)/$$relfile'\";\\\n-\t    install-info --info-dir=\"$(DESTDIR)$(infodir)\" \"$(DESTDIR)$(infodir)/$$relfile\" || :;\\\n-\t  done; \\\n-\telse : ; fi\n install-man:\n \n installcheck-am:\n@@ -1510,21 +1349,20 @@ maintainer-clean: maintainer-clean-multi maintainer-clean-recursive\n \t-rm -rf $(top_srcdir)/autom4te.cache\n \t-rm -rf src/$(DEPDIR) src/alpha/$(DEPDIR) src/arm/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/mips/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/x86/$(DEPDIR)\n \t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-aminfo \\\n-\tmaintainer-clean-generic maintainer-clean-vti\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n \n mostlyclean: mostlyclean-multi mostlyclean-recursive\n \n-mostlyclean-am: mostlyclean-aminfo mostlyclean-compile \\\n-\tmostlyclean-generic mostlyclean-libtool mostlyclean-vti\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n \n pdf: pdf-recursive\n \n-pdf-am: $(PDFS)\n+pdf-am:\n \n ps: ps-recursive\n \n-ps-am: $(PSS)\n+ps-am:\n \n uninstall-am: uninstall-info-am uninstall-toolexeclibLTLIBRARIES\n \n@@ -1534,23 +1372,21 @@ uninstall-info: uninstall-info-recursive\n \tam--refresh check check-am clean clean-generic clean-libtool \\\n \tclean-multi clean-noinstLTLIBRARIES clean-recursive \\\n \tclean-toolexeclibLTLIBRARIES ctags ctags-recursive dist \\\n-\tdist-all dist-bzip2 dist-gzip dist-info dist-shar dist-tarZ \\\n-\tdist-zip distcheck distclean distclean-compile \\\n-\tdistclean-generic distclean-hdr distclean-libtool \\\n-\tdistclean-multi distclean-recursive distclean-tags \\\n-\tdistcleancheck distdir distuninstallcheck dvi dvi-am html \\\n-\thtml-am info info-am install install-am install-data \\\n-\tinstall-data-am install-exec install-exec-am install-info \\\n-\tinstall-info-am install-man install-multi install-strip \\\n-\tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n-\tinstalldirs installdirs-am maintainer-clean \\\n-\tmaintainer-clean-aminfo maintainer-clean-generic \\\n-\tmaintainer-clean-multi maintainer-clean-recursive \\\n-\tmaintainer-clean-vti mostlyclean mostlyclean-aminfo \\\n+\tdist-all dist-bzip2 dist-gzip dist-shar dist-tarZ dist-zip \\\n+\tdistcheck distclean distclean-compile distclean-generic \\\n+\tdistclean-hdr distclean-libtool distclean-multi \\\n+\tdistclean-recursive distclean-tags distcleancheck distdir \\\n+\tdistuninstallcheck dvi dvi-am html html-am info info-am \\\n+\tinstall install-am install-data install-data-am install-exec \\\n+\tinstall-exec-am install-info install-info-am install-man \\\n+\tinstall-multi install-strip install-toolexeclibLTLIBRARIES \\\n+\tinstallcheck installcheck-am installdirs installdirs-am \\\n+\tmaintainer-clean maintainer-clean-generic \\\n+\tmaintainer-clean-multi maintainer-clean-recursive mostlyclean \\\n \tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n-\tmostlyclean-multi mostlyclean-recursive mostlyclean-vti pdf \\\n-\tpdf-am ps ps-am tags tags-recursive uninstall uninstall-am \\\n-\tuninstall-info-am uninstall-toolexeclibLTLIBRARIES\n+\tmostlyclean-multi mostlyclean-recursive pdf pdf-am ps ps-am \\\n+\ttags tags-recursive uninstall uninstall-am uninstall-info-am \\\n+\tuninstall-toolexeclibLTLIBRARIES\n \n \n # No install-html or install-pdf support in automake yet"}, {"sha": "f102612d11ce5cddcf5c4e5b83fed2a04133ede8", "filename": "libffi/README", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FREADME?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -61,6 +61,7 @@ release was only tested on:\n      x86 linux\n      x86 openbsd\n      x86 solaris\n+     x86-64 mingw\n      x86-64 darwin\n      x86-64 linux\n      x86-64 OS X"}, {"sha": "fe3a5fb075a9f87c6e45ddb57ce99c74bbaae3ef", "filename": "libffi/configure.ac", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.ac?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -146,6 +146,7 @@ case \"$host\" in\n \tTARGET=X86_DARWIN; TARGETDIR=x86\n \t;;\n   x86_64-*-cygwin* | x86_64-*-mingw*)\n+\tTARGET=X86_WIN64; TARGETDIR=x86\n \t;;\n   x86_64-*-*)\n \tTARGET=X86_64; TARGETDIR=x86\n@@ -163,6 +164,7 @@ AM_CONDITIONAL(SPARC, test x$TARGET = xSPARC)\n AM_CONDITIONAL(X86, test x$TARGET = xX86)\n AM_CONDITIONAL(X86_FREEBSD, test x$TARGET = xX86_FREEBSD)\n AM_CONDITIONAL(X86_WIN32, test x$TARGET = xX86_WIN32)\n+AM_CONDITIONAL(X86_WIN64, test x$TARGET = xX86_WIN64)\n AM_CONDITIONAL(X86_DARWIN, test x$TARGET = xX86_DARWIN)\n AM_CONDITIONAL(ALPHA, test x$TARGET = xALPHA)\n AM_CONDITIONAL(IA64, test x$TARGET = xIA64)"}, {"sha": "a81fb1aacd4575bec291c413338289f9e84f24fe", "filename": "libffi/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2FMakefile.in?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -186,6 +186,8 @@ X86_FREEBSD_TRUE = @X86_FREEBSD_TRUE@\n X86_TRUE = @X86_TRUE@\n X86_WIN32_FALSE = @X86_WIN32_FALSE@\n X86_WIN32_TRUE = @X86_WIN32_TRUE@\n+X86_WIN64_FALSE = @X86_WIN64_FALSE@\n+X86_WIN64_TRUE = @X86_WIN64_TRUE@\n ac_ct_AR = @ac_ct_AR@\n ac_ct_CC = @ac_ct_CC@\n ac_ct_DSYMUTIL = @ac_ct_DSYMUTIL@"}, {"sha": "a06d626c2d7b6a3725a2dcf824d1afd31f6f29ce", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -65,6 +65,10 @@ extern \"C\" {\n \n #ifndef LIBFFI_ASM\n \n+#ifdef _MSC_VER\n+#define __attribute__(X)\n+#endif\n+\n #include <stddef.h>\n #include <limits.h>\n "}, {"sha": "16c5f8859f7515912929fe48b555037a8b21c55d", "filename": "libffi/include/ffi_common.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Finclude%2Fffi_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Finclude%2Fffi_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi_common.h?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -18,7 +18,10 @@ extern \"C\" {\n /* Do not move this. Some versions of AIX are very picky about where\n    this is positioned. */\n #ifdef __GNUC__\n+/* mingw64 defines this already in malloc.h. */\n+#ifndef alloca\n # define alloca __builtin_alloca\n+#endif\n # define MAYBE_UNUSED __attribute__((__unused__))\n #else\n # define MAYBE_UNUSED\n@@ -29,7 +32,11 @@ extern \"C\" {\n  #pragma alloca\n #  else\n #   ifndef alloca /* predefined by HP cc +Olibcalls */\n+#    ifdef _MSC_VER\n+#     define alloca _alloca\n+#    else\n char *alloca ();\n+#    endif\n #   endif\n #  endif\n # endif\n@@ -77,6 +84,16 @@ typedef struct\n } extended_cif;\n \n /* Terse sized type definitions.  */\n+#ifdef _MSC_VER\n+typedef unsigned char UINT8;\n+typedef signed char   SINT8;\n+typedef unsigned short UINT16;\n+typedef signed short   SINT16;\n+typedef unsigned int UINT32;\n+typedef signed int   SINT32;\n+typedef unsigned __int64 UINT64;\n+typedef signed __int64   SINT64;\n+#else\n typedef unsigned int UINT8  __attribute__((__mode__(__QI__)));\n typedef signed int   SINT8  __attribute__((__mode__(__QI__)));\n typedef unsigned int UINT16 __attribute__((__mode__(__HI__)));\n@@ -85,6 +102,7 @@ typedef unsigned int UINT32 __attribute__((__mode__(__SI__)));\n typedef signed int   SINT32 __attribute__((__mode__(__SI__)));\n typedef unsigned int UINT64 __attribute__((__mode__(__DI__)));\n typedef signed int   SINT64 __attribute__((__mode__(__DI__)));\n+#endif\n \n typedef float FLOAT32;\n "}, {"sha": "65d575cf2f736f36aaf00ebc7d5de76c4ee85f08", "filename": "libffi/man/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fman%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fman%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fman%2FMakefile.in?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -177,6 +177,8 @@ X86_FREEBSD_TRUE = @X86_FREEBSD_TRUE@\n X86_TRUE = @X86_TRUE@\n X86_WIN32_FALSE = @X86_WIN32_FALSE@\n X86_WIN32_TRUE = @X86_WIN32_TRUE@\n+X86_WIN64_FALSE = @X86_WIN64_FALSE@\n+X86_WIN64_TRUE = @X86_WIN64_TRUE@\n ac_ct_AR = @ac_ct_AR@\n ac_ct_CC = @ac_ct_CC@\n ac_ct_DSYMUTIL = @ac_ct_DSYMUTIL@"}, {"sha": "0b692c50002b2f9e603a1e34c82cd182c7c5dc3c", "filename": "libffi/man/ffi_call.3", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fman%2Fffi_call.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fman%2Fffi_call.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fman%2Fffi_call.3?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -34,8 +34,8 @@ before it is used with\n .Nm ffi_call .\n .Pp\n .Fa rvalue\n-must point to storage that is sizeof(long) or larger. For smaller\n-return value sizes, the\n+must point to storage that is sizeof(ffi_arg) or larger for non-floating point\n+types. For smaller-sized return value types, the\n .Nm ffi_arg\n or\n .Nm ffi_sarg"}, {"sha": "7692c857162630b0c4abe7e021c2ee163ad41477", "filename": "libffi/src/closures.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fclosures.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fclosures.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fclosures.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -42,6 +42,13 @@\n    locations in the virtual memory space, one location writable and\n    another executable.  */\n #  define FFI_MMAP_EXEC_WRIT 1\n+#  define HAVE_MNTENT 1\n+# endif\n+# if defined(X86_WIN32) || defined(X86_WIN64)\n+/* Windows systems may have Data Execution Protection (DEP) enabled, \n+   which requires the use of VirtualMalloc/VirtualFree to alloc/free\n+   executable memory. */\n+#  define FFI_MMAP_EXEC_WRIT 1\n # endif\n #endif\n \n@@ -60,7 +67,11 @@\n \n #define USE_LOCKS 1\n #define USE_DL_PREFIX 1\n+#ifdef __GNUC__\n+#ifndef USE_BUILTIN_FFS\n #define USE_BUILTIN_FFS 1\n+#endif\n+#endif\n \n /* We need to use mmap, not sbrk.  */\n #define HAVE_MORECORE 0\n@@ -90,10 +101,15 @@\n #include <sys/stat.h>\n #include <fcntl.h>\n #include <errno.h>\n+#ifndef _MSC_VER\n #include <unistd.h>\n+#endif\n #include <string.h>\n #include <stdio.h>\n+#if !defined(X86_WIN32) && !defined(X86_WIN64)\n+#ifdef HAVE_MNTENT\n #include <mntent.h>\n+#endif /* HAVE_MNTENT */\n #include <sys/param.h>\n #include <pthread.h>\n \n@@ -150,6 +166,7 @@ selinux_enabled_check (void)\n #define is_selinux_enabled() 0\n \n #endif\n+#endif /* !defined(X86_WIN32) && !defined(X86_WIN64) */\n \n /* Declare all functions defined in dlmalloc.c as static.  */\n static void *dlmalloc(size_t);\n@@ -168,9 +185,11 @@ static int dlmalloc_trim(size_t) MAYBE_UNUSED;\n static size_t dlmalloc_usable_size(void*) MAYBE_UNUSED;\n static void dlmalloc_stats(void) MAYBE_UNUSED;\n \n+#if !defined(X86_WIN32) && !defined(X86_WIN64)\n /* Use these for mmap and munmap within dlmalloc.c.  */\n static void *dlmmap(void *, size_t, int, int, int, off_t);\n static int dlmunmap(void *, size_t);\n+#endif /* !defined(X86_WIN32) && !defined(X86_WIN64) */\n \n #define mmap dlmmap\n #define munmap dlmunmap\n@@ -180,6 +199,8 @@ static int dlmunmap(void *, size_t);\n #undef mmap\n #undef munmap\n \n+#if !defined(X86_WIN32) && !defined(X86_WIN64)\n+\n /* A mutex used to synchronize access to *exec* variables in this file.  */\n static pthread_mutex_t open_temp_exec_file_mutex = PTHREAD_MUTEX_INITIALIZER;\n \n@@ -232,6 +253,7 @@ open_temp_exec_file_env (const char *envvar)\n   return open_temp_exec_file_dir (value);\n }\n \n+#ifdef HAVE_MNTENT\n /* Open a temporary file in an executable and writable mount point\n    listed in the mounts file.  Subsequent calls with the same mounts\n    keep searching for mount points in the same file.  Providing NULL\n@@ -278,6 +300,7 @@ open_temp_exec_file_mnt (const char *mounts)\n \treturn fd;\n     }\n }\n+#endif /* HAVE_MNTENT */\n \n /* Instructions to look for a location to hold a temporary file that\n    can be mapped in for execution.  */\n@@ -292,8 +315,10 @@ static struct\n   { open_temp_exec_file_dir, \"/var/tmp\", 0 },\n   { open_temp_exec_file_dir, \"/dev/shm\", 0 },\n   { open_temp_exec_file_env, \"HOME\", 0 },\n+#ifdef HAVE_MNTENT\n   { open_temp_exec_file_mnt, \"/etc/mtab\", 1 },\n   { open_temp_exec_file_mnt, \"/proc/mounts\", 1 },\n+#endif /* HAVE_MNTENT */\n };\n \n /* Current index into open_temp_exec_file_opts.  */\n@@ -489,6 +514,8 @@ segment_holding_code (mstate m, char* addr)\n }\n #endif\n \n+#endif /* !defined(X86_WIN32) && !defined(X86_WIN64) */\n+\n /* Allocate a chunk of memory with the given size.  Returns a pointer\n    to the writable address, and sets *CODE to the executable\n    corresponding virtual address.  */"}, {"sha": "783c5c2a6f978852200a8a9d307c11b40761d579", "filename": "libffi/src/dlmalloc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fdlmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fdlmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fdlmalloc.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -1140,9 +1140,9 @@ int mspace_mallopt(int, int);\n \n /*------------------------------ internal #includes ---------------------- */\n \n-#ifdef WIN32\n+#ifdef _MSC_VER\n #pragma warning( disable : 4146 ) /* no \"unsigned\" warnings */\n-#endif /* WIN32 */\n+#endif /* _MSC_VER */\n \n #include <stdio.h>       /* for printing in malloc_stats */\n \n@@ -1315,14 +1315,14 @@ static int dev_zero_fd = -1; /* Cached file descriptor for /dev/zero. */\n \n /* Win32 MMAP via VirtualAlloc */\n static void* win32mmap(size_t size) {\n-  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);\n+  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n   return (ptr != 0)? ptr: MFAIL;\n }\n \n /* For direct MMAP, use MEM_TOP_DOWN to minimize interference */\n static void* win32direct_mmap(size_t size) {\n   void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,\n-                           PAGE_READWRITE);\n+                           PAGE_EXECUTE_READWRITE);\n   return (ptr != 0)? ptr: MFAIL;\n }\n "}, {"sha": "c89c8fc747568a6c96bd9b86831d5743bfa2856a", "filename": "libffi/src/x86/ffi.c", "status": "modified", "additions": 293, "deletions": 86, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fx86%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fx86%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -3,7 +3,7 @@\n            Copyright (c) 2002  Ranjit Mathew\n            Copyright (c) 2002  Bo Thorsen\n            Copyright (c) 2002  Roger Sayle\n-\t   Copyright (C) 2008  Free Software Foundation, Inc.\n+           Copyright (C) 2008  Free Software Foundation, Inc.\n \n    x86 Foreign Function Interface\n \n@@ -28,7 +28,11 @@\n    DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n-#ifndef __x86_64__\n+#if !defined(__x86_64__) || defined(_WIN64)\n+\n+#ifdef _WIN64\n+#include <windows.h>\n+#endif\n \n #include <ffi.h>\n #include <ffi_common.h>\n@@ -47,10 +51,15 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n \n   argp = stack;\n \n-  if (ecif->cif->flags == FFI_TYPE_STRUCT)\n+  if (ecif->cif->flags == FFI_TYPE_STRUCT\n+#ifdef X86_WIN64\n+      && (ecif->cif->rtype->size != 1 && ecif->cif->rtype->size != 2\n+          && ecif->cif->rtype->size != 4 && ecif->cif->rtype->size != 8)\n+#endif\n+      )\n     {\n       *(void **) argp = ecif->rvalue;\n-      argp += 4;\n+      argp += sizeof(void*);\n     }\n \n   p_argv = ecif->avalue;\n@@ -62,53 +71,75 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n       size_t z;\n \n       /* Align if necessary */\n-      if ((sizeof(int) - 1) & (unsigned) argp)\n-\targp = (char *) ALIGN(argp, sizeof(int));\n+      if ((sizeof(void*) - 1) & (size_t) argp)\n+        argp = (char *) ALIGN(argp, sizeof(void*));\n \n       z = (*p_arg)->size;\n-      if (z < sizeof(int))\n-\t{\n-\t  z = sizeof(int);\n-\t  switch ((*p_arg)->type)\n-\t    {\n-\t    case FFI_TYPE_SINT8:\n-\t      *(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);\n-\t      break;\n-\n-\t    case FFI_TYPE_UINT8:\n-\t      *(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);\n-\t      break;\n-\n-\t    case FFI_TYPE_SINT16:\n-\t      *(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);\n-\t      break;\n-\n-\t    case FFI_TYPE_UINT16:\n-\t      *(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);\n-\t      break;\n-\n-\t    case FFI_TYPE_SINT32:\n-\t      *(signed int *) argp = (signed int)*(SINT32 *)(* p_argv);\n-\t      break;\n-\n-\t    case FFI_TYPE_UINT32:\n-\t      *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);\n-\t      break;\n-\n-\t    case FFI_TYPE_STRUCT:\n-\t      *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);\n-\t      break;\n-\n-\t    default:\n-\t      FFI_ASSERT(0);\n-\t    }\n-\t}\n+#ifdef X86_WIN64\n+      if (z > sizeof(ffi_arg)\n+          || ((*p_arg)->type == FFI_TYPE_STRUCT\n+              && (z != 1 && z != 2 && z != 4 && z != 8))\n+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE\n+          || ((*p_arg)->type == FFI_TYPE_LONGDOUBLE)\n+#endif\n+          )\n+        {\n+          z = sizeof(ffi_arg);\n+          *(void **)argp = *p_argv;\n+        }\n+      else if ((*p_arg)->type == FFI_TYPE_FLOAT)\n+        {\n+          memcpy(argp, *p_argv, z);\n+        }\n       else\n-\t{\n-\t  memcpy(argp, *p_argv, z);\n-\t}\n+#endif\n+      if (z < sizeof(ffi_arg))\n+        {\n+          z = sizeof(ffi_arg);\n+          switch ((*p_arg)->type)\n+            {\n+            case FFI_TYPE_SINT8:\n+              *(ffi_sarg *) argp = (ffi_sarg)*(SINT8 *)(* p_argv);\n+              break;\n+\n+            case FFI_TYPE_UINT8:\n+              *(ffi_arg *) argp = (ffi_arg)*(UINT8 *)(* p_argv);\n+              break;\n+\n+            case FFI_TYPE_SINT16:\n+              *(ffi_sarg *) argp = (ffi_sarg)*(SINT16 *)(* p_argv);\n+              break;\n+\n+            case FFI_TYPE_UINT16:\n+              *(ffi_arg *) argp = (ffi_arg)*(UINT16 *)(* p_argv);\n+              break;\n+\n+            case FFI_TYPE_SINT32:\n+              *(ffi_sarg *) argp = (ffi_sarg)*(SINT32 *)(* p_argv);\n+              break;\n+\n+            case FFI_TYPE_UINT32:\n+              *(ffi_arg *) argp = (ffi_arg)*(UINT32 *)(* p_argv);\n+              break;\n+\n+            case FFI_TYPE_STRUCT:\n+              *(ffi_arg *) argp = *(ffi_arg *)(* p_argv);\n+              break;\n+\n+            default:\n+              FFI_ASSERT(0);\n+            }\n+        }\n+      else\n+        {\n+          memcpy(argp, *p_argv, z);\n+        }\n       p_argv++;\n+#ifdef X86_WIN64\n+      argp += (z + sizeof(void*) - 1) & ~(sizeof(void*) - 1);\n+#else\n       argp += z;\n+#endif\n     }\n   \n   return;\n@@ -124,21 +155,32 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n #ifdef X86\n     case FFI_TYPE_STRUCT:\n #endif\n-#if defined(X86) || defined(X86_DARWIN)\n+#if defined(X86) || defined(X86_DARWIN) || defined(X86_WIN64)\n     case FFI_TYPE_UINT8:\n     case FFI_TYPE_UINT16:\n     case FFI_TYPE_SINT8:\n     case FFI_TYPE_SINT16:\n #endif\n+#ifdef X86_WIN64\n+    case FFI_TYPE_UINT32:\n+    case FFI_TYPE_SINT32:\n+#endif\n \n     case FFI_TYPE_SINT64:\n     case FFI_TYPE_FLOAT:\n     case FFI_TYPE_DOUBLE:\n+#ifndef X86_WIN64\n+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE\n     case FFI_TYPE_LONGDOUBLE:\n+#endif\n+#endif\n       cif->flags = (unsigned) cif->rtype->type;\n       break;\n \n     case FFI_TYPE_UINT64:\n+#ifdef X86_WIN64\n+    case FFI_TYPE_POINTER:\n+#endif\n       cif->flags = FFI_TYPE_SINT64;\n       break;\n \n@@ -154,7 +196,11 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n         }\n       else if (cif->rtype->size == 4)\n         {\n+#ifdef X86_WIN64\n+          cif->flags = FFI_TYPE_SMALL_STRUCT_4B;\n+#else\n           cif->flags = FFI_TYPE_INT; /* same as int type */\n+#endif\n         }\n       else if (cif->rtype->size == 8)\n         {\n@@ -163,30 +209,62 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       else\n         {\n           cif->flags = FFI_TYPE_STRUCT;\n+#ifdef X86_WIN64\n+          // allocate space for return value pointer\n+          cif->bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);\n+#endif\n         }\n       break;\n #endif\n \n     default:\n+#ifdef X86_WIN64\n+      cif->flags = FFI_TYPE_SINT64;\n+      break;\n+    case FFI_TYPE_INT:\n+      cif->flags = FFI_TYPE_SINT32;\n+#else\n       cif->flags = FFI_TYPE_INT;\n+#endif\n       break;\n     }\n \n #ifdef X86_DARWIN\n   cif->bytes = (cif->bytes + 15) & ~0xF;\n #endif\n \n+#ifdef X86_WIN64\n+  {\n+    unsigned int i;\n+    ffi_type **ptr;\n+\n+    for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n+      {\n+        if (((*ptr)->alignment - 1) & cif->bytes)\n+          cif->bytes = ALIGN(cif->bytes, (*ptr)->alignment);\n+        cif->bytes += ALIGN((*ptr)->size, FFI_SIZEOF_ARG);\n+      }\n+  }\n+  // ensure space for storing four registers\n+  cif->bytes += 4 * sizeof(ffi_arg);\n+#endif\n+\n   return FFI_OK;\n }\n \n extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,\n-\t\t\t  unsigned, unsigned, unsigned *, void (*fn)(void));\n+                          unsigned, unsigned, unsigned *, void (*fn)(void));\n \n #ifdef X86_WIN32\n extern void ffi_call_STDCALL(void (*)(char *, extended_cif *), extended_cif *,\n-\t\t\t  unsigned, unsigned, unsigned *, void (*fn)(void));\n+                          unsigned, unsigned, unsigned *, void (*fn)(void));\n \n #endif /* X86_WIN32 */\n+#ifdef X86_WIN64\n+extern int\n+ffi_call_win64(void (*)(char *, extended_cif *), extended_cif *,\n+               unsigned, unsigned, unsigned *, void (*fn)(void));\n+#endif\n \n void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n {\n@@ -195,30 +273,66 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n   ecif.cif = cif;\n   ecif.avalue = avalue;\n   \n-  /* If the return value is a struct and we don't have a return\t*/\n-  /* value address then we need to make one\t\t        */\n-\n-  if ((rvalue == NULL) && \n-      (cif->flags == FFI_TYPE_STRUCT))\n+  /* If the return value is a struct and we don't have a return */\n+  /* value address then we need to make one                     */\n+\n+#ifdef X86_WIN64\n+  if (rvalue == NULL\n+      && cif->flags == FFI_TYPE_STRUCT\n+      && cif->rtype->size != 1 && cif->rtype->size != 2\n+      && cif->rtype->size != 4 && cif->rtype->size != 8)\n+    {\n+      ecif.rvalue = alloca((cif->rtype->size + 0xF) & ~0xF);\n+    }\n+#else\n+  if (rvalue == NULL\n+      && cif->flags == FFI_TYPE_STRUCT)\n     {\n       ecif.rvalue = alloca(cif->rtype->size);\n     }\n+#endif\n   else\n     ecif.rvalue = rvalue;\n     \n   \n   switch (cif->abi) \n     {\n+#ifdef X86_WIN64\n+    case FFI_WIN64:\n+      {\n+        // Make copies of all struct arguments\n+        // NOTE: not sure if responsibility should be here or in caller\n+        unsigned int i;\n+        for (i=0; i < cif->nargs;i++) {\n+          size_t size = cif->arg_types[i]->size;\n+          if ((cif->arg_types[i]->type == FFI_TYPE_STRUCT\n+               && (size != 1 && size != 2 && size != 4 && size != 8))\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+              || cif->arg_types[i]->type == FFI_TYPE_LONGDOUBLE\n+#endif\n+              )\n+            {\n+              void *local = alloca(size);\n+              memcpy(local, avalue[i], size);\n+              avalue[i] = local;\n+            }\n+        }\n+        ffi_call_win64(ffi_prep_args, &ecif, cif->bytes,\n+                       cif->flags, ecif.rvalue, fn);\n+      }\n+      break;\n+#else\n     case FFI_SYSV:\n       ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,\n-\t\t    fn);\n+                    fn);\n       break;\n #ifdef X86_WIN32\n     case FFI_STDCALL:\n       ffi_call_STDCALL(ffi_prep_args, &ecif, cif->bytes, cif->flags,\n-\t\t       ecif.rvalue, fn);\n+                       ecif.rvalue, fn);\n       break;\n #endif /* X86_WIN32 */\n+#endif /* X86_WIN64 */\n     default:\n       FFI_ASSERT(0);\n       break;\n@@ -229,7 +343,7 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n /** private members **/\n \n static void ffi_prep_incoming_args_SYSV (char *stack, void **ret,\n-\t\t\t\t\t void** args, ffi_cif* cif);\n+                                         void** args, ffi_cif* cif);\n void FFI_HIDDEN ffi_closure_SYSV (ffi_closure *)\n      __attribute__ ((regparm(1)));\n unsigned int FFI_HIDDEN ffi_closure_SYSV_inner (ffi_closure *, void **, void *)\n@@ -240,9 +354,42 @@ void FFI_HIDDEN ffi_closure_raw_SYSV (ffi_raw_closure *)\n void FFI_HIDDEN ffi_closure_STDCALL (ffi_closure *)\n      __attribute__ ((regparm(1)));\n #endif\n+#ifdef X86_WIN64\n+void FFI_HIDDEN ffi_closure_win64 (ffi_closure *);\n+#endif\n \n /* This function is jumped to by the trampoline */\n \n+#ifdef X86_WIN64\n+void * FFI_HIDDEN\n+ffi_closure_win64_inner (ffi_closure *closure, void *args) {\n+  ffi_cif       *cif;\n+  void         **arg_area;\n+  void          *result;\n+  void          *resp = &result;\n+\n+  cif         = closure->cif;\n+  arg_area    = (void**) alloca (cif->nargs * sizeof (void*));  \n+\n+  /* this call will initialize ARG_AREA, such that each\n+   * element in that array points to the corresponding \n+   * value on the stack; and if the function returns\n+   * a structure, it will change RESP to point to the\n+   * structure return address.  */\n+\n+  ffi_prep_incoming_args_SYSV(args, &resp, arg_area, cif);\n+  \n+  (closure->fun) (cif, resp, arg_area, closure->user_data);\n+\n+  /* The result is returned in rax.  This does the right thing for\n+     result types except for floats; we have to 'mov xmm0, rax' in the\n+     caller to correct this.\n+     TODO: structure sizes of 3 5 6 7 are returned by reference, too!!!\n+  */\n+  return cif->rtype->size > sizeof(void *) ? resp : *(void **)resp;\n+}\n+\n+#else\n unsigned int FFI_HIDDEN\n ffi_closure_SYSV_inner (closure, respp, args)\n      ffi_closure *closure;\n@@ -259,7 +406,7 @@ ffi_closure_SYSV_inner (closure, respp, args)\n   /* this call will initialize ARG_AREA, such that each\n    * element in that array points to the corresponding \n    * value on the stack; and if the function returns\n-   * a structure, it will re-set RESP to point to the\n+   * a structure, it will change RESP to point to the\n    * structure return address.  */\n \n   ffi_prep_incoming_args_SYSV(args, respp, arg_area, cif);\n@@ -268,10 +415,11 @@ ffi_closure_SYSV_inner (closure, respp, args)\n \n   return cif->flags;\n }\n+#endif /* !X86_WIN64 */\n \n static void\n ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,\n-\t\t\t    ffi_cif *cif)\n+                            ffi_cif *cif)\n {\n   register unsigned int i;\n   register void **p_argv;\n@@ -280,10 +428,20 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,\n \n   argp = stack;\n \n+#ifdef X86_WIN64\n+  if (cif->rtype->size > sizeof(ffi_arg)\n+      || (cif->flags == FFI_TYPE_STRUCT\n+          && (cif->rtype->size != 1 && cif->rtype->size != 2\n+              && cif->rtype->size != 4 && cif->rtype->size != 8))) {\n+    *rvalue = *(void **) argp;\n+    argp += sizeof(void *);\n+  }\n+#else\n   if ( cif->flags == FFI_TYPE_STRUCT ) {\n     *rvalue = *(void **) argp;\n-    argp += 4;\n+    argp += sizeof(void *);\n   }\n+#endif\n \n   p_argv = avalue;\n \n@@ -292,30 +450,65 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,\n       size_t z;\n \n       /* Align if necessary */\n-      if ((sizeof(int) - 1) & (unsigned) argp) {\n-\targp = (char *) ALIGN(argp, sizeof(int));\n+      if ((sizeof(void*) - 1) & (size_t) argp) {\n+        argp = (char *) ALIGN(argp, sizeof(void*));\n       }\n \n-      z = (*p_arg)->size;\n-\n-      /* because we're little endian, this is what it turns into.   */\n-\n-      *p_argv = (void*) argp;\n-\n+#ifdef X86_WIN64\n+      if ((*p_arg)->size > sizeof(ffi_arg)\n+          || ((*p_arg)->type == FFI_TYPE_STRUCT\n+              && ((*p_arg)->size != 1 && (*p_arg)->size != 2\n+                  && (*p_arg)->size != 4 && (*p_arg)->size != 8)))\n+        {\n+          z = sizeof(void *);\n+          *p_argv = *(void **)argp;\n+        }\n+      else\n+#endif\n+        {\n+          z = (*p_arg)->size;\n+          \n+          /* because we're little endian, this is what it turns into.   */\n+          \n+          *p_argv = (void*) argp;\n+        }\n+          \n       p_argv++;\n+#ifdef X86_WIN64\n+      argp += (z + sizeof(void*) - 1) & ~(sizeof(void*) - 1);\n+#else\n       argp += z;\n+#endif\n     }\n   \n   return;\n }\n \n+#define FFI_INIT_TRAMPOLINE_WIN64(TRAMP,FUN,CTX,MASK) \\\n+{ unsigned char *__tramp = (unsigned char*)(TRAMP); \\\n+   void*  __fun = (void*)(FUN); \\\n+   void*  __ctx = (void*)(CTX); \\\n+   *(unsigned char*) &__tramp[0] = 0x41; \\\n+   *(unsigned char*) &__tramp[1] = 0xbb; \\\n+   *(unsigned int*) &__tramp[2] = MASK; /* mov $mask, %r11 */ \\\n+   *(unsigned char*) &__tramp[6] = 0x48; \\\n+   *(unsigned char*) &__tramp[7] = 0xb8; \\\n+   *(void**) &__tramp[8] = __ctx; /* mov __ctx, %rax */ \\\n+   *(unsigned char *)  &__tramp[16] = 0x49; \\\n+   *(unsigned char *)  &__tramp[17] = 0xba; \\\n+   *(void**) &__tramp[18] = __fun; /* mov __fun, %r10 */ \\\n+   *(unsigned char *)  &__tramp[26] = 0x41; \\\n+   *(unsigned char *)  &__tramp[27] = 0xff; \\\n+   *(unsigned char *)  &__tramp[28] = 0xe2; /* jmp %r10 */ \\\n+ }\n+\n /* How to make a trampoline.  Derived from gcc/config/i386/i386.c. */\n \n #define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX) \\\n ({ unsigned char *__tramp = (unsigned char*)(TRAMP); \\\n    unsigned int  __fun = (unsigned int)(FUN); \\\n    unsigned int  __ctx = (unsigned int)(CTX); \\\n-   unsigned int  __dis = __fun - (__ctx + 10);\t\\\n+   unsigned int  __dis = __fun - (__ctx + 10);  \\\n    *(unsigned char*) &__tramp[0] = 0xb8; \\\n    *(unsigned int*)  &__tramp[1] = __ctx; /* movl __ctx, %eax */ \\\n    *(unsigned char *)  &__tramp[5] = 0xe9; \\\n@@ -340,11 +533,23 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,\n \n ffi_status\n ffi_prep_closure_loc (ffi_closure* closure,\n-\t\t      ffi_cif* cif,\n-\t\t      void (*fun)(ffi_cif*,void*,void**,void*),\n-\t\t      void *user_data,\n-\t\t      void *codeloc)\n+                      ffi_cif* cif,\n+                      void (*fun)(ffi_cif*,void*,void**,void*),\n+                      void *user_data,\n+                      void *codeloc)\n {\n+#ifdef X86_WIN64\n+#define ISFLOAT(IDX) (cif->arg_types[IDX]->type == FFI_TYPE_FLOAT || cif->arg_types[IDX]->type == FFI_TYPE_DOUBLE)\n+#define FLAG(IDX) (cif->nargs>(IDX)&&ISFLOAT(IDX)?(1<<(IDX)):0)\n+  if (cif->abi == FFI_WIN64) \n+    {\n+      int mask = FLAG(0)|FLAG(1)|FLAG(2)|FLAG(3);\n+      FFI_INIT_TRAMPOLINE_WIN64 (&closure->tramp[0],\n+                                 &ffi_closure_win64,\n+                                 codeloc, mask);\n+      /* make sure we can execute here */\n+    }\n+#else\n   if (cif->abi == FFI_SYSV)\n     {\n       FFI_INIT_TRAMPOLINE (&closure->tramp[0],\n@@ -358,7 +563,8 @@ ffi_prep_closure_loc (ffi_closure* closure,\n                                    &ffi_closure_STDCALL,\n                                    (void*)codeloc, cif->bytes);\n     }\n-#endif\n+#endif /* X86_WIN32 */\n+#endif /* !X86_WIN64 */\n   else\n     {\n       return FFI_BAD_ABI;\n@@ -377,10 +583,10 @@ ffi_prep_closure_loc (ffi_closure* closure,\n \n ffi_status\n ffi_prep_raw_closure_loc (ffi_raw_closure* closure,\n-\t\t\t  ffi_cif* cif,\n-\t\t\t  void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n-\t\t\t  void *user_data,\n-\t\t\t  void *codeloc)\n+                          ffi_cif* cif,\n+                          void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+                          void *user_data,\n+                          void *codeloc)\n {\n   int i;\n \n@@ -401,7 +607,7 @@ ffi_prep_raw_closure_loc (ffi_raw_closure* closure,\n   \n \n   FFI_INIT_TRAMPOLINE (&closure->tramp[0], &ffi_closure_raw_SYSV,\n-\t\t       codeloc);\n+                       codeloc);\n     \n   closure->cif  = cif;\n   closure->user_data = user_data;\n@@ -423,12 +629,12 @@ ffi_prep_args_raw(char *stack, extended_cif *ecif)\n \n extern void\n ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *, unsigned, \n-\t      unsigned, unsigned *, void (*fn)(void));\n+              unsigned, unsigned *, void (*fn)(void));\n \n #ifdef X86_WIN32\n extern void\n ffi_call_STDCALL(void (*)(char *, extended_cif *), extended_cif *, unsigned,\n-\t\t unsigned, unsigned *, void (*fn)(void));\n+                 unsigned, unsigned *, void (*fn)(void));\n #endif /* X86_WIN32 */\n \n void\n@@ -440,8 +646,8 @@ ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)\n   ecif.cif = cif;\n   ecif.avalue = avalue;\n   \n-  /* If the return value is a struct and we don't have a return\t*/\n-  /* value address then we need to make one\t\t        */\n+  /* If the return value is a struct and we don't have a return */\n+  /* value address then we need to make one                     */\n \n   if ((rvalue == NULL) && \n       (cif->rtype->type == FFI_TYPE_STRUCT))\n@@ -456,12 +662,12 @@ ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)\n     {\n     case FFI_SYSV:\n       ffi_call_SYSV(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,\n-\t\t    ecif.rvalue, fn);\n+                    ecif.rvalue, fn);\n       break;\n #ifdef X86_WIN32\n     case FFI_STDCALL:\n       ffi_call_STDCALL(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,\n-\t\t       ecif.rvalue, fn);\n+                       ecif.rvalue, fn);\n       break;\n #endif /* X86_WIN32 */\n     default:\n@@ -472,4 +678,5 @@ ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)\n \n #endif\n \n-#endif /* __x86_64__  */\n+#endif /* !__x86_64__  || X86_WIN64 */\n+"}, {"sha": "116c636598d82daf5c4ebfceacbffdf359e07afc", "filename": "libffi/src/x86/ffi64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fx86%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fx86%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi64.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -1,6 +1,6 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 2002, 2007  Bo Thorsen <bo@suse.de>\n-           Copyright (c) 2008  Red Hat, Inc.\n+   ffi64.c - Copyright (c) 2002, 2007  Bo Thorsen <bo@suse.de>\n+             Copyright (c) 2008  Red Hat, Inc.\n    \n    x86-64 Foreign Function Interface \n "}, {"sha": "b1d3df88f14afdf03a1035f87a166200662124cf", "filename": "libffi/src/x86/ffitarget.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fx86%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fx86%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffitarget.h?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -36,11 +36,26 @@\n #define X86\n #endif\n \n+#ifdef X86_WIN64\n+#define FFI_SIZEOF_ARG 8\n+#define USE_BUILTIN_FFS 0 // not yet implemented in mingw-64 \n+#endif\n+\n /* ---- Generic type definitions ----------------------------------------- */\n \n #ifndef LIBFFI_ASM\n+#ifdef X86_WIN64\n+#ifdef _MSC_VER\n+typedef unsigned __int64       ffi_arg;\n+typedef __int64                ffi_sarg;\n+#else\n+typedef unsigned long long     ffi_arg;\n+typedef long long              ffi_sarg;\n+#endif\n+#else\n typedef unsigned long          ffi_arg;\n typedef signed long            ffi_sarg;\n+#endif\n \n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n@@ -53,6 +68,11 @@ typedef enum ffi_abi {\n   FFI_DEFAULT_ABI = FFI_SYSV,\n #endif\n \n+#ifdef X86_WIN64\n+  FFI_WIN64,\n+  FFI_DEFAULT_ABI = FFI_WIN64,\n+#else\n+\n   /* ---- Intel x86 and AMD x86-64 - */\n #if !defined(X86_WIN32) && (defined(__i386__) || defined(__x86_64__))\n   FFI_SYSV,\n@@ -63,6 +83,7 @@ typedef enum ffi_abi {\n   FFI_DEFAULT_ABI = FFI_UNIX64,\n #endif\n #endif\n+#endif /* X86_WIN64 */\n \n   FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n } ffi_abi;\n@@ -73,6 +94,7 @@ typedef enum ffi_abi {\n #define FFI_CLOSURES 1\n #define FFI_TYPE_SMALL_STRUCT_1B (FFI_TYPE_LAST + 1)\n #define FFI_TYPE_SMALL_STRUCT_2B (FFI_TYPE_LAST + 2)\n+#define FFI_TYPE_SMALL_STRUCT_4B (FFI_TYPE_LAST + 3)\n \n #if defined (X86_64) || (defined (__x86_64__) && defined (X86_DARWIN))\n #define FFI_TRAMPOLINE_SIZE 24\n@@ -81,10 +103,18 @@ typedef enum ffi_abi {\n #ifdef X86_WIN32\n #define FFI_TRAMPOLINE_SIZE 13\n #else\n+#ifdef X86_WIN64\n+#define FFI_TRAMPOLINE_SIZE 29\n+#define FFI_NATIVE_RAW_API 0\n+#define FFI_NO_RAW_API 1\n+#else\n #define FFI_TRAMPOLINE_SIZE 10\n #endif\n+#endif\n+#ifndef X86_WIN64\n #define FFI_NATIVE_RAW_API 1\t/* x86 has native raw api support */\n #endif\n+#endif\n \n #endif\n "}, {"sha": "a1de858d96ae041a80415e0147082ca13fbbae5b", "filename": "libffi/src/x86/win32.S", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fx86%2Fwin32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fx86%2Fwin32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fwin32.S?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -34,8 +34,6 @@\n  \n \t.text\n  \n-\t.extern\tffi_prep_args\n- \n         # This assumes we are using gas.\n         .balign 16\n \t.globl\t_ffi_call_SYSV"}, {"sha": "ae56c2edb004538cf330a5b4906eb3d537e74239", "filename": "libffi/src/x86/win64.S", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fx86%2Fwin64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Fsrc%2Fx86%2Fwin64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fwin64.S?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -0,0 +1,462 @@\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\t\n+/* Constants for ffi_call_win64 */\t\n+#define STACK 0\n+#define PREP_ARGS_FN 32\n+#define ECIF 40\n+#define CIF_BYTES 48\n+#define CIF_FLAGS 56\n+#define RVALUE 64\n+#define FN 72\n+\n+/* ffi_call_win64 (void (*prep_args_fn)(char *, extended_cif *),\n+                   extended_cif *ecif, unsigned bytes, unsigned flags,\n+                   unsigned *rvalue, void (*fn)());\n+ */\n+\n+#ifdef _MSC_VER\n+PUBLIC\tffi_call_win64\n+\n+EXTRN\t__chkstk:NEAR\n+EXTRN\tffi_closure_win64_inner:NEAR\n+\n+_TEXT\tSEGMENT\n+\n+;;; ffi_closure_win64 will be called with these registers set:\n+;;;    rax points to 'closure'\n+;;;    r11 contains a bit mask that specifies which of the\n+;;;    first four parameters are float or double\n+;;;\n+;;; It must move the parameters passed in registers to their stack location,\n+;;; call ffi_closure_win64_inner for the actual work, then return the result.\n+;;; \n+ffi_closure_win64 PROC FRAME\n+\t;; copy register arguments onto stack\n+\ttest\tr11, 1\n+\tjne\tfirst_is_float\t\n+\tmov\tQWORD PTR [rsp+8], rcx\n+\tjmp\tsecond\n+first_is_float:\n+\tmovlpd\tQWORD PTR [rsp+8], xmm0\n+\n+second:\n+\ttest\tr11, 2\n+\tjne\tsecond_is_float\t\n+\tmov\tQWORD PTR [rsp+16], rdx\n+\tjmp\tthird\n+second_is_float:\n+\tmovlpd\tQWORD PTR [rsp+16], xmm1\n+\n+third:\n+\ttest\tr11, 4\n+\tjne\tthird_is_float\t\n+\tmov\tQWORD PTR [rsp+24], r8\n+\tjmp\tfourth\n+third_is_float:\n+\tmovlpd\tQWORD PTR [rsp+24], xmm2\n+\n+fourth:\n+\ttest\tr11, 8\n+\tjne\tfourth_is_float\t\n+\tmov\tQWORD PTR [rsp+32], r9\n+\tjmp\tdone\n+fourth_is_float:\n+\tmovlpd\tQWORD PTR [rsp+32], xmm3\n+\n+done:\n+        .ALLOCSTACK 40\n+\tsub\trsp, 40\n+        .ENDPROLOG\n+\tmov\trcx, rax\t; context is first parameter\n+\tmov\trdx, rsp\t; stack is second parameter\n+\tadd\trdx, 48\t\t; point to start of arguments\n+\tmov\trax, ffi_closure_win64_inner\n+\tcall\trax\t\t; call the real closure function\n+\tadd\trsp, 40\n+\tmovd\txmm0, rax\t; If the closure returned a float,\n+                                ; ffi_closure_win64_inner wrote it to rax\n+\tret\t0\n+ffi_closure_win64 ENDP\n+\n+ffi_call_win64 PROC FRAME\n+        ;; copy registers onto stack\n+\tmov\tQWORD PTR [rsp+32], r9\n+\tmov\tQWORD PTR [rsp+24], r8\n+\tmov\tQWORD PTR [rsp+16], rdx\n+\tmov\tQWORD PTR [rsp+8], rcx\n+        .PUSHREG rbp\n+\tpush\trbp\n+        .ALLOCSTACK 48\n+\tsub\trsp, 48\t\t\t\t\t; 00000030H\n+        .SETFRAME rbp, 32\n+\tlea\trbp, QWORD PTR [rsp+32]\n+        .ENDPROLOG\n+\n+\tmov\teax, DWORD PTR CIF_BYTES[rbp]\n+\tadd\trax, 15\n+\tand\trax, -16\n+\tcall\t__chkstk\n+\tsub\trsp, rax\n+\tlea\trax, QWORD PTR [rsp+32]\n+\tmov\tQWORD PTR STACK[rbp], rax\n+\n+\tmov\trdx, QWORD PTR ECIF[rbp]\n+\tmov\trcx, QWORD PTR STACK[rbp]\n+\tcall\tQWORD PTR PREP_ARGS_FN[rbp]\n+\n+\tmov\trsp, QWORD PTR STACK[rbp]\n+\n+\tmovlpd\txmm3, QWORD PTR [rsp+24]\n+\tmovd\tr9, xmm3\n+\n+\tmovlpd\txmm2, QWORD PTR [rsp+16]\n+\tmovd\tr8, xmm2\n+\n+\tmovlpd\txmm1, QWORD PTR [rsp+8]\n+\tmovd\trdx, xmm1\n+\n+\tmovlpd\txmm0, QWORD PTR [rsp]\n+\tmovd\trcx, xmm0\n+\n+\tcall\tQWORD PTR FN[rbp]\n+ret_struct4b$:\n+ \tcmp\tDWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SMALL_STRUCT_4B\n+ \tjne\tret_struct2b$\n+\n+\tmov\trcx, QWORD PTR RVALUE[rbp]\n+\tmov\tDWORD PTR [rcx], eax\n+\tjmp\tret_void$\n+\n+ret_struct2b$:\n+ \tcmp\tDWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SMALL_STRUCT_2B\n+ \tjne\tret_struct1b$\n+\n+\tmov\trcx, QWORD PTR RVALUE[rbp]\n+\tmov\tWORD PTR [rcx], ax\n+\tjmp\tret_void$\n+\n+ret_struct1b$:\n+ \tcmp\tDWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SMALL_STRUCT_1B\n+ \tjne\tret_uint8$\n+\n+\tmov\trcx, QWORD PTR RVALUE[rbp]\n+\tmov\tBYTE PTR [rcx], al\n+\tjmp\tret_void$\n+\n+ret_uint8$:\n+ \tcmp\tDWORD PTR CIF_FLAGS[rbp], FFI_TYPE_UINT8\n+ \tjne\tret_sint8$\n+\n+\tmov\trcx, QWORD PTR RVALUE[rbp]\n+\tmovzx   rax, al\n+\tmov\tQWORD PTR [rcx], rax\n+\tjmp\tret_void$\n+\n+ret_sint8$:\n+ \tcmp\tDWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SINT8\n+ \tjne\tret_uint16$\n+\n+\tmov\trcx, QWORD PTR RVALUE[rbp]\n+\tmovsx   rax, al\n+\tmov\tQWORD PTR [rcx], rax\n+\tjmp\tret_void$\n+\n+ret_uint16$:\n+ \tcmp\tDWORD PTR CIF_FLAGS[rbp], FFI_TYPE_UINT16\n+ \tjne\tret_sint16$\n+\n+\tmov\trcx, QWORD PTR RVALUE[rbp]\n+\tmovzx   rax, ax\n+\tmov\tQWORD PTR [rcx], rax\n+\tjmp\tSHORT ret_void$\n+\n+ret_sint16$:\n+ \tcmp\tDWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SINT16\n+ \tjne\tret_uint32$\n+\n+\tmov\trcx, QWORD PTR RVALUE[rbp]\n+\tmovsx   rax, ax\n+\tmov\tQWORD PTR [rcx], rax\n+\tjmp\tSHORT ret_void$\n+\n+ret_uint32$:\n+ \tcmp\tDWORD PTR CIF_FLAGS[rbp], FFI_TYPE_UINT32\n+ \tjne\tret_sint32$\n+\n+\tmov\trcx, QWORD PTR RVALUE[rbp]\n+\tmov     eax, eax\n+\tmov\tQWORD PTR [rcx], rax\n+\tjmp\tSHORT ret_void$\n+\n+ret_sint32$:\n+ \tcmp\tDWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SINT32\n+ \tjne\tret_float$\n+\n+\tmov\trcx, QWORD PTR RVALUE[rbp]\n+\tcdqe\n+\tmov\tQWORD PTR [rcx], rax\n+\tjmp\tSHORT ret_void$\n+\n+ret_float$:\n+ \tcmp\tDWORD PTR CIF_FLAGS[rbp], FFI_TYPE_FLOAT\n+ \tjne\tSHORT ret_double$\n+\n+ \tmov\trax, QWORD PTR RVALUE[rbp]\n+ \tmovss\tDWORD PTR [rax], xmm0\n+ \tjmp\tSHORT ret_void$\n+\n+ret_double$:\n+ \tcmp\tDWORD PTR CIF_FLAGS[rbp], FFI_TYPE_DOUBLE\n+ \tjne\tSHORT ret_sint64$\n+\n+ \tmov\trax, QWORD PTR RVALUE[rbp]\n+ \tmovlpd\tQWORD PTR [rax], xmm0\n+ \tjmp\tSHORT ret_void$\n+\n+ret_sint64$:\n+  \tcmp\tDWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SINT64\n+  \tjne\tret_void$\n+\n+ \tmov\trcx, QWORD PTR RVALUE[rbp]\n+ \tmov\tQWORD PTR [rcx], rax\n+ \tjmp\tSHORT ret_void$\n+\t\n+ret_void$:\n+\txor\trax, rax\n+\n+\tlea\trsp, QWORD PTR [rbp+16]\n+\tpop\trbp\n+\tret\t0\n+ffi_call_win64 ENDP\n+_TEXT\tENDS\n+END\n+#else        \n+.text\n+\n+.extern ___chkstk\n+.extern _ffi_closure_win64_inner\n+\n+# ffi_closure_win64 will be called with these registers set:\n+#    rax points to 'closure'\n+#    r11 contains a bit mask that specifies which of the\n+#    first four parameters are float or double\n+#\n+# It must move the parameters passed in registers to their stack location,\n+# call ffi_closure_win64_inner for the actual work, then return the result.\n+# \n+\t.balign 16\n+        .globl _ffi_closure_win64\t\n+_ffi_closure_win64:     \n+\t# copy register arguments onto stack\n+\ttest\t$1,%r11\n+\tjne\t.Lfirst_is_float\t\n+\tmov\t%rcx, 8(%rsp)\n+\tjmp\t.Lsecond\n+.Lfirst_is_float:\n+\tmovlpd\t%xmm0, 8(%rsp)\n+\n+.Lsecond:\n+\ttest\t$2, %r11\n+\tjne\t.Lsecond_is_float\t\n+\tmov\t%rdx, 16(%rsp)\n+\tjmp\t.Lthird\n+.Lsecond_is_float:\n+\tmovlpd\t%xmm1, 16(%rsp)\n+\n+.Lthird:\n+\ttest\t$4, %r11\n+\tjne\t.Lthird_is_float\t\n+\tmov\t%r8,24(%rsp)\n+\tjmp\t.Lfourth\n+.Lthird_is_float:\n+\tmovlpd\t%xmm2, 24(%rsp)\n+\n+.Lfourth:\n+\ttest\t$8, %r11\n+\tjne\t.Lfourth_is_float\t\n+\tmov\t%r9, 32(%rsp)\n+\tjmp\t.Ldone\n+.Lfourth_is_float:\n+\tmovlpd\t%xmm3, 32(%rsp)\n+\n+.Ldone:\n+#.ALLOCSTACK 40\n+\tsub\t$40, %rsp\n+#.ENDPROLOG\n+\tmov\t%rax, %rcx\t# context is first parameter\n+\tmov\t%rsp, %rdx\t# stack is second parameter\n+\tadd\t$48, %rdx\t# point to start of arguments\n+\tmov\t$_ffi_closure_win64_inner, %rax\n+\tcallq\t*%rax\t\t# call the real closure function\n+\tadd\t$40, %rsp\n+\tmovq\t%rax, %xmm0\t# If the closure returned a float,\n+                                # ffi_closure_win64_inner wrote it to rax\n+\tretq\n+.ffi_closure_win64_end:\n+\n+\t.balign 16\n+        .globl\t_ffi_call_win64\n+_ffi_call_win64:        \n+        # copy registers onto stack\n+\tmov\t%r9,32(%rsp)\n+\tmov\t%r8,24(%rsp)\n+\tmov\t%rdx,16(%rsp)\n+\tmov\t%rcx,8(%rsp)\n+        #.PUSHREG rbp\n+\tpush\t%rbp\n+        #.ALLOCSTACK 48\n+\tsub\t$48,%rsp\n+        #.SETFRAME rbp, 32\n+\tlea\t32(%rsp),%rbp\n+        #.ENDPROLOG\n+\n+\tmov\tCIF_BYTES(%rbp),%eax\n+\tadd\t$15, %rax\n+\tand\t$-16, %rax\n+\tcallq\t___chkstk\n+\tcmpq\t$0x1000, %rax\n+\tjb\tLch_done\n+Lch_probe:\n+\tsubq\t$0x1000,%rsp\n+\torl\t$0x0, (%rsp)\n+\tsubq\t$0x1000,%rax\n+\tcmpq\t$0x1000,%rax\n+\tja\tLch_probe\n+Lch_done:\n+\tsubq\t%rax, %rsp\n+\torl\t$0x0, (%rsp)\n+\tlea\t32(%rsp), %rax\n+\tmov\t%rax, STACK(%rbp)\n+\n+\tmov\tECIF(%rbp), %rdx\n+\tmov\tSTACK(%rbp), %rcx\n+\tcallq\t*PREP_ARGS_FN(%rbp)\n+\n+\tmov\tSTACK(%rbp), %rsp\n+\n+\tmovlpd\t24(%rsp), %xmm3\n+\tmovd\t%xmm3, %r9\n+\n+\tmovlpd\t16(%rsp), %xmm2\n+\tmovd\t%xmm2, %r8\n+\n+\tmovlpd\t8(%rsp), %xmm1\n+\tmovd\t%xmm1, %rdx\n+\n+\tmovlpd\t(%rsp), %xmm0\n+\tmovd\t%xmm0, %rcx\n+\n+\tcallq\t*FN(%rbp)\n+.Lret_struct4b:\n+ \tcmpl\t$FFI_TYPE_SMALL_STRUCT_4B, CIF_FLAGS(%rbp)\n+ \tjne .Lret_struct2b\n+\n+\tmov\tRVALUE(%rbp), %rcx\n+\tmov\t%eax, (%rcx)\n+\tjmp\t.Lret_void\n+\n+.Lret_struct2b:\n+\tcmpl\t$FFI_TYPE_SMALL_STRUCT_2B, CIF_FLAGS(%rbp)\n+\tjne .Lret_struct1b\n+\t\n+\tmov\tRVALUE(%rbp), %rcx\n+\tmov\t%ax, (%rcx)\n+\tjmp .Lret_void\n+\t\n+.Lret_struct1b:\n+\tcmpl\t$FFI_TYPE_SMALL_STRUCT_1B, CIF_FLAGS(%rbp)\n+\tjne .Lret_uint8\n+\t\n+\tmov\tRVALUE(%rbp), %rcx\n+\tmov\t%al, (%rcx)\n+\tjmp .Lret_void\n+\n+.Lret_uint8:\n+\tcmpl\t$FFI_TYPE_UINT8, CIF_FLAGS(%rbp)\n+\tjne .Lret_sint8\n+\t\n+        mov     RVALUE(%rbp), %rcx\n+        movzbq  %al, %rax\n+\tmovq    %rax, (%rcx)\n+\tjmp .Lret_void\n+\n+.Lret_sint8:\n+\tcmpl\t$FFI_TYPE_SINT8, CIF_FLAGS(%rbp)\n+\tjne .Lret_uint16\n+\t\n+        mov     RVALUE(%rbp), %rcx\n+        movsbq  %al, %rax\n+\tmovq    %rax, (%rcx)\n+\tjmp .Lret_void\n+\n+.Lret_uint16:\n+\tcmpl\t$FFI_TYPE_UINT16, CIF_FLAGS(%rbp)\n+\tjne .Lret_sint16\n+\t\n+        mov     RVALUE(%rbp), %rcx\n+        movzwq  %ax, %rax\n+\tmovq    %rax, (%rcx)\n+\tjmp .Lret_void\n+\n+.Lret_sint16:\n+\tcmpl\t$FFI_TYPE_SINT16, CIF_FLAGS(%rbp)\n+\tjne .Lret_uint32\n+\t\n+        mov     RVALUE(%rbp), %rcx\n+        movswq  %ax, %rax\n+\tmovq    %rax, (%rcx)\n+\tjmp .Lret_void\n+\n+.Lret_uint32:\n+\tcmpl\t$FFI_TYPE_UINT32, CIF_FLAGS(%rbp)\n+\tjne .Lret_sint32\n+\t\n+        mov     RVALUE(%rbp), %rcx\n+        movl    %eax, %eax\n+\tmovq    %rax, (%rcx)\n+\tjmp .Lret_void\n+\n+.Lret_sint32:\n+ \tcmpl\t$FFI_TYPE_SINT32, CIF_FLAGS(%rbp)\n+ \tjne\t.Lret_float\n+\n+\tmov\tRVALUE(%rbp), %rcx\n+\tcltq\n+\tmovq\t%rax, (%rcx)\n+\tjmp\t.Lret_void\n+\n+.Lret_float:\n+ \tcmpl\t$FFI_TYPE_FLOAT, CIF_FLAGS(%rbp)\n+ \tjne\t.Lret_double\n+\n+ \tmov\tRVALUE(%rbp), %rax\n+ \tmovss\t%xmm0, (%rax)\n+ \tjmp\t.Lret_void\n+\n+.Lret_double:\n+ \tcmpl\t$FFI_TYPE_DOUBLE, CIF_FLAGS(%rbp)\n+ \tjne\t.Lret_sint64\n+\n+ \tmov\tRVALUE(%rbp), %rax\n+ \tmovlpd\t%xmm0, (%rax)\n+ \tjmp\t.Lret_void\n+\n+.Lret_sint64:\n+  \tcmpl\t$FFI_TYPE_SINT64, CIF_FLAGS(%rbp)\n+  \tjne\t.Lret_void\n+\n+ \tmov\tRVALUE(%rbp), %rcx\n+ \tmov\t%rax, (%rcx)\n+ \tjmp\t.Lret_void\n+\t\n+.Lret_void:\n+\txor\t%rax, %rax\n+\n+\tlea\t16(%rbp), %rsp\n+\tpop\t%rbp\n+\tretq\n+.ffi_call_win64_end:\n+#endif /* !_MSC_VER */\n+"}, {"sha": "c6dd213abd01978c04b91aeb244c643468b53da3", "filename": "libffi/testsuite/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2FMakefile.in?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -175,6 +175,8 @@ X86_FREEBSD_TRUE = @X86_FREEBSD_TRUE@\n X86_TRUE = @X86_TRUE@\n X86_WIN32_FALSE = @X86_WIN32_FALSE@\n X86_WIN32_TRUE = @X86_WIN32_TRUE@\n+X86_WIN64_FALSE = @X86_WIN64_FALSE@\n+X86_WIN64_TRUE = @X86_WIN64_TRUE@\n ac_ct_AR = @ac_ct_AR@\n ac_ct_CC = @ac_ct_CC@\n ac_ct_DSYMUTIL = @ac_ct_DSYMUTIL@"}, {"sha": "a579ff6c979f3f219cd5fab04c52678c67cf12f0", "filename": "libffi/testsuite/libffi.call/closure_fn0.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn0.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -49,19 +49,11 @@ typedef int (*closure_test_type0)(unsigned long long, int, unsigned long long,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void * code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[17];\n   int res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_uint64;\n   cl_arg_types[1] = &ffi_type_sint;\n   cl_arg_types[2] = &ffi_type_uint64;\n@@ -84,10 +76,10 @@ int main (void)\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n \t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn0,\n-\t\t\t (void *) 3 /* userdata */) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn0,\n+                             (void *) 3 /* userdata */, code) == FFI_OK);\n \n-  res = (*((closure_test_type0)pcl))\n+  res = (*((closure_test_type0)code))\n     (1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13,\n      19, 21, 1);\n   /* { dg-output \"1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680\" } */"}, {"sha": "91231738c13b5240d2ee07b2d416b0738e9dac7a", "filename": "libffi/testsuite/libffi.call/closure_fn1.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn1.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -41,19 +41,11 @@ typedef int (*closure_test_type1)(float, float, float, float, signed short,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[17];\n   int res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_float;\n   cl_arg_types[1] = &ffi_type_float;\n   cl_arg_types[2] = &ffi_type_float;\n@@ -76,10 +68,10 @@ int main (void)\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n \t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn1,\n-\t\t\t (void *) 3 /* userdata */)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn1,\n+                             (void *) 3 /* userdata */, code)  == FFI_OK);\n \n-  res = (*((closure_test_type1)pcl))\n+  res = (*((closure_test_type1)code))\n     (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,\n      19, 21, 1);\n   /* { dg-output \"1 2 3 4 127 5 6 8 9 10 11 12 13 19 21 1 3: 255\" } */"}, {"sha": "08ff9d92274c317162ec862934e7e226564ada56", "filename": "libffi/testsuite/libffi.call/closure_fn2.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn2.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -41,19 +41,11 @@ typedef int (*closure_test_type2)(double, double, double, double, signed short,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[17];\n   int res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_double;\n   cl_arg_types[1] = &ffi_type_double;\n   cl_arg_types[2] = &ffi_type_double;\n@@ -76,10 +68,10 @@ int main (void)\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n \t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn2,\n-\t\t\t (void *) 3 /* userdata */) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn2,\n+                             (void *) 3 /* userdata */, code) == FFI_OK);\n \n-  res = (*((closure_test_type2)pcl))\n+  res = (*((closure_test_type2)code))\n     (1, 2, 3, 4, 127, 5, 6, 8, 9, 10, 11, 12.0, 13,\n      19.0, 21, 1);\n   /* { dg-output \"1 2 3 4 127 5 6 8 9 10 11 12 13 19 21 1 3: 255\" } */"}, {"sha": "9b54d805c8296ad87dd89502dc158284e90a2927", "filename": "libffi/testsuite/libffi.call/closure_fn3.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn3.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -42,19 +42,11 @@ typedef int (*closure_test_type3)(float, float, float, float, float, float,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[17];\n   int res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_float;\n   cl_arg_types[1] = &ffi_type_float;\n   cl_arg_types[2] = &ffi_type_float;\n@@ -77,10 +69,10 @@ int main (void)\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n \t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn3,\n-\t\t\t (void *) 3 /* userdata */)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn3,\n+                             (void *) 3 /* userdata */, code)  == FFI_OK);\n \n-  res = (*((closure_test_type3)pcl))\n+  res = (*((closure_test_type3)code))\n     (1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9, 10, 11.11, 12.0, 13,\n      19.19, 21.21, 1);\n   /* { dg-output \"1 2 3 4 5 6 7 8 9 10 11 12 13 19 21 1 3: 135\" } */"}, {"sha": "d4a1530b065b21a0cf87a4515cd3ce216b6225db", "filename": "libffi/testsuite/libffi.call/closure_fn4.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn4.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -60,19 +60,11 @@ typedef int (*closure_test_type0)(unsigned long long, unsigned long long,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[17];\n   int i, res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   for (i = 0; i < 15; i++) {\n     cl_arg_types[i] = &ffi_type_uint64;\n   }\n@@ -83,10 +75,10 @@ int main (void)\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n \t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn0,\n-\t\t\t (void *) 3 /* userdata */) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn0,\n+                             (void *) 3 /* userdata */, code) == FFI_OK);\n \n-  res = (*((closure_test_type0)pcl))\n+  res = (*((closure_test_type0)code))\n     (1LL, 2LL, 3LL, 4LL, 127LL, 429LL, 7LL, 8LL, 9LL, 10LL, 11LL, 12LL,\n      13LL, 19LL, 21LL, 1);\n   /* { dg-output \"1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680\" } */"}, {"sha": "99074426c67b5a65e383b48254ea0b8a8950fdda", "filename": "libffi/testsuite/libffi.call/closure_fn5.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn5.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -59,17 +59,10 @@ typedef int (*closure_test_type0)(unsigned long long, unsigned long long,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[17];\n   int i, res;\n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n \n   for (i = 0; i < 10; i++) {\n     cl_arg_types[i] = &ffi_type_uint64;\n@@ -85,10 +78,10 @@ int main (void)\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n \t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn5,\n-\t\t\t (void *) 3 /* userdata */) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn5,\n+                             (void *) 3 /* userdata */, code) == FFI_OK);\n \n-  res = (*((closure_test_type0)pcl))\n+  res = (*((closure_test_type0)code))\n     (1LL, 2LL, 3LL, 4LL, 127LL, 429LL, 7LL, 8LL, 9LL, 10LL, 11, 12LL,\n      13LL, 19LL, 21LL, 1);\n   /* { dg-output \"1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680\" } */"}, {"sha": "73c54fd6b16016846b47c10b6d6d2f69da45f73a", "filename": "libffi/testsuite/libffi.call/closure_fn6.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn6.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -50,19 +50,11 @@ typedef int (*closure_test_type0)(unsigned long long,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[17];\n   int res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_uint64;\n   cl_arg_types[1] = &ffi_type_uint64;\n   cl_arg_types[2] = &ffi_type_uint64;\n@@ -85,10 +77,10 @@ int main (void)\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n \t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn0,\n-\t\t\t (void *) 3 /* userdata */) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn0,\n+                             (void *) 3 /* userdata */, code) == FFI_OK);\n \n-  res = (*((closure_test_type0)pcl))\n+  res = (*((closure_test_type0)code))\n     (1, 2, 3, 4, 127, 429., 7., 8., 9.5, 10., 11, 12., 13,\n      19, 21., 1.);\n   /* { dg-output \"1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680\" } */"}, {"sha": "6bfcc1fbb5b342867ddb69cf40f48d63688b3c2d", "filename": "libffi/testsuite/libffi.call/closure_stdcall.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_stdcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_stdcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_stdcall.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -28,22 +28,14 @@ typedef int (__stdcall *closure_test_type0)(int, int, int, int);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[17];\n   int res;\n   void* sp_pre;\n   void* sp_post;\n   char buf[1024];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_uint;\n   cl_arg_types[1] = &ffi_type_uint;\n   cl_arg_types[2] = &ffi_type_uint;\n@@ -54,11 +46,11 @@ int main (void)\n   CHECK(ffi_prep_cif(&cif, FFI_STDCALL, 4,\n \t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_stdcall,\n-\t\t\t (void *) 3 /* userdata */) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_stdcall,\n+                             (void *) 3 /* userdata */, code) == FFI_OK);\n \n   asm volatile (\" movl %%esp,%0\" : \"=g\" (sp_pre));\n-  res = (*(closure_test_type0)pcl)(0, 1, 2, 3);\n+  res = (*(closure_test_type0)code)(0, 1, 2, 3);\n   asm volatile (\" movl %%esp,%0\" : \"=g\" (sp_post));\n   /* { dg-output \"0 1 2 3: 9\" } */\n "}, {"sha": "f0a334fa797595d6ec684edcf65a3f5ff626be62", "filename": "libffi/testsuite/libffi.call/cls_12byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_12byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_12byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_12byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -42,21 +42,13 @@ static void cls_struct_12byte_gn(ffi_cif* cif __UNUSED__, void* resp,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -87,13 +79,13 @@ int main (void)\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 8 9 12\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_12byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_12byte_gn, NULL, code) == FFI_OK);\n \n   res_dbl.a = 0;\n   res_dbl.b = 0;\n   res_dbl.c = 0;\n \n-  res_dbl = ((cls_struct_12byte(*)(cls_struct_12byte, cls_struct_12byte))(pcl))(h_dbl, j_dbl);\n+  res_dbl = ((cls_struct_12byte(*)(cls_struct_12byte, cls_struct_12byte))(code))(h_dbl, j_dbl);\n   /* { dg-output \"\\n7 4 9 1 5 3: 8 9 12\" } */\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 8 9 12\" } */"}, {"sha": "9b9292ab056c3aa6af43c2e700a5661993125c88", "filename": "libffi/testsuite/libffi.call/cls_16byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_16byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_16byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_16byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ static void cls_struct_16byte_gn(ffi_cif* cif __UNUSED__, void* resp,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -92,9 +84,9 @@ int main (void)\n   res_dbl.b = 0.0;\n   res_dbl.c = 0;\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_16byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_16byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_16byte(*)(cls_struct_16byte, cls_struct_16byte))(pcl))(h_dbl, j_dbl);\n+  res_dbl = ((cls_struct_16byte(*)(cls_struct_16byte, cls_struct_16byte))(code))(h_dbl, j_dbl);\n   /* { dg-output \"\\n7 8 9 1 9 3: 8 17 12\" } */\n   printf(\"res: %d %g %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 8 17 12\" } */"}, {"sha": "40c8c6d96a1b1b1c55d0bd0e075db75c591e0cfa", "filename": "libffi/testsuite/libffi.call/cls_18byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_18byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_18byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_18byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -47,21 +47,13 @@ cls_struct_18byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[5];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -93,9 +85,9 @@ int main (void)\n   printf(\"res: %g %d %d %g\\n\", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);\n   /* { dg-output \"\\nres: 5 252 250 8\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_18byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_18byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_18byte(*)(cls_struct_18byte, cls_struct_18byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_18byte(*)(cls_struct_18byte, cls_struct_18byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n1 127 126 3 4 125 124 5: 5 252 250 8\" } */\n   printf(\"res: %g %d %d %g\\n\", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);\n   /* { dg-output \"\\nres: 5 252 250 8\" } */"}, {"sha": "aa6424818f769807d36ca542a39cdb6b9381a0ba", "filename": "libffi/testsuite/libffi.call/cls_19byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_19byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_19byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_19byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -50,21 +50,13 @@ cls_struct_19byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[6];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -98,9 +90,9 @@ int main (void)\n \t res_dbl.d, res_dbl.e);\n   /* { dg-output \"\\nres: 5 252 250 8 239\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_19byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_19byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_19byte(*)(cls_struct_19byte, cls_struct_19byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_19byte(*)(cls_struct_19byte, cls_struct_19byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n1 127 126 3 120 4 125 124 5 119: 5 252 250 8 239\" } */\n   printf(\"res: %g %d %d %g %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n \t res_dbl.d, res_dbl.e);"}, {"sha": "b9402d678adaace5e12aec25a53aa79f5544ade7", "filename": "libffi/testsuite/libffi.call/cls_1_1byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_1_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_1_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_1_1byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ cls_struct_1_1byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[2];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -86,9 +78,9 @@ int main (void)\n   printf(\"res: %d\\n\", res_dbl.a);\n   /* { dg-output \"\\nres: 190\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_1_1byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_1_1byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_1_1byte(*)(cls_struct_1_1byte, cls_struct_1_1byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_1_1byte(*)(cls_struct_1_1byte, cls_struct_1_1byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 178: 190\" } */\n   printf(\"res: %d\\n\", res_dbl.a);\n   /* { dg-output \"\\nres: 190\" } */"}, {"sha": "80dd7ac931bc18cc7ab45707a5c95acdf6c05b33", "filename": "libffi/testsuite/libffi.call/cls_20byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ cls_struct_20byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -88,9 +80,9 @@ int main (void)\n   printf(\"res: %g %g %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 5 7 10\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_20byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_20byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_20byte(*)(cls_struct_20byte, cls_struct_20byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_20byte(*)(cls_struct_20byte, cls_struct_20byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n1 2 3 4 5 7: 5 7 10\" } */\n   printf(\"res: %g %g %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 5 7 10\" } */"}, {"sha": "50bcbbf831a09bf5ca0147b23d215b128a8c974a", "filename": "libffi/testsuite/libffi.call/cls_20byte1.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte1.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -45,21 +45,13 @@ cls_struct_20byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -90,9 +82,9 @@ int main (void)\n   printf(\"res: %d %g %g\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 5 7 10\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_20byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_20byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_20byte(*)(cls_struct_20byte, cls_struct_20byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_20byte(*)(cls_struct_20byte, cls_struct_20byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n1 2 3 4 5 7: 5 7 10\" } */\n   printf(\"res: %d %g %g\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 5 7 10\" } */"}, {"sha": "46a6eb4d31c0f60af7121a16d56abe8d615f87c7", "filename": "libffi/testsuite/libffi.call/cls_24byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_24byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_24byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_24byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -54,21 +54,13 @@ cls_struct_24byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[5];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -106,13 +98,13 @@ int main (void)\n   printf(\"res: %g %g %d %g\\n\", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);\n   /* { dg-output \"\\nres: 22 15 17 25\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_24byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_24byte_gn, NULL, code) == FFI_OK);\n \n   res_dbl = ((cls_struct_24byte(*)(cls_struct_24byte,\n \t\t\t\t   cls_struct_24byte,\n \t\t\t\t   cls_struct_24byte,\n \t\t\t\t   cls_struct_24byte))\n-\t     (pcl))(e_dbl, f_dbl, g_dbl, h_dbl);\n+\t     (code))(e_dbl, f_dbl, g_dbl, h_dbl);\n   /* { dg-output \"\\n9 2 6 5 1 2 3 7 4 5 7 9 8 6 1 9: 22 15 17 25\" } */\n   printf(\"res: %g %g %d %g\\n\", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);\n   /* { dg-output \"\\nres: 22 15 17 25\" } */"}, {"sha": "101e130a1fc4b4a7db1e55a273e85a55a9b4cf19", "filename": "libffi/testsuite/libffi.call/cls_2byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_2byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_2byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_2byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ cls_struct_2byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -87,9 +79,9 @@ int main (void)\n   printf(\"res: %d %d\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 13 140\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_2byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_2byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_2byte(*)(cls_struct_2byte, cls_struct_2byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_2byte(*)(cls_struct_2byte, cls_struct_2byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 127 1 13: 13 140\" } */\n   printf(\"res: %d %d\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 13 140\" } */"}, {"sha": "fc780c30d6c6787b65a2ed179e7902e11e8fda5a", "filename": "libffi/testsuite/libffi.call/cls_3_1byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3_1byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -47,21 +47,13 @@ cls_struct_3_1byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -92,9 +84,9 @@ int main (void)\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 190 192 194\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_3_1byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_3_1byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_3_1byte(*)(cls_struct_3_1byte, cls_struct_3_1byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_3_1byte(*)(cls_struct_3_1byte, cls_struct_3_1byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 13 14 178 179 180: 190 192 194\" } */\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 190 192 194\" } */"}, {"sha": "5705ce387980f62a8a226413af6250dec9434e5a", "filename": "libffi/testsuite/libffi.call/cls_3byte1.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte1.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ cls_struct_3byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -87,9 +79,9 @@ int main (void)\n   printf(\"res: %d %d\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 13 134\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_3byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_3byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_3byte(*)(cls_struct_3byte, cls_struct_3byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_3byte(*)(cls_struct_3byte, cls_struct_3byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 119 1 15: 13 134\" } */\n   printf(\"res: %d %d\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 13 134\" } */"}, {"sha": "01770a0750bc06350cc59a59bed3090cd10d9d84", "filename": "libffi/testsuite/libffi.call/cls_3byte2.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte2.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ cls_struct_3byte_gn1(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -87,9 +79,9 @@ int main (void)\n   printf(\"res: %d %d\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 24 144\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_3byte_gn1, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_3byte_gn1, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_3byte_1(*)(cls_struct_3byte_1, cls_struct_3byte_1))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_3byte_1(*)(cls_struct_3byte_1, cls_struct_3byte_1))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n15 125 9 19: 24 144\" } */\n   printf(\"res: %d %d\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 24 144\" } */"}, {"sha": "f3806d7ba1c9e764a2f7e939328402fc1a7b9797", "filename": "libffi/testsuite/libffi.call/cls_4_1byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4_1byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -49,21 +49,13 @@ cls_struct_4_1byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[5];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -95,9 +87,9 @@ int main (void)\n   printf(\"res: %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);\n   /* { dg-output \"\\nres: 190 192 194 196\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_4_1byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_4_1byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_4_1byte(*)(cls_struct_4_1byte, cls_struct_4_1byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_4_1byte(*)(cls_struct_4_1byte, cls_struct_4_1byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 13 14 15 178 179 180 181: 190 192 194 196\" } */\n   printf(\"res: %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);\n   /* { dg-output \"\\nres: 190 192 194 196\" } */"}, {"sha": "a1aba3c09d50d9ab50f60d017faa73358afae49d", "filename": "libffi/testsuite/libffi.call/cls_4byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ cls_struct_4byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -87,9 +79,9 @@ int main (void)\n   printf(\"res: %d %d\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 139 248\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_4byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_4byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_4byte(*)(cls_struct_4byte, cls_struct_4byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_4byte(*)(cls_struct_4byte, cls_struct_4byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n127 120 12 128: 139 248\" } */\n   printf(\"res: %d %d\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 139 248\" } */"}, {"sha": "2ceba3ddb2dabe94555c169fbdc4ddc2d986c0f1", "filename": "libffi/testsuite/libffi.call/cls_5_1_byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5_1_byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5_1_byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5_1_byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -51,21 +51,13 @@ cls_struct_5byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[6];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -105,9 +97,9 @@ int main (void)\n   res_dbl.d = 0;\n   res_dbl.e = 0;\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_5byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_5byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_5byte(*)(cls_struct_5byte, cls_struct_5byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_5byte(*)(cls_struct_5byte, cls_struct_5byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n127 120 1 3 4 12 128 9 3 4: 139 248 10 6 8\" } */\n   printf(\"res: %d %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n \t res_dbl.d, res_dbl.e);"}, {"sha": "61d595c2bf06a580d541137d977a67bc784024c8", "filename": "libffi/testsuite/libffi.call/cls_5byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -46,21 +46,13 @@ cls_struct_5byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -95,9 +87,9 @@ int main (void)\n   res_dbl.b = 0;\n   res_dbl.c = 0;\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_5byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_5byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_5byte(*)(cls_struct_5byte, cls_struct_5byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_5byte(*)(cls_struct_5byte, cls_struct_5byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n127 120 1 12 128 9: 139 248 10\" } */\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 139 248 10\" } */"}, {"sha": "576ebe0cc2a4e8206c0ef0931bef532ad266b921", "filename": "libffi/testsuite/libffi.call/cls_64byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_64byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_64byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_64byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -59,21 +59,13 @@ cls_struct_64byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[9];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -116,13 +108,13 @@ int main (void)\n \t res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h);\n   /* { dg-output \"\\nres: 22 15 17 25 6 13 19 18\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_64byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_64byte_gn, NULL, code) == FFI_OK);\n \n   res_dbl = ((cls_struct_64byte(*)(cls_struct_64byte,\n \t\t\t\t   cls_struct_64byte,\n \t\t\t\t   cls_struct_64byte,\n \t\t\t\t   cls_struct_64byte))\n-\t     (pcl))(e_dbl, f_dbl, g_dbl, h_dbl);\n+\t     (code))(e_dbl, f_dbl, g_dbl, h_dbl);\n   /* { dg-output \"\\n22 15 17 25 6 13 19 18\" } */\n   printf(\"res: %g %g %g %g %g %g %g %g\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n \t res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h);"}, {"sha": "9f2eff68c1ff91a1e113feb5e587e09b5e72545f", "filename": "libffi/testsuite/libffi.call/cls_6_1_byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6_1_byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6_1_byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6_1_byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -53,21 +53,13 @@ cls_struct_6byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[7];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -109,9 +101,9 @@ int main (void)\n   res_dbl.e = 0;\n   res_dbl.f = 0;\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_6byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_6byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_6byte(*)(cls_struct_6byte, cls_struct_6byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_6byte(*)(cls_struct_6byte, cls_struct_6byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n127 120 1 3 4 5 12 128 9 3 4 5: 139 248 10 6 8 10\" } */\n   printf(\"res: %d %d %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n \t res_dbl.d, res_dbl.e, res_dbl.f);"}, {"sha": "73257b0989bb5ec3d8a2a6c3b84d60b190cf5166", "filename": "libffi/testsuite/libffi.call/cls_6byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -49,21 +49,13 @@ cls_struct_6byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[5];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -95,9 +87,9 @@ int main (void)\n   printf(\"res: %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);\n   /* { dg-output \"\\nres: 139 248 10 255\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_6byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_6byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_6byte(*)(cls_struct_6byte, cls_struct_6byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_6byte(*)(cls_struct_6byte, cls_struct_6byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n127 120 1 128 12 128 9 127: 139 248 10 255\" } */\n   printf(\"res: %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);\n   /* { dg-output \"\\nres: 139 248 10 255\" } */"}, {"sha": "50d09c9da72db12fc784495f76ecb94ff6fa0cba", "filename": "libffi/testsuite/libffi.call/cls_7_1_byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7_1_byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7_1_byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7_1_byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -55,21 +55,13 @@ cls_struct_7byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[8];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -113,9 +105,9 @@ int main (void)\n   res_dbl.f = 0;\n   res_dbl.g = 0;\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_7byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_7byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_7byte(*)(cls_struct_7byte, cls_struct_7byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_7byte(*)(cls_struct_7byte, cls_struct_7byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n127 120 1 3 4 5 6 12 128 9 3 4 5 6: 139 248 10 6 8 10 12\" } */\n   printf(\"res: %d %d %d %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n \t res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);"}, {"sha": "f5c00003153dc0f79d00d1d9063760d8c9b0723b", "filename": "libffi/testsuite/libffi.call/cls_7byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -48,21 +48,13 @@ cls_struct_7byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[5];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -94,9 +86,9 @@ int main (void)\n   printf(\"res: %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);\n   /* { dg-output \"\\nres: 139 248 10 509\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_7byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_7byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_7byte(*)(cls_struct_7byte, cls_struct_7byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_7byte(*)(cls_struct_7byte, cls_struct_7byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n127 120 1 254 12 128 9 255: 139 248 10 509\" } */\n   printf(\"res: %d %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);\n   /* { dg-output \"\\nres: 139 248 10 509\" } */"}, {"sha": "4aa99d12e417c1fb47a6110571a29b917a49d629", "filename": "libffi/testsuite/libffi.call/cls_8byte.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_8byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_8byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_8byte.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -42,21 +42,13 @@ cls_struct_8byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -85,9 +77,9 @@ int main (void)\n   /* { dg-output \"1 2 4 5: 5 7\" } */\n   printf(\"res: %d %g\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 5 7\" } */\n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_8byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_8byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_8byte(*)(cls_struct_8byte, cls_struct_8byte))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_8byte(*)(cls_struct_8byte, cls_struct_8byte))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n1 2 4 5: 5 7\" } */\n   printf(\"res: %d %g\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 5 7\" } */"}, {"sha": "cc5e9d6c4e940e5efab1466418c118416873695a", "filename": "libffi/testsuite/libffi.call/cls_9byte1.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte1.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ static void cls_struct_9byte_gn(ffi_cif* cif __UNUSED__, void* resp,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[3];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -87,9 +79,9 @@ int main (void)\n   printf(\"res: %d %g\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 8 17\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_9byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_9byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_9byte(*)(cls_struct_9byte, cls_struct_9byte))(pcl))(h_dbl, j_dbl);\n+  res_dbl = ((cls_struct_9byte(*)(cls_struct_9byte, cls_struct_9byte))(code))(h_dbl, j_dbl);\n   /* { dg-output \"\\n7 8 1 9: 8 17\" } */\n   printf(\"res: %d %g\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 8 17\" } */"}, {"sha": "5c0ba0d4b8d4a6581ffc8b4e6798e74be756371a", "filename": "libffi/testsuite/libffi.call/cls_9byte2.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte2.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ static void cls_struct_9byte_gn(ffi_cif* cif __UNUSED__, void* resp,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[3];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -88,9 +80,9 @@ int main (void)\n   /* { dg-output \"\\nres: 8 17\" } */\n \n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_9byte_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_9byte_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_9byte(*)(cls_struct_9byte, cls_struct_9byte))(pcl))(h_dbl, j_dbl);\n+  res_dbl = ((cls_struct_9byte(*)(cls_struct_9byte, cls_struct_9byte))(code))(h_dbl, j_dbl);\n   /* { dg-output \"\\n7 8 1 9: 8 17\" } */\n   printf(\"res: %g %d\\n\", res_dbl.a, res_dbl.b);\n   /* { dg-output \"\\nres: 8 17\" } */"}, {"sha": "22b94d5a09de1e21b90dad788982b8ded01ad82e", "filename": "libffi/testsuite/libffi.call/cls_align_double.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_double.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -45,21 +45,13 @@ cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -90,9 +82,9 @@ int main (void)\n   printf(\"res: %d %g %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 4951 127 1 9320 13: 13 14271 140\" } */\n   printf(\"res: %d %g %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */"}, {"sha": "62637f21d182d1c4075bc192e6269ab7157672cb", "filename": "libffi/testsuite/libffi.call/cls_align_float.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_float.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -88,9 +80,9 @@ int main (void)\n   printf(\"res: %d %g %d\\n\", res_dbl.a, (double)res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 4951 127 1 9320 13: 13 14271 140\" } */\n   printf(\"res: %d %g %d\\n\", res_dbl.a, (double)res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */"}, {"sha": "af380603c99eb8f5c4d6390fd0718f3f67d22d8c", "filename": "libffi/testsuite/libffi.call/cls_align_longdouble.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -4,7 +4,7 @@\n    PR:\t\tnone.\n    Originator:\t<hos@tamanegi.org> 20031203\t */\n \n-/* { dg-do run { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */\n+/* { dg-do run } */\n \n #include \"ffitest.h\"\n \n@@ -44,21 +44,13 @@ cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -89,9 +81,9 @@ int main (void)\n   printf(\"res: %d %g %d\\n\", res_dbl.a, (double)res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 4951 127 1 9320 13: 13 14271 140\" } */\n   printf(\"res: %d %g %d\\n\", res_dbl.a, (double)res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */"}, {"sha": "40326778aee7abd7c411cdc51e3e77ee1fff8d62", "filename": "libffi/testsuite/libffi.call/cls_align_longdouble_split.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -4,8 +4,10 @@\n    PR:\t\tnone.\n    Originator:\t<hos@tamanegi.org> 20031203\t */\n \n-/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* x86_64-*-mingw* x86_64-*-cygwin* } } */\n+/* { dg-excess-errors \"no long double format\" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n /* { dg-options -mlong-double-128 { target powerpc64*-*-* } } */\n+/* { dg-output \"\" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */\n \n #include \"ffitest.h\"\n \n@@ -78,21 +80,13 @@ cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n \tffi_cif cif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure cl;\n-#endif\n-\tffi_closure *pcl;\n+        void *code;\n+\tffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tvoid* args_dbl[3];\n \tffi_type* cls_struct_fields[8];\n \tffi_type cls_struct_type;\n \tffi_type* dbl_arg_types[3];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n \tcls_struct_type.size = 0;\n \tcls_struct_type.alignment = 0;\n \tcls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -128,9 +122,9 @@ int main (void)\n \t\tres_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);\n \t/* { dg-output \"\\nres: 9 11 13 15 17 19 21\" } */\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);\n \n-\tres_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);\n+\tres_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);\n \t/* { dg-output \"\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14: 9 11 13 15 17 19 21\" } */\n \tprintf(\"res: %Lg %Lg %Lg %Lg %Lg %Lg %Lg\\n\", res_dbl.a, res_dbl.b,\n \t\tres_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);"}, {"sha": "ced41c0b00cd4f1fcaf0d9d1ef3ff318f09c20b1", "filename": "libffi/testsuite/libffi.call/cls_align_longdouble_split2.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split2.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -5,8 +5,10 @@\n \tOriginator:\t\tBlake Chaffin\t6/18/2007\n */\n \n-/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* x86_64-*-mingw* x86_64-*-cygwin* } } */\n+/* { dg-excess-errors \"no long double format\" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* } } */\n /* { dg-options -mlong-double-128 { target powerpc64*-*-* } } */\n+/* { dg-output \"\" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */\n \n #include \"ffitest.h\"\n \n@@ -58,21 +60,13 @@ cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n \tffi_cif cif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure cl;\n-#endif\n-\tffi_closure *pcl;\n+        void *code;\n+\tffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tvoid* args_dbl[3];\n \tffi_type* cls_struct_fields[8];\n \tffi_type cls_struct_type;\n \tffi_type* dbl_arg_types[3];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n \tcls_struct_type.size = 0;\n \tcls_struct_type.alignment = 0;\n \tcls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -108,13 +102,16 @@ int main (void)\n \t\tres_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);\n \t/* { dg-output \"\\nres: 9 11 13 15 17 19 21\" } */\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);\n \n-\tres_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);\n+\tres_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);\n \t/* { dg-output \"\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14: 9 11 13 15 17 19 21\" } */\n \tprintf(\"res: %Lg %Lg %Lg %Lg %Lg %g %Lg\\n\", res_dbl.a, res_dbl.b,\n \t\tres_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);\n \t/* { dg-output \"\\nres: 9 11 13 15 17 19 21\" } */\n \n   exit(0);\n }\n+\n+\n+"}, {"sha": "cbc4f953ff625871d74f67a97da4dde9cd8ea7fe", "filename": "libffi/testsuite/libffi.call/cls_align_pointer.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_pointer.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -47,21 +47,13 @@ cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -92,9 +84,9 @@ int main (void)\n   printf(\"res: %d %\" PRIuPTR \" %d\\n\", res_dbl.a, (uintptr_t)res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 4951 127 1 9320 13: 13 14271 140\" } */\n   printf(\"res: %d %\" PRIuPTR \" %d\\n\", res_dbl.a, (uintptr_t)res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */"}, {"sha": "383ea41d5a6603987711a010464960111b10ab27", "filename": "libffi/testsuite/libffi.call/cls_align_sint16.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint16.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -88,9 +80,9 @@ int main (void)\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 4951 127 1 9320 13: 13 14271 140\" } */\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */"}, {"sha": "705d78cfa84cf12ab0c6ac5c6b9bdb11e31fd4f7", "filename": "libffi/testsuite/libffi.call/cls_align_sint32.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint32.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -88,9 +80,9 @@ int main (void)\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 4951 127 1 9320 13: 13 14271 140\" } */\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */"}, {"sha": "d8b73e95783b44af879110d293af08c5100a1103", "filename": "libffi/testsuite/libffi.call/cls_align_sint64.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint64.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -88,9 +80,9 @@ int main (void)\n   printf(\"res: %d %lld %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 4951 127 1 9320 13: 13 14271 140\" } */\n   printf(\"res: %d %lld %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */"}, {"sha": "cb6b74821ea427d62232512744b5cbaca1778126", "filename": "libffi/testsuite/libffi.call/cls_align_uint16.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint16.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -88,9 +80,9 @@ int main (void)\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 4951 127 1 9320 13: 13 14271 140\" } */\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */"}, {"sha": "e453d3e5d9e0c6a570b493f4a0c95b68ffa63238", "filename": "libffi/testsuite/libffi.call/cls_align_uint32.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint32.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -43,21 +43,13 @@ cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -88,9 +80,9 @@ int main (void)\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 4951 127 1 9320 13: 13 14271 140\" } */\n   printf(\"res: %d %d %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */"}, {"sha": "a3886f489620532c0887c4d0042c61be121fbf65", "filename": "libffi/testsuite/libffi.call/cls_align_uint64.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint64.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -23,7 +23,7 @@ cls_struct_align cls_struct_align_fn(struct cls_struct_align a1,\n   result.b = a1.b + a2.b;\n   result.c = a1.c + a2.c;\n \n-  printf(\"%d %lld %d %d %lld %d: %d %lld %d\\n\", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);\n+  printf(\"%d %llu %d %d %llu %d: %d %llu %d\\n\", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);\n \n   return  result;\n }\n@@ -44,21 +44,13 @@ cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -86,14 +78,14 @@ int main (void)\n \n   ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);\n   /* { dg-output \"12 4951 127 1 9320 13: 13 14271 140\" } */\n-  printf(\"res: %d %lld %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n+  printf(\"res: %d %llu %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);\n+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);\n   /* { dg-output \"\\n12 4951 127 1 9320 13: 13 14271 140\" } */\n-  printf(\"res: %d %lld %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n+  printf(\"res: %d %llu %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c);\n   /* { dg-output \"\\nres: 13 14271 140\" } */\n \n   exit(0);"}, {"sha": "fcf48b79237d7d0ea3eb6efeed4a82ffb7e71cab", "filename": "libffi/testsuite/libffi.call/cls_dbls_struct.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_dbls_struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_dbls_struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_dbls_struct.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -30,19 +30,10 @@ int main(int argc __UNUSED__, char** argv __UNUSED__)\n {\n \tffi_cif cif;\n \n-#ifndef USING_MMAP\n-\tstatic ffi_closure cl;\n-#endif\n-\n-\tffi_closure*\tpcl;\n+        void *code;\n+\tffi_closure*\tpcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tffi_type*\t\tcl_arg_types[1];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap(sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n \tffi_type\tts1_type;\n \tffi_type*\tts1_type_elements[4];\n \n@@ -63,9 +54,9 @@ int main(int argc __UNUSED__, char** argv __UNUSED__)\n \tCHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n \t\t\t\t &ffi_type_void, cl_arg_types) == FFI_OK);\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, closure_test_gn, NULL) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_gn, NULL, code) == FFI_OK);\n \n-\t((void*(*)(Dbls))(pcl))(arg);\n+\t((void*(*)(Dbls))(code))(arg);\n \t/* { dg-output \"1.0 2.0\\n\" { xfail x86_64-*-linux-* } } */\n \n \tclosure_test_fn(arg);"}, {"sha": "84ad4cb7d925b69d238bd129ee3601c36a6c547b", "filename": "libffi/testsuite/libffi.call/cls_double.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -20,29 +20,21 @@ typedef double (*cls_ret_double)(double);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[2];\n   double res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_double;\n   cl_arg_types[1] = NULL;\n \n   /* Initialize the cif */\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n \t\t     &ffi_type_double, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_double_fn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_double_fn, NULL, code)  == FFI_OK);\n \n-  res = (*((cls_ret_double)pcl))(21474.789);\n+  res = (*((cls_ret_double)code))(21474.789);\n   /* { dg-output \"21474.789000: 21474.789000\" } */\n   printf(\"res: %.6f\\n\", res);\n   /* { dg-output \"\\nres: 21474.789000\" } */"}, {"sha": "45ce9bd7c387745c202fc3c7d999e49124752b4c", "filename": "libffi/testsuite/libffi.call/cls_double_va.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -20,19 +20,11 @@ cls_double_va_fn(ffi_cif* cif __UNUSED__, void* resp,\n int main (void)\n {\n \tffi_cif cif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure cl;\n-#endif\n-\tffi_closure *pcl;\n+        void *code;\n+\tffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tvoid* args[3];\n \tffi_type* arg_types[3];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap(sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n \tchar*\tformat\t\t= \"%.1f\\n\";\n \tdouble\tdoubleArg\t= 7;\n \tffi_arg\tres\t\t\t= 0;\n@@ -53,9 +45,9 @@ int main (void)\n \tprintf(\"res: %d\\n\", (int) res);\n \t// { dg-output \"\\nres: 4\" }\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, cls_double_va_fn, NULL) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_double_va_fn, NULL, code) == FFI_OK);\n \n-\tres\t= ((int(*)(char*, double))(pcl))(format, doubleArg);\n+\tres\t= ((int(*)(char*, double))(code))(format, doubleArg);\n \t// { dg-output \"\\n7.0\" }\n \tprintf(\"res: %d\\n\", (int) res);\n \t// { dg-output \"\\nres: 4\" }"}, {"sha": "0090fed9063174d0e2e2412280e9841b4ecc86ae", "filename": "libffi/testsuite/libffi.call/cls_float.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_float.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -21,29 +21,20 @@ typedef float (*cls_ret_float)(float);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[2];\n   float res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n-\n   cl_arg_types[0] = &ffi_type_float;\n   cl_arg_types[1] = NULL;\n \n   /* Initialize the cif */\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n \t\t     &ffi_type_float, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_float_fn, NULL)  == FFI_OK);\n-  res = ((((cls_ret_float)pcl)(-2122.12)));\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_float_fn, NULL, code)  == FFI_OK);\n+  res = ((((cls_ret_float)code)(-2122.12)));\n   /* { dg-output \"\\\\-2122.12: \\\\-2122.12\" } */\n   printf(\"res: %.6f\\n\", res);\n   /* { dg-output \"\\nres: \\-2122.120117\" } */"}, {"sha": "2f50b368e7a96dd73eb1a7fcb00b1f7fb7751058", "filename": "libffi/testsuite/libffi.call/cls_longdouble.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -4,8 +4,10 @@\n    PR:\t\t\tnone.\n    Originator:\tBlake Chaffin\t*/\n \n-/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* x86_64-*-mingw* x86_64-*-cygwin* } } */\n+/* { dg-excess-errors \"no long double format\" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n /* { dg-options -mlong-double-128 { target powerpc64*-*-* } } */\n+/* { dg-output \"\" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */\n \n #include \"ffitest.h\"\n \n@@ -47,20 +49,12 @@ cls_ldouble_gn(ffi_cif* cif __UNUSED__, void* resp,\n int main(void)\n {\n \tffi_cif\tcif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure\tcl;\n-#endif\n-\tffi_closure*\tpcl;\n+        void* code;\n+\tffi_closure*\tpcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tvoid*\t\t\targs[9];\n \tffi_type*\t\targ_types[9];\n \tlong double\t\tres\t= 0;\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap(sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n \tlong double\targ1\t= 1;\n \tlong double\targ2\t= 2;\n \tlong double\targ3\t= 3;\n@@ -98,10 +92,10 @@ int main(void)\n \tprintf(\"res: %Lg\\n\", res);\n \t/* { dg-output \"\\nres: 36\" } */\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, cls_ldouble_gn, NULL) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_ldouble_gn, NULL, code) == FFI_OK);\n \n \tres = ((long double(*)(long double, long double, long double, long double,\n-\t\tlong double, long double, long double, long double))(pcl))(arg1, arg2,\n+\t\tlong double, long double, long double, long double))(code))(arg1, arg2,\n \t\targ3, arg4, arg5, arg6, arg7, arg8);\n \t/* { dg-output \"\\n1 2 3 4 5 6 7 8: 36\" } */\n \tprintf(\"res: %Lg\\n\", res);"}, {"sha": "0e910d5bd37305b94837a6b3bfffebe4f22bee24", "filename": "libffi/testsuite/libffi.call/cls_longdouble_va.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -4,7 +4,8 @@\n    PR:\t\t\tnone.\n    Originator:\tBlake Chaffin 6/6/2007\t */\n \n-/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* x86_64-*-mingw* x86_64-*-cygwin* } } */\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+/* { dg-output \"\" { xfail x86_64-*-mingw* } } */\n #include \"ffitest.h\"\n \n static void\n@@ -20,19 +21,11 @@ cls_longdouble_va_fn(ffi_cif* cif __UNUSED__, void* resp,\n int main (void)\n {\n \tffi_cif cif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure cl;\n-#endif\n-\tffi_closure *pcl;\n+        void *code;\n+\tffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tvoid* args[3];\n \tffi_type* arg_types[3];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n \tchar*\t\tformat\t= \"%L.1f\\n\";\n \tlong double\tldArg\t= 7;\n \tffi_arg\t\tres\t\t= 0;\n@@ -53,9 +46,9 @@ int main (void)\n \tprintf(\"res: %d\\n\", (int) res);\n \t// { dg-output \"\\nres: 4\" { xfail i*86-*-linux-* x86_64-*-linux-* sh*-*-linux-* } }\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, cls_longdouble_va_fn, NULL) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_longdouble_va_fn, NULL, code) == FFI_OK);\n \n-\tres\t= ((int(*)(char*, long double))(pcl))(format, ldArg);\n+\tres\t= ((int(*)(char*, long double))(code))(format, ldArg);\n \t// { dg-output \"\\n7.0\" }\n \tprintf(\"res: %d\\n\", (int) res);\n \t// { dg-output \"\\nres: 4\" }"}, {"sha": "71df7b6516e657cee68bcc430d36cbd75f1c17fc", "filename": "libffi/testsuite/libffi.call/cls_multi_schar.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_schar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_schar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_schar.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -36,21 +36,13 @@ typedef signed char (*test_type)(signed char, signed char);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void * args_dbl[3];\n   ffi_type * cl_arg_types[3];\n   ffi_arg res_call;\n   signed char a, b, res_closure;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   a = 2;\n   b = 125;\n \n@@ -71,9 +63,9 @@ int main (void)\n   printf(\"res: %d\\n\", (signed char)res_call);\n   /* { dg-output \"\\nres: 127\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);\n \n-  res_closure = (*((test_type)pcl))(2, 125);\n+  res_closure = (*((test_type)code))(2, 125);\n   /* { dg-output \"\\n2 125: 127\" } */\n   printf(\"res: %d\\n\", res_closure);\n   /* { dg-output \"\\nres: 127\" } */"}, {"sha": "4c39153266765ca91376f1c899fcc4e0d7a4dd17", "filename": "libffi/testsuite/libffi.call/cls_multi_sshort.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_sshort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_sshort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_sshort.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -36,21 +36,13 @@ typedef signed short (*test_type)(signed short, signed short);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void * args_dbl[3];\n   ffi_type * cl_arg_types[3];\n   ffi_arg res_call;\n   unsigned short a, b, res_closure;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   a = 2;\n   b = 32765;\n \n@@ -71,9 +63,9 @@ int main (void)\n   printf(\"res: %d\\n\", (unsigned short)res_call);\n   /* { dg-output \"\\nres: 32767\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);\n \n-  res_closure = (*((test_type)pcl))(2, 32765);\n+  res_closure = (*((test_type)code))(2, 32765);\n   /* { dg-output \"\\n2 32765: 32767\" } */\n   printf(\"res: %d\\n\", res_closure);\n   /* { dg-output \"\\nres: 32767\" } */"}, {"sha": "1c3aeb5a66c157292dd1c87af44a9b938b3be3a0", "filename": "libffi/testsuite/libffi.call/cls_multi_sshortchar.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_sshortchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_sshortchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_sshortchar.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -41,22 +41,14 @@ typedef signed short (*test_type)(signed char, signed short,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void * args_dbl[5];\n   ffi_type * cl_arg_types[5];\n   ffi_arg res_call;\n   signed char a, c;\n   signed short b, d, res_closure;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   a = 1;\n   b = 32765;\n   c = 127;\n@@ -83,9 +75,9 @@ int main (void)\n   printf(\"res: %d\\n\", (signed short)res_call);\n   /* { dg-output \"\\nres: 32765\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);\n \n-  res_closure = (*((test_type)pcl))(1, 32765, 127, -128);\n+  res_closure = (*((test_type)code))(1, 32765, 127, -128);\n   /* { dg-output \"\\n1 32765 127 -128: 32765\" } */\n   printf(\"res: %d\\n\", res_closure);\n   /* { dg-output \"\\nres: 32765\" } */"}, {"sha": "009c02c72ba5360c95122443520595194be3cbb0", "filename": "libffi/testsuite/libffi.call/cls_multi_uchar.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_uchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_uchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_uchar.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -47,21 +47,13 @@ void test_func(ffi_cif *cif __UNUSED__, void *rval __UNUSED__, void **avals,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void * args_dbl[5];\n   ffi_type * cl_arg_types[5];\n   ffi_arg res_call;\n   unsigned char a, b, c, d, res_closure;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   a = 1;\n   b = 2;\n   c = 127;\n@@ -88,9 +80,9 @@ int main (void)\n   printf(\"res: %d\\n\", (unsigned char)res_call);\n   /* { dg-output \"\\nres: 255\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);\n \n-  res_closure = (*((test_type)pcl))(1, 2, 127, 125);\n+  res_closure = (*((test_type)code))(1, 2, 127, 125);\n   /* { dg-output \"\\n1 2 127 125: 255\" } */\n   printf(\"res: %d\\n\", res_closure);\n   /* { dg-output \"\\nres: 255\" } */"}, {"sha": "dd10ca734685dfb48cc7df9d2309722ba0cb85d1", "filename": "libffi/testsuite/libffi.call/cls_multi_ushort.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_ushort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_ushort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_ushort.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -36,21 +36,13 @@ typedef unsigned short (*test_type)(unsigned short, unsigned short);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void * args_dbl[3];\n   ffi_type * cl_arg_types[3];\n   ffi_arg res_call;\n   unsigned short a, b, res_closure;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   a = 2;\n   b = 32765;\n \n@@ -71,9 +63,9 @@ int main (void)\n   printf(\"res: %d\\n\", (unsigned short)res_call);\n   /* { dg-output \"\\nres: 32767\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);\n \n-  res_closure = (*((test_type)pcl))(2, 32765);\n+  res_closure = (*((test_type)code))(2, 32765);\n   /* { dg-output \"\\n2 32765: 32767\" } */\n   printf(\"res: %d\\n\", res_closure);\n   /* { dg-output \"\\nres: 32767\" } */"}, {"sha": "2588e97f987fbb5c386f78bc9b80719b674244b1", "filename": "libffi/testsuite/libffi.call/cls_multi_ushortchar.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_ushortchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_ushortchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_ushortchar.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -41,22 +41,14 @@ typedef unsigned short (*test_type)(unsigned char, unsigned short,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void * args_dbl[5];\n   ffi_type * cl_arg_types[5];\n   ffi_arg res_call;\n   unsigned char a, c;\n   unsigned short b, d, res_closure;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   a = 1;\n   b = 2;\n   c = 127;\n@@ -83,9 +75,9 @@ int main (void)\n   printf(\"res: %d\\n\", (unsigned short)res_call);\n   /* { dg-output \"\\nres: 258\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);\n \n-  res_closure = (*((test_type)pcl))(1, 2, 127, 128);\n+  res_closure = (*((test_type)code))(1, 2, 127, 128);\n   /* { dg-output \"\\n1 2 127 128: 258\" } */\n   printf(\"res: %d\\n\", res_closure);\n   /* { dg-output \"\\nres: 258\" } */"}, {"sha": "34e4209640b8e121e8de5e8c26d4b99150162d72", "filename": "libffi/testsuite/libffi.call/cls_pointer.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -32,20 +32,12 @@ cls_pointer_gn(ffi_cif* cif __UNUSED__, void* resp,\n int main (void)\n {\n \tffi_cif\tcif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure\tcl;\n-#endif\n-\tffi_closure*\tpcl;\n+        void *code;\n+\tffi_closure*\tpcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tvoid*\t\t\targs[3];\n //\tffi_type\t\tcls_pointer_type;\n \tffi_type*\t\targ_types[3];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap(sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n /*\tcls_pointer_type.size = sizeof(void*);\n \tcls_pointer_type.alignment = 0;\n \tcls_pointer_type.type = FFI_TYPE_POINTER;\n@@ -71,9 +63,9 @@ int main (void)\n \tprintf(\"res: 0x%08x\\n\", (unsigned int) res);\n \t/* { dg-output \"\\nres: 0x9be02467\" } */\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, cls_pointer_gn, NULL) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_pointer_gn, NULL, code) == FFI_OK);\n \n-\tres = (ffi_arg)((void*(*)(void*, void*))(pcl))(arg1, arg2);\n+\tres = (ffi_arg)((void*(*)(void*, void*))(code))(arg1, arg2);\n \t/* { dg-output \"\\n0x12345678 0x89abcdef: 0x9be02467\" } */\n \tprintf(\"res: 0x%08x\\n\", (unsigned int) res);\n \t/* { dg-output \"\\nres: 0x9be02467\" } */"}, {"sha": "dd59c6b2c7abefe992a86247c984eab357f98962", "filename": "libffi/testsuite/libffi.call/cls_pointer_stack.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer_stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer_stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer_stack.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -93,20 +93,12 @@ cls_pointer_gn(ffi_cif* cif __UNUSED__, void* resp,\n int main (void)\n {\n \tffi_cif\tcif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure\tcl;\n-#endif\n-\tffi_closure*\tpcl;\n+        void *code;\n+\tffi_closure*\tpcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tvoid*\t\t\targs[3];\n //\tffi_type\t\tcls_pointer_type;\n \tffi_type*\t\targ_types[3];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap(sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n /*\tcls_pointer_type.size = sizeof(void*);\n \tcls_pointer_type.alignment = 0;\n \tcls_pointer_type.type = FFI_TYPE_POINTER;\n@@ -135,9 +127,9 @@ int main (void)\n \t// { dg-output \"\\n0x8acf1356 0x01234567: 0x8bf258bd\" }\n \t// { dg-output \"\\nres: 0x8bf258bd\" }\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, cls_pointer_gn, NULL) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_pointer_gn, NULL, code) == FFI_OK);\n \n-\tres = (ffi_arg)((void*(*)(void*, void*))(pcl))(arg1, arg2);\n+\tres = (ffi_arg)((void*(*)(void*, void*))(code))(arg1, arg2);\n \n \tprintf(\"res: 0x%08x\\n\", (unsigned int) res);\n \t// { dg-output \"\\n0x01234567 0x89abcdef: 0x8acf1356\" }"}, {"sha": "82986b172c365d2d9bf9313568b056eb922ae821", "filename": "libffi/testsuite/libffi.call/cls_schar.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_schar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_schar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_schar.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -21,29 +21,21 @@ typedef signed char (*cls_ret_schar)(signed char);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[2];\n   signed char res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_schar;\n   cl_arg_types[1] = NULL;\n \n   /* Initialize the cif */\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n \t\t     &ffi_type_schar, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_schar_fn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_schar_fn, NULL, code)  == FFI_OK);\n \n-  res = (*((cls_ret_schar)pcl))(127);\n+  res = (*((cls_ret_schar)code))(127);\n   /* { dg-output \"127: 127\" } */\n   printf(\"res: %d\\n\", res);\n   /* { dg-output \"\\nres: 127\" } */"}, {"sha": "c7e13b73a3bae7e9f6efed156bea48e28e6c1052", "filename": "libffi/testsuite/libffi.call/cls_sint.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sint.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -19,29 +19,21 @@ typedef signed int (*cls_ret_sint)(signed int);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[2];\n   signed int res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_sint;\n   cl_arg_types[1] = NULL;\n \n   /* Initialize the cif */\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n \t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_sint_fn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_sint_fn, NULL, code)  == FFI_OK);\n \n-  res = (*((cls_ret_sint)pcl))(65534);\n+  res = (*((cls_ret_sint)code))(65534);\n   /* { dg-output \"65534: 65534\" } */\n   printf(\"res: %d\\n\",res);\n   /* { dg-output \"\\nres: 65534\" } */"}, {"sha": "846d57ed1ba553794ae52c4cca7cf952647dfd2e", "filename": "libffi/testsuite/libffi.call/cls_sshort.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sshort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sshort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sshort.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -19,29 +19,21 @@ typedef signed short (*cls_ret_sshort)(signed short);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[2];\n   signed short res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_sshort;\n   cl_arg_types[1] = NULL;\n \n   /* Initialize the cif */\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n \t\t     &ffi_type_sshort, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_sshort_fn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_sshort_fn, NULL, code)  == FFI_OK);\n \n-  res = (*((cls_ret_sshort)pcl))(255);\n+  res = (*((cls_ret_sshort)code))(255);\n   /* { dg-output \"255: 255\" } */\n   printf(\"res: %d\\n\",res);\n   /* { dg-output \"\\nres: 255\" } */"}, {"sha": "c1317e795fd65d1b9d5328c449a4b38ca41c2c64", "filename": "libffi/testsuite/libffi.call/cls_uchar.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -19,29 +19,21 @@ typedef unsigned char (*cls_ret_uchar)(unsigned char);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[2];\n   unsigned char res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_uchar;\n   cl_arg_types[1] = NULL;\n \n   /* Initialize the cif */\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n \t\t     &ffi_type_uchar, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_uchar_fn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_uchar_fn, NULL, code)  == FFI_OK);\n \n-  res = (*((cls_ret_uchar)pcl))(127);\n+  res = (*((cls_ret_uchar)code))(127);\n   /* { dg-output \"127: 127\" } */\n   printf(\"res: %d\\n\",res);\n   /* { dg-output \"\\nres: 127\" } */"}, {"sha": "885cff5c3146831c3a2736ebf885afdea0c1f03d", "filename": "libffi/testsuite/libffi.call/cls_uint.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uint.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -20,29 +20,21 @@ typedef unsigned int (*cls_ret_uint)(unsigned int);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[2];\n   unsigned int res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_uint;\n   cl_arg_types[1] = NULL;\n \n   /* Initialize the cif */\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n \t\t     &ffi_type_uint, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_uint_fn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_uint_fn, NULL, code)  == FFI_OK);\n \n-  res = (*((cls_ret_uint)pcl))(2147483647);\n+  res = (*((cls_ret_uint)code))(2147483647);\n   /* { dg-output \"2147483647: 2147483647\" } */\n   printf(\"res: %d\\n\",res);\n   /* { dg-output \"\\nres: 2147483647\" } */"}, {"sha": "ed891e35a2b0168e27b2cecfa06e1accd34dc1c5", "filename": "libffi/testsuite/libffi.call/cls_ulonglong.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulonglong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulonglong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulonglong.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -20,34 +20,26 @@ typedef unsigned long long (*cls_ret_ulonglong)(unsigned long long);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[2];\n   unsigned long long res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_uint64;\n   cl_arg_types[1] = NULL;\n \n   /* Initialize the cif */\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n \t\t     &ffi_type_uint64, cl_arg_types) == FFI_OK);\n-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_ulonglong_fn, NULL)  == FFI_OK);\n-  res = (*((cls_ret_ulonglong)pcl))(214LL);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_ulonglong_fn, NULL, code)  == FFI_OK);\n+  res = (*((cls_ret_ulonglong)code))(214LL);\n   /* { dg-output \"214: 214\" } */\n-  printf(\"res: %lld\\n\", res);\n+  printf(\"res: %llu\\n\", res);\n   /* { dg-output \"\\nres: 214\" } */\n \n-  res = (*((cls_ret_ulonglong)pcl))(9223372035854775808LL);\n+  res = (*((cls_ret_ulonglong)code))(9223372035854775808LL);\n   /* { dg-output \"\\n9223372035854775808: 9223372035854775808\" } */\n-  printf(\"res: %lld\\n\", res);\n+  printf(\"res: %llu\\n\", res);\n   /* { dg-output \"\\nres: 9223372035854775808\" } */\n \n   exit(0);"}, {"sha": "a00100e07f8c954f7a15a08ee5a873754d8558d5", "filename": "libffi/testsuite/libffi.call/cls_ushort.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -20,29 +20,21 @@ typedef unsigned short (*cls_ret_ushort)(unsigned short);\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[2];\n   unsigned short res;\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cl_arg_types[0] = &ffi_type_ushort;\n   cl_arg_types[1] = NULL;\n \n   /* Initialize the cif */\n   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n \t\t     &ffi_type_ushort, cl_arg_types) == FFI_OK);\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_ushort_fn, NULL)  == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_ushort_fn, NULL, code)  == FFI_OK);\n \n-  res = (*((cls_ret_ushort)pcl))(65535);\n+  res = (*((cls_ret_ushort)code))(65535);\n   /* { dg-output \"65535: 65535\" } */\n   printf(\"res: %d\\n\",res);\n   /* { dg-output \"\\nres: 65535\" } */"}, {"sha": "4f121859dadcdfe10316494a05945f4662576fc9", "filename": "libffi/testsuite/libffi.call/err_bad_abi.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_abi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_abi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_abi.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -15,19 +15,11 @@ dummy_fn(ffi_cif* cif __UNUSED__, void* resp __UNUSED__,\n int main (void)\n {\n \tffi_cif cif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure cl;\n-#endif\n-\tffi_closure *pcl;\n+        void *code;\n+\tffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tvoid* args[1];\n \tffi_type* arg_types[1];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n \targ_types[0] = NULL;\n \targs[0] = NULL;\n \n@@ -39,7 +31,7 @@ int main (void)\n \n \tcif.abi= 255;\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, dummy_fn, NULL) == FFI_BAD_ABI);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, dummy_fn, NULL, code) == FFI_BAD_ABI);\n \n \texit(0);\n }"}, {"sha": "7ec2728eb1007d952c3ccb6077a113307fb33cbd", "filename": "libffi/testsuite/libffi.call/err_bad_typedef.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_typedef.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_typedef.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_typedef.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -10,18 +10,8 @@\n int main (void)\n {\n \tffi_cif cif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure cl;\n-#endif\n-\tffi_closure *pcl;\n \tffi_type* arg_types[1];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n \targ_types[0] = NULL;\n \n \tffi_type\tbadType\t= ffi_type_void;"}, {"sha": "a0b296cf4b9437648701c2b617d8023fe34de498", "filename": "libffi/testsuite/libffi.call/float2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -4,7 +4,8 @@\n    PR:\t\tnone.\n    Originator:\tFrom the original ffitest.c  */\n \n-/* { dg-do run } */\n+/* { dg-excess-errors \"fails\" { target x86_64-*-mingw* x86_64-*-cygwin* } } */\n+/* { dg-do run { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */\n \n #include \"ffitest.h\"\n #include \"float.h\""}, {"sha": "8aa527ede4e40077e43ffe0a8c124d69cc7c73f6", "filename": "libffi/testsuite/libffi.call/nested_struct.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -68,23 +68,15 @@ cls_struct_combined_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[5];\n   ffi_type* cls_struct_fields1[5];\n   ffi_type* cls_struct_fields2[5];\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -143,12 +135,12 @@ int main (void)\n   CHECK( res_dbl.e.dd == (e_dbl.a + f_dbl.dd + g_dbl.e.dd));\n   CHECK( res_dbl.e.ff == (e_dbl.b + f_dbl.ff + g_dbl.e.ff));\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_combined_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_combined_gn, NULL, code) == FFI_OK);\n \n   res_dbl = ((cls_struct_combined(*)(cls_struct_16byte1,\n \t\t\t\t     cls_struct_16byte2,\n \t\t\t\t     cls_struct_combined))\n-\t     (pcl))(e_dbl, f_dbl, g_dbl);\n+\t     (code))(e_dbl, f_dbl, g_dbl);\n   /* { dg-output \"\\n9 2 6 1 2 3 4 5 6 3 1 8: 15 10 13 10 12 13\" } */\n   CHECK( res_dbl.d.a == (e_dbl.a + f_dbl.dd + g_dbl.d.a));\n   CHECK( res_dbl.d.b == (e_dbl.b + f_dbl.ff + g_dbl.d.b));"}, {"sha": "2a9f515cdedaf60d15169b57388e9cbc2ebe0f57", "filename": "libffi/testsuite/libffi.call/nested_struct1.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -72,23 +72,15 @@ cls_struct_combined_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[5];\n   ffi_type* cls_struct_fields1[5];\n   ffi_type* cls_struct_fields2[5];\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -150,13 +142,13 @@ int main (void)\n   CHECK( res_dbl.e.dd == (e_dbl.a + f_dbl.dd + g_dbl.e.dd));\n   CHECK( res_dbl.e.ff == (e_dbl.b + f_dbl.ff + g_dbl.e.ff));\n \n-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_combined_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_combined_gn, NULL, code) == FFI_OK);\n \n   res_dbl = ((cls_struct_combined(*)(cls_struct_16byte1,\n \t\t\t\t     cls_struct_16byte2,\n \t\t\t\t     cls_struct_combined,\n \t\t\t\t     cls_struct_16byte1))\n-\t     (pcl))(e_dbl, f_dbl, g_dbl, h_dbl);\n+\t     (code))(e_dbl, f_dbl, g_dbl, h_dbl);\n   /* { dg-output \"\\n9 2 6 1 2 3 4 5 6 3 1 8 3 2 4: 15 10 13 10 12 13\" } */\n   CHECK( res_dbl.d.a == (e_dbl.a + f_dbl.dd + g_dbl.d.a));\n   CHECK( res_dbl.d.b == (e_dbl.b + f_dbl.ff + g_dbl.d.b));"}, {"sha": "d6a718bdd019c9979796921a030dacbfb843d1ec", "filename": "libffi/testsuite/libffi.call/nested_struct10.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct10.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -58,23 +58,15 @@ B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[4];\n   ffi_type* cls_struct_fields[3];\n   ffi_type* cls_struct_fields1[4];\n   ffi_type* cls_struct_fields2[3];\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[4];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -129,9 +121,9 @@ int main (void)\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));\n   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));\n \n-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);\n+  res_dbl = ((B(*)(A, B, C))(code))(e_dbl, f_dbl, g_dbl);\n   /* { dg-output \"\\n1 7 12 127 99 255 2 9: 270 242 143\" } */\n   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + f_dbl.z + g_dbl.d));\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));"}, {"sha": "de1584c18a1ac138427474424dfe410bd8e9675d", "filename": "libffi/testsuite/libffi.call/nested_struct2.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -49,22 +49,14 @@ B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[3];\n   ffi_type* cls_struct_fields1[3];\n   ffi_type cls_struct_type, cls_struct_type1;\n   ffi_type* dbl_arg_types[3];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -106,9 +98,9 @@ int main (void)\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n \n-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);\n+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);\n   /* { dg-output \"\\n1 7 12 127 99: 13 233 134\" } */\n   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));"}, {"sha": "58aa85362e8463615b4891fd4677f6482b9665c9", "filename": "libffi/testsuite/libffi.call/nested_struct3.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct3.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -50,22 +50,14 @@ B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[3];\n   ffi_type* cls_struct_fields1[3];\n   ffi_type cls_struct_type, cls_struct_type1;\n   ffi_type* dbl_arg_types[3];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -108,9 +100,9 @@ int main (void)\n   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n \n \n-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);\n+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);\n   /* { dg-output \"\\n1 7 12 127 99: 13 233 134\" } */\n   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));"}, {"sha": "98e491e65cfae5ab85c7458b8d4f0c7c93b6080d", "filename": "libffi/testsuite/libffi.call/nested_struct4.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct4.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -50,22 +50,14 @@ B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[3];\n   ffi_type* cls_struct_fields1[3];\n   ffi_type cls_struct_type, cls_struct_type1;\n   ffi_type* dbl_arg_types[3];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -107,9 +99,9 @@ int main (void)\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n \n-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);\n+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);\n   /* { dg-output \"\\n1 7 12 127 99: 13 233 134\" } */\n   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));"}, {"sha": "d8e3537d5a0903216ce6662141eade5d5d0e95b8", "filename": "libffi/testsuite/libffi.call/nested_struct5.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct5.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -50,22 +50,14 @@ B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[3];\n   ffi_type* cls_struct_fields1[3];\n   ffi_type cls_struct_type, cls_struct_type1;\n   ffi_type* dbl_arg_types[3];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -108,9 +100,9 @@ int main (void)\n   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n \n \n-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);\n+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);\n   /* { dg-output \"\\n1 7 12 127 99: 13 233 134\" } */\n   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));"}, {"sha": "2f2b25a15db14e43a241b4da9c2fad2288bb0239", "filename": "libffi/testsuite/libffi.call/nested_struct6.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct6.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -57,23 +57,15 @@ B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[4];\n   ffi_type* cls_struct_fields[3];\n   ffi_type* cls_struct_fields1[3];\n   ffi_type* cls_struct_fields2[3];\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[4];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -127,9 +119,9 @@ int main (void)\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));\n   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));\n \n-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);\n+  res_dbl = ((B(*)(A, B, C))(code))(e_dbl, f_dbl, g_dbl);\n   /* { dg-output \"\\n1 7 12 127 99 2 9: 15 242 143\" } */\n   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));"}, {"sha": "14c70239eb29025d4db59a44b3045e3e9944f369", "filename": "libffi/testsuite/libffi.call/nested_struct7.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct7.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -50,22 +50,14 @@ B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[3];\n   ffi_type* cls_struct_fields1[3];\n   ffi_type cls_struct_type, cls_struct_type1;\n   ffi_type* dbl_arg_types[3];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -107,9 +99,9 @@ int main (void)\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n \n-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);\n+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);\n   /* { dg-output \"\\n1 7 12 127 99: 13 233 134\" } */\n   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));"}, {"sha": "bb77ead8d328f49f101a2b2e59d111c4f2d0c237", "filename": "libffi/testsuite/libffi.call/nested_struct8.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct8.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -57,23 +57,15 @@ B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[4];\n   ffi_type* cls_struct_fields[3];\n   ffi_type* cls_struct_fields1[3];\n   ffi_type* cls_struct_fields2[3];\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[4];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -127,9 +119,9 @@ int main (void)\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));\n   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));\n \n-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);\n+  res_dbl = ((B(*)(A, B, C))(code))(e_dbl, f_dbl, g_dbl);\n   /* { dg-output \"\\n1 7 12 127 99 2 9: 15 242 143\" } */\n   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));"}, {"sha": "e9f541c83a85cde3d7e7380a86deccc07eb0dbc7", "filename": "libffi/testsuite/libffi.call/nested_struct9.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct9.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -57,23 +57,15 @@ B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args_dbl[4];\n   ffi_type* cls_struct_fields[3];\n   ffi_type* cls_struct_fields1[3];\n   ffi_type* cls_struct_fields2[3];\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[4];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -127,9 +119,9 @@ int main (void)\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));\n   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));\n \n-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);\n \n-  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);\n+  res_dbl = ((B(*)(A, B, C))(code))(e_dbl, f_dbl, g_dbl);\n   /* { dg-output \"\\n1 7 12 127 99 2 9: 15 242 143\" } */\n   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));"}, {"sha": "6a91555a1fa8ddaf285b777774a9564358b19ee5", "filename": "libffi/testsuite/libffi.call/problem1.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fproblem1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fproblem1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fproblem1.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -45,19 +45,11 @@ int main(void)\n   ffi_type* my_ffi_struct_fields[4];\n   ffi_type my_ffi_struct_type;\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n   void* args[4];\n   ffi_type* arg_types[3];\n \n-#ifdef USING_MMAP\n-  pcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n-\n   struct my_ffi_struct g = { 1.0, 2.0, 3.0 };\n   struct my_ffi_struct f = { 1.0, 2.0, 3.0 };\n   struct my_ffi_struct res;\n@@ -87,9 +79,9 @@ int main(void)\n   printf(\"res: %g %g %g\\n\", res.a, res.b, res.c);\n   /* { dg-output \"\\nres: 2 4 6\" } */\n \n-  CHECK(ffi_prep_closure(pcl, &cif, stub, NULL) == FFI_OK);\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, stub, NULL, code) == FFI_OK);\n \n-  res = ((my_ffi_struct(*)(struct my_ffi_struct, struct my_ffi_struct))(pcl))(g, f);\n+  res = ((my_ffi_struct(*)(struct my_ffi_struct, struct my_ffi_struct))(code))(g, f);\n   /* { dg-output \"\\n1 2 3 1 2 3: 2 4 6\" } */\n   printf(\"res: %g %g %g\\n\", res.a, res.b, res.c);\n   /* { dg-output \"\\nres: 2 4 6\" } */"}, {"sha": "5c2fe65aece065619036fea6248a92967942f10f", "filename": "libffi/testsuite/libffi.call/return_ldl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Freturn_ldl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Freturn_ldl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Freturn_ldl.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -4,7 +4,7 @@\n    PR:\t\tnone.\n    Originator:\t<andreast@gcc.gnu.org> 20071113  */\n \n-/* { dg-do run } */\n+/* { dg-do run { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */\n #include \"ffitest.h\"\n \n static long double return_ldl(long double ldl)"}, {"sha": "12819cf467d4ae59187e70a4f054fd50b8dcdba9", "filename": "libffi/testsuite/libffi.call/stret_large.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -75,21 +75,13 @@ cls_struct_108byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args, void* us\n int main (void)\n {\n \tffi_cif cif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure cl;\n-#endif\n-\tffi_closure *pcl;\n+        void *code;\n+\tffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tvoid* args_dbl[5];\n \tffi_type* cls_struct_fields[15];\n \tffi_type cls_struct_type;\n \tffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n \tcls_struct_type.size = 0;\n \tcls_struct_type.alignment = 0;\n \tcls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -139,10 +131,10 @@ int main (void)\n \t\tres_dbl.j, res_dbl.k, res_dbl.l, res_dbl.m, res_dbl.n);\n \t/* { dg-output \"\\nres: 22 15 17 25 6 13 19 18 22 15 17 25 6 16\" } */\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, cls_struct_108byte_gn, NULL) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_108byte_gn, NULL, code) == FFI_OK);\n \n \tres_dbl = ((struct_108byte(*)(struct_108byte, struct_108byte,\n-\t\tstruct_108byte, struct_108byte))(pcl))(e_dbl, f_dbl, g_dbl, h_dbl);\n+\t\tstruct_108byte, struct_108byte))(code))(e_dbl, f_dbl, g_dbl, h_dbl);\n \t/* { dg-output \"\\n22 15 17 25 6 13 19 18 22 15 17 25 6 16\" } */\n \tprintf(\"res: %g %g %g %g %g %g %g %g %g %g %g %g %g %d\\n\", res_dbl.a, res_dbl.b,\n \t\tres_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i,"}, {"sha": "e63bb67923afa091cdf1fd31e54bcff78d3df7e8", "filename": "libffi/testsuite/libffi.call/stret_large2.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large2.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -77,21 +77,13 @@ cls_struct_116byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args, void* us\n int main (void)\n {\n \tffi_cif cif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure cl;\n-#endif\n-\tffi_closure *pcl;\n+        void *code;\n+\tffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tvoid* args_dbl[5];\n \tffi_type* cls_struct_fields[16];\n \tffi_type cls_struct_type;\n \tffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n \tcls_struct_type.size = 0;\n \tcls_struct_type.alignment = 0;\n \tcls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -142,10 +134,10 @@ int main (void)\n \t\tres_dbl.j, res_dbl.k, res_dbl.l, res_dbl.m, res_dbl.n, res_dbl.o);\n \t/* { dg-output \"\\nres: 22 15 17 25 6 13 19 18 22 15 17 25 6 26 16\" } */\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, cls_struct_116byte_gn, NULL) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_116byte_gn, NULL, code) == FFI_OK);\n \n \tres_dbl = ((struct_116byte(*)(struct_116byte, struct_116byte,\n-\t\tstruct_116byte, struct_116byte))(pcl))(e_dbl, f_dbl, g_dbl, h_dbl);\n+\t\tstruct_116byte, struct_116byte))(code))(e_dbl, f_dbl, g_dbl, h_dbl);\n \t/* { dg-output \"\\n22 15 17 25 6 13 19 18 22 15 17 25 6 26 16\" } */\n \tprintf(\"res: %g %g %g %g %g %g %g %g %g %g %g %g %g %g %d\\n\", res_dbl.a, res_dbl.b,\n \t\tres_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i,"}, {"sha": "13c4464ffac856d7eae5ed2288b7f629eb1164b1", "filename": "libffi/testsuite/libffi.call/stret_medium.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fstret_medium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fstret_medium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstret_medium.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -61,21 +61,13 @@ cls_struct_72byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args, void* use\n int main (void)\n {\n \tffi_cif cif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure cl;\n-#endif\n-\tffi_closure *pcl;\n+        void *code;\n+\tffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tvoid* args_dbl[5];\n \tffi_type* cls_struct_fields[10];\n \tffi_type cls_struct_type;\n \tffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n \tcls_struct_type.size = 0;\n \tcls_struct_type.alignment = 0;\n \tcls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -119,10 +111,10 @@ int main (void)\n \t\tres_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i);\n \t/* { dg-output \"\\nres: 22 15 17 25 6 13 19 18 16\" } */\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, cls_struct_72byte_gn, NULL) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_72byte_gn, NULL, code) == FFI_OK);\n \n \tres_dbl = ((struct_72byte(*)(struct_72byte, struct_72byte,\n-\t\tstruct_72byte, struct_72byte))(pcl))(e_dbl, f_dbl, g_dbl, h_dbl);\n+\t\tstruct_72byte, struct_72byte))(code))(e_dbl, f_dbl, g_dbl, h_dbl);\n \t/* { dg-output \"\\n22 15 17 25 6 13 19 18 16\" } */\n \tprintf(\"res: %g %g %g %g %g %g %g %g %g\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n \t\tres_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i);"}, {"sha": "43703b21dd5b5457615ed5b4789f934bd3ba8527", "filename": "libffi/testsuite/libffi.call/stret_medium2.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fstret_medium2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.call%2Fstret_medium2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstret_medium2.c?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -61,21 +61,13 @@ cls_struct_72byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args, void* use\n int main (void)\n {\n \tffi_cif cif;\n-#ifndef USING_MMAP\n-\tstatic ffi_closure cl;\n-#endif\n-\tffi_closure *pcl;\n+        void *code;\n+\tffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n \tvoid* args_dbl[5];\n \tffi_type* cls_struct_fields[10];\n \tffi_type cls_struct_type;\n \tffi_type* dbl_arg_types[5];\n \n-#ifdef USING_MMAP\n-\tpcl = allocate_mmap (sizeof(ffi_closure));\n-#else\n-\tpcl = &cl;\n-#endif\n-\n \tcls_struct_type.size = 0;\n \tcls_struct_type.alignment = 0;\n \tcls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -119,10 +111,10 @@ int main (void)\n \t\tres_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i);\n \t/* { dg-output \"\\nres: 22 15 17 25 6 13 19 18 16\" } */\n \n-\tCHECK(ffi_prep_closure(pcl, &cif, cls_struct_72byte_gn, NULL) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_72byte_gn, NULL, code) == FFI_OK);\n \n \tres_dbl = ((struct_72byte(*)(struct_72byte, struct_72byte,\n-\t\tstruct_72byte, struct_72byte))(pcl))(e_dbl, f_dbl, g_dbl, h_dbl);\n+\t\tstruct_72byte, struct_72byte))(code))(e_dbl, f_dbl, g_dbl, h_dbl);\n \t/* { dg-output \"\\n22 15 17 25 6 13 19 18 16\" } */\n \tprintf(\"res: %g %g %g %g %g %g %g %g %lld\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n \t\tres_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i);"}, {"sha": "723871626d180c73171e312a4f61738b09fdca72", "filename": "libffi/testsuite/libffi.special/unwindtest.cc", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.special%2Funwindtest.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062b827975180b9b278666e5a08f6e55bb120010/libffi%2Ftestsuite%2Flibffi.special%2Funwindtest.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.special%2Funwindtest.cc?ref=062b827975180b9b278666e5a08f6e55bb120010", "patch": "@@ -6,6 +6,7 @@\n \n /* { dg-do run } */\n #include \"ffitestcxx.h\"\n+#include <stdint.h>\n \n void\n closure_test_fn(ffi_cif* cif __UNUSED__, void* resp __UNUSED__,\n@@ -27,7 +28,7 @@ void closure_test_fn1(ffi_cif* cif __UNUSED__, void* resp,\n       (int)(*(double*)args[8]) + (int)*(int *)args[9] +\n       (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +\n       (int)*(int *)args[12] + (int)(*(int *)args[13]) +\n-      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;\n+      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(intptr_t)userdata;\n \n     printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n \t   (int)*(float *)args[0], (int)(*(float *)args[1]),\n@@ -38,7 +39,7 @@ void closure_test_fn1(ffi_cif* cif __UNUSED__, void* resp,\n \t   (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n \t   (int)*(int *)args[12], (int)(*(int *)args[13]),\n \t   (int)(*(int *)args[14]), *(int *)args[15],\n-\t   (int)(long)userdata, (int)*(ffi_arg*)resp);\n+\t   (int)(intptr_t)userdata, (int)*(ffi_arg*)resp);\n \n     throw (int)*(ffi_arg*)resp;\n }\n@@ -50,27 +51,20 @@ typedef int (*closure_test_type1)(float, float, float, float, signed short,\n int main (void)\n {\n   ffi_cif cif;\n-#ifndef USING_MMAP\n-  static ffi_closure cl;\n-#endif\n-  ffi_closure *pcl;\n+  void *code;\n+  ffi_closure *pcl = (ffi_closure *)ffi_closure_alloc(sizeof(ffi_closure), &code);\n   ffi_type * cl_arg_types[17];\n-#ifdef USING_MMAP\n-  pcl = (ffi_closure *) allocate_mmap (sizeof(ffi_closure));\n-#else\n-  pcl = &cl;\n-#endif\n \n   {\n     cl_arg_types[1] = NULL;\n \n     CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 0,\n \t\t       &ffi_type_void, cl_arg_types) == FFI_OK);\n-    CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn, NULL) == FFI_OK);\n+    CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn, NULL, code) == FFI_OK);\n \n     try\n       {\n-\t(*((closure_test_type)(pcl)))();\n+\t(*((closure_test_type)(code)))();\n       } catch (int exception_code)\n       {\n \tCHECK(exception_code == 9);\n@@ -104,11 +98,11 @@ int main (void)\n       CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n \t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn1,\n-\t\t\t     (void *) 3 /* userdata */)  == FFI_OK);\n+      CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn1,\n+                                 (void *) 3 /* userdata */, code)  == FFI_OK);\n       try\n \t{\n-\t  (*((closure_test_type1)pcl))\n+\t  (*((closure_test_type1)code))\n \t    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,\n \t     19, 21, 1);\n \t  /* { dg-output \"\\n1 2 3 4 127 5 6 8 9 10 11 12 13 19 21 1 3: 255\" } */"}]}