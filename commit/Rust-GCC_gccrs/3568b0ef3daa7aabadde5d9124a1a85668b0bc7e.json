{"sha": "3568b0ef3daa7aabadde5d9124a1a85668b0bc7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU2OGIwZWYzZGFhN2FhYmFkZGU1ZDkxMjRhMWE4NTY2OGIwYmM3ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-04-17T01:11:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-04-17T01:11:21Z"}, "message": "rtl.h (MEM_ALIAS_SET): Update documentation.\n\n        * rtl.h (MEM_ALIAS_SET): Update documentation.\n        * doc/rtl.texi (Special Accessors): New node.\n        (SYMBOL_REF_FLAG): Note relationship with SYMBOL_REF_FLAGS.\n\nFrom-SVN: r65714", "tree": {"sha": "12fa4eee096212ec7dad56be89b4a84e875a7fd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12fa4eee096212ec7dad56be89b4a84e875a7fd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3568b0ef3daa7aabadde5d9124a1a85668b0bc7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3568b0ef3daa7aabadde5d9124a1a85668b0bc7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3568b0ef3daa7aabadde5d9124a1a85668b0bc7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3568b0ef3daa7aabadde5d9124a1a85668b0bc7e/comments", "author": null, "committer": null, "parents": [{"sha": "60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e"}], "stats": {"total": 148, "additions": 135, "deletions": 13}, "files": [{"sha": "644f928fd26ce7c46cc75a381acb109366e73953", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3568b0ef3daa7aabadde5d9124a1a85668b0bc7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3568b0ef3daa7aabadde5d9124a1a85668b0bc7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3568b0ef3daa7aabadde5d9124a1a85668b0bc7e", "patch": "@@ -1,3 +1,9 @@\n+2003-04-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* rtl.h (MEM_ALIAS_SET): Update documentation.\n+\t* doc/rtl.texi (Special Accessors): New node.\n+\t(SYMBOL_REF_FLAG): Note relationship with SYMBOL_REF_FLAGS.\n+\n 2003-04-16  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* reload1.c (reload_cse_noop_set_p): Return false if mode of"}, {"sha": "79594f0ed86090548651ae8a08381ca0e711e249", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 126, "deletions": 7, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3568b0ef3daa7aabadde5d9124a1a85668b0bc7e/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3568b0ef3daa7aabadde5d9124a1a85668b0bc7e/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=3568b0ef3daa7aabadde5d9124a1a85668b0bc7e", "patch": "@@ -23,6 +23,7 @@ form uses nested parentheses to indicate the pointers in the internal form.\n * RTL Objects::       Expressions vs vectors vs strings vs integers.\n * RTL Classes::       Categories of RTL expression objects, and their structure.\n * Accessors::         Macros to access expression operands or vector elts.\n+* Special Accessors:: Macros to access specific annotations on RTL.\n * Flags::             Other flags in an RTL expression.\n * Machine Modes::     Describing the size and format of a datum.\n * Constants::         Expressions with constant values.\n@@ -368,6 +369,120 @@ All the macros defined in this section expand into lvalues and therefore\n can be used to assign the operands, lengths and vector elements as well as\n to access them.\n \n+@node Special Accessors\n+@section Access to Special Operands\n+@cindex access to special operands\n+\n+Some RTL nodes have special annotations associated with them.\n+\n+@table @code\n+@item MEM\n+@table @code\n+@findex MEM_ALIAS_SET\n+@item MEM_ALIAS_SET (@var{x})\n+If 0, @var{x} is not in any alias set, and may alias anything.  Otherwise,\n+@var{x} can only alias @code{MEM}s in a conflicting alias set.  This value\n+is set in a language-dependent manner in the front-end, and should not be\n+altered in the back-end.  In some front-ends, these numbers may correspond\n+in some way to types, or other language-level entities, but they need not,\n+and the back-end makes no such assumptions.\n+These set numbers are tested with @code{alias_sets_conflict_p}.\n+\n+@findex MEM_EXPR\n+@item MEM_EXPR (@var{x})\n+If this register is known to hold the value of some user-level\n+declaration, this is that tree node.  It may also be a\n+@code{COMPONENT_REF}, in which case this is some field reference,\n+and @code{TREE_OPERAND (@var{x}, 0)} contains the declaration,\n+or another @code{COMPONENT_REF}, or null if there is no compile-time\n+object associated with the reference.\n+\n+@findex MEM_OFFSET\n+@item MEM_OFFSET (@var{x})\n+The offset from the start of @code{MEM_EXPR} as a @code{CONST_INT} rtx.\n+\n+@findex MEM_SIZE\n+@item MEM_SIZE (@var{x})\n+The size in bytes of the memory reference as a @code{CONST_INT} rtx.\n+This is mostly relevant for @code{BLKmode} references as otherwise\n+the size is implied by the mode.\n+\n+@findex MEM_ALIGN\n+@item MEM_ALIGN (@var{x})\n+The known alignment in bits of the memory reference.\n+@end table\n+\n+@item REG\n+@table @code\n+@findex ORIGINAL_REGNO\n+@item ORIGINAL_REGNO (@var{x})\n+This field holds the number the register ``originally'' had; for a\n+pseudo register turned into a hard reg this will hold the old pseudo\n+register number.\n+\n+@findex REG_EXPR\n+@item REG_EXPR (@var{x})\n+If this register is known to hold the value of some user-level\n+declaration, this is that tree node.\n+\n+@findex REG_OFFSET\n+@item REG_OFFSET (@var{x})\n+If this register is known to hold the value of some user-level\n+declaration, this is the offset into that logical storage.\n+@end table\n+\n+@item SYMBOL_REF\n+@table @code\n+@findex SYMBOL_REF_DECL\n+@item SYMBOL_REF_DECL (@var{x})\n+If the @code{symbol_ref} @var{x} was created for a @code{VAR_DECL} or\n+a @code{FUNCTION_DECL}, that tree is recorded here.  If this value is\n+null, then @var{x} was created by back end code generation routines,\n+and so there is no associated front end symbol table entry.\n+\n+@findex SYMBOL_REF_FLAGS\n+@item SYMBOL_REF_FLAGS (@var{x})\n+In a @code{symbol_ref}, this is used to communicate various predicates\n+about the symbol.  Some of these are common enough to be computed by\n+common code, some are specific to the target.  The common bits are:\n+\n+@table @code\n+@findex SYMBOL_REF_FUNCTION_P\n+@findex SYMBOL_FLAG_FUNCTION\n+@item SYMBOL_FLAG_FUNCTION\n+Set if the symbol refers to a function.\n+\n+@findex SYMBOL_REF_LOCAL_P\n+@findex SYMBOL_FLAG_LOCAL\n+@item SYMBOL_FLAG_LOCAL\n+Set if the symbol is local to this ``module''.\n+See @code{TARGET_BINDS_LOCAL_P}.\n+\n+@findex SYMBOL_REF_EXTERNAL_P\n+@findex SYMBOL_FLAG_EXTERNAL\n+@item SYMBOL_FLAG_EXTERNAL\n+Set if this symbol is not defined in this translation unit.\n+Note that this is not the inverse of @code{SYMBOL_FLAG_LOCAL}.\n+\n+@findex SYMBOL_REF_SMALL_P\n+@findex SYMBOL_FLAG_SMALL\n+@item SYMBOL_FLAG_SMALL\n+Set if the symbol is located in the small data section.\n+See @code{TARGET_IN_SMALL_DATA_P}.\n+\n+@findex SYMBOL_FLAG_TLS_SHIFT\n+@findex SYMBOL_REF_TLS_MODEL\n+@item SYMBOL_REF_TLS_MODEL (@var{x})\n+This is a multi-bit field accessor that returns the @code{tls_model}\n+to be used for a thread-local storage symbol.  It returns zero for\n+non-thread-local symbols.\n+@end table\n+\n+Bits beginning with @code{SYMBOL_FLAG_MACH_DEP} are available for\n+the target's use.\n+@end table\n+@end table\n+\n @node Flags\n @section Flags in an RTL Expression\n @cindex flags in RTL expression\n@@ -687,13 +802,6 @@ Promoted variables are always either sign- or zero-extended to the wider\n mode on every assignment.  Stored in the @code{in_struct} field and\n printed as @samp{/s}.\n \n-@findex SYMBOL_REF_FLAG\n-@cindex @code{symbol_ref} and @samp{/v}\n-@cindex @code{volatil}, in @code{symbol_ref}\n-@item SYMBOL_REF_FLAG (@var{x})\n-In a @code{symbol_ref}, this is used as a flag for machine-specific purposes.\n-Stored in the @code{volatil} field and printed as @samp{/v}.\n-\n @findex SYMBOL_REF_USED\n @cindex @code{used}, in @code{symbol_ref}\n @item SYMBOL_REF_USED (@var{x})\n@@ -707,6 +815,17 @@ once.  Stored in the @code{used} field.\n @item SYMBOL_REF_WEAK (@var{x})\n In a @code{symbol_ref}, indicates that @var{x} has been declared weak.\n Stored in the @code{integrated} field and printed as @samp{/i}.\n+\n+@findex SYMBOL_REF_FLAG\n+@cindex @code{symbol_ref} and @samp{/v}\n+@cindex @code{volatil}, in @code{symbol_ref}\n+@item SYMBOL_REF_FLAG (@var{x})\n+In a @code{symbol_ref}, this is used as a flag for machine-specific purposes.\n+Stored in the @code{volatil} field and printed as @samp{/v}.\n+\n+Most uses of @code{SYMBOL_REF_FLAG} are historic and may be subsumed\n+by @code{SYMBOL_REF_FLAGS}.  Certainly use of @code{SYMBOL_REF_FLAGS}\n+is mandatory if the target requires more than one bit of storage.\n @end table\n \n These are the fields to which the above macros refer:"}, {"sha": "096e429d4b26c90bc61da38e10abbbbeb4c8c866", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3568b0ef3daa7aabadde5d9124a1a85668b0bc7e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3568b0ef3daa7aabadde5d9124a1a85668b0bc7e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3568b0ef3daa7aabadde5d9124a1a85668b0bc7e", "patch": "@@ -1133,13 +1133,10 @@ do {\t\t\t\t\t\t\\\n \n /* For a MEM rtx, the alias set.  If 0, this MEM is not in any alias\n    set, and may alias anything.  Otherwise, the MEM can only alias\n-   MEMs in the same alias set.  This value is set in a\n+   MEMs in a conflicting alias set.  This value is set in a\n    language-dependent manner in the front-end, and should not be\n-   altered in the back-end.  These set numbers are tested for zero,\n-   and compared for equality; they have no other significance.  In\n-   some front-ends, these numbers may correspond in some way to types,\n-   or other language-level entities, but they need not, and the\n-   back-end makes no such assumptions.  */\n+   altered in the back-end.  These set numbers are tested with\n+   alias_sets_conflict_p.  */\n #define MEM_ALIAS_SET(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->alias)\n \n /* For a MEM rtx, the decl it is known to refer to, if it is known to"}]}