{"sha": "98c3a782774396163f6bcacf91515131e3abe375", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThjM2E3ODI3NzQzOTYxNjNmNmJjYWNmOTE1MTUxMzFlM2FiZTM3NQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-09-17T18:18:05Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-09-17T18:18:05Z"}, "message": "c-tree.h (enum c_typespec_keyword): New.\n\n\t* c-tree.h (enum c_typespec_keyword): New.\n\t(struct c_declspecs): Adjust description of \"type\".  Remove\n\tspecbits, explicit_int_p and explicit_char_p.  Rename\n\ttypedef_signed_p to explicit_signed_p.  Add default_int_p, long_p,\n\tshort_p, signed_p, unsigned_p and complex_p.\n\t(finish_declspecs): New.\n\t* c-parse.in (datadef, datadecl, setspecs, decl, component_decl,\n\ttypename): Call finish_declspecs.\n\t* c-decl.c (finish_declspecs): New.\n\t(declspecs_add_type): Check for combinations which cannot occur in\n\tvalid specifier lists.  Update comments.\n\t(shadow_tag_warned): Remove checks done in finish_declspecs.\n\tDon't report useless type name if type defaulted to int.\n\t(grokdeclarator): Remove checks and actions done in\n\tfinish_declspecs.  Don't allow for type being NULL.  Update for\n\tdatastructures changes.  Initialize decl_attr.\n\t(build_null_declspecs, quals_from_declspecs): Update for\n\tdatastructures changes.\n\ntestsuite:\n\t* gcc.dg/declspec-4.c, gcc.dg/declspec-5.c, gcc.dg/declspec-6.c:\n\tUpdate expected messages.\n\t* gcc.dg/declspec-13.c: New test.\n\nFrom-SVN: r87660", "tree": {"sha": "065e742552e8a8e99595de375f55074a900b5eb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/065e742552e8a8e99595de375f55074a900b5eb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98c3a782774396163f6bcacf91515131e3abe375", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c3a782774396163f6bcacf91515131e3abe375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98c3a782774396163f6bcacf91515131e3abe375", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c3a782774396163f6bcacf91515131e3abe375/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "254ea84c129481587eae80d78783b08d8d6cd507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/254ea84c129481587eae80d78783b08d8d6cd507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/254ea84c129481587eae80d78783b08d8d6cd507"}], "stats": {"total": 867, "additions": 602, "deletions": 265}, "files": [{"sha": "04eec4c48d8c952a8f2d103a5e9695d31593b24d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c3a782774396163f6bcacf91515131e3abe375/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c3a782774396163f6bcacf91515131e3abe375/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98c3a782774396163f6bcacf91515131e3abe375", "patch": "@@ -1,3 +1,24 @@\n+2004-09-17  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* c-tree.h (enum c_typespec_keyword): New.\n+\t(struct c_declspecs): Adjust description of \"type\".  Remove\n+\tspecbits, explicit_int_p and explicit_char_p.  Rename\n+\ttypedef_signed_p to explicit_signed_p.  Add default_int_p, long_p,\n+\tshort_p, signed_p, unsigned_p and complex_p.\n+\t(finish_declspecs): New.\n+\t* c-parse.in (datadef, datadecl, setspecs, decl, component_decl,\n+\ttypename): Call finish_declspecs.\n+\t* c-decl.c (finish_declspecs): New.\n+\t(declspecs_add_type): Check for combinations which cannot occur in\n+\tvalid specifier lists.  Update comments.\n+\t(shadow_tag_warned): Remove checks done in finish_declspecs.\n+\tDon't report useless type name if type defaulted to int.\n+\t(grokdeclarator): Remove checks and actions done in\n+\tfinish_declspecs.  Don't allow for type being NULL.  Update for\n+\tdatastructures changes.  Initialize decl_attr.\n+\t(build_null_declspecs, quals_from_declspecs): Update for\n+\tdatastructures changes.\n+\n 2004-09-17  Sylvain Pion  <Sylvain.Pion@sophia.inria.fr>\n \n         * doc/extend.texi: Fix duplicated word."}, {"sha": "e1e8d4d8f0ddbe80f6074fb93f21f33839f7f48b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 404, "deletions": 216, "changes": 620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=98c3a782774396163f6bcacf91515131e3abe375", "patch": "@@ -2681,7 +2681,7 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \n   pending_invalid_xref = 0;\n \n-  if (declspecs->type && !declspecs->typedef_p)\n+  if (declspecs->type && !declspecs->default_int_p && !declspecs->typedef_p)\n     {\n       tree value = declspecs->type;\n       enum tree_code code = TREE_CODE (value);\n@@ -2730,17 +2730,6 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n       warned = 1;\n     }\n \n-  if (found_tag && (declspecs->specbits & ((1 << (int) RID_LONG)\n-\t\t\t\t\t   | (1 << (int) RID_SHORT)\n-\t\t\t\t\t   | (1 << (int) RID_UNSIGNED)\n-\t\t\t\t\t   | (1 << (int) RID_SIGNED)\n-\t\t\t\t\t   | (1 << (int) RID_COMPLEX))))\n-    {\n-      error (\"long, short, signed, unsigned or complex used invalidly \"\n-\t     \"in empty declaration\");\n-      warned = 1;\n-    }\n-\n   if (declspecs->inline_p)\n     {\n       error (\"%<inline%> in empty declaration\");\n@@ -2779,12 +2768,6 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n       warned = 2;\n     }\n \n-  if (!warned && !in_system_header && declspecs->specbits)\n-    {\n-      warning (\"useless keyword or type name in empty declaration\");\n-      warned = 2;\n-    }\n-\n   if (warned != 1)\n     {\n       if (!found_tag)\n@@ -2805,14 +2788,17 @@ quals_from_declspecs (const struct c_declspecs *specs)\n \t       | (specs->restrict_p ? TYPE_QUAL_RESTRICT : 0));\n   gcc_assert (!specs->type\n \t      && !specs->decl_attr\n-\t      && !specs->specbits\n+\t      && specs->typespec_word == cts_none\n \t      && specs->storage_class == csc_none\n \t      && !specs->typedef_p\n-\t      && !specs->typedef_signed_p\n+\t      && !specs->explicit_signed_p\n \t      && !specs->deprecated_p\n-\t      && !specs->explicit_int_p\n-\t      && !specs->explicit_char_p\n+\t      && !specs->long_p\n \t      && !specs->long_long_p\n+\t      && !specs->short_p\n+\t      && !specs->signed_p\n+\t      && !specs->unsigned_p\n+\t      && !specs->complex_p\n \t      && !specs->inline_p\n \t      && !specs->thread_p);\n   return quals;\n@@ -3673,21 +3659,19 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\tstruct c_declspecs *declspecs,\n \t\tenum decl_context decl_context, bool initialized, tree *width)\n {\n-  int specbits = declspecs->specbits;\n   tree type = declspecs->type;\n   bool threadp = declspecs->thread_p;\n   enum c_storage_class storage_class = declspecs->storage_class;\n   int constp;\n   int restrictp;\n   int volatilep;\n   int type_quals = TYPE_UNQUALIFIED;\n-  int defaulted_int = 0;\n   const char *name, *orig_name;\n   tree typedef_type = 0;\n   int funcdef_flag = 0;\n   bool funcdef_syntax = false;\n   int size_varies = 0;\n-  tree decl_attr = NULL_TREE;\n+  tree decl_attr = declspecs->decl_attr;\n   int array_ptr_quals = TYPE_UNQUALIFIED;\n   tree array_ptr_attrs = NULL_TREE;\n   int array_parm_static = 0;\n@@ -3749,182 +3733,28 @@ grokdeclarator (const struct c_declarator *declarator,\n     warn_deprecated_use (declspecs->type);\n \n   typedef_type = type;\n-  if (type)\n-    size_varies = C_TYPE_VARIABLE_SIZE (type);\n-\n-  /* No type at all: default to `int', and set DEFAULTED_INT\n-     because it was not a user-defined typedef.  */\n+  size_varies = C_TYPE_VARIABLE_SIZE (type);\n \n-  if (type == 0)\n-    {\n-      if ((! (specbits & ((1 << (int) RID_LONG) | (1 << (int) RID_SHORT)\n-\t\t\t  | (1 << (int) RID_SIGNED)\n-\t\t\t  | (1 << (int) RID_UNSIGNED)\n-\t\t\t  | (1 << (int) RID_COMPLEX))))\n-\t  /* Don't warn about typedef foo = bar.  */\n-\t  && ! (storage_class == csc_typedef && initialized)\n-\t  && ! in_system_header)\n-\t{\n-\t  /* Issue a warning if this is an ISO C 99 program or if -Wreturn-type\n-\t     and this is a function, or if -Wimplicit; prefer the former\n-\t     warning since it is more explicit.  */\n-\t  if ((warn_implicit_int || warn_return_type || flag_isoc99)\n-\t      && funcdef_flag)\n-\t    warn_about_return_type = 1;\n-\t  else if (warn_implicit_int || flag_isoc99)\n-\t    pedwarn_c99 (\"type defaults to %<int%> in declaration of %qs\",\n-\t\t\t name);\n-\t}\n+  /* Diagnose defaulting to \"int\".  */\n \n-      defaulted_int = 1;\n-      type = integer_type_node;\n-    }\n-\n-  /* Now process the modifiers that were specified\n-     and check for invalid combinations.  */\n-\n-  /* Long double is a special combination.  */\n-\n-  if ((specbits & 1 << (int) RID_LONG) && ! declspecs->long_long_p\n-      && TYPE_MAIN_VARIANT (type) == double_type_node)\n+  if (declspecs->default_int_p && !in_system_header)\n     {\n-      specbits &= ~(1 << (int) RID_LONG);\n-      type = long_double_type_node;\n+      /* Issue a warning if this is an ISO C 99 program or if\n+\t -Wreturn-type and this is a function, or if -Wimplicit;\n+\t prefer the former warning since it is more explicit.  */\n+      if ((warn_implicit_int || warn_return_type || flag_isoc99)\n+\t  && funcdef_flag)\n+\twarn_about_return_type = 1;\n+      else if (warn_implicit_int || flag_isoc99)\n+\tpedwarn_c99 (\"type defaults to %<int%> in declaration of %qs\", name);\n     }\n \n-  /* Check all other uses of type modifiers.  */\n-\n-  if (specbits & ((1 << (int) RID_LONG) | (1 << (int) RID_SHORT)\n-\t\t  | (1 << (int) RID_UNSIGNED) | (1 << (int) RID_SIGNED)))\n-    {\n-      int ok = 0;\n-\n-      if ((specbits & 1 << (int) RID_LONG)\n-\t  && (specbits & 1 << (int) RID_SHORT))\n-\terror (\"both long and short specified for %qs\", name);\n-      else if (((specbits & 1 << (int) RID_LONG)\n-\t\t|| (specbits & 1 << (int) RID_SHORT))\n-\t       && declspecs->explicit_char_p)\n-\terror (\"long or short specified with char for %qs\", name);\n-      else if (((specbits & 1 << (int) RID_LONG)\n-\t\t|| (specbits & 1 << (int) RID_SHORT))\n-\t       && TREE_CODE (type) == REAL_TYPE)\n-\t{\n-\t  static int already = 0;\n-\n-\t  error (\"long or short specified with floating type for %qs\", name);\n-\t  if (! already && ! pedantic)\n-\t    {\n-\t      error (\"the only valid combination is %<long double%>\");\n-\t      already = 1;\n-\t    }\n-\t}\n-      else if ((specbits & 1 << (int) RID_SIGNED)\n-\t       && (specbits & 1 << (int) RID_UNSIGNED))\n-\terror (\"both signed and unsigned specified for %qs\", name);\n-      else if (TREE_CODE (type) != INTEGER_TYPE)\n-\terror (\"long, short, signed or unsigned invalid for %qs\", name);\n-      else\n-\t{\n-\t  ok = 1;\n-\t  if (!declspecs->explicit_int_p && !defaulted_int\n-\t      && !declspecs->explicit_char_p)\n-\t    {\n-\t      error (\"long, short, signed or unsigned used invalidly for %qs\",\n-\t\t     name);\n-\t      ok = 0;\n-\t    }\n-\t}\n-\n-      /* Discard the type modifiers if they are invalid.  */\n-      if (! ok)\n-\t{\n-\t  specbits &= ~((1 << (int) RID_LONG) | (1 << (int) RID_SHORT)\n-\t\t\t| (1 << (int) RID_UNSIGNED) | (1 << (int) RID_SIGNED));\n-\t  declspecs->long_long_p = 0;\n-\t}\n-    }\n-\n-  if ((specbits & (1 << (int) RID_COMPLEX))\n-      && TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != REAL_TYPE)\n-    {\n-      error (\"complex invalid for %qs\", name);\n-      specbits &= ~(1 << (int) RID_COMPLEX);\n-    }\n-\n-  /* Decide whether an integer type is signed or not.\n-     Optionally treat bit-fields as signed by default.  */\n-  if (specbits & 1 << (int) RID_UNSIGNED\n-      || (bitfield && ! flag_signed_bitfields\n-\t  && (declspecs->explicit_int_p || defaulted_int\n-\t      || declspecs->explicit_char_p\n-\t      /* A typedef for plain `int' without `signed'\n-\t\t can be controlled just like plain `int'.  */\n-\t      || !declspecs->typedef_signed_p)\n-\t  && TREE_CODE (type) != ENUMERAL_TYPE\n-\t  && !(specbits & 1 << (int) RID_SIGNED)))\n-    {\n-      if (declspecs->long_long_p)\n-\ttype = long_long_unsigned_type_node;\n-      else if (specbits & 1 << (int) RID_LONG)\n-\ttype = long_unsigned_type_node;\n-      else if (specbits & 1 << (int) RID_SHORT)\n-\ttype = short_unsigned_type_node;\n-      else if (type == char_type_node)\n-\ttype = unsigned_char_type_node;\n-      else if (declspecs->typedef_p)\n-\ttype = c_common_unsigned_type (type);\n-      else\n-\ttype = unsigned_type_node;\n-    }\n-  else if ((specbits & 1 << (int) RID_SIGNED)\n-\t   && type == char_type_node)\n-    type = signed_char_type_node;\n-  else if (declspecs->long_long_p)\n-    type = long_long_integer_type_node;\n-  else if (specbits & 1 << (int) RID_LONG)\n-    type = long_integer_type_node;\n-  else if (specbits & 1 << (int) RID_SHORT)\n-    type = short_integer_type_node;\n-\n-  if (specbits & 1 << (int) RID_COMPLEX)\n-    {\n-      if (pedantic && !flag_isoc99)\n-\tpedwarn (\"ISO C90 does not support complex types\");\n-      /* If we just have \"complex\", it is equivalent to\n-\t \"complex double\", but if any modifiers at all are specified it is\n-\t the complex form of TYPE.  E.g, \"complex short\" is\n-\t \"complex short int\".  */\n-\n-      if (defaulted_int && ! declspecs->long_long_p\n-\t  && ! (specbits & ((1 << (int) RID_LONG) | (1 << (int) RID_SHORT)\n-\t\t\t    | (1 << (int) RID_SIGNED)\n-\t\t\t    | (1 << (int) RID_UNSIGNED))))\n-\t{\n-\t  if (pedantic)\n-\t    pedwarn (\"ISO C does not support plain %<complex%> meaning \"\n-\t\t     \"%<double complex%>\");\n-\t  type = complex_double_type_node;\n-\t}\n-      else if (type == integer_type_node)\n-\t{\n-\t  if (pedantic)\n-\t    pedwarn (\"ISO C does not support complex integer types\");\n-\t  type = complex_integer_type_node;\n-\t}\n-      else if (type == float_type_node)\n-\ttype = complex_float_type_node;\n-      else if (type == double_type_node)\n-\ttype = complex_double_type_node;\n-      else if (type == long_double_type_node)\n-\ttype = complex_long_double_type_node;\n-      else\n-\t{\n-\t  if (pedantic)\n-\t    pedwarn (\"ISO C does not support complex integer types\");\n-\t  type = build_complex_type (type);\n-\t}\n-    }\n+  /* Adjust the type if a bit-field is being declared,\n+     -funsigned-bitfields applied and the type is not explicitly\n+     \"signed\".  */\n+  if (bitfield && !flag_signed_bitfields && !declspecs->explicit_signed_p\n+      && TREE_CODE (type) == INTEGER_TYPE)\n+    type = c_common_unsigned_type (type);\n \n   /* Check the type and width of a bit-field.  */\n   if (bitfield)\n@@ -4397,8 +4227,7 @@ grokdeclarator (const struct c_declarator *declarator,\n       if (type_quals)\n \ttype = c_build_qualified_type (type, type_quals);\n       decl = build_decl (TYPE_DECL, declarator->u.id, type);\n-      if ((specbits & (1 << (int) RID_SIGNED))\n-\t  || declspecs->typedef_signed_p)\n+      if (declspecs->explicit_signed_p)\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n       decl_attributes (&decl, returned_attrs, 0);\n       if (declspecs->inline_p)\n@@ -4602,7 +4431,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \tif (funcdef_flag)\n \t  current_function_arg_info = arg_info;\n \n-\tif (defaulted_int)\n+\tif (declspecs->default_int_p)\n \t  C_FUNCTION_IMPLICIT_INT (decl) = 1;\n \n \t/* Record presence of `inline', if it is reasonable.  */\n@@ -6765,15 +6594,19 @@ build_null_declspecs (void)\n   ret->type = 0;\n   ret->decl_attr = 0;\n   ret->attrs = 0;\n-  ret->specbits = 0;\n+  ret->typespec_word = cts_none;\n   ret->storage_class = csc_none;\n   ret->non_sc_seen_p = false;\n   ret->typedef_p = false;\n-  ret->typedef_signed_p = false;\n+  ret->explicit_signed_p = false;\n   ret->deprecated_p = false;\n-  ret->explicit_int_p = false;\n-  ret->explicit_char_p = false;\n+  ret->default_int_p = false;\n+  ret->long_p = false;\n   ret->long_long_p = false;\n+  ret->short_p = false;\n+  ret->signed_p = false;\n+  ret->unsigned_p = false;\n+  ret->complex_p = false;\n   ret->inline_p = false;\n   ret->thread_p = false;\n   ret->const_p = false;\n@@ -6825,38 +6658,254 @@ declspecs_add_type (struct c_declspecs *specs, tree type)\n   specs->non_sc_seen_p = true;\n   if (TREE_DEPRECATED (type))\n     specs->deprecated_p = true;\n-  if (type == ridpointers[(int) RID_INT])\n-    specs->explicit_int_p = true;\n-  if (type == ridpointers[(int) RID_CHAR])\n-    specs->explicit_char_p = true;\n \n+  /* Handle type specifier keywords.  */\n   if (TREE_CODE (type) == IDENTIFIER_NODE && C_IS_RESERVED_WORD (type))\n     {\n       enum rid i = C_RID_CODE (type);\n+      if (specs->type)\n+\t{\n+\t  error (\"two or more data types in declaration specifiers\");\n+\t  return specs;\n+\t}\n       if ((int) i <= (int) RID_LAST_MODIFIER)\n \t{\n-\t  if (i == RID_LONG && (specs->specbits & (1 << (int) RID_LONG)))\n+\t  /* \"long\", \"short\", \"signed\", \"unsigned\" or \"_Complex\".  */\n+\t  bool dupe = false;\n+\t  switch (i)\n \t    {\n+\t    case RID_LONG:\n \t      if (specs->long_long_p)\n-\t\terror (\"%<long long long%> is too long for GCC\");\n-\t      else\n \t\t{\n+\t\t  error (\"%<long long long%> is too long for GCC\");\n+\t\t  break;\n+\t\t}\n+\t      if (specs->long_p)\n+\t\t{\n+\t\t  if (specs->typespec_word == cts_double)\n+\t\t    {\n+\t\t      error (\"both %<long long%> and %<double%> in \"\n+\t\t\t     \"declaration specifiers\");\n+\t\t      break;\n+\t\t    }\n \t\t  if (pedantic && !flag_isoc99 && !in_system_header\n \t\t      && warn_long_long)\n \t\t    pedwarn (\"ISO C90 does not support %<long long%>\");\n \t\t  specs->long_long_p = 1;\n+\t\t  break;\n \t\t}\n+\t      if (specs->short_p)\n+\t\terror (\"both %<long%> and %<short%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_void)\n+\t\terror (\"both %<long%> and %<void%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_bool)\n+\t\terror (\"both %<long%> and %<_Bool%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_char)\n+\t\terror (\"both %<long%> and %<char%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_float)\n+\t\terror (\"both %<long%> and %<float%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else\n+\t\tspecs->long_p = true;\n+\t      break;\n+\t    case RID_SHORT:\n+\t      dupe = specs->short_p;\n+\t      if (specs->long_p)\n+\t\terror (\"both %<long%> and %<short%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_void)\n+\t\terror (\"both %<short%> and %<void%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_bool)\n+\t\terror (\"both %<short%> and %<_Bool%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_char)\n+\t\terror (\"both %<short%> and %<char%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_float)\n+\t\terror (\"both %<short%> and %<float%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_double)\n+\t\terror (\"both %<short%> and %<double%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else\n+\t\tspecs->short_p = true;\n+\t      break;\n+\t    case RID_SIGNED:\n+\t      dupe = specs->signed_p;\n+\t      if (specs->unsigned_p)\n+\t\terror (\"both %<signed%> and %<unsigned%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_void)\n+\t\terror (\"both %<signed%> and %<void%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_bool)\n+\t\terror (\"both %<signed%> and %<_Bool%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_float)\n+\t\terror (\"both %<signed%> and %<float%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_double)\n+\t\terror (\"both %<signed%> and %<double%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else\n+\t\tspecs->signed_p = true;\n+\t      break;\n+\t    case RID_UNSIGNED:\n+\t      dupe = specs->unsigned_p;\n+\t      if (specs->signed_p)\n+\t\terror (\"both %<signed%> and %<unsigned%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_void)\n+\t\terror (\"both %<unsigned%> and %<void%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_bool)\n+\t\terror (\"both %<unsigned%> and %<_Bool%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_float)\n+\t\terror (\"both %<unsigned%> and %<float%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_double)\n+\t\terror (\"both %<unsigned%> and %<double%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else\n+\t\tspecs->unsigned_p = true;\n+\t      break;\n+\t    case RID_COMPLEX:\n+\t      dupe = specs->complex_p;\n+\t      if (pedantic && !flag_isoc99)\n+\t\tpedwarn (\"ISO C90 does not support complex types\");\n+\t      if (specs->typespec_word == cts_void)\n+\t\terror (\"both %<complex%> and %<void%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_bool)\n+\t\terror (\"both %<complex%> and %<_Bool%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else\n+\t\tspecs->complex_p = true;\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n \t    }\n-\t  else if (specs->specbits & (1 << (int) i))\n+\n+\t  if (dupe)\n \t    error (\"duplicate %qs\", IDENTIFIER_POINTER (type));\n \n-\t  specs->specbits |= 1 << (int) i;\n \t  return specs;\n \t}\n+      else\n+\t{\n+\t  /* \"void\", \"_Bool\", \"char\", \"int\", \"float\" or \"double\".  */\n+\t  if (specs->typespec_word != cts_none)\n+\t    {\n+\t      error (\"two or more data types in declaration specifiers\");\n+\t      return specs;\n+\t    }\n+\t  switch (i)\n+\t    {\n+\t    case RID_VOID:\n+\t      if (specs->long_p)\n+\t\terror (\"both %<long%> and %<void%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->short_p)\n+\t\terror (\"both %<short%> and %<void%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->signed_p)\n+\t\terror (\"both %<signed%> and %<void%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->unsigned_p)\n+\t\terror (\"both %<unsigned%> and %<void%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->complex_p)\n+\t\terror (\"both %<complex%> and %<void%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else\n+\t\tspecs->typespec_word = cts_void;\n+\t      return specs;\n+\t    case RID_BOOL:\n+\t      if (specs->long_p)\n+\t\terror (\"both %<long%> and %<_Bool%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->short_p)\n+\t\terror (\"both %<short%> and %<_Bool%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->signed_p)\n+\t\terror (\"both %<signed%> and %<_Bool%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->unsigned_p)\n+\t\terror (\"both %<unsigned%> and %<_Bool%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->complex_p)\n+\t\terror (\"both %<complex%> and %<_Bool%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else\n+\t\tspecs->typespec_word = cts_bool;\n+\t      return specs;\n+\t    case RID_CHAR:\n+\t      if (specs->long_p)\n+\t\terror (\"both %<long%> and %<char%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->short_p)\n+\t\terror (\"both %<short%> and %<char%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else\n+\t\tspecs->typespec_word = cts_char;\n+\t      return specs;\n+\t    case RID_INT:\n+\t      specs->typespec_word = cts_int;\n+\t      return specs;\n+\t    case RID_FLOAT:\n+\t      if (specs->long_p)\n+\t\terror (\"both %<long%> and %<float%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->short_p)\n+\t\terror (\"both %<short%> and %<float%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->signed_p)\n+\t\terror (\"both %<signed%> and %<float%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->unsigned_p)\n+\t\terror (\"both %<unsigned%> and %<float%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else\n+\t\tspecs->typespec_word = cts_float;\n+\t      return specs;\n+\t    case RID_DOUBLE:\n+\t      if (specs->long_long_p)\n+\t\terror (\"both %<long long%> and %<double%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->short_p)\n+\t\terror (\"both %<short%> and %<double%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->signed_p)\n+\t\terror (\"both %<signed%> and %<double%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->unsigned_p)\n+\t\terror (\"both %<unsigned%> and %<double%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else\n+\t\tspecs->typespec_word = cts_double;\n+\t      return specs;\n+\t    default:\n+\t      /* ObjC reserved word \"id\", handled below.  */\n+\t      break;\n+\t    }\n+\t}\n     }\n-  if (specs->type)\n+\n+  /* Now we have a typedef (a TYPE_DECL node), an identifier (some\n+     form of ObjC type, cases such as \"int\" and \"long\" being handled\n+     above), a TYPE (struct, union, enum and typeof specifiers) or an\n+     ERROR_MARK.  In none of these cases may there have previously\n+     been any type specifiers.  */\n+  if (specs->type || specs->typespec_word != cts_none\n+      || specs->long_p || specs->short_p || specs->signed_p\n+      || specs->unsigned_p || specs->complex_p)\n     error (\"two or more data types in declaration specifiers\");\n-  /* Actual typedefs come to us as TYPE_DECL nodes.  */\n   else if (TREE_CODE (type) == TYPE_DECL)\n     {\n       if (TREE_TYPE (type) == error_mark_node)\n@@ -6866,10 +6915,9 @@ declspecs_add_type (struct c_declspecs *specs, tree type)\n \t  specs->type = TREE_TYPE (type);\n \t  specs->decl_attr = DECL_ATTRIBUTES (type);\n \t  specs->typedef_p = true;\n-\t  specs->typedef_signed_p = C_TYPEDEF_EXPLICITLY_SIGNED (type);\n+\t  specs->explicit_signed_p = C_TYPEDEF_EXPLICITLY_SIGNED (type);\n \t}\n     }\n-  /* Built-in types come as identifiers.  */\n   else if (TREE_CODE (type) == IDENTIFIER_NODE)\n     {\n       tree t = lookup_name (type);\n@@ -6981,6 +7029,146 @@ declspecs_add_attrs (struct c_declspecs *specs, tree attrs)\n   return specs;\n }\n \n+/* Combine \"long\", \"short\", \"signed\", \"unsigned\" and \"_Complex\" type\n+   specifiers with any other type specifier to determine the resulting\n+   type.  This is where ISO C checks on complex types are made, since\n+   \"_Complex long\" is a prefix of the valid ISO C type \"_Complex long\n+   double\".  */\n+\n+struct c_declspecs *\n+finish_declspecs (struct c_declspecs *specs)\n+{\n+  /* If a type was specified as a whole, we have no modifiers and are\n+     done.  */\n+  if (specs->type != NULL_TREE)\n+    {\n+      gcc_assert (!specs->long_p && !specs->long_long_p && !specs->short_p\n+\t\t  && !specs->signed_p && !specs->unsigned_p\n+\t\t  && !specs->complex_p);\n+      return specs;\n+    }\n+\n+  /* If none of \"void\", \"_Bool\", \"char\", \"int\", \"float\" or \"double\"\n+     has been specified, treat it as \"int\" unless \"_Complex\" is\n+     present and there are no other specifiers.  If we just have\n+     \"_Complex\", it is equivalent to \"_Complex double\", but e.g.\n+     \"_Complex short\" is equivalent to \"_Complex short int\".  */\n+  if (specs->typespec_word == cts_none)\n+    {\n+      if (specs->long_p || specs->short_p\n+\t  || specs->signed_p || specs->unsigned_p)\n+\t{\n+\t  specs->typespec_word = cts_int;\n+\t}\n+      else if (specs->complex_p)\n+\t{\n+\t  specs->typespec_word = cts_double;\n+\t  if (pedantic)\n+\t    pedwarn (\"ISO C does not support plain %<complex%> meaning \"\n+\t\t     \"%<double complex%>\");\n+\t}\n+      else\n+\t{\n+\t  specs->typespec_word = cts_int;\n+\t  specs->default_int_p = true;\n+\t  /* We don't diagnose this here because grokdeclarator will\n+\t     give more specific diagnostics according to whether it is\n+\t     a function definition.  */\n+\t}\n+    }\n+\n+  /* If \"signed\" was specified, record this to distinguish \"int\" and\n+     \"signed int\" in the case of a bit-field with\n+     -funsigned-bitfields.  */\n+  specs->explicit_signed_p = specs->signed_p;\n+\n+  /* Now compute the actual type.  */\n+  switch (specs->typespec_word)\n+    {\n+    case cts_void:\n+      gcc_assert (!specs->long_p && !specs->short_p\n+\t\t  && !specs->signed_p && !specs->unsigned_p\n+\t\t  && !specs->complex_p);\n+      specs->type = void_type_node;\n+      break;\n+    case cts_bool:\n+      gcc_assert (!specs->long_p && !specs->short_p\n+\t\t  && !specs->signed_p && !specs->unsigned_p\n+\t\t  && !specs->complex_p);\n+      specs->type = boolean_type_node;\n+      break;\n+    case cts_char:\n+      gcc_assert (!specs->long_p && !specs->short_p);\n+      gcc_assert (!(specs->signed_p && specs->unsigned_p));\n+      if (specs->signed_p)\n+\tspecs->type = signed_char_type_node;\n+      else if (specs->unsigned_p)\n+\tspecs->type = unsigned_char_type_node;\n+      else\n+\tspecs->type = char_type_node;\n+      if (specs->complex_p)\n+\t{\n+\t  if (pedantic)\n+\t    pedwarn (\"ISO C does not support complex integer types\");\n+\t  specs->type = build_complex_type (specs->type);\n+\t}\n+      break;\n+    case cts_int:\n+      gcc_assert (!(specs->long_p && specs->short_p));\n+      gcc_assert (!(specs->signed_p && specs->unsigned_p));\n+      if (specs->long_long_p)\n+\tspecs->type = (specs->unsigned_p\n+\t\t       ? long_long_unsigned_type_node\n+\t\t       : long_long_integer_type_node);\n+      else if (specs->long_p)\n+\tspecs->type = (specs->unsigned_p\n+\t\t       ? long_unsigned_type_node\n+\t\t       : long_integer_type_node);\n+      else if (specs->short_p)\n+\tspecs->type = (specs->unsigned_p\n+\t\t       ? short_unsigned_type_node\n+\t\t       : short_integer_type_node);\n+      else\n+\tspecs->type = (specs->unsigned_p\n+\t\t       ? unsigned_type_node\n+\t\t       : integer_type_node);\n+      if (specs->complex_p)\n+\t{\n+\t  if (pedantic)\n+\t    pedwarn (\"ISO C does not support complex integer types\");\n+\t  specs->type = build_complex_type (specs->type);\n+\t}\n+      break;\n+    case cts_float:\n+      gcc_assert (!specs->long_p && !specs->short_p\n+\t\t  && !specs->signed_p && !specs->unsigned_p);\n+      specs->type = (specs->complex_p\n+\t\t     ? complex_float_type_node\n+\t\t     : float_type_node);\n+      break;\n+    case cts_double:\n+      gcc_assert (!specs->long_long_p && !specs->short_p\n+\t\t  && !specs->signed_p && !specs->unsigned_p);\n+      if (specs->long_p)\n+\t{\n+\t  specs->type = (specs->complex_p\n+\t\t\t ? complex_long_double_type_node\n+\t\t\t : long_double_type_node);\n+\t}\n+      else\n+\t{\n+\t  specs->type = (specs->complex_p\n+\t\t\t ? complex_double_type_node\n+\t\t\t : double_type_node);\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return specs;\n+}\n+\n /* Synthesize a function which calls all the global ctors or global\n    dtors in this file.  This is only used for targets which do not\n    support .ctors/.dtors sections.  FIXME: Migrate into cgraph.  */"}, {"sha": "6fcf66739f50d21a165663686158c6b8dc3a2073", "filename": "gcc/c-parse.in", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=98c3a782774396163f6bcacf91515131e3abe375", "patch": "@@ -420,7 +420,7 @@ datadef:\n \t| declspecs_ts setspecs initdecls ';'\n \t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs ';'\n-\t  { shadow_tag ($1); }\n+\t  { shadow_tag (finish_declspecs ($1)); }\n \t| error ';'\n \t| error '}'\n \t| ';'\n@@ -835,7 +835,7 @@ datadecl:\n \t| declspecs_nots_nosa setspecs notype_initdecls ';'\n \t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs_ts_nosa ';'\n-\t\t{ shadow_tag_warned ($1, 1);\n+\t\t{ shadow_tag_warned (finish_declspecs ($1), 1);\n \t\t  pedwarn (\"empty declaration\"); }\n \t| declspecs_nots_nosa ';'\n \t\t{ pedwarn (\"empty declaration\"); }\n@@ -868,6 +868,7 @@ setspecs: /* empty */\n \t\t      prefix_attributes = NULL_TREE;\n \t\t      current_declspecs = build_null_declspecs ();\n \t\t    }\n+\t\t  current_declspecs = finish_declspecs (current_declspecs);\n \t\t  all_prefix_attributes = prefix_attributes; }\n \t;\n \n@@ -888,7 +889,7 @@ decl:\n \t| declspecs_nots setspecs notype_nested_function\n \t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs ';'\n-\t\t{ shadow_tag ($1); }\n+\t\t{ shadow_tag (finish_declspecs ($1)); }\n \t| extension decl\n \t\t{ RESTORE_EXT_FLAGS ($1); }\n \t;\n@@ -1745,7 +1746,7 @@ component_decl:\n \t| declspecs_nosc_nots\n \t\t{ if (pedantic)\n \t\t    pedwarn (\"ISO C forbids member declarations with no members\");\n-\t\t  shadow_tag_warned ($1, pedantic);\n+\t\t  shadow_tag_warned (finish_declspecs ($1), pedantic);\n \t\t  $$ = NULL_TREE; }\n \t| error\n \t\t{ $$ = NULL_TREE; }\n@@ -1823,7 +1824,7 @@ enumerator:\n typename:\n \t  declspecs_nosc\n \t\t{ pending_xref_error ();\n-\t\t  $<dsptype>$ = $1; }\n+\t\t  $<dsptype>$ = finish_declspecs ($1); }\n \t  absdcl\n \t\t{ $$ = XOBNEW (&parser_obstack, struct c_type_name);\n \t\t  $$->specs = $<dsptype>2;"}, {"sha": "76981a7ea7cd622a13d6c9ad8366031eb51c5e07", "filename": "gcc/c-tree.h", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=98c3a782774396163f6bcacf91515131e3abe375", "patch": "@@ -141,19 +141,34 @@ enum c_storage_class {\n   csc_typedef\n };\n \n+/* A type specifier keyword \"void\", \"_Bool\", \"char\", \"int\", \"float\",\n+   \"double\", or none of these.  */\n+enum c_typespec_keyword {\n+  cts_none,\n+  cts_void,\n+  cts_bool,\n+  cts_char,\n+  cts_int,\n+  cts_float,\n+  cts_double\n+};\n+\n /* A sequence of declaration specifiers in C.  */\n struct c_declspecs {\n-  /* The type specified, not reflecting modifiers such as \"short\" and\n-     \"unsigned\", or NULL_TREE if none.  */\n+  /* The type specified, if a single type specifier such as a struct,\n+     union or enum specifier, typedef name or typeof specifies the\n+     whole type, or NULL_TREE if none or a keyword such as \"void\" or\n+     \"char\" is used.  Does not include qualifiers.  */\n   tree type;\n   /* The attributes from a typedef decl.  */\n   tree decl_attr;\n   /* When parsing, the attributes.  Outside the parser, this will be\n      NULL; attributes (possibly from multiple lists) will be passed\n      separately.  */\n   tree attrs;\n-  /* The modifier bits present.  */\n-  int specbits;\n+  /* Any type specifier keyword used such as \"int\", not reflecting\n+     modifiers such as \"short\", or cts_none if none.  */\n+  enum c_typespec_keyword typespec_word;\n   /* The storage class specifier, or csc_none if none.  */\n   enum c_storage_class storage_class;\n   /* Whether something other than a storage class specifier or\n@@ -165,17 +180,26 @@ struct c_declspecs {\n   BOOL_BITFIELD non_sc_seen_p : 1;\n   /* Whether the type is specified by a typedef.  */\n   BOOL_BITFIELD typedef_p : 1;\n-  /* Whether the type is specified by a typedef whose type is\n-     explicitly \"signed\".  */\n-  BOOL_BITFIELD typedef_signed_p : 1;\n+  /* Whether the type is explicitly \"signed\" or specified by a typedef\n+     whose type is explicitly \"signed\".  */\n+  BOOL_BITFIELD explicit_signed_p : 1;\n   /* Whether the specifiers include a deprecated typedef.  */\n   BOOL_BITFIELD deprecated_p : 1;\n-  /* Whether \"int\" was explicitly specified.  */\n-  BOOL_BITFIELD explicit_int_p : 1;\n-  /* Whether \"char\" was explicitly specified.  */\n-  BOOL_BITFIELD explicit_char_p : 1;\n+  /* Whether the type defaulted to \"int\" because there were no type\n+     specifiers.  */\n+  BOOL_BITFIELD default_int_p;\n+  /* Whether \"long\" was specified.  */\n+  BOOL_BITFIELD long_p : 1;\n   /* Whether \"long\" was specified more than once.  */\n   BOOL_BITFIELD long_long_p : 1;\n+  /* Whether \"short\" was specified.  */\n+  BOOL_BITFIELD short_p : 1;\n+  /* Whether \"signed\" was specified.  */\n+  BOOL_BITFIELD signed_p : 1;\n+  /* Whether \"unsigned\" was specified.  */\n+  BOOL_BITFIELD unsigned_p : 1;\n+  /* Whether \"complex\" was specified.  */\n+  BOOL_BITFIELD complex_p : 1;\n   /* Whether \"inline\" was specified.  */\n   BOOL_BITFIELD inline_p : 1;\n   /* Whether \"__thread\" was specified.  */\n@@ -362,6 +386,7 @@ extern struct c_declspecs *declspecs_add_qual (struct c_declspecs *, tree);\n extern struct c_declspecs *declspecs_add_type (struct c_declspecs *, tree);\n extern struct c_declspecs *declspecs_add_scspec (struct c_declspecs *, tree);\n extern struct c_declspecs *declspecs_add_attrs (struct c_declspecs *, tree);\n+extern struct c_declspecs *finish_declspecs (struct c_declspecs *);\n \n /* in c-objc-common.c */\n extern int c_disregard_inline_limits (tree);"}, {"sha": "0a27ca6c57ed1777e162ce52a66ce3c2af639e7e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=98c3a782774396163f6bcacf91515131e3abe375", "patch": "@@ -1,3 +1,9 @@\n+2004-09-17  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* gcc.dg/declspec-4.c, gcc.dg/declspec-5.c, gcc.dg/declspec-6.c:\n+\tUpdate expected messages.\n+\t* gcc.dg/declspec-13.c: New test.\n+\n 2004-09-17  David Edelsohn  <edelsohn@gnu.org>\n \n \t* gcc.dg/darwin-longlong.c: XFAIL on AIX and SPE."}, {"sha": "317252064e5b6473bd939ed2b33f6f975e46cdb1", "filename": "gcc/testsuite/gcc.dg/declspec-13.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-13.c?ref=98c3a782774396163f6bcacf91515131e3abe375", "patch": "@@ -0,0 +1,86 @@\n+/* Test declaration specifiers.  Test messages for bad type\n+   specifiers.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu89 -pedantic\" } */\n+\n+/* typeof should act much like typedef, so the following are\n+   invalid.  */\n+typeof(double) long x0; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+typeof(double) _Complex x1; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+\n+/* The following is erroneous, and used to get a bogus message about\n+   complex integer types.  */\n+typedef double D;\n+D _Complex x2; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+\n+/* The following empty declarations should have problems in their type\n+   specifiers diagnosed, not just the general problem that they are\n+   empty declarations.  */\n+long short; /* { dg-error \"error: both 'long' and 'short' in declaration specifiers\" } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"empty\" { target *-*-* } 20 } */\n+_Complex double; /* { dg-warning \"warning: ISO C90 does not support complex types\" } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"empty\" { target *-*-* } 22 } */\n+_Complex; /* { dg-warning \"warning: ISO C90 does not support complex types\" } */\n+/* { dg-warning \"warning: ISO C does not support plain 'complex' meaning 'double complex'\" \"ISO C\" { target *-*-* } 24 } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"empty\" { target *-*-* } 24 } */\n+_Complex int; /* { dg-warning \"warning: ISO C90 does not support complex types\" } */\n+/* { dg-warning \"warning: ISO C does not support complex integer types\" \"ISO C\" { target *-*-* } 27 } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"empty\" { target *-*-* } 27 } */\n+\n+/* Specific messages for each invalid combination.  (That some message\n+   is given when appropriate for a larger collection of combinations\n+   of type specifiers is tested in *typespec*.c.)  */\n+\n+long double long x3; /* { dg-error \"both 'long long' and 'double' in declaration specifiers\" } */\n+short long x4; /* { dg-error \"both 'long' and 'short' in declaration specifiers\" } */\n+void long x5; /* { dg-error \"both 'long' and 'void' in declaration specifiers\" } */\n+_Bool long x6; /* { dg-error \"both 'long' and '_Bool' in declaration specifiers\" } */\n+char long x7; /* { dg-error \"both 'long' and 'char' in declaration specifiers\" } */\n+float long x8; /* { dg-error \"both 'long' and 'float' in declaration specifiers\" } */\n+long short x9; /* { dg-error \"both 'long' and 'short' in declaration specifiers\" } */\n+void short x10; /* { dg-error \"both 'short' and 'void' in declaration specifiers\" } */\n+_Bool short x11; /* { dg-error \"both 'short' and '_Bool' in declaration specifiers\" } */\n+char short x12; /* { dg-error \"both 'short' and 'char' in declaration specifiers\" } */\n+float short x13; /* { dg-error \"both 'short' and 'float' in declaration specifiers\" } */\n+double short x14; /* { dg-error \"both 'short' and 'double' in declaration specifiers\" } */\n+unsigned signed x15; /* { dg-error \"both 'signed' and 'unsigned' in declaration specifiers\" } */\n+void signed x16; /* { dg-error \"both 'signed' and 'void' in declaration specifiers\" } */\n+_Bool signed x17; /* { dg-error \"both 'signed' and '_Bool' in declaration specifiers\" } */\n+float signed x18; /* { dg-error \"both 'signed' and 'float' in declaration specifiers\" } */\n+double signed x19; /* { dg-error \"both 'signed' and 'double' in declaration specifiers\" } */\n+signed unsigned x20; /* { dg-error \"both 'signed' and 'unsigned' in declaration specifiers\" } */\n+void unsigned x21; /* { dg-error \"both 'unsigned' and 'void' in declaration specifiers\" } */\n+_Bool unsigned x22; /* { dg-error \"both 'unsigned' and '_Bool' in declaration specifiers\" } */\n+float unsigned x23; /* { dg-error \"both 'unsigned' and 'float' in declaration specifiers\" } */\n+double unsigned x24; /* { dg-error \"both 'unsigned' and 'double' in declaration specifiers\" } */\n+void _Complex x25; /* { dg-error \"both 'complex' and 'void' in declaration specifiers\" } */\n+/* { dg-warning \"warning: ISO C90 does not support complex types\" \"C90\" { target *-*-* } 57 } */\n+_Bool _Complex x26; /* { dg-error \"both 'complex' and '_Bool' in declaration specifiers\" } */\n+/* { dg-warning \"warning: ISO C90 does not support complex types\" \"C90\" { target *-*-* } 59 } */\n+\n+long void x27; /* { dg-error \"both 'long' and 'void' in declaration specifiers\" } */\n+short void x28; /* { dg-error \"both 'short' and 'void' in declaration specifiers\" } */\n+signed void x29; /* { dg-error \"both 'signed' and 'void' in declaration specifiers\" } */\n+unsigned void x30; /* { dg-error \"both 'unsigned' and 'void' in declaration specifiers\" } */\n+_Complex void x31; /* { dg-error \"both 'complex' and 'void' in declaration specifiers\" } */\n+/* { dg-warning \"warning: ISO C90 does not support complex types\" \"C90\" { target *-*-* } 66 } */\n+/* { dg-warning \"warning: ISO C does not support plain 'complex' meaning 'double complex'\" \"complex\" { target *-*-* } 66 } */\n+long _Bool x32; /* { dg-error \"both 'long' and '_Bool' in declaration specifiers\" } */\n+short _Bool x33; /* { dg-error \"both 'short' and '_Bool' in declaration specifiers\" } */\n+signed _Bool x34; /* { dg-error \"both 'signed' and '_Bool' in declaration specifiers\" } */\n+unsigned _Bool x35; /* { dg-error \"both 'unsigned' and '_Bool' in declaration specifiers\" } */\n+_Complex _Bool x36; /* { dg-error \"both 'complex' and '_Bool' in declaration specifiers\" } */\n+/* { dg-warning \"warning: ISO C90 does not support complex types\" \"C90\" { target *-*-* } 73 } */\n+/* { dg-warning \"warning: ISO C does not support plain 'complex' meaning 'double complex'\" \"complex\" { target *-*-* } 73 } */\n+long char x37; /* { dg-error \"both 'long' and 'char' in declaration specifiers\" } */\n+short char x38; /* { dg-error \"both 'short' and 'char' in declaration specifiers\" } */\n+long float x39; /* { dg-error \"both 'long' and 'float' in declaration specifiers\" } */\n+short float x40; /* { dg-error \"both 'short' and 'float' in declaration specifiers\" } */\n+signed float x41; /* { dg-error \"both 'signed' and 'float' in declaration specifiers\" } */\n+unsigned float x42; /* { dg-error \"both 'unsigned' and 'float' in declaration specifiers\" } */\n+long long double x43; /* { dg-error \"both 'long long' and 'double' in declaration specifiers\" } */\n+/* { dg-warning \"warning: ISO C90 does not support 'long long'\" \"C90\" { target *-*-* } 82 } */\n+short double x44; /* { dg-error \"both 'short' and 'double' in declaration specifiers\" } */\n+signed double x45; /* { dg-error \"both 'signed' and 'double' in declaration specifiers\" } */\n+unsigned double x46; /* { dg-error \"both 'unsigned' and 'double' in declaration specifiers\" } */"}, {"sha": "b8eb9d0f99cef987278ee9f1b5454ea245a77e18", "filename": "gcc/testsuite/gcc.dg/declspec-4.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-4.c?ref=98c3a782774396163f6bcacf91515131e3abe375", "patch": "@@ -19,23 +19,25 @@ enum e1 { E1 };\n /* Not declaring anything (pedwarns).  */\n struct { int a; }; /* { dg-warning \"warning: unnamed struct/union that defines no instances\" } */\n int; /* { dg-warning \"warning: useless type name in empty declaration\" } */\n-long; /* { dg-warning \"warning: useless keyword or type name in empty declaration\" } */\n-/* { dg-warning \"warning: empty declaration\" \"long\" { target *-*-* } 22 } */\n+long; /* { dg-warning \"warning: useless type name in empty declaration\" } */\n T; /* { dg-warning \"warning: useless type name in empty declaration\" } */\n static const; /* { dg-warning \"warning: useless storage class specifier in empty declaration\" } */\n-/* { dg-warning \"warning: empty declaration\" \"long\" { target *-*-* } 25 } */\n+/* { dg-warning \"warning: empty declaration\" \"static const\" { target *-*-* } 24 } */\n union { long b; }; /* { dg-warning \"warning: unnamed struct/union that defines no instances\" } */\n \n /* Multiple type names (errors).  */\n struct s1 int; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n char union u1; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n-/* { dg-warning \"warning: useless type name in empty declaration\" \"char union\" { target *-*-* } 31 } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"char union\" { target *-*-* } 30 } */\n double enum { E2 }; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n-/* { dg-warning \"warning: useless type name in empty declaration\" \"double enum\" { target *-*-* } 33 } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"double enum\" { target *-*-* } 32 } */\n T struct s2; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n-/* { dg-warning \"warning: useless type name in empty declaration\" \"T struct\" { target *-*-* } 35 } */\n-long union u2; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n-struct s3 short; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n-union u3 signed; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n-unsigned struct s4; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n-_Complex enum { E3 }; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"T struct\" { target *-*-* } 34 } */\n+long union u2; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"empty\" { target *-*-* } 36 } */\n+struct s3 short; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+union u3 signed; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+unsigned struct s4; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"empty\" { target *-*-* } 40 } */\n+_Complex enum { E3 }; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"empty\" { target *-*-* } 42 } */"}, {"sha": "f24d9b468b9ad28c4cf772d87fd9bc0bcbb28ccd", "filename": "gcc/testsuite/gcc.dg/declspec-5.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-5.c?ref=98c3a782774396163f6bcacf91515131e3abe375", "patch": "@@ -19,23 +19,27 @@ enum e1 { E1 };\n /* Not declaring anything (pedwarns).  */\n struct { int a; }; /* { dg-warning \"warning: unnamed struct/union that defines no instances\" } */\n int; /* { dg-warning \"warning: useless type name in empty declaration\" } */\n-long; /* { dg-warning \"warning: useless keyword or type name in empty declaration\" } */\n-/* { dg-warning \"warning: empty declaration\" \"long\" { target *-*-* } 22 } */\n+long; /* { dg-warning \"warning: useless type name in empty declaration\" } */\n T; /* { dg-warning \"warning: useless type name in empty declaration\" } */\n static const; /* { dg-warning \"warning: useless storage class specifier in empty declaration\" } */\n-/* { dg-warning \"warning: empty declaration\" \"long\" { target *-*-* } 25 } */\n+/* { dg-warning \"warning: empty declaration\" \"static const\" { target *-*-* } 24 } */\n union { long b; }; /* { dg-warning \"warning: unnamed struct/union that defines no instances\" } */\n \n /* Multiple type names (errors).  */\n struct s1 int; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n char union u1; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n-/* { dg-warning \"warning: useless type name in empty declaration\" \"char union\" { target *-*-* } 31 } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"char union\" { target *-*-* } 30 } */\n double enum { E2 }; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n-/* { dg-warning \"warning: useless type name in empty declaration\" \"double enum\" { target *-*-* } 33 } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"double enum\" { target *-*-* } 32 } */\n T struct s2; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n-/* { dg-warning \"warning: useless type name in empty declaration\" \"T struct\" { target *-*-* } 35 } */\n-long union u2; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n-struct s3 short; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n-union u3 signed; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n-unsigned struct s4; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n-_Complex enum { E3 }; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"T struct\" { target *-*-* } 34 } */\n+long union u2; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"empty\" { target *-*-* } 36 } */\n+struct s3 short; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+union u3 signed; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+unsigned struct s4; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"empty\" { target *-*-* } 40 } */\n+_Complex enum { E3 }; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+/* { dg-warning \"warning: useless type name in empty declaration\" \"empty\" { target *-*-* } 42 } */\n+/* { dg-warning \"warning: ISO C90 does not support complex types\" \"C90\" { target *-*-* } 42 } */\n+/* { dg-warning \"warning: ISO C does not support plain 'complex' meaning 'double complex'\" \"ISO C\" { target *-*-* } 42 } */"}, {"sha": "29ef24843bf4c4741e15a9ba5392248b9b6417a9", "filename": "gcc/testsuite/gcc.dg/declspec-6.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c3a782774396163f6bcacf91515131e3abe375/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-6.c?ref=98c3a782774396163f6bcacf91515131e3abe375", "patch": "@@ -19,23 +19,27 @@ enum e1 { E1 };\n /* Not declaring anything (pedwarns).  */\n struct { int a; }; /* { dg-error \"error: unnamed struct/union that defines no instances\" } */\n int; /* { dg-error \"error: useless type name in empty declaration\" } */\n-long; /* { dg-warning \"warning: useless keyword or type name in empty declaration\" } */\n-/* { dg-error \"error: empty declaration\" \"long\" { target *-*-* } 22 } */\n+long; /* { dg-error \"error: useless type name in empty declaration\" } */\n T; /* { dg-error \"error: useless type name in empty declaration\" } */\n static const; /* { dg-warning \"warning: useless storage class specifier in empty declaration\" } */\n-/* { dg-error \"error: empty declaration\" \"long\" { target *-*-* } 25 } */\n+/* { dg-error \"error: empty declaration\" \"static const\" { target *-*-* } 24 } */\n union { long b; }; /* { dg-error \"error: unnamed struct/union that defines no instances\" } */\n \n /* Multiple type names (errors).  */\n struct s1 int; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n char union u1; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n-/* { dg-error \"error: useless type name in empty declaration\" \"char union\" { target *-*-* } 31 } */\n+/* { dg-error \"error: useless type name in empty declaration\" \"char union\" { target *-*-* } 30 } */\n double enum { E2 }; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n-/* { dg-error \"error: useless type name in empty declaration\" \"double enum\" { target *-*-* } 33 } */\n+/* { dg-error \"error: useless type name in empty declaration\" \"double enum\" { target *-*-* } 32 } */\n T struct s2; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n-/* { dg-error \"error: useless type name in empty declaration\" \"T struct\" { target *-*-* } 35 } */\n-long union u2; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n-struct s3 short; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n-union u3 signed; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n-unsigned struct s4; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n-_Complex enum { E3 }; /* { dg-error \"error: long, short, signed, unsigned or complex used invalidly in empty declaration\" } */\n+/* { dg-error \"error: useless type name in empty declaration\" \"T struct\" { target *-*-* } 34 } */\n+long union u2; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+/* { dg-error \"error: useless type name in empty declaration\" \"empty\" { target *-*-* } 36 } */\n+struct s3 short; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+union u3 signed; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+unsigned struct s4; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+/* { dg-error \"error: useless type name in empty declaration\" \"empty\" { target *-*-* } 40 } */\n+_Complex enum { E3 }; /* { dg-error \"error: two or more data types in declaration specifiers\" } */\n+/* { dg-error \"error: useless type name in empty declaration\" \"empty\" { target *-*-* } 42 } */\n+/* { dg-error \"error: ISO C90 does not support complex types\" \"C90\" { target *-*-* } 42 } */\n+/* { dg-error \"error: ISO C does not support plain 'complex' meaning 'double complex'\" \"ISO C\" { target *-*-* } 42 } */"}]}