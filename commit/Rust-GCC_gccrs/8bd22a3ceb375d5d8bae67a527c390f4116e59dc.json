{"sha": "8bd22a3ceb375d5d8bae67a527c390f4116e59dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJkMjJhM2NlYjM3NWQ1ZDhiYWU2N2E1MjdjMzkwZjQxMTZlNTlkYw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-03-26T00:38:57Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-03-26T00:38:57Z"}, "message": "[multiple changes]\n\n\n2004-03-25  Gawain Bolton  <gp.bolton@computer.org>\n\n\t* include/bits/stl_tree.h (_Rb_tree_impl): Add _Node_allocator\n\tdefault argument in constructors.\n\t(_Rb_tree::_M_empty_initialize): Remove.\n\n2004-03-25  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* testsuite/23_containers/map/operators/1_neg.cc: Adjust line numbers.\n\t* testsuite/23_containers/set/operators/1_neg.cc: Same.\n\n2004-03-25  Dhruv Matani  <dhruvbird@gmx.net>\n\n\t* include/bits/cpp_type_traits.h: Changed __is_pod\n\tcompletely. Now, it does not use any of the previous type_traits\n\tto detect the pod types, and it also detects function pointers as\n\tPOD types.\n\n\t* include/bits/stl_tree.h: Introduced a new class _Rb_tree_impl,\n\twhich encapsulates the internal implementation of an rb_tree. Made\n\tthe allocator a base class of this class instead of the rb_tree,\n\twhich was not conforming. This _Rb_tree_impl class is also\n\tspecialized on whether the _Compare parameter is a POD type or\n\tnot. If so, then it maintains the comparison function as a data\n\tmember, otherwise it makes the _Compare parameter a base class of\n\titself. Also, _M_key_compare is now a function instead of a data\n\tmember, so that the above trick can work properly. Delegated the\n\tinitialization of the other data members to this newly created\n\tclass. Also, now other member functions of rb_tree must refer to\n\t_M_key_compare as _M_impl._M_key_compare(). The other data members\n\t(*) can be referenced to as _M_impl.(*), where\n\t(*) includes _M_header, and _M_node_count.\n\nFrom-SVN: r79977", "tree": {"sha": "66861240ed089e3e08e8f7d2080d705b670e7142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66861240ed089e3e08e8f7d2080d705b670e7142"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bd22a3ceb375d5d8bae67a527c390f4116e59dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bd22a3ceb375d5d8bae67a527c390f4116e59dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bd22a3ceb375d5d8bae67a527c390f4116e59dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bd22a3ceb375d5d8bae67a527c390f4116e59dc/comments", "author": null, "committer": null, "parents": [{"sha": "c18ab9a436b5cb1b7091e16b15facf10c1ce8aa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c18ab9a436b5cb1b7091e16b15facf10c1ce8aa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c18ab9a436b5cb1b7091e16b15facf10c1ce8aa2"}], "stats": {"total": 333, "additions": 201, "deletions": 132}, "files": [{"sha": "2ca2d2a4cd375adea7ce06dc3387e0ede00f1e6e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd22a3ceb375d5d8bae67a527c390f4116e59dc/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd22a3ceb375d5d8bae67a527c390f4116e59dc/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8bd22a3ceb375d5d8bae67a527c390f4116e59dc", "patch": "@@ -1,3 +1,36 @@\n+2004-03-25  Gawain Bolton  <gp.bolton@computer.org>\n+\n+\t* include/bits/stl_tree.h (_Rb_tree_impl): Add _Node_allocator\n+\tdefault argument in constructors.\n+\t(_Rb_tree::_M_empty_initialize): Remove.\n+\t\n+2004-03-25  Benjamin Kosnik  <bkoz@redhat.com>\n+\t\n+\t* testsuite/23_containers/map/operators/1_neg.cc: Adjust line numbers.\n+\t* testsuite/23_containers/set/operators/1_neg.cc: Same.\n+\n+2004-03-25  Dhruv Matani  <dhruvbird@gmx.net>\n+\n+\t* include/bits/cpp_type_traits.h: Changed __is_pod\n+\tcompletely. Now, it does not use any of the previous type_traits\n+\tto detect the pod types, and it also detects function pointers as\n+\tPOD types.\n+\n+\t* include/bits/stl_tree.h: Introduced a new class _Rb_tree_impl,\n+\twhich encapsulates the internal implementation of an rb_tree. Made\n+\tthe allocator a base class of this class instead of the rb_tree,\n+\twhich was not conforming. This _Rb_tree_impl class is also\n+\tspecialized on whether the _Compare parameter is a POD type or\n+\tnot. If so, then it maintains the comparison function as a data\n+\tmember, otherwise it makes the _Compare parameter a base class of\n+\titself. Also, _M_key_compare is now a function instead of a data\n+\tmember, so that the above trick can work properly. Delegated the\n+\tinitialization of the other data members to this newly created\n+\tclass. Also, now other member functions of rb_tree must refer to\n+\t_M_key_compare as _M_impl._M_key_compare(). The other data members\n+\t(*) can be referenced to as _M_impl.(*), where\n+\t(*) includes _M_header, and _M_node_count.\n+\n 2004-03-25  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/ext/mt_allocator.h (__mt_alloc<>::tune):"}, {"sha": "d025c8ffe63b5e23d207feaa2a798e8e01c2799c", "filename": "libstdc++-v3/include/bits/cpp_type_traits.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd22a3ceb375d5d8bae67a527c390f4116e59dc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd22a3ceb375d5d8bae67a527c390f4116e59dc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h?ref=8bd22a3ceb375d5d8bae67a527c390f4116e59dc", "patch": "@@ -317,12 +317,27 @@ namespace std\n   //\n   // For the immediate use, the following is a good approximation\n   //\n+\n+  // NB: g++ can not compile these if declared within the class\n+  // __is_pod itself.\n+  namespace __gnu_internal\n+  {\n+    typedef char __one;\n+    typedef char __two[2];\n+\n+    template <typename _Tp>\n+    __one __test_type (int _Tp::*);\n+    template <typename _Tp>\n+    __two& __test_type (...);\n+  }\n+\n+  \n   template<typename _Tp>\n   struct __is_pod\n   {\n     enum\n     {\n-      _M_type = __is_fundamental<_Tp>::_M_type\n+      _M_type = (sizeof(__gnu_internal::__test_type<_Tp>(0)) != sizeof(__gnu_internal::__one))\n     };\n   };\n "}, {"sha": "676987312334c32e7dc0ffa2a6fe98ce9dc0d26a", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 147, "deletions": 127, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd22a3ceb375d5d8bae67a527c390f4116e59dc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd22a3ceb375d5d8bae67a527c390f4116e59dc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=8bd22a3ceb375d5d8bae67a527c390f4116e59dc", "patch": "@@ -63,33 +63,30 @@\n #ifndef _TREE_H\n #define _TREE_H 1\n \n-/*\n-\n-Red-black tree class, designed for use in implementing STL\n-associative containers (set, multiset, map, and multimap). The\n-insertion and deletion algorithms are based on those in Cormen,\n-Leiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990),\n-except that\n-\n-(1) the header cell is maintained with links not only to the root\n-but also to the leftmost node of the tree, to enable constant time\n-begin(), and to the rightmost node of the tree, to enable linear time\n-performance when used with the generic set algorithms (set_union,\n-etc.);\n-\n-(2) when a node being deleted has two children its successor node is\n-relinked into its place, rather than copied, so that the only\n-iterators invalidated are those referring to the deleted node.\n-\n-*/\n-\n #include <bits/stl_algobase.h>\n #include <bits/allocator.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_function.h>\n+#include <bits/cpp_type_traits.h>\n \n namespace std\n {\n+  // Red-black tree class, designed for use in implementing STL\n+  // associative containers (set, multiset, map, and multimap). The\n+  // insertion and deletion algorithms are based on those in Cormen,\n+  // Leiserson, and Rivest, Introduction to Algorithms (MIT Press,\n+  // 1990), except that\n+  //\n+  // (1) the header cell is maintained with links not only to the root\n+  // but also to the leftmost node of the tree, to enable constant\n+  // time begin(), and to the rightmost node of the tree, to enable\n+  // linear time performance when used with the generic set algorithms\n+  // (set_union, etc.)\n+  // \n+  // (2) when a node being deleted has two children its successor node\n+  // is relinked into its place, rather than copied, so that the only\n+  // iterators invalidated are those referring to the deleted node.\n+\n   enum _Rb_tree_color { _S_red = false, _S_black = true };\n \n   struct _Rb_tree_node_base\n@@ -164,10 +161,10 @@ namespace std\n       typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;\n       typedef _Rb_tree_node<_Tp>*           _Link_type;\n \n-      _Rb_tree_iterator() {}\n+      _Rb_tree_iterator() { }\n \n       _Rb_tree_iterator(_Link_type __x)\n-      : _M_node(__x) {}\n+      : _M_node(__x) { }\n \n       reference\n       operator*() const\n@@ -234,13 +231,13 @@ namespace std\n       typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;\n       typedef const _Rb_tree_node<_Tp>*           _Link_type;\n \n-      _Rb_tree_const_iterator() {}\n+      _Rb_tree_const_iterator() { }\n \n       _Rb_tree_const_iterator(_Link_type __x)\n-      : _M_node(__x) {}\n+      : _M_node(__x) { }\n \n       _Rb_tree_const_iterator(const iterator& __it)\n-      : _M_node(__it._M_node) {}\n+      : _M_node(__it._M_node) { }\n \n       reference\n       operator*() const\n@@ -312,20 +309,19 @@ namespace std\n                         _Rb_tree_node_base*& __root);\n \n   void\n-  _Rb_tree_insert_and_rebalance(const bool          __insert_left,\n+  _Rb_tree_insert_and_rebalance(const bool __insert_left,\n                                 _Rb_tree_node_base* __x,\n                                 _Rb_tree_node_base* __p,\n                                 _Rb_tree_node_base& __header);\n \n   _Rb_tree_node_base*\n   _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,\n-\t\t\t       _Rb_tree_node_base&\t __header);\n+\t\t\t       _Rb_tree_node_base& __header);\n \n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc = allocator<_Val> >\n     class _Rb_tree\n-    : protected _Alloc::template rebind<_Rb_tree_node<_Val> >::other\n     {\n       typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other\n               _Node_allocator;\n@@ -346,19 +342,20 @@ namespace std\n       typedef const _Rb_tree_node* _Const_Link_type;\n       typedef size_t size_type;\n       typedef ptrdiff_t difference_type;\n-\n       typedef _Alloc allocator_type;\n-      allocator_type get_allocator() const\n-      { return *static_cast<const _Node_allocator*>(this); }\n+\n+      allocator_type \n+      get_allocator() const\n+      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }\n \n     protected:\n       _Rb_tree_node*\n       _M_get_node()\n-      { return _Node_allocator::allocate(1); }\n+      { return _M_impl._Node_allocator::allocate(1); }\n \n       void\n       _M_put_node(_Rb_tree_node* __p)\n-      { _Node_allocator::deallocate(__p, 1); }\n+      { _M_impl._Node_allocator::deallocate(__p, 1); }\n \n       _Link_type\n       _M_create_node(const value_type& __x)\n@@ -392,50 +389,87 @@ namespace std\n       }\n \n     protected:\n-      _Rb_tree_node_base _M_header;\n-      size_type _M_node_count; // keeps track of size of tree\n-      _Compare _M_key_compare;\n+      template<typename _Key_compare, \n+\t       bool _Is_pod_comparator = std::__is_pod<_Key_compare>::_M_type>\n+        struct _Rb_tree_impl : public _Node_allocator\n+        {\n+\t  _Key_compare\t\t_M_key_compare;\n+\t  _Rb_tree_node_base \t_M_header;\n+\t  size_type \t\t_M_node_count; // Keeps track of size of tree.\n+\n+\t  _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),\n+\t\t\tconst _Key_compare& __comp = _Key_compare())\n+\t  : _Node_allocator(__a), _M_node_count(0), _M_key_compare(__comp)\n+\t  {\n+\t    this->_M_header._M_color = _S_red;\n+\t    this->_M_header._M_parent = 0;\n+\t    this->_M_header._M_left = &this->_M_header;\n+\t    this->_M_header._M_right = &this->_M_header;\n+\t  }\n+\t};\n+\n+      // Specialization for _Comparison types that are not capable of\n+      // being base classes / super classes.\n+      template<typename _Key_compare>\n+        struct _Rb_tree_impl<_Key_compare, true> : public _Node_allocator \n+\t{\n+\t  _Key_compare \t\t_M_key_compare;\n+\t  _Rb_tree_node_base \t_M_header;\n+\t  size_type \t\t_M_node_count; // Keeps track of size of tree.\n+\n+\t  _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),\n+\t\t\tconst _Key_compare& __comp = _Key_compare())\n+\t  : _Node_allocator(__a), _M_key_compare(__comp), _M_node_count(0)\n+\t  { \n+\t    this->_M_header._M_color = _S_red;\n+\t    this->_M_header._M_parent = 0;\n+\t    this->_M_header._M_left = &this->_M_header;\n+\t    this->_M_header._M_right = &this->_M_header;\n+\t  }\n+\t};\n+\n+      _Rb_tree_impl<_Compare> _M_impl;\n \n     protected:\n       _Base_ptr&\n       _M_root()\n-      { return this->_M_header._M_parent; }\n+      { return this->_M_impl._M_header._M_parent; }\n \n       _Const_Base_ptr\n       _M_root() const\n-      { return this->_M_header._M_parent; }\n+      { return this->_M_impl._M_header._M_parent; }\n \n       _Base_ptr&\n       _M_leftmost()\n-      { return this->_M_header._M_left; }\n+      { return this->_M_impl._M_header._M_left; }\n \n       _Const_Base_ptr\n       _M_leftmost() const\n-      { return this->_M_header._M_left; }\n+      { return this->_M_impl._M_header._M_left; }\n \n       _Base_ptr&\n       _M_rightmost()\n-      { return this->_M_header._M_right; }\n+      { return this->_M_impl._M_header._M_right; }\n \n       _Const_Base_ptr\n       _M_rightmost() const\n-      { return this->_M_header._M_right; }\n+      { return this->_M_impl._M_header._M_right; }\n \n       _Link_type\n       _M_begin()\n-      { return static_cast<_Link_type>(this->_M_header._M_parent); }\n+      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }\n \n       _Const_Link_type\n       _M_begin() const\n-      { return static_cast<_Const_Link_type>(this->_M_header._M_parent); }\n+      { return static_cast<_Const_Link_type>(this->_M_impl._M_header._M_parent); }\n \n       _Link_type\n       _M_end()\n-      { return static_cast<_Link_type>(&this->_M_header); }\n+      { return static_cast<_Link_type>(&this->_M_impl._M_header); }\n \n       _Const_Link_type\n       _M_end() const\n-      { return static_cast<_Const_Link_type>(&this->_M_header); }\n+      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }\n \n       static const_reference\n       _S_value(_Const_Link_type __x)\n@@ -505,38 +539,26 @@ namespace std\n     public:\n       // allocation/deallocation\n       _Rb_tree()\n-      : _Node_allocator(allocator_type()),\n-\t_M_node_count(0),\n-\t_M_key_compare()\n-      { _M_empty_initialize(); }\n+      { }\n \n       _Rb_tree(const _Compare& __comp)\n-      : _Node_allocator(allocator_type()),\n-\t_M_node_count(0),\n-\t_M_key_compare(__comp)\n-      { _M_empty_initialize(); }\n+      : _M_impl(allocator_type(), __comp)\n+      { }\n \n       _Rb_tree(const _Compare& __comp, const allocator_type& __a)\n-      : _Node_allocator(__a),\n-\t_M_node_count(0),\n-\t_M_key_compare(__comp)\n-      { _M_empty_initialize(); }\n+      : _M_impl(__a, __comp)\n+      { }\n \n       _Rb_tree(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x)\n-      : _Node_allocator(__x.get_allocator()),\n-\t_M_node_count(0),\n-\t_M_key_compare(__x._M_key_compare)\n+      : _M_impl(__x.get_allocator(), __x._M_impl._M_key_compare)\n       {\n-\tif (__x._M_root() == 0)\n-\t  _M_empty_initialize();\n-\telse\n+\tif (__x._M_root() != 0)\n \t  {\n-\t    this->_M_header._M_color = _S_red;\n \t    _M_root() = _M_copy(__x._M_begin(), _M_end());\n \t    _M_leftmost() = _S_minimum(_M_root());\n \t    _M_rightmost() = _S_maximum(_M_root());\n+\t    _M_impl._M_node_count = __x._M_impl._M_node_count;\n \t  }\n-\t_M_node_count = __x._M_node_count;\n       }\n \n       ~_Rb_tree()\n@@ -545,37 +567,26 @@ namespace std\n       _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&\n       operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x);\n \n-    private:\n-      void _M_empty_initialize()\n-      {\n-\t// Used to distinguish header from __root, in iterator.operator++.\n-\tthis->_M_header._M_color = _S_red;\n-\t_M_root() = 0;\n-\t_M_leftmost() = _M_end();\n-\t_M_rightmost() = _M_end();\n-      }\n-\n-    public:\n       // Accessors.\n       _Compare\n       key_comp() const\n-      { return _M_key_compare; }\n+      { return _M_impl._M_key_compare; }\n \n       iterator\n       begin()\n-      { return static_cast<_Link_type>(this->_M_header._M_left); }\n+      { return static_cast<_Link_type>(this->_M_impl._M_header._M_left); }\n \n       const_iterator\n       begin() const\n-      { return static_cast<_Const_Link_type>(this->_M_header._M_left); }\n+      { return static_cast<_Const_Link_type>(this->_M_impl._M_header._M_left); }\n \n       iterator\n       end()\n-      { return static_cast<_Link_type>(&this->_M_header); }\n+      { return static_cast<_Link_type>(&this->_M_impl._M_header); }\n \n       const_iterator\n       end() const\n-      { return static_cast<_Const_Link_type>(&this->_M_header); }\n+      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }\n \n       reverse_iterator\n       rbegin()\n@@ -595,11 +606,11 @@ namespace std\n \n       bool\n       empty() const\n-      { return _M_node_count == 0; }\n+      { return _M_impl._M_node_count == 0; }\n \n       size_type\n       size() const\n-      { return _M_node_count; }\n+      { return _M_impl._M_node_count; }\n \n       size_type\n       max_size() const\n@@ -648,7 +659,7 @@ namespace std\n         _M_leftmost() = _M_end();\n         _M_root() = 0;\n         _M_rightmost() = _M_end();\n-        _M_node_count = 0;\n+        _M_impl._M_node_count = 0;\n       }\n \n       // Set operations.\n@@ -700,7 +711,7 @@ namespace std\n     operator<(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n \t      const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n     {\n-      return lexicographical_compare(__x.begin(), __x.end(),\n+      return lexicographical_compare(__x.begin(), __x.end(), \n \t\t\t\t     __y.begin(), __y.end());\n     }\n \n@@ -749,13 +760,13 @@ namespace std\n \t{\n \t  // Note that _Key may be a constant type.\n \t  clear();\n-\t  _M_key_compare = __x._M_key_compare;\n+\t  _M_impl._M_key_compare = __x._M_impl._M_key_compare;\n \t  if (__x._M_root() != 0)\n \t    {\n \t      _M_root() = _M_copy(__x._M_begin(), _M_end());\n \t      _M_leftmost() = _S_minimum(_M_root());\n \t      _M_rightmost() = _S_maximum(_M_root());\n-\t      _M_node_count = __x._M_node_count;\n+\t      _M_impl._M_node_count = __x._M_impl._M_node_count;\n \t    }\n \t}\n       return *this;\n@@ -771,10 +782,12 @@ namespace std\n       bool __insert_left;\n \n       __insert_left = __x != 0 || __p == _M_end()\n-\t              || _M_key_compare(_KeyOfValue()(__v), _S_key(__p));\n+\t              || _M_impl._M_key_compare(_KeyOfValue()(__v), \n+\t\t\t\t\t\t_S_key(__p));\n \n-      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,  this->_M_header);\n-      ++_M_node_count;\n+      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,  \n+\t\t\t\t    this->_M_impl._M_header);\n+      ++_M_impl._M_node_count;\n       return iterator(__z);\n     }\n \n@@ -789,7 +802,7 @@ namespace std\n       while (__x != 0)\n \t{\n \t  __y = __x;\n-\t  __x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?\n+\t  __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?\n \t        _S_left(__x) : _S_right(__x);\n \t}\n       return _M_insert(__x, __y, __v);\n@@ -836,8 +849,8 @@ namespace std\n \t__t._M_root()->_M_parent = __t._M_end();\n       }\n       // No need to swap header's color as it does not change.\n-      std::swap(this->_M_node_count, __t._M_node_count);\n-      std::swap(this->_M_key_compare, __t._M_key_compare);\n+      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);\n+      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -853,7 +866,7 @@ namespace std\n       while (__x != 0)\n \t{\n \t  __y = __x;\n-\t  __comp = _M_key_compare(_KeyOfValue()(__v), _S_key(__x));\n+\t  __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));\n \t  __x = __comp ? _S_left(__x) : _S_right(__x);\n \t}\n       iterator __j = iterator(__y);\n@@ -862,7 +875,7 @@ namespace std\n \t  return pair<iterator,bool>(_M_insert(__x, __y, __v), true);\n \telse\n \t  --__j;\n-      if (_M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))\n+      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))\n \treturn pair<iterator,bool>(_M_insert(__x, __y, __v), true);\n       return pair<iterator,bool>(__j, false);\n     }\n@@ -877,16 +890,18 @@ namespace std\n \t{\n \t  // begin()\n \t  if (size() > 0\n-\t      && _M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node)))\n+\t      && _M_impl._M_key_compare(_KeyOfValue()(__v), \n+\t\t\t\t\t_S_key(__position._M_node)))\n \t    return _M_insert(__position._M_node, __position._M_node, __v);\n-\t  // first argument just needs to be non-null\n+\t  // First argument just needs to be non-null.\n \t  else\n \t    return insert_unique(__v).first;\n \t}\n       else if (__position._M_node == _M_end())\n \t{\n \t  // end()\n-\t  if (_M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__v)))\n+\t  if (_M_impl._M_key_compare(_S_key(_M_rightmost()), \n+\t\t\t\t     _KeyOfValue()(__v)))\n \t    return _M_insert(0, _M_rightmost(), __v);\n \t  else\n \t    return insert_unique(__v).first;\n@@ -895,14 +910,16 @@ namespace std\n \t{\n \t  iterator __before = __position;\n \t  --__before;\n-\t  if (_M_key_compare(_S_key(__before._M_node), _KeyOfValue()(__v))\n-\t      && _M_key_compare(_KeyOfValue()(__v),_S_key(__position._M_node)))\n+\t  if (_M_impl._M_key_compare(_S_key(__before._M_node), \n+\t\t\t\t     _KeyOfValue()(__v))\n+\t      && _M_impl._M_key_compare(_KeyOfValue()(__v),\n+\t\t\t\t\t_S_key(__position._M_node)))\n \t    {\n \t      if (_S_right(__before._M_node) == 0)\n \t\treturn _M_insert(0, __before._M_node, __v);\n \t      else\n \t\treturn _M_insert(__position._M_node, __position._M_node, __v);\n-\t      // first argument just needs to be non-null\n+\t      // First argument just needs to be non-null.\n \t    }\n \t  else\n \t    return insert_unique(__v).first;\n@@ -919,8 +936,8 @@ namespace std\n \t{\n \t  // begin()\n \t  if (size() > 0\n-\t      && !_M_key_compare(_S_key(__position._M_node),\n-\t\t\t\t _KeyOfValue()(__v)))\n+\t      && !_M_impl._M_key_compare(_S_key(__position._M_node),\n+\t\t\t\t\t _KeyOfValue()(__v)))\n \t    return _M_insert(__position._M_node, __position._M_node, __v);\n \t  // first argument just needs to be non-null\n \t  else\n@@ -929,7 +946,8 @@ namespace std\n       else if (__position._M_node == _M_end())\n \t{\n \t  // end()\n-\t  if (!_M_key_compare(_KeyOfValue()(__v), _S_key(_M_rightmost())))\n+\t  if (!_M_impl._M_key_compare(_KeyOfValue()(__v), \n+\t\t\t\t      _S_key(_M_rightmost())))\n \t    return _M_insert(0, _M_rightmost(), __v);\n \t  else\n \t    return insert_equal(__v);\n@@ -938,15 +956,16 @@ namespace std\n \t{\n \t  iterator __before = __position;\n \t  --__before;\n-\t  if (!_M_key_compare(_KeyOfValue()(__v), _S_key(__before._M_node))\n-\t      && !_M_key_compare(_S_key(__position._M_node),\n-\t\t\t\t _KeyOfValue()(__v)))\n+\t  if (!_M_impl._M_key_compare(_KeyOfValue()(__v), \n+\t\t\t\t      _S_key(__before._M_node))\n+\t      && !_M_impl._M_key_compare(_S_key(__position._M_node),\n+\t\t\t\t\t _KeyOfValue()(__v)))\n \t    {\n \t      if (_S_right(__before._M_node) == 0)\n \t\treturn _M_insert(0, __before._M_node, __v);\n \t      else\n \t\treturn _M_insert(__position._M_node, __position._M_node, __v);\n-\t      // first argument just needs to be non-null\n+\t      // First argument just needs to be non-null.\n \t    }\n \t  else\n \t    return insert_equal(__v);\n@@ -982,9 +1001,9 @@ namespace std\n     {\n       _Link_type __y =\n \tstatic_cast<_Link_type>(_Rb_tree_rebalance_for_erase(__position._M_node,\n-\t\t\t\t\t\t\t     this->_M_header));\n+\t\t\t\t\t\t\t     this->_M_impl._M_header));\n       destroy_node(__y);\n-      --_M_node_count;\n+      --_M_impl._M_node_count;\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -1080,14 +1099,14 @@ namespace std\n       _Link_type __y = _M_end(); // Last node which is not less than __k.\n \n       while (__x != 0)\n-\tif (!_M_key_compare(_S_key(__x), __k))\n+\tif (!_M_impl._M_key_compare(_S_key(__x), __k))\n \t  __y = __x, __x = _S_left(__x);\n \telse\n \t  __x = _S_right(__x);\n \n       iterator __j = iterator(__y);\n-      return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ?\n-\tend() : __j;\n+      return (__j == end() \n+\t  || _M_impl._M_key_compare(__k, _S_key(__j._M_node))) ? end() : __j;\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -1101,14 +1120,14 @@ namespace std\n \n      while (__x != 0)\n        {\n-\t if (!_M_key_compare(_S_key(__x), __k))\n+\t if (!_M_impl._M_key_compare(_S_key(__x), __k))\n \t   __y = __x, __x = _S_left(__x);\n \t else\n \t   __x = _S_right(__x);\n        }\n      const_iterator __j = const_iterator(__y);\n-     return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ?\n-       end() : __j;\n+     return (__j == end() \n+\t  || _M_impl._M_key_compare(__k, _S_key(__j._M_node))) ? end() : __j;\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -1132,7 +1151,7 @@ namespace std\n       _Link_type __y = _M_end(); // Last node which is not less than __k.\n \n       while (__x != 0)\n-\tif (!_M_key_compare(_S_key(__x), __k))\n+\tif (!_M_impl._M_key_compare(_S_key(__x), __k))\n \t  __y = __x, __x = _S_left(__x);\n \telse\n \t  __x = _S_right(__x);\n@@ -1150,7 +1169,7 @@ namespace std\n       _Const_Link_type __y = _M_end(); // Last node which is not less than __k.\n \n       while (__x != 0)\n-\tif (!_M_key_compare(_S_key(__x), __k))\n+\tif (!_M_impl._M_key_compare(_S_key(__x), __k))\n \t  __y = __x, __x = _S_left(__x);\n \telse\n \t  __x = _S_right(__x);\n@@ -1168,7 +1187,7 @@ namespace std\n       _Link_type __y = _M_end(); // Last node which is greater than __k.\n \n       while (__x != 0)\n-\tif (_M_key_compare(__k, _S_key(__x)))\n+\tif (_M_impl._M_key_compare(__k, _S_key(__x)))\n \t  __y = __x, __x = _S_left(__x);\n \telse\n \t  __x = _S_right(__x);\n@@ -1186,7 +1205,7 @@ namespace std\n       _Const_Link_type __y = _M_end(); // Last node which is greater than __k.\n \n       while (__x != 0)\n-\tif (_M_key_compare(__k, _S_key(__x)))\n+\tif (_M_impl._M_key_compare(__k, _S_key(__x)))\n \t  __y = __x, __x = _S_left(__x);\n \telse\n \t  __x = _S_right(__x);\n@@ -1224,10 +1243,10 @@ namespace std\n     bool\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const\n     {\n-      if (_M_node_count == 0 || begin() == end())\n-\treturn _M_node_count == 0 && begin() == end()\n-\t       && this->_M_header._M_left == _M_end()\n-\t       && this->_M_header._M_right == _M_end();\n+      if (_M_impl._M_node_count == 0 || begin() == end())\n+\treturn _M_impl._M_node_count == 0 && begin() == end()\n+\t       && this->_M_impl._M_header._M_left == _M_end()\n+\t       && this->_M_impl._M_header._M_right == _M_end();\n \n       unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());\n       for (const_iterator __it = begin(); __it != end(); ++__it)\n@@ -1241,9 +1260,9 @@ namespace std\n \t\t|| (__R && __R->_M_color == _S_red))\n \t      return false;\n \n-\t  if (__L && _M_key_compare(_S_key(__x), _S_key(__L)))\n+\t  if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))\n \t    return false;\n-\t  if (__R && _M_key_compare(_S_key(__R), _S_key(__x)))\n+\t  if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))\n \t    return false;\n \n \t  if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)\n@@ -1259,3 +1278,4 @@ namespace std\n } // namespace std\n \n #endif\n+"}, {"sha": "64a1d7df866d919a4aba121907afb47cee794863", "filename": "libstdc++-v3/testsuite/23_containers/map/operators/1_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd22a3ceb375d5d8bae67a527c390f4116e59dc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd22a3ceb375d5d8bae67a527c390f4116e59dc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F1_neg.cc?ref=8bd22a3ceb375d5d8bae67a527c390f4116e59dc", "patch": "@@ -41,5 +41,5 @@ void test01()\n   test &= itr == mapByName.end(); // { dg-error \"no\" } \n }\n  \n-// { dg-error \"candidates are\" \"\" { target *-*-* } 212 } \n-// { dg-error \"candidates are\" \"\" { target *-*-* } 216 }\n+// { dg-error \"candidates are\" \"\" { target *-*-* } 209 } \n+// { dg-error \"candidates are\" \"\" { target *-*-* } 213 }"}, {"sha": "8af78f30837e4eb143e7582502ce096c3fa97306", "filename": "libstdc++-v3/testsuite/23_containers/set/operators/1_neg.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd22a3ceb375d5d8bae67a527c390f4116e59dc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd22a3ceb375d5d8bae67a527c390f4116e59dc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2F1_neg.cc?ref=8bd22a3ceb375d5d8bae67a527c390f4116e59dc", "patch": "@@ -39,5 +39,6 @@ void test01()\n   test &= itr == setByName.end(); // { dg-error \"no\" } \n }\n \n-// { dg-error \"candidates are\" \"\" { target *-*-* } 285 }\n-// { dg-error \"candidates are\" \"\" { target *-*-* } 289 } \n+// { dg-error \"candidates are\" \"\" { target *-*-* } 282 } \n+// { dg-error \"candidates are\" \"\" { target *-*-* } 286 }\n+"}]}