{"sha": "0a72704b04e73d1173ae5e1c99464bea55a698b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE3MjcwNGIwNGU3M2QxMTczYWU1ZTFjOTk0NjRiZWE1NWE2OThiNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-06T03:30:57Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-06T03:30:57Z"}, "message": "re PR c++/11431 (static_cast behavior with subclasses when default constructor available)\n\n\tPR c++/11431\n\t* typeck.c (build_static_cast): Check for reference conversions\n\tearlier.\n\n\t* cp-tree.h (perform_integral_promotions): Declare.\n\t* call.c (build_addr_func): Use decay_conversion.\n\t(convert_arg_to_ellipsis): Likewise.  Remove misleading comment.\n\t(convert_for_arg_passing): Use perform_integral_promotions.\n\t* cvt.c (build_expr_type_conversion): Use decay_conversion.\n\t(type_promotes_to): Do not return a cv-qualified type.\n\t* decl.c (grok_reference_init): Fix formatting.\n\t(get_atexit_node): Use decay_conversion.\n\t(build_enumerator): Use perform_integral_promotions.\n\t* init.c (build_vec_init): Use decay_conversion.\n\t* semantics.c (finish_expr_stmt): Likewise.\n\t(finish_switch_cond): Use perform_integral_promotions.\n\t* typeck.c (default_conversion): Likewise.\n\t(perform_integral_promotions): New function.\n\t(build_indirect_ref): Use decay_conversion.\n\t(build_array_ref): Use perform_integral_promotions.\n\t(convert_arguments): Use decay_conversion.\n\t(build_unary_op): Use perform_integral_promotions.\n\t(build_c_cast): Use decay_conversion.\n\t(build_modify_expr): Likewise.\n\t(convert_for_initialization): Likewise.\n\t* typeck2.c (build_x_arrow): Likewise.\n\n\t* g++.old-deja/g++.jason/typeid1.C: Make it a compile test, not a\n\trun test.\n\n\tPR c++/11431\n\t* g++.dg/expr/static_cast3.C: New test.\n\nFrom-SVN: r68989", "tree": {"sha": "056d5a4f42966fc1a6672ee25eb4c64a77754dbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/056d5a4f42966fc1a6672ee25eb4c64a77754dbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a72704b04e73d1173ae5e1c99464bea55a698b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a72704b04e73d1173ae5e1c99464bea55a698b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a72704b04e73d1173ae5e1c99464bea55a698b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a72704b04e73d1173ae5e1c99464bea55a698b4/comments", "author": null, "committer": null, "parents": [{"sha": "ac3d7b441379a5992280022a730eb5b1a57e0784", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac3d7b441379a5992280022a730eb5b1a57e0784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac3d7b441379a5992280022a730eb5b1a57e0784"}], "stats": {"total": 234, "additions": 164, "deletions": 70}, "files": [{"sha": "62d989d89a8399835aa5753034b4c6d7a0ebac1b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0a72704b04e73d1173ae5e1c99464bea55a698b4", "patch": "@@ -1,3 +1,34 @@\n+2003-07-05  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11431\n+\t* typeck.c (build_static_cast): Check for reference conversions\n+\tearlier.\n+\n+2003-07-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (perform_integral_promotions): Declare.\n+\t* call.c (build_addr_func): Use decay_conversion.\n+\t(convert_arg_to_ellipsis): Likewise.  Remove misleading comment.\n+\t(convert_for_arg_passing): Use perform_integral_promotions.\n+\t* cvt.c (build_expr_type_conversion): Use decay_conversion.\n+\t(type_promotes_to): Do not return a cv-qualified type.\n+\t* decl.c (grok_reference_init): Fix formatting.\n+\t(get_atexit_node): Use decay_conversion.\n+\t(build_enumerator): Use perform_integral_promotions.\n+\t* init.c (build_vec_init): Use decay_conversion.\n+\t* semantics.c (finish_expr_stmt): Likewise.\n+\t(finish_switch_cond): Use perform_integral_promotions.\n+\t* typeck.c (default_conversion): Likewise.\n+\t(perform_integral_promotions): New function.\n+\t(build_indirect_ref): Use decay_conversion.\n+\t(build_array_ref): Use perform_integral_promotions.\n+\t(convert_arguments): Use decay_conversion.\n+\t(build_unary_op): Use perform_integral_promotions.\n+\t(build_c_cast): Use decay_conversion.\n+\t(build_modify_expr): Likewise.\n+\t(convert_for_initialization): Likewise.\n+\t* typeck2.c (build_x_arrow): Likewise.\n+\n 2003-07-04  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* call.c: Fix comment typos."}, {"sha": "0832df70f920f13b627d22a7d8b3d984d6356946", "filename": "gcc/cp/call.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0a72704b04e73d1173ae5e1c99464bea55a698b4", "patch": "@@ -326,7 +326,7 @@ build_addr_func (tree function)\n       function = build_address (function);\n     }\n   else\n-    function = default_conversion (function);\n+    function = decay_conversion (function);\n \n   return function;\n }\n@@ -4339,20 +4339,29 @@ call_builtin_trap (void)\n }\n \n /* ARG is being passed to a varargs function.  Perform any conversions\n-   required.  Array/function to pointer decay must have already happened.\n-   Return the converted value.  */\n+   required.  Return the converted value.  */\n \n tree\n convert_arg_to_ellipsis (tree arg)\n {\n+  /* [expr.call]\n+\n+     The lvalue-to-rvalue, array-to-pointer, and function-to-pointer\n+     standard conversions are performed.  */\n+  arg = decay_conversion (arg);\n+  /* [expr.call]\n+\n+     If the argument has integral or enumeration type that is subject\n+     to the integral promotions (_conv.prom_), or a floating point\n+     type that is subject to the floating point promotion\n+     (_conv.fpprom_), the value of the argument is converted to the\n+     promoted type before the call.  */\n   if (TREE_CODE (TREE_TYPE (arg)) == REAL_TYPE\n       && (TYPE_PRECISION (TREE_TYPE (arg))\n \t  < TYPE_PRECISION (double_type_node)))\n-    /* Convert `float' to `double'.  */\n     arg = cp_convert (double_type_node, arg);\n-  else\n-    /* Convert `short' and `char' to full-size `int'.  */\n-    arg = default_conversion (arg);\n+  else if (INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (arg)))\n+    arg = perform_integral_promotions (arg);\n \n   arg = require_complete_type (arg);\n   \n@@ -4487,7 +4496,7 @@ convert_for_arg_passing (tree type, tree val)\n   else if (PROMOTE_PROTOTYPES\n \t   && INTEGRAL_TYPE_P (type)\n \t   && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n-    val = default_conversion (val);\n+    val = perform_integral_promotions (val);\n   return val;\n }\n "}, {"sha": "f58f8be2902607854dfbcf969fc51ebf0250c0b0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0a72704b04e73d1173ae5e1c99464bea55a698b4", "patch": "@@ -4255,6 +4255,7 @@ extern tree cxx_sizeof_or_alignof_type    (tree, enum tree_code, int);\n #define cxx_sizeof_nowarn(T) cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, false)\n extern tree inline_conversion\t\t\t(tree);\n extern tree decay_conversion\t\t\t(tree);\n+extern tree perform_integral_promotions         (tree);\n extern tree build_class_member_access_expr      (tree, tree, tree, bool);\n extern tree finish_class_member_access_expr     (tree, tree);\n extern tree build_x_indirect_ref\t\t(tree, const char *);"}, {"sha": "081d3b8caca9dd6f53915df7751d8701cfc311d6", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=0a72704b04e73d1173ae5e1c99464bea55a698b4", "patch": "@@ -1056,7 +1056,7 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n \t\n       case FUNCTION_TYPE:\n       case ARRAY_TYPE:\n-\treturn (desires & WANT_POINTER) ? default_conversion (expr)\n+\treturn (desires & WANT_POINTER) ? decay_conversion (expr)\n      \t                                : NULL_TREE;\n       default:\n \treturn NULL_TREE;\n@@ -1131,12 +1131,9 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n tree\n type_promotes_to (tree type)\n {\n-  int type_quals;\n-\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  type_quals = cp_type_quals (type);\n   type = TYPE_MAIN_VARIANT (type);\n \n   /* bool always promotes to int (not unsigned), even if it's the same\n@@ -1169,8 +1166,8 @@ type_promotes_to (tree type)\n     }\n   else if (type == float_type_node)\n     type = double_type_node;\n-\n-  return cp_build_qualified_type (type, type_quals);\n+    \n+  return type;\n }\n \n /* The routines below this point are carefully written to conform to"}, {"sha": "e44153e4462cbf638de373a6926e0ad544d60693", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0a72704b04e73d1173ae5e1c99464bea55a698b4", "patch": "@@ -7213,10 +7213,8 @@ grok_reference_init (tree decl, tree type, tree init)\n \n   if (TREE_CODE (TREE_TYPE (type)) != ARRAY_TYPE\n       && TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE)\n-    {\n-      /* Note: default conversion is only called in very special cases.  */\n-      init = default_conversion (init);\n-    }\n+    /* Note: default conversion is only called in very special cases.  */\n+    init = decay_conversion (init);\n \n   /* Convert INIT to the reference type TYPE.  This may involve the\n      creation of a temporary, whose lifetime must be the same as that\n@@ -8356,7 +8354,7 @@ get_atexit_node (void)\n   atexit_fndecl = build_library_fn_ptr (name, fn_type);\n   mark_used (atexit_fndecl);\n   pop_lang_context ();\n-  atexit_node = default_conversion (atexit_fndecl);\n+  atexit_node = decay_conversion (atexit_fndecl);\n \n   return atexit_node;\n }\n@@ -13180,7 +13178,7 @@ build_enumerator (tree name, tree value, tree enumtype)\n \n \t  if (TREE_CODE (value) == INTEGER_CST)\n \t    {\n-\t      value = default_conversion (value);\n+\t      value = perform_integral_promotions (value);\n \t      constant_expression_warning (value);\n \t    }\n \t  else"}, {"sha": "18a4dcf988ea80586dbffa2f3b2bb3a3b82a512c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=0a72704b04e73d1173ae5e1c99464bea55a698b4", "patch": "@@ -2656,7 +2656,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n   ptype = build_pointer_type (type);\n   size = size_in_bytes (type);\n   if (TREE_CODE (TREE_TYPE (base)) == ARRAY_TYPE)\n-    base = cp_convert (ptype, default_conversion (base));\n+    base = cp_convert (ptype, decay_conversion (base));\n \n   /* The code we are generating looks like:\n \n@@ -2739,7 +2739,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n \t checking.  */ \n       if (init)\n \t{\n-\t  base2 = default_conversion (init);\n+\t  base2 = decay_conversion (init);\n \t  itype = TREE_TYPE (base2);\n \t  base2 = get_temp_regvar (itype, base2);\n \t  itype = TREE_TYPE (itype);"}, {"sha": "d89aa5af3467861ef217efc8c8c25be196da738e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0a72704b04e73d1173ae5e1c99464bea55a698b4", "patch": "@@ -425,7 +425,7 @@ finish_expr_stmt (tree expr)\n \t  && ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n \t       && lvalue_p (expr))\n \t      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE))\n-\texpr = default_conversion (expr);\n+\texpr = decay_conversion (expr);\n       \n       /* Remember the type of the expression.  */\n       expr_type = TREE_TYPE (expr);\n@@ -748,7 +748,10 @@ finish_switch_cond (tree cond, tree switch_stmt)\n       orig_type = TREE_TYPE (cond);\n       if (cond != error_mark_node)\n \t{\n-\t  cond = default_conversion (cond);\n+\t  /* [stmt.switch]\n+\n+\t     Integral promotions are performed.  */\n+\t  cond = perform_integral_promotions (cond);\n \t  cond = fold (build1 (CLEANUP_POINT_EXPR, TREE_TYPE (cond), cond));\n \t}\n "}, {"sha": "eef1781a1383a942603b57d45e9a6d89e9c7927d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 67, "deletions": 44, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0a72704b04e73d1173ae5e1c99464bea55a698b4", "patch": "@@ -1483,11 +1483,11 @@ expr_sizeof (tree e)\n }\n   \n \f\n-/* Perform the array-to-pointer and function-to-pointer conversions\n-   for EXP.  \n+/* Perform the conversions in [expr] that apply when an lvalue appears\n+   in an rvalue context: the lvalue-to-rvalue, array-to-pointer, and\n+   function-to-pointer conversions.\n \n-   In addition, references are converted to lvalues and manifest\n-   constants are replaced by their values.  */\n+   In addition manifest constants are replaced by their values.  */\n \n tree\n decay_conversion (tree exp)\n@@ -1609,24 +1609,32 @@ decay_conversion (tree exp)\n tree\n default_conversion (tree exp)\n {\n-  tree type;\n-  enum tree_code code;\n-\n   exp = decay_conversion (exp);\n \n-  type = TREE_TYPE (exp);\n-  code = TREE_CODE (type);\n-\n-  if (INTEGRAL_CODE_P (code))\n-    {\n-      tree t = type_promotes_to (type);\n-      if (t != type)\n-\treturn cp_convert (t, exp);\n-    }\n+  if (INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (exp)))\n+    exp = perform_integral_promotions (exp);\n \n   return exp;\n }\n \n+/* EXPR is an expression with an integral or enumeration type.\n+   Perform the integral promotions in [conv.prom], and return the\n+   converted value.  */\n+\n+tree\n+perform_integral_promotions (tree expr)\n+{\n+  tree type;\n+  tree promoted_type;\n+\n+  type = TREE_TYPE (expr);\n+  my_friendly_assert (INTEGRAL_OR_ENUMERATION_TYPE_P (type), 20030703);\n+  promoted_type = type_promotes_to (type);\n+  if (type != promoted_type)\n+    expr = cp_convert (promoted_type, expr);\n+  return expr;\n+}\n+\n /* Take the address of an inline function without setting TREE_ADDRESSABLE\n    or TREE_USED.  */\n \n@@ -2232,7 +2240,7 @@ build_indirect_ref (ptr, errorstring)\n     return current_class_ref;\n \n   pointer = (TREE_CODE (TREE_TYPE (ptr)) == REFERENCE_TYPE\n-\t     ? ptr : default_conversion (ptr));\n+\t     ? ptr : decay_conversion (ptr));\n   type = TREE_TYPE (pointer);\n \n   if (TYPE_PTR_P (type) || TREE_CODE (type) == REFERENCE_TYPE)\n@@ -2350,15 +2358,19 @@ build_array_ref (array, idx)\n \t  && TYPE_MAIN_VARIANT (TREE_TYPE (idx)) == char_type_node)\n \twarning (\"array subscript has type `char'\");\n \n-      /* Apply default promotions *after* noticing character types.  */\n-      idx = default_conversion (idx);\n-\n-      if (TREE_CODE (TREE_TYPE (idx)) != INTEGER_TYPE)\n+      if (!INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (idx)))\n \t{\n \t  error (\"array subscript is not an integer\");\n \t  return error_mark_node;\n \t}\n \n+      /* Apply integral promotions *after* noticing character types.\n+\t (It is unclear why we do these promotions -- the standard\n+\t does not say that we should.  In fact, the natual thing would\n+\t seem to be to convert IDX to ptrdiff_t; we're performing\n+\t pointer arithmetic.)  */\n+      idx = perform_integral_promotions (idx);\n+\n       /* An array that is indexed by a non-constant\n \t cannot be stored in a register; we must be able to do\n \t address arithmetic on its address.\n@@ -2742,7 +2754,7 @@ convert_arguments (typelist, values, fndecl, flags)\n \t  if (TREE_CODE (TREE_TYPE (val)) == ARRAY_TYPE\n \t      || TREE_CODE (TREE_TYPE (val)) == FUNCTION_TYPE\n \t      || TREE_CODE (TREE_TYPE (val)) == METHOD_TYPE)\n-\t    val = default_conversion (val);\n+\t    val = decay_conversion (val);\n \t}\n \n       if (val == error_mark_node)\n@@ -4039,8 +4051,8 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n     case NEGATE_EXPR:\n       if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, true)))\n \terrstring = \"wrong type argument to unary minus\";\n-      else if (!noconvert)\n-\targ = default_conversion (arg);\n+      else if (!noconvert && CP_INTEGRAL_TYPE_P (TREE_TYPE (arg)))\n+\targ = perform_integral_promotions (arg);\n       break;\n \n     case BIT_NOT_EXPR:\n@@ -4054,7 +4066,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t\t\t\t\t\t   arg, true)))\n \terrstring = \"wrong type argument to bit-complement\";\n       else if (!noconvert)\n-\targ = default_conversion (arg);\n+\targ = perform_integral_promotions (arg);\n       break;\n \n     case ABS_EXPR:\n@@ -4778,22 +4790,6 @@ build_static_cast (tree type, tree expr)\n \n   intype = TREE_TYPE (expr);\n \n-  /* [expr.static.cast]\n-\n-     An expression e can be explicitly converted to a type T using a\n-     static_cast of the form static_cast<T>(e) if the declaration T\n-     t(e);\" is well-formed, for some invented temporary variable\n-     t.  */\n-  result = perform_direct_initialization_if_possible (type, expr);\n-  if (result)\n-    return convert_from_reference (result);\n-  \n-  /* [expr.static.cast]\n-\n-     Any expression can be explicitly converted to type cv void.  */\n-  if (TREE_CODE (type) == VOID_TYPE)\n-    return convert_to_void (expr, /*implicit=*/NULL);\n-\n   /* [expr.static.cast]\n \n      An lvalue of type \"cv1 B\", where B is a class type, can be cast\n@@ -4802,6 +4798,17 @@ build_static_cast (tree type, tree expr)\n      \"pointer to D\" to \"pointer to B\" exists (_conv.ptr_), cv2 is the\n      same cv-qualification as, or greater cv-qualification than, cv1,\n      and B is not a virtual base class of D.  */\n+  /* We check this case before checking the validity of \"TYPE t =\n+     EXPR;\" below because for this case:\n+\n+       struct B {};\n+       struct D : public B { D(const B&); };\n+       extern B& b;\n+       void f() { static_cast<const D&>(b); }\n+\n+     we want to avoid constructing a new D.  The standard is not\n+     completely clear about this issue, but our interpretation is\n+     consistent with other compilers.  */\n   if (TREE_CODE (type) == REFERENCE_TYPE\n       && CLASS_TYPE_P (TREE_TYPE (type))\n       && CLASS_TYPE_P (intype)\n@@ -4825,6 +4832,22 @@ build_static_cast (tree type, tree expr)\n       return convert_from_reference (build_nop (type, expr));\n     }\n \n+  /* [expr.static.cast]\n+\n+     An expression e can be explicitly converted to a type T using a\n+     static_cast of the form static_cast<T>(e) if the declaration T\n+     t(e);\" is well-formed, for some invented temporary variable\n+     t.  */\n+  result = perform_direct_initialization_if_possible (type, expr);\n+  if (result)\n+    return convert_from_reference (result);\n+  \n+  /* [expr.static.cast]\n+\n+     Any expression can be explicitly converted to type cv void.  */\n+  if (TREE_CODE (type) == VOID_TYPE)\n+    return convert_to_void (expr, /*implicit=*/NULL);\n+\n   /* [expr.static.cast]\n \n      The inverse of any standard conversion sequence (clause _conv_),\n@@ -5158,7 +5181,7 @@ build_c_cast (tree type, tree expr)\n \t\t    && bound_pmf_p (value)))\n \t  || TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE\n \t  || TREE_CODE (TREE_TYPE (value)) == REFERENCE_TYPE)\n-\tvalue = default_conversion (value);\n+\tvalue = decay_conversion (value);\n     }\n   else if (TREE_CODE (TREE_TYPE (value)) == REFERENCE_TYPE)\n     /* However, even for class types, we still need to strip away\n@@ -5422,7 +5445,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t    || TREE_CODE (TREE_TYPE (newrhs)) == FUNCTION_TYPE\n \t    || TREE_CODE (TREE_TYPE (newrhs)) == METHOD_TYPE\n \t    || TREE_CODE (TREE_TYPE (newrhs)) == OFFSET_TYPE)\n-\t  newrhs = default_conversion (newrhs);\n+\t  newrhs = decay_conversion (newrhs);\n \t\n \t/* ISO C++ 5.4/1: The result is an lvalue if T is a reference\n \t   type, otherwise the result is an rvalue.  */\n@@ -6078,7 +6101,7 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n \t  && (TREE_CODE (type) != REFERENCE_TYPE\n \t      || TREE_CODE (TREE_TYPE (type)) != FUNCTION_TYPE))\n       || TREE_CODE (TREE_TYPE (rhs)) == METHOD_TYPE)\n-    rhs = default_conversion (rhs);\n+    rhs = decay_conversion (rhs);\n \n   rhstype = TREE_TYPE (rhs);\n   coder = TREE_CODE (rhstype);"}, {"sha": "edb9f5d5b212d77d01753e03ee52eb7ca31c09cd", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=0a72704b04e73d1173ae5e1c99464bea55a698b4", "patch": "@@ -1030,7 +1030,7 @@ build_x_arrow (tree datum)\n \tlast_rval = convert_from_reference (last_rval);\n     }\n   else\n-    last_rval = default_conversion (rval);\n+    last_rval = decay_conversion (rval);\n \n   if (TREE_CODE (TREE_TYPE (last_rval)) == POINTER_TYPE)\n     return build_indirect_ref (last_rval, NULL);"}, {"sha": "3d067f575e9e8f97e946a42b5961baa5108bce3c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0a72704b04e73d1173ae5e1c99464bea55a698b4", "patch": "@@ -1,3 +1,11 @@\n+2003-07-05  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.old-deja/g++.jason/typeid1.C: Make it a compile test, not a\n+\trun test.\n+\t\n+\tPR c++/11431\n+\t* g++.dg/expr/static_cast3.C: New test.\n+\n 2003-07-04  Zack Weinberg  <zack@codesourcery.com>\n \n \t* gcc.c-torture/execute/wchar_t-1.x: New file; XFAIL wchar_t-1.c"}, {"sha": "744648c3f45ef2486a46cf0e7d801cea4c57d404", "filename": "gcc/testsuite/g++.dg/expr/static_cast3.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fstatic_cast3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fstatic_cast3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fstatic_cast3.C?ref=0a72704b04e73d1173ae5e1c99464bea55a698b4", "patch": "@@ -0,0 +1,24 @@\n+template <class T> struct static_abort {};\n+\n+template <class E>\n+struct any\n+{\n+  const E& self() const { return static_cast<const E&>(*this); }\n+};\n+\n+struct range : public any<range>\n+{\n+  range() {}\n+\n+  template <class U>\n+  range(const U&)\n+  {\n+    typedef typename static_abort<U>::ret t;\n+  }\n+};\n+\n+int main()\n+{\n+  const any<range>& r = *new range();\n+  r.self();\n+}"}, {"sha": "ec5156e0cd0bcba2d9599980b494258bb6693710", "filename": "gcc/testsuite/g++.old-deja/g++.jason/typeid1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftypeid1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a72704b04e73d1173ae5e1c99464bea55a698b4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftypeid1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftypeid1.C?ref=0a72704b04e73d1173ae5e1c99464bea55a698b4", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run  }\n+// { dg-do compile }\n #include <typeinfo>\n #include <iostream>\n "}]}