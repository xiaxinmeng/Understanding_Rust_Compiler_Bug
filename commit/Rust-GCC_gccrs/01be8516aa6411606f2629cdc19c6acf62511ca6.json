{"sha": "01be8516aa6411606f2629cdc19c6acf62511ca6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFiZTg1MTZhYTY0MTE2MDZmMjYyOWNkYzE5YzZhY2Y2MjUxMWNhNg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-12-23T16:25:52Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-12-23T16:25:52Z"}, "message": "Fix PR47002: memory leaks.\n\n2010-12-23  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR tree-optimization/47002\n\t* tree-data-ref.c (compute_data_dependences_for_loop): Pass in a\n\tpointer to the loop_nest.\n\t(analyze_all_data_dependences): Initialize and free the loop_nest.\n\t(free_dependence_relations): Do not free loop_nest.\n\t(build_rdg): Pass in the loop_nest, datarefs, and dependence_relations.\n\t(free_rdg): Also free the data on edges.\n\t* tree-data-ref.h (build_rdg): Update declaration.\n\t(compute_data_dependences_for_loop): Same.\n\t* tree-if-conv.c (if_convertible_loop_p_1): Pass in the loop_nest.\n\t(if_convertible_loop_p): Allocate and free loop_nest.\n\t* tree-loop-distribution.c (rdg_flag_loop_exits): Free conds.\n\t(free_rdg_components): VEC_free components.\n\t(distribute_loop): Update call to build_rdg.  Allocate and free\n\tloop_nest, datarefs, and dependence_relations.\n\t* tree-loop-linear.c (linear_transform_loops): Allocate and free\n\tloop_nest.\n\t* tree-parloops.c (loop_parallel_p): Same.\n\t* tree-predcom.c (tree_predictive_commoning_loop): Same.\n\t* tree-vect-data-refs.c (vect_analyze_data_refs): Pass to\n\tcompute_data_dependences_for_loop a pointer to LOOP_VINFO_LOOP_NEST.\n\t* tree-vect-loop.c (new_loop_vec_info): Initialize LOOP_VINFO_LOOP_NEST.\n\t(destroy_loop_vec_info): Free LOOP_VINFO_MAY_ALIAS_DDRS and\n\tLOOP_VINFO_LOOP_NEST.\n\t* tree-vect-slp.c (destroy_bb_vec_info): Call free_data_refs and\n\tfree_dependence_relations.\n\t* tree-vectorizer.h (struct _loop_vec_info): Add a field loop_nest.\n\t(LOOP_VINFO_LOOP_NEST): New.\n\nFrom-SVN: r168210", "tree": {"sha": "560661198b65a199d12abbb757c1a4560e199292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/560661198b65a199d12abbb757c1a4560e199292"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01be8516aa6411606f2629cdc19c6acf62511ca6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01be8516aa6411606f2629cdc19c6acf62511ca6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01be8516aa6411606f2629cdc19c6acf62511ca6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01be8516aa6411606f2629cdc19c6acf62511ca6/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5333fe82b2a99b70066a31462e0137914a3c236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5333fe82b2a99b70066a31462e0137914a3c236", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5333fe82b2a99b70066a31462e0137914a3c236"}], "stats": {"total": 176, "additions": 120, "deletions": 56}, "files": [{"sha": "fae91539de16ddc2cf6a8d34a3b700ed1bd513c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01be8516aa6411606f2629cdc19c6acf62511ca6", "patch": "@@ -1,3 +1,34 @@\n+2010-12-23  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/47002\n+\t* tree-data-ref.c (compute_data_dependences_for_loop): Pass in a\n+\tpointer to the loop_nest.\n+\t(analyze_all_data_dependences): Initialize and free the loop_nest.\n+\t(free_dependence_relations): Do not free loop_nest.\n+\t(build_rdg): Pass in the loop_nest, datarefs, and dependence_relations.\n+\t(free_rdg): Also free the data on edges.\n+\t* tree-data-ref.h (build_rdg): Update declaration.\n+\t(compute_data_dependences_for_loop): Same.\n+\t* tree-if-conv.c (if_convertible_loop_p_1): Pass in the loop_nest.\n+\t(if_convertible_loop_p): Allocate and free loop_nest.\n+\t* tree-loop-distribution.c (rdg_flag_loop_exits): Free conds.\n+\t(free_rdg_components): VEC_free components.\n+\t(distribute_loop): Update call to build_rdg.  Allocate and free\n+\tloop_nest, datarefs, and dependence_relations.\n+\t* tree-loop-linear.c (linear_transform_loops): Allocate and free\n+\tloop_nest.\n+\t* tree-parloops.c (loop_parallel_p): Same.\n+\t* tree-predcom.c (tree_predictive_commoning_loop): Same.\n+\t* tree-vect-data-refs.c (vect_analyze_data_refs): Pass to\n+\tcompute_data_dependences_for_loop a pointer to LOOP_VINFO_LOOP_NEST.\n+\t* tree-vect-loop.c (new_loop_vec_info): Initialize LOOP_VINFO_LOOP_NEST.\n+\t(destroy_loop_vec_info): Free LOOP_VINFO_MAY_ALIAS_DDRS and\n+\tLOOP_VINFO_LOOP_NEST.\n+\t* tree-vect-slp.c (destroy_bb_vec_info): Call free_data_refs and\n+\tfree_dependence_relations.\n+\t* tree-vectorizer.h (struct _loop_vec_info): Add a field loop_nest.\n+\t(LOOP_VINFO_LOOP_NEST): New.\n+\n 2010-12-23  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa.c (cgraph_remove_unreachable_nodes): Update former_clone_of even"}, {"sha": "a9782f4825b998fae53948d6ba0b42bdd7ccb4a2", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 33, "deletions": 45, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=01be8516aa6411606f2629cdc19c6acf62511ca6", "patch": "@@ -4247,31 +4247,31 @@ find_loop_nest (struct loop *loop, VEC (loop_p, heap) **loop_nest)\n bool\n compute_data_dependences_for_loop (struct loop *loop,\n \t\t\t\t   bool compute_self_and_read_read_dependences,\n+\t\t\t\t   VEC (loop_p, heap) **loop_nest,\n \t\t\t\t   VEC (data_reference_p, heap) **datarefs,\n \t\t\t\t   VEC (ddr_p, heap) **dependence_relations)\n {\n   bool res = true;\n-  VEC (loop_p, heap) *vloops = VEC_alloc (loop_p, heap, 3);\n \n   memset (&dependence_stats, 0, sizeof (dependence_stats));\n \n   /* If the loop nest is not well formed, or one of the data references\n      is not computable, give up without spending time to compute other\n      dependences.  */\n   if (!loop\n-      || !find_loop_nest (loop, &vloops)\n+      || !find_loop_nest (loop, loop_nest)\n       || find_data_references_in_loop (loop, datarefs) == chrec_dont_know)\n     {\n       struct data_dependence_relation *ddr;\n \n       /* Insert a single relation into dependence_relations:\n \t chrec_dont_know.  */\n-      ddr = initialize_data_dependence_relation (NULL, NULL, vloops);\n+      ddr = initialize_data_dependence_relation (NULL, NULL, *loop_nest);\n       VEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n       res = false;\n     }\n   else\n-    compute_all_dependences (*datarefs, dependence_relations, vloops,\n+    compute_all_dependences (*datarefs, dependence_relations, *loop_nest,\n \t\t\t     compute_self_and_read_read_dependences);\n \n   if (dump_file && (dump_flags & TDF_STATS))\n@@ -4375,9 +4375,10 @@ analyze_all_data_dependences (struct loop *loop)\n     VEC_alloc (data_reference_p, heap, nb_data_refs);\n   VEC (ddr_p, heap) *dependence_relations =\n     VEC_alloc (ddr_p, heap, nb_data_refs * nb_data_refs);\n+  VEC (loop_p, heap) *loop_nest = VEC_alloc (loop_p, heap, 3);\n \n   /* Compute DDs on the whole function.  */\n-  compute_data_dependences_for_loop (loop, false, &datarefs,\n+  compute_data_dependences_for_loop (loop, false, &loop_nest, &datarefs,\n \t\t\t\t     &dependence_relations);\n \n   if (dump_file)\n@@ -4411,6 +4412,7 @@ analyze_all_data_dependences (struct loop *loop)\n \t}\n     }\n \n+  VEC_free (loop_p, heap, loop_nest);\n   free_dependence_relations (dependence_relations);\n   free_data_refs (datarefs);\n }\n@@ -4454,22 +4456,11 @@ free_dependence_relations (VEC (ddr_p, heap) *dependence_relations)\n {\n   unsigned int i;\n   struct data_dependence_relation *ddr;\n-  VEC (loop_p, heap) *loop_nest = NULL;\n \n   FOR_EACH_VEC_ELT (ddr_p, dependence_relations, i, ddr)\n-    {\n-      if (ddr == NULL)\n-\tcontinue;\n-      if (loop_nest == NULL)\n-\tloop_nest = DDR_LOOP_NEST (ddr);\n-      else\n-\tgcc_assert (DDR_LOOP_NEST (ddr) == NULL\n-\t\t    || DDR_LOOP_NEST (ddr) == loop_nest);\n+    if (ddr)\n       free_dependence_relation (ddr);\n-    }\n \n-  if (loop_nest)\n-    VEC_free (loop_p, heap, loop_nest);\n   VEC_free (ddr_p, heap, dependence_relations);\n }\n \n@@ -4905,37 +4896,24 @@ build_empty_rdg (int n_stmts)\n    scalar dependence.  */\n \n struct graph *\n-build_rdg (struct loop *loop)\n+build_rdg (struct loop *loop,\n+\t   VEC (loop_p, heap) **loop_nest,\n+\t   VEC (ddr_p, heap) **dependence_relations,\n+\t   VEC (data_reference_p, heap) **datarefs)\n {\n-  int nb_data_refs = 10;\n   struct graph *rdg = NULL;\n-  VEC (ddr_p, heap) *dependence_relations;\n-  VEC (data_reference_p, heap) *datarefs;\n-  VEC (gimple, heap) *stmts = VEC_alloc (gimple, heap, nb_data_refs);\n-\n-  dependence_relations = VEC_alloc (ddr_p, heap, nb_data_refs * nb_data_refs) ;\n-  datarefs = VEC_alloc (data_reference_p, heap, nb_data_refs);\n-  compute_data_dependences_for_loop (loop,\n-                                     false,\n-                                     &datarefs,\n-                                     &dependence_relations);\n-\n-  if (!known_dependences_p (dependence_relations))\n-    {\n-      free_dependence_relations (dependence_relations);\n-      free_data_refs (datarefs);\n-      VEC_free (gimple, heap, stmts);\n-\n-      return rdg;\n-    }\n+  VEC (gimple, heap) *stmts = VEC_alloc (gimple, heap, 10);\n \n-  stmts_from_loop (loop, &stmts);\n-  rdg = build_empty_rdg (VEC_length (gimple, stmts));\n+  compute_data_dependences_for_loop (loop, false, loop_nest, datarefs,\n+\t\t\t\t     dependence_relations);\n \n-  rdg->indices = htab_create (nb_data_refs, hash_stmt_vertex_info,\n-\t\t\t      eq_stmt_vertex_info, hash_stmt_vertex_del);\n-  create_rdg_vertices (rdg, stmts);\n-  create_rdg_edges (rdg, dependence_relations);\n+  if (known_dependences_p (*dependence_relations))\n+    {\n+      stmts_from_loop (loop, &stmts);\n+      rdg = build_empty_rdg (VEC_length (gimple, stmts));\n+      create_rdg_vertices (rdg, stmts);\n+      create_rdg_edges (rdg, *dependence_relations);\n+    }\n \n   VEC_free (gimple, heap, stmts);\n   return rdg;\n@@ -4949,7 +4927,17 @@ free_rdg (struct graph *rdg)\n   int i;\n \n   for (i = 0; i < rdg->n_vertices; i++)\n-    free (rdg->vertices[i].data);\n+    {\n+      struct vertex *v = &(rdg->vertices[i]);\n+      struct graph_edge *e;\n+\n+      for (e = v->succ; e; e = e->succ_next)\n+\tif (e->data)\n+\t  free (e->data);\n+\n+      if (v->data)\n+\tfree (v->data);\n+    }\n \n   htab_delete (rdg->indices);\n   free_graph (rdg);"}, {"sha": "78655762dcc55096fe5d1f9610e98880d501a9b8", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=01be8516aa6411606f2629cdc19c6acf62511ca6", "patch": "@@ -376,6 +376,7 @@ DEF_VEC_ALLOC_O (data_ref_loc, heap);\n bool get_references_in_stmt (gimple, VEC (data_ref_loc, heap) **);\n bool dr_analyze_innermost (struct data_reference *);\n extern bool compute_data_dependences_for_loop (struct loop *, bool,\n+\t\t\t\t\t       VEC (loop_p, heap) **,\n \t\t\t\t\t       VEC (data_reference_p, heap) **,\n \t\t\t\t\t       VEC (ddr_p, heap) **);\n extern bool compute_data_dependences_for_bb (basic_block, bool,\n@@ -577,7 +578,10 @@ typedef struct rdg_edge\n #define RDGE_LEVEL(E)       ((struct rdg_edge *) ((E)->data))->level\n #define RDGE_RELATION(E)    ((struct rdg_edge *) ((E)->data))->relation\n \n-struct graph *build_rdg (struct loop *);\n+struct graph *build_rdg (struct loop *,\n+\t\t\t VEC (loop_p, heap) **,\n+\t\t\t VEC (ddr_p, heap) **,\n+\t\t\t VEC (data_reference_p, heap) **);\n struct graph *build_empty_rdg (int);\n void free_rdg (struct graph *);\n "}, {"sha": "46b20c26c1946cb4b9439c671944f5ae2991e847", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=01be8516aa6411606f2629cdc19c6acf62511ca6", "patch": "@@ -977,6 +977,7 @@ predicate_bbs (loop_p loop)\n \n static bool\n if_convertible_loop_p_1 (struct loop *loop,\n+\t\t\t VEC (loop_p, heap) **loop_nest,\n \t\t\t VEC (data_reference_p, heap) **refs,\n \t\t\t VEC (ddr_p, heap) **ddrs)\n {\n@@ -986,7 +987,7 @@ if_convertible_loop_p_1 (struct loop *loop,\n \n   /* Don't if-convert the loop when the data dependences cannot be\n      computed: the loop won't be vectorized in that case.  */\n-  res = compute_data_dependences_for_loop (loop, true, refs, ddrs);\n+  res = compute_data_dependences_for_loop (loop, true, loop_nest, refs, ddrs);\n   if (!res)\n     return false;\n \n@@ -1066,6 +1067,7 @@ if_convertible_loop_p (struct loop *loop)\n   bool res = false;\n   VEC (data_reference_p, heap) *refs;\n   VEC (ddr_p, heap) *ddrs;\n+  VEC (loop_p, heap) *loop_nest;\n \n   /* Handle only innermost loop.  */\n   if (!loop || loop->inner)\n@@ -1099,7 +1101,8 @@ if_convertible_loop_p (struct loop *loop)\n \n   refs = VEC_alloc (data_reference_p, heap, 5);\n   ddrs = VEC_alloc (ddr_p, heap, 25);\n-  res = if_convertible_loop_p_1 (loop, &refs, &ddrs);\n+  loop_nest = VEC_alloc (loop_p, heap, 3);\n+  res = if_convertible_loop_p_1 (loop, &loop_nest, &refs, &ddrs);\n \n   if (flag_tree_loop_if_convert_stores)\n     {\n@@ -1110,6 +1113,7 @@ if_convertible_loop_p (struct loop *loop)\n \tfree (dr->aux);\n     }\n \n+  VEC_free (loop_p, heap, loop_nest);\n   free_data_refs (refs);\n   free_dependence_relations (ddrs);\n   return res;"}, {"sha": "d1a499b951c01b11be68b259eb6dd1306a767632", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=01be8516aa6411606f2629cdc19c6acf62511ca6", "patch": "@@ -653,6 +653,8 @@ rdg_flag_loop_exits (struct graph *rdg, bitmap loops, bitmap partition,\n \n       BITMAP_FREE (new_loops);\n     }\n+\n+  VEC_free (gimple, heap, conds);\n }\n \n /* Returns a bitmap in which all the statements needed for computing\n@@ -693,6 +695,8 @@ free_rdg_components (VEC (rdgc, heap) *components)\n       VEC_free (int, heap, x->vertices);\n       free (x);\n     }\n+\n+  VEC_free (rdgc, heap, components);\n }\n \n /* Build the COMPONENTS vector with the strongly connected components\n@@ -1146,6 +1150,9 @@ distribute_loop (struct loop *loop, VEC (gimple, heap) *stmts)\n   gimple s;\n   unsigned i;\n   VEC (int, heap) *vertices;\n+  VEC (ddr_p, heap) *dependence_relations;\n+  VEC (data_reference_p, heap) *datarefs;\n+  VEC (loop_p, heap) *loop_nest;\n \n   if (loop->num_nodes > 2)\n     {\n@@ -1157,7 +1164,10 @@ distribute_loop (struct loop *loop, VEC (gimple, heap) *stmts)\n       return res;\n     }\n \n-  rdg = build_rdg (loop);\n+  datarefs = VEC_alloc (data_reference_p, heap, 10);\n+  dependence_relations = VEC_alloc (ddr_p, heap, 100);\n+  loop_nest = VEC_alloc (loop_p, heap, 3);\n+  rdg = build_rdg (loop, &loop_nest, &dependence_relations, &datarefs);\n \n   if (!rdg)\n     {\n@@ -1166,6 +1176,9 @@ distribute_loop (struct loop *loop, VEC (gimple, heap) *stmts)\n \t\t \"FIXME: Loop %d not distributed: failed to build the RDG.\\n\",\n \t\t loop->num);\n \n+      free_dependence_relations (dependence_relations);\n+      free_data_refs (datarefs);\n+      VEC_free (loop_p, heap, loop_nest);\n       return res;\n     }\n \n@@ -1191,7 +1204,9 @@ distribute_loop (struct loop *loop, VEC (gimple, heap) *stmts)\n   res = ldist_gen (loop, rdg, vertices);\n   VEC_free (int, heap, vertices);\n   free_rdg (rdg);\n-\n+  free_dependence_relations (dependence_relations);\n+  free_data_refs (datarefs);\n+  VEC_free (loop_p, heap, loop_nest);\n   return res;\n }\n "}, {"sha": "fa31b9d2dac3724d1467b94a58e5b49e51a1d6d0", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=01be8516aa6411606f2629cdc19c6acf62511ca6", "patch": "@@ -329,7 +329,8 @@ linear_transform_loops (void)\n       lambda_trans_matrix trans;\n       struct obstack lambda_obstack;\n       struct loop *loop;\n-      VEC(loop_p,heap) *nest;\n+      VEC (loop_p, heap) *nest;\n+      VEC (loop_p, heap) *ln;\n \n       depth = perfect_loop_nest_depth (loop_nest);\n       if (depth == 0)\n@@ -346,7 +347,8 @@ linear_transform_loops (void)\n \n       datarefs = VEC_alloc (data_reference_p, heap, 10);\n       dependence_relations = VEC_alloc (ddr_p, heap, 10 * 10);\n-      if (!compute_data_dependences_for_loop (loop_nest, true, &datarefs,\n+      ln = VEC_alloc (loop_p, heap, 3);\n+      if (!compute_data_dependences_for_loop (loop_nest, true, &ln, &datarefs,\n \t\t\t\t\t      &dependence_relations))\n \tgoto free_and_continue;\n \n@@ -412,6 +414,7 @@ linear_transform_loops (void)\n       free_dependence_relations (dependence_relations);\n       free_data_refs (datarefs);\n       VEC_free (loop_p, heap, nest);\n+      VEC_free (loop_p, heap, ln);\n     }\n \n   FOR_EACH_VEC_ELT (gimple, remove_ivs, i, oldiv_stmt)"}, {"sha": "aba70c8f082fde66ab0510f94e076e840eb4d881", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=01be8516aa6411606f2629cdc19c6acf62511ca6", "patch": "@@ -252,7 +252,8 @@ name_to_copy_elt_hash (const void *aa)\n static bool\n loop_parallel_p (struct loop *loop, struct obstack * parloop_obstack)\n {\n-  VEC (ddr_p, heap) * dependence_relations;\n+  VEC (loop_p, heap) *loop_nest;\n+  VEC (ddr_p, heap) *dependence_relations;\n   VEC (data_reference_p, heap) *datarefs;\n   lambda_trans_matrix trans;\n   bool ret = false;\n@@ -270,7 +271,8 @@ loop_parallel_p (struct loop *loop, struct obstack * parloop_obstack)\n      the iterations are independent.  */\n   datarefs = VEC_alloc (data_reference_p, heap, 10);\n   dependence_relations = VEC_alloc (ddr_p, heap, 10 * 10);\n-  compute_data_dependences_for_loop (loop, true, &datarefs,\n+  loop_nest = VEC_alloc (loop_p, heap, 3);\n+  compute_data_dependences_for_loop (loop, true, &loop_nest, &datarefs,\n \t\t\t\t     &dependence_relations);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_data_dependence_relations (dump_file, dependence_relations);\n@@ -288,6 +290,7 @@ loop_parallel_p (struct loop *loop, struct obstack * parloop_obstack)\n     fprintf (dump_file,\n \t     \"  FAILED: data dependencies exist across iterations\\n\");\n \n+  VEC_free (loop_p, heap, loop_nest);\n   free_dependence_relations (dependence_relations);\n   free_data_refs (datarefs);\n "}, {"sha": "f744d4487809854e5157088451deb2c94d2d1dd5", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=01be8516aa6411606f2629cdc19c6acf62511ca6", "patch": "@@ -2441,6 +2441,7 @@ prepare_initializers (struct loop *loop, VEC (chain_p, heap) *chains)\n static bool\n tree_predictive_commoning_loop (struct loop *loop)\n {\n+  VEC (loop_p, heap) *loop_nest;\n   VEC (data_reference_p, heap) *datarefs;\n   VEC (ddr_p, heap) *dependences;\n   struct component *components;\n@@ -2458,11 +2459,14 @@ tree_predictive_commoning_loop (struct loop *loop)\n      dependence relations.  */\n   datarefs = VEC_alloc (data_reference_p, heap, 10);\n   dependences = VEC_alloc (ddr_p, heap, 10);\n-  compute_data_dependences_for_loop (loop, true, &datarefs, &dependences);\n+  loop_nest = VEC_alloc (loop_p, heap, 3);\n+  compute_data_dependences_for_loop (loop, true, &loop_nest, &datarefs,\n+\t\t\t\t     &dependences);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_data_dependence_relations (dump_file, dependences);\n \n   components = split_data_refs_to_components (loop, datarefs, dependences);\n+  VEC_free (loop_p, heap, loop_nest);\n   free_dependence_relations (dependences);\n   if (!components)\n     {"}, {"sha": "1ec59efaac6074ae9bedad9e56f71160f3f63933", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=01be8516aa6411606f2629cdc19c6acf62511ca6", "patch": "@@ -2487,7 +2487,9 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n     {\n       loop = LOOP_VINFO_LOOP (loop_vinfo);\n       res = compute_data_dependences_for_loop\n-\t(loop, true, &LOOP_VINFO_DATAREFS (loop_vinfo),\n+\t(loop, true,\n+\t &LOOP_VINFO_LOOP_NEST (loop_vinfo),\n+\t &LOOP_VINFO_DATAREFS (loop_vinfo),\n \t &LOOP_VINFO_DDRS (loop_vinfo));\n \n       if (!res)"}, {"sha": "1dc4ec0fde950112c8c3583f0523295819060f5a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=01be8516aa6411606f2629cdc19c6acf62511ca6", "patch": "@@ -745,6 +745,7 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_VECTORIZABLE_P (res) = 0;\n   LOOP_PEELING_FOR_ALIGNMENT (res) = 0;\n   LOOP_VINFO_VECT_FACTOR (res) = 0;\n+  LOOP_VINFO_LOOP_NEST (res) = VEC_alloc (loop_p, heap, 3);\n   LOOP_VINFO_DATAREFS (res) = VEC_alloc (data_reference_p, heap, 10);\n   LOOP_VINFO_DDRS (res) = VEC_alloc (ddr_p, heap, 10 * 10);\n   LOOP_VINFO_UNALIGNED_DR (res) = NULL;\n@@ -793,7 +794,9 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n       free (LOOP_VINFO_BBS (loop_vinfo));\n       free_data_refs (LOOP_VINFO_DATAREFS (loop_vinfo));\n       free_dependence_relations (LOOP_VINFO_DDRS (loop_vinfo));\n+      VEC_free (loop_p, heap, LOOP_VINFO_LOOP_NEST (loop_vinfo));\n       VEC_free (gimple, heap, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo));\n+      VEC_free (ddr_p, heap, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo));\n \n       free (loop_vinfo);\n       loop->aux = NULL;\n@@ -839,6 +842,7 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   free (LOOP_VINFO_BBS (loop_vinfo));\n   free_data_refs (LOOP_VINFO_DATAREFS (loop_vinfo));\n   free_dependence_relations (LOOP_VINFO_DDRS (loop_vinfo));\n+  VEC_free (loop_p, heap, LOOP_VINFO_LOOP_NEST (loop_vinfo));\n   VEC_free (gimple, heap, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo));\n   VEC_free (ddr_p, heap, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo));\n   slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);"}, {"sha": "6eb67ae5a75e40fccdd9da6660efd92a0496e509", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=01be8516aa6411606f2629cdc19c6acf62511ca6", "patch": "@@ -1486,6 +1486,8 @@ destroy_bb_vec_info (bb_vec_info bb_vinfo)\n         free_stmt_vec_info (stmt);\n     }\n \n+  free_data_refs (BB_VINFO_DATAREFS (bb_vinfo));\n+  free_dependence_relations (BB_VINFO_DDRS (bb_vinfo));\n   VEC_free (gimple, heap, BB_VINFO_STRIDED_STORES (bb_vinfo));\n   VEC_free (slp_instance, heap, BB_VINFO_SLP_INSTANCES (bb_vinfo));\n   free (bb_vinfo);"}, {"sha": "ee8410c18110b98cf3df3206f52a259eae3ca637", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be8516aa6411606f2629cdc19c6acf62511ca6/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=01be8516aa6411606f2629cdc19c6acf62511ca6", "patch": "@@ -216,6 +216,9 @@ typedef struct _loop_vec_info {\n   /* The mask used to check the alignment of pointers or arrays.  */\n   int ptr_mask;\n \n+  /* The loop nest in which the data dependences are computed.  */\n+  VEC (loop_p, heap) *loop_nest;\n+\n   /* All data references in the loop.  */\n   VEC (data_reference_p, heap) *datarefs;\n \n@@ -261,6 +264,7 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_VECTORIZABLE_P(L)       (L)->vectorizable\n #define LOOP_VINFO_VECT_FACTOR(L)          (L)->vectorization_factor\n #define LOOP_VINFO_PTR_MASK(L)             (L)->ptr_mask\n+#define LOOP_VINFO_LOOP_NEST(L)            (L)->loop_nest\n #define LOOP_VINFO_DATAREFS(L)             (L)->datarefs\n #define LOOP_VINFO_DDRS(L)                 (L)->ddrs\n #define LOOP_VINFO_INT_NITERS(L)           (TREE_INT_CST_LOW ((L)->num_iters))"}]}