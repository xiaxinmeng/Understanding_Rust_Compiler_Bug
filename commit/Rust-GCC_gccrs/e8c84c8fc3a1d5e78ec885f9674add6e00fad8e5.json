{"sha": "e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThjODRjOGZjM2ExZDVlNzhlYzg4NWY5Njc0YWRkNmUwMGZhZDhlNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-26T09:28:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-26T09:28:14Z"}, "message": "[multiple changes]\n\n2015-05-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch7.adb (Install_Private_Declarations,\n\tSwap_Private_Dependents): Ensure that both views of the dependent\n\tsubtype are immediately visible if we are within their scope. This\n\tmay be needed when a procedure body is both the parent of an\n\tinstantiated child unit, and is itself used to inline a local\n\tfunction.\n\n2015-05-26  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_prag.adb, gnat1drv.adb: Minor reformatting.\n\n2015-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Indexed_Component): In the circuit\n\tdetecting exceptions to the rewriting, deal with implicit\n\tdereferences in the selected component case.\n\n2015-05-26  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch13.adb (Analyze_One_Aspect): Do not\n\trequire the expression of the Disable_Controlled aspect to be\n\tstatic in a generic template, because 'Enabled is not known\n\tuntil the instance.\n\n2015-05-26  Doug Rupp  <rupp@adacore.com>\n\n\t* init-vxsim.c: New file for vxsim ZCX\n\t* sigtramp-vxworks-vxsim.c: Likewise.\n\t* sigtramp-vxworks.c: Factor out target dependent bits into ...\n\t* sigtramp-vxworks-target.inc: ... here.\n\t* sigtramp.h: Add vxsim zcx protos.\n\t* init.c [vxworks...] (sysLib.h): Include.\n\t(__gnat_map_signal): Make global.\n\t [...i386] (__gnat_error_handler): Call __gnat_vxsim_error_handler if\n\ton vxsim.\n\t[...i386] (__gnat_install_handler): Test if on vxsim.\n\n2015-05-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Iterator_Specification): For an element\n\titerator over an array, if the component is aliased, the loop\n\tvariable is aliased as well.\n\n2015-05-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb (Expand_Actuals): For a function call with in-out\n\tparameters that is rewritten as an expression_with_actions,\n\twe preserve the original function call node for further use by\n\tthe caller (typically Expand_Call). In the presence of validity\n\tchecks, that function call, though it is labelled Analyzed to\n\tprevent an infinite recursion, may be rewritten as a temporary\n\tby Remove_Side_Effects.  Ensure that the caller has access to\n\tthe original function call to continue expansion.\n\t* atree.ads: Minor typo in comment.\n\n2015-05-26  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_util.adb (Check_Function_Writable_Actuals):\n\tAdd missing support to check the violation of writable actuals\n\tin array aggregates that have a nonstatic range.\n\nFrom-SVN: r223672", "tree": {"sha": "549d728b2d31a9a843361ff2b3f424e4299f4897", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/549d728b2d31a9a843361ff2b3f424e4299f4897"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/comments", "author": null, "committer": null, "parents": [{"sha": "b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73"}], "stats": {"total": 1143, "additions": 858, "deletions": 285}, "files": [{"sha": "124d99793c9a6be4e26a013bda2c63d164294bd1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -1,3 +1,66 @@\n+2015-05-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch7.adb (Install_Private_Declarations,\n+\tSwap_Private_Dependents): Ensure that both views of the dependent\n+\tsubtype are immediately visible if we are within their scope. This\n+\tmay be needed when a procedure body is both the parent of an\n+\tinstantiated child unit, and is itself used to inline a local\n+\tfunction.\n+\n+2015-05-26  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_prag.adb, gnat1drv.adb: Minor reformatting.\n+\n+2015-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Indexed_Component): In the circuit\n+\tdetecting exceptions to the rewriting, deal with implicit\n+\tdereferences in the selected component case.\n+\n+2015-05-26  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_One_Aspect): Do not\n+\trequire the expression of the Disable_Controlled aspect to be\n+\tstatic in a generic template, because 'Enabled is not known\n+\tuntil the instance.\n+\n+2015-05-26  Doug Rupp  <rupp@adacore.com>\n+\n+\t* init-vxsim.c: New file for vxsim ZCX\n+\t* sigtramp-vxworks-vxsim.c: Likewise.\n+\t* sigtramp-vxworks.c: Factor out target dependent bits into ...\n+\t* sigtramp-vxworks-target.inc: ... here.\n+\t* sigtramp.h: Add vxsim zcx protos.\n+\t* init.c [vxworks...] (sysLib.h): Include.\n+\t(__gnat_map_signal): Make global.\n+\t [...i386] (__gnat_error_handler): Call __gnat_vxsim_error_handler if\n+\ton vxsim.\n+\t[...i386] (__gnat_install_handler): Test if on vxsim.\n+\n+2015-05-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): For an element\n+\titerator over an array, if the component is aliased, the loop\n+\tvariable is aliased as well.\n+\n+2015-05-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Actuals): For a function call with in-out\n+\tparameters that is rewritten as an expression_with_actions,\n+\twe preserve the original function call node for further use by\n+\tthe caller (typically Expand_Call). In the presence of validity\n+\tchecks, that function call, though it is labelled Analyzed to\n+\tprevent an infinite recursion, may be rewritten as a temporary\n+\tby Remove_Side_Effects.  Ensure that the caller has access to\n+\tthe original function call to continue expansion.\n+\t* atree.ads: Minor typo in comment.\n+\n+2015-05-26  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_util.adb (Check_Function_Writable_Actuals):\n+\tAdd missing support to check the violation of writable actuals\n+\tin array aggregates that have a nonstatic range.\n+\n 2015-05-26  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch6.adb (Process_Contract_Cases_For): Update the call to"}, {"sha": "155cde3d9472b3f54aba56211c09b3878edc50d0", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -730,7 +730,7 @@ package Atree is\n    -----------------------\n \n    --  Utility functions to test whether an Entity_Kind value, either given\n-   --  directly as the first argument, or the Ekind field of an Entity give\n+   --  directly as the first argument, or the Ekind field of an Entity given\n    --  as the first argument, matches any of the given list of Entity_Kind\n    --  values. Return True if any match, False if no match.\n "}, {"sha": "8e16ca793e3b348a87644217af2235dff010bf8f", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -6299,7 +6299,10 @@ package body Exp_Ch4 is\n \n       --    The prefix of an address or bit or size attribute reference\n \n-      --  The following circuit detects these exceptions\n+      --  The following circuit detects these exceptions. Note that we need to\n+      --  deal with implicit dereferences when climbing up the parent chain,\n+      --  with the additional difficulty that the type of parents may have yet\n+      --  to be resolved since prefixes are usually resolved first.\n \n       declare\n          Child : Node_Id := N;\n@@ -6351,11 +6354,22 @@ package body Exp_Ch4 is\n             then\n                return;\n \n-            elsif Nkind_In (Parnt, N_Indexed_Component, N_Selected_Component)\n+            elsif Nkind (Parnt) = N_Indexed_Component\n+              and then Prefix (Parnt) = Child\n+            then\n+               null;\n+\n+            elsif Nkind (Parnt) = N_Selected_Component\n               and then Prefix (Parnt) = Child\n+              and then not (Present (Etype (Selector_Name (Parnt)))\n+                              and then\n+                            Is_Access_Type (Etype (Selector_Name (Parnt))))\n             then\n                null;\n \n+            --  If the parent is a dereference, either implicit or explicit,\n+            --  then the packed reference needs to be expanded.\n+\n             else\n                Expand_Packed_Element_Reference (N);\n                return;"}, {"sha": "fee1cfc19e5b905e0988fc6b481cbd82d1cf6ed5", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -997,10 +997,6 @@ package body Exp_Ch6 is\n    -- Expand_Actuals --\n    --------------------\n \n-   --------------------\n-   -- Expand_Actuals --\n-   --------------------\n-\n    procedure Expand_Actuals (N : in out Node_Id; Subp : Entity_Id) is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Actual    : Node_Id;\n@@ -2018,9 +2014,12 @@ package body Exp_Ch6 is\n \n                   --  Reset calling argument to point to function call inside\n                   --  the expression with actions so the caller can continue\n-                  --  to process the call.\n+                  --  to process the call. In spite of the fact that it is\n+                  --  marked Analyzed above, it may be rewritten by Remove_\n+                  --  Side_Effects if validity checks are present, so go back\n+                  --  to original call.\n \n-                  N := Name;\n+                  N := Original_Node (Name);\n                end;\n \n             --  If not the special Ada 2012 case of a function call, then"}, {"sha": "4bbfbd4ce1622a1a69202e75964897f511e2eb5a", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -165,7 +165,7 @@ package body Exp_Prag is\n \n    begin\n       --  Rewrite pragma ignored by Ignore_Pragma to null statement, so that\n-      --  the back end or the expander here does not get over-enthusiastic and\n+      --  the back end or the expander here does not get overenthusiastic and\n       --  start processing such a pragma!\n \n       if Get_Name_Table_Boolean3 (Pname) then\n@@ -318,7 +318,7 @@ package body Exp_Prag is\n       end if;\n \n       --  Since this check is active, we rewrite the pragma into a\n-      --  corresponding if statement, and then analyze the statement\n+      --  corresponding if statement, and then analyze the statement.\n \n       --  The normal case expansion transforms:\n "}, {"sha": "70df5633fbf366cd0947bbdef0b4af7372dee6fb", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -205,7 +205,7 @@ procedure Gnat1drv is\n          --  Turn off C tree generation, not compatible with CodePeer mode. We\n          --  do not expect this to happen in normal use, since both modes are\n          --  enabled by special tools, but it is useful to turn off these flags\n-         --  this way when we are doing codepeer tests on existing test suites\n+         --  this way when we are doing CodePeer tests on existing test suites\n          --  that may have -gnatd.V set, to avoid the need for special casing.\n \n          Modify_Tree_For_C := False;"}, {"sha": "f3c05f167b208416d3b2a7c3016ee275b05bed1f", "filename": "gcc/ada/init-vxsim.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Finit-vxsim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Finit-vxsim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit-vxsim.c?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -0,0 +1,67 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                           I N I T - V X S I M                            *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *          Copyright (C) 1992-2015, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ *                                                                          *\n+ * As a special exception under Section 7 of GPL version 3, you are granted *\n+ * additional permissions described in the GCC Runtime Library Exception,   *\n+ * version 3.1, as published by the Free Software Foundation.               *\n+ *                                                                          *\n+ * You should have received a copy of the GNU General Public License and    *\n+ * a copy of the GCC Runtime Library Exception along with this program;     *\n+ * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    *\n+ * <http://www.gnu.org/licenses/>.                                          *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This file is an addition to init.c that must be compiled with the CPU\n+   specified for running under vxsim for x86-vxworks6, as the signal context\n+   structure is different for vxsim vs. real hardware.  */\n+\n+#undef CPU\n+\n+#ifndef __RTP__\n+#define CPU SIMNT\n+#else\n+#define CPU SIMPENTIUM\n+#endif\n+\n+#include \"vxWorks.h\"\n+#include \"tconfig.h\"\n+\n+#include <signal.h>\n+#include <taskLib.h>\n+\n+#ifndef __RTP__\n+#include <intLib.h>\n+#include <iv.h>\n+#endif\n+\n+extern void\n+__gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED,\n+\t\t   void *sc ATTRIBUTE_UNUSED);\n+\n+/* Process the vxsim signal context.  */\n+void\n+__gnat_vxsim_error_handler (int sig, siginfo_t *si, void *sc)\n+{\n+  #include \"sigtramp.h\"\n+\n+  __gnat_sigtramp_vxsim (sig, (void *)si, (void *)sc,\n+\t\t   (__sigtramphandler_t *)&__gnat_map_signal);\n+}"}, {"sha": "4731959b019506b9b7900ee482f27c428d7c022b", "filename": "gcc/ada/init.c", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -1702,6 +1702,7 @@ __gnat_install_handler ()\n \n #include <signal.h>\n #include <taskLib.h>\n+#include <sysLib.h>\n \n #ifndef __RTP__\n #include <intLib.h>\n@@ -1758,8 +1759,8 @@ __gnat_clear_exception_count (void)\n }\n \n /* Handle different SIGnal to exception mappings in different VxWorks\n-   versions.   */\n-static void\n+   versions.  */\n+void\n __gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED,\n \t\t   void *sc ATTRIBUTE_UNUSED)\n {\n@@ -1895,6 +1896,13 @@ __gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED,\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n+#if defined (i386) || defined (__i386__)\n+extern void\n+__gnat_vxsim_error_handler (int sig, siginfo_t *si, void *sc);\n+\n+static int is_vxsim = 0;\n+#endif\n+\n /* Tasking and Non-tasking signal handler.  Map SIGnal to Ada exception\n    propagation after the required low level adjustments.  */\n \n@@ -1911,14 +1919,22 @@ __gnat_error_handler (int sig, siginfo_t *si, void *sc)\n   sigdelset (&mask, sig);\n   sigprocmask (SIG_SETMASK, &mask, NULL);\n \n-#if defined (__ARMEL__) || defined (__PPC__)\n-  /* On ARM and PowerPC, kernel mode, we process signals through a Call Frame\n+#if defined (__ARMEL__) || defined (__PPC__) || defined (i386) || defined (__i386__)\n+  /* On certain targets, kernel mode, we process signals through a Call Frame\n      Info trampoline, voiding the need for myriads of fallback_frame_state\n      variants in the ZCX runtime.  We have no simple way to distinguish ZCX\n      from SJLJ here, so we do this for SJLJ as well even though this is not\n      necessary.  This only incurs a few extra instructions and a tiny\n      amount of extra stack usage.  */\n \n+#if defined (i386) || defined (__i386__)\n+   /* On x86, the vxsim signal context is subtly different and is processeed\n+      by a handler compiled especially for vxsim.  */\n+\n+  if (is_vxsim)\n+    __gnat_vxsim_error_handler (sig, si, sc);\n+#endif\n+\n   #include \"sigtramp.h\"\n \n   __gnat_sigtramp (sig, (void *)si, (void *)sc,\n@@ -1952,6 +1968,7 @@ void\n __gnat_install_handler (void)\n {\n   struct sigaction act;\n+  char *model ATTRIBUTE_UNUSED;\n \n   /* Setup signal handler to map synchronous signals to appropriate\n      exceptions.  Make sure that the handler isn't interrupted by another\n@@ -2002,6 +2019,15 @@ __gnat_install_handler (void)\n   trap_0_entry->inst_fourth = 0xa1480000;\n #endif\n \n+#if defined (i386) || defined (__i386__)\n+  /*  By experiment, found that sysModel () returns the following string\n+      prefix for vxsim when running on Linux and Windows.  */\n+  model = sysModel ();\n+  if ((strncmp (model, \"Linux\", 5) == 0)\n+      || (strncmp (model, \"Windows\", 7) == 0))\n+    is_vxsim = 1;\n+#endif\n+\n   __gnat_handler_installed = 1;\n }\n "}, {"sha": "8e1dcc13d2ba45055daa6ad68a9dfb5b7173754f", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -3156,10 +3156,20 @@ package body Sem_Ch13 is\n                         goto Continue;\n                      end if;\n \n-                     if not Present (Expr)\n-                       or else Is_True (Static_Boolean (Expr))\n-                     then\n-                        Set_Disable_Controlled (E);\n+                     Analyze_And_Resolve (Expr, Standard_Boolean);\n+\n+                     --  If we're in a generic template, we don't want to try\n+                     --  to disable controlled types, because typical usage is\n+                     --  \"Disable_Controlled => not <some_check>'Enabled\", and\n+                     --  the value of Enabled is not known until we see a\n+                     --  particular instance.\n+\n+                     if Expander_Active then\n+                        if not Present (Expr)\n+                          or else Is_True (Static_Boolean (Expr))\n+                        then\n+                           Set_Disable_Controlled (E);\n+                        end if;\n                      end if;\n \n                      goto Continue;"}, {"sha": "c2cefd1facc016a3295751ccd402ffd9f8449a67", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -2010,6 +2010,11 @@ package body Sem_Ch5 is\n          if Of_Present (N) then\n             Set_Etype (Def_Id, Component_Type (Typ));\n \n+            --  The loop variable is aliased if the array components are\n+            --  aliased.\n+\n+            Set_Is_Aliased (Def_Id, Has_Aliased_Components (Typ));\n+\n             --  AI12-0151 stipulates that the container cannot be a component\n             --  that depends on a discriminant if the enclosing object is\n             --  mutable, to prevent a modification of the container in the"}, {"sha": "ada3a2be85f4877da4e0dd0b3e7040902a2804a6", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -2221,9 +2221,16 @@ package body Sem_Ch7 is\n                --  swap them out in End_Package_Scope.\n \n                Replace_Elmt (Priv_Elmt, Full_View (Priv));\n+\n+               --  Ensure that both views of the dependent private subtype are\n+               --  immediately visible if within some open scope.\n+\n+               if In_Open_Scopes (Scope (Full_View (Priv))) then\n+                  Set_Is_Immediately_Visible (Priv);\n+                  Set_Is_Immediately_Visible (Full_View (Priv));\n+               end if;\n+\n                Exchange_Declarations (Priv);\n-               Set_Is_Immediately_Visible\n-                 (Priv, In_Open_Scopes (Scope (Priv)));\n                Set_Is_Potentially_Use_Visible\n                  (Priv, Is_Potentially_Use_Visible (Node (Priv_Elmt)));\n "}, {"sha": "61524cc4fcdd7bbdd95c4029ec54ec01f63ae799", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -2062,6 +2062,7 @@ package body Sem_Util is\n    procedure Check_Function_Writable_Actuals (N : Node_Id) is\n       Writable_Actuals_List : Elist_Id := No_Elist;\n       Identifiers_List      : Elist_Id := No_Elist;\n+      Aggr_Error_Node       : Node_Id  := Empty;\n       Error_Node            : Node_Id  := Empty;\n \n       procedure Collect_Identifiers (N : Node_Id);\n@@ -2119,6 +2120,14 @@ package body Sem_Util is\n                then\n                   return Skip;\n \n+               --  For rewriten nodes we continue the traversal in the original\n+               --  subtree. Needed to handle in aggregates original expressions\n+               --  extracted from the tree by Remove_Side_Effects.\n+\n+               elsif Is_Rewrite_Substitution (N) then\n+                  Collect_Identifiers (Original_Node (N));\n+                  return Skip;\n+\n                --  For now we skip aggregate discriminants, since they require\n                --  performing the analysis in two phases to identify conflicts:\n                --  first one analyzing discriminants and second one analyzing\n@@ -2600,6 +2609,75 @@ package body Sem_Util is\n                         end if;\n                      end if;\n                   end;\n+\n+               --  For an array aggregate a discrete_choice_list that has a\n+               --  nonstatic range, is considered as two or more separate\n+               --  occurrences of the expression (RM 6.20/3)\n+\n+               elsif Is_Array_Type (Etype (N))\n+                 and then Nkind (N) = N_Aggregate\n+                 and then Present (Aggregate_Bounds (N))\n+                 and then not Compile_Time_Known_Bounds (Etype (N))\n+               then\n+                  --  Collect identifiers found in the dynamic bounds\n+\n+                  declare\n+                     Count_Components : Natural := 0;\n+                     Low, High        : Node_Id;\n+\n+                  begin\n+                     Assoc := First (Component_Associations (N));\n+                     while Present (Assoc) loop\n+                        Choice := First (Choices (Assoc));\n+                        while Present (Choice) loop\n+                           if Nkind_In (Choice, N_Range,\n+                                                   N_Subtype_Indication)\n+                             or else (Is_Entity_Name (Choice)\n+                                       and then Is_Type (Entity (Choice)))\n+                           then\n+                              Get_Index_Bounds (Choice, Low, High);\n+\n+                              if not Compile_Time_Known_Value (Low) then\n+                                 Collect_Identifiers (Low);\n+\n+                                 if No (Aggr_Error_Node) then\n+                                    Aggr_Error_Node := Low;\n+                                 end if;\n+                              end if;\n+\n+                              if not Compile_Time_Known_Value (High) then\n+                                 Collect_Identifiers (High);\n+\n+                                 if No (Aggr_Error_Node) then\n+                                    Aggr_Error_Node := High;\n+                                 end if;\n+                              end if;\n+\n+                           --  For the purposes of this check it is enough to\n+                           --  consider that we cover a single component since\n+                           --  since the RM rule is violated as far as I find\n+                           --  more than one component.\n+\n+                           else\n+                              Count_Components := Count_Components + 1;\n+\n+                              if No (Aggr_Error_Node)\n+                                and then Count_Components > 1\n+                              then\n+                                 Aggr_Error_Node := Choice;\n+                              end if;\n+\n+                              if not Compile_Time_Known_Value (Choice) then\n+                                 Collect_Identifiers (Choice);\n+                              end if;\n+                           end if;\n+\n+                           Next (Choice);\n+                        end loop;\n+\n+                        Next (Assoc);\n+                     end loop;\n+                  end;\n                end if;\n \n                --  Handle ancestor part of extension aggregates\n@@ -2679,6 +2757,18 @@ package body Sem_Util is\n          return;\n       end if;\n \n+      --  Check violation of RM 6.20/3 in aggregates\n+\n+      if Present (Aggr_Error_Node)\n+        and then Writable_Actuals_List /= No_Elist\n+      then\n+         Error_Msg_N\n+           (\"value may be affected by call in other component because they \"\n+            & \"are evaluated in unspecified order\",\n+            Node (First_Elmt (Writable_Actuals_List)));\n+         return;\n+      end if;\n+\n       --  Check if some writable argument of a function is referenced\n \n       if Writable_Actuals_List /= No_Elist"}, {"sha": "c89ece0cf0e57f60319e1c84d7c2ac6257c3c87a", "filename": "gcc/ada/sigtramp-vxworks-target.inc", "status": "added", "additions": 399, "deletions": 0, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsigtramp-vxworks-target.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsigtramp-vxworks-target.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-vxworks-target.inc?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -0,0 +1,399 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                      S I G T R A M P - T A R G E T                       *\n+ *                                                                          *\n+ *                     Asm Implementation Include File                      *\n+ *                                                                          *\n+ *         Copyright (C) 2011-2015, Free Software Foundation, Inc.          *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ *                                                                          *\n+ * As a special exception under Section 7 of GPL version 3, you are granted *\n+ * additional permissions described in the GCC Runtime Library Exception,   *\n+ * version 3.1, as published by the Free Software Foundation.               *\n+ *                                                                          *\n+ * In particular,  you can freely  distribute your programs  built with the *\n+ * GNAT Pro compiler, including any required library run-time units,  using *\n+ * any licensing terms  of your choosing.  See the AdaCore Software License *\n+ * for full details.                                                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/***************************************************************\n+ * VxWorks target specific part of the __gnat_sigtramp service *\n+ ***************************************************************/\n+\n+/* Note: This target specific part is kept in a separate file to avoid\n+   duplication of its code for the vxworks and vxworks-vxsim asm\n+   implementation files.  */\n+\n+/* ---------------------------\n+   -- And now the asm stubs --\n+   ---------------------------\n+\n+   They all have a common structure with blocks of asm sequences queued one\n+   after the others.  Typically:\n+\n+   SYMBOL_START\n+\n+   CFI_DIRECTIVES\n+     CFI_DEF_CFA,\n+     CFI_COMMON_REGISTERS,\n+     ...\n+\n+   STUB_BODY\n+     asm code to establish frame, setup the cfa reg value,\n+     call the real signal handler, ...\n+\n+   SYMBOL_END\n+*/\n+\n+/*--------------------------------\n+  -- Misc constants and helpers --\n+  -------------------------------- */\n+\n+/* asm string construction helpers.  */\n+\n+#define STR(TEXT) #TEXT\n+/* stringify expanded TEXT, surrounding it with double quotes.  */\n+\n+#define S(E) STR(E)\n+/* stringify E, which will resolve as text but may contain macros\n+   still to be expanded.  */\n+\n+/* asm (TEXT) outputs <tab>TEXT. These facilitate the output of\n+   multine contents:  */\n+#define TAB(S) \"\\t\" S\n+#define CR(S)  S \"\\n\"\n+\n+#undef TCR\n+#define TCR(S) TAB(CR(S))\n+\n+/* REGNO constants, dwarf column numbers for registers of interest.  */\n+\n+#if defined (__PPC__)\n+\n+#define REGNO_LR  65\n+#define REGNO_CTR 66\n+#define REGNO_CR  70\n+#define REGNO_XER 76\n+#define REGNO_GR(N) (N)\n+\n+#define REGNO_PC  67  /* ARG_POINTER_REGNUM  */\n+\n+#define FUNCTION \"@function\"\n+\n+#elif defined (__ARMEL__)\n+\n+#define REGNO_G_REG_OFFSET(N) (N)\n+\n+#define REGNO_PC_OFFSET  15  /* PC_REGNUM  */\n+\n+#define FUNCTION \"%function\"\n+\n+#elif defined (i386)\n+\n+/* These are the cfi colunm numbers */\n+\n+#define REGNO_EDI 7\n+#define REGNO_ESI 6\n+#define REGNO_EBP 5\n+#define REGNO_ESP 4\n+#define REGNO_EBX 3\n+#define REGNO_EDX 2\n+#define REGNO_ECX 1\n+#define REGNO_EAX 0\n+#define REGNO_EFLAGS 9\n+#define REGNO_SET_PC 8 /* aka %eip */\n+\n+#define FUNCTION \"@function\"\n+\n+/* Mapping of CFI Column, Gcc Regno, Signal context offset for 32bit\n+\n+   Name\t   CFI\t   GCC\t   SCTX\n+   %eax\t    0\t    0\t    7\n+   %ecx\t    1\t    2\t    6\n+   %edx\t    2\t    1\t    5\n+   %ebx     3\t    3\t    4\n+   %esp\t    4\t    7\t    3\n+   %ebp\t    5\t    6\t    2\n+   %esi\t    6\t    4\t    1\n+   %edi\t    7\t    5\t    0\n+   %eflags  9\t   17 \t    8\n+   %eip\t    8\t  n/a\t    9\n+\n+\n+   In general:\n+   There is no unique numbering for the x86 architecture.  It's parameterized\n+   by DWARF_FRAME_REGNUM, which is DBX_REGISTER_NUMBER except for Windows, and\n+   the latter depends on the platform.\n+*/\n+\n+#else\n+Not_implemented;\n+#endif /* REGNO constants */\n+\n+\n+/*------------------------------\n+  -- Stub construction blocks --\n+  ------------------------------ */\n+\n+/* CFA setup block\n+   ---------------\n+   Only non-volatile registers are suitable for a CFA base. These are the\n+   only ones we can expect to be able retrieve from the unwinding context\n+   while walking up the chain, saved by at least the bottom-most exception\n+   propagation services.  We set a non-volatile register to the value we\n+   need in the stub body that follows.  */\n+\n+#if defined (__PPC__)\n+\n+/* Use r15 for PPC.  Note that r14 is inappropriate here, even though it\n+   is non-volatile according to the ABI, because GCC uses it as an extra\n+   SCRATCH on SPE targets.  */\n+\n+#define CFA_REG 15\n+\n+#elif defined (__ARMEL__)\n+\n+/* Use r8 for ARM.  Any of r4-r8 should work.  */\n+\n+#define CFA_REG 8\n+\n+#elif defined (i386)\n+\n+#define CFA_REG 7\n+\n+#else\n+Not_implemented;\n+#endif /* CFA setup block */\n+\n+#define CFI_DEF_CFA \\\n+CR(\".cfi_def_cfa \" S(CFA_REG) \", 0\")\n+\n+/* Register location blocks\n+   ------------------------\n+   Rules to find registers of interest from the CFA. This should comprise\n+   all the non-volatile registers relevant to the interrupted context.\n+\n+   Note that we include r1 in this set, unlike the libgcc unwinding\n+   fallbacks.  This is useful for fallbacks to allow the use of r1 in CFI\n+   expressions and the absence of rule for r1 gets compensated by using the\n+   target CFA instead.  We don't need the expression facility here and\n+   setup a fake CFA to allow very simple offset expressions, so having a\n+   rule for r1 is the proper thing to do.  We for sure have observed\n+   crashes in some cases without it.  */\n+\n+#if defined (__PPC__)\n+\n+#define COMMON_CFI(REG) \\\n+  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_SET_##REG)\n+\n+#define CFI_COMMON_REGS \\\n+CR(\"# CFI for common registers\\n\") \\\n+TCR(COMMON_CFI(GR(0)))  \\\n+TCR(COMMON_CFI(GR(1)))  \\\n+TCR(COMMON_CFI(GR(2)))  \\\n+TCR(COMMON_CFI(GR(3)))  \\\n+TCR(COMMON_CFI(GR(4)))  \\\n+TCR(COMMON_CFI(GR(5)))  \\\n+TCR(COMMON_CFI(GR(6)))  \\\n+TCR(COMMON_CFI(GR(7)))  \\\n+TCR(COMMON_CFI(GR(8)))  \\\n+TCR(COMMON_CFI(GR(9)))  \\\n+TCR(COMMON_CFI(GR(10)))  \\\n+TCR(COMMON_CFI(GR(11)))  \\\n+TCR(COMMON_CFI(GR(12)))  \\\n+TCR(COMMON_CFI(GR(13)))  \\\n+TCR(COMMON_CFI(GR(14))) \\\n+TCR(COMMON_CFI(GR(15))) \\\n+TCR(COMMON_CFI(GR(16))) \\\n+TCR(COMMON_CFI(GR(17))) \\\n+TCR(COMMON_CFI(GR(18))) \\\n+TCR(COMMON_CFI(GR(19))) \\\n+TCR(COMMON_CFI(GR(20))) \\\n+TCR(COMMON_CFI(GR(21))) \\\n+TCR(COMMON_CFI(GR(22))) \\\n+TCR(COMMON_CFI(GR(23))) \\\n+TCR(COMMON_CFI(GR(24))) \\\n+TCR(COMMON_CFI(GR(25))) \\\n+TCR(COMMON_CFI(GR(26))) \\\n+TCR(COMMON_CFI(GR(27))) \\\n+TCR(COMMON_CFI(GR(28))) \\\n+TCR(COMMON_CFI(GR(29))) \\\n+TCR(COMMON_CFI(GR(30))) \\\n+TCR(COMMON_CFI(GR(31))) \\\n+TCR(COMMON_CFI(LR)) \\\n+TCR(COMMON_CFI(CR)) \\\n+TCR(COMMON_CFI(CTR)) \\\n+TCR(COMMON_CFI(XER)) \\\n+TCR(COMMON_CFI(PC)) \\\n+TCR(\".cfi_return_column \" S(REGNO_PC))\n+\n+/* Trampoline body block\n+   ---------------------  */\n+\n+#define SIGTRAMP_BODY \\\n+CR(\"\") \\\n+TCR(\"# Allocate frame and save the non-volatile\") \\\n+TCR(\"# registers we're going to modify\") \\\n+TCR(\"stwu %r1,-16(%r1)\")  \\\n+TCR(\"mflr %r0\")\t\\\n+TCR(\"stw %r0,20(%r1)\")\t\\\n+TCR(\"stw %r\" S(CFA_REG) \",8(%r1)\")\t\\\n+TCR(\"\")\t\t\t\\\n+TCR(\"# Setup CFA_REG = context, which we'll retrieve as our CFA value\") \\\n+TCR(\"mr %r\" S(CFA_REG) \", %r7\") \\\n+TCR(\"\")\t\t\t\\\n+TCR(\"# Call the real handler. The signo, siginfo and sigcontext\") \\\n+TCR(\"# arguments are the same as those we received in r3, r4 and r5\") \\\n+TCR(\"mtctr %r6\") \\\n+TCR(\"bctrl\")\t\\\n+TCR(\"\")\t\t\\\n+TCR(\"# Restore our callee-saved items, release our frame and return\") \\\n+TCR(\"lwz %r\" S(CFA_REG) \",8(%r1)\")\t\\\n+TCR(\"lwz %r0,20(%r1)\")\t\\\n+TCR(\"mtlr %r0\")\t\t\\\n+TCR(\"\")\t\t\t\\\n+TCR(\"addi %r1,%r1,16\")\t\\\n+TCR(\"blr\")\n+\n+#elif defined (__ARMEL__)\n+\n+#define COMMON_CFI(REG) \\\n+  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_SET_##REG)\n+\n+#define CFI_COMMON_REGS \\\n+CR(\"# CFI for common registers\\n\") \\\n+TCR(COMMON_CFI(G_REG_OFFSET(0)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(1)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(2)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(3)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(4)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(5)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(6)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(7)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(8)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(9)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(10)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(11)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(12)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(13)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(14))) \\\n+TCR(COMMON_CFI(PC_OFFSET)) \\\n+TCR(\".cfi_return_column \" S(REGNO_PC_OFFSET))\n+\n+/* Trampoline body block\n+   ---------------------  */\n+\n+#define SIGTRAMP_BODY \\\n+CR(\"\") \\\n+TCR(\"# Allocate frame and save the non-volatile\") \\\n+TCR(\"# registers we're going to modify\") \\\n+TCR(\"mov\tip, sp\") \\\n+TCR(\"stmfd\tsp!, {r\"S(CFA_REG)\", fp, ip, lr, pc}\") \\\n+TCR(\"# Setup CFA_REG = context, which we'll retrieve as our CFA value\") \\\n+TCR(\"ldr\tr\"S(CFA_REG)\", [ip]\") \\\n+TCR(\"\")                 \\\n+TCR(\"# Call the real handler. The signo, siginfo and sigcontext\") \\\n+TCR(\"# arguments are the same as those we received in r0, r1 and r2\") \\\n+TCR(\"sub\tfp, ip, #4\") \\\n+TCR(\"blx\tr3\") \\\n+TCR(\"# Restore our callee-saved items, release our frame and return\") \\\n+TCR(\"ldmfd\tsp, {r\"S(CFA_REG)\", fp, sp, pc}\")\n+\n+#elif defined (i386)\n+\n+#if CPU == SIMNT || CPU == SIMPENTIUM\n+#define COMMON_CFI(REG) \\\n+  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_SET_##REG)\n+#else\n+#define COMMON_CFI(REG) \\\n+  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_##REG)\n+#endif\n+\n+#define PC_CFI(REG) \\\n+  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_##REG)\n+\n+#define CFI_COMMON_REGS \\\n+CR(\"# CFI for common registers\\n\") \\\n+TCR(COMMON_CFI(EDI)) \\\n+TCR(COMMON_CFI(ESI)) \\\n+TCR(COMMON_CFI(EBP)) \\\n+TCR(COMMON_CFI(ESP)) \\\n+TCR(COMMON_CFI(EBX)) \\\n+TCR(COMMON_CFI(EDX)) \\\n+TCR(COMMON_CFI(ECX)) \\\n+TCR(COMMON_CFI(EAX)) \\\n+TCR(COMMON_CFI(EFLAGS)) \\\n+TCR(PC_CFI(SET_PC)) \\\n+TCR(\".cfi_return_column \" S(REGNO_SET_PC))\n+\n+/* Trampoline body block\n+   ---------------------  */\n+\n+#define SIGTRAMP_BODY \\\n+CR(\"\") \\\n+TCR(\"# Allocate frame and save the non-volatile\") \\\n+TCR(\"# registers we're going to modify\") \\\n+TCR(\"pushl\t%ebp\") \\\n+TCR(\"movl\t%esp, %ebp\") \\\n+TCR(\"pushl\t%edi\") \\\n+TCR(\"subl\t$24, %esp\") \\\n+TCR(\"# Setup CFA_REG = context, which we'll retrieve as our CFA value\") \\\n+TCR(\"movl\t24(%ebp), %edi\") \\\n+TCR(\"# Call the real handler. The signo, siginfo and sigcontext\") \\\n+TCR(\"# arguments are the same as those we received\") \\\n+TCR(\"movl\t16(%ebp), %eax\") \\\n+TCR(\"movl\t%eax, 8(%esp)\") \\\n+TCR(\"movl\t12(%ebp), %eax\") \\\n+TCR(\"movl\t%eax, 4(%esp)\") \\\n+TCR(\"movl\t8(%ebp), %eax\") \\\n+TCR(\"movl\t%eax, (%esp)\") \\\n+TCR(\"call\t*20(%ebp)\") \\\n+TCR(\"# Restore our callee-saved items, release our frame and return\") \\\n+TCR(\"popl\t%edi\") \\\n+TCR(\"leave\") \\\n+TCR(\"ret\")\n+\n+#else\n+Not_implemented;\n+#endif /* CFI_COMMON_REGS and SIGTRAMP_BODY */\n+\n+/* Symbol definition block\n+   -----------------------  */\n+\n+#define SIGTRAMP_START(SYM) \\\n+CR(\"# \" S(SYM) \" cfi trampoline\") \\\n+TCR(\".type \" S(SYM) \", \"FUNCTION) \\\n+CR(\"\") \\\n+CR(S(SYM) \":\") \\\n+TCR(\".cfi_startproc\") \\\n+TCR(\".cfi_signal_frame\")\n+\n+/* Symbol termination block\n+   ------------------------  */\n+\n+#define SIGTRAMP_END(SYM) \\\n+CR(\".cfi_endproc\") \\\n+TCR(\".size \" S(SYM) \", .-\" S(SYM))\n+\n+/*----------------------------\n+  -- And now, the real code --\n+  ---------------------------- */\n+\n+/* Text section start.  The compiler isn't aware of that switch.  */\n+\n+asm (\".text\\n\"\n+     TCR(\".align 2\"));\n+"}, {"sha": "7e9f2b8aa817fa4611e7b4625f0e2ba84f18ffd8", "filename": "gcc/ada/sigtramp-vxworks-vxsim.c", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsigtramp-vxworks-vxsim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsigtramp-vxworks-vxsim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-vxworks-vxsim.c?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -0,0 +1,146 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             S I G T R A M P                              *\n+ *                                                                          *\n+ *                         Asm Implementation File                          *\n+ *                                                                          *\n+ *         Copyright (C) 2011-2015, Free Software Foundation, Inc.          *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ *                                                                          *\n+ * As a special exception under Section 7 of GPL version 3, you are granted *\n+ * additional permissions described in the GCC Runtime Library Exception,   *\n+ * version 3.1, as published by the Free Software Foundation.               *\n+ *                                                                          *\n+ * In particular,  you can freely  distribute your programs  built with the *\n+ * GNAT Pro compiler, including any required library run-time units,  using *\n+ * any licensing terms  of your choosing.  See the AdaCore Software License *\n+ * for full details.                                                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/********************************************************\n+ * VxWorks VXSIM version of the __gnat_sigtramp service *\n+ ********************************************************/\n+\n+#undef CPU\n+\n+#ifndef __RTP__\n+#define CPU SIMNT\n+#else\n+#define CPU SIMPENTIUM\n+#endif\n+\n+#include \"sigtramp.h\"\n+/* See sigtramp.h for a general explanation of functionality.  */\n+\n+#include <vxWorks.h>\n+#include <arch/../regs.h>\n+#ifndef __RTP__\n+#include <sigLib.h>\n+#else\n+#include <signal.h>\n+#include <regs.h>\n+\n+typedef struct mcontext\n+  {\n+    REG_SET     regs;\n+  } mcontext_t;\n+\n+typedef struct ucontext\n+  {\n+    mcontext_t          uc_mcontext;    /* register set */\n+    struct ucontext *   uc_link;        /* not used */\n+    sigset_t            uc_sigmask;     /* set of signals blocked */\n+    stack_t             uc_stack;       /* stack of context signaled */\n+  } ucontext_t;\n+#endif\n+\n+/* ----------------------\n+   -- General comments --\n+   ----------------------\n+\n+   Stubs are generated from toplevel asms and .cfi directives, much simpler\n+   to use and check for correctness than manual encodings of CFI byte\n+   sequences.  The general idea is to establish CFA as sigcontext->sc_pregs\n+   (for DKM) and mcontext (for RTP) and state where to find the registers as\n+   offsets from there.\n+\n+   As of today, we support a stub providing CFI info for common\n+   registers (GPRs, LR, ...). We might need variants with support for floating\n+   point or altivec registers as well at some point.\n+\n+   Checking which variant should apply and getting at sc_pregs / mcontext\n+   is simpler to express in C (we can't use offsetof in toplevel asms and\n+   hardcoding constants is not workable with the flurry of VxWorks variants),\n+   so this is the choice for our toplevel interface.\n+\n+   Note that the registers we \"restore\" here are those to which we have\n+   direct access through the system sigcontext structure, which includes\n+   only a partial set of the non-volatiles ABI-wise.  */\n+\n+/* -------------------------------------------\n+   -- Prototypes for our internal asm stubs --\n+   -------------------------------------------\n+\n+   Eventhough our symbols will remain local, the prototype claims \"extern\"\n+   and not \"static\" to prevent compiler complaints about a symbol used but\n+   never defined.  */\n+\n+/* sigtramp stub providing CFI info for common registers.  */\n+\n+extern void __gnat_sigtramp_vxsim_common\n+(int signo, void *siginfo, void *sigcontext,\n+ __sigtramphandler_t * handler, void * sc_pregs);\n+\n+\n+/* -------------------------------------\n+   -- Common interface implementation --\n+   -------------------------------------\n+\n+   We enforce optimization to minimize the overhead of the extra layer.  */\n+\n+void __gnat_sigtramp_vxsim (int signo, void *si, void *sc,\n+\t\t      __sigtramphandler_t * handler)\n+     __attribute__((optimize(2)));\n+\n+void __gnat_sigtramp_vxsim (int signo, void *si, void *sc,\n+\t\t      __sigtramphandler_t * handler)\n+{\n+#ifdef __RTP__\n+  mcontext_t *mcontext = &((ucontext_t *) sc)->uc_mcontext;\n+\n+  /* Pass MCONTEXT in the fifth position so that the assembly code can find\n+     it at the same stack location or in the same register as SC_PREGS.  */\n+  __gnat_sigtramp_vxsim_common (signo, si, mcontext, handler, mcontext);\n+#else\n+  struct sigcontext * sctx = (struct sigcontext *) sc;\n+\n+  __gnat_sigtramp_vxsim_common (signo, si, sctx, handler, sctx->sc_pregs);\n+#endif\n+}\n+\n+/* Include the target specific bits.  */\n+#include \"sigtramp-vxworks-target.inc\"\n+\n+/* sigtramp stub for common registers.  */\n+\n+#define TRAMP_COMMON __gnat_sigtramp_vxsim_common\n+\n+asm (SIGTRAMP_START(TRAMP_COMMON));\n+asm (CFI_DEF_CFA);\n+asm (CFI_COMMON_REGS);\n+asm (SIGTRAMP_BODY);\n+asm (SIGTRAMP_END(TRAMP_COMMON));\n+\n+"}, {"sha": "360b9211453ab5eee62a2d2b70f7268f688d0521", "filename": "gcc/ada/sigtramp-vxworks.c", "status": "modified", "additions": 3, "deletions": 262, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsigtramp-vxworks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsigtramp-vxworks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-vxworks.c?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                         Asm Implementation File                          *\n  *                                                                          *\n- *         Copyright (C) 2011-2014, Free Software Foundation, Inc.          *\n+ *         Copyright (C) 2011-2015, Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -122,267 +122,8 @@ void __gnat_sigtramp (int signo, void *si, void *sc,\n #endif\n }\n \n-\n-/* ---------------------------\n-   -- And now the asm stubs --\n-   ---------------------------\n-\n-   They all have a common structure with blocks of asm sequences queued one\n-   after the others.  Typically:\n-\n-   SYMBOL_START\n-\n-   CFI_DIRECTIVES\n-     CFI_DEF_CFA,\n-     CFI_COMMON_REGISTERS,\n-     ...\n-\n-   STUB_BODY\n-     asm code to establish frame, setup the cfa reg value,\n-     call the real signal handler, ...\n-\n-   SYMBOL_END\n-*/\n-\n-/*--------------------------------\n-  -- Misc constants and helpers --\n-  -------------------------------- */\n-\n-/* asm string construction helpers.  */\n-\n-#define STR(TEXT) #TEXT\n-/* stringify expanded TEXT, surrounding it with double quotes.  */\n-\n-#define S(E) STR(E)\n-/* stringify E, which will resolve as text but may contain macros\n-   still to be expanded.  */\n-\n-/* asm (TEXT) outputs <tab>TEXT. These facilitate the output of\n-   multine contents:  */\n-#define TAB(S) \"\\t\" S\n-#define CR(S)  S \"\\n\"\n-\n-#undef TCR\n-#define TCR(S) TAB(CR(S))\n-\n-/* REGNO constants, dwarf column numbers for registers of interest.  */\n-\n-#if defined (__PPC__)\n-\n-#define REGNO_LR  65\n-#define REGNO_CTR 66\n-#define REGNO_CR  70\n-#define REGNO_XER 76\n-#define REGNO_GR(N) (N)\n-\n-#define REGNO_PC  67  /* ARG_POINTER_REGNUM  */\n-\n-#define FUNCTION \"@function\"\n-\n-#elif defined (__ARMEL__)\n-\n-#define REGNO_G_REG_OFFSET(N) (N)\n-\n-#define REGNO_PC_OFFSET  15  /* PC_REGNUM  */\n-\n-#define FUNCTION \"%function\"\n-\n-#else\n-Not_implemented;\n-#endif /* REGNO constants */\n-\n-\n-/*------------------------------\n-  -- Stub construction blocks --\n-  ------------------------------ */\n-\n-/* CFA setup block\n-   ---------------\n-   Only non-volatile registers are suitable for a CFA base. These are the\n-   only ones we can expect to be able retrieve from the unwinding context\n-   while walking up the chain, saved by at least the bottom-most exception\n-   propagation services.  We set a non-volatile register to the value we\n-   need in the stub body that follows.  */\n-\n-#if defined (__PPC__)\n-\n-/* Use r15 for PPC.  Note that r14 is inappropriate here, even though it\n-   is non-volatile according to the ABI, because GCC uses it as an extra\n-   SCRATCH on SPE targets.  */\n-\n-#define CFA_REG 15\n-\n-#elif defined (__ARMEL__)\n-\n-/* Use r8 for ARM.  Any of r4-r8 should work.  */\n-\n-#define CFA_REG 8\n-\n-#else\n-Not_implemented;\n-#endif /* CFA setup block */\n-\n-#define CFI_DEF_CFA \\\n-CR(\".cfi_def_cfa \" S(CFA_REG) \", 0\")\n-\n-/* Register location blocks\n-   ------------------------\n-   Rules to find registers of interest from the CFA. This should comprise\n-   all the non-volatile registers relevant to the interrupted context.\n-\n-   Note that we include r1 in this set, unlike the libgcc unwinding\n-   fallbacks.  This is useful for fallbacks to allow the use of r1 in CFI\n-   expressions and the absence of rule for r1 gets compensated by using the\n-   target CFA instead.  We don't need the expression facility here and\n-   setup a fake CFA to allow very simple offset expressions, so having a\n-   rule for r1 is the proper thing to do.  We for sure have observed\n-   crashes in some cases without it.  */\n-\n-#define COMMON_CFI(REG) \\\n-  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_SET_##REG)\n-\n-#if defined (__PPC__)\n-\n-#define CFI_COMMON_REGS \\\n-CR(\"# CFI for common registers\\n\") \\\n-TCR(COMMON_CFI(GR(0)))  \\\n-TCR(COMMON_CFI(GR(1)))  \\\n-TCR(COMMON_CFI(GR(2)))  \\\n-TCR(COMMON_CFI(GR(3)))  \\\n-TCR(COMMON_CFI(GR(4)))  \\\n-TCR(COMMON_CFI(GR(5)))  \\\n-TCR(COMMON_CFI(GR(6)))  \\\n-TCR(COMMON_CFI(GR(7)))  \\\n-TCR(COMMON_CFI(GR(8)))  \\\n-TCR(COMMON_CFI(GR(9)))  \\\n-TCR(COMMON_CFI(GR(10)))  \\\n-TCR(COMMON_CFI(GR(11)))  \\\n-TCR(COMMON_CFI(GR(12)))  \\\n-TCR(COMMON_CFI(GR(13)))  \\\n-TCR(COMMON_CFI(GR(14))) \\\n-TCR(COMMON_CFI(GR(15))) \\\n-TCR(COMMON_CFI(GR(16))) \\\n-TCR(COMMON_CFI(GR(17))) \\\n-TCR(COMMON_CFI(GR(18))) \\\n-TCR(COMMON_CFI(GR(19))) \\\n-TCR(COMMON_CFI(GR(20))) \\\n-TCR(COMMON_CFI(GR(21))) \\\n-TCR(COMMON_CFI(GR(22))) \\\n-TCR(COMMON_CFI(GR(23))) \\\n-TCR(COMMON_CFI(GR(24))) \\\n-TCR(COMMON_CFI(GR(25))) \\\n-TCR(COMMON_CFI(GR(26))) \\\n-TCR(COMMON_CFI(GR(27))) \\\n-TCR(COMMON_CFI(GR(28))) \\\n-TCR(COMMON_CFI(GR(29))) \\\n-TCR(COMMON_CFI(GR(30))) \\\n-TCR(COMMON_CFI(GR(31))) \\\n-TCR(COMMON_CFI(LR)) \\\n-TCR(COMMON_CFI(CR)) \\\n-TCR(COMMON_CFI(CTR)) \\\n-TCR(COMMON_CFI(XER)) \\\n-TCR(COMMON_CFI(PC)) \\\n-TCR(\".cfi_return_column \" S(REGNO_PC))\n-\n-/* Trampoline body block\n-   ---------------------  */\n-\n-#define SIGTRAMP_BODY \\\n-CR(\"\") \\\n-TCR(\"# Allocate frame and save the non-volatile\") \\\n-TCR(\"# registers we're going to modify\") \\\n-TCR(\"stwu %r1,-16(%r1)\")  \\\n-TCR(\"mflr %r0\")\t\\\n-TCR(\"stw %r0,20(%r1)\")\t\\\n-TCR(\"stw %r\" S(CFA_REG) \",8(%r1)\")\t\\\n-TCR(\"\")\t\t\t\\\n-TCR(\"# Setup CFA_REG = context, which we'll retrieve as our CFA value\") \\\n-TCR(\"mr %r\" S(CFA_REG) \", %r7\") \\\n-TCR(\"\")\t\t\t\\\n-TCR(\"# Call the real handler. The signo, siginfo and sigcontext\") \\\n-TCR(\"# arguments are the same as those we received in r3, r4 and r5\") \\\n-TCR(\"mtctr %r6\") \\\n-TCR(\"bctrl\")\t\\\n-TCR(\"\")\t\t\\\n-TCR(\"# Restore our callee-saved items, release our frame and return\") \\\n-TCR(\"lwz %r\" S(CFA_REG) \",8(%r1)\")\t\\\n-TCR(\"lwz %r0,20(%r1)\")\t\\\n-TCR(\"mtlr %r0\")\t\t\\\n-TCR(\"\")\t\t\t\\\n-TCR(\"addi %r1,%r1,16\")\t\\\n-TCR(\"blr\")\n-\n-#elif defined (__ARMEL__)\n-\n-#define CFI_COMMON_REGS \\\n-CR(\"# CFI for common registers\\n\") \\\n-TCR(COMMON_CFI(G_REG_OFFSET(0)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(1)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(2)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(3)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(4)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(5)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(6)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(7)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(8)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(9)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(10)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(11)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(12)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(13)))  \\\n-TCR(COMMON_CFI(G_REG_OFFSET(14))) \\\n-TCR(COMMON_CFI(PC_OFFSET)) \\\n-TCR(\".cfi_return_column \" S(REGNO_PC_OFFSET))\n-\n-/* Trampoline body block\n-   ---------------------  */\n-\n-#define SIGTRAMP_BODY \\\n-CR(\"\") \\\n-TCR(\"# Allocate frame and save the non-volatile\") \\\n-TCR(\"# registers we're going to modify\") \\\n-TCR(\"mov\tip, sp\") \\\n-TCR(\"stmfd\tsp!, {r\" S(CFA_REG)\", fp, ip, lr, pc}\") \\\n-TCR(\"# Setup CFA_REG = context, which we'll retrieve as our CFA value\") \\\n-TCR(\"ldr\tr\" S(CFA_REG)\", [ip]\") \\\n-TCR(\"\")                 \\\n-TCR(\"# Call the real handler. The signo, siginfo and sigcontext\") \\\n-TCR(\"# arguments are the same as those we received in r0, r1 and r2\") \\\n-TCR(\"sub\tfp, ip, #4\") \\\n-TCR(\"blx\tr3\") \\\n-TCR(\"# Restore our callee-saved items, release our frame and return\") \\\n-TCR(\"ldmfd\tsp, {r\" S(CFA_REG)\", fp, sp, pc}\")\n-\n-#else\n-Not_implemented;\n-#endif /* CFI_COMMON_REGS and SIGTRAMP_BODY */\n-\n-/* Symbol definition block\n-   -----------------------  */\n-\n-#define SIGTRAMP_START(SYM) \\\n-CR(\"# \" S(SYM) \" cfi trampoline\") \\\n-TCR(\".type \" S(SYM) \", \"FUNCTION) \\\n-CR(\"\") \\\n-CR(S(SYM) \":\") \\\n-TCR(\".cfi_startproc\") \\\n-TCR(\".cfi_signal_frame\")\n-\n-/* Symbol termination block\n-   ------------------------  */\n-\n-#define SIGTRAMP_END(SYM) \\\n-CR(\".cfi_endproc\") \\\n-TCR(\".size \" S(SYM) \", .-\" S(SYM))\n-\n-/*----------------------------\n-  -- And now, the real code --\n-  ---------------------------- */\n-\n-/* Text section start.  The compiler isn't aware of that switch.  */\n-\n-asm (\".text\\n\"\n-     TCR(\".align 2\"));\n+/* Include the target specific bits.  */\n+#include \"sigtramp-vxworks-target.inc\"\n \n /* sigtramp stub for common registers.  */\n "}, {"sha": "2be20e5c3ec4760a13d2ae528f39ceec6292fb05", "filename": "gcc/ada/sigtramp.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsigtramp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5/gcc%2Fada%2Fsigtramp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp.h?ref=e8c84c8fc3a1d5e78ec885f9674add6e00fad8e5", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 2011-2014, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 2011-2015, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -62,8 +62,14 @@ typedef struct ucontext\n      system headers so call it something unique.  */\n   typedef void __sigtramphandler_t (int signo, void *siginfo, void *sigcontext);\n \n+#if CPU == SIMNT || CPU == SIMPENTIUM\n+  /* Vxsim requires a specially compiled handler.  */\n+  void __gnat_sigtramp_vxsim  (int signo, void *siginfo, void *sigcontext,\n+\t\t\t __sigtramphandler_t * handler);\n+#else\n   void __gnat_sigtramp  (int signo, void *siginfo, void *sigcontext,\n \t\t\t __sigtramphandler_t * handler);\n+#endif\n \n   /* To be called from an established signal handler.  Setup the DWARF CFI\n      bits letting unwinders walk through the signal frame up into the"}]}