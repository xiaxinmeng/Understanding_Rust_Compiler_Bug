{"sha": "84159bd8fcff0faaac81396dbe6ed503e7efff8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQxNTliZDhmY2ZmMGZhYWFjODEzOTZkYmU2ZWQ1MDNlN2VmZmY4ZQ==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2008-04-07T15:40:43Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-04-07T15:40:43Z"}, "message": "2008-04-07  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\tdoc/rtl.texi: Rewrite of subreg section.\n\nFrom-SVN: r133982", "tree": {"sha": "5d7f4c3206dbbf9646c509ae4185e62bc76ccc1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d7f4c3206dbbf9646c509ae4185e62bc76ccc1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84159bd8fcff0faaac81396dbe6ed503e7efff8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84159bd8fcff0faaac81396dbe6ed503e7efff8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84159bd8fcff0faaac81396dbe6ed503e7efff8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84159bd8fcff0faaac81396dbe6ed503e7efff8e/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8502420b678709358d5993bb6ed5d72eb3fd4353", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8502420b678709358d5993bb6ed5d72eb3fd4353", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8502420b678709358d5993bb6ed5d72eb3fd4353"}], "stats": {"total": 236, "additions": 171, "deletions": 65}, "files": [{"sha": "068f14b15f07a53ec27afea5dcba5958a7e16e44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84159bd8fcff0faaac81396dbe6ed503e7efff8e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84159bd8fcff0faaac81396dbe6ed503e7efff8e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84159bd8fcff0faaac81396dbe6ed503e7efff8e", "patch": "@@ -1,3 +1,7 @@\n+2008-04-07  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\tdoc/rtl.texi: Rewrite of subreg section.\n+\t\n 2008-04-07  Kai Tietz  <kai.tietz@onevision.com>\n \n         PR/35842"}, {"sha": "e99b381a9ae2f341e29d7ccaaf138142fc901642", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 167, "deletions": 65, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84159bd8fcff0faaac81396dbe6ed503e7efff8e/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84159bd8fcff0faaac81396dbe6ed503e7efff8e/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=84159bd8fcff0faaac81396dbe6ed503e7efff8e", "patch": "@@ -1712,89 +1712,191 @@ This virtual register is replaced by the sum of the register given by\n @end table\n \n @findex subreg\n-@item (subreg:@var{m} @var{reg} @var{bytenum})\n+@item (subreg:@var{m1} @var{reg:m2} @var{bytenum})\n+\n @code{subreg} expressions are used to refer to a register in a machine\n mode other than its natural one, or to refer to one register of\n a multi-part @code{reg} that actually refers to several registers.\n \n-Each pseudo-register has a natural mode.  If it is necessary to\n-operate on it in a different mode---for example, to perform a fullword\n-move instruction on a pseudo-register that contains a single\n-byte---the pseudo-register must be enclosed in a @code{subreg}.  In\n-such a case, @var{bytenum} is zero.\n-\n-Usually @var{m} is at least as narrow as the mode of @var{reg}, in which\n-case it is restricting consideration to only the bits of @var{reg} that\n-are in @var{m}.\n-\n-Sometimes @var{m} is wider than the mode of @var{reg}.  These\n-@code{subreg} expressions are often called @dfn{paradoxical}.  They are\n-used in cases where we want to refer to an object in a wider mode but do\n-not care what value the additional bits have.  The reload pass ensures\n-that paradoxical references are only made to hard registers.\n-\n-The other use of @code{subreg} is to extract the individual registers of\n-a multi-register value.  Machine modes such as @code{DImode} and\n-@code{TImode} can indicate values longer than a word, values which\n-usually require two or more consecutive registers.  To access one of the\n-registers, use a @code{subreg} with mode @code{SImode} and a\n-@var{bytenum} offset that says which register.\n-\n-Storing in a non-paradoxical @code{subreg} has undefined results for\n-bits belonging to the same word as the @code{subreg}.  This laxity makes\n-it easier to generate efficient code for such instructions.  To\n-represent an instruction that preserves all the bits outside of those in\n-the @code{subreg}, use @code{strict_low_part} around the @code{subreg}.\n+Each pseudo register has a natural mode.  If it is necessary to\n+operate on it in a different mode, the pseudo register must be\n+enclosed in a @code{subreg}.  \n+\n+It is seldom necessary to wrap hard registers in @code{subreg}s; such\n+registers would normally reduce to a single @code{reg} rtx.  This use of\n+@code{subregs} is discouraged and may not be supported in the future.\n+\n+@code{subreg}s come in two distinct flavors, each having its own\n+usage and rules:\n+\n+@table @asis\n+@item Paradoxical subregs\n+When @var{m1} is strictly wider than @var{m2}, the @code{subreg}\n+expression is called @dfn{paradoxical}.  The canonical test for this\n+class of @code{subreg} is:\n+\n+@smallexample\n+GET_MODE_SIZE (@var{m1}) > GET_MODE_SIZE (@var{m2})\n+@end smallexample\n+\n+Paradoxical @code{subreg}s can be used as both lvalues and rvalues.\n+When used as an rvalue, the low-order bits of the @code{subreg} are\n+taken from @var{reg} while the high-order bits are left undefined.\n+When used as an lvalue, the low-order bits of the source value are\n+stored in @var{reg} and the high-order bits are discarded.\n+\n+@var{bytenum} is always zero for a paradoxical @code{subreg}, even on\n+big-endian targets.\n+\n+For example, the paradoxical @code{subreg}:\n+\n+@smallexample\n+(set (subreg:SI (reg:HI @var{x}) 0) @var{y})\n+@end smallexample\n+\n+stores the lower 2 bytes of @var{y} in @var{x} and discards the upper\n+2 bytes.  A subsequent:\n \n+@smallexample\n+(set @var{z} (subreg:SI (reg:HI @var{x}) 0))\n+@end smallexample\n+\n+would set the lower two bytes of @var{z} to @var{y} and set the upper two\n+bytes to an unknown value.\n+\n+@item Normal subregs \n+When @var{m1} is at least as narrow as @var{m2} the @code{subreg}\n+expression is called @dfn{normal}.\n+\n+Normal @code{subreg}s restrict consideration to certain bits of @var{reg}.\n+There are two cases.  If @var{m1} is smaller than a word, the\n+@code{subreg} refers to the least-significant part (or @dfn{lowpart})\n+of one word of @var{reg}.  If @var{m1} is word-sized or greater, the\n+@code{subreg} refers to one or more complete words.\n+\n+When used as an lvalue, @code{subreg} is a word-based accessor.\n+Storing to a @code{subreg} modifies all the words of @var{reg} that\n+overlap the @code{subreg}, but it leaves the other words of @var{reg}\n+alone.\n+\n+When storing to a normal @code{subreg} that is smaller than a word,\n+the other bits of the referenced word are usually left in an undefined\n+state.  This laxity makes it easier to generate efficient code for\n+such instructions.  To represent an instruction that preserves all the\n+bits outside of those in the @code{subreg}, use @code{strict_low_part}\n+or @code{zero_extract} around the @code{subreg}.\n+\n+@var{bytenum} must identify the offset of the first byte of the\n+@code{subreg} from the start of @var{reg}, assuming that @var{reg} is\n+laid out in memory order.  The memory order of bytes is defined by\n+two target macros, @code{WORDS_BIG_ENDIAN} and @code{BYTES_BIG_ENDIAN}:\n+\n+@itemize\n+@item\n @cindex @code{WORDS_BIG_ENDIAN}, effect on @code{subreg}\n-The compilation parameter @code{WORDS_BIG_ENDIAN}, if set to 1, says\n-that byte number zero is part of the most significant word; otherwise,\n-it is part of the least significant word.\n+@code{WORDS_BIG_ENDIAN}, if set to 1, says that byte number zero is\n+part of the most significant word; otherwise, it is part of the least\n+significant word.\n \n+@item\n @cindex @code{BYTES_BIG_ENDIAN}, effect on @code{subreg}\n-The compilation parameter @code{BYTES_BIG_ENDIAN}, if set to 1, says\n-that byte number zero is the most significant byte within a word;\n-otherwise, it is the least significant byte within a word.\n+@code{BYTES_BIG_ENDIAN}, if set to 1, says that byte number zero is\n+the most significant byte within a word; otherwise, it is the least\n+significant byte within a word.\n+@end itemize\n \n @cindex @code{FLOAT_WORDS_BIG_ENDIAN}, (lack of) effect on @code{subreg}\n On a few targets, @code{FLOAT_WORDS_BIG_ENDIAN} disagrees with\n-@code{WORDS_BIG_ENDIAN}.\n-However, most parts of the compiler treat floating point values as if\n-they had the same endianness as integer values.  This works because\n-they handle them solely as a collection of integer values, with no\n-particular numerical value.  Only real.c and the runtime libraries\n-care about @code{FLOAT_WORDS_BIG_ENDIAN}.\n-\n-@cindex combiner pass\n-@cindex reload pass\n-@cindex @code{subreg}, special reload handling\n-Between the combiner pass and the reload pass, it is possible to have a\n-paradoxical @code{subreg} which contains a @code{mem} instead of a\n-@code{reg} as its first operand.  After the reload pass, it is also\n-possible to have a non-paradoxical @code{subreg} which contains a\n-@code{mem}; this usually occurs when the @code{mem} is a stack slot\n-which replaced a pseudo register.\n-\n-Note that it is not valid to access a @code{DFmode} value in @code{SFmode}\n-using a @code{subreg}.  On some machines the most significant part of a\n-@code{DFmode} value does not have the same format as a single-precision\n-floating value.\n-\n-It is also not valid to access a single word of a multi-word value in a\n-hard register when less registers can hold the value than would be\n-expected from its size.  For example, some 32-bit machines have\n-floating-point registers that can hold an entire @code{DFmode} value.\n-If register 10 were such a register @code{(subreg:SI (reg:DF 10) 4)}\n-would be invalid because there is no way to convert that reference to\n-a single machine register.  The reload pass prevents @code{subreg}\n-expressions such as these from being formed.\n+@code{WORDS_BIG_ENDIAN}.  However, most parts of the compiler treat\n+floating point values as if they had the same endianness as integer\n+values.  This works because they handle them solely as a collection of\n+integer values, with no particular numerical value.  Only real.c and\n+the runtime libraries care about @code{FLOAT_WORDS_BIG_ENDIAN}.\n+\n+Thus, \n+\n+@smallexample\n+(subreg:HI (reg:SI @var{x}) 2)\n+@end smallexample\n+\n+on a @code{BYTES_BIG_ENDIAN}, @samp{UNITS_PER_WORD == 4} target is the same as\n+\n+@smallexample\n+(subreg:HI (reg:SI @var{x}) 0)\n+@end smallexample\n+\n+on a little-endian, @samp{UNITS_PER_WORD == 4} target.  Both\n+@code{subreg}s access the lower two bytes of register @var{x}.\n+\n+@end table\n+\n+A @code{MODE_PARTIAL_INT} mode behaves as if it were as wide as the\n+corresponding @code{MODE_INT} mode, except that it has an unknown\n+number of undefined bits.  For example:\n+\n+@smallexample\n+(subreg:PSI (reg:SI 0) 0)\n+@end smallexample\n+\n+accesses the whole of @samp{(reg:SI 0)}, but the exact relationship\n+between the @code{PSImode} value and the @code{SImode} value is not\n+defined.  If we assume @samp{UNITS_PER_WORD <= 4}, then the following\n+two @code{subreg}s:\n+\n+@smallexample\n+(subreg:PSI (reg:DI 0) 0)\n+(subreg:PSI (reg:DI 0) 4)\n+@end smallexample\n+\n+represent independent 4-byte accesses to the two halves of\n+@samp{(reg:DI 0)}.  Both @code{subreg}s have an unknown number\n+of undefined bits.\n+\n+If @samp{UNITS_PER_WORD <= 2} then these two @code{subreg}s:\n+\n+@smallexample\n+(subreg:HI (reg:PSI 0) 0)\n+(subreg:HI (reg:PSI 0) 2)\n+@end smallexample\n+\n+represent independent 2-byte accesses that together span the whole\n+of @samp{(reg:PSI 0)}.  Storing to the first @code{subreg} does not\n+affect the value of the second, and vice versa.  @samp{(reg:PSI 0)}\n+has an unknown number of undefined bits, so the assignment:\n+\n+@smallexample\n+(set (subreg:HI (reg:PSI 0) 0) (reg:HI 4))\n+@end smallexample\n+\n+does not guarantee that @samp{(subreg:HI (reg:PSI 0) 0)} has the\n+value @samp{(reg:HI 4)}.\n+\n+@cindex @code{CANNOT_CHANGE_MODE_CLASS} and subreg semantics\n+The rules above apply to both pseudo @var{reg}s and hard @var{reg}s.\n+If the semantics are not correct for particular combinations of\n+@var{m1}, @var{m2} and hard @var{reg}, the target-specific code\n+must ensure that those combinations are never used.  For example:\n+\n+@smallexample\n+CANNOT_CHANGE_MODE_CLASS (@var{m2}, @var{m1}, @var{class})\n+@end smallexample\n+\n+must be true for every class @var{class} that includes @var{reg}.\n \n @findex SUBREG_REG\n @findex SUBREG_BYTE\n The first operand of a @code{subreg} expression is customarily accessed\n with the @code{SUBREG_REG} macro and the second operand is customarily\n accessed with the @code{SUBREG_BYTE} macro.\n \n+@code{subreg}s of @code{subreg}s are not supported.  Using\n+@code{simplify_gen_subreg} is the recommended way to avoid this problem.\n+\n+It has been several years since a platform in which\n+@code{BYTES_BIG_ENDIAN} was not equal to @code{WORDS_BIG_ENDIAN} has\n+been tested.  Anyone wishing to support such a platform in the future\n+may be confronted with code rot.\n+\n @findex scratch\n @cindex scratch operands\n @item (scratch:@var{m})"}]}