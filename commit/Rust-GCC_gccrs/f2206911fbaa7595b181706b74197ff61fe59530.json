{"sha": "f2206911fbaa7595b181706b74197ff61fe59530", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIyMDY5MTFmYmFhNzU5NWIxODE3MDZiNzQxOTdmZjYxZmU1OTUzMA==", "commit": {"author": {"name": "Kelley Cook", "email": "kcook@gcc.gnu.org", "date": "2003-11-14T19:15:24Z"}, "committer": {"name": "R. Kelley Cook", "email": "kcook@gcc.gnu.org", "date": "2003-11-14T19:15:24Z"}, "message": "frv-protos.h: Update for C90.\n\n2003-11-14  Kelley Cook  <kcook@gcc.gnu.org>\n\n\t* config/frv/frv-protos.h: Update for C90.\n\t* config/frv/frv.h: Likewise.\n\t* config/frv/frvbegin.c: Likewise.\n\t* config/frv/frv.c: Likewise.\n\t(frv_adjust_field_align): Delete unused variable.\n\nFrom-SVN: r73613", "tree": {"sha": "51cb7f3e9cbd2771c0130dc659e8332098efe1e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51cb7f3e9cbd2771c0130dc659e8332098efe1e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2206911fbaa7595b181706b74197ff61fe59530", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2206911fbaa7595b181706b74197ff61fe59530", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2206911fbaa7595b181706b74197ff61fe59530", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2206911fbaa7595b181706b74197ff61fe59530/comments", "author": null, "committer": null, "parents": [{"sha": "39e63627563b7f7a65c814bacca1227336872327", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39e63627563b7f7a65c814bacca1227336872327", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39e63627563b7f7a65c814bacca1227336872327"}], "stats": {"total": 1345, "additions": 504, "deletions": 841}, "files": [{"sha": "84497c75b42632f1fbb08fa7205d933f5993f64c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2206911fbaa7595b181706b74197ff61fe59530/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2206911fbaa7595b181706b74197ff61fe59530/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2206911fbaa7595b181706b74197ff61fe59530", "patch": "@@ -1,3 +1,11 @@\n+2003-11-14  Kelley Cook  <kcook@gcc.gnu.org>\n+\n+\t* config/frv/frv-protos.h: Update for C90.\n+\t* config/frv/frv.h: Likewise.\n+\t* config/frv/frvbegin.c: Likewise.\n+\t* config/frv/frv.c: Likewise. \n+\t(frv_adjust_field_align): Delete unused variable.\n+\n 2003-11-14  Geoffrey Keating  <geoffk@apple.com>\n \n \t* config/rs6000/rs6000.md: Add 'DEFAULT_ABI == ABI_DARWIN'"}, {"sha": "04774de1b84ea358c2a44c735e5889961022918f", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 154, "deletions": 161, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2206911fbaa7595b181706b74197ff61fe59530/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2206911fbaa7595b181706b74197ff61fe59530/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=f2206911fbaa7595b181706b74197ff61fe59530", "patch": "@@ -52,194 +52,187 @@ typedef enum frv_cpu\n extern frv_cpu_t frv_cpu_type;\t\t\t/* value of -mcpu= */\n \n /* Define functions defined in frv.c */\n-extern void frv_expand_prologue\t\t\tPARAMS ((void));\n-extern void frv_expand_epilogue\t\t\tPARAMS ((int));\n-extern void frv_override_options\t\tPARAMS ((void));\n-extern void frv_optimization_options\t\tPARAMS ((int, int));\n-extern void frv_conditional_register_usage\tPARAMS ((void));\n-extern frv_stack_t *frv_stack_info\t\tPARAMS ((void));\n-extern void frv_debug_stack\t\t\tPARAMS ((frv_stack_t *));\n-extern int frv_frame_pointer_required\t\tPARAMS ((void));\n-extern int frv_initial_elimination_offset\tPARAMS ((int, int));\n+extern void frv_expand_prologue\t\t\t(void);\n+extern void frv_expand_epilogue\t\t\t(int);\n+extern void frv_override_options\t\t(void);\n+extern void frv_optimization_options\t\t(int, int);\n+extern void frv_conditional_register_usage\t(void);\n+extern frv_stack_t *frv_stack_info\t\t(void);\n+extern void frv_debug_stack\t\t\t(frv_stack_t *);\n+extern int frv_frame_pointer_required\t\t(void);\n+extern int frv_initial_elimination_offset\t(int, int);\n \n #ifdef RTX_CODE\n-extern int frv_legitimate_address_p\t\tPARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t\t       int, int));\n-extern rtx frv_legitimize_address\t\tPARAMS ((rtx, rtx,\n-\t\t\t\t\t\t\t enum machine_mode));\n+extern int frv_legitimate_address_p \t\t(enum machine_mode, rtx,\n+\t\t\t\t\t\t int, int);\n+extern rtx frv_legitimize_address\t\t(rtx, rtx, enum machine_mode);\n \n #ifdef TREE_CODE\n-extern void frv_init_cumulative_args\t\tPARAMS ((CUMULATIVE_ARGS *, tree,\n-\t\t\t\t\t\t       rtx, tree, int));\n+extern void frv_init_cumulative_args\t\t(CUMULATIVE_ARGS *, tree,\n+\t\t\t\t\t\t rtx, tree, int);\n \n-extern int frv_function_arg_boundary\t\tPARAMS ((enum machine_mode, tree));\n-extern rtx frv_function_arg\t\t\tPARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t\t       tree, int, int));\n+extern int frv_function_arg_boundary\t\t(enum machine_mode, tree);\n+extern rtx frv_function_arg\t\t\t(CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t tree, int, int);\n \n-extern void frv_function_arg_advance\t\tPARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t\t       tree, int));\n+extern void frv_function_arg_advance\t\t(CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t tree, int);\n \n-extern int frv_function_arg_partial_nregs\tPARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t\t       tree, int));\n+extern int frv_function_arg_partial_nregs\t(CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t tree, int);\n \n-extern int frv_function_arg_pass_by_reference\tPARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t\t       tree, int));\n+extern int frv_function_arg_pass_by_reference\t(CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t tree, int);\n \n-extern int frv_function_arg_callee_copies\tPARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t\t       tree, int));\n+extern int frv_function_arg_callee_copies\t(CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t tree, int);\n \n-extern int frv_function_arg_keep_as_reference\tPARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t\t       tree, int));\n+extern int frv_function_arg_keep_as_reference\t(CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t tree, int);\n \n-extern rtx frv_expand_builtin_saveregs\t\tPARAMS ((void));\n-extern void frv_setup_incoming_varargs\t\tPARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t\t tree, int *, int));\n+extern rtx frv_expand_builtin_saveregs\t\t(void);\n+extern void frv_setup_incoming_varargs\t\t(CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t tree, int *, int);\n \n-extern void frv_expand_builtin_va_start\t\tPARAMS ((tree, rtx));\n-extern rtx frv_expand_builtin_va_arg\t\tPARAMS ((tree, tree));\n+extern void frv_expand_builtin_va_start\t\t(tree, rtx);\n+extern rtx frv_expand_builtin_va_arg\t\t(tree, tree);\n #endif /* TREE_CODE */\n \n-extern int frv_expand_block_move\t\tPARAMS ((rtx *));\n-extern int frv_expand_block_clear\t\tPARAMS ((rtx *));\n-extern rtx frv_dynamic_chain_address\t\tPARAMS ((rtx));\n-extern rtx frv_return_addr_rtx\t\t\tPARAMS ((int, rtx));\n-extern rtx frv_index_memory\t\t\tPARAMS ((rtx,\n-\t\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t\t int));\n+extern int frv_expand_block_move\t\t(rtx *);\n+extern int frv_expand_block_clear\t\t(rtx *);\n+extern rtx frv_dynamic_chain_address\t\t(rtx);\n+extern rtx frv_return_addr_rtx\t\t\t(int, rtx);\n+extern rtx frv_index_memory\t\t\t(rtx, enum machine_mode, int);\n extern const char *frv_asm_output_opcode\n-\t\t\t\t \tPARAMS ((FILE *, const char *));\n-extern void frv_final_prescan_insn\tPARAMS ((rtx, rtx *, int));\n-extern void frv_print_operand\t\tPARAMS ((FILE *, rtx, int));\n-extern void frv_print_operand_address\tPARAMS ((FILE *, rtx));\n-extern int frv_emit_movsi\t\tPARAMS ((rtx, rtx));\n-extern const char *output_move_single\tPARAMS ((rtx *, rtx));\n-extern const char *output_move_double\tPARAMS ((rtx *, rtx));\n+\t\t\t\t \t(FILE *, const char *);\n+extern void frv_final_prescan_insn\t(rtx, rtx *, int);\n+extern void frv_print_operand\t\t(FILE *, rtx, int);\n+extern void frv_print_operand_address\t(FILE *, rtx);\n+extern int frv_emit_movsi\t\t(rtx, rtx);\n+extern const char *output_move_single\t(rtx *, rtx);\n+extern const char *output_move_double\t(rtx *, rtx);\n extern const char *output_condmove_single\n-\t\t\t\t\tPARAMS ((rtx *, rtx));\n-extern int frv_emit_cond_branch\t\tPARAMS ((enum rtx_code, rtx));\n-extern int frv_emit_scc\t\t\tPARAMS ((enum rtx_code, rtx));\n-extern rtx frv_split_scc\t\tPARAMS ((rtx, rtx, rtx, rtx,\n-\t\t\t\t\t\t HOST_WIDE_INT));\n-extern int frv_emit_cond_move\t\tPARAMS ((rtx, rtx, rtx, rtx));\n-extern rtx frv_split_cond_move\t\tPARAMS ((rtx *));\n-extern rtx frv_split_minmax\t\tPARAMS ((rtx *));\n-extern rtx frv_split_abs\t\tPARAMS ((rtx *));\n-extern void frv_split_double_load\tPARAMS ((rtx, rtx));\n-extern void frv_split_double_store\tPARAMS ((rtx, rtx));\n+\t\t\t\t\t(rtx *, rtx);\n+extern int frv_emit_cond_branch\t\t(enum rtx_code, rtx);\n+extern int frv_emit_scc\t\t\t(enum rtx_code, rtx);\n+extern rtx frv_split_scc\t\t(rtx, rtx, rtx, rtx, HOST_WIDE_INT);\n+extern int frv_emit_cond_move\t\t(rtx, rtx, rtx, rtx);\n+extern rtx frv_split_cond_move\t\t(rtx *);\n+extern rtx frv_split_minmax\t\t(rtx *);\n+extern rtx frv_split_abs\t\t(rtx *);\n+extern void frv_split_double_load\t(rtx, rtx);\n+extern void frv_split_double_store\t(rtx, rtx);\n #ifdef BLOCK_HEAD\n-extern void frv_ifcvt_init_extra_fields\tPARAMS ((ce_if_block_t *));\n-extern void frv_ifcvt_modify_tests\tPARAMS ((ce_if_block_t *,\n-\t\t\t\t\t\t rtx *, rtx *));\n+extern void frv_ifcvt_init_extra_fields\t(ce_if_block_t *);\n+extern void frv_ifcvt_modify_tests\t(ce_if_block_t *, rtx *, rtx *);\n extern void frv_ifcvt_modify_multiple_tests\n-\t\t\t\t\tPARAMS ((ce_if_block_t *,\n-\t\t\t\t\t\t basic_block,\n-\t\t\t\t\t\t rtx *, rtx *));\n-extern rtx frv_ifcvt_modify_insn\tPARAMS ((ce_if_block_t *,\n-\t\t\t\t\t\t rtx, rtx));\n-extern void frv_ifcvt_modify_final\tPARAMS ((ce_if_block_t *));\n-extern void frv_ifcvt_modify_cancel\tPARAMS ((ce_if_block_t *));\n+\t\t\t\t\t(ce_if_block_t *, basic_block,\n+\t\t\t\t\t rtx *, rtx *);\n+extern rtx frv_ifcvt_modify_insn\t(ce_if_block_t *, rtx, rtx);\n+extern void frv_ifcvt_modify_final\t(ce_if_block_t *);\n+extern void frv_ifcvt_modify_cancel\t(ce_if_block_t *);\n #endif\n-extern int frv_trampoline_size\t\tPARAMS ((void));\n-extern void frv_initialize_trampoline\tPARAMS ((rtx, rtx, rtx));\n+extern int frv_trampoline_size\t\t(void);\n+extern void frv_initialize_trampoline\t(rtx, rtx, rtx);\n extern enum reg_class frv_secondary_reload_class\n-\t\t\t\t\tPARAMS ((enum reg_class class,\n-\t\t\t\t\t       enum machine_mode mode,\n-\t\t\t\t\t       rtx x, int));\n-extern int frv_class_likely_spilled_p\tPARAMS ((enum reg_class class));\n-extern int frv_hard_regno_mode_ok\tPARAMS ((int, enum machine_mode));\n-extern int frv_hard_regno_nregs\t\tPARAMS ((int, enum machine_mode));\n-extern int frv_class_max_nregs\t\tPARAMS ((enum reg_class class,\n-\t\t\t\t\t\t enum machine_mode mode));\n-extern int frv_legitimate_constant_p\tPARAMS ((rtx));\n+\t\t\t\t\t(enum reg_class class,\n+\t\t\t\t\t enum machine_mode mode,\n+\t\t\t\t\t rtx x, int);\n+extern int frv_class_likely_spilled_p\t(enum reg_class class);\n+extern int frv_hard_regno_mode_ok\t(int, enum machine_mode);\n+extern int frv_hard_regno_nregs\t\t(int, enum machine_mode);\n+extern int frv_class_max_nregs\t\t(enum reg_class class,\n+\t\t\t\t\t enum machine_mode mode);\n+extern int frv_legitimate_constant_p\t(rtx);\n #endif\t/* RTX_CODE */\n \n-extern int direct_return_p\t\tPARAMS ((void));\n-extern int frv_register_move_cost\tPARAMS ((enum reg_class, enum reg_class));\n+extern int direct_return_p\t\t(void);\n+extern int frv_register_move_cost\t(enum reg_class, enum reg_class);\n \n #ifdef TREE_CODE\n-extern int frv_adjust_field_align\tPARAMS ((tree, int));\n+extern int frv_adjust_field_align\t(tree, int);\n #endif\n \n-extern void fixup_section\t\tPARAMS ((void));\n-extern void sdata_section\t\tPARAMS ((void));\n-extern void sbss_section\t\tPARAMS ((void));\n-extern void data_section\t\tPARAMS ((void));\n+extern void fixup_section\t\t(void);\n+extern void sdata_section\t\t(void);\n+extern void sbss_section\t\t(void);\n+extern void data_section\t\t(void);\n \n #ifdef RTX_CODE\n-extern int integer_register_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int frv_load_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int gpr_or_fpr_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int gpr_no_subreg_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int gpr_or_int6_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int fpr_or_int6_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int gpr_or_int_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int gpr_or_int12_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int gpr_fpr_or_int12_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int gpr_or_int10_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int move_source_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int move_destination_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int condexec_source_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int condexec_dest_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int lr_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int gpr_or_memory_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int fpr_or_memory_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int reg_or_0_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int fcc_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int icc_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int cc_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int fcr_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int icr_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int cr_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int call_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int fpr_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int even_reg_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int odd_reg_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int even_gpr_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int odd_gpr_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int quad_fpr_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int even_fpr_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int odd_fpr_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int dbl_memory_one_insn_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int dbl_memory_two_insn_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int int12_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int int6_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int int5_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int uint5_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int uint4_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int uint1_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int int_2word_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int pic_register_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int pic_symbolic_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int small_data_register_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int small_data_symbolic_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int upper_int16_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int uint16_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int relational_operator\t\tPARAMS ((rtx, enum machine_mode));\n-extern int signed_relational_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int unsigned_relational_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int float_relational_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int ccr_eqne_operator\t\tPARAMS ((rtx, enum machine_mode));\n-extern int minmax_operator\t\tPARAMS ((rtx, enum machine_mode));\n-extern int condexec_si_binary_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int condexec_si_media_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int condexec_si_divide_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int condexec_si_unary_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int condexec_sf_conv_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int condexec_sf_add_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int condexec_memory_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int intop_compare_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int condexec_intop_cmp_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int acc_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern int even_acc_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int quad_acc_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int accg_operand\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern rtx frv_matching_accg_for_acc\tPARAMS ((rtx));\n+extern int integer_register_operand\t(rtx, enum machine_mode);\n+extern int frv_load_operand\t\t(rtx, enum machine_mode);\n+extern int gpr_or_fpr_operand\t\t(rtx, enum machine_mode);\n+extern int gpr_no_subreg_operand\t(rtx, enum machine_mode);\n+extern int gpr_or_int6_operand\t\t(rtx, enum machine_mode);\n+extern int fpr_or_int6_operand\t\t(rtx, enum machine_mode);\n+extern int gpr_or_int_operand\t\t(rtx, enum machine_mode);\n+extern int gpr_or_int12_operand\t\t(rtx, enum machine_mode);\n+extern int gpr_fpr_or_int12_operand\t(rtx, enum machine_mode);\n+extern int gpr_or_int10_operand\t\t(rtx, enum machine_mode);\n+extern int move_source_operand\t\t(rtx, enum machine_mode);\n+extern int move_destination_operand\t(rtx, enum machine_mode);\n+extern int condexec_source_operand\t(rtx, enum machine_mode);\n+extern int condexec_dest_operand\t(rtx, enum machine_mode);\n+extern int lr_operand\t\t\t(rtx, enum machine_mode);\n+extern int gpr_or_memory_operand\t(rtx, enum machine_mode);\n+extern int fpr_or_memory_operand\t(rtx, enum machine_mode);\n+extern int reg_or_0_operand\t\t(rtx, enum machine_mode);\n+extern int fcc_operand\t\t\t(rtx, enum machine_mode);\n+extern int icc_operand\t\t\t(rtx, enum machine_mode);\n+extern int cc_operand\t\t\t(rtx, enum machine_mode);\n+extern int fcr_operand\t\t\t(rtx, enum machine_mode);\n+extern int icr_operand\t\t\t(rtx, enum machine_mode);\n+extern int cr_operand\t\t\t(rtx, enum machine_mode);\n+extern int call_operand\t\t\t(rtx, enum machine_mode);\n+extern int fpr_operand\t\t\t(rtx, enum machine_mode);\n+extern int even_reg_operand\t\t(rtx, enum machine_mode);\n+extern int odd_reg_operand\t\t(rtx, enum machine_mode);\n+extern int even_gpr_operand\t\t(rtx, enum machine_mode);\n+extern int odd_gpr_operand\t\t(rtx, enum machine_mode);\n+extern int quad_fpr_operand\t\t(rtx, enum machine_mode);\n+extern int even_fpr_operand\t\t(rtx, enum machine_mode);\n+extern int odd_fpr_operand\t\t(rtx, enum machine_mode);\n+extern int dbl_memory_one_insn_operand\t(rtx, enum machine_mode);\n+extern int dbl_memory_two_insn_operand\t(rtx, enum machine_mode);\n+extern int int12_operand\t\t(rtx, enum machine_mode);\n+extern int int6_operand\t\t\t(rtx, enum machine_mode);\n+extern int int5_operand\t\t\t(rtx, enum machine_mode);\n+extern int uint5_operand\t\t(rtx, enum machine_mode);\n+extern int uint4_operand\t\t(rtx, enum machine_mode);\n+extern int uint1_operand\t\t(rtx, enum machine_mode);\n+extern int int_2word_operand\t\t(rtx, enum machine_mode);\n+extern int pic_register_operand\t\t(rtx, enum machine_mode);\n+extern int pic_symbolic_operand\t\t(rtx, enum machine_mode);\n+extern int small_data_register_operand\t(rtx, enum machine_mode);\n+extern int small_data_symbolic_operand\t(rtx, enum machine_mode);\n+extern int upper_int16_operand\t\t(rtx, enum machine_mode);\n+extern int uint16_operand\t\t(rtx, enum machine_mode);\n+extern int relational_operator\t\t(rtx, enum machine_mode);\n+extern int signed_relational_operator\t(rtx, enum machine_mode);\n+extern int unsigned_relational_operator\t(rtx, enum machine_mode);\n+extern int float_relational_operator\t(rtx, enum machine_mode);\n+extern int ccr_eqne_operator\t\t(rtx, enum machine_mode);\n+extern int minmax_operator\t\t(rtx, enum machine_mode);\n+extern int condexec_si_binary_operator\t(rtx, enum machine_mode);\n+extern int condexec_si_media_operator\t(rtx, enum machine_mode);\n+extern int condexec_si_divide_operator\t(rtx, enum machine_mode);\n+extern int condexec_si_unary_operator\t(rtx, enum machine_mode);\n+extern int condexec_sf_conv_operator\t(rtx, enum machine_mode);\n+extern int condexec_sf_add_operator\t(rtx, enum machine_mode);\n+extern int condexec_memory_operand\t(rtx, enum machine_mode);\n+extern int intop_compare_operator\t(rtx, enum machine_mode);\n+extern int condexec_intop_cmp_operator\t(rtx, enum machine_mode);\n+extern int acc_operand\t\t\t(rtx, enum machine_mode);\n+extern int even_acc_operand\t\t(rtx, enum machine_mode);\n+extern int quad_acc_operand\t\t(rtx, enum machine_mode);\n+extern int accg_operand\t\t\t(rtx, enum machine_mode);\n+extern rtx frv_matching_accg_for_acc\t(rtx);\n #endif\n "}, {"sha": "ce175ee80f0c79e3e8c6af7616d7c370c5752012", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 335, "deletions": 669, "changes": 1004, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2206911fbaa7595b181706b74197ff61fe59530/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2206911fbaa7595b181706b74197ff61fe59530/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=f2206911fbaa7595b181706b74197ff61fe59530", "patch": "@@ -196,96 +196,75 @@ const char *frv_sched_lookahead_str;\t /* -msched-lookahead=n */\n int frv_sched_lookahead = 4;\t\t /* -msched-lookahead=n */\n \n /* Forward references */\n-static int frv_default_flags_for_cpu\t\tPARAMS ((void));\n-static int frv_string_begins_with\t\tPARAMS ((tree, const char *));\n-static FRV_INLINE int const_small_data_p\tPARAMS ((rtx));\n-static FRV_INLINE int plus_small_data_p\t\tPARAMS ((rtx, rtx));\n+static int frv_default_flags_for_cpu\t\t(void);\n+static int frv_string_begins_with\t\t(tree, const char *);\n+static FRV_INLINE int const_small_data_p\t(rtx);\n+static FRV_INLINE int plus_small_data_p\t\t(rtx, rtx);\n static void frv_print_operand_memory_reference_reg\n-\t\t\t\t\t\tPARAMS ((FILE *, rtx));\n-static void frv_print_operand_memory_reference\tPARAMS ((FILE *, rtx, int));\n-static int frv_print_operand_jump_hint\t\tPARAMS ((rtx));\n-static FRV_INLINE int frv_regno_ok_for_base_p\tPARAMS ((int, int));\n-static rtx single_set_pattern\t\t\tPARAMS ((rtx));\n-static int frv_function_contains_far_jump\tPARAMS ((void));\n-static rtx frv_alloc_temp_reg\t\t\tPARAMS ((frv_tmp_reg_t *,\n-\t\t\t\t\t\t\t enum reg_class,\n-\t\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t\t int, int));\n-static rtx frv_frame_offset_rtx\t\t\tPARAMS ((int));\n-static rtx frv_frame_mem\t\t\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t\t rtx, int));\n-static rtx frv_dwarf_store\t\t\tPARAMS ((rtx, int));\n-static void frv_frame_insn\t\t\tPARAMS ((rtx, rtx));\n-static void frv_frame_access\t\t\tPARAMS ((frv_frame_accessor_t*,\n-\t\t\t\t\t\t\t rtx, int));\n-static void frv_frame_access_multi\t\tPARAMS ((frv_frame_accessor_t*,\n-\t\t\t\t\t\t\t frv_stack_t *, int));\n-static void frv_frame_access_standard_regs\tPARAMS ((enum frv_stack_op,\n-\t\t\t\t\t\t\t frv_stack_t *));\n-static struct machine_function *frv_init_machine_status\t\tPARAMS ((void));\n-static int frv_legitimate_memory_operand\tPARAMS ((rtx,\n-\t\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t\t int));\n-static rtx frv_int_to_acc\t\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t int, rtx));\n-static enum machine_mode frv_matching_accg_mode\tPARAMS ((enum machine_mode));\n-static rtx frv_read_argument\t\t\tPARAMS ((tree *));\n-static int frv_check_constant_argument\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t int, rtx));\n-static rtx frv_legitimize_target\t\tPARAMS ((enum insn_code, rtx));\n-static rtx frv_legitimize_argument\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t int, rtx));\n-static rtx frv_expand_set_builtin\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t tree, rtx));\n-static rtx frv_expand_unop_builtin\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t tree, rtx));\n-static rtx frv_expand_binop_builtin\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t tree, rtx));\n-static rtx frv_expand_cut_builtin\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t tree, rtx));\n-static rtx frv_expand_binopimm_builtin\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t tree, rtx));\n-static rtx frv_expand_voidbinop_builtin\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t tree));\n-static rtx frv_expand_voidtriop_builtin\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t tree));\n-static rtx frv_expand_voidaccop_builtin\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t tree));\n-static rtx frv_expand_mclracc_builtin\t\tPARAMS ((tree));\n-static rtx frv_expand_mrdacc_builtin\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t tree));\n-static rtx frv_expand_mwtacc_builtin\t\tPARAMS ((enum insn_code,\n-\t\t\t\t\t\t\t tree));\n-static rtx frv_expand_noargs_builtin\t\tPARAMS ((enum insn_code));\n-static rtx frv_emit_comparison\t\t\tPARAMS ((enum rtx_code, rtx,\n-\t\t\t\t\t\t\t rtx));\n-static int frv_clear_registers_used\t\tPARAMS ((rtx *, void *));\n-static void frv_ifcvt_add_insn\t\t\tPARAMS ((rtx, rtx, int));\n-static rtx frv_ifcvt_rewrite_mem\t\tPARAMS ((rtx,\n-\t\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t\t rtx));\n-static rtx frv_ifcvt_load_value\t\t\tPARAMS ((rtx, rtx));\n-static void frv_registers_update\t\tPARAMS  ((rtx, unsigned char [],\n-\t\t\t\t\t\t\t int [], int *, int));\n-static int frv_registers_used_p\t\t\tPARAMS ((rtx, unsigned char [],\n-\t\t\t\t\t\t\t int));\n-static int frv_registers_set_p\t\t\tPARAMS ((rtx, unsigned char [],\n-\t\t\t\t\t\t\t int));\n-static int frv_issue_rate\t\t\tPARAMS ((void));\n-static int frv_use_dfa_pipeline_interface\tPARAMS ((void));\n-static void frv_pack_insns\t\t\tPARAMS ((void));\n-static void frv_function_prologue\t\tPARAMS ((FILE *, HOST_WIDE_INT));\n-static void frv_function_epilogue\t\tPARAMS ((FILE *, HOST_WIDE_INT));\n-static bool frv_assemble_integer\t\tPARAMS ((rtx, unsigned, int));\n-static void frv_init_builtins\t\t\tPARAMS ((void));\n-static rtx frv_expand_builtin\t\t\tPARAMS ((tree, rtx, rtx, enum machine_mode, int));\n-static void frv_init_libfuncs\t\t\tPARAMS ((void));\n-static bool frv_in_small_data_p\t\t\tPARAMS ((tree));\n+\t\t\t\t\t\t(FILE *, rtx);\n+static void frv_print_operand_memory_reference\t(FILE *, rtx, int);\n+static int frv_print_operand_jump_hint\t\t(rtx);\n+static FRV_INLINE int frv_regno_ok_for_base_p\t(int, int);\n+static rtx single_set_pattern\t\t\t(rtx);\n+static int frv_function_contains_far_jump\t(void);\n+static rtx frv_alloc_temp_reg\t\t\t(frv_tmp_reg_t *,\n+\t\t\t\t\t\t enum reg_class,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t int, int);\n+static rtx frv_frame_offset_rtx\t\t\t(int);\n+static rtx frv_frame_mem\t\t\t(enum machine_mode, rtx, int);\n+static rtx frv_dwarf_store\t\t\t(rtx, int);\n+static void frv_frame_insn\t\t\t(rtx, rtx);\n+static void frv_frame_access\t\t\t(frv_frame_accessor_t*,\n+\t\t\t\t\t\t rtx, int);\n+static void frv_frame_access_multi\t\t(frv_frame_accessor_t*,\n+\t\t\t\t\t\t frv_stack_t *, int);\n+static void frv_frame_access_standard_regs\t(enum frv_stack_op,\n+\t\t\t\t\t\t frv_stack_t *);\n+static struct machine_function *frv_init_machine_status\t\t(void);\n+static int frv_legitimate_memory_operand\t(rtx, enum machine_mode, int);\n+static rtx frv_int_to_acc\t\t\t(enum insn_code, int, rtx);\n+static enum machine_mode frv_matching_accg_mode\t(enum machine_mode);\n+static rtx frv_read_argument\t\t\t(tree *);\n+static int frv_check_constant_argument\t\t(enum insn_code, int, rtx);\n+static rtx frv_legitimize_target\t\t(enum insn_code, rtx);\n+static rtx frv_legitimize_argument\t\t(enum insn_code, int, rtx);\n+static rtx frv_expand_set_builtin\t\t(enum insn_code, tree, rtx);\n+static rtx frv_expand_unop_builtin\t\t(enum insn_code, tree, rtx);\n+static rtx frv_expand_binop_builtin\t\t(enum insn_code, tree, rtx);\n+static rtx frv_expand_cut_builtin\t\t(enum insn_code, tree, rtx);\n+static rtx frv_expand_binopimm_builtin\t\t(enum insn_code, tree, rtx);\n+static rtx frv_expand_voidbinop_builtin\t\t(enum insn_code, tree);\n+static rtx frv_expand_voidtriop_builtin\t\t(enum insn_code, tree);\n+static rtx frv_expand_voidaccop_builtin\t\t(enum insn_code, tree);\n+static rtx frv_expand_mclracc_builtin\t\t(tree);\n+static rtx frv_expand_mrdacc_builtin\t\t(enum insn_code, tree);\n+static rtx frv_expand_mwtacc_builtin\t\t(enum insn_code, tree);\n+static rtx frv_expand_noargs_builtin\t\t(enum insn_code);\n+static rtx frv_emit_comparison\t\t\t(enum rtx_code, rtx, rtx);\n+static int frv_clear_registers_used\t\t(rtx *, void *);\n+static void frv_ifcvt_add_insn\t\t\t(rtx, rtx, int);\n+static rtx frv_ifcvt_rewrite_mem\t\t(rtx, enum machine_mode, rtx);\n+static rtx frv_ifcvt_load_value\t\t\t(rtx, rtx);\n+static void frv_registers_update\t\t(rtx, unsigned char [],\n+\t\t\t\t\t\t int [], int *, int);\n+static int frv_registers_used_p\t\t\t(rtx, unsigned char [], int);\n+static int frv_registers_set_p\t\t\t(rtx, unsigned char [], int);\n+static int frv_issue_rate\t\t\t(void);\n+static int frv_use_dfa_pipeline_interface\t(void);\n+static void frv_pack_insns\t\t\t(void);\n+static void frv_function_prologue\t\t(FILE *, HOST_WIDE_INT);\n+static void frv_function_epilogue\t\t(FILE *, HOST_WIDE_INT);\n+static bool frv_assemble_integer\t\t(rtx, unsigned, int);\n+static void frv_init_builtins\t\t\t(void);\n+static rtx frv_expand_builtin\t\t\t(tree, rtx, rtx, enum machine_mode, int);\n+static void frv_init_libfuncs\t\t\t(void);\n+static bool frv_in_small_data_p\t\t\t(tree);\n static void frv_asm_output_mi_thunk\n-  PARAMS ((FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));\n-static bool frv_rtx_costs\t\t\tPARAMS ((rtx, int, int, int*));\n-static void frv_asm_out_constructor\t\tPARAMS ((rtx, int));\n-static void frv_asm_out_destructor\t\tPARAMS ((rtx, int));\n+  (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n+static bool frv_rtx_costs\t\t\t(rtx, int, int, int*);\n+static void frv_asm_out_constructor\t\t(rtx, int);\n+static void frv_asm_out_destructor\t\t(rtx, int);\n \f\n /* Initialize the GCC target structure.  */\n #undef  TARGET_ASM_FUNCTION_PROLOGUE\n@@ -324,8 +303,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n /* Given a CONST, return true if the symbol_ref points to small data.  */\n \n static FRV_INLINE int\n-const_small_data_p (x)\n-     rtx x;\n+const_small_data_p (rtx x)\n {\n   rtx x0, x1;\n \n@@ -347,9 +325,7 @@ const_small_data_p (x)\n /* Given a PLUS, return true if this is a small data reference.  */\n \n static FRV_INLINE int\n-plus_small_data_p (op0, op1)\n-     rtx op0;\n-     rtx op1;\n+plus_small_data_p (rtx op0, rtx op1)\n {\n   if (GET_MODE (op0) == SImode\n       && GET_CODE (op0) == REG\n@@ -367,7 +343,7 @@ plus_small_data_p (op0, op1)\n \n \f\n static int\n-frv_default_flags_for_cpu ()\n+frv_default_flags_for_cpu (void)\n {\n   switch (frv_cpu_type)\n     {\n@@ -398,7 +374,7 @@ frv_default_flags_for_cpu ()\n    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n \n void\n-frv_override_options ()\n+frv_override_options (void)\n {\n   int regno, i;\n \n@@ -620,9 +596,7 @@ frv_override_options ()\n /* On the FRV, possibly disable VLIW packing which is done by the 2nd\n    scheduling pass at the current time.  */\n void\n-frv_optimization_options (level, size)\n-     int level;\n-     int size ATTRIBUTE_UNUSED;\n+frv_optimization_options (int level, int size ATTRIBUTE_UNUSED)\n {\n   if (level >= 2)\n     {\n@@ -639,9 +613,7 @@ frv_optimization_options (level, size)\n /* Return true if NAME (a STRING_CST node) begins with PREFIX.  */\n \n static int\n-frv_string_begins_with (name, prefix)\n-     tree name;\n-     const char *prefix;\n+frv_string_begins_with (tree name, const char *prefix)\n {\n   int prefix_len = strlen (prefix);\n \n@@ -671,7 +643,7 @@ frv_string_begins_with (name, prefix)\n    target switches are opposed to them.)  */\n \n void\n-frv_conditional_register_usage ()\n+frv_conditional_register_usage (void)\n {\n   int i;\n \n@@ -878,7 +850,7 @@ frv_conditional_register_usage ()\n  */\n \n frv_stack_t *\n-frv_stack_info ()\n+frv_stack_info (void)\n {\n   static frv_stack_t info, zero_info;\n   frv_stack_t *info_ptr\t= &info;\n@@ -1206,8 +1178,7 @@ frv_stack_info ()\n /* Print the information about the frv stack offsets, etc. when debugging. */\n \n void\n-frv_debug_stack (info)\n-     frv_stack_t *info;\n+frv_debug_stack (frv_stack_t *info)\n {\n   int range;\n \n@@ -1273,7 +1244,7 @@ static int frv_insn_packing_flag;\n /* True if the current function contains a far jump.  */\n \n static int\n-frv_function_contains_far_jump ()\n+frv_function_contains_far_jump (void)\n {\n   rtx insn = get_insns ();\n   while (insn != NULL\n@@ -1290,9 +1261,7 @@ frv_function_contains_far_jump ()\n    will return correctly.  It also does the VLIW packing.  */\n \n static void\n-frv_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+frv_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   /* If no frame was created, check whether the function uses a call\n      instruction to implement a far jump.  If so, save the link in gr3 and\n@@ -1339,12 +1308,12 @@ frv_function_prologue (file, size)\n /* Return the next available temporary register in a given class.  */\n \n static rtx\n-frv_alloc_temp_reg (info, class, mode, mark_as_used, no_abort)\n-     frv_tmp_reg_t *info;\t/* which registers are available */\n-     enum reg_class class;\t/* register class desired */\n-     enum machine_mode mode;\t/* mode to allocate register with */\n-     int mark_as_used;\t\t/* register not available after allocation */\n-     int no_abort;\t\t/* return NULL instead of aborting */\n+frv_alloc_temp_reg (\n+     frv_tmp_reg_t *info,\t/* which registers are available */\n+     enum reg_class class,\t/* register class desired */\n+     enum machine_mode mode,\t/* mode to allocate register with */\n+     int mark_as_used,\t\t/* register not available after allocation */\n+     int no_abort)\t\t/* return NULL instead of aborting */\n {\n   int regno = info->next_reg[ (int)class ];\n   int orig_regno = regno;\n@@ -1386,8 +1355,7 @@ frv_alloc_temp_reg (info, class, mode, mark_as_used, no_abort)\n    The function returns a constant rtx if OFFSET is small enough, otherwise\n    it loads the constant into register OFFSET_REGNO and returns that.  */\n static rtx\n-frv_frame_offset_rtx (offset)\n-     int offset;\n+frv_frame_offset_rtx (int offset)\n {\n   rtx offset_rtx = GEN_INT (offset);\n   if (IN_RANGE_P (offset, -2048, 2047))\n@@ -1409,10 +1377,7 @@ frv_frame_offset_rtx (offset)\n /* Generate (mem:MODE (plus:Pmode BASE (frv_frame_offset OFFSET)))).  The\n    prologue and epilogue uses such expressions to access the stack.  */\n static rtx\n-frv_frame_mem (mode, base, offset)\n-     enum machine_mode mode;\n-     rtx base;\n-     int offset;\n+frv_frame_mem (enum machine_mode mode, rtx base, int offset)\n {\n   return gen_rtx_MEM (mode, gen_rtx_PLUS (Pmode,\n \t\t\t\t\t  base,\n@@ -1429,9 +1394,7 @@ frv_frame_mem (mode, base, offset)\n    or SEQUENCE that has several sets, each set must be individually marked\n    as frame-related.  */\n static rtx\n-frv_dwarf_store (reg, offset)\n-     rtx reg;\n-     int offset;\n+frv_dwarf_store (rtx reg, int offset)\n {\n   rtx set = gen_rtx_SET (VOIDmode,\n \t\t\t gen_rtx_MEM (GET_MODE (reg),\n@@ -1448,9 +1411,7 @@ frv_dwarf_store (reg, offset)\n    frame-related and has a REG_FRAME_RELATED_EXPR note containing\n    DWARF_PATTERN.  */\n static void\n-frv_frame_insn (pattern, dwarf_pattern)\n-     rtx pattern;\n-     rtx dwarf_pattern;\n+frv_frame_insn (rtx pattern, rtx dwarf_pattern)\n {\n   rtx insn = emit_insn (pattern);\n   RTX_FRAME_RELATED_P (insn) = 1;\n@@ -1477,10 +1438,7 @@ frv_frame_insn (pattern, dwarf_pattern)\n    The function takes care of the moves to and from SPRs, using TEMP_REGNO\n    as a temporary in such cases.  */\n static void\n-frv_frame_access (accessor, reg, stack_offset)\n-     frv_frame_accessor_t *accessor;\n-     rtx reg;\n-     int stack_offset;\n+frv_frame_access (frv_frame_accessor_t *accessor, rtx reg, int stack_offset)\n {\n   enum machine_mode mode = GET_MODE (reg);\n   rtx mem = frv_frame_mem (mode,\n@@ -1531,10 +1489,9 @@ frv_frame_access (accessor, reg, stack_offset)\n    is the stack information generated by frv_stack_info, and REG_SET is the\n    number of the register set to transfer.  */\n static void\n-frv_frame_access_multi (accessor, info, reg_set)\n-     frv_frame_accessor_t *accessor;\n-     frv_stack_t *info;\n-     int reg_set;\n+frv_frame_access_multi (frv_frame_accessor_t *accessor,\n+                        frv_stack_t *info,\n+                        int reg_set)\n {\n   frv_stack_regs_t *regs_info;\n   int regno;\n@@ -1554,9 +1511,7 @@ frv_frame_access_multi (accessor, info, reg_set)\n    them if OP is FRV_LOAD.  INFO is the stack information generated by\n    frv_stack_info.  */\n static void\n-frv_frame_access_standard_regs (op, info)\n-     enum frv_stack_op op;\n-     frv_stack_t *info;\n+frv_frame_access_standard_regs (enum frv_stack_op op, frv_stack_t *info)\n {\n   frv_frame_accessor_t accessor;\n \n@@ -1579,7 +1534,7 @@ frv_frame_access_standard_regs (op, info)\n    Also any insns generated here should have RTX_FRAME_RELATED_P(insn) = 1\n    so that the debug info generation code can handle them properly.  */\n void\n-frv_expand_prologue ()\n+frv_expand_prologue (void)\n {\n   frv_stack_t *info = frv_stack_info ();\n   rtx sp = stack_pointer_rtx;\n@@ -1692,9 +1647,8 @@ frv_expand_prologue ()\n    this function provides a convient place to do cleanup.  */\n \n static void\n-frv_function_epilogue (file, size)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+frv_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n+                       HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   frv_stack_cache = (frv_stack_t *)0;\n \n@@ -1719,8 +1673,7 @@ frv_function_epilogue (file, size)\n    slots for arguments passed to the current function.  */\n \n void\n-frv_expand_epilogue (sibcall_p)\n-     int sibcall_p;\n+frv_expand_epilogue (int sibcall_p)\n {\n   frv_stack_t *info = frv_stack_info ();\n   rtx fp = frame_pointer_rtx;\n@@ -1821,12 +1774,11 @@ frv_expand_epilogue (sibcall_p)\n    varargs.  */\n \n static void\n-frv_asm_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n-     FILE *file;\n-     tree thunk_fndecl ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED;\n-     tree function;\n+frv_asm_output_mi_thunk (FILE *file,\n+                         tree thunk_fndecl ATTRIBUTE_UNUSED,\n+                         HOST_WIDE_INT delta,\n+                         HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n+                         tree function)\n {\n   const char *name_func = XSTR (XEXP (DECL_RTL (function), 0), 0);\n   const char *name_arg0 = reg_names[FIRST_ARG_REGNUM];\n@@ -1909,7 +1861,7 @@ frv_asm_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n /* On frv, create a frame whenever we need to create stack */\n \n int\n-frv_frame_pointer_required ()\n+frv_frame_pointer_required (void)\n {\n   if (! current_function_is_leaf)\n     return TRUE;\n@@ -1943,9 +1895,7 @@ frv_frame_pointer_required ()\n /* See frv_stack_info for more details on the frv stack frame.  */\n \n int\n-frv_initial_elimination_offset (from, to)\n-     int from;\n-     int to;\n+frv_initial_elimination_offset (int from, int to)\n {\n   frv_stack_t *info = frv_stack_info ();\n   int ret = 0;\n@@ -2002,12 +1952,11 @@ frv_initial_elimination_offset (from, to)\n    this case.  */\n \n void\n-frv_setup_incoming_varargs (cum, mode, type, pretend_size, second_time)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type ATTRIBUTE_UNUSED;\n-     int *pretend_size;\n-     int second_time;\n+frv_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n+                            enum machine_mode mode,\n+                            tree type ATTRIBUTE_UNUSED,\n+                            int *pretend_size,\n+                            int second_time)\n {\n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr,\n@@ -2026,7 +1975,7 @@ frv_setup_incoming_varargs (cum, mode, type, pretend_size, second_time)\n    the library function `__builtin_saveregs'.  */\n \n rtx\n-frv_expand_builtin_saveregs ()\n+frv_expand_builtin_saveregs (void)\n {\n   int offset = UNITS_PER_WORD * FRV_NUM_ARG_REGS;\n \n@@ -2041,9 +1990,7 @@ frv_expand_builtin_saveregs ()\n /* Expand __builtin_va_start to do the va_start macro.  */\n \n void\n-frv_expand_builtin_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg;\n+frv_expand_builtin_va_start (tree valist, rtx nextarg)\n {\n   tree t;\n   int num = cfun->args_info - FIRST_ARG_REGNUM - FRV_NUM_ARG_REGS;\n@@ -2070,9 +2017,7 @@ frv_expand_builtin_va_start (valist, nextarg)\n /* Expand __builtin_va_arg to do the va_arg macro.  */\n \n rtx\n-frv_expand_builtin_va_arg(valist, type)\n-     tree valist;\n-     tree type;\n+frv_expand_builtin_va_arg (tree valist, tree type)\n {\n   rtx addr;\n   rtx mem;\n@@ -2117,8 +2062,7 @@ frv_expand_builtin_va_arg(valist, type)\n #endif\n \n int\n-frv_expand_block_move (operands)\n-     rtx operands[];\n+frv_expand_block_move (rtx operands[])\n {\n   rtx orig_dest = operands[0];\n   rtx orig_src\t= operands[1];\n@@ -2218,8 +2162,7 @@ frv_expand_block_move (operands)\n    operands[2] is the alignment */\n \n int\n-frv_expand_block_clear (operands)\n-     rtx operands[];\n+frv_expand_block_clear (rtx operands[])\n {\n   rtx orig_dest = operands[0];\n   rtx bytes_rtx\t= operands[1];\n@@ -2291,9 +2234,7 @@ static rtx *frv_insn_operands;\n    if it is necessary. */\n \n const char *\n-frv_asm_output_opcode (f, ptr)\n-     FILE *f;\n-     const char *ptr;\n+frv_asm_output_opcode (FILE *f, const char *ptr)\n {\n   int c;\n \n@@ -2328,10 +2269,7 @@ frv_asm_output_opcode (f, ptr)\n    insns. */\n \n void\n-frv_final_prescan_insn (insn, opvec, noperands)\n-     rtx insn;\n-     rtx *opvec;\n-     int noperands ATTRIBUTE_UNUSED;\n+frv_final_prescan_insn (rtx insn, rtx *opvec, int noperands ATTRIBUTE_UNUSED)\n {\n   if (! PACKING_FLAG_USED_P())\n     return;\n@@ -2381,8 +2319,7 @@ frv_final_prescan_insn (insn, opvec, noperands)\n \n /* The default is correct, but we need to make sure the frame gets created.  */\n rtx\n-frv_dynamic_chain_address (frame)\n-     rtx frame;\n+frv_dynamic_chain_address (rtx frame)\n {\n   cfun->machine->frame_needed = 1;\n   return frame;\n@@ -2400,9 +2337,7 @@ frv_dynamic_chain_address (frame)\n    address of other frames.  */\n \n rtx\n-frv_return_addr_rtx (count, frame)\n-     int count ATTRIBUTE_UNUSED;\n-     rtx frame;\n+frv_return_addr_rtx (int count ATTRIBUTE_UNUSED, rtx frame)\n {\n   cfun->machine->frame_needed = 1;\n   return gen_rtx_MEM (Pmode, plus_constant (frame, 8));\n@@ -2417,10 +2352,7 @@ frv_return_addr_rtx (count, frame)\n    GO_IF_LEGITIMATE_ADDRESS forbids register+register addresses, which\n    this function cannot handle.  */\n rtx\n-frv_index_memory (memref, mode, index)\n-     rtx memref;\n-     enum machine_mode mode;\n-     int index;\n+frv_index_memory (rtx memref, enum machine_mode mode, int index)\n {\n   rtx base = XEXP (memref, 0);\n   if (GET_CODE (base) == PRE_MODIFY)\n@@ -2432,9 +2364,7 @@ frv_index_memory (memref, mode, index)\n \f\n /* Print a memory address as an operand to reference that memory location.  */\n void\n-frv_print_operand_address (stream, x)\n-     FILE * stream;\n-     rtx    x;\n+frv_print_operand_address (FILE * stream, rtx x)\n {\n   if (GET_CODE (x) == MEM)\n     x = XEXP (x, 0);\n@@ -2467,9 +2397,7 @@ frv_print_operand_address (stream, x)\n \n \f\n static void\n-frv_print_operand_memory_reference_reg (stream, x)\n-     FILE *stream;\n-     rtx x;\n+frv_print_operand_memory_reference_reg (FILE * stream, rtx x)\n {\n   int regno = true_regnum (x);\n   if (GPR_P (regno))\n@@ -2481,10 +2409,7 @@ frv_print_operand_memory_reference_reg (stream, x)\n /* Print a memory reference suitable for the ld/st instructions.  */\n \n static void\n-frv_print_operand_memory_reference (stream, x, addr_offset)\n-     FILE *stream;\n-     rtx x;\n-     int addr_offset;\n+frv_print_operand_memory_reference (FILE * stream, rtx x, int addr_offset)\n {\n   rtx x0 = NULL_RTX;\n   rtx x1 = NULL_RTX;\n@@ -2594,8 +2519,7 @@ frv_print_operand_memory_reference (stream, x, addr_offset)\n #define FRV_JUMP_NOT_LIKELY 0\n \n static int\n-frv_print_operand_jump_hint (insn)\n-     rtx insn;\n+frv_print_operand_jump_hint (rtx insn)\n {\n   rtx note;\n   rtx labelref;\n@@ -2692,10 +2616,7 @@ frv_print_operand_jump_hint (insn)\n    are valid with the `PRINT_OPERAND_PUNCT_VALID_P' macro.  */\n \n void\n-frv_print_operand (file, x, code)\n-     FILE * file;\n-     rtx    x;\n-     int    code;\n+frv_print_operand (FILE * file, rtx x, int code)\n {\n   HOST_WIDE_INT value;\n   int offset;\n@@ -3022,12 +2943,11 @@ frv_print_operand (file, x, code)\n    FNTYPE is nonzero, but never both of them at once.  */\n \n void\n-frv_init_cumulative_args (cum, fntype, libname, fndecl, incoming)\n-     CUMULATIVE_ARGS *cum;\n-     tree fntype;\n-     rtx libname;\n-     tree fndecl;\n-     int incoming;\n+frv_init_cumulative_args (CUMULATIVE_ARGS *cum,\n+                          tree fntype,\n+                          rtx libname,\n+                          tree fndecl,\n+                          int incoming)\n {\n   *cum = FIRST_ARG_REGNUM;\n \n@@ -3063,9 +2983,8 @@ frv_init_cumulative_args (cum, fntype, libname, fndecl, incoming)\n    `PARM_BOUNDARY' is used for all arguments.  */\n \n int\n-frv_function_arg_boundary (mode, type)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     tree type ATTRIBUTE_UNUSED;\n+frv_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n+                           tree type ATTRIBUTE_UNUSED)\n {\n   return BITS_PER_WORD;\n }\n@@ -3102,12 +3021,11 @@ frv_function_arg_boundary (mode, type)\n    stack and then loaded into a register.  */\n \n rtx\n-frv_function_arg (cum, mode, type, named, incoming)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type ATTRIBUTE_UNUSED;\n-     int named;\n-     int incoming ATTRIBUTE_UNUSED;\n+frv_function_arg (CUMULATIVE_ARGS *cum,\n+                  enum machine_mode mode,\n+                  tree type ATTRIBUTE_UNUSED,\n+                  int named,\n+                  int incoming ATTRIBUTE_UNUSED)\n {\n   enum machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n   int arg_num = *cum;\n@@ -3152,11 +3070,10 @@ frv_function_arg (cum, mode, type, named, incoming)\n    for arguments without any special help.  */\n \n void\n-frv_function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type ATTRIBUTE_UNUSED;\n-     int named;\n+frv_function_arg_advance (CUMULATIVE_ARGS *cum,\n+                          enum machine_mode mode,\n+                          tree type ATTRIBUTE_UNUSED,\n+                          int named)\n {\n   enum machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n   int bytes = GET_MODE_SIZE (xmode);\n@@ -3189,11 +3106,10 @@ frv_function_arg_advance (cum, mode, type, named)\n    the called function.  */\n \n int\n-frv_function_arg_partial_nregs (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type ATTRIBUTE_UNUSED;\n-     int named ATTRIBUTE_UNUSED;\n+frv_function_arg_partial_nregs (CUMULATIVE_ARGS *cum,\n+                                enum machine_mode mode,\n+                                tree type ATTRIBUTE_UNUSED,\n+                                int named ATTRIBUTE_UNUSED)\n {\n   enum machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n   int bytes = GET_MODE_SIZE (xmode);\n@@ -3226,11 +3142,10 @@ frv_function_arg_partial_nregs (cum, mode, type, named)\n           MUST_PASS_IN_STACK (MODE, TYPE)  */\n \n int\n-frv_function_arg_pass_by_reference (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+frv_function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+                                    enum machine_mode mode,\n+                                    tree type,\n+                                    int named ATTRIBUTE_UNUSED)\n {\n   return MUST_PASS_IN_STACK (mode, type);\n }\n@@ -3245,11 +3160,10 @@ frv_function_arg_pass_by_reference (cum, mode, type, named)\n    otherwise a copy must be made.  */\n \n int\n-frv_function_arg_callee_copies (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     tree type ATTRIBUTE_UNUSED;\n-     int named ATTRIBUTE_UNUSED;\n+frv_function_arg_callee_copies (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+                                enum machine_mode mode ATTRIBUTE_UNUSED,\n+                                tree type ATTRIBUTE_UNUSED,\n+                                int named ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n@@ -3259,11 +3173,10 @@ frv_function_arg_callee_copies (cum, mode, type, named)\n    copying it to a pseudo register.  */\n \n int\n-frv_function_arg_keep_as_reference (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     tree type ATTRIBUTE_UNUSED;\n-     int named ATTRIBUTE_UNUSED;\n+frv_function_arg_keep_as_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+                                    enum machine_mode mode ATTRIBUTE_UNUSED,\n+                                    tree type ATTRIBUTE_UNUSED,\n+                                    int named ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n@@ -3272,9 +3185,7 @@ frv_function_arg_keep_as_reference (cum, mode, type, named)\n /* Return true if a register is ok to use as a base or index register.  */\n \n static FRV_INLINE int\n-frv_regno_ok_for_base_p (regno, strict_p)\n-     int regno;\n-     int strict_p;\n+frv_regno_ok_for_base_p (int regno, int strict_p)\n {\n   if (GPR_P (regno))\n     return TRUE;\n@@ -3346,11 +3257,10 @@ frv_regno_ok_for_base_p (regno, strict_p)\n    `PRINT_OPERAND_ADDRESS'.  */\n \n int\n-frv_legitimate_address_p (mode, x, strict_p, condexec_p)\n-     enum machine_mode mode;\n-     rtx x;\n-     int strict_p;\n-     int condexec_p;\n+frv_legitimate_address_p (enum machine_mode mode,\n+                          rtx x,\n+                          int strict_p,\n+                          int condexec_p)\n {\n   rtx x0, x1;\n   int ret = 0;\n@@ -3503,10 +3413,9 @@ frv_legitimate_address_p (mode, x, strict_p, condexec_p)\n    can generate better code.  */\n \n rtx\n-frv_legitimize_address (x, oldx, mode)\n-     rtx x;\n-     rtx oldx ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+frv_legitimize_address (rtx x,\n+                        rtx oldx ATTRIBUTE_UNUSED,\n+                        enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx ret = NULL_RTX;\n \n@@ -3537,10 +3446,7 @@ frv_legitimize_address (x, oldx, mode)\n    the operand is used by a predicated instruction.  */\n \n static int\n-frv_legitimate_memory_operand (op, mode, condexec_p)\n-      rtx op;\n-      enum machine_mode mode;\n-      int condexec_p;\n+frv_legitimate_memory_operand (rtx op, enum machine_mode mode, int condexec_p)\n {\n   return ((GET_MODE (op) == mode || mode == VOIDmode)\n \t  && GET_CODE (op) == MEM\n@@ -3552,9 +3458,8 @@ frv_legitimate_memory_operand (op, mode, condexec_p)\n /* Return 1 is OP is a memory operand, or will be turned into one by\n    reload.  */\n \n-int frv_load_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+int\n+frv_load_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return FALSE;\n@@ -3575,9 +3480,8 @@ int frv_load_operand (op, mode)\n \n /* Return 1 if operand is a GPR register or a FPR register.  */\n \n-int gpr_or_fpr_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+int\n+gpr_or_fpr_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -3604,9 +3508,8 @@ int gpr_or_fpr_operand (op, mode)\n \n /* Return 1 if operand is a GPR register or 12 bit signed immediate.  */\n \n-int gpr_or_int12_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+int\n+gpr_or_int12_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return IN_RANGE_P (INTVAL (op), -2048, 2047);\n@@ -3631,9 +3534,8 @@ int gpr_or_int12_operand (op, mode)\n /* Return 1 if operand is a GPR register, or a FPR register, or a 12 bit\n    signed immediate.  */\n \n-int gpr_fpr_or_int12_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+int\n+gpr_fpr_or_int12_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -3663,9 +3565,8 @@ int gpr_fpr_or_int12_operand (op, mode)\n \n /* Return 1 if operand is a register or 6 bit signed immediate.  */\n \n-int fpr_or_int6_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+int\n+fpr_or_int6_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return IN_RANGE_P (INTVAL (op), -32, 31);\n@@ -3689,9 +3590,8 @@ int fpr_or_int6_operand (op, mode)\n \n /* Return 1 if operand is a register or 10 bit signed immediate.  */\n \n-int gpr_or_int10_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+int\n+gpr_or_int10_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return IN_RANGE_P (INTVAL (op), -512, 511);\n@@ -3715,9 +3615,8 @@ int gpr_or_int10_operand (op, mode)\n \n /* Return 1 if operand is a register or an integer immediate.  */\n \n-int gpr_or_int_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+int\n+gpr_or_int_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return TRUE;\n@@ -3741,9 +3640,8 @@ int gpr_or_int_operand (op, mode)\n \n /* Return 1 if operand is a 12 bit signed immediate.  */\n \n-int int12_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode ATTRIBUTE_UNUSED;\n+int\n+int12_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != CONST_INT)\n     return FALSE;\n@@ -3753,9 +3651,8 @@ int int12_operand (op, mode)\n \n /* Return 1 if operand is a 6 bit signed immediate.  */\n \n-int int6_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode ATTRIBUTE_UNUSED;\n+int\n+int6_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != CONST_INT)\n     return FALSE;\n@@ -3765,46 +3662,41 @@ int int6_operand (op, mode)\n \n /* Return 1 if operand is a 5 bit signed immediate.  */\n \n-int int5_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode ATTRIBUTE_UNUSED;\n+int\n+int5_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == CONST_INT && IN_RANGE_P (INTVAL (op), -16, 15);\n }\n \n /* Return 1 if operand is a 5 bit unsigned immediate.  */\n \n-int uint5_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode ATTRIBUTE_UNUSED;\n+int\n+uint5_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == CONST_INT && IN_RANGE_P (INTVAL (op), 0, 31);\n }\n \n /* Return 1 if operand is a 4 bit unsigned immediate.  */\n \n-int uint4_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode ATTRIBUTE_UNUSED;\n+int\n+uint4_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == CONST_INT && IN_RANGE_P (INTVAL (op), 0, 15);\n }\n \n /* Return 1 if operand is a 1 bit unsigned immediate (0 or 1).  */\n \n-int uint1_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode ATTRIBUTE_UNUSED;\n+int\n+uint1_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == CONST_INT && IN_RANGE_P (INTVAL (op), 0, 1);\n }\n \n /* Return 1 if operand is an integer constant that takes 2 instructions\n    to load up and can be split into sethi/setlo instructions..  */\n \n-int int_2word_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode ATTRIBUTE_UNUSED;\n+int\n+int_2word_operand(rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT value;\n   REAL_VALUE_TYPE rv;\n@@ -3850,9 +3742,7 @@ int int_2word_operand (op, mode)\n \n /* Return 1 if operand is the pic address register.  */\n int\n-pic_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+pic_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (! flag_pic)\n     return FALSE;\n@@ -3869,9 +3759,8 @@ pic_register_operand (op, mode)\n /* Return 1 if operand is a symbolic reference when a PIC option is specified\n    that takes 3 seperate instructions to form.  */\n \n-int pic_symbolic_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode ATTRIBUTE_UNUSED;\n+int\n+pic_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (! flag_pic)\n     return FALSE;\n@@ -3898,9 +3787,7 @@ int pic_symbolic_operand (op, mode)\n \n /* Return 1 if operand is the small data register.  */\n int\n-small_data_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+small_data_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != REG)\n     return FALSE;\n@@ -3914,9 +3801,8 @@ small_data_register_operand (op, mode)\n /* Return 1 if operand is a symbolic reference to a small data area static or\n    global object.  */\n \n-int small_data_symbolic_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode ATTRIBUTE_UNUSED;\n+int\n+small_data_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n@@ -3935,9 +3821,8 @@ int small_data_symbolic_operand (op, mode)\n \n /* Return 1 if operand is a 16 bit unsigned immediate */\n \n-int uint16_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode ATTRIBUTE_UNUSED;\n+int\n+uint16_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != CONST_INT)\n     return FALSE;\n@@ -3947,9 +3832,8 @@ int uint16_operand (op, mode)\n \n /* Return 1 if operand is an integer constant with the bottom 16 bits clear */\n \n-int upper_int16_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode ATTRIBUTE_UNUSED;\n+int\n+upper_int16_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != CONST_INT)\n     return FALSE;\n@@ -3960,9 +3844,7 @@ int upper_int16_operand (op, mode)\n /* Return true if operand is a GPR register. */\n \n int\n-integer_register_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+integer_register_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return FALSE;\n@@ -3985,9 +3867,7 @@ integer_register_operand (op, mode)\n    here, in order to prevent a combine bug.  */\n \n int\n-gpr_no_subreg_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+gpr_no_subreg_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return FALSE;\n@@ -4001,9 +3881,7 @@ gpr_no_subreg_operand (op, mode)\n /* Return true if operand is a FPR register. */\n \n int\n-fpr_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+fpr_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return FALSE;\n@@ -4025,9 +3903,7 @@ fpr_operand (op, mode)\n /* Return true if operand is an even GPR or FPR register. */\n \n int\n-even_reg_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+even_reg_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4061,9 +3937,7 @@ even_reg_operand (op, mode)\n /* Return true if operand is an odd GPR register. */\n \n int\n-odd_reg_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+odd_reg_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4098,9 +3972,7 @@ odd_reg_operand (op, mode)\n /* Return true if operand is an even GPR register. */\n \n int\n-even_gpr_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+even_gpr_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4131,9 +4003,7 @@ even_gpr_operand (op, mode)\n /* Return true if operand is an odd GPR register. */\n \n int\n-odd_gpr_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+odd_gpr_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4165,9 +4035,7 @@ odd_gpr_operand (op, mode)\n /* Return true if operand is a quad aligned FPR register. */\n \n int\n-quad_fpr_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+quad_fpr_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4198,9 +4066,7 @@ quad_fpr_operand (op, mode)\n /* Return true if operand is an even FPR register. */\n \n int\n-even_fpr_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+even_fpr_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4231,9 +4097,7 @@ even_fpr_operand (op, mode)\n /* Return true if operand is an odd FPR register. */\n \n int\n-odd_fpr_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+odd_fpr_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4270,9 +4134,7 @@ odd_fpr_operand (op, mode)\n    the stack and the address taken and passed through to another function.  */\n \n int\n-dbl_memory_one_insn_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+dbl_memory_one_insn_operand (rtx op, enum machine_mode mode)\n {\n   rtx addr;\n   rtx addr_reg;\n@@ -4323,9 +4185,7 @@ dbl_memory_one_insn_operand (op, mode)\n    use two instructions to load or store.  */\n \n int\n-dbl_memory_two_insn_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+dbl_memory_two_insn_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) != MEM)\n     return FALSE;\n@@ -4343,9 +4203,7 @@ dbl_memory_two_insn_operand (op, mode)\n    operation.  */\n \n int\n-move_destination_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+move_destination_operand (rtx op, enum machine_mode mode)\n {\n   rtx subreg;\n   enum rtx_code code;\n@@ -4387,9 +4245,7 @@ move_destination_operand (op, mode)\n    operation.  */\n \n int\n-move_source_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+move_source_operand (rtx op, enum machine_mode mode)\n {\n   rtx subreg;\n   enum rtx_code code;\n@@ -4438,9 +4294,7 @@ move_source_operand (op, mode)\n    move operation.  */\n \n int\n-condexec_dest_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+condexec_dest_operand (rtx op, enum machine_mode mode)\n {\n   rtx subreg;\n   enum rtx_code code;\n@@ -4482,9 +4336,7 @@ condexec_dest_operand (op, mode)\n    move operation.  */\n \n int\n-condexec_source_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+condexec_source_operand (rtx op, enum machine_mode mode)\n {\n   rtx subreg;\n   enum rtx_code code;\n@@ -4530,9 +4382,7 @@ condexec_source_operand (op, mode)\n    appropriate type.  */\n \n int\n-reg_or_0_operand (op, mode)\n-     rtx op;\n-      enum machine_mode mode;\n+reg_or_0_operand (rtx op, enum machine_mode mode)\n {\n   switch (GET_CODE (op))\n     {\n@@ -4557,9 +4407,7 @@ reg_or_0_operand (op, mode)\n /* Return true if operand is the link register */\n \n int\n-lr_operand (op, mode)\n-     rtx op;\n-      enum machine_mode mode;\n+lr_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) != REG)\n     return FALSE;\n@@ -4576,9 +4424,7 @@ lr_operand (op, mode)\n /* Return true if operand is a gpr register or a valid memory operation.  */\n \n int\n-gpr_or_memory_operand (op, mode)\n-     rtx op;\n-      enum machine_mode mode;\n+gpr_or_memory_operand (rtx op, enum machine_mode mode)\n {\n   return (integer_register_operand (op, mode)\n \t  || frv_legitimate_memory_operand (op, mode, FALSE));\n@@ -4587,9 +4433,7 @@ gpr_or_memory_operand (op, mode)\n /* Return true if operand is a fpr register or a valid memory operation.  */\n \n int\n-fpr_or_memory_operand (op, mode)\n-     rtx op;\n-      enum machine_mode mode;\n+fpr_or_memory_operand (rtx op, enum machine_mode mode)\n {\n   return (fpr_operand (op, mode)\n \t  || frv_legitimate_memory_operand (op, mode, FALSE));\n@@ -4598,9 +4442,7 @@ fpr_or_memory_operand (op, mode)\n /* Return true if operand is an icc register */\n \n int\n-icc_operand (op, mode)\n-     rtx op;\n-      enum machine_mode mode;\n+icc_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4617,9 +4459,7 @@ icc_operand (op, mode)\n /* Return true if operand is an fcc register */\n \n int\n-fcc_operand (op, mode)\n-     rtx op;\n-      enum machine_mode mode;\n+fcc_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4636,9 +4476,7 @@ fcc_operand (op, mode)\n /* Return true if operand is either an fcc or icc register */\n \n int\n-cc_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+cc_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4658,9 +4496,7 @@ cc_operand (op, mode)\n /* Return true if operand is an integer CCR register */\n \n int\n-icr_operand (op, mode)\n-     rtx op;\n-      enum machine_mode mode;\n+icr_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4677,9 +4513,7 @@ icr_operand (op, mode)\n /* Return true if operand is an fcc register */\n \n int\n-fcr_operand (op, mode)\n-     rtx op;\n-      enum machine_mode mode;\n+fcr_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4696,9 +4530,7 @@ fcr_operand (op, mode)\n /* Return true if operand is either an fcc or icc register */\n \n int\n-cr_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+cr_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -4718,9 +4550,7 @@ cr_operand (op, mode)\n /* Return true if operand is a memory reference suitable for a call.  */\n \n int\n-call_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+call_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode && GET_CODE (op) != CONST_INT)\n     return FALSE;\n@@ -4738,9 +4568,7 @@ call_operand (op, mode)\n /* Return true if operator is a kind of relational operator.  */\n \n int\n-relational_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+relational_operator (rtx op, enum machine_mode mode)\n {\n   rtx op0;\n   rtx op1;\n@@ -4798,9 +4626,7 @@ relational_operator (op, mode)\n /* Return true if operator is a signed integer relational operator */\n \n int\n-signed_relational_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+signed_relational_operator (rtx op, enum machine_mode mode)\n {\n   rtx op0;\n   rtx op1;\n@@ -4844,9 +4670,7 @@ signed_relational_operator (op, mode)\n /* Return true if operator is a signed integer relational operator */\n \n int\n-unsigned_relational_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+unsigned_relational_operator (rtx op, enum machine_mode mode)\n {\n   rtx op0;\n   rtx op1;\n@@ -4888,9 +4712,7 @@ unsigned_relational_operator (op, mode)\n /* Return true if operator is a floating point relational operator */\n \n int\n-float_relational_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+float_relational_operator (rtx op, enum machine_mode mode)\n {\n   rtx op0;\n   rtx op1;\n@@ -4938,9 +4760,7 @@ float_relational_operator (op, mode)\n /* Return true if operator is EQ/NE of a conditional execution register.  */\n \n int\n-ccr_eqne_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+ccr_eqne_operator (rtx op, enum machine_mode mode)\n {\n   enum machine_mode op_mode = GET_MODE (op);\n   rtx op0;\n@@ -4979,9 +4799,7 @@ ccr_eqne_operator (op, mode)\n    unsigned).  */\n \n int\n-minmax_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+minmax_operator (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && mode != GET_MODE (op))\n     return FALSE;\n@@ -5011,9 +4829,7 @@ minmax_operator (op, mode)\n    conditionally and takes 1 cycle.  */\n \n int\n-condexec_si_binary_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+condexec_si_binary_operator (rtx op, enum machine_mode mode)\n {\n   enum machine_mode op_mode = GET_MODE (op);\n \n@@ -5041,9 +4857,7 @@ condexec_si_binary_operator (op, mode)\n    executed conditionally by a media instruction.  */\n \n int\n-condexec_si_media_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+condexec_si_media_operator (rtx op, enum machine_mode mode)\n {\n   enum machine_mode op_mode = GET_MODE (op);\n \n@@ -5066,9 +4880,7 @@ condexec_si_media_operator (op, mode)\n    conditionally.  */\n \n int\n-condexec_si_divide_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+condexec_si_divide_operator (rtx op, enum machine_mode mode)\n {\n   enum machine_mode op_mode = GET_MODE (op);\n \n@@ -5090,9 +4902,7 @@ condexec_si_divide_operator (op, mode)\n    conditionally.  */\n \n int\n-condexec_si_unary_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+condexec_si_unary_operator (rtx op, enum machine_mode mode)\n {\n   enum machine_mode op_mode = GET_MODE (op);\n \n@@ -5114,9 +4924,7 @@ condexec_si_unary_operator (op, mode)\n    evaluated conditionally by floating-point instructions.  */\n \n int\n-condexec_sf_conv_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+condexec_sf_conv_operator (rtx op, enum machine_mode mode)\n {\n   enum machine_mode op_mode = GET_MODE (op);\n \n@@ -5139,9 +4947,7 @@ condexec_sf_conv_operator (op, mode)\n    instructions.  */\n \n int\n-condexec_sf_add_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+condexec_sf_add_operator (rtx op, enum machine_mode mode)\n {\n   enum machine_mode op_mode = GET_MODE (op);\n \n@@ -5163,9 +4969,7 @@ condexec_sf_add_operator (op, mode)\n    executed.  */\n \n int\n-condexec_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+condexec_memory_operand (rtx op, enum machine_mode mode)\n {\n   enum machine_mode op_mode = GET_MODE (op);\n   rtx addr;\n@@ -5202,9 +5006,7 @@ condexec_memory_operand (op, mode)\n    register.  */\n \n int\n-intop_compare_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+intop_compare_operator (rtx op, enum machine_mode mode)\n {\n   enum machine_mode op_mode = GET_MODE (op);\n \n@@ -5237,9 +5039,7 @@ intop_compare_operator (op, mode)\n    with a setcc operation inside of a conditional execution.  */\n \n int\n-condexec_intop_cmp_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+condexec_intop_cmp_operator (rtx op, enum machine_mode mode)\n {\n   enum machine_mode op_mode = GET_MODE (op);\n \n@@ -5271,9 +5071,7 @@ condexec_intop_cmp_operator (op, mode)\n /* Return 1 if operand is a valid ACC register number */\n \n int\n-acc_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+acc_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -5298,9 +5096,7 @@ acc_operand (op, mode)\n /* Return 1 if operand is a valid even ACC register number */\n \n int\n-even_acc_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+even_acc_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -5325,9 +5121,7 @@ even_acc_operand (op, mode)\n /* Return 1 if operand is zero or four */\n \n int\n-quad_acc_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+quad_acc_operand (rtx op, enum machine_mode mode)\n {\n   int regno;\n \n@@ -5352,9 +5146,7 @@ quad_acc_operand (op, mode)\n /* Return 1 if operand is a valid ACCG register number */\n \n int\n-accg_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+accg_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return FALSE;\n@@ -5378,7 +5170,7 @@ accg_operand (op, mode)\n    epilog code.  For frv, we only do it if there was no stack allocation.  */\n \n int\n-direct_return_p ()\n+direct_return_p (void)\n {\n   frv_stack_t *info;\n \n@@ -5395,9 +5187,7 @@ direct_return_p ()\n    instructions are emitted.  */\n \n int\n-frv_emit_movsi (dest, src)\n-     rtx dest;\n-     rtx src;\n+frv_emit_movsi (rtx dest, rtx src)\n {\n   int base_regno = -1;\n \n@@ -5468,9 +5258,7 @@ frv_emit_movsi (dest, src)\n /* Return a string to output a single word move.  */\n \n const char *\n-output_move_single (operands, insn)\n-     rtx operands[];\n-     rtx insn;\n+output_move_single (rtx operands[], rtx insn)\n {\n   rtx dest = operands[0];\n   rtx src  = operands[1];\n@@ -5688,9 +5476,7 @@ output_move_single (operands, insn)\n /* Return a string to output a double word move.  */\n \n const char *\n-output_move_double (operands, insn)\n-     rtx operands[];\n-     rtx insn;\n+output_move_double (rtx operands[], rtx insn)\n {\n   rtx dest = operands[0];\n   rtx src  = operands[1];\n@@ -5821,9 +5607,7 @@ output_move_double (operands, insn)\n    Operand3 -- source  */\n \n const char *\n-output_condmove_single (operands, insn)\n-     rtx operands[];\n-     rtx insn;\n+output_condmove_single (rtx operands[], rtx insn)\n {\n   rtx dest = operands[2];\n   rtx src  = operands[3];\n@@ -5962,10 +5746,7 @@ output_condmove_single (operands, insn)\n    comparison was done it.  */\n \n static rtx\n-frv_emit_comparison (test, op0, op1)\n-     enum rtx_code test;\n-     rtx op0;\n-     rtx op1;\n+frv_emit_comparison (enum rtx_code test, rtx op0, rtx op1)\n {\n   enum machine_mode cc_mode;\n   rtx cc_reg;\n@@ -5996,9 +5777,7 @@ frv_emit_comparison (test, op0, op1)\n    conditional execution, but that confuses the rest of the compiler.  */\n \n int\n-frv_emit_cond_branch (test, label)\n-     enum rtx_code test;\n-     rtx label;\n+frv_emit_cond_branch (enum rtx_code test, rtx label)\n {\n   rtx test_rtx;\n   rtx label_ref;\n@@ -6023,9 +5802,7 @@ frv_emit_cond_branch (test, label)\n    operands were previously stored in frv_compare_op0 and frv_compare_op1.  */\n \n int\n-frv_emit_scc (test, target)\n-     enum rtx_code test;\n-     rtx target;\n+frv_emit_scc (enum rtx_code test, rtx target)\n {\n   rtx set;\n   rtx test_rtx;\n@@ -6056,12 +5833,7 @@ frv_emit_scc (test, target)\n    the seperate insns.  */\n \n rtx\n-frv_split_scc (dest, test, cc_reg, cr_reg, value)\n-     rtx dest;\n-     rtx test;\n-     rtx cc_reg;\n-     rtx cr_reg;\n-     HOST_WIDE_INT value;\n+frv_split_scc (rtx dest, rtx test, rtx cc_reg, rtx cr_reg, HOST_WIDE_INT value)\n {\n   rtx ret;\n \n@@ -6096,11 +5868,7 @@ frv_split_scc (dest, test, cc_reg, cr_reg, value)\n    move.  */\n \n int\n-frv_emit_cond_move (dest, test_rtx, src1, src2)\n-     rtx dest;\n-     rtx test_rtx;\n-     rtx src1;\n-     rtx src2;\n+frv_emit_cond_move (rtx dest, rtx test_rtx, rtx src1, rtx src2)\n {\n   rtx set;\n   rtx clobber_cc;\n@@ -6177,8 +5945,7 @@ frv_emit_cond_move (dest, test_rtx, src1, src2)\n    containing all of the insns.  */\n \n rtx\n-frv_split_cond_move (operands)\n-     rtx operands[];\n+frv_split_cond_move (rtx operands[])\n {\n   rtx dest\t= operands[0];\n   rtx test\t= operands[1];\n@@ -6273,9 +6040,7 @@ frv_split_cond_move (operands)\n /* Split (set DEST SOURCE), where DEST is a double register and SOURCE is a\n    memory location that is not known to be dword-aligned.  */\n void\n-frv_split_double_load (dest, source)\n-     rtx dest;\n-     rtx source;\n+frv_split_double_load (rtx dest, rtx source)\n {\n   int regno = REGNO (dest);\n   rtx dest1 = gen_highpart (SImode, dest);\n@@ -6311,9 +6076,7 @@ frv_split_double_load (dest, source)\n /* Split (set DEST SOURCE), where DEST refers to a dword memory location\n    and SOURCE is either a double register or the constant zero.  */\n void\n-frv_split_double_store (dest, source)\n-     rtx dest;\n-     rtx source;\n+frv_split_double_store (rtx dest, rtx source)\n {\n   rtx dest1 = change_address (dest, SImode, NULL);\n   rtx dest2 = frv_index_memory (dest, SImode, 1);\n@@ -6334,8 +6097,7 @@ frv_split_double_store (dest, source)\n    insns.  */\n \n rtx\n-frv_split_minmax (operands)\n-     rtx operands[];\n+frv_split_minmax (rtx operands[])\n {\n   rtx dest\t= operands[0];\n   rtx minmax\t= operands[1];\n@@ -6415,8 +6177,7 @@ frv_split_minmax (operands)\n    insns.  */\n \n rtx\n-frv_split_abs (operands)\n-     rtx operands[];\n+frv_split_abs (rtx operands[])\n {\n   rtx dest\t= operands[0];\n   rtx src\t= operands[1];\n@@ -6458,9 +6219,7 @@ frv_split_abs (operands)\n    register used in an insn.  */\n \n static int\n-frv_clear_registers_used (ptr, data)\n-     rtx *ptr;\n-     void *data;\n+frv_clear_registers_used (rtx *ptr, void *data)\n {\n   if (GET_CODE (*ptr) == REG)\n     {\n@@ -6488,8 +6247,7 @@ frv_clear_registers_used (ptr, data)\n /* On the FR-V, we don't have any extra fields per se, but it is useful hook to\n    initialize the static storage.  */\n void\n-frv_ifcvt_init_extra_fields (ce_info)\n-     ce_if_block_t *ce_info ATTRIBUTE_UNUSED;\n+frv_ifcvt_init_extra_fields (ce_if_block_t *ce_info ATTRIBUTE_UNUSED)\n {\n   frv_ifcvt.added_insns_list = NULL_RTX;\n   frv_ifcvt.cur_scratch_regs = 0;\n@@ -6506,10 +6264,7 @@ frv_ifcvt_init_extra_fields (ce_info)\n    if the conditional execution conversion is successful.  */\n \n static void\n-frv_ifcvt_add_insn (pattern, insn, before_p)\n-     rtx pattern;\n-     rtx insn;\n-     int before_p;\n+frv_ifcvt_add_insn (rtx pattern, rtx insn, int before_p)\n {\n   rtx link = alloc_EXPR_LIST (VOIDmode, pattern, insn);\n \n@@ -6536,10 +6291,7 @@ frv_ifcvt_add_insn (pattern, insn, before_p)\n    tests cannot be converted.  */\n \n void\n-frv_ifcvt_modify_tests (ce_info, p_true, p_false)\n-     ce_if_block_t *ce_info;\n-     rtx *p_true;\n-     rtx *p_false;\n+frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n {\n   basic_block test_bb = ce_info->test_bb;\t/* test basic block */\n   basic_block then_bb = ce_info->then_bb;\t/* THEN */\n@@ -6893,11 +6645,10 @@ frv_ifcvt_modify_tests (ce_info, p_true, p_false)\n \t\t    (const_int 0))) */\n \n void\n-frv_ifcvt_modify_multiple_tests (ce_info, bb, p_true, p_false)\n-     ce_if_block_t *ce_info;\n-     basic_block bb;\n-     rtx *p_true;\n-     rtx *p_false;\n+frv_ifcvt_modify_multiple_tests (ce_if_block_t *ce_info,\n+                                 basic_block bb,\n+                                 rtx *p_true,\n+                                 rtx *p_false)\n {\n   rtx old_true = XEXP (*p_true, 0);\n   rtx old_false = XEXP (*p_false, 0);\n@@ -7026,9 +6777,7 @@ frv_ifcvt_modify_multiple_tests (ce_info, bb, p_true, p_false)\n    that use constants to ones that just use registers.  */\n \n static rtx\n-frv_ifcvt_load_value (value, insn)\n-     rtx value;\n-     rtx insn ATTRIBUTE_UNUSED;\n+frv_ifcvt_load_value (rtx value, rtx insn ATTRIBUTE_UNUSED)\n {\n   int num_alloc = frv_ifcvt.cur_scratch_regs;\n   int i;\n@@ -7098,10 +6847,7 @@ frv_ifcvt_load_value (value, insn)\n    into a temporary register, or the new MEM if we were successful.  */\n \n static rtx\n-frv_ifcvt_rewrite_mem (mem, mode, insn)\n-     rtx mem;\n-     enum machine_mode mode;\n-     rtx insn;\n+frv_ifcvt_rewrite_mem (rtx mem, enum machine_mode mode, rtx insn)\n {\n   rtx addr = XEXP (mem, 0);\n \n@@ -7149,8 +6895,7 @@ frv_ifcvt_rewrite_mem (mem, mode, insn)\n    SET, possibly conditionally executed.  It may also have CLOBBERs, USEs.  */\n \n static rtx\n-single_set_pattern (pattern)\n-     rtx pattern;\n+single_set_pattern (rtx pattern)\n {\n   rtx set;\n   int i;\n@@ -7197,10 +6942,9 @@ single_set_pattern (pattern)\n    insn cannot be converted to be executed conditionally.  */\n \n rtx\n-frv_ifcvt_modify_insn (ce_info, pattern, insn)\n-     ce_if_block_t *ce_info ATTRIBUTE_UNUSED;\n-     rtx pattern;\n-     rtx insn;\n+frv_ifcvt_modify_insn (ce_if_block_t *ce_info ATTRIBUTE_UNUSED,\n+                       rtx pattern,\n+                       rtx insn)\n {\n   rtx orig_ce_pattern = pattern;\n   rtx set;\n@@ -7452,8 +7196,7 @@ frv_ifcvt_modify_insn (ce_info, pattern, insn)\n    conditional if information CE_INFO.  */\n \n void\n-frv_ifcvt_modify_final (ce_info)\n-     ce_if_block_t *ce_info ATTRIBUTE_UNUSED;\n+frv_ifcvt_modify_final (ce_if_block_t *ce_info ATTRIBUTE_UNUSED)\n {\n   rtx existing_insn;\n   rtx check_insn;\n@@ -7509,8 +7252,7 @@ frv_ifcvt_modify_final (ce_info)\n    information CE_INFO.  */\n \n void\n-frv_ifcvt_modify_cancel (ce_info)\n-     ce_if_block_t *ce_info ATTRIBUTE_UNUSED;\n+frv_ifcvt_modify_cancel (ce_if_block_t *ce_info ATTRIBUTE_UNUSED)\n {\n   int i;\n   rtx p = frv_ifcvt.added_insns_list;\n@@ -7545,7 +7287,7 @@ frv_ifcvt_modify_cancel (ce_info)\n \tjmpl @(gr0,<jmp_reg>) */\n \n int\n-frv_trampoline_size ()\n+frv_trampoline_size (void)\n {\n   return 5 /* instructions */ * 4 /* instruction size */;\n }\n@@ -7565,10 +7307,7 @@ frv_trampoline_size ()\n \tjmpl @(gr0,<jmp_reg>) */\n \n void\n-frv_initialize_trampoline (addr, fnaddr, static_chain)\n-     rtx addr;\n-     rtx fnaddr;\n-     rtx static_chain;\n+frv_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)\n {\n   rtx sc_reg = force_reg (Pmode, static_chain);\n \n@@ -7634,11 +7373,10 @@ frv_initialize_trampoline (addr, fnaddr, static_chain)\n    This case often occurs between floating-point and general registers.  */\n \n enum reg_class\n-frv_secondary_reload_class (class, mode, x, in_p)\n-     enum reg_class class;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx x;\n-     int in_p ATTRIBUTE_UNUSED;\n+frv_secondary_reload_class (enum reg_class class,\n+                            enum machine_mode mode ATTRIBUTE_UNUSED,\n+                            rtx x,\n+                            int in_p ATTRIBUTE_UNUSED)\n {\n   enum reg_class ret;\n \n@@ -7714,8 +7452,7 @@ frv_secondary_reload_class (class, mode, x, in_p)\n    register allocation.  */\n \n int\n-frv_class_likely_spilled_p (class)\n-     enum reg_class class;\n+frv_class_likely_spilled_p (enum reg_class class)\n {\n   switch (class)\n     {\n@@ -7790,13 +7527,8 @@ frv_class_likely_spilled_p (class)\n */\n \n int\n-frv_adjust_field_align (field, computed)\n-     tree field;\n-     int computed;\n+frv_adjust_field_align (tree field, int computed)\n {\n-\n-  tree type = TREE_TYPE (field);\n-\n   /* Make sure that the bitfield is not wider than the type.  */\n   if (DECL_BIT_FIELD (field)\n       && !DECL_ARTIFICIAL (field))\n@@ -7889,9 +7621,7 @@ frv_adjust_field_align (field, computed)\n    pattern's constraint asks for one.  */\n \n int\n-frv_hard_regno_mode_ok (regno, mode)\n-     int regno;\n-     enum machine_mode mode;\n+frv_hard_regno_mode_ok (int regno, enum machine_mode mode)\n {\n   int base;\n   int mask;\n@@ -7973,9 +7703,7 @@ frv_hard_regno_mode_ok (regno, mode)\n    for each byte.  */\n \n int\n-frv_hard_regno_nregs (regno, mode)\n-     int regno;\n-     enum machine_mode mode;\n+frv_hard_regno_nregs (int regno, enum machine_mode mode)\n {\n   if (ACCG_P (regno))\n     return GET_MODE_SIZE (mode);\n@@ -7997,9 +7725,7 @@ frv_hard_regno_nregs (regno, mode)\n    This declaration is required.  */\n \n int\n-frv_class_max_nregs (class, mode)\n-     enum reg_class class;\n-     enum machine_mode mode;\n+frv_class_max_nregs (enum reg_class class, enum machine_mode mode)\n {\n   if (class == ACCG_REGS)\n     /* An N-byte value requires N accumulator guards.  */\n@@ -8015,8 +7741,7 @@ frv_class_max_nregs (class, mode)\n    definition for this macro on machines where anything `CONSTANT_P' is valid.  */\n \n int\n-frv_legitimate_constant_p (x)\n-     rtx x;\n+frv_legitimate_constant_p (rtx x)\n {\n   enum machine_mode mode = GET_MODE (x);\n \n@@ -8065,9 +7790,7 @@ frv_legitimate_constant_p (x)\n #define LOW_COST 1\n \n int\n-frv_register_move_cost (from, to)\n-     enum reg_class from;\n-     enum reg_class to;\n+frv_register_move_cost (enum reg_class from, enum reg_class to)\n {\n   switch (from)\n     {\n@@ -8156,10 +7879,7 @@ frv_register_move_cost (from, to)\n    need a fixup entry for aligned (non-debugging) code.  */\n \n static bool\n-frv_assemble_integer (value, size, aligned_p)\n-     rtx value;\n-     unsigned int size;\n-     int aligned_p;\n+frv_assemble_integer (rtx value, unsigned int size, int aligned_p)\n {\n   if (flag_pic && size == UNITS_PER_WORD)\n     {\n@@ -8198,7 +7918,7 @@ frv_assemble_integer (value, size, aligned_p)\n /* Function to set up the backend function structure.  */\n \n static struct machine_function *\n-frv_init_machine_status ()\n+frv_init_machine_status (void)\n {\n   return ggc_alloc_cleared (sizeof (struct machine_function));\n }\n@@ -8241,12 +7961,11 @@ frv_use_dfa_pipeline_interface (void)\n    or clobbered.  */\n \n static void\n-frv_registers_update (x, reg_state, modified, p_num_mod, flag)\n-     rtx x;\n-     unsigned char reg_state[];\n-     int modified[];\n-     int *p_num_mod;\n-     int flag;\n+frv_registers_update (rtx x,\n+                      unsigned char reg_state[],\n+                      int modified[],\n+                      int *p_num_mod,\n+                      int flag)\n {\n   int regno, reg_max;\n   rtx reg;\n@@ -8389,10 +8108,7 @@ frv_registers_update (x, reg_state, modified, p_num_mod, flag)\n /* Return if any registers in a hard register set were used an insn.  */\n \n static int\n-frv_registers_used_p (x, reg_state, flag)\n-     rtx x;\n-     unsigned char reg_state[];\n-     int flag;\n+frv_registers_used_p (rtx x, unsigned char reg_state[], int flag)\n {\n   int regno, reg_max;\n   rtx reg;\n@@ -8549,10 +8265,7 @@ frv_registers_used_p (x, reg_state, flag)\n /* Return if any registers in a hard register set were set in an insn.  */\n \n static int\n-frv_registers_set_p (x, reg_state, modify_p)\n-     rtx x;\n-     unsigned char reg_state[];\n-     int modify_p;\n+frv_registers_set_p (rtx x, unsigned char reg_state[], int modify_p)\n {\n   int regno, reg_max;\n   rtx reg;\n@@ -8663,7 +8376,7 @@ frv_registers_set_p (x, reg_state, modify_p)\n    information in a reasonable state.  */\n \n static void\n-frv_pack_insns ()\n+frv_pack_insns (void)\n {\n   state_t frv_state;\t\t\t/* frv state machine */\n   int cur_start_vliw_p;\t\t\t/* current insn starts a VLIW insn */\n@@ -8970,7 +8683,7 @@ static struct builtin_description bdesc_voidacc[] =\n /* Initialize media builtins. */\n \n static void\n-frv_init_builtins ()\n+frv_init_builtins (void)\n {\n   tree endlink = void_list_node;\n   tree accumulator = integer_type_node;\n@@ -9176,10 +8889,7 @@ frv_init_libfuncs (void)\n    instruction.  */\n \n static rtx\n-frv_int_to_acc (icode, opnum, opval)\n-     enum insn_code icode;\n-     int opnum;\n-     rtx opval;\n+frv_int_to_acc (enum insn_code icode, int opnum, rtx opval)\n {\n   rtx reg;\n \n@@ -9211,8 +8921,7 @@ frv_int_to_acc (icode, opnum, opval)\n    should have.  */\n \n static enum machine_mode\n-frv_matching_accg_mode (mode)\n-     enum machine_mode mode;\n+frv_matching_accg_mode (enum machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -9235,8 +8944,7 @@ frv_matching_accg_mode (mode)\n    class as ACC, but is four times smaller.  */\n \n rtx\n-frv_matching_accg_for_acc (acc)\n-     rtx acc;\n+frv_matching_accg_for_acc (rtx acc)\n {\n   return gen_rtx_REG (frv_matching_accg_mode (GET_MODE (acc)),\n \t\t      REGNO (acc) - ACC_FIRST + ACCG_FIRST);\n@@ -9247,8 +8955,7 @@ frv_matching_accg_for_acc (acc)\n    list.  */\n \n static rtx\n-frv_read_argument (arglistptr)\n-     tree *arglistptr;\n+frv_read_argument (tree *arglistptr)\n {\n   tree next = TREE_VALUE (*arglistptr);\n   *arglistptr = TREE_CHAIN (*arglistptr);\n@@ -9260,10 +8967,7 @@ frv_read_argument (arglistptr)\n    function prints an error if OPVAL is not valid.  */\n \n static int\n-frv_check_constant_argument (icode, opnum, opval)\n-     enum insn_code icode;\n-     int opnum;\n-     rtx opval;\n+frv_check_constant_argument (enum insn_code icode, int opnum, rtx opval)\n {\n   if (GET_CODE (opval) != CONST_INT)\n     {\n@@ -9283,9 +8987,7 @@ frv_check_constant_argument (icode, opnum, opval)\n    predicate.  */\n \n static rtx\n-frv_legitimize_target (icode, target)\n-     enum insn_code icode;\n-     rtx target;\n+frv_legitimize_target (enum insn_code icode, rtx target)\n {\n   enum machine_mode mode = insn_data[icode].operand[0].mode;\n \n@@ -9303,10 +9005,7 @@ frv_legitimize_target (icode, target)\n    itself.  */\n \n static rtx\n-frv_legitimize_argument (icode, opnum, arg)\n-     enum insn_code icode;\n-     int opnum;\n-     rtx arg;\n+frv_legitimize_argument (enum insn_code icode, int opnum, rtx arg)\n {\n   enum machine_mode mode = insn_data[icode].operand[opnum].mode;\n \n@@ -9320,10 +9019,7 @@ frv_legitimize_argument (icode, opnum, arg)\n    only MHDSETS falls into this category.  */\n \n static rtx\n-frv_expand_set_builtin (icode, arglist, target)\n-     enum insn_code icode;\n-     tree arglist;\n-     rtx target;\n+frv_expand_set_builtin (enum insn_code icode, tree arglist, rtx target)\n {\n   rtx pat;\n   rtx op0 = frv_read_argument (&arglist);\n@@ -9343,10 +9039,7 @@ frv_expand_set_builtin (icode, arglist, target)\n /* Expand builtins that take one operand. */\n \n static rtx\n-frv_expand_unop_builtin (icode, arglist, target)\n-     enum insn_code icode;\n-     tree arglist;\n-     rtx target;\n+frv_expand_unop_builtin (enum insn_code icode, tree arglist, rtx target)\n {\n   rtx pat;\n   rtx op0 = frv_read_argument (&arglist);\n@@ -9364,10 +9057,7 @@ frv_expand_unop_builtin (icode, arglist, target)\n /* Expand builtins that take two operands. */\n \n static rtx\n-frv_expand_binop_builtin (icode, arglist, target)\n-     enum insn_code icode;\n-     tree arglist;\n-     rtx target;\n+frv_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target)\n {\n   rtx pat;\n   rtx op0 = frv_read_argument (&arglist);\n@@ -9388,10 +9078,7 @@ frv_expand_binop_builtin (icode, arglist, target)\n    one. */\n \n static rtx\n-frv_expand_cut_builtin (icode, arglist, target)\n-     enum insn_code icode;\n-     tree arglist;\n-     rtx target;\n+frv_expand_cut_builtin (enum insn_code icode, tree arglist, rtx target)\n {\n   rtx pat;\n   rtx op0 = frv_read_argument (&arglist);\n@@ -9423,10 +9110,7 @@ frv_expand_cut_builtin (icode, arglist, target)\n /* Expand builtins that take two operands and the second is immediate. */\n \n static rtx\n-frv_expand_binopimm_builtin (icode, arglist, target)\n-     enum insn_code icode;\n-     tree arglist;\n-     rtx target;\n+frv_expand_binopimm_builtin (enum insn_code icode, tree arglist, rtx target)\n {\n   rtx pat;\n   rtx op0 = frv_read_argument (&arglist);\n@@ -9449,9 +9133,7 @@ frv_expand_binopimm_builtin (icode, arglist, target)\n    ints and return void. */\n \n static rtx\n-frv_expand_voidbinop_builtin (icode, arglist)\n-     enum insn_code icode;\n-     tree arglist;\n+frv_expand_voidbinop_builtin (enum insn_code icode, tree arglist)\n {\n   rtx pat;\n   rtx op0 = frv_read_argument (&arglist);\n@@ -9492,9 +9174,7 @@ frv_expand_voidbinop_builtin (icode, arglist)\n    corresponds to the accumulator.  */\n \n static rtx\n-frv_expand_voidtriop_builtin (icode, arglist)\n-     enum insn_code icode;\n-     tree arglist;\n+frv_expand_voidtriop_builtin (enum insn_code icode, tree arglist)\n {\n   rtx pat;\n   rtx op0 = frv_read_argument (&arglist);\n@@ -9522,9 +9202,7 @@ frv_expand_voidtriop_builtin (icode, arglist)\n    void.  */\n \n static rtx\n-frv_expand_voidaccop_builtin (icode, arglist)\n-     enum insn_code icode;\n-     tree arglist;\n+frv_expand_voidaccop_builtin (enum insn_code icode, tree arglist)\n {\n   rtx pat;\n   rtx op0 = frv_read_argument (&arglist);\n@@ -9554,8 +9232,7 @@ frv_expand_voidaccop_builtin (icode, arglist)\n    number as argument.  */\n \n static rtx\n-frv_expand_mclracc_builtin (arglist)\n-     tree arglist;\n+frv_expand_mclracc_builtin (tree arglist)\n {\n   enum insn_code icode = CODE_FOR_mclracc;\n   rtx pat;\n@@ -9575,8 +9252,7 @@ frv_expand_mclracc_builtin (arglist)\n /* Expand builtins that take no arguments.  */\n \n static rtx\n-frv_expand_noargs_builtin (icode)\n-     enum insn_code icode;\n+frv_expand_noargs_builtin (enum insn_code icode)\n {\n   rtx pat = GEN_FCN (icode) (GEN_INT (0));\n   if (pat)\n@@ -9589,9 +9265,7 @@ frv_expand_noargs_builtin (icode)\n    number or accumulator guard number as argument and return an SI integer.  */\n \n static rtx\n-frv_expand_mrdacc_builtin (icode, arglist)\n-     enum insn_code icode;\n-     tree arglist;\n+frv_expand_mrdacc_builtin (enum insn_code icode, tree arglist)\n {\n   rtx pat;\n   rtx target = gen_reg_rtx (SImode);\n@@ -9614,9 +9288,7 @@ frv_expand_mrdacc_builtin (icode, arglist)\n    second.  */\n \n static rtx\n-frv_expand_mwtacc_builtin (icode, arglist)\n-     enum insn_code icode;\n-     tree arglist;\n+frv_expand_mwtacc_builtin (enum insn_code icode, tree arglist)\n {\n   rtx pat;\n   rtx op0 = frv_read_argument (&arglist);\n@@ -9637,12 +9309,11 @@ frv_expand_mwtacc_builtin (icode, arglist)\n /* Expand builtins. */\n \n static rtx\n-frv_expand_builtin (exp, target, subtarget, mode, ignore)\n-     tree exp;\n-     rtx target;\n-     rtx subtarget ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     int ignore ATTRIBUTE_UNUSED;\n+frv_expand_builtin (tree exp,\n+                    rtx target,\n+                    rtx subtarget ATTRIBUTE_UNUSED,\n+                    enum machine_mode mode ATTRIBUTE_UNUSED,\n+                    int ignore ATTRIBUTE_UNUSED)\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n@@ -9771,8 +9442,7 @@ frv_expand_builtin (exp, target, subtarget, mode, ignore)\n }\n \n static bool\n-frv_in_small_data_p (decl)\n-     tree decl;\n+frv_in_small_data_p (tree decl)\n {\n   HOST_WIDE_INT size;\n   tree section_name;\n@@ -9806,10 +9476,10 @@ frv_in_small_data_p (decl)\n }\n \f\n static bool\n-frv_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code ATTRIBUTE_UNUSED;\n-     int *total;\n+frv_rtx_costs (rtx x,\n+               int code ATTRIBUTE_UNUSED,\n+               int outer_code ATTRIBUTE_UNUSED,\n+               int *total)\n {\n   switch (code)\n     {\n@@ -9868,19 +9538,15 @@ frv_rtx_costs (x, code, outer_code, total)\n }\n \f\n static void\n-frv_asm_out_constructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n+frv_asm_out_constructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n   ctors_section ();\n   assemble_align (POINTER_SIZE);\n   assemble_integer_with_op (\"\\t.picptr\\t\", symbol);\n }\n \n static void\n-frv_asm_out_destructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n+frv_asm_out_destructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n   dtors_section ();\n   assemble_align (POINTER_SIZE);"}, {"sha": "efb655a96849d6a0420bd3bd7bffc7d3cc786a5b", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2206911fbaa7595b181706b74197ff61fe59530/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2206911fbaa7595b181706b74197ff61fe59530/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=f2206911fbaa7595b181706b74197ff61fe59530", "patch": "@@ -1885,7 +1885,7 @@ struct machine_function GTY(())\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\t\\\n   frv_function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n \n-/* extern int frv_function_arg_partial_nregs PARAMS ((CUMULATIVE_ARGS, int, Tree, int));  */\n+/* extern int frv_function_arg_partial_nregs (CUMULATIVE_ARGS, int, Tree, int);  */\n \n /* A C expression that indicates when an argument must be passed by reference.\n    If nonzero for an argument, a copy of that argument is made in memory and a\n@@ -2180,11 +2180,7 @@ struct machine_function GTY(())\n extern int _write (int, const void *, unsigned);\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n-__trampoline_setup (addr, size, fnaddr, sc)\t\t\t\t\\\n-     short * addr;\t\t\t\t\t\t\t\\\n-     int size;\t\t\t\t\t\t\t\t\\\n-     int fnaddr;\t\t\t\t\t\t\t\\\n-     int sc;\t\t\t\t\t\t\t\t\\\n+__trampoline_setup (short * addr, int size, int fnaddr, int sc)\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   extern short __trampoline_template[];\t\t\t\t\t\\\n   short * to = addr;\t\t\t\t\t\t\t\\\n@@ -2565,7 +2561,7 @@ __asm__(\"\\n\"\t\t\t\t\t\t\t\t\\\n \n #define SDATA_SECTION_FUNCTION\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n-sdata_section ()\t\t\t\t\t\t\t\\\n+sdata_section (void)\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (in_section != in_sdata)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -2576,7 +2572,7 @@ sdata_section ()\t\t\t\t\t\t\t\\\n \n #define FIXUP_SECTION_FUNCTION\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n-fixup_section ()\t\t\t\t\t\t\t\\\n+fixup_section (void)\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (in_section != in_fixup)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "b1b43413672993449b992974485b8fa34857db1b", "filename": "gcc/config/frv/frvbegin.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2206911fbaa7595b181706b74197ff61fe59530/gcc%2Fconfig%2Ffrv%2Ffrvbegin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2206911fbaa7595b181706b74197ff61fe59530/gcc%2Fconfig%2Ffrv%2Ffrvbegin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrvbegin.c?ref=f2206911fbaa7595b181706b74197ff61fe59530", "patch": "@@ -110,7 +110,7 @@ __frv_deregister_eh (void)\n \n /* Run the global destructors */\n void\n-__do_global_dtors ()\n+__do_global_dtors (void)\n {\n   static func_ptr *p = __DTOR_LIST__ + 1;\n   while (*p)\n@@ -122,7 +122,7 @@ __do_global_dtors ()\n \n /* Run the global constructors */\n void\n-__do_global_ctors ()\n+__do_global_ctors (void)\n {\n   unsigned long nptrs = (unsigned long) __CTOR_LIST__[0];\n   unsigned i;\n@@ -145,7 +145,7 @@ __do_global_ctors ()\n    to run __do_global_ctors, so we need not do anything here.  */\n \n void\n-__main ()\n+__main (void)\n {\n   /* Support recursive calls to `main': run initializers just once.  */\n   static int initialized;"}]}