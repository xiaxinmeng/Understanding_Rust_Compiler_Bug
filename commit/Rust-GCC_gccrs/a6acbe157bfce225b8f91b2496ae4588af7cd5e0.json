{"sha": "a6acbe157bfce225b8f91b2496ae4588af7cd5e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZhY2JlMTU3YmZjZTIyNWI4ZjkxYjI0OTZhZTQ1ODhhZjdjZDVlMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-17T07:07:44Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-17T07:07:44Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r999", "tree": {"sha": "2c768c4ea7d3392df2ae5d195cd62d9656ec05bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c768c4ea7d3392df2ae5d195cd62d9656ec05bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6acbe157bfce225b8f91b2496ae4588af7cd5e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6acbe157bfce225b8f91b2496ae4588af7cd5e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6acbe157bfce225b8f91b2496ae4588af7cd5e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6acbe157bfce225b8f91b2496ae4588af7cd5e0/comments", "author": null, "committer": null, "parents": [{"sha": "b8168f0d34366808143d0f0365243d0a13e520eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8168f0d34366808143d0f0365243d0a13e520eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8168f0d34366808143d0f0365243d0a13e520eb"}], "stats": {"total": 28, "additions": 14, "deletions": 14}, "files": [{"sha": "692eec5f4c4f0c0741654f0eb490827dd647808d", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6acbe157bfce225b8f91b2496ae4588af7cd5e0/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6acbe157bfce225b8f91b2496ae4588af7cd5e0/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=a6acbe157bfce225b8f91b2496ae4588af7cd5e0", "patch": "@@ -2948,12 +2948,12 @@ simplify_unary_operation (code, mode, op, op_mode)\n       return gen_rtx (CONST_INT, VOIDmode, val);\n     }\n #endif\n-  else if (GET_MODE_CLASS (mode) == MODE_INT\n-\t   || TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n+  /* This was formerly used only for non-IEEE float.\n+     eggert@twinsun.com says it is safe for IEEE also.  */\n+  else\n     {\n       /* There are some simplifications we can do even if the operands\n-\t aren't constant, but they don't apply to floating-point\n-\t unless not IEEE.  */\n+\t aren't constant.  */\n       switch (code)\n \t{\n \tcase NEG:\n@@ -2979,8 +2979,6 @@ simplify_unary_operation (code, mode, op, op_mode)\n \n       return 0;\n     }\n-  else\n-    return 0;\n }\n \f\n /* Simplify a binary operation CODE with result mode MODE, operating on OP0"}, {"sha": "dd269861d556f34b930f56c3902b47a650cb46ea", "filename": "gcc/fold-const.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6acbe157bfce225b8f91b2496ae4588af7cd5e0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6acbe157bfce225b8f91b2496ae4588af7cd5e0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a6acbe157bfce225b8f91b2496ae4588af7cd5e0", "patch": "@@ -3007,15 +3007,17 @@ fold (expr)\n \t  /* Except with IEEE floating point, x-0 equals x.  */\n \t  if (real_zerop (arg1))\n \t    return non_lvalue (convert (type, arg0));\n-\t}\n-      /* Fold &x - &x.  This can happen from &x.foo - &x. \n-\t Note that can't be done for certain floats even in non-IEEE formats.\n-\t Also note that operand_equal_p is always false is an operand\n-\t is volatile.  */\n \n-      if (operand_equal_p (arg0, arg1,\n-\t\t\t   TREE_CODE (type) == REAL_TYPE))\n-\treturn convert (type, integer_zero_node);\n+\t  /* Fold &x - &x.  This can happen from &x.foo - &x. \n+\t     This is unsafe for certain floats even in non-IEEE formats.\n+\t     In IEEE, it is unsafe because it does wrong for NaNs.\n+\t     Also note that operand_equal_p is always false is an operand\n+\t     is volatile.  */\n+\n+\t  if (operand_equal_p (arg0, arg1,\n+\t\t\t       TREE_CODE (type) == REAL_TYPE))\n+\t    return convert (type, integer_zero_node);\n+\t}\n       goto associate;\n \n     case MULT_EXPR:"}]}