{"sha": "67ac6e637c33f25f2199d20882babd47e926c6d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdhYzZlNjM3YzMzZjI1ZjIxOTlkMjA4ODJiYWJkNDdlOTI2YzZkNQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2006-04-27T13:52:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2006-04-27T13:52:44Z"}, "message": "re PR tree-optimization/25148 (compare_values assumes that CST in a + CST (and a - CST) is always postive)\n\n2006-04-27  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/25148\n\t* tree-vrp.c (compare_values): Remove code dealing with\n\tcomparisons against type min/max value.  Honour overflow\n\tand negative constants in code dealing with comparisons\n\tof plus and minus expressions.\n\t(value_inside_range): Use fold_binary with LE_EXPR and\n\tGE_EXPR rather than compare_values.\n\nFrom-SVN: r113298", "tree": {"sha": "2be2839b78c9aa92f56204a43ca3cf7bed9461c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2be2839b78c9aa92f56204a43ca3cf7bed9461c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67ac6e637c33f25f2199d20882babd47e926c6d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67ac6e637c33f25f2199d20882babd47e926c6d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67ac6e637c33f25f2199d20882babd47e926c6d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67ac6e637c33f25f2199d20882babd47e926c6d5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "869170df101966edf90211387ba803c76e61f212", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/869170df101966edf90211387ba803c76e61f212", "html_url": "https://github.com/Rust-GCC/gccrs/commit/869170df101966edf90211387ba803c76e61f212"}], "stats": {"total": 107, "additions": 56, "deletions": 51}, "files": [{"sha": "e528f63028cc9adb7ea10418649e225b47cf3016", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ac6e637c33f25f2199d20882babd47e926c6d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ac6e637c33f25f2199d20882babd47e926c6d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67ac6e637c33f25f2199d20882babd47e926c6d5", "patch": "@@ -1,3 +1,13 @@\n+2006-04-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/25148\n+\t* tree-vrp.c (compare_values): Remove code dealing with\n+\tcomparisons against type min/max value.  Honour overflow\n+\tand negative constants in code dealing with comparisons\n+\tof plus and minus expressions.\n+\t(value_inside_range): Use fold_binary with LE_EXPR and\n+\tGE_EXPR rather than compare_values.\n+\n 2006-04-27  Dirk Mueller  <dmueller@suse.de>\n \n \t* config/i386/xmmintrin.h (_mm_shuffle_pi16): Declare"}, {"sha": "9733a3669fb8f8ad15c9f81e1b78a51703fd7c71", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ac6e637c33f25f2199d20882babd47e926c6d5/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ac6e637c33f25f2199d20882babd47e926c6d5/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=67ac6e637c33f25f2199d20882babd47e926c6d5", "patch": "@@ -432,37 +432,6 @@ compare_values (tree val1, tree val2)\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (val1))\n \t      == POINTER_TYPE_P (TREE_TYPE (val2)));\n \n-  /* Do some limited symbolic comparisons.  */\n-  if (!POINTER_TYPE_P (TREE_TYPE (val1)))\n-    {\n-      /* We can determine some comparisons against +INF and -INF even\n-\t if the other value is an expression.  */\n-      if (val1 == TYPE_MAX_VALUE (TREE_TYPE (val1))\n-\t  && TREE_CODE (val2) == MINUS_EXPR)\n-\t{\n-\t  /* +INF > NAME - CST.  */\n-\t  return 1;\n-\t}\n-      else if (val1 == TYPE_MIN_VALUE (TREE_TYPE (val1))\n-\t       && TREE_CODE (val2) == PLUS_EXPR)\n-\t{\n-\t  /* -INF < NAME + CST.  */\n-\t  return -1;\n-\t}\n-      else if (TREE_CODE (val1) == MINUS_EXPR\n-\t       && val2 == TYPE_MAX_VALUE (TREE_TYPE (val2)))\n-\t{\n-\t  /* NAME - CST < +INF.  */\n-\t  return -1;\n-\t}\n-      else if (TREE_CODE (val1) == PLUS_EXPR\n-\t       && val2 == TYPE_MIN_VALUE (TREE_TYPE (val2)))\n-\t{\n-\t  /* NAME + CST > -INF.  */\n-\t  return 1;\n-\t}\n-    }\n-\n   if ((TREE_CODE (val1) == SSA_NAME\n        || TREE_CODE (val1) == PLUS_EXPR\n        || TREE_CODE (val1) == MINUS_EXPR)\n@@ -471,69 +440,95 @@ compare_values (tree val1, tree val2)\n \t  || TREE_CODE (val2) == MINUS_EXPR))\n     {\n       tree n1, c1, n2, c2;\n+      enum tree_code code1, code2;\n   \n       /* If VAL1 and VAL2 are of the form 'NAME [+-] CST' or 'NAME',\n \t return -1 or +1 accordingly.  If VAL1 and VAL2 don't use the\n \t same name, return -2.  */\n       if (TREE_CODE (val1) == SSA_NAME)\n \t{\n+\t  code1 = SSA_NAME;\n \t  n1 = val1;\n \t  c1 = NULL_TREE;\n \t}\n       else\n \t{\n+\t  code1 = TREE_CODE (val1);\n \t  n1 = TREE_OPERAND (val1, 0);\n \t  c1 = TREE_OPERAND (val1, 1);\n+\t  if (tree_int_cst_sgn (c1) == -1)\n+\t    {\n+\t      c1 = fold_unary_to_constant (NEGATE_EXPR, TREE_TYPE (c1), c1);\n+\t      if (!c1)\n+\t\treturn -2;\n+\t      code1 = code1 == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR;\n+\t    }\n \t}\n \n       if (TREE_CODE (val2) == SSA_NAME)\n \t{\n+\t  code2 = SSA_NAME;\n \t  n2 = val2;\n \t  c2 = NULL_TREE;\n \t}\n       else\n \t{\n+\t  code2 = TREE_CODE (val2);\n \t  n2 = TREE_OPERAND (val2, 0);\n \t  c2 = TREE_OPERAND (val2, 1);\n+\t  if (tree_int_cst_sgn (c2) == -1)\n+\t    {\n+\t      c2 = fold_unary_to_constant (NEGATE_EXPR, TREE_TYPE (c2), c2);\n+\t      if (!c2)\n+\t\treturn -2;\n+\t      code2 = code2 == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR;\n+\t    }\n \t}\n \n       /* Both values must use the same name.  */\n       if (n1 != n2)\n \treturn -2;\n \n-      if (TREE_CODE (val1) == SSA_NAME)\n+      if (code1 == SSA_NAME\n+\t  && code2 == SSA_NAME)\n+\t/* NAME == NAME  */\n+\treturn 0;\n+\n+      /* If overflow is defined we cannot simplify more.  */\n+      if (TYPE_UNSIGNED (TREE_TYPE (val1))\n+\t  || flag_wrapv)\n+\treturn -2;\n+\n+      if (code1 == SSA_NAME)\n \t{\n-\t  if (TREE_CODE (val2) == SSA_NAME)\n-\t    /* NAME == NAME  */\n-\t    return 0;\n-\t  else if (TREE_CODE (val2) == PLUS_EXPR)\n+\t  if (code2 == PLUS_EXPR)\n \t    /* NAME < NAME + CST  */\n \t    return -1;\n-\t  else if (TREE_CODE (val2) == MINUS_EXPR)\n+\t  else if (code2 == MINUS_EXPR)\n \t    /* NAME > NAME - CST  */\n \t    return 1;\n \t}\n-      else if (TREE_CODE (val1) == PLUS_EXPR)\n+      else if (code1 == PLUS_EXPR)\n \t{\n-\t  if (TREE_CODE (val2) == SSA_NAME)\n+\t  if (code2 == SSA_NAME)\n \t    /* NAME + CST > NAME  */\n \t    return 1;\n-\t  else if (TREE_CODE (val2) == PLUS_EXPR)\n+\t  else if (code2 == PLUS_EXPR)\n \t    /* NAME + CST1 > NAME + CST2, if CST1 > CST2  */\n \t    return compare_values (c1, c2);\n-\t  else if (TREE_CODE (val2) == MINUS_EXPR)\n+\t  else if (code2 == MINUS_EXPR)\n \t    /* NAME + CST1 > NAME - CST2  */\n \t    return 1;\n \t}\n-      else if (TREE_CODE (val1) == MINUS_EXPR)\n+      else if (code1 == MINUS_EXPR)\n \t{\n-\t  if (TREE_CODE (val2) == SSA_NAME)\n+\t  if (code2 == SSA_NAME)\n \t    /* NAME - CST < NAME  */\n \t    return -1;\n-\t  else if (TREE_CODE (val2) == PLUS_EXPR)\n+\t  else if (code2 == PLUS_EXPR)\n \t    /* NAME - CST1 < NAME + CST2  */\n \t    return -1;\n-\t  else if (TREE_CODE (val2) == MINUS_EXPR)\n+\t  else if (code2 == MINUS_EXPR)\n \t    /* NAME - CST1 > NAME - CST2, if CST1 < CST2.  Notice that\n \t       C1 and C2 are swapped in the call to compare_values.  */\n \t    return compare_values (c2, c1);\n@@ -605,17 +600,17 @@ compare_values (tree val1, tree val2)\n static inline int\n value_inside_range (tree val, value_range_t *vr)\n {\n-  int cmp1, cmp2;\n+  tree cmp1, cmp2;\n \n-  cmp1 = compare_values (val, vr->min);\n-  if (cmp1 == -2 || cmp1 == 2)\n+  cmp1 = fold_binary_to_constant (GE_EXPR, boolean_type_node, val, vr->min);\n+  if (!cmp1)\n     return -2;\n \n-  cmp2 = compare_values (val, vr->max);\n-  if (cmp2 == -2 || cmp2 == 2)\n+  cmp2 = fold_binary_to_constant (LE_EXPR, boolean_type_node, val, vr->max);\n+  if (!cmp2)\n     return -2;\n \n-  return (cmp1 == 0 || cmp1 == 1) && (cmp2 == -1 || cmp2 == 0);\n+  return cmp1 == boolean_true_node && cmp2 == boolean_true_node;\n }\n \n "}]}