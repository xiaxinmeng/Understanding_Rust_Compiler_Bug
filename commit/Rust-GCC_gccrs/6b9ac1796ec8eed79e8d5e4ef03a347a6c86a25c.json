{"sha": "6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI5YWMxNzk2ZWM4ZWVkNzllOGQ1ZTRlZjAzYTM0N2E2Yzg2YTI1Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-12-09T02:15:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-12-09T02:15:05Z"}, "message": "re PR lto/61886 (LTO breaks fread with _FORTIFY_SOURCE=2)\n\n\n\n\tPR ipa/61886\n\t* lto-streamer.h (lto_symtab_merge_decls, lto_symtab_merge_symbols,\n\tlto_symtab_prevailing_decl): MOve to lto-symtab.h.\n\t* lto-streamer-out.c (DFS::DFS_write_tree_body): Check that\n\tDECL_ABSTRACT_ORIGIN is not error_mark_node.\n\n\t* lto-symtab.c: Include lto-symtab.h.\n\t(lto_cgraph_replace_node): Do not merge profiles here.\n\t(lto_symtab_merge_p): New function.\n\t(lto_symtab_merge_decls_2): Honor lto_symtab_merge_p.\n\t(lto_symtab_merge_symbols_1): Turn unmerged decls into transparent\n\taliases.\n\t(lto_symtab_merge_symbols): Do not clear node->aux; we no longer use it.\n\t(lto_symtab_prevailing_decl): Move to lto-symtab.h; rewrite.\n\t* lto.c: Include lto-symtab.h\n\t* lto-symtab.h: New.\n\nFrom-SVN: r231438", "tree": {"sha": "77618157acd1764e5dd8967035809f5e54b46242", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77618157acd1764e5dd8967035809f5e54b46242"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/comments", "author": null, "committer": null, "parents": [{"sha": "1a161cd7a7545318c1ee29dfd2eb76ee6ee9f43e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a161cd7a7545318c1ee29dfd2eb76ee6ee9f43e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a161cd7a7545318c1ee29dfd2eb76ee6ee9f43e"}], "stats": {"total": 261, "additions": 197, "deletions": 64}, "files": [{"sha": "44eddde4b11ef83284240057c998d1703957d2a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c", "patch": "@@ -1,3 +1,11 @@\n+2015-12-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/61886\n+\t* lto-streamer.h (lto_symtab_merge_decls, lto_symtab_merge_symbols,\n+\tlto_symtab_prevailing_decl): MOve to lto-symtab.h.\n+\t* lto-streamer-out.c (DFS::DFS_write_tree_body): Check that\n+\tDECL_ABSTRACT_ORIGIN is not error_mark_node.\n+\n 2015-12-08  David Malcolm  <dmalcolm@redhat.com>\n \n \t* tree-nested.c (convert_tramp_reference_stmt): Fix indentation."}, {"sha": "a8748464c210c17aa40030342e51dd3dfa7971ca", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c", "patch": "@@ -731,7 +731,11 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n \n       /* Do not follow DECL_ABSTRACT_ORIGIN.  We cannot handle debug information\n \t for early inlining so drop it on the floor instead of ICEing in\n-\t dwarf2out.c.  */\n+\t dwarf2out.c.\n+\t We however use DECL_ABSTRACT_ORIGIN == error_mark_node to mark\n+\t declarations which should be eliminated by decl merging. Be sure none\n+\t leaks to this point.  */\n+      gcc_assert (DECL_ABSTRACT_ORIGIN (expr) != error_mark_node);\n \n       if ((TREE_CODE (expr) == VAR_DECL\n \t   || TREE_CODE (expr) == PARM_DECL)"}, {"sha": "99f88b89f9d73ff6c24bfbb9aa0b7b68b255d03d", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c", "patch": "@@ -927,11 +927,6 @@ void cl_optimization_stream_out (struct bitpack_d *, struct cl_optimization *);\n void cl_optimization_stream_in (struct bitpack_d *, struct cl_optimization *);\n \n \n-/* In lto-symtab.c.  */\n-extern void lto_symtab_merge_decls (void);\n-extern void lto_symtab_merge_symbols (void);\n-extern tree lto_symtab_prevailing_decl (tree decl);\n-\n \n /* In lto-opts.c.  */\n extern void lto_write_options (void);"}, {"sha": "faeb3eedc706c271aa1809af83ce9b4e37b7aba2", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c", "patch": "@@ -1,3 +1,17 @@\n+2015-12-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/61886\n+\t* lto-symtab.c: Include lto-symtab.h.\n+\t(lto_cgraph_replace_node): Do not merge profiles here.\n+\t(lto_symtab_merge_p): New function.\n+\t(lto_symtab_merge_decls_2): Honor lto_symtab_merge_p.\n+\t(lto_symtab_merge_symbols_1): Turn unmerged decls into transparent\n+\taliases.\n+\t(lto_symtab_merge_symbols): Do not clear node->aux; we no longer use it.\n+\t(lto_symtab_prevailing_decl): Move to lto-symtab.h; rewrite.\n+\t* lto.c: Include lto-symtab.h\n+\t* lto-symtab.h: New.\n+\n 2015-12-08  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/61886"}, {"sha": "a0cc1708d7493f038850db267cb1d600c2af7dc3", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 122, "deletions": 58, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"builtins.h\"\n #include \"alias.h\"\n+#include \"lto-symtab.h\"\n \n /* Replace the cgraph node NODE with PREVAILING_NODE in the cgraph, merging\n    all edges and removing the old node.  */\n@@ -99,7 +100,6 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n       node->instrumented_version = NULL;\n     }\n \n-  ipa_merge_profiles (prevailing_node, node);\n   lto_free_function_in_decl_state_for_node (node);\n \n   if (node->decl != prevailing_node->decl)\n@@ -503,6 +503,30 @@ lto_symtab_resolve_symbols (symtab_node *first)\n   return prevailing;\n }\n \n+/* Decide if it is OK to merge DECL into PREVAILING.\n+   Because we wrap most of uses of declarations in MEM_REF, we can tolerate\n+   some differences but other code may inspect directly the DECL.  */\n+\n+static bool\n+lto_symtab_merge_p (tree prevailing, tree decl)\n+{\n+  if (TREE_CODE (prevailing) != TREE_CODE (decl))\n+    return false;\n+  if (TREE_CODE (prevailing) == FUNCTION_DECL)\n+    {\n+      if (DECL_BUILT_IN (prevailing) != DECL_BUILT_IN (decl))\n+\treturn false;\n+      if (DECL_BUILT_IN (prevailing)\n+\t  && (DECL_BUILT_IN_CLASS (prevailing) != DECL_BUILT_IN_CLASS (decl)\n+\t      || DECL_FUNCTION_CODE (prevailing) != DECL_FUNCTION_CODE (decl)))\n+\treturn false;\n+    }\n+  /* There are several other cases where merging can not be done, but until\n+     aliasing code is fixed to support aliases it we can not really return\n+     false on non-readonly var, yet.  */\n+  return true;\n+}\n+\n /* Merge all decls in the symbol table chain to the prevailing decl and\n    issue diagnostics about type mismatches.  If DIAGNOSED_P is true\n    do not issue further diagnostics.*/\n@@ -523,15 +547,59 @@ lto_symtab_merge_decls_2 (symtab_node *first, bool diagnosed_p)\n     return;\n \n   /* Try to merge each entry with the prevailing one.  */\n-  for (e = prevailing->next_sharing_asm_name;\n-       e; e = e->next_sharing_asm_name)\n-    if (TREE_PUBLIC (e->decl))\n-      {\n-\tif (!lto_symtab_merge (prevailing, e)\n-\t    && !diagnosed_p\n-\t    && !DECL_ARTIFICIAL (e->decl))\n-\t  mismatches.safe_push (e->decl);\n-      }\n+  symtab_node *last_prevailing = prevailing, *next;\n+  for (e = prevailing->next_sharing_asm_name; e; e = next)\n+    {\n+      next = e->next_sharing_asm_name;\n+\n+      /* Skip non-LTO symbols and symbols whose declaration we already\n+\t visited.  */\n+      if (lto_symtab_prevailing_decl (e->decl) != e->decl\n+\t  || !lto_symtab_symbol_p (e)\n+          || e->decl == prevailing->decl)\n+\tcontinue;\n+\n+      if (!lto_symtab_merge (prevailing, e)\n+\t  && !diagnosed_p\n+\t  && !DECL_ARTIFICIAL (e->decl))\n+\tmismatches.safe_push (e->decl);\n+\n+      symtab_node *this_prevailing;\n+      for (this_prevailing = prevailing; ;\n+\t   this_prevailing = this_prevailing->next_sharing_asm_name)\n+\t{\n+\t  if (lto_symtab_merge_p (this_prevailing->decl, e->decl))\n+\t    break;\n+\t  if (this_prevailing == last_prevailing)\n+\t    {\n+\t      this_prevailing = NULL;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (this_prevailing)\n+\tlto_symtab_prevail_decl (this_prevailing->decl, e->decl);\n+      /* Maintain LRU list: relink the new prevaililng symbol\n+\t just after previaling node in the chain and update last_prevailing.\n+\t Since the number of possible declarations of a given symbol is\n+\t small, this should be faster than building a hash.  */\n+      else if (e == prevailing->next_sharing_asm_name)\n+\tlast_prevailing = e;\n+      else\n+\t{\n+\t  if (e->next_sharing_asm_name)\n+\t    e->next_sharing_asm_name->previous_sharing_asm_name\n+\t      = e->previous_sharing_asm_name;\n+\t  e->previous_sharing_asm_name->next_sharing_asm_name\n+\t    = e->next_sharing_asm_name;\n+\t  e->previous_sharing_asm_name = prevailing;\n+\t  e->next_sharing_asm_name = prevailing->next_sharing_asm_name;\n+\t  prevailing->next_sharing_asm_name->previous_sharing_asm_name = e;\n+\t  prevailing->next_sharing_asm_name = e;\n+\t  if (last_prevailing == prevailing)\n+\t    last_prevailing = e;\n+\t}\n+    }\n   if (mismatches.is_empty ())\n     return;\n \n@@ -729,6 +797,8 @@ lto_symtab_merge_symbols_1 (symtab_node *prevailing)\n   symtab_node *e;\n   symtab_node *next;\n \n+  prevailing->decl->decl_with_vis.symtab_node = prevailing;\n+\n   /* Replace the cgraph node of each entry with the prevailing one.  */\n   for (e = prevailing->next_sharing_asm_name; e;\n        e = next)\n@@ -738,10 +808,47 @@ lto_symtab_merge_symbols_1 (symtab_node *prevailing)\n       if (!lto_symtab_symbol_p (e))\n \tcontinue;\n       cgraph_node *ce = dyn_cast <cgraph_node *> (e);\n-      if (ce && !DECL_BUILT_IN (e->decl))\n-\tlto_cgraph_replace_node (ce, dyn_cast<cgraph_node *> (prevailing));\n-      if (varpool_node *ve = dyn_cast <varpool_node *> (e))\n-\tlto_varpool_replace_node (ve, dyn_cast<varpool_node *> (prevailing));\n+      symtab_node *to = symtab_node::get (lto_symtab_prevailing_decl (e->decl));\n+\n+      /* No matter how we are going to deal with resolution, we will ultimately\n+\t use prevailing definition.  */\n+      if (ce)\n+          ipa_merge_profiles (dyn_cast<cgraph_node *> (prevailing),\n+\t\t\t      dyn_cast<cgraph_node *> (e));\n+\n+      /* If we decided to replace the node by TO, do it.  */\n+      if (e != to)\n+\t{\n+\t  if (ce)\n+\t    lto_cgraph_replace_node (ce, dyn_cast<cgraph_node *> (to));\n+\t  else if (varpool_node *ve = dyn_cast <varpool_node *> (e))\n+\t    lto_varpool_replace_node (ve, dyn_cast<varpool_node *> (to));\n+\t}\n+      /* Watch out for duplicated symbols for a given declaration.  */\n+      else if (!e->transparent_alias\n+\t       || !e->definition || e->get_alias_target () != to)\n+\t{\n+\t  /* We got a new declaration we do not want to merge.  In this case\n+\t     get rid of the existing definition and create a transparent\n+\t     alias.  */\n+\t  if (ce)\n+\t    {\n+\t      lto_free_function_in_decl_state_for_node (ce);\n+\t      if (!ce->weakref)\n+\t        ce->release_body ();\n+\t      ce->reset ();\n+\t      symtab->call_cgraph_removal_hooks (ce);\n+\t    }\n+\t  else\n+\t    {\n+\t      DECL_INITIAL (e->decl) = error_mark_node;\n+\t      symtab->call_varpool_removal_hooks (dyn_cast<varpool_node *> (e));\n+\t    }\n+\t  e->remove_all_references ();\n+\t  e->analyzed = e->body_removed = false;\n+\t  e->resolve_alias (prevailing, true);\n+\t  gcc_assert (e != prevailing);\n+\t}\n     }\n \n   return;\n@@ -782,9 +889,8 @@ lto_symtab_merge_symbols (void)\n \t      symtab_node *tgt = symtab_node::get_for_asmname (node->alias_target);\n \t      gcc_assert (node->weakref);\n \t      if (tgt)\n-\t\tnode->resolve_alias (tgt);\n+\t\tnode->resolve_alias (tgt, true);\n \t    }\n-\t  node->aux = NULL;\n \n \t  if (!(cnode = dyn_cast <cgraph_node *> (node))\n \t      || !cnode->clone_of\n@@ -821,45 +927,3 @@ lto_symtab_merge_symbols (void)\n \t}\n     }\n }\n-\n-/* Given the decl DECL, return the prevailing decl with the same name. */\n-\n-tree\n-lto_symtab_prevailing_decl (tree decl)\n-{\n-  symtab_node *ret;\n-\n-  /* Builtins and local symbols are their own prevailing decl.  */\n-  if ((!TREE_PUBLIC (decl) && !DECL_EXTERNAL (decl)) || is_builtin_fn (decl))\n-    return decl;\n-\n-  /* DECL_ABSTRACT_Ps are their own prevailing decl.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_ABSTRACT_P (decl))\n-    return decl;\n-\n-  /* When decl did not participate in symbol resolution leave it alone.\n-     This can happen when we streamed the decl as abstract origin\n-     from the block tree of inlining a partially inlined function.\n-     If all, the split function and the original function end up\n-     optimized away early we do not put the abstract origin into the\n-     ltrans boundary and we'll end up ICEing in\n-     dwarf2out.c:gen_inlined_subroutine_die because we eventually\n-     replace a decl with DECL_POSSIBLY_INLINED set with one without.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      && ! cgraph_node::get (decl))\n-    return decl;\n-\n-  /* Ensure DECL_ASSEMBLER_NAME will not set assembler name.  */\n-  gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n-\n-  /* Walk through the list of candidates and return the one we merged to.  */\n-  ret = symtab_node::get_for_asmname (DECL_ASSEMBLER_NAME (decl));\n-  if (!ret)\n-    return decl;\n-\n-  /* Do not replace a non-builtin with a builtin.  */\n-  if (is_builtin_fn (ret->decl))\n-    return decl;\n-\n-  return ret->decl;\n-}"}, {"sha": "c6b68b6001e3a52e0a1091b24ed2e558f1c80006", "filename": "gcc/lto/lto-symtab.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2Flto%2Flto-symtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2Flto%2Flto-symtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.h?ref=6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c", "patch": "@@ -0,0 +1,47 @@\n+/* LTO symbol table merging.\n+   Copyright (C) 2009-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+extern void lto_symtab_merge_decls (void);\n+extern void lto_symtab_merge_symbols (void);\n+extern tree lto_symtab_prevailing_decl (tree decl);\n+\n+/* Mark DECL to be previailed by PREVAILING.\n+   Use DECL_ABSTRACT_ORIGIN and DECL_CHAIN as special markers; those do not\n+   disturb debug_tree and diagnostics.\n+   We are safe to modify them as we wish, becuase the declarations disappear\n+   from the IL after the merging.  */\n+\n+inline void\n+lto_symtab_prevail_decl (tree prevailing, tree decl)\n+{\n+  gcc_checking_assert (DECL_ABSTRACT_ORIGIN (decl) != error_mark_node);\n+  DECL_CHAIN (decl) = prevailing;\n+  DECL_ABSTRACT_ORIGIN (decl) = error_mark_node;\n+}\n+\n+/* Given the decl DECL, return the prevailing decl with the same name. */\n+\n+inline tree\n+lto_symtab_prevailing_decl (tree decl)\n+{\n+  if (DECL_ABSTRACT_ORIGIN (decl) == error_mark_node)\n+    return DECL_CHAIN (decl);\n+  else\n+    return decl;\n+}"}, {"sha": "90712b45ecb9da5bbbf9dd0a3d32208f8f42f350", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=6b9ac1796ec8eed79e8d5e4ef03a347a6c86a25c", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"ipa-utils.h\"\n #include \"gomp-constants.h\"\n+#include \"lto-symtab.h\"\n \n \n /* Number of parallel tasks to run, -1 if we want to use GNU Make jobserver.  */"}]}