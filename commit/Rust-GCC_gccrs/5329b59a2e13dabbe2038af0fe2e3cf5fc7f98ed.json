{"sha": "5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMyOWI1OWEyZTEzZGFiYmUyMDM4YWYwZmUyZTNjZjVmYzdmOThlZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-05-18T18:28:16Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-05-18T18:29:18Z"}, "message": "bootstrap: Update requirement to C++11.\n\nThere was general agreement last November that we would move to allowing\nC++11 features to be used in GCC 11; this patch implements that direction.\n\nChangeLog\n2020-05-18  Jason Merrill  <jason@redhat.com>\n\n\t* configure.ac: Update bootstrap dialect to -std=c++11.\n\nconfig/ChangeLog\n2020-05-18  Jason Merrill  <jason@redhat.com>\n\n\t* ax_cxx_compile_stdcxx.m4: Import from autoconf archive with\n\tan adjustment to try the default mode.\n\ngcc/ChangeLog\n2020-05-18  Jason Merrill  <jason@redhat.com>\n\n\t* aclocal.m4: Add ax_cxx_compile_stdcxx.m4.\n\t* configure.ac: Use AX_CXX_COMPILE_STDCXX(11).", "tree": {"sha": "b5c78d4c1858c2bcda7f6fdd7ef5133d978019ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5c78d4c1858c2bcda7f6fdd7ef5133d978019ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5abd1cb9160619721336ed800779a01548231f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5abd1cb9160619721336ed800779a01548231f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5abd1cb9160619721336ed800779a01548231f1"}], "stats": {"total": 2011, "additions": 1996, "deletions": 15}, "files": [{"sha": "4fb8690abc5be7c94d049b577782a08a5117478c", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "patch": "@@ -1,3 +1,7 @@\n+2020-05-18  Jason Merrill  <jason@redhat.com>\n+\n+\t* configure.ac: Update bootstrap dialect to -std=c++11.\n+\n 2020-05-18  Alex Coplan  <alex.coplan@arm.com>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "1a260933ef377b19f8654d1dea1d1b85712e23ce", "filename": "config/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/config%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/config%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2FChangeLog?ref=5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "patch": "@@ -1,3 +1,8 @@\n+2020-05-18  Jason Merrill  <jason@redhat.com>\n+\n+\t* ax_cxx_compile_stdcxx.m4: Import from autoconf archive with\n+\tan adjustment to try the default mode.\n+\n 2020-05-15  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR bootstrap/95147"}, {"sha": "9413da624d2545123501b7788b7ac6d96fd322e8", "filename": "config/ax_cxx_compile_stdcxx.m4", "status": "added", "additions": 962, "deletions": 0, "changes": 962, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/config%2Fax_cxx_compile_stdcxx.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/config%2Fax_cxx_compile_stdcxx.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fax_cxx_compile_stdcxx.m4?ref=5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "patch": "@@ -0,0 +1,962 @@\n+# ===========================================================================\n+#  https://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_CXX_COMPILE_STDCXX(VERSION, [ext|noext], [mandatory|optional])\n+#\n+# DESCRIPTION\n+#\n+#   Check for baseline language coverage in the compiler for the specified\n+#   version of the C++ standard.  If necessary, add switches to CXX and\n+#   CXXCPP to enable support.  VERSION may be '11' (for the C++11 standard)\n+#   or '14' (for the C++14 standard).\n+#\n+#   The second argument, if specified, indicates whether you insist on an\n+#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.\n+#   -std=c++11).  If neither is specified, you get whatever works, with\n+#   preference for no added switch, and then for an extended mode.\n+#\n+#   The third argument, if specified 'mandatory' or if left unspecified,\n+#   indicates that baseline support for the specified C++ standard is\n+#   required and that the macro should error out if no mode with that\n+#   support is found.  If specified 'optional', then configuration proceeds\n+#   regardless, after defining HAVE_CXX${VERSION} if and only if a\n+#   supporting mode is found.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>\n+#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>\n+#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>\n+#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>\n+#   Copyright (c) 2015 Paul Norman <penorman@mac.com>\n+#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>\n+#   Copyright (c) 2016, 2018 Krzesimir Nowak <qdlacz@gmail.com>\n+#   Copyright (c) 2019 Enji Cooper <yaneurabeya@gmail.com>\n+#   Copyright (c) 2020 Jason Merrill <jason@redhat.com>\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved.  This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 12\n+\n+dnl  This macro is based on the code from the AX_CXX_COMPILE_STDCXX_11 macro\n+dnl  (serial version number 13).\n+\n+AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl\n+  m4_if([$1], [11], [ax_cxx_compile_alternatives=\"11 0x\"],\n+        [$1], [14], [ax_cxx_compile_alternatives=\"14 1y\"],\n+        [$1], [17], [ax_cxx_compile_alternatives=\"17 1z\"],\n+        [m4_fatal([invalid first argument `$1' to AX_CXX_COMPILE_STDCXX])])dnl\n+  m4_if([$2], [], [],\n+        [$2], [ext], [],\n+        [$2], [noext], [],\n+        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX])])dnl\n+  m4_if([$3], [], [ax_cxx_compile_cxx$1_required=true],\n+        [$3], [mandatory], [ax_cxx_compile_cxx$1_required=true],\n+        [$3], [optional], [ax_cxx_compile_cxx$1_required=false],\n+        [m4_fatal([invalid third argument `$3' to AX_CXX_COMPILE_STDCXX])])\n+  AC_LANG_PUSH([C++])dnl\n+  ac_success=no\n+\n+  m4_if([$2], [], [dnl\n+    AC_CACHE_CHECK(whether $CXX supports C++$1 features by default,\n+\t\t   ax_cv_cxx_compile_cxx$1,\n+      [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n+        [ax_cv_cxx_compile_cxx$1=yes],\n+        [ax_cv_cxx_compile_cxx$1=no])])\n+    if test x$ax_cv_cxx_compile_cxx$1 = xyes; then\n+      ac_success=yes\n+    fi])\n+\n+  m4_if([$2], [noext], [], [dnl\n+  if test x$ac_success = xno; then\n+    for alternative in ${ax_cxx_compile_alternatives}; do\n+      switch=\"-std=gnu++${alternative}\"\n+      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])\n+      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,\n+                     $cachevar,\n+        [ac_save_CXX=\"$CXX\"\n+         CXX=\"$CXX $switch\"\n+         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n+          [eval $cachevar=yes],\n+          [eval $cachevar=no])\n+         CXX=\"$ac_save_CXX\"])\n+      if eval test x\\$$cachevar = xyes; then\n+        CXX=\"$CXX $switch\"\n+        if test -n \"$CXXCPP\" ; then\n+          CXXCPP=\"$CXXCPP $switch\"\n+        fi\n+        ac_success=yes\n+        break\n+      fi\n+    done\n+  fi])\n+\n+  m4_if([$2], [ext], [], [dnl\n+  if test x$ac_success = xno; then\n+    dnl HP's aCC needs +std=c++11 according to:\n+    dnl http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/PDF_Release_Notes/769149-001.pdf\n+    dnl Cray's crayCC needs \"-h std=c++11\"\n+    for alternative in ${ax_cxx_compile_alternatives}; do\n+      for switch in -std=c++${alternative} +std=c++${alternative} \"-h std=c++${alternative}\"; do\n+        cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])\n+        AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,\n+                       $cachevar,\n+          [ac_save_CXX=\"$CXX\"\n+           CXX=\"$CXX $switch\"\n+           AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n+            [eval $cachevar=yes],\n+            [eval $cachevar=no])\n+           CXX=\"$ac_save_CXX\"])\n+        if eval test x\\$$cachevar = xyes; then\n+          CXX=\"$CXX $switch\"\n+          if test -n \"$CXXCPP\" ; then\n+            CXXCPP=\"$CXXCPP $switch\"\n+          fi\n+          ac_success=yes\n+          break\n+        fi\n+      done\n+      if test x$ac_success = xyes; then\n+        break\n+      fi\n+    done\n+  fi])\n+  AC_LANG_POP([C++])\n+  if test x$ax_cxx_compile_cxx$1_required = xtrue; then\n+    if test x$ac_success = xno; then\n+      AC_MSG_ERROR([*** A compiler with support for C++$1 language features is required.])\n+    fi\n+  fi\n+  if test x$ac_success = xno; then\n+    HAVE_CXX$1=0\n+    AC_MSG_NOTICE([No compiler with C++$1 support was found])\n+  else\n+    HAVE_CXX$1=1\n+    AC_DEFINE(HAVE_CXX$1,1,\n+              [define if the compiler supports basic C++$1 syntax])\n+  fi\n+  AC_SUBST(HAVE_CXX$1)\n+])\n+\n+\n+dnl  Test body for checking C++11 support\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_11],\n+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11\n+)\n+\n+\n+dnl  Test body for checking C++14 support\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_14],\n+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11\n+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14\n+)\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_17],\n+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11\n+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14\n+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_17\n+)\n+\n+dnl  Tests for new features in C++11\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_11], [[\n+\n+// If the compiler admits that it is not ready for C++11, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201103L\n+\n+#error \"This is not a C++11 compiler\"\n+\n+#else\n+\n+namespace cxx11\n+{\n+\n+  namespace test_static_assert\n+  {\n+\n+    template <typename T>\n+    struct check\n+    {\n+      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n+    };\n+\n+  }\n+\n+  namespace test_final_override\n+  {\n+\n+    struct Base\n+    {\n+      virtual ~Base() {}\n+      virtual void f() {}\n+    };\n+\n+    struct Derived : public Base\n+    {\n+      virtual ~Derived() override {}\n+      virtual void f() override {}\n+    };\n+\n+  }\n+\n+  namespace test_double_right_angle_brackets\n+  {\n+\n+    template < typename T >\n+    struct check {};\n+\n+    typedef check<void> single_type;\n+    typedef check<check<void>> double_type;\n+    typedef check<check<check<void>>> triple_type;\n+    typedef check<check<check<check<void>>>> quadruple_type;\n+\n+  }\n+\n+  namespace test_decltype\n+  {\n+\n+    int\n+    f()\n+    {\n+      int a = 1;\n+      decltype(a) b = 2;\n+      return a + b;\n+    }\n+\n+  }\n+\n+  namespace test_type_deduction\n+  {\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static const bool value = true;\n+    };\n+\n+    template < typename T1, typename T2 >\n+    auto\n+    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n+    {\n+      return a1 + a2;\n+    }\n+\n+    int\n+    test(const int c, volatile int v)\n+    {\n+      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n+      auto ac = c;\n+      auto av = v;\n+      auto sumi = ac + av + 'x';\n+      auto sumf = ac + av + 1.0;\n+      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n+      return (sumf > 0.0) ? sumi : add(c, v);\n+    }\n+\n+  }\n+\n+  namespace test_noexcept\n+  {\n+\n+    int f() { return 0; }\n+    int g() noexcept { return 0; }\n+\n+    static_assert(noexcept(f()) == false, \"\");\n+    static_assert(noexcept(g()) == true, \"\");\n+\n+  }\n+\n+  namespace test_constexpr\n+  {\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n+    {\n+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n+    }\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      return strlen_c_r(s, 0UL);\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"1\") == 1UL, \"\");\n+    static_assert(strlen_c(\"example\") == 7UL, \"\");\n+    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_rvalue_references\n+  {\n+\n+    template < int N >\n+    struct answer\n+    {\n+      static constexpr int value = N;\n+    };\n+\n+    answer<1> f(int&)       { return answer<1>(); }\n+    answer<2> f(const int&) { return answer<2>(); }\n+    answer<3> f(int&&)      { return answer<3>(); }\n+\n+    void\n+    test()\n+    {\n+      int i = 0;\n+      const int c = 0;\n+      static_assert(decltype(f(i))::value == 1, \"\");\n+      static_assert(decltype(f(c))::value == 2, \"\");\n+      static_assert(decltype(f(0))::value == 3, \"\");\n+    }\n+\n+  }\n+\n+  namespace test_uniform_initialization\n+  {\n+\n+    struct test\n+    {\n+      static const int zero {};\n+      static const int one {1};\n+    };\n+\n+    static_assert(test::zero == 0, \"\");\n+    static_assert(test::one == 1, \"\");\n+\n+  }\n+\n+  namespace test_lambdas\n+  {\n+\n+    void\n+    test1()\n+    {\n+      auto lambda1 = [](){};\n+      auto lambda2 = lambda1;\n+      lambda1();\n+      lambda2();\n+    }\n+\n+    int\n+    test2()\n+    {\n+      auto a = [](int i, int j){ return i + j; }(1, 2);\n+      auto b = []() -> int { return '0'; }();\n+      auto c = [=](){ return a + b; }();\n+      auto d = [&](){ return c; }();\n+      auto e = [a, &b](int x) mutable {\n+        const auto identity = [](int y){ return y; };\n+        for (auto i = 0; i < a; ++i)\n+          a += b--;\n+        return x + identity(a + b);\n+      }(0);\n+      return a + b + c + d + e;\n+    }\n+\n+    int\n+    test3()\n+    {\n+      const auto nullary = [](){ return 0; };\n+      const auto unary = [](int x){ return x; };\n+      using nullary_t = decltype(nullary);\n+      using unary_t = decltype(unary);\n+      const auto higher1st = [](nullary_t f){ return f(); };\n+      const auto higher2nd = [unary](nullary_t f1){\n+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n+      };\n+      return higher1st(nullary) + higher2nd(nullary)(unary);\n+    }\n+\n+  }\n+\n+  namespace test_variadic_templates\n+  {\n+\n+    template <int...>\n+    struct sum;\n+\n+    template <int N0, int... N1toN>\n+    struct sum<N0, N1toN...>\n+    {\n+      static constexpr auto value = N0 + sum<N1toN...>::value;\n+    };\n+\n+    template <>\n+    struct sum<>\n+    {\n+      static constexpr auto value = 0;\n+    };\n+\n+    static_assert(sum<>::value == 0, \"\");\n+    static_assert(sum<1>::value == 1, \"\");\n+    static_assert(sum<23>::value == 23, \"\");\n+    static_assert(sum<1, 2>::value == 3, \"\");\n+    static_assert(sum<5, 5, 11>::value == 21, \"\");\n+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n+\n+  }\n+\n+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n+  // because of this.\n+  namespace test_template_alias_sfinae\n+  {\n+\n+    struct foo {};\n+\n+    template<typename T>\n+    using member = typename T::member_type;\n+\n+    template<typename T>\n+    void func(...) {}\n+\n+    template<typename T>\n+    void func(member<T>*) {}\n+\n+    void test();\n+\n+    void test() { func<foo>(0); }\n+\n+  }\n+\n+}  // namespace cxx11\n+\n+#endif  // __cplusplus >= 201103L\n+\n+]])\n+\n+\n+dnl  Tests for new features in C++14\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_14], [[\n+\n+// If the compiler admits that it is not ready for C++14, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201402L\n+\n+#error \"This is not a C++14 compiler\"\n+\n+#else\n+\n+namespace cxx14\n+{\n+\n+  namespace test_polymorphic_lambdas\n+  {\n+\n+    int\n+    test()\n+    {\n+      const auto lambda = [](auto&&... args){\n+        const auto istiny = [](auto x){\n+          return (sizeof(x) == 1UL) ? 1 : 0;\n+        };\n+        const int aretiny[] = { istiny(args)... };\n+        return aretiny[0];\n+      };\n+      return lambda(1, 1L, 1.0f, '1');\n+    }\n+\n+  }\n+\n+  namespace test_binary_literals\n+  {\n+\n+    constexpr auto ivii = 0b0000000000101010;\n+    static_assert(ivii == 42, \"wrong value\");\n+\n+  }\n+\n+  namespace test_generalized_constexpr\n+  {\n+\n+    template < typename CharT >\n+    constexpr unsigned long\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      auto length = 0UL;\n+      for (auto p = s; *p; ++p)\n+        ++length;\n+      return length;\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"x\") == 1UL, \"\");\n+    static_assert(strlen_c(\"test\") == 4UL, \"\");\n+    static_assert(strlen_c(\"another\\0test\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_lambda_init_capture\n+  {\n+\n+    int\n+    test()\n+    {\n+      auto x = 0;\n+      const auto lambda1 = [a = x](int b){ return a + b; };\n+      const auto lambda2 = [a = lambda1(x)](){ return a; };\n+      return lambda2();\n+    }\n+\n+  }\n+\n+  namespace test_digit_separators\n+  {\n+\n+    constexpr auto ten_million = 100'000'000;\n+    static_assert(ten_million == 100000000, \"\");\n+\n+  }\n+\n+  namespace test_return_type_deduction\n+  {\n+\n+    auto f(int& x) { return x; }\n+    decltype(auto) g(int& x) { return x; }\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static constexpr auto value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static constexpr auto value = true;\n+    };\n+\n+    int\n+    test()\n+    {\n+      auto x = 0;\n+      static_assert(is_same<int, decltype(f(x))>::value, \"\");\n+      static_assert(is_same<int&, decltype(g(x))>::value, \"\");\n+      return x;\n+    }\n+\n+  }\n+\n+}  // namespace cxx14\n+\n+#endif  // __cplusplus >= 201402L\n+\n+]])\n+\n+\n+dnl  Tests for new features in C++17\n+\n+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_17], [[\n+\n+// If the compiler admits that it is not ready for C++17, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201703L\n+\n+#error \"This is not a C++17 compiler\"\n+\n+#else\n+\n+#include <initializer_list>\n+#include <utility>\n+#include <type_traits>\n+\n+namespace cxx17\n+{\n+\n+  namespace test_constexpr_lambdas\n+  {\n+\n+    constexpr int foo = [](){return 42;}();\n+\n+  }\n+\n+  namespace test::nested_namespace::definitions\n+  {\n+\n+  }\n+\n+  namespace test_fold_expression\n+  {\n+\n+    template<typename... Args>\n+    int multiply(Args... args)\n+    {\n+      return (args * ... * 1);\n+    }\n+\n+    template<typename... Args>\n+    bool all(Args... args)\n+    {\n+      return (args && ...);\n+    }\n+\n+  }\n+\n+  namespace test_extended_static_assert\n+  {\n+\n+    static_assert (true);\n+\n+  }\n+\n+  namespace test_auto_brace_init_list\n+  {\n+\n+    auto foo = {5};\n+    auto bar {5};\n+\n+    static_assert(std::is_same<std::initializer_list<int>, decltype(foo)>::value);\n+    static_assert(std::is_same<int, decltype(bar)>::value);\n+  }\n+\n+  namespace test_typename_in_template_template_parameter\n+  {\n+\n+    template<template<typename> typename X> struct D;\n+\n+  }\n+\n+  namespace test_fallthrough_nodiscard_maybe_unused_attributes\n+  {\n+\n+    int f1()\n+    {\n+      return 42;\n+    }\n+\n+    [[nodiscard]] int f2()\n+    {\n+      [[maybe_unused]] auto unused = f1();\n+\n+      switch (f1())\n+      {\n+      case 17:\n+        f1();\n+        [[fallthrough]];\n+      case 42:\n+        f1();\n+      }\n+      return f1();\n+    }\n+\n+  }\n+\n+  namespace test_extended_aggregate_initialization\n+  {\n+\n+    struct base1\n+    {\n+      int b1, b2 = 42;\n+    };\n+\n+    struct base2\n+    {\n+      base2() {\n+        b3 = 42;\n+      }\n+      int b3;\n+    };\n+\n+    struct derived : base1, base2\n+    {\n+        int d;\n+    };\n+\n+    derived d1 {{1, 2}, {}, 4};  // full initialization\n+    derived d2 {{}, {}, 4};      // value-initialized bases\n+\n+  }\n+\n+  namespace test_general_range_based_for_loop\n+  {\n+\n+    struct iter\n+    {\n+      int i;\n+\n+      int& operator* ()\n+      {\n+        return i;\n+      }\n+\n+      const int& operator* () const\n+      {\n+        return i;\n+      }\n+\n+      iter& operator++()\n+      {\n+        ++i;\n+        return *this;\n+      }\n+    };\n+\n+    struct sentinel\n+    {\n+      int i;\n+    };\n+\n+    bool operator== (const iter& i, const sentinel& s)\n+    {\n+      return i.i == s.i;\n+    }\n+\n+    bool operator!= (const iter& i, const sentinel& s)\n+    {\n+      return !(i == s);\n+    }\n+\n+    struct range\n+    {\n+      iter begin() const\n+      {\n+        return {0};\n+      }\n+\n+      sentinel end() const\n+      {\n+        return {5};\n+      }\n+    };\n+\n+    void f()\n+    {\n+      range r {};\n+\n+      for (auto i : r)\n+      {\n+        [[maybe_unused]] auto v = i;\n+      }\n+    }\n+\n+  }\n+\n+  namespace test_lambda_capture_asterisk_this_by_value\n+  {\n+\n+    struct t\n+    {\n+      int i;\n+      int foo()\n+      {\n+        return [*this]()\n+        {\n+          return i;\n+        }();\n+      }\n+    };\n+\n+  }\n+\n+  namespace test_enum_class_construction\n+  {\n+\n+    enum class byte : unsigned char\n+    {};\n+\n+    byte foo {42};\n+\n+  }\n+\n+  namespace test_constexpr_if\n+  {\n+\n+    template <bool cond>\n+    int f ()\n+    {\n+      if constexpr(cond)\n+      {\n+        return 13;\n+      }\n+      else\n+      {\n+        return 42;\n+      }\n+    }\n+\n+  }\n+\n+  namespace test_selection_statement_with_initializer\n+  {\n+\n+    int f()\n+    {\n+      return 13;\n+    }\n+\n+    int f2()\n+    {\n+      if (auto i = f(); i > 0)\n+      {\n+        return 3;\n+      }\n+\n+      switch (auto i = f(); i + 4)\n+      {\n+      case 17:\n+        return 2;\n+\n+      default:\n+        return 1;\n+      }\n+    }\n+\n+  }\n+\n+  namespace test_template_argument_deduction_for_class_templates\n+  {\n+\n+    template <typename T1, typename T2>\n+    struct pair\n+    {\n+      pair (T1 p1, T2 p2)\n+        : m1 {p1},\n+          m2 {p2}\n+      {}\n+\n+      T1 m1;\n+      T2 m2;\n+    };\n+\n+    void f()\n+    {\n+      [[maybe_unused]] auto p = pair{13, 42u};\n+    }\n+\n+  }\n+\n+  namespace test_non_type_auto_template_parameters\n+  {\n+\n+    template <auto n>\n+    struct B\n+    {};\n+\n+    B<5> b1;\n+    B<'a'> b2;\n+\n+  }\n+\n+  namespace test_structured_bindings\n+  {\n+\n+    int arr[2] = { 1, 2 };\n+    std::pair<int, int> pr = { 1, 2 };\n+\n+    auto f1() -> int(&)[2]\n+    {\n+      return arr;\n+    }\n+\n+    auto f2() -> std::pair<int, int>&\n+    {\n+      return pr;\n+    }\n+\n+    struct S\n+    {\n+      int x1 : 2;\n+      volatile double y1;\n+    };\n+\n+    S f3()\n+    {\n+      return {};\n+    }\n+\n+    auto [ x1, y1 ] = f1();\n+    auto& [ xr1, yr1 ] = f1();\n+    auto [ x2, y2 ] = f2();\n+    auto& [ xr2, yr2 ] = f2();\n+    const auto [ x3, y3 ] = f3();\n+\n+  }\n+\n+  namespace test_exception_spec_type_system\n+  {\n+\n+    struct Good {};\n+    struct Bad {};\n+\n+    void g1() noexcept;\n+    void g2();\n+\n+    template<typename T>\n+    Bad\n+    f(T*, T*);\n+\n+    template<typename T1, typename T2>\n+    Good\n+    f(T1*, T2*);\n+\n+    static_assert (std::is_same_v<Good, decltype(f(g1, g2))>);\n+\n+  }\n+\n+  namespace test_inline_variables\n+  {\n+\n+    template<class T> void f(T)\n+    {}\n+\n+    template<class T> inline T g(T)\n+    {\n+      return T{};\n+    }\n+\n+    template<> inline void f<>(int)\n+    {}\n+\n+    template<> int g<>(int)\n+    {\n+      return 5;\n+    }\n+\n+  }\n+\n+}  // namespace cxx17\n+\n+#endif  // __cplusplus < 201703L\n+\n+]])"}, {"sha": "3af6a530b9adea965bfbb07cb19c28574a51d977", "filename": "configure", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "patch": "@@ -5523,10 +5523,10 @@ $as_echo \"$as_me: WARNING: trying to bootstrap a cross compiler\" >&2;}\n     ;;\n esac\n \n-# When bootstrapping with GCC, build stage 1 in C++98 mode to ensure that a\n-# C++98 compiler can still start the bootstrap.\n+# When bootstrapping with GCC, build stage 1 in C++11 mode to ensure that a\n+# C++11 compiler can still start the bootstrap.\n if test \"$enable_bootstrap:$GXX\" = \"yes:yes\"; then\n-  CXX=\"$CXX -std=gnu++98\"\n+  CXX=\"$CXX -std=c++11\"\n fi\n \n # Used for setting $lt_cv_objdir"}, {"sha": "a67801371a4eabd38e5d99398e17134e5166447c", "filename": "configure.ac", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "patch": "@@ -1462,10 +1462,10 @@ case \"$have_compiler:$host:$target:$enable_bootstrap\" in\n     ;;\n esac\n \n-# When bootstrapping with GCC, build stage 1 in C++98 mode to ensure that a\n-# C++98 compiler can still start the bootstrap.\n+# When bootstrapping with GCC, build stage 1 in C++11 mode to ensure that a\n+# C++11 compiler can still start the bootstrap.\n if test \"$enable_bootstrap:$GXX\" = \"yes:yes\"; then\n-  CXX=\"$CXX -std=gnu++98\"\n+  CXX=\"$CXX -std=c++11\"\n fi\n \n # Used for setting $lt_cv_objdir"}, {"sha": "7f484da04f0d60156ac9ccc24ec499b365116fda", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "patch": "@@ -1,3 +1,13 @@\n+2020-05-18  Jason Merrill  <jason@redhat.com>\n+\n+\t* aclocal.m4: Add ax_cxx_compile_stdcxx.m4.\n+\t* configure.ac: Use AX_CXX_COMPILE_STDCXX(11).\n+\n+2020-05-14  Jason Merrill  <jason@redhat.com>\n+\n+\t* doc/install.texi (Prerequisites): Update boostrap compiler\n+\trequirement to C++11/GCC 4.8.\n+\n 2020-05-18  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>\n \n \tPR tree-optimization/94952"}, {"sha": "e93c153506392636789f3b82d76d915f01708ca0", "filename": "gcc/aclocal.m4", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/gcc%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/gcc%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Faclocal.m4?ref=5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "patch": "@@ -18,6 +18,7 @@ m4_include([../ltsugar.m4])\n m4_include([../ltversion.m4])\n m4_include([../lt~obsolete.m4])\n m4_include([../config/acx.m4])\n+m4_include([../config/ax_cxx_compile_stdcxx.m4])\n m4_include([../config/cet.m4])\n m4_include([../config/codeset.m4])\n m4_include([../config/depstand.m4])"}, {"sha": "4531d50eb0fec1456610f1afbed964704cb623f1", "filename": "gcc/configure", "status": "modified", "additions": 996, "deletions": 2, "changes": 998, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "patch": "@@ -847,6 +847,7 @@ c_loose_warn\n loose_warn\n aliasing_flags\n CPP\n+HAVE_CXX11\n EGREP\n GREP\n CXXCPP\n@@ -5708,6 +5709,999 @@ $as_echo \"$ac_cv_safe_to_define___extensions__\" >&6; }\n   $as_echo \"#define _TANDEM_SOURCE 1\" >>confdefs.h\n \n \n+\n+  ax_cxx_compile_alternatives=\"11 0x\"    ax_cxx_compile_cxx11_required=true\n+  ac_ext=cpp\n+ac_cpp='$CXXCPP $CPPFLAGS'\n+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n+  ac_success=no\n+\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features by default\" >&5\n+$as_echo_n \"checking whether $CXX supports C++11 features by default... \" >&6; }\n+if ${ax_cv_cxx_compile_cxx11+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+\n+// If the compiler admits that it is not ready for C++11, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201103L\n+\n+#error \"This is not a C++11 compiler\"\n+\n+#else\n+\n+namespace cxx11\n+{\n+\n+  namespace test_static_assert\n+  {\n+\n+    template <typename T>\n+    struct check\n+    {\n+      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n+    };\n+\n+  }\n+\n+  namespace test_final_override\n+  {\n+\n+    struct Base\n+    {\n+      virtual ~Base() {}\n+      virtual void f() {}\n+    };\n+\n+    struct Derived : public Base\n+    {\n+      virtual ~Derived() override {}\n+      virtual void f() override {}\n+    };\n+\n+  }\n+\n+  namespace test_double_right_angle_brackets\n+  {\n+\n+    template < typename T >\n+    struct check {};\n+\n+    typedef check<void> single_type;\n+    typedef check<check<void>> double_type;\n+    typedef check<check<check<void>>> triple_type;\n+    typedef check<check<check<check<void>>>> quadruple_type;\n+\n+  }\n+\n+  namespace test_decltype\n+  {\n+\n+    int\n+    f()\n+    {\n+      int a = 1;\n+      decltype(a) b = 2;\n+      return a + b;\n+    }\n+\n+  }\n+\n+  namespace test_type_deduction\n+  {\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static const bool value = true;\n+    };\n+\n+    template < typename T1, typename T2 >\n+    auto\n+    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n+    {\n+      return a1 + a2;\n+    }\n+\n+    int\n+    test(const int c, volatile int v)\n+    {\n+      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n+      auto ac = c;\n+      auto av = v;\n+      auto sumi = ac + av + 'x';\n+      auto sumf = ac + av + 1.0;\n+      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n+      return (sumf > 0.0) ? sumi : add(c, v);\n+    }\n+\n+  }\n+\n+  namespace test_noexcept\n+  {\n+\n+    int f() { return 0; }\n+    int g() noexcept { return 0; }\n+\n+    static_assert(noexcept(f()) == false, \"\");\n+    static_assert(noexcept(g()) == true, \"\");\n+\n+  }\n+\n+  namespace test_constexpr\n+  {\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n+    {\n+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n+    }\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      return strlen_c_r(s, 0UL);\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"1\") == 1UL, \"\");\n+    static_assert(strlen_c(\"example\") == 7UL, \"\");\n+    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_rvalue_references\n+  {\n+\n+    template < int N >\n+    struct answer\n+    {\n+      static constexpr int value = N;\n+    };\n+\n+    answer<1> f(int&)       { return answer<1>(); }\n+    answer<2> f(const int&) { return answer<2>(); }\n+    answer<3> f(int&&)      { return answer<3>(); }\n+\n+    void\n+    test()\n+    {\n+      int i = 0;\n+      const int c = 0;\n+      static_assert(decltype(f(i))::value == 1, \"\");\n+      static_assert(decltype(f(c))::value == 2, \"\");\n+      static_assert(decltype(f(0))::value == 3, \"\");\n+    }\n+\n+  }\n+\n+  namespace test_uniform_initialization\n+  {\n+\n+    struct test\n+    {\n+      static const int zero {};\n+      static const int one {1};\n+    };\n+\n+    static_assert(test::zero == 0, \"\");\n+    static_assert(test::one == 1, \"\");\n+\n+  }\n+\n+  namespace test_lambdas\n+  {\n+\n+    void\n+    test1()\n+    {\n+      auto lambda1 = [](){};\n+      auto lambda2 = lambda1;\n+      lambda1();\n+      lambda2();\n+    }\n+\n+    int\n+    test2()\n+    {\n+      auto a = [](int i, int j){ return i + j; }(1, 2);\n+      auto b = []() -> int { return '0'; }();\n+      auto c = [=](){ return a + b; }();\n+      auto d = [&](){ return c; }();\n+      auto e = [a, &b](int x) mutable {\n+        const auto identity = [](int y){ return y; };\n+        for (auto i = 0; i < a; ++i)\n+          a += b--;\n+        return x + identity(a + b);\n+      }(0);\n+      return a + b + c + d + e;\n+    }\n+\n+    int\n+    test3()\n+    {\n+      const auto nullary = [](){ return 0; };\n+      const auto unary = [](int x){ return x; };\n+      using nullary_t = decltype(nullary);\n+      using unary_t = decltype(unary);\n+      const auto higher1st = [](nullary_t f){ return f(); };\n+      const auto higher2nd = [unary](nullary_t f1){\n+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n+      };\n+      return higher1st(nullary) + higher2nd(nullary)(unary);\n+    }\n+\n+  }\n+\n+  namespace test_variadic_templates\n+  {\n+\n+    template <int...>\n+    struct sum;\n+\n+    template <int N0, int... N1toN>\n+    struct sum<N0, N1toN...>\n+    {\n+      static constexpr auto value = N0 + sum<N1toN...>::value;\n+    };\n+\n+    template <>\n+    struct sum<>\n+    {\n+      static constexpr auto value = 0;\n+    };\n+\n+    static_assert(sum<>::value == 0, \"\");\n+    static_assert(sum<1>::value == 1, \"\");\n+    static_assert(sum<23>::value == 23, \"\");\n+    static_assert(sum<1, 2>::value == 3, \"\");\n+    static_assert(sum<5, 5, 11>::value == 21, \"\");\n+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n+\n+  }\n+\n+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n+  // because of this.\n+  namespace test_template_alias_sfinae\n+  {\n+\n+    struct foo {};\n+\n+    template<typename T>\n+    using member = typename T::member_type;\n+\n+    template<typename T>\n+    void func(...) {}\n+\n+    template<typename T>\n+    void func(member<T>*) {}\n+\n+    void test();\n+\n+    void test() { func<foo>(0); }\n+\n+  }\n+\n+}  // namespace cxx11\n+\n+#endif  // __cplusplus >= 201103L\n+\n+\n+\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  ax_cv_cxx_compile_cxx11=yes\n+else\n+  ax_cv_cxx_compile_cxx11=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_cxx_compile_cxx11\" >&5\n+$as_echo \"$ax_cv_cxx_compile_cxx11\" >&6; }\n+    if test x$ax_cv_cxx_compile_cxx11 = xyes; then\n+      ac_success=yes\n+    fi\n+\n+    if test x$ac_success = xno; then\n+    for alternative in ${ax_cxx_compile_alternatives}; do\n+      switch=\"-std=gnu++${alternative}\"\n+      cachevar=`$as_echo \"ax_cv_cxx_compile_cxx11_$switch\" | $as_tr_sh`\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features with $switch\" >&5\n+$as_echo_n \"checking whether $CXX supports C++11 features with $switch... \" >&6; }\n+if eval \\${$cachevar+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_save_CXX=\"$CXX\"\n+         CXX=\"$CXX $switch\"\n+         cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+\n+// If the compiler admits that it is not ready for C++11, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201103L\n+\n+#error \"This is not a C++11 compiler\"\n+\n+#else\n+\n+namespace cxx11\n+{\n+\n+  namespace test_static_assert\n+  {\n+\n+    template <typename T>\n+    struct check\n+    {\n+      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n+    };\n+\n+  }\n+\n+  namespace test_final_override\n+  {\n+\n+    struct Base\n+    {\n+      virtual ~Base() {}\n+      virtual void f() {}\n+    };\n+\n+    struct Derived : public Base\n+    {\n+      virtual ~Derived() override {}\n+      virtual void f() override {}\n+    };\n+\n+  }\n+\n+  namespace test_double_right_angle_brackets\n+  {\n+\n+    template < typename T >\n+    struct check {};\n+\n+    typedef check<void> single_type;\n+    typedef check<check<void>> double_type;\n+    typedef check<check<check<void>>> triple_type;\n+    typedef check<check<check<check<void>>>> quadruple_type;\n+\n+  }\n+\n+  namespace test_decltype\n+  {\n+\n+    int\n+    f()\n+    {\n+      int a = 1;\n+      decltype(a) b = 2;\n+      return a + b;\n+    }\n+\n+  }\n+\n+  namespace test_type_deduction\n+  {\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static const bool value = true;\n+    };\n+\n+    template < typename T1, typename T2 >\n+    auto\n+    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n+    {\n+      return a1 + a2;\n+    }\n+\n+    int\n+    test(const int c, volatile int v)\n+    {\n+      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n+      auto ac = c;\n+      auto av = v;\n+      auto sumi = ac + av + 'x';\n+      auto sumf = ac + av + 1.0;\n+      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n+      return (sumf > 0.0) ? sumi : add(c, v);\n+    }\n+\n+  }\n+\n+  namespace test_noexcept\n+  {\n+\n+    int f() { return 0; }\n+    int g() noexcept { return 0; }\n+\n+    static_assert(noexcept(f()) == false, \"\");\n+    static_assert(noexcept(g()) == true, \"\");\n+\n+  }\n+\n+  namespace test_constexpr\n+  {\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n+    {\n+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n+    }\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      return strlen_c_r(s, 0UL);\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"1\") == 1UL, \"\");\n+    static_assert(strlen_c(\"example\") == 7UL, \"\");\n+    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_rvalue_references\n+  {\n+\n+    template < int N >\n+    struct answer\n+    {\n+      static constexpr int value = N;\n+    };\n+\n+    answer<1> f(int&)       { return answer<1>(); }\n+    answer<2> f(const int&) { return answer<2>(); }\n+    answer<3> f(int&&)      { return answer<3>(); }\n+\n+    void\n+    test()\n+    {\n+      int i = 0;\n+      const int c = 0;\n+      static_assert(decltype(f(i))::value == 1, \"\");\n+      static_assert(decltype(f(c))::value == 2, \"\");\n+      static_assert(decltype(f(0))::value == 3, \"\");\n+    }\n+\n+  }\n+\n+  namespace test_uniform_initialization\n+  {\n+\n+    struct test\n+    {\n+      static const int zero {};\n+      static const int one {1};\n+    };\n+\n+    static_assert(test::zero == 0, \"\");\n+    static_assert(test::one == 1, \"\");\n+\n+  }\n+\n+  namespace test_lambdas\n+  {\n+\n+    void\n+    test1()\n+    {\n+      auto lambda1 = [](){};\n+      auto lambda2 = lambda1;\n+      lambda1();\n+      lambda2();\n+    }\n+\n+    int\n+    test2()\n+    {\n+      auto a = [](int i, int j){ return i + j; }(1, 2);\n+      auto b = []() -> int { return '0'; }();\n+      auto c = [=](){ return a + b; }();\n+      auto d = [&](){ return c; }();\n+      auto e = [a, &b](int x) mutable {\n+        const auto identity = [](int y){ return y; };\n+        for (auto i = 0; i < a; ++i)\n+          a += b--;\n+        return x + identity(a + b);\n+      }(0);\n+      return a + b + c + d + e;\n+    }\n+\n+    int\n+    test3()\n+    {\n+      const auto nullary = [](){ return 0; };\n+      const auto unary = [](int x){ return x; };\n+      using nullary_t = decltype(nullary);\n+      using unary_t = decltype(unary);\n+      const auto higher1st = [](nullary_t f){ return f(); };\n+      const auto higher2nd = [unary](nullary_t f1){\n+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n+      };\n+      return higher1st(nullary) + higher2nd(nullary)(unary);\n+    }\n+\n+  }\n+\n+  namespace test_variadic_templates\n+  {\n+\n+    template <int...>\n+    struct sum;\n+\n+    template <int N0, int... N1toN>\n+    struct sum<N0, N1toN...>\n+    {\n+      static constexpr auto value = N0 + sum<N1toN...>::value;\n+    };\n+\n+    template <>\n+    struct sum<>\n+    {\n+      static constexpr auto value = 0;\n+    };\n+\n+    static_assert(sum<>::value == 0, \"\");\n+    static_assert(sum<1>::value == 1, \"\");\n+    static_assert(sum<23>::value == 23, \"\");\n+    static_assert(sum<1, 2>::value == 3, \"\");\n+    static_assert(sum<5, 5, 11>::value == 21, \"\");\n+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n+\n+  }\n+\n+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n+  // because of this.\n+  namespace test_template_alias_sfinae\n+  {\n+\n+    struct foo {};\n+\n+    template<typename T>\n+    using member = typename T::member_type;\n+\n+    template<typename T>\n+    void func(...) {}\n+\n+    template<typename T>\n+    void func(member<T>*) {}\n+\n+    void test();\n+\n+    void test() { func<foo>(0); }\n+\n+  }\n+\n+}  // namespace cxx11\n+\n+#endif  // __cplusplus >= 201103L\n+\n+\n+\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  eval $cachevar=yes\n+else\n+  eval $cachevar=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+         CXX=\"$ac_save_CXX\"\n+fi\n+eval ac_res=\\$$cachevar\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+      if eval test x\\$$cachevar = xyes; then\n+        CXX=\"$CXX $switch\"\n+        if test -n \"$CXXCPP\" ; then\n+          CXXCPP=\"$CXXCPP $switch\"\n+        fi\n+        ac_success=yes\n+        break\n+      fi\n+    done\n+  fi\n+\n+    if test x$ac_success = xno; then\n+                for alternative in ${ax_cxx_compile_alternatives}; do\n+      for switch in -std=c++${alternative} +std=c++${alternative} \"-h std=c++${alternative}\"; do\n+        cachevar=`$as_echo \"ax_cv_cxx_compile_cxx11_$switch\" | $as_tr_sh`\n+        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features with $switch\" >&5\n+$as_echo_n \"checking whether $CXX supports C++11 features with $switch... \" >&6; }\n+if eval \\${$cachevar+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_save_CXX=\"$CXX\"\n+           CXX=\"$CXX $switch\"\n+           cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+\n+// If the compiler admits that it is not ready for C++11, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201103L\n+\n+#error \"This is not a C++11 compiler\"\n+\n+#else\n+\n+namespace cxx11\n+{\n+\n+  namespace test_static_assert\n+  {\n+\n+    template <typename T>\n+    struct check\n+    {\n+      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n+    };\n+\n+  }\n+\n+  namespace test_final_override\n+  {\n+\n+    struct Base\n+    {\n+      virtual ~Base() {}\n+      virtual void f() {}\n+    };\n+\n+    struct Derived : public Base\n+    {\n+      virtual ~Derived() override {}\n+      virtual void f() override {}\n+    };\n+\n+  }\n+\n+  namespace test_double_right_angle_brackets\n+  {\n+\n+    template < typename T >\n+    struct check {};\n+\n+    typedef check<void> single_type;\n+    typedef check<check<void>> double_type;\n+    typedef check<check<check<void>>> triple_type;\n+    typedef check<check<check<check<void>>>> quadruple_type;\n+\n+  }\n+\n+  namespace test_decltype\n+  {\n+\n+    int\n+    f()\n+    {\n+      int a = 1;\n+      decltype(a) b = 2;\n+      return a + b;\n+    }\n+\n+  }\n+\n+  namespace test_type_deduction\n+  {\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static const bool value = true;\n+    };\n+\n+    template < typename T1, typename T2 >\n+    auto\n+    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n+    {\n+      return a1 + a2;\n+    }\n+\n+    int\n+    test(const int c, volatile int v)\n+    {\n+      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n+      auto ac = c;\n+      auto av = v;\n+      auto sumi = ac + av + 'x';\n+      auto sumf = ac + av + 1.0;\n+      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n+      return (sumf > 0.0) ? sumi : add(c, v);\n+    }\n+\n+  }\n+\n+  namespace test_noexcept\n+  {\n+\n+    int f() { return 0; }\n+    int g() noexcept { return 0; }\n+\n+    static_assert(noexcept(f()) == false, \"\");\n+    static_assert(noexcept(g()) == true, \"\");\n+\n+  }\n+\n+  namespace test_constexpr\n+  {\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n+    {\n+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n+    }\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      return strlen_c_r(s, 0UL);\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"1\") == 1UL, \"\");\n+    static_assert(strlen_c(\"example\") == 7UL, \"\");\n+    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_rvalue_references\n+  {\n+\n+    template < int N >\n+    struct answer\n+    {\n+      static constexpr int value = N;\n+    };\n+\n+    answer<1> f(int&)       { return answer<1>(); }\n+    answer<2> f(const int&) { return answer<2>(); }\n+    answer<3> f(int&&)      { return answer<3>(); }\n+\n+    void\n+    test()\n+    {\n+      int i = 0;\n+      const int c = 0;\n+      static_assert(decltype(f(i))::value == 1, \"\");\n+      static_assert(decltype(f(c))::value == 2, \"\");\n+      static_assert(decltype(f(0))::value == 3, \"\");\n+    }\n+\n+  }\n+\n+  namespace test_uniform_initialization\n+  {\n+\n+    struct test\n+    {\n+      static const int zero {};\n+      static const int one {1};\n+    };\n+\n+    static_assert(test::zero == 0, \"\");\n+    static_assert(test::one == 1, \"\");\n+\n+  }\n+\n+  namespace test_lambdas\n+  {\n+\n+    void\n+    test1()\n+    {\n+      auto lambda1 = [](){};\n+      auto lambda2 = lambda1;\n+      lambda1();\n+      lambda2();\n+    }\n+\n+    int\n+    test2()\n+    {\n+      auto a = [](int i, int j){ return i + j; }(1, 2);\n+      auto b = []() -> int { return '0'; }();\n+      auto c = [=](){ return a + b; }();\n+      auto d = [&](){ return c; }();\n+      auto e = [a, &b](int x) mutable {\n+        const auto identity = [](int y){ return y; };\n+        for (auto i = 0; i < a; ++i)\n+          a += b--;\n+        return x + identity(a + b);\n+      }(0);\n+      return a + b + c + d + e;\n+    }\n+\n+    int\n+    test3()\n+    {\n+      const auto nullary = [](){ return 0; };\n+      const auto unary = [](int x){ return x; };\n+      using nullary_t = decltype(nullary);\n+      using unary_t = decltype(unary);\n+      const auto higher1st = [](nullary_t f){ return f(); };\n+      const auto higher2nd = [unary](nullary_t f1){\n+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n+      };\n+      return higher1st(nullary) + higher2nd(nullary)(unary);\n+    }\n+\n+  }\n+\n+  namespace test_variadic_templates\n+  {\n+\n+    template <int...>\n+    struct sum;\n+\n+    template <int N0, int... N1toN>\n+    struct sum<N0, N1toN...>\n+    {\n+      static constexpr auto value = N0 + sum<N1toN...>::value;\n+    };\n+\n+    template <>\n+    struct sum<>\n+    {\n+      static constexpr auto value = 0;\n+    };\n+\n+    static_assert(sum<>::value == 0, \"\");\n+    static_assert(sum<1>::value == 1, \"\");\n+    static_assert(sum<23>::value == 23, \"\");\n+    static_assert(sum<1, 2>::value == 3, \"\");\n+    static_assert(sum<5, 5, 11>::value == 21, \"\");\n+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n+\n+  }\n+\n+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n+  // because of this.\n+  namespace test_template_alias_sfinae\n+  {\n+\n+    struct foo {};\n+\n+    template<typename T>\n+    using member = typename T::member_type;\n+\n+    template<typename T>\n+    void func(...) {}\n+\n+    template<typename T>\n+    void func(member<T>*) {}\n+\n+    void test();\n+\n+    void test() { func<foo>(0); }\n+\n+  }\n+\n+}  // namespace cxx11\n+\n+#endif  // __cplusplus >= 201103L\n+\n+\n+\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  eval $cachevar=yes\n+else\n+  eval $cachevar=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+           CXX=\"$ac_save_CXX\"\n+fi\n+eval ac_res=\\$$cachevar\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+        if eval test x\\$$cachevar = xyes; then\n+          CXX=\"$CXX $switch\"\n+          if test -n \"$CXXCPP\" ; then\n+            CXXCPP=\"$CXXCPP $switch\"\n+          fi\n+          ac_success=yes\n+          break\n+        fi\n+      done\n+      if test x$ac_success = xyes; then\n+        break\n+      fi\n+    done\n+  fi\n+  ac_ext=cpp\n+ac_cpp='$CXXCPP $CPPFLAGS'\n+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n+\n+  if test x$ax_cxx_compile_cxx11_required = xtrue; then\n+    if test x$ac_success = xno; then\n+      as_fn_error $? \"*** A compiler with support for C++11 language features is required.\" \"$LINENO\" 5\n+    fi\n+  fi\n+  if test x$ac_success = xno; then\n+    HAVE_CXX11=0\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: No compiler with C++11 support was found\" >&5\n+$as_echo \"$as_me: No compiler with C++11 support was found\" >&6;}\n+  else\n+    HAVE_CXX11=1\n+\n+$as_echo \"#define HAVE_CXX11 1\" >>confdefs.h\n+\n+  fi\n+\n+\n+\n ac_ext=c\n ac_cpp='$CPP $CPPFLAGS'\n ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n@@ -19018,7 +20012,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19021 \"configure\"\n+#line 20015 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -19124,7 +20118,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19127 \"configure\"\n+#line 20121 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "60d83c307715c712794413f1291305d2b3a96ed1", "filename": "gcc/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "patch": "@@ -385,6 +385,9 @@ AC_SUBST(PICFLAG_FOR_TARGET)\n # -------------------------\n \n AC_USE_SYSTEM_EXTENSIONS\n+\n+AX_CXX_COMPILE_STDCXX(11)\n+\n AC_PROG_CPP\n AC_C_INLINE\n "}, {"sha": "c367f4f66e327fe8ca63cbfe7df72658a7ff54fe", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=5329b59a2e13dabbe2038af0fe2e3cf5fc7f98ed", "patch": "@@ -238,18 +238,20 @@ described below.\n \n @heading Tools/packages necessary for building GCC\n @table @asis\n-@item ISO C++98 compiler\n-Necessary to bootstrap GCC, although versions of GCC prior\n-to 4.8 also allow bootstrapping with a ISO C89 compiler and versions\n-of GCC prior to 3.4 also allow bootstrapping with a traditional\n-(K&R) C compiler.\n+@item ISO C++11 compiler\n+Necessary to bootstrap GCC.\n+\n+Versions of GCC prior to 11 also allow bootstrapping with an ISO C++98\n+compiler, versions of GCC prior to 4.8 also allow bootstrapping with a\n+ISO C89 compiler, and versions of GCC prior to 3.4 also allow\n+bootstrapping with a traditional (K&R) C compiler.\n \n To build all languages in a cross-compiler or other configuration where\n 3-stage bootstrap is not performed, you need to start with an existing\n-GCC binary (version 3.4 or later) because source code for language\n+GCC binary (version 4.8 or later) because source code for language\n frontends other than C might use GCC extensions.\n \n-Note that to bootstrap GCC with versions of GCC earlier than 3.4, you\n+Note that to bootstrap GCC with versions of GCC earlier than 4.8, you\n may need to use @option{--disable-stage1-checking}, though\n bootstrapping the compiler with such earlier compilers is strongly\n discouraged."}]}