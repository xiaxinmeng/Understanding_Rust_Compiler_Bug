{"sha": "a45d420abf5125d73bfdc2d2af3753b810c349eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ1ZDQyMGFiZjUxMjVkNzNiZmRjMmQyYWYzNzUzYjgxMGMzNDllYg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2011-02-15T17:09:39Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2011-02-15T17:09:39Z"}, "message": "mn10300.c: Include tm-constrs.h.\n\n\t* config/mn10300/mn10300.c: Include tm-constrs.h.\n\t(struct liw_data): New data structure describing an LIW candidate\n\tinstruction.\n\t(extract_bundle): Use struct liw_data.  Allow small integer\n\toperands for some instructions.\n\t(check_liw_constraints): Use struct liw_data.  Remove swapped\n\tparameter.  Add comments describing the checks.  Fix bug when\n\tassigning the source of liw1 to the source of liw2.\n\t(liw_candidate): Delete.  Code moved into extract_bundle.\n\t(mn10300_bundle_liw): Use struct liw_data.  Check constraints\n\tbefore swapping.\n\t* config/mn10300/predicates.md (liw_operand): New predicate.\n\tAllows registers and small integer constants.\n\t* config/mn10300/constraints.md (O): New constraint.  Accetps\n\tintegers in the range -8 to +7 inclusive.\n\t* config/mn10300/mn10300.md (movesi_internal): Add an alternative\n\tfor moving a small integer into a register.  Give this alternative\n\tLIW attributes.\n\t(addsi3, subsi3, cmpsi, lshrsi3, ashrsi3): Likewise.\n\t(ashlsi3): Likewise, plus give LIW attributes to the alternatives\n\tusing the J,K,L and M constraints,\n\t(liw): Remove SI mode on second operands to allow for HI and QI\n\tmode values.\n\t(cmp_liw, liw_cmp): Likewise.  Plus fix order of operands in the\n\tinstruction.\n\nFrom-SVN: r170182", "tree": {"sha": "060852815ff3bf81b7fef60acee53e79f440a99b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/060852815ff3bf81b7fef60acee53e79f440a99b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a45d420abf5125d73bfdc2d2af3753b810c349eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a45d420abf5125d73bfdc2d2af3753b810c349eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a45d420abf5125d73bfdc2d2af3753b810c349eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a45d420abf5125d73bfdc2d2af3753b810c349eb/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a73faf108721a76f55441f6d2a3937fff901b36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a73faf108721a76f55441f6d2a3937fff901b36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a73faf108721a76f55441f6d2a3937fff901b36"}], "stats": {"total": 358, "additions": 218, "deletions": 140}, "files": [{"sha": "a6d81d03550c18ec22bd7c6d7ee7273f4dd1bdb9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45d420abf5125d73bfdc2d2af3753b810c349eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45d420abf5125d73bfdc2d2af3753b810c349eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a45d420abf5125d73bfdc2d2af3753b810c349eb", "patch": "@@ -1,3 +1,31 @@\n+2011-02-15  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/mn10300/mn10300.c: Include tm-constrs.h.\n+\t(struct liw_data): New data structure describing an LIW candidate\n+\tinstruction.\n+\t(extract_bundle): Use struct liw_data.  Allow small integer\n+\toperands for some instructions.\n+\t(check_liw_constraints): Use struct liw_data.  Remove swapped\n+\tparameter.  Add comments describing the checks.  Fix bug when\n+\tassigning the source of liw1 to the source of liw2.\n+\t(liw_candidate): Delete.  Code moved into extract_bundle.\n+\t(mn10300_bundle_liw): Use struct liw_data.  Check constraints\n+\tbefore swapping.\n+\t* config/mn10300/predicates.md (liw_operand): New predicate.\n+\tAllows registers and small integer constants.\n+\t* config/mn10300/constraints.md (O): New constraint.  Accetps\n+\tintegers in the range -8 to +7 inclusive.\n+\t* config/mn10300/mn10300.md (movesi_internal): Add an alternative\n+\tfor moving a small integer into a register.  Give this alternative\n+\tLIW attributes.\n+\t(addsi3, subsi3, cmpsi, lshrsi3, ashrsi3): Likewise.\n+\t(ashlsi3): Likewise, plus give LIW attributes to the alternatives\n+\tusing the J,K,L and M constraints,\n+\t(liw): Remove SI mode on second operands to allow for HI and QI\n+\tmode values.\n+\t(cmp_liw, liw_cmp): Likewise.  Plus fix order of operands in the\n+\tinstruction.\n+\n 2011-02-15  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR middle-end/47725"}, {"sha": "c8ee2d4e2d960e871edba3539ce60e3ea481c0d9", "filename": "gcc/config/mn10300/constraints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45d420abf5125d73bfdc2d2af3753b810c349eb/gcc%2Fconfig%2Fmn10300%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45d420abf5125d73bfdc2d2af3753b810c349eb/gcc%2Fconfig%2Fmn10300%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fconstraints.md?ref=a45d420abf5125d73bfdc2d2af3753b810c349eb", "patch": "@@ -94,6 +94,12 @@\n        (ior (match_test \"ival == 255\")\n \t    (match_test \"ival == 65535\"))))\n \n+(define_constraint \"O\"\n+  \"An integer between -8 and +7 inclusive.\"\n+  (and (match_code \"const_int\")\n+       (and (match_test \"ival >= -8\")\n+\t    (match_test \"ival <=  7\"))))\n+\n ;; Floating-point constraints\n (define_constraint \"G\"\n   \"Floating-point zero.\""}, {"sha": "0b68f2d3e858a4560cbb0af51cec4acf8a3ed06b", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 122, "deletions": 89, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45d420abf5125d73bfdc2d2af3753b810c349eb/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45d420abf5125d73bfdc2d2af3753b810c349eb/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=a45d420abf5125d73bfdc2d2af3753b810c349eb", "patch": "@@ -40,6 +40,7 @@\n #include \"obstack.h\"\n #include \"diagnostic-core.h\"\n #include \"tm_p.h\"\n+#include \"tm-constrs.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"df.h\"\n@@ -2945,91 +2946,143 @@ mn10300_split_and_operand_count (rtx op)\n     }\n }\n \f\n-/* Extract operands and (if requested) the LIW op type from the insn.\n-   Returns false if the insn can't be bundled.  */\n+struct liw_data\n+{\n+  enum attr_liw slot;\n+  enum attr_liw_op op;\n+  rtx dest;\n+  rtx src;\n+};\n+\n+/* Decide if the given insn is a candidate for LIW bundling.  If it is then\n+   extract the operands and LIW attributes from the insn and use them to fill\n+   in the liw_data structure.  Return true upon success or false if the insn\n+   cannot be bundled.  */\n \n static bool\n-extract_bundle (rtx insn, rtx * ops, enum attr_liw_op * plop)\n+extract_bundle (rtx insn, struct liw_data * pdata)\n {\n-  enum attr_liw_op lop;\n-  rtx p, s;\n+  bool allow_consts = true;\n+  rtx p,s;\n \n+  gcc_assert (pdata != NULL);\n+\n+  if (insn == NULL_RTX)\n+    return false;\n+  /* Make sure that we are dealing with a simple SET insn.  */\n   p = single_set (insn);\n+  if (p == NULL_RTX)\n+    return false;\n+\n+  /* Make sure that it could go into one of the LIW pipelines.  */\n+  pdata->slot = get_attr_liw (insn);\n+  if (pdata->slot == LIW_BOTH)\n+    return false;\n+\n+  pdata->op = get_attr_liw_op (insn);\n+\n   s = SET_SRC (p);\n-  lop = get_attr_liw_op (insn);\n-  if (plop != NULL)\n-    * plop = lop;\n \n-  switch (lop)\n+  switch (pdata->op)\n     {\n     case LIW_OP_MOV:\n-      ops[0] = SET_DEST (p);\n-      ops[1] = SET_SRC (p);\n+      pdata->dest = SET_DEST (p);\n+      pdata->src = SET_SRC (p);\n       break;\n     case LIW_OP_CMP:\n-      ops[0] = XEXP (SET_SRC (p), 0);\n-      ops[1] = XEXP (SET_SRC (p), 1);\n+      pdata->dest = XEXP (SET_SRC (p), 0);\n+      pdata->src = XEXP (SET_SRC (p), 1);\n       break;\n     case LIW_OP_NONE:\n       return false;\n+    case LIW_OP_AND:\n+    case LIW_OP_OR:\n+    case LIW_OP_XOR:\n+      /* The AND, OR and XOR long instruction words only accept register arguments.  */\n+      allow_consts = false;\n+      /* Fall through.  */\n     default:\n-      ops[0] = SET_DEST (p);\n-      ops[1] = XEXP (SET_SRC (p), 1);\n+      pdata->dest = SET_DEST (p);\n+      pdata->src = XEXP (SET_SRC (p), 1);\n       break;\n     }\n \n-  return REG_P (ops[0]) && REG_P (ops[1]);\n+  if (! REG_P (pdata->dest))\n+    return false;\n+\n+  if (REG_P (pdata->src))\n+    return true;\n+\n+  return allow_consts && satisfies_constraint_O (pdata->src);\n }\n \n-/* Look for conflicts in the operands used in\n-   the potential bundling of the two insns.  */\n+/* Make sure that it is OK to execute LIW1 and LIW2 in parallel.  GCC generated\n+   the instructions with the assumption that LIW1 would be executed before LIW2\n+   so we must check for overlaps between their sources and destinations.  */\n \n static bool\n-check_liw_constraints (rtx ops[4],\n-\t\t       enum attr_liw_op op1,\n-\t\t       enum attr_liw_op op2,\n-\t\t       bool swapped)\n-{\n-  /* Look for the two destination registers being the same.  This is OK if\n-     the first op is a comparison op, since it will compare the value prior\n-     to the completion of the second op.  */\n-  if (REGNO (ops[0]) == REGNO (ops[2])\n-      && ( (! swapped && op1 != LIW_OP_CMP)\n-\t  || (swapped && op2 != LIW_OP_CMP)))\n+check_liw_constraints (struct liw_data * pliw1, struct liw_data * pliw2)\n+{\n+  /* Check for slot conflicts.  */\n+  if (pliw2->slot == pliw1->slot && pliw1->slot != LIW_EITHER)\n     return false;\n \n-  /* Look for the source of the second op being the destination of the first op.\n-     Nomrally this will prevent the bundling since GCC has generated sequential\n-     operations and the LIW opcodes are executed in parallel.  But if the first\n-     opcode is a MOV, we can copy its source to the second ops source.  */\n-  if (swapped)\n-    return REGNO (ops[1]) != REGNO (ops[2]);\n+  /* If either operation is a compare, then \"dest\" is really an input; the real\n+     destination is CC_REG.  So these instructions need different checks.  */\n+\n+  /* Changing \"CMP ; OP\" into \"CMP | OP\" is OK because the comparison will\n+     check its values prior to any changes made by OP.  */\n+  if (pliw1->op == LIW_OP_CMP)\n+    {\n+      /* Two sequential comparisons means dead code, which ought to \n+         have been eliminated given that bundling only happens with\n+         optimization.  We cannot bundle them in any case.  */\n+      gcc_assert (pliw1->op != pliw2->op);\n+      return true;\n+    }\n \n-  if (REGNO (ops[3]) == REGNO (ops[0]))\n+  /* Changing \"OP ; CMP\" into \"OP | CMP\" does not work if the value being compared\n+     is the destination of OP, as the CMP will look at the old value, not the new\n+     one.  */\n+  if (pliw2->op == LIW_OP_CMP)\n     {\n-      if (op1 == LIW_OP_MOV)\n+      if (REGNO (pliw2->dest) == REGNO (pliw1->dest))\n+\treturn false;\n+\n+      if (REG_P (pliw2->src))\n+\treturn REGNO (pliw2->src) != REGNO (pliw1->dest);\n+\n+      return true;\n+    }\n+\n+  /* Changing \"OP1 ; OP2\" into \"OP1 | OP2\" does not work if they both write to the\n+     same destination register.  */\n+  if (REGNO (pliw2->dest) == REGNO (pliw1->dest))\n+    return false;\n+\n+  /* Changing \"OP1 ; OP2\" into \"OP1 | OP2\" generally does not work if the destination\n+     of OP1 is the source of OP2.  The exception is when OP1 is a MOVE instruction when\n+     we can replace the source in OP2 with the source of OP1.  */\n+  if (REG_P (pliw2->src) && REGNO (pliw2->src) == REGNO (pliw1->dest))\n+    {\n+      if (pliw1->op == LIW_OP_MOV && REG_P (pliw1->src))\n \t{\n-\t  ops[3] = ops[1];\n+\t  if (! REG_P (pliw1->src)\n+\t      && (pliw2->op == LIW_OP_AND\n+\t\t  || pliw2->op == LIW_OP_OR\n+\t\t  || pliw2->op == LIW_OP_XOR))\n+\t    return false;\n+\t\t  \n+\t  pliw2->src = pliw1->src;\n \t  return true;\n \t}\n       return false;\n     }\n \n+  /* Everything else is OK.  */\n   return true;\n }\n \n-/* Decide if the given insn is a candidate for LIW bundling.  For now we just\n-   check that the insn has an LIW attribute.  Later on we check operand\n-   constraints and such.  */\n-\n-static bool\n-liw_candidate (rtx insn)\n-{\n-  return insn != NULL_RTX\n-    && single_set (insn) != NULL_RTX\n-    && get_attr_liw (insn) != LIW_BOTH;\n-}\n-\n /* Combine pairs of insns into LIW bundles.  */\n \n static void\n@@ -3039,61 +3092,41 @@ mn10300_bundle_liw (void)\n \n   for (r = get_insns (); r != NULL_RTX; r = next_nonnote_nondebug_insn (r))\n     {\n-      rtx insn1, insn2, ops[4];\n-      enum attr_liw liw1, liw2;\n-      enum attr_liw_op op1, op2;\n-      bool swapped = false;\n+      rtx insn1, insn2;\n+      struct liw_data liw1, liw2;\n \n       insn1 = r;\n-      if (! liw_candidate (insn1))\n+      if (! extract_bundle (insn1, & liw1))\n \tcontinue;\n \n       insn2 = next_nonnote_nondebug_insn (insn1);\n-      if (! liw_candidate (insn2))\n+      if (! extract_bundle (insn2, & liw2))\n \tcontinue;\n \n-      liw1 = get_attr_liw (insn1);\n-      if (liw1 == LIW_BOTH)\n-\tcontinue;\n-      liw2 = get_attr_liw (insn2);\n-      if (liw2 == LIW_BOTH)\n-\tcontinue;\n-      if (liw2 == liw1 && liw1 != LIW_EITHER)\n+      /* Check for source/destination overlap.  */\n+      if (! check_liw_constraints (& liw1, & liw2))\n \tcontinue;\n \n-      /* The scheduler always groups the insns correctly, but not\n-\t always in sequence.  So, we can do a naive check and expect\n-\t it to work.  */\n-      if (liw1 == LIW_OP2 || liw2 == LIW_OP1)\n+      if (liw1.slot == LIW_OP2 || liw2.slot == LIW_OP1)\n \t{\n-\t  rtx r;\n-\t  enum attr_liw lt;\n-\n-\t  r = insn1;\n-\t  insn1 = insn2;\n-\t  insn2 = r;\n-\t  lt = liw1;\n+\t  struct liw_data temp;\n+\t  \n+\t  temp = liw1;\n \t  liw1 = liw2;\n-\t  liw2 = lt;\n-\t  swapped = true;\n+\t  liw2 = temp;\n \t}\n \n-      if (! extract_bundle (insn1, ops, & op1))\n-\tcontinue;\n-      if (! extract_bundle (insn2, ops + 2, & op2))\n-\tcontinue;\n-      if (! check_liw_constraints (ops, op1, op2, swapped))\n-\tcontinue;\n-\n       delete_insn (insn2);\n \n-      if (op1 == LIW_OP_CMP)\n-\tinsn2 = gen_cmp_liw (ops[2], ops[3], ops[0], ops[1], GEN_INT (op2));\n-      else if (op2 == LIW_OP_CMP)\n-\tinsn2 = gen_liw_cmp (ops[0], ops[1], ops[2], ops[3], GEN_INT (op1));\n+      if (liw1.op == LIW_OP_CMP)\n+\tinsn2 = gen_cmp_liw (liw2.dest, liw2.src, liw1.dest, liw1.src,\n+\t\t\t     GEN_INT (liw2.op));\n+      else if (liw2.op == LIW_OP_CMP)\n+\tinsn2 = gen_liw_cmp (liw1.dest, liw1.src, liw2.dest, liw2.src,\n+\t\t\t     GEN_INT (liw1.op));\n       else\n-\tinsn2 = gen_liw (ops[0], ops[2], ops[1], ops[3],\n-\t\t\t GEN_INT (op1), GEN_INT (op2));\n+\tinsn2 = gen_liw (liw1.dest, liw2.dest, liw1.src, liw2.src,\n+\t\t\t GEN_INT (liw1.op), GEN_INT (liw2.op));\n \n       insn2 = emit_insn_after (insn2, insn1);\n       delete_insn (insn1);"}, {"sha": "3d8e914705250514b23179c7d08f33200cc23e1e", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 58, "deletions": 51, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45d420abf5125d73bfdc2d2af3753b810c349eb/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45d420abf5125d73bfdc2d2af3753b810c349eb/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=a45d420abf5125d73bfdc2d2af3753b810c349eb", "patch": "@@ -419,17 +419,18 @@\n \n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\t  \"=r,r,r,m,r, A,*y,*y,*z,*d\")\n+\t\t\t  \"=r,r,r,r,m,r, A,*y,*y,*z,*d\")\n \t(match_operand:SI 1 \"general_operand\"\n-\t\t\t  \" 0,i,r,r,m,*y, A, i,*d,*z\"))]\n+\t\t\t  \" 0,O,i,r,r,m,*y, A, i,*d,*z\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\"\n {\n   switch (which_alternative)\n     {\n     case 0:\n       return \"\";\n-    case 1: /* imm-reg*/\n+    case 1: /* imm-reg.  */\n+    case 2: \n       /* See movhi for a discussion of sizes for 8-bit movu.  Note that the\n \t 24-bit movu is 6 bytes, which is the same size as the full 32-bit\n \t mov form for An and Dn.  So again movu is only a win for Rn.  */\n@@ -443,24 +444,25 @@\n \t    return \"movu %1,%0\";\n \t}\n       /* FALLTHRU */\n-    case 2:  /* reg-reg */\n-    case 3:  /* reg-mem */\n-    case 4:  /* mem-reg */\n-    case 5:  /* sp-reg */\n-    case 6:  /* reg-sp */\n-    case 7:  /* imm-sp */\n-    case 8:  /* reg-mdr */\n-    case 9:  /* mdr-reg */\n+    case 3:  /* reg-reg */\n+    case 4:  /* reg-mem */\n+    case 5:  /* mem-reg */\n+    case 6:  /* sp-reg */\n+    case 7:  /* reg-sp */\n+    case 8:  /* imm-sp */\n+    case 9:  /* reg-mdr */\n+    case 10:  /* mdr-reg */\n       return \"mov %1,%0\";\n     default:\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"isa\" \"*,*,*,*,*,*,*,am33,*,*\")\n-   (set_attr \"liw\" \"*,*,either,*,*,*,*,*,*,*\")\n+  [(set_attr \"isa\" \"*,*,*,*,*,*,*,*,am33,*,*\")\n+   (set_attr \"liw\" \"*,either,*,either,*,*,*,*,*,*,*\")\n    (set_attr \"liw_op\" \"mov\")\n    (set_attr_alternative \"timings\"\n \t [(const_int 11)\n+\t  (const_int 22)\n \t  (const_int 22)\n \t  (const_int 11)\n \t  (if_then_else (eq_attr \"cpu\" \"am34\")\n@@ -563,14 +565,14 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"addsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\"  \"=r,r,!*y,!r\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,  0, r\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\"  \"r,i,  i, r\")))\n+  [(set (match_operand:SI          0 \"register_operand\"  \"=r,r,r,!*y,!r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,0,  0, r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\"  \"r,O,i,  i, r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   { return mn10300_output_add (operands, false); }\n-  [(set_attr \"timings\" \"11,11,11,22\")\n-   (set_attr \"liw\" \"either,*,*,*\")\n+  [(set_attr \"timings\" \"11,11,11,11,22\")\n+   (set_attr \"liw\" \"either,either,*,*,*\")\n    (set_attr \"liw_op\" \"add\")]\n )\n \n@@ -758,19 +760,20 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"subsi3\"\n-  [(set (match_operand:SI           0 \"register_operand\"  \"=r,r,r\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\"   \"0,0,r\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\"  \"r,i,r\")))\n+  [(set (match_operand:SI           0 \"register_operand\"  \"=r,r,r,r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\"   \"0,0,0,r\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\"  \"r,O,i,r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"@\n+   sub %2,%0\n    sub %2,%0\n    sub %2,%0\n    sub %2,%1,%0\"\n-  [(set_attr \"isa\" \"*,*,am33\")\n-   (set_attr \"liw\" \"either,*,*\")\n+  [(set_attr \"isa\" \"*,*,*,am33\")\n+   (set_attr \"liw\" \"either,either,*,*\")\n    (set_attr \"liw_op\" \"sub\")\n-   (set_attr \"timings\" \"11,11,22\")]\n+   (set_attr \"timings\" \"11,11,11,22\")]\n )\n \n (define_insn \"*subsi3_flags\"\n@@ -1374,8 +1377,8 @@\n \n (define_insn \"*cmpsi\"\n   [(set (reg CC_REG)\n-\t(compare (match_operand:SI 0 \"register_operand\"  \"r,r\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"r,i\")))]\n+\t(compare (match_operand:SI 0 \"register_operand\"  \"r,r,r\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"r,O,i\")))]\n   \"reload_completed\"\n {\n   /* The operands of CMP must be distinct registers.  In the case where\n@@ -1390,8 +1393,9 @@\n }\n   [(set_attr_alternative \"timings\"\n      [(if_then_else (eq_attr \"cpu\" \"am34\") (const_int 11) (const_int 22))\n+      (if_then_else (eq_attr \"cpu\" \"am34\") (const_int 11) (const_int 22))\n       (if_then_else (eq_attr \"cpu\" \"am34\") (const_int 11) (const_int 22))])\n-   (set_attr \"liw\" \"either,*\")\n+   (set_attr \"liw\" \"either,either,*\")\n    (set_attr \"liw_op\" \"cmp\")]\n )\n \n@@ -1732,10 +1736,10 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"ashlsi3\"\n-  [(set (match_operand:SI  0 \"register_operand\"   \"=r,D,d,d,D,D,r\")\n+  [(set (match_operand:SI  0 \"register_operand\"   \"=r,D,d,d,D,D,D,r\")\n \t(ashift:SI\n-\t  (match_operand:SI 1 \"register_operand\"  \" 0,0,0,0,0,0,r\")\n-\t  (match_operand:QI 2 \"nonmemory_operand\" \" J,K,M,L,D,i,r\")))\n+\t  (match_operand:SI 1 \"register_operand\"  \" 0,0,0,0,0,0,0,r\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \" J,K,M,L,D,O,i,r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"@\n@@ -1745,42 +1749,45 @@\n    asl2 %0\\;asl2 %0\n    asl %S2,%0\n    asl %S2,%0\n+   asl %S2,%0\n    asl %2,%1,%0\"\n-  [(set_attr \"isa\" \"*,*,*,*,*,*,am33\")\n-   (set_attr \"liw\" \"*,*,*,*,op2,*,*\")\n+  [(set_attr \"isa\" \"*,*,*,*,*,*,*,am33\")\n+   (set_attr \"liw\" \"op2,op2,op2,op2,op2,op2,*,*\")\n    (set_attr \"liw_op\" \"asl\")\n-   (set_attr \"timings\" \"11,11,22,22,11,11,11\")]\n+   (set_attr \"timings\" \"11,11,22,22,11,11,11,11\")]\n )\n \n (define_insn \"lshrsi3\"\n-  [(set (match_operand:SI  0 \"register_operand\"  \"=D,D,r\")\n+  [(set (match_operand:SI  0 \"register_operand\"  \"=D,D,D,r\")\n \t(lshiftrt:SI\n-\t  (match_operand:SI 1 \"register_operand\"  \"0,0,r\")\n-\t  (match_operand:QI 2 \"nonmemory_operand\" \"D,i,r\")))\n+\t  (match_operand:SI 1 \"register_operand\"  \"0,0,0,r\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"D,O,i,r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"@\n+   lsr %S2,%0\n    lsr %S2,%0\n    lsr %S2,%0\n    lsr %2,%1,%0\"\n-  [(set_attr \"isa\" \"*,*,am33\")\n-   (set_attr \"liw\" \"op2,*,*\")\n+  [(set_attr \"isa\" \"*,*,*,am33\")\n+   (set_attr \"liw\" \"op2,op2,*,*\")\n    (set_attr \"liw_op\" \"lsr\")]\n )\n \n (define_insn \"ashrsi3\"\n-  [(set (match_operand:SI  0 \"register_operand\"  \"=D,D,r\")\n+  [(set (match_operand:SI  0 \"register_operand\"  \"=D,D,D,r\")\n \t(ashiftrt:SI\n-\t  (match_operand:SI 1 \"register_operand\"  \"0,0,r\")\n-\t  (match_operand:QI 2 \"nonmemory_operand\" \"D,i,r\")))\n+\t  (match_operand:SI 1 \"register_operand\"  \"0,0,0,r\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"D,O,i,r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"@\n+   asr %S2,%0\n    asr %S2,%0\n    asr %S2,%0\n    asr %2,%1,%0\"\n-  [(set_attr \"isa\" \"*,*,am33\")\n-   (set_attr \"liw\" \"op2,*,*\")\n+  [(set_attr \"isa\" \"*,*,*,am33\")\n+   (set_attr \"liw\" \"op2,op2,*,*\")\n    (set_attr \"liw_op\" \"asr\")]\n )\n \n@@ -2100,12 +2107,12 @@\n (define_insn \"liw\"\n   [(set (match_operand:SI             0 \"register_operand\" \"=r\")\n \t(unspec:SI [(match_dup 0)\n-                    (match_operand:SI 2 \"register_operand\" \"r\")\n+                    (match_operand    2 \"liw_operand\"       \"rO\")\n                     (match_operand:SI 4 \"const_int_operand\" \"\")]\n                    UNSPEC_LIW))\n    (set (match_operand:SI             1 \"register_operand\" \"=r\")\n         (unspec:SI [(match_dup 1)\n-                    (match_operand    3 \"register_operand\" \"r\")\n+                    (match_operand    3 \"liw_operand\"       \"rO\")\n                     (match_operand:SI 5 \"const_int_operand\" \"\")]\n                    UNSPEC_LIW))]\n   \"TARGET_ALLOW_LIW\"\n@@ -2119,29 +2126,29 @@\n (define_insn \"cmp_liw\"\n   [(set (reg:CC CC_REG)\n \t(compare:CC (match_operand:SI 2 \"register_operand\" \"r\")\n-\t\t    (match_operand:SI 3 \"register_operand\" \"r\")))\n+\t\t    (match_operand    3 \"liw_operand\"      \"rO\")))\n    (set (match_operand:SI             0 \"register_operand\" \"=r\")\n         (unspec:SI [(match_dup 0)\n-                    (match_operand    1 \"register_operand\" \"r\")\n+                    (match_operand    1 \"liw_operand\"       \"rO\")\n                     (match_operand:SI 4 \"const_int_operand\" \"\")]\n                    UNSPEC_LIW))]\n   \"TARGET_ALLOW_LIW\"\n-  \"cmp_%W4 %2, %3, %0, %1\"\n+  \"cmp_%W4 %3, %2, %1, %0\"\n   [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n \t\t\t\t       (const_int 13) (const_int 12)))]\n )\n \n (define_insn \"liw_cmp\"\n   [(set (match_operand:SI             0 \"register_operand\" \"=r\")\n         (unspec:SI [(match_dup 0)\n-                    (match_operand:SI 1 \"register_operand\" \"r\")\n+                    (match_operand    1 \"liw_operand\"      \"rO\")\n                     (match_operand:SI 4 \"const_int_operand\" \"\")]\n                    UNSPEC_LIW))\n    (set (reg:CC CC_REG)\n \t(compare:CC (match_operand:SI 2 \"register_operand\" \"r\")\n-\t\t    (match_operand:SI 3 \"register_operand\" \"r\")))]\n+\t\t    (match_operand    3 \"liw_operand\"      \"rO\")))]\n   \"TARGET_ALLOW_LIW\"\n-  \"%W4_cmp %0, %1, %2, %3\"\n+  \"%W4_cmp %1, %0, %3, %2\"\n   [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n \t\t\t\t       (const_int 13) (const_int 12)))]\n )"}, {"sha": "4c78c51e4634daa4edda2fbcf3e30030e96b306d", "filename": "gcc/config/mn10300/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45d420abf5125d73bfdc2d2af3753b810c349eb/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45d420abf5125d73bfdc2d2af3753b810c349eb/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fpredicates.md?ref=a45d420abf5125d73bfdc2d2af3753b810c349eb", "patch": "@@ -63,3 +63,7 @@\n \n (define_predicate \"CCZN_comparison_operator\"\n   (match_code \"eq,ne,lt,ge\"))\n+\n+(define_predicate \"liw_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_test \"satisfies_constraint_O (op)\")))"}]}