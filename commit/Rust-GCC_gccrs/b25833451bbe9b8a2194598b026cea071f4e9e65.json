{"sha": "b25833451bbe9b8a2194598b026cea071f4e9e65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1ODMzNDUxYmJlOWI4YTIxOTQ1OThiMDI2Y2VhMDcxZjRlOWU2NQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-11-18T09:53:52Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-11-18T09:53:52Z"}, "message": "re PR c++/3187 (gcc lays down two copies of constructors)\n\n\tPR c++/3187\n\t* cgraph.h (struct cgraph_node): Add same_body and same_body_alias\n\tfields.\n\t(cgraph_same_body_alias, cgraph_remove_same_body_alias): New\n\tprototypes.\n\t* cgraphunit.c (cgraph_expand_function, cgraph_emit_thunks,\n\tcgraph_materialize_all_clones): Handle same_body aliases.\n\t* cgraph.c (cgraph_allocate_node): New function.\n\t(cgraph_create_node): Use it.\n\t(cgraph_node_for_decl, cgraph_node, cgraph_get_node,\n\tcgraph_node_for_asm, cgraph_remove_node): Handle same_body aliases.\n\t(cgraph_same_body_alias, cgraph_remove_same_body_alias): New\n\tfunctions.\n\t* lto-cgraph.c (lto_output_node): Stream out same_body aliases.\n\t(input_node): Stream in same_body aliases.\n\t* lto-symtab.c (lto_cgraph_replace_node): Clear node pointers\n\tfor same_body aliases.\n\t(lto_symtab_merge_cgraph_nodes_1): Handle same_body aliases.\n\n\t* cp-tree.h (expand_or_defer_fn_1): New prototype.\n\t* decl2.c (cp_write_global_declarations): Mark as !DECL_EXTERNAL\n\talso all same_body aliases.\n\t* semantics.c (expand_or_defer_fn): Move most of the function\n\texcept registering with cgraph to ...\n\t(expand_or_defer_fn_1): ... here.  New function.\n\t* optimize.c: Include cgraph.h.\n\t(maybe_clone_body): If in charge parm is not used and both base\n\tand complete clones are created and are not comdat, tell cgraph\n\tthey have the same body.\n\t* Make-lang.in (cp/optimize.o): Depend on $(CGRAPH_H).\n\n\t* g++.dg/abi/mangle26.C: Also match *C2* definition.\n\t* g++.dg/abi/mangle27.C: Likewise.\n\t* g++.dg/abi/mangle28.C: Likewise.\n\t* g++.dg/abi/mangle29.C: Likewise.\n\nFrom-SVN: r154284", "tree": {"sha": "e08b1ed30e6c41061167a50b2e85f7af35d6e70c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e08b1ed30e6c41061167a50b2e85f7af35d6e70c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b25833451bbe9b8a2194598b026cea071f4e9e65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25833451bbe9b8a2194598b026cea071f4e9e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b25833451bbe9b8a2194598b026cea071f4e9e65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25833451bbe9b8a2194598b026cea071f4e9e65/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a64333b7ea23dfc1d9d512adfbfec1aeeb9e9366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a64333b7ea23dfc1d9d512adfbfec1aeeb9e9366", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a64333b7ea23dfc1d9d512adfbfec1aeeb9e9366"}], "stats": {"total": 400, "additions": 361, "deletions": 39}, "files": [{"sha": "3ec03fc5b700ae855a4b33d90f4608c6ec00ae57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -1,3 +1,24 @@\n+2009-11-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/3187\n+\t* cgraph.h (struct cgraph_node): Add same_body and same_body_alias\n+\tfields.\n+\t(cgraph_same_body_alias, cgraph_remove_same_body_alias): New\n+\tprototypes.\n+\t* cgraphunit.c (cgraph_expand_function, cgraph_emit_thunks,\n+\tcgraph_materialize_all_clones): Handle same_body aliases.\n+\t* cgraph.c (cgraph_allocate_node): New function.\n+\t(cgraph_create_node): Use it.\n+\t(cgraph_node_for_decl, cgraph_node, cgraph_get_node,\n+\tcgraph_node_for_asm, cgraph_remove_node): Handle same_body aliases.\n+\t(cgraph_same_body_alias, cgraph_remove_same_body_alias): New\n+\tfunctions.\n+\t* lto-cgraph.c (lto_output_node): Stream out same_body aliases.\n+\t(input_node): Stream in same_body aliases.\n+\t* lto-symtab.c (lto_cgraph_replace_node): Clear node pointers\n+\tfor same_body aliases.\n+\t(lto_symtab_merge_cgraph_nodes_1): Handle same_body aliases.\n+\n 2009-11-18  Iain Sandoe <iain.sandoe@sandoe-acoustics.co.uk>\n \n \tPR other/39888"}, {"sha": "02beae92469b8f1a25167e64a147a29e456ff532", "filename": "gcc/cgraph.c", "status": "modified", "additions": 135, "deletions": 9, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -425,7 +425,11 @@ cgraph_node_for_decl (tree decl)\n       key.decl = decl;\n       slot = htab_find_slot (cgraph_hash, &key, NO_INSERT);\n       if (slot && *slot)\n-\tnode = (struct cgraph_node *) *slot;\n+\t{\n+\t  node = (struct cgraph_node *) *slot;\n+\t  if (node->same_body_alias)\n+\t    node = node->same_body;\n+\t}\n     }\n \n   return node;\n@@ -442,10 +446,10 @@ eq_node (const void *p1, const void *p2)\n   return DECL_UID (n1->decl) == DECL_UID (n2->decl);\n }\n \n-/* Allocate new callgraph node and insert it into basic data structures.  */\n+/* Allocate new callgraph node.  */\n \n-static struct cgraph_node *\n-cgraph_create_node (void)\n+static inline struct cgraph_node *\n+cgraph_allocate_node (void)\n {\n   struct cgraph_node *node;\n \n@@ -460,6 +464,16 @@ cgraph_create_node (void)\n       node->uid = cgraph_max_uid++;\n     }\n \n+  return node;\n+}\n+\n+/* Allocate new callgraph node and insert it into basic data structures.  */\n+\n+static struct cgraph_node *\n+cgraph_create_node (void)\n+{\n+  struct cgraph_node *node = cgraph_allocate_node ();\n+\n   node->next = cgraph_nodes;\n   node->pid = -1;\n   node->order = cgraph_order++;\n@@ -491,6 +505,8 @@ cgraph_node (tree decl)\n   if (*slot)\n     {\n       node = *slot;\n+      if (node->same_body_alias)\n+\tnode = node->same_body;\n       return node;\n     }\n \n@@ -521,6 +537,52 @@ cgraph_node (tree decl)\n   return node;\n }\n \n+/* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n+   Same body aliases are output whenever the body of DECL is output,\n+   and cgraph_node (ALIAS) transparently returns cgraph_node (DECL).  */\n+\n+bool\n+cgraph_same_body_alias (tree alias, tree decl)\n+{\n+  struct cgraph_node key, *alias_node, *decl_node, **slot;\n+\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n+  gcc_assert (TREE_CODE (alias) == FUNCTION_DECL);\n+  gcc_assert (!assembler_name_hash);\n+\n+#ifndef ASM_OUTPUT_DEF\n+  /* If aliases aren't supported by the assembler, fail.  */\n+  return false;\n+#endif\n+\n+  /* Comdat same body aliases are only supported when comdat groups\n+     are supported and the symbols are weak.  */\n+  if (DECL_ONE_ONLY (decl) && (!HAVE_COMDAT_GROUP || !DECL_WEAK (decl)))\n+    return false;\n+\n+  decl_node = cgraph_node (decl);\n+\n+  key.decl = alias;\n+\n+  slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key, INSERT);\n+\n+  /* If the cgraph_node has been already created, fail.  */\n+  if (*slot)\n+    return false;\n+\n+  alias_node = cgraph_allocate_node ();\n+  alias_node->decl = alias;\n+  alias_node->same_body_alias = 1;\n+  alias_node->same_body = decl_node;\n+  alias_node->previous = NULL;\n+  if (decl_node->same_body)\n+    decl_node->same_body->previous = alias_node;\n+  alias_node->next = decl_node->same_body;\n+  decl_node->same_body = alias_node;\n+  *slot = alias_node;\n+  return true;\n+}\n+\n /* Returns the cgraph node assigned to DECL or NULL if no cgraph node\n    is assigned.  */\n \n@@ -540,7 +602,11 @@ cgraph_get_node (tree decl)\n \t\t\t\t\t\t NO_INSERT);\n \n   if (slot && *slot)\n-    node = *slot;\n+    {\n+      node = *slot;\n+      if (node->same_body_alias)\n+\tnode = node->same_body;\n+    }\n   return node;\n }\n \n@@ -601,9 +667,23 @@ cgraph_node_for_asm (tree asmname)\n \t       it is __builtin_strlen and strlen, for instance.  Do we need to\n \t       record them all?  Original implementation marked just first one\n \t       so lets hope for the best.  */\n-\t    if (*slot)\n-\t      continue;\n-\t    *slot = node;\n+\t    if (!*slot)\n+\t      *slot = node;\n+\t    if (node->same_body)\n+\t      {\n+\t\tstruct cgraph_node *alias;\n+\n+\t\tfor (alias = node->same_body; alias; alias = alias->next)\n+\t\t  {\n+\t\t    hashval_t hash;\n+\t\t    name = DECL_ASSEMBLER_NAME (alias->decl);\n+\t\t    hash = decl_assembler_name_hash (name);\n+\t\t    slot = htab_find_slot_with_hash (assembler_name_hash, name,\n+\t\t\t\t\t\t     hash,  INSERT);\n+\t\t    if (!*slot)\n+\t\t      *slot = alias;\n+\t\t  }\n+\t      }\n \t  }\n     }\n \n@@ -612,7 +692,12 @@ cgraph_node_for_asm (tree asmname)\n \t\t\t\t   NO_INSERT);\n \n   if (slot)\n-    return (struct cgraph_node *) *slot;\n+    {\n+      node = (struct cgraph_node *) *slot;\n+      if (node->same_body_alias)\n+\tnode = node->same_body;\n+      return node;\n+    }\n   return NULL;\n }\n \n@@ -1146,6 +1231,44 @@ cgraph_release_function_body (struct cgraph_node *node)\n     DECL_INITIAL (node->decl) = error_mark_node;\n }\n \n+/* Remove same body alias node.  */\n+\n+void\n+cgraph_remove_same_body_alias (struct cgraph_node *node)\n+{\n+  void **slot;\n+  int uid = node->uid;\n+\n+  gcc_assert (node->same_body_alias);\n+  if (node->previous)\n+    node->previous->next = node->next;\n+  else\n+    node->same_body->same_body = node->next;\n+  if (node->next)\n+    node->next->previous = node->previous;\n+  node->next = NULL;\n+  node->previous = NULL;\n+  slot = htab_find_slot (cgraph_hash, node, NO_INSERT);\n+  if (*slot == node)\n+    htab_clear_slot (cgraph_hash, slot);\n+  if (assembler_name_hash)\n+    {\n+      tree name = DECL_ASSEMBLER_NAME (node->decl);\n+      slot = htab_find_slot_with_hash (assembler_name_hash, name,\n+\t\t\t\t       decl_assembler_name_hash (name),\n+\t\t\t\t       NO_INSERT);\n+      if (slot && *slot == node)\n+\thtab_clear_slot (assembler_name_hash, slot);\n+    }\n+\n+  /* Clear out the node to NULL all pointers and add the node to the free\n+     list.  */\n+  memset (node, 0, sizeof(*node));\n+  node->uid = uid;\n+  NEXT_FREE_NODE (node) = free_nodes;\n+  free_nodes = node;\n+}\n+\n /* Remove the node from cgraph.  */\n \n void\n@@ -1283,6 +1406,9 @@ cgraph_remove_node (struct cgraph_node *node)\n       node->clone_of->clones = node->clones;\n     }\n \n+  while (node->same_body)\n+    cgraph_remove_same_body_alias (node->same_body);\n+\n   /* While all the clones are removed after being proceeded, the function\n      itself is kept in the cgraph even after it is compiled.  Check whether\n      we are done with this body and reclaim it proactively if this is the case."}, {"sha": "02c087d772e616150eecf5a25e90f5d079bc5c33", "filename": "gcc/cgraph.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -184,6 +184,9 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   struct cgraph_node *prev_sibling_clone;\n   struct cgraph_node *clones;\n   struct cgraph_node *clone_of;\n+  /* For normal nodes pointer to the list of alias nodes, in alias\n+     nodes pointer to the normal node.  */\n+  struct cgraph_node *same_body;\n   /* For functions with many calls sites it holds map from call expression\n      to the edge to speed up cgraph_edge function.  */\n   htab_t GTY((param_is (struct cgraph_edge))) call_site_hash;\n@@ -241,6 +244,9 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   unsigned alias : 1;\n   /* Set for nodes that was constructed and finalized by frontend.  */\n   unsigned finalized_by_frontend : 1;\n+  /* Set for alias nodes, same_body points to the node they are alias of\n+     and they are linked through the next/previous pointers.  */\n+  unsigned same_body_alias : 1;\n };\n \n typedef struct cgraph_node *cgraph_node_ptr;\n@@ -416,6 +422,8 @@ struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n \n struct cgraph_node * cgraph_get_node (tree);\n struct cgraph_node *cgraph_node (tree);\n+bool cgraph_same_body_alias (tree, tree);\n+void cgraph_remove_same_body_alias (struct cgraph_node *);\n struct cgraph_node *cgraph_node_for_asm (tree);\n struct cgraph_node *cgraph_node_for_decl (tree);\n struct cgraph_edge *cgraph_edge (struct cgraph_node *, gimple);"}, {"sha": "e934b3d8abc7ff73a51c15e52ce26d5bb7bd3012", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -1040,7 +1040,7 @@ cgraph_analyze_functions (void)\n static void\n cgraph_emit_thunks (void)\n {\n-  struct cgraph_node *n;\n+  struct cgraph_node *n, *alias;\n \n   for (n = cgraph_nodes; n; n = n->next)\n     {\n@@ -1053,7 +1053,12 @@ cgraph_emit_thunks (void)\n \t cgraph_mark_functions_to_output in cgraph_optimize).  */\n       if (n->reachable\n \t  && !DECL_EXTERNAL (n->decl))\n-\tlang_hooks.callgraph.emit_associated_thunks (n->decl);\n+\t{\n+\t  lang_hooks.callgraph.emit_associated_thunks (n->decl);\n+\t  for (alias = n->same_body; alias; alias = alias->next)\n+\t    if (!DECL_EXTERNAL (alias->decl))\n+\t      lang_hooks.callgraph.emit_associated_thunks (alias->decl);\n+\t}\n     }\n }\n \n@@ -1175,6 +1180,14 @@ cgraph_expand_function (struct cgraph_node *node)\n   /* Make sure that BE didn't give up on compiling.  */\n   gcc_assert (TREE_ASM_WRITTEN (decl));\n   current_function_decl = NULL;\n+  if (node->same_body)\n+    {\n+      struct cgraph_node *alias;\n+      bool saved_alias = node->alias;\n+      for (alias = node->same_body; alias; alias = alias->next)\n+\tassemble_alias (alias->decl, DECL_ASSEMBLER_NAME (decl));\n+      node->alias = saved_alias;\n+    }\n   gcc_assert (!cgraph_preserve_function_body_p (decl));\n   cgraph_release_function_body (node);\n   /* Eliminate all call edges.  This is important so the GIMPLE_CALL no longer\n@@ -1924,7 +1937,22 @@ cgraph_materialize_all_clones (void)\n \t      {\n \t\tgimple new_stmt;\n \t\tgimple_stmt_iterator gsi;\n-\t\t\n+\n+\t\tif (e->callee->same_body)\n+\t\t  {\n+\t\t    struct cgraph_node *alias;\n+\n+\t\t    for (alias = e->callee->same_body;\n+\t\t\t alias;\n+\t\t\t alias = alias->next)\n+\t\t      if (decl == alias->decl)\n+\t\t\tbreak;\n+\t\t    /* Don't update call from same body alias to the real\n+\t\t       function.  */\n+\t\t    if (alias)\n+\t\t      continue;\n+\t\t  }\n+\n \t\tif (cgraph_dump_file)\n \t\t  {\n \t\t    fprintf (cgraph_dump_file, \"updating call of %s in %s:\","}, {"sha": "b3acf8e15f1687be657f09d9251653a6d1fa07bc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -1,3 +1,18 @@\n+2009-11-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/3187\n+\t* cp-tree.h (expand_or_defer_fn_1): New prototype.\n+\t* decl2.c (cp_write_global_declarations): Mark as !DECL_EXTERNAL\n+\talso all same_body aliases.\n+\t* semantics.c (expand_or_defer_fn): Move most of the function\n+\texcept registering with cgraph to ...\n+\t(expand_or_defer_fn_1): ... here.  New function.\n+\t* optimize.c: Include cgraph.h.\n+\t(maybe_clone_body): If in charge parm is not used and both base\n+\tand complete clones are created and are not comdat, tell cgraph\n+\tthey have the same body.\n+\t* Make-lang.in (cp/optimize.o): Depend on $(CGRAPH_H).\n+\n 2009-11-17  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/42058"}, {"sha": "f5c652ec552fdc9634ef0e0cb154e3fd7f69fe5d", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -303,7 +303,7 @@ cp/semantics.o: cp/semantics.c $(CXX_TREE_H) $(TM_H) except.h toplev.h \\\n cp/dump.o: cp/dump.c $(CXX_TREE_H) $(TM_H) $(TREE_DUMP_H)\n cp/optimize.o: cp/optimize.c $(CXX_TREE_H) $(TM_H) rtl.h $(INTEGRATE_H) \\\n   insn-config.h input.h $(PARAMS_H) debug.h $(TREE_INLINE_H) $(GIMPLE_H) \\\n-  $(TARGET_H) tree-iterator.h\n+  $(TARGET_H) tree-iterator.h $(CGRAPH_H)\n cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) toplev.h $(REAL_H) \\\n   gt-cp-mangle.h $(TARGET_H) $(TM_P_H)\n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_H) gt-cp-parser.h \\"}, {"sha": "3652fe072dffaf53dcc2356f61b45b50c42f3249", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -5037,6 +5037,7 @@ extern void finish_eh_cleanup\t\t\t(tree);\n extern void emit_associated_thunks\t\t(tree);\n extern void finish_mem_initializers\t\t(tree);\n extern tree check_template_template_default_arg (tree);\n+extern bool expand_or_defer_fn_1\t\t(tree);\n extern void expand_or_defer_fn\t\t\t(tree);\n extern void check_accessibility_of_qualified_id (tree, tree, tree);\n extern tree finish_qualified_id_expr\t\t(tree, tree, bool, bool,"}, {"sha": "c0febad25157eba478060f1226163ffa5936bc9b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -3658,7 +3658,19 @@ cp_write_global_declarations (void)\n \t  if (DECL_NOT_REALLY_EXTERN (decl)\n \t      && DECL_INITIAL (decl)\n \t      && decl_needed_p (decl))\n-\t    DECL_EXTERNAL (decl) = 0;\n+\t    {\n+\t      struct cgraph_node *node = cgraph_get_node (decl), *alias;\n+\n+\t      DECL_EXTERNAL (decl) = 0;\n+\t      /* If we mark !DECL_EXTERNAL one of the same body aliases,\n+\t\t we need to mark all of them that way.  */\n+\t      if (node && node->same_body)\n+\t\t{\n+\t\t  DECL_EXTERNAL (node->decl) = 0;\n+\t\t  for (alias = node->same_body; alias; alias = alias->next)\n+\t\t    DECL_EXTERNAL (alias->decl) = 0;\n+\t\t}\n+\t    }\n \n \t  /* If we're going to need to write this function out, and\n \t     there's already a body for it, create RTL for it now."}, {"sha": "c691f0b6a0bd4e227f6f34902d703f716a290b61", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dump.h\"\n #include \"gimple.h\"\n #include \"tree-iterator.h\"\n+#include \"cgraph.h\"\n \n /* Prototypes.  */\n \n@@ -149,8 +150,10 @@ bool\n maybe_clone_body (tree fn)\n {\n   tree clone;\n-  tree complete_dtor = NULL_TREE;\n+  tree fns[3];\n   bool first = true;\n+  bool in_charge_parm_used;\n+  int idx;\n \n   /* We only clone constructors and destructors.  */\n   if (!DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn)\n@@ -160,25 +163,40 @@ maybe_clone_body (tree fn)\n   /* Emit the DWARF1 abstract instance.  */\n   (*debug_hooks->deferred_inline_function) (fn);\n \n+  in_charge_parm_used = CLASSTYPE_VBASECLASSES (DECL_CONTEXT (fn)) != NULL;\n+  fns[0] = NULL_TREE;\n+  fns[1] = NULL_TREE;\n+  fns[2] = NULL_TREE;\n+\n   /* Look for the complete destructor which may be used to build the\n      delete destructor.  */\n   FOR_EACH_CLONE (clone, fn)\n-    if (DECL_NAME (clone) == complete_dtor_identifier)\n-      {\n-        complete_dtor = clone;\n-        break;\n-      }\n+    if (DECL_NAME (clone) == complete_dtor_identifier\n+\t|| DECL_NAME (clone) == complete_ctor_identifier)\n+      fns[1] = clone;\n+    else if (DECL_NAME (clone) == base_dtor_identifier\n+\t     || DECL_NAME (clone) == base_ctor_identifier)\n+      fns[0] = clone;\n+    else if (DECL_NAME (clone) == deleting_dtor_identifier)\n+      fns[2] = clone;\n+    else\n+      gcc_unreachable ();\n \n   /* We know that any clones immediately follow FN in the TYPE_METHODS\n      list.  */\n   push_to_top_level ();\n-  FOR_EACH_CLONE (clone, fn)\n+  for (idx = 0; idx < 3; idx++)\n     {\n       tree parm;\n       tree clone_parm;\n       int parmno;\n+      bool alias = false;\n       struct pointer_map_t *decl_map;\n \n+      clone = fns[idx];\n+      if (!clone)\n+\tcontinue;      \n+\n       /* Update CLONE's source position information to match FN's.  */\n       DECL_SOURCE_LOCATION (clone) = DECL_SOURCE_LOCATION (fn);\n       DECL_DECLARED_INLINE_P (clone) = DECL_DECLARED_INLINE_P (fn);\n@@ -223,12 +241,25 @@ maybe_clone_body (tree fn)\n       /* Start processing the function.  */\n       start_preparsed_function (clone, NULL_TREE, SF_PRE_PARSED);\n \n+      /* Tell cgraph if both ctors or both dtors are known to have\n+\t the same body.  */\n+      if (!in_charge_parm_used\n+\t  && fns[0]\n+\t  && idx == 1\n+\t  && !flag_use_repository\n+\t  && DECL_INTERFACE_KNOWN (fns[0])\n+\t  && !DECL_ONE_ONLY (fns[0])\n+\t  && cgraph_same_body_alias (clone, fns[0]))\n+\talias = true;\n+\n       /* Build the delete destructor by calling complete destructor\n          and delete function.  */\n-      if (DECL_NAME (clone) == deleting_dtor_identifier)\n-        build_delete_destructor_body (clone, complete_dtor);\n+      if (idx == 2)\n+\tbuild_delete_destructor_body (clone, fns[1]);\n+      else if (alias)\n+\t/* No need to populate body.  */ ;\n       else\n-        {\n+\t{\n           /* Remap the parameters.  */\n           decl_map = pointer_map_create ();\n           for (parmno = 0,\n@@ -291,7 +322,10 @@ maybe_clone_body (tree fn)\n       /* Now, expand this function into RTL, if appropriate.  */\n       finish_function (0);\n       BLOCK_ABSTRACT_ORIGIN (DECL_INITIAL (clone)) = DECL_INITIAL (fn);\n-      expand_or_defer_fn (clone);\n+      if (alias)\n+\texpand_or_defer_fn_1 (clone);\n+      else\n+\texpand_or_defer_fn (clone);\n       first = false;\n     }\n   pop_from_top_level ();"}, {"sha": "7401593bcc68597face45c166dda6b1bc4addae5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -3315,8 +3315,8 @@ emit_associated_thunks (tree fn)\n \n /* Generate RTL for FN.  */\n \n-void\n-expand_or_defer_fn (tree fn)\n+bool\n+expand_or_defer_fn_1 (tree fn)\n {\n   /* When the parser calls us after finishing the body of a template\n      function, we don't really want to expand the body.  */\n@@ -3330,7 +3330,7 @@ expand_or_defer_fn (tree fn)\n \t is not a GC root.  */\n       if (!function_depth)\n \tggc_collect ();\n-      return;\n+      return false;\n     }\n \n   gcc_assert (DECL_SAVED_TREE (fn));\n@@ -3343,7 +3343,7 @@ expand_or_defer_fn (tree fn)\n \t it out, even though we haven't.  */\n       TREE_ASM_WRITTEN (fn) = 1;\n       DECL_SAVED_TREE (fn) = NULL_TREE;\n-      return;\n+      return false;\n     }\n \n   /* We make a decision about linkage for these functions at the end\n@@ -3390,14 +3390,23 @@ expand_or_defer_fn (tree fn)\n   /* There's no reason to do any of the work here if we're only doing\n      semantic analysis; this code just generates RTL.  */\n   if (flag_syntax_only)\n-    return;\n+    return false;\n \n-  function_depth++;\n+  return true;\n+}\n+\n+void\n+expand_or_defer_fn (tree fn)\n+{\n+  if (expand_or_defer_fn_1 (fn))\n+    {\n+      function_depth++;\n \n-  /* Expand or defer, at the whim of the compilation unit manager.  */\n-  cgraph_finalize_function (fn, function_depth > 1);\n+      /* Expand or defer, at the whim of the compilation unit manager.  */\n+      cgraph_finalize_function (fn, function_depth > 1);\n \n-  function_depth--;\n+      function_depth--;\n+    }\n }\n \n struct nrv_data"}, {"sha": "a3c7719ffbf383c6a91a560ebf9a90dbd1ea2a7a", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -306,6 +306,23 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   lto_output_sleb128_stream (ob->main_stream,\n \t\t\t     node->global.estimated_growth);\n   lto_output_uleb128_stream (ob->main_stream, node->global.inlined);\n+  if (node->same_body)\n+    {\n+      struct cgraph_node *alias;\n+      unsigned long alias_count = 1;\n+      for (alias = node->same_body; alias->next; alias = alias->next)\n+\talias_count++;\n+      lto_output_uleb128_stream (ob->main_stream, alias_count);\n+      do\n+\t{\n+\t  lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n+\t\t\t\t    alias->decl);\n+\t  alias = alias->previous;\n+\t}\n+      while (alias);\n+    }\n+  else\n+    lto_output_uleb128_stream (ob->main_stream, 0);\n }\n \n /* Stream out profile_summary to OB.  */\n@@ -495,6 +512,7 @@ input_node (struct lto_file_decl_data *file_data,\n   int self_size = 0;\n   int time_inlining_benefit = 0;\n   int size_inlining_benefit = 0;\n+  unsigned long same_body_count = 0;\n   bool inlined = false;\n \n   clone_p = (lto_input_uleb128 (ib) != 0);\n@@ -528,6 +546,7 @@ input_node (struct lto_file_decl_data *file_data,\n   size = lto_input_sleb128 (ib);\n   estimated_growth = lto_input_sleb128 (ib);\n   inlined = lto_input_uleb128 (ib);\n+  same_body_count = lto_input_uleb128 (ib);\n \n   /* Make sure that we have not read this node before.  Nodes that\n      have already been read will have their tag stored in the 'aux'\n@@ -553,6 +572,13 @@ input_node (struct lto_file_decl_data *file_data,\n   node->global.estimated_growth = estimated_growth;\n   node->global.inlined = inlined;\n \n+  while (same_body_count-- > 0)\n+    {\n+      tree alias_decl;\n+      decl_index = lto_input_uleb128 (ib);\n+      alias_decl = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n+      cgraph_same_body_alias (alias_decl, fn_decl);\n+    }\n   return node;\n }\n "}, {"sha": "3b2823bb12e2298ec0209f4dc7bc74499f74115d", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -221,6 +221,25 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n       cgraph_remove_edge (e);\n     }\n \n+  if (node->same_body)\n+    {\n+      struct cgraph_node *alias;\n+\n+      for (alias = node->same_body; alias; alias = alias->next)\n+\tif (DECL_ASSEMBLER_NAME_SET_P (alias->decl))\n+\t  {\n+\t    lto_symtab_entry_t se\n+\t      = lto_symtab_get (DECL_ASSEMBLER_NAME (alias->decl));\n+\n+\t    for (; se; se = se->next)\n+\t      if (se->node == node)\n+\t\t{\n+\t\t  se->node = NULL;\n+\t\t  break;\n+\t\t}\n+\t  }\n+    }\n+\n   /* Finally remove the replaced node.  */\n   cgraph_remove_node (node);\n }\n@@ -634,7 +653,22 @@ lto_symtab_merge_cgraph_nodes_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n   for (e = prevailing->next; e; e = e->next)\n     {\n       if (e->node != NULL)\n-\tlto_cgraph_replace_node (e->node, prevailing->node);\n+\t{\n+\t  if (e->node->decl != e->decl && e->node->same_body)\n+\t    {\n+\t      struct cgraph_node *alias;\n+\n+\t      for (alias = e->node->same_body; alias; alias = alias->next)\n+\t\tif (alias->decl == e->decl)\n+\t\t  break;\n+\t      if (alias)\n+\t\t{\n+\t\t  cgraph_remove_same_body_alias (alias);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  lto_cgraph_replace_node (e->node, prevailing->node);\n+\t}\n     }\n \n   /* Drop all but the prevailing decl from the symtab.  */"}, {"sha": "47687cc3a58b1787dbb73586b8c496ddfe623179", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -1,3 +1,11 @@\n+2009-11-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/3187\n+\t* g++.dg/abi/mangle26.C: Also match *C2* definition.\n+\t* g++.dg/abi/mangle27.C: Likewise.\n+\t* g++.dg/abi/mangle28.C: Likewise.\n+\t* g++.dg/abi/mangle29.C: Likewise.\n+\n 2009-11-18  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR debug/41926"}, {"sha": "77b0eabdaa5cb69c12a87793ec15be3233ab8ec0", "filename": "gcc/testsuite/g++.dg/abi/mangle26.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle26.C?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -11,4 +11,4 @@ namespace std {\n \n std::A a;\n \n-// { dg-final { scan-assembler \"\\n_?_ZNSt1AC1Ev\\[: \\t\\n\\]\" } }\n+// { dg-final { scan-assembler \"\\n_?_ZNSt1AC\\[12\\]Ev\\[: \\t\\n\\]\" } }"}, {"sha": "2d15abbf96124c91699e9cd1c0c513772ca08408", "filename": "gcc/testsuite/g++.dg/abi/mangle27.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle27.C?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -11,4 +11,4 @@ namespace std {\n \n std::basic_iostream<char,std::char_traits<char> > s1;\n \n-// { dg-final { scan-assembler \"\\n_?_ZNSdC1Ev\\[: \\t\\n\\]\" } }\n+// { dg-final { scan-assembler \"\\n_?_ZNSdC\\[12\\]Ev\\[: \\t\\n\\]\" } }"}, {"sha": "bea8ce01974163ce014b6503767bb05c85031478", "filename": "gcc/testsuite/g++.dg/abi/mangle28.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle28.C?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -11,4 +11,4 @@ namespace std {\n \n std::basic_istream<char,std::char_traits<char> > s1;\n \n-// { dg-final { scan-assembler \"\\n_?_ZNSiC1Ev\\[: \\t\\n\\]\" } }\n+// { dg-final { scan-assembler \"\\n_?_ZNSiC\\[12\\]Ev\\[: \\t\\n\\]\" } }"}, {"sha": "aaff2b4eb68be2cce8600e70e53818bc35adec5a", "filename": "gcc/testsuite/g++.dg/abi/mangle29.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25833451bbe9b8a2194598b026cea071f4e9e65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle29.C?ref=b25833451bbe9b8a2194598b026cea071f4e9e65", "patch": "@@ -11,4 +11,4 @@ namespace std {\n \n std::basic_ostream<char,std::char_traits<char> > s1;\n \n-// { dg-final { scan-assembler \"\\n_?_ZNSoC1Ev\\[: \\t\\n\\]\" } }\n+// { dg-final { scan-assembler \"\\n_?_ZNSoC\\[12\\]Ev\\[: \\t\\n\\]\" } }"}]}