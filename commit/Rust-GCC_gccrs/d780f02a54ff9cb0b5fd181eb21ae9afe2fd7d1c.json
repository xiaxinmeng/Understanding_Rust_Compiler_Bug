{"sha": "d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c", "node_id": "C_kwDOANBUbNoAKGQ3ODBmMDJhNTRmZjljYjBiNWZkMTgxZWIyMWFlOWFmZTJmZDdkMWM", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-08-06T18:12:47Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:27Z"}, "message": "rust-constexpr.cc: port over cxx_eval_outermost_constant_expr", "tree": {"sha": "c20bab0a1637b28de39e0a5e81e8064c58cecf6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c20bab0a1637b28de39e0a5e81e8064c58cecf6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b440d46f16e3f93dd979852a1aab55f88add75f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b440d46f16e3f93dd979852a1aab55f88add75f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b440d46f16e3f93dd979852a1aab55f88add75f"}], "stats": {"total": 433, "additions": 429, "deletions": 4}, "files": [{"sha": "276bfe94e6f2b2996ae55323ee782457d26c56be", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c", "patch": "@@ -31,6 +31,7 @@\n #include \"tree-inline.h\"\n #include \"vec.h\"\n #include \"rust-target.h\"\n+#include \"function.h\"\n \n #define VERIFY_CONSTANT(X)                                                     \\\n   do                                                                           \\\n@@ -4030,6 +4031,323 @@ eval_unary_expression (const constexpr_ctx *ctx, tree t, bool /*lval*/,\n   return r;\n }\n \n+// forked from gcc/cp/constexpr.cc cxx_eval_outermost_constant_expr\n+\n+/* ALLOW_NON_CONSTANT is false if T is required to be a constant expression.\n+   STRICT has the same sense as for constant_value_1: true if we only allow\n+   conforming C++ constant expressions, or false if we want a constant value\n+   even if it doesn't conform.\n+   MANIFESTLY_CONST_EVAL is true if T is manifestly const-evaluated as\n+   per P0595 even when ALLOW_NON_CONSTANT is true.\n+   CONSTEXPR_DTOR is true when evaluating the dtor of a constexpr variable.\n+   OBJECT must be non-NULL in that case.  */\n+\n+static tree\n+cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n+\t\t\t\t  bool strict = true,\n+\t\t\t\t  bool manifestly_const_eval = false,\n+\t\t\t\t  bool constexpr_dtor = false,\n+\t\t\t\t  tree object = NULL_TREE)\n+{\n+  auto_timevar time (TV_CONSTEXPR);\n+\n+  bool non_constant_p = false;\n+  bool overflow_p = false;\n+\n+  if (BRACE_ENCLOSED_INITIALIZER_P (t))\n+    {\n+      gcc_checking_assert (allow_non_constant);\n+      return t;\n+    }\n+\n+  constexpr_global_ctx global_ctx;\n+  constexpr_ctx ctx\n+    = {&global_ctx, NULL,\n+       NULL,\t    NULL,\n+       NULL,\t    NULL,\n+       NULL,\t    allow_non_constant,\n+       strict,\t    manifestly_const_eval || !allow_non_constant};\n+\n+  /* Turn off -frounding-math for manifestly constant evaluation.  */\n+  warning_sentinel rm (flag_rounding_math, ctx.manifestly_const_eval);\n+  tree type = initialized_type (t);\n+  tree r = t;\n+  bool is_consteval = false;\n+  if (VOID_TYPE_P (type))\n+    {\n+      if (constexpr_dtor)\n+\t/* Used for destructors of array elements.  */\n+\ttype = TREE_TYPE (object);\n+      else\n+\t{\n+\t  if (TREE_CODE (t) != CALL_EXPR)\n+\t    return t;\n+\t  /* Calls to immediate functions returning void need to be\n+\t     evaluated.  */\n+\t  tree fndecl = rs_get_callee_fndecl_nofold (t);\n+\t  if (fndecl == NULL_TREE || !DECL_IMMEDIATE_FUNCTION_P (fndecl))\n+\t    return t;\n+\t  else\n+\t    is_consteval = true;\n+\t}\n+    }\n+  else if ((TREE_CODE (t) == CALL_EXPR || TREE_CODE (t) == TARGET_EXPR))\n+    {\n+      /* For non-concept checks, determine if it is consteval.  */\n+      tree x = t;\n+      if (TREE_CODE (x) == TARGET_EXPR)\n+\tx = TARGET_EXPR_INITIAL (x);\n+      tree fndecl = rs_get_callee_fndecl_nofold (x);\n+      if (fndecl && DECL_IMMEDIATE_FUNCTION_P (fndecl))\n+\tis_consteval = true;\n+    }\n+  if (AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type))\n+    {\n+      /* In C++14 an NSDMI can participate in aggregate initialization,\n+\t and can refer to the address of the object being initialized, so\n+\t we need to pass in the relevant VAR_DECL if we want to do the\n+\t evaluation in a single pass.  The evaluation will dynamically\n+\t update ctx.values for the VAR_DECL.  We use the same strategy\n+\t for C++11 constexpr constructors that refer to the object being\n+\t initialized.  */\n+      if (constexpr_dtor)\n+\t{\n+\t  gcc_assert (object && VAR_P (object));\n+\t  gcc_assert (DECL_DECLARED_CONSTEXPR_P (object));\n+\t  gcc_assert (DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (object));\n+\t  if (error_operand_p (DECL_INITIAL (object)))\n+\t    return t;\n+\t  ctx.ctor = unshare_expr (DECL_INITIAL (object));\n+\t  TREE_READONLY (ctx.ctor) = false;\n+\t  /* Temporarily force decl_really_constant_value to return false\n+\t     for it, we want to use ctx.ctor for the current value instead.  */\n+\t  DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (object) = false;\n+\t}\n+      else\n+\t{\n+\t  ctx.ctor = build_constructor (type, NULL);\n+\t  CONSTRUCTOR_NO_CLEARING (ctx.ctor) = true;\n+\t}\n+      if (!object)\n+\t{\n+\t  if (TREE_CODE (t) == TARGET_EXPR)\n+\t    object = TARGET_EXPR_SLOT (t);\n+\t}\n+      ctx.object = object;\n+      if (object)\n+\tgcc_assert (\n+\t  same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (object)));\n+      if (object && DECL_P (object))\n+\tglobal_ctx.values.put (object, ctx.ctor);\n+      if (TREE_CODE (r) == TARGET_EXPR)\n+\t/* Avoid creating another CONSTRUCTOR when we expand the\n+\t   TARGET_EXPR.  */\n+\tr = TARGET_EXPR_INITIAL (r);\n+    }\n+\n+  auto_vec<tree, 16> cleanups;\n+  global_ctx.cleanups = &cleanups;\n+\n+  if (manifestly_const_eval)\n+    instantiate_constexpr_fns (r);\n+  r = eval_constant_expression (&ctx, r, false, &non_constant_p, &overflow_p);\n+\n+  if (!constexpr_dtor)\n+    verify_constant (r, allow_non_constant, &non_constant_p, &overflow_p);\n+  else\n+    DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (object) = true;\n+\n+  unsigned int i;\n+  tree cleanup;\n+  /* Evaluate the cleanups.  */\n+  FOR_EACH_VEC_ELT_REVERSE (cleanups, i, cleanup)\n+    eval_constant_expression (&ctx, cleanup, false, &non_constant_p,\n+\t\t\t      &overflow_p);\n+\n+  /* Mutable logic is a bit tricky: we want to allow initialization of\n+     constexpr variables with mutable members, but we can't copy those\n+     members to another constexpr variable.  */\n+  if (TREE_CODE (r) == CONSTRUCTOR && CONSTRUCTOR_MUTABLE_POISON (r))\n+    {\n+      if (!allow_non_constant)\n+\terror (\"%qE is not a constant expression because it refers to \"\n+\t       \"mutable subobjects of %qT\",\n+\t       t, type);\n+      non_constant_p = true;\n+    }\n+\n+  if (TREE_CODE (r) == CONSTRUCTOR && CONSTRUCTOR_NO_CLEARING (r))\n+    {\n+      if (!allow_non_constant)\n+\terror (\"%qE is not a constant expression because it refers to \"\n+\t       \"an incompletely initialized variable\",\n+\t       t);\n+      TREE_CONSTANT (r) = false;\n+      non_constant_p = true;\n+    }\n+\n+  if (!global_ctx.heap_vars.is_empty ())\n+    {\n+      tree heap_var\n+\t= rs_walk_tree_without_duplicates (&r, find_heap_var_refs, NULL);\n+      unsigned int i;\n+      if (heap_var)\n+\t{\n+\t  if (!allow_non_constant && !non_constant_p)\n+\t    error_at (DECL_SOURCE_LOCATION (heap_var),\n+\t\t      \"%qE is not a constant expression because it refers to \"\n+\t\t      \"a result of %<operator new%>\",\n+\t\t      t);\n+\t  r = t;\n+\t  non_constant_p = true;\n+\t}\n+      FOR_EACH_VEC_ELT (global_ctx.heap_vars, i, heap_var)\n+\t{\n+\t  if (DECL_NAME (heap_var) != heap_deleted_identifier)\n+\t    {\n+\t      if (!allow_non_constant && !non_constant_p)\n+\t\terror_at (DECL_SOURCE_LOCATION (heap_var),\n+\t\t\t  \"%qE is not a constant expression because allocated \"\n+\t\t\t  \"storage has not been deallocated\",\n+\t\t\t  t);\n+\t      r = t;\n+\t      non_constant_p = true;\n+\t    }\n+\t  varpool_node::get (heap_var)->remove ();\n+\t}\n+    }\n+\n+  /* Check that immediate invocation does not return an expression referencing\n+     any immediate function decls.  */\n+  if (is_consteval || in_immediate_context ())\n+    if (tree immediate_fndecl\n+\t= rs_walk_tree_without_duplicates (&r, find_immediate_fndecl, NULL))\n+      {\n+\tif (!allow_non_constant && !non_constant_p)\n+\t  error_at (rs_expr_loc_or_input_loc (t),\n+\t\t    \"immediate evaluation returns address of immediate \"\n+\t\t    \"function %qD\",\n+\t\t    immediate_fndecl);\n+\tr = t;\n+\tnon_constant_p = true;\n+      }\n+\n+  if (non_constant_p)\n+    /* If we saw something bad, go back to our argument.  The wrapping below is\n+       only for the cases of TREE_CONSTANT argument or overflow.  */\n+    r = t;\n+\n+  if (!non_constant_p && overflow_p)\n+    non_constant_p = true;\n+\n+  /* Unshare the result.  */\n+  bool should_unshare = true;\n+  if (r == t || (TREE_CODE (t) == TARGET_EXPR && TARGET_EXPR_INITIAL (t) == r))\n+    should_unshare = false;\n+\n+  if (non_constant_p && !allow_non_constant)\n+    return error_mark_node;\n+  else if (constexpr_dtor)\n+    return r;\n+  else if (non_constant_p && TREE_CONSTANT (r))\n+    {\n+      /* This isn't actually constant, so unset TREE_CONSTANT.\n+\t Don't clear TREE_CONSTANT on ADDR_EXPR, as the middle-end requires\n+\t it to be set if it is invariant address, even when it is not\n+\t a valid C++ constant expression.  Wrap it with a NOP_EXPR\n+\t instead.  */\n+      if (EXPR_P (r) && TREE_CODE (r) != ADDR_EXPR)\n+\tr = copy_node (r);\n+      else if (TREE_CODE (r) == CONSTRUCTOR)\n+\tr = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (r), r);\n+      else\n+\tr = build_nop (TREE_TYPE (r), r);\n+      TREE_CONSTANT (r) = false;\n+    }\n+  else if (non_constant_p)\n+    return t;\n+\n+  if (should_unshare)\n+    r = unshare_expr (r);\n+\n+  if (TREE_CODE (r) == CONSTRUCTOR && CLASS_TYPE_P (TREE_TYPE (r)))\n+    {\n+      r = adjust_temp_type (type, r);\n+      if (TREE_CODE (t) == TARGET_EXPR && TARGET_EXPR_INITIAL (t) == r)\n+\treturn t;\n+    }\n+\n+  /* Remember the original location if that wouldn't need a wrapper.  */\n+  if (location_t loc = EXPR_LOCATION (t))\n+    protected_set_expr_location (r, loc);\n+\n+  return r;\n+}\n+\n+/* Like is_constant_expression, but allow const variables that are not allowed\n+   under constexpr rules.  */\n+\n+bool\n+is_static_init_expression (tree t)\n+{\n+  // return potential_constant_expression_1 (t, false, false, true, tf_none);\n+  // faisal: just return false for now to make it compile\n+}\n+\n+/* Returns true if T is a potential static initializer expression that is not\n+   instantiation-dependent.  */\n+\n+bool\n+is_nondependent_static_init_expression (tree t)\n+{\n+  return (!type_unknown_p (t) && is_static_init_expression (t));\n+}\n+\n+/* Like maybe_constant_value, but returns a CONSTRUCTOR directly, rather\n+   than wrapped in a TARGET_EXPR.\n+   ALLOW_NON_CONSTANT is false if T is required to be a constant expression.\n+   MANIFESTLY_CONST_EVAL is true if T is manifestly const-evaluated as\n+   per P0595 even when ALLOW_NON_CONSTANT is true.  */\n+\n+static tree\n+maybe_constant_init_1 (tree t, tree decl, bool allow_non_constant,\n+\t\t       bool manifestly_const_eval)\n+{\n+  if (!t)\n+    return t;\n+  if (TREE_CODE (t) == EXPR_STMT)\n+    t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) == CONVERT_EXPR && VOID_TYPE_P (TREE_TYPE (t)))\n+    t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) == INIT_EXPR)\n+    t = TREE_OPERAND (t, 1);\n+  if (TREE_CODE (t) == TARGET_EXPR)\n+    t = TARGET_EXPR_INITIAL (t);\n+  if (!is_nondependent_static_init_expression (t))\n+    /* Don't try to evaluate it.  */;\n+  else if (CONSTANT_CLASS_P (t) && allow_non_constant)\n+    /* No evaluation needed.  */;\n+  else\n+    t = cxx_eval_outermost_constant_expr (t, allow_non_constant,\n+\t\t\t\t\t  /*strict*/ false,\n+\t\t\t\t\t  manifestly_const_eval, false, decl);\n+  if (TREE_CODE (t) == TARGET_EXPR)\n+    {\n+      tree init = TARGET_EXPR_INITIAL (t);\n+      if (TREE_CODE (init) == CONSTRUCTOR)\n+\tt = init;\n+    }\n+  return t;\n+}\n+\n+/* Wrapper for maybe_constant_init_1 which permits non constants.  */\n+\n+tree\n+maybe_constant_init (tree t, tree decl, bool manifestly_const_eval)\n+{\n+  return maybe_constant_init_1 (t, decl, true, manifestly_const_eval);\n+}\n+\n // #include \"gt-rust-rust-constexpr.h\"\n \n } // namespace Compile"}, {"sha": "ad457a2e4ce92524da33de239f3e7bd324b772ec", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c", "patch": "@@ -4108,4 +4108,47 @@ is_empty_field (tree decl)\n   return r;\n }\n \n+// forked from gcc/cp/call.cc in_immediate_context\n+\n+/* Return true if in an immediate function context, or an unevaluated operand,\n+   or a subexpression of an immediate invocation.  */\n+\n+bool\n+in_immediate_context ()\n+{\n+  return false;\n+}\n+\n+// forked from gcc/cp/cvt.cc cp_get_fndecl_from_callee\n+\n+/* FN is the callee of a CALL_EXPR or AGGR_INIT_EXPR; return the FUNCTION_DECL\n+   if we can.  */\n+\n+tree\n+rs_get_fndecl_from_callee (tree fn, bool fold /* = true */)\n+{\n+  if (fn == NULL_TREE)\n+    return fn;\n+  if (TREE_CODE (fn) == FUNCTION_DECL)\n+    return fn;\n+  tree type = TREE_TYPE (fn);\n+  if (type == NULL_TREE || !INDIRECT_TYPE_P (type))\n+    return NULL_TREE;\n+  if (fold)\n+    fn = Compile::maybe_constant_init (fn);\n+  STRIP_NOPS (fn);\n+  if (TREE_CODE (fn) == ADDR_EXPR || TREE_CODE (fn) == FDESC_EXPR)\n+    fn = TREE_OPERAND (fn, 0);\n+  if (TREE_CODE (fn) == FUNCTION_DECL)\n+    return fn;\n+  return NULL_TREE;\n+}\n+\n+// forked from gcc/cp/cvt.cc cp_get_callee_fndecl_nofold\n+tree\n+rs_get_callee_fndecl_nofold (tree call)\n+{\n+  return rs_get_fndecl_from_callee (cp_get_callee (call), false);\n+}\n+\n } // namespace Rust"}, {"sha": "bd11b20e77faa042b9cc7941c692dea472079c37", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 68, "deletions": 4, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=d780f02a54ff9cb0b5fd181eb21ae9afe2fd7d1c", "patch": "@@ -1221,6 +1221,9 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n \n #define current_class_type scope_chain->class_type\n \n+#define in_discarded_stmt scope_chain->discarded_stmt\n+#define in_consteval_if_p scope_chain->consteval_if_p\n+\n /* Nonzero means that this type is being defined.  I.e., the left brace\n    starting the definition of this type has been seen.  */\n #define TYPE_BEING_DEFINED(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->being_defined)\n@@ -1418,8 +1421,62 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n #define STAT_TYPE_HIDDEN_P(N) OVL_HIDDEN_P (N)\n #define STAT_DECL_HIDDEN_P(N) OVL_DEDUP_P (N)\n \n+/* The binding level currently in effect.  */\n+\n+#define current_binding_level                                                  \\\n+  (*(cfun && cp_function_chain && cp_function_chain->bindings                  \\\n+       ? &cp_function_chain->bindings                                          \\\n+       : &scope_chain->bindings))\n+\n // Above macros are copied from gcc/cp/name-lookup.cc\n \n+// forked from gcc/cp/name_lookup.h scope_kind\n+\n+/* The kinds of scopes we recognize.  */\n+enum scope_kind\n+{\n+  sk_block = 0,\t     /* An ordinary block scope.  This enumerator must\n+\t\t\thave the value zero because \"cp_binding_level\"\n+\t\t\tis initialized by using \"memset\" to set the\n+\t\t\tcontents to zero, and the default scope kind\n+\t\t\tis \"sk_block\".  */\n+  sk_cleanup,\t     /* A scope for (pseudo-)scope for cleanup.  It is\n+\t\t\tpseudo in that it is transparent to name lookup\n+\t\t\tactivities.  */\n+  sk_try,\t     /* A try-block.  */\n+  sk_catch,\t     /* A catch-block.  */\n+  sk_for,\t     /* The scope of the variable declared in a\n+\t\t\tinit-statement.  */\n+  sk_cond,\t     /* The scope of the variable declared in the condition\n+\t\t\tof an if or switch statement.  */\n+  sk_function_parms, /* The scope containing function parameters.  */\n+  sk_class,\t     /* The scope containing the members of a class.  */\n+  sk_scoped_enum,    /* The scope containing the enumerators of a C++11\n+\t\t\tscoped enumeration.  */\n+  sk_namespace,\t     /* The scope containing the members of a\n+\t\t\tnamespace, including the global scope.  */\n+  sk_template_parms, /* A scope for template parameters.  */\n+  sk_template_spec,  /* Like sk_template_parms, but for an explicit\n+\t\t\tspecialization.  Since, by definition, an\n+\t\t\texplicit specialization is introduced by\n+\t\t\t\"template <>\", this scope is always empty.  */\n+  sk_transaction,    /* A synchronized or atomic statement.  */\n+  sk_omp\t     /* An OpenMP structured block.  */\n+};\n+\n+// forked from gcc/cp/cp-tree.h cp_built_in_function\n+\n+/* BUILT_IN_FRONTEND function codes.  */\n+enum cp_built_in_function\n+{\n+  CP_BUILT_IN_IS_CONSTANT_EVALUATED,\n+  CP_BUILT_IN_INTEGER_PACK,\n+  CP_BUILT_IN_IS_CORRESPONDING_MEMBER,\n+  CP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS,\n+  CP_BUILT_IN_SOURCE_LOCATION,\n+  CP_BUILT_IN_LAST\n+};\n+\n // forked from gcc/cp/cp-tree.h warning_sentinel\n \n /* RAII sentinel to disable certain warnings during template substitution\n@@ -2539,13 +2596,10 @@ extern bool reduced_constant_expression_p (tree);\n extern tree cv_unqualified (tree);\n \n extern tree cp_get_callee (tree);\n-extern tree cp_get_callee_fndecl_nofold (tree);\n+extern tree rs_get_callee_fndecl_nofold (tree);\n \n extern bool is_nondependent_static_init_expression (tree);\n \n-extern tree\n-maybe_constant_init (tree, tree = NULL_TREE, bool = false);\n-\n extern tree build_nop (tree, tree);\n \n extern bool scalarish_type_p (const_tree);\n@@ -2609,6 +2663,11 @@ extern tree build_new_constexpr_heap_type (tree, tree, tree);\n \n extern bool is_empty_field (tree);\n \n+extern bool\n+in_immediate_context ();\n+\n+extern tree cp_get_callee_fndecl_nofold (tree);\n+\n // forked from gcc/cp/cp-tree.h\n \n enum\n@@ -2811,6 +2870,11 @@ cxx_incomplete_type_error (const_tree value, const_tree type)\n extern location_t\n location_of (tree t);\n \n+namespace Compile {\n+extern tree\n+maybe_constant_init (tree, tree = NULL_TREE, bool = false);\n+}\n+\n } // namespace Rust\n \n #endif // RUST_TREE"}]}