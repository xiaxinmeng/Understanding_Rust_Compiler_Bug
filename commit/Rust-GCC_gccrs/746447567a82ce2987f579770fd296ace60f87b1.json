{"sha": "746447567a82ce2987f579770fd296ace60f87b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ2NDQ3NTY3YTgyY2UyOTg3ZjU3OTc3MGZkMjk2YWNlNjBmODdiMQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-08T12:26:57Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-08T12:26:57Z"}, "message": "Remove cgraph_node::summary_uid and make cgraph_node::uid really unique.\n\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* cgraph.c (cgraph_node::remove): Do not recycle uid.\n\t* cgraph.h (symbol_table::release_symbol): Do not pass uid.\n\t(symbol_table::allocate_cgraph_symbol): Do not set uid.\n\t* passes.c (uid_hash_t): Record removed_nodes by their uids.\n\t(remove_cgraph_node_from_order): Use the removed_nodes set.\n\t(do_per_function_toporder): Likwise.\n\t* symbol-summary.h (symtab_insertion): Use cgraph_node::uid\n\tinstead of summary_uid.\n\t(symtab_removal): Likewise.\n\t(symtab_duplication): Likewise.\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* lto-partition.c (lto_balanced_map): Use cgraph_node::uid\n\tinstead of summary_uid.\n\nFrom-SVN: r261315", "tree": {"sha": "c22de406a2a163de859df4f8b0c31de0e34a74a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c22de406a2a163de859df4f8b0c31de0e34a74a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/746447567a82ce2987f579770fd296ace60f87b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/746447567a82ce2987f579770fd296ace60f87b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/746447567a82ce2987f579770fd296ace60f87b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/746447567a82ce2987f579770fd296ace60f87b1/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9d3e0adc2a0e657b2aa384f1392dd2fac77a62d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d3e0adc2a0e657b2aa384f1392dd2fac77a62d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d3e0adc2a0e657b2aa384f1392dd2fac77a62d4"}], "stats": {"total": 122, "additions": 57, "deletions": 65}, "files": [{"sha": "b6c6a6acdd5373d0123897e2663574ce4e513ffe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/746447567a82ce2987f579770fd296ace60f87b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/746447567a82ce2987f579770fd296ace60f87b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=746447567a82ce2987f579770fd296ace60f87b1", "patch": "@@ -1,3 +1,16 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* cgraph.c (cgraph_node::remove): Do not recycle uid.\n+\t* cgraph.h (symbol_table::release_symbol): Do not pass uid.\n+\t(symbol_table::allocate_cgraph_symbol): Do not set uid.\n+\t* passes.c (uid_hash_t): Record removed_nodes by their uids.\n+\t(remove_cgraph_node_from_order): Use the removed_nodes set.\n+\t(do_per_function_toporder): Likwise.\n+\t* symbol-summary.h (symtab_insertion): Use cgraph_node::uid\n+\tinstead of summary_uid.\n+\t(symtab_removal): Likewise.\n+\t(symtab_duplication): Likewise.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-cp.c (ipcp_store_bits_results): Use"}, {"sha": "6c6ecd8235c2099616d1b2e89646720148ce01fe", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/746447567a82ce2987f579770fd296ace60f87b1/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/746447567a82ce2987f579770fd296ace60f87b1/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=746447567a82ce2987f579770fd296ace60f87b1", "patch": "@@ -1779,7 +1779,6 @@ void\n cgraph_node::remove (void)\n {\n   cgraph_node *n;\n-  int uid = this->uid;\n \n   if (symtab->ipa_clones_dump_file && symtab->cloned_nodes.contains (this))\n     fprintf (symtab->ipa_clones_dump_file,\n@@ -1875,7 +1874,7 @@ cgraph_node::remove (void)\n       call_site_hash = NULL;\n     }\n \n-  symtab->release_symbol (this, uid);\n+  symtab->release_symbol (this);\n }\n \n /* Likewise indicate that a node is having address taken.  */"}, {"sha": "9a058671d3b677bb34cbbb942b3ce39be66598d5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/746447567a82ce2987f579770fd296ace60f87b1/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/746447567a82ce2987f579770fd296ace60f87b1/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=746447567a82ce2987f579770fd296ace60f87b1", "patch": "@@ -1392,8 +1392,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   int count_materialization_scale;\n   /* Unique id of the node.  */\n   int uid;\n-  /* Summary unique id of the node.  */\n-  int summary_uid;\n   /* ID assigned by the profiling.  */\n   unsigned int profile_id;\n   /* Time profiler: first run of function.  */\n@@ -2013,7 +2011,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   friend class cgraph_node;\n   friend class cgraph_edge;\n \n-  symbol_table (): cgraph_max_summary_uid (1)\n+  symbol_table (): cgraph_max_uid (1)\n   {\n   }\n \n@@ -2073,9 +2071,8 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   /* Allocate new callgraph node and insert it into basic data structures.  */\n   cgraph_node *create_empty (void);\n \n-  /* Release a callgraph NODE with UID and put in to the list\n-     of free nodes.  */\n-  void release_symbol (cgraph_node *node, int uid);\n+  /* Release a callgraph NODE.  */\n+  void release_symbol (cgraph_node *node);\n \n   /* Output all variables enqueued to be assembled.  */\n   bool output_variables (void);\n@@ -2223,7 +2220,6 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n \n   int cgraph_count;\n   int cgraph_max_uid;\n-  int cgraph_max_summary_uid;\n \n   int edges_count;\n   int edges_max_uid;\n@@ -2586,15 +2582,14 @@ symbol_table::unregister (symtab_node *node)\n /* Release a callgraph NODE with UID and put in to the list of free nodes.  */\n \n inline void\n-symbol_table::release_symbol (cgraph_node *node, int uid)\n+symbol_table::release_symbol (cgraph_node *node)\n {\n   cgraph_count--;\n \n   /* Clear out the node to NULL all pointers and add the node to the free\n      list.  */\n   memset (node, 0, sizeof (*node));\n   node->type = SYMTAB_FUNCTION;\n-  node->uid = uid;\n   SET_NEXT_FREE_NODE (node, free_nodes);\n   free_nodes = node;\n }\n@@ -2612,12 +2607,9 @@ symbol_table::allocate_cgraph_symbol (void)\n       free_nodes = NEXT_FREE_NODE (node);\n     }\n   else\n-    {\n-      node = ggc_cleared_alloc<cgraph_node> ();\n-      node->uid = cgraph_max_uid++;\n-    }\n+    node = ggc_cleared_alloc<cgraph_node> ();\n \n-  node->summary_uid = cgraph_max_summary_uid++;\n+  node->uid = cgraph_max_uid++;\n   return node;\n }\n "}, {"sha": "aaf375bc3071663cac86e76ce80dba15554d2236", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/746447567a82ce2987f579770fd296ace60f87b1/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/746447567a82ce2987f579770fd296ace60f87b1/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=746447567a82ce2987f579770fd296ace60f87b1", "patch": "@@ -1,3 +1,8 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* lto-partition.c (lto_balanced_map): Use cgraph_node::uid\n+\tinstead of summary_uid.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* lto-partition.c (add_symbol_to_partition_1): Use get_create instead"}, {"sha": "006eec77b26617a19028adb775b0b3189e8f39a3", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/746447567a82ce2987f579770fd296ace60f87b1/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/746447567a82ce2987f579770fd296ace60f87b1/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=746447567a82ce2987f579770fd296ace60f87b1", "patch": "@@ -500,35 +500,33 @@ account_reference_p (symtab_node *n1, symtab_node *n2)\n void\n lto_balanced_map (int n_lto_partitions, int max_partition_size)\n {\n-  int n_nodes = 0;\n   int n_varpool_nodes = 0, varpool_pos = 0, best_varpool_pos = 0;\n-  struct cgraph_node **order = XNEWVEC (cgraph_node *, symtab->cgraph_max_uid);\n+  auto_vec <cgraph_node *> order (symtab->cgraph_count);\n   auto_vec<cgraph_node *> noreorder;\n   auto_vec<varpool_node *> varpool_order;\n-  int i;\n   struct cgraph_node *node;\n   int64_t original_total_size, total_size = 0;\n   int64_t partition_size;\n   ltrans_partition partition;\n   int last_visited_node = 0;\n   varpool_node *vnode;\n   int64_t cost = 0, internal = 0;\n-  int best_n_nodes = 0, best_i = 0;\n+  unsigned int best_n_nodes = 0, best_i = 0;\n   int64_t best_cost = -1, best_internal = 0, best_size = 0;\n   int npartitions;\n   int current_order = -1;\n   int noreorder_pos = 0;\n \n   FOR_EACH_VARIABLE (vnode)\n     gcc_assert (!vnode->aux);\n-    \n+\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (node->get_partitioning_class () == SYMBOL_PARTITION)\n       {\n \tif (node->no_reorder)\n \t  noreorder.safe_push (node);\n \telse\n-\t  order[n_nodes++] = node;\n+\t  order.safe_push (node);\n \tif (!node->alias)\n \t  total_size += ipa_fn_summaries->get_create (node)->size;\n       }\n@@ -540,15 +538,15 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n      unit tends to import a lot of global trees defined there.  We should\n      get better about minimizing the function bounday, but until that\n      things works smoother if we order in source order.  */\n-  qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);\n+  order.qsort (node_cmp);\n   noreorder.qsort (node_cmp);\n \n   if (symtab->dump_file)\n     {\n-      for(i = 0; i < n_nodes; i++)\n+      for (unsigned i = 0; i < order.length (); i++)\n \tfprintf (symtab->dump_file, \"Balanced map symbol order:%s:%u\\n\",\n \t\t order[i]->name (), order[i]->tp_first_run);\n-      for(i = 0; i < (int)noreorder.length(); i++)\n+      for (unsigned i = 0; i < noreorder.length (); i++)\n \tfprintf (symtab->dump_file, \"Balanced map symbol no_reorder:%s:%u\\n\",\n \t\t noreorder[i]->name (), noreorder[i]->tp_first_run);\n     }\n@@ -577,7 +575,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \n   auto_vec<symtab_node *> next_nodes;\n \n-  for (i = 0; i < n_nodes; i++)\n+  for (unsigned i = 0; i < order.length (); i++)\n     {\n       if (symbol_partitioned_p (order[i]))\n \tcontinue;\n@@ -792,9 +790,9 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t\t     \"Partition insns: %i (want %\" PRId64 \")\\n\",\n \t\t     partition->insns, partition_size);\n  \t  /* When we are finished, avoid creating empty partition.  */\n-\t  while (i < n_nodes - 1 && symbol_partitioned_p (order[i + 1]))\n+\t  while (i < order.length () - 1 && symbol_partitioned_p (order[i + 1]))\n \t    i++;\n-\t  if (i == n_nodes - 1)\n+\t  if (i == order.length () - 1)\n \t    break;\n \t  total_size -= partition->insns;\n \t  partition = new_partition (\"\");\n@@ -842,8 +840,6 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n   gcc_assert (next_nodes.length () || npartitions != 1 || !best_cost || best_cost == -1);\n   add_sorted_nodes (next_nodes, partition);\n \n-  free (order);\n-\n   if (symtab->dump_file)\n     {\n       fprintf (symtab->dump_file, \"\\nPartition sizes:\\n\");\n@@ -854,7 +850,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t  ltrans_partition p = ltrans_partitions[i];\n \t  fprintf (symtab->dump_file, \"partition %d contains %d (%2.2f%%)\"\n \t\t   \" symbols and %d (%2.2f%%) insns\\n\", i, p->symbols,\n-\t\t   100.0 * p->symbols / n_nodes, p->insns,\n+\t\t   100.0 * p->symbols / order.length (), p->insns,\n \t\t   100.0 * p->insns / original_total_size);\n \t}\n "}, {"sha": "537e95aae599dd9ab21b1cd4199779a384d9c62f", "filename": "gcc/passes.c", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/746447567a82ce2987f579770fd296ace60f87b1/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/746447567a82ce2987f579770fd296ace60f87b1/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=746447567a82ce2987f579770fd296ace60f87b1", "patch": "@@ -1635,22 +1635,16 @@ do_per_function (void (*callback) (function *, void *data), void *data)\n static int nnodes;\n static GTY ((length (\"nnodes\"))) cgraph_node **order;\n \n+#define uid_hash_t hash_set<int_hash <int, 0, -1>>\n+\n /* Hook called when NODE is removed and therefore should be\n-   excluded from order vector.  DATA is an array of integers.\n-   DATA[0] holds max index it may be accessed by.  For cgraph\n-   node DATA[node->uid + 1] holds index of this node in order\n-   vector.  */\n+   excluded from order vector.  DATA is a hash set with removed nodes.  */\n+\n static void\n remove_cgraph_node_from_order (cgraph_node *node, void *data)\n {\n-  int *order_idx = (int *)data;\n-\n-  if (node->uid >= order_idx[0])\n-    return;\n-\n-  int idx = order_idx[node->uid + 1];\n-  if (idx >= 0 && idx < nnodes && order[idx] == node)\n-    order[idx] = NULL;\n+  uid_hash_t *removed_nodes = (uid_hash_t *)data;\n+  removed_nodes->add (node->uid);\n }\n \n /* If we are in IPA mode (i.e., current_function_decl is NULL), call\n@@ -1667,30 +1661,23 @@ do_per_function_toporder (void (*callback) (function *, void *data), void *data)\n   else\n     {\n       cgraph_node_hook_list *hook;\n-      int *order_idx;\n+      uid_hash_t removed_nodes;\n       gcc_assert (!order);\n       order = ggc_vec_alloc<cgraph_node *> (symtab->cgraph_count);\n \n-      order_idx = XALLOCAVEC (int, symtab->cgraph_max_uid + 1);\n-      memset (order_idx + 1, -1, sizeof (int) * symtab->cgraph_max_uid);\n-      order_idx[0] = symtab->cgraph_max_uid;\n-\n       nnodes = ipa_reverse_postorder (order);\n       for (i = nnodes - 1; i >= 0; i--)\n-\t{\n-\t  order[i]->process = 1;\n-\t  order_idx[order[i]->uid + 1] = i;\n-\t}\n+\torder[i]->process = 1;\n       hook = symtab->add_cgraph_removal_hook (remove_cgraph_node_from_order,\n-\t\t\t\t\t      order_idx);\n+\t\t\t\t\t      &removed_nodes);\n       for (i = nnodes - 1; i >= 0; i--)\n \t{\n+\t  cgraph_node *node = order[i];\n+\n \t  /* Function could be inlined and removed as unreachable.  */\n-\t  if (!order[i])\n+\t  if (node == NULL || removed_nodes.contains (node->uid))\n \t    continue;\n \n-\t  struct cgraph_node *node = order[i];\n-\n \t  /* Allow possibly removed nodes to be garbage collected.  */\n \t  order[i] = NULL;\n \t  node->process = 0;"}, {"sha": "dda3ae5718f5cbac0bb2c1f8cbcedf7156a1f54d", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/746447567a82ce2987f579770fd296ace60f87b1/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/746447567a82ce2987f579770fd296ace60f87b1/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=746447567a82ce2987f579770fd296ace60f87b1", "patch": "@@ -90,13 +90,13 @@ class GTY((user)) function_summary <T *>\n      does not exist it will be created.  */\n   T* get_create (cgraph_node *node)\n   {\n-    return get (node->summary_uid, true);\n+    return get (node->uid, true);\n   }\n \n   /* Getter for summary callgraph node pointer.  */\n   T* get (cgraph_node *node)\n   {\n-    return get (node->summary_uid, false);\n+    return get (node->uid, false);\n   }\n \n   /* Return number of elements handled by data structure.  */\n@@ -108,7 +108,7 @@ class GTY((user)) function_summary <T *>\n   /* Return true if a summary for the given NODE already exists.  */\n   bool exists (cgraph_node *node)\n   {\n-    return m_map.get (node->summary_uid) != NULL;\n+    return m_map.get (node->uid) != NULL;\n   }\n \n   /* Enable insertion hook invocation.  */\n@@ -216,7 +216,7 @@ template <typename T>\n void\n function_summary<T *>::symtab_insertion (cgraph_node *node, void *data)\n {\n-  gcc_checking_assert (node->summary_uid);\n+  gcc_checking_assert (node->uid);\n   function_summary *summary = (function_summary <T *> *) (data);\n \n   if (summary->m_insertion_enabled)\n@@ -227,11 +227,11 @@ template <typename T>\n void\n function_summary<T *>::symtab_removal (cgraph_node *node, void *data)\n {\n-  gcc_checking_assert (node->summary_uid);\n+  gcc_checking_assert (node->uid);\n   function_summary *summary = (function_summary <T *> *) (data);\n \n-  int summary_uid = node->summary_uid;\n-  T **v = summary->m_map.get (summary_uid);\n+  int uid = node->uid;\n+  T **v = summary->m_map.get (uid);\n \n   if (v)\n     {\n@@ -240,7 +240,7 @@ function_summary<T *>::symtab_removal (cgraph_node *node, void *data)\n       if (!summary->m_ggc)\n \tdelete (*v);\n \n-      summary->m_map.remove (summary_uid);\n+      summary->m_map.remove (uid);\n     }\n }\n \n@@ -256,7 +256,7 @@ function_summary<T *>::symtab_duplication (cgraph_node *node,\n     {\n       /* This load is necessary, because we insert a new value!  */\n       T *duplicate = summary->allocate_new ();\n-      summary->m_map.put (node2->summary_uid, duplicate);\n+      summary->m_map.put (node2->uid, duplicate);\n       summary->duplicate (node, node2, v, duplicate);\n     }\n }"}]}