{"sha": "67518c93373e9ad3ebe4818114f23cd42cce1f18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc1MThjOTMzNzNlOWFkM2ViZTQ4MTgxMTRmMjNjZDQyY2NlMWYxOA==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2013-08-26T16:57:28Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2013-08-26T16:57:28Z"}, "message": "avr.opt (mfract-convert-truncate): New option.\n\n        * config/avr/avr.opt (mfract-convert-truncate): New option.\n        * config/avr/avr.c (avr_out_fract): Unless TARGET_FRACT_CONV_TRUNC\n        is set, round negative fractional integers according to n1169\n        when converting to integer types.\n\nFrom-SVN: r202008", "tree": {"sha": "d2d3bf1a07979de80270e19535ae97df853672fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2d3bf1a07979de80270e19535ae97df853672fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67518c93373e9ad3ebe4818114f23cd42cce1f18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67518c93373e9ad3ebe4818114f23cd42cce1f18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67518c93373e9ad3ebe4818114f23cd42cce1f18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67518c93373e9ad3ebe4818114f23cd42cce1f18/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e2bcc98226483792e13f32d0dfbac8d828c3ca2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2bcc98226483792e13f32d0dfbac8d828c3ca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e2bcc98226483792e13f32d0dfbac8d828c3ca2"}], "stats": {"total": 207, "additions": 205, "deletions": 2}, "files": [{"sha": "5bb88ea63d67955680476438d82e0679431002b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67518c93373e9ad3ebe4818114f23cd42cce1f18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67518c93373e9ad3ebe4818114f23cd42cce1f18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67518c93373e9ad3ebe4818114f23cd42cce1f18", "patch": "@@ -3,6 +3,11 @@\n \t* config/avr/avr-stdint.h (INT16_TYPE): Change default to \"int\".\n \t(UINT16_TYPE): Change default to \"unsigned int\".\n \n+\t* config/avr/avr.opt (mfract-convert-truncate): New option.\n+\t* config/avr/avr.c (avr_out_fract): Unless TARGET_FRACT_CONV_TRUNC\n+\tis set, round negative fractional integers according to n1169\n+\twhen converting to integer types.\n+\n 2013-08-26  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_propagate_frequency): Do not assume that virtual"}, {"sha": "f6d88856becd1923bbcbaa526c639b1ec461f01e", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 196, "deletions": 2, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67518c93373e9ad3ebe4818114f23cd42cce1f18/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67518c93373e9ad3ebe4818114f23cd42cce1f18/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=67518c93373e9ad3ebe4818114f23cd42cce1f18", "patch": "@@ -7030,14 +7030,17 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)\n   RTX_CODE shift = UNKNOWN;\n   bool sign_in_carry = false;\n   bool msb_in_carry = false;\n+  bool lsb_in_tmp_reg = false;\n   bool lsb_in_carry = false;\n+  bool frac_rounded = false;\n   const char *code_ashift = \"lsl %0\";\n \n \n #define MAY_CLOBBER(RR)                                                 \\\n   /* Shorthand used below.  */                                          \\\n   ((sign_bytes                                                          \\\n     && IN_RANGE (RR, dest.regno_msb - sign_bytes + 1, dest.regno_msb))  \\\n+   || (offset && IN_RANGE (RR, dest.regno, dest.regno_msb))\t\t\\\n    || (reg_unused_after (insn, all_regs_rtx[RR])                        \\\n        && !IN_RANGE (RR, dest.regno, dest.regno_msb)))\n \n@@ -7112,13 +7115,119 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)\n   else\n     gcc_unreachable();\n \n+  /* If we need to round the fraction part, we might need to save/round it\n+     before clobbering any of it in Step 1.  Also, we might to want to do\n+     the rounding now to make use of LD_REGS.  */\n+  if (SCALAR_INT_MODE_P (GET_MODE (xop[0]))\n+      && SCALAR_ACCUM_MODE_P (GET_MODE (xop[1]))\n+      && !TARGET_FRACT_CONV_TRUNC)\n+    {\n+      bool overlap\n+\t= (src.regno <=\n+\t   (offset ? dest.regno_msb - sign_bytes : dest.regno + zero_bytes - 1)\n+\t   && dest.regno - offset -1 >= dest.regno);\n+      unsigned s0 = dest.regno - offset -1;\n+      bool use_src = true;\n+      unsigned sn;\n+      unsigned copied_msb = src.regno_msb;\n+      bool have_carry = false;\n+\n+      if (src.ibyte > dest.ibyte)\n+\tcopied_msb -= src.ibyte - dest.ibyte;\n+\n+      for (sn = s0; sn <= copied_msb; sn++)\n+\tif (!IN_RANGE (sn, dest.regno, dest.regno_msb)\n+\t    && !reg_unused_after (insn, all_regs_rtx[sn]))\n+\t  use_src = false;\n+      if (use_src && TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], s0))\n+\t{\n+\t  avr_asm_len (\"tst %0\" CR_TAB \"brpl 0f\",\n+\t\t       &all_regs_rtx[src.regno_msb], plen, 2);\n+\t  sn = src.regno;\n+\t  if (sn < s0)\n+\t    {\n+\t      if (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], sn))\n+\t\tavr_asm_len (\"cpi %0,1\", &all_regs_rtx[sn], plen, 1);\n+\t      else\n+\t\tavr_asm_len (\"sec\" CR_TAB \"cpc %0,__zero_reg__\",\n+\t\t\t     &all_regs_rtx[sn], plen, 2);\n+\t      have_carry = true;\n+\t    }\n+\t  while (++sn < s0)\n+\t    avr_asm_len (\"cpc %0,__zero_reg__\", &all_regs_rtx[sn], plen, 1);\n+\t  avr_asm_len (have_carry ? \"sbci %0,128\" : \"subi %0,129\",\n+\t\t       &all_regs_rtx[s0], plen, 1);\n+\t  for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)\n+\t    avr_asm_len (\"sbci %0,255\", &all_regs_rtx[sn], plen, 1);\n+\t  avr_asm_len (\"\\n0:\", NULL, plen, 0);\n+\t  frac_rounded = true;\n+\t}\n+      else if (use_src && overlap)\n+\t{\n+\t  avr_asm_len (\"clr __tmp_reg__\" CR_TAB\n+\t\t       \"sbrc %1,0\" CR_TAB \"dec __tmp_reg__\", xop, plen, 1);\n+\t  sn = src.regno;\n+\t  if (sn < s0)\n+\t    {\n+\t      avr_asm_len (\"add %0,__tmp_reg__\", &all_regs_rtx[sn], plen, 1);\n+\t      have_carry = true;\n+\t    }\n+\t  while (++sn < s0)\n+\t    avr_asm_len (\"adc %0,__tmp_reg__\", &all_regs_rtx[sn], plen, 1);\n+\t  if (have_carry)\n+\t    avr_asm_len (\"clt\" CR_TAB \"bld __tmp_reg__,7\" CR_TAB\n+\t\t\t \"adc %0,__tmp_reg__\",\n+\t\t\t &all_regs_rtx[s0], plen, 1);\n+\t  else\n+\t    avr_asm_len (\"lsr __tmp_reg\" CR_TAB \"add %0,__tmp_reg__\",\n+\t\t\t &all_regs_rtx[s0], plen, 2);\n+\t  for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)\n+\t    avr_asm_len (\"adc %0,__zero_reg__\", &all_regs_rtx[sn], plen, 1);\n+\t  frac_rounded = true;\n+\t}\n+      else if (overlap)\n+\t{\n+\t  bool use_src\n+\t    = (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], s0)\n+\t       && (IN_RANGE (s0, dest.regno, dest.regno_msb)\n+\t\t   || reg_unused_after (insn, all_regs_rtx[s0])));\n+\t  xop[2] = all_regs_rtx[s0];\n+\t  unsigned sn = src.regno;\n+\t  if (!use_src || sn == s0)\n+\t    avr_asm_len (\"mov __tmp_reg__,%2\", xop, plen, 1);\n+\t  /* We need to consider to-be-discarded bits\n+\t     if the value is negative.  */\n+\t  if (sn < s0)\n+\t    {\n+\t      avr_asm_len (\"tst %0\" CR_TAB \"brpl 0f\",\n+\t\t\t   &all_regs_rtx[src.regno_msb], plen, 2);\n+\t      /* Test to-be-discarded bytes for any nozero bits.\n+\t\t ??? Could use OR or SBIW to test two registers at once.  */\n+\t      if (sn < s0)\n+\t\tavr_asm_len (\"cp %0,__zero_reg__\", &all_regs_rtx[sn], plen, 1);\n+\t      while (++sn < s0)\n+\t\tavr_asm_len (\"cpc %0,__zero_reg__\", &all_regs_rtx[sn], plen, 1);\n+\t      /* Set bit 0 in __tmp_reg__ if any of the lower bits was set.  */\n+\t      if (use_src)\n+\t\tavr_asm_len (\"breq 0f\" CR_TAB\n+\t\t\t     \"ori %2,1\" \"\\n0:\\t\" \"mov __tmp_reg__,%2\",\n+\t\t\t     xop, plen, 3);\n+\t      else\n+\t\tavr_asm_len (\"breq 0f\" CR_TAB\n+\t\t\t     \"set\" CR_TAB \"bld __tmp_reg__,0\\n0:\",\n+\t\t\t     xop, plen, 3);\n+\t    }\n+\t  lsb_in_tmp_reg = true;\n+\t}\n+    }\n+\n   /* Step 1:  Clear bytes at the low end and copy payload bits from source\n      ======   to destination.  */\n \n   int step = offset < 0 ? 1 : -1;\n   unsigned d0 = offset < 0 ? dest.regno : dest.regno_msb;\n \n-  // We leared at least that number of registers.\n+  // We cleared at least that number of registers.\n   int clr_n = 0;\n \n   for (; d0 >= dest.regno && d0 <= dest.regno_msb; d0 += step)\n@@ -7208,6 +7317,7 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)\n           unsigned src_lsb = dest.regno - offset -1;\n \n           if (shift == ASHIFT && src.fbyte > dest.fbyte && !lsb_in_carry\n+\t      && !lsb_in_tmp_reg\n               && (d0 == src_lsb || d0 + stepw == src_lsb))\n             {\n               /* We are going to override the new LSB; store it into carry.  */\n@@ -7229,7 +7339,91 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)\n     {\n       unsigned s0 = dest.regno - offset -1;\n \n-      if (MAY_CLOBBER (s0))\n+      /* n1169 4.1.4 says:\n+\t \"Conversions from a fixed-point to an integer type round toward zero.\"\n+\t Hence, converting a fract type to integer only gives a non-zero result\n+\t for -1.  */\n+      if (SCALAR_INT_MODE_P (GET_MODE (xop[0]))\n+\t  && SCALAR_FRACT_MODE_P (GET_MODE (xop[1]))\n+\t  && !TARGET_FRACT_CONV_TRUNC)\n+\t{\n+\t  gcc_assert (s0 == src.regno_msb);\n+\t  /* Check if the input is -1.  We do that by checking if negating\n+\t     the input causes an integer overflow.  */\n+\t  unsigned sn = src.regno;\n+\t  avr_asm_len (\"cp __zero_reg__,%0\", &all_regs_rtx[sn++], plen, 1);\n+\t  while (sn <= s0)\n+\t    avr_asm_len (\"cpc __zero_reg__,%0\", &all_regs_rtx[sn++], plen, 1);\n+\n+\t  /* Overflow goes with set carry.  Clear carry otherwise.  */\n+\t  avr_asm_len (\"brvs 0f\" CR_TAB \"clc\\n0:\", NULL, plen, 2);\n+\t}\n+      /* Likewise, when converting from accumulator types to integer, we\n+\t need to round up negative values.  */\n+      else if (SCALAR_INT_MODE_P (GET_MODE (xop[0]))\n+\t       && SCALAR_ACCUM_MODE_P (GET_MODE (xop[1]))\n+\t       && !TARGET_FRACT_CONV_TRUNC\n+\t       && !frac_rounded)\n+\t{\n+\t  bool have_carry = false;\n+\n+\t  xop[2] = all_regs_rtx[s0];\n+\t  if (!lsb_in_tmp_reg && !MAY_CLOBBER (s0))\n+\t    avr_asm_len (\"mov __tmp_reg__,%2\", xop, plen, 1);\n+\t  avr_asm_len (\"tst %0\" CR_TAB \"brpl 0f\",\n+\t\t       &all_regs_rtx[src.regno_msb], plen, 2);\n+\t  if (!lsb_in_tmp_reg)\n+\t    {\n+\t      unsigned sn = src.regno;\n+\t      if (sn < s0)\n+\t\t{\n+\t\t  avr_asm_len (\"cp __zero_reg__,%0\", &all_regs_rtx[sn],\n+\t\t\t       plen, 1);\n+\t\t  have_carry = true;\n+\t\t}\n+\t      while (++sn < s0)\n+\t\tavr_asm_len (\"cpc __zero_reg__,%0\", &all_regs_rtx[sn], plen, 1);\n+\t      lsb_in_tmp_reg = !MAY_CLOBBER (s0);\n+\t    }\n+\t  /* Add in C and the rounding value 127.  */\n+\t  /* If the destination msb is a sign byte, and in LD_REGS,\n+\t     grab it as a temporary.  */\n+\t  if (sign_bytes\n+\t      && TEST_HARD_REG_BIT (reg_class_contents[LD_REGS],\n+\t\t\t\t    dest.regno_msb))\n+\t    {\n+\t      xop[3] = all_regs_rtx[dest.regno_msb];\n+\t      avr_asm_len (\"ldi %3,127\", xop, plen, 1);\n+\t      avr_asm_len ((have_carry && lsb_in_tmp_reg ? \"adc __tmp_reg__,%3\"\n+\t\t\t   : have_carry ? \"adc %2,%3\"\n+\t\t\t   : lsb_in_tmp_reg ? \"add __tmp_reg__,%3\"\n+\t\t\t   : \"add %2,%3\"),\n+\t\t\t   xop, plen, 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Fall back to use __zero_reg__ as a temporary.  */\n+\t      avr_asm_len (\"dec __zero_reg__\", NULL, plen, 1);\n+\t      if (have_carry)\n+\t\tavr_asm_len (\"clt\" CR_TAB \"bld __zero_reg__,7\", NULL, plen, 2);\n+\t      else\n+\t\tavr_asm_len (\"lsr __zero_reg__\", NULL, plen, 1);\n+\t      avr_asm_len ((have_carry && lsb_in_tmp_reg\n+\t\t\t   ? \"adc __tmp_reg__,__zero_reg__\"\n+\t\t\t   : have_carry ? \"adc %2,__zero_reg__\"\n+\t\t\t   : lsb_in_tmp_reg ? \"add __tmp_reg__,__zero_reg__\"\n+\t\t\t   : \"add %2,__zero_reg__\"),\n+\t\t\t   xop, plen, 1);\n+\t      avr_asm_len (\"eor __zero_reg__,__zero_reg__\", NULL, plen, 1);\n+\t    }\n+\t  for (d0 = dest.regno + zero_bytes;\n+\t       d0 <= dest.regno_msb - sign_bytes; d0++)\n+\t    avr_asm_len (\"adc %0,__zero_reg__\", &all_regs_rtx[d0], plen, 1);\n+\t  avr_asm_len (lsb_in_tmp_reg\n+\t\t       ? \"\\n0:\\t\" \"lsl __tmp_reg__\" : \"\\n0:\\t\" \"lsl %2\",\n+\t\t       xop, plen, 1);\n+\t}\n+      else if (MAY_CLOBBER (s0))\n         avr_asm_len (\"lsl %0\", &all_regs_rtx[s0], plen, 1);\n       else\n         avr_asm_len (\"mov __tmp_reg__,%0\" CR_TAB"}, {"sha": "9b0f782d385c05a6995e9bf8a762850dc258dde7", "filename": "gcc/config/avr/avr.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67518c93373e9ad3ebe4818114f23cd42cce1f18/gcc%2Fconfig%2Favr%2Favr.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67518c93373e9ad3ebe4818114f23cd42cce1f18/gcc%2Fconfig%2Favr%2Favr.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.opt?ref=67518c93373e9ad3ebe4818114f23cd42cce1f18", "patch": "@@ -78,3 +78,7 @@ The device has no SPH special function register. This option will be overridden\n Waddr-space-convert\n Warning C Report Var(avr_warn_addr_space_convert) Init(0)\n Warn if the address space of an address is changed.\n+\n+mfract-convert-truncate\n+Target Report Mask(FRACT_CONV_TRUNC)\n+Allow to use truncation instead of rounding towards 0 for fractional int types"}]}