{"sha": "cdf899781c7321987a9948e5ca0847e8b38da798", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RmODk5NzgxYzczMjE5ODdhOTk0OGU1Y2EwODQ3ZThiMzhkYTc5OA==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2018-08-13T11:33:38Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2018-08-13T11:33:38Z"}, "message": "S/390: Factor out constant pool ref decomposition\n\ngcc/ChangeLog:\n\n2018-08-13  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\t* config/s390/s390.c (s390_decompose_constant_pool_ref):\n        New function.\n\t(s390_decompose_address): Factor out constant pool ref\n        decomposition.\n\nFrom-SVN: r263504", "tree": {"sha": "0bd0f9e83368735f320e6668082c46e7a19764dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bd0f9e83368735f320e6668082c46e7a19764dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdf899781c7321987a9948e5ca0847e8b38da798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf899781c7321987a9948e5ca0847e8b38da798", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdf899781c7321987a9948e5ca0847e8b38da798", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf899781c7321987a9948e5ca0847e8b38da798/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a3b69f94b39ddaaef5a095f8133478ee6383674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a3b69f94b39ddaaef5a095f8133478ee6383674", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a3b69f94b39ddaaef5a095f8133478ee6383674"}], "stats": {"total": 162, "additions": 74, "deletions": 88}, "files": [{"sha": "e4cf0b693a1fcf0e2418ac958b227f818f739a90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf899781c7321987a9948e5ca0847e8b38da798/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf899781c7321987a9948e5ca0847e8b38da798/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cdf899781c7321987a9948e5ca0847e8b38da798", "patch": "@@ -1,3 +1,10 @@\n+2018-08-13  Ilya Leoshkevich  <iii@linux.ibm.com>\n+\n+\t* config/s390/s390.c (s390_decompose_constant_pool_ref):\n+        New function.\n+\t(s390_decompose_address): Factor out constant pool ref\n+        decomposition.\n+\n 2018-08-12  Chung-Ju Wu  <jasonwucj@gmail.com>\n \n \t* config/nds32/nds32-predicates.c"}, {"sha": "cc6f3489998b33da0c0253b1084835cf59c3bf6e", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 67, "deletions": 88, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf899781c7321987a9948e5ca0847e8b38da798/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf899781c7321987a9948e5ca0847e8b38da798/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=cdf899781c7321987a9948e5ca0847e8b38da798", "patch": "@@ -2748,6 +2748,67 @@ s390_short_displacement (rtx disp)\n   return false;\n }\n \n+/* Attempts to split `ref', which should be either UNSPEC_LTREF or\n+   UNSPEC_LTREL_BASE, into (base + `disp').  In case pool base is not known,\n+   caller-provided `pool_base' is used.  If successful, also determines the\n+   following characteristics of `ref': `is_ptr' - whether it can be an\n+   LA argument, `is_base_ptr' - whether the resulting base is a well-known\n+   base register (stack/frame pointer, etc), `is_pool_ptr` - whether it is\n+   considered a literal pool pointer for purposes of avoiding two different\n+   literal pool pointers per insn during or after reload (`B' constraint).  */\n+static bool\n+s390_decompose_constant_pool_ref (rtx *ref, rtx *disp, bool *is_ptr,\n+\t\t\t\t  bool *is_base_ptr, bool *is_pool_ptr,\n+\t\t\t\t  rtx pool_base)\n+{\n+  if (!*ref)\n+    return true;\n+\n+  if (GET_CODE (*ref) == UNSPEC)\n+    switch (XINT (*ref, 1))\n+      {\n+      case UNSPEC_LTREF:\n+\tif (!*disp)\n+\t  *disp = gen_rtx_UNSPEC (Pmode,\n+\t\t\t\t  gen_rtvec (1, XVECEXP (*ref, 0, 0)),\n+\t\t\t\t  UNSPEC_LTREL_OFFSET);\n+\telse\n+\t  return false;\n+\n+\t*ref = XVECEXP (*ref, 0, 1);\n+\tbreak;\n+\n+      case UNSPEC_LTREL_BASE:\n+\tif (XVECLEN (*ref, 0) == 1)\n+\t  *ref = pool_base, *is_pool_ptr = true;\n+\telse\n+\t  *ref = XVECEXP (*ref, 0, 1);\n+\tbreak;\n+\n+      default:\n+\treturn false;\n+      }\n+\n+  if (!REG_P (*ref) || GET_MODE (*ref) != Pmode)\n+    return false;\n+\n+  if (REGNO (*ref) == STACK_POINTER_REGNUM\n+      || REGNO (*ref) == FRAME_POINTER_REGNUM\n+      || ((reload_completed || reload_in_progress)\n+\t  && frame_pointer_needed\n+\t  && REGNO (*ref) == HARD_FRAME_POINTER_REGNUM)\n+      || REGNO (*ref) == ARG_POINTER_REGNUM\n+      || (flag_pic\n+\t  && REGNO (*ref) == PIC_OFFSET_TABLE_REGNUM))\n+    *is_ptr = *is_base_ptr = true;\n+\n+  if ((reload_completed || reload_in_progress)\n+      && *ref == cfun->machine->base_reg)\n+    *is_ptr = *is_base_ptr = *is_pool_ptr = true;\n+\n+  return true;\n+}\n+\n /* Decompose a RTL expression ADDR for a memory address into\n    its components, returned in OUT.\n \n@@ -2859,96 +2920,14 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n     }\n \n   /* Validate base register.  */\n-  if (base)\n-    {\n-      if (GET_CODE (base) == UNSPEC)\n-\tswitch (XINT (base, 1))\n-\t  {\n-\t  case UNSPEC_LTREF:\n-\t    if (!disp)\n-\t      disp = gen_rtx_UNSPEC (Pmode,\n-\t\t\t\t     gen_rtvec (1, XVECEXP (base, 0, 0)),\n-\t\t\t\t     UNSPEC_LTREL_OFFSET);\n-\t    else\n-\t      return false;\n-\n-\t    base = XVECEXP (base, 0, 1);\n-\t    break;\n-\n-\t  case UNSPEC_LTREL_BASE:\n-\t    if (XVECLEN (base, 0) == 1)\n-\t      base = fake_pool_base, literal_pool = true;\n-\t    else\n-\t      base = XVECEXP (base, 0, 1);\n-\t    break;\n-\n-\t  default:\n-\t    return false;\n-\t  }\n-\n-      if (!REG_P (base) || GET_MODE (base) != Pmode)\n-\treturn false;\n-\n-      if (REGNO (base) == STACK_POINTER_REGNUM\n-\t  || REGNO (base) == FRAME_POINTER_REGNUM\n-\t  || ((reload_completed || reload_in_progress)\n-\t      && frame_pointer_needed\n-\t      && REGNO (base) == HARD_FRAME_POINTER_REGNUM)\n-\t  || REGNO (base) == ARG_POINTER_REGNUM\n-\t  || (flag_pic\n-\t      && REGNO (base) == PIC_OFFSET_TABLE_REGNUM))\n-\tpointer = base_ptr = true;\n-\n-      if ((reload_completed || reload_in_progress)\n-\t  && base == cfun->machine->base_reg)\n-\tpointer = base_ptr = literal_pool = true;\n-    }\n+  if (!s390_decompose_constant_pool_ref (&base, &disp, &pointer, &base_ptr,\n+\t\t\t\t\t &literal_pool, fake_pool_base))\n+    return false;\n \n   /* Validate index register.  */\n-  if (indx)\n-    {\n-      if (GET_CODE (indx) == UNSPEC)\n-\tswitch (XINT (indx, 1))\n-\t  {\n-\t  case UNSPEC_LTREF:\n-\t    if (!disp)\n-\t      disp = gen_rtx_UNSPEC (Pmode,\n-\t\t\t\t     gen_rtvec (1, XVECEXP (indx, 0, 0)),\n-\t\t\t\t     UNSPEC_LTREL_OFFSET);\n-\t    else\n-\t      return false;\n-\n-\t    indx = XVECEXP (indx, 0, 1);\n-\t    break;\n-\n-\t  case UNSPEC_LTREL_BASE:\n-\t    if (XVECLEN (indx, 0) == 1)\n-\t      indx = fake_pool_base, literal_pool = true;\n-\t    else\n-\t      indx = XVECEXP (indx, 0, 1);\n-\t    break;\n-\n-\t  default:\n-\t    return false;\n-\t  }\n-\n-      if (!REG_P (indx) || GET_MODE (indx) != Pmode)\n-\treturn false;\n-\n-      if (REGNO (indx) == STACK_POINTER_REGNUM\n-\t  || REGNO (indx) == FRAME_POINTER_REGNUM\n-\t  || ((reload_completed || reload_in_progress)\n-\t      && frame_pointer_needed\n-\t      && REGNO (indx) == HARD_FRAME_POINTER_REGNUM)\n-\t  || REGNO (indx) == ARG_POINTER_REGNUM\n-\t  || (flag_pic\n-\t      && REGNO (indx) == PIC_OFFSET_TABLE_REGNUM))\n-\tpointer = indx_ptr = true;\n-\n-      if ((reload_completed || reload_in_progress)\n-\t  && indx == cfun->machine->base_reg)\n-\tpointer = indx_ptr = literal_pool = true;\n-    }\n+  if (!s390_decompose_constant_pool_ref (&indx, &disp, &pointer, &indx_ptr,\n+\t\t\t\t\t &literal_pool, fake_pool_base))\n+    return false;\n \n   /* Prefer to use pointer as base, not index.  */\n   if (base && indx && !base_ptr"}]}