{"sha": "848a1a28b91d105ff4f21cc9993befbcecb3e39d", "node_id": "C_kwDOANBUbNoAKDg0OGExYTI4YjkxZDEwNWZmNGYyMWNjOTk5M2JlZmJjZWNiM2UzOWQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-06-17T07:12:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-17T07:12:29Z"}, "message": "Merge #1315\n\n1315: Add base for parsing const generic application r=CohenArthur a=CohenArthur\n\n1. Refactor const generic declaration\r\n\r\nThe default value for const generics now benefits from using the same\r\nfunction as parsing a regular const generic expression\r\n\r\n2. `Parser::parse_type` should not always add errors\r\n\r\nIn the case that we are parsing a const generic and not a type, we\r\nshould not emit bogus errors from `parse_type` such as \"unexpected token\r\nin type: LITERAL\". Thus, we add a flag to the function to not always\r\nadd errors to the error table\r\n\r\n3. Figure out how to deal with ambiguities\r\n\r\nIn the following cases, parsing is ambiguous:\r\n\r\n```rust\r\nlet a: Foo<N>;\r\n```\r\n\r\nWhat is N? Is it a type to be used as a generic argument? Is it a const\r\nvalue to be used for a const generic argument? We need to keep both\r\npossibilities and differentiate later during typechecking. We need to\r\nfigure out if it would be better to keep the ambiguity in our future\r\n`ConstGenericArg` type (something like Kind::ConstVarOrType) or modify\r\nour current `AST::Type` to maybe get differentiated later as a const\r\nvariable, which seems more annoying.\r\n\r\nFinally, since the const evaluation is not implemented yet, we are\r\ngetting some bogus errors in the testcase. This commit simply serves as\r\na necessary base: parsing const generics before we can apply them.\r\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "8acf823dd2b8b35dee20c16b2b36d11f5ffa7e49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8acf823dd2b8b35dee20c16b2b36d11f5ffa7e49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/848a1a28b91d105ff4f21cc9993befbcecb3e39d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJirCldCRBK7hj4Ov3rIwAALTUIAF4dciRXdAG9t/wYaRUhW3IS\naH247GDPImo+pWPY/Y1+kAv6lwsHw1aZVzIRH+8DPMhRU9VmjftHFMesWfkblT8u\naqQX3Zjg97BHDdaJNG9+1vVqB0y/3YI9dl9veeTTLgzy+SJ4/LBIMJrZFosB4hf+\np2bUS28qPpZMOjTZlKPOtEOTYjssqaE/9UOVDD8KoWKf17XH37pLK4U4QOLpDddo\nHWQAERG49U4QsRhzounv0oscv+Z4jJGpYWumDTIUKX5bpBNLu3X47tMSoyh+j3Lv\n4j4yF5kcA3grmucYuDk+M9zl0YzQo2SXwN6srWesn+mOLXBkMkUrpDapupllmpY=\n=mgVS\n-----END PGP SIGNATURE-----\n", "payload": "tree 8acf823dd2b8b35dee20c16b2b36d11f5ffa7e49\nparent d4a0780073bfaf96d72427d5138b74ef257ed625\nparent 0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1655449949 +0000\ncommitter GitHub <noreply@github.com> 1655449949 +0000\n\nMerge #1315\n\n1315: Add base for parsing const generic application r=CohenArthur a=CohenArthur\n\n1. Refactor const generic declaration\r\n\r\nThe default value for const generics now benefits from using the same\r\nfunction as parsing a regular const generic expression\r\n\r\n2. `Parser::parse_type` should not always add errors\r\n\r\nIn the case that we are parsing a const generic and not a type, we\r\nshould not emit bogus errors from `parse_type` such as \"unexpected token\r\nin type: LITERAL\". Thus, we add a flag to the function to not always\r\nadd errors to the error table\r\n\r\n3. Figure out how to deal with ambiguities\r\n\r\nIn the following cases, parsing is ambiguous:\r\n\r\n```rust\r\nlet a: Foo<N>;\r\n```\r\n\r\nWhat is N? Is it a type to be used as a generic argument? Is it a const\r\nvalue to be used for a const generic argument? We need to keep both\r\npossibilities and differentiate later during typechecking. We need to\r\nfigure out if it would be better to keep the ambiguity in our future\r\n`ConstGenericArg` type (something like Kind::ConstVarOrType) or modify\r\nour current `AST::Type` to maybe get differentiated later as a const\r\nvariable, which seems more annoying.\r\n\r\nFinally, since the const evaluation is not implemented yet, we are\r\ngetting some bogus errors in the testcase. This commit simply serves as\r\na necessary base: parsing const generics before we can apply them.\r\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848a1a28b91d105ff4f21cc9993befbcecb3e39d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/848a1a28b91d105ff4f21cc9993befbcecb3e39d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848a1a28b91d105ff4f21cc9993befbcecb3e39d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4a0780073bfaf96d72427d5138b74ef257ed625", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4a0780073bfaf96d72427d5138b74ef257ed625", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4a0780073bfaf96d72427d5138b74ef257ed625"}, {"sha": "0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6"}], "stats": {"total": 190, "additions": 128, "deletions": 62}, "files": [{"sha": "a1f88d83205401e9499c2f92ddeeb691c6511a08", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848a1a28b91d105ff4f21cc9993befbcecb3e39d/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848a1a28b91d105ff4f21cc9993befbcecb3e39d/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=848a1a28b91d105ff4f21cc9993befbcecb3e39d", "patch": "@@ -134,6 +134,8 @@ struct GenericArgs\n   std::vector<Lifetime> lifetime_args;\n   std::vector<std::unique_ptr<Type> > type_args;\n   std::vector<GenericArgsBinding> binding_args;\n+  // TODO: Handle const generics here as well.\n+  // We can probably keep a vector of `Expr`s for this.\n   Location locus;\n \n public:"}, {"sha": "3a76d748d6a5703a208b7f52f3748d441cd1c34e", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 98, "deletions": 61, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848a1a28b91d105ff4f21cc9993befbcecb3e39d/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848a1a28b91d105ff4f21cc9993befbcecb3e39d/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=848a1a28b91d105ff4f21cc9993befbcecb3e39d", "patch": "@@ -2885,37 +2885,14 @@ Parser<ManagedTokenSource>::parse_generic_param (EndTokenPred is_end_token)\n \t  {\n \t    lexer.skip_token ();\n \t    auto tok = lexer.peek_token ();\n+\t    auto default_expr = parse_const_generic_expression ();\n \n-\t    switch (tok->get_id ())\n-\t      {\n-\t\tcase LEFT_CURLY: {\n-\t\t  auto block = parse_block_expr ();\n-\t\t  // pass block to `const_generic`\n-\t\t  break;\n-\t\t}\n-\t\tcase IDENTIFIER: {\n-\t\t  auto ident = tok->get_str ();\n-\t\t  // pass identifier to `const_generic`\n-\t\t  break;\n-\t\t}\n-\t      case MINUS:\n-\t      case STRING_LITERAL:\n-\t      case CHAR_LITERAL:\n-\t      case INT_LITERAL:\n-\t      case FLOAT_LITERAL:\n-\t      case TRUE_LITERAL:\n-\t\tcase FALSE_LITERAL: {\n-\t\t  auto literal = parse_literal_expr ();\n-\t\t  // pass literal to `const_generic`\n-\t\t  break;\n-\t\t}\n-\t      default:\n-\t\trust_error_at (tok->get_locus (),\n-\t\t\t       \"invalid token for start of default value for \"\n-\t\t\t       \"const generic parameter: expected %<block%>, \"\n-\t\t\t       \"%<identifier%> or %<literal%>, got %qs\",\n-\t\t\t       token_id_to_str (tok->get_id ()));\n-\t      }\n+\t    if (!default_expr)\n+\t      rust_error_at (tok->get_locus (),\n+\t\t\t     \"invalid token for start of default value for \"\n+\t\t\t     \"const generic parameter: expected %<block%>, \"\n+\t\t\t     \"%<identifier%> or %<literal%>, got %qs\",\n+\t\t\t     token_id_to_str (tok->get_id ()));\n \t  }\n \n \t// param = std::unique_ptr<AST::GenericParam> (const_generic)\n@@ -6182,6 +6159,39 @@ Parser<ManagedTokenSource>::parse_type_path ()\n \t\t\thas_opening_scope_resolution);\n }\n \n+template <typename ManagedTokenSource>\n+std::unique_ptr<AST::Expr>\n+Parser<ManagedTokenSource>::parse_const_generic_expression ()\n+{\n+  auto tok = lexer.peek_token ();\n+  switch (tok->get_id ())\n+    {\n+    case LEFT_CURLY:\n+      return parse_block_expr ();\n+      case IDENTIFIER: {\n+\tlexer.skip_token ();\n+\n+\t// TODO: This is ambiguous with regular generic types. We probably need\n+\t// to differentiate later on during type checking, and thus keep a\n+\t// special variant here\n+\n+\t// return this\n+\treturn std::unique_ptr<AST::IdentifierExpr> (\n+\t  new AST::IdentifierExpr (tok->get_str (), {}, tok->get_locus ()));\n+      }\n+    case MINUS:\n+    case STRING_LITERAL:\n+    case CHAR_LITERAL:\n+    case INT_LITERAL:\n+    case FLOAT_LITERAL:\n+    case TRUE_LITERAL:\n+    case FALSE_LITERAL:\n+      return parse_literal_expr ();\n+    default:\n+      return nullptr;\n+    }\n+}\n+\n // Parses the generic arguments in each path segment.\n template <typename ManagedTokenSource>\n AST::GenericArgs\n@@ -6193,6 +6203,9 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n       return AST::GenericArgs::create_empty ();\n     }\n \n+  // We need to parse all lifetimes, then parse types and const generics in\n+  // any order.\n+\n   // try to parse lifetimes first\n   std::vector<AST::Lifetime> lifetime_args;\n \n@@ -6222,35 +6235,42 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n \n   // try to parse types second\n   std::vector<std::unique_ptr<AST::Type>> type_args;\n+  std::vector<std::unique_ptr<AST::Expr>> const_args;\n+\n+  // TODO: Keep list of const expressions as well\n \n   // TODO: think of better control structure\n   t = lexer.peek_token ();\n   while (!is_right_angle_tok (t->get_id ()))\n     {\n+      // FIXME: Is it fine to break if there is one binding? Can't there be\n+      // bindings in between types?\n+\n       // ensure not binding being parsed as type accidently\n       if (t->get_id () == IDENTIFIER\n \t  && lexer.peek_token (1)->get_id () == EQUAL)\n+\tbreak;\n+\n+      auto type = parse_type (false);\n+      if (type)\n \t{\n-\t  break;\n+\t  type_args.emplace_back (std::move (type));\n \t}\n-\n-      std::unique_ptr<AST::Type> type = parse_type ();\n-      if (type == nullptr)\n+      else\n \t{\n-\t  // not necessarily an error\n-\t  break;\n+\t  auto const_generic_expr = parse_const_generic_expression ();\n+\t  if (const_generic_expr)\n+\t    const_args.emplace_back (std::move (const_generic_expr));\n+\t  else\n+\t    break;\n \t}\n \n-      type_args.push_back (std::move (type));\n-\n       // if next token isn't comma, then it must be end of list\n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n-\t  break;\n-\t}\n+\tbreak;\n+\n       // skip comma\n       lexer.skip_token ();\n-\n       t = lexer.peek_token ();\n     }\n \n@@ -8982,7 +9002,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_expr (\n // Parses a type (will further disambiguate any type).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Type>\n-Parser<ManagedTokenSource>::parse_type ()\n+Parser<ManagedTokenSource>::parse_type (bool save_errors)\n {\n   /* rules for all types:\n    * NeverType:               '!'\n@@ -9034,9 +9054,12 @@ Parser<ManagedTokenSource>::parse_type ()\n \tAST::QualifiedPathInType path = parse_qualified_path_in_type ();\n \tif (path.is_error ())\n \t  {\n-\t    Error error (t->get_locus (),\n-\t\t\t \"failed to parse qualified path in type\");\n-\t    add_error (std::move (error));\n+\t    if (save_errors)\n+\t      {\n+\t\tError error (t->get_locus (),\n+\t\t\t     \"failed to parse qualified path in type\");\n+\t\tadd_error (std::move (error));\n+\t      }\n \n \t    return nullptr;\n \t  }\n@@ -9085,9 +9108,12 @@ Parser<ManagedTokenSource>::parse_type ()\n \tAST::TypePath path = parse_type_path ();\n \tif (path.is_error ())\n \t  {\n-\t    Error error (t->get_locus (),\n-\t\t\t \"failed to parse path as first component of type\");\n-\t    add_error (std::move (error));\n+\t    if (save_errors)\n+\t      {\n+\t\tError error (t->get_locus (),\n+\t\t\t     \"failed to parse path as first component of type\");\n+\t\tadd_error (std::move (error));\n+\t      }\n \n \t    return nullptr;\n \t  }\n@@ -9103,10 +9129,13 @@ Parser<ManagedTokenSource>::parse_type ()\n \t      AST::SimplePath macro_path = path.as_simple_path ();\n \t      if (macro_path.is_empty ())\n \t\t{\n-\t\t  Error error (t->get_locus (),\n-\t\t\t       \"failed to parse simple path in macro \"\n-\t\t\t       \"invocation (for type)\");\n-\t\t  add_error (std::move (error));\n+\t\t  if (save_errors)\n+\t\t    {\n+\t\t      Error error (t->get_locus (),\n+\t\t\t\t   \"failed to parse simple path in macro \"\n+\t\t\t\t   \"invocation (for type)\");\n+\t\t      add_error (std::move (error));\n+\t\t    }\n \n \t\t  return nullptr;\n \t\t}\n@@ -9190,9 +9219,12 @@ Parser<ManagedTokenSource>::parse_type ()\n \t  std::unique_ptr<AST::TraitBound> initial_bound = parse_trait_bound ();\n \t  if (initial_bound == nullptr)\n \t    {\n-\t      Error error (lexer.peek_token ()->get_locus (),\n-\t\t\t   \"failed to parse ImplTraitType initial bound\");\n-\t      add_error (std::move (error));\n+\t      if (save_errors)\n+\t\t{\n+\t\t  Error error (lexer.peek_token ()->get_locus (),\n+\t\t\t       \"failed to parse ImplTraitType initial bound\");\n+\t\t  add_error (std::move (error));\n+\t\t}\n \n \t      return nullptr;\n \t    }\n@@ -9265,9 +9297,13 @@ Parser<ManagedTokenSource>::parse_type ()\n \t      = parse_trait_bound ();\n \t    if (initial_bound == nullptr)\n \t      {\n-\t\tError error (lexer.peek_token ()->get_locus (),\n-\t\t\t     \"failed to parse TraitObjectType initial bound\");\n-\t\tadd_error (std::move (error));\n+\t\tif (save_errors)\n+\t\t  {\n+\t\t    Error error (\n+\t\t      lexer.peek_token ()->get_locus (),\n+\t\t      \"failed to parse TraitObjectType initial bound\");\n+\t\t    add_error (std::move (error));\n+\t\t  }\n \n \t\treturn nullptr;\n \t      }\n@@ -9313,8 +9349,9 @@ Parser<ManagedTokenSource>::parse_type ()\n \t  }\n       }\n     default:\n-      add_error (Error (t->get_locus (), \"unrecognised token %qs in type\",\n-\t\t\tt->get_token_description ()));\n+      if (save_errors)\n+\tadd_error (Error (t->get_locus (), \"unrecognised token %qs in type\",\n+\t\t\t  t->get_token_description ()));\n \n       return nullptr;\n     }"}, {"sha": "f0aedfe6a227b3a40803f2d36eb87bc05bc10a2d", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848a1a28b91d105ff4f21cc9993befbcecb3e39d/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848a1a28b91d105ff4f21cc9993befbcecb3e39d/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=848a1a28b91d105ff4f21cc9993befbcecb3e39d", "patch": "@@ -138,7 +138,7 @@ template <typename ManagedTokenSource> class Parser\n    */\n   std::unique_ptr<AST::Stmt> parse_stmt (ParseRestrictions restrictions\n \t\t\t\t\t = ParseRestrictions ());\n-  std::unique_ptr<AST::Type> parse_type ();\n+  std::unique_ptr<AST::Type> parse_type (bool save_errors = true);\n   std::unique_ptr<AST::ExternalItem> parse_external_item ();\n   std::unique_ptr<AST::TraitItem> parse_trait_item ();\n   std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item ();\n@@ -177,6 +177,7 @@ template <typename ManagedTokenSource> class Parser\n   AST::TypePath parse_type_path ();\n   std::unique_ptr<AST::TypePathSegment> parse_type_path_segment ();\n   AST::PathIdentSegment parse_path_ident_segment ();\n+  std::unique_ptr<AST::Expr> parse_const_generic_expression ();\n   AST::GenericArgs parse_path_generic_args ();\n   AST::GenericArgsBinding parse_generic_args_binding ();\n   AST::TypePathFunction parse_type_path_function (Location locus);"}, {"sha": "6a3a0fe27bf3ccdaed81abf8198bd7e7c57b4b62", "filename": "gcc/testsuite/rust/compile/const_generics_3.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848a1a28b91d105ff4f21cc9993befbcecb3e39d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848a1a28b91d105ff4f21cc9993befbcecb3e39d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_3.rs?ref=848a1a28b91d105ff4f21cc9993befbcecb3e39d", "patch": "@@ -0,0 +1,26 @@\n+// { dg-additional-options \"-w\" }\n+\n+const M: usize = 4;\n+\n+struct Foo<T, const N: usize = 1> {\n+    // FIXME: This error is bogus. But having it means parsing is valid!\n+    value: [i32; N], // { dg-error \"failed to find name: N\" }\n+}\n+\n+fn main() {\n+    let foo = Foo::<i32> { value: [15] };\n+    let foo = Foo::<i32, 2> { value: [15, 13] };\n+    let foo: Foo<i32, 2> = Foo { value: [15, 13] };\n+    let foo: Foo<i32, 2> = Foo::<i32, 2> { value: [15, 13] };\n+    let foo: Foo<i32, { 1 + 1 }> = Foo { value: [15, 13] };\n+    let foo = Foo::<i32, { 1 + 1 }> { value: [15, 13] };\n+    let foo: Foo<i32, { 1 + 1 }> = Foo::<i32, { 1 + 1 }> { value: [15, 13] };\n+    let foo: Foo<i32, M> = Foo::<i32, 4> {\n+        value: [15, 13, 11, 9],\n+    };\n+\n+    // FIXME: Add proper const typecheck errors here\n+    let invalid_foo: Foo<i32, { 1 + 1 }> = Foo::<i32, 3> { value: [15, 13] };\n+    let invalid_foo: Foo<i32, { 1 + 1 }> = Foo::<i32, M> { value: [15, 13] };\n+    let invalid_foo: Foo<i32> = Foo::<i32, 2> { value: [15, 13] };\n+}"}]}