{"sha": "14c35be3bf493859b92c3c6ca7893075212169ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRjMzViZTNiZjQ5Mzg1OWI5MmMzYzZjYTc4OTMwNzUyMTIxNjlhYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-31T12:24:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-31T13:19:00Z"}, "message": "Amend match.pd syntax with force-simplified results\n\nThis adds a ! marker to result expressions that should simplify\n(and if not fail the simplification).  This can for example be\nused like\n\n(simplify\n  (plus (vec_cond:s @0 @1 @2) @3)\n  (vec_cond @0 (plus! @1 @3) (plus! @2 @3)))\n\nto make the simplification only apply in case both plus operations\nin the result end up simplified to a simple operand.\n\n2020-07-31  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (expr::force_leaf): Add and initialize.\n\t(expr::gen_transform): Honor force_leaf by passing\n\tNULL as sequence argument to maybe_push_res_to_seq.\n\t(parser::parse_expr): Allow ! marker on result expression\n\toperations.\n\t* doc/match-and-simplify.texi: Amend.", "tree": {"sha": "e15ade239c1f5da5effb318309783e243ab67bf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e15ade239c1f5da5effb318309783e243ab67bf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14c35be3bf493859b92c3c6ca7893075212169ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14c35be3bf493859b92c3c6ca7893075212169ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14c35be3bf493859b92c3c6ca7893075212169ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14c35be3bf493859b92c3c6ca7893075212169ab/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c89366b12ff4f36253bae125b794cbe687f7e40b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c89366b12ff4f36253bae125b794cbe687f7e40b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c89366b12ff4f36253bae125b794cbe687f7e40b"}], "stats": {"total": 34, "additions": 31, "deletions": 3}, "files": [{"sha": "41980acbfe9f1f78bf23f6e0bbbae8637f6fb01b", "filename": "gcc/doc/match-and-simplify.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c35be3bf493859b92c3c6ca7893075212169ab/gcc%2Fdoc%2Fmatch-and-simplify.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c35be3bf493859b92c3c6ca7893075212169ab/gcc%2Fdoc%2Fmatch-and-simplify.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmatch-and-simplify.texi?ref=14c35be3bf493859b92c3c6ca7893075212169ab", "patch": "@@ -361,6 +361,21 @@ Usually the types of the generated result expressions are\n determined from the context, but sometimes like in the above case\n it is required that you specify them explicitely.\n \n+Another modifier for generated expressions is @code{!} which\n+tells the machinery to only consider the simplification in case\n+the marked expression simplified to a simple operand.  Consider\n+for example\n+\n+@smallexample\n+(simplify\n+  (plus (vec_cond:s @@0 @@1 @@2) @@3)\n+  (vec_cond @@0 (plus! @@1 @@3) (plus! @@2 @@3)))\n+@end smallexample\n+\n+which moves the outer @code{plus} operation to the inner arms\n+of the @code{vec_cond} expression but only if the actual plus\n+operations both simplify.\n+\n As intermediate conversions are often optional there is a way to\n avoid the need to repeat patterns both with and without such\n conversions.  Namely you can mark a conversion as being optional"}, {"sha": "88459d9686eec1136d353a5e17f4aa6a87d4cf46", "filename": "gcc/genmatch.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c35be3bf493859b92c3c6ca7893075212169ab/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c35be3bf493859b92c3c6ca7893075212169ab/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=14c35be3bf493859b92c3c6ca7893075212169ab", "patch": "@@ -697,12 +697,13 @@ class expr : public operand\n   expr (id_base *operation_, location_t loc, bool is_commutative_ = false)\n     : operand (OP_EXPR, loc), operation (operation_),\n       ops (vNULL), expr_type (NULL), is_commutative (is_commutative_),\n-      is_generic (false), force_single_use (false), opt_grp (0) {}\n+      is_generic (false), force_single_use (false), force_leaf (false),\n+      opt_grp (0) {}\n   expr (expr *e)\n     : operand (OP_EXPR, e->location), operation (e->operation),\n       ops (vNULL), expr_type (e->expr_type), is_commutative (e->is_commutative),\n       is_generic (e->is_generic), force_single_use (e->force_single_use),\n-      opt_grp (e->opt_grp) {}\n+      force_leaf (e->force_leaf), opt_grp (e->opt_grp) {}\n   void append_op (operand *op) { ops.safe_push (op); }\n   /* The operator and its operands.  */\n   id_base *operation;\n@@ -717,6 +718,9 @@ class expr : public operand\n   /* Whether pushing any stmt to the sequence should be conditional\n      on this expression having a single-use.  */\n   bool force_single_use;\n+  /* Whether in the result expression this should be a leaf node\n+     with any children simplified down to simple operands.  */\n+  bool force_leaf;\n   /* If non-zero, the group for optional handling.  */\n   unsigned char opt_grp;\n   virtual void gen_transform (FILE *f, int, const char *, bool, int,\n@@ -2520,7 +2524,8 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n       fprintf (f, \");\\n\");\n       fprintf_indent (f, indent, \"tem_op.resimplify (lseq, valueize);\\n\");\n       fprintf_indent (f, indent,\n-\t\t      \"_r%d = maybe_push_res_to_seq (&tem_op, lseq);\\n\", depth);\n+\t\t      \"_r%d = maybe_push_res_to_seq (&tem_op, %s);\\n\", depth,\n+\t\t      !force_leaf ? \"lseq\" : \"NULL\");\n       fprintf_indent (f, indent,\n \t\t      \"if (!_r%d) return false;\\n\",\n \t\t      depth);\n@@ -4240,6 +4245,14 @@ parser::parse_expr ()\n   bool force_capture = false;\n   const char *expr_type = NULL;\n \n+  if (!parsing_match_operand\n+      && token->type == CPP_NOT\n+      && !(token->flags & PREV_WHITE))\n+    {\n+      eat_token (CPP_NOT);\n+      e->force_leaf = true;\n+    }\n+\n   if (token->type == CPP_COLON\n       && !(token->flags & PREV_WHITE))\n     {"}]}