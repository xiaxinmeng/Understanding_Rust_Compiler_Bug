{"sha": "75c702541afe8c4bb21341be284d02c401782622", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVjNzAyNTQxYWZlOGM0YmIyMTM0MWJlMjg0ZDAyYzQwMTc4MjYyMg==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-06-02T10:19:12Z"}, "committer": {"name": "Mostafa Hagog", "email": "hagog@gcc.gnu.org", "date": "2005-06-02T10:19:12Z"}, "message": "> 2005-06-02 Steven Bosscher <stevenb@suse.de> > Mostafa Hagog...\n\n> 2005-06-02 Steven Bosscher  <stevenb@suse.de>\n>            Mostafa Hagog <mustafa@il.ibm.com>\n>\n>       * cfgloop.h (doloop_condition_get): Make external.\n>       * loop-doloop.c (doloop_condition_get): Generalize to make it\n>       usable in modulo-sched.c.\n>       * modulo-sched.c (doloop_register_get): Use\n>       doloop_condition_get instead of duplicating it.\n\nCo-Authored-By: Mostafa Hagog <mustafa@il.ibm.com>\n\nFrom-SVN: r100490", "tree": {"sha": "cf218e997d7d501add114f661a4a05f7f072e7c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf218e997d7d501add114f661a4a05f7f072e7c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75c702541afe8c4bb21341be284d02c401782622", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75c702541afe8c4bb21341be284d02c401782622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75c702541afe8c4bb21341be284d02c401782622", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75c702541afe8c4bb21341be284d02c401782622/comments", "author": null, "committer": null, "parents": [{"sha": "9267ee62db3b6b08f5b963a7b00e3489ed7bf237", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9267ee62db3b6b08f5b963a7b00e3489ed7bf237", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9267ee62db3b6b08f5b963a7b00e3489ed7bf237"}], "stats": {"total": 142, "additions": 61, "deletions": 81}, "files": [{"sha": "c6f287de86b7e31d90a880a7cd8f8c0b79ff5afe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75c702541afe8c4bb21341be284d02c401782622/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75c702541afe8c4bb21341be284d02c401782622/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75c702541afe8c4bb21341be284d02c401782622", "patch": "@@ -1,3 +1,12 @@\n+2005-06-02 Steven Bosscher  <stevenb@suse.de>\n+\t   Mostafa Hagog <mustafa@il.ibm.com>\n+\n+\t* cfgloop.h (doloop_condition_get): Make external.\n+\t* loop-doloop.c (doloop_condition_get): Generalize to make it\n+\tusable in modulo-sched.c.\n+\t* modulo-sched.c (doloop_register_get): Use\n+\tdoloop_condition_get instead of duplicating it.\n+\n 2005-06-02  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* reload1.c (reload): Undo 2005-04-20 change.  Make sure we detect"}, {"sha": "048802bb85a81c78d3300334c644dd8f55fdf0e2", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75c702541afe8c4bb21341be284d02c401782622/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75c702541afe8c4bb21341be284d02c401782622/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=75c702541afe8c4bb21341be284d02c401782622", "patch": "@@ -289,6 +289,7 @@ extern void verify_loop_structure (struct loops *);\n /* Loop analysis.  */\n extern bool just_once_each_iteration_p (const struct loop *, basic_block);\n extern unsigned expected_loop_iterations (const struct loop *);\n+extern rtx doloop_condition_get (rtx);\n \n /* Loop manipulation.  */\n extern bool can_duplicate_loop_p (struct loop *loop);"}, {"sha": "dd15aab919fcf7a40411a08ab2fc0894eaa5ae1e", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75c702541afe8c4bb21341be284d02c401782622/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75c702541afe8c4bb21341be284d02c401782622/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=75c702541afe8c4bb21341be284d02c401782622", "patch": "@@ -69,12 +69,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Return the loop termination condition for PATTERN or zero\n    if it is not a decrement and branch jump insn.  */\n \n-static rtx\n+rtx\n doloop_condition_get (rtx pattern)\n {\n   rtx cmp;\n   rtx inc;\n   rtx reg;\n+  rtx inc_src;\n   rtx condition;\n \n   /* The canonical doloop pattern we expect is:\n@@ -85,12 +86,13 @@ doloop_condition_get (rtx pattern)\n                 (set (reg) (plus (reg) (const_int -1)))\n                 (additional clobbers and uses)])\n \n-     Some machines (IA-64) make the decrement conditional on\n-     the condition as well, so we don't bother verifying the\n-     actual decrement.  In summary, the branch must be the\n-     first entry of the parallel (also required by jump.c),\n-     and the second entry of the parallel must be a set of\n-     the loop counter register.  */\n+     Some targets (IA-64) wrap the set of the loop counter in\n+     an if_then_else too.\n+\n+     In summary, the branch must be the first entry of the\n+     parallel (also required by jump.c), and the second\n+     entry of the parallel must be a set of the loop counter\n+     register.  */\n \n   if (GET_CODE (pattern) != PARALLEL)\n     return 0;\n@@ -99,11 +101,21 @@ doloop_condition_get (rtx pattern)\n   inc = XVECEXP (pattern, 0, 1);\n \n   /* Check for (set (reg) (something)).  */\n-  if (GET_CODE (inc) != SET || ! REG_P (SET_DEST (inc)))\n+  if (GET_CODE (inc) != SET)\n     return 0;\n-\n-  /* Extract loop counter register.  */\n   reg = SET_DEST (inc);\n+  if (! REG_P (reg))\n+    return 0;\n+\n+  /* Check if something = (plus (reg) (const_int -1)).\n+     On IA-64, this decrement is wrapped in an if_then_else.  */\n+  inc_src = SET_SRC (inc);\n+  if (GET_CODE (inc_src) == IF_THEN_ELSE)\n+    inc_src = XEXP (inc_src, 1);\n+  if (GET_CODE (inc_src) != PLUS\n+      || XEXP (inc_src, 0) != reg\n+      || XEXP (inc_src, 1) != constm1_rtx)\n+    return 0;\n \n   /* Check for (set (pc) (if_then_else (condition)\n                                        (label_ref (label))\n@@ -118,15 +130,16 @@ doloop_condition_get (rtx pattern)\n   /* Extract loop termination condition.  */\n   condition = XEXP (SET_SRC (cmp), 0);\n \n-  if ((GET_CODE (condition) != GE && GET_CODE (condition) != NE)\n-      || GET_CODE (XEXP (condition, 1)) != CONST_INT)\n+  /* We expect a GE or NE comparison with 0 or 1.  */\n+  if ((GET_CODE (condition) != GE\n+       && GET_CODE (condition) != NE)\n+      || (XEXP (condition, 1) != const0_rtx\n+          && XEXP (condition, 1) != const1_rtx))\n     return 0;\n \n-  if (XEXP (condition, 0) == reg)\n-    return condition;\n-\n-  if (GET_CODE (XEXP (condition, 0)) == PLUS\n-      && XEXP (XEXP (condition, 0), 0) == reg)\n+  if ((XEXP (condition, 0) == reg)\n+      || (GET_CODE (XEXP (condition, 0)) == PLUS\n+\t\t   && XEXP (XEXP (condition, 0), 0) == reg))\n     return condition;\n \n   /* ??? If a machine uses a funny comparison, we could return a"}, {"sha": "f42dd1b1308c77bf8a4b21ac8341eb8c2d963b4e", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 21, "deletions": 64, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75c702541afe8c4bb21341be284d02c401782622/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75c702541afe8c4bb21341be284d02c401782622/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=75c702541afe8c4bb21341be284d02c401782622", "patch": "@@ -269,74 +269,31 @@ static struct sched_info sms_sched_info =\n };\n \n \n-/* Return the register decremented and tested or zero if it is not a decrement\n-   and branch jump insn (similar to doloop_condition_get).  */\n+/* Return the register decremented and tested in INSN,\n+   or zero if it is not a decrement-and-branch insn.  */\n+\n static rtx\n-doloop_register_get (rtx insn, rtx *comp)\n+doloop_register_get (rtx insn)\n {\n-  rtx pattern, cmp, inc, reg, condition;\n-\n-  if (!JUMP_P (insn))\n-    return NULL_RTX;\n-  pattern = PATTERN (insn);\n-\n-  /* The canonical doloop pattern we expect is:\n-\n-     (parallel [(set (pc) (if_then_else (condition)\n-\t\t\t\t\t(label_ref (label))\n-\t\t\t\t\t(pc)))\n-\t\t(set (reg) (plus (reg) (const_int -1)))\n-\t\t(additional clobbers and uses)])\n-\n-    where condition is further restricted to be\n-      (ne (reg) (const_int 1)).  */\n-\n-  if (GET_CODE (pattern) != PARALLEL)\n-    return NULL_RTX;\n-\n-  cmp = XVECEXP (pattern, 0, 0);\n-  inc = XVECEXP (pattern, 0, 1);\n-  /* Return the compare rtx.  */\n-  *comp = cmp;\n+  rtx pattern, reg, condition;\n \n-  /* Check for (set (reg) (something)).  */\n-  if (GET_CODE (inc) != SET || ! REG_P (SET_DEST (inc)))\n+  if (! JUMP_P (insn))\n     return NULL_RTX;\n \n-  /* Extract loop counter register.  */\n-  reg = SET_DEST (inc);\n-\n-  /* Check if something = (plus (reg) (const_int -1)).  */\n-  if (GET_CODE (SET_SRC (inc)) != PLUS\n-      || XEXP (SET_SRC (inc), 0) != reg\n-      || XEXP (SET_SRC (inc), 1) != constm1_rtx)\n-    return NULL_RTX;\n-\n-  /* Check for (set (pc) (if_then_else (condition)\n-\t\t\t\t       (label_ref (label))\n-\t\t\t\t       (pc))).  */\n-  if (GET_CODE (cmp) != SET\n-      || SET_DEST (cmp) != pc_rtx\n-      || GET_CODE (SET_SRC (cmp)) != IF_THEN_ELSE\n-      || GET_CODE (XEXP (SET_SRC (cmp), 1)) != LABEL_REF\n-      || XEXP (SET_SRC (cmp), 2) != pc_rtx)\n-    return NULL_RTX;\n-\n-  /* Extract loop termination condition.  */\n-  condition = XEXP (SET_SRC (cmp), 0);\n-\n-  /* Check if condition = (ne (reg) (const_int 1)), which is more\n-     restrictive than the check in doloop_condition_get:\n-     if ((GET_CODE (condition) != GE && GET_CODE (condition) != NE)\n-\t || GET_CODE (XEXP (condition, 1)) != CONST_INT).  */\n-  if (GET_CODE (condition) != NE\n-      || XEXP (condition, 1) != const1_rtx)\n+  pattern = PATTERN (insn);\n+  condition = doloop_condition_get (pattern);\n+  if (! condition)\n     return NULL_RTX;\n \n-  if (XEXP (condition, 0) == reg)\n-    return reg;\n+  if (REG_P (XEXP (condition, 0)))\n+    reg = XEXP (condition, 0);\n+  else if (GET_CODE (XEXP (condition, 0)) == PLUS\n+\t   && REG_P (XEXP (XEXP (condition, 0), 0)))\n+    reg = XEXP (XEXP (condition, 0), 0);\n+  else\n+    gcc_unreachable ();\n \n-  return NULL_RTX;\n+  return reg;\n }\n \n /* Check if COUNT_REG is set to a constant in the PRE_HEADER block, so\n@@ -1025,7 +982,7 @@ sms_schedule (FILE *dump_file)\n   for (i = 0; i < loops->num; i++)\n     {\n       rtx head, tail;\n-      rtx count_reg, comp;\n+      rtx count_reg;\n       struct loop *loop = loops->parray[i];\n \n       /* For debugging.  */\n@@ -1088,7 +1045,7 @@ sms_schedule (FILE *dump_file)\n         }\n \n       /* Make sure this is a doloop.  */\n-      if ( !(count_reg = doloop_register_get (tail, &comp)))\n+      if ( !(count_reg = doloop_register_get (tail)))\n \tcontinue;\n \n       /* Don't handle BBs with calls or barriers, or !single_set insns.  */\n@@ -1134,7 +1091,7 @@ sms_schedule (FILE *dump_file)\n   for (i = 0; i < num_loops; i++)\n     {\n       rtx head, tail;\n-      rtx count_reg, count_init, comp;\n+      rtx count_reg, count_init;\n       int mii, rec_mii;\n       unsigned stage_count = 0;\n       HOST_WIDEST_INT loop_count = 0;\n@@ -1186,7 +1143,7 @@ sms_schedule (FILE *dump_file)\n       /* In case of th loop have doloop register it gets special\n \t handling.  */\n       count_init = NULL_RTX;\n-      if ((count_reg = doloop_register_get (tail, &comp)))\n+      if ((count_reg = doloop_register_get (tail)))\n \t{\n \t  basic_block pre_header;\n "}]}