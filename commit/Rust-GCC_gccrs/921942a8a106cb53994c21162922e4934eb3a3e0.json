{"sha": "921942a8a106cb53994c21162922e4934eb3a3e0", "node_id": "C_kwDOANBUbNoAKDkyMTk0MmE4YTEwNmNiNTM5OTRjMjExNjI5MjJlNDkzNGViM2EzZTA", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-10-03T18:46:09Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-12-17T16:56:53Z"}, "message": "coroutines: Pass lvalues to user-defined operator new [PR 100772].\n\nThe wording of the standard has been clarified to be explicit that\nthe the parameters to any user-defined operator-new in the promise\nclass should be lvalues.\n\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\n\tPR c++/100772\n\ngcc/cp/ChangeLog:\n\n\t* coroutines.cc (morph_fn_to_coro): Convert function parms\n\tfrom reference before constructing any operator-new args\n\tlist.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/coroutines/pr100772-a.C: New test.\n\t* g++.dg/coroutines/pr100772-b.C: New test.", "tree": {"sha": "81ba0d1396ae007d77c2af44f7afcd296f440852", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81ba0d1396ae007d77c2af44f7afcd296f440852"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/921942a8a106cb53994c21162922e4934eb3a3e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/921942a8a106cb53994c21162922e4934eb3a3e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/921942a8a106cb53994c21162922e4934eb3a3e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/921942a8a106cb53994c21162922e4934eb3a3e0/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39d2ec41509e3b0d130215a65d7aacbd064b5532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d2ec41509e3b0d130215a65d7aacbd064b5532", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39d2ec41509e3b0d130215a65d7aacbd064b5532"}], "stats": {"total": 178, "additions": 174, "deletions": 4}, "files": [{"sha": "bcc917397025df432e0681c17d5ea9de368cf1dc", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/921942a8a106cb53994c21162922e4934eb3a3e0/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/921942a8a106cb53994c21162922e4934eb3a3e0/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=921942a8a106cb53994c21162922e4934eb3a3e0", "patch": "@@ -4595,8 +4595,8 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \tIf the lookup finds an allocation function in the scope of the promise\n \ttype, overload resolution is performed on a function call created by\n \tassembling an argument list.  The first argument is the amount of space\n-\trequested, and has type std::size_t.  The succeeding arguments are\n-\tthose of the original function.  */\n+\trequested, and has type std::size_t.  The lvalues p1...pn are the\n+\tsucceeding arguments..  */\n       vec<tree, va_gc> *args = make_tree_vector ();\n       vec_safe_push (args, resizeable); /* Space needed.  */\n \n@@ -4614,10 +4614,10 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t      this_ref = convert_to_reference (tt, this_ref, CONV_STATIC,\n \t\t\t\t\t       LOOKUP_NORMAL , NULL_TREE,\n \t\t\t\t\t       tf_warning_or_error);\n-\t      vec_safe_push (args, this_ref);\n+\t      vec_safe_push (args, convert_from_reference (this_ref));\n \t    }\n \t  else\n-\t    vec_safe_push (args, arg);\n+\t    vec_safe_push (args, convert_from_reference (arg));\n \t}\n \n       /* Note the function selected; we test to see if it's NOTHROW.  */"}, {"sha": "a325d384fc390c2d213ddce3450a05d33536ded4", "filename": "gcc/testsuite/g++.dg/coroutines/pr100772-a.C", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/921942a8a106cb53994c21162922e4934eb3a3e0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr100772-a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/921942a8a106cb53994c21162922e4934eb3a3e0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr100772-a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr100772-a.C?ref=921942a8a106cb53994c21162922e4934eb3a3e0", "patch": "@@ -0,0 +1,77 @@\n+//  { dg-additional-options \"-fsyntax-only \" }\n+#ifdef __clang__\n+#include <experimental/coroutine>\n+namespace std {\n+  using namespace std::experimental;\n+}\n+#else\n+#include <coroutine>\n+#endif\n+\n+struct Task\n+{\n+    struct promise_type\n+    {        \n+\t\tvoid return_void() const noexcept {}\n+\n+\t\tvoid* operator new(std::size_t, auto &&...args) noexcept\n+\t\t{\n+            static_assert(sizeof...(args) > 0);\n+            static_assert(sizeof...(args) == 2);\n+\n+\t\t\treturn nullptr;\n+\t\t}\n+\n+\t\tvoid operator delete(void *, std::size_t) noexcept\n+\t\t{\n+\t\t}\n+\n+        static Task get_return_object_on_allocation_failure() noexcept\n+        {\n+            return {};\n+        }\n+\n+        Task get_return_object() noexcept\n+        {\n+            return Task{ *this };\n+        }\n+\n+        std::suspend_always initial_suspend() noexcept\n+        {\n+            return {};\n+        }\n+\n+        std::suspend_always final_suspend() noexcept\n+        {\n+            return {};\n+        }\n+\n+        void unhandled_exception() noexcept {}\n+    };\n+\n+    using promise_handle = std::coroutine_handle<promise_type>;\n+\n+    Task() = default;\n+    Task(promise_type & promise) noexcept\n+        : m_handle{ promise_handle::from_promise(promise) }\n+    {}\n+\n+    ~Task()\n+    {\n+        if (m_handle.address()) { m_handle.destroy(); }\n+    }\n+    \n+    promise_handle m_handle{};\n+};\n+\n+\n+Task Foo(auto && ... args) noexcept\n+{\n+    co_return;\n+}\n+\n+int main()\n+{\n+    int v;\n+    Foo(v, 2134);\n+}"}, {"sha": "6cdf8d1e529e5c7b22c4d157f1955ab06bf9eab3", "filename": "gcc/testsuite/g++.dg/coroutines/pr100772-b.C", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/921942a8a106cb53994c21162922e4934eb3a3e0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr100772-b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/921942a8a106cb53994c21162922e4934eb3a3e0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr100772-b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr100772-b.C?ref=921942a8a106cb53994c21162922e4934eb3a3e0", "patch": "@@ -0,0 +1,93 @@\n+#ifdef __clang__\n+#include <experimental/coroutine>\n+namespace std {\n+  using namespace std::experimental;\n+}\n+#else\n+#include <coroutine>\n+#endif\n+#include <cstdio>\n+#include <typeinfo>\n+#include <cxxabi.h>  // needed for abi::__cxa_demangle\n+#include <memory>\n+\n+std::shared_ptr<char> cppDemangle(const char *abiName)\n+{\n+  int status;    \n+  char *ret = abi::__cxa_demangle(abiName, 0, 0, &status);  \n+\n+  /* NOTE: must free() the returned char when done with it! */\n+  std::shared_ptr<char> retval;\n+  retval.reset( (char *)ret, [](char *mem) { if (mem) free((void*)mem); } );\n+  return retval;\n+}\n+\n+template <typename T>\n+struct Id{};\n+struct Task\n+{\n+  struct promise_type\n+  {        \n+    void return_void() const noexcept {}\n+\n+    static void is_int (std::string x) {\n+      if (x != \"Id<int>\")\n+\tabort() ;\n+    }\n+    template <typename ... Args>\n+    void* operator new(std::size_t len, Args ...args) noexcept\n+      {\n+\t(is_int (cppDemangle(typeid(Id<Args>).name()).get()), ...);\n+\t(std::puts (cppDemangle(typeid(Id<Args>).name()).get()), ...);\n+\treturn nullptr;\n+      }\n+\n+        static Task get_return_object_on_allocation_failure() noexcept\n+        {\n+            return {};\n+        }\n+\n+        Task get_return_object() noexcept\n+        {\n+            return Task{ *this };\n+        }\n+\n+        std::suspend_always initial_suspend() noexcept\n+        {\n+            return {};\n+        }\n+\n+        std::suspend_always final_suspend() noexcept\n+        {\n+            return {};\n+        }\n+\n+        void unhandled_exception() noexcept {}\n+    };\n+\n+    using promise_handle = std::coroutine_handle<promise_type>;\n+\n+    Task() = default;\n+    Task(promise_type & promise) noexcept\n+        : m_handle{ promise_handle::from_promise(promise) }\n+    {}\n+\n+    ~Task()\n+    {\n+        if (m_handle.address()) { m_handle.destroy(); }\n+    }\n+    \n+    promise_handle m_handle{};\n+};\n+\n+\n+Task Foo(auto && ... args) noexcept\n+{\n+    co_return;\n+}\n+\n+int main()\n+{\n+    int v;\n+    Foo(v, 2134);\n+}"}]}