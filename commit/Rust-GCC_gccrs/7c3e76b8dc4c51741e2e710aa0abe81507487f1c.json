{"sha": "7c3e76b8dc4c51741e2e710aa0abe81507487f1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MzZTc2YjhkYzRjNTE3NDFlMmU3MTBhYTBhYmU4MTUwNzQ4N2YxYw==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2020-03-23T23:20:17Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-12T08:29:28Z"}, "message": "[Ada] Implement AI12-0369\n\n2020-06-12  Steve Baird  <baird@adacore.com>\n\ngcc/ada/\n\n\t* sem_util.ads, sem_util.adb: Define 3 new Boolean-valued\n\tfunctions - Statically_Denotes_Entity,\n\tStatically_Denotes_Object, and Statically_Names_Object. The\n\tfirst two were taken from sem_attr.adb. The term \"statically\n\tnames\" is defined in the Ada RM and the new function\n\tStatically_Names_Object is intended to reflect that definition,\n\tor more precisely, as described in a comment in the code, to\n\treflect the expected future definition of that term.\n\t* sem_attr.adb: Delete functions Statically_Denotes_Object and\n\tStatically_Denotes_Entity; these two functions have been moved\n\tto package Sem_Util. Replace call to Statically_Denotes_Object\n\twith a call to Statically_Names_Object as per AI12-0217 (a\n\tbinding interpretation, so no Ada_Version check).\n\t* exp_ch9.adb (Expand_Entry_Barrier.Is_Simple_Barrier): Change\n\tname of function (it was previously Is_Simple_Barrier_Name)\n\tbecause the function should return True in the case of a static\n\texpression; implement this requirement.  Change function to\n\tinclude a call to Statically_Names_Object so that, for Ada_2020\n\tand later, it will return True for appropriate subcomponent\n\tnames.\n\t(Expand_Entry_Barrier.Is_Pure_Barrier): Handle\n\tN_Indexed_Component and N_Selected_Component cases by calling\n\tStatically_Names_Object.\n\t(Expand_Entry_Barrier): Reorganize to treat Simple_Barriers and\n\tPure_Barriers more uniformly.  Prevent cascaded errors.", "tree": {"sha": "38b24616beb1d96d5f5c1f124ffd82e4f8274b1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38b24616beb1d96d5f5c1f124ffd82e4f8274b1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c3e76b8dc4c51741e2e710aa0abe81507487f1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c3e76b8dc4c51741e2e710aa0abe81507487f1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c3e76b8dc4c51741e2e710aa0abe81507487f1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c3e76b8dc4c51741e2e710aa0abe81507487f1c/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "834bb57ac5a28e740b8f6e55059a102b99380176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/834bb57ac5a28e740b8f6e55059a102b99380176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/834bb57ac5a28e740b8f6e55059a102b99380176"}], "stats": {"total": 332, "additions": 205, "deletions": 127}, "files": [{"sha": "5162118e46cc45bef484881d93c60f91938374e9", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 56, "deletions": 40, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3e76b8dc4c51741e2e710aa0abe81507487f1c/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3e76b8dc4c51741e2e710aa0abe81507487f1c/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=7c3e76b8dc4c51741e2e710aa0abe81507487f1c", "patch": "@@ -5961,12 +5961,12 @@ package body Exp_Ch9 is\n       --  If so, barrier may not be properly synchronized.\n \n       function Is_Pure_Barrier (N : Node_Id) return Traverse_Result;\n-      --  Check whether N follows the Pure_Barriers restriction. Return OK if\n+      --  Check whether N meets the Pure_Barriers restriction. Return OK if\n       --  so.\n \n-      function Is_Simple_Barrier_Name (N : Node_Id) return Boolean;\n-      --  Check whether entity name N denotes a component of the protected\n-      --  object. This is used to check the Simple_Barrier restriction.\n+      function Is_Simple_Barrier (N : Node_Id) return Boolean;\n+      --  Check whether N meets the Simple_Barriers restriction. Return OK if\n+      --  so.\n \n       ----------------------\n       -- Is_Global_Entity --\n@@ -6018,14 +6018,25 @@ package body Exp_Ch9 is\n       procedure Check_Unprotected_Barrier is\n         new Traverse_Proc (Is_Global_Entity);\n \n-      ----------------------------\n-      -- Is_Simple_Barrier_Name --\n-      ----------------------------\n+      -----------------------\n+      -- Is_Simple_Barrier --\n+      -----------------------\n \n-      function Is_Simple_Barrier_Name (N : Node_Id) return Boolean is\n+      function Is_Simple_Barrier (N : Node_Id) return Boolean is\n          Renamed : Node_Id;\n \n       begin\n+         if Is_Static_Expression (N) then\n+            return True;\n+         elsif Ada_Version >= Ada_2020\n+           and then Nkind_In (N, N_Selected_Component, N_Indexed_Component)\n+           and then Statically_Names_Object (N)\n+         then\n+            --  Restriction relaxed in Ada2020 to allow statically named\n+            --  subcomponents.\n+            return Is_Simple_Barrier (Prefix (N));\n+         end if;\n+\n          --  Check if the name is a component of the protected object. If\n          --  the expander is active, the component has been transformed into a\n          --  renaming of _object.all.component. Original_Node is needed in case\n@@ -6048,10 +6059,12 @@ package body Exp_Ch9 is\n               Present (Renamed)\n                 and then Nkind (Renamed) = N_Selected_Component\n                 and then Chars (Prefix (Prefix (Renamed))) = Name_uObject;\n+         elsif not Is_Entity_Name (N) then\n+            return False;\n          else\n             return Is_Protected_Component (Entity (N));\n          end if;\n-      end Is_Simple_Barrier_Name;\n+      end Is_Simple_Barrier;\n \n       ---------------------\n       -- Is_Pure_Barrier --\n@@ -6092,7 +6105,7 @@ package body Exp_Ch9 is\n                      return Skip;\n \n                   when E_Variable =>\n-                     if Is_Simple_Barrier_Name (N) then\n+                     if Is_Simple_Barrier (N) then\n                         return Skip;\n                      end if;\n \n@@ -6137,6 +6150,13 @@ package body Exp_Ch9 is\n             =>\n                return OK;\n \n+            when N_Indexed_Component | N_Selected_Component =>\n+               if Statically_Names_Object (N) then\n+                  return Is_Pure_Barrier (Prefix (N));\n+               else\n+                  return Abandon;\n+               end if;\n+\n             when N_Case_Expression_Alternative =>\n                --  do not traverse Discrete_Choices subtree\n                if Is_Pure_Barrier (Expression (N)) /= Abandon then\n@@ -6195,6 +6215,12 @@ package body Exp_Ch9 is\n          return;\n       end if;\n \n+      --  Prevent cascaded errors\n+\n+      if Nkind (Cond) = N_Error then\n+         return;\n+      end if;\n+\n       --  The body of the entry barrier must be analyzed in the context of the\n       --  protected object, but its scope is external to it, just as any other\n       --  unprotected version of a protected operation. The specification has\n@@ -6224,22 +6250,25 @@ package body Exp_Ch9 is\n          Analyze_And_Resolve (Cond, Any_Boolean);\n       end if;\n \n-      --  Check Pure_Barriers restriction\n+      --  Check Simple_Barriers and Pure_Barriers restrictions.\n+      --  Note that it is safe to be calling Check_Restriction from here, even\n+      --  though this is part of the expander, since Expand_Entry_Barrier is\n+      --  called from Sem_Ch9 even in -gnatc mode.\n \n-      if Check_Pure_Barriers (Cond) = Abandon then\n-         Check_Restriction (Pure_Barriers, Cond);\n+      if not Is_Simple_Barrier (Cond) then\n+         --  flag restriction violation\n+         Check_Restriction (Simple_Barriers, Cond);\n       end if;\n \n-      --  The Ravenscar profile restricts barriers to simple variables declared\n-      --  within the protected object. We also allow Boolean constants, since\n-      --  these appear in several published examples and are also allowed by\n-      --  other compilers.\n+      if Check_Pure_Barriers (Cond) = Abandon then\n+         --  flag restriction violation\n+         Check_Restriction (Pure_Barriers, Cond);\n \n-      --  Note that after analysis variables in this context will be replaced\n-      --  by the corresponding prival, that is to say a renaming of a selected\n-      --  component of the form _Object.Var. If expansion is disabled, as\n-      --  within a generic, we check that the entity appears in the current\n-      --  scope.\n+         --  Emit warning if barrier contains global entities and is thus\n+         --  potentially unsynchronized (if Pure_Barriers restrictions\n+         --  are met then no need to check for this).\n+         Check_Unprotected_Barrier (Cond);\n+      end if;\n \n       if Is_Entity_Name (Cond) then\n          Cond_Id := Entity (Cond);\n@@ -6260,25 +6289,12 @@ package body Exp_Ch9 is\n             Set_Declarations (Func_Body, Empty_List);\n          end if;\n \n-         if Cond_Id = Standard_False or else Cond_Id = Standard_True then\n-            return;\n-\n-         elsif Is_Simple_Barrier_Name (Cond) then\n-            return;\n-         end if;\n+         --  Note that after analysis variables in this context will be\n+         --  replaced by the corresponding prival, that is to say a renaming\n+         --  of a selected component of the form _Object.Var. If expansion is\n+         --  disabled, as within a generic, we check that the entity appears in\n+         --  the current scope.\n       end if;\n-\n-      --  It is not a boolean variable or literal, so check the restriction.\n-      --  Note that it is safe to be calling Check_Restriction from here, even\n-      --  though this is part of the expander, since Expand_Entry_Barrier is\n-      --  called from Sem_Ch9 even in -gnatc mode.\n-\n-      Check_Restriction (Simple_Barriers, Cond);\n-\n-      --  Emit warning if barrier contains global entities and is thus\n-      --  potentially unsynchronized.\n-\n-      Check_Unprotected_Barrier (Cond);\n    end Expand_Entry_Barrier;\n \n    ------------------------------"}, {"sha": "86772d64a06ab85e7188b091c20fca9d5e6b6fd6", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 2, "deletions": 87, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3e76b8dc4c51741e2e710aa0abe81507487f1c/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3e76b8dc4c51741e2e710aa0abe81507487f1c/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=7c3e76b8dc4c51741e2e710aa0abe81507487f1c", "patch": "@@ -220,15 +220,6 @@ package body Sem_Attr is\n    --  Standard_True, depending on the value of the parameter B. The\n    --  result is marked as a static expression.\n \n-   function Statically_Denotes_Object (N : Node_Id) return Boolean;\n-   --  Predicate used to check the legality of the prefix to 'Loop_Entry and\n-   --  'Old, when the prefix is not an entity name. Current RM specfies that\n-   --  the prefix must be a direct or expanded name, but it has been proposed\n-   --  that the prefix be allowed to be a selected component that does not\n-   --  depend on a discriminant, or an indexed component with static indices.\n-   --  Current code for this predicate implements this more permissive\n-   --  implementation.\n-\n    -----------------------\n    -- Analyze_Attribute --\n    -----------------------\n@@ -2790,7 +2781,7 @@ package body Sem_Attr is\n             when 'E' =>\n                Error_Attr_P\n                  (\"prefix of attribute % that is potentially \"\n-                  & \"unevaluated must denote an entity\");\n+                  & \"unevaluated must statically name an entity\");\n \n             when 'W' =>\n                Error_Msg_Name_1 := Aname;\n@@ -5056,7 +5047,7 @@ package body Sem_Attr is\n             --  is potentially unevaluated (6.1.1 (27/3)).\n \n             if Is_Potentially_Unevaluated (N)\n-              and then not Statically_Denotes_Object (P)\n+              and then not Statically_Names_Object (P)\n             then\n                Uneval_Old_Msg;\n \n@@ -7324,10 +7315,6 @@ package body Sem_Attr is\n       --  Static is reset to False if the type or index type is not statically\n       --  constrained.\n \n-      function Statically_Denotes_Entity (N : Node_Id) return Boolean;\n-      --  Verify that the prefix of a potentially static array attribute\n-      --  satisfies the conditions of 4.9 (14).\n-\n       -----------------------------------\n       -- Check_Concurrent_Discriminant --\n       -----------------------------------\n@@ -7604,25 +7591,6 @@ package body Sem_Attr is\n          end if;\n       end Set_Bounds;\n \n-      -------------------------------\n-      -- Statically_Denotes_Entity --\n-      -------------------------------\n-\n-      function Statically_Denotes_Entity (N : Node_Id) return Boolean is\n-         E : Entity_Id;\n-\n-      begin\n-         if not Is_Entity_Name (N) then\n-            return False;\n-         else\n-            E := Entity (N);\n-         end if;\n-\n-         return\n-           Nkind (Parent (E)) /= N_Object_Renaming_Declaration\n-             or else Statically_Denotes_Entity (Renamed_Object (E));\n-      end Statically_Denotes_Entity;\n-\n    --  Start of processing for Eval_Attribute\n \n    begin\n@@ -12066,59 +12034,6 @@ package body Sem_Attr is\n       end if;\n    end Set_Boolean_Result;\n \n-   -------------------------------\n-   -- Statically_Denotes_Object --\n-   -------------------------------\n-\n-   function Statically_Denotes_Object (N : Node_Id) return Boolean is\n-      Indx : Node_Id;\n-\n-   begin\n-      if Is_Entity_Name (N) then\n-         return True;\n-\n-      elsif Nkind (N) = N_Selected_Component\n-        and then Statically_Denotes_Object (Prefix (N))\n-        and then Present (Entity (Selector_Name (N)))\n-      then\n-         declare\n-            Sel_Id    : constant Entity_Id := Entity (Selector_Name (N));\n-            Comp_Decl : constant Node_Id   := Parent (Sel_Id);\n-\n-         begin\n-            if Depends_On_Discriminant (Sel_Id) then\n-               return False;\n-\n-            elsif Nkind (Parent (Parent (Comp_Decl))) = N_Variant then\n-               return False;\n-\n-            else\n-               return True;\n-            end if;\n-         end;\n-\n-      elsif Nkind (N) = N_Indexed_Component\n-        and then Statically_Denotes_Object (Prefix (N))\n-        and then Is_Constrained (Etype (Prefix (N)))\n-      then\n-         Indx := First (Expressions (N));\n-         while Present (Indx) loop\n-            if not Compile_Time_Known_Value (Indx)\n-              or else Do_Range_Check (Indx)\n-            then\n-               return False;\n-            end if;\n-\n-            Next (Indx);\n-         end loop;\n-\n-         return True;\n-\n-      else\n-         return False;\n-      end if;\n-   end Statically_Denotes_Object;\n-\n    --------------------------------\n    -- Stream_Attribute_Available --\n    --------------------------------"}, {"sha": "76afdb01577b681189f920bc2e74dc52c74e1a3e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3e76b8dc4c51741e2e710aa0abe81507487f1c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3e76b8dc4c51741e2e710aa0abe81507487f1c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7c3e76b8dc4c51741e2e710aa0abe81507487f1c", "patch": "@@ -26439,6 +26439,34 @@ package body Sem_Util is\n       end if;\n    end Static_Integer;\n \n+   -------------------------------\n+   -- Statically_Denotes_Entity --\n+   -------------------------------\n+   function Statically_Denotes_Entity (N : Node_Id) return Boolean is\n+      E : Entity_Id;\n+   begin\n+      if not Is_Entity_Name (N) then\n+         return False;\n+      else\n+         E := Entity (N);\n+      end if;\n+\n+      return\n+        Nkind (Parent (E)) /= N_Object_Renaming_Declaration\n+          or else Is_Prival (E)\n+          or else Statically_Denotes_Entity (Renamed_Object (E));\n+   end Statically_Denotes_Entity;\n+\n+   -------------------------------\n+   -- Statically_Denotes_Object --\n+   -------------------------------\n+\n+   function Statically_Denotes_Object (N : Node_Id) return Boolean is\n+   begin\n+      return Statically_Denotes_Entity (N)\n+         and then Is_Object_Reference (N);\n+   end Statically_Denotes_Object;\n+\n    --------------------------\n    -- Statically_Different --\n    --------------------------\n@@ -26454,6 +26482,116 @@ package body Sem_Util is\n         and then not Is_Formal (Entity (R2));\n    end Statically_Different;\n \n+   -----------------------------\n+   -- Statically_Names_Object --\n+   -----------------------------\n+   function Statically_Names_Object (N : Node_Id) return Boolean is\n+   begin\n+      if Statically_Denotes_Object (N) then\n+         return True;\n+      elsif Is_Entity_Name (N) then\n+         declare\n+            E : constant Entity_Id := Entity (N);\n+         begin\n+            return Nkind (Parent (E)) = N_Object_Renaming_Declaration\n+              and then Statically_Names_Object (Renamed_Object (E));\n+         end;\n+      end if;\n+\n+      case Nkind (N) is\n+         when N_Indexed_Component =>\n+            if Is_Access_Type (Etype (Prefix (N))) then\n+               --  treat implicit dereference same as explicit\n+               return False;\n+            end if;\n+\n+            if not Is_Constrained (Etype (Prefix (N))) then\n+               return False;\n+            end if;\n+\n+            declare\n+               Indx : Node_Id := First_Index (Etype (Prefix (N)));\n+               Expr : Node_Id := First (Expressions (N));\n+               Index_Subtype : Node_Id;\n+            begin\n+               loop\n+                  Index_Subtype := Etype (Indx);\n+\n+                  if not Is_Static_Subtype (Index_Subtype) then\n+                     return False;\n+                  end if;\n+                  if not Is_OK_Static_Expression (Expr) then\n+                     return False;\n+                  end if;\n+\n+                  declare\n+                     Index_Value : constant Uint := Expr_Value (Expr);\n+                     Low_Value   : constant Uint :=\n+                       Expr_Value (Type_Low_Bound (Index_Subtype));\n+                     High_Value   : constant Uint :=\n+                       Expr_Value (Type_High_Bound (Index_Subtype));\n+                  begin\n+                     if (Index_Value < Low_Value)\n+                       or (Index_Value > High_Value)\n+                     then\n+                        return False;\n+                     end if;\n+                  end;\n+\n+                  Next_Index (Indx);\n+                  Expr := Next (Expr);\n+                  pragma Assert ((Present (Indx) = Present (Expr))\n+                    or else (Serious_Errors_Detected > 0));\n+                  exit when not (Present (Indx) and Present (Expr));\n+               end loop;\n+            end;\n+\n+         when N_Selected_Component =>\n+            if Is_Access_Type (Etype (Prefix (N))) then\n+               --  treat implicit dereference same as explicit\n+               return False;\n+            end if;\n+\n+            if not Ekind_In (Entity (Selector_Name (N)), E_Component,\n+                                                         E_Discriminant)\n+            then\n+               return False;\n+            end if;\n+            declare\n+               Comp : constant Entity_Id :=\n+                 Original_Record_Component (Entity (Selector_Name (N)));\n+            begin\n+              --  In not calling Has_Discriminant_Dependent_Constraint here,\n+              --  we are anticipating a language definition fixup. The\n+              --  current definition of \"statically names\" includes the\n+              --  wording \"the selector_name names a component that does\n+              --  not depend on a discriminant\", which suggests that this\n+              --  call should not be commented out. But it appears likely\n+              --  that this wording will be updated to only apply to a\n+              --  component declared in a variant part. There is no need\n+              --  to disallow something like\n+              --    with Post => ... and then\n+              --       Some_Record.Some_Discrim_Dep_Array_Component'Old (I)\n+              --  since the evaluation of the 'Old prefix cannot raise an\n+              --  exception. If the language is not updated, then the call\n+              --  below to H_D_C_C will need to be uncommented.\n+\n+               if Is_Declared_Within_Variant (Comp)\n+                  --  or else Has_Discriminant_Dependent_Constraint (Comp)\n+               then\n+                  return False;\n+               end if;\n+            end;\n+\n+         when others => -- includes N_Slice, N_Explicit_Dereference\n+            return False;\n+      end case;\n+\n+      pragma Assert (Present (Prefix (N)));\n+\n+      return Statically_Names_Object (Prefix (N));\n+   end Statically_Names_Object;\n+\n    --------------------------------------\n    -- Subject_To_Loop_Entry_Attributes --\n    --------------------------------------"}, {"sha": "c096170ed89e95db7f75d2484d161b484b12b4a5", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3e76b8dc4c51741e2e710aa0abe81507487f1c/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3e76b8dc4c51741e2e710aa0abe81507487f1c/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=7c3e76b8dc4c51741e2e710aa0abe81507487f1c", "patch": "@@ -2909,10 +2909,19 @@ package Sem_Util is\n    --  universal expression is returned, otherwise an error message is output\n    --  and a value of No_Uint is returned.\n \n+   function Statically_Denotes_Entity (N : Node_Id) return Boolean;\n+   --  Return True iff N is a name that \"statically denotes\" an entity.\n+\n+   function Statically_Denotes_Object (N : Node_Id) return Boolean;\n+   --  Return True iff N is a name that \"statically denotes\" an object.\n+\n    function Statically_Different (E1, E2 : Node_Id) return Boolean;\n    --  Return True if it can be statically determined that the Expressions\n    --  E1 and E2 refer to different objects\n \n+   function Statically_Names_Object (N : Node_Id) return Boolean;\n+   --  Return True iff N is a name that \"statically names\" an object.\n+\n    function Subject_To_Loop_Entry_Attributes (N : Node_Id) return Boolean;\n    --  Determine whether node N is a loop statement subject to at least one\n    --  'Loop_Entry attribute."}]}