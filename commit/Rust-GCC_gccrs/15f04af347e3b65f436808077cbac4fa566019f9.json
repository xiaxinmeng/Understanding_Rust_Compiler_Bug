{"sha": "15f04af347e3b65f436808077cbac4fa566019f9", "node_id": "C_kwDOANBUbNoAKDE1ZjA0YWYzNDdlM2I2NWY0MzY4MDgwNzdjYmFjNGZhNTY2MDE5Zjk", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-21T12:01:04Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:07Z"}, "message": "gccrs: Add base for HIR to GCC GENERIC lowering\n\nThis pass walks the HIR crate and turns them into GCC `tree`s. We do not have\nany Rust specific tree's. We are slowly removing the backend abstraction\nwhich was ported over from gccgo in favour of using `tree`s directly.\n\n\tgcc/rust/\n\t* backend/rust-builtins.h: New.\n\t* backend/rust-compile-base.cc: New.\n\t* backend/rust-compile-base.h: New.\n\t* backend/rust-mangle.cc: New.\n\t* backend/rust-mangle.h: New.\n\t* backend/rust-tree.cc: New.\n\t* backend/rust-tree.h: New.\n\t* rust-backend.h: New.\n\t* rust-gcc.cc: New.\n\nCo-authored-by: David Faust <david.faust@oracle.com>", "tree": {"sha": "32ec5a4c2ca65044848cb37137c1074ed63f5401", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32ec5a4c2ca65044848cb37137c1074ed63f5401"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15f04af347e3b65f436808077cbac4fa566019f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f04af347e3b65f436808077cbac4fa566019f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15f04af347e3b65f436808077cbac4fa566019f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f04af347e3b65f436808077cbac4fa566019f9/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6"}], "stats": {"total": 6114, "additions": 6114, "deletions": 0}, "files": [{"sha": "2bfa6c6cdf79000c35269591a471aae59c57a4b6", "filename": "gcc/rust/backend/rust-builtins.h", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-builtins.h?ref=15f04af347e3b65f436808077cbac4fa566019f9", "patch": "@@ -0,0 +1,189 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_BUILTINS_H\n+#define RUST_BUILTINS_H\n+\n+#include \"rust-system.h\"\n+#include \"tree.h\"\n+#include \"langhooks.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+// https://github.com/rust-lang/rust/blob/master/library/core/src/intrinsics.rs\n+// https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/intrinsic.rs\n+// https://github.com/Rust-GCC/gccrs/issues/658\n+//\n+//   let llvm_name = match name {\n+//     sym::sqrtf32 => \"llvm.sqrt.f32\",\n+//     sym::sqrtf64 => \"llvm.sqrt.f64\",\n+//     sym::powif32 => \"llvm.powi.f32\",\n+//     sym::powif64 => \"llvm.powi.f64\",\n+//     sym::sinf32 => \"llvm.sin.f32\",\n+//     sym::sinf64 => \"llvm.sin.f64\",\n+//     sym::cosf32 => \"llvm.cos.f32\",\n+//     sym::cosf64 => \"llvm.cos.f64\",\n+//     sym::powf32 => \"llvm.pow.f32\",\n+//     sym::powf64 => \"llvm.pow.f64\",\n+//     sym::expf32 => \"llvm.exp.f32\",\n+//     sym::expf64 => \"llvm.exp.f64\",\n+//     sym::exp2f32 => \"llvm.exp2.f32\",\n+//     sym::exp2f64 => \"llvm.exp2.f64\",\n+//     sym::logf32 => \"llvm.log.f32\",\n+//     sym::logf64 => \"llvm.log.f64\",\n+//     sym::log10f32 => \"llvm.log10.f32\",\n+//     sym::log10f64 => \"llvm.log10.f64\",\n+//     sym::log2f32 => \"llvm.log2.f32\",\n+//     sym::log2f64 => \"llvm.log2.f64\",\n+//     sym::fmaf32 => \"llvm.fma.f32\",\n+//     sym::fmaf64 => \"llvm.fma.f64\",\n+//     sym::fabsf32 => \"llvm.fabs.f32\",\n+//     sym::fabsf64 => \"llvm.fabs.f64\",\n+//     sym::minnumf32 => \"llvm.minnum.f32\",\n+//     sym::minnumf64 => \"llvm.minnum.f64\",\n+//     sym::maxnumf32 => \"llvm.maxnum.f32\",\n+//     sym::maxnumf64 => \"llvm.maxnum.f64\",\n+//     sym::copysignf32 => \"llvm.copysign.f32\",\n+//     sym::copysignf64 => \"llvm.copysign.f64\",\n+//     sym::floorf32 => \"llvm.floor.f32\",\n+//     sym::floorf64 => \"llvm.floor.f64\",\n+//     sym::ceilf32 => \"llvm.ceil.f32\",\n+//     sym::ceilf64 => \"llvm.ceil.f64\",\n+//     sym::truncf32 => \"llvm.trunc.f32\",\n+//     sym::truncf64 => \"llvm.trunc.f64\",\n+//     sym::rintf32 => \"llvm.rint.f32\",\n+//     sym::rintf64 => \"llvm.rint.f64\",\n+//     sym::nearbyintf32 => \"llvm.nearbyint.f32\",\n+//     sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n+//     sym::roundf32 => \"llvm.round.f32\",\n+//     sym::roundf64 => \"llvm.round.f64\",\n+//     _ => return None,\n+// };\n+// Some(cx.get_intrinsic(&llvm_name))\n+class BuiltinsContext\n+{\n+public:\n+  static BuiltinsContext &get ()\n+  {\n+    static BuiltinsContext instance;\n+    return instance;\n+  }\n+\n+  bool lookup_simple_builtin (const std::string &name, tree *builtin)\n+  {\n+    auto it = rust_intrinsic_to_gcc_builtin.find (name);\n+    if (it == rust_intrinsic_to_gcc_builtin.end ())\n+      return false;\n+\n+    return lookup_gcc_builtin (it->second, builtin);\n+  }\n+\n+private:\n+  static const int builtin_const = 1 << 0;\n+  static const int builtin_noreturn = 1 << 1;\n+  static const int builtin_novops = 1 << 2;\n+\n+  BuiltinsContext () { setup (); }\n+\n+  void setup ()\n+  {\n+    tree math_function_type_f32\n+      = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n+\n+    define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n+\t\t    math_function_type_f32, builtin_const);\n+\n+    define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n+\t\t    math_function_type_f32, builtin_const);\n+\n+    define_builtin (\"unreachable\", BUILT_IN_UNREACHABLE,\n+\t\t    \"__builtin_unreachable\", NULL,\n+\t\t    build_function_type (void_type_node, void_list_node),\n+\t\t    builtin_const | builtin_noreturn);\n+\n+    define_builtin (\"abort\", BUILT_IN_ABORT, \"__builtin_abort\", \"abort\",\n+\t\t    build_function_type (void_type_node, void_list_node),\n+\t\t    builtin_const | builtin_noreturn);\n+\n+    define_builtin (\"breakpoint\", BUILT_IN_TRAP, \"__builtin_trap\", \"breakpoint\",\n+\t\t    build_function_type (void_type_node, void_list_node),\n+\t\t    builtin_const | builtin_noreturn);\n+\n+    define_builtin (\n+      \"memcpy\", BUILT_IN_MEMCPY, \"__builtin_memcpy\", \"memcpy\",\n+      build_function_type_list (build_pointer_type (void_type_node),\n+\t\t\t\tbuild_pointer_type (void_type_node),\n+\t\t\t\tbuild_pointer_type (void_type_node),\n+\t\t\t\tsize_type_node, NULL_TREE),\n+      0);\n+  }\n+\n+  // Define a builtin function.  BCODE is the builtin function code\n+  // defined by builtins.def.  NAME is the name of the builtin function.\n+  // LIBNAME is the name of the corresponding library function, and is\n+  // NULL if there isn't one.  FNTYPE is the type of the function.\n+  // CONST_P is true if the function has the const attribute.\n+  // NORETURN_P is true if the function has the noreturn attribute.\n+  void define_builtin (const std::string rust_name, built_in_function bcode,\n+\t\t       const char *name, const char *libname, tree fntype,\n+\t\t       int flags)\n+  {\n+    tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t      libname, NULL_TREE);\n+    if ((flags & builtin_const) != 0)\n+      TREE_READONLY (decl) = 1;\n+    if ((flags & builtin_noreturn) != 0)\n+      TREE_THIS_VOLATILE (decl) = 1;\n+    if ((flags & builtin_novops) != 0)\n+      DECL_IS_NOVOPS (decl) = 1;\n+    set_builtin_decl (bcode, decl, true);\n+    this->builtin_functions_[name] = decl;\n+    if (libname != NULL)\n+      {\n+\tdecl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t     NULL, NULL_TREE);\n+\tif ((flags & builtin_const) != 0)\n+\t  TREE_READONLY (decl) = 1;\n+\tif ((flags & builtin_noreturn) != 0)\n+\t  TREE_THIS_VOLATILE (decl) = 1;\n+\tif ((flags & builtin_novops) != 0)\n+\t  DECL_IS_NOVOPS (decl) = 1;\n+\tthis->builtin_functions_[libname] = decl;\n+      }\n+\n+    rust_intrinsic_to_gcc_builtin[rust_name] = name;\n+  }\n+\n+  bool lookup_gcc_builtin (const std::string &name, tree *builtin)\n+  {\n+    auto it = builtin_functions_.find (name);\n+    if (it == builtin_functions_.end ())\n+      return false;\n+\n+    *builtin = it->second;\n+    return true;\n+  }\n+\n+  // A mapping of the GCC built-ins exposed to GCC Rust.\n+  std::map<std::string, tree> builtin_functions_;\n+  std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_BUILTINS_H"}, {"sha": "2b5c850872f2bf98c646c47cfc9451c86dbe2ec5", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "added", "additions": 730, "deletions": 0, "changes": 730, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=15f04af347e3b65f436808077cbac4fa566019f9", "patch": "@@ -0,0 +1,730 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-abi.h\"\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-stmt.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-fnparam.h\"\n+#include \"rust-compile-var-decl.h\"\n+#include \"rust-constexpr.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-expr.h\"\t// for AST::AttrInputLiteral\n+#include \"rust-macro.h\" // for AST::MetaNameValueStr\n+\n+#include \"fold-const.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n+#include \"tree.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+bool inline should_mangle_item (const tree fndecl)\n+{\n+  return lookup_attribute (\"no_mangle\", DECL_ATTRIBUTES (fndecl)) == NULL_TREE;\n+}\n+\n+void\n+HIRCompileBase::setup_fndecl (tree fndecl, bool is_main_entry_point,\n+\t\t\t      bool is_generic_fn, HIR::Visibility &visibility,\n+\t\t\t      const HIR::FunctionQualifiers &qualifiers,\n+\t\t\t      const AST::AttrVec &attrs)\n+{\n+  // if its the main fn or pub visibility mark its as DECL_PUBLIC\n+  // please see https://github.com/Rust-GCC/gccrs/pull/137\n+  bool is_pub = visibility.get_vis_type () == HIR::Visibility::VisType::PUBLIC;\n+  if (is_main_entry_point || (is_pub && !is_generic_fn))\n+    {\n+      TREE_PUBLIC (fndecl) = 1;\n+    }\n+\n+  // is it a const fn\n+  if (qualifiers.is_const ())\n+    {\n+      TREE_READONLY (fndecl) = 1;\n+    }\n+\n+  // is it inline?\n+  for (const auto &attr : attrs)\n+    {\n+      bool is_inline = attr.get_path ().as_string ().compare (\"inline\") == 0;\n+      bool is_must_use\n+\t= attr.get_path ().as_string ().compare (\"must_use\") == 0;\n+      bool is_cold = attr.get_path ().as_string ().compare (\"cold\") == 0;\n+      bool is_link_section\n+\t= attr.get_path ().as_string ().compare (\"link_section\") == 0;\n+      bool no_mangle = attr.get_path ().as_string ().compare (\"no_mangle\") == 0;\n+      bool is_deprecated\n+\t= attr.get_path ().as_string ().compare (\"deprecated\") == 0;\n+\n+      if (is_inline)\n+\t{\n+\t  handle_inline_attribute_on_fndecl (fndecl, attr);\n+\t}\n+      else if (is_must_use)\n+\t{\n+\t  handle_must_use_attribute_on_fndecl (fndecl, attr);\n+\t}\n+      else if (is_cold)\n+\t{\n+\t  handle_cold_attribute_on_fndecl (fndecl, attr);\n+\t}\n+      else if (is_link_section)\n+\t{\n+\t  handle_link_section_attribute_on_fndecl (fndecl, attr);\n+\t}\n+      else if (is_deprecated)\n+\t{\n+\t  handle_deprecated_attribute_on_fndecl (fndecl, attr);\n+\t}\n+      else if (no_mangle)\n+\t{\n+\t  handle_no_mangle_attribute_on_fndecl (fndecl, attr);\n+\t}\n+    }\n+}\n+\n+void\n+HIRCompileBase::handle_cold_attribute_on_fndecl (tree fndecl,\n+\t\t\t\t\t\t const AST::Attribute &attr)\n+{\n+  // simple #[cold]\n+  if (!attr.has_attr_input ())\n+    {\n+      tree cold = get_identifier (\"cold\");\n+      // this will get handled by the GCC backend later\n+      DECL_ATTRIBUTES (fndecl)\n+\t= tree_cons (cold, NULL_TREE, DECL_ATTRIBUTES (fndecl));\n+      return;\n+    }\n+\n+  rust_error_at (attr.get_locus (),\n+\t\t \"attribute %<cold%> does not accept any arguments\");\n+}\n+\n+void\n+HIRCompileBase::handle_link_section_attribute_on_fndecl (\n+  tree fndecl, const AST::Attribute &attr)\n+{\n+  if (!attr.has_attr_input ())\n+    {\n+      rust_error_at (attr.get_locus (),\n+\t\t     \"%<link_section%> expects exactly one argment\");\n+      return;\n+    }\n+\n+  rust_assert (attr.get_attr_input ().get_attr_input_type ()\n+\t       == AST::AttrInput::AttrInputType::LITERAL);\n+\n+  auto &literal = static_cast<AST::AttrInputLiteral &> (attr.get_attr_input ());\n+  const auto &msg_str = literal.get_literal ().as_string ();\n+\n+  if (decl_section_name (fndecl))\n+    {\n+      rust_warning_at (attr.get_locus (), 0, \"section name redefined\");\n+    }\n+\n+  set_decl_section_name (fndecl, msg_str.c_str ());\n+}\n+\n+void\n+HIRCompileBase::handle_no_mangle_attribute_on_fndecl (\n+  tree fndecl, const AST::Attribute &attr)\n+{\n+  if (attr.has_attr_input ())\n+    {\n+      rust_error_at (attr.get_locus (),\n+\t\t     \"attribute %<no_mangle%> does not accept any arguments\");\n+      return;\n+    }\n+\n+  DECL_ATTRIBUTES (fndecl) = tree_cons (get_identifier (\"no_mangle\"), NULL_TREE,\n+\t\t\t\t\tDECL_ATTRIBUTES (fndecl));\n+}\n+\n+void\n+HIRCompileBase::handle_deprecated_attribute_on_fndecl (\n+  tree fndecl, const AST::Attribute &attr)\n+{\n+  tree value = NULL_TREE;\n+  TREE_DEPRECATED (fndecl) = 1;\n+\n+  // simple #[deprecated]\n+  if (!attr.has_attr_input ())\n+    return;\n+\n+  const AST::AttrInput &input = attr.get_attr_input ();\n+  auto input_type = input.get_attr_input_type ();\n+\n+  if (input_type == AST::AttrInput::AttrInputType::LITERAL)\n+    {\n+      // handle #[deprecated = \"message\"]\n+      auto &literal\n+\t= static_cast<AST::AttrInputLiteral &> (attr.get_attr_input ());\n+      const auto &msg_str = literal.get_literal ().as_string ();\n+      value = build_string (msg_str.size (), msg_str.c_str ());\n+    }\n+  else if (input_type == AST::AttrInput::AttrInputType::TOKEN_TREE)\n+    {\n+      // handle #[deprecated(since = \"...\", note = \"...\")]\n+      const auto &option = static_cast<const AST::DelimTokenTree &> (input);\n+      AST::AttrInputMetaItemContainer *meta_item = option.parse_to_meta_item ();\n+      for (const auto &item : meta_item->get_items ())\n+\t{\n+\t  auto converted_item = item->to_meta_name_value_str ();\n+\t  if (!converted_item)\n+\t    continue;\n+\t  auto key_value = converted_item->get_name_value_pair ();\n+\t  if (key_value.first.compare (\"since\") == 0)\n+\t    {\n+\t      // valid, but this is handled by Cargo and some third-party audit\n+\t      // tools\n+\t      continue;\n+\t    }\n+\t  else if (key_value.first.compare (\"note\") == 0)\n+\t    {\n+\t      const auto &msg_str = key_value.second;\n+\t      if (value)\n+\t\trust_error_at (attr.get_locus (), \"multiple %<note%> items\");\n+\t      value = build_string (msg_str.size (), msg_str.c_str ());\n+\t    }\n+\t  else\n+\t    {\n+\t      rust_error_at (attr.get_locus (), \"unknown meta item %qs\",\n+\t\t\t     key_value.first.c_str ());\n+\t    }\n+\t}\n+    }\n+\n+  if (value)\n+    {\n+      tree attr_list = build_tree_list (NULL_TREE, value);\n+      DECL_ATTRIBUTES (fndecl)\n+\t= tree_cons (get_identifier (\"deprecated\"), attr_list,\n+\t\t     DECL_ATTRIBUTES (fndecl));\n+    }\n+}\n+\n+void\n+HIRCompileBase::handle_inline_attribute_on_fndecl (tree fndecl,\n+\t\t\t\t\t\t   const AST::Attribute &attr)\n+{\n+  // simple #[inline]\n+  if (!attr.has_attr_input ())\n+    {\n+      DECL_DECLARED_INLINE_P (fndecl) = 1;\n+      return;\n+    }\n+\n+  const AST::AttrInput &input = attr.get_attr_input ();\n+  bool is_token_tree\n+    = input.get_attr_input_type () == AST::AttrInput::AttrInputType::TOKEN_TREE;\n+  rust_assert (is_token_tree);\n+  const auto &option = static_cast<const AST::DelimTokenTree &> (input);\n+  AST::AttrInputMetaItemContainer *meta_item = option.parse_to_meta_item ();\n+  if (meta_item->get_items ().size () != 1)\n+    {\n+      rust_error_at (attr.get_locus (), \"invalid number of arguments\");\n+      return;\n+    }\n+\n+  const std::string inline_option\n+    = meta_item->get_items ().at (0)->as_string ();\n+\n+  // we only care about NEVER and ALWAYS else its an error\n+  bool is_always = inline_option.compare (\"always\") == 0;\n+  bool is_never = inline_option.compare (\"never\") == 0;\n+\n+  // #[inline(never)]\n+  if (is_never)\n+    {\n+      DECL_UNINLINABLE (fndecl) = 1;\n+    }\n+  // #[inline(always)]\n+  else if (is_always)\n+    {\n+      DECL_DECLARED_INLINE_P (fndecl) = 1;\n+      DECL_ATTRIBUTES (fndecl) = tree_cons (get_identifier (\"always_inline\"),\n+\t\t\t\t\t    NULL, DECL_ATTRIBUTES (fndecl));\n+    }\n+  else\n+    {\n+      rust_error_at (attr.get_locus (), \"unknown inline option\");\n+    }\n+}\n+\n+void\n+HIRCompileBase::handle_must_use_attribute_on_fndecl (tree fndecl,\n+\t\t\t\t\t\t     const AST::Attribute &attr)\n+{\n+  tree nodiscard = get_identifier (\"nodiscard\");\n+  tree value = NULL_TREE;\n+\n+  if (attr.has_attr_input ())\n+    {\n+      rust_assert (attr.get_attr_input ().get_attr_input_type ()\n+\t\t   == AST::AttrInput::AttrInputType::LITERAL);\n+\n+      auto &literal\n+\t= static_cast<AST::AttrInputLiteral &> (attr.get_attr_input ());\n+      const auto &msg_str = literal.get_literal ().as_string ();\n+      tree message = build_string (msg_str.size (), msg_str.c_str ());\n+\n+      value = tree_cons (nodiscard, message, NULL_TREE);\n+    }\n+\n+  DECL_ATTRIBUTES (fndecl)\n+    = tree_cons (nodiscard, value, DECL_ATTRIBUTES (fndecl));\n+}\n+\n+void\n+HIRCompileBase::setup_abi_options (tree fndecl, ABI abi)\n+{\n+  tree abi_tree = NULL_TREE;\n+\n+  switch (abi)\n+    {\n+    case Rust::ABI::RUST:\n+    case Rust::ABI::INTRINSIC:\n+    case Rust::ABI::C:\n+    case Rust::ABI::CDECL:\n+      // `decl_attributes` function (not the macro) has the side-effect of\n+      // actually switching the codegen backend to use the ABI we annotated.\n+      // However, since `cdecl` is the default ABI GCC will be using, explicitly\n+      // specifying that ABI will cause GCC to emit a warning saying the\n+      // attribute is useless (which is confusing to the user as the attribute\n+      // is added by us).\n+      DECL_ATTRIBUTES (fndecl)\n+\t= tree_cons (get_identifier (\"cdecl\"), NULL, DECL_ATTRIBUTES (fndecl));\n+\n+      return;\n+\n+    case Rust::ABI::STDCALL:\n+      abi_tree = get_identifier (\"stdcall\");\n+\n+      break;\n+\n+    case Rust::ABI::FASTCALL:\n+      abi_tree = get_identifier (\"fastcall\");\n+\n+      break;\n+\n+    case Rust::ABI::SYSV64:\n+      abi_tree = get_identifier (\"sysv_abi\");\n+\n+      break;\n+\n+    case Rust::ABI::WIN64:\n+      abi_tree = get_identifier (\"ms_abi\");\n+\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  decl_attributes (&fndecl, build_tree_list (abi_tree, NULL_TREE), 0);\n+}\n+\n+// ported from gcc/c/c-typecheck.c\n+//\n+// Mark EXP saying that we need to be able to take the\n+// address of it; it should not be allocated in a register.\n+// Returns true if successful.  ARRAY_REF_P is true if this\n+// is for ARRAY_REF construction - in that case we don't want\n+// to look through VIEW_CONVERT_EXPR from VECTOR_TYPE to ARRAY_TYPE,\n+// it is fine to use ARRAY_REFs for vector subscripts on vector\n+// register variables.\n+bool\n+HIRCompileBase::mark_addressable (tree exp, Location locus)\n+{\n+  tree x = exp;\n+\n+  while (1)\n+    switch (TREE_CODE (x))\n+      {\n+      case VIEW_CONVERT_EXPR:\n+\tif (TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE\n+\t    && VECTOR_TYPE_P (TREE_TYPE (TREE_OPERAND (x, 0))))\n+\t  return true;\n+\tx = TREE_OPERAND (x, 0);\n+\tbreak;\n+\n+      case COMPONENT_REF:\n+\t// TODO\n+\t// if (DECL_C_BIT_FIELD (TREE_OPERAND (x, 1)))\n+\t//   {\n+\t//     error (\"cannot take address of bit-field %qD\", TREE_OPERAND (x,\n+\t//     1)); return false;\n+\t//   }\n+\n+\t/* FALLTHRU */\n+      case ADDR_EXPR:\n+      case ARRAY_REF:\n+      case REALPART_EXPR:\n+      case IMAGPART_EXPR:\n+\tx = TREE_OPERAND (x, 0);\n+\tbreak;\n+\n+      case COMPOUND_LITERAL_EXPR:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\tTREE_ADDRESSABLE (COMPOUND_LITERAL_EXPR_DECL (x)) = 1;\n+\treturn true;\n+\n+      case CONSTRUCTOR:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\treturn true;\n+\n+      case VAR_DECL:\n+      case CONST_DECL:\n+      case PARM_DECL:\n+      case RESULT_DECL:\n+\t// (we don't have a concept of a \"register\" declaration)\n+\t// fallthrough */\n+\n+\t/* FALLTHRU */\n+      case FUNCTION_DECL:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\n+\t/* FALLTHRU */\n+      default:\n+\treturn true;\n+      }\n+\n+  return false;\n+}\n+\n+tree\n+HIRCompileBase::address_expression (tree expr, Location location)\n+{\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+\n+  if (!mark_addressable (expr, location))\n+    return error_mark_node;\n+\n+  return build_fold_addr_expr_loc (location.gcc_location (), expr);\n+}\n+\n+tree\n+HIRCompileBase::indirect_expression (tree expr, Location locus)\n+{\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+\n+  return build_fold_indirect_ref_loc (locus.gcc_location (), expr);\n+}\n+\n+std::vector<Bvariable *>\n+HIRCompileBase::compile_locals_for_block (Context *ctx, Resolver::Rib &rib,\n+\t\t\t\t\t  tree fndecl)\n+{\n+  std::vector<Bvariable *> locals;\n+  for (auto it : rib.get_declarations ())\n+    {\n+      NodeId node_id = it.first;\n+      HirId ref = UNKNOWN_HIRID;\n+      if (!ctx->get_mappings ()->lookup_node_to_hir (node_id, &ref))\n+\tcontinue;\n+\n+      // we only care about local patterns\n+      HIR::Pattern *pattern = ctx->get_mappings ()->lookup_hir_pattern (ref);\n+      if (pattern == nullptr)\n+\tcontinue;\n+\n+      // lookup the type\n+      TyTy::BaseType *tyty = nullptr;\n+      if (!ctx->get_tyctx ()->lookup_type (ref, &tyty))\n+\tcontinue;\n+\n+      // compile the local\n+      tree type = TyTyResolveCompile::compile (ctx, tyty);\n+      Bvariable *compiled\n+\t= CompileVarDecl::compile (fndecl, type, pattern, ctx);\n+      locals.push_back (compiled);\n+    }\n+  return locals;\n+}\n+\n+void\n+HIRCompileBase::compile_function_body (Context *ctx, tree fndecl,\n+\t\t\t\t       HIR::BlockExpr &function_body,\n+\t\t\t\t       bool has_return_type)\n+{\n+  for (auto &s : function_body.get_statements ())\n+    {\n+      auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n+      if (compiled_expr != nullptr)\n+\t{\n+\t  tree s = convert_to_void (compiled_expr, ICV_STATEMENT);\n+\t  ctx->add_statement (s);\n+\t}\n+    }\n+\n+  if (function_body.has_expr ())\n+    {\n+      // the previous passes will ensure this is a valid return\n+      // or a valid trailing expression\n+      tree compiled_expr\n+\t= CompileExpr::Compile (function_body.expr.get (), ctx);\n+\n+      if (compiled_expr != nullptr)\n+\t{\n+\t  if (has_return_type)\n+\t    {\n+\t      std::vector<tree> retstmts;\n+\t      retstmts.push_back (compiled_expr);\n+\n+\t      auto ret = ctx->get_backend ()->return_statement (\n+\t\tfndecl, retstmts,\n+\t\tfunction_body.get_final_expr ()->get_locus ());\n+\t      ctx->add_statement (ret);\n+\t    }\n+\t  else\n+\t    {\n+\t      // FIXME can this actually happen?\n+\t      ctx->add_statement (compiled_expr);\n+\t    }\n+\t}\n+    }\n+}\n+\n+tree\n+HIRCompileBase::compile_function (\n+  Context *ctx, const std::string &fn_name, HIR::SelfParam &self_param,\n+  std::vector<HIR::FunctionParam> &function_params,\n+  const HIR::FunctionQualifiers &qualifiers, HIR::Visibility &visibility,\n+  AST::AttrVec &outer_attrs, Location locus, HIR::BlockExpr *function_body,\n+  const Resolver::CanonicalPath *canonical_path, TyTy::FnType *fntype,\n+  bool function_has_return)\n+{\n+  tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+  std::string ir_symbol_name\n+    = canonical_path->get () + fntype->subst_as_string ();\n+\n+  // we don't mangle the main fn since we haven't implemented the main shim\n+  bool is_main_fn = fn_name.compare (\"main\") == 0;\n+  std::string asm_name = fn_name;\n+\n+  unsigned int flags = 0;\n+  tree fndecl = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n+\t\t\t\t\t       \"\" /* asm_name */, flags, locus);\n+\n+  setup_fndecl (fndecl, is_main_fn, fntype->has_subsititions_defined (),\n+\t\tvisibility, qualifiers, outer_attrs);\n+  setup_abi_options (fndecl, qualifiers.get_abi ());\n+\n+  // conditionally mangle the function name\n+  bool should_mangle = should_mangle_item (fndecl);\n+  if (!is_main_fn && should_mangle)\n+    asm_name = ctx->mangle_item (fntype, *canonical_path);\n+  SET_DECL_ASSEMBLER_NAME (fndecl,\n+\t\t\t   get_identifier_with_length (asm_name.data (),\n+\t\t\t\t\t\t       asm_name.length ()));\n+\n+  // insert into the context\n+  ctx->insert_function_decl (fntype, fndecl);\n+\n+  // setup the params\n+  TyTy::BaseType *tyret = fntype->get_return_type ();\n+  std::vector<Bvariable *> param_vars;\n+  if (!self_param.is_error ())\n+    {\n+      rust_assert (fntype->is_method ());\n+      TyTy::BaseType *self_tyty_lookup = fntype->get_self_type ();\n+\n+      tree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+      Bvariable *compiled_self_param\n+\t= CompileSelfParam::compile (ctx, fndecl, self_param, self_type,\n+\t\t\t\t     self_param.get_locus ());\n+\n+      param_vars.push_back (compiled_self_param);\n+      ctx->insert_var_decl (self_param.get_mappings ().get_hirid (),\n+\t\t\t    compiled_self_param);\n+    }\n+\n+  // offset from + 1 for the TyTy::FnType being used when this is a method to\n+  // skip over Self on the FnType\n+  bool is_method = !self_param.is_error ();\n+  size_t i = is_method ? 1 : 0;\n+  for (auto &referenced_param : function_params)\n+    {\n+      auto tyty_param = fntype->param_at (i++);\n+      auto param_tyty = tyty_param.second;\n+      auto compiled_param_type = TyTyResolveCompile::compile (ctx, param_tyty);\n+\n+      Location param_locus = referenced_param.get_locus ();\n+      Bvariable *compiled_param_var\n+\t= CompileFnParam::compile (ctx, fndecl, &referenced_param,\n+\t\t\t\t   compiled_param_type, param_locus);\n+\n+      param_vars.push_back (compiled_param_var);\n+\n+      const HIR::Pattern &param_pattern = *referenced_param.get_param_name ();\n+      ctx->insert_var_decl (param_pattern.get_pattern_mappings ().get_hirid (),\n+\t\t\t    compiled_param_var);\n+    }\n+\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  // lookup locals\n+  auto body_mappings = function_body->get_mappings ();\n+  Resolver::Rib *rib = nullptr;\n+  bool ok\n+    = ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (), &rib);\n+  rust_assert (ok);\n+\n+  std::vector<Bvariable *> locals\n+    = compile_locals_for_block (ctx, *rib, fndecl);\n+\n+  tree enclosing_scope = NULL_TREE;\n+  Location start_location = function_body->get_locus ();\n+  Location end_location = function_body->get_end_locus ();\n+\n+  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (code_block);\n+\n+  Bvariable *return_address = nullptr;\n+  if (function_has_return)\n+    {\n+      tree return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\n+      bool address_is_taken = false;\n+      tree ret_var_stmt = NULL_TREE;\n+\n+      return_address\n+\t= ctx->get_backend ()->temporary_variable (fndecl, code_block,\n+\t\t\t\t\t\t   return_type, NULL,\n+\t\t\t\t\t\t   address_is_taken, locus,\n+\t\t\t\t\t\t   &ret_var_stmt);\n+\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  ctx->push_fn (fndecl, return_address);\n+  compile_function_body (ctx, fndecl, *function_body, function_has_return);\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+  ctx->pop_fn ();\n+  ctx->push_function (fndecl);\n+\n+  return fndecl;\n+}\n+\n+tree\n+HIRCompileBase::compile_constant_item (\n+  Context *ctx, TyTy::BaseType *resolved_type,\n+  const Resolver::CanonicalPath *canonical_path, HIR::Expr *const_value_expr,\n+  Location locus)\n+{\n+  const std::string &ident = canonical_path->get ();\n+  tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+  tree const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n+\n+  bool is_block_expr\n+    = const_value_expr->get_expression_type () == HIR::Expr::ExprType::Block;\n+\n+  // compile the expression\n+  tree folded_expr = error_mark_node;\n+  if (!is_block_expr)\n+    {\n+      tree value = CompileExpr::Compile (const_value_expr, ctx);\n+      folded_expr = fold_expr (value);\n+    }\n+  else\n+    {\n+      // in order to compile a block expr we want to reuse as much existing\n+      // machineary that we already have. This means the best approach is to\n+      // make a _fake_ function with a block so it can hold onto temps then\n+      // use our constexpr code to fold it completely or error_mark_node\n+      Backend::typed_identifier receiver;\n+      tree compiled_fn_type = ctx->get_backend ()->function_type (\n+\treceiver, {}, {Backend::typed_identifier (\"_\", const_type, locus)},\n+\tNULL, locus);\n+\n+      tree fndecl\n+\t= ctx->get_backend ()->function (compiled_fn_type, ident, \"\", 0, locus);\n+      TREE_READONLY (fndecl) = 1;\n+\n+      tree enclosing_scope = NULL_TREE;\n+      HIR::BlockExpr *function_body\n+\t= static_cast<HIR::BlockExpr *> (const_value_expr);\n+      Location start_location = function_body->get_locus ();\n+      Location end_location = function_body->get_end_locus ();\n+\n+      tree code_block\n+\t= ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n+\t\t\t\t      start_location, end_location);\n+      ctx->push_block (code_block);\n+\n+      bool address_is_taken = false;\n+      tree ret_var_stmt = NULL_TREE;\n+      Bvariable *return_address\n+\t= ctx->get_backend ()->temporary_variable (fndecl, code_block,\n+\t\t\t\t\t\t   const_type, NULL,\n+\t\t\t\t\t\t   address_is_taken, locus,\n+\t\t\t\t\t\t   &ret_var_stmt);\n+\n+      ctx->add_statement (ret_var_stmt);\n+      ctx->push_fn (fndecl, return_address);\n+\n+      compile_function_body (ctx, fndecl, *function_body, true);\n+      tree bind_tree = ctx->pop_block ();\n+\n+      gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+      DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+      ctx->pop_fn ();\n+\n+      // lets fold it into a call expr\n+      tree call = build_call_array_loc (locus.gcc_location (), const_type,\n+\t\t\t\t\tfndecl, 0, NULL);\n+      folded_expr = fold_expr (call);\n+    }\n+\n+  return named_constant_expression (const_type, ident, folded_expr, locus);\n+}\n+\n+tree\n+HIRCompileBase::named_constant_expression (tree type_tree,\n+\t\t\t\t\t   const std::string &name,\n+\t\t\t\t\t   tree const_val, Location location)\n+{\n+  if (type_tree == error_mark_node || const_val == error_mark_node)\n+    return error_mark_node;\n+\n+  tree name_tree = get_identifier_with_length (name.data (), name.length ());\n+  tree decl\n+    = build_decl (location.gcc_location (), CONST_DECL, name_tree, type_tree);\n+  DECL_INITIAL (decl) = const_val;\n+  TREE_CONSTANT (decl) = 1;\n+  TREE_READONLY (decl) = 1;\n+\n+  rust_preserve_from_gc (decl);\n+  return decl;\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "4c20933cafc7760ca3aa08bc360c6dc07e0b65d7", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=15f04af347e3b65f436808077cbac4fa566019f9", "patch": "@@ -0,0 +1,146 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_BASE\n+#define RUST_COMPILE_BASE\n+\n+#include \"rust-compile-context.h\"\n+#include \"rust-compile-type.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class HIRCompileBase\n+{\n+public:\n+  virtual ~HIRCompileBase () {}\n+\n+protected:\n+  HIRCompileBase (Context *ctx) : ctx (ctx) {}\n+\n+  Context *ctx;\n+\n+protected:\n+  Context *get_context () { return ctx; }\n+\n+  tree coercion_site (HirId id, tree rvalue, const TyTy::BaseType *actual,\n+\t\t      const TyTy::BaseType *expected, Location lvalue_locus,\n+\t\t      Location rvalue_locus);\n+  tree coercion_site1 (tree rvalue, const TyTy::BaseType *actual,\n+\t\t       const TyTy::BaseType *expected, Location lvalue_locus,\n+\t\t       Location rvalue_locus);\n+\n+  tree coerce_to_dyn_object (tree compiled_ref, const TyTy::BaseType *actual,\n+\t\t\t     const TyTy::DynamicObjectType *ty, Location locus);\n+\n+  tree compute_address_for_trait_item (\n+    const Resolver::TraitItemReference *ref,\n+    const TyTy::TypeBoundPredicate *predicate,\n+    std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n+      &receiver_bounds,\n+    const TyTy::BaseType *receiver, const TyTy::BaseType *root, Location locus);\n+\n+  bool verify_array_capacities (tree ltype, tree rtype, Location ltype_locus,\n+\t\t\t\tLocation rtype_locus);\n+\n+  tree query_compile (HirId ref, TyTy::BaseType *lookup,\n+\t\t      const HIR::PathIdentSegment &final_segment,\n+\t\t      const Analysis::NodeMapping &mappings,\n+\t\t      Location expr_locus, bool is_qualified_path);\n+\n+  tree resolve_adjustements (std::vector<Resolver::Adjustment> &adjustments,\n+\t\t\t     tree expression, Location locus);\n+\n+  tree resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n+\t\t\t\t tree expression, Location locus);\n+\n+  tree resolve_indirection_adjustment (Resolver::Adjustment &adjustment,\n+\t\t\t\t       tree expression, Location locus);\n+\n+  tree resolve_unsized_adjustment (Resolver::Adjustment &adjustment,\n+\t\t\t\t   tree expression, Location locus);\n+\n+  tree resolve_unsized_slice_adjustment (Resolver::Adjustment &adjustment,\n+\t\t\t\t\t tree expression, Location locus);\n+\n+  tree resolve_unsized_dyn_adjustment (Resolver::Adjustment &adjustment,\n+\t\t\t\t       tree expression, Location locus);\n+\n+  static void setup_fndecl (tree fndecl, bool is_main_entry_point,\n+\t\t\t    bool is_generic_fn, HIR::Visibility &visibility,\n+\t\t\t    const HIR::FunctionQualifiers &qualifiers,\n+\t\t\t    const AST::AttrVec &attrs);\n+\n+  static void handle_inline_attribute_on_fndecl (tree fndecl,\n+\t\t\t\t\t\t const AST::Attribute &attr);\n+\n+  static void handle_cold_attribute_on_fndecl (tree fndecl,\n+\t\t\t\t\t       const AST::Attribute &attr);\n+\n+  static void handle_must_use_attribute_on_fndecl (tree fndecl,\n+\t\t\t\t\t\t   const AST::Attribute &attr);\n+\n+  static void\n+  handle_link_section_attribute_on_fndecl (tree fndecl,\n+\t\t\t\t\t   const AST::Attribute &attr);\n+  static void\n+  handle_deprecated_attribute_on_fndecl (tree fndecl,\n+\t\t\t\t\t const AST::Attribute &attr);\n+\n+  static void handle_no_mangle_attribute_on_fndecl (tree fndecl,\n+\t\t\t\t\t\t    const AST::Attribute &attr);\n+\n+  static void setup_abi_options (tree fndecl, ABI abi);\n+\n+  static tree address_expression (tree expr, Location locus);\n+\n+  static tree indirect_expression (tree expr, Location locus);\n+\n+  static bool mark_addressable (tree, Location);\n+\n+  static std::vector<Bvariable *>\n+  compile_locals_for_block (Context *ctx, Resolver::Rib &rib, tree fndecl);\n+\n+  static void compile_function_body (Context *ctx, tree fndecl,\n+\t\t\t\t     HIR::BlockExpr &function_body,\n+\t\t\t\t     bool has_return_type);\n+\n+  static tree compile_function (\n+    Context *ctx, const std::string &fn_name, HIR::SelfParam &self_param,\n+    std::vector<HIR::FunctionParam> &function_params,\n+    const HIR::FunctionQualifiers &qualifiers, HIR::Visibility &visibility,\n+    AST::AttrVec &outer_attrs, Location locus, HIR::BlockExpr *function_body,\n+    const Resolver::CanonicalPath *canonical_path, TyTy::FnType *fntype,\n+    bool function_has_return);\n+\n+  static tree\n+  compile_constant_item (Context *ctx, TyTy::BaseType *resolved_type,\n+\t\t\t const Resolver::CanonicalPath *canonical_path,\n+\t\t\t HIR::Expr *const_value_expr, Location locus);\n+\n+  static tree named_constant_expression (tree type_tree,\n+\t\t\t\t\t const std::string &name,\n+\t\t\t\t\t tree const_val, Location location);\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_BASE"}, {"sha": "4d202078a70ee7bc1a9ee1826a1ee51190122240", "filename": "gcc/rust/backend/rust-mangle.cc", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.cc?ref=15f04af347e3b65f436808077cbac4fa566019f9", "patch": "@@ -0,0 +1,307 @@\n+#include \"rust-mangle.h\"\n+#include \"fnv-hash.h\"\n+#include \"rust-base62.h\"\n+\n+// FIXME: Rename those to legacy_*\n+static const std::string kMangledSymbolPrefix = \"_ZN\";\n+static const std::string kMangledSymbolDelim = \"E\";\n+static const std::string kMangledGenericDelim = \"$C$\";\n+static const std::string kMangledSubstBegin = \"$LT$\";\n+static const std::string kMangledSubstEnd = \"$GT$\";\n+static const std::string kMangledSpace = \"$u20$\";\n+static const std::string kMangledRef = \"$RF$\";\n+static const std::string kMangledPtr = \"$BP$\";\n+static const std::string kMangledLeftSqParen = \"$u5b$\";\t // [\n+static const std::string kMangledRightSqParen = \"$u5d$\"; // ]\n+static const std::string kQualPathBegin = \"_\" + kMangledSubstBegin;\n+static const std::string kMangledComma = \"$C$\";\n+\n+namespace Rust {\n+namespace Compile {\n+\n+Mangler::MangleVersion Mangler::version = MangleVersion::LEGACY;\n+\n+static std::string\n+legacy_mangle_name (const std::string &name)\n+{\n+  // example\n+  //  <&T as core::fmt::Debug>::fmt:\n+  //  _ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17h6dac924c0051eef7E\n+  // replace all white space with $ and & with RF\n+  //\n+  // <example::Bar as example::A>::fooA:\n+  // _ZN43_$LT$example..Bar$u20$as$u20$example..A$GT$4fooA17hfc615fa76c7db7a0E:\n+  //\n+  // core::ptr::const_ptr::<impl *const T>::cast:\n+  // _ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hb79f4617226f1d55E:\n+  //\n+  // core::ptr::const_ptr::<impl *const [T]>::as_ptr:\n+  // _ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$6as_ptr17he16e0dcd9473b04fE:\n+  //\n+  // example::Foo<T>::new:\n+  // _ZN7example12Foo$LT$T$GT$3new17h9a2aacb7fd783515E:\n+  //\n+  // <example::Identity as example::FnLike<&T,&T>>::call\n+  // _ZN74_$LT$example..Identity$u20$as$u20$example..FnLike$LT$$RF$T$C$$RF$T$GT$$GT$4call17ha9ee58935895acb3E\n+\n+  std::string buffer;\n+  for (size_t i = 0; i < name.size (); i++)\n+    {\n+      std::string m;\n+      char c = name.at (i);\n+\n+      if (c == ' ')\n+\tm = kMangledSpace;\n+      else if (c == '&')\n+\tm = kMangledRef;\n+      else if (i == 0 && c == '<')\n+\tm = kQualPathBegin;\n+      else if (c == '<')\n+\tm = kMangledSubstBegin;\n+      else if (c == '>')\n+\tm = kMangledSubstEnd;\n+      else if (c == '*')\n+\tm = kMangledPtr;\n+      else if (c == '[')\n+\tm = kMangledLeftSqParen;\n+      else if (c == ']')\n+\tm = kMangledRightSqParen;\n+      else if (c == ',')\n+\tm = kMangledComma;\n+      else if (c == ':')\n+\t{\n+\t  rust_assert (i + 1 < name.size ());\n+\t  rust_assert (name.at (i + 1) == ':');\n+\t  i++;\n+\t  m = \"..\";\n+\t}\n+      else\n+\tm.push_back (c);\n+\n+      buffer += m;\n+    }\n+\n+  return std::to_string (buffer.size ()) + buffer;\n+}\n+\n+static std::string\n+legacy_mangle_canonical_path (const Resolver::CanonicalPath &path)\n+{\n+  std::string buffer;\n+  for (size_t i = 0; i < path.size (); i++)\n+    {\n+      auto &seg = path.get_seg_at (i);\n+      buffer += legacy_mangle_name (seg.second);\n+    }\n+  return buffer;\n+}\n+\n+// rustc uses a sip128 hash for legacy mangling, but an fnv 128 was quicker to\n+// implement for now\n+static std::string\n+legacy_hash (const std::string &fingerprint)\n+{\n+  Hash::FNV128 hasher;\n+  hasher.write ((const unsigned char *) fingerprint.c_str (),\n+\t\tfingerprint.size ());\n+\n+  uint64_t hi, lo;\n+  hasher.sum (&hi, &lo);\n+\n+  char hex[16 + 1];\n+  memset (hex, 0, sizeof hex);\n+  snprintf (hex, sizeof hex, \"%08\" PRIx64 \"%08\" PRIx64, lo, hi);\n+\n+  return \"h\" + std::string (hex, sizeof (hex) - 1);\n+}\n+\n+static std::string\n+v0_tuple_prefix (const TyTy::BaseType *ty)\n+{\n+  if (ty->is_unit ())\n+    return \"u\";\n+\n+  // FIXME: ARTHUR: Add rest of algorithm\n+  return \"\";\n+}\n+\n+static std::string\n+v0_numeric_prefix (const TyTy::BaseType *ty)\n+{\n+  static const std::map<std::string, std::string> num_prefixes = {\n+    {\"[i8]\", \"a\"},    {\"[u8]\", \"h\"},\t{\"[i16]\", \"s\"}, {\"[u16]\", \"t\"},\n+    {\"[i32]\", \"l\"},   {\"[u32]\", \"m\"},\t{\"[i64]\", \"x\"}, {\"[u64]\", \"y\"},\n+    {\"[isize]\", \"i\"}, {\"[usize]\", \"j\"}, {\"[f32]\", \"f\"}, {\"[f64]\", \"d\"},\n+  };\n+\n+  auto ty_kind = ty->get_kind ();\n+  auto ty_str = ty->as_string ();\n+  auto numeric_iter = num_prefixes.end ();\n+\n+  // Special numeric types\n+  if (ty_kind == TyTy::TypeKind::ISIZE)\n+    return \"i\";\n+  else if (ty_kind == TyTy::TypeKind::USIZE)\n+    return \"j\";\n+\n+  numeric_iter = num_prefixes.find (ty_str);\n+  if (numeric_iter != num_prefixes.end ())\n+    return numeric_iter->second;\n+\n+  return \"\";\n+}\n+\n+static std::string\n+v0_simple_type_prefix (const TyTy::BaseType *ty)\n+{\n+  switch (ty->get_kind ())\n+    {\n+    case TyTy::TypeKind::BOOL:\n+      return \"b\";\n+    case TyTy::TypeKind::CHAR:\n+      return \"c\";\n+    case TyTy::TypeKind::STR:\n+      return \"e\";\n+    case TyTy::TypeKind::NEVER:\n+      return \"z\";\n+\n+      // Placeholder types\n+    case TyTy::TypeKind::ERROR:\t      // Fallthrough\n+    case TyTy::TypeKind::INFER:\t      // Fallthrough\n+    case TyTy::TypeKind::PLACEHOLDER: // Fallthrough\n+    case TyTy::TypeKind::PARAM:\n+      // FIXME: TyTy::TypeKind::BOUND is also a valid variant in rustc\n+      return \"p\";\n+\n+    case TyTy::TypeKind::TUPLE:\n+      return v0_tuple_prefix (ty);\n+\n+    case TyTy::TypeKind::UINT:\t// Fallthrough\n+    case TyTy::TypeKind::INT:\t// Fallthrough\n+    case TyTy::TypeKind::FLOAT: // Fallthrough\n+    case TyTy::TypeKind::ISIZE: // Fallthrough\n+    case TyTy::TypeKind::USIZE: // Fallthrough\n+      return v0_numeric_prefix (ty);\n+\n+    default:\n+      return \"\";\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+// Add an underscore-terminated base62 integer to the mangling string.\n+// This corresponds to the `<base-62-number>` grammar in the v0 mangling RFC:\n+//  - 0 is encoded as \"_\"\n+//  - any other value is encoded as itself minus one in base 62, followed by\n+//  \"_\"\n+static void\n+v0_add_integer_62 (std::string &mangled, uint64_t x)\n+{\n+  if (x > 0)\n+    mangled.append (base62_integer (x - 1));\n+\n+  mangled.append (\"_\");\n+}\n+\n+// Add a tag-prefixed base62 integer to the mangling string when the\n+// integer is greater than 0:\n+//  - 0 is encoded as \"\" (nothing)\n+//  - any other value is encoded as <tag> + v0_add_integer_62(itself), that is\n+//  <tag> + base62(itself - 1) + '_'\n+static void\n+v0_add_opt_integer_62 (std::string &mangled, std::string tag, uint64_t x)\n+{\n+  if (x > 0)\n+    {\n+      mangled.append (tag);\n+      v0_add_integer_62 (mangled, x);\n+    }\n+}\n+\n+static void\n+v0_add_disambiguator (std::string &mangled, uint64_t dis)\n+{\n+  v0_add_opt_integer_62 (mangled, \"s\", dis);\n+}\n+\n+// Add an identifier to the mangled string. This corresponds to the\n+// `<identifier>` grammar in the v0 mangling RFC.\n+static void\n+v0_add_identifier (std::string &mangled, const std::string &identifier)\n+{\n+  // FIXME: gccrs cannot handle unicode identifiers yet, so we never have to\n+  // create mangling for unicode values for now. However, this is handled\n+  // by the v0 mangling scheme. The grammar for unicode identifier is\n+  // contained in <undisambiguated-identifier>, right under the <identifier>\n+  // one. If the identifier contains unicode values, then an extra \"u\" needs\n+  // to be added to the mangling string and `punycode` must be used to encode\n+  // the characters.\n+\n+  mangled += std::to_string (identifier.size ());\n+\n+  // If the first character of the identifier is a digit or an underscore, we\n+  // add an extra underscore\n+  if (identifier[0] == '_')\n+    mangled.append (\"_\");\n+\n+  mangled.append (identifier);\n+}\n+\n+static std::string\n+v0_type_prefix (const TyTy::BaseType *ty)\n+{\n+  auto ty_prefix = v0_simple_type_prefix (ty);\n+  if (!ty_prefix.empty ())\n+    return ty_prefix;\n+\n+  // FIXME: We need to fetch more type prefixes\n+  gcc_unreachable ();\n+}\n+\n+static std::string\n+legacy_mangle_item (const TyTy::BaseType *ty,\n+\t\t    const Resolver::CanonicalPath &path)\n+{\n+  const std::string hash = legacy_hash (ty->as_string ());\n+  const std::string hash_sig = legacy_mangle_name (hash);\n+\n+  return kMangledSymbolPrefix + legacy_mangle_canonical_path (path) + hash_sig\n+\t + kMangledSymbolDelim;\n+}\n+\n+static std::string\n+v0_mangle_item (const TyTy::BaseType *ty, const Resolver::CanonicalPath &path)\n+{\n+  // we can get this from the canonical_path\n+  auto mappings = Analysis::Mappings::get ();\n+  std::string crate_name;\n+  bool ok = mappings->get_crate_name (path.get_crate_num (), crate_name);\n+  rust_assert (ok);\n+\n+  std::string mangled;\n+  // FIXME: Add real algorithm once all pieces are implemented\n+  auto ty_prefix = v0_type_prefix (ty);\n+  v0_add_identifier (mangled, crate_name);\n+  v0_add_disambiguator (mangled, 62);\n+\n+  gcc_unreachable ();\n+}\n+\n+std::string\n+Mangler::mangle_item (const TyTy::BaseType *ty,\n+\t\t      const Resolver::CanonicalPath &path) const\n+{\n+  switch (version)\n+    {\n+    case Mangler::MangleVersion::LEGACY:\n+      return legacy_mangle_item (ty, path);\n+    case Mangler::MangleVersion::V0:\n+      return v0_mangle_item (ty, path);\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "6d5a64f8bce0c7b1dce77c7dd53593ca13601443", "filename": "gcc/rust/backend/rust-mangle.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-mangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-mangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.h?ref=15f04af347e3b65f436808077cbac4fa566019f9", "patch": "@@ -0,0 +1,52 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_MANGLE_H\n+#define RUST_MANGLE_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class Mangler\n+{\n+public:\n+  enum MangleVersion\n+  {\n+    // Values defined in rust/lang.opt\n+    LEGACY = 0,\n+    V0 = 1,\n+  };\n+\n+  // this needs to support Legacy and V0 see github #429 or #305\n+  std::string mangle_item (const TyTy::BaseType *ty,\n+\t\t\t   const Resolver::CanonicalPath &path) const;\n+\n+  static void set_mangling (int frust_mangling_value)\n+  {\n+    version = static_cast<MangleVersion> (frust_mangling_value);\n+  }\n+\n+private:\n+  static enum MangleVersion version;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_MANGLE_H"}, {"sha": "3d71e19fe82c0fff1000d103401b50bbf77405a3", "filename": "gcc/rust/backend/rust-tree.cc", "status": "added", "additions": 958, "deletions": 0, "changes": 958, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=15f04af347e3b65f436808077cbac4fa566019f9", "patch": "@@ -0,0 +1,958 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-tree.h\"\n+#include \"fold-const.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n+#include \"escaped_string.h\"\n+\n+namespace Rust {\n+\n+void\n+mark_exp_read (tree exp)\n+{\n+  if (exp == NULL)\n+    return;\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case VAR_DECL:\n+      gcc_fallthrough ();\n+    case PARM_DECL:\n+      DECL_READ_P (exp) = 1;\n+      break;\n+    case ARRAY_REF:\n+    case COMPONENT_REF:\n+    case MODIFY_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    CASE_CONVERT:\n+    case ADDR_EXPR:\n+    case INDIRECT_REF:\n+    case FLOAT_EXPR:\n+    case NON_DEPENDENT_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      mark_exp_read (TREE_OPERAND (exp, 0));\n+      break;\n+    case COMPOUND_EXPR:\n+      mark_exp_read (TREE_OPERAND (exp, 1));\n+      break;\n+    case COND_EXPR:\n+      if (TREE_OPERAND (exp, 1))\n+\tmark_exp_read (TREE_OPERAND (exp, 1));\n+      if (TREE_OPERAND (exp, 2))\n+\tmark_exp_read (TREE_OPERAND (exp, 2));\n+      break;\n+    default:\n+      break;\n+    }\n+}\n+\n+tree\n+convert_from_reference (tree val)\n+{\n+  if (TREE_TYPE (val) && TYPE_REF_P (TREE_TYPE (val)))\n+    {\n+      tree t = TREE_TYPE (TREE_TYPE (val));\n+      tree ref = build1 (INDIRECT_REF, t, val);\n+\n+      mark_exp_read (val);\n+\n+      TREE_SIDE_EFFECTS (ref)\n+\t= (TREE_THIS_VOLATILE (ref) || TREE_SIDE_EFFECTS (val));\n+      val = ref;\n+    }\n+\n+  return val;\n+}\n+\n+tree\n+mark_use (tree expr, bool rvalue_p, bool read_p,\n+\t  location_t loc /* = UNKNOWN_LOCATION */,\n+\t  bool reject_builtin /* = true */)\n+{\n+#define RECUR(t) mark_use ((t), rvalue_p, read_p, loc, reject_builtin)\n+\n+  if (expr == NULL_TREE || error_operand_p (expr))\n+    return expr;\n+\n+  if (reject_builtin)\n+    return error_mark_node;\n+\n+  if (read_p)\n+    mark_exp_read (expr);\n+\n+  bool recurse_op[3] = {false, false, false};\n+  switch (TREE_CODE (expr))\n+    {\n+    case COMPONENT_REF:\n+    case NON_DEPENDENT_EXPR:\n+      recurse_op[0] = true;\n+      break;\n+    case COMPOUND_EXPR:\n+      recurse_op[1] = true;\n+      break;\n+    case COND_EXPR:\n+      recurse_op[2] = true;\n+      if (TREE_OPERAND (expr, 1))\n+\trecurse_op[1] = true;\n+      break;\n+    case INDIRECT_REF:\n+      if (REFERENCE_REF_P (expr))\n+\t{\n+\t  /* Try to look through the reference.  */\n+\t  tree ref = TREE_OPERAND (expr, 0);\n+\t  tree r = mark_rvalue_use (ref, loc, reject_builtin);\n+\t  if (r != ref)\n+\t    expr = convert_from_reference (r);\n+\t}\n+      break;\n+\n+    case VIEW_CONVERT_EXPR:\n+      if (location_wrapper_p (expr))\n+\t{\n+\t  loc = EXPR_LOCATION (expr);\n+\t  tree op = TREE_OPERAND (expr, 0);\n+\t  tree nop = RECUR (op);\n+\t  if (nop == error_mark_node)\n+\t    return error_mark_node;\n+\t  else if (op == nop)\n+\t    /* No change.  */;\n+\t  else if (DECL_P (nop) || CONSTANT_CLASS_P (nop))\n+\t    {\n+\t      /* Reuse the location wrapper.  */\n+\t      TREE_OPERAND (expr, 0) = nop;\n+\t      /* If we're replacing a DECL with a constant, we also need to\n+\t\t change the TREE_CODE of the location wrapper.  */\n+\t      if (rvalue_p)\n+\t\tTREE_SET_CODE (expr, NON_LVALUE_EXPR);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Drop the location wrapper.  */\n+\t      expr = nop;\n+\t      protected_set_expr_location (expr, loc);\n+\t    }\n+\t  return expr;\n+\t}\n+      gcc_fallthrough ();\n+    CASE_CONVERT:\n+      recurse_op[0] = true;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (int i = 0; i < 3; ++i)\n+    if (recurse_op[i])\n+      {\n+\ttree op = TREE_OPERAND (expr, i);\n+\top = RECUR (op);\n+\tif (op == error_mark_node)\n+\t  return error_mark_node;\n+\tTREE_OPERAND (expr, i) = op;\n+      }\n+\n+  return expr;\n+#undef RECUR\n+}\n+\n+tree\n+mark_rvalue_use (tree e, location_t loc /* = UNKNOWN_LOCATION */,\n+\t\t bool reject_builtin /* = true */)\n+{\n+  return mark_use (e, true, true, loc, reject_builtin);\n+}\n+\n+tree\n+mark_lvalue_use (tree expr)\n+{\n+  return mark_use (expr, false, true, input_location, false);\n+}\n+\n+tree\n+mark_lvalue_use_nonread (tree expr)\n+{\n+  return mark_use (expr, false, false, input_location, false);\n+}\n+\n+tree\n+mark_discarded_use (tree expr)\n+{\n+  if (expr == NULL_TREE)\n+    return expr;\n+\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case COND_EXPR:\n+      TREE_OPERAND (expr, 2) = mark_discarded_use (TREE_OPERAND (expr, 2));\n+      gcc_fallthrough ();\n+    case COMPOUND_EXPR:\n+      TREE_OPERAND (expr, 1) = mark_discarded_use (TREE_OPERAND (expr, 1));\n+      return expr;\n+\n+    case COMPONENT_REF:\n+    case ARRAY_REF:\n+    case INDIRECT_REF:\n+    case MEMBER_REF:\n+      break;\n+    default:\n+      if (DECL_P (expr))\n+\tbreak;\n+      else\n+\treturn expr;\n+    }\n+\n+  return mark_use (expr, true, true, input_location, false);\n+}\n+\n+tree\n+convert_to_void (tree expr, impl_conv_void implicit)\n+{\n+  location_t loc = expr_loc_or_input_loc (expr);\n+  if (expr == error_mark_node || TREE_TYPE (expr) == error_mark_node)\n+    return error_mark_node;\n+\n+  expr = mark_discarded_use (expr);\n+  if (implicit == ICV_CAST)\n+    /* An explicit cast to void avoids all -Wunused-but-set* warnings.  */\n+    mark_exp_read (expr);\n+\n+  if (!TREE_TYPE (expr))\n+    return expr;\n+\n+  if (VOID_TYPE_P (TREE_TYPE (expr)))\n+    return expr;\n+  switch (TREE_CODE (expr))\n+    {\n+      case COND_EXPR: {\n+\t/* The two parts of a cond expr might be separate lvalues.  */\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\ttree op2 = TREE_OPERAND (expr, 2);\n+\tbool side_effects\n+\t  = ((op1 && TREE_SIDE_EFFECTS (op1)) || TREE_SIDE_EFFECTS (op2));\n+\ttree new_op1, new_op2;\n+\tnew_op1 = NULL_TREE;\n+\tif (implicit != ICV_CAST && !side_effects)\n+\t  {\n+\t    if (op1)\n+\t      new_op1 = convert_to_void (op1, ICV_SECOND_OF_COND);\n+\t    new_op2 = convert_to_void (op2, ICV_THIRD_OF_COND);\n+\t  }\n+\telse\n+\t  {\n+\t    if (op1)\n+\t      new_op1 = convert_to_void (op1, ICV_CAST);\n+\t    new_op2 = convert_to_void (op2, ICV_CAST);\n+\t  }\n+\n+\texpr = build3_loc (loc, COND_EXPR, TREE_TYPE (new_op2),\n+\t\t\t   TREE_OPERAND (expr, 0), new_op1, new_op2);\n+\tbreak;\n+      }\n+\n+      case COMPOUND_EXPR: {\n+\t/* The second part of a compound expr contains the value.  */\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\ttree new_op1;\n+\tif (implicit != ICV_CAST\n+\t    && !warning_suppressed_p (expr /* What warning? */))\n+\t  new_op1 = convert_to_void (op1, ICV_RIGHT_OF_COMMA);\n+\telse\n+\t  new_op1 = convert_to_void (op1, ICV_CAST);\n+\n+\tif (new_op1 != op1)\n+\t  {\n+\t    tree t = build2_loc (loc, COMPOUND_EXPR, TREE_TYPE (new_op1),\n+\t\t\t\t TREE_OPERAND (expr, 0), new_op1);\n+\t    expr = t;\n+\t  }\n+\n+\tbreak;\n+      }\n+\n+    case NON_LVALUE_EXPR:\n+    case NOP_EXPR:\n+      /* These have already decayed to rvalue.  */\n+      break;\n+\n+    case CALL_EXPR:\n+      maybe_warn_nodiscard (expr, implicit);\n+      break;\n+\n+      case INDIRECT_REF: {\n+\ttree type = TREE_TYPE (expr);\n+\tint is_reference = TYPE_REF_P (TREE_TYPE (TREE_OPERAND (expr, 0)));\n+\tint is_volatile = TYPE_VOLATILE (type);\n+\tint is_complete = COMPLETE_TYPE_P (type);\n+\n+\t/* Can't load the value if we don't know the type.  */\n+\tif (is_volatile && !is_complete)\n+\t  {\n+\t    switch (implicit)\n+\t      {\n+\t      case ICV_CAST:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"conversion to void will not access \"\n+\t\t\t    \"object of incomplete type %qT\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_SECOND_OF_COND:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"incomplete type %qT in second operand \"\n+\t\t\t    \"of conditional expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_THIRD_OF_COND:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"incomplete type %qT in third operand \"\n+\t\t\t    \"of conditional expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_RIGHT_OF_COMMA:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"incomplete type %qT in right operand of \"\n+\t\t\t    \"comma operator\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_LEFT_OF_COMMA:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"incomplete type %qT in left operand of \"\n+\t\t\t    \"comma operator\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_STATEMENT:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"incomplete type %qT in statement\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_THIRD_IN_FOR:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"incomplete type %qT in for increment \"\n+\t\t\t    \"expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n+\t/* Don't load the value if this is an implicit dereference, or if\n+\t   the type needs to be handled by ctors/dtors.  */\n+\telse if (is_volatile && is_reference)\n+\t  {\n+\t    switch (implicit)\n+\t      {\n+\t      case ICV_CAST:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"conversion to void will not access \"\n+\t\t\t    \"object of type %qT\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_SECOND_OF_COND:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"implicit dereference will not access \"\n+\t\t\t    \"object of type %qT in second operand of \"\n+\t\t\t    \"conditional expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_THIRD_OF_COND:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"implicit dereference will not access \"\n+\t\t\t    \"object of type %qT in third operand of \"\n+\t\t\t    \"conditional expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_RIGHT_OF_COMMA:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"implicit dereference will not access \"\n+\t\t\t    \"object of type %qT in right operand of \"\n+\t\t\t    \"comma operator\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_LEFT_OF_COMMA:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"implicit dereference will not access \"\n+\t\t\t    \"object of type %qT in left operand of comma \"\n+\t\t\t    \"operator\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_STATEMENT:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"implicit dereference will not access \"\n+\t\t\t    \"object of type %qT in statement\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_THIRD_IN_FOR:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"implicit dereference will not access \"\n+\t\t\t    \"object of type %qT in for increment expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n+\telse if (is_volatile && TREE_ADDRESSABLE (type))\n+\t  {\n+\t    switch (implicit)\n+\t      {\n+\t      case ICV_CAST:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"conversion to void will not access \"\n+\t\t\t    \"object of non-trivially-copyable type %qT\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_SECOND_OF_COND:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"non-trivially-copyable type %qT in second \"\n+\t\t\t    \"operand of conditional expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_THIRD_OF_COND:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"non-trivially-copyable type %qT in third \"\n+\t\t\t    \"operand of conditional expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_RIGHT_OF_COMMA:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"non-trivially-copyable type %qT in right \"\n+\t\t\t    \"operand of comma operator\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_LEFT_OF_COMMA:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"non-trivially-copyable type %qT in left \"\n+\t\t\t    \"operand of comma operator\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_STATEMENT:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"non-trivially-copyable type %qT in statement\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_THIRD_IN_FOR:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"non-trivially-copyable type %qT in for \"\n+\t\t\t    \"increment expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n+\tif (is_reference || !is_volatile || !is_complete\n+\t    || TREE_ADDRESSABLE (type))\n+\t  {\n+\t    /* Emit a warning (if enabled) when the \"effect-less\" INDIRECT_REF\n+\t       operation is stripped off. Note that we don't warn about\n+\t       - an expression with TREE_NO_WARNING set. (For an example of\n+\t\t such expressions, see build_over_call in call.cc.)\n+\t       - automatic dereferencing of references, since the user cannot\n+\t\t control it. (See also warn_if_unused_value() in c-common.cc.)\n+\t     */\n+\t    if (warn_unused_value && implicit != ICV_CAST\n+\t\t&& !warning_suppressed_p (expr, OPT_Wunused_value)\n+\t\t&& !is_reference)\n+\t      warning_at (loc, OPT_Wunused_value, \"value computed is not used\");\n+\t    expr = TREE_OPERAND (expr, 0);\n+\t    if (TREE_CODE (expr) == CALL_EXPR)\n+\t      maybe_warn_nodiscard (expr, implicit);\n+\t  }\n+\n+\tbreak;\n+      }\n+\n+      case VAR_DECL: {\n+\t/* External variables might be incomplete.  */\n+\ttree type = TREE_TYPE (expr);\n+\tint is_complete = COMPLETE_TYPE_P (type);\n+\n+\tif (TYPE_VOLATILE (type) && !is_complete)\n+\t  switch (implicit)\n+\t    {\n+\t    case ICV_CAST:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"conversion to void will not access \"\n+\t\t\t  \"object %qE of incomplete type %qT\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    case ICV_SECOND_OF_COND:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"variable %qE of incomplete type %qT will \"\n+\t\t\t  \"not be accessed in second operand of \"\n+\t\t\t  \"conditional expression\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    case ICV_THIRD_OF_COND:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"variable %qE of incomplete type %qT will \"\n+\t\t\t  \"not be accessed in third operand of \"\n+\t\t\t  \"conditional expression\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    case ICV_RIGHT_OF_COMMA:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"variable %qE of incomplete type %qT will \"\n+\t\t\t  \"not be accessed in right operand of comma operator\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    case ICV_LEFT_OF_COMMA:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"variable %qE of incomplete type %qT will \"\n+\t\t\t  \"not be accessed in left operand of comma operator\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    case ICV_STATEMENT:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"variable %qE of incomplete type %qT will \"\n+\t\t\t  \"not be accessed in statement\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    case ICV_THIRD_IN_FOR:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"variable %qE of incomplete type %qT will \"\n+\t\t\t  \"not be accessed in for increment expression\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\n+\tbreak;\n+      }\n+\n+    default:;\n+    }\n+\n+  if (!TREE_SIDE_EFFECTS (expr))\n+    expr = void_node;\n+\n+  return expr;\n+}\n+\n+void\n+maybe_warn_nodiscard (tree expr, impl_conv_void implicit)\n+{\n+  tree call = expr;\n+  if (TREE_CODE (expr) == TARGET_EXPR)\n+    call = TARGET_EXPR_INITIAL (expr);\n+\n+  location_t loc = expr_loc_or_input_loc (call);\n+  tree callee = CALL_EXPR_FN (call);\n+  if (!callee)\n+    return;\n+\n+  tree type = TREE_TYPE (callee);\n+  if (INDIRECT_TYPE_P (type))\n+    type = TREE_TYPE (type);\n+\n+  tree rettype = TREE_TYPE (type);\n+  tree fn = get_fndecl_from_callee (callee);\n+  tree attr;\n+  if (implicit != ICV_CAST && fn\n+      && (attr = lookup_attribute (\"nodiscard\", DECL_ATTRIBUTES (fn))))\n+    {\n+      escaped_string msg;\n+      tree args = TREE_VALUE (attr);\n+      if (args)\n+\tmsg.escape (TREE_STRING_POINTER (TREE_VALUE (args)));\n+      const char *format\n+\t= (msg ? G_ (\"ignoring return value of %qD, that must be used: %<%s%>\")\n+\t       : G_ (\"ignoring return value of %qD, that must be used\"));\n+      const char *raw_msg = msg ? (const char *) msg : \"\";\n+      auto_diagnostic_group d;\n+      if (warning_at (loc, OPT_Wunused_result, format, fn, raw_msg))\n+\tinform (DECL_SOURCE_LOCATION (fn), \"declared here\");\n+    }\n+  else if (implicit != ICV_CAST\n+\t   && (attr\n+\t       = lookup_attribute (\"nodiscard\", TYPE_ATTRIBUTES (rettype))))\n+    {\n+      escaped_string msg;\n+      tree args = TREE_VALUE (attr);\n+      if (args)\n+\tmsg.escape (TREE_STRING_POINTER (TREE_VALUE (args)));\n+      const char *format\n+\t= (msg ? G_ (\n+\t     \"ignoring returned value of type %qT, that must be used: %<%s%>\")\n+\t       : G_ (\"ignoring returned value of type %qT, that must be used\"));\n+      const char *raw_msg = msg ? (const char *) msg : \"\";\n+      auto_diagnostic_group d;\n+      if (warning_at (loc, OPT_Wunused_result, format, rettype, raw_msg))\n+\t{\n+\t  if (fn)\n+\t    inform (DECL_SOURCE_LOCATION (fn), \"in call to %qD, declared here\",\n+\t\t    fn);\n+\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (rettype)),\n+\t\t  \"%qT declared here\", rettype);\n+\t}\n+    }\n+}\n+\n+location_t\n+expr_loc_or_loc (const_tree t, location_t or_loc)\n+{\n+  location_t loc = EXPR_LOCATION (t);\n+  if (loc == UNKNOWN_LOCATION)\n+    loc = or_loc;\n+  return loc;\n+}\n+\n+location_t\n+expr_loc_or_input_loc (const_tree t)\n+{\n+  return expr_loc_or_loc (t, input_location);\n+}\n+\n+// FN is the callee of a CALL_EXPR or AGGR_INIT_EXPR; return the FUNCTION_DECL\n+// if we can.\n+tree\n+get_fndecl_from_callee (tree fn)\n+{\n+  if (fn == NULL_TREE)\n+    return fn;\n+  if (TREE_CODE (fn) == FUNCTION_DECL)\n+    return fn;\n+  tree type = TREE_TYPE (fn);\n+  if (type == NULL_TREE || !INDIRECT_TYPE_P (type))\n+    return NULL_TREE;\n+\n+  STRIP_NOPS (fn);\n+  if (TREE_CODE (fn) == ADDR_EXPR || TREE_CODE (fn) == FDESC_EXPR)\n+    fn = TREE_OPERAND (fn, 0);\n+  if (TREE_CODE (fn) == FUNCTION_DECL)\n+    return fn;\n+  return NULL_TREE;\n+}\n+\n+tree\n+pointer_offset_expression (tree base_tree, tree index_tree, location_t location)\n+{\n+  tree element_type_tree = TREE_TYPE (TREE_TYPE (base_tree));\n+  if (base_tree == error_mark_node || TREE_TYPE (base_tree) == error_mark_node\n+      || index_tree == error_mark_node || element_type_tree == error_mark_node)\n+    return error_mark_node;\n+\n+  tree element_size = TYPE_SIZE_UNIT (element_type_tree);\n+  index_tree = fold_convert_loc (location, sizetype, index_tree);\n+  tree offset\n+    = fold_build2_loc (location, MULT_EXPR, sizetype, index_tree, element_size);\n+\n+  return fold_build2_loc (location, POINTER_PLUS_EXPR, TREE_TYPE (base_tree),\n+\t\t\t  base_tree, offset);\n+}\n+\n+// forked from gcc/cp/tree.cc cp_walk_subtrees\n+/* Apply FUNC to all language-specific sub-trees of TP in a pre-order\n+   traversal.  Called from walk_tree.  */\n+\n+tree\n+rs_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func, void *data,\n+\t\t  hash_set<tree> *pset)\n+{\n+  enum tree_code code = TREE_CODE (*tp);\n+  tree result;\n+\n+#define WALK_SUBTREE(NODE)                                                     \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      result = rs_walk_tree (&(NODE), func, data, pset);                       \\\n+      if (result)                                                              \\\n+\tgoto out;                                                              \\\n+    }                                                                          \\\n+  while (0)\n+\n+  if (TYPE_P (*tp))\n+    {\n+      /* If *WALK_SUBTREES_P is 1, we're interested in the syntactic form of\n+\t the argument, so don't look through typedefs, but do walk into\n+\t template arguments for alias templates (and non-typedefed classes).\n+\n+\t If *WALK_SUBTREES_P > 1, we're interested in type identity or\n+\t equivalence, so look through typedefs, ignoring template arguments for\n+\t alias templates, and walk into template args of classes.\n+\n+\t See find_abi_tags_r for an example of setting *WALK_SUBTREES_P to 2\n+\t when that's the behavior the walk_tree_fn wants.  */\n+      if (*walk_subtrees_p == 1 && typedef_variant_p (*tp))\n+\t{\n+\t  *walk_subtrees_p = 0;\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  /* Not one of the easy cases.  We must explicitly go through the\n+     children.  */\n+  result = NULL_TREE;\n+  switch (code)\n+    {\n+    case TREE_LIST:\n+      WALK_SUBTREE (TREE_PURPOSE (*tp));\n+      break;\n+\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (*tp))\n+\tWALK_SUBTREE (TYPE_PTRMEMFUNC_FN_TYPE_RAW (*tp));\n+      break;\n+\n+    case CONSTRUCTOR:\n+      if (COMPOUND_LITERAL_P (*tp))\n+\tWALK_SUBTREE (TREE_TYPE (*tp));\n+      break;\n+\n+    case DECL_EXPR:\n+      /* User variables should be mentioned in BIND_EXPR_VARS\n+\t and their initializers and sizes walked when walking\n+\t the containing BIND_EXPR.  Compiler temporaries are\n+\t handled here.  And also normal variables in templates,\n+\t since do_poplevel doesn't build a BIND_EXPR then.  */\n+      if (VAR_P (TREE_OPERAND (*tp, 0))\n+\t  && (DECL_ARTIFICIAL (TREE_OPERAND (*tp, 0))\n+\t      && !TREE_STATIC (TREE_OPERAND (*tp, 0))))\n+\t{\n+\t  tree decl = TREE_OPERAND (*tp, 0);\n+\t  WALK_SUBTREE (DECL_INITIAL (decl));\n+\t  WALK_SUBTREE (DECL_SIZE (decl));\n+\t  WALK_SUBTREE (DECL_SIZE_UNIT (decl));\n+\t}\n+      break;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+\n+  /* We didn't find what we were looking for.  */\n+out:\n+  return result;\n+\n+#undef WALK_SUBTREE\n+}\n+\n+// forked from gcc/cp/tree.cc cp_expr_location\n+\n+/* Like EXPR_LOCATION, but also handle some tcc_exceptional that have\n+   locations.  */\n+\n+location_t\n+rs_expr_location (const_tree t_)\n+{\n+  tree t = CONST_CAST_TREE (t_);\n+  if (t == NULL_TREE)\n+    return UNKNOWN_LOCATION;\n+\n+  return EXPR_LOCATION (t);\n+}\n+\n+// forked from gcc/cp/class.cc is_really_empty_class\n+\n+/* Returns true if TYPE contains no actual data, just various\n+   possible combinations of empty classes.  If IGNORE_VPTR is true,\n+   a vptr doesn't prevent the class from being considered empty.  Typically\n+   we want to ignore the vptr on assignment, and not on initialization.  */\n+\n+bool\n+is_really_empty_class (tree type, bool ignore_vptr)\n+{\n+  if (CLASS_TYPE_P (type))\n+    {\n+      tree field;\n+      tree binfo;\n+      tree base_binfo;\n+      int i;\n+\n+      /* CLASSTYPE_EMPTY_P isn't set properly until the class is actually laid\n+\t out, but we'd like to be able to check this before then.  */\n+      if (COMPLETE_TYPE_P (type) && is_empty_class (type))\n+\treturn true;\n+\n+      if (!ignore_vptr && TYPE_CONTAINS_VPTR_P (type))\n+\treturn false;\n+\n+      for (binfo = TYPE_BINFO (type), i = 0;\n+\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n+\tif (!is_really_empty_class (BINFO_TYPE (base_binfo), ignore_vptr))\n+\t  return false;\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL\n+\t    && !DECL_ARTIFICIAL (field)\n+\t    /* An unnamed bit-field is not a data member.  */\n+\t    && !DECL_UNNAMED_BIT_FIELD (field)\n+\t    && !is_really_empty_class (TREE_TYPE (field), ignore_vptr))\n+\t  return false;\n+      return true;\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    return (integer_zerop (array_type_nelts_top (type))\n+\t    || is_really_empty_class (TREE_TYPE (type), ignore_vptr));\n+  return false;\n+}\n+\n+// forked from gcc/cp/class.cc is_empty_class\n+\n+/* Returns 1 if TYPE contains only padding bytes.  */\n+\n+int\n+is_empty_class (tree type)\n+{\n+  if (type == error_mark_node)\n+    return 0;\n+\n+  if (!CLASS_TYPE_P (type))\n+    return 0;\n+\n+  return CLASSTYPE_EMPTY_P (type);\n+}\n+\n+// forked from gcc/cp/tree.cc array_type_nelts_top\n+\n+/* Return, as an INTEGER_CST node, the number of elements for TYPE\n+   (which is an ARRAY_TYPE).  This counts only elements of the top\n+   array.  */\n+\n+tree\n+array_type_nelts_top (tree type)\n+{\n+  return fold_build2_loc (input_location, PLUS_EXPR, sizetype,\n+\t\t\t  array_type_nelts (type), size_one_node);\n+}\n+\n+// forked from gcc/cp/tree.cc builtin_valid_in_constant_expr_p\n+\n+/* Test whether DECL is a builtin that may appear in a\n+   constant-expression. */\n+\n+bool\n+builtin_valid_in_constant_expr_p (const_tree decl)\n+{\n+  STRIP_ANY_LOCATION_WRAPPER (decl);\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    /* Not a function.  */\n+    return false;\n+  if (DECL_BUILT_IN_CLASS (decl) != BUILT_IN_NORMAL)\n+    {\n+      if (fndecl_built_in_p (decl, BUILT_IN_FRONTEND))\n+\tswitch (DECL_FE_FUNCTION_CODE (decl))\n+\t  {\n+\t  case RS_BUILT_IN_IS_CONSTANT_EVALUATED:\n+\t  case RS_BUILT_IN_SOURCE_LOCATION:\n+\t  case RS_BUILT_IN_IS_CORRESPONDING_MEMBER:\n+\t  case RS_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS:\n+\t    return true;\n+\t  default:\n+\t    break;\n+\t  }\n+      /* Not a built-in.  */\n+      return false;\n+    }\n+  switch (DECL_FUNCTION_CODE (decl))\n+    {\n+      /* These always have constant results like the corresponding\n+\t macros/symbol.  */\n+    case BUILT_IN_FILE:\n+    case BUILT_IN_FUNCTION:\n+    case BUILT_IN_LINE:\n+\n+      /* The following built-ins are valid in constant expressions\n+\t when their arguments are.  */\n+    case BUILT_IN_ADD_OVERFLOW_P:\n+    case BUILT_IN_SUB_OVERFLOW_P:\n+    case BUILT_IN_MUL_OVERFLOW_P:\n+\n+      /* These have constant results even if their operands are\n+\t non-constant.  */\n+    case BUILT_IN_CONSTANT_P:\n+    case BUILT_IN_ATOMIC_ALWAYS_LOCK_FREE:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n+// forked from gcc/cp/decl2.cc decl_maybe_constant_var_p\n+\n+/* Returns true if DECL could be a symbolic constant variable, depending on\n+   its initializer.  */\n+\n+bool\n+decl_maybe_constant_var_p (tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+  if (!VAR_P (decl))\n+    return false;\n+  if (DECL_DECLARED_CONSTEXPR_P (decl))\n+    return true;\n+  if (DECL_HAS_VALUE_EXPR_P (decl))\n+    /* A proxy isn't constant.  */\n+    return false;\n+  if (TYPE_REF_P (type))\n+    /* References can be constant.  */;\n+  else if (RS_TYPE_CONST_NON_VOLATILE_P (type)\n+\t   && INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n+    /* And const integers.  */;\n+  else\n+    return false;\n+\n+  if (DECL_INITIAL (decl) && !DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl))\n+    /* We know the initializer, and it isn't constant.  */\n+    return false;\n+  else\n+    return true;\n+}\n+\n+// forked from gcc/cp/typeck.cc cp_type_quals\n+\n+/* Returns the type qualifiers for this type, including the qualifiers on the\n+   elements for an array type.  */\n+\n+int\n+rs_type_quals (const_tree type)\n+{\n+  int quals;\n+  /* This CONST_CAST is okay because strip_array_types returns its\n+     argument unmodified and we assign it to a const_tree.  */\n+  type = strip_array_types (CONST_CAST_TREE (type));\n+  if (type == error_mark_node\n+      /* Quals on a FUNCTION_TYPE are memfn quals.  */\n+      || TREE_CODE (type) == FUNCTION_TYPE)\n+    return TYPE_UNQUALIFIED;\n+  quals = TYPE_QUALS (type);\n+  /* METHOD and REFERENCE_TYPEs should never have quals.  */\n+  gcc_assert (\n+    (TREE_CODE (type) != METHOD_TYPE && !TYPE_REF_P (type))\n+    || ((quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)) == TYPE_UNQUALIFIED));\n+  return quals;\n+}\n+\n+} // namespace Rust"}, {"sha": "a667cbfc8ad5dc66856810515aaea3f6e96c6b7e", "filename": "gcc/rust/backend/rust-tree.h", "status": "added", "additions": 508, "deletions": 0, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=15f04af347e3b65f436808077cbac4fa566019f9", "patch": "@@ -0,0 +1,508 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TREE\n+#define RUST_TREE\n+\n+#include \"rust-system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+\n+/* Returns true if NODE is a pointer.  */\n+#define TYPE_PTR_P(NODE) (TREE_CODE (NODE) == POINTER_TYPE)\n+\n+/* Returns true if NODE is a reference.  */\n+#define TYPE_REF_P(NODE) (TREE_CODE (NODE) == REFERENCE_TYPE)\n+\n+/* Returns true if NODE is a pointer or a reference.  */\n+#define INDIRECT_TYPE_P(NODE) (TYPE_PTR_P (NODE) || TYPE_REF_P (NODE))\n+\n+/* [basic.fundamental]\n+\n+   Types  bool, char, wchar_t, and the signed and unsigned integer types\n+   are collectively called integral types.\n+\n+   Note that INTEGRAL_TYPE_P, as defined in tree.h, allows enumeration\n+   types as well, which is incorrect in C++.  Keep these checks in\n+   ascending code order.  */\n+#define RS_INTEGRAL_TYPE_P(TYPE)                                               \\\n+  (TREE_CODE (TYPE) == BOOLEAN_TYPE || TREE_CODE (TYPE) == INTEGER_TYPE)\n+\n+/* [basic.fundamental]\n+\n+   Integral and floating types are collectively called arithmetic\n+   types.\n+\n+   As a GNU extension, we also accept complex types.\n+\n+   Keep these checks in ascending code order.  */\n+#define ARITHMETIC_TYPE_P(TYPE)                                                \\\n+  (RS_INTEGRAL_TYPE_P (TYPE) || TREE_CODE (TYPE) == REAL_TYPE                  \\\n+   || TREE_CODE (TYPE) == COMPLEX_TYPE)\n+\n+/* True iff TYPE is cv decltype(nullptr).  */\n+#define NULLPTR_TYPE_P(TYPE) (TREE_CODE (TYPE) == NULLPTR_TYPE)\n+\n+/* [basic.types]\n+\n+   Arithmetic types, enumeration types, pointer types,\n+   pointer-to-member types, and std::nullptr_t are collectively called\n+   scalar types.\n+\n+   Keep these checks in ascending code order.  */\n+#define SCALAR_TYPE_P(TYPE)                                                    \\\n+  (TREE_CODE (TYPE) == ENUMERAL_TYPE || ARITHMETIC_TYPE_P (TYPE)               \\\n+   || TYPE_PTR_P (TYPE) || NULLPTR_TYPE_P (TYPE))\n+\n+/* True if NODE is an implicit INDIRECT_REF from convert_from_reference.  */\n+#define REFERENCE_REF_P(NODE)                                                  \\\n+  (INDIRECT_REF_P (NODE) && TREE_TYPE (TREE_OPERAND (NODE, 0))                 \\\n+   && TYPE_REF_P (TREE_TYPE (TREE_OPERAND ((NODE), 0))))\n+\n+// this is a helper to differentiate RECORD types between actual records and\n+// slices\n+#define SLICE_FLAG TREE_LANG_FLAG_0\n+#define SLICE_TYPE_P(TYPE)                                                     \\\n+  (TREE_CODE (TYPE) == RECORD_TYPE && TREE_LANG_FLAG_0 (TYPE))\n+\n+/* Returns true if NODE is a pointer to member function type.  */\n+#define TYPE_PTRMEMFUNC_P(NODE)                                                \\\n+  (TREE_CODE (NODE) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (NODE))\n+\n+#define TYPE_PTRMEMFUNC_FLAG(NODE) (TYPE_LANG_FLAG_2 (RECORD_TYPE_CHECK (NODE)))\n+\n+#define TYPE_PTRMEMFUNC_FN_TYPE_RAW(NODE) (TREE_TYPE (TYPE_FIELDS (NODE)))\n+\n+/* True if NODE is a compound-literal, i.e., a brace-enclosed\n+   initializer cast to a particular type.  This is mostly only set during\n+   template parsing; once the initializer has been digested into an actual\n+   value of the type, the expression is represented by a TARGET_EXPR.  */\n+#define COMPOUND_LITERAL_P(NODE)                                               \\\n+  (TREE_CODE (NODE) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (NODE))\n+\n+/* When appearing in an INDIRECT_REF, it means that the tree structure\n+   underneath is actually a call to a constructor.  This is needed\n+   when the constructor must initialize local storage (which can\n+   be automatically destroyed), rather than allowing it to allocate\n+   space from the heap.\n+\n+   When appearing in a SAVE_EXPR, it means that underneath\n+   is a call to a constructor.\n+\n+   When appearing in a CONSTRUCTOR, the expression is an unconverted\n+   compound literal.\n+\n+   When appearing in a FIELD_DECL, it means that this field\n+   has been duly initialized in its constructor.  */\n+#define TREE_HAS_CONSTRUCTOR(NODE) (TREE_LANG_FLAG_4 (NODE))\n+\n+/* Nonzero if T is a class type.  Zero for template type parameters,\n+   typename types, and so forth.  */\n+#define CLASS_TYPE_P(T)                                                        \\\n+  (RECORD_OR_UNION_CODE_P (TREE_CODE (T)) && TYPE_LANG_FLAG_5 (T))\n+\n+/* [class.virtual]\n+\n+   A class that declares or inherits a virtual function is called a\n+   polymorphic class.  */\n+#define TYPE_POLYMORPHIC_P(NODE) (TREE_LANG_FLAG_2 (NODE))\n+\n+/* Nonzero if this class has a virtual function table pointer.  */\n+#define TYPE_CONTAINS_VPTR_P(NODE)                                             \\\n+  (TYPE_POLYMORPHIC_P (NODE) || CLASSTYPE_VBASECLASSES (NODE))\n+\n+/* A vector of BINFOs for the direct and indirect virtual base classes\n+   that this type uses in a post-order depth-first left-to-right\n+   order.  (In other words, these bases appear in the order that they\n+   should be initialized.)  */\n+#define CLASSTYPE_VBASECLASSES(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->vbases)\n+\n+/* A vector of BINFOs for the direct and indirect virtual base classes\n+   that this type uses in a post-order depth-first left-to-right\n+   order.  (In other words, these bases appear in the order that they\n+   should be initialized.)  */\n+#define CLASSTYPE_VBASECLASSES(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->vbases)\n+\n+/* We used to have a variant type for lang_type.  Keep the name of the\n+   checking accessor for the sole survivor.  */\n+#define LANG_TYPE_CLASS_CHECK(NODE) (TYPE_LANG_SPECIFIC (NODE))\n+\n+/* Keep these checks in ascending code order.  */\n+#define RECORD_OR_UNION_CODE_P(T) ((T) == RECORD_TYPE || (T) == UNION_TYPE)\n+#define OVERLOAD_TYPE_P(T) (CLASS_TYPE_P (T) || TREE_CODE (T) == ENUMERAL_TYPE)\n+\n+/* Nonzero if this class is \"empty\" in the sense of the C++ ABI.  */\n+#define CLASSTYPE_EMPTY_P(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->empty_p)\n+\n+/* True if DECL is declared 'constexpr'.  */\n+#define DECL_DECLARED_CONSTEXPR_P(DECL)                                        \\\n+  DECL_LANG_FLAG_8 (VAR_OR_FUNCTION_DECL_CHECK (DECL))\n+\n+#define VAR_OR_FUNCTION_DECL_CHECK(NODE)                                       \\\n+  TREE_CHECK2 (NODE, VAR_DECL, FUNCTION_DECL)\n+\n+// Below macros are copied from gcc/c-family/c-common.h\n+\n+/* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n+#define DECL_C_BIT_FIELD(NODE) (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) == 1)\n+#define SET_DECL_C_BIT_FIELD(NODE)                                             \\\n+  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 1)\n+#define CLEAR_DECL_C_BIT_FIELD(NODE)                                           \\\n+  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 0)\n+\n+/* True if the decl was an unnamed bitfield.  */\n+#define DECL_UNNAMED_BIT_FIELD(NODE)                                           \\\n+  (DECL_C_BIT_FIELD (NODE) && !DECL_NAME (NODE))\n+\n+/* 1 iff NODE is function-local.  */\n+#define DECL_FUNCTION_SCOPE_P(NODE)                                            \\\n+  (DECL_CONTEXT (NODE) && TREE_CODE (DECL_CONTEXT (NODE)) == FUNCTION_DECL)\n+\n+/* Nonzero if this type is const-qualified, but not\n+   volatile-qualified.  Other qualifiers are ignored.  This macro is\n+   used to test whether or not it is OK to bind an rvalue to a\n+   reference.  */\n+#define RS_TYPE_CONST_NON_VOLATILE_P(NODE)                                     \\\n+  ((rs_type_quals (NODE) & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE))             \\\n+   == TYPE_QUAL_CONST)\n+\n+/* [basic.fundamental]\n+\n+   Types  bool, char, wchar_t, and the signed and unsigned integer types\n+   are collectively called integral types.\n+\n+   Note that INTEGRAL_TYPE_P, as defined in tree.h, allows enumeration\n+   types as well, which is incorrect in C++.  Keep these checks in\n+   ascending code order.  */\n+#define RS_INTEGRAL_TYPE_P(TYPE)                                               \\\n+  (TREE_CODE (TYPE) == BOOLEAN_TYPE || TREE_CODE (TYPE) == INTEGER_TYPE)\n+\n+/* Returns true if TYPE is an integral or enumeration name.  Keep\n+   these checks in ascending code order.  */\n+#define INTEGRAL_OR_ENUMERATION_TYPE_P(TYPE)                                   \\\n+  (TREE_CODE (TYPE) == ENUMERAL_TYPE || RS_INTEGRAL_TYPE_P (TYPE))\n+\n+/* Nonzero for a VAR_DECL that was initialized with a\n+   constant-expression.  */\n+#define DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P(NODE)                        \\\n+  (TREE_LANG_FLAG_2 (VAR_DECL_CHECK (NODE)))\n+\n+// Above macros are copied from gcc/c-family/c-common.h\n+\n+// forked from gcc/cp/cp-tree.h treee_pair_s\n+\n+struct GTY (()) tree_pair_s\n+{\n+  tree purpose;\n+  tree value;\n+};\n+\n+// forked from gcc/cp/cp-tree.h tree_pair_p\n+\n+typedef tree_pair_s *tree_pair_p;\n+\n+// forked from gcc/cp/cp-tree.h lang_type\n+\n+/* This structure provides additional information above and beyond\n+   what is provide in the ordinary tree_type.  In the past, we used it\n+   for the types of class types, template parameters types, typename\n+   types, and so forth.  However, there can be many (tens to hundreds\n+   of thousands) of template parameter types in a compilation, and\n+   there's no need for this additional information in that case.\n+   Therefore, we now use this data structure only for class types.\n+\n+   In the past, it was thought that there would be relatively few\n+   class types.  However, in the presence of heavy use of templates,\n+   many (i.e., thousands) of classes can easily be generated.\n+   Therefore, we should endeavor to keep the size of this structure to\n+   a minimum.  */\n+struct GTY (()) lang_type\n+{\n+  unsigned char align;\n+\n+  unsigned has_type_conversion : 1;\n+  unsigned has_copy_ctor : 1;\n+  unsigned has_default_ctor : 1;\n+  unsigned const_needs_init : 1;\n+  unsigned ref_needs_init : 1;\n+  unsigned has_const_copy_assign : 1;\n+  unsigned use_template : 2;\n+\n+  unsigned has_mutable : 1;\n+  unsigned com_interface : 1;\n+  unsigned non_pod_class : 1;\n+  unsigned nearly_empty_p : 1;\n+  unsigned user_align : 1;\n+  unsigned has_copy_assign : 1;\n+  unsigned has_new : 1;\n+  unsigned has_array_new : 1;\n+\n+  unsigned gets_delete : 2;\n+  unsigned interface_only : 1;\n+  unsigned interface_unknown : 1;\n+  unsigned contains_empty_class_p : 1;\n+  unsigned anon_aggr : 1;\n+  unsigned non_zero_init : 1;\n+  unsigned empty_p : 1;\n+  /* 32 bits allocated.  */\n+\n+  unsigned vec_new_uses_cookie : 1;\n+  unsigned declared_class : 1;\n+  unsigned diamond_shaped : 1;\n+  unsigned repeated_base : 1;\n+  unsigned being_defined : 1;\n+  unsigned debug_requested : 1;\n+  unsigned fields_readonly : 1;\n+  unsigned ptrmemfunc_flag : 1;\n+\n+  unsigned lazy_default_ctor : 1;\n+  unsigned lazy_copy_ctor : 1;\n+  unsigned lazy_copy_assign : 1;\n+  unsigned lazy_destructor : 1;\n+  unsigned has_const_copy_ctor : 1;\n+  unsigned has_complex_copy_ctor : 1;\n+  unsigned has_complex_copy_assign : 1;\n+  unsigned non_aggregate : 1;\n+\n+  unsigned has_complex_dflt : 1;\n+  unsigned has_list_ctor : 1;\n+  unsigned non_std_layout : 1;\n+  unsigned is_literal : 1;\n+  unsigned lazy_move_ctor : 1;\n+  unsigned lazy_move_assign : 1;\n+  unsigned has_complex_move_ctor : 1;\n+  unsigned has_complex_move_assign : 1;\n+\n+  unsigned has_constexpr_ctor : 1;\n+  unsigned unique_obj_representations : 1;\n+  unsigned unique_obj_representations_set : 1;\n+  bool erroneous : 1;\n+  bool non_pod_aggregate : 1;\n+\n+  /* When adding a flag here, consider whether or not it ought to\n+     apply to a template instance if it applies to the template.  If\n+     so, make sure to copy it in instantiate_class_template!  */\n+\n+  /* There are some bits left to fill out a 32-bit word.  Keep track\n+     of this by updating the size of this bitfield whenever you add or\n+     remove a flag.  */\n+  unsigned dummy : 3;\n+\n+  tree primary_base;\n+  vec<tree_pair_s, va_gc> *vcall_indices;\n+  tree vtables;\n+  tree typeinfo_var;\n+  vec<tree, va_gc> *vbases;\n+  tree as_base;\n+  vec<tree, va_gc> *pure_virtuals;\n+  tree friend_classes;\n+  vec<tree, va_gc> *GTY ((reorder (\"resort_type_member_vec\"))) members;\n+  tree key_method;\n+  tree decl_list;\n+  tree befriending_classes;\n+  /* In a RECORD_TYPE, information specific to Objective-C++, such\n+     as a list of adopted protocols or a pointer to a corresponding\n+     @interface.  See objc/objc-act.h for details.  */\n+  tree objc_info;\n+  /* FIXME reuse another field?  */\n+  tree lambda_expr;\n+};\n+\n+namespace Rust {\n+\n+// forked from gcc/cp/cp-tree.h tsubst_flags_t\n+\n+/* This type is used for parameters and variables which hold\n+   combinations of the flags in enum tsubst_flags.  */\n+typedef int tsubst_flags_t;\n+\n+// forked from gcc/cp/cvt.cc convert_to_void\n+//\n+// When an expression is used in a void context, its value is discarded and\n+// no lvalue-rvalue and similar conversions happen [expr.static.cast/4,\n+// stmt.expr/1, expr.comma/1].  This permits dereferencing an incomplete type\n+// in a void context. The C++ standard does not define what an `access' to an\n+// object is, but there is reason to believe that it is the lvalue to rvalue\n+// conversion -- if it were not, `*&*p = 1' would violate [expr]/4 in that it\n+// accesses `*p' not to calculate the value to be stored. But, dcl.type.cv/8\n+// indicates that volatile semantics should be the same between C and C++\n+// where ever possible. C leaves it implementation defined as to what\n+// constitutes an access to a volatile. So, we interpret `*vp' as a read of\n+// the volatile object `vp' points to, unless that is an incomplete type. For\n+// volatile references we do not do this interpretation, because that would\n+// make it impossible to ignore the reference return value from functions. We\n+// issue warnings in the confusing cases.\n+//\n+// The IMPLICIT is ICV_CAST when the user is explicitly converting an\n+// expression to void via a cast. If an expression is being implicitly\n+// converted, IMPLICIT indicates the context of the implicit conversion.\n+\n+/* Possible cases of implicit or explicit bad conversions to void. */\n+enum impl_conv_void\n+{\n+  ICV_CAST,\t      /* (explicit) conversion to void */\n+  ICV_SECOND_OF_COND, /* second operand of conditional expression */\n+  ICV_THIRD_OF_COND,  /* third operand of conditional expression */\n+  ICV_RIGHT_OF_COMMA, /* right operand of comma operator */\n+  ICV_LEFT_OF_COMMA,  /* left operand of comma operator */\n+  ICV_STATEMENT,      /* statement */\n+  ICV_THIRD_IN_FOR    /* for increment expression */\n+};\n+\n+/* BUILT_IN_FRONTEND function codes.  */\n+enum rs_built_in_function\n+{\n+  RS_BUILT_IN_IS_CONSTANT_EVALUATED,\n+  RS_BUILT_IN_INTEGER_PACK,\n+  RS_BUILT_IN_IS_CORRESPONDING_MEMBER,\n+  RS_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS,\n+  RS_BUILT_IN_SOURCE_LOCATION,\n+  RS_BUILT_IN_LAST\n+};\n+\n+extern tree\n+convert_to_void (tree expr, impl_conv_void implicit);\n+\n+// The lvalue-to-rvalue conversion (7.1) is applied if and only if the\n+// expression is a glvalue of volatile-qualified type and it is one of the\n+// following:\n+// * ( expression ), where expression is one of these expressions,\n+// * id-expression (8.1.4),\n+// * subscripting (8.2.1),\n+// * class member access (8.2.5),\n+// * indirection (8.3.1),\n+// * pointer-to-member operation (8.5),\n+// * conditional expression (8.16) where both the second and the third\n+//   operands are one of these expressions, or\n+// * comma expression (8.19) where the right operand is one of these\n+//   expressions.\n+extern tree\n+mark_discarded_use (tree expr);\n+\n+// Mark EXP as read, not just set, for set but not used -Wunused warning\n+// purposes.\n+extern void\n+mark_exp_read (tree exp);\n+\n+// We've seen an actual use of EXPR.  Possibly replace an outer variable\n+// reference inside with its constant value or a lambda capture.\n+extern tree\n+mark_use (tree expr, bool rvalue_p, bool read_p, location_t loc,\n+\t  bool reject_builtin);\n+\n+// Called whenever the expression EXPR is used in an rvalue context.\n+// When REJECT_BUILTIN is true the expression is checked to make sure\n+// it doesn't make it possible to obtain the address of a GCC built-in\n+// function with no library fallback (or any of its bits, such as in\n+// a conversion to bool).\n+extern tree\n+mark_rvalue_use (tree e, location_t loc /* = UNKNOWN_LOCATION */,\n+\t\t bool reject_builtin /* = true */);\n+\n+// Called whenever an expression is used in an lvalue context.\n+extern tree\n+mark_lvalue_use (tree expr);\n+\n+// As above, but don't consider this use a read.\n+extern tree\n+mark_lvalue_use_nonread (tree expr);\n+\n+// We are using a reference VAL for its value. Bash that reference all the way\n+// down to its lowest form.\n+extern tree\n+convert_from_reference (tree val);\n+\n+// Subroutine of convert_to_void.  Warn if we're discarding something with\n+// attribute [[nodiscard]].\n+extern void\n+maybe_warn_nodiscard (tree expr, impl_conv_void implicit);\n+\n+extern location_t\n+expr_loc_or_loc (const_tree t, location_t or_loc);\n+\n+extern location_t\n+expr_loc_or_input_loc (const_tree t);\n+\n+// FN is the callee of a CALL_EXPR or AGGR_INIT_EXPR; return the FUNCTION_DECL\n+// if we can.\n+extern tree\n+get_fndecl_from_callee (tree fn);\n+\n+// FIXME some helpers from HIRCompileBase could probably be moved here over time\n+\n+// Return an expression for the address of BASE[INDEX], used in offset intrinsic\n+extern tree\n+pointer_offset_expression (tree base_tree, tree index_tree, location_t locus);\n+\n+/* A tree node, together with a location, so that we can track locations\n+   (and ranges) during parsing.\n+\n+   The location is redundant for node kinds that have locations,\n+   but not all node kinds do (e.g. constants, and references to\n+   params, locals, etc), so we stash a copy here.  */\n+\n+extern location_t rs_expr_location (const_tree);\n+\n+extern int\n+is_empty_class (tree type);\n+\n+extern tree array_type_nelts_top (tree);\n+\n+extern bool\n+is_really_empty_class (tree, bool);\n+\n+extern bool builtin_valid_in_constant_expr_p (const_tree);\n+\n+extern bool maybe_constexpr_fn (tree);\n+\n+extern bool var_in_maybe_constexpr_fn (tree);\n+\n+extern int\n+rs_type_quals (const_tree type);\n+\n+extern bool decl_maybe_constant_var_p (tree);\n+\n+extern tree\n+rs_walk_subtrees (tree *, int *, walk_tree_fn, void *, hash_set<tree> *);\n+#define rs_walk_tree(tp, func, data, pset)                                     \\\n+  walk_tree_1 (tp, func, data, pset, rs_walk_subtrees)\n+#define rs_walk_tree_without_duplicates(tp, func, data)                        \\\n+  walk_tree_without_duplicates_1 (tp, func, data, rs_walk_subtrees)\n+\n+// forked from gcc/cp/cp-tree.h cp_expr_loc_or_loc\n+\n+inline location_t\n+rs_expr_loc_or_loc (const_tree t, location_t or_loc)\n+{\n+  location_t loc = rs_expr_location (t);\n+  if (loc == UNKNOWN_LOCATION)\n+    loc = or_loc;\n+  return loc;\n+}\n+\n+// forked from gcc/cp/cp-tree.h cp_expr_loc_or_input_loc\n+\n+inline location_t\n+rs_expr_loc_or_input_loc (const_tree t)\n+{\n+  return rs_expr_loc_or_loc (t, input_location);\n+}\n+\n+} // namespace Rust\n+\n+#endif // RUST_TREE"}, {"sha": "126283c1a54f38e7f1763c3f35abe812fbcdd880", "filename": "gcc/rust/rust-backend.h", "status": "added", "additions": 506, "deletions": 0, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=15f04af347e3b65f436808077cbac4fa566019f9", "patch": "@@ -0,0 +1,506 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_BACKEND_H\n+#define RUST_BACKEND_H\n+\n+#include <gmp.h>\n+#include <mpfr.h>\n+#include <mpc.h>\n+\n+#include \"rust-location.h\"\n+#include \"rust-linemap.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"operator.h\"\n+#include \"tree.h\"\n+\n+// Pointers to these types are created by the backend, passed to the\n+// frontend, and passed back to the backend.  The types must be\n+// defined by the backend using these names.\n+\n+// The backend representation of a variable.\n+class Bvariable;\n+\n+// The backend interface.  This is a pure abstract class that a\n+// specific backend will implement.\n+\n+class Backend\n+{\n+public:\n+  virtual ~Backend () {}\n+\n+  // Name/type/location.  Used for function parameters, struct fields,\n+  // interface methods.\n+  struct typed_identifier\n+  {\n+    std::string name;\n+    tree type;\n+    Location location;\n+\n+    typed_identifier ()\n+      : name (), type (NULL_TREE), location (Linemap::unknown_location ())\n+    {}\n+\n+    typed_identifier (const std::string &a_name, tree a_type,\n+\t\t      Location a_location)\n+      : name (a_name), type (a_type), location (a_location)\n+    {}\n+  };\n+\n+  // debug\n+  virtual void debug (tree) = 0;\n+  virtual void debug (Bvariable *) = 0;\n+\n+  virtual tree get_identifier_node (const std::string &str) = 0;\n+\n+  // Types.\n+\n+  // get unit-type\n+  virtual tree unit_type () = 0;\n+\n+  // Get the unnamed boolean type.\n+  virtual tree bool_type () = 0;\n+\n+  // Get the char type\n+  virtual tree char_type () = 0;\n+\n+  // Get the wchar type\n+  virtual tree wchar_type () = 0;\n+\n+  // Get the Host pointer size in bits\n+  virtual int get_pointer_size () = 0;\n+\n+  // Get the raw str type const char*\n+  virtual tree raw_str_type () = 0;\n+\n+  // Get an unnamed integer type with the given signedness and number\n+  // of bits.\n+  virtual tree integer_type (bool is_unsigned, int bits) = 0;\n+\n+  // Get an unnamed floating point type with the given number of bits\n+  // (32 or 64).\n+  virtual tree float_type (int bits) = 0;\n+\n+  // Get an unnamed complex type with the given number of bits (64 or 128).\n+  virtual tree complex_type (int bits) = 0;\n+\n+  // Get a pointer type.\n+  virtual tree pointer_type (tree to_type) = 0;\n+\n+  // Get a reference type.\n+  virtual tree reference_type (tree to_type) = 0;\n+\n+  // make type immutable\n+  virtual tree immutable_type (tree base) = 0;\n+\n+  // Get a function type.  The receiver, parameter, and results are\n+  // generated from the types in the Function_type.  The Function_type\n+  // is provided so that the names are available.  This should return\n+  // not the type of a Go function (which is a pointer to a struct)\n+  // but the type of a C function pointer (which will be used as the\n+  // type of the first field of the struct).  If there is more than\n+  // one result, RESULT_STRUCT is a struct type to hold the results,\n+  // and RESULTS may be ignored; if there are zero or one results,\n+  // RESULT_STRUCT is NULL.\n+  virtual tree function_type (const typed_identifier &receiver,\n+\t\t\t      const std::vector<typed_identifier> &parameters,\n+\t\t\t      const std::vector<typed_identifier> &results,\n+\t\t\t      tree result_struct, Location location)\n+    = 0;\n+\n+  virtual tree\n+  function_type_varadic (const typed_identifier &receiver,\n+\t\t\t const std::vector<typed_identifier> &parameters,\n+\t\t\t const std::vector<typed_identifier> &results,\n+\t\t\t tree result_struct, Location location)\n+    = 0;\n+\n+  virtual tree function_ptr_type (tree result,\n+\t\t\t\t  const std::vector<tree> &praameters,\n+\t\t\t\t  Location location)\n+    = 0;\n+\n+  // Get a struct type.\n+  virtual tree struct_type (const std::vector<typed_identifier> &fields) = 0;\n+\n+  // Get a union type.\n+  virtual tree union_type (const std::vector<typed_identifier> &fields) = 0;\n+\n+  // Get an array type.\n+  virtual tree array_type (tree element_type, tree length) = 0;\n+\n+  // Return a named version of a type.  The location is the location\n+  // of the type definition.  This will not be called for a type\n+  // created via placeholder_pointer_type, placeholder_struct_type, or\n+  // placeholder_array_type..  (It may be called for a pointer,\n+  // struct, or array type in a case like \"type P *byte; type Q P\".)\n+  virtual tree named_type (const std::string &name, tree, Location) = 0;\n+\n+  // Return the size of a type.\n+  virtual int64_t type_size (tree) = 0;\n+\n+  // Return the alignment of a type.\n+  virtual int64_t type_alignment (tree) = 0;\n+\n+  // Return the alignment of a struct field of this type.  This is\n+  // normally the same as type_alignment, but not always.\n+  virtual int64_t type_field_alignment (tree) = 0;\n+\n+  // Return the offset of field INDEX in a struct type.  INDEX is the\n+  // entry in the FIELDS std::vector parameter of struct_type or\n+  // set_placeholder_struct_type.\n+  virtual int64_t type_field_offset (tree, size_t index) = 0;\n+\n+  // Expressions.\n+\n+  // Return an expression for a zero value of the given type.  This is\n+  // used for cases such as local variable initialization and\n+  // converting nil to other types.\n+  virtual tree zero_expression (tree) = 0;\n+\n+  virtual tree unit_expression () = 0;\n+\n+  // Create a reference to a variable.\n+  virtual tree var_expression (Bvariable *var, Location) = 0;\n+\n+  // Return an expression for the multi-precision integer VAL in BTYPE.\n+  virtual tree integer_constant_expression (tree btype, mpz_t val) = 0;\n+\n+  // Return an expression for the floating point value VAL in BTYPE.\n+  virtual tree float_constant_expression (tree btype, mpfr_t val) = 0;\n+\n+  // Return an expression for the complex value VAL in BTYPE.\n+  virtual tree complex_constant_expression (tree btype, mpc_t val) = 0;\n+\n+  // Return an expression for the string value VAL.\n+  virtual tree string_constant_expression (const std::string &val) = 0;\n+\n+  // Get a char literal\n+  virtual tree char_constant_expression (char c) = 0;\n+\n+  // Get a char literal\n+  virtual tree wchar_constant_expression (wchar_t c) = 0;\n+\n+  // Return an expression for the boolean value VAL.\n+  virtual tree boolean_constant_expression (bool val) = 0;\n+\n+  // Return an expression for the real part of BCOMPLEX.\n+  virtual tree real_part_expression (tree bcomplex, Location) = 0;\n+\n+  // Return an expression for the imaginary part of BCOMPLEX.\n+  virtual tree imag_part_expression (tree bcomplex, Location) = 0;\n+\n+  // Return an expression for the complex number (BREAL, BIMAG).\n+  virtual tree complex_expression (tree breal, tree bimag, Location) = 0;\n+\n+  // Return an expression that converts EXPR to TYPE.\n+  virtual tree convert_expression (tree type, tree expr, Location) = 0;\n+\n+  // Return an expression for the field at INDEX in BSTRUCT.\n+  virtual tree struct_field_expression (tree bstruct, size_t index, Location)\n+    = 0;\n+\n+  // Create an expression that executes BSTAT before BEXPR.\n+  virtual tree compound_expression (tree bstat, tree bexpr, Location) = 0;\n+\n+  // Return an expression that executes THEN_EXPR if CONDITION is true, or\n+  // ELSE_EXPR otherwise and returns the result as type BTYPE, within the\n+  // specified function FUNCTION.  ELSE_EXPR may be NULL.  BTYPE may be NULL.\n+  virtual tree conditional_expression (tree function, tree btype,\n+\t\t\t\t       tree condition, tree then_expr,\n+\t\t\t\t       tree else_expr, Location)\n+    = 0;\n+\n+  // Return an expression for the negation operation OP EXPR.\n+  // Supported values of OP are enumerated in NegationOperator.\n+  virtual tree negation_expression (NegationOperator op, tree expr, Location)\n+    = 0;\n+\n+  // Return an expression for the operation LEFT OP RIGHT.\n+  // Supported values of OP are enumerated in ArithmeticOrLogicalOperator.\n+  virtual tree arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t\t tree left, tree right,\n+\t\t\t\t\t\t Location)\n+    = 0;\n+\n+  // Return an expression for the operation LEFT OP RIGHT.\n+  // Supported values of OP are enumerated in ComparisonOperator.\n+  virtual tree comparison_expression (ComparisonOperator op, tree left,\n+\t\t\t\t      tree right, Location)\n+    = 0;\n+\n+  // Return an expression for the operation LEFT OP RIGHT.\n+  // Supported values of OP are enumerated in LazyBooleanOperator.\n+  virtual tree lazy_boolean_expression (LazyBooleanOperator op, tree left,\n+\t\t\t\t\ttree right, Location)\n+    = 0;\n+\n+  // Return an expression that constructs BTYPE with VALS.  BTYPE must be the\n+  // backend representation a of struct.  VALS must be in the same order as the\n+  // corresponding fields in BTYPE.\n+  virtual tree constructor_expression (tree btype, bool is_variant,\n+\t\t\t\t       const std::vector<tree> &vals, int,\n+\t\t\t\t       Location)\n+    = 0;\n+\n+  // Return an expression that constructs an array of BTYPE with INDEXES and\n+  // VALS.  INDEXES and VALS must have the same amount of elements. Each index\n+  // in INDEXES must be in the same order as the corresponding value in VALS.\n+  virtual tree\n+  array_constructor_expression (tree btype,\n+\t\t\t\tconst std::vector<unsigned long> &indexes,\n+\t\t\t\tconst std::vector<tree> &vals, Location)\n+    = 0;\n+\n+  virtual tree array_initializer (tree, tree, tree, tree, tree, tree *,\n+\t\t\t\t  Location)\n+    = 0;\n+\n+  // Return an expression for ARRAY[INDEX] as an l-value.  ARRAY is a valid\n+  // fixed-length array, not a slice.\n+  virtual tree array_index_expression (tree array, tree index, Location) = 0;\n+\n+  // Create an expression for a call to FN with ARGS, taking place within\n+  // caller CALLER.\n+  virtual tree call_expression (tree fn, const std::vector<tree> &args,\n+\t\t\t\ttree static_chain, Location)\n+    = 0;\n+\n+  // Statements.\n+\n+  // Create a variable initialization statement in the specified\n+  // function.  This initializes a local variable at the point in the\n+  // program flow where it is declared.\n+  virtual tree init_statement (tree, Bvariable *var, tree init) = 0;\n+\n+  // Create an assignment statement within the specified function.\n+  virtual tree assignment_statement (tree lhs, tree rhs, Location) = 0;\n+\n+  // Create a return statement, passing the representation of the\n+  // function and the list of values to return.\n+  virtual tree return_statement (tree, const std::vector<tree> &, Location) = 0;\n+\n+  // Create an if statement within a function.  ELSE_BLOCK may be NULL.\n+  virtual tree if_statement (tree, tree condition, tree then_block,\n+\t\t\t     tree else_block, Location)\n+    = 0;\n+\n+  // infinite loop expressions\n+  virtual tree loop_expression (tree body, Location) = 0;\n+\n+  // exit expressions\n+  virtual tree exit_expression (tree condition, Location) = 0;\n+\n+  // Create a single statement from two statements.\n+  virtual tree compound_statement (tree, tree) = 0;\n+\n+  // Create a single statement from a list of statements.\n+  virtual tree statement_list (const std::vector<tree> &) = 0;\n+\n+  // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if\n+  // an exception occurs. EXCEPT_STMT may be NULL.  FINALLY_STMT may be NULL and\n+  // if not NULL, it will always be executed.  This is used for handling defers\n+  // in Go functions.  In C++, the resulting code is of this form:\n+  //   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n+  virtual tree exception_handler_statement (tree bstat, tree except_stmt,\n+\t\t\t\t\t    tree finally_stmt, Location)\n+    = 0;\n+\n+  // Blocks.\n+\n+  // Create a block.  The frontend will call this function when it\n+  // starts converting a block within a function.  FUNCTION is the\n+  // current function.  ENCLOSING is the enclosing block; it will be\n+  // NULL for the top-level block in a function.  VARS is the list of\n+  // local variables defined within this block; each entry will be\n+  // created by the local_variable function.  START_LOCATION is the\n+  // location of the start of the block, more or less the location of\n+  // the initial curly brace.  END_LOCATION is the location of the end\n+  // of the block, more or less the location of the final curly brace.\n+  // The statements will be added after the block is created.\n+  virtual tree block (tree function, tree enclosing,\n+\t\t      const std::vector<Bvariable *> &vars,\n+\t\t      Location start_location, Location end_location)\n+    = 0;\n+\n+  // Add the statements to a block.  The block is created first.  Then\n+  // the statements are created.  Then the statements are added to the\n+  // block.  This will called exactly once per block.  The vector may\n+  // be empty if there are no statements.\n+  virtual void block_add_statements (tree, const std::vector<tree> &) = 0;\n+\n+  // Variables.\n+\n+  // Create an error variable.  This is used for cases which should\n+  // not occur in a correct program, in order to keep the compilation\n+  // going without crashing.\n+  virtual Bvariable *error_variable () = 0;\n+\n+  // Create a global variable. NAME is the package-qualified name of\n+  // the variable.  ASM_NAME is the encoded identifier for the\n+  // variable, incorporating the package, and made safe for the\n+  // assembler.  BTYPE is the type of the variable.  IS_EXTERNAL is\n+  // true if the variable is defined in some other package.  IS_HIDDEN\n+  // is true if the variable is not exported (name begins with a lower\n+  // case letter).  IN_UNIQUE_SECTION is true if the variable should\n+  // be put into a unique section if possible; this is intended to\n+  // permit the linker to garbage collect the variable if it is not\n+  // referenced.  LOCATION is where the variable was defined.\n+  virtual Bvariable *global_variable (const std::string &name,\n+\t\t\t\t      const std::string &asm_name, tree btype,\n+\t\t\t\t      bool is_external, bool is_hidden,\n+\t\t\t\t      bool in_unique_section, Location location)\n+    = 0;\n+\n+  // A global variable will 1) be initialized to zero, or 2) be\n+  // initialized to a constant value, or 3) be initialized in the init\n+  // function.  In case 2, the frontend will call\n+  // global_variable_set_init to set the initial value.  If this is\n+  // not called, the backend should initialize a global variable to 0.\n+  // The init function may then assign a value to it.\n+  virtual void global_variable_set_init (Bvariable *, tree) = 0;\n+\n+  // Create a local variable.  The frontend will create the local\n+  // variables first, and then create the block which contains them.\n+  // FUNCTION is the function in which the variable is defined.  NAME\n+  // is the name of the variable.  TYPE is the type.  DECL_VAR, if not\n+  // null, gives the location at which the value of this variable may\n+  // be found, typically used to create an inner-scope reference to an\n+  // outer-scope variable, to extend the lifetime of the variable beyond\n+  // the inner scope.  IS_ADDRESS_TAKEN is true if the address of this\n+  // variable is taken (this implies that the address does not escape\n+  // the function, as otherwise the variable would be on the heap).\n+  // LOCATION is where the variable is defined.  For each local variable\n+  // the frontend will call init_statement to set the initial value.\n+  virtual Bvariable *local_variable (tree function, const std::string &name,\n+\t\t\t\t     tree type, Bvariable *decl_var,\n+\t\t\t\t     Location location)\n+    = 0;\n+\n+  // Create a function parameter.  This is an incoming parameter, not\n+  // a result parameter (result parameters are treated as local\n+  // variables).  The arguments are as for local_variable.\n+  virtual Bvariable *parameter_variable (tree function, const std::string &name,\n+\t\t\t\t\t tree type, Location location)\n+    = 0;\n+\n+  // Create a static chain parameter.  This is the closure parameter.\n+  virtual Bvariable *static_chain_variable (tree function,\n+\t\t\t\t\t    const std::string &name, tree type,\n+\t\t\t\t\t    Location location)\n+    = 0;\n+\n+  // Create a temporary variable.  A temporary variable has no name,\n+  // just a type.  We pass in FUNCTION and BLOCK in case they are\n+  // needed.  If INIT is not NULL, the variable should be initialized\n+  // to that value.  Otherwise the initial value is irrelevant--the\n+  // backend does not have to explicitly initialize it to zero.\n+  // ADDRESS_IS_TAKEN is true if the programs needs to take the\n+  // address of this temporary variable.  LOCATION is the location of\n+  // the statement or expression which requires creating the temporary\n+  // variable, and may not be very useful.  This function should\n+  // return a variable which can be referenced later and should set\n+  // *PSTATEMENT to a statement which initializes the variable.\n+  virtual Bvariable *temporary_variable (tree, tree, tree, tree init,\n+\t\t\t\t\t bool address_is_taken,\n+\t\t\t\t\t Location location, tree *pstatement)\n+    = 0;\n+\n+  // Labels.\n+\n+  // Create a new label.  NAME will be empty if this is a label\n+  // created by the frontend for a loop construct.  The location is\n+  // where the label is defined.\n+  virtual tree label (tree, const std::string &name, Location) = 0;\n+\n+  // Create a statement which defines a label.  This statement will be\n+  // put into the codestream at the point where the label should be\n+  // defined.\n+  virtual tree label_definition_statement (tree) = 0;\n+\n+  // Create a goto statement to a label.\n+  virtual tree goto_statement (tree, Location) = 0;\n+\n+  // Create an expression for the address of a label.  This is used to\n+  // get the return address of a deferred function which may call\n+  // recover.\n+  virtual tree label_address (tree, Location) = 0;\n+\n+  // Functions.\n+\n+  // Bit flags to pass to the function method.\n+\n+  // Set if this is a function declaration rather than a definition;\n+  // the definition will be in another compilation unit.\n+  static const unsigned int function_is_declaration = 1 << 0;\n+\n+  // Set if the function should never be inlined because they call\n+  // recover and must be visible for correct panic recovery.\n+  static const unsigned int function_is_uninlinable = 1 << 1;\n+\n+  // Set if the function does not return.  This is set for the\n+  // implementation of panic.\n+  static const unsigned int function_does_not_return = 1 << 2;\n+\n+  // Set if the function should be put in a unique section if\n+  // possible.  This is used for field tracking.\n+  static const unsigned int function_in_unique_section = 1 << 3;\n+\n+  // Declare or define a function of FNTYPE.\n+  // NAME is the Go name of the function.  ASM_NAME, if not the empty\n+  // string, is the name that should be used in the symbol table; this\n+  // will be non-empty if a magic extern comment is used.  FLAGS is\n+  // bit flags described above.\n+  virtual tree function (tree fntype, const std::string &name,\n+\t\t\t const std::string &asm_name, unsigned int flags,\n+\t\t\t Location)\n+    = 0;\n+\n+  // Create a statement that runs all deferred calls for FUNCTION.  This should\n+  // be a statement that looks like this in C++:\n+  //   finish:\n+  //     try { DEFER_RETURN; } catch { CHECK_DEFER; goto finish; }\n+  virtual tree function_defer_statement (tree function, tree undefer,\n+\t\t\t\t\t tree check_defer, Location)\n+    = 0;\n+\n+  // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n+  // This will only be called for a function definition.  Returns true on\n+  // success, false on failure.\n+  virtual bool\n+  function_set_parameters (tree function,\n+\t\t\t   const std::vector<Bvariable *> &param_vars)\n+    = 0;\n+\n+  // Utility.\n+\n+  // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n+  // FUNCTION_DECLS, and VARIABLE_DECLS declared globally.\n+  virtual void\n+  write_global_definitions (const std::vector<tree> &type_decls,\n+\t\t\t    const std::vector<tree> &constant_decls,\n+\t\t\t    const std::vector<tree> &function_decls,\n+\t\t\t    const std::vector<Bvariable *> &variable_decls)\n+    = 0;\n+\n+  // Write SIZE bytes of export data from BYTES to the proper\n+  // section in the output object file.\n+  virtual void write_export_data (const char *bytes, unsigned int size) = 0;\n+};\n+\n+#endif // RUST_BACKEND_H"}, {"sha": "3a682fc01278fe0bb93f6befd88a7eb343d71987", "filename": "gcc/rust/rust-gcc.cc", "status": "added", "additions": 2718, "deletions": 0, "changes": 2718, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f04af347e3b65f436808077cbac4fa566019f9/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=15f04af347e3b65f436808077cbac4fa566019f9", "patch": "@@ -0,0 +1,2718 @@\n+// rust-gcc.cc -- Rust frontend to gcc IR.\n+// Copyright (C) 2011-2022 Free Software Foundation, Inc.\n+// Contributed by Ian Lance Taylor, Google.\n+// forked from gccgo\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-system.h\"\n+\n+// This has to be included outside of extern \"C\", so we have to\n+// include it here before tree.h includes it later.\n+#include <gmp.h>\n+\n+#include \"tree.h\"\n+#include \"opts.h\"\n+#include \"fold-const.h\"\n+#include \"stringpool.h\"\n+#include \"stor-layout.h\"\n+#include \"varasm.h\"\n+#include \"tree-iterator.h\"\n+#include \"tm.h\"\n+#include \"function.h\"\n+#include \"cgraph.h\"\n+#include \"convert.h\"\n+#include \"gimple-expr.h\"\n+#include \"gimplify.h\"\n+#include \"langhooks.h\"\n+#include \"toplev.h\"\n+#include \"output.h\"\n+#include \"realmpfr.h\"\n+#include \"builtins.h\"\n+#include \"print-tree.h\"\n+#include \"attribs.h\"\n+\n+#include \"rust-location.h\"\n+#include \"rust-linemap.h\"\n+#include \"rust-backend.h\"\n+#include \"rust-object-export.h\"\n+\n+#include \"backend/rust-tree.h\"\n+\n+// TODO: this will have to be significantly modified to work with Rust\n+\n+// Bvariable is a bit more complicated, because of zero-sized types.\n+// The GNU linker does not permit dynamic variables with zero size.\n+// When we see such a variable, we generate a version of the type with\n+// non-zero size.  However, when referring to the global variable, we\n+// want an expression of zero size; otherwise, if, say, the global\n+// variable is passed to a function, we will be passing a\n+// non-zero-sized value to a zero-sized value, which can lead to a\n+// miscompilation.\n+\n+class Bvariable\n+{\n+public:\n+  Bvariable (tree t) : t_ (t), orig_type_ (NULL) {}\n+\n+  Bvariable (tree t, tree orig_type) : t_ (t), orig_type_ (orig_type) {}\n+\n+  // Get the tree for use as an expression.\n+  tree get_tree (Location) const;\n+\n+  // Get the actual decl;\n+  tree get_decl () const { return this->t_; }\n+\n+private:\n+  tree t_;\n+  tree orig_type_;\n+};\n+\n+// Get the tree of a variable for use as an expression.  If this is a\n+// zero-sized global, create an expression that refers to the decl but\n+// has zero size.\n+tree\n+Bvariable::get_tree (Location location) const\n+{\n+  if (this->t_ == error_mark_node)\n+    return error_mark_node;\n+\n+  TREE_USED (this->t_) = 1;\n+  if (this->orig_type_ == NULL || TREE_TYPE (this->t_) == this->orig_type_)\n+    {\n+      return this->t_;\n+    }\n+\n+  // Return *(orig_type*)&decl.  */\n+  tree t = build_fold_addr_expr_loc (location.gcc_location (), this->t_);\n+  t = fold_build1_loc (location.gcc_location (), NOP_EXPR,\n+\t\t       build_pointer_type (this->orig_type_), t);\n+  return build_fold_indirect_ref_loc (location.gcc_location (), t);\n+}\n+\n+// This file implements the interface between the Rust frontend proper\n+// and the gcc IR.  This implements specific instantiations of\n+// abstract classes defined by the Rust frontend proper.  The Rust\n+// frontend proper class methods of these classes to generate the\n+// backend representation.\n+\n+class Gcc_backend : public Backend\n+{\n+public:\n+  Gcc_backend ();\n+\n+  void debug (tree t) { debug_tree (t); };\n+  void debug (Bvariable *t) { debug_tree (t->get_decl ()); };\n+\n+  tree get_identifier_node (const std::string &str)\n+  {\n+    return get_identifier_with_length (str.data (), str.length ());\n+  }\n+\n+  // Types.\n+\n+  tree unit_type ()\n+  {\n+    static tree unit_type;\n+    if (unit_type == nullptr)\n+      {\n+\tauto unit_type_node = struct_type ({});\n+\tunit_type = named_type (\"()\", unit_type_node,\n+\t\t\t\t::Linemap::predeclared_location ());\n+      }\n+\n+    return unit_type;\n+  }\n+\n+  tree bool_type () { return boolean_type_node; }\n+\n+  tree char_type () { return char_type_node; }\n+\n+  tree wchar_type ()\n+  {\n+    tree wchar = make_unsigned_type (32);\n+    TYPE_STRING_FLAG (wchar) = 1;\n+    return wchar;\n+  }\n+\n+  int get_pointer_size ();\n+\n+  tree raw_str_type ();\n+\n+  tree integer_type (bool, int);\n+\n+  tree float_type (int);\n+\n+  tree complex_type (int);\n+\n+  tree pointer_type (tree);\n+\n+  tree reference_type (tree);\n+\n+  tree immutable_type (tree);\n+\n+  tree function_type (const typed_identifier &,\n+\t\t      const std::vector<typed_identifier> &,\n+\t\t      const std::vector<typed_identifier> &, tree,\n+\t\t      const Location);\n+\n+  tree function_type_varadic (const typed_identifier &,\n+\t\t\t      const std::vector<typed_identifier> &,\n+\t\t\t      const std::vector<typed_identifier> &, tree,\n+\t\t\t      const Location);\n+\n+  tree function_ptr_type (tree, const std::vector<tree> &, Location);\n+\n+  tree struct_type (const std::vector<typed_identifier> &);\n+\n+  tree union_type (const std::vector<typed_identifier> &);\n+\n+  tree array_type (tree, tree);\n+\n+  tree named_type (const std::string &, tree, Location);\n+\n+  int64_t type_size (tree);\n+\n+  int64_t type_alignment (tree);\n+\n+  int64_t type_field_alignment (tree);\n+\n+  int64_t type_field_offset (tree, size_t index);\n+\n+  // Expressions.\n+\n+  tree zero_expression (tree);\n+\n+  tree unit_expression () { return integer_zero_node; }\n+\n+  tree var_expression (Bvariable *var, Location);\n+\n+  tree integer_constant_expression (tree type, mpz_t val);\n+\n+  tree float_constant_expression (tree type, mpfr_t val);\n+\n+  tree complex_constant_expression (tree type, mpc_t val);\n+\n+  tree string_constant_expression (const std::string &val);\n+\n+  tree wchar_constant_expression (wchar_t c);\n+\n+  tree char_constant_expression (char c);\n+\n+  tree boolean_constant_expression (bool val);\n+\n+  tree real_part_expression (tree bcomplex, Location);\n+\n+  tree imag_part_expression (tree bcomplex, Location);\n+\n+  tree complex_expression (tree breal, tree bimag, Location);\n+\n+  tree convert_expression (tree type, tree expr, Location);\n+\n+  tree struct_field_expression (tree, size_t, Location);\n+\n+  tree compound_expression (tree, tree, Location);\n+\n+  tree conditional_expression (tree, tree, tree, tree, tree, Location);\n+\n+  tree negation_expression (NegationOperator op, tree expr, Location);\n+\n+  tree arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t tree left, tree right, Location);\n+\n+  tree comparison_expression (ComparisonOperator op, tree left, tree right,\n+\t\t\t      Location);\n+\n+  tree lazy_boolean_expression (LazyBooleanOperator op, tree left, tree right,\n+\t\t\t\tLocation);\n+\n+  tree constructor_expression (tree, bool, const std::vector<tree> &, int,\n+\t\t\t       Location);\n+\n+  tree array_constructor_expression (tree, const std::vector<unsigned long> &,\n+\t\t\t\t     const std::vector<tree> &, Location);\n+\n+  tree array_initializer (tree, tree, tree, tree, tree, tree *, Location);\n+\n+  tree array_index_expression (tree array, tree index, Location);\n+\n+  tree call_expression (tree fn, const std::vector<tree> &args,\n+\t\t\ttree static_chain, Location);\n+\n+  // Statements.\n+\n+  tree init_statement (tree, Bvariable *var, tree init);\n+\n+  tree assignment_statement (tree lhs, tree rhs, Location);\n+\n+  tree return_statement (tree, const std::vector<tree> &, Location);\n+\n+  tree if_statement (tree, tree condition, tree then_block, tree else_block,\n+\t\t     Location);\n+\n+  tree compound_statement (tree, tree);\n+\n+  tree statement_list (const std::vector<tree> &);\n+\n+  tree exception_handler_statement (tree bstat, tree except_stmt,\n+\t\t\t\t    tree finally_stmt, Location);\n+\n+  tree loop_expression (tree body, Location);\n+\n+  tree exit_expression (tree condition, Location);\n+\n+  // Blocks.\n+\n+  tree block (tree, tree, const std::vector<Bvariable *> &, Location, Location);\n+\n+  void block_add_statements (tree, const std::vector<tree> &);\n+\n+  // Variables.\n+\n+  Bvariable *error_variable () { return new Bvariable (error_mark_node); }\n+\n+  Bvariable *global_variable (const std::string &var_name,\n+\t\t\t      const std::string &asm_name, tree type,\n+\t\t\t      bool is_external, bool is_hidden,\n+\t\t\t      bool in_unique_section, Location location);\n+\n+  void global_variable_set_init (Bvariable *, tree);\n+\n+  Bvariable *local_variable (tree, const std::string &, tree, Bvariable *,\n+\t\t\t     Location);\n+\n+  Bvariable *parameter_variable (tree, const std::string &, tree, Location);\n+\n+  Bvariable *static_chain_variable (tree, const std::string &, tree, Location);\n+\n+  Bvariable *temporary_variable (tree, tree, tree, tree, bool, Location,\n+\t\t\t\t tree *);\n+\n+  // Labels.\n+\n+  tree label (tree, const std::string &name, Location);\n+\n+  tree label_definition_statement (tree);\n+\n+  tree goto_statement (tree, Location);\n+\n+  tree label_address (tree, Location);\n+\n+  // Functions.\n+\n+  tree function (tree fntype, const std::string &name,\n+\t\t const std::string &asm_name, unsigned int flags, Location);\n+\n+  tree function_defer_statement (tree function, tree undefer, tree defer,\n+\t\t\t\t Location);\n+\n+  bool function_set_parameters (tree function,\n+\t\t\t\tconst std::vector<Bvariable *> &);\n+\n+  void write_global_definitions (const std::vector<tree> &,\n+\t\t\t\t const std::vector<tree> &,\n+\t\t\t\t const std::vector<tree> &,\n+\t\t\t\t const std::vector<Bvariable *> &);\n+\n+  void write_export_data (const char *bytes, unsigned int size);\n+\n+private:\n+  tree fill_in_fields (tree, const std::vector<typed_identifier> &);\n+\n+  tree fill_in_array (tree, tree, tree);\n+\n+  tree non_zero_size_type (tree);\n+\n+  tree convert_tree (tree, tree, Location);\n+};\n+\n+// A helper function to create a GCC identifier from a C++ string.\n+\n+static inline tree\n+get_identifier_from_string (const std::string &str)\n+{\n+  return get_identifier_with_length (str.data (), str.length ());\n+}\n+\n+// Define the built-in functions that are exposed to GCCRust.\n+\n+Gcc_backend::Gcc_backend ()\n+{\n+  /* We need to define the fetch_and_add functions, since we use them\n+     for ++ and --.  */\n+  // tree t = this->integer_type (true, BITS_PER_UNIT)->get_tree ();\n+  // tree p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n+  // this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_1,\n+  // \"__sync_fetch_and_add_1\",\n+  //       \t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+\n+  // t = this->integer_type (true, BITS_PER_UNIT * 2)->get_tree ();\n+  // p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n+  // this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_2,\n+  // \"__sync_fetch_and_add_2\",\n+  //       \t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+\n+  // t = this->integer_type (true, BITS_PER_UNIT * 4)->get_tree ();\n+  // p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n+  // this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_4,\n+  // \"__sync_fetch_and_add_4\",\n+  //       \t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+\n+  // t = this->integer_type (true, BITS_PER_UNIT * 8)->get_tree ();\n+  // p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n+  // this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_8,\n+  // \"__sync_fetch_and_add_8\",\n+  //       \t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+\n+  // // We use __builtin_expect for magic import functions.\n+  // this->define_builtin (BUILT_IN_EXPECT, \"__builtin_expect\", NULL,\n+  //       \t\tbuild_function_type_list (long_integer_type_node,\n+  //       \t\t\t\t\t  long_integer_type_node,\n+  //       \t\t\t\t\t  long_integer_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+\n+  // // We use __builtin_memcmp for struct comparisons.\n+  // this->define_builtin (BUILT_IN_MEMCMP, \"__builtin_memcmp\", \"memcmp\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  const_ptr_type_node,\n+  //       \t\t\t\t\t  const_ptr_type_node,\n+  //       \t\t\t\t\t  size_type_node, NULL_TREE),\n+  //       \t\t0);\n+\n+  // // We use __builtin_memmove for copying data.\n+  // this->define_builtin (BUILT_IN_MEMMOVE, \"__builtin_memmove\", \"memmove\",\n+  //       \t\tbuild_function_type_list (void_type_node, ptr_type_node,\n+  //       \t\t\t\t\t  const_ptr_type_node,\n+  //       \t\t\t\t\t  size_type_node, NULL_TREE),\n+  //       \t\t0);\n+\n+  // // We use __builtin_memset for zeroing data.\n+  // this->define_builtin (BUILT_IN_MEMSET, \"__builtin_memset\", \"memset\",\n+  //       \t\tbuild_function_type_list (void_type_node, ptr_type_node,\n+  //       \t\t\t\t\t  integer_type_node,\n+  //       \t\t\t\t\t  size_type_node, NULL_TREE),\n+  //       \t\t0);\n+\n+  // // Used by runtime/internal/sys and math/bits.\n+  // this->define_builtin (BUILT_IN_CTZ, \"__builtin_ctz\", \"ctz\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_CTZLL, \"__builtin_ctzll\", \"ctzll\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  long_long_unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_CLZ, \"__builtin_clz\", \"clz\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_CLZLL, \"__builtin_clzll\", \"clzll\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  long_long_unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_POPCOUNT, \"__builtin_popcount\", \"popcount\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_POPCOUNTLL, \"__builtin_popcountll\",\n+  //       \t\t\"popcountll\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  long_long_unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_BSWAP16, \"__builtin_bswap16\", \"bswap16\",\n+  //       \t\tbuild_function_type_list (uint16_type_node,\n+  //       \t\t\t\t\t  uint16_type_node, NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_BSWAP32, \"__builtin_bswap32\", \"bswap32\",\n+  //       \t\tbuild_function_type_list (uint32_type_node,\n+  //       \t\t\t\t\t  uint32_type_node, NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_BSWAP64, \"__builtin_bswap64\", \"bswap64\",\n+  //       \t\tbuild_function_type_list (uint64_type_node,\n+  //       \t\t\t\t\t  uint64_type_node, NULL_TREE),\n+  //       \t\tbuiltin_const);\n+\n+  // We provide some functions for the math library.\n+\n+  // We use __builtin_return_address in the thunk we build for\n+  // functions which call recover, and for runtime.getcallerpc.\n+  // t = build_function_type_list (ptr_type_node, unsigned_type_node,\n+  // NULL_TREE); this->define_builtin (BUILT_IN_RETURN_ADDRESS,\n+  // \"__builtin_return_address\",\n+  //       \t\tNULL, t, 0);\n+\n+  // The runtime calls __builtin_dwarf_cfa for runtime.getcallersp.\n+  // t = build_function_type_list (ptr_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_DWARF_CFA, \"__builtin_dwarf_cfa\", NULL, t,\n+  // 0);\n+\n+  // The runtime calls __builtin_extract_return_addr when recording\n+  // the address to which a function returns.\n+  // this->define_builtin (\n+  //   BUILT_IN_EXTRACT_RETURN_ADDR, \"__builtin_extract_return_addr\", NULL,\n+  //   build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE), 0);\n+\n+  // The compiler uses __builtin_trap for some exception handling\n+  // cases.\n+  // this->define_builtin (BUILT_IN_TRAP, \"__builtin_trap\", NULL,\n+  //       \t\tbuild_function_type (void_type_node, void_list_node),\n+  //       \t\tbuiltin_noreturn);\n+\n+  // The runtime uses __builtin_prefetch.\n+  // this->define_builtin (BUILT_IN_PREFETCH, \"__builtin_prefetch\", NULL,\n+  //       \t\tbuild_varargs_function_type_list (void_type_node,\n+  //       \t\t\t\t\t\t  const_ptr_type_node,\n+  //       \t\t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_novops);\n+\n+  // The compiler uses __builtin_unreachable for cases that cannot\n+  // occur.\n+  // this->define_builtin (BUILT_IN_UNREACHABLE, \"__builtin_unreachable\", NULL,\n+  //       \t\tbuild_function_type (void_type_node, void_list_node),\n+  //       \t\tbuiltin_const | builtin_noreturn);\n+\n+  // We provide some atomic functions.\n+  // t = build_function_type_list (uint32_type_node, ptr_type_node,\n+  //       \t\t\tinteger_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_LOAD_4, \"__atomic_load_4\", NULL, t,\n+  // 0);\n+\n+  // t = build_function_type_list (uint64_type_node, ptr_type_node,\n+  //       \t\t\tinteger_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_LOAD_8, \"__atomic_load_8\", NULL, t,\n+  // 0);\n+\n+  // t = build_function_type_list (void_type_node, ptr_type_node,\n+  // uint32_type_node,\n+  //       \t\t\tinteger_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_STORE_4, \"__atomic_store_4\", NULL, t,\n+  //       \t\t0);\n+\n+  // t = build_function_type_list (void_type_node, ptr_type_node,\n+  // uint64_type_node,\n+  //       \t\t\tinteger_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_STORE_8, \"__atomic_store_8\", NULL, t,\n+  //       \t\t0);\n+\n+  // t = build_function_type_list (uint32_type_node, ptr_type_node,\n+  //       \t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_4, \"__atomic_exchange_4\",\n+  // NULL,\n+  //       \t\tt, 0);\n+\n+  // t = build_function_type_list (uint64_type_node, ptr_type_node,\n+  //       \t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_8, \"__atomic_exchange_8\",\n+  // NULL,\n+  //       \t\tt, 0);\n+\n+  // t = build_function_type_list (boolean_type_node, ptr_type_node,\n+  // ptr_type_node,\n+  //       \t\t\tuint32_type_node, boolean_type_node,\n+  //       \t\t\tinteger_type_node, integer_type_node,\n+  //       \t\t\tNULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4,\n+  //       \t\t\"__atomic_compare_exchange_4\", NULL, t, 0);\n+\n+  // t = build_function_type_list (boolean_type_node, ptr_type_node,\n+  // ptr_type_node,\n+  //       \t\t\tuint64_type_node, boolean_type_node,\n+  //       \t\t\tinteger_type_node, integer_type_node,\n+  //       \t\t\tNULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8,\n+  //       \t\t\"__atomic_compare_exchange_8\", NULL, t, 0);\n+\n+  // t = build_function_type_list (uint32_type_node, ptr_type_node,\n+  //       \t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_4, \"__atomic_add_fetch_4\",\n+  //       \t\tNULL, t, 0);\n+\n+  // t = build_function_type_list (uint64_type_node, ptr_type_node,\n+  //       \t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_8, \"__atomic_add_fetch_8\",\n+  //       \t\tNULL, t, 0);\n+\n+  // t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n+  //       \t\t\tunsigned_char_type_node, integer_type_node,\n+  //       \t\t\tNULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_AND_FETCH_1, \"__atomic_and_fetch_1\",\n+  //       \t\tNULL, t, 0);\n+  // this->define_builtin (BUILT_IN_ATOMIC_FETCH_AND_1, \"__atomic_fetch_and_1\",\n+  //       \t\tNULL, t, 0);\n+\n+  // t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n+  //       \t\t\tunsigned_char_type_node, integer_type_node,\n+  //       \t\t\tNULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_OR_FETCH_1, \"__atomic_or_fetch_1\",\n+  // NULL,\n+  //       \t\tt, 0);\n+  // this->define_builtin (BUILT_IN_ATOMIC_FETCH_OR_1, \"__atomic_fetch_or_1\",\n+  // NULL,\n+  //       \t\tt, 0);\n+}\n+\n+// Get an unnamed integer type.\n+\n+int\n+Gcc_backend::get_pointer_size ()\n+{\n+  return POINTER_SIZE;\n+}\n+\n+tree\n+Gcc_backend::raw_str_type ()\n+{\n+  tree char_ptr = build_pointer_type (char_type_node);\n+  tree const_char_type = build_qualified_type (char_ptr, TYPE_QUAL_CONST);\n+  return const_char_type;\n+}\n+\n+tree\n+Gcc_backend::integer_type (bool is_unsigned, int bits)\n+{\n+  tree type;\n+  if (is_unsigned)\n+    {\n+      if (bits == INT_TYPE_SIZE)\n+\ttype = unsigned_type_node;\n+      else if (bits == SHORT_TYPE_SIZE)\n+\ttype = short_unsigned_type_node;\n+      else if (bits == LONG_TYPE_SIZE)\n+\ttype = long_unsigned_type_node;\n+      else if (bits == LONG_LONG_TYPE_SIZE)\n+\ttype = long_long_unsigned_type_node;\n+      else\n+\ttype = make_unsigned_type (bits);\n+    }\n+  else\n+    {\n+      if (bits == INT_TYPE_SIZE)\n+\ttype = integer_type_node;\n+      else if (bits == SHORT_TYPE_SIZE)\n+\ttype = short_integer_type_node;\n+      else if (bits == LONG_TYPE_SIZE)\n+\ttype = long_integer_type_node;\n+      else if (bits == LONG_LONG_TYPE_SIZE)\n+\ttype = long_long_integer_type_node;\n+      else\n+\ttype = make_signed_type (bits);\n+    }\n+  return type;\n+}\n+\n+// Get an unnamed float type.\n+\n+tree\n+Gcc_backend::float_type (int bits)\n+{\n+  tree type;\n+  if (bits == FLOAT_TYPE_SIZE)\n+    type = float_type_node;\n+  else if (bits == DOUBLE_TYPE_SIZE)\n+    type = double_type_node;\n+  else if (bits == LONG_DOUBLE_TYPE_SIZE)\n+    type = long_double_type_node;\n+  else\n+    {\n+      type = make_node (REAL_TYPE);\n+      TYPE_PRECISION (type) = bits;\n+      layout_type (type);\n+    }\n+  return type;\n+}\n+\n+// Get an unnamed complex type.\n+\n+tree\n+Gcc_backend::complex_type (int bits)\n+{\n+  tree type;\n+  if (bits == FLOAT_TYPE_SIZE * 2)\n+    type = complex_float_type_node;\n+  else if (bits == DOUBLE_TYPE_SIZE * 2)\n+    type = complex_double_type_node;\n+  else if (bits == LONG_DOUBLE_TYPE_SIZE * 2)\n+    type = complex_long_double_type_node;\n+  else\n+    {\n+      type = make_node (REAL_TYPE);\n+      TYPE_PRECISION (type) = bits / 2;\n+      layout_type (type);\n+      type = build_complex_type (type);\n+    }\n+  return type;\n+}\n+\n+// Get a pointer type.\n+\n+tree\n+Gcc_backend::pointer_type (tree to_type)\n+{\n+  if (to_type == error_mark_node)\n+    return error_mark_node;\n+  tree type = build_pointer_type (to_type);\n+  return type;\n+}\n+\n+// Get a reference type.\n+\n+tree\n+Gcc_backend::reference_type (tree to_type)\n+{\n+  if (to_type == error_mark_node)\n+    return error_mark_node;\n+  tree type = build_reference_type (to_type);\n+  return type;\n+}\n+\n+// Get immutable type\n+\n+tree\n+Gcc_backend::immutable_type (tree base)\n+{\n+  if (base == error_mark_node)\n+    return error_mark_node;\n+  tree constified = build_qualified_type (base, TYPE_QUAL_CONST);\n+  return constified;\n+}\n+\n+// Make a function type.\n+\n+tree\n+Gcc_backend::function_type (const typed_identifier &receiver,\n+\t\t\t    const std::vector<typed_identifier> &parameters,\n+\t\t\t    const std::vector<typed_identifier> &results,\n+\t\t\t    tree result_struct, Location)\n+{\n+  tree args = NULL_TREE;\n+  tree *pp = &args;\n+  if (receiver.type != NULL_TREE)\n+    {\n+      tree t = receiver.type;\n+      if (t == error_mark_node)\n+\treturn error_mark_node;\n+      *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n+      pp = &TREE_CHAIN (*pp);\n+    }\n+\n+  for (std::vector<typed_identifier>::const_iterator p = parameters.begin ();\n+       p != parameters.end (); ++p)\n+    {\n+      tree t = p->type;\n+      if (t == error_mark_node)\n+\treturn error_mark_node;\n+      *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n+      pp = &TREE_CHAIN (*pp);\n+    }\n+\n+  // Varargs is handled entirely at the Rust level.  When converted to\n+  // GENERIC functions are not varargs.\n+  *pp = void_list_node;\n+\n+  tree result;\n+  if (results.empty ())\n+    result = void_type_node;\n+  else if (results.size () == 1)\n+    result = results.front ().type;\n+  else\n+    {\n+      gcc_assert (result_struct != NULL);\n+      result = result_struct;\n+    }\n+  if (result == error_mark_node)\n+    return error_mark_node;\n+\n+  // The libffi library cannot represent a zero-sized object.  To\n+  // avoid causing confusion on 32-bit SPARC, we treat a function that\n+  // returns a zero-sized value as returning void.  That should do no\n+  // harm since there is no actual value to be returned.  See\n+  // https://gcc.gnu.org/PR72814 for details.\n+  if (result != void_type_node && int_size_in_bytes (result) == 0)\n+    result = void_type_node;\n+\n+  tree fntype = build_function_type (result, args);\n+  if (fntype == error_mark_node)\n+    return error_mark_node;\n+\n+  return build_pointer_type (fntype);\n+}\n+\n+tree\n+Gcc_backend::function_type_varadic (\n+  const typed_identifier &receiver,\n+  const std::vector<typed_identifier> &parameters,\n+  const std::vector<typed_identifier> &results, tree result_struct, Location)\n+{\n+  size_t n = parameters.size () + (receiver.type != NULL_TREE ? 1 : 0);\n+  tree *args = XALLOCAVEC (tree, n);\n+  size_t offs = 0;\n+\n+  if (receiver.type != NULL_TREE)\n+    {\n+      tree t = receiver.type;\n+      if (t == error_mark_node)\n+\treturn error_mark_node;\n+\n+      args[offs++] = t;\n+    }\n+\n+  for (std::vector<typed_identifier>::const_iterator p = parameters.begin ();\n+       p != parameters.end (); ++p)\n+    {\n+      tree t = p->type;\n+      if (t == error_mark_node)\n+\treturn error_mark_node;\n+      args[offs++] = t;\n+    }\n+\n+  tree result;\n+  if (results.empty ())\n+    result = void_type_node;\n+  else if (results.size () == 1)\n+    result = results.front ().type;\n+  else\n+    {\n+      gcc_assert (result_struct != NULL_TREE);\n+      result = result_struct;\n+    }\n+  if (result == error_mark_node)\n+    return error_mark_node;\n+\n+  // The libffi library cannot represent a zero-sized object.  To\n+  // avoid causing confusion on 32-bit SPARC, we treat a function that\n+  // returns a zero-sized value as returning void.  That should do no\n+  // harm since there is no actual value to be returned.  See\n+  // https://gcc.gnu.org/PR72814 for details.\n+  if (result != void_type_node && int_size_in_bytes (result) == 0)\n+    result = void_type_node;\n+\n+  tree fntype = build_varargs_function_type_array (result, n, args);\n+  if (fntype == error_mark_node)\n+    return error_mark_node;\n+\n+  return build_pointer_type (fntype);\n+}\n+\n+tree\n+Gcc_backend::function_ptr_type (tree result_type,\n+\t\t\t\tconst std::vector<tree> &parameters,\n+\t\t\t\tLocation /* locus */)\n+{\n+  tree args = NULL_TREE;\n+  tree *pp = &args;\n+\n+  for (auto &param : parameters)\n+    {\n+      if (param == error_mark_node)\n+\treturn error_mark_node;\n+\n+      *pp = tree_cons (NULL_TREE, param, NULL_TREE);\n+      pp = &TREE_CHAIN (*pp);\n+    }\n+\n+  *pp = void_list_node;\n+\n+  tree result = result_type;\n+  if (result != void_type_node && int_size_in_bytes (result) == 0)\n+    result = void_type_node;\n+\n+  tree fntype = build_function_type (result, args);\n+  if (fntype == error_mark_node)\n+    return error_mark_node;\n+\n+  return build_pointer_type (fntype);\n+}\n+\n+// Make a struct type.\n+\n+tree\n+Gcc_backend::struct_type (const std::vector<typed_identifier> &fields)\n+{\n+  return this->fill_in_fields (make_node (RECORD_TYPE), fields);\n+}\n+\n+// Make a union type.\n+\n+tree\n+Gcc_backend::union_type (const std::vector<typed_identifier> &fields)\n+{\n+  return this->fill_in_fields (make_node (UNION_TYPE), fields);\n+}\n+\n+// Fill in the fields of a struct or union type.\n+\n+tree\n+Gcc_backend::fill_in_fields (tree fill,\n+\t\t\t     const std::vector<typed_identifier> &fields)\n+{\n+  tree field_trees = NULL_TREE;\n+  tree *pp = &field_trees;\n+  for (std::vector<typed_identifier>::const_iterator p = fields.begin ();\n+       p != fields.end (); ++p)\n+    {\n+      tree name_tree = get_identifier_from_string (p->name);\n+      tree type_tree = p->type;\n+      if (type_tree == error_mark_node)\n+\treturn error_mark_node;\n+      tree field = build_decl (p->location.gcc_location (), FIELD_DECL,\n+\t\t\t       name_tree, type_tree);\n+      DECL_CONTEXT (field) = fill;\n+      *pp = field;\n+      pp = &DECL_CHAIN (field);\n+    }\n+  TYPE_FIELDS (fill) = field_trees;\n+  layout_type (fill);\n+\n+  // Because Rust permits converting between named struct types and\n+  // equivalent struct types, for which we use VIEW_CONVERT_EXPR, and\n+  // because we don't try to maintain TYPE_CANONICAL for struct types,\n+  // we need to tell the middle-end to use structural equality.\n+  SET_TYPE_STRUCTURAL_EQUALITY (fill);\n+\n+  return fill;\n+}\n+\n+// Make an array type.\n+\n+tree\n+Gcc_backend::array_type (tree element_type, tree length)\n+{\n+  return this->fill_in_array (make_node (ARRAY_TYPE), element_type, length);\n+}\n+\n+// Fill in an array type.\n+\n+tree\n+Gcc_backend::fill_in_array (tree fill, tree element_type, tree length_tree)\n+{\n+  if (element_type == error_mark_node || length_tree == error_mark_node)\n+    return error_mark_node;\n+\n+  gcc_assert (TYPE_SIZE (element_type) != NULL_TREE);\n+\n+  length_tree = fold_convert (sizetype, length_tree);\n+\n+  // build_index_type takes the maximum index, which is one less than\n+  // the length.\n+  tree index_type_tree = build_index_type (\n+    fold_build2 (MINUS_EXPR, sizetype, length_tree, size_one_node));\n+\n+  TREE_TYPE (fill) = element_type;\n+  TYPE_DOMAIN (fill) = index_type_tree;\n+  TYPE_ADDR_SPACE (fill) = TYPE_ADDR_SPACE (element_type);\n+  layout_type (fill);\n+\n+  if (TYPE_STRUCTURAL_EQUALITY_P (element_type))\n+    SET_TYPE_STRUCTURAL_EQUALITY (fill);\n+  else if (TYPE_CANONICAL (element_type) != element_type\n+\t   || TYPE_CANONICAL (index_type_tree) != index_type_tree)\n+    TYPE_CANONICAL (fill) = build_array_type (TYPE_CANONICAL (element_type),\n+\t\t\t\t\t      TYPE_CANONICAL (index_type_tree));\n+\n+  return fill;\n+}\n+\n+// Return a named version of a type.\n+\n+tree\n+Gcc_backend::named_type (const std::string &name, tree type, Location location)\n+{\n+  if (type == error_mark_node)\n+    return error_mark_node;\n+\n+  // The middle-end expects a basic type to have a name.  In Rust every\n+  // basic type will have a name.  The first time we see a basic type,\n+  // give it whatever Rust name we have at this point.\n+  if (TYPE_NAME (type) == NULL_TREE\n+      && location.gcc_location () == BUILTINS_LOCATION\n+      && (TREE_CODE (type) == INTEGER_TYPE || TREE_CODE (type) == REAL_TYPE\n+\t  || TREE_CODE (type) == COMPLEX_TYPE\n+\t  || TREE_CODE (type) == BOOLEAN_TYPE))\n+    {\n+      tree decl = build_decl (BUILTINS_LOCATION, TYPE_DECL,\n+\t\t\t      get_identifier_from_string (name), type);\n+      TYPE_NAME (type) = decl;\n+      return type;\n+    }\n+\n+  tree copy = build_variant_type_copy (type);\n+  tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n+\t\t\t  get_identifier_from_string (name), copy);\n+  DECL_ORIGINAL_TYPE (decl) = type;\n+  TYPE_NAME (copy) = decl;\n+  return copy;\n+}\n+\n+// Return the size of a type.\n+\n+int64_t\n+Gcc_backend::type_size (tree t)\n+{\n+  if (t == error_mark_node)\n+    return 1;\n+  if (t == void_type_node)\n+    return 0;\n+  t = TYPE_SIZE_UNIT (t);\n+  gcc_assert (tree_fits_uhwi_p (t));\n+  unsigned HOST_WIDE_INT val_wide = TREE_INT_CST_LOW (t);\n+  int64_t ret = static_cast<int64_t> (val_wide);\n+  if (ret < 0 || static_cast<unsigned HOST_WIDE_INT> (ret) != val_wide)\n+    return -1;\n+  return ret;\n+}\n+\n+// Return the alignment of a type.\n+\n+int64_t\n+Gcc_backend::type_alignment (tree t)\n+{\n+  if (t == error_mark_node)\n+    return 1;\n+  return TYPE_ALIGN_UNIT (t);\n+}\n+\n+// Return the alignment of a struct field of type BTYPE.\n+\n+int64_t\n+Gcc_backend::type_field_alignment (tree t)\n+{\n+  if (t == error_mark_node)\n+    return 1;\n+  return rust_field_alignment (t);\n+}\n+\n+// Return the offset of a field in a struct.\n+\n+int64_t\n+Gcc_backend::type_field_offset (tree struct_tree, size_t index)\n+{\n+  if (struct_tree == error_mark_node)\n+    return 0;\n+  gcc_assert (TREE_CODE (struct_tree) == RECORD_TYPE);\n+  tree field = TYPE_FIELDS (struct_tree);\n+  for (; index > 0; --index)\n+    {\n+      field = DECL_CHAIN (field);\n+      gcc_assert (field != NULL_TREE);\n+    }\n+  HOST_WIDE_INT offset_wide = int_byte_position (field);\n+  int64_t ret = static_cast<int64_t> (offset_wide);\n+  gcc_assert (ret == offset_wide);\n+  return ret;\n+}\n+\n+// Return the zero value for a type.\n+\n+tree\n+Gcc_backend::zero_expression (tree t)\n+{\n+  tree ret;\n+  if (t == error_mark_node)\n+    ret = error_mark_node;\n+  else\n+    ret = build_zero_cst (t);\n+  return ret;\n+}\n+\n+// An expression that references a variable.\n+\n+tree\n+Gcc_backend::var_expression (Bvariable *var, Location location)\n+{\n+  return var->get_tree (location);\n+}\n+\n+// Return a typed value as a constant integer.\n+// This function does not release the memory of @val\n+\n+tree\n+Gcc_backend::integer_constant_expression (tree t, mpz_t val)\n+{\n+  if (t == error_mark_node)\n+    return error_mark_node;\n+\n+  tree ret = wide_int_to_tree (t, wi::from_mpz (t, val, true));\n+  return ret;\n+}\n+\n+// Return a typed value as a constant floating-point number.\n+\n+tree\n+Gcc_backend::float_constant_expression (tree t, mpfr_t val)\n+{\n+  tree ret;\n+  if (t == error_mark_node)\n+    return error_mark_node;\n+\n+  REAL_VALUE_TYPE r1;\n+  real_from_mpfr (&r1, val, t, GMP_RNDN);\n+  REAL_VALUE_TYPE r2;\n+  real_convert (&r2, TYPE_MODE (t), &r1);\n+  ret = build_real (t, r2);\n+  return ret;\n+}\n+\n+// Return a typed real and imaginary value as a constant complex number.\n+\n+tree\n+Gcc_backend::complex_constant_expression (tree t, mpc_t val)\n+{\n+  tree ret;\n+  if (t == error_mark_node)\n+    return error_mark_node;\n+\n+  REAL_VALUE_TYPE r1;\n+  real_from_mpfr (&r1, mpc_realref (val), TREE_TYPE (t), GMP_RNDN);\n+  REAL_VALUE_TYPE r2;\n+  real_convert (&r2, TYPE_MODE (TREE_TYPE (t)), &r1);\n+\n+  REAL_VALUE_TYPE r3;\n+  real_from_mpfr (&r3, mpc_imagref (val), TREE_TYPE (t), GMP_RNDN);\n+  REAL_VALUE_TYPE r4;\n+  real_convert (&r4, TYPE_MODE (TREE_TYPE (t)), &r3);\n+\n+  ret = build_complex (t, build_real (TREE_TYPE (t), r2),\n+\t\t       build_real (TREE_TYPE (t), r4));\n+  return ret;\n+}\n+\n+// Make a constant string expression.\n+\n+tree\n+Gcc_backend::string_constant_expression (const std::string &val)\n+{\n+  tree index_type = build_index_type (size_int (val.length ()));\n+  tree const_char_type = build_qualified_type (char_type_node, TYPE_QUAL_CONST);\n+  tree string_type = build_array_type (const_char_type, index_type);\n+  TYPE_STRING_FLAG (string_type) = 1;\n+  tree string_val = build_string (val.length (), val.data ());\n+  TREE_TYPE (string_val) = string_type;\n+\n+  return string_val;\n+}\n+\n+tree\n+Gcc_backend::wchar_constant_expression (wchar_t c)\n+{\n+  return build_int_cst (this->wchar_type (), c);\n+}\n+\n+tree\n+Gcc_backend::char_constant_expression (char c)\n+{\n+  return build_int_cst (this->char_type (), c);\n+}\n+\n+// Make a constant boolean expression.\n+\n+tree\n+Gcc_backend::boolean_constant_expression (bool val)\n+{\n+  return val ? boolean_true_node : boolean_false_node;\n+}\n+\n+// Return the real part of a complex expression.\n+\n+tree\n+Gcc_backend::real_part_expression (tree complex_tree, Location location)\n+{\n+  if (complex_tree == error_mark_node)\n+    return error_mark_node;\n+  gcc_assert (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (complex_tree)));\n+  tree ret\n+    = fold_build1_loc (location.gcc_location (), REALPART_EXPR,\n+\t\t       TREE_TYPE (TREE_TYPE (complex_tree)), complex_tree);\n+  return ret;\n+}\n+\n+// Return the imaginary part of a complex expression.\n+\n+tree\n+Gcc_backend::imag_part_expression (tree complex_tree, Location location)\n+{\n+  if (complex_tree == error_mark_node)\n+    return error_mark_node;\n+  gcc_assert (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (complex_tree)));\n+  tree ret\n+    = fold_build1_loc (location.gcc_location (), IMAGPART_EXPR,\n+\t\t       TREE_TYPE (TREE_TYPE (complex_tree)), complex_tree);\n+  return ret;\n+}\n+\n+// Make a complex expression given its real and imaginary parts.\n+\n+tree\n+Gcc_backend::complex_expression (tree real_tree, tree imag_tree,\n+\t\t\t\t Location location)\n+{\n+  if (real_tree == error_mark_node || imag_tree == error_mark_node)\n+    return error_mark_node;\n+  gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (real_tree))\n+\t      == TYPE_MAIN_VARIANT (TREE_TYPE (imag_tree)));\n+  gcc_assert (SCALAR_FLOAT_TYPE_P (TREE_TYPE (real_tree)));\n+  tree ret = fold_build2_loc (location.gcc_location (), COMPLEX_EXPR,\n+\t\t\t      build_complex_type (TREE_TYPE (real_tree)),\n+\t\t\t      real_tree, imag_tree);\n+  return ret;\n+}\n+\n+// An expression that converts an expression to a different type.\n+\n+tree\n+Gcc_backend::convert_expression (tree type_tree, tree expr_tree,\n+\t\t\t\t Location location)\n+{\n+  if (type_tree == error_mark_node || expr_tree == error_mark_node\n+      || TREE_TYPE (expr_tree) == error_mark_node)\n+    return error_mark_node;\n+\n+  tree ret;\n+  if (this->type_size (type_tree) == 0\n+      || TREE_TYPE (expr_tree) == void_type_node)\n+    {\n+      // Do not convert zero-sized types.\n+      ret = expr_tree;\n+    }\n+  else if (TREE_CODE (type_tree) == INTEGER_TYPE)\n+    ret = convert_to_integer (type_tree, expr_tree);\n+  else if (TREE_CODE (type_tree) == REAL_TYPE)\n+    ret = convert_to_real (type_tree, expr_tree);\n+  else if (TREE_CODE (type_tree) == COMPLEX_TYPE)\n+    ret = convert_to_complex (type_tree, expr_tree);\n+  else if (TREE_CODE (type_tree) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (expr_tree)) == INTEGER_TYPE)\n+    ret = convert_to_pointer (type_tree, expr_tree);\n+  else if (TREE_CODE (type_tree) == RECORD_TYPE\n+\t   || TREE_CODE (type_tree) == ARRAY_TYPE)\n+    ret = fold_build1_loc (location.gcc_location (), VIEW_CONVERT_EXPR,\n+\t\t\t   type_tree, expr_tree);\n+  else\n+    ret = fold_convert_loc (location.gcc_location (), type_tree, expr_tree);\n+\n+  return ret;\n+}\n+\n+// Return an expression for the field at INDEX in BSTRUCT.\n+\n+tree\n+Gcc_backend::struct_field_expression (tree struct_tree, size_t index,\n+\t\t\t\t      Location location)\n+{\n+  if (struct_tree == error_mark_node\n+      || TREE_TYPE (struct_tree) == error_mark_node)\n+    return error_mark_node;\n+  gcc_assert (TREE_CODE (TREE_TYPE (struct_tree)) == RECORD_TYPE\n+\t      || TREE_CODE (TREE_TYPE (struct_tree)) == UNION_TYPE);\n+  tree field = TYPE_FIELDS (TREE_TYPE (struct_tree));\n+  if (field == NULL_TREE)\n+    {\n+      // This can happen for a type which refers to itself indirectly\n+      // and then turns out to be erroneous.\n+      return error_mark_node;\n+    }\n+  for (unsigned int i = index; i > 0; --i)\n+    {\n+      field = DECL_CHAIN (field);\n+      gcc_assert (field != NULL_TREE);\n+    }\n+  if (TREE_TYPE (field) == error_mark_node)\n+    return error_mark_node;\n+  tree ret = fold_build3_loc (location.gcc_location (), COMPONENT_REF,\n+\t\t\t      TREE_TYPE (field), struct_tree, field, NULL_TREE);\n+  if (TREE_CONSTANT (struct_tree))\n+    TREE_CONSTANT (ret) = 1;\n+  return ret;\n+}\n+\n+// Return an expression that executes BSTAT before BEXPR.\n+\n+tree\n+Gcc_backend::compound_expression (tree stat, tree expr, Location location)\n+{\n+  if (stat == error_mark_node || expr == error_mark_node)\n+    return error_mark_node;\n+  tree ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR,\n+\t\t\t      TREE_TYPE (expr), stat, expr);\n+  return ret;\n+}\n+\n+// Return an expression that executes THEN_EXPR if CONDITION is true, or\n+// ELSE_EXPR otherwise.\n+\n+tree\n+Gcc_backend::conditional_expression (tree, tree type_tree, tree cond_expr,\n+\t\t\t\t     tree then_expr, tree else_expr,\n+\t\t\t\t     Location location)\n+{\n+  if (type_tree == error_mark_node || cond_expr == error_mark_node\n+      || then_expr == error_mark_node || else_expr == error_mark_node)\n+    return error_mark_node;\n+  tree ret = build3_loc (location.gcc_location (), COND_EXPR, type_tree,\n+\t\t\t cond_expr, then_expr, else_expr);\n+  return ret;\n+}\n+\n+/* Helper function that converts rust operators to equivalent GCC tree_code.\n+   Note that CompoundAssignmentOperator don't get their corresponding tree_code,\n+   because they get compiled away when we lower AST to HIR. */\n+static enum tree_code\n+operator_to_tree_code (NegationOperator op)\n+{\n+  switch (op)\n+    {\n+    case NegationOperator::NEGATE:\n+      return NEGATE_EXPR;\n+    case NegationOperator::NOT:\n+      return TRUTH_NOT_EXPR;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Note that GCC tree code distinguishes floating point division and integer\n+   division. These two types of division are represented as the same rust\n+   operator, and can only be distinguished via context(i.e. the TREE_TYPE of the\n+   operands). */\n+static enum tree_code\n+operator_to_tree_code (ArithmeticOrLogicalOperator op, bool floating_point)\n+{\n+  switch (op)\n+    {\n+    case ArithmeticOrLogicalOperator::ADD:\n+      return PLUS_EXPR;\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n+      return MINUS_EXPR;\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n+      return MULT_EXPR;\n+    case ArithmeticOrLogicalOperator::DIVIDE:\n+      if (floating_point)\n+\treturn RDIV_EXPR;\n+      else\n+\treturn TRUNC_DIV_EXPR;\n+    case ArithmeticOrLogicalOperator::MODULUS:\n+      return TRUNC_MOD_EXPR;\n+    case ArithmeticOrLogicalOperator::BITWISE_AND:\n+      return BIT_AND_EXPR;\n+    case ArithmeticOrLogicalOperator::BITWISE_OR:\n+      return BIT_IOR_EXPR;\n+    case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+      return BIT_XOR_EXPR;\n+    case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+      return LSHIFT_EXPR;\n+    case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+      return RSHIFT_EXPR;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static enum tree_code\n+operator_to_tree_code (ComparisonOperator op)\n+{\n+  switch (op)\n+    {\n+    case ComparisonOperator::EQUAL:\n+      return EQ_EXPR;\n+    case ComparisonOperator::NOT_EQUAL:\n+      return NE_EXPR;\n+    case ComparisonOperator::GREATER_THAN:\n+      return GT_EXPR;\n+    case ComparisonOperator::LESS_THAN:\n+      return LT_EXPR;\n+    case ComparisonOperator::GREATER_OR_EQUAL:\n+      return GE_EXPR;\n+    case ComparisonOperator::LESS_OR_EQUAL:\n+      return LE_EXPR;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static enum tree_code\n+operator_to_tree_code (LazyBooleanOperator op)\n+{\n+  switch (op)\n+    {\n+    case LazyBooleanOperator::LOGICAL_OR:\n+      return TRUTH_ORIF_EXPR;\n+    case LazyBooleanOperator::LOGICAL_AND:\n+      return TRUTH_ANDIF_EXPR;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Helper function for deciding if a tree is a floating point node. */\n+bool\n+is_floating_point (tree t)\n+{\n+  auto tree_type = TREE_CODE (TREE_TYPE (t));\n+  return tree_type == REAL_TYPE || tree_type == COMPLEX_TYPE;\n+}\n+\n+// Return an expression for the negation operation OP EXPR.\n+tree\n+Gcc_backend::negation_expression (NegationOperator op, tree expr_tree,\n+\t\t\t\t  Location location)\n+{\n+  /* Check if the expression is an error, in which case we return an error\n+     expression. */\n+  if (expr_tree == error_mark_node || TREE_TYPE (expr_tree) == error_mark_node)\n+    return error_mark_node;\n+\n+  /* For negation operators, the resulting type should be the same as its\n+     operand. */\n+  auto tree_type = TREE_TYPE (expr_tree);\n+  auto original_type = tree_type;\n+  auto tree_code = operator_to_tree_code (op);\n+\n+  /* For floating point operations we may need to extend the precision of type.\n+     For example, a 64-bit machine may not support operations on float32. */\n+  bool floating_point = is_floating_point (expr_tree);\n+  auto extended_type = NULL_TREE;\n+  if (floating_point)\n+    {\n+      extended_type = excess_precision_type (tree_type);\n+      if (extended_type != NULL_TREE)\n+\t{\n+\t  expr_tree = convert (extended_type, expr_tree);\n+\t  tree_type = extended_type;\n+\t}\n+    }\n+\n+  /* Construct a new tree and build an expression from it. */\n+  auto new_tree = fold_build1_loc (location.gcc_location (), tree_code,\n+\t\t\t\t   tree_type, expr_tree);\n+  if (floating_point && extended_type != NULL_TREE)\n+    new_tree = convert (original_type, expr_tree);\n+  return new_tree;\n+}\n+\n+// Return an expression for the arithmetic or logical operation LEFT OP RIGHT.\n+tree\n+Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t       tree left_tree, tree right_tree,\n+\t\t\t\t\t       Location location)\n+{\n+  /* Check if either expression is an error, in which case we return an error\n+     expression. */\n+  if (left_tree == error_mark_node || right_tree == error_mark_node)\n+    return error_mark_node;\n+\n+  /* We need to determine if we're doing floating point arithmetics of integer\n+     arithmetics. */\n+  bool floating_point = is_floating_point (left_tree);\n+\n+  /* For arithmetic or logical operators, the resulting type should be the same\n+     as the lhs operand. */\n+  auto tree_type = TREE_TYPE (left_tree);\n+  auto original_type = tree_type;\n+  auto tree_code = operator_to_tree_code (op, floating_point);\n+\n+  /* For floating point operations we may need to extend the precision of type.\n+     For example, a 64-bit machine may not support operations on float32. */\n+  auto extended_type = NULL_TREE;\n+  if (floating_point)\n+    {\n+      extended_type = excess_precision_type (tree_type);\n+      if (extended_type != NULL_TREE)\n+\t{\n+\t  left_tree = convert (extended_type, left_tree);\n+\t  right_tree = convert (extended_type, right_tree);\n+\t  tree_type = extended_type;\n+\t}\n+    }\n+\n+  /* Construct a new tree and build an expression from it. */\n+  auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n+\t\t\t\t   tree_type, left_tree, right_tree);\n+  TREE_CONSTANT (new_tree)\n+    = TREE_CONSTANT (left_tree) && TREE_CONSTANT (right_tree);\n+\n+  if (floating_point && extended_type != NULL_TREE)\n+    new_tree = convert (original_type, new_tree);\n+  return new_tree;\n+}\n+\n+// Return an expression for the comparison operation LEFT OP RIGHT.\n+tree\n+Gcc_backend::comparison_expression (ComparisonOperator op, tree left_tree,\n+\t\t\t\t    tree right_tree, Location location)\n+{\n+  /* Check if either expression is an error, in which case we return an error\n+     expression. */\n+  if (left_tree == error_mark_node || right_tree == error_mark_node)\n+    return error_mark_node;\n+\n+  /* For comparison operators, the resulting type should be boolean. */\n+  auto tree_type = boolean_type_node;\n+  auto tree_code = operator_to_tree_code (op);\n+\n+  /* Construct a new tree and build an expression from it. */\n+  auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n+\t\t\t\t   tree_type, left_tree, right_tree);\n+  return new_tree;\n+}\n+\n+// Return an expression for the lazy boolean operation LEFT OP RIGHT.\n+tree\n+Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, tree left_tree,\n+\t\t\t\t      tree right_tree, Location location)\n+{\n+  /* Check if either expression is an error, in which case we return an error\n+     expression. */\n+  if (left_tree == error_mark_node || right_tree == error_mark_node)\n+    return error_mark_node;\n+\n+  /* For lazy boolean operators, the resulting type should be the same as the\n+     rhs operand. */\n+  auto tree_type = TREE_TYPE (right_tree);\n+  auto tree_code = operator_to_tree_code (op);\n+\n+  /* Construct a new tree and build an expression from it. */\n+  auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n+\t\t\t\t   tree_type, left_tree, right_tree);\n+  return new_tree;\n+}\n+\n+// Return an expression that constructs BTYPE with VALS.\n+\n+tree\n+Gcc_backend::constructor_expression (tree type_tree, bool is_variant,\n+\t\t\t\t     const std::vector<tree> &vals,\n+\t\t\t\t     int union_index, Location location)\n+{\n+  if (type_tree == error_mark_node)\n+    return error_mark_node;\n+\n+  vec<constructor_elt, va_gc> *init;\n+  vec_alloc (init, vals.size ());\n+\n+  tree sink = NULL_TREE;\n+  bool is_constant = true;\n+  tree field = TYPE_FIELDS (type_tree);\n+\n+  if (is_variant)\n+    {\n+      gcc_assert (union_index != -1);\n+      gcc_assert (TREE_CODE (type_tree) == UNION_TYPE);\n+\n+      for (int i = 0; i < union_index; i++)\n+\t{\n+\t  gcc_assert (field != NULL_TREE);\n+\t  field = DECL_CHAIN (field);\n+\t}\n+\n+      tree nested_ctor\n+\t= constructor_expression (TREE_TYPE (field), false, vals, -1, location);\n+\n+      constructor_elt empty = {NULL, NULL};\n+      constructor_elt *elt = init->quick_push (empty);\n+      elt->index = field;\n+      elt->value\n+\t= this->convert_tree (TREE_TYPE (field), nested_ctor, location);\n+      if (!TREE_CONSTANT (elt->value))\n+\tis_constant = false;\n+    }\n+  else\n+    {\n+      if (union_index != -1)\n+\t{\n+\t  gcc_assert (TREE_CODE (type_tree) == UNION_TYPE);\n+\t  tree val = vals.front ();\n+\t  for (int i = 0; i < union_index; i++)\n+\t    {\n+\t      gcc_assert (field != NULL_TREE);\n+\t      field = DECL_CHAIN (field);\n+\t    }\n+\t  if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n+\t      || TREE_TYPE (val) == error_mark_node)\n+\t    return error_mark_node;\n+\n+\t  if (int_size_in_bytes (TREE_TYPE (field)) == 0)\n+\t    {\n+\t      // GIMPLE cannot represent indices of zero-sized types so\n+\t      // trying to construct a map with zero-sized keys might lead\n+\t      // to errors.  Instead, we evaluate each expression that\n+\t      // would have been added as a map element for its\n+\t      // side-effects and construct an empty map.\n+\t      append_to_statement_list (val, &sink);\n+\t    }\n+\t  else\n+\t    {\n+\t      constructor_elt empty = {NULL, NULL};\n+\t      constructor_elt *elt = init->quick_push (empty);\n+\t      elt->index = field;\n+\t      elt->value\n+\t\t= this->convert_tree (TREE_TYPE (field), val, location);\n+\t      if (!TREE_CONSTANT (elt->value))\n+\t\tis_constant = false;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n+\t  for (std::vector<tree>::const_iterator p = vals.begin ();\n+\t       p != vals.end (); ++p, field = DECL_CHAIN (field))\n+\t    {\n+\t      gcc_assert (field != NULL_TREE);\n+\t      tree val = (*p);\n+\t      if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n+\t\t  || TREE_TYPE (val) == error_mark_node)\n+\t\treturn error_mark_node;\n+\n+\t      if (int_size_in_bytes (TREE_TYPE (field)) == 0)\n+\t\t{\n+\t\t  // GIMPLE cannot represent indices of zero-sized types so\n+\t\t  // trying to construct a map with zero-sized keys might lead\n+\t\t  // to errors.  Instead, we evaluate each expression that\n+\t\t  // would have been added as a map element for its\n+\t\t  // side-effects and construct an empty map.\n+\t\t  append_to_statement_list (val, &sink);\n+\t\t  continue;\n+\t\t}\n+\n+\t      constructor_elt empty = {NULL, NULL};\n+\t      constructor_elt *elt = init->quick_push (empty);\n+\t      elt->index = field;\n+\t      elt->value\n+\t\t= this->convert_tree (TREE_TYPE (field), val, location);\n+\t      if (!TREE_CONSTANT (elt->value))\n+\t\tis_constant = false;\n+\t    }\n+\t  gcc_assert (field == NULL_TREE);\n+\t}\n+    }\n+\n+  tree ret = build_constructor (type_tree, init);\n+  if (is_constant)\n+    TREE_CONSTANT (ret) = 1;\n+  if (sink != NULL_TREE)\n+    ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR, type_tree,\n+\t\t\t   sink, ret);\n+  return ret;\n+}\n+\n+tree\n+Gcc_backend::array_constructor_expression (\n+  tree type_tree, const std::vector<unsigned long> &indexes,\n+  const std::vector<tree> &vals, Location location)\n+{\n+  if (type_tree == error_mark_node)\n+    return error_mark_node;\n+\n+  gcc_assert (indexes.size () == vals.size ());\n+\n+  tree element_type = TREE_TYPE (type_tree);\n+  HOST_WIDE_INT element_size = int_size_in_bytes (element_type);\n+  vec<constructor_elt, va_gc> *init;\n+  vec_alloc (init, element_size == 0 ? 0 : vals.size ());\n+\n+  tree sink = NULL_TREE;\n+  bool is_constant = true;\n+  for (size_t i = 0; i < vals.size (); ++i)\n+    {\n+      tree index = size_int (indexes[i]);\n+      tree val = vals[i];\n+\n+      if (index == error_mark_node || val == error_mark_node)\n+\treturn error_mark_node;\n+\n+      if (element_size == 0)\n+\t{\n+\t  // GIMPLE cannot represent arrays of zero-sized types so trying\n+\t  // to construct an array of zero-sized values might lead to errors.\n+\t  // Instead, we evaluate each expression that would have been added as\n+\t  // an array value for its side-effects and construct an empty array.\n+\t  append_to_statement_list (val, &sink);\n+\t  continue;\n+\t}\n+\n+      if (!TREE_CONSTANT (val))\n+\tis_constant = false;\n+\n+      constructor_elt empty = {NULL, NULL};\n+      constructor_elt *elt = init->quick_push (empty);\n+      elt->index = index;\n+      elt->value = val;\n+    }\n+\n+  tree ret = build_constructor (type_tree, init);\n+  if (is_constant)\n+    TREE_CONSTANT (ret) = 1;\n+  if (sink != NULL_TREE)\n+    ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR, type_tree,\n+\t\t\t   sink, ret);\n+  return ret;\n+}\n+\n+// Build insns to create an array, initialize all elements of the array to\n+// value, and return it\n+tree\n+Gcc_backend::array_initializer (tree fndecl, tree block, tree array_type,\n+\t\t\t\ttree length, tree value, tree *tmp,\n+\t\t\t\tLocation locus)\n+{\n+  std::vector<tree> stmts;\n+\n+  // Temporary array we initialize with the desired value.\n+  tree t = NULL_TREE;\n+  Bvariable *tmp_array = this->temporary_variable (fndecl, block, array_type,\n+\t\t\t\t\t\t   NULL_TREE, true, locus, &t);\n+  tree arr = tmp_array->get_tree (locus);\n+  stmts.push_back (t);\n+\n+  // Temporary for the array length used for initialization loop guard.\n+  Bvariable *tmp_len = this->temporary_variable (fndecl, block, size_type_node,\n+\t\t\t\t\t\t length, true, locus, &t);\n+  tree len = tmp_len->get_tree (locus);\n+  stmts.push_back (t);\n+\n+  // Temporary variable for pointer used to initialize elements.\n+  tree ptr_type = this->pointer_type (TREE_TYPE (array_type));\n+  tree ptr_init\n+    = build1_loc (locus.gcc_location (), ADDR_EXPR, ptr_type,\n+\t\t  this->array_index_expression (arr, integer_zero_node, locus));\n+  Bvariable *tmp_ptr = this->temporary_variable (fndecl, block, ptr_type,\n+\t\t\t\t\t\t ptr_init, false, locus, &t);\n+  tree ptr = tmp_ptr->get_tree (locus);\n+  stmts.push_back (t);\n+\n+  // push statement list for the loop\n+  std::vector<tree> loop_stmts;\n+\n+  // Loop exit condition:\n+  //   if (length == 0) break;\n+  t = this->comparison_expression (ComparisonOperator::EQUAL, len,\n+\t\t\t\t   this->zero_expression (TREE_TYPE (len)),\n+\t\t\t\t   locus);\n+\n+  t = this->exit_expression (t, locus);\n+  loop_stmts.push_back (t);\n+\n+  // Assign value to the current pointer position\n+  //   *ptr = value;\n+  t = this->assignment_statement (build_fold_indirect_ref (ptr), value, locus);\n+  loop_stmts.push_back (t);\n+\n+  // Move pointer to next element\n+  //   ptr++;\n+  tree size = TYPE_SIZE_UNIT (TREE_TYPE (ptr_type));\n+  t = build2 (POSTINCREMENT_EXPR, ptr_type, ptr, convert (ptr_type, size));\n+  loop_stmts.push_back (t);\n+\n+  // Decrement loop counter.\n+  //   length--;\n+  t = build2 (POSTDECREMENT_EXPR, TREE_TYPE (len), len,\n+\t      convert (TREE_TYPE (len), integer_one_node));\n+  loop_stmts.push_back (t);\n+\n+  // pop statments and finish loop\n+  tree loop_body = this->statement_list (loop_stmts);\n+  stmts.push_back (this->loop_expression (loop_body, locus));\n+\n+  // Return the temporary in the provided pointer and the statement list which\n+  // initializes it.\n+  *tmp = tmp_array->get_tree (locus);\n+  return this->statement_list (stmts);\n+}\n+\n+// Return an expression representing ARRAY[INDEX]\n+\n+tree\n+Gcc_backend::array_index_expression (tree array_tree, tree index_tree,\n+\t\t\t\t     Location location)\n+{\n+  if (array_tree == error_mark_node || TREE_TYPE (array_tree) == error_mark_node\n+      || index_tree == error_mark_node)\n+    return error_mark_node;\n+\n+  // A function call that returns a zero sized object will have been\n+  // changed to return void.  If we see void here, assume we are\n+  // dealing with a zero sized type and just evaluate the operands.\n+  tree ret;\n+  if (TREE_TYPE (array_tree) != void_type_node)\n+    ret = build4_loc (location.gcc_location (), ARRAY_REF,\n+\t\t      TREE_TYPE (TREE_TYPE (array_tree)), array_tree,\n+\t\t      index_tree, NULL_TREE, NULL_TREE);\n+  else\n+    ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR,\n+\t\t\t   void_type_node, array_tree, index_tree);\n+\n+  return ret;\n+}\n+\n+// Create an expression for a call to FN_EXPR with FN_ARGS.\n+tree\n+Gcc_backend::call_expression (tree fn, const std::vector<tree> &fn_args,\n+\t\t\t      tree chain_expr, Location location)\n+{\n+  if (fn == error_mark_node || TREE_TYPE (fn) == error_mark_node)\n+    return error_mark_node;\n+\n+  gcc_assert (FUNCTION_POINTER_TYPE_P (TREE_TYPE (fn)));\n+  tree rettype = TREE_TYPE (TREE_TYPE (TREE_TYPE (fn)));\n+\n+  size_t nargs = fn_args.size ();\n+  tree *args = nargs == 0 ? NULL : new tree[nargs];\n+  for (size_t i = 0; i < nargs; ++i)\n+    {\n+      args[i] = fn_args.at (i);\n+    }\n+\n+  tree fndecl = fn;\n+  if (TREE_CODE (fndecl) == ADDR_EXPR)\n+    fndecl = TREE_OPERAND (fndecl, 0);\n+\n+  // This is to support builtin math functions when using 80387 math.\n+  tree excess_type = NULL_TREE;\n+  if (optimize && TREE_CODE (fndecl) == FUNCTION_DECL\n+      && fndecl_built_in_p (fndecl, BUILT_IN_NORMAL)\n+      && DECL_IS_UNDECLARED_BUILTIN (fndecl) && nargs > 0\n+      && ((SCALAR_FLOAT_TYPE_P (rettype)\n+\t   && SCALAR_FLOAT_TYPE_P (TREE_TYPE (args[0])))\n+\t  || (COMPLEX_FLOAT_TYPE_P (rettype)\n+\t      && COMPLEX_FLOAT_TYPE_P (TREE_TYPE (args[0])))))\n+    {\n+      excess_type = excess_precision_type (TREE_TYPE (args[0]));\n+      if (excess_type != NULL_TREE)\n+\t{\n+\t  tree excess_fndecl\n+\t    = mathfn_built_in (excess_type, DECL_FUNCTION_CODE (fndecl));\n+\t  if (excess_fndecl == NULL_TREE)\n+\t    excess_type = NULL_TREE;\n+\t  else\n+\t    {\n+\t      fn = build_fold_addr_expr_loc (location.gcc_location (),\n+\t\t\t\t\t     excess_fndecl);\n+\t      for (size_t i = 0; i < nargs; ++i)\n+\t\t{\n+\t\t  if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (args[i]))\n+\t\t      || COMPLEX_FLOAT_TYPE_P (TREE_TYPE (args[i])))\n+\t\t    args[i] = ::convert (excess_type, args[i]);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  tree ret\n+    = build_call_array_loc (location.gcc_location (),\n+\t\t\t    excess_type != NULL_TREE ? excess_type : rettype,\n+\t\t\t    fn, nargs, args);\n+\n+  // check for deprecated function usage\n+  if (fndecl && TREE_DEPRECATED (fndecl))\n+    {\n+      // set up the call-site information for `warn_deprecated_use`\n+      input_location = location.gcc_location ();\n+      warn_deprecated_use (fndecl, NULL_TREE);\n+    }\n+\n+  if (chain_expr)\n+    CALL_EXPR_STATIC_CHAIN (ret) = chain_expr;\n+\n+  if (excess_type != NULL_TREE)\n+    {\n+      // Calling convert here can undo our excess precision change.\n+      // That may or may not be a bug in convert_to_real.\n+      ret = build1_loc (location.gcc_location (), NOP_EXPR, rettype, ret);\n+    }\n+\n+  delete[] args;\n+  return ret;\n+}\n+\n+// Variable initialization.\n+\n+tree\n+Gcc_backend::init_statement (tree, Bvariable *var, tree init_tree)\n+{\n+  tree var_tree = var->get_decl ();\n+  if (var_tree == error_mark_node || init_tree == error_mark_node)\n+    return error_mark_node;\n+  gcc_assert (TREE_CODE (var_tree) == VAR_DECL);\n+\n+  // To avoid problems with GNU ld, we don't make zero-sized\n+  // externally visible variables.  That might lead us to doing an\n+  // initialization of a zero-sized expression to a non-zero sized\n+  // variable, or vice-versa.  Avoid crashes by omitting the\n+  // initializer.  Such initializations don't mean anything anyhow.\n+  if (int_size_in_bytes (TREE_TYPE (var_tree)) != 0 && init_tree != NULL_TREE\n+      && TREE_TYPE (init_tree) != void_type_node\n+      && int_size_in_bytes (TREE_TYPE (init_tree)) != 0)\n+    {\n+      DECL_INITIAL (var_tree) = init_tree;\n+      init_tree = NULL_TREE;\n+    }\n+\n+  tree ret = build1_loc (DECL_SOURCE_LOCATION (var_tree), DECL_EXPR,\n+\t\t\t void_type_node, var_tree);\n+  if (init_tree != NULL_TREE)\n+    ret = build2_loc (DECL_SOURCE_LOCATION (var_tree), COMPOUND_EXPR,\n+\t\t      void_type_node, init_tree, ret);\n+\n+  return ret;\n+}\n+\n+// Assignment.\n+\n+tree\n+Gcc_backend::assignment_statement (tree lhs, tree rhs, Location location)\n+{\n+  if (lhs == error_mark_node || rhs == error_mark_node)\n+    return error_mark_node;\n+\n+  // To avoid problems with GNU ld, we don't make zero-sized\n+  // externally visible variables.  That might lead us to doing an\n+  // assignment of a zero-sized expression to a non-zero sized\n+  // expression; avoid crashes here by avoiding assignments of\n+  // zero-sized expressions.  Such assignments don't really mean\n+  // anything anyhow.\n+  if (TREE_TYPE (lhs) == void_type_node\n+      || int_size_in_bytes (TREE_TYPE (lhs)) == 0\n+      || TREE_TYPE (rhs) == void_type_node\n+      || int_size_in_bytes (TREE_TYPE (rhs)) == 0)\n+    return this->compound_statement (lhs, rhs);\n+\n+  rhs = this->convert_tree (TREE_TYPE (lhs), rhs, location);\n+\n+  return fold_build2_loc (location.gcc_location (), MODIFY_EXPR, void_type_node,\n+\t\t\t  lhs, rhs);\n+}\n+\n+// Return.\n+\n+tree\n+Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n+\t\t\t       Location location)\n+{\n+  if (fntree == error_mark_node)\n+    return error_mark_node;\n+  tree result = DECL_RESULT (fntree);\n+  if (result == error_mark_node)\n+    return error_mark_node;\n+\n+  // If the result size is zero bytes, we have set the function type\n+  // to have a result type of void, so don't return anything.\n+  // See the function_type method.\n+  tree res_type = TREE_TYPE (result);\n+  if (res_type == void_type_node || int_size_in_bytes (res_type) == 0)\n+    {\n+      tree stmt_list = NULL_TREE;\n+      for (std::vector<tree>::const_iterator p = vals.begin ();\n+\t   p != vals.end (); p++)\n+\t{\n+\t  tree val = (*p);\n+\t  if (val == error_mark_node)\n+\t    return error_mark_node;\n+\t  append_to_statement_list (val, &stmt_list);\n+\t}\n+      tree ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n+\t\t\t\t  void_type_node, NULL_TREE);\n+      append_to_statement_list (ret, &stmt_list);\n+      return stmt_list;\n+    }\n+\n+  tree ret;\n+  if (vals.empty ())\n+    ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n+\t\t\t   void_type_node, NULL_TREE);\n+  else if (vals.size () == 1)\n+    {\n+      tree val = vals.front ();\n+      if (val == error_mark_node)\n+\treturn error_mark_node;\n+      tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n+\t\t\t\t  void_type_node, result, vals.front ());\n+      ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n+\t\t\t     void_type_node, set);\n+    }\n+  else\n+    {\n+      // To return multiple values, copy the values into a temporary\n+      // variable of the right structure type, and then assign the\n+      // temporary variable to the DECL_RESULT in the return\n+      // statement.\n+      tree stmt_list = NULL_TREE;\n+      tree rettype = TREE_TYPE (result);\n+\n+      if (DECL_STRUCT_FUNCTION (fntree) == NULL)\n+\tpush_struct_function (fntree);\n+      else\n+\tpush_cfun (DECL_STRUCT_FUNCTION (fntree));\n+      tree rettmp = create_tmp_var (rettype, \"RESULT\");\n+      pop_cfun ();\n+\n+      tree field = TYPE_FIELDS (rettype);\n+      for (std::vector<tree>::const_iterator p = vals.begin ();\n+\t   p != vals.end (); p++, field = DECL_CHAIN (field))\n+\t{\n+\t  gcc_assert (field != NULL_TREE);\n+\t  tree ref\n+\t    = fold_build3_loc (location.gcc_location (), COMPONENT_REF,\n+\t\t\t       TREE_TYPE (field), rettmp, field, NULL_TREE);\n+\t  tree val = (*p);\n+\t  if (val == error_mark_node)\n+\t    return error_mark_node;\n+\t  tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n+\t\t\t\t      void_type_node, ref, (*p));\n+\t  append_to_statement_list (set, &stmt_list);\n+\t}\n+      gcc_assert (field == NULL_TREE);\n+      tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n+\t\t\t\t  void_type_node, result, rettmp);\n+      tree ret_expr = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n+\t\t\t\t       void_type_node, set);\n+      append_to_statement_list (ret_expr, &stmt_list);\n+      ret = stmt_list;\n+    }\n+  return ret;\n+}\n+\n+// Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if an\n+// error occurs.  EXCEPT_STMT may be NULL.  FINALLY_STMT may be NULL and if not\n+// NULL, it will always be executed.  This is used for handling defers in Rust\n+// functions.  In C++, the resulting code is of this form:\n+//   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n+\n+tree\n+Gcc_backend::exception_handler_statement (tree try_stmt, tree except_stmt,\n+\t\t\t\t\t  tree finally_stmt, Location location)\n+{\n+  if (try_stmt == error_mark_node || except_stmt == error_mark_node\n+      || finally_stmt == error_mark_node)\n+    return error_mark_node;\n+\n+  if (except_stmt != NULL_TREE)\n+    try_stmt = build2_loc (location.gcc_location (), TRY_CATCH_EXPR,\n+\t\t\t   void_type_node, try_stmt,\n+\t\t\t   build2_loc (location.gcc_location (), CATCH_EXPR,\n+\t\t\t\t       void_type_node, NULL, except_stmt));\n+  if (finally_stmt != NULL_TREE)\n+    try_stmt = build2_loc (location.gcc_location (), TRY_FINALLY_EXPR,\n+\t\t\t   void_type_node, try_stmt, finally_stmt);\n+  return try_stmt;\n+}\n+\n+// If.\n+\n+tree\n+Gcc_backend::if_statement (tree, tree cond_tree, tree then_tree, tree else_tree,\n+\t\t\t   Location location)\n+{\n+  if (cond_tree == error_mark_node || then_tree == error_mark_node\n+      || else_tree == error_mark_node)\n+    return error_mark_node;\n+  tree ret = build3_loc (location.gcc_location (), COND_EXPR, void_type_node,\n+\t\t\t cond_tree, then_tree, else_tree);\n+  return ret;\n+}\n+\n+// Loops\n+\n+tree\n+Gcc_backend::loop_expression (tree body, Location locus)\n+{\n+  return fold_build1_loc (locus.gcc_location (), LOOP_EXPR, void_type_node,\n+\t\t\t  body);\n+}\n+\n+tree\n+Gcc_backend::exit_expression (tree cond_tree, Location locus)\n+{\n+  return fold_build1_loc (locus.gcc_location (), EXIT_EXPR, void_type_node,\n+\t\t\t  cond_tree);\n+}\n+\n+// Pair of statements.\n+\n+tree\n+Gcc_backend::compound_statement (tree s1, tree s2)\n+{\n+  tree stmt_list = NULL_TREE;\n+  tree t = s1;\n+  if (t == error_mark_node)\n+    return error_mark_node;\n+  append_to_statement_list (t, &stmt_list);\n+  t = s2;\n+  if (t == error_mark_node)\n+    return error_mark_node;\n+  append_to_statement_list (t, &stmt_list);\n+\n+  // If neither statement has any side effects, stmt_list can be NULL\n+  // at this point.\n+  if (stmt_list == NULL_TREE)\n+    stmt_list = integer_zero_node;\n+\n+  return stmt_list;\n+}\n+\n+// List of statements.\n+\n+tree\n+Gcc_backend::statement_list (const std::vector<tree> &statements)\n+{\n+  tree stmt_list = NULL_TREE;\n+  for (std::vector<tree>::const_iterator p = statements.begin ();\n+       p != statements.end (); ++p)\n+    {\n+      tree t = (*p);\n+      if (t == error_mark_node)\n+\treturn error_mark_node;\n+      append_to_statement_list (t, &stmt_list);\n+    }\n+  return stmt_list;\n+}\n+\n+// Make a block.  For some reason gcc uses a dual structure for\n+// blocks: BLOCK tree nodes and BIND_EXPR tree nodes.  Since the\n+// BIND_EXPR node points to the BLOCK node, we store the BIND_EXPR in\n+// the Bblock.\n+\n+tree\n+Gcc_backend::block (tree fndecl, tree enclosing,\n+\t\t    const std::vector<Bvariable *> &vars,\n+\t\t    Location start_location, Location)\n+{\n+  tree block_tree = make_node (BLOCK);\n+  if (enclosing == NULL)\n+    {\n+      gcc_assert (fndecl != NULL_TREE);\n+\n+      // We may have already created a block for local variables when\n+      // we take the address of a parameter.\n+      if (DECL_INITIAL (fndecl) == NULL_TREE)\n+\t{\n+\t  BLOCK_SUPERCONTEXT (block_tree) = fndecl;\n+\t  DECL_INITIAL (fndecl) = block_tree;\n+\t}\n+      else\n+\t{\n+\t  tree superblock_tree = DECL_INITIAL (fndecl);\n+\t  BLOCK_SUPERCONTEXT (block_tree) = superblock_tree;\n+\t  tree *pp;\n+\t  for (pp = &BLOCK_SUBBLOCKS (superblock_tree); *pp != NULL_TREE;\n+\t       pp = &BLOCK_CHAIN (*pp))\n+\t    ;\n+\t  *pp = block_tree;\n+\t}\n+    }\n+  else\n+    {\n+      tree superblock_tree = BIND_EXPR_BLOCK (enclosing);\n+      gcc_assert (TREE_CODE (superblock_tree) == BLOCK);\n+\n+      BLOCK_SUPERCONTEXT (block_tree) = superblock_tree;\n+      tree *pp;\n+      for (pp = &BLOCK_SUBBLOCKS (superblock_tree); *pp != NULL_TREE;\n+\t   pp = &BLOCK_CHAIN (*pp))\n+\t;\n+      *pp = block_tree;\n+    }\n+\n+  tree *pp = &BLOCK_VARS (block_tree);\n+  for (std::vector<Bvariable *>::const_iterator pv = vars.begin ();\n+       pv != vars.end (); ++pv)\n+    {\n+      *pp = (*pv)->get_decl ();\n+      if (*pp != error_mark_node)\n+\tpp = &DECL_CHAIN (*pp);\n+    }\n+  *pp = NULL_TREE;\n+\n+  TREE_USED (block_tree) = 1;\n+\n+  tree bind_tree\n+    = build3_loc (start_location.gcc_location (), BIND_EXPR, void_type_node,\n+\t\t  BLOCK_VARS (block_tree), NULL_TREE, block_tree);\n+  TREE_SIDE_EFFECTS (bind_tree) = 1;\n+  return bind_tree;\n+}\n+\n+// Add statements to a block.\n+\n+void\n+Gcc_backend::block_add_statements (tree bind_tree,\n+\t\t\t\t   const std::vector<tree> &statements)\n+{\n+  tree stmt_list = NULL_TREE;\n+  for (std::vector<tree>::const_iterator p = statements.begin ();\n+       p != statements.end (); ++p)\n+    {\n+      tree s = (*p);\n+      if (s != error_mark_node)\n+\tappend_to_statement_list (s, &stmt_list);\n+    }\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  BIND_EXPR_BODY (bind_tree) = stmt_list;\n+}\n+\n+// This is not static because we declare it with GTY(()) in rust-c.h.\n+tree rust_non_zero_struct;\n+\n+// Return a type corresponding to TYPE with non-zero size.\n+\n+tree\n+Gcc_backend::non_zero_size_type (tree type)\n+{\n+  if (int_size_in_bytes (type) != 0)\n+    return type;\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case RECORD_TYPE:\n+      if (TYPE_FIELDS (type) != NULL_TREE)\n+\t{\n+\t  tree ns = make_node (RECORD_TYPE);\n+\t  tree field_trees = NULL_TREE;\n+\t  tree *pp = &field_trees;\n+\t  for (tree field = TYPE_FIELDS (type); field != NULL_TREE;\n+\t       field = DECL_CHAIN (field))\n+\t    {\n+\t      tree ft = TREE_TYPE (field);\n+\t      if (field == TYPE_FIELDS (type))\n+\t\tft = non_zero_size_type (ft);\n+\t      tree f = build_decl (DECL_SOURCE_LOCATION (field), FIELD_DECL,\n+\t\t\t\t   DECL_NAME (field), ft);\n+\t      DECL_CONTEXT (f) = ns;\n+\t      *pp = f;\n+\t      pp = &DECL_CHAIN (f);\n+\t    }\n+\t  TYPE_FIELDS (ns) = field_trees;\n+\t  layout_type (ns);\n+\t  return ns;\n+\t}\n+\n+      if (rust_non_zero_struct == NULL_TREE)\n+\t{\n+\t  type = make_node (RECORD_TYPE);\n+\t  tree field = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t\t\t   get_identifier (\"dummy\"), boolean_type_node);\n+\t  DECL_CONTEXT (field) = type;\n+\t  TYPE_FIELDS (type) = field;\n+\t  layout_type (type);\n+\t  rust_non_zero_struct = type;\n+\t}\n+      return rust_non_zero_struct;\n+\n+      case ARRAY_TYPE: {\n+\ttree element_type = non_zero_size_type (TREE_TYPE (type));\n+\treturn build_array_type_nelts (element_type, 1);\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+// Convert EXPR_TREE to TYPE_TREE.  Sometimes the same unnamed Rust type\n+// can be created multiple times and thus have multiple tree\n+// representations.  Make sure this does not confuse the middle-end.\n+\n+tree\n+Gcc_backend::convert_tree (tree type_tree, tree expr_tree, Location location)\n+{\n+  if (type_tree == TREE_TYPE (expr_tree))\n+    return expr_tree;\n+\n+  if (type_tree == error_mark_node || expr_tree == error_mark_node\n+      || TREE_TYPE (expr_tree) == error_mark_node)\n+    return error_mark_node;\n+\n+  if (POINTER_TYPE_P (type_tree) || INTEGRAL_TYPE_P (type_tree)\n+      || SCALAR_FLOAT_TYPE_P (type_tree) || COMPLEX_FLOAT_TYPE_P (type_tree))\n+    return fold_convert_loc (location.gcc_location (), type_tree, expr_tree);\n+  else if (TREE_CODE (type_tree) == RECORD_TYPE\n+\t   || TREE_CODE (type_tree) == UNION_TYPE\n+\t   || TREE_CODE (type_tree) == ARRAY_TYPE)\n+    {\n+      gcc_assert (int_size_in_bytes (type_tree)\n+\t\t  == int_size_in_bytes (TREE_TYPE (expr_tree)));\n+      if (TYPE_MAIN_VARIANT (type_tree)\n+\t  == TYPE_MAIN_VARIANT (TREE_TYPE (expr_tree)))\n+\treturn fold_build1_loc (location.gcc_location (), NOP_EXPR, type_tree,\n+\t\t\t\texpr_tree);\n+      return fold_build1_loc (location.gcc_location (), VIEW_CONVERT_EXPR,\n+\t\t\t      type_tree, expr_tree);\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+// Make a global variable.\n+\n+Bvariable *\n+Gcc_backend::global_variable (const std::string &var_name,\n+\t\t\t      const std::string &asm_name, tree type_tree,\n+\t\t\t      bool is_external, bool is_hidden,\n+\t\t\t      bool in_unique_section, Location location)\n+{\n+  if (type_tree == error_mark_node)\n+    return this->error_variable ();\n+\n+  // The GNU linker does not like dynamic variables with zero size.\n+  tree orig_type_tree = type_tree;\n+  if ((is_external || !is_hidden) && int_size_in_bytes (type_tree) == 0)\n+    type_tree = this->non_zero_size_type (type_tree);\n+\n+  tree decl = build_decl (location.gcc_location (), VAR_DECL,\n+\t\t\t  get_identifier_from_string (var_name), type_tree);\n+  if (is_external)\n+    DECL_EXTERNAL (decl) = 1;\n+  else\n+    TREE_STATIC (decl) = 1;\n+  if (!is_hidden)\n+    {\n+      TREE_PUBLIC (decl) = 1;\n+      SET_DECL_ASSEMBLER_NAME (decl, get_identifier_from_string (asm_name));\n+    }\n+  else\n+    {\n+      SET_DECL_ASSEMBLER_NAME (decl, get_identifier_from_string (asm_name));\n+    }\n+\n+  TREE_USED (decl) = 1;\n+\n+  if (in_unique_section)\n+    resolve_unique_section (decl, 0, 1);\n+\n+  rust_preserve_from_gc (decl);\n+\n+  return new Bvariable (decl, orig_type_tree);\n+}\n+\n+// Set the initial value of a global variable.\n+\n+void\n+Gcc_backend::global_variable_set_init (Bvariable *var, tree expr_tree)\n+{\n+  if (expr_tree == error_mark_node)\n+    return;\n+  gcc_assert (TREE_CONSTANT (expr_tree));\n+  tree var_decl = var->get_decl ();\n+  if (var_decl == error_mark_node)\n+    return;\n+  DECL_INITIAL (var_decl) = expr_tree;\n+\n+  // If this variable goes in a unique section, it may need to go into\n+  // a different one now that DECL_INITIAL is set.\n+  if (symtab_node::get (var_decl)\n+      && symtab_node::get (var_decl)->implicit_section)\n+    {\n+      set_decl_section_name (var_decl, (const char *) NULL);\n+      resolve_unique_section (var_decl, compute_reloc_for_constant (expr_tree),\n+\t\t\t      1);\n+    }\n+}\n+\n+// Make a local variable.\n+\n+Bvariable *\n+Gcc_backend::local_variable (tree function, const std::string &name,\n+\t\t\t     tree type_tree, Bvariable *decl_var,\n+\t\t\t     Location location)\n+{\n+  if (type_tree == error_mark_node)\n+    return this->error_variable ();\n+  tree decl = build_decl (location.gcc_location (), VAR_DECL,\n+\t\t\t  get_identifier_from_string (name), type_tree);\n+  DECL_CONTEXT (decl) = function;\n+\n+  if (decl_var != NULL)\n+    {\n+      DECL_HAS_VALUE_EXPR_P (decl) = 1;\n+      SET_DECL_VALUE_EXPR (decl, decl_var->get_decl ());\n+    }\n+  rust_preserve_from_gc (decl);\n+  return new Bvariable (decl);\n+}\n+\n+// Make a function parameter variable.\n+\n+Bvariable *\n+Gcc_backend::parameter_variable (tree function, const std::string &name,\n+\t\t\t\t tree type_tree, Location location)\n+{\n+  if (type_tree == error_mark_node)\n+    return this->error_variable ();\n+  tree decl = build_decl (location.gcc_location (), PARM_DECL,\n+\t\t\t  get_identifier_from_string (name), type_tree);\n+  DECL_CONTEXT (decl) = function;\n+  DECL_ARG_TYPE (decl) = type_tree;\n+\n+  rust_preserve_from_gc (decl);\n+  return new Bvariable (decl);\n+}\n+\n+// Make a static chain variable.\n+\n+Bvariable *\n+Gcc_backend::static_chain_variable (tree fndecl, const std::string &name,\n+\t\t\t\t    tree type_tree, Location location)\n+{\n+  if (type_tree == error_mark_node)\n+    return this->error_variable ();\n+  tree decl = build_decl (location.gcc_location (), PARM_DECL,\n+\t\t\t  get_identifier_from_string (name), type_tree);\n+  DECL_CONTEXT (decl) = fndecl;\n+  DECL_ARG_TYPE (decl) = type_tree;\n+  TREE_USED (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 1;\n+  TREE_READONLY (decl) = 1;\n+\n+  struct function *f = DECL_STRUCT_FUNCTION (fndecl);\n+  if (f == NULL)\n+    {\n+      push_struct_function (fndecl);\n+      pop_cfun ();\n+      f = DECL_STRUCT_FUNCTION (fndecl);\n+    }\n+  gcc_assert (f->static_chain_decl == NULL);\n+  f->static_chain_decl = decl;\n+  DECL_STATIC_CHAIN (fndecl) = 1;\n+\n+  rust_preserve_from_gc (decl);\n+  return new Bvariable (decl);\n+}\n+\n+// Make a temporary variable.\n+\n+Bvariable *\n+Gcc_backend::temporary_variable (tree fndecl, tree bind_tree, tree type_tree,\n+\t\t\t\t tree init_tree, bool is_address_taken,\n+\t\t\t\t Location location, tree *pstatement)\n+{\n+  gcc_assert (fndecl != NULL_TREE);\n+  if (type_tree == error_mark_node || init_tree == error_mark_node\n+      || fndecl == error_mark_node)\n+    {\n+      *pstatement = error_mark_node;\n+      return this->error_variable ();\n+    }\n+\n+  tree var;\n+  // We can only use create_tmp_var if the type is not addressable.\n+  if (!TREE_ADDRESSABLE (type_tree))\n+    {\n+      if (DECL_STRUCT_FUNCTION (fndecl) == NULL)\n+\tpush_struct_function (fndecl);\n+      else\n+\tpush_cfun (DECL_STRUCT_FUNCTION (fndecl));\n+\n+      var = create_tmp_var (type_tree, \"RUSTTMP\");\n+      pop_cfun ();\n+    }\n+  else\n+    {\n+      gcc_assert (bind_tree != NULL_TREE);\n+      var = build_decl (location.gcc_location (), VAR_DECL,\n+\t\t\tcreate_tmp_var_name (\"RUSTTMP\"), type_tree);\n+      DECL_ARTIFICIAL (var) = 1;\n+      DECL_IGNORED_P (var) = 1;\n+      TREE_USED (var) = 1;\n+      DECL_CONTEXT (var) = fndecl;\n+\n+      // We have to add this variable to the BLOCK and the BIND_EXPR.\n+      gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+      tree block_tree = BIND_EXPR_BLOCK (bind_tree);\n+      gcc_assert (TREE_CODE (block_tree) == BLOCK);\n+      DECL_CHAIN (var) = BLOCK_VARS (block_tree);\n+      BLOCK_VARS (block_tree) = var;\n+      BIND_EXPR_VARS (bind_tree) = BLOCK_VARS (block_tree);\n+    }\n+\n+  if (this->type_size (type_tree) != 0 && init_tree != NULL_TREE\n+      && TREE_TYPE (init_tree) != void_type_node)\n+    DECL_INITIAL (var) = this->convert_tree (type_tree, init_tree, location);\n+\n+  if (is_address_taken)\n+    TREE_ADDRESSABLE (var) = 1;\n+\n+  *pstatement\n+    = build1_loc (location.gcc_location (), DECL_EXPR, void_type_node, var);\n+\n+  // For a zero sized type, don't initialize VAR with BINIT, but still\n+  // evaluate BINIT for its side effects.\n+  if (init_tree != NULL_TREE\n+      && (this->type_size (type_tree) == 0\n+\t  || TREE_TYPE (init_tree) == void_type_node))\n+    *pstatement = this->compound_statement (init_tree, *pstatement);\n+\n+  return new Bvariable (var);\n+}\n+\n+// Make a label.\n+\n+tree\n+Gcc_backend::label (tree func_tree, const std::string &name, Location location)\n+{\n+  tree decl;\n+  if (name.empty ())\n+    {\n+      if (DECL_STRUCT_FUNCTION (func_tree) == NULL)\n+\tpush_struct_function (func_tree);\n+      else\n+\tpush_cfun (DECL_STRUCT_FUNCTION (func_tree));\n+\n+      decl = create_artificial_label (location.gcc_location ());\n+\n+      pop_cfun ();\n+    }\n+  else\n+    {\n+      tree id = get_identifier_from_string (name);\n+      decl\n+\t= build_decl (location.gcc_location (), LABEL_DECL, id, void_type_node);\n+      DECL_CONTEXT (decl) = func_tree;\n+    }\n+  return decl;\n+}\n+\n+// Make a statement which defines a label.\n+\n+tree\n+Gcc_backend::label_definition_statement (tree label)\n+{\n+  return fold_build1_loc (DECL_SOURCE_LOCATION (label), LABEL_EXPR,\n+\t\t\t  void_type_node, label);\n+}\n+\n+// Make a goto statement.\n+\n+tree\n+Gcc_backend::goto_statement (tree label, Location location)\n+{\n+  return fold_build1_loc (location.gcc_location (), GOTO_EXPR, void_type_node,\n+\t\t\t  label);\n+}\n+\n+// Get the address of a label.\n+\n+tree\n+Gcc_backend::label_address (tree label, Location location)\n+{\n+  TREE_USED (label) = 1;\n+  TREE_ADDRESSABLE (label) = 1;\n+  tree ret\n+    = fold_convert_loc (location.gcc_location (), ptr_type_node,\n+\t\t\tbuild_fold_addr_expr_loc (location.gcc_location (),\n+\t\t\t\t\t\t  label));\n+  return ret;\n+}\n+\n+// Declare or define a new function.\n+\n+tree\n+Gcc_backend::function (tree functype, const std::string &name,\n+\t\t       const std::string &asm_name, unsigned int flags,\n+\t\t       Location location)\n+{\n+  if (functype != error_mark_node)\n+    {\n+      gcc_assert (FUNCTION_POINTER_TYPE_P (functype));\n+      functype = TREE_TYPE (functype);\n+    }\n+  tree id = get_identifier_from_string (name);\n+  if (functype == error_mark_node || id == error_mark_node)\n+    return error_mark_node;\n+\n+  tree decl\n+    = build_decl (location.gcc_location (), FUNCTION_DECL, id, functype);\n+  if (!asm_name.empty ())\n+    SET_DECL_ASSEMBLER_NAME (decl, get_identifier_from_string (asm_name));\n+\n+  if ((flags & function_is_declaration) != 0)\n+    DECL_EXTERNAL (decl) = 1;\n+  else\n+    {\n+      tree restype = TREE_TYPE (functype);\n+      tree resdecl = build_decl (location.gcc_location (), RESULT_DECL,\n+\t\t\t\t NULL_TREE, restype);\n+      DECL_ARTIFICIAL (resdecl) = 1;\n+      DECL_IGNORED_P (resdecl) = 1;\n+      DECL_CONTEXT (resdecl) = decl;\n+      DECL_RESULT (decl) = resdecl;\n+    }\n+  if ((flags & function_is_uninlinable) != 0)\n+    DECL_UNINLINABLE (decl) = 1;\n+  if ((flags & function_does_not_return) != 0)\n+    TREE_THIS_VOLATILE (decl) = 1;\n+  if ((flags & function_in_unique_section) != 0)\n+    resolve_unique_section (decl, 0, 1);\n+\n+  rust_preserve_from_gc (decl);\n+  return decl;\n+}\n+\n+// Create a statement that runs all deferred calls for FUNCTION.  This should\n+// be a statement that looks like this in C++:\n+//   finish:\n+//     try { UNDEFER; } catch { CHECK_DEFER; goto finish; }\n+\n+tree\n+Gcc_backend::function_defer_statement (tree function, tree undefer_tree,\n+\t\t\t\t       tree defer_tree, Location location)\n+{\n+  if (undefer_tree == error_mark_node || defer_tree == error_mark_node\n+      || function == error_mark_node)\n+    return error_mark_node;\n+\n+  if (DECL_STRUCT_FUNCTION (function) == NULL)\n+    push_struct_function (function);\n+  else\n+    push_cfun (DECL_STRUCT_FUNCTION (function));\n+\n+  tree stmt_list = NULL;\n+  tree label = this->label (function, \"\", location);\n+  tree label_def = this->label_definition_statement (label);\n+  append_to_statement_list (label_def, &stmt_list);\n+\n+  tree jump_stmt = this->goto_statement (label, location);\n+  tree catch_body\n+    = build2 (COMPOUND_EXPR, void_type_node, defer_tree, jump_stmt);\n+  catch_body = build2 (CATCH_EXPR, void_type_node, NULL, catch_body);\n+  tree try_catch\n+    = build2 (TRY_CATCH_EXPR, void_type_node, undefer_tree, catch_body);\n+  append_to_statement_list (try_catch, &stmt_list);\n+  pop_cfun ();\n+\n+  return stmt_list;\n+}\n+\n+// Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n+// This will only be called for a function definition.\n+\n+bool\n+Gcc_backend::function_set_parameters (\n+  tree function, const std::vector<Bvariable *> &param_vars)\n+{\n+  if (function == error_mark_node)\n+    return false;\n+\n+  tree params = NULL_TREE;\n+  tree *pp = &params;\n+  for (std::vector<Bvariable *>::const_iterator pv = param_vars.begin ();\n+       pv != param_vars.end (); ++pv)\n+    {\n+      *pp = (*pv)->get_decl ();\n+      gcc_assert (*pp != error_mark_node);\n+      pp = &DECL_CHAIN (*pp);\n+    }\n+  *pp = NULL_TREE;\n+  DECL_ARGUMENTS (function) = params;\n+  return true;\n+}\n+\n+// Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n+// FUNCTION_DECLS, and VARIABLE_DECLS declared globally, as well as\n+// emit early debugging information.\n+\n+void\n+Gcc_backend::write_global_definitions (\n+  const std::vector<tree> &type_decls, const std::vector<tree> &constant_decls,\n+  const std::vector<tree> &function_decls,\n+  const std::vector<Bvariable *> &variable_decls)\n+{\n+  size_t count_definitions = type_decls.size () + constant_decls.size ()\n+\t\t\t     + function_decls.size () + variable_decls.size ();\n+\n+  tree *defs = new tree[count_definitions];\n+\n+  // Convert all non-erroneous declarations into Gimple form.\n+  size_t i = 0;\n+  for (std::vector<Bvariable *>::const_iterator p = variable_decls.begin ();\n+       p != variable_decls.end (); ++p)\n+    {\n+      tree v = (*p)->get_decl ();\n+      if (v != error_mark_node)\n+\t{\n+\t  defs[i] = v;\n+\t  rust_preserve_from_gc (defs[i]);\n+\t  ++i;\n+\t}\n+    }\n+\n+  for (std::vector<tree>::const_iterator p = type_decls.begin ();\n+       p != type_decls.end (); ++p)\n+    {\n+      tree type_tree = (*p);\n+      if (type_tree != error_mark_node && IS_TYPE_OR_DECL_P (type_tree))\n+\t{\n+\t  defs[i] = TYPE_NAME (type_tree);\n+\t  gcc_assert (defs[i] != NULL);\n+\t  rust_preserve_from_gc (defs[i]);\n+\t  ++i;\n+\t}\n+    }\n+  for (std::vector<tree>::const_iterator p = constant_decls.begin ();\n+       p != constant_decls.end (); ++p)\n+    {\n+      if ((*p) != error_mark_node)\n+\t{\n+\t  defs[i] = (*p);\n+\t  rust_preserve_from_gc (defs[i]);\n+\t  ++i;\n+\t}\n+    }\n+  for (std::vector<tree>::const_iterator p = function_decls.begin ();\n+       p != function_decls.end (); ++p)\n+    {\n+      tree decl = (*p);\n+      if (decl != error_mark_node)\n+\t{\n+\t  rust_preserve_from_gc (decl);\n+\t  if (DECL_STRUCT_FUNCTION (decl) == NULL)\n+\t    allocate_struct_function (decl, false);\n+\t  dump_function (TDI_original, decl);\n+\t  cgraph_node::finalize_function (decl, true);\n+\n+\t  defs[i] = decl;\n+\t  ++i;\n+\t}\n+    }\n+\n+  // Pass everything back to the middle-end.\n+\n+  wrapup_global_declarations (defs, i);\n+\n+  delete[] defs;\n+}\n+\n+void\n+Gcc_backend::write_export_data (const char *bytes, unsigned int size)\n+{\n+  rust_write_export_data (bytes, size);\n+}\n+\n+// Return the backend generator.\n+\n+Backend *\n+rust_get_backend ()\n+{\n+  return new Gcc_backend ();\n+}"}]}