{"sha": "5e781161bab5a1f425f534c9dfa71e4f481daf71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU3ODExNjFiYWI1YTFmNDI1ZjUzNGM5ZGZhNzFlNGY0ODFkYWY3MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-09T12:29:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-09T12:29:20Z"}, "message": "New file.\n\nFrom-SVN: r145833", "tree": {"sha": "c664010ce5e9549319902557c7c2c6032be9df19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c664010ce5e9549319902557c7c2c6032be9df19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e781161bab5a1f425f534c9dfa71e4f481daf71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e781161bab5a1f425f534c9dfa71e4f481daf71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e781161bab5a1f425f534c9dfa71e4f481daf71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e781161bab5a1f425f534c9dfa71e4f481daf71/comments", "author": null, "committer": null, "parents": [{"sha": "c75c4293c3ffaf2f65ae42f7439939ae0cc65dbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75c4293c3ffaf2f65ae42f7439939ae0cc65dbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c75c4293c3ffaf2f65ae42f7439939ae0cc65dbb"}], "stats": {"total": 266, "additions": 266, "deletions": 0}, "files": [{"sha": "e700abdf8f8c38b242f40a6b997d730358ab5644", "filename": "gcc/ada/style.adb", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e781161bab5a1f425f534c9dfa71e4f481daf71/gcc%2Fada%2Fstyle.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e781161bab5a1f425f534c9dfa71e4f481daf71/gcc%2Fada%2Fstyle.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyle.adb?ref=5e781161bab5a1f425f534c9dfa71e4f481daf71", "patch": "@@ -0,0 +1,266 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                S T Y L E                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Casing;   use Casing;\n+with Csets;    use Csets;\n+with Einfo;    use Einfo;\n+with Errout;   use Errout;\n+with Namet;    use Namet;\n+with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n+with Stand;    use Stand;\n+with Stylesw;  use Stylesw;\n+\n+package body Style is\n+\n+   -----------------------\n+   -- Body_With_No_Spec --\n+   -----------------------\n+\n+   --  If the check specs mode (-gnatys) is set, then all subprograms must\n+   --  have specs unless they are parameterless procedures that are not child\n+   --  units at the library level (i.e. they are possible main programs).\n+\n+   procedure Body_With_No_Spec (N : Node_Id) is\n+   begin\n+      if Style_Check_Specs then\n+         if Nkind (Parent (N)) = N_Compilation_Unit then\n+            declare\n+               Spec  : constant Node_Id := Specification (N);\n+               Defnm : constant Node_Id := Defining_Unit_Name (Spec);\n+\n+            begin\n+               if Nkind (Spec) = N_Procedure_Specification\n+                 and then Nkind (Defnm) = N_Defining_Identifier\n+                 and then No (First_Formal (Defnm))\n+               then\n+                  return;\n+               end if;\n+            end;\n+         end if;\n+\n+         Error_Msg_N (\"(style) subprogram body has no previous spec\", N);\n+      end if;\n+   end Body_With_No_Spec;\n+\n+   ---------------------------------\n+   -- Check_Array_Attribute_Index --\n+   ---------------------------------\n+\n+   procedure Check_Array_Attribute_Index\n+     (N  : Node_Id;\n+      E1 : Node_Id;\n+      D  : Int)\n+   is\n+   begin\n+      if Style_Check_Array_Attribute_Index then\n+         if D = 1 and then Present (E1) then\n+            Error_Msg_N\n+              (\"(style) index number not allowed for one dimensional array\",\n+               E1);\n+         elsif D > 1 and then No (E1) then\n+            Error_Msg_N\n+              (\"(style) index number required for multi-dimensional array\",\n+               N);\n+         end if;\n+      end if;\n+   end Check_Array_Attribute_Index;\n+\n+   ----------------------\n+   -- Check_Identifier --\n+   ----------------------\n+\n+   --  In check references mode (-gnatyr), identifier uses must be cased\n+   --  the same way as the corresponding identifier declaration.\n+\n+   procedure Check_Identifier\n+     (Ref : Node_Or_Entity_Id;\n+      Def : Node_Or_Entity_Id)\n+   is\n+      Sref : Source_Ptr := Sloc (Ref);\n+      Sdef : Source_Ptr := Sloc (Def);\n+      Tref : Source_Buffer_Ptr;\n+      Tdef : Source_Buffer_Ptr;\n+      Nlen : Nat;\n+      Cas  : Casing_Type;\n+\n+   begin\n+      --  If reference does not come from source, nothing to check\n+\n+      if not Comes_From_Source (Ref) then\n+         return;\n+\n+      --  If previous error on either node/entity, ignore\n+\n+      elsif Error_Posted (Ref) or else Error_Posted (Def) then\n+         return;\n+\n+      --  Case of definition comes from source\n+\n+      elsif Comes_From_Source (Def) then\n+\n+         --  Check same casing if we are checking references\n+\n+         if Style_Check_References then\n+            Tref := Source_Text (Get_Source_File_Index (Sref));\n+            Tdef := Source_Text (Get_Source_File_Index (Sdef));\n+\n+            --  Ignore operator name case completely. This also catches the\n+            --  case of where one is an operator and the other is not. This\n+            --  is a phenomenon from rewriting of operators as functions,\n+            --  and is to be ignored.\n+\n+            if Tref (Sref) = '\"' or else Tdef (Sdef) = '\"' then\n+               return;\n+\n+            else\n+               while Tref (Sref) = Tdef (Sdef) loop\n+\n+                  --  If end of identifier, all done\n+\n+                  if not Identifier_Char (Tref (Sref)) then\n+                     return;\n+\n+                  --  Otherwise loop continues\n+\n+                  else\n+                     Sref := Sref + 1;\n+                     Sdef := Sdef + 1;\n+                  end if;\n+               end loop;\n+\n+               --  Fall through loop when mismatch between identifiers\n+               --  If either identifier is not terminated, error.\n+\n+               if Identifier_Char (Tref (Sref))\n+                    or else\n+                  Identifier_Char (Tdef (Sdef))\n+               then\n+                  Error_Msg_Node_1 := Def;\n+                  Error_Msg_Sloc := Sloc (Def);\n+                  Error_Msg\n+                    (\"(style) bad casing of & declared#\", Sref);\n+                  return;\n+\n+               --  Else end of identifiers, and they match\n+\n+               else\n+                  return;\n+               end if;\n+            end if;\n+         end if;\n+\n+      --  Case of definition in package Standard\n+\n+      elsif Sdef = Standard_Location\n+              or else\n+            Sdef = Standard_ASCII_Location\n+      then\n+         --  Check case of identifiers in Standard\n+\n+         if Style_Check_Standard then\n+            Tref := Source_Text (Get_Source_File_Index (Sref));\n+\n+            --  Ignore operators\n+\n+            if Tref (Sref) = '\"' then\n+               null;\n+\n+            --  Otherwise determine required casing of Standard entity\n+\n+            else\n+               --  ASCII is all upper case\n+\n+               if Entity (Ref) = Standard_ASCII then\n+                  Cas := All_Upper_Case;\n+\n+               --  Special names in ASCII are also all upper case\n+\n+               elsif Sdef = Standard_ASCII_Location then\n+                  Cas := All_Upper_Case;\n+\n+               --  All other entities are in mixed case\n+\n+               else\n+                  Cas := Mixed_Case;\n+               end if;\n+\n+               Nlen := Length_Of_Name (Chars (Ref));\n+\n+               --  Now check if we have the right casing\n+\n+               if Determine_Casing\n+                    (Tref (Sref .. Sref + Source_Ptr (Nlen) - 1)) = Cas\n+               then\n+                  null;\n+               else\n+                  Name_Len := Integer (Nlen);\n+                  Name_Buffer (1 .. Name_Len) :=\n+                    String (Tref (Sref .. Sref + Source_Ptr (Nlen) - 1));\n+                  Set_Casing (Cas);\n+                  Error_Msg_Name_1 := Name_Enter;\n+                  Error_Msg_N\n+                    (\"(style) bad casing of %% declared in Standard\", Ref);\n+               end if;\n+            end if;\n+         end if;\n+      end if;\n+   end Check_Identifier;\n+\n+   ------------------------\n+   -- Missing_Overriding --\n+   ------------------------\n+\n+   procedure Missing_Overriding (N : Node_Id; E : Entity_Id) is\n+   begin\n+      --  Note that Error_Msg_NE, which would be more natural to use here,\n+      --  is not visible from this generic unit ???\n+\n+      Error_Msg_Name_1 := Chars (E);\n+\n+      if Style_Check_Missing_Overriding and then Comes_From_Source (N) then\n+         if Nkind (N) = N_Subprogram_Body then\n+            Error_Msg_N\n+              (\"(style) missing OVERRIDING indicator in body of%\", N);\n+         else\n+            Error_Msg_N\n+              (\"(style) missing OVERRIDING indicator in declaration of%\", N);\n+         end if;\n+      end if;\n+   end Missing_Overriding;\n+\n+   -----------------------------------\n+   -- Subprogram_Not_In_Alpha_Order --\n+   -----------------------------------\n+\n+   procedure Subprogram_Not_In_Alpha_Order (Name : Node_Id) is\n+   begin\n+      if Style_Check_Order_Subprograms then\n+         Error_Msg_N\n+           (\"(style) subprogram body& not in alphabetical order\", Name);\n+      end if;\n+   end Subprogram_Not_In_Alpha_Order;\n+end Style;"}]}