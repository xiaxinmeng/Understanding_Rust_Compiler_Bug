{"sha": "d3ca3d6bd706bd629168a7e467ae1efdd923fed8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNjYTNkNmJkNzA2YmQ2MjkxNjhhN2U0NjdhZTFlZmRkOTIzZmVkOA==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2010-07-03T22:43:47Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2010-07-03T22:43:47Z"}, "message": "re PR target/44597 (FAIL: gcc.c-torture/execute/builtin-prefetch-2.c compilation, ICE)\n\n\tPR target/44597\n\t* config/pa/predicates.md (prefetch_cc_operand): Remove.\n\t(prefetch_nocc_operand): Likewise.\n\t* config/pa/pa.md (prefetch): Revise expander to use prefetch_20.\n\t(prefetch_20): New insn.\n\t(prefetch_cc): Remove.\n\t(prefetch_nocc): Likewise.\n\nFrom-SVN: r161786", "tree": {"sha": "cb35f7db82c2d2397c270304adbd8d6c6e352152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb35f7db82c2d2397c270304adbd8d6c6e352152"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3ca3d6bd706bd629168a7e467ae1efdd923fed8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ca3d6bd706bd629168a7e467ae1efdd923fed8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3ca3d6bd706bd629168a7e467ae1efdd923fed8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ca3d6bd706bd629168a7e467ae1efdd923fed8/comments", "author": null, "committer": null, "parents": [{"sha": "4d451982e36b1f5a7a8412d9fb36924699aeb223", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d451982e36b1f5a7a8412d9fb36924699aeb223", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d451982e36b1f5a7a8412d9fb36924699aeb223"}], "stats": {"total": 145, "additions": 23, "deletions": 122}, "files": [{"sha": "a5e5c164477c8df63066c6c817700d7d8cc11f07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ca3d6bd706bd629168a7e467ae1efdd923fed8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ca3d6bd706bd629168a7e467ae1efdd923fed8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3ca3d6bd706bd629168a7e467ae1efdd923fed8", "patch": "@@ -1,3 +1,13 @@\n+2010-07-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/44597\n+\t* config/pa/predicates.md (prefetch_cc_operand): Remove.\n+\t(prefetch_nocc_operand): Likewise.\n+\t* config/pa/pa.md (prefetch): Revise expander to use prefetch_20.\n+\t(prefetch_20): New insn.\n+\t(prefetch_cc): Remove.\n+\t(prefetch_nocc): Likewise.\n+\n 2010-07-03  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* expr.c (vector_mode_valid_p): Move to c-common.c."}, {"sha": "cfe843d40f1a4bb573f3621cc0cf8e1386c1d668", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 13, "deletions": 64, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ca3d6bd706bd629168a7e467ae1efdd923fed8/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ca3d6bd706bd629168a7e467ae1efdd923fed8/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=d3ca3d6bd706bd629168a7e467ae1efdd923fed8", "patch": "@@ -9544,90 +9544,39 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n    (match_operand 2 \"const_int_operand\" \"\")]\n   \"TARGET_PA_20\"\n {\n-  int locality = INTVAL (operands[2]);\n-\n-  gcc_assert (locality >= 0 && locality <= 3);\n-\n-  /* Change operand[0] to a MEM as we don't have the infrastructure\n-     to output all the supported address modes for ldw/ldd when we use\n-     the address directly.  However, we do have it for MEMs.  */\n-  operands[0] = gen_rtx_MEM (QImode, operands[0]);\n-\n-  /* If the address isn't valid for the prefetch, replace it.  */\n-  if (locality)\n-    {\n-      if (!prefetch_nocc_operand (operands[0], QImode))\n-\toperands[0]\n-\t  = replace_equiv_address (operands[0],\n-\t\t\t\t   copy_to_mode_reg (Pmode,\n-\t\t\t\t\t\t     XEXP (operands[0], 0)));\n-      emit_insn (gen_prefetch_nocc (operands[0], operands[1], operands[2]));\n-    }\n-  else\n-    {\n-      if (!prefetch_cc_operand (operands[0], QImode))\n-\toperands[0]\n-\t  = replace_equiv_address (operands[0],\n-\t\t\t\t   copy_to_mode_reg (Pmode,\n-\t\t\t\t\t\t     XEXP (operands[0], 0)));\n-      emit_insn (gen_prefetch_cc (operands[0], operands[1], operands[2]));\n-    }\n+  operands[0] = copy_addr_to_reg (operands[0]);\n+  emit_insn (gen_prefetch_20 (operands[0], operands[1], operands[2]));\n   DONE;\n })\n \n-(define_insn \"prefetch_cc\"\n-  [(prefetch (match_operand:QI 0 \"prefetch_cc_operand\" \"RW\")\n+(define_insn \"prefetch_20\"\n+  [(prefetch (match_operand 0 \"pmode_register_operand\" \"r\")\n \t     (match_operand:SI 1 \"const_int_operand\" \"n\")\n \t     (match_operand:SI 2 \"const_int_operand\" \"n\"))]\n-  \"TARGET_PA_20 && operands[2] == const0_rtx\"\n+  \"TARGET_PA_20\"\n {\n-  /* The SL cache-control completor indicates good spatial locality but\n+  /* The SL cache-control completer indicates good spatial locality but\n      poor temporal locality.  The ldw instruction with a target of general\n      register 0 prefetches a cache line for a read.  The ldd instruction\n      prefetches a cache line for a write.  */\n-  static const char * const instr[2] = {\n-    \"ldw%M0,sl %0,%%r0\",\n-    \"ldd%M0,sl %0,%%r0\"\n-  };\n-  int read_or_write = INTVAL (operands[1]);\n-\n-  gcc_assert (read_or_write >= 0 && read_or_write <= 1);\n-\n-  return instr [read_or_write];\n-}\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"prefetch_nocc\"\n-  [(prefetch (match_operand:QI 0 \"prefetch_nocc_operand\" \"A,RQ\")\n-\t     (match_operand:SI 1 \"const_int_operand\" \"n,n\")\n-\t     (match_operand:SI 2 \"const_int_operand\" \"n,n\"))]\n-  \"TARGET_PA_20 && operands[2] != const0_rtx\"\n-{\n-  /* The ldw instruction with a target of general register 0 prefetches\n-     a cache line for a read.  The ldd instruction prefetches a cache line\n-     for a write.  */\n   static const char * const instr[2][2] = {\n     {\n-      \"ldw RT'%A0,%%r0\",\n-      \"ldd RT'%A0,%%r0\",\n+      \"ldw,sl 0(%0),%%r0\",\n+      \"ldd,sl 0(%0),%%r0\"\n     },\n     {\n-      \"ldw%M0 %0,%%r0\",\n-      \"ldd%M0 %0,%%r0\",\n+      \"ldw 0(%0),%%r0\",\n+      \"ldd 0(%0),%%r0\"\n     }\n   };\n-  int read_or_write = INTVAL (operands[1]);\n+  int read_or_write = INTVAL (operands[1]) == 0 ? 0 : 1;\n+  int locality = INTVAL (operands[2]) == 0 ? 0 : 1;\n \n-  gcc_assert (which_alternative == 0 || which_alternative == 1);\n-  gcc_assert (read_or_write >= 0 && read_or_write <= 1);\n-\n-  return instr [which_alternative][read_or_write];\n+  return instr [locality][read_or_write];\n }\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n-\n ;; TLS Support\n (define_insn \"tgd_load\"\n  [(set (match_operand:SI 0 \"register_operand\" \"=r\")"}, {"sha": "959dbdd009d359dd08a0851b8c8b1070ac60efed", "filename": "gcc/config/pa/predicates.md", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ca3d6bd706bd629168a7e467ae1efdd923fed8/gcc%2Fconfig%2Fpa%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ca3d6bd706bd629168a7e467ae1efdd923fed8/gcc%2Fconfig%2Fpa%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpredicates.md?ref=d3ca3d6bd706bd629168a7e467ae1efdd923fed8", "patch": "@@ -240,64 +240,6 @@\n   return memory_address_p (mode, XEXP (op, 0));\n })\n \n-;; Accept anything that can be used as the source operand for a\n-;; prefetch instruction with a cache-control completer.\n-\n-(define_predicate \"prefetch_cc_operand\"\n-  (match_code \"mem\")\n-{\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  op = XEXP (op, 0);\n-\n-  /* We must reject virtual registers as we don't allow REG+D.  */\n-  if (op == virtual_incoming_args_rtx\n-      || op == virtual_stack_vars_rtx\n-      || op == virtual_stack_dynamic_rtx\n-      || op == virtual_outgoing_args_rtx\n-      || op == virtual_cfa_rtx)\n-    return 0;\n-\n-  if (!REG_P (op) && !IS_INDEX_ADDR_P (op))\n-    return 0;\n-\n-  /* Until problems with management of the REG_POINTER flag are resolved,\n-     we need to delay creating prefetch insns with unscaled indexed addresses\n-     until CSE is not expected.  */\n-  if (!TARGET_NO_SPACE_REGS\n-      && !cse_not_expected\n-      && GET_CODE (op) == PLUS\n-      && REG_P (XEXP (op, 0)))\n-    return 0;\n-\n-  return memory_address_p (mode, op);\n-})\n-\n-;; Accept anything that can be used as the source operand for a\n-;; prefetch instruction with no cache-control completer.\n-\n-(define_predicate \"prefetch_nocc_operand\"\n-  (match_code \"mem\")\n-{\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  op = XEXP (op, 0);\n-\n-  /* Until problems with management of the REG_POINTER flag are resolved,\n-     we need to delay creating prefetch insns with unscaled indexed addresses\n-     until CSE is not expected.  */\n-  if (!TARGET_NO_SPACE_REGS\n-      && !cse_not_expected\n-      && GET_CODE (op) == PLUS\n-      && REG_P (XEXP (op, 0))\n-      && REG_P (XEXP (op, 1)))\n-    return 0;\n-\n-  return memory_address_p (mode, op);\n-})\n-\n ;; Accept REG and any CONST_INT that can be moved in one instruction\n ;; into a general register.\n "}]}