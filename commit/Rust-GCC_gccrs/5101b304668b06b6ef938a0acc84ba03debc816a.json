{"sha": "5101b304668b06b6ef938a0acc84ba03debc816a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEwMWIzMDQ2NjhiMDZiNmVmOTM4YTBhY2M4NGJhMDNkZWJjODE2YQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-04-12T01:44:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-04-12T01:44:21Z"}, "message": "dwarf2out.c (modified_type_die): Don't create new types here.\n\n\t* dwarf2out.c (modified_type_die): Don't create new types here.\n\t* tree.h (get_qualified_type): New function.\n\t(build_qualified_type): Adjust comment.\n\t* tree.c (get_qualified_type): New function.\n\t(build_qualified_type): Use it.\n\nFrom-SVN: r41276", "tree": {"sha": "897357278c2c9107171eee2fa55d88b0af494956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/897357278c2c9107171eee2fa55d88b0af494956"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5101b304668b06b6ef938a0acc84ba03debc816a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5101b304668b06b6ef938a0acc84ba03debc816a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5101b304668b06b6ef938a0acc84ba03debc816a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5101b304668b06b6ef938a0acc84ba03debc816a/comments", "author": null, "committer": null, "parents": [{"sha": "e98d0ceafcef5dc4ddaf9b8c5bd08b04a4e5fb5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e98d0ceafcef5dc4ddaf9b8c5bd08b04a4e5fb5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e98d0ceafcef5dc4ddaf9b8c5bd08b04a4e5fb5f"}], "stats": {"total": 120, "additions": 90, "deletions": 30}, "files": [{"sha": "8426f00efa327f7232cdd2d77ce9f552446bfcbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5101b304668b06b6ef938a0acc84ba03debc816a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5101b304668b06b6ef938a0acc84ba03debc816a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5101b304668b06b6ef938a0acc84ba03debc816a", "patch": "@@ -1,3 +1,11 @@\n+2001-04-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* dwarf2out.c (modified_type_die): Don't create new types here.\n+\t* tree.h (get_qualified_type): New function.\n+\t(build_qualified_type): Adjust comment.\n+\t* tree.c (get_qualified_type): New function.\n+\t(build_qualified_type): Use it.\n+\n 2001-04-11  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cpp.texi (-Wtraditional): Update description."}, {"sha": "9be55d8ff6d396f8c07b55c1a37b8f6279c1da17", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5101b304668b06b6ef938a0acc84ba03debc816a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5101b304668b06b6ef938a0acc84ba03debc816a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5101b304668b06b6ef938a0acc84ba03debc816a", "patch": "@@ -6812,30 +6812,43 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \n   if (code != ERROR_MARK)\n     {\n-      type = build_type_variant (type, is_const_type, is_volatile_type);\n-\n-      mod_type_die = lookup_type_die (type);\n-      if (mod_type_die)\n-\treturn mod_type_die;\n+      tree qualified_type;\n+\n+      /* See if we already have the appropriately qualified variant of\n+\t this type.  */\n+      qualified_type \n+\t= get_qualified_type (type,\n+\t\t\t      ((is_const_type ? TYPE_QUAL_CONST : 0)\n+\t\t\t       | (is_volatile_type \n+\t\t\t\t  ? TYPE_QUAL_VOLATILE : 0)));\n+      /* If we do, then we can just use its DIE, if it exists.  */\n+      if (qualified_type)\n+\t{\n+\t  mod_type_die = lookup_type_die (qualified_type);\n+\t  if (mod_type_die)\n+\t    return mod_type_die;\n+\t}\n \n       /* Handle C typedef types.  */\n-      if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t  && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))\n+      if (qualified_type && TYPE_NAME (qualified_type) \n+\t  && TREE_CODE (TYPE_NAME (qualified_type)) == TYPE_DECL\n+\t  && DECL_ORIGINAL_TYPE (TYPE_NAME (qualified_type)))\n \t{\n-\t  tree dtype = TREE_TYPE (TYPE_NAME (type));\n-\t  if (type == dtype)\n+\t  tree type_name = TYPE_NAME (qualified_type);\n+\t  tree dtype = TREE_TYPE (type_name);\n+\t  if (qualified_type == dtype)\n \t    {\n \t      /* For a named type, use the typedef.  */\n-\t      gen_type_die (type, context_die);\n-\t      mod_type_die = lookup_type_die (type);\n+\t      gen_type_die (qualified_type, context_die);\n+\t      mod_type_die = lookup_type_die (qualified_type);\n \t    }\n \n \t  else if (is_const_type < TYPE_READONLY (dtype)\n \t\t   || is_volatile_type < TYPE_VOLATILE (dtype))\n \t    /* cv-unqualified version of named type.  Just use the unnamed\n \t       type to which it refers.  */\n \t    mod_type_die\n-\t      = modified_type_die (DECL_ORIGINAL_TYPE (TYPE_NAME (type)),\n+\t      = modified_type_die (DECL_ORIGINAL_TYPE (type_name),\n \t\t\t\t   is_const_type, is_volatile_type,\n \t\t\t\t   context_die);\n \t  /* Else cv-qualified version of named type; fall through.  */"}, {"sha": "2b78be2911fa9b3c12e6a8d1291c6a87072310f6", "filename": "gcc/testsuite/g++.old-deja/g++.other/debug8.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5101b304668b06b6ef938a0acc84ba03debc816a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdebug8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5101b304668b06b6ef938a0acc84ba03debc816a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdebug8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdebug8.C?ref=5101b304668b06b6ef938a0acc84ba03debc816a", "patch": "@@ -0,0 +1,21 @@\n+// Build don't link:\n+// Special g++ Options: -g\n+\n+struct X {\n+  const int x[4];\n+};\n+\n+struct A {\n+  A();\n+  A(const A&);\n+};\n+\n+struct B {\n+  A a;\n+  int b[4];\n+};\n+\n+struct C {\n+  A a;\n+  C() { B b=B(); };\n+};"}, {"sha": "1d880d78b7ed5256e8d2a7bd2fd242bdcbbd4896", "filename": "gcc/tree.c", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5101b304668b06b6ef938a0acc84ba03debc816a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5101b304668b06b6ef938a0acc84ba03debc816a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5101b304668b06b6ef938a0acc84ba03debc816a", "patch": "@@ -2993,31 +2993,47 @@ set_type_quals (type, type_quals)\n   TYPE_RESTRICT (type) = (type_quals & TYPE_QUAL_RESTRICT) != 0;\n }\n \n-/* Given a type node TYPE and a TYPE_QUALIFIER_SET, return a type for\n-   the same kind of data as TYPE describes.  Variants point to the\n-   \"main variant\" (which has no qualifiers set) via TYPE_MAIN_VARIANT,\n-   and it points to a chain of other variants so that duplicate\n-   variants are never made.  Only main variants should ever appear as\n-   types of expressions.  */\n+/* Return a version of the TYPE, qualified as indicated by the\n+   TYPE_QUALS, if one exists.  If no qualified version exists yet,\n+   return NULL_TREE.  */\n \n tree\n-build_qualified_type (type, type_quals)\n+get_qualified_type (type, type_quals)\n      tree type;\n      int type_quals;\n {\n-  register tree t;\n+  tree t;\n \n   /* Search the chain of variants to see if there is already one there just\n      like the one we need to have.  If so, use that existing one.  We must\n      preserve the TYPE_NAME, since there is code that depends on this.  */\n-\n   for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n     if (TYPE_QUALS (t) == type_quals && TYPE_NAME (t) == TYPE_NAME (type))\n       return t;\n \n-  /* We need a new one.  */\n-  t = build_type_copy (type);\n-  set_type_quals (t, type_quals);\n+  return NULL_TREE;\n+}\n+\n+/* Like get_qualified_type, but creates the type if it does not\n+   exist.  This function never returns NULL_TREE.  */\n+\n+tree\n+build_qualified_type (type, type_quals)\n+     tree type;\n+     int type_quals;\n+{\n+  tree t;\n+\n+  /* See if we already have the appropriate qualified variant.  */\n+  t = get_qualified_type (type, type_quals);\n+\n+  /* If not, build it.  */\n+  if (!t)\n+    {\n+      t = build_type_copy (type);\n+      set_type_quals (t, type_quals);\n+    }\n+\n   return t;\n }\n "}, {"sha": "fe5a75fc44fae9baf5d203476a0f7ab4abf11f63", "filename": "gcc/tree.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5101b304668b06b6ef938a0acc84ba03debc816a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5101b304668b06b6ef938a0acc84ba03debc816a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5101b304668b06b6ef938a0acc84ba03debc816a", "patch": "@@ -2060,12 +2060,14 @@ extern tree lookup_attribute\t\tPARAMS ((const char *, tree));\n \n extern tree merge_attributes\t\tPARAMS ((tree, tree));\n \n-/* Given a type node TYPE and a TYPE_QUALIFIER_SET, return a type for\n-   the same kind of data as TYPE describes.  Variants point to the\n-   \"main variant\" (which has no qualifiers set) via TYPE_MAIN_VARIANT,\n-   and it points to a chain of other variants so that duplicate\n-   variants are never made.  Only main variants should ever appear as\n-   types of expressions.  */\n+/* Return a version of the TYPE, qualified as indicated by the\n+   TYPE_QUALS, if one exists.  If no qualified version exists yet,\n+   return NULL_TREE.  */\n+\n+extern tree get_qualified_type          PARAMS ((tree, int));\n+\n+/* Like get_qualified_type, but creates the type if it does not\n+   exist.  This function never returns NULL_TREE.  */\n \n extern tree build_qualified_type        PARAMS ((tree, int));\n "}]}