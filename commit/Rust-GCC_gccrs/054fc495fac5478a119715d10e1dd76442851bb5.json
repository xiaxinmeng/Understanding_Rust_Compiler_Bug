{"sha": "054fc495fac5478a119715d10e1dd76442851bb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU0ZmM0OTVmYWM1NDc4YTExOTcxNWQxMGUxZGQ3NjQ0Mjg1MWJiNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-11T07:57:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-11T09:29:18Z"}, "message": "improve BB vectorization dump locations\n\nThis tries to improve BB vectorization dumps by providing more\nprecise locations.  Currently the vect_location is simply the\nvery last stmt in a basic-block that has a location.  So for\n\ndouble a[4], b[4];\nint x[4], y[4];\nvoid foo()\n{\n  a[0] = b[0]; // line 5\n  a[1] = b[1];\n  a[2] = b[2];\n  a[3] = b[3];\n  x[0] = y[0]; // line 9\n  x[1] = y[1];\n  x[2] = y[2];\n  x[3] = y[3];\n} // line 13\n\nwe show the user with -O3 -fopt-info-vec\n\nt.c:13:1: optimized: basic block part vectorized using 16 byte vectors\n\nwhile with the patch we point to both independently vectorized\nopportunities:\n\nt.c:5:8: optimized: basic block part vectorized using 16 byte vectors\nt.c:9:8: optimized: basic block part vectorized using 16 byte vectors\n\nthere's the possibility that the location regresses in case the\nroot stmt in the SLP instance has no location.  For a SLP subgraph\nwith multiple entries the location also chooses one entry at random,\nnot sure in which case we want to dump both.\n\nStill as the plan is to extend the basic-block vectorization\nscope from single basic-block to multiple ones this is a first\nstep to preserve something sensible.\n\nImplementation-wise this makes both costing and code-generation\nhappen on the subgraphs as analyzed.\n\n2020-09-11  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_slp_instance::location): New method.\n\t(vect_schedule_slp): Adjust prototype.\n\t* tree-vectorizer.c (vec_info::remove_stmt): Adjust\n\tthe BB region begin if we removed the stmt it points to.\n\t* tree-vect-loop.c (vect_transform_loop): Adjust.\n\t* tree-vect-slp.c (_slp_instance::location): Implement.\n\t(vect_analyze_slp_instance): For BB vectorization set\n\tvect_location to that of the instance.\n\t(vect_slp_analyze_operations): Likewise.\n\t(vect_bb_vectorization_profitable_p): Remove wrapper.\n\t(vect_slp_analyze_bb_1): Remove cost check here.\n\t(vect_slp_region): Cost check and code generate subgraphs separately,\n\treport optimized locations and missed optimizations due to\n\tprofitability for each of them.\n\t(vect_schedule_slp): Get the vector of SLP graph entries to\n\tvectorize as argument.", "tree": {"sha": "6c1f113a97f4a3312004426062fcdf9c4eb74aba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c1f113a97f4a3312004426062fcdf9c4eb74aba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/054fc495fac5478a119715d10e1dd76442851bb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054fc495fac5478a119715d10e1dd76442851bb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/054fc495fac5478a119715d10e1dd76442851bb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054fc495fac5478a119715d10e1dd76442851bb5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef4ab841d94a4f6ec975c9653c69faeeb85c78e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef4ab841d94a4f6ec975c9653c69faeeb85c78e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef4ab841d94a4f6ec975c9653c69faeeb85c78e8"}], "stats": {"total": 152, "additions": 73, "deletions": 79}, "files": [{"sha": "c95ec5ad267c4cb65fa26fe93d70cfe02cfa9ca6", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/054fc495fac5478a119715d10e1dd76442851bb5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/054fc495fac5478a119715d10e1dd76442851bb5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=054fc495fac5478a119715d10e1dd76442851bb5", "patch": "@@ -9018,7 +9018,7 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n   if (!loop_vinfo->slp_instances.is_empty ())\n     {\n       DUMP_VECT_SCOPE (\"scheduling SLP instances\");\n-      vect_schedule_slp (loop_vinfo);\n+      vect_schedule_slp (loop_vinfo, LOOP_VINFO_SLP_INSTANCES (loop_vinfo));\n     }\n \n   /* FORNOW: the vectorizer supports only loops which body consist"}, {"sha": "519cd6a725415447aeea0904a8576a909eeed9ac", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 63, "deletions": 75, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/054fc495fac5478a119715d10e1dd76442851bb5/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/054fc495fac5478a119715d10e1dd76442851bb5/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=054fc495fac5478a119715d10e1dd76442851bb5", "patch": "@@ -117,6 +117,18 @@ vect_free_slp_tree (slp_tree node, bool final_p)\n   delete node;\n }\n \n+/* Return a location suitable for dumpings related to the SLP instance.  */\n+\n+dump_user_location_t\n+_slp_instance::location () const\n+{\n+  if (root_stmt)\n+    return root_stmt->stmt;\n+  else\n+    return SLP_TREE_SCALAR_STMTS (root)[0]->stmt;\n+}\n+\n+\n /* Free the memory allocated for the SLP instance.  FINAL_P is true if we\n    have vectorized the instance or if we have made a final decision not\n    to vectorize the statements in any way.  */\n@@ -2121,6 +2133,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   vec<stmt_vec_info> scalar_stmts;\n   bool constructor = false;\n \n+  if (is_a <bb_vec_info> (vinfo))\n+    vect_location = stmt_info->stmt;\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n       scalar_type = TREE_TYPE (DR_REF (dr));\n@@ -3120,6 +3134,8 @@ vect_slp_analyze_operations (vec_info *vinfo)\n       hash_set<slp_tree> lvisited;\n       stmt_vector_for_cost cost_vec;\n       cost_vec.create (2);\n+      if (is_a <bb_vec_info> (vinfo))\n+\tvect_location = instance->location ();\n       if (!vect_slp_analyze_node_operations (vinfo,\n \t\t\t\t\t     SLP_INSTANCE_TREE (instance),\n \t\t\t\t\t     instance, visited, lvisited,\n@@ -3157,8 +3173,11 @@ vect_slp_analyze_operations (vec_info *vinfo)\n     {\n       hash_set<stmt_vec_info> svisited;\n       for (i = 0; vinfo->slp_instances.iterate (i, &instance); ++i)\n-\tvect_bb_slp_mark_live_stmts (bb_vinfo, SLP_INSTANCE_TREE (instance),\n-\t\t\t\t     instance, &instance->cost_vec, svisited);\n+\t{\n+\t  vect_location = instance->location ();\n+\t  vect_bb_slp_mark_live_stmts (bb_vinfo, SLP_INSTANCE_TREE (instance),\n+\t\t\t\t       instance, &instance->cost_vec, svisited);\n+\t}\n     }\n \n   return !vinfo->slp_instances.is_empty ();\n@@ -3435,54 +3454,6 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo,\n   return true;\n }\n \n-/* For each SLP subgraph determine profitability and remove parts not so.\n-   Returns true if any profitable to vectorize subgraph remains.  */\n-\n-static bool\n-vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n-{\n-  slp_instance instance;\n-  unsigned i;\n-\n-  auto_vec<slp_instance> subgraphs (BB_VINFO_SLP_INSTANCES (bb_vinfo).length ());\n-  FOR_EACH_VEC_ELT (BB_VINFO_SLP_INSTANCES (bb_vinfo), i, instance)\n-    if (!instance->subgraph_entries.is_empty ())\n-      subgraphs.quick_push (instance);\n-  BB_VINFO_SLP_INSTANCES (bb_vinfo).truncate (0);\n-  for (i = 0; i < subgraphs.length ();)\n-    {\n-      instance = subgraphs[i];\n-      if (!vect_bb_vectorization_profitable_p (bb_vinfo,\n-\t\t\t\t\t       instance->subgraph_entries))\n-\t{\n-\t  /* ???  We need to think of providing better dump/opt-report\n-\t     locations here.  */\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"not vectorized: vectorization is not \"\n-\t\t\t       \"profitable.\\n\");\n-\t    }\n-\t  slp_instance entry;\n-\t  unsigned j;\n-\t  FOR_EACH_VEC_ELT (instance->subgraph_entries, j, entry)\n-\t    if (entry != instance)\n-\t      vect_free_slp_instance (entry, false);\n-\t  vect_free_slp_instance (instance, false);\n-\t  subgraphs.ordered_remove (i);\n-\t}\n-      else\n-\t{\n-\t  slp_instance entry;\n-\t  unsigned j;\n-\t  FOR_EACH_VEC_ELT (instance->subgraph_entries, j, entry)\n-\t    BB_VINFO_SLP_INSTANCES (bb_vinfo).safe_push (entry);\n-\t  ++i;\n-\t}\n-    }\n-  return !BB_VINFO_SLP_INSTANCES (bb_vinfo).is_empty ();\n-}\n-\n /* Find any vectorizable constructors and add them to the grouped_store\n    array.  */\n \n@@ -3590,6 +3561,7 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal,\n      dependence in the SLP instances.  */\n   for (i = 0; BB_VINFO_SLP_INSTANCES (bb_vinfo).iterate (i, &instance); )\n     {\n+      vect_location = instance->location ();\n       if (! vect_slp_analyze_instance_alignment (bb_vinfo, instance)\n \t  || ! vect_slp_analyze_instance_dependence (bb_vinfo, instance))\n \t{\n@@ -3626,14 +3598,6 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal,\n \n   vect_bb_partition_graph (bb_vinfo);\n \n-  /* Cost model: check if the vectorization opportunities are worthwhile.  */\n-  if (!unlimited_cost_model (NULL)\n-      && !vect_bb_vectorization_profitable_p (bb_vinfo))\n-    return false;\n-\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"Basic block will be vectorized using SLP\\n\");\n   return true;\n }\n \n@@ -3686,22 +3650,48 @@ vect_slp_region (gimple_stmt_iterator region_begin,\n \t    }\n \n \t  bb_vinfo->shared->check_datarefs ();\n-\t  vect_schedule_slp (bb_vinfo);\n \n-\t  unsigned HOST_WIDE_INT bytes;\n-\t  if (dump_enabled_p ())\n+\t  unsigned i;\n+\t  slp_instance instance;\n+\t  FOR_EACH_VEC_ELT (BB_VINFO_SLP_INSTANCES (bb_vinfo), i, instance)\n \t    {\n-\t      if (GET_MODE_SIZE (bb_vinfo->vector_mode).is_constant (&bytes))\n-\t\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t\t\t \"basic block part vectorized using %wu byte \"\n-\t\t\t\t \"vectors\\n\", bytes);\n-\t      else\n-\t\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t\t\t \"basic block part vectorized using variable \"\n-\t\t\t\t \"length vectors\\n\");\n-\t    }\n+\t      if (instance->subgraph_entries.is_empty ())\n+\t\tcontinue;\n \n-\t  vectorized = true;\n+\t      vect_location = instance->location ();\n+\t      if (!unlimited_cost_model (NULL)\n+\t\t  && !vect_bb_vectorization_profitable_p\n+\t\t\t(bb_vinfo, instance->subgraph_entries))\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"not vectorized: vectorization is not \"\n+\t\t\t\t     \"profitable.\\n\");\n+\t\t  continue;\n+\t\t}\n+\n+\t      if (!vectorized && dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"Basic block will be vectorized \"\n+\t\t\t\t \"using SLP\\n\");\n+\t      vectorized = true;\n+\n+\t      vect_schedule_slp (bb_vinfo, instance->subgraph_entries);\n+\n+\t      unsigned HOST_WIDE_INT bytes;\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  if (GET_MODE_SIZE\n+\t\t\t(bb_vinfo->vector_mode).is_constant (&bytes))\n+\t\t    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t\t\t     \"basic block part vectorized using %wu \"\n+\t\t\t\t     \"byte vectors\\n\", bytes);\n+\t\t  else\n+\t\t    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t\t\t     \"basic block part vectorized using \"\n+\t\t\t\t     \"variable length vectors\\n\");\n+\t\t}\n+\t    }\n \t}\n       else\n \t{\n@@ -4828,16 +4818,14 @@ vectorize_slp_instance_root_stmt (slp_tree node, slp_instance instance)\n     gsi_replace (&rgsi, rstmt, true);\n }\n \n-/* Generate vector code for all SLP instances in the loop/basic block.  */\n+/* Generate vector code for SLP_INSTANCES in the loop/basic block.  */\n \n void\n-vect_schedule_slp (vec_info *vinfo)\n+vect_schedule_slp (vec_info *vinfo, vec<slp_instance> slp_instances)\n {\n-  vec<slp_instance> slp_instances;\n   slp_instance instance;\n   unsigned int i;\n \n-  slp_instances = vinfo->slp_instances;\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       slp_tree node = SLP_INSTANCE_TREE (instance);"}, {"sha": "bbe2de56365290849612fbabbe200cb89e2df24d", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/054fc495fac5478a119715d10e1dd76442851bb5/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/054fc495fac5478a119715d10e1dd76442851bb5/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=054fc495fac5478a119715d10e1dd76442851bb5", "patch": "@@ -603,9 +603,13 @@ vec_info::remove_stmt (stmt_vec_info stmt_info)\n {\n   gcc_assert (!stmt_info->pattern_stmt_p);\n   set_vinfo_for_stmt (stmt_info->stmt, NULL);\n-  gimple_stmt_iterator si = gsi_for_stmt (stmt_info->stmt);\n   unlink_stmt_vdef (stmt_info->stmt);\n-  gsi_remove (&si, true);\n+  gimple_stmt_iterator si = gsi_for_stmt (stmt_info->stmt);\n+  gimple_stmt_iterator *psi = &si;\n+  if (bb_vec_info bb_vinfo = dyn_cast <bb_vec_info> (this))\n+    if (gsi_stmt (bb_vinfo->region_begin) == stmt_info->stmt)\n+      psi = &bb_vinfo->region_begin;\n+  gsi_remove (psi, true);\n   release_defs (stmt_info->stmt);\n   free_stmt_vec_info (stmt_info);\n }"}, {"sha": "6c29ee6cfed6beed5f5937d1e90dac1f25ca2d00", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/054fc495fac5478a119715d10e1dd76442851bb5/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/054fc495fac5478a119715d10e1dd76442851bb5/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=054fc495fac5478a119715d10e1dd76442851bb5", "patch": "@@ -190,6 +190,8 @@ typedef class _slp_instance {\n   /* If this instance is the main entry of a subgraph the set of\n      entries into the same subgraph, including itself.  */\n   vec<_slp_instance *> subgraph_entries;\n+\n+  dump_user_location_t location () const;\n } *slp_instance;\n \n \n@@ -2027,7 +2029,7 @@ extern bool vect_transform_slp_perm_load (vec_info *, slp_tree, vec<tree>,\n \t\t\t\t\t  gimple_stmt_iterator *, poly_uint64,\n \t\t\t\t\t  bool, unsigned *);\n extern bool vect_slp_analyze_operations (vec_info *);\n-extern void vect_schedule_slp (vec_info *);\n+extern void vect_schedule_slp (vec_info *, vec<slp_instance>);\n extern opt_result vect_analyze_slp (vec_info *, unsigned);\n extern bool vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);"}]}