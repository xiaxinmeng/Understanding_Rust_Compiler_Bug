{"sha": "34b650b300c86bf21af5b3f1aacdedaa124f4aec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRiNjUwYjMwMGM4NmJmMjFhZjViM2YxYWFjZGVkYWExMjRmNGFlYw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-27T19:14:40Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-27T19:14:40Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r844", "tree": {"sha": "41e8be71892b22e8704027f231877297b277bffd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41e8be71892b22e8704027f231877297b277bffd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34b650b300c86bf21af5b3f1aacdedaa124f4aec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34b650b300c86bf21af5b3f1aacdedaa124f4aec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34b650b300c86bf21af5b3f1aacdedaa124f4aec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34b650b300c86bf21af5b3f1aacdedaa124f4aec/comments", "author": null, "committer": null, "parents": [{"sha": "31d04616b57669ad6727d4c0052e31c1a300a8d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31d04616b57669ad6727d4c0052e31c1a300a8d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31d04616b57669ad6727d4c0052e31c1a300a8d4"}], "stats": {"total": 1325, "additions": 858, "deletions": 467}, "files": [{"sha": "f47d88f35edb0d36d270a2ecc860ba807c004b77", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 311, "deletions": 88, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b650b300c86bf21af5b3f1aacdedaa124f4aec/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b650b300c86bf21af5b3f1aacdedaa124f4aec/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=34b650b300c86bf21af5b3f1aacdedaa124f4aec", "patch": "@@ -94,6 +94,24 @@ extern char **save_argv;\n extern char  *version_string;\n extern char  *language_string;\n \n+/* Enumeration for all of the relational tests, so that we can build\n+   arrays indexed by the test type, and not worry about the order\n+   of EQ, NE, etc. */\n+\n+enum internal_test {\n+    ITEST_EQ,\n+    ITEST_NE,\n+    ITEST_GT,\n+    ITEST_GE,\n+    ITEST_LT,\n+    ITEST_LE,\n+    ITEST_GTU,\n+    ITEST_GEU,\n+    ITEST_LTU,\n+    ITEST_LEU,\n+    ITEST_MAX\n+  };\n+\n /* Global variables for machine-dependent things.  */\n \n /* Threshold for data being put into the small data/bss area, instead\n@@ -462,6 +480,16 @@ md_register_operand (op, mode)\n \t  && MD_REG_P (REGNO (op)));\n }\n \n+/* Return truth value of whether OP is the FP status register.  */\n+\n+int\n+fpsw_register_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == REG && ST_REG_P (REGNO (op)));\n+}\n+\n /* Return truth value if a CONST_DOUBLE is ok to be a legitimate constant.  */\n \n int\n@@ -658,6 +686,23 @@ fcmp_op (op, mode)\n   return (classify_op (op, mode) & CLASS_FCMP_OP) != 0;\n }\n \n+\n+/* Return true if the operand is either the PC or a label_ref.  */\n+\n+int\n+pc_or_label_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (op == pc_rtx)\n+    return TRUE;\n+\n+  if (GET_CODE (op) == LABEL_REF)\n+    return TRUE;\n+\n+  return FALSE;\n+}\n+\n \f\n /* Return an operand string if the given instruction's delay slot or\n    wrap it in a .set noreorder section.  This is for filling delay\n@@ -683,7 +728,7 @@ mips_fill_delay_slot (ret, type, operands, cur_insn)\n   register rtx next_insn\t= (cur_insn) ? NEXT_INSN (cur_insn) : (rtx)0;\n   register int num_nops;\n \n-  if (type == DELAY_LOAD)\n+  if (type == DELAY_LOAD || type == DELAY_FCMP)\n     num_nops = 1;\n \n   else if (type == DELAY_HILO)\n@@ -1435,6 +1480,210 @@ mips_address_cost (addr)\n   return 4;\n }\n \n+\f\n+/* Make normal rtx_code into something we can index from an array */\n+\n+static enum internal_test\n+map_test_to_internal_test (test_code)\n+     enum rtx_code test_code;\n+{\n+  enum internal_test test = ITEST_MAX;\n+\n+  switch (test_code)\n+    {\n+    case EQ:  test = ITEST_EQ;  break;\n+    case NE:  test = ITEST_NE;  break;\n+    case GT:  test = ITEST_GT;  break;\n+    case GE:  test = ITEST_GE;  break;\n+    case LT:  test = ITEST_LT;  break;\n+    case LE:  test = ITEST_LE;  break;\n+    case GTU: test = ITEST_GTU; break;\n+    case GEU: test = ITEST_GEU; break;\n+    case LTU: test = ITEST_LTU; break;\n+    case LEU: test = ITEST_LEU; break;\n+    }\n+\n+  return test;\n+}\n+\n+\f\n+/* Generate the code to compare two integer values.  The return value is:\n+   (reg:SI xx)\t\tThe pseudo register the comparison is in\n+   (const_int 0)\tThe comparison is always false\n+   (const_int 1)\tThe comparison is always true\n+   (rtx)0\t       \tNo register, generate a simple branch.  */\n+\n+rtx\n+gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n+     enum rtx_code test_code;\t/* relational test (EQ, etc) */\n+     rtx result;\t\t/* result to store comp. or 0 if branch */\n+     rtx cmp0;\t\t\t/* first operand to compare */\n+     rtx cmp1;\t\t\t/* second operand to compare */\n+     int *p_invert;\t\t/* NULL or ptr to hold whether branch needs */\n+\t\t\t\t/* to reserse it's test */\n+{\n+  struct cmp_info {\n+    enum rtx_code test_code;\t/* code to use in instruction (LT vs. LTU) */\n+    int const_low;\t\t/* low bound of constant we can accept */\n+    int const_high;\t\t/* high bound of constant we can accept */\n+    int const_add;\t\t/* constant to add (convert LE -> LT) */\n+    int reverse_regs;\t\t/* reverse registers in test */\n+    int invert_const;\t\t/* != 0 if invert value if cmp1 is constant */\n+    int invert_reg;\t\t/* != 0 if invert value if cmp1 is register */\n+  };\n+\n+  static struct cmp_info info[ (int)ITEST_MAX ] = {\n+\n+    { XOR,\t 0,  65535,  0,\t 0,  0,\t 0 },\t/* EQ  */\n+    { XOR,\t 0,  65535,  0,\t 0,  1,\t 1 },\t/* NE  */\n+    { LT,   -32769,  32766,  1,\t 1,  1,\t 0 },\t/* GT  */\n+    { LT,   -32768,  32767,  0,\t 0,  1,\t 1 },\t/* GE  */\n+    { LT,   -32768,  32767,  0,\t 0,  0,\t 0 },\t/* LT  */\n+    { LT,   -32769,  32766,  1,\t 1,  0,\t 1 },\t/* LE  */\n+    { LTU,  -32769,  32766,  1,\t 1,  1,\t 0 },\t/* GTU */\n+    { LTU,  -32768,  32767,  0,\t 0,  1,\t 1 },\t/* GEU */\n+    { LTU,  -32768,  32767,  0,\t 0,  0,\t 0 },\t/* LTU */\n+    { LTU,  -32769,  32766,  1,\t 1,  0,\t 1 },\t/* LEU */\n+  };\n+\n+  enum internal_test test;\n+  struct cmp_info *p_info;\n+  int branch_p;\n+  int eqne_p;\n+  int invert;\n+  rtx reg;\n+  rtx reg2;\n+\n+  test = map_test_to_internal_test (test_code);\n+  if (test == ITEST_MAX)\n+    abort ();\n+\n+  p_info = &info[ (int)test ];\n+  eqne_p = (p_info->test_code == XOR);\n+\n+  /* See if the test is always true or false.  */\n+  if ((GET_CODE (cmp0) == REG || GET_CODE (cmp0) == SUBREG)\n+      && GET_CODE (cmp1) == CONST_INT)\n+    {\n+      int value = INTVAL (cmp1);\n+      rtx truth = (rtx)0;\n+\n+      if (test == ITEST_GEU && value == 0)\n+\ttruth = const1_rtx;\n+\n+      else if (test == ITEST_LTU && value == 0)\n+\ttruth = const0_rtx;\n+\n+      else if (!TARGET_INT64)\n+\t{\n+\t  if (test == ITEST_LTU && value == -1)\n+\t    truth = const1_rtx;\n+\n+\t  else if (test == ITEST_GTU && value == -1)\n+\t    truth = const0_rtx;\n+\n+\t  else if (test == ITEST_LEU && value == -1)\n+\t    truth = const1_rtx;\n+\n+\t  else if (test == ITEST_GT && value == 0x7fffffff)\n+\t    truth = const0_rtx;\n+\n+\t  else if (test == ITEST_LE && value == 0x7fffffff)\n+\t    truth = const1_rtx;\n+\n+\t  else if (test == ITEST_LT && value == 0x80000000)\n+\t    truth = const0_rtx;\n+\n+\t  else if (test == ITEST_GE && value == 0x80000000)\n+\t    truth = const1_rtx;\n+\t}\n+\n+      if (truth != (rtx)0)\n+\t{\n+\t  if (result != (rtx)0)\n+\t    emit_move_insn (result, truth);\n+\n+\t  return truth;\n+\t}\n+    }\n+\n+  /* Eliminate simple branches */\n+  branch_p = (result == (rtx)0);\n+  if (branch_p)\n+    {\n+      if (GET_CODE (cmp0) == REG || GET_CODE (cmp0) == SUBREG)\n+\t{\n+\t  /* Comparisons against zero are simple branches */\n+\t  if (GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) == 0)\n+\t    return (rtx)0;\n+\n+\t  /* Test for beq/bne.  */\n+\t  if (eqne_p)\n+\t    return (rtx)0;\n+\t}\n+\n+      /* allocate a psuedo to calculate the value in.  */\n+      result = gen_reg_rtx (SImode);\n+    }\n+\n+  /* Make sure we can handle any constants given to us.  */\n+  if (GET_CODE (cmp0) == CONST_INT)\n+    cmp0 = force_reg (SImode, cmp0);\n+\n+  if (GET_CODE (cmp1) == CONST_INT)\n+    {\n+      int value = INTVAL (cmp1);\n+      if (value < p_info->const_low || value > p_info->const_high)\n+\tcmp1 = force_reg (SImode, cmp1);\n+    }\n+\n+  /* See if we need to invert the result.  */\n+  invert = (GET_CODE (cmp1) == CONST_INT)\n+\t\t? p_info->invert_const\n+\t\t: p_info->invert_reg;\n+\n+  if (p_invert != (int *)0)\n+    {\n+      *p_invert = invert;\n+      invert = FALSE;\n+    }\n+\n+  /* Comparison to constants, may involve adding 1 to change a LT into LE.\n+     Comparison between two registers, may involve switching operands.  */\n+  if (GET_CODE (cmp1) == CONST_INT)\n+    {\n+      if (p_info->const_add != 0)\n+\tcmp1 = gen_rtx (CONST_INT, VOIDmode, INTVAL (cmp1) + p_info->const_add);\n+    }\n+  else if (p_info->reverse_regs)\n+    {\n+      rtx temp = cmp0;\n+      cmp0 = cmp1;\n+      cmp1 = temp;\n+    }\n+\n+  reg = (invert || eqne_p) ? gen_reg_rtx (SImode) : result;\n+  emit_move_insn (reg, gen_rtx (p_info->test_code, SImode, cmp0, cmp1));\n+\n+  if (test == ITEST_NE && GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) == 0)\n+    {\n+      emit_move_insn (result, gen_rtx (GTU, SImode, reg, const0_rtx));\n+      invert = FALSE;\n+    }\n+\n+  else if (eqne_p)\n+    {\n+      reg2 = (invert) ? gen_reg_rtx (SImode) : result;\n+      emit_move_insn (reg2, gen_rtx (LTU, SImode, reg, const1_rtx));\n+      reg = reg2;\n+    }\n+\n+  if (invert)\n+    emit_move_insn (result, gen_rtx (XOR, SImode, reg, const1_rtx));\n+\n+  return result;\n+}\n+\n \f\n /* Emit the common code for doing conditional branches.\n    operand[0] is the label to jump to.\n@@ -1445,36 +1694,22 @@ gen_conditional_branch (operands, test_code)\n      rtx operands[];\n      enum rtx_code test_code;\n {\n-  enum {\n-    I_EQ,\n-    I_NE,\n-    I_GT,\n-    I_GE,\n-    I_LT,\n-    I_LE,\n-    I_GTU,\n-    I_GEU,\n-    I_LTU,\n-    I_LEU,\n-    I_MAX\n-  } test = I_MAX;\n-\n-  static enum machine_mode mode_map[(int)CMP_MAX][(int)I_MAX] = {\n+  static enum machine_mode mode_map[(int)CMP_MAX][(int)ITEST_MAX] = {\n     {\t\t\t\t/* CMP_SI */\n-      CC_EQmode,\t\t/* eq  */\n-      CC_EQmode,\t\t/* ne  */\n-      CCmode,\t\t\t/* gt  */\n-      CCmode,\t\t\t/* ge  */\n-      CCmode,\t\t\t/* lt  */\n-      CCmode,\t\t\t/* le  */\n-      CCmode,\t\t\t/* gtu */\n-      CCmode,\t\t\t/* geu */\n-      CCmode,\t\t\t/* ltu */\n-      CCmode,\t\t\t/* leu */\n+      SImode,\t\t\t/* eq  */\n+      SImode,\t\t\t/* ne  */\n+      SImode,\t\t\t/* gt  */\n+      SImode,\t\t\t/* ge  */\n+      SImode,\t\t\t/* lt  */\n+      SImode,\t\t\t/* le  */\n+      SImode,\t\t\t/* gtu */\n+      SImode,\t\t\t/* geu */\n+      SImode,\t\t\t/* ltu */\n+      SImode,\t\t\t/* leu */\n     },\n     {\t\t\t\t/* CMP_SF */\n       CC_FPmode,\t\t/* eq  */\n-      CC_FPmode,\t\t/* ne  */\n+      CC_REV_FPmode,\t\t/* ne  */\n       CC_FPmode,\t\t/* gt  */\n       CC_FPmode,\t\t/* ge  */\n       CC_FPmode,\t\t/* lt  */\n@@ -1486,7 +1721,7 @@ gen_conditional_branch (operands, test_code)\n     },\n     {\t\t\t\t/* CMP_DF */\n       CC_FPmode,\t\t/* eq  */\n-      CC_FPmode,\t\t/* ne  */\n+      CC_REV_FPmode,\t\t/* ne  */\n       CC_FPmode,\t\t/* gt  */\n       CC_FPmode,\t\t/* ge  */\n       CC_FPmode,\t\t/* lt  */\n@@ -1499,33 +1734,22 @@ gen_conditional_branch (operands, test_code)\n   };\n \n   enum machine_mode mode;\n-  enum cmp_type type = branch_type;\n-  rtx cmp0 = branch_cmp[0];\n-  rtx cmp1 = branch_cmp[1];\n-  rtx label = gen_rtx (LABEL_REF, VOIDmode, operands[0]);\n-\n-  /* Make normal rtx_code into something we can index from an array */\n-  switch (test_code)\n+  enum cmp_type type\t  = branch_type;\n+  rtx cmp0\t\t  = branch_cmp[0];\n+  rtx cmp1\t\t  = branch_cmp[1];\n+  rtx label1\t\t  = gen_rtx (LABEL_REF, VOIDmode, operands[0]);\n+  rtx label2\t\t  = pc_rtx;\n+  rtx reg\t\t  = (rtx)0;\n+  int invert\t\t  = 0;\n+  enum internal_test test = map_test_to_internal_test (test_code);\n+\n+  if (test == ITEST_MAX)\n     {\n-    case EQ:  test = I_EQ;  break;\n-    case NE:  test = I_NE;  break;\n-    case GT:  test = I_GT;  break;\n-    case GE:  test = I_GE;  break;\n-    case LT:  test = I_LT;  break;\n-    case LE:  test = I_LE;  break;\n-    case GTU: test = I_GTU; break;\n-    case GEU: test = I_GEU; break;\n-    case LTU: test = I_LTU; break;\n-    case LEU: test = I_LEU; break;\n-    }\n-\n-  if (test == I_MAX)\n-    {\n-      mode = CCmode;\n+      mode = SImode;\n       goto fail;\n     }\n \n-  /* Get the machine mode to use (CCmode, CC_EQmode, or CC_FPmode).  */\n+  /* Get the machine mode to use (CCmode, CC_EQmode, CC_FPmode, or CC_REV_FPmode).  */\n   mode = mode_map[(int)type][(int)test];\n   if (mode == VOIDmode)\n     goto fail;\n@@ -1536,50 +1760,46 @@ gen_conditional_branch (operands, test_code)\n       goto fail;\n \n     case CMP_SI:\n-      /* Change >, >=, <, <= tests against 0 to use CC_0mode, since we have\n-\t special instructions to do these tests directly. */\n-\n-      if (mode == CCmode && GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) == 0)\n-\t{\n-\t  emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx, cmp0));\n-\t  mode = CC_0mode;\n-\t}\n-\n-      else if (mode == CCmode && GET_CODE (cmp0) == CONST_INT && INTVAL (cmp0) == 0)\n+      reg = gen_int_relational (test_code, (rtx)0, cmp0, cmp1, &invert);\n+      if (reg != (rtx)0)\n \t{\n-\t  emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx, cmp1));\n-\t  test_code = reverse_condition (test_code);\n-\t  mode = CC_0mode;\n+\t  cmp0 = reg;\n+\t  cmp1 = const0_rtx;\n+\t  test_code = NE;\n \t}\n \n-      else\n-\t{\n-\t  /* force args to register for equality comparisons. */\n-\t  if (mode == CC_EQmode && GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) != 0)\n-\t    cmp1 = force_reg (SImode, cmp1);\n+      /* Make sure not non-zero constant if ==/!= */\n+      else if (GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) != 0)\n+\tcmp1 = force_reg (SImode, cmp1);\n \n-\t  emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t      cc0_rtx,\n-\t\t\t      gen_rtx (COMPARE, mode, cmp0, cmp1)));\n-\t}\n       break;\n \n     case CMP_DF:\n-      emit_insn (gen_cmpdf_internal (cmp0, cmp1));\n-      break;\n-\n     case CMP_SF:\n-      emit_insn (gen_cmpsf_internal (cmp0, cmp1));\n+      {\n+\trtx reg = gen_rtx (REG, mode, FPSW_REGNUM);\n+\temit_insn (gen_rtx (SET, VOIDmode, reg, gen_rtx (test_code, mode, cmp0, cmp1)));\n+\tcmp0 = reg;\n+\tcmp1 = const0_rtx;\n+\ttest_code = NE;\n+      }\n       break;\n     }\n   \n   /* Generate the jump */\n+  if (invert)\n+    {\n+      label2 = label1;\n+      label1 = pc_rtx;\n+    }\n+\n   emit_jump_insn (gen_rtx (SET, VOIDmode,\n \t\t\t   pc_rtx,\n \t\t\t   gen_rtx (IF_THEN_ELSE, VOIDmode,\n-\t\t\t\t    gen_rtx (test_code, mode, cc0_rtx, const0_rtx),\n-\t\t\t\t    label,\n-\t\t\t\t    pc_rtx)));\n+\t\t\t\t    gen_rtx (test_code, mode, cmp0, cmp1),\n+\t\t\t\t    label1,\n+\t\t\t\t    label2)));\n+\n   return;\n \n fail:\n@@ -2728,9 +2948,9 @@ override_options ()\n   mips_char_to_class['f'] = ((TARGET_HARD_FLOAT) ? FP_REGS : NO_REGS);\n   mips_char_to_class['h'] = HI_REG;\n   mips_char_to_class['l'] = LO_REG;\n-  mips_char_to_class['s'] = ST_REGS;\n   mips_char_to_class['x'] = MD_REGS;\n   mips_char_to_class['y'] = GR_REGS;\n+  mips_char_to_class['z'] = ST_REGS;\n \n   /* Set up array to map GCC register number to debug register number.\n      Ignore the special purpose register numbers.  */\n@@ -2762,22 +2982,25 @@ override_options ()\n \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t{\n-\t  register int temp = FALSE;\n+\t  register int temp;\n+\n+\t  if (mode == CC_FPmode || mode == CC_REV_FPmode)\n+\t    temp = (regno == FPSW_REGNUM);\n \n-\t  if (GP_REG_P (regno))\n+\t  else if (GP_REG_P (regno))\n \t    temp = ((regno & 1) == 0 || (size <= UNITS_PER_WORD));\n \n \t  else if (FP_REG_P (regno))\n \t    temp = ((TARGET_FLOAT64 || ((regno & 1) == 0))\n-\t\t    && (TARGET_DEBUG_H_MODE\n-\t\t\t|| class == MODE_FLOAT\n-\t\t\t|| class == MODE_COMPLEX_FLOAT));\n+\t\t    && (class == MODE_FLOAT\n+\t\t\t|| class == MODE_COMPLEX_FLOAT\n+\t\t\t|| (TARGET_DEBUG_H_MODE && class == MODE_INT)));\n \n \t  else if (MD_REG_P (regno))\n \t    temp = (mode == SImode || (regno == MD_REG_FIRST && mode == DImode));\n \n-\t  else if (ST_REG_P (regno))\n-\t    temp = ((mode == SImode) || (class == MODE_CC));\n+\t  else\n+\t    temp = FALSE;\n \n \t  mips_hard_regno_mode_ok[(int)mode][regno] = temp;\n \t}"}, {"sha": "240d64aeba33ccc28a6c3f9d7f7b04c859668eb9", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b650b300c86bf21af5b3f1aacdedaa124f4aec/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b650b300c86bf21af5b3f1aacdedaa124f4aec/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=34b650b300c86bf21af5b3f1aacdedaa124f4aec", "patch": "@@ -49,7 +49,8 @@ enum cmp_type {\n enum delay_type {\n   DELAY_NONE,\t\t\t\t/* no delay slot */\n   DELAY_LOAD,\t\t\t\t/* load from memory delay */\n-  DELAY_HILO\t\t\t\t/* move from/to hi/lo registers */\n+  DELAY_HILO,\t\t\t\t/* move from/to hi/lo registers */\n+  DELAY_FCMP\t\t\t\t/* delay after doing c.<xx>.{d,s} */\n };\n \n /* Which processor to schedule for.  Since there is no difference between\n@@ -120,12 +121,14 @@ extern unsigned long\tcompute_frame_size ();\n extern void\t\texpand_block_move ();\n extern int\t\tequality_op ();\n extern int\t\tfcmp_op ();\n+extern int\t\tfpsw_register_operand ();\n extern struct rtx_def *\tfunction_arg ();\n extern void\t\tfunction_arg_advance ();\n extern int\t\tfunction_arg_partial_nregs ();\n extern void\t\tfunction_epilogue ();\n extern void\t\tfunction_prologue ();\n extern void\t\tgen_conditional_branch ();\n+extern struct rtx_def * gen_int_relational ();\n extern void\t\tinit_cumulative_args ();\n extern int\t\tlarge_int ();\n extern int\t\tmd_register_operand ();\n@@ -145,6 +148,7 @@ extern void\t\tmips_output_filename ();\n extern void\t\tmips_output_lineno ();\n extern char\t       *output_block_move ();\n extern void\t\toverride_options ();\n+extern int\t\tpc_or_label_operand ();\n extern void\t\tprint_operand_address ();\n extern void\t\tprint_operand ();\n extern void\t\tprint_options ();\n@@ -416,7 +420,7 @@ while (0)\n \f\n /* Print subsidiary information on the compiler version in use.  */\n \n-#define MIPS_VERSION \"[AL 1.1, MM 15]\"\n+#define MIPS_VERSION \"[AL 1.1, MM 16]\"\n \n #ifndef MACHINE_TYPE\n #define MACHINE_TYPE \"BSD Mips\"\n@@ -646,7 +650,7 @@ do {\t\t\t\t\t\t\t\\\n #define MASK_DEBUG\t0x40000000\t/* Eliminate version # in .s file */\n #define MASK_DEBUG_A\t0x20000000\t/* don't allow <label>($reg) addrs */\n #define MASK_DEBUG_B\t0x10000000\t/* GO_IF_LEGITIMATE_ADDRESS debug */\n-#define MASK_DEBUG_C\t0x08000000\t/* suppress normal divmod patterns */\n+#define MASK_DEBUG_C\t0x08000000\t/* allow new seq, sne, etc. patterns */\n #define MASK_DEBUG_D\t0x04000000\t/* don't do define_split's */\n #define MASK_DEBUG_E\t0x02000000\t/* function_arg debug */\n #define MASK_DEBUG_F\t0x01000000\t/* don't try to suppress load nop's */\n@@ -1280,8 +1284,8 @@ extern enum reg_class mips_regno_to_class[];\n    'f'\tFloating point registers\n    'h'\tHi register\n    'l'\tLo register\n-   's'\tStatus registers\n-   'x'\tMultiply/divide registers  */\n+   'x'\tMultiply/divide registers\n+   'z'\tFP Status register */\n \n extern enum reg_class mips_char_to_class[];\n \n@@ -2547,47 +2551,34 @@ do\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n-/* A list of names to be used for additional modes for condition\n-   code values in registers (*note Jump Patterns::.).  These names\n-   are added to `enum machine_mode' and all have class `MODE_CC'. \n-   By convention, they should start with `CC' and end with `mode'.\n+/* A list of names to be used for additional modes for condition code\n+   values in registers.  These names are added to `enum machine_mode'\n+   and all have class `MODE_CC'.  By convention, they should start\n+   with `CC' and end with `mode'.\n \n    You should only define this macro if your machine does not use\n    `cc0' and only if additional modes are required.\n \n-   On the MIPS, we use CC_FPmode for all floating point, CC_EQmode for\n-   integer equality/inequality comparisons, CC_0mode for comparisons\n-   against 0, and CCmode for other integer comparisons.  */\n+   On the MIPS, we use CC_FPmode for all floating point except for not\n+   equal, CC_REV_FPmode for not equal (to reverse the sense of the\n+   jump), CC_EQmode for integer equality/inequality comparisons,\n+   CC_0mode for comparisons against 0, and CCmode for other integer\n+   comparisons. */\n \n-#define EXTRA_CC_MODES CC_EQmode, CC_FPmode, CC_0mode\n+#define EXTRA_CC_MODES CC_EQmode, CC_FPmode, CC_0mode, CC_REV_FPmode\n \n /* A list of C strings giving the names for the modes listed in\n-   `EXTRA_CC_MODES'.  For example, the Sparc defines this macro and\n-   `EXTRA_CC_MODES' as\n+   `EXTRA_CC_MODES'.  */\n \n-          #define EXTRA_CC_MODES CC_NOOVmode, CCFPmode\n-          #define EXTRA_CC_NAMES \"CC_NOOV\", \"CCFP\"\n-\n-   This macro is not required if `EXTRA_CC_MODES' is not defined.  */\n-\n-#define EXTRA_CC_NAMES \"CC_EQ\", \"CC_FP\", \"CC_0\"\n+#define EXTRA_CC_NAMES \"CC_EQ\", \"CC_FP\", \"CC_0\", \"CC_REV_FP\"\n \n /* Returns a mode from class `MODE_CC' to be used when comparison\n-   operation code OP is applied to rtx X.  For example, on the\n-   Sparc, `SELECT_CC_MODE' is defined as (see *note Jump\n-   Patterns::. for a description of the reason for this definition)\n-\n-          #define SELECT_CC_MODE(OP,X)\t\t\t\t\t\\\n-            (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? CCFPmode\t\\\n-             : (GET_CODE (X) == PLUS || GET_CODE (X) == MINUS\t\t\\\n-                || GET_CODE (X) == NEG)\t\t\t\t\t\\\n-             ? CC_NOOVmode : CCmode)\n-\n-   This macro is not required if `EXTRA_CC_MODES' is not defined.  */\n+   operation code OP is applied to rtx X.  */\n \n-#define SELECT_CC_MODE (OP, X)\t\t\t\t\t\t\\\n-  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? CC_FPmode :\t\t\\\n-   (OP == EQ || OP == NE) ? CC_EQmode : CCmode)\n+#define SELECT_CC_MODE(OP, X)\t\t\t\t\t\t\\\n+  (GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT\t\t\t\t\\\n+\t? SImode\t\t\t\t\t\t\t\\\n+\t: ((OP == NE) ? CC_REV_FPmode : CC_FPmode))\n \n \f\n /* Control the assembler format that we output.  */"}, {"sha": "f4b7e05beb5f00079863119fe4f63c36adacdcb9", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 521, "deletions": 344, "changes": 865, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b650b300c86bf21af5b3f1aacdedaa124f4aec/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b650b300c86bf21af5b3f1aacdedaa124f4aec/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=34b650b300c86bf21af5b3f1aacdedaa124f4aec", "patch": "@@ -58,7 +58,7 @@\n   (const_string \"unknown\"))\n \n ;; Main data type used by the insn\n-(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,SF,DF\" (const_string \"unknown\"))\n+(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,SF,DF,FPSW\" (const_string \"unknown\"))\n \n ;; # instructions (4 bytes each)\n (define_attr \"length\" \"\" (const_int 1))\n@@ -133,6 +133,8 @@\n \n (define_function_unit \"memory\"\t 1 0 (eq_attr \"type\" \"store\") 1 0)\n \n+(define_function_unit \"fp_comp\"  1 0 (eq_attr \"type\" \"fcmp\")\t 2 0)\n+\n (define_function_unit \"transfer\" 1 0 (eq_attr \"type\" \"xfer\")\t 2 0)\n (define_function_unit \"transfer\" 1 0 (eq_attr \"type\" \"hilo\")\t 3 0)\n \n@@ -317,7 +319,7 @@\n \t\t (subreg:SI (match_dup 2) 0)))\n \n    (set (match_dup 3)\n-\t(ltu:CC (subreg:SI (match_dup 0) 0)\n+\t(ltu:SI (subreg:SI (match_dup 0) 0)\n \t\t(subreg:SI (match_dup 2) 0)))\n \n    (set (subreg:SI (match_dup 0) 1)\n@@ -346,7 +348,7 @@\n \t\t (subreg:SI (match_dup 2) 1)))\n \n    (set (match_dup 3)\n-\t(ltu:CC (subreg:SI (match_dup 0) 1)\n+\t(ltu:SI (subreg:SI (match_dup 0) 1)\n \t\t(subreg:SI (match_dup 2) 1)))\n \n    (set (subreg:SI (match_dup 0) 0)\n@@ -387,7 +389,7 @@\n \t\t (match_dup 2)))\n \n    (set (match_dup 3)\n-\t(ltu:CC (subreg:SI (match_dup 0) 0)\n+\t(ltu:SI (subreg:SI (match_dup 0) 0)\n \t\t(match_dup 2)))\n \n    (set (subreg:SI (match_dup 0) 1)\n@@ -410,7 +412,7 @@\n \t\t (match_dup 2)))\n \n    (set (match_dup 3)\n-\t(ltu:CC (subreg:SI (match_dup 0) 1)\n+\t(ltu:SI (subreg:SI (match_dup 0) 1)\n \t\t(match_dup 2)))\n \n    (set (subreg:SI (match_dup 0) 0)\n@@ -491,7 +493,7 @@\n    && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n \n   [(set (match_dup 3)\n-\t(ltu:CC (subreg:SI (match_dup 1) 0)\n+\t(ltu:SI (subreg:SI (match_dup 1) 0)\n \t\t(subreg:SI (match_dup 2) 0)))\n \n    (set (subreg:SI (match_dup 0) 0)\n@@ -518,7 +520,7 @@\n    && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n \n   [(set (match_dup 3)\n-\t(ltu:CC (subreg:SI (match_dup 1) 1)\n+\t(ltu:SI (subreg:SI (match_dup 1) 1)\n \t        (subreg:SI (match_dup 2) 1)))\n \n    (set (subreg:SI (match_dup 0) 1)\n@@ -559,7 +561,7 @@\n    && INTVAL (operands[2]) > 0\"\n \n   [(set (match_dup 3)\n-\t(ltu:CC (subreg:SI (match_dup 1) 0)\n+\t(ltu:SI (subreg:SI (match_dup 1) 0)\n \t\t(match_dup 2)))\n \n    (set (subreg:SI (match_dup 0) 0)\n@@ -582,7 +584,7 @@\n    && INTVAL (operands[2]) > 0\"\n \n   [(set (match_dup 3)\n-\t(ltu:CC (subreg:SI (match_dup 1) 1)\n+\t(ltu:SI (subreg:SI (match_dup 1) 1)\n \t\t(match_dup 2)))\n \n    (set (subreg:SI (match_dup 0) 1)\n@@ -760,7 +762,7 @@\n \t\t(match_dup 2)))\n    (clobber (reg:SI 64))\n    (clobber (reg:SI 65))]\n-  \"optimize && !TARGET_DEBUG_C_MODE\"\n+  \"optimize\"\n   \"*\n {\n   if (find_reg_note (insn, REG_UNUSED, operands[3]))\n@@ -784,7 +786,7 @@\n \t\t (match_dup 2)))\n    (clobber (reg:SI 64))\n    (clobber (reg:SI 65))]\n-  \"optimize && !TARGET_DEBUG_C_MODE\"\n+  \"optimize\"\n   \"*\n {\n   if (find_reg_note (insn, REG_UNUSED, operands[3]))\n@@ -805,7 +807,7 @@\n \t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n    (clobber (reg:SI 64))\n    (clobber (reg:SI 65))]\n-  \"!optimize || TARGET_DEBUG_C_MODE\"\n+  \"!optimize\"\n   \"div\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")\n@@ -817,7 +819,7 @@\n \t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n    (clobber (reg:SI 64))\n    (clobber (reg:SI 65))]\n-  \"!optimize || TARGET_DEBUG_C_MODE\"\n+  \"!optimize\"\n   \"rem\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")\n@@ -829,7 +831,7 @@\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n    (clobber (reg:SI 64))\n    (clobber (reg:SI 65))]\n-  \"!optimize || TARGET_DEBUG_C_MODE\"\n+  \"!optimize\"\n   \"divu\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")\n@@ -841,7 +843,7 @@\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n    (clobber (reg:SI 64))\n    (clobber (reg:SI 65))]\n-  \"!optimize || TARGET_DEBUG_C_MODE\"\n+  \"!optimize\"\n   \"remu\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")\n@@ -2629,14 +2631,9 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;\tdone, so that we can constrain things appropriately.  There\n ;;\tare assumptions in the rest of GCC that break if we fold the\n ;;\toperands into the branchs for integer operations, and use cc0\n-;;\tfor floating point.\n-;;\n-;;  3)\tThe compare define_insns then once again set branch_cmp and\n-;;\tbranch_type, and the branch define_insns use them.\n-;;\n-;;  4)\tIf a set condition code is done instead of a branch, then the\n-;;\toperands are folded into the RTL, and a separate set of cc0 is\n-;;\tnot done.  This allows slt's to be put into delay slots.\n+;;\tfor floating point, so we use the fp status register instead.\n+;;\tIf needed, an appropriate temporary is created to hold the\n+;;\tof the integer compare.\n \n (define_expand \"cmpsi\"\n   [(set (cc0)\n@@ -2669,53 +2666,6 @@ move\\\\t%0,%z4\\\\n\\\\\n     }\n }\")\n \n-(define_insn \"cmpsi_eqne\"\n-  [(set (cc0)\n-\t(compare:CC_EQ (match_operand:SI 0 \"register_operand\" \"dJ\")\n-\t\t       (match_operand:SI 1 \"reg_or_0_operand\" \"dJ\")))]\n-  \"\"\n-  \"*\n-{\n-  branch_cmp[0] = operands[0];\n-  branch_cmp[1] = operands[1];\n-  branch_type = CMP_SI;\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\"\t\"icmp\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"0\")])\n-\n-(define_insn \"cmpsi_zero\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"reg_or_0_operand\" \"dJ\"))]\n-  \"\"\n-  \"*\n-{\n-  branch_cmp[0] = operands[0];\n-  branch_cmp[1] = const0_rtx;\n-  branch_type = CMP_SI;\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\"\t\"icmp\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"0\")])\n-\n-(define_insn \"cmpsi_relational\"\n-  [(set (cc0)\n-\t(compare:CC (match_operand:SI 0 \"register_operand\" \"dJ\")\n-\t\t    (match_operand:SI 1 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"*\n-{\n-  branch_cmp[0] = operands[0];\n-  branch_cmp[1] = operands[1];\n-  branch_type = CMP_SI;\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\"\t\"icmp\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"0\")])\n-\n (define_expand \"cmpdf\"\n   [(set (cc0)\n \t(compare:CC_FP (match_operand:DF 0 \"register_operand\" \"\")\n@@ -2732,23 +2682,6 @@ move\\\\t%0,%z4\\\\n\\\\\n     }\n }\")\n \n-(define_insn \"cmpdf_internal\"\n-  [(set (cc0)\n-\t(compare:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n-\t\t       (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n-  branch_cmp[0] = operands[0];\n-  branch_cmp[1] = operands[1];\n-  branch_type = CMP_DF;\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\"\t\"fcmp\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"0\")])\n-\n-\n (define_expand \"cmpsf\"\n   [(set (cc0)\n \t(compare:CC_FP (match_operand:SF 0 \"register_operand\" \"\")\n@@ -2765,22 +2698,6 @@ move\\\\t%0,%z4\\\\n\\\\\n     }\n }\")\n \n-(define_insn \"cmpsf_internal\"\n-  [(set (cc0)\n-\t(compare:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n-\t\t       (match_operand:SF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n-  branch_cmp[0] = operands[0];\n-  branch_cmp[1] = operands[1];\n-  branch_type = CMP_SF;\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\"\t\"fcmp\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"0\")])\n-\n \f\n ;;\n ;;  ....................\n@@ -2789,224 +2706,163 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;\n ;;  ....................\n \n-;; We really can't note that integer branches clobber $at, and FP\n-;; branches clobber $fcr31 because if we use a parallel operation, a\n-;; normal insn is used to hold the value instead of jump_insn.  See\n-;; above for cmpxx saving the operands in branch_cmp and branch_type.\n-\n-(define_insn \"branch_fp_true\"\n+(define_insn \"branch_fp_ne\"\n   [(set (pc)\n-\t(if_then_else (match_operator:CC_FP 0 \"fcmp_op\" [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n+\t(if_then_else (ne:CC_FP (reg:CC_FP 66)\n+\t\t\t\t(const_int 0))\n+\t\t      (match_operand 0 \"pc_or_label_operand\" \"\")\n+\t\t      (match_operand 1 \"pc_or_label_operand\" \"\")))]\n   \"\"\n   \"*\n {\n-  operands[2] = branch_cmp[0];\n-  operands[3] = branch_cmp[1];\n-\n   mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-  if (branch_type == CMP_DF)\n-    {\n-      switch (GET_CODE (operands[0]))\n-\t{\n-\tcase EQ: return \\\"c.eq.d\\\\t%2,%3%#\\;%*bc1t%?\\\\t%l1\\\";\n-\tcase NE: return \\\"c.eq.d\\\\t%2,%3%#\\;%*bc1f%?\\\\t%l1\\\";\n-\tcase LT: return \\\"c.lt.d\\\\t%2,%3%#\\;%*bc1t%?\\\\t%l1\\\";\n-\tcase LE: return \\\"c.le.d\\\\t%2,%3%#\\;%*bc1t%?\\\\t%l1\\\";\n-\tcase GT: return \\\"c.lt.d\\\\t%3,%2%#\\;%*bc1t%?\\\\t%l1\\\";\n-\tcase GE: return \\\"c.le.d\\\\t%3,%2%#\\;%*bc1t%?\\\\t%l1\\\";\n-\t}\n-    }\n-\n-  else if (branch_type == CMP_SF)\n-    {\n-      switch (GET_CODE (operands[0]))\n-\t{\n-\tcase EQ: return \\\"c.eq.s\\\\t%2,%3%#\\;%*bc1t%?\\\\t%l1\\\";\n-\tcase NE: return \\\"c.eq.s\\\\t%2,%3%#\\;%*bc1f%?\\\\t%l1\\\";\n-\tcase LT: return \\\"c.lt.s\\\\t%2,%3%#\\;%*bc1t%?\\\\t%l1\\\";\n-\tcase LE: return \\\"c.le.s\\\\t%2,%3%#\\;%*bc1t%?\\\\t%l1\\\";\n-\tcase GT: return \\\"c.lt.s\\\\t%3,%2%#\\;%*bc1t%?\\\\t%l1\\\";\n-\tcase GE: return \\\"c.le.s\\\\t%3,%2%#\\;%*bc1t%?\\\\t%l1\\\";\n-\t}\n-    }\n-\n-  abort_with_insn (insn, \\\"Bad floating compare/branch\\\");\n-  return (char *)0;\n+  return (operands[0] != pc_rtx) ? \\\"%*bc1t%?\\\\t%0\\\" : \\\"%*bc1f%?\\\\t%1\\\";\n }\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"3\")])\n+   (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"branch_fp_false\"\n+(define_insn \"branch_fp_ne_rev\"\n   [(set (pc)\n-\t(if_then_else (match_operator:CC_FP 0 \"fcmp_op\" [(cc0) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n+\t(if_then_else (ne:CC_REV_FP (reg:CC_REV_FP 66)\n+\t\t\t\t    (const_int 0))\n+\t\t      (match_operand 0 \"pc_or_label_operand\" \"\")\n+\t\t      (match_operand 1 \"pc_or_label_operand\" \"\")))]\n   \"\"\n   \"*\n {\n-  operands[2] = branch_cmp[0];\n-  operands[3] = branch_cmp[1];\n-\n   mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-  if (branch_type == CMP_DF)\n-    {\n-      switch (GET_CODE (operands[0]))\n-\t{\n-\tcase EQ: return \\\"c.eq.d\\\\t%2,%3%#\\;%*bc1f%?\\\\t%l1\\\";\n-\tcase NE: return \\\"c.eq.d\\\\t%2,%3%#\\;%*bc1t%?\\\\t%l1\\\";\n-\tcase LT: return \\\"c.lt.d\\\\t%2,%3%#\\;%*bc1f%?\\\\t%l1\\\";\n-\tcase LE: return \\\"c.le.d\\\\t%2,%3%#\\;%*bc1f%?\\\\t%l1\\\";\n-\tcase GT: return \\\"c.lt.d\\\\t%3,%2%#\\;%*bc1f%?\\\\t%l1\\\";\n-\tcase GE: return \\\"c.le.d\\\\t%3,%2%#\\;%*bc1f%?\\\\t%l1\\\";\n-\t}\n-    }\n-\n-  else if (branch_type == CMP_SF)\n-    {\n-      switch (GET_CODE (operands[0]))\n-\t{\n-\tcase EQ: return \\\"c.eq.s\\\\t%2,%3%#\\;%*bc1f%?\\\\t%l1\\\";\n-\tcase NE: return \\\"c.eq.s\\\\t%2,%3%#\\;%*bc1t%?\\\\t%l1\\\";\n-\tcase LT: return \\\"c.lt.s\\\\t%2,%3%#\\;%*bc1f%?\\\\t%l1\\\";\n-\tcase LE: return \\\"c.le.s\\\\t%2,%3%#\\;%*bc1f%?\\\\t%l1\\\";\n-\tcase GT: return \\\"c.lt.s\\\\t%3,%2%#\\;%*bc1f%?\\\\t%l1\\\";\n-\tcase GE: return \\\"c.le.s\\\\t%3,%2%#\\;%*bc1f%?\\\\t%l1\\\";\n-\t}\n-    }\n-\n-  abort_with_insn (insn, \\\"Bad floating compare/branch\\\");\n-  return (char *)0;\n+  return (operands[0] != pc_rtx) ? \\\"%*bc1f%?\\\\t%0\\\" : \\\"%*bc1t%?\\\\t%1\\\";\n }\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"3\")])\n-\n+   (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"branch_eqne_true\"\n+(define_insn \"branch_fp_eq\"\n   [(set (pc)\n-\t(if_then_else (match_operator:CC_EQ 0 \"equality_op\" [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n+\t(if_then_else (eq:CC_FP (reg:CC_FP 66)\n+\t\t\t\t(const_int 0))\n+\t\t      (match_operand 0 \"pc_or_label_operand\" \"\")\n+\t\t      (match_operand 1 \"pc_or_label_operand\" \"\")))]\n   \"\"\n   \"*\n {\n   mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-  operands[2] = branch_cmp[0];\n-  operands[3] = branch_cmp[1];\n-  return \\\"%*b%C0%?\\\\t%z2,%z3,%1\\\";\n+  return (operands[0] != pc_rtx) ? \\\"%*bc1f%?\\\\t%0\\\" : \\\"%*bc1t%?\\\\t%1\\\";\n }\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"branch_eqne_false\"\n+(define_insn \"branch_fp_eq_rev\"\n   [(set (pc)\n-\t(if_then_else (match_operator:CC_EQ 0 \"equality_op\" [(cc0) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n+\t(if_then_else (eq:CC_REV_FP (reg:CC_REV_FP 66)\n+\t\t\t\t    (const_int 0))\n+\t\t      (match_operand 0 \"pc_or_label_operand\" \"\")\n+\t\t      (match_operand 1 \"pc_or_label_operand\" \"\")))]\n   \"\"\n   \"*\n {\n   mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-  operands[2] = branch_cmp[0];\n-  operands[3] = branch_cmp[1];\n-  return \\\"%*b%N0%?\\\\t%z2,%z3,%1\\\";\n+  return (operands[0] != pc_rtx) ? \\\"%*bc1t%?\\\\t%0\\\" : \\\"%*bc1f%?\\\\t%1\\\";\n }\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"branch_zero_true\"\n+\n+(define_insn \"branch_zero\"\n   [(set (pc)\n-\t(if_then_else (match_operator:CC_0 0 \"cmp_op\" [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n+\t(if_then_else (match_operator:SI 0 \"cmp_op\"\n+\t\t\t\t\t [(match_operand:SI 1 \"arith32_operand\" \"rn\")\n+\t\t\t\t\t  (const_int 0)])\n+\t(match_operand 2 \"pc_or_label_operand\" \"\")\n+\t(match_operand 3 \"pc_or_label_operand\" \"\")))]\n   \"\"\n   \"*\n {\n   mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-  operands[2] = branch_cmp[0];\n \n-  switch (GET_CODE (operands[0]))\n+  /* Handle places where CSE has folded a constant into the register operand.  */\n+  if (GET_CODE (operands[1]) == CONST_INT)\n     {\n-    case EQ:  return \\\"%*beq%?\\\\t%z2,%.,%1\\\";\n-    case NE:  return \\\"%*bne%?\\\\t%z2,%.,%1\\\";\n-    case GTU: return \\\"%*bne%?\\\\t%z2,%.,%1\\\";\n-    case LEU: return \\\"%*beq%?\\\\t%z2,%.,%1\\\";\n-    case GEU: return \\\"%*j\\\\t%1\\\";\n-    case LTU: return \\\"#%*bltuz\\\\t%z2,%1\\\";\n+      int value = INTVAL (operands[1]);\n+      int truth = 0;\n+\n+      switch (GET_CODE (operands[0]))\n+\t{\n+\tdefault:  abort ();\n+\tcase EQ:  truth = (value == 0);\t\t\tbreak;\n+\tcase NE:  truth = (value != 0);\t\t\tbreak;\n+\tcase GT:  truth = (value >  0);\t\t\tbreak;\n+\tcase GE:  truth = (value >= 0);\t\t\tbreak;\n+\tcase LT:  truth = (value <  0);\t\t\tbreak;\n+\tcase LE:  truth = (value <= 0);\t\t\tbreak;\n+\tcase GTU: truth = (((unsigned)value) >  0);\tbreak;\n+\tcase GEU: truth = 1;\t\t\t\tbreak;\n+\tcase LTU: truth = 0;\t\t\t\tbreak;\n+\tcase LEU: truth = (((unsigned)value) <= 0);\tbreak;\n+\t}\n+\n+      if (operands[2] != pc_rtx)\n+\treturn (truth) ? \\\"%*j\\\\t%2\\\" : \\\"#bne\\\\t%z1,%.,%2\\\";\n+      else\n+\treturn (truth) ? \\\"#bne\\\\t%z1,%.,%3\\\" : \\\"%*j\\\\t%3\\\";\n     }\n \n-  return \\\"%*b%C0z%?\\\\t%z2,%1\\\";\n-}\"\n-  [(set_attr \"type\"\t\"branch\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"1\")])\n+  if (operands[2] != pc_rtx)\n+    {\t\t\t\t/* normal jump */\n+      switch (GET_CODE (operands[0]))\n+\t{\n+\tcase EQ:  return \\\"%*beq%?\\\\t%z1,%.,%2\\\";\n+\tcase NE:  return \\\"%*bne%?\\\\t%z1,%.,%2\\\";\n+\tcase GTU: return \\\"%*bne%?\\\\t%z1,%.,%2\\\";\n+\tcase LEU: return \\\"%*beq%?\\\\t%z1,%.,%2\\\";\n+\tcase GEU: return \\\"%*j\\\\t%2\\\";\n+\tcase LTU: return \\\"#%*bltuz\\\\t%z1,%2\\\";\n+\t}\n \n-(define_insn \"branch_zero_false\"\n-  [(set (pc)\n-\t(if_then_else (match_operator:CC_0 0 \"cmp_op\" [(cc0) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-  operands[2] = branch_cmp[0];\n-  switch (GET_CODE (operands[0]))\n-    {\n-    case EQ:  return \\\"%*bne%?\\\\t%z2,%.,%1\\\";\n-    case NE:  return \\\"%*beq%?\\\\t%z2,%.,%1\\\";\n-    case GTU: return \\\"%*beq%?\\\\t%z2,%.,%1\\\";\n-    case LEU: return \\\"%*bne\\\\t%z2,%.,%1\\\";\n-    case GEU: return \\\"#%*bgeuz\\\\t%z2,%1\\\";\n-    case LTU: return \\\"%*j\\\\t%1\\\";\n+      return \\\"%*b%C0z%?\\\\t%z1,%2\\\";\n     }\n+  else\n+    {\t\t\t\t/* inverted jump */\n+      switch (GET_CODE (operands[0]))\n+\t{\n+\tcase EQ:  return \\\"%*bne%?\\\\t%z1,%.,%3\\\";\n+\tcase NE:  return \\\"%*beq%?\\\\t%z1,%.,%3\\\";\n+\tcase GTU: return \\\"%*beq%?\\\\t%z1,%.,%3\\\";\n+\tcase LEU: return \\\"%*bne%?\\\\t%z1,%.,%3\\\";\n+\tcase GEU: return \\\"#%*bgeuz\\\\t%z1,%3\\\";\n+\tcase LTU: return \\\"%*j\\\\t%3\\\";\n+\t}\n \n-  return \\\"%*b%N0z%?\\\\t%z2,%1\\\";\n+      return \\\"%*b%N0z%?\\\\t%z1,%3\\\";\n+    }\n }\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"branch_relop_true\"\n-  [(set (pc)\n-\t(if_then_else (match_operator:CC 0 \"cmp2_op\" [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-  operands[2] = branch_cmp[0];\n-  operands[3] = branch_cmp[1];\n-\n-  return \\\"%&b%C0%?\\\\t%z2,%z3,%1%!\\\";\n-}\"\n-  [(set_attr \"type\"\t\"branch\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"2\")])\n \n-(define_insn \"branch_relop_false\"\n+(define_insn \"branch_equality\"\n   [(set (pc)\n-\t(if_then_else (match_operator:CC 0 \"cmp2_op\" [(cc0) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n+\t(if_then_else (match_operator:SI 0 \"equality_op\"\n+\t\t\t\t\t [(match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t\t\t  (match_operand:SI 2 \"register_operand\" \"d\")])\n+\t(match_operand 3 \"pc_or_label_operand\" \"\")\n+\t(match_operand 4 \"pc_or_label_operand\" \"\")))]\n   \"\"\n   \"*\n {\n   mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-  operands[2] = branch_cmp[0];\n-  operands[3] = branch_cmp[1];\n-\n-  return \\\"%&b%N0%?\\\\t%z2,%z3,%1%!\\\";\n+  return (operands[3] != pc_rtx)\n+\t? \\\"%*b%C0%?\\\\t%z1,%z2,%3\\\"\n+\t: \\\"%*b%N0%?\\\\t%z1,%z2,%4\\\";\n }\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"2\")])\n+   (set_attr \"length\"\t\"1\")])\n+\n \n (define_expand \"beq\"\n   [(set (pc)\n@@ -3179,8 +3035,8 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"seq\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(eq:CC_EQ (match_dup 1)\n-\t\t  (match_dup 2)))]\n+\t(eq:SI (match_dup 1)\n+\t       (match_dup 2)))]\n   \"\"\n   \"\n {\n@@ -3193,43 +3049,59 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n+  if (TARGET_DEBUG_C_MODE)\n+    {\n+      gen_int_relational (EQ, operands[0], operands[1], operands[2], (int *)0);\n+      DONE;\n+    }\n+\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n     operands[2] = force_reg (SImode, operands[2]);\n \n   /* fall through and generate default code */\n }\")\n \n-(define_insn \"seq_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n-\t(eq:CC_EQ (match_operand:SI 1 \"register_operand\" \"%d,d,d\")\n-\t\t  (match_operand:SI 2 \"uns_arith_operand\" \"J,d,K\")))]\n+\n+(define_insn \"seq_si_zero\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t       (const_int 0)))]\n   \"\"\n+  \"sltu\\\\t%0,%1,1\"\n+ [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"seq_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \"%d,d\")\n+\t       (match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n+  \"!TARGET_DEBUG_C_MODE\"\n   \"@\n-   sltu\\\\t%0,%1,1\n    xor\\\\t%0,%1,%2\\;sltu\\\\t%0,%0,1\n-   xori\\\\t%0,%1,%x2\\;sltu\\\\t%0,%0,1\"\n- [(set_attr \"type\"\t\"arith,arith,arith\")\n-   (set_attr \"mode\"\t\"SI,SI,SI\")\n-   (set_attr \"length\"\t\"1,2,2\")])\n+   xori\\\\t%0,%1,%2\\;sltu\\\\t%0,%0,1\"\n+ [(set_attr \"type\"\t\"arith,arith\")\n+   (set_attr \"mode\"\t\"SI,SI\")\n+   (set_attr \"length\"\t\"2,2\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(eq:CC_EQ (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t  (match_operand:SI 2 \"uns_arith_operand\" \"\")))]\n-  \"!TARGET_DEBUG_D_MODE\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t       (match_operand:SI 2 \"uns_arith_operand\" \"\")))]\n+  \"!TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\n     && (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != 0)\"\n   [(set (match_dup 0)\n \t(xor:SI (match_dup 1)\n \t\t(match_dup 2)))\n    (set (match_dup 0)\n-\t(ltu:CC (match_dup 0)\n+\t(ltu:SI (match_dup 0)\n \t\t(const_int 1)))]\n   \"\")\n \n (define_expand \"sne\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ne:CC_EQ (match_dup 1)\n-\t\t  (match_dup 2)))]\n+\t(ne:SI (match_dup 1)\n+\t       (match_dup 2)))]\n   \"\"\n   \"\n {\n@@ -3242,48 +3114,57 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n+  if (TARGET_DEBUG_C_MODE)\n+    {\n+      gen_int_relational (NE, operands[0], operands[1], operands[2], (int *)0);\n+      DONE;\n+    }\n+\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n     operands[2] = force_reg (SImode, operands[2]);\n \n   /* fall through and generate default code */\n }\")\n \n-(define_insn \"sne_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n-\t(ne:CC_EQ (match_operand:SI 1 \"register_operand\" \"%d,d,d\")\n-\t\t  (match_operand:SI 2 \"uns_arith_operand\" \"J,d,K\")))]\n+(define_insn \"sne_si_zero\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ne:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t       (const_int 0)))]\n   \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    return \\\"xor\\\\t%0,%1,%2\\;sltu\\\\t%0,%.,%0\\\";\n-\n-  if (INTVAL (operands[2]) == 0)\n-    return \\\"sltu\\\\t%0,%.,%1\\\";\n+  \"sltu\\\\t%0,%.,%1\"\n+ [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n \n-  return \\\"xori\\\\t%0,%1,%x2\\;sltu\\\\t%0,%.,%0\\\";\n-}\"\n- [(set_attr \"type\"\t\"arith,arith,arith\")\n-   (set_attr \"mode\"\t\"SI,SI,SI\")\n-   (set_attr \"length\"\t\"1,2,2\")])\n+(define_insn \"sne_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(ne:SI (match_operand:SI 1 \"register_operand\" \"%d,d\")\n+\t       (match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n+  \"!TARGET_DEBUG_C_MODE\"\n+  \"@\n+    xor\\\\t%0,%1,%2\\;sltu\\\\t%0,%.,%0\n+    xori\\\\t%0,%1,%x2\\;sltu\\\\t%0,%.,%0\"\n+ [(set_attr \"type\"\t\"arith,arith\")\n+   (set_attr \"mode\"\t\"SI,SI\")\n+   (set_attr \"length\"\t\"2,2\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ne:CC_EQ (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t  (match_operand:SI 2 \"uns_arith_operand\" \"\")))]\n-  \"!TARGET_DEBUG_D_MODE\n+\t(ne:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t       (match_operand:SI 2 \"uns_arith_operand\" \"\")))]\n+  \"!TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\n     && (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != 0)\"\n   [(set (match_dup 0)\n \t(xor:SI (match_dup 1)\n \t\t(match_dup 2)))\n    (set (match_dup 0)\n-\t(gtu:CC (match_dup 0)\n+\t(gtu:SI (match_dup 0)\n \t\t(const_int 0)))]\n   \"\")\n \n (define_expand \"sgt\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(gt:CC (match_dup 1)\n+\t(gt:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n   \"\n@@ -3297,6 +3178,12 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n+  if (TARGET_DEBUG_C_MODE)\n+    {\n+      gen_int_relational (GT, operands[0], operands[1], operands[2], (int *)0);\n+      DONE;\n+    }\n+\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) != 0)\n     operands[2] = force_reg (SImode, operands[2]);\n \n@@ -3305,7 +3192,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"sgt_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(gt:CC (match_operand:SI 1 \"register_operand\" \"d\")\n+\t(gt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t       (match_operand:SI 2 \"reg_or_0_operand\" \"dJ\")))]\n   \"\"\n   \"slt\\\\t%0,%z2,%1\"\n@@ -3315,7 +3202,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"sge\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ge:CC (match_dup 1)\n+\t(ge:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n   \"\n@@ -3327,26 +3214,32 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n+  if (TARGET_DEBUG_C_MODE)\n+    {\n+      gen_int_relational (GE, operands[0], operands[1], operands[2], (int *)0);\n+      DONE;\n+    }\n+\n   /* fall through and generate default code */\n }\")\n \n (define_insn \"sge_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ge:CC (match_operand:SI 1 \"register_operand\" \"d\")\n+\t(ge:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t       (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n+  \"!TARGET_DEBUG_C_MODE\"\n   \"slt\\\\t%0,%1,%2\\;xori\\\\t%0,%0,0x0001\"\n  [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"2\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ge:CC (match_operand:SI 1 \"register_operand\" \"\")\n+\t(ge:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t       (match_operand:SI 2 \"arith_operand\" \"\")))]\n-  \"!TARGET_DEBUG_D_MODE\"\n+  \"!TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\"\n   [(set (match_dup 0)\n-\t(lt:CC (match_dup 1)\n+\t(lt:SI (match_dup 1)\n \t       (match_dup 2)))\n    (set (match_dup 0)\n \t(xor:SI (match_dup 0)\n@@ -3355,7 +3248,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"slt\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(lt:CC (match_dup 1)\n+\t(lt:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n   \"\n@@ -3367,12 +3260,18 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n+  if (TARGET_DEBUG_C_MODE)\n+    {\n+      gen_int_relational (LT, operands[0], operands[1], operands[2], (int *)0);\n+      DONE;\n+    }\n+\n   /* fall through and generate default code */\n }\")\n \n (define_insn \"slt_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(lt:CC (match_operand:SI 1 \"register_operand\" \"d\")\n+\t(lt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t       (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n   \"\"\n   \"slt\\\\t%0,%1,%2\"\n@@ -3382,7 +3281,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"sle\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(le:CC (match_dup 1)\n+\t(le:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n   \"\n@@ -3396,31 +3295,49 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n+  if (TARGET_DEBUG_C_MODE)\n+    {\n+      gen_int_relational (LE, operands[0], operands[1], operands[2], (int *)0);\n+      DONE;\n+    }\n+\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 32767)\n     operands[2] = force_reg (SImode, operands[2]);\n \n   /* fall through and generate default code */\n }\")\n \n-(define_insn \"sle_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-\t(le:CC (match_operand:SI 1 \"register_operand\" \"d,d\")\n-\t       (match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n-  \"GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) < 32767\"\n-  \"@\n-   slt\\\\t%0,%z2,%1\\;xori\\\\t%0,%0,0x0001\n-   slt\\\\t%0,%1,(%2+1)\"\n- [(set_attr \"type\"\t\"arith,arith\")\n-   (set_attr \"mode\"\t\"SI,SI\")\n-   (set_attr \"length\"\t\"2,1\")])\n+(define_insn \"sle_si_const\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(le:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t       (match_operand:SI 2 \"small_int\" \"I\")))]\n+  \"INTVAL (operands[2]) < 32767\"\n+  \"*\n+{\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2])+1);\n+  return \\\"slt\\\\t%0,%1,%2\\\";\n+}\"\n+ [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"sle_si_reg\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(le:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t       (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"!TARGET_DEBUG_C_MODE\"\n+  \"slt\\\\t%0,%z2,%1\\;xori\\\\t%0,%0,0x0001\"\n+ [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"2\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(le:CC (match_operand:SI 1 \"register_operand\" \"\")\n+\t(le:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t       (match_operand:SI 2 \"register_operand\" \"\")))]\n-  \"!TARGET_DEBUG_D_MODE\"\n+  \"!TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\"\n   [(set (match_dup 0)\n-\t(lt:CC (match_dup 2)\n+\t(lt:SI (match_dup 2)\n \t       (match_dup 1)))\n    (set (match_dup 0)\n \t(xor:SI (match_dup 0)\n@@ -3429,7 +3346,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"sgtu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(gtu:CC (match_dup 1)\n+\t(gtu:SI (match_dup 1)\n \t\t(match_dup 2)))]\n   \"\"\n   \"\n@@ -3443,6 +3360,12 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n+  if (TARGET_DEBUG_C_MODE)\n+    {\n+      gen_int_relational (GTU, operands[0], operands[1], operands[2], (int *)0);\n+      DONE;\n+    }\n+\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) != 0)\n     operands[2] = force_reg (SImode, operands[2]);\n \n@@ -3451,7 +3374,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"sgtu_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(gtu:CC (match_operand:SI 1 \"register_operand\" \"d\")\n+\t(gtu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t(match_operand:SI 2 \"reg_or_0_operand\" \"dJ\")))]\n   \"\"\n   \"sltu\\\\t%0,%z2,%1\"\n@@ -3461,7 +3384,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"sgeu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (geu:CC (match_dup 1)\n+        (geu:SI (match_dup 1)\n                 (match_dup 2)))]\n   \"\"\n   \"\n@@ -3473,26 +3396,32 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n+  if (TARGET_DEBUG_C_MODE)\n+    {\n+      gen_int_relational (GEU, operands[0], operands[1], operands[2], (int *)0);\n+      DONE;\n+    }\n+\n   /* fall through and generate default code */\n }\")\n \n (define_insn \"sgeu_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(geu:CC (match_operand:SI 1 \"register_operand\" \"d\")\n+\t(geu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n+  \"!TARGET_DEBUG_C_MODE\"\n   \"sltu\\\\t%0,%1,%2\\;xori\\\\t%0,%0,0x0001\"\n  [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"2\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(geu:CC (match_operand:SI 1 \"register_operand\" \"\")\n+\t(geu:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t(match_operand:SI 2 \"arith_operand\" \"\")))]\n-  \"!TARGET_DEBUG_D_MODE\"\n+  \"!TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\"\n   [(set (match_dup 0)\n-\t(ltu:CC (match_dup 1)\n+\t(ltu:SI (match_dup 1)\n \t\t(match_dup 2)))\n    (set (match_dup 0)\n \t(xor:SI (match_dup 0)\n@@ -3501,7 +3430,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"sltu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ltu:CC (match_dup 1)\n+\t(ltu:SI (match_dup 1)\n \t\t(match_dup 2)))]\n   \"\"\n   \"\n@@ -3513,12 +3442,18 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n+  if (TARGET_DEBUG_C_MODE)\n+    {\n+      gen_int_relational (LTU, operands[0], operands[1], operands[2], (int *)0);\n+      DONE;\n+    }\n+\n   /* fall through and generate default code */\n }\")\n \n (define_insn \"sltu_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ltu:CC (match_operand:SI 1 \"register_operand\" \"d\")\n+\t(ltu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n   \"\"\n   \"sltu\\\\t%0,%1,%2\"\n@@ -3528,7 +3463,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"sleu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(leu:CC (match_dup 1)\n+\t(leu:SI (match_dup 1)\n \t\t(match_dup 2)))]\n   \"\"\n   \"\n@@ -3542,37 +3477,279 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n+  if (TARGET_DEBUG_C_MODE)\n+    {\n+      gen_int_relational (LEU, operands[0], operands[1], operands[2], (int *)0);\n+      DONE;\n+    }\n+\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 32767)\n     operands[2] = force_reg (SImode, operands[2]);\n \n   /* fall through and generate default code */\n }\")\n \n-(define_insn \"sleu_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-\t(leu:CC (match_operand:SI 1 \"register_operand\" \"d,d\")\n-\t\t(match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n-  \"GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) < 32767\"\n-  \"@\n-   sltu\\\\t%0,%z2,%1\\;xori\\\\t%0,%0,0x0001\n-   sltu\\\\t%0,%1,(%2+1)\"\n- [(set_attr \"type\"\t\"arith,arith\")\n-   (set_attr \"mode\"\t\"SI,SI\")\n-   (set_attr \"length\"\t\"2,1\")])\n+(define_insn \"sleu_si_const\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(leu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t(match_operand:SI 2 \"small_int\" \"I\")))]\n+  \"INTVAL (operands[2]) < 32767\"\n+  \"*\n+{\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2])+1);\n+  return \\\"sltu\\\\t%0,%1,%2\\\";\n+}\"\n+ [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"sleu_si_reg\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(leu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"!TARGET_DEBUG_C_MODE\"\n+  \"sltu\\\\t%0,%z2,%1\\;xori\\\\t%0,%0,0x0001\"\n+ [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"2\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(leu:CC (match_operand:SI 1 \"register_operand\" \"\")\n+\t(leu:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t(match_operand:SI 2 \"register_operand\" \"\")))]\n-  \"!TARGET_DEBUG_D_MODE\"\n+  \"!TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\"\n   [(set (match_dup 0)\n-\t(ltu:CC (match_dup 2)\n+\t(ltu:SI (match_dup 2)\n \t\t(match_dup 1)))\n    (set (match_dup 0)\n \t(xor:SI (match_dup 0)\n \t\t(const_int 1)))]\n   \"\")\n \n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tFLOATING POINT COMPARISONS\n+;;\n+;;  ....................\n+\n+(define_insn \"seq_df\"\n+  [(set (reg:CC_FP 66)\n+\t(eq:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n+\t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+  xoperands[1] = operands[0];\n+  xoperands[2] = operands[1];\n+\n+  return mips_fill_delay_slot (\\\"c.eq.d\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+}\"\n+ [(set_attr \"type\"\t\"fcmp\")\n+  (set_attr \"mode\"\t\"FPSW\")\n+  (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"sne_df\"\n+  [(set (reg:CC_REV_FP 66)\n+\t(ne:CC_REV_FP (match_operand:DF 0 \"register_operand\" \"f\")\n+\t\t      (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+  xoperands[1] = operands[0];\n+  xoperands[2] = operands[1];\n+\n+  return mips_fill_delay_slot (\\\"c.eq.d\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+}\"\n+ [(set_attr \"type\"\t\"fcmp\")\n+  (set_attr \"mode\"\t\"FPSW\")\n+  (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"slt_df\"\n+  [(set (reg:CC_FP 66)\n+\t(lt:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n+\t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+  xoperands[1] = operands[0];\n+  xoperands[2] = operands[1];\n+\n+  return mips_fill_delay_slot (\\\"c.lt.d\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+}\"\n+ [(set_attr \"type\"\t\"fcmp\")\n+  (set_attr \"mode\"\t\"FPSW\")\n+  (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"sle_df\"\n+  [(set (reg:CC_FP 66)\n+\t(le:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n+\t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+  xoperands[1] = operands[0];\n+  xoperands[2] = operands[1];\n+\n+  return mips_fill_delay_slot (\\\"c.le.d\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+}\"\n+ [(set_attr \"type\"\t\"fcmp\")\n+  (set_attr \"mode\"\t\"FPSW\")\n+  (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"sgt_df\"\n+  [(set (reg:CC_FP 66)\n+\t(gt:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n+\t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+  xoperands[1] = operands[0];\n+  xoperands[2] = operands[1];\n+\n+  return mips_fill_delay_slot (\\\"c.lt.d\\\\t%1,%0\\\", DELAY_FCMP, xoperands, insn);\n+}\"\n+ [(set_attr \"type\"\t\"fcmp\")\n+  (set_attr \"mode\"\t\"FPSW\")\n+  (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"sge_df\"\n+  [(set (reg:CC_FP 66)\n+\t(ge:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n+\t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+  xoperands[1] = operands[0];\n+  xoperands[2] = operands[1];\n+\n+  return mips_fill_delay_slot (\\\"c.le.d\\\\t%1,%0\\\", DELAY_FCMP, xoperands, insn);\n+}\"\n+ [(set_attr \"type\"\t\"fcmp\")\n+  (set_attr \"mode\"\t\"FPSW\")\n+  (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"seq_sf\"\n+  [(set (reg:CC_FP 66)\n+\t(eq:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n+\t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+  xoperands[1] = operands[0];\n+  xoperands[2] = operands[1];\n+\n+  return mips_fill_delay_slot (\\\"c.eq.s\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+}\"\n+ [(set_attr \"type\"\t\"fcmp\")\n+  (set_attr \"mode\"\t\"FPSW\")\n+  (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"sne_sf\"\n+  [(set (reg:CC_REV_FP 66)\n+\t(ne:CC_REV_FP (match_operand:SF 0 \"register_operand\" \"f\")\n+\t\t      (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+  xoperands[1] = operands[0];\n+  xoperands[2] = operands[1];\n+\n+  return mips_fill_delay_slot (\\\"c.eq.s\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+}\"\n+ [(set_attr \"type\"\t\"fcmp\")\n+  (set_attr \"mode\"\t\"FPSW\")\n+  (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"slt_sf\"\n+  [(set (reg:CC_FP 66)\n+\t(lt:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n+\t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+  xoperands[1] = operands[0];\n+  xoperands[2] = operands[1];\n+\n+  return mips_fill_delay_slot (\\\"c.lt.s\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+}\"\n+ [(set_attr \"type\"\t\"fcmp\")\n+  (set_attr \"mode\"\t\"FPSW\")\n+  (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"sle_sf\"\n+  [(set (reg:CC_FP 66)\n+\t(le:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n+\t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+  xoperands[1] = operands[0];\n+  xoperands[2] = operands[1];\n+\n+  return mips_fill_delay_slot (\\\"c.le.s\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+}\"\n+ [(set_attr \"type\"\t\"fcmp\")\n+  (set_attr \"mode\"\t\"FPSW\")\n+  (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"sgt_sf\"\n+  [(set (reg:CC_FP 66)\n+\t(gt:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n+\t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+  xoperands[1] = operands[0];\n+  xoperands[2] = operands[1];\n+\n+  return mips_fill_delay_slot (\\\"c.lt.s\\\\t%1,%0\\\", DELAY_FCMP, xoperands, insn);\n+}\"\n+ [(set_attr \"type\"\t\"fcmp\")\n+  (set_attr \"mode\"\t\"FPSW\")\n+  (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"sge_sf\"\n+  [(set (reg:CC_FP 66)\n+\t(ge:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n+\t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[10];\n+  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+  xoperands[1] = operands[0];\n+  xoperands[2] = operands[1];\n+\n+  return mips_fill_delay_slot (\\\"c.le.s\\\\t%1,%0\\\", DELAY_FCMP, xoperands, insn);\n+}\"\n+ [(set_attr \"type\"\t\"fcmp\")\n+  (set_attr \"mode\"\t\"FPSW\")\n+  (set_attr \"length\"\t\"1\")])\n+\n \f\n ;;\n ;;  ...................."}]}