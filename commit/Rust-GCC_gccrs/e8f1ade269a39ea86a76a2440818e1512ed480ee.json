{"sha": "e8f1ade269a39ea86a76a2440818e1512ed480ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThmMWFkZTI2OWEzOWVhODZhNzZhMjQ0MDgxOGUxNTEyZWQ0ODBlZQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-12-17T23:53:07Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-12-17T23:53:07Z"}, "message": "PR c++/61339 - add warning for mismatch between struct and class\n\ngcc/c-family/ChangeLog:\n\n\tPR c++/61339\n\t* c.opt (-Wmismatched-tags, -Wredundant-tags): New options.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/61339\n\t* parser.c (cp_parser_maybe_warn_enum_key): New function.\n\t(class_decl_loc_t): New class.\n\t(cp_parser_elaborated_type_specifier): Call\n\tcp_parser_maybe_warn_enum_key.\n\t(cp_parser_class_head): Call cp_parser_check_class_key.\n\t(cp_parser_check_class_key): Add arguments.  Call class_decl_loc_t::add.\n\t(c_parse_file): Call class_decl_loc_t::diag_mismatched_tags.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/61339\n\t* g++.dg/warn/Wmismatched-tags.C: New test.\n\t* g++.dg/warn/Wredundant-tags.C: New test.\n\t* g++.dg/pch/Wmismatched-tags.C: New test.\n\t* g++.dg/pch/Wmismatched-tags.Hs: New test header.\n\ngcc/ChangeLog:\n\n\tPR c++/61339\n\t* doc/invoke.texi (-Wmismatched-tags, -Wredundant-tags): Document\n\tnew C++ options.\n\nFrom-SVN: r279480", "tree": {"sha": "6e3d510dd85b3c1cd750eb1e46594fa5374f03e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e3d510dd85b3c1cd750eb1e46594fa5374f03e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8f1ade269a39ea86a76a2440818e1512ed480ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8f1ade269a39ea86a76a2440818e1512ed480ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8f1ade269a39ea86a76a2440818e1512ed480ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8f1ade269a39ea86a76a2440818e1512ed480ee/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "54ba911fd1670654d494f238d83e337a4aeb0cb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54ba911fd1670654d494f238d83e337a4aeb0cb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54ba911fd1670654d494f238d83e337a4aeb0cb4"}], "stats": {"total": 946, "additions": 932, "deletions": 14}, "files": [{"sha": "a77f573d2c4c6f423b928ad4934ae477ddf9606d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8f1ade269a39ea86a76a2440818e1512ed480ee", "patch": "@@ -1,3 +1,9 @@\n+2019-12-17  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/61339\n+\t* doc/invoke.texi (-Wmismatched-tags, -Wredundant-tags): Document\n+\tnew C++ options.\n+\n 2019-12-17  Michael Meissner  <meissner@linux.ibm.com>\n \n \t* config/rs6000/rs6000.c (num_insns_constant_gpr): Return 1 if the"}, {"sha": "966607f59c9765ad2cd5c43cc991b31e4f15db73", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=e8f1ade269a39ea86a76a2440818e1512ed480ee", "patch": "@@ -1,3 +1,8 @@\n+2019-12-17  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/61339\n+\t* c.opt (-Wmismatched-tags, -Wredundant-tags): New options.\n+\n 2019-12-11  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-pretty-print.c (c_pretty_printer::clone): New vfunc"}, {"sha": "1fcb2e303b0332777cd25bdb4711b1d7a0f13497", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=e8f1ade269a39ea86a76a2440818e1512ed480ee", "patch": "@@ -755,6 +755,10 @@ Wmisleading-indentation\n C C++ Common Var(warn_misleading_indentation) Warning LangEnabledBy(C C++,Wall)\n Warn when the indentation of the code does not reflect the block structure.\n \n+Wmismatched-tags\n+C++ ObjC++ Var(warn_mismatched_tags) Warning\n+Warn when a class is redeclared or referenced using a mismatched class-key.\n+\n Wmissing-braces\n C ObjC C++ ObjC++ Var(warn_missing_braces) Warning LangEnabledBy(C ObjC,Wall)\n Warn about possibly missing braces around initializers.\n@@ -783,6 +787,10 @@ Wpacked-not-aligned\n C ObjC C++ ObjC++ Var(warn_packed_not_aligned) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n Warn when fields in a struct with the packed attribute are misaligned.\n \n+Wredundant-tags\n+C++ ObjC++ Var(warn_redundant_tags) Warning\n+Warn when a class or enumerated type is referenced using a redundant class-key.\n+\n Wsized-deallocation\n C++ ObjC++ Var(warn_sized_deallocation) Warning EnabledBy(Wextra)\n Warn about missing sized deallocation functions."}, {"sha": "eefe5bf45389879ae2f23b4f8f015bfdffc03925", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e8f1ade269a39ea86a76a2440818e1512ed480ee", "patch": "@@ -1,3 +1,14 @@\n+2019-12-17  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/61339\n+\t* parser.c (cp_parser_maybe_warn_enum_key): New function.\n+\t(class_decl_loc_t): New class.\n+\t(cp_parser_elaborated_type_specifier): Call\n+\tcp_parser_maybe_warn_enum_key.\n+\t(cp_parser_class_head): Call cp_parser_check_class_key.\n+\t(cp_parser_check_class_key): Add arguments.  Call class_decl_loc_t::add.\n+\t(c_parse_file): Call class_decl_loc_t::diag_mismatched_tags.\n+\n 2019-12-17  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/79592 - missing explanation of invalid constexpr."}, {"sha": "f61089934dfe6bcd8865251dbb210f0c3b320cc7", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 423, "deletions": 12, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e8f1ade269a39ea86a76a2440818e1512ed480ee", "patch": "@@ -2599,8 +2599,9 @@ static enum tag_types cp_parser_token_is_class_key\n   (cp_token *);\n static enum tag_types cp_parser_token_is_type_parameter_key\n   (cp_token *);\n+static void cp_parser_maybe_warn_enum_key (cp_parser *, location_t, tree, rid);\n static void cp_parser_check_class_key\n-  (enum tag_types, tree type);\n+(cp_parser *, location_t, enum tag_types, tree type, bool, bool);\n static void cp_parser_check_access_in_redeclaration\n   (tree type, location_t location);\n static bool cp_parser_optional_template_keyword\n@@ -18498,6 +18499,11 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n   tree globalscope;\n   cp_token *token = NULL;\n \n+  /* For class and enum types the location of the class-key or enum-key.  */\n+  location_t key_loc = cp_lexer_peek_token (parser->lexer)->location;\n+  /* For a scoped enum, the 'class' or 'struct' keyword id.  */\n+  rid scoped_key = RID_MAX;\n+\n   /* See if we're looking at the `enum' keyword.  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_ENUM))\n     {\n@@ -18508,18 +18514,24 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       /* Issue a warning if the `struct' or `class' key (for C++0x scoped\n \t enums) is used here.  */\n       cp_token *token = cp_lexer_peek_token (parser->lexer);\n-      if (cp_parser_is_keyword (token, RID_CLASS)\n-\t  || cp_parser_is_keyword (token, RID_STRUCT))\n+      if (cp_parser_is_keyword (token, scoped_key = RID_CLASS)\n+\t  || cp_parser_is_keyword (token, scoped_key = RID_STRUCT))\n \t{\n-\t  gcc_rich_location richloc (token->location);\n+\t  location_t loc = token->location;\n+\t  gcc_rich_location richloc (loc);\n \t  richloc.add_range (input_location);\n \t  richloc.add_fixit_remove ();\n \t  pedwarn (&richloc, 0, \"elaborated-type-specifier for \"\n \t\t   \"a scoped enum must not use the %qD keyword\",\n \t\t   token->u.value);\n \t  /* Consume the `struct' or `class' and parse it anyway.  */\n \t  cp_lexer_consume_token (parser->lexer);\n+\t  /* Create a combined location for the whole scoped-enum-key.  */\n+\t  key_loc = make_location (key_loc, key_loc, loc);\n \t}\n+      else\n+\tscoped_key = RID_MAX;\n+\n       /* Parse the attributes.  */\n       attributes = cp_parser_attributes_opt (parser);\n     }\n@@ -18535,6 +18547,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n   /* Otherwise it must be a class-key.  */\n   else\n     {\n+      key_loc = cp_lexer_peek_token (parser->lexer)->location;\n       tag_type = cp_parser_class_key (parser);\n       if (tag_type == none_type)\n \treturn error_mark_node;\n@@ -18845,13 +18858,18 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t\t \"attributes ignored on elaborated-type-specifier that is not a forward declaration\");\n     }\n \n-  if (tag_type != enum_type)\n+  if (tag_type == enum_type)\n+    cp_parser_maybe_warn_enum_key (parser, key_loc, type, scoped_key);\n+  else\n     {\n+      /* Diagnose class/struct/union mismatches.  */\n+      cp_parser_check_class_key (parser, key_loc, tag_type, type, false,\n+\t\t\t\t cp_parser_declares_only_class_p (parser));\n+\n       /* Indicate whether this class was declared as a `class' or as a\n \t `struct'.  */\n-      if (CLASS_TYPE_P (type))\n+      if (CLASS_TYPE_P (type) && !currently_open_class (type))\n \tCLASSTYPE_DECLARED_CLASS (type) = (tag_type == class_type);\n-      cp_parser_check_class_key (tag_type, type);\n     }\n \n   /* A \"<\" cannot follow an elaborated type specifier.  If that\n@@ -24389,11 +24407,14 @@ cp_parser_class_head (cp_parser* parser,\n \t\t       parser->num_template_parameter_lists);\n     }\n \n+  /* Diagnose class/struct/union mismatches.  */\n+  cp_parser_check_class_key (parser, UNKNOWN_LOCATION, class_key, type,\n+\t\t\t     true, true);\n+\n   /* Indicate whether this class was declared as a `class' or as a\n      `struct'.  */\n   if (TREE_CODE (type) == RECORD_TYPE)\n-    CLASSTYPE_DECLARED_CLASS (type) = (class_key == class_type);\n-  cp_parser_check_class_key (class_key, type);\n+    CLASSTYPE_DECLARED_CLASS (type) = class_key == class_type;\n \n   /* If this type was already complete, and we see another definition,\n      that's an error.  Likewise if the type is already being defined:\n@@ -30617,22 +30638,410 @@ cp_parser_token_is_type_parameter_key (cp_token* token)\n     }\n }\n \n-/* Issue an error message if the CLASS_KEY does not match the TYPE.  */\n+/* Diagnose redundant enum-keys.  */\n \n static void\n-cp_parser_check_class_key (enum tag_types class_key, tree type)\n+cp_parser_maybe_warn_enum_key (cp_parser *parser, location_t key_loc,\n+\t\t\t       tree type, rid scoped_key)\n+{\n+  tree type_decl = TYPE_MAIN_DECL (type);\n+  tree name = DECL_NAME (type_decl);\n+  /* Look up the NAME to see if it unambiguously refers to the TYPE\n+     and set KEY_REDUNDANT if so.  */\n+  tree decl = cp_parser_lookup_name_simple (parser, name, input_location);\n+\n+  /* The enum-key is redundant for uses of the TYPE that are not\n+     declarations and for which name lookup returns just the type\n+     itself.  */\n+  if (decl == type_decl)\n+    {\n+      gcc_rich_location richloc (key_loc);\n+      richloc.add_fixit_remove (key_loc);\n+      warning_at (&richloc, OPT_Wredundant_tags,\n+\t\t  \"redundant enum-key %<enum%s%> in reference to %q#T\",\n+\t\t  (scoped_key == RID_CLASS ? \" class\"\n+\t\t   : scoped_key == RID_STRUCT ? \" struct\" : \"\"), type);\n+    }\n+}\n+\n+/* Describes the set of declarations of a struct, class, or class template\n+   or its specializations.  Used for -Wmismatched-tags.  */\n+\n+class class_decl_loc_t\n+{\n+ public:\n+\n+  class_decl_loc_t ()\n+    : locvec (), idxdef (), def_class_key ()\n+  {\n+    locvec.create (4);\n+  }\n+\n+  /* Constructs an object for a single declaration of a class with\n+     CLASS_KEY at the current location in the current function (or\n+     at another scope).  KEY_REDUNDANT is true if the class-key may\n+     be omitted in the current context without an ambiguity with\n+     another symbol with the same name.\n+     DEF_P is true for a class declaration that is a definition.\n+     CURLOC is the associated location.  */\n+  class_decl_loc_t (tag_types class_key, bool key_redundant, bool def_p,\n+\t\t    location_t curloc = input_location)\n+    : locvec (), idxdef (def_p ? 0 : UINT_MAX), def_class_key (class_key)\n+  {\n+    locvec.create (4);\n+    class_key_loc_t ckl (current_function_decl, curloc, class_key,\n+\t\t\t key_redundant);\n+    locvec.quick_push (ckl);\n+  }\n+\n+  /* Copy, assign, and destroy the object.  Necessary because LOCVEC\n+     isn't safely copyable and assignable and doesn't release storage\n+     on its own.  */\n+  class_decl_loc_t (const class_decl_loc_t &rhs)\n+    : locvec (rhs.locvec.copy ()), idxdef (rhs.idxdef),\n+      def_class_key (rhs.def_class_key)\n+  { }\n+\n+  class_decl_loc_t& operator= (const class_decl_loc_t &rhs)\n+  {\n+    if (this == &rhs)\n+      return *this;\n+    locvec.release ();\n+    locvec = rhs.locvec.copy ();\n+    idxdef = rhs.idxdef;\n+    def_class_key = rhs.def_class_key;\n+    return *this;\n+  }\n+\n+  ~class_decl_loc_t ()\n+  {\n+    locvec.release ();\n+  }\n+\n+  /* Issues -Wmismatched-tags for a single class.  */\n+  void diag_mismatched_tags (tree);\n+\n+  /* Issues -Wmismatched-tags for all classes.  */\n+  static void diag_mismatched_tags ();\n+\n+  /* Adds TYPE_DECL to the collection of class decls.  */\n+  static void add (tree, tag_types, bool, bool);\n+\n+  /* Either adds this decl to the collection of class decls\n+     or diagnoses it, whichever is appropriate.  */\n+  void add_or_diag_mismatched_tag (tree, tag_types, bool, bool);\n+\n+private:\n+\n+  tree function (unsigned i) const\n+  {\n+    return locvec[i].func;\n+  }\n+\n+  location_t location (unsigned i) const\n+  {\n+    return locvec[i].loc;\n+  }\n+\n+  bool key_redundant (unsigned i) const\n+  {\n+    return locvec[i].key_redundant;\n+  }\n+\n+  tag_types class_key (unsigned i) const\n+  {\n+    return locvec[i].class_key;\n+  }\n+\n+  /* The location of a single mention of a class type with the given\n+     class-key.  */\n+  struct class_key_loc_t\n+  {\n+    class_key_loc_t (tree func, location_t loc, tag_types key, bool redundant)\n+      : func (func), loc (loc), class_key (key), key_redundant (redundant) { }\n+\n+    /* The function the type is mentioned in.  */\n+    tree func;\n+    /* The exact location.  */\n+    location_t loc;\n+    /* The class-key used in the mention of the type.  */\n+    tag_types class_key;\n+    /* True when the class-key could be omitted at this location\n+       without an ambiguity with another symbol of the same name.  */\n+    bool key_redundant;\n+  };\n+  /* Avoid using auto_vec here since it's not safe to copy due to pr90904.  */\n+  vec <class_key_loc_t> locvec;\n+  /* LOCVEC index of the definition or UINT_MAX if none exists.  */\n+  unsigned idxdef;\n+  /* The class-key the class was last declared with or none_type when\n+     it has been declared with a mismatched key.  */\n+  tag_types def_class_key;\n+\n+  /* A mapping between a TYPE_DECL for a class and the class_decl_loc_t\n+     description above.  */\n+  typedef hash_map<tree_decl_hash, class_decl_loc_t> class_to_loc_map_t;\n+  static class_to_loc_map_t class2loc;\n+};\n+\n+class_decl_loc_t::class_to_loc_map_t class_decl_loc_t::class2loc;\n+\n+/* Issue an error message if the CLASS_KEY does not match the TYPE.\n+   DEF_P is expected to be set for a definition of class TYPE.  DECL_P\n+   is set for a declaration of class TYPE and clear for a reference to\n+   it that is not a declaration of it.  */\n+\n+static void\n+cp_parser_check_class_key (cp_parser *parser, location_t key_loc,\n+\t\t\t   tag_types class_key, tree type, bool def_p,\n+\t\t\t   bool decl_p)\n {\n   if (type == error_mark_node)\n     return;\n-  if ((TREE_CODE (type) == UNION_TYPE) != (class_key == union_type))\n+\n+  bool seen_as_union = TREE_CODE (type) == UNION_TYPE;\n+  if (seen_as_union != (class_key == union_type))\n     {\n       if (permerror (input_location, \"%qs tag used in naming %q#T\",\n \t\t     class_key == union_type ? \"union\"\n \t\t     : class_key == record_type ? \"struct\" : \"class\",\n \t\t     type))\n \tinform (DECL_SOURCE_LOCATION (TYPE_NAME (type)),\n \t\t\"%q#T was previously declared here\", type);\n+      return;\n     }\n+\n+  if (!warn_mismatched_tags && !warn_redundant_tags)\n+    return;\n+\n+  tree type_decl = TYPE_MAIN_DECL (type);\n+  tree name = DECL_NAME (type_decl);\n+  /* Look up the NAME to see if it unambiguously refers to the TYPE\n+     and set KEY_REDUNDANT if so.  */\n+  tree decl = cp_parser_lookup_name_simple (parser, name, input_location);\n+\n+  /* The class-key is redundant for uses of the CLASS_TYPE that are\n+     neither definitions of it nor declarations, and for which name\n+     lookup returns just the type itself.  */\n+  bool key_redundant = !def_p && !decl_p && decl == type_decl;\n+  if (key_redundant)\n+    {\n+      gcc_rich_location richloc (key_loc);\n+      richloc.add_fixit_remove (key_loc);\n+      warning_at (&richloc, OPT_Wredundant_tags,\n+\t\t\"redundant class-key %qs in reference to %q#T\",\n+\t\tclass_key == union_type ? \"union\"\n+\t\t: class_key == record_type ? \"struct\" : \"class\",\n+\t\ttype);\n+    }\n+\n+  if (seen_as_union || !warn_mismatched_tags)\n+    return;\n+\n+  class_decl_loc_t::add (type_decl, class_key, key_redundant, def_p);\n+}\n+\n+/* Adds TYPE_DECL to the collection of class decls.  */\n+\n+void\n+class_decl_loc_t::add (tree type_decl, tag_types class_key, bool redundant,\n+\t\t       bool def_p)\n+{\n+  bool exist;\n+  class_decl_loc_t *rdl = &class2loc.get_or_insert (type_decl, &exist);\n+  if (!exist)\n+    {\n+      tree type = TREE_TYPE (type_decl);\n+      if (def_p || !COMPLETE_TYPE_P (type))\n+\t{\n+\t  /* TYPE_DECL is the first declaration or definition of the type\n+\t     (outside precompiled headers -- see below).  Just create\n+\t     a new entry for it.  */\n+\t  *rdl = class_decl_loc_t (class_key, false, def_p);\n+\t  return;\n+\t}\n+\n+      /* TYPE was previously defined in some unknown precompiled hdeader.\n+\t Simply add a record of its definition at an unknown location and\n+\t proceed below to add a reference to it at the current location.\n+\t (Declarations in precompiled headers that are not definitions\n+\t are ignored.)  */\n+      tag_types def_key\n+\t= CLASSTYPE_DECLARED_CLASS (type) ? class_type : record_type;\n+      location_t def_loc = DECL_SOURCE_LOCATION (type_decl);\n+      *rdl = class_decl_loc_t (def_key, false, true, def_loc);\n+    }\n+\n+  /* A prior declaration of TYPE_DECL has been seen.  */\n+\n+  if (rdl->idxdef != UINT_MAX && rdl->def_class_key == class_key)\n+    /* Do nothing if the class-key in this declaration matches\n+       the definition.  */\n+    return;\n+\n+  rdl->add_or_diag_mismatched_tag (type_decl, class_key, redundant, def_p);\n+}\n+\n+/* Either adds this DECL corresponding to the TYPE_DECL to the collection\n+   of class decls or diagnoses it, whichever is appropriate.  */\n+\n+void\n+class_decl_loc_t::add_or_diag_mismatched_tag (tree type_decl,\n+\t\t\t\t\t      tag_types class_key,\n+\t\t\t\t\t      bool redundant,\n+\t\t\t\t\t      bool def_p)\n+{\n+  /* Reset the CLASS_KEY associated with this type on mismatch.\n+     This is an optimization that lets the diagnostic code skip\n+     over classes that use the same class-key in all declarations.  */\n+  if (def_class_key != class_key)\n+    def_class_key = none_type;\n+\n+  /* Set IDXDEF to the index of the vector corresponding to\n+     the definition.  */\n+  if (def_p)\n+    idxdef = locvec.length ();\n+\n+  /* Append a record of this declaration to the vector.  */\n+  class_key_loc_t ckl (current_function_decl, input_location, class_key,\n+\t\t       redundant);\n+  locvec.safe_push (ckl);\n+\n+  if (idxdef == UINT_MAX)\n+    return;\n+\n+  /* As a space optimization diagnose declarations of a class\n+     whose definition has been seen and purge the LOCVEC of\n+     all entries except the definition.  */\n+  diag_mismatched_tags (type_decl);\n+  if (idxdef)\n+    {\n+      class_decl_loc_t::class_key_loc_t ent = locvec[idxdef];\n+      locvec.release ();\n+      locvec.reserve (2);\n+      locvec.safe_push (ent);\n+      idxdef = 0;\n+    }\n+  else\n+    /* Pop the entry pushed above for this declaration.  */\n+    locvec.pop ();\n+}\n+\n+/* Issues -Wmismatched-tags for a single class.  */\n+\n+void\n+class_decl_loc_t::diag_mismatched_tags (tree type_decl)\n+{\n+  unsigned ndecls = locvec.length ();\n+\n+  /* Skip a declaration that consistently uses the same class-key\n+     or one with just a solitary declaration (i.e., TYPE_DECL).  */\n+  if (def_class_key != none_type || ndecls < 2)\n+    return;\n+\n+  /* Save the current function before changing it below.  */\n+  tree save_func = current_function_decl;\n+  /* Set if a class definition for RECLOC has been seen.  */\n+  bool def_p = idxdef < ndecls;\n+  unsigned idxguide = def_p ? idxdef : 0;\n+  unsigned idx = 0;\n+  /* Advance IDX to the first declaration that either is not\n+     a definition or that doesn't match the first declaration\n+     if no definition is provided.  */\n+  while (class_key (idx) == class_key (idxguide))\n+    if (++idx == ndecls)\n+      return;\n+\n+  /* The class-key the class is expected to be declared with: it's\n+     either the key used in its definition or the first declaration\n+     if no definition has been provided.  */\n+  tag_types xpect_key = class_key (def_p ? idxguide : 0);\n+  const char *xmatchkstr = xpect_key == record_type ? \"class\" : \"struct\";\n+  const char *xpectkstr = xpect_key == record_type ? \"struct\" : \"class\";\n+  /* Set the function declaration to print in diagnostic context.  */\n+  current_function_decl = function (idx);\n+\n+  location_t loc = location (idx);\n+  bool key_redundant_p = key_redundant (idx);\n+  auto_diagnostic_group d;\n+  /* Issue a warning for the first mismatched declaration.\n+     Avoid using \"%#qT\" since the class-key for the same type will\n+     be the same regardless of which one was used in the declaraion.  */\n+  warning_at (loc, OPT_Wmismatched_tags,\n+\t      \"%qT declared with a mismatched class-key %qs\",\n+\t      type_decl, xmatchkstr);\n+\n+  /* Suggest how to avoid the warning for each instance since\n+     the guidance may be different depending on context.  */\n+  inform (loc,\n+\t  (key_redundant_p\n+\t   ? G_(\"remove the class-key or replace it with %qs\")\n+\t   : G_(\"replace the class-key with %qs\")),\n+\t  xpectkstr);\n+\n+  /* Also point to the first declaration or definition that guided\n+     the decision to issue the warning above.  */\n+  inform (location (idxguide),\n+\t  (def_p\n+\t   ? G_(\"%qT defined as %qs here\")\n+\t   : G_(\"%qT first declared as %qs here\")),\n+\t  type_decl, xpectkstr);\n+\n+  /* Issue warnings for the remaining inconsistent declarations.  */\n+  for (unsigned i = idx + 1; i != ndecls; ++i)\n+    {\n+      tag_types clskey = class_key (i);\n+      /* Skip over the declarations that match either the definition\n+\t if one was provided or the first declaration.  */\n+      if (clskey == xpect_key)\n+\tcontinue;\n+\n+      loc = location (i);\n+      key_redundant_p = key_redundant (i);\n+      /* Set the function declaration to print in diagnostic context.  */\n+      current_function_decl = function (i);\n+      warning_at (loc, OPT_Wmismatched_tags,\n+\t\t  \"%qT declared with a mismatched class-key %qs\",\n+\t\t  type_decl, xmatchkstr);\n+      /* Suggest how to avoid the warning for each instance since\n+\t the guidance may be different depending on context.  */\n+      inform (loc,\n+\t      (key_redundant_p\n+\t       ? G_(\"remove the class-key or replace it with %qs\")\n+\t       : G_(\"replace the class-key with %qs\")),\n+\t      xpectkstr);\n+    }\n+\n+  /* Restore the current function in case it was replaced above.  */\n+  current_function_decl = save_func;\n+}\n+\n+/* Issues -Wmismatched-tags for all classes.  Called at the end\n+   of processing a translation unit, after declarations of all class\n+   types and their uses have been recorded.  */\n+\n+void\n+class_decl_loc_t::diag_mismatched_tags ()\n+{\n+  /* CLASS2LOC should be empty if -Wmismatched-tags is disabled.  */\n+  gcc_assert (warn_mismatched_tags || class2loc.is_empty ());\n+\n+  /* Save the current function before changing it below.  It should\n+     be null at this point.  */\n+  tree save_func = current_function_decl;\n+\n+  /* Iterate over the collected class/struct declarations.  */\n+  typedef class_to_loc_map_t::iterator iter_t;\n+  for (iter_t it = class2loc.begin (); it != class2loc.end (); ++it)\n+    {\n+      tree type_decl = (*it).first;\n+      class_decl_loc_t &recloc = (*it).second;\n+      recloc.diag_mismatched_tags (type_decl);\n+    }\n+\n+  class2loc.empty ();\n+  /* Restore the current function.  */\n+  current_function_decl = save_func;\n }\n \n /* Issue an error message if DECL is redeclared with different\n@@ -43065,6 +43474,8 @@ c_parse_file (void)\n   push_deferring_access_checks (flag_access_control\n \t\t\t\t? dk_no_deferred : dk_no_check);\n   cp_parser_translation_unit (the_parser);\n+  class_decl_loc_t::diag_mismatched_tags ();\n+\n   the_parser = NULL;\n \n   finish_translation_unit ();"}, {"sha": "1493e8d633c479e398de536e78d8df3ec6ab6829", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e8f1ade269a39ea86a76a2440818e1512ed480ee", "patch": "@@ -233,10 +233,10 @@ in the following sections.\n -Wabi=@var{n}  -Wabi-tag  -Wcomma-subscript  -Wconversion-null @gol\n -Wctor-dtor-privacy @gol\n -Wdelete-non-virtual-dtor  -Wdeprecated-copy  -Wdeprecated-copy-dtor @gol\n--Wliteral-suffix @gol\n+-Wliteral-suffix -Wmismatched-tags @gol\n -Wmultiple-inheritance  -Wno-init-list-lifetime @gol\n -Wnamespaces  -Wnarrowing @gol\n--Wpessimizing-move  -Wredundant-move @gol\n+-Wpessimizing-move  -Wredundant-move -Wredundant-tags @gol\n -Wnoexcept  -Wnoexcept-type  -Wclass-memaccess @gol\n -Wnon-virtual-dtor  -Wreorder  -Wregister @gol\n -Weffc++  -Wstrict-null-sentinel  -Wtemplates @gol\n@@ -3323,6 +3323,21 @@ treats the return value as if it were designated by an rvalue.\n \n This warning is enabled by @option{-Wextra}.\n \n+@item -Wredundant-tags @r{(C++ and Objective-C++ only)}\n+@opindex Wredundant-tags\n+@opindex Wno-redundant-tags\n+Warn about redundant class-key and enum-key in references to class types\n+and enumerated types in contexts where the key can be eliminated without\n+causing an ambiguity.  For example\n+\n+@smallexample\n+struct foo;\n+struct foo *p;   // -Wredundant-tags, keyword struct can be eliminated\n+\n+void foo ();   // \"hides\" struct foo\n+void bar (struct foo&);   // no warning, keyword struct cannot be eliminated\n+@end smallexample\n+\n @item -fext-numeric-literals @r{(C++ and Objective-C++ only)}\n @opindex fext-numeric-literals\n @opindex fno-ext-numeric-literals\n@@ -3458,6 +3473,32 @@ The warning is inactive inside a system header file, such as the STL, so\n one can still use the STL.  One may also instantiate or specialize\n templates.\n \n+@item -Wmismatched-tags @r{(C++ and Objective-C++ only)}\n+@opindex Wmismatched-tags\n+@opindex Wno-mismatched-tags\n+Warn for declarations of structs, classes, and class templates and their\n+specializations with a class-key that does not match either the definition\n+or the first declaration if no definition is provided.\n+\n+For example, the declaration of @code{struct Object} in the argument list\n+of @code{draw} triggers the warning.  To avoid it, either remove the redundant\n+class-key @code{struct} or replace it with @code{class} to match its definition.\n+@smallexample\n+class Object @{\n+public:\n+  virtual ~Object () = 0;\n+@};\n+void draw (struct Object*);\n+@end smallexample\n+\n+It is not wrong to declare a class with the class-key @code{struct} as\n+the example above shows.  The @option{-Wmismatched-tags} option is intended\n+to help achieve a consistent style of class declarations.  In code that is\n+intended to be portable to Windows-based compilers the warning helps prevent\n+unresolved references due to the difference in the mangling of symbols\n+declared with different class-keys.  The option can be used either on its\n+own or in conjunction with @option{-Wredundant-tags}.\n+\n @item -Wmultiple-inheritance @r{(C++ and Objective-C++ only)}\n @opindex Wmultiple-inheritance\n @opindex Wno-multiple-inheritance"}, {"sha": "3020a95efdf52a0aa51c13a00825db79a2043bdc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e8f1ade269a39ea86a76a2440818e1512ed480ee", "patch": "@@ -1,3 +1,11 @@\n+2019-12-17  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/61339\n+\t* g++.dg/warn/Wmismatched-tags.C: New test.\n+\t* g++.dg/warn/Wredundant-tags.C: New test.\n+\t* g++.dg/pch/Wmismatched-tags.C: New test.\n+\t* g++.dg/pch/Wmismatched-tags.Hs: New test header.\n+\n 2019-12-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/59655"}, {"sha": "89b6ba556889766fc4d571bb33b594f2fc3c8cc7", "filename": "gcc/testsuite/g++.dg/pch/Wmismatched-tags.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2FWmismatched-tags.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2FWmismatched-tags.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2FWmismatched-tags.C?ref=e8f1ade269a39ea86a76a2440818e1512ed480ee", "patch": "@@ -0,0 +1,15 @@\n+/*  PR c++/61339 - add mismatch between struct and class\n+    Verify that declarations that don't match definitions in precompiled\n+    headers are diagnosed.\n+    { dg-options \"-Wall -Wmismatched-tags\" } */\n+\n+#include \"Wmismatched-tags.H\"\n+\n+class PCHDeclaredClass;\n+struct PCHDeclaredStruct;\n+\n+struct PCHDefinedClass;       // { dg-warning \"declared with a mismatched class-key 'struct'\" }\n+class PCHDefinedStruct;       // { dg-warning \"declared with a mismatched class-key 'class'\" }\n+\n+class PCHDeclaredClass { };\n+struct PCHDeclaredStruct { };"}, {"sha": "f4c5dc557e9d979c7c3d5eced7062686986f97d4", "filename": "gcc/testsuite/g++.dg/pch/Wmismatched-tags.Hs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2FWmismatched-tags.Hs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2FWmismatched-tags.Hs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2FWmismatched-tags.Hs?ref=e8f1ade269a39ea86a76a2440818e1512ed480ee", "patch": "@@ -0,0 +1,7 @@\n+class PCHDeclaredClass;\n+\n+struct PCHDeclaredStruct;\n+\n+class PCHDefinedClass { };\n+\n+struct PCHDefinedStruct { };\n\\ No newline at end of file"}, {"sha": "36a7903234adf883274ac1ef565ecfa743969382", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-tags.C", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags.C?ref=e8f1ade269a39ea86a76a2440818e1512ed480ee", "patch": "@@ -0,0 +1,278 @@\n+/* PR c++/61339 - add mismatch between struct and class\n+   Test to verify that -Wmismatched-tags is issued for declarations\n+   of the same class using different class-ids.\n+   { dg-do compile }\n+   { dg-options \"-Wmismatched-tags\" } */\n+\n+namespace Classes\n+{\n+class A;\n+class A;\n+\n+struct B;\n+struct B;\n+\n+union C;\n+union C;\n+\n+struct D;                   // { dg-warning \"Classes::D' declared with a mismatched class-key 'struct'\" }\n+class D { };                // { dg-message \"Classes::D' defined as 'class' here\" }\n+\n+class E;                    // { dg-warning \"Classes::E' declared with a mismatched class-key 'class'\" }\n+struct E { };               // { dg-message \"Classes::E' defined as 'struct' here\" }\n+\n+class D;\n+struct E;\n+\n+class D;\n+struct E;\n+\n+struct D;                   // { dg-warning \"Classes::D' declared with a mismatched class-key\" }\n+\n+class E;                    // { dg-warning \"Classes::E' declared with a mismatched class-key\" }\n+\n+class F;                    // { dg-message \"Classes::F' first declared as 'class' here\" }\n+class F;\n+\n+struct G { };               // { dg-message \"Classes::G' defined as 'struct' here\" }\n+}   // namespace Classes\n+\n+\n+namespace Classes\n+{\n+class A;\n+struct B;\n+union C;\n+class D;\n+struct E;\n+\n+struct F;                   // { dg-warning \"Classes::F' declared with a mismatched class-key\" }\n+\n+struct G;\n+}\n+\n+// Verify that the correct hint is provided, one to remove the class-key\n+// when it's redundant, and one to (only) replace it with the correct one\n+// when it's needed to disambiguate the reference to the class type.\n+namespace RemoveOrReplace\n+{\n+struct Func;\n+class Func;                 // { dg-warning \"RemoveOrReplace::Func' declared with a mismatched class-key 'class'\" }\n+                            // { dg-message \"replace the class-key with 'struct'\" \"hint to remove\" { target *-*-* } .-1 }\n+\n+void Func ();\n+\n+class Func;                 // { dg-warning \"RemoveOrReplace::Func' declared with a mismatched class-key 'class'\" }\n+                            // { dg-message \"replace the class-key with 'struct'\" \"hint to replace\" { target *-*-* } .-1 }\n+\n+class Var;\n+struct Var;                  // { dg-warning \"RemoveOrReplace::Var' declared with a mismatched class-key 'struct'\" }\n+                            // { dg-message \"replace the class-key with 'class'\" \"hint to remove\" { target *-*-* } .-1 }\n+void f (struct Var*);       // { dg-warning \"RemoveOrReplace::Var' declared with a mismatched class-key 'struct'\" }\n+                            // { dg-message \"remove the class-key or replace it with 'class'\" \"hint to remove\" { target *-*-* } .-1 }\n+\n+int Var;\n+\n+struct Var;                  // { dg-warning \"RemoveOrReplace::Var' declared with a mismatched class-key 'struct'\" }\n+                            // { dg-message \"replace the class-key with 'class'\" \"hint to replace\" { target *-*-* } .-1 }\n+}\n+\n+namespace GlobalObjects\n+{\n+class A;                    // { dg-message \"'GlobalObjects::A' first declared as 'class' here\" }\n+struct B;                   // { dg-message \"'GlobalObjects::B' first declared as 'struct' here\" }\n+class C { };                // { dg-message \"'GlobalObjects::C' defined as 'class' here\" }\n+\n+extern A a0;\n+extern class A a1;\n+extern class A a2;\n+\n+extern B b0;\n+extern struct B b1;\n+extern struct B b2;\n+\n+extern struct A a3;         // { dg-warning \"GlobalObjects::A' declared with a mismatched class-key\" }\n+extern class A a4;\n+\n+extern class B b3;          // { dg-warning \"GlobalObjects::B' declared with a mismatched class-key\" }\n+extern struct B b4;\n+\n+extern struct C c[];        // { dg-warning \"GlobalObjects::C' declared with a mismatched class-key\" }\n+                            // { dg-message \"remove the class-key or replace it with 'class'\" \"hint to remove\" { target *-*-* } .-1 }\n+\n+extern char\n+arr[sizeof (struct C)];     // { dg-warning \"GlobalObjects::C' declared with a mismatched class-key\" }\n+                            // { dg-message \"remove the class-key or replace it with 'class'\" \"hint to remove\" { target *-*-* } .-1 }\n+}   // namespace GlobalObjects\n+\n+\n+namespace LocalObjects\n+{\n+class A;                    // { dg-message \"LocalObjects::A' first declared as 'class' here\" }\n+struct B;                   // { dg-message \"LocalObjects::B' first declared as 'struct' here\" }\n+\n+void f (A*, B&)\n+{\n+  class A *a1;\n+  class A *a2;\n+\n+  struct B *b1;\n+  struct B *b2;\n+\n+  struct A *a3;             // { dg-warning \"LocalObjects::A' declared with a mismatched class-key\" }\n+  class A *a4;\n+\n+  class B *b3;              // { dg-warning \"LocalObjects::B' declared with a mismatched class-key\" }\n+  struct B *b4;\n+}\n+\n+void g (struct A*);         // { dg-warning \"LocalObjects::A' declared with a mismatched class-key\" }\n+\n+}   // namespace LocalObjects\n+\n+\n+namespace MemberClasses\n+{\n+struct A { struct B; };\n+struct C { struct D; struct D; struct D { }; };\n+struct E { class F; class F { }; class F; };\n+\n+struct G {\n+  struct H;                 // { dg-message \"MemberClasses::G::H' first declared as 'struct' here\" }\n+  class H;                  // { dg-warning \"MemberClasses::G::H' declared with a mismatched class-key\" }\n+  class I { };              // { dg-message \"MemberClasses::G::I' defined as 'class' here\" }\n+  struct I;                 // { dg-warning \"MemberClasses::G::I' declared with a mismatched class-key\" }\n+};\n+}   // namespace MemberClasses\n+\n+\n+namespace DataMembers\n+{\n+struct A { struct B *p; };\n+struct C { struct D *p; struct D *q; struct D { } d; };\n+struct E { class F &r; class F { } f; class F *p; };\n+\n+class G;                    // { dg-message \"DataMembers::G' first declared as 'class' here\" }\n+struct H;                   // { dg-message \"DataMembers::H' first declared as 'struct' here\" }\n+\n+struct I {\n+  struct G *p0;             // { dg-warning \"DataMembers::G' declared with a mismatched class-key\" }\n+  class G *p1;\n+\n+  struct H &r0;\n+  class H &r1;              // { dg-warning \"DataMembers::H' declared with a mismatched class-key\" }\n+\n+  class J { };              // { dg-message \"DataMembers::I::J' defined as 'class' here\" }\n+  struct K { };             // { dg-message \"DataMembers::I::K' defined as 'struct' here\" }\n+\n+  class J j0;\n+  class K k0;               // { dg-warning \"DataMembers::I::K' declared with a mismatched class-key\" }\n+\n+  struct J j1;              // { dg-warning \"DataMembers::I::J' declared with a mismatched class-key\" }\n+  struct K k1;\n+};\n+}   // namespace DataMembers\n+\n+\n+namespace Templates\n+{\n+template <int> class A;\n+template <int> class A;\n+\n+template <int> struct B;\n+template <int> struct B;\n+\n+template <int> union C;\n+template <int> union C;\n+\n+template <int> struct D;    // { dg-warning \"Templates::D\\[^\\n\\r]*' declared with a mismatched class-key\" }\n+template <int>\n+class D                     // { dg-message \"Templates::D\\[^\\n\\r]*' defined as 'class' here\" }\n+{ public: D (); };\n+\n+template <int> class E;     // { dg-warning \"Templates::E\\[^\\n\\r]*' declared with a mismatched class-key\" }\n+template <int>\n+struct E                    // { dg-message \"Templates::E\\[^\\n\\r]*' defined as 'struct' here\" }\n+{ int i; };\n+\n+template <int> class D;\n+template <int> struct E;\n+\n+template <int>\n+struct D;                   // { dg-warning \"Templates::D\\[^\\n\\r]*' declared with a mismatched class-key\" }\n+                            // { dg-message \"replace the class-key with 'class'\" \"hint\" { target *-*-* } .-1 }\n+}   // namespace Templates\n+\n+\n+namespace ExplicitSpecializations\n+{\n+template <int> class A;\n+template <> class A<0>;\n+template <> struct A<1>;\n+template <> struct A<1> { };\n+\n+template <int> struct B;\n+template <> struct B<0>;\n+template <> class B<1>;\n+template <> class B<2> { public: B (); };\n+\n+template <int> union C;\n+template <> union C<0>;\n+\n+template <int> class D;\n+template <> class D<0>;     // { dg-warning \"ExplicitSpecializations::D\\[^\\n\\r]*' declared with a mismatched class-key \" }\n+template <>\n+struct D<0> { };            // { dg-message \"ExplicitSpecializations::D\\[^\\n\\r]*' defined as 'struct' here\" }\n+\n+template <int> struct E;\n+template <> struct E<0>;    // { dg-warning \"ExplicitSpecializations::E\\[^\\n\\r]*' declared with a mismatched class-key\" }\n+template <>\n+class E<0> { };             // { dg-message \"ExplicitSpecializations::E\\[^\\n\\r]*' defined as 'class' here\" }\n+\n+template <int> struct F;\n+template <> class F<0> { }; // { dg-message \"ExplicitSpecializations::F\\[^\\n\\r]*' defined as 'class' here\" }\n+\n+template <>\n+struct F<0>;                // { dg-warning \"ExplicitSpecializations::F\\[^\\n\\r]*' declared with a mismatched class-key\" }\n+}   // namespace ExplicitSpecializations\n+\n+\n+namespace PartialSpecializations\n+{\n+template <class> class A;\n+template <class T> struct A<const T>;\n+template <class T> struct A<volatile T>;\n+\n+template <class> struct B;\n+template <class T> class B<const T>;\n+template <class T> class B<volatile T>;\n+\n+template <class> class C { };\n+template <class T> struct C<const T> { };\n+template <class T> struct C<volatile T> { };\n+\n+template <class> struct D { };\n+template <class T> class D<const T> { };\n+template <class T> class D<volatile T> { };\n+\n+template <class> class E;\n+template <class T>\n+struct E<const T>;          // { dg-message \"PartialSpecializations::E<const T>' first declared as 'struct' here\" }\n+\n+template <class T>\n+class E<const T>;           // { dg-warning \"PartialSpecializations::E<const T>' declared with a mismatched class-key\" }\n+\n+template <class> class F;\n+template <class T>\n+class F<const T>;           // { dg-message \"PartialSpecializations::F<const T>' first declared as 'class' here\" }\n+template <class T>\n+struct F<const T>;          // { dg-warning \"PartialSpecializations::F<const T>' declared with a mismatched class-key\" }\n+}   // namespace PartialSpecializations\n+\n+\n+namespace Classes\n+{\n+struct G;\n+\n+class G;                    // { dg-warning \"Classes::G' declared with a mismatched class-key 'class'\" }\n+}"}, {"sha": "ac5afa912a1b5424a3ba1ea5cdf83ea04cb60c4f", "filename": "gcc/testsuite/g++.dg/warn/Wredundant-tags.C", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWredundant-tags.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f1ade269a39ea86a76a2440818e1512ed480ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWredundant-tags.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWredundant-tags.C?ref=e8f1ade269a39ea86a76a2440818e1512ed480ee", "patch": "@@ -0,0 +1,128 @@\n+/* PR c++/61339 - add mismatch between struct and class\n+   Test to verify that -Wredundant-tags is issued for references to class\n+   types that use the class-key even though they don't need to.\n+   { dg-do compile }\n+   { dg-options \"-Wredundant-tags\" } */\n+\n+struct A;\n+\n+extern A *pa;\n+extern struct A *pa;        // { dg-warning \"redundant class-key 'struct' in reference to 'struct A'\" }\n+\n+extern A aa[];\n+extern struct A aa[];       // { dg-warning \"redundant class-key 'struct' in reference to 'struct A'\" }\n+\n+void func (A*);\n+void func (struct A*);      // { dg-warning \"redundant class-key 'struct' in reference to 'struct A'\" }\n+\n+int A;\n+\n+extern struct A *pa;\n+extern struct A aa[];\n+void func (struct A*);\n+\n+\n+class B;\n+\n+extern B *pb;\n+extern class B *pb;         // { dg-warning \"redundant class-key 'class' in reference to 'class B'\" }\n+\n+extern B ab[];\n+extern class B ab[];        // { dg-warning \"redundant class-key 'class' in reference to 'class B'\" }\n+\n+void func (B*);\n+void func (class B*);       // { dg-warning \"redundant class-key 'class' in reference to 'class B'\" }\n+\n+int B;\n+\n+extern class B *pb;\n+extern class B ab[];\n+void func (class B*);\n+\n+\n+enum C { c0 };\n+\n+extern C *pc;\n+extern enum C *pc;          // { dg-warning \"redundant enum-key 'enum' in reference to 'enum C'\" }\n+\n+extern C ac[];\n+extern enum C ac[];         // { dg-warning \"redundant enum-key 'enum' in reference to 'enum C'\" }\n+\n+void func (C*);\n+void func (enum C*);        // { dg-warning \"redundant enum-key 'enum' in reference to 'enum C'\" }\n+\n+int C;\n+\n+extern enum C *pc;\n+extern enum C ac[];\n+void func (enum C*);\n+\n+\n+#if __cplusplus > 199711L\n+\n+enum class D1 { d1 };\n+enum struct D2 { d2 };\n+\n+#else\n+\n+enum D1 { d1 };\n+enum D2 { d2 };\n+\n+#endif\n+\n+extern D1 *pd1;\n+extern D2 *pd2;\n+extern enum D1 *pd1;        // { dg-warning \"redundant enum-key 'enum' in reference to 'enum class D1'\" \"C++ 11 and above\" { target c++11 } }\n+                            // { dg-warning \"redundant enum-key 'enum' in reference to 'enum D1'\" \"C++ 98\" { target c++98_only } .-1 }\n+\n+extern enum D2 *pd2;        // { dg-warning \"redundant enum-key 'enum' in reference to 'enum class D2'\" \"C++ 11 and above\" { target c++11 } }\n+                            // { dg-warning \"redundant enum-key 'enum' in reference to 'enum D2'\" \"C++ 98\" { target c++98_only } .-1 }\n+\n+extern D1 ad1[];\n+extern D2 ad2[];\n+\n+#if __cplusplus > 199711L\n+extern enum class D1 ad1[]; // { dg-warning \"redundant enum-key 'enum class' in reference to 'enum class D1'\" \"C++ 11 and above\" { target c++11 } }\n+                            // { dg-warning \"elaborated-type-specifier for a scoped enum must not use the 'class' keyword\" \"C++ 11 and above\" { target c++11 } .-1 }\n+/* The pretty printer cannot differentiate between enum class and enum struct\n+   because the C++ front-end doesn't encode it so allow for both in the text\n+   of the warning below.  */\n+extern enum struct D2 ad2[]; // { dg-warning \"redundant enum-key 'enum struct' in reference to 'enum \\(class|struct\\) D2'\" \"C++ 11 and above\" { target c++11 } }\n+                            // { dg-warning \"elaborated-type-specifier for a scoped enum must not use the 'struct' keyword\" \"C++ 11 and above\" { target c++11 } .-1 }\n+#else\n+extern enum D1 ad1[];       // { dg-warning \"redundant enum-key 'enum' in reference to 'enum D1'\" \"C++ 98\" { target c++98_only } }\n+#endif\n+\n+void func (D1*);\n+void func (enum D1*);       // { dg-warning \"redundant enum-key 'enum' in reference to 'enum \" }\n+\n+void func (D2*);\n+void func (enum D2*);       // { dg-warning \"redundant enum-key 'enum' in reference to 'enum \" }\n+\n+int D1, D2;\n+\n+extern enum D1 *pd1;\n+extern enum D1 ad1[];\n+void func (enum D1*);\n+\n+extern enum D2 *pd2;\n+extern enum D2 ad2[];\n+void func (enum D2*);\n+\n+\n+union U;\n+\n+extern U *pu;\n+extern union U *pu;         // { dg-warning \"redundant class-key 'union' in reference to 'union U'\" }\n+\n+extern U au[];\n+extern union U au[];        // { dg-warning \"redundant class-key 'union' in reference to 'union U'\" }\n+\n+void func (U*);\n+void func (union U*);       // { dg-warning \"redundant class-key 'union' in reference to 'union U'\" }\n+\n+int U;\n+\n+extern union U *pu;\n+extern union U au[];\n+void func (union U*);"}]}