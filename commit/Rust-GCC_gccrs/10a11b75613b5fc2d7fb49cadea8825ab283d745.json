{"sha": "10a11b75613b5fc2d7fb49cadea8825ab283d745", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBhMTFiNzU2MTNiNWZjMmQ3ZmI0OWNhZGVhODgyNWFiMjgzZDc0NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "1999-11-25T02:36:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-11-25T02:36:40Z"}, "message": "dwarf2out.c (free_AT, free_die): New fns.\n\n        * dwarf2out.c (free_AT, free_die): New fns.\n        (remove_children): Call them.\n        (output_line_info): Disable removal of duplicate notes.\n\n        Generate minimal debug info for types with TYPE_DECL_SUPPRESS_INFO set.\n        * dwarf2out.c (gen_struct_or_union_type_die): TYPE_DECL_SUPPRESS_INFO\n        means pretend the type isn't defined.\n        Don't defer emitting types.\n        (gen_type_die_for_member): New fn.\n        (gen_decl_die): Call it.\n        (splice_child_die): New fn.\n        (gen_member_die): Call it rather than generate duplicate dies.\n\n        Defer emitting information for the abstract instance of an inline\n        until we either inline it or emit an out-of-line copy.\n        * dwarf2out.c (decl_ultimate_origin): Ignore DECL_ABSTRACT_ORIGIN\n        from output_inline_function if DECL_ABSTRACT is also set.\n        (block_ultimate_origin): Likewise.\n        (gen_abstract_function): New fn.\n        (gen_decl_die, gen_inlined_subroutine_die): Call it.\n        (gen_subprogram_die):  An abstract instance is not a declaration\n        just because it doesn't match current_function_decl.  Don't abort\n        because DECL_DEFER_OUTPUT isn't set.  Do abort if a declaration\n        has an abstract origin.\n        * toplev.c (rest_of_compilation): Don't emit dwarf2 info for the\n        abstract instance here.\n\nFrom-SVN: r30659", "tree": {"sha": "b8d824a990ecfa26f4e85b6a58fd25bf6211beab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8d824a990ecfa26f4e85b6a58fd25bf6211beab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10a11b75613b5fc2d7fb49cadea8825ab283d745", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a11b75613b5fc2d7fb49cadea8825ab283d745", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10a11b75613b5fc2d7fb49cadea8825ab283d745", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a11b75613b5fc2d7fb49cadea8825ab283d745/comments", "author": null, "committer": null, "parents": [{"sha": "50e159f65532eb334dc2b12210acdc9ab0f334cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e159f65532eb334dc2b12210acdc9ab0f334cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e159f65532eb334dc2b12210acdc9ab0f334cf"}], "stats": {"total": 274, "additions": 224, "deletions": 50}, "files": [{"sha": "c560118de56fad29513d53979812d455ba03c603", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a11b75613b5fc2d7fb49cadea8825ab283d745/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a11b75613b5fc2d7fb49cadea8825ab283d745/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10a11b75613b5fc2d7fb49cadea8825ab283d745", "patch": "@@ -1,3 +1,32 @@\n+1999-11-24  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* dwarf2out.c (free_AT, free_die): New fns.\n+\t(remove_children): Call them.\n+\t(output_line_info): Disable removal of duplicate notes.\n+\n+\tGenerate minimal debug info for types with TYPE_DECL_SUPPRESS_INFO set.\n+\t* dwarf2out.c (gen_struct_or_union_type_die): TYPE_DECL_SUPPRESS_INFO\n+\tmeans pretend the type isn't defined.\n+\tDon't defer emitting types.\n+\t(gen_type_die_for_member): New fn.\n+\t(gen_decl_die): Call it.\n+\t(splice_child_die): New fn.\n+\t(gen_member_die): Call it rather than generate duplicate dies.\n+\n+\tDefer emitting information for the abstract instance of an inline\n+\tuntil we either inline it or emit an out-of-line copy.\n+\t* dwarf2out.c (decl_ultimate_origin): Ignore DECL_ABSTRACT_ORIGIN\n+\tfrom output_inline_function if DECL_ABSTRACT is also set.\n+\t(block_ultimate_origin): Likewise.\n+\t(gen_abstract_function): New fn.\n+\t(gen_decl_die, gen_inlined_subroutine_die): Call it.\n+\t(gen_subprogram_die):  An abstract instance is not a declaration\n+\tjust because it doesn't match current_function_decl.  Don't abort\n+\tbecause DECL_DEFER_OUTPUT isn't set.  Do abort if a declaration\n+\thas an abstract origin.\n+\t* toplev.c (rest_of_compilation): Don't emit dwarf2 info for the\n+\tabstract instance here.\n+\n Wed Nov 24 18:39:18 1999  Andrew Haley  <aph@cygnus.com>\n \n \t* config/sh/sh.h (SECONDARY_OUTPUT_RELOAD_CLASS): Add the case"}, {"sha": "6657fd5c1ca98dd6bd9dde1777cb935866b302ef", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 195, "deletions": 39, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a11b75613b5fc2d7fb49cadea8825ab283d745/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a11b75613b5fc2d7fb49cadea8825ab283d745/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=10a11b75613b5fc2d7fb49cadea8825ab283d745", "patch": "@@ -2543,6 +2543,8 @@ static void gen_decl_die\t\tPROTO((tree, dw_die_ref));\n static unsigned lookup_filename\t\tPROTO((const char *));\n static void add_incomplete_type\t\tPROTO((tree));\n static void retry_incomplete_types\tPROTO((void));\n+static void gen_type_die_for_member\tPROTO((tree, tree, dw_die_ref));\n+static void gen_abstract_function\tPROTO((tree));\n \n /* Section names used to hold DWARF debugging information.  */\n #ifndef DEBUG_INFO_SECTION\n@@ -3542,6 +3544,12 @@ static tree\n decl_ultimate_origin (decl)\n      register tree decl;\n {\n+  /* output_inline_function sets DECL_ABSTRACT_ORIGIN for all the\n+     nodes in the function to point to themselves; ignore that if\n+     we're trying to output the abstract instance of this function.  */\n+  if (DECL_ABSTRACT (decl) && DECL_ABSTRACT_ORIGIN (decl) == decl)\n+    return NULL_TREE;\n+\n #ifdef ENABLE_CHECKING \n   if (DECL_FROM_INLINE (DECL_ORIGIN (decl)))\n     /* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the\n@@ -3564,6 +3572,12 @@ block_ultimate_origin (block)\n {\n   register tree immediate_origin = BLOCK_ABSTRACT_ORIGIN (block);\n \n+  /* output_inline_function sets BLOCK_ABSTRACT_ORIGIN for all the\n+     nodes in the function to point to themselves; ignore that if\n+     we're trying to output the abstract instance of this function.  */\n+  if (BLOCK_ABSTRACT (block) && immediate_origin == block)\n+    return NULL_TREE;\n+\n   if (immediate_origin == NULL_TREE)\n     return NULL_TREE;\n   else\n@@ -4035,9 +4049,31 @@ is_fortran ()\n   return (lang == DW_LANG_Fortran77 || lang == DW_LANG_Fortran90);\n } \n \n-/* Remove the specified attribute if present.  */\n+/* Free up the memory used by A.  */\n \n static inline void\n+free_AT (a)\n+     dw_attr_ref a;\n+{\n+  switch (AT_class (a))\n+    {\n+    case dw_val_class_addr:\n+    case dw_val_class_str:\n+    case dw_val_class_lbl_id:\n+    case dw_val_class_lbl_offset:\n+      free (a->dw_attr_val.v.val_str);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  free (a);\n+}  \n+\n+/* Remove the specified attribute if present.  */\n+\n+static void\n remove_AT (die, attr_kind)\n      register dw_die_ref die;\n      register enum dwarf_attribute attr_kind;\n@@ -4056,28 +4092,23 @@ remove_AT (die, attr_kind)\n \t  }\n \n       if (removed != 0)\n-\t{\n-\t  switch (AT_class (removed))\n-\t    {\n-\t    case dw_val_class_addr:\n-\t    case dw_val_class_str:\n-\t    case dw_val_class_lbl_id:\n-\t    case dw_val_class_lbl_offset:\n-\t      free (removed->dw_attr_val.v.val_str);\n-\t      break;\n+\tfree_AT (removed);\n+    }\n+}\n \n-\t    default:\n-\t      break;\n-\t    }\n+/* Free up the memory used by DIE.  */\n \n-\t  free (removed);\n-\t}\n-    }\n+static inline void\n+free_die (die)\n+     dw_die_ref die;\n+{\n+  remove_children (die);\n+  free (die);\n }\n \n /* Discard the children of this DIE.  */\n \n-static inline void\n+static void\n remove_children (die)\n      register dw_die_ref die;\n {\n@@ -4097,10 +4128,10 @@ remove_children (die)\n \t  register dw_attr_ref tmp_a = a;\n \n \t  a = a->dw_attr_next;\n-\t  free (tmp_a);\n+\t  free_AT (tmp_a);\n \t}\n \n-      free (tmp_die);\n+      free_die (tmp_die);\n     }\n }\n \n@@ -4122,6 +4153,34 @@ add_child_die (die, child_die)\n     }\n }\n \n+/* Move CHILD, which must be a child of PARENT, to the front of\n+   PARENT's list of children.  */\n+\n+static void\n+splice_child_die (parent, child)\n+     dw_die_ref parent, child;\n+{\n+  dw_die_ref *p;\n+\n+  /* We want the declaration DIE from inside the class, not the\n+     specification DIE at toplevel.  */\n+  if (child->die_parent != parent)\n+    child = get_AT_ref (child, DW_AT_specification);\n+\n+  if (parent == NULL || child == NULL || child->die_parent != parent)\n+    abort ();\n+\n+  for (p = &(parent->die_child); *p; p = &((*p)->die_sib))\n+    if (*p == child)\n+      {\n+\t*p = child->die_sib;\n+\tbreak;\n+      }\n+\n+  child->die_sib = parent->die_child;\n+  parent->die_child = child;\n+}\n+\n /* Return a pointer to a newly created DIE node.  */\n \n static inline dw_die_ref\n@@ -4165,7 +4224,7 @@ lookup_type_die (type)\n \n /* Equate a DIE to a given type specifier.  */\n \n-static void\n+static inline void\n equate_type_number_to_die (type, type_die)\n      register tree type;\n      register dw_die_ref type_die;\n@@ -5666,12 +5725,18 @@ output_line_info ()\n     {\n       register dw_line_info_ref line_info = &line_info_table[lt_index];\n \n+#if 0\n+      /* Disable this optimization for now; GDB wants to see two line notes\n+\t at the beginning of a function so it can find the end of the\n+\t prologue.  */\n+\n       /* Don't emit anything for redundant notes.  Just updating the\n          address doesn't accomplish anything, because we already assume\n          that anything after the last address is this line.  */\n       if (line_info->dw_line_num == current_line\n \t  && line_info->dw_file_num == current_file)\n \tcontinue;\n+#endif\n \n       /* Emit debug info for the address of the current line, choosing\n \t the encoding that uses the least amount of space.  */\n@@ -5824,11 +5889,13 @@ output_line_info ()\n       register dw_separate_line_info_ref line_info\n \t= &separate_line_info_table[lt_index];\n \n+#if 0\n       /* Don't emit anything for redundant notes.  */\n       if (line_info->dw_line_num == current_line\n \t  && line_info->dw_file_num == current_file\n \t  && line_info->function == function)\n \tgoto cont;\n+#endif\n \n       /* Emit debug info for the address of the current line.  If this is\n \t a new function, or the first line of a function, then we need\n@@ -5944,7 +6011,9 @@ output_line_info ()\n \t  fputc ('\\n', asm_out_file);\n \t}\n \n+#if 0\n     cont:\n+#endif\n       ++lt_index;\n \n       /* If we're done with a function, end its sequence.  */\n@@ -8192,6 +8261,55 @@ gen_formal_types_die (function_or_method_type, context_die)\n     }\n }\n \n+/* We want to generate the DIE for TYPE so that we can generate the\n+   die for MEMBER, which has been defined; we will need to refer back\n+   to the member declaration nested within TYPE.  If we're trying to\n+   generate minimal debug info for TYPE, processing TYPE won't do the\n+   trick; we need to attach the member declaration by hand.  */\n+\n+static void\n+gen_type_die_for_member (type, member, context_die)\n+     tree type, member;\n+     dw_die_ref context_die;\n+{\n+  gen_type_die (type, context_die);\n+\n+  /* If we're trying to avoid duplicate debug info, we may not have\n+     emitted the member decl for this function.  Emit it now.  */\n+  if (TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (type))\n+      && ! lookup_decl_die (member))\n+    {\n+      if (decl_ultimate_origin (member))\n+\tabort ();\n+\n+      push_decl_scope (type);\n+      if (TREE_CODE (member) == FUNCTION_DECL)\n+\tgen_subprogram_die (member, lookup_type_die (type));\n+      else\n+\tgen_variable_die (member, lookup_type_die (type));\n+      pop_decl_scope ();\n+    }\n+}\n+\n+/* Generate the DWARF2 info for the \"abstract\" instance\n+   of a function which we may later generate inlined and/or\n+   out-of-line instances of.  */\n+\n+static void\n+gen_abstract_function (decl)\n+     tree decl;\n+{\n+  register dw_die_ref old_die = lookup_decl_die (decl);\n+\n+  if (old_die && get_AT_unsigned (old_die, DW_AT_inline))\n+    /* We've already generated the abstract instance.  */\n+    return;\n+\n+  set_decl_abstract_flags (decl, 1);\n+  dwarf2out_decl (decl);\n+  set_decl_abstract_flags (decl, 0);\n+}\n+\n /* Generate a DIE to represent a declared function (either file-scope or\n    block-local).  */\n \n@@ -8208,13 +8326,23 @@ gen_subprogram_die (decl, context_die)\n   register tree outer_scope;\n   register dw_die_ref old_die = lookup_decl_die (decl);\n   register int declaration\n-    = (current_function_decl != decl\n+    = ((current_function_decl != decl && ! DECL_ABSTRACT (decl))\n        || (context_die\n \t   && (context_die->die_tag == DW_TAG_structure_type\n \t       || context_die->die_tag == DW_TAG_union_type)));\n \n+  /* Note that it is possible to have both DECL_ABSTRACT and `declaration'\n+     be true, if we started to generate the abstract instance of an inline,\n+     decided to output its containing class, and proceeded to emit the\n+     declaration of the inline from the member list for the class.  In that\n+     case, `declaration' takes priority; we'll get back to the abstract\n+     instance when we're done with the class.  */\n+\n   if (origin != NULL)\n     {\n+      if (declaration)\n+\tabort ();\n+\n       subr_die = new_die (DW_TAG_subprogram, context_die);\n       add_abstract_origin_attribute (subr_die, origin);\n     }\n@@ -8324,22 +8452,20 @@ gen_subprogram_die (decl, context_die)\n     }\n   else if (DECL_ABSTRACT (decl))\n     {\n-      /* ??? Checking DECL_DEFER_OUTPUT is correct for static inline functions,\n-\t but not for extern inline functions.  We can't get this completely\n-\t correct because information about whether the function was declared\n-\t inline is not saved anywhere.  */\n-      if (DECL_DEFER_OUTPUT (decl))\n+      if (DECL_INLINE (decl) && !flag_no_inline)\n \t{\n-\t  if (DECL_INLINE (decl) && !flag_no_inline)\n+\t  /* ??? Checking DECL_DEFER_OUTPUT is correct for static\n+\t     inline functions, but not for extern inline functions.\n+\t     We can't get this completely correct because information\n+\t     about whether the function was declared inline is not\n+\t     saved anywhere.  */\n+\t  if (DECL_DEFER_OUTPUT (decl))\n \t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_declared_inlined);\n \t  else\n-\t    add_AT_unsigned (subr_die, DW_AT_inline,\n-\t\t\t     DW_INL_declared_not_inlined);\n+\t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_inlined);\n \t}\n-      else if (DECL_INLINE (decl) && !flag_no_inline)\n-\tadd_AT_unsigned (subr_die, DW_AT_inline, DW_INL_inlined);\n       else\n-\tabort ();\n+\tadd_AT_unsigned (subr_die, DW_AT_inline, DW_INL_declared_not_inlined);\n \n       equate_decl_number_to_die (decl, subr_die);\n     }\n@@ -8637,6 +8763,9 @@ gen_inlined_subroutine_die (stmt, context_die, depth)\n       register tree decl = block_ultimate_origin (stmt);\n       char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n+      /* Emit info for the abstract instance first, if we haven't yet.  */\n+      gen_abstract_function (decl);\n+\n       add_abstract_origin_attribute (subr_die, decl);\n       ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,\n \t\t\t\t   next_block_number);\n@@ -8833,6 +8962,7 @@ gen_member_die (type, context_die)\n      register dw_die_ref context_die;\n {\n   register tree member;\n+  dw_die_ref child;\n \n   /* If this is not an incomplete type, output descriptions of each of its\n      members. Note that as we output the DIEs necessary to represent the\n@@ -8860,14 +8990,33 @@ gen_member_die (type, context_die)\n \n   /* Now output info about the data members and type members.  */\n   for (member = TYPE_FIELDS (type); member; member = TREE_CHAIN (member))\n-    gen_decl_die (member, context_die);\n+    {\n+      /* If we thought we were generating minimal debug info for TYPE\n+\t and then changed our minds, some of the member declarations\n+\t may have already been defined.  Don't define them again, but\n+\t do put them in the right order.  */\n+\n+      child = lookup_decl_die (member);\n+      if (child)\n+\tsplice_child_die (context_die, child);\n+      else\n+\tgen_decl_die (member, context_die);\n+    }\n \n   /* Now output info about the function members (if any).  */\n   for (member = TYPE_METHODS (type); member; member = TREE_CHAIN (member))\n-    gen_decl_die (member, context_die);\n+    {\n+      child = lookup_decl_die (member);\n+      if (child)\n+\tsplice_child_die (context_die, child);\n+      else\n+\tgen_decl_die (member, context_die);\n+    }\n }\n \n-/* Generate a DIE for a structure or union type.  */\n+/* Generate a DIE for a structure or union type.  If TYPE_DECL_SUPPRESS_DEBUG\n+   is set, we pretend that the type was never defined, so we only get the\n+   member DIEs needed by later specification DIEs.  */\n \n static void\n gen_struct_or_union_type_die (type, context_die)\n@@ -8877,8 +9026,10 @@ gen_struct_or_union_type_die (type, context_die)\n   register dw_die_ref type_die = lookup_type_die (type);\n   register dw_die_ref scope_die = 0;\n   register int nested = 0;\n+  int complete = (TYPE_SIZE (type)\n+\t\t  && ! TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (type)));\n \n-  if (type_die && ! TYPE_SIZE (type))\n+  if (type_die && ! complete)\n     return;\n \n   if (TYPE_CONTEXT (type) != NULL_TREE\n@@ -8912,7 +9063,7 @@ gen_struct_or_union_type_die (type, context_die)\n     }\n   /* If this type has been completed, then give it a byte_size attribute and\n      then give a list of members.  */\n-  else if (TYPE_SIZE (type))\n+  else if (complete)\n     {\n       /* Prevent infinite recursion in cases where the type of some member of \n          this type is expressed in terms of this type itself.  */\n@@ -9386,6 +9537,11 @@ gen_decl_die (decl, context_die)\n \t  && (current_function_decl == NULL_TREE || ! DECL_ARTIFICIAL (decl)))\n \tbreak;\n \n+      /* Emit info for the abstract instance first, if we haven't yet.  */\n+      origin = decl_ultimate_origin (decl);\n+      if (origin)\n+\tgen_abstract_function (origin);\n+\n       if (debug_info_level > DINFO_LEVEL_TERSE)\n \t{\n \t  /* Before we describe the FUNCTION_DECL itself, make sure that we\n@@ -9395,7 +9551,7 @@ gen_decl_die (decl, context_die)\n \t  /* And its containing type.  */\n \t  origin = decl_class_context (decl);\n \t  if (origin != NULL_TREE)\n-\t    gen_type_die (origin, context_die);\n+\t    gen_type_die_for_member (origin, decl, context_die);\n \n \t  /* And its virtual context.  */\n \t  if (DECL_VINDEX (decl) != NULL_TREE)\n@@ -9450,7 +9606,7 @@ gen_decl_die (decl, context_die)\n       /* And its containing type.  */\n       origin = decl_class_context (decl);\n       if (origin != NULL_TREE)\n-\tgen_type_die (origin, context_die);\n+\tgen_type_die_for_member (origin, decl, context_die);\n \n       /* Now output the DIE to represent the data object itself.  This gets\n          complicated because of the possibility that the VAR_DECL really"}, {"sha": "dbe5dceb9dc6ea46c049574871c23e7cd1a46938", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a11b75613b5fc2d7fb49cadea8825ab283d745/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a11b75613b5fc2d7fb49cadea8825ab283d745/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=10a11b75613b5fc2d7fb49cadea8825ab283d745", "patch": "@@ -3689,17 +3689,6 @@ rest_of_compilation (decl)\n \t      TIMEVAR (symout_time, dwarfout_file_scope_decl (decl, 0));\n \t      set_decl_abstract_flags (decl, 0);\n \t    }\n-#endif\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t  /* Generate the DWARF2 info for the \"abstract\" instance\n-\t     of a function which we may later generate inlined and/or\n-\t     out-of-line instances of.  */\n-\t  if (write_symbols == DWARF2_DEBUG)\n-\t    {\n-\t      set_decl_abstract_flags (decl, 1);\n-\t      TIMEVAR (symout_time, dwarf2out_decl (decl));\n-\t      set_decl_abstract_flags (decl, 0);\n-\t    }\n #endif\n \t  TIMEVAR (integration_time, save_for_inline_nocopy (decl));\n \t  DECL_SAVED_INSNS (decl)->inlinable = inlinable;"}]}