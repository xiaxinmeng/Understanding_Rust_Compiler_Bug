{"sha": "44167383a18a5e2af75ccccaf2c1ea7b6c334695", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQxNjczODNhMThhNWUyYWY3NWNjY2NhZjJjMWVhN2I2YzMzNDY5NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-10-06T17:12:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-06T17:12:36Z"}, "message": "i386: Add AVX2 support to ix86_expand_vshuffle.\n\nFrom-SVN: r179624", "tree": {"sha": "79d2344f83536551f5ddcd1e7afd6976092174f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79d2344f83536551f5ddcd1e7afd6976092174f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44167383a18a5e2af75ccccaf2c1ea7b6c334695", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44167383a18a5e2af75ccccaf2c1ea7b6c334695", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44167383a18a5e2af75ccccaf2c1ea7b6c334695", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44167383a18a5e2af75ccccaf2c1ea7b6c334695/comments", "author": null, "committer": null, "parents": [{"sha": "cf9899972bcb7ec5e577519737cd9443eb783d6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf9899972bcb7ec5e577519737cd9443eb783d6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf9899972bcb7ec5e577519737cd9443eb783d6d"}], "stats": {"total": 152, "additions": 135, "deletions": 17}, "files": [{"sha": "89905f5b7279bb3bbc317682cd151b4ab833c86e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44167383a18a5e2af75ccccaf2c1ea7b6c334695/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44167383a18a5e2af75ccccaf2c1ea7b6c334695/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44167383a18a5e2af75ccccaf2c1ea7b6c334695", "patch": "@@ -1,3 +1,12 @@\n+2001-10-06  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_expand_vshuffle): Add AVX2 support.\n+\t* config/i386/sse.md (sseshuffint): Remove.\n+\t(sseintvecmode): Support V16HI, V8HI, V32QI, V16QI.\n+\t(VSHUFFLE_AVX2): New mode iterator.\n+\t(vshuffle<mode>): Use it.\n+\t(avx_vec_concat<V_256>): Rename from *vec_concat<V_256>_avx.\n+\n 2001-10-06  Richard Henderson  <rth@redhat.com>\n \n \t* optabs.c (expand_vec_shuffle_expr): Use the proper mode for the"}, {"sha": "9960fd29ee607a1920f194d60a9095b152de701e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 108, "deletions": 4, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44167383a18a5e2af75ccccaf2c1ea7b6c334695/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44167383a18a5e2af75ccccaf2c1ea7b6c334695/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=44167383a18a5e2af75ccccaf2c1ea7b6c334695", "patch": "@@ -19312,17 +19312,120 @@ ix86_expand_vshuffle (rtx operands[])\n   rtx op0 = operands[1];\n   rtx op1 = operands[2];\n   rtx mask = operands[3];\n-  rtx vt, vec[16];\n+  rtx t1, t2, vt, vec[16];\n   enum machine_mode mode = GET_MODE (op0);\n   enum machine_mode maskmode = GET_MODE (mask);\n   int w, e, i;\n   bool one_operand_shuffle = rtx_equal_p (op0, op1);\n \n-  gcc_checking_assert (GET_MODE_BITSIZE (mode) == 128);\n-\n   /* Number of elements in the vector.  */\n   w = GET_MODE_NUNITS (mode);\n   e = GET_MODE_UNIT_SIZE (mode);\n+  gcc_assert (w <= 16);\n+\n+  if (TARGET_AVX2)\n+    {\n+      if (mode == V4DImode || mode == V4DFmode)\n+\t{\n+\t  /* Unfortunately, the VPERMQ and VPERMPD instructions only support\n+\t     an constant shuffle operand.  With a tiny bit of effort we can\n+\t     use VPERMD instead.  A re-interpretation stall for V4DFmode is\n+\t     unfortunate but there's no avoiding it.  */\n+\t  t1 = gen_reg_rtx (V8SImode);\n+\n+\t  /* Replicate the low bits of the V4DImode mask into V8SImode:\n+\t       mask = { A B C D }\n+\t       t1 = { A A B B C C D D }.  */\n+\t  for (i = 0; i < 4; ++i)\n+\t    vec[i*2 + 1] = vec[i*2] = GEN_INT (i * 2);\n+\t  vt = gen_rtx_CONST_VECTOR (V8SImode, gen_rtvec_v (8, vec));\n+\t  vt = force_reg (V8SImode, vt);\n+\t  mask = gen_lowpart (V8SImode, mask);\n+\t  emit_insn (gen_avx2_permvarv8si (t1, vt, mask));\n+\n+\t  /* Multiply the shuffle indicies by two.  */\n+\t  emit_insn (gen_avx2_lshlv8si3 (t1, t1, const1_rtx));\n+\n+\t  /* Add one to the odd shuffle indicies:\n+\t\tt1 = { A*2, A*2+1, B*2, B*2+1, ... }.  */\n+\t  for (i = 0; i < 4; ++i)\n+\t    {\n+\t      vec[i * 2] = const0_rtx;\n+\t      vec[i * 2 + 1] = const1_rtx;\n+\t    }\n+\t  vt = gen_rtx_CONST_VECTOR (V8SImode, gen_rtvec_v (8, vec));\n+\t  vt = force_const_mem (V8SImode, vt);\n+\t  emit_insn (gen_addv8si3 (t1, t1, vt));\n+\n+\t  /* Continue as if V8SImode was used initially.  */\n+\t  operands[3] = mask = t1;\n+\t  target = gen_lowpart (V8SImode, target);\n+\t  op0 = gen_lowpart (V8SImode, op0);\n+\t  op1 = gen_lowpart (V8SImode, op1);\n+\t  maskmode = mode = V8SImode;\n+\t  w = 8;\n+\t  e = 4;\n+\t}\n+\n+      switch (mode)\n+\t{\n+\tcase V8SImode:\n+\t  /* The VPERMD and VPERMPS instructions already properly ignore\n+\t     the high bits of the shuffle elements.  No need for us to\n+\t     perform an AND ourselves.  */\n+\t  if (one_operand_shuffle)\n+\t    emit_insn (gen_avx2_permvarv8si (target, mask, op0));\n+\t  else\n+\t    {\n+\t      t1 = gen_reg_rtx (V8SImode);\n+\t      t2 = gen_reg_rtx (V8SImode);\n+\t      emit_insn (gen_avx2_permvarv8si (t1, mask, op0));\n+\t      emit_insn (gen_avx2_permvarv8si (t2, mask, op1));\n+\t      goto merge_two;\n+\t    }\n+\t  return;\n+\n+\tcase V8SFmode:\n+\t  mask = gen_lowpart (V8SFmode, mask);\n+\t  if (one_operand_shuffle)\n+\t    emit_insn (gen_avx2_permvarv8sf (target, mask, op0));\n+\t  else\n+\t    {\n+\t      t1 = gen_reg_rtx (V8SFmode);\n+\t      t2 = gen_reg_rtx (V8SFmode);\n+\t      emit_insn (gen_avx2_permvarv8sf (t1, mask, op0));\n+\t      emit_insn (gen_avx2_permvarv8sf (t2, mask, op1));\n+\t      goto merge_two;\n+\t    }\n+\t  return;\n+\n+        case V4SImode:\n+\t  /* By combining the two 128-bit input vectors into one 256-bit\n+\t     input vector, we can use VPERMD and VPERMPS for the full\n+\t     two-operand shuffle.  */\n+\t  t1 = gen_reg_rtx (V8SImode);\n+\t  t2 = gen_reg_rtx (V8SImode);\n+\t  emit_insn (gen_avx_vec_concatv8si (t1, op0, op1));\n+\t  emit_insn (gen_avx_vec_concatv8si (t2, mask, mask));\n+\t  emit_insn (gen_avx2_permvarv8si (t1, t2, t1));\n+\t  emit_insn (gen_avx_vextractf128v8si (target, t1, const0_rtx));\n+\t  return;\n+\n+        case V4SFmode:\n+\t  t1 = gen_reg_rtx (V8SFmode);\n+\t  t2 = gen_reg_rtx (V8SFmode);\n+\t  mask = gen_lowpart (V4SFmode, mask);\n+\t  emit_insn (gen_avx_vec_concatv8sf (t1, op0, op1));\n+\t  emit_insn (gen_avx_vec_concatv8sf (t2, mask, mask));\n+\t  emit_insn (gen_avx2_permvarv8sf (t1, t2, t1));\n+\t  emit_insn (gen_avx_vextractf128v8sf (target, t1, const0_rtx));\n+\t  return;\n+\n+\tdefault:\n+\t  gcc_assert (GET_MODE_SIZE (mode) <= 16);\n+\t  break;\n+\t}\n+    }\n \n   if (TARGET_XOP)\n     {\n@@ -19394,7 +19497,7 @@ ix86_expand_vshuffle (rtx operands[])\n     }\n   else\n     {\n-      rtx xops[6], t1, t2;\n+      rtx xops[6];\n       bool ok;\n \n       /* Shuffle the two input vectors independently.  */\n@@ -19403,6 +19506,7 @@ ix86_expand_vshuffle (rtx operands[])\n       emit_insn (gen_ssse3_pshufbv16qi3 (t1, op0, mask));\n       emit_insn (gen_ssse3_pshufbv16qi3 (t2, op1, mask));\n \n+ merge_two:\n       /* Then merge them together.  The key is whether any given control\n          element contained a bit set that indicates the second word.  */\n       mask = operands[3];"}, {"sha": "bf1d448f84d4f3ffe476818babd6679097525be7", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44167383a18a5e2af75ccccaf2c1ea7b6c334695/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44167383a18a5e2af75ccccaf2c1ea7b6c334695/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=44167383a18a5e2af75ccccaf2c1ea7b6c334695", "patch": "@@ -230,19 +230,16 @@\n    (V4SF \"V4SF\") (V2DF \"V2DF\")\n    (TI \"TI\")])\n \n-;; All 128bit vector modes\n-(define_mode_attr sseshuffint\n-  [(V16QI \"V16QI\") (V8HI \"V8HI\")\n-   (V4SI \"V4SI\")  (V2DI \"V2DI\")\n-   (V4SF \"V4SI\") (V2DF \"V2DI\")])\n-\n ;; Mapping of vector float modes to an integer mode of the same size\n (define_mode_attr sseintvecmode\n   [(V8SF \"V8SI\") (V4DF \"V4DI\")\n    (V4SF \"V4SI\") (V2DF \"V2DI\")\n    (V4DF \"V4DI\") (V8SF \"V8SI\")\n    (V8SI \"V8SI\") (V4DI \"V4DI\")\n-   (V4SI \"V4SI\") (V2DI \"V2DI\")])\n+   (V4SI \"V4SI\") (V2DI \"V2DI\")\n+   (V16HI \"V16HI\") (V8HI \"V8HI\")\n+   (V32QI \"V32QI\") (V16QI \"V16QI\")\n+  ])\n \n ;; Mapping of vector modes to a vector mode of double size\n (define_mode_attr ssedoublevecmode\n@@ -6226,12 +6223,20 @@\n   DONE;\n })\n \n+;; ??? Irritatingly, the 256-bit VPSHUFB only shuffles within the 128-bit\n+;; lanes.  For now, we don't try to support V32QI or V16HImode.  So we\n+;; don't want to use VI_AVX2.\n+(define_mode_iterator VSHUFFLE_AVX2\n+  [V16QI V8HI V4SI V2DI V4SF V2DF\n+   (V8SI \"TARGET_AVX2\") (V4DI \"TARGET_AVX2\")\n+   (V8SF \"TARGET_AVX2\") (V4DF \"TARGET_AVX2\")])\n+\n (define_expand \"vshuffle<mode>\"\n-  [(match_operand:V_128 0 \"register_operand\" \"\")\n-   (match_operand:V_128 1 \"register_operand\" \"\")\n-   (match_operand:V_128 2 \"register_operand\" \"\")\n-   (match_operand:<sseshuffint> 3 \"register_operand\" \"\")]\n-  \"TARGET_SSSE3 || TARGET_AVX\"\n+  [(match_operand:VSHUFFLE_AVX2 0 \"register_operand\" \"\")\n+   (match_operand:VSHUFFLE_AVX2 1 \"register_operand\" \"\")\n+   (match_operand:VSHUFFLE_AVX2 2 \"register_operand\" \"\")\n+   (match_operand:<sseintvecmode> 3 \"register_operand\" \"\")]\n+  \"TARGET_SSSE3 || TARGET_AVX || TARGET_XOP\"\n {\n   ix86_expand_vshuffle (operands);\n   DONE;\n@@ -12397,7 +12402,7 @@\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"TI\")])\n \n-(define_insn \"*vec_concat<mode>_avx\"\n+(define_insn \"avx_vec_concat<mode>\"\n   [(set (match_operand:V_256 0 \"register_operand\" \"=x,x\")\n \t(vec_concat:V_256\n \t  (match_operand:<ssehalfvecmode> 1 \"register_operand\" \"x,x\")"}]}