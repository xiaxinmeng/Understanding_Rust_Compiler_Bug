{"sha": "89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlmYjcwYTM0NTEwNGE4NGJmZjRkNTEwNWYzNDU2ZTdiOGE1Y2ExZQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2007-06-30T14:15:26Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-06-30T14:15:26Z"}, "message": "Fix PR tree-optimization/32540 Fix PR tree-optimization/31651\n\n2007-06-30  Daniel Berlin  <dberlin@dberlin.org>\n\t\n\tFix PR tree-optimization/32540\n\tFix PR tree-optimization/31651\n\n\t* tree-ssa-sccvn.c: New file.\n\n\t* tree-ssa-sccvn.h: Ditto.\n\t\n\t* tree-vn.c: Include tree-ssa-sccvn.h\n\t(val_expr_paid_d): Removed.\n\t(value_table): Ditto.\n\t(vn_compute): Ditto.\n\t(val_expr_pair_hash): Ditto.\n\t(val_expr_pair_expr_eq): Ditto.\n\t(copy_vuses_from_stmt): Ditto.\n\t(vn_delete): Ditto.\n\t(vn_init): Ditto.\n\t(shared_vuses_from_stmt): Ditto.\n\t(print_creation_to_file): Moved up.\n\t(sort_vuses): Ditto.\n\t(sort_vuses_heap): Ditto.\n\t(set_value_handle): Make non-static.\n\t(make_value_handle): Ditto.\n\t(vn_add): Rewritten to use sccvn lookups.\n\t(vn_add_with_vuses): Ditto.\n\t(vn_lookup): Ditto (and second argument removed).\n\t(vn_lookup_with_vuses): Ditto.\n\t(vn_lookup_or_add): Ditto (and second argument removed);\n\t(vn_lookup_or_add_with_vuses): Ditto.\n\t(vn_lookup_with_stmt): New.\n\t(vn_lookup_or_add_with_stmt): Ditto.\n\t(create_value_handle_for_expr): Ditto.\n\n\t* tree-ssa-pre.c: Include tree-ssa-sccvn.h.\n\t(seen_during_translate): New function.\n\t(phi_trans_lookup): Use iterative_hash_expr, not vn_compute.\n\t(phi_trans_add): Ditto.\n\t(constant_expr_p): FIELD_DECL is always constant.\n\t(phi_translate_1): Renamed from phi_translate, add seen bitmap.\n\tUse constant_expr_p.\n\tAvoid infinite recursion on mutually valued expressions.\n\tChange callers of vn_lookup_or_add.\n\t(phi_translate): New function.\n\t(compute_antic_safe): Allow phi nodes.\n\t(create_component_ref_by_pieces): Update for FIELD_DECL change.\n\t(find_or_generate_expression): Rewrite slightly.\n\t(create_expression_by_pieces): Updated for vn_lookup_or_add\n\tchange.\n\tUpdate VN_INFO for new names.\n\t(insert_into_preds_of_block): Update for new names.\n\t(add_to_exp_gen): New function.\n\t(add_to_sets): Use vn_lookup_or_add_with_stmt.\n\t(find_existing_value_expr): Rewrite to changed vn_lookup.\n\t(create_value_expr_from): Ditto, and use add_to_exp_gen.\n\t(try_look_through_load): Removed.\n\t(try_combine_conversion): Ditto.\n\t(get_sccvn_value): New function.\n\t(make_values_for_phi): Ditto.\n\t(make_values_for_stmt): Ditto.\n\t(compute_avail): Rewritten for vn_lookup_or_add changes and to use\n\tSCCVN.\n\t(init_pre): Update for SCCVN changes.\n\t(fini_pre): Ditto.\n\t(execute_pre): Ditto.\n\n\t* tree-flow.h (make_value_handle): Declare.\n\t(set_value_handle): Ditto.\n\t(sort_vuses_heap): Ditto.\n\t(vn_lookup_or_add_with_stmt): Ditto.\n\t(vn_lookup_with_stmt): Ditto.\n\t(vn_compute): Remove.\n\t(vn_init): Ditto.\n\t(vn_delete): Ditto.\n\t(vn_lookup): Update arguments.\n\n\t* Makefile.in (tree-ssa-pre.o): Add tree-ssa-sccvn.h\n\t(tree-vn.o): Ditto.\n\t(tree-ssa-sccvn.o): New.\n\t(OBJS-common): Add tree-ssa-sccvn.o\n\nFrom-SVN: r126149", "tree": {"sha": "3d5f6f46e5be067510e255315be8197a985346ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d5f6f46e5be067510e255315be8197a985346ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11147af3976574211dce0f0d69d2566f03b79c14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11147af3976574211dce0f0d69d2566f03b79c14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11147af3976574211dce0f0d69d2566f03b79c14"}], "stats": {"total": 3422, "additions": 2889, "deletions": 533}, "files": [{"sha": "de2a2c1307476664759b4d5c72041a8b967c228d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -1,3 +1,84 @@\n+2007-06-30  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\tFix PR tree-optimization/32540\n+\tFix PR tree-optimization/31651\n+\n+\t* tree-ssa-sccvn.c: New file.\n+\n+\t* tree-ssa-sccvn.h: Ditto.\n+\t\n+\t* tree-vn.c: Include tree-ssa-sccvn.h\n+\t(val_expr_paid_d): Removed.\n+\t(value_table): Ditto.\n+\t(vn_compute): Ditto.\n+\t(val_expr_pair_hash): Ditto.\n+\t(val_expr_pair_expr_eq): Ditto.\n+\t(copy_vuses_from_stmt): Ditto.\n+\t(vn_delete): Ditto.\n+\t(vn_init): Ditto.\n+\t(shared_vuses_from_stmt): Ditto.\n+\t(print_creation_to_file): Moved up.\n+\t(sort_vuses): Ditto.\n+\t(sort_vuses_heap): Ditto.\n+\t(set_value_handle): Make non-static.\n+\t(make_value_handle): Ditto.\n+\t(vn_add): Rewritten to use sccvn lookups.\n+\t(vn_add_with_vuses): Ditto.\n+\t(vn_lookup): Ditto (and second argument removed).\n+\t(vn_lookup_with_vuses): Ditto.\n+\t(vn_lookup_or_add): Ditto (and second argument removed);\n+\t(vn_lookup_or_add_with_vuses): Ditto.\n+\t(vn_lookup_with_stmt): New.\n+\t(vn_lookup_or_add_with_stmt): Ditto.\n+\t(create_value_handle_for_expr): Ditto.\n+\n+\t* tree-ssa-pre.c: Include tree-ssa-sccvn.h.\n+\t(seen_during_translate): New function.\n+\t(phi_trans_lookup): Use iterative_hash_expr, not vn_compute.\n+\t(phi_trans_add): Ditto.\n+\t(constant_expr_p): FIELD_DECL is always constant.\n+\t(phi_translate_1): Renamed from phi_translate, add seen bitmap.\n+\tUse constant_expr_p.\n+\tAvoid infinite recursion on mutually valued expressions.\n+\tChange callers of vn_lookup_or_add.\n+\t(phi_translate): New function.\n+\t(compute_antic_safe): Allow phi nodes.\n+\t(create_component_ref_by_pieces): Update for FIELD_DECL change.\n+\t(find_or_generate_expression): Rewrite slightly.\n+\t(create_expression_by_pieces): Updated for vn_lookup_or_add\n+\tchange.\n+\tUpdate VN_INFO for new names.\n+\t(insert_into_preds_of_block): Update for new names.\n+\t(add_to_exp_gen): New function.\n+\t(add_to_sets): Use vn_lookup_or_add_with_stmt.\n+\t(find_existing_value_expr): Rewrite to changed vn_lookup.\n+\t(create_value_expr_from): Ditto, and use add_to_exp_gen.\n+\t(try_look_through_load): Removed.\n+\t(try_combine_conversion): Ditto.\n+\t(get_sccvn_value): New function.\n+\t(make_values_for_phi): Ditto.\n+\t(make_values_for_stmt): Ditto.\n+\t(compute_avail): Rewritten for vn_lookup_or_add changes and to use\n+\tSCCVN.\n+\t(init_pre): Update for SCCVN changes.\n+\t(fini_pre): Ditto.\n+\t(execute_pre): Ditto.\n+\n+\t* tree-flow.h (make_value_handle): Declare.\n+\t(set_value_handle): Ditto.\n+\t(sort_vuses_heap): Ditto.\n+\t(vn_lookup_or_add_with_stmt): Ditto.\n+\t(vn_lookup_with_stmt): Ditto.\n+\t(vn_compute): Remove.\n+\t(vn_init): Ditto.\n+\t(vn_delete): Ditto.\n+\t(vn_lookup): Update arguments.\n+\n+\t* Makefile.in (tree-ssa-pre.o): Add tree-ssa-sccvn.h\n+\t(tree-vn.o): Ditto.\n+\t(tree-ssa-sccvn.o): New.\n+\t(OBJS-common): Add tree-ssa-sccvn.o\n+\t\n 2007-06-30  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c/4076"}, {"sha": "7c48cda4099fb377530c88cd64030dec35f52201", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -1137,6 +1137,7 @@ OBJS-common = \\\n \ttree-ssa-pre.o \\\n \ttree-ssa-propagate.o \\\n \ttree-ssa-reassoc.o \\\n+\ttree-ssa-sccvn.o \\\n \ttree-ssa-sink.o \\\n \ttree-ssa-structalias.o \\\n \ttree-ssa-ter.o \\\n@@ -2006,10 +2007,15 @@ tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(CFGLOOP_H) \\\n    alloc-pool.h $(BASIC_BLOCK_H) bitmap.h $(HASHTAB_H) $(TREE_GIMPLE_H) \\\n-   $(TREE_INLINE_H) tree-iterator.h\n+   $(TREE_INLINE_H) tree-iterator.h tree-ssa-sccvn.h\n+tree-ssa-sccvn.o : tree-ssa-sccvn.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n+   $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(CFGLOOP_H) \\\n+   alloc-pool.h $(BASIC_BLOCK_H) bitmap.h $(HASHTAB_H) $(TREE_GIMPLE_H) \\\n+   $(TREE_INLINE_H) tree-iterator.h tree-ssa-sccvn.h\n tree-vn.o : tree-vn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n    $(TREE_H) $(TREE_FLOW_H) $(HASHTAB_H) langhooks.h tree-pass.h \\\n-   $(TREE_DUMP_H) $(DIAGNOSTIC_H)\n+   $(TREE_DUMP_H) $(DIAGNOSTIC_H) tree-ssa-sccvn.h\n tree-vrp.o : tree-vrp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) tree-ssa-propagate.h $(FLAGS_H) $(TREE_DUMP_H) \\"}, {"sha": "e8c57512bbdb56a86ba0acbe250db5779a4b444f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-1.c?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -11,6 +11,6 @@ int f(int *a)\n   return *c + t;\n }\n \n-/* { dg-final { scan-tree-dump \"Replaced \\\\\\(int \\\\\\*\\\\\\) b_.*with a_\" \"fre\" } } */\n-/* { dg-final { scan-tree-dump \"Replaced \\\\\\*c_.*with t_\" \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced \\\\\\(int \\\\\\*\\\\\\) b_.*with a_\" \"fre\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"Replaced \\\\\\*c_.*with t_\" \"fre\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "e22064624ae298886c17be02e396955da8e18348", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-3.c?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -11,5 +11,5 @@ foo (int a, int b)\n   return aa + bb;\n }\n \n-/* { dg-final { scan-tree-dump \"Replaced \\\\\\(int\\\\\\) aa_.*with a_\" \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced \\\\\\(int\\\\\\) aa_.*with a_\" \"fre\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "2b2353f33633dca851523019b987804e53c214f2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-4.c?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -9,6 +9,6 @@ char bar(char f)\n         return wrap(f);\n }\n \n-/* { dg-final { scan-tree-dump \"Replaced \\\\\\(char\\\\\\) .*with \" \"fre\" } } */\n-/* { dg-final { scan-tree-dump \"Replaced \\\\\\(int\\\\\\) .*with \" \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced \\\\\\(char\\\\\\) .*with \" \"fre\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"Replaced \\\\\\(int\\\\\\) .*with \" \"fre\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "db6346cc2e77c927d3353fa16a6d7b16e5af4f2d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-5.c?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -10,5 +10,5 @@ bar (unsigned int t)\n   return a == t;\n }\n \n-/* { dg-final { scan-tree-dump \"Replaced \\\\\\(unsigned int\\\\\\) a_.*with t_\" \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced \\\\\\(unsigned int\\\\\\) a_.*with t_\" \"fre\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "263124b646ebfd79ca643fb8633800e2bfcbb16a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-1.c?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-fre-stats\" } */\n+\n+void vnum_test8(int *data) \n+{ \n+  int i; \n+  int stop = data[3]; \n+  int m = data[4]; \n+  int n = m; \n+  for (i=0; i<stop; i++) { \n+    int k = data[2]; \n+    data[k] = 2; \n+    data[0] = m - n; \n+    k = data[1]; \n+    m = m + k; \n+    n = n + k; \n+  } \n+} \n+/* We should eliminate m - n, and set n = n + k into n = m. */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 2\" 1 \"fre\"} } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "2c73a678b788b6b92ce637bc1de3002535f3945c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-2.c?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-fre-stats\" } */\n+\n+int vnum_test8(int *data) \n+{ \n+  int i; \n+  int stop = data[3]; \n+  int m = data[4]; \n+  int n = m; \n+  int p;\n+  for (i=0; i<stop; i++) { \n+    int k = data[2]; \n+    data[k] = 2; \n+    data[0] = m - n; \n+    k = data[1]; \n+    m = m + k; \n+    n = n + k;\n+    p = data[0]; \n+  } \n+  return p;\n+} \n+/* We should eliminate m - n, and set n = n + k into n = m, and\n+   set p to 0 */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 3\" 1 \"fre\"} } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "b80a8dc3bba7ad12ae274f08ac39b7bb3187b2f2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-3.c?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-fre-stats\" } */\n+int main(int argc, char **argv)\n+{\n+  int *p;\n+  int result;\n+  *p = 2;\n+  if (argc)\n+    *p = 2;\n+  result = *p;\n+  return result;\n+}\n+/* We should eliminate result = *p by saying it has the value 2.  */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"fre\"} } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "7caf4eec6f8f948ee6dbe990f7cd8ecfdf100ee0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-4.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-4.c?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-fre-stats\" } */\n+\n+int vnum_test8(int *data) \n+{ \n+  int i; \n+  int stop = data[3]; \n+  int m = data[4]; \n+  int n = m; \n+  int p = 0;\n+\n+  for (i=0; i<stop; i++) { \n+    int k = data[2]; \n+    data[5] = 0;\n+    if (i < 30)\n+      data[5] = m - n;\n+    p = data[5];\n+    k = data[1]; \n+    m = m + k; \n+    n = n + k; \n+  } \n+  return p;\n+} \n+/* We should eliminate m - n, n + k, set data[5] = 0, eliminate the\n+   address arithmetic for data[5], and set p = 0.\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 5\" 1 \"fre\"} } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "76378699706d84cc320725876f8bda700c9d4349", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -1083,18 +1083,20 @@ void print_value_expressions (FILE *, tree);\n \n \n /* In tree-vn.c  */\n+tree make_value_handle (tree);\n+void set_value_handle (tree, tree);\n bool expressions_equal_p (tree, tree);\n static inline tree get_value_handle (tree);\n-hashval_t vn_compute (tree, hashval_t);\n void sort_vuses (VEC (tree, gc) *);\n-tree vn_lookup_or_add (tree, tree);\n+void sort_vuses_heap (VEC (tree, heap) *);\n+tree vn_lookup_or_add (tree);\n+tree vn_lookup_or_add_with_stmt (tree, tree);\n tree vn_lookup_or_add_with_vuses (tree, VEC (tree, gc) *);\n void vn_add (tree, tree);\n void vn_add_with_vuses (tree, tree, VEC (tree, gc) *);\n-tree vn_lookup (tree, tree);\n+tree vn_lookup_with_stmt (tree, tree);\n+tree vn_lookup (tree);\n tree vn_lookup_with_vuses (tree, VEC (tree, gc) *);\n-void vn_init (void);\n-void vn_delete (void);\n \n /* In tree-ssa-sink.c  */\n bool is_hidden_global_store (tree);"}, {"sha": "b3f2cf05c44c7ef70eb948a04c8d610505e40e6a", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -299,12 +299,12 @@ typedef struct ssa_operand_iterator_d\n        DEFVAR = op_iter_next_def (&(ITER)))\n \n /* This macro executes a loop over the VDEF operands of STMT.  The def\n-   and use for each VDEF is returned in DEFVAR and USEVAR. \n+   and use vector for each VDEF is returned in DEFVAR and USEVECT. \n    ITER is an ssa_op_iter structure used to control the loop.  */\n-#define FOR_EACH_SSA_VDEF_OPERAND(DEFVAR, USEVAR, STMT, ITER)\t\\\n-  for (op_iter_init_vdef (&(ITER), STMT, &(USEVAR), &(DEFVAR));\t\\\n+#define FOR_EACH_SSA_VDEF_OPERAND(DEFVAR, USEVECT, STMT, ITER)\t\\\n+  for (op_iter_init_vdef (&(ITER), STMT, &(USEVECT), &(DEFVAR));\t\\\n        !op_iter_done (&(ITER));\t\t\t\t\t\\\n-       op_iter_next_vdef (&(USEVAR), &(DEFVAR), &(ITER)))\n+       op_iter_next_vdef (&(USEVECT), &(DEFVAR), &(ITER)))\n \n /* This macro will execute a loop over all the arguments of a PHI which\n    match FLAGS.   A use_operand_p is always returned via USEVAR.  FLAGS"}, {"sha": "966d881f8f8118d82feaca63a3a32184e6a57964", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 369, "deletions": 267, "changes": 636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -45,6 +45,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"bitmap.h\"\n #include \"langhooks.h\"\n #include \"cfgloop.h\"\n+#include \"tree-ssa-sccvn.h\"\n \n /* TODO:\n \n@@ -393,6 +394,9 @@ static tree prephitemp;\n    cleaned up.  */\n static bitmap need_eh_cleanup;\n \n+/* Which expressions have been seen during a given phi translation.  */\n+static bitmap seen_during_translate;\n+\n /* The phi_translate_table caches phi translations for a given\n    expression and predecessor.  */\n \n@@ -482,7 +486,7 @@ phi_trans_lookup (tree e, basic_block pred, VEC (tree, gc) *vuses)\n   ept.e = e;\n   ept.pred = pred;\n   ept.vuses = vuses;\n-  ept.hashcode = vn_compute (e, (unsigned long) pred);\n+  ept.hashcode = iterative_hash_expr (e, (unsigned long) pred);\n   slot = htab_find_slot_with_hash (phi_translate_table, &ept, ept.hashcode,\n \t\t\t\t   NO_INSERT);\n   if (!slot)\n@@ -504,7 +508,7 @@ phi_trans_add (tree e, tree v, basic_block pred, VEC (tree, gc) *vuses)\n   new_pair->pred = pred;\n   new_pair->vuses = vuses;\n   new_pair->v = v;\n-  new_pair->hashcode = vn_compute (e, (unsigned long) pred);\n+  new_pair->hashcode = iterative_hash_expr (e, (unsigned long) pred);\n   slot = htab_find_slot_with_hash (phi_translate_table, new_pair,\n \t\t\t\t   new_pair->hashcode, INSERT);\n   if (*slot)\n@@ -519,8 +523,8 @@ phi_trans_add (tree e, tree v, basic_block pred, VEC (tree, gc) *vuses)\n static inline bool\n constant_expr_p (tree v)\n {\n-  return TREE_CODE (v) != VALUE_HANDLE && is_gimple_min_invariant (v);\n-/*   return TREE_CODE (v) != VALUE_HANDLE; */\n+  return TREE_CODE (v) != VALUE_HANDLE && \n+    (TREE_CODE (v) == FIELD_DECL || is_gimple_min_invariant (v));\n }\n \n /* Add expression E to the expression set of value V.  */\n@@ -648,9 +652,8 @@ bitmap_set_and (bitmap_set_t dest, bitmap_set_t orig)\n   if (dest != orig)\n     {\n       bitmap temp = BITMAP_ALLOC (&grand_bitmap_obstack);\n-      \n+\n       bitmap_and_into (dest->values, orig->values);\n-      \n       bitmap_copy (temp, dest->expressions);\n       EXECUTE_IF_SET_IN_BITMAP (temp, 0, i, bi)\n \t{\n@@ -937,20 +940,22 @@ find_leader_in_sets (tree expr, bitmap_set_t set1, bitmap_set_t set2)\n }\n \n /* Translate EXPR using phis in PHIBLOCK, so that it has the values of\n-   the phis in PRED.  Return NULL if we can't find a leader for each\n-   part of the translated expression.  */\n+   the phis in PRED.  SEEN is a bitmap saying which expression we have\n+   translated since we started translation of the toplevel expression.\n+   Return NULL if we can't find a leader for each part of the\n+   translated expression.  */  \n \n static tree\n-phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n-\t       basic_block pred, basic_block phiblock)\n+phi_translate_1 (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n+\t\t basic_block pred, basic_block phiblock, bitmap seen)\n {\n   tree phitrans = NULL;\n   tree oldexpr = expr;\n \n   if (expr == NULL)\n     return NULL;\n \n-  if (is_gimple_min_invariant (expr))\n+  if (constant_expr_p (expr))\n     return expr;\n \n   /* Phi translations of a given expression don't change.  */\n@@ -970,6 +975,16 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n   if (phitrans)\n     return phitrans;\n \n+  /* Prevent cycles when we have recursively dependent leaders.  This\n+     can only happen when phi translating the maximal set.  */\n+  if (seen)\n+    {\n+      unsigned int expr_id = get_expression_id (expr);\n+      if (bitmap_bit_p (seen, expr_id))\n+\treturn NULL;\n+      bitmap_set_bit (seen, expr_id);\n+    }\n+\n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n     case tcc_expression:\n@@ -991,8 +1006,8 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t    VEC (tree, gc) *vuses = VALUE_HANDLE_VUSES (vh);\n \t    VEC (tree, gc) *tvuses;\n \n-\t    newfn = phi_translate (find_leader_in_sets (oldfn, set1, set2),\n-\t\t\t\t   set1, set2, pred, phiblock);\n+\t    newfn = phi_translate_1 (find_leader_in_sets (oldfn, set1, set2),\n+\t\t\t\t     set1, set2, pred, phiblock, seen);\n \t    if (newfn == NULL)\n \t      return NULL;\n \t    if (newfn != oldfn)\n@@ -1002,8 +1017,8 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t      }\n \t    if (oldsc)\n \t      {\n-\t\tnewsc = phi_translate (find_leader_in_sets (oldsc, set1, set2),\n-\t\t\t\t       set1, set2, pred, phiblock);\n+\t\tnewsc = phi_translate_1 (find_leader_in_sets (oldsc, set1, set2),\n+\t\t\t\t\t set1, set2, pred, phiblock, seen);\n \t\tif (newsc == NULL)\n \t\t  return NULL;\n \t\tif (newsc != oldsc)\n@@ -1035,8 +1050,8 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\t    if (AGGREGATE_TYPE_P (TREE_TYPE (oldval)))\n \t\t      return NULL;\n \t\t    oldval = find_leader_in_sets (oldval, set1, set2);\n-\t\t    newval = phi_translate (oldval, set1, set2, pred,\n-\t\t\t\t\t    phiblock);\n+\t\t    newval = phi_translate_1 (oldval, set1, set2, pred,\n+\t\t\t\t\t    phiblock, seen);\n \t\t    if (newval == NULL)\n \t\t      return NULL;\n \t\t    if (newval != oldval)\n@@ -1067,9 +1082,9 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \n \t    tvuses = translate_vuses_through_block (vuses, phiblock, pred);\n \t    if (vuses != tvuses && ! newexpr)\n- \t      newexpr = temp_copy_call_expr (expr);\n+\t      newexpr = temp_copy_call_expr (expr);\n \n- \t    if (newexpr)\n+\t    if (newexpr)\n \t      {\n \t\tnewexpr->base.ann = NULL;\n \t\tvn_lookup_or_add_with_vuses (newexpr, tvuses);\n@@ -1117,15 +1132,15 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t  return NULL;\n \n \toldop0 = find_leader_in_sets (oldop0, set1, set2);\n-\tnewop0 = phi_translate (oldop0, set1, set2, pred, phiblock);\n+\tnewop0 = phi_translate_1 (oldop0, set1, set2, pred, phiblock, seen);\n \tif (newop0 == NULL)\n \t  return NULL;\n \n \tif (TREE_CODE (expr) == ARRAY_REF)\n \t  {\n \t    oldop1 = TREE_OPERAND (expr, 1);\n \t    oldop1 = find_leader_in_sets (oldop1, set1, set2);\n-\t    newop1 = phi_translate (oldop1, set1, set2, pred, phiblock);\n+\t    newop1 = phi_translate_1 (oldop1, set1, set2, pred, phiblock, seen);\n \n \t    if (newop1 == NULL)\n \t      return NULL;\n@@ -1134,7 +1149,7 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t    if (oldop2)\n \t      {\n \t\toldop2 = find_leader_in_sets (oldop2, set1, set2);\n-\t\tnewop2 = phi_translate (oldop2, set1, set2, pred, phiblock);\n+\t\tnewop2 = phi_translate_1 (oldop2, set1, set2, pred, phiblock, seen);\n \n \t\tif (newop2 == NULL)\n \t\t  return NULL;\n@@ -1143,7 +1158,7 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t    if (oldop3)\n \t      {\n \t\toldop3 = find_leader_in_sets (oldop3, set1, set2);\n-\t\tnewop3 = phi_translate (oldop3, set1, set2, pred, phiblock);\n+\t\tnewop3 = phi_translate_1 (oldop3, set1, set2, pred, phiblock, seen);\n \n \t\tif (newop3 == NULL)\n \t\t  return NULL;\n@@ -1205,12 +1220,12 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \ttree newexpr;\n \n \toldop1 = find_leader_in_sets (oldop1, set1, set2);\n-\tnewop1 = phi_translate (oldop1, set1, set2, pred, phiblock);\n+\tnewop1 = phi_translate_1 (oldop1, set1, set2, pred, phiblock, seen);\n \tif (newop1 == NULL)\n \t  return NULL;\n \n \toldop2 = find_leader_in_sets (oldop2, set1, set2);\n-\tnewop2 = phi_translate (oldop2, set1, set2, pred, phiblock);\n+\tnewop2 = phi_translate_1 (oldop2, set1, set2, pred, phiblock, seen);\n \tif (newop2 == NULL)\n \t  return NULL;\n \tif (newop1 != oldop1 || newop2 != oldop2)\n@@ -1229,7 +1244,7 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t    else\n \t      {\n \t\tnewexpr->base.ann = NULL;\n-\t\tvn_lookup_or_add (newexpr, NULL);\n+\t\tvn_lookup_or_add (newexpr);\n \t      }\n \t    expr = newexpr;\n \t  }\n@@ -1244,7 +1259,7 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \ttree newexpr;\n \n \toldop1 = find_leader_in_sets (oldop1, set1, set2);\n-\tnewop1 = phi_translate (oldop1, set1, set2, pred, phiblock);\n+\tnewop1 = phi_translate_1 (oldop1, set1, set2, pred, phiblock, seen);\n \tif (newop1 == NULL)\n \t  return NULL;\n \tif (newop1 != oldop1)\n@@ -1262,7 +1277,7 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t    else\n \t      {\n \t\tnewexpr->base.ann = NULL;\n-\t\tvn_lookup_or_add (newexpr, NULL);\n+\t\tvn_lookup_or_add (newexpr);\n \t      }\n \t    expr = newexpr;\n \t  }\n@@ -1287,10 +1302,18 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \te = find_edge (pred, bb_for_stmt (phi));\n \tif (e)\n \t  {\n-\t    if (is_undefined_value (PHI_ARG_DEF (phi, e->dest_idx)))\n+\t    tree val;\n+\t    tree def = PHI_ARG_DEF (phi, e->dest_idx);\n+\t    \n+\t    if (is_gimple_min_invariant (def))\n+\t      return def;\n+\t    \n+\t    if (is_undefined_value (def))\n \t      return NULL;\n-\t    vn_lookup_or_add (PHI_ARG_DEF (phi, e->dest_idx), NULL);\n-\t    return PHI_ARG_DEF (phi, e->dest_idx);\n+\t    \n+\t    val = get_value_handle (def);\n+\t    gcc_assert (val);\n+\t    return def;\n \t  }\n       }\n       return expr;\n@@ -1299,6 +1322,17 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n       gcc_unreachable ();\n     }\n }\n+/* Translate EXPR using phis in PHIBLOCK, so that it has the values of\n+   the phis in PRED. \n+   Return NULL if we can't find a leader for each part of the\n+   translated expression.  */  \n+\n+static tree\n+phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n+\t       basic_block pred, basic_block phiblock)\n+{\n+  return phi_translate_1 (expr, set1, set2, pred, phiblock, NULL);\n+}\n \n /* For each expression in SET, translate the value handles through phi nodes\n    in PHIBLOCK using edge PHIBLOCK->PRED, and store the resulting\n@@ -1322,7 +1356,9 @@ phi_translate_set (bitmap_set_t dest, bitmap_set_t set, basic_block pred,\n   for (i = 0; VEC_iterate (tree, exprs, i, expr); i++)\n     {\n       tree translated;\n-      translated = phi_translate (expr, set, NULL, pred, phiblock);\n+      bitmap_clear (seen_during_translate);\n+      translated = phi_translate_1 (expr, set, NULL, pred, phiblock,\n+\t\t\t\t    seen_during_translate);\n \n       /* Don't add constants or empty translations to the cache, since\n \t we won't look them up that way, or use the result, anyway.  */\n@@ -1394,14 +1430,14 @@ value_dies_in_block_x (tree vh, basic_block block)\n   int i;\n   tree vuse;\n   VEC (tree, gc) *vuses = VALUE_HANDLE_VUSES (vh);\n-  \n+\n   /* Conservatively, a value dies if it's vuses are defined in this\n      block, unless they come from phi nodes (which are merge operations,\n      rather than stores.  */\n   for (i = 0; VEC_iterate (tree, vuses, i, vuse); i++)\n     {\n       tree def = SSA_NAME_DEF_STMT (vuse);\n-      \n+\n       if (bb_for_stmt (def) != block)\n \tcontinue;\n       if (TREE_CODE (def) == PHI_NODE)\n@@ -1571,7 +1607,7 @@ clean (bitmap_set_t set, basic_block block)\n }\n \n static sbitmap has_abnormal_preds;\n-\t\t\t      \n+\n /* List of blocks that may have changed during ANTIC computation and\n    thus need to be iterated over.  */\n \n@@ -1678,7 +1714,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n       if (phi_nodes (first))\n \t{\n \t  bitmap_set_t from = ANTIC_IN (first);\n-\t      \n+\n \t  if (!BB_VISITED (first))\n \t    from = maximal_set;\n \t  phi_translate_set (ANTIC_OUT, from, block, first);\n@@ -1693,22 +1729,22 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \n       for (i = 1; VEC_iterate (basic_block, worklist, i, bprime); i++)\n \t{\n-\t  if (phi_nodes (bprime)) \n+\t  if (phi_nodes (bprime))\n \t    {\n \t      bitmap_set_t tmp = bitmap_set_new ();\n \t      bitmap_set_t from = ANTIC_IN (bprime);\n-\t      \n+\n \t      if (!BB_VISITED (bprime))\n \t\tfrom = maximal_set;\n \t      phi_translate_set (tmp, from, block, bprime);\n \t      bitmap_set_and (ANTIC_OUT, tmp);\n \t      bitmap_set_free (tmp);\n \t    }\n-\t  else \n+\t  else\n \t    {\n \t      if (!BB_VISITED (bprime))\n \t\tbitmap_set_and (ANTIC_OUT, maximal_set);\n-\t      else \n+\t      else\n \t\tbitmap_set_and (ANTIC_OUT, ANTIC_IN (bprime));\n \t    }\n \t}\n@@ -1811,10 +1847,10 @@ compute_partial_antic_aux (basic_block block,\n     ;\n   /* If we have one successor, we could have some phi nodes to\n      translate through.  Note that we can't phi translate across DFS\n-     back edges in partial antic, because it uses a union operation\n-     on the successors.  For recurrences like IV's, we will end up generating a\n-     new value in the set on each go around (i + 3 (VH.1) VH.1 + 1\n-     (VH.2), VH.2 + 1 (VH.3), etc), forever.  */\n+     back edges in partial antic, because it uses a union operation on\n+     the successors.  For recurrences like IV's, we will end up\n+     generating a new value in the set on each go around (i + 3 (VH.1)\n+     VH.1 + 1 (VH.2), VH.2 + 1 (VH.3), etc), forever.  */\n   else if (single_succ_p (block))\n     {\n       basic_block succ = single_succ (block);\n@@ -2009,7 +2045,7 @@ compute_antic (void)\n    ANTIC_SAFE_LOADS are those loads generated in a block that actually\n    occur before any kill to their vuses in the block, and thus, are\n    safe at the top of the block.  This function computes the set by\n-   walking the EXP_GEN set for the block, and checking the VUSES.  \n+   walking the EXP_GEN set for the block, and checking the VUSES.\n \n    This set could be computed as ANTIC calculation is proceeding, but\n    but because it does not actually change during that computation, it is\n@@ -2022,7 +2058,7 @@ compute_antic_safe (void)\n   basic_block bb;\n   bitmap_iterator bi;\n   unsigned int i;\n-  \n+\n   FOR_EACH_BB (bb)\n     {\n       FOR_EACH_EXPR_ID_IN_SET (EXP_GEN (bb), i, bi)\n@@ -2036,26 +2072,28 @@ compute_antic_safe (void)\n \t      tree vuse;\n \t      tree stmt;\n \t      bool okay = true;\n-\t      \n+\n \t      if (!maybe)\n \t\tcontinue;\n \t      stmt = SSA_NAME_DEF_STMT (maybe);\n+\t      if (TREE_CODE (stmt) == PHI_NODE)\n+\t\tcontinue;\n \t      \n \t      FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, i,\n \t\t\t\t\t SSA_OP_VIRTUAL_USES)\n-\t\t{\t\t      \n+\t\t{\n \t\t  tree def = SSA_NAME_DEF_STMT (vuse);\n-\t\t  \n+\n \t\t  if (bb_for_stmt (def) != bb)\n \t\t    continue;\n-\t\t  \n+\n \t\t  /* See if the vuse is defined by a statement that\n \t\t     comes before us in the block.  Phi nodes are not\n \t\t     stores, so they do not count.  */\n \t\t  if (TREE_CODE (def) != PHI_NODE\n \t\t      && stmt_ann (def)->uid < stmt_ann (stmt)->uid)\n \t\t    {\n-\t\t      okay = false;      \n+\t\t      okay = false;\n \t\t      break;\n \t\t    }\n \t\t}\n@@ -2183,16 +2221,14 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n       }\n     case COMPONENT_REF:\n       {\n-\tbitmap_set_t exprset;\n-\tunsigned int firstbit;\n \ttree op0;\n \ttree op1;\n \top0 = create_component_ref_by_pieces (block,\n \t\t\t\t\t      TREE_OPERAND (genop, 0),\n \t\t\t\t\t      stmts);\n-\texprset = VALUE_HANDLE_EXPR_SET (TREE_OPERAND (genop, 1));\n-\tfirstbit = bitmap_first_set_bit (exprset->expressions);\n-\top1 = expression_for_id (firstbit);\n+\t/* op1 should be a FIELD_DECL, which are represented by\n+\t   themselves.  */\n+\top1 = TREE_OPERAND (genop, 1);\n \tfolded = fold_build3 (COMPONENT_REF, TREE_TYPE (genop), op0, op1,\n \t\t\t      NULL_TREE);\n \treturn folded;\n@@ -2240,11 +2276,24 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n   if (genop == NULL)\n     {\n       bitmap_set_t exprset = VALUE_HANDLE_EXPR_SET (expr);\n-      unsigned int firstbit = bitmap_first_set_bit (exprset->expressions);\n+      bool handled = false;\n+      bitmap_iterator bi;\n+      unsigned int i;\n \n-      genop = expression_for_id (firstbit);\n-      gcc_assert (can_PRE_operation (genop));\n-      genop = create_expression_by_pieces (block, genop, stmts);\n+      /* We will hit cases where we have SSA_NAME's in exprset before\n+\t other operations, because we may have come up with the SCCVN\n+\t value before getting to the RHS of the expression.  */\n+      FOR_EACH_EXPR_ID_IN_SET (exprset, i, bi)\n+\t{\n+\t  genop = expression_for_id (i);\n+\t  if (can_PRE_operation (genop))\n+\t    {\n+\t      handled = true;\n+\t      genop = create_expression_by_pieces (block, genop, stmts);\n+\t      break;\n+\t    }\n+\t}\n+      gcc_assert (handled);\n     }\n   return genop;\n }\n@@ -2365,9 +2414,10 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \t  tree stmt = tsi_stmt (tsi);\n \t  tree forcedname = GIMPLE_STMT_OPERAND (stmt, 0);\n \t  tree forcedexpr = GIMPLE_STMT_OPERAND (stmt, 1);\n-\t  tree val = vn_lookup_or_add (forcedexpr, NULL);\n+\t  tree val = vn_lookup_or_add (forcedexpr);\n \n \t  VEC_safe_push (tree, heap, inserted_exprs, stmt);\n+\t  VN_INFO_GET (forcedname)->valnum = forcedname;\n \t  vn_add (forcedname, val);\n \t  bitmap_value_replace_in_set (NEW_SETS (block), forcedname);\n \t  bitmap_value_replace_in_set (AVAIL_OUT (block), forcedname);\n@@ -2411,6 +2461,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n      here.  */\n   v = get_value_handle (expr);\n   vn_add (name, v);\n+  VN_INFO_GET (name)->valnum = name;\n   get_or_alloc_expression_id (name);\n   bitmap_value_replace_in_set (NEW_SETS (block), name);\n   bitmap_value_replace_in_set (AVAIL_OUT (block), name);\n@@ -2521,6 +2572,8 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n   temp = create_phi_node (temp, block);\n \n   NECESSARY (temp) = 0;\n+  VN_INFO_GET (PHI_RESULT (temp))->valnum = PHI_RESULT (temp);\n+  \n   VEC_safe_push (tree, heap, inserted_exprs, temp);\n   FOR_EACH_EDGE (pred, ei, block->preds)\n     add_phi_arg (temp, avail[pred->src->index], pred);\n@@ -2888,6 +2941,26 @@ is_undefined_value (tree expr)\n \t  && TREE_CODE (SSA_NAME_VAR (expr)) != PARM_DECL);\n }\n \n+/* Add OP to EXP_GEN (block), and possibly to the maximal set if it is\n+   not defined by a phi node.   \n+   PHI nodes can't go in the maximal sets because they are not in\n+   TMP_GEN, so it is possible to get into non-monotonic situations\n+   during ANTIC calculation, because it will *add* bits.  */\n+\n+static void\n+add_to_exp_gen (basic_block block, tree op)\n+{\n+  if (!in_fre)\n+    {\n+      if (TREE_CODE (op) == SSA_NAME && is_undefined_value (op))\n+\treturn;\n+      bitmap_value_insert_into_set (EXP_GEN (block), op);\n+      if (TREE_CODE (op) != SSA_NAME\n+\t  || TREE_CODE (SSA_NAME_DEF_STMT (op)) != PHI_NODE)\n+\tbitmap_value_insert_into_set (maximal_set, op);\n+    }\n+}\n+\n \n /* Given an SSA variable VAR and an expression EXPR, compute the value\n    number for EXPR and create a value handle (VAL) for it.  If VAR and\n@@ -2902,7 +2975,8 @@ static inline void\n add_to_sets (tree var, tree expr, tree stmt, bitmap_set_t s1,\n \t     bitmap_set_t s2)\n {\n-  tree val = vn_lookup_or_add (expr, stmt);\n+  tree val;\n+  val = vn_lookup_or_add_with_stmt (expr, stmt);\n \n   /* VAR and EXPR may be the same when processing statements for which\n      we are not computing value numbers (e.g., non-assignments, or\n@@ -2914,11 +2988,6 @@ add_to_sets (tree var, tree expr, tree stmt, bitmap_set_t s1,\n   if (s1)\n     bitmap_insert_into_set (s1, var);\n \n-  /* PHI nodes can't go in the maximal sets because they are not in\n-     TMP_GEN, so it is possible to get into non-monotonic situations\n-     during ANTIC calculation, because it will *add* bits.  */\n-  if (!in_fre && TREE_CODE (SSA_NAME_DEF_STMT (var)) != PHI_NODE)\n-    bitmap_value_insert_into_set (maximal_set, var);\n   bitmap_value_insert_into_set (s2, var);\n }\n \n@@ -2933,11 +3002,11 @@ find_existing_value_expr (tree t, tree stmt)\n   tree vh;\n   bitmap_set_t exprset;\n \n-  if (REFERENCE_CLASS_P (t))\n-    vh = vn_lookup (t, stmt);\n+  if (REFERENCE_CLASS_P (t) || TREE_CODE (t) == CALL_EXPR || DECL_P (t))\n+    vh = vn_lookup_with_stmt (t, stmt);\n   else\n-    vh = vn_lookup (t, NULL);\n-\n+    vh = vn_lookup (t);\n+  \n   if (!vh)\n     return NULL;\n   exprset = VALUE_HANDLE_EXPR_SET (vh);\n@@ -2996,7 +3065,8 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n \n   for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n     {\n-      tree val, op;\n+      tree val = NULL_TREE;\n+      tree op;\n \n       op = TREE_OPERAND (expr, i);\n       if (op == NULL_TREE)\n@@ -3007,15 +3077,15 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n \t{\n \t  tree tempop = create_value_expr_from (op, block, stmt);\n \t  op = tempop ? tempop : op;\n-\t  val = vn_lookup_or_add (op, stmt);\n+\t  val = vn_lookup_or_add_with_stmt (op, stmt);\n \t}\n       else\n-\t/* Create a value handle for OP and add it to VEXPR.  */\n-\tval = vn_lookup_or_add (op, NULL);\n-\n-      if (!is_undefined_value (op) && TREE_CODE (op) != TREE_LIST)\n-\tbitmap_value_insert_into_set (EXP_GEN (block), op);\n-\n+\t{\n+\t  val = vn_lookup_or_add (op);\n+\t}\n+      if (TREE_CODE (op) != TREE_LIST)\n+\tadd_to_exp_gen (block, op);\n+      \n       if (TREE_CODE (val) == VALUE_HANDLE)\n \tTREE_TYPE (val) = TREE_TYPE (TREE_OPERAND (vexpr, i));\n \n@@ -3028,77 +3098,6 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n   return vexpr;\n }\n \n-/* Given a statement STMT and its right hand side which is a load, try\n-   to look for the expression stored in the location for the load, and\n-   return true if a useful equivalence was recorded for LHS.  */\n-\n-static bool\n-try_look_through_load (tree lhs, tree mem_ref, tree stmt, basic_block block)\n-{\n-  tree store_stmt = NULL;\n-  tree rhs;\n-  ssa_op_iter i;\n-  tree vuse;\n-\n-  FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, i, SSA_OP_VIRTUAL_USES)\n-    {\n-      tree def_stmt;\n-\n-      gcc_assert (TREE_CODE (vuse) == SSA_NAME);\n-      def_stmt = SSA_NAME_DEF_STMT (vuse);\n-\n-      /* If there is no useful statement for this VUSE, we'll not find a\n-\t useful expression to return either.  Likewise, if there is a\n-\t statement but it is not a simple assignment or it has virtual\n-\t uses, we can stop right here.  Note that this means we do\n-\t not look through PHI nodes, which is intentional.  */\n-      if (!def_stmt\n-\t  || TREE_CODE (def_stmt) != GIMPLE_MODIFY_STMT\n-\t  || !ZERO_SSA_OPERANDS (def_stmt, SSA_OP_VIRTUAL_USES))\n-\treturn false;\n-\n-      /* If this is not the same statement as one we have looked at for\n-\t another VUSE of STMT already, we have two statements producing\n-\t something that reaches our STMT.  */\n-      if (store_stmt && store_stmt != def_stmt)\n-\treturn false;\n-      else\n-\t{\n-\t  /* Is this a store to the exact same location as the one we are\n-\t     loading from in STMT?  */\n-\t  if (!operand_equal_p (GIMPLE_STMT_OPERAND (def_stmt, 0), mem_ref, 0))\n-\t    return false;\n-\n-\t  /* Otherwise remember this statement and see if all other VUSEs\n-\t     come from the same statement.  */\n-\t  store_stmt = def_stmt;\n-\t}\n-    }\n-\n-  /* Alright then, we have visited all VUSEs of STMT and we've determined\n-     that all of them come from the same statement STORE_STMT.  See if there\n-     is a useful expression we can deduce from STORE_STMT.  */\n-  rhs = GIMPLE_STMT_OPERAND (store_stmt, 1);\n-  if ((TREE_CODE (rhs) == SSA_NAME\n-       && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs))\n-      || is_gimple_min_invariant (rhs)\n-      || TREE_CODE (rhs) == ADDR_EXPR\n-      || TREE_INVARIANT (rhs))\n-    {\n-\n-      /* Yay!  Compute a value number for the RHS of the statement and\n-\t add its value to the AVAIL_OUT set for the block.  Add the LHS\n-\t to TMP_GEN.  */\n-      add_to_sets (lhs, rhs, store_stmt, TMP_GEN (block), AVAIL_OUT (block));\n-      if (TREE_CODE (rhs) == SSA_NAME\n-\t  && !is_undefined_value (rhs))\n-\tbitmap_value_insert_into_set (EXP_GEN (block), rhs);\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n /* Return a copy of NODE that is stored in the temporary alloc_pool's.\n    This is made recursively true, so that the operands are stored in\n    the pool as well.  */\n@@ -3273,52 +3272,188 @@ realify_fake_stores (void)\n     }\n }\n \n-/* Tree-combine a value number expression *EXPR_P that does a type\n-   conversion with the value number expression of its operand.\n-   Returns true, if *EXPR_P simplifies to a value number or\n-   gimple min-invariant expression different from EXPR_P and\n-   sets *EXPR_P to the simplified expression value number.\n-   Otherwise returns false and does not change *EXPR_P.  */\n+/* Given an SSA_NAME, see if SCCVN has a value number for it, and if\n+   so, return the value handle for this value number, creating it if\n+   necessary.\n+   Return NULL if SCCVN has no info for us.  */\n \n-static bool\n-try_combine_conversion (tree *expr_p)\n+static tree\n+get_sccvn_value (tree name)\n {\n-  tree expr = *expr_p;\n-  tree t;\n-  bitmap_set_t exprset;\n-  unsigned int firstbit;\n-\n-  if (!((TREE_CODE (expr) == NOP_EXPR\n-\t || TREE_CODE (expr) == CONVERT_EXPR\n-\t || TREE_CODE (expr) == REALPART_EXPR\n-\t || TREE_CODE (expr) == IMAGPART_EXPR)\n-\t&& TREE_CODE (TREE_OPERAND (expr, 0)) == VALUE_HANDLE\n-\t&& !VALUE_HANDLE_VUSES (TREE_OPERAND (expr, 0))))\n-    return false;\n+  if (TREE_CODE (name) == SSA_NAME\n+      && VN_INFO (name)->valnum != name\n+      && VN_INFO (name)->valnum != VN_TOP)\n+    {\n+      tree val = VN_INFO (name)->valnum;\n+      bool is_invariant = is_gimple_min_invariant (val);\n+      tree valvh = !is_invariant ? get_value_handle (val) : NULL_TREE;\n \n-  exprset = VALUE_HANDLE_EXPR_SET (TREE_OPERAND (expr, 0));\n-  firstbit = bitmap_first_set_bit (exprset->expressions);\n-  t = fold_unary (TREE_CODE (expr), TREE_TYPE (expr),\n-\t\t  expression_for_id (firstbit));\n-  if (!t)\n-    return false;\n+      /* We may end up with situations where SCCVN has chosen a\n+\t representative for the equivalence set that we have not\n+\t visited yet.  In this case, just create the value handle for\n+\t it.  */\n+      if (!valvh && !is_invariant)\n+\t{\n+\t  tree defstmt = SSA_NAME_DEF_STMT (val);\n+\t  \n+\t  gcc_assert (VN_INFO (val)->valnum == val);\n+\t  /* PHI nodes can't have vuses and attempts to iterate over\n+\t     their VUSE operands will crash.  */\n+\t  if (TREE_CODE (defstmt) == PHI_NODE || IS_EMPTY_STMT (defstmt))\n+\t    defstmt = NULL;\n+\t  {\n+\t    tree defstmt2 = SSA_NAME_DEF_STMT (name);\n+\t    if (TREE_CODE (defstmt2) != PHI_NODE &&\n+\t\t!ZERO_SSA_OPERANDS (defstmt2, SSA_OP_ALL_VIRTUALS))\n+\t      gcc_assert (defstmt);\n+\t  }\n+\t  valvh = vn_lookup_or_add_with_stmt (val, defstmt);\n+\t}\n+      \n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"SCCVN says \");\n+\t  print_generic_expr (dump_file, name, 0);\n+\t  fprintf (dump_file, \" value numbers to \");\n+\t  if (valvh && !is_invariant)\n+\t    {\n+\t      print_generic_expr (dump_file, val, 0);\n+\t      fprintf (dump_file, \" (\");\n+\t      print_generic_expr (dump_file, valvh, 0);\n+\t      fprintf (dump_file, \")\\n\");\n+\t    }\n+\t  else\n+\t    print_generic_stmt (dump_file, val, 0);  \n+\t}\n+      if (valvh)\n+\treturn valvh;\n+      else\n+\treturn val;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Create value handles for PHI in BLOCK.  */\n+\n+static void\n+make_values_for_phi (tree phi, basic_block block)\n+{\n+  tree result = PHI_RESULT (phi);\n+  /* We have no need for virtual phis, as they don't represent\n+     actual computations.  */\n+  if (is_gimple_reg (result))\n+    {\n+      tree sccvnval = get_sccvn_value (result);\n+      if (sccvnval)\n+\t{\n+\t  vn_add (result, sccvnval);\n+\t  bitmap_insert_into_set (PHI_GEN (block), result);\n+\t  bitmap_value_insert_into_set (AVAIL_OUT (block), result);\n+\t}\n+      else\n+\tadd_to_sets (result, result, NULL,\n+\t\t     PHI_GEN (block), AVAIL_OUT (block));\n+    }\n+}\n \n-  /* Strip useless type conversions, which is safe in the optimizers but\n-     not generally in fold.  */\n-  STRIP_USELESS_TYPE_CONVERSION (t);\n \n-  /* Disallow value expressions we have no value number for already, as\n-     we would miss a leader for it here.  */\n-  if (!(TREE_CODE (t) == VALUE_HANDLE\n-\t|| is_gimple_min_invariant (t)))\n-    t = vn_lookup (t, NULL);\n+/* Create value handles for STMT in BLOCK.  Return true if we handled\n+   the statement.  */\n \n-  if (t && t != expr)\n+static bool\n+make_values_for_stmt (tree stmt, basic_block block)\n+{\n+\n+  tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+  tree valvh = NULL_TREE;\n+  tree lhsval;\n+  \n+  valvh = get_sccvn_value (lhs);\n+  if (valvh)\n+    {\n+      vn_add (lhs, valvh);\n+      bitmap_value_insert_into_set (AVAIL_OUT (block), lhs);      \n+      /* Shortcut for FRE. We have no need to create value expressions,\n+\t just want to know what values are available where.  */\n+      if (in_fre)\n+\treturn true;\n+\n+    }\n+  else if (in_fre)\n+    {\n+      /* For FRE, if SCCVN didn't find anything, we aren't going to\n+\t either, so just make up a new value number if necessary and\n+\t call it a day */\n+      if (get_value_handle (lhs) == NULL)\n+\tvn_lookup_or_add (lhs);\n+      bitmap_value_insert_into_set (AVAIL_OUT (block), lhs);\n+      return true;\n+    }\n+  \n+  lhsval = valvh ? valvh : get_value_handle (lhs);\n+  \n+  STRIP_USELESS_TYPE_CONVERSION (rhs);\n+  if (can_value_number_operation (rhs))\n+    {\n+      /* For value numberable operation, create a\n+\t duplicate expression with the operands replaced\n+\t with the value handles of the original RHS.  */\n+      tree newt = create_value_expr_from (rhs, block, stmt);\n+      if (newt)\n+\t{\n+\t  /* If we already have a value number for the LHS, reuse\n+\t     it rather than creating a new one.  */\n+\t  if (lhsval)\n+\t    {\n+\t      set_value_handle (newt, lhsval);\n+\t      if (!is_gimple_min_invariant (lhsval))\n+\t\tadd_to_value (lhsval, newt);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree val = vn_lookup_or_add_with_stmt (newt, stmt);\n+\t      vn_add (lhs, val);\n+\t    }\n+\t  \n+\t  add_to_exp_gen (block, newt);\n+\t}      \n+      \n+      bitmap_insert_into_set (TMP_GEN (block), lhs);\n+      bitmap_value_insert_into_set (AVAIL_OUT (block), lhs);\n+      return true;\n+    }\n+  else if ((TREE_CODE (rhs) == SSA_NAME\n+\t    && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs))\n+\t   || is_gimple_min_invariant (rhs)\n+\t   || TREE_CODE (rhs) == ADDR_EXPR\n+\t   || TREE_INVARIANT (rhs)\n+\t   || DECL_P (rhs))\n     {\n-      *expr_p = t;\n+      \n+      if (lhsval)\n+\t{\n+\t  set_value_handle (rhs, lhsval);\n+\t  if (!is_gimple_min_invariant (lhsval))\n+\t    add_to_value (lhsval, rhs);\n+\t  bitmap_insert_into_set (TMP_GEN (block), lhs);\n+\t  bitmap_value_insert_into_set (AVAIL_OUT (block), lhs);\n+\t}\n+      else\n+\t{\n+\t  /* Compute a value number for the RHS of the statement\n+\t     and add its value to the AVAIL_OUT set for the block.\n+\t     Add the LHS to TMP_GEN.  */\n+\t  add_to_sets (lhs, rhs, stmt, TMP_GEN (block),\n+\t\t       AVAIL_OUT (block));\n+\t}\n+      /* None of the rest of these can be PRE'd.  */\n+      if (TREE_CODE (rhs) == SSA_NAME && !is_undefined_value (rhs))\n+\tadd_to_exp_gen (block, rhs);\n       return true;\n     }\n   return false;\n+\n }\n \n /* Compute the AVAIL set for all basic blocks.\n@@ -3338,6 +3473,7 @@ compute_avail (void)\n   basic_block *worklist;\n   size_t sp = 0;\n   tree param;\n+\n   /* For arguments with default definitions, we pretend they are\n      defined in the entry block.  */\n   for (param = DECL_ARGUMENTS (current_function_decl);\n@@ -3348,10 +3484,12 @@ compute_avail (void)\n \t{\n \t  tree def = gimple_default_def (cfun, param);\n \n-\t  vn_lookup_or_add (def, NULL);\n-\t  bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), def);\n+\t  vn_lookup_or_add (def);\n \t  if (!in_fre)\n-\t    bitmap_value_insert_into_set (maximal_set, def);\n+\t    {\n+\t      bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), def);\n+\t      bitmap_value_insert_into_set (maximal_set, def);\n+\t    }\n \t  bitmap_value_insert_into_set (AVAIL_OUT (ENTRY_BLOCK_PTR), def);\n \t}\n     }\n@@ -3364,10 +3502,12 @@ compute_avail (void)\n \t{\n \t  tree def = gimple_default_def (cfun, param);\n \n-\t  vn_lookup_or_add (def, NULL);\n-\t  bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), def);\n-\t  if (!in_fre)\n-\t    bitmap_value_insert_into_set (maximal_set, def);\n+\t  vn_lookup_or_add (def);\n+\t  if (!in_fre) \n+\t    {\n+\t      bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), def);\n+\t      bitmap_value_insert_into_set (maximal_set, def);\n+\t    }\n \t  bitmap_value_insert_into_set (AVAIL_OUT (ENTRY_BLOCK_PTR), def);\n \t}\n     }\n@@ -3401,15 +3541,7 @@ compute_avail (void)\n \n       /* Generate values for PHI nodes.  */\n       for (phi = phi_nodes (block); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  /* We have no need for virtual phis, as they don't represent\n-\t     actual computations.  */\n-\t  if (is_gimple_reg (PHI_RESULT (phi)))\n-\t    {\n-\t      add_to_sets (PHI_RESULT (phi), PHI_RESULT (phi), NULL,\n-\t\t\t   PHI_GEN (block), AVAIL_OUT (block));\n-\t    }\n-\t}\n+\tmake_values_for_phi (phi, block);\n \n       /* Now compute value numbers and populate value sets with all\n \t the expressions computed in BLOCK.  */\n@@ -3438,11 +3570,25 @@ compute_avail (void)\n \t      stmt = TREE_OPERAND (stmt, 0);\n \t      if (stmt && TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t\t{\n-\t\t  lhs  = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t\t  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n \t\t  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n-\t\t  if (TREE_CODE (rhs) == SSA_NAME\n-\t\t      && !is_undefined_value (rhs))\n-\t\t    bitmap_value_insert_into_set (EXP_GEN (block), rhs);\n+\t\t  if (TREE_CODE (lhs) == SSA_NAME\n+\t\t      && is_gimple_min_invariant (VN_INFO (lhs)->valnum))\n+\t\t    {\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\t{\n+\t\t\t  fprintf (dump_file, \"SCCVN says \");\n+\t\t\t  print_generic_expr (dump_file, lhs, 0);\n+\t\t\t  fprintf (dump_file, \" value numbers to \");\n+\t\t\t  print_generic_stmt (dump_file, VN_INFO (lhs)->valnum,\n+\t\t\t\t\t      0);\n+\t\t\t}\n+\t\t      vn_add (lhs, VN_INFO (lhs)->valnum);\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  if (TREE_CODE (rhs) == SSA_NAME)\n+\t\t    add_to_exp_gen (block, rhs);\n \n \t\t  FOR_EACH_SSA_TREE_OPERAND (op, realstmt, iter, SSA_OP_DEF)\n \t\t    add_to_sets (op, op, NULL, TMP_GEN (block),\n@@ -3455,62 +3601,11 @@ compute_avail (void)\n \t      && !ann->has_volatile_ops\n \t      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME\n \t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI\n-\t           (GIMPLE_STMT_OPERAND (stmt, 0)))\n+\t\t   (GIMPLE_STMT_OPERAND (stmt, 0)))\n \t    {\n-\t      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n-\t      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n-\n-\t      /* Try to look through loads.  */\n-\t      if (TREE_CODE (lhs) == SSA_NAME\n-\t\t  && !ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_USES)\n-\t\t  && try_look_through_load (lhs, rhs, stmt, block))\n+\t      if (make_values_for_stmt (stmt, block))\n \t\tcontinue;\n \n-\t      STRIP_USELESS_TYPE_CONVERSION (rhs);\n-\t      if (can_value_number_operation (rhs))\n-\t\t{\n-\t\t  /* For value numberable operation, create a\n-\t\t     duplicate expression with the operands replaced\n-\t\t     with the value handles of the original RHS.  */\n-\t\t  tree newt = create_value_expr_from (rhs, block, stmt);\n-\t\t  if (newt)\n-\t\t    {\n-\t\t      /* If we can combine a conversion expression\n-\t\t\t with the expression for its operand just\n-\t\t\t record the value number for it.  */\n-\t\t      if (try_combine_conversion (&newt))\n-\t\t\tvn_add (lhs, newt);\n-\t\t      else\n-\t\t\t{\n-\t\t\t  tree val = vn_lookup_or_add (newt, stmt);\n-\t\t\t  vn_add (lhs, val);\n-\t\t\t  if (!in_fre)\n-\t\t\t    bitmap_value_insert_into_set (maximal_set, newt);\n-\t\t\t  bitmap_value_insert_into_set (EXP_GEN (block), newt);\n-\t\t\t}\n-\t\t      bitmap_insert_into_set (TMP_GEN (block), lhs);\n-\t\t      bitmap_value_insert_into_set (AVAIL_OUT (block), lhs);\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t      else if ((TREE_CODE (rhs) == SSA_NAME\n-\t\t\t&& !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs))\n-\t\t       || is_gimple_min_invariant (rhs)\n-\t\t       || TREE_CODE (rhs) == ADDR_EXPR\n-\t\t       || TREE_INVARIANT (rhs)\n-\t\t       || DECL_P (rhs))\n-\t\t{\n-\t\t  /* Compute a value number for the RHS of the statement\n-\t\t     and add its value to the AVAIL_OUT set for the block.\n-\t\t     Add the LHS to TMP_GEN.  */\n-\t\t  add_to_sets (lhs, rhs, stmt, TMP_GEN (block),\n-\t\t\t       AVAIL_OUT (block));\n-\n-\t\t  if (TREE_CODE (rhs) == SSA_NAME\n-\t\t      && !is_undefined_value (rhs))\n-\t\t    bitmap_value_insert_into_set (EXP_GEN (block), rhs);\n-\t\t  continue;\n-\t\t}\n \t    }\n \n \t  /* For any other statement that we don't recognize, simply\n@@ -3520,7 +3615,11 @@ compute_avail (void)\n \t    add_to_sets (op, op, NULL, TMP_GEN (block), AVAIL_OUT (block));\n \n \t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n-\t    add_to_sets (op, op, NULL, NULL , AVAIL_OUT (block));\n+\t    {\n+\t      add_to_sets (op, op, NULL, NULL , AVAIL_OUT (block));\n+\t      if (TREE_CODE (op) == SSA_NAME || can_PRE_operation (op))\n+\t\tadd_to_exp_gen (block, op);\n+\t    }\n \t}\n \n       /* Put the dominator children of BLOCK on the worklist of blocks\n@@ -3564,7 +3663,8 @@ eliminate (void)\n \t      tree sprime;\n \n \t      sprime = bitmap_find_leader (AVAIL_OUT (b),\n-\t\t\t\t\t   vn_lookup (lhs, NULL));\n+\t\t\t\t\t   get_value_handle (lhs));\n+\t      \n \t      if (sprime\n \t\t  && sprime != lhs\n \t\t  && (TREE_CODE (*rhs_p) != SSA_NAME\n@@ -3684,14 +3784,14 @@ remove_dead_inserted_code (void)\n       else\n \t{\n \t  /* Propagate through the operands.  Examine all the USE, VUSE and\n-\t     VDEF operands in this statement.  Mark all the statements \n+\t     VDEF operands in this statement.  Mark all the statements\n \t     which feed this statement's uses as necessary.  */\n \t  ssa_op_iter iter;\n \t  tree use;\n \n \t  /* The operands of VDEF expressions are also needed as they\n \t     represent potential definitions that may reach this\n-\t     statement (VDEF operands allow us to follow def-def \n+\t     statement (VDEF operands allow us to follow def-def\n \t     links).  */\n \n \t  FOR_EACH_SSA_TREE_OPERAND (use, t, iter, SSA_OP_ALL_USES)\n@@ -3736,7 +3836,7 @@ static void\n init_pre (bool do_fre)\n {\n   basic_block bb;\n-\n+  \n   next_expression_id = 0;\n   expressions = NULL;\n   in_fre = do_fre;\n@@ -3747,7 +3847,6 @@ init_pre (bool do_fre)\n   storetemp = NULL_TREE;\n   prephitemp = NULL_TREE;\n \n-  vn_init ();\n   if (!do_fre)\n     loop_optimizer_init (LOOPS_NORMAL);\n \n@@ -3767,6 +3866,7 @@ init_pre (bool do_fre)\n   bitmap_obstack_initialize (&grand_bitmap_obstack);\n   phi_translate_table = htab_create (5110, expr_pred_trans_hash,\n \t\t\t\t     expr_pred_trans_eq, free);\n+  seen_during_translate = BITMAP_ALLOC (&grand_bitmap_obstack);\n   bitmap_set_pool = create_alloc_pool (\"Bitmap sets\",\n \t\t\t\t       sizeof (struct bitmap_set), 30);\n   binary_node_pool = create_alloc_pool (\"Binary tree nodes\",\n@@ -3779,7 +3879,7 @@ init_pre (bool do_fre)\n \t\t\t\t\t    tree_code_size (EQ_EXPR), 30);\n   modify_expr_node_pool = create_alloc_pool (\"GIMPLE_MODIFY_STMT nodes\",\n \t\t\t\t\t     tree_code_size (GIMPLE_MODIFY_STMT),\n-  \t\t\t\t\t     30);\n+\t\t\t\t\t     30);\n   obstack_init (&temp_call_expr_obstack);\n   modify_expr_template = NULL;\n \n@@ -3824,7 +3924,6 @@ fini_pre (void)\n     }\n \n   free_dominance_info (CDI_POST_DOMINATORS);\n-  vn_delete ();\n \n   if (!bitmap_empty_p (need_eh_cleanup))\n     {\n@@ -3865,6 +3964,8 @@ execute_pre (bool do_fre)\n     insert_fake_stores ();\n \n   /* Collect and value number expressions computed in each basic block.  */\n+  run_scc_vn ();\n+  switch_to_PRE_table ();\n   compute_avail ();\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3906,6 +4007,7 @@ execute_pre (bool do_fre)\n     }\n   bsi_commit_edge_inserts ();\n \n+  free_scc_vn ();\n   clear_expression_ids ();\n   if (!do_fre)\n     {"}, {"sha": "89e399508e9bb349477606564f99241cdc654c4d", "filename": "gcc/tree-ssa-sccvn.c", "status": "added", "additions": 2043, "deletions": 0, "changes": 2043, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -0,0 +1,2043 @@\n+/* SCC value numbering for trees\n+   Copyright (C) 2006\n+   Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin <dan@dberlin.org>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-inline.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-gimple.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"fibheap.h\"\n+#include \"hashtab.h\"\n+#include \"tree-iterator.h\"\n+#include \"real.h\"\n+#include \"alloc-pool.h\"\n+#include \"tree-pass.h\"\n+#include \"flags.h\"\n+#include \"bitmap.h\"\n+#include \"langhooks.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-ssa-sccvn.h\"\n+\n+/* This algorithm is based on the SCC algorithm presented by Keith\n+   Cooper and L. Taylor Simpson in \"SCC-Based Value numbering\"\n+   (http://citeseer.ist.psu.edu/41805.html).  In\n+   straight line code, it is equivalent to a regular hash based value\n+   numbering that is performed in reverse postorder.\n+\n+   For code with cycles, there are two alternatives, both of which\n+   require keeping the hashtables separate from the actual list of\n+   value numbers for SSA names.\n+\n+   1. Iterate value numbering in an RPO walk of the blocks, removing\n+   all the entries from the hashtable after each iteration (but\n+   keeping the SSA name->value number mapping between iterations).\n+   Iterate until it does not change.\n+\n+   2. Perform value numbering as part of an SCC walk on the SSA graph,\n+   iterating only the cycles in the SSA graph until they do not change\n+   (using a separate, optimistic hashtable for value numbering the SCC\n+   operands).\n+\n+   The second is not just faster in practice (because most SSA graph\n+   cycles do not involve all the variables in the graph), it also has\n+   some nice properties.\n+\n+   One of these nice properties is that when we pop an SCC off the\n+   stack, we are guaranteed to have processed all the operands coming from\n+   *outside of that SCC*, so we do not need to do anything special to\n+   ensure they have value numbers.\n+\n+   Another nice property is that the SCC walk is done as part of a DFS\n+   of the SSA graph, which makes it easy to perform combining and\n+   simplifying operations at the same time.\n+\n+   The code below is deliberately written in a way that makes it easy\n+   to separate the SCC walk from the other work it does.\n+\n+   In order to propagate constants through the code, we track which\n+   expressions contain constants, and use those while folding.  In\n+   theory, we could also track expressions whose value numbers are\n+   replaced, in case we end up folding based on expression\n+   identities.\n+\n+   In order to value number memory, we assign value numbers to vuses.\n+   This enables us to note that, for example, stores to the same\n+   address of the same value from the same starting memory states are\n+   equivalent.  \n+   TODO:\n+\n+   1. We can iterate only the changing portions of the SCC's, but\n+   I have not seen an SCC big enough for this to be a win.\n+   2. If you differentiate between phi nodes for loops and phi nodes\n+   for if-then-else, you can properly consider phi nodes in different\n+   blocks for equivalence.\n+   3. We could value number vuses in more cases, particularly, whole\n+   structure copies.\n+*/\n+\n+/* The set of hashtables and alloc_pool's for their items.  */\n+\n+typedef struct vn_tables_s\n+{\n+  htab_t unary;\n+  htab_t binary;\n+  htab_t phis;\n+  htab_t references;\n+  alloc_pool unary_op_pool;\n+  alloc_pool binary_op_pool;\n+  alloc_pool phis_pool;\n+  alloc_pool references_pool;\n+} *vn_tables_t;\n+\n+/* Binary operations in the hashtable consist of two operands, an\n+   opcode, and a type.  Result is the value number of the operation,\n+   and hashcode is stored to avoid having to calculate it\n+   repeatedly.  */\n+\n+typedef struct vn_binary_op_s\n+{\n+  enum tree_code opcode;\n+  tree type;\n+  tree op0;\n+  tree op1;\n+  hashval_t hashcode;\n+  tree result;\n+} *vn_binary_op_t;\n+\n+/* Unary operations in the hashtable consist of a single operand, an\n+   opcode, and a type.  Result is the value number of the operation,\n+   and hashcode is stored to avoid having to calculate it repeatedly. */\n+\n+typedef struct vn_unary_op_s\n+{\n+  enum tree_code opcode;\n+  tree type;\n+  tree op0;\n+  hashval_t hashcode;\n+  tree result;\n+} *vn_unary_op_t;\n+\n+/* Phi nodes in the hashtable consist of their non-VN_TOP phi\n+   arguments, and the basic block the phi is in. Result is the value\n+   number of the operation, and hashcode is stored to avoid having to\n+   calculate it repeatedly.  Phi nodes not in the same block are never\n+   considered equivalent.  */\n+\n+typedef struct vn_phi_s\n+{\n+  VEC (tree, heap) *phiargs;\n+  basic_block block;\n+  hashval_t hashcode;\n+  tree result;\n+} *vn_phi_t;\n+\n+/* Reference operands only exist in reference operations structures.\n+   They consist of an opcode, type, and some number of operands.  For\n+   a given opcode, some, all, or none of the operands may be used.\n+   The operands are there to store the information that makes up the\n+   portion of the addressing calculation that opcode performs.  */\n+\n+typedef struct vn_reference_op_struct\n+{\n+  enum tree_code opcode;\n+  tree type;\n+  tree op0;\n+  tree op1;\n+  tree op2;\n+} vn_reference_op_s;\n+typedef vn_reference_op_s *vn_reference_op_t;\n+\n+DEF_VEC_O(vn_reference_op_s);\n+DEF_VEC_ALLOC_O(vn_reference_op_s, heap);\n+\n+/* A reference operation in the hashtable is representation as a\n+   collection of vuses, representing the memory state at the time of\n+   the operation, and a collection of operands that make up the\n+   addressing calculation.  If two vn_reference_t's have the same set\n+   of operands, they access the same memory location. We also store\n+   the resulting value number, and the hashcode.  The vuses are\n+   always stored in order sorted by ssa name version.  */\n+\n+typedef struct vn_reference_s\n+{\n+  VEC (tree, gc) *vuses;\n+  VEC (vn_reference_op_s, heap) *operands;\n+  hashval_t hashcode;\n+  tree result;\n+} *vn_reference_t;\n+\n+/* Valid hashtables storing information we have proven to be\n+   correct.  */\n+\n+static vn_tables_t valid_info;\n+\n+/* Optimistic hashtables storing information we are making assumptions about\n+   during iterations.  */\n+\n+static vn_tables_t optimistic_info;\n+\n+/* PRE hashtables storing information about mapping from expressions to\n+   value handles.  */\n+\n+static vn_tables_t pre_info;\n+\n+/* Pointer to the set of hashtables that is currently being used.\n+   Should always point to either the optimistic_info, or the\n+   valid_info.  */\n+\n+static vn_tables_t current_info;\n+\n+\n+/* Reverse post order index for each basic block.  */\n+\n+static int *rpo_numbers;\n+\n+#define SSA_VAL(x) (VN_INFO ((x))->valnum)\n+\n+/* This represents the top of the VN lattice, which is the universal\n+   value.  */\n+\n+tree VN_TOP;\n+\n+/* Next DFS number and the stack for strongly connected component\n+   detection. */\n+\n+static unsigned int next_dfs_num;\n+static VEC (tree, heap) *sccstack;\n+\n+DEF_VEC_P(vn_ssa_aux_t);\n+DEF_VEC_ALLOC_P(vn_ssa_aux_t, heap);\n+\n+/* Table of vn_ssa_aux_t's, one per ssa_name.  */\n+\n+static VEC (vn_ssa_aux_t, heap) *vn_ssa_aux_table;\n+\n+/* Return the value numbering information for a given SSA name.  */\n+\n+vn_ssa_aux_t\n+VN_INFO (tree name)\n+{\n+  return VEC_index (vn_ssa_aux_t, vn_ssa_aux_table,\n+\t\t    SSA_NAME_VERSION (name));\n+}\n+\n+/* Set the value numbering info for a given SSA name to a given\n+   value.  */\n+\n+static inline void\n+VN_INFO_SET (tree name, vn_ssa_aux_t value)\n+{\n+  VEC_replace (vn_ssa_aux_t, vn_ssa_aux_table,\n+\t       SSA_NAME_VERSION (name), value);\n+}\n+\n+/* Get the value numbering info for a given SSA name, creating it if\n+   it does not exist.  */ \n+\n+vn_ssa_aux_t\n+VN_INFO_GET (tree name)\n+{\n+  vn_ssa_aux_t newinfo = XCNEW (struct vn_ssa_aux);\n+  if (SSA_NAME_VERSION (name) >= VEC_length (vn_ssa_aux_t, vn_ssa_aux_table))\n+    VEC_safe_grow (vn_ssa_aux_t, heap, vn_ssa_aux_table,\n+\t\t   SSA_NAME_VERSION (name) + 1);\n+  VEC_replace (vn_ssa_aux_t, vn_ssa_aux_table,\n+\t       SSA_NAME_VERSION (name), newinfo);\n+  return newinfo;\n+}\n+\n+\n+/* Compare two reference operands P1 and P2 for equality.  return true if\n+   they are equal, and false otherwise.  */\n+\n+static int\n+vn_reference_op_eq (const void *p1, const void *p2)\n+{\n+  const vn_reference_op_t vro1 = (vn_reference_op_t) p1;\n+  const vn_reference_op_t vro2 = (vn_reference_op_t) p2;\n+  return vro1->opcode == vro2->opcode\n+    && vro1->type == vro2->type\n+    && expressions_equal_p (vro1->op0, vro2->op0)\n+    && expressions_equal_p (vro1->op1, vro2->op1)\n+    && expressions_equal_p (vro1->op2, vro2->op2);\n+}\n+\n+/* Compute the hash for a reference operand VRO1  */\n+\n+static hashval_t\n+vn_reference_op_compute_hash (const vn_reference_op_t vro1)\n+{\n+  return iterative_hash_expr (vro1->op0, vro1->opcode)\n+    + iterative_hash_expr (vro1->op1, vro1->opcode)\n+    + iterative_hash_expr (vro1->op2, vro1->opcode);\n+}\n+\n+/* Return the hashcode for a given reference operation P1.  */\n+\n+static hashval_t\n+vn_reference_hash (const void *p1)\n+{\n+  const vn_reference_t vr1 = (vn_reference_t) p1;\n+  return vr1->hashcode;\n+}\n+\n+/* Compute a hash for the reference operation VR1 and return it.  */\n+\n+static inline hashval_t\n+vn_reference_compute_hash (const vn_reference_t vr1)\n+{\n+  hashval_t result = 0;\n+  tree v;\n+  int i;\n+  vn_reference_op_t vro;\n+\n+  for (i = 0; VEC_iterate (tree, vr1->vuses, i, v); i++)\n+    result += iterative_hash_expr (v, 0);\n+  for (i = 0; VEC_iterate (vn_reference_op_s, vr1->operands, i, vro); i++)\n+    result += vn_reference_op_compute_hash (vro);\n+\n+  return result;\n+}\n+\n+/* Return true if reference operations P1 and P2 are equivalent.  This\n+   means they have the same set of operands and vuses.  */\n+\n+static int\n+vn_reference_eq (const void *p1, const void *p2)\n+{\n+  tree v;\n+  int i;\n+  vn_reference_op_t vro;\n+\n+  const vn_reference_t vr1 = (vn_reference_t) p1;\n+  const vn_reference_t vr2 = (vn_reference_t) p2;\n+\n+  if (vr1->vuses == vr2->vuses\n+      && vr1->operands == vr2->operands)\n+    return true;\n+\n+  /* Impossible for them to be equivalent if they have different\n+     number of vuses.  */\n+  if (VEC_length (tree, vr1->vuses) != VEC_length (tree, vr2->vuses))\n+    return false;\n+\n+  /* We require that address operands be canonicalized in a way that\n+     two memory references will have the same operands if they are\n+     equivalent.  */\n+  if (VEC_length (vn_reference_op_s, vr1->operands)\n+      != VEC_length (vn_reference_op_s, vr2->operands))\n+    return false;\n+\n+  /* The memory state is more often different than the address of the\n+     store/load, so check it first.  */\n+  for (i = 0; VEC_iterate (tree, vr1->vuses, i, v); i++)\n+    {\n+      if (VEC_index (tree, vr2->vuses, i) != v)\n+\treturn false;\n+    }\n+  \n+  for (i = 0; VEC_iterate (vn_reference_op_s, vr1->operands, i, vro); i++)\n+    {\n+      if (!vn_reference_op_eq (VEC_index (vn_reference_op_s, vr2->operands, i),\n+\t\t\t       vro))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Place the vuses from STMT into *result */\n+\n+static inline void\n+vuses_to_vec (tree stmt, VEC (tree, gc) **result)\n+{\n+  ssa_op_iter iter;\n+  tree vuse;\n+\n+  if (!stmt)\n+    return;\n+\n+  FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, iter, SSA_OP_VIRTUAL_USES)\n+    VEC_safe_push (tree, gc, *result, vuse);\n+\n+  if (VEC_length (tree, *result) > 1)\n+    sort_vuses (*result);\n+}\n+\n+\n+/* Copy the VUSE names in STMT into a vector, and return\n+   the vector.  */\n+\n+VEC (tree, gc) *\n+copy_vuses_from_stmt (tree stmt)\n+{\n+  VEC (tree, gc) *vuses = NULL;\n+\n+  vuses_to_vec (stmt, &vuses);\n+\n+  return vuses;\n+}\n+\n+/* Place the vdefs from STMT into *result */\n+\n+static inline void\n+vdefs_to_vec (tree stmt, VEC (tree, gc) **result)\n+{\n+  ssa_op_iter iter;\n+  tree vdef;\n+\n+  if (!stmt)\n+    return;\n+\n+  FOR_EACH_SSA_TREE_OPERAND (vdef, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n+    VEC_safe_push (tree, gc, *result, vdef);\n+\n+  if (VEC_length (tree, *result) > 1)\n+    sort_vuses (*result);\n+}\n+\n+/* Copy the names of vdef results in STMT into a vector, and return\n+   the vector.  */\n+\n+static VEC (tree, gc) *\n+copy_vdefs_from_stmt (tree stmt)\n+{\n+  VEC (tree, gc) *vdefs = NULL;\n+\n+  vdefs_to_vec (stmt, &vdefs);\n+\n+  return vdefs;\n+}\n+\n+/* Place for shared_v{uses/defs}_from_stmt to shove vuses/vdefs.  */\n+static VEC (tree, gc) *shared_lookup_vops;\n+\n+/* Copy the virtual uses from STMT into SHARED_LOOKUP_VOPS.\n+   This function will overwrite the current SHARED_LOOKUP_VOPS\n+   variable.  */\n+\n+VEC (tree, gc) *\n+shared_vuses_from_stmt (tree stmt)\n+{\n+  VEC_truncate (tree, shared_lookup_vops, 0);\n+  vuses_to_vec (stmt, &shared_lookup_vops);\n+\n+  return shared_lookup_vops;\n+}\n+\n+/* Copy the operations present in load/store/call REF into RESULT, a vector of\n+   vn_reference_op_s's.  */\n+\n+static void\n+copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n+{\n+  /* Calls are different from all other reference operations.  */\n+  if (TREE_CODE (ref) == CALL_EXPR)\n+    {\n+      vn_reference_op_s temp;\n+      tree callfn;\n+      call_expr_arg_iterator iter;\n+      tree callarg;\n+\n+      /* Copy the call_expr opcode, type, function being called, and\n+\t arguments.  */\n+      memset (&temp, 0, sizeof (temp));\n+      temp.type = TREE_TYPE (ref);\n+      temp.opcode = CALL_EXPR;\n+      VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+\n+      callfn = get_callee_fndecl (ref);\n+      if (!callfn)\n+\tcallfn = CALL_EXPR_FN (ref);\n+      temp.type = TREE_TYPE (callfn);\n+      temp.opcode = TREE_CODE (callfn);\n+      temp.op0 = callfn;\n+      VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+\n+      FOR_EACH_CALL_EXPR_ARG (callarg, iter, ref)\n+\t{\n+\t  memset (&temp, 0, sizeof (temp));\n+\t  temp.type = TREE_TYPE (callarg);\n+\t  temp.opcode = TREE_CODE (callarg);\n+\t  temp.op0 = callarg;\n+\t  VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+\t}\n+      return;\n+    }\n+\n+  /* For non-calls, store the information that makes up the address.  */\n+\n+  while (ref)\n+    {\n+      vn_reference_op_s temp;\n+\n+      memset (&temp, 0, sizeof (temp));\n+      temp.type = TREE_TYPE (ref);\n+      temp.opcode = TREE_CODE (ref);\n+\n+      switch (temp.opcode)\n+\t{\n+\tcase ALIGN_INDIRECT_REF:\n+\tcase MISALIGNED_INDIRECT_REF:\n+\tcase INDIRECT_REF:\n+\t  /* The only operand is the address, which gets its own\n+\t     vn_reference_op_s structure.  */\n+\t  break;\n+\tcase BIT_FIELD_REF:\n+\t  /* Record bits and position.  */\n+\t  temp.op0 = TREE_OPERAND (ref, 1);\n+\t  temp.op1 = TREE_OPERAND (ref, 2);\n+\t  break;\n+\tcase COMPONENT_REF:\n+\t  /* Record field as operand.  */\n+\t  temp.op0 = TREE_OPERAND (ref, 1);\n+\t  break;\n+\tcase ARRAY_RANGE_REF:\n+\tcase ARRAY_REF:\n+\t  /* Record index as operand.  */\n+\t  temp.op0 = TREE_OPERAND (ref, 1);\n+\t  temp.op1 = TREE_OPERAND (ref, 3);\n+\t  break;\n+\tcase VALUE_HANDLE:\n+\tcase VAR_DECL:\n+\tcase PARM_DECL:\n+\tcase CONST_DECL:\n+\tcase RESULT_DECL:\n+\tcase SSA_NAME:\n+\t  temp.op0 = ref;\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+\n+      if (REFERENCE_CLASS_P (ref))\n+\tref = TREE_OPERAND (ref, 0);\n+      else\n+\tref = NULL_TREE;\n+    }\n+}\n+\n+/* Create a vector of vn_reference_op_s structures from REF, a\n+   REFERENCE_CLASS_P tree.  The vector is not shared. */\n+\n+static VEC(vn_reference_op_s, heap) *\n+create_reference_ops_from_ref (tree ref)\n+{\n+  VEC (vn_reference_op_s, heap) *result = NULL;\n+\n+  copy_reference_ops_from_ref (ref, &result);\n+  return result;\n+}\n+\n+static VEC(vn_reference_op_s, heap) *shared_lookup_references;\n+\n+/* Create a vector of vn_reference_op_s structures from REF, a\n+   REFERENCE_CLASS_P tree.  The vector is shared among all callers of\n+   this function.  */\n+\n+static VEC(vn_reference_op_s, heap) *\n+shared_reference_ops_from_ref (tree ref)\n+{\n+  if (!ref)\n+    return NULL;\n+  VEC_truncate (vn_reference_op_s, shared_lookup_references, 0);\n+  copy_reference_ops_from_ref (ref, &shared_lookup_references);\n+  return shared_lookup_references;\n+}\n+\n+\n+/* Transform any SSA_NAME's in a vector of vn_reference_op_s\n+   structures into their value numbers.  This is done in-place, and\n+   the vector passed in is returned.  */\n+\n+static VEC (vn_reference_op_s, heap) *\n+valueize_refs (VEC (vn_reference_op_s, heap) *orig)\n+{\n+  vn_reference_op_t vro;\n+  int i;\n+\n+  for (i = 0; VEC_iterate (vn_reference_op_s, orig, i, vro); i++)\n+    {\n+      if (vro->opcode == SSA_NAME\n+\t  || (vro->op0 && TREE_CODE (vro->op0) == SSA_NAME))\n+\tvro->op0 = SSA_VAL (vro->op0);\n+    }\n+\n+  return orig;\n+}\n+\n+/* Transform any SSA_NAME's in ORIG, a vector of vuse trees, into\n+   their value numbers. This is done in-place, and the vector passed\n+   in is returned.  */\n+\n+static VEC (tree, gc) *\n+valueize_vuses (VEC (tree, gc) *orig)\n+{\n+  bool made_replacement = false;\n+  tree vuse;\n+  int i;\n+\n+  for (i = 0; VEC_iterate (tree, orig, i, vuse); i++)\n+    {\n+      if (vuse != SSA_VAL (vuse))\n+\t{\n+\t  made_replacement = true;\n+\t  VEC_replace (tree, orig, i, SSA_VAL (vuse));\n+\t}\n+    }\n+\n+  if (made_replacement && VEC_length (tree, orig) > 1)\n+    sort_vuses (orig);\n+\n+  return orig;\n+}\n+\n+/* Lookup OP in the current hash table, and return the resulting\n+   value number if it exists in the hash table.  Return NULL_TREE if\n+   it does not exist in the hash table. */\n+\n+tree\n+vn_reference_lookup (tree op, VEC (tree, gc) *vuses)\n+{\n+  void **slot;\n+  struct vn_reference_s vr1;\n+\n+  vr1.vuses = valueize_vuses (vuses);\n+  vr1.operands = valueize_refs (shared_reference_ops_from_ref (op));\n+  vr1.hashcode = vn_reference_compute_hash (&vr1);\n+  slot = htab_find_slot_with_hash (current_info->references, &vr1, vr1.hashcode,\n+\t\t\t\t   NO_INSERT);\n+  if (!slot)\n+    return NULL_TREE;\n+\n+  return ((vn_reference_t)*slot)->result;\n+}\n+\n+/* Insert OP into the current hash table with a value number of\n+   RESULT.  */\n+\n+void\n+vn_reference_insert (tree op, tree result, VEC (tree, gc) *vuses)\n+{\n+  void **slot;\n+  vn_reference_t vr1;\n+\n+  vr1 = (vn_reference_t) pool_alloc (current_info->references_pool);\n+\n+  vr1->vuses = valueize_vuses (vuses);\n+  vr1->operands = valueize_refs (create_reference_ops_from_ref (op));\n+  vr1->hashcode = vn_reference_compute_hash (vr1);\n+  vr1->result = TREE_CODE (result) == SSA_NAME ? SSA_VAL (result) : result;\n+\n+  slot = htab_find_slot_with_hash (current_info->references, vr1, vr1->hashcode,\n+\t\t\t\t   INSERT);\n+\n+  /* Because we lookup stores using vuses, and value number failures\n+     using the vdefs (see visit_reference_op_store for how and why),\n+     it's possible that on failure we may try to insert an already\n+     inserted store.  This is not wrong, there is no ssa name for a\n+     store that we could use as a differentiator anyway.  Thus, unlike\n+     the other lookup functions, you cannot gcc_assert (!*slot)\n+     here.  */\n+\n+\n+  *slot = vr1;\n+}\n+\n+\n+/* Return the stored hashcode for a unary operation.  */\n+\n+static hashval_t\n+vn_unary_op_hash (const void *p1)\n+{\n+  const vn_unary_op_t vuo1 = (vn_unary_op_t) p1;\n+  return vuo1->hashcode;\n+}\n+\n+/* Hash a unary operation P1 and return the result.  */\n+\n+static inline hashval_t\n+vn_unary_op_compute_hash (const vn_unary_op_t vuo1)\n+{\n+  return iterative_hash_expr (vuo1->op0, vuo1->opcode);\n+}\n+\n+/* Return true if P1 and P2, two unary operations, are equivalent.  */\n+\n+static int\n+vn_unary_op_eq (const void *p1, const void *p2)\n+{\n+  const vn_unary_op_t vuo1 = (vn_unary_op_t) p1;\n+  const vn_unary_op_t vuo2 = (vn_unary_op_t) p2;\n+  return vuo1->opcode == vuo2->opcode\n+    && vuo1->type == vuo2->type\n+    && expressions_equal_p (vuo1->op0, vuo2->op0);\n+}\n+\n+/* Lookup OP in the current hash table, and return the resulting\n+   value number if it exists in the hash table.  Return NULL_TREE if\n+   it does not exist in the hash table. */\n+\n+tree\n+vn_unary_op_lookup (tree op)\n+{\n+  void **slot;\n+  struct vn_unary_op_s vuo1;\n+\n+  vuo1.opcode = TREE_CODE (op);\n+  vuo1.type = TREE_TYPE (op);\n+  vuo1.op0 = TREE_OPERAND (op, 0);\n+\n+  if (TREE_CODE (vuo1.op0) == SSA_NAME)\n+    vuo1.op0 = SSA_VAL (vuo1.op0);\n+\n+  vuo1.hashcode = vn_unary_op_compute_hash (&vuo1);\n+  slot = htab_find_slot_with_hash (current_info->unary, &vuo1, vuo1.hashcode,\n+\t\t\t\t   NO_INSERT);\n+  if (!slot)\n+    return NULL_TREE;\n+  return ((vn_unary_op_t)*slot)->result;\n+}\n+\n+/* Insert OP into the current hash table with a value number of\n+   RESULT.  */\n+\n+void\n+vn_unary_op_insert (tree op, tree result)\n+{\n+  void **slot;\n+  vn_unary_op_t vuo1 = (vn_unary_op_t) pool_alloc (current_info->unary_op_pool);\n+\n+  vuo1->opcode = TREE_CODE (op);\n+  vuo1->type = TREE_TYPE (op);\n+  vuo1->op0 = TREE_OPERAND (op, 0);\n+  vuo1->result = result;\n+\n+  if (TREE_CODE (vuo1->op0) == SSA_NAME)\n+    vuo1->op0 = SSA_VAL (vuo1->op0);\n+\n+  vuo1->hashcode = vn_unary_op_compute_hash (vuo1);\n+  slot = htab_find_slot_with_hash (current_info->unary, vuo1, vuo1->hashcode,\n+\t\t\t\t   INSERT);\n+  gcc_assert (!*slot);\n+  *slot = vuo1;\n+}\n+\n+/* Compute and return the hash value for binary operation VBO1.  */\n+\n+static inline hashval_t\n+vn_binary_op_compute_hash (const vn_binary_op_t vbo1)\n+{\n+  return iterative_hash_expr (vbo1->op0, vbo1->opcode)\n+    + iterative_hash_expr (vbo1->op1, vbo1->opcode);\n+}\n+\n+/* Return the computed hashcode for binary operation P1.  */\n+\n+static hashval_t\n+vn_binary_op_hash (const void *p1)\n+{\n+  const vn_binary_op_t vbo1 = (vn_binary_op_t) p1;\n+  return vbo1->hashcode;\n+}\n+\n+/* Compare binary operations P1 and P2 and return true if they are\n+   equivalent.  */\n+\n+static int\n+vn_binary_op_eq (const void *p1, const void *p2)\n+{\n+  const vn_binary_op_t vbo1 = (vn_binary_op_t) p1;\n+  const vn_binary_op_t vbo2 = (vn_binary_op_t) p2;\n+  return vbo1->opcode == vbo2->opcode\n+    && vbo1->type == vbo2->type\n+    && expressions_equal_p (vbo1->op0, vbo2->op0)\n+    && expressions_equal_p (vbo1->op1, vbo2->op1);\n+}\n+\n+/* Lookup OP in the current hash table, and return the resulting\n+   value number if it exists in the hash table.  Return NULL_TREE if\n+   it does not exist in the hash table. */\n+\n+tree\n+vn_binary_op_lookup (tree op)\n+{\n+  void **slot;\n+  struct vn_binary_op_s vbo1;\n+\n+  vbo1.opcode = TREE_CODE (op);\n+  vbo1.type = TREE_TYPE (op);\n+  vbo1.op0 = TREE_OPERAND (op, 0);\n+  vbo1.op1 = TREE_OPERAND (op, 1);\n+\n+  if (TREE_CODE (vbo1.op0) == SSA_NAME)\n+    vbo1.op0 = SSA_VAL (vbo1.op0);\n+  if (TREE_CODE (vbo1.op1) == SSA_NAME)\n+    vbo1.op1 = SSA_VAL (vbo1.op1);\n+\n+  if (tree_swap_operands_p (vbo1.op0, vbo1.op1, false)\n+      && commutative_tree_code (vbo1.opcode))\n+    {\n+      tree temp = vbo1.op0;\n+      vbo1.op0 = vbo1.op1;\n+      vbo1.op1 = temp;\n+    }\n+\n+  vbo1.hashcode = vn_binary_op_compute_hash (&vbo1);\n+  slot = htab_find_slot_with_hash (current_info->binary, &vbo1, vbo1.hashcode,\n+\t\t\t\t   NO_INSERT);\n+  if (!slot)\n+    return NULL_TREE;\n+  return ((vn_binary_op_t)*slot)->result;\n+}\n+\n+/* Insert OP into the current hash table with a value number of\n+   RESULT.  */\n+\n+void\n+vn_binary_op_insert (tree op, tree result)\n+{\n+  void **slot;\n+  vn_binary_op_t vbo1;\n+  vbo1 = (vn_binary_op_t) pool_alloc (current_info->binary_op_pool);\n+\n+  vbo1->opcode = TREE_CODE (op);\n+  vbo1->type = TREE_TYPE (op);\n+  vbo1->op0 = TREE_OPERAND (op, 0);\n+  vbo1->op1 = TREE_OPERAND (op, 1);\n+  vbo1->result = result;\n+\n+  if (TREE_CODE (vbo1->op0) == SSA_NAME)\n+    vbo1->op0 = SSA_VAL (vbo1->op0);\n+  if (TREE_CODE (vbo1->op1) == SSA_NAME)\n+    vbo1->op1 = SSA_VAL (vbo1->op1);\n+\n+  if (tree_swap_operands_p (vbo1->op0, vbo1->op1, false)\n+      && commutative_tree_code (vbo1->opcode))\n+    {\n+      tree temp = vbo1->op0;\n+      vbo1->op0 = vbo1->op1;\n+      vbo1->op1 = temp;\n+    }\n+  vbo1->hashcode = vn_binary_op_compute_hash (vbo1);\n+  slot = htab_find_slot_with_hash (current_info->binary, vbo1, vbo1->hashcode,\n+\t\t\t\t   INSERT);\n+  gcc_assert (!*slot);\n+\n+  *slot = vbo1;\n+}\n+\n+/* Compute a hashcode for PHI operation VP1 and return it.  */\n+\n+static inline hashval_t\n+vn_phi_compute_hash (vn_phi_t vp1)\n+{\n+  hashval_t result = 0;\n+  int i;\n+  tree phi1op;\n+\n+  result = vp1->block->index;\n+\n+  for (i = 0; VEC_iterate (tree, vp1->phiargs, i, phi1op); i++)\n+    {\n+      if (phi1op == VN_TOP)\n+\tcontinue;\n+      result += iterative_hash_expr (phi1op, result);\n+    }\n+\n+  return result;\n+}\n+\n+/* Return the computed hashcode for phi operation P1.  */\n+\n+static hashval_t\n+vn_phi_hash (const void *p1)\n+{\n+  const vn_phi_t vp1 = (vn_phi_t) p1;\n+  return vp1->hashcode;\n+}\n+\n+/* Compare two phi entries for equality, ignoring VN_TOP arguments.  */\n+\n+static int\n+vn_phi_eq (const void *p1, const void *p2)\n+{\n+  const vn_phi_t vp1 = (vn_phi_t) p1;\n+  const vn_phi_t vp2 = (vn_phi_t) p2;\n+\n+  if (vp1->block == vp2->block)\n+    {\n+      int i;\n+      tree phi1op;\n+\n+      /* Any phi in the same block will have it's arguments in the\n+\t same edge order, because of how we store phi nodes.  */\n+      for (i = 0; VEC_iterate (tree, vp1->phiargs, i, phi1op); i++)\n+\t{\n+\t  tree phi2op = VEC_index (tree, vp2->phiargs, i);\n+\t  if (phi1op == VN_TOP || phi2op == VN_TOP)\n+\t    continue;\n+\t  if (!expressions_equal_p (phi1op, phi2op))\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+  return false;\n+}\n+\n+static VEC(tree, heap) *shared_lookup_phiargs;\n+\n+/* Lookup PHI in the current hash table, and return the resulting\n+   value number if it exists in the hash table.  Return NULL_TREE if\n+   it does not exist in the hash table. */\n+\n+static tree\n+vn_phi_lookup (tree phi)\n+{\n+  void **slot;\n+  struct vn_phi_s vp1;\n+  int i;\n+\n+  VEC_truncate (tree, shared_lookup_phiargs, 0);\n+\n+  /* Canonicalize the SSA_NAME's to their value number.  */\n+  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+    {\n+      tree def = PHI_ARG_DEF (phi, i);\n+      def = TREE_CODE (def) == SSA_NAME ? SSA_VAL (def) : def;\n+      VEC_safe_push (tree, heap, shared_lookup_phiargs, def);\n+    }\n+  vp1.phiargs = shared_lookup_phiargs;\n+  vp1.block = bb_for_stmt (phi);\n+  vp1.hashcode = vn_phi_compute_hash (&vp1);\n+  slot = htab_find_slot_with_hash (current_info->phis, &vp1, vp1.hashcode,\n+\t\t\t\t   NO_INSERT);\n+  if (!slot)\n+    return NULL_TREE;\n+  return ((vn_phi_t)*slot)->result;\n+}\n+\n+/* Insert PHI into the current hash table with a value number of\n+   RESULT.  */\n+\n+static void\n+vn_phi_insert (tree phi, tree result)\n+{\n+  void **slot;\n+  vn_phi_t vp1 = (vn_phi_t) pool_alloc (current_info->phis_pool);\n+  int i;\n+  VEC (tree, heap) *args = NULL;\n+\n+  /* Canonicalize the SSA_NAME's to their value number.  */\n+  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+    {\n+      tree def = PHI_ARG_DEF (phi, i);\n+      def = TREE_CODE (def) == SSA_NAME ? SSA_VAL (def) : def;\n+      VEC_safe_push (tree, heap, args, def);\n+    }\n+  vp1->phiargs = args;\n+  vp1->block = bb_for_stmt (phi);\n+  vp1->result = result;\n+  vp1->hashcode = vn_phi_compute_hash (vp1);\n+\n+  slot = htab_find_slot_with_hash (current_info->phis, vp1, vp1->hashcode,\n+\t\t\t\t   INSERT);\n+\n+  /* Because we iterate over phi operations more than once, it's\n+     possible the slot might already exist here, hence no assert.*/\n+  *slot = vp1;\n+}\n+\n+\n+/* Print set of components in strongly connected component SCC to OUT. */\n+\n+static void\n+print_scc (FILE *out, VEC (tree, heap) *scc)\n+{\n+  tree var;\n+  unsigned int i;\n+\n+  fprintf (out, \"SCC consists of: \");\n+  for (i = 0; VEC_iterate (tree, scc, i, var); i++)\n+    {\n+      print_generic_expr (out, var, 0);\n+      fprintf (out, \" \");\n+    }\n+  fprintf (out, \"\\n\");\n+}\n+\n+/* Set the value number of FROM to TO, return true if it has changed\n+   as a result.  */\n+\n+static inline bool\n+set_ssa_val_to (tree from, tree to)\n+{\n+  gcc_assert (to != NULL);\n+\n+  /* Make sure we don't create chains of copies, so that we get the\n+     best value numbering.  visit_copy has code to make sure this doesn't\n+     happen, we are doing this here to assert that nothing else breaks\n+     this.  */\n+  gcc_assert (TREE_CODE (to) != SSA_NAME\n+\t      || TREE_CODE (SSA_VAL (to)) != SSA_NAME\n+\t      || SSA_VAL (to) == to\n+\t      || to == from);\n+  /* The only thing we allow as value numbers are ssa_names and\n+     invariants.  So assert that here.  */\n+  gcc_assert (TREE_CODE (to) == SSA_NAME || is_gimple_min_invariant (to));\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Setting value number of \");\n+      print_generic_expr (dump_file, from, 0);\n+      fprintf (dump_file, \" to \");\n+      print_generic_expr (dump_file, to, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (SSA_VAL (from) != to)\n+    {\n+      SSA_VAL (from) = to;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Set all definitions in STMT to value number to themselves.\n+   Return true if a value number changed. */\n+\n+static bool\n+defs_to_varying (tree stmt)\n+{\n+  bool changed = false;\n+  ssa_op_iter iter;\n+  def_operand_p defp;\n+\n+  FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_ALL_DEFS)\n+    {\n+      tree def = DEF_FROM_PTR (defp);\n+\n+      VN_INFO (def)->use_processed = true;\n+      changed |= set_ssa_val_to (def, def);\n+    }\n+  return changed;\n+}\n+\n+/* Visit a copy between LHS and RHS, return true if the value number\n+   changed.  */\n+\n+static bool\n+visit_copy (tree lhs, tree rhs)\n+{\n+\n+  /* Follow chains of copies to their destination.  */\n+  while (SSA_VAL (rhs) != rhs && TREE_CODE (SSA_VAL (rhs)) == SSA_NAME)\n+    rhs = SSA_VAL (rhs);\n+  \n+  /* The copy may have a more interesting constant filled expression\n+     (we don't, since we know our RHS is just an SSA name).  */\n+  VN_INFO (lhs)->has_constants = VN_INFO (rhs)->has_constants;\n+  VN_INFO (lhs)->expr = VN_INFO (rhs)->expr;\n+\n+  return set_ssa_val_to (lhs, rhs);\n+}\n+\n+/* Visit a unary operator RHS, value number it, and return true if the\n+   value number of LHS has changed as a result.  */\n+\n+static bool\n+visit_unary_op (tree lhs, tree op)\n+{\n+  bool changed = false;\n+  tree result = vn_unary_op_lookup (op);\n+\n+  if (result)\n+    {\n+      changed = set_ssa_val_to (lhs, result);\n+    }\n+  else\n+    {\n+      changed = set_ssa_val_to (lhs, lhs);\n+      vn_unary_op_insert (op, lhs);\n+    }\n+\n+  return changed;\n+}\n+\n+/* Visit a binary operator RHS, value number it, and return true if the\n+   value number of LHS has changed as a result.  */\n+\n+static bool\n+visit_binary_op (tree lhs, tree op)\n+{\n+  bool changed = false;\n+  tree result = vn_binary_op_lookup (op);\n+\n+  if (result)\n+    {\n+      changed = set_ssa_val_to (lhs, result);\n+    }\n+  else\n+    {\n+      changed = set_ssa_val_to (lhs, lhs);\n+      vn_binary_op_insert (op, lhs);\n+    }\n+\n+  return changed;\n+}\n+\n+/* Visit a load from a reference operator RHS, part of STMT, value number it,\n+   and return true if the value number of the LHS has changed as a result.  */\n+\n+static bool\n+visit_reference_op_load (tree lhs, tree op, tree stmt)\n+{\n+  bool changed = false;\n+  tree result = vn_reference_lookup (op, shared_vuses_from_stmt (stmt));\n+\n+  if (result)\n+    {\n+      changed = set_ssa_val_to (lhs, result);\n+    }\n+  else\n+    {\n+      changed = set_ssa_val_to (lhs, lhs);\n+      vn_reference_insert (op, lhs, copy_vuses_from_stmt (stmt));\n+    }\n+\n+  return changed;\n+}\n+\n+\n+/* Visit a store to a reference operator LHS, part of STMT, value number it,\n+   and return true if the value number of the LHS has changed as a result.  */\n+\n+static bool\n+visit_reference_op_store (tree lhs, tree op, tree stmt)\n+{\n+  bool changed = false;\n+  tree result;\n+  bool resultsame = false;\n+\n+  /* First we want to lookup using the *vuses* from the store and see\n+     if there the last store to this location with the same address\n+     had the same value.\n+\n+     The vuses represent the memory state before the store.  If the\n+     memory state, address, and value of the store is the same as the\n+     last store to this location, then this store will produce the\n+     same memory state as that store.\n+\n+     In this case the vdef versions for this store are value numbered to those\n+     vuse versions, since they represent the same memory state after\n+     this store.\n+\n+     Otherwise, the vdefs for the store are used when inserting into\n+     the table, since the store generates a new memory state.  */\n+\n+  result = vn_reference_lookup (lhs, shared_vuses_from_stmt (stmt));\n+\n+  if (result)\n+    {\n+      if (TREE_CODE (result) == SSA_NAME)\n+\tresult = SSA_VAL (result);\n+      resultsame = expressions_equal_p (result, op);\n+    }\n+\n+  if (!result || !resultsame)\n+    {\n+      VEC(tree, gc) *vdefs = copy_vdefs_from_stmt (stmt);\n+      int i;\n+      tree vdef;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"No store match\\n\");\n+\t  fprintf (dump_file, \"Value numbering store \");\n+\t  print_generic_expr (dump_file, lhs, 0);\n+\t  fprintf (dump_file, \" to \");\n+\t  print_generic_expr (dump_file, op, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      /* Have to set value numbers before insert, since insert is\n+\t going to valueize the references in-place.  */\n+      for (i = 0; VEC_iterate (tree, vdefs, i, vdef); i++)\n+\t{\n+\t  VN_INFO (vdef)->use_processed = true;\n+\t  changed |= set_ssa_val_to (vdef, vdef);\n+\t}\n+\n+      vn_reference_insert (lhs, op, vdefs);\n+    }\n+  else\n+    {\n+      /* We had a match, so value number the vdefs to have the value\n+\t number of the vuses they came from.  */\n+      ssa_op_iter op_iter;\n+      def_operand_p var;\n+      vuse_vec_p vv;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Store matched earlier value,\"\n+\t\t \"value numbering store vdefs to matching vuses.\\n\");\n+\n+      FOR_EACH_SSA_VDEF_OPERAND (var, vv, stmt, op_iter)\n+\t{\n+\t  tree def = DEF_FROM_PTR (var);\n+\t  tree use;\n+\n+\t  /* Uh, if the vuse is a multiuse, we can't really do much\n+\t     here, sadly, since we don't know which value number of\n+\t     which vuse to use.  */\n+\t  if (VUSE_VECT_NUM_ELEM (*vv) != 1)\n+\t    use = def;\n+\t  else\n+\t    use = VUSE_ELEMENT_VAR (*vv, 0);\n+\n+\t  VN_INFO (def)->use_processed = true;\n+\t  changed |= set_ssa_val_to (def, SSA_VAL (use));\n+\t}\n+    }\n+\n+  return changed;\n+}\n+\n+/* Visit and value number PHI, return true if the value number\n+   changed.  */\n+\n+static bool\n+visit_phi (tree phi)\n+{\n+  bool changed = false;\n+  tree result;\n+  tree sameval = VN_TOP;\n+  bool allsame = true;\n+  int i;\n+\n+  /* See if all non-TOP arguments have the same value.  TOP is\n+     equivalent to everything, so we can ignore it.  */\n+  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+    {\n+      tree def = PHI_ARG_DEF (phi, i);\n+\n+      if (TREE_CODE (def) == SSA_NAME)\n+\tdef = SSA_VAL (def);\n+      if (def == VN_TOP)\n+\tcontinue;\n+      if (sameval == VN_TOP)\n+\t{\n+\t  sameval = def;\n+\t}\n+      else\n+\t{\n+\t  if (!expressions_equal_p (def, sameval))\n+\t    {\n+\t      allsame = false;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  /* If all value numbered to the same value, the phi node has that\n+     value.  */\n+  if (allsame)\n+    {\n+      if (is_gimple_min_invariant (sameval))\n+\t{\n+\t  VN_INFO (PHI_RESULT (phi))->has_constants = true;\n+\t  VN_INFO (PHI_RESULT (phi))->expr = sameval;\n+\t}\n+      else\n+\t{\n+\t  VN_INFO (PHI_RESULT (phi))->has_constants = false;\n+\t  VN_INFO (PHI_RESULT (phi))->expr = sameval;\n+\t}\n+      \n+      if (TREE_CODE (sameval) == SSA_NAME)\n+\treturn visit_copy (PHI_RESULT (phi), sameval);\n+      \n+      return set_ssa_val_to (PHI_RESULT (phi), sameval);\n+    }\n+\n+  /* Otherwise, see if it is equivalent to a phi node in this block.  */\n+  result = vn_phi_lookup (phi);\n+  if (result)\n+    {\n+      if (TREE_CODE (result) == SSA_NAME)\n+\tchanged = visit_copy (PHI_RESULT (phi), result);\n+      else\n+\tchanged = set_ssa_val_to (PHI_RESULT (phi), result);\n+    }\n+  else\n+    {\n+      vn_phi_insert (phi, PHI_RESULT (phi));\n+      VN_INFO (PHI_RESULT (phi))->has_constants = false;\n+      VN_INFO (PHI_RESULT (phi))->expr = PHI_RESULT (phi);\n+      changed = set_ssa_val_to (PHI_RESULT (phi), PHI_RESULT (phi));\n+    }\n+\n+  return changed;\n+}\n+\n+/* Return true if EXPR contains constants.  */\n+\n+static bool\n+expr_has_constants (tree expr)\n+{\n+  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n+    {\n+    case tcc_unary:\n+      return is_gimple_min_invariant (TREE_OPERAND (expr, 0));\n+\n+    case tcc_binary:\n+      return is_gimple_min_invariant (TREE_OPERAND (expr, 0))\n+\t|| is_gimple_min_invariant (TREE_OPERAND (expr, 1));\n+      /* Constants inside reference ops are rarely interesting, but\n+\t it can take a lot of looking to find them.  */\n+    case tcc_reference:\n+      return false;\n+    default:\n+      return is_gimple_min_invariant (expr);\n+    }\n+  return false;\n+}\n+\n+/* Replace SSA_NAMES in expr with their value numbers, and return the\n+   result.\n+   This is performed in place. */\n+\n+static tree\n+valueize_expr (tree expr)\n+{\n+  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n+    {\n+    case tcc_unary:\n+      if (TREE_CODE (TREE_OPERAND (expr, 0)) == SSA_NAME\n+\t  && SSA_VAL (TREE_OPERAND (expr, 0)) != VN_TOP)\n+\tTREE_OPERAND (expr, 0) = SSA_VAL (TREE_OPERAND (expr, 0));\n+      break;\n+    case tcc_binary:\n+      if (TREE_CODE (TREE_OPERAND (expr, 0)) == SSA_NAME\n+\t  && SSA_VAL (TREE_OPERAND (expr, 0)) != VN_TOP)\n+\tTREE_OPERAND (expr, 0) = SSA_VAL (TREE_OPERAND (expr, 0));\n+      if (TREE_CODE (TREE_OPERAND (expr, 1)) == SSA_NAME\n+\t  && SSA_VAL (TREE_OPERAND (expr, 1)) != VN_TOP)\n+\tTREE_OPERAND (expr, 1) = SSA_VAL (TREE_OPERAND (expr, 1));\n+      break;\n+    default:\n+      break;\n+    }\n+  return expr;\n+}\n+\n+/* Simplify the binary expression RHS, and return the result if\n+   simplified. */\n+\n+static tree\n+simplify_binary_expression (tree rhs)\n+{\n+  tree result = NULL_TREE;\n+  tree op0 = TREE_OPERAND (rhs, 0);\n+  tree op1 = TREE_OPERAND (rhs, 1);\n+\n+  /* This will not catch every single case we could combine, but will\n+     catch those with constants.  The goal here is to simultaneously\n+     combine constants between expressions, but avoid infinite\n+     expansion of expressions during simplification.  */\n+  if (TREE_CODE (op0) == SSA_NAME)\n+    {\n+      if (VN_INFO (op0)->has_constants)\n+\top0 = valueize_expr (VN_INFO (op0)->expr);\n+      else if (SSA_VAL (op0) != VN_TOP && SSA_VAL (op0) != op0)\n+\top0 = VN_INFO (op0)->valnum;      \n+    }\n+\n+  if (TREE_CODE (op1) == SSA_NAME)\n+    {\n+      if (VN_INFO (op1)->has_constants)\n+\top1 = valueize_expr (VN_INFO (op1)->expr);\n+      else if (SSA_VAL (op1) != VN_TOP && SSA_VAL (op1) != op1)\n+\top1 = VN_INFO (op1)->valnum;\n+    }\n+  result = fold_binary (TREE_CODE (rhs), TREE_TYPE (rhs), op0, op1);\n+\n+  /* Make sure result is not a complex expression consiting\n+     of operators of operators (IE (a + b) + (a + c))\n+     Otherwise, we will end up with unbounded expressions if\n+     fold does anything at all.  */\n+  if (result)\n+    {\n+      if (is_gimple_min_invariant (result))\n+\treturn result;\n+      else if (SSA_VAR_P (result))\n+\treturn result;\n+      else if (EXPR_P (result))\n+\t{\n+\t  switch (TREE_CODE_CLASS (TREE_CODE (result)))\n+\t    {\n+\t    case tcc_unary:\n+\t      {\n+\t\ttree op0 = TREE_OPERAND (result, 0);\n+\t\tif (!EXPR_P (op0))\n+\t\t  return result;\n+\t      }\n+\t      break;\n+\t    case tcc_binary:\n+\t      {\n+\t\ttree op0 = TREE_OPERAND (result, 0);\n+\t\ttree op1 = TREE_OPERAND (result, 1);\n+\t\tif (!EXPR_P (op0) && !EXPR_P (op1))\n+\t\t  return result;\n+\t      }\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Try to simplify RHS using equivalences and constant folding.  */\n+\n+static tree\n+try_to_simplify (tree stmt, tree rhs)\n+{\n+  if (TREE_CODE (rhs) == SSA_NAME)\n+    {\n+      if (is_gimple_min_invariant (SSA_VAL (rhs)))\n+\treturn SSA_VAL (rhs);\n+      else if (VN_INFO (rhs)->has_constants)\n+\treturn VN_INFO (rhs)->expr;\n+    }\n+  else\n+    {\n+      switch (TREE_CODE_CLASS (TREE_CODE (rhs)))\n+\t{\n+\t  /* For references, see if we find a result for the lookup,\n+\t     and use it if we do.  */\n+\n+\tcase tcc_reference:\n+\t  {\n+\t    tree result = vn_reference_lookup (rhs,\n+\t\t\t\t\t       shared_vuses_from_stmt (stmt));\n+\t    if (result)\n+\t      return result;\n+\t  }\n+\t  break;\n+\t  /* We could do a little more with unary ops, if they expand\n+\t     into binary ops, but it's debatable whether it is worth it. */\n+\tcase tcc_unary:\n+\t  {\n+\t    tree result = NULL_TREE;\n+\t    tree op0 = TREE_OPERAND (rhs, 0);\n+\t    if (TREE_CODE (op0) == SSA_NAME && VN_INFO (op0)->has_constants)\n+\t      op0 = VN_INFO (op0)->expr;\n+\t    else if (TREE_CODE (op0) == SSA_NAME && SSA_VAL (op0) != op0)\n+\t      op0 = SSA_VAL (op0);\n+\t    result = fold_unary (TREE_CODE (rhs), TREE_TYPE (rhs), op0);\n+\t    if (result)\n+\t      return result;\n+\t  }\n+\t  break;\n+\tcase tcc_comparison:\n+\tcase tcc_binary:\n+\t  return simplify_binary_expression (rhs);\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  return rhs;\n+}\n+\n+/* Visit and value number USE, return true if the value number\n+   changed. */\n+\n+static bool\n+visit_use (tree use)\n+{\n+  bool changed = false;\n+  tree stmt = SSA_NAME_DEF_STMT (use);\n+  stmt_ann_t ann;\n+\n+  VN_INFO (use)->use_processed = true;\n+\n+  gcc_assert (!SSA_NAME_IN_FREE_LIST (use));\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Value numbering \");\n+      print_generic_expr (dump_file, use, 0);\n+      fprintf (dump_file, \" stmt = \");\n+      print_generic_stmt (dump_file, stmt, 0);\n+    }\n+\n+  /* RETURN_EXPR may have an embedded MODIFY_STMT.  */\n+  if (TREE_CODE (stmt) == RETURN_EXPR\n+      && TREE_CODE (TREE_OPERAND (stmt, 0)) == GIMPLE_MODIFY_STMT)\n+    stmt = TREE_OPERAND (stmt, 0);\n+\n+  ann = stmt_ann (stmt);\n+\n+  /* Handle uninitialized uses.  */\n+  if (IS_EMPTY_STMT (stmt))\n+    {\n+      changed = set_ssa_val_to (use, use);\n+    }\n+  else\n+    {\n+      if (TREE_CODE (stmt) == PHI_NODE)\n+\t{\n+\t  changed = visit_phi (stmt);\n+\t}\n+      else if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT\n+\t       || (ann && ann->has_volatile_ops))\n+\t{\n+\t  changed = defs_to_varying (stmt);\n+\t}\n+      else\n+\t{\n+\t  tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+\t  tree simplified;\n+\n+\t  STRIP_USELESS_TYPE_CONVERSION (rhs);\n+\n+\t  simplified = try_to_simplify (stmt, rhs);\n+\t  if (simplified && simplified != rhs)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"RHS \");\n+\t\t  print_generic_expr (dump_file, rhs, 0);\n+\t\t  fprintf (dump_file, \" simplified to \");\n+\t\t  print_generic_expr (dump_file, simplified, 0);\n+\t\t  if (TREE_CODE (lhs) == SSA_NAME)\n+\t\t    fprintf (dump_file, \" has constants %d\\n\",\n+\t\t\t     VN_INFO (lhs)->has_constants);\n+\t\t  else\n+\t\t    fprintf (dump_file, \"\\n\");\n+\n+\t\t}\n+\t    }\n+\t  /* Setting value numbers to constants will occasionally\n+\t     screw up phi congruence because constants are not\n+\t     uniquely associated with a single ssa name that can be\n+\t     looked up.  */\n+\t  if (simplified && is_gimple_min_invariant (simplified)\n+\t      && TREE_CODE (lhs) == SSA_NAME\n+\t      && simplified != rhs)\n+\t    {\n+\t      VN_INFO (lhs)->expr = simplified;\n+\t      VN_INFO (lhs)->has_constants = true;\n+\t      changed = set_ssa_val_to (lhs, simplified);\n+\t      goto done;\n+\t    }\n+\t  else if (simplified && TREE_CODE (simplified) == SSA_NAME\n+\t\t   && TREE_CODE (lhs) == SSA_NAME)\n+\t    {\n+\t      changed = visit_copy (lhs, simplified);\n+\t      goto done;\n+\t    }\n+\t  else if (simplified)\n+\t    {\n+\t      if (TREE_CODE (lhs) == SSA_NAME)\n+\t\t{\n+\t\t  VN_INFO (lhs)->has_constants = expr_has_constants (simplified);\n+\t\t  /* We have to unshare the expression or else\n+\t\t     valuizing may change the IL stream.  */\n+\t\t  VN_INFO (lhs)->expr = unshare_expr (simplified);\n+\t\t}\n+\t      rhs = simplified;\n+\t    }\n+\t  else if (expr_has_constants (rhs) && TREE_CODE (lhs) == SSA_NAME)\n+\t    {\n+\t      VN_INFO (lhs)->has_constants = true;\n+\t      VN_INFO (lhs)->expr = unshare_expr (rhs);\n+\t    }\n+\t  else if (TREE_CODE (lhs) == SSA_NAME)\n+\t    {\n+\t      /* We reset expr and constantness here because we may\n+\t\t have been value numbering optimistically, and\n+\t\t iterating. They may become non-constant in this case,\n+\t\t even if they were optimistically constant. */\n+\t\t \n+\t      VN_INFO (lhs)->has_constants = false;\n+\t      VN_INFO (lhs)->expr = lhs;\n+\t    }\n+\n+\t  if (TREE_CODE (lhs) == SSA_NAME\n+\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n+\t    changed = defs_to_varying (stmt);\n+\t  else if (REFERENCE_CLASS_P (lhs))\n+\t    {\n+\t      changed = visit_reference_op_store (lhs, rhs, stmt);\n+\t    }\n+\t  else if (TREE_CODE (lhs) == SSA_NAME)\n+\t    {\n+\t      if (is_gimple_min_invariant (rhs))\n+\t\t{\n+\t\t  VN_INFO (lhs)->has_constants = true;\n+\t\t  VN_INFO (lhs)->expr = rhs;\n+\t\t  changed = set_ssa_val_to (lhs, rhs);\n+\t\t}\n+\t      else if (TREE_CODE (rhs) == SSA_NAME)\n+\t\tchanged = visit_copy (lhs, rhs);\n+\t      else\n+\t\t{\n+\t\t  switch (TREE_CODE_CLASS (TREE_CODE (rhs)))\n+\t\t    {\n+\t\t    case tcc_unary:\n+\t\t      changed = visit_unary_op (lhs, rhs);\n+\t\t      break;\n+\t\t    case tcc_binary:\n+\t\t      changed = visit_binary_op (lhs, rhs);\n+\t\t      break;\n+\t\t      /* If tcc_vl_expr ever encompasses more than\n+\t\t\t CALL_EXPR, this will need to be changed.  */\n+\t\t    case tcc_vl_exp:\n+\t\t      if (call_expr_flags (rhs)  & (ECF_PURE | ECF_CONST))\n+\t\t\tchanged = visit_reference_op_load (lhs, rhs, stmt);\n+\t\t      else\n+\t\t\tchanged = defs_to_varying (stmt);\n+\t\t      break;\n+\t\t    case tcc_declaration:\n+\t\t    case tcc_reference:\n+\t\t      changed = visit_reference_op_load (lhs, rhs, stmt);\n+\t\t      break;\n+\t\t    case tcc_expression:\n+\t\t      if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t\t\t{\n+\t\t\t  changed = visit_unary_op (lhs, rhs);\n+\t\t\t  goto done;\n+\t\t\t}\n+\t\t      /* Fallthrough.  */\n+\t\t    default:\n+\t\t      changed = defs_to_varying (stmt);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    changed = defs_to_varying (stmt);\n+\t}\n+    }\n+ done:\n+  return changed;\n+}\n+\n+/* Compare two operands by reverse postorder index */\n+\n+static int\n+compare_ops (const void *pa, const void *pb)\n+{\n+  const tree opa = *((const tree *)pa);\n+  const tree opb = *((const tree *)pb);\n+  tree opstmta = SSA_NAME_DEF_STMT (opa);\n+  tree opstmtb = SSA_NAME_DEF_STMT (opb);\n+  basic_block bba;\n+  basic_block bbb;\n+\n+  if (IS_EMPTY_STMT (opstmta) && IS_EMPTY_STMT (opstmtb))\n+    return 0;\n+  else if (IS_EMPTY_STMT (opstmta))\n+    return -1;\n+  else if (IS_EMPTY_STMT (opstmtb))\n+    return 1;\n+\n+  bba = bb_for_stmt (opstmta);\n+  bbb = bb_for_stmt (opstmtb);\n+\n+  if (!bba && !bbb)\n+    return 0;\n+  else if (!bba)\n+    return -1;\n+  else if (!bbb)\n+    return 1;\n+\n+  if (bba == bbb)\n+    {\n+      if (TREE_CODE (opstmta) == PHI_NODE && TREE_CODE (opstmtb) == PHI_NODE)\n+\treturn 0;\n+      else if (TREE_CODE (opstmta) == PHI_NODE)\n+\treturn -1;\n+      else if (TREE_CODE (opstmtb) == PHI_NODE)\n+\treturn 1;\n+      return stmt_ann (opstmta)->uid - stmt_ann (opstmtb)->uid;\n+    }\n+  return rpo_numbers[bba->index] - rpo_numbers[bbb->index];\n+}\n+\n+/* Sort an array containing members of a strongly connected component\n+   SCC so that the members are ordered by RPO number.\n+   This means that when the sort is complete, iterating through the\n+   array will give you the members in RPO order.  */\n+\n+static void\n+sort_scc (VEC (tree, heap) *scc)\n+{\n+  qsort (VEC_address (tree, scc),\n+\t VEC_length (tree, scc),\n+\t sizeof (tree),\n+\t compare_ops);\n+}\n+\n+/* Process a strongly connected component in the SSA graph.  */\n+\n+static void\n+process_scc (VEC (tree, heap) *scc)\n+{\n+  /* If the SCC has a single member, just visit it.  */\n+\n+  if (VEC_length (tree, scc) == 1)\n+    {\n+      tree use = VEC_index (tree, scc, 0);\n+      if (!VN_INFO (use)->use_processed) \n+\tvisit_use (use);\n+    }\n+  else\n+    {\n+      tree var;\n+      unsigned int i;\n+      unsigned int iterations = 0;\n+      bool changed = true;\n+\n+      /* Iterate over the SCC with the optimistic table until it stops\n+\t changing.  */\n+      current_info = optimistic_info;\n+      while (changed)\n+\t{\n+\t  changed = false;\n+\t  iterations++;\n+\t  for (i = 0; VEC_iterate (tree, scc, i, var); i++)\n+\t    changed |= visit_use (var);\n+\t}\n+\n+      if (dump_file && (dump_flags & TDF_STATS))\n+\tfprintf (dump_file, \"Processing SCC required %d iterations\\n\",\n+\t\t iterations);\n+\n+      /* Finally, visit the SCC once using the valid table.  */\n+      current_info = valid_info;\n+      for (i = 0; VEC_iterate (tree, scc, i, var); i++)\n+\tvisit_use (var);\n+    }\n+}\n+\n+/* Depth first search on NAME to discover and process SCC's in the SSA\n+   graph.\n+   Execution of this algorithm relies on the fact that the SCC's are\n+   popped off the stack in topological order.  */\n+\n+static void\n+DFS (tree name)\n+{\n+  ssa_op_iter iter;\n+  use_operand_p usep;\n+  tree defstmt;\n+\n+  /* SCC info */\n+  VN_INFO (name)->dfsnum = next_dfs_num++;\n+  VN_INFO (name)->visited = true;\n+  VN_INFO (name)->low = VN_INFO (name)->dfsnum;\n+\n+  VEC_safe_push (tree, heap, sccstack, name);\n+  VN_INFO (name)->on_sccstack = true;\n+  defstmt = SSA_NAME_DEF_STMT (name);\n+\n+  /* Recursively DFS on our operands, looking for SCC's.  */\n+  if (!IS_EMPTY_STMT (defstmt))\n+    {\n+      FOR_EACH_PHI_OR_STMT_USE (usep, SSA_NAME_DEF_STMT (name), iter,\n+\t\t\t\tSSA_OP_ALL_USES)\n+\t{\n+\t  tree use = USE_FROM_PTR (usep);\n+\n+\t  /* Since we handle phi nodes, we will sometimes get\n+\t     invariants in the use expression.  */\n+\t  if (TREE_CODE (use) != SSA_NAME)\n+\t    continue;\n+\n+\t  if (! (VN_INFO (use)->visited))\n+\t    {\n+\t      DFS (use);\n+\t      VN_INFO (name)->low = MIN (VN_INFO (name)->low,\n+\t\t\t\t\t VN_INFO (use)->low);\n+\t    }\n+\t  if (VN_INFO (use)->dfsnum < VN_INFO (name)->dfsnum\n+\t      && VN_INFO (use)->on_sccstack)\n+\t    {\n+\t      VN_INFO (name)->low = MIN (VN_INFO (use)->dfsnum,\n+\t\t\t\t\t VN_INFO (name)->low);\n+\t    }\n+\t}\n+    }\n+\n+  /* See if we found an SCC.  */\n+  if (VN_INFO (name)->low == VN_INFO (name)->dfsnum)\n+    {\n+      VEC (tree, heap) *scc = NULL;\n+      tree x;\n+\n+      /* Found an SCC, pop the components off the SCC stack and\n+\t process them.  */\n+      do\n+\t{\n+\t  x = VEC_pop (tree, sccstack);\n+\n+\t  VN_INFO (x)->on_sccstack = false;\n+\t  VEC_safe_push (tree, heap, scc, x);\n+\t} while (x != name);\n+\n+      if (VEC_length (tree, scc) > 1)\n+\tsort_scc (scc);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tprint_scc (dump_file, scc);\n+\n+      process_scc (scc);\n+\n+      VEC_free (tree, heap, scc);\n+    }\n+}\n+\n+static void\n+free_phi (void *vp)\n+{\n+  vn_phi_t phi = vp;\n+  VEC_free (tree, heap, phi->phiargs);\n+}\n+\n+\n+/* Free a reference operation structure VP.  */\n+\n+static void\n+free_reference (void *vp)\n+{\n+  vn_reference_t vr = vp;\n+  VEC_free (vn_reference_op_s, heap, vr->operands);\n+}\n+\n+/* Allocate a value number table.  */\n+\n+static void\n+allocate_vn_table (vn_tables_t table)\n+{\n+  table->phis = htab_create (23, vn_phi_hash, vn_phi_eq, free_phi);\n+  table->unary = htab_create (23, vn_unary_op_hash, vn_unary_op_eq, NULL);\n+  table->binary = htab_create (23, vn_binary_op_hash, vn_binary_op_eq, NULL);\n+  table->references = htab_create (23, vn_reference_hash, vn_reference_eq,\n+\t\t\t\t   free_reference);\n+\n+  table->unary_op_pool = create_alloc_pool (\"VN unary operations\",\n+\t\t\t\t\t    sizeof (struct vn_unary_op_s),\n+\t\t\t\t\t    30);\n+  table->binary_op_pool = create_alloc_pool (\"VN binary operations\",\n+\t\t\t\t\t     sizeof (struct vn_binary_op_s),\n+\t\t\t\t\t     30);\n+  table->phis_pool = create_alloc_pool (\"VN phis\",\n+\t\t\t\t\tsizeof (struct vn_phi_s),\n+\t\t\t\t\t30);\n+  table->references_pool = create_alloc_pool (\"VN references\",\n+\t\t\t\t\t      sizeof (struct vn_reference_s),\n+\t\t\t\t\t      30);\n+}\n+\n+/* Free a value number table.  */\n+\n+static void\n+free_vn_table (vn_tables_t table)\n+{\n+  htab_delete (table->phis);\n+  htab_delete (table->unary);\n+  htab_delete (table->binary);\n+  htab_delete (table->references);\n+  free_alloc_pool (table->unary_op_pool);\n+  free_alloc_pool (table->binary_op_pool);\n+  free_alloc_pool (table->phis_pool);\n+  free_alloc_pool (table->references_pool);\n+}\n+\n+static void\n+init_scc_vn (void)\n+{\n+  size_t i;\n+  int j;\n+  int *rpo_numbers_temp;\n+  basic_block bb;\n+  size_t id = 0;\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  sccstack = NULL;\n+  next_dfs_num = 1;\n+\n+  vn_ssa_aux_table = VEC_alloc (vn_ssa_aux_t, heap, num_ssa_names + 1);\n+  /* VEC_alloc doesn't actually grow it to the right size, it just\n+     preallocates the space to do so.  */\n+  VEC_safe_grow (vn_ssa_aux_t, heap, vn_ssa_aux_table, num_ssa_names + 1);\n+  shared_lookup_phiargs = NULL;\n+  shared_lookup_vops = NULL;\n+  shared_lookup_references = NULL;\n+  rpo_numbers = XCNEWVEC (int, last_basic_block + NUM_FIXED_BLOCKS);\n+  rpo_numbers_temp = XCNEWVEC (int, last_basic_block + NUM_FIXED_BLOCKS);\n+  pre_and_rev_post_order_compute (NULL, rpo_numbers_temp, false);\n+\n+  /* RPO numbers is an array of rpo ordering, rpo[i] = bb means that\n+     the i'th block in RPO order is bb.  We want to map bb's to RPO\n+     numbers, so we need to rearrange this array.  */\n+  for (j = 0; j < n_basic_blocks - NUM_FIXED_BLOCKS; j++)\n+    rpo_numbers[rpo_numbers_temp[j]] = j;\n+\n+  free (rpo_numbers_temp);\n+\n+  VN_TOP = create_tmp_var_raw (void_type_node, \"vn_top\");\n+\n+  /* Create the VN_INFO structures, and initialize value numbers to\n+     TOP.  */\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      tree name = ssa_name (i);\n+      if (name)\n+\t{\n+\t  VN_INFO_GET (name)->valnum = VN_TOP;\n+\t  VN_INFO (name)->expr = name;\n+\t}\n+    }\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      block_stmt_iterator bsi;\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  stmt_ann (stmt)->uid = id++;\n+\t}\n+    }\n+\n+  /* Create the valid and optimistic value numbering tables.  */\n+  valid_info = XCNEW (struct vn_tables_s);\n+  allocate_vn_table (valid_info);\n+  optimistic_info = XCNEW (struct vn_tables_s);\n+  allocate_vn_table (optimistic_info);\n+  pre_info = NULL;\n+}\n+\n+void\n+switch_to_PRE_table (void)\n+{\n+  pre_info = XCNEW (struct vn_tables_s);\n+  allocate_vn_table (pre_info);\n+  current_info = pre_info;\n+}\n+\n+void\n+free_scc_vn (void)\n+{\n+  size_t i;\n+\n+  VEC_free (tree, heap, shared_lookup_phiargs);\n+  VEC_free (tree, gc, shared_lookup_vops);\n+  VEC_free (vn_reference_op_s, heap, shared_lookup_references);\n+  XDELETEVEC (rpo_numbers);\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      tree name = ssa_name (i);\n+      if (name)\n+\t{\n+\t  XDELETE (VN_INFO (name));\n+\t  if (SSA_NAME_VALUE (name) &&\n+\t      TREE_CODE (SSA_NAME_VALUE (name)) == VALUE_HANDLE)\n+\t    SSA_NAME_VALUE (name) = NULL;\n+\t}\n+    }\n+      \n+  VEC_free (vn_ssa_aux_t, heap, vn_ssa_aux_table);\n+  VEC_free (tree, heap, sccstack);\n+  free_vn_table (valid_info);\n+  XDELETE (valid_info);\n+  free_vn_table (optimistic_info);\n+  XDELETE (optimistic_info);\n+  if (pre_info)\n+    {\n+      free_vn_table (pre_info);\n+      XDELETE (pre_info);\n+    }\n+}\n+\n+void\n+run_scc_vn (void)\n+{\n+  size_t i;\n+  tree param;\n+\n+  init_scc_vn ();\n+  current_info = valid_info;\n+\n+  for (param = DECL_ARGUMENTS (current_function_decl);\n+       param;\n+       param = TREE_CHAIN (param))\n+    {\n+      if (gimple_default_def (cfun, param) != NULL)\n+\t{\n+\t  tree def = gimple_default_def (cfun, param);\n+\t  SSA_VAL (def) = def;\n+\t}\n+    }\n+\n+  for (i = num_ssa_names - 1; i > 0; i--)\n+    {\n+      tree name = ssa_name (i);\n+      if (name\n+\t  && VN_INFO (name)->visited == false\n+\t  && !has_zero_uses (name))\n+\tDFS (name);\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Value numbers:\\n\");\n+      for (i = 0; i < num_ssa_names; i++)\n+\t{\n+\t  tree name = ssa_name (i);\n+\t  if (name && VN_INFO (name)->visited\n+\t      && (SSA_VAL (name) != name\n+\t\t  || is_gimple_min_invariant (VN_INFO (name)->expr)))\n+\t    {\n+\t      print_generic_expr (dump_file, name, 0);\n+\t      fprintf (dump_file, \" = \");\n+\t      if (is_gimple_min_invariant (VN_INFO (name)->expr))\n+\t\tprint_generic_expr (dump_file, VN_INFO (name)->expr, 0);\n+\t      else\n+\t\tprint_generic_expr (dump_file, SSA_VAL (name), 0);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t}\n+    }\n+}"}, {"sha": "9e8c317992a51c2aea97b85caee567a1e4d9006d", "filename": "gcc/tree-ssa-sccvn.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -0,0 +1,65 @@\n+/* Tree SCC value numbering\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin <dberlin@dberlin.org>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2 of the License, or\n+(at your option) any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; if not, write to the Free Software\n+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+*/\n+\n+#ifndef TREE_SSA_SCCVN_H\n+#define TREE_SSA_SCCVN_H\n+\n+/* TOP of the VN lattice.  */\n+extern tree VN_TOP;\n+\n+typedef struct vn_ssa_aux\n+{\n+  /* SCC information.  */\n+  unsigned int dfsnum;\n+  bool visited;\n+  unsigned int low;\n+  bool on_sccstack;\n+\n+  /* Value number. This may be an SSA name or a constant.  */\n+  tree valnum;\n+  /* Representative expression, if not a direct constant. */\n+  tree expr;\n+  /* Whether the representative expression contains constants.  */\n+  bool has_constants;\n+  /* Whether the SSA_NAME has been value numbered already.  This is\n+     only saying whether visit_use has been called on it at least\n+     once.  It cannot be used to avoid visitation for SSA_NAME's\n+     involved in non-singleton SCC's.  */\n+  bool use_processed;\n+} *vn_ssa_aux_t;\n+\n+/* Return the value numbering info for an SSA_NAME.  */\n+extern vn_ssa_aux_t VN_INFO (tree);\n+extern vn_ssa_aux_t VN_INFO_GET (tree);\n+void run_scc_vn (void);\n+void free_scc_vn (void);\n+void switch_to_PRE_table (void);\n+tree vn_binary_op_lookup (tree);\n+void vn_binary_op_insert (tree, tree);\n+tree vn_unary_op_lookup (tree);\n+void vn_unary_op_insert (tree, tree);\n+tree vn_reference_lookup (tree, VEC (tree, gc) *);\n+void vn_reference_insert (tree, tree, VEC (tree, gc) *);\n+VEC (tree, gc) *shared_vuses_from_stmt (tree);\n+VEC (tree, gc) *copy_vuses_from_stmt (tree);\n+\t\t\t\t  \n+\n+#endif /* TREE_SSA_SCCVN_H  */"}, {"sha": "a000ca2815c1792a478081e8a44870bae85385bc", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 218, "deletions": 249, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fb70a345104a84bff4d5105f3456e7b8a5ca1e/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=89fb70a345104a84bff4d5105f3456e7b8a5ca1e", "patch": "@@ -32,35 +32,15 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-pass.h\"\n #include \"tree-dump.h\"\n #include \"diagnostic.h\"\n+#include \"tree-ssa-sccvn.h\"\n \n-/* The value table that maps expressions to values.  */\n-static htab_t value_table;\n-\n-/* Map expressions to values.  These are simple pairs of expressions\n-   and the values they represent.  To find the value represented by\n-   an expression, we use a hash table where the elements are {e,v}\n-   pairs, and the expression is the key.  */\n-typedef struct val_expr_pair_d\n-{\n-  /* Value handle.  */\n-  tree v;\n-\n-  /* Associated expression.  */\n-  tree e;\n-\n-  /* For comparing virtual uses in E.  */\n-  VEC (tree, gc) *vuses;\n-\n-  /* E's hash value.  */\n-  hashval_t hashcode;\n-} *val_expr_pair_t;\n-\n-static void set_value_handle (tree e, tree v);\n-\n+/* Most of this is PRE specific.  The real grunt work is done in\n+   tree-ssa-sccvn.c.  This is where the lookup and insertion\n+   functions, etc, can be found */\n \n /* Create and return a new value handle node of type TYPE.  */\n \n-static tree\n+tree\n make_value_handle (tree type)\n {\n   static unsigned int id = 0;\n@@ -72,25 +52,6 @@ make_value_handle (tree type)\n }\n \n \n-/* Given an expression EXPR, compute a hash value number using the\n-   code of the expression, its real operands and virtual operands (if\n-   any).\n-   \n-   VAL can be used to iterate by passing previous value numbers (it is\n-   used by iterative_hash_expr).  */\n-\n-hashval_t\n-vn_compute (tree expr, hashval_t val)\n-{\n-  /* EXPR must not be a statement.  We are only interested in value\n-     numbering expressions on the RHS of assignments.  */\n-  gcc_assert (expr);\n-  gcc_assert (!expr->base.ann\n-\t      || expr->base.ann->common.type != STMT_ANN);\n-\n-  val = iterative_hash_expr (expr, val);\n-  return val;\n-}\n \n /* Compare two expressions E1 and E2 and return true if they are\n    equal.  */\n@@ -130,52 +91,9 @@ expressions_equal_p (tree e1, tree e2)\n   return false;\n }\n \n-\n-/* Hash a {v,e} pair that is pointed to by P.\n-   The hashcode is cached in the val_expr_pair, so we just return\n-   that.  */\n-\n-static hashval_t\n-val_expr_pair_hash (const void *p)\n-{\n-  const val_expr_pair_t ve = (val_expr_pair_t) p;\n-  return ve->hashcode;\n-}\n-\n-\n-/* Given two val_expr_pair_t's, return true if they represent the same\n-   expression, false otherwise.\n-   P1 and P2 should point to the val_expr_pair_t's to be compared.  */\n-\n-static int\n-val_expr_pair_expr_eq (const void *p1, const void *p2)\n-{\n-  int i;\n-  tree vuse1;\n-  const val_expr_pair_t ve1 = (val_expr_pair_t) p1;\n-  const val_expr_pair_t ve2 = (val_expr_pair_t) p2;\n-\n-  if (! expressions_equal_p (ve1->e, ve2->e))\n-    return false;\n-\n-  if (ve1->vuses == ve2->vuses)\n-    return true;\n-\n-  if (VEC_length (tree, ve1->vuses) != VEC_length (tree, ve2->vuses))\n-    return false;\n-\n-  for (i = 0; VEC_iterate (tree, ve1->vuses, i, vuse1); i++)\n-    {\n-      if (VEC_index (tree, ve2->vuses, i) != vuse1)\n-\treturn false;\n-    }\n-  return true;\n-}\n-\n-\n /* Set the value handle for expression E to value V.  */\n    \n-static void\n+void\n set_value_handle (tree e, tree v)\n {\n   if (TREE_CODE (e) == SSA_NAME)\n@@ -189,97 +107,206 @@ set_value_handle (tree e, tree v)\n     gcc_assert (is_gimple_min_invariant (e));\n }\n \n-/* Copy the virtual uses from STMT into a newly allocated VEC(tree),\n-   and return the VEC(tree).  */\n \n-static VEC (tree, gc) *\n-copy_vuses_from_stmt (tree stmt)\n-{\n-  ssa_op_iter iter;\n-  tree vuse;\n-  VEC (tree, gc) *vuses = NULL;\n \n-  if (!stmt)\n-    return NULL;\n \n-  FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, iter, SSA_OP_VUSE)\n-    VEC_safe_push (tree, gc, vuses, vuse);\n+/* A comparison function for use in qsort to compare vuses.  Simply\n+   subtracts version numbers.  */\n \n-  return vuses;\n-}\n+static int\n+vuses_compare (const void *pa, const void *pb)\n+{\n+  const tree vusea = *((const tree *)pa);\n+  const tree vuseb = *((const tree *)pb);\n+  int sn = SSA_NAME_VERSION (vusea) - SSA_NAME_VERSION (vuseb);\n \n-/* Place for shared_vuses_from_stmt to shove vuses.  */\n-static VEC (tree, gc) *shared_lookup_vuses;\n+  return sn;\n+}\n \n-/* Copy the virtual uses from STMT into SHARED_LOOKUP_VUSES.\n-   This function will overwrite the current SHARED_LOOKUP_VUSES\n-   variable.  */\n+/* Print out the \"Created value <x> for <Y>\" statement to the\n+   dump_file.\n+   This is factored because both versions of lookup use it, and it\n+   obscures the real work going on in those functions.  */\n \n-static VEC (tree, gc) *\n-shared_vuses_from_stmt (tree stmt)\n+static void\n+print_creation_to_file (tree v, tree expr, VEC (tree, gc) *vuses)\n {\n-  ssa_op_iter iter;\n-  tree vuse;\n+  fprintf (dump_file, \"Created value \");\n+  print_generic_expr (dump_file, v, dump_flags);\n+  fprintf (dump_file, \" for \");\n+  print_generic_expr (dump_file, expr, dump_flags);\n+  \n+  if (vuses && VEC_length (tree, vuses) != 0)\n+    {\n+      size_t i;\n+      tree vuse;\n+      \n+      fprintf (dump_file, \" vuses: (\");\n+      for (i = 0; VEC_iterate (tree, vuses, i, vuse); i++)\n+\t{\n+\t  print_generic_expr (dump_file, vuse, dump_flags);\n+\t  if (VEC_length (tree, vuses) - 1 != i)\n+\t    fprintf (dump_file, \",\");\n+\t}\n+      fprintf (dump_file, \")\");\n+    }\t\t   \n+  fprintf (dump_file, \"\\n\");\n+}\n \n-  if (!stmt)\n-    return NULL;\n \n-  VEC_truncate (tree, shared_lookup_vuses, 0);\n+/* Sort the VUSE array so that we can do equality comparisons\n+   quicker on two vuse vecs.  */\n \n-  FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, iter, SSA_OP_VUSE)\n-    VEC_safe_push (tree, gc, shared_lookup_vuses, vuse);\n+void \n+sort_vuses (VEC (tree,gc) *vuses)\n+{\n+  if (VEC_length (tree, vuses) > 1)\n+    qsort (VEC_address (tree, vuses),\n+\t   VEC_length (tree, vuses),\n+\t   sizeof (tree),\n+\t   vuses_compare);\n+}\n \n-  if (VEC_length (tree, shared_lookup_vuses) > 1)\n-    sort_vuses (shared_lookup_vuses);\n+/* Sort the VUSE array so that we can do equality comparisons\n+   quicker on two vuse vecs.  */\n \n-  return shared_lookup_vuses;\n+void \n+sort_vuses_heap (VEC (tree,heap) *vuses)\n+{\n+  if (VEC_length (tree, vuses) > 1)\n+    qsort (VEC_address (tree, vuses),\n+\t   VEC_length (tree, vuses),\n+\t   sizeof (tree),\n+\t   vuses_compare);\n }\n-\n /* Insert EXPR into VALUE_TABLE with value VAL, and add expression\n    EXPR to the value set for value VAL.  */\n \n void\n vn_add (tree expr, tree val)\n {\n-  vn_add_with_vuses (expr, val, NULL);\n+  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n+    {\n+    case tcc_comparison:\n+    case tcc_binary:\n+      vn_binary_op_insert (expr, val);\n+      break;\n+    case tcc_unary:\n+      vn_unary_op_insert (expr, val);\n+      break;\n+      /* In the case of array-refs of constants, for example, we can\n+\t end up with no vuses.  */\n+    case tcc_reference:\n+      vn_reference_insert (expr, val, NULL);\n+      break;\n+      /* The *only* time CALL_EXPR should appear here is\n+\t when it has no vuses.  */\n+    case tcc_vl_exp:\n+    case tcc_exceptional:\n+    case tcc_expression:\n+    case tcc_declaration:\n+      if (TREE_CODE (expr) == CALL_EXPR || DECL_P (expr))\n+\t{\n+\t  vn_reference_insert (expr, val, NULL);\n+\t  break;\n+\t}\n+      else if (TREE_CODE (expr) == SSA_NAME)\n+\t{\n+\t  SSA_NAME_VALUE (expr) = val;\n+\t  break;\n+\t}\n+      else if (TREE_CODE (expr) == ADDR_EXPR)\n+\t{\n+\t  vn_unary_op_insert (expr, val);\n+\t  break;\n+\t}\n+      /* FALLTHROUGH */\n+    default:\n+      gcc_unreachable ();\n+    }\n+  set_value_handle (expr, val);\n+  if (TREE_CODE (val) == VALUE_HANDLE)\n+    add_to_value (val, expr);\n }\n \n-/* Insert EXPR into VALUE_TABLE with value VAL, and add expression\n-   EXPR to the value set for value VAL.  VUSES represents the virtual\n-   use operands associated with EXPR.  It is used when computing a\n-   hash value for EXPR.  */\n+/* Insert EXPR into the value numbering tables.  with value VAL, and\n+   add expression EXPR to the value set for value VAL.  VUSES\n+   represents the virtual use operands associated with EXPR.  It is\n+   used when computing a hash value for EXPR.  */\n \n void\n vn_add_with_vuses (tree expr, tree val, VEC (tree, gc) *vuses)\n {\n-  void **slot;\n-  val_expr_pair_t new_pair;\n-  \n-  new_pair = XNEW (struct val_expr_pair_d);\n-  new_pair->e = expr;\n-  new_pair->v = val;\n-  new_pair->vuses = vuses;\n-  new_pair->hashcode = vn_compute (expr, 0);\n-  slot = htab_find_slot_with_hash (value_table, new_pair, new_pair->hashcode,\n-\t\t\t\t   INSERT);\n-  if (*slot)\n-    free (*slot);\n-  *slot = (void *) new_pair;\n+  if (!vuses)\n+    {\n+      vn_add (expr, val);\n+      return;\n+    }\n+  vn_reference_insert (expr, val, vuses);\n \n   set_value_handle (expr, val);\n   if (TREE_CODE (val) == VALUE_HANDLE)\n     add_to_value (val, expr);\n }\n \n \n-/* Search in VALUE_TABLE for an existing instance of expression EXPR,\n-   and return its value, or NULL if none has been set.  STMT\n+/* Lookup EXPR in the value numbering tables and return the result, if\n+   we have one.  */\n+\n+tree\n+vn_lookup (tree expr)\n+{\n+  /* Constants are their own value.  */\n+  if (is_gimple_min_invariant (expr) || TREE_CODE (expr) == FIELD_DECL)\n+    return expr;\n+\n+  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n+    {\n+    case tcc_comparison:\n+    case tcc_binary:\n+      return vn_binary_op_lookup (expr);\n+    case tcc_unary:\n+      return vn_unary_op_lookup (expr);\n+      break;\n+      /* In the case of array-refs of constants, for example, we can\n+\t end up with no vuses.  */\n+    case tcc_reference:\n+      return vn_reference_lookup (expr, NULL);\n+      break;\n+      /* It is possible to have CALL_EXPR with no vuses for things\n+\t like \"cos\", and these will fall into vn_lookup.   */\n+    case tcc_vl_exp:\n+    case tcc_exceptional:\n+    case tcc_expression:\n+    case tcc_declaration:\n+      if (TREE_CODE (expr) == CALL_EXPR || DECL_P (expr))\n+\treturn vn_reference_lookup (expr, NULL);\n+      else if (TREE_CODE (expr) == SSA_NAME)\n+\treturn SSA_NAME_VALUE (expr);      \n+      else if (TREE_CODE (expr) == ADDR_EXPR)\n+\treturn vn_unary_op_lookup (expr);\n+      /* FALLTHROUGH */\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return NULL;\n+}\n+\n+/* Search in the value numbering tables for an existing instance of\n+   expression EXPR,  and return its value, or NULL if none has been set.  STMT\n    represents the stmt associated with EXPR.  It is used when computing the \n-   hash value for EXPR.  */\n+   hash value for EXPR for reference operations.  */\n \n tree\n-vn_lookup (tree expr, tree stmt)\n+vn_lookup_with_stmt (tree expr, tree stmt)\n {\n+  if (stmt == NULL)\n+    return vn_lookup (expr);\n+\n+  /* Constants are their own value.  */\n+  if (is_gimple_min_invariant (expr) || TREE_CODE (expr) == FIELD_DECL)\n+    return expr;\n+\n   return vn_lookup_with_vuses (expr, shared_vuses_from_stmt (stmt));\n }\n \n@@ -291,109 +318,71 @@ vn_lookup (tree expr, tree stmt)\n tree\n vn_lookup_with_vuses (tree expr, VEC (tree, gc) *vuses)\n {\n-  void **slot;\n-  struct val_expr_pair_d vep = {NULL, NULL, NULL, 0};\n+  if (!vuses || !VEC_length (tree, vuses))\n+    return vn_lookup (expr);\n \n-  /* Constants are their own value.  */\n-  if (is_gimple_min_invariant (expr))\n+  if (is_gimple_min_invariant (expr) || TREE_CODE (expr) == FIELD_DECL)\n     return expr;\n \n-  vep.e = expr;\n-  vep.vuses = vuses;\n-  vep.hashcode = vn_compute (expr, 0);\n-  slot = htab_find_slot_with_hash (value_table, &vep, vep.hashcode, NO_INSERT);\n-  if (!slot)\n-    return NULL_TREE;\n-  else\n-    return ((val_expr_pair_t) *slot)->v;\n+  return vn_reference_lookup (expr, vuses);\n }\n \n-\n-/* A comparison function for use in qsort to compare vuses.  Simply\n-   subtracts version numbers.  */\n-\n-static int\n-vuses_compare (const void *pa, const void *pb)\n+static tree\n+create_value_handle_for_expr (tree expr, VEC (tree, gc) *vuses)\n {\n-  const tree vusea = *((const tree *)pa);\n-  const tree vuseb = *((const tree *)pb);\n-  int sn = SSA_NAME_VERSION (vusea) - SSA_NAME_VERSION (vuseb);\n-\n-  return sn;\n+  tree v;\n+  \n+  v = make_value_handle (TREE_TYPE (expr));\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    print_creation_to_file (v, expr, vuses);\n+  if (vuses)\n+    VALUE_HANDLE_VUSES (v) = vuses;\n+  return v;\n }\n \n-/* Print out the \"Created value <x> for <Y>\" statement to the\n-   dump_file.\n-   This is factored because both versions of lookup use it, and it\n-   obscures the real work going on in those functions.  */\n+/* Like vn_lookup, but creates a new value for the operation if one\n+   does not exist.  */\n \n-static void\n-print_creation_to_file (tree v, tree expr, VEC (tree, gc) *vuses)\n+tree\n+vn_lookup_or_add (tree expr)\n {\n-  fprintf (dump_file, \"Created value \");\n-  print_generic_expr (dump_file, v, dump_flags);\n-  fprintf (dump_file, \" for \");\n-  print_generic_expr (dump_file, expr, dump_flags);\n+  tree v = vn_lookup (expr);\n   \n-  if (vuses && VEC_length (tree, vuses) != 0)\n+  if (v == NULL_TREE)\n     {\n-      size_t i;\n-      tree vuse;\n-      \n-      fprintf (dump_file, \" vuses: (\");\n-      for (i = 0; VEC_iterate (tree, vuses, i, vuse); i++)\n-\t{\n-\t  print_generic_expr (dump_file, vuse, dump_flags);\n-\t  if (VEC_length (tree, vuses) - 1 != i)\n-\t    fprintf (dump_file, \",\");\n-\t}\n-      fprintf (dump_file, \")\");\n-    }\t\t   \n-  fprintf (dump_file, \"\\n\");\n+      v = create_value_handle_for_expr (expr, NULL);\n+      vn_add (expr, v);\n+    }\n+  else\n+    set_value_handle (expr, v);\n+\n+  return v;\n }\n \n-/* Like vn_lookup, but creates a new value for expression EXPR, if\n-   EXPR doesn't already have a value.  Return the existing/created\n-   value for EXPR.  STMT represents the stmt associated with EXPR.  It\n-   is used when computing the VUSES for EXPR.  */\n+/* Like vn_lookup, but handles reference operations as well by using\n+   STMT to get the set of vuses.  */\n \n tree\n-vn_lookup_or_add (tree expr, tree stmt)\n+vn_lookup_or_add_with_stmt (tree expr, tree stmt)\n {\n-  tree v = vn_lookup (expr, stmt);\n+  tree v;\n+  if (!stmt)\n+    return vn_lookup_or_add (expr);\n+\n+  v = vn_lookup_with_stmt (expr, stmt);\n   if (v == NULL_TREE)\n     {\n-      VEC(tree,gc) *vuses;\n-\n-      v = make_value_handle (TREE_TYPE (expr));\n-      vuses = copy_vuses_from_stmt (stmt);\n-      sort_vuses (vuses);\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tprint_creation_to_file (v, expr, vuses);\n-\n-      VALUE_HANDLE_VUSES (v) = vuses;\n+      VEC (tree, gc) *vuses = copy_vuses_from_stmt (stmt);\n+      v = create_value_handle_for_expr (expr, vuses);\n       vn_add_with_vuses (expr, v, vuses);\n     }\n-\n-  set_value_handle (expr, v);\n+  else\n+    set_value_handle (expr, v);\n \n   return v;\n }\n \n-/* Sort the VUSE array so that we can do equality comparisons\n-   quicker on two vuse vecs.  */\n-\n-void \n-sort_vuses (VEC (tree,gc) *vuses)\n-{\n-  if (VEC_length (tree, vuses) > 1)\n-    qsort (VEC_address (tree, vuses),\n-\t   VEC_length (tree, vuses),\n-\t   sizeof (tree),\n-\t   vuses_compare);\n-}\n-\n /* Like vn_lookup, but creates a new value for expression EXPR, if\n    EXPR doesn't already have a value.  Return the existing/created\n    value for EXPR.  STMT represents the stmt associated with EXPR.  It is used\n@@ -402,40 +391,20 @@ sort_vuses (VEC (tree,gc) *vuses)\n tree\n vn_lookup_or_add_with_vuses (tree expr, VEC (tree, gc) *vuses)\n {\n-  tree v = vn_lookup_with_vuses (expr, vuses);\n+  tree v;\n+  \n+  if (!vuses || VEC_length (tree, vuses) == 0)\n+    return vn_lookup_or_add (expr);\n+  \n+  v = vn_lookup_with_vuses (expr, vuses);\n   if (v == NULL_TREE)\n     {\n-      v = make_value_handle (TREE_TYPE (expr));\n-      sort_vuses (vuses);\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tprint_creation_to_file (v, expr, vuses);\n-\n-      VALUE_HANDLE_VUSES (v) = vuses;\n+      v = create_value_handle_for_expr (expr, vuses);\n       vn_add_with_vuses (expr, v, vuses);\n     }\n-\n-  set_value_handle (expr, v);\n+  else\n+    set_value_handle (expr, v);\n \n   return v;\n }\n \n-/* Initialize data structures used in value numbering.  */\n-\n-void\n-vn_init (void)\n-{\n-  value_table = htab_create (511, val_expr_pair_hash,\n-\t\t\t     val_expr_pair_expr_eq, free);\n-  shared_lookup_vuses = NULL;\n-}\n-\n-/* Delete data used for value numbering.  */\n-\n-void\n-vn_delete (void)\n-{\n-  htab_delete (value_table);\n-  VEC_free (tree, gc, shared_lookup_vuses);\n-  value_table = NULL;\n-}"}]}