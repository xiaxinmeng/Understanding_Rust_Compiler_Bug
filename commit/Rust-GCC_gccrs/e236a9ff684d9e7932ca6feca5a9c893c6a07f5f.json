{"sha": "e236a9ff684d9e7932ca6feca5a9c893c6a07f5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIzNmE5ZmY2ODRkOWU3OTMyY2E2ZmVjYTVhOWM4OTNjNmEwN2Y1Zg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-12-03T05:33:31Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-12-03T05:33:31Z"}, "message": "pa.h: Replace many uses of fprintf with fputs.\n\n        * pa.h: Replace many uses of fprintf with fputs.\n        * pa.c: Likewise.\n        * pa-pro.h: Likewise.\n\n        * pa.h (SECONDARY_RELOAD_CLASS): Don't call secondary_reload_class\n        to handle trivial cases.\n        * pa.c (secondary_reload_class): Rework to be more efficient.\n\nFrom-SVN: r10664", "tree": {"sha": "1c54dd37a7e814fc70e9eb3b41b45bb6560d3c2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c54dd37a7e814fc70e9eb3b41b45bb6560d3c2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e236a9ff684d9e7932ca6feca5a9c893c6a07f5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e236a9ff684d9e7932ca6feca5a9c893c6a07f5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e236a9ff684d9e7932ca6feca5a9c893c6a07f5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e236a9ff684d9e7932ca6feca5a9c893c6a07f5f/comments", "author": null, "committer": null, "parents": [{"sha": "5456dd8ea6c24386380fcbf74afb079654cff063", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5456dd8ea6c24386380fcbf74afb079654cff063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5456dd8ea6c24386380fcbf74afb079654cff063"}], "stats": {"total": 278, "additions": 169, "deletions": 109}, "files": [{"sha": "0bbc44ae347b1eed01cd43b054060de476f9ae8b", "filename": "gcc/config/pa/pa-pro.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e236a9ff684d9e7932ca6feca5a9c893c6a07f5f/gcc%2Fconfig%2Fpa%2Fpa-pro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e236a9ff684d9e7932ca6feca5a9c893c6a07f5f/gcc%2Fconfig%2Fpa%2Fpa-pro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-pro.h?ref=e236a9ff684d9e7932ca6feca5a9c893c6a07f5f", "patch": "@@ -64,19 +64,19 @@ dtors_section ()\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     dtors_section ();                   \t\t\t\t\\\n-    fprintf (FILE, \"\\t.word\\t \");\t\t\t\t\\\n+    fputs (\"\\t.word\\t \", FILE);\t\t\t\t\\\n     assemble_name (FILE, NAME);              \t\t\t\t\\\n-    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+    fputs (\"\\n\", FILE);\t\t\t\t\t\t\\\n   } while (0)\n \n /* A C statement (sans semicolon) to output an element in the table of\n    global constructors.  */\n #define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     ctors_section ();\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t.word\\t \");\t\t\t\t\\\n+    fputs (\"\\t.word\\t \", FILE);\t\t\t\t\\\n     assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+    fputs (\"\\n\", FILE);\t\t\t\t\t\t\\\n   } while (0)\n \n #include \"pa/pa.h\""}, {"sha": "bc10baa63d48db79162aca1b22245d01998a35b2", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 133, "deletions": 77, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e236a9ff684d9e7932ca6feca5a9c893c6a07f5f/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e236a9ff684d9e7932ca6feca5a9c893c6a07f5f/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=e236a9ff684d9e7932ca6feca5a9c893c6a07f5f", "patch": "@@ -1726,7 +1726,7 @@ output_ascii (file, p, size)\n      restriction is in number of input characters (see \\xnn &\n      \\whatever).  So we have to do this very carefully.  */\n \n-  fprintf (file, \"\\t.STRING \\\"\");\n+  fputs (\"\\t.STRING \\\"\", file);\n \n   chars_output = 0;\n   for (i = 0; i < size; i += 4)\n@@ -1758,14 +1758,14 @@ output_ascii (file, p, size)\n \t}\n       if (chars_output + co > 243)\n \t{\n-\t  fprintf (file, \"\\\"\\n\\t.STRING \\\"\");\n+\t  fputs (\"\\\"\\n\\t.STRING \\\"\", file);\n \t  chars_output = 0;\n \t}\n       fwrite (partial_output, 1, co, file);\n       chars_output += co;\n       co = 0;\n     }\n-  fprintf (file, \"\\\"\\n\");\n+  fputs (\"\\\"\\n\", file);\n }\n \f\n /* You may have trouble believing this, but this is the HP-PA stack\n@@ -1983,12 +1983,12 @@ output_function_prologue (file, size)\n      of a function.  */\n   fprintf (file, \"\\t.CALLINFO FRAME=%d\", actual_fsize);\n   if (regs_ever_live[2] || profile_flag)\n-    fprintf (file, \",CALLS,SAVE_RP\");\n+    fputs (\",CALLS,SAVE_RP\", file);\n   else\n-    fprintf (file, \",NO_CALLS\");\n+    fputs (\",NO_CALLS\", file);\n \n   if (frame_pointer_needed)\n-    fprintf (file, \",SAVE_SP\");\n+    fputs (\",SAVE_SP\", file);\n \n   /* Pass on information about the number of callee register saves\n      performed in the prologue.\n@@ -2004,7 +2004,7 @@ output_function_prologue (file, size)\n   if (fr_saved)\n     fprintf (file, \",ENTRY_FR=%d\", fr_saved + 11);\n \n-  fprintf (file, \"\\n\\t.ENTRY\\n\");\n+  fputs (\"\\n\\t.ENTRY\\n\", file);\n \n   /* Horrid hack.  emit_function_prologue will modify this RTL in\n      place to get the expected results.  */\n@@ -2293,9 +2293,9 @@ output_function_epilogue (file, size)\n   /* If insn is a CALL_INSN, then it must be a call to a volatile\n      function (otherwise there would be epilogue insns).  */\n   if (insn && GET_CODE (insn) == CALL_INSN)\n-    fprintf (file, \"\\tnop\\n\");\n+    fputs (\"\\tnop\\n\", file);\n \n-  fprintf (file, \"\\t.EXIT\\n\\t.PROCEND\\n\");\n+  fputs (\"\\t.EXIT\\n\\t.PROCEND\\n\", file);\n \n   /* If we have deferred plabels, then we need to switch into the data\n      section and align it to a 4 byte boundary before we output the\n@@ -2827,25 +2827,25 @@ print_operand (file, x, code)\n       switch (GET_CODE (x))\n \t{\n \tcase EQ:\n-\t  fprintf (file, \"=\");  break;\n+\t  fputs (\"=\", file);  break;\n \tcase NE:\n-\t  fprintf (file, \"<>\");  break;\n+\t  fputs (\"<>\", file);  break;\n \tcase GT:\n-\t  fprintf (file, \">\");  break;\n+\t  fputs (\">\", file);  break;\n \tcase GE:\n-\t  fprintf (file, \">=\");  break;\n+\t  fputs (\">=\", file);  break;\n \tcase GEU:\n-\t  fprintf (file, \">>=\");  break;\n+\t  fputs (\">>=\", file);  break;\n \tcase GTU:\n-\t  fprintf (file, \">>\");  break;\n+\t  fputs (\">>\", file);  break;\n \tcase LT:\n-\t  fprintf (file, \"<\");  break;\n+\t  fputs (\"<\", file);  break;\n \tcase LE:\n-\t  fprintf (file, \"<=\");  break;\n+\t  fputs (\"<=\", file);  break;\n \tcase LEU:\n-\t  fprintf (file, \"<<=\");  break;\n+\t  fputs (\"<<=\", file);  break;\n \tcase LTU:\n-\t  fprintf (file, \"<<\");  break;\n+\t  fputs (\"<<\", file);  break;\n \tdefault:\n \t  abort ();\n \t}\n@@ -2854,25 +2854,25 @@ print_operand (file, x, code)\n       switch (GET_CODE (x))\n \t{\n \tcase EQ:\n-\t  fprintf (file, \"<>\");  break;\n+\t  fputs (\"<>\", file);  break;\n \tcase NE:\n-\t  fprintf (file, \"=\");  break;\n+\t  fputs (\"=\", file);  break;\n \tcase GT:\n-\t  fprintf (file, \"<=\");  break;\n+\t  fputs (\"<=\", file);  break;\n \tcase GE:\n-\t  fprintf (file, \"<\");  break;\n+\t  fputs (\"<\", file);  break;\n \tcase GEU:\n-\t  fprintf (file, \"<<\");  break;\n+\t  fputs (\"<<\", file);  break;\n \tcase GTU:\n-\t  fprintf (file, \"<<=\");  break;\n+\t  fputs (\"<<=\", file);  break;\n \tcase LT:\n-\t  fprintf (file, \">=\");  break;\n+\t  fputs (\">=\", file);  break;\n \tcase LE:\n-\t  fprintf (file, \">\");  break;\n+\t  fputs (\">\", file);  break;\n \tcase LEU:\n-\t  fprintf (file, \">>\");  break;\n+\t  fputs (\">>\", file);  break;\n \tcase LTU:\n-\t  fprintf (file, \">>=\");  break;\n+\t  fputs (\">>=\", file);  break;\n \tdefault:\n \t  abort ();\n \t}\n@@ -2883,17 +2883,17 @@ print_operand (file, x, code)\n       switch (GET_CODE (x))\n \t{\n \tcase EQ:\n-\t  fprintf (file, \"!=\");  break;\n+\t  fputs (\"!=\", file);  break;\n \tcase NE:\n-\t  fprintf (file, \"=\");  break;\n+\t  fputs (\"=\", file);  break;\n \tcase GT:\n-\t  fprintf (file, \"!>\");  break;\n+\t  fputs (\"!>\", file);  break;\n \tcase GE:\n-\t  fprintf (file, \"!>=\");  break;\n+\t  fputs (\"!>=\", file);  break;\n \tcase LT:\n-\t  fprintf (file, \"!<\");  break;\n+\t  fputs (\"!<\", file);  break;\n \tcase LE:\n-\t  fprintf (file, \"!<=\");  break;\n+\t  fputs (\"!<=\", file);  break;\n \tdefault:\n \t  abort ();\n \t}\n@@ -2904,17 +2904,17 @@ print_operand (file, x, code)\n       switch (GET_CODE (x))\n \t{\n \tcase EQ:\n-\t  fprintf (file, \"?=\");  break;\n+\t  fputs (\"?=\", file);  break;\n \tcase NE:\n-\t  fprintf (file, \"!?=\");  break;\n+\t  fputs (\"!?=\", file);  break;\n \tcase GT:\n-\t  fprintf (file, \"!<=\");  break;\n+\t  fputs (\"!<=\", file);  break;\n \tcase GE:\n-\t  fprintf (file, \"!<\");  break;\n+\t  fputs (\"!<\", file);  break;\n \tcase LT:\n-\t  fprintf (file, \"!>=\");  break;\n+\t  fputs (\"!>=\", file);  break;\n \tcase LE:\n-\t  fprintf (file, \"!>\");  break;\n+\t  fputs (\"!>\", file);  break;\n \tdefault:\n \t  abort ();\n \t}\n@@ -2923,25 +2923,25 @@ print_operand (file, x, code)\n       switch (GET_CODE (x))\n \t{\n \tcase EQ:\n-\t  fprintf (file, \"=\");  break;\n+\t  fputs (\"=\", file);  break;\n \tcase NE:\n-\t  fprintf (file, \"<>\");  break;\n+\t  fputs (\"<>\", file);  break;\n \tcase GT:\n-\t  fprintf (file, \"<\");  break;\n+\t  fputs (\"<\", file);  break;\n \tcase GE:\n-\t  fprintf (file, \"<=\");  break;\n+\t  fputs (\"<=\", file);  break;\n \tcase GEU:\n-\t  fprintf (file, \"<<=\");  break;\n+\t  fputs (\"<<=\", file);  break;\n \tcase GTU:\n-\t  fprintf (file, \"<<\");  break;\n+\t  fputs (\"<<\", file);  break;\n \tcase LT:\n-\t  fprintf (file, \">\");  break;\n+\t  fputs (\">\", file);  break;\n \tcase LE:\n-\t  fprintf (file, \">=\");  break;\n+\t  fputs (\">=\", file);  break;\n \tcase LEU:\n-\t  fprintf (file, \">>=\");  break;\n+\t  fputs (\">>=\", file);  break;\n \tcase LTU:\n-\t  fprintf (file, \">>\");  break;\n+\t  fputs (\">>\", file);  break;\n \tdefault:\n \t  abort ();\n \t}\n@@ -2950,25 +2950,25 @@ print_operand (file, x, code)\n       switch (GET_CODE (x))\n \t{\n \tcase EQ:\n-\t  fprintf (file, \"<>\");  break;\n+\t  fputs (\"<>\", file);  break;\n \tcase NE:\n-\t  fprintf (file, \"=\");  break;\n+\t  fputs (\"=\", file);  break;\n \tcase GT:\n-\t  fprintf (file, \">=\");  break;\n+\t  fputs (\">=\", file);  break;\n \tcase GE:\n-\t  fprintf (file, \">\");  break;\n+\t  fputs (\">\", file);  break;\n \tcase GEU:\n-\t  fprintf (file, \">>\");  break;\n+\t  fputs (\">>\", file);  break;\n \tcase GTU:\n-\t  fprintf (file, \">>=\");  break;\n+\t  fputs (\">>=\", file);  break;\n \tcase LT:\n-\t  fprintf (file, \"<=\");  break;\n+\t  fputs (\"<=\", file);  break;\n \tcase LE:\n-\t  fprintf (file, \"<\");  break;\n+\t  fputs (\"<\", file);  break;\n \tcase LEU:\n-\t  fprintf (file, \"<<\");  break;\n+\t  fputs (\"<<\", file);  break;\n \tcase LTU:\n-\t  fprintf (file, \"<<=\");  break;\n+\t  fputs (\"<<=\", file);  break;\n \tdefault:\n \t  abort ();\n \t}\n@@ -3010,11 +3010,11 @@ print_operand (file, x, code)\n \t{\n \tcase PRE_DEC:\n \tcase PRE_INC:\n-\t  fprintf (file, \"s,mb\");\n+\t  fputs (\"s,mb\", file);\n \t  break;\n \tcase POST_DEC:\n \tcase POST_INC:\n-\t  fprintf (file, \"s,ma\");\n+\t  fputs (\"s,ma\", file);\n \t  break;\n \tdefault:\n \t  break;\n@@ -3025,11 +3025,11 @@ print_operand (file, x, code)\n \t{\n \tcase PRE_DEC:\n \tcase PRE_INC:\n-\t  fprintf (file, \",mb\");\n+\t  fputs (\",mb\", file);\n \t  break;\n \tcase POST_DEC:\n \tcase POST_INC:\n-\t  fprintf (file, \",ma\");\n+\t  fputs (\",ma\", file);\n \t  break;\n \tdefault:\n \t  break;\n@@ -3101,7 +3101,7 @@ output_global_address (file, x, round_constant)\n   else if (GET_CODE (x) == SYMBOL_REF && !flag_pic)\n     {\n       assemble_name (file, XSTR (x, 0));\n-      fprintf (file, \"-$global$\");\n+      fputs (\"-$global$\", file);\n     }\n   else if (GET_CODE (x) == CONST)\n     {\n@@ -3155,7 +3155,7 @@ output_global_address (file, x, round_constant)\n       else abort ();\n \n       if (!read_only_operand (base) && !flag_pic)\n-\tfprintf (file, \"-$global$\");\n+\tfputs (\"-$global$\", file);\n       if (offset)\n \tfprintf (file,\"%s%d\", sep, offset);\n     }\n@@ -3341,8 +3341,8 @@ output_arg_descriptor (call_insn)\n      if using the portable runtime calling conventions.  */\n   if (TARGET_PORTABLE_RUNTIME)\n     {\n-      fprintf (asm_out_file,\n-\t       \"\\t.CALL ARGW0=NO,ARGW1=NO,ARGW2=NO,ARGW3=NO,RETVAL=NO\\n\");\n+      fputs (\"\\t.CALL ARGW0=NO,ARGW1=NO,ARGW2=NO,ARGW3=NO,RETVAL=NO\\n\",\n+\t     asm_out_file);\n       return;\n     }\n \n@@ -3394,16 +3394,23 @@ output_arg_descriptor (call_insn)\n   fputc ('\\n', asm_out_file);\n }\n \f\n-/* Memory loads/stores to/from the shift need to go through\n-   the general registers.  */\n+/* Return the class of any secondary reload register that is needed to\n+   move IN into a register in class CLASS using mode MODE.\n+\n+   Profiling has showed this routine and its descendants account for\n+   a significant amount of compile time (~7%).  So it has been\n+   optimized to reduce redundant computations and eliminate useless\n+   function calls.\n+\n+   It might be worthwhile to try and make this a leaf function too.  */\n \n enum reg_class\n secondary_reload_class (class, mode, in)\n      enum reg_class class;\n      enum machine_mode mode;\n      rtx in;\n {\n-  int regno = true_regnum (in);\n+  int regno, is_symbolic;\n \n   /* Trying to load a constant into a FP register during PIC code\n      generation will require %r1 as a scratch register.  */\n@@ -3413,6 +3420,34 @@ secondary_reload_class (class, mode, in)\n       && (GET_CODE (in) == CONST_INT || GET_CODE (in) == CONST_DOUBLE))\n     return R1_REGS;\n \n+  /* Profiling showed the PA port spends about 1.3% of its compilation\n+     time in true_regnum from calls inside secondary_reload_class.  */\n+\n+  if (GET_CODE (in) == REG)\n+    {\n+      regno = REGNO (in);\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\tregno = true_regnum (in);\n+    }\n+  else if (GET_CODE (in) == SUBREG)\n+    regno = true_regnum (in);\n+  else\n+    regno = -1;\n+\n+  /* Profiling showed the PA port spends about 1.3% of its compilation\n+     time in true_regnum from calls inside secondary_reload_class.  */\n+\n+  if (GET_CODE (in) == REG)\n+    {\n+      regno = REGNO (in);\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\tregno = true_regnum (in);\n+    }\n+  else if (GET_CODE (in) == SUBREG)\n+    regno = true_regnum (in);\n+  else\n+    regno = -1;\n+\n   if (((regno >= FIRST_PSEUDO_REGISTER || regno == -1)\n        && GET_MODE_CLASS (mode) == MODE_INT\n        && FP_REG_CLASS_P (class))\n@@ -3422,17 +3457,38 @@ secondary_reload_class (class, mode, in)\n   if (GET_CODE (in) == HIGH)\n     in = XEXP (in, 0);\n \n+  /* Profiling has showed GCC spends about 2.6% of its compilation\n+     time in symbolic_operand from calls inside secondary_reload_class.\n+\n+     We use an inline copy and only compute its return value once to avoid\n+     useless work.  */\n+  switch (GET_CODE (in))\n+    {\n+      rtx tmp;\n+\n+      case SYMBOL_REF:\n+      case LABEL_REF:\n+        is_symbolic = 1;\n+        break;\n+      case CONST:\n+\ttmp = XEXP (in, 0);\n+\tis_symbolic = ((GET_CODE (XEXP (tmp, 0)) == SYMBOL_REF\n+\t\t\t|| GET_CODE (XEXP (tmp, 0)) == LABEL_REF)\n+\t\t       && GET_CODE (XEXP (tmp, 1)) == CONST_INT);\n+        break;\n+      default:\n+        is_symbolic = 0;\n+        break;\n+    }\n+  \n   if (!flag_pic\n-      && symbolic_operand (in, VOIDmode)\n+      && is_symbolic\n       && read_only_operand (in))\n     return NO_REGS;\n \n-  if (class != R1_REGS && symbolic_operand (in, VOIDmode))\n+  if (class != R1_REGS && is_symbolic)\n     return R1_REGS;\n \n-  if (GET_CODE (in) == SUBREG)\n-    in = SUBREG_REG (in);\n-\n   return NO_REGS;\n }\n "}, {"sha": "21178b4be66a749060d6c7c431fbcb03e18d6f51", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e236a9ff684d9e7932ca6feca5a9c893c6a07f5f/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e236a9ff684d9e7932ca6feca5a9c893c6a07f5f/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=e236a9ff684d9e7932ca6feca5a9c893c6a07f5f", "patch": "@@ -49,7 +49,7 @@ extern enum processor_type pa_cpu;\n \n /* Print subsidiary information on the compiler version in use.  */\n \n-#define TARGET_VERSION fprintf (stderr, \" (hppa)\");\n+#define TARGET_VERSION fputs (\" (hppa)\", stderr);\n \n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n@@ -702,11 +702,15 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n #define PREFERRED_RELOAD_CLASS(X,CLASS) (CLASS)\n \n /* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly,\n-   NO_REGS is returned.  */\n+   or out of a register in CLASS in MODE.  If it can be done directly\n+   NO_REGS is returned. \n+\n+  Avoid doing any work for the common case calls.  */\n \n #define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n-  secondary_reload_class (CLASS, MODE, IN)\n+  ((CLASS == BASE_REG_CLASS && GET_CODE (IN) == REG\t\t\\\n+    && REGNO (IN) < FIRST_PSEUDO_REGISTER)\t\t\t\\\n+   ? NO_REGS : secondary_reload_class (CLASS, MODE, IN))\n \n /* On the PA it is not possible to directly move data between\n    GENERAL_REGS and FP_REGS.  */\n@@ -1087,11 +1091,11 @@ extern enum cmp_type hppa_branch_type;\n \t\t   fprintf (FILE, \",ARGW%d=GR\", i);\t\t\t\\\n \t       }\t\t\t\t\t\t\t\\\n \t     if (TYPE_MODE (fntype) == DFmode && ! TARGET_SOFT_FLOAT)\t\\\n-\t       fprintf (FILE, \",RTNVAL=FR\");\t\t\t\t\\\n+\t       fputs (\",RTNVAL=FR\", FILE);\t\t\t\t\\\n \t     else if (TYPE_MODE (fntype) == SFmode && ! TARGET_SOFT_FLOAT) \\\n-\t       fprintf (FILE, \",RTNVAL=FU\");\t\t\t\t\\\n+\t       fputs (\",RTNVAL=FU\", FILE);\t\t\t\t\\\n \t     else if (fntype != void_type_node)\t\t\t\t\\\n-\t       fprintf (FILE, \",RTNVAL=GR\");\t\t\t\t\\\n+\t       fputs (\",RTNVAL=GR\", FILE);\t\t\t\t\\\n \t     fputs (\"\\n\", FILE);\t\t\t\t\t\\\n \t   }} while (0)\n \n@@ -1171,17 +1175,17 @@ extern union tree_node *current_function_decl;\n \n #define TRAMPOLINE_TEMPLATE(FILE) \\\n   {\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tldw\t36(0,%%r22),%%r21\\n\");\t\\\n-    fprintf (FILE, \"\\tbb,>=,n\t%%r21,30,.+16\\n\");\t\\\n-    fprintf (FILE, \"\\tdepi\t0,31,2,%%r21\\n\");\t\\\n-    fprintf (FILE, \"\\tldw\t4(0,%%r21),%%r19\\n\");\t\\\n-    fprintf (FILE, \"\\tldw\t0(0,%%r21),%%r21\\n\");\t\\\n-    fprintf (FILE, \"\\tldsid\t(0,%%r21),%%r1\\n\");\t\\\n-    fprintf (FILE, \"\\tmtsp\t%%r1,%%sr0\\n\");\t\t\\\n-    fprintf (FILE, \"\\tbe\t0(%%sr0,%%r21)\\n\");\t\\\n-    fprintf (FILE, \"\\tldw\t40(0,%%r22),%%r29\\n\");\t\\\n-    fprintf (FILE, \"\\t.word\t0\\n\");\t\t\t\\\n-    fprintf (FILE, \"\\t.word\t0\\n\");\t\t\t\\\n+    fputs (\"\\tldw\t36(0,%%r22),%%r21\\n\", FILE);\t\\\n+    fputs (\"\\tbb,>=,n\t%%r21,30,.+16\\n\", FILE);\t\\\n+    fputs (\"\\tdepi\t0,31,2,%%r21\\n\", FILE);\t\t\\\n+    fputs (\"\\tldw\t4(0,%%r21),%%r19\\n\", FILE);\t\\\n+    fputs (\"\\tldw\t0(0,%%r21),%%r21\\n\", FILE);\t\\\n+    fputs (\"\\tldsid\t(0,%%r21),%%r1\\n\", FILE);\t\\\n+    fputs (\"\\tmtsp\t%%r1,%%sr0\\n\", FILE);\t\t\\\n+    fputs (\"\\tbe\t0(%%sr0,%%r21)\\n\", FILE);\t\\\n+    fputs (\"\\tldw\t40(0,%%r22),%%r29\\n\", FILE);\t\\\n+    fputs (\"\\t.word\t0\\n\", FILE);\t\t\t\\\n+    fputs (\"\\t.word\t0\\n\", FILE);\t\t\t\\\n   }\n \n /* Length in units of the trampoline for entering a nested function.\n@@ -1753,14 +1757,14 @@ while (0)\n /* Output at beginning of assembler file.  */\n \n #define ASM_FILE_START(FILE) \\\n-do { fprintf (FILE, \"\\t.SPACE $PRIVATE$\\n\\\n+do { fputs (\"\\t.SPACE $PRIVATE$\\n\\\n \\t.SUBSPA $DATA$,QUAD=1,ALIGN=8,ACCESS=31\\n\\\n \\t.SUBSPA $BSS$,QUAD=1,ALIGN=8,ACCESS=31,ZERO,SORT=82\\n\\\n \\t.SPACE $TEXT$\\n\\\n \\t.SUBSPA $LIT$,QUAD=0,ALIGN=8,ACCESS=44\\n\\\n \\t.SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\\n\\\n \\t.IMPORT $global$,DATA\\n\\\n-\\t.IMPORT $$dyncall,MILLICODE\\n\");\\\n+\\t.IMPORT $$dyncall,MILLICODE\\n\", FILE);\\\n      if (profile_flag)\\\n        fprintf (FILE, \"\\t.IMPORT _mcount, CODE\\n\");\\\n      if (write_symbols != NO_DEBUG) \\\n@@ -1778,7 +1782,7 @@ do { fprintf (FILE, \"\\t.SPACE $PRIVATE$\\n\\\n #define ASM_APP_OFF \"\"\n \n /* We don't yet know how to identify GCC to HP-PA machines.  */\n-#define ASM_IDENTIFY_GCC(FILE) fprintf (FILE, \"; gcc_compiled.:\\n\")\n+#define ASM_IDENTIFY_GCC(FILE) fputs (\"; gcc_compiled.:\\n\", FILE)\n \n /* Output before code.  */\n \n@@ -1982,24 +1986,24 @@ DTORS_SECTION_FUNCTION\n /* This is how to output an assembler line defining an `int' constant.  */\n \n #define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-{ fprintf (FILE, \"\\t.word \");\t\t\t\\\n+{ fputs (\"\\t.word \", FILE);\t\t\t\\\n   if (function_label_operand (VALUE, VOIDmode)\t\\\n       && !TARGET_PORTABLE_RUNTIME)\t\t\\\n-    fprintf (FILE, \"P%%\");\t\t\t\\\n+    fputs (\"P%%\", FILE);\t\t\t\\\n   output_addr_const (FILE, (VALUE));\t\t\\\n-  fprintf (FILE, \"\\n\");}\n+  fputs (\"\\n\", FILE);}\n \n /* Likewise for `short' and `char' constants.  */\n \n #define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.half \"),\t\t\t\\\n+( fputs (\"\\t.half \", FILE),\t\t\t\\\n   output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n+  fputs (\"\\n\", FILE))\n \n #define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+( fputs (\"\\t.byte \", FILE),\t\t\t\\\n   output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n+  fputs (\"\\n\", FILE))\n \n /* This is how to output an assembler line for a numeric constant byte.  */\n "}]}