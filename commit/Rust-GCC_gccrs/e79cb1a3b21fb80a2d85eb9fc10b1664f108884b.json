{"sha": "e79cb1a3b21fb80a2d85eb9fc10b1664f108884b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc5Y2IxYTNiMjFmYjgwYTJkODVlYjlmYzEwYjE2NjRmMTA4ODg0Yg==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana.radhakrishnan@arm.com", "date": "2014-05-08T14:35:40Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2014-05-08T14:35:40Z"}, "message": "Neon intrinsics TLC - remove ML\n\n2014-05-08  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n\t* config/arm/arm_neon.h: Update comment.\n\t* config/arm/neon-docgen.ml: Delete.\n\t* config/arm/neon-gen.ml: Delete.\n\t* doc/arm-neon-intrinsics.texi: Update comment.\n\nFrom-SVN: r210219", "tree": {"sha": "9c00b5949c6089ccc9d37e70ee24324714fcd99d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c00b5949c6089ccc9d37e70ee24324714fcd99d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e79cb1a3b21fb80a2d85eb9fc10b1664f108884b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79cb1a3b21fb80a2d85eb9fc10b1664f108884b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e79cb1a3b21fb80a2d85eb9fc10b1664f108884b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79cb1a3b21fb80a2d85eb9fc10b1664f108884b/comments", "author": null, "committer": null, "parents": [{"sha": "0d0b79a649ac98c868e0341a16d7b23f9cddee70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d0b79a649ac98c868e0341a16d7b23f9cddee70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d0b79a649ac98c868e0341a16d7b23f9cddee70"}], "stats": {"total": 956, "additions": 8, "deletions": 948}, "files": [{"sha": "39aab717dfc1d80efaca47764d44613e48b0d8a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79cb1a3b21fb80a2d85eb9fc10b1664f108884b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79cb1a3b21fb80a2d85eb9fc10b1664f108884b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e79cb1a3b21fb80a2d85eb9fc10b1664f108884b", "patch": "@@ -1,3 +1,10 @@\n+2014-05-08  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+\t* config/arm/arm_neon.h: Update comment.\n+\t* config/arm/neon-docgen.ml: Delete.\n+\t* config/arm/neon-gen.ml: Delete.\n+\t* doc/arm-neon-intrinsics.texi: Update comment.\n+\n 2014-05-08  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \t* config/arm/arm_neon_builtins.def (vadd, vsub): Only define the v2sf"}, {"sha": "af2d3b34e376d3299a9b5359e50fbb716df444d8", "filename": "gcc/config/arm/arm_neon.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79cb1a3b21fb80a2d85eb9fc10b1664f108884b/gcc%2Fconfig%2Farm%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79cb1a3b21fb80a2d85eb9fc10b1664f108884b/gcc%2Fconfig%2Farm%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon.h?ref=e79cb1a3b21fb80a2d85eb9fc10b1664f108884b", "patch": "@@ -1,5 +1,4 @@\n-/* ARM NEON intrinsics include file. This file is generated automatically\n-   using neon-gen.ml.  Please do not edit manually.\n+/* ARM NEON intrinsics include file.\n \n    Copyright (C) 2006-2014 Free Software Foundation, Inc.\n    Contributed by CodeSourcery."}, {"sha": "5788a533e19672207ed59d041df667ef832d1f66", "filename": "gcc/config/arm/neon-docgen.ml", "status": "removed", "additions": 0, "deletions": 424, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0b79a649ac98c868e0341a16d7b23f9cddee70/gcc%2Fconfig%2Farm%2Fneon-docgen.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0b79a649ac98c868e0341a16d7b23f9cddee70/gcc%2Fconfig%2Farm%2Fneon-docgen.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon-docgen.ml?ref=0d0b79a649ac98c868e0341a16d7b23f9cddee70", "patch": "@@ -1,424 +0,0 @@\n-(* ARM NEON documentation generator.\n-\n-   Copyright (C) 2006-2014 Free Software Foundation, Inc.\n-   Contributed by CodeSourcery.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.\n-\n-   This is an O'Caml program.  The O'Caml compiler is available from:\n-\n-     http://caml.inria.fr/\n-\n-   Or from your favourite OS's friendly packaging system. Tested with version\n-   3.09.2, though other versions will probably work too.\n-\n-   Compile with:\n-     ocamlc -c neon.ml\n-     ocamlc -o neon-docgen neon.cmo neon-docgen.ml\n-\n-   Run with:\n-     /path/to/neon-docgen /path/to/gcc/doc/arm-neon-intrinsics.texi\n-*)\n-\n-open Neon\n-\n-(* The combined \"ops\" and \"reinterp\" table.  *)\n-let ops_reinterp = reinterp @ ops\n-\n-(* Helper functions for extracting things from the \"ops\" table.  *)\n-let single_opcode desired_opcode () =\n-  List.fold_left (fun got_so_far ->\n-                  fun row ->\n-                    match row with\n-                      (opcode, _, _, _, _, _) ->\n-                        if opcode = desired_opcode then row :: got_so_far\n-                                                   else got_so_far\n-                 ) [] ops_reinterp\n-\n-let multiple_opcodes desired_opcodes () =\n-  List.fold_left (fun got_so_far ->\n-                  fun desired_opcode ->\n-                    (single_opcode desired_opcode ()) @ got_so_far)\n-                 [] desired_opcodes\n-\n-let ldx_opcode number () =\n-  List.fold_left (fun got_so_far ->\n-                  fun row ->\n-                    match row with\n-                      (opcode, _, _, _, _, _) ->\n-                        match opcode with\n-                          Vldx n | Vldx_lane n | Vldx_dup n when n = number ->\n-                            row :: got_so_far\n-                          | _ -> got_so_far\n-                 ) [] ops_reinterp\n-\n-let stx_opcode number () =\n-  List.fold_left (fun got_so_far ->\n-                  fun row ->\n-                    match row with\n-                      (opcode, _, _, _, _, _) ->\n-                        match opcode with\n-                          Vstx n | Vstx_lane n when n = number ->\n-                            row :: got_so_far\n-                          | _ -> got_so_far\n-                 ) [] ops_reinterp\n-\n-let tbl_opcode () =\n-  List.fold_left (fun got_so_far ->\n-                  fun row ->\n-                    match row with\n-                      (opcode, _, _, _, _, _) ->\n-                        match opcode with\n-                          Vtbl _ -> row :: got_so_far\n-                          | _ -> got_so_far\n-                 ) [] ops_reinterp\n-\n-let tbx_opcode () =\n-  List.fold_left (fun got_so_far ->\n-                  fun row ->\n-                    match row with\n-                      (opcode, _, _, _, _, _) ->\n-                        match opcode with\n-                          Vtbx _ -> row :: got_so_far\n-                          | _ -> got_so_far\n-                 ) [] ops_reinterp\n-\n-(* The groups of intrinsics.  *)\n-let intrinsic_groups =\n-  [ \"Addition\", single_opcode Vadd;\n-    \"Multiplication\", single_opcode Vmul;\n-    \"Multiply-accumulate\", single_opcode Vmla;\n-    \"Multiply-subtract\", single_opcode Vmls;\n-    \"Fused-multiply-accumulate\", single_opcode Vfma;\n-    \"Fused-multiply-subtract\", single_opcode Vfms;\n-    \"Round to integral (to nearest, ties to even)\", single_opcode Vrintn;\n-    \"Round to integral (to nearest, ties away from zero)\", single_opcode Vrinta;\n-    \"Round to integral (towards +Inf)\", single_opcode Vrintp;\n-    \"Round to integral (towards -Inf)\", single_opcode Vrintm;\n-    \"Round to integral (towards 0)\", single_opcode Vrintz;\n-    \"Subtraction\", single_opcode Vsub;\n-    \"Comparison (equal-to)\", single_opcode Vceq;\n-    \"Comparison (greater-than-or-equal-to)\", single_opcode Vcge;\n-    \"Comparison (less-than-or-equal-to)\", single_opcode Vcle;\n-    \"Comparison (greater-than)\", single_opcode Vcgt;\n-    \"Comparison (less-than)\", single_opcode Vclt;\n-    \"Comparison (absolute greater-than-or-equal-to)\", single_opcode Vcage;\n-    \"Comparison (absolute less-than-or-equal-to)\", single_opcode Vcale;\n-    \"Comparison (absolute greater-than)\", single_opcode Vcagt;\n-    \"Comparison (absolute less-than)\", single_opcode Vcalt;\n-    \"Test bits\", single_opcode Vtst;\n-    \"Absolute difference\", single_opcode Vabd;\n-    \"Absolute difference and accumulate\", single_opcode Vaba;\n-    \"Maximum\", single_opcode Vmax;\n-    \"Minimum\", single_opcode Vmin;\n-    \"Pairwise add\", single_opcode Vpadd;\n-    \"Pairwise add, single_opcode widen and accumulate\", single_opcode Vpada;\n-    \"Folding maximum\", single_opcode Vpmax;\n-    \"Folding minimum\", single_opcode Vpmin;\n-    \"Reciprocal step\", multiple_opcodes [Vrecps; Vrsqrts];\n-    \"Vector shift left\", single_opcode Vshl;\n-    \"Vector shift left by constant\", single_opcode Vshl_n;\n-    \"Vector shift right by constant\", single_opcode Vshr_n;\n-    \"Vector shift right by constant and accumulate\", single_opcode Vsra_n;\n-    \"Vector shift right and insert\", single_opcode Vsri;\n-    \"Vector shift left and insert\", single_opcode Vsli;\n-    \"Absolute value\", single_opcode Vabs;\n-    \"Negation\", single_opcode Vneg;\n-    \"Bitwise not\", single_opcode Vmvn;\n-    \"Count leading sign bits\", single_opcode Vcls;\n-    \"Count leading zeros\", single_opcode Vclz;\n-    \"Count number of set bits\", single_opcode Vcnt;\n-    \"Reciprocal estimate\", single_opcode Vrecpe;\n-    \"Reciprocal square-root estimate\", single_opcode Vrsqrte;\n-    \"Get lanes from a vector\", single_opcode Vget_lane;\n-    \"Set lanes in a vector\", single_opcode Vset_lane;\n-    \"Create vector from literal bit pattern\", single_opcode Vcreate;\n-    \"Set all lanes to the same value\",\n-      multiple_opcodes [Vdup_n; Vmov_n; Vdup_lane];\n-    \"Combining vectors\", single_opcode Vcombine;\n-    \"Splitting vectors\", multiple_opcodes [Vget_high; Vget_low];\n-    \"Conversions\", multiple_opcodes [Vcvt; Vcvt_n];\n-    \"Move, single_opcode narrowing\", single_opcode Vmovn;\n-    \"Move, single_opcode long\", single_opcode Vmovl;\n-    \"Table lookup\", tbl_opcode;\n-    \"Extended table lookup\", tbx_opcode;\n-    \"Multiply, lane\", single_opcode Vmul_lane;\n-    \"Long multiply, lane\", single_opcode Vmull_lane;\n-    \"Saturating doubling long multiply, lane\", single_opcode Vqdmull_lane;\n-    \"Saturating doubling multiply high, lane\", single_opcode Vqdmulh_lane;\n-    \"Multiply-accumulate, lane\", single_opcode Vmla_lane;\n-    \"Multiply-subtract, lane\", single_opcode Vmls_lane;\n-    \"Vector multiply by scalar\", single_opcode Vmul_n;\n-    \"Vector long multiply by scalar\", single_opcode Vmull_n;\n-    \"Vector saturating doubling long multiply by scalar\",\n-      single_opcode Vqdmull_n;\n-    \"Vector saturating doubling multiply high by scalar\",\n-      single_opcode Vqdmulh_n;\n-    \"Vector multiply-accumulate by scalar\", single_opcode Vmla_n;\n-    \"Vector multiply-subtract by scalar\", single_opcode Vmls_n;\n-    \"Vector extract\", single_opcode Vext;\n-    \"Reverse elements\", multiple_opcodes [Vrev64; Vrev32; Vrev16];\n-    \"Bit selection\", single_opcode Vbsl;\n-    \"Transpose elements\", single_opcode Vtrn;\n-    \"Zip elements\", single_opcode Vzip;\n-    \"Unzip elements\", single_opcode Vuzp;\n-    \"Element/structure loads, VLD1 variants\", ldx_opcode 1;\n-    \"Element/structure stores, VST1 variants\", stx_opcode 1;\n-    \"Element/structure loads, VLD2 variants\", ldx_opcode 2;\n-    \"Element/structure stores, VST2 variants\", stx_opcode 2;\n-    \"Element/structure loads, VLD3 variants\", ldx_opcode 3;\n-    \"Element/structure stores, VST3 variants\", stx_opcode 3;\n-    \"Element/structure loads, VLD4 variants\", ldx_opcode 4;\n-    \"Element/structure stores, VST4 variants\", stx_opcode 4;\n-    \"Logical operations (AND)\", single_opcode Vand;\n-    \"Logical operations (OR)\", single_opcode Vorr;\n-    \"Logical operations (exclusive OR)\", single_opcode Veor;\n-    \"Logical operations (AND-NOT)\", single_opcode Vbic;\n-    \"Logical operations (OR-NOT)\", single_opcode Vorn;\n-    \"Reinterpret casts\", single_opcode Vreinterp ]\n-\n-(* Given an intrinsic shape, produce a string to document the corresponding\n-   operand shapes.  *)\n-let rec analyze_shape shape =\n-  let rec n_things n thing =\n-    match n with\n-      0 -> []\n-    | n -> thing :: (n_things (n - 1) thing)\n-  in\n-  let rec analyze_shape_elt reg_no elt =\n-    match elt with\n-      Dreg -> \"@var{d\" ^ (string_of_int reg_no) ^ \"}\"\n-    | Qreg -> \"@var{q\" ^ (string_of_int reg_no) ^ \"}\"\n-    | Corereg -> \"@var{r\" ^ (string_of_int reg_no) ^ \"}\"\n-    | Immed -> \"#@var{0}\"\n-    | VecArray (1, elt) ->\n-        let elt_regexp = analyze_shape_elt 0 elt in\n-          \"@{\" ^ elt_regexp ^ \"@}\"\n-    | VecArray (n, elt) ->\n-      let rec f m =\n-        match m with\n-          0 -> []\n-        | m -> (analyze_shape_elt (m - 1) elt) :: (f (m - 1))\n-      in\n-      let ops = List.rev (f n) in\n-        \"@{\" ^ (commas (fun x -> x) ops \"\") ^ \"@}\"\n-    | (PtrTo elt | CstPtrTo elt) ->\n-      \"[\" ^ (analyze_shape_elt reg_no elt) ^ \"]\"\n-    | Element_of_dreg -> (analyze_shape_elt reg_no Dreg) ^ \"[@var{0}]\"\n-    | Element_of_qreg -> (analyze_shape_elt reg_no Qreg) ^ \"[@var{0}]\"\n-    | All_elements_of_dreg -> (analyze_shape_elt reg_no Dreg) ^ \"[]\"\n-    | Alternatives alts -> (analyze_shape_elt reg_no (List.hd alts))\n-  in\n-    match shape with\n-      All (n, elt) -> commas (analyze_shape_elt 0) (n_things n elt) \"\"\n-    | Long -> (analyze_shape_elt 0 Qreg) ^ \", \" ^ (analyze_shape_elt 0 Dreg) ^\n-              \", \" ^ (analyze_shape_elt 0 Dreg)\n-    | Long_noreg elt -> (analyze_shape_elt 0 elt) ^ \", \" ^\n-              (analyze_shape_elt 0 elt)\n-    | Wide -> (analyze_shape_elt 0 Qreg) ^ \", \" ^ (analyze_shape_elt 0 Qreg) ^\n-              \", \" ^ (analyze_shape_elt 0 Dreg)\n-    | Wide_noreg elt -> analyze_shape (Long_noreg elt)\n-    | Narrow -> (analyze_shape_elt 0 Dreg) ^ \", \" ^ (analyze_shape_elt 0 Qreg) ^\n-                \", \" ^ (analyze_shape_elt 0 Qreg)\n-    | Use_operands elts -> commas (analyze_shape_elt 0) (Array.to_list elts) \"\"\n-    | By_scalar Dreg ->\n-        analyze_shape (Use_operands [| Dreg; Dreg; Element_of_dreg |])\n-    | By_scalar Qreg ->\n-        analyze_shape (Use_operands [| Qreg; Qreg; Element_of_dreg |])\n-    | By_scalar _ -> assert false\n-    | Wide_lane ->\n-        analyze_shape (Use_operands [| Qreg; Dreg; Element_of_dreg |])\n-    | Wide_scalar ->\n-        analyze_shape (Use_operands [| Qreg; Dreg; Element_of_dreg |])\n-    | Pair_result elt ->\n-      let elt_regexp = analyze_shape_elt 0 elt in\n-      let elt_regexp' = analyze_shape_elt 1 elt in\n-        elt_regexp ^ \", \" ^ elt_regexp'\n-    | Unary_scalar _ -> \"FIXME Unary_scalar\"\n-    | Binary_imm elt -> analyze_shape (Use_operands [| elt; elt; Immed |])\n-    | Narrow_imm -> analyze_shape (Use_operands [| Dreg; Qreg; Immed |])\n-    | Long_imm -> analyze_shape (Use_operands [| Qreg; Dreg; Immed |])\n-\n-(* Document a single intrinsic.  *)\n-let describe_intrinsic first chan\n-                       (elt_ty, (_, features, shape, name, munge, _)) =\n-  let c_arity, new_elt_ty = munge shape elt_ty in\n-  let c_types = strings_of_arity c_arity in\n-  Printf.fprintf chan \"@itemize @bullet\\n\";\n-  let item_code = if first then \"@item\" else \"@itemx\" in\n-    Printf.fprintf chan \"%s %s %s_%s (\" item_code (List.hd c_types)\n-                   (intrinsic_name name) (string_of_elt elt_ty);\n-    Printf.fprintf chan \"%s)\\n\" (commas (fun ty -> ty) (List.tl c_types) \"\");\n-    if not (List.exists (fun feature -> feature = No_op) features) then\n-    begin\n-      let print_one_insn name =\n-        Printf.fprintf chan \"@code{\";\n-        let no_suffix = (new_elt_ty = NoElts) in\n-        let name_with_suffix =\n-          if no_suffix then name\n-          else name ^ \".\" ^ (string_of_elt_dots new_elt_ty)\n-        in\n-        let possible_operands = analyze_all_shapes features shape\n-                                                   analyze_shape\n-        in\n-\tlet rec print_one_possible_operand op =\n-\t  Printf.fprintf chan \"%s %s}\" name_with_suffix op\n-        in\n-          (* If the intrinsic expands to multiple instructions, we assume\n-             they are all of the same form.  *)\n-          print_one_possible_operand (List.hd possible_operands)\n-      in\n-      let rec print_insns names =\n-        match names with\n-          [] -> ()\n-        | [name] -> print_one_insn name\n-        | name::names -> (print_one_insn name;\n-                          Printf.fprintf chan \" @emph{or} \";\n-                          print_insns names)\n-      in\n-      let insn_names = get_insn_names features name in\n-        Printf.fprintf chan \"@*@emph{Form of expected instruction(s):} \";\n-        print_insns insn_names;\n-        Printf.fprintf chan \"\\n\"\n-    end;\n-    Printf.fprintf chan \"@end itemize\\n\";\n-    Printf.fprintf chan \"\\n\\n\"\n-\n-(* Document a group of intrinsics.  *)\n-let document_group chan (group_title, group_extractor) =\n-  (* Extract the rows in question from the ops table and then turn them\n-     into a list of intrinsics.  *)\n-  let intrinsics =\n-    List.fold_left (fun got_so_far ->\n-                    fun row ->\n-                      match row with\n-                        (_, _, _, _, _, elt_tys) ->\n-                          List.fold_left (fun got_so_far' ->\n-                                          fun elt_ty ->\n-                                            (elt_ty, row) :: got_so_far')\n-                                         got_so_far elt_tys\n-                   ) [] (group_extractor ())\n-  in\n-    (* Emit the title for this group.  *)\n-    Printf.fprintf chan \"@subsubsection %s\\n\\n\" group_title;\n-    (* Emit a description of each intrinsic.  *)\n-    List.iter (describe_intrinsic true chan) intrinsics;\n-    (* Close this group.  *)\n-    Printf.fprintf chan \"\\n\\n\"\n-\n-let gnu_header chan =\n-  List.iter (fun s -> Printf.fprintf chan \"%s\\n\" s) [\n-  \"@c Copyright (C) 2006-2014 Free Software Foundation, Inc.\";\n-  \"@c This is part of the GCC manual.\";\n-  \"@c For copying conditions, see the file gcc.texi.\";\n-  \"\";\n-  \"@c This file is generated automatically using gcc/config/arm/neon-docgen.ml\";\n-  \"@c Please do not edit manually.\"]\n-\n-let crypto_doc =\n-\"\n-@itemize @bullet\n-@item poly128_t vldrq_p128(poly128_t const *)\n-@end itemize\n-\n-@itemize @bullet\n-@item void vstrq_p128(poly128_t *, poly128_t)\n-@end itemize\n-\n-@itemize @bullet\n-@item uint64x1_t vceq_p64 (poly64x1_t, poly64x1_t)\n-@end itemize\n-\n-@itemize @bullet\n-@item uint64x1_t vtst_p64 (poly64x1_t, poly64x1_t)\n-@end itemize\n-\n-@itemize @bullet\n-@item uint32_t vsha1h_u32 (uint32_t)\n-@*@emph{Form of expected instruction(s):} @code{sha1h.32 @var{q0}, @var{q1}}\n-@end itemize\n-\n-@itemize @bullet\n-@item uint32x4_t vsha1cq_u32 (uint32x4_t, uint32_t, uint32x4_t)\n-@*@emph{Form of expected instruction(s):} @code{sha1c.32 @var{q0}, @var{q1}, @var{q2}}\n-@end itemize\n-\n-@itemize @bullet\n-@item uint32x4_t vsha1pq_u32 (uint32x4_t, uint32_t, uint32x4_t)\n-@*@emph{Form of expected instruction(s):} @code{sha1p.32 @var{q0}, @var{q1}, @var{q2}}\n-@end itemize\n-\n-@itemize @bullet\n-@item uint32x4_t vsha1mq_u32 (uint32x4_t, uint32_t, uint32x4_t)\n-@*@emph{Form of expected instruction(s):} @code{sha1m.32 @var{q0}, @var{q1}, @var{q2}}\n-@end itemize\n-\n-@itemize @bullet\n-@item uint32x4_t vsha1su0q_u32 (uint32x4_t, uint32x4_t, uint32x4_t)\n-@*@emph{Form of expected instruction(s):} @code{sha1su0.32 @var{q0}, @var{q1}, @var{q2}}\n-@end itemize\n-\n-@itemize @bullet\n-@item uint32x4_t vsha1su1q_u32 (uint32x4_t, uint32x4_t)\n-@*@emph{Form of expected instruction(s):} @code{sha1su1.32 @var{q0}, @var{q1}, @var{q2}}\n-@end itemize\n-\n-@itemize @bullet\n-@item uint32x4_t vsha256hq_u32 (uint32x4_t, uint32x4_t, uint32x4_t)\n-@*@emph{Form of expected instruction(s):} @code{sha256h.32 @var{q0}, @var{q1}, @var{q2}}\n-@end itemize\n- \n-@itemize @bullet\n-@item uint32x4_t vsha256h2q_u32 (uint32x4_t, uint32x4_t, uint32x4_t)\n-@*@emph{Form of expected instruction(s):} @code{sha256h2.32 @var{q0}, @var{q1}, @var{q2}}\n-@end itemize\n- \n-@itemize @bullet\n-@item uint32x4_t vsha256su0q_u32 (uint32x4_t, uint32x4_t)\n-@*@emph{Form of expected instruction(s):} @code{sha256su0.32 @var{q0}, @var{q1}}\n-@end itemize\n- \n-@itemize @bullet\n-@item uint32x4_t vsha256su1q_u32 (uint32x4_t, uint32x4_t, uint32x4_t)\n-@*@emph{Form of expected instruction(s):} @code{sha256su1.32 @var{q0}, @var{q1}, @var{q2}}\n-@end itemize\n-\n-@itemize @bullet\n-@item poly128_t vmull_p64 (poly64_t a, poly64_t b)\n-@*@emph{Form of expected instruction(s):} @code{vmull.p64 @var{q0}, @var{d1}, @var{d2}}\n-@end itemize\n-\n-@itemize @bullet\n-@item poly128_t vmull_high_p64 (poly64x2_t a, poly64x2_t b)\n-@*@emph{Form of expected instruction(s):} @code{vmull.p64 @var{q0}, @var{d1}, @var{d2}}\n-@end itemize\n-\"\n-\n-(* Program entry point.  *)\n-let _ =\n-  if Array.length Sys.argv <> 2 then\n-    failwith \"Usage: neon-docgen <output filename>\"\n-  else\n-  let file = Sys.argv.(1) in\n-    try\n-      let chan = open_out file in\n-        gnu_header chan;\n-        List.iter (document_group chan) intrinsic_groups;\n-        Printf.fprintf chan \"%s\\n\" crypto_doc;\n-        close_out chan\n-    with Sys_error sys ->\n-      failwith (\"Could not create output file \" ^ file ^ \": \" ^ sys)"}, {"sha": "f3dd86b0ace32a6052236e3194679657d6230f56", "filename": "gcc/config/arm/neon-gen.ml", "status": "removed", "additions": 0, "deletions": 520, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0b79a649ac98c868e0341a16d7b23f9cddee70/gcc%2Fconfig%2Farm%2Fneon-gen.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0b79a649ac98c868e0341a16d7b23f9cddee70/gcc%2Fconfig%2Farm%2Fneon-gen.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon-gen.ml?ref=0d0b79a649ac98c868e0341a16d7b23f9cddee70", "patch": "@@ -1,520 +0,0 @@\n-(* Auto-generate ARM Neon intrinsics header file.\n-   Copyright (C) 2006-2014 Free Software Foundation, Inc.\n-   Contributed by CodeSourcery.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.\n-\n-   This is an O'Caml program.  The O'Caml compiler is available from:\n-\n-     http://caml.inria.fr/\n-\n-   Or from your favourite OS's friendly packaging system. Tested with version\n-   3.09.2, though other versions will probably work too.\n-\n-   Compile with:\n-     ocamlc -c neon.ml\n-     ocamlc -o neon-gen neon.cmo neon-gen.ml\n-\n-   Run with:\n-     ./neon-gen > arm_neon.h\n-*)\n-\n-open Neon\n-\n-(* The format codes used in the following functions are documented at:\n-     http://caml.inria.fr/pub/docs/manual-ocaml/libref/Format.html\\\n-     #6_printflikefunctionsforprettyprinting\n-   (one line, remove the backslash.)\n-*)\n-\n-(* Following functions can be used to approximate GNU indentation style.  *)\n-let start_function () =\n-  Format.printf \"@[<v 0>\";\n-  ref 0\n-\n-let end_function nesting =\n-  match !nesting with\n-    0 -> Format.printf \"@;@;@]\"\n-  | _ -> failwith (\"Bad nesting (ending function at level \"\n-                   ^ (string_of_int !nesting) ^ \")\")\n-\n-let open_braceblock nesting =\n-  begin match !nesting with\n-    0 -> Format.printf \"@,@<0>{@[<v 2>@,\"\n-  | _ -> Format.printf \"@,@[<v 2>  @<0>{@[<v 2>@,\"\n-  end;\n-  incr nesting\n-\n-let close_braceblock nesting =\n-  decr nesting;\n-  match !nesting with\n-    0 -> Format.printf \"@]@,@<0>}\"\n-  | _ -> Format.printf \"@]@,@<0>}@]\"\n-\n-let print_function arity fnname body =\n-  let ffmt = start_function () in\n-  Format.printf \"__extension__ static __inline \";\n-  let inl = \"__attribute__ ((__always_inline__))\" in\n-  begin match arity with\n-    Arity0 ret ->\n-      Format.printf \"%s %s@,%s (void)\" (string_of_vectype ret) inl fnname\n-  | Arity1 (ret, arg0) ->\n-      Format.printf \"%s %s@,%s (%s __a)\" (string_of_vectype ret) inl fnname\n-                                        (string_of_vectype arg0)\n-  | Arity2 (ret, arg0, arg1) ->\n-      Format.printf \"%s %s@,%s (%s __a, %s __b)\"\n-        (string_of_vectype ret) inl fnname (string_of_vectype arg0)\n-\t(string_of_vectype arg1)\n-  | Arity3 (ret, arg0, arg1, arg2) ->\n-      Format.printf \"%s %s@,%s (%s __a, %s __b, %s __c)\"\n-        (string_of_vectype ret) inl fnname (string_of_vectype arg0)\n-\t(string_of_vectype arg1) (string_of_vectype arg2)\n-  | Arity4 (ret, arg0, arg1, arg2, arg3) ->\n-      Format.printf \"%s %s@,%s (%s __a, %s __b, %s __c, %s __d)\"\n-        (string_of_vectype ret) inl fnname (string_of_vectype arg0)\n-\t(string_of_vectype arg1) (string_of_vectype arg2)\n-        (string_of_vectype arg3)\n-  end;\n-  open_braceblock ffmt;\n-  let rec print_lines = function\n-    []       -> ()\n-  | \"\" :: lines -> print_lines lines\n-  | [line] -> Format.printf \"%s\" line\n-  | line::lines -> Format.printf \"%s@,\" line ; print_lines lines in\n-  print_lines body;\n-  close_braceblock ffmt;\n-  end_function ffmt\n-\n-let union_string num elts base =\n-  let itype = inttype_for_array num elts in\n-  let iname = string_of_inttype itype\n-  and sname = string_of_vectype (T_arrayof (num, elts)) in\n-  Printf.sprintf \"union { %s __i; %s __o; } %s\" sname iname base\n-\n-let rec signed_ctype = function\n-    T_uint8x8 | T_poly8x8 -> T_int8x8\n-  | T_uint8x16 | T_poly8x16 -> T_int8x16\n-  | T_uint16x4 | T_poly16x4 -> T_int16x4\n-  | T_uint16x8 | T_poly16x8 -> T_int16x8\n-  | T_uint32x2 -> T_int32x2\n-  | T_uint32x4 -> T_int32x4\n-  | T_uint64x1 -> T_int64x1\n-  | T_uint64x2 -> T_int64x2\n-  | T_poly64x2 -> T_int64x2\n-  (* Cast to types defined by mode in arm.c, not random types pulled in from\n-     the <stdint.h> header in use. This fixes incompatible pointer errors when\n-     compiling with C++.  *)\n-  | T_uint8 | T_int8 -> T_intQI\n-  | T_uint16 | T_int16 -> T_intHI\n-  | T_uint32 | T_int32 -> T_intSI\n-  | T_uint64 | T_int64 -> T_intDI\n-  | T_float16 -> T_floatHF\n-  | T_float32 -> T_floatSF\n-  | T_poly8 -> T_intQI\n-  | T_poly16 -> T_intHI\n-  | T_poly64 -> T_intDI\n-  | T_poly128 -> T_intTI\n-  | T_arrayof (n, elt) -> T_arrayof (n, signed_ctype elt)\n-  | T_ptrto elt -> T_ptrto (signed_ctype elt)\n-  | T_const elt -> T_const (signed_ctype elt)\n-  | x -> x\n-\n-let add_cast ctype cval =\n-  let stype = signed_ctype ctype in\n-  if ctype <> stype then\n-    Printf.sprintf \"(%s) %s\" (string_of_vectype stype) cval\n-  else\n-    cval\n-\n-let cast_for_return to_ty = \"(\" ^ (string_of_vectype to_ty) ^ \")\"\n-\n-(* Return a tuple of a list of declarations to go at the start of the function,\n-   and a list of statements needed to return THING.  *)\n-let return arity thing =\n-  match arity with\n-    Arity0 (ret) | Arity1 (ret, _) | Arity2 (ret, _, _) | Arity3 (ret, _, _, _)\n-  | Arity4 (ret, _, _, _, _) ->\n-      begin match ret with\n-\tT_arrayof (num, vec) ->\n-          let uname = union_string num vec \"__rv\" in\n-          [uname ^ \";\"], [\"__rv.__o = \" ^ thing ^ \";\"; \"return __rv.__i;\"]\n-      | T_void ->\n-\t  [], [thing ^ \";\"]\n-      | _ ->\n-\t  [], [\"return \" ^ (cast_for_return ret) ^ thing ^ \";\"]\n-      end\n-\n-let mask_shape_for_shuffle = function\n-    All (num, reg) -> All (num, reg)\n-  | Pair_result reg -> All (2, reg)\n-  | _ -> failwith \"mask_for_shuffle\"\n-\n-let mask_elems shuffle shape elttype part =\n-  let elem_size = elt_width elttype in\n-  let num_elems =\n-    match regmap shape 0 with\n-      Dreg -> 64 / elem_size\n-    | Qreg -> 128 / elem_size\n-    | _ -> failwith \"mask_elems\" in\n-  shuffle elem_size num_elems part\n-\n-(* Return a tuple of a list of declarations 0and a list of statements needed\n-   to implement an intrinsic using __builtin_shuffle.  SHUFFLE is a function\n-   which returns a list of elements suitable for using as a mask.  *)\n-\n-let shuffle_fn shuffle shape arity elttype =\n-  let mshape = mask_shape_for_shuffle shape in\n-  let masktype = type_for_elt mshape (unsigned_of_elt elttype) 0 in\n-  let masktype_str = string_of_vectype masktype in\n-  let shuffle_res = type_for_elt mshape elttype 0 in\n-  let shuffle_res_str = string_of_vectype shuffle_res in\n-  match arity with\n-    Arity0 (ret) | Arity1 (ret, _) | Arity2 (ret, _, _) | Arity3 (ret, _, _, _)\n-  | Arity4 (ret, _, _, _, _) ->\n-      begin match ret with\n-        T_arrayof (num, vec) ->\n-\t  let elems1 = mask_elems shuffle mshape elttype `lo\n-\t  and elems2 = mask_elems shuffle mshape elttype `hi in\n-\t  let mask1 = (String.concat \", \" (List.map string_of_int elems1))\n-\t  and mask2 = (String.concat \", \" (List.map string_of_int elems2)) in\n-\t  let shuf1 = Printf.sprintf\n-\t    \"__rv.val[0] = (%s) __builtin_shuffle (__a, __b, (%s) { %s });\"\n-\t    shuffle_res_str masktype_str mask1\n-\t  and shuf2 = Printf.sprintf\n-\t    \"__rv.val[1] = (%s) __builtin_shuffle (__a, __b, (%s) { %s });\"\n-\t    shuffle_res_str masktype_str mask2 in\n-\t  [Printf.sprintf \"%s __rv;\" (string_of_vectype ret);],\n-\t  [shuf1; shuf2; \"return __rv;\"]\n-      | _ ->\n-          let elems = mask_elems shuffle mshape elttype `lo in\n-          let mask =  (String.concat \", \" (List.map string_of_int elems)) in\n-\t  let shuf = Printf.sprintf\n-\t    \"return (%s) __builtin_shuffle (__a, (%s) { %s });\" shuffle_res_str masktype_str mask in\n-\t  [\"\"],\n-\t  [shuf]\n-      end\n-\n-let rec element_type ctype =\n-  match ctype with\n-    T_arrayof (_, v) -> element_type v\n-  | _ -> ctype\n-\n-let params ps =\n-  let pdecls = ref [] in\n-  let ptype t p =\n-    match t with\n-      T_arrayof (num, elts) ->\n-        let uname = union_string num elts (p ^ \"u\") in\n-        let decl = Printf.sprintf \"%s = { %s };\" uname p in\n-        pdecls := decl :: !pdecls;\n-        p ^ \"u.__o\"\n-    | _ -> add_cast t p in\n-  let plist = match ps with\n-    Arity0 _ -> []\n-  | Arity1 (_, t1) -> [ptype t1 \"__a\"]\n-  | Arity2 (_, t1, t2) -> [ptype t1 \"__a\"; ptype t2 \"__b\"]\n-  | Arity3 (_, t1, t2, t3) -> [ptype t1 \"__a\"; ptype t2 \"__b\"; ptype t3 \"__c\"]\n-  | Arity4 (_, t1, t2, t3, t4) ->\n-      [ptype t1 \"__a\"; ptype t2 \"__b\"; ptype t3 \"__c\"; ptype t4 \"__d\"] in\n-  !pdecls, plist\n-\n-let modify_params features plist =\n-  let is_flipped =\n-    List.exists (function Flipped _ -> true | _ -> false) features in\n-  if is_flipped then\n-    match plist with\n-      [ a; b ] -> [ b; a ]\n-    | _ ->\n-      failwith (\"Don't know how to flip args \" ^ (String.concat \", \" plist))\n-  else\n-    plist\n-\n-(* !!! Decide whether to add an extra information word based on the shape\n-   form.  *)\n-let extra_word shape features paramlist bits =\n-  let use_word =\n-    match shape with\n-      All _ | Long | Long_noreg _ | Wide | Wide_noreg _ | Narrow\n-    | By_scalar _ | Wide_scalar | Wide_lane | Binary_imm _ | Long_imm\n-    | Narrow_imm -> true\n-    | _ -> List.mem InfoWord features\n-  in\n-    if use_word then\n-      paramlist @ [string_of_int bits]\n-    else\n-      paramlist\n-\n-(* Bit 0 represents signed (1) vs unsigned (0), or float (1) vs poly (0).\n-   Bit 1 represents floats & polynomials (1), or ordinary integers (0).\n-   Bit 2 represents rounding (1) vs none (0).  *)\n-let infoword_value elttype features =\n-  let bits01 =\n-    match elt_class elttype with\n-      Signed | ConvClass (Signed, _) | ConvClass (_, Signed) -> 0b001\n-    | Poly -> 0b010\n-    | Float -> 0b011\n-    | _ -> 0b000\n-  and rounding_bit = if List.mem Rounding features then 0b100 else 0b000 in\n-  bits01 lor rounding_bit\n-\n-(* \"Cast\" type operations will throw an exception in mode_of_elt (actually in\n-   elt_width, called from there). Deal with that here, and generate a suffix\n-   with multiple modes (<to><from>).  *)\n-let rec mode_suffix elttype shape =\n-  try\n-    let mode = mode_of_elt elttype shape in\n-    string_of_mode mode\n-  with MixedMode (dst, src) ->\n-    let dstmode = mode_of_elt ~argpos:0 dst shape\n-    and srcmode = mode_of_elt ~argpos:1 src shape in\n-    string_of_mode dstmode ^ string_of_mode srcmode\n-\n-let get_shuffle features =\n-  try\n-    match List.find (function Use_shuffle _ -> true | _ -> false) features with\n-      Use_shuffle fn -> Some fn\n-    | _ -> None\n-  with Not_found -> None\n-\n-let print_feature_test_start features =\n-  try\n-    match List.find (fun feature ->\n-                       match feature with Requires_feature _ -> true\n-                                        | Requires_arch _ -> true\n-                                        | Requires_FP_bit _ -> true\n-                                        | _ -> false)\n-                     features with\n-      Requires_feature feature ->\n-        Format.printf \"#ifdef __ARM_FEATURE_%s@\\n\" feature\n-    | Requires_arch arch ->\n-        Format.printf \"#if __ARM_ARCH >= %d@\\n\" arch\n-    | Requires_FP_bit bit ->\n-        Format.printf \"#if ((__ARM_FP & 0x%X) != 0)@\\n\"\n-                      (1 lsl bit)\n-    | _ -> assert false\n-  with Not_found -> assert true\n-\n-let print_feature_test_end features =\n-  let feature =\n-    List.exists (function Requires_feature _ -> true\n-                          | Requires_arch _ -> true\n-                          | Requires_FP_bit _ -> true\n-                          |  _ -> false) features in\n-  if feature then Format.printf \"#endif@\\n\"\n-\n-\n-let print_variant opcode features shape name (ctype, asmtype, elttype) =\n-  let bits = infoword_value elttype features in\n-  let modesuf = mode_suffix elttype shape in\n-  let pdecls, paramlist = params ctype in\n-  let rdecls, stmts =\n-    match get_shuffle features with\n-      Some shuffle -> shuffle_fn shuffle shape ctype elttype\n-    | None ->\n-\tlet paramlist' = modify_params features paramlist in\n-\tlet paramlist'' = extra_word shape features paramlist' bits in\n-\tlet parstr = String.concat \", \" paramlist'' in\n-\tlet builtin = Printf.sprintf \"__builtin_neon_%s%s (%s)\"\n-                \t(builtin_name features name) modesuf parstr in\n-\treturn ctype builtin in\n-  let body = pdecls @ rdecls @ stmts\n-  and fnname = (intrinsic_name name) ^ \"_\" ^ (string_of_elt elttype) in\n-  begin\n-    print_feature_test_start features;\n-    print_function ctype fnname body;\n-    print_feature_test_end features;\n-  end\n-\n-(* When this function processes the element types in the ops table, it rewrites\n-   them in a list of tuples (a,b,c):\n-     a : C type as an \"arity\", e.g. Arity1 (T_poly8x8, T_poly8x8)\n-     b : Asm type : a single, processed element type, e.g. P16. This is the\n-         type which should be attached to the asm opcode.\n-     c : Variant type : the unprocessed type for this variant (e.g. in add\n-         instructions which don't care about the sign, b might be i16 and c\n-         might be s16.)\n-*)\n-\n-let print_op (opcode, features, shape, name, munge, types) =\n-  let sorted_types = List.sort compare types in\n-  let munged_types = List.map\n-    (fun elt -> let c, asm = munge shape elt in c, asm, elt) sorted_types in\n-  List.iter\n-    (fun variant -> print_variant opcode features shape name variant)\n-    munged_types\n-\n-let print_ops ops =\n-  List.iter print_op ops\n-\n-(* Output type definitions. Table entries are:\n-     cbase : \"C\" name for the type.\n-     abase : \"ARM\" base name for the type (i.e. int in int8x8_t).\n-     esize : element size.\n-     enum : element count.\n-     alevel: architecture level at which available.\n-*)\n-\n-type fpulevel = CRYPTO | ALL\n-\n-let deftypes () =\n-  let typeinfo = [\n-    (* Doubleword vector types.  *)\n-    \"__builtin_neon_qi\", \"int\", 8, 8, ALL;\n-    \"__builtin_neon_hi\", \"int\", 16, 4, ALL;\n-    \"__builtin_neon_si\", \"int\", 32, 2, ALL;\n-    \"__builtin_neon_di\", \"int\", 64, 1, ALL;\n-    \"__builtin_neon_hf\", \"float\", 16, 4, ALL;\n-    \"__builtin_neon_sf\", \"float\", 32, 2, ALL;\n-    \"__builtin_neon_poly8\", \"poly\", 8, 8, ALL;\n-    \"__builtin_neon_poly16\", \"poly\", 16, 4, ALL;\n-    \"__builtin_neon_poly64\", \"poly\", 64, 1, CRYPTO;\n-    \"__builtin_neon_uqi\", \"uint\", 8, 8, ALL;\n-    \"__builtin_neon_uhi\", \"uint\", 16, 4, ALL;\n-    \"__builtin_neon_usi\", \"uint\", 32, 2, ALL;\n-    \"__builtin_neon_udi\", \"uint\", 64, 1, ALL;\n-\n-    (* Quadword vector types.  *)\n-    \"__builtin_neon_qi\", \"int\", 8, 16, ALL;\n-    \"__builtin_neon_hi\", \"int\", 16, 8, ALL;\n-    \"__builtin_neon_si\", \"int\", 32, 4, ALL;\n-    \"__builtin_neon_di\", \"int\", 64, 2, ALL;\n-    \"__builtin_neon_sf\", \"float\", 32, 4, ALL;\n-    \"__builtin_neon_poly8\", \"poly\", 8, 16, ALL;\n-    \"__builtin_neon_poly16\", \"poly\", 16, 8, ALL;\n-    \"__builtin_neon_poly64\", \"poly\", 64, 2, CRYPTO;\n-    \"__builtin_neon_uqi\", \"uint\", 8, 16, ALL;\n-    \"__builtin_neon_uhi\", \"uint\", 16, 8, ALL;\n-    \"__builtin_neon_usi\", \"uint\", 32, 4, ALL;\n-    \"__builtin_neon_udi\", \"uint\", 64, 2, ALL\n-  ] in\n-  List.iter\n-    (fun (cbase, abase, esize, enum, fpulevel) ->\n-      let attr =\n-        match enum with\n-          1 -> \"\"\n-        | _ -> Printf.sprintf \"\\t__attribute__ ((__vector_size__ (%d)))\"\n-                              (esize * enum / 8) in\n-      if fpulevel == CRYPTO then\n-        Format.printf \"#ifdef __ARM_FEATURE_CRYPTO\\n\";\n-      Format.printf \"typedef %s %s%dx%d_t%s;@\\n\" cbase abase esize enum attr;\n-      if fpulevel == CRYPTO then\n-        Format.printf \"#endif\\n\";)\n-    typeinfo;\n-  Format.print_newline ();\n-  (* Extra types not in <stdint.h>.  *)\n-  Format.printf \"typedef float float32_t;\\n\";\n-  Format.printf \"typedef __builtin_neon_poly8 poly8_t;\\n\";\n-  Format.printf \"typedef __builtin_neon_poly16 poly16_t;\\n\";\n-  Format.printf \"#ifdef __ARM_FEATURE_CRYPTO\\n\";\n-  Format.printf \"typedef __builtin_neon_poly64 poly64_t;\\n\";\n-  Format.printf \"typedef __builtin_neon_poly128 poly128_t;\\n\";\n-  Format.printf \"#endif\\n\"\n-\n-(* Output structs containing arrays, for load & store instructions etc.\n-   poly128_t is deliberately not included here because it has no array types\n-   defined for it.  *)\n-\n-let arrtypes () =\n-  let typeinfo = [\n-    \"int\", 8, ALL;    \"int\", 16, ALL;\n-    \"int\", 32, ALL;   \"int\", 64, ALL;\n-    \"uint\", 8, ALL;   \"uint\", 16, ALL;\n-    \"uint\", 32, ALL;  \"uint\", 64, ALL;\n-    \"float\", 32, ALL; \"poly\", 8, ALL;\n-    \"poly\", 16, ALL; \"poly\", 64, CRYPTO\n-  ] in\n-  let writestruct elname elsize regsize arrsize fpulevel =\n-    let elnum = regsize / elsize in\n-    let structname =\n-      Printf.sprintf \"%s%dx%dx%d_t\" elname elsize elnum arrsize in\n-    let sfmt = start_function () in\n-    Format.printf \"%stypedef struct %s\"\n-      (if fpulevel == CRYPTO then \"#ifdef __ARM_FEATURE_CRYPTO\\n\" else \"\") structname;\n-    open_braceblock sfmt;\n-    Format.printf \"%s%dx%d_t val[%d];\" elname elsize elnum arrsize;\n-    close_braceblock sfmt;\n-    Format.printf \" %s;%s\" structname (if fpulevel == CRYPTO then \"\\n#endif\\n\" else \"\");\n-    end_function sfmt;\n-  in\n-    for n = 2 to 4 do\n-      List.iter\n-        (fun (elname, elsize, alevel) ->\n-          writestruct elname elsize 64 n alevel;\n-          writestruct elname elsize 128 n alevel)\n-        typeinfo\n-    done\n-\n-let print_lines = List.iter (fun s -> Format.printf \"%s@\\n\" s)\n-\n-(* Do it.  *)\n-\n-let _ =\n-  print_lines [\n-\"/* ARM NEON intrinsics include file. This file is generated automatically\";\n-\"   using neon-gen.ml.  Please do not edit manually.\";\n-\"\";\n-\"   Copyright (C) 2006-2014 Free Software Foundation, Inc.\";\n-\"   Contributed by CodeSourcery.\";\n-\"\";\n-\"   This file is part of GCC.\";\n-\"\";\n-\"   GCC is free software; you can redistribute it and/or modify it\";\n-\"   under the terms of the GNU General Public License as published\";\n-\"   by the Free Software Foundation; either version 3, or (at your\";\n-\"   option) any later version.\";\n-\"\";\n-\"   GCC is distributed in the hope that it will be useful, but WITHOUT\";\n-\"   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\";\n-\"   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\";\n-\"   License for more details.\";\n-\"\";\n-\"   Under Section 7 of GPL version 3, you are granted additional\";\n-\"   permissions described in the GCC Runtime Library Exception, version\";\n-\"   3.1, as published by the Free Software Foundation.\";\n-\"\";\n-\"   You should have received a copy of the GNU General Public License and\";\n-\"   a copy of the GCC Runtime Library Exception along with this program;\";\n-\"   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\";\n-\"   <http://www.gnu.org/licenses/>.  */\";\n-\"\";\n-\"#ifndef _GCC_ARM_NEON_H\";\n-\"#define _GCC_ARM_NEON_H 1\";\n-\"\";\n-\"#ifndef __ARM_NEON__\";\n-\"#error You must enable NEON instructions (e.g. -mfloat-abi=softfp -mfpu=neon) to use arm_neon.h\";\n-\"#else\";\n-\"\";\n-\"#ifdef __cplusplus\";\n-\"extern \\\"C\\\" {\";\n-\"#endif\";\n-\"\";\n-\"#include <stdint.h>\";\n-\"\"];\n-  deftypes ();\n-  arrtypes ();\n-  Format.print_newline ();\n-  print_ops ops;\n-  Format.print_newline ();\n-  print_ops reinterp;\n-  print_ops reinterpq;\n-  Format.printf \"%s\" crypto_intrinsics;\n-  print_lines [\n-\"#ifdef __cplusplus\";\n-\"}\";\n-\"#endif\";\n-\"#endif\";\n-\"#endif\"]"}, {"sha": "56987e4a68639b83b861df97f2de2485d18316aa", "filename": "gcc/doc/arm-neon-intrinsics.texi", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79cb1a3b21fb80a2d85eb9fc10b1664f108884b/gcc%2Fdoc%2Farm-neon-intrinsics.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79cb1a3b21fb80a2d85eb9fc10b1664f108884b/gcc%2Fdoc%2Farm-neon-intrinsics.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Farm-neon-intrinsics.texi?ref=e79cb1a3b21fb80a2d85eb9fc10b1664f108884b", "patch": "@@ -2,8 +2,6 @@\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n-@c This file is generated automatically using gcc/config/arm/neon-docgen.ml\n-@c Please do not edit manually.\n @subsubsection Addition\n \n @itemize @bullet"}]}