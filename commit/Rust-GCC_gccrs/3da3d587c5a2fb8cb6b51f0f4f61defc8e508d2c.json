{"sha": "3da3d587c5a2fb8cb6b51f0f4f61defc8e508d2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RhM2Q1ODdjNWEyZmI4Y2I2YjUxZjBmNGY2MWRlZmM4ZTUwOGQyYw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2004-10-27T17:29:29Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-10-27T17:29:29Z"}, "message": "re PR c++/18075 (#pragma implementation broken in presence of #pragma ident)\n\n\tPR 18075\n\t* directives.c (do_pragma): Do not defer pragmas which are unknown.\n\t(cpp_handle_deferred_pragma): Add cast to silence warning.\n\nFrom-SVN: r89693", "tree": {"sha": "8688154b1cf993240030405dd70e878caba25ee8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8688154b1cf993240030405dd70e878caba25ee8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3da3d587c5a2fb8cb6b51f0f4f61defc8e508d2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3da3d587c5a2fb8cb6b51f0f4f61defc8e508d2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3da3d587c5a2fb8cb6b51f0f4f61defc8e508d2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3da3d587c5a2fb8cb6b51f0f4f61defc8e508d2c/comments", "author": null, "committer": null, "parents": [{"sha": "121260258cea3bae636b32c298b1dc4a25435056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121260258cea3bae636b32c298b1dc4a25435056", "html_url": "https://github.com/Rust-GCC/gccrs/commit/121260258cea3bae636b32c298b1dc4a25435056"}], "stats": {"total": 72, "additions": 41, "deletions": 31}, "files": [{"sha": "48f65270ac92b045ab7bc1b6f9e03e15782d097e", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da3d587c5a2fb8cb6b51f0f4f61defc8e508d2c/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da3d587c5a2fb8cb6b51f0f4f61defc8e508d2c/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=3da3d587c5a2fb8cb6b51f0f4f61defc8e508d2c", "patch": "@@ -1,3 +1,9 @@\n+2004-10-27  Zack Weinberg  <zack@codesourcery.com>\n+\n+\tPR 18075\n+\t* directives.c (do_pragma): Do not defer pragmas which are unknown.\n+\t(cpp_handle_deferred_pragma): Add cast to silence warning.\n+\n 2004-10-14  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* errors.c (_cpp_begin_message): Print \"error: \" for errors."}, {"sha": "10d080bee4429174dce821ac32caa7d0fad2ecae", "filename": "libcpp/directives.c", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da3d587c5a2fb8cb6b51f0f4f61defc8e508d2c/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da3d587c5a2fb8cb6b51f0f4f61defc8e508d2c/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=3da3d587c5a2fb8cb6b51f0f4f61defc8e508d2c", "patch": "@@ -1167,37 +1167,41 @@ do_pragma (cpp_reader *pfile)\n \t}\n     }\n \n-  if (p && (p->is_internal || !CPP_OPTION (pfile, defer_pragmas)))\n-    {\n-      /* Since the handler below doesn't get the line number, that it\n-\t might need for diagnostics, make sure it has the right\n-\t numbers in place.  */\n-      if (pfile->cb.line_change)\n-\t(*pfile->cb.line_change) (pfile, pragma_token, false);\n-      (*p->u.handler) (pfile);\n-    }\n-  else if (CPP_OPTION (pfile, defer_pragmas))\n+  if (p)\n     {\n-      /* Squirrel away the pragma text.  Pragmas are newline-terminated. */\n-      const uchar *line_end;\n-      uchar *s;\n-      cpp_string body;\n-      cpp_token *ptok;\n-\n-      line_end = ustrchr (line_start, '\\n');\n-\n-      body.len = (line_end - line_start) + 1;\n-      s = _cpp_unaligned_alloc (pfile, body.len + 1);\n-      memcpy (s, line_start, body.len);\n-      s[body.len] = '\\0';\n-      body.text = s;\n-\n-      /* Create a CPP_PRAGMA token.  */\n-      ptok = &pfile->directive_result;\n-      ptok->src_loc = pragma_token->src_loc;\n-      ptok->type = CPP_PRAGMA;\n-      ptok->flags = pragma_token->flags | NO_EXPAND;\n-      ptok->val.str = body;\n+      if (p->is_internal || !CPP_OPTION (pfile, defer_pragmas))\n+\t{\n+\t  /* Since the handler below doesn't get the line number, that it\n+\t     might need for diagnostics, make sure it has the right\n+\t     numbers in place.  */\n+\t  if (pfile->cb.line_change)\n+\t    (*pfile->cb.line_change) (pfile, pragma_token, false);\n+\t  (*p->u.handler) (pfile);\n+\t}\n+      else\n+\t{\n+\t  /* Squirrel away the pragma text.  Pragmas are\n+\t     newline-terminated. */\n+\t  const uchar *line_end;\n+\t  uchar *s;\n+\t  cpp_string body;\n+\t  cpp_token *ptok;\n+\n+\t  line_end = ustrchr (line_start, '\\n');\n+\n+\t  body.len = (line_end - line_start) + 1;\n+\t  s = _cpp_unaligned_alloc (pfile, body.len + 1);\n+\t  memcpy (s, line_start, body.len);\n+\t  s[body.len] = '\\0';\n+\t  body.text = s;\n+\n+\t  /* Create a CPP_PRAGMA token.  */\n+\t  ptok = &pfile->directive_result;\n+\t  ptok->src_loc = pragma_token->src_loc;\n+\t  ptok->type = CPP_PRAGMA;\n+\t  ptok->flags = pragma_token->flags | NO_EXPAND;\n+\t  ptok->val.str = body;\n+\t}\n     }\n   else if (pfile->cb.def_pragma)\n     {\n@@ -1428,7 +1432,7 @@ cpp_handle_deferred_pragma (cpp_reader *pfile, const cpp_string *s)\n   pfile->cb.line_change = NULL;\n   CPP_OPTION (pfile, defer_pragmas) = false;\n \n-  run_directive (pfile, T_PRAGMA, s->text, s->len);\n+  run_directive (pfile, T_PRAGMA, (const char *)s->text, s->len);\n \n   XDELETE (pfile->context);\n   pfile->context = saved_context;"}]}