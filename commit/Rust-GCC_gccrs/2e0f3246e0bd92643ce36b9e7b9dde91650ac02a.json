{"sha": "2e0f3246e0bd92643ce36b9e7b9dde91650ac02a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUwZjMyNDZlMGJkOTI2NDNjZTM2YjllN2I5ZGRlOTE2NTBhYzAyYQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-31T20:41:27Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-01T00:49:40Z"}, "message": "Replace ssa_range_in_bb with entry exit and def range\n\nSplit the old functionality of ssa_name_in_bb into the components for\ndefinition in a block, entry and exit range.  Call these as appropriate.\n\n\t* gimple-range-cache.cc (ranger_cache::ssa_range_in_bb): Delete.\n\t(ranger_cache::range_of_def): New.\n\t(ranger_cache::entry_range): New.\n\t(ranger_cache::exit_range): New.\n\t(ranger_cache::range_of_expr): Adjust.\n\t(ranger_cache::range_on_edge): Adjust.\n\t(ranger_cache::propagate_cache): Call exit_range directly.\n\t* gimple-range-cache.h (class ranger_cache): Adjust.", "tree": {"sha": "66cc5877e10719c3f4ed5355db00e6d604213c0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66cc5877e10719c3f4ed5355db00e6d604213c0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e0f3246e0bd92643ce36b9e7b9dde91650ac02a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e0f3246e0bd92643ce36b9e7b9dde91650ac02a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e0f3246e0bd92643ce36b9e7b9dde91650ac02a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e0f3246e0bd92643ce36b9e7b9dde91650ac02a/comments", "author": null, "committer": null, "parents": [{"sha": "47ea02bb862d6be9a200ebccbd5d64b31a003ec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ea02bb862d6be9a200ebccbd5d64b31a003ec2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47ea02bb862d6be9a200ebccbd5d64b31a003ec2"}], "stats": {"total": 133, "additions": 97, "deletions": 36}, "files": [{"sha": "dc32841310a3f06cf64518abfbd34c0ea9d303ac", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 92, "deletions": 34, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e0f3246e0bd92643ce36b9e7b9dde91650ac02a/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e0f3246e0bd92643ce36b9e7b9dde91650ac02a/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=2e0f3246e0bd92643ce36b9e7b9dde91650ac02a", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa.h\"\n #include \"gimple-pretty-print.h\"\n #include \"gimple-range.h\"\n+#include \"tree-cfg.h\"\n \n // During contructor, allocate the vector of ssa_names.\n \n@@ -708,36 +709,51 @@ ranger_cache::push_poor_value (basic_block bb, tree name)\n //  of an ssa_name in any given basic block.  Note, this does no additonal\n //  lookups, just accesses the data that is already known.\n \n+// Get the range of NAME when the def occurs in block BB\n+\n void\n-ranger_cache::ssa_range_in_bb (irange &r, tree name, basic_block bb)\n+ranger_cache::range_of_def (irange &r, tree name, basic_block bb)\n {\n-  gimple *s = SSA_NAME_DEF_STMT (name);\n-  basic_block def_bb = ((s && gimple_bb (s)) ? gimple_bb (s) :\n-\t\t\t\t\t       ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-  if (bb == def_bb)\n+  gcc_checking_assert (gimple_range_ssa_p (name));\n+  gcc_checking_assert (bb == gimple_bb (SSA_NAME_DEF_STMT (name)));\n+\n+  if (!m_globals.get_global_range (r, name))\n     {\n-      // NAME is defined in this block, so request its current value\n-      if (!m_globals.get_global_range (r, name))\n+      // If it doesn't have a value calculated, it means it's a\n+      // \"poor\" value being used in some calculation.  Queue it up\n+      // as a poor value to be improved later.\n+      r = gimple_range_global (name);\n+      if (push_poor_value (bb, name))\n \t{\n-\t  // If it doesn't have a value calculated, it means it's a\n-\t  // \"poor\" value being used in some calculation.  Queue it up\n-\t  // as a poor value to be improved later.\n-\t  r = gimple_range_global (name);\n-\t  if (push_poor_value (bb, name))\n+\t  if (DEBUG_RANGE_CACHE)\n \t    {\n-\t      if (DEBUG_RANGE_CACHE)\n-\t\t{\n-\t\t  fprintf (dump_file,\n-\t\t\t   \"*CACHE* no global def in bb %d for \", bb->index);\n-\t\t  print_generic_expr (dump_file, name, TDF_SLIM);\n-\t\t  fprintf (dump_file, \" depth : %d\\n\",\n-\t\t\t   m_poor_value_list.length ());\n-\t\t}\n+\t      fprintf (dump_file,\n+\t\t       \"*CACHE* no global def in bb %d for \", bb->index);\n+\t      print_generic_expr (dump_file, name, TDF_SLIM);\n+\t      fprintf (dump_file, \" depth : %d\\n\",\n+\t\t       m_poor_value_list.length ());\n \t    }\n-\t }\n+\t}\n     }\n+  if (r.varying_p () && m_non_null.non_null_deref_p (name, bb, false) &&\n+      !cfun->can_throw_non_call_exceptions)\n+    r = range_nonzero (TREE_TYPE (name));\n+}\n+\n+// Get the range of NAME as it occurs on entry to block BB.  If it is not set,\n+// mark it as a poor value for possible later improvement.\n+\n+void\n+ranger_cache::entry_range (irange &r, tree name, basic_block bb)\n+{\n+  if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+    {\n+      r = gimple_range_global (name);\n+      return;\n+    }\n+\n   // Look for the on-entry value of name in BB from the cache.\n-  else if (!m_on_entry.get_bb_range (r, name, bb))\n+  if (!m_on_entry.get_bb_range (r, name, bb))\n     {\n       // If it has no entry but should, then mark this as a poor value.\n       // Its not a poor value if it does not have *any* edge ranges,\n@@ -764,29 +780,71 @@ ranger_cache::ssa_range_in_bb (irange &r, tree name, basic_block bb)\n     r = range_nonzero (TREE_TYPE (name));\n }\n \n+// Get the range of NAME as it occurs on exit from block BB.\n+\n+void\n+ranger_cache::exit_range (irange &r, tree name, basic_block bb)\n+{\n+  if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+    {\n+      r = gimple_range_global (name);\n+      return;\n+    }\n+\n+  gimple *s = SSA_NAME_DEF_STMT (name);\n+  basic_block def_bb = gimple_bb (s);\n+  if (def_bb == bb)\n+    range_of_def (r, name, bb);\n+  else\n+    entry_range (r, name, bb);\n+ }\n+\n+\n // Implement range_of_expr.\n \n bool\n-ranger_cache::range_of_expr (irange &r, tree expr, gimple *stmt)\n+ranger_cache::range_of_expr (irange &r, tree name, gimple *stmt)\n {\n-  if (gimple_range_ssa_p (expr))\n-    ssa_range_in_bb (r, expr, gimple_bb (stmt));\n+  if (!gimple_range_ssa_p (name))\n+    {\n+      get_tree_range (r, name);\n+      return true;\n+    }\n+\n+  basic_block bb = gimple_bb (stmt);\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+  basic_block def_bb = gimple_bb (def_stmt);\n+\n+  if (bb == def_bb)\n+    range_of_def (r, name, bb);\n   else\n-    get_tree_range (r, expr);\n+    entry_range (r, name, bb);\n   return true;\n }\n \n-// Implement range_on_edge which returns true ONLY if there is a range\n-// calculated.\n \n-bool\n-ranger_cache::range_on_edge (irange &r, edge e, tree expr)\n-{\n-  if (gimple_range_ssa_p (expr))\n-    return m_gori.outgoing_edge_range_p (r, e, expr, *this);\n+// Implement range_on_edge. Return TRUE if the edge generates a range,\n+// otherwise false.. but still return a range.\n+\n+ bool\n+ ranger_cache::range_on_edge (irange &r, edge e, tree expr)\n+ {\n+   if (gimple_range_ssa_p (expr))\n+    {\n+      exit_range (r, expr, e->src);\n+      int_range_max edge_range;\n+      if (m_gori.outgoing_edge_range_p (edge_range, e, expr, *this))\n+\t{\n+\t  r.intersect (edge_range);\n+\t  return true;\n+\t}\n+    }\n+  else\n+    get_tree_range (r, expr);\n   return false;\n }\n \n+\n // Return a static range for NAME on entry to basic block BB in R.  If\n // calc is true, fill any cache entries required between BB and the\n // def block for NAME.  Otherwise, return false if the cache is empty.\n@@ -879,7 +937,7 @@ ranger_cache::propagate_cache (tree name)\n \t  // Get whatever range we can for this edge.\n \t  if (!m_gori.outgoing_edge_range_p (e_range, e, name, *this))\n \t    {\n-\t      ssa_range_in_bb (e_range, name, e->src);\n+\t      exit_range (e_range, name, e->src);\n \t      if (DEBUG_RANGE_CACHE)\n \t\t{\n \t\t  fprintf (dump_file, \"No outgoing edge range, picked up \");"}, {"sha": "fee69bcc5787025756b55438c1e8dbc1f367e948", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e0f3246e0bd92643ce36b9e7b9dde91650ac02a/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e0f3246e0bd92643ce36b9e7b9dde91650ac02a/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=2e0f3246e0bd92643ce36b9e7b9dde91650ac02a", "patch": "@@ -92,9 +92,8 @@ class ranger_cache : public range_query\n   ranger_cache (class gimple_ranger &q);\n   ~ranger_cache ();\n \n-  virtual bool range_of_expr (irange &r, tree expr, gimple *stmt);\n+  virtual bool range_of_expr (irange &r, tree name, gimple *stmt);\n   virtual bool range_on_edge (irange &r, edge e, tree expr);\n-  void ssa_range_in_bb (irange &r, tree name, basic_block bb);\n   bool block_range (irange &r, basic_block bb, tree name, bool calc = true);\n \n   bool get_global_range (irange &r, tree name) const;\n@@ -114,6 +113,10 @@ class ranger_cache : public range_query\n   void fill_block_cache (tree name, basic_block bb, basic_block def_bb);\n   void propagate_cache (tree name);\n \n+  void range_of_def (irange &r, tree name, basic_block bb);\n+  void entry_range (irange &r, tree expr, basic_block bb);\n+  void exit_range (irange &r, tree expr, basic_block bb);\n+\n   void propagate_updated_value (tree name, basic_block bb);\n \n   vec<basic_block> m_workback;"}]}