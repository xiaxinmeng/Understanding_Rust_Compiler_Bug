{"sha": "85b19f61bcb817478b6110e14b69c8c345f04409", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODViMTlmNjFiY2I4MTc0NzhiNjExMGUxNGI2OWM4YzM0NWYwNDQwOQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-07-02T12:13:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-07-02T12:13:39Z"}, "message": "tree-ssa.c (useless_type_conversion_p): Document future intent as defining the middle-end type system.\n\n2007-07-02  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa.c (useless_type_conversion_p): Document\n\tfuture intent as defining the middle-end type system.\n\tRe-structure to call langhook last, group by type class,\n\tmark questionable parts.\n\nFrom-SVN: r126199", "tree": {"sha": "e811fa8c5c29dbb52c1d70adb4aeef11508ad4b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e811fa8c5c29dbb52c1d70adb4aeef11508ad4b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85b19f61bcb817478b6110e14b69c8c345f04409", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b19f61bcb817478b6110e14b69c8c345f04409", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b19f61bcb817478b6110e14b69c8c345f04409", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b19f61bcb817478b6110e14b69c8c345f04409/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f4088621a53c4c93304030178a4ff14b4fdb30db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4088621a53c4c93304030178a4ff14b4fdb30db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4088621a53c4c93304030178a4ff14b4fdb30db"}], "stats": {"total": 157, "additions": 97, "deletions": 60}, "files": [{"sha": "f9f4b246e77fa5caaff38f4f1947558a764c3543", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b19f61bcb817478b6110e14b69c8c345f04409/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b19f61bcb817478b6110e14b69c8c345f04409/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85b19f61bcb817478b6110e14b69c8c345f04409", "patch": "@@ -1,3 +1,10 @@\n+2007-07-02  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa.c (useless_type_conversion_p): Document\n+\tfuture intent as defining the middle-end type system.\n+\tRe-structure to call langhook last, group by type class,\n+\tmark questionable parts.\n+\n 2007-07-02  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-flow.h (types_compatible_p): Declare."}, {"sha": "8b2d85222523bfe1932ff16da8dbd39906f4fd10", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 90, "deletions": 60, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b19f61bcb817478b6110e14b69c8c345f04409/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b19f61bcb817478b6110e14b69c8c345f04409/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=85b19f61bcb817478b6110e14b69c8c345f04409", "patch": "@@ -888,7 +888,29 @@ delete_tree_ssa (void)\n \n \n /* Return true if the conversion from INNER_TYPE to OUTER_TYPE is a\n-   useless type conversion, otherwise return false.  */\n+   useless type conversion, otherwise return false.\n+\n+   This function implicitly defines the middle-end type system.  With\n+   the notion of 'a < b' meaning that useless_type_conversion_p (a, b)\n+   holds and 'a > b' meaning that useless_type_conversion_p (b, a) holds,\n+   the following invariants shall be fulfilled:\n+\n+     1) useless_type_conversion_p is transitive.\n+\tIf a < b and b < c then a < c.\n+\n+     2) useless_type_conversion_p is not symmetric.\n+\tFrom a < b does not follow a > b.\n+\n+     3) Types define the available set of operations applicable to values.\n+\tA type conversion is useless if the operations for the target type\n+\tis a subset of the operations for the source type.  For example\n+\tcasts to void* are useless, casts from void* are not (void* can't\n+\tbe dereferenced or offsetted, but copied, hence its set of operations\n+\tis a strict subset of that of all other data pointer types).  Casts\n+\tto const T* are useless (can't be written to), casts from const T*\n+\tto T* are not.\n+\n+   ???  The above do not hold currently.  */\n \n bool\n useless_type_conversion_p (tree outer_type, tree inner_type)\n@@ -900,75 +922,83 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n   if (TYPE_MODE (inner_type) != TYPE_MODE (outer_type))\n     return false;\n \n-  /* If the inner and outer types are effectively the same, then\n-     strip the type conversion and enter the equivalence into\n-     the table.  */\n-  if (lang_hooks.types_compatible_p (inner_type, outer_type))\n-    return true;\n-\n-  /* If both types are pointers and the outer type is a (void *), then\n-     the conversion is not necessary.  The opposite is not true since\n-     that conversion would result in a loss of information if the\n-     equivalence was used.  Consider an indirect function call where\n-     we need to know the exact type of the function to correctly\n-     implement the ABI.  */\n-  else if (POINTER_TYPE_P (inner_type)\n-           && POINTER_TYPE_P (outer_type)\n-\t   && TYPE_REF_CAN_ALIAS_ALL (inner_type)\n-\t      == TYPE_REF_CAN_ALIAS_ALL (outer_type)\n-\t   && TREE_CODE (TREE_TYPE (outer_type)) == VOID_TYPE)\n-    return true;\n+  /* If both the inner and outer types are integral types, then the\n+     conversion is not necessary if they have the same mode and\n+     signedness and precision, and both or neither are boolean.  */\n+  if (INTEGRAL_TYPE_P (inner_type)\n+      && INTEGRAL_TYPE_P (outer_type))\n+    {\n+      /* Preserve changes in signedness or precision.  */\n+      if (TYPE_UNSIGNED (inner_type) != TYPE_UNSIGNED (outer_type)\n+\t  || TYPE_PRECISION (inner_type) != TYPE_PRECISION (outer_type))\n+\treturn false;\n+\n+      /* Preserve booleanness.  Some code assumes an invariant that boolean\n+\t types stay boolean and do not become 1-bit bit-field types.  */\n+      if ((TREE_CODE (inner_type) == BOOLEAN_TYPE)\n+\t  != (TREE_CODE (outer_type) == BOOLEAN_TYPE))\n+\treturn false;\n+\n+      /* Preserve changes in the types minimum or maximum value.\n+\t ???  Due to the way we handle sizetype as signed we need\n+\t to jump through hoops here to make sizetype and size_type_node\n+\t compatible.  */\n+      if (!tree_int_cst_equal (fold_convert (outer_type,\n+\t\t\t\t\t     TYPE_MIN_VALUE (inner_type)),\n+\t\t\t       TYPE_MIN_VALUE (outer_type))\n+\t  || !tree_int_cst_equal (fold_convert (outer_type,\n+\t\t\t\t\t\tTYPE_MAX_VALUE (inner_type)),\n+\t\t\t\t  TYPE_MAX_VALUE (outer_type)))\n+\treturn false;\n+\n+      /* ???  We might want to preserve base type changes because of\n+\t TBAA.  Or we need to be extra careful below.  */\n \n-  /* Don't lose casts between pointers to volatile and non-volatile\n-     qualified types.  Doing so would result in changing the semantics\n-     of later accesses.  */\n-  else if (POINTER_TYPE_P (inner_type)\n-           && POINTER_TYPE_P (outer_type)\n-\t   && TYPE_VOLATILE (TREE_TYPE (outer_type))\n-\t      != TYPE_VOLATILE (TREE_TYPE (inner_type)))\n-    return false;\n+      return true;\n+    }\n \n-  /* Pointers/references are equivalent if their pointed to types\n-     are effectively the same.  This allows to strip conversions between\n-     pointer types with different type qualifiers.  */\n+  /* We need to take special care recursing to pointed-to types.  */\n   else if (POINTER_TYPE_P (inner_type)\n-           && POINTER_TYPE_P (outer_type)\n-\t   && TYPE_REF_CAN_ALIAS_ALL (inner_type)\n-\t      == TYPE_REF_CAN_ALIAS_ALL (outer_type)\n-           && lang_hooks.types_compatible_p (TREE_TYPE (inner_type),\n-\t\t\t\t\t     TREE_TYPE (outer_type)))\n-    return true;\n-\n-  /* If both the inner and outer types are integral types, then the\n-     conversion is not necessary if they have the same mode and\n-     signedness and precision, and both or neither are boolean.  Some\n-     code assumes an invariant that boolean types stay boolean and do\n-     not become 1-bit bit-field types.  Note that types with precision\n-     not using all bits of the mode (such as bit-field types in C)\n-     mean that testing of precision is necessary.  */\n-  else if (INTEGRAL_TYPE_P (inner_type)\n-           && INTEGRAL_TYPE_P (outer_type)\n-\t   && TYPE_UNSIGNED (inner_type) == TYPE_UNSIGNED (outer_type)\n-\t   && TYPE_PRECISION (inner_type) == TYPE_PRECISION (outer_type))\n+\t   && POINTER_TYPE_P (outer_type))\n     {\n-      tree min_inner = fold_convert (outer_type, TYPE_MIN_VALUE (inner_type));\n-      tree max_inner = fold_convert (outer_type, TYPE_MAX_VALUE (inner_type));\n-      bool first_boolean = (TREE_CODE (inner_type) == BOOLEAN_TYPE);\n-      bool second_boolean = (TREE_CODE (outer_type) == BOOLEAN_TYPE);\n-      if (simple_cst_equal (max_inner, TYPE_MAX_VALUE (outer_type))\n-\t  && simple_cst_equal (min_inner, TYPE_MIN_VALUE (outer_type))\n-\t  && first_boolean == second_boolean)\n+      /* Don't lose casts between pointers to volatile and non-volatile\n+\t qualified types.  Doing so would result in changing the semantics\n+\t of later accesses.  */\n+      if (TYPE_VOLATILE (TREE_TYPE (outer_type))\n+\t  != TYPE_VOLATILE (TREE_TYPE (inner_type)))\n+\treturn false;\n+\n+      /* Do not lose casts between pointers with different\n+\t TYPE_REF_CAN_ALIAS_ALL setting.  */\n+      if (TYPE_REF_CAN_ALIAS_ALL (inner_type)\n+\t  != TYPE_REF_CAN_ALIAS_ALL (outer_type))\n+\treturn false;\n+\n+      /* If the outer type is (void *), then the conversion is not\n+\t necessary.\n+\t ???  Together with calling the langhook below this makes\n+\t useless_type_conversion_p not transitive.  */\n+      if (TREE_CODE (TREE_TYPE (outer_type)) == VOID_TYPE)\n \treturn true;\n+\n+      /* Otherwise pointers/references are equivalent if their pointed\n+\t to types are effectively the same.  This allows to strip conversions\n+\t between pointer types with different type qualifiers.\n+\t ???  We should recurse here with\n+\t useless_type_conversion_p.  */\n+      return lang_hooks.types_compatible_p (TREE_TYPE (inner_type),\n+\t\t\t\t\t   TREE_TYPE (outer_type));\n     }\n \n   /* Recurse for complex types.  */\n   else if (TREE_CODE (inner_type) == COMPLEX_TYPE\n-\t   && TREE_CODE (outer_type) == COMPLEX_TYPE\n-\t   && useless_type_conversion_p (TREE_TYPE (outer_type),\n-\t\t\t\t\t\t  TREE_TYPE (inner_type)))\n-    return true;\n+\t   && TREE_CODE (outer_type) == COMPLEX_TYPE)\n+    return useless_type_conversion_p (TREE_TYPE (outer_type),\n+\t\t\t\t      TREE_TYPE (inner_type));\n \n-  return false;\n+  /* Fall back to what the frontend thinks of type compatibility.\n+     ???  This should eventually just return false.  */\n+  return lang_hooks.types_compatible_p (inner_type, outer_type);\n }\n \n /* Return true if a conversion from either type of TYPE1 and TYPE2"}]}