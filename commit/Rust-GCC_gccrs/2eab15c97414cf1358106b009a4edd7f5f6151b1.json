{"sha": "2eab15c97414cf1358106b009a4edd7f5f6151b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVhYjE1Yzk3NDE0Y2YxMzU4MTA2YjAwOWE0ZWRkN2Y1ZjYxNTFiMQ==", "commit": {"author": {"name": "Phil Edwards", "email": "phil@codesourcery.com", "date": "2005-08-24T07:13:10Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2005-08-24T07:13:10Z"}, "message": "config.gcc (*-*-vxworks*): Update tm_file, add extra_options, remove use_collect2.\n\n2005-08-22  Phil Edwards  <phil@codesourcery.com>\n\n\t* config.gcc (*-*-vxworks*):  Update tm_file, add extra_options,\n\tremove use_collect2.\n\t(powerpc-wrs-vxworks):  Update, split out *-*-vxworksae target.\n\n\t* target-def.h (TARGET_HAVE_CTORS_DTORS):  Allow target\n\tconfiguration files to override the default value.\n\n\t* config/t-vxworks:  Remove INSTALL_ASSERT_H.  Define STMP_FIXPROTO,\n\tEXTRA_HEADERS, and EXTRA_MULTILIB_PARTS.\n\t* config/vx-common.h:  New file, split out from...\n\t* config/vxworks.h:  here.  Update for VxWorks 6.x and RTP mode.\n\t* config/vxworksae.h:  New file, for VxWorks AE.\n\t* config/vxworks.opt:  New file.\n\t* config/vxlib.c:  Update for VxWorks 6.\n\n\t* config/rs6000/t-vxworks (MULTILIB_OPTIONS):  New list.  Adjust\n\tother MULTILIB_* variables appropriately.\n\t(LIB2FUNCS_EXTRA, EXTRA_MULTILIB_PARTS):  Correct from t-ppccomm.\n\t* config/rs6000/t-vxworksae:  New file, adjust multilibs for AE.\n\t* config/rs6000/vxworks.h:  Update for VxWorks 6.\n\t* config/rs6000/vxworksae.h:  New file, mostly placeholder for now.\n\nFrom-SVN: r103432", "tree": {"sha": "043e6201134ccf2fb879689b66262419aefab937", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/043e6201134ccf2fb879689b66262419aefab937"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2eab15c97414cf1358106b009a4edd7f5f6151b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eab15c97414cf1358106b009a4edd7f5f6151b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eab15c97414cf1358106b009a4edd7f5f6151b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eab15c97414cf1358106b009a4edd7f5f6151b1/comments", "author": null, "committer": null, "parents": [{"sha": "7307936052bc73e87f5bb6ddeefcb6c2ed327094", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7307936052bc73e87f5bb6ddeefcb6c2ed327094", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7307936052bc73e87f5bb6ddeefcb6c2ed327094"}], "stats": {"total": 825, "additions": 632, "deletions": 193}, "files": [{"sha": "a8c5bb2d0251f0adefdc825ba51c435213b04f17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -1,3 +1,27 @@\n+2005-08-23  Phil Edwards  <phil@codesourcery.com>\n+\n+\t* config.gcc (*-*-vxworks*):  Update tm_file, add extra_options,\n+\tremove use_collect2.\n+\t(powerpc-wrs-vxworks):  Update, split out *-*-vxworksae target.\n+\n+\t* target-def.h (TARGET_HAVE_CTORS_DTORS):  Allow target\n+\tconfiguration files to override the default value.\n+\n+\t* config/t-vxworks:  Remove INSTALL_ASSERT_H.  Define STMP_FIXPROTO,\n+\tEXTRA_HEADERS, and EXTRA_MULTILIB_PARTS.\n+\t* config/vx-common.h:  New file, split out from...\n+\t* config/vxworks.h:  here.  Update for VxWorks 6.x and RTP mode.\n+\t* config/vxworksae.h:  New file, for VxWorks AE.\n+\t* config/vxworks.opt:  New file.\n+\t* config/vxlib.c:  Update for VxWorks 6.\n+\n+\t* config/rs6000/t-vxworks (MULTILIB_OPTIONS):  New list.  Adjust\n+\tother MULTILIB_* variables appropriately.\n+\t(LIB2FUNCS_EXTRA, EXTRA_MULTILIB_PARTS):  Correct from t-ppccomm.\n+\t* config/rs6000/t-vxworksae:  New file, adjust multilibs for AE.\n+\t* config/rs6000/vxworks.h:  Update for VxWorks 6.\n+\t* config/rs6000/vxworksae.h:  New file, mostly placeholder for now.\n+\n 2005-08-23  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR target/20799"}, {"sha": "f7281329343c5ed00a23a01494107bbfb77dd11e", "filename": "gcc/config.gcc", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -533,14 +533,14 @@ case ${target} in\n   ;;\n *-*-vxworks*)\n   tmake_file=t-vxworks\n-  tm_file=\"${tm_file} elfos.h svr4.h vxworks.h\"\n+  tm_file=\"${tm_file} elfos.h svr4.h\"\n+  xm_defines=POSIX\n+  extra_options=\"${extra_options} vxworks.opt\"\n   case ${enable_threads} in\n     no) ;;\n     \"\" | yes | vxworks) thread_file='vxworks' ;;\n     *) echo 'Unknown thread configuration for VxWorks'; exit 1 ;;\n   esac\n-  use_collect2=yes\n-  xm_defines=POSIX\n   ;;\n esac\n \n@@ -1722,22 +1722,30 @@ powerpc-*-gnu*)\n \t\tthread_file='posix'\n \tfi\n \t;;\n-powerpc-wrs-vxworks*)\n+powerpc-wrs-vxworks|powerpc-wrs-vxworksae)\n \t# We want vxworks.h after rs6000/sysv4.h, which unfortunately\n \t# means we have to redo the tm_file list from scratch.\n \ttm_file=\"rs6000/rs6000.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h\"\n-\ttm_file=\"${tm_file} vxworks.h rs6000/vxworks.h\"\n \ttmake_file=\"${tmake_file} rs6000/t-fprules rs6000/t-ppccomm rs6000/t-vxworks\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \textra_headers=ppc-asm.h\n+\tcase ${target} in\n+\t  *-vxworksae*)\n+\t    tm_file=\"${tm_file} vx-common.h vxworksae.h rs6000/vxworks.h rs6000/vxworksae.h\"\n+\t    tmake_file=\"${tmake_file} rs6000/t-vxworksae\"\n+\t    ;;\n+\t  *-vxworks*)\n+\t    tm_file=\"${tm_file} vx-common.h vxworks.h rs6000/vxworks.h\"\n+\t    ;;\n+\tesac\n \t;;\n-powerpc-wrs-windiss*)\t# Instruction-level simulator for VxWorks.\n+powerpc-wrs-windiss*)  # Instruction-level simulator for VxWorks.\n \ttm_file=\"${tm_file} elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/windiss.h\"\n-        tmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-        thread_file=\"\"\n+\tthread_file=\"\"\n \tuse_fixproto=yes\n-        ;;\n+\t;;\n powerpc-*-lynxos*)\n \txm_defines=POSIX\n \ttm_file=\"${tm_file} dbxelf.h elfos.h rs6000/sysv4.h rs6000/lynx.h lynx.h\""}, {"sha": "fe65a399397c0e2545a0a167e763247a8313b41f", "filename": "gcc/config/rs6000/t-vxworks", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Frs6000%2Ft-vxworks", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Frs6000%2Ft-vxworks", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-vxworks?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -1,10 +1,11 @@\n # Multilibs for VxWorks.\n \n-MULTILIB_OPTIONS  = t403/t405/t440/t603/t604/t860\n-MULTILIB_DIRNAMES = PPC403gnu PPC405gnu PPC440gnu \\\n-\t\t    PPC603gnu PPC604gnu PPC860gnu\n+# The base multilib is -mhard-float.\n+MULTILIB_OPTIONS = mrtp fPIC msoft-float\n+MULTILIB_DIRNAMES =\n+MULTILIB_MATCHES = fPIC=fpic\n+MULTILIB_EXCEPTIONS = fPIC*\n \n-MULTILIB_MATCHES  = t604=\n-\n-# Put vxlib.c back in LIB2FUNCS_EXTRA (t-ppccomm clobbers it).\n-LIB2FUNCS_EXTRA += $(srcdir)/config/vxlib.c\n+# Restore some variables from t-vxworks clobbered by t-ppccomm.\n+EXTRA_MULTILIB_PARTS = \n+LIB2FUNCS_EXTRA = $(srcdir)/config/vxlib.c"}, {"sha": "5f682627ebc62ed3b6f7b2b42774dae0a67be8fc", "filename": "gcc/config/rs6000/t-vxworksae", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Frs6000%2Ft-vxworksae", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Frs6000%2Ft-vxworksae", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-vxworksae?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -0,0 +1,5 @@\n+# Multilibs for VxWorks AE.\n+\n+MULTILIB_OPTIONS = mvthreads msoft-float\n+MULTILIB_MATCHES =\n+MULTILIB_EXCEPTIONS = "}, {"sha": "d389ace8d456ac1bbb48be33ffcef211db831329", "filename": "gcc/config/rs6000/vxworks.h", "status": "modified", "additions": 136, "deletions": 55, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Frs6000%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Frs6000%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvxworks.h?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -1,32 +1,66 @@\n /* Definitions of target machine for GNU compiler.  Vxworks PowerPC version.\n-   Copyright (C) 1996, 2000, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 2000, 2002, 2003, 2004, 2005\n+   Free Software Foundation, Inc.\n+   Contributed by CodeSourcery, LLC.\n \n-   This file is part of GCC.\n+This file is part of GCC.\n \n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 2, or (at your\n-   option) any later version.\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n \n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n \n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to the\n-   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n \n-#undef  TARGET_OS_CPP_BUILTINS\n+/* Note to future editors: VxWorks is mostly an EABI target.  We do\n+   not use rs6000/eabi.h because we would have to override most of\n+   it anyway.  However, if you change that file, consider making\n+   analogous changes here too.  */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (PowerPC VxWorks)\");\n+\n+/* CPP predefined macros.  */\n+\n+#undef TARGET_OS_CPP_BUILTINS\n #define TARGET_OS_CPP_BUILTINS()\t\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n+      builtin_define (\"__ppc\");\t\t\t\\\n+      builtin_define (\"__EABI__\");\t\t\\\n+      builtin_define (\"__ELF__\");\t\t\\\n       builtin_define (\"__vxworks\");\t\t\\\n-      builtin_define (\"__vxworks__\");\t\t\\\n+      builtin_define (\"__VXWORKS__\");\t\t\\\n+      if (!TARGET_SOFT_FLOAT)\t\t\t\\\n+\tbuiltin_define (\"__hardfp\");\t\t\\\n+      if (flag_pic == 2)\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  builtin_define (\"__PIC__=2\");\t\t\\\n+\t  builtin_define (\"__pic__=2\");\t\t\\\n+\t}\t\t\t\t\t\\\n+      else if (flag_pic == 1)\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  builtin_define (\"__PIC__=1\");\t\t\\\n+\t  builtin_define (\"__pic__=1\");\t\t\\\n+\t}\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+      /* C89 namespace violation! */\t\t\\\n+      builtin_define (\"CPU_FAMILY=PPC\");\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n \n+/* Only big endian PPC is supported by VxWorks.  */\n+#undef BYTES_BIG_ENDIAN\n+#define BYTES_BIG_ENDIAN 1\n+\n /* We have to kill off the entire specs set created by rs6000/sysv4.h\n    and substitute our own set.  The top level vxworks.h has done some\n    of this for us.  */\n@@ -38,45 +72,92 @@\n \n #define SUBTARGET_EXTRA_SPECS /* none needed */\n \n+/* FIXME: The only reason we allow no -mcpu switch at all is because\n+   config-ml.in insists on a \".\" multilib. */\n #define CPP_SPEC \\\n-\"-DCPU_FAMILY=PPC -D__ppc -D__EABI__  \\\n- %{t403: -DCPU=PPC403 -D_SOFT_FLOAT ; \\\n-   t405: -DCPU=PPC405 -D_SOFT_FLOAT ; \\\n-   t440: -DCPU=PPC440 -D_SOFT_FLOAT ; \\\n-   t603: -DCPU=PPC603               ; \\\n-   t604: -DCPU=PPC604               ; \\\n-   t860: -DCPU=PPC860 -D_SOFT_FLOAT ; \\\n-       : -DCPU=PPC604}  \\\n- %{!msoft-float:-D__hardfp}\t   \\\n- %{fpic|fpie: -D__PIC__=1 -D__pic__=1 ; \\\n-   fPIC|fPIE: -D__PIC__=2 -D__pic__=2 } \\\n- %(cpp_cpu)\"\n-\n-#define CC1_SPEC \\\n-\"%{t403: -mcpu=403 -mstrict-align ;\t\t\t\t\\\n-   t405: -mcpu=405 -mstrict-align ;\t\t\t\t\\\n-   t440: -mcpu=440 -mstrict-align ;\t\t\t\t\\\n-   t603: -mcpu=603 -mstrict-align ;\t\t\t\t\\\n-   t604: -mcpu=604 -mstrict-align ;\t\t\t\t\\\n-   t860: -mcpu=860                ;                             \\\n-       : -mcpu=604 -mstrict-align }\t\t\t\t\\\n- %{G*} %{mno-sdata:-msdata=none} %{msdata:-msdata=default}\t\\\n+\"%{!DCPU=*:\t\t  \\\n+   %{mcpu=403 : -DCPU=PPC403  ; \\\n+     mcpu=405 : -DCPU=PPC405  ; \\\n+     mcpu=440 : -DCPU=PPC440  ; \\\n+     mcpu=603 : -DCPU=PPC603  ; \\\n+     mcpu=604 : -DCPU=PPC604  ; \\\n+     mcpu=860 : -DCPU=PPC860  ; \\\n+     mcpu=8540: -DCPU=PPC85XX ; \\\n+              : -DCPU=PPC604  }}\" \\\n+VXWORKS_ADDITIONAL_CPP_SPEC\n+\n+#define CC1_SPEC\t\t\t\t\t\t\\\n+\"%{G*} %{mno-sdata:-msdata=none} %{msdata:-msdata=default}\t\\\n  %{mlittle|mlittle-endian:-mstrict-align}\t\t\t\\\n- %{profile: -p}\t\t\t\t\t\t\t\\\n+ %{profile: -p}\t\t\\\n  %{fvec:-maltivec} %{fvec-eabi:-maltivec -mabi=altivec}\"\n-   \n-#define ASM_SPEC \"%(asm_cpu) \\\n-%{.s: %{mregnames} %{mno-regnames}} %{.S: %{mregnames} %{mno-regnames}} \\\n-%{v:-V} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*} \\\n-%{mrelocatable} %{mrelocatable-lib} %{fpic:-K PIC} %{fPIC:-K PIC} -mbig\"\n-\n-#undef  MULTILIB_DEFAULTS\n-#define MULTILIB_DEFAULTS { \"t604\" }\n-\n-/* We can't use .ctors/.dtors sections.  */\n-#undef TARGET_ASM_OUTPUT_CONSTRUCTOR\n-#undef TARGET_ASM_OUTPUT_DESTRUCTOR\n-\n-/* Nor sdata.  */\n-#undef  SDATA_DEFAULT_SIZE\n-#define SDATA_DEFAULT_SIZE 0\n+\n+#define ASM_SPEC \\\n+\"%(asm_cpu) \\\n+ %{.s: %{mregnames} %{mno-regnames}} %{.S: %{mregnames} %{mno-regnames}} \\\n+ %{v:-v} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*} \\\n+ %{mrelocatable} %{mrelocatable-lib} %{fpic:-K PIC} %{fPIC:-K PIC} -mbig\"\n+\n+#undef  LIB_SPEC\n+#define LIB_SPEC VXWORKS_LIB_SPEC\n+#undef  LINK_SPEC\n+#define LINK_SPEC VXWORKS_LINK_SPEC\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC VXWORKS_STARTFILE_SPEC\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC VXWORKS_ENDFILE_SPEC\n+\n+/* There is no default multilib.  */\n+#undef MULTILIB_DEFAULTS\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT \\\n+  (MASK_POWERPC | MASK_NEW_MNEMONICS | MASK_EABI | MASK_STRICT_ALIGN)\n+\n+#undef PROCESSOR_DEFAULT\n+#define PROCESSOR_DEFAULT PROCESSOR_PPC604\n+\n+/* Nor sdata, for kernel mode.  We use this in\n+   SUBSUBTARGET_INITIALIZE_OPTIONS, after rs6000_rtp has been initialized.  */\n+#undef SDATA_DEFAULT_SIZE\n+#define SDATA_DEFAULT_SIZE (TARGET_VXWORKS_RTP ? 8 : 0)\n+\n+#undef  STACK_BOUNDARY\n+#define STACK_BOUNDARY (16*BITS_PER_UNIT)\n+/* Override sysv4.h, reset to the default.  */\n+#undef  PREFERRED_STACK_BOUNDARY\n+\n+/* Enable SPE */\n+#undef TARGET_SPE_ABI\n+#undef TARGET_SPE\n+#undef TARGET_E500\n+#undef TARGET_ISEL\n+#undef TARGET_FPRS\n+\n+#define TARGET_SPE_ABI rs6000_spe_abi\n+#define TARGET_SPE rs6000_spe\n+#define TARGET_E500 (rs6000_cpu == PROCESSOR_PPC8540)\n+#define TARGET_ISEL rs6000_isel\n+#define TARGET_FPRS (!rs6000_float_gprs)\n+\n+/* Make -mcpu=8540 imply SPE.  ISEL is automatically enabled, the\n+   others must be done by hand.  Handle -mrtp.  Disable -fPIC\n+   for -mrtp - the VxWorks PIC model is not compatible with it.  */\n+#undef SUBSUBTARGET_OVERRIDE_OPTIONS\n+#define SUBSUBTARGET_OVERRIDE_OPTIONS\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    if (TARGET_E500)\t\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\trs6000_spe = 1;\t\t\t\t\\\n+\trs6000_spe_abi = 1;\t\t\t\\\n+\trs6000_float_gprs = 1;\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+  if (!g_switch_set)\t\t\t\t\\\n+    g_switch_value = SDATA_DEFAULT_SIZE;\t\\\n+  VXWORKS_OVERRIDE_OPTIONS;\t\t\t\\\n+  } while (0)\n+\n+/* No _mcount profiling on VxWorks.  */\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE,LABELNO) VXWORKS_FUNCTION_PROFILER(FILE,LABELNO)"}, {"sha": "814b969b0a23a1f4668e8574ae4ae0ef9a93ead7", "filename": "gcc/config/rs6000/vxworksae.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Frs6000%2Fvxworksae.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Frs6000%2Fvxworksae.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvxworksae.h?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -0,0 +1,24 @@\n+/* PowerPC VxWorks AE target definitions for GNU compiler.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery, LLC.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (PowerPC VxWorks AE)\");\n+"}, {"sha": "677b3b4544308552cd94af3dccd9214863518cd2", "filename": "gcc/config/t-vxworks", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Ft-vxworks", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Ft-vxworks", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-vxworks?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -1,8 +1,7 @@\n-# Since we have a functional assert.h, use it.\n-INSTALL_ASSERT_H =\n+# Don't run fixproto.\n+STMP_FIXPROTO =\n \n # Build libgcc using the multilib mechanism\n-\n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib\n \n@@ -15,8 +14,14 @@ LIBGCC2_DEBUG_CFLAGS =\n # Extra libgcc2 module used by gthr-vxworks.h functions\n LIB2FUNCS_EXTRA = $(srcdir)/config/vxlib.c\n \n+# Some runtime modules need these.  Can't set extra_headers in config.gcc\n+# because the paths are always made absolute to the cpu config dir.\n+EXTRA_HEADERS += $(srcdir)/gthr-vxworks.h gthr-default.h\n+\n # This ensures that the correct target headers are used; some\n # VxWorks system headers have names that collide with GCC's\n # internal (host) headers, e.g. regs.h.\n # FIXME: May not be necessary anymore.\n LIBGCC2_INCLUDES=\"-I$(SYSTEM_HEADER_DIR)\"\n+\n+EXTRA_MULTILIB_PARTS = "}, {"sha": "baa37f0e80e3d32d38c004685c85669b751f422f", "filename": "gcc/config/vx-common.h", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Fvx-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Fvx-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvx-common.h?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -0,0 +1,99 @@\n+/* Target-independent configuration for VxWorks and VxWorks AE.   \n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by by CodeSourcery, LLC.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* VxWorks headers are C++-aware.  */\n+#undef  NO_IMPLICIT_EXTERN_C\n+#define NO_IMPLICIT_EXTERN_C\n+\n+/* Most of these will probably be overridden by subsequent headers.  We\n+   undefine them here just in case, and define VXWORKS_ versions of each,\n+   to be used in port-specific vxworks.h.  */\n+#undef LIB_SPEC\n+#undef LINK_SPEC\n+#undef LIBGCC_SPEC\n+#define LIBGCC_SPEC VXWORKS_LIBGCC_SPEC\n+#undef STARTFILE_SPEC\n+#undef ENDFILE_SPEC\n+\n+/* Most of these macros are overridden in \"config/vxworks.h\" or\n+   \"config/vxworksae.h\" and are here merely for documentation\n+   purposes.  */\n+#define VXWORKS_ADDITIONAL_CPP_SPEC \"\"\n+#define\tVXWORKS_LIB_SPEC \"\"\n+#define VXWORKS_LINK_SPEC \"\"\n+#define VXWORKS_LIBGCC_SPEC \"\"\n+#define\tVXWORKS_STARTFILE_SPEC \"\"\n+#define VXWORKS_ENDFILE_SPEC \"\"\n+\n+/* VxWorks cannot have dots in constructor labels, because it uses a\n+   mutant variation of collect2 that generates C code instead of\n+   assembly.  Thus each constructor label must be a legitimate C\n+   symbol.  FIXME: Have VxWorks use real collect2 instead.  */\n+#undef NO_DOLLAR_IN_LABEL\n+#define NO_DOT_IN_LABEL\n+\n+/* VxWorks uses wchar_t == unsigned short (UCS2) on all architectures.  */\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"short unsigned int\"\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 16\n+\n+/* Dwarf2 unwind info is not supported.  */\n+#define DWARF2_UNWIND_INFO 0\n+\n+/* VxWorks uses DWARF2.  */\n+#define DWARF2_DEBUGGING_INFO 1\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+/* None of these other formats is supported.  */\n+#undef DWARF_DEBUGGING_INFO\n+#undef DBX_DEBUGGING_INFO\n+#undef SDB_DEBUGGING_INFO\n+#undef XCOFF_DEBUGGING_INFO\n+#undef VMS_DEBUGGING_INFO\n+\n+/* Kernel mode doesn't have ctors/dtors, but RTP mode does.  */\n+#define TARGET_HAVE_CTORS_DTORS false\n+#define VXWORKS_OVERRIDE_OPTIONS /* empty */\n+\n+/* No math library needed.  */\n+#define MATH_LIBRARY \"\"\n+\n+/* No profiling.  */\n+#define VXWORKS_FUNCTION_PROFILER(FILE, LABELNO) do\t\\\n+{\t\t\t\t\t\t\t\\\n+  sorry (\"profiler support for VxWorks\");\t\t\\\n+} while (0)\n+\n+/* This section either contains dynamic relocations, or contains\n+   PC-rel indirections to stubs in the data section which contain dynamic\n+   relocations.  General dynamic relocations are not processed\n+   for shared libraries' text segments, and PC-relative displacements\n+   from the text segment to the data segment don't work.  So force\n+   it to .gcc_except_section, which the linker will place in .data.  */\n+\n+void vxworks_exception_section (void);\n+#undef TARGET_ASM_EXCEPTION_SECTION\n+#define TARGET_ASM_EXCEPTION_SECTION default_exception_section\n+\n+/* We occasionally need to distinguish between the VxWorks variants.  */\n+#define VXWORKS_KIND_NORMAL  1\n+#define VXWORKS_KIND_AE      2"}, {"sha": "ab02388dd96f45d6c30b673decfff169e0c5a12e", "filename": "gcc/config/vxlib.c", "status": "modified", "additions": 128, "deletions": 67, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Fvxlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Fvxlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxlib.c?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Zack Weinberg <zack@codesourcery.com>\n \n This file is part of GCC.\n@@ -18,24 +18,31 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-/* Threads compatibility routines for libgcc2 for VxWorks.\n-   These are out-of-line routines called from gthr-vxworks.h.  */\n-\n /* As a special exception, if you link this library with other files,\n    some of which are compiled with GCC, to produce an executable,\n    this library does not by itself cause the resulting executable\n    to be covered by the GNU General Public License.\n    This exception does not however invalidate any other reasons why\n    the executable file might be covered by the GNU General Public License.  */\n \n+/* Threads compatibility routines for libgcc2 for VxWorks.\n+   These are out-of-line routines called from gthr-vxworks.h.  */\n+\n #include \"tconfig.h\"\n #include \"tsystem.h\"\n #include \"gthr.h\"\n \n+#if defined(__GTHREADS)\n #include <vxWorks.h>\n+#ifndef __RTP__\n #include <vxLib.h>\n+#endif\n #include <taskLib.h>\n+#ifndef __RTP__\n #include <taskHookLib.h>\n+#else\n+# include <errno.h>\n+#endif\n \n /* Init-once operation.\n \n@@ -57,8 +64,12 @@ __gthread_once (__gthread_once_t *guard, void (*func)(void))\n   if (guard->done)\n     return 0;\n \n+#ifdef __RTP__\n+  __gthread_lock_library ();\n+#else\n   while (!vxTas ((void *)&guard->busy))\n     taskDelay (1);\n+#endif\n \n   /* Only one thread at a time gets here.  Check ->done again, then\n      go ahead and call func() if no one has done it yet.  */\n@@ -68,53 +79,67 @@ __gthread_once (__gthread_once_t *guard, void (*func)(void))\n       guard->done = 1;\n     }\n \n+#ifdef __RTP__\n+  __gthread_unlock_library ();\n+#else\n   guard->busy = 0;\n+#endif\n   return 0;\n }\n \n-/* Thread-specific data.\n+/* Thread-local storage.\n \n    We reserve a field in the TCB to point to a dynamically allocated\n-   array which is used to store TSD values.  A TSD key is simply an\n+   array which is used to store TLS values.  A TLS key is simply an\n    offset in this array.  The exact location of the TCB field is not\n    known to this code nor to vxlib.c -- all access to it indirects\n-   through the routines __gthread_get_tsd_data and\n-   __gthread_set_tsd_data, which are provided by the VxWorks kernel.\n+   through the routines __gthread_get_tls_data and\n+   __gthread_set_tls_data, which are provided by the VxWorks kernel.\n \n    There is also a global array which records which keys are valid and\n    which have destructors.\n \n    A task delete hook is installed to execute key destructors.  The\n-   routines __gthread_enter_tsd_dtor_context and\n-   __gthread_leave_tsd_dtor_context, which are also provided by the\n+   routines __gthread_enter_tls_dtor_context and\n+   __gthread_leave_tls_dtor_context, which are also provided by the\n    kernel, ensure that it is safe to call free() on memory allocated\n    by the task being deleted.  (This is a no-op on VxWorks 5, but\n    a major undertaking on AE.)\n \n+   The task delete hook is only installed when at least one thread\n+   has TLS data.  This is a necessary precaution, to allow this module\n+   to be unloaded - a module with a hook can not be removed.\n+\n    Since this interface is used to allocate only a small number of\n    keys, the table size is small and static, which simplifies the\n    code quite a bit.  Revisit this if and when it becomes necessary.  */\n \n #define MAX_KEYS 4\n \n /* This is the structure pointed to by the pointer returned\n-   by __gthread_get_tsd_data.  */\n-struct tsd_data\n+   by __gthread_get_tls_data.  */\n+struct tls_data\n {\n+  int *owner;\n   void *values[MAX_KEYS];\n   unsigned int generation[MAX_KEYS];\n };\n \n+/* To make sure we only delete TLS data associated with this object,\n+   include a pointer to a local variable in the TLS data object.  */\n+static int self_owner;\n+\n+/* The number of threads for this module which have active TLS data.\n+   This is protected by tls_lock.  */\n+static int active_tls_threads;\n \n /* kernel provided routines */\n-extern void *__gthread_get_tsd_data (WIND_TCB *tcb);\n-extern void __gthread_set_tsd_data (WIND_TCB *tcb, void *data);\n+extern void *__gthread_get_tls_data (void);\n+extern void __gthread_set_tls_data (void *data);\n \n-extern void __gthread_enter_tsd_dtor_context (WIND_TCB *tcb);\n-extern void __gthread_leave_tsd_dtor_context (WIND_TCB *tcb);\n+extern void __gthread_enter_tls_dtor_context (void);\n+extern void __gthread_leave_tls_dtor_context (void);\n \n-typedef void (*fet_callback_t) (WIND_TCB *, unsigned int);\n-extern void __gthread_for_all_tasks (fet_callback_t fun, unsigned int number);\n \n /* This is a global structure which records all of the active keys.\n \n@@ -128,104 +153,133 @@ extern void __gthread_for_all_tasks (fet_callback_t fun, unsigned int number);\n    stored in this structure is equal to the generation count stored in\n    T's specific-value structure.  */\n \n-typedef void (*tsd_dtor) (void *);\n+typedef void (*tls_dtor) (void *);\n \n-struct tsd_keys\n+struct tls_keys\n {\n-  tsd_dtor dtor[MAX_KEYS];\n+  tls_dtor dtor[MAX_KEYS];\n   unsigned int generation[MAX_KEYS];\n };\n \n-#define KEY_VALID_P(key) !(tsd_keys.generation[key] & 1)\n+#define KEY_VALID_P(key) !(tls_keys.generation[key] & 1)\n \n /* Note: if MAX_KEYS is increased, this initializer must be updated\n    to match.  All the generation counts begin at 1, which means no\n    key is valid.  */\n-static struct tsd_keys tsd_keys =\n+static struct tls_keys tls_keys =\n {\n   { 0, 0, 0, 0 },\n   { 1, 1, 1, 1 }\n };\n \n-/* This lock protects the tsd_keys structure.  */\n-static __gthread_mutex_t tsd_lock;\n+/* This lock protects the tls_keys structure.  */\n+static __gthread_mutex_t tls_lock;\n \n-static __gthread_once_t tsd_init_guard = __GTHREAD_ONCE_INIT;\n+static __gthread_once_t tls_init_guard = __GTHREAD_ONCE_INIT;\n \n /* Internal routines.  */\n \n /* The task TCB has just been deleted.  Call the destructor\n-   function for each TSD key that has both a destructor and\n+   function for each TLS key that has both a destructor and\n    a non-NULL specific value in this thread.\n \n-   This routine does not need to take tsd_lock; the generation\n+   This routine does not need to take tls_lock; the generation\n    count protects us from calling a stale destructor.  It does\n-   need to read tsd_keys.dtor[key] atomically.  */\n+   need to read tls_keys.dtor[key] atomically.  */\n \n static void\n-tsd_delete_hook (WIND_TCB *tcb)\n+tls_delete_hook (void *tcb ATTRIBUTE_UNUSED)\n {\n-  struct tsd_data *data = __gthread_get_tsd_data (tcb);\n+  struct tls_data *data = __gthread_get_tls_data ();\n   __gthread_key_t key;\n \n-  if (data)\n+  if (data && data->owner == &self_owner)\n     {\n-      __gthread_enter_tsd_dtor_context (tcb);\n+      __gthread_enter_tls_dtor_context ();\n       for (key = 0; key < MAX_KEYS; key++)\n \t{\n-\t  if (data->generation[key] == tsd_keys.generation[key])\n+\t  if (data->generation[key] == tls_keys.generation[key])\n \t    {\n-\t      tsd_dtor dtor = tsd_keys.dtor[key];\n+\t      tls_dtor dtor = tls_keys.dtor[key];\n \n \t      if (dtor)\n \t\tdtor (data->values[key]);\n \t    }\n \t}\n       free (data);\n-      __gthread_set_tsd_data (tcb, 0);\n-      __gthread_leave_tsd_dtor_context (tcb);\n+\n+      /* We can't handle an error here, so just leave the thread\n+\t marked as loaded if one occurs.  */\n+      if (__gthread_mutex_lock (&tls_lock) != ERROR)\n+\t{\n+\t  active_tls_threads--;\n+\t  if (active_tls_threads == 0)\n+\t    taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);\n+\t  __gthread_mutex_unlock (&tls_lock);\n+\t}\n+\n+      __gthread_set_tls_data (0);\n+      __gthread_leave_tls_dtor_context ();\n     }\n } \n \n-/* Initialize global data used by the TSD system.  */\n+/* Initialize global data used by the TLS system.  */\n static void\n-tsd_init (void)\n+tls_init (void)\n {\n-  taskDeleteHookAdd ((FUNCPTR)tsd_delete_hook);\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&tsd_lock);\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&tls_lock);\n+}\n+\n+static void tls_destructor (void) __attribute__ ((destructor));\n+static void\n+tls_destructor (void)\n+{\n+#ifdef __RTP__\n+  /* All threads but this one should have exited by now.  */\n+  tls_delete_hook (NULL);\n+#else\n+  /* Unregister the hook forcibly.  The counter of active threads may\n+     be incorrect, because constructors (like the C++ library's) and\n+     destructors (like this one) run in the context of the shell rather\n+     than in a task spawned from this module.  */\n+  taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);\n+#endif\n+\n+  if (tls_init_guard.done && __gthread_mutex_lock (&tls_lock) != ERROR)\n+    semDelete (tls_lock);\n }\n \n /* External interface */\n \n /* Store in KEYP a value which can be passed to __gthread_setspecific/\n-   __gthread_getspecific to store and retrieve a value which is\n+   __gthread_getspecific to store and retrive a value which is\n    specific to each calling thread.  If DTOR is not NULL, it will be\n    called when a thread terminates with a non-NULL specific value for\n    this key, with the value as its sole argument.  */\n \n int\n-__gthread_key_create (__gthread_key_t *keyp, tsd_dtor dtor)\n+__gthread_key_create (__gthread_key_t *keyp, tls_dtor dtor)\n {\n   __gthread_key_t key;\n \n-  __gthread_once (&tsd_init_guard, tsd_init);\n+  __gthread_once (&tls_init_guard, tls_init);\n \n-  if (__gthread_mutex_lock (&tsd_lock) == ERROR)\n+  if (__gthread_mutex_lock (&tls_lock) == ERROR)\n     return errno;\n \n   for (key = 0; key < MAX_KEYS; key++)\n     if (!KEY_VALID_P (key))\n       goto found_slot;\n \n   /* no room */\n-  __gthread_mutex_unlock (&tsd_lock);\n+  __gthread_mutex_unlock (&tls_lock);\n   return EAGAIN;\n \n  found_slot:\n-  tsd_keys.generation[key]++;  /* making it even */\n-  tsd_keys.dtor[key] = dtor;\n+  tls_keys.generation[key]++;  /* making it even */\n+  tls_keys.dtor[key] = dtor;\n   *keyp = key;\n-  __gthread_mutex_unlock (&tsd_lock);\n+  __gthread_mutex_unlock (&tls_lock);\n   return 0;\n }\n \n@@ -238,21 +292,21 @@ __gthread_key_delete (__gthread_key_t key)\n   if (key >= MAX_KEYS)\n     return EINVAL;\n \n-  __gthread_once (&tsd_init_guard, tsd_init);\n+  __gthread_once (&tls_init_guard, tls_init);\n \n-  if (__gthread_mutex_lock (&tsd_lock) == ERROR)\n+  if (__gthread_mutex_lock (&tls_lock) == ERROR)\n     return errno;\n \n   if (!KEY_VALID_P (key))\n     {\n-      __gthread_mutex_unlock (&tsd_lock);\n+      __gthread_mutex_unlock (&tls_lock);\n       return EINVAL;\n     }\n \n-  tsd_keys.generation[key]++;  /* making it odd */\n-  tsd_keys.dtor[key] = 0;\n+  tls_keys.generation[key]++;  /* making it odd */\n+  tls_keys.dtor[key] = 0;\n \n-  __gthread_mutex_unlock (&tsd_lock);\n+  __gthread_mutex_unlock (&tls_lock);\n   return 0;\n }\n \n@@ -266,17 +320,17 @@ __gthread_key_delete (__gthread_key_t key)\n void *\n __gthread_getspecific (__gthread_key_t key)\n {\n-  struct tsd_data *data;\n+  struct tls_data *data;\n \n   if (key >= MAX_KEYS)\n     return 0;\n \n-  data = __gthread_get_tsd_data (taskTcb (taskIdSelf ()));\n+  data = __gthread_get_tls_data ();\n \n   if (!data)\n     return 0;\n \n-  if (data->generation[key] != tsd_keys.generation[key])\n+  if (data->generation[key] != tls_keys.generation[key])\n     return 0;\n \n   return data->values[key];\n@@ -289,31 +343,37 @@ __gthread_getspecific (__gthread_key_t key)\n    key_create/key_delete; the worst thing that can happen is that a\n    value is successfully stored into a dead generation (and then\n    immediately becomes invalid).  However, we do have to make sure\n-   to read tsd_keys.generation[key] atomically.  */\n+   to read tls_keys.generation[key] atomically.  */\n \n int\n __gthread_setspecific (__gthread_key_t key, void *value)\n {\n-  struct tsd_data *data;\n-  WIND_TCB *tcb;\n+  struct tls_data *data;\n   unsigned int generation;\n \n   if (key >= MAX_KEYS)\n     return EINVAL;\n \n-  tcb = taskTcb (taskIdSelf ());\n-  data = __gthread_get_tsd_data (tcb);\n+  data = __gthread_get_tls_data ();\n   if (!data)\n     {\n-      data = malloc (sizeof (struct tsd_data));\n+      if (__gthread_mutex_lock (&tls_lock) == ERROR)\n+\treturn ENOMEM;\n+      if (active_tls_threads == 0)\n+\ttaskDeleteHookAdd ((FUNCPTR)tls_delete_hook);\n+      active_tls_threads++;\n+      __gthread_mutex_unlock (&tls_lock);\n+\n+      data = malloc (sizeof (struct tls_data));\n       if (!data)\n \treturn ENOMEM;\n \n-      memset (data, 0, sizeof (struct tsd_data));\n-      __gthread_set_tsd_data (tcb, data);\n+      memset (data, 0, sizeof (struct tls_data));\n+      data->owner = &self_owner;\n+      __gthread_set_tls_data (data);\n     }\n \n-  generation = tsd_keys.generation[key];\n+  generation = tls_keys.generation[key];\n \n   if (generation & 1)\n     return EINVAL;\n@@ -323,3 +383,4 @@ __gthread_setspecific (__gthread_key_t key, void *value)\n \n   return 0;\n }\n+#endif /* __GTHREADS */"}, {"sha": "26445454b61bcba7b89b8939a87d49ad13e5d584", "filename": "gcc/config/vxworks.h", "status": "modified", "additions": 85, "deletions": 46, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxworks.h?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -1,64 +1,103 @@\n-/* Common VxWorks target definitions for GCC.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.\n+/* Common VxWorks target definitions for GNU compiler.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Free Software Foundation, Inc.\n    Contributed by Wind River Systems.\n+   Rewritten by CodeSourcery, LLC.\n \n This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n \n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n \n-/* Specify what to link with.  */\n-/* VxWorks does all the library stuff itself.  */\n-#undef\tLIB_SPEC\n-#define\tLIB_SPEC \"\"\n+/* In kernel mode, VxWorks provides all the libraries itself, as well as\n+   the functionality of startup files, etc.  In RTP mode, it behaves more\n+   like a traditional Unix, with more external files.  Most of our specs\n+   must be aware of the difference.  */\n \n-#undef LINK_SPEC\n-#define LINK_SPEC \"-r\"\n+/* The directory containing the VxWorks target headers.  */\n+#define VXWORKS_TARGET_DIR  \"/home/tornado/base6/target\"\n \n-/* VxWorks provides the functionality of crt0.o and friends itself.  */\n-#undef  STARTFILE_SPEC\n-#define\tSTARTFILE_SPEC \"\"\n+/* Since we provide a default -isystem, expand -isystem on the command\n+   line early.  */\n+#undef VXWORKS_ADDITIONAL_CPP_SPEC\n+#define VXWORKS_ADDITIONAL_CPP_SPEC \" \t\t\t\t\t\\\n+ %{!nostdinc:%{isystem*}}\t\t\t\t\t\t\\\n+ %{mrtp: -D__RTP__=1\t\t\t\t\t\t\t\\\n+\t %{!nostdinc:-isystem \" VXWORKS_TARGET_DIR \"/usr/h}}\t\t\\\n+ %{!mrtp:-D_WRS_KERNEL=1\t\t\t\t\t\t\\\n+\t %{!nostdinc:-isystem \" VXWORKS_TARGET_DIR \"/h}}\"\n \n-#undef ENDFILE_SPEC\n-#define ENDFILE_SPEC \"\"\n+/* The references to __init and __fini will be satisified by\n+   libc_internal.a.  */\n+#undef VXWORKS_LIB_SPEC\n+#define\tVXWORKS_LIB_SPEC\t\t\t\t\t\t\\\n+\"%{mrtp:%{shared:-u \" USER_LABEL_PREFIX \"__init -u \" USER_LABEL_PREFIX \"__fini} \\\n+\t%{!shared:%{non-static:-u \" USER_LABEL_PREFIX \"_STI__6__rtld -ldl} \\\n+\t\t  --start-group -lc -lgcc -lc_internal -lnet -ldsi\t\\\n+\t\t  --end-group}}\"\n \n-/* VxWorks cannot have dots in constructor labels, because it uses a\n-   mutant variation of collect2 that generates C code instead of\n-   assembly.  Thus each constructor label must be a legitimate C\n-   symbol.  FIXME: Have VxWorks use real collect2 instead.  */\n+/* The no-op spec for \"-shared\" below is present because otherwise GCC\n+   will treat it as an unrecognized option.  */\n+#undef VXWORKS_LINK_SPEC\n+#define VXWORKS_LINK_SPEC\t\t\t\t\\\n+\"%{!mrtp:-r}\t\t\t\t\t\t\\\n+ %{!shared:\t\t\t\t\t\t\\\n+   %{mrtp:-q %{h*}\t\t\t\t\t\\\n+          %{R*} %{!Wl,-T*: %{!T*: %(link_start) }}\t\\\n+          %(link_target) %(link_os)}}\t\t\t\\\n+ %{v:-V}\t\t\t\t\t\t\\\n+ %{shared:-shared}\t\t\t\t\t\\\n+ %{Bstatic:-Bstatic}\t\t\t\t\t\\\n+ %{Bdynamic:-Bdynamic}\t\t\t\t\t\\\n+ %{!Xbind-lazy:-z now}\t\t\t\t\t\\\n+ %{Xbind-now:%{Xbind-lazy:\t\t\t\t\\\n+   %e-Xbind-now and -Xbind-lazy are incompatible}}\t\\\n+ %{mrtp:%{!shared:%{!non-static:-static}\t\t\\\n+ \t\t  %{non-static:--force-dynamic --export-dynamic}}}\"\n \n-#undef NO_DOLLAR_IN_LABEL\n-#define NO_DOT_IN_LABEL\n+/* For VxWorks, the system provides libc_internal.a.  This is a superset\n+   of libgcc.a; we want to use it.  Make sure not to dynamically export\n+   any of its symbols, though.  Always look for libgcc.a first so that\n+   we get the latest versions of the GNU intrinsics during our builds.  */\n+#undef VXWORKS_LIBGCC_SPEC\n+#define VXWORKS_LIBGCC_SPEC \\\n+  \"-lgcc %{mrtp:--exclude-libs=libc_internal,libgcc -lc_internal}\"\n \n-/* We want #pragma pack(n) enabled and expect to inherit the proper\n-   definition of HANDLE_SYSV_PRAGMA from elfos.h for that purpose.  */\n+#undef VXWORKS_STARTFILE_SPEC\n+#define\tVXWORKS_STARTFILE_SPEC \"%{mrtp:%{!shared:crt0.o%s}}\"\n+#define VXWORKS_ENDFILE_SPEC \"\"\n \n-/* No underscore is prepended to any C symbol name.  */\n-#undef USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"\"\n+/* We can use .ctors/.dtors sections only in RTP mode.\n+   Unfortunately this must be an integer constant expression;\n+   fix up in override_options.  */\n+#undef VXWORKS_OVERRIDE_OPTIONS\n+#define VXWORKS_OVERRIDE_OPTIONS do { \\\n+  targetm.have_ctors_dtors = TARGET_VXWORKS_RTP; \\\n+} while (0)\n \n-/* VxWorks uses wchar_t == unsigned short (UCS2) on all architectures.  */\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"short unsigned int\"\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE 16\n+/* The VxWorks runtime uses a clever trick to get the sentinel entry\n+   (-1) inserted at the beginning of the .ctors segment.  This trick\n+   will not work if we ever generate any entries in plain .ctors\n+   sections; we must always use .ctors.PRIORITY.  */\n+#define ALWAYS_NUMBER_CTORS_SECTIONS 1\n \n-/* Dwarf2 unwind info is not supported.  */\n-#define DWARF2_UNWIND_INFO 0\n-/* Weak symbols and link-once sections are not enabled by default.  */\n-#define DEFAULT_USE_WEAK 0\n+/* The name of the symbol for the table of GOTs in a particular\n+   RTP.  */\n+#define VXWORKS_GOTT_BASE \"__GOTT_BASE__\"\n+/* The name of the symbol for the index into the table of GOTs for the\n+   GOT associated with the current shared library.  */\n+#define VXWORKS_GOTT_INDEX \"__GOTT_INDEX__\"\n \n-/* Only supported debug format is Dwarf2.  */\n-#undef DBX_DEBUGGING_INFO\n+#define VXWORKS_KIND VXWORKS_KIND_NORMAL"}, {"sha": "98a44f57a6cf25f25c99db6b5487a0bffbe1dac5", "filename": "gcc/config/vxworks.opt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Fvxworks.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Fvxworks.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxworks.opt?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -0,0 +1,32 @@\n+; Processor-independent options for VxWorks.\n+;\n+; Copyright (C) 2005 Free Software Foundation, Inc.\n+; Contributed by CodeSourcery, LLC.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 2, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING.  If not, write to the Free\n+; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+; 02110-1301, USA.\n+\n+mrtp\n+Target Report RejectNegative Mask(VXWORKS_RTP) Condition(VXWORKS_KIND == VXWORKS_KIND_NORMAL)\n+Assume the VxWorks RTP environment\n+\n+; VxWorks AE has two modes: kernel mode and vThreads mode.  In\n+; general, back ends do not actually need to know which mode they're\n+; in, so we do not have to set any flags.\n+mvthreads\n+Target RejectNegative Condition(VXWORKS_KIND == VXWORKS_KIND_AE)\n+Assume the VxWorks vThreads environment"}, {"sha": "b63192ecb1597176ba556fe8c17ed937afe37f41", "filename": "gcc/config/vxworksae.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Fvxworksae.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Fconfig%2Fvxworksae.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxworksae.h?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -0,0 +1,58 @@\n+/* Common VxWorks AE target definitions for GNU compiler.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery, LLC.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* This header should be included after including vx-common.h.  */\n+\n+/* Most of the definitions below this point are versions of the\n+   vxworks.h definitions, without the -mrtp bits.  */\n+\n+/* The directory containing the VxWorks AE target headers.  */\n+#define VXWORKSAE_TARGET_DIR \\\n+  \"/home/tornado/vxworks-ae/latest/target\"\n+\n+/* Include target/vThreads/h or target/h (depending on the compilation\n+   mode), and then target/val/h (in either mode).  The macros defined\n+   are in the user's namespace, but the VxWorks headers require\n+   them.  */\n+#undef VXWORKS_ADDITIONAL_CPP_SPEC\n+#define VXWORKS_ADDITIONAL_CPP_SPEC \"\t\t\t\t\t\\\n+ %{!nostdinc:%{isystem*}}\t\t\t\t\t\t\\\n+ %{mvthreads:-DVTHREADS=1\t\t\t\t\t\t\\\n+\t %{!nostdinc:-isystem \" VXWORKSAE_TARGET_DIR \"/vThreads/h}}\t\\\n+ %{!mvthreads:-DAE653_BUILD=1\t\t\t\t\t\t\\\n+\t %{!nostdinc:-isystem \" VXWORKSAE_TARGET_DIR \"/h}}\t\t\\\n+ %{!nostdinc:-isystem \" VXWORKSAE_TARGET_DIR \"/val/h}\"\n+\n+#undef VXWORKS_LIB_SPEC\n+#define VXWORKS_LIB_SPEC \"\"\n+\n+#undef VXWORKS_LINK_SPEC\n+#define VXWORKS_LINK_SPEC\t\\\n+  \"-r %{v:-V}\"\n+ \n+#undef VXWORKS_LIBGCC_SPEC\n+#define VXWORKS_LIBGCC_SPEC\t\\\n+  \"-lgcc\"\n+\n+#undef VXWORKS_STARTFILE_SPEC\n+#define VXWORKS_STARTFILE_SPEC \"\"\n+\n+#define VXWORKS_KIND VXWORKS_KIND_AE"}, {"sha": "e874bb7147b05f150023ed701928f607238e6ba0", "filename": "gcc/target-def.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab15c97414cf1358106b009a4edd7f5f6151b1/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=2eab15c97414cf1358106b009a4edd7f5f6151b1", "patch": "@@ -126,12 +126,14 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_ASM_OUTPUT_MI_THUNK NULL\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_tree_hwi_hwi_tree_false\n \n-#if defined(TARGET_ASM_CONSTRUCTOR) && defined(TARGET_ASM_DESTRUCTOR)\n-#define TARGET_HAVE_CTORS_DTORS true\n-#else\n-#define TARGET_HAVE_CTORS_DTORS false\n-#define TARGET_ASM_CONSTRUCTOR NULL\n-#define TARGET_ASM_DESTRUCTOR NULL\n+#if !defined(TARGET_HAVE_CTORS_DTORS)\n+# if defined(TARGET_ASM_CONSTRUCTOR) && defined(TARGET_ASM_DESTRUCTOR)\n+# define TARGET_HAVE_CTORS_DTORS true\n+# else\n+# define TARGET_HAVE_CTORS_DTORS false\n+# define TARGET_ASM_CONSTRUCTOR NULL\n+# define TARGET_ASM_DESTRUCTOR NULL\n+# endif\n #endif\n \n #ifdef TARGET_ASM_NAMED_SECTION"}]}