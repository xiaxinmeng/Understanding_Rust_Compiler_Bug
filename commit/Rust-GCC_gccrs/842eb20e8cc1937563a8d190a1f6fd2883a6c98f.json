{"sha": "842eb20e8cc1937563a8d190a1f6fd2883a6c98f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQyZWIyMGU4Y2MxOTM3NTYzYThkMTkwYTFmNmZkMjg4M2E2Yzk4Zg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-28T22:41:38Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-28T22:41:38Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r617", "tree": {"sha": "a641fe95b7e51b1d7046c385f339ea620793ba0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a641fe95b7e51b1d7046c385f339ea620793ba0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/842eb20e8cc1937563a8d190a1f6fd2883a6c98f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/842eb20e8cc1937563a8d190a1f6fd2883a6c98f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/842eb20e8cc1937563a8d190a1f6fd2883a6c98f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/842eb20e8cc1937563a8d190a1f6fd2883a6c98f/comments", "author": null, "committer": null, "parents": [{"sha": "ae65ba85168d63989afe2455c54e5ba2df8dbe00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae65ba85168d63989afe2455c54e5ba2df8dbe00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae65ba85168d63989afe2455c54e5ba2df8dbe00"}], "stats": {"total": 307, "additions": 270, "deletions": 37}, "files": [{"sha": "a4f1172ad15dd6c952f0d152159fcd2ef90fbeca", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 235, "deletions": 34, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842eb20e8cc1937563a8d190a1f6fd2883a6c98f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842eb20e8cc1937563a8d190a1f6fd2883a6c98f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=842eb20e8cc1937563a8d190a1f6fd2883a6c98f", "patch": "@@ -77,6 +77,7 @@ extern rtx gen_movhi ();\n extern rtx gen_movsi ();\n extern rtx gen_movsi_ulw ();\n extern rtx gen_movsi_usw ();\n+extern rtx gen_movstrsi_internal ();\n extern rtx gen_addsi3 ();\n extern rtx gen_iorsi3 ();\n extern rtx gen_andsi3 ();\n@@ -1029,7 +1030,7 @@ mips_move_1word (operands, insn, unsignedp)\n \t      else if (FP_REG_P (regno0))\n \t\t{\n \t\t  delay = DELAY_LOAD;\n-\t\t  return \"mtc1\\t%z1,%0\";\n+\t\t  ret = \"mtc1\\t%z1,%0\";\n \t\t}\n \t    }\n \n@@ -1074,7 +1075,8 @@ mips_move_1word (operands, insn, unsignedp)\n \t  if (HALF_PIC_P () && CONSTANT_P (op1) && HALF_PIC_ADDRESS_P (op1))\n \t    {\n \t      delay = DELAY_LOAD;\n-\t      ret = \"la\\t%0,%a1\\t\\t# pic reference\";\n+\t      ret = \"lw\\t%0,%2\\t\\t# pic reference\";\n+\t      operands[2] = HALF_PIC_PTR (op1);\n \t    }\n \t  else\n \t    ret = \"la\\t%0,%a1\";\n@@ -1619,12 +1621,13 @@ gen_conditional_branch (operands, test_code)\n    The load is emitted directly, and the store insn is returned.  */\n \n static rtx\n-block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align)\n+block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align, orig_src)\n      rtx src_reg;\t\t/* register holding source memory addresss */\n      rtx dest_reg;\t\t/* register holding dest. memory addresss */\n      int *p_bytes;\t\t/* pointer to # bytes remaining */\n      int *p_offset;\t\t/* pointer to current offset */\n      int align;\t\t\t/* alignment */\n+     rtx orig_src;\t\t/* original source for making a reg note */\n {\n   int bytes;\t\t\t/* # bytes remaining */\n   int offset;\t\t\t/* offset to use */\n@@ -1633,6 +1636,8 @@ block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align)\n   rtx reg;\t\t\t/* temporary register */\n   rtx src_addr;\t\t\t/* source address */\n   rtx dest_addr;\t\t/* destination address */\n+  rtx insn;\t\t\t/* insn of the load */\n+  rtx orig_src_addr;\t\t/* original source address */\n   rtx (*load_func)();\t\t/* function to generate load insn */\n   rtx (*store_func)();\t\t/* function to generate destination insn */\n \n@@ -1648,13 +1653,17 @@ block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align)\n       store_func = gen_movsi;\n     }\n \n+#if 0\n+  /* Don't generate unligned moves here, rather defer those to the\n+     general movestrsi_internal pattern.  */\n   else if (bytes >= UNITS_PER_WORD)\n     {\n       mode = SImode;\n       size = UNITS_PER_WORD;\n       load_func = gen_movsi_ulw;\n       store_func = gen_movsi_usw;\n     }\n+#endif\n \n   else if (bytes >= UNITS_PER_SHORT && align >= UNITS_PER_SHORT)\n     {\n@@ -1688,7 +1697,13 @@ block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align)\n     }\n \n   reg = gen_reg_rtx (mode);\n-  emit_insn ((*load_func) (reg, gen_rtx (MEM, mode, src_addr)));\n+  insn = emit_insn ((*load_func) (reg, gen_rtx (MEM, mode, src_addr)));\n+  orig_src_addr = XEXP (orig_src, 0);\n+  if (CONSTANT_P (orig_src_addr))\n+    REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUIV,\n+\t\t\t\tplus_constant (orig_src_addr, offset),\n+\t\t\t\tREG_NOTES (insn));\n+\n   return (*store_func) (gen_rtx (MEM, mode, dest_addr), reg);\n }\n \n@@ -1710,11 +1725,12 @@ block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align)\n    in deference to the R4000.  */\n \n static void\n-block_move_sequence (dest_reg, src_reg, bytes, align)\n+block_move_sequence (dest_reg, src_reg, bytes, align, orig_src)\n      rtx dest_reg;\t\t/* register holding destination address */\n      rtx src_reg;\t\t/* register holding source address */\n      int bytes;\t\t\t/* # bytes to move */\n      int align;\t\t\t/* max alignment to assume */\n+     rtx orig_src;\t\t/* original source for making a reg note */\n {\n   int offset\t\t= 0;\n   rtx prev2_store\t= (rtx)0;\n@@ -1729,7 +1745,9 @@ block_move_sequence (dest_reg, src_reg, bytes, align)\n \n       prev2_store = prev_store;\n       prev_store = cur_store;\n-      cur_store = block_move_load_store (dest_reg, src_reg, &bytes, &offset, align);\n+      cur_store = block_move_load_store (dest_reg, src_reg,\n+\t\t\t\t\t &bytes, &offset,\n+\t\t\t\t\t align, orig_src);\n     }\n \n   /* Finish up last three stores.  */\n@@ -1751,11 +1769,11 @@ block_move_sequence (dest_reg, src_reg, bytes, align)\n      temp2 = src[1];\n      ...\n      temp<last> = src[MAX_MOVE_REGS-1];\n-     src += MAX_MOVE_REGS;\n      dest[0] = temp1;\n      dest[1] = temp2;\n      ...\n      dest[MAX_MOVE_REGS-1] = temp<last>;\n+     src += MAX_MOVE_REGS;\n      dest += MAX_MOVE_REGS;\n    } while (src != final);\n \n@@ -1770,19 +1788,21 @@ block_move_sequence (dest_reg, src_reg, bytes, align)\n #define MAX_MOVE_BYTES (MAX_MOVE_REGS * UNITS_PER_WORD)\n \n static void\n-block_move_loop (dest_reg, src_reg, bytes, align)\n+block_move_loop (dest_reg, src_reg, bytes, align, orig_src)\n      rtx dest_reg;\t\t/* register holding destination address */\n      rtx src_reg;\t\t/* register holding source address */\n      int bytes;\t\t\t/* # bytes to move */\n      int align;\t\t\t/* alignment */\n+     rtx orig_src;\t\t/* original source for making a reg note */\n {\n-  rtx stores[MAX_MOVE_REGS];\n+  rtx dest_mem\t\t= gen_rtx (MEM, BLKmode, dest_reg);\n+  rtx src_mem\t\t= gen_rtx (MEM, BLKmode, src_reg);\n+  rtx align_rtx\t\t= gen_rtx (CONST_INT, VOIDmode, align);\n   rtx label;\n   rtx final_src;\n   rtx bytes_rtx;\n   int i;\n   int leftover;\n-  int offset;\n \n   if (bytes < 2*MAX_MOVE_BYTES)\n     abort ();\n@@ -1804,20 +1824,17 @@ block_move_loop (dest_reg, src_reg, bytes, align)\n \n   emit_label (label);\n \n-  offset = 0;\n-  for (i = 0; i < MAX_MOVE_REGS; i++)\n-    stores[i] = block_move_load_store (dest_reg, src_reg, &bytes, &offset, align);\n-\n-  emit_insn (gen_addsi3 (src_reg, src_reg, gen_rtx (CONST_INT, VOIDmode, MAX_MOVE_BYTES)));\n-  for (i = 0; i < MAX_MOVE_REGS; i++)\n-    emit_insn (stores[i]);\n-\n-  emit_insn (gen_addsi3 (dest_reg, dest_reg, gen_rtx (CONST_INT, VOIDmode, MAX_MOVE_BYTES)));\n+  bytes_rtx = gen_rtx (CONST_INT, VOIDmode, MAX_MOVE_BYTES);\n+  emit_insn (gen_movstrsi_internal (dest_mem, src_mem, bytes_rtx, align_rtx));\n+  emit_insn (gen_addsi3 (src_reg, src_reg, bytes_rtx));\n+  emit_insn (gen_addsi3 (dest_reg, dest_reg, bytes_rtx));\n   emit_insn (gen_cmpsi (src_reg, final_src));\n   emit_jump_insn (gen_bne (label));\n \n   if (leftover)\n-    block_move_sequence (dest_reg, src_reg, leftover, align);\n+    emit_insn (gen_movstrsi_internal (dest_mem, src_mem,\n+\t\t\t\t      gen_rtx (CONST_INT, VOIDmode, leftover),\n+\t\t\t\t      align_rtx));\n }\n \n \f\n@@ -1857,27 +1874,39 @@ expand_block_move (operands)\n      rtx operands[];\n {\n   rtx bytes_rtx\t= operands[2];\n+  rtx align_rtx = operands[3];\n   int constp\t= (GET_CODE (bytes_rtx) == CONST_INT);\n   int bytes\t= (constp ? INTVAL (bytes_rtx) : 0);\n-  int align\t= INTVAL (operands[3]);\n+  int align\t= INTVAL (align_rtx);\n+  rtx orig_src\t= operands[1];\n   rtx src_reg;\n   rtx dest_reg;\n \n   if (constp && bytes <= 0)\n     return;\n \n+  if (align > UNITS_PER_WORD)\n+    align = UNITS_PER_WORD;\n+\n   /* Move the address into scratch registers.  */\n   dest_reg = copy_addr_to_reg (XEXP (operands[0], 0));\n-  src_reg  = copy_addr_to_reg (XEXP (operands[1], 0));\n+  src_reg  = copy_addr_to_reg (XEXP (orig_src, 0));\n \n   if (TARGET_MEMCPY)\n     block_move_call (dest_reg, src_reg, bytes_rtx);\n \n+#if 0\n+  else if (constp && bytes <= 3*align)\n+    block_move_sequence (dest_reg, src_reg, bytes, align, orig_src);\n+#endif\n+\n   else if (constp && bytes <= 2*MAX_MOVE_BYTES)\n-    block_move_sequence (dest_reg, src_reg, bytes, align);\n+    emit_insn (gen_movstrsi_internal (gen_rtx (MEM, BLKmode, dest_reg),\n+\t\t\t\t      gen_rtx (MEM, BLKmode, src_reg),\n+\t\t\t\t      bytes_rtx, align_rtx));\n \n   else if (constp && align >= UNITS_PER_WORD && optimize)\n-    block_move_loop (dest_reg, src_reg, bytes, align);\n+    block_move_loop (dest_reg, src_reg, bytes, align, orig_src);\n \n   else if (constp && optimize)\n     {\n@@ -1898,24 +1927,184 @@ expand_block_move (operands)\n       emit_jump_insn (gen_beq (aligned_label));\n \n       /* Unaligned loop.  */\n-      block_move_loop (dest_reg, src_reg, bytes, 1);\n+      block_move_loop (dest_reg, src_reg, bytes, 1, orig_src);\n       emit_jump_insn (gen_jump (join_label));\n       emit_barrier ();\n \n       /* Aligned loop.  */\n       emit_label (aligned_label);\n-      block_move_loop (dest_reg, src_reg, bytes, UNITS_PER_WORD);\n+      block_move_loop (dest_reg, src_reg, bytes, UNITS_PER_WORD, orig_src);\n       emit_label (join_label);\n \n       /* Bytes at the end of the loop.  */\n       if (leftover)\n-\tblock_move_sequence (dest_reg, src_reg, leftover, align);\n+\t{\n+#if 0\n+\t  if (leftover <= 3*align)\n+\t    block_move_sequence (dest_reg, src_reg, leftover, align, orig_src);\n+\n+\t  else\n+#endif\n+\t    emit_insn (gen_movstrsi_internal (gen_rtx (MEM, BLKmode, dest_reg),\n+\t\t\t\t\t      gen_rtx (MEM, BLKmode, src_reg),\n+\t\t\t\t\t      gen_rtx (CONST_INT, VOIDmode, leftover),\n+\t\t\t\t\t      gen_rtx (CONST_INT, VOIDmode, align)));\n+\t}\n     }\n \n   else\n     block_move_call (dest_reg, src_reg, bytes_rtx);\n }\n \n+\f\n+/* Emit load/stores for a small constant block_move. \n+\n+   operands[0] is the memory address of the destination.\n+   operands[1] is the memory address of the source.\n+   operands[2] is the number of bytes to move.\n+   operands[3] is the alignment.\n+   operands[4] is a temp register.\n+   operands[5] is a temp register.\n+   ... */\n+\n+char *\n+output_block_move (insn, operands, num_regs)\n+     rtx insn;\n+     rtx operands[];\n+     int num_regs;\n+{\n+  rtx dest_reg\t\t= XEXP (operands[0], 0);\n+  rtx src_reg\t\t= XEXP (operands[1], 0);\n+  int bytes\t\t= INTVAL (operands[2]);\n+  int align\t\t= INTVAL (operands[3]);\n+  int num\t\t= 0;\n+  int offset\t\t= 0;\n+  int i;\n+  rtx xoperands[10];\n+\n+  struct {\n+    char *load;\t\t\t/* load insn without nop */\n+    char *load_nop;\t\t/* load insn with trailing nop */\n+    char *store;\t\t/* store insn */\n+    int offset;\t\t\t/* current offset */\n+    enum machine_mode mode;\t/* mode to use on (MEM) */\n+  } load_store[4];\n+\n+  /* If we are given global or static addresses, and we would be\n+     emitting a few instructions, try to save time by using a\n+     temporary register for the pointer.  */\n+  if (bytes > 2*align)\n+    {\n+      if (CONSTANT_P (src_reg))\n+\t{\n+\t  xoperands[1] = operands[1];\n+\t  xoperands[0] = src_reg = operands[ 3 + num_regs-- ];\n+\t  output_asm_insn (\"la\\t%0,%1\", xoperands);\n+\t}\n+\n+      if (CONSTANT_P (dest_reg))\n+\t{\n+\t  xoperands[1] = operands[1];\n+\t  xoperands[0] = dest_reg = operands[ 3 + num_regs-- ];\n+\t  output_asm_insn (\"la\\t%0,%1\", xoperands);\n+\t}\n+    }\n+\n+  if (num_regs > (sizeof (load_store) / sizeof (load_store[0])))\n+    num_regs = (sizeof (load_store) / sizeof (load_store[0]));\n+\n+  else if (num_regs < 1)\n+    abort ();\n+\n+  if (TARGET_GAS && set_noreorder++ == 0)\n+    output_asm_insn (\".set\\tnoreorder\", operands);\n+\n+  while (bytes > 0)\n+    {\n+      load_store[num].offset = offset;\n+\n+      if (bytes >= UNITS_PER_WORD && align >= UNITS_PER_WORD)\n+\t{\n+\t  load_store[num].load     = \"lw\\t%0,%1\";\n+\t  load_store[num].load_nop = \"lw\\t%0,%1%#\";\n+\t  load_store[num].store    = \"sw\\t%0,%1\";\n+\t  load_store[num].mode     = SImode;\n+\t  offset += UNITS_PER_WORD;\n+\t  bytes -= UNITS_PER_WORD;\n+\t}\n+\n+      else if (bytes >= UNITS_PER_WORD)\n+\t{\n+\t  load_store[num].load     = \"ulw\\t%0,%1\";\n+\t  load_store[num].load_nop = \"ulw\\t%0,%1%#\";\n+\t  load_store[num].store    = \"usw\\t%0,%1\";\n+\t  load_store[num].mode     = SImode;\n+\t  offset += UNITS_PER_WORD;\n+\t  bytes -= UNITS_PER_WORD;\n+\t}\n+\n+      else if (bytes >= UNITS_PER_SHORT && align >= UNITS_PER_SHORT)\n+\t{\n+\t  load_store[num].load     = \"lh\\t%0,%1\";\n+\t  load_store[num].load_nop = \"lh\\t%0,%1%#\";\n+\t  load_store[num].store    = \"sh\\t%0,%1\";\n+\t  load_store[num].offset   = offset;\n+\t  load_store[num].mode     = HImode;\n+\t  offset += UNITS_PER_SHORT;\n+\t  bytes -= UNITS_PER_SHORT;\n+\t}\n+\n+      else\n+\t{\n+\t  load_store[num].load     = \"lb\\t%0,%1\";\n+\t  load_store[num].load_nop = \"lb\\t%0,%1%#\";\n+\t  load_store[num].store    = \"sb\\t%0,%1\";\n+\t  load_store[num].mode     = QImode;\n+\t  offset++;\n+\t  bytes--;\n+\t}\n+\n+      /* Emit load/stores now if we have run out of registers or are\n+\t at the end of the move.  */\n+\n+      if (++num == 4 || bytes == 0)\n+\t{\n+\t  /* If only load/store, we need a NOP after the load.  */\n+\t  if (num == 1)\n+\t    load_store[0].load = load_store[0].load_nop;\n+\n+\t  for (i = 0; i < num; i++)\n+\t    {\n+\t      if (!operands[i+4])\n+\t\tabort ();\n+\n+\t      if (GET_MODE (operands[i+4]) != load_store[i].mode)\n+\t\toperands[i+4] = gen_rtx (REG, load_store[i].mode, REGNO (operands[i+4]));\n+\n+\t      xoperands[0] = operands[i+4];\n+\t      xoperands[1] = gen_rtx (MEM, load_store[i].mode,\n+\t\t\t\t      plus_constant (src_reg, load_store[i].offset));\n+\t      output_asm_insn (load_store[i].load, xoperands);\n+\t    }\n+\n+\t  for (i = 0; i < num; i++)\n+\t    {\n+\t      xoperands[0] = operands[i+4];\n+\t      xoperands[1] = gen_rtx (MEM, load_store[i].mode,\n+\t\t\t\t      plus_constant (dest_reg, load_store[i].offset));\n+\t      output_asm_insn (load_store[i].store, xoperands);\n+\t    }\n+\n+\t  num = 0;\t\t/* reset load_store */\n+\t}\n+    }\n+\n+  if (TARGET_GAS && --set_noreorder == 0)\n+    output_asm_insn (\".set\\treorder\", operands);\n+\n+  return \"\";\n+}\n+\n \f\n /* Argument support functions.  */\n \n@@ -2234,20 +2423,26 @@ static void\n siginfo (signo)\n      int signo;\n {\n-  char print_pid[50];\n+  char select_pgrp[15];\n   char *argv[4];\n   pid_t pid;\n+  pid_t pgrp;\n   int status;\n \n   fprintf (stderr, \"compiling '%s' in '%s'\\n\",\n \t   (current_function_name != (char *)0) ? current_function_name : \"<toplevel>\",\n \t   (current_function_file != (char *)0) ? current_function_file : \"<no file>\");\n \n+  pgrp = getpgrp ();\n+  if (pgrp != -1)\n+    sprintf (select_pgrp, \"-g%d\", pgrp);\n+  else\n+    strcpy (select_pgrp, \"-a\");\n+\n   /* Spawn a ps to tell about current memory usage, etc. */\n-  sprintf (print_pid, \"-p%d,%d\", getpid (), getppid ());\n   argv[0] = \"ps\";\n-  argv[1] = print_pid;\n-  argv[2] = \"-ouser,state,pid,pri,nice,wchan,tt,start,usertime,systime,pcpu,cp,inblock,oublock,vsize,rss,pmem,ucomm\";\n+  argv[1] = \"-ouser,pid,pri,nice,usertime,systime,pcpu,cp,inblock,oublock,vsize,rss,pmem,ucomm\";\n+  argv[2] = select_pgrp;\n   argv[3] = (char *)0;\n \n   pid = vfork ();\n@@ -2270,10 +2465,7 @@ siginfo (signo)\n       (void) signal (SIGINT,  sigint);\n       (void) signal (SIGQUIT, sigquit);\n     }\n-\n-  signal (SIGINFO, siginfo);\n }\n-\n #endif /* SIGINFO */\n \n \f\n@@ -2417,6 +2609,12 @@ override_options ()\n     }\n #endif\n \n+#ifdef _IOLBF\n+  /* If -mstats and -quiet, make stderr line buffered.  */\n+  if (quiet_flag && TARGET_STATS)\n+    setvbuf (stderr, (char *)0, _IOLBF, BUFSIZ);\n+#endif\n+\n   /* Set up the classification arrays now.  */\n   mips_rtx_classify[(int)PLUS]  = CLASS_ADD_OP;\n   mips_rtx_classify[(int)MINUS] = CLASS_ADD_OP;\n@@ -3105,6 +3303,9 @@ mips_asm_file_end (file)\n   struct extern_list *p;\n   int len;\n \n+  if (HALF_PIC_P ())\n+    HALF_PIC_FINISH (file);\n+\n   if (TARGET_GP_OPT)\n     {\n       if (extern_head)"}, {"sha": "bf6afdc75781ee8c42f04cfcf0e319a0377e0afd", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842eb20e8cc1937563a8d190a1f6fd2883a6c98f/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842eb20e8cc1937563a8d190a1f6fd2883a6c98f/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=842eb20e8cc1937563a8d190a1f6fd2883a6c98f", "patch": "@@ -1628,11 +1628,18 @@ move\\\\t%0,%z4\\\\n\\\\\n   extern rtx gen_movsi_ulw ();\n   extern rtx gen_movsi ();\n \n-  if (GET_CODE (operands[0]) == MEM && !reg_or_0_operand (operands[1], SImode))\n+  /* Handle loads.  */\n+  if (GET_CODE (operands[0]) == MEM)\n     {\n       rtx reg = gen_reg_rtx (SImode);\n+      rtx insn = emit_insn (gen_movsi_ulw (reg, operands[1]));\n+      rtx addr = XEXP (operands[0], 0);\n+      if (CONSTANT_P (addr))\n+\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUIV, addr, REG_NOTES (insn));\n+\n+      if (reg_or_0_operand (operands[1], SImode))\n+\tDONE;\n \n-      emit_insn (gen_movsi_ulw (reg, operands[1]));\n       operands[1] = reg;\n     }\n \n@@ -1733,7 +1740,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n   return \\\"usw\\\\t%z1,%0\\\";\n }\"\n-  [(set_attr \"type\"\t\"load,load\")\n+  [(set_attr \"type\"\t\"store,store\")\n    (set_attr \"mode\"\t\"SI,SI\")\n    (set_attr \"length\"\t\"2,4\")])\n \n@@ -1881,6 +1888,23 @@ move\\\\t%0,%z4\\\\n\\\\\n     }\n }\")\n \n+;; Insn generated by block moves\n+\n+(define_insn \"movstrsi_internal\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"Ro\")\n+\t(match_operand:BLK 1 \"memory_operand\" \"Ro\"))\n+   (clobber (match_scratch:SI 4 \"d\"))\n+   (clobber (match_scratch:SI 5 \"d\"))\n+   (clobber (match_scratch:SI 6 \"d\"))\n+   (clobber (match_scratch:SI 7 \"d\"))\n+   (use (match_operand:SI 2 \"small_int\" \"I\"))\n+   (use (match_operand:SI 3 \"small_int\" \"I\"))]\n+  \"\"\n+  \"* return output_block_move (insn, operands, 4);\"\n+  [(set_attr \"type\"\t\"multi\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"20\")])\n+\n \f\n ;;\n ;;  ...................."}, {"sha": "d7336b17545d72ae7a72938084a1fbcc05b0ba52", "filename": "gcc/config/mips/svr3-4.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842eb20e8cc1937563a8d190a1f6fd2883a6c98f/gcc%2Fconfig%2Fmips%2Fsvr3-4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842eb20e8cc1937563a8d190a1f6fd2883a6c98f/gcc%2Fconfig%2Fmips%2Fsvr3-4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsvr3-4.h?ref=842eb20e8cc1937563a8d190a1f6fd2883a6c98f", "patch": "@@ -46,4 +46,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define MACHINE_TYPE \"RISC-OS System V Mips\"\n \n+/* Override defaults for finding the MIPS tools.  */\n+#define MD_STARTFILE_PREFIX \"/sysv/usr/lib/cmplrs/cc/\"\n+#define MD_EXEC_PREFIX \"/sysv/usr/lib/cmplrs/cc/\"\n+\n #include \"mips.h\""}, {"sha": "43ec03121d0e3acd3fbd08660d84a161f0a4329b", "filename": "gcc/config/mips/svr4-4.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842eb20e8cc1937563a8d190a1f6fd2883a6c98f/gcc%2Fconfig%2Fmips%2Fsvr4-4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842eb20e8cc1937563a8d190a1f6fd2883a6c98f/gcc%2Fconfig%2Fmips%2Fsvr4-4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsvr4-4.h?ref=842eb20e8cc1937563a8d190a1f6fd2883a6c98f", "patch": "@@ -46,4 +46,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define MACHINE_TYPE \"RISC-OS System V.4 Mips\"\n \n+/* Override defaults for finding the MIPS tools.  */\n+#define MD_STARTFILE_PREFIX \"/svr4/usr/lib/cmplrs/cc/\"\n+#define MD_EXEC_PREFIX \"/svr4/usr/lib/cmplrs/cc/\"\n+\n #include \"mips.h\""}]}