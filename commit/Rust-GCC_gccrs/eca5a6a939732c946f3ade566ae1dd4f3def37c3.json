{"sha": "eca5a6a939732c946f3ade566ae1dd4f3def37c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNhNWE2YTkzOTczMmM5NDZmM2FkZTU2NmFlMWRkNGYzZGVmMzdjMw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-04-25T18:44:10Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-04-25T18:44:10Z"}, "message": "jni.h (_Jv_va_list): Removed.\n\n\t* include/jni.h (_Jv_va_list): Removed.\n\tMoved configuration code...\n\t* include/jni_md.h: ... here.  New file.\n\t* include/Makefile.in: Rebuilt.\n\t* include/Makefile.am (tool_include__HEADERS): Added jni_md.h.\n\nFrom-SVN: r98730", "tree": {"sha": "f5e780c1953c9c9b3306f17ccf0035e652486ec0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5e780c1953c9c9b3306f17ccf0035e652486ec0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eca5a6a939732c946f3ade566ae1dd4f3def37c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eca5a6a939732c946f3ade566ae1dd4f3def37c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eca5a6a939732c946f3ade566ae1dd4f3def37c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eca5a6a939732c946f3ade566ae1dd4f3def37c3/comments", "author": null, "committer": null, "parents": [{"sha": "3321369fcea93ddae5b1d04b2589af1ef069be44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3321369fcea93ddae5b1d04b2589af1ef069be44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3321369fcea93ddae5b1d04b2589af1ef069be44"}], "stats": {"total": 567, "additions": 340, "deletions": 227}, "files": [{"sha": "7d828e398217888f5c093f56f2a9f0f4b749958f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca5a6a939732c946f3ade566ae1dd4f3def37c3/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca5a6a939732c946f3ade566ae1dd4f3def37c3/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=eca5a6a939732c946f3ade566ae1dd4f3def37c3", "patch": "@@ -1,3 +1,11 @@\n+2005-04-25  Tom Tromey  <tromey@redhat.com>\n+\n+\t* include/jni.h (_Jv_va_list): Removed.\n+\tMoved configuration code...\n+\t* include/jni_md.h: ... here.  New file.\n+\t* include/Makefile.in: Rebuilt.\n+\t* include/Makefile.am (tool_include__HEADERS): Added jni_md.h.\n+\n 2005-04-23  Jeroen Frijters  <jeroen@frijters.net>\n \n \t* java/io/FileInputStream.java (FileInputStream(File)),"}, {"sha": "f1d78390061bd305e0d05299277391f5c1b7370c", "filename": "libjava/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca5a6a939732c946f3ade566ae1dd4f3def37c3/libjava%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca5a6a939732c946f3ade566ae1dd4f3def37c3/libjava%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2FMakefile.am?ref=eca5a6a939732c946f3ade566ae1dd4f3def37c3", "patch": "@@ -9,4 +9,4 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n target_noncanonical = @target_noncanonical@\n \n tool_include_dir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include\n-tool_include__HEADERS = jni.h jawt.h jawt_md.h jvmpi.h\n+tool_include__HEADERS = jni.h jni_md.h jawt.h jawt_md.h jvmpi.h"}, {"sha": "35e3a48433f1bd08aa9be4d8584d67c731184d99", "filename": "libjava/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca5a6a939732c946f3ade566ae1dd4f3def37c3/libjava%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca5a6a939732c946f3ade566ae1dd4f3def37c3/libjava%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2FMakefile.in?ref=eca5a6a939732c946f3ade566ae1dd4f3def37c3", "patch": "@@ -300,7 +300,7 @@ AUTOMAKE_OPTIONS = foreign\n # May be used by various substitution variables.\n gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n tool_include_dir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include\n-tool_include__HEADERS = jni.h jawt.h jawt_md.h jvmpi.h\n+tool_include__HEADERS = jni.h jni_md.h jawt.h jawt_md.h jvmpi.h\n all: config.h\n \t$(MAKE) $(AM_MAKEFLAGS) all-am\n "}, {"sha": "743f7df437f1456082fc1ebb7ac96e9f46b5cb55", "filename": "libjava/include/jni.h", "status": "modified", "additions": 179, "deletions": 225, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca5a6a939732c946f3ade566ae1dd4f3def37c3/libjava%2Finclude%2Fjni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca5a6a939732c946f3ade566ae1dd4f3def37c3/libjava%2Finclude%2Fjni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjni.h?ref=eca5a6a939732c946f3ade566ae1dd4f3def37c3", "patch": "@@ -1,90 +1,58 @@\n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004  Free Software Foundation\n+/* jni.h\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2005  Free Software Foundation\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n /* Note: this file must be compilable by the C compiler (for now,\n    assuming GNU C is ok).  This means you must never use `//'\n    comments, and all C++-specific code must be conditional on\n    __cplusplus.  */\n \n-#ifndef __GCJ_JNI_H__\n-#define __GCJ_JNI_H__\n-\n-#include <gcj/libgcj-config.h>\n+#ifndef _CLASSPATH_JNI_H\n+#define _CLASSPATH_JNI_H\n \n /* We include <stdio.h> for compatibility with Sun's <jni.h>.  */\n #include <stdio.h>\n \n #include <stdarg.h>\n-#define _Jv_va_list va_list\n-\n-#ifdef __GCJ_JNI_IMPL__\n-\n-/* If __GCJ_JNI_IMPL__ is defined, then we assume that we're building\n-   libgcj itself, and we include headers which taint the namespace\n-   more than is acceptable for the ordinary JNI user.  */\n-#include <gcj/javaprims.h>\n-#include <gcj/array.h>\n-#include <gnu/gcj/runtime/JNIWeakRef.h>\n-\n-typedef gnu::gcj::runtime::JNIWeakRef *jweak;\n-\n-typedef struct _Jv_JNIEnv JNIEnv;\n-typedef struct _Jv_JavaVM JavaVM;\n-\n-#define JNI_TRUE true\n-#define JNI_FALSE false\n-\n-#else /* __GCJ_JNI_IMPL__ */\n-\n-# ifdef __GNUC__\n-\n-/* If we're using gcc, we can use a platform-independent scheme to get\n-   the right integer types.  FIXME: this is not always correct, for\n-   instance on the c4x it will be wrong -- it depends on whether\n-   QImode is 8 bits.  */\n-typedef int    jbyte  __attribute__((__mode__(__QI__)));\n-typedef int    jshort __attribute__((__mode__(__HI__)));\n-typedef int    jint   __attribute__((__mode__(__SI__)));\n-typedef int    jlong  __attribute__((__mode__(__DI__)));\n-typedef int    jboolean __attribute__((__mode__(__QI__)));\n-typedef unsigned short jchar __attribute__((__mode__(__HI__)));\n-typedef float  jfloat;\n-typedef double jdouble;\n-typedef jint jsize;\n-\n-# else /* __GNUC__ */\n-\n-#  ifdef JV_HAVE_INTTYPES_H\n-\n-/* If <inttypes.h> is available, we use it.  */\n-\n-#   include <inttypes.h>\n-\n-typedef int8_t jbyte;\n-typedef int16_t jshort;\n-typedef int32_t jint;\n-typedef int64_t jlong;\n-typedef float jfloat;\n-typedef double jdouble;\n-typedef jint jsize;\n-typedef int8_t jboolean;\n-typedef uint16_t jchar;\n-\n-#  else /* JV_HAVE_INTTYPES_H */\n \n-/* For now, we require either gcc or <inttypes.h>.  If we did more\n-   work at configure time we could get around this, but right now it\n-   doesn't seem worth it.  */\n-#   error jni.h not ported to this platform\n+#include \"jni_md.h\"\n \n-#  endif /* JV_HAVE_INTTYPES_H */\n-\n-# endif /* __GNUC__ */\n+/* The VM might define jobject and friends.  */\n+#ifndef _CLASSPATH_VM_JNI_TYPES_DEFINED\n \n # ifdef __cplusplus\n \n@@ -154,11 +122,21 @@ typedef const struct JNIInvokeInterface *JavaVM;\n \n # endif /* __cplusplus */\n \n-/* Dummy defines.  */\n-typedef void *jfieldID;\n-typedef void *jmethodID;\n+#endif /* _CLASSPATH_VM_JNI_TYPES_DEFINED */\n \n-#endif /* __GCJ_JNI_IMPL__ */\n+/* \n+ * Before jni.h is #included within a typical JVM, the source code should \n+ * #define _JNI_VM_INTERNAL_TYPES_DEFINED and provide the real declarations\n+ * for 'jobject', 'jfieldID', 'jmethodID' and other implementation types.\n+ * If _JNI_VM_INTERNAL_TYPES_DEFINED is not defined, the following \n+ * declares the old versions of the types.\n+ */\n+#ifndef _CLASSPATH_VM_INTERNAL_TYPES_DEFINED\n+struct _jfieldID;\n+struct _jmethodID;\n+typedef struct _jfieldID *jfieldID;\n+typedef struct _jmethodID *jmethodID;\n+#endif \n \n /* Version numbers.  */\n #define JNI_VERSION_1_1 0x00010001\n@@ -171,39 +149,11 @@ typedef void *jmethodID;\n \n /* Error codes */\n #define JNI_OK            0\n-#define JNI_ERR          -1\n-#define JNI_EDETACHED    -2\n-#define JNI_EVERSION     -3\n-\n-/* Linkage and calling conventions. */\n-#if defined (_WIN32) || defined (__WIN32__) || defined (WIN32)\n-\n-#define JNIIMPORT        __declspec(dllimport)\n-#define JNIEXPORT        __declspec(dllexport)\n-\n-#define JNICALL          __stdcall\n-\n-/* These defines apply to symbols in libgcj */\n-#ifdef __GCJ_DLL__\n-# ifdef __GCJ_JNI_IMPL__\n-#  define __GCJ_JNIIMPEXP__ JNIEXPORT\n-# else\n-#  define __GCJ_JNIIMPEXP__ JNIIMPORT\n-# endif /* ! __GCJ_JNI_IMPL__ */\n-#else /* ! __GCJ_DLL__ */\n-# define __GCJ_JNIIMPEXP__\n-#endif /*  __GCJ_DLL__ */\n+#define JNI_ERR          (-1)\n+#define JNI_EDETACHED    (-2)\n+#define JNI_EVERSION     (-3)\n \n-#else /* !( _WIN32 || __WIN32__ || WIN32) */\n \n-#define JNIIMPORT\n-#define JNIEXPORT\n-#define JNICALL\n-#define __GCJ_JNIIMPEXP__\n-\n-#endif /* !( _WIN32 || __WIN32__ || WIN32) */\n-\n- \n #ifdef __cplusplus\n extern \"C\"\n {\n@@ -214,16 +164,22 @@ extern \"C\"\n extern JNIEXPORT jint JNICALL JNI_OnLoad (JavaVM *, void *);\n extern JNIEXPORT void JNICALL JNI_OnUnload (JavaVM *, void *);\n \n+/* This can be defined as JNIIMPORT or JNIEXPORT by the md file,\n+   depending on whether this is the implementation or a user.  */\n+#ifndef _CLASSPATH_JNIIMPEXP\n+#define _CLASSPATH_JNIIMPEXP JNIIMPORT\n+#endif\n+\n /* These functions are called by user code to start using the\n    invocation API.  */\n-extern __GCJ_JNIIMPEXP__ jint JNICALL\n+extern _CLASSPATH_JNIIMPEXP jint JNICALL\n JNI_GetDefaultJavaVMInitArgs (void *);\n \n-extern __GCJ_JNIIMPEXP__ jint JNICALL\n+extern _CLASSPATH_JNIIMPEXP jint JNICALL\n JNI_CreateJavaVM (JavaVM **, void **, void *);\n \n-extern __GCJ_JNIIMPEXP__ jint JNICALL\n-JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *);\n+extern _CLASSPATH_JNIIMPEXP jint JNICALL\n+JNI_GetCreatedJavaVMs (JavaVM **, jsize, jsize *);\n \n #ifdef __cplusplus\n }\n@@ -298,7 +254,7 @@ struct JNINativeInterface\n   jobject (JNICALL *NewObject)\t\t\t   (JNIEnv *, jclass, \n                                                     jmethodID, ...);\n   jobject (JNICALL *NewObjectV)\t\t\t   (JNIEnv *, jclass, \n-                                                    jmethodID, _Jv_va_list);\n+                                                    jmethodID, va_list);\n   jobject (JNICALL *NewObjectA)\t\t\t   (JNIEnv *, jclass, \n                                                     jmethodID, jvalue *);\n \n@@ -309,114 +265,114 @@ struct JNINativeInterface\n \n   jobject (JNICALL *CallObjectMethod)\t   (JNIEnv *, jobject, jmethodID, ...);\n   jobject (JNICALL *CallObjectMethodV)\t   (JNIEnv *, jobject, jmethodID,\n-                                            _Jv_va_list);\n+                                            va_list);\n   jobject (JNICALL *CallObjectMethodA)\t   (JNIEnv *, jobject, jmethodID,\n                                             jvalue *);\n   jboolean (JNICALL *CallBooleanMethod)\t   (JNIEnv *, jobject, jmethodID,\n                                             ...);\n   jboolean (JNICALL *CallBooleanMethodV)   (JNIEnv *, jobject, jmethodID,\n-                                            _Jv_va_list);\n+                                            va_list);\n   jboolean (JNICALL *CallBooleanMethodA)   (JNIEnv *, jobject, jmethodID,\n                                             jvalue *);\n   jbyte (JNICALL *CallByteMethod)   (JNIEnv *, jobject, jmethodID, ...);\n   jbyte (JNICALL *CallByteMethodV)\t   (JNIEnv *, jobject, jmethodID,\n-                                            _Jv_va_list);\n+                                            va_list);\n   jbyte (JNICALL *CallByteMethodA)\t   (JNIEnv *, jobject, jmethodID,\n                                             jvalue *);\n   jchar (JNICALL *CallCharMethod)\t   (JNIEnv *, jobject, jmethodID, ...);\n   jchar (JNICALL *CallCharMethodV)\t   (JNIEnv *, jobject, jmethodID,\n-                                            _Jv_va_list);\n+                                            va_list);\n   jchar (JNICALL *CallCharMethodA)\t   (JNIEnv *, jobject, jmethodID,\n                                             jvalue *);\n   jshort (JNICALL *CallShortMethod)\t   (JNIEnv *, jobject, jmethodID, ...);\n   jshort (JNICALL *CallShortMethodV)\t   (JNIEnv *, jobject, jmethodID,\n-                                            _Jv_va_list);\n+                                            va_list);\n   jshort (JNICALL *CallShortMethodA)\t   (JNIEnv *, jobject, jmethodID,\n                                             jvalue *);\n   jint \t(JNICALL *CallIntMethod)\t   (JNIEnv *, jobject, jmethodID, ...);\n   jint \t(JNICALL *CallIntMethodV)\t   (JNIEnv *, jobject, jmethodID,\n-                                            _Jv_va_list);\n+                                            va_list);\n   jint \t(JNICALL *CallIntMethodA)\t   (JNIEnv *, jobject, jmethodID,\n                                             jvalue *);\n   jlong (JNICALL *CallLongMethod)\t   (JNIEnv *, jobject, jmethodID, ...);\n   jlong (JNICALL *CallLongMethodV)\t   (JNIEnv *, jobject, jmethodID,\n-                                            _Jv_va_list);\n+                                            va_list);\n   jlong (JNICALL *CallLongMethodA)\t   (JNIEnv *, jobject, jmethodID,\n                                             jvalue *);\n   jfloat (JNICALL *CallFloatMethod)\t   (JNIEnv *, jobject, jmethodID, ...);\n   jfloat (JNICALL *CallFloatMethodV)\t   (JNIEnv *, jobject, jmethodID,\n-                                            _Jv_va_list);\n+                                            va_list);\n   jfloat (JNICALL *CallFloatMethodA)\t   (JNIEnv *, jobject, jmethodID,\n                                             jvalue *);\n   jdouble (JNICALL *CallDoubleMethod)\t   (JNIEnv *, jobject, jmethodID, ...);\n   jdouble (JNICALL *CallDoubleMethodV)\t   (JNIEnv *, jobject, jmethodID,\n-                                            _Jv_va_list);\n+                                            va_list);\n   jdouble (JNICALL *CallDoubleMethodA)\t   (JNIEnv *, jobject, jmethodID,\n                                             jvalue *);\n   void  (JNICALL *CallVoidMethod)\t   (JNIEnv *, jobject, jmethodID, ...);\n   void  (JNICALL *CallVoidMethodV)\t   (JNIEnv *, jobject, jmethodID,\n-                                            _Jv_va_list);\n+                                            va_list);\n   void  (JNICALL *CallVoidMethodA)\t   (JNIEnv *, jobject, jmethodID,\n                                             jvalue *);\n \n   jobject   (JNICALL *CallNonvirtualObjectMethod)  (JNIEnv *, jobject, jclass,\n                                                     jmethodID, ...);\n   jobject   (JNICALL *CallNonvirtualObjectMethodV) (JNIEnv *, jobject, jclass,\n-\t\t\t\t\t            jmethodID, _Jv_va_list);\n+\t\t\t\t\t            jmethodID, va_list);\n   jobject   (JNICALL *CallNonvirtualObjectMethodA) (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, jvalue *);\n   jboolean  (JNICALL *CallNonvirtualBooleanMethod) (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, ...);\n   jboolean  (JNICALL *CallNonvirtualBooleanMethodV) (JNIEnv *, jobject, jclass,\n-\t\t\t\t\t             jmethodID, _Jv_va_list);\n+\t\t\t\t\t             jmethodID, va_list);\n   jboolean  (JNICALL *CallNonvirtualBooleanMethodA) (JNIEnv *, jobject, jclass,\n \t\t\t\t\t             jmethodID, jvalue *);\n   jbyte     (JNICALL *CallNonvirtualByteMethod)\t   (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, ...);\n   jbyte     (JNICALL *CallNonvirtualByteMethodV)   (JNIEnv *, jobject, jclass,\n-\t\t\t\t\t            jmethodID, _Jv_va_list);\n+\t\t\t\t\t            jmethodID, va_list);\n   jbyte     (JNICALL *CallNonvirtualByteMethodA)   (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, jvalue *);\n   jchar     (JNICALL *CallNonvirtualCharMethod)\t   (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, ...);\n   jchar     (JNICALL *CallNonvirtualCharMethodV)   (JNIEnv *, jobject, jclass,\n-\t\t\t\t\t            jmethodID, _Jv_va_list);\n+\t\t\t\t\t            jmethodID, va_list);\n   jchar     (JNICALL *CallNonvirtualCharMethodA)   (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, jvalue *);\n   jshort    (JNICALL *CallNonvirtualShortMethod)   (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, ...);\n   jshort    (JNICALL *CallNonvirtualShortMethodV)  (JNIEnv *, jobject, jclass,\n-\t\t\t\t\t            jmethodID, _Jv_va_list);\n+\t\t\t\t\t            jmethodID, va_list);\n   jshort    (JNICALL *CallNonvirtualShortMethodA)  (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, jvalue *);\n   jint \t    (JNICALL *CallNonvirtualIntMethod)\t   (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, ...);\n   jint \t    (JNICALL *CallNonvirtualIntMethodV)\t   (JNIEnv *, jobject, jclass,\n-\t\t\t\t\t            jmethodID, _Jv_va_list);\n+\t\t\t\t\t            jmethodID, va_list);\n   jint \t    (JNICALL *CallNonvirtualIntMethodA)\t   (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, jvalue *);\n   jlong     (JNICALL *CallNonvirtualLongMethod)\t   (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, ...);\n   jlong     (JNICALL *CallNonvirtualLongMethodV)   (JNIEnv *, jobject, jclass,\n-\t\t\t\t\t            jmethodID, _Jv_va_list);\n+\t\t\t\t\t            jmethodID, va_list);\n   jlong     (JNICALL *CallNonvirtualLongMethodA)   (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, jvalue *);\n   jfloat    (JNICALL *CallNonvirtualFloatMethod)   (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, ...);\n   jfloat    (JNICALL *CallNonvirtualFloatMethodV)  (JNIEnv *, jobject, jclass,\n-\t\t\t\t\t            jmethodID, _Jv_va_list);\n+\t\t\t\t\t            jmethodID, va_list);\n   jfloat    (JNICALL *CallNonvirtualFloatMethodA)  (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, jvalue *);\n   jdouble   (JNICALL *CallNonvirtualDoubleMethod)  (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, ...);\n   jdouble   (JNICALL *CallNonvirtualDoubleMethodV) (JNIEnv *, jobject, jclass,\n-\t\t\t\t\t            jmethodID, _Jv_va_list);\n+\t\t\t\t\t            jmethodID, va_list);\n   jdouble   (JNICALL *CallNonvirtualDoubleMethodA) (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, jvalue *);\n   void      (JNICALL *CallNonvirtualVoidMethod)\t   (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, ...);\n   void      (JNICALL *CallNonvirtualVoidMethodV)   (JNIEnv *, jobject, jclass,\n-\t\t\t\t\t            jmethodID, _Jv_va_list);\n+\t\t\t\t\t            jmethodID, va_list);\n   void      (JNICALL *CallNonvirtualVoidMethodA)   (JNIEnv *, jobject, jclass,\n \t\t\t\t\t            jmethodID, jvalue *);\n \n@@ -458,61 +414,61 @@ struct JNINativeInterface\n   jobject  (JNICALL *CallStaticObjectMethod)  (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       ...);\n   jobject  (JNICALL *CallStaticObjectMethodV) (JNIEnv *, jclass, jmethodID,\n-\t\t\t\t\t       _Jv_va_list);\n+\t\t\t\t\t       va_list);\n   jobject  (JNICALL *CallStaticObjectMethodA) (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       jvalue *);\n   jboolean (JNICALL *CallStaticBooleanMethod) (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       ...);\n   jboolean (JNICALL *CallStaticBooleanMethodV) (JNIEnv *, jclass, jmethodID,\n-\t\t\t\t\t        _Jv_va_list);\n+\t\t\t\t\t        va_list);\n   jboolean (JNICALL *CallStaticBooleanMethodA) (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t        jvalue *);\n   jbyte\t   (JNICALL *CallStaticByteMethod)    (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       ...);\n   jbyte    (JNICALL *CallStaticByteMethodV)   (JNIEnv *, jclass, jmethodID,\n-\t\t\t\t\t       _Jv_va_list);\n+\t\t\t\t\t       va_list);\n   jbyte    (JNICALL *CallStaticByteMethodA)   (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       jvalue *);\n   jchar    (JNICALL *CallStaticCharMethod)    (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       ...);\n   jchar    (JNICALL *CallStaticCharMethodV)   (JNIEnv *, jclass, jmethodID,\n-\t\t\t\t\t       _Jv_va_list);\n+\t\t\t\t\t       va_list);\n   jchar    (JNICALL *CallStaticCharMethodA)   (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       jvalue *);\n   jshort   (JNICALL *CallStaticShortMethod)   (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       ...);\n   jshort   (JNICALL *CallStaticShortMethodV)  (JNIEnv *, jclass, jmethodID,\n-\t\t\t\t\t       _Jv_va_list);\n+\t\t\t\t\t       va_list);\n   jshort   (JNICALL *CallStaticShortMethodA)  (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       jvalue *);\n   jint \t   (JNICALL *CallStaticIntMethod)     (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       ...);\n   jint \t   (JNICALL *CallStaticIntMethodV)    (JNIEnv *, jclass, jmethodID,\n-\t\t\t\t\t       _Jv_va_list);\n+\t\t\t\t\t       va_list);\n   jint \t   (JNICALL *CallStaticIntMethodA)    (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       jvalue *);\n   jlong    (JNICALL *CallStaticLongMethod)    (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       ...);\n   jlong    (JNICALL *CallStaticLongMethodV)   (JNIEnv *, jclass, jmethodID,\n-\t\t\t\t\t       _Jv_va_list);\n+\t\t\t\t\t       va_list);\n   jlong    (JNICALL *CallStaticLongMethodA)   (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       jvalue *);\n   jfloat   (JNICALL *CallStaticFloatMethod)   (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       ...);\n   jfloat   (JNICALL *CallStaticFloatMethodV)  (JNIEnv *, jclass, jmethodID,\n-\t\t\t\t\t       _Jv_va_list);\n+\t\t\t\t\t       va_list);\n   jfloat   (JNICALL *CallStaticFloatMethodA)  (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       jvalue *);\n   jdouble  (JNICALL *CallStaticDoubleMethod)  (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       ...);\n   jdouble  (JNICALL *CallStaticDoubleMethodV) (JNIEnv *, jclass, jmethodID,\n-\t\t\t\t\t       _Jv_va_list);\n+\t\t\t\t\t       va_list);\n   jdouble  (JNICALL *CallStaticDoubleMethodA) (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       jvalue *);\n   void     (JNICALL *CallStaticVoidMethod)    (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       ...);\n   void     (JNICALL *CallStaticVoidMethodV)   (JNIEnv *, jclass, jmethodID,\n-\t\t\t\t\t       _Jv_va_list);\n+\t\t\t\t\t       va_list);\n   void     (JNICALL *CallStaticVoidMethodA)   (JNIEnv *, jclass, jmethodID,\n \t\t\t\t\t       jvalue *);\n \n@@ -647,6 +603,7 @@ struct JNINativeInterface\n   jint     (JNICALL *MonitorExit)                  (JNIEnv *, jobject);\n   jint     (JNICALL *GetJavaVM)                    (JNIEnv *, JavaVM **);\n \n+  /* ---- JNI 1.2 functions ---- */\n   void\t   (JNICALL *GetStringRegion)\t           (JNIEnv *, jstring, jsize,\n \t\t\t\t\t            jsize, jchar *);\n   void     (JNICALL *GetStringUTFRegion)\t   (JNIEnv *, jstring, jsize,\n@@ -667,6 +624,7 @@ struct JNINativeInterface\n \n   jboolean\t(JNICALL *ExceptionCheck)\t   (JNIEnv *);\n \n+  /* ---- JNI 1.4 functions ---- */\n   jobject (JNICALL *NewDirectByteBuffer)           (JNIEnv *, void *, jlong);\n   void *  (JNICALL *GetDirectBufferAddress)        (JNIEnv *, jobject);\n   jlong   (JNICALL *GetDirectBufferCapacity)       (JNIEnv *, jobject);\n@@ -680,24 +638,10 @@ class _Jv_JNIEnv\n   /* The method table.  */\n   struct JNINativeInterface *p;\n \n-  /* This is ugly, but we must live with it.  */\n-#ifndef __GCJ_JNI_IMPL__\n-private:\n+#ifdef _CLASSPATH_JNIENV_CONTENTS\n+  _CLASSPATH_JNIENV_CONTENTS\n #endif\n-  /* The current exception.  */\n-  jthrowable ex;\n \n-  /* The class of the current native method.  */\n-  jclass klass;\n-\n-  /* The chain of local frames.  */\n-  struct _Jv_JNI_LocalFrame *locals;\n-\n-  /* The bottom-most element of the chain, initialized with the env and\n-     reused between non-nesting JNI calls.  */\n-  struct _Jv_JNI_LocalFrame *bottom_locals;\n-\n-public:\n   jint GetVersion ()\n   { return p->GetVersion (this); }\n \n@@ -773,14 +717,14 @@ class _Jv_JNIEnv\n \n   jobject NewObject (jclass cl0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jobject result = p->NewObjectV (this, cl0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jobject NewObjectV (jclass cl0, jmethodID meth1, _Jv_va_list val2)\n+  jobject NewObjectV (jclass cl0, jmethodID meth1, va_list val2)\n   { return p->NewObjectV (this, cl0, meth1, val2); }\n \n   jobject NewObjectA (jclass cl0, jmethodID meth1, jvalue * val2)\n@@ -797,297 +741,297 @@ class _Jv_JNIEnv\n \n   jobject CallObjectMethod (jobject obj0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jobject result = p->CallObjectMethodV (this, obj0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jobject CallObjectMethodV (jobject obj0, jmethodID meth1, _Jv_va_list val2)\n+  jobject CallObjectMethodV (jobject obj0, jmethodID meth1, va_list val2)\n   { return p->CallObjectMethodV (this, obj0, meth1, val2); }\n \n   jobject CallObjectMethodA (jobject obj0, jmethodID meth1, jvalue * val2)\n   { return p->CallObjectMethodA (this, obj0, meth1, val2); }\n \n   jboolean CallBooleanMethod (jobject obj0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jboolean result = p->CallBooleanMethodV (this, obj0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jboolean CallBooleanMethodV (jobject obj0, jmethodID meth1, _Jv_va_list val2)\n+  jboolean CallBooleanMethodV (jobject obj0, jmethodID meth1, va_list val2)\n   { return p->CallBooleanMethodV (this, obj0, meth1, val2); }\n \n   jboolean CallBooleanMethodA (jobject obj0, jmethodID meth1, jvalue * val2)\n   { return p->CallBooleanMethodA (this, obj0, meth1, val2); }\n \n   jbyte CallByteMethod (jobject obj0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jbyte result = p->CallByteMethodV (this, obj0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jbyte CallByteMethodV (jobject obj0, jmethodID meth1, _Jv_va_list val2)\n+  jbyte CallByteMethodV (jobject obj0, jmethodID meth1, va_list val2)\n   { return p->CallByteMethodV (this, obj0, meth1, val2); }\n \n   jbyte CallByteMethodA (jobject obj0, jmethodID meth1, jvalue * val2)\n   { return p->CallByteMethodA (this, obj0, meth1, val2); }\n \n   jchar CallCharMethod (jobject obj0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jchar result = p->CallCharMethodV (this, obj0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jchar CallCharMethodV (jobject obj0, jmethodID meth1, _Jv_va_list val2)\n+  jchar CallCharMethodV (jobject obj0, jmethodID meth1, va_list val2)\n   { return p->CallCharMethodV (this, obj0, meth1, val2); }\n \n   jchar CallCharMethodA (jobject obj0, jmethodID meth1, jvalue * val2)\n   { return p->CallCharMethodA (this, obj0, meth1, val2); }\n \n   jshort CallShortMethod (jobject obj0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jshort result = p->CallShortMethodV (this, obj0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jshort CallShortMethodV (jobject obj0, jmethodID meth1, _Jv_va_list val2)\n+  jshort CallShortMethodV (jobject obj0, jmethodID meth1, va_list val2)\n   { return p->CallShortMethodV (this, obj0, meth1, val2); }\n \n   jshort CallShortMethodA (jobject obj0, jmethodID meth1, jvalue * val2)\n   { return p->CallShortMethodA (this, obj0, meth1, val2); }\n \n   jint CallIntMethod (jobject obj0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jint result = p->CallIntMethodV (this, obj0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jint CallIntMethodV (jobject obj0, jmethodID meth1, _Jv_va_list val2)\n+  jint CallIntMethodV (jobject obj0, jmethodID meth1, va_list val2)\n   { return p->CallIntMethodV (this, obj0, meth1, val2); }\n \n   jint CallIntMethodA (jobject obj0, jmethodID meth1, jvalue * val2)\n   { return p->CallIntMethodA (this, obj0, meth1, val2); }\n \n   jlong CallLongMethod (jobject obj0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jlong result = p->CallLongMethodV (this, obj0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jlong CallLongMethodV (jobject obj0, jmethodID meth1, _Jv_va_list val2)\n+  jlong CallLongMethodV (jobject obj0, jmethodID meth1, va_list val2)\n   { return p->CallLongMethodV (this, obj0, meth1, val2); }\n \n   jlong CallLongMethodA (jobject obj0, jmethodID meth1, jvalue * val2)\n   { return p->CallLongMethodA (this, obj0, meth1, val2); }\n \n   jfloat CallFloatMethod (jobject obj0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jfloat result = p->CallFloatMethodV (this, obj0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jfloat CallFloatMethodV (jobject obj0, jmethodID meth1, _Jv_va_list val2)\n+  jfloat CallFloatMethodV (jobject obj0, jmethodID meth1, va_list val2)\n   { return p->CallFloatMethodV (this, obj0, meth1, val2); }\n \n   jfloat CallFloatMethodA (jobject obj0, jmethodID meth1, jvalue * val2)\n   { return p->CallFloatMethodA (this, obj0, meth1, val2); }\n \n   jdouble CallDoubleMethod (jobject obj0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jdouble result = p->CallDoubleMethodV (this, obj0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jdouble CallDoubleMethodV (jobject obj0, jmethodID meth1, _Jv_va_list val2)\n+  jdouble CallDoubleMethodV (jobject obj0, jmethodID meth1, va_list val2)\n   { return p->CallDoubleMethodV (this, obj0, meth1, val2); }\n \n   jdouble CallDoubleMethodA (jobject obj0, jmethodID meth1, jvalue * val2)\n   { return p->CallDoubleMethodA (this, obj0, meth1, val2); }\n \n   void CallVoidMethod (jobject obj0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     p->CallVoidMethodV (this, obj0, meth1, args);\n     va_end (args);\n   }\n \n-  void CallVoidMethodV (jobject obj0, jmethodID meth1, _Jv_va_list val2)\n+  void CallVoidMethodV (jobject obj0, jmethodID meth1, va_list val2)\n   { p->CallVoidMethodV (this, obj0, meth1, val2); }\n \n   void CallVoidMethodA (jobject obj0, jmethodID meth1, jvalue * val2)\n   { p->CallVoidMethodA (this, obj0, meth1, val2); }\n \n   jobject CallNonvirtualObjectMethod (jobject obj0, jclass cl1, jmethodID meth2, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth2);\n     jobject result = p->CallNonvirtualObjectMethodV (this, obj0, cl1, meth2, args);\n     va_end (args);\n     return result;\n   }\n \n-  jobject CallNonvirtualObjectMethodV (jobject obj0, jclass cl1, jmethodID meth2, _Jv_va_list val3)\n+  jobject CallNonvirtualObjectMethodV (jobject obj0, jclass cl1, jmethodID meth2, va_list val3)\n   { return p->CallNonvirtualObjectMethodV (this, obj0, cl1, meth2, val3); }\n \n   jobject CallNonvirtualObjectMethodA (jobject obj0, jclass cl1, jmethodID meth2, jvalue * val3)\n   { return p->CallNonvirtualObjectMethodA (this, obj0, cl1, meth2, val3); }\n \n   jboolean CallNonvirtualBooleanMethod (jobject obj0, jclass cl1, jmethodID meth2, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth2);\n     jboolean result = p->CallNonvirtualBooleanMethodV (this, obj0, cl1, meth2, args);\n     va_end (args);\n     return result;\n   }\n \n-  jboolean CallNonvirtualBooleanMethodV (jobject obj0, jclass cl1, jmethodID meth2, _Jv_va_list val3)\n+  jboolean CallNonvirtualBooleanMethodV (jobject obj0, jclass cl1, jmethodID meth2, va_list val3)\n   { return p->CallNonvirtualBooleanMethodV (this, obj0, cl1, meth2, val3); }\n \n   jboolean CallNonvirtualBooleanMethodA (jobject obj0, jclass cl1, jmethodID meth2, jvalue * val3)\n   { return p->CallNonvirtualBooleanMethodA (this, obj0, cl1, meth2, val3); }\n \n   jbyte CallNonvirtualByteMethod (jobject obj0, jclass cl1, jmethodID meth2, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth2);\n     jbyte result = p->CallNonvirtualByteMethodV (this, obj0, cl1, meth2, args);\n     va_end (args);\n     return result;\n   }\n \n-  jbyte CallNonvirtualByteMethodV (jobject obj0, jclass cl1, jmethodID meth2, _Jv_va_list val3)\n+  jbyte CallNonvirtualByteMethodV (jobject obj0, jclass cl1, jmethodID meth2, va_list val3)\n   { return p->CallNonvirtualByteMethodV (this, obj0, cl1, meth2, val3); }\n \n   jbyte CallNonvirtualByteMethodA (jobject obj0, jclass cl1, jmethodID meth2, jvalue * val3)\n   { return p->CallNonvirtualByteMethodA (this, obj0, cl1, meth2, val3); }\n \n   jchar CallNonvirtualCharMethod (jobject obj0, jclass cl1, jmethodID meth2, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth2);\n     jchar result = p->CallNonvirtualCharMethodV (this, obj0, cl1, meth2, args);\n     va_end (args);\n     return result;\n   }\n \n-  jchar CallNonvirtualCharMethodV (jobject obj0, jclass cl1, jmethodID meth2, _Jv_va_list val3)\n+  jchar CallNonvirtualCharMethodV (jobject obj0, jclass cl1, jmethodID meth2, va_list val3)\n   { return p->CallNonvirtualCharMethodV (this, obj0, cl1, meth2, val3); }\n \n   jchar CallNonvirtualCharMethodA (jobject obj0, jclass cl1, jmethodID meth2, jvalue * val3)\n   { return p->CallNonvirtualCharMethodA (this, obj0, cl1, meth2, val3); }\n \n   jshort CallNonvirtualShortMethod (jobject obj0, jclass cl1, jmethodID meth2, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth2);\n     jshort result = p->CallNonvirtualShortMethodV (this, obj0, cl1, meth2, args);\n     va_end (args);\n     return result;\n   }\n \n-  jshort CallNonvirtualShortMethodV (jobject obj0, jclass cl1, jmethodID meth2, _Jv_va_list val3)\n+  jshort CallNonvirtualShortMethodV (jobject obj0, jclass cl1, jmethodID meth2, va_list val3)\n   { return p->CallNonvirtualShortMethodV (this, obj0, cl1, meth2, val3); }\n \n   jshort CallNonvirtualShortMethodA (jobject obj0, jclass cl1, jmethodID meth2, jvalue * val3)\n   { return p->CallNonvirtualShortMethodA (this, obj0, cl1, meth2, val3); }\n \n   jint CallNonvirtualIntMethod (jobject obj0, jclass cl1, jmethodID meth2, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth2);\n     jint result = p->CallNonvirtualIntMethodV (this, obj0, cl1, meth2, args);\n     va_end (args);\n     return result;\n   }\n \n-  jint CallNonvirtualIntMethodV (jobject obj0, jclass cl1, jmethodID meth2, _Jv_va_list val3)\n+  jint CallNonvirtualIntMethodV (jobject obj0, jclass cl1, jmethodID meth2, va_list val3)\n   { return p->CallNonvirtualIntMethodV (this, obj0, cl1, meth2, val3); }\n \n   jint CallNonvirtualIntMethodA (jobject obj0, jclass cl1, jmethodID meth2, jvalue * val3)\n   { return p->CallNonvirtualIntMethodA (this, obj0, cl1, meth2, val3); }\n \n   jlong CallNonvirtualLongMethod (jobject obj0, jclass cl1, jmethodID meth2, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth2);\n     jlong result = p->CallNonvirtualLongMethodV (this, obj0, cl1, meth2, args);\n     va_end (args);\n     return result;\n   }\n \n-  jlong CallNonvirtualLongMethodV (jobject obj0, jclass cl1, jmethodID meth2, _Jv_va_list val3)\n+  jlong CallNonvirtualLongMethodV (jobject obj0, jclass cl1, jmethodID meth2, va_list val3)\n   { return p->CallNonvirtualLongMethodV (this, obj0, cl1, meth2, val3); }\n \n   jlong CallNonvirtualLongMethodA (jobject obj0, jclass cl1, jmethodID meth2, jvalue * val3)\n   { return p->CallNonvirtualLongMethodA (this, obj0, cl1, meth2, val3); }\n \n   jfloat CallNonvirtualFloatMethod (jobject obj0, jclass cl1, jmethodID meth2, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth2);\n     jfloat result = p->CallNonvirtualFloatMethodV (this, obj0, cl1, meth2, args);\n     va_end (args);\n     return result;\n   }\n \n-  jfloat CallNonvirtualFloatMethodV (jobject obj0, jclass cl1, jmethodID meth2, _Jv_va_list val3)\n+  jfloat CallNonvirtualFloatMethodV (jobject obj0, jclass cl1, jmethodID meth2, va_list val3)\n   { return p->CallNonvirtualFloatMethodV (this, obj0, cl1, meth2, val3); }\n \n   jfloat CallNonvirtualFloatMethodA (jobject obj0, jclass cl1, jmethodID meth2, jvalue * val3)\n   { return p->CallNonvirtualFloatMethodA (this, obj0, cl1, meth2, val3); }\n \n   jdouble CallNonvirtualDoubleMethod (jobject obj0, jclass cl1, jmethodID meth2, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth2);\n     jdouble result = p->CallNonvirtualDoubleMethodV (this, obj0, cl1, meth2, args);\n     va_end (args);\n     return result;\n   }\n \n-  jdouble CallNonvirtualDoubleMethodV (jobject obj0, jclass cl1, jmethodID meth2, _Jv_va_list val3)\n+  jdouble CallNonvirtualDoubleMethodV (jobject obj0, jclass cl1, jmethodID meth2, va_list val3)\n   { return p->CallNonvirtualDoubleMethodV (this, obj0, cl1, meth2, val3); }\n \n   jdouble CallNonvirtualDoubleMethodA (jobject obj0, jclass cl1, jmethodID meth2, jvalue * val3)\n   { return p->CallNonvirtualDoubleMethodA (this, obj0, cl1, meth2, val3); }\n \n   void CallNonvirtualVoidMethod (jobject obj0, jclass cl1, jmethodID meth2, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth2);\n     p->CallNonvirtualVoidMethodV (this, obj0, cl1, meth2, args);\n     va_end (args);\n   }\n \n-  void CallNonvirtualVoidMethodV (jobject obj0, jclass cl1, jmethodID meth2, _Jv_va_list val3)\n+  void CallNonvirtualVoidMethodV (jobject obj0, jclass cl1, jmethodID meth2, va_list val3)\n   { p->CallNonvirtualVoidMethodV (this, obj0, cl1, meth2, val3); }\n \n   void CallNonvirtualVoidMethodA (jobject obj0, jclass cl1, jmethodID meth2, jvalue * val3)\n@@ -1155,148 +1099,148 @@ class _Jv_JNIEnv\n \n   jobject CallStaticObjectMethod (jclass cl0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jobject result = p->CallStaticObjectMethodV (this, cl0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jobject CallStaticObjectMethodV (jclass cl0, jmethodID meth1, _Jv_va_list val2)\n+  jobject CallStaticObjectMethodV (jclass cl0, jmethodID meth1, va_list val2)\n   { return p->CallStaticObjectMethodV (this, cl0, meth1, val2); }\n \n   jobject CallStaticObjectMethodA (jclass cl0, jmethodID meth1, jvalue * val2)\n   { return p->CallStaticObjectMethodA (this, cl0, meth1, val2); }\n \n   jboolean CallStaticBooleanMethod (jclass cl0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jboolean result = p->CallStaticBooleanMethodV (this, cl0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jboolean CallStaticBooleanMethodV (jclass cl0, jmethodID meth1, _Jv_va_list val2)\n+  jboolean CallStaticBooleanMethodV (jclass cl0, jmethodID meth1, va_list val2)\n   { return p->CallStaticBooleanMethodV (this, cl0, meth1, val2); }\n \n   jboolean CallStaticBooleanMethodA (jclass cl0, jmethodID meth1, jvalue * val2)\n   { return p->CallStaticBooleanMethodA (this, cl0, meth1, val2); }\n \n   jbyte CallStaticByteMethod (jclass cl0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jbyte result = p->CallStaticByteMethodV (this, cl0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jbyte CallStaticByteMethodV (jclass cl0, jmethodID meth1, _Jv_va_list val2)\n+  jbyte CallStaticByteMethodV (jclass cl0, jmethodID meth1, va_list val2)\n   { return p->CallStaticByteMethodV (this, cl0, meth1, val2); }\n \n   jbyte CallStaticByteMethodA (jclass cl0, jmethodID meth1, jvalue * val2)\n   { return p->CallStaticByteMethodA (this, cl0, meth1, val2); }\n \n   jchar CallStaticCharMethod (jclass cl0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jchar result = p->CallStaticCharMethodV (this, cl0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jchar CallStaticCharMethodV (jclass cl0, jmethodID meth1, _Jv_va_list val2)\n+  jchar CallStaticCharMethodV (jclass cl0, jmethodID meth1, va_list val2)\n   { return p->CallStaticCharMethodV (this, cl0, meth1, val2); }\n \n   jchar CallStaticCharMethodA (jclass cl0, jmethodID meth1, jvalue * val2)\n   { return p->CallStaticCharMethodA (this, cl0, meth1, val2); }\n \n   jshort CallStaticShortMethod (jclass cl0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jshort result = p->CallStaticShortMethodV (this, cl0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jshort CallStaticShortMethodV (jclass cl0, jmethodID meth1, _Jv_va_list val2)\n+  jshort CallStaticShortMethodV (jclass cl0, jmethodID meth1, va_list val2)\n   { return p->CallStaticShortMethodV (this, cl0, meth1, val2); }\n \n   jshort CallStaticShortMethodA (jclass cl0, jmethodID meth1, jvalue * val2)\n   { return p->CallStaticShortMethodA (this, cl0, meth1, val2); }\n \n   jint CallStaticIntMethod (jclass cl0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jint result = p->CallStaticIntMethodV (this, cl0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jint CallStaticIntMethodV (jclass cl0, jmethodID meth1, _Jv_va_list val2)\n+  jint CallStaticIntMethodV (jclass cl0, jmethodID meth1, va_list val2)\n   { return p->CallStaticIntMethodV (this, cl0, meth1, val2); }\n \n   jint CallStaticIntMethodA (jclass cl0, jmethodID meth1, jvalue * val2)\n   { return p->CallStaticIntMethodA (this, cl0, meth1, val2); }\n \n   jlong CallStaticLongMethod (jclass cl0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jlong result = p->CallStaticLongMethodV (this, cl0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jlong CallStaticLongMethodV (jclass cl0, jmethodID meth1, _Jv_va_list val2)\n+  jlong CallStaticLongMethodV (jclass cl0, jmethodID meth1, va_list val2)\n   { return p->CallStaticLongMethodV (this, cl0, meth1, val2); }\n \n   jlong CallStaticLongMethodA (jclass cl0, jmethodID meth1, jvalue * val2)\n   { return p->CallStaticLongMethodA (this, cl0, meth1, val2); }\n \n   jfloat CallStaticFloatMethod (jclass cl0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jfloat result = p->CallStaticFloatMethodV (this, cl0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jfloat CallStaticFloatMethodV (jclass cl0, jmethodID meth1, _Jv_va_list val2)\n+  jfloat CallStaticFloatMethodV (jclass cl0, jmethodID meth1, va_list val2)\n   { return p->CallStaticFloatMethodV (this, cl0, meth1, val2); }\n \n   jfloat CallStaticFloatMethodA (jclass cl0, jmethodID meth1, jvalue * val2)\n   { return p->CallStaticFloatMethodA (this, cl0, meth1, val2); }\n \n   jdouble CallStaticDoubleMethod (jclass cl0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     jdouble result = p->CallStaticDoubleMethodV (this, cl0, meth1, args);\n     va_end (args);\n     return result;\n   }\n \n-  jdouble CallStaticDoubleMethodV (jclass cl0, jmethodID meth1, _Jv_va_list val2)\n+  jdouble CallStaticDoubleMethodV (jclass cl0, jmethodID meth1, va_list val2)\n   { return p->CallStaticDoubleMethodV (this, cl0, meth1, val2); }\n \n   jdouble CallStaticDoubleMethodA (jclass cl0, jmethodID meth1, jvalue * val2)\n   { return p->CallStaticDoubleMethodA (this, cl0, meth1, val2); }\n \n   void CallStaticVoidMethod (jclass cl0, jmethodID meth1, ...)\n   {\n-    _Jv_va_list args;\n+    va_list args;\n     va_start (args, meth1);\n     p->CallStaticVoidMethodV (this, cl0, meth1, args);\n     va_end (args);\n   }\n \n-  void CallStaticVoidMethodV (jclass cl0, jmethodID meth1, _Jv_va_list val2)\n+  void CallStaticVoidMethodV (jclass cl0, jmethodID meth1, va_list val2)\n   { p->CallStaticVoidMethodV (this, cl0, meth1, val2); }\n \n   void CallStaticVoidMethodA (jclass cl0, jmethodID meth1, jvalue * val2)\n@@ -1566,6 +1510,7 @@ class _Jv_JNIEnv\n   jlong GetDirectBufferCapacity (jobject buf)\n   { return p->GetDirectBufferCapacity (this, buf); }\n };\n+\n #endif /* __cplusplus */\n \n /*\n@@ -1592,10 +1537,6 @@ class _Jv_JavaVM\n public:\n   const struct JNIInvokeInterface *functions;\n \n-private:\n-  /* FIXME: other fields.  */\n-\n-public:\n   jint DestroyJavaVM ()\n   { return functions->DestroyJavaVM (this); }\n \n@@ -1611,6 +1552,7 @@ class _Jv_JavaVM\n   jint AttachCurrentThreadAsDaemon (void **penv, void *args)\n   { return functions->AttachCurrentThreadAsDaemon (this, penv, args); }\n };\n+\n #endif /* __cplusplus */\n \n typedef struct JavaVMAttachArgs\n@@ -1642,4 +1584,16 @@ typedef struct JavaVMInitArgs\n   jboolean ignoreUnrecognized;\n } JavaVMInitArgs;\n \n-#endif /* __GCJ_JNI_H__ */\n+\n+\f\n+/* Keep c-font-lock-extra-types in alphabetical order. */\n+/* Local Variables: */\n+/* c-font-lock-extra-types: (\"\\\\sw+_t\" \n+   \"JNIEnv\" \"JNINativeMethod\" \"JavaVM\" \"JavaVMOption\" \"jarray\"\n+   \"jboolean\" \"jbooleanArray\" \"jbyte\" \"jbyteArray\" \"jchar\"  \"jcharArray\" \n+   \"jclass\" \"jdouble\" \"jdoubleArray\" \"jfieldID\" \"jfloat\" \"jfloatArray\"\n+   \"jint\" \"jintArray\" \"jlong\" \"jlongArray\" \"jmethodID\" \"jobject\" \"jstring\" \"jthrowable\" \n+   \"jvalue\" \"jweak\") */\n+/* End: */\n+\n+#endif /* _CLASSPATH_JNI_H */"}, {"sha": "7c04b955d6c8323d5e0ace96146f60c9049bdd43", "filename": "libjava/include/jni_md.h", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca5a6a939732c946f3ade566ae1dd4f3def37c3/libjava%2Finclude%2Fjni_md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca5a6a939732c946f3ade566ae1dd4f3def37c3/libjava%2Finclude%2Fjni_md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjni_md.h?ref=eca5a6a939732c946f3ade566ae1dd4f3def37c3", "patch": "@@ -0,0 +1,151 @@\n+/* jni_md.h\n+   Copyright (C) 2001, 2005 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+#ifndef __GCJ_JNI_MD_H__\n+#define __GCJ_JNI_MD_H__\n+\n+#include <gcj/libgcj-config.h>\n+\n+#ifdef __GCJ_JNI_IMPL__\n+\n+/* If __GCJ_JNI_IMPL__ is defined, then we assume that we're building\n+   libgcj itself, and we include headers which taint the namespace\n+   more than is acceptable for the ordinary JNI user.  */\n+#include <gcj/javaprims.h>\n+#include <gcj/array.h>\n+#include <gnu/gcj/runtime/JNIWeakRef.h>\n+\n+typedef gnu::gcj::runtime::JNIWeakRef *jweak;\n+\n+typedef struct _Jv_JNIEnv JNIEnv;\n+typedef struct _Jv_JavaVM JavaVM;\n+\n+#define JNI_TRUE true\n+#define JNI_FALSE false\n+\n+/* We defined jobject and friends, so don't redefine them in jni.h.  */\n+#define _CLASSPATH_VM_JNI_TYPES_DEFINED\n+\n+/* We defined jmethodID and and jfieldID, so don't redefine them in\n+   jni.h.  */\n+#define _CLASSPATH_VM_INTERNAL_TYPES_DEFINED\n+\n+/* Contents of the JNIEnv; but only inside the implementation.  */\n+#define _CLASSPATH_JNIENV_CONTENTS\t\t\t\t\t\\\n+  /* The current exception.  */\t\t\t\t\t\t\\\n+  jthrowable ex;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* The class of the current native method.  */\t\t\t\\\n+  jclass klass;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* The chain of local frames.  */\t\t\t\t\t\\\n+  struct _Jv_JNI_LocalFrame *locals;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* The bottom-most element of the chain, initialized with the env and\t\\\n+     reused between non-nesting JNI calls.  */\t\t\t\t\\\n+  struct _Jv_JNI_LocalFrame *bottom_locals;\n+\n+\n+#else /* __GCJ_JNI_IMPL__ */\n+\n+# ifdef __GNUC__\n+\n+/* If we're using gcc, we can use a platform-independent scheme to get\n+   the right integer types.  FIXME: this is not always correct, for\n+   instance on the c4x it will be wrong -- it depends on whether\n+   QImode is 8 bits.  */\n+typedef int    jbyte  __attribute__((__mode__(__QI__)));\n+typedef int    jshort __attribute__((__mode__(__HI__)));\n+typedef int    jint   __attribute__((__mode__(__SI__)));\n+typedef int    jlong  __attribute__((__mode__(__DI__)));\n+typedef int    jboolean __attribute__((__mode__(__QI__)));\n+typedef unsigned short jchar __attribute__((__mode__(__HI__)));\n+typedef float  jfloat;\n+typedef double jdouble;\n+typedef jint jsize;\n+\n+# else /* __GNUC__ */\n+\n+#  ifdef JV_HAVE_INTTYPES_H\n+\n+/* If <inttypes.h> is available, we use it.  */\n+\n+#   include <inttypes.h>\n+\n+typedef int8_t jbyte;\n+typedef int16_t jshort;\n+typedef int32_t jint;\n+typedef int64_t jlong;\n+typedef float jfloat;\n+typedef double jdouble;\n+typedef jint jsize;\n+typedef int8_t jboolean;\n+typedef uint16_t jchar;\n+\n+#  else /* JV_HAVE_INTTYPES_H */\n+\n+/* For now, we require either gcc or <inttypes.h>.  If we did more\n+   work at configure time we could get around this, but right now it\n+   doesn't seem worth it.  */\n+#   error jni.h not ported to this platform\n+\n+#  endif /* JV_HAVE_INTTYPES_H */\n+\n+# endif /* __GNUC__ */\n+\n+#endif /* __GCJ_JNI_IMPL__ */\n+\n+\n+/* Linkage and calling conventions. */\n+#if defined (_WIN32) || defined (__WIN32__) || defined (WIN32)\n+\n+#define JNIIMPORT        __declspec(dllimport)\n+#define JNIEXPORT        __declspec(dllexport)\n+\n+#define JNICALL          __stdcall\n+\n+/* These defines apply to symbols in libgcj */\n+#ifdef __GCJ_DLL__\n+# ifdef __GCJ_JNI_IMPL__\n+#  define _CLASSPATH_JNIIMPEXP JNIEXPORT\n+# else\n+#  define _CLASSPATH_JNIIMPEXP JNIIMPORT\n+# endif /* ! __GCJ_JNI_IMPL__ */\n+#else /* ! __GCJ_DLL__ */\n+# define _CLASSPATH_JNIIMPEXP\n+#endif /*  __GCJ_DLL__ */\n+\n+#else /* !( _WIN32 || __WIN32__ || WIN32) */\n+\n+#define JNIIMPORT\n+#define JNIEXPORT\n+#define JNICALL\n+#define _CLASSPATH_JNIIMPEXP\n+\n+#endif /* !( _WIN32 || __WIN32__ || WIN32) */\n+\n+\n+#endif /* __GCJ_JNI_MD_H__ */"}]}