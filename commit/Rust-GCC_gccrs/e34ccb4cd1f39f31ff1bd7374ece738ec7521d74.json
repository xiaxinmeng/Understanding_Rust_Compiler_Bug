{"sha": "e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM0Y2NiNGNkMWYzOWYzMWZmMWJkNzM3NGVjZTczOGVjNzUyMWQ3NA==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2009-04-24T15:20:23Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2009-04-24T15:20:23Z"}, "message": "gfortran.h (gfc_get_typebound_proc): Removed as macro, now a function.\n\n2009-04-24  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.h (gfc_get_typebound_proc): Removed as macro, now a function.\n\t(struct gfc_symtree): Moved `typebound' member inside union.\n\t(struct gfc_namespace): Add `tb_sym_root' as new symtree to sort out\n\ttype-bound procedures there.\n\t(gfc_get_tbp_symtree): New procedure.\n\t* symbol.c (tentative_tbp_list): New global.\n\t(gfc_get_namespace): NULL new `tb_sym_root' member.\n\t(gfc_new_symtree): Removed initialization of `typebound' member.\n\t(gfc_undo_symbols): Process list of tentative tbp's.\n\t(gfc_commit_symbols): Ditto.\n\t(free_tb_tree): New method.\n\t(gfc_free_namespace): Call it.\n\t(gfc_get_typebound_proc): New method.\n\t(gfc_get_tbp_symtree): New method.\n\t(gfc_find_typebound_proc): Adapt to structural changes of gfc_symtree\n\tand gfc_namespace with regards to tbp's.\n\t* dump-parse-tree.c (show_typebound): Ditto.\n\t* primary.c (gfc_match_varspec): Ditto.  Don't reference tbp-symbol\n\tas it isn't a symbol any longer.\n\t* module.c (mio_typebound_symtree): Adapt to changes.\n\t(mio_typebound_proc): Ditto, create symtrees using `gfc_get_tbp_symtree'\n\trather than `gfc_get_sym_tree'.\n\t(mio_f2k_derived): Ditto.\n\t* decl.c (match_procedure_in_type): Ditto.\n\t(gfc_match_generic): Ditto.  Don't reference tbp-symbol.\n\t* resolve.c (check_typebound_override): Adapt to changes.\n\t(resolve_typebound_generic): Ditto.\n\t(resolve_typebound_procedures): Ditto.\n\t(ensure_not_abstract_walker): Ditto.\n\t(ensure_not_abstract): Ditto.\n\t(resolve_typebound_procedure): Ditto, ignore erraneous symbols (for\n\tinstance, through removed tentative ones).\n\t* gfc-internals.texi (Type-bound procedures): Document changes.\n\n2009-04-24  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.dg/typebound_generic_1.f03: Change so that no error is\n\texpected on already erraneous symbol (renamed to fresh one).\n\nFrom-SVN: r146733", "tree": {"sha": "6857c66e3f14011e7afd4f510d84a7d7ded9cc88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6857c66e3f14011e7afd4f510d84a7d7ded9cc88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b178461a93752916e0ff817e7db879aa638ab956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b178461a93752916e0ff817e7db879aa638ab956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b178461a93752916e0ff817e7db879aa638ab956"}], "stats": {"total": 382, "additions": 262, "deletions": 120}, "files": [{"sha": "769f3c41267e2c70e723a5be5461ddaa386283cc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "patch": "@@ -1,3 +1,39 @@\n+2009-04-24  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.h (gfc_get_typebound_proc): Removed as macro, now a function.\n+\t(struct gfc_symtree): Moved `typebound' member inside union.\n+\t(struct gfc_namespace): Add `tb_sym_root' as new symtree to sort out\n+\ttype-bound procedures there.\n+\t(gfc_get_tbp_symtree): New procedure.\n+\t* symbol.c (tentative_tbp_list): New global.\n+\t(gfc_get_namespace): NULL new `tb_sym_root' member.\n+\t(gfc_new_symtree): Removed initialization of `typebound' member.\n+\t(gfc_undo_symbols): Process list of tentative tbp's.\n+\t(gfc_commit_symbols): Ditto.\n+\t(free_tb_tree): New method.\n+\t(gfc_free_namespace): Call it.\n+\t(gfc_get_typebound_proc): New method.\n+\t(gfc_get_tbp_symtree): New method.\n+\t(gfc_find_typebound_proc): Adapt to structural changes of gfc_symtree\n+\tand gfc_namespace with regards to tbp's.\n+\t* dump-parse-tree.c (show_typebound): Ditto.\n+\t* primary.c (gfc_match_varspec): Ditto.  Don't reference tbp-symbol\n+\tas it isn't a symbol any longer.\n+\t* module.c (mio_typebound_symtree): Adapt to changes.\n+\t(mio_typebound_proc): Ditto, create symtrees using `gfc_get_tbp_symtree'\n+\trather than `gfc_get_sym_tree'.\n+\t(mio_f2k_derived): Ditto.\n+\t* decl.c (match_procedure_in_type): Ditto.\n+\t(gfc_match_generic): Ditto.  Don't reference tbp-symbol.\n+\t* resolve.c (check_typebound_override): Adapt to changes.\n+\t(resolve_typebound_generic): Ditto.\n+\t(resolve_typebound_procedures): Ditto.\n+\t(ensure_not_abstract_walker): Ditto.\n+\t(ensure_not_abstract): Ditto.\n+\t(resolve_typebound_procedure): Ditto, ignore erraneous symbols (for\n+\tinstance, through removed tentative ones).\n+\t* gfc-internals.texi (Type-bound procedures): Document changes.\n+\n 2009-04-24  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/39861"}, {"sha": "1a2e8452e5df6fcf8741bd955b4a8f7630a609eb", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "patch": "@@ -7141,21 +7141,26 @@ match_procedure_in_type (void)\n   /* See if we already have a binding with this name in the symtree which would\n      be an error.  If a GENERIC already targetted this binding, it may be\n      already there but then typebound is still NULL.  */\n-  stree = gfc_find_symtree (ns->sym_root, name);\n-  if (stree && stree->typebound)\n+  stree = gfc_find_symtree (ns->tb_sym_root, name);\n+  if (stree && stree->n.tb)\n     {\n       gfc_error (\"There's already a procedure with binding name '%s' for the\"\n \t\t \" derived type '%s' at %C\", name, block->name);\n       return MATCH_ERROR;\n     }\n \n   /* Insert it and set attributes.  */\n-  if (gfc_get_sym_tree (name, ns, &stree))\n-    return MATCH_ERROR;\n+\n+  if (!stree)\n+    {\n+      stree = gfc_new_symtree (&ns->tb_sym_root, name);\n+      gcc_assert (stree);\n+    }\n+  stree->n.tb = tb;\n+\n   if (gfc_get_sym_tree (target, gfc_current_ns, &tb->u.specific))\n     return MATCH_ERROR;\n   gfc_set_sym_referenced (tb->u.specific->n.sym);\n-  stree->typebound = tb;\n \n   return MATCH_YES;\n }\n@@ -7210,18 +7215,20 @@ gfc_match_generic (void)\n \n   /* If there's already something with this name, check that it is another\n      GENERIC and then extend that rather than build a new node.  */\n-  st = gfc_find_symtree (ns->sym_root, name);\n+  st = gfc_find_symtree (ns->tb_sym_root, name);\n   if (st)\n     {\n-      if (!st->typebound || !st->typebound->is_generic)\n+      gcc_assert (st->n.tb);\n+      tb = st->n.tb;\n+\n+      if (!tb->is_generic)\n \t{\n \t  gfc_error (\"There's already a non-generic procedure with binding name\"\n \t\t     \" '%s' for the derived type '%s' at %C\",\n \t\t     name, block->name);\n \t  goto error;\n \t}\n \n-      tb = st->typebound;\n       if (tb->access != tbattr.access)\n \t{\n \t  gfc_error (\"Binding at %C must have the same access as already\"\n@@ -7231,10 +7238,10 @@ gfc_match_generic (void)\n     }\n   else\n     {\n-      if (gfc_get_sym_tree (name, ns, &st))\n-\treturn MATCH_ERROR;\n+      st = gfc_new_symtree (&ns->tb_sym_root, name);\n+      gcc_assert (st);\n \n-      st->typebound = tb = gfc_get_typebound_proc ();\n+      st->n.tb = tb = gfc_get_typebound_proc ();\n       tb->where = gfc_current_locus;\n       tb->access = tbattr.access;\n       tb->is_generic = 1;\n@@ -7256,20 +7263,17 @@ gfc_match_generic (void)\n \t  goto error;\n \t}\n \n-      if (gfc_get_sym_tree (name, ns, &target_st))\n-\tgoto error;\n+      target_st = gfc_get_tbp_symtree (&ns->tb_sym_root, name);\n \n       /* See if this is a duplicate specification.  */\n       for (target = tb->u.generic; target; target = target->next)\n \tif (target_st == target->specific_st)\n \t  {\n \t    gfc_error (\"'%s' already defined as specific binding for the\"\n-\t\t       \" generic '%s' at %C\", name, st->n.sym->name);\n+\t\t       \" generic '%s' at %C\", name, st->name);\n \t    goto error;\n \t  }\n \n-      gfc_set_sym_referenced (target_st->n.sym);\n-\n       target = gfc_get_tbp_generic ();\n       target->specific_st = target_st;\n       target->specific = NULL;"}, {"sha": "6c915084db92a69f375d5d78b268403e261536cc", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "patch": "@@ -671,48 +671,48 @@ show_components (gfc_symbol *sym)\n static void\n show_typebound (gfc_symtree* st)\n {\n-  if (!st->typebound)\n+  if (!st->n.tb)\n     return;\n \n   show_indent ();\n \n-  if (st->typebound->is_generic)\n+  if (st->n.tb->is_generic)\n     fputs (\"GENERIC\", dumpfile);\n   else\n     {\n       fputs (\"PROCEDURE, \", dumpfile);\n-      if (st->typebound->nopass)\n+      if (st->n.tb->nopass)\n \tfputs (\"NOPASS\", dumpfile);\n       else\n \t{\n-\t  if (st->typebound->pass_arg)\n-\t    fprintf (dumpfile, \"PASS(%s)\", st->typebound->pass_arg);\n+\t  if (st->n.tb->pass_arg)\n+\t    fprintf (dumpfile, \"PASS(%s)\", st->n.tb->pass_arg);\n \t  else\n \t    fputs (\"PASS\", dumpfile);\n \t}\n-      if (st->typebound->non_overridable)\n+      if (st->n.tb->non_overridable)\n \tfputs (\", NON_OVERRIDABLE\", dumpfile);\n     }\n \n-  if (st->typebound->access == ACCESS_PUBLIC)\n+  if (st->n.tb->access == ACCESS_PUBLIC)\n     fputs (\", PUBLIC\", dumpfile);\n   else\n     fputs (\", PRIVATE\", dumpfile);\n \n   fprintf (dumpfile, \" :: %s => \", st->n.sym->name);\n \n-  if (st->typebound->is_generic)\n+  if (st->n.tb->is_generic)\n     {\n       gfc_tbp_generic* g;\n-      for (g = st->typebound->u.generic; g; g = g->next)\n+      for (g = st->n.tb->u.generic; g; g = g->next)\n \t{\n \t  fputs (g->specific_st->name, dumpfile);\n \t  if (g->next)\n \t    fputs (\", \", dumpfile);\n \t}\n     }\n   else\n-    fputs (st->typebound->u.specific->n.sym->name, dumpfile);\n+    fputs (st->n.tb->u.specific->n.sym->name, dumpfile);\n }\n \n static void"}, {"sha": "65fc7697dc7e34a3936f052df33e78b8c9d89450", "filename": "gcc/fortran/gfc-internals.texi", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fgfc-internals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fgfc-internals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfc-internals.texi?ref=e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "patch": "@@ -577,15 +577,14 @@ substring reference as described in the subsection above.\n @node Type-bound Procedures\n @section Type-bound Procedures\n \n-Type-bound procedures are stored in the @code{sym_root} of the namespace\n+Type-bound procedures are stored in the @code{tb_sym_root} of the namespace\n @code{f2k_derived} associated with the derived-type symbol as @code{gfc_symtree}\n nodes.  The name and symbol of these symtrees corresponds to the binding-name\n of the procedure, i.e. the name that is used to call it from the context of an\n object of the derived-type.\n \n-In addition, those and only those symtrees representing a type-bound procedure\n-have their @code{typebound} member set; @code{typebound} points to a struct of\n-type @code{gfc_typebound_proc} containing the additional data needed:  The\n+In addition, this type of symtrees stores in @code{n.tb} a struct of type\n+@code{gfc_typebound_proc} containing the additional data needed:  The\n binding attributes (like @code{PASS} and @code{NOPASS}, @code{NON_OVERRIDABLE} \n or the access-specifier), the binding's target(s) and, if the current binding\n overrides or extends an inherited binding of the same name, @code{overridden}"}, {"sha": "875be9516b881ab7b9c6eca85f7fc48a608ea228", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "patch": "@@ -1049,8 +1049,6 @@ typedef struct gfc_typebound_proc\n }\n gfc_typebound_proc;\n \n-#define gfc_get_typebound_proc() XCNEW (gfc_typebound_proc)\n-\n \n /* Symbol nodes.  These are important things.  They are what the\n    standard refers to as \"entities\".  The possibly multiple names that\n@@ -1215,11 +1213,9 @@ typedef struct gfc_symtree\n     gfc_symbol *sym;\t\t/* Symbol associated with this node */\n     gfc_user_op *uop;\n     gfc_common_head *common;\n+    gfc_typebound_proc *tb;\n   }\n   n;\n-\n-  /* Data for type-bound procedures; NULL if no type-bound procedure.  */\n-  gfc_typebound_proc* typebound;\n }\n gfc_symtree;\n \n@@ -1248,6 +1244,9 @@ typedef struct gfc_namespace\n   gfc_symtree *uop_root;\n   /* Tree containing all the common blocks.  */\n   gfc_symtree *common_root;\n+\n+  /* Tree containing type-bound procedures.  */\n+  gfc_symtree *tb_sym_root;\n   /* Linked list of finalizer procedures.  */\n   struct gfc_finalizer *finalizers;\n \n@@ -2370,8 +2369,10 @@ void gfc_free_dt_list (void);\n gfc_gsymbol *gfc_get_gsymbol (const char *);\n gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n \n+gfc_typebound_proc* gfc_get_typebound_proc (void);\n gfc_symbol* gfc_get_derived_super_type (gfc_symbol*);\n gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, gfc_try*, const char*, bool);\n+gfc_symtree* gfc_get_tbp_symtree (gfc_symtree**, const char*);\n \n void gfc_copy_formal_args (gfc_symbol *, gfc_symbol *);\n void gfc_copy_formal_args_intr (gfc_symbol *, gfc_intrinsic_sym *);"}, {"sha": "12ac96600cfd0b76518d4920be1083f9a01c5b94", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "patch": "@@ -3251,12 +3251,14 @@ mio_typebound_proc (gfc_typebound_proc** proc)\n \t  (*proc)->u.generic = NULL;\n \t  while (peek_atom () != ATOM_RPAREN)\n \t    {\n+\t      gfc_symtree** sym_root;\n+\n \t      g = gfc_get_tbp_generic ();\n \t      g->specific = NULL;\n \n \t      require_atom (ATOM_STRING);\n-\t      gfc_get_sym_tree (atom_string, current_f2k_derived,\n-\t\t\t\t&g->specific_st);\n+\t      sym_root = &current_f2k_derived->tb_sym_root;\n+\t      g->specific_st = gfc_get_tbp_symtree (sym_root, atom_string);\n \t      gfc_free (atom_string);\n \n \t      g->next = (*proc)->u.generic;\n@@ -3275,7 +3277,7 @@ mio_typebound_proc (gfc_typebound_proc** proc)\n static void\n mio_typebound_symtree (gfc_symtree* st)\n {\n-  if (iomode == IO_OUTPUT && !st->typebound)\n+  if (iomode == IO_OUTPUT && !st->n.tb)\n     return;\n \n   if (iomode == IO_OUTPUT)\n@@ -3285,7 +3287,7 @@ mio_typebound_symtree (gfc_symtree* st)\n     }\n   /* For IO_INPUT, the above is done in mio_f2k_derived.  */\n \n-  mio_typebound_proc (&st->typebound);\n+  mio_typebound_proc (&st->n.tb);\n   mio_rparen ();\n }\n \n@@ -3338,7 +3340,7 @@ mio_f2k_derived (gfc_namespace *f2k)\n   /* Handle type-bound procedures.  */\n   mio_lparen ();\n   if (iomode == IO_OUTPUT)\n-    gfc_traverse_symtree (f2k->sym_root, &mio_typebound_symtree);\n+    gfc_traverse_symtree (f2k->tb_sym_root, &mio_typebound_symtree);\n   else\n     {\n       while (peek_atom () == ATOM_LPAREN)\n@@ -3348,7 +3350,7 @@ mio_f2k_derived (gfc_namespace *f2k)\n \t  mio_lparen (); \n \n \t  require_atom (ATOM_STRING);\n-\t  gfc_get_sym_tree (atom_string, f2k, &st);\n+\t  st = gfc_get_tbp_symtree (&f2k->tb_sym_root, atom_string);\n \t  gfc_free (atom_string);\n \n \t  mio_typebound_symtree (st);"}, {"sha": "7e41535c266181fb8be81c65c381ecb048f2d3ab", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "patch": "@@ -1784,19 +1784,19 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag)\n \t  gcc_assert (!tail || !tail->next);\n \t  gcc_assert (primary->expr_type == EXPR_VARIABLE);\n \n-\t  if (tbp->typebound->is_generic)\n+\t  if (tbp->n.tb->is_generic)\n \t    tbp_sym = NULL;\n \t  else\n-\t    tbp_sym = tbp->typebound->u.specific->n.sym;\n+\t    tbp_sym = tbp->n.tb->u.specific->n.sym;\n \n \t  primary->expr_type = EXPR_COMPCALL;\n-\t  primary->value.compcall.tbp = tbp->typebound;\n+\t  primary->value.compcall.tbp = tbp->n.tb;\n \t  primary->value.compcall.name = tbp->name;\n \t  gcc_assert (primary->symtree->n.sym->attr.referenced);\n \t  if (tbp_sym)\n \t    primary->ts = tbp_sym->ts;\n \n-\t  m = gfc_match_actual_arglist (tbp->typebound->subroutine,\n+\t  m = gfc_match_actual_arglist (tbp->n.tb->subroutine,\n \t\t\t\t\t&primary->value.compcall.actual);\n \t  if (m == MATCH_ERROR)\n \t    return MATCH_ERROR;\n@@ -1811,8 +1811,6 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag)\n \t\t}\n \t    }\n \n-\t  gfc_set_sym_referenced (tbp->n.sym);\n-\n \t  break;\n \t}\n "}, {"sha": "3277475d1e7ab02901ce99ad828f8b37ebd3ecc5", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 73, "deletions": 67, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "patch": "@@ -8283,30 +8283,30 @@ check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n   gfc_formal_arglist* old_formal;\n \n   /* This procedure should only be called for non-GENERIC proc.  */\n-  gcc_assert (!proc->typebound->is_generic);\n+  gcc_assert (!proc->n.tb->is_generic);\n \n   /* If the overwritten procedure is GENERIC, this is an error.  */\n-  if (old->typebound->is_generic)\n+  if (old->n.tb->is_generic)\n     {\n       gfc_error (\"Can't overwrite GENERIC '%s' at %L\",\n-\t\t old->name, &proc->typebound->where);\n+\t\t old->name, &proc->n.tb->where);\n       return FAILURE;\n     }\n \n-  where = proc->typebound->where;\n-  proc_target = proc->typebound->u.specific->n.sym;\n-  old_target = old->typebound->u.specific->n.sym;\n+  where = proc->n.tb->where;\n+  proc_target = proc->n.tb->u.specific->n.sym;\n+  old_target = old->n.tb->u.specific->n.sym;\n \n   /* Check that overridden binding is not NON_OVERRIDABLE.  */\n-  if (old->typebound->non_overridable)\n+  if (old->n.tb->non_overridable)\n     {\n       gfc_error (\"'%s' at %L overrides a procedure binding declared\"\n \t\t \" NON_OVERRIDABLE\", proc->name, &where);\n       return FAILURE;\n     }\n \n   /* It's an error to override a non-DEFERRED procedure with a DEFERRED one.  */\n-  if (!old->typebound->deferred && proc->typebound->deferred)\n+  if (!old->n.tb->deferred && proc->n.tb->deferred)\n     {\n       gfc_error (\"'%s' at %L must not be DEFERRED as it overrides a\"\n \t\t \" non-DEFERRED binding\", proc->name, &where);\n@@ -8370,8 +8370,8 @@ check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n \n   /* If the overridden binding is PUBLIC, the overriding one must not be\n      PRIVATE.  */\n-  if (old->typebound->access == ACCESS_PUBLIC\n-      && proc->typebound->access == ACCESS_PRIVATE)\n+  if (old->n.tb->access == ACCESS_PUBLIC\n+      && proc->n.tb->access == ACCESS_PRIVATE)\n     {\n       gfc_error (\"'%s' at %L overrides a PUBLIC procedure and must not be\"\n \t\t \" PRIVATE\", proc->name, &where);\n@@ -8383,20 +8383,20 @@ check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n      bindings as at least the overridden one might not yet be resolved and we\n      need those positions in the check below.  */\n   proc_pass_arg = old_pass_arg = 0;\n-  if (!proc->typebound->nopass && !proc->typebound->pass_arg)\n+  if (!proc->n.tb->nopass && !proc->n.tb->pass_arg)\n     proc_pass_arg = 1;\n-  if (!old->typebound->nopass && !old->typebound->pass_arg)\n+  if (!old->n.tb->nopass && !old->n.tb->pass_arg)\n     old_pass_arg = 1;\n   argpos = 1;\n   for (proc_formal = proc_target->formal, old_formal = old_target->formal;\n        proc_formal && old_formal;\n        proc_formal = proc_formal->next, old_formal = old_formal->next)\n     {\n-      if (proc->typebound->pass_arg\n-\t  && !strcmp (proc->typebound->pass_arg, proc_formal->sym->name))\n+      if (proc->n.tb->pass_arg\n+\t  && !strcmp (proc->n.tb->pass_arg, proc_formal->sym->name))\n \tproc_pass_arg = argpos;\n-      if (old->typebound->pass_arg\n-\t  && !strcmp (old->typebound->pass_arg, old_formal->sym->name))\n+      if (old->n.tb->pass_arg\n+\t  && !strcmp (old->n.tb->pass_arg, old_formal->sym->name))\n \told_pass_arg = argpos;\n \n       /* Check that the names correspond.  */\n@@ -8432,7 +8432,7 @@ check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n \n   /* If the overridden binding is NOPASS, the overriding one must also be\n      NOPASS.  */\n-  if (old->typebound->nopass && !proc->typebound->nopass)\n+  if (old->n.tb->nopass && !proc->n.tb->nopass)\n     {\n       gfc_error (\"'%s' at %L overrides a NOPASS binding and must also be\"\n \t\t \" NOPASS\", proc->name, &where);\n@@ -8441,9 +8441,9 @@ check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n \n   /* If the overridden binding is PASS(x), the overriding one must also be\n      PASS and the passed-object dummy arguments must correspond.  */\n-  if (!old->typebound->nopass)\n+  if (!old->n.tb->nopass)\n     {\n-      if (proc->typebound->nopass)\n+      if (proc->n.tb->nopass)\n \t{\n \t  gfc_error (\"'%s' at %L overrides a binding with PASS and must also be\"\n \t\t     \" PASS\", proc->name, &where);\n@@ -8512,26 +8512,26 @@ resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n   gfc_symtree* inherited;\n   locus where;\n \n-  gcc_assert (st->typebound);\n-  gcc_assert (st->typebound->is_generic);\n+  gcc_assert (st->n.tb);\n+  gcc_assert (st->n.tb->is_generic);\n \n-  where = st->typebound->where;\n+  where = st->n.tb->where;\n   super_type = gfc_get_derived_super_type (derived);\n \n   /* Find the overridden binding if any.  */\n-  st->typebound->overridden = NULL;\n+  st->n.tb->overridden = NULL;\n   if (super_type)\n     {\n       gfc_symtree* overridden;\n       overridden = gfc_find_typebound_proc (super_type, NULL, st->name, true);\n \n-      if (overridden && overridden->typebound)\n-\tst->typebound->overridden = overridden->typebound;\n+      if (overridden && overridden->n.tb)\n+\tst->n.tb->overridden = overridden->n.tb;\n     }\n \n   /* Try to find the specific bindings for the symtrees in our target-list.  */\n-  gcc_assert (st->typebound->u.generic);\n-  for (target = st->typebound->u.generic; target; target = target->next)\n+  gcc_assert (st->n.tb->u.generic);\n+  for (target = st->n.tb->u.generic; target; target = target->next)\n     if (!target->specific)\n       {\n \tgfc_typebound_proc* overridden_tbp;\n@@ -8541,9 +8541,9 @@ resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n \ttarget_name = target->specific_st->name;\n \n \t/* Defined for this type directly.  */\n-\tif (target->specific_st->typebound)\n+\tif (target->specific_st->n.tb)\n \t  {\n-\t    target->specific = target->specific_st->typebound;\n+\t    target->specific = target->specific_st->n.tb;\n \t    goto specific_found;\n \t  }\n \n@@ -8555,8 +8555,8 @@ resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n \n \t    if (inherited)\n \t      {\n-\t\tgcc_assert (inherited->typebound);\n-\t\ttarget->specific = inherited->typebound;\n+\t\tgcc_assert (inherited->n.tb);\n+\t\ttarget->specific = inherited->n.tb;\n \t\tgoto specific_found;\n \t      }\n \t  }\n@@ -8579,14 +8579,14 @@ resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n \t  }\n \n \t/* Check those already resolved on this type directly.  */\n-\tfor (g = st->typebound->u.generic; g; g = g->next)\n+\tfor (g = st->n.tb->u.generic; g; g = g->next)\n \t  if (g != target && g->specific\n \t      && check_generic_tbp_ambiguity (target, g, st->name, where)\n \t\t  == FAILURE)\n \t    return FAILURE;\n \n \t/* Check for ambiguity with inherited specific targets.  */\n-\tfor (overridden_tbp = st->typebound->overridden; overridden_tbp;\n+\tfor (overridden_tbp = st->n.tb->overridden; overridden_tbp;\n \t     overridden_tbp = overridden_tbp->overridden)\n \t  if (overridden_tbp->is_generic)\n \t    {\n@@ -8601,7 +8601,7 @@ resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n       }\n \n   /* If we attempt to \"overwrite\" a specific binding, this is an error.  */\n-  if (st->typebound->overridden && !st->typebound->overridden->is_generic)\n+  if (st->n.tb->overridden && !st->n.tb->overridden->is_generic)\n     {\n       gfc_error (\"GENERIC '%s' at %L can't overwrite specific binding with\"\n \t\t \" the same name\", st->name, &where);\n@@ -8610,9 +8610,10 @@ resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n \n   /* Take the SUBROUTINE/FUNCTION attributes of the first specific target, as\n      all must have the same attributes here.  */\n-  first_target = st->typebound->u.generic->specific->u.specific;\n-  st->typebound->subroutine = first_target->n.sym->attr.subroutine;\n-  st->typebound->function = first_target->n.sym->attr.function;\n+  first_target = st->n.tb->u.generic->specific->u.specific;\n+  gcc_assert (first_target);\n+  st->n.tb->subroutine = first_target->n.sym->attr.subroutine;\n+  st->n.tb->function = first_target->n.sym->attr.function;\n \n   return SUCCESS;\n }\n@@ -8632,12 +8633,17 @@ resolve_typebound_procedure (gfc_symtree* stree)\n   gfc_symbol* super_type;\n   gfc_component* comp;\n \n-  /* If this is no type-bound procedure, just return.  */\n-  if (!stree->typebound)\n+  gcc_assert (stree);\n+\n+  /* Undefined specific symbol from GENERIC target definition.  */\n+  if (!stree->n.tb)\n+    return;\n+\n+  if (stree->n.tb->error)\n     return;\n \n   /* If this is a GENERIC binding, use that routine.  */\n-  if (stree->typebound->is_generic)\n+  if (stree->n.tb->is_generic)\n     {\n       if (resolve_typebound_generic (resolve_bindings_derived, stree)\n \t    == FAILURE)\n@@ -8646,27 +8652,27 @@ resolve_typebound_procedure (gfc_symtree* stree)\n     }\n \n   /* Get the target-procedure to check it.  */\n-  gcc_assert (!stree->typebound->is_generic);\n-  gcc_assert (stree->typebound->u.specific);\n-  proc = stree->typebound->u.specific->n.sym;\n-  where = stree->typebound->where;\n+  gcc_assert (!stree->n.tb->is_generic);\n+  gcc_assert (stree->n.tb->u.specific);\n+  proc = stree->n.tb->u.specific->n.sym;\n+  where = stree->n.tb->where;\n \n   /* Default access should already be resolved from the parser.  */\n-  gcc_assert (stree->typebound->access != ACCESS_UNKNOWN);\n+  gcc_assert (stree->n.tb->access != ACCESS_UNKNOWN);\n \n   /* It should be a module procedure or an external procedure with explicit\n      interface.  For DEFERRED bindings, abstract interfaces are ok as well.  */\n   if ((!proc->attr.subroutine && !proc->attr.function)\n       || (proc->attr.proc != PROC_MODULE\n \t  && proc->attr.if_source != IFSRC_IFBODY)\n-      || (proc->attr.abstract && !stree->typebound->deferred))\n+      || (proc->attr.abstract && !stree->n.tb->deferred))\n     {\n       gfc_error (\"'%s' must be a module procedure or an external procedure with\"\n \t\t \" an explicit interface at %L\", proc->name, &where);\n       goto error;\n     }\n-  stree->typebound->subroutine = proc->attr.subroutine;\n-  stree->typebound->function = proc->attr.function;\n+  stree->n.tb->subroutine = proc->attr.subroutine;\n+  stree->n.tb->function = proc->attr.function;\n \n   /* Find the super-type of the current derived type.  We could do this once and\n      store in a global if speed is needed, but as long as not I believe this is\n@@ -8675,41 +8681,41 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \n   /* If PASS, resolve and check arguments if not already resolved / loaded\n      from a .mod file.  */\n-  if (!stree->typebound->nopass && stree->typebound->pass_arg_num == 0)\n+  if (!stree->n.tb->nopass && stree->n.tb->pass_arg_num == 0)\n     {\n-      if (stree->typebound->pass_arg)\n+      if (stree->n.tb->pass_arg)\n \t{\n \t  gfc_formal_arglist* i;\n \n \t  /* If an explicit passing argument name is given, walk the arg-list\n \t     and look for it.  */\n \n \t  me_arg = NULL;\n-\t  stree->typebound->pass_arg_num = 1;\n+\t  stree->n.tb->pass_arg_num = 1;\n \t  for (i = proc->formal; i; i = i->next)\n \t    {\n-\t      if (!strcmp (i->sym->name, stree->typebound->pass_arg))\n+\t      if (!strcmp (i->sym->name, stree->n.tb->pass_arg))\n \t\t{\n \t\t  me_arg = i->sym;\n \t\t  break;\n \t\t}\n-\t      ++stree->typebound->pass_arg_num;\n+\t      ++stree->n.tb->pass_arg_num;\n \t    }\n \n \t  if (!me_arg)\n \t    {\n \t      gfc_error (\"Procedure '%s' with PASS(%s) at %L has no\"\n \t\t\t \" argument '%s'\",\n-\t\t\t proc->name, stree->typebound->pass_arg, &where,\n-\t\t\t stree->typebound->pass_arg);\n+\t\t\t proc->name, stree->n.tb->pass_arg, &where,\n+\t\t\t stree->n.tb->pass_arg);\n \t      goto error;\n \t    }\n \t}\n       else\n \t{\n \t  /* Otherwise, take the first one; there should in fact be at least\n \t     one.  */\n-\t  stree->typebound->pass_arg_num = 1;\n+\t  stree->n.tb->pass_arg_num = 1;\n \t  if (!proc->formal)\n \t    {\n \t      gfc_error (\"Procedure '%s' with PASS at %L must have at\"\n@@ -8737,15 +8743,15 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \n   /* If we are extending some type, check that we don't override a procedure\n      flagged NON_OVERRIDABLE.  */\n-  stree->typebound->overridden = NULL;\n+  stree->n.tb->overridden = NULL;\n   if (super_type)\n     {\n       gfc_symtree* overridden;\n       overridden = gfc_find_typebound_proc (super_type, NULL,\n \t\t\t\t\t    stree->name, true);\n \n-      if (overridden && overridden->typebound)\n-\tstree->typebound->overridden = overridden->typebound;\n+      if (overridden && overridden->n.tb)\n+\tstree->n.tb->overridden = overridden->n.tb;\n \n       if (overridden && check_typebound_override (stree, overridden) == FAILURE)\n \tgoto error;\n@@ -8770,23 +8776,23 @@ resolve_typebound_procedure (gfc_symtree* stree)\n       goto error;\n     }\n \n-  stree->typebound->error = 0;\n+  stree->n.tb->error = 0;\n   return;\n \n error:\n   resolve_bindings_result = FAILURE;\n-  stree->typebound->error = 1;\n+  stree->n.tb->error = 1;\n }\n \n static gfc_try\n resolve_typebound_procedures (gfc_symbol* derived)\n {\n-  if (!derived->f2k_derived || !derived->f2k_derived->sym_root)\n+  if (!derived->f2k_derived || !derived->f2k_derived->tb_sym_root)\n     return SUCCESS;\n \n   resolve_bindings_derived = derived;\n   resolve_bindings_result = SUCCESS;\n-  gfc_traverse_symtree (derived->f2k_derived->sym_root,\n+  gfc_traverse_symtree (derived->f2k_derived->tb_sym_root,\n \t\t\t&resolve_typebound_procedure);\n \n   return resolve_bindings_result;\n@@ -8828,12 +8834,12 @@ ensure_not_abstract_walker (gfc_symbol* sub, gfc_symtree* st)\n   if (ensure_not_abstract_walker (sub, st->right) == FAILURE)\n     return FAILURE;\n \n-  if (st->typebound && st->typebound->deferred)\n+  if (st->n.tb && st->n.tb->deferred)\n     {\n       gfc_symtree* overriding;\n       overriding = gfc_find_typebound_proc (sub, NULL, st->name, true);\n-      gcc_assert (overriding && overriding->typebound);\n-      if (overriding->typebound->deferred)\n+      gcc_assert (overriding && overriding->n.tb);\n+      if (overriding->n.tb->deferred)\n \t{\n \t  gfc_error (\"Derived-type '%s' declared at %L must be ABSTRACT because\"\n \t\t     \" '%s' is DEFERRED and not overridden\",\n@@ -8861,7 +8867,7 @@ ensure_not_abstract (gfc_symbol* sub, gfc_symbol* ancestor)\n   if (ancestor->f2k_derived)\n     {\n       gfc_try t;\n-      t = ensure_not_abstract_walker (sub, ancestor->f2k_derived->sym_root);\n+      t = ensure_not_abstract_walker (sub, ancestor->f2k_derived->tb_sym_root);\n       if (t == FAILURE)\n \treturn FAILURE;\n     }"}, {"sha": "a82e67558fb29c9c63d3e5c5250298c0b4e20e2e", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 95, "deletions": 4, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "patch": "@@ -101,6 +101,18 @@ static gfc_symbol *changed_syms = NULL;\n gfc_dt_list *gfc_derived_types;\n \n \n+/* List of tentative typebound-procedures.  */\n+\n+typedef struct tentative_tbp\n+{\n+  gfc_typebound_proc *proc;\n+  struct tentative_tbp *next;\n+}\n+tentative_tbp;\n+\n+static tentative_tbp *tentative_tbp_list = NULL;\n+\n+\n /*********** IMPLICIT NONE and IMPLICIT statement handlers ***********/\n \n /* The following static variable indicates whether a particular element has\n@@ -2191,6 +2203,7 @@ gfc_get_namespace (gfc_namespace *parent, int parent_types)\n   ns = XCNEW (gfc_namespace);\n   ns->sym_root = NULL;\n   ns->uop_root = NULL;\n+  ns->tb_sym_root = NULL;\n   ns->finalizers = NULL;\n   ns->default_access = ACCESS_UNKNOWN;\n   ns->parent = parent;\n@@ -2258,7 +2271,6 @@ gfc_new_symtree (gfc_symtree **root, const char *name)\n \n   st = XCNEW (gfc_symtree);\n   st->name = gfc_get_string (name);\n-  st->typebound = NULL;\n \n   gfc_insert_bbt (root, st, compare_symtree);\n   return st;\n@@ -2691,6 +2703,7 @@ void\n gfc_undo_symbols (void)\n {\n   gfc_symbol *p, *q, *old;\n+  tentative_tbp *tbp, *tbq;\n \n   for (p = changed_syms; p; p = q)\n     {\n@@ -2789,6 +2802,14 @@ gfc_undo_symbols (void)\n     }\n \n   changed_syms = NULL;\n+\n+  for (tbp = tentative_tbp_list; tbp; tbp = tbq)\n+    {\n+      tbq = tbp->next;\n+      /* Procedure is already marked `error' by default.  */\n+      gfc_free (tbp);\n+    }\n+  tentative_tbp_list = NULL;\n }\n \n \n@@ -2826,6 +2847,7 @@ void\n gfc_commit_symbols (void)\n {\n   gfc_symbol *p, *q;\n+  tentative_tbp *tbp, *tbq;\n \n   for (p = changed_syms; p; p = q)\n     {\n@@ -2836,6 +2858,14 @@ gfc_commit_symbols (void)\n       free_old_symbol (p);\n     }\n   changed_syms = NULL;\n+\n+  for (tbp = tentative_tbp_list; tbp; tbp = tbq)\n+    {\n+      tbq = tbp->next;\n+      tbp->proc->error = 0;\n+      gfc_free (tbp);\n+    }\n+  tentative_tbp_list = NULL;\n }\n \n \n@@ -2867,6 +2897,24 @@ gfc_commit_symbol (gfc_symbol *sym)\n }\n \n \n+/* Recursively free trees containing type-bound procedures.  */\n+\n+static void\n+free_tb_tree (gfc_symtree *t)\n+{\n+  if (t == NULL)\n+    return;\n+\n+  free_tb_tree (t->left);\n+  free_tb_tree (t->right);\n+\n+  /* TODO: Free type-bound procedure structs themselves; probably needs some\n+     sort of ref-counting mechanism.  */\n+\n+  gfc_free (t);\n+}\n+\n+\n /* Recursive function that deletes an entire tree and all the common\n    head structures it points to.  */\n \n@@ -3055,6 +3103,7 @@ gfc_free_namespace (gfc_namespace *ns)\n   free_sym_tree (ns->sym_root);\n   free_uop_tree (ns->uop_root);\n   free_common_tree (ns->common_root);\n+  free_tb_tree (ns->tb_sym_root);\n   gfc_free_finalizer_list (ns->finalizers);\n   gfc_free_charlen (ns->cl_list, NULL);\n   free_st_labels (ns->st_labels);\n@@ -4342,6 +4391,27 @@ gfc_check_symbol_typed (gfc_symbol* sym, gfc_namespace* ns,\n }\n \n \n+/* Construct a typebound-procedure structure.  Those are stored in a tentative\n+   list and marked `error' until symbols are committed.  */\n+\n+gfc_typebound_proc*\n+gfc_get_typebound_proc (void)\n+{\n+  gfc_typebound_proc *result;\n+  tentative_tbp *list_node;\n+\n+  result = XCNEW (gfc_typebound_proc);\n+  result->error = 1;\n+\n+  list_node = XCNEW (tentative_tbp);\n+  list_node->next = tentative_tbp_list;\n+  list_node->proc = result;\n+  tentative_tbp_list = list_node;\n+\n+  return result;\n+}\n+\n+\n /* Get the super-type of a given derived type.  */\n \n gfc_symbol*\n@@ -4373,15 +4443,15 @@ gfc_find_typebound_proc (gfc_symbol* derived, gfc_try* t,\n \n   /* Try to find it in the current type's namespace.  */\n   gcc_assert (derived->f2k_derived);\n-  res = gfc_find_symtree (derived->f2k_derived->sym_root, name);\n-  if (res && res->typebound)\n+  res = gfc_find_symtree (derived->f2k_derived->tb_sym_root, name);\n+  if (res && res->n.tb)\n     {\n       /* We found one.  */\n       if (t)\n \t*t = SUCCESS;\n \n       if (!noaccess && derived->attr.use_assoc\n-\t  && res->typebound->access == ACCESS_PRIVATE)\n+\t  && res->n.tb->access == ACCESS_PRIVATE)\n \t{\n \t  gfc_error (\"'%s' of '%s' is PRIVATE at %C\", name, derived->name);\n \t  if (t)\n@@ -4403,3 +4473,24 @@ gfc_find_typebound_proc (gfc_symbol* derived, gfc_try* t,\n   /* Nothing found.  */\n   return NULL;\n }\n+\n+\n+/* Get a typebound-procedure symtree or create and insert it if not yet\n+   present.  This is like a very simplified version of gfc_get_sym_tree for\n+   tbp-symtrees rather than regular ones.  */\n+\n+gfc_symtree*\n+gfc_get_tbp_symtree (gfc_symtree **root, const char *name)\n+{\n+  gfc_symtree *result;\n+\n+  result = gfc_find_symtree (*root, name);\n+  if (!result)\n+    {\n+      result = gfc_new_symtree (root, name);\n+      gcc_assert (result);\n+      result->n.tb = NULL;\n+    }\n+\n+  return result;\n+}"}, {"sha": "bbe7fba7fafd966714fef10f931a8625497994cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "patch": "@@ -1,3 +1,8 @@\n+2009-04-24  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.dg/typebound_generic_1.f03: Change so that no error is\n+\texpected on already erraneous symbol (renamed to fresh one).\n+\n 2009-04-24  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR middle-end/39867"}, {"sha": "1ae08fc14f2cec45a1d9f7dc0a6ab5a9049ec14b", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_1.f03", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34ccb4cd1f39f31ff1bd7374ece738ec7521d74/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_1.f03?ref=e34ccb4cd1f39f31ff1bd7374ece738ec7521d74", "patch": "@@ -28,8 +28,8 @@ MODULE m\n     PROCEDURE, NOPASS :: gen1 => intf1 ! { dg-error \"already a procedure\" }\n     GENERIC :: gen3 => ! { dg-error \"specific binding\" }\n     GENERIC :: gen4 => p1 x ! { dg-error \"Junk after\" }\n-    GENERIC :: gen4 => p_notthere ! { dg-error \"Undefined specific binding\" }\n-    GENERIC :: gen5 => gen1 ! { dg-error \"must target a specific binding\" }\n+    GENERIC :: gen5 => p_notthere ! { dg-error \"Undefined specific binding\" }\n+    GENERIC :: gen6 => gen1 ! { dg-error \"must target a specific binding\" }\n \n     GENERIC :: gensubr => p2 ! { dg-error \"mixed FUNCTION/SUBROUTINE\" }\n     GENERIC :: gensubr => subr"}]}