{"sha": "a1a826110720eda37c73f829daa4ee243ee953f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFhODI2MTEwNzIwZWRhMzdjNzNmODI5ZGFhNGVlMjQzZWU5NTNmNQ==", "commit": {"author": {"name": "Revital Eres", "email": "eres@il.ibm.com", "date": "2007-09-04T12:11:11Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2007-09-04T12:11:11Z"}, "message": "Add new fp flags: -fassociative-math and -freciprocal-math\n\nCo-Authored-By: R. Clint Whaley <whaley@cs.utsa.edu>\nCo-Authored-By: Richard Guenther <rguenther@suse.de>\n\nFrom-SVN: r128075", "tree": {"sha": "67cecf461cc930540853bd8eb0d4f19b3b21b0ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67cecf461cc930540853bd8eb0d4f19b3b21b0ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1a826110720eda37c73f829daa4ee243ee953f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1a826110720eda37c73f829daa4ee243ee953f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1a826110720eda37c73f829daa4ee243ee953f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1a826110720eda37c73f829daa4ee243ee953f5/comments", "author": {"login": "revit13", "id": 16211463, "node_id": "MDQ6VXNlcjE2MjExNDYz", "avatar_url": "https://avatars.githubusercontent.com/u/16211463?v=4", "gravatar_id": "", "url": "https://api.github.com/users/revit13", "html_url": "https://github.com/revit13", "followers_url": "https://api.github.com/users/revit13/followers", "following_url": "https://api.github.com/users/revit13/following{/other_user}", "gists_url": "https://api.github.com/users/revit13/gists{/gist_id}", "starred_url": "https://api.github.com/users/revit13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/revit13/subscriptions", "organizations_url": "https://api.github.com/users/revit13/orgs", "repos_url": "https://api.github.com/users/revit13/repos", "events_url": "https://api.github.com/users/revit13/events{/privacy}", "received_events_url": "https://api.github.com/users/revit13/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cea79118fa00faf811626e67209ca666468bc76f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea79118fa00faf811626e67209ca666468bc76f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cea79118fa00faf811626e67209ca666468bc76f"}], "stats": {"total": 163, "additions": 129, "deletions": 34}, "files": [{"sha": "1abb3fe3ed21a5123b19d08e31c43fc16bccd804", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -1,3 +1,35 @@\n+2007-09-04  Revital Eres  <eres@il.ibm.com>\n+\t    Richard Guenther  <rguenther@suse.de>\n+\t    R. Clint Whaley  <whaley@cs.utsa.edu>\n+\n+\t* doc/invoke.texi (-fassociative-math, -freciprocal-math):\n+\tDocument new flags.\n+\t* tree-tailcall.c (process_assignment): Use -fassociative-math\n+\twhen reodering operands of floating-point type.\n+\t* fold-const.c (fold_comparison, fold_binary): Use\n+\t-fassociative-math and -freciprocal-math instead of\n+\t-funsafe-math-optimization flag.\n+\t* toplev.h (set_unsafe_math_optimizations_flags): Declare function.\n+\t* tree-ssa-math-opts.c (gate_cse_reciprocals): Use\n+\t-freciprocal-math instead of -funsafe-math-optimizations.\n+\t* opts.c (set_fast_math_flags): Set -freciprocal-math and\n+\t-fassociative-math when -ffast-math is set.\n+\t(set_unsafe_math_optimizations_flags): New Function\n+\tto set -freciprocal-math and -fassociative-math when\n+\t-funsafe-math-optimizations is set.\n+\t(common_handle_option): Call it.\n+\t* tree-vectorizer.c (vect_is_simple_reduction): Use\n+\t-fassociative-math when doing reduction on floats.\n+\t* loop-unroll.c (analyze_insn_to_expand_var): Use\n+\t-fassociative-math when expanding an accumulator of type float.\n+\t* simplify-rtx.c (simplify_binary_operation_1): Use\n+\t-fassociative-math and -freciprocal-math when reordeing operands\n+\tof floating-point type.\n+\t* combine.c (combine_simplify_rtx): Likewise.\n+\t* tree-ssa-reassoc.c (break_up_subtract_bb, reassociate_bb):\n+\tLikewise.\n+\t* common.opt (-fassociative-math, -freciprocal-math): New flags.\n+\n 2007-09-04  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR c++/18608"}, {"sha": "c8ed4402f9317029cda86639a63461dd69b9ffc7", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -4699,7 +4699,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n        || code == AND || code == IOR || code == XOR\n        || code == SMAX || code == SMIN || code == UMAX || code == UMIN)\n       && ((INTEGRAL_MODE_P (mode) && code != DIV)\n-\t  || (flag_unsafe_math_optimizations && FLOAT_MODE_P (mode))))\n+\t  || (flag_associative_math && FLOAT_MODE_P (mode))))\n     {\n       if (GET_CODE (XEXP (x, 0)) == code)\n \t{\n@@ -4972,7 +4972,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t}\n \n       /* Try simplify a*(b/c) as (a*b)/c.  */\n-      if (FLOAT_MODE_P (mode) && flag_unsafe_math_optimizations\n+      if (FLOAT_MODE_P (mode) && flag_associative_math \n \t  && GET_CODE (XEXP (x, 0)) == DIV)\n \t{\n \t  rtx tem = simplify_binary_operation (MULT, mode,"}, {"sha": "27b2b63803c529fc795ea07b949f5a6a50fed4d1", "filename": "gcc/common.opt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -1125,6 +1125,15 @@ funsafe-loop-optimizations\n Common Report Var(flag_unsafe_loop_optimizations) Optimization\n Allow loop optimizations to assume that the loops behave in normal way\n \n+fassociative-math\n+Common Report Var(flag_associative_math)\n+Allow optimization for floating-point arithmetic which may change the\n+result of the operation due to rounding.\n+\n+freciprocal-math\n+Common Report Var(flag_reciprocal_math)\n+Same as -fassociative-math for expressions which include division.\n+\n ; Nonzero means that unsafe floating-point math optimizations are allowed\n ; for the sake of speed.  IEEE compliance is not guaranteed, and operations\n ; are allowed to assume that their arguments and results are \"normal\""}, {"sha": "774f2f3709b536f0f456c6e89fd0bfac377bab76", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -6173,6 +6173,7 @@ it might, and @option{-fno-math-errno} is the default.\n \n @item -funsafe-math-optimizations\n @opindex funsafe-math-optimizations\n+\n Allow optimizations for floating-point arithmetic that (a) assume\n that arguments and results are valid and (b) may violate IEEE or\n ANSI standards.  When used at link-time, it may include libraries\n@@ -6184,9 +6185,36 @@ it can result in incorrect output for programs which depend on\n an exact implementation of IEEE or ISO rules/specifications for\n math functions. It may, however, yield faster code for programs\n that do not require the guarantees of these specifications.\n+Enables @option{-freciprocal-math} and @option{-fassociative-math}.\n \n The default is @option{-fno-unsafe-math-optimizations}.\n \n+@item -fassociative-math\n+@opindex -fassociative-math\n+\n+Allow re-association of operands in series of floating-point operations.\n+This violates the ISO C and C++ language standard by possibly changing\n+computation result.  NOTE: re-ordering may change the sign of zero as\n+well as ignore NaNs and inhibit or create underflow or overflow (and\n+thus cannot be used on a code which relies on rounding behavior like\n+@code{(x + 2**52) - 2**52)}.  May also reorder floating-point comparisons\n+and thus may not be used when ordered comparisons are required.\n+This flag doesn't make much sense without @option{-fno-signed-zeros}\n+or @option{-fno-trapping-math} or with @option{-frounding-math}.\n+\n+The default is @option{-fno-associative-math}.\n+\n+@item -freciprocal-math\n+@opindex -freciprocal-math\n+\n+Allow the reciprocal of a value to be used instead of dividing by\n+the value if this enables optimizations.  For example @code{x / y}\n+can be replaced with @code{x * (1/y)} which is useful if @code{(1/y)}\n+is subject to common subexpression elimination.  Note that this loses\n+precision and increases the number of flops operating on the value.\n+\n+The default is @option{-fno-reciprocal-math}.\n+\n @item -ffinite-math-only\n @opindex ffinite-math-only\n Allow optimizations for floating-point arithmetic that assume"}, {"sha": "6b11283a8aefc3f3e5cfade8b4e060fa6db3b825", "filename": "gcc/fold-const.c", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -9096,8 +9096,9 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \n       /* Likewise, we can simplify a comparison of a real constant with\n          a MINUS_EXPR whose first operand is also a real constant, i.e.\n-         (c1 - x) < c2 becomes x > c1-c2.  */\n-      if (flag_unsafe_math_optimizations\n+         (c1 - x) < c2 becomes x > c1-c2.  Reordering is allowed on \n+         floating-point types only if -fassociative-math is set.  */\n+      if (flag_associative_math\n \t  && TREE_CODE (arg1) == REAL_CST\n \t  && TREE_CODE (arg0) == MINUS_EXPR\n \t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == REAL_CST\n@@ -9651,11 +9652,12 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t}\n \n       /* Handle (A1 * C1) + (A2 * C2) with A1, A2 or C1, C2 being the\n-\t same or one.  Make sure type is not saturating.  */\n+\t same or one.  Make sure type is not saturating.\n+\t fold_plusminus_mult_expr will re-associate.  */\n       if ((TREE_CODE (arg0) == MULT_EXPR\n \t   || TREE_CODE (arg1) == MULT_EXPR)\n \t  && !TYPE_SATURATING (type)\n-\t  && (!FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations))\n+\t  && (!FLOAT_TYPE_P (type) || flag_associative_math))\n         {\n \t  tree tem = fold_plusminus_mult_expr (code, type, arg0, arg1);\n \t  if (tem)\n@@ -9791,8 +9793,10 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    return fold_build2 (MULT_EXPR, type, arg0,\n \t\t\t\tbuild_real (type, dconst2));\n \n-          /* Convert a + (b*c + d*e) into (a + b*c) + d*e.  */\n-          if (flag_unsafe_math_optimizations\n+          /* Convert a + (b*c + d*e) into (a + b*c) + d*e.  \n+             We associate floats only if the user has specified\n+             -fassociative-math.  */\n+          if (flag_associative_math\n               && TREE_CODE (arg1) == PLUS_EXPR\n               && TREE_CODE (arg0) != MULT_EXPR)\n             {\n@@ -9806,8 +9810,10 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n                   return fold_build2 (PLUS_EXPR, type, tree0, tree11);\n                 }\n             }\n-          /* Convert (b*c + d*e) + a into b*c + (d*e +a).  */\n-          if (flag_unsafe_math_optimizations\n+          /* Convert (b*c + d*e) + a into b*c + (d*e +a).  \n+             We associate floats only if the user has specified\n+             -fassociative-math.  */\n+          if (flag_associative_math\n               && TREE_CODE (arg0) == PLUS_EXPR\n               && TREE_CODE (arg1) != MULT_EXPR)\n             {\n@@ -9898,10 +9904,10 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       /* In most languages, can't associate operations on floats through\n \t parentheses.  Rather than remember where the parentheses were, we\n \t don't associate floats at all, unless the user has specified\n-\t -funsafe-math-optimizations.\n+\t -fassociative-math.\n \t And, we need to make sure type is not saturating.  */\n \n-      if ((! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n+      if ((! FLOAT_TYPE_P (type) || flag_associative_math)\n \t  && !TYPE_SATURATING (type))\n \t{\n \t  tree var0, con0, lit0, minus_lit0;\n@@ -10202,11 +10208,12 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \treturn tem;\n \n       /* Handle (A1 * C1) - (A2 * C2) with A1, A2 or C1, C2 being the\n-\t same or one.  Make sure type is not saturating.  */\n+\t same or one.  Make sure type is not saturating.\n+\t fold_plusminus_mult_expr will re-associate.  */\n       if ((TREE_CODE (arg0) == MULT_EXPR\n \t   || TREE_CODE (arg1) == MULT_EXPR)\n \t  && !TYPE_SATURATING (type)\n-\t  && (!FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations))\n+\t  && (!FLOAT_TYPE_P (type) || flag_associative_math))\n         {\n \t  tree tem = fold_plusminus_mult_expr (code, type, arg0, arg1);\n \t  if (tem)\n@@ -10297,8 +10304,10 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      && real_minus_onep (arg1))\n \t    return fold_convert (type, negate_expr (arg0));\n \n-\t  /* Convert (C1/X)*C2 into (C1*C2)/X.  */\n-\t  if (flag_unsafe_math_optimizations\n+\t  /* Convert (C1/X)*C2 into (C1*C2)/X.  This transformation may change\n+             the result for floating point types due to rounding so it is applied\n+             only if -fassociative-math was specify.  */\n+\t  if (flag_associative_math\n \t      && TREE_CODE (arg0) == RDIV_EXPR\n \t      && TREE_CODE (arg1) == REAL_CST\n \t      && TREE_CODE (TREE_OPERAND (arg0, 0)) == REAL_CST)\n@@ -10962,12 +10971,12 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n       /* If ARG1 is a constant, we can convert this to a multiply by the\n \t reciprocal.  This does not have the same rounding properties,\n-\t so only do this if -funsafe-math-optimizations.  We can actually\n+\t so only do this if -freciprocal-math.  We can actually\n \t always safely do it if ARG1 is a power of two, but it's hard to\n \t tell if it is or not in a portable manner.  */\n       if (TREE_CODE (arg1) == REAL_CST)\n \t{\n-\t  if (flag_unsafe_math_optimizations\n+\t  if (flag_reciprocal_math\n \t      && 0 != (tem = const_binop (code, build_real (type, dconst1),\n \t\t\t\t\t  arg1, 0)))\n \t    return fold_build2 (MULT_EXPR, type, arg0, tem);\n@@ -10984,23 +10993,23 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t}\n \t    }\n \t}\n-      /* Convert A/B/C to A/(B*C).  */\n-      if (flag_unsafe_math_optimizations\n+      /* Convert A/B/C to A/(B*C).  */ \n+      if (flag_reciprocal_math\n \t  && TREE_CODE (arg0) == RDIV_EXPR)\n \treturn fold_build2 (RDIV_EXPR, type, TREE_OPERAND (arg0, 0),\n \t\t\t    fold_build2 (MULT_EXPR, type,\n \t\t\t\t\t TREE_OPERAND (arg0, 1), arg1));\n \n       /* Convert A/(B/C) to (A/B)*C.  */\n-      if (flag_unsafe_math_optimizations\n+      if (flag_reciprocal_math\n \t  && TREE_CODE (arg1) == RDIV_EXPR)\n \treturn fold_build2 (MULT_EXPR, type,\n \t\t\t    fold_build2 (RDIV_EXPR, type, arg0,\n \t\t\t\t\t TREE_OPERAND (arg1, 0)),\n \t\t\t    TREE_OPERAND (arg1, 1));\n \n       /* Convert C1/(X*C2) into (C1/C2)/X.  */\n-      if (flag_unsafe_math_optimizations\n+      if (flag_reciprocal_math\n \t  && TREE_CODE (arg1) == MULT_EXPR\n \t  && TREE_CODE (arg0) == REAL_CST\n \t  && TREE_CODE (TREE_OPERAND (arg1, 1)) == REAL_CST)"}, {"sha": "e57e8e665b24fbeea9965e5c6afde9687c1413c2", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -1631,7 +1631,7 @@ analyze_insn_to_expand_var (struct loop *loop, rtx insn)\n   mode2 = GET_MODE (something);\n   if ((FLOAT_MODE_P (mode1) \n        || FLOAT_MODE_P (mode2)) \n-      && !flag_unsafe_math_optimizations) \n+      && !flag_associative_math) \n     return NULL;\n \n   if (dump_file)"}, {"sha": "735f942a8831c5d874251d1190603ec68727e05a", "filename": "gcc/opts.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -1559,6 +1559,10 @@ common_handle_option (size_t scode, const char *arg, int value,\n       set_fast_math_flags (value);\n       break;\n \n+    case OPT_funsafe_math_optimizations:\n+      set_unsafe_math_optimizations_flags (value);\n+      break;\n+\n     case OPT_ffixed_:\n       fix_register (arg, 1, 1);\n       break;\n@@ -1857,6 +1861,8 @@ set_fast_math_flags (int set)\n {\n   flag_trapping_math = !set;\n   flag_unsafe_math_optimizations = set;\n+  flag_associative_math = set;\n+  flag_reciprocal_math = set;\n   flag_finite_math_only = set;\n   flag_signed_zeros = !set;\n   flag_errno_math = !set;\n@@ -1868,6 +1874,15 @@ set_fast_math_flags (int set)\n     }\n }\n \n+/* When -funsafe-math-optimizations is set the following \n+   flags are set as well.  */ \n+void\n+set_unsafe_math_optimizations_flags (int set)\n+{\n+  flag_reciprocal_math = set;\n+  flag_associative_math = set;\n+}\n+\n /* Return true iff flags are set as if -ffast-math.  */\n bool\n fast_math_flags_set_p (void)"}, {"sha": "ac91f2fc92aba9c3d269d8cd29237c0baf1ebc23", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -1723,9 +1723,9 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \treturn tem;\n \n       /* Reassociate floating point addition only when the user\n-\t specifies unsafe math optimizations.  */\n+\t specifies associative math operations.  */\n       if (FLOAT_MODE_P (mode)\n-\t  && flag_unsafe_math_optimizations)\n+\t  && flag_associative_math)\n \t{\n \t  tem = simplify_associative_operation (code, mode, op0, op1);\n \t  if (tem)\n@@ -2480,8 +2480,8 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t\treturn simplify_gen_unary (NEG, mode, op0, mode);\n \n \t      /* Change FP division by a constant into multiplication.\n-\t\t Only do this with -funsafe-math-optimizations.  */\n-\t      if (flag_unsafe_math_optimizations\n+\t\t Only do this with -freciprocal-math.  */\n+\t      if (flag_reciprocal_math\n \t\t  && !REAL_VALUES_EQUAL (d, dconst0))\n \t\t{\n \t\t  REAL_ARITHMETIC (d, RDIV_EXPR, dconst1, d);"}, {"sha": "749cf308a9690aa765ce8362a5f77562e92ebbe3", "filename": "gcc/toplev.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -148,6 +148,8 @@ extern struct ht *ident_hash;\n \n extern void set_fast_math_flags         (int);\n \n+extern void set_unsafe_math_optimizations_flags (int);\n+\n /* Handle -d switch.  */\n extern void decode_d_option\t\t(const char *);\n "}, {"sha": "543169ad932598ea44910aece6d30d7c929e752e", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -443,7 +443,7 @@ execute_cse_reciprocals_1 (block_stmt_iterator *def_bsi, tree def)\n static bool\n gate_cse_reciprocals (void)\n {\n-  return optimize && !optimize_size && flag_unsafe_math_optimizations;\n+  return optimize && !optimize_size && flag_reciprocal_math;\n }\n \n /* Go through all the floating-point SSA_NAMEs, and call"}, {"sha": "f75437d0522911b52c59124492d173ba831ffed0", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -1244,14 +1244,14 @@ break_up_subtract_bb (basic_block bb)\n \t  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n \t  TREE_VISITED (stmt) = 0;\n-\t  /* If unsafe math optimizations we can do reassociation for\n+\t  /* If associative-math we can do reassociation for\n \t     non-integral types.  Or, we can do reassociation for\n \t     non-saturating fixed-point types.  */\n \t  if ((!INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n \t       || !INTEGRAL_TYPE_P (TREE_TYPE (rhs)))\n \t      && (!SCALAR_FLOAT_TYPE_P (TREE_TYPE (rhs))\n \t\t  || !SCALAR_FLOAT_TYPE_P (TREE_TYPE(lhs))\n-\t\t  || !flag_unsafe_math_optimizations)\n+\t\t  || !flag_associative_math)\n \t      && (!NON_SAT_FIXED_POINT_TYPE_P (TREE_TYPE (rhs))\n \t\t  || !NON_SAT_FIXED_POINT_TYPE_P (TREE_TYPE(lhs))))\n \t    continue;\n@@ -1294,14 +1294,14 @@ reassociate_bb (basic_block bb)\n \t  if (TREE_VISITED (stmt))\n \t    continue;\n \n-\t  /* If unsafe math optimizations we can do reassociation for\n+\t  /* If associative-math we can do reassociation for\n \t     non-integral types.  Or, we can do reassociation for\n \t     non-saturating fixed-point types.  */\n \t  if ((!INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n \t       || !INTEGRAL_TYPE_P (TREE_TYPE (rhs)))\n \t      && (!SCALAR_FLOAT_TYPE_P (TREE_TYPE (rhs))\n \t\t  || !SCALAR_FLOAT_TYPE_P (TREE_TYPE(lhs))\n-\t\t  || !flag_unsafe_math_optimizations)\n+\t\t  || !flag_associative_math)\n \t      && (!NON_SAT_FIXED_POINT_TYPE_P (TREE_TYPE (rhs))\n \t\t  || !NON_SAT_FIXED_POINT_TYPE_P (TREE_TYPE(lhs))))\n \t    continue;"}, {"sha": "8651b60fc0d8f4de77cb7cf0eba16357d6a0796d", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -297,7 +297,7 @@ process_assignment (tree ass, tree stmt, block_stmt_iterator call, tree *m,\n   /* Accumulator optimizations will reverse the order of operations.\n      We can only do that for floating-point types if we're assuming\n      that addition and multiplication are associative.  */\n-  if (!flag_unsafe_math_optimizations)\n+  if (!flag_associative_math)\n     if (FLOAT_TYPE_P (TREE_TYPE (DECL_RESULT (current_function_decl))))\n       return false;\n "}, {"sha": "c239d296316ad2ba5dab3dd7cc1fcc22e3153f22", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a826110720eda37c73f829daa4ee243ee953f5/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=a1a826110720eda37c73f829daa4ee243ee953f5", "patch": "@@ -2304,7 +2304,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, tree phi)\n      outer-loop vectorization is safe.  */\n \n   /* CHECKME: check for !flag_finite_math_only too?  */\n-  if (SCALAR_FLOAT_TYPE_P (type) && !flag_unsafe_math_optimizations\n+  if (SCALAR_FLOAT_TYPE_P (type) && !flag_associative_math\n       && !nested_in_vect_loop_p (vect_loop, def_stmt)) \n     {\n       /* Changing the order of operations changes the semantics.  */"}]}