{"sha": "0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJlOGJkMWExYzg5YzY3MGI2YzMyNWU0ODk2YzZjZmQzYjk3ZmUxZA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2012-07-07T16:38:46Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2012-07-07T16:38:46Z"}, "message": "arm.h (TARGET_CPU_CPP_BUILTINS): Remove Maverick support.\n\n\t* arm.h (TARGET_CPU_CPP_BUILTINS): Remove Maverick support.\n\t(TARGET_FPA): Delete definition.\n\t(TARGET_MAVERICK): Likewise.\n\t(TARGET_FPA_EMU2): Likewise.\n\t(arm_fp_model): Remove FPA and Maverick models.\n\t(arm_arch_cirrus): Delete declaration.\n\t(FLOAT_WORDS_BIG_ENDIAN): Delete definition.\n\t(FIXED_REGISTERS): Remove FPA and Maverick support.  Reorganize.\n\t(CALL_USED_REGISTERS): Likewise.\n\t(FIRST_FPA_REGNUM, LAST_FPA_REGNUM): Delete definition.\n\t(FIRST_VFP_REGNUM): Renumbered.\n\t(D7_VFP_REGNUM): Chain definition.\n\t(LAST_LO_VFP_REGNUM): Likewise.\n\t(FIRST_HI_VFP_REGNUM): Likewise.\n\t(LAST_HI_VFP_REGNUM): Likewise.\n\t(FIRST_IWMMXT_GR_REGNUM): Likewise.\n\t(LAST_IWMMXT_GR_REGNUM): Likewise.\n\t(FIRST_IWMMXT_REGNUM): Likewise.\n\t(LAST_IWMMXT_REGNUM): Likewise.\n\t(FRAME_POINTER_REGNUM): Renumbered.\n\t(ARG_POINTER_REGNUM): Renumbered.\n\t(FIRST_PSEUDO_REGISTER): Remove FPA and Maverick registers.\n\t(FIRST_CIRRUS_FP_REGNUM, LAST_CIRRUS_FP_REGNUM): Delete definitions.\n\t(HARD_REGNO_REGNUM): Remove FPA support.\n\t(REG_ALLOC_ORDER): Remove FPA and Maverick registers.  Reorganize.\n\t(reg_class): Likewise.\n\t(REG_CLASS_NAMES): Likewise.\n\t(REG_CLASS_CONTENTS): Likewise.\n\t(CANNOT_CHANGE_MODE_CLASS): Never true.  Update comment.\n\t(SECONDARY_INPUT_RELOAD_CLASS): Remove Maverick support.\n\t(CLASS_MAX_NREGS): Remove FPA and Maverick support.\n\t* aout.h (REGISTER_NAMES): Remove FPA and Maverick registers.\n\tReorganize.  Use AAPCS preferred names.\n\t(ADDITIONAL_REGISTER_NAMES): Remove aliases for Maverick.  Update\n\tcomments.\n\t(OVERLAPPING_REGISTER_NAMES): Update register numbering.\n\t* arm.c (FL_CIRRUS): Delete definition.\n\t(arm_arch_cirrus): Delete variable.\n\t(arm_float_words_big_endian): Delete function.\n\t(cirrus_memory_offset): Delete function.\n\t(output_mov_long_double_fpa_from_arm): Delete function.\n\t(output_mov_long_double_arm_from_fpa): Delete function.\n\t(output_mov_double_fpa_from_arm): Delete function.\n\t(output_mov_double_arm_from_fpa): Delete function.\n\t(emit_sfm): Delete function.\n\t(maybe_get_arm_condition_code): Update comment.\n\t(arm_file_start): Always use softvfp for softfloat systems.\n\t(thumb_core_reg_alloc_order): Adjust for updated register allocation.\n\t(arm_option_override): Remove FPA and Maverick support.  Always\n\tdefault to vfp as the fallback FPU format.\n\t(use_return_insn): Remove FPA support.\n\t(arm_get_frame_offsets): Likewise.\n\t(arm_save_coproc_regs): Likewise.\n\t(arm_canonicalize_comparison): Remove Maverick support.\n\t(arm_select_cc_mode): Likewise.\n\t(arm_gen_compare_reg): Likewise.\n\t(arm_print_operand): Likewise.\n\t(arm_libcall_value_1): Remove FPA and Maverick support.\n\t(arm_function_value_regno_p): Likewise.\n\t(arm_apply_result_size): Likewise.\n\t(arm_legitimate_index_p): Likewise.\n\t(thumb2_legitimate_index_p): Likewise.\n\t(legitimize_reload_address): Likewise.\n\t(arm_register_move_cost): Likewise.\n\t(arm_hard_regno_mode_ok): Likewise.\n\t(arm_regno_class): Likewise.\n\t(arm_dbx_register_number): Likewise.\n\t(arm_emit_unwind_sequence): Likewise.\n\t(arm_conditional_register_usage): Likewise.\n\t* arm-protos.h (neg_const_double_rtx_ok_for_fpa): Remove declaration.\n\t(cirrus_memory_offset): Likewise.\n\t(output_move_long_double_fpa_from_arm): Likewise.\n\t(output_move_long_double_arm_from_fpa): Likewise.\n\t(output_move_double_fpa_from_arm): Likewise.\n\t(output_move_double_arm_from_fpa): Likewise.\n\t(arm_float_words_big_endian): Likewise.\n\t* arm.md (CC_REGNUM): Renumbered.\n\t(VFPCC_REGNUM): Moved here.  Renumbered.\n\t(FPA_F0_REGNUM, FPA_F7_REGNUM): Delete.\n\t(attr fpu): Remove FPA and Maverick support.\n\t* vfp.md (VFPCC_REGNUM): Delete.  Moved to arm.md.\n\t* arm-cores.def (ep9312): Remove Maverick support.\n\t* arm-arches.def (ep9312): Delete architecture.\n\t* arm-tables.opt: Regenerated.\n\n\t* arm/linux-elf.h (FPUTYPE_DEFAULT): Set to vfp.\n\nFrom-SVN: r189350", "tree": {"sha": "d3b76be704bca069331b26bd9847c4e652355618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3b76be704bca069331b26bd9847c4e652355618"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/comments", "author": null, "committer": null, "parents": [{"sha": "8166ff4df037abbada1ca6e4c417d10fee5fe36f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8166ff4df037abbada1ca6e4c417d10fee5fe36f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8166ff4df037abbada1ca6e4c417d10fee5fe36f"}], "stats": {"total": 1156, "additions": 343, "deletions": 813}, "files": [{"sha": "bae00c6ba3f6ca5b141df48e1e074b7cd51b5ceb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "patch": "@@ -1,3 +1,92 @@\n+2012-07-07  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.h (TARGET_CPU_CPP_BUILTINS): Remove Maverick support.\n+\t(TARGET_FPA): Delete definition.\n+\t(TARGET_MAVERICK): Likewise.\n+\t(TARGET_FPA_EMU2): Likewise.\n+\t(arm_fp_model): Remove FPA and Maverick models.\n+\t(arm_arch_cirrus): Delete declaration.\n+\t(FLOAT_WORDS_BIG_ENDIAN): Delete definition.\n+\t(FIXED_REGISTERS): Remove FPA and Maverick support.  Reorganize.\n+\t(CALL_USED_REGISTERS): Likewise.\n+\t(FIRST_FPA_REGNUM, LAST_FPA_REGNUM): Delete definition.\n+\t(FIRST_VFP_REGNUM): Renumbered.\n+\t(D7_VFP_REGNUM): Chain definition.\n+\t(LAST_LO_VFP_REGNUM): Likewise.\n+\t(FIRST_HI_VFP_REGNUM): Likewise.\n+\t(LAST_HI_VFP_REGNUM): Likewise.\n+\t(FIRST_IWMMXT_GR_REGNUM): Likewise.\n+\t(LAST_IWMMXT_GR_REGNUM): Likewise.\n+\t(FIRST_IWMMXT_REGNUM): Likewise.\n+\t(LAST_IWMMXT_REGNUM): Likewise.\n+\t(FRAME_POINTER_REGNUM): Renumbered.\n+\t(ARG_POINTER_REGNUM): Renumbered.\n+\t(FIRST_PSEUDO_REGISTER): Remove FPA and Maverick registers.\n+\t(FIRST_CIRRUS_FP_REGNUM, LAST_CIRRUS_FP_REGNUM): Delete definitions.\n+\t(HARD_REGNO_REGNUM): Remove FPA support.\n+\t(REG_ALLOC_ORDER): Remove FPA and Maverick registers.  Reorganize.\n+\t(reg_class): Likewise.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(CANNOT_CHANGE_MODE_CLASS): Never true.  Update comment.\n+\t(SECONDARY_INPUT_RELOAD_CLASS): Remove Maverick support.\n+\t(CLASS_MAX_NREGS): Remove FPA and Maverick support.\n+\t* aout.h (REGISTER_NAMES): Remove FPA and Maverick registers.\n+\tReorganize.  Use AAPCS preferred names.\n+\t(ADDITIONAL_REGISTER_NAMES): Remove aliases for Maverick.  Update\n+\tcomments.\n+\t(OVERLAPPING_REGISTER_NAMES): Update register numbering.\n+\t* arm.c (FL_CIRRUS): Delete definition.\n+\t(arm_arch_cirrus): Delete variable.\n+\t(arm_float_words_big_endian): Delete function.\n+\t(cirrus_memory_offset): Delete function.\n+\t(output_mov_long_double_fpa_from_arm): Delete function.\n+\t(output_mov_long_double_arm_from_fpa): Delete function.\n+\t(output_mov_double_fpa_from_arm): Delete function.\n+\t(output_mov_double_arm_from_fpa): Delete function.\n+\t(emit_sfm): Delete function.\n+\t(maybe_get_arm_condition_code): Update comment.\n+\t(arm_file_start): Always use softvfp for softfloat systems.\n+\t(thumb_core_reg_alloc_order): Adjust for updated register allocation.\n+\t(arm_option_override): Remove FPA and Maverick support.  Always\n+\tdefault to vfp as the fallback FPU format.\n+\t(use_return_insn): Remove FPA support.\n+\t(arm_get_frame_offsets): Likewise.\n+\t(arm_save_coproc_regs): Likewise.\n+\t(arm_canonicalize_comparison): Remove Maverick support.\n+\t(arm_select_cc_mode): Likewise.\n+\t(arm_gen_compare_reg): Likewise.\n+\t(arm_print_operand): Likewise.\n+\t(arm_libcall_value_1): Remove FPA and Maverick support.\n+\t(arm_function_value_regno_p): Likewise.\n+\t(arm_apply_result_size): Likewise.\n+\t(arm_legitimate_index_p): Likewise.\n+\t(thumb2_legitimate_index_p): Likewise.\n+\t(legitimize_reload_address): Likewise.\n+\t(arm_register_move_cost): Likewise.\n+\t(arm_hard_regno_mode_ok): Likewise.\n+\t(arm_regno_class): Likewise.\n+\t(arm_dbx_register_number): Likewise.\n+\t(arm_emit_unwind_sequence): Likewise.\n+\t(arm_conditional_register_usage): Likewise.\n+\t* arm-protos.h (neg_const_double_rtx_ok_for_fpa): Remove declaration.\n+\t(cirrus_memory_offset): Likewise.\n+\t(output_move_long_double_fpa_from_arm): Likewise.\n+\t(output_move_long_double_arm_from_fpa): Likewise.\n+\t(output_move_double_fpa_from_arm): Likewise.\n+\t(output_move_double_arm_from_fpa): Likewise.\n+\t(arm_float_words_big_endian): Likewise.\n+\t* arm.md (CC_REGNUM): Renumbered.\n+\t(VFPCC_REGNUM): Moved here.  Renumbered.\n+\t(FPA_F0_REGNUM, FPA_F7_REGNUM): Delete.\n+\t(attr fpu): Remove FPA and Maverick support.\n+\t* vfp.md (VFPCC_REGNUM): Delete.  Moved to arm.md.\n+\t* arm-cores.def (ep9312): Remove Maverick support.\n+\t* arm-arches.def (ep9312): Delete architecture.\n+\t* arm-tables.opt: Regenerated.\n+\n+\t* arm/linux-elf.h (FPUTYPE_DEFAULT): Set to vfp.\n+\n 2012-07-07  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR tree-optimization/53881"}, {"sha": "0be3de3f006afc0fd4aecdea118198afcbdedf57", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 54, "deletions": 124, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "patch": "@@ -51,30 +51,24 @@\n    (each of which is overlaid on two S registers), although there are no\n    actual single-precision registers which correspond to D16-D31.  */\n #ifndef REGISTER_NAMES\n-#define REGISTER_NAMES\t\t\t\t   \\\n-{\t\t\t\t                   \\\n-  \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",  \\\n-  \"r8\", \"r9\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\",  \\\n-  \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\",  \\\n-  \"cc\", \"sfp\", \"afp\",\t\t   \t\t   \\\n-  \"mv0\",   \"mv1\",   \"mv2\",   \"mv3\",\t\t   \\\n-  \"mv4\",   \"mv5\",   \"mv6\",   \"mv7\",\t\t   \\\n-  \"mv8\",   \"mv9\",   \"mv10\",  \"mv11\",\t\t   \\\n-  \"mv12\",  \"mv13\",  \"mv14\",  \"mv15\",\t\t   \\\n-  \"wcgr0\", \"wcgr1\", \"wcgr2\", \"wcgr3\",\t\t   \\\n-  \"wr0\",   \"wr1\",   \"wr2\",   \"wr3\",\t\t   \\\n-  \"wr4\",   \"wr5\",   \"wr6\",   \"wr7\",\t\t   \\\n-  \"wr8\",   \"wr9\",   \"wr10\",  \"wr11\",\t\t   \\\n-  \"wr12\",  \"wr13\",  \"wr14\",  \"wr15\",\t\t   \\\n-  \"s0\",  \"s1\",  \"s2\",  \"s3\",  \"s4\",  \"s5\",  \"s6\",  \"s7\",  \\\n-  \"s8\",  \"s9\",  \"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\", \\\n-  \"s16\", \"s17\", \"s18\", \"s19\", \"s20\", \"s21\", \"s22\", \"s23\", \\\n-  \"s24\", \"s25\", \"s26\", \"s27\", \"s28\", \"s29\", \"s30\", \"s31\", \\\n-  \"d16\", \"?16\", \"d17\", \"?17\", \"d18\", \"?18\", \"d19\", \"?19\", \\\n-  \"d20\", \"?20\", \"d21\", \"?21\", \"d22\", \"?22\", \"d23\", \"?23\", \\\n-  \"d24\", \"?24\", \"d25\", \"?25\", \"d26\", \"?26\", \"d27\", \"?27\", \\\n-  \"d28\", \"?28\", \"d29\", \"?29\", \"d30\", \"?30\", \"d31\", \"?31\", \\\n-  \"vfpcc\"\t\t\t\t\t   \\\n+#define REGISTER_NAMES\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\t\t\\\n+  \"r8\", \"r9\", \"r10\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\",\t\t\\\n+  \"s0\",  \"s1\",  \"s2\",  \"s3\",  \"s4\",  \"s5\",  \"s6\",  \"s7\",\t\\\n+  \"s8\",  \"s9\",  \"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\",\t\\\n+  \"s16\", \"s17\", \"s18\", \"s19\", \"s20\", \"s21\", \"s22\", \"s23\",\t\\\n+  \"s24\", \"s25\", \"s26\", \"s27\", \"s28\", \"s29\", \"s30\", \"s31\",\t\\\n+  \"d16\", \"?16\", \"d17\", \"?17\", \"d18\", \"?18\", \"d19\", \"?19\",\t\\\n+  \"d20\", \"?20\", \"d21\", \"?21\", \"d22\", \"?22\", \"d23\", \"?23\",\t\\\n+  \"d24\", \"?24\", \"d25\", \"?25\", \"d26\", \"?26\", \"d27\", \"?27\",\t\\\n+  \"d28\", \"?28\", \"d29\", \"?29\", \"d30\", \"?30\", \"d31\", \"?31\",\t\\\n+  \"wr0\",   \"wr1\",   \"wr2\",   \"wr3\",\t\t\t\t\\\n+  \"wr4\",   \"wr5\",   \"wr6\",   \"wr7\",\t\t\t\t\\\n+  \"wr8\",   \"wr9\",   \"wr10\",  \"wr11\",\t\t\t\t\\\n+  \"wr12\",  \"wr13\",  \"wr14\",  \"wr15\",\t\t\t\t\\\n+  \"wcgr0\", \"wcgr1\", \"wcgr2\", \"wcgr3\",\t\t\t\t\\\n+  \"cc\", \"vfpcc\", \"sfp\", \"afp\"\t\t\t\t\t\\\n }\n #endif\n \n@@ -91,117 +85,53 @@\n   {\"v4\", 7},\t\t\t\t\t\\\n   {\"v5\", 8},\t\t\t\t\t\\\n   {\"v6\", 9},\t\t\t\t\t\\\n-  {\"rfp\", 9}, /* Gcc used to call it this */\t\\\n-  {\"sb\", 9},\t\t\t\t\t\\\n+  {\"rfp\", 9}, /* Historical.  */\t\t\\\n+  {\"sb\", 9}, /* Historical.  */\t\t\t\\\n   {\"v7\", 10},\t\t\t\t\t\\\n-  {\"r10\", 10},\t/* sl */\t\t\t\\\n+  {\"sl\", 10},\t/* Historical.  */\t\t\\\n   {\"r11\", 11},\t/* fp */\t\t\t\\\n   {\"r12\", 12},\t/* ip */\t\t\t\\\n   {\"r13\", 13},\t/* sp */\t\t\t\\\n   {\"r14\", 14},\t/* lr */\t\t\t\\\n-  {\"r15\", 15},\t/* pc */\t\t\t\\\n-  {\"mvf0\", 27},\t\t\t\t\t\\\n-  {\"mvf1\", 28},\t\t\t\t\t\\\n-  {\"mvf2\", 29},\t\t\t\t\t\\\n-  {\"mvf3\", 30},\t\t\t\t\t\\\n-  {\"mvf4\", 31},\t\t\t\t\t\\\n-  {\"mvf5\", 32},\t\t\t\t\t\\\n-  {\"mvf6\", 33},\t\t\t\t\t\\\n-  {\"mvf7\", 34},\t\t\t\t\t\\\n-  {\"mvf8\", 35},\t\t\t\t\t\\\n-  {\"mvf9\", 36},\t\t\t\t\t\\\n-  {\"mvf10\", 37},\t\t\t\t\\\n-  {\"mvf11\", 38},\t\t\t\t\\\n-  {\"mvf12\", 39},\t\t\t\t\\\n-  {\"mvf13\", 40},\t\t\t\t\\\n-  {\"mvf14\", 41},\t\t\t\t\\\n-  {\"mvf15\", 42},\t\t\t\t\\\n-  {\"mvd0\", 27},\t\t\t\t\t\\\n-  {\"mvd1\", 28},\t\t\t\t\t\\\n-  {\"mvd2\", 29},\t\t\t\t\t\\\n-  {\"mvd3\", 30},\t\t\t\t\t\\\n-  {\"mvd4\", 31},\t\t\t\t\t\\\n-  {\"mvd5\", 32},\t\t\t\t\t\\\n-  {\"mvd6\", 33},\t\t\t\t\t\\\n-  {\"mvd7\", 34},\t\t\t\t\t\\\n-  {\"mvd8\", 35},\t\t\t\t\t\\\n-  {\"mvd9\", 36},\t\t\t\t\t\\\n-  {\"mvd10\", 37},\t\t\t\t\\\n-  {\"mvd11\", 38},\t\t\t\t\\\n-  {\"mvd12\", 39},\t\t\t\t\\\n-  {\"mvd13\", 40},\t\t\t\t\\\n-  {\"mvd14\", 41},\t\t\t\t\\\n-  {\"mvd15\", 42},\t\t\t\t\\\n-  {\"mvfx0\", 27},\t\t\t\t\\\n-  {\"mvfx1\", 28},\t\t\t\t\\\n-  {\"mvfx2\", 29},\t\t\t\t\\\n-  {\"mvfx3\", 30},\t\t\t\t\\\n-  {\"mvfx4\", 31},\t\t\t\t\\\n-  {\"mvfx5\", 32},\t\t\t\t\\\n-  {\"mvfx6\", 33},\t\t\t\t\\\n-  {\"mvfx7\", 34},\t\t\t\t\\\n-  {\"mvfx8\", 35},\t\t\t\t\\\n-  {\"mvfx9\", 36},\t\t\t\t\\\n-  {\"mvfx10\", 37},\t\t\t\t\\\n-  {\"mvfx11\", 38},\t\t\t\t\\\n-  {\"mvfx12\", 39},\t\t\t\t\\\n-  {\"mvfx13\", 40},\t\t\t\t\\\n-  {\"mvfx14\", 41},\t\t\t\t\\\n-  {\"mvfx15\", 42},\t\t\t\t\\\n-  {\"mvdx0\", 27},\t\t\t\t\\\n-  {\"mvdx1\", 28},\t\t\t\t\\\n-  {\"mvdx2\", 29},\t\t\t\t\\\n-  {\"mvdx3\", 30},\t\t\t\t\\\n-  {\"mvdx4\", 31},\t\t\t\t\\\n-  {\"mvdx5\", 32},\t\t\t\t\\\n-  {\"mvdx6\", 33},\t\t\t\t\\\n-  {\"mvdx7\", 34},\t\t\t\t\\\n-  {\"mvdx8\", 35},\t\t\t\t\\\n-  {\"mvdx9\", 36},\t\t\t\t\\\n-  {\"mvdx10\", 37},\t\t\t\t\\\n-  {\"mvdx11\", 38},\t\t\t\t\\\n-  {\"mvdx12\", 39},\t\t\t\t\\\n-  {\"mvdx13\", 40},\t\t\t\t\\\n-  {\"mvdx14\", 41},\t\t\t\t\\\n-  {\"mvdx15\", 42}\t\t\t\t\\\n+  {\"r15\", 15}\t/* pc */\t\t\t\\\n }\n #endif\n \n #ifndef OVERLAPPING_REGISTER_NAMES\n #define OVERLAPPING_REGISTER_NAMES\t\t\\\n {\t\t\t\t\t\t\\\n-  {\"d0\", 63, 2},\t\t\t\t\\\n-  {\"d1\", 65, 2},\t\t\t\t\\\n-  {\"d2\", 67, 2},\t\t\t\t\\\n-  {\"d3\", 69, 2},\t\t\t\t\\\n-  {\"d4\", 71, 2},\t\t\t\t\\\n-  {\"d5\", 73, 2},\t\t\t\t\\\n-  {\"d6\", 75, 2},\t\t\t\t\\\n-  {\"d7\", 77, 2},\t\t\t\t\\\n-  {\"d8\", 79, 2},\t\t\t\t\\\n-  {\"d9\", 81, 2},\t\t\t\t\\\n-  {\"d10\", 83, 2},\t\t\t\t\\\n-  {\"d11\", 85, 2},\t\t\t\t\\\n-  {\"d12\", 87, 2},\t\t\t\t\\\n-  {\"d13\", 89, 2},\t\t\t\t\\\n-  {\"d14\", 91, 2},\t\t\t\t\\\n-  {\"d15\", 93, 2},\t\t\t\t\\\n-  {\"q0\", 63, 4},\t\t\t\t\\\n-  {\"q1\", 67, 4},\t\t\t\t\\\n-  {\"q2\", 71, 4},\t\t\t\t\\\n-  {\"q3\", 75, 4},\t\t\t\t\\\n-  {\"q4\", 79, 4},\t\t\t\t\\\n-  {\"q5\", 83, 4},\t\t\t\t\\\n-  {\"q6\", 87, 4},\t\t\t\t\\\n-  {\"q7\", 91, 4},\t\t\t\t\\\n-  {\"q8\", 95, 4},\t\t\t\t\\\n-  {\"q9\", 99, 4},\t\t\t\t\\\n-  {\"q10\", 103, 4},\t\t\t\t\\\n-  {\"q11\", 107, 4},\t\t\t\t\\\n-  {\"q12\", 111, 4},\t\t\t\t\\\n-  {\"q13\", 115, 4},\t\t\t\t\\\n-  {\"q14\", 119, 4},\t\t\t\t\\\n-  {\"q15\", 123, 4}\t\t\t\t\\\n+  {\"d0\",  FIRST_VFP_REGNUM + 0,  2},\t\t\\\n+  {\"d1\",  FIRST_VFP_REGNUM + 2,  2},\t\t\\\n+  {\"d2\",  FIRST_VFP_REGNUM + 4,  2},\t\t\\\n+  {\"d3\",  FIRST_VFP_REGNUM + 6,  2},\t\t\\\n+  {\"d4\",  FIRST_VFP_REGNUM + 8,  2},\t\t\\\n+  {\"d5\",  FIRST_VFP_REGNUM + 10, 2},\t\t\\\n+  {\"d6\",  FIRST_VFP_REGNUM + 12, 2},\t\t\\\n+  {\"d7\",  FIRST_VFP_REGNUM + 14, 2},\t\t\\\n+  {\"d8\",  FIRST_VFP_REGNUM + 16, 2},\t\t\\\n+  {\"d9\",  FIRST_VFP_REGNUM + 18, 2},\t\t\\\n+  {\"d10\", FIRST_VFP_REGNUM + 20, 2},\t\t\\\n+  {\"d11\", FIRST_VFP_REGNUM + 22, 2},\t\t\\\n+  {\"d12\", FIRST_VFP_REGNUM + 24, 2},\t\t\\\n+  {\"d13\", FIRST_VFP_REGNUM + 26, 2},\t\t\\\n+  {\"d14\", FIRST_VFP_REGNUM + 28, 2},\t\t\\\n+  {\"d15\", FIRST_VFP_REGNUM + 30, 2},\t\t\\\n+  {\"q0\",  FIRST_VFP_REGNUM + 0,  4},\t\t\\\n+  {\"q1\",  FIRST_VFP_REGNUM + 4,  4},\t\t\\\n+  {\"q2\",  FIRST_VFP_REGNUM + 8,  4},\t\t\\\n+  {\"q3\",  FIRST_VFP_REGNUM + 12, 4},\t\t\\\n+  {\"q4\",  FIRST_VFP_REGNUM + 16, 4},\t\t\\\n+  {\"q5\",  FIRST_VFP_REGNUM + 20, 4},\t\t\\\n+  {\"q6\",  FIRST_VFP_REGNUM + 24, 4},\t\t\\\n+  {\"q7\",  FIRST_VFP_REGNUM + 28, 4},\t\t\\\n+  {\"q8\",  FIRST_VFP_REGNUM + 32, 4},\t\t\\\n+  {\"q9\",  FIRST_VFP_REGNUM + 36, 4},\t\t\\\n+  {\"q10\", FIRST_VFP_REGNUM + 40, 4},\t\t\\\n+  {\"q11\", FIRST_VFP_REGNUM + 44, 4},\t\t\\\n+  {\"q12\", FIRST_VFP_REGNUM + 48, 4},\t\t\\\n+  {\"q13\", FIRST_VFP_REGNUM + 52, 4},\t\t\\\n+  {\"q14\", FIRST_VFP_REGNUM + 56, 4},\t\t\\\n+  {\"q15\", FIRST_VFP_REGNUM + 60, 4}\t\t\\\n }\n #endif\n "}, {"sha": "f83639df83ba94f1f12460fce5c84410268b4c17", "filename": "gcc/config/arm/arm-arches.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm-arches.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm-arches.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-arches.def?ref=0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "patch": "@@ -55,6 +55,5 @@ ARM_ARCH(\"armv7-a\", cortexa8,\t7A,  FL_CO_PROC |\t      FL_FOR_ARCH7A)\n ARM_ARCH(\"armv7-r\", cortexr4,\t7R,  FL_CO_PROC |\t      FL_FOR_ARCH7R)\n ARM_ARCH(\"armv7-m\", cortexm3,\t7M,  FL_CO_PROC |\t      FL_FOR_ARCH7M)\n ARM_ARCH(\"armv7e-m\", cortexm4,  7EM, FL_CO_PROC |\t      FL_FOR_ARCH7EM)\n-ARM_ARCH(\"ep9312\",  ep9312,     4T,  FL_LDSCHED | FL_CIRRUS | FL_FOR_ARCH4)\n ARM_ARCH(\"iwmmxt\",  iwmmxt,     5TE, FL_LDSCHED | FL_STRONG | FL_FOR_ARCH5TE | FL_XSCALE | FL_IWMMXT)\n ARM_ARCH(\"iwmmxt2\", iwmmxt2,    5TE, FL_LDSCHED | FL_STRONG | FL_FOR_ARCH5TE | FL_XSCALE | FL_IWMMXT | FL_IWMMXT2)"}, {"sha": "223e41f4fbc3aa1e81557bb1a08079057cf5c031", "filename": "gcc/config/arm/arm-cores.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-cores.def?ref=0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "patch": "@@ -89,7 +89,7 @@ ARM_CORE(\"arm920\",        arm920,\t4T,\t                         FL_LDSCHED, fastm\n ARM_CORE(\"arm920t\",       arm920t,\t4T,\t                         FL_LDSCHED, fastmul)\n ARM_CORE(\"arm922t\",       arm922t,\t4T,\t                         FL_LDSCHED, fastmul)\n ARM_CORE(\"arm940t\",       arm940t,\t4T,\t                         FL_LDSCHED, fastmul)\n-ARM_CORE(\"ep9312\",        ep9312,\t4T,\t                         FL_LDSCHED |             FL_CIRRUS, fastmul)\n+ARM_CORE(\"ep9312\",        ep9312,\t4T,\t                         FL_LDSCHED, fastmul)\n \n /* V5T Architecture Processors */\n ARM_CORE(\"arm10tdmi\",     arm10tdmi,\t5T,\t                         FL_LDSCHED, fastmul)"}, {"sha": "eb77b72325d06696b00e6a55a29830fa2fe7d2ae", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "patch": "@@ -67,7 +67,6 @@ extern int thumb1_legitimate_address_p (enum machine_mode, rtx, int);\n extern bool ldm_stm_operation_p (rtx, bool, enum machine_mode mode,\n                                  bool, bool);\n extern int arm_const_double_rtx (rtx);\n-extern int neg_const_double_rtx_ok_for_fpa (rtx);\n extern int vfp3_const_double_rtx (rtx);\n extern int neon_immediate_valid_for_move (rtx, enum machine_mode, rtx *, int *);\n extern int neon_immediate_valid_for_logic (rtx, enum machine_mode, int, rtx *,\n@@ -95,7 +94,6 @@ extern enum reg_class coproc_secondary_reload_class (enum machine_mode, rtx,\n \t\t\t\t\t\t     bool);\n extern bool arm_tls_referenced_p (rtx);\n \n-extern int cirrus_memory_offset (rtx);\n extern int arm_coproc_mem_operand (rtx, bool);\n extern int neon_vector_mem_operand (rtx, int);\n extern int neon_struct_mem_operand (rtx);\n@@ -134,11 +132,7 @@ extern void arm_emit_call_insn (rtx, rtx);\n extern const char *output_call (rtx *);\n extern const char *output_call_mem (rtx *);\n void arm_emit_movpair (rtx, rtx);\n-extern const char *output_mov_long_double_fpa_from_arm (rtx *);\n-extern const char *output_mov_long_double_arm_from_fpa (rtx *);\n extern const char *output_mov_long_double_arm_from_arm (rtx *);\n-extern const char *output_mov_double_fpa_from_arm (rtx *);\n-extern const char *output_mov_double_arm_from_fpa (rtx *);\n extern const char *output_move_double (rtx *, bool, int *count);\n extern const char *output_move_quad (rtx *);\n extern int arm_count_output_move_double_insns (rtx *);\n@@ -179,8 +173,6 @@ extern int arm_apply_result_size (void);\n \n #endif /* RTX_CODE */\n \n-extern int arm_float_words_big_endian (void);\n-\n /* Thumb functions.  */\n extern void arm_init_expanders (void);\n extern const char *thumb1_unexpanded_epilogue (void);"}, {"sha": "5f9369553e041cd68f43b298f433ab4445c7d866", "filename": "gcc/config/arm/arm-tables.opt", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm-tables.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm-tables.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-tables.opt?ref=0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "patch": "@@ -347,13 +347,10 @@ EnumValue\n Enum(arm_arch) String(armv7e-m) Value(22)\n \n EnumValue\n-Enum(arm_arch) String(ep9312) Value(23)\n+Enum(arm_arch) String(iwmmxt) Value(23)\n \n EnumValue\n-Enum(arm_arch) String(iwmmxt) Value(24)\n-\n-EnumValue\n-Enum(arm_arch) String(iwmmxt2) Value(25)\n+Enum(arm_arch) String(iwmmxt2) Value(24)\n \n Enum\n Name(arm_fpu) Type(int)"}, {"sha": "0639beb5a0483e1aad3c1fc66374e6f54672d3c7", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 44, "deletions": 478, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "patch": "@@ -86,7 +86,6 @@ inline static int thumb1_index_register_rtx_p (rtx, int);\n static bool arm_legitimate_address_p (enum machine_mode, rtx, bool);\n static int thumb_far_jump_used_p (void);\n static bool thumb_force_lr_save (void);\n-static rtx emit_sfm (int, int);\n static unsigned arm_size_return_regs (void);\n static bool arm_assemble_integer (rtx, unsigned int, int);\n static void arm_print_operand (FILE *, rtx, int);\n@@ -661,7 +660,7 @@ static int thumb_call_reg_needed;\n #define FL_STRONG     (1 << 8)\t      /* StrongARM */\n #define FL_ARCH5E     (1 << 9)        /* DSP extensions to v5 */\n #define FL_XSCALE     (1 << 10)\t      /* XScale */\n-#define FL_CIRRUS     (1 << 11)\t      /* Cirrus/DSP.  */\n+/* spare\t      (1 << 11)\t*/\n #define FL_ARCH6      (1 << 12)       /* Architecture rel 6.  Adds\n \t\t\t\t\t media instructions.  */\n #define FL_VFPV2      (1 << 13)       /* Vector Floating Point V2.  */\n@@ -760,9 +759,6 @@ int arm_ld_sched = 0;\n /* Nonzero if this chip is a StrongARM.  */\n int arm_tune_strongarm = 0;\n \n-/* Nonzero if this chip is a Cirrus variant.  */\n-int arm_arch_cirrus = 0;\n-\n /* Nonzero if this chip supports Intel Wireless MMX technology.  */\n int arm_arch_iwmmxt = 0;\n \n@@ -1714,7 +1710,6 @@ arm_option_override (void)\n   arm_arch7em = (insn_flags & FL_ARCH7EM) != 0;\n   arm_arch_thumb2 = (insn_flags & FL_THUMB2) != 0;\n   arm_arch_xscale = (insn_flags & FL_XSCALE) != 0;\n-  arm_arch_cirrus = (insn_flags & FL_CIRRUS) != 0;\n \n   arm_ld_sched = (tune_flags & FL_LDSCHED) != 0;\n   arm_tune_strongarm = (tune_flags & FL_STRONG) != 0;\n@@ -1774,10 +1769,7 @@ arm_option_override (void)\n #ifdef FPUTYPE_DEFAULT\n       target_fpu_name = FPUTYPE_DEFAULT;\n #else\n-      if (arm_arch_cirrus)\n-\ttarget_fpu_name = \"maverick\";\n-      else\n-\ttarget_fpu_name = \"fpe2\";\n+      target_fpu_name = \"vfp\";\n #endif\n \n       ok = opt_enum_arg_to_value (OPT_mfpu_, target_fpu_name, &arm_fpu_index,\n@@ -1789,19 +1781,6 @@ arm_option_override (void)\n \n   switch (arm_fpu_desc->model)\n     {\n-    case ARM_FP_MODEL_FPA:\n-      if (arm_fpu_desc->rev == 2)\n-\tarm_fpu_attr = FPU_FPE2;\n-      else if (arm_fpu_desc->rev == 3)\n-\tarm_fpu_attr = FPU_FPE3;\n-      else\n-\tarm_fpu_attr = FPU_FPA;\n-      break;\n-\n-    case ARM_FP_MODEL_MAVERICK:\n-      arm_fpu_attr = FPU_MAVERICK;\n-      break;\n-\n     case ARM_FP_MODEL_VFP:\n       arm_fpu_attr = FPU_VFP;\n       break;\n@@ -1810,10 +1789,6 @@ arm_option_override (void)\n       gcc_unreachable();\n     }\n \n-  if (TARGET_AAPCS_BASED\n-      && (arm_fpu_desc->model == ARM_FP_MODEL_FPA))\n-    error (\"FPA is unsupported in the AAPCS\");\n-\n   if (TARGET_AAPCS_BASED)\n     {\n       if (TARGET_CALLER_INTERWORKING)\n@@ -1823,11 +1798,6 @@ arm_option_override (void)\n \t  error (\"AAPCS does not support -mcallee-super-interworking\");\n     }\n \n-  /* FPA and iWMMXt are incompatible because the insn encodings overlap.\n-     VFP and iWMMXt however can coexist.  */\n-  if (TARGET_IWMMXT && TARGET_HARD_FLOAT && !TARGET_VFP)\n-    error (\"iWMMXt and non-VFP floating point unit are incompatible\");\n-\n   /* iWMMXt and NEON are incompatible.  */\n   if (TARGET_IWMMXT && TARGET_NEON)\n     error (\"iWMMXt and NEON are incompatible\");\n@@ -1866,11 +1836,9 @@ arm_option_override (void)\n \tarm_pcs_default = ARM_PCS_ATPCS;\n     }\n \n-  /* For arm2/3 there is no need to do any scheduling if there is only\n-     a floating point emulator, or we are doing software floating-point.  */\n-  if ((TARGET_SOFT_FLOAT\n-       || (TARGET_FPA && arm_fpu_desc->rev))\n-      && (tune_flags & FL_MODE32) == 0)\n+  /* For arm2/3 there is no need to do any scheduling if we are doing\n+     software floating-point.  */\n+  if (TARGET_SOFT_FLOAT && (tune_flags & FL_MODE32) == 0)\n     flag_schedule_insns = flag_schedule_insns_after_reload = 0;\n \n   /* Use the cp15 method if it is available.  */\n@@ -2362,14 +2330,8 @@ use_return_insn (int iscond, rtx sibling)\n   if (saved_int_regs && !(saved_int_regs & (1 << LR_REGNUM)))\n     return 0;\n \n-  /* Can't be done if any of the FPA regs are pushed,\n+  /* Can't be done if any of the VFP regs are pushed,\n      since this also requires an insn.  */\n-  if (TARGET_HARD_FLOAT && TARGET_FPA)\n-    for (regno = FIRST_FPA_REGNUM; regno <= LAST_FPA_REGNUM; regno++)\n-      if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n-\treturn 0;\n-\n-  /* Likewise VFP regs.  */\n   if (TARGET_HARD_FLOAT && TARGET_VFP)\n     for (regno = FIRST_VFP_REGNUM; regno <= LAST_VFP_REGNUM; regno++)\n       if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n@@ -3494,11 +3456,6 @@ arm_canonicalize_comparison (enum rtx_code code, rtx *op0, rtx *op1)\n     {\n       rtx tem;\n \n-      /* To keep things simple, always use the Cirrus cfcmp64 if it is\n-\t available.  */\n-      if (TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK)\n-\treturn code;\n-\n       if (code == GT || code == LE\n \t  || (!TARGET_ARM && (code == GTU || code == LEU)))\n \t{\n@@ -3748,16 +3705,6 @@ arm_libcall_value_1 (enum machine_mode mode)\n {\n   if (TARGET_AAPCS_BASED)\n     return aapcs_libcall_value (mode);\n-  else if (TARGET_32BIT\n-\t   && TARGET_HARD_FLOAT_ABI\n-\t   && TARGET_FPA\n-\t   && GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    return gen_rtx_REG (mode, FIRST_FPA_REGNUM);\n-  else if (TARGET_32BIT\n-\t   && TARGET_HARD_FLOAT_ABI\n-\t   && TARGET_MAVERICK\n-\t   && GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    return gen_rtx_REG (mode, FIRST_CIRRUS_FP_REGNUM);\n   else if (TARGET_IWMMXT_ABI\n \t   && arm_vector_mode_supported_p (mode))\n     return gen_rtx_REG (mode, FIRST_IWMMXT_REGNUM);\n@@ -3795,16 +3742,8 @@ arm_function_value_regno_p (const unsigned int regno)\n \t  && TARGET_VFP\n \t  && TARGET_HARD_FLOAT\n \t  && regno == FIRST_VFP_REGNUM)\n-      || (TARGET_32BIT\n-\t  && TARGET_HARD_FLOAT_ABI\n-\t  && TARGET_MAVERICK\n-\t  && regno == FIRST_CIRRUS_FP_REGNUM)\n       || (TARGET_IWMMXT_ABI\n-\t  && regno == FIRST_IWMMXT_REGNUM)\n-      || (TARGET_32BIT\n-\t  && TARGET_HARD_FLOAT_ABI\n-\t  && TARGET_FPA\n-\t  && regno == FIRST_FPA_REGNUM))\n+\t  && regno == FIRST_IWMMXT_REGNUM))\n     return true;\n \n   return false;\n@@ -3819,15 +3758,8 @@ arm_apply_result_size (void)\n \n   if (TARGET_32BIT)\n     {\n-      if (TARGET_HARD_FLOAT_ABI)\n-\t{\n-\t  if (TARGET_VFP)\n-\t    size += 32;\n-\t  if (TARGET_FPA)\n-\t    size += 12;\n-\t  if (TARGET_MAVERICK)\n-\t    size += 8;\n-\t}\n+      if (TARGET_HARD_FLOAT_ABI && TARGET_VFP)\n+\tsize += 32;\n       if (TARGET_IWMMXT_ABI)\n \tsize += 8;\n     }\n@@ -3978,28 +3910,6 @@ arm_return_in_memory (const_tree type, const_tree fntype)\n   return true;\n }\n \n-/* Indicate whether or not words of a double are in big-endian order.  */\n-\n-int\n-arm_float_words_big_endian (void)\n-{\n-  if (TARGET_MAVERICK)\n-    return 0;\n-\n-  /* For FPA, float words are always big-endian.  For VFP, floats words\n-     follow the memory system mode.  */\n-\n-  if (TARGET_FPA)\n-    {\n-      return 1;\n-    }\n-\n-  if (TARGET_VFP)\n-    return (TARGET_BIG_END ? 1 : 0);\n-\n-  return 1;\n-}\n-\n const struct pcs_attribute_arg\n {\n   const char *arg;\n@@ -5879,9 +5789,8 @@ arm_legitimate_index_p (enum machine_mode mode, rtx index, RTX_CODE outer,\n \n   /* Standard coprocessor addressing modes.  */\n   if (TARGET_HARD_FLOAT\n-      && (TARGET_VFP || TARGET_FPA || TARGET_MAVERICK)\n-      && (mode == SFmode || mode == DFmode\n-\t  || (TARGET_MAVERICK && mode == DImode)))\n+      && TARGET_VFP\n+      && (mode == SFmode || mode == DFmode))\n     return (code == CONST_INT && INTVAL (index) < 1024\n \t    && INTVAL (index) > -1024\n \t    && (INTVAL (index) & 3) == 0);\n@@ -6000,9 +5909,8 @@ thumb2_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)\n   /* ??? Combine arm and thumb2 coprocessor addressing modes.  */\n   /* Standard coprocessor addressing modes.  */\n   if (TARGET_HARD_FLOAT\n-      && (TARGET_VFP || TARGET_FPA || TARGET_MAVERICK)\n-      && (mode == SFmode || mode == DFmode\n-\t  || (TARGET_MAVERICK && mode == DImode)))\n+      && TARGET_VFP\n+      && (mode == SFmode || mode == DFmode))\n     return (code == CONST_INT && INTVAL (index) < 1024\n \t    /* Thumb-2 allows only > -256 index range for it's core register\n \t       load/stores. Since we allow SF/DF in core registers, we have\n@@ -6715,9 +6623,8 @@ arm_legitimize_reload_address (rtx *p,\n \n       /* Detect coprocessor load/stores.  */\n       bool coproc_p = ((TARGET_HARD_FLOAT\n-\t\t\t&& (TARGET_VFP || TARGET_FPA || TARGET_MAVERICK)\n-\t\t\t&& (mode == SFmode || mode == DFmode\n-\t\t\t    || (mode == DImode && TARGET_MAVERICK)))\n+\t\t\t&& TARGET_VFP\n+\t\t\t&& (mode == SFmode || mode == DFmode))\n \t\t       || (TARGET_REALLY_IWMMXT\n \t\t\t   && VALID_IWMMXT_REG_MODE (mode))\n \t\t       || (TARGET_NEON\n@@ -8573,7 +8480,6 @@ fa726te_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n \n /* Implement TARGET_REGISTER_MOVE_COST.\n \n-   Moves between FPA_REGS and GENERAL_REGS are two memory insns.\n    Moves between VFP_REGS and GENERAL_REGS are a single insn, but\n    it is typically more expensive than a single memory access.  We set\n    the cost to less than two memory accesses so that floating\n@@ -8585,20 +8491,14 @@ arm_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n {\n   if (TARGET_32BIT)\n     {\n-      if ((from == FPA_REGS && to != FPA_REGS)\n-\t  || (from != FPA_REGS && to == FPA_REGS))\n-\treturn 20;\n-      else if ((IS_VFP_CLASS (from) && !IS_VFP_CLASS (to))\n-\t       || (!IS_VFP_CLASS (from) && IS_VFP_CLASS (to)))\n+      if ((IS_VFP_CLASS (from) && !IS_VFP_CLASS (to))\n+\t  || (!IS_VFP_CLASS (from) && IS_VFP_CLASS (to)))\n \treturn 15;\n       else if ((from == IWMMXT_REGS && to != IWMMXT_REGS)\n \t       || (from != IWMMXT_REGS && to == IWMMXT_REGS))\n \treturn 4;\n       else if (from == IWMMXT_GR_REGS || to == IWMMXT_GR_REGS)\n \treturn 20;\n-      else if ((from == CIRRUS_REGS && to != CIRRUS_REGS)\n-\t       || (from != CIRRUS_REGS && to == CIRRUS_REGS))\n-\treturn 20;\n       else\n \treturn 2;\n     }\n@@ -8656,7 +8556,7 @@ arm_adjust_cost (rtx insn, rtx link, rtx dep, int cost)\n \treturn cost;\n     }\n \n-  /* XXX This is not strictly true for the FPA.  */\n+  /* XXX Is this strictly true?  */\n   if (REG_NOTE_KIND (link) == REG_DEP_ANTI\n       || REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n     return 0;\n@@ -9505,43 +9405,6 @@ neon_element_bits (enum machine_mode mode)\n \f\n /* Predicates for `match_operand' and `match_operator'.  */\n \n-/* Return nonzero if OP is a valid Cirrus memory address pattern.  */\n-int\n-cirrus_memory_offset (rtx op)\n-{\n-  /* Reject eliminable registers.  */\n-  if (! (reload_in_progress || reload_completed)\n-      && (   reg_mentioned_p (frame_pointer_rtx, op)\n-\t  || reg_mentioned_p (arg_pointer_rtx, op)\n-\t  || reg_mentioned_p (virtual_incoming_args_rtx, op)\n-\t  || reg_mentioned_p (virtual_outgoing_args_rtx, op)\n-\t  || reg_mentioned_p (virtual_stack_dynamic_rtx, op)\n-\t  || reg_mentioned_p (virtual_stack_vars_rtx, op)))\n-    return 0;\n-\n-  if (GET_CODE (op) == MEM)\n-    {\n-      rtx ind;\n-\n-      ind = XEXP (op, 0);\n-\n-      /* Match: (mem (reg)).  */\n-      if (GET_CODE (ind) == REG)\n-\treturn 1;\n-\n-      /* Match:\n-\t (mem (plus (reg)\n-\t            (const))).  */\n-      if (GET_CODE (ind) == PLUS\n-\t  && GET_CODE (XEXP (ind, 0)) == REG\n-\t  && REG_MODE_OK_FOR_BASE_P (XEXP (ind, 0), VOIDmode)\n-\t  && GET_CODE (XEXP (ind, 1)) == CONST_INT)\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\n /* Return TRUE if OP is a valid coprocessor memory address pattern.\n    WB is true if full writeback address modes are allowed and is false\n    if limited writeback address modes (POST_INC and PRE_DEC) are\n@@ -11641,8 +11504,6 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \tcase LE:\n \tcase GT:\n \tcase GE:\n-\t  if (TARGET_HARD_FLOAT && TARGET_MAVERICK)\n-\t    return CCFPmode;\n \t  return CCFPEmode;\n \n \tdefault:\n@@ -11747,11 +11608,6 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \n   if (GET_MODE (x) == DImode || GET_MODE (y) == DImode)\n     {\n-      /* To keep things simple, always use the Cirrus cfcmp64 if it is\n-\t available.  */\n-      if (TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK)\n-\treturn CCmode;\n-\n       switch (op)\n \t{\n \tcase EQ:\n@@ -11819,7 +11675,6 @@ arm_gen_compare_reg (enum rtx_code code, rtx x, rtx y, rtx scratch)\n   cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n \n   if (dimode_comparison\n-      && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)\n       && mode != CC_CZmode)\n     {\n       rtx clobber, set;\n@@ -13962,47 +13817,6 @@ output_call_mem (rtx *operands)\n }\n \n \n-/* Output a move from arm registers to an fpa registers.\n-   OPERANDS[0] is an fpa register.\n-   OPERANDS[1] is the first registers of an arm register pair.  */\n-const char *\n-output_mov_long_double_fpa_from_arm (rtx *operands)\n-{\n-  int arm_reg0 = REGNO (operands[1]);\n-  rtx ops[3];\n-\n-  gcc_assert (arm_reg0 != IP_REGNUM);\n-\n-  ops[0] = gen_rtx_REG (SImode, arm_reg0);\n-  ops[1] = gen_rtx_REG (SImode, 1 + arm_reg0);\n-  ops[2] = gen_rtx_REG (SImode, 2 + arm_reg0);\n-\n-  output_asm_insn (\"stm%(fd%)\\t%|sp!, {%0, %1, %2}\", ops);\n-  output_asm_insn (\"ldf%?e\\t%0, [%|sp], #12\", operands);\n-\n-  return \"\";\n-}\n-\n-/* Output a move from an fpa register to arm registers.\n-   OPERANDS[0] is the first registers of an arm register pair.\n-   OPERANDS[1] is an fpa register.  */\n-const char *\n-output_mov_long_double_arm_from_fpa (rtx *operands)\n-{\n-  int arm_reg0 = REGNO (operands[0]);\n-  rtx ops[3];\n-\n-  gcc_assert (arm_reg0 != IP_REGNUM);\n-\n-  ops[0] = gen_rtx_REG (SImode, arm_reg0);\n-  ops[1] = gen_rtx_REG (SImode, 1 + arm_reg0);\n-  ops[2] = gen_rtx_REG (SImode, 2 + arm_reg0);\n-\n-  output_asm_insn (\"stf%?e\\t%1, [%|sp, #-12]!\", operands);\n-  output_asm_insn (\"ldm%(fd%)\\t%|sp!, {%0, %1, %2}\", ops);\n-  return \"\";\n-}\n-\n /* Output a move from arm registers to arm registers of a long double\n    OPERANDS[0] is the destination.\n    OPERANDS[1] is the source.  */\n@@ -14055,42 +13869,6 @@ arm_emit_movpair (rtx dest, rtx src)\n    emit_set_insn (dest, gen_rtx_LO_SUM (SImode, dest, src));\n  }\n \n-/* Output a move from arm registers to an fpa registers.\n-   OPERANDS[0] is an fpa register.\n-   OPERANDS[1] is the first registers of an arm register pair.  */\n-const char *\n-output_mov_double_fpa_from_arm (rtx *operands)\n-{\n-  int arm_reg0 = REGNO (operands[1]);\n-  rtx ops[2];\n-\n-  gcc_assert (arm_reg0 != IP_REGNUM);\n-\n-  ops[0] = gen_rtx_REG (SImode, arm_reg0);\n-  ops[1] = gen_rtx_REG (SImode, 1 + arm_reg0);\n-  output_asm_insn (\"stm%(fd%)\\t%|sp!, {%0, %1}\", ops);\n-  output_asm_insn (\"ldf%?d\\t%0, [%|sp], #8\", operands);\n-  return \"\";\n-}\n-\n-/* Output a move from an fpa register to arm registers.\n-   OPERANDS[0] is the first registers of an arm register pair.\n-   OPERANDS[1] is an fpa register.  */\n-const char *\n-output_mov_double_arm_from_fpa (rtx *operands)\n-{\n-  int arm_reg0 = REGNO (operands[0]);\n-  rtx ops[2];\n-\n-  gcc_assert (arm_reg0 != IP_REGNUM);\n-\n-  ops[0] = gen_rtx_REG (SImode, arm_reg0);\n-  ops[1] = gen_rtx_REG (SImode, 1 + arm_reg0);\n-  output_asm_insn (\"stf%?d\\t%1, [%|sp, #-8]!\", operands);\n-  output_asm_insn (\"ldm%(fd%)\\t%|sp!, {%0, %1}\", ops);\n-  return \"\";\n-}\n-\n /* Output a move between double words.  It must be REG<-MEM\n    or MEM<-REG.  */\n const char *\n@@ -16133,68 +15911,7 @@ arm_size_return_regs (void)\n   return GET_MODE_SIZE (mode);\n }\n \n-static rtx\n-emit_sfm (int base_reg, int count)\n-{\n-  rtx par;\n-  rtx dwarf;\n-  rtx tmp, reg;\n-  int i;\n-\n-  par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n-  dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (count + 1));\n-\n-  reg = gen_rtx_REG (XFmode, base_reg++);\n-\n-  XVECEXP (par, 0, 0)\n-    = gen_rtx_SET (VOIDmode,\n-\t\t   gen_frame_mem\n-\t\t   (BLKmode,\n-\t\t    gen_rtx_PRE_MODIFY (Pmode,\n-\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\tplus_constant\n-\t\t\t\t\t(Pmode, stack_pointer_rtx,\n-\t\t\t\t\t -12 * count))\n-\t\t    ),\n-\t\t   gen_rtx_UNSPEC (BLKmode,\n-\t\t\t\t   gen_rtvec (1, reg),\n-\t\t\t\t   UNSPEC_PUSH_MULT));\n-  tmp = gen_rtx_SET (VOIDmode,\n-\t\t     gen_frame_mem (XFmode, stack_pointer_rtx), reg);\n-  RTX_FRAME_RELATED_P (tmp) = 1;\n-  XVECEXP (dwarf, 0, 1) = tmp;\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      reg = gen_rtx_REG (XFmode, base_reg++);\n-      XVECEXP (par, 0, i) = gen_rtx_USE (VOIDmode, reg);\n-\n-      tmp = gen_rtx_SET (VOIDmode,\n-\t\t\t gen_frame_mem (XFmode,\n-\t\t\t\t\tplus_constant (Pmode,\n-\t\t\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t\t\t       i * 12)),\n-\t\t\t reg);\n-      RTX_FRAME_RELATED_P (tmp) = 1;\n-      XVECEXP (dwarf, 0, i + 1) = tmp;\n-    }\n-\n-  tmp = gen_rtx_SET (VOIDmode,\n-\t\t     stack_pointer_rtx,\n-\t\t     plus_constant (Pmode, stack_pointer_rtx, -12 * count));\n-\n-  RTX_FRAME_RELATED_P (tmp) = 1;\n-  XVECEXP (dwarf, 0, 0) = tmp;\n-\n-  par = emit_insn (par);\n-  add_reg_note (par, REG_FRAME_RELATED_EXPR, dwarf);\n-\n-  return par;\n-}\n-\n-\n /* Return true if the current function needs to save/restore LR.  */\n-\n static bool\n thumb_force_lr_save (void)\n {\n@@ -16207,7 +15924,6 @@ thumb_force_lr_save (void)\n \n /* Return true if r3 is used by any of the tail call insns in the\n    current function.  */\n-\n static bool\n any_sibcall_uses_r3 (void)\n {\n@@ -16345,17 +16061,10 @@ arm_get_frame_offsets (void)\n \t}\n \n       func_type = arm_current_func_type ();\n-      if (! IS_VOLATILE (func_type))\n-\t{\n-\t  /* Space for saved FPA registers.  */\n-\t  for (regno = FIRST_FPA_REGNUM; regno <= LAST_FPA_REGNUM; regno++)\n-\t    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n-\t    saved += 12;\n-\n-\t  /* Space for saved VFP registers.  */\n-\t  if (TARGET_HARD_FLOAT && TARGET_VFP)\n-\t    saved += arm_get_vfp_saved_size ();\n-\t}\n+      /* Space for saved VFP registers.  */\n+      if (! IS_VOLATILE (func_type)\n+\t  && TARGET_HARD_FLOAT && TARGET_VFP)\n+\tsaved += arm_get_vfp_saved_size ();\n     }\n   else /* TARGET_THUMB1 */\n     {\n@@ -16551,55 +16260,6 @@ arm_save_coproc_regs(void)\n \tsaved_size += 8;\n       }\n \n-  /* Save any floating point call-saved registers used by this\n-     function.  */\n-  if (TARGET_FPA_EMU2)\n-    {\n-      for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n-\tif (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n-\t  {\n-\t    insn = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n-\t    insn = gen_rtx_MEM (XFmode, insn);\n-\t    insn = emit_set_insn (insn, gen_rtx_REG (XFmode, reg));\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t    saved_size += 12;\n-\t  }\n-    }\n-  else\n-    {\n-      start_reg = LAST_FPA_REGNUM;\n-\n-      for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n-\t{\n-\t  if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n-\t    {\n-\t      if (start_reg - reg == 3)\n-\t\t{\n-\t\t  insn = emit_sfm (reg, 4);\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t  saved_size += 48;\n-\t\t  start_reg = reg - 1;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      if (start_reg != reg)\n-\t\t{\n-\t\t  insn = emit_sfm (reg + 1, start_reg - reg);\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t  saved_size += (start_reg - reg) * 12;\n-\t\t}\n-\t      start_reg = reg - 1;\n-\t    }\n-\t}\n-\n-      if (start_reg != reg)\n-\t{\n-\t  insn = emit_sfm (reg + 1, start_reg - reg);\n-\t  saved_size += (start_reg - reg) * 12;\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t}\n-    }\n   if (TARGET_HARD_FLOAT && TARGET_VFP)\n     {\n       start_reg = FIRST_VFP_REGNUM;\n@@ -17156,16 +16816,6 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       fprintf (stream, \"%s\", arithmetic_instr (x, 1));\n       return;\n \n-    /* Truncate Cirrus shift counts.  */\n-    case 's':\n-      if (GET_CODE (x) == CONST_INT)\n-\t{\n-\t  fprintf (stream, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) & 0x3f);\n-\t  return;\n-\t}\n-      arm_print_operand (stream, x, 0);\n-      return;\n-\n     case 'I':\n       fprintf (stream, \"%s\", arithmetic_instr (x, 0));\n       return;\n@@ -17352,44 +17002,15 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t     stream);\n       return;\n \n-    /* Cirrus registers can be accessed in a variety of ways:\n-         single floating point (f)\n-\t double floating point (d)\n-\t 32bit integer         (fx)\n-\t 64bit integer         (dx).  */\n-    case 'W':\t\t\t/* Cirrus register in F mode.  */\n-    case 'X':\t\t\t/* Cirrus register in D mode.  */\n-    case 'Y':\t\t\t/* Cirrus register in FX mode.  */\n-    case 'Z':\t\t\t/* Cirrus register in DX mode.  */\n-      gcc_assert (GET_CODE (x) == REG\n-\t\t  && REGNO_REG_CLASS (REGNO (x)) == CIRRUS_REGS);\n-\n-      fprintf (stream, \"mv%s%s\",\n-\t       code == 'W' ? \"f\"\n-\t       : code == 'X' ? \"d\"\n-\t       : code == 'Y' ? \"fx\" : \"dx\", reg_names[REGNO (x)] + 2);\n-\n-      return;\n-\n-    /* Print cirrus register in the mode specified by the register's mode.  */\n+    case 's':\n     case 'V':\n-      {\n-\tint mode = GET_MODE (x);\n-\n-\tif (GET_CODE (x) != REG || REGNO_REG_CLASS (REGNO (x)) != CIRRUS_REGS)\n-\t  {\n-\t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n-\t    return;\n-\t  }\n-\n-\tfprintf (stream, \"mv%s%s\",\n-\t\t mode == DFmode ? \"d\"\n-\t\t : mode == SImode ? \"fx\"\n-\t\t : mode == DImode ? \"dx\"\n-\t\t : \"f\", reg_names[REGNO (x)] + 2);\n-\n-\treturn;\n-      }\n+    case 'W':\n+    case 'X':\n+    case 'Y':\n+    case 'Z':\n+      /* Former Maverick support, removed after GCC-4.7.  */\n+      output_operand_lossage (\"obsolete Maverick format code '%c'\", code);\n+      return;\n \n     case 'U':\n       if (GET_CODE (x) != REG\n@@ -18074,9 +17695,7 @@ maybe_get_arm_condition_code (rtx comparison)\n \n     case CCFPEmode:\n     case CCFPmode:\n-      /* These encodings assume that AC=1 in the FPA system control\n-\t byte.  This allows us to handle all cases except UNEQ and\n-\t LTGT.  */\n+      /* We can handle all cases except UNEQ and LTGT.  */\n       switch (comp_code)\n \t{\n \tcase GE: return ARM_GE;\n@@ -18576,15 +18195,6 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n        start of an even numbered register pair.  */\n     return (ARM_NUM_REGS (mode) < 2) || (regno < LAST_LO_REGNUM);\n \n-  if (TARGET_HARD_FLOAT && TARGET_MAVERICK\n-      && IS_CIRRUS_REGNUM (regno))\n-    /* We have outlawed SI values in Cirrus registers because they\n-       reside in the lower 32 bits, but SF values reside in the\n-       upper 32 bits.  This causes gcc all sorts of grief.  We can't\n-       even split the registers into pairs because Cirrus SI values\n-       get sign extended to 64bits-- aldyh.  */\n-    return (GET_MODE_CLASS (mode) == MODE_FLOAT) || (mode == DImode);\n-\n   if (TARGET_HARD_FLOAT && TARGET_VFP\n       && IS_VFP_REGNUM (regno))\n     {\n@@ -18634,12 +18244,7 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n     /* We only allow integers in the fake hard registers.  */\n     return GET_MODE_CLASS (mode) == MODE_INT;\n \n-  /* The only registers left are the FPA registers\n-     which we only allow to hold FP values.  */\n-  return (TARGET_HARD_FLOAT && TARGET_FPA\n-\t  && GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t  && regno >= FIRST_FPA_REGNUM\n-\t  && regno <= LAST_FPA_REGNUM);\n+  return FALSE;\n }\n \n /* Implement MODES_TIEABLE_P.  */\n@@ -18693,9 +18298,6 @@ arm_regno_class (int regno)\n   if (regno == CC_REGNUM || regno == VFPCC_REGNUM)\n     return TARGET_THUMB2 ? CC_REG : NO_REGS;\n \n-  if (IS_CIRRUS_REGNUM (regno))\n-    return CIRRUS_REGS;\n-\n   if (IS_VFP_REGNUM (regno))\n     {\n       if (regno <= D7_VFP_REGNUM)\n@@ -18712,7 +18314,7 @@ arm_regno_class (int regno)\n   if (IS_IWMMXT_GR_REGNUM (regno))\n     return IWMMXT_GR_REGS;\n \n-  return FPA_REGS;\n+  return NO_REGS;\n }\n \n /* Handle a special case when computing the offset\n@@ -23645,10 +23247,7 @@ arm_file_start (void)\n \n       if (TARGET_SOFT_FLOAT)\n \t{\n-\t  if (TARGET_VFP)\n-\t    fpu_name = \"softvfp\";\n-\t  else\n-\t    fpu_name = \"softfpa\";\n+\t  fpu_name = \"softvfp\";\n \t}\n       else\n \t{\n@@ -24550,11 +24149,6 @@ arm_dbx_register_number (unsigned int regno)\n   if (regno < 16)\n     return regno;\n \n-  /* TODO: Legacy targets output FPA regs as registers 16-23 for backwards\n-     compatibility.  The EABI defines them as registers 96-103.  */\n-  if (IS_FPA_REGNUM (regno))\n-    return (TARGET_AAPCS_BASED ? 96 : 16) + regno - FIRST_FPA_REGNUM;\n-\n   if (IS_VFP_REGNUM (regno))\n     {\n       /* See comment in arm_dwarf_register_span.  */\n@@ -24656,12 +24250,6 @@ arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n       reg_size = 8;\n       fprintf (asm_out_file, \"\\t.vsave {\");\n     }\n-  else if (reg >= FIRST_FPA_REGNUM && reg <= LAST_FPA_REGNUM)\n-    {\n-      /* FPA registers are done differently.  */\n-      asm_fprintf (asm_out_file, \"\\t.save %r, %wd\\n\", reg, nregs);\n-      return;\n-    }\n   else\n     /* Unknown register type.  */\n     abort ();\n@@ -25358,7 +24946,7 @@ arm_mangle_type (const_tree type)\n static const int thumb_core_reg_alloc_order[] =\n {\n    3,  2,  1,  0,  4,  5,  6,  7,\n-  14, 12,  8,  9, 10, 11, 13, 15\n+  14, 12,  8,  9, 10, 11\n };\n \n /* Adjust register allocation order when compiling for Thumb.  */\n@@ -25441,13 +25029,6 @@ arm_conditional_register_usage (void)\n {\n   int regno;\n \n-  if (TARGET_SOFT_FLOAT || TARGET_THUMB1 || !TARGET_FPA)\n-    {\n-      for (regno = FIRST_FPA_REGNUM;\n-\t   regno <= LAST_FPA_REGNUM; ++regno)\n-\tfixed_regs[regno] = call_used_regs[regno] = 1;\n-    }\n-\n   if (TARGET_THUMB1 && optimize_size)\n     {\n       /* When optimizing for size on Thumb-1, it's better not\n@@ -25464,32 +25045,17 @@ arm_conditional_register_usage (void)\n   if (TARGET_THUMB1)\n     fixed_regs[LR_REGNUM] = call_used_regs[LR_REGNUM] = 1;\n \n-  if (TARGET_32BIT && TARGET_HARD_FLOAT)\n+  if (TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP)\n     {\n-      if (TARGET_MAVERICK)\n-\t{\n-\t  for (regno = FIRST_FPA_REGNUM;\n-\t       regno <= LAST_FPA_REGNUM; ++ regno)\n-\t    fixed_regs[regno] = call_used_regs[regno] = 1;\n-\t  for (regno = FIRST_CIRRUS_FP_REGNUM;\n-\t       regno <= LAST_CIRRUS_FP_REGNUM; ++ regno)\n-\t    {\n-\t      fixed_regs[regno] = 0;\n-\t      call_used_regs[regno] = regno < FIRST_CIRRUS_FP_REGNUM + 4;\n-\t    }\n-\t}\n-      if (TARGET_VFP)\n+      /* VFPv3 registers are disabled when earlier VFP\n+\t versions are selected due to the definition of\n+\t LAST_VFP_REGNUM.  */\n+      for (regno = FIRST_VFP_REGNUM;\n+\t   regno <= LAST_VFP_REGNUM; ++ regno)\n \t{\n-\t  /* VFPv3 registers are disabled when earlier VFP\n-\t     versions are selected due to the definition of\n-\t     LAST_VFP_REGNUM.  */\n-\t  for (regno = FIRST_VFP_REGNUM;\n-\t       regno <= LAST_VFP_REGNUM; ++ regno)\n-\t    {\n-\t      fixed_regs[regno] = 0;\n-\t      call_used_regs[regno] = regno < FIRST_VFP_REGNUM + 16\n-\t      \t|| regno >= FIRST_VFP_REGNUM + 32;\n-\t    }\n+\t  fixed_regs[regno] = 0;\n+\t  call_used_regs[regno] = regno < FIRST_VFP_REGNUM + 16\n+\t    || regno >= FIRST_VFP_REGNUM + 32;\n \t}\n     }\n "}, {"sha": "8acde0e6267bcff56773dc3f1c8e2982de08433e", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 141, "deletions": 177, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "patch": "@@ -139,8 +139,6 @@ extern char arm_arch_name[];\n \tbuiltin_assert (\"machine=arm\");\t\t\t\\\n \t\t\t\t\t\t\t\\\n \tbuiltin_define (arm_arch_name);\t\t\t\\\n-\tif (arm_arch_cirrus)\t\t\t\t\\\n-\t  builtin_define (\"__MAVERICK__\");\t\t\\\n \tif (arm_arch_xscale)\t\t\t\t\\\n \t  builtin_define (\"__XSCALE__\");\t\t\\\n \tif (arm_arch_iwmmxt)\t\t\t\t\\\n@@ -243,8 +241,6 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n #define TARGET_HARD_FLOAT\t\t(arm_float_abi != ARM_FLOAT_ABI_SOFT)\n /* Use hardware floating point calling convention.  */\n #define TARGET_HARD_FLOAT_ABI\t\t(arm_float_abi == ARM_FLOAT_ABI_HARD)\n-#define TARGET_FPA\t\t(arm_fpu_desc->model == ARM_FP_MODEL_FPA)\n-#define TARGET_MAVERICK\t\t(arm_fpu_desc->model == ARM_FP_MODEL_MAVERICK)\n #define TARGET_VFP\t\t(arm_fpu_desc->model == ARM_FP_MODEL_VFP)\n #define TARGET_IWMMXT\t\t\t(arm_arch_iwmmxt)\n #define TARGET_IWMMXT2\t\t\t(arm_arch_iwmmxt2)\n@@ -272,8 +268,6 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n #define TARGET_THUMB2\t\t\t(TARGET_THUMB && arm_arch_thumb2)\n /* Thumb-1 only.  */\n #define TARGET_THUMB1_ONLY\t\t(TARGET_THUMB1 && !arm_arch_notm)\n-/* FPA emulator without LFM.  */\n-#define TARGET_FPA_EMU2\t\t\t(TARGET_FPA && arm_fpu_desc->rev == 2)\n \n /* The following two macros concern the ability to execute coprocessor\n    instructions for VFPv3 or NEON.  TARGET_VFP3/TARGET_VFPD32 are currently\n@@ -386,10 +380,6 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n enum arm_fp_model\n {\n   ARM_FP_MODEL_UNKNOWN,\n-  /* FPA model (Hardware or software).  */\n-  ARM_FP_MODEL_FPA,\n-  /* Cirrus Maverick floating point model.  */\n-  ARM_FP_MODEL_MAVERICK,\n   /* VFP floating point model.  */\n   ARM_FP_MODEL_VFP\n };\n@@ -501,9 +491,6 @@ extern int thumb1_code;\n /* Nonzero if this chip is a StrongARM.  */\n extern int arm_tune_strongarm;\n \n-/* Nonzero if this chip is a Cirrus variant.  */\n-extern int arm_arch_cirrus;\n-\n /* Nonzero if this chip supports Intel XScale with Wireless MMX technology.  */\n extern int arm_arch_iwmmxt;\n \n@@ -604,11 +591,6 @@ extern int arm_arch_thumb_hwdiv;\n    This is always false, even when in big-endian mode.  */\n #define WORDS_BIG_ENDIAN  (BYTES_BIG_ENDIAN && ! TARGET_LITTLE_WORDS)\n \n-/* Define this if most significant word of doubles is the lowest numbered.\n-   The rules are different based on whether or not we use FPA-format,\n-   VFP-format or some other floating point co-processor's format doubles.  */\n-#define FLOAT_WORDS_BIG_ENDIAN (arm_float_words_big_endian ())\n-\n #define UNITS_PER_WORD\t4\n \n /* True if natural alignment is used for doubleword types.  */\n@@ -727,7 +709,7 @@ extern int arm_arch_thumb_hwdiv;\n \f\n /* Standard register usage.  */\n \n-/* Register allocation in ARM Procedure Call Standard (as used on RISCiX):\n+/* Register allocation in ARM Procedure Call Standard\n    (S - saved over call).\n \n \tr0\t   *\targument word/integer result\n@@ -743,11 +725,6 @@ extern int arm_arch_thumb_hwdiv;\n \tr14\t\t(lr) link address/workspace\n \tr15\t   F\t(pc) program counter\n \n-\tf0\t\tfloating point result\n-\tf1-f3\t\tfloating point scratch\n-\n-\tf4-f7\t     S\tfloating point variable\n-\n \tcc\t\tThis is NOT a real register, but is used internally\n \t                to represent things that use or set the condition\n \t\t\tcodes.\n@@ -761,11 +738,6 @@ extern int arm_arch_thumb_hwdiv;\n \n    *: See TARGET_CONDITIONAL_REGISTER_USAGE  */\n \n-/*\n-  \tmvf0\t\tCirrus floating point result\n-\tmvf1-mvf3\tCirrus floating point scratch\n-\tmvf4-mvf15   S\tCirrus floating point variable.  */\n-\n /*\ts0-s15\t\tVFP scratch (aka d0-d7).\n \ts16-s31\t      S\tVFP variable (aka d8-d15).\n \tvfpcc\t\tNot a real register.  Represents the VFP condition\n@@ -787,34 +759,30 @@ extern int arm_arch_thumb_hwdiv;\n                      [|  saved r2 value     |]\n                      [|  saved r1 value     |]\n                      [|  saved r0 value     |]\n-                     [|  saved f7 value     |]     three words\n-                     [|  saved f6 value     |]     three words\n-                     [|  saved f5 value     |]     three words\n-                     [|  saved f4 value     |]     three words\n   r0-r3 are not normally saved in a C function.  */\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.  */\n-#define FIXED_REGISTERS \\\n-{                       \\\n-  0,0,0,0,0,0,0,0,\t\\\n-  0,0,0,0,0,1,0,1,\t\\\n-  0,0,0,0,0,0,0,0,\t\\\n-  1,1,1,\t\t\\\n-  1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,\t\t\\\n-  1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,1,1,1,1,\t\\\n-  1\t\t\t\\\n+#define FIXED_REGISTERS \t\\\n+{\t\t\t\t\\\n+  /* Core regs.  */\t\t\\\n+  0,0,0,0,0,0,0,0,\t\t\\\n+  0,0,0,0,0,1,0,1,\t\t\\\n+  /* VFP regs.  */\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  /* IWMMXT regs.  */\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,\t\t\t\\\n+  /* Specials.  */\t\t\\\n+  1,1,1,1\t\t\t\\\n }\n \n /* 1 for registers not available across function calls.\n@@ -825,26 +793,26 @@ extern int arm_arch_thumb_hwdiv;\n    Aside from that, you can include as many other registers as you like.\n    The CC is not preserved over function calls on the ARM 6, so it is\n    easier to assume this for all.  SFP is preserved, since FP is.  */\n-#define CALL_USED_REGISTERS  \\\n-{                            \\\n-  1,1,1,1,0,0,0,0,\t     \\\n-  0,0,0,0,1,1,1,1,\t     \\\n-  1,1,1,1,0,0,0,0,\t     \\\n-  1,1,1,\t\t     \\\n-  1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,\t\t     \\\n-  1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,1,1,1,1,\t     \\\n-  1\t\t\t     \\\n+#define CALL_USED_REGISTERS\t\\\n+{\t\t\t\t\\\n+  /* Core regs.  */\t\t\\\n+  1,1,1,1,0,0,0,0,\t\t\\\n+  0,0,0,0,1,1,1,1,\t\t\\\n+  /* VFP Regs.  */\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  /* IWMMXT regs.  */\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\t\\\n+  1,1,1,1,\t\t\t\\\n+  /* Specials.  */\t\t\\\n+  1,1,1,1\t\t\t\\\n }\n \n #ifndef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n@@ -961,34 +929,24 @@ extern int arm_arch_thumb_hwdiv;\n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM\tSP_REGNUM\n \n-/* ARM floating pointer registers.  */\n-#define FIRST_FPA_REGNUM \t16\n-#define LAST_FPA_REGNUM  \t23\n-#define IS_FPA_REGNUM(REGNUM) \\\n-  (((REGNUM) >= FIRST_FPA_REGNUM) && ((REGNUM) <= LAST_FPA_REGNUM))\n+#define FIRST_IWMMXT_REGNUM\t(LAST_HI_VFP_REGNUM + 1)\n+#define LAST_IWMMXT_REGNUM\t(FIRST_IWMMXT_REGNUM + 15)\n+#define FIRST_IWMMXT_GR_REGNUM\t(LAST_IWMMXT_REGNUM + 1)\n+#define LAST_IWMMXT_GR_REGNUM\t(FIRST_IWMMXT_GR_REGNUM + 3)\n \n-#define FIRST_IWMMXT_GR_REGNUM\t43\n-#define LAST_IWMMXT_GR_REGNUM\t46\n-#define FIRST_IWMMXT_REGNUM\t47\n-#define LAST_IWMMXT_REGNUM\t62\n #define IS_IWMMXT_REGNUM(REGNUM) \\\n   (((REGNUM) >= FIRST_IWMMXT_REGNUM) && ((REGNUM) <= LAST_IWMMXT_REGNUM))\n #define IS_IWMMXT_GR_REGNUM(REGNUM) \\\n   (((REGNUM) >= FIRST_IWMMXT_GR_REGNUM) && ((REGNUM) <= LAST_IWMMXT_GR_REGNUM))\n \n /* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM\t25\n+#define FRAME_POINTER_REGNUM\t102\n \n /* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM\t26\n+#define ARG_POINTER_REGNUM\t103\n \n-#define FIRST_CIRRUS_FP_REGNUM\t27\n-#define LAST_CIRRUS_FP_REGNUM\t42\n-#define IS_CIRRUS_REGNUM(REGNUM) \\\n-  (((REGNUM) >= FIRST_CIRRUS_FP_REGNUM) && ((REGNUM) <= LAST_CIRRUS_FP_REGNUM))\n-\n-#define FIRST_VFP_REGNUM\t63\n-#define D7_VFP_REGNUM\t\t78  /* Registers 77 and 78 == VFP reg D7.  */\n+#define FIRST_VFP_REGNUM\t16\n+#define D7_VFP_REGNUM\t\t(FIRST_VFP_REGNUM + 15)\n #define LAST_VFP_REGNUM\t\\\n   (TARGET_VFPD32 ? LAST_HI_VFP_REGNUM : LAST_LO_VFP_REGNUM)\n \n@@ -1001,9 +959,9 @@ extern int arm_arch_thumb_hwdiv;\n    in various parts of the backend, we implement as \"fake\" single-precision\n    registers (which would be S32-S63, but cannot be used in that way).  The\n    following macros define these ranges of registers.  */\n-#define LAST_LO_VFP_REGNUM\t94\n-#define FIRST_HI_VFP_REGNUM\t95\n-#define LAST_HI_VFP_REGNUM\t126\n+#define LAST_LO_VFP_REGNUM\t(FIRST_VFP_REGNUM + 31)\n+#define FIRST_HI_VFP_REGNUM\t(LAST_LO_VFP_REGNUM + 1)\n+#define LAST_HI_VFP_REGNUM\t(FIRST_HI_VFP_REGNUM + 31)\n \n #define VFP_REGNO_OK_FOR_SINGLE(REGNUM) \\\n   ((REGNUM) <= LAST_LO_VFP_REGNUM)\n@@ -1024,11 +982,10 @@ extern int arm_arch_thumb_hwdiv;\n   ((((REGNUM) - FIRST_VFP_REGNUM) & 3) == 0 \\\n    && (LAST_VFP_REGNUM - (REGNUM) >= 2 * (N) - 1))\n \n-/* The number of hard registers is 16 ARM + 8 FPA + 1 CC + 1 SFP + 1 AFP.  */\n-/* + 16 Cirrus registers take us up to 43.  */\n+/* The number of hard registers is 16 ARM + 1 CC + 1 SFP + 1 AFP.  */\n /* Intel Wireless MMX Technology registers add 16 + 4 more.  */\n-/* VFP (VFP3) adds 32 (64) + 1 more.  */\n-#define FIRST_PSEUDO_REGISTER   128\n+/* VFP (VFP3) adds 32 (64) + 1 VFPCC.  */\n+#define FIRST_PSEUDO_REGISTER   104\n \n #define DBX_REGISTER_NUMBER(REGNO) arm_dbx_register_number (REGNO)\n \n@@ -1048,11 +1005,10 @@ extern int arm_arch_thumb_hwdiv;\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n \n-   On the ARM regs are UNITS_PER_WORD bits wide; FPA regs can hold any FP\n-   mode.  */\n+   On the ARM core regs are UNITS_PER_WORD bits wide.  */\n #define HARD_REGNO_NREGS(REGNO, MODE)  \t\\\n   ((TARGET_32BIT\t\t\t\\\n-    && REGNO >= FIRST_FPA_REGNUM\t\\\n+    && REGNO > PC_REGNUM\t\t\\\n     && REGNO != FRAME_POINTER_REGNUM\t\\\n     && REGNO != ARG_POINTER_REGNUM)\t\\\n     && !IS_VFP_REGNUM (REGNO)\t\t\\\n@@ -1096,26 +1052,44 @@ extern int arm_regs_in_sequence[];\n    pressure when both single- and double-precision registers are used in a\n    function.  */\n \n+#define VREG(X)  (FIRST_VFP_REGNUM + (X))\n+#define WREG(X)  (FIRST_IWMMXT_REGNUM + (X))\n+#define WGREG(X) (FIRST_IWMMXT_GR_REGNUM + (X))\n+\n #define REG_ALLOC_ORDER\t\t\t\t\\\n {\t\t\t\t\t\t\\\n-     3,  2,  1,  0, 12, 14,  4,  5,\t\t\\\n-     6,  7,  8, 10,  9, 11, 13, 15,\t\t\\\n-    16, 17, 18, 19, 20, 21, 22, 23,\t\t\\\n-    27, 28, 29, 30, 31, 32, 33, 34,\t\t\\\n-    35, 36, 37, 38, 39, 40, 41, 42,\t\t\\\n-    43, 44, 45, 46, 47, 48, 49, 50,\t\t\\\n-    51, 52, 53, 54, 55, 56, 57, 58,\t\t\\\n-    59, 60, 61, 62,\t\t\t\t\\\n-    24, 25, 26,\t\t\t\t\t\\\n-    95,  96,  97,  98,  99, 100, 101, 102,\t\\\n-   103, 104, 105, 106, 107, 108, 109, 110,\t\\\n-   111, 112, 113, 114, 115, 116, 117, 118,\t\\\n-   119, 120, 121, 122, 123, 124, 125, 126,\t\\\n-    78,  77,  76,  75,  74,  73,  72,  71,\t\\\n-    70,  69,  68,  67,  66,  65,  64,  63,\t\\\n-    79,  80,  81,  82,  83,  84,  85,  86,\t\\\n-    87,  88,  89,  90,  91,  92,  93,  94,\t\\\n-   127\t\t\t\t\t\t\\\n+  /* General registers.  */\t\t\t\\\n+  3,  2,  1,  0,  12, 14,  4,  5,\t\t\\\n+  6,  7,  8,  9,  10, 11,\t\t\t\\\n+  /* High VFP registers.  */\t\t\t\\\n+  VREG(32), VREG(33), VREG(34), VREG(35),\t\\\n+  VREG(36), VREG(37), VREG(38), VREG(39),\t\\\n+  VREG(40), VREG(41), VREG(42), VREG(43),\t\\\n+  VREG(44), VREG(45), VREG(46), VREG(47),\t\\\n+  VREG(48), VREG(49), VREG(50), VREG(51),\t\\\n+  VREG(52), VREG(53), VREG(54), VREG(55),\t\\\n+  VREG(56), VREG(57), VREG(58), VREG(59),\t\\\n+  VREG(60), VREG(61), VREG(62), VREG(63),\t\\\n+  /* VFP argument registers.  */\t\t\\\n+  VREG(15), VREG(14), VREG(13), VREG(12),\t\\\n+  VREG(11), VREG(10), VREG(9),  VREG(8),\t\\\n+  VREG(7),  VREG(6),  VREG(5),  VREG(4),\t\\\n+  VREG(3),  VREG(2),  VREG(1),  VREG(0),\t\\\n+  /* VFP call-saved registers.  */\t\t\\\n+  VREG(16), VREG(17), VREG(18), VREG(19),\t\\\n+  VREG(20), VREG(21), VREG(22), VREG(23),\t\\\n+  VREG(24), VREG(25), VREG(26), VREG(27),\t\\\n+  VREG(28), VREG(29), VREG(30), VREG(31),\t\\\n+  /* IWMMX registers.  */\t\t\t\\\n+  WREG(0),  WREG(1),  WREG(2),  WREG(3),\t\\\n+  WREG(4),  WREG(5),  WREG(6),  WREG(7),\t\\\n+  WREG(8),  WREG(9),  WREG(10), WREG(11),\t\\\n+  WREG(12), WREG(13), WREG(14), WREG(15),\t\\\n+  WGREG(0), WGREG(1), WGREG(2), WGREG(3),\t\\\n+  /* Registers not for general use.  */\t\t\\\n+  CC_REGNUM, VFPCC_REGNUM,\t\t\t\\\n+  FRAME_POINTER_REGNUM, ARG_POINTER_REGNUM,\t\\\n+  SP_REGNUM, PC_REGNUM \t\t\t\t\\\n }\n \n /* Use different register alloc ordering for Thumb.  */\n@@ -1134,27 +1108,26 @@ extern int arm_regs_in_sequence[];\n \f\n /* Register and constant classes.  */\n \n-/* Register classes: used to be simple, just all ARM regs or all FPA regs\n-   Now that the Thumb is involved it has become more complicated.  */\n+/* Register classes.  */\n enum reg_class\n {\n   NO_REGS,\n-  FPA_REGS,\n-  CIRRUS_REGS,\n+  LO_REGS,\n+  STACK_REG,\n+  BASE_REGS,\n+  HI_REGS,\n+  GENERAL_REGS,\n+  CORE_REGS,\n   VFP_D0_D7_REGS,\n   VFP_LO_REGS,\n   VFP_HI_REGS,\n   VFP_REGS,\n-  IWMMXT_GR_REGS,\n   IWMMXT_REGS,\n-  LO_REGS,\n-  STACK_REG,\n-  BASE_REGS,\n-  HI_REGS,\n+  IWMMXT_GR_REGS,\n   CC_REG,\n   VFPCC_REG,\n-  GENERAL_REGS,\n-  CORE_REGS,\n+  SFP_REG,\n+  AFP_REG,\n   ALL_REGS,\n   LIM_REG_CLASSES\n };\n@@ -1165,22 +1138,20 @@ enum reg_class\n #define REG_CLASS_NAMES  \\\n {\t\t\t\\\n   \"NO_REGS\",\t\t\\\n-  \"FPA_REGS\",\t\t\\\n-  \"CIRRUS_REGS\",\t\\\n+  \"LO_REGS\",\t\t\\\n+  \"STACK_REG\",\t\t\\\n+  \"BASE_REGS\",\t\t\\\n+  \"HI_REGS\",\t\t\\\n+  \"GENERAL_REGS\",\t\\\n+  \"CORE_REGS\",\t\t\\\n   \"VFP_D0_D7_REGS\",\t\\\n   \"VFP_LO_REGS\",\t\\\n   \"VFP_HI_REGS\",\t\\\n   \"VFP_REGS\",\t\t\\\n-  \"IWMMXT_GR_REGS\",\t\\\n   \"IWMMXT_REGS\",\t\\\n-  \"LO_REGS\",\t\t\\\n-  \"STACK_REG\",\t\t\\\n-  \"BASE_REGS\",\t\t\\\n-  \"HI_REGS\",\t\t\\\n+  \"IWMMXT_GR_REGS\",\t\\\n   \"CC_REG\",\t\t\\\n   \"VFPCC_REG\",\t\t\\\n-  \"GENERAL_REGS\",\t\\\n-  \"CORE_REGS\",\t\t\\\n   \"ALL_REGS\",\t\t\\\n }\n \n@@ -1190,23 +1161,23 @@ enum reg_class\n #define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, /* NO_REGS  */\t\\\n-  { 0x00FF0000, 0x00000000, 0x00000000, 0x00000000 }, /* FPA_REGS */\t\\\n-  { 0xF8000000, 0x000007FF, 0x00000000, 0x00000000 }, /* CIRRUS_REGS */\t\\\n-  { 0x00000000, 0x80000000, 0x00007FFF, 0x00000000 }, /* VFP_D0_D7_REGS  */ \\\n-  { 0x00000000, 0x80000000, 0x7FFFFFFF, 0x00000000 }, /* VFP_LO_REGS  */ \\\n-  { 0x00000000, 0x00000000, 0x80000000, 0x7FFFFFFF }, /* VFP_HI_REGS  */ \\\n-  { 0x00000000, 0x80000000, 0xFFFFFFFF, 0x7FFFFFFF }, /* VFP_REGS  */\t\\\n-  { 0x00000000, 0x00007800, 0x00000000, 0x00000000 }, /* IWMMXT_GR_REGS */ \\\n-  { 0x00000000, 0x7FFF8000, 0x00000000, 0x00000000 }, /* IWMMXT_REGS */\t\\\n   { 0x000000FF, 0x00000000, 0x00000000, 0x00000000 }, /* LO_REGS */\t\\\n   { 0x00002000, 0x00000000, 0x00000000, 0x00000000 }, /* STACK_REG */\t\\\n   { 0x000020FF, 0x00000000, 0x00000000, 0x00000000 }, /* BASE_REGS */\t\\\n-  { 0x0000DF00, 0x00000000, 0x00000000, 0x00000000 }, /* HI_REGS */\t\\\n-  { 0x01000000, 0x00000000, 0x00000000, 0x00000000 }, /* CC_REG */\t\\\n-  { 0x00000000, 0x00000000, 0x00000000, 0x80000000 }, /* VFPCC_REG */\t\\\n-  { 0x0000DFFF, 0x00000000, 0x00000000, 0x00000000 }, /* GENERAL_REGS */ \\\n-  { 0x0000FFFF, 0x00000000, 0x00000000, 0x00000000 }, /* CORE_REGS */\t\\\n-  { 0xFAFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF }  /* ALL_REGS */\t\\\n+  { 0x00005F00, 0x00000000, 0x00000000, 0x00000000 }, /* HI_REGS */\t\\\n+  { 0x00005FFF, 0x00000000, 0x00000000, 0x00000000 }, /* GENERAL_REGS */ \\\n+  { 0x00007FFF, 0x00000000, 0x00000000, 0x00000000 }, /* CORE_REGS */\t\\\n+  { 0xFFFF0000, 0x00000000, 0x00000000, 0x00000000 }, /* VFP_D0_D7_REGS  */ \\\n+  { 0xFFFF0000, 0x0000FFFF, 0x00000000, 0x00000000 }, /* VFP_LO_REGS  */ \\\n+  { 0x00000000, 0xFFFF0000, 0x0000FFFF, 0x00000000 }, /* VFP_HI_REGS  */ \\\n+  { 0xFFFF0000, 0xFFFFFFFF, 0x0000FFFF, 0x00000000 }, /* VFP_REGS  */\t\\\n+  { 0x00000000, 0x00000000, 0xFFFF0000, 0x00000000 }, /* IWMMXT_REGS */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x0000000F }, /* IWMMXT_GR_REGS */ \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000010 }, /* CC_REG */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000020 }, /* VFPCC_REG */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000040 }, /* SFP_REG */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000080 }, /* AFP_REG */\t\\\n+  { 0xFFFF7FFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000 }  /* ALL_REGS */\t\\\n }\n \n /* Any of the VFP register classes.  */\n@@ -1220,14 +1191,11 @@ enum reg_class\n    or could index an array.  */\n #define REGNO_REG_CLASS(REGNO)  arm_regno_class (REGNO)\n \n-/* FPA registers can't do subreg as all values are reformatted to internal\n-   precision.  In VFPv1, VFP registers could only be accessed in the mode\n-   they were set, so subregs would be invalid there too.  However, we don't\n-   support VFPv1 at the moment, and the restriction was lifted in VFPv2.  */\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)\t\t\t\\\n-   ? reg_classes_intersect_p (FPA_REGS, (CLASS))\t\t\\\n-   : 0)\n+/* In VFPv1, VFP registers could only be accessed in the mode they\n+   were set, so subregs would be invalid there.  However, we don't\n+   support VFPv1 at the moment, and the restriction was lifted in\n+   VFPv2.  */\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) 0\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS  (TARGET_THUMB1 ? LO_REGS : GENERAL_REGS)\n@@ -1289,21 +1257,16 @@ enum reg_class\n     ? coproc_secondary_reload_class (MODE, X, FALSE) :\t\t\\\n     (TARGET_IWMMXT && (CLASS) == IWMMXT_REGS) ?\t\t\t\\\n     coproc_secondary_reload_class (MODE, X, TRUE) :\t\t\\\n-  /* Cannot load constants into Cirrus registers.  */\t\t\\\n-   (TARGET_MAVERICK && TARGET_HARD_FLOAT\t\t\t\\\n-     && (CLASS) == CIRRUS_REGS\t\t\t\t\t\\\n-     && (CONSTANT_P (X) || GET_CODE (X) == SYMBOL_REF))\t\t\\\n+   (TARGET_32BIT ?\t\t\t\t\t\t\\\n+    (((CLASS) == IWMMXT_REGS || (CLASS) == IWMMXT_GR_REGS)\t\\\n+     && CONSTANT_P (X))\t\t\t\t\t\t\\\n     ? GENERAL_REGS :\t\t\t\t\t\t\\\n-  (TARGET_32BIT ?\t\t\t\t\t\t\\\n-   (((CLASS) == IWMMXT_REGS || (CLASS) == IWMMXT_GR_REGS)\t\\\n-      && CONSTANT_P (X))\t\t\t\t\t\\\n-   ? GENERAL_REGS :\t\t\t\t\t\t\\\n-   (((MODE) == HImode && ! arm_arch4\t\t\t\t\\\n-     && (GET_CODE (X) == MEM\t\t\t\t\t\\\n-\t || ((GET_CODE (X) == REG || GET_CODE (X) == SUBREG)\t\\\n-\t     && true_regnum (X) == -1)))\t\t\t\\\n-    ? GENERAL_REGS : NO_REGS)\t\t\t\t\t\\\n-   : THUMB_SECONDARY_INPUT_RELOAD_CLASS (CLASS, MODE, X)))\n+    (((MODE) == HImode && ! arm_arch4\t\t\t\t\\\n+      && (GET_CODE (X) == MEM\t\t\t\t\t\\\n+\t  || ((GET_CODE (X) == REG || GET_CODE (X) == SUBREG)\t\\\n+\t      && true_regnum (X) == -1)))\t\t\t\\\n+     ? GENERAL_REGS : NO_REGS)\t\t\t\t\t\\\n+    : THUMB_SECONDARY_INPUT_RELOAD_CLASS (CLASS, MODE, X)))\n \n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n@@ -1347,9 +1310,10 @@ do {\t\t\t\t\t\t\t\t\t      \\\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n-   ARM regs are UNITS_PER_WORD bits while FPA regs can hold any FP mode */\n+   ARM regs are UNITS_PER_WORD bits.  \n+   FIXME: Is this true for iWMMX?  */\n #define CLASS_MAX_NREGS(CLASS, MODE)  \\\n-  (((CLASS) == FPA_REGS || (CLASS) == CIRRUS_REGS) ? 1 : ARM_NUM_REGS (MODE))\n+  (ARM_NUM_REGS (MODE))\n \n /* If defined, gives a class of registers that cannot be used as the\n    operand of a SUBREG that changes the mode of the object illegally.  */"}, {"sha": "db404e79453707519ef28448a03afb152b1234cf", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "patch": "@@ -28,18 +28,17 @@\n ;;---------------------------------------------------------------------------\n ;; Constants\n \n-;; Register numbers\n+;; Register numbers -- All machine registers should be defined here\n (define_constants\n-  [(R0_REGNUM        0)\t\t; First CORE register\n-   (R1_REGNUM\t     1)\t\t; Second CORE register\n-   (IP_REGNUM\t    12)\t\t; Scratch register\n-   (SP_REGNUM\t    13)\t\t; Stack pointer\n-   (LR_REGNUM       14)\t\t; Return address register\n-   (PC_REGNUM\t    15)\t\t; Program counter\n-   (CC_REGNUM       24)\t\t; Condition code pseudo register\n-   (LAST_ARM_REGNUM 15)\t\t;\n-   (FPA_F0_REGNUM   16)\t\t; FIRST_FPA_REGNUM\n-   (FPA_F7_REGNUM   23)\t\t; LAST_FPA_REGNUM\n+  [(R0_REGNUM         0)\t; First CORE register\n+   (R1_REGNUM\t      1)\t; Second CORE register\n+   (IP_REGNUM\t     12)\t; Scratch register\n+   (SP_REGNUM\t     13)\t; Stack pointer\n+   (LR_REGNUM        14)\t; Return address register\n+   (PC_REGNUM\t     15)\t; Program counter\n+   (LAST_ARM_REGNUM  15)\t;\n+   (CC_REGNUM       100)\t; Condition code pseudo register\n+   (VFPCC_REGNUM    101)\t; VFP Condition code pseudo register\n   ]\n )\n ;; 3rd operand to select_dominance_cc_mode\n@@ -178,7 +177,7 @@\n ; Floating Point Unit.  If we only have floating point emulation, then there\n ; is no point in scheduling the floating point insns.  (Well, for best\n ; performance we should try and group them together).\n-(define_attr \"fpu\" \"none,fpa,fpe2,fpe3,maverick,vfp\"\n+(define_attr \"fpu\" \"none,vfp\"\n   (const (symbol_ref \"arm_fpu_attr\")))\n \n ; LENGTH of an instruction (in bytes)"}, {"sha": "82b4bfc7b74ac39c532556cb66a1f34ddc66a1b7", "filename": "gcc/config/arm/linux-elf.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Flinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Flinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-elf.h?ref=0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "patch": "@@ -92,9 +92,8 @@\n     }\t\t\t\t\t   \\\n   while (0)\n \n-/* NWFPE always understands FPA instructions.  */\n #undef  FPUTYPE_DEFAULT\n-#define FPUTYPE_DEFAULT \"fpe3\"\n+#define FPUTYPE_DEFAULT \"vfp\"\n \n /* Call the function profiler with a given profile label.  */\n #undef  ARM_FUNCTION_PROFILER"}, {"sha": "8369949580439c5118a996c8c9681cbd95a2dbef", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=0be8bd1a1c89c670b6c325e4896c6cfd3b97fe1d", "patch": "@@ -19,11 +19,6 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.  */\n \n-;; Additional register numbers\n-(define_constants\n-  [(VFPCC_REGNUM 127)]\n-)\n-\n ;; The VFP \"type\" attributes differ from those used in the FPA model.\n ;; fcpys\tSingle precision cpy.\n ;; ffariths\tSingle precision abs, neg."}]}