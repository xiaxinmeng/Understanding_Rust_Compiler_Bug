{"sha": "e9d2adc17d0dbe46db67e1b618dea888d5c7aca3", "node_id": "C_kwDOANBUbNoAKGU5ZDJhZGMxN2QwZGJlNDZkYjY3ZTFiNjE4ZGVhODg4ZDVjN2FjYTM", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-04-08T17:48:25Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-04-29T21:25:03Z"}, "message": "c++: reorganize friend template matching [PR91618]\n\nThe the different calling of check_explicit_specialization for class and\nnamespace scope friends bothered me, so this patch combines them.\n\n\tPR c++/91618\n\tPR c++/96604\n\ngcc/cp/ChangeLog:\n\n\t* friend.cc (do_friend): Call check_explicit_specialization here.\n\t* decl.cc (grokdeclarator): Not here.\n\t* decl2.cc (check_classfn): Or here.", "tree": {"sha": "5e62d35604cca84d2ef20450fc4c98cf468ec01b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e62d35604cca84d2ef20450fc4c98cf468ec01b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9d2adc17d0dbe46db67e1b618dea888d5c7aca3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d2adc17d0dbe46db67e1b618dea888d5c7aca3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d2adc17d0dbe46db67e1b618dea888d5c7aca3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d2adc17d0dbe46db67e1b618dea888d5c7aca3/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4259c229b457361a9b5cdec157e058bf0c2c8b77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4259c229b457361a9b5cdec157e058bf0c2c8b77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4259c229b457361a9b5cdec157e058bf0c2c8b77"}], "stats": {"total": 110, "additions": 49, "deletions": 61}, "files": [{"sha": "324498f399dbd98ca4b827c0ba20a04ecb9d6bfa", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d2adc17d0dbe46db67e1b618dea888d5c7aca3/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d2adc17d0dbe46db67e1b618dea888d5c7aca3/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=e9d2adc17d0dbe46db67e1b618dea888d5c7aca3", "patch": "@@ -14142,15 +14142,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t     So set it here.  */\n \t\t  funcdef_flag = true;\n \n-\t\tif (template_class_depth (current_class_type) == 0)\n-\t\t  {\n-\t\t    decl = check_explicit_specialization\n-\t\t      (unqualified_id, decl, template_count,\n-\t\t       2 * funcdef_flag + 4);\n-\t\t    if (decl == error_mark_node)\n-\t\t      return error_mark_node;\n-\t\t  }\n-\n \t\tdecl = do_friend (ctype, unqualified_id, decl,\n \t\t\t\t  flags, funcdef_flag);\n \t\treturn decl;"}, {"sha": "ae743c8a3df177e7c81b8269ede7a82f3d83db2b", "filename": "gcc/cp/decl2.cc", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d2adc17d0dbe46db67e1b618dea888d5c7aca3/gcc%2Fcp%2Fdecl2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d2adc17d0dbe46db67e1b618dea888d5c7aca3/gcc%2Fcp%2Fdecl2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.cc?ref=e9d2adc17d0dbe46db67e1b618dea888d5c7aca3", "patch": "@@ -799,14 +799,9 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \t is replaced with the specialization chosen by deduction from the\n \t friend declaration or discarded if deduction fails.\"\n \n-\t So ask check_explicit_specialization to find a matching template.  */\n+\t So tell check_explicit_specialization to look for a match.  */\n       SET_DECL_IMPLICIT_INSTANTIATION (function);\n-      tree spec = check_explicit_specialization (DECL_NAME (function),\n-\t\t\t\t\t\t function, /* tcount */0,\n-\t\t\t\t\t\t /* friend flag */4,\n-\t\t\t\t\t\t /* attrlist */NULL_TREE);\n-      if (spec != error_mark_node)\n-\tmatched = spec;\n+      matched = function;\n     }\n \n   if (!matched)"}, {"sha": "124ed4f3962d82a44c8a2a699afdb80eb1bb7929", "filename": "gcc/cp/friend.cc", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d2adc17d0dbe46db67e1b618dea888d5c7aca3/gcc%2Fcp%2Ffriend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d2adc17d0dbe46db67e1b618dea888d5c7aca3/gcc%2Fcp%2Ffriend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.cc?ref=e9d2adc17d0dbe46db67e1b618dea888d5c7aca3", "patch": "@@ -506,39 +506,41 @@ do_friend (tree ctype, tree declarator, tree decl,\n     error (\"friend declaration %qD may not have virt-specifiers\",\n \t   decl);\n \n+  tree orig_declarator = declarator;\n   if (TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n     {\n       declarator = TREE_OPERAND (declarator, 0);\n       if (!identifier_p (declarator))\n \tdeclarator = OVL_NAME (declarator);\n     }\n \n+  /* CLASS_TEMPLATE_DEPTH counts the number of template headers for\n+     the enclosing class.  FRIEND_DEPTH counts the number of template\n+     headers used for this friend declaration.  TEMPLATE_MEMBER_P is\n+     true if a template header in FRIEND_DEPTH is intended for\n+     DECLARATOR.  For example, the code\n+\n+     template <class T> struct A {\n+       template <class U> struct B {\n+\t template <class V> template <class W>\n+\t   friend void C<V>::f(W);\n+       };\n+     };\n+\n+     will eventually give the following results\n+\n+     1. CLASS_TEMPLATE_DEPTH equals 2 (for `T' and `U').\n+     2. FRIEND_DEPTH equals 2 (for `V' and `W').\n+     3. CTYPE_DEPTH equals 1 (for `V').\n+     4. TEMPLATE_MEMBER_P is true (for `W').  */\n+\n+  int class_template_depth = template_class_depth (current_class_type);\n+  int friend_depth = current_template_depth - class_template_depth;\n+  int ctype_depth = num_template_headers_for_class (ctype);\n+  bool template_member_p = friend_depth > ctype_depth;\n+\n   if (ctype)\n     {\n-      /* CLASS_TEMPLATE_DEPTH counts the number of template headers for\n-\t the enclosing class.  FRIEND_DEPTH counts the number of template\n-\t headers used for this friend declaration.  TEMPLATE_MEMBER_P is\n-\t true if a template header in FRIEND_DEPTH is intended for\n-\t DECLARATOR.  For example, the code\n-\n-\t   template <class T> struct A {\n-\t     template <class U> struct B {\n-\t       template <class V> template <class W>\n-\t\t friend void C<V>::f(W);\n-\t     };\n-\t   };\n-\n-\t will eventually give the following results\n-\n-\t 1. CLASS_TEMPLATE_DEPTH equals 2 (for `T' and `U').\n-\t 2. FRIEND_DEPTH equals 2 (for `V' and `W').\n-\t 3. TEMPLATE_MEMBER_P is true (for `W').  */\n-\n-      int class_template_depth = template_class_depth (current_class_type);\n-      int friend_depth = current_template_depth - class_template_depth;\n-      /* We will figure this out later.  */\n-      bool template_member_p = false;\n-\n       tree cname = TYPE_NAME (ctype);\n       if (TREE_CODE (cname) == TYPE_DECL)\n \tcname = DECL_NAME (cname);\n@@ -549,13 +551,6 @@ do_friend (tree ctype, tree declarator, tree decl,\n \n       grokclassfn (ctype, decl, flags);\n \n-      if (friend_depth)\n-\t{\n-\t  if (!uses_template_parms_level (ctype, class_template_depth\n-\t\t\t\t\t\t + friend_depth))\n-\t    template_member_p = true;\n-\t}\n-\n       /* A nested class may declare a member of an enclosing class\n \t to be a friend, so we do lookup here even if CTYPE is in\n \t the process of being defined.  */\n@@ -584,9 +579,6 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t       || (class_template_depth && friend_depth))\n \t      && decl && TREE_CODE (decl) == FUNCTION_DECL)\n \t    decl = DECL_TI_TEMPLATE (decl);\n-\n-\t  if (decl)\n-\t    add_friend (current_class_type, decl, /*complain=*/true);\n \t}\n       else\n \terror (\"member %qD declared as friend before type %qT defined\",\n@@ -595,7 +587,6 @@ do_friend (tree ctype, tree declarator, tree decl,\n   else\n     {\n       /* Namespace-scope friend function.  */\n-      int is_friend_template = PROCESSING_REAL_TEMPLATE_DECL_P ();\n \n       if (funcdef_flag)\n \tSET_DECL_FRIEND_CONTEXT (decl, current_class_type);\n@@ -606,12 +597,11 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t     arguments before push_template_decl adds a reference to\n \t     the containing template class.  */\n \t  int warn = (warn_nontemplate_friend\n-\t\t      && ! funcdef_flag && ! is_friend_template\n+\t\t      && ! funcdef_flag && ! friend_depth\n \t\t      && current_template_parms\n \t\t      && uses_template_parms (decl));\n \n-\t  if (is_friend_template\n-\t      || template_class_depth (current_class_type) != 0)\n+\t  if (friend_depth || class_template_depth)\n \t    /* We can't call pushdecl for a template class, since in\n \t       general, such a declaration depends on template\n \t       parameters.  Instead, we call pushdecl when the class\n@@ -651,15 +641,27 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t\t}\n \t    }\n \t}\n-\n-      if (decl == error_mark_node)\n-\treturn error_mark_node;\n-\n-      add_friend (current_class_type,\n-\t\t  is_friend_template ? DECL_TI_TEMPLATE (decl) : decl,\n-\t\t  /*complain=*/true);\n     }\n \n+  if (decl == error_mark_node)\n+    return error_mark_node;\n+\n+  if (!class_template_depth && DECL_IMPLICIT_INSTANTIATION (decl))\n+    /* \"[if no non-template match is found,] each remaining function template\n+       is replaced with the specialization chosen by deduction from the\n+       friend declaration or discarded if deduction fails.\"\n+\n+       set_decl_namespace or check_classfn set DECL_IMPLICIT_INSTANTIATION to\n+       indicate that we need a template match, so ask\n+       check_explicit_specialization to find one.  */\n+    decl = (check_explicit_specialization\n+\t    (orig_declarator, decl, ctype_depth,\n+\t     2 * funcdef_flag + 4));\n+\n+  add_friend (current_class_type,\n+\t      (!ctype && friend_depth) ? DECL_TI_TEMPLATE (decl) : decl,\n+\t      /*complain=*/true);\n+\n   return decl;\n }\n "}]}