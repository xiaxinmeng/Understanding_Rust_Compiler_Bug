{"sha": "4a0cafdda88f0f9993467067bb7ed4b5f7281f75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEwY2FmZGRhODhmMGY5OTkzNDY3MDY3YmI3ZWQ0YjVmNzI4MWY3NQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2017-12-14T15:03:09Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2017-12-14T15:03:09Z"}, "message": "[compare-debug] use call loc for nop_endbr\n\nWe skip debug insns and notes after a call that needs a nop_endbr, but\nsince a debug insn could be the last in a block, it may affect the loc\nin the emitted nop_endbr insn.  Although this has no effect on\ncodegen, it does mess with debug info a bit, and it causes\n-fcompare-debug to fail for e.g. libsanitizer's\ntsan/tsan_platform_linux.cc on x86_64.\n\nSo, pick the location of the call insn for the nop_endbr insn, to\navoid the line number differences in dumps, including -fcompare-debug\nones.\n\nAlso, we don't need to determine what the insert point would be unless\nwe're actually emitting the nop_endbr insn after the call, so\nrearrange the code to avoid wasting cycles.\n\nFinally, it seems like testing for barriers is a mistake.  We probably\nnever actually pass that test, for the barriers would hit BB_END\nfirst.  If we did, we'd end up emitting the nop_endbr outside any BB,\neven after the end of the function!  That would be Very Bad (TM).\nNow, since the test as it is can't hurt, I figured I wouldn't change\nthe logic right now, just add a comment so that someone involved in\nendbr stuff can have a second look and hopefully fix it.\n\nfor  gcc/ChangeLog\n\n\t* config/i386/i386.c (rest_of_insert_endbranch): Use call loc\n\tfor its nop_endbr.\n\nFrom-SVN: r255639", "tree": {"sha": "c8073edf762e1ecf67435fbd269555ae646dd524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8073edf762e1ecf67435fbd269555ae646dd524"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a0cafdda88f0f9993467067bb7ed4b5f7281f75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a0cafdda88f0f9993467067bb7ed4b5f7281f75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a0cafdda88f0f9993467067bb7ed4b5f7281f75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a0cafdda88f0f9993467067bb7ed4b5f7281f75/comments", "author": null, "committer": null, "parents": [{"sha": "c483db37a4d962ed2a60919c33629d080629fea6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c483db37a4d962ed2a60919c33629d080629fea6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c483db37a4d962ed2a60919c33629d080629fea6"}], "stats": {"total": 23, "additions": 15, "deletions": 8}, "files": [{"sha": "5805e116ff5e61bd1a4c6a551afcedce7599a8d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a0cafdda88f0f9993467067bb7ed4b5f7281f75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a0cafdda88f0f9993467067bb7ed4b5f7281f75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a0cafdda88f0f9993467067bb7ed4b5f7281f75", "patch": "@@ -1,5 +1,8 @@\n 2017-12-14  Alexandre Oliva <aoliva@redhat.com>\n \n+\t* config/i386/i386.c (rest_of_insert_endbranch): Use call loc\n+\tfor its nop_endbr.\n+\n \tPR bootstrap/83396\n \t* config/arc/arc.c (hwloop_optimize): Skip debug insns.\n \t* config/sh/sh-protos.h (sh_find_set_of_reg): Adjust."}, {"sha": "35037434bf50ec26bd254e444542b29e4f04360e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a0cafdda88f0f9993467067bb7ed4b5f7281f75/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a0cafdda88f0f9993467067bb7ed4b5f7281f75/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4a0cafdda88f0f9993467067bb7ed4b5f7281f75", "patch": "@@ -2609,21 +2609,25 @@ rest_of_insert_endbranch (void)\n \t{\n \t  if (INSN_P (insn) && GET_CODE (insn) == CALL_INSN)\n \t    {\n-\t      rtx_insn *next_insn = insn;\n+\t      if (find_reg_note (insn, REG_SETJMP, NULL) == NULL)\n+\t\tcontinue;\n+\t      /* Generate ENDBRANCH after CALL, which can return more than\n+\t\t twice, setjmp-like functions.  */\n \n+\t      /* Skip notes and debug insns that must be next to the\n+\t\t call insn.  ??? This might skip a lot more than\n+\t\t that...  ??? Skipping barriers and emitting code\n+\t\t after them surely looks like a mistake; we probably\n+\t\t won't ever hit it, for we'll hit BB_END first.  */\n+\t      rtx_insn *next_insn = insn;\n \t      while ((next_insn != BB_END (bb))\n \t\t      && (DEBUG_INSN_P (NEXT_INSN (next_insn))\n \t\t\t  || NOTE_P (NEXT_INSN (next_insn))\n \t\t\t  || BARRIER_P (NEXT_INSN (next_insn))))\n \t\tnext_insn = NEXT_INSN (next_insn);\n \n-\t      /* Generate ENDBRANCH after CALL, which can return more than\n-\t\t twice, setjmp-like functions.  */\n-\t      if (find_reg_note (insn, REG_SETJMP, NULL) != NULL)\n-\t\t{\n-\t\t  cet_eb = gen_nop_endbr ();\n-\t\t  emit_insn_after (cet_eb, next_insn);\n-\t\t}\n+\t      cet_eb = gen_nop_endbr ();\n+\t      emit_insn_after_setloc (cet_eb, next_insn, INSN_LOCATION (insn));\n \t      continue;\n \t    }\n "}]}