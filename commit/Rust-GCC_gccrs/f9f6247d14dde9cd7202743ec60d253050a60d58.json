{"sha": "f9f6247d14dde9cd7202743ec60d253050a60d58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlmNjI0N2QxNGRkZTljZDcyMDI3NDNlYzYwZDI1MzA1MGE2MGQ1OA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:03:58Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:03:58Z"}, "message": "[arm] Cleanup dead code - old support for DImode comparisons\n\nNow that all the major patterns for DImode have been converted to\nearly expansion, we can safely clean up some dead code for the old way\nof handling DImode.\n\n\t* config/arm/arm-modes.def (CC_NCV, CC_CZ): Delete CC modes.\n\t* config/arm/arm.c (arm_select_cc_mode): Remove old selection code\n\tfor DImode operands.\n\t(arm_gen_dicompare_reg): Remove unreachable expansion code.\n\t(maybe_get_arm_condition_code): Remove support for CC_CZmode and\n\tCC_NCVmode.\n\t* config/arm/arm.md (arm_cmpdi_insn): Delete.\n\t(arm_cmpdi_unsigned): Delete.\n\nFrom-SVN: r277181", "tree": {"sha": "5cb99a37be6e79e5d57002fae9f2fcae84e4cd36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cb99a37be6e79e5d57002fae9f2fcae84e4cd36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9f6247d14dde9cd7202743ec60d253050a60d58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f6247d14dde9cd7202743ec60d253050a60d58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9f6247d14dde9cd7202743ec60d253050a60d58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f6247d14dde9cd7202743ec60d253050a60d58/comments", "author": null, "committer": null, "parents": [{"sha": "af74bfeee1faccef25dc0086d4249eb0f127c820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af74bfeee1faccef25dc0086d4249eb0f127c820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af74bfeee1faccef25dc0086d4249eb0f127c820"}], "stats": {"total": 208, "additions": 12, "deletions": 196}, "files": [{"sha": "7c015cdd61f5f87c362f649485e09b2523977339", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f6247d14dde9cd7202743ec60d253050a60d58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f6247d14dde9cd7202743ec60d253050a60d58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9f6247d14dde9cd7202743ec60d253050a60d58", "patch": "@@ -1,3 +1,14 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm-modes.def (CC_NCV, CC_CZ): Delete CC modes.\n+\t* config/arm/arm.c (arm_select_cc_mode): Remove old selection code\n+\tfor DImode operands.\n+\t(arm_gen_dicompare_reg): Remove unreachable expansion code.\n+\t(maybe_get_arm_condition_code): Remove support for CC_CZmode and\n+\tCC_NCVmode.\n+\t* config/arm/arm.md (arm_cmpdi_insn): Delete.\n+\t(arm_cmpdi_unsigned): Delete.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.c (arm_const_double_prefer_rsbs_rsc): New function."}, {"sha": "f0eb8415b937b16d8b2762be60c47a0c65b40193", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f6247d14dde9cd7202743ec60d253050a60d58/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f6247d14dde9cd7202743ec60d253050a60d58/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=f9f6247d14dde9cd7202743ec60d253050a60d58", "patch": "@@ -36,21 +36,16 @@ ADJUST_FLOAT_FORMAT (HF, ((arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)\n    CC_Nmode should be used if only the N (sign) flag is set correctly\n    CC_NVmode should be used if only the N and V bits are set correctly,\n      (used for signed comparisons when the carry is propagated in).\n-   CC_CZmode should be used if only the C and Z flags are correct\n-   (used for DImode unsigned comparisons).\n    CC_RSBmode should be used where the comparison is set by an RSB immediate,\n      or NEG instruction.  The form of the comparison for (const - reg) will\n      be (COMPARE (not (reg)) (~const)).\n-   CC_NCVmode should be used if only the N, C, and V flags are correct\n    CC_Bmode should be used if only the C flag is correct after a subtract\n      (eg after an unsigned borrow with carry-in propagation).\n    (used for DImode signed comparisons).\n    CCmode should be used otherwise.  */\n \n CC_MODE (CC_NOOV);\n CC_MODE (CC_Z);\n-CC_MODE (CC_CZ);\n-CC_MODE (CC_NCV);\n CC_MODE (CC_NV);\n CC_MODE (CC_SWP);\n CC_MODE (CC_RSB);"}, {"sha": "6c1e9132ca8d325ac4fd84014b9b31460902875b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 146, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f6247d14dde9cd7202743ec60d253050a60d58/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f6247d14dde9cd7202743ec60d253050a60d58/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f9f6247d14dde9cd7202743ec60d253050a60d58", "patch": "@@ -15403,56 +15403,6 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \t  || arm_borrow_operation (y, DImode)))\n     return CC_Bmode;\n \n-  if (GET_MODE (x) == DImode || GET_MODE (y) == DImode)\n-    {\n-      switch (op)\n-\t{\n-\tcase EQ:\n-\tcase NE:\n-\t  /* A DImode comparison against zero can be implemented by\n-\t     or'ing the two halves together.  We can also handle\n-\t     immediates where one word of that value is zero by\n-\t     subtracting the non-zero word from the corresponding word\n-\t     in the other register and then ORRing it with the other\n-\t     word.  */\n-\t  if (CONST_INT_P (y)\n-\t      && ((UINTVAL (y) & 0xffffffff) == 0\n-\t\t  || (UINTVAL (y) >> 32) == 0))\n-\t    return CC_Zmode;\n-\n-\t  /* We can do an equality test in three Thumb instructions.  */\n-\t  if (!TARGET_32BIT)\n-\t    return CC_Zmode;\n-\n-\t  /* FALLTHROUGH */\n-\n-\tcase LTU:\n-\tcase LEU:\n-\tcase GTU:\n-\tcase GEU:\n-\t  /* DImode unsigned comparisons can be implemented by cmp +\n-\t     cmpeq without a scratch register.  Not worth doing in\n-\t     Thumb-2.  */\n-\t  if (TARGET_32BIT)\n-\t    return CC_CZmode;\n-\n-\t  /* FALLTHROUGH */\n-\n-\tcase LT:\n-\tcase LE:\n-\tcase GT:\n-\tcase GE:\n-\t  /* DImode signed and unsigned comparisons can be implemented\n-\t     by cmp + sbcs with a scratch register, but that does not\n-\t     set the Z flag - we must reverse GT/LE/GTU/LEU.  */\n-\t  gcc_assert (op != EQ && op != NE);\n-\t  return CC_NCVmode;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-\n   if (GET_MODE_CLASS (GET_MODE (x)) == MODE_CC)\n     return GET_MODE (x);\n \n@@ -15673,81 +15623,8 @@ arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n       }\n \n     default:\n-      break;\n-    }\n-\n-  /* We might have X as a constant, Y as a register because of the predicates\n-     used for cmpdi.  If so, force X to a register here.  */\n-  if (!REG_P (x))\n-    x = force_reg (DImode, x);\n-\n-  mode = SELECT_CC_MODE (code, x, y);\n-  cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n-\n-  if (mode != CC_CZmode)\n-    {\n-      rtx clobber, set;\n-\n-      /* To compare two non-zero values for equality, XOR them and\n-\t then compare against zero.  Not used for ARM mode; there\n-\t CC_CZmode is cheaper.  */\n-      if (mode == CC_Zmode)\n-\t{\n-\t  mode = CC_NOOVmode;\n-\t  PUT_MODE (cc_reg, mode);\n-\t  if (y != const0_rtx)\n-\t    {\n-\t      gcc_assert (CONST_INT_P (y));\n-\t      rtx xlo, xhi, ylo, yhi;\n-\t      arm_decompose_di_binop (x, y, &xlo, &xhi, &ylo, &yhi);\n-\t      if (!scratch)\n-\t\tscratch = gen_reg_rtx (SImode);\n-\t      if (ylo == const0_rtx)\n-\t\t{\n-\t\t  yhi = gen_int_mode (-INTVAL (yhi), SImode);\n-\t\t  if (!arm_add_operand (yhi, SImode))\n-\t\t    yhi = force_reg (SImode, yhi);\n-\t\t  emit_insn (gen_addsi3 (scratch, xhi, yhi));\n-\t\t  y = xlo;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  gcc_assert (yhi == const0_rtx);\n-\t\t  ylo = gen_int_mode (-INTVAL (ylo), SImode);\n-\t\t  if (!arm_add_operand (ylo, SImode))\n-\t\t    ylo = force_reg (SImode, ylo);\n-\t\t  emit_insn (gen_addsi3 (scratch, xlo, ylo));\n-\t\t  y = xhi;\n-\t\t}\n-\t      x = gen_rtx_IOR (SImode, scratch, y);\n-\t      y = const0_rtx;\n-\t    }\n-\t  else\n-\t    x = gen_rtx_IOR (SImode, gen_lowpart (SImode, x),\n-\t\t\t     gen_highpart (SImode, x));\n-\t}\n-      else if (!cmpdi_operand (y, mode))\n-\ty = force_reg (DImode, y);\n-\n-      /* A scratch register is required.  */\n-      if (reload_completed)\n-\tgcc_assert (scratch != NULL && GET_MODE (scratch) == SImode);\n-      else\n-\tscratch = gen_rtx_SCRATCH (SImode);\n-\n-      clobber = gen_rtx_CLOBBER (VOIDmode, scratch);\n-      set = gen_rtx_SET (cc_reg, gen_rtx_COMPARE (mode, x, y));\n-      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber)));\n-    }\n-  else\n-    {\n-      if (!cmpdi_operand (y, mode))\n-\ty = force_reg (DImode, y);\n-\n-      emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));\n+      gcc_unreachable ();\n     }\n-\n-  return cc_reg;\n }\n \n /* X and Y are two things to compare using CODE.  Emit the compare insn and\n@@ -24051,28 +23928,6 @@ maybe_get_arm_condition_code (rtx comparison)\n \tdefault: return ARM_NV;\n \t}\n \n-    case E_CC_CZmode:\n-      switch (comp_code)\n-\t{\n-\tcase NE: return ARM_NE;\n-\tcase EQ: return ARM_EQ;\n-\tcase GEU: return ARM_CS;\n-\tcase GTU: return ARM_HI;\n-\tcase LEU: return ARM_LS;\n-\tcase LTU: return ARM_CC;\n-\tdefault: return ARM_NV;\n-\t}\n-\n-    case E_CC_NCVmode:\n-      switch (comp_code)\n-\t{\n-\tcase GE: return ARM_GE;\n-\tcase LT: return ARM_LT;\n-\tcase GEU: return ARM_CS;\n-\tcase LTU: return ARM_CC;\n-\tdefault: return ARM_NV;\n-\t}\n-\n     case E_CC_NVmode:\n       switch (comp_code)\n \t{"}, {"sha": "eaadfd64128b8d9e30ad31c862280a71b61a12c3", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f6247d14dde9cd7202743ec60d253050a60d58/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f6247d14dde9cd7202743ec60d253050a60d58/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=f9f6247d14dde9cd7202743ec60d253050a60d58", "patch": "@@ -6545,51 +6545,6 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-;; DImode comparisons.  The generic code generates branches that\n-;; if-conversion cannot reduce to a conditional compare, so we do\n-;; that directly.\n-\n-(define_insn \"*arm_cmpdi_insn\"\n-  [(set (reg:CC_NCV CC_REGNUM)\n-\t(compare:CC_NCV (match_operand:DI 0 \"s_register_operand\" \"r\")\n-\t\t\t(match_operand:DI 1 \"arm_di_operand\"\t   \"rDi\")))\n-   (clobber (match_scratch:SI 2 \"=r\"))]\n-  \"TARGET_32BIT\"\n-  \"cmp\\\\t%Q0, %Q1\\;sbcs\\\\t%2, %R0, %R1\"\n-  [(set_attr \"conds\" \"set\")\n-   (set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn_and_split \"*arm_cmpdi_unsigned\"\n-  [(set (reg:CC_CZ CC_REGNUM)\n-        (compare:CC_CZ (match_operand:DI 0 \"s_register_operand\" \"l,r,r,r\")\n-                       (match_operand:DI 1 \"arm_di_operand\"     \"Py,r,Di,rDi\")))]\n-\n-  \"TARGET_32BIT\"\n-  \"#\"   ; \"cmp\\\\t%R0, %R1\\;it eq\\;cmpeq\\\\t%Q0, %Q1\"\n-  \"&& reload_completed\"\n-  [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_dup 2) (match_dup 3)))\n-   (cond_exec (eq:SI (reg:CC CC_REGNUM) (const_int 0))\n-              (set (reg:CC CC_REGNUM)\n-                   (compare:CC (match_dup 0) (match_dup 1))))]\n-  {\n-    operands[2] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    if (CONST_INT_P (operands[1]))\n-      operands[3] = gen_highpart_mode (SImode, DImode, operands[1]);\n-    else\n-      operands[3] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-  }\n-  [(set_attr \"conds\" \"set\")\n-   (set_attr \"enabled_for_short_it\" \"yes,yes,no,*\")\n-   (set_attr \"arch\" \"t2,t2,t2,a\")\n-   (set_attr \"length\" \"6,6,10,8\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n ; This insn allows redundant compares to be removed by cse, nothing should\n ; ever appear in the output file since (set (reg x) (reg x)) is a no-op that\n ; is deleted later on. The match_dup will match the mode here, so that"}]}