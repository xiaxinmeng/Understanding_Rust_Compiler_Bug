{"sha": "c0da9742e547dc0c83a1056062fe1deb8177971b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBkYTk3NDJlNTQ3ZGMwYzgzYTEwNTYwNjJmZTFkZWI4MTc3OTcxYg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2006-12-12T11:05:54Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2006-12-12T11:05:54Z"}, "message": "vxlib.c: Extract tls related routines into ...\n\n\t* config/vxlib.c: Extract tls related routines into ...\n\t* config/vxlib-tls.c: New file. \n\t* config/t-vxworks: Add vxlib-tls.c to LIB2FUNCS_EXTRA.\n\nFrom-SVN: r119771", "tree": {"sha": "32388c70556c0603241ffc6d6d693eb359249da9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32388c70556c0603241ffc6d6d693eb359249da9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0da9742e547dc0c83a1056062fe1deb8177971b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0da9742e547dc0c83a1056062fe1deb8177971b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0da9742e547dc0c83a1056062fe1deb8177971b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0da9742e547dc0c83a1056062fe1deb8177971b/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "253e0d15a5651e750781cc3936ec5ff4da522eb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/253e0d15a5651e750781cc3936ec5ff4da522eb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/253e0d15a5651e750781cc3936ec5ff4da522eb4"}], "stats": {"total": 657, "additions": 359, "deletions": 298}, "files": [{"sha": "6c7c1d0e3b146149f30e0f924680b3e153fc7e4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0da9742e547dc0c83a1056062fe1deb8177971b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0da9742e547dc0c83a1056062fe1deb8177971b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0da9742e547dc0c83a1056062fe1deb8177971b", "patch": "@@ -1,3 +1,9 @@\n+2006-12-12  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* config/vxlib.c: Extract tls related routines into ...\n+\t* config/vxlib-tls.c: New file. \n+\t* config/t-vxworks: Add vxlib-tls.c to LIB2FUNCS_EXTRA.\n+\t\n 2006-12-12  Sa Liu  <saliu@de.ibm.com>\n \t    Ben Elliston  <bje@au.ibm.com>\n "}, {"sha": "1eac999d8703b066ad57ab1e30e8b6341a01ca71", "filename": "gcc/config/t-vxworks", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0da9742e547dc0c83a1056062fe1deb8177971b/gcc%2Fconfig%2Ft-vxworks", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0da9742e547dc0c83a1056062fe1deb8177971b/gcc%2Fconfig%2Ft-vxworks", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-vxworks?ref=c0da9742e547dc0c83a1056062fe1deb8177971b", "patch": "@@ -11,8 +11,8 @@ TARGET_LIBGCC2_CFLAGS =\n # Don't build libgcc.a with debug info\n LIBGCC2_DEBUG_CFLAGS =\n \n-# Extra libgcc2 module used by gthr-vxworks.h functions\n-LIB2FUNCS_EXTRA = $(srcdir)/config/vxlib.c\n+# Extra libgcc2 modules used by gthr-vxworks.h functions\n+LIB2FUNCS_EXTRA = $(srcdir)/config/vxlib.c $(srcdir)/config/vxlib-tls.c\n \n # Some runtime modules need these.  Can't set extra_headers in config.gcc\n # because the paths are always made absolute to the cpu config dir."}, {"sha": "eba8f5cf54704607cb6151f7b6d1b917e9554b28", "filename": "gcc/config/vxlib-tls.c", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0da9742e547dc0c83a1056062fe1deb8177971b/gcc%2Fconfig%2Fvxlib-tls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0da9742e547dc0c83a1056062fe1deb8177971b/gcc%2Fconfig%2Fvxlib-tls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxlib-tls.c?ref=c0da9742e547dc0c83a1056062fe1deb8177971b", "patch": "@@ -0,0 +1,351 @@\n+/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Contributed by Zack Weinberg <zack@codesourcery.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+/* Threads compatibility routines for libgcc2 for VxWorks.\n+   These are out-of-line routines called from gthr-vxworks.h. \n+\n+   This file provides the TLS related support routines, calling specific\n+   VxWorks kernel entry points for this purpose.  The base VxWorks 5.x kernels\n+   don't feature these entry points, and we provide gthr_supp_vxw_5x.c as an\n+   option to fill this gap.  Asking users to rebuild a kernel is not to be\n+   taken lightly, still, so we have isolated these routines from the rest of\n+   vxlib to ensure that the kernel dependencies are only dragged when really\n+   necessary.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"gthr.h\"\n+\n+#if defined(__GTHREADS)\n+#include <vxWorks.h>\n+#ifndef __RTP__\n+#include <vxLib.h>\n+#endif\n+#include <taskLib.h>\n+#ifndef __RTP__\n+#include <taskHookLib.h>\n+#else\n+# include <errno.h>\n+#endif\n+\n+/* Thread-local storage.\n+\n+   We reserve a field in the TCB to point to a dynamically allocated\n+   array which is used to store TLS values.  A TLS key is simply an\n+   offset in this array.  The exact location of the TCB field is not\n+   known to this code nor to vxlib.c -- all access to it indirects\n+   through the routines __gthread_get_tls_data and\n+   __gthread_set_tls_data, which are provided by the VxWorks kernel.\n+\n+   There is also a global array which records which keys are valid and\n+   which have destructors.\n+\n+   A task delete hook is installed to execute key destructors.  The\n+   routines __gthread_enter_tls_dtor_context and\n+   __gthread_leave_tls_dtor_context, which are also provided by the\n+   kernel, ensure that it is safe to call free() on memory allocated\n+   by the task being deleted.  (This is a no-op on VxWorks 5, but\n+   a major undertaking on AE.)\n+\n+   The task delete hook is only installed when at least one thread\n+   has TLS data.  This is a necessary precaution, to allow this module\n+   to be unloaded - a module with a hook can not be removed.\n+\n+   Since this interface is used to allocate only a small number of\n+   keys, the table size is small and static, which simplifies the\n+   code quite a bit.  Revisit this if and when it becomes necessary.  */\n+\n+#define MAX_KEYS 4\n+\n+/* This is the structure pointed to by the pointer returned\n+   by __gthread_get_tls_data.  */\n+struct tls_data\n+{\n+  int *owner;\n+  void *values[MAX_KEYS];\n+  unsigned int generation[MAX_KEYS];\n+};\n+\n+/* To make sure we only delete TLS data associated with this object,\n+   include a pointer to a local variable in the TLS data object.  */\n+static int self_owner;\n+\n+/* The number of threads for this module which have active TLS data.\n+   This is protected by tls_lock.  */\n+static int active_tls_threads;\n+\n+/* kernel provided routines */\n+extern void *__gthread_get_tls_data (void);\n+extern void __gthread_set_tls_data (void *data);\n+\n+extern void __gthread_enter_tls_dtor_context (void);\n+extern void __gthread_leave_tls_dtor_context (void);\n+\n+\n+/* This is a global structure which records all of the active keys.\n+\n+   A key is potentially valid (i.e. has been handed out by\n+   __gthread_key_create) iff its generation count in this structure is\n+   even.  In that case, the matching entry in the dtors array is a\n+   routine to be called when a thread terminates with a valid,\n+   non-NULL specific value for that key.\n+\n+   A key is actually valid in a thread T iff the generation count\n+   stored in this structure is equal to the generation count stored in\n+   T's specific-value structure.  */\n+\n+typedef void (*tls_dtor) (void *);\n+\n+struct tls_keys\n+{\n+  tls_dtor dtor[MAX_KEYS];\n+  unsigned int generation[MAX_KEYS];\n+};\n+\n+#define KEY_VALID_P(key) !(tls_keys.generation[key] & 1)\n+\n+/* Note: if MAX_KEYS is increased, this initializer must be updated\n+   to match.  All the generation counts begin at 1, which means no\n+   key is valid.  */\n+static struct tls_keys tls_keys =\n+{\n+  { 0, 0, 0, 0 },\n+  { 1, 1, 1, 1 }\n+};\n+\n+/* This lock protects the tls_keys structure.  */\n+static __gthread_mutex_t tls_lock;\n+\n+static __gthread_once_t tls_init_guard = __GTHREAD_ONCE_INIT;\n+\n+/* Internal routines.  */\n+\n+/* The task TCB has just been deleted.  Call the destructor\n+   function for each TLS key that has both a destructor and\n+   a non-NULL specific value in this thread.\n+\n+   This routine does not need to take tls_lock; the generation\n+   count protects us from calling a stale destructor.  It does\n+   need to read tls_keys.dtor[key] atomically.  */\n+\n+static void\n+tls_delete_hook (void *tcb ATTRIBUTE_UNUSED)\n+{\n+  struct tls_data *data = __gthread_get_tls_data ();\n+  __gthread_key_t key;\n+\n+  if (data && data->owner == &self_owner)\n+    {\n+      __gthread_enter_tls_dtor_context ();\n+      for (key = 0; key < MAX_KEYS; key++)\n+\t{\n+\t  if (data->generation[key] == tls_keys.generation[key])\n+\t    {\n+\t      tls_dtor dtor = tls_keys.dtor[key];\n+\n+\t      if (dtor)\n+\t\tdtor (data->values[key]);\n+\t    }\n+\t}\n+      free (data);\n+\n+      /* We can't handle an error here, so just leave the thread\n+\t marked as loaded if one occurs.  */\n+      if (__gthread_mutex_lock (&tls_lock) != ERROR)\n+\t{\n+\t  active_tls_threads--;\n+\t  if (active_tls_threads == 0)\n+\t    taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);\n+\t  __gthread_mutex_unlock (&tls_lock);\n+\t}\n+\n+      __gthread_set_tls_data (0);\n+      __gthread_leave_tls_dtor_context ();\n+    }\n+} \n+\n+/* Initialize global data used by the TLS system.  */\n+static void\n+tls_init (void)\n+{\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&tls_lock);\n+}\n+\n+static void tls_destructor (void) __attribute__ ((destructor));\n+static void\n+tls_destructor (void)\n+{\n+#ifdef __RTP__\n+  /* All threads but this one should have exited by now.  */\n+  tls_delete_hook (NULL);\n+#else\n+  /* Unregister the hook forcibly.  The counter of active threads may\n+     be incorrect, because constructors (like the C++ library's) and\n+     destructors (like this one) run in the context of the shell rather\n+     than in a task spawned from this module.  */\n+  taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);\n+#endif\n+\n+  if (tls_init_guard.done && __gthread_mutex_lock (&tls_lock) != ERROR)\n+    semDelete (tls_lock);\n+}\n+\n+/* External interface */\n+\n+/* Store in KEYP a value which can be passed to __gthread_setspecific/\n+   __gthread_getspecific to store and retrieve a value which is\n+   specific to each calling thread.  If DTOR is not NULL, it will be\n+   called when a thread terminates with a non-NULL specific value for\n+   this key, with the value as its sole argument.  */\n+\n+int\n+__gthread_key_create (__gthread_key_t *keyp, tls_dtor dtor)\n+{\n+  __gthread_key_t key;\n+\n+  __gthread_once (&tls_init_guard, tls_init);\n+\n+  if (__gthread_mutex_lock (&tls_lock) == ERROR)\n+    return errno;\n+\n+  for (key = 0; key < MAX_KEYS; key++)\n+    if (!KEY_VALID_P (key))\n+      goto found_slot;\n+\n+  /* no room */\n+  __gthread_mutex_unlock (&tls_lock);\n+  return EAGAIN;\n+\n+ found_slot:\n+  tls_keys.generation[key]++;  /* making it even */\n+  tls_keys.dtor[key] = dtor;\n+  *keyp = key;\n+  __gthread_mutex_unlock (&tls_lock);\n+  return 0;\n+}\n+\n+/* Invalidate KEY; it can no longer be used as an argument to\n+   setspecific/getspecific.  Note that this does NOT call destructor\n+   functions for any live values for this key.  */\n+int\n+__gthread_key_delete (__gthread_key_t key)\n+{\n+  if (key >= MAX_KEYS)\n+    return EINVAL;\n+\n+  __gthread_once (&tls_init_guard, tls_init);\n+\n+  if (__gthread_mutex_lock (&tls_lock) == ERROR)\n+    return errno;\n+\n+  if (!KEY_VALID_P (key))\n+    {\n+      __gthread_mutex_unlock (&tls_lock);\n+      return EINVAL;\n+    }\n+\n+  tls_keys.generation[key]++;  /* making it odd */\n+  tls_keys.dtor[key] = 0;\n+\n+  __gthread_mutex_unlock (&tls_lock);\n+  return 0;\n+}\n+\n+/* Retrieve the thread-specific value for KEY.  If it has never been\n+   set in this thread, or KEY is invalid, returns NULL.\n+\n+   It does not matter if this function races with key_create or\n+   key_delete; the worst that can happen is you get a value other than\n+   the one that a serialized implementation would have provided.  */\n+\n+void *\n+__gthread_getspecific (__gthread_key_t key)\n+{\n+  struct tls_data *data;\n+\n+  if (key >= MAX_KEYS)\n+    return 0;\n+\n+  data = __gthread_get_tls_data ();\n+\n+  if (!data)\n+    return 0;\n+\n+  if (data->generation[key] != tls_keys.generation[key])\n+    return 0;\n+\n+  return data->values[key];\n+}\n+\n+/* Set the thread-specific value for KEY.  If KEY is invalid, or\n+   memory allocation fails, returns -1, otherwise 0.\n+\n+   The generation count protects this function against races with\n+   key_create/key_delete; the worst thing that can happen is that a\n+   value is successfully stored into a dead generation (and then\n+   immediately becomes invalid).  However, we do have to make sure\n+   to read tls_keys.generation[key] atomically.  */\n+\n+int\n+__gthread_setspecific (__gthread_key_t key, void *value)\n+{\n+  struct tls_data *data;\n+  unsigned int generation;\n+\n+  if (key >= MAX_KEYS)\n+    return EINVAL;\n+\n+  data = __gthread_get_tls_data ();\n+  if (!data)\n+    {\n+      if (__gthread_mutex_lock (&tls_lock) == ERROR)\n+\treturn ENOMEM;\n+      if (active_tls_threads == 0)\n+\ttaskDeleteHookAdd ((FUNCPTR)tls_delete_hook);\n+      active_tls_threads++;\n+      __gthread_mutex_unlock (&tls_lock);\n+\n+      data = malloc (sizeof (struct tls_data));\n+      if (!data)\n+\treturn ENOMEM;\n+\n+      memset (data, 0, sizeof (struct tls_data));\n+      data->owner = &self_owner;\n+      __gthread_set_tls_data (data);\n+    }\n+\n+  generation = tls_keys.generation[key];\n+\n+  if (generation & 1)\n+    return EINVAL;\n+\n+  data->generation[key] = generation;\n+  data->values[key] = value;\n+\n+  return 0;\n+}\n+#endif /* __GTHREADS */"}, {"sha": "2c6a5c086728900d68b04838d95e935ca69b18ef", "filename": "gcc/config/vxlib.c", "status": "modified", "additions": 0, "deletions": 296, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0da9742e547dc0c83a1056062fe1deb8177971b/gcc%2Fconfig%2Fvxlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0da9742e547dc0c83a1056062fe1deb8177971b/gcc%2Fconfig%2Fvxlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxlib.c?ref=c0da9742e547dc0c83a1056062fe1deb8177971b", "patch": "@@ -87,300 +87,4 @@ __gthread_once (__gthread_once_t *guard, void (*func)(void))\n   return 0;\n }\n \n-/* Thread-local storage.\n-\n-   We reserve a field in the TCB to point to a dynamically allocated\n-   array which is used to store TLS values.  A TLS key is simply an\n-   offset in this array.  The exact location of the TCB field is not\n-   known to this code nor to vxlib.c -- all access to it indirects\n-   through the routines __gthread_get_tls_data and\n-   __gthread_set_tls_data, which are provided by the VxWorks kernel.\n-\n-   There is also a global array which records which keys are valid and\n-   which have destructors.\n-\n-   A task delete hook is installed to execute key destructors.  The\n-   routines __gthread_enter_tls_dtor_context and\n-   __gthread_leave_tls_dtor_context, which are also provided by the\n-   kernel, ensure that it is safe to call free() on memory allocated\n-   by the task being deleted.  (This is a no-op on VxWorks 5, but\n-   a major undertaking on AE.)\n-\n-   The task delete hook is only installed when at least one thread\n-   has TLS data.  This is a necessary precaution, to allow this module\n-   to be unloaded - a module with a hook can not be removed.\n-\n-   Since this interface is used to allocate only a small number of\n-   keys, the table size is small and static, which simplifies the\n-   code quite a bit.  Revisit this if and when it becomes necessary.  */\n-\n-#define MAX_KEYS 4\n-\n-/* This is the structure pointed to by the pointer returned\n-   by __gthread_get_tls_data.  */\n-struct tls_data\n-{\n-  int *owner;\n-  void *values[MAX_KEYS];\n-  unsigned int generation[MAX_KEYS];\n-};\n-\n-/* To make sure we only delete TLS data associated with this object,\n-   include a pointer to a local variable in the TLS data object.  */\n-static int self_owner;\n-\n-/* The number of threads for this module which have active TLS data.\n-   This is protected by tls_lock.  */\n-static int active_tls_threads;\n-\n-/* kernel provided routines */\n-extern void *__gthread_get_tls_data (void);\n-extern void __gthread_set_tls_data (void *data);\n-\n-extern void __gthread_enter_tls_dtor_context (void);\n-extern void __gthread_leave_tls_dtor_context (void);\n-\n-\n-/* This is a global structure which records all of the active keys.\n-\n-   A key is potentially valid (i.e. has been handed out by\n-   __gthread_key_create) iff its generation count in this structure is\n-   even.  In that case, the matching entry in the dtors array is a\n-   routine to be called when a thread terminates with a valid,\n-   non-NULL specific value for that key.\n-\n-   A key is actually valid in a thread T iff the generation count\n-   stored in this structure is equal to the generation count stored in\n-   T's specific-value structure.  */\n-\n-typedef void (*tls_dtor) (void *);\n-\n-struct tls_keys\n-{\n-  tls_dtor dtor[MAX_KEYS];\n-  unsigned int generation[MAX_KEYS];\n-};\n-\n-#define KEY_VALID_P(key) !(tls_keys.generation[key] & 1)\n-\n-/* Note: if MAX_KEYS is increased, this initializer must be updated\n-   to match.  All the generation counts begin at 1, which means no\n-   key is valid.  */\n-static struct tls_keys tls_keys =\n-{\n-  { 0, 0, 0, 0 },\n-  { 1, 1, 1, 1 }\n-};\n-\n-/* This lock protects the tls_keys structure.  */\n-static __gthread_mutex_t tls_lock;\n-\n-static __gthread_once_t tls_init_guard = __GTHREAD_ONCE_INIT;\n-\n-/* Internal routines.  */\n-\n-/* The task TCB has just been deleted.  Call the destructor\n-   function for each TLS key that has both a destructor and\n-   a non-NULL specific value in this thread.\n-\n-   This routine does not need to take tls_lock; the generation\n-   count protects us from calling a stale destructor.  It does\n-   need to read tls_keys.dtor[key] atomically.  */\n-\n-static void\n-tls_delete_hook (void *tcb ATTRIBUTE_UNUSED)\n-{\n-  struct tls_data *data = __gthread_get_tls_data ();\n-  __gthread_key_t key;\n-\n-  if (data && data->owner == &self_owner)\n-    {\n-      __gthread_enter_tls_dtor_context ();\n-      for (key = 0; key < MAX_KEYS; key++)\n-\t{\n-\t  if (data->generation[key] == tls_keys.generation[key])\n-\t    {\n-\t      tls_dtor dtor = tls_keys.dtor[key];\n-\n-\t      if (dtor)\n-\t\tdtor (data->values[key]);\n-\t    }\n-\t}\n-      free (data);\n-\n-      /* We can't handle an error here, so just leave the thread\n-\t marked as loaded if one occurs.  */\n-      if (__gthread_mutex_lock (&tls_lock) != ERROR)\n-\t{\n-\t  active_tls_threads--;\n-\t  if (active_tls_threads == 0)\n-\t    taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);\n-\t  __gthread_mutex_unlock (&tls_lock);\n-\t}\n-\n-      __gthread_set_tls_data (0);\n-      __gthread_leave_tls_dtor_context ();\n-    }\n-} \n-\n-/* Initialize global data used by the TLS system.  */\n-static void\n-tls_init (void)\n-{\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&tls_lock);\n-}\n-\n-static void tls_destructor (void) __attribute__ ((destructor));\n-static void\n-tls_destructor (void)\n-{\n-#ifdef __RTP__\n-  /* All threads but this one should have exited by now.  */\n-  tls_delete_hook (NULL);\n-#else\n-  /* Unregister the hook forcibly.  The counter of active threads may\n-     be incorrect, because constructors (like the C++ library's) and\n-     destructors (like this one) run in the context of the shell rather\n-     than in a task spawned from this module.  */\n-  taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);\n-#endif\n-\n-  if (tls_init_guard.done && __gthread_mutex_lock (&tls_lock) != ERROR)\n-    semDelete (tls_lock);\n-}\n-\n-/* External interface */\n-\n-/* Store in KEYP a value which can be passed to __gthread_setspecific/\n-   __gthread_getspecific to store and retrieve a value which is\n-   specific to each calling thread.  If DTOR is not NULL, it will be\n-   called when a thread terminates with a non-NULL specific value for\n-   this key, with the value as its sole argument.  */\n-\n-int\n-__gthread_key_create (__gthread_key_t *keyp, tls_dtor dtor)\n-{\n-  __gthread_key_t key;\n-\n-  __gthread_once (&tls_init_guard, tls_init);\n-\n-  if (__gthread_mutex_lock (&tls_lock) == ERROR)\n-    return errno;\n-\n-  for (key = 0; key < MAX_KEYS; key++)\n-    if (!KEY_VALID_P (key))\n-      goto found_slot;\n-\n-  /* no room */\n-  __gthread_mutex_unlock (&tls_lock);\n-  return EAGAIN;\n-\n- found_slot:\n-  tls_keys.generation[key]++;  /* making it even */\n-  tls_keys.dtor[key] = dtor;\n-  *keyp = key;\n-  __gthread_mutex_unlock (&tls_lock);\n-  return 0;\n-}\n-\n-/* Invalidate KEY; it can no longer be used as an argument to\n-   setspecific/getspecific.  Note that this does NOT call destructor\n-   functions for any live values for this key.  */\n-int\n-__gthread_key_delete (__gthread_key_t key)\n-{\n-  if (key >= MAX_KEYS)\n-    return EINVAL;\n-\n-  __gthread_once (&tls_init_guard, tls_init);\n-\n-  if (__gthread_mutex_lock (&tls_lock) == ERROR)\n-    return errno;\n-\n-  if (!KEY_VALID_P (key))\n-    {\n-      __gthread_mutex_unlock (&tls_lock);\n-      return EINVAL;\n-    }\n-\n-  tls_keys.generation[key]++;  /* making it odd */\n-  tls_keys.dtor[key] = 0;\n-\n-  __gthread_mutex_unlock (&tls_lock);\n-  return 0;\n-}\n-\n-/* Retrieve the thread-specific value for KEY.  If it has never been\n-   set in this thread, or KEY is invalid, returns NULL.\n-\n-   It does not matter if this function races with key_create or\n-   key_delete; the worst that can happen is you get a value other than\n-   the one that a serialized implementation would have provided.  */\n-\n-void *\n-__gthread_getspecific (__gthread_key_t key)\n-{\n-  struct tls_data *data;\n-\n-  if (key >= MAX_KEYS)\n-    return 0;\n-\n-  data = __gthread_get_tls_data ();\n-\n-  if (!data)\n-    return 0;\n-\n-  if (data->generation[key] != tls_keys.generation[key])\n-    return 0;\n-\n-  return data->values[key];\n-}\n-\n-/* Set the thread-specific value for KEY.  If KEY is invalid, or\n-   memory allocation fails, returns -1, otherwise 0.\n-\n-   The generation count protects this function against races with\n-   key_create/key_delete; the worst thing that can happen is that a\n-   value is successfully stored into a dead generation (and then\n-   immediately becomes invalid).  However, we do have to make sure\n-   to read tls_keys.generation[key] atomically.  */\n-\n-int\n-__gthread_setspecific (__gthread_key_t key, void *value)\n-{\n-  struct tls_data *data;\n-  unsigned int generation;\n-\n-  if (key >= MAX_KEYS)\n-    return EINVAL;\n-\n-  data = __gthread_get_tls_data ();\n-  if (!data)\n-    {\n-      if (__gthread_mutex_lock (&tls_lock) == ERROR)\n-\treturn ENOMEM;\n-      if (active_tls_threads == 0)\n-\ttaskDeleteHookAdd ((FUNCPTR)tls_delete_hook);\n-      active_tls_threads++;\n-      __gthread_mutex_unlock (&tls_lock);\n-\n-      data = malloc (sizeof (struct tls_data));\n-      if (!data)\n-\treturn ENOMEM;\n-\n-      memset (data, 0, sizeof (struct tls_data));\n-      data->owner = &self_owner;\n-      __gthread_set_tls_data (data);\n-    }\n-\n-  generation = tls_keys.generation[key];\n-\n-  if (generation & 1)\n-    return EINVAL;\n-\n-  data->generation[key] = generation;\n-  data->values[key] = value;\n-\n-  return 0;\n-}\n #endif /* __GTHREADS */"}]}