{"sha": "0e5a4ad8710376a670f22139b797da01f180249b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU1YTRhZDg3MTAzNzZhNjcwZjIyMTM5Yjc5N2RhMDFmMTgwMjQ5Yg==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2001-09-15T02:03:14Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2001-09-15T02:03:14Z"}, "message": "mips.md: Add unspec #2.\n\n2001-09-15  Eric Christopher  <echristo@redhat.com>\n\n\t* config/mips/mips.md: Add unspec #2.\n\t(reload_indi): Use.\n\t(reload_outdi): Ditto.\n\t(reload_outsi): Ditto.\n\t(HILO_delay): New.\n\n2001-09-15  Eric Christopher  <echristo@redhat.com>\n\t    Jason Eckhardt  <jle@redhat.com>\n\n\t* config.gcc: Add mipsisa32 target and mipsisa32-linux target.\n\t* config/mips/isa32-linux.h: New file.\n\t* config/mips/isa3264.h: Ditto.\n\t* config/mips/mips-protos.h: Add mips_hard_regno_nregs.\n\t* config/mips/mips.c (mips_hard_regno_nregs): Move here from mips.h.\n\t(output_block_mode): Support MEABI.\n\t(function_arg): Ditto. Fix floating point arg passing.\n\t(mips_va_start): Ditto.\n\t(override_options): Add isas 32 and 64, meabi, mips32 and mips64\n\tprocessors.\n\t(mips_asm_file_start): Add new section to pass abi to gdb.\n\t(function_arg_pass_by_reference): Support MEABI.\n\t(mips_parse_cpu): Support mips32 and mips64 processors.\n\t* config/mips/mips.h: Support ABI_MEABI, TARGET_MIPS4KC,\n\tTARGET_MIPS5KC.  Support isa32 and isa64.\n\t(processor_type): Add r4kc, r5kc, r20kc.\n\t(GENERATE_MULT3_SI): New.\n\t(GENERATE_MULT3_DI): Ditto.\n\t(GENERATE_MULT3): Remove.\n\t(ISA_HAS_64BIT_REGS): Add isa == 64.\n\t(ISA_HAS_8CC): Add mips_isa = 32 and 64.\n\t(ISA_HAS_MADD_MSUB): New.\n\t(ISA_HAS_CLZ_CLO): Ditto.\n\t(ISA_HAS_DCLZ_DCLO): Ditto.\n\t(ABI_GAS_ASM_SPEC): New.\n\t(GAS_ASM_SPEC): Use. Add support for mips32, mips64.\n\t(ASM_SPEC): Ditto.\n\t(LINK_SPEC): Ditto.\n\t(SUBTARGET_CC1_SPEC): Ditto.\n\t(SUBTARGET_CPP_SIZE_SPEC): Ditto.\n\t(PAD_VARARGS_DOWN): Support MEABI.\n\t(HARD_REGNO_NREGS): Move to mips.c.\n\t(ASM_OUTPUT_IDENT): Add #undef.\n\t* config/mips/mips.md: Add r4kc, r5kc, r20kc.\n\t(mulsi3): Use GENERATE_MULT3_SI.\n\t(mulsi3_mult3): Ditto.  Support mips32, mips64.\n\t(mul_acc_si): Use ISA_HAS_MADD_MSUB.\n\t(mul_sub_si): New pattern.\n\t(unnamed splitters): New.\n\t(muldi3): Use GENERATE_MULT3_DI.\n\t(muldi3_internal2): Ditto.\n\t(movdicc): Support mips32.\n\t* config/mips/t-isa3264: New file.\n\nFrom-SVN: r45623", "tree": {"sha": "a52e73f5fe30e2c59cb4e5aa66445b15df727dcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a52e73f5fe30e2c59cb4e5aa66445b15df727dcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e5a4ad8710376a670f22139b797da01f180249b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5a4ad8710376a670f22139b797da01f180249b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e5a4ad8710376a670f22139b797da01f180249b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5a4ad8710376a670f22139b797da01f180249b/comments", "author": null, "committer": null, "parents": [{"sha": "9a5257d5e9116150c217314ae19f5a591dec1a22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a5257d5e9116150c217314ae19f5a591dec1a22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a5257d5e9116150c217314ae19f5a591dec1a22"}], "stats": {"total": 821, "additions": 736, "deletions": 85}, "files": [{"sha": "89c2c3b3618e12739548ca4f623900e6176c8e4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e5a4ad8710376a670f22139b797da01f180249b", "patch": "@@ -1,3 +1,58 @@\n+2001-09-15  Eric Christopher  <echristo@redhat.com>\n+\n+\t* config/mips/mips.md: Add unspec #2.\n+\t(reload_indi): Use.\n+\t(reload_outdi): Ditto.\n+\t(reload_outsi): Ditto.\n+\t(HILO_delay): New.\n+\n+2001-09-15  Eric Christopher  <echristo@redhat.com>\n+\t    Jason Eckhardt  <jle@redhat.com>\n+\n+\t* config.gcc: Add mipsisa32 target and mipsisa32-linux target.\n+\t* config/mips/isa32-linux.h: New file.\n+\t* config/mips/isa3264.h: Ditto.\n+\t* config/mips/mips-protos.h: Add mips_hard_regno_nregs.\n+\t* config/mips/mips.c (mips_hard_regno_nregs): Move here from mips.h.\n+\t(output_block_mode): Support MEABI.\n+\t(function_arg): Ditto. Fix floating point arg passing.\n+\t(mips_va_start): Ditto.\n+\t(override_options): Add isas 32 and 64, meabi, mips32 and mips64\n+\tprocessors.\n+\t(mips_asm_file_start): Add new section to pass abi to gdb.\n+\t(function_arg_pass_by_reference): Support MEABI.\n+\t(mips_parse_cpu): Support mips32 and mips64 processors.\n+\t* config/mips/mips.h: Support ABI_MEABI, TARGET_MIPS4KC,\n+\tTARGET_MIPS5KC.  Support isa32 and isa64.\n+\t(processor_type): Add r4kc, r5kc, r20kc.\n+\t(GENERATE_MULT3_SI): New.\n+\t(GENERATE_MULT3_DI): Ditto.\n+\t(GENERATE_MULT3): Remove.\n+\t(ISA_HAS_64BIT_REGS): Add isa == 64.\n+\t(ISA_HAS_8CC): Add mips_isa = 32 and 64.\n+\t(ISA_HAS_MADD_MSUB): New.\n+\t(ISA_HAS_CLZ_CLO): Ditto.\n+\t(ISA_HAS_DCLZ_DCLO): Ditto.\n+\t(ABI_GAS_ASM_SPEC): New.\n+\t(GAS_ASM_SPEC): Use. Add support for mips32, mips64.\n+\t(ASM_SPEC): Ditto.\n+\t(LINK_SPEC): Ditto.\n+\t(SUBTARGET_CC1_SPEC): Ditto.\n+\t(SUBTARGET_CPP_SIZE_SPEC): Ditto.\n+\t(PAD_VARARGS_DOWN): Support MEABI.\n+\t(HARD_REGNO_NREGS): Move to mips.c.\n+\t(ASM_OUTPUT_IDENT): Add #undef.\n+\t* config/mips/mips.md: Add r4kc, r5kc, r20kc.\n+\t(mulsi3): Use GENERATE_MULT3_SI.\n+\t(mulsi3_mult3): Ditto.  Support mips32, mips64.\n+\t(mul_acc_si): Use ISA_HAS_MADD_MSUB.\n+\t(mul_sub_si): New pattern.\n+\t(unnamed splitters): New.\n+\t(muldi3): Use GENERATE_MULT3_DI.\n+\t(muldi3_internal2): Ditto.\n+\t(movdicc): Support mips32.\n+\t* config/mips/t-isa3264: New file.\n+\n 2001-09-15  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* rtl.h (FIND_REG_INC_NOTE) [HAVE_PRE_INCREMENT\n@@ -81,7 +136,7 @@ Fri Sep 14 13:54:50 EDT 2001  John Wehle  (john@feith.com)\n \tnot already defined.\n \t* config/arm/conix-elf.h: (USER_LABEL_PREFIX,\n \tLOCAL_LABEL_PREFIX, MAKE_DECL_ONE_ONLY, UNIQUE_SECTION):\n-\tRemove duplicate definition. \n+\tRemove duplicate definition.\n \t(READONLY_DATA_SECTION, SUBTARGET_EXTRA_SECTION,\n \t(SUBTARGET_EXTRA_SECTION_FUNCTION, RDATA_SECTION_ASM_OP,\n \t(RDATA_SECTION_FUNCTION): Remove redundant definition.\n@@ -113,6 +168,7 @@ Fri Sep 14 13:54:50 EDT 2001  John Wehle  (john@feith.com)\n \t* crti.asm: New file.\n \t* crtn.asm: New file.\n \n+>>>>>>> 1.11331\n 2001-09-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* c-parse.in (_yylex): Use _cpp_backup_tokens.\n@@ -170,7 +226,7 @@ Fri Sep 14 13:54:50 EDT 2001  John Wehle  (john@feith.com)\n \t* sdbout.c (plain_type_1, sdbout_end_function,\n \tsdbout_end_epilogue): Likewise.\n \t* varasm.c (decode_reg_name): Likewise.\n-\t\n+\n \t* 1750a.c (mod_regno_adjust): Likewise.\n \t* alpha.c (alpha_write_one_linkage,\n \tunicosmk_output_default_externs): Likewise.\n@@ -225,7 +281,7 @@ Fri Sep 14 13:54:50 EDT 2001  John Wehle  (john@feith.com)\n \n \t* fixinc/inclhack.def(hpux11_size_t): Keep HP-UX headers from\n \tdefining __size_t and leaving size_t undefined.\n-\t\n+\n 2001-09-12  Diego Novillo  <dnovillo@redhat.com>\n \n \t* basic-block.h (expunge_block): Declare.\n@@ -264,7 +320,7 @@ Fri Sep 14 13:54:50 EDT 2001  John Wehle  (john@feith.com)\n \t* toplev.c (decode_g_option): Likewise.\n \t* tradcpp.c (output_deps): Likewise.\n \t* varasm.c (decode_reg_name): Likewise.\n-\t\n+\n \t* arm.c (arm_condition_codes, strings_fpa, thumb_condition_code):\n \tConst-ification.\n \t* arm.md: Likewise.\n@@ -514,7 +570,7 @@ Tue Sep 11 11:37:52 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \tUnicos/Mk versions.\n \t(*divmodsi_internal, *divmoddi_internal): Disable for\n \tTARGET_ABI_UNICOSMK.\n-\t(unaligned_extend?idi, unaligned_load?i, unaligned_store?i): Split in \n+\t(unaligned_extend?idi, unaligned_load?i, unaligned_store?i): Split in\n \tlittle-endian and big-endian versions.\n \t(ext, ins, msk): Likewise.\n \t(extv, extzv, insv): Support big-endian mode."}, {"sha": "4b4779c3771e52251ce3ab3826dcdb05cdbb7a47", "filename": "gcc/config.gcc", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=0e5a4ad8710376a670f22139b797da01f180249b", "patch": "@@ -92,10 +92,10 @@\n #\n #  c_target_objs\tList of extra target-dependant objects that be\n #\t\t\tlinked into the C compiler only.\n-#  \n+#\n #  cxx_target_objs\tList of extra target-dependant objects that be\n #\t\t\tlinked into the C++ compiler only.\n-#  \n+#\n #  build_xm_defines\tList of macros to define when compiling for the\n #\t\t\tbuild machine.\n #\n@@ -252,7 +252,7 @@ case $machine in\n *-*-*aout*)\n \tuse_collect2=yes\n \t;;\n-esac\t\n+esac\n \n # Common parts for GNU/Linux, GNU/Hurd, OpenBSD and FreeBSD systems.\n case $machine in\n@@ -401,7 +401,7 @@ a29k-*-*)\t\t\t# Default a29k environment.\n alpha*-*-unicosmk*)\n \tuse_collect2=yes\n \ttm_file=\"${tm_file} alpha/unicosmk.h\"\n-\t\n+\n \t# Don't include t-ieee for now because we don't support that yet\n \t# tmake_file=\"alpha/t-ieee\"\n \ttmake_file=\"alpha/t-unicosmk\"\n@@ -471,7 +471,7 @@ alpha*-*-openbsd*)\n \ttarget_cpu_default=\"MASK_GAS\"\n \ttmake_file=\"alpha/t-alpha alpha/t-ieee\"\n \t;;\n-\t\n+\n alpha*-dec-osf*)\n \txm_defines=POSIX\n \tif test x$stabs = xyes\n@@ -597,7 +597,7 @@ arm*-*-aout)\n arm*-*-ecos-elf)\n \ttm_file=\"elfos.h arm/unknown-elf.h arm/elf.h arm/ecos-elf.h\"\n \ttmake_file=arm/t-arm-elf\n-\t;; \n+\t;;\n arm*-*-elf)\n \ttm_file=\"elfos.h arm/unknown-elf.h arm/elf.h\"\n \ttmake_file=arm/t-arm-elf\n@@ -634,7 +634,7 @@ c34-convex-*)\n \tuse_collect2=yes\n \t;;\n c38-convex-*)\n-\ttarget_cpu_default=16\t\t\n+\ttarget_cpu_default=16\n \tuse_collect2=yes\n \t;;\n c4x-*-rtems*)\n@@ -911,12 +911,12 @@ hppa*-*-lites*)\n \t;;\n hppa*-*-mpeix*)\n \ttm_file=\"${tm_file} pa/pa32-regs.h pa/long_double.h pa/som.h pa/pa-mpeix.h\"\n-\txmake_file=pa/x-pa-mpeix \n-\techo \"You must use gas. Assuming it is already installed.\" \n+\txmake_file=pa/x-pa-mpeix\n+\techo \"You must use gas. Assuming it is already installed.\"\n \tgas=yes\n \tinstall_headers_dir=install-headers-tar\n-\tuse_collect2=yes \n-\t;; \n+\tuse_collect2=yes\n+\t;;\n i370-*-opened*)\t\t\t # IBM 360/370/390 Architecture\n \txm_defines='POSIX FATAL_EXIT_CODE=12'\n \ttm_file=i370/oe.h\n@@ -1117,7 +1117,7 @@ i[34567]86-*-linux*aout*)\t# Intel 80386's running GNU/Linux\n i[34567]86-*-linux*libc1)\t# Intel 80386's running GNU/Linux\n \t\t\t\t# with ELF format using the\n \t\t\t\t# GNU/Linux C library 5\n-\txmake_file=x-linux\t\n+\txmake_file=x-linux\n \ttm_file=\"i386/i386.h i386/att.h linux.h i386/linux.h\"\n \ttmake_file=\"t-slibgcc-elf-ver t-linux t-linux-gnulibc1 i386/t-crtstuff\"\n \textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtendS.o\"\n@@ -2215,7 +2215,11 @@ mips*-*-linux*)\t\t\t\t# Linux MIPS, either endian.\n \txmake_file=x-linux\n \ttm_file=\"linux.h mips/linux.h\"\n \tcase $machine in\n-\t       mips*el-*)  tm_file=\"mips/little.h $tm_file\" ;;\n+\t\tmipsisa32el-*)\n+\t\t\ttm_file=\"mips/little.h $tm_file mips/isa32-linux.h\";;\n+                mipsisa32-*)\n+\t\t\ttm_file=\"$tm_file mips/isa32-linux.h\";;\n+\t       \tmips*el-*)  tm_file=\"mips/little.h $tm_file\" ;;\n \tesac\n \ttmake_file=\"t-slibgcc-elf-ver t-linux\"\n \textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtendS.o\"\n@@ -2434,6 +2438,10 @@ mips-*-ecoff*)\n \tfi\n \ttmake_file=mips/t-ecoff\n \t;;\n+mipsisa32-*-elf*)\n+\ttm_file=\"mips/isa3264.h mips/abi64.h\"\n+\ttmake_file=mips/t-isa3264\n+\t;;\n mipsel-*-elf*)\n \ttm_file=\"mips/elfl.h\"\n \ttmake_file=mips/t-elf\n@@ -2789,7 +2797,7 @@ rs6000-*-lynxos*)\n \ttmake_file=rs6000/t-rs6000\n \tuse_collect2=yes\n \t;;\n-s390-*-linux*)\t\n+s390-*-linux*)\n \txmake_file=x-linux\n \ttm_file=s390/linux.h\n \ttmake_file=\"t-slibgcc-elf-ver t-linux s390/t-linux\"\n@@ -2798,7 +2806,7 @@ s390-*-linux*)\n \t\tthread_file='posix'\n \tfi\n \t;;\n-s390x-*-linux*)\t\n+s390x-*-linux*)\n \txmake_file=x-linux\n \ttm_file=s390/linux64.h\n \ttmake_file=\"t-slibgcc-elf-ver t-linux s390/t-linux\"\n@@ -3089,7 +3097,7 @@ sparc86x-*-aout*)\n \ttm_file=\"sparc/sp86x-aout.h aoutos.h libgloss.h\"\n \ttmake_file=sparc/t-sp86x\n \t;;\n-sparc86x-*-elf*)\t\n+sparc86x-*-elf*)\n \ttm_file=\"sparc/sol2.h sparc./elf.h sparc/sp86x-elf.h\"\n \ttmake_file=sparc/t-sp86x\n         extra_parts=\"crtbegin.o crtend.o\"\n@@ -3272,7 +3280,7 @@ alpha*-*-*)\n \t\t\ttarget_cpu_default2=\"MASK_CPU_EV5\"\n \t\t\t;;\n \tesac\n-\t\t\t\n+\n \tif test x$gas = xyes\n \tthen\n \t\tif test \"$target_cpu_default2\" = \"\""}, {"sha": "a03b79a6621e6c6379354dd293e8355ad712e7ff", "filename": "gcc/config/mips/isa32-linux.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Fisa32-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Fisa32-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fisa32-linux.h?ref=0e5a4ad8710376a670f22139b797da01f180249b", "patch": "@@ -0,0 +1,29 @@\n+/* Definitions for MIPS32 running Linux-based GNU systems with ELF format.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#undef TARGET_VERSION\n+#if TARGET_ENDIAN_DEFAULT == 0\n+#define TARGET_VERSION fprintf (stderr, \" (MIPS32el GNU/Linux with ELF)\");\n+#else\n+#define TARGET_VERSION fprintf (stderr, \" (MIPS32 GNU/Linux with ELF)\");\n+#endif\n+\n+#undef MIPS_ISA_DEFAULT\n+#define MIPS_ISA_DEFAULT 32"}, {"sha": "cd25e55ae79269d2a0e9f70d4b536e3a9ac297e4", "filename": "gcc/config/mips/isa3264.h", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Fisa3264.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Fisa3264.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fisa3264.h?ref=0e5a4ad8710376a670f22139b797da01f180249b", "patch": "@@ -0,0 +1,148 @@\n+/* Definitions of target machine for GNU compiler.\n+   MIPS 32 and MIPS 64 version.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef MIPS_ISA_DEFAULT\n+#define MIPS_ISA_DEFAULT 32\n+#endif\n+\n+#ifndef MIPS_ABI_DEFAULT\n+#define MIPS_ABI_DEFAULT ABI_MEABI\n+#endif\n+\n+#ifndef MIPS_ENABLE_EMBEDDED_O32\n+#define MIPS_ENABLE_EMBEDDED_O32 1\n+#endif\n+\n+#ifndef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+#endif\n+\n+#include \"mips/elf.h\"\n+\n+/* This must be done after including mips.h so that the\n+   ABI_{EABI,O64,O32,...} are #defined. */\n+\n+#if MIPS_ABI_DEFAULT == ABI_EABI\n+#undef SUBTARGET_CPP_SIZE_SPEC\n+#define SUBTARGET_CPP_SIZE_SPEC \"\\\n+%{mabi=eabi|!mabi=*:\\\n+  %{mips1|mips2|mips32|mlong32: -D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int} \\\n+  %{!mips1:%{!mips2:%{!mips32:%{!mlong32:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int}}}}} \\\n+%{mabi=o64:\\\n+ %{mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int} \\\n+ %{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int}} \\\n+%{mabi=32:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int} \\\n+\"\n+#elif MIPS_ABI_DEFAULT == ABI_O64\n+#undef SUBTARGET_CPP_SIZE_SPEC\n+#define SUBTARGET_CPP_SIZE_SPEC \"\\\n+%{mabi=eabi:\\\n+  %{mips1|mips2|mips32|mlong32: -D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int} \\\n+  %{!mips1:%{!mips2:%{!mips32:%{!mlong32:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int}}}}} \\\n+%{mabi=o64|!mabi=*:\\\n+ %{mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int} \\\n+ %{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int}} \\\n+%{mabi=32:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int} \\\n+\"\n+\n+#elif MIPS_ABI_DEFAULT == ABI_32\n+#if MIPS_ISA_DEFAULT == 3 || MIPS_ISA_DEFAULT == 4 || MIPS_ISA_DEFAULT == 5 || MIPS_ISA_DEFAULT == 64\n+#undef SUBTARGET_CPP_SIZE_SPEC\n+#define SUBTARGET_CPP_SIZE_SPEC \"\\\n+%{mabi=eabi:\\\n+  %{mips1|mips2|mips32|mlong32: -D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int} \\\n+  %{!mips1:%{!mips2:%{!mips32:%{!mlong32:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int}}}}} \\\n+%{mabi=o64|!!mabi=*:\\\n+ %{mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int} \\\n+ %{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int}} \\\n+%{mabi=32:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int} \\\n+\"\n+#else /* not a 64bit default ISA */\n+#undef SUBTARGET_CPP_SIZE_SPEC\n+#define SUBTARGET_CPP_SIZE_SPEC \"\\\n+%{mabi=eabi:\\\n+  %{mips3|mips4|mips5|mips64|mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int} \\\n+  %{!mips3:%{!mips4:%{!mips5:%{!mips64:%{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int}}}}}} \\\n+%{mabi=o64:\\\n+ %{mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int} \\\n+ %{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int}} \\\n+%{mabi=32:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int} \\\n+%{!mabi=*:\\\n+ %{mips3|mips4|mips5|mips64:\\\n+  %{mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int} \\\n+  %{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int}} \\\n+ %{!mips3:%{!mips4:%{!mips5:%{!mips64:\\\n+  -D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int}}}}} \\\n+\"\n+#endif /* ISA */\n+\n+#elif MIPS_ABI_DEFAULT == ABI_MEABI\n+/* For MEABI, don't link with crt0 files, let the linker start files specify\n+   the appropriate crt0 file.  */\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"crti%O%s crtbegin%O%s %{!mno-crt0: }\"\n+\n+/*\n+   The MIPS_ISA_DEFAULT test is for EABI, in which the size of longs depends on\n+   the ISA.\n+\n+   For MEABI the size of longs is always 32bits.  If long64 is specified then\n+   we honor that.  The errors for long64 & long32 is because while CC1 can\n+   handle overriding mlong32 with mlong64 and vise-versa, the specs cannot. */\n+\n+#if MIPS_ISA_DEFAULT == 3 || MIPS_ISA_DEFAULT == 4 || MIPS_ISA_DEFAULT == 5 || MIPS_ISA_DEFAULT == 64\n+#undef SUBTARGET_CPP_SIZE_SPEC\n+#define SUBTARGET_CPP_SIZE_SPEC \"\\\n+%{mabi=meabi:\\\n+  %{mips1|mips2|mips32|mlong32: -D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int} \\\n+  %{!mips1:%{!mips2:%{!mips32:%{!mlong32:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int}}}}} \\\n+%{mabi=o64:\\\n+ %{mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int \\\n+  %{mlong32:%e-mlong32 and -mlong64 can not both be specified.}} \\\n+ %{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int }} \\\n+%{mabi=32:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int} \\\n+%{mabi=meabi|!mabi=*:\\\n+ %{mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int \\\n+  %{mlong32:%e-mlong32 and -mlong64 can not both be specified.}} \\\n+ %{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int }} \\\n+\"\n+\n+#else /* not a 64bit default ISA */\n+#undef SUBTARGET_CPP_SIZE_SPEC\n+#define SUBTARGET_CPP_SIZE_SPEC \"\\\n+%{mabi=meabi:\\\n+  %{mips3|mips4|mips5|mips64|mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int} \\\n+  %{!mips3:%{!mips4:%{!mips5:%{!mips64:%{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int}}}}}} \\\n+%{mabi=o64:\\\n+ %{mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int \\\n+  %{mlong32:%e-mlong32 and -mlong64 can not both be specified.}} \\\n+ %{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int }} \\\n+%{mabi=32:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int} \\\n+%{mabi=meabi|!mabi=*:\\\n+ %{mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int \\\n+  %{mlong32:%e-mlong32 and -mlong64 can not both be specified.}} \\\n+ %{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int }} \\\n+\"\n+#endif /* ISA */\n+\n+#endif /* ABI */\n+\n+/* eof */"}, {"sha": "57011aea31cf35adc47149e15cfad48c28c6a60f", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=0e5a4ad8710376a670f22139b797da01f180249b", "patch": "@@ -53,6 +53,7 @@ extern int\t\tmips_output_external_libcall PARAMS ((FILE *, const char *));\n \n \n #ifdef TREE_CODE\n+extern unsigned int\tmips_hard_regno_nregs PARAMS ((int, enum machine_mode));\n extern struct rtx_def *\tfunction_arg PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n extern void\t\tfunction_arg_advance PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n extern int\t\tfunction_arg_partial_nregs PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));"}, {"sha": "dee6503ee545398e33bc224780c931bb568a98c2", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 145, "deletions": 22, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0e5a4ad8710376a670f22139b797da01f180249b", "patch": "@@ -1383,7 +1383,7 @@ mips_legitimate_address_p (mode, xinsn, strict)\n \t         (set (blah:DI) (plus x y)).  */\n \t      && (!TARGET_64BIT\n \t\t  || (code1 == CONST_INT\n-\t\t      && trunc_int_for_mode (INTVAL (xplus1), \n+\t\t      && trunc_int_for_mode (INTVAL (xplus1),\n \t\t\t\t\t     SImode) == INTVAL (xplus1)))\n \t      && !TARGET_MIPS16)\n \t    return 1;\n@@ -3536,7 +3536,9 @@ output_block_move (insn, operands, num_regs, move_type)\n      constant addresses into registers when generating N32/N64 code, just\n      in case we might emit an unaligned load instruction.  */\n   if (num_regs > 2 && (bytes > 2 * align || move_type != BLOCK_MOVE_NORMAL\n-\t\t       || mips_abi == ABI_N32 || mips_abi == ABI_64))\n+\t\t       || mips_abi == ABI_MEABI\n+\t\t       || mips_abi == ABI_N32\n+\t\t       || mips_abi == ABI_64))\n     {\n       if (CONSTANT_P (src_reg))\n \t{\n@@ -3994,6 +3996,11 @@ function_arg (cum, mode, type, named)\n \t  arg_words = &cum->fp_arg_words;\n \t  regbase = FP_ARG_FIRST;\n \t}\n+      /* The MIPS eabi says only structures containing doubles get passed in a\n+         fp register, so force a structure containing a float to be passed in\n+         the integer registers.  */\n+      else if (mips_abi == ABI_MEABI && struct_p)\n+\tregbase = GP_ARG_FIRST;\n       else\n \tregbase = (TARGET_SOFT_FLOAT || ! named ? GP_ARG_FIRST : FP_ARG_FIRST);\n       break;\n@@ -4063,11 +4070,30 @@ function_arg (cum, mode, type, named)\n       if (regbase == -1)\n \tabort ();\n \n-      if (! type || TREE_CODE (type) != RECORD_TYPE || mips_abi == ABI_32\n-\t  || mips_abi == ABI_EABI || mips_abi == ABI_O64 || ! named\n+      if (! type || TREE_CODE (type) != RECORD_TYPE\n+\t  || mips_abi == ABI_32  || mips_abi == ABI_EABI\n+\t  || mips_abi == ABI_O64 || mips_abi == ABI_MEABI\n+\t  || ! named\n \t  || ! TYPE_SIZE_UNIT (type)\n \t  || ! host_integerp (TYPE_SIZE_UNIT (type), 1))\n-\tret = gen_rtx_REG (mode, regbase + *arg_words + bias);\n+\t{\n+\n+\t  unsigned int arg_reg = (regbase + *arg_words + bias);\n+\t  ret = gen_rtx_REG (mode, arg_reg);\n+\t  if (mips_abi == ABI_MEABI\n+\t      && regbase == FP_ARG_FIRST\n+\t      && ! cum->prototype)\n+\t    {\n+              /* To make K&R varargs work we need to pass floating\n+                 point arguments in both integer and FP registers.  */\n+              ret = gen_rtx_PARALLEL (mode,\n+\t\t\t\t      gen_rtvec (2,\n+\t\t\t\t\t\t gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\t\t\t    gen_rtx_REG (mode,\n+\t\t\t\t\t\t\t\t\t\t arg_reg + GP_ARG_FIRST - FP_ARG_FIRST),\n+\t\t\t\t\t\t\t\t    const0_rtx),                                                gen_rtx_EXPR_LIST (VOIDmode, ret, const0_rtx)));\n+            }\n+\t}\n       else\n \t{\n \t  /* The Irix 6 n32/n64 ABIs say that if any 64 bit chunk of the\n@@ -4124,6 +4150,7 @@ function_arg (cum, mode, type, named)\n \t\t  if (field\n \t\t      && int_bit_position (field) == bitpos\n \t\t      && TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n+\t\t      && !TARGET_SOFT_FLOAT\n \t\t      && TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD)\n \t\t    reg = gen_rtx_REG (DFmode,\n \t\t\t\t       regno + FP_ARG_FIRST - GP_ARG_FIRST);\n@@ -4164,7 +4191,9 @@ function_arg (cum, mode, type, named)\n \t calling convention for now.  */\n \n       if (struct_p && int_size_in_bytes (type) < UNITS_PER_WORD\n-\t  && ! TARGET_64BIT && mips_abi != ABI_EABI)\n+\t  && ! TARGET_64BIT\n+\t  && mips_abi != ABI_EABI\n+\t  && mips_abi != ABI_MEABI)\n \t{\n \t  rtx amount = GEN_INT (BITS_PER_WORD\n \t\t\t\t- int_size_in_bytes (type) * BITS_PER_UNIT);\n@@ -4454,6 +4483,8 @@ mips_va_start (stdarg_p, valist, nextarg)\n \t     and both iris5.h and iris6.h define _MIPS_SIM.  */\n \t  if (mips_abi == ABI_N32 || mips_abi == ABI_64)\n  \t    ofs = (int_arg_words >= 8 ? -UNITS_PER_WORD : 0);\n+\t  else if (mips_abi == ABI_MEABI)\n+\t    ofs = (int_arg_words >= 8 ? -UNITS_PER_WORD : 0);\n \t  else\n \t    ofs = -UNITS_PER_WORD;\n \t}\n@@ -4764,7 +4795,10 @@ override_options ()\n \t      mips_isa = MIPS_ISA_DEFAULT;\n \t    }\n \t}\n-      else if (mips_isa < 1 || mips_isa > 4)\n+      else if (mips_isa < 1\n+\t       || (mips_isa > 4\n+\t\t   && mips_isa != 32\n+\t\t   && mips_isa != 64))\n \t{\n \t  error (\"-mips%d not supported\", mips_isa);\n \t  mips_isa = 1;\n@@ -4791,17 +4825,26 @@ override_options ()\n     mips_abi = ABI_64;\n   else if (! strcmp (mips_abi_string, \"eabi\"))\n     mips_abi = ABI_EABI;\n+  else if (! strcmp (mips_abi_string, \"meabi\"))\n+    mips_abi = ABI_MEABI;\n   else\n     error (\"bad value (%s) for -mabi= switch\", mips_abi_string);\n \n   /* A specified ISA defaults the ABI if it was not specified.  */\n   if (mips_abi_string == 0 && mips_isa_string\n-      && mips_abi != ABI_EABI && mips_abi != ABI_O64)\n+      && mips_abi != ABI_EABI\n+      && mips_abi != ABI_O64\n+      && mips_abi != ABI_MEABI)\n     {\n-      if (! ISA_HAS_64BIT_REGS)\n-\tmips_abi = ABI_32;\n+      if (mips_isa == 64)\n+\tmips_abi = ABI_O64;\n       else\n-\tmips_abi = ABI_64;\n+\t{\n+\t  if (! ISA_HAS_64BIT_REGS)\n+\t    mips_abi = ABI_32;\n+\t  else\n+\t    mips_abi = ABI_64;\n+\t}\n     }\n \n #ifdef MIPS_CPU_STRING_DEFAULT\n@@ -4894,6 +4937,14 @@ override_options ()\n \t  mips_arch_string = \"8000\";\n \t  mips_arch = PROCESSOR_R8000;\n \t  break;\n+\tcase 32:\n+          mips_arch_string = \"4kc\";\n+          mips_arch = PROCESSOR_R4KC;\n+          break;\n+        case 64:\n+          mips_arch_string = \"5kc\";\n+          mips_arch = PROCESSOR_R5KC;\n+          break;\n \t}\n     }\n   else\n@@ -4930,6 +4981,14 @@ override_options ()\n \t  mips_tune_string = \"8000\";\n \t  mips_tune = PROCESSOR_R8000;\n \t  break;\n+\tcase 32:\n+\t  mips_arch_string = \"4kc\";\n+\t  mips_arch = PROCESSOR_R4KC;\n+\t  break;\n+\tcase 64:\n+\t  mips_arch_string = \"5kc\";\n+\t  mips_arch = PROCESSOR_R5KC;\n+\t  break;\n \t}\n \n     }\n@@ -4943,16 +5002,22 @@ override_options ()\n \t}\n     }\n \n-   /* Handle processor configuration based on architecture.  */\n-   if (TARGET_MIPS4100 || TARGET_MIPS3900)\n-     target_flags |= MASK_SOFT_FLOAT;\n+  /* Handle processor configuration based on architecture.  */\n+  if (TARGET_MIPS4100\n+      || TARGET_MIPS3900\n+      || TARGET_MIPS4KC\n+      || TARGET_MIPS5KC)\n+    target_flags |= MASK_SOFT_FLOAT;\n \n \n   if ((mips_arch == PROCESSOR_R3000 && (mips_isa != 1))\n+      || (mips_arch == PROCESSOR_R4KC && mips_isa != 32)\n+      || ((mips_arch == PROCESSOR_R5KC\n+\t   || mips_arch == PROCESSOR_R20KC) && mips_isa != 64)\n       || (mips_arch == PROCESSOR_R6000 && mips_isa != 1 && mips_isa != 2)\n       || ((mips_arch == PROCESSOR_R4000\n-           || mips_arch == PROCESSOR_R4100\n-           || mips_arch == PROCESSOR_R4300\n+\t   || mips_arch == PROCESSOR_R4100\n+\t   || mips_arch == PROCESSOR_R4300\n \t   || mips_arch == PROCESSOR_R4600\n \t   || mips_arch == PROCESSOR_R4650)\n \t  && mips_isa != 1 && mips_isa != 2 && mips_isa != 3))\n@@ -5160,7 +5225,14 @@ override_options ()\n \t    temp = ((regno & 1) == 0 || size <= UNITS_PER_WORD);\n \n \t  else if (FP_REG_P (regno))\n-\t    temp = ((TARGET_FLOAT64 || ((regno & 1) == 0))\n+\t    temp = ((TARGET_FLOAT64 || ((regno & 1) == 0)\n+\t\t      /* I think this change is OK regardless of abi, but\n+                        I'm being cautions untill I can test this more.\n+                        HARD_REGNO_MODE_OK is about whether or not you\n+                        can move to and from a register without changing\n+                        the value, not about whether math works on the\n+                        register.  */\n+                     || (mips_abi == ABI_MEABI && size <= 4))\n \t\t    && (class == MODE_FLOAT\n \t\t\t|| class == MODE_COMPLEX_FLOAT\n \t\t\t|| (TARGET_DEBUG_H_MODE && class == MODE_INT))\n@@ -5866,7 +5938,6 @@ mips_output_lineno (stream, line)\n \t       LOCAL_LABEL_PREFIX, sym_lineno, ASM_STABN_OP, N_SLINE, line,\n \t       LOCAL_LABEL_PREFIX, sym_lineno);\n     }\n-\n   else\n     {\n       fprintf (stream, \"\\n\\t%s.loc\\t%d %d\\n\",\n@@ -6021,6 +6092,8 @@ void\n mips_asm_file_start (stream)\n      FILE *stream;\n {\n+  const char * abi_string = NULL;\n+\n   ASM_OUTPUT_SOURCE_FILENAME (stream, main_input_filename);\n \n   /* Versions of the MIPS assembler before 2.20 generate errors if a branch\n@@ -6031,6 +6104,35 @@ mips_asm_file_start (stream)\n   if (TARGET_MIPS_AS && optimize && flag_delayed_branch)\n     fprintf (stream, \"\\t.set\\tnobopt\\n\");\n \n+#ifdef OBJECT_FORMAT_ELF\n+  /* Generate a special section to describe the ABI switches used to produce\n+     the resultant binary.  This used to be done by the assembler setting bits\n+     in the ELF header's flags field, but we have run out of bits.  GDB needs\n+     this information in order to be able to correctly debug these binaries.\n+     See the function mips_gdbarch_init() in gdb/mips-tdep.c.  */\n+  switch (mips_abi)\n+    {\n+    case ABI_32:   abi_string = \"abi32\"; break;\n+    case ABI_N32:  abi_string = \"abiN32\"; break;\n+    case ABI_64:   abi_string = \"abi64\"; break;\n+    case ABI_O64:  abi_string = \"abiO64\"; break;\n+    case ABI_EABI: abi_string = TARGET_64BIT ? \"eabi64\" : \"eabi32\"; break;\n+    case ABI_MEABI:abi_string = TARGET_64BIT ? \"meabi64\" : \"meabi32\"; break;\n+    default:\n+      abort ();\n+    }\n+  /* Note - we use fprintf directly rather than called named_section()\n+     because in this way we can avoid creating an allocated section.  We\n+     do not want this section to take up any space in the running\n+     executable.  */\n+  fprintf (stream, \"\\t.section .mdebug.%s\\n\", abi_string);\n+\n+  /* Restore the default section.  */\n+  fprintf (stream, \"\\t.previous\\n\");\n+#endif\n+\n+\n+\n   /* Generate the pseudo ops that System V.4 wants.  */\n #ifndef ABICALLS_ASM_OP\n #define ABICALLS_ASM_OP \"\\t.abicalls\"\n@@ -6115,7 +6217,6 @@ copy_file_data (to, from)\n {\n   char buffer[8192];\n   size_t len;\n-\n   rewind (from);\n   if (ferror (from))\n     fatal_io_error (\"can't rewind temp file\");\n@@ -7910,7 +8011,8 @@ function_arg_pass_by_reference (cum, mode, type, named)\n      to prevent it, or add code to function.c to properly handle the case.  */\n   /* ??? cum can be NULL when called from mips_va_arg.  The problem handled\n      here hopefully is not relevant to mips_va_arg.  */\n-  if (cum && MUST_PASS_IN_STACK (mode, type))\n+  if (cum && MUST_PASS_IN_STACK (mode, type)\n+      && mips_abi != ABI_MEABI)\n      {\n        /* Don't pass the actual CUM to FUNCTION_ARG, because we would\n \t  get double copies of any offsets generated for small structs\n@@ -9714,6 +9816,8 @@ mips_parse_cpu (cpu_string)\n     case '2':\n       if (!strcmp (p, \"2000\") || !strcmp (p, \"2k\") || !strcmp (p, \"2K\"))\n \tcpu = PROCESSOR_R3000;\n+      else if (!strcmp (p, \"20kc\") || !strcmp (p, \"20Kc\") )\n+        cpu = PROCESSOR_R20KC;\n       break;\n \n     case '3':\n@@ -9742,11 +9846,20 @@ mips_parse_cpu (cpu_string)\n \tcpu = PROCESSOR_R4600;\n       else if (!strcmp (p, \"4650\"))\n \tcpu = PROCESSOR_R4650;\n+      /* The 4kc and 4kp processor cores are the same for\n+\t scheduling purposes; they both implement the MIPS32\n+\t ISA and only differ in their memory management\n+\t methods.  */\n+      else if (!strcmp (p, \"4kc\") || !strcmp (p, \"4Kc\")\n+               || !strcmp (p, \"4kp\") || !strcmp (p, \"4Kp\") )\n+\tcpu = PROCESSOR_R4KC;\n       break;\n \n     case '5':\n       if (!strcmp (p, \"5000\") || !strcmp (p, \"5k\") || !strcmp (p, \"5K\"))\n \tcpu = PROCESSOR_R5000;\n+      else if (!strcmp (p, \"5kc\") || !strcmp (p, \"5Kc\") )\n+          cpu = PROCESSOR_R5KC;\n       break;\n \n     case '6':\n@@ -9864,6 +9977,17 @@ mips_unique_section (decl, reloc)\n   DECL_SECTION_NAME (decl) = build_string (len, string);\n }\n \n+unsigned int\n+mips_hard_regno_nregs (regno, mode)\n+    int regno;\n+    enum machine_mode mode;\n+{\n+  if (! FP_REG_P (regno))\n+    return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n+  else\n+    return ((GET_MODE_SIZE (mode) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG);\n+}\n+\n \f\n #ifdef TARGET_IRIX6\n /* Output assembly to switch to section NAME with attribute FLAGS.  */\n@@ -9887,7 +10011,6 @@ iris6_asm_named_section_1 (name, flags, align)\n     sh_flags |= 0x10000000; /* SHF_MIPS_GPREL */\n   if (strcmp (name, \".debug_frame\") == 0)\n     sh_flags |= 0x08000000; /* SHF_MIPS_NOSTRIP */\n-\n   if (flags & SECTION_DEBUG)\n     sh_type = 0x7000001e; /* SHT_MIPS_DWARF */\n   else if (flags & SECTION_BSS)\n@@ -9980,7 +10103,7 @@ iris6_asm_output_align (file, log)\n    but takes it from the first .section directive seen.  Play yet more\n    file switching games so that we can emit a .section directive at the\n    beginning of the file with the proper alignment attached.  */\n-   \n+\n void\n iris6_asm_file_start (stream)\n      FILE *stream;"}, {"sha": "dfb8aff623967cb966e0946898f945b8bd9156b6", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 107, "deletions": 25, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=0e5a4ad8710376a670f22139b797da01f180249b", "patch": "@@ -67,7 +67,10 @@ enum processor_type {\n   PROCESSOR_R4600,\n   PROCESSOR_R4650,\n   PROCESSOR_R5000,\n-  PROCESSOR_R8000\n+  PROCESSOR_R8000,\n+  PROCESSOR_R4KC,\n+  PROCESSOR_R5KC,\n+  PROCESSOR_R20KC\n };\n \n /* Recast the cpu class to be the cpu attribute.  */\n@@ -84,6 +87,18 @@ enum processor_type {\n #define ABI_64  2\n #define ABI_EABI 3\n #define ABI_O64  4\n+/* MEABI is gcc's internal name for MIPS' new EABI (defined by MIPS)\n+   which is not the same as the above EABI (defined by Cygnus,\n+   Greenhills, and Toshiba?).  MEABI is not yet complete or published,\n+   but at this point it looks like N32 as far as calling conventions go,\n+   but allows for either 32 or 64 bit registers.\n+\n+   Currently MIPS is calling their EABI \"the\" MIPS EABI, and Cygnus'\n+   EABI the legacy EABI.  In the end we may end up calling both ABI's\n+   EABI but give them different version numbers, but for now I'm going\n+   with different names. */\n+#define ABI_MEABI 5\n+\n \n #ifndef MIPS_ABI_DEFAULT\n /* We define this away so that there is no extra runtime cost if the target\n@@ -339,6 +354,8 @@ extern void\t\tsbss_section PARAMS ((void));\n #define TARGET_MIPS4000             (mips_arch == PROCESSOR_R4000)\n #define TARGET_MIPS4100             (mips_arch == PROCESSOR_R4100)\n #define TARGET_MIPS4300             (mips_arch == PROCESSOR_R4300)\n+#define TARGET_MIPS4KC              (mips_arch == PROCESSOR_R4KC)\n+#define TARGET_MIPS5KC              (mips_arch == PROCESSOR_R5KC)\n \n /* Scheduling target defines.  */\n #define TUNE_MIPS3000               (mips_tune == PROCESSOR_R3000)\n@@ -542,8 +559,16 @@ extern void\t\tsbss_section PARAMS ((void));\n #        if MIPS_ISA_DEFAULT == 4\n #          define MULTILIB_ISA_DEFAULT \"mips4\"\n #        else\n+#          if MIPS_ISA_DEFAULT == 32\n+#            define MULTILIB_ISA_DEFAULT \"mips32\"\n+#          else\n+#            if MIPS_ISA_DEFAULT == 64\n+#              define MULTILIB_ISA_DEFAULT \"mips64\"\n+#            else\n #          define MULTILIB_ISA_DEFAULT \"mips1\"\n+#         endif\n #        endif\n+#       endif\n #      endif\n #    endif\n #  endif\n@@ -607,9 +632,15 @@ extern void\t\tsbss_section PARAMS ((void));\n \n #define GENERATE_BRANCHLIKELY  (!TARGET_MIPS16 && ISA_HAS_BRANCHLIKELY)\n \n-/* Generate three-operand multiply instructions for both SImode and DImode.  */\n-#define GENERATE_MULT3         (TARGET_MIPS3900\t\t\t\t\\\n-\t\t\t\t&& !TARGET_MIPS16)\n+/* Generate three-operand multiply instructions for SImode.  */\n+#define GENERATE_MULT3_SI       ((TARGET_MIPS3900                       \\\n+                                  || mips_isa == 32                     \\\n+                                  || mips_isa == 64)                    \\\n+                                 && !TARGET_MIPS16)\n+\n+/* Generate three-operand multiply instructions for DImode.  */\n+#define GENERATE_MULT3_DI       ((TARGET_MIPS3900)                      \\\n+\t\t\t\t && !TARGET_MIPS16)\n \n /* Macros to decide whether certain features are available or not,\n    depending on the instruction set architecture level.  */\n@@ -618,8 +649,9 @@ extern void\t\tsbss_section PARAMS ((void));\n #define HAVE_SQRT_P()\t\t(mips_isa != 1)\n \n /* ISA has instructions for managing 64 bit fp and gp regs (eg. mips3). */\n-#define ISA_HAS_64BIT_REGS\t(mips_isa == 3 || mips_isa == 4 \t\\\n-                                )\n+#define ISA_HAS_64BIT_REGS\t(mips_isa == 3          \\\n+\t\t\t\t || mips_isa == 4 \t\\\n+                                 || mips_isa == 64)\n \n /* ISA has branch likely instructions (eg. mips2). */\n /* Disable branchlikely for tx39 until compare rewrite.  They haven't\n@@ -629,7 +661,8 @@ extern void\t\tsbss_section PARAMS ((void));\n \n /* ISA has the conditional move instructions introduced in mips4. */\n #define ISA_HAS_CONDMOVE        (mips_isa == 4\t\t\t\t\\\n-\t\t\t\t )\n+\t\t\t\t || mips_isa == 32                      \\\n+\t\t\t\t || mips_isa == 64)\n \n /* ISA has just the integer condition move instructions (movn,movz) */\n #define ISA_HAS_INT_CONDMOVE     0\n@@ -639,7 +672,8 @@ extern void\t\tsbss_section PARAMS ((void));\n /* ISA has the mips4 FP condition code instructions: FP-compare to CC,\n    branch on CC, and move (both FP and non-FP) on CC. */\n #define ISA_HAS_8CC\t\t(mips_isa == 4\t\t\t\t\\\n-\t\t\t\t)\n+                         \t || mips_isa == 32                      \\\n+\t\t\t\t || mips_isa == 64)\n \n \n /* This is a catch all for the other new mips4 instructions: indexed load and\n@@ -651,10 +685,25 @@ extern void\t\tsbss_section PARAMS ((void));\n /* ISA has conditional trap instructions.  */\n #define ISA_HAS_COND_TRAP\t(mips_isa >= 2)\n \n+/* ISA has multiply-accumulate instructions, madd and msub.  */\n+#define ISA_HAS_MADD_MSUB       (mips_isa == 32                         \\\n+                                || mips_isa == 64                       \\\n+                                )\n+\n /* ISA has nmadd and nmsub instructions.  */\n #define ISA_HAS_NMADD_NMSUB\t(mips_isa == 4\t\t\t\t\\\n \t\t\t\t)\n \n+/* ISA has count leading zeroes/ones instruction (not implemented).  */\n+#define ISA_HAS_CLZ_CLO         (mips_isa == 32                         \\\n+                                || mips_isa == 64                       \\\n+                                )\n+\n+/* ISA has double-word count leading zeroes/ones instruction (not\n+   implemented).  */\n+#define ISA_HAS_DCLZ_DCLO       (mips_isa == 64)\n+\n+\n /* CC1_SPEC causes -mips3 and -mips4 to set -mfp64 and -mgp64; -mips1 or\n    -mips2 sets -mfp32 and -mgp32.  This can be overridden by an explicit\n    -mfp32, -mfp64, -mgp32 or -mgp64.  -mfp64 sets MASK_FLOAT64 in\n@@ -670,10 +719,7 @@ extern void\t\tsbss_section PARAMS ((void));\n \f\n /* Switch  Recognition by gcc.c.  Add -G xx support */\n \n-#ifdef SWITCH_TAKES_ARG\n-#undef SWITCH_TAKES_ARG\n-#endif\n-\n+#undef  SWITCH_TAKES_ARG\n #define SWITCH_TAKES_ARG(CHAR)\t\t\t\t\t\t\\\n   (DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')\n \n@@ -822,7 +868,39 @@ while (0)\n /* GAS_ASM_SPEC is passed when using gas, rather than the MIPS\n    assembler.  */\n \n-#define GAS_ASM_SPEC \"%{march=*} %{mtune=*} %{mcpu=*} %{m4650} %{mmad:-m4650} %{m3900} %{v} %{mgp32} %{mgp64}\"\n+#define GAS_ASM_SPEC \"%{march=*} %{mtune=*} %{mcpu=*} %{m4650} %{mmad:-m4650} %{m3900} %{v} %{mgp32} %{mgp64} %(abi_gas_asm_spec) %{mabi=32:%{!mips*:-mips2}}\"\n+\n+#ifndef MIPS_ABI_DEFAULT\n+#define ABI_GAS_ASM_SPEC \"\\\n+%{mabi=*} \\\n+%{!mabi=*:%{mips1|mips2|mips32:-mabi=32} %{!mips1:%{!mips2:%{!mips32:-mabi=64}}}}\"\n+\n+#elif MIPS_ABI_DEFAULT == ABI_32\n+#define ABI_GAS_ASM_SPEC \"%{mabi=*} %{!mabi=*:-mabi=32}\"\n+\n+#elif MIPS_ABI_DEFAULT == ABI_N32\n+#define ABI_GAS_ASM_SPEC \"%{mabi=*} %{!mabi=*:-mabi=n32}\"\n+\n+#elif MIPS_ABI_DEFAULT == ABI_64\n+#define ABI_GAS_ASM_SPEC \"%{mabi=*} %{!mabi=*:-mabi=64}\"\n+\n+#elif MIPS_ABI_DEFAULT == ABI_EABI\n+#define ABI_GAS_ASM_SPEC \"%{mabi=*} %{!mabi=*:-mabi=eabi}\"\n+\n+#elif MIPS_ABI_DEFAULT == ABI_O64\n+#define ABI_GAS_ASM_SPEC \"\\\n+%{mabi=*} \\\n+%{!mabi=*:%{mips1|mips2|mips32:-mabi=32} %{!mips1:%{!mips2:%{!mips32:-mabi=o64}}}}\"\n+\n+#elif MIPS_ABI_DEFAULT == ABI_MEABI\n+#define ABI_GAS_ASM_SPEC \"\\\n+%{mabi=*} \\\n+%{!mabi=*:-mabi=meabi }\"\n+\n+#else\n+ #error \"Unhandled MIPS_ABI_DEFAULT\"\n+#endif\n+\n \n /* TARGET_ASM_SPEC is used to select either MIPS_AS_ASM_SPEC or\n    GAS_ASM_SPEC as the default, depending upon the value of\n@@ -873,12 +951,11 @@ while (0)\n \n #undef ASM_SPEC\n #define ASM_SPEC \"\\\n-%{!membedded-pic:%{G*}} %(endian_spec) %{mips1} %{mips2} %{mips3} %{mips4} \\\n+%{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{mips4} %{mips32} %{mips64}\\\n %{mips16:%{!mno-mips16:-mips16}} %{mno-mips16:-no-mips16} \\\n %(subtarget_asm_optimizing_spec) \\\n %(subtarget_asm_debugging_spec) \\\n %{membedded-pic} \\\n-%{mfix7000} \\\n %{mabi=32:-32}%{mabi=o32:-32}%{mabi=n32:-n32}%{mabi=64:-64}%{mabi=n64:-64} \\\n %(target_asm_spec) \\\n %(subtarget_asm_spec)\"\n@@ -929,9 +1006,10 @@ while (0)\n #ifndef LINK_SPEC\n #define LINK_SPEC \"\\\n %(endian_spec) \\\n-%{G*} %{mips1} %{mips2} %{mips3} %{mips4} \\\n+%{G*} %{mips1} %{mips2} %{mips3} %{mips4} %{mips32} %{mips64} \\\n %{bestGnum} %{shared} %{non_shared}\"\n-#endif\t/* LINK_SPEC defined */\n+#endif  /* LINK_SPEC defined */\n+\n \n /* Specs for the compiler proper */\n \n@@ -962,6 +1040,8 @@ while (0)\n %{mips1:-mfp32 -mgp32} %{mips2:-mfp32 -mgp32}\\\n %{mips3:%{!msingle-float:%{!m4650:-mfp64}} -mgp64} \\\n %{mips4:%{!msingle-float:%{!m4650:-mfp64}} -mgp64} \\\n+%{mips32:-mfp32 -mgp32} \\\n+%{mips64:%{!msingle-float:%{!m4650:-mfp64}} -mgp64} \\\n %{mfp64:%{msingle-float:%emay not use both -mfp64 and -msingle-float}} \\\n %{mfp64:%{m4650:%emay not use both -mfp64 and -m4650}} \\\n %{mint64|mlong64|mlong32:-mexplicit-type-size }\\\n@@ -983,7 +1063,7 @@ while (0)\n \n #ifndef SUBTARGET_CPP_SIZE_SPEC\n #define SUBTARGET_CPP_SIZE_SPEC \"\\\n-%{mlong64:%{!mips1:%{!mips2:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int}}} \\\n+%{mlong64:%{!mips1:%{!mips2:%{!mips32:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int}}}} \\\n %{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int}\"\n #endif\n \n@@ -1029,6 +1109,8 @@ while (0)\n %(subtarget_cpp_size_spec) \\\n %{mips3:-U__mips -D__mips=3 -D__mips64} \\\n %{mips4:-U__mips -D__mips=4 -D__mips64} \\\n+%{mips32:-U__mips -D__mips=32} \\\n+%{mips64:-U__mips -D__mips=64 -D__mips64} \\\n %{mgp32:-U__mips64} %{mgp64:-D__mips64} \\\n %{mfp32:-D__mips_fpr=32} %{mfp64:-D__mips_fpr=64} %{!mfp32: %{!mfp64: %{mgp32:-D__mips_fpr=32} %{!mgp32: %(cpp_fpr_spec)}}} \\\n %{msingle-float:%{!msoft-float:-D__mips_single_float}} \\\n@@ -1061,6 +1143,7 @@ while (0)\n   { \"cpp_fpr_spec\", CPP_FPR_SPEC },\t\t\t\t\t\\\n   { \"mips_as_asm_spec\", MIPS_AS_ASM_SPEC },\t\t\t\t\\\n   { \"gas_asm_spec\", GAS_ASM_SPEC },\t\t\t\t\t\\\n+  { \"abi_gas_asm_spec\", ABI_GAS_ASM_SPEC },                             \\\n   { \"target_asm_spec\", TARGET_ASM_SPEC },\t\t\t\t\\\n   { \"subtarget_mips_as_asm_spec\", SUBTARGET_MIPS_AS_ASM_SPEC }, \t\\\n   { \"subtarget_asm_optimizing_spec\", SUBTARGET_ASM_OPTIMIZING_SPEC },\t\\\n@@ -1519,7 +1602,9 @@ do {\t\t\t\t\t\t\t\\\n \n /* Force right-alignment for small varargs in 32 bit little_endian mode */\n \n-#define PAD_VARARGS_DOWN (TARGET_64BIT ? BYTES_BIG_ENDIAN : !BYTES_BIG_ENDIAN)\n+#define PAD_VARARGS_DOWN (TARGET_64BIT                                  \\\n+\t\t\t  || mips_abi == ABI_MEABI                      \\\n+\t\t\t     ? BYTES_BIG_ENDIAN : !BYTES_BIG_ENDIAN)\n \n /* Define this macro if an argument declared as `char' or `short' in a\n    prototype should actually be passed as an `int'.  In addition to\n@@ -1674,10 +1759,7 @@ do {\t\t\t\t\t\t\t\\\n    the R4000 with the FR bit set, the floating point uses register\n    pairs, with the second register not being allocable.  */\n \n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n-  (! FP_REG_P (REGNO)\t\t\t\t\t\t\t\\\n-\t? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD) \\\n-\t: ((GET_MODE_SIZE (MODE) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG))\n+#define HARD_REGNO_NREGS(REGNO, MODE) mips_hard_regno_nregs (REGNO, MODE)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode\n    MODE.  In 32 bit mode, require that DImode and DFmode be in even\n@@ -2546,6 +2628,7 @@ typedef struct mips_args {\n \t\t\t\t/* ??? The size is doubled to work around a\n \t\t\t\t   bug in the code that sets the adjustments\n \t\t\t\t   in function_arg.  */\n+  int prototype;                /* True if the function has a prototype.  */\n   struct rtx_def *adjust[MAX_ARGS_IN_REGISTERS*2];\n } CUMULATIVE_ARGS;\n \n@@ -4411,16 +4494,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Handle certain cpp directives used in header files on sysV.  */\n #define SCCS_DIRECTIVE\n \n-#ifndef ASM_OUTPUT_IDENT\n /* Output #ident as a in the read-only data section.  */\n+#undef  ASM_OUTPUT_IDENT\n #define ASM_OUTPUT_IDENT(FILE, STRING)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   const char *p = STRING;\t\t\t\t\t\t\\\n   int size = strlen (p) + 1;\t\t\t\t\t\t\\\n   rdata_section ();\t\t\t\t\t\t\t\\\n   assemble_string (p, size);\t\t\t\t\t\t\\\n }\n-#endif\n \f\n /* Default to -G 8 */\n #ifndef MIPS_DEFAULT_GVALUE"}, {"sha": "98ee650d22c9720c45a50616697e0aff42803f45", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 117, "deletions": 16, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=0e5a4ad8710376a670f22139b797da01f180249b", "patch": "@@ -30,6 +30,7 @@\n ;; Number\tUSE\n ;; 0\t\tmovsi_ul\n ;; 1\t\tmovsi_us, get_fnaddr\n+;; 2            reload_in*, reload_out* : sets delay on HILO register\n ;; 3\t\teh_set_return\n ;; 20\t\tbuiltin_setjmp_setup\n ;;\n@@ -119,7 +120,7 @@\n \n ;; ??? Fix everything that tests this attribute.\n (define_attr \"cpu\"\n-  \"default,r3000,r3900,r6000,r4000,r4100,r4300,r4600,r4650,r5000,r8000\"\n+  \"default,r3000,r3900,r6000,r4000,r4100,r4300,r4600,r4650,r5000,r8000,r4kc,r5kc,r20kc\"\n   (const (symbol_ref \"mips_cpu_attr\")))\n \n ;; Does the instruction have a mandatory delay slot?\n@@ -1711,7 +1712,7 @@\n   \"\"\n   \"\n {\n-  if (HAVE_mulsi3_mult3)\n+  if (GENERATE_MULT3_SI || TARGET_MAD)\n     emit_insn (gen_mulsi3_mult3 (operands[0], operands[1], operands[2]));\n   else if (!TARGET_MIPS4000 || TARGET_MIPS16)\n     emit_insn (gen_mulsi3_internal (operands[0], operands[1], operands[2]));\n@@ -1727,13 +1728,15 @@\n    (clobber (match_scratch:SI 3 \"=h,h\"))\n    (clobber (match_scratch:SI 4 \"=l,X\"))\n    (clobber (match_scratch:SI 5 \"=a,a\"))]\n-  \"GENERATE_MULT3\n+  \"GENERATE_MULT3_SI\n    || TARGET_MAD\"\n   \"*\n {\n   if (which_alternative == 1)\n     return \\\"mult\\\\t%1,%2\\\";\n-  if (TARGET_MAD)\n+  if (TARGET_MAD\n+      || mips_isa == 32\n+      || mips_isa == 64)\n     return \\\"mul\\\\t%0,%1,%2\\\";\n   return \\\"mult\\\\t%0,%1,%2\\\";\n }\"\n@@ -1796,12 +1799,15 @@\n    (clobber (match_scratch:SI 6 \"=a,a,a\"))\n    (clobber (match_scratch:SI 7 \"=X,X,d\"))]\n   \"TARGET_MIPS3900\n+   || ISA_HAS_MADD_MSUB\n    && !TARGET_MIPS16\"\n   \"*\n {\n   static const char *const madd[] = { \\\"madd\\\\t%1,%2\\\", \\\"madd\\\\t%0,%1,%2\\\" };\n   if (which_alternative == 2)\n     return \\\"#\\\";\n+  if (ISA_HAS_MADD_MSUB && which_alternative != 0)\n+    return \\\"#\\\";\n   return madd[which_alternative];\n }\"\n   [(set_attr \"type\"\t\"imul,imul,multi\")\n@@ -1827,6 +1833,90 @@\n    (set (match_dup 0) (plus:SI (match_dup 7) (match_dup 3)))]\n   \"\")\n \n+;; Splitter to copy result of MADD to a general register\n+(define_split\n+  [(set (match_operand:SI                   0 \"register_operand\" \"\")\n+        (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+                          (match_operand:SI 2 \"register_operand\" \"\"))\n+                 (match_operand:SI          3 \"register_operand\" \"\")))\n+   (clobber (match_scratch:SI               4 \"\"))\n+   (clobber (match_scratch:SI               5 \"\"))\n+   (clobber (match_scratch:SI               6 \"\"))\n+   (clobber (match_scratch:SI               7 \"\"))]\n+  \"reload_completed && GP_REG_P (true_regnum (operands[0]))\n+   && true_regnum (operands[3]) == LO_REGNUM\"\n+  [(parallel [(set (match_dup 3)\n+                   (plus:SI (mult:SI (match_dup 1) (match_dup 2))\n+                            (match_dup 3)))\n+              (clobber (match_dup 4))\n+              (clobber (match_dup 5))\n+              (clobber (match_dup 6))\n+              (clobber (match_dup 7))])\n+   (set (match_dup 0) (match_dup 3))]\n+  \"\")\n+\n+(define_insn \"*mul_sub_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,*d,*d\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\" \"0,l,*d\")\n+                  (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d,d\")\n+                           (match_operand:SI 3 \"register_operand\" \"d,d,d\"))))\n+   (clobber (match_scratch:SI 4 \"=h,h,h\"))\n+   (clobber (match_scratch:SI 5 \"=X,3,l\"))\n+   (clobber (match_scratch:SI 6 \"=a,a,a\"))\n+   (clobber (match_scratch:SI 7 \"=X,X,d\"))]\n+  \"ISA_HAS_MADD_MSUB\"\n+  \"*\n+{\n+  if (which_alternative != 0)\n+    return \\\"#\\\";\n+  return \\\"msub\\\\t%2,%3\\\";\n+}\"\n+  [(set_attr \"type\"     \"imul,imul,multi\")\n+   (set_attr \"mode\"     \"SI\")\n+   (set_attr \"length\"   \"4,8,8\")])\n+\n+;; Split the above insn if we failed to get LO allocated.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+                  (mult:SI (match_operand:SI 2 \"register_operand\" \"\")\n+                           (match_operand:SI 3 \"register_operand\" \"\"))))\n+   (clobber (match_scratch:SI 4 \"\"))\n+   (clobber (match_scratch:SI 5 \"\"))\n+   (clobber (match_scratch:SI 6 \"\"))\n+   (clobber (match_scratch:SI 7 \"\"))]\n+  \"reload_completed && GP_REG_P (true_regnum (operands[0])) && GP_REG_P (true_regnum (operands[1]))\"\n+  [(parallel [(set (match_dup 7)\n+                   (mult:SI (match_dup 2) (match_dup 3)))\n+              (clobber (match_dup 4))\n+              (clobber (match_dup 5))\n+              (clobber (match_dup 6))])\n+   (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 7)))]\n+  \"\")\n+\n+;; Splitter to copy result of MSUB to a general register\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+                  (mult:SI (match_operand:SI 2 \"register_operand\" \"\")\n+                           (match_operand:SI 3 \"register_operand\" \"\"))))\n+   (clobber (match_scratch:SI 4 \"\"))\n+   (clobber (match_scratch:SI 5 \"\"))\n+   (clobber (match_scratch:SI 6 \"\"))\n+   (clobber (match_scratch:SI 7 \"\"))]\n+  \"reload_completed && GP_REG_P (true_regnum (operands[0]))\n+   && true_regnum (operands[1]) == LO_REGNUM\"\n+  [(parallel [(set (match_dup 1)\n+                   (minus:SI (match_dup 1)\n+                             (mult:SI (match_dup 2) (match_dup 3))))\n+              (clobber (match_dup 4))\n+              (clobber (match_dup 5))\n+              (clobber (match_dup 6))\n+              (clobber (match_dup 7))])\n+   (set (match_dup 0) (match_dup 1))]\n+  \"\")\n+\n+\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n@@ -1855,7 +1945,7 @@\n \n   \"\n {\n-  if (GENERATE_MULT3 || TARGET_MIPS4000 || TARGET_MIPS16)\n+  if (GENERATE_MULT3_DI || TARGET_MIPS4000 || TARGET_MIPS16)\n     emit_insn (gen_muldi3_internal2 (operands[0], operands[1], operands[2]));\n   else\n     emit_insn (gen_muldi3_internal (operands[0], operands[1], operands[2]));\n@@ -1885,10 +1975,10 @@\n    (clobber (match_scratch:DI 3 \"=h\"))\n    (clobber (match_scratch:DI 4 \"=l\"))\n    (clobber (match_scratch:DI 5 \"=a\"))]\n-  \"TARGET_64BIT && (GENERATE_MULT3 || TARGET_MIPS4000 || TARGET_MIPS16)\"\n+  \"TARGET_64BIT && (GENERATE_MULT3_DI || TARGET_MIPS4000 || TARGET_MIPS16)\"\n   \"*\n {\n-  if (GENERATE_MULT3)\n+  if (GENERATE_MULT3_DI)\n     output_asm_insn (\\\"dmult\\\\t%0,%1,%2\\\", operands);\n   else\n     {\n@@ -1905,7 +1995,7 @@\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"DI\")\n    (set (attr \"length\")\n-\t(if_then_else (ne (symbol_ref \"GENERATE_MULT3\") (const_int 0))\n+\t(if_then_else (ne (symbol_ref \"GENERATE_MULT3_DI\") (const_int 0))\n \t\t       (const_int 4)\n \t\t       (const_int 12)))]) \t;; mult + mflo + delay\n \n@@ -5086,7 +5176,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t  emit_move_insn (gen_rtx_REG (SImode, 64), scratch);\n \t  emit_move_insn (scratch, lo_word);\n \t  emit_move_insn (gen_rtx (REG, SImode, 65), scratch);\n-          emit_insn (gen_rtx_USE (VOIDmode, operands[0]));\n+\t  emit_insn (gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, operands[0]), 2));\n \t}\n       else\n \t{\n@@ -5095,7 +5185,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t  emit_insn (gen_ashldi3 (scratch, operands[1], GEN_INT (32)));\n \t  emit_insn (gen_ashrdi3 (scratch, scratch, GEN_INT (32)));\n \t  emit_insn (gen_movdi (gen_rtx (REG, DImode, 65), scratch));\n-          emit_insn (gen_rtx_USE (VOIDmode, operands[0]));\n+          emit_insn (gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, operands[0]), 2));\n \t}\n       DONE;\n     }\n@@ -5107,7 +5197,7 @@ move\\\\t%0,%z4\\\\n\\\\\n       emit_insn (gen_movdi (operands[0], gen_rtx_REG (DImode, 64)));\n       emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT (32)));\n       emit_insn (gen_iordi3 (operands[0], operands[0], scratch));\n-      emit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n+      emit_insn (gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, operands[1]), 2));\n       DONE;\n     }\n   /* This handles moves between a float register and HI/LO.  */\n@@ -5137,7 +5227,7 @@ move\\\\t%0,%z4\\\\n\\\\\n       emit_insn (gen_ashldi3 (scratch, operands[1], GEN_INT (32)));\n       emit_insn (gen_ashrdi3 (scratch, scratch, GEN_INT (32)));\n       emit_insn (gen_movdi (gen_rtx (REG, DImode, 65), scratch));\n-      emit_insn (gen_rtx_USE (VOIDmode, operands[0]));\n+      emit_insn (gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, operands[0]), 2));\n       DONE;\n     }\n   if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == HILO_REGNUM)\n@@ -5166,7 +5256,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t  emit_move_insn (hi_word, scratch);\n \t  emit_move_insn (scratch, gen_rtx_REG (SImode, 65));\n \t  emit_move_insn (lo_word, scratch);\n-\t  emit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n+\t  emit_insn (gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, operands[1]), 2));\n \t}\n       else if (TARGET_MIPS16 && ! M16_REG_P (REGNO (operands[0])))\n \t{\n@@ -5181,7 +5271,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t  emit_insn (gen_ashldi3 (scratch2, scratch2, GEN_INT (32)));\n \t  emit_insn (gen_iordi3 (scratch, scratch, scratch2));\n \t  emit_insn (gen_movdi (operands[0], scratch));\n-\t  emit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n+\t  emit_insn (gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, operands[1]), 2));\n \t}\n       else\n \t{\n@@ -5191,7 +5281,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t  emit_insn (gen_movdi (operands[0], gen_rtx (REG, DImode, 64)));\n \t  emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT (32)));\n \t  emit_insn (gen_iordi3 (operands[0], operands[0], scratch));\n-\t  emit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n+\t  emit_insn (gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, operands[1]), 2));\n \t}\n       DONE;\n     }\n@@ -5517,7 +5607,7 @@ move\\\\t%0,%z4\\\\n\\\\\n       emit_insn (gen_movsi (gen_rtx_REG (SImode, 65), operands[1]));\n       emit_insn (gen_ashrsi3 (operands[2], operands[1], GEN_INT (31)));\n       emit_insn (gen_movsi (gen_rtx (REG, SImode, 64), operands[2]));\n-      emit_insn (gen_rtx_USE (VOIDmode, operands[0]));\n+      emit_insn (gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, operands[0]), 2));\n       DONE;\n     }\n   /* Use a mult to reload LO on mips16.  ??? This is hideous.  */\n@@ -5642,6 +5732,15 @@ move\\\\t%0,%z4\\\\n\\\\\n   DONE;\n }\")\n \n+;; This insn is for the unspec delay for HILO.\n+\n+(define_insn \"*HILO_delay\"\n+  [(unspec [(match_operand 0 \"register_operand\" \"=b\")] 2 )]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\" \"nop\")\n+   (set_attr \"mode\" \"none\")])\n+\n ;; This insn handles moving CCmode values.  It's really just a\n ;; slightly simplified copy of movsi_internal2, with additional cases\n ;; to move a condition register to a general register and to move\n@@ -10339,6 +10438,8 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\;j\\\\t%2\"\n   \"(ISA_HAS_CONDMOVE || ISA_HAS_INT_CONDMOVE) && TARGET_64BIT\"\n   \"\n {\n+  if (mips_isa == 32)\n+    FAIL;\n   gen_conditional_move (operands);\n   DONE;\n }\")"}, {"sha": "22afb216f9385a95bf19e7f3efb5a28dc59fbedf", "filename": "gcc/config/mips/t-isa3264", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Ft-isa3264", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5a4ad8710376a670f22139b797da01f180249b/gcc%2Fconfig%2Fmips%2Ft-isa3264", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-isa3264?ref=0e5a4ad8710376a670f22139b797da01f180249b", "patch": "@@ -0,0 +1,103 @@\n+CONFIG2_H\t= $(srcdir)/config/mips/isa3264.h $(srcdir)/config/mips/elf.h $(srcdir)/config/mips/ecoff.h $(srcdir)/config/mips/mips.h\n+\n+# Suppress building libgcc1.a, since the MIPS compiler port is complete\n+# and does not need anything from libgcc1.a.\n+LIBGCC1 =\n+\n+# Don't let CTOR_LIST end up in sdata section.\n+CRTSTUFF_T_CFLAGS = -G 0\n+\n+# Assemble startup files.\n+$(T)crti.o: $(srcdir)/config/mips/crti.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n+\t-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/mips/crti.asm\n+\n+$(T)crtn.o: $(srcdir)/config/mips/crtn.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n+\t-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/mips/crtn.asm\n+\n+# When building a cross compiler, put the mips16 support functions in\n+# libgcc1.a.\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = mips/mips16.S\n+LIB1ASMFUNCS = _m16addsf3 _m16subsf3 _m16mulsf3 _m16divsf3 \\\n+\t_m16eqsf2 _m16nesf2 _m16gtsf2 _m16gesf2 _m16lesf2 _m16ltsf2 \\\n+\t_m16fltsisf _m16fixsfsi \\\n+\t_m16adddf3 _m16subdf3 _m16muldf3 _m16divdf3 \\\n+\t_m16extsfdf2 _m16trdfsf2 \\\n+\t_m16eqdf2 _m16nedf2 _m16gtdf2 _m16gedf2 _m16ledf2 _m16ltdf2 \\\n+\t_m16fltsidf _m16fixdfsi \\\n+\t_m16retsf _m16retdf \\\n+\t_m16stub1 _m16stub2 _m16stub5 _m16stub6 _m16stub9 _m16stub10 \\\n+\t_m16stubsf0 _m16stubsf1 _m16stubsf2 _m16stubsf5 _m16stubsf6 \\\n+\t_m16stubsf9 _m16stubsf10 \\\n+\t_m16stubdf0 _m16stubdf1 _m16stubdf2 _m16stubdf5 _m16stubdf6 \\\n+\t_m16stubdf9 _m16stubdf10\n+\n+# We must build libgcc2.a with -G 0, in case the user wants to link\n+# without the $gp register.\n+TARGET_LIBGCC2_CFLAGS = -G 0\n+\n+# fp-bit and dp-bit are really part of libgcc1, but this will cause\n+# them to be built correctly, so... [taken from t-sparclite]\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifdef __MIPSEL__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#endif' >> dp-bit.c\n+\techo '#define US_SOFTWARE_GOFAST' >> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifdef __MIPSEL__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n+\techo '#endif' >> fp-bit.c\n+\techo '#define US_SOFTWARE_GOFAST' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+# Build the libraries for both hard and soft floating point\n+\n+MULTILIB_OPTIONS = msoft-float EL/EB mips32/mips64\n+MULTILIB_DIRNAMES = soft-float el eb mips32 mips64\n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n+# Add additional dependencies to recompile selected modules whenever the\n+# tm.h file changes.  The files compiled are:\n+#\n+#\tgcc.c\t\t(*_SPEC changes)\n+#\ttoplev.c\t(new switches + assembly output changes)\n+#\tsdbout.c\t(debug format changes)\n+#\tdbxout.c\t(debug format changes)\n+#\tdwarfout.c\t(debug format changes)\n+#\tfinal.c\t\t(assembly output changes)\n+#\tvarasm.c\t(assembly output changes)\n+#\tcse.c\t\t(cost functions)\n+#\tinsn-output.c\t(possible ifdef changes in tm.h)\n+#\tregclass.c\t(fixed/call used register changes)\n+#\tcccp.c\t\t(new preprocessor macros, -v version #)\n+#\texplow.c\t(GO_IF_LEGITIMATE_ADDRESS)\n+#\trecog.c\t\t(GO_IF_LEGITIMATE_ADDRESS)\n+#\treload.c\t(GO_IF_LEGITIMATE_ADDRESS)\n+\n+gcc.o: $(CONFIG2_H)\n+toplev.o: $(CONFIG2_H)\n+sdbout.o: $(CONFIG2_H)\n+dbxout.o: $(CONFIG2_H)\n+dwarfout.o: $(CONFIG2_H)\n+final.o: $(CONFIG2_H)\n+varasm.o: $(CONFIG2_H)\n+cse.o: $(CONFIG2_H)\n+insn-output.o: $(CONFIG2_H)\n+regclass.o: $(CONFIG2_H)\n+cccp.o: $(CONFIG2_H)\n+explow.o: $(CONFIG2_H)\n+recog.o: $(CONFIG2_H)\n+reload.o: $(CONFIG2_H)"}]}