{"sha": "1ac2bdb45faaa455afcb3b77eb824dde429c27fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFjMmJkYjQ1ZmFhYTQ1NWFmY2IzYjc3ZWI4MjRkZGU0MjljMjdmYg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-08T12:29:44Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-08T12:29:44Z"}, "message": "Port IPA CP to edge_clone_summaries.\n\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* ipa-cp.c (class edge_clone_summary): New summary.\n\t(grow_edge_clone_vectors): Remove.\n\t(ipcp_edge_duplication_hook): Remove.\n\t(class edge_clone_summary_t): New call_summary class.\n\t(ipcp_edge_removal_hook): Remove.\n\t(edge_clone_summary_t::duplicate): New function.\n\t(get_next_cgraph_edge_clone): Use edge_clone_summaries.\n\t(create_specialized_node): Likewise.\n\t(ipcp_driver): Initialize edge_clone_summaries and do not\n\tregister hooks.\n\nFrom-SVN: r261317", "tree": {"sha": "12d191052f225734708dc0a28f04a3863f46dd99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12d191052f225734708dc0a28f04a3863f46dd99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ac2bdb45faaa455afcb3b77eb824dde429c27fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ac2bdb45faaa455afcb3b77eb824dde429c27fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ac2bdb45faaa455afcb3b77eb824dde429c27fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ac2bdb45faaa455afcb3b77eb824dde429c27fb/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dbea5bf947c6e39016869dc382636345c1aa02b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbea5bf947c6e39016869dc382636345c1aa02b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbea5bf947c6e39016869dc382636345c1aa02b7"}], "stats": {"total": 115, "additions": 62, "deletions": 53}, "files": [{"sha": "a3543c31450526258ff77f05aa1802293ecf685e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ac2bdb45faaa455afcb3b77eb824dde429c27fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ac2bdb45faaa455afcb3b77eb824dde429c27fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ac2bdb45faaa455afcb3b77eb824dde429c27fb", "patch": "@@ -1,3 +1,16 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-cp.c (class edge_clone_summary): New summary.\n+\t(grow_edge_clone_vectors): Remove.\n+\t(ipcp_edge_duplication_hook): Remove.\n+\t(class edge_clone_summary_t): New call_summary class.\n+\t(ipcp_edge_removal_hook): Remove.\n+\t(edge_clone_summary_t::duplicate): New function.\n+\t(get_next_cgraph_edge_clone): Use edge_clone_summaries.\n+\t(create_specialized_node): Likewise.\n+\t(ipcp_driver): Initialize edge_clone_summaries and do not\n+\tregister hooks.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* symbol-summary.h (get): New function."}, {"sha": "435c9ee1638799dbe414da108391d76917447c3c", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 49, "deletions": 53, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ac2bdb45faaa455afcb3b77eb824dde429c27fb/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ac2bdb45faaa455afcb3b77eb824dde429c27fb/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=1ac2bdb45faaa455afcb3b77eb824dde429c27fb", "patch": "@@ -3374,54 +3374,56 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n     ipa_update_overall_fn_summary (node);\n }\n \n-/* Vector of pointers which for linked lists of clones of an original crgaph\n-   edge. */\n+class edge_clone_summary;\n+static call_summary <edge_clone_summary *> *edge_clone_summaries = NULL;\n \n-static vec<cgraph_edge *> next_edge_clone;\n-static vec<cgraph_edge *> prev_edge_clone;\n+/* Edge clone summary.  */\n \n-static inline void\n-grow_edge_clone_vectors (void)\n+struct edge_clone_summary\n {\n-  if (next_edge_clone.length ()\n-      <=  (unsigned) symtab->edges_max_uid)\n-    next_edge_clone.safe_grow_cleared (symtab->edges_max_uid + 1);\n-  if (prev_edge_clone.length ()\n-      <=  (unsigned) symtab->edges_max_uid)\n-    prev_edge_clone.safe_grow_cleared (symtab->edges_max_uid + 1);\n-}\n+  /* Default constructor.  */\n+  edge_clone_summary (): prev_clone (NULL), next_clone (NULL) {}\n \n-/* Edge duplication hook to grow the appropriate linked list in\n-   next_edge_clone. */\n+  /* Default destructor.  */\n+  ~edge_clone_summary ()\n+  {\n+    if (prev_clone)\n+      edge_clone_summaries->get (prev_clone)->next_clone = next_clone;\n+    if (next_clone)\n+      edge_clone_summaries->get (next_clone)->prev_clone = prev_clone;\n+  }\n \n-static void\n-ipcp_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n-\t\t\t    void *)\n-{\n-  grow_edge_clone_vectors ();\n+  cgraph_edge *prev_clone;\n+  cgraph_edge *next_clone;\n+};\n \n-  struct cgraph_edge *old_next = next_edge_clone[src->uid];\n-  if (old_next)\n-    prev_edge_clone[old_next->uid] = dst;\n-  prev_edge_clone[dst->uid] = src;\n+class edge_clone_summary_t:\n+  public call_summary <edge_clone_summary *>\n+{\n+public:\n+  edge_clone_summary_t (symbol_table *symtab):\n+    call_summary <edge_clone_summary *> (symtab)\n+    {\n+      m_initialize_when_cloning = true;\n+    }\n \n-  next_edge_clone[dst->uid] = old_next;\n-  next_edge_clone[src->uid] = dst;\n-}\n+  virtual void duplicate (cgraph_edge *src_edge, cgraph_edge *dst_edge,\n+\t\t\t  edge_clone_summary *src_data,\n+\t\t\t  edge_clone_summary *dst_data);\n+};\n \n-/* Hook that is called by cgraph.c when an edge is removed.  */\n+/* Edge duplication hook.  */\n \n-static void\n-ipcp_edge_removal_hook (struct cgraph_edge *cs, void *)\n+void\n+edge_clone_summary_t::duplicate (cgraph_edge *src_edge, cgraph_edge *dst_edge,\n+\t\t\t\t edge_clone_summary *src_data,\n+\t\t\t\t edge_clone_summary *dst_data)\n {\n-  grow_edge_clone_vectors ();\n-\n-  struct cgraph_edge *prev = prev_edge_clone[cs->uid];\n-  struct cgraph_edge *next = next_edge_clone[cs->uid];\n-  if (prev)\n-    next_edge_clone[prev->uid] = next;\n-  if (next)\n-    prev_edge_clone[next->uid] = prev;\n+  if (src_data->next_clone)\n+    edge_clone_summaries->get (src_data->next_clone)->prev_clone = dst_edge;\n+  dst_data->prev_clone = src_edge;\n+  dst_data->next_clone = src_data->next_clone;\n+  src_data->next_clone = dst_edge;\n }\n \n /* See if NODE is a clone with a known aggregate value at a given OFFSET of a\n@@ -3549,7 +3551,8 @@ cgraph_edge_brings_value_p (cgraph_edge *cs,\n static inline struct cgraph_edge *\n get_next_cgraph_edge_clone (struct cgraph_edge *cs)\n {\n-  return next_edge_clone[cs->uid];\n+  edge_clone_summary *s = edge_clone_summaries->get (cs);\n+  return s != NULL ? s->next_clone : NULL;\n }\n \n /* Given VAL that is intended for DEST, iterate over all its sources and if any\n@@ -3853,7 +3856,7 @@ create_specialized_node (struct cgraph_node *node,\n   bool have_self_recursive_calls = !self_recursive_calls.is_empty ();\n   for (unsigned j = 0; j < self_recursive_calls.length (); j++)\n     {\n-      cgraph_edge *cs = next_edge_clone[self_recursive_calls[j]->uid];\n+      cgraph_edge *cs = get_next_cgraph_edge_clone (self_recursive_calls[j]);\n       /* Cloned edges can disappear during cloning as speculation can be\n \t resolved, check that we have one and that it comes from the last\n \t cloning.  */\n@@ -3863,8 +3866,8 @@ create_specialized_node (struct cgraph_node *node,\n \t edge would confuse this mechanism, so let's check that does not\n \t happen.  */\n       gcc_checking_assert (!cs\n-\t\t\t   || !next_edge_clone[cs->uid]\n-\t\t\t   || next_edge_clone[cs->uid]->caller != new_node);\n+\t\t\t   || !get_next_cgraph_edge_clone (cs)\n+\t\t\t   || get_next_cgraph_edge_clone (cs)->caller != new_node);\n     }\n   if (have_self_recursive_calls)\n     new_node->expand_all_artificial_thunks ();\n@@ -5055,17 +5058,13 @@ ipcp_store_vr_results (void)\n static unsigned int\n ipcp_driver (void)\n {\n-  struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n-  struct cgraph_edge_hook_list *edge_removal_hook_holder;\n   struct ipa_topo_info topo;\n \n+  if (edge_clone_summaries == NULL)\n+    edge_clone_summaries = new edge_clone_summary_t (symtab);\n+\n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n-  grow_edge_clone_vectors ();\n-  edge_duplication_hook_holder\n-    = symtab->add_edge_duplication_hook (&ipcp_edge_duplication_hook, NULL);\n-  edge_removal_hook_holder\n-    = symtab->add_edge_removal_hook (&ipcp_edge_removal_hook, NULL);\n \n   if (dump_file)\n     {\n@@ -5088,10 +5087,7 @@ ipcp_driver (void)\n \n   /* Free all IPCP structures.  */\n   free_toporder_info (&topo);\n-  next_edge_clone.release ();\n-  prev_edge_clone.release ();\n-  symtab->remove_edge_removal_hook (edge_removal_hook_holder);\n-  symtab->remove_edge_duplication_hook (edge_duplication_hook_holder);\n+  delete edge_clone_summaries;\n   ipa_free_all_structures_after_ipa_cp ();\n   if (dump_file)\n     fprintf (dump_file, \"\\nIPA constant propagation end\\n\");"}]}