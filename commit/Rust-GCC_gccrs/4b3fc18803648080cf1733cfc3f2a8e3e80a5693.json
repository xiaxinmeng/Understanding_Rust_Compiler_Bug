{"sha": "4b3fc18803648080cf1733cfc3f2a8e3e80a5693", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIzZmMxODgwMzY0ODA4MGNmMTczM2NmYzNmMmE4ZTNlODBhNTY5Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2019-12-10T03:41:49Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-12-10T03:41:49Z"}, "message": "libbacktrace: remove duplicate low_pc/high_pc/range handling\n\n\t* dwarf.c (struct pcrange): Define.\n\t(update_pcrange, add_ranges): New static functions.\n\t(add_unit_addr): Change signature to work with add_ranges.  Don't\n\tadd base_address here.\n\t(add_unit_ranges): Remove.\n\t(find_address_ranges): Replace str/ranges parameters with\n\tdwarf_sections.  Use update_pcrange and add_ranges.  Change all\n\tcallers.\n\t(add_function_range): Change signature to work with add_ranges.\n\tDon't add base_address here.\n\t(add_function_ranges): Remove.\n\t(read_function_entry): Use update_pcrange and add_ranges.\n\nFrom-SVN: r279154", "tree": {"sha": "886184cf9dcd8d55a123d2aa1a5cc0c7b1d48a79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/886184cf9dcd8d55a123d2aa1a5cc0c7b1d48a79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b3fc18803648080cf1733cfc3f2a8e3e80a5693", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b3fc18803648080cf1733cfc3f2a8e3e80a5693", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b3fc18803648080cf1733cfc3f2a8e3e80a5693", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b3fc18803648080cf1733cfc3f2a8e3e80a5693/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d68f5d458d7df12b31d27094e8f7ed0208ccf693", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d68f5d458d7df12b31d27094e8f7ed0208ccf693", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d68f5d458d7df12b31d27094e8f7ed0208ccf693"}], "stats": {"total": 414, "additions": 179, "deletions": 235}, "files": [{"sha": "7d91aadb818483a08f70dacdacf84c8888c64fbb", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b3fc18803648080cf1733cfc3f2a8e3e80a5693/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b3fc18803648080cf1733cfc3f2a8e3e80a5693/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=4b3fc18803648080cf1733cfc3f2a8e3e80a5693", "patch": "@@ -1,3 +1,18 @@\n+2019-12-08  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* dwarf.c (struct pcrange): Define.\n+\t(update_pcrange, add_ranges): New static functions.\n+\t(add_unit_addr): Change signature to work with add_ranges.  Don't\n+\tadd base_address here.\n+\t(add_unit_ranges): Remove.\n+\t(find_address_ranges): Replace str/ranges parameters with\n+\tdwarf_sections.  Use update_pcrange and add_ranges.  Change all\n+\tcallers.\n+\t(add_function_range): Change signature to work with add_ranges.\n+\tDon't add base_address here.\n+\t(add_function_ranges): Remove.\n+\t(read_function_entry): Use update_pcrange and add_ranges.\n+\n 2019-12-04  Ian Lance Taylor  <iant@golang.org>\n \n \t* edtest.c (test1): Add noclone attribute."}, {"sha": "9e00792da506df6228e5475f52d97dd831582452", "filename": "libbacktrace/dwarf.c", "status": "modified", "additions": 164, "deletions": 235, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b3fc18803648080cf1733cfc3f2a8e3e80a5693/libbacktrace%2Fdwarf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b3fc18803648080cf1733cfc3f2a8e3e80a5693/libbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fdwarf.c?ref=4b3fc18803648080cf1733cfc3f2a8e3e80a5693", "patch": "@@ -945,31 +945,28 @@ function_addrs_search (const void *vkey, const void *ventry)\n     return 0;\n }\n \n-/* Add a new compilation unit address range to a vector.  Returns 1 on\n-   success, 0 on failure.  */\n+/* Add a new compilation unit address range to a vector.  This is\n+   called via add_ranges.  Returns 1 on success, 0 on failure.  */\n \n static int\n-add_unit_addr (struct backtrace_state *state, uintptr_t base_address,\n-\t       struct unit_addrs addrs,\n+add_unit_addr (struct backtrace_state *state, void *rdata,\n+\t       uint64_t lowpc, uint64_t highpc,\n \t       backtrace_error_callback error_callback, void *data,\n-\t       struct unit_addrs_vector *vec)\n+\t       void *pvec)\n {\n+  struct unit *u = (struct unit *) rdata;\n+  struct unit_addrs_vector *vec = (struct unit_addrs_vector *) pvec;\n   struct unit_addrs *p;\n \n-  /* Add in the base address of the module here, so that we can look\n-     up the PC directly.  */\n-  addrs.low += base_address;\n-  addrs.high += base_address;\n-\n   /* Try to merge with the last entry.  */\n   if (vec->count > 0)\n     {\n       p = (struct unit_addrs *) vec->vec.base + (vec->count - 1);\n-      if ((addrs.low == p->high || addrs.low == p->high + 1)\n-\t  && addrs.u == p->u)\n+      if ((lowpc == p->high || lowpc == p->high + 1)\n+\t  && u == p->u)\n \t{\n-\t  if (addrs.high > p->high)\n-\t    p->high = addrs.high;\n+\t  if (highpc > p->high)\n+\t    p->high = highpc;\n \t  return 1;\n \t}\n     }\n@@ -980,8 +977,12 @@ add_unit_addr (struct backtrace_state *state, uintptr_t base_address,\n   if (p == NULL)\n     return 0;\n \n-  *p = addrs;\n+  p->low = lowpc;\n+  p->high = highpc;\n+  p->u = u;\n+\n   ++vec->count;\n+\n   return 1;\n }\n \n@@ -1262,29 +1263,122 @@ lookup_abbrev (struct abbrevs *abbrevs, uint64_t code,\n   return (const struct abbrev *) p;\n }\n \n-/* Add non-contiguous address ranges for a compilation unit.  Returns\n-   1 on success, 0 on failure.  */\n+/* This struct is used to gather address range information while\n+   reading attributes.  We use this while building a mapping from\n+   address ranges to compilation units and then again while mapping\n+   from address ranges to function entries.  Normally either\n+   lowpc/highpc is set or ranges is set.  */\n+\n+struct pcrange {\n+  uint64_t lowpc;\t\t/* The low PC value.  */\n+  int have_lowpc;\t\t/* Whether a low PC value was found.  */\n+  uint64_t highpc;\t\t/* The high PC value.  */\n+  int have_highpc;\t\t/* Whether a high PC value was found.  */\n+  int highpc_is_relative;\t/* Whether highpc is relative to lowpc.  */\n+  uint64_t ranges;\t\t/* Offset in ranges section.  */\n+  int have_ranges;\t\t/* Whether ranges is valid.  */\n+};\n+\n+/* Update PCRANGE from an attribute value.  */\n+\n+static void\n+update_pcrange (const struct attr* attr, const struct attr_val* val,\n+\t\tstruct pcrange *pcrange)\n+{\n+  switch (attr->name)\n+    {\n+    case DW_AT_low_pc:\n+      if (val->encoding == ATTR_VAL_ADDRESS)\n+\t{\n+\t  pcrange->lowpc = val->u.uint;\n+\t  pcrange->have_lowpc = 1;\n+\t}\n+      break;\n+\n+    case DW_AT_high_pc:\n+      if (val->encoding == ATTR_VAL_ADDRESS)\n+\t{\n+\t  pcrange->highpc = val->u.uint;\n+\t  pcrange->have_highpc = 1;\n+\t}\n+      else if (val->encoding == ATTR_VAL_UINT)\n+\t{\n+\t  pcrange->highpc = val->u.uint;\n+\t  pcrange->have_highpc = 1;\n+\t  pcrange->highpc_is_relative = 1;\n+\t}\n+      break;\n+\n+    case DW_AT_ranges:\n+      if (val->encoding == ATTR_VAL_UINT\n+\t  || val->encoding == ATTR_VAL_REF_SECTION)\n+\t{\n+\t  pcrange->ranges = val->u.uint;\n+\t  pcrange->have_ranges = 1;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Call ADD_RANGE for each lowpc/highpc pair in PCRANGE.  RDATA is\n+   passed to ADD_RANGE, and is either a struct unit * or a struct\n+   function *.  VEC is the vector we are adding ranges to, and is\n+   either a struct unit_addrs_vector * or a struct function_vector *.\n+   Returns 1 on success, 0 on error.  */\n \n static int\n-add_unit_ranges (struct backtrace_state *state, uintptr_t base_address,\n-\t\t struct unit *u, uint64_t ranges, uint64_t base,\n-\t\t int is_bigendian, const unsigned char *dwarf_ranges,\n-\t\t size_t dwarf_ranges_size,\n-\t\t backtrace_error_callback error_callback, void *data,\n-\t\t struct unit_addrs_vector *addrs)\n+add_ranges (struct backtrace_state *state,\n+\t    const struct dwarf_sections *dwarf_sections,\n+\t    uintptr_t base_address, int is_bigendian,\n+\t    struct unit *u, uint64_t base, const struct pcrange *pcrange,\n+\t    int (*add_range) (struct backtrace_state *state, void *rdata, \n+\t\t\t      uint64_t lowpc, uint64_t highpc,\n+\t\t\t      backtrace_error_callback error_callback,\n+\t\t\t      void *data, void *vec),\n+\t    void *rdata,\n+\t    backtrace_error_callback error_callback, void *data,\n+\t    void *vec)\n {\n   struct dwarf_buf ranges_buf;\n \n-  if (ranges >= dwarf_ranges_size)\n+  if (pcrange->have_lowpc && pcrange->have_highpc)\n+    {\n+      uint64_t lowpc;\n+      uint64_t highpc;\n+\n+      lowpc = pcrange->lowpc;\n+      highpc = pcrange->highpc;\n+      if (pcrange->highpc_is_relative)\n+\thighpc += lowpc;\n+\n+      /* Add in the base address of the module when recording PC\n+\t values, so that we can look up the PC directly.  */\n+      lowpc += base_address;\n+      highpc += base_address;\n+\n+      return add_range (state, rdata, lowpc, highpc, error_callback, data,\n+\t\t\tvec);\n+    }\n+\n+  if (!pcrange->have_ranges)\n+    {\n+      /* Did not find any address ranges to add.  */\n+      return 1;\n+    }\n+\n+  if (pcrange->ranges >= dwarf_sections->size[DEBUG_RANGES])\n     {\n       error_callback (data, \"ranges offset out of range\", 0);\n       return 0;\n     }\n \n   ranges_buf.name = \".debug_ranges\";\n-  ranges_buf.start = dwarf_ranges;\n-  ranges_buf.buf = dwarf_ranges + ranges;\n-  ranges_buf.left = dwarf_ranges_size - ranges;\n+  ranges_buf.start = dwarf_sections->data[DEBUG_RANGES];\n+  ranges_buf.buf = dwarf_sections->data[DEBUG_RANGES] + pcrange->ranges;\n+  ranges_buf.left = dwarf_sections->size[DEBUG_RANGES] - pcrange->ranges;\n   ranges_buf.is_bigendian = is_bigendian;\n   ranges_buf.error_callback = error_callback;\n   ranges_buf.data = data;\n@@ -1308,13 +1402,10 @@ add_unit_ranges (struct backtrace_state *state, uintptr_t base_address,\n \tbase = high;\n       else\n \t{\n-\t  struct unit_addrs a;\n-\n-\t  a.low = low + base;\n-\t  a.high = high + base;\n-\t  a.u = u;\n-\t  if (!add_unit_addr (state, base_address, a, error_callback, data,\n-\t\t\t      addrs))\n+\t  if (!add_range (state, rdata, \n+\t\t\t  low + base + base_address,\n+\t\t\t  high + base + base_address,\n+\t\t\t  error_callback, data, vec))\n \t    return 0;\n \t}\n     }\n@@ -1332,9 +1423,7 @@ add_unit_ranges (struct backtrace_state *state, uintptr_t base_address,\n static int\n find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n \t\t     struct dwarf_buf *unit_buf,\n-\t\t     const unsigned char *dwarf_str, size_t dwarf_str_size,\n-\t\t     const unsigned char *dwarf_ranges,\n-\t\t     size_t dwarf_ranges_size,\n+\t\t     const struct dwarf_sections *dwarf_sections,\n \t\t     int is_bigendian, struct dwarf_data *altlink,\n \t\t     backtrace_error_callback error_callback, void *data,\n \t\t     struct unit *u, struct unit_addrs_vector *addrs,\n@@ -1344,13 +1433,7 @@ find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n     {\n       uint64_t code;\n       const struct abbrev *abbrev;\n-      uint64_t lowpc;\n-      int have_lowpc;\n-      uint64_t highpc;\n-      int have_highpc;\n-      int highpc_is_relative;\n-      uint64_t ranges;\n-      int have_ranges;\n+      struct pcrange pcrange;\n       size_t i;\n \n       code = read_uleb128 (unit_buf);\n@@ -1364,53 +1447,22 @@ find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n       if (unit_tag != NULL)\n \t*unit_tag = abbrev->tag;\n \n-      lowpc = 0;\n-      have_lowpc = 0;\n-      highpc = 0;\n-      have_highpc = 0;\n-      highpc_is_relative = 0;\n-      ranges = 0;\n-      have_ranges = 0;\n+      memset (&pcrange, 0, sizeof pcrange);\n       for (i = 0; i < abbrev->num_attrs; ++i)\n \t{\n \t  struct attr_val val;\n \n \t  if (!read_attribute (abbrev->attrs[i].form, unit_buf,\n \t\t\t       u->is_dwarf64, u->version, u->addrsize,\n-\t\t\t       dwarf_str, dwarf_str_size, altlink, &val))\n+\t\t\t       dwarf_sections->data[DEBUG_STR],\n+\t\t\t       dwarf_sections->size[DEBUG_STR],\n+\t\t\t       altlink, &val))\n \t    return 0;\n \n \t  switch (abbrev->attrs[i].name)\n \t    {\n-\t    case DW_AT_low_pc:\n-\t      if (val.encoding == ATTR_VAL_ADDRESS)\n-\t\t{\n-\t\t  lowpc = val.u.uint;\n-\t\t  have_lowpc = 1;\n-\t\t}\n-\t      break;\n-\n-\t    case DW_AT_high_pc:\n-\t      if (val.encoding == ATTR_VAL_ADDRESS)\n-\t\t{\n-\t\t  highpc = val.u.uint;\n-\t\t  have_highpc = 1;\n-\t\t}\n-\t      else if (val.encoding == ATTR_VAL_UINT)\n-\t\t{\n-\t\t  highpc = val.u.uint;\n-\t\t  have_highpc = 1;\n-\t\t  highpc_is_relative = 1;\n-\t\t}\n-\t      break;\n-\n-\t    case DW_AT_ranges:\n-\t      if (val.encoding == ATTR_VAL_UINT\n-\t\t  || val.encoding == ATTR_VAL_REF_SECTION)\n-\t\t{\n-\t\t  ranges = val.u.uint;\n-\t\t  have_ranges = 1;\n-\t\t}\n+\t    case DW_AT_low_pc: case DW_AT_high_pc: case DW_AT_ranges:\n+\t      update_pcrange (&abbrev->attrs[i], &val, &pcrange);\n \t      break;\n \n \t    case DW_AT_stmt_list:\n@@ -1440,43 +1492,25 @@ find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n       if (abbrev->tag == DW_TAG_compile_unit\n \t  || abbrev->tag == DW_TAG_subprogram)\n \t{\n-\t  if (have_ranges)\n-\t    {\n-\t      if (!add_unit_ranges (state, base_address, u, ranges, lowpc,\n-\t\t\t\t    is_bigendian, dwarf_ranges,\n-\t\t\t\t    dwarf_ranges_size, error_callback,\n-\t\t\t\t    data, addrs))\n-\t\treturn 0;\n-\t    }\n-\t  else if (have_lowpc && have_highpc)\n-\t    {\n-\t      struct unit_addrs a;\n-\n-\t      if (highpc_is_relative)\n-\t\thighpc += lowpc;\n-\t      a.low = lowpc;\n-\t      a.high = highpc;\n-\t      a.u = u;\n-\n-\t      if (!add_unit_addr (state, base_address, a, error_callback, data,\n-\t\t\t\t  addrs))\n-\t\treturn 0;\n-\t    }\n+\t  if (!add_ranges (state, dwarf_sections, base_address,\n+\t\t\t   is_bigendian, u, pcrange.lowpc, &pcrange,\n+\t\t\t   add_unit_addr, (void *) u, error_callback, data,\n+\t\t\t   (void *) addrs))\n+\t    return 0;\n \n \t  /* If we found the PC range in the DW_TAG_compile_unit, we\n \t     can stop now.  */\n \t  if (abbrev->tag == DW_TAG_compile_unit\n-\t      && (have_ranges || (have_lowpc && have_highpc)))\n+\t      && (pcrange.have_ranges\n+\t\t  || (pcrange.have_lowpc && pcrange.have_highpc)))\n \t    return 1;\n \t}\n \n       if (abbrev->has_children)\n \t{\n \t  if (!find_address_ranges (state, base_address, unit_buf,\n-\t\t\t\t    dwarf_str, dwarf_str_size,\n-\t\t\t\t    dwarf_ranges, dwarf_ranges_size,\n-\t\t\t\t    is_bigendian, altlink, error_callback, data,\n-\t\t\t\t    u, addrs, NULL))\n+\t\t\t\t    dwarf_sections, is_bigendian, altlink,\n+\t\t\t\t    error_callback, data, u, addrs, NULL))\n \t    return 0;\n \t}\n     }\n@@ -1599,11 +1633,7 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n       u->function_addrs = NULL;\n       u->function_addrs_count = 0;\n \n-      if (!find_address_ranges (state, base_address, &unit_buf,\n-\t\t\t\tdwarf_sections->data[DEBUG_STR],\n-\t\t\t\tdwarf_sections->size[DEBUG_STR],\n-\t\t\t\tdwarf_sections->data[DEBUG_RANGES],\n-\t\t\t\tdwarf_sections->size[DEBUG_RANGES],\n+      if (!find_address_ranges (state, base_address, &unit_buf, dwarf_sections,\n \t\t\t\tis_bigendian, altlink, error_callback, data,\n \t\t\t\tu, addrs, &unit_tag))\n \tgoto fail;\n@@ -2304,25 +2334,22 @@ read_referenced_name (struct dwarf_data *ddata, struct unit *u,\n   return ret;\n }\n \n-/* Add a single range to U that maps to function.  Returns 1 on\n-   success, 0 on error.  */\n+/* Add a range to a unit that maps to a function.  This is called via\n+   add_ranges.  Returns 1 on success, 0 on error.  */\n \n static int\n-add_function_range (struct backtrace_state *state, struct dwarf_data *ddata,\n-\t\t    struct function *function, uint64_t lowpc, uint64_t highpc,\n-\t\t    backtrace_error_callback error_callback,\n-\t\t    void *data, struct function_vector *vec)\n+add_function_range (struct backtrace_state *state, void *rdata,\n+\t\t    uint64_t lowpc, uint64_t highpc,\n+\t\t    backtrace_error_callback error_callback, void *data,\n+\t\t    void *pvec)\n {\n+  struct function *function = (struct function *) rdata;\n+  struct function_vector *vec = (struct function_vector *) pvec;\n   struct function_addrs *p;\n \n-  /* Add in the base address here, so that we can look up the PC\n-     directly.  */\n-  lowpc += ddata->base_address;\n-  highpc += ddata->base_address;\n-\n   if (vec->count > 0)\n     {\n-      p = (struct function_addrs *) vec->vec.base + vec->count - 1;\n+      p = (struct function_addrs *) vec->vec.base + (vec->count - 1);\n       if ((lowpc == p->high || lowpc == p->high + 1)\n \t  && function == p->function)\n \t{\n@@ -2341,63 +2368,8 @@ add_function_range (struct backtrace_state *state, struct dwarf_data *ddata,\n   p->low = lowpc;\n   p->high = highpc;\n   p->function = function;\n-  ++vec->count;\n-  return 1;\n-}\n-\n-/* Add PC ranges to U that map to FUNCTION.  Returns 1 on success, 0\n-   on error.  */\n-\n-static int\n-add_function_ranges (struct backtrace_state *state, struct dwarf_data *ddata,\n-\t\t     struct unit *u, struct function *function,\n-\t\t     uint64_t ranges, uint64_t base,\n-\t\t     backtrace_error_callback error_callback, void *data,\n-\t\t     struct function_vector *vec)\n-{\n-  struct dwarf_buf ranges_buf;\n-\n-  if (ranges >= ddata->dwarf_sections.size[DEBUG_RANGES])\n-    {\n-      error_callback (data, \"function ranges offset out of range\", 0);\n-      return 0;\n-    }\n-\n-  ranges_buf.name = \".debug_ranges\";\n-  ranges_buf.start = ddata->dwarf_sections.data[DEBUG_RANGES];\n-  ranges_buf.buf = ddata->dwarf_sections.data[DEBUG_RANGES] + ranges;\n-  ranges_buf.left = ddata->dwarf_sections.size[DEBUG_RANGES] - ranges;\n-  ranges_buf.is_bigendian = ddata->is_bigendian;\n-  ranges_buf.error_callback = error_callback;\n-  ranges_buf.data = data;\n-  ranges_buf.reported_underflow = 0;\n-\n-  while (1)\n-    {\n-      uint64_t low;\n-      uint64_t high;\n-\n-      if (ranges_buf.reported_underflow)\n-\treturn 0;\n \n-      low = read_address (&ranges_buf, u->addrsize);\n-      high = read_address (&ranges_buf, u->addrsize);\n-\n-      if (low == 0 && high == 0)\n-\tbreak;\n-\n-      if (is_highest_address (low, u->addrsize))\n-\tbase = high;\n-      else\n-\t{\n-\t  if (!add_function_range (state, ddata, function, low + base,\n-\t\t\t\t   high + base, error_callback, data, vec))\n-\t    return 0;\n-\t}\n-    }\n-\n-  if (ranges_buf.reported_underflow)\n-    return 0;\n+  ++vec->count;\n \n   return 1;\n }\n@@ -2421,13 +2393,7 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n       struct function *function;\n       struct function_vector *vec;\n       size_t i;\n-      uint64_t lowpc;\n-      int have_lowpc;\n-      uint64_t highpc;\n-      int have_highpc;\n-      int highpc_is_relative;\n-      uint64_t ranges;\n-      int have_ranges;\n+      struct pcrange pcrange;\n       int have_linkage_name;\n \n       code = read_uleb128 (unit_buf);\n@@ -2458,13 +2424,7 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n \t  memset (function, 0, sizeof *function);\n \t}\n \n-      lowpc = 0;\n-      have_lowpc = 0;\n-      highpc = 0;\n-      have_highpc = 0;\n-      highpc_is_relative = 0;\n-      ranges = 0;\n-      have_ranges = 0;\n+      memset (&pcrange, 0, sizeof pcrange);\n       have_linkage_name = 0;\n       for (i = 0; i < abbrev->num_attrs; ++i)\n \t{\n@@ -2549,35 +2509,8 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n \t\t    }\n \t\t  break;\n \n-\t\tcase DW_AT_low_pc:\n-\t\t  if (val.encoding == ATTR_VAL_ADDRESS)\n-\t\t    {\n-\t\t      lowpc = val.u.uint;\n-\t\t      have_lowpc = 1;\n-\t\t    }\n-\t\t  break;\n-\n-\t\tcase DW_AT_high_pc:\n-\t\t  if (val.encoding == ATTR_VAL_ADDRESS)\n-\t\t    {\n-\t\t      highpc = val.u.uint;\n-\t\t      have_highpc = 1;\n-\t\t    }\n-\t\t  else if (val.encoding == ATTR_VAL_UINT)\n-\t\t    {\n-\t\t      highpc = val.u.uint;\n-\t\t      have_highpc = 1;\n-\t\t      highpc_is_relative = 1;\n-\t\t    }\n-\t\t  break;\n-\n-\t\tcase DW_AT_ranges:\n-\t\t  if (val.encoding == ATTR_VAL_UINT\n-\t\t      || val.encoding == ATTR_VAL_REF_SECTION)\n-\t\t    {\n-\t\t      ranges = val.u.uint;\n-\t\t      have_ranges = 1;\n-\t\t    }\n+\t\tcase DW_AT_low_pc: case DW_AT_high_pc: case DW_AT_ranges:\n+\t\t  update_pcrange (&abbrev->attrs[i], &val, &pcrange);\n \t\t  break;\n \n \t\tdefault:\n@@ -2597,18 +2530,14 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n \n       if (is_function)\n \t{\n-\t  if (have_ranges)\n-\t    {\n-\t      if (!add_function_ranges (state, ddata, u, function, ranges,\n-\t\t\t\t\tbase, error_callback, data, vec))\n-\t\treturn 0;\n-\t    }\n-\t  else if (have_lowpc && have_highpc)\n+\t  if (pcrange.have_ranges\n+\t      || (pcrange.have_lowpc && pcrange.have_highpc))\n \t    {\n-\t      if (highpc_is_relative)\n-\t\thighpc += lowpc;\n-\t      if (!add_function_range (state, ddata, function, lowpc, highpc,\n-\t\t\t\t       error_callback, data, vec))\n+\t      if (!add_ranges (state, &ddata->dwarf_sections,\n+\t\t\t       ddata->base_address, ddata->is_bigendian,\n+\t\t\t       u, base, &pcrange, add_function_range,\n+\t\t\t       (void *) function, error_callback, data,\n+\t\t\t       (void *) vec))\n \t\treturn 0;\n \t    }\n \t  else"}]}