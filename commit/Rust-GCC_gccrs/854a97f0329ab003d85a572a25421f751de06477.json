{"sha": "854a97f0329ab003d85a572a25421f751de06477", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU0YTk3ZjAzMjlhYjAwM2Q4NWE1NzJhMjU0MjFmNzUxZGUwNjQ3Nw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-03T07:29:11Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-03T07:29:11Z"}, "message": "* toplev.c: Fix formatting.\n\nFrom-SVN: r35444", "tree": {"sha": "c759961129fbbb4344e37077279ce74c2b486473", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c759961129fbbb4344e37077279ce74c2b486473"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/854a97f0329ab003d85a572a25421f751de06477", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/854a97f0329ab003d85a572a25421f751de06477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/854a97f0329ab003d85a572a25421f751de06477", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/854a97f0329ab003d85a572a25421f751de06477/comments", "author": null, "committer": null, "parents": [{"sha": "66ed03f845c35c5b869534036d4dc1332f23452c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66ed03f845c35c5b869534036d4dc1332f23452c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66ed03f845c35c5b869534036d4dc1332f23452c"}], "stats": {"total": 443, "additions": 229, "deletions": 214}, "files": [{"sha": "8914591c10679ca87697868f11368cd79b6d61e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/854a97f0329ab003d85a572a25421f751de06477/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/854a97f0329ab003d85a572a25421f751de06477/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=854a97f0329ab003d85a572a25421f751de06477", "patch": "@@ -1,3 +1,7 @@\n+2000-08-03  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* toplev.c: Fix formatting.\n+\n Thu Aug  3 01:05:32 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* flow.c (find_auto_inc): Verify that we've got a REG before"}, {"sha": "6a64f7a8a84931597a057118dea46aefc00026bf", "filename": "gcc/toplev.c", "status": "modified", "additions": 225, "deletions": 214, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/854a97f0329ab003d85a572a25421f751de06477/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/854a97f0329ab003d85a572a25421f751de06477/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=854a97f0329ab003d85a572a25421f751de06477", "patch": "@@ -91,10 +91,11 @@ Boston, MA 02111-1307, USA.  */\n \f\n #ifdef VMS\n /* The extra parameters substantially improve the I/O performance.  */\n+\n static FILE *\n vms_fopen (fname, type)\n-     char * fname;\n-     char * type;\n+     char *fname;\n+     char *type;\n {\n   /* The <stdio.h> in the gcc-vms-1.42 distribution prototypes fopen with two\n      fixed arguments, which matches ANSI's specification but not VAXCRTL's\n@@ -107,15 +108,16 @@ vms_fopen (fname, type)\n   else\n     return (*vmslib_fopen) (fname, type, \"mbc=32\");\n }\n+\n #define fopen vms_fopen\n-#endif\t/* VMS */\n+#endif\t/* VMS  */\n \n #ifndef DEFAULT_GDB_EXTENSIONS\n #define DEFAULT_GDB_EXTENSIONS 1\n #endif\n \n /* If more than one debugging type is supported, you must define\n-   PREFERRED_DEBUGGING_TYPE to choose a format in a system-dependent way. \n+   PREFERRED_DEBUGGING_TYPE to choose a format in a system-dependent way.\n \n    This is one long line cause VAXC can't handle a \\-newline.  */\n #if 1 < (defined (DBX_DEBUGGING_INFO) + defined (SDB_DEBUGGING_INFO) + defined (DWARF_DEBUGGING_INFO) + defined (DWARF2_DEBUGGING_INFO) + defined (XCOFF_DEBUGGING_INFO))\n@@ -235,7 +237,7 @@ extern int target_flags;\n struct dump_file_info\n {\n   /* The unique extension to apply, e.g. \".jump\".  */\n-  const char * const extension;\n+  const char *const extension;\n \n   /* The -d<c> character that enables this dump file.  */\n   char const debug_switch;\n@@ -296,7 +298,7 @@ enum dump_file_index\n \t\"       H  K   OPQ  TUVW YZ\"\n */\n \n-struct dump_file_info dump_file[DFI_MAX] = \n+struct dump_file_info dump_file[DFI_MAX] =\n {\n   { \"rtl\",\t'r', 0, 0, 0 },\n   { \"sibling\",  'i', 0, 0, 0 },\n@@ -340,7 +342,7 @@ int rtl_dump_and_exit;\n int flag_print_asm_name;\n static int flag_print_mem;\n static int version_flag;\n-static char * filename;\n+static char *filename;\n enum graph_dump_types graph_dump_format;\n \n /* Name for output file of assembly code, specified with -o.  */\n@@ -441,11 +443,11 @@ int flag_test_coverage = 0;\n \n int flag_branch_probabilities = 0;\n \n-/* Nonzero if basic blocks should be reordered. */\n+/* Nonzero if basic blocks should be reordered.  */\n \n int flag_reorder_blocks = 0;\n \n-/* Nonzero if registers should be renamed */\n+/* Nonzero if registers should be renamed.  */\n \n int flag_rename_registers = 0;\n \n@@ -552,12 +554,12 @@ int flag_unroll_loops;\n int flag_unroll_all_loops;\n \n /* Nonzero forces all invariant computations in loops to be moved\n-   outside the loop. */\n+   outside the loop.  */\n \n int flag_move_all_movables = 0;\n \n /* Nonzero forces all general induction variables in loops to be\n-   strength reduced. */\n+   strength reduced.  */\n \n int flag_reduce_all_givs = 0;\n \n@@ -588,7 +590,7 @@ int flag_omit_frame_pointer = 0;\n int flag_function_sections = 0;\n \n /* ... and similar for data.  */\n- \n+\n int flag_data_sections = 0;\n \n /* Nonzero to inhibit use of define_optimization peephole opts.  */\n@@ -699,12 +701,12 @@ int flag_pic;\n \n int flag_exceptions;\n \n-/* Nonzero means use the new model for exception handling. Replaces \n-   -DNEW_EH_MODEL as a compile option. */\n+/* Nonzero means use the new model for exception handling. Replaces\n+   -DNEW_EH_MODEL as a compile option.  */\n \n int flag_new_exceptions = 1;\n \n-/* Nonzero means generate frame unwind info table when supported */\n+/* Nonzero means generate frame unwind info table when supported.  */\n \n int flag_unwind_tables = 0;\n \n@@ -750,11 +752,11 @@ int flag_schedule_speculative_load_dangerous = 0;\n int flag_single_precision_constant;\n \n /* flag_branch_on_count_reg means try to replace add-1,compare,branch tupple\n-   by a cheaper branch on a count register. */\n+   by a cheaper branch on a count register.  */\n int flag_branch_on_count_reg = 1;\n \n /* -finhibit-size-directive inhibits output of .size for ELF.\n-   This is used only for compiling crtstuff.c, \n+   This is used only for compiling crtstuff.c,\n    and it may be extended to other effects\n    needed for crtstuff.c on other systems.  */\n int flag_inhibit_size_directive = 0;\n@@ -792,7 +794,7 @@ int flag_ssa = 0;\n /* Enable dead code elimination. */\n int flag_dce = 0;\n \n-/* Tag all structures with __attribute__(packed) */\n+/* Tag all structures with __attribute__(packed).  */\n int flag_pack_struct = 0;\n \n /* Emit code to check for stack overflow; also may cause large objects\n@@ -841,7 +843,7 @@ int flag_instrument_function_entry_exit = 0;\n \n int flag_no_ident = 0;\n \n-/* This will perform a peephole pass before sched2. */\n+/* This will perform a peephole pass before sched2.  */\n int flag_peephole2 = 0;\n \n /* -fbounded-pointers causes gcc to compile pointers as composite\n@@ -864,8 +866,8 @@ int flag_bounds_check = 0;\n    one, unconditionally renumber instruction UIDs.  */\n int flag_renumber_insns = 1;\n \n-/* Values of the -falign-* flags: how much to align labels in code. \n-   0 means `use default', 1 means `don't align'.  \n+/* Values of the -falign-* flags: how much to align labels in code.\n+   0 means `use default', 1 means `don't align'.\n    For each variable, there is an _log variant which is the power\n    of two not less than the variable, for .align output.  */\n \n@@ -881,12 +883,12 @@ int align_functions_log;\n /* Table of supported debugging formats.  */\n static struct\n {\n-  const char * arg;\n+  const char *arg;\n   /* Since PREFERRED_DEBUGGING_TYPE isn't necessarily a\n      constant expression, we use NO_DEBUG in its place.  */\n   enum debug_info_type debug_type;\n   int use_extensions_p;\n-  const char * description;\n+  const char *description;\n } *da,\n debug_args[] =\n {\n@@ -917,10 +919,10 @@ debug_args[] =\n \n typedef struct\n {\n-  const char * string;\n-  int *  variable;\n-  int    on_value;\n-  const char * description;\n+  const char *string;\n+  int *variable;\n+  int on_value;\n+  const char *description;\n }\n lang_independent_options;\n \n@@ -1082,9 +1084,9 @@ lang_independent_options f_options[] =\n    \"Assume arguments do not alias each other or globals\" },\n   {\"strict-aliasing\", &flag_strict_aliasing, 1,\n    \"Assume strict aliasing rules apply\" },\n-  {\"align-loops\", &align_loops, 0, \n+  {\"align-loops\", &align_loops, 0,\n    \"Align the start of loops\" },\n-  {\"align-jumps\", &align_jumps, 0, \n+  {\"align-jumps\", &align_jumps, 0,\n    \"Align labels which are only reached by jumping\" },\n   {\"align-labels\", &align_labels, 0,\n    \"Align all labels\" },\n@@ -1124,8 +1126,8 @@ lang_independent_options f_options[] =\n \n static struct lang_opt\n {\n-  const char * option;\n-  const char * description;\n+  const char *option;\n+  const char *description;\n }\n documented_lang_options[] =\n {\n@@ -1242,12 +1244,12 @@ documented_lang_options[] =\n   { \"-Wno-undef\", \"\" },\n   { \"-Wwrite-strings\", \"Mark strings as 'const char *'\"},\n   { \"-Wno-write-strings\", \"\" },\n-  \n+\n #define DEFINE_LANG_NAME(NAME) { NULL, NAME },\n-  \n+\n   /* These are for Objective C.  */\n   DEFINE_LANG_NAME (\"Objective C\")\n-  \n+\n   { \"-lang-objc\", \"\" },\n   { \"-gen-decls\", \"Dump decls to a .decl file\" },\n   { \"-fgnu-runtime\", \"Generate code for GNU runtime environment\" },\n@@ -1262,7 +1264,7 @@ documented_lang_options[] =\n     \"Generate C header of platform specific features\" },\n \n #include \"options.h\"\n-  \n+\n };\n \n /* Here is a table, controlled by the tm.h file, listing each -m switch\n@@ -1273,9 +1275,9 @@ documented_lang_options[] =\n \n struct\n {\n-  const char * name;\n-  int    value;\n-  const char * description;\n+  const char *name;\n+  int value;\n+  const char *description;\n }\n target_switches [] = TARGET_SWITCHES;\n \n@@ -1284,14 +1286,14 @@ target_switches [] = TARGET_SWITCHES;\n #ifdef TARGET_OPTIONS\n struct\n {\n-  const char *  prefix;\n-  const char ** variable;\n-  const char *  description;\n+  const char *prefix;\n+  const char **variable;\n+  const char *description;\n }\n target_options [] = TARGET_OPTIONS;\n #endif\n \f\n-/* Options controlling warnings */\n+/* Options controlling warnings.  */\n \n /* Don't print warning messages.  -w.  */\n \n@@ -1321,7 +1323,7 @@ set_Wunused (setting)\n   warn_unused_label = setting;\n   /* Unused function parameter warnings are reported when either ``-W\n      -Wunused'' or ``-Wunused-parameter'' is specified.  Differentiate\n-     -Wunused by setting WARN_UNUSED_PARAMETER to -1 */\n+     -Wunused by setting WARN_UNUSED_PARAMETER to -1.  */\n   if (!setting)\n     warn_unused_parameter = 0;\n   else if (!warn_unused_parameter)\n@@ -1366,7 +1368,7 @@ int id_clash_len;\n /* Nonzero means warn about any objects definitions whose size is larger\n    than N bytes.  Also want about function definitions whose returned\n    values are larger than N bytes. The value N is in `larger_than_size'.  */\n- \n+\n int warn_larger_than;\n HOST_WIDE_INT larger_than_size;\n \n@@ -1404,7 +1406,7 @@ lang_independent_options W_options[] =\n    \"Warn about returning structures, unions or arrays\" },\n   {\"cast-align\", &warn_cast_align, 1,\n    \"Warn about pointer casts which increase alignment\" },\n-  {\"unreachable-code\", &warn_notreached, 1, \n+  {\"unreachable-code\", &warn_notreached, 1,\n    \"Warn about code that will never be executed\" },\n   {\"uninitialized\", &warn_uninitialized, 1,\n    \"Warn about unitialized automatic variables\"},\n@@ -1426,8 +1428,8 @@ FILE *rtl_dump_file = NULL;\n /* Decode the string P as an integral parameter.\n    If the string is indeed an integer return its numeric value else\n    issue an Invalid Option error for the option PNAME and return DEFVAL.\n-   If PNAME is zero just return DEFVAL, do not call error.               */\n-   \n+   If PNAME is zero just return DEFVAL, do not call error.  */\n+\n int\n read_integral_parameter (p, pname, defval)\n      const char *p;\n@@ -1500,7 +1502,7 @@ do_abort ()\n \n void\n botch (s)\n-  const char * s ATTRIBUTE_UNUSED;\n+     const char *s ATTRIBUTE_UNUSED;\n {\n   abort ();\n }\n@@ -1553,7 +1555,8 @@ float_signal (signo)\n   if (float_handled == 0)\n     crash_signal (signo);\n #if defined (USG) || defined (hpux)\n-  signal (SIGFPE, float_signal);  /* re-enable the signal catcher */\n+  /* Re-enable the signal catcher.  */\n+  signal (SIGFPE, float_signal);\n #endif\n   float_handled = 0;\n   signal (SIGFPE, float_signal);\n@@ -1583,7 +1586,7 @@ set_float_handler (handler)\n    pointer FN, and one argument DATA.  DATA is usually a struct which\n    contains the real input and output for function FN.  This function\n    returns 0 (failure) if longjmp was called (i.e. an exception\n-   occured.)  It returns 1 (success) otherwise. */\n+   occured.)  It returns 1 (success) otherwise.  */\n \n int\n do_float_handler (fn, data)\n@@ -1594,7 +1597,8 @@ do_float_handler (fn, data)\n \n   if (setjmp (buf))\n     {\n-      /* We got here via longjmp() caused by an exception in function fn() */\n+      /* We got here via longjmp () caused by an exception in function\n+         fn ().  */\n       set_float_handler (NULL);\n       return 0;\n     }\n@@ -1653,7 +1657,7 @@ See %s for instructions.\", strsignal (signo), GCCBUGURL);\n /* Strip off a legitimate source ending from the input string NAME of\n    length LEN.  Rather than having to know the names used by all of\n    our front ends, we strip off an ending of a period followed by\n-   up to five characters.  (Java uses \".class\".) */\n+   up to five characters.  (Java uses \".class\".)  */\n \n void\n strip_off_ending (name, len)\n@@ -1727,12 +1731,14 @@ output_file_directive (asm_file, input_name)\n \f\n #ifdef ASM_IDENTIFY_LANGUAGE\n /* Routine to build language identifier for object file.  */\n+\n static void\n output_lang_identify (asm_out_file)\n      FILE *asm_out_file;\n {\n   int len = strlen (lang_identify ()) + sizeof (\"__gnu_compiled_\") + 1;\n   char *s = (char *) alloca (len);\n+\n   sprintf (s, \"__gnu_compiled_%s\", lang_identify ());\n   ASM_OUTPUT_LABEL (asm_out_file, s);\n }\n@@ -1755,7 +1761,7 @@ open_dump_file (index, decl)\n   timevar_push (TV_DUMP);\n   if (rtl_dump_file != NULL)\n     fclose (rtl_dump_file);\n-  \n+\n   sprintf (seq, \".%02d.\", index);\n \n   if (! dump_file[index].initialized)\n@@ -1780,7 +1786,7 @@ open_dump_file (index, decl)\n   rtl_dump_file = fopen (dump_name, open_arg);\n   if (rtl_dump_file == NULL)\n     pfatal_with_name (dump_name);\n-       \n+\n   free (dump_name);\n \n   if (decl)\n@@ -1797,7 +1803,7 @@ static void\n close_dump_file (index, func, insns)\n      enum dump_file_index index;\n      void (*func) PARAMS ((FILE *, rtx));\n-     rtx    insns;\n+     rtx insns;\n {\n   if (! rtl_dump_file)\n     return;\n@@ -1818,18 +1824,19 @@ close_dump_file (index, func, insns)\n \n   if (func && insns)\n     func (rtl_dump_file, insns);\n-       \n+\n   fflush (rtl_dump_file);\n   fclose (rtl_dump_file);\n-       \n+\n   rtl_dump_file = NULL;\n   timevar_pop (TV_DUMP);\n }\n \n /* Do any final processing required for the declarations in VEC, of\n    which there are LEN.  We write out inline functions and variables\n    that have been deferred until this point, but which are required.\n-   Returns non-zero if anything was put out.  */ \n+   Returns non-zero if anything was put out.  */\n+\n int\n wrapup_global_declarations (vec, len)\n      tree *vec;\n@@ -1843,10 +1850,10 @@ wrapup_global_declarations (vec, len)\n   for (i = 0; i < len; i++)\n     {\n       decl = vec[i];\n-      \n+\n       /* We're not deferring this any longer.  */\n       DECL_DEFER_OUTPUT (decl) = 0;\n-      \n+\n       if (TREE_CODE (decl) == VAR_DECL && DECL_SIZE (decl) == 0\n \t  && incomplete_decl_finalize_hook != 0)\n \t(*incomplete_decl_finalize_hook) (decl);\n@@ -1924,6 +1931,7 @@ wrapup_global_declarations (vec, len)\n \n /* Issue appropriate warnings for the global declarations in VEC (of\n    which there are LEN).  Output debugging information for them.  */\n+\n void\n check_global_declarations (vec, len)\n      tree *vec;\n@@ -2006,7 +2014,7 @@ check_global_declarations (vec, len)\n \t  && DECL_RTL (decl) != 0\n \t  && GET_CODE (DECL_RTL (decl)) == MEM)\n \tsdbout_toplevel_data (decl);\n-#endif /* SDB_DEBUGGING_INFO */\n+#endif /* SDB_DEBUGGING_INFO  */\n #ifdef DWARF_DEBUGGING_INFO\n       /* Output DWARF information for file-scope tentative data object\n \t declarations, file-scope (extern) function declarations (which\n@@ -2065,7 +2073,7 @@ void\n pop_srcloc ()\n {\n   struct file_stack *fs;\n-  \n+\n   fs = input_file_stack;\n   input_file_stack = fs->next;\n   free (fs);\n@@ -2095,7 +2103,7 @@ compile_file (name)\n \n   init_timevar ();\n   timevar_start (TV_TOTAL);\n-  \n+\n   /* Initialize data in various passes.  */\n \n   init_obstacks ();\n@@ -2220,7 +2228,7 @@ compile_file (name)\n #ifdef ASM_IDENTIFY_LANGUAGE\n       ASM_IDENTIFY_LANGUAGE (asm_out_file);\n #endif\n-    } /* ! flag_syntax_only */\n+    } /* ! flag_syntax_only  */\n \n #ifndef ASM_OUTPUT_SECTION_NAME\n   if (flag_function_sections)\n@@ -2256,7 +2264,7 @@ compile_file (name)\n       Therefore, I took out that change.\n       In future versions we should find another way to solve\n       that dbx problem.  -- rms, 23 May 93.  */\n-      \n+\n   /* Don't let the first function fall at the same address\n      as gcc_compiled., if profiling.  */\n   if (profile_flag || profile_block_flag)\n@@ -2356,7 +2364,7 @@ compile_file (name)\n     output_exception_table ();\n #endif\n     free_exception_table ();\n-    \n+\n     check_global_declarations (vec, len);\n \n     /* Clean up.  */\n@@ -2367,7 +2375,7 @@ compile_file (name)\n \n   weak_finish ();\n \n-  /* Do dbx symbols */\n+  /* Do dbx symbols.  */\n   timevar_push (TV_SYMOUT);\n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n   if (write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n@@ -2393,7 +2401,7 @@ compile_file (name)\n   /* Output some stuff at end of file if nec.  */\n \n   end_final (dump_base_name);\n-   \n+\n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n       timevar_push (TV_DUMP);\n@@ -2404,7 +2412,7 @@ compile_file (name)\n       close_dump_file (DFI_bp, NULL, NULL_RTX);\n       timevar_pop (TV_DUMP);\n     }\n-   \n+\n #ifdef ASM_FILE_END\n   ASM_FILE_END (asm_out_file);\n #endif\n@@ -2666,7 +2674,7 @@ rest_of_compilation (decl)\n \t generating code for this one is not only not necessary but will\n \t confuse some debugging output writers.  */\n       for (parent = DECL_CONTEXT (current_function_decl);\n-\t   parent != NULL_TREE; \n+\t   parent != NULL_TREE;\n \t   parent = get_containing_scope (parent))\n \tif (TREE_CODE (parent) == FUNCTION_DECL\n \t    && DECL_INLINE (parent) && DECL_EXTERNAL (parent))\n@@ -2935,7 +2943,7 @@ rest_of_compilation (decl)\n \t\t\t !JUMP_AFTER_REGSCAN);\n \t  timevar_pop (TV_JUMP);\n \t}\n- \n+\n       /* Run this after jump optmizations remove all the unreachable code\n \t so that unreachable code will not keep values live.  */\n       delete_trivially_dead_insns (insns, max_reg_num ());\n@@ -2977,7 +2985,7 @@ rest_of_compilation (decl)\n       timevar_push (TV_TO_SSA);\n       open_dump_file (DFI_ssa, decl);\n \n-      find_basic_blocks (insns, max_reg_num(), rtl_dump_file);\n+      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n       cleanup_cfg (insns);\n       convert_to_ssa ();\n \n@@ -3030,7 +3038,7 @@ rest_of_compilation (decl)\n       timevar_push (TV_GCSE);\n       open_dump_file (DFI_gcse, decl);\n \n-      find_basic_blocks (insns, max_reg_num(), rtl_dump_file);\n+      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n       cleanup_cfg (insns);\n       tem = gcse_main (insns, rtl_dump_file);\n \n@@ -3042,7 +3050,7 @@ rest_of_compilation (decl)\n \t  jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n \t\t\t !JUMP_AFTER_REGSCAN);\n \t  timevar_pop (TV_JUMP);\n-        }\n+\t}\n \n       close_dump_file (DFI_gcse, print_rtl, insns);\n       timevar_pop (TV_GCSE);\n@@ -3057,11 +3065,11 @@ rest_of_compilation (decl)\n     {\n       timevar_push (TV_LOOP);\n       open_dump_file (DFI_loop, decl);\n-      \n+\n       if (flag_rerun_loop_opt)\n \t{\n \t  /* We only want to perform unrolling once.  */\n-\t       \n+\n \t  loop_optimize (insns, rtl_dump_file, 0);\n \n \t  /* The first call to loop_optimize makes some instructions\n@@ -3074,7 +3082,8 @@ rest_of_compilation (decl)\n \t\t  analysis code depends on this information.  */\n \t  reg_scan (insns, max_reg_num (), 1);\n \t}\n-      loop_optimize (insns, rtl_dump_file, (flag_unroll_loops ? LOOP_UNROLL : 0) | LOOP_BCT);\n+      loop_optimize (insns, rtl_dump_file,\n+\t\t     (flag_unroll_loops ? LOOP_UNROLL : 0) | LOOP_BCT);\n \n       close_dump_file (DFI_loop, print_rtl, insns);\n       timevar_pop (TV_LOOP);\n@@ -3110,7 +3119,7 @@ rest_of_compilation (decl)\n \t  timevar_pop(TV_IFCVT);\n \n \t  timevar_pop (TV_JUMP);\n-\t  \n+\n \t  reg_scan (insns, max_reg_num (), 0);\n \t  tem = cse_main (insns, max_reg_num (), 1, rtl_dump_file);\n \n@@ -3144,7 +3153,6 @@ rest_of_compilation (decl)\n \n   regclass_init ();\n \n-  \n   /* Do control and data flow analysis; wrote some of the results to\n      the dump file.  */\n \n@@ -3155,7 +3163,7 @@ rest_of_compilation (decl)\n   cleanup_cfg (insns);\n \n   close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n- \n+\n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n       timevar_push (TV_BRANCH_PROB);\n@@ -3214,7 +3222,7 @@ rest_of_compilation (decl)\n \n       rebuild_jump_labels_after_combine\n \t= combine_instructions (insns, max_reg_num ());\n-      \n+\n       /* Combining insns may have turned an indirect jump into a\n \t direct jump.  Rebuid the JUMP_LABEL fields of jumping\n \t instructions.  */\n@@ -3334,7 +3342,7 @@ rest_of_compilation (decl)\n   timevar_push (TV_LOCAL_ALLOC);\n   open_dump_file (DFI_lreg, decl);\n \n-  /* Allocate pseudo-regs that are used only within 1 basic block. \n+  /* Allocate pseudo-regs that are used only within 1 basic block.\n \n      RUN_JUMP_AFTER_RELOAD records whether or not we need to rerun the\n      jump optimizer after register allocation and reloading are finished.  */\n@@ -3387,7 +3395,7 @@ rest_of_compilation (decl)\n     {\n       timevar_push (TV_RELOAD_CSE_REGS);\n       reload_cse_regs (insns);\n-      timevar_pop (TV_RELOAD_CSE_REGS); \n+      timevar_pop (TV_RELOAD_CSE_REGS);\n     }\n \n   /* If optimizing, then go ahead and split insns now since we are about\n@@ -3487,7 +3495,7 @@ rest_of_compilation (decl)\n \n       close_dump_file (DFI_rnreg, print_rtl_with_bb, insns);\n       timevar_pop (TV_RENAME_REGISTERS);\n-    }    \n+    }\n \n #ifdef INSN_SCHEDULING\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n@@ -3522,17 +3530,17 @@ rest_of_compilation (decl)\n \n       close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n       timevar_pop (TV_REORDER_BLOCKS);\n-    }    \n+    }\n \n-  /* One more attempt to remove jumps to .+1 left by dead-store elimination. \n+  /* One more attempt to remove jumps to .+1 left by dead-store elimination.\n      Also do cross-jumping this time and delete no-op move insns.  */\n \n   if (optimize > 0)\n     {\n       timevar_push (TV_JUMP);\n       open_dump_file (DFI_jump2, decl);\n \n-      jump_optimize (insns, JUMP_CROSS_JUMP, JUMP_NOOP_MOVES, \n+      jump_optimize (insns, JUMP_CROSS_JUMP, JUMP_NOOP_MOVES,\n \t\t     !JUMP_AFTER_REGSCAN);\n \n       /* CFG no longer kept up to date.  */\n@@ -3572,7 +3580,7 @@ rest_of_compilation (decl)\n     }\n #endif\n \n-  /* Shorten branches. \n+  /* Shorten branches.\n \n      Note this must run before reg-stack because of death note (ab)use\n      in the ia32 backend.  */\n@@ -3625,18 +3633,18 @@ rest_of_compilation (decl)\n     if (! quiet_flag)\n       fflush (asm_out_file);\n \n-\t     /* Release all memory allocated by flow.  */\n+    /* Release all memory allocated by flow.  */\n     free_basic_block_vars (0);\n \n-    /* Release all memory held by regsets now */\n+    /* Release all memory held by regsets now.  */\n     regset_release_memory ();\n   }\n   timevar_pop (TV_FINAL);\n \n   if (ggc_p)\n     ggc_collect ();\n \n-  /* Write DBX symbols if requested */\n+  /* Write DBX symbols if requested.  */\n \n   /* Note that for those inline functions where we don't initially\n      know for certain that we will be generating an out-of-line copy,\n@@ -3684,7 +3692,7 @@ rest_of_compilation (decl)\n   init_insn_lengths ();\n \n   /* Clear out the real_constant_chain before some of the rtx's\n-\t\t it runs through become garbage.  */\n+     it runs through become garbage.  */\n   clear_const_double_mem ();\n \n   /* Cancel the effect of rtl_in_current_obstack.  */\n@@ -3723,11 +3731,11 @@ rest_of_compilation (decl)\n static void\n display_help ()\n {\n-  int    undoc;\n-  unsigned long\t i;\n-  const char * lang;\n-  \n-#ifndef USE_CPPLIB  \n+  int undoc;\n+  unsigned long i;\n+  const char *lang;\n+\n+#ifndef USE_CPPLIB\n   printf (_(\"Usage: %s input [switches]\\n\"), progname);\n   printf (_(\"Switches:\\n\"));\n #endif\n@@ -3740,50 +3748,51 @@ display_help ()\n \n   for (i = NUM_ELEM (f_options); i--;)\n     {\n-      const char * description = f_options[i].description;\n-      \n+      const char *description = f_options[i].description;\n+\n       if (description != NULL && * description != 0)\n \tprintf (\"  -f%-21s %s\\n\",\n \t\tf_options[i].string, description);\n     }\n-  \n+\n   printf (_(\"  -O[number]              Set optimisation level to [number]\\n\"));\n   printf (_(\"  -Os                     Optimise for space rather than speed\\n\"));\n   printf (_(\"  -pedantic               Issue warnings needed by strict compliance to ANSI C\\n\"));\n   printf (_(\"  -pedantic-errors        Like -pedantic except that errors are produced\\n\"));\n   printf (_(\"  -w                      Suppress warnings\\n\"));\n   printf (_(\"  -W                      Enable extra warnings\\n\"));\n-  \n+\n   for (i = NUM_ELEM (W_options); i--;)\n     {\n-      const char * description = W_options[i].description;\n-      \n+      const char *description = W_options[i].description;\n+\n       if (description != NULL && * description != 0)\n \tprintf (\"  -W%-21s %s\\n\",\n \t\tW_options[i].string, description);\n     }\n-  \n+\n   printf (_(\"  -Wunused                Enable unused warnings\\n\"));\n   printf (_(\"  -Wid-clash-<num>        Warn if 2 identifiers have the same first <num> chars\\n\"));\n   printf (_(\"  -Wlarger-than-<number>  Warn if an object is larger than <number> bytes\\n\"));\n   printf (_(\"  -p                      Enable function profiling\\n\"));\n #if defined (BLOCK_PROFILER) || defined (FUNCTION_BLOCK_PROFILER)\n   printf (_(\"  -a                      Enable block profiling \\n\"));\n-#endif  \n+#endif\n #if defined (BLOCK_PROFILER) || defined (FUNCTION_BLOCK_PROFILER) || defined FUNCTION_BLOCK_PROFILER_EXIT\n   printf (_(\"  -ax                     Enable jump profiling \\n\"));\n-#endif  \n+#endif\n   printf (_(\"  -o <file>               Place output into <file> \\n\"));\n   printf (_(\"\\\n   -G <number>             Put global and static data smaller than <number>\\n\\\n                           bytes into a special section (on some targets)\\n\"));\n-  \n+\n   for (i = NUM_ELEM (debug_args); i--;)\n     {\n       if (debug_args[i].description != NULL)\n-\tprintf (\"  -g%-21s %s\\n\", debug_args[i].arg, debug_args[i].description);\n+\tprintf (\"  -g%-21s %s\\n\",\n+\t\tdebug_args[i].arg, debug_args[i].description);\n     }\n-  \n+\n   printf (_(\"  -aux-info <file>        Emit declaration info into <file>.X\\n\"));\n   printf (_(\"  -quiet                  Do not display functions compiled or elapsed time\\n\"));\n   printf (_(\"  -version                Display the compiler's version\\n\"));\n@@ -3796,23 +3805,23 @@ display_help ()\n \n   undoc = 0;\n   lang  = \"language\";\n-  \n+\n   /* Display descriptions of language specific options.\n      If there is no description, note that there is an undocumented option.\n      If the description is empty, do not display anything.  (This allows\n      options to be deliberately undocumented, for whatever reason).\n      If the option string is missing, then this is a marker, indicating\n      that the description string is in fact the name of a language, whose\n      language specific options are to follow.  */\n-  \n+\n   if (NUM_ELEM (documented_lang_options) > 1)\n     {\n       printf (_(\"\\nLanguage specific options:\\n\"));\n \n       for (i = 0; i < NUM_ELEM (documented_lang_options); i++)\n \t{\n-\t  const char * description = documented_lang_options[i].description;\n-\t  const char * option      = documented_lang_options[i].option;\n+\t  const char *description = documented_lang_options[i].description;\n+\t  const char *option      = documented_lang_options[i].option;\n \n \t  if (description == NULL)\n \t    {\n@@ -3821,7 +3830,7 @@ display_help ()\n \t      if (extra_warnings)\n \t\tprintf (_(\"  %-23.23s [undocumented]\\n\"), option);\n \t    }\n-\t  else if (* description == 0)\n+\t  else if (*description == 0)\n \t    continue;\n \t  else if (option == NULL)\n \t    {\n@@ -3830,7 +3839,7 @@ display_help ()\n \t\t  (_(\"\\nThere are undocumented %s specific options as well.\\n\"),\n \t\t\tlang);\n \t      undoc = 0;\n-\t      \n+\n \t      printf (_(\"\\n Options for %s:\\n\"), description);\n \n \t      lang = description;\n@@ -3841,7 +3850,8 @@ display_help ()\n     }\n \n   if (undoc)\n-    printf (_(\"\\nThere are undocumented %s specific options as well.\\n\"), lang);\n+    printf (_(\"\\nThere are undocumented %s specific options as well.\\n\"),\n+\t    lang);\n \n   if (NUM_ELEM (target_switches) > 1\n #ifdef TARGET_OPTIONS\n@@ -3850,41 +3860,41 @@ display_help ()\n       )\n     {\n       int doc = 0;\n-      \n+\n       undoc = 0;\n-  \n+\n       printf (_(\"\\nTarget specific options:\\n\"));\n \n       for (i = NUM_ELEM (target_switches); i--;)\n \t{\n-\t  const char * option      = target_switches[i].name;\n-\t  const char * description = target_switches[i].description;\n+\t  const char *option      = target_switches[i].name;\n+\t  const char *description = target_switches[i].description;\n \n-\t  if (option == NULL || * option == 0)\n+\t  if (option == NULL || *option == 0)\n \t    continue;\n \t  else if (description == NULL)\n \t    {\n \t      undoc = 1;\n-\t      \n+\n \t      if (extra_warnings)\n \t\tprintf (_(\"  -m%-21.21s [undocumented]\\n\"), option);\n \t    }\n \t  else if (* description != 0)\n \t    doc += printf (\"  -m%-21.21s %s\\n\", option, description);\n \t}\n-      \n-#ifdef TARGET_OPTIONS      \n+\n+#ifdef TARGET_OPTIONS\n       for (i = NUM_ELEM (target_options); i--;)\n \t{\n-\t  const char * option      = target_options[i].prefix;\n-\t  const char * description = target_options[i].description;\n+\t  const char *option      = target_options[i].prefix;\n+\t  const char *description = target_options[i].description;\n \n-\t  if (option == NULL || * option == 0)\n+\t  if (option == NULL || *option == 0)\n \t    continue;\n \t  else if (description == NULL)\n \t    {\n \t      undoc = 1;\n-\t      \n+\n \t      if (extra_warnings)\n \t\tprintf (_(\"  -m%-21.21s [undocumented]\\n\"), option);\n \t    }\n@@ -3906,7 +3916,7 @@ display_help ()\n \n static void\n decode_d_option (arg)\n-     const char * arg;\n+     const char *arg;\n {\n   int i, c, matched;\n \n@@ -3960,7 +3970,7 @@ decode_d_option (arg)\n \n static int\n decode_f_option (arg)\n-     const char * arg;\n+     const char *arg;\n {\n   int j;\n   const char *option_value = NULL;\n@@ -3973,7 +3983,7 @@ decode_f_option (arg)\n \t  *f_options[j].variable = f_options[j].on_value;\n \t  return 1;\n \t}\n-    \n+\n       if (arg[0] == 'n' && arg[1] == 'o' && arg[2] == '-'\n \t  && ! strcmp (arg + 3, f_options[j].string))\n \t{\n@@ -4007,7 +4017,7 @@ decode_f_option (arg)\n     align_labels\n       = read_integral_parameter (option_value, arg - 2, align_labels);\n   else if ((option_value\n-            = skip_leading_substring (arg, \"stack-limit-register=\")))\n+\t    = skip_leading_substring (arg, \"stack-limit-register=\")))\n     {\n       int reg = decode_reg_name (option_value);\n       if (reg < 0)\n@@ -4016,7 +4026,7 @@ decode_f_option (arg)\n \tstack_limit_rtx = gen_rtx_REG (Pmode, reg);\n     }\n   else if ((option_value\n-            = skip_leading_substring (arg, \"stack-limit-symbol=\")))\n+\t    = skip_leading_substring (arg, \"stack-limit-symbol=\")))\n     {\n       char *nm;\n       if (ggc_p)\n@@ -4027,18 +4037,18 @@ decode_f_option (arg)\n     }\n   else if ((option_value\n             = skip_leading_substring (arg, \"message-length=\")))\n-    diagnostic_message_length_per_line = \n+    diagnostic_message_length_per_line =\n       read_integral_parameter (option_value, arg - 2,\n-                               diagnostic_message_length_per_line);\n+\t\t\t       diagnostic_message_length_per_line);\n   else if ((option_value\n-            = skip_leading_substring (arg, \"diagnostics-show-location=\")))\n+\t    = skip_leading_substring (arg, \"diagnostics-show-location=\")))\n     {\n       if (!strcmp (option_value, \"once\"))\n-        set_message_prefixing_rule (DIAGNOSTICS_SHOW_PREFIX_ONCE);\n+\tset_message_prefixing_rule (DIAGNOSTICS_SHOW_PREFIX_ONCE);\n       else if (!strcmp (option_value, \"every-line\"))\n-        set_message_prefixing_rule (DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE);\n+\tset_message_prefixing_rule (DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE);\n       else\n-        error (\"Unrecognized option `%s'\", arg - 2);\n+\terror (\"Unrecognized option `%s'\", arg - 2);\n     }\n   else if (!strcmp (arg, \"no-stack-limit\"))\n     stack_limit_rtx = NULL_RTX;\n@@ -4058,11 +4068,11 @@ decode_f_option (arg)\n \n static int\n decode_W_option (arg)\n-     const char * arg;\n+     const char *arg;\n {\n   const char *option_value = NULL;\n   int j;\n-  \n+\n   /* Search for the option in the table of binary W options.  */\n \n   for (j = sizeof (W_options) / sizeof (W_options[0]); j--;)\n@@ -4084,7 +4094,7 @@ decode_W_option (arg)\n   if ((option_value = skip_leading_substring (arg, \"id-clash-\")))\n     {\n       id_clash_len = read_integral_parameter (option_value, arg - 2, -1);\n-      \n+\n       if (id_clash_len != -1)\n \twarn_id_clash = 1;\n     }\n@@ -4115,7 +4125,7 @@ decode_W_option (arg)\n \n static int\n decode_g_option (arg)\n-     const char * arg;\n+     const char *arg;\n {\n   unsigned level;\n   /* A lot of code assumes write_symbols == NO_DEBUG if the\n@@ -4129,14 +4139,14 @@ decode_g_option (arg)\n      -gdwarf -g3 is equivalent to -gdwarf3.  */\n   static int type_explicitly_set_p = 0;\n   /* Indexed by enum debug_info_type.  */\n-  static const char * debug_type_names[] =\n+  static const char *debug_type_names[] =\n   {\n     \"none\", \"stabs\", \"coff\", \"dwarf-1\", \"dwarf-2\", \"xcoff\"\n   };\n-  \n+\n   /* The maximum admissible debug level value.  */\n   static const unsigned max_debug_level = 3;\n-  \n+\n   /* Look up ARG in the table.  */\n   for (da = debug_args; da->arg; da++)\n     {\n@@ -4145,32 +4155,32 @@ decode_g_option (arg)\n       if (da_len == 0 || ! strncmp (arg, da->arg, da_len))\n \t{\n \t  enum debug_info_type type = da->debug_type;\n-\t  const char * p = arg + da_len;\n-\t  \n+\t  const char *p = arg + da_len;\n+\n \t  if (*p && (*p < '0' || *p > '9'))\n \t    continue;\n-\t  \n+\n \t  /* A debug flag without a level defaults to level 2.\n \t     Note we do not want to call read_integral_parameter\n-\t     for that case since it will call atoi which \n+\t     for that case since it will call atoi which\n \t     will return zero.\n-\t     \n-\t     ??? We may want to generalize the interface to \n+\n+\t     ??? We may want to generalize the interface to\n \t     read_integral_parameter to better handle this case\n \t     if this case shows up often.  */\n \t  if (*p)\n \t    level = read_integral_parameter (p, 0, max_debug_level + 1);\n \t  else\n \t    level = 2;\n-\t  \n+\n \t  if (da_len > 1 && *p && !strncmp (arg, \"dwarf\", da_len))\n \t    {\n \t      error (\"use -gdwarf -g%d for DWARF v1, level %d\",\n \t\t     level, level);\n \t      if (level == 2)\n \t\terror (\"use -gdwarf-2   for DWARF v2\");\n \t    }\n-\t  \n+\n \t  if (level > max_debug_level)\n \t    {\n \t      warning (\"\\\n@@ -4182,7 +4192,7 @@ ignoring option `%s' due to invalid debug level specification\",\n \t  if (type == NO_DEBUG)\n \t    {\n \t      type = PREFERRED_DEBUGGING_TYPE;\n-\t      \n+\n \t      if (da_len > 1 && strncmp (arg, \"gdb\", da_len) == 0)\n \t\t{\n #if defined (DWARF2_DEBUGGING_INFO) && !defined (LINKER_DOES_NOT_WORK_WITH_DWARF2)\n@@ -4194,13 +4204,13 @@ ignoring option `%s' due to invalid debug level specification\",\n #endif\n \t\t}\n \t    }\n-\t  \n+\n \t  if (type == NO_DEBUG)\n \t    warning (\"`%s': unknown or unsupported -g option\", arg - 2);\n \n \t  /* Does it conflict with an already selected type?  */\n \t  if (type_explicitly_set_p\n-\t      /* -g/-ggdb don't conflict with anything */\n+\t      /* -g/-ggdb don't conflict with anything.  */\n \t      && da->debug_type != NO_DEBUG\n \t      && type != selected_debug_type)\n \t    warning (\"`%s' ignored, conflicts with `-g%s'\",\n@@ -4210,24 +4220,25 @@ ignoring option `%s' due to invalid debug level specification\",\n \t      /* If the format has already been set, -g/-ggdb\n \t\t only change the debug level.  */\n \t      if (type_explicitly_set_p && da->debug_type == NO_DEBUG)\n-\t\t; /* don't change debugging type */\n+\t\t/* Don't change debugging type.  */\n+\t\t;\n \t      else\n \t\t{\n \t\t  selected_debug_type = type;\n \t\t  type_explicitly_set_p = da->debug_type != NO_DEBUG;\n \t\t}\n-\t      \n+\n \t      write_symbols = (level == 0\n \t\t\t       ? NO_DEBUG\n \t\t\t       : selected_debug_type);\n \t      use_gnu_debug_info_extensions = da->use_extensions_p;\n \t      debug_info_level = (enum debug_info_level) level;\n \t    }\n-\t  \n+\n \t  break;\n \t}\n     }\n-  \n+\n   if (! da->arg)\n     warning (\"`%s': unknown or unsupported -g option\", arg - 2);\n \n@@ -4238,52 +4249,52 @@ ignoring option `%s' due to invalid debug level specification\",\n    Return the number of strings consumed.  'strings_processed' is the\n    number of strings that have already been decoded in a language\n    specific fashion before this function was invoked.  */\n-   \n+\n static unsigned int\n independent_decode_option (argc, argv, strings_processed)\n      int argc;\n      char **argv;\n      unsigned int strings_processed;\n {\n   char *arg = argv[0];\n-  \n+\n   if (arg[0] != '-' || arg[1] == 0)\n     {\n       if (arg[0] == '+')\n \treturn 0;\n-      \n+\n       filename = arg;\n \n       return 1;\n     }\n \n-  arg ++;\n-  \n+  arg++;\n+\n   if (!strcmp (arg, \"-help\"))\n     {\n       display_help ();\n       exit (0);\n     }\n \n-  if (* arg == 'Y')\n-    arg ++;\n-  \n+  if (*arg == 'Y')\n+    arg++;\n+\n   switch (*arg)\n     {\n     default:\n       return 0;\n-      \n+\n     case 'O':\n       /* Already been treated in main (). Do nothing.  */\n       break;\n-\t  \n+\n     case 'm':\n       set_target_switch (arg + 1);\n       break;\n \n     case 'f':\n       return decode_f_option (arg + 1);\n-\t    \n+\n     case 'g':\n       if (strings_processed == 0)\n \treturn decode_g_option (arg + 1);\n@@ -4295,7 +4306,7 @@ independent_decode_option (argc, argv, strings_processed)\n \t{\n \t  if (argc == 1)\n \t    return 0;\n-\t  \n+\n \t  dump_base_name = argv[1];\n \t  return 2;\n \t}\n@@ -4348,7 +4359,7 @@ independent_decode_option (argc, argv, strings_processed)\n       else\n \treturn decode_W_option (arg + 1);\n       break;\n-\t  \n+\n     case 'a':\n       if (arg[1] == 0)\n \t{\n@@ -4363,7 +4374,7 @@ independent_decode_option (argc, argv, strings_processed)\n #if !defined (FUNCTION_BLOCK_PROFILER_EXIT) || !defined (BLOCK_PROFILER) || !defined (FUNCTION_BLOCK_PROFILER)\n \t  warning (\"`-ax' option (jump profiling) not supported\");\n #else\n-\t  profile_block_flag = (!profile_block_flag \n+\t  profile_block_flag = (!profile_block_flag\n \t\t\t\t|| profile_block_flag == 2) ? 2 : 3;\n #endif\n \t}\n@@ -4374,7 +4385,7 @@ independent_decode_option (argc, argv, strings_processed)\n \t    {\n \t      if (argc == 1)\n \t\treturn 0;\n-\t      \n+\n \t      aux_info_file_name = argv[1];\n \t      return 2;\n \t    }\n@@ -4390,7 +4401,7 @@ independent_decode_option (argc, argv, strings_processed)\n \t{\n \t  if (argc == 1)\n \t    return 0;\n-\t  \n+\n \t  asm_file_name = argv[1];\n \t  return 2;\n \t}\n@@ -4400,12 +4411,12 @@ independent_decode_option (argc, argv, strings_processed)\n       {\n \tint g_switch_val;\n \tint return_val;\n-\t    \n+\n \tif (arg[1] == 0)\n \t  {\n \t    if (argc == 1)\n \t      return 0;\n-\t    \n+\n \t    g_switch_val = read_integral_parameter (argv[1], 0, -1);\n \t    return_val = 2;\n \t  }\n@@ -4414,19 +4425,19 @@ independent_decode_option (argc, argv, strings_processed)\n \t    g_switch_val = read_integral_parameter (arg + 1, 0, -1);\n \t    return_val = 1;\n \t  }\n-\t    \n+\n \tif (g_switch_val == -1)\n \t  return_val = 0;\n \telse\n \t  {\n \t    g_switch_set = TRUE;\n \t    g_switch_value = g_switch_val;\n \t  }\n-\t    \n+\n \treturn return_val;\n       }\n     }\n-  \n+\n   return 1;\n }\n \f\n@@ -4479,7 +4490,7 @@ main (argc, argv)\n #if defined SIGIOT && (!defined SIGABRT || SIGABRT != SIGIOT)\n   signal (SIGIOT, crash_signal);\n #endif\n-  \n+\n   decl_printable_name = decl_name;\n   lang_expand_expr = (lang_expand_expr_t) do_abort;\n \n@@ -4499,7 +4510,7 @@ main (argc, argv)\n   ggc_add_tree_root (&current_function_func_begin_label, 1);\n \n   /* Initialize the diagnostics reporting machinery.  */\n-  initialize_diagnostics();\n+  initialize_diagnostics ();\n \n   /* Perform language-specific options intialization.  */\n   lang_init_options ();\n@@ -4517,16 +4528,16 @@ main (argc, argv)\n \t{\n \t  /* Handle -Os, -O2, -O3, -O69, ...  */\n \t  char *p = &argv[i][2];\n-\t  \n+\n \t  if ((p[0] == 's') && (p[1] == 0))\n \t    {\n \t      optimize_size = 1;\n-\t      \n-\t      /* Optimizing for size forces optimize to be 2. */\n+\n+\t      /* Optimizing for size forces optimize to be 2.  */\n \t      optimize = 2;\n \t    }\n \t  else\n-\t    {\t    \n+\t    {\n \t      const int optimize_val = read_integral_parameter (p, p - 2, -1);\n \t      if (optimize_val != -1)\n \t\t{\n@@ -4590,7 +4601,7 @@ main (argc, argv)\n   set_target_switch (\"\");\n \n   /* Unwind tables are always present in an ABI-conformant IA-64\n-     object file, so the default should be ON. */\n+     object file, so the default should be ON.  */\n #ifdef IA64_UNWIND_INFO\n   flag_unwind_tables = IA64_UNWIND_INFO;\n #endif\n@@ -4626,10 +4637,10 @@ main (argc, argv)\n \t      ? lang_processed : indep_processed);\n       else\n \t{\n-\t  const char * option = NULL;\n-\t  const char * lang = NULL;\n+\t  const char *option = NULL;\n+\t  const char *lang = NULL;\n \t  unsigned int j;\n-\t  \n+\n \t  /* It is possible that the command line switch is not valid for the\n \t     current language, but it is valid for another language.  In order\n \t     to be compatible with previous versions of the compiler (which\n@@ -4640,7 +4651,7 @@ main (argc, argv)\n \t  for (j = 0; j < NUM_ELEM (documented_lang_options); j++)\n \t    {\n \t      option = documented_lang_options[j].option;\n-\t      \n+\n \t      if (option == NULL)\n \t\tlang = documented_lang_options[j].description;\n \t      else if (! strncmp (argv[i], option, strlen (option)))\n@@ -4659,11 +4670,11 @@ main (argc, argv)\n \t    }\n \t  else\n \t    error (\"Unrecognized option `%s'\", argv[i]);\n-\t  \n+\n \t  i++;\n \t}\n     }\n-  \n+\n   /* Reflect any language-specific diagnostic option setting.  */\n   reshape_diagnostic_buffer ();\n \n@@ -4714,14 +4725,14 @@ main (argc, argv)\n   /* Set up the align_*_log variables, defaulting them to 1 if they\n      were still unset.  */\n   if (align_loops <= 0) align_loops = 1;\n-  align_loops_log = floor_log2 (align_loops*2-1);\n+  align_loops_log = floor_log2 (align_loops * 2 - 1);\n   if (align_jumps <= 0) align_jumps = 1;\n-  align_jumps_log = floor_log2 (align_jumps*2-1);\n+  align_jumps_log = floor_log2 (align_jumps * 2 - 1);\n   if (align_labels <= 0) align_labels = 1;\n-  align_labels_log = floor_log2 (align_labels*2-1);\n+  align_labels_log = floor_log2 (align_labels * 2 - 1);\n   if (align_functions <= 0) align_functions = 1;\n-  align_functions_log = floor_log2 (align_functions*2-1);\n-  \n+  align_functions_log = floor_log2 (align_functions * 2 - 1);\n+\n   if (profile_block_flag == 3)\n     {\n       warning (\"`-ax' and `-a' are conflicting options. `-a' ignored.\");\n@@ -4755,7 +4766,7 @@ main (argc, argv)\n   user_label_prefix = USER_LABEL_PREFIX;\n   if (flag_leading_underscore != -1)\n     {\n-      /* If the default prefix is more complicated than \"\" or \"_\", \n+      /* If the default prefix is more complicated than \"\" or \"_\",\n \t issue a warning and ignore this option.  */\n       if (user_label_prefix[0] == 0 ||\n \t  (user_label_prefix[0] == '_' && user_label_prefix[1] == 0))\n@@ -4789,12 +4800,12 @@ main (argc, argv)\n #ifndef __MSDOS__\n #ifdef USG\n       system (\"ps -l 1>&2\");\n-#else /* not USG */\n+#else /* not USG  */\n       system (\"ps v\");\n-#endif /* not USG */\n+#endif /* not USG  */\n #endif\n     }\n-#endif /* ! OS2 && ! VMS && (! _WIN32 || CYGWIN) && ! __INTERIX */\n+#endif /* ! OS2 && ! VMS && (! _WIN32 || CYGWIN) && ! __INTERIX  */\n \n   if (errorcount)\n     return (FATAL_EXIT_CODE);\n@@ -4808,7 +4819,7 @@ main (argc, argv)\n \n static void\n set_target_switch (name)\n-  const char *name;\n+     const char *name;\n {\n   register size_t j;\n   int valid_target_option = 0;\n@@ -4891,7 +4902,7 @@ print_single_switch (file, pos, max, indent, sep, term, type, name)\n   pos += len;\n   return pos;\n }\n-     \n+\n /* Print active target switches to FILE.\n    POS is the current cursor position and MAX is the size of a \"line\".\n    Each line begins with INDENT and ends with TERM.\n@@ -4985,12 +4996,12 @@ debug_start_source_file (filename)\n   if (debug_info_level == DINFO_LEVEL_VERBOSE\n       && write_symbols == DWARF_DEBUG)\n     dwarfout_start_new_source_file (filename);\n-#endif /* DWARF_DEBUGGING_INFO */\n+#endif /* DWARF_DEBUGGING_INFO  */\n #ifdef DWARF2_DEBUGGING_INFO\n   if (debug_info_level == DINFO_LEVEL_VERBOSE\n       && write_symbols == DWARF2_DEBUG)\n     dwarf2out_start_source_file (filename);\n-#endif /* DWARF2_DEBUGGING_INFO */  \n+#endif /* DWARF2_DEBUGGING_INFO  */\n #ifdef SDB_DEBUGGING_INFO\n   if (write_symbols == SDB_DEBUG)\n     sdbout_start_new_source_file (filename);\n@@ -5012,12 +5023,12 @@ debug_end_source_file (lineno)\n   if (debug_info_level == DINFO_LEVEL_VERBOSE\n       && write_symbols == DWARF_DEBUG)\n     dwarfout_resume_previous_source_file (lineno);\n-#endif /* DWARF_DEBUGGING_INFO */\n+#endif /* DWARF_DEBUGGING_INFO  */\n #ifdef DWARF2_DEBUGGING_INFO\n   if (debug_info_level == DINFO_LEVEL_VERBOSE\n       && write_symbols == DWARF2_DEBUG)\n     dwarf2out_end_source_file ();\n-#endif /* DWARF2_DEBUGGING_INFO */\n+#endif /* DWARF2_DEBUGGING_INFO  */\n #ifdef SDB_DEBUGGING_INFO\n   if (write_symbols == SDB_DEBUG)\n     sdbout_resume_previous_source_file ();\n@@ -5037,12 +5048,12 @@ debug_define (lineno, buffer)\n   if (debug_info_level == DINFO_LEVEL_VERBOSE\n       && write_symbols == DWARF_DEBUG)\n     dwarfout_define (lineno, buffer);\n-#endif /* DWARF_DEBUGGING_INFO */\n+#endif /* DWARF_DEBUGGING_INFO  */\n #ifdef DWARF2_DEBUGGING_INFO\n   if (debug_info_level == DINFO_LEVEL_VERBOSE\n       && write_symbols == DWARF2_DEBUG)\n     dwarf2out_define (lineno, buffer);\n-#endif /* DWARF2_DEBUGGING_INFO */\n+#endif /* DWARF2_DEBUGGING_INFO  */\n }\n \n /* Called from check_newline in c-parse.y.  The `buffer' parameter contains\n@@ -5058,12 +5069,12 @@ debug_undef (lineno, buffer)\n   if (debug_info_level == DINFO_LEVEL_VERBOSE\n       && write_symbols == DWARF_DEBUG)\n     dwarfout_undef (lineno, buffer);\n-#endif /* DWARF_DEBUGGING_INFO */\n+#endif /* DWARF_DEBUGGING_INFO  */\n #ifdef DWARF2_DEBUGGING_INFO\n   if (debug_info_level == DINFO_LEVEL_VERBOSE\n       && write_symbols == DWARF2_DEBUG)\n     dwarf2out_undef (lineno, buffer);\n-#endif /* DWARF2_DEBUGGING_INFO */\n+#endif /* DWARF2_DEBUGGING_INFO  */\n }\n \n /* Returns nonzero if it is appropriate not to emit any debugging"}]}