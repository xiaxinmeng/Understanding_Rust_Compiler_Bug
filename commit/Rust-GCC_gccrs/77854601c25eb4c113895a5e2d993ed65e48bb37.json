{"sha": "77854601c25eb4c113895a5e2d993ed65e48bb37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc4NTQ2MDFjMjVlYjRjMTEzODk1YTVlMmQ5OTNlZDY1ZTQ4YmIzNw==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-02-13T14:25:58Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-02-13T14:25:58Z"}, "message": "loop.c (scan_loop): Call reg_in_basic_block_p before loop_reg_used_before_p.\n\n\t* loop.c (scan_loop): Call reg_in_basic_block_p before\n\tloop_reg_used_before_p.\n\nFrom-SVN: r25182", "tree": {"sha": "c51b0dcea97d8e97c98a6e0be8cf36f60fb69e5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c51b0dcea97d8e97c98a6e0be8cf36f60fb69e5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77854601c25eb4c113895a5e2d993ed65e48bb37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77854601c25eb4c113895a5e2d993ed65e48bb37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77854601c25eb4c113895a5e2d993ed65e48bb37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77854601c25eb4c113895a5e2d993ed65e48bb37/comments", "author": null, "committer": null, "parents": [{"sha": "3c602fcbd2c7ea3f137735f5951d6e182092c052", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c602fcbd2c7ea3f137735f5951d6e182092c052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c602fcbd2c7ea3f137735f5951d6e182092c052"}], "stats": {"total": 27, "additions": 19, "deletions": 8}, "files": [{"sha": "b495dfcdff1f346186d570a5b5e4cd7fbba7465a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77854601c25eb4c113895a5e2d993ed65e48bb37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77854601c25eb4c113895a5e2d993ed65e48bb37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77854601c25eb4c113895a5e2d993ed65e48bb37", "patch": "@@ -1,3 +1,8 @@\n+Sun Feb 14 11:24:05 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+ \t* loop.c (scan_loop): Call reg_in_basic_block_p before\n+\tloop_reg_used_before_p.\n+\n Sat Feb 13 05:32:00 1999  Richard Earnshaw (rearnsha@arm.com)\n \n \t* arm.md: Use gen_rtx_FOO instead of gen_rtx (FOO, ...)."}, {"sha": "9e230a63ade843aaefccb646b87069da8e1eb039", "filename": "gcc/loop.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77854601c25eb4c113895a5e2d993ed65e48bb37/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77854601c25eb4c113895a5e2d993ed65e48bb37/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=77854601c25eb4c113895a5e2d993ed65e48bb37", "patch": "@@ -851,17 +851,23 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n \t     We don't know its life-span, so we can't compute the benefit.  */\n \t  if (REGNO (SET_DEST (set)) >= max_reg_before_loop)\n \t    ;\n-\t  else if (/* The set is not guaranteed to be executed one\n-\t\t      the loop starts, or the value before the set is\n-\t\t      needed before the set occurs... */\n-\t\t   (maybe_never\n-\t\t    || loop_reg_used_before_p (set, p, loop_start,\n-\t\t\t\t\t       scan_start, end))\n-\t\t   /* And the register is used in basic blocks other\n+\t  else if (/* The register is used in basic blocks other\n \t\t      than the one where it is set (meaning that\n \t\t      something after this point in the loop might\n \t\t      depend on its value before the set).  */\n-\t\t   && !reg_in_basic_block_p (p, SET_DEST (set)))\n+\t\t   ! reg_in_basic_block_p (p, SET_DEST (set))\n+\t\t   /* And the set is not guaranteed to be executed one\n+\t\t      the loop starts, or the value before the set is\n+\t\t      needed before the set occurs... \n+\n+\t\t      ??? Note we have quadratic behaviour here, mitigated\n+\t\t      by the fact that the previous test will often fail for\n+\t\t      large loops.  Rather than re-scanning the entire loop\n+\t\t      each time for register usage, we should build tables\n+\t\t      of the register usage and use them here instead.  */\n+\t\t   && (maybe_never\n+\t\t       || loop_reg_used_before_p (set, p, loop_start,\n+\t\t\t\t\t\t  scan_start, end)))\n \t    /* It is unsafe to move the set.  \n \n \t       This code used to consider it OK to move a set of a variable"}]}