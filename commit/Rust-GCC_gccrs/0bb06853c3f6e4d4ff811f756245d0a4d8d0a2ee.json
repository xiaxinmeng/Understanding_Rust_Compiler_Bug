{"sha": "0bb06853c3f6e4d4ff811f756245d0a4d8d0a2ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJiMDY4NTNjM2Y2ZTRkNGZmODExZjc1NjI0NWQwYTRkOGQwYTJlZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-09-05T17:48:57Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-09-05T17:48:57Z"}, "message": "* doc/cni.sgml: Updated from master copy.\n\nFrom-SVN: r36162", "tree": {"sha": "ab67ee92e9121fe936f26d043f4f2a32bb421bf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab67ee92e9121fe936f26d043f4f2a32bb421bf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bb06853c3f6e4d4ff811f756245d0a4d8d0a2ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bb06853c3f6e4d4ff811f756245d0a4d8d0a2ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bb06853c3f6e4d4ff811f756245d0a4d8d0a2ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bb06853c3f6e4d4ff811f756245d0a4d8d0a2ee/comments", "author": null, "committer": null, "parents": [{"sha": "4d73d07a81e47e89727f33bcc681e89b0e9d37aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d73d07a81e47e89727f33bcc681e89b0e9d37aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d73d07a81e47e89727f33bcc681e89b0e9d37aa"}], "stats": {"total": 145, "additions": 28, "deletions": 117}, "files": [{"sha": "fec3ae4c6032853eac556b8fda3430190e9d0d27", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bb06853c3f6e4d4ff811f756245d0a4d8d0a2ee/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bb06853c3f6e4d4ff811f756245d0a4d8d0a2ee/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=0bb06853c3f6e4d4ff811f756245d0a4d8d0a2ee", "patch": "@@ -1,3 +1,7 @@\n+2000-09-05  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* doc/cni.sgml: Updated from master copy.\n+\n 2000-09-05  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* gnu/gcj/convert/natIconv.cc (read): Remove unused local."}, {"sha": "0c82ca67ddd3e152f3c7a5040cce871d792de29f", "filename": "libjava/doc/cni.sgml", "status": "modified", "additions": 24, "deletions": 117, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bb06853c3f6e4d4ff811f756245d0a4d8d0a2ee/libjava%2Fdoc%2Fcni.sgml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bb06853c3f6e4d4ff811f756245d0a4d8d0a2ee/libjava%2Fdoc%2Fcni.sgml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fcni.sgml?ref=0bb06853c3f6e4d4ff811f756245d0a4d8d0a2ee", "patch": "@@ -6,7 +6,7 @@\n <authorgroup>\n <corpauthor>Cygnus Solutions</corpauthor>\n </authorgroup>\n-<date>February, 1999</date>\n+<date>March, 2000</date>\n </artheader>\n \n <abstract><para>\n@@ -369,98 +369,6 @@ to private C++ fields and methods, but other fields and methods\n are mapped to public fields and methods.\n </para>\n </sect2>\n-<sect2><title>Non-Java fields</title>\n-<para>\n-When you write a Java wrapper around an existing library, that library\n-will often allocate and manage its own data structures.  These are\n-<quote>objects</quote> that are not Java <literal>Object</literal>s;\n-instead they are usually C <literal>struct</literal> instances.\n-Typically, you will write a Java class, and use native CNI methods\n-which call functions in the C library.  The problem is how to get\n-from the Java wrapper object to the C <literal>struct</literal> instances.\n-The obvious solution is to add a field to the Java object that\n-points to the C structure.  The problem is that there is no Java\n-type that we can give to this field.</para>\n-<para>The GCJ solution is to define a special dummy class\n-<literal>gnu.gcj.RawData</literal>.  This can be used as the type for fields,\n-parameters, array elements, or local variables in Java code.\n-It means that the field or variable is a pointer to a non-Java object.\n-Nothing else is known about it, so it corresponds to a\n-<literal>(void*)</literal> declaration is C or C++ code.</para>\n-<para>\n-The garbage collector will ignore a field that has type\n-<literal>gnu.gcj.RawData</literal>.  You are responsible for\n-freeing the C data structure when you are done with it, and\n-performing any necessary cleanups.  In most cases, you should\n-use a <literal>finalize</literal> method, and have it call\n-the library's cleanup routine.  Also, the C data structure\n-should not contain a pointer back to the Java object, since\n-the garbage collector will not know about the pointer.\n-If you need to save a pointer to a Java object inside some\n-non-Java data structure, you first need to <quote>pin</quote>\n-or <quote>globalize</quote> the pointer;  there is no CNI function\n-to do this yet.\n-(From the point of view of the\n-implementation, a <literal>gnu.gcj.RawData</literal> value is\n-the same as an integer that has the same size as a pointer.)</para>\n-<para>\n-Here is an example where we create a Java wrapper around C stdio:\n-<programlisting>\n-import gnu.gcj.RawData;\n-\n-public class StdioFile\n-{\n-  private RawData file;\n-  public StdioFile (RawData file) { this.file = file; }\n-  public StdioFile (String name, String mode)\n-    throws FileNotFoundException\n-  { init(name, mode); }\n-  private native void init (String name, String mode)\n-    throws FileNotFoundException;\n-  public native int getc();\n-  public native int close();\n-  protected native void finalize();\n-}\n-</programlisting>\n-This is the CNI implementation:\n-<programlisting>\n-jint\n-StdioFile::getc()\n-{\n-  return getc((FILE*) file);\n-}\n-\n-jint\n-StdioFile::close()\n-{\n-  return fclose((FILE*) file);\n-}\n-\n-void\n-StdioFile::init(jstring name, jstring mode)\n-{\n-  int cname_len = JvGetStringUTFLength (name);\n-  int cmode_len = JvGetStringUTFLength (mode);\n-  char cname[cname_len + 1];\n-  char cmode[cmode_len + 1];\n-  JvGetStringUTFRegion (name, 0, name->length(), cname);\n-  JvGetStringUTFRegion (mode, 0, mode->length(), cmode);\n-  cname[cname_len] = '\\0';\n-  cmode[cmode_len] = '\\0';\n-  file = (gnu::gcj::RawData*) fopen(cname, cmode);\n-  if (file == NULL)\n-    JvThrow(new java::lang::FileNotFoundException(name));\n-}\n-\n-void\n-StdioFile::finalize()\n-{\n-  fclose((FILE*) file);\n-}\n-</programlisting>\n-\n-</sect2>\n-\n </sect1>\n \n <sect1><title>Arrays</title>\n@@ -640,7 +548,8 @@ During 1999, G++ will switch to a new ABI that is compatible with\n <acronym>gcj</acronym>.  Some platforms (including Linux) have already\n changed.  On other platforms, you will have to pass\n the <literal>-fvtable-thunks</literal> flag to g++ when\n-compiling <acronym>CNI</acronym> code.\n+compiling <acronym>CNI</acronym> code.  Note that you must also compile\n+your C++ source code with <literal>-fno-rtti</literal>.\n </para>\n <para>\n Calling a Java instance method in <acronym>CNI</acronym> is done\n@@ -850,33 +759,24 @@ initialized before you access a static field.</para>\n <sect1><title>Exception Handling</title>\n <para>\n While C++ and Java share a common exception handling framework,\n-things are not quite as integrated as we would like, yet.\n-The main issue is the incompatible exception <emphasis>values</emphasis>,\n-and that the <quote>run-time type information</quote> facilities of the\n-two languages are not integrated.</para>\n-<para>\n-Basically, this means that you cannot in C++ catch an exception\n-value (<classname>Throwable</classname>) thrown from Java code, nor\n-can you use <literal>throw</literal> on a Java exception value from C++ code,\n-and expect to be able to catch it in Java code.\n-We do intend to change this.</para>\n-<para>\n-You can throw a Java exception from C++ code by using\n-the <literal>JvThrow</literal> <acronym>CNI</acronym> function.\n-<funcsynopsis>\n-   <funcdef>void <function>JvThrow</function></funcdef>\n-   <paramdef>jobject <parameter>obj</parameter></paramdef>\n-</funcsynopsis>\n-  Throws an exception <parameter>obj</parameter>, in a way compatible \n-with the Java exception-handling functions.\n-  The class of <parameter>obj</parameter> must be a subclass of\n-  <literal>Throwable</literal>.\n+things are not yet perfectly integrated.  The main issue is that the\n+<quote>run-time type information</quote> facilities of the two\n+languages are not integrated.</para>\n+<para>\n+Still, things work fairly well.  You can throw a Java exception from\n+C++ using the ordinary <literal>throw</literal> construct, and this\n+exception can be caught by Java code.  Similarly, you can catch an\n+exception thrown from Java using the C++ <literal>catch</literal>\n+construct.\n+<para>\n+Note that currently you cannot mix C++ catches and Java catches in\n+a single C++ translation unit.  We do intend to fix this eventually.\n </para>\n <para>\n Here is an example:\n <programlisting>\n if (i >= count)\n-   JvThrow (new java::lang::IndexOutOfBoundsException());\n+   throw new java::lang::IndexOutOfBoundsException();\n </programlisting>\n </para>\n </sect1>\n@@ -1044,7 +944,14 @@ as the names of classes for which headers should be generated.</para>\n <para>\n gcjh will generate all the required namespace declarations and\n <literal>#include</literal>'s for the header file.\n-In some situations, gcjh will generate simple inline member functions.</para>\n+In some situations, gcjh will generate simple inline member\n+functions.  Note that, while gcjh puts <literal>#pragma\n+interface</literal> in the generated header file, you should\n+<emphasis>not</emphasis> put <literal>#pragma implementation</literal>\n+into your C++ source file.  If you do, duplicate definitions of\n+inline functions will sometimes be created, leading to link-time\n+errors.\n+</para>\n <para>\n There are a few cases where gcjh will fail to work properly:</para>\n <para>"}]}