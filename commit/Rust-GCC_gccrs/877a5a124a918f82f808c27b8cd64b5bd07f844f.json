{"sha": "877a5a124a918f82f808c27b8cd64b5bd07f844f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc3YTVhMTI0YTkxOGY4MmY4MDhjMjdiOGNkNjRiNWJkMDdmODQ0Zg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T10:57:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T10:57:17Z"}, "message": "[multiple changes]\n\n2015-10-26  Claire Dross  <dross@adacore.com>\n\n\t* sem_aux.ads (Number_Components): Can return 0 when called on\n\tan empty record.\n\n2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* contracts.adb (Analyze_Subprogram_Body_Contract): Use\n\tUnique_Defining_Entity instead of Corresponding_Spec_Of.\n\t* einfo.adb SPARK_Pragma and SPARK_Aux_Pragma are now Node40 and\n\tNode41 respectively.\n\t(SPARK_Aux_Pragma): Update the assertion and node querry.\n\t(SPARK_Aux_Pragma_Inherited): Update the assertion and node query.\n\t(SPARK_Pragma): Update the assertion and node query.\n\t(SPARK_Pragma_Inherited): Update the assertion and node query.\n\t(Set_SPARK_Aux_Pragma): Update the assertion and node setting.\n\t(Set_SPARK_Aux_Pragma_Inherited): Update the assertion and node setting.\n\t(Set_SPARK_Pragma): Update the assertion and node setting.\n\t(Set_SPARK_Pragma_Inherited): Update the assertion and node setting.\n\t(Write_Field32_Name): Remove the output for SPARK_Pragma.\n\t(Write_Field33_Name): Remove the output for SPARK_Aux_Pragma.\n\t(Write_Field40_Name): Add output for SPARK_Pragma.\n\t(Write_Field41_Name): Add output for SPARK_Aux_Pragma.\n\t* einfo.ads Rewrite the documentation on attributes\n\tSPARK_Pragma, SPARK_Aux_Pragma, SPARK_Pragma_Inherited and\n\tSPARK_Aux_Pragma_Inherited. Update their uses in nodes.\n\t* exp_ch4.adb (Create_Anonymous_Master): Use\n\tUnique_Defining_Entity instead of Corresponding_Spec_Of.\n\t* exp_ch9.adb (Expand_Entry_Declaration): Mark the barrier\n\tfunction as such.\n\t(Expand_N_Task_Body): Mark the task body as such.\n\t(Expand_N_Task_Type_Declaration): Mark the task body as such.\n\t* exp_unst.adb (Visit_Node): Use Unique_Defining_Entity instead\n\tof Corresponding_Spec_Of.\n\t* sem_attr.adb (Analyze_Attribute_Old_Result): Use\n\tUnique_Defining_Entity instead of Corresponding_Spec_Of.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Entry barrier\n\tfunctions do not inherit the SPARK_Mode from the context.\n\t(Build_Subprogram_Declaration): The matching spec is now marked\n\tas a source construct to mimic the original stand alone body.\n\t* sem_ch7.adb (Analyze_Package_Body_Helper): Code cleanup.\n\t* sem_ch9.adb Add with and use clauses for Contracts.\n\t(Analyze_Entry_Body): An entry body freezes the contract of\n\tthe nearest enclosing package body. The entry body now inherits\n\tthe SPARK_Mode from the context.\n\t(Analyze_Entry_Declaration): A protected entry declaration now inherits\n\tthe SPARK_Mode from the context.\n\t(Analyze_Protected_Body): A protected body freezes\n\tthe contract of the nearest enclosing package body. Set the\n\tEtype of a protected body as this is neede for proper aspect\n\tanalysis. Protected bodies can now carry meaningful aspects and\n\tthose are now analyzed.\n\t(Analyze_Protected_Type_Declaration): A protected type now inherits the\n\tSPARK_Mode from the context.\n\t(Analyze_Task_Body): A task body freezes the contract of the\n\tnearest enclosing package body. Set the Etype of a task body\n\tas this is needed for proper aspect analysis. A task body\n\tnow inherits the SPARK_Mode from the context.  Task bodies\n\tcan now carry meaningful aspects and those are now analyzed.\n\t(Analyze_Task_Type_Declaration): A task type declaration now\n\tinherits the SPARK_Mode of from the context.\n\t* sem_ch10.adb (Analyze_Protected_Body_Stub): Protected body\n\tstubs can now carry meaningful aspects.\n\t(Analyze_Task_Body_Stub): Task body stubs can now carry meaningful\n\taspects.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Aspects SPARK_Mode\n\tWarnings now use routine Insert_Pragma as means of insertion into\n\tthe tree.\n\t(Insert_After_SPARK_Mode): Clean up documentation.\n\t(Insert_Pragma): Clean up documentation. The routine is now\n\tcapable of operating on synchronized units.\n\t* sem_prag.adb (Add_Entity_To_Name_Buffer): New routine.\n\t(Analyze_Contract_Cases_In_Decl_Part): Use\n\tUnique_Defining_Entity instead of Corresponding_Spec_Of.\n\t(Analyze_Depends_Global): Use Unique_Defining_Entity instead\n\tof Corresponding_Spec_Of.\n\t(Analyze_Depends_In_Decl_Part): Use Unique_Defining_Entity instead of\n\tCorresponding_Spec_Of.\n\t(Analyze_Global_In_Decl_Part): Use Unique_Defining_Entity instead of\n\tCorresponding_Spec_Of.\n\t(Analyze_Pragma): Use Unique_Defining_Entity instead of\n\tCorresponding_Spec_Of.\n\tUpdate the detection of an illegal pragma Ghost when it applies\n\tto a task or protected unit. Reimplement the handling of\n\tpragma SPARK_Mode.\n\t(Analyze_Pre_Post_Condition_In_Decl_Part): Use Unique_Defining_Entity\n\tinstead of Corresponding_Spec_Of.\n\t(Analyze_Test_Case_In_Decl_Part): Use Unique_Defining_Entity instead of\n\tCorresponding_Spec_Of.\n\t(Check_Library_Level_Entity): Update the comment on usage.\n\tReimplemented to offer a more specialized errror context.\n\t(Check_Pragma_Conformance): Update profile and comment on usage.\n\tHandle error message output on single protected or task units.\n\t(Collect_Subprogram_Inputs_Outputs): Use Unique_Defining_Entity\n\tinstead of Corresponding_Spec_Of.\n\t(Process_Body): New routine.\n\t(Process_Overloadable): New routine.\n\t(Process_Private_Part): New routine.\n\t(Process_Statement_Part): New routine.\n\t(Process_Visible_Part): New routine.\n\t(Set_SPARK_Context): New routine.\n\t(Set_SPARK_Flags): Removed.\n\t* sem_util.adb (Corresponding_Spec_Of): Removed.\n\t(Unique_Entity): Reimplemented to handle many more cases.\n\t* sem_util.ads (Corresponding_Spec_Of): Removed.\n\t(Unique_Defining_Entity): Update the comment on usage.\n\t* sinfo.ads (Is_Entry_Barrier_Function): Update the assertion.\n\t(Is_Task_Body_Procedure): New routine.\n\t(Set_Is_Entry_Barrier_Function): Update the assertion.\n\t(Set_Is_Task_Body_Procedure): New routine.\n\t* sinfo.adb Update the documentation of attribute\n\tIs_Entry_Barrier_Function along with use in nodes. Add new\n\tattribute Is_Task_Body_Procedure along with use in nodes.\n\t(Is_Task_Body_Procedure): New routine along with pragma Inline.\n\t(Set_Is_Task_Body_Procedure): New routine along with pragma Inline.\n\nFrom-SVN: r229328", "tree": {"sha": "0d8feb8c9db7f87829392d60519c795fc82583d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d8feb8c9db7f87829392d60519c795fc82583d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/877a5a124a918f82f808c27b8cd64b5bd07f844f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/877a5a124a918f82f808c27b8cd64b5bd07f844f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/877a5a124a918f82f808c27b8cd64b5bd07f844f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/877a5a124a918f82f808c27b8cd64b5bd07f844f/comments", "author": null, "committer": null, "parents": [{"sha": "078b1a5f6db354c2f8cf73c535542e2d32224e3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078b1a5f6db354c2f8cf73c535542e2d32224e3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/078b1a5f6db354c2f8cf73c535542e2d32224e3a"}], "stats": {"total": 1817, "additions": 1173, "deletions": 644}, "files": [{"sha": "9b619987a8f9e1ebe7de911357b4b6d4c43abcc0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -1,3 +1,119 @@\n+2015-10-26  Claire Dross  <dross@adacore.com>\n+\n+\t* sem_aux.ads (Number_Components): Can return 0 when called on\n+\tan empty record.\n+\n+2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* contracts.adb (Analyze_Subprogram_Body_Contract): Use\n+\tUnique_Defining_Entity instead of Corresponding_Spec_Of.\n+\t* einfo.adb SPARK_Pragma and SPARK_Aux_Pragma are now Node40 and\n+\tNode41 respectively.\n+\t(SPARK_Aux_Pragma): Update the assertion and node querry.\n+\t(SPARK_Aux_Pragma_Inherited): Update the assertion and node query.\n+\t(SPARK_Pragma): Update the assertion and node query.\n+\t(SPARK_Pragma_Inherited): Update the assertion and node query.\n+\t(Set_SPARK_Aux_Pragma): Update the assertion and node setting.\n+\t(Set_SPARK_Aux_Pragma_Inherited): Update the assertion and node setting.\n+\t(Set_SPARK_Pragma): Update the assertion and node setting.\n+\t(Set_SPARK_Pragma_Inherited): Update the assertion and node setting.\n+\t(Write_Field32_Name): Remove the output for SPARK_Pragma.\n+\t(Write_Field33_Name): Remove the output for SPARK_Aux_Pragma.\n+\t(Write_Field40_Name): Add output for SPARK_Pragma.\n+\t(Write_Field41_Name): Add output for SPARK_Aux_Pragma.\n+\t* einfo.ads Rewrite the documentation on attributes\n+\tSPARK_Pragma, SPARK_Aux_Pragma, SPARK_Pragma_Inherited and\n+\tSPARK_Aux_Pragma_Inherited. Update their uses in nodes.\n+\t* exp_ch4.adb (Create_Anonymous_Master): Use\n+\tUnique_Defining_Entity instead of Corresponding_Spec_Of.\n+\t* exp_ch9.adb (Expand_Entry_Declaration): Mark the barrier\n+\tfunction as such.\n+\t(Expand_N_Task_Body): Mark the task body as such.\n+\t(Expand_N_Task_Type_Declaration): Mark the task body as such.\n+\t* exp_unst.adb (Visit_Node): Use Unique_Defining_Entity instead\n+\tof Corresponding_Spec_Of.\n+\t* sem_attr.adb (Analyze_Attribute_Old_Result): Use\n+\tUnique_Defining_Entity instead of Corresponding_Spec_Of.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Entry barrier\n+\tfunctions do not inherit the SPARK_Mode from the context.\n+\t(Build_Subprogram_Declaration): The matching spec is now marked\n+\tas a source construct to mimic the original stand alone body.\n+\t* sem_ch7.adb (Analyze_Package_Body_Helper): Code cleanup.\n+\t* sem_ch9.adb Add with and use clauses for Contracts.\n+\t(Analyze_Entry_Body): An entry body freezes the contract of\n+\tthe nearest enclosing package body. The entry body now inherits\n+\tthe SPARK_Mode from the context.\n+\t(Analyze_Entry_Declaration): A protected entry declaration now inherits\n+\tthe SPARK_Mode from the context.\n+\t(Analyze_Protected_Body): A protected body freezes\n+\tthe contract of the nearest enclosing package body. Set the\n+\tEtype of a protected body as this is neede for proper aspect\n+\tanalysis. Protected bodies can now carry meaningful aspects and\n+\tthose are now analyzed.\n+\t(Analyze_Protected_Type_Declaration): A protected type now inherits the\n+\tSPARK_Mode from the context.\n+\t(Analyze_Task_Body): A task body freezes the contract of the\n+\tnearest enclosing package body. Set the Etype of a task body\n+\tas this is needed for proper aspect analysis. A task body\n+\tnow inherits the SPARK_Mode from the context.  Task bodies\n+\tcan now carry meaningful aspects and those are now analyzed.\n+\t(Analyze_Task_Type_Declaration): A task type declaration now\n+\tinherits the SPARK_Mode of from the context.\n+\t* sem_ch10.adb (Analyze_Protected_Body_Stub): Protected body\n+\tstubs can now carry meaningful aspects.\n+\t(Analyze_Task_Body_Stub): Task body stubs can now carry meaningful\n+\taspects.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Aspects SPARK_Mode\n+\tWarnings now use routine Insert_Pragma as means of insertion into\n+\tthe tree.\n+\t(Insert_After_SPARK_Mode): Clean up documentation.\n+\t(Insert_Pragma): Clean up documentation. The routine is now\n+\tcapable of operating on synchronized units.\n+\t* sem_prag.adb (Add_Entity_To_Name_Buffer): New routine.\n+\t(Analyze_Contract_Cases_In_Decl_Part): Use\n+\tUnique_Defining_Entity instead of Corresponding_Spec_Of.\n+\t(Analyze_Depends_Global): Use Unique_Defining_Entity instead\n+\tof Corresponding_Spec_Of.\n+\t(Analyze_Depends_In_Decl_Part): Use Unique_Defining_Entity instead of\n+\tCorresponding_Spec_Of.\n+\t(Analyze_Global_In_Decl_Part): Use Unique_Defining_Entity instead of\n+\tCorresponding_Spec_Of.\n+\t(Analyze_Pragma): Use Unique_Defining_Entity instead of\n+\tCorresponding_Spec_Of.\n+\tUpdate the detection of an illegal pragma Ghost when it applies\n+\tto a task or protected unit. Reimplement the handling of\n+\tpragma SPARK_Mode.\n+\t(Analyze_Pre_Post_Condition_In_Decl_Part): Use Unique_Defining_Entity\n+\tinstead of Corresponding_Spec_Of.\n+\t(Analyze_Test_Case_In_Decl_Part): Use Unique_Defining_Entity instead of\n+\tCorresponding_Spec_Of.\n+\t(Check_Library_Level_Entity): Update the comment on usage.\n+\tReimplemented to offer a more specialized errror context.\n+\t(Check_Pragma_Conformance): Update profile and comment on usage.\n+\tHandle error message output on single protected or task units.\n+\t(Collect_Subprogram_Inputs_Outputs): Use Unique_Defining_Entity\n+\tinstead of Corresponding_Spec_Of.\n+\t(Process_Body): New routine.\n+\t(Process_Overloadable): New routine.\n+\t(Process_Private_Part): New routine.\n+\t(Process_Statement_Part): New routine.\n+\t(Process_Visible_Part): New routine.\n+\t(Set_SPARK_Context): New routine.\n+\t(Set_SPARK_Flags): Removed.\n+\t* sem_util.adb (Corresponding_Spec_Of): Removed.\n+\t(Unique_Entity): Reimplemented to handle many more cases.\n+\t* sem_util.ads (Corresponding_Spec_Of): Removed.\n+\t(Unique_Defining_Entity): Update the comment on usage.\n+\t* sinfo.ads (Is_Entry_Barrier_Function): Update the assertion.\n+\t(Is_Task_Body_Procedure): New routine.\n+\t(Set_Is_Entry_Barrier_Function): Update the assertion.\n+\t(Set_Is_Task_Body_Procedure): New routine.\n+\t* sinfo.adb Update the documentation of attribute\n+\tIs_Entry_Barrier_Function along with use in nodes. Add new\n+\tattribute Is_Task_Body_Procedure along with use in nodes.\n+\t(Is_Task_Body_Procedure): New routine along with pragma Inline.\n+\t(Set_Is_Task_Body_Procedure): New routine along with pragma Inline.\n+\n 2015-10-26  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_ch13.adb: Minor reformatting."}, {"sha": "fa678bf11e1e60cc27ca4dec3fdf82ecdc40bd51", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -624,7 +624,7 @@ package body Contracts is\n    procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id) is\n       Body_Decl   : constant Node_Id   := Unit_Declaration_Node (Body_Id);\n       Items       : constant Node_Id   := Contract (Body_Id);\n-      Spec_Id     : constant Entity_Id := Corresponding_Spec_Of (Body_Decl);\n+      Spec_Id     : constant Entity_Id := Unique_Defining_Entity (Body_Decl);\n       Mode        : SPARK_Mode_Type;\n       Prag        : Node_Id;\n       Prag_Nam    : Name_Id;"}, {"sha": "08072f2301044158f663173117b8acfba54f03ad", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 88, "deletions": 43, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -255,24 +255,23 @@ package body Einfo is\n    --    Activation_Record_Component     Node31\n \n    --    Encapsulating_State             Node32\n-   --    SPARK_Pragma                    Node32\n    --    No_Tagged_Streams_Pragma        Node32\n \n    --    Linker_Section_Pragma           Node33\n-   --    SPARK_Aux_Pragma                Node33\n \n    --    Contract                        Node34\n \n    --    Import_Pragma                   Node35\n \n    --    Anonymous_Master                Node36\n \n-   --    (Class_Wide_Preconds)           List38\n+   --    Class_Wide_Preconds             List38\n \n-   --    (Class_Wide_Postconds)          List39\n+   --    Class_Wide_Postconds            List39\n \n-   --    (unused)                        Node40\n-   --    (unused)                        Node41\n+   --    SPARK_Pragma                    Node40\n+\n+   --    SPARK_Aux_Pragma                Node41\n \n    ---------------------------------------------\n    -- Usage of Flags in Defining Entity Nodes --\n@@ -3113,46 +3112,66 @@ package body Einfo is\n       pragma Assert\n         (Ekind_In (Id, E_Generic_Package,  --  package variants\n                        E_Package,\n-                       E_Package_Body));\n-      return Node33 (Id);\n+                       E_Package_Body)\n+           or else\n+         Ekind_In (Id, E_Protected_Type,   --  synchronized variants\n+                       E_Task_Type));\n+      return Node41 (Id);\n    end SPARK_Aux_Pragma;\n \n    function SPARK_Aux_Pragma_Inherited (Id : E) return B is\n    begin\n       pragma Assert\n         (Ekind_In (Id, E_Generic_Package,  --  package variants\n                        E_Package,\n-                       E_Package_Body));\n+                       E_Package_Body)\n+           or else\n+         Ekind_In (Id, E_Protected_Type,   --  synchronized variants\n+                       E_Task_Type));\n       return Flag266 (Id);\n    end SPARK_Aux_Pragma_Inherited;\n \n    function SPARK_Pragma (Id : E) return N is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Function,         --  subprogram variants\n+        (Ekind_In (Id, E_Entry,            --  overloadable variants\n+                       E_Entry_Family,\n+                       E_Function,\n                        E_Generic_Function,\n                        E_Generic_Procedure,\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n          Ekind_In (Id, E_Generic_Package,  --  package variants\n                        E_Package,\n-                       E_Package_Body));\n-      return Node32 (Id);\n+                       E_Package_Body)\n+           or else\n+         Ekind_In (Id, E_Protected_Body,   --  synchronized variants\n+                       E_Protected_Type,\n+                       E_Task_Body,\n+                       E_Task_Type));\n+      return Node40 (Id);\n    end SPARK_Pragma;\n \n    function SPARK_Pragma_Inherited (Id : E) return B is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Function,         --  subprogram variants\n+        (Ekind_In (Id, E_Entry,            --  overloadable variants\n+                       E_Entry_Family,\n+                       E_Function,\n                        E_Generic_Function,\n                        E_Generic_Procedure,\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n          Ekind_In (Id, E_Generic_Package,  --  package variants\n                        E_Package,\n-                       E_Package_Body));\n+                       E_Package_Body)\n+           or else\n+         Ekind_In (Id, E_Protected_Body,   --  synchronized variants\n+                       E_Protected_Type,\n+                       E_Task_Body,\n+                       E_Task_Type));\n       return Flag265 (Id);\n    end SPARK_Pragma_Inherited;\n \n@@ -6124,50 +6143,66 @@ package body Einfo is\n       pragma Assert\n         (Ekind_In (Id, E_Generic_Package,  --  package variants\n                        E_Package,\n-                       E_Package_Body));\n-\n-      Set_Node33 (Id, V);\n+                       E_Package_Body)\n+           or else\n+         Ekind_In (Id, E_Protected_Type,   --  synchronized variants\n+                       E_Task_Type));\n+      Set_Node41 (Id, V);\n    end Set_SPARK_Aux_Pragma;\n \n    procedure Set_SPARK_Aux_Pragma_Inherited (Id : E; V : B := True) is\n    begin\n       pragma Assert\n         (Ekind_In (Id, E_Generic_Package,  --  package variants\n                        E_Package,\n-                       E_Package_Body));\n-\n+                       E_Package_Body)\n+           or else\n+         Ekind_In (Id, E_Protected_Type,   --  synchronized variants\n+                       E_Task_Type));\n       Set_Flag266 (Id, V);\n    end Set_SPARK_Aux_Pragma_Inherited;\n \n    procedure Set_SPARK_Pragma (Id : E; V : N) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Function,         --  subprogram variants\n+        (Ekind_In (Id, E_Entry,            --  overloadable variants\n+                       E_Entry_Family,\n+                       E_Function,\n                        E_Generic_Function,\n                        E_Generic_Procedure,\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n          Ekind_In (Id, E_Generic_Package,  --  package variants\n                        E_Package,\n-                       E_Package_Body));\n-\n-      Set_Node32 (Id, V);\n+                       E_Package_Body)\n+           or else\n+         Ekind_In (Id, E_Protected_Body,   --  synchronized variants\n+                       E_Protected_Type,\n+                       E_Task_Body,\n+                       E_Task_Type));\n+      Set_Node40 (Id, V);\n    end Set_SPARK_Pragma;\n \n    procedure Set_SPARK_Pragma_Inherited (Id : E; V : B := True) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Function,         --  subprogram variants\n+        (Ekind_In (Id, E_Entry,            --  overloadable variants\n+                       E_Entry_Family,\n+                       E_Function,\n                        E_Generic_Function,\n                        E_Generic_Procedure,\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n          Ekind_In (Id, E_Generic_Package,  --  package variants\n                        E_Package,\n-                       E_Package_Body));\n-\n+                       E_Package_Body)\n+           or else\n+         Ekind_In (Id, E_Protected_Body,   --  synchronized variants\n+                       E_Protected_Type,\n+                       E_Task_Body,\n+                       E_Task_Type));\n       Set_Flag265 (Id, V);\n    end Set_SPARK_Pragma_Inherited;\n \n@@ -10141,16 +10176,6 @@ package body Einfo is\n               E_Variable                                   =>\n             Write_Str (\"Encapsulating_State\");\n \n-         when E_Function                                   |\n-              E_Generic_Function                           |\n-              E_Generic_Package                            |\n-              E_Generic_Procedure                          |\n-              E_Package                                    |\n-              E_Package_Body                               |\n-              E_Procedure                                  |\n-              E_Subprogram_Body                            =>\n-            Write_Str (\"SPARK_Pragma\");\n-\n          when Type_Kind                                    =>\n             Write_Str (\"No_Tagged_Streams_Pragma\");\n \n@@ -10166,11 +10191,6 @@ package body Einfo is\n    procedure Write_Field33_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Generic_Package                            |\n-              E_Package                                    |\n-              E_Package_Body                               =>\n-            Write_Str (\"SPARK_Aux_Pragma\");\n-\n          when E_Constant                                   |\n               E_Variable                                   |\n               Subprogram_Kind                              |\n@@ -10259,7 +10279,8 @@ package body Einfo is\n    procedure Write_Field38_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Function | E_Procedure                     =>\n+         when E_Function                                   |\n+              E_Procedure                                  =>\n             Write_Str (\"Class-wide preconditions\");\n \n          when others                                       =>\n@@ -10274,7 +10295,8 @@ package body Einfo is\n    procedure Write_Field39_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Function | E_Procedure                     =>\n+         when E_Function                                   |\n+              E_Procedure                                  =>\n             Write_Str (\"Class-wide postcondition\");\n \n          when others                                       =>\n@@ -10289,6 +10311,22 @@ package body Einfo is\n    procedure Write_Field40_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Entry                                      |\n+              E_Entry_Family                               |\n+              E_Function                                   |\n+              E_Generic_Function                           |\n+              E_Generic_Package                            |\n+              E_Generic_Procedure                          |\n+              E_Package                                    |\n+              E_Package_Body                               |\n+              E_Procedure                                  |\n+              E_Protected_Body                             |\n+              E_Protected_Type                             |\n+              E_Subprogram_Body                            |\n+              E_Task_Body                                  |\n+              E_Task_Type                                  =>\n+            Write_Str (\"SPARK_Pragma\");\n+\n          when others                                       =>\n             Write_Str (\"Field40??\");\n       end case;\n@@ -10301,6 +10339,13 @@ package body Einfo is\n    procedure Write_Field41_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Generic_Package                            |\n+              E_Package                                    |\n+              E_Package_Body                               |\n+              E_Protected_Type                             |\n+              E_Task_Type                                  =>\n+            Write_Str (\"SPARK_Aux_Pragma\");\n+\n          when others                                       =>\n             Write_Str (\"Field41??\");\n       end case;"}, {"sha": "ecefb11916a36a8f2cab45c3aa13db8431d03a61", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 50, "deletions": 35, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -4070,35 +4070,36 @@ package Einfo is\n --       Small of the type, either as given in a representation clause, or\n --       as computed (as a power of two) by the compiler.\n \n---    SPARK_Aux_Pragma (Node33)\n---       Present in package spec and body entities. For a package spec entity\n---       it relates to the SPARK mode setting for the private part. This field\n---       points to the N_Pragma node that applies to the private part. This is\n---       either set with a local SPARK_Mode pragma in the private part or it is\n---       inherited from the SPARK mode that applies to the rest of the spec.\n---       For a package body, it similarly applies to the SPARK mode setting for\n---       the elaboration sequence after the BEGIN. In the case where the pragma\n---       is inherited, the SPARK_Aux_Pragma_Inherited flag is set in the\n---       package spec or body entity.\n+--    SPARK_Aux_Pragma (Node41)\n+--       Present in [generic] package specs, package bodies and synchronized\n+--       types. For package specs and synchronized types it refers to the SPARK\n+--       mode setting for the private part. This field points to the N_Pragma\n+--       node that either appears in the private part or is inherited from the\n+--       enclosing context. For package bodies, it refers to the SPARK mode of\n+--       the elaboration sequence after the BEGIN. The fields points to the\n+--       N_Pragma node that either appears in the statement sequence or is\n+--       inherited from the enclosing context. In all cases, if the pragma is\n+--       inherited, then the SPARK_Aux_Pragma_Inherited flag is set.\n \n --    SPARK_Aux_Pragma_Inherited (Flag266)\n---       Present in the entities of subprogram specs and bodies as well as\n---       in package specs and bodies. Set if the SPARK_Aux_Pragma field\n---       points to a pragma that is inherited, rather than a local one.\n-\n---    SPARK_Pragma (Node32)\n---       Present in the entities of subprogram specs and bodies as well as in\n---       package specs and bodies. Points to the N_Pragma node that applies to\n---       the spec or body. This is either set by a local SPARK_Mode pragma or\n---       is inherited from the context (from an outer scope for the spec case\n---       or from the spec for the body case). In the case where it is inherited\n---       the flag SPARK_Pragma_Inherited is set. Empty if no SPARK_Mode pragma\n---       is applicable.\n+--       Present in [generic] package specs, package bodies and synchronized\n+--       types. Set if the SPARK_Aux_Pragma field points to a pragma that is\n+--       inherited, rather than a local one.\n+\n+--    SPARK_Pragma (Node40)\n+--       Present in entries, [generic] package specs, package bodies, [generic]\n+--       subprogram specs, subprogram bodies and synchronized types. Points to\n+--       the N_Pragma node that applies to the spec or body. This is either set\n+--       by a local SPARK_Mode pragma or is inherited from the context (from an\n+--       outer scope for the spec case or from the spec for the body case). In\n+--       the case where it is inherited the flag SPARK_Pragma_Inherited is set.\n+--       Empty if no SPARK_Mode pragma is applicable.\n \n --    SPARK_Pragma_Inherited (Flag265)\n---       Present in the entities of subprogram specs and bodies as well as in\n---       package specs and bodies. Set if the SPARK_Pragma field points to a\n---       pragma that is inherited, rather than a local one.\n+--       Present in entries, [generic] package specs, package bodies, [generic]\n+--       subprogram specs, subprogram bodies and synchronized types. Set if the\n+--       SPARK_Pragma attribute points to a pragma that is inherited, rather\n+--       than a local one.\n \n --    Spec_Entity (Node19)\n --       Defined in package body entities. Points to corresponding package\n@@ -5756,12 +5757,14 @@ package Einfo is\n    --    PPC_Wrapper                         (Node25)\n    --    Extra_Formals                       (Node28)\n    --    Contract                            (Node34)\n+   --    SPARK_Pragma                        (Node40)   (protected kind)\n    --    Needs_No_Actuals                    (Flag22)\n    --    Uses_Sec_Stack                      (Flag95)\n    --    Default_Expressions_Processed       (Flag108)\n    --    Entry_Accepted                      (Flag152)\n    --    Sec_Stack_Needed_For_Return         (Flag167)\n    --    Has_Expanded_Contract               (Flag240)\n+   --    SPARK_Pragma_Inherited              (Flag265)  (protected kind)\n    --    Address_Clause                      (synth)\n    --    Entry_Index_Type                    (synth)\n    --    First_Formal                        (synth)\n@@ -5864,13 +5867,13 @@ package Einfo is\n    --    Subprograms_For_Type                (Node29)\n    --    Corresponding_Equality              (Node30)   (implicit /= only)\n    --    Thunk_Entity                        (Node31)   (thunk case only)\n-   --    SPARK_Pragma                        (Node32)\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)   (non-generic case only)\n    --    Anonymous_Master                    (Node36)   (non-generic case only)\n    --    Class_Wide_Preconds                 (List38)\n    --    Class_Wide_Postconds                (List39)\n+   --    SPARK_Pragma                        (Node40)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    Default_Expressions_Processed       (Flag108)\n@@ -6086,10 +6089,10 @@ package Einfo is\n    --    Package_Instantiation               (Node26)\n    --    Current_Use_Clause                  (Node27)\n    --    Finalizer                           (Node28)   (non-generic case only)\n-   --    SPARK_Pragma                        (Node32)\n-   --    SPARK_Aux_Pragma                    (Node33)\n    --    Contract                            (Node34)\n    --    Anonymous_Master                    (Node36)   (non-generic case only)\n+   --    SPARK_Pragma                        (Node40)\n+   --    SPARK_Aux_Pragma                    (Node41)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Contains_Ignored_Ghost_Code         (Flag279)\n@@ -6123,10 +6126,10 @@ package Einfo is\n    --    Last_Entity                         (Node20)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Finalizer                           (Node28)   (non-generic case only)\n-   --    SPARK_Pragma                        (Node32)\n-   --    SPARK_Aux_Pragma                    (Node33)\n    --    Contract                            (Node34)\n    --    Anonymous_Master                    (Node36)\n+   --    SPARK_Pragma                        (Node40)\n+   --    SPARK_Aux_Pragma                    (Node41)\n    --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    SPARK_Aux_Pragma_Inherited          (Flag266)\n@@ -6174,13 +6177,13 @@ package Einfo is\n    --    Extra_Formals                       (Node28)\n    --    Static_Initialization               (Node30)   (init_proc only)\n    --    Thunk_Entity                        (Node31)   (thunk case only)\n-   --    SPARK_Pragma                        (Node32)\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)   (non-generic case only)\n    --    Anonymous_Master                    (Node36)   (non-generic case only)\n    --    Class_Wide_Preconds                 (List38)\n    --    Class_Wide_Postconds                (List39)\n+   --    SPARK_Pragma                        (Node40)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    Delay_Cleanups                      (Flag114)\n@@ -6233,6 +6236,8 @@ package Einfo is\n    --    Number_Formals                      (synth)\n \n    --  E_Protected_Body\n+   --    SPARK_Pragma                        (Node40)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    (any others??? First/Last Entity, Scope_Depth???)\n \n    --  E_Protected_Object\n@@ -6247,14 +6252,18 @@ package Einfo is\n    --    Last_Entity                         (Node20)\n    --    Discriminant_Constraint             (Elist21)\n    --    Scope_Depth_Value                   (Uint22)\n-   --    Scope_Depth                         (synth)\n    --    Stored_Constraint                   (Elist23)\n-   --    Has_Interrupt_Handler               (synth)\n+   --    SPARK_Pragma                        (Node40)\n+   --    SPARK_Aux_Pragma                    (Node41)\n    --    Sec_Stack_Needed_For_Return         (Flag167)  ???\n+   --    SPARK_Aux_Pragma_Inherited          (Flag266)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Uses_Lock_Free                      (Flag188)\n    --    Uses_Sec_Stack                      (Flag95)   ???\n    --    Has_Entries                         (synth)\n+   --    Has_Interrupt_Handler               (synth)\n    --    Number_Entries                      (synth)\n+   --    Scope_Depth                         (synth)\n \n    --  E_Record_Type\n    --  E_Record_Subtype\n@@ -6351,9 +6360,9 @@ package Einfo is\n    --    Last_Entity                         (Node20)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Extra_Formals                       (Node28)\n-   --    SPARK_Pragma                        (Node32)\n    --    Contract                            (Node34)\n    --    Anonymous_Master                    (Node36)\n+   --    SPARK_Pragma                        (Node40)\n    --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    SPARK_Pragma_Inherited              (Flag265)\n    --    Scope_Depth                         (synth)\n@@ -6369,6 +6378,8 @@ package Einfo is\n    --    (plus type attributes)\n \n    --  E_Task_Body\n+   --    SPARK_Pragma                        (Node40)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    (any others??? First/Last Entity, Scope_Depth???)\n \n    --  E_Task_Type\n@@ -6385,11 +6396,15 @@ package Einfo is\n    --    Task_Body_Procedure                 (Node25)\n    --    Storage_Size_Variable               (Node26)   (base type only)\n    --    Relative_Deadline_Variable          (Node28)   (base type only)\n+   --    SPARK_Pragma                        (Node40)\n+   --    SPARK_Aux_Pragma                    (Node41)\n    --    Delay_Cleanups                      (Flag114)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Storage_Size_Clause             (Flag23)   (base type only)\n-   --    Uses_Sec_Stack                      (Flag95)   ???\n    --    Sec_Stack_Needed_For_Return         (Flag167)  ???\n+   --    SPARK_Aux_Pragma_Inherited          (Flag266)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n+   --    Uses_Sec_Stack                      (Flag95)   ???\n    --    Has_Entries                         (synth)\n    --    Number_Entries                      (synth)\n    --    (plus type attributes)"}, {"sha": "aa3d19f27fa7a7654288a24d9062c6504b18242c", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -463,7 +463,7 @@ package body Exp_Ch4 is\n          --  Local variables\n \n          Loc       : constant Source_Ptr := Sloc (Unit_Id);\n-         Spec_Id   : constant Entity_Id  := Corresponding_Spec_Of (Unit_Decl);\n+         Spec_Id   : constant Entity_Id  := Unique_Defining_Entity (Unit_Decl);\n          Decls     : List_Id;\n          FM_Id     : Entity_Id;\n          Pref      : Character;"}, {"sha": "00b3b60c55a5957f0c7f18e4ed77408888de6be0", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 80, "deletions": 75, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -1019,14 +1019,16 @@ package body Exp_Ch9 is\n       --  (whether coming from this routine, or directly from source).\n \n       if Opt.Suppress_Control_Flow_Optimizations then\n-         Stmt := Make_Implicit_If_Statement (Cond,\n-                   Condition       => Cond,\n-                   Then_Statements => New_List (\n-                     Make_Simple_Return_Statement (Loc,\n-                       New_Occurrence_Of (Standard_True, Loc))),\n-                   Else_Statements => New_List (\n-                     Make_Simple_Return_Statement (Loc,\n-                       New_Occurrence_Of (Standard_False, Loc))));\n+         Stmt :=\n+           Make_Implicit_If_Statement (Cond,\n+             Condition       => Cond,\n+             Then_Statements => New_List (\n+               Make_Simple_Return_Statement (Loc,\n+                 New_Occurrence_Of (Standard_True, Loc))),\n+\n+             Else_Statements => New_List (\n+               Make_Simple_Return_Statement (Loc,\n+                 New_Occurrence_Of (Standard_False, Loc))));\n \n       else\n          Stmt := Make_Simple_Return_Statement (Loc, Cond);\n@@ -1061,22 +1063,24 @@ package body Exp_Ch9 is\n    begin\n       Set_Debug_Info_Needed (Def_Id);\n \n-      return Make_Function_Specification (Loc,\n-        Defining_Unit_Name       => Def_Id,\n-        Parameter_Specifications => New_List (\n-          Make_Parameter_Specification (Loc,\n-            Defining_Identifier =>\n-              Make_Defining_Identifier (Loc, Name_uO),\n-            Parameter_Type      =>\n-              New_Occurrence_Of (RTE (RE_Address), Loc)),\n-\n-          Make_Parameter_Specification (Loc,\n-            Defining_Identifier =>\n-              Make_Defining_Identifier (Loc, Name_uE),\n-            Parameter_Type      =>\n-              New_Occurrence_Of (RTE (RE_Protected_Entry_Index), Loc))),\n-\n-        Result_Definition        => New_Occurrence_Of (Standard_Boolean, Loc));\n+      return\n+        Make_Function_Specification (Loc,\n+          Defining_Unit_Name       => Def_Id,\n+          Parameter_Specifications => New_List (\n+            Make_Parameter_Specification (Loc,\n+              Defining_Identifier =>\n+                Make_Defining_Identifier (Loc, Name_uO),\n+              Parameter_Type      =>\n+                New_Occurrence_Of (RTE (RE_Address), Loc)),\n+\n+            Make_Parameter_Specification (Loc,\n+              Defining_Identifier =>\n+                Make_Defining_Identifier (Loc, Name_uE),\n+              Parameter_Type      =>\n+                New_Occurrence_Of (RTE (RE_Protected_Entry_Index), Loc))),\n+\n+          Result_Definition        =>\n+            New_Occurrence_Of (Standard_Boolean, Loc));\n    end Build_Barrier_Function_Specification;\n \n    --------------------------\n@@ -6260,7 +6264,7 @@ package body Exp_Ch9 is\n       --  version of it because it is never called.\n \n       if Expander_Active then\n-         B_F := Build_Barrier_Function (N, Ent, Prot);\n+         B_F  := Build_Barrier_Function (N, Ent, Prot);\n          Func := Barrier_Function (Ent);\n          Set_Corresponding_Spec (B_F, Func);\n \n@@ -8827,29 +8831,29 @@ package body Exp_Ch9 is\n    --  the specs refer to this type.\n \n    procedure Expand_N_Protected_Type_Declaration (N : Node_Id) is\n-      Loc      : constant Source_Ptr := Sloc (N);\n-      Prot_Typ : constant Entity_Id  := Defining_Identifier (N);\n+      Discr_Map : constant Elist_Id := New_Elmt_List;\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Prot_Typ  : constant Entity_Id  := Defining_Identifier (N);\n \n       Lock_Free_Active : constant Boolean := Uses_Lock_Free (Prot_Typ);\n       --  This flag indicates whether the lock free implementation is active\n \n       Pdef : constant Node_Id := Protected_Definition (N);\n       --  This contains two lists; one for visible and one for private decls\n \n-      Rec_Decl     : Node_Id;\n+      Body_Arr     : Node_Id;\n+      Body_Id      : Entity_Id;\n       Cdecls       : List_Id;\n-      Discr_Map    : constant Elist_Id := New_Elmt_List;\n-      Priv         : Node_Id;\n-      New_Priv     : Node_Id;\n       Comp         : Node_Id;\n       Comp_Id      : Entity_Id;\n-      Sub          : Node_Id;\n       Current_Node : Node_Id := N;\n-      Entries_Aggr : Node_Id;\n-      Body_Id      : Entity_Id;\n-      Body_Arr     : Node_Id;\n       E_Count      : Int;\n+      Entries_Aggr : Node_Id;\n+      New_Priv     : Node_Id;\n       Object_Comp  : Node_Id;\n+      Priv         : Node_Id;\n+      Rec_Decl     : Node_Id;\n+      Sub          : Node_Id;\n \n       procedure Check_Inlining (Subp : Entity_Id);\n       --  If the original operation has a pragma Inline, propagate the flag\n@@ -9020,6 +9024,7 @@ package body Exp_Ch9 is\n            Make_Subprogram_Declaration (Loc,\n              Specification =>\n                Build_Barrier_Function_Specification (Loc, Bdef));\n+         Set_Is_Entry_Barrier_Function (Sub);\n \n          Insert_After (Current_Node, Sub);\n          Analyze (Sub);\n@@ -9146,13 +9151,12 @@ package body Exp_Ch9 is\n                   elsif Restriction_Active (No_Implicit_Heap_Allocations) then\n                      if not Discriminated_Size (Defining_Identifier (Priv))\n                      then\n-\n                         --  Any object of the type will be  non-static.\n \n                         Error_Msg_N (\"component has non-static size??\", Priv);\n                         Error_Msg_NE\n-                          (\"\\creation of protected object of type& will\"\n-                           & \" violate restriction \"\n+                          (\"\\creation of protected object of type& will \"\n+                           & \"violate restriction \"\n                            & \"No_Implicit_Heap_Allocations??\", Priv, Prot_Typ);\n                      else\n \n@@ -9172,24 +9176,22 @@ package body Exp_Ch9 is\n                   then\n                      if not Discriminated_Size (Defining_Identifier (Priv))\n                      then\n-\n                         --  Any object of the type will be  non-static.\n \n                         Error_Msg_N (\"component has non-static size??\", Priv);\n                         Error_Msg_NE\n-                          (\"\\creation of protected object of type& will\"\n-                           & \" violate restriction \"\n+                          (\"\\creation of protected object of type& will \"\n+                           & \"violate restriction \"\n                            & \"No_Implicit_Protected_Object_Allocations??\",\n                            Priv, Prot_Typ);\n                      else\n-\n                         --  Object will be non-static if discriminants are.\n \n                         Error_Msg_NE\n                           (\"creation of protected object of type& with \"\n-                           &  \"non-static discriminants  will violate \"\n-                           & \" restriction\"\n-                           & \" No_Implicit_Protected_Object_Allocations??\",\n+                           & \"non-static discriminants  will violate \"\n+                           & \"restriction \"\n+                           & \"No_Implicit_Protected_Object_Allocations??\",\n                            Priv, Prot_Typ);\n                      end if;\n                   end if;\n@@ -9202,26 +9204,26 @@ package body Exp_Ch9 is\n                declare\n                   Old_Comp : constant Node_Id   := Component_Definition (Priv);\n                   Oent     : constant Entity_Id := Defining_Identifier (Priv);\n-                  New_Comp : Node_Id;\n                   Nent     : constant Entity_Id :=\n                                Make_Defining_Identifier (Sloc (Oent),\n                                  Chars => Chars (Oent));\n+                  New_Comp : Node_Id;\n \n                begin\n                   if Present (Subtype_Indication (Old_Comp)) then\n                      New_Comp :=\n                        Make_Component_Definition (Sloc (Oent),\n                          Aliased_Present    => False,\n                          Subtype_Indication =>\n-                           New_Copy_Tree (Subtype_Indication (Old_Comp),\n-                                           Discr_Map));\n+                           New_Copy_Tree\n+                             (Subtype_Indication (Old_Comp), Discr_Map));\n                   else\n                      New_Comp :=\n                        Make_Component_Definition (Sloc (Oent),\n                          Aliased_Present    => False,\n                          Access_Definition  =>\n-                           New_Copy_Tree (Access_Definition (Old_Comp),\n-                                           Discr_Map));\n+                           New_Copy_Tree\n+                             (Access_Definition (Old_Comp), Discr_Map));\n                   end if;\n \n                   New_Priv :=\n@@ -9289,12 +9291,12 @@ package body Exp_Ch9 is\n \n       if not Lock_Free_Active then\n          declare\n-            Ritem              : Node_Id;\n-            Num_Attach_Handler : Int := 0;\n-            Protection_Subtype : Node_Id;\n             Entry_Count_Expr   : constant Node_Id :=\n                                    Build_Entry_Count_Expression\n                                      (Prot_Typ, Cdecls, Loc);\n+            Num_Attach_Handler : Int := 0;\n+            Protection_Subtype : Node_Id;\n+            Ritem              : Node_Id;\n \n          begin\n             if Has_Attach_Handler (Prot_Typ) then\n@@ -9486,9 +9488,7 @@ package body Exp_Ch9 is\n             end if;\n \n          elsif Nkind (Comp) = N_Entry_Declaration then\n-\n             Expand_Entry_Declaration (Comp);\n-\n          end if;\n \n          Next (Comp);\n@@ -9518,28 +9518,31 @@ package body Exp_Ch9 is\n \n          case Corresponding_Runtime_Package (Prot_Typ) is\n             when System_Tasking_Protected_Objects_Entries =>\n-               Body_Arr := Make_Object_Declaration (Loc,\n-                 Defining_Identifier => Body_Id,\n-                 Aliased_Present => True,\n-                 Object_Definition =>\n-                   Make_Subtype_Indication (Loc,\n-                     Subtype_Mark => New_Occurrence_Of (\n-                       RTE (RE_Protected_Entry_Body_Array), Loc),\n-                     Constraint =>\n-                       Make_Index_Or_Discriminant_Constraint (Loc,\n-                         Constraints => New_List (\n-                            Make_Range (Loc,\n-                              Make_Integer_Literal (Loc, 1),\n-                              Make_Integer_Literal (Loc, E_Count))))),\n-                 Expression => Entries_Aggr);\n+               Body_Arr :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Body_Id,\n+                   Aliased_Present => True,\n+                   Object_Definition =>\n+                     Make_Subtype_Indication (Loc,\n+                       Subtype_Mark =>\n+                         New_Occurrence_Of\n+                           (RTE (RE_Protected_Entry_Body_Array), Loc),\n+                       Constraint =>\n+                         Make_Index_Or_Discriminant_Constraint (Loc,\n+                           Constraints => New_List (\n+                              Make_Range (Loc,\n+                                Make_Integer_Literal (Loc, 1),\n+                                Make_Integer_Literal (Loc, E_Count))))),\n+                   Expression => Entries_Aggr);\n \n             when System_Tasking_Protected_Objects_Single_Entry =>\n-               Body_Arr := Make_Object_Declaration (Loc,\n-                 Defining_Identifier => Body_Id,\n-                 Aliased_Present => True,\n-                 Object_Definition => New_Occurrence_Of\n-                                        (RTE (RE_Entry_Body), Loc),\n-                 Expression => Remove_Head (Expressions (Entries_Aggr)));\n+               Body_Arr :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Body_Id,\n+                   Aliased_Present     => True,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (RTE (RE_Entry_Body), Loc),\n+                   Expression => Remove_Head (Expressions (Entries_Aggr)));\n \n             when others =>\n                raise Program_Error;\n@@ -11512,6 +11515,7 @@ package body Exp_Ch9 is\n           Specification              => Build_Task_Proc_Specification (Ttyp),\n           Declarations               => Declarations (N),\n           Handled_Statement_Sequence => Handled_Statement_Sequence (N));\n+      Set_Is_Task_Body_Procedure (New_N);\n \n       --  If the task contains generic instantiations, cleanup actions are\n       --  delayed until after instantiation. Transfer the activation chain to\n@@ -12052,6 +12056,7 @@ package body Exp_Ch9 is\n       Body_Decl :=\n         Make_Subprogram_Declaration (Loc,\n           Specification => Proc_Spec);\n+      Set_Is_Task_Body_Procedure (Body_Decl);\n \n       Insert_After (Rec_Decl, Body_Decl);\n "}, {"sha": "1bea872aaf791e289c25e5604b96c884f9163482", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -520,7 +520,7 @@ package body Exp_Unst is\n             --  of no corresponding body being available is ignored for now.\n \n             elsif Nkind (N) = N_Subprogram_Body then\n-               Ent := Corresponding_Spec_Of (N);\n+               Ent := Unique_Defining_Entity (N);\n \n                --  Ignore generic subprogram\n "}, {"sha": "009379df8240fa428bbe2469e6f6f5602da3fbc7", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -1351,7 +1351,7 @@ package body Sem_Attr is\n          --  If we get here, then the attribute is legal\n \n          Legal   := True;\n-         Spec_Id := Corresponding_Spec_Of (Subp_Decl);\n+         Spec_Id := Unique_Defining_Entity (Subp_Decl);\n       end Analyze_Attribute_Old_Result;\n \n       ---------------------------------"}, {"sha": "c85a9f366d713cb5205fa7fba0d8e25d61f8779b", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -1380,7 +1380,7 @@ package body Sem_Aux is\n    -- Number_Components --\n    -----------------------\n \n-   function Number_Components (Typ : Entity_Id) return Pos is\n+   function Number_Components (Typ : Entity_Id) return Nat is\n       N    : Int;\n       Comp : Entity_Id;\n "}, {"sha": "ba60284daac2179a856b9b06b51acfe9ef6b85b1", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -377,7 +377,7 @@ package Sem_Aux is\n    --  The result returned is the next _Tag field in this record, or Empty\n    --  if this is the last such field.\n \n-   function Number_Components (Typ : Entity_Id) return Pos;\n+   function Number_Components (Typ : Entity_Id) return Nat;\n    --  Typ is a record type, yields number of components (including\n    --  discriminants) in type.\n "}, {"sha": "2599228b858544cb9b6d77f537e8ca742f068b7a", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -1926,17 +1926,6 @@ package body Sem_Ch10 is\n          Error_Msg_N (\"missing specification for Protected body\", N);\n \n       else\n-         --  Currently there are no language-defined aspects that can apply to\n-         --  a protected body stub. Issue an error and remove the aspects to\n-         --  prevent cascaded errors.\n-\n-         if Has_Aspects (N) then\n-            Error_Msg_N\n-              (\"aspects on protected bodies are not allowed\",\n-               First (Aspect_Specifications (N)));\n-            Remove_Aspects (N);\n-         end if;\n-\n          Set_Scope (Defining_Entity (N), Current_Scope);\n          Set_Has_Completion (Etype (Nam));\n          Set_Corresponding_Spec_Of_Stub (N, Nam);\n@@ -2390,17 +2379,6 @@ package body Sem_Ch10 is\n          Error_Msg_N (\"missing specification for task body\", N);\n \n       else\n-         --  Currently there are no language-defined aspects that can apply to\n-         --  a task body stub. Issue an error and remove the aspects to prevent\n-         --  cascaded errors.\n-\n-         if Has_Aspects (N) then\n-            Error_Msg_N\n-              (\"aspects on task bodies are not allowed\",\n-               First (Aspect_Specifications (N)));\n-            Remove_Aspects (N);\n-         end if;\n-\n          Set_Scope (Defining_Entity (N), Current_Scope);\n          Generate_Reference (Nam, Defining_Identifier (N), 'b');\n          Set_Corresponding_Spec_Of_Stub (N, Nam);\n@@ -2425,7 +2403,7 @@ package body Sem_Ch10 is\n          if Expander_Active then\n             Insert_After (N,\n               Make_Assignment_Statement (Loc,\n-                Name =>\n+                Name        =>\n                   Make_Identifier (Loc,\n                     Chars => New_External_Name (Chars (Etype (Nam)), 'E')),\n                  Expression => New_Occurrence_Of (Standard_True, Loc)));"}, {"sha": "ae02bdd00ea9099e751dba6549a8433d7d937c4c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 139, "deletions": 85, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -1212,15 +1212,28 @@ package body Sem_Ch13 is\n         (Prag    : Node_Id;\n          Ins_Nod : Node_Id;\n          Decls   : List_Id);\n-      --  Subsidiary to the analysis of aspects Abstract_State, Ghost,\n-      --  Initializes, Initial_Condition and Refined_State. Insert node Prag\n-      --  before node Ins_Nod. If Ins_Nod is for pragma SPARK_Mode, then skip\n-      --  SPARK_Mode. Decls is the associated declarative list where Prag is to\n-      --  reside.\n+      --  Subsidiary to the analysis of aspects\n+      --    Abstract_State\n+      --    Ghost\n+      --    Initializes\n+      --    Initial_Condition\n+      --    Refined_State\n+      --  Insert node Prag before node Ins_Nod. If Ins_Nod is for pragma\n+      --  SPARK_Mode, then skip SPARK_Mode. Decls is the associated declarative\n+      --  list where Prag is to reside.\n \n       procedure Insert_Pragma (Prag : Node_Id);\n-      --  Subsidiary to the analysis of aspects Attach_Handler, Contract_Cases,\n-      --  Depends, Global, Post, Pre, Refined_Depends and Refined_Global.\n+      --  Subsidiary to the analysis of aspects\n+      --    Attach_Handler\n+      --    Contract_Cases\n+      --    Depends\n+      --    Global\n+      --    Post\n+      --    Pre\n+      --    Refined_Depends\n+      --    Refined_Global\n+      --    SPARK_Mode\n+      --    Warnings\n       --  Insert pragma Prag such that it mimics the placement of a source\n       --  pragma of the same kind.\n       --\n@@ -1277,46 +1290,123 @@ package body Sem_Ch13 is\n       -------------------\n \n       procedure Insert_Pragma (Prag : Node_Id) is\n-         Aux  : Node_Id;\n-         Decl : Node_Id;\n+         Aux   : Node_Id;\n+         Decl  : Node_Id;\n+         Decls : List_Id;\n \n       begin\n-         if Nkind (N) = N_Subprogram_Body then\n-            if Present (Declarations (N)) then\n-\n-               --  Skip other internally generated pragmas from aspects to find\n-               --  the proper insertion point. As a result the order of pragmas\n-               --  is the same as the order of aspects.\n-\n-               --  As precondition pragmas generated from conjuncts in the\n-               --  precondition aspect are presented in reverse order to\n-               --  Insert_Pragma, insert them in the correct order here by not\n-               --  skipping previously inserted precondition pragmas when the\n-               --  current pragma is a precondition.\n-\n-               Decl := First (Declarations (N));\n-               while Present (Decl) loop\n-                  if Nkind (Decl) = N_Pragma\n-                    and then From_Aspect_Specification (Decl)\n-                    and then not (Get_Pragma_Id (Decl) = Pragma_Precondition\n-                                    and then\n-                                  Get_Pragma_Id (Prag) = Pragma_Precondition)\n-                  then\n-                     Next (Decl);\n-                  else\n-                     exit;\n-                  end if;\n-               end loop;\n+         --  When the aspect appears on a package, protected unit, subprogram\n+         --  or task unit body, insert the generated pragma at the top of the\n+         --  body declarations to emulate the behavior of a source pragma.\n+\n+         --    package body Pack with Aspect is\n \n-               if Present (Decl) then\n-                  Insert_Before (Decl, Prag);\n+         --    package body Pack is\n+         --       pragma Prag;\n+\n+         if Nkind_In (N, N_Package_Body,\n+                         N_Protected_Body,\n+                         N_Subprogram_Body,\n+                         N_Task_Body)\n+         then\n+            Decls := Declarations (N);\n+\n+            if No (Decls) then\n+               Decls := New_List;\n+               Set_Declarations (N, Decls);\n+            end if;\n+\n+            --  Skip other internally generated pragmas from aspects to find\n+            --  the proper insertion point. As a result the order of pragmas\n+            --  is the same as the order of aspects.\n+\n+            --  As precondition pragmas generated from conjuncts in the\n+            --  precondition aspect are presented in reverse order to\n+            --  Insert_Pragma, insert them in the correct order here by not\n+            --  skipping previously inserted precondition pragmas when the\n+            --  current pragma is a precondition.\n+\n+            Decl := First (Decls);\n+            while Present (Decl) loop\n+               if Nkind (Decl) = N_Pragma\n+                 and then From_Aspect_Specification (Decl)\n+                 and then not (Get_Pragma_Id (Decl) = Pragma_Precondition\n+                                 and then\n+                               Get_Pragma_Id (Prag) = Pragma_Precondition)\n+               then\n+                  Next (Decl);\n                else\n-                  Append (Prag, Declarations (N));\n+                  exit;\n                end if;\n+            end loop;\n+\n+            if Present (Decl) then\n+               Insert_Before (Decl, Prag);\n             else\n-               Set_Declarations (N, New_List (Prag));\n+               Append_To (Decls, Prag);\n+            end if;\n+\n+         --  When the aspect is associated with a [generic] package declaration\n+         --  insert the generated pragma at the top of the visible declarations\n+         --  to emulate the behavior of a source pragma.\n+\n+         --    package Pack with Aspect is\n+\n+         --    package Pack is\n+         --       pragma Prag;\n+\n+         elsif Nkind_In (N, N_Generic_Package_Declaration,\n+                            N_Package_Declaration)\n+         then\n+            Decls := Visible_Declarations (Specification (N));\n+\n+            if No (Decls) then\n+               Decls := New_List;\n+               Set_Visible_Declarations (Specification (N), Decls);\n+            end if;\n+\n+            Prepend_To (Decls, Prag);\n+\n+         --  When the aspect is associated with a protected unit declaration,\n+         --  insert the generated pragma at the top of the visible declarations\n+         --  the emulate the behavior of a source pragma.\n+\n+         --    protected [type] Prot with Aspect is\n+\n+         --    protected [type] Prot is\n+         --       pragma Prag;\n+\n+         elsif Nkind (N) = N_Protected_Type_Declaration then\n+            Decls := Visible_Declarations (Protected_Definition (N));\n+\n+            if No (Decls) then\n+               Decls := New_List;\n+               Set_Visible_Declarations (Protected_Definition (N), Decls);\n             end if;\n \n+            Prepend_To (Decls, Prag);\n+\n+         --  When the aspect is associated with a task unit declaration with a\n+         --  definition, insert the generated pragma at the top of the visible\n+         --  declarations the emulate the behavior of a source pragma.\n+\n+         --    task [type] Prot with Aspect is\n+\n+         --    task [type] Prot is\n+         --       pragma Prag;\n+\n+         elsif Nkind (N) = N_Task_Type_Declaration\n+           and then Present (Task_Definition (N))\n+         then\n+            Decls := Visible_Declarations (Task_Definition (N));\n+\n+            if No (Decls) then\n+               Decls := New_List;\n+               Set_Visible_Declarations (Task_Definition (N), Decls);\n+            end if;\n+\n+            Prepend_To (Decls, Prag);\n+\n          --  When the context is a library unit, the pragma is added to the\n          --  Pragmas_After list.\n \n@@ -1329,7 +1419,7 @@ package body Sem_Ch13 is\n \n             Prepend (Prag, Pragmas_After (Aux));\n \n-         --  Default\n+         --  Default, the pragma is inserted after the context\n \n          else\n             Insert_After (N, Prag);\n@@ -2128,11 +2218,9 @@ package body Sem_Ch13 is\n \n                      goto Continue;\n \n-                  --  For tasks\n+                  --  For tasks pass the aspect as an attribute\n \n                   else\n-                     --  Pass the aspect as an attribute\n-\n                      Aitem :=\n                        Make_Attribute_Definition_Clause (Loc,\n                          Name       => Ent,\n@@ -2151,6 +2239,10 @@ package body Sem_Ch13 is\n                          Expression => New_Occurrence_Of (E, Loc))),\n                      Pragma_Name                  => Chars (Id));\n \n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n+                  goto Continue;\n+\n                --  Case 2c: Aspects corresponding to pragmas with three\n                --  arguments.\n \n@@ -2657,54 +2749,16 @@ package body Sem_Ch13 is\n \n                --  SPARK_Mode\n \n-               when Aspect_SPARK_Mode => SPARK_Mode : declare\n-                  Decls : List_Id;\n-\n-               begin\n+               when Aspect_SPARK_Mode =>\n                   Make_Aitem_Pragma\n                     (Pragma_Argument_Associations => New_List (\n                        Make_Pragma_Argument_Association (Loc,\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_SPARK_Mode);\n \n-                  --  When the aspect appears on a package or a subprogram\n-                  --  body, insert the generated pragma at the top of the body\n-                  --  declarations to emulate the behavior of a source pragma.\n-\n-                  if Nkind_In (N, N_Package_Body, N_Subprogram_Body) then\n-                     Decorate (Aspect, Aitem);\n-\n-                     Decls := Declarations (N);\n-\n-                     if No (Decls) then\n-                        Decls := New_List;\n-                        Set_Declarations (N, Decls);\n-                     end if;\n-\n-                     Prepend_To (Decls, Aitem);\n-                     goto Continue;\n-\n-                  --  When the aspect is associated with a [generic] package\n-                  --  declaration, insert the generated pragma at the top of\n-                  --  the visible declarations to emulate the behavior of a\n-                  --  source pragma.\n-\n-                  elsif Nkind_In (N, N_Generic_Package_Declaration,\n-                                     N_Package_Declaration)\n-                  then\n-                     Decorate (Aspect, Aitem);\n-\n-                     Decls := Visible_Declarations (Specification (N));\n-\n-                     if No (Decls) then\n-                        Decls := New_List;\n-                        Set_Visible_Declarations (Specification (N), Decls);\n-                     end if;\n-\n-                     Prepend_To (Decls, Aitem);\n-                     goto Continue;\n-                  end if;\n-               end SPARK_Mode;\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n+                  goto Continue;\n \n                --  Refined_Depends\n "}, {"sha": "56a13defaebb7f5e91b977377b910abbd4973343", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -2364,6 +2364,7 @@ package body Sem_Ch6 is\n          Subp_Decl :=\n            Make_Subprogram_Declaration (Loc,\n              Specification => Copy_Subprogram_Spec (Body_Spec));\n+         Set_Comes_From_Source (Subp_Decl, True);\n \n          --  Relocate the aspects of the subprogram body to the new subprogram\n          --  spec because it acts as the initial declaration.\n@@ -3467,10 +3468,19 @@ package body Sem_Ch6 is\n          Generate_Reference_To_Formals (Body_Id);\n       end if;\n \n-      --  Set SPARK_Mode from context\n+      --  Set the SPARK_Mode from the current context (may be overwritten later\n+      --  with explicit pragma). This is not done for entry barrier functions\n+      --  because they are generated outside the protected type and should not\n+      --  carry the mode of the enclosing context.\n \n-      Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n-      Set_SPARK_Pragma_Inherited (Body_Id);\n+      if Nkind (N) = N_Subprogram_Body\n+        and then Is_Entry_Barrier_Function (N)\n+      then\n+         null;\n+      else\n+         Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma_Inherited (Body_Id);\n+      end if;\n \n       --  If the return type is an anonymous access type whose designated type\n       --  is the limited view of a class-wide type and the non-limited view is\n@@ -4047,11 +4057,19 @@ package body Sem_Ch6 is\n \n       Generate_Definition (Designator);\n \n-      --  Set SPARK mode from current context (may be overwritten later with\n-      --  explicit pragma).\n+      --  Set the SPARK mode from the current context (may be overwritten later\n+      --  with explicit pragma). This is not done for entry barrier functions\n+      --  because they are generated outside the protected type and should not\n+      --  carry the mode of the enclosing context.\n \n-      Set_SPARK_Pragma (Designator, SPARK_Mode_Pragma);\n-      Set_SPARK_Pragma_Inherited (Designator);\n+      if Nkind (N) = N_Subprogram_Declaration\n+        and then Is_Entry_Barrier_Function (N)\n+      then\n+         null;\n+      else\n+         Set_SPARK_Pragma (Designator, SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma_Inherited (Designator);\n+      end if;\n \n       --  A subprogram declared within a Ghost region is automatically Ghost\n       --  (SPARK RM 6.9(2))."}, {"sha": "1ebda333b6c267d7f853f69d30b35a6f36b88c56", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -718,15 +718,9 @@ package body Sem_Ch7 is\n       --  Set SPARK_Mode only for non-generic package\n \n       if Ekind (Spec_Id) = E_Package then\n-\n-         --  Set SPARK_Mode from context\n-\n-         Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n-         Set_SPARK_Pragma_Inherited (Body_Id);\n-\n-         --  Set elaboration code SPARK mode the same for now\n-\n-         Set_SPARK_Aux_Pragma (Body_Id, SPARK_Pragma (Body_Id));\n+         Set_SPARK_Pragma               (Body_Id, SPARK_Mode_Pragma);\n+         Set_SPARK_Aux_Pragma           (Body_Id, SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma_Inherited     (Body_Id);\n          Set_SPARK_Aux_Pragma_Inherited (Body_Id);\n       end if;\n "}, {"sha": "3494eb5676614ea97ff36c752560ca7c02c398ef", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 110, "deletions": 75, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -23,42 +23,43 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Aspects;  use Aspects;\n-with Atree;    use Atree;\n-with Checks;   use Checks;\n-with Debug;    use Debug;\n-with Einfo;    use Einfo;\n-with Errout;   use Errout;\n-with Exp_Ch9;  use Exp_Ch9;\n-with Elists;   use Elists;\n-with Freeze;   use Freeze;\n-with Layout;   use Layout;\n-with Lib.Xref; use Lib.Xref;\n-with Namet;    use Namet;\n-with Nlists;   use Nlists;\n-with Nmake;    use Nmake;\n-with Opt;      use Opt;\n-with Restrict; use Restrict;\n-with Rident;   use Rident;\n-with Rtsfind;  use Rtsfind;\n-with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch5;  use Sem_Ch5;\n-with Sem_Ch6;  use Sem_Ch6;\n-with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch13; use Sem_Ch13;\n-with Sem_Eval; use Sem_Eval;\n-with Sem_Res;  use Sem_Res;\n-with Sem_Type; use Sem_Type;\n-with Sem_Util; use Sem_Util;\n-with Sem_Warn; use Sem_Warn;\n-with Snames;   use Snames;\n-with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n+with Aspects;   use Aspects;\n+with Atree;     use Atree;\n+with Checks;    use Checks;\n+with Contracts; use Contracts;\n+with Debug;     use Debug;\n+with Einfo;     use Einfo;\n+with Errout;    use Errout;\n+with Exp_Ch9;   use Exp_Ch9;\n+with Elists;    use Elists;\n+with Freeze;    use Freeze;\n+with Layout;    use Layout;\n+with Lib.Xref;  use Lib.Xref;\n+with Namet;     use Namet;\n+with Nlists;    use Nlists;\n+with Nmake;     use Nmake;\n+with Opt;       use Opt;\n+with Restrict;  use Restrict;\n+with Rident;    use Rident;\n+with Rtsfind;   use Rtsfind;\n+with Sem;       use Sem;\n+with Sem_Aux;   use Sem_Aux;\n+with Sem_Ch3;   use Sem_Ch3;\n+with Sem_Ch5;   use Sem_Ch5;\n+with Sem_Ch6;   use Sem_Ch6;\n+with Sem_Ch8;   use Sem_Ch8;\n+with Sem_Ch13;  use Sem_Ch13;\n+with Sem_Eval;  use Sem_Eval;\n+with Sem_Res;   use Sem_Res;\n+with Sem_Type;  use Sem_Type;\n+with Sem_Util;  use Sem_Util;\n+with Sem_Warn;  use Sem_Warn;\n+with Snames;    use Snames;\n+with Stand;     use Stand;\n+with Sinfo;     use Sinfo;\n with Style;\n-with Tbuild;   use Tbuild;\n-with Uintp;    use Uintp;\n+with Tbuild;    use Tbuild;\n+with Uintp;     use Uintp;\n \n package body Sem_Ch9 is\n \n@@ -1190,6 +1191,13 @@ package body Sem_Ch9 is\n       Entry_Name : Entity_Id;\n \n    begin\n+      --  An entry body \"freezes\" the contract of the nearest enclosing\n+      --  package body. This ensures that any annotations referenced by the\n+      --  contract of an entry or subprogram body declared within the current\n+      --  protected body are available.\n+\n+      Analyze_Enclosing_Package_Body_Contract (N);\n+\n       Tasking_Used := True;\n \n       --  Entry_Name is initialized to Any_Id. It should get reset to the\n@@ -1209,6 +1217,12 @@ package body Sem_Ch9 is\n       Set_Etype          (Id, Standard_Void_Type);\n       Set_Accept_Address (Id, New_Elmt_List);\n \n+      --  Set the SPARK_Mode from the current context (may be overwritten later\n+      --  with an explicit pragma).\n+\n+      Set_SPARK_Pragma           (Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (Id);\n+\n       E := First_Entity (P_Type);\n       while Present (E) loop\n          if Chars (E) = Chars (Id)\n@@ -1217,7 +1231,7 @@ package body Sem_Ch9 is\n          then\n             Entry_Name := E;\n             Set_Convention (Id, Convention (E));\n-            Set_Corresponding_Body (Parent (Entry_Name), Id);\n+            Set_Corresponding_Body (Parent (E), Id);\n             Check_Fully_Conformant (Id, E, N);\n \n             if Ekind (Id) = E_Entry_Family then\n@@ -1601,6 +1615,15 @@ package body Sem_Ch9 is\n       Set_Convention     (Def_Id, Convention_Entry);\n       Set_Accept_Address (Def_Id, New_Elmt_List);\n \n+      --  Set the SPARK_Mode from the current context (may be overwritten later\n+      --  with an explicit pragma). Task entries are excluded because they are\n+      --  not completed by entry bodies.\n+\n+      if Ekind (Current_Scope) = E_Protected_Type then\n+         Set_SPARK_Pragma           (Def_Id, SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma_Inherited (Def_Id);\n+      end if;\n+\n       --  Process formals\n \n       if Present (Formals) then\n@@ -1730,29 +1753,19 @@ package body Sem_Ch9 is\n    --  Start of processing for Analyze_Protected_Body\n \n    begin\n+      --  A protected body \"freezes\" the contract of the nearest enclosing\n+      --  package body. This ensures that any annotations referenced by the\n+      --  contract of an entry or subprogram body declared within the current\n+      --  protected body are available.\n+\n+      Analyze_Enclosing_Package_Body_Contract (N);\n+\n       Tasking_Used := True;\n       Set_Ekind (Body_Id, E_Protected_Body);\n+      Set_Etype (Body_Id, Standard_Void_Type);\n       Spec_Id := Find_Concurrent_Spec (Body_Id);\n \n-      --  Protected bodies are currently removed by the expander. Since there\n-      --  are no language-defined aspects that apply to a protected body, it is\n-      --  not worth changing the whole expansion to accomodate implementation-\n-      --  defined aspects. Plus we cannot possibly known the semantics of such\n-      --  future implementation-defined aspects in order to plan ahead.\n-\n-      if Has_Aspects (N) then\n-         Error_Msg_N\n-           (\"aspects on protected bodies are not allowed\",\n-            First (Aspect_Specifications (N)));\n-\n-         --  Remove illegal aspects to prevent cascaded errors later on\n-\n-         Remove_Aspects (N);\n-      end if;\n-\n-      if Present (Spec_Id)\n-        and then Ekind (Spec_Id) = E_Protected_Type\n-      then\n+      if Present (Spec_Id) and then Ekind (Spec_Id) = E_Protected_Type then\n          null;\n \n       elsif Present (Spec_Id)\n@@ -1776,6 +1789,10 @@ package body Sem_Ch9 is\n          Spec_Id := Etype (Spec_Id);\n       end if;\n \n+      if Has_Aspects (N) then\n+         Analyze_Aspect_Specifications (N, Body_Id);\n+      end if;\n+\n       Push_Scope (Spec_Id);\n       Set_Corresponding_Spec (N, Spec_Id);\n       Set_Corresponding_Body (Parent (Spec_Id), Body_Id);\n@@ -1967,6 +1984,15 @@ package body Sem_Ch9 is\n       Set_Etype              (T, T);\n       Set_Has_Delayed_Freeze (T, True);\n       Set_Stored_Constraint  (T, No_Elist);\n+\n+      --  Set the SPARK_Mode from the current context (may be overwritten later\n+      --  with an explicit pragma).\n+\n+      Set_SPARK_Pragma               (T, SPARK_Mode_Pragma);\n+      Set_SPARK_Aux_Pragma           (T, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited     (T);\n+      Set_SPARK_Aux_Pragma_Inherited (T);\n+\n       Push_Scope (T);\n \n       if Ada_Version >= Ada_2005 then\n@@ -2719,33 +2745,23 @@ package body Sem_Ch9 is\n       --  a single task, since Spec_Id is set to the task type).\n \n    begin\n+      --  A task body \"freezes\" the contract of the nearest enclosing package\n+      --  body. This ensures that any annotations referenced by the contract\n+      --  of an entry or subprogram body declared within the current protected\n+      --  body are available.\n+\n+      Analyze_Enclosing_Package_Body_Contract (N);\n+\n       Tasking_Used := True;\n-      Set_Ekind (Body_Id, E_Task_Body);\n       Set_Scope (Body_Id, Current_Scope);\n+      Set_Ekind (Body_Id, E_Task_Body);\n+      Set_Etype (Body_Id, Standard_Void_Type);\n       Spec_Id := Find_Concurrent_Spec (Body_Id);\n \n-      --  Task bodies are transformed into a subprogram spec and body pair by\n-      --  the expander. Since there are no language-defined aspects that apply\n-      --  to a task body, it is not worth changing the whole expansion to\n-      --  accomodate implementation-defined aspects. Plus we cannot possibly\n-      --  know semantics of such aspects in order to plan ahead.\n-\n-      if Has_Aspects (N) then\n-         Error_Msg_N\n-           (\"aspects on task bodies are not allowed\",\n-            First (Aspect_Specifications (N)));\n-\n-         --  Remove illegal aspects to prevent cascaded errors later on\n-\n-         Remove_Aspects (N);\n-      end if;\n-\n       --  The spec is either a task type declaration, or a single task\n       --  declaration for which we have created an anonymous type.\n \n-      if Present (Spec_Id)\n-        and then Ekind (Spec_Id) = E_Task_Type\n-      then\n+      if Present (Spec_Id) and then Ekind (Spec_Id) = E_Task_Type then\n          null;\n \n       elsif Present (Spec_Id)\n@@ -2779,6 +2795,16 @@ package body Sem_Ch9 is\n          Spec_Id := Etype (Spec_Id);\n       end if;\n \n+      --  Set the SPARK_Mode from the current context (may be overwritten later\n+      --  with an explicit pragma).\n+\n+      Set_SPARK_Pragma           (Body_Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (Body_Id);\n+\n+      if Has_Aspects (N) then\n+         Analyze_Aspect_Specifications (N, Body_Id);\n+      end if;\n+\n       Push_Scope (Spec_Id);\n       Set_Corresponding_Spec (N, Spec_Id);\n       Set_Corresponding_Body (Parent (Spec_Id), Body_Id);\n@@ -2939,6 +2965,15 @@ package body Sem_Ch9 is\n       Set_Etype              (T, T);\n       Set_Has_Delayed_Freeze (T, True);\n       Set_Stored_Constraint  (T, No_Elist);\n+\n+      --  Set the SPARK_Mode from the current context (may be overwritten later\n+      --  with an explicit pragma).\n+\n+      Set_SPARK_Pragma               (T, SPARK_Mode_Pragma);\n+      Set_SPARK_Aux_Pragma           (T, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited     (T);\n+      Set_SPARK_Aux_Pragma_Inherited (T);\n+\n       Push_Scope (T);\n \n       if Ada_Version >= Ada_2005 then"}, {"sha": "0795b21f56b5416eee18397f9a5c723dfe53d6d4", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 437, "deletions": 210, "changes": 647, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -387,7 +387,7 @@ package body Sem_Prag is\n       --  Local variables\n \n       Subp_Decl : constant Node_Id   := Find_Related_Subprogram_Or_Body (N);\n-      Spec_Id   : constant Entity_Id := Corresponding_Spec_Of (Subp_Decl);\n+      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n       CCases    : constant Node_Id   := Expression (Get_Argument (N, Spec_Id));\n \n       Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n@@ -460,7 +460,7 @@ package body Sem_Prag is\n    procedure Analyze_Depends_In_Decl_Part (N : Node_Id) is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Subp_Decl : constant Node_Id    := Find_Related_Subprogram_Or_Body (N);\n-      Spec_Id   : constant Entity_Id  := Corresponding_Spec_Of (Subp_Decl);\n+      Spec_Id   : constant Entity_Id  := Unique_Defining_Entity (Subp_Decl);\n \n       All_Inputs_Seen : Elist_Id := No_Elist;\n       --  A list containing the entities of all the inputs processed so far.\n@@ -1750,7 +1750,7 @@ package body Sem_Prag is\n \n    procedure Analyze_Global_In_Decl_Part (N : Node_Id) is\n       Subp_Decl : constant Node_Id   := Find_Related_Subprogram_Or_Body (N);\n-      Spec_Id   : constant Entity_Id := Corresponding_Spec_Of (Subp_Decl);\n+      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n       Subp_Id   : constant Entity_Id := Defining_Entity (Subp_Decl);\n \n       Constits_Seen : Elist_Id := No_Elist;\n@@ -3328,7 +3328,7 @@ package body Sem_Prag is\n             return;\n          end if;\n \n-         Spec_Id := Corresponding_Spec_Of (Subp_Decl);\n+         Spec_Id := Unique_Defining_Entity (Subp_Decl);\n \n          --  A pragma that applies to a Ghost entity becomes Ghost for the\n          --  purposes of legality checks and removal of ignored Ghost code.\n@@ -12327,7 +12327,7 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            Spec_Id := Corresponding_Spec_Of (Subp_Decl);\n+            Spec_Id := Unique_Defining_Entity (Subp_Decl);\n \n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n@@ -14003,7 +14003,7 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            Spec_Id := Corresponding_Spec_Of (Subp_Decl);\n+            Spec_Id := Unique_Defining_Entity (Subp_Decl);\n \n             --  Mark the pragma as Ghost if the related subprogram is also\n             --  Ghost. This also ensures that any expansion performed further\n@@ -14255,14 +14255,6 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_At_Most_N_Arguments (1);\n \n-            Context := Parent (N);\n-\n-            --  Handle compilation units\n-\n-            if Nkind (Context) = N_Compilation_Unit_Aux then\n-               Context := Unit (Parent (Context));\n-            end if;\n-\n             Id   := Empty;\n             Stmt := Prev (N);\n             while Present (Stmt) loop\n@@ -14276,14 +14268,12 @@ package body Sem_Prag is\n                      Error_Msg_N (\"pragma % duplicates pragma declared#\", N);\n                   end if;\n \n-               --  Protected and task types cannot be subject to pragma Ghost\n-               --  (SPARK RM 6.9(19)).\n+               --  Task unit declared without a definition cannot be subject to\n+               --  pragma Ghost (SPARK RM 6.9(19)).\n \n-               elsif Nkind (Stmt) = N_Protected_Type_Declaration then\n-                  Error_Pragma (\"pragma % cannot apply to a protected type\");\n-                  return;\n-\n-               elsif Nkind (Stmt) = N_Task_Type_Declaration then\n+               elsif Nkind_In (Stmt, N_Single_Task_Declaration,\n+                                     N_Task_Type_Declaration)\n+               then\n                   Error_Pragma (\"pragma % cannot apply to a task type\");\n                   return;\n \n@@ -14343,6 +14333,27 @@ package body Sem_Prag is\n                Stmt := Prev (Stmt);\n             end loop;\n \n+            Context := Parent (N);\n+\n+            --  Handle compilation units\n+\n+            if Nkind (Context) = N_Compilation_Unit_Aux then\n+               Context := Unit (Parent (Context));\n+            end if;\n+\n+            --  Protected and task types cannot be subject to pragma Ghost\n+            --  (SPARK RM 6.9(19)).\n+\n+            if Nkind_In (Context, N_Protected_Body, N_Protected_Definition)\n+            then\n+               Error_Pragma (\"pragma % cannot apply to a protected type\");\n+               return;\n+\n+            elsif Nkind_In (Context, N_Task_Body, N_Task_Definition) then\n+               Error_Pragma (\"pragma % cannot apply to a task type\");\n+               return;\n+            end if;\n+\n             if No (Id) then\n \n                --  When pragma Ghost is associated with a [generic] package, it\n@@ -19428,51 +19439,84 @@ package body Sem_Prag is\n \n             procedure Check_Pragma_Conformance\n               (Context_Pragma : Node_Id;\n-               Entity_Pragma  : Node_Id;\n-               Entity         : Entity_Id);\n-            --  If Context_Pragma is not Empty, verify that the new pragma N\n-            --  is compatible with the pragma Context_Pragma that was inherited\n+               Entity         : Entity_Id;\n+               Entity_Pragma  : Node_Id);\n+            --  Subsidiary to routines Process_xxx. Verify the SPARK_Mode\n+            --  conformance of pragma N depending the following scenarios:\n+            --\n+            --  If pragma Context_Pragma is not Empty, verify that pragma N is\n+            --  compatible with the pragma Context_Pragma that was inherited\n             --  from the context:\n-            --  . if Context_Pragma is ON, then the new mode can be anything\n-            --  . if Context_Pragma is OFF, then the only allowed new mode is\n-            --    also OFF.\n+            --    * If the mode of Context_Pragma is ON, then the new mode can\n+            --      be anything.\n+            --    * If the mode of Context_Pragma is OFF, then the only allowed\n+            --      new mode is also OFF. Emit error if this is not the case.\n             --\n-            --  If Entity is not Empty, verify that the new pragma N is\n-            --  compatible with Entity_Pragma, the SPARK_Mode previously set\n-            --  for Entity (which may be Empty):\n-            --  . if Entity_Pragma is ON, then the new mode can be anything\n-            --  . if Entity_Pragma is OFF, then the only allowed new mode is\n-            --    also OFF.\n-            --  . if Entity_Pragma is Empty, we always issue an error, as this\n-            --    corresponds to a case where a previous section of Entity\n-            --    had no SPARK_Mode set.\n+            --  If Entity is not Empty, verify that pragma N is compatible with\n+            --  pragma Entity_Pragma that belongs to Entity.\n+            --    * If Entity_Pragma is Empty, always issue an error as this\n+            --      corresponds to the case where a previous section of Entity\n+            --      has no SPARK_Mode set.\n+            --    * If the mode of Entity_Pragma is ON, then the new mode can\n+            --      be anything.\n+            --    * If the mode of Entity_Pragma is OFF, then the only allowed\n+            --      new mode is also OFF. Emit error if this is not the case.\n \n             procedure Check_Library_Level_Entity (E : Entity_Id);\n-            --  Verify that pragma is applied to library-level entity E\n-\n-            procedure Set_SPARK_Flags;\n-            --  Sets SPARK_Mode from Mode_Id and SPARK_Mode_Pragma from N,\n-            --  and ensures that Dynamic_Elaboration_Checks are off if the\n-            --  call sets SPARK_Mode On.\n+            --  Subsidiary to routines Process_xxx. Verify that the related\n+            --  entity E subject to pragma SPARK_Mode is library-level.\n+\n+            procedure Process_Body (Decl : Node_Id);\n+            --  Verify the legality of pragma SPARK_Mode when it appears as the\n+            --  top of the body declarations of entry, package, protected unit,\n+            --  subprogram or task unit body denoted by Decl.\n+\n+            procedure Process_Overloadable (Decl : Node_Id);\n+            --  Verify the legality of pragma SPARK_Mode when it applies to an\n+            --  entry or [generic] subprogram declaration denoted by Decl.\n+\n+            procedure Process_Private_Part (Decl : Node_Id);\n+            --  Verify the legality of pragma SPARK_Mode when it appears at the\n+            --  top of the private declarations of a package spec, protected or\n+            --  task unit declaration denoted by Decl.\n+\n+            procedure Process_Statement_Part (Decl : Node_Id);\n+            --  Verify the legality of pragma SPARK_Mode when it appears at the\n+            --  top of the statement sequence of a package body denoted by node\n+            --  Decl.\n+\n+            procedure Process_Visible_Part (Decl : Node_Id);\n+            --  Verify the legality of pragma SPARK_Mode when it appears at the\n+            --  top of the visible declarations of a package spec, protected or\n+            --  task unit declaration denoted by Decl. The routine is also used\n+            --  on protected or task units declared without a definition.\n+\n+            procedure Set_SPARK_Context;\n+            --  Subsidiary to routines Process_xxx. Set the global variables\n+            --  which represent the mode of the context from pragma N. Ensure\n+            --  that Dynamic_Elaboration_Checks are off if the new mode is On.\n \n             ------------------------------\n             -- Check_Pragma_Conformance --\n             ------------------------------\n \n             procedure Check_Pragma_Conformance\n               (Context_Pragma : Node_Id;\n-               Entity_Pragma  : Node_Id;\n-               Entity         : Entity_Id)\n+               Entity         : Entity_Id;\n+               Entity_Pragma  : Node_Id)\n             is\n-               Arg : Node_Id := Arg1;\n+               Err_Id : Entity_Id;\n+               Err_N  : Node_Id;\n \n             begin\n                --  The current pragma may appear without an argument. If this\n                --  is the case, associate all error messages with the pragma\n                --  itself.\n \n-               if No (Arg) then\n-                  Arg := N;\n+               if Present (Arg1) then\n+                  Err_N := Arg1;\n+               else\n+                  Err_N := N;\n                end if;\n \n                --  The mode of the current pragma is compared against that of\n@@ -19488,18 +19532,31 @@ package body Sem_Prag is\n                     and then Get_SPARK_Mode_From_Pragma (N) = On\n                   then\n                      Error_Msg_N\n-                       (\"cannot change SPARK_Mode from Off to On\", Arg);\n+                       (\"cannot change SPARK_Mode from Off to On\", Err_N);\n                      Error_Msg_Sloc := Sloc (SPARK_Mode_Pragma);\n-                     Error_Msg_N (\"\\SPARK_Mode was set to Off#\", Arg);\n+                     Error_Msg_N (\"\\SPARK_Mode was set to Off#\", Err_N);\n                      raise Pragma_Exit;\n                   end if;\n                end if;\n \n                --  The mode of the current pragma is compared against that of\n-               --  an initial package/subprogram declaration.\n+               --  an initial package, protected type, subprogram or task type\n+               --  declaration.\n \n                if Present (Entity) then\n \n+                  --  A simple protected or task type is transformed into an\n+                  --  anonymous type whose name cannot be used to issue error\n+                  --  messages. Recover the original entity of the type.\n+\n+                  if Ekind_In (Entity, E_Protected_Type, E_Task_Type) then\n+                     Err_Id :=\n+                       Defining_Entity\n+                         (Original_Node (Unit_Declaration_Node (Entity)));\n+                  else\n+                     Err_Id := Entity;\n+                  end if;\n+\n                   --  Both the initial declaration and the completion carry\n                   --  SPARK_Mode pragmas.\n \n@@ -19512,11 +19569,11 @@ package body Sem_Prag is\n                      if Get_SPARK_Mode_From_Pragma (Entity_Pragma) = Off\n                        and then Get_SPARK_Mode_From_Pragma (N) = On\n                      then\n-                        Error_Msg_N (\"incorrect use of SPARK_Mode\", Arg);\n+                        Error_Msg_N (\"incorrect use of SPARK_Mode\", Err_N);\n                         Error_Msg_Sloc := Sloc (Entity_Pragma);\n                         Error_Msg_NE\n                           (\"\\value Off was set for SPARK_Mode on&#\",\n-                           Arg, Entity);\n+                           Err_N, Err_Id);\n                         raise Pragma_Exit;\n                      end if;\n \n@@ -19525,11 +19582,11 @@ package body Sem_Prag is\n                   --  it cannot \"complete\".\n \n                   else\n-                     Error_Msg_N (\"incorrect use of SPARK_Mode\", Arg);\n-                     Error_Msg_Sloc := Sloc (Entity);\n+                     Error_Msg_N (\"incorrect use of SPARK_Mode\", Err_N);\n+                     Error_Msg_Sloc := Sloc (Err_Id);\n                      Error_Msg_NE\n                        (\"\\no value was set for SPARK_Mode on&#\",\n-                        Arg, Entity);\n+                        Err_N, Err_Id);\n                      raise Pragma_Exit;\n                   end if;\n                end if;\n@@ -19540,48 +19597,269 @@ package body Sem_Prag is\n             --------------------------------\n \n             procedure Check_Library_Level_Entity (E : Entity_Id) is\n-               MsgF : constant String := \"incorrect placement of pragma%\";\n+               procedure Add_Entity_To_Name_Buffer;\n+               --  Add the E_Kind of entity E to the name buffer\n \n-            begin\n-               if not Is_Library_Level_Entity (E) then\n-                  Error_Msg_Name_1 := Pname;\n-                  Error_Msg_N (Fix_Error (MsgF), N);\n+               -------------------------------\n+               -- Add_Entity_To_Name_Buffer --\n+               -------------------------------\n \n-                  if Ekind_In (E, E_Generic_Package,\n-                                  E_Package,\n-                                  E_Package_Body)\n+               procedure Add_Entity_To_Name_Buffer is\n+               begin\n+                  if Ekind_In (E, E_Entry, E_Entry_Family) then\n+                     Add_Str_To_Name_Buffer (\"entry\");\n+\n+                  elsif Ekind_In (E, E_Generic_Package,\n+                                     E_Package,\n+                                     E_Package_Body)\n                   then\n-                     Error_Msg_NE\n-                       (\"\\& is not a library-level package\", N, E);\n+                     Add_Str_To_Name_Buffer (\"package\");\n+\n+                  elsif Ekind_In (E, E_Protected_Body, E_Protected_Type) then\n+                     Add_Str_To_Name_Buffer (\"protected unit\");\n+\n+                  elsif Ekind_In (E, E_Function,\n+                                     E_Generic_Function,\n+                                     E_Generic_Procedure,\n+                                     E_Procedure,\n+                                     E_Subprogram_Body)\n+                  then\n+                     Add_Str_To_Name_Buffer (\"subprogram\");\n+\n                   else\n-                     Error_Msg_NE\n-                       (\"\\& is not a library-level subprogram\", N, E);\n+                     pragma Assert (Ekind_In (E, E_Task_Body, E_Task_Type));\n+                     Add_Str_To_Name_Buffer (\"task unit\");\n                   end if;\n+               end Add_Entity_To_Name_Buffer;\n+\n+               --  Local variables\n+\n+               Msg_1 : constant String := \"incorrect placement of pragma%\";\n+               Msg_2 : Name_Id;\n+\n+            --  Start of processing for Check_Library_Level_Entity\n+\n+            begin\n+               if not Is_Library_Level_Entity (E) then\n+                  Error_Msg_Name_1 := Pname;\n+                  Error_Msg_N (Fix_Error (Msg_1), N);\n+\n+                  Name_Len := 0;\n+                  Add_Str_To_Name_Buffer (\"\\& is not a library-level \");\n+                  Add_Entity_To_Name_Buffer;\n+\n+                  Msg_2 := Name_Find;\n+                  Error_Msg_NE (Get_Name_String (Msg_2), N, E);\n \n                   raise Pragma_Exit;\n                end if;\n             end Check_Library_Level_Entity;\n \n-            ---------------------\n-            -- Set_SPARK_Flags --\n-            ---------------------\n+            ------------------\n+            -- Process_Body --\n+            ------------------\n+\n+            procedure Process_Body (Decl : Node_Id) is\n+               Body_Id : constant Entity_Id := Defining_Entity (Decl);\n+               Spec_Id : constant Entity_Id := Unique_Defining_Entity (Decl);\n \n-            procedure Set_SPARK_Flags is\n+            begin\n+               --  Ignore pragma when applied to the special body created for\n+               --  inlining, recognized by its internal name _Parent.\n+\n+               if Chars (Body_Id) = Name_uParent then\n+                  return;\n+               end if;\n+\n+               Check_Library_Level_Entity (Body_Id);\n+\n+               --  For entry bodies, verify the legality against:\n+               --    * The mode of the context\n+               --    * The mode of the spec (if any)\n+\n+               if Nkind_In (Decl, N_Entry_Body, N_Subprogram_Body) then\n+\n+                  --  A stand alone subprogram body\n+\n+                  if Body_Id = Spec_Id then\n+                     Check_Pragma_Conformance\n+                       (Context_Pragma => SPARK_Pragma (Body_Id),\n+                        Entity         => Empty,\n+                        Entity_Pragma  => Empty);\n+\n+                  --  An entry or subprogram body that completes a previous\n+                  --  declaration.\n+\n+                  else\n+                     Check_Pragma_Conformance\n+                       (Context_Pragma => SPARK_Pragma (Body_Id),\n+                        Entity         => Spec_Id,\n+                        Entity_Pragma  => SPARK_Pragma (Spec_Id));\n+                  end if;\n+\n+                  Set_SPARK_Context;\n+                  Set_SPARK_Pragma           (Body_Id, N);\n+                  Set_SPARK_Pragma_Inherited (Body_Id, False);\n+\n+               --  For package bodies, verify the legality against:\n+               --    * The mode of the context\n+               --    * The mode of the private part\n+\n+               --  This case is separated from protected and task bodies\n+               --  because the statement part of the package body inherits\n+               --  the mode of the body declarations.\n+\n+               elsif Nkind (Decl) = N_Package_Body then\n+                  Check_Pragma_Conformance\n+                    (Context_Pragma => SPARK_Pragma (Body_Id),\n+                     Entity         => Spec_Id,\n+                     Entity_Pragma  => SPARK_Aux_Pragma (Spec_Id));\n+\n+                  Set_SPARK_Context;\n+                  Set_SPARK_Pragma               (Body_Id, N);\n+                  Set_SPARK_Pragma_Inherited     (Body_Id, False);\n+                  Set_SPARK_Aux_Pragma           (Body_Id, N);\n+                  Set_SPARK_Aux_Pragma_Inherited (Body_Id, True);\n+\n+               --  For protected and task bodies, verify the legality against:\n+               --    * The mode of the context\n+               --    * The mode of the private part\n+\n+               else\n+                  pragma Assert\n+                    (Nkind_In (Decl, N_Protected_Body, N_Task_Body));\n+\n+                  Check_Pragma_Conformance\n+                    (Context_Pragma => SPARK_Pragma (Body_Id),\n+                     Entity         => Spec_Id,\n+                     Entity_Pragma  => SPARK_Aux_Pragma (Spec_Id));\n+\n+                  Set_SPARK_Context;\n+                  Set_SPARK_Pragma           (Body_Id, N);\n+                  Set_SPARK_Pragma_Inherited (Body_Id, False);\n+               end if;\n+            end Process_Body;\n+\n+            --------------------------\n+            -- Process_Overloadable --\n+            --------------------------\n+\n+            procedure Process_Overloadable (Decl : Node_Id) is\n+               Spec_Id : constant Entity_Id := Defining_Entity (Decl);\n+\n+            begin\n+               Check_Library_Level_Entity (Spec_Id);\n+\n+               --  Verify the legality against:\n+               --    * The mode of the context\n+\n+               Check_Pragma_Conformance\n+                 (Context_Pragma => SPARK_Pragma (Spec_Id),\n+                  Entity         => Empty,\n+                  Entity_Pragma  => Empty);\n+\n+               Set_SPARK_Pragma           (Spec_Id, N);\n+               Set_SPARK_Pragma_Inherited (Spec_Id, False);\n+            end Process_Overloadable;\n+\n+            --------------------------\n+            -- Process_Private_Part --\n+            --------------------------\n+\n+            procedure Process_Private_Part (Decl : Node_Id) is\n+               Spec_Id : constant Entity_Id := Defining_Entity (Decl);\n+\n+            begin\n+               Check_Library_Level_Entity (Spec_Id);\n+\n+               --  Verify the legality against:\n+               --    * The mode of the visible declarations\n+\n+               Check_Pragma_Conformance\n+                 (Context_Pragma => Empty,\n+                  Entity         => Spec_Id,\n+                  Entity_Pragma  => SPARK_Pragma (Spec_Id));\n+\n+               Set_SPARK_Context;\n+               Set_SPARK_Aux_Pragma           (Spec_Id, N);\n+               Set_SPARK_Aux_Pragma_Inherited (Spec_Id, False);\n+            end Process_Private_Part;\n+\n+            ----------------------------\n+            -- Process_Statement_Part --\n+            ----------------------------\n+\n+            procedure Process_Statement_Part (Decl : Node_Id) is\n+               Body_Id : constant Entity_Id := Defining_Entity (Decl);\n+\n+            begin\n+               Check_Library_Level_Entity (Body_Id);\n+\n+               --  Verify the legality against:\n+               --    * The mode of the body declarations\n+\n+               Check_Pragma_Conformance\n+                 (Context_Pragma => Empty,\n+                  Entity         => Body_Id,\n+                  Entity_Pragma  => SPARK_Pragma (Body_Id));\n+\n+               Set_SPARK_Context;\n+               Set_SPARK_Aux_Pragma           (Body_Id, N);\n+               Set_SPARK_Aux_Pragma_Inherited (Body_Id, False);\n+            end Process_Statement_Part;\n+\n+            --------------------------\n+            -- Process_Visible_Part --\n+            --------------------------\n+\n+            procedure Process_Visible_Part (Decl : Node_Id) is\n+               Spec_Id : constant Entity_Id := Defining_Entity (Decl);\n+\n+            begin\n+               Check_Library_Level_Entity (Spec_Id);\n+\n+               --  Verify the legality against:\n+               --    * The mode of the context\n+\n+               Check_Pragma_Conformance\n+                 (Context_Pragma => SPARK_Pragma (Spec_Id),\n+                  Entity         => Empty,\n+                  Entity_Pragma  => Empty);\n+\n+               --  A task unit declared without a definition does not set the\n+               --  SPARK_Mode of the context because the task does not have any\n+               --  entries that could inherit the mode.\n+\n+               if not Nkind_In (Decl, N_Single_Task_Declaration,\n+                                      N_Task_Type_Declaration)\n+               then\n+                  Set_SPARK_Context;\n+               end if;\n+\n+               Set_SPARK_Pragma               (Spec_Id, N);\n+               Set_SPARK_Pragma_Inherited     (Spec_Id, False);\n+               Set_SPARK_Aux_Pragma           (Spec_Id, N);\n+               Set_SPARK_Aux_Pragma_Inherited (Spec_Id, True);\n+            end Process_Visible_Part;\n+\n+            -----------------------\n+            -- Set_SPARK_Context --\n+            -----------------------\n+\n+            procedure Set_SPARK_Context is\n             begin\n                SPARK_Mode := Mode_Id;\n                SPARK_Mode_Pragma := N;\n \n                if SPARK_Mode = On then\n                   Dynamic_Elaboration_Checks := False;\n                end if;\n-            end Set_SPARK_Flags;\n+            end Set_SPARK_Context;\n \n             --  Local variables\n \n-            Body_Id : Entity_Id;\n             Context : Node_Id;\n             Mode    : Name_Id;\n-            Spec_Id : Entity_Id;\n             Stmt    : Node_Id;\n \n          --  Start of processing for Do_SPARK_Mode\n@@ -19624,7 +19902,7 @@ package body Sem_Prag is\n                   raise Pragma_Exit;\n                end if;\n \n-               Set_SPARK_Flags;\n+               Set_SPARK_Context;\n \n             --  The pragma acts as a configuration pragma in a compilation unit\n \n@@ -19635,7 +19913,7 @@ package body Sem_Prag is\n               and then List_Containing (N) = Context_Items (Context)\n             then\n                Check_Valid_Configuration_Pragma;\n-               Set_SPARK_Flags;\n+               Set_SPARK_Context;\n \n             --  Otherwise the placement of the pragma within the tree dictates\n             --  its associated construct. Inspect the declarative list where\n@@ -19645,7 +19923,8 @@ package body Sem_Prag is\n                Stmt := Prev (N);\n                while Present (Stmt) loop\n \n-                  --  Skip prior pragmas, but check for duplicates\n+                  --  Skip prior pragmas, but check for duplicates. Note that\n+                  --  this also takes care of pragmas generated for aspects.\n \n                   if Nkind (Stmt) = N_Pragma then\n                      if Pragma_Name (Stmt) = Pname then\n@@ -19655,33 +19934,56 @@ package body Sem_Prag is\n                         raise Pragma_Exit;\n                      end if;\n \n-                  --  The pragma applies to a [generic] subprogram declaration.\n-                  --  Note that this case covers an internally generated spec\n-                  --  for a stand alone body.\n+                  --  The pragma applies to an expression function that has\n+                  --  already been rewritten into a subprogram declaration.\n \n-                  --    [generic]\n-                  --    procedure Proc ...;\n-                  --    pragma SPARK_Mode ..;\n+                  --    function Expr_Func return ... is (...);\n+                  --    pragma SPARK_Mode ...;\n \n-                  elsif Nkind_In (Stmt, N_Generic_Subprogram_Declaration,\n-                                        N_Subprogram_Declaration)\n+                  elsif Nkind (Stmt) = N_Subprogram_Declaration\n+                    and then Nkind (Original_Node (Stmt)) =\n+                               N_Expression_Function\n                   then\n-                     Spec_Id := Defining_Entity (Stmt);\n-                     Check_Library_Level_Entity (Spec_Id);\n-                     Check_Pragma_Conformance\n-                       (Context_Pragma => SPARK_Pragma (Spec_Id),\n-                        Entity_Pragma  => Empty,\n-                        Entity         => Empty);\n+                     Process_Overloadable (Stmt);\n+                     return;\n+\n+                  --  The pragma applies to a task unit without a definition.\n+                  --  This also handles the case where a single task unit is\n+                  --  rewritten into a task type declaration.\n+\n+                  --    task [type] Tsk;\n+                  --    pragma SPARK_Mode ...;\n \n-                     Set_SPARK_Pragma           (Spec_Id, N);\n-                     Set_SPARK_Pragma_Inherited (Spec_Id, False);\n+                  elsif Nkind_In (Stmt, N_Single_Task_Declaration,\n+                                        N_Task_Type_Declaration)\n+                  then\n+                     Process_Visible_Part (Stmt);\n                      return;\n \n                   --  Skip internally generated code\n \n                   elsif not Comes_From_Source (Stmt) then\n                      null;\n \n+                  --  The pragma applies to an entry or [generic] subprogram\n+                  --  declaration.\n+\n+                  --    entry Ent ...;\n+                  --    pragma SPARK_Mode ...;\n+\n+                  --    [generic]\n+                  --    procedure Proc ...;\n+                  --    pragma SPARK_Mode ...;\n+\n+                  elsif Nkind_In (Stmt, N_Generic_Subprogram_Declaration,\n+                                        N_Subprogram_Declaration)\n+                    or else (Nkind (Stmt) = N_Entry_Declaration\n+                              and then Is_Protected_Type\n+                                         (Scope (Defining_Entity (Stmt))))\n+                  then\n+                     Process_Overloadable (Stmt);\n+                     return;\n+\n                   --  Otherwise the pragma does not apply to a legal construct\n                   --  or it does not appear at the top of a declarative or a\n                   --  statement list. Issue an error and stop the analysis.\n@@ -19704,65 +20006,51 @@ package body Sem_Prag is\n                   Context := Unit (Parent (Context));\n                end if;\n \n-               --  The pragma appears within package declarations\n-\n-               if Nkind (Context) = N_Package_Specification then\n-                  Spec_Id := Defining_Entity (Context);\n-                  Check_Library_Level_Entity (Spec_Id);\n-\n-                  --  The pragma is at the top of the visible declarations\n-\n-                  --    package Pack is\n-                  --       pragma SPARK_Mode ...;\n+               --  The pragma appears at the top of entry, package, protected\n+               --  unit, subprogram or task unit body declarations.\n \n-                  if List_Containing (N) = Visible_Declarations (Context) then\n-                     Check_Pragma_Conformance\n-                       (Context_Pragma => SPARK_Pragma (Spec_Id),\n-                        Entity_Pragma  => Empty,\n-                        Entity         => Empty);\n-                     Set_SPARK_Flags;\n-\n-                     Set_SPARK_Pragma               (Spec_Id, N);\n-                     Set_SPARK_Pragma_Inherited     (Spec_Id, False);\n-                     Set_SPARK_Aux_Pragma           (Spec_Id, N);\n-                     Set_SPARK_Aux_Pragma_Inherited (Spec_Id, True);\n+               --    entry Ent when ... is\n+               --       pragma SPARK_Mode ...;\n \n-                  --  The pragma is at the top of the private declarations\n+               --    package body Pack is\n+               --       pragma SPARK_Mode ...;\n \n-                  --    package Pack is\n-                  --    private\n-                  --       pragma SPARK_Mode ...;\n+               --    procedure Proc ... is\n+               --       pragma SPARK_Mode;\n \n-                  else\n-                     Check_Pragma_Conformance\n-                       (Context_Pragma => Empty,\n-                        Entity_Pragma  => SPARK_Pragma (Spec_Id),\n-                        Entity         => Spec_Id);\n-                     Set_SPARK_Flags;\n+               --    protected body Prot is\n+               --       pragma SPARK_Mode ...;\n \n-                     Set_SPARK_Aux_Pragma           (Spec_Id, N);\n-                     Set_SPARK_Aux_Pragma_Inherited (Spec_Id, False);\n-                  end if;\n+               if Nkind_In (Context, N_Entry_Body,\n+                                     N_Package_Body,\n+                                     N_Protected_Body,\n+                                     N_Subprogram_Body,\n+                                     N_Task_Body)\n+               then\n+                  Process_Body (Context);\n \n-               --  The pragma appears at the top of package body declarations\n+               --  The pragma appears at the top of the visible or private\n+               --  declaration of a package spec, protected or task unit.\n \n-               --    package body Pack is\n+               --    package Pack is\n+               --       pragma SPARK_Mode ...;\n+               --    private\n                --       pragma SPARK_Mode ...;\n \n-               elsif Nkind (Context) = N_Package_Body then\n-                  Spec_Id := Corresponding_Spec (Context);\n-                  Body_Id := Defining_Entity (Context);\n-                  Check_Library_Level_Entity (Body_Id);\n-                  Check_Pragma_Conformance\n-                    (Context_Pragma => SPARK_Pragma (Body_Id),\n-                     Entity_Pragma  => SPARK_Aux_Pragma (Spec_Id),\n-                     Entity         => Spec_Id);\n-                  Set_SPARK_Flags;\n+               --    protected [type] Prot is\n+               --       pragma SPARK_Mode ...;\n+               --    private\n+               --       pragma SPARK_Mode ...;\n \n-                  Set_SPARK_Pragma               (Body_Id, N);\n-                  Set_SPARK_Pragma_Inherited     (Body_Id, False);\n-                  Set_SPARK_Aux_Pragma           (Body_Id, N);\n-                  Set_SPARK_Aux_Pragma_Inherited (Body_Id, True);\n+               elsif Nkind_In (Context, N_Package_Specification,\n+                                        N_Protected_Definition,\n+                                        N_Task_Definition)\n+               then\n+                  if List_Containing (N) = Visible_Declarations (Context) then\n+                     Process_Visible_Part (Parent (Context));\n+                  else\n+                     Process_Private_Part (Parent (Context));\n+                  end if;\n \n                --  The pragma appears at the top of package body statements\n \n@@ -19773,18 +20061,7 @@ package body Sem_Prag is\n                elsif Nkind (Context) = N_Handled_Sequence_Of_Statements\n                  and then Nkind (Parent (Context)) = N_Package_Body\n                then\n-                  Context := Parent (Context);\n-                  Spec_Id := Corresponding_Spec (Context);\n-                  Body_Id := Defining_Entity (Context);\n-                  Check_Library_Level_Entity (Body_Id);\n-                  Check_Pragma_Conformance\n-                    (Context_Pragma => Empty,\n-                     Entity_Pragma  => SPARK_Pragma (Body_Id),\n-                     Entity         => Body_Id);\n-                  Set_SPARK_Flags;\n-\n-                  Set_SPARK_Aux_Pragma           (Body_Id, N);\n-                  Set_SPARK_Aux_Pragma_Inherited (Body_Id, False);\n+                  Process_Statement_Part (Parent (Context));\n \n                --  The pragma appeared as an aspect of a [generic] subprogram\n                --  declaration that acts as a compilation unit.\n@@ -19796,57 +20073,7 @@ package body Sem_Prag is\n                elsif Nkind_In (Context, N_Generic_Subprogram_Declaration,\n                                         N_Subprogram_Declaration)\n                then\n-                  Spec_Id := Defining_Entity (Context);\n-                  Check_Library_Level_Entity (Spec_Id);\n-                  Check_Pragma_Conformance\n-                    (Context_Pragma => SPARK_Pragma (Spec_Id),\n-                     Entity_Pragma  => Empty,\n-                     Entity         => Empty);\n-\n-                  Set_SPARK_Pragma           (Spec_Id, N);\n-                  Set_SPARK_Pragma_Inherited (Spec_Id, False);\n-\n-               --  The pragma appears at the top of subprogram body\n-               --  declarations.\n-\n-               --    procedure Proc ... is\n-               --       pragma SPARK_Mode;\n-\n-               elsif Nkind (Context) = N_Subprogram_Body then\n-                  Spec_Id := Corresponding_Spec (Context);\n-                  Context := Specification (Context);\n-                  Body_Id := Defining_Entity (Context);\n-\n-                  --  Ignore pragma when applied to the special body created\n-                  --  for inlining, recognized by its internal name _Parent.\n-\n-                  if Chars (Body_Id) = Name_uParent then\n-                     return;\n-                  end if;\n-\n-                  Check_Library_Level_Entity (Body_Id);\n-\n-                  --  The body is a completion of a previous declaration\n-\n-                  if Present (Spec_Id) then\n-                     Check_Pragma_Conformance\n-                       (Context_Pragma => SPARK_Pragma (Body_Id),\n-                        Entity_Pragma  => SPARK_Pragma (Spec_Id),\n-                        Entity         => Spec_Id);\n-\n-                  --  The body acts as spec\n-\n-                  else\n-                     Check_Pragma_Conformance\n-                       (Context_Pragma => SPARK_Pragma (Body_Id),\n-                        Entity_Pragma  => Empty,\n-                        Entity         => Empty);\n-                  end if;\n-\n-                  Set_SPARK_Flags;\n-\n-                  Set_SPARK_Pragma           (Body_Id, N);\n-                  Set_SPARK_Pragma_Inherited (Body_Id, False);\n+                  Process_Overloadable (Context);\n \n                --  The pragma does not apply to a legal construct, issue error\n \n@@ -21559,7 +21786,7 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            Spec_Id := Corresponding_Spec_Of (Subp_Decl);\n+            Spec_Id := Unique_Defining_Entity (Subp_Decl);\n \n             if not Ekind_In (Spec_Id, E_Function, E_Generic_Function) then\n                Pragma_Misplaced;\n@@ -22186,7 +22413,7 @@ package body Sem_Prag is\n       --  Local variables\n \n       Subp_Decl : constant Node_Id   := Find_Related_Subprogram_Or_Body (N);\n-      Spec_Id   : constant Entity_Id := Corresponding_Spec_Of (Subp_Decl);\n+      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n       Expr      : constant Node_Id   := Expression (Get_Argument (N, Spec_Id));\n \n       Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n@@ -24864,7 +25091,7 @@ package body Sem_Prag is\n \n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id) is\n       Subp_Decl : constant Node_Id   := Find_Related_Subprogram_Or_Body (N);\n-      Spec_Id   : constant Entity_Id := Corresponding_Spec_Of (Subp_Decl);\n+      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n \n       procedure Preanalyze_Test_Case_Arg (Arg_Nam : Name_Id);\n       --  Preanalyze one of the optional arguments \"Requires\" or \"Ensures\"\n@@ -25845,7 +26072,7 @@ package body Sem_Prag is\n       --  Local variables\n \n       Subp_Decl : constant Node_Id   := Unit_Declaration_Node (Subp_Id);\n-      Spec_Id   : constant Entity_Id := Corresponding_Spec_Of (Subp_Decl);\n+      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n       Clause    : Node_Id;\n       Clauses   : Node_Id;\n       Depends   : Node_Id;"}, {"sha": "4a86c71ab596407eb8f43b34c6fe2283062abff2", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 69, "deletions": 59, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -4766,27 +4766,6 @@ package body Sem_Util is\n       end if;\n    end Corresponding_Generic_Type;\n \n-   ---------------------------\n-   -- Corresponding_Spec_Of --\n-   ---------------------------\n-\n-   function Corresponding_Spec_Of (Decl : Node_Id) return Entity_Id is\n-   begin\n-      if Nkind_In (Decl, N_Package_Body, N_Subprogram_Body)\n-        and then Present (Corresponding_Spec (Decl))\n-      then\n-         return Corresponding_Spec (Decl);\n-\n-      elsif Nkind_In (Decl, N_Package_Body_Stub, N_Subprogram_Body_Stub)\n-        and then Present (Corresponding_Spec_Of_Stub (Decl))\n-      then\n-         return Corresponding_Spec_Of_Stub (Decl);\n-\n-      else\n-         return Defining_Entity (Decl);\n-      end if;\n-   end Corresponding_Spec_Of;\n-\n    --------------------\n    -- Current_Entity --\n    --------------------\n@@ -19031,9 +19010,31 @@ package body Sem_Util is\n                U := Full_View (E);\n             end if;\n \n-         when Type_Kind =>\n-            if Present (Full_View (E)) then\n-               U := Full_View (E);\n+         when Entry_Kind =>\n+            if Nkind (Parent (E)) = N_Entry_Body then\n+               declare\n+                  Prot_Item : Entity_Id;\n+               begin\n+                  --  Traverse the entity list of the protected type and locate\n+                  --  an entry declaration which matches the entry body.\n+\n+                  Prot_Item := First_Entity (Scope (E));\n+                  while Present (Prot_Item) loop\n+                     if Ekind (Prot_Item) = E_Entry\n+                       and then Corresponding_Body (Parent (Prot_Item)) = E\n+                     then\n+                        U := Prot_Item;\n+                        exit;\n+                     end if;\n+\n+                     Next_Entity (Prot_Item);\n+                  end loop;\n+               end;\n+            end if;\n+\n+         when Formal_Kind =>\n+            if Present (Spec_Entity (E)) then\n+               U := Spec_Entity (E);\n             end if;\n \n          when E_Package_Body =>\n@@ -19043,7 +19044,30 @@ package body Sem_Util is\n                P := Parent (P);\n             end if;\n \n-            U := Corresponding_Spec (P);\n+            if Nkind (P) = N_Package_Body\n+              and then Present (Corresponding_Spec (P))\n+            then\n+               U := Corresponding_Spec (P);\n+\n+            elsif Nkind (P) = N_Package_Body_Stub\n+              and then Present (Corresponding_Spec_Of_Stub (P))\n+            then\n+               U := Corresponding_Spec_Of_Stub (P);\n+            end if;\n+\n+         when E_Protected_Body =>\n+            P := Parent (E);\n+\n+            if Nkind (P) = N_Protected_Body\n+              and then Present (Corresponding_Spec (P))\n+            then\n+               U := Corresponding_Spec (P);\n+\n+            elsif Nkind (P) = N_Protected_Body_Stub\n+              and then Present (Corresponding_Spec_Of_Stub (P))\n+            then\n+               U := Corresponding_Spec_Of_Stub (P);\n+            end if;\n \n          when E_Subprogram_Body =>\n             P := Parent (E);\n@@ -19054,48 +19078,34 @@ package body Sem_Util is\n \n             P := Parent (P);\n \n-            if Nkind (P) = N_Subprogram_Body_Stub then\n-               if Present (Library_Unit (P)) then\n-\n-                  --  Get to the function or procedure (generic) entity through\n-                  --  the body entity.\n-\n-                  U :=\n-                    Unique_Entity (Defining_Entity (Get_Body_From_Stub (P)));\n-               end if;\n-            else\n+            if Nkind (P) = N_Subprogram_Body\n+              and then Present (Corresponding_Spec (P))\n+            then\n                U := Corresponding_Spec (P);\n-            end if;\n \n-         when Formal_Kind =>\n-            if Present (Spec_Entity (E)) then\n-               U := Spec_Entity (E);\n+            elsif Nkind (P) = N_Subprogram_Body_Stub\n+              and then Present (Corresponding_Spec_Of_Stub (P))\n+            then\n+               U := Corresponding_Spec_Of_Stub (P);\n             end if;\n \n          when E_Task_Body =>\n             P := Parent (E);\n-            U := Corresponding_Spec (P);\n \n-         when E_Entry =>\n-            if Nkind (Parent (E)) = N_Entry_Body then\n-               declare\n-                  Decl : Entity_Id := First_Entity (Scope (E));\n-               begin\n-                  --  Traverse the entity list of the protected object\n-                  --  and locate an entry declaration with a matching\n-                  --  Corresponding_Body.\n+            if Nkind (P) = N_Task_Body\n+              and then Present (Corresponding_Spec (P))\n+            then\n+               U := Corresponding_Spec (P);\n \n-                  while Present (Decl) loop\n-                     if Ekind (Decl) = E_Entry\n-                       and then Corresponding_Body (Parent (Decl)) = E\n-                     then\n-                        U := Decl;\n-                        exit;\n-                     end if;\n-                     Next_Entity (Decl);\n-                  end loop;\n-                  pragma Assert (Present (Decl));\n-               end;\n+            elsif Nkind (P) = N_Task_Body_Stub\n+              and then Present (Corresponding_Spec_Of_Stub (P))\n+            then\n+               U := Corresponding_Spec_Of_Stub (P);\n+            end if;\n+\n+         when Type_Kind =>\n+            if Present (Full_View (E)) then\n+               U := Full_View (E);\n             end if;\n \n          when others =>"}, {"sha": "2349252f523e05a6839bd7014e5d6b84b7f053f0", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -413,10 +413,6 @@ package Sem_Util is\n    --  attribute, except in the case of formal private and derived types.\n    --  Possible optimization???\n \n-   function Corresponding_Spec_Of (Decl : Node_Id) return Entity_Id;\n-   --  Return the corresponding spec of Decl when it denotes a package or a\n-   --  subprogram [stub], or the defining entity of Decl.\n-\n    function Current_Entity (N : Node_Id) return Entity_Id;\n    pragma Inline (Current_Entity);\n    --  Find the currently visible definition for a given identifier, that is to\n@@ -2092,12 +2088,13 @@ package Sem_Util is\n    function Unique_Defining_Entity (N : Node_Id) return Entity_Id;\n    --  Return the entity which represents declaration N, so that different\n    --  views of the same entity have the same unique defining entity:\n-   --  * package spec and body;\n-   --  * subprogram declaration, subprogram stub and subprogram body;\n-   --  * entry declaration and entry body;\n-   --  * task declaration, task body stub and task body;\n-   --  * private view and full view of a type;\n-   --  * private view and full view of a deferred constant.\n+   --    * entry declaration and entry body\n+   --    * package spec and body\n+   --    * protected type declaration, protected body stub and protected body\n+   --    * private view and full view of a deferred constant\n+   --    * private view and full view of a type\n+   --    * subprogram declaration, subprogram stub and subprogram body\n+   --    * task type declaration, task body stub and task body\n    --  In other cases, return the defining entity for N.\n \n    function Unique_Entity (E : Entity_Id) return Entity_Id;"}, {"sha": "7f2d9a8fd8868c87237c20ee59e153c55ef3d2a4", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -1848,7 +1848,8 @@ package body Sinfo is\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Subprogram_Body);\n+        or else NT (N).Nkind = N_Subprogram_Body\n+        or else NT (N).Nkind = N_Subprogram_Declaration);\n       return Flag8 (N);\n    end Is_Entry_Barrier_Function;\n \n@@ -2005,6 +2006,15 @@ package body Sinfo is\n       return Flag6 (N);\n    end Is_Task_Allocation_Block;\n \n+   function Is_Task_Body_Procedure\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Subprogram_Body\n+        or else NT (N).Nkind = N_Subprogram_Declaration);\n+      return Flag1 (N);\n+   end Is_Task_Body_Procedure;\n+\n    function Is_Task_Master\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5069,7 +5079,8 @@ package body Sinfo is\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Subprogram_Body);\n+        or else NT (N).Nkind = N_Subprogram_Body\n+        or else NT (N).Nkind = N_Subprogram_Declaration);\n       Set_Flag8 (N, Val);\n    end Set_Is_Entry_Barrier_Function;\n \n@@ -5226,6 +5237,15 @@ package body Sinfo is\n       Set_Flag6 (N, Val);\n    end Set_Is_Task_Allocation_Block;\n \n+   procedure Set_Is_Task_Body_Procedure\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Subprogram_Body\n+        or else NT (N).Nkind = N_Subprogram_Declaration);\n+      Set_Flag1 (N, Val);\n+   end Set_Is_Task_Body_Procedure;\n+\n    procedure Set_Is_Task_Master\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "613ea4c647a25d0f81541986cae852d6555dcaf1", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877a5a124a918f82f808c27b8cd64b5bd07f844f/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=877a5a124a918f82f808c27b8cd64b5bd07f844f", "patch": "@@ -1571,7 +1571,7 @@ package Sinfo is\n    --    concatenation nodes in instances.\n \n    --  Is_Controlling_Actual (Flag16-Sem)\n-   --    This flag is set on in an expression that is a controlling argument in\n+   --    This flag is set on an expression that is a controlling argument in\n    --    a dispatching call. It is off in all other cases. See Sem_Disp for\n    --    details of its use.\n \n@@ -1596,9 +1596,9 @@ package Sinfo is\n    --    the enclosing object.\n \n    --  Is_Entry_Barrier_Function (Flag8-Sem)\n-   --    This flag is set in an N_Subprogram_Body node which is the expansion\n-   --    of an entry barrier from a protected entry body. It is used for the\n-   --    circuitry checking for incorrect use of Current_Task.\n+   --    This flag is set on N_Subprogram_Declaration and N_Subprogram_Body\n+   --    nodes which emulate the barrier function of a protected entry body.\n+   --    The flag is used when checking for incorrect use of Current_Task.\n \n    --  Is_Expanded_Build_In_Place_Call (Flag11-Sem)\n    --    This flag is set in an N_Function_Call node to indicate that the extra\n@@ -1728,6 +1728,10 @@ package Sinfo is\n    --    Expunge_Unactivated_Tasks to complete any tasks that have been\n    --    allocated but not activated when the allocator completes abnormally.\n \n+   --  Is_Task_Body_Procedure (Flag1-Sem)\n+   --    This flag is set on N_Subprogram_Declaration and N_Subprogram_Body\n+   --    nodes which emulate the body of a task unit.\n+\n    --  Is_Task_Master (Flag5-Sem)\n    --    A flag set in a Subprogram_Body, Block_Statement or Task_Body node to\n    --    indicate that the construct is a task master (i.e. has declared tasks\n@@ -4953,6 +4957,8 @@ package Sinfo is\n       --  Body_To_Inline (Node3-Sem)\n       --  Corresponding_Body (Node5-Sem)\n       --  Parent_Spec (Node4-Sem)\n+      --  Is_Entry_Barrier_Function (Flag8-Sem)\n+      --  Is_Task_Body_Procedure (Flag1-Sem)\n \n       ------------------------------------------\n       -- 6.1  Abstract Subprogram Declaration --\n@@ -5192,8 +5198,9 @@ package Sinfo is\n       --  Acts_As_Spec (Flag4-Sem)\n       --  Bad_Is_Detected (Flag15) used only by parser\n       --  Do_Storage_Check (Flag17-Sem)\n-      --  Is_Protected_Subprogram_Body (Flag7-Sem)\n       --  Is_Entry_Barrier_Function (Flag8-Sem)\n+      --  Is_Protected_Subprogram_Body (Flag7-Sem)\n+      --  Is_Task_Body_Procedure (Flag1-Sem)\n       --  Is_Task_Master (Flag5-Sem)\n       --  Was_Originally_Stub (Flag13-Sem)\n       --  Has_Relative_Deadline_Pragma (Flag9-Sem)\n@@ -9384,6 +9391,9 @@ package Sinfo is\n    function Is_Task_Allocation_Block\n      (N : Node_Id) return Boolean;    -- Flag6\n \n+   function Is_Task_Body_Procedure\n+     (N : Node_Id) return Boolean;    -- Flag1\n+\n    function Is_Task_Master\n      (N : Node_Id) return Boolean;    -- Flag5\n \n@@ -10413,6 +10423,9 @@ package Sinfo is\n    procedure Set_Is_Task_Allocation_Block\n      (N : Node_Id; Val : Boolean := True);    -- Flag6\n \n+   procedure Set_Is_Task_Body_Procedure\n+     (N : Node_Id; Val : Boolean := True);    -- Flag1\n+\n    procedure Set_Is_Task_Master\n      (N : Node_Id; Val : Boolean := True);    -- Flag5\n \n@@ -12780,6 +12793,7 @@ package Sinfo is\n    pragma Inline (Is_Static_Expression);\n    pragma Inline (Is_Subprogram_Descriptor);\n    pragma Inline (Is_Task_Allocation_Block);\n+   pragma Inline (Is_Task_Body_Procedure);\n    pragma Inline (Is_Task_Master);\n    pragma Inline (Iteration_Scheme);\n    pragma Inline (Itype);\n@@ -13118,6 +13132,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Static_Expression);\n    pragma Inline (Set_Is_Subprogram_Descriptor);\n    pragma Inline (Set_Is_Task_Allocation_Block);\n+   pragma Inline (Set_Is_Task_Body_Procedure);\n    pragma Inline (Set_Is_Task_Master);\n    pragma Inline (Set_Iteration_Scheme);\n    pragma Inline (Set_Iterator_Specification);"}]}