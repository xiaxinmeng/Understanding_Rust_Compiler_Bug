{"sha": "18ea3d61120e90daa10cb87231b4426cba8bee3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThlYTNkNjExMjBlOTBkYWExMGNiODcyMzFiNDQyNmNiYThiZWUzZg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2014-11-21T21:29:54Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2014-11-21T21:29:54Z"}, "message": "re PR target/63897 (gcc.dg/torture/vector-2.c fails at on x86_64-apple-darwin14)\n\n2014-11-21  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/63897\n\t* lra-lives.c (mark_regno_live, mark_regno_dead): Remove last\n\targument.\n\t(process_bb_lives): Rename dead_insn_p on remove_p\n\tand global_live_info_p on dead_insn_p.  Calculate local live info\n\tunconditionally.  Remove last argument in calls mark_regno_live and\n\tmark_regno_dead.  Reorganize body of EXECUTE_IF_SET_IN_BITMAP.\n\t(lra_create_live_ranges): Rename to lra_create_live_ranges_1.\n\tReturn bool.  Rename global_live_info_p on dead_insn_p.  Return\n\tflag of live info change.\n\t(lra_create_live_ranges): New.\n\nFrom-SVN: r217947", "tree": {"sha": "a629e3c2af5b118ea59b6ee21bb59c67643b18e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a629e3c2af5b118ea59b6ee21bb59c67643b18e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18ea3d61120e90daa10cb87231b4426cba8bee3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18ea3d61120e90daa10cb87231b4426cba8bee3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18ea3d61120e90daa10cb87231b4426cba8bee3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18ea3d61120e90daa10cb87231b4426cba8bee3f/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "92344ed0caa6b9364cd66c12e36b572106d43de4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92344ed0caa6b9364cd66c12e36b572106d43de4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92344ed0caa6b9364cd66c12e36b572106d43de4"}], "stats": {"total": 135, "additions": 80, "deletions": 55}, "files": [{"sha": "4697608f8a28e5b7f8973bc3aa3b9791ba45288c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18ea3d61120e90daa10cb87231b4426cba8bee3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18ea3d61120e90daa10cb87231b4426cba8bee3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18ea3d61120e90daa10cb87231b4426cba8bee3f", "patch": "@@ -1,3 +1,17 @@\n+2014-11-21  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/63897\n+\t* lra-lives.c (mark_regno_live, mark_regno_dead): Remove last\n+\targument.\n+\t(process_bb_lives): Rename dead_insn_p on remove_p\n+\tand global_live_info_p on dead_insn_p.  Calculate local live info\n+\tunconditionally.  Remove last argument in calls mark_regno_live and\n+\tmark_regno_dead.  Reorganize body of EXECUTE_IF_SET_IN_BITMAP.\n+\t(lra_create_live_ranges): Rename to lra_create_live_ranges_1.\n+\tReturn bool.  Rename global_live_info_p on dead_insn_p.  Return\n+\tflag of live info change.\n+\t(lra_create_live_ranges): New.\n+\n 2014-11-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/63848"}, {"sha": "df0143f893b8607854678b6e04f308a8cb9ba7b0", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 66, "deletions": 55, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18ea3d61120e90daa10cb87231b4426cba8bee3f/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18ea3d61120e90daa10cb87231b4426cba8bee3f/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=18ea3d61120e90daa10cb87231b4426cba8bee3f", "patch": "@@ -321,11 +321,11 @@ mark_pseudo_dead (int regno, int point)\n static bitmap bb_killed_pseudos, bb_gen_pseudos;\n \n /* Mark register REGNO (pseudo or hard register) in MODE as live at\n-   program point POINT.  Update BB_GEN_PSEUDOS if LOCAL_SETS_P.\n+   program point POINT.  Update BB_GEN_PSEUDOS.\n    Return TRUE if the liveness tracking sets were modified, or FALSE\n    if nothing changed.  */\n static bool\n-mark_regno_live (int regno, machine_mode mode, int point, bool local_sets_p)\n+mark_regno_live (int regno, machine_mode mode, int point)\n {\n   int last;\n   bool changed = false;\n@@ -344,19 +344,17 @@ mark_regno_live (int regno, machine_mode mode, int point, bool local_sets_p)\n \t  mark_pseudo_live (regno, point);\n \t  changed = true;\n \t}\n-      if (local_sets_p)\n-\tbitmap_set_bit (bb_gen_pseudos, regno);\n+      bitmap_set_bit (bb_gen_pseudos, regno);\n     }\n   return changed;\n }\n \n \n /* Mark register REGNO in MODE as dead at program point POINT.  Update\n-   BB_GEN_PSEUDOS and BB_KILLED_PSEUDOS if LOCAL_SETS_P.  Return TRUE\n-   if the liveness tracking sets were modified, or FALSE if nothing\n-   changed.  */\n+   BB_GEN_PSEUDOS and BB_KILLED_PSEUDOS.  Return TRUE if the liveness\n+   tracking sets were modified, or FALSE if nothing changed.  */\n static bool\n-mark_regno_dead (int regno, machine_mode mode, int point, bool local_sets_p)\n+mark_regno_dead (int regno, machine_mode mode, int point)\n {\n   int last;\n   bool changed = false;\n@@ -375,11 +373,8 @@ mark_regno_dead (int regno, machine_mode mode, int point, bool local_sets_p)\n \t  mark_pseudo_dead (regno, point);\n \t  changed = true;\n \t}\n-      if (local_sets_p)\n-\t{\n-\t  bitmap_clear_bit (bb_gen_pseudos, regno);\n-\t  bitmap_set_bit (bb_killed_pseudos, regno);\n-\t}\n+      bitmap_clear_bit (bb_gen_pseudos, regno);\n+      bitmap_set_bit (bb_killed_pseudos, regno);\n     }\n   return changed;\n }\n@@ -639,10 +634,10 @@ check_pseudos_live_through_calls (int regno)\n    BB ends.  The function updates this counter and returns in\n    CURR_POINT the program point where BB starts.  The function also\n    does local live info updates and can delete the dead insns if\n-   GLOBAL_LIVE_INFO_P.  It returns true if pseudo live info was\n+   DEAD_INSN_P.  It returns true if pseudo live info was\n    changed at the BB start.  */\n static bool\n-process_bb_lives (basic_block bb, int &curr_point, bool global_live_info_p)\n+process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n {\n   int i, regno, freq;\n   unsigned int j;\n@@ -662,13 +657,10 @@ process_bb_lives (basic_block bb, int &curr_point, bool global_live_info_p)\n   EXECUTE_IF_SET_IN_BITMAP (reg_live_out, FIRST_PSEUDO_REGISTER, j, bi)\n     mark_pseudo_live (j, curr_point);\n \n-  if (global_live_info_p)\n-    {\n-      bb_gen_pseudos = &get_bb_data (bb)->gen_pseudos;\n-      bb_killed_pseudos = &get_bb_data (bb)->killed_pseudos;\n-      bitmap_clear (bb_gen_pseudos);\n-      bitmap_clear (bb_killed_pseudos);\n-    }\n+  bb_gen_pseudos = &get_bb_data (bb)->gen_pseudos;\n+  bb_killed_pseudos = &get_bb_data (bb)->killed_pseudos;\n+  bitmap_clear (bb_gen_pseudos);\n+  bitmap_clear (bb_killed_pseudos);\n   freq = REG_FREQ_FROM_BB (bb);\n \n   if (lra_dump_file != NULL)\n@@ -701,7 +693,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool global_live_info_p)\n \n       set = single_set (curr_insn);\n \n-      if (global_live_info_p && set != NULL_RTX\n+      if (dead_insn_p && set != NULL_RTX\n \t  && REG_P (SET_DEST (set)) && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n \t  && find_reg_note (curr_insn, REG_EH_REGION, NULL_RTX) == NULL_RTX\n \t  && ! may_trap_p (PATTERN (curr_insn))\n@@ -710,21 +702,21 @@ process_bb_lives (basic_block bb, int &curr_point, bool global_live_info_p)\n \t  && (pic_offset_table_rtx == NULL_RTX\n \t      || pic_offset_table_rtx != SET_DEST (set)))\n \t{\n-\t  bool dead_insn_p = true;\n+\t  bool remove_p = true;\n \n \t  for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \t    if (reg->type != OP_IN && sparseset_bit_p (pseudos_live, reg->regno))\n \t      {\n-\t\tdead_insn_p = false;\n+\t\tremove_p = false;\n \t\tbreak;\n \t      }\n \t  for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \t    if (reg->type != OP_IN)\n \t      {\n-\t\tdead_insn_p = false;\n+\t\tremove_p = false;\n \t\tbreak;\n \t      }\n-\t  if (dead_insn_p && ! volatile_refs_p (PATTERN (curr_insn)))\n+\t  if (remove_p && ! volatile_refs_p (PATTERN (curr_insn)))\n \t    {\n \t      dst_regno = REGNO (SET_DEST (set));\n \t      if (lra_dump_file != NULL)\n@@ -818,7 +810,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool global_live_info_p)\n \t  {\n \t    need_curr_point_incr\n \t      |= mark_regno_live (reg->regno, reg->biggest_mode,\n-\t\t\t\t  curr_point, global_live_info_p);\n+\t\t\t\t  curr_point);\n \t    check_pseudos_live_through_calls (reg->regno);\n \t  }\n \n@@ -835,7 +827,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool global_live_info_p)\n \tif (reg->type == OP_OUT && ! reg->early_clobber && ! reg->subreg_p)\n \t  need_curr_point_incr\n \t    |= mark_regno_dead (reg->regno, reg->biggest_mode,\n-\t\t\t\tcurr_point, global_live_info_p);\n+\t\t\t\tcurr_point);\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_OUT && ! reg->early_clobber && ! reg->subreg_p)\n@@ -877,7 +869,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool global_live_info_p)\n \t  {\n \t    need_curr_point_incr\n \t      |= mark_regno_live (reg->regno, reg->biggest_mode,\n-\t\t\t\t  curr_point, global_live_info_p);\n+\t\t\t\t  curr_point);\n \t    check_pseudos_live_through_calls (reg->regno);\n \t  }\n \n@@ -897,7 +889,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool global_live_info_p)\n \tif (reg->type == OP_OUT && reg->early_clobber && ! reg->subreg_p)\n \t  need_curr_point_incr\n \t    |= mark_regno_dead (reg->regno, reg->biggest_mode,\n-\t\t\t\tcurr_point, global_live_info_p);\n+\t\t\t\tcurr_point);\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_OUT && reg->early_clobber && ! reg->subreg_p)\n@@ -971,25 +963,22 @@ process_bb_lives (basic_block bb, int &curr_point, bool global_live_info_p)\n     }\n \n   bool live_change_p = false;\n-  if (global_live_info_p)\n+  /* Check if bb border live info was changed.  */\n+  unsigned int live_pseudos_num = 0;\n+  EXECUTE_IF_SET_IN_BITMAP (df_get_live_in (bb),\n+\t\t\t    FIRST_PSEUDO_REGISTER, j, bi)\n     {\n-      /* Check if bb border live info was changed.  */\n-      unsigned int live_pseudos_num = 0;\n-      EXECUTE_IF_SET_IN_BITMAP (df_get_live_in (bb),\n-\t\t\t\tFIRST_PSEUDO_REGISTER, j, bi)\n+      live_pseudos_num++;\n+      if (! sparseset_bit_p (pseudos_live, j))\n \t{\n-\t  live_pseudos_num++;\n-\t  if (! sparseset_bit_p (pseudos_live, j))\n-\t    {\n-\t      live_change_p = TRUE;\n-\t      break;\n-\t    }\n+\t  live_change_p = TRUE;\n+\t  break;\n \t}\n-      live_change_p\n-\t= (live_change_p\n-\t   || sparseset_cardinality (pseudos_live) != live_pseudos_num);\n     }\n-\n+  live_change_p\n+    = (live_change_p\n+       || sparseset_cardinality (pseudos_live) != live_pseudos_num);\n+  \n   /* See if we'll need an increment at the end of this basic block.\n      An increment is needed if the PSEUDOS_LIVE set is not empty,\n      to make sure the finish points are set up correctly.  */\n@@ -1180,13 +1169,14 @@ compress_live_ranges (void)\n /* The number of the current live range pass.  */\n int lra_live_range_iter;\n \n-/* The main entry function creates live ranges only for memory pseudos\n-   (or for all ones if ALL_P), set up CONFLICT_HARD_REGS for the\n-   pseudos.  It also does dead insn elimination and global live\n-   analysis only for pseudos and only if GLOBAL_LIVE_INFO_P and the\n-   pseudo live info was changed on a BB border.  */\n-void\n-lra_create_live_ranges (bool all_p, bool global_live_info_p)\n+/* The function creates live ranges only for memory pseudos (or for\n+   all ones if ALL_P), set up CONFLICT_HARD_REGS for the pseudos.  It\n+   also does dead insn elimination if DEAD_INSN_P and global live\n+   analysis only for pseudos and only if the pseudo live info was\n+   changed on a BB border.  Return TRUE if the live info was\n+   changed.  */\n+static bool\n+lra_create_live_ranges_1 (bool all_p, bool dead_insn_p)\n {\n   basic_block bb;\n   int i, hard_regno, max_regno = max_reg_num ();\n@@ -1239,7 +1229,7 @@ lra_create_live_ranges (bool all_p, bool global_live_info_p)\n   if (! have_referenced_pseudos)\n     {\n       timevar_pop (TV_LRA_CREATE_LIVE_RANGES);\n-      return;\n+      return false;\n     }\n \n   pseudos_live = sparseset_alloc (max_regno);\n@@ -1262,7 +1252,7 @@ lra_create_live_ranges (bool all_p, bool global_live_info_p)\n       if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || bb\n \t  == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n-      if (process_bb_lives (bb, curr_point, global_live_info_p))\n+      if (process_bb_lives (bb, curr_point, dead_insn_p))\n \tbb_live_change_p = true;\n     }\n   if (bb_live_change_p)\n@@ -1317,6 +1307,27 @@ lra_create_live_ranges (bool all_p, bool global_live_info_p)\n   sparseset_free (pseudos_live);\n   compress_live_ranges ();\n   timevar_pop (TV_LRA_CREATE_LIVE_RANGES);\n+  return bb_live_change_p;\n+}\n+\n+/* The main entry function creates live-ranges and other live info\n+   necessary for the assignment sub-pass.  It uses\n+   lra_creates_live_ranges_1 -- so read comments for the\n+   function.  */\n+void\n+lra_create_live_ranges (bool all_p, bool dead_insn_p)\n+{\n+  if (! lra_create_live_ranges_1 (all_p, dead_insn_p))\n+    return;\n+  if (lra_dump_file != NULL)\n+    fprintf (lra_dump_file, \"Live info was changed -- recalculate it\\n\");\n+  /* Live info was changed on a bb border.  It means that some info,\n+     e.g. about conflict regs, calls crossed may be wrong, live\n+     ranges.  We need this info for allocation.  So recalcualate it\n+     again.  */\n+  lra_clear_live_ranges ();\n+  bool res = lra_create_live_ranges_1 (all_p, dead_insn_p);\n+  lra_assert (! res);\n }\n \n /* Finish all live ranges.  */"}]}