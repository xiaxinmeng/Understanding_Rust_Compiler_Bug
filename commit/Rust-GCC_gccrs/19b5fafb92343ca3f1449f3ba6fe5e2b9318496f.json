{"sha": "19b5fafb92343ca3f1449f3ba6fe5e2b9318496f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTliNWZhZmI5MjM0M2NhM2YxNDQ5ZjNiYTZmZTVlMmI5MzE4NDk2Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-07-24T17:36:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-07-24T17:36:56Z"}, "message": "Introduce and use code_to_optab and optab_to_code functions\n\nRemoves all the direct uses of op->code so that we can change\nthe representation of \"optab\".  The code_to_optab change is\nsimply for uniformity (and better type checking).\n\n        * optabs.h (struct optab_d): Rename code member to code_.\n        (struct convert_optab_h): Likewise.\n        (code_to_optab_): Rename from code_to_optab.\n        (code_to_optab, optab_to_code): New.\n        * dojump.c (do_compare_rtx_and_jump): Use code_to_optab.\n        * ifcvt.c (noce_emit_move_insn): Likewise.\n        * optabs.c (simplify_expand_binop): Use optab_to_code.\n        (expand_simple_binop, shift_optab_p, commutative_optab_p): Likewise.\n        (avoid_expensive_constant, expand_binop_directly): Likewise.\n        (expand_binop, expand_simple_unop, expand_unop_direct): Likewise.\n        (expand_unop, prepare_float_lib_cmp, expand_fixed_convert): Likewise.\n        (have_insn_for, debug_optab_libfuncs): Likewise.\n        (init_optab, init_optabv, init_convert_optab): Update for optab\n        member name change.\n\nFrom-SVN: r189818", "tree": {"sha": "915b8b77cea8c62c51c2089f3804fe1591603acd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/915b8b77cea8c62c51c2089f3804fe1591603acd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f/comments", "author": null, "committer": null, "parents": [{"sha": "723cd7abc6c94d4fa8cc4e1428f79e7861c5d99a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/723cd7abc6c94d4fa8cc4e1428f79e7861c5d99a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/723cd7abc6c94d4fa8cc4e1428f79e7861c5d99a"}], "stats": {"total": 99, "additions": 62, "deletions": 37}, "files": [{"sha": "ef1dc84246044c67d4c900f0b85013bc046acc4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19b5fafb92343ca3f1449f3ba6fe5e2b9318496f", "patch": "@@ -1,5 +1,20 @@\n 2012-07-24  Richard Henderson  <rth@redhat.com>\n \n+\t* optabs.h (struct optab_d): Rename code member to code_.\n+\t(struct convert_optab_h): Likewise.\n+\t(code_to_optab_): Rename from code_to_optab.\n+\t(code_to_optab, optab_to_code): New.\n+\t* dojump.c (do_compare_rtx_and_jump): Use code_to_optab.\n+\t* ifcvt.c (noce_emit_move_insn): Likewise.\n+\t* optabs.c (simplify_expand_binop): Use optab_to_code.\n+\t(expand_simple_binop, shift_optab_p, commutative_optab_p): Likewise.\n+\t(avoid_expensive_constant, expand_binop_directly): Likewise.\n+\t(expand_binop, expand_simple_unop, expand_unop_direct): Likewise.\n+\t(expand_unop, prepare_float_lib_cmp, expand_fixed_convert): Likewise.\n+\t(have_insn_for, debug_optab_libfuncs): Likewise.\n+\t(init_optab, init_optabv, init_convert_optab): Update for optab\n+\tmember name change.\n+\n \t* libfuncs.h: Include optabs.h.\n \t* dwarf2out.c, lto-streamer.in.c: Don't include libfuncs.h.\n \t* Makefile.in (LIBFUNCS_H): Add OPTABS_H."}, {"sha": "ea6620d64b7af909eb6b39fd34c1ee5ae1abe899", "filename": "gcc/dojump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=19b5fafb92343ca3f1449f3ba6fe5e2b9318496f", "patch": "@@ -1037,7 +1037,7 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t\t  we can jump on other conditions...  */\n \t       && (have_insn_for (COMPARE, mode)\n \t           /* ... or if there is no libcall for it.  */\n-\t           || code_to_optab[code] == unknown_optab))\n+\t           || code_to_optab (code) == unknown_optab))\n         {\n \t  enum rtx_code first_code;\n \t  bool and_them = split_comparison (code, mode, &first_code, &code);"}, {"sha": "31fa66571b2f88c157d84905a60bd7a2398e082b", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=19b5fafb92343ca3f1449f3ba6fe5e2b9318496f", "patch": "@@ -902,7 +902,7 @@ noce_emit_move_insn (rtx x, rtx y)\n \t  switch (GET_RTX_CLASS (GET_CODE (y)))\n \t    {\n \t    case RTX_UNARY:\n-\t      ot = code_to_optab[GET_CODE (y)];\n+\t      ot = code_to_optab (GET_CODE (y));\n \t      if (ot)\n \t\t{\n \t\t  start_sequence ();\n@@ -919,7 +919,7 @@ noce_emit_move_insn (rtx x, rtx y)\n \n \t    case RTX_BIN_ARITH:\n \t    case RTX_COMM_ARITH:\n-\t      ot = code_to_optab[GET_CODE (y)];\n+\t      ot = code_to_optab (GET_CODE (y));\n \t      if (ot)\n \t\t{\n \t\t  start_sequence ();"}, {"sha": "83509f99877e7ec0dd7cb7266d2c71c2f0570875", "filename": "gcc/optabs.c", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=19b5fafb92343ca3f1449f3ba6fe5e2b9318496f", "patch": "@@ -55,7 +55,7 @@ struct target_libfuncs *this_target_libfuncs = &default_target_libfuncs;\n   (this_target_libfuncs->x_libfunc_hash)\n \n /* Contains the optab used for each rtx code.  */\n-optab code_to_optab[NUM_RTX_CODE + 1];\n+optab code_to_optab_[NUM_RTX_CODE + 1];\n \n static void prepare_float_lib_cmp (rtx, rtx, enum rtx_code, rtx *,\n \t\t\t\t   enum machine_mode *);\n@@ -678,8 +678,8 @@ simplify_expand_binop (enum machine_mode mode, optab binoptab,\n {\n   if (CONSTANT_P (op0) && CONSTANT_P (op1))\n     {\n-      rtx x = simplify_binary_operation (binoptab->code, mode, op0, op1);\n-\n+      rtx x = simplify_binary_operation (optab_to_code (binoptab),\n+\t\t\t\t\t mode, op0, op1);\n       if (x)\n \treturn x;\n     }\n@@ -1266,7 +1266,7 @@ expand_simple_binop (enum machine_mode mode, enum rtx_code code, rtx op0,\n \t\t     rtx op1, rtx target, int unsignedp,\n \t\t     enum optab_methods methods)\n {\n-  optab binop = code_to_optab[(int) code];\n+  optab binop = code_to_optab (code);\n   gcc_assert (binop);\n \n   return expand_binop (mode, binop, op0, op1, target, unsignedp, methods);\n@@ -1300,7 +1300,7 @@ swap_commutative_operands_with_target (rtx target, rtx op0, rtx op1)\n static bool\n shift_optab_p (optab binoptab)\n {\n-  switch (binoptab->code)\n+  switch (optab_to_code (binoptab))\n     {\n     case ASHIFT:\n     case SS_ASHIFT:\n@@ -1321,7 +1321,7 @@ shift_optab_p (optab binoptab)\n static bool\n commutative_optab_p (optab binoptab)\n {\n-  return (GET_RTX_CLASS (binoptab->code) == RTX_COMM_ARITH\n+  return (GET_RTX_CLASS (optab_to_code (binoptab)) == RTX_COMM_ARITH\n \t  || binoptab == smul_widen_optab\n \t  || binoptab == umul_widen_optab\n \t  || binoptab == smul_highpart_optab\n@@ -1342,7 +1342,8 @@ avoid_expensive_constant (enum machine_mode mode, optab binoptab,\n   if (mode != VOIDmode\n       && optimize\n       && CONSTANT_P (x)\n-      && rtx_cost (x, binoptab->code, opn, speed) > set_src_cost (x, speed))\n+      && (rtx_cost (x, optab_to_code (binoptab), opn, speed)\n+\t  > set_src_cost (x, speed)))\n     {\n       if (CONST_INT_P (x))\n \t{\n@@ -1458,7 +1459,7 @@ expand_binop_directly (enum machine_mode mode, optab binoptab,\n \t REG_EQUAL note to it.  If we can't because TEMP conflicts with an\n \t operand, call expand_binop again, this time without a target.  */\n       if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n-\t  && ! add_equal_note (pat, ops[0].value, binoptab->code,\n+\t  && ! add_equal_note (pat, ops[0].value, optab_to_code (binoptab),\n \t\t\t       ops[1].value, ops[2].value))\n \t{\n \t  delete_insns_since (last);\n@@ -2029,8 +2030,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t      rtx temp = emit_move_insn (target, xtarget);\n \n \t      set_dst_reg_note (temp, REG_EQUAL,\n-\t\t\t\tgen_rtx_fmt_ee (binoptab->code, mode,\n-\t\t\t\t\t\tcopy_rtx (xop0),\n+\t\t\t\tgen_rtx_fmt_ee (optab_to_code (binoptab),\n+\t\t\t\t\t\tmode, copy_rtx (xop0),\n \t\t\t\t\t\tcopy_rtx (xop1)),\n \t\t\t\ttarget);\n \t    }\n@@ -2128,7 +2129,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       target = gen_reg_rtx (mode);\n       emit_libcall_block_1 (insns, target, value,\n-\t\t\t    gen_rtx_fmt_ee (binoptab->code, mode, op0, op1),\n+\t\t\t    gen_rtx_fmt_ee (optab_to_code (binoptab),\n+\t\t\t\t\t    mode, op0, op1),\n \t\t\t    trapv_binoptab_p (binoptab));\n \n       return target;\n@@ -2481,7 +2483,7 @@ rtx\n expand_simple_unop (enum machine_mode mode, enum rtx_code code, rtx op0,\n \t\t    rtx target, int unsignedp)\n {\n-  optab unop = code_to_optab[(int) code];\n+  optab unop = code_to_optab (code);\n   gcc_assert (unop);\n \n   return expand_unop (mode, unop, op0, target, unsignedp);\n@@ -2971,7 +2973,7 @@ expand_unop_direct (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       if (pat)\n \t{\n \t  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n-\t      && ! add_equal_note (pat, ops[0].value, unoptab->code,\n+\t      && ! add_equal_note (pat, ops[0].value, optab_to_code (unoptab),\n \t\t\t\t   ops[1].value, NULL_RTX))\n \t    {\n \t      delete_insns_since (last);\n@@ -3170,7 +3172,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       return target;\n     }\n \n-  if (unoptab->code == NEG)\n+  if (optab_to_code (unoptab) == NEG)\n     {\n       /* Try negating floating point values by flipping the sign bit.  */\n       if (SCALAR_FLOAT_MODE_P (mode))\n@@ -3246,7 +3248,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       end_sequence ();\n \n       target = gen_reg_rtx (outmode);\n-      eq_value = gen_rtx_fmt_e (unoptab->code, mode, op0);\n+      eq_value = gen_rtx_fmt_e (optab_to_code (unoptab), mode, op0);\n       if (GET_MODE_SIZE (outmode) < GET_MODE_SIZE (mode))\n \teq_value = simplify_gen_unary (TRUNCATE, outmode, eq_value, mode);\n       else if (GET_MODE_SIZE (outmode) > GET_MODE_SIZE (mode))\n@@ -3326,7 +3328,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n   /* One final attempt at implementing negation via subtraction,\n      this time allowing widening of the operand.  */\n-  if (unoptab->code == NEG && !HONOR_SIGNED_ZEROS (mode))\n+  if (optab_to_code (unoptab) == NEG && !HONOR_SIGNED_ZEROS (mode))\n     {\n       rtx temp;\n       temp = expand_binop (mode,\n@@ -4325,21 +4327,21 @@ prepare_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison,\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n-      if (code_to_optab[comparison]\n-\t  && (libfunc = optab_libfunc (code_to_optab[comparison], mode)))\n+      if (code_to_optab (comparison)\n+\t  && (libfunc = optab_libfunc (code_to_optab (comparison), mode)))\n \tbreak;\n \n-      if (code_to_optab[swapped]\n-\t  && (libfunc = optab_libfunc (code_to_optab[swapped], mode)))\n+      if (code_to_optab (swapped)\n+\t  && (libfunc = optab_libfunc (code_to_optab (swapped), mode)))\n \t{\n \t  rtx tmp;\n \t  tmp = x; x = y; y = tmp;\n \t  comparison = swapped;\n \t  break;\n \t}\n \n-      if (code_to_optab[reversed]\n-\t  && (libfunc = optab_libfunc (code_to_optab[reversed], mode)))\n+      if (code_to_optab (reversed)\n+\t  && (libfunc = optab_libfunc (code_to_optab (reversed), mode)))\n \t{\n \t  comparison = reversed;\n \t  reversed_p = true;\n@@ -5355,7 +5357,7 @@ expand_fixed_convert (rtx to, rtx from, int uintp, int satp)\n   end_sequence ();\n \n   emit_libcall_block (insns, to, value,\n-\t\t      gen_rtx_fmt_e (tab->code, to_mode, from));\n+\t\t      gen_rtx_fmt_e (optab_to_code (tab), to_mode, from));\n }\n \n /* Generate code to convert FROM to fixed point and store in TO.  FROM\n@@ -5408,8 +5410,8 @@ expand_sfix_optab (rtx to, rtx from, convert_optab tab)\n int\n have_insn_for (enum rtx_code code, enum machine_mode mode)\n {\n-  return (code_to_optab[(int) code] != 0\n-\t  && (optab_handler (code_to_optab[(int) code], mode)\n+  return (code_to_optab (code)\n+\t  && (optab_handler (code_to_optab (code), mode)\n \t      != CODE_FOR_nothing));\n }\n \n@@ -5427,23 +5429,23 @@ init_insn_codes (void)\n static inline void\n init_optab (optab op, enum rtx_code code)\n {\n-  op->code = code;\n-  code_to_optab[(int) code] = op;\n+  op->code_ = code;\n+  code_to_optab_[(int) code] = op;\n }\n \n /* Same, but fill in its code as CODE, and do _not_ write it into\n    the code_to_optab table.  */\n static inline void\n init_optabv (optab op, enum rtx_code code)\n {\n-  op->code = code;\n+  op->code_ = code;\n }\n \n /* Conversion optabs never go in the code_to_optab table.  */\n static void\n init_convert_optab (convert_optab op, enum rtx_code code)\n {\n-  op->code = code;\n+  op->code_ = code;\n }\n \n /* Initialize the libfunc fields of an entire group of entries in some\n@@ -6701,7 +6703,7 @@ debug_optab_libfuncs (void)\n \t  {\n \t    gcc_assert (GET_CODE (l) == SYMBOL_REF);\n \t    fprintf (stderr, \"%s\\t%s:\\t%s\\n\",\n-\t\t     GET_RTX_NAME (o->code),\n+\t\t     GET_RTX_NAME (optab_to_code (o)),\n \t\t     GET_MODE_NAME (j),\n \t\t     XSTR (l, 0));\n \t  }\n@@ -6722,7 +6724,7 @@ debug_optab_libfuncs (void)\n \t    {\n \t      gcc_assert (GET_CODE (l) == SYMBOL_REF);\n \t      fprintf (stderr, \"%s\\t%s\\t%s:\\t%s\\n\",\n-\t\t       GET_RTX_NAME (o->code),\n+\t\t       GET_RTX_NAME (optab_to_code (o)),\n \t\t       GET_MODE_NAME (j),\n \t\t       GET_MODE_NAME (k),\n \t\t       XSTR (l, 0));"}, {"sha": "60f83cff8a5e9a83fae5a81a3d4a153d7fea8090", "filename": "gcc/optabs.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b5fafb92343ca3f1449f3ba6fe5e2b9318496f/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=19b5fafb92343ca3f1449f3ba6fe5e2b9318496f", "patch": "@@ -50,7 +50,7 @@ struct widening_optab_handlers\n \n struct optab_d\n {\n-  enum rtx_code code;\n+  enum rtx_code code_;\n   char libcall_suffix;\n   const char *libcall_basename;\n   void (*libcall_gen)(struct optab_d *, const char *name, char suffix,\n@@ -65,7 +65,7 @@ typedef struct optab_d * optab;\n    is the source mode.  */\n struct convert_optab_d\n {\n-  enum rtx_code code;\n+  enum rtx_code code_;\n   const char *libcall_basename;\n   void (*libcall_gen)(struct convert_optab_d *, const char *name,\n \t\t      enum machine_mode,\n@@ -671,7 +671,15 @@ enum convert_optab_index\n #define vcondu_optab (&convert_optab_table[(int) COI_vcondu])\n \n /* Contains the optab used for each rtx code.  */\n-extern optab code_to_optab[NUM_RTX_CODE + 1];\n+extern optab code_to_optab_[NUM_RTX_CODE + 1];\n+\n+static inline optab\n+code_to_optab (enum rtx_code code)\n+{\n+  return code_to_optab_[code];\n+}\n+\n+#define optab_to_code(op)\t((op)->code_)\n \n \f\n typedef rtx (*rtxfun) (rtx);"}]}