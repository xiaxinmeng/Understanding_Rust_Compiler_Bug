{"sha": "f18590c6209457736eda5e66c76c33e3f92532fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE4NTkwYzYyMDk0NTc3MzZlZGE1ZTY2Yzc2YzMzZTNmOTI1MzJmZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-11-10T22:06:49Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-11-10T22:06:49Z"}, "message": "Externalizable.java, [...]: New versions from Classpath.\n\n\t* java/io/Externalizable.java, java/io/FilePermission.java,\n\tjava/io/ObjectStreamConstants.java, java/io/Serializable.java,\n\tjava/io/SerializablePermission.java, java/text/Format.java,\n\tjava/util/AbstractMap.java, java/util/HashMap.java,\n\tjava/util/LinkedHashMap.java, javax/naming/BinaryRefAddr.java: New\n\tversions from Classpath.\n\nFrom-SVN: r58996", "tree": {"sha": "b99c34071ce1e42a9742123fef03b7f802acd754", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b99c34071ce1e42a9742123fef03b7f802acd754"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f18590c6209457736eda5e66c76c33e3f92532fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f18590c6209457736eda5e66c76c33e3f92532fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f18590c6209457736eda5e66c76c33e3f92532fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f18590c6209457736eda5e66c76c33e3f92532fd/comments", "author": null, "committer": null, "parents": [{"sha": "99c49d11c10224de2364fc1d56039f8ff5899d0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c49d11c10224de2364fc1d56039f8ff5899d0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99c49d11c10224de2364fc1d56039f8ff5899d0f"}], "stats": {"total": 315, "additions": 176, "deletions": 139}, "files": [{"sha": "891c9ace1dd5d700fdc3e007745131d659be1708", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f18590c6209457736eda5e66c76c33e3f92532fd", "patch": "@@ -1,3 +1,12 @@\n+2002-11-10  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/io/Externalizable.java, java/io/FilePermission.java,\n+\tjava/io/ObjectStreamConstants.java, java/io/Serializable.java,\n+\tjava/io/SerializablePermission.java, java/text/Format.java,\n+\tjava/util/AbstractMap.java, java/util/HashMap.java,\n+\tjava/util/LinkedHashMap.java, javax/naming/BinaryRefAddr.java: New\n+\tversions from Classpath.\n+\n 2002-11-10  Anthony Green  <green@redhat.com>\n \n \t* java/util/jar/Attributes.java (Name): Fix name check."}, {"sha": "83f1b653ec56c2a7f1e3eb00052179da047ddddb", "filename": "libjava/java/io/Externalizable.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Fio%2FExternalizable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Fio%2FExternalizable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FExternalizable.java?ref=f18590c6209457736eda5e66c76c33e3f92532fd", "patch": "@@ -62,6 +62,7 @@\n   */\n public interface Externalizable extends Serializable\n {\n+  static final long serialVersionUID = -282491828744381764L;\n \n /**\n   * This method restores an object's state by reading in the instance data"}, {"sha": "0fc06c91473c866caeaedfb147768e3dc98f33d9", "filename": "libjava/java/io/FilePermission.java", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Fio%2FFilePermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Fio%2FFilePermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilePermission.java?ref=f18590c6209457736eda5e66c76c33e3f92532fd", "patch": "@@ -41,7 +41,10 @@\n import java.security.*;\n \n \n-public final class FilePermission extends Permission implements Serializable {\n+public final class FilePermission extends Permission implements Serializable\n+{\n+  static final long serialVersionUID = 7930732926638008763L;\n+\n   private static final String CURRENT_DIRECTORY = System.getProperty(\"user.dir\");\n   private boolean usingPerms = false;\n   private boolean readPerm = false;"}, {"sha": "980b04de2647dcbee8179cd0b32abc79079e017f", "filename": "libjava/java/io/ObjectStreamConstants.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Fio%2FObjectStreamConstants.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Fio%2FObjectStreamConstants.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamConstants.java?ref=f18590c6209457736eda5e66c76c33e3f92532fd", "patch": "@@ -70,7 +70,7 @@\n   final static byte TC_PROXYCLASSDESC = (byte)125;  //0x7D\n \n   final static byte TC_BASE = TC_NULL;\n-  final static byte TC_MAX = TC_EXCEPTION;\n+  final static byte TC_MAX = TC_PROXYCLASSDESC;\n \n   final static int baseWireHandle = 0x7e0000;\n "}, {"sha": "0d6310ce3403c3c09cc8bf3b89c2eeceef03f4b4", "filename": "libjava/java/io/Serializable.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Fio%2FSerializable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Fio%2FSerializable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FSerializable.java?ref=f18590c6209457736eda5e66c76c33e3f92532fd", "patch": "@@ -51,4 +51,5 @@\n   */\n public interface Serializable\n {\n+  static final long serialVersionUID = 1196656838076753133L;\n } // interface Serializable"}, {"sha": "d9dc3dd924ae1f819f6bf05730bd69f9244a8712", "filename": "libjava/java/io/SerializablePermission.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Fio%2FSerializablePermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Fio%2FSerializablePermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FSerializablePermission.java?ref=f18590c6209457736eda5e66c76c33e3f92532fd", "patch": "@@ -61,7 +61,8 @@\n   */\n public final class SerializablePermission extends BasicPermission\n {\n-\n+  static final long serialVersionUID = 8537212141160296410L;\n+\t\n /*\n  * Class Variables\n  */"}, {"sha": "804ef43ff29cb7020c28b9f0f0fec37bc451e4e2", "filename": "libjava/java/text/Format.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Ftext%2FFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Ftext%2FFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FFormat.java?ref=f18590c6209457736eda5e66c76c33e3f92532fd", "patch": "@@ -59,6 +59,8 @@\n  */\n public abstract class Format implements Serializable, Cloneable\n {\n+  static final long serialVersionUID = -299282585814624189L;\n+\n   /**\n    * This method initializes a new instance of <code>Format</code>.\n    * It performs no actions, but acts as a default constructor for"}, {"sha": "4be5f3dbd942605dbced7039b9ab6057de8a2289", "filename": "libjava/java/util/AbstractMap.java", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Futil%2FAbstractMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Futil%2FAbstractMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractMap.java?ref=f18590c6209457736eda5e66c76c33e3f92532fd", "patch": "@@ -466,6 +466,11 @@ public int size()\n           return AbstractMap.this.size();\n         }\n \n+        public boolean contains(Object value)\n+        {\n+          return containsValue(value);\n+        }\n+\n         public Iterator iterator()\n         {\n           return new Iterator()\n@@ -527,8 +532,9 @@ static final int hashCode(Object o)\n    * @author Jon Zeppieri\n    * @author Eric Blake <ebb9@email.byu.edu>\n    */\n+  // XXX - FIXME Use fully qualified implements as gcj 3.1 workaround.\n   static class BasicMapEntry implements Map.Entry\n-  {\t// XXX - FIXME Use fully qualified implements as gcj 3.1 workaround.\n+  {\n     /**\n      * The key. Package visible for direct manipulation.\n      */\n@@ -553,16 +559,14 @@ static class BasicMapEntry implements Map.Entry\n     /**\n      * Compares the specified object with this entry. Returns true only if\n      * the object is a mapping of identical key and value. In other words,\n-     * this must be:\n-     * \n-<pre>(o instanceof Map.Entry) &&\n-(getKey() == null ? ((HashMap) o).getKey() == null\n-                  : getKey().equals(((HashMap) o).getKey())) &&\n-(getValue() == null ? ((HashMap) o).getValue() == null\n-                    : getValue().equals(((HashMap) o).getValue()))</pre>\n+     * this must be:<br>\n+     * <pre>(o instanceof Map.Entry)\n+     *       && (getKey() == null ? ((HashMap) o).getKey() == null\n+     *           : getKey().equals(((HashMap) o).getKey()))\n+     *       && (getValue() == null ? ((HashMap) o).getValue() == null\n+     *           : getValue().equals(((HashMap) o).getValue()))</pre>\n      *\n      * @param o the object to compare\n-     *\n      * @return <code>true</code> if it is equal\n      */\n     public final boolean equals(Object o)\n@@ -605,10 +609,9 @@ public final Object getValue()\n     /**\n      * Returns the hash code of the entry.  This is defined as the exclusive-or\n      * of the hashcodes of the key and value (using 0 for null). In other\n-     * words, this must be:\n-     * \n-<pre>(getKey() == null ? 0 : getKey().hashCode())\n-^ (getValue() == null ? 0 : getValue().hashCode())</pre>\n+     * words, this must be:<br>\n+     * <pre>(getKey() == null ? 0 : getKey().hashCode())\n+     *       ^ (getValue() == null ? 0 : getValue().hashCode())</pre>\n      *\n      * @return the hash code\n      */"}, {"sha": "9faca0339d1ab6808523b08a53e007d058dee4d9", "filename": "libjava/java/util/HashMap.java", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Futil%2FHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Futil%2FHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashMap.java?ref=f18590c6209457736eda5e66c76c33e3f92532fd", "patch": "@@ -179,6 +179,15 @@ static class HashEntry extends AbstractMap.BasicMapEntry\n       super(key, value);\n     }\n \n+    /**\n+     * Called when this entry is accessed via {@link #put(Object, Object)}.\n+     * This version does nothing, but in LinkedHashMap, it must do some\n+     * bookkeeping for access-traversal mode.\n+     */\n+    void access()\n+    {\n+    }\n+\n     /**\n      * Called when this entry is removed from the map. This version simply\n      * returns the value, but in LinkedHashMap, it must also do bookkeeping.\n@@ -338,8 +347,12 @@ public Object put(Object key, Object value)\n     while (e != null)\n       {\n         if (equals(key, e.key))\n-          // Must use this method for necessary bookkeeping in LinkedHashMap.\n-          return e.setValue(value);\n+          {\n+            e.access(); // Must call this for bookkeeping in LinkedHashMap.\n+            Object r = e.value;\n+            e.value = value;\n+            return r;\n+          }\n         else\n           e = e.next;\n       }\n@@ -368,8 +381,8 @@ public Object put(Object key, Object value)\n   public void putAll(Map m)\n   {\n     Iterator itr = m.entrySet().iterator();\n-\n-    for (int msize = m.size(); msize > 0; msize--)\n+    int msize = m.size();\n+    while (msize-- > 0)\n       {\n         Map.Entry e = (Map.Entry) itr.next();\n         // Optimize in case the Entry is one of our own.\n@@ -379,9 +392,7 @@ public void putAll(Map m)\n             put(entry.key, entry.value);\n           }\n         else\n-          {\n-            put(e.getKey(), e.getValue());\n-          }\n+          put(e.getKey(), e.getValue());\n       }\n   }\n   \n@@ -520,7 +531,7 @@ public boolean contains(Object o)\n         public boolean remove(Object o)\n         {\n           // Test against the size of the HashMap to determine if anything\n-          // really got removed. This is neccessary because the return value\n+          // really got removed. This is necessary because the return value\n           // of HashMap.remove() is ambiguous in the null case.\n           int oldsize = size;\n           HashMap.this.remove(o);\n@@ -634,7 +645,6 @@ public boolean remove(Object o)\n   void addEntry(Object key, Object value, int idx, boolean callRemove)\n   {\n     HashEntry e = new HashEntry(key, value);\n-\n     e.next = buckets[idx];\n     buckets[idx] = e;\n   }\n@@ -648,17 +658,18 @@ void addEntry(Object key, Object value, int idx, boolean callRemove)\n    * @see #entrySet()\n    */\n   // Package visible, for use in nested classes.\n-  HashEntry getEntry(Object o)\n+  final HashEntry getEntry(Object o)\n   {\n-    if (!(o instanceof Map.Entry))\n+    if (! (o instanceof Map.Entry))\n       return null;\n     Map.Entry me = (Map.Entry) o;\n-    int idx = hash(me.getKey());\n+    Object key = me.getKey();\n+    int idx = hash(key);\n     HashEntry e = buckets[idx];\n     while (e != null)\n       {\n-        if (e.equals(me))\n-          return e;\n+        if (equals(e.key, key))\n+          return equals(e.value, me.getValue()) ? e : null;\n         e = e.next;\n       }\n     return null;\n@@ -699,9 +710,8 @@ void putAllInternal(Map m)\n   {\n     Iterator itr = m.entrySet().iterator();\n     int msize = m.size();\n-    this.size = msize;\n-\n-    for (; msize > 0; msize--)\n+    size = msize;\n+    while (msize-- > 0)\n       {\n \tMap.Entry e = (Map.Entry) itr.next();\n \tObject key = e.getKey();\n@@ -742,9 +752,7 @@ private void rehash()\n                 dest.next = e;\n               }\n             else\n-              {\n-                buckets[idx] = e;\n-              }\n+              buckets[idx] = e;\n \n             HashEntry next = e.next;\n             e.next = null;\n@@ -797,13 +805,14 @@ private void readObject(ObjectInputStream s)\n     // Read the threshold and loadFactor fields.\n     s.defaultReadObject();\n \n-    // Read and use capacity.\n+    // Read and use capacity, followed by key/value pairs.\n     buckets = new HashEntry[s.readInt()];\n     int len = s.readInt();\n-\n-    // Read and use key/value pairs.\n-    for ( ; len > 0; len--)\n-      put(s.readObject(), s.readObject());\n+    while (len-- > 0)\n+      {\n+        Object key = s.readObject();\n+        addEntry(key, s.readObject(), hash(key), false);\n+      }\n   }\n \n   /**"}, {"sha": "0a8484bae8867a8d79d54eb29abdbac0d56229b7", "filename": "libjava/java/util/LinkedHashMap.java", "status": "modified", "additions": 105, "deletions": 97, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Futil%2FLinkedHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjava%2Futil%2FLinkedHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLinkedHashMap.java?ref=f18590c6209457736eda5e66c76c33e3f92532fd", "patch": "@@ -1,6 +1,6 @@\n /* LinkedHashMap.java -- a class providing hashtable data structure,\n    mapping Object --> Object, with linked list traversal\n-   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -50,8 +50,17 @@\n  * can cause primary clustering) and rehashing (which does not fit very\n  * well with Java's method of precomputing hash codes) are avoided.  In\n  * addition, this maintains a doubly-linked list which tracks either\n- * insertion or access order.  Note that the insertion order is not\n- * modified if a <code>put</code> simply reinserts a key in the map.\n+ * insertion or access order.\n+ * <p>\n+ *\n+ * In insertion order, calling <code>put</code> adds the key to the end of\n+ * traversal, unless the key was already in the map; changing traversal order\n+ * requires removing and reinserting a key.  On the other hand, in access\n+ * order, all calls to <code>put</code> and <code>get</code> cause the\n+ * accessed key to move to the end of the traversal list.  Note that any\n+ * accesses to the map's contents via its collection views and iterators do\n+ * not affect the map's traversal order, since the collection views do not\n+ * call <code>put</code> or <code>get</code>.\n  * <p>\n  *\n  * One of the nice features of tracking insertion order is that you can\n@@ -61,19 +70,19 @@\n  * <p>\n  *\n  * When using this {@link #LinkedHashMap(int, float, boolean) constructor},\n- * you build an access-order mapping.  This can be used to implement LRU\n- * caches, for example.  In this case, every invocation of <code>put</code>,\n- * <code>putAll</code>, or <code>get</code> moves the accessed entry to\n- * the end of the iteration list.  By overriding\n- * {@link #removeEldestEntry(Map.Entry)}, you can also control the\n- * removal of the oldest entry, and thereby do things like keep the map\n- * at a fixed size.\n+ * you can build an access-order mapping.  This can be used to implement LRU\n+ * caches, for example.  By overriding {@link #removeEldestEntry(Map.Entry)},\n+ * you can also control the removal of the oldest entry, and thereby do\n+ * things like keep the map at a fixed size.\n  * <p>\n  *\n  * Under ideal circumstances (no collisions), LinkedHashMap offers O(1) \n  * performance on most operations (<code>containsValue()</code> is,\n  * of course, O(n)).  In the worst case (all keys map to the same \n- * hash code -- very unlikely), most operations are O(n).\n+ * hash code -- very unlikely), most operations are O(n).  Traversal is\n+ * faster than in HashMap (proportional to the map size, and not the space\n+ * allocated for the map), but other operations may be slower because of the\n+ * overhead of the maintaining the traversal order list.\n  * <p>\n  *\n  * LinkedHashMap accepts the null key and null values.  It is not\n@@ -105,19 +114,15 @@ public class LinkedHashMap extends HashMap\n   private static final long serialVersionUID = 3801124242820219131L;\n \n   /**\n-   * The first Entry to iterate over.\n-   */\n-  transient LinkedHashEntry head;\n-\n-  /**\n-   * The last Entry to iterate over.\n+   * The oldest Entry to begin iteration at.\n    */\n-  transient LinkedHashEntry tail;\n+  transient LinkedHashEntry root;\n \n   /**\n    * The iteration order of this linked hash map: <code>true</code> for\n    * access-order, <code>false</code> for insertion-order.\n-   * @serial\n+   *\n+   * @serial true for access order traversal\n    */\n   final boolean accessOrder;\n \n@@ -127,69 +132,91 @@ public class LinkedHashMap extends HashMap\n    */\n   class LinkedHashEntry extends HashEntry\n   {\n-    /** The predecessor in the iteration list, null if this is the eldest. */\n+    /**\n+     * The predecessor in the iteration list. If this entry is the root\n+     * (eldest), pred points to the newest entry.\n+     */\n     LinkedHashEntry pred;\n+\n     /** The successor in the iteration list, null if this is the newest. */\n     LinkedHashEntry succ;\n \n     /**\n      * Simple constructor.\n+     *\n      * @param key the key\n      * @param value the value\n      */\n     LinkedHashEntry(Object key, Object value)\n     {\n       super(key, value);\n-      if (head == null)\n-        head = this;\n-      pred = tail;\n-      tail = this;\n-      if (pred != null)\n-        pred.succ = this;\n+      if (root == null)\n+        {\n+          root = this;\n+          pred = this;\n+        }\n+      else\n+        {\n+          pred = root.pred;\n+          pred.succ = this;\n+          root.pred = this;\n+        }\n     }\n \n     /**\n-     * Sets the value of this entry, and shuffles it to the end of\n-     * the list if this is in access-order.\n-     * @param value the new value\n-     * @return the prior value\n+     * Called when this entry is accessed via put or get. This version does\n+     * the necessary bookkeeping to keep the doubly-linked list in order,\n+     * after moving this element to the newest position in access order.\n      */\n-    public Object setValue(Object value)\n+    void access()\n     {\n       if (accessOrder && succ != null)\n         {\n-          succ.pred = pred;\n-          if (pred == null)\n-            head = succ;\n+          modCount++;\n+          if (this == root)\n+            {\n+              root = succ;\n+              pred.succ = this;\n+              succ = null;\n+            }\n           else\n-            pred.succ = succ;\n-          succ = null;\n-          pred = tail;\n-          pred.succ = this;\n-          tail = this;\n+            {\n+              pred.succ = succ;\n+              succ.pred = pred;\n+              succ = null;\n+              pred = root.pred;\n+              pred.succ = this;\n+            }\n         }\n-      return super.setValue(value);\n     }\n \n     /**\n      * Called when this entry is removed from the map. This version does\n      * the necessary bookkeeping to keep the doubly-linked list in order.\n+     *\n      * @return the value of this key as it is removed\n      */\n     Object cleanup()\n     {\n-      if (pred == null)\n-        head = succ;\n-      else\n-        pred.succ = succ;\n-      if (succ == null)\n-        tail = pred;\n+      if (this == root)\n+        {\n+          root = succ;\n+          if (succ != null)\n+            succ.pred = pred;\n+        }\n+      else if (succ == null)\n+        {\n+          pred.succ = null;\n+          root.pred = pred;\n+        }\n       else\n-        succ.pred = pred;\n-      \n+        {\n+          pred.succ = succ;\n+          succ.pred = pred;\n+        }\n       return value;\n     }\n-  }\n+  } // class LinkedHashEntry\n \n   /**\n    * Construct a new insertion-ordered LinkedHashMap with the default\n@@ -253,10 +280,9 @@ public LinkedHashMap(int initialCapacity, float loadFactor)\n    * Construct a new LinkedHashMap with a specific inital capacity, load\n    * factor, and ordering mode.\n    *\n-   * @param initialCapacity the initial capacity (>=0)\n-   * @param loadFactor the load factor (>0, not NaN)\n+   * @param initialCapacity the initial capacity (&gt;=0)\n+   * @param loadFactor the load factor (&gt;0, not NaN)\n    * @param accessOrder true for access-order, false for insertion-order\n-   *\n    * @throws IllegalArgumentException if (initialCapacity &lt; 0) ||\n    *                                     ! (loadFactor &gt; 0.0)\n    */\n@@ -273,21 +299,19 @@ public LinkedHashMap(int initialCapacity, float loadFactor,\n   public void clear()\n   {\n     super.clear();\n-    head = null;\n-    tail = null;\n+    root = null;\n   }\n \n   /**\n    * Returns <code>true</code> if this HashMap contains a value\n    * <code>o</code>, such that <code>o.equals(value)</code>.\n    *\n    * @param value the value to search for in this HashMap\n-   *\n    * @return <code>true</code> if at least one key maps to the value\n    */\n   public boolean containsValue(Object value)\n   {\n-    LinkedHashEntry e = head;\n+    LinkedHashEntry e = root;\n     while (e != null)\n       {\n         if (equals(value, e.value))\n@@ -318,23 +342,7 @@ public Object get(Object key)\n       {\n         if (equals(key, e.key))\n           {\n-            if (accessOrder)\n-              {\n-                modCount++;\n-                LinkedHashEntry l = (LinkedHashEntry) e;\n-                if (l.succ != null)\n-                  {\n-                    l.succ.pred = l.pred;\n-                    if (l.pred == null)\n-                      head = l.succ;\n-                    else\n-                      l.pred.succ = l.succ;\n-                    l.succ = null;\n-                    l.pred = tail;\n-                    tail.succ = l;\n-                    tail = l;\n-                  }\n-              }\n+            e.access();\n             return e.value;\n           }\n         e = e.next;\n@@ -352,20 +360,21 @@ public Object get(Object key)\n    * <p>\n    *\n    * For example, to keep the Map limited to 100 entries, override as follows:\n-   * \n-<pre>private static final int MAX_ENTRIES = 100;\n-\n-protected boolean removeEldestEntry(Map.Entry eldest)\n-{\n-  return size() &gt; MAX_ENTRIES;\n-}\n-</pre><p>\n+   * <pre>\n+   * private static final int MAX_ENTRIES = 100;\n+   * protected boolean removeEldestEntry(Map.Entry eldest)\n+   * {\n+   *   return size() &gt; MAX_ENTRIES;\n+   * }\n+   * </pre><p>\n    *\n    * Typically, this method does not modify the map, but just uses the\n    * return value as an indication to <code>put</code> whether to proceed.\n    * However, if you override it to modify the map, you must return false\n-   * (indicating that <code>put</code> should do nothing), or face\n-   * unspecified behavior.\n+   * (indicating that <code>put</code> should leave the modified map alone),\n+   * or you face unspecified behavior.  Remember that in access-order mode,\n+   * even calling <code>get</code> is a structural modification, but using\n+   * the collections views (such as <code>keySet</code>) is not.\n    * <p>\n    *\n    * This method is called after the eldest entry has been inserted, so\n@@ -378,7 +387,6 @@ protected boolean removeEldestEntry(Map.Entry eldest)\n    *        returns true. For an access-order map, this is the least\n    *        recently accessed; for an insertion-order map, this is the\n    *        earliest element inserted.\n-   *\n    * @return true if <code>eldest</code> should be removed\n    */\n   protected boolean removeEldestEntry(Map.Entry eldest)\n@@ -396,51 +404,52 @@ protected boolean removeEldestEntry(Map.Entry eldest)\n    * @param callRemove whether to call the removeEldestEntry method\n    * @see #put(Object, Object)\n    * @see #removeEldestEntry(Map.Entry)\n+   * @see LinkedHashEntry#LinkedHashEntry(Object, Object)\n    */\n   void addEntry(Object key, Object value, int idx, boolean callRemove)\n   {\n     LinkedHashEntry e = new LinkedHashEntry(key, value);\n-\n     e.next = buckets[idx];\n     buckets[idx] = e;\n-\n-    if (callRemove && removeEldestEntry(head))\n-      remove(head);\n+    if (callRemove && removeEldestEntry(root))\n+      remove(root);\n   }\n \n   /**\n    * Helper method, called by clone() to reset the doubly-linked list.\n+   *\n    * @param m the map to add entries from\n    * @see #clone()\n    */\n   void putAllInternal(Map m)\n   {\n-    head = null;\n-    tail = null;\n+    root = null;\n     super.putAllInternal(m);\n   }\n \n   /**\n    * Generates a parameterized iterator. This allows traversal to follow\n    * the doubly-linked list instead of the random bin order of HashMap.\n+   *\n    * @param type {@link #KEYS}, {@link #VALUES}, or {@link #ENTRIES}\n    * @return the appropriate iterator\n    */\n   Iterator iterator(final int type)\n   {\n     return new Iterator()\n     {\n-      /** The current Entry */\n-      LinkedHashEntry current = head;\n+      /** The current Entry. */\n+      LinkedHashEntry current = root;\n \n-      /** The previous Entry returned by next() */\n+      /** The previous Entry returned by next(). */\n       LinkedHashEntry last;\n \n-      /** The number of known modifications to the backing HashMap */\n+      /** The number of known modifications to the backing Map. */\n       int knownMod = modCount;\n \n       /**\n        * Returns true if the Iterator has more elements.\n+       *\n        * @return true if there are more elements\n        * @throws ConcurrentModificationException if the HashMap was modified\n        */\n@@ -453,6 +462,7 @@ public boolean hasNext()\n \n       /**\n        * Returns the next element in the Iterator's sequential view.\n+       *\n        * @return the next element\n        * @throws ConcurrentModificationException if the HashMap was modified\n        * @throws NoSuchElementException if there is none\n@@ -473,7 +483,6 @@ public Object next()\n        * with the <code>next()</code> method.\n        *\n        * @throws ConcurrentModificationException if the HashMap was modified\n-       *\n        * @throws IllegalStateException if called when there is no last element\n        */\n       public void remove()\n@@ -482,11 +491,10 @@ public void remove()\n           throw new ConcurrentModificationException();\n         if (last == null)\n           throw new IllegalStateException();\n-\n         LinkedHashMap.this.remove(last.key);\n         last = null;\n         knownMod++;\n       }\n     };\n   }\n-}\n+} // class LinkedHashMap"}, {"sha": "793552a9e653f4e422f9ac94a0436e21ff88f994", "filename": "libjava/javax/naming/BinaryRefAddr.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjavax%2Fnaming%2FBinaryRefAddr.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f18590c6209457736eda5e66c76c33e3f92532fd/libjava%2Fjavax%2Fnaming%2FBinaryRefAddr.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnaming%2FBinaryRefAddr.java?ref=f18590c6209457736eda5e66c76c33e3f92532fd", "patch": "@@ -51,7 +51,7 @@\n public class BinaryRefAddr extends RefAddr\n {\n   static final long serialVersionUID = -3415254970957330361L;\n-\n+\t\n   /**\n    * The possibly null content of this RefAddr.\n    * Set by the constructor and returned by getContent."}]}