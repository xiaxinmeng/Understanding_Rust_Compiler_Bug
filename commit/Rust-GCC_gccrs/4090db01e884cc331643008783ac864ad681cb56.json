{"sha": "4090db01e884cc331643008783ac864ad681cb56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA5MGRiMDFlODg0Y2MzMzE2NDMwMDg3ODNhYzg2NGFkNjgxY2I1Ng==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2006-11-27T08:10:23Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2006-11-27T08:10:23Z"}, "message": "re PR tree-optimization/22372 (Vectorizer produces mis-match types)\n\n\tPR tree-optimization/22372\n\t* tree-vect-transform.c (vect_create_addr_base_for_vector_ref): Convert\n\tthe type of the base address.\n\t(vect_create_data_ref_ptr): Add an argument, type of the data-ref. Use\n\tit in the data-ref pointer creation.\n\t(vect_init_vector): Add an argument, type of the init vector. Use it in\n\tthe stmt creation.\n\t(vect_get_vec_def_for_operand): Fix calls to vect_init_vector.\n\t(get_initial_def_for_reduction): Likewise.\n\t(vect_create_epilog_for_reduction): Change type of MODIFY_EXPR to\n\tvoid_type_node.\n\t(vectorizable_assignment, vect_permute_store_chain): Likewise.\n\t(vectorizable_store): Fix call to vect_create_data_ref_ptr. Use the\n\tcorrect type in stmt creation.\n\t(vect_setup_realignment): Use the correct type in stmt creation.\n\t(vect_permute_load_chain): Change type of MODIFY_EXPR to\n\tvoid_type_node.\n\t(vectorizable_load): Fix calls to vect_create_data_ref_ptr. Change type\n\tof MODIFY_EXPR to void_type_node.\n\t(vectorizable_condition): Change type of MODIFY_EXPR to\n\tvoid_type_node.\n\t(vect_update_ivs_after_vectorizer): Use the correct type in stmt\n\tcreation.\n\nFrom-SVN: r119247", "tree": {"sha": "cec3fd9bedde26db55e559acea9ad9cba329bfb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cec3fd9bedde26db55e559acea9ad9cba329bfb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4090db01e884cc331643008783ac864ad681cb56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4090db01e884cc331643008783ac864ad681cb56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4090db01e884cc331643008783ac864ad681cb56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4090db01e884cc331643008783ac864ad681cb56/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ce7d4645bb1e1610a0f2a34928f22f277d1f5d24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce7d4645bb1e1610a0f2a34928f22f277d1f5d24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce7d4645bb1e1610a0f2a34928f22f277d1f5d24"}], "stats": {"total": 152, "additions": 96, "deletions": 56}, "files": [{"sha": "316ead1a4772587c03d8a1bca8a38ca42f3d2181", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4090db01e884cc331643008783ac864ad681cb56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4090db01e884cc331643008783ac864ad681cb56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4090db01e884cc331643008783ac864ad681cb56", "patch": "@@ -1,3 +1,29 @@\n+2006-11-27  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/22372\n+\t* tree-vect-transform.c (vect_create_addr_base_for_vector_ref): Convert\n+\tthe type of the base address.\n+\t(vect_create_data_ref_ptr): Add an argument, type of the data-ref. Use\n+\tit in the data-ref pointer creation.\n+\t(vect_init_vector): Add an argument, type of the init vector. Use it in\n+\tthe stmt creation.\n+\t(vect_get_vec_def_for_operand): Fix calls to vect_init_vector.\n+\t(get_initial_def_for_reduction): Likewise.\n+\t(vect_create_epilog_for_reduction): Change type of MODIFY_EXPR to\n+\tvoid_type_node.\n+\t(vectorizable_assignment, vect_permute_store_chain): Likewise.\n+\t(vectorizable_store): Fix call to vect_create_data_ref_ptr. Use the\n+\tcorrect type in stmt creation.\n+\t(vect_setup_realignment): Use the correct type in stmt creation.\n+\t(vect_permute_load_chain): Change type of MODIFY_EXPR to\n+\tvoid_type_node.\n+\t(vectorizable_load): Fix calls to vect_create_data_ref_ptr. Change type\n+\tof MODIFY_EXPR to void_type_node.\n+\t(vectorizable_condition): Change type of MODIFY_EXPR to\n+\tvoid_type_node.\n+\t(vect_update_ivs_after_vectorizer): Use the correct type in stmt\n+\tcreation.\n+\n 2006-11-27  Uros Bizjak  <ubizjak@gmail.com>\n \n \tRevert:"}, {"sha": "b2771bbf77c547abf5f669384ffdc9c4ebbf038c", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 70, "deletions": 56, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4090db01e884cc331643008783ac864ad681cb56/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4090db01e884cc331643008783ac864ad681cb56/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=4090db01e884cc331643008783ac864ad681cb56", "patch": "@@ -49,12 +49,12 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n static bool vect_transform_stmt (tree, block_stmt_iterator *, bool *);\n static tree vect_create_destination_var (tree, tree);\n static tree vect_create_data_ref_ptr \n-  (tree, block_stmt_iterator *, tree, tree *, tree *, bool); \n+  (tree, block_stmt_iterator *, tree, tree *, tree *, bool, tree); \n static tree vect_create_addr_base_for_vector_ref (tree, tree *, tree);\n static tree vect_setup_realignment (tree, block_stmt_iterator *, tree *);\n static tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n static tree vect_get_vec_def_for_operand (tree, tree, tree *);\n-static tree vect_init_vector (tree, tree);\n+static tree vect_init_vector (tree, tree, tree);\n static void vect_finish_stmt_generation \n   (tree stmt, tree vec_stmt, block_stmt_iterator *bsi);\n static bool vect_is_simple_cond (tree, loop_vec_info); \n@@ -137,15 +137,12 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree data_ref_base = unshare_expr (DR_BASE_ADDRESS (dr));\n   tree base_name = build_fold_indirect_ref (data_ref_base);\n-  tree ref = DR_REF (dr);\n-  tree scalar_type = TREE_TYPE (ref);\n-  tree scalar_ptr_type = build_pointer_type (scalar_type);\n   tree vec_stmt;\n-  tree new_temp;\n   tree addr_base, addr_expr;\n   tree dest, new_stmt;\n   tree base_offset = unshare_expr (DR_OFFSET (dr));\n   tree init = unshare_expr (DR_INIT (dr));\n+  tree vect_ptr_type, addr_expr2;\n \n   /* Create base_offset */\n   base_offset = size_binop (PLUS_EXPR, base_offset, init);\n@@ -180,21 +177,25 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   addr_base = fold_build2 (PLUS_EXPR, TREE_TYPE (data_ref_base), data_ref_base,\n \t\t\t   base_offset);\n \n+  vect_ptr_type = build_pointer_type (STMT_VINFO_VECTYPE (stmt_info));\n+\n   /* addr_expr = addr_base */\n-  addr_expr = vect_get_new_vect_var (scalar_ptr_type, vect_pointer_var,\n+  addr_expr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n                                      get_name (base_name));\n   add_referenced_var (addr_expr);\n-  vec_stmt = build2 (MODIFY_EXPR, void_type_node, addr_expr, addr_base);\n-  new_temp = make_ssa_name (addr_expr, vec_stmt);\n-  TREE_OPERAND (vec_stmt, 0) = new_temp;\n-  append_to_statement_list_force (vec_stmt, new_stmt_list);\n+  vec_stmt = fold_convert (vect_ptr_type, addr_base);\n+  addr_expr2 = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n+                                     get_name (base_name));\n+  add_referenced_var (addr_expr2);\n+  vec_stmt = force_gimple_operand (vec_stmt, &new_stmt, false, addr_expr2);\n+  append_to_statement_list_force (new_stmt, new_stmt_list);\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"created \");\n       print_generic_expr (vect_dump, vec_stmt, TDF_SLIM);\n     }\n-  return new_temp;\n+  return vec_stmt;\n }\n \n \n@@ -215,6 +216,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n         by the data-ref in STMT.\n    4. ONLY_INIT: indicate if vp is to be updated in the loop, or remain\n         pointing to the initial address.\n+   5. TYPE: if not NULL indicates the required type of the data-ref\n \n    Output:\n    1. Declare a new ptr to vector_type, and have it point to the base of the\n@@ -242,7 +244,7 @@ static tree\n vect_create_data_ref_ptr (tree stmt,\n \t\t\t  block_stmt_iterator *bsi ATTRIBUTE_UNUSED,\n \t\t\t  tree offset, tree *initial_address, tree *ptr_incr,\n-\t\t\t  bool only_init)\n+\t\t\t  bool only_init, tree type)\n {\n   tree base_name;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -279,13 +281,14 @@ vect_create_data_ref_ptr (tree stmt,\n     }\n \n   /** (1) Create the new vector-pointer variable:  **/\n-\n-  vect_ptr_type = build_pointer_type (vectype);\n+  if (type)  \n+    vect_ptr_type = build_pointer_type (type);\n+  else\n+    vect_ptr_type = build_pointer_type (vectype);\n   vect_ptr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n                                     get_name (base_name));\n   add_referenced_var (vect_ptr);\n-  \n-  \n+\n   /** (2) Add aliasing information to the new vector-pointer:\n           (The points-to info (DR_PTR_INFO) may be defined later.)  **/\n   \n@@ -467,23 +470,22 @@ vect_create_destination_var (tree scalar_dest, tree vectype)\n    used in the vectorization of STMT.  */\n \n static tree\n-vect_init_vector (tree stmt, tree vector_var)\n+vect_init_vector (tree stmt, tree vector_var, tree vector_type)\n {\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree new_var;\n   tree init_stmt;\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo); \n   tree vec_oprnd;\n   edge pe;\n   tree new_temp;\n   basic_block new_bb;\n  \n-  new_var = vect_get_new_vect_var (vectype, vect_simple_var, \"cst_\");\n+  new_var = vect_get_new_vect_var (vector_type, vect_simple_var, \"cst_\");\n   add_referenced_var (new_var); \n  \n-  init_stmt = build2 (MODIFY_EXPR, vectype, new_var, vector_var);\n+  init_stmt = build2 (MODIFY_EXPR, void_type_node, new_var, vector_var);\n   new_temp = make_ssa_name (new_var, init_stmt);\n   TREE_OPERAND (init_stmt, 0) = new_temp;\n \n@@ -532,6 +534,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n   int i;\n   enum vect_def_type dt;\n   bool is_simple_use;\n+  tree vector_type;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -571,8 +574,10 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n           {\n             t = tree_cons (NULL_TREE, op, t);\n           }\n-        vec_cst = build_vector (vectype, t);\n-        return vect_init_vector (stmt, vec_cst);\n+        vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n+        vec_cst = build_vector (vector_type, t);\n+\n+        return vect_init_vector (stmt, vec_cst, vector_type);\n       }\n \n     /* Case 2: operand is defined outside the loop - loop invariant.  */\n@@ -591,8 +596,9 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n           }\n \n \t/* FIXME: use build_constructor directly.  */\n-        vec_inv = build_constructor_from_list (vectype, t);\n-        return vect_init_vector (stmt, vec_inv);\n+\tvector_type = get_vectype_for_scalar_type (TREE_TYPE (def));\n+        vec_inv = build_constructor_from_list (vector_type, t);\n+        return vect_init_vector (stmt, vec_inv, vector_type);\n       }\n \n     /* Case 3: operand is defined inside the loop.  */\n@@ -802,6 +808,7 @@ get_initial_def_for_reduction (tree stmt, tree init_val, tree *scalar_def)\n   tree vec, t = NULL_TREE;\n   bool need_epilog_adjust;\n   int i;\n+  tree vector_type;\n \n   gcc_assert (INTEGRAL_TYPE_P (type) || SCALAR_FLOAT_TYPE_P (type));\n \n@@ -849,18 +856,19 @@ get_initial_def_for_reduction (tree stmt, tree init_val, tree *scalar_def)\n       nelements += 1;\n     }\n   gcc_assert (nelements == nunits);\n-  \n+\n+  vector_type = get_vectype_for_scalar_type (TREE_TYPE (def));\n   if (TREE_CODE (init_val) == INTEGER_CST || TREE_CODE (init_val) == REAL_CST)\n-    vec = build_vector (vectype, t);\n+    vec = build_vector (vector_type, t);\n   else\n-    vec = build_constructor_from_list (vectype, t);\n+    vec = build_constructor_from_list (vector_type, t);\n     \n   if (!need_epilog_adjust)\n     *scalar_def = NULL_TREE;\n   else\n     *scalar_def = init_val;\n \n-  return vect_init_vector (stmt, vec);\n+  return vect_init_vector (stmt, vec, vector_type);\n }\n \n \n@@ -1048,7 +1056,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \tfprintf (vect_dump, \"Reduce using direct vector reduction.\");\n \n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      epilog_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n+      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest,\n \t\t\tbuild1 (reduc_code, vectype,  PHI_RESULT (new_phi)));\n       new_temp = make_ssa_name (vec_dest, epilog_stmt);\n       TREE_OPERAND (epilog_stmt, 0) = new_temp;\n@@ -1106,14 +1114,14 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t    {\n \t      tree bitpos = size_int (bit_offset);\n \n-\t      epilog_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n+\t      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest,\n \t\t\t\t    build2 (shift_code, vectype,\n \t\t\t\t\t    new_temp, bitpos));\n \t      new_name = make_ssa_name (vec_dest, epilog_stmt);\n \t      TREE_OPERAND (epilog_stmt, 0) = new_name;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \n-\t      epilog_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n+\t      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest,\n \t\t\t\t    build2 (code, vectype,\n \t\t\t\t\t    new_name, new_temp));\n \t      new_temp = make_ssa_name (vec_dest, epilog_stmt);\n@@ -1145,7 +1153,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t  rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n \t\t\t bitsize_zero_node);\n \t  BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n-\t  epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest, rhs);\n+\t  epilog_stmt = build2 (MODIFY_EXPR, void_type_node, new_scalar_dest, rhs);\n \t  new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t  TREE_OPERAND (epilog_stmt, 0) = new_temp;\n \t  bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n@@ -1159,13 +1167,13 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t\t\t\t bitpos);\n \t\t\n \t      BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n-\t      epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n+\t      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, new_scalar_dest,\n \t\t\t\t    rhs);\t\n \t      new_name = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t      TREE_OPERAND (epilog_stmt, 0) = new_name;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \n-\t      epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n+\t      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, new_scalar_dest,\n \t\t\t\tbuild2 (code, scalar_type, new_name, new_temp));\n \t      new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n@@ -1195,7 +1203,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \n       rhs = build3 (BIT_FIELD_REF, scalar_type, new_temp, bitsize, bitpos);\n       BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n-      epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest, rhs);\n+      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, new_scalar_dest, rhs);\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n       TREE_OPERAND (epilog_stmt, 0) = new_temp; \n       bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n@@ -1210,7 +1218,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   \n   if (scalar_initial_def)\n     {\n-      epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n+      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, new_scalar_dest,\n                       build2 (code, scalar_type, new_temp, scalar_initial_def));\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n       TREE_OPERAND (epilog_stmt, 0) = new_temp;\n@@ -1625,7 +1633,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   vec_oprnd = vect_get_vec_def_for_operand (op, stmt, NULL);\n \n   /* Arguments are ready. create the new vector stmt.  */\n-  *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, vec_oprnd);\n+  *vec_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, vec_oprnd);\n   new_temp = make_ssa_name (vec_dest, *vec_stmt);\n   TREE_OPERAND (*vec_stmt, 0) = new_temp;\n   vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n@@ -2121,7 +2129,7 @@ vect_gen_widened_results_half (enum tree_code code, tree vectype, tree decl,\n       else  \n         expr = build1 (code, vectype, vec_oprnd0); \n     } \n-  new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, expr); \n+  new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, expr);\n   new_temp = make_ssa_name (vec_dest, new_stmt); \n   TREE_OPERAND (new_stmt, 0) = new_temp; \n   vect_finish_stmt_generation (stmt, new_stmt, bsi); \n@@ -2434,7 +2442,7 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n \t  /* high = interleave_high (vect1, vect2);  */\n \t  perm_dest = create_tmp_var (vectype, \"vect_inter_high\");\n \t  add_referenced_var (perm_dest);\n-\t  perm_stmt = build2 (MODIFY_EXPR, vectype, perm_dest,\n+\t  perm_stmt = build2 (MODIFY_EXPR, void_type_node, perm_dest,\n \t\t\t      build2 (VEC_INTERLEAVE_HIGH_EXPR, vectype, vect1, \n \t\t\t\t      vect2));\n \t  high = make_ssa_name (perm_dest, perm_stmt);\n@@ -2445,7 +2453,7 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n \t  /* low = interleave_low (vect1, vect2);  */\n \t  perm_dest = create_tmp_var (vectype, \"vect_inter_low\");\n \t  add_referenced_var (perm_dest);\n-\t  perm_stmt = build2 (MODIFY_EXPR, vectype, perm_dest,\n+\t  perm_stmt = build2 (MODIFY_EXPR, void_type_node, perm_dest,\n \t\t\t      build2 (VEC_INTERLEAVE_LOW_EXPR, vectype, vect1, \n \t\t\t\t      vect2));\n \t  low = make_ssa_name (perm_dest, perm_stmt);\n@@ -2644,7 +2652,8 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t      next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n \t    }\n \t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, bsi, NULL_TREE, \n-\t\t\t\t\t\t  &dummy, &ptr_incr, false);\n+\t\t\t\t\t\t  &dummy, &ptr_incr, false,\n+\t\t\t\t\t\t  TREE_TYPE (vec_oprnd));\n \t}\n       else \n \t{\n@@ -2685,7 +2694,8 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n \t  data_ref = build_fold_indirect_ref (dataref_ptr);\n \t  /* Arguments are ready. Create the new vector stmt.  */\n-\t  new_stmt = build2 (MODIFY_EXPR, vectype, data_ref, vec_oprnd);\n+\t  new_stmt = build2 (MODIFY_EXPR, void_type_node, data_ref, \n+\t\t\t     vec_oprnd);\n \t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n \n \t  /* Set the V_MAY_DEFS for the vector pointer. If this virtual def has a \n@@ -2793,9 +2803,10 @@ vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n \n   /* 1. Create msq_init = *(floor(p1)) in the loop preheader  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-  ptr = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, &init_addr, &inc, true);\n+  ptr = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, &init_addr, &inc, true,\n+\t\t\t\t  NULL_TREE);\n   data_ref = build1 (ALIGN_INDIRECT_REF, vectype, ptr);\n-  new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n+  new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, data_ref);\n   new_temp = make_ssa_name (vec_dest, new_stmt);\n   TREE_OPERAND (new_stmt, 0) = new_temp;\n   new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n@@ -2810,10 +2821,10 @@ vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n       tree builtin_decl;\n       tree params = build_tree_list (NULL_TREE, init_addr);\n \n-      vec_dest = vect_create_destination_var (scalar_dest, \n-\t\t\t\t\t\t\tTREE_TYPE (new_stmt));\n       builtin_decl = targetm.vectorize.builtin_mask_for_load ();\n       new_stmt = build_function_call_expr (builtin_decl, params);\n+      vec_dest = vect_create_destination_var (scalar_dest, \n+\t\t\t\t\t      TREE_TYPE (new_stmt));\n       new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, new_stmt);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       TREE_OPERAND (new_stmt, 0) = new_temp;\n@@ -2990,7 +3001,7 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t  perm_dest = create_tmp_var (vectype, \"vect_perm_even\");\n \t  add_referenced_var (perm_dest);\n \t \n-\t  perm_stmt = build2 (MODIFY_EXPR, vectype, perm_dest,\n+\t  perm_stmt = build2 (MODIFY_EXPR, void_type_node, perm_dest,\n \t\t\t      build2 (VEC_EXTRACT_EVEN_EXPR, vectype, \n \t\t\t\t      first_vect, second_vect));\n \n@@ -3005,7 +3016,7 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t  perm_dest = create_tmp_var (vectype, \"vect_perm_odd\");\n \t  add_referenced_var (perm_dest);\n \n-\t  perm_stmt = build2 (MODIFY_EXPR, vectype, perm_dest,\n+\t  perm_stmt = build2 (MODIFY_EXPR, void_type_node, perm_dest,\n \t\t\t      build2 (VEC_EXTRACT_ODD_EXPR, vectype, \n \t\t\t\t      first_vect, second_vect));\n \t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n@@ -3336,8 +3347,8 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     { \n       /* 1. Create the vector pointer update chain.  */\n       if (j == 0)\n-        dataref_ptr = vect_create_data_ref_ptr (first_stmt, bsi, offset,\n-                                                &dummy, &ptr_incr, false);\n+        dataref_ptr = vect_create_data_ref_ptr (first_stmt, bsi, offset, &dummy,\n+                                                &ptr_incr, false, NULL_TREE);\n       else\n         dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt);\n \n@@ -3369,7 +3380,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t      gcc_unreachable ();\n \t    }\n \t  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-\t  new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n+\t  new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, data_ref);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  TREE_OPERAND (new_stmt, 0) = new_temp;\n \t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n@@ -3387,7 +3398,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \t      new_stmt =\n \t\tbuild3 (REALIGN_LOAD_EXPR, vectype, msq, lsq, realignment_token);\n-\t      new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, new_stmt);\n+\t      new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, new_stmt);\n \t      new_temp = make_ssa_name (vec_dest, new_stmt);\n \t      TREE_OPERAND (new_stmt, 0) = new_temp;\n \t      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n@@ -3638,7 +3649,7 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   vec_cond_expr = build3 (VEC_COND_EXPR, vectype, \n \t\t\t  vec_compare, vec_then_clause, vec_else_clause);\n \n-  *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, vec_cond_expr);\n+  *vec_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, vec_cond_expr);\n   new_temp = make_ssa_name (vec_dest, *vec_stmt);\n   TREE_OPERAND (*vec_stmt, 0) = new_temp;\n   vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n@@ -4037,8 +4048,11 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n \t\t\t\t\t\t\t       loop->num));\n \n       ni = fold_build2 (PLUS_EXPR, TREE_TYPE (init_expr),\n-\t\t\tfold_build2 (MULT_EXPR, TREE_TYPE (niters),\n-\t\t\t\t     niters, step_expr), init_expr);\n+\t\t\tfold_build2 (MULT_EXPR, TREE_TYPE (init_expr),\n+\t\t\t\t     fold_convert (TREE_TYPE (init_expr), \n+\t\t\t\t\t\t   niters), \n+\t\t\t\t     step_expr),\n+\t\t\tinit_expr);\n \n       var = create_tmp_var (TREE_TYPE (init_expr), \"tmp\");\n       add_referenced_var (var);"}]}