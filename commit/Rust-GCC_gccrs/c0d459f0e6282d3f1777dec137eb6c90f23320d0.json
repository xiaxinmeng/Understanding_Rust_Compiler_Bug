{"sha": "c0d459f0e6282d3f1777dec137eb6c90f23320d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBkNDU5ZjBlNjI4MmQzZjE3NzdkZWMxMzdlYjZjOTBmMjMzMjBkMA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-07-01T11:05:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-07-01T11:05:17Z"}, "message": "re PR tree-optimization/36666 (ICE in process_constraint, at tree-ssa-structalias.c:2573)\n\n2008-07-01  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/36666\n\t* tree-ssa-structalias.c (get_constraint_for_1): Declare.\n\t(get_constraint_exp_from_ssa_var): Split into ...\n\t(get_constraint_exp_for_temp): ... this ...\n\t(get_constraint_for_ssa_var): ... and that.\n\tReturn constraint expressions for all touched sub-fields\n\tif the results address is not taken.\n\t(process_constraint): Remove assertion that aggregate\n\tassignments do not happen at this place.\n\t(get_constraint_for_component_ref): Add address_p argument.\n\tReturn constraint expressions for all touched sub-fields\n\tif the results address is not taken.\n\t(do_deref): Use get_constraint_exp_for_temp.\n\t(get_constraint_for_1): Rename from ...\n\t(get_constraint_for): ... this.  Add the old function as\n\twrapper.\n\t(do_structure_copy): Use get_constraint_for_1.\n\n\t* gcc.c-torture/compile/pr36666.c: New testcase.\n\nFrom-SVN: r137315", "tree": {"sha": "a112f255682465337762db21676dae4533f92af0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a112f255682465337762db21676dae4533f92af0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0d459f0e6282d3f1777dec137eb6c90f23320d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0d459f0e6282d3f1777dec137eb6c90f23320d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0d459f0e6282d3f1777dec137eb6c90f23320d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0d459f0e6282d3f1777dec137eb6c90f23320d0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b6e99746ac31845e39844334378bafbb9a93517c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e99746ac31845e39844334378bafbb9a93517c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6e99746ac31845e39844334378bafbb9a93517c"}], "stats": {"total": 225, "additions": 152, "deletions": 73}, "files": [{"sha": "cd186dcbb8d351dcc1fd6b13088167a9e96f84e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0d459f0e6282d3f1777dec137eb6c90f23320d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0d459f0e6282d3f1777dec137eb6c90f23320d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0d459f0e6282d3f1777dec137eb6c90f23320d0", "patch": "@@ -1,4 +1,25 @@\n+2008-07-01  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/36666\n+\t* tree-ssa-structalias.c (get_constraint_for_1): Declare.\n+\t(get_constraint_exp_from_ssa_var): Split into ...\n+\t(get_constraint_exp_for_temp): ... this ...\n+\t(get_constraint_for_ssa_var): ... and that.\n+\tReturn constraint expressions for all touched sub-fields\n+\tif the results address is not taken.\n+\t(process_constraint): Remove assertion that aggregate\n+\tassignments do not happen at this place.\n+\t(get_constraint_for_component_ref): Add address_p argument.\n+\tReturn constraint expressions for all touched sub-fields\n+\tif the results address is not taken.\n+\t(do_deref): Use get_constraint_exp_for_temp.\n+\t(get_constraint_for_1): Rename from ...\n+\t(get_constraint_for): ... this.  Add the old function as\n+\twrapper.\n+\t(do_structure_copy): Use get_constraint_for_1.\n+\n 2008-07-01  Martin Jambor  <mjambor@suse.cz>\n+\n         * Makefile.in (tree-switch-conversion.o): Add.\n         (OBJS-common): Add tree-swtch-conversion.o.\n         * passes.c (init_optimization_passes): Add pass_convert_switch."}, {"sha": "e74fb52c3acbbb63b6e56c48d485aa7e25d7c2f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0d459f0e6282d3f1777dec137eb6c90f23320d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0d459f0e6282d3f1777dec137eb6c90f23320d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c0d459f0e6282d3f1777dec137eb6c90f23320d0", "patch": "@@ -1,3 +1,8 @@\n+2008-07-01  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/36666\n+\t* gcc.c-torture/compile/pr36666.c: New testcase.\n+\n 2008-07-01  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/pack10.adb: New test."}, {"sha": "9eb132cd044e697deb4ae7549edc130906ffb488", "filename": "gcc/testsuite/gcc.c-torture/compile/pr36666.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0d459f0e6282d3f1777dec137eb6c90f23320d0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr36666.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0d459f0e6282d3f1777dec137eb6c90f23320d0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr36666.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr36666.c?ref=c0d459f0e6282d3f1777dec137eb6c90f23320d0", "patch": "@@ -0,0 +1,22 @@\n+struct Foo {\n+    int *p;\n+    struct X {\n+\tint a,b,c,d,e,*f;\n+    } x;\n+} *init, *init2;\n+\n+struct X __attribute__((const)) foo(struct X);\n+struct Foo __attribute__((const)) foo2(struct Foo);\n+\n+void bar1 (void)\n+{\n+  init->x = foo (init2->x);\n+}\n+void bar2 (void)\n+{\n+  init->x = foo (init->x);\n+}\n+void bar3 (void)\n+{\n+  *init = foo2 (*init2);\n+}"}, {"sha": "57a02a4c754d421ee08b3ca8226906ab1a659de9", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 104, "deletions": 73, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0d459f0e6282d3f1777dec137eb6c90f23320d0/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0d459f0e6282d3f1777dec137eb6c90f23320d0/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=c0d459f0e6282d3f1777dec137eb6c90f23320d0", "patch": "@@ -412,6 +412,7 @@ struct constraint_expr\n typedef struct constraint_expr ce_s;\n DEF_VEC_O(ce_s);\n DEF_VEC_ALLOC_O(ce_s, heap);\n+static void get_constraint_for_1 (tree, VEC(ce_s, heap) **, bool);\n static void get_constraint_for (tree, VEC(ce_s, heap) **);\n static void do_deref (VEC (ce_s, heap) **);\n \n@@ -2495,35 +2496,70 @@ get_vi_for_tree (tree t)\n   return (varinfo_t) *slot;\n }\n \n-/* Get a constraint expression from an SSA_VAR_P node.  */\n+/* Get a constraint expression for a new temporary variable.  */\n \n static struct constraint_expr\n-get_constraint_exp_from_ssa_var (tree t)\n+get_constraint_exp_for_temp (tree t)\n {\n   struct constraint_expr cexpr;\n \n+  gcc_assert (SSA_VAR_P (t));\n+\n+  cexpr.type = SCALAR;\n+  cexpr.var = get_vi_for_tree (t)->id;\n+  cexpr.offset = 0;\n+\n+  return cexpr;\n+}\n+\n+/* Get a constraint expression vector from an SSA_VAR_P node.\n+   If address_p is true, the result will be taken its address of.  */\n+\n+static void\n+get_constraint_for_ssa_var (tree t, VEC(ce_s, heap) **results, bool address_p)\n+{\n+  struct constraint_expr cexpr;\n+  varinfo_t vi;\n+\n+  /* We allow FUNCTION_DECLs here even though it doesn't make much sense.  */\n   gcc_assert (SSA_VAR_P (t) || DECL_P (t));\n \n   /* For parameters, get at the points-to set for the actual parm\n      decl.  */\n   if (TREE_CODE (t) == SSA_NAME\n       && TREE_CODE (SSA_NAME_VAR (t)) == PARM_DECL\n       && SSA_NAME_IS_DEFAULT_DEF (t))\n-    return get_constraint_exp_from_ssa_var (SSA_NAME_VAR (t));\n+    {\n+      get_constraint_for_ssa_var (SSA_NAME_VAR (t), results, address_p);\n+      return;\n+    }\n \n+  vi = get_vi_for_tree (t);\n+  cexpr.var = vi->id;\n   cexpr.type = SCALAR;\n-\n-  cexpr.var = get_vi_for_tree (t)->id;\n+  cexpr.offset = 0;\n   /* If we determine the result is \"anything\", and we know this is readonly,\n      say it points to readonly memory instead.  */\n   if (cexpr.var == anything_id && TREE_READONLY (t))\n     {\n+      gcc_unreachable ();\n       cexpr.type = ADDRESSOF;\n       cexpr.var = readonly_id;\n     }\n \n-  cexpr.offset = 0;\n-  return cexpr;\n+  /* If we are not taking the address of the constraint expr, add all\n+     sub-fiels of the variable as well.  */\n+  if (!address_p)\n+    {\n+      for (; vi; vi = vi->next)\n+\t{\n+\t  cexpr.var = vi->id;\n+\t  VEC_safe_push (ce_s, heap, *results, &cexpr);\n+\t}\n+      return;\n+    }\n+\n+  VEC_safe_push (ce_s, heap, *results, &cexpr);\n }\n \n /* Process constraint T, performing various simplifications and then\n@@ -2564,13 +2600,7 @@ process_constraint (constraint_t t)\n       tree pointertype = TREE_TYPE (rhsdecl);\n       tree pointedtotype = TREE_TYPE (pointertype);\n       tree tmpvar = create_tmp_var_raw (pointedtotype, \"doubledereftmp\");\n-      struct constraint_expr tmplhs = get_constraint_exp_from_ssa_var (tmpvar);\n-\n-      /* If this is an aggregate of known size, we should have passed\n-\t this off to do_structure_copy, and it should have broken it\n-\t up.  */\n-      gcc_assert (!AGGREGATE_TYPE_P (pointedtotype)\n-\t\t  || get_varinfo (rhs.var)->is_unknown_size_var);\n+      struct constraint_expr tmplhs = get_constraint_exp_for_temp (tmpvar);\n \n       process_constraint (new_constraint (tmplhs, rhs));\n       process_constraint (new_constraint (lhs, tmplhs));\n@@ -2581,7 +2611,7 @@ process_constraint (constraint_t t)\n       tree rhsdecl = get_varinfo (rhs.var)->decl;\n       tree pointertype = TREE_TYPE (rhsdecl);\n       tree tmpvar = create_tmp_var_raw (pointertype, \"derefaddrtmp\");\n-      struct constraint_expr tmplhs = get_constraint_exp_from_ssa_var (tmpvar);\n+      struct constraint_expr tmplhs = get_constraint_exp_for_temp (tmpvar);\n \n       process_constraint (new_constraint (tmplhs, rhs));\n       process_constraint (new_constraint (lhs, tmplhs));\n@@ -2625,18 +2655,19 @@ bitpos_of_field (const tree fdecl)\n }\n \n \n-/* Given a COMPONENT_REF T, return the constraint_expr for it.  */\n+/* Given a COMPONENT_REF T, return the constraint_expr vector for it.\n+   If address_p is true the result will be taken its address of.  */\n \n static void\n-get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results)\n+get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n+\t\t\t\t  bool address_p)\n {\n   tree orig_t = t;\n   HOST_WIDE_INT bitsize = -1;\n   HOST_WIDE_INT bitmaxsize = -1;\n   HOST_WIDE_INT bitpos;\n   tree forzero;\n   struct constraint_expr *result;\n-  unsigned int beforelength = VEC_length (ce_s, *results);\n \n   /* Some people like to do cute things like take the address of\n      &0->a.b */\n@@ -2657,11 +2688,12 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results)\n \n   t = get_ref_base_and_extent (t, &bitpos, &bitsize, &bitmaxsize);\n \n-  get_constraint_for (t, results);\n+  /* Pretend to take the address of the base, we'll take care of\n+     adding the required subset of sub-fields below.  */\n+  get_constraint_for_1 (t, results, true);\n   result = VEC_last (ce_s, *results);\n-  result->offset = bitpos;\n \n-  gcc_assert (beforelength + 1 == VEC_length (ce_s, *results));\n+  gcc_assert (VEC_length (ce_s, *results) == 1);\n \n   /* This can also happen due to weird offsetof type macros.  */\n   if (TREE_CODE (t) != ADDR_EXPR && result->type == ADDRESSOF)\n@@ -2674,28 +2706,34 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results)\n \t ignore this constraint. When we handle pointer subtraction,\n \t we may have to do something cute here.  */\n \n-      if (result->offset < get_varinfo (result->var)->fullsize\n+      if ((unsigned HOST_WIDE_INT)bitpos < get_varinfo (result->var)->fullsize\n \t  && bitmaxsize != 0)\n \t{\n \t  /* It's also not true that the constraint will actually start at the\n \t     right offset, it may start in some padding.  We only care about\n \t     setting the constraint to the first actual field it touches, so\n \t     walk to find it.  */\n+\t  struct constraint_expr cexpr = *result;\n \t  varinfo_t curr;\n-\t  for (curr = get_varinfo (result->var); curr; curr = curr->next)\n+\t  VEC_pop (ce_s, *results);\n+\t  cexpr.offset = 0;\n+\t  for (curr = get_varinfo (cexpr.var); curr; curr = curr->next)\n \t    {\n \t      if (ranges_overlap_p (curr->offset, curr->size,\n-\t\t\t\t    result->offset, bitmaxsize))\n+\t\t\t\t    bitpos, bitmaxsize))\n \t\t{\n-\t\t  result->var = curr->id;\n-\t\t  break;\n+\t\t  cexpr.var = curr->id;\n+\t\t  VEC_safe_push (ce_s, heap, *results, &cexpr);\n+\t\t  if (address_p)\n+\t\t    break;\n \t\t}\n \t    }\n \t  /* assert that we found *some* field there. The user couldn't be\n \t     accessing *only* padding.  */\n \t  /* Still the user could access one past the end of an array\n \t     embedded in a struct resulting in accessing *only* padding.  */\n-\t  gcc_assert (curr || ref_contains_array_ref (orig_t));\n+\t  gcc_assert (VEC_length (ce_s, *results) >= 1\n+\t\t      || ref_contains_array_ref (orig_t));\n \t}\n       else if (bitmaxsize == 0)\n \t{\n@@ -2706,8 +2744,6 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results)\n       else\n \tif (dump_file && (dump_flags & TDF_DETAILS))\n \t  fprintf (dump_file, \"Access to past the end of variable, ignoring\\n\");\n-\n-      result->offset = 0;\n     }\n   else if (bitmaxsize == -1)\n     {\n@@ -2716,6 +2752,8 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results)\n       result->var = anything_id;\n       result->offset = 0;\n     }\n+  else\n+    result->offset = bitpos;\n }\n \n \n@@ -2740,7 +2778,7 @@ do_deref (VEC (ce_s, heap) **constraints)\n       else if (c->type == DEREF)\n \t{\n \t  tree tmpvar = create_tmp_var_raw (ptr_type_node, \"dereftmp\");\n-\t  struct constraint_expr tmplhs = get_constraint_exp_from_ssa_var (tmpvar);\n+\t  struct constraint_expr tmplhs = get_constraint_exp_for_temp (tmpvar);\n \t  process_constraint (new_constraint (tmplhs, *c));\n \t  c->var = tmplhs.var;\n \t}\n@@ -2752,7 +2790,7 @@ do_deref (VEC (ce_s, heap) **constraints)\n /* Given a tree T, return the constraint expression for it.  */\n \n static void\n-get_constraint_for (tree t, VEC (ce_s, heap) **results)\n+get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p)\n {\n   struct constraint_expr temp;\n \n@@ -2796,32 +2834,8 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t      struct constraint_expr *c;\n \t      unsigned int i;\n \t      tree exp = TREE_OPERAND (t, 0);\n-\t      tree pttype = TREE_TYPE (TREE_TYPE (t));\n-\n-\t      get_constraint_for (exp, results);\n \n-\n-\t      /* Complex types are special. Taking the address of one\n-\t\t allows you to access either part of it through that\n-\t\t pointer.  */\n-\t      if (VEC_length (ce_s, *results) == 1 &&\n-\t\t  TREE_CODE (pttype) == COMPLEX_TYPE)\n-\t\t{\n-\t\t  struct constraint_expr *origrhs;\n-\t\t  varinfo_t origvar;\n-\t\t  struct constraint_expr tmp;\n-\n-\t\t  gcc_assert (VEC_length (ce_s, *results) == 1);\n-\t\t  origrhs = VEC_last (ce_s, *results);\n-\t\t  tmp = *origrhs;\n-\t\t  VEC_pop (ce_s, *results);\n-\t\t  origvar = get_varinfo (origrhs->var);\n-\t\t  for (; origvar; origvar = origvar->next)\n-\t\t    {\n-\t\t      tmp.var = origvar->id;\n-\t\t      VEC_safe_push (ce_s, heap, *results, &tmp);\n-\t\t    }\n-\t\t}\n+\t      get_constraint_for_1 (exp, results, true);\n \n \t      for (i = 0; VEC_iterate (ce_s, *results, i, c); i++)\n \t\t{\n@@ -2888,14 +2902,14 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t  {\n \t  case INDIRECT_REF:\n \t    {\n-\t      get_constraint_for (TREE_OPERAND (t, 0), results);\n+\t      get_constraint_for_1 (TREE_OPERAND (t, 0), results, address_p);\n \t      do_deref (results);\n \t      return;\n \t    }\n \t  case ARRAY_REF:\n \t  case ARRAY_RANGE_REF:\n \t  case COMPONENT_REF:\n-\t    get_constraint_for_component_ref (t, results);\n+\t    get_constraint_for_component_ref (t, results, address_p);\n \t    return;\n \t  default:\n \t    {\n@@ -2920,7 +2934,7 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t      if (!(POINTER_TYPE_P (TREE_TYPE (t))\n \t\t    && ! POINTER_TYPE_P (TREE_TYPE (op))))\n \t\t{\n-\t\t  get_constraint_for (op, results);\n+\t\t  get_constraint_for_1 (op, results, address_p);\n \t\t  return;\n \t\t}\n \n@@ -2942,15 +2956,13 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t  {\n \t  case PHI_NODE:\n \t    {\n-\t      get_constraint_for (PHI_RESULT (t), results);\n+\t      get_constraint_for_1 (PHI_RESULT (t), results, address_p);\n \t      return;\n \t    }\n \t    break;\n \t  case SSA_NAME:\n \t    {\n-\t      struct constraint_expr temp;\n-\t      temp = get_constraint_exp_from_ssa_var (t);\n-\t      VEC_safe_push (ce_s, heap, *results, &temp);\n+\t      get_constraint_for_ssa_var (t, results, address_p);\n \t      return;\n \t    }\n \t    break;\n@@ -2966,9 +2978,7 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n       }\n     case tcc_declaration:\n       {\n-\tstruct constraint_expr temp;\n-\ttemp = get_constraint_exp_from_ssa_var (t);\n-\tVEC_safe_push (ce_s, heap, *results, &temp);\n+\tget_constraint_for_ssa_var (t, results, address_p);\n \treturn;\n       }\n     default:\n@@ -2982,6 +2992,15 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n     }\n }\n \n+/* Given a gimple tree T, return the constraint expression vector for it.  */\n+\n+static void\n+get_constraint_for (tree t, VEC (ce_s, heap) **results)\n+{\n+  gcc_assert (VEC_length (ce_s, *results) == 0);\n+\n+  get_constraint_for_1 (t, results, false);\n+}\n \n /* Handle the structure copy case where we have a simple structure copy\n    between LHS and RHS that is of SIZE (in bits)\n@@ -3140,8 +3159,10 @@ do_structure_copy (tree lhsop, tree rhsop)\n   unsigned HOST_WIDE_INT lhssize;\n   unsigned HOST_WIDE_INT rhssize;\n \n-  get_constraint_for (lhsop, &lhsc);\n-  get_constraint_for (rhsop, &rhsc);\n+  /* Pretend we are taking the address of the constraint exprs.\n+     We deal with walking the sub-fields ourselves.  */\n+  get_constraint_for_1 (lhsop, &lhsc, true);\n+  get_constraint_for_1 (rhsop, &rhsc, true);\n   gcc_assert (VEC_length (ce_s, lhsc) == 1);\n   gcc_assert (VEC_length (ce_s, rhsc) == 1);\n   lhs = *(VEC_last (ce_s, lhsc));\n@@ -3436,8 +3457,9 @@ handle_const_call (tree stmt)\n   struct constraint_expr rhsc;\n   unsigned int j;\n   struct constraint_expr *lhsp;\n-  tree arg;\n+  tree arg, tmpvar;\n   call_expr_arg_iterator iter;\n+  struct constraint_expr tmpc;\n \n   get_constraint_for (lhs, &lhsc);\n \n@@ -3453,12 +3475,18 @@ handle_const_call (tree stmt)\n       return;\n     }\n \n+  /* We always use a temporary here, otherwise we end up with a quadratic\n+     amount of constraints for\n+       large_struct = const_call (large_struct);\n+     in field-sensitive PTA.  */\n+  tmpvar = create_tmp_var_raw (ptr_type_node, \"consttmp\");\n+  tmpc = get_constraint_exp_for_temp (tmpvar);\n+\n   /* May return addresses of globals.  */\n   rhsc.var = nonlocal_id;\n   rhsc.offset = 0;\n   rhsc.type = ADDRESSOF;\n-  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-    process_constraint (new_constraint (*lhsp, rhsc));\n+  process_constraint (new_constraint (tmpc, rhsc));\n \n   /* May return arguments.  */\n   FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n@@ -3467,13 +3495,16 @@ handle_const_call (tree stmt)\n \tVEC(ce_s, heap) *argc = NULL;\n \tstruct constraint_expr *argp;\n \tint i;\n+\n \tget_constraint_for (arg, &argc);\n \tfor (i = 0; VEC_iterate (ce_s, argc, i, argp); i++)\n-\t  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-\t    process_constraint (new_constraint (*lhsp, *argp));\n+\t  process_constraint (new_constraint (tmpc, *argp));\n \tVEC_free (ce_s, heap, argc);\n       }\n \n+  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+    process_constraint (new_constraint (*lhsp, tmpc));\n+\n   VEC_free (ce_s, heap, lhsc);\n }\n "}]}