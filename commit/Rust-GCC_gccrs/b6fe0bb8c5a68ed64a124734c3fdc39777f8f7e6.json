{"sha": "b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZmZTBiYjhjNWE2OGVkNjRhMTI0NzM0YzNmZGMzOTc3N2Y4ZjdlNg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-07-25T09:52:32Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-07-25T09:52:32Z"}, "message": "Remove pedwarn_with_decl, warning_with_decl and error_with_decl from GCC.\n\n        Remove pedwarn_with_decl, warning_with_decl and error_with_decl\n        from GCC.\n        * calls.c (try_to_integrate): Don't use xxx_with_decl.\n        (expand_call): Likewise.\n        * dwarfout.c (output_reg_number): Likewise.\n        * expr.c (expand_expr): Likewise.\n        * function.c (assign_temp): Likewise.\n        (uninitialized_vars_warning): Likewise.\n        (setjmp_args_warning): Likewise.\n        (expand_function_end): Likewise.\n        * stmt.c (fixup_gotos): Likewise.\n        (warn_about_unused_variables): Likewise.\n        (expand_end_bindings): Likewise.\n        * stor-layout.c (layout_decl): Likewise.\n        (place_field): Likewise.\n        * toplev.c (check_global_declarations): Likewise.\n        (rest_of_handle_inlining): Likewise.\n        (default_tree_printer): New function.\n        (general_init): Initialize diagnostic machinery before routing\n        signals to the ICE machinery.  Set default tree printer.\n        * toplev.h (pedwarn_with_decl): Remove declaration.\n        (warning_with_decl): Likewise.\n        (error_with_decl): Likewise.\n        (pedwarn): Remove attribute for the time being.\n        * tree-inline.c (expand_call_inline): Don't use xxx_with_decl.\n        * varasm.c (named_section): Likewise.\n        (make_decl_rtl): Likewise.\n        (assemble_variable): Likewise.\n        (merge_weak): Likewise.\n        (declare_weak): Likewise.\n\n        * diagnostic.h: Move non-diagnostic stuff into pretty-print.h.\n        * diagnostic.c: Move non-diagnostic stuff into pretty-print.c.\n        (format_with_decl): Remove.\n        (diagnostic_for_decl): Likewise.\n        (pedwarn_with_decl): Likewise.\n        (warning_with_decl): Likewise.\n        (error_with_decl): Likewise.\n        (diagnostic_initialize): Adjust.\n        (diagnostic_count_diagnostic): Likewise.\n        (announce_function): Likewise.\n        (lhd_print_error_function): Likewise.\n        (diagnostic_report_current_module): Likewise.\n        (default_diagnostic_starter): Likewise.\n        (diagnostic_report_diagnostic): Likewise.\n        (default_diagnostic_finalizer): Likewise.\n        (verbatim): Likewise.\n        (error): Likewise.\n        (warning): Likewise.\n        * opts.c (common_handle_option): Likewise.\n        * pretty-print.c: New file.\n        * c-pretty-print.h (pp_base): Override.\n        * c-pretty-print.c: Adjust use of macros throughout.\n        (pp_buffer): New macro.\n        (pp_newline): Likewise.\n        * c-objc-common.c (c_tree_printer): Adjust prototype. Tidy.\n        * Makefile.in (DIAGNOSTIC_H): New variable.\n        (c-errors.o): Use it.\n        (c-objc-common.o): Likewise.\n        (c-common.o): Likewise.\n        (c-opts.o): Likewise.\n        (c-format.o): Likewise.\n        (diagnostic.o): Likewise.\n        (opts.o): Likewise.\n        (toplev.o): Likewise.\n        (rtl-error.o): Likewise.\n        (dwarf2out.o): Likewise.\n        (jump.o): Likewise.\n        (pretty-print.o): New rule.\n\ncp/\n        * Make-lang.in (cp/error.o): Depend on DIAGNOSTIC_H.\n        * error.c: Use the new pretty-printer fraamework.\n\nFrom-SVN: r69773", "tree": {"sha": "0cd9e2817d3c1f65316bb57b92b7f8d6cd0f1864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cd9e2817d3c1f65316bb57b92b7f8d6cd0f1864"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d5ff4e3f11063acc36318f0c7a6dd9643679c92f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5ff4e3f11063acc36318f0c7a6dd9643679c92f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5ff4e3f11063acc36318f0c7a6dd9643679c92f"}], "stats": {"total": 2753, "additions": 1336, "deletions": 1417}, "files": [{"sha": "5c90a76b371034af3795155bf5232c7345061783", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -1,3 +1,75 @@\n+2003-07-25  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tRemove pedwarn_with_decl, warning_with_decl and error_with_decl\n+\tfrom GCC. \n+\t* calls.c (try_to_integrate): Don't use xxx_with_decl.\n+\t(expand_call): Likewise.\n+\t* dwarfout.c (output_reg_number): Likewise.\n+\t* expr.c (expand_expr): Likewise.\n+\t* function.c (assign_temp): Likewise.\n+\t(uninitialized_vars_warning): Likewise.\n+\t(setjmp_args_warning): Likewise.\n+\t(expand_function_end): Likewise.\n+\t* stmt.c (fixup_gotos): Likewise.\n+\t(warn_about_unused_variables): Likewise.\n+\t(expand_end_bindings): Likewise.\n+\t* stor-layout.c (layout_decl): Likewise.\n+\t(place_field): Likewise.\n+\t* toplev.c (check_global_declarations): Likewise.\n+\t(rest_of_handle_inlining): Likewise.\n+\t(default_tree_printer): New function.\n+\t(general_init): Initialize diagnostic machinery before routing\n+\tsignals to the ICE machinery.  Set default tree printer.\n+\t* toplev.h (pedwarn_with_decl): Remove declaration.\n+\t(warning_with_decl): Likewise.\n+\t(error_with_decl): Likewise.\n+\t(pedwarn): Remove attribute for the time being. \n+\t* tree-inline.c (expand_call_inline): Don't use xxx_with_decl.\n+\t* varasm.c (named_section): Likewise.\n+\t(make_decl_rtl): Likewise.\n+\t(assemble_variable): Likewise.\n+\t(merge_weak): Likewise.\n+\t(declare_weak): Likewise.\n+\n+\t* diagnostic.h: Move non-diagnostic stuff into pretty-print.h.\n+\t* diagnostic.c: Move non-diagnostic stuff into pretty-print.c.\n+\t(format_with_decl): Remove.\n+\t(diagnostic_for_decl): Likewise.\n+\t(pedwarn_with_decl): Likewise.\n+\t(warning_with_decl): Likewise.\n+\t(error_with_decl): Likewise.\n+\t(diagnostic_initialize): Adjust.\n+\t(diagnostic_count_diagnostic): Likewise.\n+\t(announce_function): Likewise.\n+\t(lhd_print_error_function): Likewise.\n+\t(diagnostic_report_current_module): Likewise.\n+\t(default_diagnostic_starter): Likewise.\n+\t(diagnostic_report_diagnostic): Likewise.\n+\t(default_diagnostic_finalizer): Likewise.\n+\t(verbatim): Likewise.\n+\t(error): Likewise.\n+\t(warning): Likewise.\n+\t* opts.c (common_handle_option): Likewise.\n+\t* pretty-print.c: New file.\n+\t* c-pretty-print.h (pp_base): Override.\n+\t* c-pretty-print.c: Adjust use of macros throughout.\n+\t(pp_buffer): New macro.\n+\t(pp_newline): Likewise.\n+\t* c-objc-common.c (c_tree_printer): Adjust prototype. Tidy.\n+\t* Makefile.in (DIAGNOSTIC_H): New variable.\n+\t(c-errors.o): Use it.\n+\t(c-objc-common.o): Likewise.\n+\t(c-common.o): Likewise.\n+\t(c-opts.o): Likewise.\n+\t(c-format.o): Likewise.\n+\t(diagnostic.o): Likewise.\n+\t(opts.o): Likewise.\n+\t(toplev.o): Likewise.\n+\t(rtl-error.o): Likewise.\n+\t(dwarf2out.o): Likewise.\n+\t(jump.o): Likewise.\n+\t(pretty-print.o): New rule.\n+\n 2003-07-24  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.def (BUILT_IN_PRINTF, BUILT_IN_FPRINTF): Changed from"}, {"sha": "1968f82776b101b276b9be956e23a78a1d564025", "filename": "gcc/Makefile.in", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -652,6 +652,8 @@ C_TREE_H = c-tree.h $(C_COMMON_H)\n SYSTEM_H = system.h hwint.h $(srcdir)/../include/libiberty.h\n PREDICT_H = predict.h predict.def\n CPPLIB_H = cpplib.h line-map.h\n+PRETTY_PRINT_H = pretty-print.h input.h $(OBSTACK_H)\n+DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H)\n \n # sed inserts variable overrides after the following line.\n ####target overrides\n@@ -821,7 +823,7 @@ OBJS-common = \\\n  sibcall.o simplify-rtx.o sreal.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t   \\\n  stor-layout.o stringpool.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o\t\t   \\\n- alloc-pool.o et-forest.o cfghooks.o bt-load.o $(GGC)\n+ alloc-pool.o et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) \n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) hashtable.o tree-inline.o\t   \\\n@@ -1238,7 +1240,7 @@ s-crt0:\t$(CRT0_S) $(MCRT0_S) $(GCC_PASSES) $(CONFIG_H)\n # C language specific files.\n \n c-errors.o: c-errors.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-    $(C_TREE_H) flags.h diagnostic.h $(TM_P_H)\n+    $(C_TREE_H) flags.h $(DIAGNOSTIC_H) $(TM_P_H)\n c-parse.o : $(parsedir)/c-parse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(GGC_H) intl.h $(C_TREE_H) input.h flags.h toplev.h output.h $(CPPLIB_H) \\\n     varray.h gt-c-parse.h\n@@ -1282,7 +1284,7 @@ c-ppoutput.o : c-ppoutput.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(C_COMMON_H) $(TREE_H) $(CPPLIB_H) cpphash.h $(TM_P_H) c-pragma.h\n c-objc-common.o : c-objc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(C_TREE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) $(EXPR_H) $(C_TREE_H) \\\n-    flags.h toplev.h tree-inline.h diagnostic.h $(VARRAY_H) \\\n+    flags.h toplev.h tree-inline.h $(DIAGNOSTIC_H) $(VARRAY_H) \\\n     langhooks.h $(GGC_H) gt-c-objc-common.h $(TARGET_H) cgraph.h\n c-aux-info.o : c-aux-info.c  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(C_TREE_H) flags.h toplev.h\n@@ -1317,13 +1319,13 @@ tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h\n c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \t$(OBSTACK_H) $(C_COMMON_H) flags.h toplev.h output.h c-pragma.h intl.h \\\n \t$(GGC_H) $(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def \\\n-\tdiagnostic.h gt-c-common.h langhooks.h varray.h $(RTL_H) $(TARGET_H) \\\n-\t$(C_TREE_H)\n+\t$(DIAGNOSTIC_H) gt-c-common.h langhooks.h varray.h $(RTL_H) \\\n+\t$(TARGET_H) $(C_TREE_H)\n c-pretty-print.o : c-pretty-print.c c-pretty-print.h pretty-print.h \\\n \t$(C_COMMON_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) real.h\n \n c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-        c-pragma.h flags.h toplev.h langhooks.h tree-inline.h diagnostic.h \\\n+        c-pragma.h flags.h toplev.h langhooks.h tree-inline.h $(DIAGNOSTIC_H) \\\n \tintl.h debug.h $(C_COMMON_H) opts.h options.h $(PARAMS_H)\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$< $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@\n@@ -1339,7 +1341,7 @@ attribs.o : attribs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) flag\n \tbuiltin-types.def $(TARGET_H) langhooks.h\n \n c-format.o : c-format.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) langhooks.h \\\n-\t$(C_COMMON_H) flags.h toplev.h intl.h diagnostic.h\n+\t$(C_COMMON_H) flags.h toplev.h intl.h $(DIAGNOSTIC_H)\n \n c-semantics.o : c-semantics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \t$(C_TREE_H) flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n@@ -1473,14 +1475,14 @@ stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE\n    langhooks.h\n fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    flags.h real.h toplev.h $(HASHTAB_H) $(EXPR_H) $(RTL_H) $(GGC_H) $(TM_P_H) langhooks.h\n-diagnostic.o : diagnostic.c diagnostic.h real.h diagnostic.def \\\n+diagnostic.o : diagnostic.c $(DIAGNOSTIC_H) real.h \\\n    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(TM_P_H) flags.h $(GGC_H) \\\n    input.h toplev.h intl.h langhooks.h $(LANGHOOKS_DEF_H)\n opts.o : opts.c opts.h options.h toplev.h $(CONFIG_H) $(SYSTEM_H) \\\n \tcoretypes.h $(TREE_H) $(TM_H) $(LANGHOOKS_H) $(GGC_H) $(RTL_H) \\\n-\toutput.h diagnostic.h $(TM_P_H) $(INSN_ATTR_H) intl.h\n+\toutput.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h\n toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n-   function.h flags.h xcoffout.h input.h $(INSN_ATTR_H) output.h diagnostic.h \\\n+   function.h flags.h xcoffout.h input.h $(INSN_ATTR_H) output.h $(DIAGNOSTIC_H) \\\n    debug.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h \\\n    dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n    graph.h $(LOOP_H) except.h $(REGS_H) $(TIMEVAR_H) \\\n@@ -1496,7 +1498,7 @@ host-default.o : host-default.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \thosthooks.h hosthooks-def.h\n \n rtl-error.o: rtl-error.c $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(INSN_ATTR_H) \\\n-   insn-config.h input.h toplev.h intl.h diagnostic.h $(CONFIG_H)\n+   insn-config.h input.h toplev.h intl.h $(DIAGNOSTIC_H) $(CONFIG_H)\n \n rtl.o : rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) $(RTL_H) real.h \\\n   $(GGC_H) errors.h\n@@ -1563,7 +1565,7 @@ dwarfout.o : dwarfout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) dwarf.h flags.h insn-config.h reload.h output.h toplev.h $(TM_P_H) \\\n    debug.h langhooks.h $(TARGET_H)\n dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   $(RTL_H) dwarf2.h debug.h flags.h insn-config.h reload.h output.h diagnostic.h real.h \\\n+   $(RTL_H) dwarf2.h debug.h flags.h insn-config.h reload.h output.h $(DIAGNOSTIC_H) real.h \\\n    hard-reg-set.h $(REGS_H) $(EXPR_H) libfuncs.h toplev.h dwarf2out.h varray.h \\\n    $(GGC_H) except.h dwarf2asm.h $(TM_P_H) langhooks.h $(HASHTAB_H) \\\n    gt-dwarf2out.h $(TARGET_H)\n@@ -1585,7 +1587,7 @@ integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $\n jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \\\n    hard-reg-set.h $(REGS_H) insn-config.h $(RECOG_H) $(EXPR_H) real.h except.h function.h \\\n    toplev.h $(INSN_ATTR_H) $(TM_P_H) reload.h $(PREDICT_H) $(TIMEVAR_H) \\\n-   diagnostic.h\n+   $(DIAGNOSTIC_H)\n \n simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n@@ -1794,6 +1796,7 @@ ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    cfgloop.h\n params.o : params.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(PARAMS_H) toplev.h\n hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(HOOKS_H)\n+pretty-print.o: pretty-print.c $(PRETTY_PRINT_H)\n \n $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) $(GGC_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \\"}, {"sha": "887175be6f8a126fc56f22e37a88e67ea5fc73b4", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -39,7 +39,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"cgraph.h\"\n \n-static bool c_tree_printer (output_buffer *, text_info *);\n+static bool c_tree_printer (pretty_printer *, text_info *);\n static tree inline_forbidden_p (tree *, int *, void *);\n static void expand_deferred_fns (void);\n static tree start_cdtor (int);\n@@ -416,7 +416,7 @@ c_objc_common_finish_file (void)\n    Please notice when called, the `%' part was already skipped by the\n    diagnostic machinery.  */\n static bool\n-c_tree_printer (output_buffer *buffer, text_info *text)\n+c_tree_printer (pretty_printer *pp, text_info *text)\n {\n   tree t = va_arg (*text->args_ptr, tree);\n \n@@ -429,14 +429,14 @@ c_tree_printer (output_buffer *buffer, text_info *text)\n         const char *n = DECL_NAME (t)\n           ? (*lang_hooks.decl_printable_name) (t, 2)\n           : \"({anonymous})\";\n-        output_add_string (buffer, n);\n+        pp_string (pp, n);\n       }\n       return true;\n \n     case 'E':\n        if (TREE_CODE (t) == IDENTIFIER_NODE)\n          {\n-           output_add_string (buffer, IDENTIFIER_POINTER (t));\n+           pp_string (pp, IDENTIFIER_POINTER (t));\n            return true;\n          }\n        return false;"}, {"sha": "7bb4cb03ed8f972b252050426d5c82f6374f3519", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -74,6 +74,9 @@ static void pp_c_type_id (c_pretty_printer, tree);\n static void pp_c_storage_class_specifier (c_pretty_printer, tree);\n static void pp_c_function_specifier (c_pretty_printer, tree);\n \n+#define pp_buffer(PP) pp_base (PP)->buffer\n+#define pp_newline(PP) (pp_newline) (pp_base (PP))\n+\n \f\n /* Declarations.  */\n \n@@ -248,9 +251,9 @@ pp_c_init_declarator (c_pretty_printer pp, tree t)\n   pp_declarator (pp, t);\n   if (DECL_INITIAL (t))\n     {\n-      pp_whitespace (pp);\n+      pp_space (pp);\n       pp_equal (pp);\n-      pp_whitespace (pp);\n+      pp_space (pp);\n       pp_c_initializer (pp, DECL_INITIAL (t));\n     }\n }\n@@ -336,9 +339,9 @@ pp_c_char (c_pretty_printer ppi, int c)\n       break;\n     default:\n       if (ISPRINT (c))\n-\tpp_character (ppi, c);\n+\tpp_character (&ppi->base, c);\n       else\n-\tpp_format_scalar (ppi, \"\\\\%03o\", (unsigned) c);\n+\tpp_scalar (ppi, \"\\\\%03o\", (unsigned) c);\n       break;\n     }\n }\n@@ -1038,7 +1041,7 @@ pp_c_assignment_expression (c_pretty_printer ppi, tree e)\n       pp_c_unary_expression (ppi, TREE_OPERAND (e, 0));\n       pp_c_maybe_whitespace (ppi);\n       pp_equal (ppi);\n-      pp_whitespace (ppi);\n+      pp_space (ppi);\n       pp_c_assignment_expression (ppi, TREE_OPERAND (e, 1));\n     }\n   else\n@@ -1234,7 +1237,7 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n \n     case IF_STMT:\n       pp_c_identifier (ppi, \"if\");\n-      pp_whitespace (ppi);\n+      pp_space (ppi);\n       pp_c_left_paren (ppi);\n       pp_c_expression (ppi, IF_COND (stmt));\n       pp_right_paren (ppi);\n@@ -1258,7 +1261,7 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n     case SWITCH_STMT:\n       pp_newline (ppi);\n       pp_c_identifier (ppi, \"switch\");\n-      pp_whitespace (ppi);\n+      pp_space (ppi);\n       pp_c_left_paren (ppi);\n       pp_c_expression (ppi, SWITCH_COND (stmt));\n       pp_right_paren (ppi);\n@@ -1269,7 +1272,7 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n \n     case WHILE_STMT:\n       pp_c_identifier (ppi, \"while\");\n-      pp_whitespace (ppi);\n+      pp_space (ppi);\n       pp_c_left_paren (ppi);\n       pp_c_expression (ppi, WHILE_COND (stmt));\n       pp_right_paren (ppi);\n@@ -1284,7 +1287,7 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n       pp_statement (ppi, DO_BODY (stmt));\n       pp_newline_and_indent (ppi, -3);\n       pp_c_identifier (ppi, \"while\");\n-      pp_whitespace (ppi);\n+      pp_space (ppi);\n       pp_c_left_paren (ppi);\n       pp_c_expression (ppi, DO_COND (stmt));\n       pp_c_right_paren (ppi);\n@@ -1294,7 +1297,7 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n \n     case FOR_STMT:\n       pp_c_identifier (ppi, \"for\");\n-      pp_whitespace (ppi);\n+      pp_space (ppi);\n       pp_c_left_paren (ppi);\n       pp_statement (ppi, FOR_INIT_STMT (stmt));\n       pp_c_whitespace (ppi);\n@@ -1364,20 +1367,20 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n \tpp_c_identifier (ppi, is_extended ? \"__asm__\" : \"asm\");\n \tif (has_volatile_p)\n \t  pp_c_identifier (ppi, \"__volatile__\");\n-\tpp_whitespace (ppi);\n+\tpp_space (ppi);\n \tpp_c_left_paren (ppi);\n \tpp_c_string_literal (ppi, ASM_STRING (stmt));\n \tif (is_extended)\n \t  {\n-\t    pp_whitespace (ppi);\n+\t    pp_space (ppi);\n \t    pp_separate_with (ppi, ':');\n \t    if (ASM_OUTPUTS (stmt))\n \t      pp_c_expression (ppi, ASM_OUTPUTS (stmt));\n-\t    pp_whitespace (ppi);\n+\t    pp_space (ppi);\n \t    pp_separate_with (ppi, ':');\n \t    if (ASM_INPUTS (stmt))\n \t      pp_c_expression (ppi, ASM_INPUTS (stmt));\n-\t    pp_whitespace (ppi);\n+\t    pp_space (ppi);\n \t    pp_separate_with (ppi, ':');\n \t    if (ASM_CLOBBERS (stmt))\n \t      pp_c_expression (ppi, ASM_CLOBBERS (stmt));\n@@ -1389,7 +1392,7 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n \n     case FILE_STMT:\n       pp_c_identifier (ppi, \"__FILE__\");\n-      pp_whitespace (ppi);\n+      pp_space (ppi);\n       pp_equal (ppi);\n       pp_c_whitespace (ppi);\n       pp_c_identifier (ppi, FILE_STMT_FILENAME (stmt));"}, {"sha": "bdd92b15f1bd57ed4de6471066f6a071819415f9", "filename": "gcc/c-pretty-print.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -62,6 +62,9 @@ struct c_pretty_print_info\n   c_pretty_print_fn assignment_expression;\n };\n \n+#undef pp_base\n+#define pp_base(PP)  (&pp_c_base (PP)->base)\n+\n #define pp_c_left_paren(PPI)                       \\\n    do {                                            \\\n      pp_left_paren (PPI);                          \\\n@@ -84,7 +87,7 @@ struct c_pretty_print_info\n    } while (0)\n #define pp_c_whitespace(PPI)                       \\\n    do {                                            \\\n-     pp_whitespace (PPI);                          \\\n+     pp_space (PPI);                               \\\n      pp_c_base (PPI)->base.padding = pp_none;      \\\n    } while (0)\n #define pp_c_maybe_whitespace(PPI)                 \\\n@@ -102,10 +105,6 @@ struct c_pretty_print_info\n #define pp_c_tree_identifier(PPI, ID)              \\\n    pp_c_identifier (PPI, IDENTIFIER_POINTER (ID))\n \n-/* Returns the 'output_buffer *' associated with a PRETTY-PRINTER, the latter\n-   being something digestible by pp_c_base.  */\n-#define pp_buffer(PPI) pp_c_base (PPI)->base.buffer\n-\n #define pp_declaration(PPI, T)                    \\\n    (*pp_c_base (PPI)->declaration) (pp_c_base (PPI), T)\n #define pp_declaration_specifiers(PPI, D)         \\"}, {"sha": "135b3336e31e28e25934398ddab0c2243c1f6bfc", "filename": "gcc/calls.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -1808,7 +1808,8 @@ try_to_integrate (tree fndecl, tree actparms, rtx target, int ignore,\n   if (DECL_INLINE (fndecl) && warn_inline && !flag_no_inline\n       && optimize > 0 && !TREE_ADDRESSABLE (fndecl))\n     {\n-      warning_with_decl (fndecl, \"inlining failed in call to `%s'\");\n+      warning (\"%Hinlining failed in call to '%F'\",\n+               &DECL_SOURCE_LOCATION (fndecl), fndecl);\n       warning (\"called from here\");\n     }\n   (*lang_hooks.mark_addressable) (fndecl);\n@@ -2147,7 +2148,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t  if (DECL_INLINE (fndecl) && warn_inline && !flag_no_inline\n \t      && optimize > 0)\n \t    {\n-\t      warning_with_decl (fndecl, \"can't inline call to `%s'\");\n+\t      warning (\"%Hcan't inline call to '%F'\",\n+                       &DECL_SOURCE_LOCATION (fndecl), fndecl);\n \t      warning (\"called from here\");\n \t    }\n \t  (*lang_hooks.mark_addressable) (fndecl);"}, {"sha": "0487cbae8e4b1d8cd708ce8777246f5af64fecb5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -1,3 +1,8 @@\n+2003-07-25 Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* Make-lang.in (cp/error.o): Depend on DIAGNOSTIC_H.\n+\t* error.c: Use the new pretty-printer fraamework.\n+\n 2003-07-24  Per Bothner  <pbothner@apple.com>\n \n \t* decl.c (pushdecl_class_level):   Don't use push_srcloc/pop_srcloc"}, {"sha": "d16a5bcb02e14c5153b0b9d5474742b9188dd100", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -265,8 +265,8 @@ cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(RTL_H) flags.h $(EXPR_H) toplev.h \\\n   except.h $(TM_P_H)\n cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h cp/lex.h \\\n   toplev.h $(RTL_H) except.h tree-inline.h gt-cp-pt.h\n-cp/error.o: cp/error.c $(CXX_TREE_H) $(TM_H) toplev.h diagnostic.h flags.h real.h \\\n-  $(LANGHOOKS_DEF_H)\n+cp/error.o: cp/error.c $(CXX_TREE_H) $(TM_H) toplev.h $(DIAGNOSTIC_H) \\\n+  flags.h real.h $(LANGHOOKS_DEF_H)\n cp/repo.o: cp/repo.c $(CXX_TREE_H) $(TM_H) toplev.h diagnostic.h \\\n   gt-cp-repo.h\n cp/semantics.o: cp/semantics.c $(CXX_TREE_H) $(TM_H) cp/lex.h except.h toplev.h \\"}, {"sha": "86b336e3c4d39c2ffedcb62b1c898f10d700f2dd", "filename": "gcc/cp/error.c", "status": "modified", "additions": 313, "deletions": 360, "changes": 673, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -30,32 +30,21 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"diagnostic.h\"\n #include \"langhooks-def.h\"\n+#include \"pretty-print.h\"\n \n enum pad { none, before, after };\n \n-#define sorry_for_unsupported_tree(T)                                      \\\n-   sorry (\"`%s' not supported by %s\", tree_code_name[(int) TREE_CODE (T)], \\\n-             __FUNCTION__)\n-\n-#define print_scope_operator(BUFFER)  output_add_string ((BUFFER), \"::\")\n-#define print_left_paren(BUFFER)      output_add_character ((BUFFER), '(')\n-#define print_right_paren(BUFFER)     output_add_character ((BUFFER), ')')\n-#define print_left_bracket(BUFFER)    output_add_character ((BUFFER), '[')\n-#define print_right_bracket(BUFFER)   output_add_character ((BUFFER), ']')\n-#define print_template_argument_list_start(BUFFER) \\\n-   print_non_consecutive_character ((BUFFER), '<')\n-#define print_template_argument_list_end(BUFFER)  \\\n-   print_non_consecutive_character ((BUFFER), '>')\n-#define print_tree_identifier(BUFFER, TID) \\\n-   output_add_string ((BUFFER), IDENTIFIER_POINTER (TID))\n-#define print_identifier(BUFFER, ID) output_add_string ((BUFFER), (ID))\n-#define separate_with_comma(BUFFER) output_add_string ((BUFFER), \", \")\n+#define pp_template_argument_list_start(PP) \\\n+   pp_non_consecutive_character (PP, '<')\n+#define pp_template_argument_list_end(PP)  \\\n+   pp_non_consecutive_character (PP, '>')\n+#define pp_separate_with_comma(PP) pp_string (PP, \", \")\n \n /* The global buffer where we dump everything.  It is there only for\n    transitional purpose.  It is expected, in the near future, to be\n    completely removed.  */\n-static output_buffer scratch_buffer_rec;\n-static output_buffer *scratch_buffer = &scratch_buffer_rec;\n+static pretty_printer scratch_pretty_printer;\n+#define cxx_pp (&scratch_pretty_printer)\n \n # define NEXT_CODE(T) (TREE_CODE (TREE_TYPE (T)))\n \n@@ -109,8 +98,8 @@ static void cp_diagnostic_starter (diagnostic_context *, diagnostic_info *);\n static void cp_diagnostic_finalizer (diagnostic_context *, diagnostic_info *);\n static void cp_print_error_function (diagnostic_context *, diagnostic_info *);\n \n-static bool cp_printer (output_buffer *, text_info *);\n-static void print_non_consecutive_character (output_buffer *, int);\n+static bool cp_printer (pretty_printer *, text_info *);\n+static void pp_non_consecutive_character (pretty_printer *, int);\n static tree locate_error (const char *, va_list);\n static location_t location_of (tree);\n \n@@ -121,7 +110,7 @@ init_error (void)\n   diagnostic_finalizer (global_dc) = cp_diagnostic_finalizer;\n   diagnostic_format_decoder (global_dc) = cp_printer;\n \n-  init_output_buffer (scratch_buffer, /* prefix */NULL, /* line-width */0);\n+  pp_construct (cxx_pp, NULL, 0);\n }\n \n /* Dump a scope, if deemed necessary.  */\n@@ -139,18 +128,18 @@ dump_scope (tree scope, int flags)\n       if (scope != global_namespace)\n         {\n           dump_decl (scope, f);\n-          print_scope_operator (scratch_buffer);\n+          pp_colon_colon (cxx_pp);\n         }\n     }\n   else if (AGGREGATE_TYPE_P (scope))\n     {\n       dump_type (scope, f);\n-      print_scope_operator (scratch_buffer);\n+      pp_colon_colon (cxx_pp);\n     }\n   else if ((flags & TFF_SCOPE) && TREE_CODE (scope) == FUNCTION_DECL)\n     {\n       dump_function_decl (scope, f);\n-      print_scope_operator (scratch_buffer);\n+      pp_colon_colon (cxx_pp);\n     }\n }\n \n@@ -174,12 +163,12 @@ dump_qualifiers (tree t, enum pad p)\n         if (masks[ix] & quals)\n           {\n             if (p == before)\n-              output_add_space (scratch_buffer);\n+              pp_space (cxx_pp);\n             p = before;\n-            print_identifier (scratch_buffer, names[ix]);\n+            pp_identifier (cxx_pp, names[ix]);\n           }\n       if (do_after)\n-        output_add_space (scratch_buffer);\n+        pp_space (cxx_pp);\n     }\n   else\n     p = none;\n@@ -210,7 +199,7 @@ dump_template_argument_list (tree args, int flags)\n   for (i = 0; i< n; ++i)\n     {\n       if (need_comma)\n-        separate_with_comma (scratch_buffer);\n+        pp_separate_with_comma (cxx_pp);\n       dump_template_argument (TREE_VEC_ELT (args, i), flags);\n       need_comma = 1;\n     }\n@@ -228,24 +217,24 @@ dump_template_parameter (tree parm, int flags)\n     {\n       if (flags & TFF_DECL_SPECIFIERS)\n         {\n-          print_identifier (scratch_buffer, \"class\");\n+          pp_identifier (cxx_pp, \"class\");\n           if (DECL_NAME (p))\n             {\n-              output_add_space (scratch_buffer);\n-              print_tree_identifier (scratch_buffer, DECL_NAME (p));\n+              pp_space (cxx_pp);\n+              pp_tree_identifier (cxx_pp, DECL_NAME (p));\n             }\n         }\n       else if (DECL_NAME (p))\n-        print_tree_identifier (scratch_buffer, DECL_NAME (p));\n+        pp_tree_identifier (cxx_pp, DECL_NAME (p));\n       else\n-        print_identifier (scratch_buffer, \"{template default argument error}\");\n+        pp_identifier (cxx_pp, \"<template default argument error>\");\n     }\n   else\n     dump_decl (p, flags | TFF_DECL_SPECIFIERS);\n \n   if ((flags & TFF_FUNCTION_DEFAULT_ARGUMENTS) && a != NULL_TREE)\n     {\n-      output_add_string (scratch_buffer, \" = \");\n+      pp_string (cxx_pp, \" = \");\n       if (TREE_CODE (p) == TYPE_DECL || TREE_CODE (p) == TEMPLATE_DECL)\n         dump_type (a, flags & ~TFF_CHASE_TYPEDEF);\n       else\n@@ -282,13 +271,13 @@ dump_template_bindings (tree parms, tree args)\n \t    }\n \n \t  if (need_comma)\n-\t    separate_with_comma (scratch_buffer);\n+\t    pp_separate_with_comma (cxx_pp);\n \t  dump_template_parameter (TREE_VEC_ELT (p, i), TFF_PLAIN_IDENTIFIER);\n-\t  output_add_string (scratch_buffer, \" = \");\n+\t  pp_string (cxx_pp, \" = \");\n \t  if (arg)\n \t    dump_template_argument (arg, TFF_PLAIN_IDENTIFIER);\n \t  else\n-\t    print_identifier (scratch_buffer, \"<missing>\");\n+\t    pp_identifier (cxx_pp, \"<missing>\");\n \n \t  ++arg_idx;\n \t  need_comma = 1;\n@@ -313,7 +302,7 @@ dump_type (tree t, int flags)\n   switch (TREE_CODE (t))\n     {\n     case UNKNOWN_TYPE:\n-      print_identifier (scratch_buffer, \"<unknown type>\");\n+      pp_identifier (cxx_pp, \"<unknown type>\");\n       break;\n \n     case TREE_LIST:\n@@ -322,7 +311,7 @@ dump_type (tree t, int flags)\n       break;\n \n     case IDENTIFIER_NODE:\n-      print_tree_identifier (scratch_buffer, t);\n+      pp_tree_identifier (cxx_pp, t);\n       break;\n \n     case TREE_VEC:\n@@ -350,12 +339,12 @@ dump_type (tree t, int flags)\n       break;\n \n     case COMPLEX_TYPE:\n-      output_add_string (scratch_buffer, \"__complex__ \");\n+      pp_string (cxx_pp, \"__complex__ \");\n       dump_type (TREE_TYPE (t), flags);\n       break;\n \n     case VECTOR_TYPE:\n-      output_add_string (scratch_buffer, \"__vector__ \");\n+      pp_string (cxx_pp, \"__vector__ \");\n       {\n \t/* The subtype of a VECTOR_TYPE is something like intQI_type_node,\n \t   which has no name and is not very useful for diagnostics.  So\n@@ -368,9 +357,9 @@ dump_type (tree t, int flags)\n \n     case INTEGER_TYPE:\n       if (!TREE_UNSIGNED (TYPE_MAIN_VARIANT (t)) && TREE_UNSIGNED (t))\n-\toutput_add_string (scratch_buffer, \"unsigned \");\n+\tpp_string (cxx_pp, \"unsigned \");\n       else if (TREE_UNSIGNED (TYPE_MAIN_VARIANT (t)) && !TREE_UNSIGNED (t))\n-\toutput_add_string (scratch_buffer, \"signed \");\n+\tpp_string (cxx_pp, \"signed \");\n \n       /* fall through.  */\n     case REAL_TYPE:\n@@ -381,41 +370,39 @@ dump_type (tree t, int flags)\n \tdump_qualifiers (t, after);\n \ttype = flags & TFF_CHASE_TYPEDEF ? TYPE_MAIN_VARIANT (t) : t;\n \tif (TYPE_NAME (type) && TYPE_IDENTIFIER (type))\n-\t  print_tree_identifier (scratch_buffer, TYPE_IDENTIFIER (type));\n+\t  pp_tree_identifier (cxx_pp, TYPE_IDENTIFIER (type));\n \telse\n \t  /* Types like intQI_type_node and friends have no names.\n \t     These don't come up in user error messages, but it's nice\n \t     to be able to print them from the debugger.  */\n-\t  print_identifier (scratch_buffer, \"<anonymous>\");\n+\t  pp_identifier (cxx_pp, \"<anonymous>\");\n       }\n       break;\n \n     case TEMPLATE_TEMPLATE_PARM:\n       /* For parameters inside template signature.  */\n       if (TYPE_IDENTIFIER (t))\n-\tprint_tree_identifier (scratch_buffer, TYPE_IDENTIFIER (t));\n+\tpp_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n       else\n-\tprint_identifier\n-          (scratch_buffer, \"<anonymous template template parameter>\");\n+\tpp_identifier (cxx_pp, \"<anonymous template template parameter>\");\n       break;\n \n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n       {\n \ttree args = TYPE_TI_ARGS (t);\n-\tprint_tree_identifier (scratch_buffer, TYPE_IDENTIFIER (t));\n-\tprint_template_argument_list_start (scratch_buffer);\n+\tpp_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n+\tpp_template_argument_list_start (cxx_pp);\n         dump_template_argument_list (args, flags);\n-\tprint_template_argument_list_end (scratch_buffer);\n+\tpp_template_argument_list_end (cxx_pp);\n       }\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n       dump_qualifiers (t, after);\n       if (TYPE_IDENTIFIER (t))\n-\tprint_tree_identifier (scratch_buffer, TYPE_IDENTIFIER (t));\n+\tpp_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n       else\n-\tprint_identifier\n-          (scratch_buffer, \"<anonymous template type parameter>\");\n+\tpp_identifier (cxx_pp, \"<anonymous template type parameter>\");\n       break;\n \n       /* This is not always necessary for pointers and such, but doing this\n@@ -434,29 +421,29 @@ dump_type (tree t, int flags)\n     }\n     case TYPENAME_TYPE:\n       dump_qualifiers (t, after);\n-      output_add_string (scratch_buffer, \"typename \");\n+      pp_string (cxx_pp, \"typename \");\n       dump_typename (t, flags);\n       break;\n \n     case UNBOUND_CLASS_TEMPLATE:\n       dump_type (TYPE_CONTEXT (t), flags);\n-      print_scope_operator (scratch_buffer);\n-      print_identifier (scratch_buffer, \"template \");\n+      pp_colon_colon (cxx_pp);\n+      pp_identifier (cxx_pp, \"template \");\n       dump_type (DECL_NAME (TYPE_NAME (t)), flags);\n       break;\n \n     case TYPEOF_TYPE:\n-      output_add_string (scratch_buffer, \"__typeof (\");\n+      pp_string (cxx_pp, \"__typeof (\");\n       dump_expr (TYPE_FIELDS (t), flags & ~TFF_EXPR_IN_PARENS);\n-      print_right_paren (scratch_buffer);\n+      pp_right_paren (cxx_pp);\n       break;\n \n     default:\n-      sorry_for_unsupported_tree (t);\n+      pp_unsupported_tree (cxx_pp, t);\n       /* Fall through to error.  */\n \n     case ERROR_MARK:\n-      print_identifier (scratch_buffer, \"<type error>\");\n+      pp_identifier (cxx_pp, \"<type error>\");\n       break;\n     }\n }\n@@ -473,7 +460,7 @@ dump_typename (tree t, int flags)\n     dump_typename (ctx, flags);\n   else\n     dump_type (ctx, flags & ~TFF_CLASS_KEY_OR_ENUM);\n-  print_scope_operator (scratch_buffer);\n+  pp_colon_colon (cxx_pp);\n   dump_decl (TYPENAME_TYPE_FULLNAME (t), flags);\n }\n \n@@ -507,8 +494,8 @@ dump_aggr_type (tree t, int flags)\n \n   if (flags & TFF_CLASS_KEY_OR_ENUM)\n     {\n-      print_identifier (scratch_buffer, variety);\n-      output_add_space (scratch_buffer);\n+      pp_identifier (cxx_pp, variety);\n+      pp_space (cxx_pp);\n     }\n \n   if (flags & TFF_CHASE_TYPEDEF)\n@@ -542,12 +529,12 @@ dump_aggr_type (tree t, int flags)\n   if (name == 0 || ANON_AGGRNAME_P (name))\n     {\n       if (flags & TFF_CLASS_KEY_OR_ENUM)\n-        print_identifier (scratch_buffer, \"<anonymous>\");\n+        pp_identifier (cxx_pp, \"<anonymous>\");\n       else\n-        output_printf (scratch_buffer, \"<anonymous %s>\", variety);\n+        pp_printf (cxx_pp, \"<anonymous %s>\", variety);\n     }\n   else\n-    print_tree_identifier (scratch_buffer, name);\n+    pp_tree_identifier (cxx_pp, name);\n   if (tmplate)\n     dump_template_parms (TYPE_TEMPLATE_INFO (t),\n                          !CLASSTYPE_USE_TEMPLATE (t),\n@@ -589,11 +576,10 @@ dump_type_prefix (tree t, int flags)\n \tpadding = dump_type_prefix (sub, flags);\n \tif (TREE_CODE (sub) == ARRAY_TYPE)\n \t  {\n-\t    output_add_space (scratch_buffer);\n-\t    print_left_paren (scratch_buffer);\n+\t    pp_space (cxx_pp);\n+\t    pp_left_paren (cxx_pp);\n \t  }\n-\toutput_add_character\n-\t  (scratch_buffer, \"&*\"[TREE_CODE (t) == POINTER_TYPE]);\n+\tpp_character (cxx_pp, \"&*\"[TREE_CODE (t) == POINTER_TYPE]);\n \tpadding = dump_qualifiers (t, before);\n       }\n       break;\n@@ -604,11 +590,11 @@ dump_type_prefix (tree t, int flags)\n       if (TREE_CODE (t) == OFFSET_TYPE)\t/* pmfs deal with this in d_t_p */\n \t{\n \t  if (padding != none)\n-\t    output_add_space (scratch_buffer);\n+\t    pp_space (cxx_pp);\n \t  dump_type (TYPE_OFFSET_BASETYPE (t), flags);\n-\t  print_scope_operator (scratch_buffer);\n+\t  pp_colon_colon (cxx_pp);\n \t}\n-      output_add_character (scratch_buffer, '*');\n+      pp_star (cxx_pp);\n       padding = dump_qualifiers (t, none);\n       break;\n \n@@ -617,19 +603,19 @@ dump_type_prefix (tree t, int flags)\n     case FUNCTION_TYPE:\n       padding = dump_type_prefix (TREE_TYPE (t), flags);\n       if (padding != none)\n-        output_add_space (scratch_buffer);\n-      print_left_paren (scratch_buffer);\n+        pp_space (cxx_pp);\n+      pp_left_paren (cxx_pp);\n       padding = none;\n       break;\n \n     case METHOD_TYPE:\n       padding = dump_type_prefix (TREE_TYPE (t), flags);\n       if (padding != none)\n-        output_add_space (scratch_buffer);\n-      print_left_paren (scratch_buffer);\n+        pp_space (cxx_pp);\n+      pp_left_paren (cxx_pp);\n       padding = none;\n       dump_aggr_type (TYPE_METHOD_BASETYPE (t), flags);\n-      print_scope_operator (scratch_buffer);\n+      pp_colon_colon (cxx_pp);\n       break;\n \n     case ARRAY_TYPE:\n@@ -660,10 +646,10 @@ dump_type_prefix (tree t, int flags)\n       break;\n \n     default:\n-      sorry_for_unsupported_tree (t);\n+      pp_unsupported_tree (cxx_pp, t);\n       /* fall through.  */\n     case ERROR_MARK:\n-      print_identifier (scratch_buffer, \"<typeprefixerror>\");\n+      pp_identifier (cxx_pp, \"<typeprefixerror>\");\n       break;\n     }\n   return padding;\n@@ -684,7 +670,7 @@ dump_type_suffix (tree t, int flags)\n     case REFERENCE_TYPE:\n     case OFFSET_TYPE:\n       if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n-\tprint_right_paren (scratch_buffer);\n+\tpp_right_paren (cxx_pp);\n       dump_type_suffix (TREE_TYPE (t), flags);\n       break;\n \n@@ -693,7 +679,7 @@ dump_type_suffix (tree t, int flags)\n     case METHOD_TYPE:\n       {\n \ttree arg;\n-        print_right_paren (scratch_buffer);\n+        pp_right_paren (cxx_pp);\n \targ = TYPE_ARG_TYPES (t);\n \tif (TREE_CODE (t) == METHOD_TYPE)\n \t  arg = TREE_CHAIN (arg);\n@@ -711,13 +697,12 @@ dump_type_suffix (tree t, int flags)\n       }\n \n     case ARRAY_TYPE:\n-      print_left_bracket (scratch_buffer);\n+      pp_left_bracket (cxx_pp);\n       if (TYPE_DOMAIN (t))\n \t{\n \t  if (host_integerp (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0))\n-\t    output_host_wide_integer\n-              (scratch_buffer,\n-               tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0) + 1);\n+\t    pp_wide_integer\n+              (cxx_pp, tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0) + 1);\n \t  else if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) == MINUS_EXPR)\n \t    dump_expr (TREE_OPERAND (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0),\n \t               flags & ~TFF_EXPR_IN_PARENS);\n@@ -727,7 +712,7 @@ dump_type_suffix (tree t, int flags)\n \t\t\t      integer_one_node)),\n \t               flags & ~TFF_EXPR_IN_PARENS);\n \t}\n-      print_right_bracket (scratch_buffer);\n+      pp_right_bracket (cxx_pp);\n       dump_type_suffix (TREE_TYPE (t), flags);\n       break;\n \n@@ -753,7 +738,7 @@ dump_type_suffix (tree t, int flags)\n       break;\n \n     default:\n-      sorry_for_unsupported_tree (t);\n+      pp_unsupported_tree (cxx_pp, t);\n     case ERROR_MARK:\n       /* Don't mark it here, we should have already done in\n          dump_type_prefix.  */\n@@ -773,7 +758,7 @@ dump_global_iord (tree t)\n   else\n     abort ();\n \n-  output_printf (scratch_buffer, \"(static %s for %s)\", p, input_filename);\n+  pp_printf (cxx_pp, \"(static %s for %s)\", p, input_filename);\n }\n \n static void\n@@ -782,14 +767,14 @@ dump_simple_decl (tree t, tree type, int flags)\n   if (flags & TFF_DECL_SPECIFIERS)\n     {\n       if (dump_type_prefix (type, flags) != none)\n-        output_add_space (scratch_buffer);\n+        pp_space (cxx_pp);\n     }\n   if (!DECL_INITIAL (t) || TREE_CODE (DECL_INITIAL (t)) != TEMPLATE_PARM_INDEX)\n     dump_scope (CP_DECL_CONTEXT (t), flags);\n   if (DECL_NAME (t))\n     dump_decl (DECL_NAME (t), flags);\n   else\n-    print_identifier (scratch_buffer, \"<anonymous>\");\n+    pp_identifier (cxx_pp, \"<anonymous>\");\n   if (flags & TFF_DECL_SPECIFIERS)\n     dump_type_suffix (type, flags);\n }\n@@ -812,14 +797,14 @@ dump_decl (tree t, int flags)\n \t    if ((flags & TFF_DECL_SPECIFIERS)\n \t        && TREE_CODE (TREE_TYPE (t)) == TEMPLATE_TYPE_PARM)\n \t      /* Say `class T' not just `T'.  */\n-\t      output_add_string (scratch_buffer, \"class \");\n+\t      pp_string (cxx_pp, \"class \");\n \n \t    dump_type (TREE_TYPE (t), flags);\n \t    break;\n \t  }\n       }\n       if (flags & TFF_DECL_SPECIFIERS)\n-\toutput_add_string (scratch_buffer, \"typedef \");\n+\tpp_string (cxx_pp, \"typedef \");\n       dump_simple_decl (t, DECL_ORIGINAL_TYPE (t)\n \t\t\t? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t),\n \t                flags);\n@@ -828,7 +813,7 @@ dump_decl (tree t, int flags)\n     case VAR_DECL:\n       if (DECL_NAME (t) && VTABLE_NAME_P (DECL_NAME (t)))\n \t{\n-\t  output_add_string (scratch_buffer, \"vtable for \");\n+\t  pp_string (cxx_pp, \"vtable for \");\n \t  my_friendly_assert (TYPE_P (DECL_CONTEXT (t)), 20010720);\n \t  dump_type (DECL_CONTEXT (t), flags);\n \t  break;\n@@ -840,29 +825,29 @@ dump_decl (tree t, int flags)\n       break;\n \n     case RESULT_DECL:\n-      output_add_string (scratch_buffer, \"<return value> \");\n+      pp_string (cxx_pp, \"<return value> \");\n       dump_simple_decl (t, TREE_TYPE (t), flags);\n       break;\n \n     case NAMESPACE_DECL:\n       dump_scope (CP_DECL_CONTEXT (t), flags);\n       if (DECL_NAME (t) == anonymous_namespace_name)\n-\tprint_identifier (scratch_buffer, \"<unnamed>\");\n+\tpp_identifier (cxx_pp, \"<unnamed>\");\n       else\n-\tprint_tree_identifier (scratch_buffer, DECL_NAME (t));\n+\tpp_tree_identifier (cxx_pp, DECL_NAME (t));\n       break;\n \n     case SCOPE_REF:\n       dump_decl (TREE_OPERAND (t, 0), flags & ~TFF_DECL_SPECIFIERS);\n-      print_scope_operator (scratch_buffer); \n+      pp_colon_colon (cxx_pp); \n       dump_decl (TREE_OPERAND (t, 1), flags);\n       break;\n \n     case ARRAY_REF:\n       dump_decl (TREE_OPERAND (t, 0), flags);\n-      print_left_bracket (scratch_buffer);\n+      pp_left_bracket (cxx_pp);\n       dump_decl (TREE_OPERAND (t, 1), flags);\n-      print_right_bracket (scratch_buffer);\n+      pp_right_bracket (cxx_pp);\n       break;\n \n       /* So that we can do dump_decl on an aggr type.  */\n@@ -875,7 +860,7 @@ dump_decl (tree t, int flags)\n     case BIT_NOT_EXPR:\n       /* This is a pseudo destructor call which has not been folded into\n          a PSEUDO_DTOR_EXPR yet.  */\n-      output_add_character (scratch_buffer, '~');\n+      pp_complement (cxx_pp);\n       dump_type (TREE_OPERAND (t, 0), flags);\n       break;\n \n@@ -888,13 +873,13 @@ dump_decl (tree t, int flags)\n     case IDENTIFIER_NODE:\n       if (IDENTIFIER_TYPENAME_P (t))\n \t{\n-\t  output_add_string (scratch_buffer, \"operator \");\n+\t  pp_string (cxx_pp, \"operator \");\n \t  /* Not exactly IDENTIFIER_TYPE_VALUE.  */\n \t  dump_type (TREE_TYPE (t), flags);\n \t  break;\n \t}\n       else\n-\tprint_tree_identifier (scratch_buffer, t);\n+\tpp_tree_identifier (cxx_pp, t);\n       break;\n \n     case OVERLOAD:\n@@ -904,12 +889,12 @@ dump_decl (tree t, int flags)\n \t  if (DECL_CLASS_SCOPE_P (t))\n \t    {\n \t      dump_type (DECL_CONTEXT (t), flags);\n-\t      output_add_string (scratch_buffer, \"::\");\n+              pp_colon_colon (cxx_pp);\n \t    }\n \t  else if (DECL_CONTEXT (t))\n \t    {\n \t      dump_decl (DECL_CONTEXT (t), flags);\n-\t      output_add_string (scratch_buffer, \"::\");\n+              pp_colon_colon (cxx_pp);\n \t    }\n \t  dump_decl (DECL_NAME (t), flags);\n \t  break;\n@@ -924,7 +909,7 @@ dump_decl (tree t, int flags)\n       if (DECL_GLOBAL_CTOR_P (t) || DECL_GLOBAL_DTOR_P (t))\n \tdump_global_iord (t);\n       else if (! DECL_LANG_SPECIFIC (t))\n-\tprint_identifier (scratch_buffer, \"<internal>\");\n+\tpp_identifier (cxx_pp, \"<internal>\");\n       else\n         dump_function_decl (t, flags);\n       break;\n@@ -940,19 +925,19 @@ dump_decl (tree t, int flags)\n \tif (is_overloaded_fn (name))\n \t  name = DECL_NAME (get_first_fn (name));\n \tdump_decl (name, flags);\n-\tprint_template_argument_list_start (scratch_buffer);\n+\tpp_template_argument_list_start (cxx_pp);\n \tfor (args = TREE_OPERAND (t, 1); args; args = TREE_CHAIN (args))\n \t  {\n \t    dump_template_argument (TREE_VALUE (args), flags);\n \t    if (TREE_CHAIN (args))\n-\t      separate_with_comma (scratch_buffer);\n+\t      pp_separate_with_comma (cxx_pp);\n \t  }\n-\tprint_template_argument_list_end (scratch_buffer);\n+\tpp_template_argument_list_end (cxx_pp);\n       }\n       break;\n \n     case LABEL_DECL:\n-      print_tree_identifier (scratch_buffer, DECL_NAME (t));\n+      pp_tree_identifier (cxx_pp, DECL_NAME (t));\n       break;\n \n     case CONST_DECL:\n@@ -965,13 +950,13 @@ dump_decl (tree t, int flags)\n       else if (DECL_INITIAL (t))\n \tdump_expr (DECL_INITIAL (t), flags | TFF_EXPR_IN_PARENS);\n       else\n-\tprint_identifier (scratch_buffer, \"<enumerator>\");\n+\tpp_identifier (cxx_pp, \"<enumerator>\");\n       break;\n \n     case USING_DECL:\n-      output_add_string (scratch_buffer, \"using \");\n+      pp_string (cxx_pp, \"using \");\n       dump_type (DECL_INITIAL (t), flags);\n-      print_scope_operator (scratch_buffer);\n+      pp_colon_colon (cxx_pp);\n       dump_decl (DECL_NAME (t), flags);\n       break;\n \n@@ -984,11 +969,11 @@ dump_decl (tree t, int flags)\n       break;\n \n     default:\n-      sorry_for_unsupported_tree (t);\n+      pp_unsupported_tree (cxx_pp, t);\n       /* Fallthrough to error.  */\n \n     case ERROR_MARK:\n-      print_identifier (scratch_buffer, \"<declaration error>\");\n+      pp_identifier (cxx_pp, \"<declaration error>\");\n       break;\n     }\n }\n@@ -1012,7 +997,7 @@ dump_template_decl (tree t, int flags)\n \t  tree inner_parms = INNERMOST_TEMPLATE_PARMS (parms);\n           int len = TREE_VEC_LENGTH (inner_parms);\n \n-          output_add_string (scratch_buffer, \"template<\");\n+          pp_string (cxx_pp, \"template<\");\n \n \t  /* If we've shown the template prefix, we'd better show the\n \t     parameters' and decl's type too.  */\n@@ -1021,17 +1006,17 @@ dump_template_decl (tree t, int flags)\n           for (i = 0; i < len; i++)\n             {\n               if (i)\n-                separate_with_comma (scratch_buffer);\n+                pp_separate_with_comma (cxx_pp);\n               dump_template_parameter (TREE_VEC_ELT (inner_parms, i), flags);\n             }\n-          print_template_argument_list_end (scratch_buffer);\n-          output_add_space (scratch_buffer);\n+          pp_template_argument_list_end (cxx_pp);\n+          pp_space (cxx_pp);\n         }\n       nreverse(orig_parms);\n \n       if (DECL_TEMPLATE_TEMPLATE_PARM_P (t))\n \t/* Say `template<arg> class TT' not just `template<arg> TT'.  */\n-\toutput_add_string (scratch_buffer, \"class \");\n+\tpp_string (cxx_pp, \"class \");\n     }\n \n   if (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == TYPE_DECL)\n@@ -1101,9 +1086,9 @@ dump_function_decl (tree t, int flags)\n   if (!(flags & TFF_DECL_SPECIFIERS))\n     /* OK */;\n   else if (DECL_STATIC_FUNCTION_P (t))\n-    print_identifier (scratch_buffer, \"static \");\n+    pp_identifier (cxx_pp, \"static \");\n   else if (DECL_VIRTUAL_P (t))\n-    print_identifier (scratch_buffer, \"virtual \");\n+    pp_identifier (cxx_pp, \"virtual \");\n \n   /* Print the return type?  */\n   if (show_return)\n@@ -1112,14 +1097,14 @@ dump_function_decl (tree t, int flags)\n   if (show_return)\n     {\n       dump_type_prefix (TREE_TYPE (fntype), flags);\n-      output_add_space (scratch_buffer);\n+      pp_space (cxx_pp);\n     }\n \n   /* Print the function name.  */\n   if (cname)\n     {\n       dump_type (cname, flags);\n-      print_scope_operator (scratch_buffer);\n+      pp_colon_colon (cxx_pp);\n     }\n   else\n     dump_scope (CP_DECL_CONTEXT (t), flags);\n@@ -1144,9 +1129,9 @@ dump_function_decl (tree t, int flags)\n   /* If T is a template instantiation, dump the parameter binding.  */\n   if (template_parms != NULL_TREE && template_args != NULL_TREE)\n     {\n-      output_add_string (scratch_buffer, \" [with \");\n+      pp_string (cxx_pp, \" [with \");\n       dump_template_bindings (template_parms, template_args);\n-      print_right_bracket (scratch_buffer);\n+      pp_right_bracket (cxx_pp);\n     }\n }\n \n@@ -1159,29 +1144,29 @@ dump_parameters (tree parmtypes, int flags)\n {\n   int first;\n \n-  print_left_paren (scratch_buffer);\n+  pp_left_paren (cxx_pp);\n \n   for (first = 1; parmtypes != void_list_node;\n        parmtypes = TREE_CHAIN (parmtypes))\n     {\n       if (!first)\n-        separate_with_comma (scratch_buffer);\n+        pp_separate_with_comma (cxx_pp);\n       first = 0;\n       if (!parmtypes)\n         {\n-          print_identifier (scratch_buffer, \"...\");\n+          pp_identifier (cxx_pp, \"...\");\n           break;\n         }\n       dump_type (TREE_VALUE (parmtypes), flags);\n \n       if ((flags & TFF_FUNCTION_DEFAULT_ARGUMENTS) && TREE_PURPOSE (parmtypes))\n         {\n-          output_add_string (scratch_buffer, \" = \");\n+          pp_string (cxx_pp, \" = \");\n           dump_expr (TREE_PURPOSE (parmtypes), flags | TFF_EXPR_IN_PARENS);\n         }\n     }\n \n-  print_right_paren (scratch_buffer);\n+  pp_right_paren (cxx_pp);\n }\n \n /* Print an exception specification. T is the exception specification.  */\n@@ -1191,17 +1176,17 @@ dump_exception_spec (tree t, int flags)\n {\n   if (t)\n     {\n-      output_add_string (scratch_buffer, \" throw (\");\n+      pp_string (cxx_pp, \" throw (\");\n       if (TREE_VALUE (t) != NULL_TREE)\n         while (1)\n           {\n             dump_type (TREE_VALUE (t), flags);\n             t = TREE_CHAIN (t);\n             if (!t)\n               break;\n-            separate_with_comma (scratch_buffer);\n+            pp_separate_with_comma (cxx_pp);\n           }\n-      print_right_paren (scratch_buffer);\n+      pp_right_paren (cxx_pp);\n     }\n }\n \n@@ -1223,7 +1208,7 @@ dump_function_name (tree t, int flags)\n \n   if (DECL_DESTRUCTOR_P (t))\n     {\n-      output_add_character (scratch_buffer, '~');\n+      pp_complement (cxx_pp);\n       dump_decl (name, TFF_PLAIN_IDENTIFIER);\n     }\n   else if (DECL_CONV_FN_P (t))\n@@ -1234,11 +1219,11 @@ dump_function_name (tree t, int flags)\n \t declarations, both will have the same name, yet\n \t the types will be different, hence the TREE_TYPE field\n \t of the first name will be clobbered by the second.  */\n-      output_add_string (scratch_buffer, \"operator \");\n+      pp_string (cxx_pp, \"operator \");\n       dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n     }\n   else if (IDENTIFIER_OPNAME_P (name))\n-    print_tree_identifier (scratch_buffer, name);\n+    pp_tree_identifier (cxx_pp, name);\n   else\n     dump_decl (name, flags);\n \n@@ -1265,7 +1250,7 @@ dump_template_parms (tree info, int primary, int flags)\n   if (primary && flags & TFF_TEMPLATE_NAME)\n     return;\n   flags &= ~(TFF_CLASS_KEY_OR_ENUM | TFF_TEMPLATE_NAME);\n-  print_template_argument_list_start (scratch_buffer);\n+  pp_template_argument_list_start (cxx_pp);\n \n   /* Be careful only to print things when we have them, so as not\n \t to crash producing error messages.  */\n@@ -1299,10 +1284,10 @@ dump_template_parms (tree info, int primary, int flags)\n               args = TREE_CHAIN (args);\n             }\n           if (need_comma)\n-            separate_with_comma (scratch_buffer);\n+            pp_separate_with_comma (cxx_pp);\n           \n           if (!arg)\n-            print_identifier (scratch_buffer, \"<template parameter error>\");\n+            pp_identifier (cxx_pp, \"<template parameter error>\");\n           else\n             dump_template_argument (arg, flags);\n           need_comma = 1;\n@@ -1322,12 +1307,12 @@ dump_template_parms (tree info, int primary, int flags)\n           tree parm = TREE_VALUE (TREE_VEC_ELT (parms, ix));\n \n           if (ix)\n-            separate_with_comma (scratch_buffer);\n+            pp_separate_with_comma (cxx_pp);\n \n           dump_decl (parm, flags & ~TFF_DECL_SPECIFIERS);\n         }\n     }\n-  print_template_argument_list_end (scratch_buffer);\n+  pp_template_argument_list_end (cxx_pp);\n }\n \n static void\n@@ -1336,40 +1321,40 @@ dump_char (int c)\n   switch (c)\n     {\n     case TARGET_NEWLINE:\n-      output_add_string (scratch_buffer, \"\\\\n\");\n+      pp_string (cxx_pp, \"\\\\n\");\n       break;\n     case TARGET_TAB:\n-      output_add_string (scratch_buffer, \"\\\\t\");\n+      pp_string (cxx_pp, \"\\\\t\");\n       break;\n     case TARGET_VT:\n-      output_add_string (scratch_buffer, \"\\\\v\");\n+      pp_string (cxx_pp, \"\\\\v\");\n       break;\n     case TARGET_BS:\n-      output_add_string (scratch_buffer, \"\\\\b\");\n+      pp_string (cxx_pp, \"\\\\b\");\n       break;\n     case TARGET_CR:\n-      output_add_string (scratch_buffer, \"\\\\r\");\n+      pp_string (cxx_pp, \"\\\\r\");\n       break;\n     case TARGET_FF:\n-      output_add_string (scratch_buffer, \"\\\\f\");\n+      pp_string (cxx_pp, \"\\\\f\");\n       break;\n     case TARGET_BELL:\n-      output_add_string (scratch_buffer, \"\\\\a\");\n+      pp_string (cxx_pp, \"\\\\a\");\n       break;\n     case '\\\\':\n-      output_add_string (scratch_buffer, \"\\\\\\\\\");\n+      pp_string (cxx_pp, \"\\\\\\\\\");\n       break;\n     case '\\'':\n-      output_add_string (scratch_buffer, \"\\\\'\");\n+      pp_string (cxx_pp, \"\\\\'\");\n       break;\n     case '\\\"':\n-      output_add_string (scratch_buffer, \"\\\\\\\"\");\n+      pp_string (cxx_pp, \"\\\\\\\"\");\n       break;\n     default:\n       if (ISPRINT (c))\n-\toutput_add_character (scratch_buffer, c);\n+\tpp_character (cxx_pp, c);\n       else\n-        output_formatted_scalar (scratch_buffer, \"\\\\%03o\", (unsigned) c);\n+        pp_scalar (cxx_pp, \"\\\\%03o\", (unsigned) c);\n       break;\n     }\n }\n@@ -1384,7 +1369,7 @@ dump_expr_list (tree l, int flags)\n       dump_expr (TREE_VALUE (l), flags | TFF_EXPR_IN_PARENS);\n       l = TREE_CHAIN (l);\n       if (l)\n-\tseparate_with_comma (scratch_buffer);\n+\tpp_separate_with_comma (cxx_pp);\n     }\n }\n \n@@ -1426,32 +1411,32 @@ dump_expr (tree t, int flags)\n \t        break;\n \n \t    if (values)\n-\t      print_tree_identifier (scratch_buffer, TREE_PURPOSE (values));\n+\t      pp_tree_identifier (cxx_pp, TREE_PURPOSE (values));\n \t    else\n \t      {\n                 /* Value must have been cast.  */\n-                print_left_paren (scratch_buffer);\n+                pp_left_paren (cxx_pp);\n                 dump_type (type, flags);\n-                print_right_paren (scratch_buffer);\n+                pp_right_paren (cxx_pp);\n                 goto do_int;\n \t      }\n \t  }\n \telse if (type == boolean_type_node)\n \t  {\n \t    if (t == boolean_false_node || integer_zerop (t))\n-\t      print_identifier (scratch_buffer, \"false\");\n+\t      pp_identifier (cxx_pp, \"false\");\n \t    else if (t == boolean_true_node)\n-\t      print_identifier (scratch_buffer, \"true\");\n+\t      pp_identifier (cxx_pp, \"true\");\n \t  }\n \telse if (type == char_type_node)\n \t  {\n-\t    output_add_character (scratch_buffer, '\\'');\n+            pp_quote (cxx_pp);\n \t    if (host_integerp (t, TREE_UNSIGNED (type)))\n \t      dump_char (tree_low_cst (t, TREE_UNSIGNED (type)));\n \t    else\n-\t      output_printf (scratch_buffer, \"\\\\x%x\",\n-\t\t\t     (unsigned int) TREE_INT_CST_LOW (t));\n-\t    output_add_character (scratch_buffer, '\\'');\n+\t      pp_printf (cxx_pp, \"\\\\x%x\",\n+                         (unsigned int) TREE_INT_CST_LOW (t));\n+            pp_quote (cxx_pp);\n \t  }\n \telse\n \t  {\n@@ -1462,35 +1447,33 @@ dump_expr (tree t, int flags)\n \n \t        if (tree_int_cst_sgn (val) < 0)\n \t          {\n-\t\t    output_add_character (scratch_buffer, '-');\n+                    pp_minus (cxx_pp);\n \t\t    val = build_int_2 (-TREE_INT_CST_LOW (val),\n \t\t\t\t       ~TREE_INT_CST_HIGH (val)\n \t                               + !TREE_INT_CST_LOW (val));\n \t          }\n-\t\tsprintf (scratch_buffer->digit_buffer,\n+\t\tsprintf (cxx_pp->buffer->digit_buffer,\n                          HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n \t\t\t TREE_INT_CST_HIGH (val), TREE_INT_CST_LOW (val));\n-\t\toutput_add_string\n-                  (scratch_buffer, scratch_buffer->digit_buffer);\n+\t\tpp_string (cxx_pp, cxx_pp->buffer->digit_buffer);\n \t      }\n \t    else\n-\t      output_host_wide_integer (scratch_buffer, TREE_INT_CST_LOW (t));\n+\t      pp_wide_integer (cxx_pp, TREE_INT_CST_LOW (t));\n \t  }\n       }\n       break;\n \n     case REAL_CST:\n-      real_to_decimal (scratch_buffer->digit_buffer, &TREE_REAL_CST (t),\n-\t\t       sizeof (scratch_buffer->digit_buffer), 0, 1);\n-      output_add_string (scratch_buffer, scratch_buffer->digit_buffer);\n+      real_to_decimal (cxx_pp->buffer->digit_buffer, &TREE_REAL_CST (t),\n+\t\t       sizeof (cxx_pp->buffer->digit_buffer), 0, 1);\n+      pp_string (cxx_pp, cxx_pp->buffer->digit_buffer);\n       break;\n \n     case PTRMEM_CST:\n-      output_add_character (scratch_buffer, '&');\n+      pp_ampersand (cxx_pp);\n       dump_type (PTRMEM_CST_CLASS (t), flags);\n-      print_scope_operator (scratch_buffer);\n-      print_tree_identifier\n-        (scratch_buffer, DECL_NAME (PTRMEM_CST_MEMBER (t)));\n+      pp_colon_colon (cxx_pp);\n+      pp_tree_identifier (cxx_pp, DECL_NAME (PTRMEM_CST_MEMBER (t)));\n       break;\n \n     case STRING_CST:\n@@ -1499,15 +1482,15 @@ dump_expr (tree t, int flags)\n \tint len = TREE_STRING_LENGTH (t) - 1;\n \tint i;\n \n-\toutput_add_character (scratch_buffer, '\\\"');\n+\tpp_doublequote (cxx_pp);\n \tfor (i = 0; i < len; i++)\n \t  dump_char (p[i]);\n-\toutput_add_character (scratch_buffer, '\\\"');\n+\tpp_doublequote (cxx_pp);\n       }\n       break;\n \n     case COMPOUND_EXPR:\n-      print_left_paren (scratch_buffer);\n+      pp_left_paren (cxx_pp);\n       /* Within templates, a COMPOUND_EXPR has only one operand,\n          containing a TREE_LIST of the two operands.  */\n       if (TREE_CODE (TREE_OPERAND (t, 0)) == TREE_LIST)\n@@ -1519,32 +1502,30 @@ dump_expr (tree t, int flags)\n       else\n       {\n         dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-        separate_with_comma (scratch_buffer);\n+        pp_separate_with_comma (cxx_pp);\n         dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n       }\n-      print_right_paren (scratch_buffer);\n+      pp_right_paren (cxx_pp);\n       break;\n \n     case COND_EXPR:\n-      print_left_paren (scratch_buffer);\n+      pp_left_paren (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-      output_add_string (scratch_buffer, \" ? \");\n+      pp_string (cxx_pp, \" ? \");\n       dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n-      output_add_string (scratch_buffer, \" : \");\n+      pp_string (cxx_pp, \" : \");\n       dump_expr (TREE_OPERAND (t, 2), flags | TFF_EXPR_IN_PARENS);\n-      print_right_paren (scratch_buffer);\n+      pp_right_paren (cxx_pp);\n       break;\n \n     case SAVE_EXPR:\n       if (TREE_HAS_CONSTRUCTOR (t))\n \t{\n-\t  output_add_string (scratch_buffer, \"new \");\n+\t  pp_string (cxx_pp, \"new \");\n \t  dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n \t}\n       else\n-\t{\n-\t  dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-\t}\n+        dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n       break;\n \n     case AGGR_INIT_EXPR:\n@@ -1557,18 +1538,17 @@ dump_expr (tree t, int flags)\n \tif (fn && TREE_CODE (fn) == FUNCTION_DECL)\n \t  {\n \t    if (DECL_CONSTRUCTOR_P (fn))\n-\t      print_tree_identifier\n-                (scratch_buffer, TYPE_IDENTIFIER (TREE_TYPE (t)));\n+\t      pp_tree_identifier (cxx_pp, TYPE_IDENTIFIER (TREE_TYPE (t)));\n \t    else\n \t      dump_decl (fn, 0);\n \t  }\n \telse\n \t  dump_expr (TREE_OPERAND (t, 0), 0);\n       }\n-      print_left_paren (scratch_buffer);\n+      pp_left_paren (cxx_pp);\n       if (TREE_OPERAND (t, 1))\n \tdump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)), flags);\n-      print_right_paren (scratch_buffer);\n+      pp_right_paren (cxx_pp);\n       break;\n \n     case CALL_EXPR:\n@@ -1585,20 +1565,20 @@ dump_expr (tree t, int flags)\n \t    if (TREE_CODE (ob) == ADDR_EXPR)\n \t      {\n \t\tdump_expr (TREE_OPERAND (ob, 0), flags | TFF_EXPR_IN_PARENS);\n-\t\toutput_add_character (scratch_buffer, '.');\n+\t\tpp_dot (cxx_pp);\n \t      }\n \t    else if (TREE_CODE (ob) != PARM_DECL\n \t\t     || strcmp (IDENTIFIER_POINTER (DECL_NAME (ob)), \"this\"))\n \t      {\n \t\tdump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n-\t\toutput_add_string (scratch_buffer, \"->\");\n+\t\tpp_arrow (cxx_pp);\n \t      }\n \t    args = TREE_CHAIN (args);\n \t  }\n \tdump_expr (fn, flags | TFF_EXPR_IN_PARENS);\n-\tprint_left_paren (scratch_buffer);\n+\tpp_left_paren (cxx_pp);\n \tdump_expr_list (args, flags);\n-\tprint_right_paren (scratch_buffer);\n+\tpp_right_paren (cxx_pp);\n       }\n       break;\n \n@@ -1607,13 +1587,13 @@ dump_expr (tree t, int flags)\n \ttree type = TREE_OPERAND (t, 1);\n \ttree init = TREE_OPERAND (t, 2);\n \tif (NEW_EXPR_USE_GLOBAL (t))\n-\t  print_scope_operator (scratch_buffer);\n-\toutput_add_string (scratch_buffer, \"new \");\n+          pp_colon_colon (cxx_pp);\n+\tpp_string (cxx_pp, \"new \");\n \tif (TREE_OPERAND (t, 0))\n \t  {\n-\t    print_left_paren (scratch_buffer);\n+\t    pp_left_paren (cxx_pp);\n \t    dump_expr_list (TREE_OPERAND (t, 0), flags);\n-\t    output_add_string (scratch_buffer, \") \");\n+\t    pp_string (cxx_pp, \") \");\n \t  }\n \tif (TREE_CODE (type) == ARRAY_REF)\n \t  type = build_cplus_array_type\n@@ -1624,7 +1604,7 @@ dump_expr (tree t, int flags)\n \tdump_type (type, flags);\n \tif (init)\n \t  {\n-\t    print_left_paren (scratch_buffer);\n+\t    pp_left_paren (cxx_pp);\n \t    if (TREE_CODE (init) == TREE_LIST)\n \t      dump_expr_list (init, flags);\n \t    else if (init == void_zero_node)\n@@ -1633,7 +1613,7 @@ dump_expr (tree t, int flags)\n \t      ;\n \t    else\n \t      dump_expr (init, flags);\n-\t    print_right_paren (scratch_buffer);\n+\t    pp_right_paren (cxx_pp);\n \t  }\n       }\n       break;\n@@ -1697,31 +1677,31 @@ dump_expr (tree t, int flags)\n \t\t|| strcmp (IDENTIFIER_POINTER (DECL_NAME (ob)), \"this\"))\n \t      {\n \t\tdump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n-\t\toutput_add_string (scratch_buffer, \"->\");\n+\t\tpp_arrow (cxx_pp);\n \t      }\n \t  }\n \telse\n \t  {\n \t    dump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n-\t    output_add_character (scratch_buffer, '.');\n+\t    pp_dot (cxx_pp);\n \t  }\n \tdump_expr (TREE_OPERAND (t, 1), flags & ~TFF_EXPR_IN_PARENS);\n       }\n       break;\n \n     case ARRAY_REF:\n       dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-      print_left_bracket (scratch_buffer);\n+      pp_left_bracket (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n-      print_right_bracket (scratch_buffer);\n+      pp_right_bracket (cxx_pp);\n       break;\n \n     case CONVERT_EXPR:\n       if (TREE_TYPE (t) && VOID_TYPE_P (TREE_TYPE (t)))\n \t{\n-\t  print_left_paren (scratch_buffer);\n+\t  pp_left_paren (cxx_pp);\n \t  dump_type (TREE_TYPE (t), flags);\n-\t  print_right_paren (scratch_buffer);\n+\t  pp_right_paren (cxx_pp);\n \t  dump_expr (TREE_OPERAND (t, 0), flags);\n \t}\n       else\n@@ -1747,9 +1727,9 @@ dump_expr (tree t, int flags)\n \t  t = TREE_OPERAND (t, 0);\n \t  my_friendly_assert (TREE_CODE (t) == CALL_EXPR, 237);\n \t  dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-\t  print_left_paren (scratch_buffer);\n+\t  pp_left_paren (cxx_pp);\n \t  dump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)), flags);\n-\t  print_right_paren (scratch_buffer);\n+\t  pp_right_paren (cxx_pp);\n \t}\n       else\n \t{\n@@ -1772,11 +1752,10 @@ dump_expr (tree t, int flags)\n \n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n-      print_left_paren (scratch_buffer);\n+      pp_left_paren (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-      print_identifier\n-        (scratch_buffer, operator_name_info[(int)TREE_CODE (t)].name);\n-      print_right_paren (scratch_buffer);\n+      pp_identifier (cxx_pp, operator_name_info[(int)TREE_CODE (t)].name);\n+      pp_right_paren (cxx_pp);\n       break;\n \n     case NON_LVALUE_EXPR:\n@@ -1793,11 +1772,11 @@ dump_expr (tree t, int flags)\n \t  if (TREE_CODE (next) == FUNCTION_TYPE)\n \t    {\n \t      if (flags & TFF_EXPR_IN_PARENS)\n-\t        print_left_paren (scratch_buffer);\n-\t      output_add_character (scratch_buffer, '*');\n+\t        pp_left_paren (cxx_pp);\n+\t      pp_star (cxx_pp);\n \t      dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n \t      if (flags & TFF_EXPR_IN_PARENS)\n-\t        print_right_paren (scratch_buffer);\n+\t        pp_right_paren (cxx_pp);\n \t      break;\n \t    }\n \t  /* else FALLTHRU */\n@@ -1821,9 +1800,11 @@ dump_expr (tree t, int flags)\n \t  if (integer_zerop (idx))\n \t    {\n \t      /* A NULL pointer-to-member constant.  */\n-\t      output_add_string (scratch_buffer, \"((\");\n+              pp_left_paren (cxx_pp);\n+              pp_left_paren (cxx_pp);\n \t      dump_type (TREE_TYPE (t), flags);\n-\t      output_add_string (scratch_buffer, \") 0)\");\n+              pp_right_paren (cxx_pp);\n+              pp_string (cxx_pp, \")0)\");\n \t      break;\n \t    }\n \t  else if (host_integerp (idx, 0))\n@@ -1857,14 +1838,14 @@ dump_expr (tree t, int flags)\n       if (TREE_TYPE (t) && !CONSTRUCTOR_ELTS (t))\n \t{\n \t  dump_type (TREE_TYPE (t), 0);\n-\t  output_add_character (scratch_buffer, '(');\n-\t  output_add_character (scratch_buffer, ')');\n+          pp_left_paren (cxx_pp);\n+          pp_right_paren (cxx_pp);\n \t}\n       else\n \t{\n-\t  output_add_character (scratch_buffer, '{');\n+          pp_left_brace (cxx_pp);\n \t  dump_expr_list (CONSTRUCTOR_ELTS (t), flags);\n-\t  output_add_character (scratch_buffer, '}');\n+          pp_right_brace (cxx_pp);\n \t}\n       \n       break;\n@@ -1889,12 +1870,12 @@ dump_expr (tree t, int flags)\n \t    if (TREE_CODE (ob) == INDIRECT_REF)\n \t      {\n \t\tdump_expr (TREE_OPERAND (ob, 0), flags | TFF_EXPR_IN_PARENS);\n-\t\toutput_add_string (scratch_buffer, \"->*\");\n+\t\tpp_string (cxx_pp, \"->*\");\n \t      }\n \t    else\n \t      {\n \t\tdump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n-\t\toutput_add_string (scratch_buffer, \".*\");\n+\t\tpp_string (cxx_pp, \".*\");\n \t      }\n \t    dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n \t  }\n@@ -1907,7 +1888,7 @@ dump_expr (tree t, int flags)\n \n     case SCOPE_REF:\n       dump_type (TREE_OPERAND (t, 0), flags);\n-      print_scope_operator (scratch_buffer);\n+      pp_colon_colon (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n       break;\n \n@@ -1916,69 +1897,68 @@ dump_expr (tree t, int flags)\n \t  || TREE_CHAIN (TREE_OPERAND (t, 0)))\n \t{\n \t  dump_type (TREE_TYPE (t), flags);\n-\t  print_left_paren (scratch_buffer);\n+\t  pp_left_paren (cxx_pp);\n \t  dump_expr_list (TREE_OPERAND (t, 0), flags);\n-\t  print_right_paren (scratch_buffer);\n+\t  pp_right_paren (cxx_pp);\n \t}\n       else\n \t{\n-\t  print_left_paren (scratch_buffer);\n+\t  pp_left_paren (cxx_pp);\n \t  dump_type (TREE_TYPE (t), flags);\n-          output_add_string (scratch_buffer, \")(\");\n+          pp_string (cxx_pp, \")(\");\n \t  dump_expr_list (TREE_OPERAND (t, 0), flags);\n-\t  print_right_paren (scratch_buffer);\n+\t  pp_right_paren (cxx_pp);\n \t}\n       break;\n \n     case STATIC_CAST_EXPR:\n-      output_add_string (scratch_buffer, \"static_cast<\");\n+      pp_string (cxx_pp, \"static_cast<\");\n       goto cast;\n     case REINTERPRET_CAST_EXPR:\n-      output_add_string (scratch_buffer, \"reinterpret_cast<\");\n+      pp_string (cxx_pp, \"reinterpret_cast<\");\n       goto cast;\n     case CONST_CAST_EXPR:\n-      output_add_string (scratch_buffer, \"const_cast<\");\n+      pp_string (cxx_pp, \"const_cast<\");\n       goto cast;\n     case DYNAMIC_CAST_EXPR:\n-      output_add_string (scratch_buffer, \"dynamic_cast<\");\n+      pp_string (cxx_pp, \"dynamic_cast<\");\n     cast:\n       dump_type (TREE_TYPE (t), flags);\n-      output_add_string (scratch_buffer, \">(\");\n+      pp_string (cxx_pp, \">(\");\n       dump_expr (TREE_OPERAND (t, 0), flags);\n-      print_right_paren (scratch_buffer);\n+      pp_right_paren (cxx_pp);\n       break;\n \n     case ARROW_EXPR:\n       dump_expr (TREE_OPERAND (t, 0), flags);\n-      output_add_string (scratch_buffer, \"->\");\n+      pp_arrow (cxx_pp);\n       break;\n \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n       if (TREE_CODE (t) == SIZEOF_EXPR)\n-\toutput_add_string (scratch_buffer, \"sizeof (\");\n+\tpp_string (cxx_pp, \"sizeof (\");\n       else\n \t{\n \t  my_friendly_assert (TREE_CODE (t) == ALIGNOF_EXPR, 0);\n-\t  output_add_string (scratch_buffer, \"__alignof__ (\");\n+\t  pp_string (cxx_pp, \"__alignof__ (\");\n \t}\n       if (TYPE_P (TREE_OPERAND (t, 0)))\n \tdump_type (TREE_OPERAND (t, 0), flags);\n       else\n         dump_expr (TREE_OPERAND (t, 0), flags);\n-      print_right_paren (scratch_buffer);\n+      pp_right_paren (cxx_pp);\n       break;\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      print_identifier (scratch_buffer,\n-                        operator_name_info[TREE_CODE (t)].name);\n-      output_add_space (scratch_buffer);\n+      pp_identifier (cxx_pp, operator_name_info[TREE_CODE (t)].name);\n+      pp_space (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 0), flags);\n       break;\n \n     case DEFAULT_ARG:\n-      print_identifier (scratch_buffer, \"<unparsed>\");\n+      pp_identifier (cxx_pp, \"<unparsed>\");\n       break;\n \n     case TRY_CATCH_EXPR:\n@@ -1989,9 +1969,10 @@ dump_expr (tree t, int flags)\n \n     case PSEUDO_DTOR_EXPR:\n       dump_expr (TREE_OPERAND (t, 2), flags);\n-      output_add_character (scratch_buffer, '.');\n+      pp_dot (cxx_pp);\n       dump_type (TREE_OPERAND (t, 0), flags);\n-      output_add_string (scratch_buffer, \"::~\");\n+      pp_colon_colon (cxx_pp);\n+      pp_complement (cxx_pp);\n       dump_type (TREE_OPERAND (t, 1), flags);\n       break;\n \n@@ -2002,25 +1983,25 @@ dump_expr (tree t, int flags)\n     case STMT_EXPR:\n       /* We don't yet have a way of dumping statements in a\n \t human-readable format.  */\n-      output_add_string (scratch_buffer, \"({...})\");\n+      pp_string (cxx_pp, \"({...})\");\n       break;\n \n     case BIND_EXPR:\n-      output_add_character (scratch_buffer, '{');\n+      pp_left_brace (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 1), flags & ~TFF_EXPR_IN_PARENS);\n-      output_add_character (scratch_buffer, '}');\n+      pp_right_brace (cxx_pp);\n       break;\n \n     case LOOP_EXPR:\n-      output_add_string (scratch_buffer, \"while (1) { \");\n+      pp_string (cxx_pp, \"while (1) { \");\n       dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n-      output_add_character (scratch_buffer, '}');\n+      pp_right_brace (cxx_pp);\n       break;\n \n     case EXIT_EXPR:\n-      output_add_string (scratch_buffer, \"if (\");\n+      pp_string (cxx_pp, \"if (\");\n       dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n-      output_add_string (scratch_buffer, \") break; \");\n+      pp_string (cxx_pp, \") break; \");\n       break;\n \n     case BASELINK:\n@@ -2029,52 +2010,52 @@ dump_expr (tree t, int flags)\n \n     case EMPTY_CLASS_EXPR:\n       dump_type (TREE_TYPE (t), flags);\n-      print_left_paren (scratch_buffer);\n-      print_right_paren (scratch_buffer);\n+      pp_left_paren (cxx_pp);\n+      pp_right_paren (cxx_pp);\n       break;\n \n     case NON_DEPENDENT_EXPR:\n-      output_add_string (scratch_buffer, \"<expression of type \");\n+      pp_string (cxx_pp, \"<expression of type \");\n       dump_type (TREE_TYPE (t), flags);\n-      output_add_character (scratch_buffer, '>');\n+      pp_greater (cxx_pp);\n       break;\n \n       /*  This list is incomplete, but should suffice for now.\n \t  It is very important that `sorry' does not call\n \t  `report_error_function'.  That could cause an infinite loop.  */\n     default:\n-      sorry_for_unsupported_tree (t);\n+      pp_unsupported_tree (cxx_pp, t);\n       /* fall through to ERROR_MARK...  */\n     case ERROR_MARK:\n-      print_identifier (scratch_buffer, \"<expression error>\");\n+      pp_identifier (cxx_pp, \"<expression error>\");\n       break;\n     }\n }\n \n static void\n dump_binary_op (const char *opstring, tree t, int flags)\n {\n-  print_left_paren (scratch_buffer);\n+  pp_left_paren (cxx_pp);\n   dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-  output_add_space (scratch_buffer);\n+  pp_space (cxx_pp);\n   if (opstring)\n-    print_identifier (scratch_buffer, opstring);\n+    pp_identifier (cxx_pp, opstring);\n   else\n-    print_identifier (scratch_buffer, \"<unknown operator>\");\n-  output_add_space (scratch_buffer);\n+    pp_identifier (cxx_pp, \"<unknown operator>\");\n+  pp_space (cxx_pp);\n   dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n-  print_right_paren (scratch_buffer);\n+  pp_right_paren (cxx_pp);\n }\n \n static void\n dump_unary_op (const char *opstring, tree t, int flags)\n {\n   if (flags & TFF_EXPR_IN_PARENS)\n-    print_left_paren (scratch_buffer);\n-  print_identifier (scratch_buffer, opstring);\n+    pp_left_paren (cxx_pp);\n+  pp_identifier (cxx_pp, opstring);\n   dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n   if (flags & TFF_EXPR_IN_PARENS)\n-    print_right_paren (scratch_buffer);\n+    pp_right_paren (cxx_pp);\n }\n \n /* Exported interface to stringifying types, exprs and decls under TFF_*\n@@ -2083,41 +2064,33 @@ dump_unary_op (const char *opstring, tree t, int flags)\n const char *\n type_as_string (tree typ, int flags)\n {\n-  reinit_global_formatting_buffer ();\n-\n+  pp_clear_output_area (cxx_pp);\n   dump_type (typ, flags);\n-\n-  return output_finalize_message (scratch_buffer);\n+  return pp_formatted_text (cxx_pp);\n }\n \n const char *\n expr_as_string (tree decl, int flags)\n {\n-  reinit_global_formatting_buffer ();\n-\n+  pp_clear_output_area (cxx_pp);\n   dump_expr (decl, flags);\n-\n-  return output_finalize_message (scratch_buffer);\n+  return pp_formatted_text (cxx_pp);\n }\n \n const char *\n decl_as_string (tree decl, int flags)\n {\n-  reinit_global_formatting_buffer ();\n-\n+  pp_clear_output_area (cxx_pp);\n   dump_decl (decl, flags);\n-\n-  return output_finalize_message (scratch_buffer);\n+  return pp_formatted_text (cxx_pp);\n }\n \n const char *\n context_as_string (tree context, int flags)\n {\n-  reinit_global_formatting_buffer ();\n-\n+  pp_clear_output_area (cxx_pp);\n   dump_scope (context, flags);\n-\n-  return output_finalize_message (scratch_buffer);\n+  return pp_formatted_text (cxx_pp);\n }\n \n /* Generate the three forms of printable names for cxx_printable_name.  */\n@@ -2128,20 +2101,19 @@ lang_decl_name (tree decl, int v)\n   if (v >= 2)\n     return decl_as_string (decl, TFF_DECL_SPECIFIERS);\n \n-  reinit_global_formatting_buffer ();\n-\n+  pp_clear_output_area (cxx_pp);\n   if (v == 1 && DECL_CLASS_SCOPE_P (decl))\n     {\n       dump_type (CP_DECL_CONTEXT (decl), TFF_PLAIN_IDENTIFIER);\n-      print_scope_operator (scratch_buffer);\n+      pp_colon_colon (cxx_pp);\n     }\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     dump_function_name (decl, TFF_PLAIN_IDENTIFIER);\n   else\n     dump_decl (DECL_NAME (decl), TFF_PLAIN_IDENTIFIER);\n \n-  return output_finalize_message (scratch_buffer);\n+  return pp_formatted_text (cxx_pp);\n }\n \n static location_t\n@@ -2175,21 +2147,17 @@ decl_to_string (tree decl, int verbose)\n     flags |= TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE;\n   flags |= TFF_TEMPLATE_HEADER;\n \n-  reinit_global_formatting_buffer ();\n-\n+  pp_clear_output_area (cxx_pp);\n   dump_decl (decl, flags);\n-\n-  return output_finalize_message (scratch_buffer);\n+  return pp_formatted_text (cxx_pp);\n }\n \n static const char *\n expr_to_string (tree decl)\n {\n-  reinit_global_formatting_buffer ();\n-\n+  pp_clear_output_area (cxx_pp);\n   dump_expr (decl, 0);\n-\n-  return output_finalize_message (scratch_buffer);\n+  return pp_formatted_text (cxx_pp);\n }\n \n static const char *\n@@ -2200,11 +2168,9 @@ fndecl_to_string (tree fndecl, int verbose)\n   flags = TFF_EXCEPTION_SPECIFICATION | TFF_DECL_SPECIFIERS;\n   if (verbose)\n     flags |= TFF_FUNCTION_DEFAULT_ARGUMENTS;\n-  reinit_global_formatting_buffer ();\n-\n+  pp_clear_output_area (cxx_pp);\n   dump_decl (fndecl, flags);\n-\n-  return output_finalize_message (scratch_buffer);\n+  return pp_formatted_text (cxx_pp);\n }\n \n \n@@ -2239,48 +2205,38 @@ language_to_string (enum languages c)\n static const char *\n parm_to_string (int p)\n {\n-  reinit_global_formatting_buffer ();\n-\n+  pp_clear_output_area (cxx_pp);\n   if (p < 0)\n-    output_add_string (scratch_buffer, \"'this'\");\n+    pp_string (cxx_pp, \"'this'\");\n   else\n-    output_decimal (scratch_buffer, p + 1);\n-\n-  return output_finalize_message (scratch_buffer);\n+    pp_decimal_int (cxx_pp, p + 1);\n+  return pp_formatted_text (cxx_pp);\n }\n \n static const char *\n op_to_string (enum tree_code p)\n {\n-  tree id;\n-\n-  id = operator_name_info[(int) p].identifier;\n+  tree id = operator_name_info[(int) p].identifier;\n   return id ? IDENTIFIER_POINTER (id) : \"<unknown>\";\n }\n \n static const char *\n type_to_string (tree typ, int verbose)\n {\n-  int flags;\n-\n-  flags = 0;\n+  int flags = 0;\n   if (verbose)\n     flags |= TFF_CLASS_KEY_OR_ENUM;\n   flags |= TFF_TEMPLATE_HEADER;\n \n-  reinit_global_formatting_buffer ();\n-\n+  pp_clear_output_area (cxx_pp);\n   dump_type (typ, flags);\n-\n-  return output_finalize_message (scratch_buffer);\n+  return pp_formatted_text (cxx_pp);\n }\n \n static const char *\n assop_to_string (enum tree_code p)\n {\n-  tree id;\n-\n-  id = assignment_operator_name_info[(int) p].identifier;\n+  tree id = assignment_operator_name_info[(int) p].identifier;\n   return id ? IDENTIFIER_POINTER (id) : \"{unknown}\";\n }\n \n@@ -2297,35 +2253,33 @@ args_to_string (tree p, int verbose)\n   if (TYPE_P (TREE_VALUE (p)))\n     return type_as_string (p, flags);\n \n-  reinit_global_formatting_buffer ();\n+  pp_clear_output_area (cxx_pp);\n   for (; p; p = TREE_CHAIN (p))\n     {\n       if (TREE_VALUE (p) == null_node)\n-\tprint_identifier (scratch_buffer, \"NULL\");\n+\tpp_identifier (cxx_pp, \"NULL\");\n       else\n \tdump_type (error_type (TREE_VALUE (p)), flags);\n       if (TREE_CHAIN (p))\n-\tseparate_with_comma (scratch_buffer);\n+\tpp_separate_with_comma (cxx_pp);\n     }\n-  return output_finalize_message (scratch_buffer);\n+  return pp_formatted_text (cxx_pp);\n }\n \n static const char *\n cv_to_string (tree p, int v)\n {\n-  reinit_global_formatting_buffer ();\n-\n+  pp_clear_output_area (cxx_pp);\n   dump_qualifiers (p, v ? before : none);\n-\n-  return output_finalize_message (scratch_buffer);\n+  return pp_formatted_text (cxx_pp);\n }\n \n /* Langhook for print_error_function.  */\n void\n cxx_print_error_function (diagnostic_context *context, const char *file)\n {\n   lhd_print_error_function (context, file);\n-  output_set_prefix (&context->buffer, file);\n+  pp_set_prefix (context->printer, file);\n   maybe_print_instantiation_context (context);\n }\n \n@@ -2336,14 +2290,14 @@ cp_diagnostic_starter (diagnostic_context *context,\n   diagnostic_report_current_module (context);\n   cp_print_error_function (context, diagnostic);\n   maybe_print_instantiation_context (context);\n-  output_set_prefix (&context->buffer, diagnostic_build_prefix (diagnostic));\n+  pp_set_prefix (context->printer, diagnostic_build_prefix (diagnostic));\n }\n \n static void\n cp_diagnostic_finalizer (diagnostic_context *context,\n                          diagnostic_info *diagnostic ATTRIBUTE_UNUSED)\n {\n-  output_destroy_prefix (&context->buffer);\n+  pp_destroy_prefix (context->printer);\n }\n \n /* Print current function onto BUFFER, in the process of reporting\n@@ -2354,24 +2308,24 @@ cp_print_error_function (diagnostic_context *context,\n {\n   if (diagnostic_last_function_changed (context))\n     {\n-      const char *old_prefix = output_prefix (&context->buffer);\n+      const char *old_prefix = context->printer->prefix;\n       char *new_prefix = diagnostic->location.file\n         ? file_name_as_prefix (diagnostic->location.file)\n         : NULL;\n \n-      output_set_prefix (&context->buffer, new_prefix);\n+      pp_set_prefix (context->printer, new_prefix);\n \n       if (current_function_decl == NULL)\n-        output_add_string (&context->buffer, \"At global scope:\");\n+        pp_string (context->printer, \"At global scope:\");\n       else\n-        output_printf (&context->buffer, \"In %s `%s':\",\n-                       function_category (current_function_decl),\n-                       cxx_printable_name (current_function_decl, 2));\n-      output_add_newline (&context->buffer);\n+        pp_printf (context->printer, \"In %s `%s':\",\n+                   function_category (current_function_decl),\n+                   cxx_printable_name (current_function_decl, 2));\n+      pp_newline (context->printer);\n \n       diagnostic_set_last_function (context);\n-      output_destroy_prefix (&context->buffer);\n-      context->buffer.state.prefix = old_prefix;\n+      pp_destroy_prefix (context->printer);\n+      context->printer->prefix = old_prefix;\n     }\n }\n \n@@ -2417,10 +2371,10 @@ print_instantiation_full_context (diagnostic_context *context)\n \t  if (current_function_decl == TINST_DECL (p))\n \t    /* Avoid redundancy with the the \"In function\" line.  */;\n \t  else\n-\t    output_verbatim (&context->buffer,\n-                             \"%s: In instantiation of `%s':\\n\", location.file,\n-                             decl_as_string (TINST_DECL (p),\n-                                             TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n+\t    pp_verbatim (context->printer,\n+                         \"%s: In instantiation of `%s':\\n\", location.file,\n+                         decl_as_string (TINST_DECL (p),\n+                                         TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n \n \t  location.line = TINST_LINE (p);\n \t  location.file = TINST_FILE (p);\n@@ -2438,16 +2392,15 @@ print_instantiation_partial_context (diagnostic_context *context,\n {\n   for (; t; t = TREE_CHAIN (t))\n     {\n-      output_verbatim\n-        (&context->buffer, \"%s:%d:   instantiated from `%s'\\n\",\n-\t loc.file, loc.line,\n-         decl_as_string (TINST_DECL (t),\n-\t\t\t TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n+      pp_verbatim (context->printer, \"%s:%d:   instantiated from `%s'\\n\",\n+                   loc.file, loc.line,\n+                   decl_as_string (TINST_DECL (t),\n+                                   TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n       loc.line = TINST_LINE (t);\n       loc.file = TINST_FILE (t);\n     }\n-  output_verbatim (&context->buffer, \"%s:%d:   instantiated from here\\n\",\n-\t\t   loc.file, loc.line);\n+  pp_verbatim (context->printer, \"%s:%d:   instantiated from here\\n\",\n+               loc.file, loc.line);\n }\n \n /* Called from cp_thing to print the template context for an error.  */\n@@ -2484,7 +2437,7 @@ print_instantiation_context (void)\n    %T   type.\n    %V   cv-qualifier.  */\n static bool\n-cp_printer (output_buffer *buffer, text_info *text)\n+cp_printer (pretty_printer *pp, text_info *text)\n {\n   int verbose = 0;\n   const char *result;\n@@ -2519,7 +2472,7 @@ cp_printer (output_buffer *buffer, text_info *text)\n       return false;\n     }\n \n-  output_add_string (buffer, result);\n+  pp_string (pp, result);\n   return true;\n #undef next_tree\n #undef next_tcode\n@@ -2528,13 +2481,13 @@ cp_printer (output_buffer *buffer, text_info *text)\n }\n \n static void\n-print_non_consecutive_character (output_buffer *buffer, int c)\n+pp_non_consecutive_character (pretty_printer *pp, int c)\n {\n-  const char *p = output_last_position (buffer);\n+  const char *p = pp_last_position_in_text (pp);\n \n   if (p != NULL && *p == c)\n-    output_add_space (buffer);\n-  output_add_character (buffer, c);\n+    pp_space (pp);\n+  pp_character (pp, c);\n }\n \n /* These are temporary wrapper functions which handle the historic"}, {"sha": "c226815c42d08fd76b66abcc3c34692f4d3fc31d", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 45, "deletions": 748, "changes": 793, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -39,56 +39,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n \n-#define output_text_length(BUFFER) (BUFFER)->line_length\n-#define is_starting_newline(BUFFER) (output_text_length (BUFFER) == 0)\n-#define line_wrap_cutoff(BUFFER) (BUFFER)->state.maximum_length\n-#define prefix_was_emitted_for(BUFFER) (BUFFER)->state.emitted_prefix_p\n-\n-/* Format an integer given by va_arg (ARG, type-specifier T) where\n-   type-specifier is a precision modifier as indicated by PREC.  F is\n-   a string used to construct the appropriate format-specifier.  */\n-#define output_integer_with_precision(BUFFER, ARG, PREC, T, F)  \\\n-  do                                                            \\\n-    switch (PREC)                                               \\\n-      {                                                         \\\n-      case 0:                                                   \\\n-        output_formatted_scalar                                 \\\n-          (BUFFER, \"%\" F, va_arg (ARG, T));                     \\\n-        break;                                                  \\\n-                                                                \\\n-      case 1:                                                   \\\n-        output_formatted_scalar                                 \\\n-          (BUFFER, \"%l\" F, va_arg (ARG, long T));               \\\n-        break;                                                  \\\n-                                                                \\\n-      case 2:                                                   \\\n-        output_formatted_scalar                                 \\\n-          (BUFFER, \"%ll\" F, va_arg (ARG, long long T));         \\\n-        break;                                                  \\\n-                                                                \\\n-      default:                                                  \\\n-        break;                                                  \\\n-      }                                                         \\\n-  while (0)\n-\n \n /* Prototypes.  */\n-static void output_flush (output_buffer *);\n-static void output_do_verbatim (output_buffer *, text_info *);\n-static void output_buffer_to_stream (output_buffer *);\n-static void output_format (output_buffer *, text_info *);\n-static void output_indent (output_buffer *);\n-\n-static char *build_message_string (const char *, ...)\n-     ATTRIBUTE_PRINTF_1;\n-static void format_with_decl (output_buffer *, text_info *, tree);\n-static void diagnostic_for_decl (diagnostic_context *, diagnostic_info *,\n-\t\t\t\t tree);\n-static void set_real_maximum_length (output_buffer *);\n-static void output_append_r (output_buffer *, const char *, int);\n-static void wrap_text (output_buffer *, const char *, const char *);\n-static void maybe_wrap_text (output_buffer *, const char *, const char *);\n-static void output_clear_data (output_buffer *);\n+static char *build_message_string (const char *, ...) ATTRIBUTE_PRINTF_1;\n \n static void default_diagnostic_starter (diagnostic_context *,\n \t\t\t\t\tdiagnostic_info *);\n@@ -116,482 +69,6 @@ with preprocessed source if appropriate.\\n\\\n See %s for instructions.\\n\"\n \n \f\n-/* Subroutine of output_set_maximum_length.  Set up BUFFER's\n-   internal maximum characters per line.  */\n-static void\n-set_real_maximum_length (output_buffer *buffer)\n-{\n-  /* If we're told not to wrap lines then do the obvious thing.  In case\n-   we'll emit prefix only once per diagnostic message, it is appropriate\n-  not to increase unnecessarily the line-length cut-off.  */\n-  if (!output_is_line_wrapping (buffer)\n-      || output_prefixing_rule (buffer) == DIAGNOSTICS_SHOW_PREFIX_ONCE\n-      || output_prefixing_rule (buffer) == DIAGNOSTICS_SHOW_PREFIX_NEVER)\n-    line_wrap_cutoff (buffer) = output_line_cutoff (buffer);\n-  else\n-    {\n-      int prefix_length = buffer->state.prefix ?\n-        strlen (buffer->state.prefix) : 0;\n-      /* If the prefix is ridiculously too long, output at least\n-         32 characters.  */\n-      if (output_line_cutoff (buffer) - prefix_length < 32)\n-\tline_wrap_cutoff (buffer) = output_line_cutoff (buffer) + 32;\n-      else\n-\tline_wrap_cutoff (buffer) = output_line_cutoff (buffer);\n-    }\n-}\n-\n-/* Sets the number of maximum characters per line BUFFER can output\n-   in line-wrapping mode.  A LENGTH value 0 suppresses line-wrapping.  */\n-void\n-output_set_maximum_length (output_buffer *buffer, int length)\n-{\n-  output_line_cutoff (buffer) = length;\n-  set_real_maximum_length (buffer);\n-}\n-\n-/* Sets BUFFER's PREFIX.  */\n-void\n-output_set_prefix (output_buffer *buffer, const char *prefix)\n-{\n-  buffer->state.prefix = prefix;\n-  set_real_maximum_length (buffer);\n-  prefix_was_emitted_for (buffer) = false;\n-  output_indentation (buffer) = 0;\n-}\n-\n-/*  Return a pointer to the last character emitted in the output\n-    BUFFER area.  A NULL pointer means no character available.  */\n-const char *\n-output_last_position (const output_buffer *buffer)\n-{\n-  const char *p = NULL;\n-\n-  if (obstack_base (&buffer->obstack) != obstack_next_free (&buffer->obstack))\n-    p = ((const char *) obstack_next_free (&buffer->obstack)) - 1;\n-  return p;\n-}\n-\n-/* Free BUFFER's prefix, a previously malloc'd string.  */\n-void\n-output_destroy_prefix (output_buffer *buffer)\n-{\n-  if (buffer->state.prefix != NULL)\n-    {\n-      free ((char *) buffer->state.prefix);\n-      buffer->state.prefix = NULL;\n-    }\n-}\n-\n-/* Zero out any text output so far in BUFFER.  */\n-void\n-output_clear_message_text (output_buffer *buffer)\n-{\n-  obstack_free (&buffer->obstack, obstack_base (&buffer->obstack));\n-  output_text_length (buffer) = 0;\n-}\n-\n-/* Zero out any formatting data used so far by BUFFER.  */\n-static void\n-output_clear_data (output_buffer *buffer)\n-{\n-  prefix_was_emitted_for (buffer) = false;\n-  output_indentation (buffer) = 0;\n-}\n-\n-/* Construct an output BUFFER with PREFIX and of MAXIMUM_LENGTH\n-   characters per line.  */\n-void\n-init_output_buffer (output_buffer *buffer, const char *prefix,\n-\t\t    int maximum_length)\n-{\n-  memset (buffer, 0, sizeof (output_buffer));\n-  obstack_init (&buffer->obstack);\n-  output_buffer_attached_stream (buffer) = stderr;\n-  output_line_cutoff (buffer) = maximum_length;\n-  output_prefixing_rule (buffer) = diagnostic_prefixing_rule (global_dc);\n-  output_set_prefix (buffer, prefix);\n-  output_text_length (buffer) = 0;\n-  output_clear_data (buffer);\n-}\n-\n-/* Reinitialize BUFFER.  */\n-void\n-output_clear (output_buffer *buffer)\n-{\n-  output_clear_message_text (buffer);\n-  output_clear_data (buffer);\n-}\n-\n-/* Finishes constructing a NULL-terminated character string representing\n-   the BUFFERed message.  */\n-const char *\n-output_finalize_message (output_buffer *buffer)\n-{\n-  obstack_1grow (&buffer->obstack, '\\0');\n-  return output_message_text (buffer);\n-}\n-\n-/* Return the amount of characters BUFFER can accept to\n-   make a full line.  */\n-int\n-output_space_left (const output_buffer *buffer)\n-{\n-  return line_wrap_cutoff (buffer) - output_text_length (buffer);\n-}\n-\n-/* Write out BUFFER's prefix.  */\n-void\n-output_emit_prefix (output_buffer *buffer)\n-{\n-  if (buffer->state.prefix != NULL)\n-    {\n-      switch (output_prefixing_rule (buffer))\n-\t{\n-\tdefault:\n-\tcase DIAGNOSTICS_SHOW_PREFIX_NEVER:\n-\t  break;\n-\n-\tcase DIAGNOSTICS_SHOW_PREFIX_ONCE:\n-\t  if (prefix_was_emitted_for (buffer))\n-\t    {\n-\t      output_indent (buffer);\n-\t      break;\n-\t    }\n-\t  output_indentation (buffer) += 3;\n-\t  /* Fall through.  */\n-\n-\tcase DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE:\n-\t  {\n-\t    int prefix_length = strlen (buffer->state.prefix);\n-\t    output_append_r (buffer, buffer->state.prefix, prefix_length);\n-\t    prefix_was_emitted_for (buffer) = true;\n-\t  }\n-\t  break;\n-\t}\n-    }\n-}\n-\n-/* Have BUFFER start a new line.  */\n-void\n-output_add_newline (output_buffer *buffer)\n-{\n-  obstack_1grow (&buffer->obstack, '\\n');\n-  output_text_length (buffer) = 0;\n-}\n-\n-/* Appends a character to BUFFER.  */\n-void\n-output_add_character (output_buffer *buffer, int c)\n-{\n-  if (output_is_line_wrapping (buffer) && output_space_left (buffer) <= 0)\n-    output_add_newline (buffer);\n-  obstack_1grow (&buffer->obstack, c);\n-  ++output_text_length (buffer);\n-}\n-\n-/* Adds a space to BUFFER.  */\n-void\n-output_add_space (output_buffer *buffer)\n-{\n-  if (output_is_line_wrapping (buffer) && output_space_left (buffer) <= 0)\n-    {\n-      output_add_newline (buffer);\n-      return;\n-    }\n-  obstack_1grow (&buffer->obstack, ' ');\n-  ++output_text_length (buffer);\n-}\n-\n-/* These functions format an INTEGER into BUFFER as suggested by their\n-   names.  */\n-void\n-output_decimal (output_buffer *buffer, int i)\n-{\n-  output_formatted_scalar (buffer, \"%d\", i);\n-}\n-\n-void\n-output_host_wide_integer (output_buffer *buffer, HOST_WIDE_INT i)\n-{\n-  output_formatted_scalar (buffer, HOST_WIDE_INT_PRINT_DEC, i);\n-}\n-\n-static inline void\n-output_pointer (output_buffer *buffer, void *p)\n-{\n-  output_formatted_scalar (buffer, HOST_PTR_PRINTF, p);\n-}\n-\n-/* Append to BUFFER a string specified by its STARTING character\n-   and LENGTH.  */\n-static void\n-output_append_r (output_buffer *buffer, const char *start, int length)\n-{\n-  obstack_grow (&buffer->obstack, start, length);\n-  output_text_length (buffer) += length;\n-}\n-\n-/* Append a string delimited by START and END to BUFFER.  No wrapping is\n-   done.  However, if beginning a new line then emit BUFFER->state.prefix\n-   and skip any leading whitespace if appropriate.  The caller must ensure\n-   that it is safe to do so.  */\n-void\n-output_append (output_buffer *buffer, const char *start, const char *end)\n-{\n-  /* Emit prefix and skip whitespace if we're starting a new line.  */\n-  if (is_starting_newline (buffer))\n-    {\n-      output_emit_prefix (buffer);\n-      if (output_is_line_wrapping (buffer))\n-\twhile (start != end && *start == ' ')\n-\t  ++start;\n-    }\n-  output_append_r (buffer, start, end - start);\n-}\n-\n-/* Insert enough spaces into BUFFER to bring the column position to\n-   the current indentation level, assuming that a newline has just\n-   been written to the buffer.  */\n-static void\n-output_indent (output_buffer *buffer)\n-{\n-  int n = output_indentation (buffer);\n-  int i;\n-\n-  for (i = 0; i < n; ++i)\n-    output_add_character (buffer, ' ');\n-}\n-\n-/* Wrap a text delimited by START and END into BUFFER.  */\n-static void\n-wrap_text (output_buffer *buffer, const char *start, const char *end)\n-{\n-  bool is_wrapping = output_is_line_wrapping (buffer);\n-\n-  while (start != end)\n-    {\n-      /* Dump anything bordered by whitespaces.  */\n-      {\n-\tconst char *p = start;\n-\twhile (p != end && *p != ' ' && *p != '\\n')\n-\t  ++p;\n-\tif (is_wrapping && p - start >= output_space_left (buffer))\n-\t  output_add_newline (buffer);\n-\toutput_append (buffer, start, p);\n-\tstart = p;\n-      }\n-\n-      if (start != end && *start == ' ')\n-\t{\n-\t  output_add_space (buffer);\n-\t  ++start;\n-\t}\n-      if (start != end && *start == '\\n')\n-\t{\n-\t  output_add_newline (buffer);\n-\t  ++start;\n-\t}\n-    }\n-}\n-\n-/* Same as wrap_text but wrap text only when in line-wrapping mode.  */\n-static void\n-maybe_wrap_text (output_buffer *buffer, const char *start, const char *end)\n-{\n-  if (output_is_line_wrapping (buffer))\n-    wrap_text (buffer, start, end);\n-  else\n-    output_append (buffer, start, end);\n-}\n-\n-\n-/* Append a STRING to BUFFER; the STRING might be line-wrapped if in\n-   appropriate mode.  */\n-void\n-output_add_string (output_buffer *buffer, const char *str)\n-{\n-  maybe_wrap_text (buffer, str, str + (str ? strlen (str) : 0));\n-}\n-\n-/* Append an identifier ID to BUFFER.  */\n-void\n-output_add_identifier (output_buffer *buffer, tree id)\n-{\n-  output_append (buffer, IDENTIFIER_POINTER (id),\n-\t\t IDENTIFIER_POINTER (id) + IDENTIFIER_LENGTH (id));\n-}\n-\n-/* Flush the content of BUFFER onto the attached stream,\n-   and reinitialize.  */\n-\n-static void\n-output_buffer_to_stream (output_buffer *buffer)\n-{\n-  const char *text = output_finalize_message (buffer);\n-  fputs (text, output_buffer_attached_stream (buffer));\n-  output_clear_message_text (buffer);\n-}\n-\n-/* Format a message pointed to by TEXT.  The following format specifiers are\n-   recognized as being language independent:\n-   %d, %i: (signed) integer in base ten.\n-   %u: unsigned integer in base ten.\n-   %o: unsigned integer in base eight.\n-   %x: unsigned integer in base sixteen.\n-   %ld, %li, %lo, %lu, %lx: long versions of the above.\n-   %lld, %lli, %llo, %llu, %llx: long long versions.\n-   %wd, %wi, %wo, %wu, %wx: HOST_WIDE_INT versions.\n-   %c: character.\n-   %s: string.\n-   %p: pointer.\n-   %m: strerror(text->err_no) - does not consume a value from args_ptr.\n-   %%: `%'.\n-   %*.s: a substring the length of which is specified by an integer.\n-   %H: location_t.  */\n-static void\n-output_format (output_buffer *buffer, text_info *text)\n-{\n-  for (; *text->format_spec; ++text->format_spec)\n-    {\n-      int precision = 0;\n-      bool wide = false;\n-\n-      /* Ignore text.  */\n-      {\n-\tconst char *p = text->format_spec;\n-\twhile (*p && *p != '%')\n-\t  ++p;\n-\twrap_text (buffer, text->format_spec, p);\n-        text->format_spec = p;\n-      }\n-\n-      if (*text->format_spec == '\\0')\n-\tbreak;\n-\n-      /* We got a '%'.  Parse precision modifiers, if any.  */\n-      switch (*++text->format_spec)\n-        {\n-        case 'w':\n-          wide = true;\n-          ++text->format_spec;\n-          break;\n-\n-        case 'l':\n-          do\n-            ++precision;\n-          while (*++text->format_spec == 'l');\n-          break;\n-\n-        default:\n-          break;\n-        }\n-      /* We don't support precision behond that of \"long long\".  */\n-      if (precision > 2)\n-        abort();\n-\n-      switch (*text->format_spec)\n-\t{\n-\tcase 'c':\n-\t  output_add_character (buffer, va_arg (*text->args_ptr, int));\n-\t  break;\n-\n-\tcase 'd':\n-\tcase 'i':\n-          if (wide)\n-            output_formatted_scalar\n-              (buffer, HOST_WIDE_INT_PRINT_DEC,\n-               va_arg (*text->args_ptr, HOST_WIDE_INT));\n-          else\n-            output_integer_with_precision\n-              (buffer, *text->args_ptr, precision, int, \"d\");\n-\t  break;\n-\n-\tcase 'o':\n-          if (wide)\n-            output_formatted_scalar\n-              (buffer, \"%\" HOST_WIDE_INT_PRINT \"o\",\n-               va_arg (*text->args_ptr, unsigned HOST_WIDE_INT));\n-          else\n-            output_integer_with_precision\n-              (buffer, *text->args_ptr, precision, unsigned, \"u\");\n-\t  break;\n-\n-\tcase 's':\n-\t  output_add_string (buffer, va_arg (*text->args_ptr, const char *));\n-\t  break;\n-\n-        case 'p':\n-          output_pointer (buffer, va_arg (*text->args_ptr, void *));\n-          break;\n-\n-\tcase 'u':\n-          if (wide)\n-            output_formatted_scalar\n-              (buffer, HOST_WIDE_INT_PRINT_UNSIGNED,\n-               va_arg (*text->args_ptr, unsigned HOST_WIDE_INT));\n-          else\n-            output_integer_with_precision\n-              (buffer, *text->args_ptr, precision, unsigned, \"u\");\n-\t  break;\n-\n-\tcase 'x':\n-          if (wide)\n-            output_formatted_scalar\n-              (buffer, HOST_WIDE_INT_PRINT_HEX,\n-               va_arg (*text->args_ptr, unsigned HOST_WIDE_INT));\n-          else\n-            output_integer_with_precision\n-              (buffer, *text->args_ptr, precision, unsigned, \"x\");\n-\t  break;\n-\n-\tcase 'm':\n-\t  output_add_string (buffer, xstrerror (text->err_no));\n-\t  break;\n-\n-\tcase '%':\n-\t  output_add_character (buffer, '%');\n-\t  break;\n-\n-        case 'H':\n-          {\n-            const location_t *locus = va_arg (*text->args_ptr, location_t *);\n-            output_add_string (buffer, \"file '\");\n-            output_add_string (buffer, locus->file);\n-            output_add_string (buffer, \"', line \");\n-            output_decimal (buffer, locus->line);\n-          }\n-          break;\n-\n-\tcase '.':\n-\t  {\n-\t    int n;\n-\t    const char *s;\n-\t    /* We handle no precision specifier but `%.*s'.  */\n-\t    if (*++text->format_spec != '*')\n-\t      abort ();\n-\t    else if (*++text->format_spec != 's')\n-\t      abort ();\n-\t    n = va_arg (*text->args_ptr, int);\n-\t    s = va_arg (*text->args_ptr, const char *);\n-\t    output_append (buffer, s, s + n);\n-\t  }\n-\t  break;\n-\n-\tdefault:\n-\t  if (!buffer->format_decoder\n-              || !(*buffer->format_decoder) (buffer, text))\n-\t    {\n-\t      /* Hmmm.  The front-end failed to install a format translator\n-                 but called us with an unrecognized format.  Or, maybe, the\n-                 translated string just contains an invalid format, or\n-                 has formats in the wrong order.  Sorry.  */\n-\t      abort ();\n-\t    }\n-\t}\n-    }\n-}\n-\n /* Return a malloc'd string containing MSG formatted a la printf.  The\n    caller is responsible for freeing the memory.  */\n static char *\n@@ -614,127 +91,31 @@ file_name_as_prefix (const char *f)\n   return build_message_string (\"%s: \", f);\n }\n \n-/* Format a message into BUFFER a la printf.  */\n-void\n-output_printf (struct output_buffer *buffer, const char *msgid, ...)\n-{\n-  text_info text;\n-  va_list ap;\n-\n-  va_start (ap, msgid);\n-  text.err_no = errno;\n-  text.args_ptr = &ap;\n-  text.format_spec = _(msgid);\n-  output_format (buffer, &text);\n-  va_end (ap);\n-}\n-\n-/* Print a message relevant to the given DECL.  */\n-static void\n-format_with_decl (output_buffer *buffer, text_info *text, tree decl)\n-{\n-  const char *p;\n-\n-  /* Do magic to get around lack of varargs support for insertion\n-     of arguments into existing list.  We know that the decl is first;\n-     we ass_u_me that it will be printed with \"%s\".  */\n-  for (p = text->format_spec; *p; ++p)\n-    {\n-      if (*p == '%')\n-\t{\n-\t  if (*(p + 1) == '%')\n-\t    ++p;\n-\t  else if (*(p + 1) != 's')\n-\t    abort ();\n-\t  else\n-\t    break;\n-\t}\n-    }\n-\n-  /* Print the left-hand substring.  */\n-  maybe_wrap_text (buffer, text->format_spec, p);\n-\n-  if (*p == '%')\t\t/* Print the name.  */\n-    {\n-      const char *const n = (DECL_NAME (decl)\n-\t\t\t     ? (*lang_hooks.decl_printable_name) (decl, 2)\n-\t\t\t     : _(\"((anonymous))\"));\n-      output_add_string (buffer, n);\n-      while (*p)\n-\t{\n-\t  ++p;\n-\t  if (ISALPHA (*(p - 1) & 0xFF))\n-\t    break;\n-\t}\n-    }\n-\n-  if (*p)\t\t\t/* Print the rest of the message.  */\n-    {\n-      text->format_spec = p;\n-      output_format (buffer, text);\n-    }\n-}\n-\n-/* Flush the content of BUFFER onto the attached stream.  */\n-static void\n-output_flush (output_buffer *buffer)\n-{\n-  output_buffer_to_stream (buffer);\n-  output_clear_data (buffer);\n-  fputc ('\\n', output_buffer_attached_stream (buffer));\n-  fflush (output_buffer_attached_stream (buffer));\n-}\n-\n-/* Helper subroutine of output_verbatim and verbatim. Do the appropriate\n-   settings needed by BUFFER for a verbatim formatting.  */\n-static void\n-output_do_verbatim (output_buffer *buffer, text_info *text)\n-{\n-  diagnostic_prefixing_rule_t rule = output_prefixing_rule (buffer);\n-  int line_cutoff = output_line_cutoff (buffer);\n-\n-  /* Set verbatim mode.  */\n-  output_prefixing_rule (buffer) = DIAGNOSTICS_SHOW_PREFIX_NEVER;\n-  output_line_cutoff (buffer) = 0;\n-  /* Do the actual formatting.  */\n-  output_format (buffer, text);\n-  /* Restore previous settings.  */\n-  output_prefixing_rule (buffer) = rule;\n-  output_line_cutoff (buffer) = line_cutoff;\n-}\n-\n-/* Output MESSAGE verbatim into BUFFER.  */\n-void\n-output_verbatim (output_buffer *buffer, const char *msgid, ...)\n-{\n-  text_info text;\n-  va_list ap;\n-\n-  va_start (ap, msgid);\n-  text.err_no = errno;\n-  text.args_ptr = &ap;\n-  text.format_spec = _(msgid);\n-  output_do_verbatim (buffer, &text);\n-  va_end (ap);\n-}\n \n \f\n /* Initialize the diagnostic message outputting machinery.  */\n void\n diagnostic_initialize (diagnostic_context *context)\n {\n-  memset (context, 0, sizeof *context);\n-  obstack_init (&context->buffer.obstack);\n-\n+  /* Allocate a basic pretty-printer.  Clients will replace this a\n+     much more elaborated pretty-printer if they wish.  */\n+  context->printer = xmalloc (sizeof (pretty_printer));\n+  pp_construct (context->printer, NULL, 0);\n   /* By default, diagnostics are sent to stderr.  */\n-  output_buffer_attached_stream (&context->buffer) = stderr;\n-\n+  context->printer->buffer->stream = stderr;\n   /* By default, we emit prefixes once per message.  */\n-  diagnostic_prefixing_rule (context) = DIAGNOSTICS_SHOW_PREFIX_ONCE;\n+  context->printer->prefixing_rule = DIAGNOSTICS_SHOW_PREFIX_ONCE;\n \n+  memset (context->diagnostic_count, 0, sizeof context->diagnostic_count);\n+  context->warnings_are_errors_message = warnings_are_errors;\n+  context->abort_on_error = false;\n+  context->internal_error = NULL;\n   diagnostic_starter (context) = default_diagnostic_starter;\n   diagnostic_finalizer (context) = default_diagnostic_finalizer;\n-  context->warnings_are_errors_message = warnings_are_errors;\n+  context->last_module = 0;\n+  context->last_function = NULL;\n+  context->lock = 0;\n+  context->x_data = NULL;\n }\n \n /* Returns true if the next format specifier in TEXT is a format specifier\n@@ -797,13 +178,6 @@ diagnostic_build_prefix (diagnostic_info *diagnostic)\n                             _(diagnostic_kind_text[diagnostic->kind]));\n }\n \n-void\n-diagnostic_flush_buffer (diagnostic_context *context)\n-{\n-  output_buffer_to_stream (&context->buffer);\n-  fflush (output_buffer_attached_stream (&context->buffer));\n-}\n-\n /* Count a diagnostic.  Return true if the message should be printed.  */\n static bool\n diagnostic_count_diagnostic (diagnostic_context *context,\n@@ -852,8 +226,8 @@ diagnostic_count_diagnostic (diagnostic_context *context,\n \n       if (context->warnings_are_errors_message)\n         {\n-\t  output_verbatim (&context->buffer,\n-                           \"%s: warnings being treated as errors\\n\", progname);\n+\t  pp_verbatim (context->printer,\n+                       \"%s: warnings being treated as errors\\n\", progname);\n           context->warnings_are_errors_message = false;\n         }\n \n@@ -917,7 +291,7 @@ announce_function (tree decl)\n       else\n \tverbatim (\" %s\", (*lang_hooks.decl_printable_name) (decl, 2));\n       fflush (stderr);\n-      output_needs_newline (&global_dc->buffer) = true;\n+      global_dc->printer->need_newline = true;\n       diagnostic_set_last_function (global_dc);\n     }\n }\n@@ -929,29 +303,29 @@ lhd_print_error_function (diagnostic_context *context, const char *file)\n {\n   if (diagnostic_last_function_changed (context))\n     {\n-      const char *old_prefix = output_prefix (&context->buffer);\n+      const char *old_prefix = context->printer->prefix;\n       char *new_prefix = file ? build_message_string (\"%s: \", file) : NULL;\n \n-      output_set_prefix (&context->buffer, new_prefix);\n+      pp_set_prefix (context->printer, new_prefix);\n \n       if (current_function_decl == NULL)\n-\toutput_add_string (&context->buffer, _(\"At top level:\"));\n+\tpp_string (context->printer, _(\"At top level:\"));\n       else\n \t{\n \t  if (TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE)\n-\t    output_printf\n-\t      (&context->buffer, \"In member function `%s':\",\n+\t    pp_printf\n+\t      (context->printer, \"In member function `%s':\",\n \t       (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n \t  else\n-\t    output_printf\n-\t      (&context->buffer, \"In function `%s':\",\n+\t    pp_printf\n+\t      (context->printer, \"In function `%s':\",\n \t       (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n \t}\n-      output_add_newline (&context->buffer);\n+      pp_newline (context->printer);\n \n       diagnostic_set_last_function (context);\n-      output_buffer_to_stream (&context->buffer);\n-      context->buffer.state.prefix = old_prefix;\n+      pp_flush (context->printer);\n+      context->printer->prefix = old_prefix;\n       free ((char*) new_prefix);\n     }\n }\n@@ -972,23 +346,23 @@ diagnostic_report_current_module (diagnostic_context *context)\n {\n   struct file_stack *p;\n \n-  if (output_needs_newline (&context->buffer))\n+  if (pp_needs_newline (context->printer))\n     {\n-      output_add_newline (&context->buffer);\n-      output_needs_newline (&context->buffer) = false;\n+      pp_newline (context->printer);\n+      pp_needs_newline (context->printer) = false;\n     }\n \n   if (input_file_stack && diagnostic_last_module_changed (context))\n     {\n       p = input_file_stack;\n-      output_verbatim (&context->buffer,\n-\t\t       \"In file included from %s:%d\",\n-\t\t       p->location.file, p->location.line);\n+      pp_verbatim (context->printer,\n+                   \"In file included from %s:%d\",\n+                   p->location.file, p->location.line);\n       while ((p = p->next) != NULL)\n-\toutput_verbatim (&context->buffer,\n-\t\t\t \",\\n                 from %s:%d\",\n-\t\t\t p->location.file, p->location.line);\n-      output_verbatim (&context->buffer, \":\\n\");\n+\tpp_verbatim (context->printer,\n+                     \",\\n                 from %s:%d\",\n+                     p->location.file, p->location.line);\n+      pp_verbatim (context->printer, \":\\n\");\n       diagnostic_set_last_module (context);\n     }\n }\n@@ -998,14 +372,14 @@ default_diagnostic_starter (diagnostic_context *context,\n \t\t\t    diagnostic_info *diagnostic)\n {\n   diagnostic_report_current_function (context);\n-  output_set_prefix (&context->buffer, diagnostic_build_prefix (diagnostic));\n+  pp_set_prefix (context->printer, diagnostic_build_prefix (diagnostic));\n }\n \n static void\n default_diagnostic_finalizer (diagnostic_context *context,\n \t\t\t      diagnostic_info *diagnostic __attribute__((unused)))\n {\n-  output_destroy_prefix (&context->buffer);\n+  pp_destroy_prefix (context->printer);\n }\n \n /* Report a diagnostic message (an error or a warning) as specified by\n@@ -1024,31 +398,9 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n   if (diagnostic_count_diagnostic (context, diagnostic))\n     {\n       (*diagnostic_starter (context)) (context, diagnostic);\n-      output_format (&context->buffer, &diagnostic->message);\n-      (*diagnostic_finalizer (context)) (context, diagnostic);\n-      output_flush (&context->buffer);\n-      diagnostic_action_after_output (context, diagnostic);\n-    }\n-\n-  context->lock--;\n-}\n-\n-/* Report a diagnostic MESSAGE at the declaration DECL.\n-   MSG is a format string which uses %s to substitute the declaration\n-   name; subsequent substitutions are a la output_format.  */\n-static void\n-diagnostic_for_decl (diagnostic_context *context,\n-\t\t     diagnostic_info *diagnostic, tree decl)\n-{\n-  if (context->lock++ && diagnostic->kind < DK_SORRY)\n-    error_recursion (context);\n-\n-  if (diagnostic_count_diagnostic (context, diagnostic))\n-    {\n-      (*diagnostic_starter (context)) (context, diagnostic);\n-      format_with_decl (&context->buffer, &diagnostic->message, decl);\n+      pp_format_text (context->printer, &diagnostic->message);\n       (*diagnostic_finalizer (context)) (context, diagnostic);\n-      output_flush (&context->buffer);\n+      pp_flush (context->printer);\n       diagnostic_action_after_output (context, diagnostic);\n     }\n \n@@ -1114,8 +466,8 @@ verbatim (const char *msgid, ...)\n   text.err_no = errno;\n   text.args_ptr = &ap;\n   text.format_spec = _(msgid);\n-  output_do_verbatim (&global_dc->buffer, &text);\n-  output_buffer_to_stream (&global_dc->buffer);\n+  pp_format_verbatim (global_dc->printer, &text);\n+  pp_flush (global_dc->printer);\n   va_end (ap);\n }\n \n@@ -1234,61 +586,6 @@ internal_error (const char *msgid, ...)\n   real_abort ();\n }\n \f\n-/* Variants of some of the above, which make reference to a particular\n-   DECL node.  These are deprecated.  */\n-\n-void\n-warning_with_decl (tree decl, const char *msgid, ...)\n-{\n-  diagnostic_info diagnostic;\n-  va_list ap;\n-\n-  va_start (ap, msgid);\n-\n-  /* Do not issue a warning about a decl which came from a system header,\n-     unless -Wsystem-headers.  */\n-  if (DECL_IN_SYSTEM_HEADER (decl) && !warn_system_headers)\n-    return;\n-\n-  diagnostic_set_info (&diagnostic, msgid, &ap,\n-                       DECL_SOURCE_LOCATION (decl), DK_WARNING);\n-  diagnostic_for_decl (global_dc, &diagnostic, decl);\n-  va_end (ap);\n-}\n-\n-void\n-pedwarn_with_decl (tree decl, const char *msgid, ...)\n-{\n-  diagnostic_info diagnostic;\n-  va_list ap;\n-\n-  va_start (ap, msgid);\n-\n-  /* Do not issue a warning about a decl which came from a system header,\n-     unless -Wsystem-headers.  */\n-  if (DECL_IN_SYSTEM_HEADER (decl) && !warn_system_headers)\n-    return;\n-\n-  diagnostic_set_info (&diagnostic, msgid, &ap,\n-                       DECL_SOURCE_LOCATION (decl), pedantic_error_kind ());\n-  diagnostic_for_decl (global_dc, &diagnostic, decl);\n-\n-  va_end (ap);\n-}\n-\n-void\n-error_with_decl (tree decl, const char *msgid, ...)\n-{\n-  diagnostic_info diagnostic;\n-  va_list ap;\n-\n-  va_start (ap, msgid);\n-  diagnostic_set_info (&diagnostic, msgid, &ap,\n-                       DECL_SOURCE_LOCATION (decl), DK_ERROR);\n-  diagnostic_for_decl (global_dc, &diagnostic, decl);\n-  va_end (ap);\n-}\n-\f\n /* Special case error functions.  Most are implemented in terms of the\n    above, or should be.  */\n \n@@ -1351,7 +648,7 @@ static void\n error_recursion (diagnostic_context *context)\n {\n   if (context->lock < 3)\n-    output_flush (&context->buffer);\n+    pp_flush (context->printer);\n \n   fnotice (stderr,\n \t   \"Internal compiler error: Error reporting routines re-entered.\\n\");"}, {"sha": "1a26553f9a284445b3339dbc59f2f5184942dfb9", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 9, "deletions": 153, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -22,17 +22,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_DIAGNOSTIC_H\n #define GCC_DIAGNOSTIC_H\n \n-#include \"obstack.h\"\n-#include \"input.h\"\n-\n-/* The type of a text to be formatted according a format specification\n-   along with a list of things.  */\n-typedef struct\n-{\n-  const char *format_spec;\n-  va_list *args_ptr;\n-  int err_no;  /* for %m */\n-} text_info;\n+#include \"pretty-print.h\"\n \n /* Constants used to discriminate diagnostics.  */\n typedef enum\n@@ -56,118 +46,6 @@ typedef struct\n \n #define pedantic_error_kind() (flag_pedantic_errors ? DK_ERROR : DK_WARNING)\n \n-/* How often diagnostics are prefixed by their locations:\n-   o DIAGNOSTICS_SHOW_PREFIX_NEVER: never - not yet supported;\n-   o DIAGNOSTICS_SHOW_PREFIX_ONCE: emit only once;\n-   o DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE: emit each time a physical\n-   line is started.  */\n-typedef enum\n-{\n-  DIAGNOSTICS_SHOW_PREFIX_ONCE       = 0x0,\n-  DIAGNOSTICS_SHOW_PREFIX_NEVER      = 0x1,\n-  DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE = 0x2\n-} diagnostic_prefixing_rule_t;\n-\n-/* This data structure encapsulates an output_buffer's state.  */\n-typedef struct\n-{\n-  /* The prefix for each new line.  */\n-  const char *prefix;\n-\n-  /* The real upper bound of number of characters per line, taking into\n-     account the case of a very very looong prefix.  */  \n-  int maximum_length;\n-\n-  /* The ideal upper bound of number of characters per line, as suggested\n-     by front-end.  */  \n-  int ideal_maximum_length;\n-\n-  /* Indentation count.  */\n-  int indent_skip;\n-\n-  /* Nonzero if current PREFIX was emitted at least once.  */\n-  bool emitted_prefix_p;\n-\n-  /* Nonzero means one should emit a newline before outputting anything.  */\n-  bool need_newline_p;\n-\n-  /* Current prefixing rule.  */\n-  diagnostic_prefixing_rule_t prefixing_rule;\n-} output_state;\n-\n-/* The type of a hook that formats client-specific data (trees mostly) into\n-   an output_buffer.  A client-supplied formatter returns true if everything\n-   goes well.  */\n-typedef struct output_buffer output_buffer;\n-typedef bool (*printer_fn) (output_buffer *, text_info *);\n-\n-/* The output buffer datatype.  This is best seen as an abstract datatype\n-   whose fields should not be accessed directly by clients.  */\n-struct output_buffer\n-{\n-  /* The current state of the buffer.  */\n-  output_state state;\n-\n-  /* Where to output formatted text.  */\n-  FILE* stream;\n-\n-  /* The obstack where the text is built up.  */  \n-  struct obstack obstack;\n-\n-  /* The amount of characters output so far.  */  \n-  int line_length;\n-\n-  /* This must be large enough to hold any printed integer or\n-     floating-point value.  */\n-  char digit_buffer[128];\n-\n-  /* If non-NULL, this function formats a TEXT into the BUFFER. When called,\n-     TEXT->format_spec points to a format code.  FORMAT_DECODER should call\n-     output_add_string (and related functions) to add data to the BUFFER.\n-     FORMAT_DECODER can read arguments from *TEXT->args_pts using VA_ARG.\n-     If the BUFFER needs additional characters from the format string, it\n-     should advance the TEXT->format_spec as it goes.  When FORMAT_DECODER\n-     returns, TEXT->format_spec should point to the last character processed.\n-  */\n-  printer_fn format_decoder;\n-} ;\n-\n-#define output_prefix(BUFFER) (BUFFER)->state.prefix\n-\n-/* The stream attached to the output_buffer, where the formatted\n-   diagnostics will ultimately go.  Works only on `output_buffer *'.  */\n-#define output_buffer_attached_stream(BUFFER) (BUFFER)->stream\n-\n-/* In line-wrapping mode, whether we should start a new line.  */\n-#define output_needs_newline(BUFFER) (BUFFER)->state.need_newline_p\n-\n-/* The amount of whitespace to be emitted when starting a new line.  */\n-#define output_indentation(BUFFER) (BUFFER)->state.indent_skip\n-\n-/* A pointer to the formatted diagnostic message.  */\n-#define output_message_text(BUFFER) \\\n-   ((const char *) obstack_base (&(BUFFER)->obstack))\n-\n-/* Client supplied function used to decode formats.  */\n-#define output_format_decoder(BUFFER)     (BUFFER)->format_decoder\n-\n-/* Prefixing rule used in formatting a diagnostic message.  */\n-#define output_prefixing_rule(BUFFER)  (BUFFER)->state.prefixing_rule\n-\n-/* Maximum characters per line in automatic line wrapping mode.\n-   Zero means don't wrap lines.  */\n-#define output_line_cutoff(BUFFER)  (BUFFER)->state.ideal_maximum_length\n-\n-/* True if BUFFER is in line-wrapping mode.  */\n-#define output_is_line_wrapping(BUFFER) (output_line_cutoff (BUFFER) > 0)\n-\n-#define output_formatted_scalar(BUFFER, FORMAT, SCALAR)\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      sprintf ((BUFFER)->digit_buffer, FORMAT, SCALAR);\t\\\n-      output_add_string (BUFFER, (BUFFER)->digit_buffer);\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n \n /*  Forward declarations.  */\n typedef struct diagnostic_context diagnostic_context;\n@@ -179,10 +57,8 @@ typedef diagnostic_starter_fn diagnostic_finalizer_fn;\n    the context of a diagnostic message.  */\n struct diagnostic_context\n {\n-  /* Where most of the diagnostic formatting work is done.  In Object\n-     Oriented terms, we'll say that diagnostic_context is a sub-class of\n-     output_buffer.  */\n-  output_buffer buffer;\n+  /* Where most of the diagnostic formatting work is done.   */\n+  pretty_printer *printer;\n \n   /* The number of times we have issued diagnostics.  */\n   int diagnostic_count[DK_LAST_DIAGNOSTIC_KIND];\n@@ -233,15 +109,17 @@ struct diagnostic_context\n /* Extension hook for client.  */\n #define diagnostic_auxiliary_data(DC) (DC)->x_data\n \n-/* Same as output_format_decoder.  Works on 'diagnostic_context *'.  */\n-#define diagnostic_format_decoder(DC) output_format_decoder (&(DC)->buffer)\n+/* Same as pp_format_decoder.  Works on 'diagnostic_context *'.  */\n+#define diagnostic_format_decoder(DC) pp_format_decoder ((DC)->printer)\n \n /* Same as output_prefixing_rule.  Works on 'diagnostic_context *'.  */\n-#define diagnostic_prefixing_rule(DC) output_prefixing_rule (&(DC)->buffer)\n+#define diagnostic_prefixing_rule(DC) ((DC)->printer->prefixing_rule)\n \n /* Maximum characters per line in automatic line wrapping mode.\n    Zero means don't wrap lines.  */\n-#define diagnostic_line_cutoff(DC) output_line_cutoff (&(DC)->buffer)\n+#define diagnostic_line_cutoff(DC) ((DC)->printer->ideal_maximum_length)\n+\n+#define diagnostic_flush_buffer(DC) pp_flush ((DC)->printer)\n \n /* True if the last function in which a diagnostic was reported is\n    different from the current one.  */\n@@ -294,35 +172,13 @@ extern diagnostic_context *global_dc;\n extern void diagnostic_initialize (diagnostic_context *);\n extern void diagnostic_report_current_module (diagnostic_context *);\n extern void diagnostic_report_current_function (diagnostic_context *);\n-extern void diagnostic_flush_buffer (diagnostic_context *);\n extern void diagnostic_report_diagnostic (diagnostic_context *,\n \t\t\t\t\t  diagnostic_info *);\n extern void diagnostic_set_info (diagnostic_info *, const char *, va_list *,\n \t\t\t\t location_t, diagnostic_t);\n extern char *diagnostic_build_prefix (diagnostic_info *);\n \n /* Pure text formatting support functions.  */\n-extern void init_output_buffer (output_buffer *, const char *, int);\n-extern void output_clear (output_buffer *);\n-extern const char *output_last_position (const output_buffer *);\n-extern void output_set_prefix (output_buffer *, const char *);\n-extern void output_destroy_prefix (output_buffer *);\n-extern void output_set_maximum_length (output_buffer *, int);\n-extern void output_emit_prefix (output_buffer *);\n-extern void output_add_newline (output_buffer *);\n-extern void output_add_space (output_buffer *);\n-extern int output_space_left (const output_buffer *);\n-extern void output_append (output_buffer *, const char *, const char *);\n-extern void output_add_character (output_buffer *, int);\n-extern void output_decimal (output_buffer *, int);\n-extern void output_host_wide_integer (output_buffer *, HOST_WIDE_INT);\n-extern void output_add_string (output_buffer *, const char *);\n-extern void output_add_identifier (output_buffer *, tree);\n-extern const char *output_finalize_message (output_buffer *);\n-extern void output_clear_message_text (output_buffer *);\n-extern void output_printf (output_buffer *, const char *, ...)\n-     ATTRIBUTE_PRINTF_2;\n-extern void output_verbatim (output_buffer *, const char *, ...);\n extern void verbatim (const char *, ...);\n extern char *file_name_as_prefix (const char *);\n "}, {"sha": "769c0eacb80f61057ead671f9b97737ea8ec761c", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -2036,9 +2036,9 @@ output_reg_number (rtx rtl)\n \n   if (regno >= DWARF_FRAME_REGISTERS)\n     {\n-      warning_with_decl (dwarf_last_decl,\n-\t\t\t \"internal regno botch: `%s' has regno = %d\\n\",\n-\t\t\t regno);\n+      warning (\"%Hinternal regno botch: '%D' has regno = %d\\n\",\n+               &DECL_SOURCE_LOCATION (dwarf_last_decl), dwarf_last_decl,\n+               regno);\n       regno = 0;\n     }\n   dw2_assemble_integer (4, GEN_INT (DBX_REGISTER_NUMBER (regno)));"}, {"sha": "f95678f9dd12fa597d14e45cbc373f0f27bed429", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -6734,7 +6734,8 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n     case PARM_DECL:\n       if (!DECL_RTL_SET_P (exp))\n \t{\n-\t  error_with_decl (exp, \"prior parameter's size depends on `%s'\");\n+\t  error (\"%Hprior parameter's size depends on '%D'\",\n+                 &DECL_SOURCE_LOCATION (exp), exp);\n \t  return CONST0_RTX (mode);\n \t}\n "}, {"sha": "84c1e6fcc44d0d60a60f77cf830be6711c615dbb", "filename": "gcc/function.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -877,7 +877,8 @@ assign_temp (tree type_or_decl, int keep, int memory_required,\n       if (decl && size == -1\n \t  && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST)\n \t{\n-\t  error_with_decl (decl, \"size of variable `%s' is too large\");\n+\t  error (\"%Hsize of variable '%D' is too large\",\n+                 &DECL_SOURCE_LOCATION (decl), decl);\n \t  size = 1;\n \t}\n \n@@ -5567,15 +5568,15 @@ uninitialized_vars_warning (tree block)\n \t     not worry that it may be a dangling pointer.  */\n \t  && DECL_INITIAL (decl) == NULL_TREE\n \t  && regno_uninitialized (REGNO (DECL_RTL (decl))))\n-\twarning_with_decl (decl,\n-\t\t\t   \"`%s' might be used uninitialized in this function\");\n+\twarning (\"%H'%D' might be used uninitialized in this function\",\n+                 &DECL_SOURCE_LOCATION (decl), decl);\n       if (extra_warnings\n \t  && TREE_CODE (decl) == VAR_DECL\n \t  && DECL_RTL (decl) != 0\n \t  && GET_CODE (DECL_RTL (decl)) == REG\n \t  && regno_clobbered_at_setjmp (REGNO (DECL_RTL (decl))))\n-\twarning_with_decl (decl,\n-\t\t\t   \"variable `%s' might be clobbered by `longjmp' or `vfork'\");\n+\twarning (\"%Hvariable '%D' might be clobbered by `longjmp' or `vfork'\",\n+                 &DECL_SOURCE_LOCATION (decl), decl);\n     }\n   for (sub = BLOCK_SUBBLOCKS (block); sub; sub = TREE_CHAIN (sub))\n     uninitialized_vars_warning (sub);\n@@ -5593,8 +5594,8 @@ setjmp_args_warning (void)\n     if (DECL_RTL (decl) != 0\n \t&& GET_CODE (DECL_RTL (decl)) == REG\n \t&& regno_clobbered_at_setjmp (REGNO (DECL_RTL (decl))))\n-      warning_with_decl (decl,\n-\t\t\t \"argument `%s' might be clobbered by `longjmp' or `vfork'\");\n+      warning (\"%Hargument '%D' might be clobbered by `longjmp' or `vfork'\",\n+               &DECL_SOURCE_LOCATION (decl), decl);\n }\n \n /* If this function call setjmp, put all vars into the stack\n@@ -6919,7 +6920,8 @@ expand_function_end (void)\n \t   decl; decl = TREE_CHAIN (decl))\n \tif (! TREE_USED (decl) && TREE_CODE (decl) == PARM_DECL\n \t    && DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n-\t  warning_with_decl (decl, \"unused parameter `%s'\");\n+          warning (\"%Hunused parameter '%D'\",\n+                   &DECL_SOURCE_LOCATION (decl), decl);\n     }\n \n   /* Delete handlers for nonlocal gotos if nothing uses them.  */"}, {"sha": "7c24921b0abda324c372bbd588f56c49ae5c3349", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -1071,7 +1071,7 @@ common_handle_option (size_t scode, const char *arg,\n       break;\n \n     case OPT_fmessage_length_:\n-      output_set_maximum_length (&global_dc->buffer, value);\n+      pp_set_line_maximum_length (global_dc->printer, value);\n       break;\n \n     case OPT_fmove_all_movables:"}, {"sha": "b1190632b27fcb60f49019f40351b030e54511c1", "filename": "gcc/pretty-print.c", "status": "added", "additions": 547, "deletions": 0, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -0,0 +1,547 @@\n+/* Various declarations for language-independent pretty-print subroutines.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#undef FLOAT /* This is for hpux. They should change hpux.  */\n+#undef FFS  /* Some systems define this in param.h.  */\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"pretty-print.h\"\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free  free\n+\n+/* A pointer to the formatted diagnostic message.  */\n+#define pp_formatted_text_data(PP) \\\n+   ((const char *) obstack_base (&pp_base (PP)->buffer->obstack))\n+\n+/* Format an integer given by va_arg (ARG, type-specifier T) where\n+   type-specifier is a precision modifier as indicated by PREC.  F is\n+   a string used to construct the appropriate format-specifier.  */\n+#define pp_integer_with_precision(PP, ARG, PREC, T, F)       \\\n+  do                                                         \\\n+    switch (PREC)                                            \\\n+      {                                                      \\\n+      case 0:                                                \\\n+        pp_scalar (PP, \"%\" F, va_arg (ARG, T));              \\\n+        break;                                               \\\n+                                                             \\\n+      case 1:                                                \\\n+        pp_scalar (PP, \"%l\" F, va_arg (ARG, long T));        \\\n+        break;                                               \\\n+                                                             \\\n+      case 2:                                                \\\n+        pp_scalar (PP, \"%ll\" F, va_arg (ARG, long long T));  \\\n+        break;                                               \\\n+                                                             \\\n+      default:                                               \\\n+        break;                                               \\\n+      }                                                      \\\n+  while (0)\n+\n+\n+/* Subroutine of pp_set_maximum_length.  Set up PRETTY-PRINTER's\n+   internal maximum characters per line.  */\n+static void\n+pp_set_real_maximum_length (pretty_printer *pp)\n+{\n+  /* If we're told not to wrap lines then do the obvious thing.  In case\n+     we'll emit prefix only once per message, it is appropriate\n+     not to increase unnecessarily the line-length cut-off.  */\n+  if (!pp_is_wrapping_line (pp)\n+      || pp_prefixing_rule (pp) == DIAGNOSTICS_SHOW_PREFIX_ONCE\n+      || pp_prefixing_rule (pp) == DIAGNOSTICS_SHOW_PREFIX_NEVER)\n+    pp->maximum_length = pp_line_cutoff (pp);\n+  else\n+    {\n+      int prefix_length = pp->prefix ? strlen (pp->prefix) : 0;\n+      /* If the prefix is ridiculously too long, output at least\n+         32 characters.  */\n+      if (pp_line_cutoff (pp) - prefix_length < 32)\n+\tpp->maximum_length = pp_line_cutoff (pp) + 32;\n+      else\n+\tpp->maximum_length = pp_line_cutoff (pp);\n+    }\n+}\n+\n+/* Clear PRETTY-PRINTER's output state.  */\n+static inline void\n+pp_clear_state (pretty_printer *pp)\n+{\n+  pp->emitted_prefix = false;\n+  pp_indentation (pp) = 0;\n+}\n+\n+/* Insert enough spaces into the output area of PRETTY-PRINTER to bring\n+   the column position to the current indentation level, assuming that a\n+   newline has just been written to the buffer.  */\n+static void\n+pp_indent (pretty_printer *pp)\n+{\n+  int n = pp_indentation (pp);\n+  int i;\n+\n+  for (i = 0; i < n; ++i)\n+    pp_space (pp);\n+}\n+\n+/* Flush the formatted text of PRETTY-PRINTER onto the attached stream.  */\n+static inline void\n+pp_write_text_to_stream (pretty_printer *pp)\n+{\n+  const char *text = pp_formatted_text (pp);\n+  fputs (text, pp->buffer->stream);\n+  pp_clear_output_area (pp);\n+}\n+\n+/* Wrap a text delimited by START and END into PRETTY-PRINTER.  */\n+static void\n+pp_wrap_text (pretty_printer *pp, const char *start, const char *end)\n+{\n+  bool wrapping_line = pp_is_wrapping_line (pp);\n+\n+  while (start != end)\n+    {\n+      /* Dump anything bordered by whitespaces.  */\n+      {\n+\tconst char *p = start;\n+\twhile (p != end && !ISBLANK (*p) && *p != '\\n')\n+\t  ++p;\n+\tif (wrapping_line\n+            && p - start >= pp_remaining_character_count_for_line (pp))\n+\t  pp_newline (pp);\n+\tpp_append_text (pp, start, p);\n+\tstart = p;\n+      }\n+\n+      if (start != end && ISBLANK (*start))\n+\t{\n+\t  pp_space (pp);\n+\t  ++start;\n+\t}\n+      if (start != end && *start == '\\n')\n+\t{\n+\t  pp_newline (pp);\n+\t  ++start;\n+\t}\n+    }\n+}\n+\n+/* Same as pp_wrap_text but wrap text only when in line-wrapping mode.  */\n+static inline void\n+pp_maybe_wrap_text (pretty_printer *pp, const char *start, const char *end)\n+{\n+  if (pp_is_wrapping_line (pp))\n+    pp_wrap_text (pp, start, end);\n+  else\n+    pp_append_text (pp, start, end);\n+}\n+\n+/* Append to the output area of PRETTY-PRINTER a string specified by its\n+   STARTing character and LENGTH.  */\n+static inline void\n+pp_append_r (pretty_printer *pp, const char *start, int length)\n+{\n+  obstack_grow (&pp->buffer->obstack, start, length);\n+  pp->buffer->line_length += length;\n+}\n+\n+/* Format a message pointed to by TEXT.  The following format specifiers are\n+   recognized as being client independent:\n+   %d, %i: (signed) integer in base ten.\n+   %u: unsigned integer in base ten.\n+   %o: unsigned integer in base eight.\n+   %x: unsigned integer in base sixteen.\n+   %ld, %li, %lo, %lu, %lx: long versions of the above.\n+   %lld, %lli, %llo, %llu, %llx: long long versions.\n+   %wd, %wi, %wo, %wu, %wx: HOST_WIDE_INT versions.\n+   %c: character.\n+   %s: string.\n+   %p: pointer.\n+   %m: strerror(text->err_no) - does not consume a value from args_ptr.\n+   %%: `%'.\n+   %*.s: a substring the length of which is specified by an integer.\n+   %H: location_t.  */\n+void\n+pp_format_text (pretty_printer *pp, text_info *text)\n+{\n+  for (; *text->format_spec; ++text->format_spec)\n+    {\n+      int precision = 0;\n+      bool wide = false;\n+\n+      /* Ignore text.  */\n+      {\n+\tconst char *p = text->format_spec;\n+\twhile (*p && *p != '%')\n+\t  ++p;\n+\tpp_wrap_text (pp, text->format_spec, p);\n+        text->format_spec = p;\n+      }\n+\n+      if (*text->format_spec == '\\0')\n+\tbreak;\n+\n+      /* We got a '%'.  Parse precision modifiers, if any.  */\n+      switch (*++text->format_spec)\n+        {\n+        case 'w':\n+          wide = true;\n+          ++text->format_spec;\n+          break;\n+\n+        case 'l':\n+          do\n+            ++precision;\n+          while (*++text->format_spec == 'l');\n+          break;\n+\n+        default:\n+          break;\n+        }\n+      /* We don't support precision behond that of \"long long\".  */\n+      if (precision > 2)\n+        abort();\n+\n+      switch (*text->format_spec)\n+\t{\n+\tcase 'c':\n+\t  pp_character (pp, va_arg (*text->args_ptr, int));\n+\t  break;\n+\n+\tcase 'd':\n+\tcase 'i':\n+          if (wide)\n+            pp_wide_integer (pp, va_arg (*text->args_ptr, HOST_WIDE_INT));\n+          else\n+            pp_integer_with_precision\n+              (pp, *text->args_ptr, precision, int, \"d\");\n+\t  break;\n+\n+\tcase 'o':\n+          if (wide)\n+            pp_scalar (pp, \"%\" HOST_WIDE_INT_PRINT \"o\",\n+                       va_arg (*text->args_ptr, unsigned HOST_WIDE_INT));\n+          else\n+            pp_integer_with_precision\n+              (pp, *text->args_ptr, precision, unsigned, \"u\");\n+\t  break;\n+\n+\tcase 's':\n+\t  pp_string (pp, va_arg (*text->args_ptr, const char *));\n+\t  break;\n+\n+        case 'p':\n+          pp_pointer (pp, va_arg (*text->args_ptr, void *));\n+          break;\n+\n+\tcase 'u':\n+          if (wide)\n+            pp_scalar (pp, HOST_WIDE_INT_PRINT_UNSIGNED,\n+                       va_arg (*text->args_ptr, unsigned HOST_WIDE_INT));\n+          else\n+            pp_integer_with_precision\n+              (pp, *text->args_ptr, precision, unsigned, \"u\");\n+\t  break;\n+\n+\tcase 'x':\n+          if (wide)\n+            pp_scalar (pp, HOST_WIDE_INT_PRINT_HEX,\n+                       va_arg (*text->args_ptr, unsigned HOST_WIDE_INT));\n+          else\n+            pp_integer_with_precision\n+              (pp, *text->args_ptr, precision, unsigned, \"x\");\n+\t  break;\n+\n+\tcase 'm':\n+\t  pp_string (pp, xstrerror (text->err_no));\n+\t  break;\n+\n+\tcase '%':\n+\t  pp_character (pp, '%');\n+\t  break;\n+\n+        case 'H':\n+          {\n+            const location_t *locus = va_arg (*text->args_ptr, location_t *);\n+            pp_string (pp, \"file '\");\n+            pp_string (pp, locus->file);\n+            pp_string (pp, \"', line \");\n+            pp_decimal_int (pp, locus->line);\n+          }\n+          break;\n+\n+\tcase '.':\n+\t  {\n+\t    int n;\n+\t    const char *s;\n+\t    /* We handle no precision specifier but `%.*s'.  */\n+\t    if (*++text->format_spec != '*')\n+\t      abort ();\n+\t    else if (*++text->format_spec != 's')\n+\t      abort ();\n+\t    n = va_arg (*text->args_ptr, int);\n+\t    s = va_arg (*text->args_ptr, const char *);\n+\t    pp_append_text (pp, s, s + n);\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+          if (!pp_format_decoder (pp) || !(*pp_format_decoder (pp)) (pp, text))\n+\t    {\n+\t      /* Hmmm.  The client failed to install a format translator\n+                 but called us with an unrecognized format.  Or, maybe, the\n+                 translated string just contains an invalid format, or\n+                 has formats in the wrong order.  Sorry.  */\n+\t      abort ();\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Helper subroutine of output_verbatim and verbatim. Do the appropriate\n+   settings needed by BUFFER for a verbatim formatting.  */\n+void\n+pp_format_verbatim (pretty_printer *pp, text_info *text)\n+{\n+  diagnostic_prefixing_rule_t rule = pp_prefixing_rule (pp);\n+  int line_cutoff = pp_line_cutoff (pp);\n+\n+  /* Set verbatim mode.  */\n+  pp->prefixing_rule = DIAGNOSTICS_SHOW_PREFIX_NEVER;\n+  pp_line_cutoff (pp) = 0;\n+  /* Do the actual formatting.  */\n+  pp_format_text (pp, text);\n+  /* Restore previous settings.  */\n+  pp_prefixing_rule (pp) = rule;\n+  pp_line_cutoff (pp) = line_cutoff;\n+}\n+\n+/* Flush the content of BUFFER onto the attached stream.  */\n+void\n+pp_flush (pretty_printer *pp)\n+{\n+  pp_write_text_to_stream (pp);\n+  pp_clear_state (pp);\n+  fputc ('\\n', pp->buffer->stream);\n+  fflush (pp->buffer->stream);\n+}\n+\n+/* Sets the number of maximum characters per line PRETTY-PRINTER can\n+   output in line-wrapping mode.  A LENGTH value 0 suppresses\n+   line-wrapping.  */\n+void\n+pp_set_line_maximum_length (pretty_printer *pp, int length)\n+{\n+  pp_line_cutoff (pp) = length;\n+  pp_set_real_maximum_length (pp);\n+}\n+\n+/* Clear PRETTY-PRINTER output area text info.  */\n+void\n+pp_clear_output_area (pretty_printer *pp)\n+{\n+  obstack_free (&pp->buffer->obstack, obstack_base (&pp->buffer->obstack));\n+  pp->buffer->line_length = 0;\n+}\n+\n+/* Set PREFIX for PRETTY-PRINTER.  */\n+void\n+pp_set_prefix (pretty_printer *pp, const char *prefix)\n+{\n+  pp->prefix = prefix;\n+  pp_set_real_maximum_length (pp);\n+  pp->emitted_prefix = false;\n+  pp_indentation (pp) = 0;\n+}\n+\n+/* Free PRETTY-PRINTER's prefix, a previously malloc()'d string.  */\n+void\n+pp_destroy_prefix (pretty_printer *pp)\n+{\n+  if (pp->prefix != NULL)\n+    {\n+      free ((char *) pp->prefix);\n+      pp->prefix = NULL;\n+    }\n+}\n+\n+/* Write out PRETTY-PRINTER's prefix.  */\n+void\n+pp_emit_prefix (pretty_printer *pp)\n+{\n+  if (pp->prefix != NULL)\n+    {\n+      switch (pp_prefixing_rule (pp))\n+\t{\n+\tdefault:\n+\tcase DIAGNOSTICS_SHOW_PREFIX_NEVER:\n+\t  break;\n+\n+\tcase DIAGNOSTICS_SHOW_PREFIX_ONCE:\n+\t  if (pp->emitted_prefix)\n+\t    {\n+\t      pp_indent (pp);\n+\t      break;\n+\t    }\n+\t  pp_indentation (pp) += 3;\n+\t  /* Fall through.  */\n+\n+\tcase DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE:\n+\t  {\n+\t    int prefix_length = strlen (pp->prefix);\n+\t    pp_append_r (pp, pp->prefix, prefix_length);\n+\t    pp->emitted_prefix = true;\n+\t  }\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* Construct a PRETTY-PRINTER with PREFIX and of MAXIMUM_LENGTH\n+   characters per line.  */\n+void\n+pp_construct (pretty_printer *pp, const char *prefix, int maximum_length)\n+{\n+  memset (pp, 0, sizeof (pretty_printer));\n+  pp->buffer = xmalloc (sizeof (output_buffer));\n+  obstack_init (&pp->buffer->obstack);\n+  pp->buffer->stream = stderr;\n+  pp_line_cutoff (pp) = maximum_length;\n+  pp_prefixing_rule (pp) = DIAGNOSTICS_SHOW_PREFIX_ONCE;\n+  pp_set_prefix (pp, prefix);\n+}\n+\n+/* Append a string delimited by START and END to the output area of\n+   PRETTY-PRINTER.  No line wrapping is done.  However, if beginning a\n+   new line then emit PRETTY-PRINTER's prefix and skip any leading\n+   whitespace if appropriate.  The caller must ensure that it is\n+   safe to do so.  */\n+void\n+pp_append_text (pretty_printer *pp, const char *start, const char *end)\n+{\n+  /* Emit prefix and skip whitespace if we're starting a new line.  */\n+  if (pp->buffer->line_length == 0)\n+    {\n+      pp_emit_prefix (pp);\n+      if (pp_is_wrapping_line (pp))\n+\twhile (start != end && *start == ' ')\n+\t  ++start;\n+    }\n+  pp_append_r (pp, start, end - start);\n+}\n+\n+/* Finishes constructing a NULL-terminated character string representing\n+   the PRETTY-PRINTED text.  */\n+const char *\n+pp_formatted_text (pretty_printer *pp)\n+{\n+  obstack_1grow (&pp->buffer->obstack, '\\0');\n+  return pp_formatted_text_data (pp);\n+}\n+\n+/*  Return a pointer to the last character emitted in PRETTY-PRINTER's\n+    output area.  A NULL pointer means no character available.  */\n+const char *\n+pp_last_position_in_text (const pretty_printer *pp)\n+{\n+  const char *p = NULL;\n+  struct obstack *text = &pp->buffer->obstack;\n+\n+  if (obstack_base (text) != obstack_next_free (text))\n+    p = ((const char *) obstack_next_free (text)) - 1;\n+  return p;\n+}\n+\n+/* Return the amount of characters PRETTY-PRINTER can accept to\n+   make a full line.  Meaningfull only in line-wrapping mode.  */\n+int\n+pp_remaining_character_count_for_line (pretty_printer *pp)\n+{\n+  return pp->maximum_length - pp->buffer->line_length;\n+}\n+\n+\n+/* Format a message into BUFFER a la printf.  */\n+void\n+pp_printf (pretty_printer *pp, const char *msg, ...)\n+{\n+  text_info text;\n+  va_list ap;\n+\n+  va_start (ap, msg);\n+  text.err_no = errno;\n+  text.args_ptr = &ap;\n+  text.format_spec = msg;\n+  pp_format_text (pp, &text);\n+  va_end (ap);\n+}\n+\n+\n+/* Output MESSAGE verbatim into BUFFER.  */\n+void\n+pp_verbatim (pretty_printer *pp, const char *msg, ...)\n+{\n+  text_info text;\n+  va_list ap;\n+\n+  va_start (ap, msg);\n+  text.err_no = errno;\n+  text.args_ptr = &ap;\n+  text.format_spec = msg;\n+  pp_format_verbatim (pp, &text);\n+  va_end (ap);\n+}\n+\n+\n+\n+/* Have PRETTY-PRINTER start a new line.  */\n+void\n+pp_newline (pretty_printer *pp)\n+{\n+  obstack_1grow (&pp->buffer->obstack, '\\n');\n+  pp->buffer->line_length = 0;\n+}\n+\n+/* Have PRETTY-PRINTER add a CHARACTER.  */\n+void\n+pp_character (pretty_printer *pp, int c)\n+{\n+  if (pp_is_wrapping_line (pp)\n+      && pp_remaining_character_count_for_line (pp) <= 0)\n+    {\n+      pp_newline (pp);\n+      if (ISSPACE (c))\n+        return;\n+    }\n+  obstack_1grow (&pp->buffer->obstack, c);\n+  ++pp->buffer->line_length;\n+}\n+\n+/* Append a STRING to the output area of PRETTY-PRINTER; the STRING may\n+   be line-wrapped if in appropriate mode.  */\n+void\n+pp_string (pretty_printer *pp, const char *str)\n+{\n+  pp_maybe_wrap_text (pp, str, str + (str ? strlen (str) : 0));\n+}\n+\n+"}, {"sha": "2b4e55921ed6e8c049a877d42ff7af50f7c78d16", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 186, "deletions": 52, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -1,5 +1,5 @@\n /* Various declarations for language-independent pretty-print subroutines.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n This file is part of GCC.\n@@ -22,7 +22,47 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_PRETTY_PRINT_H\n #define GCC_PRETTY_PRINT_H\n \n-#include \"diagnostic.h\"\n+#include \"obstack.h\"\n+#include \"input.h\"\n+\n+/* The type of a text to be formatted according a format specification\n+   along with a list of things.  */\n+typedef struct\n+{\n+  const char *format_spec;\n+  va_list *args_ptr;\n+  int err_no;  /* for %m */\n+} text_info;\n+\n+/* How often diagnostics are prefixed by their locations:\n+   o DIAGNOSTICS_SHOW_PREFIX_NEVER: never - not yet supported;\n+   o DIAGNOSTICS_SHOW_PREFIX_ONCE: emit only once;\n+   o DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE: emit each time a physical\n+   line is started.  */\n+typedef enum\n+{\n+  DIAGNOSTICS_SHOW_PREFIX_ONCE       = 0x0,\n+  DIAGNOSTICS_SHOW_PREFIX_NEVER      = 0x1,\n+  DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE = 0x2\n+} diagnostic_prefixing_rule_t;\n+\n+/* The output buffer datatype.  This is best seen as an abstract datatype\n+   whose fields should not be accessed directly by clients.  */\n+typedef struct \n+{\n+  /* The obstack where the text is built up.  */  \n+  struct obstack obstack;\n+\n+  /* Where to output formatted text.  */\n+  FILE *stream;\n+\n+  /* The amount of characters output so far.  */  \n+  int line_length;\n+\n+  /* This must be large enough to hold any printed integer or\n+     floating-point value.  */\n+  char digit_buffer[128];\n+} output_buffer;\n \n /* The type of pretty-printer flags passed to clients.  */\n typedef unsigned int pp_flags;\n@@ -32,69 +72,163 @@ typedef enum\n   pp_none, pp_before, pp_after\n } pp_padding;\n \n+/* The type of a hook that formats client-specific data onto a pretty_pinter.\n+   A client-supplied formatter returns true if everything goes well,\n+   otherwise it returns false.  */\n+typedef struct pretty_print_info pretty_printer;\n+typedef bool (*printer_fn) (pretty_printer *, text_info *);\n+\n+/* Client supplied function used to decode formats.  */\n+#define pp_format_decoder(PP) pp_base (PP)->format_decoder\n+\n+/* TRUE if a newline character needs to be added before further\n+   formatting.  */\n+#define pp_needs_newline(PP)  pp_base (PP)->need_newline \n+\n+/* Maximum characters per line in automatic line wrapping mode.\n+   Zero means don't wrap lines.  */\n+#define pp_line_cutoff(PP)  pp_base (PP)->ideal_maximum_length\n+\n+/* True if PRETTY-PTINTER is in line-wrapping mode.  */\n+#define pp_is_wrapping_line(PP) (pp_line_cutoff (PP) > 0)\n+\n+/* Prefixing rule used in formatting a diagnostic message.  */\n+#define pp_prefixing_rule(PP)  pp_base (PP)->prefixing_rule\n+\n+/* The amount of whitespace to be emitted when starting a new line.  */\n+#define pp_indentation(PP) pp_base (PP)->indent_skip\n+\n+/* The data structure that contains the bare minimum required to do\n+   proper pretty-printing.  Clients may derived from this structure\n+   and add additional fields they need.  */\n struct pretty_print_info\n {\n   /* Where we print external representation of ENTITY.  */\n   output_buffer *buffer;\n+\n+  /* The prefix for each new line.  */\n+  const char *prefix;\n+\n   pp_flags flags;\n+  \n   /* Where to put whitespace around the entity being formatted.  */\n   pp_padding padding;\n+  \n+  /* The real upper bound of number of characters per line, taking into\n+     account the case of a very very looong prefix.  */  \n+  int maximum_length;\n+\n+  /* The ideal upper bound of number of characters per line, as suggested\n+     by front-end.  */  \n+  int ideal_maximum_length;\n+\n+  /* Indentation count.  */\n+  int indent_skip;\n+\n+  /* Current prefixing rule.  */\n+  diagnostic_prefixing_rule_t prefixing_rule;\n+\n+  /* If non-NULL, this function formats a TEXT into the BUFFER.  When called,\n+     TEXT->format_spec points to a format code.  FORMAT_DECODER should call\n+     pp_string (and related functions) to add data to the BUFFER.\n+     FORMAT_DECODER can read arguments from *TEXT->args_pts using VA_ARG.\n+     If the BUFFER needs additional characters from the format string, it\n+     should advance the TEXT->format_spec as it goes.  When FORMAT_DECODER\n+     returns, TEXT->format_spec should point to the last character processed.\n+  */\n+  printer_fn format_decoder;\n+\n+  /* Nonzero if current PREFIX was emitted at least once.  */\n+  bool emitted_prefix;\n+\n+  /* Nonzero means one should emit a newline before outputting anything.  */\n+  bool need_newline;\n };\n \n-#define pp_left_paren(PPI)      output_add_character (pp_buffer (PPI), '(')\n-#define pp_right_paren(PPI)     output_add_character (pp_buffer (PPI), ')')\n-#define pp_left_bracket(PPI)    output_add_character (pp_buffer (PPI), '[')\n-#define pp_right_bracket(PPI)   output_add_character (pp_buffer (PPI), ']')\n-#define pp_left_brace(PPI)      output_add_character (pp_buffer (PPI), '{')\n-#define pp_right_brace(PPI)     output_add_character (pp_buffer (PPI), '}')\n-#define pp_semicolon(PPI)       output_add_character (pp_buffer (PPI), ';')\n-#define pp_comma(PPI)           output_add_string (pp_buffer (PPI), \", \")\n-#define pp_dot(PPI)             output_add_character (pp_buffer (PPI), '.')\n-#define pp_colon(PPI)           output_add_character (pp_buffer (PPI), ':')\n-#define pp_colon_colon(PPI)     output_add_string (pp_buffer (PPI), \"::\")\n-#define pp_arrow(PPI)           output_add_string (pp_buffer (PPI), \"->\")\n-#define pp_equal(PPI)           output_add_character (pp_buffer (PPI), '=')\n-#define pp_question(PPI)        output_add_character (pp_buffer (PPI), '?')\n-#define pp_bar(PPI)             output_add_character (pp_buffer (PPI), '|')\n-#define pp_carret(PPI)          output_add_character (pp_buffer (PPI), '^')\n-#define pp_ampersand(PPI)       output_add_character (pp_buffer (PPI), '&')\n-#define pp_less(PPI)            output_add_character (pp_buffer (PPI), '<')\n-#define pp_greater(PPI)         output_add_character (pp_buffer (PPI), '>')\n-#define pp_plus(PPI)            output_add_character (pp_buffer (PPI), '+')\n-#define pp_minus(PPI)           output_add_character (pp_buffer (PPI), '-')\n-#define pp_star(PPI)            output_add_character (pp_buffer (PPI), '*')\n-#define pp_slash(PPI)           output_add_character (pp_buffer (PPI), '/')\n-#define pp_modulo(PPI)          output_add_character (pp_buffer (PPI), '%')\n-#define pp_exclamation(PPI)     output_add_character (pp_buffer (PPI), '!')\n-#define pp_complement(PPI)      output_add_character (pp_buffer (PPI), '~')\n-#define pp_quote(PPI)           output_add_character (pp_buffer (PPI), '\\'')\n-#define pp_backquote(PPI)       output_add_character (pp_buffer (PPI), '`')\n-#define pp_doublequote(PPI)     output_add_character (pp_buffer (PPI), '\"')\n-#define pp_newline(PPI)         output_add_newline (pp_buffer (PPI))\n-#define pp_character(PPI, C)    output_add_character (pp_buffer (PPI), C)\n-#define pp_whitespace(PPI)      output_add_space (pp_buffer (PPI))\n-#define pp_indentation(PPI)     output_indentation (pp_buffer (PPI))\n-#define pp_newline_and_indent(PPI, N) \\\n-  do {                                \\\n-    pp_indentation (PPI) += N;        \\\n-    pp_newline (PPI);                 \\\n+#define pp_space(PP)            pp_character (pp_base (PP), ' ')\n+#define pp_left_paren(PP)       pp_character (pp_base (PP), '(')\n+#define pp_right_paren(PP)      pp_character (pp_base (PP), ')')\n+#define pp_left_bracket(PP)     pp_character (pp_base (PP), '[')\n+#define pp_right_bracket(PP)    pp_character (pp_base (PP), ']')\n+#define pp_left_brace(PP)       pp_character (pp_base (PP), '{')\n+#define pp_right_brace(PP)      pp_character (pp_base (PP), '}')\n+#define pp_semicolon(PP)        pp_character (pp_base (PP), ';')\n+#define pp_comma(PP)            pp_string (pp_base (PP), \", \")\n+#define pp_dot(PP)              pp_character (pp_base (PP), '.')\n+#define pp_colon(PP)            pp_character (pp_base (PP), ':')\n+#define pp_colon_colon(PP)      pp_string (pp_base (PP), \"::\")\n+#define pp_arrow(PP)            pp_string (pp_base (PP), \"->\")\n+#define pp_equal(PP)            pp_character (pp_base (PP), '=')\n+#define pp_question(PP)         pp_character (pp_base (PP), '?')\n+#define pp_bar(PP)              pp_character (pp_base (PP), '|')\n+#define pp_carret(PP)           pp_character (pp_base (PP), '^')\n+#define pp_ampersand(PP)        pp_character (pp_base (PP), '&')\n+#define pp_less(PP)             pp_character (pp_base (PP), '<')\n+#define pp_greater(PP)          pp_character (pp_base (PP), '>')\n+#define pp_plus(PP)             pp_character (pp_base (PP), '+')\n+#define pp_minus(PP)            pp_character (pp_base (PP), '-')\n+#define pp_star(PP)             pp_character (pp_base (PP), '*')\n+#define pp_slash(PP)            pp_character (pp_base (PP), '/')\n+#define pp_modulo(PP)           pp_character (pp_base (PP), '%')\n+#define pp_exclamation(PP)      pp_character (pp_base (PP), '!')\n+#define pp_complement(PP)       pp_character (pp_base (PP), '~')\n+#define pp_quote(PP)            pp_character (pp_base (PP), '\\'')\n+#define pp_backquote(PP)        pp_character (pp_base (PP), '`')\n+#define pp_doublequote(PP)      pp_character (pp_base (PP), '\"')\n+#define pp_newline_and_indent(PP, N) \\\n+  do {                               \\\n+    pp_indentation (PP) += N;        \\\n+    pp_newline (PP);                 \\\n   } while (0)\n-#define pp_separate_with(PPI, C) \\\n-   do {                          \\\n-     pp_character (PPI, C);      \\\n-     pp_whitespace (PPI);        \\\n+#define pp_separate_with(PP, C)     \\\n+   do {                             \\\n+     pp_character (pp_base (PP), C);\\\n+     pp_space (PP);                 \\\n    } while (0)\n-#define pp_format_scalar(PPI, F, S) \\\n-   output_formatted_scalar (pp_buffer (PPI), F, S)\n-#define pp_wide_integer(PPI, I) \\\n-   pp_format_scalar (PPI, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT) I)\n-#define pp_pointer(PPI, P) pp_format_scalar (PPI, \"%p\", p)\n+#define pp_scalar(PP, FORMAT, SCALAR)\t                            \\\n+  do\t\t\t\t\t\t\t\t    \\\n+    {\t\t\t\t\t\t\t\t    \\\n+      sprintf (pp_base (PP)->buffer->digit_buffer, FORMAT, SCALAR); \\\n+      pp_string (pp_base (PP), pp_base (PP)->buffer->digit_buffer); \\\n+    }\t\t\t\t\t\t\t\t    \\\n+  while (0)\n+#define pp_decimal_int(PP, I)  pp_scalar (PP, \"%d\", I)\n+#define pp_wide_integer(PP, I) \\\n+   pp_scalar (PP, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT) I)\n+#define pp_pointer(PP, P)      pp_scalar (PP, \"%p\", P)\n \n-#define pp_identifier(PPI, ID)  output_add_string (pp_buffer (PPI), ID)\n-#define pp_tree_identifier(PPI, T) pp_identifier(PPI, IDENTIFIER_POINTER (T))\n+#define pp_identifier(PP, ID)  pp_string (pp_base (PP), ID)\n+#define pp_tree_identifier(PP, T)                      \\\n+  pp_append_text(pp_base (PP), IDENTIFIER_POINTER (T), \\\n+                 IDENTIFIER_POINTER (T) + IDENTIFIER_LENGTH (T))\n \n-#define pp_unsupported_tree(PPI, T) \\\n-  output_verbatim (pp_buffer(PPI), \"#`%s' not supported by %s#\",\\\n+#define pp_unsupported_tree(PP, T) \\\n+  pp_verbatim (pp_base (PP), \"#`%s' not supported by %s#\",\\\n                    tree_code_name[(int) TREE_CODE (T)], __FUNCTION__)\n \n+\n+/* Clients that directly derive from pretty_printer need to override\n+   this macro to return a pointer to the base pretty_printer structrure.  */\n+#define pp_base(PP) (PP)\n+\n+extern void pp_construct (pretty_printer *, const char *, int);\n+extern void pp_set_line_maximum_length (pretty_printer *, int);\n+extern void pp_set_prefix (pretty_printer *, const char *);\n+extern void pp_destroy_prefix (pretty_printer *);\n+extern int pp_remaining_character_count_for_line (pretty_printer *);\n+extern void pp_clear_output_area (pretty_printer *);\n+extern const char *pp_formatted_text (pretty_printer *);\n+extern const char *pp_last_position_in_text (const pretty_printer *);\n+extern void pp_emit_prefix (pretty_printer *);\n+extern void pp_append_text (pretty_printer *, const char *, const char *);\n+extern void pp_printf (pretty_printer *, const char *, ...) ATTRIBUTE_PRINTF_2;\n+extern void pp_verbatim (pretty_printer *, const char *, ...);\n+extern void pp_flush (pretty_printer *);\n+extern void pp_format_text (pretty_printer *, text_info *);\n+extern void pp_format_verbatim (pretty_printer *, text_info *);\n+\n+extern void pp_newline (pretty_printer *);\n+extern void pp_character (pretty_printer *, int);\n+extern void pp_string (pretty_printer *, const char *);\n+\n #endif /* GCC_PRETTY_PRINT_H */"}, {"sha": "a4900ec0822932dd8b33a533f7f1a30e62cdd566", "filename": "gcc/stmt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -986,8 +986,8 @@ fixup_gotos (struct nesting *thisblock, rtx stack_level,\n \t      && INSN_UID (first_insn) > INSN_UID (f->before_jump)\n \t      && ! DECL_ERROR_ISSUED (f->target))\n \t    {\n-\t      error_with_decl (f->target,\n-\t\t\t       \"label `%s' used before containing binding contour\");\n+\t      error (\"%Hlabel '%D' used before containing binding contour\",\n+                     &DECL_SOURCE_LOCATION (f->target), f->target);\n \t      /* Prevent multiple errors for one label.  */\n \t      DECL_ERROR_ISSUED (f->target) = 1;\n \t    }\n@@ -3636,7 +3636,7 @@ warn_about_unused_variables (tree vars)\n \t  && ! TREE_USED (decl)\n \t  && ! DECL_IN_SYSTEM_HEADER (decl)\n \t  && DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n-\twarning_with_decl (decl, \"unused variable `%s'\");\n+\twarning (\"%Hunused variable '%D'\", &DECL_SOURCE_LOCATION (decl), decl);\n }\n \n /* Generate RTL code to terminate a binding contour.\n@@ -3696,8 +3696,8 @@ expand_end_bindings (tree vars, int mark_ends, int dont_jump_in)\n \t     that must be an error, because gotos without fixups\n \t     come from outside all saved stack-levels.  */\n \t  if (TREE_ADDRESSABLE (chain->label))\n-\t    error_with_decl (chain->label,\n-\t\t\t     \"label `%s' used before containing binding contour\");\n+\t    error (\"%Hlabel '%D' used before containing binding contour\",\n+                   &DECL_SOURCE_LOCATION (chain->label), chain->label);\n \t}\n     }\n "}, {"sha": "e2395c451c54706efe9ad93cf532c56ecab702e5", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -515,10 +515,11 @@ layout_decl (tree decl, unsigned int known_align)\n \t  int size_as_int = TREE_INT_CST_LOW (size);\n \n \t  if (compare_tree_int (size, size_as_int) == 0)\n-\t    warning_with_decl (decl, \"size of `%s' is %d bytes\", size_as_int);\n+\t    warning (\"%Hsize of '%D' is %d bytes\",\n+                     &DECL_SOURCE_LOCATION (decl), decl, size_as_int);\n \t  else\n-\t    warning_with_decl (decl, \"size of `%s' is larger than %d bytes\",\n-\t\t\t       larger_than_size);\n+\t    warning (\"size of '%D' is larger than %d bytes\",\n+                     &DECL_SOURCE_LOCATION (decl), decl, larger_than_size);\n \t}\n     }\n \n@@ -883,9 +884,11 @@ place_field (record_layout_info rli, tree field)\n \t  if (TYPE_ALIGN (type) > desired_align)\n \t    {\n \t      if (STRICT_ALIGNMENT)\n-\t\twarning_with_decl (field, \"packed attribute causes inefficient alignment for `%s'\");\n+\t\twarning (\"%Hpacked attribute causes inefficient alignment \"\n+                         \"for '%D'\", &DECL_SOURCE_LOCATION (field), field);\n \t      else\n-\t\twarning_with_decl (field, \"packed attribute is unnecessary for `%s'\");\n+\t\twarning (\"%Hpacked attribute is unnecessary for '%D'\",\n+                         &DECL_SOURCE_LOCATION (field), field);\n \t    }\n \t}\n       else\n@@ -900,7 +903,8 @@ place_field (record_layout_info rli, tree field)\n \t Bump the cumulative size to multiple of field alignment.  */\n \n       if (warn_padded)\n-\twarning_with_decl (field, \"padding struct to align `%s'\");\n+\twarning (\"%Hpadding struct to align '%D'\",\n+                 &DECL_SOURCE_LOCATION (field), field);\n \n       /* If the alignment is still within offset_align, just align\n \t the bit position.  */"}, {"sha": "144db9801865b63eba3828948602755c664c3743", "filename": "gcc/toplev.c", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -1659,11 +1659,11 @@ check_global_declarations (tree *vec, int len)\n \t  && ! TREE_PUBLIC (decl))\n \t{\n \t  if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-\t    pedwarn_with_decl (decl,\n-\t\t\t       \"`%s' used but never defined\");\n+\t    pedwarn (\"%H'%F' used but never defined\",\n+                     &DECL_SOURCE_LOCATION (decl), decl);\n \t  else\n-\t    warning_with_decl (decl,\n-\t\t\t       \"`%s' declared `static' but never defined\");\n+\t    warning (\"%H'%F' declared `static' but never defined\",\n+                     &DECL_SOURCE_LOCATION (decl), decl);\n \t  /* This symbol is effectively an \"extern\" declaration now.  */\n \t  TREE_PUBLIC (decl) = 1;\n \t  assemble_external (decl);\n@@ -1684,7 +1684,8 @@ check_global_declarations (tree *vec, int len)\n \t  && ! (TREE_CODE (decl) == VAR_DECL && DECL_REGISTER (decl))\n \t  /* Otherwise, ask the language.  */\n \t  && (*lang_hooks.decls.warn_unused_global) (decl))\n-\twarning_with_decl (decl, \"`%s' defined but not used\");\n+\twarning (\"%H'%D' defined but not used\",\n+                 &DECL_SOURCE_LOCATION (decl), decl);\n \n       /* Avoid confusing the debug information machinery when there are\n \t errors.  */\n@@ -2512,8 +2513,15 @@ rest_of_handle_inlining (tree decl)\n       timevar_pop (TV_INTEGRATION);\n       if (lose || ! optimize)\n \t{\n-\t  if (warn_inline && DECL_INLINE (decl))\n-\t    warning_with_decl (decl, lose);\n+\t  if (warn_inline && lose && DECL_INLINE (decl))\n+            {\n+              char *msg = xmalloc (2 + strlen (lose) + 1);\n+              msg[0] = '%';\n+              msg[1] = 'H';\n+              strcpy(msg + 2, lose);\n+              warning (msg, &DECL_SOURCE_LOCATION (decl));\n+              free (msg);\n+            }\n \t  DECL_ABSTRACT_ORIGIN (decl) = 0;\n \t  /* Don't really compile an extern inline function.\n \t     If we can't make it inline, pretend\n@@ -4091,6 +4099,29 @@ init_asm_output (const char *name)\n     }\n }\n \n+/* Default tree printer.   Handles declarations only.  */\n+static bool\n+default_tree_printer (pretty_printer * pp, text_info *text)\n+{\n+  switch (*text->format_spec)\n+    {\n+    case 'D':\n+    case 'F':\n+    case 'T':\n+      {\n+        tree t = va_arg (*text->args_ptr, tree);\n+        const char *n = DECL_NAME (t)\n+          ? (*lang_hooks.decl_printable_name) (t, 2)\n+          : \"<anonymous>\";\n+        pp_string (pp, n);\n+      }\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Initialization of the front end environment, before command line\n    options are parsed.  Signal handlers, internationalization etc.\n    ARGV0 is main's argv[0].  */\n@@ -4110,6 +4141,13 @@ general_init (const char *argv0)\n \n   gcc_init_libintl ();\n \n+  /* Initialize the diagnostics reporting machinery, so option parsing\n+     can give warnings and errors.  */\n+  diagnostic_initialize (global_dc);\n+  /* Set a default printer.  Language specific initializations will\n+     override it later.  */\n+  pp_format_decoder (global_dc->printer) = &default_tree_printer;\n+\n   /* Trap fatal signals, e.g. SIGSEGV, and convert them to ICE messages.  */\n #ifdef SIGSEGV\n   signal (SIGSEGV, crash_signal);\n@@ -4133,10 +4171,6 @@ general_init (const char *argv0)\n   /* Other host-specific signal setup.  */\n   (*host_hooks.extra_signals)();\n \n-  /* Initialize the diagnostics reporting machinery, so option parsing\n-     can give warnings and errors.  */\n-  diagnostic_initialize (global_dc);\n-\n   /* Initialize the garbage-collector, string pools and tree type hash\n      table.  */\n   init_ggc ();"}, {"sha": "c45105c760e7260054c8a366135908213f504ec1", "filename": "gcc/toplev.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -56,21 +56,17 @@ extern void _fatal_insn (const char *, rtx, const char *, int, const char *)\n extern void internal_error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2)\n      ATTRIBUTE_NORETURN;\n extern void warning (const char *, ...);\n-extern void error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n+extern void error (const char *, ...);\n extern void fatal_error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2)\n      ATTRIBUTE_NORETURN;\n-extern void pedwarn (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n+extern void pedwarn (const char *, ...);\n extern void sorry (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n extern void inform (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n \n extern void rest_of_decl_compilation (tree, const char *, int, int);\n extern void rest_of_type_compilation (tree, int);\n extern void rest_of_compilation (tree);\n \n-extern void pedwarn_with_decl (tree, const char *, ...);\n-extern void warning_with_decl (tree, const char *, ...);\n-extern void error_with_decl (tree, const char *, ...);\n-\n extern void announce_function (tree);\n \n extern void error_for_asm (rtx, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);"}, {"sha": "759dc07473149cb8ae575bb01cce7b287d1cab00", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -1171,7 +1171,8 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n       if (warn_inline && DECL_INLINE (fn) && !DID_INLINE_FUNC (fn)\n \t  && !DECL_IN_SYSTEM_HEADER (fn))\n \t{\n-\t  warning_with_decl (fn, \"inlining failed in call to `%s'\");\n+\t  warning (\"%Hinlining failed in call to '%F'\",\n+                   &DECL_SOURCE_LOCATION (fn), fn);\n \t  warning (\"called from here\");\n \t}\n       return NULL_TREE;"}, {"sha": "a8ff36fb0dcc709c448c81f3eab136346457d759", "filename": "gcc/varasm.c", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "patch": "@@ -432,7 +432,8 @@ named_section (tree decl, const char *name, int reloc)\n     {\n       flags = get_named_section_flags (name);\n       if ((flags & SECTION_OVERRIDE) == 0)\n-\terror_with_decl (decl, \"%s causes a section type conflict\");\n+\terror (\"%H%D causes a section type conflict\",\n+               &DECL_SOURCE_LOCATION (decl), decl);\n     }\n \n   named_section_flags (name, flags);\n@@ -802,15 +803,17 @@ make_decl_rtl (tree decl, const char *asmspec)\n     {\n       /* First detect errors in declaring global registers.  */\n       if (reg_number == -1)\n-\terror_with_decl (decl, \"register name not specified for `%s'\");\n+\terror (\"%Hregister name not specified for '%D'\",\n+               &DECL_SOURCE_LOCATION (decl), decl);\n       else if (reg_number < 0)\n-\terror_with_decl (decl, \"invalid register name for `%s'\");\n+\terror (\"%Hinvalid register name for '%D'\",\n+               &DECL_SOURCE_LOCATION (decl), decl);\n       else if (TYPE_MODE (TREE_TYPE (decl)) == BLKmode)\n-\terror_with_decl (decl,\n-\t\t\t \"data type of `%s' isn't suitable for a register\");\n+\terror (\"%Hdata type of '%D' isn't suitable for a register\",\n+               &DECL_SOURCE_LOCATION (decl), decl);\n       else if (! HARD_REGNO_MODE_OK (reg_number, TYPE_MODE (TREE_TYPE (decl))))\n-\terror_with_decl (decl,\n-\t\t\t \"register specified for `%s' isn't suitable for data type\");\n+\terror (\"%Hregister specified for '%D' isn't suitable for data type\",\n+               &DECL_SOURCE_LOCATION (decl), decl);\n       /* Now handle properly declared static register variables.  */\n       else\n \t{\n@@ -854,8 +857,8 @@ make_decl_rtl (tree decl, const char *asmspec)\n      Also handle vars declared register invalidly.  */\n \n   if (reg_number >= 0 || reg_number == -3)\n-    error_with_decl (decl,\n-\t\t     \"register name given for non-register variable `%s'\");\n+    error (\"%Hregister name given for non-register variable '%D'\",\n+           &DECL_SOURCE_LOCATION (decl), decl);\n \n   /* Specifying a section attribute on a variable forces it into a\n      non-.bss section, and thus it cannot be common.  */\n@@ -1391,7 +1394,8 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   if (! dont_output_data\n       && ! host_integerp (DECL_SIZE_UNIT (decl), 1))\n     {\n-      error_with_decl (decl, \"size of variable `%s' is too large\");\n+      error (\"%Hsize of variable '%D' is too large\",\n+             &DECL_SOURCE_LOCATION (decl), decl);\n       return;\n     }\n \n@@ -1429,9 +1433,9 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n #endif\n   if (align > MAX_OFILE_ALIGNMENT)\n     {\n-      warning_with_decl (decl,\n-\t\"alignment of `%s' is greater than maximum object file alignment. Using %d\",\n-\t\t\t MAX_OFILE_ALIGNMENT/BITS_PER_UNIT);\n+      warning (\"%Halignment of '%D' is greater than maximum object \"\n+               \"file alignment.  Using %d\", &DECL_SOURCE_LOCATION (decl),\n+               decl, MAX_OFILE_ALIGNMENT/BITS_PER_UNIT);\n       align = MAX_OFILE_ALIGNMENT;\n     }\n \n@@ -1497,8 +1501,9 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \n #if !defined(ASM_OUTPUT_ALIGNED_COMMON) && !defined(ASM_OUTPUT_ALIGNED_DECL_COMMON) && !defined(ASM_OUTPUT_ALIGNED_BSS)\n       if ((unsigned HOST_WIDE_INT) DECL_ALIGN (decl) / BITS_PER_UNIT > rounded)\n-\twarning_with_decl\n-\t  (decl, \"requested alignment for %s is greater than implemented alignment of %d\",rounded);\n+\twarning (\"%Hrequested alignment for '%D' is greater than \"\n+                 \"implemented alignment of %d\", &DECL_SOURCE_LOCATION (decl),\n+                 decl, rounded);\n #endif\n \n       /* If the target cannot output uninitialized but not common global data\n@@ -4169,15 +4174,17 @@ merge_weak (tree newdecl, tree olddecl)\n \t declare_weak because the NEWDECL and OLDDECL was not yet\n \t been merged; therefore, TREE_ASM_WRITTEN was not set.  */\n       if (TREE_ASM_WRITTEN (olddecl))\n-\terror_with_decl (newdecl,\n-\t\t\t \"weak declaration of `%s' must precede definition\");\n+\terror (\"%Hweak declaration of '%D' must precede definition\",\n+               &DECL_SOURCE_LOCATION (newdecl), newdecl);\n \n       /* If we've already generated rtl referencing OLDDECL, we may\n \t have done so in a way that will not function properly with\n \t a weak symbol.  */\n       else if (TREE_USED (olddecl)\n \t       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (olddecl)))\n-\twarning_with_decl (newdecl, \"weak declaration of `%s' after first use results in unspecified behavior\");\n+\twarning (\"%Hweak declaration of '%D' after first use results \"\n+                 \"in unspecified behavior\",\n+                 &DECL_SOURCE_LOCATION (newdecl), newdecl);\n \n       if (SUPPORTS_WEAK)\n \t{\n@@ -4210,16 +4217,19 @@ void\n declare_weak (tree decl)\n {\n   if (! TREE_PUBLIC (decl))\n-    error_with_decl (decl, \"weak declaration of `%s' must be public\");\n+    error (\"%Hweak declaration of '%D' must be public\",\n+           &DECL_SOURCE_LOCATION (decl), decl);\n   else if (TREE_CODE (decl) == FUNCTION_DECL && TREE_ASM_WRITTEN (decl))\n-    error_with_decl (decl, \"weak declaration of `%s' must precede definition\");\n+    error (\"%Hweak declaration of '%D' must precede definition\",\n+           &DECL_SOURCE_LOCATION (decl), decl);\n   else if (SUPPORTS_WEAK)\n     {\n       if (! DECL_WEAK (decl))\n \tweak_decls = tree_cons (NULL, decl, weak_decls);\n     }\n   else\n-    warning_with_decl (decl, \"weak declaration of `%s' not supported\");\n+    warning (\"%Hweak declaration of '%D' not supported\",\n+             &DECL_SOURCE_LOCATION (decl), decl);\n \n   mark_weak (decl);\n }"}]}