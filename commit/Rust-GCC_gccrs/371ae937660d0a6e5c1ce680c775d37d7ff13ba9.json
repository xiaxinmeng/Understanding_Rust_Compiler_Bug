{"sha": "371ae937660d0a6e5c1ce680c775d37d7ff13ba9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcxYWU5Mzc2NjBkMGE2ZTVjMWNlNjgwYzc3NWQzN2Q3ZmYxM2JhOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-01-12T10:18:24Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-01-12T10:18:24Z"}, "message": "re PR rtl-optimization/83565 (RTL combine pass yields wrong rotate result)\n\n\tPR rtl-optimization/83565\n\t* rtlanal.c (nonzero_bits1): On WORD_REGISTER_OPERATIONS machines, do\n\tnot extend the result to a larger mode for rotate operations.\n\t(num_sign_bit_copies1): Likewise.\n\nFrom-SVN: r256572", "tree": {"sha": "41fac78fb9fc33bf7665d785001199058967572c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41fac78fb9fc33bf7665d785001199058967572c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/371ae937660d0a6e5c1ce680c775d37d7ff13ba9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/371ae937660d0a6e5c1ce680c775d37d7ff13ba9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/371ae937660d0a6e5c1ce680c775d37d7ff13ba9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/371ae937660d0a6e5c1ce680c775d37d7ff13ba9/comments", "author": null, "committer": null, "parents": [{"sha": "c574147e6298bf5e623c1c10c0deddde8cec507b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c574147e6298bf5e623c1c10c0deddde8cec507b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c574147e6298bf5e623c1c10c0deddde8cec507b"}], "stats": {"total": 108, "additions": 85, "deletions": 23}, "files": [{"sha": "a8737dc22cd0df96e1da56f8b847f35e3cfead15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/371ae937660d0a6e5c1ce680c775d37d7ff13ba9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/371ae937660d0a6e5c1ce680c775d37d7ff13ba9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=371ae937660d0a6e5c1ce680c775d37d7ff13ba9", "patch": "@@ -1,3 +1,10 @@\n+2018-01-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/83565\n+\t* rtlanal.c (nonzero_bits1): On WORD_REGISTER_OPERATIONS machines, do\n+\tnot extend the result to a larger mode for rotate operations.\n+\t(num_sign_bit_copies1): Likewise.\n+\n 2018-01-12  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR target/40411"}, {"sha": "89d586b72886d3c626ffb8031acd720a28690f10", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/371ae937660d0a6e5c1ce680c775d37d7ff13ba9/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/371ae937660d0a6e5c1ce680c775d37d7ff13ba9/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=371ae937660d0a6e5c1ce680c775d37d7ff13ba9", "patch": "@@ -4429,7 +4429,7 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n {\n   unsigned HOST_WIDE_INT nonzero = GET_MODE_MASK (mode);\n   unsigned HOST_WIDE_INT inner_nz;\n-  enum rtx_code code;\n+  enum rtx_code code = GET_CODE (x);\n   machine_mode inner_mode;\n   unsigned int inner_width;\n   scalar_int_mode xmode;\n@@ -4465,16 +4465,16 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n     return nonzero;\n \n   /* If MODE is wider than X, but both are a single word for both the host\n-     and target machines, we can compute this from which bits of the\n-     object might be nonzero in its own mode, taking into account the fact\n-     that on many CISC machines, accessing an object in a wider mode\n-     causes the high-order bits to become undefined.  So they are\n-     not known to be zero.  */\n-\n-  if (!WORD_REGISTER_OPERATIONS\n-      && mode_width > xmode_width\n+     and target machines, we can compute this from which bits of the object\n+     might be nonzero in its own mode, taking into account the fact that, on\n+     CISC machines, accessing an object in a wider mode generally causes the\n+     high-order bits to become undefined, so they are not known to be zero.\n+     We extend this reasoning to RISC machines for rotate operations since the\n+     semantics of the operations in the larger mode is not well defined.  */\n+  if (mode_width > xmode_width\n       && xmode_width <= BITS_PER_WORD\n-      && xmode_width <= HOST_BITS_PER_WIDE_INT)\n+      && xmode_width <= HOST_BITS_PER_WIDE_INT\n+      && (!WORD_REGISTER_OPERATIONS || code == ROTATE || code == ROTATERT))\n     {\n       nonzero &= cached_nonzero_bits (x, xmode,\n \t\t\t\t      known_x, known_mode, known_ret);\n@@ -4484,7 +4484,6 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n \n   /* Please keep nonzero_bits_binary_arith_p above in sync with\n      the code in the switch below.  */\n-  code = GET_CODE (x);\n   switch (code)\n     {\n     case REG:\n@@ -4760,10 +4759,11 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n \t}\n       break;\n \n+    case ASHIFT:\n     case ASHIFTRT:\n     case LSHIFTRT:\n-    case ASHIFT:\n     case ROTATE:\n+    case ROTATERT:\n       /* The nonzero bits are in two classes: any bits within MODE\n \t that aren't in xmode are always significant.  The rest of the\n \t nonzero bits are those that are significant in the operand of\n@@ -4786,10 +4786,17 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n \t  if (mode_width > xmode_width)\n \t    outer = (op_nonzero & nonzero & ~mode_mask);\n \n-\t  if (code == LSHIFTRT)\n-\t    inner >>= count;\n-\t  else if (code == ASHIFTRT)\n+\t  switch (code)\n \t    {\n+\t    case ASHIFT:\n+\t      inner <<= count;\n+\t      break;\n+\n+\t    case LSHIFTRT:\n+\t      inner >>= count;\n+\t      break;\n+\n+\t    case ASHIFTRT:\n \t      inner >>= count;\n \n \t      /* If the sign bit may have been nonzero before the shift, we\n@@ -4798,13 +4805,23 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n \t      if (inner & (HOST_WIDE_INT_1U << (xmode_width - 1 - count)))\n \t\tinner |= (((HOST_WIDE_INT_1U << count) - 1)\n \t\t\t  << (xmode_width - count));\n+\t      break;\n+\n+\t    case ROTATE:\n+\t      inner = (inner << (count % xmode_width)\n+\t\t       | (inner >> (xmode_width - (count % xmode_width))))\n+\t\t      & mode_mask;\n+\t      break;\n+\n+\t    case ROTATERT:\n+\t      inner = (inner >> (count % xmode_width)\n+\t\t       | (inner << (xmode_width - (count % xmode_width))))\n+\t\t      & mode_mask;\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n \t    }\n-\t  else if (code == ASHIFT)\n-\t    inner <<= count;\n-\t  else\n-\t    inner = ((inner << (count % xmode_width)\n-\t\t      | (inner >> (xmode_width - (count % xmode_width))))\n-\t\t     & mode_mask);\n \n \t  nonzero &= (outer | inner);\n \t}\n@@ -4992,8 +5009,10 @@ num_sign_bit_copies1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n     {\n       /* If this machine does not do all register operations on the entire\n \t register and MODE is wider than the mode of X, we can say nothing\n-\t at all about the high-order bits.  */\n-      if (!WORD_REGISTER_OPERATIONS)\n+\t at all about the high-order bits.  We extend this reasoning to every\n+\t machine for rotate operations since the semantics of the operations\n+\t in the larger mode is not well defined.  */\n+      if (!WORD_REGISTER_OPERATIONS || code == ROTATE || code == ROTATERT)\n \treturn 1;\n \n       /* Likewise on machines that do, if the mode of the object is smaller"}, {"sha": "6b6b8e03e5d98816b3dc9dfcb2fab88d395aa30a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/371ae937660d0a6e5c1ce680c775d37d7ff13ba9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/371ae937660d0a6e5c1ce680c775d37d7ff13ba9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=371ae937660d0a6e5c1ce680c775d37d7ff13ba9", "patch": "@@ -1,3 +1,7 @@\n+2018-01-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.c-torture/execute/20180112-1.c: New test.\n+\n 2018-01-12  Tom de Vries  <tom@codesourcery.com>\n \n \t* g++.dg/ext/label13.C: Add dg-require-effective-target indirect_jumps."}, {"sha": "6752661ecb6cd602a5531c8d1bf746f2c03bfcc9", "filename": "gcc/testsuite/gcc.c-torture/execute/20180112-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/371ae937660d0a6e5c1ce680c775d37d7ff13ba9/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20180112-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/371ae937660d0a6e5c1ce680c775d37d7ff13ba9/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20180112-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20180112-1.c?ref=371ae937660d0a6e5c1ce680c775d37d7ff13ba9", "patch": "@@ -0,0 +1,32 @@\n+/* PR rtl-optimization/83565 */\n+/* Testcase by Sergei Trofimovich <slyfox@inbox.ru> */\n+\n+extern void abort (void);\n+\n+typedef unsigned int u32;\n+\n+u32 bug (u32 * result) __attribute__((noinline));\n+u32 bug (u32 * result)\n+{\n+  volatile u32 ss = 0xFFFFffff;\n+  volatile u32 d  = 0xEEEEeeee;\n+  u32 tt = d & 0x00800000;\n+  u32 r  = tt << 8;\n+\n+  r = (r >> 31) | (r <<  1);\n+\n+  u32 u = r^ss;\n+  u32 off = u >> 1;\n+\n+  *result = tt;\n+  return off;\n+}\n+\n+int main(void)\n+{\n+  u32 l;\n+  u32 off = bug(&l);\n+  if (off != 0x7fffffff)\n+    abort ();\n+  return 0;\n+}"}]}