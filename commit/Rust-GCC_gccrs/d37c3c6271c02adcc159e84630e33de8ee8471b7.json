{"sha": "d37c3c6271c02adcc159e84630e33de8ee8471b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM3YzNjNjI3MWMwMmFkY2MxNTllODQ2MzBlMzNkZThlZTg0NzFiNw==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2010-07-27T19:44:51Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2010-07-27T19:44:51Z"}, "message": "re PR target/42495 (redundant memory load)\n\n\tPR target/42495\n\tPR middle-end/42574\n\t* config/arm/arm.c (legitimize_pic_address): Use\n\tgen_calculate_pic_address pattern to emit calculation of PIC address.\n\t(will_be_in_index_register): New function.\n\t(arm_legitimate_address_outer_p, thumb2_legitimate_address_p,)\n\t(thumb1_legitimate_address_p): Use it provided !strict_p.\n\t* config/arm/arm.md (calculate_pic_address): New expand and split.\n\nFrom-SVN: r162595", "tree": {"sha": "f8f2b26252296ce86368166625eb73b53e466f20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8f2b26252296ce86368166625eb73b53e466f20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d37c3c6271c02adcc159e84630e33de8ee8471b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d37c3c6271c02adcc159e84630e33de8ee8471b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d37c3c6271c02adcc159e84630e33de8ee8471b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d37c3c6271c02adcc159e84630e33de8ee8471b7/comments", "author": null, "committer": null, "parents": [{"sha": "3393e880c6040bac26ef0b183273877844dd2116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3393e880c6040bac26ef0b183273877844dd2116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3393e880c6040bac26ef0b183273877844dd2116"}], "stats": {"total": 88, "additions": 72, "deletions": 16}, "files": [{"sha": "0deef9c056629faf1d58cfb36f19b70a827cada4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d37c3c6271c02adcc159e84630e33de8ee8471b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d37c3c6271c02adcc159e84630e33de8ee8471b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d37c3c6271c02adcc159e84630e33de8ee8471b7", "patch": "@@ -1,3 +1,14 @@\n+2010-07-27  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\tPR target/42495\n+\tPR middle-end/42574\n+\t* config/arm/arm.c (legitimize_pic_address): Use\n+\tgen_calculate_pic_address pattern to emit calculation of PIC address.\n+\t(will_be_in_index_register): New function.\n+\t(arm_legitimate_address_outer_p, thumb2_legitimate_address_p,)\n+\t(thumb1_legitimate_address_p): Use it provided !strict_p.\n+\t* config/arm/arm.md (calculate_pic_address): New expand and split.\n+\n 2010-07-27  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \tPR target/42495"}, {"sha": "1146418fbfd105080dcef172d3ba7f37ed1e7297", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d37c3c6271c02adcc159e84630e33de8ee8471b7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d37c3c6271c02adcc159e84630e33de8ee8471b7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d37c3c6271c02adcc159e84630e33de8ee8471b7", "patch": "@@ -4977,17 +4977,13 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n   if (GET_CODE (orig) == SYMBOL_REF\n       || GET_CODE (orig) == LABEL_REF)\n     {\n-      rtx pic_ref, address;\n       rtx insn;\n \n       if (reg == 0)\n \t{\n \t  gcc_assert (can_create_pseudo_p ());\n \t  reg = gen_reg_rtx (Pmode);\n-\t  address = gen_reg_rtx (Pmode);\n \t}\n-      else\n-\taddress = reg;\n \n       /* VxWorks does not impose a fixed gap between segments; the run-time\n \t gap can be different from the object-file gap.  We therefore can't\n@@ -5003,18 +4999,21 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \tinsn = arm_pic_static_addr (orig, reg);\n       else\n \t{\n+\t  rtx pat;\n+\t  rtx mem;\n+\n \t  /* If this function doesn't have a pic register, create one now.  */\n \t  require_pic_register ();\n \n-\t  if (TARGET_32BIT)\n-\t    emit_insn (gen_pic_load_addr_32bit (address, orig));\n-\t  else /* TARGET_THUMB1 */\n-\t    emit_insn (gen_pic_load_addr_thumb1 (address, orig));\n+\t  pat = gen_calculate_pic_address (reg, cfun->machine->pic_reg, orig);\n \n-\t  pic_ref = gen_const_mem (Pmode,\n-\t\t\t\t   gen_rtx_PLUS (Pmode, cfun->machine->pic_reg,\n-\t\t\t\t\t         address));\n-\t  insn = emit_move_insn (reg, pic_ref);\n+\t  /* Make the MEM as close to a constant as possible.  */\n+\t  mem = SET_SRC (pat);\n+\t  gcc_assert (MEM_P (mem) && !MEM_VOLATILE_P (mem));\n+\t  MEM_READONLY_P (mem) = 1;\n+\t  MEM_NOTRAP_P (mem) = 1;\n+\n+\t  insn = emit_insn (pat);\n \t}\n \n       /* Put a REG_EQUAL note on this insn, so that it can be optimized\n@@ -5294,6 +5293,15 @@ pcrel_constant_p (rtx x)\n   return FALSE;\n }\n \n+/* Return true if X will surely end up in an index register after next\n+   splitting pass.  */\n+static bool\n+will_be_in_index_register (const_rtx x)\n+{\n+  /* arm.md: calculate_pic_address will split this into a register.  */\n+  return GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_PIC_SYM;\n+}\n+\n /* Return nonzero if X is a valid ARM state address operand.  */\n int\n arm_legitimate_address_outer_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n@@ -5351,8 +5359,9 @@ arm_legitimate_address_outer_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n       rtx xop1 = XEXP (x, 1);\n \n       return ((arm_address_register_rtx_p (xop0, strict_p)\n-\t       && GET_CODE(xop1) == CONST_INT\n-\t       && arm_legitimate_index_p (mode, xop1, outer, strict_p))\n+\t       && ((GET_CODE(xop1) == CONST_INT\n+\t\t    && arm_legitimate_index_p (mode, xop1, outer, strict_p))\n+\t\t   || (!strict_p && will_be_in_index_register (xop1))))\n \t      || (arm_address_register_rtx_p (xop1, strict_p)\n \t\t  && arm_legitimate_index_p (mode, xop0, outer, strict_p)));\n     }\n@@ -5438,7 +5447,8 @@ thumb2_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n       rtx xop1 = XEXP (x, 1);\n \n       return ((arm_address_register_rtx_p (xop0, strict_p)\n-\t       && thumb2_legitimate_index_p (mode, xop1, strict_p))\n+\t       && (thumb2_legitimate_index_p (mode, xop1, strict_p)\n+\t\t   || (!strict_p && will_be_in_index_register (xop1))))\n \t      || (arm_address_register_rtx_p (xop1, strict_p)\n \t\t  && thumb2_legitimate_index_p (mode, xop0, strict_p)));\n     }\n@@ -5741,7 +5751,8 @@ thumb1_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n \t  && XEXP (x, 0) != frame_pointer_rtx\n \t  && XEXP (x, 1) != frame_pointer_rtx\n \t  && thumb1_index_register_rtx_p (XEXP (x, 0), strict_p)\n-\t  && thumb1_index_register_rtx_p (XEXP (x, 1), strict_p))\n+\t  && (thumb1_index_register_rtx_p (XEXP (x, 1), strict_p)\n+\t      || (!strict_p && will_be_in_index_register (XEXP (x, 1)))))\n \treturn 1;\n \n       /* REG+const has 5-7 bit offset for non-SP registers.  */\n@@ -7110,6 +7121,12 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t a single register, otherwise it costs one insn per word.  */\n       if (REG_P (XEXP (x, 0)))\n \t*total = COSTS_N_INSNS (1);\n+      else if (flag_pic\n+\t       && GET_CODE (XEXP (x, 0)) == PLUS\n+\t       && will_be_in_index_register (XEXP (XEXP (x, 0), 1)))\n+\t/* This will be split into two instructions.\n+\t   See arm.md:calculate_pic_address.  */\n+\t*total = COSTS_N_INSNS (2);\n       else\n \t*total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n       return true;"}, {"sha": "885d6ed81cba14814ce1bfcae98f7c6d342042f9", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d37c3c6271c02adcc159e84630e33de8ee8471b7/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d37c3c6271c02adcc159e84630e33de8ee8471b7/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d37c3c6271c02adcc159e84630e33de8ee8471b7", "patch": "@@ -5133,6 +5133,34 @@\n ;; we use an unspec.  The offset will be loaded from a constant pool entry,\n ;; since that is the only type of relocation we can use.\n \n+;; Wrap calculation of the whole PIC address in a single pattern for the\n+;; benefit of optimizers, particularly, PRE and HOIST.  Calculation of\n+;; a PIC address involves two loads from memory, so we want to CSE it\n+;; as often as possible.\n+;; This pattern will be split into one of the pic_load_addr_* patterns\n+;; and a move after GCSE optimizations.\n+;;\n+;; Note: Update arm.c: legitimize_pic_address() when changing this pattern.\n+(define_expand \"calculate_pic_address\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (unspec:SI [(match_operand:SI 2 \"\" \"\")]\n+\t\t\t\t    UNSPEC_PIC_SYM))))]\n+  \"flag_pic\"\n+)\n+\n+;; Split calculate_pic_address into pic_load_addr_* and a move.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (unspec:SI [(match_operand:SI 2 \"\" \"\")]\n+\t\t\t\t    UNSPEC_PIC_SYM))))]\n+  \"flag_pic\"\n+  [(set (match_dup 3) (unspec:SI [(match_dup 2)] UNSPEC_PIC_SYM))\n+   (set (match_dup 0) (mem:SI (plus:SI (match_dup 1) (match_dup 3))))]\n+  \"operands[3] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];\"\n+)\n+\n ;; The rather odd constraints on the following are to force reload to leave\n ;; the insn alone, and to force the minipool generation pass to then move\n ;; the GOT symbol to memory."}]}