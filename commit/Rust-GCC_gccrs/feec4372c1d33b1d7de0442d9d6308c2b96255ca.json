{"sha": "feec4372c1d33b1d7de0442d9d6308c2b96255ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVlYzQzNzJjMWQzM2IxZDdkZTA0NDJkOWQ2MzA4YzJiOTYyNTVjYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-22T08:34:09Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-22T08:34:09Z"}, "message": "ada-tree.def: Fix formatting nits.\n\n\t* gcc-interface/ada-tree.def: Fix formatting nits.\n\t(REGION_STMT): Delete.\n\t(HANDLER_STMT): Likewise.\n\t* gcc-interface/ada-tree.h: Fix formatting nits.\n\t(IS_STMT): Delete.\n\t(REGION_STMT_BODY): Likewise.\n\t(REGION_STMT_HANDLE): Likewise.\n\t(REGION_STMT_BLOCK): Likewise.\n\t(HANDLER_STMT_ARG): Likewise.\n\t(HANDLER_STMT_LIST): Likewise.\n\t(HANDLER_STMT_BLOCK): Likewise.\n\t* gcc-interface/gigi.h (fp_prec_to_size): Update comment.\n\t(fp_size_to_prec): Likewise.\n\t(largest_move_alignment): Delete.\n\t(gnat_compute_largest_alignment): Likewise.\n\tFix minor nits.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n\tRemove redundant code.\n\t<E_Array_Type>: Remove redundant assert.\n\t<E_Array_Subtype>: Exit early from index computation in pathological\n\tcases.\n\tRewrite conditional assignment.\n\t(make_type_from_size): Likewise.\n\t* gcc-interface/misc.c (largest_move_alignment): Delete.\n\t(gnat_finish_incomplete_decl): Likewise.\n\t(LANG_HOOKS_FINISH_INCOMPLETE_DECL): Likewise.\n\t(asm_out_file): Likewise\n\t(gnat_print_type) <INTEGER_TYPE>: Fall through to ENUMERAL_TYPE case.\n\t(gnat_dwarf_name): Move around.\n\t* gcc-interface/trans.c (Attribute_to_gnu): Fix minor nits.\n\t(gigi): Remove call to gnat_compute_largest_alignment.\n\t* utils.c (create_field_decl): Rewrite conditional assignment.\n\tFix minor nits.\n\nFrom-SVN: r146551", "tree": {"sha": "bc368177858013d50041be20988e8673b42cffe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc368177858013d50041be20988e8673b42cffe4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/feec4372c1d33b1d7de0442d9d6308c2b96255ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feec4372c1d33b1d7de0442d9d6308c2b96255ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feec4372c1d33b1d7de0442d9d6308c2b96255ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feec4372c1d33b1d7de0442d9d6308c2b96255ca/comments", "author": null, "committer": null, "parents": [{"sha": "7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73"}], "stats": {"total": 512, "additions": 252, "deletions": 260}, "files": [{"sha": "6074e3f439a1f209d59732b92f8a8ffc0ea3eb32", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=feec4372c1d33b1d7de0442d9d6308c2b96255ca", "patch": "@@ -1,3 +1,39 @@\n+2009-04-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.def: Fix formatting nits.\n+\t(REGION_STMT): Delete.\n+\t(HANDLER_STMT): Likewise.\n+\t* gcc-interface/ada-tree.h: Fix formatting nits.\n+\t(IS_STMT): Delete.\n+\t(REGION_STMT_BODY): Likewise.\n+\t(REGION_STMT_HANDLE): Likewise.\n+\t(REGION_STMT_BLOCK): Likewise.\n+\t(HANDLER_STMT_ARG): Likewise.\n+\t(HANDLER_STMT_LIST): Likewise.\n+\t(HANDLER_STMT_BLOCK): Likewise.\n+\t* gcc-interface/gigi.h (fp_prec_to_size): Update comment.\n+\t(fp_size_to_prec): Likewise.\n+\t(largest_move_alignment): Delete.\n+\t(gnat_compute_largest_alignment): Likewise.\n+\tFix minor nits.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n+\tRemove redundant code.\n+\t<E_Array_Type>: Remove redundant assert.\n+\t<E_Array_Subtype>: Exit early from index computation in pathological\n+\tcases.\n+\tRewrite conditional assignment.\n+\t(make_type_from_size): Likewise.\n+\t* gcc-interface/misc.c (largest_move_alignment): Delete.\n+\t(gnat_finish_incomplete_decl): Likewise.\n+\t(LANG_HOOKS_FINISH_INCOMPLETE_DECL): Likewise.\n+\t(asm_out_file): Likewise\n+\t(gnat_print_type) <INTEGER_TYPE>: Fall through to ENUMERAL_TYPE case.\n+\t(gnat_dwarf_name): Move around.\n+\t* gcc-interface/trans.c (Attribute_to_gnu): Fix minor nits.\n+\t(gigi): Remove call to gnat_compute_largest_alignment.\n+\t* utils.c (create_field_decl): Rewrite conditional assignment.\n+\tFix minor nits.\n+\n 2009-04-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity): Compute is_type predicate"}, {"sha": "454b4bd1106de86ec9007dbebf4327deb2dee28c", "filename": "gcc/ada/gcc-interface/ada-tree.def", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.def?ref=feec4372c1d33b1d7de0442d9d6308c2b96255ca", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              Specification                               *\n  *                                                                          *\n- *            Copyright (C) 1992-2008, Free Software Foundation, Inc.       *\n+ *            Copyright (C) 1992-2009, Free Software Foundation, Inc.       *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -23,19 +23,17 @@\n  *                                                                          *\n  ****************************************************************************/\n \n-/* A type that is an unconstrained array itself.  This node is never passed\n-   to GCC. TREE_TYPE is the type of the fat pointer and TYPE_OBJECT_RECORD_TYPE\n-   is the type of a record containing the template and data.  */\n-\n+/* A type that is an unconstrained array.  This node is never passed to GCC.\n+   TREE_TYPE is the type of the fat pointer and TYPE_OBJECT_RECORD_TYPE is\n+   the type of a record containing the template and data.  */\n DEFTREECODE (UNCONSTRAINED_ARRAY_TYPE, \"unconstrained_array_type\", tcc_type, 0)\n \n /* A reference to an unconstrained array.  This node only exists as an\n    intermediate node during the translation of a GNAT tree to a GCC tree;\n    it is never passed to GCC.  The only field used is operand 0, which\n    is the fat pointer object.  */\n-\n DEFTREECODE (UNCONSTRAINED_ARRAY_REF, \"unconstrained_array_ref\",\n-\t    tcc_reference, 1)\n+\t     tcc_reference, 1)\n \n /* An expression that returns an RTL suitable for its type.  Operand 0\n    is an expression to be evaluated for side effects only.  */\n@@ -51,7 +49,7 @@ DEFTREECODE (MINUS_NOMOD_EXPR, \"minus_nomod_expr\", tcc_binary, 2)\n \n /* Same as ADDR_EXPR, except that if the operand represents a bit field,\n    return the address of the byte containing the bit.  This is used\n-   for the 'Address attribute and never shows up in the tree.  */\n+   for the Address attribute and never shows up in the tree.  */\n DEFTREECODE (ATTR_ADDR_EXPR, \"attr_addr_expr\", tcc_reference, 1)\n \n /* Here are the tree codes for the statement types known to Ada.  These\n@@ -64,26 +62,14 @@ DEFTREECODE (ATTR_ADDR_EXPR, \"attr_addr_expr\", tcc_reference, 1)\n DEFTREECODE (STMT_STMT, \"stmt_stmt\", tcc_statement, 1)\n \n /* A loop.  LOOP_STMT_TOP_COND and LOOP_STMT_BOT_COND are the tests to exit a\n-   loop at the top and bottom, respectively.  LOOP_STMT_UPDATE is the statement\n+   loop at the top and bottom respectively.  LOOP_STMT_UPDATE is the statement\n    to update the loop iterator at the continue point.  LOOP_STMT_BODY are the\n-   statements in the body of the loop.  LOOP_STMT_LABEL points to the LABEL_DECL\n-   of the end label of the loop.  */\n+   statements in the body of the loop.  LOOP_STMT_LABEL points to the\n+   LABEL_DECL of the end label of the loop.  */\n DEFTREECODE (LOOP_STMT, \"loop_stmt\", tcc_statement, 5)\n \n /* Conditionally exit a loop.  EXIT_STMT_COND is the condition, which, if\n    true, will cause the loop to be exited.  If no condition is specified,\n    the loop is unconditionally exited.  EXIT_STMT_LABEL is the end label\n    corresponding to the loop to exit.  */\n DEFTREECODE (EXIT_STMT, \"exit_stmt\", tcc_statement, 2)\n-\n-/* A exception region.  REGION_STMT_BODY is the statement to be executed\n-   inside the region.  REGION_STMT_HANDLE is a statement that represents\n-   the exception handlers (usually a BLOCK_STMT of HANDLE_STMTs).\n-   REGION_STMT_BLOCK is the BLOCK node for the declarative region, if any.  */\n-DEFTREECODE (REGION_STMT, \"region_stmt\", tcc_statement, 3)\n-\n-/* An exception handler.  HANDLER_STMT_ARG is the value to pass to \n-   expand_start_catch, HANDLER_STMT_LIST is the list of statements for the\n-   handler itself, and HANDLER_STMT_BLOCK is the BLOCK node for this\n-   binding. */\n-DEFTREECODE (HANDLER_STMT, \"handler_stmt\", tcc_statement, 3)"}, {"sha": "cd2b97038872267f35ae180d5671f0dbf7f1d715", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 30, "deletions": 39, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=feec4372c1d33b1d7de0442d9d6308c2b96255ca", "patch": "@@ -30,24 +30,24 @@ union lang_tree_node\n {\n   union tree_node GTY((tag (\"0\"))) t;\n };\n-struct lang_decl GTY(()) {tree t; };\n-struct lang_type GTY(()) {tree t; };\n+struct lang_decl GTY(()) { tree t; };\n+struct lang_type GTY(()) { tree t; };\n \n /* Define macros to get and set the tree in TYPE_ and DECL_LANG_SPECIFIC.  */\n #define GET_TYPE_LANG_SPECIFIC(NODE) \\\n   (TYPE_LANG_SPECIFIC (NODE) ? TYPE_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n #define SET_TYPE_LANG_SPECIFIC(NODE, X)\t\\\n  (TYPE_LANG_SPECIFIC (NODE)\t\t\t\\\n   = (TYPE_LANG_SPECIFIC (NODE)\t\t\t\\\n-     ? TYPE_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_type)))   \\\n+     ? TYPE_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_type))) \\\n  ->t = X;\n \n #define GET_DECL_LANG_SPECIFIC(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE) ? DECL_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n #define SET_DECL_LANG_SPECIFIC(NODE, VALUE)\t\\\n  (DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n   = (DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n-     ? DECL_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_decl)))   \\\n+     ? DECL_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_decl))) \\\n  ->t = VALUE;\n \n /* Flags added to GCC type nodes.  */\n@@ -57,7 +57,7 @@ struct lang_type GTY(()) {tree t; };\n #define TYPE_IS_FAT_POINTER_P(NODE) \\\n   TYPE_LANG_FLAG_0 (RECORD_OR_UNION_CHECK (NODE))\n \n-#define TYPE_FAT_POINTER_P(NODE)  \\\n+#define TYPE_FAT_POINTER_P(NODE) \\\n   (TREE_CODE (NODE) == RECORD_TYPE && TYPE_IS_FAT_POINTER_P (NODE))\n \n /* For integral types and array types, nonzero if this is a packed array type\n@@ -75,7 +75,7 @@ struct lang_type GTY(()) {tree t; };\n \n /* For ARRAY_TYPE, nonzero if this type corresponds to a dimension of\n    an Ada array other than the first.  */\n-#define TYPE_MULTI_ARRAY_P(NODE)  TYPE_LANG_FLAG_1 (ARRAY_TYPE_CHECK (NODE))\n+#define TYPE_MULTI_ARRAY_P(NODE) TYPE_LANG_FLAG_1 (ARRAY_TYPE_CHECK (NODE))\n \n /* For FUNCTION_TYPE, nonzero if this denotes a function returning an\n    unconstrained array or record.  */\n@@ -102,7 +102,7 @@ struct lang_type GTY(()) {tree t; };\n \n /* For INTEGER_TYPE, nonzero if this really represents a VAX\n    floating-point type.  */\n-#define TYPE_VAX_FLOATING_POINT_P(NODE)  \\\n+#define TYPE_VAX_FLOATING_POINT_P(NODE) \\\n   TYPE_LANG_FLAG_3 (INTEGER_TYPE_CHECK (NODE))\n \n /* True if NODE is a thin pointer.  */\n@@ -154,22 +154,22 @@ struct lang_type GTY(()) {tree t; };\n /* True if TYPE can alias any other types.  */\n #define TYPE_UNIVERSAL_ALIASING_P(NODE) TYPE_LANG_FLAG_6 (NODE)\n \n-/* This field is only defined for FUNCTION_TYPE nodes. If the Ada\n-   subprogram contains no parameters passed by copy in/copy out then this\n-   field is 0. Otherwise it points to a list of nodes used to specify the\n-   return values of the out (or in out) parameters that qualify to be passed\n-   by copy in copy out.  It is a CONSTRUCTOR.  For a full description of the\n-   cico parameter passing mechanism refer to the routine gnat_to_gnu_entity. */\n-#define TYPE_CI_CO_LIST(NODE)  TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))\n+/* This field is only defined for FUNCTION_TYPE nodes. If the Ada subprogram\n+   contains no parameters passed by copy in/copy out then this field is zero.\n+   Otherwise it points to a list of nodes used to specify the return values\n+   of the out (or in out) parameters that qualify to be passed by copy in/\n+   copy out. For a full description of the copy in/copy out parameter passing\n+   mechanism refer to the routine gnat_to_gnu_entity. */\n+#define TYPE_CI_CO_LIST(NODE) TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))\n \n /* For integral types, this is the RM Size of the type.  */\n-#define TYPE_RM_SIZE(NODE)  \\\n+#define TYPE_RM_SIZE(NODE) \\\n   TYPE_LANG_SLOT_1 (TREE_CHECK3 (NODE, ENUMERAL_TYPE, BOOLEAN_TYPE, INTEGER_TYPE))\n \n /* For an INTEGER_TYPE with TYPE_MODULAR_P, this is the value of the\n    modulus. */\n #define TYPE_MODULUS(NODE) GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n-#define SET_TYPE_MODULUS(NODE, X)  \\\n+#define SET_TYPE_MODULUS(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n \n /* For an INTEGER_TYPE that is the TYPE_DOMAIN of some ARRAY_TYPE, points to\n@@ -183,29 +183,29 @@ struct lang_type GTY(()) {tree t; };\n    Digits_Value.  */\n #define TYPE_DIGITS_VALUE(NODE) \\\n   GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n-#define SET_TYPE_DIGITS_VALUE(NODE, X)  \\\n+#define SET_TYPE_DIGITS_VALUE(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n \n /* For a RECORD_TYPE that is a fat pointer, point to the type for the\n    unconstrained object.  Likewise for a RECORD_TYPE that is pointed\n    to by a thin pointer.  */\n-#define TYPE_UNCONSTRAINED_ARRAY(NODE)  \\\n+#define TYPE_UNCONSTRAINED_ARRAY(NODE) \\\n   GET_TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE))\n-#define SET_TYPE_UNCONSTRAINED_ARRAY(NODE, X)  \\\n+#define SET_TYPE_UNCONSTRAINED_ARRAY(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE), X)\n \n /* For other RECORD_TYPEs and all UNION_TYPEs and QUAL_UNION_TYPEs, the Ada\n    size of the object.  This differs from the GCC size in that it does not\n    include any rounding up to the alignment of the type.  */\n-#define TYPE_ADA_SIZE(NODE)   \\\n+#define TYPE_ADA_SIZE(NODE) \\\n   GET_TYPE_LANG_SPECIFIC (RECORD_OR_UNION_CHECK (NODE))\n #define SET_TYPE_ADA_SIZE(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC (RECORD_OR_UNION_CHECK (NODE), X)\n \n /* For an INTEGER_TYPE with TYPE_HAS_ACTUAL_BOUNDS_P or an ARRAY_TYPE, this is\n    the index type that should be used when the actual bounds are required for\n    a template.  This is used in the case of packed arrays.  */\n-#define TYPE_ACTUAL_BOUNDS(NODE)   \\\n+#define TYPE_ACTUAL_BOUNDS(NODE) \\\n   GET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE))\n #define SET_TYPE_ACTUAL_BOUNDS(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE), X)\n@@ -298,24 +298,15 @@ struct lang_type GTY(()) {tree t; };\n    discriminant number.  */\n #define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))\n \n-/* Define fields and macros for statements.\n+/* Define fields and macros for statements.  */\n+#define IS_ADA_STMT(NODE) \\\n+  (STATEMENT_CLASS_P (NODE) && TREE_CODE (NODE) >= STMT_STMT)\n \n-   Start by defining which tree codes are used for statements.  */\n-#define IS_STMT(NODE)\t\t(STATEMENT_CLASS_P (NODE))\n-#define IS_ADA_STMT(NODE)\t(IS_STMT (NODE)\t\t\t\t\\\n-\t\t\t\t && TREE_CODE (NODE) >= STMT_STMT)\n-\n-#define STMT_STMT_STMT(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, STMT_STMT, 0)\n+#define STMT_STMT_STMT(NODE)     TREE_OPERAND_CHECK_CODE (NODE, STMT_STMT, 0)\n #define LOOP_STMT_TOP_COND(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 0)\n #define LOOP_STMT_BOT_COND(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 1)\n-#define LOOP_STMT_UPDATE(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 2)\n-#define LOOP_STMT_BODY(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 3)\n-#define LOOP_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 4)\n-#define EXIT_STMT_COND(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 0)\n-#define EXIT_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 1)\n-#define REGION_STMT_BODY(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 0)\n-#define REGION_STMT_HANDLE(NODE) TREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 1)\n-#define REGION_STMT_BLOCK(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 2)\n-#define HANDLER_STMT_ARG(NODE) TREE_OPERAND_CHECK_CODE (NODE, HANDLER_STMT, 0)\n-#define HANDLER_STMT_LIST(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, HANDLER_STMT, 1)\n-#define HANDLER_STMT_BLOCK(NODE) TREE_OPERAND_CHECK_CODE(NODE, HANDLER_STMT, 2)\n+#define LOOP_STMT_UPDATE(NODE)   TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 2)\n+#define LOOP_STMT_BODY(NODE)     TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 3)\n+#define LOOP_STMT_LABEL(NODE)    TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 4)\n+#define EXIT_STMT_COND(NODE)     TREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 0)\n+#define EXIT_STMT_LABEL(NODE)    TREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 1)"}, {"sha": "31e51b0b34ea7d34acdb9a89109f23642c9f2138", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 72, "deletions": 52, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=feec4372c1d33b1d7de0442d9d6308c2b96255ca", "patch": "@@ -363,7 +363,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  else\n \t    max_esize = LONG_LONG_TYPE_SIZE;\n \n-\t  esize = MIN (esize, max_esize);\n+\t  if (esize > max_esize)\n+\t   esize = max_esize;\n \t}\n       else\n \tesize = LONG_LONG_TYPE_SIZE;\n@@ -1578,15 +1579,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       TYPE_BIASED_REPRESENTATION_P (gnu_type)\n \t= Has_Biased_Representation (gnat_entity);\n \n-     /* This should be an unsigned type if the lower bound is constant\n-\t and non-negative or if the base type is unsigned; a signed type\n-\t otherwise.    */\n-      TYPE_UNSIGNED (gnu_type)\n-\t= (TYPE_UNSIGNED (TREE_TYPE (gnu_type))\n-\t   || (TREE_CODE (TYPE_MIN_VALUE (gnu_type)) == INTEGER_CST\n-\t       && TREE_INT_CST_HIGH (TYPE_MIN_VALUE (gnu_type)) >= 0)\n-\t   || TYPE_BIASED_REPRESENTATION_P (gnu_type)\n-\t   || Is_Unsigned_Type (gnat_entity));\n+      /* This should be an unsigned type if the base type is unsigned or\n+\t if the lower bound is constant and non-negative (as computed by\n+\t layout_type) or if the type is biased.  */\n+      TYPE_UNSIGNED (gnu_type) = (TYPE_UNSIGNED (TREE_TYPE (gnu_type))\n+\t\t\t\t  || TYPE_BIASED_REPRESENTATION_P (gnu_type)\n+\t\t\t\t  || Is_Unsigned_Type (gnat_entity));\n \n       layout_type (gnu_type);\n \n@@ -1979,14 +1977,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      TYPE_NONALIASED_COMPONENT (tem) = 1;\n \t  }\n \n-\t/* If an alignment is specified, use it if valid.  But ignore it for\n-\t   types that represent the unpacked base type for packed arrays.  If\n-\t   the alignment was requested with an explicit user alignment clause,\n-\t   state so.  */\n+\t/* If an alignment is specified, use it if valid.  But ignore it\n+\t   for the original type of packed array types.  If the alignment\n+\t   was requested with an explicit alignment clause, state so.  */\n \tif (No (Packed_Array_Type (gnat_entity))\n \t    && Known_Alignment (gnat_entity))\n \t  {\n-\t    gcc_assert (Present (Alignment (gnat_entity)));\n \t    TYPE_ALIGN (tem)\n \t      = validate_alignment (Alignment (gnat_entity), gnat_entity,\n \t\t\t\t    TYPE_ALIGN (tem));\n@@ -2124,62 +2120,85 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  && TREE_CODE (gnu_min) == INTEGER_CST\n \t\t  && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t  && TREE_OVERFLOW (gnu_min) && TREE_OVERFLOW (gnu_max)\n-\t\t  && (!TREE_OVERFLOW\n+\t\t  && !TREE_OVERFLOW\n \t\t      (fold_build2 (MINUS_EXPR, gnu_index_subtype,\n \t\t\t\t    TYPE_MAX_VALUE (gnu_index_subtype),\n-\t\t\t\t    TYPE_MIN_VALUE (gnu_index_subtype)))))\n+\t\t\t\t    TYPE_MIN_VALUE (gnu_index_subtype))))\n \t\t{\n \t\t  TREE_OVERFLOW (gnu_min) = 0;\n \t\t  TREE_OVERFLOW (gnu_max) = 0;\n+\t\t  if (tree_int_cst_lt (gnu_max, gnu_min))\n+\t\t    {\n+\t\t      gnu_min = size_one_node;\n+\t\t      gnu_max = size_zero_node;\n+\t\t    }\n+\t\t  gnu_high = gnu_max;\n \t\t}\n \n \t      /* Similarly, if the range is null, use bounds of 1..0 for\n \t\t the sizetype bounds.  */\n \t      else if ((TYPE_PRECISION (gnu_index_subtype)\n \t\t\t> TYPE_PRECISION (sizetype)\n-\t\t       || TYPE_UNSIGNED (gnu_index_subtype)\n-\t\t\t  != TYPE_UNSIGNED (sizetype))\n+\t\t        || TYPE_UNSIGNED (gnu_index_subtype)\n+\t\t\t   != TYPE_UNSIGNED (sizetype))\n \t\t       && TREE_CODE (gnu_min) == INTEGER_CST\n \t\t       && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t       && (TREE_OVERFLOW (gnu_min) || TREE_OVERFLOW (gnu_max))\n \t\t       && tree_int_cst_lt (TYPE_MAX_VALUE (gnu_index_subtype),\n \t\t\t\t\t   TYPE_MIN_VALUE (gnu_index_subtype)))\n-\t\tgnu_min = size_one_node, gnu_max = size_zero_node;\n-\n-\t      /* Now compute the size of this bound.  We need to provide\n-\t\t GCC with an upper bound to use but have to deal with the\n-\t\t \"superflat\" case.  There are three ways to do this.  If we\n-\t\t can prove that the array can never be superflat, we can\n-\t\t just use the high bound of the index subtype.  If we can\n-\t\t prove that the low bound minus one can't overflow, we\n-\t\t can do this as MAX (hb, lb - 1).  Otherwise, we have to use\n-\t\t the expression hb >= lb ? hb : lb - 1.  */\n-\t      gnu_high = size_binop (MINUS_EXPR, gnu_min, size_one_node);\n+\t\t{\n+\t\t  gnu_min = size_one_node;\n+\t\t  gnu_max = size_zero_node;\n+\t\t  gnu_high = gnu_max;\n+\t\t}\n \n \t      /* See if the base array type is already flat.  If it is, we\n-\t\t are probably compiling an ACVC test, but it will cause the\n+\t\t are probably compiling an ACATS test, but it will cause the\n \t\t code below to malfunction if we don't handle it specially.  */\n-\t      if (TREE_CODE (gnu_base_min) == INTEGER_CST\n-\t\t  && TREE_CODE (gnu_base_max) == INTEGER_CST\n-\t\t  && !TREE_OVERFLOW (gnu_base_min)\n-\t\t  && !TREE_OVERFLOW (gnu_base_max)\n-\t\t  && tree_int_cst_lt (gnu_base_max, gnu_base_min))\n-\t\tgnu_high = size_zero_node, gnu_min = size_one_node;\n-\n-\t      /* If gnu_high is now an integer which overflowed, the array\n-\t\t cannot be superflat.  */\n-\t      else if (TREE_CODE (gnu_high) == INTEGER_CST\n-\t\t       && TREE_OVERFLOW (gnu_high))\n-\t\tgnu_high = gnu_max;\n-\t      else if (TYPE_UNSIGNED (gnu_base_subtype)\n-\t\t       || TREE_CODE (gnu_high) == INTEGER_CST)\n-\t\tgnu_high = size_binop (MAX_EXPR, gnu_max, gnu_high);\n+\t      else if (TREE_CODE (gnu_base_min) == INTEGER_CST\n+\t\t       && TREE_CODE (gnu_base_max) == INTEGER_CST\n+\t\t       && !TREE_OVERFLOW (gnu_base_min)\n+\t\t       && !TREE_OVERFLOW (gnu_base_max)\n+\t\t       && tree_int_cst_lt (gnu_base_max, gnu_base_min))\n+\t\t{\n+\t\t  gnu_min = size_one_node;\n+\t\t  gnu_max = size_zero_node;\n+\t\t  gnu_high = gnu_max;\n+\t\t}\n+\n \t      else\n-\t\tgnu_high\n-\t\t  = build_cond_expr\n-\t\t    (sizetype, build_binary_op (GE_EXPR, integer_type_node,\n-\t\t\t\t\t\tgnu_max, gnu_min),\n-\t\t     gnu_max, gnu_high);\n+\t\t{\n+\t\t  /* Now compute the size of this bound.  We need to provide\n+\t\t     GCC with an upper bound to use but have to deal with the\n+\t\t     \"superflat\" case.  There are three ways to do this.  If\n+\t\t     we can prove that the array can never be superflat, we\n+\t\t     can just use the high bound of the index subtype.  If we\n+\t\t     can prove that the low bound minus one can't overflow,\n+\t\t     we can do this as MAX (hb, lb - 1).  Otherwise, we have\n+\t\t     to use the expression hb >= lb ? hb : lb - 1.  */\n+\t\t  gnu_high = size_binop (MINUS_EXPR, gnu_min, size_one_node);\n+\n+\t\t  /* If gnu_high is now an integer which overflowed, the array\n+\t\t     cannot be superflat.  */\n+\t\t  if (TREE_CODE (gnu_high) == INTEGER_CST\n+\t\t      && TREE_OVERFLOW (gnu_high))\n+\t\t    gnu_high = gnu_max;\n+\n+\t\t  /* gnu_high cannot overflow if the subtype is unsigned since\n+\t\t     sizetype is signed, or if it is now a constant that hasn't\n+\t\t     overflowed.  */\n+\t\t  else if (TYPE_UNSIGNED (gnu_base_subtype)\n+\t\t\t   || TREE_CODE (gnu_high) == INTEGER_CST)\n+\t\t    gnu_high = size_binop (MAX_EXPR, gnu_max, gnu_high);\n+\n+\t\t  else\n+\t\t    gnu_high\n+\t\t      = build_cond_expr (sizetype,\n+\t\t\t\t\t build_binary_op (GE_EXPR,\n+\t\t\t\t\t\t\t  integer_type_node,\n+\t\t\t\t\t\t\t  gnu_max, gnu_min),\n+\t\t\t\t\t gnu_max, gnu_high);\n+\t\t}\n \n \t      gnu_index_type[index]\n \t\t= create_index_type (gnu_min, gnu_high, gnu_index_subtype,\n@@ -7338,7 +7357,8 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n \tbreak;\n \n       biased_p |= for_biased;\n-      size = MIN (size, LONG_LONG_TYPE_SIZE);\n+      if (size > LONG_LONG_TYPE_SIZE)\n+\tsize = LONG_LONG_TYPE_SIZE;\n \n       if (TYPE_UNSIGNED (type) || biased_p)\n \tnew_type = make_unsigned_type (size);"}, {"sha": "e9f6885abcaa3178948e028606806b59294a4051", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 44, "deletions": 52, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=feec4372c1d33b1d7de0442d9d6308c2b96255ca", "patch": "@@ -25,30 +25,6 @@\n \n /* Declare all functions and types used by gigi.  */\n \n-/* The largest alignment, in bits, that is needed for using the widest\n-   move instruction.  */\n-extern unsigned int largest_move_alignment;\n-\n-/* Compute the alignment of the largest mode that can be used for copying\n-   objects.  */\n-extern void gnat_compute_largest_alignment (void);\n-\n-/* GNU_TYPE is a type. Determine if it should be passed by reference by\n-   default.  */\n-extern bool default_pass_by_ref (tree gnu_type);\n-\n-/* GNU_TYPE is the type of a subprogram parameter.  Determine from the type\n-   if it should be passed by reference.  */\n-extern bool must_pass_by_ref (tree gnu_type);\n-\n-/* Initialize DUMMY_NODE_TABLE.  */\n-extern void init_dummy_type (void);\n-\n-/* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n-   GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n-   refer to an Ada type.  */\n-extern tree gnat_to_gnu_type (Entity_Id gnat_entity);\n-\n /* Given GNAT_ENTITY, a GNAT defining identifier node, which denotes some Ada\n    entity, this routine returns the equivalent GCC tree for that entity\n    (an ..._DECL node) and associates the ..._DECL node with the input GNAT\n@@ -71,6 +47,10 @@ extern tree gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr,\n    FIELD_DECL.  */\n extern tree gnat_to_gnu_field_decl (Entity_Id gnat_entity);\n \n+/* Similar, but GNAT_ENTITY is assumed to refer to a GNAT type.  Return\n+   the GCC type corresponding to that entity.  */\n+extern tree gnat_to_gnu_type (Entity_Id gnat_entity);\n+\n /* Wrap up compilation of T, a TYPE_DECL, possibly deferring it.  */\n extern void rest_of_type_decl_compilation (tree t);\n \n@@ -98,7 +78,7 @@ extern void add_decl_expr (tree gnu_decl, Entity_Id gnat_entity);\n /* Mark nodes rooted at *TP with TREE_VISITED and types as having their\n    sized gimplified.  We use this to indicate all variable sizes and\n    positions in global types may not be shared by any subprogram.  */\n-extern void mark_visited (tree *);\n+extern void mark_visited (tree *tp);\n \n /* Finalize any From_With_Type incomplete types.  We do this after processing\n    our compilation unit and after processing its spec, if this is a body.  */\n@@ -110,7 +90,7 @@ extern void finalize_from_with_types (void);\n    for its representation, return GNAT_ENTITY.  If a type is supposed to\n    exist, but does not, abort unless annotating types, in which case\n    return Empty.   If GNAT_ENTITY is Empty, return Empty.  */\n-extern Entity_Id Gigi_Equivalent_Type (Entity_Id);\n+extern Entity_Id Gigi_Equivalent_Type (Entity_Id gnat_entity);\n \n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */\n@@ -120,9 +100,6 @@ extern void elaborate_entity (Entity_Id gnat_entity);\n    any entities on its entity chain similarly.  */\n extern void mark_out_of_scope (Entity_Id gnat_entity);\n \n-/* Make a dummy type corresponding to GNAT_TYPE.  */\n-extern tree make_dummy_type (Entity_Id gnat_type);\n-\n /* Get the unpadded version of a GNAT type.  */\n extern tree get_unpadded_type (Entity_Id gnat_entity);\n \n@@ -227,7 +204,7 @@ extern tree gnat_to_gnu (Node_Id gnat_node);\n /* GNU_STMT is a statement.  We generate code for that statement.  */\n extern void gnat_expand_stmt (tree gnu_stmt);\n \n-/* ??? missing documentation */\n+/* Generate GIMPLE in place for the expression at *EXPR_P.  */\n extern int gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n                                gimple_seq *post_p ATTRIBUTE_UNUSED);\n \n@@ -244,7 +221,7 @@ extern bool Sloc_to_locus (Source_Ptr Sloc, location_t *locus);\n /* Post an error message.  MSG is the error message, properly annotated.\n    NODE is the node at which to post the error and the node to use for the\n    \"&\" substitution.  */\n-extern void post_error (const char *, Node_Id);\n+extern void post_error (const char *msg, Node_Id node);\n \n /* Similar, but NODE is the node at which to post the error and ENT\n    is the node to use for the \"&\" substitution.  */\n@@ -273,7 +250,7 @@ extern tree protect_multiple_eval (tree exp);\n \n /* Return a label to branch to for the exception type in KIND or NULL_TREE\n    if none.  */\n-extern tree get_exception_label (char);\n+extern tree get_exception_label (char kind);\n \n /* Current node being treated, in case gigi_abort or Check_Elaboration_Code\n    called.  */\n@@ -381,7 +358,7 @@ enum standard_datatypes\n \n   /* Function declaration nodes for run-time functions for allocating memory.\n      Ada allocators cause calls to these functions to be generated.  Malloc32\n-     is used only on 64bit systems needing to allocate 32bit memory. */\n+     is used only on 64bit systems needing to allocate 32bit memory.  */\n   ADT_malloc_decl,\n   ADT_malloc32_decl,\n \n@@ -442,7 +419,7 @@ extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n /* Returns nonzero if we are currently in the global binding level.  */\n extern int global_bindings_p (void);\n \n-/* Enter and exit a new binding level. */\n+/* Enter and exit a new binding level.  */\n extern void gnat_pushlevel (void);\n extern void gnat_poplevel (void);\n \n@@ -496,6 +473,9 @@ extern tree convert (tree type, tree expr);\n /* Routines created solely for the tree translator's sake. Their prototypes\n    can be changed as desired.  */\n \n+/* Initialize the association of GNAT nodes to GCC trees.  */\n+extern void init_gnat_to_gnu (void);\n+\n /* GNAT_ENTITY is a GNAT tree node for a defining identifier.\n    GNU_DECL is the GCC tree which is to be associated with\n    GNAT_ENTITY. Such gnu tree node is always an ..._DECL node.\n@@ -512,8 +492,11 @@ extern tree get_gnu_tree (Entity_Id gnat_entity);\n /* Return nonzero if a GCC tree has been associated with GNAT_ENTITY.  */\n extern bool present_gnu_tree (Entity_Id gnat_entity);\n \n-/* Initialize tables for above routines.  */\n-extern void init_gnat_to_gnu (void);\n+/* Initialize the association of GNAT nodes to GCC trees as dummies.  */\n+extern void init_dummy_type (void);\n+\n+/* Make a dummy type corresponding to GNAT_TYPE.  */\n+extern tree make_dummy_type (Entity_Id gnat_type);\n \n /* Record TYPE as a builtin type for Ada.  NAME is the name of the type.  */\n extern void record_builtin_type (const char *name, tree type);\n@@ -600,7 +583,7 @@ extern tree create_type_decl (tree type_name, tree type,\n    it indicates whether to always allocate storage to the variable.\n \n    GNAT_NODE is used for the position of the decl.  */\n-tree\n+extern tree\n create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n \t\t   bool const_flag, bool public_flag, bool extern_flag,\n \t\t   bool static_flag, bool const_decl_allowed_p,\n@@ -629,11 +612,11 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n /* Given a DECL and ATTR_LIST, apply the listed attributes.  */\n extern void process_attributes (tree decl, struct attrib *attr_list);\n \n-/* Record a global renaming pointer.  */\n-void record_global_renaming_pointer (tree);\n+/* Record DECL as a global renaming pointer.  */\n+extern void record_global_renaming_pointer (tree decl);\n \n-/* Invalidate the global renaming pointers.   */\n-void invalidate_global_renaming_pointers (void);\n+/* Invalidate the global renaming pointers.  */\n+extern void invalidate_global_renaming_pointers (void);\n \n /* Returns a FIELD_DECL node. FIELD_NAME the field name, FIELD_TYPE is its\n    type, and RECORD_TYPE is the type of the parent.  PACKED is nonzero if\n@@ -648,7 +631,7 @@ extern tree create_field_decl (tree field_name, tree field_type,\n /* Returns a PARM_DECL node. PARAM_NAME is the name of the parameter,\n    PARAM_TYPE is its type.  READONLY is true if the parameter is\n    readonly (either an In parameter or an address of a pass-by-ref\n-   parameter). */\n+   parameter).  */\n extern tree create_param_decl (tree param_name, tree param_type,\n                                bool readonly);\n \n@@ -692,7 +675,7 @@ extern tree build_template (tree template_type, tree array_type, tree expr);\n extern tree build_vms_descriptor (tree type, Mechanism_Type mech,\n                                   Entity_Id gnat_entity);\n \n-/* Build a 32bit VMS descriptor from a Mechanism_Type. See above. */\n+/* Build a 32bit VMS descriptor from a Mechanism_Type. See above.  */\n extern tree build_vms_descriptor32 (tree type, Mechanism_Type mech,\n                                   Entity_Id gnat_entity);\n \n@@ -710,7 +693,7 @@ extern tree build_unc_object_type (tree template_type, tree object_type,\n                                    tree name);\n \n /* Same as build_unc_object_type, but taking a thin or fat pointer type\n-   instead of the template type. */\n+   instead of the template type.  */\n extern tree build_unc_object_type_from_ptr (tree thin_fat_ptr_type,\n \t\t\t\t\t    tree object_type, tree name);\n \n@@ -743,13 +726,13 @@ extern tree maybe_unconstrained_array (tree exp);\n    If NOTRUNC_P is true, truncation operations should be suppressed.  */\n extern tree unchecked_convert (tree type, tree expr, bool notrunc_p);\n \n-/* Return the appropriate GCC tree code for the specified GNAT type,\n+/* Return the appropriate GCC tree code for the specified GNAT_TYPE,\n    the latter being a record type as predicated by Is_Record_Type.  */\n-extern enum tree_code tree_code_for_record_type (Entity_Id);\n+extern enum tree_code tree_code_for_record_type (Entity_Id gnat_type);\n \n /* Return true if GNU_TYPE is suitable as the type of a non-aliased\n    component of an aggregate type.  */\n-extern bool type_for_nonaliased_component_p (tree);\n+extern bool type_for_nonaliased_component_p (tree gnu_type);\n \n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n    operation.\n@@ -775,7 +758,7 @@ extern tree get_base_type (tree type);\n extern unsigned int known_alignment (tree exp);\n \n /* Return true if VALUE is a multiple of FACTOR. FACTOR must be a power\n-   of 2. */\n+   of 2.  */\n extern bool value_factor_p (tree value, HOST_WIDE_INT factor);\n \n /* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n@@ -785,7 +768,7 @@ extern bool value_factor_p (tree value, HOST_WIDE_INT factor);\n extern tree build_binary_op (enum tree_code op_code, tree result_type,\n                              tree left_operand, tree right_operand);\n \n-/* Similar, but make unary operation.   */\n+/* Similar, but make unary operation.  */\n extern tree build_unary_op (enum tree_code op_code, tree result_type,\n                             tree operand);\n \n@@ -870,6 +853,14 @@ extern tree gnat_builtin_function (tree decl);\n    Return the first node found, if any, or NULL_TREE otherwise.  */\n extern tree builtin_decl_for (tree name);\n \n+/* GNU_TYPE is a type. Determine if it should be passed by reference by\n+   default.  */\n+extern bool default_pass_by_ref (tree gnu_type);\n+\n+/* GNU_TYPE is the type of a subprogram parameter.  Determine from the type\n+   if it should be passed by reference.  */\n+extern bool must_pass_by_ref (tree gnu_type);\n+\n /* This function is called by the front end to enumerate all the supported\n    modes for the machine.  We pass a function which is called back with\n    the following integer parameters:\n@@ -884,9 +875,10 @@ extern tree builtin_decl_for (tree name);\n extern void enumerate_modes (void (*f) (int, int, int, int, int, int,\n \t\t\t\t\tunsigned int));\n \n-/* These are temporary function to deal with recent GCC changes related to\n-   FP type sizes and precisions.  */\n+/* Return the size of the FP mode with precision PREC.  */\n extern int fp_prec_to_size (int prec);\n+\n+/* Return the precision of the FP mode with size SIZE.  */\n extern int fp_size_to_prec (int size);\n \n /* These functions return the basic data type sizes and related parameters\n@@ -922,7 +914,7 @@ extern Nat get_strict_alignment (void);\n \n /* VMS macro set by default, when clear forces 32bit mallocs and 32bit\n    Descriptors. Always used in combination with TARGET_ABI_OPEN_VMS\n-   so no effect on non-VMS systems. */\n+   so no effect on non-VMS systems.  */\n #ifndef TARGET_MALLOC64\n #define TARGET_MALLOC64 0\n #endif"}, {"sha": "c35a9c37848d00f3fd4b24175ac6203caf38b45f", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 28, "deletions": 61, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=feec4372c1d33b1d7de0442d9d6308c2b96255ca", "patch": "@@ -72,14 +72,7 @@\n #include \"opts.h\"\n #include \"options.h\"\n \n-extern FILE *asm_out_file;\n-\n-/* The largest alignment, in bits, that is needed for using the widest\n-   move instruction.  */\n-unsigned int largest_move_alignment;\n-\n static bool gnat_init\t\t\t(void);\n-static void gnat_finish_incomplete_decl\t(tree);\n static unsigned int gnat_init_options\t(unsigned int, const char **);\n static int gnat_handle_option\t\t(size_t, const char *, int);\n static bool gnat_post_options\t\t(const char **);\n@@ -118,8 +111,6 @@ static tree gnat_type_max_size\t\t(const_tree);\n #define LANG_HOOKS_PUSHDECL\t\tgnat_return_tree\n #undef  LANG_HOOKS_WRITE_GLOBALS\n #define LANG_HOOKS_WRITE_GLOBALS\tgnat_write_global_declarations\n-#undef  LANG_HOOKS_FINISH_INCOMPLETE_DECL\n-#define LANG_HOOKS_FINISH_INCOMPLETE_DECL gnat_finish_incomplete_decl\n #undef  LANG_HOOKS_GET_ALIAS_SET\n #define LANG_HOOKS_GET_ALIAS_SET\tgnat_get_alias_set\n #undef  LANG_HOOKS_MARK_ADDRESSABLE\n@@ -153,18 +144,14 @@ const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n    are incompatible with regular GDB versions, so we must make sure to only\n    produce them on explicit request.  This is eventually reflected into the\n    use_gnu_debug_info_extensions common flag for later processing.  */\n-\n static int gnat_dwarf_extensions = 0;\n \n-/* Command-line argc and argv.\n-   These variables are global, since they are imported and used in\n-   back_end.adb  */\n-\n+/* Command-line argc and argv.  These variables are global\n+   since they are imported in back_end.adb.  */\n unsigned int save_argc;\n const char **save_argv;\n \n-/* gnat standard argc argv */\n-\n+/* GNAT argc and argv.  */\n extern int gnat_argc;\n extern char **gnat_argv;\n \n@@ -202,8 +189,8 @@ gnat_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \n /* Decode all the language specific options that cannot be decoded by GCC.\n    The option decoding phase of GCC calls this routine on the flags that\n-   it cannot decode.  This routine returns the number of consecutive arguments\n-   from ARGV that it successfully decoded; 0 indicates failure.  */\n+   it cannot decode.  Return the number of consecutive arguments from ARGV\n+   that have been successfully decoded or 0 on failure.  */\n \n static int\n gnat_handle_option (size_t scode, const char *arg, int value)\n@@ -427,34 +414,6 @@ gnat_init (void)\n   return true;\n }\n \n-/* This function is called indirectly from toplev.c to handle incomplete\n-   declarations, i.e. VAR_DECL nodes whose DECL_SIZE is zero.  To be precise,\n-   compile_file in toplev.c makes an indirect call through the function pointer\n-   incomplete_decl_finalize_hook which is initialized to this routine in\n-   init_decl_processing.  */\n-\n-static void\n-gnat_finish_incomplete_decl (tree dont_care ATTRIBUTE_UNUSED)\n-{\n-  gcc_unreachable ();\n-}\n-\f\n-/* Compute the alignment of the largest mode that can be used for copying\n-   objects.  */\n-\n-void\n-gnat_compute_largest_alignment (void)\n-{\n-  enum machine_mode mode;\n-\n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n-    if (optab_handler (mov_optab, mode)->insn_code != CODE_FOR_nothing)\n-      largest_move_alignment = MIN (BIGGEST_ALIGNMENT,\n-\t\t\t\t    MAX (largest_move_alignment,\n-\t\t\t\t\t GET_MODE_ALIGNMENT (mode)));\n-}\n-\n /* If we are using the GCC mechanism to process exception handling, we\n    have to register the personality routine for Ada and to initialize\n    various language dependent hooks.  */\n@@ -506,7 +465,7 @@ gnat_init_gcc_eh (void)\n #endif\n }\n \n-/* Language hooks, first one to print language-specific items in a DECL.  */\n+/* Print language-specific items in declaration NODE.  */\n \n static void\n gnat_print_decl (FILE *file, tree node, int indent)\n@@ -533,6 +492,8 @@ gnat_print_decl (FILE *file, tree node, int indent)\n     }\n }\n \n+/* Print language-specific items in type NODE.  */\n+\n static void\n gnat_print_type (FILE *file, tree node, int indent)\n {\n@@ -542,11 +503,6 @@ gnat_print_type (FILE *file, tree node, int indent)\n       print_node (file, \"ci_co_list\", TYPE_CI_CO_LIST (node), indent + 4);\n       break;\n \n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-      print_node (file, \"RM size\", TYPE_RM_SIZE (node), indent + 4);\n-      break;\n-\n     case INTEGER_TYPE:\n       if (TYPE_MODULAR_P (node))\n \tprint_node (file, \"modulus\", TYPE_MODULUS (node), indent + 4);\n@@ -558,6 +514,10 @@ gnat_print_type (FILE *file, tree node, int indent)\n       else\n \tprint_node (file, \"index type\", TYPE_INDEX_TYPE (node), indent + 4);\n \n+      /* ... fall through ... */\n+\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n       print_node (file, \"RM size\", TYPE_RM_SIZE (node), indent + 4);\n       break;\n \n@@ -583,13 +543,7 @@ gnat_print_type (FILE *file, tree node, int indent)\n     }\n }\n \n-static const char *\n-gnat_dwarf_name (tree t, int verbosity ATTRIBUTE_UNUSED)\n-{\n-  gcc_assert (DECL_P (t));\n-\n-  return (const char *) IDENTIFIER_POINTER (DECL_NAME (t));\n-}\n+/* Return the name to be printed for DECL.  */\n \n static const char *\n gnat_printable_name (tree decl, int verbosity)\n@@ -604,8 +558,17 @@ gnat_printable_name (tree decl, int verbosity)\n       Set_Identifier_Casing (ada_name, (char *) DECL_SOURCE_FILE (decl));\n       return ggc_strdup (Name_Buffer);\n     }\n-  else\n-    return ada_name;\n+\n+  return ada_name;\n+}\n+\n+/* Return the name to be used in DWARF debug info for DECL.  */\n+\n+static const char *\n+gnat_dwarf_name (tree decl, int verbosity ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (DECL_P (decl));\n+  return (const char *) IDENTIFIER_POINTER (DECL_NAME (decl));\n }\n \n /* Do nothing (return the tree node passed).  */\n@@ -810,6 +773,8 @@ enumerate_modes (void (*f) (int, int, int, int, int, int, unsigned int))\n     }\n }\n \n+/* Return the size of the FP mode with precision PREC.  */\n+\n int\n fp_prec_to_size (int prec)\n {\n@@ -823,6 +788,8 @@ fp_prec_to_size (int prec)\n   gcc_unreachable ();\n }\n \n+/* Return the precision of the FP mode with size SIZE.  */\n+\n int\n fp_size_to_prec (int size)\n {"}, {"sha": "807b370e077b3aabe92a22164858c27a371134e4", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=feec4372c1d33b1d7de0442d9d6308c2b96255ca", "patch": "@@ -301,7 +301,6 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n   /* Initialize ourselves.  */\n   init_code_table ();\n   init_gnat_to_gnu ();\n-  gnat_compute_largest_alignment ();\n   init_dummy_type ();\n \n   /* If we are just annotating types, give VOID_TYPE zero sizes to avoid\n@@ -1058,7 +1057,7 @@ Pragma_to_gnu (Node_Id gnat_node)\n   return gnu_result;\n }\n \f\n-/* Subroutine of gnat_to_gnu to translate gnat_node, an N_Attribute,\n+/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Attribute node,\n    to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer to\n    where we should place the result type.  ATTRIBUTE is the attribute ID.  */\n \n@@ -1075,20 +1074,19 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n   /* If the input is a NULL_EXPR, make a new one.  */\n   if (TREE_CODE (gnu_prefix) == NULL_EXPR)\n     {\n-      *gnu_result_type_p = get_unpadded_type (Etype (gnat_node));\n-      return build1 (NULL_EXPR, *gnu_result_type_p,\n-\t\t     TREE_OPERAND (gnu_prefix, 0));\n+      gnu_result_type = get_unpadded_type (Etype (gnat_node));\n+      *gnu_result_type_p = gnu_result_type;\n+      return build1 (NULL_EXPR, gnu_result_type, TREE_OPERAND (gnu_prefix, 0));\n     }\n \n   switch (attribute)\n     {\n     case Attr_Pos:\n     case Attr_Val:\n-      /* These are just conversions until since representation clauses for\n-\t enumerations are handled in the front end.  */\n+      /* These are just conversions since representation clauses for\n+\t enumeration types are handled in the front-end.  */\n       {\n \tbool checkp = Do_Range_Check (First (Expressions (gnat_node)));\n-\n \tgnu_result = gnat_to_gnu (First (Expressions (gnat_node)));\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \tgnu_result = convert_with_check (Etype (gnat_node), gnu_result,\n@@ -1098,8 +1096,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n     case Attr_Pred:\n     case Attr_Succ:\n-      /* These just add or subject the constant 1.  Representation clauses for\n-\t enumerations are handled in the front-end.  */\n+      /* These just add or subtract the constant 1 since representation\n+\t clauses for enumeration types are handled in the front-end.  */\n       gnu_expr = gnat_to_gnu (First (Expressions (gnat_node)));\n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n@@ -1117,16 +1115,15 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t}\n \n       gnu_result\n-\t= build_binary_op (attribute == Attr_Pred\n-\t\t\t   ? MINUS_EXPR : PLUS_EXPR,\n+\t= build_binary_op (attribute == Attr_Pred ? MINUS_EXPR : PLUS_EXPR,\n \t\t\t   gnu_result_type, gnu_expr,\n \t\t\t   convert (gnu_result_type, integer_one_node));\n       break;\n \n     case Attr_Address:\n     case Attr_Unrestricted_Access:\n-      /* Conversions don't change something's address but can cause us to miss\n-\t the COMPONENT_REF case below, so strip them off.  */\n+      /* Conversions don't change addresses but can cause us to miss the\n+\t COMPONENT_REF case below, so strip them off.  */\n       gnu_prefix = remove_conversions (gnu_prefix,\n \t\t\t\t       !Must_Be_Byte_Aligned (gnat_node));\n \n@@ -1237,9 +1234,9 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n-\t/* If this is an unconstrained array, we know the object must have been\n-\t   allocated with the template in front of the object.  So compute the\n-\t   template address.*/\n+\t/* If this is an unconstrained array, we know the object has been\n+\t   allocated with the template in front of the object.  So compute\n+\t   the template address.  */\n \tif (TYPE_FAT_POINTER_P (TREE_TYPE (gnu_ptr)))\n \t  gnu_ptr\n \t    = convert (build_pointer_type\n@@ -1273,7 +1270,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n     case Attr_Max_Size_In_Storage_Elements:\n       gnu_expr = gnu_prefix;\n \n-      /* Remove NOPS from gnu_expr and conversions from gnu_prefix.\n+      /* Remove NOPs from GNU_EXPR and conversions from GNU_PREFIX.\n \t We only use GNU_EXPR to see if a COMPONENT_REF was involved.  */\n       while (TREE_CODE (gnu_expr) == NOP_EXPR)\n \tgnu_expr = TREE_OPERAND (gnu_expr, 0);\n@@ -1351,8 +1348,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n       gcc_assert (gnu_result);\n \n-      /* Deal with a self-referential size by returning the maximum size for a\n-\t type and by qualifying the size with the object for 'Size of an\n+      /* Deal with a self-referential size by returning the maximum size for\n+\t a type and by qualifying the size with the object for 'Size of an\n \t object.  */\n       if (CONTAINS_PLACEHOLDER_P (gnu_result))\n \t{\n@@ -1521,7 +1518,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\t   much rarer cases, for extremely large arrays we expect\n \t\t   never to encounter in practice.  In addition, the former\n \t\t   computation required the use of potentially constraining\n-\t\t   signed arithmetic while the latter doesn't. Note that the\n+\t\t   signed arithmetic while the latter doesn't.  Note that the\n \t\t   comparison must be done in the original index base type,\n \t\t   otherwise the conversion of either bound to gnu_compute_type\n \t\t   may overflow.  */\n@@ -1663,8 +1660,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t    break;\n \t\t}\n \n-\t/* If this has a PLACEHOLDER_EXPR, qualify it by the object\n-\t   we are handling.  */\n+\t/* If this has a PLACEHOLDER_EXPR, qualify it by the object we are\n+\t   handling.  */\n \tgnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result, gnu_prefix);\n \tbreak;\n       }\n@@ -1714,8 +1711,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       break;\n \n     case Attr_Null_Parameter:\n-      /* This is just a zero cast to the pointer type for\n-\t our prefix and dereferenced.  */\n+      /* This is just a zero cast to the pointer type for our prefix and\n+\t dereferenced.  */\n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n       gnu_result\n \t= build_unary_op (INDIRECT_REF, NULL_TREE,\n@@ -1755,8 +1752,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n     default:\n       /* Say we have an unimplemented attribute.  Then set the value to be\n-\t returned to be a zero and hope that's something we can convert to the\n-\t type of this attribute.  */\n+\t returned to be a zero and hope that's something we can convert to\n+\t the type of this attribute.  */\n       post_error (\"unimplemented attribute\", gnat_node);\n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n       gnu_result = integer_zero_node;"}, {"sha": "b2c4399a410d9aa8b665cfbe1ea417e0ef9edffd", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feec4372c1d33b1d7de0442d9d6308c2b96255ca/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=feec4372c1d33b1d7de0442d9d6308c2b96255ca", "patch": "@@ -1472,10 +1472,13 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n       DECL_BIT_FIELD (field_decl) = 1;\n       DECL_SIZE (field_decl) = size;\n       if (!packed && !pos)\n-\tDECL_ALIGN (field_decl)\n-\t  = (TYPE_ALIGN (record_type) != 0\n-\t     ? MIN (TYPE_ALIGN (record_type), TYPE_ALIGN (field_type))\n-\t     : TYPE_ALIGN (field_type));\n+\t{\n+\t  if (TYPE_ALIGN (record_type) != 0\n+\t      && TYPE_ALIGN (record_type) < TYPE_ALIGN (field_type))\n+\t    DECL_ALIGN (field_decl) = TYPE_ALIGN (record_type);\n+\t  else\n+\t    DECL_ALIGN (field_decl) = TYPE_ALIGN (field_type);\n+\t}\n     }\n \n   DECL_PACKED (field_decl) = pos ? DECL_BIT_FIELD (field_decl) : packed;\n@@ -1636,7 +1639,7 @@ process_attributes (tree decl, struct attrib *attr_list)\n       }\n }\n \f\n-/* Record a global renaming pointer.  */\n+/* Record DECL as a global renaming pointer.  */\n \n void\n record_global_renaming_pointer (tree decl)\n@@ -4520,7 +4523,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n   return expr;\n }\n \f\n-/* Return the appropriate GCC tree code for the specified GNAT type,\n+/* Return the appropriate GCC tree code for the specified GNAT_TYPE,\n    the latter being a record type as predicated by Is_Record_Type.  */\n \n enum tree_code"}]}