{"sha": "c9220e3a83aecc4d5fa5ecfad4d203f086e0c061", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkyMjBlM2E4M2FlY2M0ZDVmYTVlY2ZhZDRkMjAzZjA4NmUwYzA2MQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-05-27T05:51:14Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-05-27T05:51:14Z"}, "message": "c-common.c (c_common_init): Set CPP arithmetic precision.\n\n\t* c-common.c (c_common_init): Set CPP arithmetic precision.\n\t* cppexp.c (cpp_num_part): Move typedef ...\n\t* cpphash.h: ...here; make unsigned HOST_WIDE_INT.\n\t* cppinit.c (cpp_create_reader): Default to host long arithmetic.\n\t(sanity_checks): Update.\ntestsuite:\n\t* gcc.dg/cpp/arith-2.c, gcc.dg/cpp/arith-3.c: New tests.\n\t* gcc.dg/cpp/if-3.c: Remove.\n\nFrom-SVN: r53911", "tree": {"sha": "2f52ca5c8e31847edc88df70f877c0e92544df2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f52ca5c8e31847edc88df70f877c0e92544df2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/comments", "author": null, "committer": null, "parents": [{"sha": "1457a0b52ae505202bd1f341e74e039e0f4a4602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1457a0b52ae505202bd1f341e74e039e0f4a4602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1457a0b52ae505202bd1f341e74e039e0f4a4602"}], "stats": {"total": 931, "additions": 923, "deletions": 8}, "files": [{"sha": "210eb525d9b2c66d2b63b569a102867a8e9bff27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9220e3a83aecc4d5fa5ecfad4d203f086e0c061", "patch": "@@ -1,3 +1,11 @@\n+2002-05-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* c-common.c (c_common_init): Set CPP arithmetic precision.\n+\t* cppexp.c (cpp_num_part): Move typedef ...\n+\t* cpphash.h: ...here; make unsigned HOST_WIDE_INT.\n+\t* cppinit.c (cpp_create_reader): Default to host long arithmetic.\n+\t(sanity_checks): Update.\n+\n 2002-05-26  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* Makefile.in (INSTALL_HEADERS): Add 'install-mkheaders'."}, {"sha": "421f7f267eddf2dea3b1609366efc2adbe9a2863", "filename": "gcc/c-common.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=c9220e3a83aecc4d5fa5ecfad4d203f086e0c061", "patch": "@@ -4488,6 +4488,10 @@ c_common_init (filename)\n \n   /* Set up preprocessor arithmetic.  Must be done after call to\n      c_common_nodes_and_builtins for wchar_type_node to be good.  */\n+  if (flag_isoc99)\n+    options->precision = TYPE_PRECISION (intmax_type_node);\n+  else\n+    options->precision = TYPE_PRECISION (long_integer_type_node);\n   options->char_precision = TYPE_PRECISION (char_type_node);\n   options->int_precision = TYPE_PRECISION (integer_type_node);\n   options->wchar_precision = TYPE_PRECISION (wchar_type_node);"}, {"sha": "b2bad21a248f5b455805c710756ca603620116c9", "filename": "gcc/cppexp.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=c9220e3a83aecc4d5fa5ecfad4d203f086e0c061", "patch": "@@ -23,7 +23,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-typedef unsigned long cpp_num_part;\n typedef struct cpp_num cpp_num;\n \n #define PART_PRECISION (sizeof (cpp_num_part) * CHAR_BIT)"}, {"sha": "af85cc1f447d9f8ec0cade9605d759f48c8220fa", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=c9220e3a83aecc4d5fa5ecfad4d203f086e0c061", "patch": "@@ -29,6 +29,7 @@ struct directive;\t\t/* Deliberately incomplete.  */\n struct pending_option;\n struct op;\n \n+typedef unsigned HOST_WIDE_INT cpp_num_part;\n typedef unsigned char uchar;\n #define U (const uchar *)  /* Intended use: U\"string\" */\n "}, {"sha": "86566e5f4a29f6fe2fbb88c491c2e33c7fb8188d", "filename": "gcc/cppinit.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=c9220e3a83aecc4d5fa5ecfad4d203f086e0c061", "patch": "@@ -496,8 +496,7 @@ cpp_create_reader (lang)\n \n   /* Default CPP arithmetic to something sensible for the host for the\n      benefit of dumb users like fix-header.  */\n-#define BITS_PER_HOST_WIDEST_INT (CHAR_BIT * sizeof (HOST_WIDEST_INT))\n-  CPP_OPTION (pfile, precision) = BITS_PER_HOST_WIDEST_INT;\n+  CPP_OPTION (pfile, precision) = CHAR_BIT * sizeof (long);\n   CPP_OPTION (pfile, char_precision) = CHAR_BIT;\n   CPP_OPTION (pfile, wchar_precision) = CHAR_BIT * sizeof (int);\n   CPP_OPTION (pfile, int_precision) = CHAR_BIT * sizeof (int);\n@@ -848,18 +847,19 @@ static void sanity_checks (pfile)\n      cpp_reader *pfile;\n {\n   cppchar_t test = 0;\n+  size_t max_precision = 2 * CHAR_BIT * sizeof (cpp_num_part);\n \n   /* Sanity checks for assumptions about CPP arithmetic and target\n      type precisions made by cpplib.  */\n   test--;\n   if (test < 1)\n     cpp_error (pfile, DL_ICE, \"cppchar_t must be an unsigned type\");\n \n-  if (CPP_OPTION (pfile, precision) > BITS_PER_HOST_WIDEST_INT)\n+  if (CPP_OPTION (pfile, precision) > max_precision)\n     cpp_error (pfile, DL_ICE,\n \t       \"preprocessor arithmetic has maximum precision of %lu bits; target requires %lu bits\",\n-\t       (unsigned long)BITS_PER_HOST_WIDEST_INT,\n-\t       (unsigned long)CPP_OPTION (pfile, precision));\n+\t       (unsigned long) max_precision,\n+\t       (unsigned long) CPP_OPTION (pfile, precision));\n \n   if (CPP_OPTION (pfile, precision) < CPP_OPTION (pfile, int_precision))\n     cpp_error (pfile, DL_ICE,\n@@ -876,11 +876,15 @@ static void sanity_checks (pfile)\n     cpp_error (pfile, DL_ICE,\n \t       \"target int is narrower than target char\");\n \n+  /* This is assumed in eval_token() and could be fixed if necessary.  */\n+  if (sizeof (cppchar_t) > sizeof (cpp_num_part))\n+    cpp_error (pfile, DL_ICE, \"CPP half-integer narrower than CPP character\");\n+\n   if (CPP_OPTION (pfile, wchar_precision) > BITS_PER_CPPCHAR_T)\n     cpp_error (pfile, DL_ICE,\n \t       \"CPP on this host cannot handle wide character constants over %lu bits, but the target requires %lu bits\",\n-\t       (unsigned long)BITS_PER_CPPCHAR_T,\n-\t       (unsigned long)CPP_OPTION (pfile, wchar_precision));\n+\t       (unsigned long) BITS_PER_CPPCHAR_T,\n+\t       (unsigned long) CPP_OPTION (pfile, wchar_precision));\n }\n #else\n # define sanity_checks(PFILE)"}, {"sha": "942ba17f0343e313bab357cebf5c06c9b7e7eb7a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c9220e3a83aecc4d5fa5ecfad4d203f086e0c061", "patch": "@@ -1,3 +1,8 @@\n+2002-05-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/arith-2.c, gcc.dg/cpp/arith-3.c: New tests.\n+\t* gcc.dg/cpp/if-3.c: Remove.\n+\n 2002-05-26  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/opt/cse2.C: New test."}, {"sha": "315585e459b2669d563ca29c00e5fa7b3ac6e436", "filename": "gcc/testsuite/gcc.dg/cpp/arith-2.c", "status": "added", "additions": 447, "deletions": 0, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-2.c?ref=c9220e3a83aecc4d5fa5ecfad4d203f086e0c061", "patch": "@@ -0,0 +1,447 @@\n+/* Preprocessor arithmetic semantic tests.  */\n+\n+/* Copyright (C) 2002 Free Software Foundation, Inc.  */\n+/* Source: Neil Booth, 26 May 2002.  */\n+\n+/* The file tests overflow warnings for, and values of, preprocessor\n+   arithmetic that are dependent on target precision.  \n+\n+   Please keep changes to arith-2.c and arith-3.c in sync.  */\n+\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=c89 -fno-show-column\" } */\n+\n+#include <limits.h>\n+\n+#define APPEND2(NUM, SUFF) NUM ## SUFF\n+#define APPEND(NUM, SUFF) APPEND2(NUM, SUFF)\n+\n+#define TARGET_UTYPE_MAX ULONG_MAX\n+\n+/* The tests in this file depend only on the macros defined in this\n+   #if block.  Note that it is no good calculating these values, as\n+   the intent is to test both the preprocessor's number parser and\n+   arithmetic.  */\n+#if TARGET_UTYPE_MAX == 65535UL\n+\n+#  define TARG_PRECISION 16\n+#  define MAX_INT  32767\n+#  define MAX_UINT 65535\n+\n+#  define TARG_MAX_HEX 0x7fff\n+#  define TARG_MAX_OCT 077777\n+#  define TARG_MAX_PLUS_1 32768L\n+#  define TARG_MAX_PLUS_1_U 32768UL\n+#  define TARG_MAX_PLUS_1_HEX 0x8000\n+#  define TARG_MAX_PLUS_1_OCT 0100000\n+#  define UTARG_MAX_HEX 0xffff\n+#  define UTARG_MAX_OCT 0177777\n+#  define UTARG_MAX_PLUS_1 65536L\n+#  define UTARG_MAX_PLUS_1_HEX 0x10000\n+#  define UTARG_MAX_PLUS_1_OCT 0200000\n+\n+#  define TARG_LOWPART_PLUS_1 256L\n+#  define TARG_LOWPART_PLUS_1_U 256UL\n+\n+  /* Division and modulo; anything that uses the high half in both\n+     dividend and divisor.  */\n+#  define LONG_UDIVISION 61234UL / 260L\n+#  define LONG_UDIVISION_ANSWER 235\n+#  define LONG_SDIVISION -15000L / 299L\n+#  define LONG_SDIVISION_ANSWER -50\n+#  define LONG_UMODULO 61234UL % 260L\n+#  define LONG_UMODULO_ANSWER 134\n+#  define LONG_SMODULO -15000L % 299L\n+#  define LONG_SMODULO_ANSWER -50\n+\n+#elif TARGET_UTYPE_MAX == 4294967295UL\n+\n+#  define TARG_PRECISION 32\n+#  define MAX_INT  2147483647\n+#  define MAX_UINT 4294967295\n+\n+#  define TARG_MAX_HEX 0x7fffffff\n+#  define TARG_MAX_OCT 017777777777\n+#  define TARG_MAX_PLUS_1 2147483648L\n+#  define TARG_MAX_PLUS_1_U 2147483648UL\n+#  define TARG_MAX_PLUS_1_HEX 0x80000000\n+#  define TARG_MAX_PLUS_1_OCT 020000000000\n+#  define UTARG_MAX_HEX 0xffffffff\n+#  define UTARG_MAX_OCT 037777777777\n+#  define UTARG_MAX_PLUS_1 4294967296L\n+#  define UTARG_MAX_PLUS_1_HEX 0x100000000\n+#  define UTARG_MAX_PLUS_1_OCT 040000000000\n+\n+#  define TARG_LOWPART_PLUS_1 65536\n+#  define TARG_LOWPART_PLUS_1_U 65536UL\n+\n+  /* Division and modulo; anything that uses the high half in both\n+     dividend and divisor.  */\n+#  define LONG_UDIVISION 268335456UL / 70000L\n+#  define LONG_UDIVISION_ANSWER 3833\n+#  define LONG_SDIVISION -368335456L / 123456L\n+#  define LONG_SDIVISION_ANSWER -2983\n+#  define LONG_UMODULO 268335456UL % 70000L\n+#  define LONG_UMODULO_ANSWER 25456\n+#  define LONG_SMODULO -368335456L % 123456L\n+#  define LONG_SMODULO_ANSWER -66208\n+\n+#elif TARGET_UTYPE_MAX == 18446744073709551615UL\n+\n+#  define TARG_PRECISION 64\n+#  define MAX_INT  9223372036854775807\n+#  define MAX_UINT 18446744073709551615\n+\n+#  define TARG_MAX_HEX 0x7fffffffffffffff\n+#  define TARG_MAX_OCT 0777777777777777777777\n+#  define TARG_MAX_PLUS_1 9223372036854775808L\n+#  define TARG_MAX_PLUS_1_U 9223372036854775808UL\n+#  define TARG_MAX_PLUS_1_HEX 0x8000000000000000\n+#  define TARG_MAX_PLUS_1_OCT 01000000000000000000000\n+#  define UTARG_MAX_HEX 0xffffffffffffffff\n+#  define UTARG_MAX_OCT 01777777777777777777777\n+#  define UTARG_MAX_PLUS_1 18446744073709551616L\n+#  define UTARG_MAX_PLUS_1_HEX 0x10000000000000000\n+#  define UTARG_MAX_PLUS_1_OCT 02000000000000000000000\n+\n+#  define TARG_LOWPART_PLUS_1 4294967296\n+#  define TARG_LOWPART_PLUS_1_U 4294967296U\n+\n+  /* Division and modulo; anything that uses the high half in both\n+     dividend and divisor.  */\n+#  define LONG_UDIVISION 235184372088832UL / 17279869184L\n+#  define LONG_UDIVISION_ANSWER 13610\n+#  define LONG_SDIVISION -234582345927345L / 12345678901L\n+#  define LONG_SDIVISION_ANSWER -19001\n+#  define LONG_UMODULO 235184372088832UL % 17279869184L\n+#  define LONG_UMODULO_ANSWER 5352494592L\n+#  define LONG_SMODULO -234582345927345L % 12345678901L\n+#  define LONG_SMODULO_ANSWER -2101129444L\n+\n+#else\n+\n+#  error Please extend the macros here so that this file tests your target\n+\n+#endif\n+\n+/* Create more macros based on the above.  */\n+#define TARG_PART_BITS (TARG_PRECISION / 2)\n+#define TARG_MIN (-TARG_MAX - 1)\n+#define TARG_MAX APPEND (MAX_INT, L)\n+#define TARG_MAX_U APPEND (MAX_INT, UL)\n+#define UTARG_MAX APPEND (MAX_UINT, L)\n+#define UTARG_MAX_U APPEND (MAX_UINT, UL)\n+\n+/* And now the tests.  */\n+\n+#if TARG_MAX\t\t\t/* { dg-bogus \"so large\" }  */\n+#endif\n+#if TARG_MAX_PLUS_1_HEX\t\t/* { dg-bogus \"so large\" }  */\n+#endif\n+#if TARG_MAX_PLUS_1_OCT\t\t/* { dg-bogus \"so large\" }  */\n+#endif\n+\n+#if UTARG_MAX\t\t\t/* { dg-warning \"so large\" }  */\n+#endif\n+#if UTARG_MAX_PLUS_1\t\t/* { dg-error \"too large\" }  */\n+#endif\n+#if UTARG_MAX_PLUS_1_HEX\t/* { dg-error \"too large\" }  */\n+#endif\n+#if UTARG_MAX_HEX\t\t/* { dg-bogus \"too large\" }  */\n+#endif\n+#if UTARG_MAX_PLUS_1_OCT\t/* { dg-error \"too large\" }  */\n+#endif\n+#if UTARG_MAX_OCT\t\t/* { dg-bogus \"too large\" }  */\n+#endif\n+\n+#if TARG_MAX < 0 || TARG_MAX_PLUS_1 < 0\t/* { dg-warning \"so large\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if UTARG_MAX_HEX < 0 || TARG_MAX_HEX < 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if UTARG_MAX_OCT < 0 || TARG_MAX_OCT < 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -1 != UTARG_MAX_U\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Test each operator correctly warns of overflow conditions, and\n+   gives the right answer.  */\n+\n+/* Binary +.  */\n+#if TARG_MAX + 1 != TARG_MIN\t/* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX + -2 != TARG_MAX\t/* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX + -1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX_U + 1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX_U + -2 != TARG_MAX /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Binary -.  */\n+#if TARG_MAX - -1 != TARG_MIN\t/* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX - 2 != TARG_MAX\t/* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX - 1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX_U - -1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX_U - 2 != TARG_MAX /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+\n+/* Binary *.  */\n+#if TARG_LOWPART_PLUS_1 * (TARG_LOWPART_PLUS_1 >> 1) != TARG_MIN /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_LOWPART_PLUS_1 >> 1) * TARG_LOWPART_PLUS_1 != TARG_MIN /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_LOWPART_PLUS_1 << 1) * (TARG_LOWPART_PLUS_1 + 1) != (TARG_LOWPART_PLUS_1 << 1) /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX * 1 != TARG_MAX\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_MAX >> 1) * 2\t!= TARG_MAX - 1 /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_LOWPART_PLUS_1_U + 61) * (TARG_LOWPART_PLUS_1 << 1) != 61 * (TARG_LOWPART_PLUS_1 << 1) /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_LOWPART_PLUS_1 >> 1) * TARG_LOWPART_PLUS_1_U != TARG_MIN /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 1 * TARG_MIN != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Binary /.  */\n+#if TARG_MIN / -1 != TARG_MIN\t/* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MIN / 1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX_PLUS_1_U / -1 != 0 /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -5 / (2 - 2) /* { dg-error \"division by zero\" } */\n+#endif\n+\n+#if LONG_UDIVISION != LONG_UDIVISION_ANSWER\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if LONG_SDIVISION != LONG_SDIVISION_ANSWER\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Binary %.  Cannot overflow.  */\n+#if -5 % (2 - 2) /* { dg-error \"division by zero\" } */\n+#endif\n+\n+#if TARG_MIN % 1 /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if LONG_UMODULO != LONG_UMODULO_ANSWER\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if LONG_SMODULO != LONG_SMODULO_ANSWER\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 234 % -1U != 234\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MIN % -1U != TARG_MIN\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Binary << and Binary >>, the latter cannot overflow.  */\n+#if -1 >> 3 != -1     /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX >> 3 != TARG_MAX / 8     /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 0 << 256 != 0  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 1 << 256 != 0 /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 1U << 256 != 0  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX << 1 != -2  /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX_U << 1 != -2  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_LOWPART_PLUS_1 << TARG_PART_BITS != 0  /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_LOWPART_PLUS_1 << (TARG_PART_BITS - 1) != TARG_MIN  /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_LOWPART_PLUS_1_U << (TARG_PART_BITS - 1) != TARG_MIN  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_LOWPART_PLUS_1 << (TARG_PART_BITS - 2) != (TARG_MAX_PLUS_1_U >> 1)  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Test how the sign bit is handled.  */\n+#if (TARG_MIN << 1) != 0    /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_MAX_PLUS_1_U << 1) != 0    /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_MIN >> 1) != 3U << (TARG_PRECISION - 2)    /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_MAX_PLUS_1_U >> 1) != 1 << (TARG_PRECISION - 2)    /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+/* Unary -.  It can overflow in just one case.  */\n+#if -TARG_MIN != TARG_MIN  /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if - -TARG_MAX != TARG_MAX   /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Unary +, ~, and !.  They cannot overflow.  */\n+#if +TARG_MAX != TARG_MAX  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if !TARG_MAX + !TARG_MIN != 0   /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if ~TARG_MAX , ~TARG_MIN != TARG_MAX  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Bitwise &, ^, |.  They cannot overflow.  */\n+#if (TARG_MAX & -1), (TARG_MIN & -1) != TARG_MIN  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX | -1, (TARG_MIN | -1) != -1  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX ^ -1, (TARG_MIN ^ -1) != TARG_MAX  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Comparison operators.  They cannot overflow.  */\n+#if -1 <= TARG_MAX, (TARG_MIN <= 1) != 1  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -1 >= TARG_MAX, (TARG_MIN >= 1) != 0  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -1 < TARG_MAX, (TARG_MIN < 1) != 1  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -1 > TARG_MAX, (TARG_MIN > 1) != 0  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Comma and ? : operators.  They cannot overflow.  */\n+#if -1, TARG_MAX, TARG_MIN != TARG_MIN  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -1 ? TARG_MAX: TARG_MAX, 0 ? 1: TARG_MIN != TARG_MIN /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif"}, {"sha": "af01f9a9f3b6f75284514d934a293087402a2d63", "filename": "gcc/testsuite/gcc.dg/cpp/arith-3.c", "status": "added", "additions": 447, "deletions": 0, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9220e3a83aecc4d5fa5ecfad4d203f086e0c061/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-3.c?ref=c9220e3a83aecc4d5fa5ecfad4d203f086e0c061", "patch": "@@ -0,0 +1,447 @@\n+/* Preprocessor arithmetic semantic tests.  */\n+\n+/* Copyright (C) 2002 Free Software Foundation, Inc.  */\n+/* Source: Neil Booth, 26 May 2002.  */\n+\n+/* The file tests overflow warnings for, and values of, preprocessor\n+   arithmetic that are dependent on target precision.\n+\n+   Please keep changes to arith-2.c and arith-3.c in sync.  */\n+\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=c99 -fno-show-column\" } */\n+\n+#include <limits.h>\n+\n+#define APPEND2(NUM, SUFF) NUM ## SUFF\n+#define APPEND(NUM, SUFF) APPEND2(NUM, SUFF)\n+\n+#define TARGET_UTYPE_MAX  ULLONG_MAX\n+\n+/* The tests in this file depend only on the macros defined in this\n+   #if block.  Note that it is no good calculating these values, as\n+   the intent is to test both the preprocessor's number parser and\n+   arithmetic.  */\n+#if TARGET_UTYPE_MAX == 65535ULL\n+\n+#  define TARG_PRECISION 16\n+#  define MAX_INT  32767\n+#  define MAX_UINT 65535\n+\n+#  define TARG_MAX_HEX 0x7fff\n+#  define TARG_MAX_OCT 077777\n+#  define TARG_MAX_PLUS_1 32768L\n+#  define TARG_MAX_PLUS_1_U 32768UL\n+#  define TARG_MAX_PLUS_1_HEX 0x8000\n+#  define TARG_MAX_PLUS_1_OCT 0100000\n+#  define UTARG_MAX_HEX 0xffff\n+#  define UTARG_MAX_OCT 0177777\n+#  define UTARG_MAX_PLUS_1 65536L\n+#  define UTARG_MAX_PLUS_1_HEX 0x10000\n+#  define UTARG_MAX_PLUS_1_OCT 0200000\n+\n+#  define TARG_LOWPART_PLUS_1 256L\n+#  define TARG_LOWPART_PLUS_1_U 256UL\n+\n+  /* Division and modulo; anything that uses the high half in both\n+     dividend and divisor.  */\n+#  define LONG_UDIVISION 61234UL / 260L\n+#  define LONG_UDIVISION_ANSWER 235\n+#  define LONG_SDIVISION -15000L / 299L\n+#  define LONG_SDIVISION_ANSWER -50\n+#  define LONG_UMODULO 61234UL % 260L\n+#  define LONG_UMODULO_ANSWER 134\n+#  define LONG_SMODULO -15000L % 299L\n+#  define LONG_SMODULO_ANSWER -50\n+\n+#elif TARGET_UTYPE_MAX == 4294967295ULL\n+\n+#  define TARG_PRECISION 32\n+#  define MAX_INT  2147483647\n+#  define MAX_UINT 4294967295\n+\n+#  define TARG_MAX_HEX 0x7fffffff\n+#  define TARG_MAX_OCT 017777777777\n+#  define TARG_MAX_PLUS_1 2147483648L\n+#  define TARG_MAX_PLUS_1_U 2147483648UL\n+#  define TARG_MAX_PLUS_1_HEX 0x80000000\n+#  define TARG_MAX_PLUS_1_OCT 020000000000\n+#  define UTARG_MAX_HEX 0xffffffff\n+#  define UTARG_MAX_OCT 037777777777\n+#  define UTARG_MAX_PLUS_1 4294967296L\n+#  define UTARG_MAX_PLUS_1_HEX 0x100000000\n+#  define UTARG_MAX_PLUS_1_OCT 040000000000\n+\n+#  define TARG_LOWPART_PLUS_1 65536\n+#  define TARG_LOWPART_PLUS_1_U 65536UL\n+\n+  /* Division and modulo; anything that uses the high half in both\n+     dividend and divisor.  */\n+#  define LONG_UDIVISION 268335456UL / 70000L\n+#  define LONG_UDIVISION_ANSWER 3833\n+#  define LONG_SDIVISION -368335456L / 123456L\n+#  define LONG_SDIVISION_ANSWER -2983\n+#  define LONG_UMODULO 268335456UL % 70000L\n+#  define LONG_UMODULO_ANSWER 25456\n+#  define LONG_SMODULO -368335456L % 123456L\n+#  define LONG_SMODULO_ANSWER -66208\n+\n+#elif TARGET_UTYPE_MAX == 18446744073709551615ULL\n+\n+#  define TARG_PRECISION 64\n+#  define MAX_INT  9223372036854775807\n+#  define MAX_UINT 18446744073709551615\n+\n+#  define TARG_MAX_HEX 0x7fffffffffffffff\n+#  define TARG_MAX_OCT 0777777777777777777777\n+#  define TARG_MAX_PLUS_1 9223372036854775808L\n+#  define TARG_MAX_PLUS_1_U 9223372036854775808UL\n+#  define TARG_MAX_PLUS_1_HEX 0x8000000000000000\n+#  define TARG_MAX_PLUS_1_OCT 01000000000000000000000\n+#  define UTARG_MAX_HEX 0xffffffffffffffff\n+#  define UTARG_MAX_OCT 01777777777777777777777\n+#  define UTARG_MAX_PLUS_1 18446744073709551616L\n+#  define UTARG_MAX_PLUS_1_HEX 0x10000000000000000\n+#  define UTARG_MAX_PLUS_1_OCT 02000000000000000000000\n+\n+#  define TARG_LOWPART_PLUS_1 4294967296\n+#  define TARG_LOWPART_PLUS_1_U 4294967296U\n+\n+  /* Division and modulo; anything that uses the high half in both\n+     dividend and divisor.  */\n+#  define LONG_UDIVISION 235184372088832UL / 17279869184L\n+#  define LONG_UDIVISION_ANSWER 13610\n+#  define LONG_SDIVISION -234582345927345L / 12345678901L\n+#  define LONG_SDIVISION_ANSWER -19001\n+#  define LONG_UMODULO 235184372088832UL % 17279869184L\n+#  define LONG_UMODULO_ANSWER 5352494592L\n+#  define LONG_SMODULO -234582345927345L % 12345678901L\n+#  define LONG_SMODULO_ANSWER -2101129444L\n+\n+#else\n+\n+#  error Please extend the macros here so that this file tests your target\n+\n+#endif\n+\n+/* Create more macros based on the above.  */\n+#define TARG_PART_BITS (TARG_PRECISION / 2)\n+#define TARG_MIN (-TARG_MAX - 1)\n+#define TARG_MAX APPEND (MAX_INT, L)\n+#define TARG_MAX_U APPEND (MAX_INT, UL)\n+#define UTARG_MAX APPEND (MAX_UINT, L)\n+#define UTARG_MAX_U APPEND (MAX_UINT, UL)\n+\n+/* And now the tests.  */\n+\n+#if TARG_MAX\t\t\t/* { dg-bogus \"so large\" }  */\n+#endif\n+#if TARG_MAX_PLUS_1_HEX\t\t/* { dg-bogus \"so large\" }  */\n+#endif\n+#if TARG_MAX_PLUS_1_OCT\t\t/* { dg-bogus \"so large\" }  */\n+#endif\n+\n+#if UTARG_MAX\t\t\t/* { dg-warning \"so large\" }  */\n+#endif\n+#if UTARG_MAX_PLUS_1\t\t/* { dg-error \"too large\" }  */\n+#endif\n+#if UTARG_MAX_PLUS_1_HEX\t/* { dg-error \"too large\" }  */\n+#endif\n+#if UTARG_MAX_HEX\t\t/* { dg-bogus \"too large\" }  */\n+#endif\n+#if UTARG_MAX_PLUS_1_OCT\t/* { dg-error \"too large\" }  */\n+#endif\n+#if UTARG_MAX_OCT\t\t/* { dg-bogus \"too large\" }  */\n+#endif\n+\n+#if TARG_MAX < 0 || TARG_MAX_PLUS_1 < 0\t/* { dg-warning \"so large\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if UTARG_MAX_HEX < 0 || TARG_MAX_HEX < 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if UTARG_MAX_OCT < 0 || TARG_MAX_OCT < 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -1 != UTARG_MAX_U\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Test each operator correctly warns of overflow conditions, and\n+   gives the right answer.  */\n+\n+/* Binary +.  */\n+#if TARG_MAX + 1 != TARG_MIN\t/* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX + -2 != TARG_MAX\t/* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX + -1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX_U + 1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX_U + -2 != TARG_MAX /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Binary -.  */\n+#if TARG_MAX - -1 != TARG_MIN\t/* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX - 2 != TARG_MAX\t/* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX - 1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX_U - -1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX_U - 2 != TARG_MAX /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+\n+/* Binary *.  */\n+#if TARG_LOWPART_PLUS_1 * (TARG_LOWPART_PLUS_1 >> 1) != TARG_MIN /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_LOWPART_PLUS_1 >> 1) * TARG_LOWPART_PLUS_1 != TARG_MIN /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_LOWPART_PLUS_1 << 1) * (TARG_LOWPART_PLUS_1 + 1) != (TARG_LOWPART_PLUS_1 << 1) /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX * 1 != TARG_MAX\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_MAX >> 1) * 2\t!= TARG_MAX - 1 /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_LOWPART_PLUS_1_U + 61) * (TARG_LOWPART_PLUS_1 << 1) != 61 * (TARG_LOWPART_PLUS_1 << 1) /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_LOWPART_PLUS_1 >> 1) * TARG_LOWPART_PLUS_1_U != TARG_MIN /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 1 * TARG_MIN != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Binary /.  */\n+#if TARG_MIN / -1 != TARG_MIN\t/* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MIN / 1 != TARG_MIN\t/* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -TARG_MAX_PLUS_1_U / -1 != 0 /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -5 / (2 - 2) /* { dg-error \"division by zero\" } */\n+#endif\n+\n+#if LONG_UDIVISION != LONG_UDIVISION_ANSWER\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if LONG_SDIVISION != LONG_SDIVISION_ANSWER\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Binary %.  Cannot overflow.  */\n+#if -5 % (2 - 2) /* { dg-error \"division by zero\" } */\n+#endif\n+\n+#if TARG_MIN % 1 /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if LONG_UMODULO != LONG_UMODULO_ANSWER\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if LONG_SMODULO != LONG_SMODULO_ANSWER\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 234 % -1U != 234\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MIN % -1U != TARG_MIN\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Binary << and Binary >>, the latter cannot overflow.  */\n+#if -1 >> 3 != -1     /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX >> 3 != TARG_MAX / 8     /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 0 << 256 != 0  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 1 << 256 != 0 /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 1U << 256 != 0  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX << 1 != -2  /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX_U << 1 != -2  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_LOWPART_PLUS_1 << TARG_PART_BITS != 0  /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_LOWPART_PLUS_1 << (TARG_PART_BITS - 1) != TARG_MIN  /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_LOWPART_PLUS_1_U << (TARG_PART_BITS - 1) != TARG_MIN  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_LOWPART_PLUS_1 << (TARG_PART_BITS - 2) != (TARG_MAX_PLUS_1_U >> 1)  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Test how the sign bit is handled.  */\n+#if (TARG_MIN << 1) != 0    /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_MAX_PLUS_1_U << 1) != 0    /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_MIN >> 1) != 3U << (TARG_PRECISION - 2)    /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (TARG_MAX_PLUS_1_U >> 1) != 1 << (TARG_PRECISION - 2)    /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+/* Unary -.  It can overflow in just one case.  */\n+#if -TARG_MIN != TARG_MIN  /* { dg-warning \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if - -TARG_MAX != TARG_MAX   /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Unary +, ~, and !.  They cannot overflow.  */\n+#if +TARG_MAX != TARG_MAX  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if !TARG_MAX + !TARG_MIN != 0   /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if ~TARG_MAX , ~TARG_MIN != TARG_MAX  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Bitwise &, ^, |.  They cannot overflow.  */\n+#if (TARG_MAX & -1), (TARG_MIN & -1) != TARG_MIN  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX | -1, (TARG_MIN | -1) != -1  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if TARG_MAX ^ -1, (TARG_MIN ^ -1) != TARG_MAX  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Comparison operators.  They cannot overflow.  */\n+#if -1 <= TARG_MAX, (TARG_MIN <= 1) != 1  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -1 >= TARG_MAX, (TARG_MIN >= 1) != 0  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -1 < TARG_MAX, (TARG_MIN < 1) != 1  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -1 > TARG_MAX, (TARG_MIN > 1) != 0  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+\n+\n+\n+/* Comma and ? : operators.  They cannot overflow.  */\n+#if -1, TARG_MAX, TARG_MIN != TARG_MIN  /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -1 ? TARG_MAX: TARG_MAX, 0 ? 1: TARG_MIN != TARG_MIN /* { dg-bogus \"overflow\" } */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif"}]}