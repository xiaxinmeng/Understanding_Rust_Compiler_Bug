{"sha": "3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NjMmRkNGI3ZWIzZDYwYzI0YjljZWJlY2I5Y2QzZmIxYWI5NDE4NA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2011-10-14T10:19:01Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-10-14T10:19:01Z"}, "message": "In gcc/: 2011-10-14 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/:\n2011-10-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* gengtype.c (files_rules): Added rules for objc/objc-map.h and\n\tobjc/objc-map.c.\n\nIn gcc/objc/:\n2011-10-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objc-map.h: New file.\n\t* objc-map.c: New file.\t\n\t* config-lang.in (gtfiles): Added objc-map.h.\n\t* Make-lang.in (OBJC_OBJS): Added objc-map.o.\n\t(objc/objc-map.o): New rule.\n\t(objc/objc-act.o): Depend on objc/objc-map.h.\n\t* objc-next-runtime-abi-02.c: Added a TODO comment.\n\t* objc-act.c: Include objc-map.h.\n\t(nst_method_hash_list, cls_method_hash_list): Removed.\n\t(instance_method_map, class_method_map): New.\n\t(cls_name_hash_list, als_name_hash_list): Removed.\n\t(class_name_map, alias_name_map): Removed.\n\t(ivar_offset_hash_list): Removed.\n\t(hash_class_name_enter, hash_class_name_lookup, hash_enter,\n\thash_lookup, hash_add_attr, add_method_to_hash_list): Removed.\n\t(interface_hash_init): New.\n\t(objc_init): Call interface_hash_init.\n\t(objc_write_global_declarations): Iterate over class_method_map\n\tand instance_method_map instead of cls_method_hash_list and\n\tnst_method_hash_list.\n\t(objc_declare_alias): Use alias_name_map instead of\n\tcls_name_hash_list.\n\t(objc_is_class_name): Use class_name_map and alias_name_map\n\tinstead of cls_name_hash_list and als_name_hash_list.\n\t(interface_tuple, interface_htab, hash_interface, eq_interface):\n\tRemoved.\n\t(interface_map): New.\n\t(add_class): Renamed to add_interface.  Use interface_map instead\n\tof interface_htab.\n\t(lookup_interface): Use interface_map instead of interface_htab.\n\t(check_duplicates): Changed first argument to be a tree,\n\tpotentially a TREE_VEC, instead of a hash.  Changed implementation\n\tto match.\n\t(lookup_method_in_hash_lists): Use class_method_map and\n\tinstance_method_map instead of cls_method_hash_list and\n\tnst_method_hash_list.\n\t(objc_build_selector_expr): Likewise.\n\t(hash_func): Removed.\n\t(hash_init): Create instance_method_map, class_method_map,\n\tclass_name_map, and alias_name_map.  Do not create\n\tnst_method_hash_list, cls_method_hash_list, cls_name_hash_list,\n\tals_name_hash_list, and ivar_offset_hash_list.\n\t(insert_method_into_method_map): New.\n\t(objc_add_method): Use insert_method_into_method_map instead of\n\tadd_method_to_hash_list.\n\t(start_class): Call add_interface instead of add_class.\n\t* objc-act.h (cls_name_hash_list, als_name_hash_list,\n\tnst_method_hash_list, cls_method_hash_list): Removed.\n\nIn gcc/objcp/:\n2011-10-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* Make-lang.in (OBJCXX_OBJS): Added objc-map.o.\n\t(objcp/objc-map.o): New rule.\n\t(objcp/objcp-act.o): Depend on objc/objc-map.h.\n\t* config-lang.in (gtfiles): Added objc-map.h.\n\nFrom-SVN: r179965", "tree": {"sha": "ef62f9d9f5ec292c126959f551815e48323b3a22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef62f9d9f5ec292c126959f551815e48323b3a22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5e678de8bada6db595df5addc0a2db6e7fc9cf32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e678de8bada6db595df5addc0a2db6e7fc9cf32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e678de8bada6db595df5addc0a2db6e7fc9cf32"}], "stats": {"total": 1076, "additions": 770, "deletions": 306}, "files": [{"sha": "5c82e9b837d4301b0b354feed3c57c1da0062d83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -1,3 +1,8 @@\n+2011-10-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* gengtype.c (files_rules): Added rules for objc/objc-map.h and\n+\tobjc/objc-map.c.\n+\n 2011-10-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/17212"}, {"sha": "6063d81daa56e70e1b0f1919efd129dd8067de56", "filename": "gcc/gengtype.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -1817,6 +1817,11 @@ struct file_rule_st files_rules[] = {\n     REG_EXTENDED, NULL_REGEX,\n     \"gt-objc-objc-act.h\", \"objc/objc-act.c\", NULL_FRULACT },\n \n+  /* objc/objc-map.h gives gt-objc-objc-map.h for objc/objc-map.c !  */\n+  { DIR_PREFIX_REGEX \"objc/objc-map\\\\.h$\",\n+    REG_EXTENDED, NULL_REGEX,\n+    \"gt-objc-objc-map.h\", \"objc/objc-map.c\", NULL_FRULACT },\n+\n   /* General cases.  For header *.h and source *.c files, we need\n    * special actions to handle the language.  */\n "}, {"sha": "e5fa097c4857da0a2fe3efe5977ae0e379e2a061", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -1,3 +1,54 @@\n+2011-10-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-map.h: New file.\n+\t* objc-map.c: New file.\t\n+\t* config-lang.in (gtfiles): Added objc-map.h.\n+\t* Make-lang.in (OBJC_OBJS): Added objc-map.o.\n+\t(objc/objc-map.o): New rule.\n+\t(objc/objc-act.o): Depend on objc/objc-map.h.\n+\t* objc-next-runtime-abi-02.c: Added a TODO comment.\n+\t* objc-act.c: Include objc-map.h.\n+\t(nst_method_hash_list, cls_method_hash_list): Removed.\n+\t(instance_method_map, class_method_map): New.\n+\t(cls_name_hash_list, als_name_hash_list): Removed.\n+\t(class_name_map, alias_name_map): Removed.\n+\t(ivar_offset_hash_list): Removed.\n+\t(hash_class_name_enter, hash_class_name_lookup, hash_enter,\n+\thash_lookup, hash_add_attr, add_method_to_hash_list): Removed.\n+\t(interface_hash_init): New.\n+\t(objc_init): Call interface_hash_init.\n+\t(objc_write_global_declarations): Iterate over class_method_map\n+\tand instance_method_map instead of cls_method_hash_list and\n+\tnst_method_hash_list.\n+\t(objc_declare_alias): Use alias_name_map instead of\n+\tcls_name_hash_list.\n+\t(objc_is_class_name): Use class_name_map and alias_name_map\n+\tinstead of cls_name_hash_list and als_name_hash_list.\n+\t(interface_tuple, interface_htab, hash_interface, eq_interface):\n+\tRemoved.\n+\t(interface_map): New.\n+\t(add_class): Renamed to add_interface.  Use interface_map instead\n+\tof interface_htab.\n+\t(lookup_interface): Use interface_map instead of interface_htab.\n+\t(check_duplicates): Changed first argument to be a tree,\n+\tpotentially a TREE_VEC, instead of a hash.  Changed implementation\n+\tto match.\n+\t(lookup_method_in_hash_lists): Use class_method_map and\n+\tinstance_method_map instead of cls_method_hash_list and\n+\tnst_method_hash_list.\n+\t(objc_build_selector_expr): Likewise.\n+\t(hash_func): Removed.\n+\t(hash_init): Create instance_method_map, class_method_map,\n+\tclass_name_map, and alias_name_map.  Do not create\n+\tnst_method_hash_list, cls_method_hash_list, cls_name_hash_list,\n+\tals_name_hash_list, and ivar_offset_hash_list.\n+\t(insert_method_into_method_map): New.\n+\t(objc_add_method): Use insert_method_into_method_map instead of\n+\tadd_method_to_hash_list.\n+\t(start_class): Call add_interface instead of add_class.\n+\t* objc-act.h (cls_name_hash_list, als_name_hash_list,\n+\tnst_method_hash_list, cls_method_hash_list): Removed.\n+\n 2011-10-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* objc-next-runtime-abi-01.c (objc_build_exc_ptr): Delete old"}, {"sha": "5cca11a6b4d602524920e288407422dcd830791e", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -55,7 +55,8 @@ OBJC_OBJS = objc/objc-lang.o objc/objc-act.o \\\n    objc/objc-gnu-runtime-abi-01.o \\\n    objc/objc-next-runtime-abi-01.o \\\n    objc/objc-next-runtime-abi-02.o \\\n-   objc/objc-encoding.o\n+   objc/objc-encoding.o \\\n+   objc/objc-map.o\n \n objc_OBJS = $(OBJC_OBJS) cc1obj-checksum.o\n \n@@ -129,6 +130,7 @@ objc/objc-act.o : objc/objc-act.c \\\n    $(HASHTAB_H) $(GIMPLE_H) \\\n    $(C_PRAGMA_H) $(C_TARGET_H) \\\n    objc/objc-encoding.h \\\n+   objc/objc-map.h \\\n    objc/objc-runtime-hooks.h \\\n    objc/objc-runtime-shared-support.h\n \n@@ -139,6 +141,12 @@ objc/objc-encoding.o : objc/objc-encoding.c \\\n    objc/objc-encoding.h \\\n    objc/objc-runtime-shared-support.h\n \n+objc/objc-map.o : objc/objc-map.c \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   objc/objc-map.h\n+\n objc.srcextra:\n \n #\f"}, {"sha": "48f8582d74c143b03e423d019333c1cc53b3335c", "filename": "gcc/objc/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fconfig-lang.in?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -36,4 +36,4 @@ lang_requires=\"c\"\n # Order is important.  If you change this list, make sure you test\n # building without C++ as well; that is, remove the gcc/cp directory,\n # and build with --enable-languages=c,objc.\n-gtfiles=\"\\$(srcdir)/c-family/c-objc.h \\$(srcdir)/objc/objc-act.h \\$(srcdir)/objc/objc-act.c \\$(srcdir)/objc/objc-runtime-shared-support.c \\$(srcdir)/objc/objc-gnu-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-02.c \\$(srcdir)/c-parser.c \\$(srcdir)/c-tree.h \\$(srcdir)/c-decl.c \\$(srcdir)/c-lang.h \\$(srcdir)/c-objc-common.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-cppbuiltin.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c\"\n+gtfiles=\"\\$(srcdir)/objc/objc-map.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/objc/objc-act.h \\$(srcdir)/objc/objc-act.c \\$(srcdir)/objc/objc-runtime-shared-support.c \\$(srcdir)/objc/objc-gnu-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-02.c \\$(srcdir)/c-parser.c \\$(srcdir)/c-tree.h \\$(srcdir)/c-decl.c \\$(srcdir)/c-lang.h \\$(srcdir)/c-objc-common.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-cppbuiltin.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c\""}, {"sha": "396d748849f39730da7b81c16fd4b8d51bbb91bb", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 210, "deletions": 297, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"langhooks.h\"\n #include \"objc-act.h\"\n+#include \"objc-map.h\"\n #include \"input.h\"\n #include \"function.h\"\n #include \"output.h\"\n@@ -157,27 +158,25 @@ static void objc_generate_cxx_cdtors (void);\n static void objc_decl_method_attributes (tree*, tree, int);\n static tree build_keyword_selector (tree);\n \n-/* Hash tables to manage the global pool of method prototypes.  */\n static void hash_init (void);\n \n-hash *nst_method_hash_list = 0;\n-hash *cls_method_hash_list = 0;\n+/* Hash tables to manage the global pool of method prototypes.  Each\n+   of these maps map a method name (selector) identifier to either a\n+   single tree (for methods with a single method prototype) or a\n+   TREE_VEC (for methods with multiple method prototypes).  */\n+static GTY(()) objc_map_t instance_method_map = 0;\n+static GTY(()) objc_map_t class_method_map = 0;\n \n /* Hash tables to manage the global pool of class names.  */\n \n-hash *cls_name_hash_list = 0;\n-hash *als_name_hash_list = 0;\n+static GTY(()) objc_map_t class_name_map = 0;\n+static GTY(()) objc_map_t alias_name_map = 0;\n \n-hash *ivar_offset_hash_list = 0;\n-\n-static void hash_class_name_enter (hash *, tree, tree);\n-static hash hash_class_name_lookup (hash *, tree);\n-\n-static hash hash_lookup (hash *, tree);\n static tree lookup_method (tree, tree);\n static tree lookup_method_static (tree, tree, int);\n \n-static tree add_class (tree, tree);\n+static void interface_hash_init (void);\n+static tree add_interface (tree, tree);\n static void add_category (tree, tree);\n static inline tree lookup_category (tree, tree);\n \n@@ -207,7 +206,7 @@ static void generate_struct_by_value_array (void) ATTRIBUTE_NORETURN;\n \n static void mark_referenced_methods (void);\n static bool objc_type_valid_for_messaging (tree type, bool allow_classes);\n-static tree check_duplicates (hash, int, int);\n+static tree check_duplicates (tree, int, int);\n \n /*** Private Interface (data) ***/\n /* Flags for lookup_method_static().  */\n@@ -380,6 +379,7 @@ objc_init (void)\n \n   /* Set up stuff used by FE parser and all runtimes.  */\n   errbuf = XNEWVEC (char, 1024 * 10);\n+  interface_hash_init ();\n   hash_init ();\n   objc_encoding_init ();\n   /* ... and then check flags and set-up for the selected runtime ... */\n@@ -418,19 +418,15 @@ objc_write_global_declarations (void)\n \n   if (warn_selector)\n     {\n-      int slot;\n-      hash hsh;\n+      objc_map_iterator_t i;\n \n-      /* Run through the selector hash tables and print a warning for any\n-         selector which has multiple methods.  */\n+      objc_map_iterator_initialize (class_method_map, &i);\n+      while (objc_map_iterator_move_to_next (class_method_map, &i))\n+\tcheck_duplicates (objc_map_iterator_current_value (class_method_map, i), 0, 1);\n \n-      for (slot = 0; slot < SIZEHASHTABLE; slot++)\n-\t{\n-\t  for (hsh = cls_method_hash_list[slot]; hsh; hsh = hsh->next)\n-\t    check_duplicates (hsh, 0, 1);\n-\t  for (hsh = nst_method_hash_list[slot]; hsh; hsh = hsh->next)\n-\t    check_duplicates (hsh, 0, 0);\n-\t}\n+      objc_map_iterator_initialize (instance_method_map, &i);\n+      while (objc_map_iterator_move_to_next (instance_method_map, &i))\n+\tcheck_duplicates (objc_map_iterator_current_value (instance_method_map, i), 0, 0);\n     }\n \n   /* TODO: consider an early exit here if either errorcount or sorrycount\n@@ -3351,8 +3347,7 @@ objc_declare_alias (tree alias_ident, tree class_ident)\n #ifdef OBJCPLUS\n       pop_lang_context ();\n #endif\n-      hash_class_name_enter (als_name_hash_list, alias_ident,\n-\t\t\t     underlying_class);\n+      objc_map_put (alias_name_map, alias_ident, underlying_class);\n     }\n }\n \n@@ -3392,15 +3387,13 @@ objc_declare_class (tree identifier)\n \t the TYPE_OBJC_INTERFACE.  If later an @interface is found,\n \t we'll replace the ident with the interface.  */\n       TYPE_OBJC_INTERFACE (record) = identifier;\n-      hash_class_name_enter (cls_name_hash_list, identifier, NULL_TREE);\n+      objc_map_put (class_name_map, identifier, NULL_TREE);\n     }\n }\n \n tree\n objc_is_class_name (tree ident)\n {\n-  hash target;\n-\n   if (ident && TREE_CODE (ident) == IDENTIFIER_NODE)\n     {\n       tree t = identifier_global_value (ident);\n@@ -3428,16 +3421,17 @@ objc_is_class_name (tree ident)\n   if (lookup_interface (ident))\n     return ident;\n \n-  target = hash_class_name_lookup (cls_name_hash_list, ident);\n-  if (target)\n-    return target->key;\n+  {\n+    tree target;\n \n-  target = hash_class_name_lookup (als_name_hash_list, ident);\n-  if (target)\n-    {\n-      gcc_assert (target->list && target->list->value);\n-      return target->list->value;\n-    }\n+    target = objc_map_get (class_name_map, ident);\n+    if (target != OBJC_MAP_NOT_FOUND)\n+      return ident;\n+\n+    target = objc_map_get (alias_name_map, ident);\n+    if (target != OBJC_MAP_NOT_FOUND)\n+      return target;\n+  }\n \n   return 0;\n }\n@@ -3761,25 +3755,30 @@ objc_generate_write_barrier (tree lhs, enum tree_code modifycode, tree rhs)\n   return result;\n }\n \n-struct GTY(()) interface_tuple {\n-  tree id;\n-  tree class_name;\n-};\n+/* Implementation of the table mapping a class name (as an identifier)\n+   to a class node.  The two public functions for it are\n+   lookup_interface() and add_interface().  add_interface() is only\n+   used in this file, so we can make it static.  */\n \n-static GTY ((param_is (struct interface_tuple))) htab_t interface_htab;\n+static GTY(()) objc_map_t interface_map;\n \n-static hashval_t\n-hash_interface (const void *p)\n+static void\n+interface_hash_init (void)\n {\n-  const struct interface_tuple *d = (const struct interface_tuple *) p;\n-  return IDENTIFIER_HASH_VALUE (d->id);\n+  interface_map = objc_map_alloc_ggc (200);  \n }\n \n-static int\n-eq_interface (const void *p1, const void *p2)\n+static tree\n+add_interface (tree class_name, tree name)\n {\n-  const struct interface_tuple *d = (const struct interface_tuple *) p1;\n-  return d->id == p2;\n+  /* Put interfaces on list in reverse order.  */\n+  TREE_CHAIN (class_name) = interface_chain;\n+  interface_chain = class_name;\n+\n+  /* Add it to the map.  */\n+  objc_map_put (interface_map, name, class_name);\n+\n+  return interface_chain;\n }\n \n tree\n@@ -3794,19 +3793,12 @@ lookup_interface (tree ident)\n     return NULL_TREE;\n \n   {\n-    struct interface_tuple **slot;\n-    tree i = NULL_TREE;\n+    tree interface = objc_map_get (interface_map, ident);\n \n-    if (interface_htab)\n-      {\n-\tslot = (struct interface_tuple **)\n-\t  htab_find_slot_with_hash (interface_htab, ident,\n-\t\t\t\t    IDENTIFIER_HASH_VALUE (ident),\n-\t\t\t\t    NO_INSERT);\n-\tif (slot && *slot)\n-\t  i = (*slot)->class_name;\n-      }\n-    return i;\n+    if (interface == OBJC_MAP_NOT_FOUND)\n+      return NULL_TREE;\n+    else\n+      return interface;\n   }\n }\n \n@@ -5052,71 +5044,75 @@ build_function_type_for_method (tree return_type, tree method,\n   return ftype;\n }\n \n+/* The 'method' argument is a tree; this tree could either be a single\n+   method, which is returned, or could be a TREE_VEC containing a list\n+   of methods.  In that case, the first one is returned, and warnings\n+   are issued as appropriate.  */\n static tree\n-check_duplicates (hash hsh, int methods, int is_class)\n+check_duplicates (tree method, int methods, int is_class)\n {\n-  tree meth = NULL_TREE;\n-\n-  if (hsh)\n-    {\n-      meth = hsh->key;\n-\n-      if (hsh->list)\n-        {\n-\t  /* We have two or more methods with the same name but\n-\t     different types.  */\n-\t  attr loop;\n-\n-\t  /* But just how different are those types?  If\n-\t     -Wno-strict-selector-match is specified, we shall not\n-\t     complain if the differences are solely among types with\n-\t     identical size and alignment.  */\n-\t  if (!warn_strict_selector_match)\n-\t    {\n-\t      for (loop = hsh->list; loop; loop = loop->next)\n-\t\tif (!comp_proto_with_proto (meth, loop->value, 0))\n-\t\t  goto issue_warning;\n-\n-\t      return meth;\n-\t    }\n-\n-\tissue_warning:\n-\t  if (methods)\n-\t    {\n-\t      bool type = TREE_CODE (meth) == INSTANCE_METHOD_DECL;\n-\n-\t      warning_at (input_location, 0,\n-\t\t\t  \"multiple methods named %<%c%E%> found\",\n-\t\t\t  (is_class ? '+' : '-'),\n-\t\t\t  METHOD_SEL_NAME (meth));\n-\t      inform (DECL_SOURCE_LOCATION (meth), \"using %<%c%s%>\",\n-\t\t      (type ? '-' : '+'),\n-\t\t      identifier_to_locale (gen_method_decl (meth)));\n-\t    }\n-\t  else\n-\t    {\n-\t      bool type = TREE_CODE (meth) == INSTANCE_METHOD_DECL;\n+  tree first_method;\n+  size_t i;\n \n-\t      warning_at (input_location, 0,\n-\t\t\t  \"multiple selectors named %<%c%E%> found\",\n-\t\t\t  (is_class ? '+' : '-'),\n-\t\t\t  METHOD_SEL_NAME (meth));\n-\t      inform (DECL_SOURCE_LOCATION (meth), \"found %<%c%s%>\",\n-\t\t      (type ? '-' : '+'),\n-\t\t      identifier_to_locale (gen_method_decl (meth)));\n-\t    }\n-\n-\t  for (loop = hsh->list; loop; loop = loop->next)\n-\t    {\n-\t      bool type = TREE_CODE (loop->value) == INSTANCE_METHOD_DECL;\n+  if (method == NULL_TREE)\n+    return NULL_TREE;\n \n-\t      inform (DECL_SOURCE_LOCATION (loop->value), \"also found %<%c%s%>\",\n-\t\t      (type ? '-' : '+'),\n-\t\t      identifier_to_locale (gen_method_decl (loop->value)));\n-\t    }\n-        }\n+  if (TREE_CODE (method) != TREE_VEC)\n+    return method;\n+\n+  /* We have two or more methods with the same name but different\n+     types.  */\n+  first_method = TREE_VEC_ELT (method, 0);\n+  \n+  /* But just how different are those types?  If\n+     -Wno-strict-selector-match is specified, we shall not complain if\n+     the differences are solely among types with identical size and\n+     alignment.  */\n+  if (!warn_strict_selector_match)\n+    {\n+      for (i = 0; i < TREE_VEC_LENGTH (method); i++)\n+\tif (!comp_proto_with_proto (first_method, TREE_VEC_ELT (method, i), 0))\n+\t  goto issue_warning;\n+      \n+      return first_method;\n+    }\n+    \n+ issue_warning:\n+  if (methods)\n+    {\n+      bool type = TREE_CODE (first_method) == INSTANCE_METHOD_DECL;\n+      \n+      warning_at (input_location, 0,\n+\t\t  \"multiple methods named %<%c%E%> found\",\n+\t\t  (is_class ? '+' : '-'),\n+\t\t  METHOD_SEL_NAME (first_method));\n+      inform (DECL_SOURCE_LOCATION (first_method), \"using %<%c%s%>\",\n+\t      (type ? '-' : '+'),\n+\t      identifier_to_locale (gen_method_decl (first_method)));\n     }\n-  return meth;\n+  else\n+    {\n+      bool type = TREE_CODE (first_method) == INSTANCE_METHOD_DECL;\n+      \n+      warning_at (input_location, 0,\n+\t\t  \"multiple selectors named %<%c%E%> found\",\n+\t\t  (is_class ? '+' : '-'),\n+\t\t  METHOD_SEL_NAME (first_method));\n+      inform (DECL_SOURCE_LOCATION (first_method), \"found %<%c%s%>\",\n+\t      (type ? '-' : '+'),\n+\t      identifier_to_locale (gen_method_decl (first_method)));\n+    }\n+  \n+  for (i = 0; i < TREE_VEC_LENGTH (method); i++)\n+    {\n+      bool type = TREE_CODE (TREE_VEC_ELT (method, i)) == INSTANCE_METHOD_DECL;\n+      \n+      inform (DECL_SOURCE_LOCATION (TREE_VEC_ELT (method, i)), \"also found %<%c%s%>\",\n+\t      (type ? '-' : '+'),\n+\t      identifier_to_locale (gen_method_decl (TREE_VEC_ELT (method, i))));\n+    }\n+\n+  return first_method;\n }\n \n /* If RECEIVER is a class reference, return the identifier node for\n@@ -5294,17 +5290,18 @@ objc_build_message_expr (tree receiver, tree message_args)\n static tree\n lookup_method_in_hash_lists (tree sel_name, int is_class)\n {\n-  hash method_prototype = NULL;\n+  tree method_prototype = OBJC_MAP_NOT_FOUND;\n \n   if (!is_class)\n-    method_prototype = hash_lookup (nst_method_hash_list,\n-\t\t\t\t    sel_name);\n-\n-  if (!method_prototype)\n+    method_prototype = objc_map_get (instance_method_map, sel_name);\n+  \n+  if (method_prototype == OBJC_MAP_NOT_FOUND)\n     {\n-      method_prototype = hash_lookup (cls_method_hash_list,\n-\t\t\t\t      sel_name);\n+      method_prototype = objc_map_get (class_method_map, sel_name);\n       is_class = 1;\n+\n+      if (method_prototype == OBJC_MAP_NOT_FOUND)\n+\treturn NULL_TREE;\n     }\n \n   return check_duplicates (method_prototype, 1, is_class);\n@@ -5714,21 +5711,19 @@ objc_build_selector_expr (location_t loc, tree selnamelist)\n       /* Look the selector up in the list of all known class and\n          instance methods (up to this line) to check that the selector\n          exists.  */\n-      hash hsh;\n+      tree method;\n \n       /* First try with instance methods.  */\n-      hsh = hash_lookup (nst_method_hash_list, selname);\n+      method = objc_map_get (instance_method_map, selname);\n \n       /* If not found, try with class methods.  */\n-      if (!hsh)\n+      if (method == OBJC_MAP_NOT_FOUND)\n \t{\n-\t  hsh = hash_lookup (cls_method_hash_list, selname);\n-\t}\n+\t  method = objc_map_get (class_method_map, selname);\n \n-      /* If still not found, print out a warning.  */\n-      if (!hsh)\n-\t{\n-\t  warning (0, \"undeclared selector %qE\", selname);\n+\t  /* If still not found, print out a warning.  */\n+\t  if (method == OBJC_MAP_NOT_FOUND)\n+\t    warning (0, \"undeclared selector %qE\", selname);\n \t}\n     }\n \n@@ -5761,131 +5756,99 @@ build_ivar_reference (tree id)\n   return (*runtime.build_ivar_reference) (input_location, base, id);\n }\n \n-/* Compute a hash value for a given method SEL_NAME.  */\n-\n-static size_t\n-hash_func (tree sel_name)\n-{\n-  const unsigned char *s\n-    = (const unsigned char *)IDENTIFIER_POINTER (sel_name);\n-  size_t h = 0;\n-\n-  while (*s)\n-    h = h * 67 + *s++ - 113;\n-  return h;\n-}\n-\n static void\n hash_init (void)\n {\n-  nst_method_hash_list = ggc_alloc_cleared_vec_hash (SIZEHASHTABLE);\n-  cls_method_hash_list = ggc_alloc_cleared_vec_hash (SIZEHASHTABLE);\n-\n-  cls_name_hash_list = ggc_alloc_cleared_vec_hash (SIZEHASHTABLE);\n-  als_name_hash_list = ggc_alloc_cleared_vec_hash (SIZEHASHTABLE);\n+  instance_method_map = objc_map_alloc_ggc (1000);\n+  class_method_map = objc_map_alloc_ggc (1000);\n \n-  ivar_offset_hash_list = ggc_alloc_cleared_vec_hash (SIZEHASHTABLE);\n+  class_name_map = objc_map_alloc_ggc (200);\n+  alias_name_map = objc_map_alloc_ggc (200);\n \n   /* Initialize the hash table used to hold the constant string objects.  */\n   string_htab = htab_create_ggc (31, string_hash,\n \t\t\t\t   string_eq, NULL);\n }\n \n-/* This routine adds sel_name to the hash list. sel_name  is a class or alias\n-   name for the class. If alias name, then value is its underlying class.\n-   If class, the value is NULL_TREE. */\n-\n+/* Use the following to add a method to class_method_map or\n+   instance_method_map.  It will add the method, keyed by the\n+   METHOD_SEL_NAME.  If the method already exists, but with one or\n+   more different prototypes, it will store a TREE_VEC in the map,\n+   with the method prototypes in the vector.  */\n static void\n-hash_class_name_enter (hash *hashlist, tree sel_name, tree value)\n+insert_method_into_method_map (bool class_method, tree method)\n {\n-  hash obj;\n-  int slot = hash_func (sel_name) % SIZEHASHTABLE;\n+  tree method_name = METHOD_SEL_NAME (method);\n+  tree existing_entry;\n+  objc_map_t map;\n \n-  obj = ggc_alloc_hashed_entry ();\n-  if (value != NULL_TREE)\n-    {\n-      /* Save the underlying class for the 'alias' in the hash table */\n-      attr obj_attr = ggc_alloc_hashed_attribute ();\n-      obj_attr->value = value;\n-      obj->list = obj_attr;\n-    }\n+  if (class_method)\n+    map = class_method_map;\n   else\n-    obj->list = 0;\n-  obj->next = hashlist[slot];\n-  obj->key = sel_name;\n-\n-  hashlist[slot] = obj;         /* append to front */\n+    map = instance_method_map;\n \n-}\n+  /* Check if the method already exists in the map.  */\n+  existing_entry = objc_map_get (map, method_name);\n \n-/*\n-   Searches in the hash table looking for a match for class or alias name.\n-*/\n-\n-static hash\n-hash_class_name_lookup (hash *hashlist, tree sel_name)\n-{\n-  hash target;\n-\n-  target = hashlist[hash_func (sel_name) % SIZEHASHTABLE];\n-\n-  while (target)\n+  /* If not, we simply add it to the map.  */\n+  if (existing_entry == OBJC_MAP_NOT_FOUND)\n+    objc_map_put (map, method_name, method);\n+  else\n     {\n-      if (sel_name == target->key)\n-\treturn target;\n-\n-      target = target->next;\n-    }\n-  return 0;\n-}\n-\n-/* WARNING!!!!  hash_enter is called with a method, and will peek\n-   inside to find its selector!  But hash_lookup is given a selector\n-   directly, and looks for the selector that's inside the found\n-   entry's key (method) for comparison.  */\n-\n-static void\n-hash_enter (hash *hashlist, tree method)\n-{\n-  hash obj;\n-  int slot = hash_func (METHOD_SEL_NAME (method)) % SIZEHASHTABLE;\n-\n-  obj = ggc_alloc_hashed_entry ();\n-  obj->list = 0;\n-  obj->next = hashlist[slot];\n-  obj->key = method;\n-\n-  hashlist[slot] = obj;\t\t/* append to front */\n-}\n-\n-static hash\n-hash_lookup (hash *hashlist, tree sel_name)\n-{\n-  hash target;\n+      tree new_entry;\n+      \n+      /* If an entry already exists, it's more complicated.  We'll\n+\t have to check whether the method prototype is the same or\n+\t not.  */\n+      if (TREE_CODE (existing_entry) != TREE_VEC)\n+\t{\n+\t  /* If the method prototypes are the same, there is nothing\n+\t     to do.  */\n+\t  if (comp_proto_with_proto (method, existing_entry, 1))\n+\t    return;\n \n-  target = hashlist[hash_func (sel_name) % SIZEHASHTABLE];\n+\t  /* If not, create a vector to store both the method already\n+\t     in the map, and the new one that we are adding.  */\n+\t  new_entry = make_tree_vec (2);\n+\t  \n+\t  TREE_VEC_ELT (new_entry, 0) = existing_entry;\n+\t  TREE_VEC_ELT (new_entry, 1) = method;\n+\t}\n+      else\n+\t{\n+\t  /* An entry already exists, and it's already a vector.  This\n+\t     means that at least 2 different method prototypes were\n+\t     already found, and we're considering registering yet\n+\t     another one.  */\n+\t  size_t i;\n+\n+\t  /* Check all the existing prototypes.  If any matches the\n+\t     one we need to add, there is nothing to do because it's\n+\t     already there.  */\n+\t  for (i = 0; i < TREE_VEC_LENGTH (existing_entry); i++)\n+\t    if (comp_proto_with_proto (method, TREE_VEC_ELT (existing_entry, i), 1))\n+\t      return;\n \n-  while (target)\n-    {\n-      if (sel_name == METHOD_SEL_NAME (target->key))\n-\treturn target;\n+\t  /* Else, create a new, bigger vector and add the new method\n+\t     at the end of it.  This is inefficient but extremely\n+\t     rare; in any sane program most methods have a single\n+\t     prototype, and very few, if any, will have more than\n+\t     2!  */\n+\t  new_entry = make_tree_vec (TREE_VEC_LENGTH (existing_entry) + 1);\n+\t  \n+\t  /* Copy the methods from the existing vector.  */\n+\t  for (i = 0; i < TREE_VEC_LENGTH (existing_entry); i++)\n+\t    TREE_VEC_ELT (new_entry, i) = TREE_VEC_ELT (existing_entry, i);\n+\t  \n+\t  /* Add the new method at the end.  */\n+\t  TREE_VEC_ELT (new_entry, i) = method;\n+\t}\n \n-      target = target->next;\n+      /* Store the new vector in the map.  */\n+      objc_map_put (map, method_name, new_entry);\n     }\n-  return 0;\n }\n \n-static void\n-hash_add_attr (hash entry, tree value)\n-{\n-  attr obj;\n-\n-  obj = ggc_alloc_hashed_attribute ();\n-  obj->next = entry->list;\n-  obj->value = value;\n-\n-  entry->list = obj;\t\t/* append to front */\n-}\n \f\n static tree\n lookup_method (tree mchain, tree method)\n@@ -5988,31 +5951,6 @@ lookup_method_static (tree interface, tree ident, int flags)\n     }\n }\n \n-/* Add the method to the hash list if it doesn't contain an identical\n-   method already. */\n-\n-static void\n-add_method_to_hash_list (hash *hash_list, tree method)\n-{\n-  hash hsh;\n-\n-  if (!(hsh = hash_lookup (hash_list, METHOD_SEL_NAME (method))))\n-    {\n-      /* Install on a global chain.  */\n-      hash_enter (hash_list, method);\n-    }\n-  else\n-    {\n-      /* Check types against those; if different, add to a list.  */\n-      attr loop;\n-      int already_there = comp_proto_with_proto (method, hsh->key, 1);\n-      for (loop = hsh->list; !already_there && loop; loop = loop->next)\n-\talready_there |= comp_proto_with_proto (method, loop->value, 1);\n-      if (!already_there)\n-\thash_add_attr (hsh, method);\n-    }\n-}\n-\n static tree\n objc_add_method (tree klass, tree method, int is_class, bool is_optional)\n {\n@@ -6135,10 +6073,10 @@ objc_add_method (tree klass, tree method, int is_class, bool is_optional)\n     }\n \n   if (is_class)\n-    add_method_to_hash_list (cls_method_hash_list, method);\n+    insert_method_into_method_map (true, method);\n   else\n     {\n-      add_method_to_hash_list (nst_method_hash_list, method);\n+      insert_method_into_method_map (false, method);\n \n       /* Instance methods in root classes (and categories thereof)\n \t may act as class methods as a last resort.  We also add\n@@ -6151,37 +6089,12 @@ objc_add_method (tree klass, tree method, int is_class, bool is_optional)\n \n       if (TREE_CODE (klass) == PROTOCOL_INTERFACE_TYPE\n \t  || !CLASS_SUPER_NAME (klass))\n-\tadd_method_to_hash_list (cls_method_hash_list, method);\n+\tinsert_method_into_method_map (true, method);\n     }\n \n   return method;\n }\n \n-static tree\n-add_class (tree class_name, tree name)\n-{\n-  struct interface_tuple **slot;\n-\n-  /* Put interfaces on list in reverse order.  */\n-  TREE_CHAIN (class_name) = interface_chain;\n-  interface_chain = class_name;\n-\n-  if (interface_htab == NULL)\n-    interface_htab = htab_create_ggc (31, hash_interface, eq_interface, NULL);\n-  slot = (struct interface_tuple **)\n-    htab_find_slot_with_hash (interface_htab, name,\n-\t\t\t      IDENTIFIER_HASH_VALUE (name),\n-\t\t\t      INSERT);\n-  if (!*slot)\n-    {\n-      *slot = ggc_alloc_cleared_interface_tuple ();\n-      (*slot)->id = name;\n-    }\n-  (*slot)->class_name = class_name;\n-\n-  return interface_chain;\n-}\n-\n static void\n add_category (tree klass, tree category)\n {\n@@ -6951,8 +6864,8 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n         {\n \t  warning (0, \"cannot find interface declaration for %qE\",\n \t\t   class_name);\n-\t  add_class (implementation_template = objc_implementation_context,\n-\t\t     class_name);\n+\t  add_interface (implementation_template = objc_implementation_context,\n+\t\t\t class_name);\n         }\n \n       /* If a super class has been specified in the implementation,\n@@ -6985,7 +6898,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n         warning (0, \"duplicate interface declaration for class %qE\", class_name);\n #endif\n       else\n-\tadd_class (klass, class_name);\n+\tadd_interface (klass, class_name);\n \n       if (protocol_list)\n \tCLASS_PROTOCOL_LIST (klass)"}, {"sha": "e958e669af0da71c92f10ef96db8e66374b62ce3", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -252,12 +252,6 @@ struct GTY(()) hashed_entry {\n \n #define SIZEHASHTABLE\t\t257\n \n-extern GTY ((length (\"SIZEHASHTABLE\"))) hash *nst_method_hash_list;\n-extern GTY ((length (\"SIZEHASHTABLE\"))) hash *cls_method_hash_list;\n-\n-extern GTY ((length (\"SIZEHASHTABLE\"))) hash *cls_name_hash_list;\n-extern GTY ((length (\"SIZEHASHTABLE\"))) hash *als_name_hash_list;\n-\n /* An array of all the local variables in the current function that\n    need to be marked as volatile.  */\n extern GTY(()) VEC(tree,gc) *local_variables_to_volatilize;"}, {"sha": "77a98c1d82525c594ef9ebc83e39d78c1aee52c4", "filename": "gcc/objc/objc-map.c", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2Fobjc-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2Fobjc-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-map.c?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -0,0 +1,161 @@\n+/* objc-map.c -- Implementation of map data structures for ObjC compiler\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Written by Nicola Pero <nicola.pero@meta-innovation.com>\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU Lesser Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU Lesser Public License for more details.\n+\n+You should have received a copy of the GNU Lesser Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"ggc.h\"\n+#include \"objc-map.h\"\n+\n+#define OUT_OF_MEMORY { fprintf (stderr, \"Out of memory\\n\"); abort (); }\n+\n+static\n+size_t\n+ATTRIBUTE_PURE\n+next_power_of_two (size_t x)\n+{\n+  size_t result = 1;\n+\n+  if (x < 2)\n+    return 2;\n+\n+  /* Avoid the long calculation if x is already a power of two.  Since\n+     we internally always increase/shrink tables by powers of 2, the\n+     calculation should only be done once, when the table is first\n+     set up.  */\n+  if ((x & (x - 1)) == 0)\n+    return x;\n+\n+  /* Calculate log_2 by counting how many times we can divide by 2\n+     before reaching 0.  */\n+  while (x > 0)\n+    {\n+      x = x >> 1;\n+      result = result << 1;\n+    }\n+  return result;\n+}\n+\n+objc_map_t\n+objc_map_alloc_ggc (size_t initial_capacity)\n+{\n+  objc_map_t map = (objc_map_t) ggc_internal_cleared_vec_alloc_stat (1, sizeof (struct objc_map_private));\n+  if (map == NULL)\n+    OUT_OF_MEMORY;\n+  \n+  initial_capacity = next_power_of_two (initial_capacity);\n+  \n+  map->number_of_slots = initial_capacity;\n+  map->mask = initial_capacity - 1;\n+  map->maximum_load_factor = 70;\n+  map->max_number_of_non_empty_slots = (initial_capacity * map->maximum_load_factor) / 100;\n+\n+  map->slots = (tree *)ggc_internal_cleared_vec_alloc_stat (initial_capacity, sizeof (tree));\n+  map->values = (tree *)ggc_internal_cleared_vec_alloc_stat (initial_capacity, sizeof (tree));\n+\n+  if (map->slots == NULL)\n+    OUT_OF_MEMORY;\n+  \n+  if (map->values == NULL)\n+    OUT_OF_MEMORY;\n+\n+  return map;\n+}\n+\n+void\n+objc_map_set_maximum_load_factor (objc_map_t map, int number_between_zero_and_one_hundred)\n+{\n+  if (map->number_of_non_empty_slots != 0)\n+    return;\n+\n+  map->maximum_load_factor = number_between_zero_and_one_hundred;\n+  map->max_number_of_non_empty_slots = (map->number_of_slots * number_between_zero_and_one_hundred) / 100;\n+}\n+\n+int\n+objc_map_maximum_load_factor (objc_map_t map)\n+{\n+  return map->maximum_load_factor;\n+}\n+\n+static void\n+objc_map_private_resize (objc_map_t map, size_t new_number_of_slots)\n+{\n+  tree *old_slots = map->slots;\n+  tree *old_values = map->values;\n+  size_t i, old_number_of_slots = map->number_of_slots;\n+  \n+  if (new_number_of_slots < (map->number_of_non_empty_slots))\n+    new_number_of_slots = 2 * map->number_of_non_empty_slots;\n+\n+  new_number_of_slots = next_power_of_two (new_number_of_slots);\n+  \n+  map->number_of_slots = new_number_of_slots;\n+  map->mask = map->number_of_slots - 1;\n+  map->max_number_of_non_empty_slots = (map->number_of_slots * map->maximum_load_factor) / 100;\n+\n+\n+  map->slots = (tree *)ggc_internal_cleared_vec_alloc_stat (map->number_of_slots, sizeof (tree));\n+  map->values = (tree *)ggc_internal_cleared_vec_alloc_stat (map->number_of_slots, sizeof (tree));\n+\n+  if (map->slots == NULL)\n+    OUT_OF_MEMORY;\n+\n+  if (map->values == NULL)\n+    OUT_OF_MEMORY;\n+\n+  for (i = 0; i < old_number_of_slots; i++)\n+    if (old_slots[i] != OBJC_MAP_PRIVATE_EMPTY_SLOT)\n+      {\n+\tsize_t k = IDENTIFIER_HASH_VALUE (old_slots[i]) & map->mask;\n+\t\n+\tif (map->slots[k] == OBJC_MAP_PRIVATE_EMPTY_SLOT)\n+\t  {\n+\t    map->slots[k] = old_slots[i];\n+\t    map->values[k] = old_values[i];\n+\t  }\n+\telse\n+\t  {\n+\t    size_t j = 1;\n+\t    while (1)\n+\t      {\n+\t\tk = (k + j) & map->mask;\n+\t\tif (map->slots[k] == OBJC_MAP_PRIVATE_EMPTY_SLOT)\n+\t\t  {\n+\t\t    map->slots[k] = old_slots[i];\n+\t\t    map->values[k] = old_values[i];\n+\t\t    break;\n+\t\t  }\n+\t\tj++;\n+\t      }\n+\t  }\n+      }\n+\n+  ggc_free (old_slots);\n+  ggc_free (old_values);\n+}\n+\n+void\n+objc_map_private_grow (struct objc_map_private *map)\n+{\n+  objc_map_private_resize (map, map->number_of_slots * 2);\n+}\n+\n+#include \"gt-objc-objc-map.h\""}, {"sha": "c4565de186e267f27eafd0d445e2cba4a3b5223f", "filename": "gcc/objc/objc-map.h", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2Fobjc-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2Fobjc-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-map.h?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -0,0 +1,309 @@\n+/* objc-map.h -- Implementation of map data structures for ObjC compiler\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Written by Nicola Pero <nicola.pero@meta-innovation.com>\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU Lesser Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU Lesser Public License for more details.\n+\n+You should have received a copy of the GNU Lesser Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#ifndef OBJC_MAP_H\n+#define OBJC_MAP_H\n+\n+/* A map is a data structure that maps a key to a value.  In this file\n+   we currently have maps that can map a GCC identifier (a tree) to\n+   some other GCC tree.  This is what the ObjC frontend mostly needs:\n+   being able to look up an identifier into an ObjC data structure.  A\n+   typical usage is mapping ObjC class names (as identifiers) to a\n+   tree representing the class.\n+\n+   This implementation is fast.  :-) */\n+\n+/**\n+ ** Private definitions.\n+ **/\n+\n+/* We include private declaration and definitions that are required to\n+   provide the implementation of inline functions.  You should ignore\n+   these definitions (and the implementation of the inline functions)\n+   as they are not part of the public API and may change.  */\n+typedef unsigned int objc_map_private_hash_t;\n+\n+/* This is used as sentinel.  */\n+#define OBJC_MAP_PRIVATE_EMPTY_SLOT (tree)0\n+\n+struct GTY(()) objc_map_private {\n+  /* Total number of slots.  This is the maximum number of elements\n+     that can be currently stored in the map before resizing.  This is\n+     the number of slots in the C array.  Important: this is\n+     guaranteed to be a power of 2.  When we create (or resize) the\n+     map, we round up the size to the next power of 2.  This allows us\n+     to convert a hash to a position in the hashtable by simply doing\n+     \"position = hash & mask\", where mask is number_of_slots - 1\n+     instead of using a modulo (which requires a division).  */\n+  size_t number_of_slots;\n+\n+  /* This is number_of_slots - 1, precomputed.  */\n+  size_t mask;\n+\n+  /* Number of slots that are not empty (ie, that are active).  We\n+     keep counts using this variable which can easily be checked\n+     against max_number_of_non_empty_slots.  */\n+  size_t number_of_non_empty_slots;\n+\n+  /* This is the load factor limit.  When the number of non empty\n+     slots equals this number, we need to resize the array.  This is\n+     calculated once, when the slots are resized, and then kept cached\n+     so it can be compared quickly when elements are added.  */\n+  size_t max_number_of_non_empty_slots;\n+\n+  /* The maximum load factor.  */\n+  int maximum_load_factor;\n+\n+  /* These are the keys.  */\n+  tree * GTY ((length (\"%h.number_of_slots\"))) slots;\n+\n+  /* These are the values.  values[i] is the the value corresponding\n+     to slots[i].  */\n+  tree * GTY ((length (\"%h.number_of_slots\"))) values;\n+};\n+\n+/* Private functions used to resize the map.  They may be called by\n+   the inline functions when adding elements.  */\n+extern void\n+objc_map_private_grow (struct objc_map_private *map);\n+\n+\n+/**\n+ ** The definition of a map.\n+ **/\n+typedef struct objc_map_private *objc_map_t;\n+\n+\n+/**\n+ ** Creating a map.\n+ **/\n+\n+/* objc_map_alloc_ggc() creates a new map which is under GGC.  The initial\n+   capacity must be specified as an argument; this is used to size the map\n+   when it is created.  */\n+objc_map_t objc_map_alloc_ggc (size_t initial_capacity);\n+\n+/**\n+ ** Performance tuning.\n+ **/\n+\n+/* Set a maximum load factor for the data structure.  This is the main\n+   tuning parameter to improve performance (at the expense of\n+   memory).  */\n+void objc_map_set_maximum_load_factor (objc_map_t map, int number_between_zero_and_one_hundred);\n+\n+/* Read the maximum load factor.  */\n+int objc_map_maximum_load_factor (objc_map_t map);\n+\n+\n+/**\n+ ** Getting the value corresponding to a key.\n+ **/\n+\n+/* This is the value returned by objc_map_get() when the value\n+   corresponding to a key is not found.  */\n+#define OBJC_MAP_NOT_FOUND (tree)1\n+\n+/* objc_map_get() returns the value associated with a certain key,\n+   or OBJC_MAP_NOT_FOUND if there is no value associated with that key.\n+   Note that you can also use it to simply check if the map contains a\n+   pair with a certain key; just compare the result of calling\n+   objc_map_get() to OBJC_MAP_NOT_FOUND.\n+\n+   It is essential to always check the results of the call to make\n+   sure it is not OBJC_MAP_NOT_FOUND.\n+\n+   NULL is a valid value, so a key can be inserted into a map with\n+   value NULL, and objc_map_get() will return NULL in that case.\n+   So a result of NULL means that they key *was* found, and the value\n+   associated with it was NULL.  */\n+static inline tree\n+objc_map_get (objc_map_t map, /* struct tree_identifier * */tree key)\n+{\n+  /* The inline implementation is private and may change without notice.  */\n+  objc_map_private_hash_t hash = IDENTIFIER_HASH_VALUE (key);\n+  size_t i = hash & map->mask;\n+  size_t j = 1;\n+\n+  if (map->slots[i] == OBJC_MAP_PRIVATE_EMPTY_SLOT)\n+    return OBJC_MAP_NOT_FOUND;\n+\n+  if (map->slots[i] == key)\n+    return map->values[i];\n+  \n+  while (1)\n+    {\n+      i = (i + j) & map->mask;\n+      \n+      if (map->slots[i] == OBJC_MAP_PRIVATE_EMPTY_SLOT)\n+\treturn OBJC_MAP_NOT_FOUND;\n+      \n+      if (map->slots[i] == key)\n+\treturn map->values[i];\n+\n+      j++;\n+    }\n+}\n+\n+/* objc_map_put() puts a key/value pair into the map.  If the map does\n+   not contain the key, it is added to it with the specified value.\n+   If the map already contains the key, the previous value is replaced\n+   with the new one.\n+\n+   You can use any identifier as key, with the exception of NULL.\n+\n+   You can use any tree as value, including NULL.  */\n+static inline\n+void objc_map_put (objc_map_t map, /*struct tree_identifier * */tree key, tree value)\n+{\n+  /* The inline implementation is private and may change without notice.  */\n+  objc_map_private_hash_t hash = IDENTIFIER_HASH_VALUE (key);\n+  size_t i, j = 0;\n+\n+  if (map->number_of_non_empty_slots == map->max_number_of_non_empty_slots)\n+    objc_map_private_grow (map);\n+\n+  i = hash & map->mask;\n+    \n+  while (1)\n+    {\n+      if (map->slots[i] == OBJC_MAP_PRIVATE_EMPTY_SLOT)\n+\t{\n+\t  map->number_of_non_empty_slots++;\n+\t  map->slots[i] = key;\n+\t  map->values[i] = value;\n+\t  return;\n+\t}\n+      if (map->slots[i] == key)\n+\t{\n+\t  map->values[i] = value;\n+\t  return;\n+\t}\n+\n+      j++;\n+      i = (i + j) & map->mask;\n+    }\n+}\n+\n+/**\n+ ** Iterating over a map using an iterator.\n+ **/\n+\n+/* When using iterators you can iterate directly on the elements in\n+   the map, and take an action over each one.\n+\n+   Here is how you iterate over a hmap_pointer using iterators:\n+\n+   objc_map_iterator_t i;\n+\n+   objc_map_iterator_initialize (map, &i);\n+\n+   while (objc_map_iterator_move_to_next (map, &i))\n+     {\n+       tree p = objc_map_iterator_current_key (map, i);\n+       tree q = objc_map_iterator_current_value (map, i);\n+\n+       ... do something with p and q ...\n+     }\n+\n+   You'll notice that the functions that modify the iterator (to\n+   initialize it, or move it to the next element) take a pointer to it\n+   as argument (as in \"&i\"), while the functions that only read its\n+   state (to read the current key/value, or remove the current\n+   key/value from the map) take it as a direct argument (as in \"i\").\n+\n+   Note that all the objc_map_iterator_*() functions are inline and if\n+   you follow the pattern above, the compiler should be able to inline\n+   everything into a very efficient loop, roughly equivalent to\n+   hand-writing a C loop that iterates directly onto the hmap_pointer\n+   internal data structures.  */\n+\n+/* A objc_map_iterator_t variable encapsulates the state of an\n+   iteration.  The fact that this is actually a size_t (pointing to\n+   the index of the slot that we return next) is an internal, private\n+   detail of the implementation and may change without notice.  */\n+typedef size_t objc_map_iterator_t;\n+\n+/* Initialize an iterator to iterate over the specified objc_map.  You\n+   must use this before starting the iteration, to get a working\n+   iterator.  */\n+static inline\n+void\n+objc_map_iterator_initialize (objc_map_t map ATTRIBUTE_UNUSED, objc_map_iterator_t *i)\n+{\n+  /* The inline implementation is private and may change without notice.  */\n+  /* This is trivial, but the same API would work to initialize more\n+     complicated iterators.  */\n+  *i = 0;\n+}\n+\n+#define OBJC_MAP_FAILURE 0\n+#define OBJC_MAP_SUCCESS 1\n+\n+/* Move the iterator to the next key/value pair, and return\n+   OBJC_MAP_SUCCESS if there is such a key/value pair, and\n+   OBJC_MAP_FAILURE if there are no more ones.  The iterator must have\n+   been initialized using objc_map_iterator_initialize().  Note that\n+   because this function is modifying the iterator, you need to pass a\n+   pointer to it.  */\n+static inline\n+int\n+objc_map_iterator_move_to_next (objc_map_t map, objc_map_iterator_t *i)\n+{\n+  /* The inline implementation is private and may change without notice.  */\n+  while (1)\n+    {\n+      void *slot;\n+      if (*i == map->number_of_slots)\n+\treturn OBJC_MAP_FAILURE;\n+      \n+      slot = map->slots[*i];\n+      *i = *i + 1;\n+      if (slot != OBJC_MAP_PRIVATE_EMPTY_SLOT)\n+\treturn OBJC_MAP_SUCCESS;\n+    }\n+}\n+\n+/* Return the current key.  You can only call it after you have called\n+   objc_map_iterator_move_to_next() at least once (to move to the\n+   first element), and only if the last call returned\n+   OBJC_MAP_SUCCESS.  The behaviour is otherwise undefined, probably a\n+   segmentation fault.  */\n+static inline\n+tree\n+objc_map_iterator_current_key (objc_map_t map, objc_map_iterator_t i)\n+{\n+  /* The inline implementation is private and may change without notice.  */\n+  return map->slots[i - 1];\n+}\n+\n+/* Return the current value.  You can only call it after you have\n+   called objc_map_iterator_move_to_next() at least once (to move to\n+   the first element), and only if the last call returned\n+   OBJC_MAP_SUCCESS.  The behaviour is otherwise undefined, probably a\n+   segmentation fault.  */\n+static inline\n+tree\n+objc_map_iterator_current_value (objc_map_t map, objc_map_iterator_t i)\n+{\n+  /* The inline implementation is private and may change without notice.  */\n+  return map->values[i - 1];\n+}\n+\n+#endif /* OBJC_MAP_H */"}, {"sha": "4512c846cc0c0e74611ccbe0cdb982e3d594a2b3", "filename": "gcc/objc/objc-next-runtime-abi-02.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -231,6 +231,7 @@ static tree begin_catch (struct objc_try_context **, tree, tree, tree, bool);\n static void finish_catch (struct objc_try_context **, tree);\n static tree finish_try_stmt (struct objc_try_context **);\n \n+/* TODO: Use an objc-map.  */\n static GTY ((length (\"SIZEHASHTABLE\"))) hash *extern_names;\n \n bool"}, {"sha": "bed3b9dcd25e1eb8e8aac74469a73df78bea062d", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -1,3 +1,10 @@\n+2011-10-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* Make-lang.in (OBJCXX_OBJS): Added objc-map.o.\n+\t(objcp/objc-map.o): New rule.\n+\t(objcp/objcp-act.o): Depend on objc/objc-map.h.\n+\t* config-lang.in (gtfiles): Added objc-map.h.\n+\n 2011-07-11  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* Make-lang.in (objcp/objc-runtime-shared-support.o): Do not"}, {"sha": "4255bd6390980ab60fe7fe5474b139a1ac5277f1", "filename": "gcc/objcp/Make-lang.in", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FMake-lang.in?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -58,6 +58,7 @@ OBJCXX_OBJS = objcp/objcp-act.o objcp/objcp-lang.o objcp/objcp-decl.o \\\n    objcp/objc-next-runtime-abi-01.o \\\n    objcp/objc-next-runtime-abi-02.o \\\n    objcp/objc-encoding.o \\\n+   objcp/objc-map.o \\\n    $(CXX_AND_OBJCXX_OBJS)\n \n obj-c++_OBJS = $(OBJCXX_OBJS) cc1objplus-checksum.o\n@@ -149,6 +150,7 @@ objcp/objcp-act.o : objc/objc-act.c \\\n    $(RTL_H) $(EXPR_H) $(TARGET_H) \\\n    objcp/objcp-decl.h \\\n    objc/objc-encoding.h \\\n+   objc/objc-map.h \\\n    objc/objc-runtime-hooks.h \\\n    objc/objc-runtime-shared-support.h \\\n    objcp/objcp-decl.h\n@@ -165,6 +167,14 @@ objcp/objc-encoding.o : objc/objc-encoding.c \\\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n \t\t$(OUTPUT_OPTION)\n \n+objcp/objc-map.o : objc/objc-map.c \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   objc/objc-map.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n+\t\t$(OUTPUT_OPTION)\n+\n po-generated:\n \n #\f"}, {"sha": "5fd0f06b33b214b741d8b3fd4c3aba80d48b395b", "filename": "gcc/objcp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184/gcc%2Fobjcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fconfig-lang.in?ref=3cc2dd4b7eb3d60c24b9cebecb9cd3fb1ab94184", "patch": "@@ -46,5 +46,5 @@ subdir_requires=\"objc cp\"\n # This list is separated in two parts: the first one is identical to\n # the C++ one, the second one contains our ObjC++ additions.\n gtfiles=\"\\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.h \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-lex.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/cp/class.c \\$(srcdir)/cp/cp-objcp-common.c \\\n-\\$(srcdir)/objc/objc-act.h \\$(srcdir)/objc/objc-act.c \\$(srcdir)/objc/objc-runtime-shared-support.c \\$(srcdir)/objc/objc-gnu-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-02.c \\$(srcdir)/c-family/c-cppbuiltin.c\"\n+\\$(srcdir)/objc/objc-map.h \\$(srcdir)/objc/objc-act.h \\$(srcdir)/objc/objc-act.c \\$(srcdir)/objc/objc-runtime-shared-support.c \\$(srcdir)/objc/objc-gnu-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-02.c \\$(srcdir)/c-family/c-cppbuiltin.c\"\n "}]}