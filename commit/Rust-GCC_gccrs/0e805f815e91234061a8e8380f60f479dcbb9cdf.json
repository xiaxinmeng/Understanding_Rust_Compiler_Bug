{"sha": "0e805f815e91234061a8e8380f60f479dcbb9cdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU4MDVmODE1ZTkxMjM0MDYxYThlODM4MGY2MGY0NzlkY2JiOWNkZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-03-30T21:46:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-03-30T21:46:37Z"}, "message": "expmed.c (store_bit_field, [...]): Fix more cases of alignment in bytes.\n\n\t* expmed.c (store_bit_field, store_fixed_bit_field): Fix more\n\tcases of alignment in bytes.\n\nFrom-SVN: r32836", "tree": {"sha": "a30a72bbc901febaf9e2f6c49c52aef3000534ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a30a72bbc901febaf9e2f6c49c52aef3000534ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e805f815e91234061a8e8380f60f479dcbb9cdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e805f815e91234061a8e8380f60f479dcbb9cdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e805f815e91234061a8e8380f60f479dcbb9cdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e805f815e91234061a8e8380f60f479dcbb9cdf/comments", "author": null, "committer": null, "parents": [{"sha": "744bfbfa782d95bec20b3e109bde6ee109588f1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/744bfbfa782d95bec20b3e109bde6ee109588f1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/744bfbfa782d95bec20b3e109bde6ee109588f1a"}], "stats": {"total": 28, "additions": 16, "deletions": 12}, "files": [{"sha": "eae11d49a74b0d76f5b7db226da5ef82f85eff57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e805f815e91234061a8e8380f60f479dcbb9cdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e805f815e91234061a8e8380f60f479dcbb9cdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e805f815e91234061a8e8380f60f479dcbb9cdf", "patch": "@@ -1,3 +1,8 @@\n+Thu Mar 30 06:32:51 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expmed.c (store_bit_field, store_fixed_bit_field): Fix more\n+\tcases of alignment in bytes.\n+\n Thu Mar 30 13:30:40 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* function.c (expand_function_end): Pass alignment argument to"}, {"sha": "4194f2b182e89eb713f3bcd783ec0a8966ef94a4", "filename": "gcc/expmed.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e805f815e91234061a8e8380f60f479dcbb9cdf/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e805f815e91234061a8e8380f60f479dcbb9cdf/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0e805f815e91234061a8e8380f60f479dcbb9cdf", "patch": "@@ -217,7 +217,7 @@ negate_rtx (mode, x)\n    into a bit-field within structure STR_RTX\n    containing BITSIZE bits starting at bit BITNUM.\n    FIELDMODE is the machine-mode of the FIELD_DECL node for this field.\n-   ALIGN is the alignment that STR_RTX is known to have, measured in bytes.\n+   ALIGN is the alignment that STR_RTX is known to have.\n    TOTAL_SIZE is the size of the structure in bytes, or -1 if varying.  */\n \n /* ??? Note that there are two different ideas here for how\n@@ -309,7 +309,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       && (GET_CODE (op0) != MEM\n \t  || ! SLOW_UNALIGNED_ACCESS (fieldmode, align)\n \t  || (offset * BITS_PER_UNIT % bitsize == 0\n-\t      && align % GET_MODE_SIZE (fieldmode) == 0))\n+\t      && align % GET_MODE_BITSIZE (fieldmode) == 0))\n       && (BYTES_BIG_ENDIAN ? bitpos + bitsize == unit : bitpos == 0)\n       && bitsize == GET_MODE_BITSIZE (fieldmode))\n     {\n@@ -515,14 +515,14 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t  if (GET_MODE (op0) == BLKmode\n \t      || GET_MODE_SIZE (GET_MODE (op0)) > GET_MODE_SIZE (maxmode))\n \t    bestmode\n-\t      = get_best_mode (bitsize, bitnum, align * BITS_PER_UNIT, maxmode,\n+\t      = get_best_mode (bitsize, bitnum, align, maxmode,\n \t\t\t       MEM_VOLATILE_P (op0));\n \t  else\n \t    bestmode = GET_MODE (op0);\n \n \t  if (bestmode == VOIDmode\n \t      || (SLOW_UNALIGNED_ACCESS (bestmode, align)\n-\t\t  && GET_MODE_SIZE (bestmode) > align))\n+\t\t  && GET_MODE_BITSIZE (bestmode) > align))\n \t    goto insv_loses;\n \n \t  /* Adjust address to point to the containing unit of that mode.  */\n@@ -533,7 +533,8 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t  op0 = change_address (op0, bestmode, \n \t\t\t\tplus_constant (XEXP (op0, 0), offset));\n \n-\t  /* Fetch that unit, store the bitfield in it, then store the unit.  */\n+\t  /* Fetch that unit, store the bitfield in it, then store\n+\t     the unit.  */\n \t  tempreg = copy_to_reg (op0);\n \t  store_bit_field (tempreg, bitsize, bitpos, fieldmode, value,\n \t\t\t   align, total_size);\n@@ -628,7 +629,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n     (If OP0 is a register, it may be a full word or a narrower mode,\n      but BITPOS still counts within a full word,\n      which is significant on bigendian machines.)\n-   STRUCT_ALIGN is the alignment the structure is known to have (in bytes).\n+   STRUCT_ALIGN is the alignment the structure is known to have.\n \n    Note that protect_from_queue has already been done on OP0 and VALUE.  */\n \n@@ -798,7 +799,7 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n    BITSIZE is the field width; BITPOS the position of its first bit\n    (within the word).\n    VALUE is the value to store.\n-   ALIGN is the known alignment of OP0, measured in bytes.\n+   ALIGN is the known alignment of OP0.\n    This is also the size of the memory objects to be used.\n \n    This does not yet handle fields wider than BITS_PER_WORD.  */\n@@ -818,7 +819,7 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n   if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n     unit = BITS_PER_WORD;\n   else\n-    unit = MIN (align * BITS_PER_UNIT, BITS_PER_WORD);\n+    unit = MIN (align, BITS_PER_WORD);\n \n   /* If VALUE is a constant other than a CONST_INT, get it into a register in\n      WORD_MODE.  If we can do this using gen_lowpart_common, do so.  Note\n@@ -885,8 +886,7 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n \t\t GET_MODE (value) == VOIDmode\n \t\t ? UNITS_PER_WORD\n \t\t : (GET_MODE (value) == BLKmode\n-\t\t    ? 1\n-\t\t    : GET_MODE_ALIGNMENT (GET_MODE (value)) / BITS_PER_UNIT));\n+\t\t    ? 1 : GET_MODE_ALIGNMENT (GET_MODE (value))));\n \t}\n       else\n \t{\n@@ -902,8 +902,7 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n \t\t GET_MODE (value) == VOIDmode\n \t\t ? UNITS_PER_WORD\n \t\t : (GET_MODE (value) == BLKmode\n-\t\t    ? 1\n-\t\t    : GET_MODE_ALIGNMENT (GET_MODE (value)) / BITS_PER_UNIT));\n+\t\t    ? 1 : GET_MODE_ALIGNMENT (GET_MODE (value))));\n \t}\n \n       /* If OP0 is a register, then handle OFFSET here."}]}