{"sha": "fd312e903f8427204fd73fe574bfb18b28005825", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQzMTJlOTAzZjg0MjcyMDRmZDczZmU1NzRiZmIxOGIyODAwNTgyNQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-09-15T01:28:10Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-09-15T01:28:10Z"}, "message": "re PR tree-optimization/23835 (-O3 compile takes two times longer)\n\n2005-09-14  Daniel Berlin  <dberlin@dberlin.org>\n\n\tPR tree-optimization/23835\n\t* tree-ssa-alias.c (sort_pointers_by_pt_vars): New function.\n\t(create_name_tags): Rewrite to be not O(num_ssa_names^2).\n\nFrom-SVN: r104296", "tree": {"sha": "a3ecd11f2fdf9fcbb09d7863b6ddeb4031d10cd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3ecd11f2fdf9fcbb09d7863b6ddeb4031d10cd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd312e903f8427204fd73fe574bfb18b28005825", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd312e903f8427204fd73fe574bfb18b28005825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd312e903f8427204fd73fe574bfb18b28005825", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd312e903f8427204fd73fe574bfb18b28005825/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0d676b85ae437226df3e9704072153bde2328ed9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d676b85ae437226df3e9704072153bde2328ed9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d676b85ae437226df3e9704072153bde2328ed9"}], "stats": {"total": 121, "additions": 66, "deletions": 55}, "files": [{"sha": "b424f3068af0edc9ac807ef387d438245e12a524", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd312e903f8427204fd73fe574bfb18b28005825/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd312e903f8427204fd73fe574bfb18b28005825/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd312e903f8427204fd73fe574bfb18b28005825", "patch": "@@ -1,3 +1,9 @@\n+2005-09-14  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tPR tree-optimization/23835\n+\t* tree-ssa-alias.c (sort_pointers_by_pt_vars): New function.\n+\t(create_name_tags): Rewrite to be not O(num_ssa_names^2).\n+\n 2005-09-14  Richard Henderson  <rth@redhat.com>\n \n \t* config/ia64/vect.md (addv2sf3, subv2sf3): Rewrite as expand."}, {"sha": "30c1e9d990d5b3e96ff2719a50cfe3816187abec", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 60, "deletions": 55, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd312e903f8427204fd73fe574bfb18b28005825/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd312e903f8427204fd73fe574bfb18b28005825/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=fd312e903f8427204fd73fe574bfb18b28005825", "patch": "@@ -568,7 +568,6 @@ delete_alias_info (struct alias_info *ai)\n   delete_points_to_sets ();\n }\n \n-\n /* Create name tags for all the pointers that have been dereferenced.\n    We only create a name tag for a pointer P if P is found to point to\n    a set of variables (so that we can alias them to *P) or if it is\n@@ -582,7 +581,10 @@ static void\n create_name_tags (void)\n {\n   size_t i;\n+  VEC (tree, heap) *with_ptvars = NULL;\n+  tree ptr;\n \n+  /* Collect the list of pointers with a non-empty points to set.  */\n   for (i = 1; i < num_ssa_names; i++)\n     {\n       tree ptr = ssa_name (i);\n@@ -603,68 +605,71 @@ create_name_tags (void)\n \t  continue;\n \t}\n \n-      if (pi->pt_vars && !bitmap_empty_p (pi->pt_vars))\n+      /* Set pt_anything on the pointers without pt_vars filled in so\n+\t that they are assigned a type tag.  */\n+      \n+      if (pi->pt_vars && !bitmap_empty_p (pi->pt_vars))\t\n+\tVEC_safe_push (tree, heap, with_ptvars, ptr);\n+      else\n+\tset_pt_anything (ptr);\n+    }\n+  \n+  /* If we didn't find any pointers with pt_vars set, we're done.  */\n+  if (!with_ptvars)\n+    return;\n+\n+  /* Now go through the pointers with pt_vars, and find a name tag\n+     with the same pt_vars as this pointer, or create one if one\n+     doesn't exist.  */\n+  for (i = 0; VEC_iterate (tree, with_ptvars, i, ptr); i++)\n+    {\n+      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+      size_t j;\n+      tree ptr2;\n+      tree old_name_tag = pi->name_mem_tag;\n+      \n+      /* If PTR points to a set of variables, check if we don't\n+\t have another pointer Q with the same points-to set before\n+\t creating a tag.  If so, use Q's tag instead of creating a\n+\t new one.\n+\t \n+\t This is important for not creating unnecessary symbols\n+\t and also for copy propagation.  If we ever need to\n+\t propagate PTR into Q or vice-versa, we would run into\n+\t problems if they both had different name tags because\n+\t they would have different SSA version numbers (which\n+\t would force us to take the name tags in and out of SSA).  */\n+      for (j = 0; j < i && VEC_iterate (tree, with_ptvars, j, ptr2); j++)\n \t{\n-\t  size_t j;\n-\t  tree old_name_tag = pi->name_mem_tag;\n-\n-\t  /* If PTR points to a set of variables, check if we don't\n-\t     have another pointer Q with the same points-to set before\n-\t     creating a tag.  If so, use Q's tag instead of creating a\n-\t     new one.\n-\n-\t     This is important for not creating unnecessary symbols\n-\t     and also for copy propagation.  If we ever need to\n-\t     propagate PTR into Q or vice-versa, we would run into\n-\t     problems if they both had different name tags because\n-\t     they would have different SSA version numbers (which\n-\t     would force us to take the name tags in and out of SSA).  */\n-\t  for (j = 1; j < i; j++)\n+\t  struct ptr_info_def *qi = SSA_NAME_PTR_INFO (ptr2);\n+\t  \n+\t  if (bitmap_equal_p (pi->pt_vars, qi->pt_vars))\n \t    {\n-\t      tree q = ssa_name (j);\n-\t      struct ptr_info_def *qi;\n-\n-\t      if (!q || !POINTER_TYPE_P (TREE_TYPE (q)))\n-\t\tcontinue;\n-\n-\t      qi = SSA_NAME_PTR_INFO (q);\n-\n-\t      if (qi\n-\t\t  && qi->pt_vars\n-\t\t  && qi->name_mem_tag\n-\t\t  && bitmap_equal_p (pi->pt_vars, qi->pt_vars))\n-\t\t{\n-\t\t  pi->name_mem_tag = qi->name_mem_tag;\n-\t\t  break;\n-\t\t}\n+\t      pi->name_mem_tag = qi->name_mem_tag;\n+\t      break;\n \t    }\n-\n-\t  /* If we didn't find a pointer with the same points-to set\n-\t     as PTR, create a new name tag if needed.  */\n-\t  if (pi->name_mem_tag == NULL_TREE)\n-\t    pi->name_mem_tag = get_nmt_for (ptr);\n-\n-\t  /* If the new name tag computed for PTR is different than\n-\t     the old name tag that it used to have, then the old tag\n-\t     needs to be removed from the IL, so we mark it for\n-\t     renaming.  */\n-\t  if (old_name_tag && old_name_tag != pi->name_mem_tag)\n-\t    mark_sym_for_renaming (old_name_tag);\n-\t}\n-      else\n-\t{\n-\t  /* If the pointer does not point to a known spot, we should\n-\t     use type tags.  */\n-\t  set_pt_anything (ptr);\n-\t  continue;\n \t}\n-\n+      \n+      /* If we didn't find a pointer with the same points-to set\n+\t as PTR, create a new name tag if needed.  */\n+      if (pi->name_mem_tag == NULL_TREE)\n+\tpi->name_mem_tag = get_nmt_for (ptr);\n+      \n+      /* If the new name tag computed for PTR is different than\n+\t the old name tag that it used to have, then the old tag\n+\t needs to be removed from the IL, so we mark it for\n+\t renaming.  */\n+      if (old_name_tag && old_name_tag != pi->name_mem_tag)\n+\tmark_sym_for_renaming (old_name_tag);\n+      \n       TREE_THIS_VOLATILE (pi->name_mem_tag)\n-\t  |= TREE_THIS_VOLATILE (TREE_TYPE (TREE_TYPE (ptr)));\n-\n+\t|= TREE_THIS_VOLATILE (TREE_TYPE (TREE_TYPE (ptr)));\n+      \n       /* Mark the new name tag for renaming.  */\n       mark_sym_for_renaming (pi->name_mem_tag);\n     }\n+\n+  VEC_free (tree, heap, with_ptvars);\n }\n \n "}]}