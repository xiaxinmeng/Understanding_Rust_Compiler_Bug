{"sha": "924af605fe5f1e5cfac29d369c3fa50b7bd603dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI0YWY2MDVmZTVmMWU1Y2ZhYzI5ZDM2OWMzZmE1MGI3YmQ2MDNkZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-11-10T23:11:21Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-11-10T23:11:21Z"}, "message": "GridLayout.java (layoutContainer): Use tree lock.\n\n\t* java/awt/GridLayout.java (layoutContainer): Use tree lock.\n\t(getSize): Likewise.\n\t* java/awt/FlowLayout.java (layoutContainer): Use tree lock.\n\t(getSize): Likewise.\n\t* java/awt/BorderLayout.java (layoutContainer): Use tree lock.\n\t(calcSize): Likewise.\n\t* java/awt/CardLayout.java (getSize): Use tree lock.\n\t(gotoComponent): Likewise.\n\t(layoutContainer): Likewise.\n\nFrom-SVN: r58998", "tree": {"sha": "d386206ae8dd27800faed535df9f14d9a0aecaee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d386206ae8dd27800faed535df9f14d9a0aecaee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/924af605fe5f1e5cfac29d369c3fa50b7bd603dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/924af605fe5f1e5cfac29d369c3fa50b7bd603dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/924af605fe5f1e5cfac29d369c3fa50b7bd603dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/924af605fe5f1e5cfac29d369c3fa50b7bd603dd/comments", "author": null, "committer": null, "parents": [{"sha": "a6b5bd3b6bae362a975ac28a00c0b9fe01c3ebf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6b5bd3b6bae362a975ac28a00c0b9fe01c3ebf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6b5bd3b6bae362a975ac28a00c0b9fe01c3ebf8"}], "stats": {"total": 745, "additions": 391, "deletions": 354}, "files": [{"sha": "1cb7ddeba893a0d6f23b2d53bfbc6e99beaeab80", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/924af605fe5f1e5cfac29d369c3fa50b7bd603dd/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/924af605fe5f1e5cfac29d369c3fa50b7bd603dd/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=924af605fe5f1e5cfac29d369c3fa50b7bd603dd", "patch": "@@ -1,5 +1,15 @@\n 2002-11-10  Tom Tromey  <tromey@redhat.com>\n \n+\t* java/awt/GridLayout.java (layoutContainer): Use tree lock.\n+\t(getSize): Likewise.\n+\t* java/awt/FlowLayout.java (layoutContainer): Use tree lock.\n+\t(getSize): Likewise.\n+\t* java/awt/BorderLayout.java (layoutContainer): Use tree lock.\n+\t(calcSize): Likewise.\n+\t* java/awt/CardLayout.java (getSize): Use tree lock.\n+\t(gotoComponent): Likewise.\n+\t(layoutContainer): Likewise.\n+\n \t* java/io/natFileDescriptorWin32.cc (read): Handle case where\n \tcount is 0.\n \t* java/io/natFileDescriptorPosix.cc (read): Handle case where"}, {"sha": "930773f0142a497bf476178ece6cec7e9a20645f", "filename": "libjava/java/awt/BorderLayout.java", "status": "modified", "additions": 125, "deletions": 119, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/924af605fe5f1e5cfac29d369c3fa50b7bd603dd/libjava%2Fjava%2Fawt%2FBorderLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/924af605fe5f1e5cfac29d369c3fa50b7bd603dd/libjava%2Fjava%2Fawt%2FBorderLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FBorderLayout.java?ref=924af605fe5f1e5cfac29d369c3fa50b7bd603dd", "patch": "@@ -529,80 +529,83 @@ else if (str.equals(AFTER_LINE_ENDS))\n public void\n layoutContainer(Container target)\n {\n-  Insets i = target.getInsets();\n-\n-  ComponentOrientation orient = target.getComponentOrientation ();\n-  boolean left_to_right = orient.isLeftToRight ();\n-\n-  Component my_north = north;\n-  Component my_east = east;\n-  Component my_south = south;\n-  Component my_west = west;\n-\n-  // Note that we currently don't handle vertical layouts.  Neither\n-  // does JDK 1.3.\n-  if (firstLine != null)\n-    my_north = firstLine;\n-  if (lastLine != null)\n-    my_south = lastLine;\n-  if (firstItem != null)\n+  synchronized (target.getTreeLock ())\n     {\n-      if (left_to_right)\n-\tmy_west = firstItem;\n-      else\n-\tmy_east = firstItem;\n+      Insets i = target.getInsets();\n+\n+      ComponentOrientation orient = target.getComponentOrientation ();\n+      boolean left_to_right = orient.isLeftToRight ();\n+\n+      Component my_north = north;\n+      Component my_east = east;\n+      Component my_south = south;\n+      Component my_west = west;\n+\n+      // Note that we currently don't handle vertical layouts.  Neither\n+      // does JDK 1.3.\n+      if (firstLine != null)\n+\tmy_north = firstLine;\n+      if (lastLine != null)\n+\tmy_south = lastLine;\n+      if (firstItem != null)\n+\t{\n+\t  if (left_to_right)\n+\t    my_west = firstItem;\n+\t  else\n+\t    my_east = firstItem;\n+\t}\n+      if (lastItem != null)\n+\t{\n+\t  if (left_to_right)\n+\t    my_east = lastItem;\n+\t  else\n+\t    my_west = lastItem;\n+\t}\n+\n+      Dimension c = calcCompSize(center, PREF);\n+      Dimension n = calcCompSize(my_north, PREF);\n+      Dimension s = calcCompSize(my_south, PREF);\n+      Dimension e = calcCompSize(my_east, PREF);\n+      Dimension w = calcCompSize(my_west, PREF);\n+      Dimension t = target.getSize();\n+\n+      /*\n+\t<-> hgap     <-> hgap\n+\t+----------------------------+          }\n+\t|t                           |          } i.top\n+\t|  +----------------------+  |  --- y1  }\n+\t|  |n                     |  |\n+\t|  +----------------------+  |          } vgap\n+\t|  +---+ +----------+ +---+  |  --- y2  }        }\n+\t|  |w  | |c         | |e  |  |                   } hh\n+\t|  +---+ +----------+ +---+  |          } vgap   }\n+\t|  +----------------------+  |  --- y3  }\n+\t|  |s                     |  |\n+\t|  +----------------------+  |          }\n+\t|                            |          } i.bottom\n+\t+----------------------------+          }\n+\t|x1   |x2          |x3\n+\t<---------------------->\n+\t<-->         ww           <-->\n+\ti.left                    i.right\n+      */\n+\n+      int x1 = i.left;\n+      int x2 = x1 + w.width + hgap;\n+      int x3 = t.width - i.right - e.width;\n+      int ww = t.width - i.right - i.left;\n+\n+      int y1 = i.top;\n+      int y2 = y1 + n.height + vgap;\n+      int y3 = t.height - i.bottom - s.height;\n+      int hh = y3-y2-vgap;\n+\n+      setBounds(center, x2, y2, x3-x2-hgap, hh);\n+      setBounds(my_north, x1, y1, ww, n.height);\n+      setBounds(my_south, x1, y3, ww, s.height);\n+      setBounds(my_west, x1, y2, w.width, hh);\n+      setBounds(my_east, x3, y2, e.width, hh);\n     }\n-  if (lastItem != null)\n-    {\n-      if (left_to_right)\n-\tmy_east = lastItem;\n-      else\n-\tmy_west = lastItem;\n-    }\n-\n-  Dimension c = calcCompSize(center, PREF);\n-  Dimension n = calcCompSize(my_north, PREF);\n-  Dimension s = calcCompSize(my_south, PREF);\n-  Dimension e = calcCompSize(my_east, PREF);\n-  Dimension w = calcCompSize(my_west, PREF);\n-  Dimension t = target.getSize();\n-\n-    /*\n-             <-> hgap     <-> hgap\n-      +----------------------------+          }\n-      |t                           |          } i.top\n-      |  +----------------------+  |  --- y1  }\n-      |  |n                     |  |\n-      |  +----------------------+  |          } vgap\n-      |  +---+ +----------+ +---+  |  --- y2  }        }\n-      |  |w  | |c         | |e  |  |                   } hh\n-      |  +---+ +----------+ +---+  |          } vgap   }\n-      |  +----------------------+  |  --- y3  }\n-      |  |s                     |  |\n-      |  +----------------------+  |          }\n-      |                            |          } i.bottom\n-      +----------------------------+          }\n-         |x1   |x2          |x3\n-         <---------------------->\n-      <-->         ww           <-->\n-     i.left                    i.right\n-    */\n-\n-  int x1 = i.left;\n-  int x2 = x1 + w.width + hgap;\n-  int x3 = t.width - i.right - e.width;\n-  int ww = t.width - i.right - i.left;\n-\n-  int y1 = i.top;\n-  int y2 = y1 + n.height + vgap;\n-  int y3 = t.height - i.bottom - s.height;\n-  int hh = y3-y2-vgap;\n-\n-  setBounds(center, x2, y2, x3-x2-hgap, hh);\n-  setBounds(my_north, x1, y1, ww, n.height);\n-  setBounds(my_south, x1, y3, ww, s.height);\n-  setBounds(my_west, x1, y2, w.width, hh);\n-  setBounds(my_east, x3, y2, e.width, hh);\n }\n \n /*************************************************************************/\n@@ -648,59 +651,62 @@ else if (what == MAX)\n private Dimension\n calcSize(Container target, int what)\n {\n-  Insets ins = target.getInsets();\n-\n-  ComponentOrientation orient = target.getComponentOrientation ();\n-  boolean left_to_right = orient.isLeftToRight ();\n-\n-  Component my_north = north;\n-  Component my_east = east;\n-  Component my_south = south;\n-  Component my_west = west;\n-\n-  // Note that we currently don't handle vertical layouts.  Neither\n-  // does JDK 1.3.\n-  if (firstLine != null)\n-    my_north = firstLine;\n-  if (lastLine != null)\n-    my_south = lastLine;\n-  if (firstItem != null)\n+  synchronized (target.getTreeLock ())\n     {\n-      if (left_to_right)\n-\tmy_west = firstItem;\n-      else\n-\tmy_east = firstItem;\n-    }\n-  if (lastItem != null)\n-    {\n-      if (left_to_right)\n-\tmy_east = lastItem;\n-      else\n-\tmy_west = lastItem;\n-    }\n+      Insets ins = target.getInsets();\n+\n+      ComponentOrientation orient = target.getComponentOrientation ();\n+      boolean left_to_right = orient.isLeftToRight ();\n+\n+      Component my_north = north;\n+      Component my_east = east;\n+      Component my_south = south;\n+      Component my_west = west;\n+\n+      // Note that we currently don't handle vertical layouts.  Neither\n+      // does JDK 1.3.\n+      if (firstLine != null)\n+\tmy_north = firstLine;\n+      if (lastLine != null)\n+\tmy_south = lastLine;\n+      if (firstItem != null)\n+\t{\n+\t  if (left_to_right)\n+\t    my_west = firstItem;\n+\t  else\n+\t    my_east = firstItem;\n+\t}\n+      if (lastItem != null)\n+\t{\n+\t  if (left_to_right)\n+\t    my_east = lastItem;\n+\t  else\n+\t    my_west = lastItem;\n+\t}\n       \n-  Dimension ndim = calcCompSize(my_north, what);\n-  Dimension sdim = calcCompSize(my_south, what);\n-  Dimension edim = calcCompSize(my_east, what);\n-  Dimension wdim = calcCompSize(my_west, what);\n-  Dimension cdim = calcCompSize(center, what);\n+      Dimension ndim = calcCompSize(my_north, what);\n+      Dimension sdim = calcCompSize(my_south, what);\n+      Dimension edim = calcCompSize(my_east, what);\n+      Dimension wdim = calcCompSize(my_west, what);\n+      Dimension cdim = calcCompSize(center, what);\n \n-  int width = edim.width + cdim.width + wdim.width + (hgap * 2);\n-  if (ndim.width > width)\n-    width = ndim.width;\n-  if (sdim.width > width)\n-    width = sdim.width;\n+      int width = edim.width + cdim.width + wdim.width + (hgap * 2);\n+      if (ndim.width > width)\n+\twidth = ndim.width;\n+      if (sdim.width > width)\n+\twidth = sdim.width;\n \n-  width += (ins.left + ins.right);\n+      width += (ins.left + ins.right);\n \n-  int height = edim.height;\n-  if (cdim.height > height)\n-    height = cdim.height;\n-  if (wdim.height > height)\n-    height = wdim.height;\n+      int height = edim.height;\n+      if (cdim.height > height)\n+\theight = cdim.height;\n+      if (wdim.height > height)\n+\theight = wdim.height;\n \n-  height += (ndim.height + sdim.height + (vgap * 2) + ins.top + ins.bottom);\n+      height += (ndim.height + sdim.height + (vgap * 2) + ins.top + ins.bottom);\n \n-  return(new Dimension(width, height));\n+      return(new Dimension(width, height));\n+    }\n }\n } // class BorderLayout "}, {"sha": "10ffa2ec6c2935255cd6af13732a8ca01862ae5b", "filename": "libjava/java/awt/CardLayout.java", "status": "modified", "additions": 86, "deletions": 77, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/924af605fe5f1e5cfac29d369c3fa50b7bd603dd/libjava%2Fjava%2Fawt%2FCardLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/924af605fe5f1e5cfac29d369c3fa50b7bd603dd/libjava%2Fjava%2Fawt%2FCardLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FCardLayout.java?ref=924af605fe5f1e5cfac29d369c3fa50b7bd603dd", "patch": "@@ -165,21 +165,24 @@ public void last (Container parent)\n    */ \n   public void layoutContainer (Container parent)\n   {\n-    int width = parent.width;\n-    int height = parent.height;\n+    synchronized (parent.getTreeLock ())\n+      {\n+\tint width = parent.width;\n+\tint height = parent.height;\n \n-    Insets ins = parent.getInsets ();\n+\tInsets ins = parent.getInsets ();\n \n-    int num = parent.ncomponents;\n-    Component[] comps = parent.component;\n+\tint num = parent.ncomponents;\n+\tComponent[] comps = parent.component;\n \n-    int x = ins.left + hgap;\n-    int y = ins.top + vgap;\n-    width = width - 2 * hgap - ins.left - ins.right;\n-    height = height - 2 * vgap - ins.top - ins.bottom;\n+\tint x = ins.left + hgap;\n+\tint y = ins.top + vgap;\n+\twidth = width - 2 * hgap - ins.left - ins.right;\n+\theight = height - 2 * vgap - ins.top - ins.bottom;\n \n-    for (int i = 0; i < num; ++i)\n-      comps[i].setBounds (x, y, width, height);\n+\tfor (int i = 0; i < num; ++i)\n+\t  comps[i].setBounds (x, y, width, height);\n+      }\n   }\n \n   /** Get the maximum layout size of the container.\n@@ -287,91 +290,97 @@ public String toString ()\n   private void gotoComponent (Container parent, int what,\n \t\t\t      Component target)\n   {\n-    int num = parent.ncomponents;\n-    // This is more efficient than calling getComponents().\n-    Component[] comps = parent.component;\n-    int choice = -1;\n-\n-    if (what == FIRST)\n-      choice = 0;\n-    else if (what == LAST)\n-      choice = num - 1;\n-    else if (what >= 0)\n-      choice = what;\n-\n-    for (int i = 0; i < num; ++i)\n+    synchronized (parent.getTreeLock ())\n       {\n-\t// If TARGET is set then we are looking for a specific\n-\t// component.\n-\tif (target != null)\n-\t  {\n-\t    if (target == comps[i])\n-\t      choice = i;\n-\t  }\n-\n-\tif (comps[i].isVisible ())\n+\tint num = parent.ncomponents;\n+\t// This is more efficient than calling getComponents().\n+\tComponent[] comps = parent.component;\n+\tint choice = -1;\n+\n+\tif (what == FIRST)\n+\t  choice = 0;\n+\telse if (what == LAST)\n+\t  choice = num - 1;\n+\telse if (what >= 0)\n+\t  choice = what;\n+\n+\tfor (int i = 0; i < num; ++i)\n \t  {\n-\t    if (what == NEXT)\n+\t    // If TARGET is set then we are looking for a specific\n+\t    // component.\n+\t    if (target != null)\n \t      {\n-\t\tchoice = i + 1;\n-\t\tif (choice == num)\n-\t\t  choice = 0;\n+\t\tif (target == comps[i])\n+\t\t  choice = i;\n \t      }\n-\t    else if (what == PREV)\n-\t      {\n-\t\tchoice = i - 1;\n-\t\tif (choice < 0)\n-\t\t  choice = num - 1;\n-\t      }\n-\t    else if (choice == i)\n+\n+\t    if (comps[i].isVisible ())\n \t      {\n-\t\t// Do nothing if we're already looking at the right\n-\t\t// component.\n-\t\treturn;\n+\t\tif (what == NEXT)\n+\t\t  {\n+\t\t    choice = i + 1;\n+\t\t    if (choice == num)\n+\t\t      choice = 0;\n+\t\t  }\n+\t\telse if (what == PREV)\n+\t\t  {\n+\t\t    choice = i - 1;\n+\t\t    if (choice < 0)\n+\t\t      choice = num - 1;\n+\t\t  }\n+\t\telse if (choice == i)\n+\t\t  {\n+\t\t    // Do nothing if we're already looking at the right\n+\t\t    // component.\n+\t\t    return;\n+\t\t  }\n+\t\tcomps[i].setVisible (false);\n+\n+\t\tif (choice >= 0)\n+\t\t  break;\n \t      }\n-\t    comps[i].setVisible (false);\n-\n-\t    if (choice >= 0)\n-\t      break;\n \t  }\n-      }\n \n-    if (choice >= 0 && choice < num)\n-      comps[choice].setVisible (true);\n+\tif (choice >= 0 && choice < num)\n+\t  comps[choice].setVisible (true);\n+      }\n   }\n \n   // Compute the size according to WHAT.\n   private Dimension getSize (Container parent, int what)\n   {\n-    int w = 0, h = 0, num = parent.ncomponents;\n-    Component[] comps = parent.component;\n-\n-    for (int i = 0; i < num; ++i)\n+    synchronized (parent.getTreeLock ())\n       {\n-\tDimension d;\n+\tint w = 0, h = 0, num = parent.ncomponents;\n+\tComponent[] comps = parent.component;\n+\n+\tfor (int i = 0; i < num; ++i)\n+\t  {\n+\t    Dimension d;\n \n-\tif (what == MIN)\n-\t  d = comps[i].getMinimumSize ();\n-\telse if (what == MAX)\n-\t  d = comps[i].getMaximumSize ();\n-\telse\n-\t  d = comps[i].getPreferredSize ();\n+\t    if (what == MIN)\n+\t      d = comps[i].getMinimumSize ();\n+\t    else if (what == MAX)\n+\t      d = comps[i].getMaximumSize ();\n+\t    else\n+\t      d = comps[i].getPreferredSize ();\n \n-\tw = Math.max (d.width, w);\n-\th = Math.max (d.height, h);\n-      }\n+\t    w = Math.max (d.width, w);\n+\t    h = Math.max (d.height, h);\n+\t  }\n \n-    Insets i = parent.getInsets ();\n-    w += 2 * hgap + i.right + i.left;\n-    h += 2 * vgap + i.bottom + i.top;\n+\tInsets i = parent.getInsets ();\n+\tw += 2 * hgap + i.right + i.left;\n+\th += 2 * vgap + i.bottom + i.top;\n \n-    // Handle overflow.\n-    if (w < 0)\n-      w = Integer.MAX_VALUE;\n-    if (h < 0)\n-      h = Integer.MAX_VALUE;\n+\t// Handle overflow.\n+\tif (w < 0)\n+\t  w = Integer.MAX_VALUE;\n+\tif (h < 0)\n+\t  h = Integer.MAX_VALUE;\n \n-    return new Dimension (w, h);\n+\treturn new Dimension (w, h);\n+      }\n   }\n \n   /**"}, {"sha": "1f9465e4bf964a488bd45b4cc674e2795a99617e", "filename": "libjava/java/awt/FlowLayout.java", "status": "modified", "additions": 86, "deletions": 80, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/924af605fe5f1e5cfac29d369c3fa50b7bd603dd/libjava%2Fjava%2Fawt%2FFlowLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/924af605fe5f1e5cfac29d369c3fa50b7bd603dd/libjava%2Fjava%2Fawt%2FFlowLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FFlowLayout.java?ref=924af605fe5f1e5cfac29d369c3fa50b7bd603dd", "patch": "@@ -150,76 +150,79 @@ public FlowLayout (int align, int hgap, int vgap)\n    */\n   public void layoutContainer (Container parent)\n   {\n-    int num = parent.getComponentCount ();\n-    // This is more efficient than calling getComponents().\n-    Component[] comps = parent.component;\n+    synchronized (parent.getTreeLock ())\n+      {\n+\tint num = parent.getComponentCount ();\n+\t// This is more efficient than calling getComponents().\n+\tComponent[] comps = parent.component;\n \n-    Dimension d = parent.getSize ();\n-    Insets ins = parent.getInsets ();\n+\tDimension d = parent.getSize ();\n+\tInsets ins = parent.getInsets ();\n \n-    ComponentOrientation orient = parent.getComponentOrientation ();\n-    boolean left_to_right = orient.isLeftToRight ();\n+\tComponentOrientation orient = parent.getComponentOrientation ();\n+\tboolean left_to_right = orient.isLeftToRight ();\n \n-    int y = ins.top + vgap;\n-    int i = 0;\n-    while (i < num)\n-      {\n-\t// Find the components which go in the current row.\n-\tint new_w = ins.left + hgap + ins.right;\n-\tint new_h = 0;\n-\tint j;\n-\tboolean found_one = false;\n-\tfor (j = i; j < num && ! found_one; ++j)\n+\tint y = ins.top + vgap;\n+\tint i = 0;\n+\twhile (i < num)\n \t  {\n-\t    // Skip invisible items.\n-\t    if (! comps[i].visible)\n-\t      continue;\n-\n-\t    Dimension c = comps[i].getPreferredSize ();\n-\n-\t    int next_w = new_w + hgap + c.width;\n-\t    if (next_w <= d.width || ! found_one)\n+\t    // Find the components which go in the current row.\n+\t    int new_w = ins.left + hgap + ins.right;\n+\t    int new_h = 0;\n+\t    int j;\n+\t    boolean found_one = false;\n+\t    for (j = i; j < num && ! found_one; ++j)\n \t      {\n-\t\tnew_w = next_w;\n-\t\tnew_h = Math.max (new_h, c.height);\n-\t\tfound_one = true;\n+\t\t// Skip invisible items.\n+\t\tif (! comps[i].visible)\n+\t\t  continue;\n+\n+\t\tDimension c = comps[i].getPreferredSize ();\n+\n+\t\tint next_w = new_w + hgap + c.width;\n+\t\tif (next_w <= d.width || ! found_one)\n+\t\t  {\n+\t\t    new_w = next_w;\n+\t\t    new_h = Math.max (new_h, c.height);\n+\t\t    found_one = true;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    // Must start a new row, and we already found an item\n+\t\t    break;\n+\t\t  }\n \t      }\n-\t    else\n-\t      {\n-\t\t// Must start a new row, and we already found an item\n-\t\tbreak;\n-\t      }\n-\t  }\n \n-\t// Set the location of each component for this row.\n-\tint x;\n+\t    // Set the location of each component for this row.\n+\t    int x;\n \n-\tint myalign = align;\n-\tif (align == LEADING)\n-\t  myalign = left_to_right ? LEFT : RIGHT;\n-\telse if (align == TRAILING)\n-\t  myalign = left_to_right ? RIGHT : LEFT;\n+\t    int myalign = align;\n+\t    if (align == LEADING)\n+\t      myalign = left_to_right ? LEFT : RIGHT;\n+\t    else if (align == TRAILING)\n+\t      myalign = left_to_right ? RIGHT : LEFT;\n \n-\tif (myalign == LEFT)\n-\t  x = ins.left + hgap;\n-\telse if (myalign == CENTER)\n-\t  x = (d.width - new_w) / 2;\n-\telse\n-\t  x = d.width - new_w;\n+\t    if (myalign == LEFT)\n+\t      x = ins.left + hgap;\n+\t    else if (myalign == CENTER)\n+\t      x = (d.width - new_w) / 2;\n+\t    else\n+\t      x = d.width - new_w;\n \n-\tfor (int k = i; k < j; ++k)\n-\t  {\n-\t    if (comps[k].visible)\n+\t    for (int k = i; k < j; ++k)\n \t      {\n-\t\tDimension c = comps[k].getPreferredSize ();\n-\t\tcomps[k].setBounds (x, y, c.width, new_h);\n-\t\tx += c.width + hgap;\n+\t\tif (comps[k].visible)\n+\t\t  {\n+\t\t    Dimension c = comps[k].getPreferredSize ();\n+\t\t    comps[k].setBounds (x, y, c.width, new_h);\n+\t\t    x += c.width + hgap;\n+\t\t  }\n \t      }\n-\t  }\n \n-\t// Advance to next row.\n-\ti = j;\n-\ty += new_h + vgap;\n+\t    // Advance to next row.\n+\t    i = j;\n+\t    y += new_h + vgap;\n+\t  }\n       }\n   }\n \n@@ -304,36 +307,39 @@ public String toString ()\n   // This method is used to compute the various sizes.\n   private Dimension getSize (Container parent, boolean is_min)\n   {\n-    int w, h, num = parent.getComponentCount ();\n-    // This is more efficient than calling getComponents().\n-    Component[] comps = parent.component;\n-\n-    w = 0;\n-    h = 0;\n-    for (int i = 0; i < num; ++i)\n+    synchronized (parent.getTreeLock ())\n       {\n-\tif (! comps[i].visible)\n-\t  continue;\n+\tint w, h, num = parent.getComponentCount ();\n+\t// This is more efficient than calling getComponents().\n+\tComponent[] comps = parent.component;\n \n-\t// FIXME: can we just directly read the fields in Component?\n-\t// Or will that not work with subclassing?\n-\tDimension d;\n+\tw = 0;\n+\th = 0;\n+\tfor (int i = 0; i < num; ++i)\n+\t  {\n+\t    if (! comps[i].visible)\n+\t      continue;\n \n-\tif (is_min)\n-\t  d = comps[i].getMinimumSize ();\n-\telse\n-\t  d = comps[i].getPreferredSize ();\n+\t    // FIXME: can we just directly read the fields in Component?\n+\t    // Or will that not work with subclassing?\n+\t    Dimension d;\n \n-\tw += d.width;\n-\th = Math.max (d.height, h);\n-      }\n+\t    if (is_min)\n+\t      d = comps[i].getMinimumSize ();\n+\t    else\n+\t      d = comps[i].getPreferredSize ();\n \n-    Insets ins = parent.getInsets ();\n+\t    w += d.width;\n+\t    h = Math.max (d.height, h);\n+\t  }\n \n-    w += (num + 1) * hgap + ins.left + ins.right;\n-    h += 2 * vgap + ins.top + ins.bottom;\n+\tInsets ins = parent.getInsets ();\n \n-    return new Dimension (w, h);\n+\tw += (num + 1) * hgap + ins.left + ins.right;\n+\th += 2 * vgap + ins.top + ins.bottom;\n+\n+\treturn new Dimension (w, h);\n+      }\n   }\n \n   /**"}, {"sha": "a8befc4c0d375e774fa0a180e56846139e5e7c65", "filename": "libjava/java/awt/GridLayout.java", "status": "modified", "additions": 84, "deletions": 78, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/924af605fe5f1e5cfac29d369c3fa50b7bd603dd/libjava%2Fjava%2Fawt%2FGridLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/924af605fe5f1e5cfac29d369c3fa50b7bd603dd/libjava%2Fjava%2Fawt%2FGridLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGridLayout.java?ref=924af605fe5f1e5cfac29d369c3fa50b7bd603dd", "patch": "@@ -153,62 +153,65 @@ public GridLayout (int rows, int cols, int hgap, int vgap)\n    */\n   public void layoutContainer (Container parent)\n   {\n-    int num = parent.ncomponents;\n-\n-    // There's no point, and handling this would mean adding special\n-    // cases.\n-    if (num == 0)\n-      return;\n-\n-    // This is more efficient than calling getComponents().\n-    Component[] comps = parent.component;\n-\n-    int real_rows = rows;\n-    int real_cols = cols;\n-    if (real_rows == 0)\n-      real_rows = (num + real_cols - 1) / real_cols;\n-    else\n-      real_cols = (num + real_rows - 1) / real_rows;\n-\n-    // We might have less than a single row.  In this case we expand\n-    // to fill.\n-    if (num < real_cols)\n-      real_cols = num;\n-\n-    Dimension d = parent.getSize ();\n-    Insets ins = parent.getInsets ();\n-\n-    // Compute width and height of each cell in the grid.\n-    int tw = d.width - ins.left - ins.right;\n-    tw = (tw - (real_cols - 1) * hgap) / real_cols;\n-    int th = d.height - ins.top - ins.bottom;\n-    th = (th - (real_rows - 1) * vgap) / real_rows;\n-\n-    // If the cells are too small, still try to do something.\n-    if (tw < 0)\n-      tw = 1;\n-    if (th < 0)\n-      th = 1;\n-\n-    int x = ins.left;\n-    int y = ins.top;\n-    int i = 0;\n-    int recount = 0;\n-\n-    while (i < num)\n+    synchronized (parent.getTreeLock ())\n       {\n-\tcomps[i].setBounds (x, y, tw, th);\n+\tint num = parent.ncomponents;\n \n-\t++i;\n-\t++recount;\n-\tif (recount == real_cols)\n+\t// There's no point, and handling this would mean adding special\n+\t// cases.\n+\tif (num == 0)\n+\t  return;\n+\n+\t// This is more efficient than calling getComponents().\n+\tComponent[] comps = parent.component;\n+\n+\tint real_rows = rows;\n+\tint real_cols = cols;\n+\tif (real_rows == 0)\n+\t  real_rows = (num + real_cols - 1) / real_cols;\n+\telse\n+\t  real_cols = (num + real_rows - 1) / real_rows;\n+\n+\t// We might have less than a single row.  In this case we expand\n+\t// to fill.\n+\tif (num < real_cols)\n+\t  real_cols = num;\n+\n+\tDimension d = parent.getSize ();\n+\tInsets ins = parent.getInsets ();\n+\n+\t// Compute width and height of each cell in the grid.\n+\tint tw = d.width - ins.left - ins.right;\n+\ttw = (tw - (real_cols - 1) * hgap) / real_cols;\n+\tint th = d.height - ins.top - ins.bottom;\n+\tth = (th - (real_rows - 1) * vgap) / real_rows;\n+\n+\t// If the cells are too small, still try to do something.\n+\tif (tw < 0)\n+\t  tw = 1;\n+\tif (th < 0)\n+\t  th = 1;\n+\n+\tint x = ins.left;\n+\tint y = ins.top;\n+\tint i = 0;\n+\tint recount = 0;\n+\n+\twhile (i < num)\n \t  {\n-\t    recount = 0;\n-\t    y += vgap + th;\n-\t    x = ins.left;\n+\t    comps[i].setBounds (x, y, tw, th);\n+\n+\t    ++i;\n+\t    ++recount;\n+\t    if (recount == real_cols)\n+\t      {\n+\t\trecount = 0;\n+\t\ty += vgap + th;\n+\t\tx = ins.left;\n+\t      }\n+\t    else\n+\t      x += hgap + tw;\n \t  }\n-\telse\n-\t  x += hgap + tw;\n       }\n   }\n \n@@ -301,36 +304,39 @@ public String toString ()\n   // This method is used to compute the various sizes.\n   private Dimension getSize (Container parent, boolean is_min)\n   {\n-    int w = 0, h = 0, num = parent.ncomponents;\n-    // This is more efficient than calling getComponents().\n-    Component[] comps = parent.component;\n-\n-    for (int i = 0; i < num; ++i)\n+    synchronized (parent.getTreeLock ())\n       {\n-\tDimension d;\n+\tint w = 0, h = 0, num = parent.ncomponents;\n+\t// This is more efficient than calling getComponents().\n+\tComponent[] comps = parent.component;\n \n-\tif (is_min)\n-\t  d = comps[i].getMinimumSize ();\n-\telse\n-\t  d = comps[i].getPreferredSize ();\n+\tfor (int i = 0; i < num; ++i)\n+\t  {\n+\t    Dimension d;\n \n-\tw = Math.max (d.width, w);\n-\th = Math.max (d.height, h);\n-      }\n+\t    if (is_min)\n+\t      d = comps[i].getMinimumSize ();\n+\t    else\n+\t      d = comps[i].getPreferredSize ();\n+\n+\t    w = Math.max (d.width, w);\n+\t    h = Math.max (d.height, h);\n+\t  }\n \n-    int real_rows = rows;\n-    int real_cols = cols;\n-    if (real_rows == 0)\n-      real_rows = (num + real_cols - 1) / real_cols;\n-    else\n-      real_cols = (num + real_rows - 1) / real_rows;\n-\n-    Insets ins = parent.getInsets ();\n-    // We subtract out an extra gap here because the gaps are only\n-    // between cells.\n-    w = ins.left + ins.right + real_cols * (w + hgap) - hgap;\n-    h = ins.top + ins.bottom + real_rows * (h + vgap) - vgap;\n-    return new Dimension (w, h);\n+\tint real_rows = rows;\n+\tint real_cols = cols;\n+\tif (real_rows == 0)\n+\t  real_rows = (num + real_cols - 1) / real_cols;\n+\telse\n+\t  real_cols = (num + real_rows - 1) / real_rows;\n+\n+\tInsets ins = parent.getInsets ();\n+\t// We subtract out an extra gap here because the gaps are only\n+\t// between cells.\n+\tw = ins.left + ins.right + real_cols * (w + hgap) - hgap;\n+\th = ins.top + ins.bottom + real_rows * (h + vgap) - vgap;\n+\treturn new Dimension (w, h);\n+      }\n   }\n \n   /**"}]}