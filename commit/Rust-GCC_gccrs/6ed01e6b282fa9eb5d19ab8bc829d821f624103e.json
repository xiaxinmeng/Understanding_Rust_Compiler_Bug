{"sha": "6ed01e6b282fa9eb5d19ab8bc829d821f624103e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVkMDFlNmIyODJmYTllYjVkMTlhYjhiYzgyOWQ4MjFmNjI0MTAzZQ==", "commit": {"author": {"name": "Andrew Waterman", "email": "andrew@sifive.com", "date": "2017-11-07T17:09:39Z"}, "committer": {"name": "Palmer Dabbelt", "email": "palmer@gcc.gnu.org", "date": "2017-11-07T17:09:39Z"}, "message": "RISC-V: Implement movmemsi\n\nWithout this we aren't getting proper memcpy inlining on RISC-V systems,\nwhich is particularly disastrous for Dhrystone performance on RV32IM\nsystems.\n\ngcc/ChangeLog\n\n2017-11-07  Andrew Waterman  <andrew@sifive.com>\n\n        * config/riscv/riscv-protos.h (riscv_hard_regno_nregs): New\n        prototype.\n        (riscv_expand_block_move): Likewise.\n        gcc/config/riscv/riscv.h (MOVE_RATIO): Tune cost to movmemsi\n        implementation.\n        (RISCV_MAX_MOVE_BYTES_PER_LOOP_ITER): New define.\n        (RISCV_MAX_MOVE_BYTES_STRAIGHT): New define.\n        gcc/config/riscv/riscv.c (riscv_block_move_straight): New\n        function.\n        (riscv_adjust_block_mem): Likewise.\n        (riscv_block_move_loop): Likewise.\n        (riscv_expand_block_move): Likewise.\n        gcc/config/riscv/riscv.md (movmemsi): New pattern.\n\nFrom-SVN: r254501", "tree": {"sha": "572f7f70b0efc8ad8987a83d24131725bdb8be01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/572f7f70b0efc8ad8987a83d24131725bdb8be01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ed01e6b282fa9eb5d19ab8bc829d821f624103e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ed01e6b282fa9eb5d19ab8bc829d821f624103e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ed01e6b282fa9eb5d19ab8bc829d821f624103e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ed01e6b282fa9eb5d19ab8bc829d821f624103e/comments", "author": {"login": "aswaterman", "id": 1031106, "node_id": "MDQ6VXNlcjEwMzExMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1031106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aswaterman", "html_url": "https://github.com/aswaterman", "followers_url": "https://api.github.com/users/aswaterman/followers", "following_url": "https://api.github.com/users/aswaterman/following{/other_user}", "gists_url": "https://api.github.com/users/aswaterman/gists{/gist_id}", "starred_url": "https://api.github.com/users/aswaterman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aswaterman/subscriptions", "organizations_url": "https://api.github.com/users/aswaterman/orgs", "repos_url": "https://api.github.com/users/aswaterman/repos", "events_url": "https://api.github.com/users/aswaterman/events{/privacy}", "received_events_url": "https://api.github.com/users/aswaterman/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d30a85ecee179acc22a213653f4c03028994a6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d30a85ecee179acc22a213653f4c03028994a6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d30a85ecee179acc22a213653f4c03028994a6b"}], "stats": {"total": 210, "additions": 206, "deletions": 4}, "files": [{"sha": "3af06775113c1d62db20c8c2bfa6ce3f490b19c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed01e6b282fa9eb5d19ab8bc829d821f624103e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed01e6b282fa9eb5d19ab8bc829d821f624103e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ed01e6b282fa9eb5d19ab8bc829d821f624103e", "patch": "@@ -1,3 +1,19 @@\n+2017-11-07  Andrew Waterman  <andrew@sifive.com>\n+\n+\t* config/riscv/riscv-protos.h (riscv_hard_regno_nregs): New\n+\tprototype.\n+\t(riscv_expand_block_move): Likewise.\n+\tgcc/config/riscv/riscv.h (MOVE_RATIO): Tune cost to movmemsi\n+\timplementation.\n+\t(RISCV_MAX_MOVE_BYTES_PER_LOOP_ITER): New define.\n+\t(RISCV_MAX_MOVE_BYTES_STRAIGHT): New define.\n+\tgcc/config/riscv/riscv.c (riscv_block_move_straight): New\n+\tfunction.\n+\t(riscv_adjust_block_mem): Likewise.\n+\t(riscv_block_move_loop): Likewise.\n+\t(riscv_expand_block_move): Likewise.\n+\tgcc/config/riscv/riscv.md (movmemsi): New pattern.\n+\n 2017-11-07  Michael Clark  <michaeljclark@mac.com>\n \n \t* config/riscv/linux.h (MUSL_ABI_SUFFIX): New define."}, {"sha": "34f9859928e2d67267a2ac9e0a9bec4e9be9c0b3", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed01e6b282fa9eb5d19ab8bc829d821f624103e/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed01e6b282fa9eb5d19ab8bc829d821f624103e/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=6ed01e6b282fa9eb5d19ab8bc829d821f624103e", "patch": "@@ -67,7 +67,9 @@ extern HOST_WIDE_INT riscv_initial_elimination_offset (int, int);\n extern void riscv_expand_prologue (void);\n extern void riscv_expand_epilogue (bool);\n extern bool riscv_can_use_return_insn (void);\n-extern rtx riscv_function_value (const_tree, const_tree, machine_mode);\n+extern rtx riscv_function_value (const_tree, const_tree, enum machine_mode);\n+extern unsigned int riscv_hard_regno_nregs (int, enum machine_mode);\n+extern bool riscv_expand_block_move (rtx, rtx, rtx);\n \n /* Routines implemented in riscv-c.c.  */\n void riscv_cpu_cpp_builtins (cpp_reader *);"}, {"sha": "e9783e920ef6fc3882c66c1ccf23ace000d8d640", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed01e6b282fa9eb5d19ab8bc829d821f624103e/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed01e6b282fa9eb5d19ab8bc829d821f624103e/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=6ed01e6b282fa9eb5d19ab8bc829d821f624103e", "patch": "@@ -2642,6 +2642,162 @@ riscv_legitimize_call_address (rtx addr)\n   return addr;\n }\n \n+/* Emit straight-line code to move LENGTH bytes from SRC to DEST.\n+   Assume that the areas do not overlap.  */\n+\n+static void\n+riscv_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n+{\n+  HOST_WIDE_INT offset, delta;\n+  unsigned HOST_WIDE_INT bits;\n+  int i;\n+  enum machine_mode mode;\n+  rtx *regs;\n+\n+  bits = MAX (BITS_PER_UNIT,\n+\t      MIN (BITS_PER_WORD, MIN (MEM_ALIGN (src), MEM_ALIGN (dest))));\n+\n+  mode = mode_for_size (bits, MODE_INT, 0);\n+  delta = bits / BITS_PER_UNIT;\n+\n+  /* Allocate a buffer for the temporary registers.  */\n+  regs = XALLOCAVEC (rtx, length / delta);\n+\n+  /* Load as many BITS-sized chunks as possible.  Use a normal load if\n+     the source has enough alignment, otherwise use left/right pairs.  */\n+  for (offset = 0, i = 0; offset + delta <= length; offset += delta, i++)\n+    {\n+      regs[i] = gen_reg_rtx (mode);\n+      riscv_emit_move (regs[i], adjust_address (src, mode, offset));\n+    }\n+\n+  /* Copy the chunks to the destination.  */\n+  for (offset = 0, i = 0; offset + delta <= length; offset += delta, i++)\n+    riscv_emit_move (adjust_address (dest, mode, offset), regs[i]);\n+\n+  /* Mop up any left-over bytes.  */\n+  if (offset < length)\n+    {\n+      src = adjust_address (src, BLKmode, offset);\n+      dest = adjust_address (dest, BLKmode, offset);\n+      move_by_pieces (dest, src, length - offset,\n+\t\t      MIN (MEM_ALIGN (src), MEM_ALIGN (dest)), 0);\n+    }\n+}\n+\n+/* Helper function for doing a loop-based block operation on memory\n+   reference MEM.  Each iteration of the loop will operate on LENGTH\n+   bytes of MEM.\n+\n+   Create a new base register for use within the loop and point it to\n+   the start of MEM.  Create a new memory reference that uses this\n+   register.  Store them in *LOOP_REG and *LOOP_MEM respectively.  */\n+\n+static void\n+riscv_adjust_block_mem (rtx mem, HOST_WIDE_INT length,\n+\t\t       rtx *loop_reg, rtx *loop_mem)\n+{\n+  *loop_reg = copy_addr_to_reg (XEXP (mem, 0));\n+\n+  /* Although the new mem does not refer to a known location,\n+     it does keep up to LENGTH bytes of alignment.  */\n+  *loop_mem = change_address (mem, BLKmode, *loop_reg);\n+  set_mem_align (*loop_mem, MIN (MEM_ALIGN (mem), length * BITS_PER_UNIT));\n+}\n+\n+/* Move LENGTH bytes from SRC to DEST using a loop that moves BYTES_PER_ITER\n+   bytes at a time.  LENGTH must be at least BYTES_PER_ITER.  Assume that\n+   the memory regions do not overlap.  */\n+\n+static void\n+riscv_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length,\n+\t\t      HOST_WIDE_INT bytes_per_iter)\n+{\n+  rtx label, src_reg, dest_reg, final_src, test;\n+  HOST_WIDE_INT leftover;\n+\n+  leftover = length % bytes_per_iter;\n+  length -= leftover;\n+\n+  /* Create registers and memory references for use within the loop.  */\n+  riscv_adjust_block_mem (src, bytes_per_iter, &src_reg, &src);\n+  riscv_adjust_block_mem (dest, bytes_per_iter, &dest_reg, &dest);\n+\n+  /* Calculate the value that SRC_REG should have after the last iteration\n+     of the loop.  */\n+  final_src = expand_simple_binop (Pmode, PLUS, src_reg, GEN_INT (length),\n+\t\t\t\t   0, 0, OPTAB_WIDEN);\n+\n+  /* Emit the start of the loop.  */\n+  label = gen_label_rtx ();\n+  emit_label (label);\n+\n+  /* Emit the loop body.  */\n+  riscv_block_move_straight (dest, src, bytes_per_iter);\n+\n+  /* Move on to the next block.  */\n+  riscv_emit_move (src_reg, plus_constant (Pmode, src_reg, bytes_per_iter));\n+  riscv_emit_move (dest_reg, plus_constant (Pmode, dest_reg, bytes_per_iter));\n+\n+  /* Emit the loop condition.  */\n+  test = gen_rtx_NE (VOIDmode, src_reg, final_src);\n+  if (Pmode == DImode)\n+    emit_jump_insn (gen_cbranchdi4 (test, src_reg, final_src, label));\n+  else\n+    emit_jump_insn (gen_cbranchsi4 (test, src_reg, final_src, label));\n+\n+  /* Mop up any left-over bytes.  */\n+  if (leftover)\n+    riscv_block_move_straight (dest, src, leftover);\n+  else\n+    emit_insn(gen_nop ());\n+}\n+\n+/* Expand a movmemsi instruction, which copies LENGTH bytes from\n+   memory reference SRC to memory reference DEST.  */\n+\n+bool\n+riscv_expand_block_move (rtx dest, rtx src, rtx length)\n+{\n+  if (CONST_INT_P (length))\n+    {\n+      HOST_WIDE_INT factor, align;\n+\n+      align = MIN (MIN (MEM_ALIGN (src), MEM_ALIGN (dest)), BITS_PER_WORD);\n+      factor = BITS_PER_WORD / align;\n+\n+      if (optimize_function_for_size_p (cfun)\n+\t  && INTVAL (length) * factor * UNITS_PER_WORD > MOVE_RATIO (false))\n+\treturn false;\n+\n+      if (INTVAL (length) <= RISCV_MAX_MOVE_BYTES_STRAIGHT / factor)\n+\t{\n+\t  riscv_block_move_straight (dest, src, INTVAL (length));\n+\t  return true;\n+\t}\n+      else if (optimize && align >= BITS_PER_WORD)\n+\t{\n+\t  unsigned min_iter_words\n+\t    = RISCV_MAX_MOVE_BYTES_PER_LOOP_ITER / UNITS_PER_WORD;\n+\t  unsigned iter_words = min_iter_words;\n+\t  HOST_WIDE_INT bytes = INTVAL (length), words = bytes / UNITS_PER_WORD;\n+\n+\t  /* Lengthen the loop body if it shortens the tail.  */\n+\t  for (unsigned i = min_iter_words; i < min_iter_words * 2 - 1; i++)\n+\t    {\n+\t      unsigned cur_cost = iter_words + words % iter_words;\n+\t      unsigned new_cost = i + words % i;\n+\t      if (new_cost <= cur_cost)\n+\t\titer_words = i;\n+\t    }\n+\n+\t  riscv_block_move_loop (dest, src, bytes, iter_words * UNITS_PER_WORD);\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Print symbolic operand OP, which is part of a HIGH or LO_SUM\n    in context CONTEXT.  HI_RELOC indicates a high-part reloc.  */\n "}, {"sha": "c0901a093033f711ea4bf19546ee5f9fd8543596", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed01e6b282fa9eb5d19ab8bc829d821f624103e/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed01e6b282fa9eb5d19ab8bc829d821f624103e/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=6ed01e6b282fa9eb5d19ab8bc829d821f624103e", "patch": "@@ -808,10 +808,25 @@ while (0)\n #undef PTRDIFF_TYPE\n #define PTRDIFF_TYPE (POINTER_SIZE == 64 ? \"long int\" : \"int\")\n \n-/* If a memory-to-memory move would take MOVE_RATIO or more simple\n-   move-instruction pairs, we will do a movmem or libcall instead.  */\n+/* The maximum number of bytes copied by one iteration of a movmemsi loop.  */\n+\n+#define RISCV_MAX_MOVE_BYTES_PER_LOOP_ITER (UNITS_PER_WORD * 4)\n+\n+/* The maximum number of bytes that can be copied by a straight-line\n+   movmemsi implementation.  */\n \n-#define MOVE_RATIO(speed) (CLEAR_RATIO (speed) / 2)\n+#define RISCV_MAX_MOVE_BYTES_STRAIGHT (RISCV_MAX_MOVE_BYTES_PER_LOOP_ITER * 3)\n+\n+/* If a memory-to-memory move would take MOVE_RATIO or more simple\n+   move-instruction pairs, we will do a movmem or libcall instead.\n+   Do not use move_by_pieces at all when strict alignment is not\n+   in effect but the target has slow unaligned accesses; in this\n+   case, movmem or libcall is more efficient.  */\n+\n+#define MOVE_RATIO(speed)\t\t\t\t\t\t\\\n+  (!STRICT_ALIGNMENT && riscv_slow_unaligned_access ? 1 :\t\t\\\n+   (speed) ? RISCV_MAX_MOVE_BYTES_PER_LOOP_ITER / UNITS_PER_WORD :\t\\\n+   CLEAR_RATIO (speed) / 2)\n \n /* For CLEAR_RATIO, when optimizing for size, give a better estimate\n    of the length of a memset call, but use the default otherwise.  */"}, {"sha": "814ff6ec6ad708b2470383a89a250b10ee354ba5", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed01e6b282fa9eb5d19ab8bc829d821f624103e/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed01e6b282fa9eb5d19ab8bc829d821f624103e/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=6ed01e6b282fa9eb5d19ab8bc829d821f624103e", "patch": "@@ -1436,6 +1436,19 @@\n   DONE;\n })\n \n+(define_expand \"movmemsi\"\n+  [(parallel [(set (match_operand:BLK 0 \"general_operand\")\n+\t\t   (match_operand:BLK 1 \"general_operand\"))\n+\t      (use (match_operand:SI 2 \"\"))\n+\t      (use (match_operand:SI 3 \"const_int_operand\"))])]\n+  \"\"\n+{\n+  if (riscv_expand_block_move (operands[0], operands[1], operands[2]))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n ;; Expand in-line code to clear the instruction cache between operand[0] and\n ;; operand[1].\n (define_expand \"clear_cache\""}]}