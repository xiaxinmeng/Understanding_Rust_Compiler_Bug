{"sha": "90588a106ef2e2fe5d524ef138652f68bce5f72c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA1ODhhMTA2ZWYyZTJmZTVkNTI0ZWYxMzg2NTJmNjhiY2U1ZjcyYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-09-06T19:31:55Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-09-06T19:31:55Z"}, "message": "re PR bootstrap/41241 (bootstrap comparison failure)\n\n\tPR bootstrap/41241\n\t* combine-stack-adj.c (struct csa_memlist): Rename to...\n\t(struct csa_reflist): ... this.  Rename mem field to ref.\n\t(free_csa_memlist): Rename to...\n\t(free_csa_reflist): ... this.\n\t(record_one_stack_memref): Rename to...\n\t(record_one_stack_ref): ... this.  Handle also REG_P.\n\t(try_apply_stack_adjustment): Handle also REG_P.\n\t(struct record_stack_memrefs_data): Rename to...\n\t(struct record_stack_refs_data): ... this.  Rename memlist field to\n\treflist.\n\t(record_stack_memrefs): Rename to...\n\t(record_stack_refs): ... this.  For DEBUG_INSNs keep traversing\n\tsubexpressions instead of failing when a MEM contains SP references.\n\tFor SP itself in DEBUG_INSNs queue it also onto reflist chain.\n\t(combine_stack_adjustments_for_block): Adjust for mem to ref renaming.\n\n\t* gcc.dg/pr41241.c: New test.\n\nFrom-SVN: r151462", "tree": {"sha": "dcfa70361ebbee4fe6fd329aae2b75ba7ac4b3f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcfa70361ebbee4fe6fd329aae2b75ba7ac4b3f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90588a106ef2e2fe5d524ef138652f68bce5f72c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90588a106ef2e2fe5d524ef138652f68bce5f72c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90588a106ef2e2fe5d524ef138652f68bce5f72c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90588a106ef2e2fe5d524ef138652f68bce5f72c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3797a0ff2f3da43cef2c13b2b3fad2695cd7cf02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3797a0ff2f3da43cef2c13b2b3fad2695cd7cf02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3797a0ff2f3da43cef2c13b2b3fad2695cd7cf02"}], "stats": {"total": 216, "additions": 147, "deletions": 69}, "files": [{"sha": "9824c28fc89abd2c83190e4518e35a39d3455db3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90588a106ef2e2fe5d524ef138652f68bce5f72c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90588a106ef2e2fe5d524ef138652f68bce5f72c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90588a106ef2e2fe5d524ef138652f68bce5f72c", "patch": "@@ -1,3 +1,22 @@\n+2009-09-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/41241\n+\t* combine-stack-adj.c (struct csa_memlist): Rename to...\n+\t(struct csa_reflist): ... this.  Rename mem field to ref.\n+\t(free_csa_memlist): Rename to...\n+\t(free_csa_reflist): ... this.\n+\t(record_one_stack_memref): Rename to...\n+\t(record_one_stack_ref): ... this.  Handle also REG_P.\n+\t(try_apply_stack_adjustment): Handle also REG_P.\n+\t(struct record_stack_memrefs_data): Rename to...\n+\t(struct record_stack_refs_data): ... this.  Rename memlist field to\n+\treflist.\n+\t(record_stack_memrefs): Rename to...\n+\t(record_stack_refs): ... this.  For DEBUG_INSNs keep traversing\n+\tsubexpressions instead of failing when a MEM contains SP references.\n+\tFor SP itself in DEBUG_INSNs queue it also onto reflist chain.\n+\t(combine_stack_adjustments_for_block): Adjust for mem to ref renaming.\n+\n 2009-09-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/41144"}, {"sha": "babd6d27e93238ed401d862fafaf00c76277756c", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 89, "deletions": 69, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90588a106ef2e2fe5d524ef138652f68bce5f72c/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90588a106ef2e2fe5d524ef138652f68bce5f72c/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=90588a106ef2e2fe5d524ef138652f68bce5f72c", "patch": "@@ -71,25 +71,26 @@ along with GCC; see the file COPYING3.  If not see\n #define STACK_GROWS_DOWNWARD 0\n #endif\n \n-/* This structure records stack memory references between stack adjusting\n-   instructions.  */\n+/* This structure records two kinds of stack references between stack\n+   adjusting instructions: stack references in memory addresses for\n+   regular insns and all stack references for debug insns.  */\n \n-struct csa_memlist\n+struct csa_reflist\n {\n   HOST_WIDE_INT sp_offset;\n-  rtx insn, *mem;\n-  struct csa_memlist *next;\n+  rtx insn, *ref;\n+  struct csa_reflist *next;\n };\n \n static int stack_memref_p (rtx);\n static rtx single_set_for_csa (rtx);\n-static void free_csa_memlist (struct csa_memlist *);\n-static struct csa_memlist *record_one_stack_memref (rtx, rtx *,\n-\t\t\t\t\t\t    struct csa_memlist *);\n-static int try_apply_stack_adjustment (rtx, struct csa_memlist *,\n+static void free_csa_reflist (struct csa_reflist *);\n+static struct csa_reflist *record_one_stack_ref (rtx, rtx *,\n+\t\t\t\t\t\t struct csa_reflist *);\n+static int try_apply_stack_adjustment (rtx, struct csa_reflist *,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT);\n static void combine_stack_adjustments_for_block (basic_block);\n-static int record_stack_memrefs (rtx *, void *);\n+static int record_stack_refs (rtx *, void *);\n \n \n /* Main entry point for stack adjustment combination.  */\n@@ -157,65 +158,75 @@ single_set_for_csa (rtx insn)\n   return XVECEXP (tmp, 0, 0);\n }\n \n-/* Free the list of csa_memlist nodes.  */\n+/* Free the list of csa_reflist nodes.  */\n \n static void\n-free_csa_memlist (struct csa_memlist *memlist)\n+free_csa_reflist (struct csa_reflist *reflist)\n {\n-  struct csa_memlist *next;\n-  for (; memlist ; memlist = next)\n+  struct csa_reflist *next;\n+  for (; reflist ; reflist = next)\n     {\n-      next = memlist->next;\n-      free (memlist);\n+      next = reflist->next;\n+      free (reflist);\n     }\n }\n \n-/* Create a new csa_memlist node from the given memory reference.\n-   It is already known that the memory is stack_memref_p.  */\n+/* Create a new csa_reflist node from the given stack reference.\n+   It is already known that the reference is either a MEM satisfying the\n+   predicate stack_memref_p or a REG representing the stack pointer.  */\n \n-static struct csa_memlist *\n-record_one_stack_memref (rtx insn, rtx *mem, struct csa_memlist *next_memlist)\n+static struct csa_reflist *\n+record_one_stack_ref (rtx insn, rtx *ref, struct csa_reflist *next_reflist)\n {\n-  struct csa_memlist *ml;\n+  struct csa_reflist *ml;\n \n-  ml = XNEW (struct csa_memlist);\n+  ml = XNEW (struct csa_reflist);\n \n-  if (XEXP (*mem, 0) == stack_pointer_rtx)\n+  if (REG_P (*ref) || XEXP (*ref, 0) == stack_pointer_rtx)\n     ml->sp_offset = 0;\n   else\n-    ml->sp_offset = INTVAL (XEXP (XEXP (*mem, 0), 1));\n+    ml->sp_offset = INTVAL (XEXP (XEXP (*ref, 0), 1));\n \n   ml->insn = insn;\n-  ml->mem = mem;\n-  ml->next = next_memlist;\n+  ml->ref = ref;\n+  ml->next = next_reflist;\n \n   return ml;\n }\n \n /* Attempt to apply ADJUST to the stack adjusting insn INSN, as well\n-   as each of the memories in MEMLIST.  Return true on success.  */\n+   as each of the memories and stack references in REFLIST.  Return true\n+   on success.  */\n \n static int\n-try_apply_stack_adjustment (rtx insn, struct csa_memlist *memlist, HOST_WIDE_INT new_adjust,\n-\t\t\t    HOST_WIDE_INT delta)\n+try_apply_stack_adjustment (rtx insn, struct csa_reflist *reflist,\n+\t\t\t    HOST_WIDE_INT new_adjust, HOST_WIDE_INT delta)\n {\n-  struct csa_memlist *ml;\n+  struct csa_reflist *ml;\n   rtx set;\n \n   set = single_set_for_csa (insn);\n   validate_change (insn, &XEXP (SET_SRC (set), 1), GEN_INT (new_adjust), 1);\n \n-  for (ml = memlist; ml ; ml = ml->next)\n-    validate_change\n-      (ml->insn, ml->mem,\n-       replace_equiv_address_nv (*ml->mem,\n-\t\t\t\t plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\tml->sp_offset - delta)), 1);\n+  for (ml = reflist; ml ; ml = ml->next)\n+    {\n+      rtx new_addr = plus_constant (stack_pointer_rtx, ml->sp_offset - delta);\n+      rtx new_val;\n+\n+      if (MEM_P (*ml->ref))\n+\tnew_val = replace_equiv_address_nv (*ml->ref, new_addr);\n+      else if (GET_MODE (*ml->ref) == GET_MODE (stack_pointer_rtx))\n+\tnew_val = new_addr;\n+      else\n+\tnew_val = lowpart_subreg (GET_MODE (*ml->ref), new_addr,\n+\t\t\t\t  GET_MODE (new_addr));\n+      validate_change (ml->insn, ml->ref, new_val, 1);\n+    }\n \n   if (apply_change_group ())\n     {\n-      /* Succeeded.  Update our knowledge of the memory references.  */\n-      for (ml = memlist; ml ; ml = ml->next)\n+      /* Succeeded.  Update our knowledge of the stack references.  */\n+      for (ml = reflist; ml ; ml = ml->next)\n \tml->sp_offset -= delta;\n \n       return 1;\n@@ -224,20 +235,20 @@ try_apply_stack_adjustment (rtx insn, struct csa_memlist *memlist, HOST_WIDE_INT\n     return 0;\n }\n \n-/* Called via for_each_rtx and used to record all stack memory references in\n-   the insn and discard all other stack pointer references.  */\n-struct record_stack_memrefs_data\n+/* Called via for_each_rtx and used to record all stack memory and other\n+   references in the insn and discard all other stack pointer references.  */\n+struct record_stack_refs_data\n {\n   rtx insn;\n-  struct csa_memlist *memlist;\n+  struct csa_reflist *reflist;\n };\n \n static int\n-record_stack_memrefs (rtx *xp, void *data)\n+record_stack_refs (rtx *xp, void *data)\n {\n   rtx x = *xp;\n-  struct record_stack_memrefs_data *d =\n-    (struct record_stack_memrefs_data *) data;\n+  struct record_stack_refs_data *d =\n+    (struct record_stack_refs_data *) data;\n   if (!x)\n     return 0;\n   switch (GET_CODE (x))\n@@ -249,10 +260,11 @@ record_stack_memrefs (rtx *xp, void *data)\n          stack pointer, so this check is necessary.  */\n       if (stack_memref_p (x))\n \t{\n-\t  d->memlist = record_one_stack_memref (d->insn, xp, d->memlist);\n+\t  d->reflist = record_one_stack_ref (d->insn, xp, d->reflist);\n \t  return -1;\n \t}\n-      return 1;\n+      /* Try harder for DEBUG_INSNs, handle e.g. (mem (mem (sp + 16) + 4).  */\n+      return !DEBUG_INSN_P (d->insn);\n     case REG:\n       /* ??? We want be able to handle non-memory stack pointer\n \t references later.  For now just discard all insns referring to\n@@ -262,9 +274,17 @@ record_stack_memrefs (rtx *xp, void *data)\n \t We can't just compare with STACK_POINTER_RTX because the\n \t reference to the stack pointer might be in some other mode.\n \t In particular, an explicit clobber in an asm statement will\n-\t result in a QImode clobber.  */\n+\t result in a QImode clobber.\n+\n+\t In DEBUG_INSNs, we want to replace all occurrences, otherwise\n+\t they will cause -fcompare-debug failures.  */\n       if (REGNO (x) == STACK_POINTER_REGNUM)\n-\treturn 1;\n+\t{\n+\t  if (!DEBUG_INSN_P (d->insn))\n+\t    return 1;\n+\t  d->reflist = record_one_stack_ref (d->insn, xp, d->reflist);\n+\t  return -1;\n+\t}\n       break;\n     default:\n       break;\n@@ -343,9 +363,9 @@ combine_stack_adjustments_for_block (basic_block bb)\n {\n   HOST_WIDE_INT last_sp_adjust = 0;\n   rtx last_sp_set = NULL_RTX;\n-  struct csa_memlist *memlist = NULL;\n+  struct csa_reflist *reflist = NULL;\n   rtx insn, next, set;\n-  struct record_stack_memrefs_data data;\n+  struct record_stack_refs_data data;\n   bool end_of_block = false;\n \n   for (insn = BB_HEAD (bb); !end_of_block ; insn = next)\n@@ -379,7 +399,7 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t\t  continue;\n \t\t}\n \n-\t      /* If not all recorded memrefs can be adjusted, or the\n+\t      /* If not all recorded refs can be adjusted, or the\n \t\t adjustment is now too large for a constant addition,\n \t\t we cannot merge the two stack adjustments.\n \n@@ -403,7 +423,7 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t      /* Combine an allocation into the first instruction.  */\n \t      if (STACK_GROWS_DOWNWARD ? this_adjust <= 0 : this_adjust >= 0)\n \t\t{\n-\t\t  if (try_apply_stack_adjustment (last_sp_set, memlist,\n+\t\t  if (try_apply_stack_adjustment (last_sp_set, reflist,\n \t\t\t\t\t\t  last_sp_adjust + this_adjust,\n \t\t\t\t\t\t  this_adjust))\n \t\t    {\n@@ -422,16 +442,16 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t      else if (STACK_GROWS_DOWNWARD\n \t\t       ? last_sp_adjust >= 0 : last_sp_adjust <= 0)\n \t\t{\n-\t\t  if (try_apply_stack_adjustment (insn, memlist,\n+\t\t  if (try_apply_stack_adjustment (insn, reflist,\n \t\t\t\t\t\t  last_sp_adjust + this_adjust,\n \t\t\t\t\t\t  -last_sp_adjust))\n \t\t    {\n \t\t      /* It worked!  */\n \t\t      delete_insn (last_sp_set);\n \t\t      last_sp_set = insn;\n \t\t      last_sp_adjust += this_adjust;\n-\t\t      free_csa_memlist (memlist);\n-\t\t      memlist = NULL;\n+\t\t      free_csa_reflist (reflist);\n+\t\t      reflist = NULL;\n \t\t      continue;\n \t\t    }\n \t\t}\n@@ -441,8 +461,8 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t\t delete the old deallocation insn.  */\n \t      if (last_sp_set && last_sp_adjust == 0)\n \t\tdelete_insn (last_sp_set);\n-\t      free_csa_memlist (memlist);\n-\t      memlist = NULL;\n+\t      free_csa_reflist (reflist);\n+\t      reflist = NULL;\n \t      last_sp_set = insn;\n \t      last_sp_adjust = this_adjust;\n \t      continue;\n@@ -451,7 +471,7 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t  /* Find a predecrement of exactly the previous adjustment and\n \t     turn it into a direct store.  Obviously we can't do this if\n \t     there were any intervening uses of the stack pointer.  */\n-\t  if (memlist == NULL\n+\t  if (reflist == NULL\n \t      && MEM_P (dest)\n \t      && ((GET_CODE (XEXP (dest, 0)) == PRE_DEC\n \t\t   && (last_sp_adjust\n@@ -472,23 +492,23 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t\t\t\t  0))\n \t    {\n \t      delete_insn (last_sp_set);\n-\t      free_csa_memlist (memlist);\n-\t      memlist = NULL;\n+\t      free_csa_reflist (reflist);\n+\t      reflist = NULL;\n \t      last_sp_set = NULL_RTX;\n \t      last_sp_adjust = 0;\n \t      continue;\n \t    }\n \t}\n \n       data.insn = insn;\n-      data.memlist = memlist;\n+      data.reflist = reflist;\n       if (!CALL_P (insn) && last_sp_set\n-\t  && !for_each_rtx (&PATTERN (insn), record_stack_memrefs, &data))\n+\t  && !for_each_rtx (&PATTERN (insn), record_stack_refs, &data))\n \t{\n-\t   memlist = data.memlist;\n+\t   reflist = data.reflist;\n \t   continue;\n \t}\n-      memlist = data.memlist;\n+      reflist = data.reflist;\n \n       /* Otherwise, we were not able to process the instruction.\n \t Do not continue collecting data across such a one.  */\n@@ -498,8 +518,8 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t{\n \t  if (last_sp_set && last_sp_adjust == 0)\n \t    delete_insn (last_sp_set);\n-\t  free_csa_memlist (memlist);\n-\t  memlist = NULL;\n+\t  free_csa_reflist (reflist);\n+\t  reflist = NULL;\n \t  last_sp_set = NULL_RTX;\n \t  last_sp_adjust = 0;\n \t}\n@@ -508,8 +528,8 @@ combine_stack_adjustments_for_block (basic_block bb)\n   if (last_sp_set && last_sp_adjust == 0)\n     delete_insn (last_sp_set);\n \n-  if (memlist)\n-    free_csa_memlist (memlist);\n+  if (reflist)\n+    free_csa_reflist (reflist);\n }\n \f\n "}, {"sha": "567e58ced73c9d49dddb51c020614e5e269bc3ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90588a106ef2e2fe5d524ef138652f68bce5f72c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90588a106ef2e2fe5d524ef138652f68bce5f72c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=90588a106ef2e2fe5d524ef138652f68bce5f72c", "patch": "@@ -1,3 +1,8 @@\n+2009-09-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/41241\n+\t* gcc.dg/pr41241.c: New test.\n+\n 2009-09-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/41144"}, {"sha": "b69aa96ca5e2450e87ad958f9f99c5bb27329fe4", "filename": "gcc/testsuite/gcc.dg/pr41241.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90588a106ef2e2fe5d524ef138652f68bce5f72c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41241.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90588a106ef2e2fe5d524ef138652f68bce5f72c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41241.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41241.c?ref=90588a106ef2e2fe5d524ef138652f68bce5f72c", "patch": "@@ -0,0 +1,34 @@\n+/* PR bootstrap/41241 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fcompare-debug -g\" } */\n+/* { dg-options \"-O2 -fcompare-debug -g -march=i586 -mtune=i586 -fomit-frame-pointer\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n+\n+typedef struct { int t1; int t2; int t3; } *T;\n+typedef struct { int s; } S;\n+\n+int fn1 (int);\n+int fn2 (int, int, int);\n+int fn3 (void);\n+\n+static S\n+bar ()\n+{\n+  S s = { 0 };\n+  return s;\n+}\n+\n+void\n+foo (T x)\n+{\n+  int a, b, c, d, e;\n+  T f, g;\n+  S h;\n+  a = x->t2;\n+  fn1 (x->t1);\n+  h = bar (b);\n+  c = fn1 (e);\n+  d = fn3 ();\n+  f->t3 &= g->t3 |= fn2 (0, b, x->t1);\n+  fn2 (0, c, d);\n+  fn2 (0, e, 0);\n+}"}]}