{"sha": "08ee945e0b945fd2797c8bb7524d79dc73a9b6bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhlZTk0NWUwYjk0NWZkMjc5N2M4YmI3NTI0ZDc5ZGM3M2E5YjZiZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-11-29T21:58:48Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-11-29T21:58:48Z"}, "message": "runtime: If no sem_timedwait, use pthread_cond_timedwait.\n\nFrom-SVN: r181821", "tree": {"sha": "e7665ea556f238ad5c34dff64c5b1839162dc2ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7665ea556f238ad5c34dff64c5b1839162dc2ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd/comments", "author": null, "committer": null, "parents": [{"sha": "85b8555ed3c45855b237b0f3a044eefb9382255c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b8555ed3c45855b237b0f3a044eefb9382255c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b8555ed3c45855b237b0f3a044eefb9382255c"}], "stats": {"total": 125, "additions": 114, "deletions": 11}, "files": [{"sha": "0c1283cc574b0d3afe521c3b9ff799fa32515e9b", "filename": "libgo/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd/libgo%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd/libgo%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfig.h.in?ref=08ee945e0b945fd2797c8bb7524d79dc73a9b6bd", "patch": "@@ -36,6 +36,9 @@\n /* Define to 1 if you have the `random' function. */\n #undef HAVE_RANDOM\n \n+/* Define to 1 if you have the `sem_timedwait' function. */\n+#undef HAVE_SEM_TIMEDWAIT\n+\n /* Define to 1 if you have the `setenv' function. */\n #undef HAVE_SETENV\n "}, {"sha": "e9f536a58834800608ed7c003c3415b5a2aa7368", "filename": "libgo/configure", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=08ee945e0b945fd2797c8bb7524d79dc73a9b6bd", "patch": "@@ -14559,6 +14559,24 @@ else\n fi\n \n \n+CFLAGS_hold=\"$CFLAGS\"\n+CFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\n+LIBS_hold=\"$LIBS\"\n+LIBS=\"$LIBS $PTHREAD_LIBS\"\n+for ac_func in sem_timedwait\n+do :\n+  ac_fn_c_check_func \"$LINENO\" \"sem_timedwait\" \"ac_cv_func_sem_timedwait\"\n+if test \"x$ac_cv_func_sem_timedwait\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_SEM_TIMEDWAIT 1\n+_ACEOF\n+\n+fi\n+done\n+\n+CFLAGS=\"$CFLAGS_hold\"\n+LIBS=\"$LIBS_hold\"\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for __sync_bool_compare_and_swap_4\" >&5\n $as_echo_n \"checking for __sync_bool_compare_and_swap_4... \" >&6; }\n if test \"${libgo_cv_func___sync_bool_compare_and_swap_4+set}\" = set; then :"}, {"sha": "576d1a64329b69dc08a353dc143d6e1989ba7d2f", "filename": "libgo/configure.ac", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=08ee945e0b945fd2797c8bb7524d79dc73a9b6bd", "patch": "@@ -456,6 +456,14 @@ AC_CHECK_FUNCS(srandom random strerror_r strsignal wait4 mincore setenv)\n AM_CONDITIONAL(HAVE_STRERROR_R, test \"$ac_cv_func_strerror_r\" = yes)\n AM_CONDITIONAL(HAVE_WAIT4, test \"$ac_cv_func_wait4\" = yes)\n \n+CFLAGS_hold=\"$CFLAGS\"\n+CFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\n+LIBS_hold=\"$LIBS\"\n+LIBS=\"$LIBS $PTHREAD_LIBS\"\n+AC_CHECK_FUNCS(sem_timedwait)\n+CFLAGS=\"$CFLAGS_hold\"\n+LIBS=\"$LIBS_hold\"\n+\n AC_CACHE_CHECK([for __sync_bool_compare_and_swap_4],\n [libgo_cv_func___sync_bool_compare_and_swap_4],\n [AC_LINK_IFELSE(["}, {"sha": "6b4fffbdcf82d67566e975f737b18aaec18a9f0d", "filename": "libgo/runtime/lock_sema.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd/libgo%2Fruntime%2Flock_sema.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd/libgo%2Fruntime%2Flock_sema.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flock_sema.c?ref=08ee945e0b945fd2797c8bb7524d79dc73a9b6bd", "patch": "@@ -32,9 +32,11 @@ enum\n void\n runtime_lock(Lock *l)\n {\n+\tM *m;\n \tuintptr v;\n \tuint32 i, spin;\n \n+\tm = runtime_m();\n \tif(m->locks++ < 0)\n \t\truntime_throw(\"runtime_lock: lock count\");\n \n@@ -91,7 +93,7 @@ runtime_unlock(Lock *l)\n \tuintptr v;\n \tM *mp;\n \n-\tif(--m->locks < 0)\n+\tif(--runtime_m()->locks < 0)\n \t\truntime_throw(\"runtime_unlock: lock count\");\n \n \tfor(;;) {\n@@ -144,6 +146,9 @@ runtime_notewakeup(Note *n)\n void\n runtime_notesleep(Note *n)\n {\n+\tM *m;\n+\n+\tm = runtime_m();\n \tif(m->waitsema == 0)\n \t\tm->waitsema = runtime_semacreate();\n \tif(!runtime_casp(&n->waitm, nil, m)) {  // must be LOCKED (got wakeup)\n@@ -158,6 +163,7 @@ runtime_notesleep(Note *n)\n void\n runtime_notetsleep(Note *n, int64 ns)\n {\n+\tM *m;\n \tM *mp;\n \tint64 deadline, now;\n \n@@ -166,6 +172,7 @@ runtime_notetsleep(Note *n, int64 ns)\n \t\treturn;\n \t}\n \n+\tm = runtime_m();\n \tif(m->waitsema == 0)\n \t\tm->waitsema = runtime_semacreate();\n "}, {"sha": "71555d09725060423e9172367a2b7c7be7381eab", "filename": "libgo/runtime/thread-sema.c", "status": "modified", "additions": 77, "deletions": 10, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd/libgo%2Fruntime%2Fthread-sema.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ee945e0b945fd2797c8bb7524d79dc73a9b6bd/libgo%2Fruntime%2Fthread-sema.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread-sema.c?ref=08ee945e0b945fd2797c8bb7524d79dc73a9b6bd", "patch": "@@ -2,26 +2,51 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+#include \"config.h\"\n #include \"runtime.h\"\n \n #include <errno.h>\n #include <stdlib.h>\n #include <time.h>\n #include <semaphore.h>\n \n+/* If we don't have sem_timedwait, use pthread_cond_timedwait instead.\n+   We don't always use condition variables because on some systems\n+   pthread_mutex_lock and pthread_mutex_unlock must be called by the\n+   same thread.  That is never true of semaphores.  */\n+\n+struct go_sem\n+{\n+  sem_t sem;\n+\n+#ifndef HAVE_SEM_TIMEDWAIT\n+  int timedwait;\n+  pthread_mutex_t mutex;\n+  pthread_cond_t cond;\n+#endif\n+};\n+\n /* Create a semaphore.  */\n \n uintptr\n runtime_semacreate(void)\n {\n-  sem_t *p;\n+  struct go_sem *p;\n \n   /* Call malloc rather than runtime_malloc.  This will allocate space\n      on the C heap.  We can't call runtime_malloc here because it\n      could cause a deadlock.  */\n-  p = malloc (sizeof (sem_t));\n-  if (sem_init (p, 0, 0) != 0)\n+  p = malloc (sizeof (struct go_sem));\n+  if (sem_init (&p->sem, 0, 0) != 0)\n     runtime_throw (\"sem_init\");\n+\n+#ifndef HAVE_SEM_TIMEDWAIT\n+  if (pthread_mutex_init (&p->mutex, NULL) != 0)\n+    runtime_throw (\"pthread_mutex_init\");\n+  if (pthread_cond_init (&p->cond, NULL) != 0)\n+    runtime_throw (\"pthread_cond_init\");\n+#endif\n+\n   return (uintptr) p;\n }\n \n@@ -30,26 +55,56 @@ runtime_semacreate(void)\n int32\n runtime_semasleep (int64 ns)\n {\n+  M *m;\n+  struct go_sem *sem;\n   int r;\n \n+  m = runtime_m ();\n+  sem = (struct go_sem *) m->waitsema;\n   if (ns >= 0)\n     {\n+      int64 abs;\n       struct timespec ts;\n+      int err;\n+\n+      abs = ns + runtime_nanotime ();\n+      ts.tv_sec = abs / 1000000000LL;\n+      ts.tv_nsec = abs % 1000000000LL;\n+\n+      err = 0;\n \n-      ns += runtime_nanotime ();\n-      ts.tv_sec = ns / 1000000000LL;\n-      ts.tv_nsec = ns % 1000000000LL;\n-      r = sem_timedwait ((sem_t *) m->waitsema, &ts);\n+#ifdef HAVE_SEM_TIMEDWAIT\n+      r = sem_timedwait (&sem->sem, &ts);\n       if (r != 0)\n+\terr = errno;\n+#else\n+      if (pthread_mutex_lock (&sem->mutex) != 0)\n+\truntime_throw (\"pthread_mutex_lock\");\n+\n+      while ((r = sem_trywait (&sem->sem)) != 0)\n \t{\n-\t  if (errno == ETIMEDOUT || errno == EINTR)\n+\t  r = pthread_cond_timedwait (&sem->cond, &sem->mutex, &ts);\n+\t  if (r != 0)\n+\t    {\n+\t      err = r;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (pthread_mutex_unlock (&sem->mutex) != 0)\n+\truntime_throw (\"pthread_mutex_unlock\");\n+#endif\n+\n+      if (err != 0)\n+\t{\n+\t  if (err == ETIMEDOUT || err == EAGAIN || err == EINTR)\n \t    return -1;\n \t  runtime_throw (\"sema_timedwait\");\n \t}\n       return 0;\n     }\n \n-  while (sem_wait ((sem_t *) m->waitsema) != 0)\n+  while (sem_wait (&sem->sem) != 0)\n     {\n       if (errno == EINTR)\n \tcontinue;\n@@ -64,8 +119,20 @@ runtime_semasleep (int64 ns)\n void\n runtime_semawakeup (M *mp)\n {\n-  if (sem_post ((sem_t *) mp->waitsema) != 0)\n+  struct go_sem *sem;\n+\n+  sem = (struct go_sem *) mp->waitsema;\n+  if (sem_post (&sem->sem) != 0)\n     runtime_throw (\"sem_post\");\n+\n+#ifndef HAVE_SEM_TIMEDWAIT\n+  if (pthread_mutex_lock (&sem->mutex) != 0)\n+    runtime_throw (\"pthread_mutex_lock\");\n+  if (pthread_cond_broadcast (&sem->cond) != 0)\n+    runtime_throw (\"pthread_cond_broadcast\");\n+  if (pthread_mutex_unlock (&sem->mutex) != 0)\n+    runtime_throw (\"pthread_mutex_unlock\");\n+#endif\n }\n \n void"}]}