{"sha": "0358d788d238ba7407648962f40026bd8c190308", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM1OGQ3ODhkMjM4YmE3NDA3NjQ4OTYyZjQwMDI2YmQ4YzE5MDMwOA==", "commit": {"author": {"name": "Renlin Li", "email": "renlin.li@arm.com", "date": "2018-11-21T14:29:19Z"}, "committer": {"name": "Renlin Li", "email": "renlin@gcc.gnu.org", "date": "2018-11-21T14:29:19Z"}, "message": "[PATCH][PR84877]Dynamically align the address for local parameter copy on the stack when required alignment is larger than MAX_SUPPORTED_STACK_ALIGNMENT\n\n\nAs described in PR84877. https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84877\nThe local copy of parameter on stack is not aligned.\n\nFor BLKmode paramters, a local copy on the stack will be saved.\nThere are three cases:\n1) arguments passed partially on the stack, partially via registers.\n2) arguments passed fully on the stack.\n3) arguments passed via registers.\n\nAfter the change here, in all three cases, the stack slot for the local\nparameter copy is aligned by the data type.\nThe stack slot is the DECL_RTL of the parameter. All the references thereafter\nin the function will refer to this RTL.\n\nTo populate the local copy on the stack,\nFor case 1) and 2), there are operations to move data from the caller's stack\n(from incoming rtl) into callee's stack.\nFor case 3), the registers are directly saved into the stack slot.\n\nIn all cases, the destination address is properly aligned.\nBut for case 1) and case 2), the source address is not aligned by the type.\nIt is defined by the PCS how the arguments are prepared.\nThe block move operation is fulfilled by emit_block_move (). As far as I can see,\nit will use the smaller alignment of source and destination.\nThis looks fine as long as we don't use instructions which requires a strict\nlarger alignment than the address actually has.\n\nHere, it only changes receiving parameters.\nThe function assign_stack_local_1 will be called in various places.\nUsually, the caller will constraint the ALIGN parameter.\nFor example via STACK_SLOT_ALIGNMENT macro.\nassign_parm_setup_block will call assign_stack_local () with alignment from the\nparameter type which in this case could be\nlarger than MAX_SUPPORTED_STACK_ALIGNMENT.\n\nThe alignment operation for parameter copy on the stack is similar to stack vars.\nFirst, enough space is reserved on the stack. The size is fixed at compile time.\nInstructions are emitted to dynamically get an aligned address at runtime\nwithin this piece of memory.\n\nThis will unavoidably increase the usage of stack. However, it really depends on\nhow many over-aligned parameters are passed by value.\n\n\ngcc/\n\n2018-11-21  Renlin Li  <renlin.li@arm.com>\n\n\tPR middle-end/84877\n\t* explow.h (get_dynamic_stack_size): Declare it as external.\n\t* explow.c (record_new_stack_level): Remove function static attribute.\n\t* function.c (assign_stack_local_1): Dynamically align the stack slot\n\taddr for parameter copy on the stack.\n\ngcc/testsuite/\n\n2018-11-21  Renlin Li  <renlin.li@arm.com>\n\n\tPR middle-end/84877\n\t* gcc.dg/pr84877.c: New.\n\nFrom-SVN: r266345", "tree": {"sha": "bcd09aa19909fcbc6ad37c8776a9914f1d3d98ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcd09aa19909fcbc6ad37c8776a9914f1d3d98ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0358d788d238ba7407648962f40026bd8c190308", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0358d788d238ba7407648962f40026bd8c190308", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0358d788d238ba7407648962f40026bd8c190308", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0358d788d238ba7407648962f40026bd8c190308/comments", "author": null, "committer": null, "parents": [{"sha": "566422e03b34c8c934b878bf7b0af2fab3b1fb5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/566422e03b34c8c934b878bf7b0af2fab3b1fb5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/566422e03b34c8c934b878bf7b0af2fab3b1fb5f"}], "stats": {"total": 120, "additions": 110, "deletions": 10}, "files": [{"sha": "e0eedf712bad602e3904b979b89e1d20fd645772", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0358d788d238ba7407648962f40026bd8c190308/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0358d788d238ba7407648962f40026bd8c190308/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0358d788d238ba7407648962f40026bd8c190308", "patch": "@@ -1,3 +1,11 @@\n+2018-11-21  Renlin Li  <renlin.li@arm.com>\n+\n+\tPR middle-end/84877\n+\t* explow.h (get_dynamic_stack_size): Declare it as external.\n+\t* explow.c (record_new_stack_level): Remove function static attribute.\n+\t* function.c (assign_stack_local_1): Dynamically align the stack slot\n+\taddr for parameter copy on the stack.\n+\n 2018-11-21  Richard Biener  <rguenther@suse.de>\n \n \tPR bootstrap/88133"}, {"sha": "2c5de12dee17b962207027260dee4f4ec1e355b3", "filename": "gcc/explow.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0358d788d238ba7407648962f40026bd8c190308/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0358d788d238ba7407648962f40026bd8c190308/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=0358d788d238ba7407648962f40026bd8c190308", "patch": "@@ -1176,9 +1176,10 @@ record_new_stack_level (void)\n   if (targetm_common.except_unwind_info (&global_options) == UI_SJLJ)\n     update_sjlj_context ();\n }\n-\f\n+\n /* Return an rtx doing runtime alignment to REQUIRED_ALIGN on TARGET.  */\n-static rtx\n+\n+rtx\n align_dynamic_address (rtx target, unsigned required_align)\n {\n   /* CEIL_DIV_EXPR needs to worry about the addition overflowing,"}, {"sha": "b263d353b84b9c10d04b9a8d7257c14c1c7b7ccc", "filename": "gcc/explow.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0358d788d238ba7407648962f40026bd8c190308/gcc%2Fexplow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0358d788d238ba7407648962f40026bd8c190308/gcc%2Fexplow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.h?ref=0358d788d238ba7407648962f40026bd8c190308", "patch": "@@ -104,6 +104,9 @@ extern void get_dynamic_stack_size (rtx *, unsigned, unsigned, HOST_WIDE_INT *);\n /* Returns the address of the dynamic stack space without allocating it.  */\n extern rtx get_dynamic_stack_base (poly_int64, unsigned);\n \n+/* Return an rtx doing runtime alignment to REQUIRED_ALIGN on TARGET.  */\n+extern rtx align_dynamic_address (rtx, unsigned);\n+\n /* Emit one stack probe at ADDRESS, an address within the stack.  */\n extern void emit_stack_probe (rtx);\n "}, {"sha": "954e9468f01f6d325bd34167f023eae374de5934", "filename": "gcc/function.c", "status": "modified", "additions": 53, "deletions": 8, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0358d788d238ba7407648962f40026bd8c190308/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0358d788d238ba7407648962f40026bd8c190308/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0358d788d238ba7407648962f40026bd8c190308", "patch": "@@ -377,6 +377,7 @@ assign_stack_local_1 (machine_mode mode, poly_int64 size,\n   poly_int64 bigend_correction = 0;\n   poly_int64 slot_offset = 0, old_frame_offset;\n   unsigned int alignment, alignment_in_bits;\n+  bool dynamic_align_addr = false;\n \n   if (align == 0)\n     {\n@@ -395,14 +396,20 @@ assign_stack_local_1 (machine_mode mode, poly_int64 size,\n \n   alignment_in_bits = alignment * BITS_PER_UNIT;\n \n-  /* Ignore alignment if it exceeds MAX_SUPPORTED_STACK_ALIGNMENT.  */\n   if (alignment_in_bits > MAX_SUPPORTED_STACK_ALIGNMENT)\n     {\n-      alignment_in_bits = MAX_SUPPORTED_STACK_ALIGNMENT;\n-      alignment = alignment_in_bits / BITS_PER_UNIT;\n+      /* If the required alignment exceeds MAX_SUPPORTED_STACK_ALIGNMENT and\n+\t it is not OK to reduce it.  Align the slot dynamically.  */\n+      if (mode == BLKmode && (kind & ASLK_REDUCE_ALIGN) == 0)\n+\tdynamic_align_addr = true;\n+      else\n+\t{\n+\t  alignment_in_bits = MAX_SUPPORTED_STACK_ALIGNMENT;\n+\t  alignment = MAX_SUPPORTED_STACK_ALIGNMENT / BITS_PER_UNIT;\n+\t}\n     }\n \n-  if (SUPPORTS_STACK_ALIGNMENT)\n+  if (SUPPORTS_STACK_ALIGNMENT && !dynamic_align_addr)\n     {\n       if (crtl->stack_alignment_estimated < alignment_in_bits)\n \t{\n@@ -432,10 +439,42 @@ assign_stack_local_1 (machine_mode mode, poly_int64 size,\n \t}\n     }\n \n-  if (crtl->stack_alignment_needed < alignment_in_bits)\n-    crtl->stack_alignment_needed = alignment_in_bits;\n-  if (crtl->max_used_stack_slot_alignment < alignment_in_bits)\n-    crtl->max_used_stack_slot_alignment = alignment_in_bits;\n+  /* Handle overalignment here for parameter copy on the stack.\n+     Reserved enough space for it and dynamically align the address.\n+     No free frame_space is added here.  */\n+  if (dynamic_align_addr)\n+    {\n+      rtx allocsize = gen_int_mode (size, Pmode);\n+      get_dynamic_stack_size (&allocsize, 0, alignment_in_bits, NULL);\n+\n+      /* This is the size of space needed to accommodate required size of data\n+\t with given alignment.  */\n+      poly_int64 len = rtx_to_poly_int64 (allocsize);\n+      old_frame_offset = frame_offset;\n+\n+      if (FRAME_GROWS_DOWNWARD)\n+\t{\n+\t  frame_offset -= len;\n+\t  try_fit_stack_local (frame_offset, len, len,\n+\t\t\t       PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT,\n+\t\t\t       &slot_offset);\n+\t}\n+      else\n+\t{\n+\t  frame_offset += len;\n+\t  try_fit_stack_local (old_frame_offset, len, len,\n+\t\t\t       PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT,\n+\t\t\t       &slot_offset);\n+\t}\n+      goto found_space;\n+    }\n+  else\n+    {\n+      if (crtl->stack_alignment_needed < alignment_in_bits)\n+\tcrtl->stack_alignment_needed = alignment_in_bits;\n+      if (crtl->max_used_stack_slot_alignment < alignment_in_bits)\n+\tcrtl->max_used_stack_slot_alignment = alignment_in_bits;\n+    }\n \n   if (mode != BLKmode || maybe_ne (size, 0))\n     {\n@@ -522,6 +561,12 @@ assign_stack_local_1 (machine_mode mode, poly_int64 size,\n \t\t\t  (slot_offset + bigend_correction,\n \t\t\t   Pmode));\n \n+  if (dynamic_align_addr)\n+    {\n+      addr = align_dynamic_address (addr, alignment_in_bits);\n+      mark_reg_pointer (addr, alignment_in_bits);\n+    }\n+\n   x = gen_rtx_MEM (mode, addr);\n   set_mem_align (x, alignment_in_bits);\n   MEM_NOTRAP_P (x) = 1;"}, {"sha": "056199612a455e091c80ceb17a95d496f9cb9d9d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0358d788d238ba7407648962f40026bd8c190308/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0358d788d238ba7407648962f40026bd8c190308/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0358d788d238ba7407648962f40026bd8c190308", "patch": "@@ -1,3 +1,8 @@\n+2018-11-21  Renlin Li  <renlin.li@arm.com>\n+\n+\tPR middle-end/84877\n+\t* gcc.dg/pr84877.c: New.\n+\n 2018-11-21  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/87317"}, {"sha": "8a34dd4fb66de169d469c17b458c3745577bef06", "filename": "gcc/testsuite/gcc.dg/pr84877.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0358d788d238ba7407648962f40026bd8c190308/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84877.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0358d788d238ba7407648962f40026bd8c190308/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84877.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84877.c?ref=0358d788d238ba7407648962f40026bd8c190308", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <inttypes.h>\n+\n+struct U {\n+    int M0;\n+    int M1;\n+} __attribute ((aligned (16)));\n+\n+volatile struct U p0 = {1, 0};\n+\n+void __attribute__ ((noinline))\n+foo (struct U p)\n+{\n+\n+  volatile intptr_t mask = 0b1111;\n+  volatile int dummy[2];\n+  struct U p1 = p;\n+  dummy[1] = p.M0;\n+\n+  if ((intptr_t)(&p1) & mask)\n+    __builtin_abort ();\n+  if ((intptr_t)(&p) & mask)\n+    __builtin_abort ();\n+\n+  if (p1.M0 != dummy[1])\n+    __builtin_abort ();\n+  if (p1.M1 != p.M1)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  foo (p0);\n+  return 0;\n+}"}]}