{"sha": "705debec1e0d71c1d6c0c3e7f9346c8eed391111", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA1ZGViZWMxZTBkNzFjMWQ2YzBjM2U3ZjkzNDZjOGVlZDM5MTExMQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-08-09T13:51:33Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-08-09T13:51:33Z"}, "message": "stl_bvector.h: Trivial formatting fixes.\n\n2004-08-09  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_bvector.h: Trivial formatting fixes.\n\n2004-08-09  Paolo Carlini  <pcarlini@suse.de>\n\n\t* src/ios.cc (ios_base::_M_grow_words): Uglify the names.\n\nFrom-SVN: r85716", "tree": {"sha": "560cb9e35acad2d161ada29e760f062ccc7eaf0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/560cb9e35acad2d161ada29e760f062ccc7eaf0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/705debec1e0d71c1d6c0c3e7f9346c8eed391111", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/705debec1e0d71c1d6c0c3e7f9346c8eed391111", "html_url": "https://github.com/Rust-GCC/gccrs/commit/705debec1e0d71c1d6c0c3e7f9346c8eed391111", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/705debec1e0d71c1d6c0c3e7f9346c8eed391111/comments", "author": null, "committer": null, "parents": [{"sha": "27f577e57d7ac0b2064bb36e5df8d7e2491ea17a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27f577e57d7ac0b2064bb36e5df8d7e2491ea17a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27f577e57d7ac0b2064bb36e5df8d7e2491ea17a"}], "stats": {"total": 445, "additions": 260, "deletions": 185}, "files": [{"sha": "816c4e7758017726b5c5dd6de35a5aaf681b5d3a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705debec1e0d71c1d6c0c3e7f9346c8eed391111/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705debec1e0d71c1d6c0c3e7f9346c8eed391111/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=705debec1e0d71c1d6c0c3e7f9346c8eed391111", "patch": "@@ -1,3 +1,11 @@\n+2004-08-09  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_bvector.h: Trivial formatting fixes.\n+\n+2004-08-09  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* src/ios.cc (ios_base::_M_grow_words): Uglify the names.\n+\n 2004-08-07  Jonathan Wakely  <redi@gcc.gnu.org>\n \t    Paolo Carlini  <pcarlini@suse.de>\n \t"}, {"sha": "a8f1b696a55efb4b6de738a108e0db9496401df5", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 237, "deletions": 170, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705debec1e0d71c1d6c0c3e7f9346c8eed391111/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705debec1e0d71c1d6c0c3e7f9346c8eed391111/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=705debec1e0d71c1d6c0c3e7f9346c8eed391111", "patch": "@@ -76,7 +76,8 @@ namespace _GLIBCXX_STD\n \n     _Bit_reference() : _M_p(0), _M_mask(0) { }\n \n-    operator bool() const { return !!(*_M_p & _M_mask); }\n+    operator bool() const\n+    { return !!(*_M_p & _M_mask); }\n \n     _Bit_reference&\n     operator=(bool __x)\n@@ -101,7 +102,8 @@ namespace _GLIBCXX_STD\n     { return !bool(*this) && bool(__x); }\n \n     void\n-    flip() { *_M_p ^= _M_mask; }\n+    flip()\n+    { *_M_p ^= _M_mask; }\n   };\n \n   struct _Bit_iterator_base : public iterator<random_access_iterator_tag, bool>\n@@ -188,11 +190,13 @@ namespace _GLIBCXX_STD\n     typedef _Bit_iterator   iterator;\n \n     _Bit_iterator() : _Bit_iterator_base(0, 0) { }\n+\n     _Bit_iterator(_Bit_type * __x, unsigned int __y)\n     : _Bit_iterator_base(__x, __y) { }\n \n     reference\n-    operator*() const { return reference(_M_p, 1UL << _M_offset); }\n+    operator*() const\n+    { return reference(_M_p, 1UL << _M_offset); }\n \n     iterator&\n     operator++()\n@@ -258,8 +262,8 @@ namespace _GLIBCXX_STD\n   };\n \n   inline _Bit_iterator\n-  operator+(ptrdiff_t __n, const _Bit_iterator& __x) { return __x + __n; }\n-\n+  operator+(ptrdiff_t __n, const _Bit_iterator& __x)\n+  { return __x + __n; }\n \n   struct _Bit_const_iterator : public _Bit_iterator_base\n   {\n@@ -269,8 +273,10 @@ namespace _GLIBCXX_STD\n     typedef _Bit_const_iterator  const_iterator;\n \n     _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }\n+\n     _Bit_const_iterator(_Bit_type * __x, unsigned int __y)\n     : _Bit_iterator_base(__x, __y) { }\n+\n     _Bit_const_iterator(const _Bit_iterator& __x)\n     : _Bit_iterator_base(__x._M_p, __x._M_offset) { }\n \n@@ -370,7 +376,8 @@ namespace _GLIBCXX_STD\n \n       _Bvector_base(const allocator_type& __a) : _M_impl(__a) { }\n \n-      ~_Bvector_base() { this->_M_deallocate(); }\n+      ~_Bvector_base()\n+      { this->_M_deallocate(); }\n \n     protected:\n       _Bvector_impl _M_impl;\n@@ -384,7 +391,7 @@ namespace _GLIBCXX_STD\n       {\n \tif (_M_impl._M_start._M_p)\n \t  _M_impl.deallocate(_M_impl._M_start._M_p,\n-\t\t\t    _M_impl._M_end_of_storage - _M_impl._M_start._M_p);\n+\t\t\t     _M_impl._M_end_of_storage - _M_impl._M_start._M_p);\n       }\n     };\n } // namespace std\n@@ -440,16 +447,19 @@ template<typename _Alloc>\n     using _Bvector_base<_Alloc>::_M_deallocate;\n \n   protected:\n-    void _M_initialize(size_type __n)\n+    void\n+    _M_initialize(size_type __n)\n     {\n       _Bit_type* __q = this->_M_allocate(__n);\n-      this->_M_impl._M_end_of_storage = __q \n-\t                               + (__n + _S_word_bit - 1) / _S_word_bit;\n+      this->_M_impl._M_end_of_storage = (__q\n+\t\t\t\t\t + ((__n + _S_word_bit - 1)\n+\t\t\t\t\t    / _S_word_bit));\n       this->_M_impl._M_start = iterator(__q, 0);\n       this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);\n     }\n \n-    void _M_insert_aux(iterator __position, bool __x)\n+    void\n+    _M_insert_aux(iterator __position, bool __x)\n     {\n       if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)\n \t{\n@@ -467,129 +477,154 @@ template<typename _Alloc>\n \t  *__i++ = __x;\n \t  this->_M_impl._M_finish = std::copy(__position, end(), __i);\n \t  this->_M_deallocate();\n-\t  this->_M_impl._M_end_of_storage = __q + (__len + _S_word_bit - 1)\n-\t\t\t\t    / _S_word_bit;\n+\t  this->_M_impl._M_end_of_storage = (__q + ((__len + _S_word_bit - 1)\n+\t\t\t\t\t\t    / _S_word_bit));\n \t  this->_M_impl._M_start = iterator(__q, 0);\n \t}\n     }\n \n     template<class _InputIterator>\n-    void _M_initialize_range(_InputIterator __first, _InputIterator __last,\n-                             input_iterator_tag)\n-    {\n-      this->_M_impl._M_start = iterator();\n-      this->_M_impl._M_finish = iterator();\n-      this->_M_impl._M_end_of_storage = 0;\n-      for ( ; __first != __last; ++__first)\n-        push_back(*__first);\n-    }\n+      void\n+      _M_initialize_range(_InputIterator __first, _InputIterator __last,\n+\t\t\t  input_iterator_tag)\n+      {\n+\tthis->_M_impl._M_start = iterator();\n+\tthis->_M_impl._M_finish = iterator();\n+\tthis->_M_impl._M_end_of_storage = 0;\n+\tfor (; __first != __last; ++__first)\n+\t  push_back(*__first);\n+      }\n \n     template<class _ForwardIterator>\n-    void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n-                             forward_iterator_tag)\n-    {\n-      const size_type __n = std::distance(__first, __last);\n-      _M_initialize(__n);\n-      std::copy(__first, __last, this->_M_impl._M_start);\n-    }\n+      void\n+      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t\t  forward_iterator_tag)\n+      {\n+\tconst size_type __n = std::distance(__first, __last);\n+\t_M_initialize(__n);\n+\tstd::copy(__first, __last, this->_M_impl._M_start);\n+      }\n \n     template<class _InputIterator>\n-    void _M_insert_range(iterator __pos, _InputIterator __first, \n-\t\t\t _InputIterator __last, input_iterator_tag)\n-    {\n-      for ( ; __first != __last; ++__first)\n-\t{\n-\t  __pos = insert(__pos, *__first);\n-\t  ++__pos;\n-\t}\n-    }\n+      void\n+      _M_insert_range(iterator __pos, _InputIterator __first, \n+\t\t      _InputIterator __last, input_iterator_tag)\n+      {\n+\tfor (; __first != __last; ++__first)\n+\t  {\n+\t    __pos = insert(__pos, *__first);\n+\t    ++__pos;\n+\t  }\n+      }\n \n     template<class _ForwardIterator>\n-    void _M_insert_range(iterator __position, _ForwardIterator __first, \n-\t\t\t _ForwardIterator __last, forward_iterator_tag)\n-    {\n-      if (__first != __last)\n-\t{\n-\t  size_type __n = std::distance(__first, __last);\n-\t  if (capacity() - size() >= __n)\n-\t    {\n-\t      std::copy_backward(__position, end(),\n-\t\t\t       this->_M_impl._M_finish + difference_type(__n));\n-\t      std::copy(__first, __last, __position);\n-\t      this->_M_impl._M_finish += difference_type(__n);\n-\t    }\n-\t  else\n-\t    {\n-\t      const size_type __len = size() + std::max(size(), __n);\n-\t      _Bit_type * __q = this->_M_allocate(__len);\n-\t      iterator __i = std::copy(begin(), __position, iterator(__q, 0));\n-\t      __i = std::copy(__first, __last, __i);\n-\t      this->_M_impl._M_finish = std::copy(__position, end(), __i);\n-\t      this->_M_deallocate();\n-\t      this->_M_impl._M_end_of_storage = __q + (__len + _S_word_bit - 1)\n-\t\t                                / _S_word_bit;\n-\t      this->_M_impl._M_start = iterator(__q, 0);\n-\t    }\n-\t}\n-    }\n+      void\n+      _M_insert_range(iterator __position, _ForwardIterator __first, \n+\t\t      _ForwardIterator __last, forward_iterator_tag)\n+      {\n+\tif (__first != __last)\n+\t  {\n+\t    size_type __n = std::distance(__first, __last);\n+\t    if (capacity() - size() >= __n)\n+\t      {\n+\t\tstd::copy_backward(__position, end(),\n+\t\t\t\t   this->_M_impl._M_finish\n+\t\t\t\t   + difference_type(__n));\n+\t\tstd::copy(__first, __last, __position);\n+\t\tthis->_M_impl._M_finish += difference_type(__n);\n+\t      }\n+\t    else\n+\t      {\n+\t\tconst size_type __len = size() + std::max(size(), __n);\n+\t\t_Bit_type * __q = this->_M_allocate(__len);\n+\t\titerator __i = std::copy(begin(), __position,\n+\t\t\t\t\t iterator(__q, 0));\n+\t\t__i = std::copy(__first, __last, __i);\n+\t\tthis->_M_impl._M_finish = std::copy(__position, end(), __i);\n+\t\tthis->_M_deallocate();\n+\t\tthis->_M_impl._M_end_of_storage = (__q\n+\t\t\t\t\t\t   + ((__len + _S_word_bit - 1)\n+\t\t\t\t\t\t      / _S_word_bit));\n+\t\tthis->_M_impl._M_start = iterator(__q, 0);\n+\t      }\n+\t  }\n+      }\n \n   public:\n-    iterator begin()\n+    iterator\n+    begin()\n     { return this->_M_impl._M_start; }\n \n-    const_iterator begin() const\n+    const_iterator\n+    begin() const\n     { return this->_M_impl._M_start; }\n \n-    iterator end()\n+    iterator\n+    end()\n     { return this->_M_impl._M_finish; }\n \n-    const_iterator end() const\n+    const_iterator\n+    end() const\n     { return this->_M_impl._M_finish; }\n \n-    reverse_iterator rbegin()\n+    reverse_iterator\n+    rbegin()\n     { return reverse_iterator(end()); }\n \n-    const_reverse_iterator rbegin() const\n+    const_reverse_iterator\n+    rbegin() const\n     { return const_reverse_iterator(end()); }\n \n-    reverse_iterator rend()\n+    reverse_iterator\n+    rend()\n     { return reverse_iterator(begin()); }\n \n-    const_reverse_iterator rend() const\n+    const_reverse_iterator\n+    rend() const\n     { return const_reverse_iterator(begin()); }\n \n-    size_type size() const\n+    size_type\n+    size() const\n     { return size_type(end() - begin()); }\n \n-    size_type max_size() const\n+    size_type\n+    max_size() const\n     { return size_type(-1); }\n \n-    size_type capacity() const\n+    size_type\n+    capacity() const\n     { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)\n \t\t       - begin()); }\n-    bool empty() const\n+    bool\n+    empty() const\n     { return begin() == end(); }\n \n-    reference operator[](size_type __n)\n+    reference\n+    operator[](size_type __n)\n     { return *(begin() + difference_type(__n)); }\n \n-    const_reference operator[](size_type __n) const\n+    const_reference\n+    operator[](size_type __n) const\n     { return *(begin() + difference_type(__n)); }\n \n-    void _M_range_check(size_type __n) const\n+    void\n+    _M_range_check(size_type __n) const\n     {\n       if (__n >= this->size())\n         __throw_out_of_range(__N(\"vector<bool>::_M_range_check\"));\n     }\n \n-    reference at(size_type __n)\n+    reference\n+    at(size_type __n)\n     { _M_range_check(__n); return (*this)[__n]; }\n \n-    const_reference at(size_type __n) const\n+    const_reference\n+    at(size_type __n) const\n     { _M_range_check(__n); return (*this)[__n]; }\n \n-    explicit vector(const allocator_type& __a = allocator_type())\n-      : _Bvector_base<_Alloc>(__a) { }\n+    explicit\n+    vector(const allocator_type& __a = allocator_type())\n+    : _Bvector_base<_Alloc>(__a) { }\n \n     vector(size_type __n, bool __value, \n \t   const allocator_type& __a = allocator_type())\n@@ -600,28 +635,31 @@ template<typename _Alloc>\n \t\t__value ? ~0 : 0);\n     }\n \n-    explicit vector(size_type __n)\n+    explicit\n+    vector(size_type __n)\n     : _Bvector_base<_Alloc>(allocator_type())\n     {\n       _M_initialize(__n);\n       std::fill(this->_M_impl._M_start._M_p, \n \t\tthis->_M_impl._M_end_of_storage, 0);\n     }\n \n-    vector(const vector& __x) : _Bvector_base<_Alloc>(__x.get_allocator())\n+    vector(const vector& __x)\n+    : _Bvector_base<_Alloc>(__x.get_allocator())\n     {\n       _M_initialize(__x.size());\n       std::copy(__x.begin(), __x.end(), this->_M_impl._M_start);\n     }\n \n     // Check whether it's an integral type.  If so, it's not an iterator.\n     template<class _Integer>\n-    void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n-    {\n-      _M_initialize(__n);\n-      std::fill(this->_M_impl._M_start._M_p, \n-\t\tthis->_M_impl._M_end_of_storage, __x ? ~0 : 0);\n-    }\n+      void\n+      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n+      {\n+\t_M_initialize(__n);\n+\tstd::fill(this->_M_impl._M_start._M_p, \n+\t\t  this->_M_impl._M_end_of_storage, __x ? ~0 : 0);\n+      }\n \n     template<class _InputIterator>\n       void \n@@ -633,15 +671,16 @@ template<typename _Alloc>\n     template<class _InputIterator>\n       vector(_InputIterator __first, _InputIterator __last,\n \t     const allocator_type& __a = allocator_type())\n-    : _Bvector_base<_Alloc>(__a)\n-    {\n-      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-      _M_initialize_dispatch(__first, __last, _Integral());\n-    }\n+      : _Bvector_base<_Alloc>(__a)\n+      {\n+\ttypedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t_M_initialize_dispatch(__first, __last, _Integral());\n+      }\n \n     ~vector() { }\n \n-    vector& operator=(const vector& __x)\n+    vector&\n+    operator=(const vector& __x)\n     {\n       if (&__x == this)\n \treturn *this;\n@@ -660,7 +699,8 @@ template<typename _Alloc>\n     // The range version is a member template, so we dispatch on whether\n     // or not the type is an integer.\n \n-    void _M_fill_assign(size_t __n, bool __x)\n+    void\n+    _M_fill_assign(size_t __n, bool __x)\n     {\n       if (__n > size())\n \t{\n@@ -676,55 +716,62 @@ template<typename _Alloc>\n \t}\n     }\n \n-    void assign(size_t __n, bool __x)\n+    void\n+    assign(size_t __n, bool __x)\n     { _M_fill_assign(__n, __x); }\n \n     template<class _InputIterator>\n-    void assign(_InputIterator __first, _InputIterator __last)\n-    {\n-      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-      _M_assign_dispatch(__first, __last, _Integral());\n-    }\n+      void\n+      assign(_InputIterator __first, _InputIterator __last)\n+      {\n+\ttypedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t_M_assign_dispatch(__first, __last, _Integral());\n+      }\n \n     template<class _Integer>\n-    void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-    { _M_fill_assign((size_t) __n, (bool) __val); }\n+      void\n+      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+      { _M_fill_assign((size_t) __n, (bool) __val); }\n \n     template<class _InputIterator>\n-    void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n-\t\t\t    __false_type)\n-    { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n+      void\n+      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n+\t\t\t __false_type)\n+      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n \n     template<class _InputIterator>\n-    void _M_assign_aux(_InputIterator __first, _InputIterator __last,\n-                       input_iterator_tag)\n-    {\n-      iterator __cur = begin();\n-      for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n-        *__cur = *__first;\n-      if (__first == __last)\n-        erase(__cur, end());\n-      else\n-        insert(end(), __first, __last);\n-    }\n-\n+      void\n+      _M_assign_aux(_InputIterator __first, _InputIterator __last,\n+\t\t    input_iterator_tag)\n+      {\n+\titerator __cur = begin();\n+\tfor (; __first != __last && __cur != end(); ++__cur, ++__first)\n+\t  *__cur = *__first;\n+\tif (__first == __last)\n+\t  erase(__cur, end());\n+\telse\n+\t  insert(end(), __first, __last);\n+      }\n+    \n     template<class _ForwardIterator>\n-    void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-                       forward_iterator_tag)\n-    {\n-      const size_type __len = std::distance(__first, __last);\n-      if (__len < size())\n-        erase(std::copy(__first, __last, begin()), end());\n-      else\n-\t{\n-\t  _ForwardIterator __mid = __first;\n-\t  std::advance(__mid, size());\n-\t  std::copy(__first, __mid, begin());\n-\t  insert(end(), __mid, __last);\n-\t}\n-    }\n+      void\n+      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t    forward_iterator_tag)\n+      {\n+\tconst size_type __len = std::distance(__first, __last);\n+\tif (__len < size())\n+\t  erase(std::copy(__first, __last, begin()), end());\n+\telse\n+\t  {\n+\t    _ForwardIterator __mid = __first;\n+\t    std::advance(__mid, size());\n+\t    std::copy(__first, __mid, begin());\n+\t    insert(end(), __mid, __last);\n+\t  }\n+      }\n \n-    void reserve(size_type __n)\n+    void\n+    reserve(size_type __n)\n     {\n       if (__n > this->max_size())\n \t__throw_length_error(__N(\"vector::reserve\"));\n@@ -735,31 +782,38 @@ template<typename _Alloc>\n \t\t\t\t\t      iterator(__q, 0));\n \t  this->_M_deallocate();\n \t  this->_M_impl._M_start = iterator(__q, 0);\n-\t  this->_M_impl._M_end_of_storage = __q + (__n + _S_word_bit - 1) / _S_word_bit;\n+\t  this->_M_impl._M_end_of_storage = (__q + (__n + _S_word_bit - 1)\n+\t\t\t\t\t     / _S_word_bit);\n \t}\n     }\n \n-    reference front()\n+    reference\n+    front()\n     { return *begin(); }\n \n-    const_reference front() const\n+    const_reference\n+    front() const\n     { return *begin(); }\n \n-    reference back()\n+    reference\n+    back()\n     { return *(end() - 1); }\n \n-    const_reference back() const\n+    const_reference\n+    back() const\n     { return *(end() - 1); }\n \n-    void push_back(bool __x)\n+    void\n+    push_back(bool __x)\n     {\n       if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)\n         *this->_M_impl._M_finish++ = __x;\n       else\n         _M_insert_aux(end(), __x);\n     }\n \n-    void swap(vector<bool, _Alloc>& __x)\n+    void\n+    swap(vector<bool, _Alloc>& __x)\n     {\n       std::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n       std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n@@ -768,14 +822,16 @@ template<typename _Alloc>\n     }\n \n     // [23.2.5]/1, third-to-last entry in synopsis listing\n-    static void swap(reference __x, reference __y)\n+    static void\n+    swap(reference __x, reference __y)\n     {\n       bool __tmp = __x;\n       __x = __y;\n       __y = __tmp;\n     }\n \n-    iterator insert(iterator __position, bool __x = bool())\n+    iterator\n+    insert(iterator __position, bool __x = bool())\n     {\n       const difference_type __n = __position - begin();\n       if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage\n@@ -789,26 +845,30 @@ template<typename _Alloc>\n     // Check whether it's an integral type.  If so, it's not an iterator.\n \n     template<class _Integer>\n-    void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n-                            __true_type)\n-    { _M_fill_insert(__pos, __n, __x); }\n+      void\n+      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n+\t\t\t __true_type)\n+      { _M_fill_insert(__pos, __n, __x); }\n \n     template<class _InputIterator>\n-    void _M_insert_dispatch(iterator __pos,\n-                            _InputIterator __first, _InputIterator __last,\n-                            __false_type)\n-    { _M_insert_range(__pos, __first, __last,\n-\t\t      std::__iterator_category(__first)); }\n+      void\n+      _M_insert_dispatch(iterator __pos,\n+\t\t\t _InputIterator __first, _InputIterator __last,\n+\t\t\t __false_type)\n+      { _M_insert_range(__pos, __first, __last,\n+\t\t\tstd::__iterator_category(__first)); }\n \n     template<class _InputIterator>\n-    void insert(iterator __position,\n-                _InputIterator __first, _InputIterator __last)\n-    {\n-      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-      _M_insert_dispatch(__position, __first, __last, _Integral());\n-    }\n+      void\n+      insert(iterator __position,\n+\t     _InputIterator __first, _InputIterator __last)\n+      {\n+\ttypedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t_M_insert_dispatch(__position, __first, __last, _Integral());\n+      }\n \n-    void _M_fill_insert(iterator __position, size_type __n, bool __x)\n+    void\n+    _M_fill_insert(iterator __position, size_type __n, bool __x)\n     {\n       if (__n == 0)\n \treturn;\n@@ -828,48 +888,55 @@ template<typename _Alloc>\n \t  this->_M_impl._M_finish = std::copy(__position, end(),\n \t\t\t\t\t      __i + difference_type(__n));\n \t  this->_M_deallocate();\n-\t  this->_M_impl._M_end_of_storage = __q + (__len + _S_word_bit - 1)\n-\t                                    / _S_word_bit;\n+\t  this->_M_impl._M_end_of_storage = (__q + ((__len + _S_word_bit - 1)\n+\t\t\t\t\t\t    / _S_word_bit));\n \t  this->_M_impl._M_start = iterator(__q, 0);\n \t}\n     }\n \n-    void insert(iterator __position, size_type __n, bool __x)\n+    void\n+    insert(iterator __position, size_type __n, bool __x)\n     { _M_fill_insert(__position, __n, __x); }\n \n-    void pop_back()\n+    void\n+    pop_back()\n     { --this->_M_impl._M_finish; }\n \n-    iterator erase(iterator __position)\n+    iterator\n+    erase(iterator __position)\n     {\n       if (__position + 1 != end())\n         std::copy(__position + 1, end(), __position);\n       --this->_M_impl._M_finish;\n       return __position;\n     }\n \n-    iterator erase(iterator __first, iterator __last)\n+    iterator\n+    erase(iterator __first, iterator __last)\n     {\n       this->_M_impl._M_finish = std::copy(__last, end(), __first);\n       return __first;\n     }\n \n-    void resize(size_type __new_size, bool __x = bool())\n+    void\n+    resize(size_type __new_size, bool __x = bool())\n     {\n       if (__new_size < size())\n         erase(begin() + difference_type(__new_size), end());\n       else\n         insert(end(), __new_size - size(), __x);\n     }\n \n-    void flip()\n+    void\n+    flip()\n     {\n       for (_Bit_type * __p = this->_M_impl._M_start._M_p;\n \t   __p != this->_M_impl._M_end_of_storage; ++__p)\n         *__p = ~*__p;\n     }\n \n-    void clear()\n+    void\n+    clear()\n     { erase(begin(), end()); }\n   };\n } // namespace std"}, {"sha": "09b292916f1cc321be5f47fabb0386d60e6ea226", "filename": "libstdc++-v3/src/ios.cc", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705debec1e0d71c1d6c0c3e7f9346c8eed391111/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705debec1e0d71c1d6c0c3e7f9346c8eed391111/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fios.cc?ref=705debec1e0d71c1d6c0c3e7f9346c8eed391111", "patch": "@@ -149,32 +149,32 @@ namespace std\n \n   // 27.4.2.5  iword/pword storage\n   ios_base::_Words&\n-  ios_base::_M_grow_words(int ix, bool iword)\n+  ios_base::_M_grow_words(int __ix, bool __iword)\n   {\n-    // Precondition: _M_word_size <= ix\n-    int newsize = _S_local_word_size;\n-    _Words* words = _M_local_word;\n-    if (ix > _S_local_word_size - 1)\n+    // Precondition: _M_word_size <= __ix\n+    int __newsize = _S_local_word_size;\n+    _Words* __words = _M_local_word;\n+    if (__ix > _S_local_word_size - 1)\n       {\n-\tif (ix < numeric_limits<int>::max())\n+\tif (__ix < numeric_limits<int>::max())\n \t  {\n-\t    newsize = ix + 1;\n+\t    __newsize = __ix + 1;\n \t    try\n-\t      { words = new _Words[newsize]; }\n+\t      { __words = new _Words[__newsize]; }\n \t    catch (...)\n \t      {\n \t\t_M_streambuf_state |= badbit;\n \t\tif (_M_streambuf_state & _M_exception)\n \t\t  __throw_ios_failure(__N(\"ios_base::_M_grow_words \"\n \t\t\t\t      \"allocation failed\"));\n-\t\tif (iword)\n+\t\tif (__iword)\n \t\t  _M_word_zero._M_iword = 0;\n \t\telse\n \t\t  _M_word_zero._M_pword = 0;\n \t\treturn _M_word_zero;\n \t      }\n-\t    for (int i = 0; i < _M_word_size; i++) \n-\t      words[i] = _M_word[i];\n+\t    for (int __i = 0; __i < _M_word_size; __i++) \n+\t      __words[__i] = _M_word[__i];\n \t    if (_M_word && _M_word != _M_local_word) \n \t      {\n \t\tdelete [] _M_word;\n@@ -186,16 +186,16 @@ namespace std\n \t    _M_streambuf_state |= badbit;\n \t    if (_M_streambuf_state & _M_exception)\n \t      __throw_ios_failure(__N(\"ios_base::_M_grow_words is not valid\"));\n-\t    if (iword)\n+\t    if (__iword)\n \t      _M_word_zero._M_iword = 0;\n \t    else\n \t      _M_word_zero._M_pword = 0;\n \t    return _M_word_zero;\n \t  }\n       }\n-    _M_word = words;\n-    _M_word_size = newsize;\n-    return _M_word[ix];\n+    _M_word = __words;\n+    _M_word_size = __newsize;\n+    return _M_word[__ix];\n   }\n \n   void "}]}