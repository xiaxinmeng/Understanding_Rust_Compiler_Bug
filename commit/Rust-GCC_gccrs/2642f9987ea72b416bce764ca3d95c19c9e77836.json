{"sha": "2642f9987ea72b416bce764ca3d95c19c9e77836", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY0MmY5OTg3ZWE3MmI0MTZiY2U3NjRjYTNkOTVjMTljOWU3NzgzNg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-09-26T10:42:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-09-26T10:42:29Z"}, "message": "checks.adb, [...]: Improve warnings for address overlays.\n\n2007-09-26  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb, gnat1drv.adb, sem_util.ads: Improve warnings for address\n\toverlays.\n\n\t* sem_ch13.ads, sem_ch13.adb: Improve warnings for address overlays\n\t(Analyze_Record_Representation_Clause): Suppress junk warning for\n\tmissing component clause.\n\t(Analyze_Attribute_Definition_Clause, case Address): Apply the special\n\ttests for controlled type overlay to composites with controlled\n\tcomponents.\n\t(Analyze_Record_Representation_Clause): Add reference for component name\n\nFrom-SVN: r128785", "tree": {"sha": "c18c110446e28ac9daaa52f59a3c7a207d5e4632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c18c110446e28ac9daaa52f59a3c7a207d5e4632"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2642f9987ea72b416bce764ca3d95c19c9e77836", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2642f9987ea72b416bce764ca3d95c19c9e77836", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2642f9987ea72b416bce764ca3d95c19c9e77836", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2642f9987ea72b416bce764ca3d95c19c9e77836/comments", "author": null, "committer": null, "parents": [{"sha": "6e818918f2c6dab5258d709562aad8a836feaa1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e818918f2c6dab5258d709562aad8a836feaa1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e818918f2c6dab5258d709562aad8a836feaa1f"}], "stats": {"total": 311, "additions": 239, "deletions": 72}, "files": [{"sha": "33696b0003cde9e581c857738790baf2981d21cb", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2642f9987ea72b416bce764ca3d95c19c9e77836/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2642f9987ea72b416bce764ca3d95c19c9e77836/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=2642f9987ea72b416bce764ca3d95c19c9e77836", "patch": "@@ -543,6 +543,7 @@ package body Checks is\n             Error_Msg_FE\n               (\"\\?program execution may be erroneous (RM 13.3(27))\",\n                Aexp, E);\n+            Set_Address_Warning_Posted (AC);\n          end if;\n       end Compile_Time_Bad_Alignment;\n \n@@ -626,6 +627,7 @@ package body Checks is\n                   Error_Msg_FE\n                     (\"\\?program execution may be erroneous\", Aexp, E);\n                   Size_Warning_Output := True;\n+                  Set_Address_Warning_Posted (AC);\n                end if;\n             end if;\n          end;"}, {"sha": "743520ee79953b6400c1929947c56fd901fc0b95", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2642f9987ea72b416bce764ca3d95c19c9e77836/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2642f9987ea72b416bce764ca3d95c19c9e77836/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=2642f9987ea72b416bce764ca3d95c19c9e77836", "patch": "@@ -442,6 +442,7 @@ begin\n       if Compilation_Errors then\n          Treepr.Tree_Dump;\n          Sem_Ch13.Validate_Unchecked_Conversions;\n+         Sem_Ch13.Validate_Address_Clauses;\n          Errout.Output_Messages;\n          Namet.Finalize;\n \n@@ -622,6 +623,7 @@ begin\n          Write_Eol;\n \n          Sem_Ch13.Validate_Unchecked_Conversions;\n+         Sem_Ch13.Validate_Address_Clauses;\n          Errout.Finalize (Last_Call => True);\n          Errout.Output_Messages;\n          Treepr.Tree_Dump;\n@@ -654,6 +656,7 @@ begin\n                    or else Targparm.VM_Target /= No_VM)\n       then\n          Sem_Ch13.Validate_Unchecked_Conversions;\n+         Sem_Ch13.Validate_Address_Clauses;\n          Errout.Finalize (Last_Call => True);\n          Errout.Output_Messages;\n          Write_ALI (Object => False);\n@@ -704,6 +707,11 @@ begin\n \n       Sem_Ch13.Validate_Unchecked_Conversions;\n \n+      --  Validate address clauses (again using alignment values annotated\n+      --  by the backend where possible).\n+\n+      Sem_Ch13.Validate_Address_Clauses;\n+\n       --  Now we complete output of errors, rep info and the tree info. These\n       --  are delayed till now, since it is perfectly possible for gigi to\n       --  generate errors, modify the tree (in particular by setting flags"}, {"sha": "a632d0dfc87dff9546bfbb6d0d570a8168c9c309", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 211, "deletions": 67, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2642f9987ea72b416bce764ca3d95c19c9e77836/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2642f9987ea72b416bce764ca3d95c19c9e77836/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=2642f9987ea72b416bce764ca3d95c19c9e77836", "patch": "@@ -30,6 +30,7 @@ with Errout;   use Errout;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Lib;      use Lib;\n+with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -88,11 +89,6 @@ package body Sem_Ch13 is\n    function Address_Aliased_Entity (N : Node_Id) return Entity_Id;\n    --  If expression N is of the form E'Address, return E\n \n-   procedure Mark_Aliased_Address_As_Volatile (N : Node_Id);\n-   --  This is used for processing of an address representation clause. If\n-   --  the expression N is of the form of K'Address, then the entity that\n-   --  is associated with K is marked as volatile.\n-\n    procedure New_Stream_Subprogram\n      (N    : Node_Id;\n       Ent  : Entity_Id;\n@@ -138,6 +134,41 @@ package body Sem_Ch13 is\n      Table_Increment      => 200,\n      Table_Name           => \"Unchecked_Conversions\");\n \n+   ----------------------------------------\n+   -- Table for Validate_Address_Clauses --\n+   ----------------------------------------\n+\n+   --  If an address clause has the form\n+\n+   --    for X'Address use Expr\n+\n+   --  where Expr is of the form Y'Address or recursively is a reference\n+   --  to a constant of either of these forms, and X and Y are entities of\n+   --  objects, then if Y has a smaller alignment than X, that merits a\n+   --  warning about possible bad alignment. The following table collects\n+   --  address clauses of this kind. We put these in a table so that they\n+   --  can be checked after the back end has completed annotation of the\n+   --  alignments of objects, since we can catch more cases that way.\n+\n+   type Address_Clause_Check_Record is record\n+      N : Node_Id;\n+      --  The address clause\n+\n+      X : Entity_Id;\n+      --  The entity of the object overlaying Y\n+\n+      Y : Entity_Id;\n+      --  The entity of the object being overlaid\n+   end record;\n+\n+   package Address_Clause_Checks is new Table.Table (\n+     Table_Component_Type => Address_Clause_Check_Record,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 20,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Address_Clause_Checks\");\n+\n    ----------------------------\n    -- Address_Aliased_Entity --\n    ----------------------------\n@@ -259,7 +290,7 @@ package body Sem_Ch13 is\n       end loop;\n \n       --  We need to sort the component clauses on the basis of the Position\n-      --  values in the clause, so we can group clauses with the same Position\n+      --  values in the clause, so we can group clauses with the same Position.\n       --  together to determine the relevant machine scalar size.\n \n       declare\n@@ -601,7 +632,6 @@ package body Sem_Ch13 is\n \n             else\n                Get_First_Interp (Expr, I, It);\n-\n                while Present (It.Nam) loop\n                   if Has_Good_Profile (It.Nam) then\n                      Subp := It.Nam;\n@@ -720,11 +750,12 @@ package body Sem_Ch13 is\n                     (\"address clause cannot be given \" &\n                      \"for overloaded subprogram\",\n                      Nam);\n+                  return;\n                end if;\n \n-               --  For subprograms, all address clauses are permitted,\n-               --  and we mark the subprogram as having a deferred freeze\n-               --  so that Gigi will not elaborate it too soon.\n+               --  For subprograms, all address clauses are permitted, and we\n+               --  mark the subprogram as having a deferred freeze so that Gigi\n+               --  will not elaborate it too soon.\n \n                --  Above needs more comments, what is too soon about???\n \n@@ -736,12 +767,15 @@ package body Sem_Ch13 is\n                if Nkind (Parent (N)) = N_Task_Body then\n                   Error_Msg_N\n                     (\"entry address must be specified in task spec\", Nam);\n+                  return;\n                end if;\n \n                --  For entries, we require a constant address\n \n                Check_Constant_Address_Clause (Expr, U_Ent);\n \n+               --  Special checks for task types\n+\n                if Is_Task_Type (Scope (U_Ent))\n                  and then Comes_From_Source (Scope (U_Ent))\n                then\n@@ -751,6 +785,8 @@ package body Sem_Ch13 is\n                     (\"\\?only one task can be declared of this type\", N);\n                end if;\n \n+               --  Entry address clauses are obsolescent\n+\n                Check_Restriction (No_Obsolescent_Features, N);\n \n                if Warn_On_Obsolescent_Feature then\n@@ -761,17 +797,20 @@ package body Sem_Ch13 is\n                     (\"\\use interrupt procedure instead?\", N);\n                end if;\n \n-            --  Case of an address clause for a controlled object:\n-            --  erroneous execution.\n+            --  Case of an address clause for a controlled object which we\n+            --  consider to be erroneous.\n \n-            elsif Is_Controlled (Etype (U_Ent)) then\n+            elsif Is_Controlled (Etype (U_Ent))\n+              or else Has_Controlled_Component (Etype (U_Ent))\n+            then\n                Error_Msg_NE\n                  (\"?controlled object& must not be overlaid\", Nam, U_Ent);\n                Error_Msg_N\n                  (\"\\?Program_Error will be raised at run time\", Nam);\n                Insert_Action (Declaration_Node (U_Ent),\n                  Make_Raise_Program_Error (Loc,\n                    Reason => PE_Overlaid_Controlled_Object));\n+               return;\n \n             --  Case of address clause for a (non-controlled) object\n \n@@ -781,8 +820,9 @@ package body Sem_Ch13 is\n               Ekind (U_Ent) = E_Constant\n             then\n                declare\n-                  Expr : constant Node_Id   := Expression (N);\n-                  Aent : constant Entity_Id := Address_Aliased_Entity (Expr);\n+                  Expr  : constant Node_Id   := Expression (N);\n+                  Aent  : constant Entity_Id := Address_Aliased_Entity (Expr);\n+                  Ent_Y : constant Entity_Id := Find_Overlaid_Object (N);\n \n                begin\n                   --  Exported variables cannot have an address clause,\n@@ -791,19 +831,22 @@ package body Sem_Ch13 is\n                   if Is_Exported (U_Ent) then\n                      Error_Msg_N\n                        (\"cannot export object with address clause\", Nam);\n+                     return;\n \n                   --  Overlaying controlled objects is erroneous\n \n                   elsif Present (Aent)\n-                    and then Is_Controlled (Etype (Aent))\n+                    and then (Has_Controlled_Component (Etype (Aent))\n+                                or else Is_Controlled (Etype (Aent)))\n                   then\n                      Error_Msg_N\n-                       (\"?controlled object must not be overlaid\", Expr);\n+                       (\"?cannot overlay with controlled object\", Expr);\n                      Error_Msg_N\n                        (\"\\?Program_Error will be raised at run time\", Expr);\n                      Insert_Action (Declaration_Node (U_Ent),\n                        Make_Raise_Program_Error (Loc,\n                          Reason => PE_Overlaid_Controlled_Object));\n+                     return;\n \n                   elsif Present (Aent)\n                     and then Ekind (U_Ent) = E_Constant\n@@ -815,6 +858,7 @@ package body Sem_Ch13 is\n                      Error_Msg_N\n                        (\"address clause not allowed\"\n                           & \" for a renaming declaration (RM 13.1(6))\", Nam);\n+                     return;\n \n                   --  Imported variables can have an address clause, but then\n                   --  the import is pretty meaningless except to suppress\n@@ -831,41 +875,13 @@ package body Sem_Ch13 is\n \n                   Note_Possible_Modification (Nam);\n \n-                  --  Here we are checking for explicit overlap of one\n-                  --  variable by another, and if we find this, then we\n-                  --  mark the overlapped variable as also being aliased.\n-\n-                  --  First case is where we have an explicit\n-\n-                  --    for J'Address use K'Address;\n+                  --  Here we are checking for explicit overlap of one variable\n+                  --  by another, and if we find this then mark the overlapped\n+                  --  variable as also being volatile to prevent unwanted\n+                  --  optimizations.\n \n-                  --  In this case, we mark K as volatile\n-\n-                  Mark_Aliased_Address_As_Volatile (Expr);\n-\n-                  --  Second case is where we have a constant whose\n-                  --  definition is of the form of an address as in:\n-\n-                  --     A : constant Address := K'Address;\n-                  --     ...\n-                  --     for B'Address use A;\n-\n-                  --  In this case we also mark K as volatile\n-\n-                  if Is_Entity_Name (Expr) then\n-                     declare\n-                        Ent  : constant Entity_Id := Entity (Expr);\n-                        Decl : constant Node_Id   := Declaration_Node (Ent);\n-\n-                     begin\n-                        if Ekind (Ent) = E_Constant\n-                          and then Nkind (Decl) = N_Object_Declaration\n-                          and then Present (Expression (Decl))\n-                        then\n-                           Mark_Aliased_Address_As_Volatile\n-                             (Expression (Decl));\n-                        end if;\n-                     end;\n+                  if Present (Ent_Y) then\n+                     Set_Treat_As_Volatile (Ent_Y);\n                   end if;\n \n                   --  Legality checks on the address clause for initialized\n@@ -900,6 +916,38 @@ package body Sem_Ch13 is\n                   Kill_Size_Check_Code (U_Ent);\n                end;\n \n+               --  If the address clause is of the form:\n+\n+               --    for X'Address use Y'Address\n+\n+               --  or\n+\n+               --    Const : constant Address := Y'Address;\n+               --    ...\n+               --    for X'Address use Const;\n+\n+               --  then we make an entry in the table for checking the size and\n+               --  alignment of the overlaying variable. We defer this check\n+               --  till after code generation to take full advantage of the\n+               --  annotation done by the back end. This entry is only made if\n+               --  we have not already posted a warning about size/alignment\n+               --  (some warnings of this type are posted in Checks).\n+\n+               if Address_Clause_Overlay_Warnings then\n+                  declare\n+                     Ent_X : Entity_Id := Empty;\n+                     Ent_Y : Entity_Id := Empty;\n+\n+                  begin\n+                     Ent_Y := Find_Overlaid_Object (N);\n+\n+                     if Present (Ent_Y) and then Is_Entity_Name (Name (N)) then\n+                        Ent_X := Entity (Name (N));\n+                           Address_Clause_Checks.Append ((N, Ent_X, Ent_Y));\n+                     end if;\n+                  end;\n+               end if;\n+\n             --  Not a valid entity for an address clause\n \n             else\n@@ -2137,7 +2185,7 @@ package body Sem_Ch13 is\n       end if;\n \n       --  Clear any existing component clauses for the type (this happens with\n-      --  derived types, where we are now overriding the original)\n+      --  derived types, where we are now overriding the original).\n \n       Comp := First_Component_Or_Discriminant (Rectype);\n       while Present (Comp) loop\n@@ -2274,6 +2322,13 @@ package body Sem_Ch13 is\n                        (\"component clause previously given#\", CC);\n \n                   else\n+                     --  Make reference for field in record rep clause and set\n+                     --  appropriate entity field in the field identifier.\n+\n+                     Generate_Reference\n+                       (Comp, Component_Name (CC), Set_Ref => False);\n+                     Set_Entity (Component_Name (CC), Comp);\n+\n                      --  Update Fbit and Lbit to the actual bit number\n \n                      Fbit := Fbit + UI_From_Int (SSU) * Posit;\n@@ -2641,7 +2696,11 @@ package body Sem_Ch13 is\n             then\n                Comp := First_Component_Or_Discriminant (Rectype);\n                while Present (Comp) loop\n-                  if No (Component_Clause (Comp)) then\n+                  if No (Component_Clause (Comp))\n+                    and then (Is_Scalar_Type (Underlying_Type (Etype (Comp)))\n+                                or else Size_Known_At_Compile_Time\n+                                             (Underlying_Type (Etype (Comp))))\n+                  then\n                      Error_Msg_Sloc := Sloc (Comp);\n                      Error_Msg_NE\n                        (\"?no component clause given for & declared #\",\n@@ -3236,19 +3295,6 @@ package body Sem_Ch13 is\n       end if;\n    end Is_Operational_Item;\n \n-   --------------------------------------\n-   -- Mark_Aliased_Address_As_Volatile --\n-   --------------------------------------\n-\n-   procedure Mark_Aliased_Address_As_Volatile (N : Node_Id) is\n-      Ent : constant Entity_Id := Address_Aliased_Entity (N);\n-\n-   begin\n-      if Present (Ent) then\n-         Set_Treat_As_Volatile (Ent);\n-      end if;\n-   end Mark_Aliased_Address_As_Volatile;\n-\n    ------------------\n    -- Minimum_Size --\n    ------------------\n@@ -3965,12 +4011,110 @@ package body Sem_Ch13 is\n         and then Esize (T) < Standard_Integer_Size\n       then\n          Init_Esize (T, Standard_Integer_Size);\n-\n       else\n          Init_Esize (T, Sz);\n       end if;\n    end Set_Enum_Esize;\n \n+   ------------------------------\n+   -- Validate_Address_Clauses --\n+   ------------------------------\n+\n+   procedure Validate_Address_Clauses is\n+   begin\n+      for J in Address_Clause_Checks.First .. Address_Clause_Checks.Last loop\n+         declare\n+            ACCR : Address_Clause_Check_Record\n+                     renames Address_Clause_Checks.Table (J);\n+\n+            X_Alignment : Uint;\n+            Y_Alignment : Uint;\n+\n+            X_Size : Uint;\n+            Y_Size : Uint;\n+\n+         begin\n+            --  Skip processing of this entry if warning already posted\n+\n+            if not Address_Warning_Posted (ACCR.N) then\n+\n+               --  Get alignments. Really we should always have the alignment\n+               --  of the objects properly back annotated, but right now the\n+               --  back end fails to back annotate for address clauses???\n+\n+               if Known_Alignment (ACCR.X) then\n+                  X_Alignment := Alignment (ACCR.X);\n+               else\n+                  X_Alignment := Alignment (Etype (ACCR.X));\n+               end if;\n+\n+               if Known_Alignment (ACCR.Y) then\n+                  Y_Alignment := Alignment (ACCR.Y);\n+               else\n+                  Y_Alignment := Alignment (Etype (ACCR.Y));\n+               end if;\n+\n+               --  Similarly obtain sizes\n+\n+               if Known_Esize (ACCR.X) then\n+                  X_Size := Esize (ACCR.X);\n+               else\n+                  X_Size := Esize (Etype (ACCR.X));\n+               end if;\n+\n+               if Known_Esize (ACCR.Y) then\n+                  Y_Size := Esize (ACCR.Y);\n+               else\n+                  Y_Size := Esize (Etype (ACCR.Y));\n+               end if;\n+\n+               --  Check for large object overlaying smaller one\n+\n+               if Y_Size > Uint_0\n+                 and then X_Size > Uint_0\n+                 and then X_Size > Y_Size\n+               then\n+                  Error_Msg_N\n+                    (\"?size for overlaid object is too small\", ACCR.N);\n+                  Error_Msg_Uint_1 := X_Size;\n+                  Error_Msg_NE\n+                    (\"\\?size of & is ^\", ACCR.N, ACCR.X);\n+                  Error_Msg_Uint_1 := Y_Size;\n+                  Error_Msg_NE\n+                    (\"\\?size of & is ^\", ACCR.N, ACCR.Y);\n+\n+                  --  Check for inadequate alignment. Again the defensive check\n+                  --  on Y_Alignment should not be needed, but because of the\n+                  --  failure in back end annotation, we can have an alignment\n+                  --  of 0 here???\n+\n+                  --  Note: we do not check alignments if we gave a size\n+                  --  warning, since it would likely be redundant.\n+\n+               elsif Y_Alignment /= Uint_0\n+                 and then Y_Alignment < X_Alignment\n+               then\n+                  Error_Msg_NE\n+                    (\"?specified address for& may be inconsistent \"\n+                       & \"with alignment\",\n+                     ACCR.N, ACCR.X);\n+                  Error_Msg_N\n+                    (\"\\?program execution may be erroneous (RM 13.3(27))\",\n+                     ACCR.N);\n+                  Error_Msg_Uint_1 := X_Alignment;\n+                  Error_Msg_NE\n+                    (\"\\?alignment of & is ^\",\n+                     ACCR.N, ACCR.X);\n+                  Error_Msg_Uint_1 := Y_Alignment;\n+                  Error_Msg_NE\n+                    (\"\\?alignment of & is ^\",\n+                     ACCR.N, ACCR.Y);\n+               end if;\n+            end if;\n+         end;\n+      end loop;\n+   end Validate_Address_Clauses;\n+\n    -----------------------------------\n    -- Validate_Unchecked_Conversion --\n    -----------------------------------"}, {"sha": "3c5681c7bf26a394e06bf8d2d7d98c5faba658ed", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2642f9987ea72b416bce764ca3d95c19c9e77836/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2642f9987ea72b416bce764ca3d95c19c9e77836/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=2642f9987ea72b416bce764ca3d95c19c9e77836", "patch": "@@ -161,4 +161,10 @@ package Sem_Ch13 is\n    --  The reason it is called that late is to take advantage of any\n    --  back-annotation of size and alignment performed by the backend.\n \n+   procedure Validate_Address_Clauses;\n+   --  This is called after the back end has been called (and thus after the\n+   --  alignments of objects have been back annotated). It goes through the\n+   --  table of saved address clauses checking for suspicious alignments and\n+   --  if necessary issuing warnings.\n+\n end Sem_Ch13;"}, {"sha": "c0ce298befa3f2ed53f7ea330b6e549813769efc", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2642f9987ea72b416bce764ca3d95c19c9e77836/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2642f9987ea72b416bce764ca3d95c19c9e77836/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=2642f9987ea72b416bce764ca3d95c19c9e77836", "patch": "@@ -292,6 +292,13 @@ package Sem_Util is\n    --  denotes when analyzed. Subsequent uses of this id on a different\n    --  type denote the discriminant at the same position in this new type.\n \n+   function Find_Overlaid_Object (N : Node_Id) return Entity_Id;\n+   --  The node N should be an address representation clause. This function\n+   --  checks if the target expression is the address of some stand alone\n+   --  object (variable or constant), and if so, returns its entity. If N is\n+   --  not an address representation clause, or if it is not possible to\n+   --  determine that the address is of this form, then Empty is returned.\n+\n    function Find_Overridden_Synchronized_Primitive\n      (Def_Id      : Entity_Id;\n       First_Hom   : Entity_Id;\n@@ -304,6 +311,11 @@ package Sem_Util is\n    --  declared inside the scope of the synchronized type or after. Return\n    --  the overridden entity or Empty.\n \n+   function Find_Static_Alternative (N : Node_Id) return Node_Id;\n+   --  N is a case statement whose expression is a compile-time value.\n+   --  Determine the alternative chosen, so that the code of non-selected\n+   --  alternatives, and the warnings that may apply to them, are removed.\n+\n    function First_Actual (Node : Node_Id) return Node_Id;\n    --  Node is an N_Function_Call or N_Procedure_Call_Statement node. The\n    --  result returned is the first actual parameter in declaration order\n@@ -321,11 +333,6 @@ package Sem_Util is\n    --  name in upper case. An ASCII.NUL is appended as the last character.\n    --  The names in the string are generated by Namet.Get_Decoded_Name_String.\n \n-   function Find_Static_Alternative (N : Node_Id) return Node_Id;\n-   --  N is a case statement whose expression is a compile-time value.\n-   --  Determine the alternative chosen, so that the code of non-selected\n-   --  alternatives, and the warnings that may apply to them, are removed.\n-\n    procedure Gather_Components\n      (Typ           : Entity_Id;\n       Comp_List     : Node_Id;"}]}