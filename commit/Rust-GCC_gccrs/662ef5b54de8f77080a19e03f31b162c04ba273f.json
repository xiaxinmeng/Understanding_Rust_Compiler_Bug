{"sha": "662ef5b54de8f77080a19e03f31b162c04ba273f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYyZWY1YjU0ZGU4Zjc3MDgwYTE5ZTAzZjMxYjE2MmMwNGJhMjczZg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-03T17:01:13Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-03T17:01:13Z"}, "message": "c++: Clean up normalization and satisfaction routines\n\nThis patch mostly performs some straightforward refactoring:\n\n  - Renamed satisfy_constraint to satisfy_normalized_constraints\n  - Renamed the three-parameter version of satisfy_constraint_expression\n    to satisfy_nondeclaration_constraints\n  - Removed normalize_(non)?template_requirements\n  - Removed satisfy_associated_constraints (and made its callers\n    check for dependent template args sooner, before normalization)\n  - Removed the tsubst_flags_t parameter of evaluate_concept_check\n  - Combined the two versions of constraint_satisfaction_value\n  - Combined the two versions of constraint_satisfied_p\n\nAdditionally, this patch removes the handling of general\nconstraint-expressions from satisfy_nondeclaration_constraints, and\nhence constraints_satisfied_p and constraint_satisfaction_value now take\nonly things that carry their own template information needed for\nnormalization, and, as a special case, REQUIRES_EXPRs.  But the latter\nnow get evaluated directly via tsubst_requires_expr rather than going\nthrough satisfaction.\n\n(That we used to evaluate REQUIRES_EXPR via satisfaction might even be a\ncorrectness issue: since we cache satisfaction in special ways that don't\napply to regular evaluation, going through satisfaction could in theory\ncause us to reuse a cached value for a REQUIRES_EXPR when we shouldn't\nhave.)\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.c (cxx_eval_call_expression): Adjust call to\n\tevaluate_concept_check.\n\t(cxx_eval_constant_expression) <case REQUIRES_EXPR>: Use\n\tevaluate_requires_expression instead of\n\tsatisfy_constraint_expression.\n\t<case TEMPLATE_ID_EXPR>: Adjust call to evaluate_concept_check.\n\t* constraint.cc (struct sat_info): Adjust comment about which\n\tsatisfaction entrypoints use noisy-unsat.\n\t(normalize_template_requirements): Remove (and adjust callers\n\tappropriately).\n\t(normalize_nontemplate_requirements): Likewise.\n\t(tsubst_nested_requirement): Use constraint_satisfaction_value\n\tinstead of satisfy_constraint_expression, which'll do the\n\tnoisy replaying of ill-formed quiet satisfaction for us.\n\t(decl_satisfied_cache): Adjust comment.\n\t(satisfy_constraint): Rename to ...\n\t(satisfy_normalized_constraints): ... this.\n\t(satisfy_associated_constraints): Remove (and make its\n\tcallers check for dependent arguments).\n\t(satisfy_constraint_expression): Rename to ...\n\t(satisfy_nondeclaration_constraints): ... this.  Assert that\n\t'args' is empty when 't' is a concept-id.  Removing handling\n\tbare constraint-expressions, and handle REQUIRES_EXPRs\n\tspecially.  Adjust comment accordingly.\n\t(satisfy_declaration_constraints): Assert in the two-parameter\n\tversion that 't' is not a TEMPLATE_DECL.  Adjust following\n\tremoval of normalize_(non)?template_requirements and\n\tsatisfy_asociated_constraints.\n\t(constraint_satisfaction_value): Combine the two- and\n\tthree-parameter versions in the natural way.\n\t(constraints_satisfied_p): Combine the one- and two-parameter\n\tversions in the natural way.  Improve documentation.\n\t(evaluate_requires_expr): Define.\n\t(evaluate_concept_check): Remove 'complain' parameter.  Use\n\tconstraint_satisfaction_value instead of\n\tsatisfy_constraint_expression.\n\t(diagnose_nested_requirement): Adjust following renaming of\n\tsatisfy_constraint_expression.\n\t(diagnose_constraints): Handle REQUIRES_EXPR by going through\n\tdiagnose_requires_expr directly instead of treating it as a\n\tconstraint-expression.  Improve documentation.\n\t* cp-gimplify.c (cp_genericize_r) <case CALL_EXPR>: Adjust call\n\tto evaluate_concept_check.\n\t<case REQUIRES_EXPR>: Use evaluate_requires_expr instead of\n\tconstraints_satisfied_p.\n\t<case TEMPLATE_ID_EXPR>: Adjust call to evaluate_concept_check.\n\t* cp-tree.h (evaluate_requires_expr): Declare.\n\t(evaluate_concept_check): Remove tsubst_flag_t parameter.\n\t(satisfy_constraint_expression): Remove declaration.\n\t(constraints_satisfied_p): Remove one-parameter declaration.\n\tAdd a default argument to the two-parameter declaration.\n\t* cvt.c (convert_to_void): Adjust call to\n\tevaluate_concept_check.", "tree": {"sha": "719af4f3e7349cf7da230988be93761b19817c04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/719af4f3e7349cf7da230988be93761b19817c04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/662ef5b54de8f77080a19e03f31b162c04ba273f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/662ef5b54de8f77080a19e03f31b162c04ba273f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/662ef5b54de8f77080a19e03f31b162c04ba273f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/662ef5b54de8f77080a19e03f31b162c04ba273f/comments", "author": null, "committer": null, "parents": [{"sha": "39d7eb8a73d5f8c09db20926a98181181d9dd2c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d7eb8a73d5f8c09db20926a98181181d9dd2c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39d7eb8a73d5f8c09db20926a98181181d9dd2c2"}], "stats": {"total": 256, "additions": 110, "deletions": 146}, "files": [{"sha": "7d96d577d84df247ad2fa21f4f33d9e4fa80c8da", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662ef5b54de8f77080a19e03f31b162c04ba273f/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662ef5b54de8f77080a19e03f31b162c04ba273f/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=662ef5b54de8f77080a19e03f31b162c04ba273f", "patch": "@@ -2257,7 +2257,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n {\n   /* Handle concept checks separately.  */\n   if (concept_check_p (t))\n-    return evaluate_concept_check (t, tf_warning_or_error);\n+    return evaluate_concept_check (t);\n \n   location_t loc = cp_expr_loc_or_input_loc (t);\n   tree fun = get_function_named_in_call (t);\n@@ -6905,7 +6905,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n          '!requires (T t) { ... }' which is not transformed into\n          a constraint.  */\n       if (!processing_template_decl)\n-        return satisfy_constraint_expression (t);\n+\treturn evaluate_requires_expr (t);\n       else\n         *non_constant_p = true;\n       return t;\n@@ -6941,7 +6941,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \n \tif (!processing_template_decl\n \t    && !uid_sensitive_constexpr_evaluation_p ())\n-\t  r = evaluate_concept_check (t, tf_warning_or_error);\n+\t  r = evaluate_concept_check (t);\n \telse\n \t  *non_constant_p = true;\n "}, {"sha": "0949788aa295b228110069ad9042115b2cec13ad", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 100, "deletions": 134, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662ef5b54de8f77080a19e03f31b162c04ba273f/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662ef5b54de8f77080a19e03f31b162c04ba273f/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=662ef5b54de8f77080a19e03f31b162c04ba273f", "patch": "@@ -107,10 +107,9 @@ struct subst_info\n    a constraint is not satisfied.\n \n    The entrypoints to satisfaction for which we set noisy+unsat are\n-   diagnose_constraints and diagnose_nested_requirement.  The entrypoints for\n-   which we set noisy-unsat are the replays inside constraint_satisfaction_value,\n-   evaluate_concept_check and tsubst_nested_requirement.  In other entrypoints,\n-   e.g. constraints_satisfied_p, we enter satisfaction quietly (both flags\n+   diagnose_constraints and diagnose_nested_requirement.  The entrypoint for\n+   which we set noisy-unsat is the replay inside constraint_satisfaction_value.\n+   From constraints_satisfied_p, we enter satisfaction quietly (both flags\n    cleared).  */\n \n struct sat_info : subst_info\n@@ -133,7 +132,7 @@ struct sat_info : subst_info\n   bool diagnose_unsatisfaction;\n };\n \n-static tree satisfy_constraint_expression (tree, tree, sat_info);\n+static tree constraint_satisfaction_value (tree, tree, sat_info);\n \n /* True if T is known to be some type other than bool. Note that this\n    is false for dependent types and errors.  */\n@@ -958,22 +957,6 @@ normalize_concept_definition (tree tmpl, bool diag = false)\n   return norm;\n }\n \n-/* Returns the normal form of TMPL's requirements.  */\n-\n-static tree\n-normalize_template_requirements (tree tmpl, bool diag = false)\n-{\n-  return get_normalized_constraints_from_decl (tmpl, diag);\n-}\n-\n-/* Returns the normal form of TMPL's requirements.  */\n-\n-static tree\n-normalize_nontemplate_requirements (tree decl, bool diag = false)\n-{\n-  return get_normalized_constraints_from_decl (decl, diag);\n-}\n-\n /* Normalize an EXPR as a constraint.  */\n \n static tree\n@@ -2068,15 +2051,8 @@ tsubst_compound_requirement (tree t, tree args, subst_info info)\n static tree\n tsubst_nested_requirement (tree t, tree args, subst_info info)\n {\n-  /* Perform satisfaction quietly first.  */\n   sat_info quiet (tf_none, info.in_decl);\n-  tree result = satisfy_constraint_expression (t, args, quiet);\n-  if (result == error_mark_node)\n-    {\n-      /* Replay the error.  */\n-      sat_info noisy (tf_warning_or_error, info.in_decl);\n-      satisfy_constraint_expression (t, args, noisy);\n-    }\n+  tree result = constraint_satisfaction_value (t, args, quiet);\n   if (result != boolean_true_node)\n     return error_mark_node;\n   return boolean_true_node;\n@@ -2459,7 +2435,7 @@ struct sat_hasher : ggc_ptr_hash<sat_entry>\n /* Cache the result of satisfy_atom.  */\n static GTY((deletable)) hash_table<sat_hasher> *sat_cache;\n \n-/* Cache the result of constraint_satisfaction_value.  */\n+/* Cache the result of satisfy_declaration_constraints.  */\n static GTY((deletable)) hash_map<tree, tree> *decl_satisfied_cache;\n \n /* A tool used by satisfy_atom to help manage satisfaction caching and to\n@@ -2941,7 +2917,7 @@ satisfy_constraint_r (tree t, tree args, sat_info info)\n /* Check that the normalized constraint T is satisfied for ARGS.  */\n \n static tree\n-satisfy_constraint (tree t, tree args, sat_info info)\n+satisfy_normalized_constraints (tree t, tree args, sat_info info)\n {\n   auto_timevar time (TV_CONSTRAINT_SAT);\n \n@@ -2957,24 +2933,6 @@ satisfy_constraint (tree t, tree args, sat_info info)\n   return satisfy_constraint_r (t, args, info);\n }\n \n-/* Check the normalized constraints T against ARGS, returning a satisfaction\n-   value (either true, false, or error).  */\n-\n-static tree\n-satisfy_associated_constraints (tree t, tree args, sat_info info)\n-{\n-  /* If there are no constraints then this is trivially satisfied.  */\n-  if (!t)\n-    return boolean_true_node;\n-\n-  /* If any arguments depend on template parameters, we can't\n-     check constraints. Pretend they're satisfied for now.  */\n-  if (args && uses_template_parms (args))\n-    return boolean_true_node;\n-\n-  return satisfy_constraint (t, args, info);\n-}\n-\n /* Return the normal form of the constraints on the placeholder 'auto'\n    type T.  */\n \n@@ -3005,19 +2963,34 @@ normalize_placeholder_type_constraints (tree t, bool diag)\n   return normalize_constraint_expression (constr, info);\n }\n \n-/* Evaluate EXPR as a constraint expression using ARGS, returning a\n-   satisfaction value. */\n+/* Evaluate the constraints of T using ARGS, returning a satisfaction value.\n+   Here, T can be a concept-id, nested-requirement, placeholder 'auto', or\n+   requires-expression.  */\n \n static tree\n-satisfy_constraint_expression (tree t, tree args, sat_info info)\n+satisfy_nondeclaration_constraints (tree t, tree args, sat_info info)\n {\n   if (t == error_mark_node)\n     return error_mark_node;\n \n+  /* Handle REQUIRES_EXPR directly, bypassing satisfaction.  */\n+  if (TREE_CODE (t) == REQUIRES_EXPR)\n+    {\n+      /* TODO: Remove this assert and the special casing of REQUIRES_EXPRs\n+\t from diagnose_constraints once we merge tsubst_requires_expr and\n+\t diagnose_requires_expr.  */\n+      gcc_assert (!info.diagnose_unsatisfaction_p ());\n+      auto ovr = make_temp_override (current_constraint_diagnosis_depth);\n+      if (info.noisy ())\n+\t++current_constraint_diagnosis_depth;\n+      return tsubst_requires_expr (t, args, info.complain, info.in_decl);\n+    }\n+\n   /* Get the normalized constraints.  */\n   tree norm;\n-  if (args == NULL_TREE && concept_check_p (t))\n+  if (concept_check_p (t))\n     {\n+      gcc_assert (!args);\n       tree id = unpack_concept_check (t);\n       args = TREE_OPERAND (id, 1);\n       tree tmpl = get_concept_check_template (id);\n@@ -3032,11 +3005,6 @@ satisfy_constraint_expression (tree t, tree args, sat_info info)\n       ninfo.initial_parms = TREE_TYPE (t);\n       norm = normalize_constraint_expression (TREE_OPERAND (t, 0), ninfo);\n     }\n-  else if (EXPR_P (t))\n-    {\n-      norm_info ninfo (info.noisy () ? tf_norm : tf_none);\n-      norm = normalize_constraint_expression (t, ninfo);\n-    }\n   else if (is_auto (t))\n     {\n       norm = normalize_placeholder_type_constraints (t, info.noisy ());\n@@ -3047,23 +3015,16 @@ satisfy_constraint_expression (tree t, tree args, sat_info info)\n     gcc_unreachable ();\n \n   /* Perform satisfaction.  */\n-  return satisfy_constraint (norm, args, info);\n+  return satisfy_normalized_constraints (norm, args, info);\n }\n \n-/* Used only to evaluate requires-expressions during constant expression\n-   evaluation.  */\n-\n-tree\n-satisfy_constraint_expression (tree expr)\n-{\n-  sat_info info (tf_none, NULL_TREE);\n-  return satisfy_constraint_expression (expr, NULL_TREE, info);\n-}\n+/* Evaluate the associated constraints of the template specialization T\n+   according to INFO, returning a satisfaction value.  */\n \n static tree\n satisfy_declaration_constraints (tree t, sat_info info)\n {\n-  gcc_assert (DECL_P (t));\n+  gcc_assert (DECL_P (t) && TREE_CODE (t) != TEMPLATE_DECL);\n   const tree saved_t = t;\n \n   /* For inherited constructors, consider the original declaration;\n@@ -3083,26 +3044,24 @@ satisfy_declaration_constraints (tree t, sat_info info)\n     if (tree *result = hash_map_safe_get (decl_satisfied_cache, saved_t))\n       return *result;\n \n-  /* Get the normalized constraints.  */\n-  tree norm = NULL_TREE;\n   tree args = NULL_TREE;\n   if (tree ti = DECL_TEMPLATE_INFO (t))\n     {\n-      tree tmpl = TI_TEMPLATE (ti);\n-      norm = normalize_template_requirements (tmpl, info.noisy ());\n-\n       /* The initial parameter mapping is the complete set of\n \t template arguments substituted into the declaration.  */\n       args = TI_ARGS (ti);\n       if (inh_ctor_targs)\n \targs = add_outermost_template_args (args, inh_ctor_targs);\n-    }\n-  else\n-    {\n-      /* These should be empty until we allow constraints on non-templates.  */\n-      norm = normalize_nontemplate_requirements (t, info.noisy ());\n+\n+      /* If any arguments depend on template parameters, we can't\n+\t check constraints. Pretend they're satisfied for now.  */\n+      if (uses_template_parms (args))\n+\treturn boolean_true_node;\n     }\n \n+  /* Get the normalized constraints.  */\n+  tree norm = get_normalized_constraints_from_decl (t, info.noisy ());\n+\n   unsigned ftc_count = vec_safe_length (failed_type_completions);\n \n   tree result = boolean_true_node;\n@@ -3111,7 +3070,7 @@ satisfy_declaration_constraints (tree t, sat_info info)\n       if (!push_tinst_level (t))\n \treturn result;\n       push_access_scope (t);\n-      result = satisfy_associated_constraints (norm, args, info);\n+      result = satisfy_normalized_constraints (norm, args, info);\n       pop_access_scope (t);\n       pop_tinst_level ();\n     }\n@@ -3134,6 +3093,10 @@ satisfy_declaration_constraints (tree t, sat_info info)\n   return result;\n }\n \n+/* Evaluate the associated constraints of the template T using ARGS as the\n+   innermost set of template arguments and according to INFO, returning a\n+   satisfaction value.  */\n+\n static tree\n satisfy_declaration_constraints (tree t, tree args, sat_info info)\n {\n@@ -3144,77 +3107,70 @@ satisfy_declaration_constraints (tree t, tree args, sat_info info)\n \n   args = add_outermost_template_args (t, args);\n \n+  /* If any arguments depend on template parameters, we can't\n+     check constraints. Pretend they're satisfied for now.  */\n+  if (uses_template_parms (args))\n+    return boolean_true_node;\n+\n   tree result = boolean_true_node;\n-  if (tree norm = normalize_template_requirements (t, info.noisy ()))\n+  if (tree norm = get_normalized_constraints_from_decl (t, info.noisy ()))\n     {\n       if (!push_tinst_level (t, args))\n \treturn result;\n       tree pattern = DECL_TEMPLATE_RESULT (t);\n       push_access_scope (pattern);\n-      result = satisfy_associated_constraints (norm, args, info);\n+      result = satisfy_normalized_constraints (norm, args, info);\n       pop_access_scope (pattern);\n       pop_tinst_level ();\n     }\n \n   return result;\n }\n \n+/* A wrapper around satisfy_declaration_constraints and\n+   satisfy_nondeclaration_constraints which additionally replays\n+   quiet ill-formed satisfaction noisily, so that ill-formed\n+   satisfaction always gets diagnosed.  */\n+\n static tree\n-constraint_satisfaction_value (tree t, sat_info info)\n+constraint_satisfaction_value (tree t, tree args, sat_info info)\n {\n   tree r;\n   if (DECL_P (t))\n-    r = satisfy_declaration_constraints (t, info);\n+    {\n+      if (args)\n+\tr = satisfy_declaration_constraints (t, args, info);\n+      else\n+\tr = satisfy_declaration_constraints (t, info);\n+    }\n   else\n-    r = satisfy_constraint_expression (t, NULL_TREE, info);\n+    r = satisfy_nondeclaration_constraints (t, args, info);\n   if (r == error_mark_node && info.quiet ()\n       && !(DECL_P (t) && TREE_NO_WARNING (t)))\n     {\n-      /* Replay the error with re-normalized requirements.  */\n+      /* Replay the error noisily.  */\n       sat_info noisy (tf_warning_or_error, info.in_decl);\n-      constraint_satisfaction_value (t, noisy);\n-      if (DECL_P (t))\n+      constraint_satisfaction_value (t, args, noisy);\n+      if (DECL_P (t) && !args)\n \t/* Avoid giving these errors again.  */\n \tTREE_NO_WARNING (t) = true;\n     }\n   return r;\n }\n \n-static tree\n-constraint_satisfaction_value (tree t, tree args, sat_info info)\n-{\n-  tree r;\n-  if (DECL_P (t))\n-    r = satisfy_declaration_constraints (t, args, info);\n-  else\n-    r = satisfy_constraint_expression (t, args, info);\n-  if (r == error_mark_node && info.quiet ())\n-    {\n-      /* Replay the error with re-normalized requirements.  */\n-      sat_info noisy (tf_warning_or_error, info.in_decl);\n-      constraint_satisfaction_value (t, args, noisy);\n-    }\n-  return r;\n-}\n-\n-/* True iff the result of satisfying T is BOOLEAN_TRUE_NODE and false\n-   otherwise, even in the case of errors.  */\n-\n-bool\n-constraints_satisfied_p (tree t)\n-{\n-  if (!flag_concepts)\n-    return true;\n-\n-  sat_info quiet (tf_none, NULL_TREE);\n-  return constraint_satisfaction_value (t, quiet) == boolean_true_node;\n-}\n+/* True iff the result of satisfying T using ARGS is BOOLEAN_TRUE_NODE\n+   and false otherwise, even in the case of errors.\n \n-/* True iff the result of satisfying T with ARGS is BOOLEAN_TRUE_NODE\n-    and false otherwise, even in the case of errors.  */\n+   Here, T can be:\n+     - a template declaration\n+     - a template specialization (in which case ARGS must be empty)\n+     - a concept-id (in which case ARGS must be empty)\n+     - a nested-requirement\n+     - a placeholder 'auto'\n+     - a requires-expression.  */\n \n bool\n-constraints_satisfied_p (tree t, tree args)\n+constraints_satisfied_p (tree t, tree args/*= NULL_TREE */)\n {\n   if (!flag_concepts)\n     return true;\n@@ -3227,7 +3183,7 @@ constraints_satisfied_p (tree t, tree args)\n    evaluation of template-ids as id-expressions.  */\n \n tree\n-evaluate_concept_check (tree check, tsubst_flags_t complain)\n+evaluate_concept_check (tree check)\n {\n   if (check == error_mark_node)\n     return error_mark_node;\n@@ -3236,14 +3192,19 @@ evaluate_concept_check (tree check, tsubst_flags_t complain)\n \n   /* Check for satisfaction without diagnostics.  */\n   sat_info quiet (tf_none, NULL_TREE);\n-  tree result = satisfy_constraint_expression (check, NULL_TREE, quiet);\n-  if (result == error_mark_node && (complain & tf_error))\n-    {\n-      /* Replay the error with re-normalized requirements.  */\n-      sat_info noisy (tf_warning_or_error, NULL_TREE);\n-      satisfy_constraint_expression (check, NULL_TREE, noisy);\n-    }\n-  return result;\n+  return constraint_satisfaction_value (check, /*args=*/NULL_TREE, quiet);\n+}\n+\n+/* Evaluate the requires-expression T, returning either boolean_true_node\n+   or boolean_false_node.  This is used during gimplification and constexpr\n+   evaluation.  */\n+\n+tree\n+evaluate_requires_expr (tree t)\n+{\n+  gcc_assert (TREE_CODE (t) == REQUIRES_EXPR);\n+  sat_info quiet (tf_none, NULL_TREE);\n+  return constraint_satisfaction_value (t, /*args=*/NULL_TREE, quiet);\n }\n \n /*---------------------------------------------------------------------------\n@@ -3709,7 +3670,7 @@ diagnose_nested_requirement (tree req, tree args)\n {\n   /* Quietly check for satisfaction first.  */\n   sat_info quiet (tf_none, NULL_TREE);\n-  tree result = satisfy_constraint_expression (req, args, quiet);\n+  tree result = satisfy_nondeclaration_constraints (req, args, quiet);\n   if (result == boolean_true_node)\n     return;\n \n@@ -3721,7 +3682,7 @@ diagnose_nested_requirement (tree req, tree args)\n       inform (loc, \"nested requirement %qE is not satisfied, because\", expr);\n \n       sat_info noisy (tf_warning_or_error, NULL_TREE, /*diag_unsat=*/true);\n-      satisfy_constraint_expression (req, args, noisy);\n+      satisfy_nondeclaration_constraints (req, args, noisy);\n     }\n   else\n     inform (loc, \"nested requirement %qE is not satisfied\", expr);\n@@ -3854,7 +3815,7 @@ diagnosing_failed_constraint::replay_errors_p ()\n }\n \n /* Emit diagnostics detailing the failure ARGS to satisfy the constraints\n-   of T. Here, T can be either a constraint or a declaration.  */\n+   of T.  Here, T and ARGS are as in constraints_satisfied_p.  */\n \n void\n diagnose_constraints (location_t loc, tree t, tree args)\n@@ -3866,8 +3827,13 @@ diagnose_constraints (location_t loc, tree t, tree args)\n \n   /* Replay satisfaction, but diagnose unsatisfaction.  */\n   sat_info noisy (tf_warning_or_error, NULL_TREE, /*diag_unsat=*/true);\n-  if (!args)\n-    constraint_satisfaction_value (t, noisy);\n+  if (TREE_CODE (t) == REQUIRES_EXPR)\n+    {\n+      gcc_assert (!args);\n+      ++current_constraint_diagnosis_depth;\n+      diagnose_requires_expr (t, /*map=*/NULL_TREE, /*in_decl=*/NULL_TREE);\n+      --current_constraint_diagnosis_depth;\n+    }\n   else\n     constraint_satisfaction_value (t, args, noisy);\n "}, {"sha": "df89ff3815b7f49ed09714f8fa410bda1254215e", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662ef5b54de8f77080a19e03f31b162c04ba273f/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662ef5b54de8f77080a19e03f31b162c04ba273f/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=662ef5b54de8f77080a19e03f31b162c04ba273f", "patch": "@@ -1381,7 +1381,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t normal functions.  */\n       if (concept_check_p (stmt))\n \t{\n-\t  *stmt_p = evaluate_concept_check (stmt, tf_warning_or_error);\n+\t  *stmt_p = evaluate_concept_check (stmt);\n \t  * walk_subtrees = 0;\n \t  break;\n \t}\n@@ -1453,15 +1453,14 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \n     case REQUIRES_EXPR:\n       /* Emit the value of the requires-expression.  */\n-      *stmt_p = constant_boolean_node (constraints_satisfied_p (stmt),\n-\t\t\t\t       boolean_type_node);\n+      *stmt_p = evaluate_requires_expr (stmt);\n       *walk_subtrees = 0;\n       break;\n \n     case TEMPLATE_ID_EXPR:\n       gcc_assert (concept_check_p (stmt));\n       /* Emit the value of the concept check.  */\n-      *stmt_p = evaluate_concept_check (stmt, tf_warning_or_error);\n+      *stmt_p = evaluate_concept_check (stmt);\n       walk_subtrees = 0;\n       break;\n "}, {"sha": "699c50515e891e989e587748aea6a5e910855ef9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662ef5b54de8f77080a19e03f31b162c04ba273f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662ef5b54de8f77080a19e03f31b162c04ba273f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=662ef5b54de8f77080a19e03f31b162c04ba273f", "patch": "@@ -8110,6 +8110,7 @@ extern tree finish_compound_requirement         (location_t, tree, tree, bool);\n extern tree finish_nested_requirement           (location_t, tree);\n extern void check_constrained_friend            (tree, tree);\n extern tree tsubst_requires_expr                (tree, tree, tsubst_flags_t, tree);\n+extern tree evaluate_requires_expr\t\t(tree);\n extern tree tsubst_constraint                   (tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_constraint_info              (tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_parameter_mapping\t\t(tree, tree, tsubst_flags_t, tree);\n@@ -8124,10 +8125,8 @@ struct processing_constraint_expression_sentinel\n extern bool processing_constraint_expression_p\t();\n \n extern tree unpack_concept_check\t\t(tree);\n-extern tree evaluate_concept_check              (tree, tsubst_flags_t);\n-extern tree satisfy_constraint_expression\t(tree);\n-extern bool constraints_satisfied_p\t\t(tree);\n-extern bool constraints_satisfied_p\t\t(tree, tree);\n+extern tree evaluate_concept_check              (tree);\n+extern bool constraints_satisfied_p\t\t(tree, tree = NULL_TREE);\n extern bool* lookup_subsumption_result          (tree, tree);\n extern bool save_subsumption_result             (tree, tree, bool);\n extern tree find_template_parameters\t\t(tree, tree);"}, {"sha": "3f5467c8283a1473a37cdebea469edc4834998ed", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662ef5b54de8f77080a19e03f31b162c04ba273f/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662ef5b54de8f77080a19e03f31b162c04ba273f/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=662ef5b54de8f77080a19e03f31b162c04ba273f", "patch": "@@ -1170,7 +1170,7 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n   /* Explicitly evaluate void-converted concept checks since their\n      satisfaction may produce ill-formed programs.  */\n    if (concept_check_p (expr))\n-     expr = evaluate_concept_check (expr, tf_warning_or_error);\n+     expr = evaluate_concept_check (expr);\n \n   if (VOID_TYPE_P (TREE_TYPE (expr)))\n     return expr;"}]}