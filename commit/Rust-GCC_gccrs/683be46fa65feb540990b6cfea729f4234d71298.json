{"sha": "683be46fa65feb540990b6cfea729f4234d71298", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgzYmU0NmZhNjVmZWI1NDA5OTBiNmNmZWE3MjlmNDIzNGQ3MTI5OA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-08-12T21:54:23Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-08-12T21:54:23Z"}, "message": "re PR target/67071 (GCC misses an optimization to load vector constants)\n\n[gcc]\n2015-08-12  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/67071\n\t* config/rs6000/predicates.md (easy_vector_constant_vsldoi): New\n\tpredicate to allow construction of vector constants using the\n\tVSLDOI vector shift instruction.\n\n\t* config/rs6000/rs6000-protos.h (vspltis_shifted): Add\n\tdeclaration.\n\n\t* config/rs6000/rs6000.c (vspltis_shifted): New function to return\n\tthe number of bytes to be shifted left and filled in with either\n\tall zero or all one bits.\n\t(gen_easy_altivec_constant): Call vsplitis_shifted if no other\n\tmethods exist.\n\t(output_vec_const_move): On power8, generate XXLORC to generate\n\ta vector constant with all 1's. Do a split if we need to use a\n\tVSLDOI instruction.\n\n\t* config/rs6000/rs6000.h (EASY_VECTOR_MSB): Use mode mask to\n\tproperly test for the MSB.\n\n\t* config/rs6000/altivec.md (VSLDOI splitter): Add splitter for\n\tvector constants that can be created with VSLDOI.\n\n[gcc/testsuite]\n2015-08-12  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/67071\n\t* gcc.target/powerpc/pr67071-1.c: New file to test PR 67071 new\n\tvector constants.\n\t* gcc.target/powerpc/pr67071-2.c: Likewise.\n\t* gcc.target/powerpc/pr67071-3.c: Likewise.\n\nFrom-SVN: r226836", "tree": {"sha": "e042ba5e831a20c5580d65644efdfb4ad9e683ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e042ba5e831a20c5580d65644efdfb4ad9e683ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/683be46fa65feb540990b6cfea729f4234d71298", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683be46fa65feb540990b6cfea729f4234d71298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/683be46fa65feb540990b6cfea729f4234d71298", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683be46fa65feb540990b6cfea729f4234d71298/comments", "author": null, "committer": null, "parents": [{"sha": "17795822b27b7b5381525b1d7c98ca181be9bc80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17795822b27b7b5381525b1d7c98ca181be9bc80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17795822b27b7b5381525b1d7c98ca181be9bc80"}], "stats": {"total": 320, "additions": 317, "deletions": 3}, "files": [{"sha": "65a4f2a0012f13efcbb32f8ea3748af92b8038f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683be46fa65feb540990b6cfea729f4234d71298/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683be46fa65feb540990b6cfea729f4234d71298/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=683be46fa65feb540990b6cfea729f4234d71298", "patch": "@@ -1,3 +1,28 @@\n+2015-08-12  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/67071\n+\t* config/rs6000/predicates.md (easy_vector_constant_vsldoi): New\n+\tpredicate to allow construction of vector constants using the\n+\tVSLDOI vector shift instruction.\n+\n+\t* config/rs6000/rs6000-protos.h (vspltis_shifted): Add\n+\tdeclaration.\n+\n+\t* config/rs6000/rs6000.c (vspltis_shifted): New function to return\n+\tthe number of bytes to be shifted left and filled in with either\n+\tall zero or all one bits.\n+\t(gen_easy_altivec_constant): Call vsplitis_shifted if no other\n+\tmethods exist.\n+\t(output_vec_const_move): On power8, generate XXLORC to generate\n+\ta vector constant with all 1's. Do a split if we need to use a\n+\tVSLDOI instruction.\n+\n+\t* config/rs6000/rs6000.h (EASY_VECTOR_MSB): Use mode mask to\n+\tproperly test for the MSB.\n+\n+\t* config/rs6000/altivec.md (VSLDOI splitter): Add splitter for\n+\tvector constants that can be created with VSLDOI.\n+\n 2015-08-11  Trevor Saunders  <tbsaunde@tbsaunde.org>\n \n \trevert:"}, {"sha": "4170f38b7db27665f0267310783713e540666ac5", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=683be46fa65feb540990b6cfea729f4234d71298", "patch": "@@ -311,6 +311,47 @@\n   operands[4] = gen_rtx_PLUS (op_mode, operands[0], operands[0]);\n })\n \n+(define_split\n+  [(set (match_operand:VM 0 \"altivec_register_operand\" \"\")\n+\t(match_operand:VM 1 \"easy_vector_constant_vsldoi\" \"\"))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode) && can_create_pseudo_p ()\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))\n+   (set (match_dup 0)\n+        (unspec:VM [(match_dup 2)\n+\t\t    (match_dup 4)\n+\t\t    (match_dup 6)]\n+\t\t   UNSPEC_VSLDOI))]\n+{\n+  rtx op1 = operands[1];\n+  int elt = (BYTES_BIG_ENDIAN) ? 0 : GET_MODE_NUNITS (<MODE>mode) - 1;\n+  HOST_WIDE_INT val = const_vector_elt_as_int (op1, elt);\n+  rtx rtx_val = GEN_INT (val);\n+  int shift = vspltis_shifted (op1);\n+  int nunits = GET_MODE_NUNITS (<MODE>mode);\n+  int i;\n+\n+  gcc_assert (shift != 0);\n+  operands[2] = gen_reg_rtx (<MODE>mode);\n+  operands[3] = gen_rtx_CONST_VECTOR (<MODE>mode, rtvec_alloc (nunits));\n+  operands[4] = gen_reg_rtx (<MODE>mode);\n+\n+  if (shift < 0)\n+    {\n+      operands[5] = CONSTM1_RTX (<MODE>mode);\n+      operands[6] = GEN_INT (-shift);\n+    }\n+  else\n+    {\n+      operands[5] = CONST0_RTX (<MODE>mode);\n+      operands[6] = GEN_INT (shift);\n+    }\n+\n+  /* Populate the constant vectors.  */\n+  for (i = 0; i < nunits; i++)\n+    XVECEXP (operands[3], 0, i) = rtx_val;\n+})\n+\n (define_insn \"get_vrsave_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(unspec:SI [(reg:SI 109)] UNSPEC_GET_VRSAVE))]"}, {"sha": "ae74796849d7b6ca23fc3c17f03bf7f2c7b9d0b6", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=683be46fa65feb540990b6cfea729f4234d71298", "patch": "@@ -562,6 +562,14 @@\n   return EASY_VECTOR_MSB (val, GET_MODE_INNER (mode));\n })\n \n+;; Return true if this is an easy altivec constant that we form\n+;; by using VSLDOI.\n+(define_predicate \"easy_vector_constant_vsldoi\"\n+  (and (match_code \"const_vector\")\n+       (and (match_test \"TARGET_ALTIVEC\")\n+\t    (and (match_test \"easy_altivec_constant (op, mode)\")\n+\t\t (match_test \"vspltis_shifted (op) != 0\")))))\n+\n ;; Return 1 if operand is constant zero (scalars and vectors).\n (define_predicate \"zero_constant\"\n   (and (match_code \"const_int,const_double,const_wide_int,const_vector\")"}, {"sha": "7262a1514388c789d7d976a0da2b377938176472", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=683be46fa65feb540990b6cfea729f4234d71298", "patch": "@@ -31,6 +31,7 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, int, int, int,\n #endif /* TREE_CODE */\n \n extern bool easy_altivec_constant (rtx, machine_mode);\n+extern int vspltis_shifted (rtx);\n extern HOST_WIDE_INT const_vector_elt_as_int (rtx, unsigned int);\n extern bool macho_lo_sum_memory_operand (rtx, machine_mode);\n extern int num_insns_constant (rtx, machine_mode);"}, {"sha": "d1326eba47d43843a654810f816b693731509e77", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 103, "deletions": 2, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=683be46fa65feb540990b6cfea729f4234d71298", "patch": "@@ -5449,6 +5449,96 @@ vspltis_constant (rtx op, unsigned step, unsigned copies)\n   return true;\n }\n \n+/* Like vsplitis_constant, but allow the value to be shifted left with a VSLDOI\n+   instruction, filling in the bottom elements with 0 or -1.\n+\n+   Return 0 if the constant cannot be generated with VSLDOI.  Return positive\n+   for the number of zeroes to shift in, or negative for the number of 0xff\n+   bytes to shift in.\n+\n+   OP is a CONST_VECTOR.  */\n+\n+int\n+vspltis_shifted (rtx op)\n+{\n+  machine_mode mode = GET_MODE (op);\n+  machine_mode inner = GET_MODE_INNER (mode);\n+\n+  unsigned i, j;\n+  unsigned nunits;\n+  unsigned mask;\n+\n+  HOST_WIDE_INT val;\n+\n+  if (mode != V16QImode && mode != V8HImode && mode != V4SImode)\n+    return false;\n+\n+  /* We need to create pseudo registers to do the shift, so don't recognize\n+     shift vector constants after reload.  */\n+  if (!can_create_pseudo_p ())\n+    return false;\n+\n+  nunits = GET_MODE_NUNITS (mode);\n+  mask = GET_MODE_MASK (inner);\n+\n+  val = const_vector_elt_as_int (op, BYTES_BIG_ENDIAN ? 0 : nunits - 1);\n+\n+  /* Check if the value can really be the operand of a vspltis[bhw].  */\n+  if (EASY_VECTOR_15 (val))\n+    ;\n+\n+  /* Also check if we are loading up the most significant bit which can be done\n+     by loading up -1 and shifting the value left by -1.  */\n+  else if (EASY_VECTOR_MSB (val, inner))\n+    ;\n+\n+  else\n+    return 0;\n+\n+  /* Check if VAL is present in every STEP-th element until we find elements\n+     that are 0 or all 1 bits.  */\n+  for (i = 1; i < nunits; ++i)\n+    {\n+      unsigned elt = BYTES_BIG_ENDIAN ? i : nunits - 1 - i;\n+      HOST_WIDE_INT elt_val = const_vector_elt_as_int (op, elt);\n+\n+      /* If the value isn't the splat value, check for the remaining elements\n+\t being 0/-1.  */\n+      if (val != elt_val)\n+\t{\n+\t  if (elt_val == 0)\n+\t    {\n+\t      for (j = i+1; j < nunits; ++j)\n+\t\t{\n+\t\t  unsigned elt2 = BYTES_BIG_ENDIAN ? j : nunits - 1 - j;\n+\t\t  if (const_vector_elt_as_int (op, elt2) != 0)\n+\t\t    return 0;\n+\t\t}\n+\n+\t      return (nunits - i) * GET_MODE_SIZE (inner);\n+\t    }\n+\n+\t  else if ((elt_val & mask) == mask)\n+\t    {\n+\t      for (j = i+1; j < nunits; ++j)\n+\t\t{\n+\t\t  unsigned elt2 = BYTES_BIG_ENDIAN ? j : nunits - 1 - j;\n+\t\t  if ((const_vector_elt_as_int (op, elt2) & mask) != mask)\n+\t\t    return 0;\n+\t\t}\n+\n+\t      return -((nunits - i) * GET_MODE_SIZE (inner));\n+\t    }\n+\n+\t  else\n+\t    return 0;\n+\t}\n+    }\n+\n+  /* If all elements are equal, we don't need to do VLSDOI.  */\n+  return 0;\n+}\n+\n \n /* Return true if OP is of the given MODE and can be synthesized\n    with a vspltisb, vspltish or vspltisw.  */\n@@ -5513,6 +5603,9 @@ easy_altivec_constant (rtx op, machine_mode mode)\n   if (vspltis_constant (op, step, copies))\n     return true;\n \n+  if (vspltis_shifted (op) != 0)\n+    return true;\n+\n   return false;\n }\n \n@@ -5556,7 +5649,7 @@ gen_easy_altivec_constant (rtx op)\n const char *\n output_vec_const_move (rtx *operands)\n {\n-  int cst, cst2;\n+  int cst, cst2, shift;\n   machine_mode mode;\n   rtx dest, vec;\n \n@@ -5569,10 +5662,13 @@ output_vec_const_move (rtx *operands)\n       if (zero_constant (vec, mode))\n \treturn \"xxlxor %x0,%x0,%x0\";\n \n+      if (TARGET_P8_VECTOR && vec == CONSTM1_RTX (mode))\n+\treturn \"xxlorc %x0,%x0,%x0\";\n+\n       if ((mode == V2DImode || mode == V1TImode)\n \t  && INTVAL (CONST_VECTOR_ELT (vec, 0)) == -1\n \t  && INTVAL (CONST_VECTOR_ELT (vec, 1)) == -1)\n-\treturn \"vspltisw %0,-1\";\n+\treturn (TARGET_P8_VECTOR) ? \"xxlorc %x0,%x0,%x0\" : \"vspltisw %0,-1\";\n     }\n \n   if (TARGET_ALTIVEC)\n@@ -5581,6 +5677,11 @@ output_vec_const_move (rtx *operands)\n       if (zero_constant (vec, mode))\n \treturn \"vxor %0,%0,%0\";\n \n+      /* Do we need to construct a value using VSLDOI?  */\n+      shift = vspltis_shifted (vec);\n+      if (shift != 0)\n+\treturn \"#\";\n+\n       splat_vec = gen_easy_altivec_constant (vec);\n       gcc_assert (GET_CODE (splat_vec) == VEC_DUPLICATE);\n       operands[1] = XEXP (splat_vec, 0);"}, {"sha": "e4f2937325290efc1f35fe4caa0a29895b84ea2c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=683be46fa65feb540990b6cfea729f4234d71298", "patch": "@@ -1980,7 +1980,7 @@ typedef struct rs6000_args\n \t\t\t\t    && ((n) & 1) == 0)\n \n #define EASY_VECTOR_MSB(n,mode)\t\t\t\t\t\t\\\n-  (((unsigned HOST_WIDE_INT)n) ==\t\t\t\t\t\\\n+  ((((unsigned HOST_WIDE_INT) (n)) & GET_MODE_MASK (mode)) ==\t\t\\\n    ((((unsigned HOST_WIDE_INT)GET_MODE_MASK (mode)) + 1) >> 1))\n \n \f"}, {"sha": "20735b946b67d88992541c1180c3f2b7280dc025", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=683be46fa65feb540990b6cfea729f4234d71298", "patch": "@@ -1,3 +1,11 @@\n+2015-08-12  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/67071\n+\t* gcc.target/powerpc/pr67071-1.c: New file to test PR 67071 new\n+\tvector constants.\n+\t* gcc.target/powerpc/pr67071-2.c: Likewise.\n+\t* gcc.target/powerpc/pr67071-3.c: Likewise.\n+\n 2015-08-12  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/55095"}, {"sha": "c50b4e55f7b88348e72dcc0db0ae61989ee31350", "filename": "gcc/testsuite/gcc.target/powerpc/pr67071-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr67071-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr67071-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr67071-1.c?ref=683be46fa65feb540990b6cfea729f4234d71298", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power6\" } } */\n+/* { dg-options \"-mcpu=power6 -maltivec\" } */\n+\n+vector unsigned char\n+foo_char (void)\n+{\n+  return (vector unsigned char) {\n+    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n+    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80\n+  };\n+}\n+\n+vector unsigned short\n+foo_short (void)\n+{\n+  return (vector unsigned short) {\n+    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000\n+  };\n+}\n+\n+vector unsigned int\n+foo_int (void)\n+{\n+  return (vector unsigned int) {\n+    0x80000000u, 0x80000000u, 0x80000000u, 0x80000000u,\n+  };\n+}\n+\n+/* { dg-final { scan-assembler-times \"vspltisw\" 3 } } */\n+/* { dg-final { scan-assembler-times \"vslb\"     1 } } */\n+/* { dg-final { scan-assembler-times \"vslh\"     1 } } */\n+/* { dg-final { scan-assembler-times \"vslw\"     1 } } */"}, {"sha": "9c34b3e799fa7a3674d8848f78f1c37af8619a22", "filename": "gcc/testsuite/gcc.target/powerpc/pr67071-2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr67071-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr67071-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr67071-2.c?ref=683be46fa65feb540990b6cfea729f4234d71298", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power6\" } } */\n+/* { dg-options \"-mcpu=power6 -maltivec\" } */\n+\n+vector unsigned char\n+foo_char (void)\n+{\n+  return (vector unsigned char) {\n+#if __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__\n+    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+#else\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80\n+#endif\n+  };\n+}\n+\n+vector unsigned short\n+foo_short (void)\n+{\n+  return (vector unsigned short) {\n+#if __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__\n+    0x8000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000\n+#else\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x8000\n+#endif\n+  };\n+}\n+\n+vector unsigned int\n+foo_int (void)\n+{\n+  return (vector unsigned int) {\n+#if __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__\n+    0x80000000u, 0x00000000u, 0x00000000u, 0x00000000u,\n+#else\n+    0x00000000u, 0x00000000u, 0x00000000u, 0x80000000u,\n+#endif\n+  };\n+}\n+\n+/* { dg-final { scan-assembler-times \"vspltisw\" 3 } } */\n+/* { dg-final { scan-assembler-times \"vsldoi\"   3 } } */\n+/* { dg-final { scan-assembler-times \"vslb\"     1 } } */\n+/* { dg-final { scan-assembler-times \"vslh\"     1 } } */\n+/* { dg-final { scan-assembler-times \"vslw\"     1 } } */"}, {"sha": "470afb787a4ed99b39dcc348a8090f90cf08b68b", "filename": "gcc/testsuite/gcc.target/powerpc/pr67071-3.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr67071-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683be46fa65feb540990b6cfea729f4234d71298/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr67071-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr67071-3.c?ref=683be46fa65feb540990b6cfea729f4234d71298", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power6\" } } */\n+/* { dg-options \"-mcpu=power6 -maltivec\" } */\n+\n+\n+vector unsigned char\n+foo_char (void)\n+{\n+  return (vector unsigned char) {\n+#if __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__\n+    0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n+#else\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x80\n+#endif\n+  };\n+}\n+\n+vector unsigned short\n+foo_short (void)\n+{\n+  return (vector unsigned short) {\n+#if __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__\n+    0x8000, 0x8000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff\n+#else\n+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x8000, 0x8000\n+#endif\n+  };\n+}\n+\n+vector unsigned int\n+foo_int (void)\n+{\n+  return (vector unsigned int) {\n+#if __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__\n+    0x80000000u, 0x80000000u, 0xffffffffu, 0xffffffffu,\n+#else\n+    0xffffffffu, 0xffffffffu, 0x80000000u, 0x80000000u,\n+#endif\n+  };\n+}\n+\n+/* { dg-final { scan-assembler-times \"vslb\"   1 } } */\n+/* { dg-final { scan-assembler-times \"vslh\"   1 } } */\n+/* { dg-final { scan-assembler-times \"vslw\"   1 } } */\n+/* { dg-final { scan-assembler-times \"vsldoi\" 3 } } */"}]}