{"sha": "39703eb9e28d401299fb5c86d4b8d51981fa058d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk3MDNlYjllMjhkNDAxMjk5ZmI1Yzg2ZDRiOGQ1MTk4MWZhMDU4ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-17T04:31:42Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-17T04:31:42Z"}, "message": "re PR c++/11547 (ICE with const temporaries)\n\n\tPR c++/11547\n\t* cp-tree.h (DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P): New\n\tmacro.\n\t(DECL_PRETTY_FUNCTION_P): Use VAR_DECL_CHECK.\n\t* decl.c (duplicate_decls): Merge\n\tDECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P.\n\t* parser.c (cp_parser_postfix_expression): Adjust call to\n\tcp_parser_initializer_list and\n\tcp_parser_parenthesized_expression_list.\n\t(cp_parser_parenthesized_expression_list): Add non_constant_p.\n\t(cp_parser_new_placement): Adjust call to\n\tcp_parser_parenthesized_expression_list.\n\t(cp_parser_direct_new_declarator): Likewise.\n\t(cp_parser_conditional_expression): Remove.\n\t(cp_parser_constant_expression): Parse an assignment-expression,\n\tnot a conditional-expression.\n\t(cp_parser_simple_declaration): Resolve expression/declaration\n\tambiguity more quickly.\n\t(cp_parser_mem_initializer): Adjust call to\n\tcp_parser_parenthesized_expression_list.\n\t(cp_parser_init_declarator): Keep track of whether or not the\n\tinitializer is a constant-expression.\n\t(cp_parser_initializer): Add non_constant_p parameter.\n\t(cp_parser_initializer_clause): Likewise.\n\t(cp_parser_initializer_list): Likewise.\n\t(cp_parser_attribute_list): Adjust call to\n\tcp_parser_parenthesized_expression_list.\n\t(cp_parser_functional_cast): Likewise.\n\t* pt.c (tsubst_decl): Copy\n\tDECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P.\n\t(tsubst_expr): Tweak use of DECL_PRETTY_FUNCTION_P.\n\t* semantics.c (finish_id_expression): Use\n\tDECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P.\n\n\tPR c++/11547\n\t* g++.dg/parse/constant3.C: New test.\n\t* g++.dg/parse/crash7.C: Likewise.\n\nFrom-SVN: r69493", "tree": {"sha": "eab02b08c217a06c773812f40a3bf9384443716d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eab02b08c217a06c773812f40a3bf9384443716d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39703eb9e28d401299fb5c86d4b8d51981fa058d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39703eb9e28d401299fb5c86d4b8d51981fa058d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39703eb9e28d401299fb5c86d4b8d51981fa058d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39703eb9e28d401299fb5c86d4b8d51981fa058d/comments", "author": null, "committer": null, "parents": [{"sha": "db5eed1873ad17205d6cf4ac15ca84f4822b5381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db5eed1873ad17205d6cf4ac15ca84f4822b5381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db5eed1873ad17205d6cf4ac15ca84f4822b5381"}], "stats": {"total": 293, "additions": 200, "deletions": 93}, "files": [{"sha": "c4d01e69579fc2293bb7b25af2fad7767354ce87", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=39703eb9e28d401299fb5c86d4b8d51981fa058d", "patch": "@@ -1,3 +1,39 @@\n+2003-07-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11547\n+\t* cp-tree.h (DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P): New\n+\tmacro.\n+\t(DECL_PRETTY_FUNCTION_P): Use VAR_DECL_CHECK.\n+\t* decl.c (duplicate_decls): Merge\n+\tDECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P.\n+\t* parser.c (cp_parser_postfix_expression): Adjust call to\n+\tcp_parser_initializer_list and\n+\tcp_parser_parenthesized_expression_list.\n+\t(cp_parser_parenthesized_expression_list): Add non_constant_p.\n+\t(cp_parser_new_placement): Adjust call to\n+\tcp_parser_parenthesized_expression_list.\n+\t(cp_parser_direct_new_declarator): Likewise.\n+\t(cp_parser_conditional_expression): Remove.\n+\t(cp_parser_constant_expression): Parse an assignment-expression,\n+\tnot a conditional-expression.\n+\t(cp_parser_simple_declaration): Resolve expression/declaration\n+\tambiguity more quickly.\n+\t(cp_parser_mem_initializer): Adjust call to\n+\tcp_parser_parenthesized_expression_list.\n+\t(cp_parser_init_declarator): Keep track of whether or not the\n+\tinitializer is a constant-expression.\n+\t(cp_parser_initializer): Add non_constant_p parameter.\n+\t(cp_parser_initializer_clause): Likewise.\n+\t(cp_parser_initializer_list): Likewise.\n+\t(cp_parser_attribute_list): Adjust call to\n+\tcp_parser_parenthesized_expression_list.\n+\t(cp_parser_functional_cast): Likewise.\n+\t* pt.c (tsubst_decl): Copy\n+\tDECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P.\n+\t(tsubst_expr): Tweak use of DECL_PRETTY_FUNCTION_P.\n+\t* semantics.c (finish_id_expression): Use\n+\tDECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P.\n+\t\n 2003-07-16  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* lang-options.h: Remove."}, {"sha": "1728b379353547b963ea148ff2ae5159fd832c1d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=39703eb9e28d401299fb5c86d4b8d51981fa058d", "patch": "@@ -45,6 +45,7 @@ struct diagnostic_context;\n       AGGR_INIT_VIA_CTOR_P (in AGGR_INIT_EXPR)\n       PTRMEM_OK_P (in ADDR_EXPR, OFFSET_REF)\n       PARMLIST_ELLIPSIS_P (in PARMLIST)\n+      DECL_PRETTY_FUNCTION_P (in VAR_DECL)\n    1: IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -59,6 +60,7 @@ struct diagnostic_context;\n       ICS_THIS_FLAG (in _CONV)\n       BINFO_LOST_PRIMARY_P (in BINFO)\n       TREE_PARMLIST (in TREE_LIST)\n+      DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n    3: TYPE_USES_VIRTUAL_BASECLASSES (in a class TYPE).\n       BINFO_VTABLE_PATH_MARKED.\n       BINFO_PUSHDECLS_MARKED.\n@@ -1926,6 +1928,11 @@ struct lang_decl GTY(())\n #define DECL_INITIALIZED_P(NODE) \\\n    (TREE_LANG_FLAG_1 (VAR_DECL_CHECK (NODE)))\n \n+/* Nonzero for a VAR_DECL that was initialized with a\n+   constant-expression.  */\n+#define DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P(NODE) \\\n+  (TREE_LANG_FLAG_2 (VAR_DECL_CHECK (NODE)))\n+\n /* Nonzero if the DECL was initialized in the class definition itself,\n    rather than outside the class.  This is used for both static member\n    VAR_DECLS, and FUNTION_DECLS that are defined in the class.  */\n@@ -2033,7 +2040,7 @@ struct lang_decl GTY(())\n /* Nonzero if this DECL is the __PRETTY_FUNCTION__ variable in a\n    template function.  */\n #define DECL_PRETTY_FUNCTION_P(NODE) \\\n-  (TREE_LANG_FLAG_0 (NODE))\n+  (TREE_LANG_FLAG_0 (VAR_DECL_CHECK (NODE)))\n \n /* The _TYPE context in which this _DECL appears.  This field holds the\n    class where a virtual function instance is actually defined.  */"}, {"sha": "62ecbc487b4e66ec3ca55d7bc8fb1dac015587f5", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=39703eb9e28d401299fb5c86d4b8d51981fa058d", "patch": "@@ -3306,6 +3306,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t{\n \t  DECL_THIS_EXTERN (newdecl) |= DECL_THIS_EXTERN (olddecl);\n \t  DECL_INITIALIZED_P (newdecl) |= DECL_INITIALIZED_P (olddecl);\n+\t  DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (newdecl)\n+\t    |= DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (olddecl);\n \t}\n \n       /* Do this after calling `merge_types' so that default"}, {"sha": "8af9f46d7f169160dc9393761c3fdb30fabc0c72", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 122, "deletions": 82, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=39703eb9e28d401299fb5c86d4b8d51981fa058d", "patch": "@@ -1311,7 +1311,7 @@ static tree cp_parser_class_or_namespace_name\n static tree cp_parser_postfix_expression\n   (cp_parser *, bool);\n static tree cp_parser_parenthesized_expression_list\n-  (cp_parser *, bool);\n+  (cp_parser *, bool, bool *);\n static void cp_parser_pseudo_destructor_name\n   (cp_parser *, tree *, tree *);\n static tree cp_parser_unary_expression\n@@ -1356,8 +1356,6 @@ static tree cp_parser_logical_and_expression\n   (cp_parser *);\n static tree cp_parser_logical_or_expression \n   (cp_parser *);\n-static tree cp_parser_conditional_expression\n-  (cp_parser *);\n static tree cp_parser_question_colon_clause\n   (cp_parser *, tree);\n static tree cp_parser_assignment_expression\n@@ -1479,11 +1477,11 @@ static tree cp_parser_function_definition\n static void cp_parser_function_body\n   (cp_parser *);\n static tree cp_parser_initializer\n-  (cp_parser *, bool *);\n+  (cp_parser *, bool *, bool *);\n static tree cp_parser_initializer_clause\n-  (cp_parser *);\n+  (cp_parser *, bool *);\n static tree cp_parser_initializer_list\n-  (cp_parser *);\n+  (cp_parser *, bool *);\n \n static bool cp_parser_ctor_initializer_opt_and_function_body\n   (cp_parser *);\n@@ -3375,9 +3373,10 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t       keep going.  */\n \t    if (!cp_parser_error_occurred (parser))\n \t      {\n+\t\tbool non_constant_p;\n \t\t/* Parse the initializer-list.  */\n \t\tinitializer_list \n-\t\t  = cp_parser_initializer_list (parser);\n+\t\t  = cp_parser_initializer_list (parser, &non_constant_p);\n \t\t/* Allow a trailing `,'.  */\n \t\tif (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \t\t  cp_lexer_consume_token (parser->lexer);\n@@ -3472,7 +3471,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \tcase CPP_OPEN_PAREN:\n \t  /* postfix-expression ( expression-list [opt] ) */\n \t  {\n-\t    tree args = cp_parser_parenthesized_expression_list (parser, false);\n+\t    tree args = (cp_parser_parenthesized_expression_list \n+\t\t\t (parser, false, /*non_constant_p=*/NULL));\n \n \t    if (args == error_mark_node)\n \t      {\n@@ -3735,14 +3735,22 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n    error_mark_node is returned if the ( and or ) are\n    missing. NULL_TREE is returned on no expressions. The parentheses\n    are eaten. IS_ATTRIBUTE_LIST is true if this is really an attribute\n-   list being parsed. */\n+   list being parsed.  If NON_CONSTANT_P is non-NULL, *NON_CONSTANT_P\n+   indicates whether or not all of the expressions in the list were\n+   constant.  */\n \n static tree\n-cp_parser_parenthesized_expression_list (cp_parser* parser, bool is_attribute_list)\n+cp_parser_parenthesized_expression_list (cp_parser* parser, \n+\t\t\t\t\t bool is_attribute_list,\n+\t\t\t\t\t bool *non_constant_p)\n {\n   tree expression_list = NULL_TREE;\n   tree identifier = NULL_TREE;\n-  \n+\n+  /* Assume all the expressions will be constant.  */\n+  if (non_constant_p)\n+    *non_constant_p = false;\n+\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n     return error_mark_node;\n   \n@@ -3767,7 +3775,17 @@ cp_parser_parenthesized_expression_list (cp_parser* parser, bool is_attribute_li\n \telse\n \t  {\n \t    /* Parse the next assignment-expression.  */\n-\t    expr = cp_parser_assignment_expression (parser);\n+\t    if (non_constant_p)\n+\t      {\n+\t\tbool expr_non_constant_p;\n+\t\texpr = (cp_parser_constant_expression \n+\t\t\t(parser, /*allow_non_constant_p=*/true,\n+\t\t\t &expr_non_constant_p));\n+\t\tif (expr_non_constant_p)\n+\t\t  *non_constant_p = true;\n+\t      }\n+\t    else\n+\t      expr = cp_parser_assignment_expression (parser);\n \n \t     /* Add it to the list.  We add error_mark_node\n \t\texpressions to the list, so that we can still tell if\n@@ -4177,7 +4195,8 @@ cp_parser_new_placement (cp_parser* parser)\n   tree expression_list;\n \n   /* Parse the expression-list.  */\n-  expression_list = cp_parser_parenthesized_expression_list (parser, false);\n+  expression_list = (cp_parser_parenthesized_expression_list \n+\t\t     (parser, false, /*non_constant_p=*/NULL));\n \n   return expression_list;\n }\n@@ -4341,7 +4360,8 @@ cp_parser_new_initializer (cp_parser* parser)\n {\n   tree expression_list;\n \n-  expression_list = cp_parser_parenthesized_expression_list (parser, false);\n+  expression_list = (cp_parser_parenthesized_expression_list \n+\t\t     (parser, false, /*non_constant_p=*/NULL));\n   if (!expression_list)\n     expression_list = void_zero_node;\n \n@@ -4755,43 +4775,12 @@ cp_parser_logical_or_expression (cp_parser* parser)\n \t\t\t\t      cp_parser_logical_and_expression);\n }\n \n-/* Parse a conditional-expression.\n-\n-   conditional-expression:\n-     logical-or-expression\n-     logical-or-expression ? expression : assignment-expression\n-     \n-   GNU Extensions:\n-   \n-   conditional-expression:\n-     logical-or-expression ?  : assignment-expression\n-\n-   Returns a representation of the expression.  */\n-\n-static tree\n-cp_parser_conditional_expression (cp_parser* parser)\n-{\n-  tree logical_or_expr;\n-\n-  /* Parse the logical-or-expression.  */\n-  logical_or_expr = cp_parser_logical_or_expression (parser);\n-  /* If the next token is a `?', then we have a real conditional\n-     expression.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_QUERY))\n-    return cp_parser_question_colon_clause (parser, logical_or_expr);\n-  /* Otherwise, the value is simply the logical-or-expression.  */\n-  else\n-    return logical_or_expr;\n-}\n-\n /* Parse the `? expression : assignment-expression' part of a\n    conditional-expression.  The LOGICAL_OR_EXPR is the\n    logical-or-expression that started the conditional-expression.\n    Returns a representation of the entire conditional-expression.\n \n-   This routine exists only so that it can be shared between\n-   cp_parser_conditional_expression and\n-   cp_parser_assignment_expression.\n+   This routine is used by cp_parser_assignment_expression.\n \n      ? expression : assignment-expression\n    \n@@ -5071,8 +5060,16 @@ cp_parser_constant_expression (cp_parser* parser,\n   parser->constant_expression_p = true;\n   parser->allow_non_constant_expression_p = allow_non_constant_p;\n   parser->non_constant_expression_p = false;\n-  /* Parse the conditional-expression.  */\n-  expression = cp_parser_conditional_expression (parser);\n+  /* Although the grammar says \"conditional-expression\", we parse an\n+     \"assignment-expression\", which also permits \"throw-expression\"\n+     and the use of assignment operators.  In the case that\n+     ALLOW_NON_CONSTANT_P is false, we get better errors than we would\n+     otherwise.  In the case that ALLOW_NON_CONSTANT_P is true, it is\n+     actually essential that we look for an assignment-expression.\n+     For example, cp_parser_initializer_clauses uses this function to\n+     determine whether a particular assignment-expression is in fact\n+     constant.  */\n+  expression = cp_parser_assignment_expression (parser);\n   /* Restore the old settings.  */\n   parser->constant_expression_p = saved_constant_expression_p;\n   parser->allow_non_constant_expression_p \n@@ -6081,6 +6078,15 @@ cp_parser_simple_declaration (cp_parser* parser,\n   /* We no longer need to defer access checks.  */\n   stop_deferring_access_checks ();\n \n+  /* In a block scope, a valid declaration must always have a\n+     decl-specifier-seq.  By not trying to parse declarators, we can\n+     resolve the declaration/expression ambiguity more quickly.  */\n+  if (!function_definition_allowed_p && !decl_specifiers)\n+    {\n+      cp_parser_error (parser, \"expected declaration\");\n+      goto done;\n+    }\n+\n   /* If the next two tokens are both identifiers, the code is\n      erroneous. The usual cause of this situation is code like:\n \n@@ -6093,7 +6099,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n \t looking at a declaration.  */\n       cp_parser_commit_to_tentative_parse (parser);\n       /* Give up.  */\n-      return;\n+      goto done;\n     }\n \n   /* Keep going until we hit the `;' at the end of the simple\n@@ -6116,10 +6122,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n \t statement is treated as a declaration-statement until proven\n \t otherwise.)  */\n       if (cp_parser_error_occurred (parser))\n-\t{\n-\t  pop_deferring_access_checks ();\n-\t  return;\n-\t}\n+\tgoto done;\n       /* Handle function definitions specially.  */\n       if (function_definition_p)\n \t{\n@@ -6152,8 +6155,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n \t  cp_parser_error (parser, \"expected `,' or `;'\");\n \t  /* Skip tokens until we reach the end of the statement.  */\n \t  cp_parser_skip_to_end_of_statement (parser);\n-\t  pop_deferring_access_checks ();\n-\t  return;\n+\t  goto done;\n \t}\n       /* After the first time around, a function-definition is not\n \t allowed -- even if it was OK at first.  For example:\n@@ -6175,14 +6177,15 @@ cp_parser_simple_declaration (cp_parser* parser,\n       perform_deferred_access_checks ();\n     }\n \n-  pop_deferring_access_checks ();\n-\n   /* Consume the `;'.  */\n   cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n \n   /* Mark all the classes that appeared in the decl-specifier-seq as\n      having received a `;'.  */\n   note_list_got_semicolon (decl_specifiers);\n+\n+ done:\n+  pop_deferring_access_checks ();\n }\n \n /* Parse a decl-specifier-seq.\n@@ -6774,7 +6777,9 @@ cp_parser_mem_initializer (cp_parser* parser)\n   if (member && !DECL_P (member))\n     in_base_initializer = 1;\n \n-  expression_list = cp_parser_parenthesized_expression_list (parser, false);\n+  expression_list \n+    = cp_parser_parenthesized_expression_list (parser, false,\n+\t\t\t\t\t       /*non_constant_p=*/NULL);\n   if (!expression_list)\n     expression_list = void_type_node;\n \n@@ -9156,6 +9161,7 @@ cp_parser_init_declarator (cp_parser* parser,\n   tree scope;\n   bool is_initialized;\n   bool is_parenthesized_init;\n+  bool is_non_constant_init;\n   int ctor_dtor_or_conv_p;\n   bool friend_p;\n \n@@ -9325,11 +9331,14 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   /* Parse the initializer.  */\n   if (is_initialized)\n-    initializer = cp_parser_initializer (parser, &is_parenthesized_init);\n+    initializer = cp_parser_initializer (parser, \n+\t\t\t\t\t &is_parenthesized_init,\n+\t\t\t\t\t &is_non_constant_init);\n   else\n     {\n       initializer = NULL_TREE;\n       is_parenthesized_init = false;\n+      is_non_constant_init = true;\n     }\n \n   /* The old parser allows attributes to appear after a parenthesized\n@@ -9371,6 +9380,12 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t    ((is_parenthesized_init || !is_initialized)\n \t\t     ? 0 : LOOKUP_ONLYCONVERTING));\n \n+  /* Remember whether or not variables were initialized by\n+     constant-expressions.  */\n+  if (decl && TREE_CODE (decl) == VAR_DECL \n+      && is_initialized && !is_non_constant_init)\n+    DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = true;\n+\n   return decl;\n }\n \n@@ -10729,10 +10744,13 @@ cp_parser_ctor_initializer_opt_and_function_body (cp_parser *parser)\n \n    *IS_PARENTHESIZED_INIT is set to TRUE if the `( expression-list )'\n    production is used, and zero otherwise.  *IS_PARENTHESIZED_INIT is\n-   set to FALSE if there is no initializer present.  */\n+   set to FALSE if there is no initializer present.  If there is an\n+   initializer, and it is not a constant-expression, *NON_CONSTANT_P\n+   is set to true; otherwise it is set to false.  */\n \n static tree\n-cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init)\n+cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init,\n+\t\t       bool* non_constant_p)\n {\n   cp_token *token;\n   tree init;\n@@ -10743,16 +10761,19 @@ cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init)\n   /* Let our caller know whether or not this initializer was\n      parenthesized.  */\n   *is_parenthesized_init = (token->type == CPP_OPEN_PAREN);\n+  /* Assume that the initializer is constant.  */\n+  *non_constant_p = false;\n \n   if (token->type == CPP_EQ)\n     {\n       /* Consume the `='.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Parse the initializer-clause.  */\n-      init = cp_parser_initializer_clause (parser);\n+      init = cp_parser_initializer_clause (parser, non_constant_p);\n     }\n   else if (token->type == CPP_OPEN_PAREN)\n-    init = cp_parser_parenthesized_expression_list (parser, false);\n+    init = cp_parser_parenthesized_expression_list (parser, false,\n+\t\t\t\t\t\t    non_constant_p);\n   else\n     {\n       /* Anything else is an error.  */\n@@ -10779,17 +10800,21 @@ cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init)\n    the elements of the initializer-list (or NULL_TREE, if the last\n    production is used).  The TREE_TYPE for the CONSTRUCTOR will be\n    NULL_TREE.  There is no way to detect whether or not the optional\n-   trailing `,' was provided.  */\n+   trailing `,' was provided.  NON_CONSTANT_P is as for\n+   cp_parser_initializer.  */\n \n static tree\n-cp_parser_initializer_clause (cp_parser* parser)\n+cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)\n {\n   tree initializer;\n \n   /* If it is not a `{', then we are looking at an\n      assignment-expression.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE))\n-    initializer = cp_parser_assignment_expression (parser);\n+    initializer \n+      = cp_parser_constant_expression (parser,\n+\t\t\t\t       /*allow_non_constant_p=*/true,\n+\t\t\t\t       non_constant_p);\n   else\n     {\n       /* Consume the `{' token.  */\n@@ -10805,12 +10830,11 @@ cp_parser_initializer_clause (cp_parser* parser)\n \t{\n \t  /* Parse the initializer list.  */\n \t  CONSTRUCTOR_ELTS (initializer)\n-\t    = cp_parser_initializer_list (parser);\n+\t    = cp_parser_initializer_list (parser, non_constant_p);\n \t  /* A trailing `,' token is allowed.  */\n \t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \t    cp_lexer_consume_token (parser->lexer);\n \t}\n-\n       /* Now, there should be a trailing `}'.  */\n       cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n     }\n@@ -10832,20 +10856,25 @@ cp_parser_initializer_clause (cp_parser* parser)\n \n    Returns a TREE_LIST.  The TREE_VALUE of each node is an expression\n    for the initializer.  If the TREE_PURPOSE is non-NULL, it is the\n-   IDENTIFIER_NODE naming the field to initialize.  */\n+   IDENTIFIER_NODE naming the field to initialize.  NON_CONSTANT_P is\n+   as for cp_parser_initializer.  */\n \n static tree\n-cp_parser_initializer_list (cp_parser* parser)\n+cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n {\n   tree initializers = NULL_TREE;\n \n+  /* Assume all of the expressions are constant.  */\n+  *non_constant_p = false;\n+\n   /* Parse the rest of the list.  */\n   while (true)\n     {\n       cp_token *token;\n       tree identifier;\n       tree initializer;\n-      \n+      bool clause_non_constant_p;\n+\n       /* If the next token is an identifier and the following one is a\n \t colon, we are looking at the GNU designated-initializer\n \t syntax.  */\n@@ -10862,8 +10891,11 @@ cp_parser_initializer_list (cp_parser* parser)\n \tidentifier = NULL_TREE;\n \n       /* Parse the initializer.  */\n-      initializer = cp_parser_initializer_clause (parser);\n-\n+      initializer = cp_parser_initializer_clause (parser, \n+\t\t\t\t\t\t  &clause_non_constant_p);\n+      /* If any clause is non-constant, so is the entire initializer.  */\n+      if (clause_non_constant_p)\n+\t*non_constant_p = true;\n       /* Add it to the list.  */\n       initializers = tree_cons (identifier, initializer, initializers);\n \n@@ -11821,12 +11853,18 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t  (cp_lexer_peek_token (parser->lexer)))\n \t\tdecl = error_mark_node;\n \t      else\n-\t\t/* Create the declaration.  */\n-\t\tdecl = grokfield (declarator, \n-\t\t\t\t  decl_specifiers, \n-\t\t\t\t  initializer,\n-\t\t\t\t  asm_specification,\n-\t\t\t\t  attributes);\n+\t\t{\n+\t\t  /* Create the declaration.  */\n+\t\t  decl = grokfield (declarator, \n+\t\t\t\t    decl_specifiers, \n+\t\t\t\t    initializer,\n+\t\t\t\t    asm_specification,\n+\t\t\t\t    attributes);\n+\t\t  /* Any initialization must have been from a\n+\t\t     constant-expression.  */\n+\t\t  if (decl && TREE_CODE (decl) == VAR_DECL && initializer)\n+\t\t    DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = 1;\n+\t\t}\n \t    }\n \n \t  /* Reset PREFIX_ATTRIBUTES.  */\n@@ -12616,8 +12654,8 @@ cp_parser_attribute_list (cp_parser* parser)\n \t{\n \t  tree arguments;\n \n-\t  arguments = cp_parser_parenthesized_expression_list (parser, true);\n-\n+\t  arguments = (cp_parser_parenthesized_expression_list \n+\t\t       (parser, true, /*non_constant_p=*/NULL));\n \t  /* Save the identifier and arguments away.  */\n \t  TREE_VALUE (attribute) = arguments;\n \t}\n@@ -13583,7 +13621,9 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n {\n   tree expression_list;\n \n-  expression_list = cp_parser_parenthesized_expression_list (parser, false);\n+  expression_list \n+    = cp_parser_parenthesized_expression_list (parser, false,\n+\t\t\t\t\t       /*non_constant_p=*/NULL);\n \n   return build_functional_cast (type, expression_list);\n }"}, {"sha": "6c4a5a86815c8f524f68e2177ad44d54fdb16bfc", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=39703eb9e28d401299fb5c86d4b8d51981fa058d", "patch": "@@ -6190,7 +6190,11 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \n \tr = copy_decl (t);\n \tif (TREE_CODE (r) == VAR_DECL)\n-\t  type = complete_type (type);\n+\t  {\n+\t    type = complete_type (type);\n+\t    DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (r)\n+\t      = DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (t);\n+\t  }\n \telse if (DECL_SELF_REFERENCE_P (t))\n \t  SET_DECL_SELF_REFERENCE_P (r);\n \tTREE_TYPE (r) = type;\n@@ -7620,7 +7624,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\telse \n \t\t  {\n \t\t    maybe_push_decl (decl);\n-\t\t    if (DECL_PRETTY_FUNCTION_P (decl))\n+\t\t    if (TREE_CODE (decl) == VAR_DECL\n+\t\t\t&& DECL_PRETTY_FUNCTION_P (decl))\n \t\t      {\n \t\t\t/* For __PRETTY_FUNCTION__ we have to adjust the\n \t\t\t   initializer.  */"}, {"sha": "3d704ebe194258a5fd4c0c5a65e1f044f276a4d7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=39703eb9e28d401299fb5c86d4b8d51981fa058d", "patch": "@@ -2478,17 +2478,11 @@ finish_id_expression (tree id_expression,\n \t  ;\n \t  /* Const variables or static data members of integral or\n \t     enumeration types initialized with constant expressions\n-\t     are OK.  We also accept dependent initializers; they may\n-\t     turn out to be constant at instantiation-time.  */\n+\t     are OK.  */\n \t  else if (TREE_CODE (decl) == VAR_DECL\n \t\t   && CP_TYPE_CONST_P (TREE_TYPE (decl))\n \t\t   && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl))\n-\t\t   && DECL_INITIAL (decl)\n-\t\t   && (TREE_CONSTANT (DECL_INITIAL (decl))\n-\t\t       || type_dependent_expression_p (DECL_INITIAL \n-\t\t\t\t\t\t       (decl))\n-\t\t       || value_dependent_expression_p (DECL_INITIAL \n-\t\t\t\t\t\t\t(decl))))\n+\t\t   && DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl))\n \t    ;\n \t  else\n \t    {"}, {"sha": "d6cced3bbc61653e2d5337d6a6e7dde4af1fa6f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=39703eb9e28d401299fb5c86d4b8d51981fa058d", "patch": "@@ -1,3 +1,9 @@\n+2003-07-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11547\n+\t* g++.dg/parse/constant3.C: New test.\n+\t* g++.dg/parse/crash7.C: Likewise.\n+\n 2003-07-16  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR target/11008"}, {"sha": "c029e33ed5827652cc3ad1378eee361e4c072bc1", "filename": "gcc/testsuite/g++.dg/parse/constant3.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstant3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstant3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstant3.C?ref=39703eb9e28d401299fb5c86d4b8d51981fa058d", "patch": "@@ -0,0 +1,7 @@\n+const int i = 1;\n+const int j (2);\n+const int k = { 3 };\n+\n+enum { a = i, b = j, c = k };\n+\n+"}, {"sha": "86fa477266b10433f3efd72d7b172c68e2f104d9", "filename": "gcc/testsuite/g++.dg/parse/crash7.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39703eb9e28d401299fb5c86d4b8d51981fa058d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash7.C?ref=39703eb9e28d401299fb5c86d4b8d51981fa058d", "patch": "@@ -0,0 +1,10 @@\n+struct A\n+{\n+    int foo () const { return 0; }\n+};\n+\n+template <typename> void bar (int x[], const A &a)\n+{\n+    const int i=a.foo();\n+    x[i]=0;\n+}"}]}