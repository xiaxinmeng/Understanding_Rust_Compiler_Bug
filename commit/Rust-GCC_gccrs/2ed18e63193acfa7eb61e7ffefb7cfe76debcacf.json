{"sha": "2ed18e63193acfa7eb61e7ffefb7cfe76debcacf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVkMThlNjMxOTNhY2ZhN2ViNjFlN2ZmZWZiN2NmZTc2ZGViY2FjZg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-10-29T01:25:27Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-10-29T01:25:27Z"}, "message": "Updates from Bob.\n\nFrom-SVN: r13061", "tree": {"sha": "10099a17eb880ca79f27cc60680069299664d142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10099a17eb880ca79f27cc60680069299664d142"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ed18e63193acfa7eb61e7ffefb7cfe76debcacf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed18e63193acfa7eb61e7ffefb7cfe76debcacf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed18e63193acfa7eb61e7ffefb7cfe76debcacf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed18e63193acfa7eb61e7ffefb7cfe76debcacf/comments", "author": null, "committer": null, "parents": [{"sha": "3c377a2a6a981ef37ce06a5534d90034c40612f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c377a2a6a981ef37ce06a5534d90034c40612f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c377a2a6a981ef37ce06a5534d90034c40612f5"}], "stats": {"total": 249, "additions": 192, "deletions": 57}, "files": [{"sha": "af3f50c3519ccd5bf83f1ad8b6168f55f7153dde", "filename": "gcc/except.c", "status": "modified", "additions": 192, "deletions": 57, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed18e63193acfa7eb61e7ffefb7cfe76debcacf/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed18e63193acfa7eb61e7ffefb7cfe76debcacf/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=2ed18e63193acfa7eb61e7ffefb7cfe76debcacf", "patch": "@@ -55,10 +55,27 @@ Boston, MA 02111-1307, USA.  */\n    to any arbitrary depth. Also, exception regions cannot cross\n    function boundaries.\n \n-   Each object file that is compiled with exception handling contains a\n-   static array of exception handlers named __EXCEPTION_TABLE__. Each entry\n-   contains the starting and ending addresses of the exception region,\n-   and the address of the handler designated for that region.\n+   Exception handlers can either be specified by the user (which we\n+   will call a \"user-defined handler\") or generated by the compiler\n+   (which we will designate as a \"cleanup\"). Cleanups are used to\n+   perform tasks such as destruction of objects allocated on the\n+   stack.\n+\n+   In the current implementaion, cleanups are handled by allocating an\n+   exception region for the area that the cleanup is designated for,\n+   and the handler for the region performs the cleanup and then\n+   rethrows the exception to the outer exception region. From the\n+   standpoint of the current implementation, there is little\n+   distinction made between a cleanup and a user-defined handler, and\n+   the phrase \"exception handler\" can be used to refer to either one\n+   equally well. (The section \"Future Directions\" below discusses how\n+   this will change).\n+\n+   Each object file that is compiled with exception handling contains\n+   a static array of exception handlers named __EXCEPTION_TABLE__.\n+   Each entry contains the starting and ending addresses of the\n+   exception region, and the address of the handler designated for\n+   that region.\n \n    At program startup each object file invokes a function named\n    __register_exceptions with the address of its local\n@@ -69,87 +86,130 @@ Boston, MA 02111-1307, USA.  */\n    The function __throw () is actually responsible for doing the\n    throw. In the C++ frontend, __throw () is generated on a\n    per-object-file basis for each source file compiled with\n-   -fexceptions. \n+   -fexceptions. Before __throw () is invoked, the current context\n+   of the throw needs to be placed in the global variable __eh_pc.\n \n    __throw () attempts to find the appropriate exception handler for the \n    PC value stored in __eh_pc by calling __find_first_exception_table_match\n-   (which is defined in libgcc2.c). If an appropriate handler is\n-   found, __throw jumps directly to it.\n+   (which is defined in libgcc2.c). If __find_first_exception_table_match\n+   finds a relevant handler, __throw jumps directly to it.\n \n-   If a handler for the address being thrown from can't be found,\n+   If a handler for the context being thrown from can't be found,\n    __throw is responsible for unwinding the stack, determining the\n    address of the caller of the current function (which will be used\n-   as the new context to throw from), and then searching for a handler\n-   for the new context. __throw may also call abort () if it is unable\n-   to unwind the stack, and can also call an external library function\n-   named __terminate if it reaches the top of the stack without\n-   finding an appropriate handler.\n-\n-   Note that some of the regions and handlers are implicitly\n-   generated. The handlers for these regions perform necessary\n-   cleanups (in C++ these cleanups are responsible for invoking\n-   necessary object destructors) before rethrowing the exception to\n-   the outer exception region.\n+   as the new context to throw from), and then restarting the process\n+   of searching for a handler for the new context. __throw may also\n+   call abort () if it is unable to unwind the stack, and can also\n+   call an external library function named __terminate if it reaches\n+   the top of the stack without finding an appropriate handler. (By\n+   default __terminate () invokes abort (), but this behavior can be\n+   changed by the user to perform some sort of cleanup behavior before\n+   exiting).\n \n    Internal implementation details:\n \n-   The start of an exception region is indicated by calling\n-   expand_eh_region_start (). expand_eh_region_end (handler) is\n-   subsequently invoked to end the region and to associate a handler\n-   with the region. This is used to create a region that has an\n-   associated cleanup routine for performing tasks like object\n-   destruction.\n-\n    To associate a user-defined handler with a block of statements, the\n    function expand_start_try_stmts () is used to mark the start of the\n    block of statements with which the handler is to be associated\n-   (which is usually known as a \"try block\"). All statements that\n-   appear afterwards will be associated with the try block.\n-\n-   A call to expand_start_all_catch () will mark the end of the try\n-   block, and also marks the start of the \"catch block\" associated\n-   with the try block. This catch block will only be invoked if an\n-   exception is thrown through the try block. The instructions for the\n-   catch block are kept as a separate sequence, and will be emitted at\n-   the end of the function along with the handlers specified via\n-   expand_eh_region_end (). The end of the catch block is marked with\n-   expand_end_all_catch ().\n+   (which is known as a \"try block\"). All statements that appear\n+   afterwards will be associated with the try block.\n+\n+   A call to expand_start_all_catch () marks the end of the try block,\n+   and also marks the start of the \"catch block\" (the user-defined\n+   handler) associated with the try block.\n+\n+   This user-defined handler will be invoked for *every* exception\n+   thrown with the context of the try block. It is up to the handler\n+   to decide whether or not it wishes to handle any given exception,\n+   as there is currently no mechanism in this implementation for doing\n+   this. (There are plans for conditionally processing an exception\n+   based on its \"type\", which will provide a language-independent\n+   mechanism).\n+\n+   If the handler chooses not to process the exception (perhaps by\n+   looking at an \"exception type\" or some other additional data\n+   supplied with the exception), it can fall through to the end of the\n+   handler. expand_end_all_catch () and expand_leftover_cleanups ()\n+   add additional code to the end of each handler to take care of\n+   rethrowing to the outer exception handler.\n+\n+   The handler also has the option to continue with \"normal flow of\n+   code\", or in other words to resume executing at the statement\n+   immediately after the end of the exception region. The variable\n+   caught_return_label_stack contains a stack of labels, and jumping\n+   to the topmost entry's label via expand_goto () will resume normal\n+   flow to the statement immediately after the end of the exception\n+   region. If the handler falls through to the end, the exception will\n+   be rethrown to the outer exception region.\n+\n+   The instructions for the catch block are kept as a separate\n+   sequence, and will be emitted at the end of the function along with\n+   the handlers specified via expand_eh_region_end (). The end of the\n+   catch block is marked with expand_end_all_catch ().\n \n    Any data associated with the exception must currently be handled by\n    some external mechanism maintained in the frontend.  For example,\n    the C++ exception mechanism passes an arbitrary value along with\n    the exception, and this is handled in the C++ frontend by using a\n-   global variable to hold the value.\n-\n-   Internally-generated exception regions are marked by calling\n-   expand_eh_region_start () to mark the start of the region, and\n-   expand_eh_region_end () is used to both designate the end of the\n-   region and to associate a handler/cleanup with the region. These\n-   functions generate the appropriate RTL sequences to mark the start\n-   and end of the exception regions and ensure that an appropriate\n-   exception region entry will be added to the exception region table.\n-   expand_eh_region_end () also queues the provided handler to be\n-   emitted at the end of the current function.\n+   global variable to hold the value. (This will be changing in the\n+   future.)\n+\n+   The mechanism in C++ for handling data associated with the\n+   exception is clearly not thread-safe. For a thread-based\n+   environment, another mechanism must be used (possibly using a\n+   per-thread allocation mechanism if the size of the area that needs\n+   to be allocated isn't known at compile time.)\n+\n+   Internally-generated exception regions (cleanups) are marked by\n+   calling expand_eh_region_start () to mark the start of the region,\n+   and expand_eh_region_end (handler) is used to both designate the\n+   end of the region and to associate a specified handler/cleanup with\n+   the region. The rtl code in HANDLER will be invoked whenever an\n+   exception occurs in the region between the calls to\n+   expand_eh_region_start and expand_eh_region_end. After HANDLER is\n+   executed, additional code is emitted to handle rethrowing the\n+   exception to the outer exception handler. The code for HANDLER will\n+   be emitted at the end of the function.\n \n    TARGET_EXPRs can also be used to designate exception regions. A\n    TARGET_EXPR gives an unwind-protect style interface commonly used\n    in functional languages such as LISP. The associated expression is\n-   evaluated, and if it (or any of the functions that it calls) throws\n-   an exception it is caught by the associated cleanup. The backend\n-   also takes care of the details of associating an exception table\n-   entry with the expression and generating the necessary code.\n+   evaluated, and whether or not it (or any of the functions that it\n+   calls) throws an exception, the protect expression is always\n+   invoked. This implementation takes care of the details of\n+   associating an exception table entry with the expression and\n+   generating the necessary code (it actually emits the protect\n+   expression twice, once for normal flow and once for the exception\n+   case). As for the other handlers, the code for the exception case\n+   will be emitted at the end of the function.\n+\n+   Cleanups can also be specified by using add_partial_entry (handler)\n+   and end_protect_partials (). add_partial_entry creates the start of\n+   a new exception region; HANDLER will be invoked if an exception is\n+   thrown with the context of the region between the calls to\n+   add_partial_entry and end_protect_partials. end_protect_partials is\n+   used to mark the end of these regions. add_partial_entry can be\n+   called as many times as needed before calling end_protect_partials.\n+   However, end_protect_partials should only be invoked once for each\n+   group of calls to add_partial_entry () as the entries are queued\n+   and all of the outstanding entries are processed simultaneously\n+   when end_protect_partials is invoked. Similarly to the other\n+   handlers, the code for HANDLER will be emitted at the end of the\n+   function.\n \n    The generated RTL for an exception region includes\n    NOTE_INSN_EH_REGION_BEG and NOTE_INSN_EH_REGION_END notes that mark\n    the start and end of the exception region. A unique label is also\n-   generated at the start of the exception region.\n+   generated at the start of the exception region, which is available\n+   by looking at the ehstack variable. The topmost entry corresponds\n+   to the current region.\n \n    In the current implementation, an exception can only be thrown from\n    a function call (since the mechanism used to actually throw an\n    exception involves calling __throw).  If an exception region is\n    created but no function calls occur within that region, the region\n-   can be safely optimized away since no exceptions can ever be caught\n-   in that region.\n+   can be safely optimized away (along with its exception handlers)\n+   since no exceptions can ever be caught in that region.\n \n    Unwinding the stack:\n \n@@ -165,7 +225,15 @@ Boston, MA 02111-1307, USA.  */\n    definition for __unwind_function (), inlined unwinders will be used\n    instead. The main tradeoff here is in text space utilization.\n    Obviously, if inline unwinders have to be generated repeatedly,\n-   this uses more space than if a single routine is used.\n+   this uses much more space than if a single routine is used.\n+\n+   However, it is simply not possible on some platforms to write a\n+   generalized routine for doing stack unwinding without having some\n+   form of additional data associated with each function. The current\n+   implementation encodes this data in the form of additional machine\n+   instructions. This is clearly not desirable, as it is extremely\n+   inefficient. The next implementation will provide a set of metadata\n+   for each function that will provide the needed information.\n \n    The backend macro DOESNT_NEED_UNWINDER is used to conditionalize\n    whether or not per-function unwinders are needed. If DOESNT_NEED_UNWINDER\n@@ -175,7 +243,74 @@ Boston, MA 02111-1307, USA.  */\n    On some platforms it is possible that neither __unwind_function ()\n    nor inlined unwinders are available. For these platforms it is not\n    possible to throw through a function call, and abort () will be\n-   invoked instead of performing the throw. */\n+   invoked instead of performing the throw. \n+\n+   Future directions:\n+\n+   Currently __throw () makes no differentiation between cleanups and\n+   user-defined exception regions. While this makes the implementation\n+   simple, it also implies that it is impossible to determine if a\n+   user-defined exception handler exists for a given exception without\n+   completely unwinding the stack in the process. This is undesirable\n+   from the standpoint of debugging, as ideally it would be possible\n+   to trap unhandled exceptions in the debugger before the process of\n+   unwinding has even started.\n+\n+   This problem can be solved by marking user-defined handlers in a\n+   special way (probably by adding additional bits to exception_table_list).\n+   A two-pass scheme could then be used by __throw () to iterate\n+   through the table. The first pass would search for a relevant\n+   user-defined handler for the current context of the throw, and if\n+   one is found, the second pass would then invoke all needed cleanups\n+   before jumping to the user-defined handler.\n+\n+   Many languages (including C++ and Ada) make execution of a\n+   user-defined handler conditional on the \"type\" of the exception\n+   thrown. (The type of the exception is actually the type of the data\n+   that is thrown with the exception.) It will thus be necessary for\n+   __throw () to be able to determine if a given user-defined\n+   exception handler will actually be executed, given the type of\n+   exception.\n+\n+   One scheme is to add additional information to exception_table_list\n+   as to the types of exceptions accepted by each handler. __throw ()\n+   can do the type comparisons and then determine if the handler is\n+   actually going to be executed.\n+\n+   There is currently no significant level of debugging support\n+   available, other than to place a breakpoint on __throw (). While\n+   this is sufficient in most cases, it would be helpful to be able to\n+   know where a given exception was going to be thrown to before it is\n+   actually thrown, and to be able to choose between stopping before\n+   every exception region (including cleanups), or just user-defined\n+   exception regions. This should be possible to do in the two-pass\n+   scheme by adding additional labels to __throw () for appropriate\n+   breakpoints, and additional debugger commands could be added to\n+   query various state variables to determine what actions are to be\n+   performed next.\n+\n+   Another major problem that is being worked on is the issue with\n+   stack unwinding on various platforms. Currently the only platform\n+   that has support for __unwind_function () is the Sparc; all other\n+   ports require per-function unwinders, which causes large amounts of\n+   code bloat.\n+\n+   Ideally it would be possible to store a small set of metadata with\n+   each function that would then make it possible to write a\n+   __unwind_function () for every platform. This would eliminate the\n+   need for per-function unwinders.\n+\n+   The main reason the data is needed is that on some platforms the\n+   order and types of data stored on the stack can vary depending on\n+   the type of function, its arguments and returned values, and the\n+   compilation options used (optimization versus non-optimization,\n+   -fomit-frame-pointer, processor variations, etc).\n+\n+   Unfortunately, this also means that throwing through functions that\n+   aren't compiled with exception handling support will still not be\n+   possible on some platforms. This problem is currently being\n+   investigated, but no solutions have been found that do not imply\n+   some unacceptable performance penalties.  */\n \n \n #include \"config.h\""}]}