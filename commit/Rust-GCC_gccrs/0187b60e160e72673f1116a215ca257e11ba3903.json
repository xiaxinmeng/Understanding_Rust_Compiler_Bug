{"sha": "0187b60e160e72673f1116a215ca257e11ba3903", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE4N2I2MGUxNjBlNzI2NzNmMTExNmEyMTVjYTI1N2UxMWJhMzkwMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T10:50:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T10:50:14Z"}, "message": "[multiple changes]\n\n2011-08-03  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch6.adb (Find_Corresponding_Spec): When in an instance, skip\n\tconforming subprogram renamings that appear to be completions if they\n\tare not fully conformant.\n\tSuch renamings are homographs but not completions.\n\t* sem_type.adb (Disambiguate): Handle disambiguation of overloaded\n\tnames in a subprogram renaming that appears in an instance.\n\n2011-08-03  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.adb (Expand_Subtype_From_Expr): if the type is limited but\n\tnot immutably limited, build actual subtype from expression to provide\n\tproper bounds to caller.\n\n2011-08-03  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch8.adb: Minor comment correction.\n\n2011-08-03  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_strm.adb (Build_Array_Input_Function): In Ada 2005 mode, when\n\treturning a limited array, use an extended return statement.\n\n2011-08-03  Vincent Celier  <celier@adacore.com>\n\n\t* make.adb (Initialize): If --subdirs= is used, but no project file is\n\tspecified, attempt to create the specify subdir if it does not already\n\texist and use it as the object directory as if -D had been specified.\n\n2011-08-03  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-tpopsp-vms.adb: New file.\n\t* s-taprop-vms.adb: Put back ATCB_Key, since needed by this file on VMS.\n\t* gcc-interfaces/Makefile.in: Use s-taprop-vms.adb on VMS.\n\nFrom-SVN: r177266", "tree": {"sha": "f59ec3e7f6d6ce26c1e709b66654bfafc93b35d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f59ec3e7f6d6ce26c1e709b66654bfafc93b35d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0187b60e160e72673f1116a215ca257e11ba3903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0187b60e160e72673f1116a215ca257e11ba3903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0187b60e160e72673f1116a215ca257e11ba3903", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0187b60e160e72673f1116a215ca257e11ba3903/comments", "author": null, "committer": null, "parents": [{"sha": "e0b23d9fd37bfef08ad71836438ba88446ecb5b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0b23d9fd37bfef08ad71836438ba88446ecb5b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0b23d9fd37bfef08ad71836438ba88446ecb5b7"}], "stats": {"total": 280, "additions": 257, "deletions": 23}, "files": [{"sha": "43e546c96ba11b2ac341b51b29d9b05c2b2a6a08", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0187b60e160e72673f1116a215ca257e11ba3903", "patch": "@@ -1,3 +1,39 @@\n+2011-08-03  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_ch6.adb (Find_Corresponding_Spec): When in an instance, skip\n+\tconforming subprogram renamings that appear to be completions if they\n+\tare not fully conformant.\n+\tSuch renamings are homographs but not completions.\n+\t* sem_type.adb (Disambiguate): Handle disambiguation of overloaded\n+\tnames in a subprogram renaming that appears in an instance.\n+\n+2011-08-03  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_util.adb (Expand_Subtype_From_Expr): if the type is limited but\n+\tnot immutably limited, build actual subtype from expression to provide\n+\tproper bounds to caller.\n+\n+2011-08-03  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_ch8.adb: Minor comment correction.\n+\n+2011-08-03  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_strm.adb (Build_Array_Input_Function): In Ada 2005 mode, when\n+\treturning a limited array, use an extended return statement.\n+\n+2011-08-03  Vincent Celier  <celier@adacore.com>\n+\n+\t* make.adb (Initialize): If --subdirs= is used, but no project file is\n+\tspecified, attempt to create the specify subdir if it does not already\n+\texist and use it as the object directory as if -D had been specified.\n+\n+2011-08-03  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-tpopsp-vms.adb: New file.\n+\t* s-taprop-vms.adb: Put back ATCB_Key, since needed by this file on VMS.\n+\t* gcc-interfaces/Makefile.in: Use s-taprop-vms.adb on VMS.\n+\n 2011-08-03  Emmanuel Briot  <briot@adacore.com>\n \n \t* make.adb, makeutl.adb, makeutl.ads, clean.adb (Makeutl.Queue): new"}, {"sha": "b89e088b2f66e183ba6d4ad886c005458b60e876", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=0187b60e160e72673f1116a215ca257e11ba3903", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -149,7 +149,9 @@ package body Exp_Strm is\n       Decls  : List_Id;\n       Ranges : List_Id;\n       Stms   : List_Id;\n+      Rstmt  : Node_Id;\n       Indx   : Node_Id;\n+      Odecl  : Node_Id;\n \n    begin\n       Decls := New_List;\n@@ -197,13 +199,13 @@ package body Exp_Strm is\n       --  build a subtype indication with the proper bounds.\n \n       if Is_Constrained (Stream_Base_Type (Typ)) then\n-         Append_To (Decls,\n+         Odecl :=\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Make_Defining_Identifier (Loc, Name_V),\n              Object_Definition =>\n-               New_Occurrence_Of (Stream_Base_Type (Typ), Loc)));\n+               New_Occurrence_Of (Stream_Base_Type (Typ), Loc));\n       else\n-         Append_To (Decls,\n+         Odecl :=\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Make_Defining_Identifier (Loc, Name_V),\n              Object_Definition =>\n@@ -212,19 +214,34 @@ package body Exp_Strm is\n                    New_Occurrence_Of (Stream_Base_Type (Typ), Loc),\n                  Constraint =>\n                    Make_Index_Or_Discriminant_Constraint (Loc,\n-                     Constraints => Ranges))));\n+                     Constraints => Ranges)));\n       end if;\n \n-      Stms := New_List (\n-         Make_Attribute_Reference (Loc,\n-           Prefix => New_Occurrence_Of (Typ, Loc),\n-           Attribute_Name => Name_Read,\n-           Expressions => New_List (\n-             Make_Identifier (Loc, Name_S),\n-             Make_Identifier (Loc, Name_V))),\n+      Rstmt := Make_Attribute_Reference (Loc,\n+                 Prefix         => New_Occurrence_Of (Typ, Loc),\n+                 Attribute_Name => Name_Read,\n+                 Expressions    => New_List (\n+                   Make_Identifier (Loc, Name_S),\n+                   Make_Identifier (Loc, Name_V)));\n \n-         Make_Simple_Return_Statement (Loc,\n-           Expression => Make_Identifier (Loc, Name_V)));\n+      if Ada_Version >= Ada_2005 then\n+         Stms := New_List (\n+            Make_Extended_Return_Statement (Loc,\n+              Return_Object_Declarations => New_List (Odecl),\n+              Handled_Statement_Sequence =>\n+                Make_Handled_Sequence_Of_Statements (Loc,\n+                  New_List (Rstmt))));\n+      else\n+         --  pragma Assert (not Is_Limited_Type (Typ));\n+         --  Returning a local object, shouldn't happen in the case of a\n+         --  limited type, but currently occurs in DSA stubs in Ada 95 mode???\n+\n+         Stms := New_List (\n+                   Odecl,\n+                   Rstmt,\n+                   Make_Simple_Return_Statement (Loc,\n+                     Expression => Make_Identifier (Loc, Name_V)));\n+      end if;\n \n       Fnam :=\n         Make_Defining_Identifier (Loc,"}, {"sha": "7557a125a2ab47084516d0cfbb857dc1838be4b6", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=0187b60e160e72673f1116a215ca257e11ba3903", "patch": "@@ -1371,8 +1371,11 @@ package body Exp_Util is\n \n       --  If the type is class-wide, the expression is dynamically tagged and\n       --  we do not create an actual subtype either. Ditto for an interface.\n+      --  For now this applies only if the type is immutably limited, and the\n+      --  function being called is build-in-place. This will have to be revised\n+      --  when build-in-place functions are generalized to other types.\n \n-      elsif Is_Limited_Type (Exp_Typ)\n+      elsif Is_Immutably_Limited_Type (Exp_Typ)\n         and then\n          (Is_Class_Wide_Type (Exp_Typ)\n            or else Is_Interface (Exp_Typ)"}, {"sha": "386c05fb740f0b401358ec36e2b98135acb798ab", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=0187b60e160e72673f1116a215ca257e11ba3903", "patch": "@@ -1520,7 +1520,7 @@ ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(targ)))\n     s-taprop.adb<s-taprop-vms.adb \\\n     s-tasdeb.adb<s-tasdeb-vms.adb \\\n     s-taspri.ads<s-taspri-vms.ads \\\n-    s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+    s-tpopsp.adb<s-tpopsp-vms.adb \\\n     s-tpopde.adb<s-tpopde-vms.adb \\\n     s-tpopde.ads<s-tpopde-vms.ads\n "}, {"sha": "0eca00878efc2191232ed8e7393cf49998125df4", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=0187b60e160e72673f1116a215ca257e11ba3903", "patch": "@@ -61,17 +61,18 @@ pragma Warnings (On);\n \n with Switch;   use Switch;\n with Switch.M; use Switch.M;\n-with Targparm; use Targparm;\n with Table;\n+with Targparm; use Targparm;\n with Tempdir;\n with Types;    use Types;\n \n-with Ada.Exceptions;            use Ada.Exceptions;\n with Ada.Command_Line;          use Ada.Command_Line;\n+with Ada.Directories;\n+with Ada.Exceptions;            use Ada.Exceptions;\n \n+with GNAT.Case_Util;            use GNAT.Case_Util;\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.Dynamic_HTables;      use GNAT.Dynamic_HTables;\n-with GNAT.Case_Util;            use GNAT.Case_Util;\n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n package body Make is\n@@ -5898,6 +5899,10 @@ package body Make is\n \n                   Prj.Env.Set_Ada_Paths\n                     (Main_Project, Project_Tree, Use_Include_Path_File);\n+                  --  (Project => Main_Project,\n+                  --   In_Tree => Project_Tree,\n+                  --   Including_Libraries => True,\n+                  --   Include_Path => Use_Include_Path_File);\n \n                   --  If switch -C was specified, create a binder mapping file\n \n@@ -6729,6 +6734,38 @@ package body Make is\n          Make_Failed (\"-i and -D cannot be used simultaneously\");\n       end if;\n \n+      --  If --subdirs= is specified, but not -P, this is equivalent to -D,\n+      --  except that the directory is created if it does not exist.\n+\n+      if Prj.Subdirs /= null and then Project_File_Name = null then\n+         if Object_Directory_Path /= null then\n+            Make_Failed (\"--subdirs and -D cannot be used simultaneously\");\n+\n+         elsif In_Place_Mode then\n+            Make_Failed (\"--subdirs and -i cannot be used simultaneously\");\n+\n+         else\n+            if not Is_Directory (Prj.Subdirs.all) then\n+               begin\n+                  Ada.Directories.Create_Path (Prj.Subdirs.all);\n+               exception\n+                  when others =>\n+                     Make_Failed (\"unable to create object directory \" &\n+                                  Prj.Subdirs.all);\n+               end;\n+            end if;\n+\n+            Object_Directory_Present := True;\n+\n+            declare\n+               Argv : constant String (1 .. Prj.Subdirs'Length) :=\n+                        Prj.Subdirs.all;\n+            begin\n+               Scan_Make_Arg (Env, Argv, And_Save => False);\n+            end;\n+         end if;\n+      end if;\n+\n       --  Deal with -C= switch\n \n       if Gnatmake_Mapping_File /= null then"}, {"sha": "bd19c474eaa2c413a3365c480c6a5c86e6263c80", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=0187b60e160e72673f1116a215ca257e11ba3903", "patch": "@@ -72,6 +72,9 @@ package body System.Task_Primitives.Operations is\n    --  a time; it is used to execute in mutual exclusion from all other tasks.\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n+   ATCB_Key : aliased pthread_key_t;\n+   --  Key used to find the Ada Task_Id associated with a thread\n+\n    Environment_Task_Id : Task_Id;\n    --  A variable to hold Task_Id for the environment task\n "}, {"sha": "42503f6cd99a3b77529f450ef0bc41cee26b6c83", "filename": "gcc/ada/s-tpopsp-vms.adb", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fs-tpopsp-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fs-tpopsp-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopsp-vms.adb?ref=0187b60e160e72673f1116a215ca257e11ba3903", "patch": "@@ -0,0 +1,103 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--                SYSTEM.TASK_PRIMITIVES.OPERATIONS.SPECIFIC                --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--         Copyright (C) 1992-2011, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a VMS version of this package where foreign threads are\n+--  recognized.\n+\n+separate (System.Task_Primitives.Operations)\n+package body Specific is\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Environment_Task : Task_Id) is\n+      pragma Warnings (Off, Environment_Task);\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_key_create (ATCB_Key'Access, null);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+   -------------------\n+   -- Is_Valid_Task --\n+   -------------------\n+\n+   function Is_Valid_Task return Boolean is\n+   begin\n+      return pthread_getspecific (ATCB_Key) /= System.Null_Address;\n+   end Is_Valid_Task;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   procedure Set (Self_Id : Task_Id) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_setspecific (ATCB_Key, To_Address (Self_Id));\n+      pragma Assert (Result = 0);\n+   end Set;\n+\n+   ----------\n+   -- Self --\n+   ----------\n+\n+   --  To make Ada tasks and C threads interoperate better, we have added some\n+   --  functionality to Self. Suppose a C main program (with threads) calls an\n+   --  Ada procedure and the Ada procedure calls the tasking runtime system.\n+   --  Eventually, a call will be made to self. Since the call is not coming\n+   --  from an Ada task, there will be no corresponding ATCB.\n+\n+   --  What we do in Self is to catch references that do not come from\n+   --  recognized Ada tasks, and create an ATCB for the calling thread.\n+\n+   --  The new ATCB will be \"detached\" from the normal Ada task master\n+   --  hierarchy, much like the existing implicitly created signal-server\n+   --  tasks.\n+\n+   function Self return Task_Id is\n+      Result : System.Address;\n+\n+   begin\n+      Result := pthread_getspecific (ATCB_Key);\n+\n+      --  If the key value is Null then it is a non-Ada task\n+\n+      if Result /= System.Null_Address then\n+         return To_Task_Id (Result);\n+      else\n+         return Register_Foreign_Thread;\n+      end if;\n+   end Self;\n+\n+end Specific;"}, {"sha": "6c69643cbddbe6f7c22e03a4e5a7f51dd729c2d0", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0187b60e160e72673f1116a215ca257e11ba3903", "patch": "@@ -6332,7 +6332,13 @@ package body Sem_Ch6 is\n                if In_Instance then\n                   Set_Convention (Designator, Convention (E));\n \n-                  if Nkind (N) = N_Subprogram_Body\n+                  --  Skip past subprogram bodies and subprogram renamings that\n+                  --  may appear to have a matching spec, but that aren't fully\n+                  --  conformant with it. That can occur in cases where an\n+                  --  actual type causes unrelated homographs in the instance.\n+\n+                  if Nkind_In (N, N_Subprogram_Body,\n+                                  N_Subprogram_Renaming_Declaration)\n                     and then Present (Homonym (E))\n                     and then not Fully_Conformant (Designator, E)\n                   then"}, {"sha": "19581b99ba1ea99a6828ff38e9133b634fcdc7c0", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=0187b60e160e72673f1116a215ca257e11ba3903", "patch": "@@ -5461,7 +5461,7 @@ package body Sem_Ch8 is\n          return Old_S;\n       end Report_Overload;\n \n-   --  Start of processing for Find_Renamed_Entry\n+   --  Start of processing for Find_Renamed_Entity\n \n    begin\n       Old_S := Any_Id;"}, {"sha": "e5b8b3587608e2de625989bad5872e6ff1c4c6ea", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0187b60e160e72673f1116a215ca257e11ba3903/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=0187b60e160e72673f1116a215ca257e11ba3903", "patch": "@@ -1751,15 +1751,26 @@ package body Sem_Type is\n          --  case the resolution was to the explicit declaration in the\n          --  generic, and remains so in the instance.\n \n+         --  The same sort of disambiguation needed for calls is also required\n+         --  for the name given in a subprogram renaming, and that case is\n+         --  handled here as well. We test Comes_From_Source to exclude this\n+         --  treatment for implicit renamings created for formal subprograms.\n+\n          elsif In_Instance\n            and then not In_Generic_Actual (N)\n          then\n             if Nkind (N) = N_Function_Call\n               or else Nkind (N) = N_Procedure_Call_Statement\n+              or else\n+                (Nkind (N) in N_Has_Entity\n+                  and then\n+                    Nkind (Parent (N)) = N_Subprogram_Renaming_Declaration\n+                  and then Comes_From_Source (Parent (N)))\n             then\n                declare\n                   Actual  : Node_Id;\n                   Formal  : Entity_Id;\n+                  Renam   : Entity_Id        := Empty;\n                   Is_Act1 : constant Boolean := Is_Actual_Subprogram (Nam1);\n                   Is_Act2 : constant Boolean := Is_Actual_Subprogram (Nam2);\n \n@@ -1781,14 +1792,32 @@ package body Sem_Type is\n                      return It1;\n                   end if;\n \n-                  Actual := First_Actual (N);\n+                  --  In the case of a renamed subprogram, pick up the entity\n+                  --  of the renaming declaration so we can traverse its\n+                  --  formal parameters.\n+\n+                  if Nkind (N) in N_Has_Entity then\n+                     Renam := Defining_Unit_Name (Specification (Parent (N)));\n+                  end if;\n+\n+                  if Present (Renam) then\n+                     Actual := First_Formal (Renam);\n+                  else\n+                     Actual := First_Actual (N);\n+                  end if;\n+\n                   Formal := First_Formal (Nam1);\n                   while Present (Actual) loop\n                      if Etype (Actual) /= Etype (Formal) then\n                         return It2;\n                      end if;\n \n-                     Next_Actual (Actual);\n+                     if Present (Renam) then\n+                        Next_Formal (Actual);\n+                     else\n+                        Next_Actual (Actual);\n+                     end if;\n+\n                      Next_Formal (Formal);\n                   end loop;\n "}]}