{"sha": "6e755043ddb0a6055edff6654b14585ca4b02218", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU3NTUwNDNkZGIwYTYwNTVlZGZmNjY1NGIxNDU4NWNhNGIwMjIxOA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-08-12T16:27:05Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-08-12T16:27:05Z"}, "message": "mn10300.c, [...]: Remove \"global zero register\" optimizations.\n\n        * mn10300.c, mn10300.h, mn10300.md: Remove \"global zero register\"\n        optimizations.\n\nFrom-SVN: r21686", "tree": {"sha": "4ccef94677302b5184581684ff4fc03095ed2928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ccef94677302b5184581684ff4fc03095ed2928"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e755043ddb0a6055edff6654b14585ca4b02218", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e755043ddb0a6055edff6654b14585ca4b02218", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e755043ddb0a6055edff6654b14585ca4b02218", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e755043ddb0a6055edff6654b14585ca4b02218/comments", "author": null, "committer": null, "parents": [{"sha": "49e0438549375d706a61eb78f8375ce4877e78cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e0438549375d706a61eb78f8375ce4877e78cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49e0438549375d706a61eb78f8375ce4877e78cc"}], "stats": {"total": 319, "additions": 14, "deletions": 305}, "files": [{"sha": "726102a481ee487764cd9af07e4859fecdaad14c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e755043ddb0a6055edff6654b14585ca4b02218/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e755043ddb0a6055edff6654b14585ca4b02218/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e755043ddb0a6055edff6654b14585ca4b02218", "patch": "@@ -1,3 +1,8 @@\n+Wed Aug 12 17:25:18 1998  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* mn10300.c, mn10300.h, mn10300.md: Remove \"global zero register\"\n+\toptimizations.\n+\n Wed Aug 12 12:39:16 1998  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* mips/mips.h (ENCODE_SECTION_INFO): Set SYMBOL_REF_FLAG for"}, {"sha": "d1f71ef303ff1f0b2a6e4598e8a78a4143ff80c4", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e755043ddb0a6055edff6654b14585ca4b02218/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e755043ddb0a6055edff6654b14585ca4b02218/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=6e755043ddb0a6055edff6654b14585ca4b02218", "patch": "@@ -41,26 +41,6 @@ Boston, MA 02111-1307, USA.  */\n    speed standpoint, so we want to optimize this sooner or later.  */\n #define REG_SAVE_BYTES (16)\n \n-/* Global registers known to hold the value zero.\n-\n-   Normally we'd depend on CSE and combine to put zero into a\n-   register and re-use it.\n-\n-   However, on the mn10x00 processors we implicitly use the constant\n-   zero in tst instructions, so we might be able to do better by\n-   loading the value into a register in the prologue, then re-useing\n-   that register throughout the function.\n-\n-   We could perform similar optimizations for other constants, but with\n-   gcse due soon, it doesn't seem worth the effort.\n-\n-   These variables hold a rtx for a register known to hold the value\n-   zero throughout the entire function, or NULL if no register of\n-   the appropriate class has such a value throughout the life of the\n-   function.  */\n-rtx zero_dreg;\n-rtx zero_areg;\n-\n void\n asm_file_start (file)\n      FILE *file;\n@@ -379,128 +359,11 @@ can_use_return_insn ()\n \t  && !frame_pointer_needed);\n }\n \n-/* Count the number of tst insns which compare a data or address\n-   register with zero.  */\n-static void \n-count_tst_insns (dreg_countp, areg_countp, oreg_countp)\n-     int *dreg_countp;\n-     int *areg_countp;\n-     int *oreg_countp;\n-{\n-  rtx insn;\n-\n-  /* Assume no tst insns exist.  */\n-  *dreg_countp = 0;\n-  *areg_countp = 0;\n-  *oreg_countp = 0;\n-\n-  /* If not optimizing, then quit now.  */\n-  if (!optimize)\n-    return;\n-\n-  /* Walk through all the insns.  */\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      rtx pat;\n-\n-      /* Ignore anything that is not a normal INSN.  */\n-      if (GET_CODE (insn) != INSN)\n-\tcontinue;\n-\n-      /* Ignore anything that isn't a SET.  */\n-      pat = PATTERN (insn);\n-      if (GET_CODE (pat) != SET)\n-\tcontinue;\n-\n-      /* Check for a tst insn.  */\n-      if (SET_DEST (pat) == cc0_rtx\n-\t  && GET_CODE (SET_SRC (pat)) == REG)\n-\t{\n-\t  if (REGNO_REG_CLASS (REGNO (SET_SRC (pat))) == DATA_REGS)\n-\t    (*dreg_countp)++;\n-    \n-\t  if (REGNO_REG_CLASS (REGNO (SET_SRC (pat))) == ADDRESS_REGS)\n-\t    (*areg_countp)++;\n-\t}\n-\n-      /* Setting an address register to zero can also be optimized,\n-\t so count it just like a tst insn.  */\n-      if (GET_CODE (SET_DEST (pat)) == REG\n-\t  && SET_SRC (pat) == CONST0_RTX (GET_MODE (SET_DEST (pat)))\n-\t  && REGNO_REG_CLASS (REGNO (SET_DEST (pat))) == ADDRESS_REGS)\n-\t(*areg_countp)++;\n-    }\n-}\n-\n void\n expand_prologue ()\n {\n   unsigned int size;\n \n-  /* We need to end the current sequence so that count_tst_insns can\n-     look at all the insns in this function.  Normally this would be\n-     unsafe, but it's OK in the prologue/epilogue expanders.  */\n-  end_sequence ();\n-\n-  /* Determine if it is profitable to put the value zero into a register\n-     for the entire function.  If so, set ZERO_DREG and ZERO_AREG.  */\n-  if (regs_ever_live[2] || regs_ever_live[3]\n-      || regs_ever_live[6] || regs_ever_live[7]\n-      || frame_pointer_needed)\n-    {\n-      int dreg_count, areg_count, oreg_count;\n-\n-      /* Get a count of the number of tst insns which use address and\n-\t data registers.  */\n-      count_tst_insns (&dreg_count, &areg_count, &oreg_count);\n-\n-      /* If there's more than one tst insn using a data register, then\n-\t this optimization is a win.  */\n-      if ((dreg_count > 1 || oreg_count > 1)\n-\t   && (!regs_ever_live[2] || !regs_ever_live[3]))\n-\t{\n- \t  if (!regs_ever_live[2])\n-\t    {\n-\t      regs_ever_live[2] = 1;\n-\t      zero_dreg = gen_rtx (REG, SImode, 2);\n-\t    }\n-\t  else\n-\t    {\n-\t      regs_ever_live[3] = 1;\n-\t      zero_dreg = gen_rtx (REG, SImode, 3);\n-\t    }\n-\t}\n-      else\n-\tzero_dreg = NULL_RTX;\n-\n-      /* If there's more than two tst insns using an address register,\n-\t then this optimization is a win.  */\n-      if ((areg_count > 2 || oreg_count > 1)\n-\t   && (!regs_ever_live[6] || !regs_ever_live[7]))\n-\t{\n- \t  if (!regs_ever_live[6])\n-\t    {\n-\t      regs_ever_live[6] = 1;\n-\t      zero_areg = gen_rtx (REG, SImode, 6);\n-\t    }\n-\t  else\n-\t    {\n-\t      regs_ever_live[7] = 1;\n-\t      zero_areg = gen_rtx (REG, SImode, 7);\n-\t    }\n-\t}\n-      else\n-\tzero_areg = NULL_RTX;\n-    }\n-  else\n-    {\n-      zero_dreg = NULL_RTX;\n-      zero_areg = NULL_RTX;\n-    }\n-\n-  /* Start a new sequence.  */\n-  start_sequence ();\n-\n   /* SIZE includes the fixed stack space needed for function calls.  */\n   size = get_frame_size () + current_function_outgoing_args_size;\n   size += (current_function_outgoing_args_size ? 4 : 0);\n@@ -535,13 +398,6 @@ expand_prologue ()\n     emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t   stack_pointer_rtx,\n \t\t\t   GEN_INT (-size)));\n-\n-  /* Load zeros into registers as needed.  */\n-  if (zero_dreg)\n-    emit_move_insn (zero_dreg, const0_rtx);\n-\n-  if (zero_areg)\n-    emit_move_insn (zero_areg, const0_rtx);\n }\n \n void\n@@ -898,29 +754,6 @@ output_tst (operand, insn)\n   rtx temp;\n   int past_call = 0;\n \n-  /* If we have a data register which is known to be zero throughout\n-     the function, then use it instead of doing a search.  */\n-  if (zero_dreg && REGNO_REG_CLASS (REGNO (operand)) == DATA_REGS)\n-    {\n-      rtx xoperands[2];\n-      xoperands[0] = operand;\n-      xoperands[1] = zero_dreg;\n-\n-      output_asm_insn (\"cmp %1,%0\", xoperands);\n-      return \"\";\n-    }\n-\n-  /* Similarly for address registers.  */\n-  if (zero_areg && REGNO_REG_CLASS (REGNO (operand)) == ADDRESS_REGS)\n-    {\n-      rtx xoperands[2];\n-      xoperands[0] = operand;\n-      xoperands[1] = zero_areg;\n-\n-      output_asm_insn (\"cmp %1,%0\", xoperands);\n-      return \"\";\n-    }\n-\n   /* We can save a byte if we can find a register which has the value\n      zero in it.  */\n   temp = PREV_INSN (insn);"}, {"sha": "ef57aaca9e6e1f4ad1c7b9aea93e4172521b7640", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e755043ddb0a6055edff6654b14585ca4b02218/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e755043ddb0a6055edff6654b14585ca4b02218/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=6e755043ddb0a6055edff6654b14585ca4b02218", "patch": "@@ -36,10 +36,6 @@ Boston, MA 02111-1307, USA.  */\n \n extern int target_flags;\n \n-/* Global registers known to hold the value zero.  */\n-extern struct rtx_def *zero_dreg;\n-extern struct rtx_def *zero_areg;\n-\n /* Macros used in the machine description to test the flags.  */\n \n /* Macro to define tables used to set the flags."}, {"sha": "8a652ebd97071e84470d6f52ba79de2d99efe5d6", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 9, "deletions": 134, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e755043ddb0a6055edff6654b14585ca4b02218/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e755043ddb0a6055edff6654b14585ca4b02218/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=6e755043ddb0a6055edff6654b14585ca4b02218", "patch": "@@ -71,20 +71,6 @@\n     case 2:\n       return \\\"clr %0\\\";\n     case 3:\n-      if (zero_areg)\n-\t{\n-\t  rtx xoperands[2];\n-\n-\t  xoperands[0] = operands[0];\n-\t  xoperands[1] = zero_areg;\n-\t  if (rtx_equal_p (xoperands[0], xoperands[1]))\n-\t    output_asm_insn (\\\"sub %1,%0\\\", xoperands);\n-\t  else\n-\t    output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n-\t  return \\\"\\\";\n-\t}\n-\n-      /* FALLTHROUGH */\n     case 4:\n     case 5:\n     case 6:\n@@ -135,20 +121,6 @@\n     case 2:\n       return \\\"clr %0\\\";\n     case 3:\n-      if (zero_areg)\n-\t{\n-\t  rtx xoperands[2];\n-\n-\t  xoperands[0] = operands[0];\n-\t  xoperands[1] = zero_areg;\n-\t  if (rtx_equal_p (xoperands[0], xoperands[1]))\n-\t    output_asm_insn (\\\"sub %1,%0\\\", xoperands);\n-\t  else\n-\t    output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n-\t  return \\\"\\\";\n-\t}\n-\n-      /* FALLTHROUGH */\n     case 4:\n     case 5:\n     case 6:\n@@ -238,20 +210,6 @@\n     case 2:\n       return \\\"clr %0\\\";\n     case 3:\n-      if (zero_areg)\n-\t{\n-\t  rtx xoperands[2];\n-\n-\t  xoperands[0] = operands[0];\n-\t  xoperands[1] = zero_areg;\n-\t  if (rtx_equal_p (xoperands[0], xoperands[1]))\n-\t    output_asm_insn (\\\"sub %1,%0\\\", xoperands);\n-\t  else\n-\t    output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n-\t  return \\\"\\\";\n-\t}\n-\n-      /* FALLTHROUGH */\n     case 4:\n     case 5:\n     case 6:\n@@ -302,20 +260,6 @@\n     case 2:\n       return \\\"clr %0\\\";\n     case 3:\n-      if (zero_areg)\n-\t{\n-\t  rtx xoperands[2];\n-\n-\t  xoperands[0] = operands[0];\n-\t  xoperands[1] = zero_areg;\n-\t  if (rtx_equal_p (xoperands[0], xoperands[1]))\n-\t    output_asm_insn (\\\"sub %1,%0\\\", xoperands);\n-\t  else\n-\t    output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n-\t  return \\\"\\\";\n-\t}\n-\n-      /* FALLTHROUGH */\n     case 4:\n     case 5:\n       return \\\"mov %1,%0\\\";\n@@ -357,17 +301,10 @@\n \treturn \\\"clr %L0\\;clr %H0\\\";\n \n       case 3:\n-\t  {\n-\t    rtx xoperands[2];\n-\n-\t    xoperands[0] = operands[0];\n-\t    xoperands[1] = zero_areg ? zero_areg : operands[1];\n-\t    if (rtx_equal_p (xoperands[0], xoperands[1]))\n-\t      output_asm_insn (\\\"sub %L1,%L0\\;mov %L0,%H0\\\", xoperands);\n-\t    else\n-\t      output_asm_insn (\\\"mov %1,%L0\\;mov %L0,%H0\\\", xoperands);\n-\t    return \\\"\\\";\n-\t  }\n+\tif (rtx_equal_p (operands[0], operands[1]))\n+\t  return \\\"sub %L1,%L0\\;mov %L0,%H0\\\";\n+\telse\n+\t  return \\\"mov %1,%L0\\;mov %L0,%H0\\\";\n       case 4:\n       case 5:\n       case 6:\n@@ -435,19 +372,6 @@\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"clr %L0\\\", operands);\n-\t        else if (zero_areg\n-\t\t\t && (REGNO_REG_CLASS (REGNO (operands[0]))\n-\t\t\t     == ADDRESS_REGS))\n-\t\t  {\n-\t\t    rtx xoperands[2];\n-\n-\t\t    xoperands[0] = operands[0];\n-\t\t    xoperands[1] = zero_areg;\n-\t\t    if (rtx_equal_p (xoperands[0], xoperands[1]))\n-\t\t      output_asm_insn (\\\"sub %L0,%L0\\\", xoperands);\n-\t\t    else\n-\t\t      output_asm_insn (\\\"mov %1,%L0\\\", xoperands);\n-\t\t  }\n \t\telse\n \t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \t      }\n@@ -460,19 +384,6 @@\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"clr %H0\\\", operands);\n-\t        else if (zero_areg\n-\t\t\t && (REGNO_REG_CLASS (REGNO (operands[0]))\n-\t\t\t     == ADDRESS_REGS))\n-\t\t  {\n-\t\t    rtx xoperands[2];\n-\n-\t\t    xoperands[0] = operands[0];\n-\t\t    xoperands[1] = zero_areg;\n-\t\t    if (rtx_equal_p (xoperands[0], xoperands[1]))\n-\t\t      output_asm_insn (\\\"sub %H0,%H0\\\", xoperands);\n-\t\t    else\n-\t\t      output_asm_insn (\\\"mov %1,%H0\\\", xoperands);\n-\t\t  }\n \t\telse\n \t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t      }\n@@ -522,17 +433,10 @@\n \treturn \\\"clr %L0\\;clr %H0\\\";\n \n       case 3:\n-\t  {\n-\t    rtx xoperands[2];\n-\n-\t    xoperands[0] = operands[0];\n-\t    xoperands[1] = zero_areg ? zero_areg : operands[1];\n-\t    if (rtx_equal_p (xoperands[0], xoperands[1]))\n-\t      output_asm_insn (\\\"sub %L1,%L0\\;mov %L0,%H0\\\", xoperands);\n-\t    else\n-\t      output_asm_insn (\\\"mov %1,%L0\\;mov %L0,%H0\\\", xoperands);\n-\t    return \\\"\\\";\n-\t  }\n+\t if (rtx_equal_p (operands[0], operands[1]))\n+\t   return \\\"sub %L1,%L0\\;mov %L0,%H0\\\";\n+\t else\n+\t   return \\\"mov %1,%L0\\;mov %L0,%H0\\\";\n       case 4:\n       case 5:\n       case 6:\n@@ -600,19 +504,6 @@\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"clr %L0\\\", operands);\n-\t        else if (zero_areg\n-\t\t\t && (REGNO_REG_CLASS (REGNO (operands[0]))\n-\t\t\t     == ADDRESS_REGS))\n-\t\t  {\n-\t\t    rtx xoperands[2];\n-\n-\t\t    xoperands[0] = operands[0];\n-\t\t    xoperands[1] = zero_areg;\n-\t\t    if (rtx_equal_p (xoperands[0], xoperands[1]))\n-\t\t      output_asm_insn (\\\"sub %L0,%L0\\\", xoperands);\n-\t\t    else\n-\t\t      output_asm_insn (\\\"mov %1,%L0\\\", xoperands);\n-\t\t  }\n \t\telse\n \t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \t      }\n@@ -625,19 +516,6 @@\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"clr %H0\\\", operands);\n-\t        else if (zero_areg\n-\t\t\t && (REGNO_REG_CLASS (REGNO (operands[0]))\n-\t\t\t     == ADDRESS_REGS))\n-\t\t  {\n-\t\t    rtx xoperands[2];\n-\n-\t\t    xoperands[0] = operands[0];\n-\t\t    xoperands[1] = zero_areg;\n-\t\t    if (rtx_equal_p (xoperands[0], xoperands[1]))\n-\t\t      output_asm_insn (\\\"sub %H0,%H0\\\", xoperands);\n-\t\t    else\n-\t\t      output_asm_insn (\\\"mov %1,%H0\\\", xoperands);\n-\t\t  }\n \t\telse\n \t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t      }\n@@ -821,10 +699,7 @@\n   \"\"\n   \"*\n {\n-  if (zero_dreg)\n-    output_asm_insn (\\\"mov %0,mdr\\\", &zero_dreg);\n-  else\n-    output_asm_insn (\\\"sub %3,%3\\;mov %3,mdr\\\", operands);\n+  output_asm_insn (\\\"sub %3,%3\\;mov %3,mdr\\\", operands);\n \n   if (find_reg_note (insn, REG_UNUSED, operands[3]))\n     return \\\"divu %2,%0\\\";"}]}