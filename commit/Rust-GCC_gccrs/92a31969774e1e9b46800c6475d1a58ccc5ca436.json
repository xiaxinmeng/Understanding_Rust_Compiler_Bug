{"sha": "92a31969774e1e9b46800c6475d1a58ccc5ca436", "node_id": "C_kwDOANBUbNoAKDkyYTMxOTY5Nzc0ZTFlOWI0NjgwMGM2NDc1ZDFhNThjY2M1Y2E0MzY", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-21T21:48:18Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-22T10:48:43Z"}, "message": "Support generic arguments on TypeBounds\n\nThis adds support to managing generic arguments within type bounds. Such\nas:\n\n```rust\nfn test<T: GenericBound<i32>>(a:T) { ... }\n```\n\nThe interesting piece here is that for any usage of the bounds on T the\nitems must be substituted with the inherited arguments specified within\nthe bound.\n\nThis fixes the test case from #743 by removing the lifetimes and where\nconstraint which needs to be implemented in #442. This associated test\ncase will fail the rust borrow checker but we need a way to work though\nbugs in the short term in some senario's.\n\nFixes #743", "tree": {"sha": "e7c9a6d82870937b5b0bc17a036cb00a93b35828", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7c9a6d82870937b5b0bc17a036cb00a93b35828"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92a31969774e1e9b46800c6475d1a58ccc5ca436", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a31969774e1e9b46800c6475d1a58ccc5ca436", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92a31969774e1e9b46800c6475d1a58ccc5ca436", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a31969774e1e9b46800c6475d1a58ccc5ca436/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3bd3f0dd8d145469598dcccc597ae69500369ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3bd3f0dd8d145469598dcccc597ae69500369ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3bd3f0dd8d145469598dcccc597ae69500369ae"}], "stats": {"total": 267, "additions": 247, "deletions": 20}, "files": [{"sha": "6e39fa3d35135210409329d5b0b840f51eb80780", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 59, "deletions": 18, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a31969774e1e9b46800c6475d1a58ccc5ca436/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a31969774e1e9b46800c6475d1a58ccc5ca436/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=92a31969774e1e9b46800c6475d1a58ccc5ca436", "patch": "@@ -130,28 +130,24 @@ class PathProbeType : public TypeCheckBase\n     if (!probe_bounds)\n       return probe.candidates;\n \n-    std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> probed_bounds\n-      = TypeBoundsProbe::Probe (receiver);\n-\n-    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n-      specified_bounds;\n-    for (const TyTy::TypeBoundPredicate &predicate :\n-\t receiver->get_specified_bounds ())\n+    if (!probe.is_reciever_generic ())\n       {\n-\tconst TraitReference *trait_item = predicate.get ();\n-\n-\t// FIXME lookup impl_block for this trait impl for this receiver\n-\tspecified_bounds.push_back ({trait_item, nullptr});\n+\tstd::vector<std::pair<TraitReference *, HIR::ImplBlock *>> probed_bounds\n+\t  = TypeBoundsProbe::Probe (receiver);\n+\tfor (auto &candidate : probed_bounds)\n+\t  {\n+\t    const TraitReference *trait_ref = candidate.first;\n+\t    HIR::ImplBlock *impl = candidate.second;\n+\t    probe.process_associated_trait_for_candidates (\n+\t      trait_ref, impl, ignore_mandatory_trait_items);\n+\t  }\n       }\n \n-    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n-      union_type_bounds = probe.union_bounds (probed_bounds, specified_bounds);\n-    for (auto &candidate : union_type_bounds)\n+    for (const TyTy::TypeBoundPredicate &predicate :\n+\t receiver->get_specified_bounds ())\n       {\n-\tconst TraitReference *trait_ref = candidate.first;\n-\tHIR::ImplBlock *impl = candidate.second;\n-\tprobe.process_associated_trait_for_candidates (\n-\t  trait_ref, impl, ignore_mandatory_trait_items);\n+\tprobe.process_predicate_for_candidates (predicate,\n+\t\t\t\t\t\tignore_mandatory_trait_items);\n       }\n \n     return probe.candidates;\n@@ -321,6 +317,51 @@ class PathProbeType : public TypeCheckBase\n     candidates.push_back (std::move (candidate));\n   }\n \n+  void\n+  process_predicate_for_candidates (const TyTy::TypeBoundPredicate &predicate,\n+\t\t\t\t    bool ignore_mandatory_trait_items)\n+  {\n+    const TraitReference *trait_ref = predicate.get ();\n+\n+    TyTy::TypeBoundPredicateItem item\n+      = predicate.lookup_associated_item (search.as_string ());\n+    if (item.is_error ())\n+      return;\n+\n+    if (ignore_mandatory_trait_items && item.needs_implementation ())\n+      return;\n+\n+    const TraitItemReference *trait_item_ref = item.get_raw_item ();\n+    PathProbeCandidate::CandidateType candidate_type;\n+    switch (trait_item_ref->get_trait_item_type ())\n+      {\n+      case TraitItemReference::TraitItemType::FN:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+\tbreak;\n+      case TraitItemReference::TraitItemType::CONST:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n+\tbreak;\n+      case TraitItemReference::TraitItemType::TYPE:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n+\tbreak;\n+\n+      case TraitItemReference::TraitItemType::ERROR:\n+      default:\n+\tgcc_unreachable ();\n+\tbreak;\n+      }\n+\n+    TyTy::BaseType *trait_item_tyty = item.get_tyty_for_receiver (receiver);\n+    PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n+\t\t\t\t\t\t\t\ttrait_item_ref,\n+\t\t\t\t\t\t\t\tnullptr};\n+    PathProbeCandidate candidate{candidate_type,\n+\t\t\t\t trait_item_tyty,\n+\t\t\t\t trait_item_ref->get_locus (),\n+\t\t\t\t {trait_item_candidate}};\n+    candidates.push_back (std::move (candidate));\n+  }\n+\n protected:\n   PathProbeType (const TyTy::BaseType *receiver,\n \t\t const HIR::PathIdentSegment &query)"}, {"sha": "91c49e0eb4c52aa8be23e23c54525176cdc89a05", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a31969774e1e9b46800c6475d1a58ccc5ca436/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a31969774e1e9b46800c6475d1a58ccc5ca436/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=92a31969774e1e9b46800c6475d1a58ccc5ca436", "patch": "@@ -234,10 +234,28 @@ class TypeResolveGenericParam : public TypeCheckBase\n \t\t  HIR::TraitBound *b\n \t\t    = static_cast<HIR::TraitBound *> (bound.get ());\n \n-\t\t  TraitReference *trait = resolve_trait_path (b->get_path ());\n+\t\t  auto &type_path = b->get_path ();\n+\t\t  TraitReference *trait = resolve_trait_path (type_path);\n \t\t  TyTy::TypeBoundPredicate predicate (\n \t\t    trait->get_mappings ().get_defid (), b->get_locus ());\n \n+\t\t  auto &final_seg = type_path.get_final_segment ();\n+\t\t  if (final_seg->is_generic_segment ())\n+\t\t    {\n+\t\t      auto final_generic_seg\n+\t\t\t= static_cast<HIR::TypePathSegmentGeneric *> (\n+\t\t\t  final_seg.get ());\n+\t\t      if (final_generic_seg->has_generic_args ())\n+\t\t\t{\n+\t\t\t  HIR::GenericArgs &generic_args\n+\t\t\t    = final_generic_seg->get_generic_args ();\n+\n+\t\t\t  // this is applying generic arguments to a trait\n+\t\t\t  // reference\n+\t\t\t  predicate.apply_generic_arguments (&generic_args);\n+\t\t\t}\n+\t\t    }\n+\n \t\t  specified_bounds.push_back (std::move (predicate));\n \t\t}\n \t\tbreak;"}, {"sha": "88c94d25111d328cc019d45f99ce3b1086548460", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a31969774e1e9b46800c6475d1a58ccc5ca436/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a31969774e1e9b46800c6475d1a58ccc5ca436/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=92a31969774e1e9b46800c6475d1a58ccc5ca436", "patch": "@@ -108,5 +108,84 @@ TypeBoundPredicate::is_object_safe (bool emit_error, Location locus) const\n   return trait->is_object_safe (emit_error, locus);\n }\n \n+void\n+TypeBoundPredicate::apply_generic_arguments (HIR::GenericArgs *generic_args)\n+{\n+  args = generic_args;\n+  // TODO verify these arguments are valid and not too many were added\n+}\n+\n+bool\n+TypeBoundPredicate::contains_item (const std::string &search) const\n+{\n+  auto trait_ref = get ();\n+  const Resolver::TraitItemReference *trait_item_ref = nullptr;\n+  return trait_ref->lookup_trait_item (search, &trait_item_ref);\n+}\n+\n+TypeBoundPredicateItem\n+TypeBoundPredicate::lookup_associated_item (const std::string &search) const\n+{\n+  auto trait_ref = get ();\n+  const Resolver::TraitItemReference *trait_item_ref = nullptr;\n+  if (!trait_ref->lookup_trait_item (search, &trait_item_ref))\n+    return TypeBoundPredicateItem::error ();\n+\n+  return TypeBoundPredicateItem (this, trait_item_ref);\n+}\n+\n+BaseType *\n+TypeBoundPredicateItem::get_tyty_for_receiver (const TyTy::BaseType *receiver)\n+{\n+  TyTy::BaseType *trait_item_tyty = get_raw_item ()->get_tyty ();\n+  if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n+      TyTy::SubstitutionParamMapping *param = nullptr;\n+      for (auto &param_mapping : fn->get_substs ())\n+\t{\n+\t  const HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n+\t  if (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t    {\n+\t      param = &param_mapping;\n+\t      break;\n+\t    }\n+\t}\n+      rust_assert (param != nullptr);\n+\n+      std::vector<TyTy::SubstitutionArg> mappings;\n+      mappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n+\n+      Location locus; // FIXME\n+      TyTy::SubstitutionArgumentMappings args (std::move (mappings), locus);\n+      trait_item_tyty\n+\t= Resolver::SubstMapperInternal::Resolve (trait_item_tyty, args);\n+    }\n+\n+  if (!parent->has_generic_args ())\n+    return trait_item_tyty;\n+\n+  // FIXME LEAK this should really be const\n+  const HIR::GenericArgs *args = parent->get_generic_args ();\n+  HIR::GenericArgs *generic_args = new HIR::GenericArgs (*args);\n+  TyTy::BaseType *resolved\n+    = Resolver::SubstMapper::Resolve (trait_item_tyty, parent->get_locus (),\n+\t\t\t\t      generic_args);\n+\n+  return resolved;\n+}\n+\n+const Resolver::TraitItemReference *\n+TypeBoundPredicateItem::get_raw_item () const\n+{\n+  return trait_item_ref;\n+}\n+\n+bool\n+TypeBoundPredicateItem::needs_implementation () const\n+{\n+  return !get_raw_item ()->is_optional ();\n+}\n+\n } // namespace TyTy\n } // namespace Rust"}, {"sha": "20bad107e1ddc0845dbfc8f59e480af15325e7ff", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a31969774e1e9b46800c6475d1a58ccc5ca436/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a31969774e1e9b46800c6475d1a58ccc5ca436/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=92a31969774e1e9b46800c6475d1a58ccc5ca436", "patch": "@@ -146,11 +146,42 @@ class TypeKindFormat\n   }\n };\n \n+class BaseType;\n+class TypeBoundPredicate;\n+class TypeBoundPredicateItem\n+{\n+public:\n+  TypeBoundPredicateItem (const TypeBoundPredicate *parent,\n+\t\t\t  const Resolver::TraitItemReference *trait_item_ref)\n+    : parent (parent), trait_item_ref (trait_item_ref)\n+  {}\n+\n+  static TypeBoundPredicateItem error ()\n+  {\n+    return TypeBoundPredicateItem (nullptr, nullptr);\n+  }\n+\n+  bool is_error () const\n+  {\n+    return parent == nullptr || trait_item_ref == nullptr;\n+  }\n+\n+  BaseType *get_tyty_for_receiver (const TyTy::BaseType *receiver);\n+\n+  const Resolver::TraitItemReference *get_raw_item () const;\n+\n+  bool needs_implementation () const;\n+\n+private:\n+  const TypeBoundPredicate *parent;\n+  const Resolver::TraitItemReference *trait_item_ref;\n+};\n+\n class TypeBoundPredicate\n {\n public:\n   TypeBoundPredicate (DefId reference, Location locus)\n-    : reference (reference), locus (locus)\n+    : reference (reference), locus (locus), args (nullptr)\n   {}\n \n   std::string as_string () const;\n@@ -165,9 +196,29 @@ class TypeBoundPredicate\n   // https://doc.rust-lang.org/reference/items/traits.html#object-safety\n   bool is_object_safe (bool emit_error, Location locus) const;\n \n+  void apply_generic_arguments (HIR::GenericArgs *generic_args);\n+\n+  bool contains_item (const std::string &search) const;\n+\n+  TypeBoundPredicateItem\n+  lookup_associated_item (const std::string &search) const;\n+\n+  HIR::GenericArgs *get_generic_args () { return args; }\n+\n+  const HIR::GenericArgs *get_generic_args () const { return args; }\n+\n+  bool has_generic_args () const\n+  {\n+    if (args == nullptr)\n+      return false;\n+\n+    return args->has_generic_args ();\n+  }\n+\n private:\n   DefId reference;\n   Location locus;\n+  HIR::GenericArgs *args;\n };\n \n class TypeBoundsMappings"}, {"sha": "1fe77e3a60c49f042c18d435b847db6c7b55d75e", "filename": "gcc/testsuite/rust/execute/torture/trait9.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a31969774e1e9b46800c6475d1a58ccc5ca436/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a31969774e1e9b46800c6475d1a58ccc5ca436/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait9.rs?ref=92a31969774e1e9b46800c6475d1a58ccc5ca436", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-output \"3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+trait FnLike<A, R> {\n+    fn call(&self, arg: A) -> R;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .arg.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct S;\n+impl<T> FnLike<&T, &T> for S {\n+    fn call(&self, arg: &T) -> &T {\n+        // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+        // { dg-warning \"unused name .<S as FnLike>::call.\" \"\" { target *-*-* } .-2 }\n+        arg\n+    }\n+}\n+\n+fn indirect<F: FnLike<&isize, &isize>>(f: F) {\n+    let x = 3;\n+    let y = f.call(&x);\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, *y);\n+    }\n+}\n+\n+fn main() -> i32 {\n+    indirect(S);\n+\n+    0\n+}"}]}