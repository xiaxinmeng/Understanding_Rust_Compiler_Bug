{"sha": "927630a5658fcd6707593f6b486c9aa80fcacd44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI3NjMwYTU2NThmY2Q2NzA3NTkzZjZiNDg2YzlhYTgwZmNhY2Q0NA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-03-10T23:28:01Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-03-10T23:28:01Z"}, "message": "expr.c (expand_expr_real_1): If possible, use a conditional move for expanding MIN_EXPR and MAX_EXPR.\n\n\t* expr.c (expand_expr_real_1): If possible, use a conditional\n\tmove for expanding MIN_EXPR and MAX_EXPR.\n\tUse temp for moving around rtx-en.\n\nFrom-SVN: r96269", "tree": {"sha": "f843660de8e938b83421485c8cf571dcacbc0ae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f843660de8e938b83421485c8cf571dcacbc0ae5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/927630a5658fcd6707593f6b486c9aa80fcacd44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/927630a5658fcd6707593f6b486c9aa80fcacd44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/927630a5658fcd6707593f6b486c9aa80fcacd44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/927630a5658fcd6707593f6b486c9aa80fcacd44/comments", "author": null, "committer": null, "parents": [{"sha": "cebfb966e6b7eb32bc2b25f53d43847f20270577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cebfb966e6b7eb32bc2b25f53d43847f20270577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cebfb966e6b7eb32bc2b25f53d43847f20270577"}], "stats": {"total": 63, "additions": 55, "deletions": 8}, "files": [{"sha": "9de54901da4e4e2ae58d367d0fe049acef08e92c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927630a5658fcd6707593f6b486c9aa80fcacd44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927630a5658fcd6707593f6b486c9aa80fcacd44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=927630a5658fcd6707593f6b486c9aa80fcacd44", "patch": "@@ -1,3 +1,9 @@\n+2005-03-10  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* expr.c (expand_expr_real_1): If possible, use a conditional\n+\tmove for expanding MIN_EXPR and MAX_EXPR.\n+\tUse temp for moving around rtx-en.\n+\n 2005-03-10  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR rtl-opt/20412\n@@ -18,7 +24,7 @@\n \n 2005-03-10  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * doc/invoke.texi: Add 8540 to list of cpus in rs6000 cpu section.\n+\t* doc/invoke.texi: Add 8540 to list of cpus in rs6000 cpu section.\n \n 2005-03-10  Kazu Hirata  <kazu@cs.umass.edu>\n "}, {"sha": "775a83a3cfce7599e7aab4dcad7ebd94a1956d67", "filename": "gcc/expr.c", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927630a5658fcd6707593f6b486c9aa80fcacd44/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927630a5658fcd6707593f6b486c9aa80fcacd44/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=927630a5658fcd6707593f6b486c9aa80fcacd44", "patch": "@@ -7876,20 +7876,61 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* If op1 was placed in target, swap op0 and op1.  */\n       if (target != op0 && target == op1)\n \t{\n-\t  rtx tem = op0;\n+\t  temp = op0;\n \t  op0 = op1;\n-\t  op1 = tem;\n+\t  op1 = temp;\n \t}\n \n       /* We generate better code and avoid problems with op1 mentioning\n \t target by forcing op1 into a pseudo if it isn't a constant.  */\n       if (! CONSTANT_P (op1))\n \top1 = force_reg (mode, op1);\n \n+#ifdef HAVE_conditional_move\n+      /* Use a conditional move if possible.  */\n+      if (can_conditionally_move_p (mode))\n+\t{\n+\t  enum rtx_code comparison_code;\n+\t  rtx insn;\n+\n+\t  if (code == MAX_EXPR)\n+\t    comparison_code = unsignedp ? GEU : GE;\n+\t  else\n+\t    comparison_code = unsignedp ? LEU : LE;\n+\n+\t  /* ??? Same problem as in expmed.c: emit_conditional_move\n+\t     forces a stack adjustment via compare_from_rtx, and we\n+\t     lose the stack adjustment if the sequence we are about\n+\t     to create is discarded.  */\n+\t  do_pending_stack_adjust ();\n+\n+\t  start_sequence ();\n+\n+\t  /* Try to emit the conditional move.  */\n+\t  insn = emit_conditional_move (target, comparison_code,\n+\t\t\t\t\top0, op1, mode,\n+\t\t\t\t\top0, op1, mode,\n+\t\t\t\t\tunsignedp);\n+\n+\t  /* If we could do the conditional move, emit the sequence,\n+\t     and return.  */\n+\t  if (insn)\n+\t    {\n+\t      rtx seq = get_insns ();\n+\t      end_sequence ();\n+\t      emit_insn (seq);\n+\t      return target;\n+\t    }\n+\n+\t  /* Otherwise discard the sequence and fall back to code with\n+\t     branches.  */\n+\t  end_sequence ();\n+\t}\n+#endif\n       if (target != op0)\n \temit_move_insn (target, op0);\n \n-      op0 = gen_label_rtx ();\n+      temp = gen_label_rtx ();\n \n       /* If this mode is an integer too wide to compare properly,\n \t compare word by word.  Rely on cse to optimize constant cases.  */\n@@ -7898,18 +7939,18 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t{\n \t  if (code == MAX_EXPR)\n \t    do_jump_by_parts_greater_rtx (mode, unsignedp, target, op1,\n-\t\t\t\t\t  NULL_RTX, op0);\n+\t\t\t\t\t  NULL_RTX, temp);\n \t  else\n \t    do_jump_by_parts_greater_rtx (mode, unsignedp, op1, target,\n-\t\t\t\t\t  NULL_RTX, op0);\n+\t\t\t\t\t  NULL_RTX, temp);\n \t}\n       else\n \t{\n \t  do_compare_rtx_and_jump (target, op1, code == MAX_EXPR ? GE : LE,\n-\t\t\t\t   unsignedp, mode, NULL_RTX, NULL_RTX, op0);\n+\t\t\t\t   unsignedp, mode, NULL_RTX, NULL_RTX, temp);\n \t}\n       emit_move_insn (target, op1);\n-      emit_label (op0);\n+      emit_label (temp);\n       return target;\n \n     case BIT_NOT_EXPR:"}]}