{"sha": "73c68f614dcd037a892768ace3481d45d8280436", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNjNjhmNjE0ZGNkMDM3YTg5Mjc2OGFjZTM0ODFkNDVkODI4MDQzNg==", "commit": {"author": {"name": "Scott Snyder", "email": "snyder@fnal.gov", "date": "2003-02-28T23:57:50Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-02-28T23:57:50Z"}, "message": "flags.h: Add flag_eliminate_unused_debug_types.\n\n        * flags.h: Add flag_eliminate_unused_debug_types.\n        * toplev.c: Add flag_eliminate_unused_debug_types.\n        (f_options): Add -feliminate-unused-debug-types.\n        * dwarf2out.c (struct file_table): Add emitted member.\n        (splice_child_die): Fix the parent pointer for the child being\n        spliced.\n        (lookup_filename): Maintain file_table.emitted array.  Don't\n        output .file directive here.\n        (maybe_emit_file): (new)\n        (init_file_table): Set up file_table.emitted.\n        (dwarf2out_source_line): Use maybe_emit_file.\n        (dwarf2out_start_source_file): Use maybe_emit_file.\n        (dwarf2out_init): Use maybe_emit_file.\n        (prune_unused_types_walk_attribs): (new)\n        (prune_unused_types_mark): (new)\n        (prune_unused_types_walk): (new)\n        (prune_unused_types_prune): (new)\n        (prune_unused_types): (new)\n        (dwarf2out_finish): Call prune_unused_types if\n        flag_eliminate_unused_debug_types is set.\n        * doc/invoke.texi (Option Summary): Add\n        -feliminate-unused-debug-types.\n        (Debugging Options): Likewise.\n\nFrom-SVN: r63588", "tree": {"sha": "7110cbf93c9b18e15a06019a2d41460bedc046c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7110cbf93c9b18e15a06019a2d41460bedc046c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73c68f614dcd037a892768ace3481d45d8280436", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c68f614dcd037a892768ace3481d45d8280436", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73c68f614dcd037a892768ace3481d45d8280436", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c68f614dcd037a892768ace3481d45d8280436/comments", "author": null, "committer": null, "parents": [{"sha": "d8fad4ea49a49a7787891d1a6e7dbb81e2a09572", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8fad4ea49a49a7787891d1a6e7dbb81e2a09572", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8fad4ea49a49a7787891d1a6e7dbb81e2a09572"}], "stats": {"total": 596, "additions": 444, "deletions": 152}, "files": [{"sha": "298c1dd0e63e66941255b45061cdfa989c23bc84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c68f614dcd037a892768ace3481d45d8280436/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c68f614dcd037a892768ace3481d45d8280436/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73c68f614dcd037a892768ace3481d45d8280436", "patch": "@@ -1,3 +1,29 @@\n+2003-02-28  scott snyder  <snyder@fnal.gov>\n+\n+\t* flags.h: Add flag_eliminate_unused_debug_types.\n+\t* toplev.c: Add flag_eliminate_unused_debug_types.\n+\t(f_options): Add -feliminate-unused-debug-types.\n+\t* dwarf2out.c (struct file_table): Add emitted member.\n+\t(splice_child_die): Fix the parent pointer for the child being\n+\tspliced.\n+\t(lookup_filename): Maintain file_table.emitted array.  Don't\n+\toutput .file directive here.\n+\t(maybe_emit_file): (new)\n+\t(init_file_table): Set up file_table.emitted.\n+\t(dwarf2out_source_line): Use maybe_emit_file.\n+\t(dwarf2out_start_source_file): Use maybe_emit_file.\n+\t(dwarf2out_init): Use maybe_emit_file.\n+\t(prune_unused_types_walk_attribs): (new)\n+\t(prune_unused_types_mark): (new)\n+\t(prune_unused_types_walk): (new)\n+\t(prune_unused_types_prune): (new)\n+\t(prune_unused_types): (new)\n+\t(dwarf2out_finish): Call prune_unused_types if\n+\tflag_eliminate_unused_debug_types is set.\n+\t* doc/invoke.texi (Option Summary): Add\n+\t-feliminate-unused-debug-types.\n+\t(Debugging Options): Likewise.\n+\n 2003-02-28  Geoffrey Keating  <geoffk@apple.com>\n \n \t* doc/invoke.texi: Change .pch to .gch."}, {"sha": "755d0dd54aa44c6854971674c2cf0867c0d67a7c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c68f614dcd037a892768ace3481d45d8280436/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c68f614dcd037a892768ace3481d45d8280436/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=73c68f614dcd037a892768ace3481d45d8280436", "patch": "@@ -258,6 +258,7 @@ in the following sections.\n -p  -pg  -print-file-name=@var{library}  -print-libgcc-file-name @gol\n -print-multi-directory  -print-multi-lib @gol\n -print-prog-name=@var{program}  -print-search-dirs  -Q @gol\n+-feliminate-unused-debug-types @gol\n -save-temps  -time}\n \n @item Optimization Options\n@@ -3412,6 +3413,18 @@ anything else.\n @opindex dumpspecs\n Print the compiler's built-in specs---and don't do anything else.  (This\n is used when GCC itself is being built.)  @xref{Spec Files}.\n+\n+@item -feliminate-unused-debug-types\n+@opindex feliminate-unused-debug-types\n+Normally, when producing DWARF2 output, GCC will emit debugging\n+information for all types declared in a compilation\n+unit, regardless of whether or not they are actually used\n+in that compilation unit.  Sometimes this is useful, such as\n+if, in the debugger, you want to cast a value to a type that is\n+not actually used in your program (but is declared).  More often,\n+however, this results in a significant amount of wasted space.\n+With this option, GCC will avoid producing debug symbol output\n+for types that are nowhere used in the source file being compiled.\n @end table\n \n @node Optimize Options"}, {"sha": "03d02cc386005898e1a67adb27b54215813fd4da", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 395, "deletions": 152, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c68f614dcd037a892768ace3481d45d8280436/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c68f614dcd037a892768ace3481d45d8280436/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=73c68f614dcd037a892768ace3481d45d8280436", "patch": "@@ -337,7 +337,7 @@ static void dwarf2out_frame_debug_expr\tPARAMS ((rtx, const char *));\n /* Support for complex CFA locations.  */\n static void output_cfa_loc \t\tPARAMS ((dw_cfi_ref));\n static void get_cfa_from_loc_descr \tPARAMS ((dw_cfa_location *,\n-\t\t\t\t\t        struct dw_loc_descr_struct *));\n+\t\t\t\t\t\tstruct dw_loc_descr_struct *));\n static struct dw_loc_descr_struct *build_cfa_loc\n \t\t\t\t\tPARAMS ((dw_cfa_location *));\n static void def_cfa_1\t\t \tPARAMS ((const char *,\n@@ -1236,7 +1236,7 @@ static dw_cfa_location cfa_temp;\n   Rule 1:\n   (set <reg1> <reg2>:cfa.reg)\n   effects: cfa.reg = <reg1>\n-           cfa.offset unchanged\n+\t   cfa.offset unchanged\n \t   cfa_temp.reg = <reg1>\n \t   cfa_temp.offset = cfa.offset\n \n@@ -1357,7 +1357,7 @@ dwarf2out_frame_debug_expr (expr, label)\n     case REG:\n       /* Rule 1 */\n       /* Update the CFA rule wrt SP or FP.  Make sure src is\n-         relative to the current CFA register.  */\n+\t relative to the current CFA register.  */\n       switch (GET_CODE (src))\n \t{\n \t  /* Setting FP from SP.  */\n@@ -1620,7 +1620,7 @@ dwarf2out_frame_debug_expr (expr, label)\n \t  else\n \t    {\n \t      /* Otherwise, we'll need to look in the stack to\n-                 calculate the CFA.  */\n+\t\t calculate the CFA.  */\n \t      rtx x = XEXP (dest, 0);\n \n \t      if (GET_CODE (x) != REG)\n@@ -2123,13 +2123,13 @@ output_call_frame_info (for_eh)\n \t      dw2_asm_output_data_uleb128 (size, \"Augmentation size\");\n \n \t      if (fde->uses_eh_lsda)\n-\t        {\n-\t          ASM_GENERATE_INTERNAL_LABEL (l1, \"LLSDA\",\n+\t\t{\n+\t\t  ASM_GENERATE_INTERNAL_LABEL (l1, \"LLSDA\",\n \t\t\t\t\t       fde->funcdef_number);\n-\t          dw2_asm_output_encoded_addr_rtx (\n+\t\t  dw2_asm_output_encoded_addr_rtx (\n \t\t\tlsda_encoding, gen_rtx_SYMBOL_REF (Pmode, l1),\n \t\t \t\"Language Specific Data Area\");\n-\t        }\n+\t\t}\n \t      else\n \t\t{\n \t\t  if (lsda_encoding == DW_EH_PE_aligned)\n@@ -2151,7 +2151,7 @@ output_call_frame_info (for_eh)\n \n       /* Pad the FDE out to an address sized boundary.  */\n       ASM_OUTPUT_ALIGN (asm_out_file,\n-\t\t        floor_log2 ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE)));\n+\t\t\tfloor_log2 ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE)));\n       ASM_OUTPUT_LABEL (asm_out_file, l2);\n     }\n \n@@ -2953,9 +2953,9 @@ output_loc_operands (loc)\n     case DW_OP_skip:\n     case DW_OP_bra:\n       /* We currently don't make any attempt to make sure these are\n-         aligned properly like we do for the main unwind info, so\n-         don't support emitting things larger than a byte if we're\n-         only doing unwinding.  */\n+\t aligned properly like we do for the main unwind info, so\n+\t don't support emitting things larger than a byte if we're\n+\t only doing unwinding.  */\n       abort ();\n #endif\n     case DW_OP_const1u:\n@@ -3458,6 +3458,7 @@ static GTY(()) limbo_die_node *limbo_die_list;\n \n /* Filenames referenced by this compilation unit.  */\n static GTY(()) varray_type file_table;\n+static GTY(()) varray_type file_table_emitted;\n static GTY(()) size_t file_table_last_lookup_index;\n \n /* A pointer to the base of a table of references to DIE's that describe\n@@ -3844,6 +3845,14 @@ static void add_loc_descr_to_loc_list   PARAMS ((dw_loc_list_ref *,\n static void output_loc_list\t\tPARAMS ((dw_loc_list_ref));\n static char *gen_internal_sym \t\tPARAMS ((const char *));\n \n+static void prune_unmark_dies\t\tPARAMS ((dw_die_ref));\n+static void prune_unused_types_mark     PARAMS ((dw_die_ref, int));\n+static void prune_unused_types_walk     PARAMS ((dw_die_ref));\n+static void prune_unused_types_walk_attribs PARAMS ((dw_die_ref));\n+static void prune_unused_types_prune    PARAMS ((dw_die_ref));\n+static void prune_unused_types          PARAMS ((void));\n+static int maybe_emit_file              PARAMS ((int));\n+\n /* Section names used to hold DWARF debugging information.  */\n #ifndef DEBUG_INFO_SECTION\n #define DEBUG_INFO_SECTION\t\".debug_info\"\n@@ -5217,6 +5226,7 @@ splice_child_die (parent, child)\n \tbreak;\n       }\n \n+  child->die_parent = parent;\n   child->die_sib = parent->die_child;\n   parent->die_child = child;\n }\n@@ -5699,12 +5709,12 @@ same_dw_val_p (v1, v2, mark)\n       return v1->v.val_unsigned == v2->v.val_unsigned;\n     case dw_val_class_long_long:\n       return v1->v.val_long_long.hi == v2->v.val_long_long.hi\n-             && v1->v.val_long_long.low == v2->v.val_long_long.low;\n+\t     && v1->v.val_long_long.low == v2->v.val_long_long.low;\n     case dw_val_class_float:\n       if (v1->v.val_float.length != v2->v.val_float.length)\n \treturn 0;\n       for (i = 0; i < v1->v.val_float.length; i++)\n-        if (v1->v.val_float.array[i] != v2->v.val_float.array[i])\n+\tif (v1->v.val_float.array[i] != v2->v.val_float.array[i])\n \t  return 0;\n       return 1;\n     case dw_val_class_flag:\n@@ -6145,7 +6155,7 @@ break_out_includes (die)\n       if (is_dupl)\n \t*pnode = node->next;\n       else\n-        {\n+\t{\n \t  pnode = &node->next;\n \t  record_comdat_symbol_number (node->die, cu_hash_table,\n \t\tcomdat_symbol_number);\n@@ -7078,7 +7088,7 @@ output_aranges ()\n   if (DWARF_ARANGES_PAD_SIZE)\n     {\n       /* Pad using a 2 byte words so that padding is correct for any\n-         pointer size.  */\n+\t pointer size.  */\n       dw2_asm_output_data (2, 0, \"Pad to %d byte boundary\",\n \t\t\t   2 * DWARF2_ADDR_SIZE);\n       for (i = 2; i < (unsigned) DWARF_ARANGES_PAD_SIZE; i += 2)\n@@ -7582,8 +7592,8 @@ output_line_info ()\n \t prologue.  */\n \n       /* Don't emit anything for redundant notes.  Just updating the\n-         address doesn't accomplish anything, because we already assume\n-         that anything after the last address is this line.  */\n+\t address doesn't accomplish anything, because we already assume\n+\t that anything after the last address is this line.  */\n       if (line_info->dw_line_num == current_line\n \t  && line_info->dw_file_num == current_file)\n \tcontinue;\n@@ -7609,7 +7619,7 @@ output_line_info ()\n       else\n \t{\n \t  /* This can handle any delta.  This takes\n-             4+DWARF2_ADDR_SIZE bytes.  */\n+\t     4+DWARF2_ADDR_SIZE bytes.  */\n \t  dw2_asm_output_data (1, 0, \"DW_LNE_set_address\");\n \t  dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n \t  dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n@@ -7831,9 +7841,9 @@ base_type_die (type)\n     {\n     case INTEGER_TYPE:\n       /* Carefully distinguish the C character types, without messing\n-         up if the language is not C. Note that we check only for the names\n-         that contain spaces; other names might occur by coincidence in other\n-         languages.  */\n+\t up if the language is not C. Note that we check only for the names\n+\t that contain spaces; other names might occur by coincidence in other\n+\t languages.  */\n       if (! (TYPE_PRECISION (type) == CHAR_TYPE_SIZE\n \t     && (type == char_type_node\n \t\t || ! strcmp (type_name, \"signed char\")\n@@ -8284,28 +8294,28 @@ mem_loc_descriptor (rtl, mode)\n \n     case SUBREG:\n       /* The case of a subreg may arise when we have a local (register)\n-         variable or a formal (register) parameter which doesn't quite fill\n-         up an entire register.  For now, just assume that it is\n-         legitimate to make the Dwarf info refer to the whole register which\n-         contains the given subreg.  */\n+\t variable or a formal (register) parameter which doesn't quite fill\n+\t up an entire register.  For now, just assume that it is\n+\t legitimate to make the Dwarf info refer to the whole register which\n+\t contains the given subreg.  */\n       rtl = SUBREG_REG (rtl);\n \n       /* ... fall through ...  */\n \n     case REG:\n       /* Whenever a register number forms a part of the description of the\n-         method for calculating the (dynamic) address of a memory resident\n-         object, DWARF rules require the register number be referred to as\n-         a \"base register\".  This distinction is not based in any way upon\n-         what category of register the hardware believes the given register\n-         belongs to.  This is strictly DWARF terminology we're dealing with\n-         here. Note that in cases where the location of a memory-resident\n-         data object could be expressed as: OP_ADD (OP_BASEREG (basereg),\n-         OP_CONST (0)) the actual DWARF location descriptor that we generate\n-         may just be OP_BASEREG (basereg).  This may look deceptively like\n-         the object in question was allocated to a register (rather than in\n-         memory) so DWARF consumers need to be aware of the subtle\n-         distinction between OP_REG and OP_BASEREG.  */\n+\t method for calculating the (dynamic) address of a memory resident\n+\t object, DWARF rules require the register number be referred to as\n+\t a \"base register\".  This distinction is not based in any way upon\n+\t what category of register the hardware believes the given register\n+\t belongs to.  This is strictly DWARF terminology we're dealing with\n+\t here. Note that in cases where the location of a memory-resident\n+\t data object could be expressed as: OP_ADD (OP_BASEREG (basereg),\n+\t OP_CONST (0)) the actual DWARF location descriptor that we generate\n+\t may just be OP_BASEREG (basereg).  This may look deceptively like\n+\t the object in question was allocated to a register (rather than in\n+\t memory) so DWARF consumers need to be aware of the subtle\n+\t distinction between OP_REG and OP_BASEREG.  */\n       if (REGNO (rtl) < FIRST_PSEUDO_REGISTER)\n \tmem_loc_result = based_loc_descr (reg_number (rtl), 0);\n       break;\n@@ -8354,7 +8364,7 @@ mem_loc_descriptor (rtl, mode)\n \n     case PRE_MODIFY:\n       /* Extract the PLUS expression nested inside and fall into\n-         PLUS code below.  */\n+\t PLUS code below.  */\n       rtl = XEXP (rtl, 1);\n       goto plus;\n \n@@ -8475,10 +8485,10 @@ loc_descriptor (rtl)\n     {\n     case SUBREG:\n       /* The case of a subreg may arise when we have a local (register)\n-         variable or a formal (register) parameter which doesn't quite fill\n-         up an entire register.  For now, just assume that it is\n-         legitimate to make the Dwarf info refer to the whole register which\n-         contains the given subreg.  */\n+\t variable or a formal (register) parameter which doesn't quite fill\n+\t up an entire register.  For now, just assume that it is\n+\t legitimate to make the Dwarf info refer to the whole register which\n+\t contains the given subreg.  */\n       rtl = SUBREG_REG (rtl);\n \n       /* ... fall through ...  */\n@@ -9199,9 +9209,9 @@ add_const_value_attribute (die, rtl)\n \n     case CONST_DOUBLE:\n       /* Note that a CONST_DOUBLE rtx could represent either an integer or a\n-         floating-point constant.  A CONST_DOUBLE is used whenever the\n-         constant requires more than one word in order to be adequately\n-         represented.  We output CONST_DOUBLEs as blocks.  */\n+\t floating-point constant.  A CONST_DOUBLE is used whenever the\n+\t constant requires more than one word in order to be adequately\n+\t represented.  We output CONST_DOUBLEs as blocks.  */\n       {\n \tenum machine_mode mode = GET_MODE (rtl);\n \n@@ -9258,16 +9268,16 @@ add_const_value_attribute (die, rtl)\n \n     case PLUS:\n       /* In cases where an inlined instance of an inline function is passed\n-         the address of an `auto' variable (which is local to the caller) we\n-         can get a situation where the DECL_RTL of the artificial local\n-         variable (for the inlining) which acts as a stand-in for the\n-         corresponding formal parameter (of the inline function) will look\n-         like (plus:SI (reg:SI FRAME_PTR) (const_int ...)).  This is not\n-         exactly a compile-time constant expression, but it isn't the address\n-         of the (artificial) local variable either.  Rather, it represents the\n-         *value* which the artificial local variable always has during its\n-         lifetime.  We currently have no way to represent such quasi-constant\n-         values in Dwarf, so for now we just punt and generate nothing.  */\n+\t the address of an `auto' variable (which is local to the caller) we\n+\t can get a situation where the DECL_RTL of the artificial local\n+\t variable (for the inlining) which acts as a stand-in for the\n+\t corresponding formal parameter (of the inline function) will look\n+\t like (plus:SI (reg:SI FRAME_PTR) (const_int ...)).  This is not\n+\t exactly a compile-time constant expression, but it isn't the address\n+\t of the (artificial) local variable either.  Rather, it represents the\n+\t *value* which the artificial local variable always has during its\n+\t lifetime.  We currently have no way to represent such quasi-constant\n+\t values in Dwarf, so for now we just punt and generate nothing.  */\n       break;\n \n     default:\n@@ -9366,7 +9376,7 @@ rtl_for_decl_location (decl)\n       if (rtl\n \t  && (CONSTANT_P (rtl)\n \t      || (GET_CODE (rtl) == MEM\n-\t          && CONSTANT_P (XEXP (rtl, 0)))))\n+\t\t  && CONSTANT_P (XEXP (rtl, 0)))))\n \t{\n \t  rtl = (*targetm.delegitimize_address) (rtl);\n \t  return rtl;\n@@ -9653,23 +9663,23 @@ add_bound_info (subrange_die, bound_attr, bound)\n \n     case SAVE_EXPR:\n       /* If optimization is turned on, the SAVE_EXPRs that describe how to\n-         access the upper bound values may be bogus.  If they refer to a\n-         register, they may only describe how to get at these values at the\n-         points in the generated code right after they have just been\n-         computed.  Worse yet, in the typical case, the upper bound values\n-         will not even *be* computed in the optimized code (though the\n-         number of elements will), so these SAVE_EXPRs are entirely\n-         bogus. In order to compensate for this fact, we check here to see\n-         if optimization is enabled, and if so, we don't add an attribute\n-         for the (unknown and unknowable) upper bound.  This should not\n-         cause too much trouble for existing (stupid?)  debuggers because\n-         they have to deal with empty upper bounds location descriptions\n-         anyway in order to be able to deal with incomplete array types.\n-         Of course an intelligent debugger (GDB?)  should be able to\n-         comprehend that a missing upper bound specification in an array\n-         type used for a storage class `auto' local array variable\n-         indicates that the upper bound is both unknown (at compile- time)\n-         and unknowable (at run-time) due to optimization.\n+\t access the upper bound values may be bogus.  If they refer to a\n+\t register, they may only describe how to get at these values at the\n+\t points in the generated code right after they have just been\n+\t computed.  Worse yet, in the typical case, the upper bound values\n+\t will not even *be* computed in the optimized code (though the\n+\t number of elements will), so these SAVE_EXPRs are entirely\n+\t bogus. In order to compensate for this fact, we check here to see\n+\t if optimization is enabled, and if so, we don't add an attribute\n+\t for the (unknown and unknowable) upper bound.  This should not\n+\t cause too much trouble for existing (stupid?)  debuggers because\n+\t they have to deal with empty upper bounds location descriptions\n+\t anyway in order to be able to deal with incomplete array types.\n+\t Of course an intelligent debugger (GDB?)  should be able to\n+\t comprehend that a missing upper bound specification in an array\n+\t type used for a storage class `auto' local array variable\n+\t indicates that the upper bound is both unknown (at compile- time)\n+\t and unknowable (at run-time) due to optimization.\n \n \t We assume that a MEM rtx is safe because gcc wouldn't put the\n \t value there unless it was going to be used repeatedly in the\n@@ -9790,7 +9800,7 @@ add_subscript_info (type_die, type)\n \n       /* Arrays come in three flavors: Unspecified bounds, fixed bounds,\n \t and (in GNU C only) variable bounds.  Handle all three forms\n-         here.  */\n+\t here.  */\n       subrange_die = new_die (DW_TAG_subrange_type, type_die, NULL);\n       if (domain)\n \t{\n@@ -9852,9 +9862,9 @@ add_byte_size_attribute (die, tree_node)\n       break;\n     case FIELD_DECL:\n       /* For a data member of a struct or union, the DW_AT_byte_size is\n-         generally given as the number of bytes normally allocated for an\n-         object of the *declared* type of the member itself.  This is true\n-         even for bit-fields.  */\n+\t generally given as the number of bytes normally allocated for an\n+\t object of the *declared* type of the member itself.  This is true\n+\t even for bit-fields.  */\n       size = simple_type_size_in_bits (field_type (tree_node)) / BITS_PER_UNIT;\n       break;\n     default:\n@@ -9979,7 +9989,7 @@ add_abstract_origin_attribute (die, origin)\n \t function, if we're in an exception handler or some such; make\n \t sure that the abstract function has been written out.\n \n-         Doing this for nested functions is wrong, however; functions are\n+\t Doing this for nested functions is wrong, however; functions are\n \t distinct units, and our context might not even be inline.  */\n       tree fn = origin;\n \n@@ -10239,8 +10249,8 @@ type_tag (type)\n \tt = TYPE_NAME (type);\n \n       /* The g++ front end makes the TYPE_NAME of *each* tagged type point to\n-         a TYPE_DECL node, regardless of whether or not a `typedef' was\n-         involved.  */\n+\t a TYPE_DECL node, regardless of whether or not a `typedef' was\n+\t involved.  */\n       else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t       && ! DECL_IGNORED_P (TYPE_NAME (type)))\n \tt = DECL_NAME (TYPE_NAME (type));\n@@ -10888,8 +10898,8 @@ gen_subprogram_die (decl, context_die)\n #endif\n \n       /* Define the \"frame base\" location for this routine.  We use the\n-         frame pointer or stack pointer registers, since the RTL for local\n-         variables is relative to one of them.  */\n+\t frame pointer or stack pointer registers, since the RTL for local\n+\t variables is relative to one of them.  */\n       fp_reg\n \t= frame_pointer_needed ? hard_frame_pointer_rtx : stack_pointer_rtx;\n       add_AT_loc (subr_die, DW_AT_frame_base, reg_loc_descriptor (fp_reg));\n@@ -10927,7 +10937,7 @@ gen_subprogram_die (decl, context_die)\n       tree parm;\n \n       /* When generating DIEs, generate the unspecified_parameters DIE\n-         instead if we come across the arg \"__builtin_va_alist\" */\n+\t instead if we come across the arg \"__builtin_va_alist\" */\n       for (parm = arg_decls; parm; parm = TREE_CHAIN (parm))\n \tif (TREE_CODE (parm) == PARM_DECL)\n \t  {\n@@ -10940,11 +10950,11 @@ gen_subprogram_die (decl, context_die)\n \t  }\n \n       /* Decide whether we need an unspecified_parameters DIE at the end.\n-         There are 2 more cases to do this for: 1) the ansi ... declaration -\n-         this is detectable when the end of the arg list is not a\n-         void_type_node 2) an unprototyped function declaration (not a\n-         definition).  This just means that we have no info about the\n-         parameters at all.  */\n+\t There are 2 more cases to do this for: 1) the ansi ... declaration -\n+\t this is detectable when the end of the arg list is not a\n+\t void_type_node 2) an unprototyped function declaration (not a\n+\t definition).  This just means that we have no info about the\n+\t parameters at all.  */\n       fn_arg_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n       if (fn_arg_types != NULL)\n \t{\n@@ -11495,7 +11505,7 @@ gen_struct_or_union_type_die (type, context_die)\n   if (complete)\n     {\n       /* Prevent infinite recursion in cases where the type of some member of\n-         this type is expressed in terms of this type itself.  */\n+\t this type is expressed in terms of this type itself.  */\n       TREE_ASM_WRITTEN (type) = 1;\n       add_byte_size_attribute (type_die, type);\n       if (TYPE_STUB_DECL (type) != NULL_TREE)\n@@ -11645,7 +11655,7 @@ gen_type_die (type, context_die)\n       TREE_ASM_WRITTEN (type) = 1;\n \n       /* For these types, all that is required is that we output a DIE (or a\n-         set of DIEs) to represent the \"basis\" type.  */\n+\t set of DIEs) to represent the \"basis\" type.  */\n       gen_type_die (TREE_TYPE (type), context_die);\n       break;\n \n@@ -11658,7 +11668,7 @@ gen_type_die (type, context_die)\n       gen_type_die (TREE_TYPE (type), context_die);\n \n       /* Now output a DIE to represent this pointer-to-data-member type\n-         itself.  */\n+\t itself.  */\n       gen_ptr_to_mbr_type_die (type, context_die);\n       break;\n \n@@ -11703,11 +11713,11 @@ gen_type_die (type, context_die)\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n       /* If this is a nested type whose containing class hasn't been written\n-         out yet, writing it out will cover this one, too.  This does not apply\n-         to instantiations of member class templates; they need to be added to\n-         the containing class as they are generated.  FIXME: This hurts the\n-         idea of combining type decls from multiple TUs, since we can't predict\n-         what set of template instantiations we'll get.  */\n+\t out yet, writing it out will cover this one, too.  This does not apply\n+\t to instantiations of member class templates; they need to be added to\n+\t the containing class as they are generated.  FIXME: This hurts the\n+\t idea of combining type decls from multiple TUs, since we can't predict\n+\t what set of template instantiations we'll get.  */\n       if (TYPE_CONTEXT (type)\n \t  && AGGREGATE_TYPE_P (TYPE_CONTEXT (type))\n \t  && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n@@ -11850,12 +11860,12 @@ gen_block_die (stmt, context_die, depth)\n   else\n     {\n       /* In the case where the current block represents an inlining of the\n-         \"body block\" of an inline function, we must *NOT* output any DIE for\n-         this block because we have already output a DIE to represent the whole\n-         inlined function scope and the \"body block\" of any function doesn't\n-         really represent a different scope according to ANSI C rules.  So we\n-         check here to make sure that this block does not represent a \"body\n-         block inlining\" before trying to set the MUST_OUTPUT_DIE flag.  */\n+\t \"body block\" of an inline function, we must *NOT* output any DIE for\n+\t this block because we have already output a DIE to represent the whole\n+\t inlined function scope and the \"body block\" of any function doesn't\n+\t really represent a different scope according to ANSI C rules.  So we\n+\t check here to make sure that this block does not represent a \"body\n+\t block inlining\" before trying to set the MUST_OUTPUT_DIE flag.  */\n       if (! is_body_block (origin ? origin : stmt))\n \t{\n \t  /* Determine if this block directly contains any \"significant\"\n@@ -11980,7 +11990,7 @@ gen_decl_die (decl, context_die)\n \n     case CONST_DECL:\n       /* The individual enumerators of an enum type get output when we output\n-         the Dwarf representation of the relevant enum type itself.  */\n+\t the Dwarf representation of the relevant enum type itself.  */\n       break;\n \n     case FUNCTION_DECL:\n@@ -12030,16 +12040,16 @@ gen_decl_die (decl, context_die)\n \n     case TYPE_DECL:\n       /* If we are in terse mode, don't generate any DIEs to represent any\n-         actual typedefs.  */\n+\t actual typedefs.  */\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \tbreak;\n \n       /* In the special case of a TYPE_DECL node representing the declaration\n-         of some type tag, if the given TYPE_DECL is marked as having been\n-         instantiated from some other (original) TYPE_DECL node (e.g. one which\n-         was generated within the original definition of an inline function) we\n-         have to generate a special (abbreviated) DW_TAG_structure_type,\n-         DW_TAG_union_type, or DW_TAG_enumeration_type DIE here.  */\n+\t of some type tag, if the given TYPE_DECL is marked as having been\n+\t instantiated from some other (original) TYPE_DECL node (e.g. one which\n+\t was generated within the original definition of an inline function) we\n+\t have to generate a special (abbreviated) DW_TAG_structure_type,\n+\t DW_TAG_union_type, or DW_TAG_enumeration_type DIE here.  */\n       if (TYPE_DECL_IS_STUB (decl) && decl_ultimate_origin (decl) != NULL_TREE)\n \t{\n \t  gen_tagged_type_instantiation_die (TREE_TYPE (decl), context_die);\n@@ -12060,12 +12070,12 @@ gen_decl_die (decl, context_die)\n \n     case VAR_DECL:\n       /* If we are in terse mode, don't generate any DIEs to represent any\n-         variable declarations or definitions.  */\n+\t variable declarations or definitions.  */\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \tbreak;\n \n       /* Output any DIEs that are needed to specify the type of this data\n-         object.  */\n+\t object.  */\n       gen_type_die (TREE_TYPE (decl), context_die);\n \n       /* And its containing type.  */\n@@ -12074,9 +12084,9 @@ gen_decl_die (decl, context_die)\n \tgen_type_die_for_member (origin, decl, context_die);\n \n       /* Now output the DIE to represent the data object itself.  This gets\n-         complicated because of the possibility that the VAR_DECL really\n-         represents an inlined instance of a formal parameter for an inline\n-         function.  */\n+\t complicated because of the possibility that the VAR_DECL really\n+\t represents an inlined instance of a formal parameter for an inline\n+\t function.  */\n       origin = decl_ultimate_origin (decl);\n       if (origin != NULL_TREE && TREE_CODE (origin) == PARM_DECL)\n \tgen_formal_parameter_die (decl, context_die);\n@@ -12163,32 +12173,32 @@ dwarf2out_decl (decl)\n \n     case FUNCTION_DECL:\n       /* Ignore this FUNCTION_DECL if it refers to a builtin declaration of a\n-         builtin function.  Explicit programmer-supplied declarations of\n-         these same functions should NOT be ignored however.  */\n+\t builtin function.  Explicit programmer-supplied declarations of\n+\t these same functions should NOT be ignored however.  */\n       if (DECL_EXTERNAL (decl) && DECL_BUILT_IN (decl))\n \treturn;\n \n       /* What we would really like to do here is to filter out all mere\n-         file-scope declarations of file-scope functions which are never\n-         referenced later within this translation unit (and keep all of ones\n-         that *are* referenced later on) but we aren't clairvoyant, so we have\n-         no idea which functions will be referenced in the future (i.e. later\n-         on within the current translation unit). So here we just ignore all\n-         file-scope function declarations which are not also definitions.  If\n-         and when the debugger needs to know something about these functions,\n-         it will have to hunt around and find the DWARF information associated\n-         with the definition of the function.\n+\t file-scope declarations of file-scope functions which are never\n+\t referenced later within this translation unit (and keep all of ones\n+\t that *are* referenced later on) but we aren't clairvoyant, so we have\n+\t no idea which functions will be referenced in the future (i.e. later\n+\t on within the current translation unit). So here we just ignore all\n+\t file-scope function declarations which are not also definitions.  If\n+\t and when the debugger needs to know something about these functions,\n+\t it will have to hunt around and find the DWARF information associated\n+\t with the definition of the function.\n \n \t We can't just check DECL_EXTERNAL to find out which FUNCTION_DECL\n-         nodes represent definitions and which ones represent mere\n-         declarations.  We have to check DECL_INITIAL instead. That's because\n-         the C front-end supports some weird semantics for \"extern inline\"\n-         function definitions.  These can get inlined within the current\n-         translation unit (an thus, we need to generate Dwarf info for their\n-         abstract instances so that the Dwarf info for the concrete inlined\n-         instances can have something to refer to) but the compiler never\n-         generates any out-of-lines instances of such things (despite the fact\n-         that they *are* definitions).\n+\t nodes represent definitions and which ones represent mere\n+\t declarations.  We have to check DECL_INITIAL instead. That's because\n+\t the C front-end supports some weird semantics for \"extern inline\"\n+\t function definitions.  These can get inlined within the current\n+\t translation unit (an thus, we need to generate Dwarf info for their\n+\t abstract instances so that the Dwarf info for the concrete inlined\n+\t instances can have something to refer to) but the compiler never\n+\t generates any out-of-lines instances of such things (despite the fact\n+\t that they *are* definitions).\n \n \t The important point is that the C front-end marks these \"extern\n \t inline\" functions as DECL_EXTERNAL, but we need to generate DWARF for\n@@ -12207,18 +12217,18 @@ dwarf2out_decl (decl)\n \n     case VAR_DECL:\n       /* Ignore this VAR_DECL if it refers to a file-scope extern data object\n-         declaration and if the declaration was never even referenced from\n-         within this entire compilation unit.  We suppress these DIEs in\n-         order to save space in the .debug section (by eliminating entries\n-         which are probably useless).  Note that we must not suppress\n-         block-local extern declarations (whether used or not) because that\n-         would screw-up the debugger's name lookup mechanism and cause it to\n-         miss things which really ought to be in scope at a given point.  */\n+\t declaration and if the declaration was never even referenced from\n+\t within this entire compilation unit.  We suppress these DIEs in\n+\t order to save space in the .debug section (by eliminating entries\n+\t which are probably useless).  Note that we must not suppress\n+\t block-local extern declarations (whether used or not) because that\n+\t would screw-up the debugger's name lookup mechanism and cause it to\n+\t miss things which really ought to be in scope at a given point.  */\n       if (DECL_EXTERNAL (decl) && !TREE_USED (decl))\n \treturn;\n \n       /* If we are in terse mode, don't generate any DIEs to represent any\n-         variable declarations or definitions.  */\n+\t variable declarations or definitions.  */\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \treturn;\n       break;\n@@ -12229,11 +12239,11 @@ dwarf2out_decl (decl)\n \treturn;\n \n       /* Don't bother trying to generate any DIEs to represent any of the\n-         normal built-in types for the language we are compiling.  */\n+\t normal built-in types for the language we are compiling.  */\n       if (DECL_SOURCE_LINE (decl) == 0)\n \t{\n \t  /* OK, we need to generate one for `bool' so GDB knows what type\n-             comparisons have.  */\n+\t     comparisons have.  */\n \t  if ((get_AT_unsigned (comp_unit_die, DW_AT_language)\n \t       == DW_LANG_C_plus_plus)\n \t      && TREE_CODE (TREE_TYPE (decl)) == BOOLEAN_TYPE\n@@ -12336,7 +12346,7 @@ lookup_filename (file_name)\n       const char *last\n \t= VARRAY_CHAR_PTR (file_table, file_table_last_lookup_index);\n       if (strcmp (file_name, last) == 0)\n-        return file_table_last_lookup_index;\n+\treturn file_table_last_lookup_index;\n     }\n \n   /* Didn't match the previous lookup, search the table */\n@@ -12352,25 +12362,43 @@ lookup_filename (file_name)\n   file_table_last_lookup_index = n;\n   save_file_name = (char *) ggc_strdup (file_name);\n   VARRAY_PUSH_CHAR_PTR (file_table, save_file_name);\n+  VARRAY_PUSH_UINT (file_table_emitted, 0);\n \n-  if (DWARF2_ASM_LINE_DEBUG_INFO)\n+  return i;\n+}\n+\n+static int\n+maybe_emit_file (fileno)\n+     int fileno;\n+{\n+  static int emitcount = 0;  \n+  if (DWARF2_ASM_LINE_DEBUG_INFO && fileno > 0)\n     {\n-      fprintf (asm_out_file, \"\\t.file %lu \", (unsigned long) i);\n-      output_quoted_string (asm_out_file, file_name);\n-      fputc ('\\n', asm_out_file);\n+      if (!VARRAY_UINT (file_table_emitted, fileno))\n+\t{\n+\t  VARRAY_UINT (file_table_emitted, fileno) = ++emitcount;\n+\t  fprintf (asm_out_file, \"\\t.file %u \",\n+\t\t   VARRAY_UINT (file_table_emitted, fileno));\n+\t  output_quoted_string (asm_out_file,\n+\t\t\t\tVARRAY_CHAR_PTR (file_table, fileno));\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n+      return VARRAY_UINT (file_table_emitted, fileno);\n     }\n-\n-  return i;\n+  else\n+    return fileno;\n }\n \n static void\n init_file_table ()\n {\n   /* Allocate the initial hunk of the file_table.  */\n   VARRAY_CHAR_PTR_INIT (file_table, 64, \"file_table\");\n+  VARRAY_UINT_INIT (file_table_emitted, 64, \"file_table_emitted\");\n \n   /* Skip the first entry - file numbers begin at 1.  */\n   VARRAY_PUSH_CHAR_PTR (file_table, NULL);\n+  VARRAY_PUSH_UINT (file_table_emitted, 0);\n   file_table_last_lookup_index = 0;\n }\n \n@@ -12396,6 +12424,8 @@ dwarf2out_source_line (line, filename)\n \t{\n \t  unsigned file_num = lookup_filename (filename);\n \n+\t  file_num = maybe_emit_file (file_num);\n+\n \t  /* Emit the .loc directive understood by GNU as.  */\n \t  fprintf (asm_out_file, \"\\t.loc %d %d 0\\n\", file_num, line);\n \n@@ -12487,6 +12517,7 @@ dwarf2out_start_source_file (lineno, filename)\n       dw2_asm_output_data (1, DW_MACINFO_start_file, \"Start new file\");\n       dw2_asm_output_data_uleb128 (lineno, \"Included from line number %d\",\n \t\t\t\t   lineno);\n+      maybe_emit_file (lookup_filename (filename));\n       dw2_asm_output_data_uleb128 (lookup_filename (filename),\n \t\t\t\t   \"Filename we just started\");\n     }\n@@ -12646,6 +12677,215 @@ output_indirect_string (h, v)\n   return 1;\n }\n \n+\n+\n+/* Clear the marks for a die and its children.\n+   Be cool if the mark isn't set. */\n+\n+static void\n+prune_unmark_dies (die)\n+     dw_die_ref die;\n+{\n+  dw_die_ref c;\n+  die->die_mark = 0;\n+  for (c = die->die_child; c; c = c->die_sib)\n+    prune_unmark_dies (c);\n+}\n+\n+\n+/* Given DIE that we're marking as used, find any other dies\n+   it references as attributes and mark them as used.  */\n+\n+static void\n+prune_unused_types_walk_attribs (die)\n+     dw_die_ref die;\n+{\n+  dw_attr_ref a;\n+\n+  for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n+    {\n+      if (a->dw_attr_val.val_class == dw_val_class_die_ref)\n+\t{\n+\t  /* A reference to another DIE.\n+\t     Make sure that it will get emitted.  */\n+\t  prune_unused_types_mark (a->dw_attr_val.v.val_die_ref.die, 1);\n+\t}\n+      else if (a->dw_attr == DW_AT_decl_file)\n+\t{\n+\t  /* A reference to a file.  Make sure the file name is emitted.  */\n+\t  a->dw_attr_val.v.val_unsigned =\n+\t    maybe_emit_file (a->dw_attr_val.v.val_unsigned);\n+\t}\n+    }\n+}\n+\n+\n+/* Mark DIE as being used.  If DOKIDS is true, then walk down\n+   to DIE's children.  */\n+\n+static void\n+prune_unused_types_mark (die, dokids)\n+     dw_die_ref die;\n+     int dokids;\n+{\n+  dw_die_ref c;\n+\n+  if (die->die_mark == 0)\n+    {\n+      /* We haven't done this node yet.  Mark it as used.  */\n+      die->die_mark = 1;\n+\n+      /* We also have to mark its parents as used.\n+\t (But we don't want to mark our parents' kids due to this.)  */\n+      if (die->die_parent)\n+\tprune_unused_types_mark (die->die_parent, 0);\n+\n+      /* Mark any referenced nodes.  */\n+      prune_unused_types_walk_attribs (die);\n+    }\n+\n+  if (dokids && die->die_mark != 2)\n+    {\n+      /* We need to walk the children, but haven't done so yet.\n+\t Remember that we've walked the kids.  */\n+      die->die_mark = 2;\n+\n+      /* Walk them.  */\n+      for (c = die->die_child; c; c = c->die_sib)\n+\t{\n+\t  /* If this is an array type, we need to make sure our\n+\t     kids get marked, even if they're types. */\n+\t  if (die->die_tag == DW_TAG_array_type)\n+\t    prune_unused_types_mark (c, 1);\n+\t  else\n+\t    prune_unused_types_walk (c);\n+\t}\n+    }\n+}\n+\n+\n+/* Walk the tree DIE and mark types that we actually use.  */\n+\n+static void\n+prune_unused_types_walk (die)\n+     dw_die_ref die;\n+{\n+  dw_die_ref c;\n+\n+  /* Don't do anything if this node is already marked.  */\n+  if (die->die_mark)\n+    return;\n+\n+  switch (die->die_tag) {\n+  case DW_TAG_const_type:\n+  case DW_TAG_packed_type:\n+  case DW_TAG_pointer_type:\n+  case DW_TAG_reference_type:\n+  case DW_TAG_volatile_type:\n+  case DW_TAG_typedef:\n+  case DW_TAG_array_type:\n+  case DW_TAG_structure_type:\n+  case DW_TAG_union_type:\n+  case DW_TAG_class_type:\n+  case DW_TAG_friend:\n+  case DW_TAG_variant_part:\n+  case DW_TAG_enumeration_type:\n+  case DW_TAG_subroutine_type:\n+  case DW_TAG_string_type:\n+  case DW_TAG_set_type:\n+  case DW_TAG_subrange_type:\n+  case DW_TAG_ptr_to_member_type:\n+  case DW_TAG_file_type:\n+    /* It's a type node --- don't mark it.  */\n+    return;\n+\n+  default:\n+    /* Mark everything else.  */\n+    break;\n+  }\n+\n+  die->die_mark = 1;\n+\n+  /* Now, mark any dies referenced from here.  */\n+  prune_unused_types_walk_attribs (die);\n+\n+  /* Mark children.  */\n+  for (c = die->die_child; c; c = c->die_sib)\n+    prune_unused_types_walk (c);\n+}\n+\n+\n+/* Remove from the tree DIE any dies that aren't marked.  */\n+\n+static void\n+prune_unused_types_prune (die)\n+     dw_die_ref die;\n+{\n+  dw_die_ref c, p, n;\n+  if (!die->die_mark)\n+    abort();\n+\n+  p = NULL;\n+  for (c = die->die_child; c; c = n)\n+    {\n+      n = c->die_sib;\n+      if (c->die_mark)\n+\t{\n+\t  prune_unused_types_prune (c);\n+\t  p = c;\n+\t}\n+      else\n+\t{\n+\t  if (p)\n+\t    p->die_sib = n;\n+\t  else\n+\t    die->die_child = n;\n+\t  free_die (c);\n+\t}\n+    }\n+}\n+\n+\n+/* Remove dies representing declarations that we never use.  */\n+\n+static void\n+prune_unused_types ()\n+{\n+  unsigned int i;\n+  limbo_die_node *node;\n+\n+  /* Clear all the marks.  */\n+  prune_unmark_dies (comp_unit_die);\n+  for (node = limbo_die_list; node; node = node->next)\n+    prune_unmark_dies (node->die);\n+\n+  /* Set the mark on nodes that are actually used.  */\n+  prune_unused_types_walk (comp_unit_die);\n+  for (node = limbo_die_list; node; node = node->next)\n+    prune_unused_types_walk (node->die);\n+\n+  /* Also set the mark on nodes referenced from the\n+     pubname_table or arange_table.  */\n+  for (i=0; i < pubname_table_in_use; i++)\n+    {\n+      prune_unused_types_mark (pubname_table[i].die, 1);\n+    }\n+  for (i=0; i < arange_table_in_use; i++)\n+    {\n+      prune_unused_types_mark (arange_table[i], 1);\n+    }\n+\n+  /* Get rid of nodes that aren't marked.  */\n+  prune_unused_types_prune (comp_unit_die);\n+  for (node = limbo_die_list; node; node = node->next)\n+    prune_unused_types_prune (node->die);\n+\n+  /* Leave the marks clear.  */\n+  prune_unmark_dies (comp_unit_die);\n+  for (node = limbo_die_list; node; node = node->next)\n+    prune_unmark_dies (node->die);\n+}\n+\n /* Output stuff that dwarf requires at the end of every file,\n    and generate the DWARF-2 debugging info.  */\n \n@@ -12740,6 +12980,9 @@ dwarf2out_finish (input_filename)\n   if (flag_eliminate_dwarf2_dups)\n     break_out_includes (comp_unit_die);\n \n+  if (flag_eliminate_unused_debug_types)\n+    prune_unused_types ();\n+\n   /* Traverse the DIE's and add add sibling attributes to those DIE's\n      that have children.  */\n   add_sibling_attributes (comp_unit_die);"}, {"sha": "032edb6d941261b536070a76a9b7d3e475f62654", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c68f614dcd037a892768ace3481d45d8280436/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c68f614dcd037a892768ace3481d45d8280436/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=73c68f614dcd037a892768ace3481d45d8280436", "patch": "@@ -641,6 +641,10 @@ extern int flag_gcse_sm;\n \n extern int flag_eliminate_dwarf2_dups;\n \n+/* Nonzero means we should do unused type elimination.  */\n+\n+extern int flag_eliminate_unused_debug_types;\n+\n /* Nonzero means to collect statistics which might be expensive\n    and to print them when we are done.  */\n extern int flag_detailed_statistics;"}, {"sha": "7730a39aacff3919c4e54b96001cd52568665601", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c68f614dcd037a892768ace3481d45d8280436/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c68f614dcd037a892768ace3481d45d8280436/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=73c68f614dcd037a892768ace3481d45d8280436", "patch": "@@ -378,6 +378,10 @@ tree current_function_func_begin_label;\n \n int flag_eliminate_dwarf2_dups = 0;\n \n+/* Nonzero if doing unused type elimination.  */\n+\n+int flag_eliminate_unused_debug_types = 0;\n+\n /* Nonzero if generating code to do profiling.  */\n \n int profile_flag = 0;\n@@ -999,6 +1003,8 @@ static const lang_independent_options f_options[] =\n {\n   {\"eliminate-dwarf2-dups\", &flag_eliminate_dwarf2_dups, 1,\n    N_(\"Perform DWARF2 duplicate elimination\") },\n+  {\"eliminate-unused-debug-types\", &flag_eliminate_unused_debug_types, 1,\n+   N_(\"Perform unused type elimination in debug info\") },\n   {\"float-store\", &flag_float_store, 1,\n    N_(\"Do not store floats in registers\") },\n   {\"defer-pop\", &flag_defer_pop, 1,"}]}