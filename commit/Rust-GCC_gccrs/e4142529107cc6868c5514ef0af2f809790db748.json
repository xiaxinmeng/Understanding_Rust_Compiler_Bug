{"sha": "e4142529107cc6868c5514ef0af2f809790db748", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQxNDI1MjkxMDdjYzY4NjhjNTUxNGVmMGFmMmY4MDk3OTBkYjc0OA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2015-09-17T03:40:18Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2015-09-17T03:40:18Z"}, "message": "re PR tree-optimization/66388 (Test gcc.target/i386/pr49781-1.c failed because of recent scev overflow patches.)\n\n\n\tPR tree-optimization/66388\n\t* tree-ssa-loop-ivopts.c (struct iv, iv_cand, ivopts_data): New\n\tfields.\n\t(dump_iv): Dump no_overflow information.\n\t(alloc_iv): Initialize new field for struct iv.\n\t(mark_bivs): Count number of no_overflow bivs.\n\t(find_deriving_biv_for_expr, record_biv_for_address_use): New\n\tfunctions.\n\t(idx_find_step): Call new functions above.\n\t(add_candidate_1, add_candidate): New paramter.\n\t(add_iv_candidate_for_biv): Add sizetype cand for BIV.\n\t(get_computation_aff): Simplify convertion of cand for BIV.\n\t(get_computation_cost_at): Step cand's base if necessary.\n\nFrom-SVN: r227844", "tree": {"sha": "35de94bb740404aa91c3a5be13bf446c6d719254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35de94bb740404aa91c3a5be13bf446c6d719254"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4142529107cc6868c5514ef0af2f809790db748", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4142529107cc6868c5514ef0af2f809790db748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4142529107cc6868c5514ef0af2f809790db748", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4142529107cc6868c5514ef0af2f809790db748/comments", "author": null, "committer": null, "parents": [{"sha": "f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a"}], "stats": {"total": 235, "additions": 230, "deletions": 5}, "files": [{"sha": "b4d8efaf74fad51ce6d9c17f7062d415b1df9be9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4142529107cc6868c5514ef0af2f809790db748/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4142529107cc6868c5514ef0af2f809790db748/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4142529107cc6868c5514ef0af2f809790db748", "patch": "@@ -1,3 +1,19 @@\n+2015-09-17  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/66388\n+\t* tree-ssa-loop-ivopts.c (struct iv, iv_cand, ivopts_data): New\n+\tfields.\n+\t(dump_iv): Dump no_overflow information.\n+\t(alloc_iv): Initialize new field for struct iv.\n+\t(mark_bivs): Count number of no_overflow bivs.\n+\t(find_deriving_biv_for_expr, record_biv_for_address_use): New\n+\tfunctions.\n+\t(idx_find_step): Call new functions above.\n+\t(add_candidate_1, add_candidate): New paramter.\n+\t(add_iv_candidate_for_biv): Add sizetype cand for BIV.\n+\t(get_computation_aff): Simplify convertion of cand for BIV.\n+\t(get_computation_cost_at): Step cand's base if necessary.\n+\n 2015-09-17  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-niter.c (tree_simplify_using_condition_1): New"}, {"sha": "b62a7d0cf60e571d29539350e87f74b0eea53932", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 214, "deletions": 5, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4142529107cc6868c5514ef0af2f809790db748/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4142529107cc6868c5514ef0af2f809790db748/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=e4142529107cc6868c5514ef0af2f809790db748", "patch": "@@ -147,6 +147,8 @@ struct iv\n   bool biv_p;\t\t/* Is it a biv?  */\n   bool have_use_for;\t/* Do we already have a use for it?  */\n   bool no_overflow;\t/* True if the iv doesn't overflow.  */\n+  bool have_address_use;/* For biv, indicate if it's used in any address\n+\t\t\t   type use.  */\n };\n \n /* Per-ssa version information (induction variable descriptions, etc.).  */\n@@ -251,6 +253,8 @@ struct iv_cand\n \t\t\t      where it is incremented.  */\n   bitmap depends_on;\t/* The list of invariants that are used in step of the\n \t\t\t   biv.  */\n+  struct iv *orig_iv;\t/* The original iv if this cand is added from biv with\n+\t\t\t   smaller type.  */\n };\n \n /* Loop invariant expression hashtable entry.  */\n@@ -336,6 +340,9 @@ struct ivopts_data\n   /* The maximum invariant id.  */\n   unsigned max_inv_id;\n \n+  /* Number of no_overflow BIVs which are not used in memory address.  */\n+  unsigned bivs_not_used_in_addr;\n+\n   /* Obstack for iv structure.  */\n   struct obstack iv_obstack;\n \n@@ -529,6 +536,9 @@ dump_iv (FILE *file, struct iv *iv, bool dump_name)\n \n   if (iv->biv_p)\n     fprintf (file, \"  is a biv\\n\");\n+\n+  if (iv->no_overflow)\n+    fprintf (file, \"  iv doesn't overflow wrto loop niter\\n\");\n }\n \n /* Dumps information about the USE to FILE.  */\n@@ -1013,6 +1023,7 @@ alloc_iv (struct ivopts_data *data, tree base, tree step,\n   iv->use_id = 0;\n   iv->ssa_name = NULL_TREE;\n   iv->no_overflow = no_overflow;\n+  iv->have_address_use = false;\n \n   return iv;\n }\n@@ -1155,6 +1166,7 @@ mark_bivs (struct ivopts_data *data)\n   basic_block incr_bb;\n   gphi_iterator psi;\n \n+  data->bivs_not_used_in_addr = 0;\n   for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))\n     {\n       phi = psi.phi ();\n@@ -1183,6 +1195,10 @@ mark_bivs (struct ivopts_data *data)\n \n       iv->biv_p = true;\n       incr_iv->biv_p = true;\n+      if (iv->no_overflow)\n+\tdata->bivs_not_used_in_addr++;\n+      if (incr_iv->no_overflow)\n+\tdata->bivs_not_used_in_addr++;\n     }\n }\n \n@@ -1621,6 +1637,144 @@ expr_invariant_in_loop_p (struct loop *loop, tree expr)\n   return true;\n }\n \n+/* Given expression EXPR which computes inductive values with respect\n+   to loop recorded in DATA, this function returns biv from which EXPR\n+   is derived by tracing definition chains of ssa variables in EXPR.  */\n+\n+static struct iv*\n+find_deriving_biv_for_expr (struct ivopts_data *data, tree expr)\n+{\n+  struct iv *iv;\n+  unsigned i, n;\n+  tree e2, e1;\n+  enum tree_code code;\n+  gimple stmt;\n+\n+  if (expr == NULL_TREE)\n+    return NULL;\n+\n+  if (is_gimple_min_invariant (expr))\n+    return NULL;\n+\n+  code = TREE_CODE (expr);\n+  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n+    {\n+      n = TREE_OPERAND_LENGTH (expr);\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  iv = find_deriving_biv_for_expr (data, TREE_OPERAND (expr, i));\n+\t  if (iv)\n+\t    return iv;\n+\t}\n+    }\n+\n+  /* Stop if it's not ssa name.  */\n+  if (code != SSA_NAME)\n+    return NULL;\n+\n+  iv = get_iv (data, expr);\n+  if (!iv || integer_zerop (iv->step))\n+    return NULL;\n+  else if (iv->biv_p)\n+    return iv;\n+\n+  stmt = SSA_NAME_DEF_STMT (expr);\n+  if (gphi *phi = dyn_cast <gphi *> (stmt))\n+    {\n+      ssa_op_iter iter;\n+      use_operand_p use_p;\n+\n+      if (virtual_operand_p (gimple_phi_result (phi)))\n+\treturn NULL;\n+\n+      FOR_EACH_PHI_ARG (use_p, phi, iter, SSA_OP_USE)\n+\t{\n+\t  tree use = USE_FROM_PTR (use_p);\n+\t  iv = find_deriving_biv_for_expr (data, use);\n+\t  if (iv)\n+\t    return iv;\n+\t}\n+      return NULL;\n+    }\n+  if (gimple_code (stmt) != GIMPLE_ASSIGN)\n+    return NULL;\n+\n+  e1 = gimple_assign_rhs1 (stmt);\n+  code = gimple_assign_rhs_code (stmt);\n+  if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS)\n+    return find_deriving_biv_for_expr (data, e1);\n+\n+  switch (code)\n+    {\n+    case MULT_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n+      /* Increments, decrements and multiplications by a constant\n+\t are simple.  */\n+      e2 = gimple_assign_rhs2 (stmt);\n+      iv = find_deriving_biv_for_expr (data, e2);\n+      if (iv)\n+\treturn iv;\n+\n+      /* Fallthru.  */\n+    CASE_CONVERT:\n+      /* Casts are simple.  */\n+      return find_deriving_biv_for_expr (data, e1);\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Record BIV, its predecessor and successor that they are used in\n+   address type uses.  */\n+\n+static void\n+record_biv_for_address_use (struct ivopts_data *data, struct iv *biv)\n+{\n+  unsigned i;\n+  tree type, base_1, base_2;\n+  bitmap_iterator bi;\n+\n+  if (!biv || !biv->biv_p || integer_zerop (biv->step)\n+      || biv->have_address_use || !biv->no_overflow)\n+    return;\n+\n+  type = TREE_TYPE (biv->base);\n+  if (!INTEGRAL_TYPE_P (type))\n+    return;\n+\n+  biv->have_address_use = true;\n+  data->bivs_not_used_in_addr--;\n+  base_1 = fold_build2 (PLUS_EXPR, type, biv->base, biv->step);\n+  EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)\n+    {\n+      struct iv *iv = ver_info (data, i)->iv;\n+\n+      if (!iv || !iv->biv_p || integer_zerop (iv->step)\n+\t  || iv->have_address_use || !iv->no_overflow)\n+\tcontinue;\n+\n+      if (type != TREE_TYPE (iv->base)\n+\t  || !INTEGRAL_TYPE_P (TREE_TYPE (iv->base)))\n+\tcontinue;\n+\n+      if (!operand_equal_p (biv->step, iv->step, 0))\n+\tcontinue;\n+\n+      base_2 = fold_build2 (PLUS_EXPR, type, iv->base, iv->step);\n+      if (operand_equal_p (base_1, iv->base, 0)\n+\t  || operand_equal_p (base_2, biv->base, 0))\n+\t{\n+\t  iv->have_address_use = true;\n+\t  data->bivs_not_used_in_addr--;\n+\t}\n+    }\n+}\n+\n /* Cumulates the steps of indices into DATA and replaces their values with the\n    initial ones.  Returns false when the value of the index cannot be determined.\n    Callback for for_each_index.  */\n@@ -1711,6 +1865,13 @@ idx_find_step (tree base, tree *idx, void *data)\n   step = fold_build2 (MULT_EXPR, sizetype, step, iv_step);\n   dta->step = fold_build2 (PLUS_EXPR, sizetype, dta->step, step);\n \n+  if (dta->ivopts_data->bivs_not_used_in_addr)\n+    {\n+      if (!iv->biv_p)\n+\tiv = find_deriving_biv_for_expr (dta->ivopts_data, iv->ssa_name);\n+\n+      record_biv_for_address_use (dta->ivopts_data, iv);\n+    }\n   return true;\n }\n \n@@ -2603,7 +2764,8 @@ find_depends (tree *expr_p, int *ws ATTRIBUTE_UNUSED, void *data)\n static struct iv_cand *\n add_candidate_1 (struct ivopts_data *data,\n \t\t tree base, tree step, bool important, enum iv_position pos,\n-\t\t struct iv_use *use, gimple incremented_at)\n+\t\t struct iv_use *use, gimple incremented_at,\n+\t\t struct iv *orig_iv = NULL)\n {\n   unsigned i;\n   struct iv_cand *cand = NULL;\n@@ -2685,6 +2847,7 @@ add_candidate_1 (struct ivopts_data *data,\n       else\n \tcand->ainc_use = NULL;\n \n+      cand->orig_iv = orig_iv;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tdump_cand (dump_file, cand);\n     }\n@@ -2793,15 +2956,17 @@ add_autoinc_candidates (struct ivopts_data *data, tree base, tree step,\n \n static void\n add_candidate (struct ivopts_data *data,\n-\t       tree base, tree step, bool important, struct iv_use *use)\n+\t       tree base, tree step, bool important, struct iv_use *use,\n+\t       struct iv *orig_iv = NULL)\n {\n   gcc_assert (use == NULL || use->sub_id == 0);\n \n   if (ip_normal_pos (data->current_loop))\n-    add_candidate_1 (data, base, step, important, IP_NORMAL, use, NULL);\n+    add_candidate_1 (data, base, step, important,\n+\t\t     IP_NORMAL, use, NULL, orig_iv);\n   if (ip_end_pos (data->current_loop)\n       && allow_ip_end_pos_p (data->current_loop))\n-    add_candidate_1 (data, base, step, important, IP_END, use, NULL);\n+    add_candidate_1 (data, base, step, important, IP_END, use, NULL, orig_iv);\n }\n \n /* Adds standard iv candidates.  */\n@@ -2836,7 +3001,22 @@ add_iv_candidate_for_biv (struct ivopts_data *data, struct iv *iv)\n   tree def;\n   struct iv_cand *cand;\n \n-  add_candidate (data, iv->base, iv->step, true, NULL);\n+  /* Check if this biv is used in address type use.  */\n+  if (iv->no_overflow  && iv->have_address_use\n+      && INTEGRAL_TYPE_P (TREE_TYPE (iv->base))\n+      && TYPE_PRECISION (TREE_TYPE (iv->base)) < TYPE_PRECISION (sizetype))\n+    {\n+      tree base = fold_convert (sizetype, iv->base);\n+      tree step = fold_convert (sizetype, iv->step);\n+\n+      /* Add iv cand of same precision as index part in TARGET_MEM_REF.  */\n+      add_candidate (data, base, step, true, NULL, iv);\n+      /* Add iv cand of the original type only if it has nonlinear use.  */\n+      if (iv->have_use_for)\n+\tadd_candidate (data, iv->base, iv->step, true, NULL);\n+    }\n+  else\n+    add_candidate (data, iv->base, iv->step, true, NULL);\n \n   /* The same, but with initial value zero.  */\n   if (POINTER_TYPE_P (TREE_TYPE (iv->base)))\n@@ -3358,6 +3538,28 @@ get_computation_aff (struct loop *loop,\n   /* If the conversion is not noop, perform it.  */\n   if (TYPE_PRECISION (utype) < TYPE_PRECISION (ctype))\n     {\n+      if (cand->orig_iv != NULL && CONVERT_EXPR_P (cbase)\n+\t  && (CONVERT_EXPR_P (cstep) || TREE_CODE (cstep) == INTEGER_CST))\n+\t{\n+\t  tree inner_base, inner_step, inner_type;\n+\t  inner_base = TREE_OPERAND (cbase, 0);\n+\t  if (CONVERT_EXPR_P (cstep))\n+\t    inner_step = TREE_OPERAND (cstep, 0);\n+\t  else\n+\t    inner_step = cstep;\n+\n+\t  inner_type = TREE_TYPE (inner_base);\n+\t  /* If candidate is added from a biv whose type is smaller than\n+\t     ctype, we know both candidate and the biv won't overflow.\n+\t     In this case, it's safe to skip the convertion in candidate.\n+\t     As an example, (unsigned short)((unsigned long)A) equals to\n+\t     (unsigned short)A, if A has a type no larger than short.  */\n+\t  if (TYPE_PRECISION (inner_type) <= TYPE_PRECISION (uutype))\n+\t    {\n+\t      cbase = inner_base;\n+\t      cstep = inner_step;\n+\t    }\n+\t}\n       cstep = fold_convert (uutype, cstep);\n       cbase = fold_convert (uutype, cbase);\n       var = fold_convert (uutype, var);\n@@ -4526,6 +4728,13 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t(ratio, mem_mode,\n \t\t\tTYPE_ADDR_SPACE (TREE_TYPE (utype))))\n     {\n+      if (cstepi == 0 && stmt_is_after_inc)\n+\t{\n+\t  if (POINTER_TYPE_P (ctype))\n+\t    cbase = fold_build2 (POINTER_PLUS_EXPR, ctype, cbase, cstep);\n+\t  else\n+\t    cbase = fold_build2 (PLUS_EXPR, ctype, cbase, cstep);\n+\t}\n       cbase\n \t= fold_build2 (MULT_EXPR, ctype, cbase, build_int_cst (ctype, ratio));\n       cost = difference_cost (data,"}]}