{"sha": "82a794419a00ea98b68d69b64363ae6746710de9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJhNzk0NDE5YTAwZWE5OGI2OGQ2OWI2NDM2M2FlNjc0NjcxMGRlOQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-05-08T15:39:52Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-06T14:46:54Z"}, "message": "[Ada] Tbuild cleanup\n\ngcc/ada/\n\n\t* tbuild.adb (Convert_To): Add assert, along with a comment.\n\t(Make_DT_Access): Remove this function, which is not used.  It\n\twas incorrect anyway (the call to New_Occurrence_Of should not\n\tbe there).\n\t(Unchecked_Convert_To): Add assert.  The previous version's test\n\tfor unchecked conversion to the same type was redundant and\n\tcould never be true, because the previous 'if' already checked\n\tfor ANY expression of the same type. Remove that, and replace\n\twith a test for unchecked conversion to a related type.\n\tOtherwise, we somethings get things like\n\t\"finalize(some_type!(some_type!(x)))\" in the generated code,\n\twhere x is already of type some_type, but we're converting it to\n\tthe private type and then to the full type or vice versa (so the\n\ttypes aren't equal, so the previous 'if' doesn't catch it).\n\tAvoid updating the Parent. This is not necessary; the Parent\n\twill be updated if/when the node is attached to the tree.\n\t* tbuild.ads: Fix comments. No need to say \"this is safe\" when\n\twe just explained that a few lines earlier.  Remove\n\tMake_DT_Access.\n\t* sinfo.ads: Add comments.\n\t* exp_ch7.adb (Make_Finalize_Address_Stmts): Minor comment fix.\n\t* gen_il-gen.adb, gen_il-gen.ads, gen_il-gen-gen_nodes.adb,\n\tgen_il-internals.ads: Implement a feature where you can put:\n\tNmake_Assert => \"expr\" where expr is a boolean expression in a\n\tcall to Create_Concrete_Node_Type. It is added in a pragma\n\tAssert in the Nmake.Make_... function for that type.", "tree": {"sha": "a216a476635457a50b68eac80396d690071b19a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a216a476635457a50b68eac80396d690071b19a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82a794419a00ea98b68d69b64363ae6746710de9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82a794419a00ea98b68d69b64363ae6746710de9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82a794419a00ea98b68d69b64363ae6746710de9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82a794419a00ea98b68d69b64363ae6746710de9/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06a5fb60eb53ef297454f58db61d3374d538f515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06a5fb60eb53ef297454f58db61d3374d538f515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06a5fb60eb53ef297454f58db61d3374d538f515"}], "stats": {"total": 169, "additions": 79, "deletions": 90}, "files": [{"sha": "b0374a39d4c36f03b3805484e24cabf75bac80eb", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=82a794419a00ea98b68d69b64363ae6746710de9", "patch": "@@ -9344,7 +9344,7 @@ package body Exp_Ch7 is\n             Dope_Id : Entity_Id;\n \n          begin\n-            --  Ensure that Ptr_Typ a thin pointer, generate:\n+            --  Ensure that Ptr_Typ is a thin pointer; generate:\n             --    for Ptr_Typ'Size use System.Address'Size;\n \n             Append_To (Decls,"}, {"sha": "2427a1e8e891f2d096050faa797b3e01cd4968e0", "filename": "gcc/ada/gen_il-gen-gen_nodes.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb?ref=82a794419a00ea98b68d69b64363ae6746710de9", "patch": "@@ -31,7 +31,8 @@ procedure Gen_IL.Gen.Gen_Nodes is\n       renames Create_Abstract_Node_Type;\n    procedure Cc -- Short for \"ConCrete\"\n      (T : Concrete_Node; Parent : Abstract_Type;\n-      Fields : Field_Sequence := No_Fields)\n+      Fields : Field_Sequence := No_Fields;\n+      Nmake_Assert : String := \"\")\n       renames Create_Concrete_Node_Type;\n \n    function Sy -- Short for \"Syntactic\"\n@@ -562,7 +563,12 @@ begin -- Gen_IL.Gen.Gen_Nodes\n        (Sy (Subtype_Mark, Node_Id, Default_Empty),\n         Sy (Expression, Node_Id, Default_Empty),\n         Sm (Kill_Range_Check, Flag),\n-        Sm (No_Truncation, Flag)));\n+        Sm (No_Truncation, Flag)),\n+       Nmake_Assert => \"True or else Nkind (Expression) /= N_Unchecked_Type_Conversion\");\n+--       Nmake_Assert => \"Nkind (Expression) /= N_Unchecked_Type_Conversion\");\n+   --  Assert that we don't have unchecked conversions of unchecked\n+   --  conversions; if Expression might be an unchecked conversion,\n+   --  then Tbuild.Unchecked_Convert_To should be used.\n \n    Cc (N_Subtype_Indication, N_Has_Etype,\n        (Sy (Subtype_Mark, Node_Id, Default_Empty),"}, {"sha": "94f7c9cb2d8d7420b73a8280d6ced69904e9a373", "filename": "gcc/ada/gen_il-gen.adb", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Fgen_il-gen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Fgen_il-gen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen.adb?ref=82a794419a00ea98b68d69b64363ae6746710de9", "patch": "@@ -47,9 +47,10 @@ package body Gen_IL.Gen is\n    All_Entities : constant Type_Vector := To_Vector (Entity_Kind, Length => 1);\n \n    procedure Create_Type\n-     (T      : Node_Or_Entity_Type;\n-      Parent : Opt_Abstract_Type;\n-      Fields : Field_Sequence);\n+     (T            : Node_Or_Entity_Type;\n+      Parent       : Opt_Abstract_Type;\n+      Fields       : Field_Sequence;\n+      Nmake_Assert : String);\n    --  Called by the Create_..._Type procedures exported by this package to\n    --  create an entry in the Types_Table.\n \n@@ -107,9 +108,10 @@ package body Gen_IL.Gen is\n    -----------------\n \n    procedure Create_Type\n-     (T      : Node_Or_Entity_Type;\n-      Parent : Opt_Abstract_Type;\n-      Fields : Field_Sequence)\n+     (T            : Node_Or_Entity_Type;\n+      Parent       : Opt_Abstract_Type;\n+      Fields       : Field_Sequence;\n+      Nmake_Assert : String)\n    is\n    begin\n       Check_Type (T);\n@@ -132,7 +134,8 @@ package body Gen_IL.Gen is\n         new Type_Info'\n           (Is_Union => False, Parent => Parent,\n            Children | Concrete_Descendants => Type_Vectors.Empty_Vector,\n-           First | Last | Fields => <>); -- filled in later\n+           First | Last | Fields => <>, -- filled in later\n+           Nmake_Assert => new String'(Nmake_Assert));\n \n       if Parent /= No_Type then\n          Append (Type_Table (Parent).Children, T);\n@@ -215,7 +218,7 @@ package body Gen_IL.Gen is\n      (T      : Abstract_Node;\n       Fields : Field_Sequence := No_Fields) is\n    begin\n-      Create_Type (T, Parent => No_Type, Fields => Fields);\n+      Create_Type (T, Parent => No_Type, Fields => Fields, Nmake_Assert => \"\");\n    end Create_Root_Node_Type;\n \n    -------------------------------\n@@ -227,7 +230,7 @@ package body Gen_IL.Gen is\n       Fields : Field_Sequence := No_Fields)\n    is\n    begin\n-      Create_Type (T, Parent, Fields);\n+      Create_Type (T, Parent, Fields, Nmake_Assert => \"\");\n    end Create_Abstract_Node_Type;\n \n    -------------------------------\n@@ -236,10 +239,11 @@ package body Gen_IL.Gen is\n \n    procedure Create_Concrete_Node_Type\n      (T      : Concrete_Node; Parent : Abstract_Type;\n-      Fields : Field_Sequence := No_Fields)\n+      Fields : Field_Sequence := No_Fields;\n+      Nmake_Assert : String := \"\")\n    is\n    begin\n-      Create_Type (T, Parent, Fields);\n+      Create_Type (T, Parent, Fields, Nmake_Assert);\n    end Create_Concrete_Node_Type;\n \n    -----------------------------\n@@ -250,7 +254,7 @@ package body Gen_IL.Gen is\n      (T      : Abstract_Entity;\n       Fields : Field_Sequence := No_Fields) is\n    begin\n-      Create_Type (T, Parent => No_Type, Fields => Fields);\n+      Create_Type (T, Parent => No_Type, Fields => Fields, Nmake_Assert => \"\");\n    end Create_Root_Entity_Type;\n \n    ---------------------------------\n@@ -262,7 +266,7 @@ package body Gen_IL.Gen is\n       Fields : Field_Sequence := No_Fields)\n    is\n    begin\n-      Create_Type (T, Parent, Fields);\n+      Create_Type (T, Parent, Fields, Nmake_Assert => \"\");\n    end Create_Abstract_Entity_Type;\n \n    ---------------------------------\n@@ -274,7 +278,7 @@ package body Gen_IL.Gen is\n       Fields : Field_Sequence := No_Fields)\n    is\n    begin\n-      Create_Type (T, Parent, Fields);\n+      Create_Type (T, Parent, Fields, Nmake_Assert => \"\");\n    end Create_Concrete_Entity_Type;\n \n    ------------------\n@@ -352,7 +356,7 @@ package body Gen_IL.Gen is\n               Image (Field);\n          end if;\n \n-         if Pre /= Field_Table (Field).Pre.all then\n+         if Pre_Set /= Field_Table (Field).Pre_Set.all then\n             raise Illegal with\n               \"mismatched extra setter-only preconditions for \" &\n               Image (Field);\n@@ -2561,6 +2565,11 @@ package body Gen_IL.Gen is\n                   end;\n                end if;\n \n+               if Type_Table (T).Nmake_Assert.all /= \"\" then\n+                  Put (S, \"pragma Assert (\" &\n+                           Type_Table (T).Nmake_Assert.all & \");\" & LF);\n+               end if;\n+\n                Put (S, \"return N;\" & LF);\n                Decrease_Indent (S, 3);\n \n@@ -2628,6 +2637,7 @@ package body Gen_IL.Gen is\n          Increase_Indent (B, 3);\n \n          Put (B, \"--  This package is automatically generated.\" & LF & LF);\n+         Put (B, \"pragma Style_Checks (\"\"M200\"\");\" & LF);\n \n          Put_Make_Bodies (B, Node_Kind);\n "}, {"sha": "1d24ebf10928c4d909a700aadb16268af632203a", "filename": "gcc/ada/gen_il-gen.ads", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Fgen_il-gen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Fgen_il-gen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen.ads?ref=82a794419a00ea98b68d69b64363ae6746710de9", "patch": "@@ -102,9 +102,12 @@ package Gen_IL.Gen is\n \n    procedure Create_Concrete_Node_Type\n      (T : Concrete_Node; Parent : Abstract_Type;\n-      Fields : Field_Sequence := No_Fields);\n+      Fields : Field_Sequence := No_Fields;\n+      Nmake_Assert : String := \"\");\n    --  Create a concrete node type. Every node is an instance of a concrete\n-   --  node type.\n+   --  node type. Nmake_Assert is an assertion to put in the Make_... function\n+   --  in the generated Nmake package. It should be a String that represents a\n+   --  Boolean expression.\n \n    procedure Create_Root_Entity_Type\n      (T : Abstract_Entity;\n@@ -151,13 +154,14 @@ package Gen_IL.Gen is\n    --  only for syntactic fields. Flag fields of syntactic nodes always have a\n    --  default value, which is False unless specified as Default_True. Pre is\n    --  an additional precondition for the field getter and setter, in addition\n-   --  to the precondition that asserts that the type has that field. Pre_Get\n-   --  and Pre_Set are similar to Pre, but for the getter or setter only,\n-   --  respectively.\n+   --  to the precondition that asserts that the type has that field. It should\n+   --  be a String that represents a Boolean expression. Pre_Get and Pre_Set\n+   --  are similar to Pre, but for the getter or setter only, respectively.\n    --\n    --  If multiple calls to these occur for the same Field but different types,\n-   --  the Field_Type and Pre must match. Default_Value should match for\n-   --  syntactic fields. See the declaration of Type_Only_Enum for Type_Only.\n+   --  the Field_Type, Pre, Pre_Get, and Pre_Set must match. Default_Value\n+   --  should match for syntactic fields. See the declaration of Type_Only_Enum\n+   --  for Type_Only.\n    --\n    --  (The matching Default_Value requirement is a simplification from the\n    --  earlier hand-written version.)"}, {"sha": "b8911ec3c0afb7a632d76ff4e06e09dae853b16b", "filename": "gcc/ada/gen_il-internals.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Fgen_il-internals.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Fgen_il-internals.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-internals.ads?ref=82a794419a00ea98b68d69b64363ae6746710de9", "patch": "@@ -104,6 +104,8 @@ package Gen_IL.Internals is\n             --  includes two or more types.\n \n             Fields : Field_Vector;\n+\n+            Nmake_Assert : String_Access; -- only for concrete node types\n       end case;\n    end record;\n "}, {"sha": "f6c5e0dcc59f5048ca0d49b39d9738a4981832d3", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=82a794419a00ea98b68d69b64363ae6746710de9", "patch": "@@ -8420,8 +8420,11 @@ package Sinfo is\n       --  An unchecked type conversion node represents the semantic action\n       --  corresponding to a call to an instantiation of Unchecked_Conversion.\n       --  It is generated as a result of actual use of Unchecked_Conversion\n-      --  and also the expander generates unchecked type conversion nodes\n-      --  directly for expansion of complex semantic actions.\n+      --  and also by the expander.\n+\n+      --  Unchecked type conversion nodes should normally be created by calling\n+      --  Tbuild.Unchecked_Convert_To, rather than by directly calling\n+      --  Nmake.Make_Unchecked_Type_Conversion.\n \n       --  Note: an unchecked type conversion is a variable as far as the\n       --  semantics are concerned, which is convenient for the expander."}, {"sha": "e7186444365b74f99b8ff17b5b1d92daf30dc984", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 16, "deletions": 43, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=82a794419a00ea98b68d69b64363ae6746710de9", "patch": "@@ -29,14 +29,12 @@ with Csets;          use Csets;\n with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n-with Elists;         use Elists;\n with Lib;            use Lib;\n with Nlists;         use Nlists;\n with Nmake;          use Nmake;\n with Opt;            use Opt;\n with Restrict;       use Restrict;\n with Rident;         use Rident;\n-with Sem_Aux;        use Sem_Aux;\n with Sinfo.Utils;    use Sinfo.Utils;\n with Sem_Util;       use Sem_Util;\n with Snames;         use Snames;\n@@ -117,6 +115,7 @@ package body Tbuild is\n    ----------------\n \n    function Convert_To (Typ : Entity_Id; Expr : Node_Id) return Node_Id is\n+      pragma Assert (Is_Type (Typ));\n       Result : Node_Id;\n \n    begin\n@@ -185,32 +184,6 @@ package body Tbuild is\n       return N;\n    end Make_Byte_Aligned_Attribute_Reference;\n \n-   --------------------\n-   -- Make_DT_Access --\n-   --------------------\n-\n-   function Make_DT_Access\n-     (Loc : Source_Ptr;\n-      Rec : Node_Id;\n-      Typ : Entity_Id) return Node_Id\n-   is\n-      Full_Type : Entity_Id := Typ;\n-\n-   begin\n-      if Is_Private_Type (Typ) then\n-         Full_Type := Underlying_Type (Typ);\n-      end if;\n-\n-      return\n-        Unchecked_Convert_To (\n-          New_Occurrence_Of\n-            (Etype (Node (First_Elmt (Access_Disp_Table (Full_Type)))), Loc),\n-          Make_Selected_Component (Loc,\n-            Prefix => New_Copy (Rec),\n-            Selector_Name =>\n-              New_Occurrence_Of (First_Tag_Component (Full_Type), Loc)));\n-   end Make_DT_Access;\n-\n    ------------------------\n    -- Make_Float_Literal --\n    ------------------------\n@@ -906,26 +879,34 @@ package body Tbuild is\n      (Typ  : Entity_Id;\n       Expr : Node_Id) return Node_Id\n    is\n+      pragma Assert (Ekind (Typ) in E_Void | Type_Kind);\n+      --  We don't really want to allow E_Void here, but existing code passes\n+      --  it.\n+\n       Loc         : constant Source_Ptr := Sloc (Expr);\n       Result      : Node_Id;\n-      Expr_Parent : Node_Id;\n \n    begin\n       --  If the expression is already of the correct type, then nothing\n-      --  to do, except for relocating the node in case this is required.\n+      --  to do, except for relocating the node\n \n       if Present (Etype (Expr))\n-        and then (Base_Type (Etype (Expr)) = Typ\n-                   or else Etype (Expr) = Typ)\n+        and then (Base_Type (Etype (Expr)) = Typ or else Etype (Expr) = Typ)\n       then\n          return Relocate_Node (Expr);\n \n-      --  Case where the expression is itself an unchecked conversion to\n-      --  the same type, and we can thus eliminate the outer conversion.\n+      --  Case where the expression is already an unchecked conversion. We\n+      --  replace the type being converted to, to avoid creating an unchecked\n+      --  conversion of an unchecked conversion. Extra unchecked conversions\n+      --  make the .dg output less readable. We can't do this in cases\n+      --  involving bitfields, because the sizes might not match. The\n+      --  Is_Composite_Type checks avoid such cases.\n \n       elsif Nkind (Expr) = N_Unchecked_Type_Conversion\n-        and then Entity (Subtype_Mark (Expr)) = Typ\n+        and then Is_Composite_Type (Etype (Expr))\n+        and then Is_Composite_Type (Typ)\n       then\n+         Set_Subtype_Mark (Expr, New_Occurrence_Of (Typ, Loc));\n          Result := Relocate_Node (Expr);\n \n       elsif Nkind (Expr) = N_Null\n@@ -938,18 +919,10 @@ package body Tbuild is\n       --  All other cases\n \n       else\n-         --  Capture the parent of the expression before relocating it and\n-         --  creating the conversion, so the conversion's parent can be set\n-         --  to the original parent below.\n-\n-         Expr_Parent := Parent (Expr);\n-\n          Result :=\n            Make_Unchecked_Type_Conversion (Loc,\n              Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n              Expression   => Relocate_Node (Expr));\n-\n-         Set_Parent (Result, Expr_Parent);\n       end if;\n \n       Set_Etype (Result, Typ);"}, {"sha": "f2f9809eb7340474c100cc3371ea3c8b08f2f6c9", "filename": "gcc/ada/tbuild.ads", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Ftbuild.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a794419a00ea98b68d69b64363ae6746710de9/gcc%2Fada%2Ftbuild.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.ads?ref=82a794419a00ea98b68d69b64363ae6746710de9", "patch": "@@ -41,19 +41,16 @@ package Tbuild is\n    --  except that it will be analyzed and resolved with checks off.\n \n    function Convert_To (Typ : Entity_Id; Expr : Node_Id) return Node_Id;\n-   --  Returns an expression that represents the result of a checked convert\n-   --  of expression Exp to type T. If the base type of Exp is T, then no\n-   --  conversion is required, and Exp is returned unchanged. Otherwise an\n-   --  N_Type_Conversion node is constructed to convert the expression.\n-   --  If an N_Type_Conversion node is required, Relocate_Node is used on\n-   --  Exp. This means that it is safe to replace a node by a Convert_To\n-   --  of itself to some other type.\n+   --  Returns an expression that is a type conversion of expression Expr to\n+   --  type Typ. If the type of Expr is Typ, then no conversion is required.\n+   --  Otherwise an N_Type_Conversion node is constructed to convert the\n+   --  expression. Relocate_Node is applied to Expr, so that it is safe to\n+   --  replace a node by a Convert_To of itself to some other type.\n \n    procedure Convert_To_And_Rewrite (Typ : Entity_Id; Expr : Node_Id);\n    pragma Inline (Convert_To_And_Rewrite);\n    --  Like the function, except that there is an extra step of calling\n    --  Rewrite on the Expr node and replacing it with the converted result.\n-   --  As noted above, this is safe, because Relocate_Node is called.\n \n    procedure Discard_Node (N : Node_Or_Entity_Id);\n    pragma Inline (Discard_Node);\n@@ -78,11 +75,6 @@ package Tbuild is\n    --  Must_Be_Byte_Aligned is set in the attribute reference node. The\n    --  Attribute_Name must be Name_Address or Name_Unrestricted_Access.\n \n-   function Make_DT_Access\n-     (Loc : Source_Ptr; Rec : Node_Id; Typ : Entity_Id) return Node_Id;\n-   --  Create an access to the Dispatch Table by using the Tag field of a\n-   --  tagged record : Acc_Dt (Rec.tag).all\n-\n    function Make_Float_Literal\n      (Loc         : Source_Ptr;\n       Radix       : Uint;\n@@ -319,13 +311,12 @@ package Tbuild is\n    function New_Occurrence_Of\n      (Def_Id : Entity_Id;\n       Loc    : Source_Ptr) return Node_Id;\n-   --  New_Occurrence_Of creates an N_Identifier node which is an occurrence\n-   --  of the defining identifier which is passed as its argument. The Entity\n-   --  and Etype of the result are set from the given defining identifier as\n-   --  follows: Entity is simply a copy of Def_Id. Etype is a copy of Def_Id\n-   --  for types, and a copy of the Etype of Def_Id for other entities. Note\n-   --  that Is_Static_Expression is set if this call creates an occurrence of\n-   --  an enumeration literal.\n+   --  New_Occurrence_Of creates an N_Identifier node that is an occurrence of\n+   --  the defining identifier Def_Id. The Entity and Etype of the result are\n+   --  set from the given defining identifier as follows: Entity is a copy of\n+   --  Def_Id. Etype is a copy of Def_Id for types, and a copy of the Etype of\n+   --  Def_Id for other entities. Note that Is_Static_Expression is set if this\n+   --  call creates an occurrence of an enumeration literal.\n \n    function New_Suffixed_Name\n      (Related_Id : Name_Id;"}]}