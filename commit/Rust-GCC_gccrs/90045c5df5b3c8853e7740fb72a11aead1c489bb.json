{"sha": "90045c5df5b3c8853e7740fb72a11aead1c489bb", "node_id": "C_kwDOANBUbNoAKDkwMDQ1YzVkZjViM2M4ODUzZTc3NDBmYjcyYTExYWVhZDFjNDg5YmI", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2022-01-10T16:04:34Z"}, "committer": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gmail.com", "date": "2022-01-16T21:57:45Z"}, "message": "Fortran: allow IEEE_VALUE to correctly return signaling NaNs\n\nI moved the library implementation of IEEE_VALUE in libgfortran from\nFortran to C code, which gives us access to GCC's built-ins for NaN generation\n(both quiet and signalling). It will be perform better than the current\nFortran implementation.\n\nlibgfortran/ChangeLog:\n\n\tPR fortran/82207\n\t* mk-kinds-h.sh: Add values for TINY.\n\t* ieee/ieee_arithmetic.F90: Call C helper functions for\n\tIEEE_VALUE.\n\t* ieee/ieee_helper.c: New functions ieee_value_helper_N for each\n\tfloating-point type.\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/82207\n\t* gfortran.dg/ieee/ieee_10.f90: Do not create signaling NaNs.\n\t* gfortran.dg/ieee/signaling_2.f90: New test.\n\t* gfortran.dg/ieee/signaling_2_c.c: New file.", "tree": {"sha": "5a59d689ecb0d21bb9aa1cb3e3a1d2e479a5f07b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a59d689ecb0d21bb9aa1cb3e3a1d2e479a5f07b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90045c5df5b3c8853e7740fb72a11aead1c489bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90045c5df5b3c8853e7740fb72a11aead1c489bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90045c5df5b3c8853e7740fb72a11aead1c489bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90045c5df5b3c8853e7740fb72a11aead1c489bb/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bca1c431affee41ecadb7f29d8d65142a73e0ebf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bca1c431affee41ecadb7f29d8d65142a73e0ebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bca1c431affee41ecadb7f29d8d65142a73e0ebf"}], "stats": {"total": 455, "additions": 203, "deletions": 252}, "files": [{"sha": "a596504ae1e4a2b8f9cb93022a2d4c63fa403147", "filename": "gcc/testsuite/gfortran.dg/ieee/ieee_10.f90", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90045c5df5b3c8853e7740fb72a11aead1c489bb/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90045c5df5b3c8853e7740fb72a11aead1c489bb/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_10.f90?ref=90045c5df5b3c8853e7740fb72a11aead1c489bb", "patch": "@@ -12,8 +12,10 @@ program foo\n    real x\n    real(8) y\n \n-   x = ieee_value(x, ieee_signaling_nan)\n-   if (.not. ieee_is_nan(x)) stop 1\n+   ! At this point it is unclear what the behavior should be\n+   ! for -ffpe-trap=invalid with a signaling NaN\n+   !x = ieee_value(x, ieee_signaling_nan)\n+   !if (.not. ieee_is_nan(x)) stop 1\n    x = ieee_value(x, ieee_quiet_nan)\n    if (.not. ieee_is_nan(x)) stop 2\n \n@@ -22,8 +24,10 @@ program foo\n    x = ieee_value(x, ieee_negative_inf)\n    if (ieee_is_finite(x)) stop 4\n \n-   y = ieee_value(y, ieee_signaling_nan)\n-   if (.not. ieee_is_nan(y)) stop 5\n+   ! At this point it is unclear what the behavior should be\n+   ! for -ffpe-trap=invalid with a signaling NaN\n+   !y = ieee_value(y, ieee_signaling_nan)\n+   !if (.not. ieee_is_nan(y)) stop 5\n    y = ieee_value(y, ieee_quiet_nan)\n    if (.not. ieee_is_nan(y)) stop 6\n "}, {"sha": "e7e7a4a10f2349eb0c5a56ef3a5559062f8838ca", "filename": "gcc/testsuite/gfortran.dg/ieee/signaling_2.f90", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90045c5df5b3c8853e7740fb72a11aead1c489bb/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90045c5df5b3c8853e7740fb72a11aead1c489bb/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_2.f90?ref=90045c5df5b3c8853e7740fb72a11aead1c489bb", "patch": "@@ -0,0 +1,70 @@\n+! { dg-do run }\n+! { dg-require-effective-target issignaling } */\n+! { dg-additional-sources signaling_2_c.c }\n+! { dg-additional-options \"-w\" }\n+! the -w option is needed to make cc1 not report a warning for\n+! the -fintrinsic-modules-path option passed by ieee.exp\n+!\n+program test\n+  use, intrinsic :: iso_c_binding\n+  use, intrinsic :: ieee_arithmetic\n+  implicit none\n+\n+  interface\n+    integer(kind=c_int) function isnansf (x) bind(c)\n+      import :: c_float, c_int\n+      real(kind=c_float), value :: x\n+    end function\n+\n+    integer(kind=c_int) function isnans (x) bind(c)\n+      import :: c_double, c_int\n+      real(kind=c_double), value :: x\n+    end function\n+\n+    integer(kind=c_int) function isnansl (x) bind(c)\n+      import :: c_long_double, c_int\n+      real(kind=c_long_double), value :: x\n+    end function\n+  end interface\n+\n+  real(kind=c_float) :: x\n+  real(kind=c_double) :: y\n+  real(kind=c_long_double) :: z\n+\n+  if (ieee_support_nan(x)) then\n+    x = ieee_value(x, ieee_signaling_nan)\n+    if (ieee_class(x) /= ieee_signaling_nan) stop 100\n+    if (.not. ieee_is_nan(x)) stop 101\n+    if (isnansf(x) /= 1) stop 102\n+\n+    x = ieee_value(x, ieee_quiet_nan)\n+    if (ieee_class(x) /= ieee_quiet_nan) stop 103\n+    if (.not. ieee_is_nan(x)) stop 104\n+    if (isnansf(x) /= 0) stop 105\n+  end if\n+\n+  if (ieee_support_nan(y)) then\n+    y = ieee_value(y, ieee_signaling_nan)\n+    if (ieee_class(y) /= ieee_signaling_nan) stop 100\n+    if (.not. ieee_is_nan(y)) stop 101\n+    if (isnans(y) /= 1) stop 102\n+\n+    y = ieee_value(y, ieee_quiet_nan)\n+    if (ieee_class(y) /= ieee_quiet_nan) stop 103\n+    if (.not. ieee_is_nan(y)) stop 104\n+    if (isnans(y) /= 0) stop 105\n+  end if\n+\n+  if (ieee_support_nan(z)) then\n+    z = ieee_value(z, ieee_signaling_nan)\n+    if (ieee_class(z) /= ieee_signaling_nan) stop 100\n+    if (.not. ieee_is_nan(z)) stop 101\n+    if (isnansl(z) /= 1) stop 102\n+\n+    z = ieee_value(z, ieee_quiet_nan)\n+    if (ieee_class(z) /= ieee_quiet_nan) stop 103\n+    if (.not. ieee_is_nan(z)) stop 104\n+    if (isnansl(z) /= 0) stop 105\n+  end if\n+\n+end program test"}, {"sha": "ea7fc0467bd7d7132aa50a0437b7606227d63c73", "filename": "gcc/testsuite/gfortran.dg/ieee/signaling_2_c.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90045c5df5b3c8853e7740fb72a11aead1c489bb/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_2_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90045c5df5b3c8853e7740fb72a11aead1c489bb/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_2_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_2_c.c?ref=90045c5df5b3c8853e7740fb72a11aead1c489bb", "patch": "@@ -0,0 +1,8 @@\n+#define _GNU_SOURCE\n+#include <math.h>\n+#include <float.h>\n+\n+int isnansf (float x)       { return issignaling (x) ? 1 : 0; }\n+int isnans  (double x)      { return issignaling (x) ? 1 : 0; }\n+int isnansl (long double x) { return issignaling (x) ? 1 : 0; }\n+"}, {"sha": "c8ef3e2faeb184bbe733669a9e6480acfc208663", "filename": "libgfortran/ieee/ieee_arithmetic.F90", "status": "modified", "additions": 36, "deletions": 248, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90045c5df5b3c8853e7740fb72a11aead1c489bb/libgfortran%2Fieee%2Fieee_arithmetic.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90045c5df5b3c8853e7740fb72a11aead1c489bb/libgfortran%2Fieee%2Fieee_arithmetic.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_arithmetic.F90?ref=90045c5df5b3c8853e7740fb72a11aead1c489bb", "patch": "@@ -915,275 +915,63 @@ elemental function IEEE_CLASS_16 (X) result(res)\n   ! IEEE_VALUE\n \n   elemental real(kind=4) function IEEE_VALUE_4(X, CLASS) result(res)\n-\n     real(kind=4), intent(in) :: X\n     type(IEEE_CLASS_TYPE), intent(in) :: CLASS\n-    logical flag\n-\n-    select case (CLASS%hidden)\n-      case (1)     ! IEEE_SIGNALING_NAN\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_get_halting_mode(ieee_invalid, flag)\n-           call ieee_set_halting_mode(ieee_invalid, .false.)\n-        end if\n-        res = -1\n-        res = sqrt(res)\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_set_halting_mode(ieee_invalid, flag)\n-        end if\n-      case (2)     ! IEEE_QUIET_NAN\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_get_halting_mode(ieee_invalid, flag)\n-           call ieee_set_halting_mode(ieee_invalid, .false.)\n-        end if\n-        res = -1\n-        res = sqrt(res)\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_set_halting_mode(ieee_invalid, flag)\n-        end if\n-      case (3)     ! IEEE_NEGATIVE_INF\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_get_halting_mode(ieee_overflow, flag)\n-           call ieee_set_halting_mode(ieee_overflow, .false.)\n-        end if\n-        res = huge(res)\n-        res = (-res) * res\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_set_halting_mode(ieee_overflow, flag)\n-        end if\n-      case (4)     ! IEEE_NEGATIVE_NORMAL\n-        res = -42\n-      case (5)     ! IEEE_NEGATIVE_DENORMAL\n-        res = -tiny(res)\n-        res = res / 2\n-      case (6)     ! IEEE_NEGATIVE_ZERO\n-        res = 0\n-        res = -res\n-      case (7)     ! IEEE_POSITIVE_ZERO\n-        res = 0\n-      case (8)     ! IEEE_POSITIVE_DENORMAL\n-        res = tiny(res)\n-        res = res / 2\n-      case (9)     ! IEEE_POSITIVE_NORMAL\n-        res = 42\n-      case (10)    ! IEEE_POSITIVE_INF\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_get_halting_mode(ieee_overflow, flag)\n-           call ieee_set_halting_mode(ieee_overflow, .false.)\n-        end if\n-        res = huge(res)\n-        res = res * res\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_set_halting_mode(ieee_overflow, flag)\n-        end if\n-      case default ! IEEE_OTHER_VALUE, should not happen\n-        res = 0\n-     end select\n+\n+    interface\n+      pure real(kind=4) function _gfortrani_ieee_value_helper_4(x)\n+        use ISO_C_BINDING, only: C_INT\n+        integer(kind=C_INT), value :: x\n+      end function\n+    end interface\n+\n+    res = _gfortrani_ieee_value_helper_4(CLASS%hidden)\n   end function\n \n   elemental real(kind=8) function IEEE_VALUE_8(X, CLASS) result(res)\n-\n     real(kind=8), intent(in) :: X\n     type(IEEE_CLASS_TYPE), intent(in) :: CLASS\n-    logical flag\n-\n-    select case (CLASS%hidden)\n-      case (1)     ! IEEE_SIGNALING_NAN\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_get_halting_mode(ieee_invalid, flag)\n-           call ieee_set_halting_mode(ieee_invalid, .false.)\n-        end if\n-        res = -1\n-        res = sqrt(res)\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_set_halting_mode(ieee_invalid, flag)\n-        end if\n-      case (2)     ! IEEE_QUIET_NAN\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_get_halting_mode(ieee_invalid, flag)\n-           call ieee_set_halting_mode(ieee_invalid, .false.)\n-        end if\n-        res = -1\n-        res = sqrt(res)\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_set_halting_mode(ieee_invalid, flag)\n-        end if\n-      case (3)     ! IEEE_NEGATIVE_INF\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_get_halting_mode(ieee_overflow, flag)\n-           call ieee_set_halting_mode(ieee_overflow, .false.)\n-        end if\n-        res = huge(res)\n-        res = (-res) * res\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_set_halting_mode(ieee_overflow, flag)\n-        end if\n-      case (4)     ! IEEE_NEGATIVE_NORMAL\n-        res = -42\n-      case (5)     ! IEEE_NEGATIVE_DENORMAL\n-        res = -tiny(res)\n-        res = res / 2\n-      case (6)     ! IEEE_NEGATIVE_ZERO\n-        res = 0\n-        res = -res\n-      case (7)     ! IEEE_POSITIVE_ZERO\n-        res = 0\n-      case (8)     ! IEEE_POSITIVE_DENORMAL\n-        res = tiny(res)\n-        res = res / 2\n-      case (9)     ! IEEE_POSITIVE_NORMAL\n-        res = 42\n-      case (10)    ! IEEE_POSITIVE_INF\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_get_halting_mode(ieee_overflow, flag)\n-           call ieee_set_halting_mode(ieee_overflow, .false.)\n-        end if\n-        res = huge(res)\n-        res = res * res\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_set_halting_mode(ieee_overflow, flag)\n-        end if\n-      case default ! IEEE_OTHER_VALUE, should not happen\n-        res = 0\n-     end select\n+\n+    interface\n+      pure real(kind=8) function _gfortrani_ieee_value_helper_8(x)\n+        use ISO_C_BINDING, only: C_INT\n+        integer(kind=C_INT), value :: x\n+      end function\n+    end interface\n+\n+    res = _gfortrani_ieee_value_helper_8(CLASS%hidden)\n   end function\n \n #ifdef HAVE_GFC_REAL_10\n   elemental real(kind=10) function IEEE_VALUE_10(X, CLASS) result(res)\n-\n     real(kind=10), intent(in) :: X\n     type(IEEE_CLASS_TYPE), intent(in) :: CLASS\n-    logical flag\n-\n-    select case (CLASS%hidden)\n-      case (1)     ! IEEE_SIGNALING_NAN\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_get_halting_mode(ieee_invalid, flag)\n-           call ieee_set_halting_mode(ieee_invalid, .false.)\n-        end if\n-        res = -1\n-        res = sqrt(res)\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_set_halting_mode(ieee_invalid, flag)\n-        end if\n-      case (2)     ! IEEE_QUIET_NAN\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_get_halting_mode(ieee_invalid, flag)\n-           call ieee_set_halting_mode(ieee_invalid, .false.)\n-        end if\n-        res = -1\n-        res = sqrt(res)\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_set_halting_mode(ieee_invalid, flag)\n-        end if\n-     case (3)     ! IEEE_NEGATIVE_INF\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_get_halting_mode(ieee_overflow, flag)\n-           call ieee_set_halting_mode(ieee_overflow, .false.)\n-        end if\n-        res = huge(res)\n-        res = (-res) * res\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_set_halting_mode(ieee_overflow, flag)\n-        end if\n-      case (4)     ! IEEE_NEGATIVE_NORMAL\n-        res = -42\n-      case (5)     ! IEEE_NEGATIVE_DENORMAL\n-        res = -tiny(res)\n-        res = res / 2\n-      case (6)     ! IEEE_NEGATIVE_ZERO\n-        res = 0\n-        res = -res\n-      case (7)     ! IEEE_POSITIVE_ZERO\n-        res = 0\n-      case (8)     ! IEEE_POSITIVE_DENORMAL\n-        res = tiny(res)\n-        res = res / 2\n-      case (9)     ! IEEE_POSITIVE_NORMAL\n-        res = 42\n-      case (10)    ! IEEE_POSITIVE_INF\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_get_halting_mode(ieee_overflow, flag)\n-           call ieee_set_halting_mode(ieee_overflow, .false.)\n-        end if\n-        res = huge(res)\n-        res = res * res\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_set_halting_mode(ieee_overflow, flag)\n-        end if\n-      case default ! IEEE_OTHER_VALUE, should not happen\n-        res = 0\n-     end select\n+\n+    interface\n+      pure real(kind=10) function _gfortrani_ieee_value_helper_10(x)\n+        use ISO_C_BINDING, only: C_INT\n+        integer(kind=C_INT), value :: x\n+      end function\n+    end interface\n+\n+    res = _gfortrani_ieee_value_helper_10(CLASS%hidden)\n   end function\n \n #endif\n \n #ifdef HAVE_GFC_REAL_16\n   elemental real(kind=16) function IEEE_VALUE_16(X, CLASS) result(res)\n-\n     real(kind=16), intent(in) :: X\n     type(IEEE_CLASS_TYPE), intent(in) :: CLASS\n-    logical flag\n-\n-    select case (CLASS%hidden)\n-      case (1)     ! IEEE_SIGNALING_NAN\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_get_halting_mode(ieee_invalid, flag)\n-           call ieee_set_halting_mode(ieee_invalid, .false.)\n-        end if\n-        res = -1\n-        res = sqrt(res)\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_set_halting_mode(ieee_invalid, flag)\n-        end if\n-      case (2)     ! IEEE_QUIET_NAN\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_get_halting_mode(ieee_invalid, flag)\n-           call ieee_set_halting_mode(ieee_invalid, .false.)\n-        end if\n-        res = -1\n-        res = sqrt(res)\n-        if (ieee_support_halting(ieee_invalid)) then\n-           call ieee_set_halting_mode(ieee_invalid, flag)\n-        end if\n-      case (3)     ! IEEE_NEGATIVE_INF\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_get_halting_mode(ieee_overflow, flag)\n-           call ieee_set_halting_mode(ieee_overflow, .false.)\n-        end if\n-        res = huge(res)\n-        res = (-res) * res\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_set_halting_mode(ieee_overflow, flag)\n-        end if\n-      case (4)     ! IEEE_NEGATIVE_NORMAL\n-        res = -42\n-      case (5)     ! IEEE_NEGATIVE_DENORMAL\n-        res = -tiny(res)\n-        res = res / 2\n-      case (6)     ! IEEE_NEGATIVE_ZERO\n-        res = 0\n-        res = -res\n-      case (7)     ! IEEE_POSITIVE_ZERO\n-        res = 0\n-      case (8)     ! IEEE_POSITIVE_DENORMAL\n-        res = tiny(res)\n-        res = res / 2\n-      case (9)     ! IEEE_POSITIVE_NORMAL\n-        res = 42\n-      case (10)    ! IEEE_POSITIVE_INF\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_get_halting_mode(ieee_overflow, flag)\n-           call ieee_set_halting_mode(ieee_overflow, .false.)\n-        end if\n-        res = huge(res)\n-        res = res * res\n-        if (ieee_support_halting(ieee_overflow)) then\n-           call ieee_set_halting_mode(ieee_overflow, flag)\n-        end if\n-      case default ! IEEE_OTHER_VALUE, should not happen\n-        res = 0\n-     end select\n+\n+    interface\n+      pure real(kind=16) function _gfortrani_ieee_value_helper_16(x)\n+        use ISO_C_BINDING, only: C_INT\n+        integer(kind=C_INT), value :: x\n+      end function\n+    end interface\n+\n+    res = _gfortrani_ieee_value_helper_16(CLASS%hidden)\n   end function\n #endif\n "}, {"sha": "794ccec40ee44ba6fb3c989135256b4a9548f9e9", "filename": "libgfortran/ieee/ieee_helper.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90045c5df5b3c8853e7740fb72a11aead1c489bb/libgfortran%2Fieee%2Fieee_helper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90045c5df5b3c8853e7740fb72a11aead1c489bb/libgfortran%2Fieee%2Fieee_helper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_helper.c?ref=90045c5df5b3c8853e7740fb72a11aead1c489bb", "patch": "@@ -116,6 +116,80 @@ CLASSMACRO(16)\n #endif\n \n \n+extern GFC_REAL_4 ieee_value_helper_4 (int);\n+internal_proto(ieee_value_helper_4);\n+\n+extern GFC_REAL_8 ieee_value_helper_8 (int);\n+internal_proto(ieee_value_helper_8);\n+\n+#ifdef HAVE_GFC_REAL_10\n+extern GFC_REAL_10 ieee_value_helper_10 (int);\n+internal_proto(ieee_value_helper_10);\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+extern GFC_REAL_16 ieee_value_helper_16 (int);\n+internal_proto(ieee_value_helper_16);\n+#endif\n+\n+\n+#define VALUEMACRO(TYPE, SUFFIX) \\\n+  GFC_REAL_ ## TYPE ieee_value_helper_ ## TYPE (int type) \\\n+  { \\\n+    switch (type) \\\n+    { \\\n+      case IEEE_SIGNALING_NAN: \\\n+\treturn __builtin_nans ## SUFFIX (\"\"); \\\n+   \\\n+      case IEEE_QUIET_NAN: \\\n+\treturn __builtin_nan ## SUFFIX (\"\"); \\\n+   \\\n+      case IEEE_NEGATIVE_INF: \\\n+\treturn - __builtin_inf ## SUFFIX (); \\\n+   \\\n+      case IEEE_NEGATIVE_NORMAL: \\\n+\treturn -42; \\\n+   \\\n+      case IEEE_NEGATIVE_DENORMAL: \\\n+\treturn -(GFC_REAL_ ## TYPE ## _TINY) / 2; \\\n+   \\\n+      case IEEE_NEGATIVE_ZERO: \\\n+\treturn -(GFC_REAL_ ## TYPE) 0; \\\n+   \\\n+      case IEEE_POSITIVE_ZERO: \\\n+\treturn 0; \\\n+   \\\n+      case IEEE_POSITIVE_DENORMAL: \\\n+\treturn (GFC_REAL_ ## TYPE ## _TINY) / 2; \\\n+   \\\n+      case IEEE_POSITIVE_NORMAL: \\\n+\treturn 42; \\\n+   \\\n+      case IEEE_POSITIVE_INF: \\\n+\treturn __builtin_inf ## SUFFIX (); \\\n+   \\\n+      default: \\\n+\treturn 0; \\\n+    } \\\n+  }\n+\n+\n+VALUEMACRO(4, f)\n+VALUEMACRO(8, )\n+\n+#ifdef HAVE_GFC_REAL_10\n+VALUEMACRO(10, l)\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+# ifdef GFC_REAL_16_IS_FLOAT128\n+VALUEMACRO(16, f128)\n+# else\n+VALUEMACRO(16, l)\n+# endif\n+#endif\n+\n+\n #define GFC_FPE_ALL (GFC_FPE_INVALID | GFC_FPE_DENORMAL | \\\n \t\t     GFC_FPE_ZERO | GFC_FPE_OVERFLOW | \\\n \t\t     GFC_FPE_UNDERFLOW | GFC_FPE_INEXACT)"}, {"sha": "fb4232eb954410c704627a3a5e76da7ee34e81e5", "filename": "libgfortran/mk-kinds-h.sh", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90045c5df5b3c8853e7740fb72a11aead1c489bb/libgfortran%2Fmk-kinds-h.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90045c5df5b3c8853e7740fb72a11aead1c489bb/libgfortran%2Fmk-kinds-h.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fmk-kinds-h.sh?ref=90045c5df5b3c8853e7740fb72a11aead1c489bb", "patch": "@@ -87,6 +87,12 @@ for k in $possible_real_kinds; do\n \t\t| sed 's/ *TRANSFER *//' | sed 's/_.*//'`\n     rm -f tmq$$.*\n \n+    # Check for the value of TINY\n+    echo \"print *, tiny(0._$k) ; end\" > tmq$$.f90\n+    tiny=`$compile -S -fdump-parse-tree tmq$$.f90 | grep TRANSFER \\\n+\t\t| sed 's/ *TRANSFER *//' | sed 's/_.*//'`\n+    rm -f tmq$$.*\n+\n     # Check for the value of DIGITS\n     echo \"print *, digits(0._$k) ; end\" > tmq$$.f90\n     digits=`$compile -S -fdump-parse-tree tmq$$.f90 | grep TRANSFER \\\n@@ -105,6 +111,7 @@ for k in $possible_real_kinds; do\n     echo \"#define HAVE_GFC_REAL_${k}\"\n     echo \"#define HAVE_GFC_COMPLEX_${k}\"\n     echo \"#define GFC_REAL_${k}_HUGE ${huge}${suffix}\"\n+    echo \"#define GFC_REAL_${k}_TINY ${tiny}${suffix}\"\n     echo \"#define GFC_REAL_${k}_LITERAL_SUFFIX ${suffix}\"\n     if [ \"x$suffix\" = \"x\" ]; then\n       echo \"#define GFC_REAL_${k}_LITERAL(X) (X)\""}]}