{"sha": "901e66e03e1cd80f28ff887f6ff1abaf15873792", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTAxZTY2ZTAzZTFjZDgwZjI4ZmY4ODdmNmZmMWFiYWYxNTg3Mzc5Mg==", "commit": {"author": {"name": "Sudakshina Das", "email": "sudi.das@arm.com", "date": "2019-01-09T14:10:58Z"}, "committer": {"name": "Sudakshina Das", "email": "sudi@gcc.gnu.org", "date": "2019-01-09T14:10:58Z"}, "message": "[AArch64, 3/6] Restrict indirect tail calls to x16 and x17\n\nThis patch is part of a series that enables ARMv8.5-A in GCC and\nadds Branch Target Identification Mechanism.\n\nThis patch changes the registers that are allowed for indirect tail calls.\nWe are choosing to restrict these to only x16 or x17.\n\nIndirect tail calls are special in a way that they convert a call statement\n(BLR instruction) to a jump statement (BR instruction). For the best possible\nuse of Branch Target Identification Mechanism, we would like to place a\n\"BTI C\" (call) at the beginning of the function which is only\ncompatible with BLRs and BR X16/X17. In order to make indirect tail calls\ncompatible with this scenario, we are restricting the TAILCALL_ADDR_REGS.\n\nIn order to use x16/x17 for this purpose, we also had to change the use\nof these registers in the epilogue/prologue handling. For this purpose\nwe are now using x12 and x13 named as EP0_REGNUM and EP1_REGNUM as\nscratch registers for epilogue and prologue.\n\n*** gcc/ChangeLog***\n\n2018-01-09  Sudakshina Das  <sudi.das@arm.com>\n\n\t* config/aarch64/aarch64.c (aarch64_expand_prologue): Use new\n\tepilogue/prologue scratch registers EP0_REGNUM and EP1_REGNUM.\n\t(aarch64_expand_epilogue): Likewise.\n\t(aarch64_output_mi_thunk): Likewise\n\t* config/aarch64/aarch64.h (REG_CLASS_CONTENTS): Change\n\tTAILCALL_ADDR_REGS to x16 and x17.\n\t* config/aarch64/aarch64.md: Define EP0_REGNUM and EP1_REGNUM.\n\n*** gcc/testsuite/ChangeLog ***\n\n2018-01-09  Sudakshina Das  <sudi.das@arm.com>\n\n\t* gcc.target/aarch64/test_frame_17.c: Update to check for EP0_REGNUM\n\tinstead of IP0_REGNUM and add test case.\n\nFrom-SVN: r267767", "tree": {"sha": "b5c7e4c1010094519b520627fc44d9b57d0bce73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5c7e4c1010094519b520627fc44d9b57d0bce73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/901e66e03e1cd80f28ff887f6ff1abaf15873792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/901e66e03e1cd80f28ff887f6ff1abaf15873792", "html_url": "https://github.com/Rust-GCC/gccrs/commit/901e66e03e1cd80f28ff887f6ff1abaf15873792", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/901e66e03e1cd80f28ff887f6ff1abaf15873792/comments", "author": {"login": "sudakshina-das-arm", "id": 28538945, "node_id": "MDQ6VXNlcjI4NTM4OTQ1", "avatar_url": "https://avatars.githubusercontent.com/u/28538945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sudakshina-das-arm", "html_url": "https://github.com/sudakshina-das-arm", "followers_url": "https://api.github.com/users/sudakshina-das-arm/followers", "following_url": "https://api.github.com/users/sudakshina-das-arm/following{/other_user}", "gists_url": "https://api.github.com/users/sudakshina-das-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/sudakshina-das-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sudakshina-das-arm/subscriptions", "organizations_url": "https://api.github.com/users/sudakshina-das-arm/orgs", "repos_url": "https://api.github.com/users/sudakshina-das-arm/repos", "events_url": "https://api.github.com/users/sudakshina-das-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/sudakshina-das-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b4247de4f578102b00513f59596dc8e15d34c15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b4247de4f578102b00513f59596dc8e15d34c15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b4247de4f578102b00513f59596dc8e15d34c15"}], "stats": {"total": 72, "additions": 52, "deletions": 20}, "files": [{"sha": "bd065bc471621fb4c12f885f4ae5c4e316cd5f15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/901e66e03e1cd80f28ff887f6ff1abaf15873792/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/901e66e03e1cd80f28ff887f6ff1abaf15873792/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=901e66e03e1cd80f28ff887f6ff1abaf15873792", "patch": "@@ -1,3 +1,13 @@\n+2018-01-09  Sudakshina Das  <sudi.das@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_expand_prologue): Use new\n+\tepilogue/prologue scratch registers EP0_REGNUM and EP1_REGNUM.\n+\t(aarch64_expand_epilogue): Likewise.\n+\t(aarch64_output_mi_thunk): Likewise\n+\t* config/aarch64/aarch64.h (REG_CLASS_CONTENTS): Change\n+\tTAILCALL_ADDR_REGS to x16 and x17.\n+\t* config/aarch64/aarch64.md: Define EP0_REGNUM and EP1_REGNUM.\n+\n 2018-01-09  Sudakshina Das  <sudi.das@arm.com>\n \n \t* config/aarch64/aarch64-option-extensions.def: Define"}, {"sha": "152875d9dacf298052416cd871c587c756256645", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/901e66e03e1cd80f28ff887f6ff1abaf15873792/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/901e66e03e1cd80f28ff887f6ff1abaf15873792/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=901e66e03e1cd80f28ff887f6ff1abaf15873792", "patch": "@@ -5521,8 +5521,8 @@ aarch64_expand_prologue (void)\n \taarch64_emit_probe_stack_range (get_stack_check_protect (), frame_size);\n     }\n \n-  rtx ip0_rtx = gen_rtx_REG (Pmode, IP0_REGNUM);\n-  rtx ip1_rtx = gen_rtx_REG (Pmode, IP1_REGNUM);\n+  rtx tmp0_rtx = gen_rtx_REG (Pmode, EP0_REGNUM);\n+  rtx tmp1_rtx = gen_rtx_REG (Pmode, EP1_REGNUM);\n \n   /* In theory we should never have both an initial adjustment\n      and a callee save adjustment.  Verify that is the case since the\n@@ -5532,7 +5532,7 @@ aarch64_expand_prologue (void)\n   /* Will only probe if the initial adjustment is larger than the guard\n      less the amount of the guard reserved for use by the caller's\n      outgoing args.  */\n-  aarch64_allocate_and_probe_stack_space (ip0_rtx, ip1_rtx, initial_adjust,\n+  aarch64_allocate_and_probe_stack_space (tmp0_rtx, tmp1_rtx, initial_adjust,\n \t\t\t\t\t  true, false);\n \n   if (callee_adjust != 0)\n@@ -5550,7 +5550,7 @@ aarch64_expand_prologue (void)\n \t}\n       aarch64_add_offset (Pmode, hard_frame_pointer_rtx,\n \t\t\t  stack_pointer_rtx, callee_offset,\n-\t\t\t  ip1_rtx, ip0_rtx, frame_pointer_needed);\n+\t\t\t  tmp1_rtx, tmp0_rtx, frame_pointer_needed);\n       if (frame_pointer_needed && !frame_size.is_constant ())\n \t{\n \t  /* Variable-sized frames need to describe the save slot\n@@ -5596,7 +5596,7 @@ aarch64_expand_prologue (void)\n \n   /* We may need to probe the final adjustment if it is larger than the guard\n      that is assumed by the called.  */\n-  aarch64_allocate_and_probe_stack_space (ip1_rtx, ip0_rtx, final_adjust,\n+  aarch64_allocate_and_probe_stack_space (tmp1_rtx, tmp0_rtx, final_adjust,\n \t\t\t\t\t  !frame_pointer_needed, true);\n }\n \n@@ -5647,8 +5647,8 @@ aarch64_expand_epilogue (bool for_sibcall)\n   unsigned reg2 = cfun->machine->frame.wb_candidate2;\n   rtx cfi_ops = NULL;\n   rtx_insn *insn;\n-  /* A stack clash protection prologue may not have left IP0_REGNUM or\n-     IP1_REGNUM in a usable state.  The same is true for allocations\n+  /* A stack clash protection prologue may not have left EP0_REGNUM or\n+     EP1_REGNUM in a usable state.  The same is true for allocations\n      with an SVE component, since we then need both temporary registers\n      for each allocation.  For stack clash we are in a usable state if\n      the adjustment is less than GUARD_SIZE - GUARD_USED_BY_CALLER.  */\n@@ -5663,8 +5663,8 @@ aarch64_expand_epilogue (bool for_sibcall)\n   bool can_inherit_p = (initial_adjust.is_constant ()\n \t\t\t&& final_adjust.is_constant ())\n \t\t\t&& (!flag_stack_clash_protection\n-\t\t\t     || known_lt (initial_adjust,\n-\t\t\t\t\t  guard_size - guard_used_by_caller));\n+\t\t\t    || known_lt (initial_adjust,\n+\t\t\t\t\t guard_size - guard_used_by_caller));\n \n   /* We need to add memory barrier to prevent read from deallocated stack.  */\n   bool need_barrier_p\n@@ -5682,20 +5682,20 @@ aarch64_expand_epilogue (bool for_sibcall)\n \n   /* Restore the stack pointer from the frame pointer if it may not\n      be the same as the stack pointer.  */\n-  rtx ip0_rtx = gen_rtx_REG (Pmode, IP0_REGNUM);\n-  rtx ip1_rtx = gen_rtx_REG (Pmode, IP1_REGNUM);\n+  rtx tmp0_rtx = gen_rtx_REG (Pmode, EP0_REGNUM);\n+  rtx tmp1_rtx = gen_rtx_REG (Pmode, EP1_REGNUM);\n   if (frame_pointer_needed\n       && (maybe_ne (final_adjust, 0) || cfun->calls_alloca))\n     /* If writeback is used when restoring callee-saves, the CFA\n        is restored on the instruction doing the writeback.  */\n     aarch64_add_offset (Pmode, stack_pointer_rtx,\n \t\t\thard_frame_pointer_rtx, -callee_offset,\n-\t\t\tip1_rtx, ip0_rtx, callee_adjust == 0);\n+\t\t\ttmp1_rtx, tmp0_rtx, callee_adjust == 0);\n   else\n      /* The case where we need to re-use the register here is very rare, so\n \tavoid the complicated condition and just always emit a move if the\n \timmediate doesn't fit.  */\n-     aarch64_add_sp (ip1_rtx, ip0_rtx, final_adjust, true);\n+     aarch64_add_sp (tmp1_rtx, tmp0_rtx, final_adjust, true);\n \n   aarch64_restore_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n \t\t\t\tcallee_adjust != 0, &cfi_ops);\n@@ -5722,8 +5722,11 @@ aarch64_expand_epilogue (bool for_sibcall)\n       cfi_ops = NULL;\n     }\n \n-  aarch64_add_sp (ip0_rtx, ip1_rtx, initial_adjust,\n-\t\t  !can_inherit_p || df_regs_ever_live_p (IP0_REGNUM));\n+  /* Liveness of EP0_REGNUM can not be trusted across function calls either, so\n+     add restriction on emit_move optimization to leaf functions.  */\n+  aarch64_add_sp (tmp0_rtx, tmp1_rtx, initial_adjust,\n+\t\t  (!can_inherit_p || !crtl->is_leaf\n+\t\t   || df_regs_ever_live_p (EP0_REGNUM)));\n \n   if (cfi_ops)\n     {\n@@ -5829,8 +5832,8 @@ aarch64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   emit_note (NOTE_INSN_PROLOGUE_END);\n \n   this_rtx = gen_rtx_REG (Pmode, this_regno);\n-  temp0 = gen_rtx_REG (Pmode, IP0_REGNUM);\n-  temp1 = gen_rtx_REG (Pmode, IP1_REGNUM);\n+  temp0 = gen_rtx_REG (Pmode, EP0_REGNUM);\n+  temp1 = gen_rtx_REG (Pmode, EP1_REGNUM);\n \n   if (vcall_offset == 0)\n     aarch64_add_offset (Pmode, this_rtx, this_rtx, delta, temp1, temp0, false);"}, {"sha": "e401ffb1962d20963810e8971f7ae189d450169c", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/901e66e03e1cd80f28ff887f6ff1abaf15873792/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/901e66e03e1cd80f28ff887f6ff1abaf15873792/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=901e66e03e1cd80f28ff887f6ff1abaf15873792", "patch": "@@ -579,7 +579,7 @@ enum reg_class\n #define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0x00000000 },\t/* NO_REGS */\t\t\\\n-  { 0x0004ffff, 0x00000000, 0x00000000 },\t/* TAILCALL_ADDR_REGS */\\\n+  { 0x00030000, 0x00000000, 0x00000000 },\t/* TAILCALL_ADDR_REGS */\\\n   { 0x7fffffff, 0x00000000, 0x00000003 },\t/* GENERAL_REGS */\t\\\n   { 0x80000000, 0x00000000, 0x00000000 },\t/* STACK_REG */\t\t\\\n   { 0xffffffff, 0x00000000, 0x00000003 },\t/* POINTER_REGS */\t\\"}, {"sha": "1d8226d3efa4cb34b382806efebba1d2954fd13f", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/901e66e03e1cd80f28ff887f6ff1abaf15873792/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/901e66e03e1cd80f28ff887f6ff1abaf15873792/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=901e66e03e1cd80f28ff887f6ff1abaf15873792", "patch": "@@ -35,6 +35,9 @@\n     (R11_REGNUM\t\t11)\n     (R12_REGNUM\t\t12)\n     (R13_REGNUM\t\t13)\n+    ;; Scratch registers for prologue/epilogue use.\n+    (EP0_REGNUM\t\t12)\n+    (EP1_REGNUM\t\t13)\n     (R14_REGNUM\t\t14)\n     (R15_REGNUM\t\t15)\n     (R16_REGNUM\t\t16)"}, {"sha": "d3d73f54eae7d7183da4f6d0cbc1198a0e0429de", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/901e66e03e1cd80f28ff887f6ff1abaf15873792/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/901e66e03e1cd80f28ff887f6ff1abaf15873792/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=901e66e03e1cd80f28ff887f6ff1abaf15873792", "patch": "@@ -1,3 +1,8 @@\n+2018-01-09  Sudakshina Das  <sudi.das@arm.com>\n+\n+\t* gcc.target/aarch64/test_frame_17.c: Update to check for EP0_REGNUM\n+\tinstead of IP0_REGNUM and add test case.\n+\n 2019-01-09  Alejandro Martinez  <alejandro.martinezvicente@arm.com>\n \n \t* gcc.target/aarch64/sve/copysign_1.c: New test for SVE vectorized"}, {"sha": "44f132911286779f63db60157987d568d3c13d0d", "filename": "gcc/testsuite/gcc.target/aarch64/test_frame_17.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/901e66e03e1cd80f28ff887f6ff1abaf15873792/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/901e66e03e1cd80f28ff887f6ff1abaf15873792/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_17.c?ref=901e66e03e1cd80f28ff887f6ff1abaf15873792", "patch": "@@ -1,21 +1,32 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 --save-temps\" } */\n+/* { dg-options \"-O2\" } */\n \n /* Test reuse of stack adjustment temporaries.  */\n \n void foo ();\n \n+/* Should only use 1 mov and re-use it.  */\n int reuse_mov (int i)\n {\n   int arr[1025];\n   return arr[i];\n }\n \n+/* Should use 2 movs because x12 is live.  */\n+int no_reuse_mov_live (int i)\n+{\n+  int arr[1025];\n+  register long long a __asm(\"x12\");\n+  a = a+1;\n+  return arr[i] + a;\n+}\n+\n+/* Should use 2 movs because its not a leaf function.  */\n int no_reuse_mov (int i)\n {\n   int arr[1025];\n   foo ();\n   return arr[i];\n }\n \n-/* { dg-final { scan-assembler-times \"mov\\tx16, \\[0-9\\]+\" 3 } } */\n+/* { dg-final { scan-assembler-times \"mov\\tx12, \\[0-9\\]+\" 5 } } */"}]}