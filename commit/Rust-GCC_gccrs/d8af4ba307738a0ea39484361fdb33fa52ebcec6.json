{"sha": "d8af4ba307738a0ea39484361fdb33fa52ebcec6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhhZjRiYTMwNzczOGEwZWEzOTQ4NDM2MWZkYjMzZmE1MmViY2VjNg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "ook@ucw.cz", "date": "2011-08-26T13:36:28Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-08-26T13:36:28Z"}, "message": "tree-ssa-loop-ivopts.c (struct cost_pair): Add comp field.\n\n2011-08-26  Zdenek Dvorak  <ook@ucw.cz>\n\t    Tom de Vries  <tom@codesourcery.com>\n\n\t* tree-ssa-loop-ivopts.c (struct cost_pair): Add comp field.\n\t(struct ivopts_data): Add loop_single_exit_p field.\n\t(niter_for_exit): Change parameter desc_p into return value.  Return\n\tdesc if\tdesc->may_be_zero.  Free desc if unused.\n\t(niter_for_single_dom_exit): Change return type.\n\t(find_induction_variables): Handle changed return type of\n\tniter_for_single_dom_exit.  Dump may_be_zero.\n\t(add_candidate_1): Keep original base and step type for IP_ORIGINAL.\n\t(set_use_iv_cost): Add and handle comp parameter.\n\t(determine_use_iv_cost_generic, determine_use_iv_cost_address): Add\n\tcomp argument to set_use_iv_cost.\n\t(strip_wrap_conserving_type_conversions, expr_equal_p)\n\t(difference_cannot_overflow_p, iv_elimination_compare_lt): New function.\n\t(may_eliminate_iv): Add comp parameter.  Handle new return type of\n\tniter_for_exit.  Use loop_single_exit_p.  Use iv_elimination_compare_lt.\n\t(determine_use_iv_cost_condition): Add comp argument to set_use_iv_cost\n\tand may_eliminate_iv.\n\t(rewrite_use_compare): Move call to iv_elimination_compare to ...\n\t(may_eliminate_iv): Here.\n\t(tree_ssa_iv_optimize_loop): Initialize loop_single_exit_p.\n\nCo-Authored-By: Tom de Vries <tom@codesourcery.com>\n\nFrom-SVN: r178104", "tree": {"sha": "c69d49213c5ed36ba5c347472eaddca8c98ffe40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c69d49213c5ed36ba5c347472eaddca8c98ffe40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8af4ba307738a0ea39484361fdb33fa52ebcec6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8af4ba307738a0ea39484361fdb33fa52ebcec6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8af4ba307738a0ea39484361fdb33fa52ebcec6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8af4ba307738a0ea39484361fdb33fa52ebcec6/comments", "author": {"login": "rakdver", "id": 20416833, "node_id": "MDQ6VXNlcjIwNDE2ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/20416833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakdver", "html_url": "https://github.com/rakdver", "followers_url": "https://api.github.com/users/rakdver/followers", "following_url": "https://api.github.com/users/rakdver/following{/other_user}", "gists_url": "https://api.github.com/users/rakdver/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakdver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakdver/subscriptions", "organizations_url": "https://api.github.com/users/rakdver/orgs", "repos_url": "https://api.github.com/users/rakdver/repos", "events_url": "https://api.github.com/users/rakdver/events{/privacy}", "received_events_url": "https://api.github.com/users/rakdver/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd1777ca0fb732b899f27b1ff465d4fbc8965a74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd1777ca0fb732b899f27b1ff465d4fbc8965a74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd1777ca0fb732b899f27b1ff465d4fbc8965a74"}], "stats": {"total": 395, "additions": 344, "deletions": 51}, "files": [{"sha": "9412f498569fecf132ac47aedc23ed2facf5d4f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8af4ba307738a0ea39484361fdb33fa52ebcec6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8af4ba307738a0ea39484361fdb33fa52ebcec6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8af4ba307738a0ea39484361fdb33fa52ebcec6", "patch": "@@ -1,3 +1,27 @@\n+2011-08-26  Zdenek Dvorak  <ook@ucw.cz>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\n+\t* tree-ssa-loop-ivopts.c (struct cost_pair): Add comp field.\n+\t(struct ivopts_data): Add loop_single_exit_p field.\n+\t(niter_for_exit): Change parameter desc_p into return value.  Return\n+\tdesc if\tdesc->may_be_zero.  Free desc if unused.\n+\t(niter_for_single_dom_exit): Change return type.\n+\t(find_induction_variables): Handle changed return type of\n+\tniter_for_single_dom_exit.  Dump may_be_zero.\n+\t(add_candidate_1): Keep original base and step type for IP_ORIGINAL.\n+\t(set_use_iv_cost): Add and handle comp parameter.\n+\t(determine_use_iv_cost_generic, determine_use_iv_cost_address): Add\n+\tcomp argument to set_use_iv_cost.\n+\t(strip_wrap_conserving_type_conversions, expr_equal_p)\n+\t(difference_cannot_overflow_p, iv_elimination_compare_lt): New function.\n+\t(may_eliminate_iv): Add comp parameter.  Handle new return type of\n+\tniter_for_exit.  Use loop_single_exit_p.  Use iv_elimination_compare_lt.\n+\t(determine_use_iv_cost_condition): Add comp argument to set_use_iv_cost\n+\tand may_eliminate_iv.\n+\t(rewrite_use_compare): Move call to iv_elimination_compare to ...\n+\t(may_eliminate_iv): Here.\n+\t(tree_ssa_iv_optimize_loop): Initialize loop_single_exit_p.\n+\n 2011-08-26  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree-pretty-print (dump_generic_node): Test for NULL_TREE before"}, {"sha": "f170859fde4c3568025a1740cf9587883788d3a9", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 320, "deletions": 51, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8af4ba307738a0ea39484361fdb33fa52ebcec6/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8af4ba307738a0ea39484361fdb33fa52ebcec6/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=d8af4ba307738a0ea39484361fdb33fa52ebcec6", "patch": "@@ -176,6 +176,7 @@ struct cost_pair\n   tree value;\t\t/* For final value elimination, the expression for\n \t\t\t   the final value of the iv.  For iv elimination,\n \t\t\t   the new bound to compare with.  */\n+  enum tree_code comp;\t/* For iv elimination, the comparison.  */\n   int inv_expr_id;      /* Loop invariant expression id.  */\n };\n \n@@ -297,6 +298,9 @@ struct ivopts_data\n \n   /* Whether the loop body includes any function calls.  */\n   bool body_includes_call;\n+\n+  /* Whether the loop body can only be exited via single exit.  */\n+  bool loop_single_exit_p;\n };\n \n /* An assignment of iv candidates to uses.  */\n@@ -770,15 +774,13 @@ contains_abnormal_ssa_name_p (tree expr)\n   return false;\n }\n \n-/*  Returns tree describing number of iterations determined from\n+/*  Returns the structure describing number of iterations determined from\n     EXIT of DATA->current_loop, or NULL if something goes wrong.  */\n \n-static tree\n-niter_for_exit (struct ivopts_data *data, edge exit,\n-                struct tree_niter_desc **desc_p)\n+static struct tree_niter_desc *\n+niter_for_exit (struct ivopts_data *data, edge exit)\n {\n-  struct tree_niter_desc* desc = NULL;\n-  tree niter;\n+  struct tree_niter_desc *desc;\n   void **slot;\n \n   if (!data->niters)\n@@ -791,45 +793,39 @@ niter_for_exit (struct ivopts_data *data, edge exit,\n \n   if (!slot)\n     {\n-      /* Try to determine number of iterations.  We must know it\n-\t unconditionally (i.e., without possibility of # of iterations\n-\t being zero).  Also, we cannot safely work with ssa names that\n-\t appear in phi nodes on abnormal edges, so that we do not create\n-\t overlapping life ranges for them (PR 27283).  */\n+      /* Try to determine number of iterations.  We cannot safely work with ssa\n+         names that appear in phi nodes on abnormal edges, so that we do not\n+         create overlapping life ranges for them (PR 27283).  */\n       desc = XNEW (struct tree_niter_desc);\n-      if (number_of_iterations_exit (data->current_loop,\n-\t\t\t\t     exit, desc, true)\n-\t  && integer_zerop (desc->may_be_zero)\n-     \t  && !contains_abnormal_ssa_name_p (desc->niter))\n-\tniter = desc->niter;\n-      else\n-\tniter = NULL_TREE;\n-\n-      desc->niter = niter;\n+      if (!number_of_iterations_exit (data->current_loop,\n+\t\t\t\t      exit, desc, true)\n+     \t  || contains_abnormal_ssa_name_p (desc->niter))\n+\t{\n+\t  XDELETE (desc);\n+\t  desc = NULL;\n+\t}\n       slot = pointer_map_insert (data->niters, exit);\n       *slot = desc;\n     }\n   else\n-    niter = ((struct tree_niter_desc *) *slot)->niter;\n+    desc = (struct tree_niter_desc *) *slot;\n \n-  if (desc_p)\n-    *desc_p = (struct tree_niter_desc *) *slot;\n-  return niter;\n+  return desc;\n }\n \n-/* Returns tree describing number of iterations determined from\n+/* Returns the structure describing number of iterations determined from\n    single dominating exit of DATA->current_loop, or NULL if something\n    goes wrong.  */\n \n-static tree\n+static struct tree_niter_desc *\n niter_for_single_dom_exit (struct ivopts_data *data)\n {\n   edge exit = single_dom_exit (data->current_loop);\n \n   if (!exit)\n     return NULL;\n \n-  return niter_for_exit (data, exit, NULL);\n+  return niter_for_exit (data, exit);\n }\n \n /* Hash table equality function for expressions.  */\n@@ -1174,12 +1170,17 @@ find_induction_variables (struct ivopts_data *data)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      tree niter = niter_for_single_dom_exit (data);\n+      struct tree_niter_desc *niter = niter_for_single_dom_exit (data);\n \n       if (niter)\n \t{\n \t  fprintf (dump_file, \"  number of iterations \");\n-\t  print_generic_expr (dump_file, niter, TDF_SLIM);\n+\t  print_generic_expr (dump_file, niter->niter, TDF_SLIM);\n+\t  if (!integer_zerop (niter->may_be_zero))\n+\t    {\n+\t      fprintf (dump_file, \"; zero if \");\n+\t      print_generic_expr (dump_file, niter->may_be_zero, TDF_SLIM);\n+\t    }\n \t  fprintf (dump_file, \"\\n\\n\");\n     \t};\n \n@@ -2217,7 +2218,10 @@ add_candidate_1 (struct ivopts_data *data,\n   struct iv_cand *cand = NULL;\n   tree type, orig_type;\n \n-  if (base)\n+  /* For non-original variables, make sure their values are computed in a type\n+     that does not invoke undefined behavior on overflows (since in general,\n+     we cannot prove that these induction variables are non-wrapping).  */\n+  if (pos != IP_ORIGINAL)\n     {\n       orig_type = TREE_TYPE (base);\n       type = generic_type_for (orig_type);\n@@ -2663,13 +2667,13 @@ infinite_cost_p (comp_cost cost)\n \n /* Sets cost of (USE, CANDIDATE) pair to COST and record that it depends\n    on invariants DEPENDS_ON and that the value used in expressing it\n-   is VALUE.  */\n+   is VALUE, and in case of iv elimination the comparison operator is COMP.  */\n \n static void\n set_use_iv_cost (struct ivopts_data *data,\n \t\t struct iv_use *use, struct iv_cand *cand,\n \t\t comp_cost cost, bitmap depends_on, tree value,\n-                 int inv_expr_id)\n+\t\t enum tree_code comp, int inv_expr_id)\n {\n   unsigned i, s;\n \n@@ -2685,6 +2689,7 @@ set_use_iv_cost (struct ivopts_data *data,\n       use->cost_map[cand->id].cost = cost;\n       use->cost_map[cand->id].depends_on = depends_on;\n       use->cost_map[cand->id].value = value;\n+      use->cost_map[cand->id].comp = comp;\n       use->cost_map[cand->id].inv_expr_id = inv_expr_id;\n       return;\n     }\n@@ -2705,6 +2710,7 @@ set_use_iv_cost (struct ivopts_data *data,\n   use->cost_map[i].cost = cost;\n   use->cost_map[i].depends_on = depends_on;\n   use->cost_map[i].value = value;\n+  use->cost_map[i].comp = comp;\n   use->cost_map[i].inv_expr_id = inv_expr_id;\n }\n \n@@ -4257,14 +4263,15 @@ determine_use_iv_cost_generic (struct ivopts_data *data,\n   if (cand->pos == IP_ORIGINAL\n       && cand->incremented_at == use->stmt)\n     {\n-      set_use_iv_cost (data, use, cand, zero_cost, NULL, NULL_TREE, -1);\n+      set_use_iv_cost (data, use, cand, zero_cost, NULL, NULL_TREE,\n+                       ERROR_MARK, -1);\n       return true;\n     }\n \n   cost = get_computation_cost (data, use, cand, false, &depends_on,\n                                NULL, &inv_expr_id);\n \n-  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE,\n+  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE, ERROR_MARK,\n                    inv_expr_id);\n \n   return !infinite_cost_p (cost);\n@@ -4292,7 +4299,7 @@ determine_use_iv_cost_address (struct ivopts_data *data,\n       else if (cand->pos == IP_AFTER_USE || cand->pos == IP_BEFORE_USE)\n \tcost = infinite_cost;\n     }\n-  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE,\n+  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE, ERROR_MARK,\n                    inv_expr_id);\n \n   return !infinite_cost_p (cost);\n@@ -4368,16 +4375,261 @@ iv_elimination_compare (struct ivopts_data *data, struct iv_use *use)\n   return (exit->flags & EDGE_TRUE_VALUE ? EQ_EXPR : NE_EXPR);\n }\n \n+static tree\n+strip_wrap_conserving_type_conversions (tree exp)\n+{\n+  while (tree_ssa_useless_type_conversion (exp)\n+\t && (nowrap_type_p (TREE_TYPE (exp))\n+\t     == nowrap_type_p (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n+    exp = TREE_OPERAND (exp, 0);\n+  return exp;\n+}\n+\n+/* Walk the SSA form and check whether E == WHAT.  Fairly simplistic, we\n+   check for an exact match.  */\n+\n+static bool\n+expr_equal_p (tree e, tree what)\n+{\n+  gimple stmt;\n+  enum tree_code code;\n+\n+  e = strip_wrap_conserving_type_conversions (e);\n+  what = strip_wrap_conserving_type_conversions (what);\n+\n+  code = TREE_CODE (what);\n+  if (TREE_TYPE (e) != TREE_TYPE (what))\n+    return false;\n+\n+  if (operand_equal_p (e, what, 0))\n+    return true;\n+\n+  if (TREE_CODE (e) != SSA_NAME)\n+    return false;\n+\n+  stmt = SSA_NAME_DEF_STMT (e);\n+  if (gimple_code (stmt) != GIMPLE_ASSIGN\n+      || gimple_assign_rhs_code (stmt) != code)\n+    return false;\n+\n+  switch (get_gimple_rhs_class (code))\n+    {\n+    case GIMPLE_BINARY_RHS:\n+      if (!expr_equal_p (gimple_assign_rhs2 (stmt), TREE_OPERAND (what, 1)))\n+\treturn false;\n+      /* Fallthru.  */\n+\n+    case GIMPLE_UNARY_RHS:\n+    case GIMPLE_SINGLE_RHS:\n+      return expr_equal_p (gimple_assign_rhs1 (stmt), TREE_OPERAND (what, 0));\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Returns true if we can prove that BASE - OFFSET does not overflow.  For now,\n+   we only detect the situation that BASE = SOMETHING + OFFSET, where the\n+   calculation is performed in non-wrapping type.\n+\n+   TODO: More generally, we could test for the situation that\n+\t BASE = SOMETHING + OFFSET' and OFFSET is between OFFSET' and zero.\n+\t This would require knowing the sign of OFFSET.\n+\n+\t Also, we only look for the first addition in the computation of BASE.\n+\t More complex analysis would be better, but introducing it just for\n+\t this optimization seems like an overkill.  */\n+\n+static bool\n+difference_cannot_overflow_p (tree base, tree offset)\n+{\n+  enum tree_code code;\n+  tree e1, e2;\n+\n+  if (!nowrap_type_p (TREE_TYPE (base)))\n+    return false;\n+\n+  base = expand_simple_operations (base);\n+\n+  if (TREE_CODE (base) == SSA_NAME)\n+    {\n+      gimple stmt = SSA_NAME_DEF_STMT (base);\n+\n+      if (gimple_code (stmt) != GIMPLE_ASSIGN)\n+\treturn false;\n+\n+      code = gimple_assign_rhs_code (stmt);\n+      if (get_gimple_rhs_class (code) != GIMPLE_BINARY_RHS)\n+\treturn false;\n+\n+      e1 = gimple_assign_rhs1 (stmt);\n+      e2 = gimple_assign_rhs2 (stmt);\n+    }\n+  else\n+    {\n+      code = TREE_CODE (base);\n+      if (get_gimple_rhs_class (code) != GIMPLE_BINARY_RHS)\n+\treturn false;\n+      e1 = TREE_OPERAND (base, 0);\n+      e2 = TREE_OPERAND (base, 1);\n+    }\n+\n+  /* TODO: deeper inspection may be necessary to prove the equality.  */\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+      return expr_equal_p (e1, offset) || expr_equal_p (e2, offset);\n+    case POINTER_PLUS_EXPR:\n+      return expr_equal_p (e2, offset);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Tries to replace loop exit by one formulated in terms of a LT_EXPR\n+   comparison with CAND.  NITER describes the number of iterations of\n+   the loops.  If successful, the comparison in COMP_P is altered accordingly.\n+\n+   We aim to handle the following situation:\n+\n+   sometype *base, *p;\n+   int a, b, i;\n+\n+   i = a;\n+   p = p_0 = base + a;\n+\n+   do\n+     {\n+       bla (*p);\n+       p++;\n+       i++;\n+     }\n+   while (i < b);\n+\n+   Here, the number of iterations of the loop is (a + 1 > b) ? 0 : b - a - 1.\n+   We aim to optimize this to\n+\n+   p = p_0 = base + a;\n+   do\n+     {\n+       bla (*p);\n+       p++;\n+     }\n+   while (p < p_0 - a + b);\n+\n+   This preserves the correctness, since the pointer arithmetics does not\n+   overflow.  More precisely:\n+\n+   1) if a + 1 <= b, then p_0 - a + b is the final value of p, hence there is no\n+      overflow in computing it or the values of p.\n+   2) if a + 1 > b, then we need to verify that the expression p_0 - a does not\n+      overflow.  To prove this, we use the fact that p_0 = base + a.  */\n+\n+static bool\n+iv_elimination_compare_lt (struct ivopts_data *data,\n+                           struct iv_cand *cand, enum tree_code *comp_p,\n+\t\t\t   struct tree_niter_desc *niter)\n+{\n+  tree cand_type, a, b, mbz, nit_type = TREE_TYPE (niter->niter), offset;\n+  struct affine_tree_combination nit, tmpa, tmpb;\n+  enum tree_code comp;\n+  HOST_WIDE_INT step;\n+\n+  /* We need to know that the candidate induction variable does not overflow.\n+     While more complex analysis may be used to prove this, for now just\n+     check that the variable appears in the original program and that it\n+     is computed in a type that guarantees no overflows.  */\n+  cand_type = TREE_TYPE (cand->iv->base);\n+  if (cand->pos != IP_ORIGINAL || !nowrap_type_p (cand_type))\n+    return false;\n+\n+  /* Make sure that the loop iterates till the loop bound is hit, as otherwise\n+     the calculation of the BOUND could overflow, making the comparison\n+     invalid.  */\n+  if (!data->loop_single_exit_p)\n+    return false;\n+\n+  /* We need to be able to decide whether candidate is increasing or decreasing\n+     in order to choose the right comparison operator.  */\n+  if (!cst_and_fits_in_hwi (cand->iv->step))\n+    return false;\n+  step = int_cst_value (cand->iv->step);\n+\n+  /* Check that the number of iterations matches the expected pattern:\n+     a + 1 > b ? 0 : b - a - 1.  */\n+  mbz = niter->may_be_zero;\n+  if (TREE_CODE (mbz) == GT_EXPR)\n+    {\n+      /* Handle a + 1 > b.  */\n+      tree op0 = TREE_OPERAND (mbz, 0);\n+      if (TREE_CODE (op0) == PLUS_EXPR && integer_onep (TREE_OPERAND (op0, 1)))\n+\t{\n+\t  a = TREE_OPERAND (op0, 0);\n+\t  b = TREE_OPERAND (mbz, 1);\n+\t}\n+      else\n+\treturn false;\n+    }\n+  else if (TREE_CODE (mbz) == LT_EXPR)\n+    {\n+      tree op1 = TREE_OPERAND (mbz, 1);\n+\n+      /* Handle b < a + 1.  */\n+      if (TREE_CODE (op1) == PLUS_EXPR && integer_onep (TREE_OPERAND (op1, 1)))\n+        {\n+          a = TREE_OPERAND (op1, 0);\n+          b = TREE_OPERAND (mbz, 0);\n+        }\n+      else\n+\treturn false;\n+    }\n+  else\n+    return false;\n+\n+  /* Expected number of iterations is B - A - 1.  Check that it matches\n+     the actual number, i.e., that B - A - NITER = 1.  */\n+  tree_to_aff_combination (niter->niter, nit_type, &nit);\n+  tree_to_aff_combination (fold_convert (nit_type, a), nit_type, &tmpa);\n+  tree_to_aff_combination (fold_convert (nit_type, b), nit_type, &tmpb);\n+  aff_combination_scale (&nit, double_int_minus_one);\n+  aff_combination_scale (&tmpa, double_int_minus_one);\n+  aff_combination_add (&tmpb, &tmpa);\n+  aff_combination_add (&tmpb, &nit);\n+  if (tmpb.n != 0 || !double_int_equal_p (tmpb.offset, double_int_one))\n+    return false;\n+\n+  /* Finally, check that CAND->IV->BASE - CAND->IV->STEP * A does not\n+     overflow.  */\n+  offset = fold_build2 (MULT_EXPR, TREE_TYPE (cand->iv->step),\n+\t\t\tcand->iv->step,\n+\t\t\tfold_convert (TREE_TYPE (cand->iv->step), a));\n+  if (!difference_cannot_overflow_p (cand->iv->base, offset))\n+    return false;\n+\n+  /* Determine the new comparison operator.  */\n+  comp = step < 0 ? GT_EXPR : LT_EXPR;\n+  if (*comp_p == NE_EXPR)\n+    *comp_p = comp;\n+  else if (*comp_p == EQ_EXPR)\n+    *comp_p = invert_tree_comparison (comp, false);\n+  else\n+    gcc_unreachable ();\n+\n+  return true;\n+}\n+\n /* Check whether it is possible to express the condition in USE by comparison\n-   of candidate CAND.  If so, store the value compared with to BOUND.  */\n+   of candidate CAND.  If so, store the value compared with to BOUND, and the\n+   comparison operator to COMP.  */\n \n static bool\n may_eliminate_iv (struct ivopts_data *data,\n-\t\t  struct iv_use *use, struct iv_cand *cand, tree *bound)\n+\t\t  struct iv_use *use, struct iv_cand *cand, tree *bound,\n+\t\t  enum tree_code *comp)\n {\n   basic_block ex_bb;\n   edge exit;\n-  tree nit, period;\n+  tree period;\n   struct loop *loop = data->current_loop;\n   aff_tree bnd;\n   struct tree_niter_desc *desc = NULL;\n@@ -4399,8 +4651,8 @@ may_eliminate_iv (struct ivopts_data *data,\n   if (flow_bb_inside_loop_p (loop, exit->dest))\n     return false;\n \n-  nit = niter_for_exit (data, exit, &desc);\n-  if (!nit)\n+  desc = niter_for_exit (data, exit);\n+  if (!desc)\n     return false;\n \n   /* Determine whether we can use the variable to test the exit condition.\n@@ -4409,17 +4661,17 @@ may_eliminate_iv (struct ivopts_data *data,\n   period = iv_period (cand->iv);\n \n   /* If the number of iterations is constant, compare against it directly.  */\n-  if (TREE_CODE (nit) == INTEGER_CST)\n+  if (TREE_CODE (desc->niter) == INTEGER_CST)\n     {\n       /* See cand_value_at.  */\n       if (stmt_after_increment (loop, cand, use->stmt))\n         {\n-          if (!tree_int_cst_lt (nit, period))\n+          if (!tree_int_cst_lt (desc->niter, period))\n             return false;\n         }\n       else\n         {\n-          if (tree_int_cst_lt (period, nit))\n+          if (tree_int_cst_lt (period, desc->niter))\n             return false;\n         }\n     }\n@@ -4438,7 +4690,7 @@ may_eliminate_iv (struct ivopts_data *data,\n       if (double_int_ucmp (max_niter, period_value) > 0)\n         {\n           /* See if we can take advantage of infered loop bound information.  */\n-          if (loop_only_exit_p (loop, exit))\n+          if (data->loop_single_exit_p)\n             {\n               if (!estimated_loop_iterations (loop, true, &max_niter))\n                 return false;\n@@ -4451,13 +4703,26 @@ may_eliminate_iv (struct ivopts_data *data,\n         }\n     }\n \n-  cand_value_at (loop, cand, use->stmt, nit, &bnd);\n+  cand_value_at (loop, cand, use->stmt, desc->niter, &bnd);\n \n   *bound = aff_combination_to_tree (&bnd);\n+  *comp = iv_elimination_compare (data, use);\n+\n   /* It is unlikely that computing the number of iterations using division\n      would be more profitable than keeping the original induction variable.  */\n   if (expression_expensive_p (*bound))\n     return false;\n+\n+  /* Sometimes, it is possible to handle the situation that the number of\n+     iterations may be zero unless additional assumtions by using <\n+     instead of != in the exit condition.\n+\n+     TODO: we could also calculate the value MAY_BE_ZERO ? 0 : NITER and\n+\t   base the exit condition on it.  However, that is often too\n+\t   expensive.  */\n+  if (!integer_zerop (desc->may_be_zero))\n+    return iv_elimination_compare_lt (data, cand, comp, desc);\n+\n   return true;\n }\n \n@@ -4492,16 +4757,18 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   bool ok;\n   int elim_inv_expr_id = -1, express_inv_expr_id = -1, inv_expr_id;\n   tree *control_var, *bound_cst;\n+  enum tree_code comp;\n \n   /* Only consider real candidates.  */\n   if (!cand->iv)\n     {\n-      set_use_iv_cost (data, use, cand, infinite_cost, NULL, NULL_TREE, -1);\n+      set_use_iv_cost (data, use, cand, infinite_cost, NULL, NULL_TREE,\n+\t\t       ERROR_MARK, -1);\n       return false;\n     }\n \n   /* Try iv elimination.  */\n-  if (may_eliminate_iv (data, use, cand, &bound))\n+  if (may_eliminate_iv (data, use, cand, &bound, &comp))\n     {\n       elim_cost = force_var_cost (data, bound, &depends_on_elim);\n       if (elim_cost.cost == 0)\n@@ -4572,10 +4839,11 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n       depends_on = depends_on_express;\n       depends_on_express = NULL;\n       bound = NULL_TREE;\n+      comp = ERROR_MARK;\n       inv_expr_id = express_inv_expr_id;\n     }\n \n-  set_use_iv_cost (data, use, cand, cost, depends_on, bound, inv_expr_id);\n+  set_use_iv_cost (data, use, cand, cost, depends_on, bound, comp, inv_expr_id);\n \n   if (depends_on_elim)\n     BITMAP_FREE (depends_on_elim);\n@@ -6215,7 +6483,7 @@ rewrite_use_compare (struct ivopts_data *data,\n           fprintf (dump_file, \"Replacing exit test: \");\n           print_gimple_stmt (dump_file, use->stmt, 0, TDF_SLIM);\n         }\n-      compare = iv_elimination_compare (data, use);\n+      compare = cp->comp;\n       bound = unshare_expr (fold_convert (var_type, bound));\n       op = force_gimple_operand (bound, &stmts, true, NULL_TREE);\n       if (stmts)\n@@ -6445,7 +6713,7 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n {\n   bool changed = false;\n   struct iv_ca *iv_ca;\n-  edge exit;\n+  edge exit = single_dom_exit (loop);\n   basic_block *body;\n \n   gcc_assert (!data->niters);\n@@ -6456,7 +6724,6 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n     {\n       fprintf (dump_file, \"Processing loop %d\\n\", loop->num);\n \n-      exit = single_dom_exit (loop);\n       if (exit)\n \t{\n \t  fprintf (dump_file, \"  single exit %d -> %d, exit condition \",\n@@ -6473,6 +6740,8 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n   renumber_gimple_stmt_uids_in_blocks (body, loop->num_nodes);\n   free (body);\n \n+  data->loop_single_exit_p = exit != NULL && loop_only_exit_p (loop, exit);\n+\n   /* For each ssa name determines whether it behaves as an induction variable\n      in some loop.  */\n   if (!find_induction_variables (data))"}]}