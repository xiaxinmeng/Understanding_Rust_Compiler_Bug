{"sha": "976e21f67321ad483895471c5f285a1880a47b4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc2ZTIxZjY3MzIxYWQ0ODM4OTU0NzFjNWYyODVhMTg4MGE0N2I0YQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-10-26T05:20:19Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-10-26T05:20:19Z"}, "message": "re PR fortran/24158 (ICE in f951 with nested, recursive derived types)\n\n2005-10-26  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/24158\n\t* decl.c (gfc_match_data_decl): Correct broken bit of code\n\tthat prevents undefined derived types from being used as\n\tcomponents of another derived type.\n\t* resolve.c (resolve_symbol): Add backstop error when derived\n\ttype variables arrive here with a type that has no components.\n\n2005-10-26  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/24158\n\tgfortran.dg/derived_recursion.f90: New test.\n\tgfortran.dg/implicit_actual.f90: New test.\n\nFrom-SVN: r105913", "tree": {"sha": "cb4b3fbc58344b406d2294ab4e6cbe21fb873c8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb4b3fbc58344b406d2294ab4e6cbe21fb873c8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/976e21f67321ad483895471c5f285a1880a47b4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/976e21f67321ad483895471c5f285a1880a47b4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/976e21f67321ad483895471c5f285a1880a47b4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/976e21f67321ad483895471c5f285a1880a47b4a/comments", "author": null, "committer": null, "parents": [{"sha": "02f8406bd02ea1016df74868d5576138fe760d7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f8406bd02ea1016df74868d5576138fe760d7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02f8406bd02ea1016df74868d5576138fe760d7d"}], "stats": {"total": 111, "additions": 103, "deletions": 8}, "files": [{"sha": "2cfea316984a6ff7a282fa7260d2d10767e93313", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/976e21f67321ad483895471c5f285a1880a47b4a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/976e21f67321ad483895471c5f285a1880a47b4a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=976e21f67321ad483895471c5f285a1880a47b4a", "patch": "@@ -1,3 +1,12 @@\n+2005-10-26  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/24158\n+\t* decl.c (gfc_match_data_decl): Correct broken bit of code\n+\tthat prevents undefined derived types from being used as\n+\tcomponents of another derived type.\n+\t* resolve.c (resolve_symbol): Add backstop error when derived\n+\ttype variables arrive here with a type that has no components.\n+\n 2005-10-25  Jakub Jelinek  <jakub@redhat.com>\n \n \t* trans.h (gfc_conv_cray_pointee): Remove."}, {"sha": "8c2895ed873c69f35dc11ce44022470a377cdf26", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/976e21f67321ad483895471c5f285a1880a47b4a/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/976e21f67321ad483895471c5f285a1880a47b4a/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=976e21f67321ad483895471c5f285a1880a47b4a", "patch": "@@ -2075,17 +2075,21 @@ gfc_match_data_decl (void)\n       if (current_attr.pointer && gfc_current_state () == COMP_DERIVED)\n \tgoto ok;\n \n-      if (gfc_find_symbol (current_ts.derived->name,\n-\t\t\t   current_ts.derived->ns->parent, 1, &sym) == 0)\n-\tgoto ok;\n+      gfc_find_symbol (current_ts.derived->name,\n+\t\t\t current_ts.derived->ns->parent, 1, &sym);\n \n-      /* Hope that an ambiguous symbol is itself masked by a type definition.  */\n-      if (sym != NULL && sym->attr.flavor == FL_DERIVED)\n+      /* Any symbol that we find had better be a type definition\n+         which has its components defined.  */\n+      if (sym != NULL && sym->attr.flavor == FL_DERIVED\n+\t    && current_ts.derived->components != NULL)\n \tgoto ok;\n \n-      gfc_error (\"Derived type at %C has not been previously defined\");\n-      m = MATCH_ERROR;\n-      goto cleanup;\n+      /* Now we have an error, which we signal, and then fix up\n+\t because the knock-on is plain and simple confusing.  */\n+      gfc_error_now (\"Derived type at %C has not been previously defined \"\n+\t\t \"and so cannot appear in a derived type definition.\");\n+      current_attr.pointer = 1;\n+      goto ok;\n     }\n \n ok:"}, {"sha": "03206bbd3a0146b90550765a70f80e87111a2e36", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/976e21f67321ad483895471c5f285a1880a47b4a/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/976e21f67321ad483895471c5f285a1880a47b4a/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=976e21f67321ad483895471c5f285a1880a47b4a", "patch": "@@ -4339,6 +4339,24 @@ resolve_symbol (gfc_symbol * sym)\n         }\n     }\n \n+  /* If a derived type symbol has reached this point, without its\n+     type being declared, we have an error.  Notice that most\n+     conditions that produce undefined derived types have already\n+     been dealt with.  However, the likes of:\n+     implicit type(t) (t) ..... call foo (t) will get us here if\n+     the type is not declared in the scope of the implicit\n+     statement. Change the type to BT_UNKNOWN, both because it is so\n+     and to prevent an ICE.  */\n+  if (sym->ts.type == BT_DERIVED\n+\t&& sym->ts.derived->components == NULL)\n+    {\n+      gfc_error (\"The derived type '%s' at %L is of type '%s', \"\n+\t\t \"which has not been defined.\", sym->name,\n+\t\t  &sym->declared_at, sym->ts.derived->name);\n+      sym->ts.type = BT_UNKNOWN;\n+      return;\n+    }\n+\n   /* Ensure that derived type components of a public derived type\n      are not of a private type.  */\n   if (sym->attr.flavor == FL_DERIVED"}, {"sha": "3ef11962a00d6aceb4b6d8712d3a988cecd68182", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/976e21f67321ad483895471c5f285a1880a47b4a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/976e21f67321ad483895471c5f285a1880a47b4a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=976e21f67321ad483895471c5f285a1880a47b4a", "patch": "@@ -1,3 +1,9 @@\n+2005-10-26  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/24158\n+\tgfortran.dg/derived_recursion.f90: New test.\n+\tgfortran.dg/implicit_actual.f90: New test.\n+\n 2005-10-25  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR middle-end/24295, PR testsuite/24477"}, {"sha": "d52732ff2798c58e1a8e2d4a909cfb4c2a4acffb", "filename": "gcc/testsuite/gfortran.dg/derived_recursion.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/976e21f67321ad483895471c5f285a1880a47b4a/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_recursion.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/976e21f67321ad483895471c5f285a1880a47b4a/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_recursion.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_recursion.f90?ref=976e21f67321ad483895471c5f285a1880a47b4a", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+! { dg-options \"-O0\" }\n+! Tests patch for PR24158 - The module would compile, in spite\n+! of the recursion between the derived types. This would cause\n+! an ICE in the commented out main program. The standard demands\n+! that derived type components be already defined, to break\n+! recursive derived type definitions.\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+!\n+module snafu\n+  type       ::   a\n+    integer    :: v\n+    type(b)    :: i ! { dg-error \"not been previously defined\" }\n+  end type a\n+  type       ::   b\n+    type(a)    :: i\n+  end type b\n+  type (a)   :: foo\n+end module snafu\n+\n+!  use snafu\n+!  foo%v = 1\n+!  end"}, {"sha": "707df9c49d243fa990dd82793285fb456f062d7a", "filename": "gcc/testsuite/gfortran.dg/implicit_actual.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/976e21f67321ad483895471c5f285a1880a47b4a/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_actual.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/976e21f67321ad483895471c5f285a1880a47b4a/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_actual.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_actual.f90?ref=976e21f67321ad483895471c5f285a1880a47b4a", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do compile }\n+! { dg-options \"-O0\" }\n+! Tests patch for problem that was found whilst investigating\n+! PR24158. The call to foo would cause an ICE because the\n+! actual argument was of a type that was not defined.\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+!\n+module global\n+  type :: t2\n+    type(t3), pointer :: d\n+  end type t2\n+end module global\n+\n+program snafu\n+  use global\n+  implicit type (t3) (z)\n+\n+  call foo (zin) ! { dg-error \"defined|Type/rank\" }\n+\n+contains\n+\n+  subroutine foo (z)\n+\n+    type :: t3\n+      integer :: i\n+    end type t3\n+\n+    type(t3)  :: z\n+    z%i = 1\n+\n+  end subroutine foo\n+end program snafu\n+"}]}