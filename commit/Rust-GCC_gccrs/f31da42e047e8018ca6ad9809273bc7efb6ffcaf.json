{"sha": "f31da42e047e8018ca6ad9809273bc7efb6ffcaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMxZGE0MmUwNDdlODAxOGNhNmFkOTgwOTI3M2JjN2VmYjZmZmNhZg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-08-06T12:39:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-08-06T13:32:30Z"}, "message": "tree-optimization/101801 - remove vect_worthwhile_without_simd_p\n\nThis removes the cost part of vect_worthwhile_without_simd_p, retaining\nonly the correctness bits.  The reason is that the cost heuristic\ndo not properly account for SLP plus the check whether \"without simd\"\napplies misfires for AVX512 mask vectors at the moment, leading to\nmissed vectorizations there.\n\nAny costing decision should take place in the cost modeling, no\nsingle stmt is to disable all vectorization on its own.\n\n2021-08-06  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101801\n\t* tree-vectorizer.h (vect_worthwhile_without_simd_p): Rename...\n\t(vect_can_vectorize_without_simd_p): ... to this.\n\t* tree-vect-loop.c (vect_worthwhile_without_simd_p): Rename...\n\t(vect_can_vectorize_without_simd_p): ... to this and fold\n\tin vect_min_worthwhile_factor.\n\t(vect_min_worthwhile_factor): Remove.\n\t(vectorizable_reduction): Adjust and remove the cost part.\n\t* tree-vect-stmts.c (vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.", "tree": {"sha": "94fce0bf3db36f9a3feefe87c26f67c2321c7a5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94fce0bf3db36f9a3feefe87c26f67c2321c7a5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f31da42e047e8018ca6ad9809273bc7efb6ffcaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31da42e047e8018ca6ad9809273bc7efb6ffcaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f31da42e047e8018ca6ad9809273bc7efb6ffcaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31da42e047e8018ca6ad9809273bc7efb6ffcaf/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2a984a3570b908a44a35e43bb48f0a05196156a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a984a3570b908a44a35e43bb48f0a05196156a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2a984a3570b908a44a35e43bb48f0a05196156a"}], "stats": {"total": 71, "additions": 10, "deletions": 61}, "files": [{"sha": "37c7daa7f9efb70f17650572fb2dd6315f553b9c", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31da42e047e8018ca6ad9809273bc7efb6ffcaf/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31da42e047e8018ca6ad9809273bc7efb6ffcaf/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f31da42e047e8018ca6ad9809273bc7efb6ffcaf", "patch": "@@ -7227,24 +7227,13 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n           if (dump_enabled_p ())\n             dump_printf (MSG_NOTE, \"op not supported by target.\\n\");\n \t  if (maybe_ne (GET_MODE_SIZE (vec_mode), UNITS_PER_WORD)\n-\t      || !vect_worthwhile_without_simd_p (loop_vinfo, code))\n+\t      || !vect_can_vectorize_without_simd_p (code))\n \t    ok = false;\n \t  else\n \t    if (dump_enabled_p ())\n \t      dump_printf (MSG_NOTE, \"proceeding using word mode.\\n\");\n         }\n \n-      /* Worthwhile without SIMD support?  */\n-      if (ok\n-\t  && !VECTOR_MODE_P (TYPE_MODE (vectype_in))\n-\t  && !vect_worthwhile_without_simd_p (loop_vinfo, code))\n-        {\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not worthwhile without SIMD support.\\n\");\n-\t  ok = false;\n-        }\n-\n       /* lane-reducing operations have to go through vect_transform_reduction.\n          For the other cases try without the single cycle optimization.  */\n       if (!ok)\n@@ -7948,46 +7937,28 @@ vectorizable_phi (vec_info *,\n }\n \n \n-/* Function vect_min_worthwhile_factor.\n+/* Return true if we can emulate CODE on an integer mode representation\n+   of a vector.  */\n \n-   For a loop where we could vectorize the operation indicated by CODE,\n-   return the minimum vectorization factor that makes it worthwhile\n-   to use generic vectors.  */\n-static unsigned int\n-vect_min_worthwhile_factor (enum tree_code code)\n+bool\n+vect_can_vectorize_without_simd_p (tree_code code)\n {\n   switch (code)\n     {\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case NEGATE_EXPR:\n-      return 4;\n-\n     case BIT_AND_EXPR:\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n     case BIT_NOT_EXPR:\n-      return 2;\n+      return true;\n \n     default:\n-      return INT_MAX;\n+      return false;\n     }\n }\n \n-/* Return true if VINFO indicates we are doing loop vectorization and if\n-   it is worth decomposing CODE operations into scalar operations for\n-   that loop's vectorization factor.  */\n-\n-bool\n-vect_worthwhile_without_simd_p (vec_info *vinfo, tree_code code)\n-{\n-  loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n-  unsigned HOST_WIDE_INT value;\n-  return (loop_vinfo\n-\t  && LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&value)\n-\t  && value >= vect_min_worthwhile_factor (code));\n-}\n-\n /* Function vectorizable_induction\n \n    Check if STMT_INFO performs an induction computation that can be vectorized."}, {"sha": "5b94d41e2929f19dc2fb6d2b3f85ffa0d7ff7c9e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31da42e047e8018ca6ad9809273bc7efb6ffcaf/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31da42e047e8018ca6ad9809273bc7efb6ffcaf/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f31da42e047e8018ca6ad9809273bc7efb6ffcaf", "patch": "@@ -5685,24 +5685,13 @@ vectorizable_shift (vec_info *vinfo,\n       /* Check only during analysis.  */\n       if (maybe_ne (GET_MODE_SIZE (vec_mode), UNITS_PER_WORD)\n \t  || (!vec_stmt\n-\t      && !vect_worthwhile_without_simd_p (vinfo, code)))\n+\t      && !vect_can_vectorize_without_simd_p (code)))\n         return false;\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"proceeding using word mode.\\n\");\n     }\n \n-  /* Worthwhile without SIMD support?  Check only during analysis.  */\n-  if (!vec_stmt\n-      && !VECTOR_MODE_P (TYPE_MODE (vectype))\n-      && !vect_worthwhile_without_simd_p (vinfo, code))\n-    {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not worthwhile without SIMD support.\\n\");\n-      return false;\n-    }\n-\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       if (slp_node\n@@ -6094,24 +6083,13 @@ vectorizable_operation (vec_info *vinfo,\n                          \"op not supported by target.\\n\");\n       /* Check only during analysis.  */\n       if (maybe_ne (GET_MODE_SIZE (vec_mode), UNITS_PER_WORD)\n-\t  || (!vec_stmt && !vect_worthwhile_without_simd_p (vinfo, code)))\n+\t  || (!vec_stmt && !vect_can_vectorize_without_simd_p (code)))\n         return false;\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"proceeding using word mode.\\n\");\n     }\n \n-  /* Worthwhile without SIMD support?  Check only during analysis.  */\n-  if (!VECTOR_MODE_P (vec_mode)\n-      && !vec_stmt\n-      && !vect_worthwhile_without_simd_p (vinfo, code))\n-    {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not worthwhile without SIMD support.\\n\");\n-      return false;\n-    }\n-\n   int reduc_idx = STMT_VINFO_REDUC_IDX (stmt_info);\n   vec_loop_masks *masks = (loop_vinfo ? &LOOP_VINFO_MASKS (loop_vinfo) : NULL);\n   internal_fn cond_fn = get_conditional_internal_fn (code);"}, {"sha": "de0ecf86478ec8df8a42d906a827bd7ccab006d1", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31da42e047e8018ca6ad9809273bc7efb6ffcaf/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31da42e047e8018ca6ad9809273bc7efb6ffcaf/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f31da42e047e8018ca6ad9809273bc7efb6ffcaf", "patch": "@@ -2061,7 +2061,7 @@ extern bool vectorizable_lc_phi (loop_vec_info, stmt_vec_info,\n \t\t\t\t gimple **, slp_tree);\n extern bool vectorizable_phi (vec_info *, stmt_vec_info, gimple **, slp_tree,\n \t\t\t      stmt_vector_for_cost *);\n-extern bool vect_worthwhile_without_simd_p (vec_info *, tree_code);\n+extern bool vect_can_vectorize_without_simd_p (tree_code);\n extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,\n \t\t\t\t\tstmt_vector_for_cost *,\n \t\t\t\t\tstmt_vector_for_cost *,"}]}