{"sha": "8d08fdba598cf87c3794df53beae1026345ebb02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQwOGZkYmE1OThjZjg3YzM3OTRkZjUzYmVhZTEwMjYzNDVlYmIwMg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-02-24T01:02:37Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-02-24T01:02:37Z"}, "message": "Initial revision\n\nFrom-SVN: r6613", "tree": {"sha": "c9a38e97d26c8dcc0a3aab71de38da5f8fdcc3bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9a38e97d26c8dcc0a3aab71de38da5f8fdcc3bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d08fdba598cf87c3794df53beae1026345ebb02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d08fdba598cf87c3794df53beae1026345ebb02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d08fdba598cf87c3794df53beae1026345ebb02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d08fdba598cf87c3794df53beae1026345ebb02/comments", "author": null, "committer": null, "parents": [{"sha": "f8a9e02bc1443b3300c024454d7700f7bbe6967c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8a9e02bc1443b3300c024454d7700f7bbe6967c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8a9e02bc1443b3300c024454d7700f7bbe6967c"}], "stats": {"total": 67714, "additions": 67714, "deletions": 0}, "files": [{"sha": "686b5b54635ecc22a5b59a09f26f342ce95d4828", "filename": "gcc/cp/Makefile.in", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,318 @@\n+# Makefile for GNU C++ compiler.\n+#   Copyright (C) 1987, 88, 90, 91, 92, 93, 1994 Free Software Foundation, Inc.\n+\n+#This file is part of GNU CC.\n+\n+#GNU CC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 2, or (at your option)\n+#any later version.\n+\n+#GNU CC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GNU CC; see the file COPYING.  If not, write to\n+#the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+# The targets for external use include:\n+# all, doc, TAGS, mostlyclean, clean, distclean, realclean,\n+\n+# Suppress smart makes who think they know how to automake Yacc files\n+.y.c:\n+\n+# Variables that exist for you to override.\n+# See below for how to change them for certain systems.\n+\n+INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config\n+\n+# Various ways of specifying flags for compilations:  \n+# CFLAGS is for the user to override to, e.g., do a bootstrap with -O2.\n+# BOOT_CFLAGS is the value of CFLAGS to pass\n+# to the stage2 and stage3 compilations\n+# XCFLAGS is used for most compilations but not when using the GCC just built.\n+XCFLAGS =\n+CFLAGS = -g\n+BOOT_CFLAGS = -O $(CFLAGS)\n+# These exists to be overridden by the x-* and t-* files, respectively.\n+X_CFLAGS =\n+T_CFLAGS =\n+\n+X_CPPFLAGS =\n+T_CPPFLAGS =\n+\n+CC = cc\n+# CYGNUS LOCAL: we use byacc instead of bison, DO NOT SEND TO RMS\n+BISON = `if [ -f ../../byacc/byacc ] ; then echo ../../byacc/byacc ;  else echo byacc ; fi`\n+BISONFLAGS =\n+LEX = `if [ -f ../../flex/flex ] ; then echo ../../flex/flex ;  else echo flex ; fi`\n+LEXFLAGS=\n+AR = ar\n+OLDAR_FLAGS = qc\n+AR_FLAGS = rc\n+SHELL = /bin/sh\n+MAKEINFO = makeinfo\n+TEXI2DVI = texi2dvi\n+\n+# Define this as & to perform parallel make on a Sequent.\n+# Note that this has some bugs, and it seems currently necessary \n+# to compile all the gen* files first by hand to avoid erroneous results.\n+P =\n+\n+# This is used instead of ALL_CFLAGS when compiling with GCC_FOR_TARGET.\n+# It omits XCFLAGS, and specifies -B./.\n+# It also specifies -B$(tooldir)/ to find as and ld for a cross compiler.\n+GCC_CFLAGS=$(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS)\n+\n+# Tools to use when building a cross-compiler.\n+# These are used because `configure' appends `cross-make'\n+# to the makefile when making a cross-compiler.\n+\n+# CYGNUS LOCAL: we don't use cross-make.  Instead we use the tools\n+# from the build tree, if they are available.\n+# program_transform_name and objdir are set by configure.in.\n+program_transform_name =\n+objdir = .\n+\n+target= ... `configure' substitutes actual target name here.\n+xmake_file= ... `configure' substitutes actual x- file name here.\n+tmake_file= ... `configure' substitutes actual t- file name here.\n+#version=`sed -e 's/.*\\\"\\([^ \\\"]*\\)[ \\\"].*/\\1/' < $(srcdir)/version.c`\n+#mainversion=`sed -e 's/.*\\\"\\([0-9]*\\.[0-9]*\\).*/\\1/' < $(srcdir)/version.c`\n+\n+# Directory where sources are, from where we are.\n+srcdir = .\n+\n+# Change this to a null string if obstacks are installed in the\n+# system library.\n+OBSTACK=obstack.o\n+\n+# Directory to link to, when using the target `maketest'.\n+DIR = ../gcc\n+\n+# Choose the real default target.\n+ALL=all\n+\n+# End of variables for you to override.\n+\n+# Definition of `all' is here so that new rules inserted by sed\n+# do not specify the default target.\n+all: all.indirect\n+\n+# This tells GNU Make version 3 not to put all variables in the environment.\n+.NOEXPORT:\n+\n+# sed inserts variable overrides after the following line.\n+####target overrides\n+####host overrides\n+####cross overrides\n+####build overrides\n+####site overrides\n+\f\n+# Now figure out from those variables how to compile and link.\n+\n+all.indirect: Makefile ../cc1plus\n+\n+# IN_GCC tells obstack.h to use gstddef.h.\n+INTERNAL_CFLAGS = $(CROSS) -DIN_GCC\n+\n+# This is the variable actually used when we compile.\n+ALL_CFLAGS = $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS) $(XCFLAGS)\n+\n+# Likewise.\n+ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)\n+\n+SUBDIR_OBSTACK = `if [ x$(OBSTACK) != x ]; then echo ../$(OBSTACK); else true; fi`\n+SUBDIR_USE_ALLOCA = `if [ x$(USE_ALLOCA) != x ]; then echo ../$(USE_ALLOCA); else true; fi`\n+SUBDIR_MALLOC = `if [ x$(MALLOC) != x ]; then echo ../$(MALLOC); else true; fi`\n+\n+# How to link with both our special library facilities\n+# and the system's installed libraries.\n+LIBS = $(SUBDIR_OBSTACK) $(SUBDIR_USE_ALLOCA) $(SUBDIR_MALLOC) $(CLIB)\n+\n+# Always use -I$(srcdir)/config when compiling.\n+.c.o:\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n+# This tells GNU make version 3 not to export all the variables\n+# defined in this file into the environment.\n+.NOEXPORT:\n+\f\n+# Lists of files for various purposes.\n+\n+# Language-specific object files for g++\n+\n+CXX_OBJS = call.o decl.o errfn.o expr.o pt.o sig.o typeck2.o \\\n+ class.o decl2.o error.o gc.o lex.o parse.o ptree.o spew.o typeck.o cvt.o \\\n+ edsel.o except.o init.o method.o search.o tree.o xref.o\n+\n+# Files specific to the C interpreter bytecode compiler(s).\n+BC_OBJS = ../bc-emit.o ../bc-optab.o\n+\n+# Language-independent object files.\n+OBJS = ../toplev.o ../version.o ../tree.o ../print-tree.o ../stor-layout.o ../fold-const.o \\\n+ ../function.o ../stmt.o ../expr.o ../calls.o ../expmed.o ../explow.o ../optabs.o ../varasm.o \\\n+ ../rtl.o ../print-rtl.o ../rtlanal.o ../emit-rtl.o ../real.o \\\n+ ../dbxout.o ../sdbout.o ../dwarfout.o ../xcoffout.o \\\n+ ../integrate.o ../jump.o ../cse.o ../loop.o ../unroll.o ../flow.o ../stupid.o ../combine.o \\\n+ ../regclass.o ../local-alloc.o ../global.o ../reload.o ../reload1.o ../caller-save.o \\\n+ ../insn-peep.o ../reorg.o ../sched.o ../final.o ../recog.o ../reg-stack.o \\\n+ ../insn-opinit.o ../insn-recog.o ../insn-extract.o ../insn-output.o ../insn-emit.o \\\n+ ../insn-attrtab.o ../aux-output.o ../getpwd.o ../convert.o \\\n+ ../c-common.o\n+\n+compiler: ../cc1plus\n+../cc1plus: $(P) $(CXX_OBJS) $(OBJS) $(BC_OBJS) $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o ../cc1plus \\\n+\t      $(CXX_OBJS) $(OBJS) $(BC_OBJS) $(LIBS)\n+\n+\f\n+Makefile: $(srcdir)/Makefile.in $(srcdir)/../configure\n+\tcd ..; $(SHELL) config.status\n+\n+native: config.status ../cc1plus\n+\n+# Really, really stupid make features, such as SUN's KEEP_STATE, may force\n+# a target to build even if it is up-to-date.  So we must verify that\n+# config.status does not exist before failing.\n+config.status:\n+\t@if [ ! -f config.status ] ; then \\\n+\t  echo You must configure gcc.  Look at the ../INSTALL file for details.; \\\n+\t  false; \\\n+\telse \\\n+\t  true; \\\n+\tfi\n+\n+\f\n+# Compiling object files from source files.\n+\n+# Note that dependencies on obstack.h are not written\n+# because that file is not part of GCC.\n+# Dependencies on gvarargs.h are not written\n+# because all that file does, when not compiling with GCC,\n+# is include the system varargs.h.\n+\n+# C++ language specific files.\n+\n+TREE_H = ../tree.h ../real.h ../tree.def ../machmode.h ../machmode.def\n+CXX_TREE_H = $(TREE_H) cp-tree.h tree.def\n+\n+parse.o : $(srcdir)/parse.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h lex.h\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) \\\n+  `echo $(srcdir)/parse.c | sed 's,^\\./,,'`\n+\n+$(srcdir)/parse.c $(srcdir)/parse.h : $(srcdir)/parse.y\n+\t@echo expect 28 shift/reduce conflicts, 14 reduce/reduce conflicts.\n+\tcd $(srcdir); $(BISON) $(BISONFLAGS) -d -o parse.c parse.y\n+\tcd $(srcdir); grep '^#define[ \t]*YYEMPTY' parse.c >>parse.h\n+\n+# hash.h really depends on $(srcdir)/gxx.gperf.\n+# But this would screw things for people that don't have gperf,\n+# if gxx.gpref got touched, say.\n+# Thus you have to remove hash.h to force it to be re-made.\n+$(srcdir)/hash.h:\n+\tgperf -p -j1 -g -o -t -N is_reserved_word '-k1,4,7,$$' \\\n+\t\t$(srcdir)/gxx.gperf >$(srcdir)/hash.h\n+\n+spew.o : spew.c $(CONFIG_H) $(CXX_TREE_H) \\\n+  parse.h ../flags.h lex.h\n+lex.o : lex.c $(CONFIG_H) $(CXX_TREE_H) \\\n+  parse.h input.c ../flags.h hash.h lex.h\n+decl.o : decl.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h \\\n+  lex.h decl.h ../stack.h\n+decl2.o : decl2.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h \\\n+  lex.h decl.h\n+typeck2.o : typeck2.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h\n+typeck.o : typeck.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h $(RTL_H)\n+class.o : class.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h\n+call.o : call.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h class.h\n+init.o : init.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h $(RTL_H)\n+method.o : method.c $(CONFIG_H) $(CXX_TREE_H) class.h\n+cvt.o : cvt.c $(CONFIG_H) $(CXX_TREE_H) class.h\n+search.o : search.c $(CONFIG_H) $(CXX_TREE_H) ../stack.h ../flags.h\n+tree.o : tree.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h\n+ptree.o : ptree.c $(CONFIG_H) $(CXX_TREE_H)\n+gc.o : gc.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h\n+except.o : except.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h $(RTL_H)\n+expr.o : expr.c $(CONFIG_H) $(CXX_TREE_H) $(RTL_H) ../flags.h \\\n+  ../expr.h ../insn-codes.h\n+edsel.o : edsel.c $(CONFIG_H) $(CXX_TREE_H) ../stack.h ../flags.h\n+xref.o : xref.c $(CONFIG_H) $(CXX_TREE_H) ../input.h\n+pt.o : pt.c $(CONFIG_H) $(CXX_TREE_H) decl.h parse.h\n+error.o : error.c $(CONFIG_H) $(CXX_TREE_H)\n+errfn.o : errfn.c $(CONFIG_H) $(CXX_TREE_H)\n+sig.o : sig.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h\n+\n+doc: info\n+info:\n+\n+dvi:\n+\n+\f\n+# Deletion of files made during compilation.\n+# There are four levels of this:\n+#   `mostlyclean', `clean', `distclean' and `realclean'.\n+# `mostlyclean' is useful while working on a particular type of machine.\n+# It deletes most, but not all, of the files made by compilation.\n+# It does not delete libgcc.a or its parts, so it won't have to be recompiled.\n+# `clean' deletes everything made by running `make all'.\n+# `distclean' also deletes the files made by config.\n+# `realclean' also deletes everything that could be regenerated automatically.\n+\n+\n+mostlyclean: \n+# Delete the stamp files.\n+\t-rm -f stamp-* tmp-*\n+# Delete debugging dump files.\n+\t-rm -f *.greg *.lreg *.combine *.flow *.cse *.jump *.rtl *.tree *.loop\n+\t-rm -f *.dbr *.jump2 *.sched *.cse2 *.sched2 *.stack\n+# Delete unwanted output files from TeX.\n+\t-rm -f *.toc *.log *.vr *.fn *.cp *.tp *.ky *.pg\n+# Delete sorted indices we don't actually use.\n+\t-rm -f gcc.vrs gcc.kys gcc.tps gcc.pgs gcc.fns\n+\t-rm -f *.o ../cc1plus\n+\n+# Delete all files made by compilation\n+# that don't exist in the distribution.\n+clean: mostlyclean\n+\t-rm -f *.dvi\n+\n+# Delete all files that users would normally create\n+# while building and installing GCC.\n+distclean: clean\n+\t-rm -f config.status Makefile *.oaux\n+\t-rm -f parse.output\n+\n+# Delete anything likely to be found in the source directory\n+# that shouldn't be in the distribution.\n+extraclean: distclean\n+\t-rm -rf =* ./\"#\"* *~*\n+\t-rm -f patch* *.orig *.rej\n+\t-rm -f *.dvi *.oaux *.d *.[zZ] *.gz\n+\t-rm -f *.s *.s[0-9] *.i\n+\n+# Get rid of every file that's generated from some other file.\n+# Most of these files ARE PRESENT in the GCC distribution.\n+realclean: distclean\n+\t-rm -f TAGS\n+\t-rm -f parse.c parse.h parse.output\n+\f\n+# These exist for maintenance purposes.\n+\n+# This target creates the files that can be rebuilt, but go in the\n+# distribution anyway.\n+distdir: parse.c hash.h\n+\n+# Update the tags table.\n+TAGS: force\n+\tcd $(srcdir) ;\t\t\t\t\t\t\t\\\n+\tetags *.c *.h ;\t\t\t\t\t\t\t\\\n+\techo 'l' | tr 'l' '\\f' >> TAGS ;\t\t\t\t\\\n+\techo 'parse.y,0' >> TAGS ; \t\t\t\t\t\\\n+\tetags -a ../*.h ../*.c;\n+\n+.PHONY: clean realclean TAGS\n+\n+force:"}, {"sha": "02fc964e3aee4956194a79de5f41cb068b1b9192", "filename": "gcc/cp/call.c", "status": "added", "additions": 4205, "deletions": 0, "changes": 4205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02"}, {"sha": "e64001051124fb9f6e811662b528fff1c320b94e", "filename": "gcc/cp/class.c", "status": "added", "additions": 5048, "deletions": 0, "changes": 5048, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02"}, {"sha": "fb25a5f56b4fa8b862de8f9432fa827e98833e59", "filename": "gcc/cp/class.h", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fclass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fclass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.h?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,161 @@\n+/* Variables and structures for overloading rules.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* The following structure is used when comparing various alternatives\n+   for overloading.  The unsigned quantity `strikes.i' is used\n+   for fast comparison of two possibilities.  This number is an\n+   aggregate of four constituents:\n+\n+     EVIL: if this is non-zero, then the candidate should not be considered\n+     ELLIPSIS: if this is non-zero, then some actual argument has been matched\n+               against an ellipsis\n+     USER: if this is non-zero, then a user-defined type conversion is needed\n+     B_OR_D: if this is non-zero, then use a base pointer instead of the\n+             type of the pointer we started with.\n+     EASY: if this is non-zero, then we have a builtin conversion\n+           (such as int to long, int to float, etc) to do.\n+\n+   If two candidates require user-defined type conversions, and the\n+   type conversions are not identical, then an ambiguity error\n+   is reported.\n+\n+   If two candidates agree on user-defined type conversions,\n+   and one uses pointers of strictly higher type (derived where\n+   another uses base), then that alternative is silently chosen.\n+\n+   If two candidates have a non-monotonic derived/base pointer\n+   relationship, and/or a non-monotonic easy conversion relationship,\n+   then a warning is emitted to show which paths are possible, and\n+   which one is being chosen.\n+\n+   For example:\n+\n+   int i;\n+   double x;\n+\n+   overload f;\n+   int f (int, int);\n+   double f (double, double);\n+\n+   f (i, x);\t// draws a warning\n+\n+   struct B\n+   {\n+     f (int);\n+   } *bb;\n+   struct D : B\n+   {\n+     f (double);\n+   } *dd;\n+\n+   dd->f (x);\t// exact match\n+   dd->f (i);\t// draws warning\n+\n+   Note that this technique really only works for 255 arguments.  Perhaps\n+   this is not enough.  */\n+\n+/* These macros and harshness_code are used by the NEW METHOD.  */\n+#define EVIL_CODE (1<<7)\n+#define CONST_CODE (1<<6)\n+#define ELLIPSIS_CODE (1<<5)\n+#define USER_CODE (1<<4)\n+#define STD_CODE (1<<3)\n+#define PROMO_CODE (1<<2)\n+#define QUAL_CODE (1<<1)\n+#define TRIVIAL_CODE (1<<0)\n+\n+struct harshness_code\n+{\n+  /* What kind of conversion is involved.  */\n+  unsigned short code;\n+\n+  /* The inheritance distance.  */\n+  short distance;\n+\n+  /* For a PROMO_CODE, Any special penalties involved in integral conversions.\n+     This exists because $4.1 of the ARM states that something like\n+     `short unsigned int' should promote to `int', not `unsigned int'.\n+     If, for example, it tries to match two fns, f(int) and f(unsigned),\n+     f(int) should be a better match than f(unsigned) by this rule.  Without\n+     this extra metric, they both only appear as \"integral promotions\", which\n+     will lead to an ambiguity.\n+     For a TRIVIAL_CODE, This is also used by build_overload_call_real and\n+     convert_harshness to keep track of other information we need.  */\n+  unsigned short int_penalty;\n+};\n+\n+struct candidate\n+{\n+  /* OLD METHOD */\n+  unsigned char evil;\t      /* !0 if this will never convert.  */\n+  unsigned char ellipsis;     /* !0 if a match against an ellipsis occurred */\n+  unsigned char user;\t      /* !0 if at least one user-defined type conv.  */\n+  unsigned short b_or_d;      /* count number of derived->base or\n+\t\t\t\t base->derived conv.  */\n+  unsigned short easy;\t      /* count number of builtin type conv.  */\n+\n+  /* NEW METHOD */\n+  struct harshness_code h;\t/* Used for single-argument conversions.  */\n+\n+  int h_len;\t\t\t/* The length of the harshness vector.  */\n+\n+  /* Both methods.  */\n+  tree function;\t\t/* A FUNCTION_DECL */\n+  tree basetypes;\t\t/* The path to function. */\n+  tree arg;\t\t\t/* first parm to function.  */\n+\n+  /* This union is only here while we maintain both the old and new\n+     argument matching schemes.  When it goes away, all v.ansi_harshness\n+     references will be just `harshness'.  */\n+  union\n+    {\n+      /* Indexed by argument number, encodes evil, user, d_to_b, and easy\n+\t strikes for that argument.  At end of array, we store the index+1\n+\t of where we started using default parameters, or 0 if there are\n+\t none.  */\n+      struct harshness_code *ansi_harshness; /* NEW METHOD */\n+      unsigned short *old_harshness;  /* OLD METHOD */\n+    } v;\n+\n+  union\n+    {\n+      tree field;\t\t/* If no evil strikes, the FUNCTION_DECL of\n+\t\t\t\t   the function (if a member function).  */\n+      int bad_arg;\t\t/* the index of the first bad argument:\n+\t\t\t\t   0 if no bad arguments\n+\t\t\t\t   > 0 is first bad argument\n+\t\t\t\t   -1 if extra actual arguments\n+\t\t\t\t   -2 if too few actual arguments.\n+\t\t\t\t   -3 if const/non const method mismatch.\n+\t\t\t\t   -4 if type unification failed.\n+\t\t\t\t   -5 if contravariance violation.  */\n+    } u;\n+};\n+int rank_for_overload ();\n+\n+/* Variables shared between cp-class.c and cp-call.c.  */\n+\n+extern int n_vtables;\n+extern int n_vtable_entries;\n+extern int n_vtable_searches;\n+extern int n_vtable_elems;\n+extern int n_convert_harshness;\n+extern int n_compute_conversion_costs;\n+extern int n_build_method_call;\n+extern int n_inner_fields_searched;"}, {"sha": "dc4bbdad0850648cc20690d4ba815f71cb2fb495", "filename": "gcc/cp/cp-tree.def", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,92 @@\n+/* This file contains the definitions and documentation for the\n+   additional tree codes used in the GNU C++ compiler (see tree.def\n+   for the standard codes).\n+   Copyright (C) 1987, 1988, 1990, 1993 Free Software Foundation, Inc.\n+   Hacked by Michael Tiemann (tiemann@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+ \n+/* Reference to the contents of an offset\n+   (a value whose type is an OFFSET_TYPE).\n+   Operand 0 is the object within which the offset is taken.\n+   Operand 1 is the offset.  The language independent OFFSET_REF\n+   just won't work for us.  */\n+DEFTREECODE (CP_OFFSET_REF, \"cp_offset_ref\", \"r\", 2)\n+\n+/* For DELETE_EXPR, operand 0 is the store to be destroyed.\n+   Operand 1 is the value to pass to the destroying function\n+   saying whether the store should be deallocated as well.  */\n+DEFTREECODE (DELETE_EXPR, \"dl_expr\", \"e\", 2)\n+\n+/* Value is reference to particular overloaded class method.\n+   Operand 0 is the class name (an IDENTIFIER_NODE);\n+   operand 1 is the field (also an IDENTIFIER_NODE).\n+   The COMPLEXITY field holds the class level (usually 0).  */\n+DEFTREECODE (SCOPE_REF, \"scope_ref\", \"r\", 2)\n+\n+/* When composing an object with a member, this is the result.\n+   Operand 0 is the object.  Operand 1 is the member (usually\n+   a dereferenced pointer to member).  */\n+DEFTREECODE (MEMBER_REF, \"member_ref\", \"r\", 2)\n+\n+/* Type conversion operator in C++.  TREE_TYPE is type that this\n+   operator converts to.  Operand is expression to be converted.  */\n+DEFTREECODE (TYPE_EXPR, \"type_expr\", \"e\", 1)\n+\n+/* For CPLUS_NEW_EXPR, operand 0 is function which performs initialization,\n+   operand 1 is argument list to initialization function,\n+   and operand 2 is the slot which was allocated for this expression.  */\n+DEFTREECODE (NEW_EXPR, \"nw_expr\", \"e\", 3)\n+\n+/* Distinguish variables that are only used to identify exceptions\n+   that were caught.  Only the DECL_NAME (and TREE_CHAIN)\n+   is really used.  */\n+DEFTREECODE (CPLUS_CATCH_DECL, \"catch_decl\", \"d\", 0)\n+\n+/* Template definition.  The following fields have the specified uses,\n+   although there are other macros in cp-tree.h that should be used for\n+   accessing this data.\n+        DECL_ARGUMENTS          template parm vector\n+        DECL_TEMPLATE_INFO      template text &c\n+\tDECL_VINDEX\t\tlist of instantiations already produced;\n+\t\t\t\tonly done for functions so far\n+   For class template:\n+        DECL_INITIAL            associated templates (methods &c)\n+        DECL_RESULT             null\n+   For non-class templates:\n+\tTREE_TYPE\t\ttype of object to be constructed\n+        DECL_RESULT             decl for object to be created\n+                                (e.g., FUNCTION_DECL with tmpl parms used)\n+ */\n+DEFTREECODE (TEMPLATE_DECL, \"template_decl\", \"d\", 0)\n+\n+/* Index into a template parameter list.  This parameter must be a type.\n+   Use TYPE_FIELDS to find parmlist and index.  */\n+DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", \"t\", 0)\n+\n+/* Index into a template parameter list.  This parameter must not be a\n+   type.  */\n+DEFTREECODE (TEMPLATE_CONST_PARM, \"template_const_parm\", \"c\", 2)\n+\n+/* For uninstantiated parameterized types.\n+        TYPE_VALUES     tree list:\n+                TREE_PURPOSE    template decl\n+                TREE_VALUE      parm vector\n+                TREE_CHAIN      null\n+   Other useful fields to be defined later.  */\n+DEFTREECODE (UNINSTANTIATED_P_TYPE, \"uninstantiated_p_type\", \"t\", 0)"}, {"sha": "b431e160a6b2e220dd1621be8a2365feaf8d0018", "filename": "gcc/cp/cp-tree.h", "status": "added", "additions": 2228, "deletions": 0, "changes": 2228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,2228 @@\n+/* Definitions for C++ parsing and type checking.\n+   Copyright (C) 1987, 1993 Free Software Foundation, Inc.\n+   Hacked by Michael Tiemann (tiemann@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef _CP_TREE_H\n+#define _CP_TREE_H\n+\n+/* Borrow everything that is C from c-tree.h,\n+   but do so by copy, not by inclusion, since c-tree.h defines\n+   lang_identifier.  */\n+\n+#ifndef STDIO_PROTO\n+#ifdef BUFSIZ\n+#define STDIO_PROTO(ARGS) PROTO(ARGS)\n+#else\n+#define STDIO_PROTO(ARGS) ()\n+#endif\n+#endif\n+\n+/* Language-dependent contents of an identifier.  */\n+\n+struct lang_identifier\n+{\n+  struct tree_identifier ignore;\n+  tree global_value, local_value;\n+  tree class_value;\n+  tree class_template_info;\n+  struct lang_id2 *x;\n+};\n+\n+struct lang_id2\n+{\n+  tree label_value, implicit_decl;\n+  tree type_desc, as_list, error_locus;\n+};\n+\n+/* To identify to the debug emitters if it should pay attention to the\n+   flag `-Wtemplate-debugging'.  */\n+#define HAVE_TEMPLATES 1\n+\n+/* Macros for access to language-specific slots in an identifier.  */\n+\n+#define IDENTIFIER_GLOBAL_VALUE(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->global_value)\n+#define IDENTIFIER_CLASS_VALUE(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->class_value)\n+#define IDENTIFIER_LOCAL_VALUE(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->local_value)\n+#define IDENTIFIER_TEMPLATE(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->class_template_info)\n+\n+#define IDENTIFIER_TYPE_VALUE(NODE) (TREE_TYPE (NODE))\n+#define SET_IDENTIFIER_TYPE_VALUE(NODE,TYPE) (TREE_TYPE (NODE) = TYPE)\n+#define IDENTIFIER_HAS_TYPE_VALUE(NODE) (TREE_TYPE (NODE) ? 1 : 0)\n+#define IDENTIFIER_HAS_CLASS_TYPE_VALUE(NODE) \\\n+  (IDENTIFIER_CLASS_VALUE (NODE) && TREE_TYPE (IDENTIFIER_CLASS_VALUE (NODE)))\n+#define IDENTIFIER_CLASS_TYPE_VALUE(NODE) \\\n+  TREE_TYPE (IDENTIFIER_CLASS_VALUE (NODE))\n+\n+#define LANG_ID_FIELD(NAME,NODE) \\\n+  (((struct lang_identifier *)(NODE))->x \\\n+   ? ((struct lang_identifier *)(NODE))->x->NAME : 0)\n+#define SET_LANG_ID(NODE,VALUE,NAME) \\\n+  (((struct lang_identifier *)(NODE))->x == 0\t\t\t\t    \\\n+   ? ((struct lang_identifier *)(NODE))->x\t\t\t\t    \\\n+      = (struct lang_id2 *)perm_calloc (1, sizeof (struct lang_id2)) : 0,   \\\n+   ((struct lang_identifier *)(NODE))->x->NAME = (VALUE))\n+\n+#define IDENTIFIER_LABEL_VALUE(NODE)\t    LANG_ID_FIELD(label_value, NODE)\n+#define SET_IDENTIFIER_LABEL_VALUE(NODE,VALUE)   \\\n+\tSET_LANG_ID(NODE, VALUE, label_value)\n+\n+#define IDENTIFIER_IMPLICIT_DECL(NODE)\t    LANG_ID_FIELD(implicit_decl, NODE)\n+#define SET_IDENTIFIER_IMPLICIT_DECL(NODE,VALUE) \\\n+\tSET_LANG_ID(NODE, VALUE, implicit_decl)\n+\n+#define IDENTIFIER_AS_DESC(NODE)\t    LANG_ID_FIELD(type_desc, NODE)\n+#define SET_IDENTIFIER_AS_DESC(NODE,DESC)\t\\\n+\tSET_LANG_ID(NODE, DESC, type_desc)\n+\n+#define IDENTIFIER_AS_LIST(NODE)\t    LANG_ID_FIELD(as_list, NODE)\n+#define SET_IDENTIFIER_AS_LIST(NODE,LIST)\t\\\n+\tSET_LANG_ID(NODE, LIST, as_list)\n+\n+#define IDENTIFIER_ERROR_LOCUS(NODE)\t    LANG_ID_FIELD(error_locus, NODE)\n+#define SET_IDENTIFIER_ERROR_LOCUS(NODE,VALUE)\t\\\n+\tSET_LANG_ID(NODE, VALUE, error_locus)\n+\n+\n+#define IDENTIFIER_VIRTUAL_P(NODE) TREE_LANG_FLAG_1(NODE)\n+\n+/* Nonzero if this identifier is the prefix for a mangled C++ operator name.  */\n+#define IDENTIFIER_OPNAME_P(NODE) TREE_LANG_FLAG_2(NODE)\n+\n+#define IDENTIFIER_TYPENAME_P(NODE)\t\\\n+  (! strncmp (IDENTIFIER_POINTER (NODE),\t\t\t\\\n+\t      IDENTIFIER_POINTER (ansi_opname[(int) TYPE_EXPR]),\t\\\n+\t      IDENTIFIER_LENGTH (ansi_opname[(int) TYPE_EXPR])))\n+\n+/* Nonzero means reject anything that ANSI standard C forbids.  */\n+extern int pedantic;\n+\n+/* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is read-only.  */\n+#define C_TYPE_FIELDS_READONLY(type) TYPE_LANG_FLAG_0 (type)\n+\f\n+/* If non-zero, a VAR_DECL whose cleanup will cause a throw to the\n+   next exception handler.  */\n+extern tree exception_throw_decl;\n+\n+extern tree double_type_node, long_double_type_node, float_type_node;\n+extern tree char_type_node, unsigned_char_type_node, signed_char_type_node;\n+extern tree ptrdiff_type_node;\n+\n+extern tree short_integer_type_node, short_unsigned_type_node;\n+extern tree long_integer_type_node, long_unsigned_type_node;\n+extern tree long_long_integer_type_node, long_long_unsigned_type_node;\n+extern tree unsigned_type_node;\n+extern tree string_type_node, char_array_type_node, int_array_type_node;\n+extern tree wchar_array_type_node;\n+extern tree wchar_type_node, signed_wchar_type_node, unsigned_wchar_type_node;\n+extern tree intQI_type_node, unsigned_intQI_type_node;\n+extern tree intHI_type_node, unsigned_intHI_type_node;\n+extern tree intSI_type_node, unsigned_intSI_type_node;\n+extern tree intDI_type_node, unsigned_intDI_type_node;\n+\n+extern int current_function_returns_value;\n+extern int current_function_returns_null;\n+extern tree current_function_return_value;\n+\n+extern tree ridpointers[];\n+extern tree ansi_opname[];\n+extern tree ansi_assopname[];\n+\n+/* Nonzero means `$' can be in an identifier.  */\n+\n+extern int dollars_in_ident;\n+\n+/* Nonzero means allow type mismatches in conditional expressions;\n+   just make their values `void'.   */\n+\n+extern int flag_cond_mismatch;\n+\n+/* Nonzero means don't recognize the keyword `asm'.  */\n+\n+extern int flag_no_asm;\n+\n+/* For cross referencing.  */\n+\n+extern int flag_gnu_xref;\n+\n+/* For environments where you can use GNU binutils (as, ld in particular).  */\n+\n+extern int flag_gnu_binutils;\n+\n+/* Nonzero means ignore `#ident' directives.  */\n+\n+extern int flag_no_ident;\n+\n+/* Nonzero means warn about implicit declarations.  */\n+\n+extern int warn_implicit;\n+\n+/* Nonzero means warn when all ctors or dtors are private, and the class\n+   has no friends.  */\n+\n+extern int warn_ctor_dtor_privacy;\n+\n+/* Nonzero means warn about function definitions that default the return type\n+   or that use a null return and have a return-type other than void.  */\n+\n+extern int warn_return_type;\n+\n+/* Nonzero means give string constants the type `const char *'\n+   to get extra warnings from them.  These warnings will be too numerous\n+   to be useful, except in thoroughly ANSIfied programs.  */\n+\n+extern int warn_write_strings;\n+\n+/* Nonzero means warn about sizeof(function) or addition/subtraction\n+   of function pointers.  */\n+\n+extern int warn_pointer_arith;\n+\n+/* Nonzero means warn for all old-style non-prototype function decls.  */\n+\n+extern int warn_strict_prototypes;\n+\n+/* Nonzero means warn about suggesting putting in ()'s.  */\n+\n+extern int warn_parentheses;\n+\n+/* Nonzero means warn about multiple (redundant) decls for the same single\n+   variable or function.  */\n+\n+extern int warn_redundant_decls;\n+\n+/* Warn if initializer is not completely bracketed.  */\n+\n+extern int warn_missing_braces;\n+\n+/* Warn about a subscript that has type char.  */\n+\n+extern int warn_char_subscripts;\n+\n+/* Nonzero means warn about pointer casts that can drop a type qualifier\n+   from the pointer target type.  */\n+\n+extern int warn_cast_qual;\n+\n+/* Warn about traditional constructs whose meanings changed in ANSI C.  */\n+\n+extern int warn_traditional;\n+\n+/* Warn about *printf or *scanf format/argument anomalies. */\n+\n+extern int warn_format;\n+\n+/* Nonzero means warn about non virtual destructors in classes that have\n+   virtual functions. */\n+\n+extern int warn_nonvdtor;\n+\n+/* Non-zero means warn when a function is declared extern and later inline.  */\n+extern int warn_extern_inline;\n+\n+/* Nonzero means do some things the same way PCC does.  */\n+\n+extern int flag_traditional;\n+\n+/* Nonzero means to treat bitfields as unsigned unless they say `signed'.  */\n+\n+extern int flag_signed_bitfields;\n+\n+/* 3 means write out only virtuals function tables `defined'\n+   in this implementation file.\n+   2 means write out only specific virtual function tables\n+   and give them (C) public access.\n+   1 means write out virtual function tables and give them\n+   (C) public access.\n+   0 means write out virtual function tables and give them\n+   (C) static access (default).\n+   -1 means declare virtual function tables extern.  */\n+\n+extern int write_virtuals;\n+\n+/* INTERFACE_ONLY nonzero means that we are in an \"interface\"\n+   section of the compiler.  INTERFACE_UNKNOWN nonzero means\n+   we cannot trust the value of INTERFACE_ONLY.  If INTERFACE_UNKNOWN\n+   is zero and INTERFACE_ONLY is zero, it means that we are responsible\n+   for exporting definitions that others might need.  */\n+extern int interface_only, interface_unknown;\n+\n+/* Nonzero means we should attempt to elide constructors when possible.  */\n+\n+extern int flag_elide_constructors;\n+\n+/* Nonzero means recognize and handle exception handling constructs.  */\n+\n+extern int flag_handle_exceptions;\n+\n+/* Nonzero means recognize and handle ansi-style exception handling constructs.  */\n+\n+extern int flag_ansi_exceptions;\n+\n+/* Nonzero means do argument matching for overloading according to the\n+   ANSI rules, rather than what g++ used to believe to be correct.  */\n+\n+extern int flag_ansi_overloading;\n+\n+/* Nonzero means recognize and handle signature language constructs.  */\n+\n+extern int flag_handle_signatures;\n+\n+/* Nonzero means that member functions defined in class scope are\n+   inline by default.  */\n+\n+extern int flag_default_inline;\n+\n+/* Nonzero means emit cadillac protocol.  */\n+\n+extern int flag_cadillac;\n+\f\n+/* C++ language-specific tree codes.  */\n+#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n+enum cplus_tree_code {\n+  __DUMMY = LAST_AND_UNUSED_TREE_CODE,\n+#include \"tree.def\"\n+  LAST_CPLUS_TREE_CODE\n+};\n+#undef DEFTREECODE\n+\n+/* Override OFFSET_REFs from the back-end, as we want our very own. */\n+/* Allow complex pointer to members to work correctly. */\n+#define OFFSET_REF CP_OFFSET_REF\n+\n+enum languages { lang_c, lang_cplusplus };\n+\n+/* Macros to make error reporting functions' lives easier.  */\n+#define TYPE_IDENTIFIER(NODE) (DECL_NAME (TYPE_NAME (NODE)))\n+#define TYPE_NAME_STRING(NODE) (IDENTIFIER_POINTER (TYPE_IDENTIFIER (NODE)))\n+#define TYPE_NAME_LENGTH(NODE) (IDENTIFIER_LENGTH (TYPE_IDENTIFIER (NODE)))\n+\n+#define TYPE_ASSEMBLER_NAME_STRING(NODE) (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME  (NODE))))\n+#define TYPE_ASSEMBLER_NAME_LENGTH(NODE) (IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (TYPE_NAME (NODE))))\n+\n+#define IS_AGGR_TYPE(t)\t\t(TYPE_LANG_FLAG_5 (t))\n+#define IS_AGGR_TYPE_CODE(t)\t(t == RECORD_TYPE || t == UNION_TYPE)\n+#define IS_AGGR_TYPE_2(TYPE1,TYPE2) \\\n+  (TREE_CODE (TYPE1) == TREE_CODE (TYPE2)\t\\\n+   && IS_AGGR_TYPE (TYPE1)&IS_AGGR_TYPE (TYPE2))\n+\n+/* In a *_TYPE, nonzero means a built-in type.  */\n+#define TYPE_BUILT_IN(NODE) TYPE_LANG_FLAG_6(NODE)\n+\n+/* Macros which might want to be replaced by function calls.  */\n+\n+#if 1\n+/* Virtual function addresses can be gotten from a virtual function\n+   table entry using this macro.  */\n+#define FNADDR_FROM_VTABLE_ENTRY(ENTRY) \\\n+  TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (ENTRY))))\n+#define SET_FNADDR_FROM_VTABLE_ENTRY(ENTRY,VALUE) \\\n+  (TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (ENTRY)))) = (VALUE))\n+\n+#define FUNCTION_ARG_CHAIN(NODE) (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (NODE))))\n+#define PROMOTES_TO_AGGR_TYPE(NODE,CODE)\t\\\n+  (((CODE) == TREE_CODE (NODE)\t\t\t\\\n+       && IS_AGGR_TYPE (TREE_TYPE (NODE)))\t\\\n+   || IS_AGGR_TYPE (NODE))\n+\n+#else\n+#define FNADDR_FROM_VTABLE_ENTRY(ENTRY) (fnaddr_from_vtable_entry (ENTRY))\n+#define SET_FNADDR_FROM_VTABLE_ENTRY(ENTRY,VALUE) \\\n+  (set_fnaddr_from_vtable_entry (ENTRY, VALUE))\n+/* #define TYPE_NAME_STRING(NODE) (type_name_string (NODE)) */\n+#define FUNCTION_ARG_CHAIN(NODE) (function_arg_chain (NODE))\n+#define PROMOTES_TO_AGGR_TYPE(NODE,CODE) (promotes_to_aggr_type (NODE, CODE))\n+/* #define IS_AGGR_TYPE_2(TYPE1, TYPE2) (is_aggr_type_2 (TYPE1, TYPE2)) */\n+#endif\n+/* Nonzero iff TYPE is uniquely derived from PARENT.  Under MI, PARENT can\n+   be an ambiguous base class of TYPE, and this macro will be false.  */\n+#define UNIQUELY_DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 0, (tree *)0) >= 0)\n+#define ACCESSIBLY_DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, -1, (tree *)0) >= 0)\n+#define ACCESSIBLY_UNIQUELY_DERIVED_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 1, (tree *)0) >= 0)\n+\f\n+enum conversion_type { ptr_conv, constptr_conv, int_conv,\n+\t\t       real_conv, last_conversion_type };\n+\n+/* Statistics show that while the GNU C++ compiler may generate\n+   thousands of different types during a compilation run, it\n+   generates relatively few (tens) of classtypes.  Because of this,\n+   it is not costly to store a generous amount of information\n+   in classtype nodes.  This struct must fill out to a multiple of 4 bytes.  */\n+struct lang_type\n+{\n+  struct\n+    {\n+      unsigned has_type_conversion : 1;\n+      unsigned has_int_conversion : 1;\n+      unsigned has_float_conversion : 1;\n+      unsigned has_init_ref : 1;\n+      unsigned gets_init_aggr : 1;\n+      unsigned has_assignment : 1;\n+      unsigned has_default_ctor : 1;\n+      unsigned uses_multiple_inheritance : 1;\n+\n+      unsigned has_nonpublic_ctor : 2;\n+      unsigned has_nonpublic_assign_ref : 2;\n+      unsigned const_needs_init : 1;\n+      unsigned ref_needs_init : 1;\n+      unsigned has_const_assign_ref : 1;\n+      unsigned vtable_needs_writing : 1;\n+\n+      unsigned has_assign_ref : 1;\n+      unsigned gets_new : 1;\n+      unsigned gets_placed_new : 1;\n+      unsigned gets_delete : 1;\n+      unsigned has_call_overloaded : 1;\n+      unsigned has_array_ref_overloaded : 1;\n+      unsigned has_arrow_overloaded : 1;\n+      unsigned local_typedecls : 1;\n+\n+      unsigned interface_only : 1;\n+      unsigned interface_unknown : 1;\n+      unsigned needs_virtual_reinit : 1;\n+      unsigned declared_exception : 1;\n+      unsigned declared_class : 1;\n+      unsigned being_defined : 1;\n+      unsigned redefined : 1;\n+      unsigned no_globalize : 1;\n+\n+      unsigned marked : 1;\n+      unsigned marked2 : 1;\n+      unsigned marked3 : 1;\n+      unsigned marked4 : 1;\n+      unsigned marked5 : 1;\n+      unsigned marked6 : 1;\n+      unsigned use_template : 2;\n+\n+      unsigned debug_requested : 1;\n+      unsigned has_method_call_overloaded : 1;\n+      unsigned private_attr : 1;\n+      unsigned got_semicolon : 1;\n+      unsigned ptrmemfunc_flag : 1;\n+      unsigned is_signature : 1;\n+      unsigned is_signature_pointer : 1;\n+      unsigned is_signature_reference : 1;\n+\n+      unsigned has_default_implementation : 1;\n+      unsigned grokking_typedef : 1;\n+      unsigned has_opaque_typedecls : 1;\n+      unsigned sigtable_has_been_generated : 1;\n+      unsigned was_anonymous : 1;\n+      unsigned has_real_assignment : 1;\n+      unsigned has_real_assign_ref : 1;\n+      unsigned has_const_init_ref : 1;\n+      \n+      unsigned has_complex_init_ref : 1;\n+      unsigned has_complex_assign_ref : 1;\n+\n+      /* The MIPS compiler gets it wrong if this struct also\n+\t does not fill out to a multiple of 4 bytes.  Add a\n+\t member `dummy' with new bits if you go over the edge.  */\n+      unsigned dummy : 22;\n+\n+      unsigned n_vancestors : 16;\n+    } type_flags;\n+\n+  int cid;\n+  int n_ancestors;\n+  int vsize;\n+  int max_depth;\n+  int vfield_parent;\n+\n+  union tree_node *vbinfo[2];\n+  union tree_node *baselink_vec;\n+  union tree_node *vfields;\n+  union tree_node *vbases;\n+  union tree_node *vbase_size;\n+\n+  union tree_node *tags;\n+  char *memoized_table_entry;\n+\n+  char *search_slot;\n+\n+#ifdef ONLY_INT_FIELDS\n+  unsigned int mode : 8;\n+#else\n+  enum machine_mode mode : 8;\n+#endif\n+\n+  unsigned char size_unit;\n+  unsigned char align;\n+  unsigned char sep_unit;\n+\n+  union tree_node *sep;\n+  union tree_node *size;\n+\n+  union tree_node *base_init_list;\n+  union tree_node *abstract_virtuals;\n+  union tree_node *as_list;\n+  union tree_node *id_as_list;\n+  union tree_node *binfo_as_list;\n+  union tree_node *vtbl_ptr;\n+  union tree_node *instance_variable;\n+  union tree_node *friend_classes;\n+\n+  char *mi_matrix;\n+  union tree_node *conversions[last_conversion_type];\n+\n+  union tree_node *dossier;\n+\n+  union tree_node *signature;\n+  union tree_node *signature_pointer_to;\n+  union tree_node *signature_reference_to;\n+};\n+\n+/* Indicates whether a template should be (or has been) expanded for this\n+   class definition.  0=do, 1=did, 2=don't, 3=didn't.  */\n+#define CLASSTYPE_USE_TEMPLATE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.use_template)\n+\n+/* Fields used for storing information before the class is defined.\n+   After the class is defined, these fields hold other information.  */\n+\n+/* List of friends which were defined inline in this class definition.  */\n+#define CLASSTYPE_INLINE_FRIENDS(NODE) (TYPE_NONCOPIED_PARTS (NODE))\n+\n+/* Nonzero for _CLASSTYPE means that the _CLASSTYPE either has\n+   a special meaning for the assignment operator (\"operator=\"),\n+   or one of its fields (or base members) has a special meaning\n+   defined.  */\n+#define TYPE_HAS_ASSIGNMENT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_assignment)\n+#define TYPE_HAS_REAL_ASSIGNMENT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_real_assignment)\n+\n+/* Nonzero for _CLASSTYPE means that operator new and delete are defined,\n+   respectively.  */\n+#define TREE_GETS_NEW(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_new)\n+#define TREE_GETS_PLACED_NEW(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_placed_new)\n+#define TREE_GETS_DELETE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_delete)\n+\n+/* Nonzero for TREE_LIST or _TYPE node means that this node is class-local.  */\n+#define TREE_NONLOCAL_FLAG(NODE) (TREE_LANG_FLAG_0 (NODE))\n+\n+/* Nonzero for a _CLASSTYPE node which we know to be private.  */\n+#define TYPE_PRIVATE_P(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.private_attr)\n+\n+/* Nonzero means that this _CLASSTYPE node defines ways of converting\n+   itself to other types.  */\n+#define TYPE_HAS_CONVERSION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_type_conversion)\n+\n+/* Nonzero means that this _CLASSTYPE node can convert itself to an\n+   INTEGER_TYPE.  */\n+#define TYPE_HAS_INT_CONVERSION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_int_conversion)\n+\n+/* Nonzero means that this _CLASSTYPE node can convert itself to an\n+   REAL_TYPE.  */\n+#define TYPE_HAS_REAL_CONVERSION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_float_conversion)\n+\n+/* Nonzero means that this _CLASSTYPE node overloads operator=(X&).  */\n+#define TYPE_HAS_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_assign_ref)\n+#define TYPE_HAS_CONST_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_const_assign_ref)\n+\n+/* Nonzero means that this _CLASSTYPE node has an X(X&) constructor.  */\n+#define TYPE_HAS_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_init_ref)\n+#define TYPE_HAS_CONST_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_const_init_ref)\n+\n+/* Nonzero means that this _CLASSTYPE node has an X(X ...) constructor.\n+   Note that there must be other arguments, or this constructor is flagged\n+   as being erroneous.  */\n+#define TYPE_GETS_INIT_AGGR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_init_aggr)\n+\n+/* Nonzero means that this type is being defined.  I.e., the left brace\n+   starting the definition of this type has been seen.  */\n+#define TYPE_BEING_DEFINED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.being_defined)\n+/* Nonzero means that this type has been redefined.  In this case, if\n+   convenient, don't reprocess any methods that appear in its redefinition.  */\n+#define TYPE_REDEFINED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.redefined)\n+\n+/* Nonzero means that this _CLASSTYPE node overloads the method call\n+   operator.  In this case, all method calls go through `operator->()(...).  */\n+#define TYPE_OVERLOADS_METHOD_CALL_EXPR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_method_call_overloaded)\n+\n+/* Nonzero means that this type is a signature.  */\n+# define IS_SIGNATURE(NODE) (TYPE_LANG_SPECIFIC(NODE)?TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature:0)\n+# define SET_SIGNATURE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature=1)\n+# define CLEAR_SIGNATURE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature=0)\n+\n+/* Nonzero means that this type is a signature pointer type.  */\n+# define IS_SIGNATURE_POINTER(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature_pointer)\n+\n+/* Nonzero means that this type is a signature reference type.  */\n+# define IS_SIGNATURE_REFERENCE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature_reference)\n+\n+/* Nonzero means that this signature type has a default implementation.  */\n+# define HAS_DEFAULT_IMPLEMENTATION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_default_implementation)\n+\n+/* Nonzero means that grokdeclarator works on a signature-local typedef.  */\n+#define SIGNATURE_GROKKING_TYPEDEF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.grokking_typedef)\n+\n+/* Nonzero means that this signature contains opaque type declarations.  */\n+#define SIGNATURE_HAS_OPAQUE_TYPEDECLS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_opaque_typedecls)\n+\n+/* Nonzero means that a signature table has been generated\n+   for this signature.  */\n+#define SIGTABLE_HAS_BEEN_GENERATED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.sigtable_has_been_generated)\n+\n+/* If NODE is a class, this is the signature type that contains NODE's\n+   signature after it has been computed using sigof().  */\n+#define CLASSTYPE_SIGNATURE(NODE) (TYPE_LANG_SPECIFIC(NODE)->signature)\n+\n+/* If NODE is a signature pointer or signature reference, this is the\n+   signature type the pointer/reference points to.  */\n+#define SIGNATURE_TYPE(NODE) (TYPE_LANG_SPECIFIC(NODE)->signature)\n+\n+/* If NODE is a signature, this is a vector of all methods defined\n+   in the signature or in its base types together with their default\n+   implementations.  */\n+#define SIGNATURE_METHOD_VEC(NODE) (TYPE_LANG_SPECIFIC(NODE)->signature)\n+\n+/* If NODE is a signature, this is the _TYPE node that contains NODE's\n+   signature pointer type.  */\n+#define SIGNATURE_POINTER_TO(NODE) (TYPE_LANG_SPECIFIC(NODE)->signature_pointer_to)\n+\n+/* If NODE is a signature, this is the _TYPE node that contains NODE's\n+   signature reference type.  */\n+#define SIGNATURE_REFERENCE_TO(NODE) (TYPE_LANG_SPECIFIC(NODE)->signature_reference_to)\n+\n+/* The is the VAR_DECL that contains NODE's dossier.  */\n+#define CLASSTYPE_DOSSIER(NODE) (TYPE_LANG_SPECIFIC(NODE)->dossier)\n+\n+/* Nonzero means that this _CLASSTYPE node overloads operator().  */\n+#define TYPE_OVERLOADS_CALL_EXPR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_call_overloaded)\n+\n+/* Nonzero means that this _CLASSTYPE node overloads operator[].  */\n+#define TYPE_OVERLOADS_ARRAY_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_array_ref_overloaded)\n+\n+/* Nonzero means that this _CLASSTYPE node overloads operator->.  */\n+#define TYPE_OVERLOADS_ARROW(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_arrow_overloaded)\n+\n+/* Nonzero means that this _CLASSTYPE (or one of its ancestors) uses\n+   multiple inheritance.  If this is 0 for the root of a type\n+   hierarchy, then we can use more efficient search techniques.  */\n+#define TYPE_USES_MULTIPLE_INHERITANCE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.uses_multiple_inheritance)\n+\n+/* Nonzero means that this _CLASSTYPE (or one of its ancestors) uses\n+   virtual base classes.  If this is 0 for the root of a type\n+   hierarchy, then we can use more efficient search techniques.  */\n+#define TYPE_USES_VIRTUAL_BASECLASSES(NODE) (TREE_LANG_FLAG_3(NODE))\n+\n+/* List of lists of member functions defined in this class.  */\n+#define CLASSTYPE_METHOD_VEC(NODE) TYPE_METHODS(NODE)\n+\n+/* Pointer from any member function to the head of the list of\n+   member functions of the type that member function belongs to.  */\n+#define CLASSTYPE_BASELINK_VEC(NODE) (TYPE_LANG_SPECIFIC(NODE)->baselink_vec)\n+\n+/* Mark bits for depth-first and breath-first searches.  */\n+#define CLASSTYPE_MARKED(NODE)  (TYPE_LANG_SPECIFIC(NODE)->type_flags.marked)\n+#define CLASSTYPE_MARKED2(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.marked2)\n+#define CLASSTYPE_MARKED3(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.marked3)\n+#define CLASSTYPE_MARKED4(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.marked4)\n+#define CLASSTYPE_MARKED5(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.marked5)\n+#define CLASSTYPE_MARKED6(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.marked6)\n+/* Macros to modify the above flags */\n+#define SET_CLASSTYPE_MARKED(NODE)\t(CLASSTYPE_MARKED(NODE) = 1)\n+#define CLEAR_CLASSTYPE_MARKED(NODE)\t(CLASSTYPE_MARKED(NODE) = 0)\n+#define SET_CLASSTYPE_MARKED2(NODE)\t(CLASSTYPE_MARKED2(NODE) = 1)\n+#define CLEAR_CLASSTYPE_MARKED2(NODE)\t(CLASSTYPE_MARKED2(NODE) = 0)\n+#define SET_CLASSTYPE_MARKED3(NODE)\t(CLASSTYPE_MARKED3(NODE) = 1)\n+#define CLEAR_CLASSTYPE_MARKED3(NODE)\t(CLASSTYPE_MARKED3(NODE) = 0)\n+#define SET_CLASSTYPE_MARKED4(NODE)\t(CLASSTYPE_MARKED4(NODE) = 1)\n+#define CLEAR_CLASSTYPE_MARKED4(NODE)\t(CLASSTYPE_MARKED4(NODE) = 0)\n+#define SET_CLASSTYPE_MARKED5(NODE)\t(CLASSTYPE_MARKED5(NODE) = 1)\n+#define CLEAR_CLASSTYPE_MARKED5(NODE)\t(CLASSTYPE_MARKED5(NODE) = 0)\n+#define SET_CLASSTYPE_MARKED6(NODE)\t(CLASSTYPE_MARKED6(NODE) = 1)\n+#define CLEAR_CLASSTYPE_MARKED6(NODE)\t(CLASSTYPE_MARKED6(NODE) = 0)\n+\n+#define CLASSTYPE_TAGS(NODE)\t\t(TYPE_LANG_SPECIFIC(NODE)->tags)\n+\n+/* If this class has any bases, this is the number of the base class from\n+   which our VFIELD is based, -1 otherwise.  If this class has no base\n+   classes, this is not used.\n+   In D : B1, B2, PARENT would be 0, if D's vtable came from B1,\n+   1, if D's vtable came from B2. */\n+#define CLASSTYPE_VFIELD_PARENT(NODE)\t(TYPE_LANG_SPECIFIC(NODE)->vfield_parent)\n+\n+/* Remove when done merging.  */\n+#define CLASSTYPE_VFIELD(NODE) TYPE_VFIELD(NODE)\n+\n+/* The number of virtual functions defined for this\n+   _CLASSTYPE node.  */\n+#define CLASSTYPE_VSIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->vsize)\n+/* The virtual base classes that this type uses.  */\n+#define CLASSTYPE_VBASECLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->vbases)\n+/* The virtual function pointer fields that this type contains.  */\n+#define CLASSTYPE_VFIELDS(NODE) (TYPE_LANG_SPECIFIC(NODE)->vfields)\n+\n+/* Number of baseclasses defined for this type.\n+   0 means no base classes.  */\n+#define CLASSTYPE_N_BASECLASSES(NODE) \\\n+  (TYPE_BINFO_BASETYPES (NODE) ? TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES(NODE)) : 0)\n+\n+/* Memoize the number of super classes (base classes) tha this node\n+   has.  That way we can know immediately (albeit conservatively how\n+   large a multiple-inheritance matrix we need to build to find\n+   derivation information.  */\n+#define CLASSTYPE_N_SUPERCLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->n_ancestors)\n+#define CLASSTYPE_N_VBASECLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.n_vancestors)\n+\n+/* Record how deep the inheritance is for this class so `void*' conversions\n+   are less favorable than a conversion to the most base type.  */\n+#define CLASSTYPE_MAX_DEPTH(NODE) (TYPE_LANG_SPECIFIC(NODE)->max_depth)\n+\n+/* Used for keeping search-specific information.  Any search routine\n+   which uses this must define what exactly this slot is used for.  */\n+#define CLASSTYPE_SEARCH_SLOT(NODE) (TYPE_LANG_SPECIFIC(NODE)->search_slot)\n+\n+/* Entry for keeping memoization tables for this type to\n+   hopefully speed up search routines.  Since it is a pointer,\n+   it can mean almost anything.  */\n+#define CLASSTYPE_MTABLE_ENTRY(NODE) (TYPE_LANG_SPECIFIC(NODE)->memoized_table_entry)\n+\n+/* This is the total size of the baseclasses defined for this type.\n+   Needed because it is desirable to layout such information\n+   before beginning to process the class itself, and we\n+   don't want to compute it second time when actually laying\n+   out the type for real.  */\n+#define CLASSTYPE_SIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->size)\n+#define CLASSTYPE_SIZE_UNIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->size_unit)\n+#define CLASSTYPE_MODE(NODE) (TYPE_LANG_SPECIFIC(NODE)->mode)\n+#define CLASSTYPE_ALIGN(NODE) (TYPE_LANG_SPECIFIC(NODE)->align)\n+\n+/* This is the space needed for virtual base classes.  NULL if\n+   there are no virtual basetypes.  */\n+#define CLASSTYPE_VBASE_SIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->vbase_size)\n+\n+/* A cons list of structure elements which either have constructors\n+   to be called, or virtual function table pointers which\n+   need initializing.  Depending on what is being initialized,\n+   the TREE_PURPOSE and TREE_VALUE fields have different meanings:\n+\n+   Member initialization: <FIELD_DECL, TYPE>\n+   Base class construction: <NULL_TREE, BASETYPE>\n+   Base class initialization: <BASE_INITIALIZATION, THESE_INITIALIZATIONS>\n+   Whole type: <MEMBER_INIT, BASE_INIT>.  */\n+#define CLASSTYPE_BASE_INIT_LIST(NODE) (TYPE_LANG_SPECIFIC(NODE)->base_init_list)\n+\n+/* A cons list of virtual functions which cannot be inherited by\n+   derived classes.  When deriving from this type, the derived\n+   class must provide its own definition for each of these functions.  */\n+#define CLASSTYPE_ABSTRACT_VIRTUALS(NODE) (TYPE_LANG_SPECIFIC(NODE)->abstract_virtuals)\n+\n+/* Nonzero means that this aggr type has been `closed' by a semicolon.  */\n+#define CLASSTYPE_GOT_SEMICOLON(NODE) (TYPE_LANG_SPECIFIC (NODE)->type_flags.got_semicolon)\n+\n+/* Nonzero means that the main virtual function table pointer needs to be\n+   set because base constructors have placed the wrong value there.\n+   If this is zero, it means that they placed the right value there,\n+   and there is no need to change it.  */\n+#define CLASSTYPE_NEEDS_VIRTUAL_REINIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.needs_virtual_reinit)\n+\n+/* Nonzero means that if this type has virtual functions, that\n+   the virtual function table will be written out.  */\n+#define CLASSTYPE_VTABLE_NEEDS_WRITING(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.vtable_needs_writing)\n+\n+/* Nonzero means that this type defines its own local type declarations.  */\n+#define CLASSTYPE_LOCAL_TYPEDECLS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.local_typedecls)\n+\n+/* Nonzero means that this type has an X() constructor.  */\n+#define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_default_ctor)\n+\n+/* Nonzero means the type declared a ctor as private or protected.  We\n+   use this to make sure we don't try to generate a copy ctor for a \n+   class that has a member of type NODE.  */\n+#define TYPE_HAS_NONPUBLIC_CTOR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_nonpublic_ctor)\n+\n+/* Ditto, for operator=.  */\n+#define TYPE_HAS_NONPUBLIC_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_nonpublic_assign_ref)\n+\n+/* Many routines need to cons up a list of basetypes for access\n+   checking.  This field contains a TREE_LIST node whose TREE_VALUE\n+   is the main variant of the type, and whose TREE_VIA_PUBLIC\n+   and TREE_VIA_VIRTUAL bits are correctly set.  */\n+#define CLASSTYPE_AS_LIST(NODE) (TYPE_LANG_SPECIFIC(NODE)->as_list)\n+/* Same, but cache a list whose value is the name of this type.  */\n+#define CLASSTYPE_ID_AS_LIST(NODE) (TYPE_LANG_SPECIFIC(NODE)->id_as_list)\n+/* Same, but cache a list whose value is the binfo of this type.  */\n+#define CLASSTYPE_BINFO_AS_LIST(NODE) (TYPE_LANG_SPECIFIC(NODE)->binfo_as_list)\n+\n+/* Slot in which to cache a copy of the local vtable pointer.  */\n+#define CLASSTYPE_VTBL_PTR(NODE) (TYPE_LANG_SPECIFIC(NODE)->vtbl_ptr)\n+\n+/* Hold the instance object associated with this method.  */\n+#define CLASSTYPE_INST_VAR(NODE) (TYPE_LANG_SPECIFIC(NODE)->instance_variable)\n+\n+/* A list of class types with which this type is a friend.  */\n+#define CLASSTYPE_FRIEND_CLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->friend_classes)\n+\n+/* Keep an inheritance lattice around so we can quickly tell whether\n+   a type is derived from another or not.  */\n+#define CLASSTYPE_MI_MATRIX(NODE) (TYPE_LANG_SPECIFIC(NODE)->mi_matrix)\n+\n+/* If there is exactly one conversion to a non-void, non-const pointer type,\n+   remember that here.  If there are more than one, put\n+   `error_mark_node' here.  If there are none, this holds NULL_TREE.  */\n+#define CLASSTYPE_CONVERSION(NODE,KIND) \\\n+  (TYPE_LANG_SPECIFIC(NODE)->conversions[(int) KIND])\n+\n+/* Say whether this node was declared as a \"class\" or a \"struct\".  */\n+#define CLASSTYPE_DECLARED_CLASS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.declared_class)\n+/* Say whether this node was declared as a \"class\" or a \"struct\".  */\n+#define CLASSTYPE_DECLARED_EXCEPTION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.declared_exception)\n+/* whether this can be globalized.  */\n+#define CLASSTYPE_NO_GLOBALIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.no_globalize)\n+\n+/* Nonzero if this class has const members which have no specified initialization.  */\n+#define CLASSTYPE_READONLY_FIELDS_NEED_INIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.const_needs_init)\n+\n+/* Nonzero if this class has ref members which have no specified initialization.  */\n+#define CLASSTYPE_REF_FIELDS_NEED_INIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.ref_needs_init)\n+\n+/* Nonzero if this class is included from a header file which employs\n+   `#pragma interface', and it is not included in its implementation file.  */\n+#define CLASSTYPE_INTERFACE_ONLY(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.interface_only)\n+\n+/* Same as above, but for classes whose purpose we do not know.  */\n+#define CLASSTYPE_INTERFACE_UNKNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.interface_unknown)\n+#define CLASSTYPE_INTERFACE_KNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.interface_unknown == 0)\n+#define SET_CLASSTYPE_INTERFACE_UNKNOWN_X(NODE,X) (TYPE_LANG_SPECIFIC(NODE)->type_flags.interface_unknown = !!(X))\n+#define SET_CLASSTYPE_INTERFACE_UNKNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.interface_unknown = 1)\n+#define SET_CLASSTYPE_INTERFACE_KNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.interface_unknown = 0)\n+\n+/* Nonzero if a _DECL node requires us to output debug info for this class.  */\n+#define CLASSTYPE_DEBUG_REQUESTED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.debug_requested)\n+\f\n+/* Additional macros for inheritance information.  */\n+\n+#define CLASSTYPE_VBINFO(NODE,VIA_PUBLIC) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->vbinfo[VIA_PUBLIC])\n+\n+/* When following an binfo-specific chain, this is the cumulative\n+   via-public flag.  */\n+#define BINFO_VIA_PUBLIC(NODE) TREE_LANG_FLAG_5 (NODE)\n+\n+/* When building a matrix to determine by a single lookup\n+   whether one class is derived from another or not,\n+   this field is the index of the class in the table.  */\n+#define CLASSTYPE_CID(NODE) (TYPE_LANG_SPECIFIC(NODE)->cid)\n+#define BINFO_CID(NODE) CLASSTYPE_CID(BINFO_TYPE(NODE))\n+\n+/* Nonzero means marked by DFS or BFS search, including searches\n+   by `get_binfo' and `get_base_distance'.  */\n+#define BINFO_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED(BINFO_TYPE(NODE)):TREE_LANG_FLAG_0(NODE))\n+/* Macros needed because of C compilers that don't allow conditional\n+   expressions to be lvalues.  Grr!  */\n+#define SET_BINFO_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?SET_CLASSTYPE_MARKED(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_0(NODE)=1))\n+#define CLEAR_BINFO_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLEAR_CLASSTYPE_MARKED(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_0(NODE)=0))\n+\n+/* Nonzero means marked in building initialization list.  */\n+#define BINFO_BASEINIT_MARKED(NODE) CLASSTYPE_MARKED2 (BINFO_TYPE (NODE))\n+/* Modifier macros */\n+#define SET_BINFO_BASEINIT_MARKED(NODE) SET_CLASSTYPE_MARKED2 (BINFO_TYPE (NODE))\n+#define CLEAR_BINFO_BASEINIT_MARKED(NODE) CLEAR_CLASSTYPE_MARKED2 (BINFO_TYPE (NODE))\n+\n+/* Nonzero means marked in search through virtual inheritance hierarchy.  */\n+#define BINFO_VBASE_MARKED(NODE) CLASSTYPE_MARKED2 (BINFO_TYPE (NODE))\n+/* Modifier macros */\n+#define SET_BINFO_VBASE_MARKED(NODE) SET_CLASSTYPE_MARKED2 (BINFO_TYPE (NODE))\n+#define CLEAR_BINFO_VBASE_MARKED(NODE) CLEAR_CLASSTYPE_MARKED2 (BINFO_TYPE (NODE))\n+\n+/* Nonzero means marked in search for members or member functions.  */\n+#define BINFO_FIELDS_MARKED(NODE) \\\n+  (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED2 (BINFO_TYPE (NODE)):TREE_LANG_FLAG_2(NODE))\n+#define SET_BINFO_FIELDS_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?SET_CLASSTYPE_MARKED2(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_2(NODE)=1))\n+#define CLEAR_BINFO_FIELDS_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLEAR_CLASSTYPE_MARKED2(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_2(NODE)=0))\n+\n+/* Nonzero means that this class is on a path leading to a new vtable.  */\n+#define BINFO_VTABLE_PATH_MARKED(NODE) \\\n+  (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED3(BINFO_TYPE(NODE)):TREE_LANG_FLAG_3(NODE))\n+#define SET_BINFO_VTABLE_PATH_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?SET_CLASSTYPE_MARKED3(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_3(NODE)=1))\n+#define CLEAR_BINFO_VTABLE_PATH_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLEAR_CLASSTYPE_MARKED3(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_3(NODE)=0))\n+\n+/* Nonzero means that this class has a new vtable.  */\n+#define BINFO_NEW_VTABLE_MARKED(NODE) \\\n+  (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED4(BINFO_TYPE(NODE)):TREE_LANG_FLAG_4(NODE))\n+#define SET_BINFO_NEW_VTABLE_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?SET_CLASSTYPE_MARKED4(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_4(NODE)=1))\n+#define CLEAR_BINFO_NEW_VTABLE_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLEAR_CLASSTYPE_MARKED4(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_4(NODE)=0))\n+\n+/* Nonzero means this class has initialized its virtual baseclasses.  */\n+#define BINFO_VBASE_INIT_MARKED(NODE) \\\n+  (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED5(BINFO_TYPE(NODE)):TREE_LANG_FLAG_5(NODE))\n+#define SET_BINFO_VBASE_INIT_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?SET_CLASSTYPE_MARKED5(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_5(NODE)=1))\n+#define CLEAR_BINFO_VBASE_INIT_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLEAR_CLASSTYPE_MARKED5(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_5(NODE)=0))\n+\f\n+/* Accessor macros for the vfield slots in structures.  */\n+\n+/* Get the assoc info that caused this vfield to exist.  */\n+#define VF_BINFO_VALUE(NODE) TREE_PURPOSE (NODE)\n+\n+/* Get that same information as a _TYPE.  */\n+#define VF_BASETYPE_VALUE(NODE) TREE_VALUE (NODE)\n+\n+/* Get the value of the top-most type dominating the non-`normal' vfields.  */\n+#define VF_DERIVED_VALUE(NODE) (VF_BINFO_VALUE (NODE) ? BINFO_TYPE (VF_BINFO_VALUE (NODE)) : NULL_TREE)\n+\n+/* Get the value of the top-most type that's `normal' for the vfield.  */\n+#define VF_NORMAL_VALUE(NODE) TREE_TYPE (NODE)\n+\f\n+/* Nonzero for TREE_LIST node means that this list of things\n+   is a list of parameters, as opposed to a list of expressions.  */\n+#define TREE_PARMLIST(NODE) ((NODE)->common.unsigned_flag) /* overloaded! */\n+\n+/* For FUNCTION_TYPE or METHOD_TYPE, a list of the exceptions that\n+   this type can raise.  */\n+#define TYPE_RAISES_EXCEPTIONS(NODE) TYPE_NONCOPIED_PARTS (NODE)\n+\f\n+struct lang_decl_flags\n+{\n+#ifdef ONLY_INT_FIELDS\n+  int language : 8;\n+#else\n+  enum languages language : 8;\n+#endif\n+\n+  unsigned operator_attr : 1;\n+  unsigned constructor_attr : 1;\n+  unsigned returns_first_arg : 1;\n+  unsigned preserves_first_arg : 1;\n+  unsigned friend_attr : 1;\n+  unsigned static_function : 1;\n+  unsigned const_memfunc : 1;\n+  unsigned volatile_memfunc : 1;\n+\n+  unsigned abstract_virtual : 1;\n+  unsigned permanent_attr : 1 ;\n+  unsigned constructor_for_vbase_attr : 1;\n+  unsigned mutable_flag : 1;\n+  unsigned is_default_implementation : 1;\n+  unsigned synthesized : 1;\n+  unsigned dummy : 10;\n+\n+  tree access;\n+  tree context;\n+  tree memfunc_pointer_to;\n+};\n+\n+struct lang_decl\n+{\n+  struct lang_decl_flags decl_flags;\n+\n+  struct template_info *template_info;\n+  tree main_decl_variant;\n+  struct pending_inline *pending_inline_info;\n+  tree vbase_init_list;\n+  tree chain;\n+};\n+\n+/* Non-zero if NODE is a _DECL with TREE_READONLY set.  */\n+#define TREE_READONLY_DECL_P(NODE) \\\n+  (TREE_READONLY (NODE) && TREE_CODE_CLASS (TREE_CODE (NODE)) == 'd')\n+\n+/* For FUNCTION_DECLs: return the language in which this decl\n+   was declared.  */\n+#define DECL_LANGUAGE(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.language)\n+\n+/* For FUNCTION_DECLs: nonzero means that this function is a constructor.  */\n+#define DECL_CONSTRUCTOR_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.constructor_attr)\n+/* For FUNCTION_DECLs: nonzero means that this function is a constructor\n+   for an object with virtual baseclasses.  */\n+#define DECL_CONSTRUCTOR_FOR_VBASE_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.constructor_for_vbase_attr)\n+\n+/* For FUNCTION_DECLs: nonzero means that this function is a default\n+   implementation of a signature method.  */\n+#define IS_DEFAULT_IMPLEMENTATION(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.is_default_implementation)\n+\n+/* For FUNCTION_DECLs: nonzero means that the constructor\n+   is known to return a non-zero `this' unchanged.  */\n+#define DECL_RETURNS_FIRST_ARG(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.returns_first_arg)\n+\n+/* Nonzero for FUNCTION_DECL means that this constructor is known to\n+   not make any assignment to `this', and therefore can be trusted\n+   to return it unchanged.  Otherwise, we must re-assign `current_class_decl'\n+   after performing base initializations.  */\n+#define DECL_PRESERVES_THIS(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.preserves_first_arg)\n+\n+/* Nonzero for _DECL means that this decl appears in (or will appear\n+   in) as a member in a RECORD_TYPE or UNION_TYPE node.  It is also for\n+   detecting circularity in case members are multiply defined.  In the\n+   case of a VAR_DECL, it is also used to determine how program storage\n+   should be allocated.  */\n+#define DECL_IN_AGGR_P(NODE) (DECL_LANG_FLAG_3(NODE))\n+\n+/* Nonzero for FUNCTION_DECL means that this decl is just a\n+   friend declaration, and should not be added to the list of\n+   member functions for this class.  */\n+#define DECL_FRIEND_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.friend_attr)\n+\n+/* Nonzero for FUNCTION_DECL means that this decl is a static\n+   member function.  */\n+#define DECL_STATIC_FUNCTION_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.static_function)\n+\n+/* Nonzero for FUNCTION_DECL means that this member function\n+   has `this' as const X *const.  */\n+#define DECL_CONST_MEMFUNC_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.const_memfunc)\n+\n+/* Nonzero for FUNCTION_DECL means that this member function\n+   has `this' as volatile X *const.  */\n+#define DECL_VOLATILE_MEMFUNC_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.volatile_memfunc)\n+\n+/* Nonzero for _DECL means that this member object type\n+   is mutable.  */\n+#define DECL_MUTABLE_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.mutable_flag)\n+\n+/* Nonzero for FUNCTION_DECL means that this member function\n+   exists as part of an abstract class's interface.  */\n+#define DECL_ABSTRACT_VIRTUAL_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.abstract_virtual)\n+\n+/* Nonzero if allocated on permanent_obstack.  */\n+#define LANG_DECL_PERMANENT(LANGDECL) ((LANGDECL)->decl_flags.permanent_attr)\n+\n+/* The _TYPE context in which this _DECL appears.  This field is used\n+   only to compute access information.  */\n+#define DECL_CLASS_CONTEXT(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.context)\n+\n+/* For a FUNCTION_DECL: the chain through which the next method\n+   in the method chain is found.  We now use TREE_CHAIN to\n+   link into the FIELD_DECL chain.  */\n+#if 1\n+#define DECL_CHAIN(NODE) (DECL_LANG_SPECIFIC(NODE)->chain)\n+#else\n+#define DECL_CHAIN(NODE) (TREE_CHAIN (NODE))\n+#endif\n+\n+/* Points back to the decl which caused this lang_decl to be allocated.  */\n+#define DECL_MAIN_VARIANT(NODE) (DECL_LANG_SPECIFIC(NODE)->main_decl_variant)\n+\n+/* For a FUNCTION_DECL: if this function was declared inline inside of\n+   a class declaration, this is where the text for the function is\n+   squirreled away.  */\n+#define DECL_PENDING_INLINE_INFO(NODE) (DECL_LANG_SPECIFIC(NODE)->pending_inline_info)\n+\n+/* For a FUNCTION_DECL: if this function was declared inside a signature\n+   declaration, this is the corresponding member function pointer that was\n+   created for it.  */\n+#define DECL_MEMFUNC_POINTER_TO(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.memfunc_pointer_to)\n+\n+/* For a FIELD_DECL: this points to the signature member function from\n+   which this signature member function pointer was created.  */\n+#define DECL_MEMFUNC_POINTING_TO(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.memfunc_pointer_to)\n+\n+/* Holds information about how virtual base classes should be initialized\n+   by this constructor *if* this constructor is the one to perform\n+   such initialization.  */\n+#define DECL_VBASE_INIT_LIST(NODE) (DECL_LANG_SPECIFIC(NODE)->vbase_init_list)\n+\n+/* For a TEMPLATE_DECL: template-specific information.  */\n+#define DECL_TEMPLATE_INFO(NODE) (DECL_LANG_SPECIFIC(NODE)->template_info)\n+\n+/* Nonzero in INT_CST means that this int is negative by dint of\n+   using a twos-complement negated operand.  */\n+#define TREE_NEGATED_INT(NODE) (TREE_LANG_FLAG_0 (NODE))\n+\n+/* Nonzero in any kind of _EXPR or _REF node means that it is a call\n+   to a storage allocation routine.  If, later, alternate storage\n+   is found to hold the object, this call can be ignored.  */\n+#define TREE_CALLS_NEW(NODE) (TREE_LANG_FLAG_1 (NODE))\n+\n+/* Nonzero in any kind of _TYPE that uses multiple inheritance\n+   or virtual baseclasses.  */\n+#define TYPE_USES_COMPLEX_INHERITANCE(NODE) (TREE_LANG_FLAG_1 (NODE))\n+\n+/* Nonzero in IDENTIFIER_NODE means that this name is overloaded, and\n+   should be looked up in a non-standard way.  */\n+#define TREE_OVERLOADED(NODE) (TREE_LANG_FLAG_0 (NODE))\n+#define DECL_OVERLOADED(NODE) (DECL_LANG_FLAG_4 (NODE))\n+\n+/* Nonzero if this (non-TYPE)_DECL has its virtual attribute set.\n+   For a FUNCTION_DECL, this is when the function is a virtual function.\n+   For a VAR_DECL, this is when the variable is a virtual function table.\n+   For a FIELD_DECL, when the field is the field for the virtual function table.\n+   For an IDENTIFIER_NODE, nonzero if any function with this name\n+   has been declared virtual.\n+\n+   For a _TYPE if it uses virtual functions (or is derived from\n+   one that does).  */\n+#define TYPE_VIRTUAL_P(NODE) (TREE_LANG_FLAG_2 (NODE))\n+\n+#if 0\n+/* Same, but tells if this field is private in current context.  */\n+#define DECL_PRIVATE(NODE) (DECL_LANG_FLAG_5 (NODE))\n+\n+/* Same, but tells if this field is private in current context.  */\n+#define DECL_PROTECTED(NODE) (DECL_LANG_FLAG_6 (NODE))\n+\n+#define DECL_PUBLIC(NODE) (DECL_LANG_FLAG_7 (NODE))\n+#endif\n+\n+/* This method was synthesized by cons_up_default_function.  */\n+#define DECL_SYNTHESIZED(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.synthesized)\n+\n+/* Record whether a typedef for type `int' was actually `signed int'.  */\n+#define C_TYPEDEF_EXPLICITLY_SIGNED(exp) DECL_LANG_FLAG_1 ((exp))\n+\n+/* Nonzero if the type T promotes to itself.\n+   ANSI C states explicitly the list of types that promote;\n+   in particular, short promotes to int even if they have the same width.  */\n+#define C_PROMOTING_INTEGER_TYPE_P(t)\t\t\t\t\\\n+  (TREE_CODE ((t)) == INTEGER_TYPE\t\t\t\t\\\n+   && (TYPE_MAIN_VARIANT (t) == char_type_node\t\t\t\\\n+       || TYPE_MAIN_VARIANT (t) == signed_char_type_node\t\\\n+       || TYPE_MAIN_VARIANT (t) == unsigned_char_type_node\t\\\n+       || TYPE_MAIN_VARIANT (t) == short_integer_type_node\t\\\n+       || TYPE_MAIN_VARIANT (t) == short_unsigned_type_node))\n+\n+/* Mark which labels are explicitly declared.\n+   These may be shadowed, and may be referenced from nested functions.  */\n+#define C_DECLARED_LABEL_FLAG(label) TREE_LANG_FLAG_1 (label)\n+\n+/* Record whether a type or decl was written with nonconstant size.\n+   Note that TYPE_SIZE may have simplified to a constant.  */\n+#define C_TYPE_VARIABLE_SIZE(type) TREE_LANG_FLAG_4 (type)\n+#define C_DECL_VARIABLE_SIZE(type) DECL_LANG_FLAG_8 (type)\n+\n+/* Nonzero for _TYPE means that the _TYPE defines\n+   at least one constructor.  */\n+#define TYPE_HAS_CONSTRUCTOR(NODE) (TYPE_LANG_FLAG_1(NODE))\n+\n+/* When appearing in an INDIRECT_REF, it means that the tree structure\n+   underneath is actually a call to a constructor.  This is needed\n+   when the constructor must initialize local storage (which can\n+   be automatically destroyed), rather than allowing it to allocate\n+   space from the heap.\n+\n+   When appearing in a SAVE_EXPR, it means that underneath\n+   is a call to a constructor.\n+\n+   When appearing in a CONSTRUCTOR, it means that it was\n+   a GNU C constructor expression.\n+\n+   When appearing in a FIELD_DECL, it means that this field\n+   has been duly initialized in its constructor.  */\n+#define TREE_HAS_CONSTRUCTOR(NODE) (TREE_LANG_FLAG_4(NODE))\n+\n+/* Indicates that a NON_LVALUE_EXPR came from a C++ reference.\n+   Used to generate more helpful error message in case somebody\n+   tries to take its address.  */\n+#define TREE_REFERENCE_EXPR(NODE) (TREE_LANG_FLAG_3(NODE))\n+\n+/* Nonzero for _TYPE means that the _TYPE defines a destructor.  */\n+#define TYPE_HAS_DESTRUCTOR(NODE) (TYPE_LANG_FLAG_2(NODE))\n+\n+/* Nonzero for _TYPE node means that creating an object of this type\n+   will involve a call to a constructor.  This can apply to objects\n+   of ARRAY_TYPE if the type of the elements needs a constructor.  */\n+#define TYPE_NEEDS_CONSTRUCTING(NODE) (TYPE_LANG_FLAG_3(NODE))\n+\n+/* Nonzero if there is a user-defined X::op=(x&) for this class.  */\n+#define TYPE_HAS_REAL_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_real_assign_ref)\n+#define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_complex_assign_ref)\n+#define TYPE_HAS_COMPLEX_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_complex_init_ref)\n+\n+/* Nonzero for _TYPE node means that destroying an object of this type\n+   will involve a call to a destructor.  This can apply to objects\n+   of ARRAY_TYPE is the type of the elements needs a destructor.  */\n+#define TYPE_NEEDS_DESTRUCTOR(NODE) (TYPE_LANG_FLAG_4(NODE))\n+\n+/* Nonzero for _TYPE node means that this type is a pointer to member\n+   function type. */\n+#define TYPE_PTRMEMFUNC_P(NODE) (TREE_CODE(NODE) == RECORD_TYPE && TYPE_LANG_SPECIFIC(NODE)->type_flags.ptrmemfunc_flag)\n+#define TYPE_PTRMEMFUNC_FLAG(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.ptrmemfunc_flag)\n+/* Get the POINTER_TYPE to the METHOD_TYPE associated with this\n+   pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,\n+   before using this macro. */\n+#define TYPE_PTRMEMFUNC_FN_TYPE(NODE) (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (NODE)))))))\n+/* These are use to manipulate the the canonical RECORD_TYPE from the\n+   hashed POINTER_TYPE, and can only be used on the POINTER_TYPE. */\n+#define TYPE_GET_PTRMEMFUNC_TYPE(NODE) ((tree)TYPE_LANG_SPECIFIC(NODE))\n+#define TYPE_SET_PTRMEMFUNC_TYPE(NODE, VALUE) (TYPE_LANG_SPECIFIC(NODE) = ((struct lang_type *)(void*)(VALUE)))\n+/* These are to get the delta2 and pfn fields from a TYPE_PTRMEMFUNC_P. */\n+#define DELTA2_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, 0, 0), delta2_identifier, 0, 0))\n+#define PFN_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, 0, 0), pfn_identifier, 0, 0))\n+\n+/* Nonzero for VAR_DECL node means that `external' was specified in\n+   its declaration.  */\n+#define DECL_THIS_EXTERN(NODE) (DECL_LANG_FLAG_2(NODE))\n+\n+/* Nonzero for SAVE_EXPR if used to initialize a PARM_DECL.  */\n+#define PARM_DECL_EXPR(NODE) (TREE_LANG_FLAG_2(NODE))\n+\n+/* Nonzero in FUNCTION_DECL means it is really an operator.\n+   Just used to communicate formatting information to dbxout.c.  */\n+#define DECL_OPERATOR(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.operator_attr)\n+\n+#define ANON_UNION_P(NODE) (DECL_NAME (NODE) == 0)\n+\n+#define UNKNOWN_TYPE LANG_TYPE\n+\n+/* Define fields and accessors for nodes representing declared names.  */\n+\n+#if 0\n+/* C++: A derived class may be able to directly use the virtual\n+   function table of a base class.  When it does so, it may\n+   still have a decl node used to access the virtual function\n+   table (so that variables of this type can initialize their\n+   virtual function table pointers by name).  When such thievery\n+   is committed, know exactly which base class's virtual function\n+   table is the one being stolen.  This effectively computes the\n+   transitive closure.  */\n+#define DECL_VPARENT(NODE) ((NODE)->decl.arguments)\n+#endif\n+\n+/* Make a slot so we can implement nested types.  This slot holds\n+   the IDENTIFIER_NODE that uniquely names the nested type.  This\n+   is for TYPE_DECLs only.  */\n+#define DECL_NESTED_TYPENAME(NODE) ((NODE)->decl.arguments)\n+#define TYPE_NESTED_NAME(NODE) (DECL_NESTED_TYPENAME (TYPE_NAME (NODE)))\n+\n+#define TYPE_WAS_ANONYMOUS(NODE) (TYPE_LANG_SPECIFIC (NODE)->type_flags.was_anonymous)\n+\n+/* C++: all of these are overloaded!  These apply only to TYPE_DECLs.  */\n+#define DECL_FRIENDLIST(NODE)\t\t(DECL_INITIAL (NODE))\n+#if 0\n+#define DECL_UNDEFINED_FRIENDS(NODE)\t((NODE)->decl.result)\n+#endif\n+#define DECL_WAITING_FRIENDS(NODE)\t((tree)(NODE)->decl.rtl)\n+#define SET_DECL_WAITING_FRIENDS(NODE,VALUE) \\\n+\t((NODE)->decl.rtl=(struct rtx_def*)VALUE)\n+\n+/* The DECL_ACCESS is used to record under which context\n+   special access rules apply.  */\n+#define DECL_ACCESS(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.access)\n+\n+/* C++: all of these are overloaded!\n+   These apply to PARM_DECLs and VAR_DECLs.  */\n+#define DECL_REFERENCE_SLOT(NODE) ((tree)(NODE)->decl.arguments)\n+#define SET_DECL_REFERENCE_SLOT(NODE,VAL) ((NODE)->decl.arguments=VAL)\n+\n+/* For local VAR_DECLs, holds index into gc-protected obstack.  */\n+#define DECL_GC_OFFSET(NODE) ((NODE)->decl.result)\n+\n+/* Accessor macros for C++ template decl nodes.  */\n+#define DECL_TEMPLATE_IS_CLASS(NODE)    (DECL_RESULT(NODE) == NULL_TREE)\n+#define DECL_TEMPLATE_PARMS(NODE)       DECL_ARGUMENTS(NODE)\n+/* For class templates.  */\n+#define DECL_TEMPLATE_MEMBERS(NODE)     DECL_INITIAL(NODE)\n+/* For function, method, class-data templates.  */\n+#define DECL_TEMPLATE_RESULT(NODE)      DECL_RESULT(NODE)\n+#define DECL_TEMPLATE_INSTANTIATIONS(NODE) DECL_VINDEX(NODE)\n+\n+/* ...and for unexpanded-parameterized-type nodes.  */\n+#define UPT_TEMPLATE(NODE)      TREE_PURPOSE(TYPE_VALUES(NODE))\n+#define UPT_PARMS(NODE)         TREE_VALUE(TYPE_VALUES(NODE))\n+\n+/* An enumeration of the kind of tags that C++ accepts.  */\n+enum tag_types { record_type, class_type, union_type, enum_type,\n+\t\t   exception_type, signature_type };\n+\n+/* Zero means prototype weakly, as in ANSI C (no args means nothing).\n+   Each language context defines how this variable should be set.  */\n+extern int strict_prototype;\n+extern int strict_prototypes_lang_c, strict_prototypes_lang_cplusplus;\n+\n+/* Non-zero means that if a label exists, and no other identifier\n+   applies, use the value of the label.  */\n+extern int flag_labels_ok;\n+\n+/* Non-zero means to collect statistics which might be expensive\n+   and to print them when we are done.  */\n+extern int flag_detailed_statistics;\n+\n+/* Non-zero means warn in function declared in derived class has the\n+   same name as a virtual in the base class, but fails to match the\n+   type signature of any virtual function in the base class.  */\n+extern int warn_overloaded_virtual;\n+\n+/* in c-common.c */\n+extern void declare_function_name               PROTO((void));\n+extern void decl_attributes                     PROTO((tree, tree));\n+extern void init_function_format_info\t\tPROTO((void));\n+extern void record_function_format\t\tPROTO((tree, tree, int, int, int));\n+extern void check_function_format\t\tPROTO((tree, tree, tree));\n+/* Print an error message for invalid operands to arith operation CODE.\n+   NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n+extern void binary_op_error                     PROTO((enum tree_code));\n+extern void c_expand_expr_stmt                  PROTO((tree));\n+/* Validate the expression after `case' and apply default promotions.  */\n+extern tree check_case_value                    PROTO((tree));\n+/* Concatenate a list of STRING_CST nodes into one STRING_CST.  */\n+extern tree combine_strings                     PROTO((tree));\n+extern void constant_expression_warning         PROTO((tree));\n+extern tree convert_and_check\t\t\tPROTO((tree, tree));\n+extern void overflow_warning\t\t\tPROTO((tree));\n+extern void unsigned_conversion_warning\t\tPROTO((tree, tree));\n+/* Read the rest of the current #-directive line.  */\n+extern char *get_directive_line                 STDIO_PROTO((FILE *));\n+/* Subroutine of build_binary_op, used for comparison operations.\n+   See if the operands have both been converted from subword integer types\n+   and, if so, perhaps change them both back to their original type.  */\n+extern tree shorten_compare                     PROTO((tree *, tree *, tree *, enum tree_code *));\n+/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n+   or validate its data type for an `if' or `while' statement or ?..: exp. */\n+extern tree truthvalue_conversion               PROTO((tree));\n+extern tree type_for_mode                       PROTO((enum machine_mode, int));\n+extern tree type_for_size                       PROTO((unsigned, int));\n+\n+/* in cp-decl{2}.c */\n+extern tree void_list_node;\n+extern tree void_zero_node;\n+extern tree default_function_type;\n+extern tree vtable_entry_type;\n+extern tree sigtable_entry_type;\n+extern tree __t_desc_type_node, __i_desc_type_node, __m_desc_type_node;\n+extern tree Type_info_type_node;\n+extern tree class_star_type_node;\n+extern tree this_identifier;\n+extern tree pfn_identifier;\n+extern tree index_identifier;\n+extern tree delta_identifier;\n+extern tree delta2_identifier;\n+extern tree pfn_or_delta2_identifier;\n+\n+/* A node that is a list (length 1) of error_mark_nodes.  */\n+extern tree error_mark_list;\n+\n+extern tree ptr_type_node, const_ptr_type_node;\n+extern tree class_type_node, record_type_node, union_type_node, enum_type_node;\n+extern tree exception_type_node, unknown_type_node;\n+extern tree opaque_type_node, signature_type_node;\n+\n+/* The largest size a virtual function table can be.\n+   Must be a (power of 2).  */\n+#ifndef VINDEX_MAX\n+#define VINDEX_MAX ((unsigned)128)\n+/* This is the integer ~ (vindex_max - 1).  */\n+#endif\n+extern tree vtbl_mask;\n+\n+/* Array type `(void *)[]' */\n+extern tree vtbl_type_node;\n+extern tree delta_type_node;\n+\n+extern tree long_long_integer_type_node, long_long_unsigned_type_node;\n+/* For building calls to `delete'.  */\n+extern tree integer_two_node, integer_three_node;\n+\n+/* in cp-except.c */\n+extern tree current_exception_type;\n+extern tree current_exception_decl;\n+extern tree current_exception_object;\n+\n+/* in cp-pt.c  */\n+/* PARM_VEC is a vector of template parameters, either IDENTIFIER_NODEs or\n+   PARM_DECLs.  BINDINGS, if non-null, is a vector of bindings for those\n+   parameters.  */\n+struct template_info {\n+  /* Vector of template parameters, either PARM_DECLs or IDENTIFIER_NODEs.  */\n+  tree parm_vec;\n+  /* If non-null, a vector of bindings for the template parms.  */\n+  tree bindings;\n+\n+  /* Text of template, and length.  */\n+  char *text;\n+  int length;\n+  /* Where it came from.  */\n+  char *filename;\n+  int lineno;\n+\n+  /* What kind of aggregate -- struct, class, or null.  */\n+  tree aggr;\n+};\n+extern int processing_template_decl, processing_template_defn;\n+\n+/* The template currently being instantiated, and where the instantiation\n+   was triggered.  */\n+struct tinst_level\n+{\n+  tree classname;\n+  int line;\n+  char *file;\n+  struct tinst_level *next;\n+};\n+\n+extern struct tinst_level *current_tinst_level;\n+\n+/* in cp-class.c */\n+extern tree current_class_name;\n+extern tree current_class_type;\n+extern tree previous_class_type;\n+\n+extern tree current_lang_name, lang_name_cplusplus, lang_name_c;\n+\n+/* Points to the name of that function. May not be the DECL_NAME\n+   of CURRENT_FUNCTION_DECL due to overloading */\n+extern tree original_function_name;\n+\n+extern tree current_class_name, current_class_type, current_class_decl, C_C_D;\n+extern tree current_vtable_decl;\n+\n+/* in cp-init.c  */\n+extern tree global_base_init_list;\n+extern tree current_base_init_list, current_member_init_list;\n+\n+extern int current_function_assigns_this;\n+extern int current_function_just_assigned_this;\n+extern int current_function_parms_stored;\n+\f\n+/* Here's where we control how name mangling takes place.  */\n+\n+#define OPERATOR_ASSIGN_FORMAT \"__a%s\"\n+#define OPERATOR_FORMAT \"__%s\"\n+#define OPERATOR_TYPENAME_FORMAT \"__op\"\n+#define OPERATOR_TYPENAME_P(ID_NODE) \\\n+  (IDENTIFIER_POINTER (ID_NODE)[0] == '_'\t\\\n+   && IDENTIFIER_POINTER (ID_NODE)[1] == '_'\t\\\n+   && IDENTIFIER_POINTER (ID_NODE)[2] == 'o'\t\\\n+   && IDENTIFIER_POINTER (ID_NODE)[3] == 'p')\n+\n+\n+/* Cannot use '$' up front, because this confuses gdb\n+   (names beginning with '$' are gdb-local identifiers).\n+\n+   Note that all forms in which the '$' is significant are long enough\n+   for direct indexing (meaning that if we know there is a '$'\n+   at a particular location, we can index into the string at\n+   any other location that provides distinguishing characters).  */\n+\n+/* Define NO_DOLLAR_IN_LABEL in your favorite tm file if your assembler\n+   doesn't allow '$' in symbol names.  */\n+#ifndef NO_DOLLAR_IN_LABEL\n+\n+#define JOINER '$'\n+\n+#define VPTR_NAME \"$v\"\n+#define THROW_NAME \"$eh_throw\"\n+#define DESTRUCTOR_DECL_PREFIX \"_$_\"\n+#define AUTO_VTABLE_NAME \"__vtbl$me__\"\n+#define AUTO_TEMP_NAME \"_$tmp_\"\n+#define AUTO_TEMP_FORMAT \"_$tmp_%d\"\n+#define VTABLE_BASE \"$vb\"\n+#define VTABLE_NAME_FORMAT \"_vt$%s\"\n+#define VFIELD_BASE \"$vf\"\n+#define VFIELD_NAME \"_vptr$\"\n+#define VFIELD_NAME_FORMAT \"_vptr$%s\"\n+#define VBASE_NAME \"_vb$\"\n+#define VBASE_NAME_FORMAT \"_vb$%s\"\n+#define STATIC_NAME_FORMAT \"_%s$%s\"\n+#define ANON_AGGRNAME_FORMAT \"$_%d\"\n+\n+#else /* NO_DOLLAR_IN_LABEL */\n+\n+#ifndef NO_DOT_IN_LABEL\n+\n+#define JOINER '.'\n+\n+#define VPTR_NAME \".v\"\n+#define THROW_NAME \".eh_throw\"\n+#define DESTRUCTOR_DECL_PREFIX \"_._\"\n+#define AUTO_VTABLE_NAME \"__vtbl.me__\"\n+#define AUTO_TEMP_NAME \"_.tmp_\"\n+#define AUTO_TEMP_FORMAT \"_.tmp_%d\"\n+#define VTABLE_BASE \".vb\"\n+#define VTABLE_NAME_FORMAT \"_vt.%s\"\n+#define VFIELD_BASE \".vf\"\n+#define VFIELD_NAME \"_vptr.\"\n+#define VFIELD_NAME_FORMAT \"_vptr.%s\"\n+#define VBASE_NAME \"_vb.\"\n+#define VBASE_NAME_FORMAT \"_vb.%s\"\n+#define STATIC_NAME_FORMAT \"_%s.%s\"\n+\n+#define ANON_AGGRNAME_FORMAT \"._%d\"\n+\n+#else /* NO_DOT_IN_LABEL */\n+\n+#define VPTR_NAME \"__vptr\"\n+#define VPTR_NAME_P(ID_NODE) \\\n+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), VPTR_NAME, sizeof (VPTR_NAME) - 1))\n+#define THROW_NAME \"__eh_throw\"\n+#define DESTRUCTOR_DECL_PREFIX \"__destr_\"\n+#define DESTRUCTOR_NAME_P(ID_NODE) \\\n+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), DESTRUCTOR_DECL_PREFIX, \\\n+\t     sizeof (DESTRUCTOR_DECL_PREFIX) - 1))\n+#define IN_CHARGE_NAME \"__in_chrg\"\n+#define AUTO_VTABLE_NAME \"__vtbl_me__\"\n+#define AUTO_TEMP_NAME \"__tmp_\"\n+#define TEMP_NAME_P(ID_NODE) \\\n+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), AUTO_TEMP_NAME, \\\n+\t     sizeof (AUTO_TEMP_NAME) - 1))\n+#define AUTO_TEMP_FORMAT \"__tmp_%d\"\n+#define VTABLE_BASE \"__vtb\"\n+#define VTABLE_NAME \"__vt_\"\n+#define VTABLE_NAME_FORMAT \"__vt_%s\"\n+#define VTABLE_NAME_P(ID_NODE) \\\n+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), VTABLE_NAME, \\\n+\t     sizeof (VTABLE_NAME) - 1))\n+#define VFIELD_BASE \"__vfb\"\n+#define VFIELD_NAME \"__vptr_\"\n+#define VFIELD_NAME_P(ID_NODE) \\\n+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), VFIELD_NAME, \\\n+\t    sizeof (VFIELD_NAME) - 1))\n+#define VFIELD_NAME_FORMAT \"_vptr_%s\"\n+#define VBASE_NAME \"__vb_\"\n+#define VBASE_NAME_P(ID_NODE) \\\n+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), VBASE_NAME, \\\n+\t     sizeof (VBASE_NAME) - 1))\n+#define VBASE_NAME_FORMAT \"__vb_%s\"\n+#define STATIC_NAME_FORMAT \"__static_%s_%s\"\n+\n+#define ANON_AGGRNAME_PREFIX \"__anon_\"\n+#define ANON_AGGRNAME_P(ID_NODE) \\\n+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), ANON_AGGRNAME_PREFIX, \\\n+\t     sizeof (ANON_AGGRNAME_PREFIX) - 1))\n+#define ANON_AGGRNAME_FORMAT \"__anon_%d\"\n+#define ANON_PARMNAME_FORMAT \"__%d\"\n+#define ANON_PARMNAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[0] == '_' \\\n+\t\t\t\t  && IDENTIFIER_POINTER (ID_NODE)[1] == '_' \\\n+\t\t\t\t  && IDENTIFIER_POINTER (ID_NODE)[2] <= '9')\n+\n+#endif\t/* NO_DOT_IN_LABEL */\n+#endif\t/* NO_DOLLAR_IN_LABEL */\n+\n+#define THIS_NAME \"this\"\n+#define DESTRUCTOR_NAME_FORMAT \"~%s\"\n+#define FILE_FUNCTION_PREFIX_LEN 9\n+\n+#define IN_CHARGE_NAME \"__in_chrg\"\n+\n+#define VTBL_PTR_TYPE\t\t\"__vtbl_ptr_type\"\n+#define VTABLE_DELTA_NAME\t\"__delta\"\n+#define VTABLE_INDEX_NAME\t\"__index\"\n+#define VTABLE_PFN_NAME\t\t\"__pfn\"\n+#define VTABLE_DELTA2_NAME\t\"__delta2\"\n+\n+#define SIGNATURE_FIELD_NAME\t\"__s_\"\n+#define SIGNATURE_FIELD_NAME_FORMAT \"__s_%s\"\n+#define SIGNATURE_OPTR_NAME\t\"__optr\"\n+#define SIGNATURE_SPTR_NAME\t\"__sptr\"\n+#define SIGNATURE_VPTR_NAME\t\"__vptr\"\n+#define SIGNATURE_POINTER_NAME\t\"__sp_\"\n+#define SIGNATURE_POINTER_NAME_FORMAT \"__%s%ssp_%s\"\n+#define SIGNATURE_REFERENCE_NAME \"__sr_\"\n+#define SIGNATURE_REFERENCE_NAME_FORMAT \"__%s%ssr_%s\"\n+\n+#define SIGTABLE_PTR_TYPE\t\"__sigtbl_ptr_type\"\n+#define SIGTABLE_NAME_FORMAT\t\"__st_%s_%s\"\n+#define SIGTABLE_NAME_FORMAT_LONG \"__st_%s_%s_%d\"\n+#define SIGTABLE_CODE_NAME\t\"__code\"\n+#define SIGTABLE_OFFSET_NAME\t\"__offset\"\n+#define SIGTABLE_PFN_NAME\t\"__pfn\"\n+#define EXCEPTION_CLEANUP_NAME \t\"exception cleanup\"\n+\n+#define THIS_NAME_P(ID_NODE) (strcmp(IDENTIFIER_POINTER (ID_NODE), \"this\") == 0)\n+\n+#if !defined(NO_DOLLAR_IN_LABEL) || !defined(NO_DOT_IN_LABEL)\n+\n+#define VPTR_NAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[0] == JOINER \\\n+\t\t\t      && IDENTIFIER_POINTER (ID_NODE)[1] == 'v')\n+#define DESTRUCTOR_NAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[1] == JOINER \\\n+                                    && IDENTIFIER_POINTER (ID_NODE)[2] == '_') \n+\n+#define VTABLE_NAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[1] == 'v' \\\n+  && IDENTIFIER_POINTER (ID_NODE)[2] == 't' \\\n+  && IDENTIFIER_POINTER (ID_NODE)[3] == JOINER)\n+\n+#define VBASE_NAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[1] == 'v' \\\n+  && IDENTIFIER_POINTER (ID_NODE)[2] == 'b' \\\n+  && IDENTIFIER_POINTER (ID_NODE)[3] == JOINER)\n+\n+#define TEMP_NAME_P(ID_NODE) (!strncmp (IDENTIFIER_POINTER (ID_NODE), AUTO_TEMP_NAME, sizeof (AUTO_TEMP_NAME)-1))\n+#define VFIELD_NAME_P(ID_NODE) (!strncmp (IDENTIFIER_POINTER (ID_NODE), VFIELD_NAME, sizeof(VFIELD_NAME)-1))\n+\n+/* For anonymous aggregate types, we need some sort of name to\n+   hold on to.  In practice, this should not appear, but it should\n+   not be harmful if it does.  */\n+#define ANON_AGGRNAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[0] == JOINER \\\n+\t\t\t\t  && IDENTIFIER_POINTER (ID_NODE)[1] == '_')\n+#define ANON_PARMNAME_FORMAT \"_%d\"\n+#define ANON_PARMNAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[0] == '_' \\\n+\t\t\t\t  && IDENTIFIER_POINTER (ID_NODE)[1] <= '9')\n+#endif /* !defined(NO_DOLLAR_IN_LABEL) || !defined(NO_DOT_IN_LABEL) */\n+\f\n+/* Define the sets of attributes that member functions and baseclasses\n+   can have.  These are sensible combinations of {public,private,protected}\n+   cross {virtual,non-virtual}.  */\n+\n+enum access_type {\n+  access_default,\n+  access_public,\n+  access_protected,\n+  access_private,\n+  access_default_virtual,\n+  access_public_virtual,\n+  access_private_virtual\n+};\n+\n+/* in cp-lex.c  */\n+extern tree current_unit_name, current_unit_language;\n+\n+/* Things for handling inline functions.  */\n+\n+struct pending_inline\n+{\n+  struct pending_inline *next;\t/* pointer to next in chain */\n+  int lineno;\t\t\t/* line number we got the text from */\n+  char *filename;\t\t/* name of file we were processing */\n+  tree fndecl;\t\t\t/* FUNCTION_DECL that brought us here */\n+  int token;\t\t\t/* token we were scanning */\n+  int token_value;\t\t/* value of token we were scanning (YYSTYPE) */\n+\n+  char *buf;\t\t\t/* pointer to character stream */\n+  int len;\t\t\t/* length of stream */\n+  tree parm_vec, bindings;\t/* in case this is derived from a template */\n+  unsigned int can_free : 1;\t/* free this after we're done with it? */\n+  unsigned int deja_vu : 1;\t/* set iff we don't want to see it again.  */\n+  unsigned int interface : 2;\t/* 0=interface 1=unknown 2=implementation */\n+};\n+\n+/* in cp-method.c */\n+extern struct pending_inline *pending_inlines;\n+\n+/* 1 for -fall-virtual: make every member function (except\n+   constructors) lay down in the virtual function table.\n+   Calls can then either go through the virtual function table or not,\n+   depending on whether we know what function will actually be called.  */\n+\n+extern int flag_all_virtual;\n+\n+/* Positive values means that we cannot make optimizing assumptions about\n+   `this'.  Negative values means we know `this' to be of static type.  */\n+\n+extern int flag_this_is_variable;\n+\n+/* Controls whether enums and ints freely convert.\n+   1 means with complete freedom.\n+   0 means enums can convert to ints, but not vice-versa.  */\n+\n+extern int flag_int_enum_equivalence;\n+\n+/* Nonzero means layout structures so that we can do garbage collection.  */\n+\n+extern int flag_gc;\n+\n+/* Nonzero means generate 'dossiers' that give run-time type information.  */\n+\n+extern int flag_dossier;\n+\n+/* Nonzero means templates obey #pragma interface and implementation.  */\n+\n+extern int flag_external_templates;\n+\n+/* Nonzero means templates are emitted where they are instantiated.  */\n+\n+extern int flag_alt_external_templates;\n+\n+/* Current end of entries in the gc obstack for stack pointer variables.  */\n+\n+extern int current_function_obstack_index;\n+\n+/* Flag saying whether we have used the obstack in this function or not.  */\n+\n+extern int current_function_obstack_usage;\n+\n+enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n+\n+extern tree current_class_decl, C_C_D;\t/* PARM_DECL: the class instance variable */\n+\n+/* The following two can be derived from the previous one */\n+extern tree current_class_name;\t/* IDENTIFIER_NODE: name of current class */\n+extern tree current_class_type;\t/* _TYPE: the type of the current class */\n+\n+/* Some macros for char-based bitfields.  */\n+#define B_SET(a,x) (a[x>>3] |= (1 << (x&7)))\n+#define B_CLR(a,x) (a[x>>3] &= ~(1 << (x&7)))\n+#define B_TST(a,x) (a[x>>3] & (1 << (x&7)))\n+\n+/* These are uses as bits in flags passed to build_method_call\n+   to control its error reporting behavior.\n+\n+   LOOKUP_PROTECT means flag access violations.\n+   LOOKUP_COMPLAIN mean complain if no suitable member function\n+     matching the arguments is found.\n+   LOOKUP_NORMAL is just a combination of these two.\n+   LOOKUP_AGGR requires the instance to be of aggregate type.\n+   LOOKUP_NONVIRTUAL means make a direct call to the member function found\n+   LOOKUP_GLOBAL means search through the space of overloaded functions,\n+     as well as the space of member functions.\n+   LOOKUP_HAS_IN_CHARGE means that the \"in charge\" variable is already\n+     in the parameter list.\n+   LOOKUP_NO_CONVERSION means that user-defined conversions are not\n+     permitted.  Built-in conversions are permitted.\n+   LOOKUP_DESTRUCTOR means explicit call to destructor.  */\n+\n+#define LOOKUP_PROTECT (1)\n+#define LOOKUP_COMPLAIN (2)\n+#define LOOKUP_NORMAL (3)\n+#define LOOKUP_AGGR (4)\n+#define LOOKUP_NONVIRTUAL (8)\n+#define LOOKUP_GLOBAL (16)\n+#define LOOKUP_HAS_IN_CHARGE (32)\n+#define LOOKUP_SPECULATIVELY (64)\n+/* 128 & 256 are free */\n+#define LOOKUP_NO_CONVERSION (512)\n+#define LOOKUP_DESTRUCTOR (512)\n+\n+/* Anatomy of a DECL_FRIENDLIST (which is a TREE_LIST):\n+   purpose = friend name (IDENTIFIER_NODE);\n+   value = TREE_LIST of FUNCTION_DECLS;\n+   chain, type = EMPTY;  */\n+#define FRIEND_NAME(LIST) (TREE_PURPOSE (LIST))\n+#define FRIEND_DECLS(LIST) (TREE_VALUE (LIST))\n+\n+/* These macros are for accessing the fields of TEMPLATE...PARM nodes.  */\n+#define TEMPLATE_TYPE_TPARMLIST(NODE) TREE_PURPOSE (TYPE_FIELDS (NODE))\n+#define TEMPLATE_TYPE_IDX(NODE) TREE_INT_CST_LOW (TREE_VALUE (TYPE_FIELDS (NODE)))\n+#define TEMPLATE_TYPE_SET_INFO(NODE,P,I) \\\n+  (TYPE_FIELDS (NODE) = build_tree_list (P, build_int_2 (I, 0)))\n+#define TEMPLATE_CONST_TPARMLIST(NODE) (*(tree*)&TREE_INT_CST_LOW(NODE))\n+#define TEMPLATE_CONST_IDX(NODE) (TREE_INT_CST_HIGH(NODE))\n+#define TEMPLATE_CONST_SET_INFO(NODE,P,I) \\\n+  (TEMPLATE_CONST_TPARMLIST (NODE) = saved_parmlist, \\\n+   TEMPLATE_CONST_IDX (NODE) = I)\n+\n+/* in cp-lex.c  */\n+/* Indexed by TREE_CODE, these tables give C-looking names to\n+   operators represented by TREE_CODES.  For example,\n+   opname_tab[(int) MINUS_EXPR] == \"-\".  */\n+extern char **opname_tab, **assignop_tab;\n+\f\n+/* in c-common.c */\n+extern tree convert_and_check\t\t\tPROTO((tree, tree));\n+extern void overflow_warning\t\t\tPROTO((tree));\n+extern void unsigned_conversion_warning\t\tPROTO((tree, tree));\n+\n+/* in cp-call.c */\n+extern struct candidate *ansi_c_bullshit;\n+\n+extern int rank_for_overload\t\t\tPROTO((struct candidate *, struct candidate *));\n+extern void compute_conversion_costs\t\tPROTO((tree, tree, struct candidate *, int));\n+extern int get_arglist_len_in_bytes\t\tPROTO((tree));\n+extern tree build_vfield_ref\t\t\tPROTO((tree, tree));\n+extern tree find_scoped_type\t\t\tPROTO((tree, tree, tree));\n+extern tree resolve_scope_to_name\t\tPROTO((tree, tree));\n+extern tree build_scoped_method_call\t\tPROTO((tree, tree, tree, tree));\n+extern tree build_method_call\t\t\tPROTO((tree, tree, tree, tree, int));\n+extern tree build_overload_call_real\t\tPROTO((tree, tree, int, struct candidate *, int));\n+extern tree build_overload_call\t\t\tPROTO((tree, tree, int, struct candidate *));\n+extern tree build_overload_call_maybe\t\tPROTO((tree, tree, int, struct candidate *));\n+\n+/* in cp-class.c */\n+extern tree build_vbase_pointer\t\t\tPROTO((tree, tree));\n+extern tree build_vbase_path\t\t\tPROTO((enum tree_code, tree, tree, tree, int));\n+extern tree build_vtable_entry\t\t\tPROTO((tree, tree));\n+extern tree build_vfn_ref\t\t\tPROTO((tree *, tree, tree));\n+extern void add_method\t\t\t\tPROTO((tree, tree *, tree));\n+extern void duplicate_tag_error\t\t\tPROTO((tree));\n+extern tree finish_struct\t\t\tPROTO((tree, tree, int));\n+extern int resolves_to_fixed_type_p\t\tPROTO((tree, int *));\n+extern void init_class_processing\t\tPROTO((void));\n+extern void pushclass\t\t\t\tPROTO((tree, int));\n+extern void popclass\t\t\t\tPROTO((int));\n+extern void push_nested_class\t\t\tPROTO((tree, int));\n+extern void pop_nested_class\t\t\tPROTO((int));\n+extern void push_lang_context\t\t\tPROTO((tree));\n+extern void pop_lang_context\t\t\tPROTO((void));\n+extern int root_lang_context_p\t\t\tPROTO((void));\n+extern tree instantiate_type\t\t\tPROTO((tree, tree, int));\n+extern void print_class_statistics\t\tPROTO((void));\n+extern void maybe_push_cache_obstack\t\tPROTO((void));\n+\n+/* in cp-cvt.c */\n+extern tree convert_to_reference\t\tPROTO((tree, tree, tree, tree, int, char *, int, int));\n+extern tree convert_from_reference\t\tPROTO((tree));\n+extern tree convert_to_aggr\t\t\tPROTO((tree, tree, char **, int));\n+extern tree convert_pointer_to\t\t\tPROTO((tree, tree));\n+extern tree convert_pointer_to_real\t\tPROTO((tree, tree));\n+extern tree convert_pointer_to_vbase\t\tPROTO((tree, tree));\n+extern tree convert\t\t\t\tPROTO((tree, tree));\n+extern tree convert_force\t\t\tPROTO((tree, tree));\n+extern tree build_type_conversion\t\tPROTO((enum tree_code, tree, tree, int));\n+extern int build_default_binary_type_conversion\tPROTO((enum tree_code, tree *, tree *));\n+extern int build_default_unary_type_conversion\tPROTO((enum tree_code, tree *));\n+\n+/* cp-decl.c */\n+extern int global_bindings_p\t\t\tPROTO((void));\n+extern void keep_next_level\t\t\tPROTO((void));\n+extern int kept_level_p\t\t\t\tPROTO((void));\n+extern void declare_parm_level\t\t\tPROTO((void));\n+extern void declare_implicit_exception\t\tPROTO((void));\n+extern int have_exceptions_p\t\t\tPROTO((void));\n+extern void declare_uninstantiated_type_level\tPROTO((void));\n+extern int uninstantiated_type_level_p\t\tPROTO((void));\n+extern void declare_pseudo_global_level\t\tPROTO((void));\n+extern int pseudo_global_level_p\t\tPROTO((void));\n+extern void pushlevel\t\t\t\tPROTO((int));\n+extern void pushlevel_temporary\t\t\tPROTO((int));\n+extern tree poplevel\t\t\t\tPROTO((int, int, int));\n+extern void delete_block\t\t\tPROTO((tree));\n+extern void insert_block\t\t\tPROTO((tree));\n+extern void add_block_current_level\t\tPROTO((tree));\n+extern void set_block\t\t\t\tPROTO((tree));\n+extern void pushlevel_class\t\t\tPROTO((void));\n+extern tree poplevel_class\t\t\tPROTO((void));\n+/* skip print_other_binding_stack and print_binding_level */\n+extern void print_binding_stack\t\t\tPROTO((void));\n+extern void push_to_top_level\t\t\tPROTO((void));\n+extern void pop_from_top_level\t\t\tPROTO((void));\n+extern void set_identifier_type_value\t\tPROTO((tree, tree));\n+extern tree make_type_decl\t\t\tPROTO((tree, tree));\n+extern void pushtag\t\t\t\tPROTO((tree, tree, int));\n+extern tree make_anon_name\t\t\tPROTO((void));\n+extern void clear_anon_tags\t\t\tPROTO((void));\n+extern tree pushdecl\t\t\t\tPROTO((tree));\n+extern tree pushdecl_top_level\t\t\tPROTO((tree));\n+extern void push_class_level_binding\t\tPROTO((tree, tree));\n+extern void push_overloaded_decl_top_level\tPROTO((tree, int));\n+extern tree pushdecl_class_level\t\tPROTO((tree));\n+extern int overloaded_globals_p\t\t\tPROTO((tree));\n+extern tree push_overloaded_decl\t\tPROTO((tree, int));\n+extern tree implicitly_declare\t\t\tPROTO((tree));\n+extern tree lookup_label\t\t\tPROTO((tree));\n+extern tree shadow_label\t\t\tPROTO((tree));\n+extern tree define_label\t\t\tPROTO((char *, int, tree));\n+extern void define_case_label\t\t\tPROTO((tree));\n+extern tree getdecls\t\t\t\tPROTO((void));\n+extern tree gettags\t\t\t\tPROTO((void));\n+extern void set_current_level_tags_transparency\tPROTO((int));\n+extern tree typedecl_for_tag\t\t\tPROTO((tree));\n+extern tree lookup_name\t\t\t\tPROTO((tree, int));\n+extern tree lookup_name_current_level\t\tPROTO((tree));\n+extern void init_decl_processing\t\tPROTO((void));\n+/* skipped define_function */\n+extern void shadow_tag\t\t\t\tPROTO((tree));\n+extern void grok_ctor_properties\t\tPROTO((tree, tree));\n+extern tree groktypename\t\t\tPROTO((tree));\n+extern tree start_decl\t\t\t\tPROTO((tree, tree, int, tree));\n+extern void finish_decl\t\t\t\tPROTO((tree, tree, tree, int));\n+extern void expand_static_init\t\t\tPROTO((tree, tree));\n+extern int complete_array_type\t\t\tPROTO((tree, tree, int));\n+extern tree build_ptrmemfunc_type\t\tPROTO((tree));\n+extern tree grokdeclarator\t\t\t(); /* PROTO((tree, tree, enum decl_context, int, tree)); */\n+extern tree xref_defn_tag\t\t\tPROTO((tree, tree, tree));\n+extern tree xref_tag\t\t\t\tPROTO((tree, tree, tree, int));\n+extern tree start_enum\t\t\t\tPROTO((tree));\n+extern tree finish_enum\t\t\t\tPROTO((tree, tree));\n+extern tree build_enumerator\t\t\tPROTO((tree, tree));\n+extern tree grok_enum_decls\t\t\tPROTO((tree, tree));\n+extern int start_function\t\t\tPROTO((tree, tree, tree, int));\n+extern void store_parm_decls\t\t\tPROTO((void));\n+extern void store_return_init\t\t\tPROTO((tree, tree));\n+extern void finish_function\t\t\tPROTO((int, int));\n+extern tree start_method\t\t\tPROTO((tree, tree, tree));\n+extern tree finish_method\t\t\tPROTO((tree));\n+extern void hack_incomplete_structures\t\tPROTO((tree));\n+extern tree maybe_build_cleanup\t\t\tPROTO((tree));\n+extern void cplus_expand_expr_stmt\t\tPROTO((tree));\n+extern void finish_stmt\t\t\t\tPROTO((void));\n+extern void pop_implicit_try_blocks\t\tPROTO((tree));\n+extern void push_exception_cleanup\t\tPROTO((tree));\n+extern void revert_static_member_fn\t\tPROTO((tree *, tree *, tree *));\n+\n+/* in cp-decl2.c */\n+extern int lang_decode_option\t\t\tPROTO((char *));\n+extern tree grok_method_quals\t\t\tPROTO((tree, tree, tree));\n+extern void grokclassfn\t\t\t\tPROTO((tree, tree, tree, enum overload_flags, tree));\n+extern tree grok_alignof\t\t\tPROTO((tree));\n+extern tree grok_array_decl\t\t\tPROTO((tree, tree));\n+extern tree delete_sanity\t\t\tPROTO((tree, tree, int, int));\n+extern void check_classfn\t\t\tPROTO((tree, tree, tree));\n+extern tree grokfield\t\t\t\tPROTO((tree, tree, tree, tree, tree));\n+extern tree grokbitfield\t\t\tPROTO((tree, tree, tree));\n+extern tree groktypefield\t\t\tPROTO((tree, tree));\n+extern tree grokoptypename\t\t\tPROTO((tree, int));\n+extern tree build_push_scope\t\t\tPROTO((tree, tree));\n+extern tree constructor_name_full\t\tPROTO((tree));\n+extern tree constructor_name\t\t\tPROTO((tree));\n+extern void setup_vtbl_ptr\t\t\tPROTO((void));\n+extern void mark_inline_for_output\t\tPROTO((tree));\n+extern void clear_temp_name\t\t\tPROTO((void));\n+extern tree get_temp_name\t\t\tPROTO((tree, int));\n+extern tree get_temp_regvar\t\t\tPROTO((tree, tree));\n+extern void finish_anon_union\t\t\tPROTO((tree));\n+extern tree finish_table\t\t\tPROTO((tree, tree, tree, int));\n+extern void finish_builtin_type\t\t\tPROTO((tree, char *, tree *, int, tree));\n+extern tree coerce_new_type\t\t\tPROTO((tree));\n+extern tree coerce_delete_type\t\t\tPROTO((tree));\n+extern void walk_vtables\t\t\tPROTO((void (*)(), void (*)()));\n+extern void finish_file\t\t\t\tPROTO((void));\n+extern void warn_if_unknown_interface\t\tPROTO((void));\n+extern tree grok_x_components\t\t\tPROTO((tree, tree));\n+\n+/* in cp-edsel.c */\n+\n+/* in cp-except.c */\n+extern tree lookup_exception_cname\t\tPROTO((tree, tree, tree));\n+extern tree lookup_exception_tname\t\tPROTO((tree));\n+extern tree lookup_exception_object\t\tPROTO((tree, tree, int));\n+extern tree lookup_exception_type\t\tPROTO((tree, tree, tree));\n+extern tree finish_exception\t\t\tPROTO((tree, tree));\n+extern void finish_exception_decl\t\tPROTO((tree, tree));\n+extern void end_exception_decls\t\t\tPROTO((void));\n+extern void cplus_expand_start_try\t\tPROTO((int));\n+extern tree cplus_expand_end_try\t\tPROTO((int));\n+extern void cplus_expand_start_except\t\tPROTO((tree, tree));\n+extern void cplus_expand_end_except\t\tPROTO((tree));\n+extern void cplus_expand_raise\t\t\tPROTO((tree, tree, tree, int));\n+extern tree ansi_exception_object_lookup\tPROTO((tree));\n+extern void cplus_expand_throw\t\t\tPROTO((tree));\n+extern tree cplus_expand_start_catch\t\tPROTO((tree));\n+extern tree ansi_expand_start_catch\t\tPROTO((tree));\n+extern void cplus_expand_end_catch\t\tPROTO((int));\n+extern void cplus_expand_reraise\t\tPROTO((tree));\n+extern void setup_exception_throw_decl\t\tPROTO((void));\n+extern void init_exception_processing\t\tPROTO((void));\n+extern void init_exception_processing_1\t\tPROTO((void));\n+\n+/* in cp-expr.c */\n+/* skip cplus_expand_expr */\n+extern void init_cplus_expand\t\t\tPROTO((void));\n+extern void fixup_result_decl\t\t\tPROTO((tree, struct rtx_def *));\n+extern int decl_in_memory_p\t\t\tPROTO((tree));\n+\n+/* in cp-gc.c */\n+extern int type_needs_gc_entry\t\t\tPROTO((tree));\n+extern int value_safe_from_gc\t\t\tPROTO((tree, tree));\n+extern void build_static_gc_entry\t\tPROTO((tree, tree));\n+extern tree protect_value_from_gc\t\tPROTO((tree, tree));\n+extern tree build_headof\t\t\tPROTO((tree));\n+extern tree build_classof\t\t\tPROTO((tree));\n+extern tree build_t_desc\t\t\tPROTO((tree, int));\n+extern tree build_i_desc\t\t\tPROTO((tree));\n+extern tree build_m_desc\t\t\tPROTO((tree));\n+extern void expand_gc_prologue_and_epilogue\tPROTO((void));\n+extern void lang_expand_end_bindings\t\tPROTO((struct rtx_def *, struct rtx_def *));\n+extern void init_gc_processing\t\t\tPROTO((void));\n+extern tree build_typeid\t\t\tPROTO((tree));\n+extern tree get_typeid\t\t\t\tPROTO((tree));\n+extern tree build_dynamic_cast\t\t\tPROTO((tree, tree));\n+\n+/* in cp-init.c */\n+extern void emit_base_init\t\t\tPROTO((tree, int));\n+extern void check_base_init\t\t\tPROTO((tree));\n+extern tree build_virtual_init\t\t\tPROTO((tree, tree, tree));\n+extern void init_vtbl_ptrs\t\t\tPROTO((tree, int, int));\n+extern void do_member_init\t\t\tPROTO((tree, tree, tree));\n+extern void expand_member_init\t\t\tPROTO((tree, tree, tree));\n+extern void expand_aggr_init\t\t\tPROTO((tree, tree, int));\n+extern int is_aggr_typedef\t\t\tPROTO((tree, int));\n+extern tree get_aggr_from_typedef\t\tPROTO((tree, int));\n+extern tree get_type_value\t\t\tPROTO((tree));\n+extern tree build_member_call\t\t\tPROTO((tree, tree, tree));\n+extern tree build_offset_ref\t\t\tPROTO((tree, tree));\n+extern tree get_member_function\t\t\tPROTO((tree *, tree, tree));\n+extern tree get_member_function_from_ptrfunc\tPROTO((tree *, tree, tree));\n+extern tree resolve_offset_ref\t\t\tPROTO((tree));\n+extern tree decl_constant_value\t\t\tPROTO((tree));\n+extern int is_friend_type\t\t\tPROTO((tree, tree));\n+extern int is_friend\t\t\t\tPROTO((tree, tree));\n+extern void make_friend_class\t\t\tPROTO((tree, tree));\n+extern tree do_friend\t\t\t\tPROTO((tree, tree, tree, tree, enum overload_flags, tree));\n+extern void embrace_waiting_friends\t\tPROTO((tree));\n+extern tree build_builtin_call\t\t\tPROTO((tree, tree, tree));\n+extern tree build_new\t\t\t\tPROTO((tree, tree, tree, int));\n+extern tree expand_vec_init\t\t\tPROTO((tree, tree, tree, tree, int));\n+extern tree build_x_delete\t\t\tPROTO((tree, tree, int, tree));\n+extern tree build_delete\t\t\tPROTO((tree, tree, tree, int, int));\n+extern tree build_vbase_delete\t\t\tPROTO((tree, tree));\n+extern tree build_vec_delete\t\t\tPROTO((tree, tree, tree, tree, tree, tree));\n+\n+/* in cp-input.c */\n+\n+/* in cp-lex.c */\n+extern tree make_pointer_declarator\t\tPROTO((tree, tree));\n+extern tree make_reference_declarator\t\tPROTO((tree, tree));\n+extern char *operator_name_string\t\tPROTO((tree));\n+extern void lang_init\t\t\t\tPROTO((void));\n+extern void lang_finish\t\t\t\tPROTO((void));\n+extern void init_filename_times\t\t\tPROTO((void));\n+extern void reinit_lang_specific\t\tPROTO((void));\n+extern void init_lex\t\t\t\tPROTO((void));\n+extern void reinit_parse_for_function\t\tPROTO((void));\n+extern int *init_parse\t\t\t\tPROTO((void));\n+extern void print_parse_statistics\t\tPROTO((void));\n+extern void extract_interface_info\t\tPROTO((void));\n+extern void set_vardecl_interface_info\t\tPROTO((tree, tree));\n+extern void do_pending_inlines\t\t\tPROTO((void));\n+extern void process_next_inline\t\t\tPROTO((tree));\n+/* skip restore_pending_input */\n+extern void yyungetc\t\t\t\tPROTO((int, int));\n+extern void reinit_parse_for_method\t\tPROTO((int, tree));\n+#if 0\n+extern void reinit_parse_for_block\t\tPROTO((int, struct obstack *, int));\n+#endif\n+extern tree cons_up_default_function\t\tPROTO((tree, tree, tree, int));\n+extern void check_for_missing_semicolon\t\tPROTO((tree));\n+extern void note_got_semicolon\t\t\tPROTO((tree));\n+extern void note_list_got_semicolon\t\tPROTO((tree));\n+extern int check_newline\t\t\tPROTO((void));\n+extern void dont_see_typename\t\t\tPROTO((void));\n+extern int identifier_type\t\t\tPROTO((tree));\n+extern void see_typename\t\t\tPROTO((void));\n+extern tree do_identifier\t\t\tPROTO((tree));\n+extern tree identifier_typedecl_value\t\tPROTO((tree));\n+extern int real_yylex\t\t\t\tPROTO((void));\n+extern tree build_lang_decl\t\t\tPROTO((enum tree_code, tree, tree));\n+extern tree build_lang_field_decl\t\tPROTO((enum tree_code, tree, tree));\n+extern void copy_lang_decl\t\t\tPROTO((tree));\n+extern tree make_lang_type\t\t\tPROTO((enum tree_code));\n+extern void copy_decl_lang_specific\t\tPROTO((tree));\n+extern void dump_time_statistics\t\tPROTO((void));\n+/* extern void compiler_error\t\t\tPROTO((char *, HOST_WIDE_INT, HOST_WIDE_INT)); */\n+extern void compiler_error_with_decl\t\tPROTO((tree, char *));\n+extern void yyerror\t\t\t\tPROTO((char *));\n+\n+/* in cp-error.c */\n+extern void init_error\t\t\t\tPROTO((void));\n+extern char *fndecl_as_string\t\t\tPROTO((tree, tree, int));\n+extern char *type_as_string\t\t\tPROTO((tree, int));\n+extern char *args_as_string\t\t\tPROTO((tree, int));\n+extern char *decl_as_string\t\t\tPROTO((tree, int));\n+extern char *expr_as_string\t\t\tPROTO((tree, int));\n+extern char *code_as_string\t\t\tPROTO((enum tree_code, int));\n+extern char *language_as_string\t\t\tPROTO((enum languages, int));\n+extern char *parm_as_string\t\t\tPROTO((int, int));\n+extern char *op_as_string\t\t\tPROTO((enum tree_code, int));\n+\n+/* in cp-method.c */\n+extern void init_method\t\t\t\tPROTO((void));\n+extern tree make_anon_parm_name\t\t\tPROTO((void));\n+extern void clear_anon_parm_name\t\tPROTO((void));\n+extern void do_inline_function_hair\t\tPROTO((tree, tree));\n+/* skip report_type_mismatch */\n+extern char *build_overload_name\t\tPROTO((tree, int, int));\n+extern tree cplus_exception_name\t\tPROTO((tree));\n+extern tree build_decl_overload\t\t\tPROTO((tree, tree, int));\n+extern tree build_typename_overload\t\tPROTO((tree));\n+extern tree build_t_desc_overload\t\tPROTO((tree));\n+extern void declare_overloaded\t\t\tPROTO((tree));\n+#ifdef NO_AUTO_OVERLOAD\n+extern int is_overloaded\t\t\tPROTO((tree));\n+#endif\n+extern tree build_opfncall\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n+extern tree hack_identifier\t\t\tPROTO((tree, tree, int));\n+extern tree build_component_type_expr\t\tPROTO((tree, tree, tree, int));\n+\n+/* in cp-pt.c */\n+extern void begin_template_parm_list\t\tPROTO((void));\n+extern tree process_template_parm\t\tPROTO((tree, tree));\n+extern tree end_template_parm_list\t\tPROTO((tree));\n+extern void end_template_decl\t\t\tPROTO((tree, tree, tree));\n+extern tree lookup_template_class\t\tPROTO((tree, tree, tree));\n+extern void push_template_decls\t\t\tPROTO((tree, tree, int));\n+extern void pop_template_decls\t\t\tPROTO((tree, tree, int));\n+extern int uses_template_parms\t\t\tPROTO((tree));\n+extern void instantiate_member_templates\tPROTO((tree));\n+extern tree instantiate_class_template\t\tPROTO((tree, int));\n+extern tree instantiate_template\t\tPROTO((tree, tree *));\n+extern void undo_template_name_overload\t\tPROTO((tree, int));\n+extern void overload_template_name\t\tPROTO((tree, int));\n+extern void end_template_instantiation\t\tPROTO((tree));\n+extern void reinit_parse_for_template\t\tPROTO((int, tree, tree));\n+extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, int *, int));\n+extern int do_pending_expansions\t\tPROTO((void));\n+extern void do_pending_templates\t\tPROTO((void));\n+struct tinst_level *tinst_for_decl\t\tPROTO((void));\n+extern void do_function_instantiation\t\tPROTO((tree, tree));\n+\n+/* in cp-search.c */\n+extern tree make_memoized_table_entry\t\tPROTO((tree, tree, int));\n+extern void push_memoized_context\t\tPROTO((tree, int));\n+extern void pop_memoized_context\t\tPROTO((int));\n+extern tree get_binfo\t\t\t\tPROTO((tree, tree, int));\n+extern int get_base_distance\t\t\tPROTO((tree, tree, int, tree *));\n+extern enum access_type check_access\tPROTO((tree, tree));\n+extern tree lookup_field\t\t\tPROTO((tree, tree, int, int));\n+extern tree lookup_nested_field\t\t\tPROTO((tree, int));\n+extern tree lookup_fnfields\t\t\tPROTO((tree, tree, int));\n+extern HOST_WIDE_INT breadth_first_search\tPROTO((tree, int (*)(), int (*)()));\n+extern int tree_needs_constructor_p\t\tPROTO((tree, int));\n+extern int tree_has_any_destructor_p\t\tPROTO((tree, int));\n+extern tree get_first_matching_virtual\t\tPROTO((tree, tree, int));\n+extern tree get_abstract_virtuals\t\tPROTO((tree));\n+extern tree get_baselinks\t\t\tPROTO((tree, tree, tree));\n+extern tree next_baselink\t\t\tPROTO((tree));\n+extern tree init_vbase_pointers\t\t\tPROTO((tree, tree));\n+extern tree build_vbase_vtables_init\t\tPROTO((tree, tree, tree, tree, int));\n+extern void clear_search_slots\t\t\tPROTO((tree));\n+extern tree get_vbase_types\t\t\tPROTO((tree));\n+extern void build_mi_matrix\t\t\tPROTO((tree));\n+extern void free_mi_matrix\t\t\tPROTO((void));\n+extern void build_mi_virtuals\t\t\tPROTO((int, int));\n+extern void add_mi_virtuals\t\t\tPROTO((int, tree));\n+extern void report_ambiguous_mi_virtuals\tPROTO((int, tree));\n+extern void note_debug_info_needed\t\tPROTO((tree));\n+extern void push_class_decls\t\t\tPROTO((tree));\n+extern void pop_class_decls\t\t\tPROTO((tree));\n+extern void unuse_fields\t\t\tPROTO((tree));\n+extern void unmark_finished_struct\t\tPROTO((tree));\n+extern void print_search_statistics\t\tPROTO((void));\n+extern void init_search_processing\t\tPROTO((void));\n+extern void reinit_search_statistics\t\tPROTO((void));\n+extern tree current_scope\t\t\tPROTO((void));\n+\n+/* in cp-sig.c */\n+extern tree build_signature_pointer_type\tPROTO((tree, int, int));\n+extern tree build_signature_reference_type\tPROTO((tree, int, int));\n+extern tree build_signature_pointer_constructor\tPROTO((tree, tree));\n+extern tree build_signature_method_call\t\tPROTO((tree, tree, tree, tree));\n+extern tree build_optr_ref\t\t\tPROTO((tree));\n+extern tree build_sptr_ref\t\t\tPROTO((tree));\n+extern tree build_vptr_ref\t\t\tPROTO((tree));\n+\n+/* in cp-spew.c */\n+extern void init_spew\t\t\t\tPROTO((void));\n+extern int yylex\t\t\t\tPROTO((void));\n+extern tree arbitrate_lookup\t\t\tPROTO((tree, tree, tree));\n+\n+/* in cp-tree.c */\n+extern int lvalue_p\t\t\t\tPROTO((tree));\n+extern int lvalue_or_else\t\t\tPROTO((tree, char *));\n+extern tree build_cplus_new\t\t\tPROTO((tree, tree, int));\n+extern tree break_out_cleanups\t\t\tPROTO((tree));\n+extern tree break_out_calls\t\t\tPROTO((tree));\n+extern tree build_cplus_method_type\t\tPROTO((tree, tree, tree));\n+extern tree build_cplus_staticfn_type\t\tPROTO((tree, tree, tree));\n+extern tree build_cplus_array_type\t\tPROTO((tree, tree));\n+extern void propagate_binfo_offsets\t\tPROTO((tree, tree));\n+extern int layout_vbasetypes\t\t\tPROTO((tree, int));\n+extern tree layout_basetypes\t\t\tPROTO((tree, tree));\n+extern int list_hash\t\t\t\tPROTO((tree));\n+extern tree list_hash_lookup\t\t\tPROTO((int, tree));\n+extern void list_hash_add\t\t\tPROTO((int, tree));\n+extern tree list_hash_canon\t\t\tPROTO((int, tree));\n+extern tree hash_tree_cons\t\t\tPROTO((int, int, int, tree, tree, tree));\n+extern tree hash_tree_chain\t\t\tPROTO((tree, tree));\n+extern tree hash_chainon\t\t\tPROTO((tree, tree));\n+extern tree get_decl_list\t\t\tPROTO((tree));\n+extern tree list_hash_lookup_or_cons\t\tPROTO((tree));\n+extern tree make_binfo\t\t\t\tPROTO((tree, tree, tree, tree, tree));\n+extern tree copy_binfo\t\t\t\tPROTO((tree));\n+extern tree binfo_value\t\t\t\tPROTO((tree, tree));\n+extern tree reverse_path\t\t\tPROTO((tree));\n+extern tree virtual_member\t\t\tPROTO((tree, tree));\n+extern tree virtual_offset\t\t\tPROTO((tree, tree, tree));\n+extern void debug_binfo\t\t\t\tPROTO((tree));\n+extern int decl_list_length\t\t\tPROTO((tree));\n+extern tree decl_value_member\t\t\tPROTO((tree, tree));\n+extern int is_overloaded_fn\t\t\tPROTO((tree));\n+extern tree get_first_fn\t\t\tPROTO((tree));\n+extern tree fnaddr_from_vtable_entry\t\tPROTO((tree));\n+extern void set_fnaddr_from_vtable_entry\tPROTO((tree, tree));\n+extern tree function_arg_chain\t\t\tPROTO((tree));\n+extern int promotes_to_aggr_type\t\tPROTO((tree, enum tree_code));\n+extern int is_aggr_type_2\t\t\tPROTO((tree, tree));\n+extern void message_2_types\t\t\tPROTO((void (*)(), char *, tree, tree));\n+extern char *lang_printable_name\t\tPROTO((tree));\n+extern tree build_exception_variant\t\tPROTO((tree, tree, tree));\n+extern tree copy_to_permanent\t\t\tPROTO((tree));\n+extern void print_lang_statistics\t\tPROTO((void));\n+/* skip __eprintf */\n+extern tree array_type_nelts_total\t\tPROTO((tree));\n+extern tree array_type_nelts_top\t\tPROTO((tree));\n+\n+/* in cp-typeck.c */\n+extern tree target_type\t\t\t\tPROTO((tree));\n+extern tree require_complete_type\t\tPROTO((tree));\n+extern int type_unknown_p\t\t\tPROTO((tree));\n+extern int fntype_p\t\t\t\tPROTO((tree));\n+extern tree require_instantiated_type\t\tPROTO((tree, tree, tree));\n+extern tree commonparms\t\t\t\tPROTO((tree, tree));\n+extern tree common_type\t\t\t\tPROTO((tree, tree));\n+extern int compexcepttypes\t\t\tPROTO((tree, tree, int));\n+extern int comptypes\t\t\t\tPROTO((tree, tree, int));\n+extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n+extern tree common_base_types\t\t\tPROTO((tree, tree));\n+extern int compparms\t\t\t\tPROTO((tree, tree, int));\n+extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n+extern tree unsigned_type\t\t\tPROTO((tree));\n+extern tree signed_type\t\t\t\tPROTO((tree));\n+extern tree signed_or_unsigned_type\t\tPROTO((int, tree));\n+extern tree c_sizeof\t\t\t\tPROTO((tree));\n+extern tree c_sizeof_nowarn\t\t\tPROTO((tree));\n+extern tree c_alignof\t\t\t\tPROTO((tree));\n+extern tree default_conversion\t\t\tPROTO((tree));\n+extern tree build_object_ref\t\t\tPROTO((tree, tree, tree));\n+extern tree build_component_ref_1\t\tPROTO((tree, tree, int));\n+extern tree build_component_ref\t\t\tPROTO((tree, tree, tree, int));\n+extern tree build_x_indirect_ref\t\tPROTO((tree, char *));\n+extern tree build_indirect_ref\t\t\tPROTO((tree, char *));\n+extern tree build_x_array_ref\t\t\tPROTO((tree, tree));\n+extern tree build_array_ref\t\t\tPROTO((tree, tree));\n+extern tree build_x_function_call\t\tPROTO((tree, tree, tree));\n+extern tree build_function_call_real\t\tPROTO((tree, tree, int, int));\n+extern tree build_function_call\t\t\tPROTO((tree, tree));\n+extern tree build_function_call_maybe\t\tPROTO((tree, tree));\n+extern tree convert_arguments\t\t\tPROTO((tree, tree, tree, tree, int));\n+extern tree build_x_binary_op\t\t\tPROTO((enum tree_code, tree, tree));\n+extern tree build_binary_op\t\t\tPROTO((enum tree_code, tree, tree, int));\n+extern tree build_binary_op_nodefault\t\tPROTO((enum tree_code, tree, tree, enum tree_code));\n+extern tree build_component_addr\t\tPROTO((tree, tree, char *));\n+extern tree build_x_unary_op\t\t\tPROTO((enum tree_code, tree));\n+extern tree build_unary_op\t\t\tPROTO((enum tree_code, tree, int));\n+extern tree unary_complex_lvalue\t\tPROTO((enum tree_code, tree));\n+extern int mark_addressable\t\t\tPROTO((tree));\n+extern tree build_x_conditional_expr\t\tPROTO((tree, tree, tree));\n+extern tree build_conditional_expr\t\tPROTO((tree, tree, tree));\n+extern tree build_x_compound_expr\t\tPROTO((tree));\n+extern tree build_compound_expr\t\t\tPROTO((tree));\n+extern tree build_c_cast\t\t\tPROTO((tree, tree));\n+extern tree build_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n+extern int language_lvalue_valid\t\tPROTO((tree));\n+extern void warn_for_assignment\t\t\tPROTO((char *, char *, char *, tree, int, int));\n+extern tree convert_for_initialization\t\tPROTO((tree, tree, tree, int, char *, tree, int));\n+extern void c_expand_asm_operands\t\tPROTO((tree, tree, tree, tree, int, char *, int));\n+extern void c_expand_return\t\t\tPROTO((tree));\n+extern tree c_expand_start_case\t\t\tPROTO((tree));\n+extern tree build_component_ref\t\t\tPROTO((tree, tree, tree, int));\n+extern tree build_ptrmemfunc\t\t\tPROTO((tree, tree, int));\n+\n+/* in cp-type2.c */\n+extern tree error_not_base_type\t\t\tPROTO((tree, tree));\n+extern tree binfo_or_else\t\t\tPROTO((tree, tree));\n+extern void error_with_aggr_type\t\t(); /* PROTO((tree, char *, HOST_WIDE_INT)); */\n+extern void readonly_error\t\t\tPROTO((tree, char *, int));\n+extern void abstract_virtuals_error\t\tPROTO((tree, tree));\n+extern void incomplete_type_error\t\tPROTO((tree, tree));\n+extern void my_friendly_abort\t\t\tPROTO((int));\n+extern void my_friendly_assert\t\t\tPROTO((int, int));\n+extern tree store_init_value\t\t\tPROTO((tree, tree));\n+extern tree digest_init\t\t\t\tPROTO((tree, tree, tree *));\n+extern tree build_scoped_ref\t\t\tPROTO((tree, tree));\n+extern tree build_x_arrow\t\t\tPROTO((tree));\n+extern tree build_m_component_ref\t\tPROTO((tree, tree));\n+extern tree build_functional_cast\t\tPROTO((tree, tree));\n+extern char *enum_name_string\t\t\tPROTO((tree, tree));\n+extern void report_case_error\t\t\tPROTO((int, tree, tree, tree));\n+\n+/* in cp-xref.c */\n+extern void GNU_xref_begin\t\t\tPROTO((char *));\n+extern void GNU_xref_end\t\t\tPROTO((int));\n+extern void GNU_xref_file\t\t\tPROTO((char *));\n+extern void GNU_xref_start_scope\t\tPROTO((HOST_WIDE_INT));\n+extern void GNU_xref_end_scope\t\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT, int, int, int));\n+extern void GNU_xref_def\t\t\tPROTO((tree, char *));\n+extern void GNU_xref_decl\t\t\tPROTO((tree, tree));\n+extern void GNU_xref_call\t\t\tPROTO((tree, char *));\n+extern void GNU_xref_function\t\t\tPROTO((tree, tree));\n+extern void GNU_xref_assign\t\t\tPROTO((tree));\n+extern void GNU_xref_hier\t\t\tPROTO((char *, char *, int, int, int));\n+extern void GNU_xref_member\t\t\tPROTO((tree, tree));\n+\n+/* -- end of C++ */\n+\n+#endif /* not _CP_TREE_H */"}, {"sha": "347a901a821969d9f3fc8aa8b62ca5a8fcd06d03", "filename": "gcc/cp/cvt.c", "status": "added", "additions": 1997, "deletions": 0, "changes": 1997, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,1997 @@\n+/* Language-level data type conversion for GNU C++.\n+   Copyright (C) 1987, 1988, 1992, 1993 Free Software Foundation, Inc.\n+   Hacked by Michael Tiemann (tiemann@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This file contains the functions for converting C expressions\n+   to different data types.  The only entry point is `convert'.\n+   Every language front end must have a `convert' function\n+   but what kind of conversions it does will depend on the language.  */\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"cp-tree.h\"\n+#include \"class.h\"\n+#include \"convert.h\"\n+\n+#undef NULL\n+#define NULL (char *)0\n+\n+/* Change of width--truncation and extension of integers or reals--\n+   is represented with NOP_EXPR.  Proper functioning of many things\n+   assumes that no other conversions can be NOP_EXPRs.\n+\n+   Conversion between integer and pointer is represented with CONVERT_EXPR.\n+   Converting integer to real uses FLOAT_EXPR\n+   and real to integer uses FIX_TRUNC_EXPR.\n+\n+   Here is a list of all the functions that assume that widening and\n+   narrowing is always done with a NOP_EXPR:\n+     In convert.c, convert_to_integer.\n+     In c-typeck.c, build_binary_op_nodefault (boolean ops),\n+        and truthvalue_conversion.\n+     In expr.c: expand_expr, for operands of a MULT_EXPR.\n+     In fold-const.c: fold.\n+     In tree.c: get_narrower and get_unwidened.\n+\n+   C++: in multiple-inheritance, converting between pointers may involve\n+   adjusting them by a delta stored within the class definition.  */\n+\f\n+/* Subroutines of `convert'.  */\n+\n+/* Build a thunk.  What it is, is an entry point that when called will\n+   adjust the this pointer (the first argument) by offset, and then\n+   goto the real address of the function given by REAL_ADDR that we\n+   would like called.  What we return is the address of the thunk.  */\n+static tree\n+build_thunk (offset, real_addr)\n+     tree offset, real_addr;\n+{\n+  if (TREE_CODE (real_addr) != ADDR_EXPR\n+      || TREE_CODE (TREE_OPERAND (real_addr, 0)) != FUNCTION_DECL)\n+    {\n+      sorry (\"MI pointer to member conversion too complex\");\n+      return error_mark_node;\n+    }\n+  sorry (\"MI pointer to member conversion too complex\");\n+  return error_mark_node;\n+}\n+\n+/* Convert a `pointer to member' (POINTER_TYPE to METHOD_TYPE) into\n+   another `pointer to method'.  This may involved the creation of\n+   a thunk to handle the this offset calculation.  */\n+static tree\n+convert_fn_ptr (type, expr)\n+     tree type, expr;\n+{\n+  tree binfo = get_binfo (TYPE_METHOD_BASETYPE (TREE_TYPE (TREE_TYPE (expr))),\n+\t\t\t  TYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n+\t\t\t  1);\n+  if (binfo == error_mark_node)\n+    {\n+      error (\"  in pointer to member conversion\");\n+      return error_mark_node;\n+    }\n+  if (binfo == NULL_TREE)\n+    {\n+      /* ARM 4.8 restriction. */\n+      error (\"invalid pointer to member conversion\");\n+      return error_mark_node;\n+    }\n+  if (BINFO_OFFSET_ZEROP (binfo))\n+    return build1 (NOP_EXPR, type, expr);\n+  return build1 (NOP_EXPR, type, build_thunk (BINFO_OFFSET (binfo), expr));\n+}\n+\n+/* if converting pointer to pointer\n+     if dealing with classes, check for derived->base or vice versa\n+     else if dealing with method pointers, delegate\n+     else convert blindly\n+   else if converting class, pass off to build_type_conversion\n+   else try C-style pointer conversion  */\n+static tree\n+cp_convert_to_pointer (type, expr)\n+     tree type, expr;\n+{\n+  register tree intype = TREE_TYPE (expr);\n+  register enum tree_code form = TREE_CODE (intype);\n+  \n+  if (form == POINTER_TYPE)\n+    {\n+      intype = TYPE_MAIN_VARIANT (intype);\n+\n+      if (TYPE_MAIN_VARIANT (type) != intype\n+\t  && TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n+\t  && TREE_CODE (TREE_TYPE (intype)) == RECORD_TYPE)\n+\t{\n+\t  enum tree_code code = PLUS_EXPR;\n+\t  tree binfo = get_binfo (TREE_TYPE (type), TREE_TYPE (intype), 1);\n+\t  if (binfo == error_mark_node)\n+\t    return error_mark_node;\n+\t  if (binfo == NULL_TREE)\n+\t    {\n+\t      binfo = get_binfo (TREE_TYPE (intype), TREE_TYPE (type), 1);\n+\t      if (binfo == error_mark_node)\n+\t\treturn error_mark_node;\n+\t      code = MINUS_EXPR;\n+\t    }\n+\t  if (binfo)\n+\t    {\n+\t      if (TYPE_USES_VIRTUAL_BASECLASSES (TREE_TYPE (type))\n+\t\t  || TYPE_USES_VIRTUAL_BASECLASSES (TREE_TYPE (intype))\n+\t\t  || ! BINFO_OFFSET_ZEROP (binfo))\n+\t\t{\n+\t\t  /* Need to get the path we took.  */\n+\t\t  tree path;\n+\n+\t\t  if (code == PLUS_EXPR)\n+\t\t    get_base_distance (TREE_TYPE (type), TREE_TYPE (intype), 0, &path);\n+\t\t  else\n+\t\t    get_base_distance (TREE_TYPE (intype), TREE_TYPE (type), 0, &path);\n+\t\t  return build_vbase_path (code, type, expr, path, 0);\n+\t\t}\n+\t    }\n+\t}\n+      if (TYPE_MAIN_VARIANT (type) != intype\n+\t  && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE\n+\t  && TREE_CODE (type) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (intype)) == METHOD_TYPE)\n+\treturn convert_fn_ptr (type, expr);\n+\n+      return build1 (NOP_EXPR, type, expr);\n+    }\n+\n+  my_friendly_assert (form != OFFSET_TYPE, 186);\n+\n+  if (TYPE_LANG_SPECIFIC (intype)\n+      && (IS_SIGNATURE_POINTER (intype) || IS_SIGNATURE_REFERENCE (intype)))\n+    return convert_to_pointer (type, build_optr_ref (expr));\n+\n+  if (IS_AGGR_TYPE (intype))\n+    {\n+      tree rval;\n+      rval = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n+      if (rval)\n+\t{\n+\t  if (rval == error_mark_node)\n+\t    cp_error (\"conversion of `%E' from `%T' to `%T' is ambiguous\",\n+\t\t      expr, intype, type);\n+\t  return rval;\n+\t}\n+    }\n+\n+  if (integer_zerop (expr))\n+    {\n+      if (type == TREE_TYPE (null_pointer_node))\n+\treturn null_pointer_node;\n+      expr = build_int_2 (0, 0);\n+      TREE_TYPE (expr) = type;\n+      return expr;\n+    }\n+\n+  if (form == INTEGER_TYPE || form == ENUMERAL_TYPE)\n+    {\n+      if (type_precision (intype) == POINTER_SIZE)\n+\treturn build1 (CONVERT_EXPR, type, expr);\n+      expr = convert (type_for_size (POINTER_SIZE, 0), expr);\n+      /* Modes may be different but sizes should be the same.  */\n+      if (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr)))\n+\t  != GET_MODE_SIZE (TYPE_MODE (type)))\n+\t/* There is supposed to be some integral type\n+\t   that is the same width as a pointer.  */\n+\tabort ();\n+      return convert_to_pointer (type, expr);\n+    }\n+\n+  cp_error (\"cannot convert `%E' from type `%T' to type `%T'\",\n+\t    expr, intype, type);\n+  return error_mark_node;\n+}\n+\n+/* Like convert, except permit conversions to take place which\n+   are not normally allowed due to access restrictions\n+   (such as conversion from sub-type to private super-type).  */\n+static tree\n+convert_to_pointer_force (type, expr)\n+     tree type, expr;\n+{\n+  register tree intype = TREE_TYPE (expr);\n+  register enum tree_code form = TREE_CODE (intype);\n+  \n+  if (integer_zerop (expr))\n+    {\n+      if (type == TREE_TYPE (null_pointer_node))\n+\treturn null_pointer_node;\n+      expr = build_int_2 (0, 0);\n+      TREE_TYPE (expr) = type;\n+      return expr;\n+    }\n+\n+  /* Convert signature pointer/reference to `void *' first.  */\n+  if (form == RECORD_TYPE\n+      && (IS_SIGNATURE_POINTER (intype) || IS_SIGNATURE_REFERENCE (intype)))\n+    {\n+      expr = build_optr_ref (expr);\n+      intype = TREE_TYPE (expr);\n+      form = TREE_CODE (intype);\n+    }\n+\n+  if (form == POINTER_TYPE)\n+    {\n+      intype = TYPE_MAIN_VARIANT (intype);\n+\n+      if (TYPE_MAIN_VARIANT (type) != intype\n+\t  && TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n+\t  && TREE_CODE (TREE_TYPE (intype)) == RECORD_TYPE)\n+\t{\n+\t  enum tree_code code = PLUS_EXPR;\n+\t  tree path;\n+\t  int distance = get_base_distance (TREE_TYPE (type),\n+\t\t\t\t\t    TREE_TYPE (intype), 0, &path);\n+\t  if (distance == -2)\n+\t    {\n+\t    ambig:\n+\t      cp_error (\"type `%T' is ambiguous baseclass of `%s'\", TREE_TYPE (type),\n+\t\t\t\t    TYPE_NAME_STRING (TREE_TYPE (intype)));\n+\t      return error_mark_node;\n+\t    }\n+\t  if (distance == -1)\n+\t    {\n+\t      distance = get_base_distance (TREE_TYPE (intype),\n+\t\t\t\t\t    TREE_TYPE (type), 0, &path);\n+\t      if (distance == -2)\n+\t\tgoto ambig;\n+\t      if (distance < 0)\n+\t\t/* Doesn't need any special help from us.  */\n+\t\treturn build1 (NOP_EXPR, type, expr);\n+\n+\t      code = MINUS_EXPR;\n+\t    }\n+\t  return build_vbase_path (code, type, expr, path, 0);\n+\t}\n+      return build1 (NOP_EXPR, type, expr);\n+    }\n+\n+  return cp_convert_to_pointer (type, expr);\n+}\n+\n+/* We are passing something to a function which requires a reference.\n+   The type we are interested in is in TYPE. The initial\n+   value we have to begin with is in ARG.\n+\n+   FLAGS controls how we manage access checking.\n+   CHECKCONST controls if we report error messages on const subversion.  */\n+static tree\n+build_up_reference (type, arg, flags, checkconst)\n+     tree type, arg;\n+     int flags, checkconst;\n+{\n+  tree rval, targ;\n+  int literal_flag = 0;\n+  tree argtype = TREE_TYPE (arg), basetype = argtype;\n+  tree target_type = TREE_TYPE (type);\n+  tree binfo = NULL_TREE;\n+\n+  my_friendly_assert (TREE_CODE (type) == REFERENCE_TYPE, 187);\n+  if (flags != 0\n+      && TYPE_MAIN_VARIANT (argtype) != TYPE_MAIN_VARIANT (target_type)\n+      && IS_AGGR_TYPE (argtype)\n+      && IS_AGGR_TYPE (target_type))\n+    {\n+      binfo = get_binfo (target_type, argtype, 1);\n+      if ((flags & LOOKUP_PROTECT) && binfo == error_mark_node)\n+\treturn error_mark_node;\n+      if (binfo == NULL_TREE)\n+\treturn error_not_base_type (target_type, argtype);\n+      basetype = BINFO_TYPE (binfo);\n+    }\n+\n+  /* Pass along const and volatile down into the type. */\n+  if (TYPE_READONLY (type) || TYPE_VOLATILE (type))\n+    target_type = build_type_variant (target_type, TYPE_READONLY (type),\n+\t\t\t\t      TYPE_VOLATILE (type));\n+  targ = arg;\n+  if (TREE_CODE (targ) == SAVE_EXPR)\n+    targ = TREE_OPERAND (targ, 0);\n+\n+  switch (TREE_CODE (targ))\n+    {\n+    case INDIRECT_REF:\n+      /* This is a call to a constructor which did not know what it was\n+\t initializing until now: it needs to initialize a temporary.  */\n+      if (TREE_HAS_CONSTRUCTOR (targ))\n+\t{\n+\t  tree temp = build_cplus_new (argtype, TREE_OPERAND (targ, 0), 1);\n+\t  TREE_HAS_CONSTRUCTOR (targ) = 0;\n+\t  return build_up_reference (type, temp, flags, 1);\n+\t}\n+      /* Let &* cancel out to simplify resulting code.\n+         Also, throw away intervening NOP_EXPRs.  */\n+      arg = TREE_OPERAND (targ, 0);\n+      if (TREE_CODE (arg) == NOP_EXPR || TREE_CODE (arg) == NON_LVALUE_EXPR\n+\t  || (TREE_CODE (arg) == CONVERT_EXPR && TREE_REFERENCE_EXPR (arg)))\n+\targ = TREE_OPERAND (arg, 0);\n+\n+      /* in doing a &*, we have to get rid of the const'ness on the pointer\n+\t value.  Haven't thought about volatile here.  Pointers come to mind\n+\t here.  */\n+      if (TREE_READONLY (arg))\n+\t{\n+\t  arg = copy_node (arg);\n+\t  TREE_READONLY (arg) = 0;\n+\t}\n+\n+      rval = build1 (CONVERT_EXPR, type, arg);\n+      TREE_REFERENCE_EXPR (rval) = 1;\n+\n+      /* propagate the const flag on something like:\n+\n+\t class Base {\n+\t public:\n+\t   int foo;\n+\t };\n+\n+      class Derived : public Base {\n+      public:\n+\tint bar;\n+      };\n+\n+      void func(Base&);\n+\n+      void func2(const Derived& d) {\n+\tfunc(d);\n+      }\n+\n+        on the d parameter.  The below could have been avoided, if the flags\n+        were down in the tree, not sure why they are not.  (mrs) */\n+      /* The below code may have to be propagated to other parts of this\n+\t switch.  */\n+      if (TREE_READONLY (targ) && !TREE_READONLY (arg)\n+\t  && (TREE_CODE (arg) == PARM_DECL || TREE_CODE (arg) == VAR_DECL)\n+\t  && TREE_CODE (TREE_TYPE (arg)) == REFERENCE_TYPE\n+\t  && (TYPE_READONLY (target_type) && checkconst))\n+\t{\n+\t  arg = copy_node (arg);\n+\t  TREE_READONLY (arg) = TREE_READONLY (targ);\n+\t}\n+      literal_flag = TREE_CONSTANT (arg);\n+\n+      goto done_but_maybe_warn;\n+\n+      /* Get this out of a register if we happened to be in one by accident.\n+\t Also, build up references to non-lvalues it we must.  */\n+      /* For &x[y], return (&) x+y */\n+    case ARRAY_REF:\n+      if (mark_addressable (TREE_OPERAND (targ, 0)) == 0)\n+\treturn error_mark_node;\n+      rval = build_binary_op (PLUS_EXPR, TREE_OPERAND (targ, 0),\n+\t\t\t      TREE_OPERAND (targ, 1), 1);\n+      TREE_TYPE (rval) = type;\n+      if (TREE_CONSTANT (TREE_OPERAND (targ, 1))\n+\t  && staticp (TREE_OPERAND (targ, 0)))\n+\tTREE_CONSTANT (rval) = 1;\n+      goto done;\n+\n+    case SCOPE_REF:\n+      /* Could be a reference to a static member.  */\n+      {\n+\ttree field = TREE_OPERAND (targ, 1);\n+\tif (TREE_STATIC (field))\n+\t  {\n+\t    rval = build1 (ADDR_EXPR, type, field);\n+\t    literal_flag = 1;\n+\t    goto done;\n+\t  }\n+      }\n+\n+      /* We should have farmed out member pointers above.  */\n+      my_friendly_abort (188);\n+\n+    case COMPONENT_REF:\n+      rval = build_component_addr (targ, build_pointer_type (argtype),\n+\t\t\t\t   \"attempt to make a reference to bit-field structure member `%s'\");\n+      TREE_TYPE (rval) = type;\n+      literal_flag = staticp (TREE_OPERAND (targ, 0));\n+\n+      goto done_but_maybe_warn;\n+\n+      /* Anything not already handled and not a true memory reference\n+\t needs to have a reference built up.  Do so silently for\n+\t things like integers and return values from function,\n+\t but complain if we need a reference to something declared\n+\t as `register'.  */\n+\n+    case RESULT_DECL:\n+      if (staticp (targ))\n+\tliteral_flag = 1;\n+      TREE_ADDRESSABLE (targ) = 1;\n+      put_var_into_stack (targ);\n+      break;\n+\n+    case PARM_DECL:\n+      if (targ == current_class_decl)\n+\t{\n+\t  error (\"address of `this' not available\");\n+#if 0\n+\t  /* This code makes the following core dump the compiler on a sun4,\n+\t     if the code below is used.\n+\n+\t     class e_decl;\n+\t     class a_decl;\n+\t     typedef a_decl* a_ref;\n+\n+\t     class a_s {\n+\t     public:\n+\t       a_s();\n+\t       void* append(a_ref& item);\n+\t     };\n+\t     class a_decl {\n+\t     public:\n+\t       a_decl (e_decl *parent);\n+\t       a_s  generic_s;\n+\t       a_s  decls;\n+\t       e_decl* parent;\n+\t     };\n+\n+\t     class e_decl {\n+\t     public:\n+\t       e_decl();\n+\t       a_s implementations;\n+\t     };\n+\n+\t     void foobar(void *);\n+\n+\t     a_decl::a_decl(e_decl *parent) {\n+\t       parent->implementations.append(this);\n+\t     }\n+\t   */\n+\n+\t  TREE_ADDRESSABLE (targ) = 1; /* so compiler doesn't die later */\n+\t  put_var_into_stack (targ);\n+\t  break;\n+#else\n+\t  return error_mark_node;\n+#endif\n+\t}\n+      /* Fall through.  */\n+    case VAR_DECL:\n+    case CONST_DECL:\n+      if (DECL_REGISTER (targ) && !TREE_ADDRESSABLE (targ))\n+\twarning (\"address needed to build reference for `%s', which is declared `register'\",\n+\t\t IDENTIFIER_POINTER (DECL_NAME (targ)));\n+      else if (staticp (targ))\n+\tliteral_flag = 1;\n+\n+      TREE_ADDRESSABLE (targ) = 1;\n+      put_var_into_stack (targ);\n+      break;\n+\n+    case COMPOUND_EXPR:\n+      {\n+\ttree real_reference = build_up_reference (type, TREE_OPERAND (targ, 1),\n+\t\t\t\t\t\t  LOOKUP_PROTECT, checkconst);\n+\trval = build (COMPOUND_EXPR, type, TREE_OPERAND (targ, 0), real_reference);\n+\tTREE_CONSTANT (rval) = staticp (TREE_OPERAND (targ, 1));\n+\treturn rval;\n+      }\n+\n+    case MODIFY_EXPR:\n+    case INIT_EXPR:\n+      {\n+\ttree real_reference = build_up_reference (type, TREE_OPERAND (targ, 0),\n+\t\t\t\t\t\t  LOOKUP_PROTECT, checkconst);\n+\trval = build (COMPOUND_EXPR, type, arg, real_reference);\n+\tTREE_CONSTANT (rval) = staticp (TREE_OPERAND (targ, 0));\n+\treturn rval;\n+      }\n+\n+    case COND_EXPR:\n+      return build (COND_EXPR, type,\n+\t\t    TREE_OPERAND (targ, 0),\n+\t\t    build_up_reference (type, TREE_OPERAND (targ, 1),\n+\t\t\t\t\tLOOKUP_PROTECT, checkconst),\n+\t\t    build_up_reference (type, TREE_OPERAND (targ, 2),\n+\t\t\t\t\tLOOKUP_PROTECT, checkconst));\n+\n+    case WITH_CLEANUP_EXPR:\n+      return build (WITH_CLEANUP_EXPR, type,\n+\t\t    build_up_reference (type, TREE_OPERAND (targ, 0),\n+\t\t\t\t\tLOOKUP_PROTECT, checkconst),\n+\t\t    0, TREE_OPERAND (targ, 2));\n+\n+    case BIND_EXPR:\n+      arg = TREE_OPERAND (targ, 1);\n+      if (arg == NULL_TREE)\n+\t{\n+\t  compiler_error (\"({ ... }) expression not expanded when needed for reference\");\n+\t  return error_mark_node;\n+\t}\n+      rval = build1 (ADDR_EXPR, type, arg);\n+      TREE_REFERENCE_EXPR (rval) = 1;\n+      return rval;\n+\n+    default:\n+      break;\n+    }\n+\n+  if (TREE_ADDRESSABLE (targ) == 0)\n+    {\n+      tree temp;\n+\n+      if (TREE_CODE (targ) == CALL_EXPR && IS_AGGR_TYPE (argtype))\n+\t{\n+\t  temp = build_cplus_new (argtype, targ, 1);\n+\t  rval = build1 (ADDR_EXPR, type, temp);\n+\t  goto done;\n+\t}\n+      else\n+\t{\n+\t  temp = get_temp_name (argtype, 0);\n+\t  if (global_bindings_p ())\n+\t    {\n+\t      /* Give this new temp some rtl and initialize it.  */\n+\t      DECL_INITIAL (temp) = targ;\n+\t      TREE_STATIC (temp) = 1;\n+\t      finish_decl (temp, targ, NULL_TREE, 0);\n+\t      /* Do this after declaring it static.  */\n+\t      rval = build_unary_op (ADDR_EXPR, temp, 0);\n+\t      TREE_TYPE (rval) = type;\n+\t      literal_flag = TREE_CONSTANT (rval);\n+\t      goto done;\n+\t    }\n+\t  else\n+\t    {\n+\t      rval = build_unary_op (ADDR_EXPR, temp, 0);\n+\t      if (binfo && !BINFO_OFFSET_ZEROP (binfo))\n+\t\trval = convert_pointer_to (target_type, rval);\n+\t      else\n+\t\tTREE_TYPE (rval) = type;\n+\n+\t      temp = build (MODIFY_EXPR, argtype, temp, arg);\n+\t      TREE_SIDE_EFFECTS (temp) = 1;\n+\t      return build (COMPOUND_EXPR, type, temp, rval);\n+\t    }\n+\t}\n+    }\n+  else\n+    rval = build1 (ADDR_EXPR, type, arg);\n+\n+ done_but_maybe_warn:\n+  if (checkconst && TREE_READONLY (arg) && ! TYPE_READONLY (target_type))\n+    readonly_error (arg, \"conversion to reference\", 1);\n+\n+ done:\n+  if (TYPE_USES_COMPLEX_INHERITANCE (argtype))\n+    {\n+      TREE_TYPE (rval) = TYPE_POINTER_TO (argtype);\n+      rval = convert_pointer_to (target_type, rval);\n+      TREE_TYPE (rval) = type;\n+    }\n+  TREE_CONSTANT (rval) = literal_flag;\n+  return rval;\n+}\n+\n+/* For C++: Only need to do one-level references, but cannot\n+   get tripped up on signed/unsigned differences.\n+\n+   If DECL is NULL_TREE it means convert as though casting (by force).\n+   If it is ERROR_MARK_NODE, it means the conversion is implicit,\n+   and that temporaries may be created.\n+   Make sure the use of user-defined conversion operators is un-ambiguous.\n+   Otherwise, DECL is a _DECL node which can be used in error reporting.\n+\n+   FNDECL, PARMNUM, and ERRTYPE are only used when checking for use of\n+   volatile or const references where they aren't desired.  */\n+\n+tree\n+convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n+\t\t      errtype, strict, flags)\n+     tree decl;\n+     tree reftype, expr;\n+     tree fndecl;\n+     int parmnum;\n+     char *errtype;\n+     int strict, flags;\n+{\n+  register tree type = TYPE_MAIN_VARIANT (TREE_TYPE (reftype));\n+  register tree intype = TREE_TYPE (expr);\n+  register enum tree_code form = TREE_CODE (intype);\n+  tree rval = NULL_TREE;\n+\n+  if (TREE_CODE(type) == ARRAY_TYPE)\n+    type = build_pointer_type (TREE_TYPE(type));\n+  if (form == REFERENCE_TYPE)\n+    intype = TREE_TYPE (intype);\n+  intype = TYPE_MAIN_VARIANT (intype);\n+\n+  if (IS_AGGR_TYPE (intype)\n+      && (rval = build_type_conversion (CONVERT_EXPR, reftype, expr, 1)))\n+    {\n+      if (rval == error_mark_node)\n+\tcp_error (\"conversion from `%T' to `%T' is ambiguous\",\n+\t\t  intype, reftype);\n+      return rval;\n+    }\n+\n+  if (comptypes (type, intype, strict))\n+    {\n+      /* Section 13.  */\n+      if (flags & LOOKUP_COMPLAIN)\n+\t{\n+\t  /* Since convert_for_initialization didn't call convert_for_assignment,\n+\t     we have to do this checking here.  FIXME: We should have a common\n+\t     routine between here and convert_for_assignment.  */\n+\t  if (TREE_CODE (TREE_TYPE (expr)) == REFERENCE_TYPE)\n+\t    {\n+\t      register tree ttl = TREE_TYPE (reftype);\n+\t      register tree ttr = TREE_TYPE (TREE_TYPE (expr));\n+\n+\t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n+\t\t{\n+\t\t  if (fndecl)\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards const\",\n+\t\t\t\tTREE_TYPE (expr), parmnum, fndecl);\n+\t\t  else\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards const\",\n+\t\t\t\terrtype, reftype, TREE_TYPE (expr));\n+\t\t}\n+\t      if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n+\t\t{\n+\t\t  if (fndecl)\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards volatile\",\n+\t\t\t\tTREE_TYPE (expr), parmnum, fndecl);\n+\t\t  else\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards volatile\",\n+\t\t\t\terrtype, reftype, TREE_TYPE (expr));\n+\t\t}\n+\t  } else if (TREE_CODE (reftype) == REFERENCE_TYPE\n+\t\t     && ! TREE_READONLY (TREE_TYPE (reftype))\n+\t\t     && ! lvalue_p (expr))\n+\t    {\n+\t      /* Ensure semantics of 8.4.3 */\n+\t      if (fndecl)\n+\t\tcp_pedwarn (\"ANSI C++ forbids passing non-lvalue `%T' as argument %P of `%D' into non-const &\",\n+\t\t\t    TREE_TYPE (expr), parmnum, fndecl);\n+\t      else\n+\t\tcp_pedwarn (\"ANSI C++ forbids %s to `%T' from non-lvalue `%T'\",\n+\t\t\t    errtype, reftype, TREE_TYPE (expr));\n+\t    }\n+\t}\n+\n+      /* If EXPR is of aggregate type, and is really a CALL_EXPR,\n+\t then we don't need to convert it to reference type if\n+\t it is only being used to initialize DECL which is also\n+\t of the same aggregate type.  */\n+      if (form == REFERENCE_TYPE\n+\t  || (decl != NULL_TREE && decl != error_mark_node\n+\t      && IS_AGGR_TYPE (type)\n+\t      && TREE_CODE (expr) == CALL_EXPR\n+\t      && TYPE_MAIN_VARIANT (type) == intype))\n+\t{\n+\t  if (decl && decl != error_mark_node)\n+\t    {\n+\t      tree e1 = build (INIT_EXPR, void_type_node, decl, expr);\n+\t      tree e2;\n+\n+\t      TREE_SIDE_EFFECTS (e1) = 1;\n+\t      if (form == REFERENCE_TYPE)\n+\t\te2 = build1 (NOP_EXPR, reftype, decl);\n+\t      else\n+\t\t{\n+\t\t  e2 = build_unary_op (ADDR_EXPR, decl, 0);\n+\t\t  TREE_TYPE (e2) = reftype;\n+\t\t  TREE_REFERENCE_EXPR (e2) = 1;\n+\t\t}\n+\t      return build_compound_expr (tree_cons (NULL_TREE, e1,\n+\t\t\t\t\t\t     build_tree_list (NULL_TREE, e2)));\n+\t    }\n+\t  expr = copy_node (expr);\n+\t  TREE_TYPE (expr) = reftype;\n+\t  return expr;\n+\t}\n+      return build_up_reference (reftype, expr, flags, decl!=NULL_TREE);\n+    }\n+\n+  if (decl == error_mark_node)\n+    {\n+      tree rval_as_conversion = NULL_TREE;\n+      tree rval_as_ctor = NULL_TREE;\n+      \n+      if (IS_AGGR_TYPE (intype)\n+\t  && (rval = build_type_conversion (CONVERT_EXPR, type, expr, 1)))\n+\t{\n+\t  if (rval == error_mark_node)\n+\t    return rval;\n+\n+\t  rval_as_conversion = build_up_reference (reftype, rval, flags, 1);\n+\t}\n+      \n+      /* Definitely need to go through a constructor here.  */\n+      if (TYPE_HAS_CONSTRUCTOR (type)\n+\t  && (rval = build_method_call\n+\t      (NULL_TREE, constructor_name_full (type),\n+\t       build_tree_list (NULL_TREE, expr), TYPE_BINFO (type),\n+\t       LOOKUP_NO_CONVERSION|LOOKUP_SPECULATIVELY)))\n+\t{\n+\t  tree init;\n+\n+\t  if (global_bindings_p ())\n+\t    {\n+\t      extern tree static_aggregates;\n+\t      decl = get_temp_name (type, global_bindings_p ());\n+\t      init = build_method_call (decl, constructor_name_full (type),\n+\t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n+\t\t\t\t\tTYPE_BINFO (type), LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n+\n+\t      if (init == error_mark_node)\n+\t\treturn error_mark_node;\n+\n+\t      make_decl_rtl (decl, NULL_PTR, 1);\n+\t      static_aggregates = perm_tree_cons (expr, decl, static_aggregates);\n+\t      rval = build_unary_op (ADDR_EXPR, decl, 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      init = build_method_call (NULL_TREE, constructor_name_full (type),\n+\t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n+\t\t\t\t\tTYPE_BINFO (type), LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n+\n+\t      if (init == error_mark_node)\n+\t\treturn error_mark_node;\n+\n+\t      rval = build_cplus_new (type, init, 1);\n+\t      rval = build_up_reference (reftype, rval, flags, 1);\n+\t    }\n+\t  rval_as_ctor = rval;\n+\t}\n+\n+      if (rval_as_ctor && rval_as_conversion)\n+\t{\n+\t  cp_error (\"ambiguous conversion from `%T' to `%T'; both user-defined conversion and constructor apply\",\n+\t\t    intype, reftype);\n+\t  return error_mark_node;\n+\t}\n+      else if (rval_as_ctor)\n+\trval = rval_as_ctor;\n+      else if (rval_as_conversion)\n+\trval = rval_as_conversion;\n+      else if (! IS_AGGR_TYPE (type) && ! IS_AGGR_TYPE (intype))\n+\t{\n+\t  rval = convert (type, expr);\n+\t  if (rval == error_mark_node)\n+\t    return error_mark_node;\n+\t  \n+\t  rval = build_up_reference (reftype, rval, flags, 1);\n+\t}\n+\n+      if (rval && ! TYPE_READONLY (TREE_TYPE (reftype)))\n+\tcp_pedwarn (\"converting `%T' to non-const `%T' will use a temporary\",\n+\t\t    intype, reftype);\n+    }\n+\n+  if (rval)\n+    {\n+      /* If we found a way to convert earlier, then use it. */\n+      return rval;\n+    }\n+\n+  my_friendly_assert (form != OFFSET_TYPE, 189);\n+\n+  if ((flags & (LOOKUP_COMPLAIN|LOOKUP_SPECULATIVELY)) == LOOKUP_COMPLAIN)\n+    cp_error (\"cannot convert type `%T' to type `%T'\", intype, reftype);\n+\n+  if (flags & LOOKUP_SPECULATIVELY)\n+    return NULL_TREE;\n+\n+  return error_mark_node;\n+}\n+\n+/* We are using a reference VAL for its value. Bash that reference all the\n+   way down to its lowest form. */\n+tree\n+convert_from_reference (val)\n+     tree val;\n+{\n+  tree type = TREE_TYPE (val);\n+\n+  if (TREE_CODE (type) == OFFSET_TYPE)\n+    type = TREE_TYPE (type);\n+ if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      tree target_type = TREE_TYPE (type);\n+      tree nval;\n+\n+      /* This can happen if we cast to a reference type.  */\n+      if (TREE_CODE (val) == ADDR_EXPR)\n+\t{\n+\t  nval = build1 (NOP_EXPR, build_pointer_type (target_type), val);\n+\t  nval = build_indirect_ref (nval, NULL_PTR);\n+\t  /* The below was missing, are other important flags missing too? */\n+\t  TREE_SIDE_EFFECTS (nval) = TREE_SIDE_EFFECTS (val);\n+\t  return nval;\n+\t}\n+\n+      nval = build1 (INDIRECT_REF, TYPE_MAIN_VARIANT (target_type), val);\n+\n+      TREE_THIS_VOLATILE (nval) = TYPE_VOLATILE (target_type);\n+      TREE_SIDE_EFFECTS (nval) = TYPE_VOLATILE (target_type);\n+      TREE_READONLY (nval) = TYPE_READONLY (target_type);\n+      /* The below was missing, are other important flags missing too? */\n+      TREE_SIDE_EFFECTS (nval) |= TREE_SIDE_EFFECTS (val);\n+      return nval;\n+    }\n+  return val;\n+}\n+\f\n+/* See if there is a constructor of type TYPE which will convert\n+   EXPR.  The reference manual seems to suggest (8.5.6) that we need\n+   not worry about finding constructors for base classes, then converting\n+   to the derived class.\n+\n+   MSGP is a pointer to a message that would be an appropriate error\n+   string.  If MSGP is NULL, then we are not interested in reporting\n+   errors.  */\n+tree\n+convert_to_aggr (type, expr, msgp, protect)\n+     tree type, expr;\n+     char **msgp;\n+     int protect;\n+{\n+  tree basetype = type;\n+  tree name = TYPE_IDENTIFIER (basetype);\n+  tree function, fndecl, fntype, parmtypes, parmlist, result;\n+  tree method_name;\n+  enum access_type access;\n+  int can_be_private, can_be_protected;\n+\n+  if (! TYPE_HAS_CONSTRUCTOR (basetype))\n+    {\n+      if (msgp)\n+\t*msgp = \"type `%s' does not have a constructor\";\n+      return error_mark_node;\n+    }\n+\n+  access = access_public;\n+  can_be_private = 0;\n+  can_be_protected = IDENTIFIER_CLASS_VALUE (name) || name == current_class_name;\n+\n+  parmlist = build_tree_list (NULL_TREE, expr);\n+  parmtypes = tree_cons (NULL_TREE, TREE_TYPE (expr), void_list_node);\n+\n+  if (TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n+    {\n+      parmtypes = tree_cons (NULL_TREE, integer_type_node, parmtypes);\n+      parmlist = tree_cons (NULL_TREE, integer_one_node, parmlist);\n+    }\n+\n+  /* The type of the first argument will be filled in inside the loop.  */\n+  parmlist = tree_cons (NULL_TREE, integer_zero_node, parmlist);\n+  parmtypes = tree_cons (NULL_TREE, TYPE_POINTER_TO (basetype), parmtypes);\n+\n+  method_name = build_decl_overload (name, parmtypes, 1);\n+\n+  /* constructors are up front.  */\n+  fndecl = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 0);\n+  if (TYPE_HAS_DESTRUCTOR (basetype))\n+    fndecl = DECL_CHAIN (fndecl);\n+\n+  while (fndecl)\n+    {\n+      if (DECL_ASSEMBLER_NAME (fndecl) == method_name)\n+\t{\n+\t  function = fndecl;\n+\t  if (protect)\n+\t    {\n+\t      if (TREE_PRIVATE (fndecl))\n+\t\t{\n+\t\t  can_be_private =\n+\t\t    (basetype == current_class_type\n+\t\t     || is_friend (basetype, current_function_decl)\n+\t\t     || purpose_member (basetype, DECL_ACCESS (fndecl)));\n+\t\t  if (! can_be_private)\n+\t\t    goto found;\n+\t\t}\n+\t      else if (TREE_PROTECTED (fndecl))\n+\t\t{\n+\t\t  if (! can_be_protected)\n+\t\t    goto found;\n+\t\t}\n+\t    }\n+\t  goto found_and_ok;\n+\t}\n+      fndecl = DECL_CHAIN (fndecl);\n+    }\n+\n+  /* No exact conversion was found.  See if an approximate\n+     one will do.  */\n+  fndecl = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 0);\n+  if (TYPE_HAS_DESTRUCTOR (basetype))\n+    fndecl = DECL_CHAIN (fndecl);\n+\n+  {\n+    int saw_private = 0;\n+    int saw_protected = 0;\n+    struct candidate *candidates =\n+      (struct candidate *) alloca ((decl_list_length (fndecl)+1) * sizeof (struct candidate));\n+    struct candidate *cp = candidates;\n+\n+    while (fndecl)\n+      {\n+\tfunction = fndecl;\n+\tcp->h_len = 2;\n+\tif (flag_ansi_overloading)\n+\t  cp->v.ansi_harshness = (struct harshness_code *)\n+\t    alloca (3 * sizeof (struct harshness_code));\n+\telse\n+\t  cp->v.old_harshness = (unsigned short *)\n+\t    alloca (3 * sizeof (short));\n+\n+\tcompute_conversion_costs (fndecl, parmlist, cp, 2);\n+\tif ((flag_ansi_overloading && (cp->h.code & EVIL_CODE) == 0)\n+\t    || (!flag_ansi_overloading && cp->evil == 0))\n+\t  {\n+\t    cp->u.field = fndecl;\n+\t    if (protect)\n+\t      {\n+\t\tif (TREE_PRIVATE (fndecl))\n+\t\t  access = access_private;\n+\t\telse if (TREE_PROTECTED (fndecl))\n+\t\t  access = access_protected;\n+\t\telse\n+\t\t  access = access_public;\n+\t      }\n+\t    else\n+\t      access = access_public;\n+\n+\t    if (access == access_private\n+\t\t? (basetype == current_class_type\n+\t\t   || is_friend (basetype, cp->function)\n+\t\t   || purpose_member (basetype, DECL_ACCESS (fndecl)))\n+\t\t: access == access_protected\n+\t\t? (can_be_protected\n+\t\t   || purpose_member (basetype, DECL_ACCESS (fndecl)))\n+\t\t: 1)\n+\t      {\n+\t\tif ((flag_ansi_overloading && cp->h.code <= TRIVIAL_CODE)\n+\t\t    || (!flag_ansi_overloading\n+\t\t\t&& cp->user == 0 && cp->b_or_d == 0\n+\t\t\t&& cp->easy <= 1))\n+\t\t  goto found_and_ok;\n+\t\tcp++;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (access == access_private)\n+\t\t  saw_private = 1;\n+\t\telse\n+\t\t  saw_protected = 1;\n+\t      }\n+\t  }\n+\tfndecl = DECL_CHAIN (fndecl);\n+      }\n+    if (cp - candidates)\n+      {\n+\t/* Rank from worst to best.  Then cp will point to best one.\n+\t   Private fields have their bits flipped.  For unsigned\n+\t   numbers, this should make them look very large.\n+\t   If the best alternate has a (signed) negative value,\n+\t   then all we ever saw were private members.  */\n+\tif (cp - candidates > 1)\n+\t  qsort (candidates,\t/* char *base */\n+\t\t cp - candidates, /* int nel */\n+\t\t sizeof (struct candidate), /* int width */\n+\t\t rank_for_overload); /* int (*compar)() */\n+\n+\t--cp;\n+\tif ((flag_ansi_overloading && (cp->h.code & EVIL_CODE))\n+\t    || (!flag_ansi_overloading && cp->evil > 1))\n+\t  {\n+\t    if (msgp)\n+\t      *msgp = \"ambiguous type conversion possible for `%s'\";\n+\t    return error_mark_node;\n+\t  }\n+\n+\tfunction = cp->function;\n+\tfndecl = cp->u.field;\n+\tgoto found_and_ok;\n+      }\n+    else if (msgp)\n+      {\n+\tif (saw_private)\n+\t  if (saw_protected)\n+\t    *msgp = \"only private and protected conversions apply\";\n+\t  else\n+\t    *msgp = \"only private conversions apply\";\n+\telse if (saw_protected)\n+\t  *msgp = \"only protected conversions apply\";\n+      }\n+    return error_mark_node;\n+  }\n+  /* NOTREACHED */\n+\n+ not_found:\n+  if (msgp) *msgp = \"no appropriate conversion to type `%s'\";\n+  return error_mark_node;\n+ found:\n+  if (access == access_private)\n+    if (! can_be_private)\n+      {\n+\tif (msgp)\n+\t  *msgp = TREE_PRIVATE (fndecl)\n+\t    ? \"conversion to type `%s' is private\"\n+\t    : \"conversion to type `%s' is from private base class\";\n+\treturn error_mark_node;\n+      }\n+  if (access == access_protected)\n+    if (! can_be_protected)\n+      {\n+\tif (msgp)\n+\t  *msgp = TREE_PRIVATE (fndecl)\n+\t    ? \"conversion to type `%s' is protected\"\n+\t    : \"conversion to type `%s' is from protected base class\";\n+\treturn error_mark_node;\n+      }\n+  function = fndecl;\n+ found_and_ok:\n+\n+  /* It will convert, but we don't do anything about it yet.  */\n+  if (msgp == 0)\n+    return NULL_TREE;\n+\n+  fntype = TREE_TYPE (function);\n+  if (DECL_INLINE (function) && TREE_CODE (function) == FUNCTION_DECL)\n+    function = build1 (ADDR_EXPR, build_pointer_type (fntype), function);\n+  else\n+    function = default_conversion (function);\n+\n+  result = build_nt (CALL_EXPR, function,\n+\t\t     convert_arguments (NULL_TREE, TYPE_ARG_TYPES (fntype),\n+\t\t\t\t\tparmlist, NULL_TREE, LOOKUP_NORMAL),\n+\t\t     NULL_TREE);\n+  TREE_TYPE (result) = TREE_TYPE (fntype);\n+  TREE_SIDE_EFFECTS (result) = 1;\n+  TREE_RAISES (result) = !! TYPE_RAISES_EXCEPTIONS (fntype);\n+  return result;\n+}\n+\n+/* Call this when we know (for any reason) that expr is not, in fact,\n+   zero.  This routine is like convert_pointer_to, but it pays\n+   attention to which specific instance of what type we want to\n+   convert to.  This routine should eventually become\n+   convert_to_pointer after all references to convert_to_pointer\n+   are removed.  */\n+tree\n+convert_pointer_to_real (binfo, expr)\n+     tree binfo, expr;\n+{\n+  register tree intype = TREE_TYPE (expr);\n+  tree ptr_type;\n+  tree type, rval;\n+\n+  if (TREE_CODE (binfo) == TREE_VEC)\n+    type = BINFO_TYPE (binfo);\n+  else if (IS_AGGR_TYPE (binfo))\n+    {\n+      type = binfo;\n+    }\n+  else\n+    {\n+      type = binfo;\n+      binfo = NULL_TREE;\n+    }\n+\n+  ptr_type = build_pointer_type (type);\n+  if (ptr_type == TYPE_MAIN_VARIANT (intype))\n+    return expr;\n+\n+  if (intype == error_mark_node)\n+    return error_mark_node;\n+\n+  my_friendly_assert (!integer_zerop (expr), 191);\n+\n+  if (TREE_CODE (type) == RECORD_TYPE\n+      && TREE_CODE (TREE_TYPE (intype)) == RECORD_TYPE\n+      && type != TYPE_MAIN_VARIANT (TREE_TYPE (intype)))\n+    {\n+      tree path;\n+      int distance\n+\t= get_base_distance (binfo, TYPE_MAIN_VARIANT (TREE_TYPE (intype)),\n+\t\t\t     0, &path);\n+\n+      /* This function shouldn't be called with unqualified arguments\n+\t but if it is, give them an error message that they can read.  */\n+      if (distance < 0)\n+\t{\n+\t  cp_error (\"cannot convert a pointer of type `%T'\",\n+\t\t    TREE_TYPE (intype));\n+\t  cp_error (\"to a pointer of type `%T'\", type);\n+\n+\t  if (distance == -2)\n+\t    cp_error (\"because `%T' is an ambiguous base class\", type);\n+\t  return error_mark_node;\n+\t}\n+\n+      return build_vbase_path (PLUS_EXPR, ptr_type, expr, path, 1);\n+    }\n+  rval = build1 (NOP_EXPR, ptr_type,\n+\t\t TREE_CODE (expr) == NOP_EXPR ? TREE_OPERAND (expr, 0) : expr);\n+  TREE_CONSTANT (rval) = TREE_CONSTANT (expr);\n+  return rval;\n+}\n+\n+/* Call this when we know (for any reason) that expr is\n+   not, in fact, zero.  This routine gets a type out of the first\n+   argument and uses it to search for the type to convert to.  If there\n+   is more than one instance of that type in the expr, the conversion is\n+   ambiguous.  This routine should eventually go away, and all\n+   callers should use convert_to_pointer_real.  */\n+tree\n+convert_pointer_to (binfo, expr)\n+     tree binfo, expr;\n+{\n+  tree type;\n+\n+  if (TREE_CODE (binfo) == TREE_VEC)\n+    type = BINFO_TYPE (binfo);\n+  else if (IS_AGGR_TYPE (binfo))\n+      type = binfo;\n+  else\n+      type = binfo;\n+  return convert_pointer_to_real (type, expr);\n+}\n+\n+/* Same as above, but don't abort if we get an \"ambiguous\" baseclass.\n+   There's only one virtual baseclass we are looking for, and once\n+   we find one such virtual baseclass, we have found them all.  */\n+\n+tree\n+convert_pointer_to_vbase (binfo, expr)\n+     tree binfo;\n+     tree expr;\n+{\n+  tree intype = TREE_TYPE (TREE_TYPE (expr));\n+  tree binfos = TYPE_BINFO_BASETYPES (intype);\n+  int i;\n+\n+  for (i = TREE_VEC_LENGTH (binfos)-1; i >= 0; i--)\n+    {\n+      tree basetype = BINFO_TYPE (TREE_VEC_ELT (binfos, i));\n+      if (BINFO_TYPE (binfo) == basetype)\n+\treturn convert_pointer_to (binfo, expr);\n+      if (binfo_member (BINFO_TYPE (binfo), CLASSTYPE_VBASECLASSES (basetype)))\n+\treturn convert_pointer_to_vbase (binfo, convert_pointer_to (basetype, expr));\n+    }\n+  my_friendly_abort (6);\n+  /* NOTREACHED */\n+  return NULL_TREE;\n+}\n+\f\n+/* Create an expression whose value is that of EXPR,\n+   converted to type TYPE.  The TREE_TYPE of the value\n+   is always TYPE.  This function implements all reasonable\n+   conversions; callers should filter out those that are\n+   not permitted by the language being compiled.  */\n+\n+tree\n+convert (type, expr)\n+     tree type, expr;\n+{\n+  register tree e = expr;\n+  register enum tree_code code = TREE_CODE (type);\n+\n+  if (type == TREE_TYPE (expr)\n+      || TREE_CODE (expr) == ERROR_MARK)\n+    return expr;\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n+    return fold (build1 (NOP_EXPR, type, expr));\n+  if (TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n+    return error_mark_node;\n+  if (TREE_CODE (TREE_TYPE (expr)) == VOID_TYPE)\n+    {\n+      error (\"void value not ignored as it ought to be\");\n+      return error_mark_node;\n+    }\n+  if (code == VOID_TYPE)\n+    {\n+      /* We're converting to a void type; see if they have an\n+\t `operator void'.  */\n+      tree rval = build_type_conversion (NOP_EXPR, type, e, 0);\n+      /* If we can convert to void type via a type conversion, do so.  */\n+      if (rval)\n+\treturn rval;\n+      return build1 (CONVERT_EXPR, type, e);\n+    }\n+#if 0\n+  /* This is incorrect.  A truncation can't be stripped this way.\n+     Extensions will be stripped by the use of get_unwidened.  */\n+  if (TREE_CODE (expr) == NOP_EXPR)\n+    return convert (type, TREE_OPERAND (expr, 0));\n+#endif\n+\n+  /* Just convert to the type of the member.  */\n+  if (code == OFFSET_TYPE)\n+    {\n+      type = TREE_TYPE (type);\n+      code = TREE_CODE (type);\n+    }\n+\n+  /* C++ */\n+  if (code == REFERENCE_TYPE)\n+    return fold (convert_to_reference (error_mark_node, type, e, NULL_TREE,\n+\t\t\t\t       -1, \"conversion\", -1, LOOKUP_NORMAL));\n+  else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n+    e = convert_from_reference (e);\n+\n+  if (code == INTEGER_TYPE || code == ENUMERAL_TYPE)\n+    {\n+      tree intype = TREE_TYPE (expr);\n+      enum tree_code form = TREE_CODE (intype);\n+      /* enum = enum, enum = int, enum = float are all errors. */\n+      if (flag_int_enum_equivalence == 0\n+\t  && TREE_CODE (type) == ENUMERAL_TYPE\n+\t  && (form == INTEGER_TYPE || form == REAL_TYPE\n+\t      || form == ENUMERAL_TYPE))\n+\t{\n+\t  cp_pedwarn (\"conversion from `%#T' to `%#T'\", intype, type);\n+\n+\t  if (flag_pedantic_errors)\n+\t    return error_mark_node;\n+\t}\n+      if (form == OFFSET_TYPE)\n+\tcp_error_at (\"pointer-to-member expression object not composed with type `%D' object\",\n+\t\t     TYPE_NAME (TYPE_OFFSET_BASETYPE (intype)));\n+      else if (IS_AGGR_TYPE (intype))\n+\t{\n+\t  tree rval;\n+\t  rval = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n+\t  if (rval) return rval;\n+\t  cp_error (\"`%#T' used where an `int' was expected\", intype);\n+\t  return error_mark_node;\n+\t}\n+      return fold (convert_to_integer (type, e));\n+    }\n+  if (code == POINTER_TYPE)\n+    return fold (cp_convert_to_pointer (type, e));\n+  if (code == REAL_TYPE)\n+    {\n+      if (IS_AGGR_TYPE (TREE_TYPE (e)))\n+\t{\n+\t  tree rval;\n+\t  rval = build_type_conversion (CONVERT_EXPR, type, e, 1);\n+\t  if (rval)\n+\t    return rval;\n+\t  else\n+\t    cp_error (\"`%#T' used where a floating point value was expected\",\n+\t\t      TREE_TYPE (e));\n+\t}\n+      return fold (convert_to_real (type, e));\n+    }\n+\n+  /* New C++ semantics:  since assignment is now based on\n+     memberwise copying,  if the rhs type is derived from the\n+     lhs type, then we may still do a conversion.  */\n+  if (IS_AGGR_TYPE_CODE (code))\n+    {\n+      tree dtype = TREE_TYPE (e);\n+\n+      if (TREE_CODE (dtype) == REFERENCE_TYPE)\n+\t{\n+\t  e = convert_from_reference (e);\n+\t  dtype = TREE_TYPE (e);\n+\t}\n+      dtype = TYPE_MAIN_VARIANT (dtype);\n+\n+      /* Conversion of object pointers or signature pointers/references\n+\t to signature pointers/references.  */\n+\n+      if (TYPE_LANG_SPECIFIC (type)\n+\t  && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type)))\n+\t{\n+\t  tree constructor = build_signature_pointer_constructor (type, expr);\n+\t  tree sig_ty = SIGNATURE_TYPE (type);\n+\t  tree sig_ptr;\n+\n+\t  if (constructor == error_mark_node)\n+\t    return error_mark_node;\n+\n+\t  sig_ptr = get_temp_name (type, 1);\n+\t  DECL_INITIAL (sig_ptr) = constructor;\n+\t  CLEAR_SIGNATURE (sig_ty);\n+\t  finish_decl (sig_ptr, constructor, 0, 0);\n+\t  SET_SIGNATURE (sig_ty);\n+\t  TREE_READONLY (sig_ptr) = 1;\n+\n+\t  return sig_ptr;\n+\t}\n+\n+      /* Conversion between aggregate types.  New C++ semantics allow\n+\t objects of derived type to be cast to objects of base type.\n+\t Old semantics only allowed this between pointers.\n+\n+\t There may be some ambiguity between using a constructor\n+\t vs. using a type conversion operator when both apply.  */\n+\n+      else if (IS_AGGR_TYPE (dtype))\n+\t{\n+\t  tree binfo;\n+\n+\t  tree conversion = TYPE_HAS_CONVERSION (dtype)\n+\t    ? build_type_conversion (CONVERT_EXPR, type, e, 1) : NULL_TREE;\n+\n+\t  if (TYPE_HAS_CONSTRUCTOR (type))\n+\t    {\n+\t      tree rval = build_method_call (NULL_TREE, constructor_name_full (type),\n+\t\t\t\t\t     build_tree_list (NULL_TREE, e),\n+\t\t\t\t\t     TYPE_BINFO (type),\n+\t\t\t\t\t     conversion ? LOOKUP_NO_CONVERSION : 0);\n+\n+\t      if (rval != error_mark_node)\n+\t\t{\n+\t\t  if (conversion)\n+\t\t    {\n+\t\t      error (\"both constructor and type conversion operator apply\");\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t  /* call to constructor successful.  */\n+\t\t  rval = build_cplus_new (type, rval, 0);\n+\t\t  return rval;\n+\t\t}\n+\t    }\n+\t  /* Type conversion successful/applies.  */\n+\t  if (conversion)\n+\t    {\n+\t      if (conversion == error_mark_node)\n+\t\terror (\"ambiguous pointer conversion\");\n+\t      return conversion;\n+\t    }\n+\n+\t  /* now try normal C++ assignment semantics.  */\n+\t  binfo = TYPE_BINFO (dtype);\n+\t  if (BINFO_TYPE (binfo) == type\n+\t      || (binfo = get_binfo (type, dtype, 1)))\n+\t    {\n+\t      if (binfo == error_mark_node)\n+\t\treturn error_mark_node;\n+\t    }\n+\t  if (binfo != NULL_TREE)\n+\t    {\n+\t      if (lvalue_p (e))\n+\t\t{\n+\t\t  e = build_unary_op (ADDR_EXPR, e, 0);\n+\n+\t\t  if (! BINFO_OFFSET_ZEROP (binfo))\n+\t\t    e = build (PLUS_EXPR, TYPE_POINTER_TO (type),\n+\t\t\t       e, BINFO_OFFSET (binfo));\n+\t\t  return build1 (INDIRECT_REF, type, e);\n+\t\t}\n+\n+\t      sorry (\"addressable aggregates\");\n+\t      return error_mark_node;\n+\t    }\n+\t  error (\"conversion between incompatible aggregate types requested\");\n+\t  return error_mark_node;\n+\t}\n+      /* conversion from non-aggregate to aggregate type requires\n+         constructor.  */\n+      else if (TYPE_HAS_CONSTRUCTOR (type))\n+\t{\n+\t  tree rval;\n+\t  tree init = build_method_call (NULL_TREE, constructor_name_full (type),\n+\t\t\t\t\t build_tree_list (NULL_TREE, e),\n+\t\t\t\t\t TYPE_BINFO (type), LOOKUP_NORMAL);\n+\t  if (init == error_mark_node)\n+\t    {\n+\t      cp_error (\"in conversion to type `%T'\", type);\n+\t      return error_mark_node;\n+\t    }\n+\t  rval = build_cplus_new (type, init, 0);\n+\t  return rval;\n+\t}\n+    }\n+\n+  /* If TYPE or TREE_TYPE (EXPR) is not on the permanent_obstack,\n+     then the it won't be hashed and hence compare as not equal,\n+     even when it is.  */\n+  if (code == ARRAY_TYPE\n+      && TREE_TYPE (TREE_TYPE (expr)) == TREE_TYPE (type)\n+      && index_type_equal (TYPE_DOMAIN (TREE_TYPE (expr)), TYPE_DOMAIN (type)))\n+    return expr;\n+\n+  cp_error (\"conversion from `%T' to non-scalar type `%T' requested\",\n+\t    TREE_TYPE (expr), type);\n+  return error_mark_node;\n+}\n+\n+/* Like convert, except permit conversions to take place which\n+   are not normally allowed due to access restrictions\n+   (such as conversion from sub-type to private super-type).  */\n+tree\n+convert_force (type, expr)\n+     tree type;\n+     tree expr;\n+{\n+  register tree e = expr;\n+  register enum tree_code code = TREE_CODE (type);\n+\n+  if (code == REFERENCE_TYPE)\n+    return fold (convert_to_reference (0, type, e, NULL_TREE, -1,\n+\t\t\t\t       NULL, -1, 0));\n+  else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n+    e = convert_from_reference (e);\n+\n+  if (code == POINTER_TYPE)\n+    return fold (convert_to_pointer_force (type, e));\n+\n+  /* From cp-typeck.c convert_for_assignment */\n+  if (((TREE_CODE (TREE_TYPE (e)) == POINTER_TYPE && TREE_CODE (e) == ADDR_EXPR\n+\t&& TREE_CODE (TREE_TYPE (e)) == POINTER_TYPE\n+\t&& TREE_CODE (TREE_TYPE (TREE_TYPE (e))) == METHOD_TYPE)\n+       || integer_zerop (e))\n+      && TYPE_PTRMEMFUNC_P (type))\n+    {\n+      /* compatible pointer to member functions. */\n+      e = build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), e, 1);\n+      if (e == 0)\n+\treturn error_mark_node;\n+      return digest_init (type, e, (tree *)0);\n+    }\n+  {\n+    int old_equiv = flag_int_enum_equivalence;\n+    flag_int_enum_equivalence = 1;\n+    e = convert (type, e);\n+    flag_int_enum_equivalence = old_equiv;\n+  }\n+  return e;\n+}\n+\n+/* Subroutine of build_type_conversion.  */\n+static tree\n+build_type_conversion_1 (xtype, basetype, expr, typename, for_sure)\n+     tree xtype, basetype;\n+     tree expr;\n+     tree typename;\n+     int for_sure;\n+{\n+  tree first_arg = expr;\n+  tree rval;\n+  int flags;\n+\n+  if (for_sure == 0)\n+    {\n+      if (! lvalue_p (expr))\n+\tfirst_arg = build1 (NOP_EXPR, TYPE_POINTER_TO (basetype), integer_zero_node);\n+      flags = LOOKUP_PROTECT;\n+    }\n+  else\n+    flags = LOOKUP_NORMAL;\n+\n+  rval = build_method_call (first_arg, constructor_name_full (typename),\n+\t\t\t    NULL_TREE, NULL_TREE, flags);\n+  if (rval == error_mark_node)\n+    {\n+      if (for_sure == 0)\n+\treturn NULL_TREE;\n+      return error_mark_node;\n+    }\n+  if (first_arg != expr)\n+    {\n+      expr = build_up_reference (build_reference_type (TREE_TYPE (expr)), expr,\n+\t\t\t\t LOOKUP_COMPLAIN, 1);\n+      TREE_VALUE (TREE_OPERAND (rval, 1)) = build_unary_op (ADDR_EXPR, expr, 0);\n+    }\n+  if (TREE_CODE (TREE_TYPE (rval)) == REFERENCE_TYPE\n+      && TREE_CODE (xtype) != REFERENCE_TYPE)\n+    rval = default_conversion (rval);\n+\n+  if (warn_cast_qual\n+      && TREE_TYPE (xtype)\n+      && (TREE_READONLY (TREE_TYPE (TREE_TYPE (rval)))\n+\t  > TREE_READONLY (TREE_TYPE (xtype))))\n+    warning (\"user-defined conversion casting away `const'\");\n+  return convert (xtype, rval);\n+}\n+\n+/* Convert an aggregate EXPR to type XTYPE.  If a conversion\n+   exists, return the attempted conversion.  This may\n+   return ERROR_MARK_NODE if the conversion is not\n+   allowed (references private members, etc).\n+   If no conversion exists, NULL_TREE is returned.\n+\n+   If (FOR_SURE & 1) is non-zero, then we allow this type conversion\n+   to take place immediately.  Otherwise, we build a SAVE_EXPR\n+   which can be evaluated if the results are ever needed.\n+\n+   If FOR_SURE >= 2, then we only look for exact conversions.\n+\n+   TYPE may be a reference type, in which case we first look\n+   for something that will convert to a reference type.  If\n+   that fails, we will try to look for something of the\n+   reference's target type, and then return a reference to that.  */\n+tree\n+build_type_conversion (code, xtype, expr, for_sure)\n+     enum tree_code code;\n+     tree xtype, expr;\n+     int for_sure;\n+{\n+  /* C++: check to see if we can convert this aggregate type\n+     into the required scalar type.  */\n+  tree type, type_default;\n+  tree typename = build_typename_overload (xtype), *typenames;\n+  int n_variants = 0;\n+  tree basetype, save_basetype;\n+  tree rval;\n+  int exact_conversion = for_sure >= 2;\n+  for_sure &= 1;\n+\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+\n+  basetype = TREE_TYPE (expr);\n+  if (TREE_CODE (basetype) == REFERENCE_TYPE)\n+    basetype = TREE_TYPE (basetype);\n+\n+  basetype = TYPE_MAIN_VARIANT (basetype);\n+  if (! TYPE_LANG_SPECIFIC (basetype) || ! TYPE_HAS_CONVERSION (basetype))\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (xtype) == POINTER_TYPE\n+      || TREE_CODE (xtype) == REFERENCE_TYPE)\n+    {\n+      /* Prepare to match a variant of this type.  */\n+      type = TYPE_MAIN_VARIANT (TREE_TYPE (xtype));\n+      for (n_variants = 0; type; type = TYPE_NEXT_VARIANT (type))\n+\tn_variants++;\n+      typenames = (tree *)alloca (n_variants * sizeof (tree));\n+      for (n_variants = 0, type = TYPE_MAIN_VARIANT (TREE_TYPE (xtype));\n+\t   type; n_variants++, type = TYPE_NEXT_VARIANT (type))\n+\t{\n+\t  if (type == TREE_TYPE (xtype))\n+\t    typenames[n_variants] = typename;\n+\t  else if (TREE_CODE (xtype) == POINTER_TYPE)\n+\t    typenames[n_variants] = build_typename_overload (build_pointer_type (type));\n+\t  else\n+\t    typenames[n_variants] = build_typename_overload (build_reference_type (type));\n+\t}\n+    }\n+\n+  save_basetype = basetype;\n+  type = xtype;\n+\n+  while (TYPE_HAS_CONVERSION (basetype))\n+    {\n+      int i;\n+      if (lookup_fnfields (TYPE_BINFO (basetype), typename, 0))\n+\treturn build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n+      for (i = 0; i < n_variants; i++)\n+\tif (typenames[i] != typename\n+\t    && lookup_fnfields (TYPE_BINFO (basetype), typenames[i], 0))\n+\t  return build_type_conversion_1 (xtype, basetype, expr, typenames[i], for_sure);\n+\n+      if (TYPE_BINFO_BASETYPES (basetype))\n+\tbasetype = TYPE_BINFO_BASETYPE (basetype, 0);\n+      else\n+\tbreak;\n+    }\n+\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      tree first_arg = expr;\n+      type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+      basetype = save_basetype;\n+\n+      /* May need to build a temporary for this.  */\n+      while (TYPE_HAS_CONVERSION (basetype))\n+\t{\n+\t  if (lookup_fnfields (TYPE_BINFO (basetype), typename, 0))\n+\t    {\n+\t      int flags;\n+\n+\t      if (for_sure == 0)\n+\t\t{\n+\t\t  if (! lvalue_p (expr))\n+\t\t    first_arg = build1 (NOP_EXPR, TYPE_POINTER_TO (basetype), integer_zero_node);\n+\t\t  flags = LOOKUP_PROTECT;\n+\t\t}\n+\t      else\n+\t\tflags = LOOKUP_NORMAL;\n+\t      rval = build_method_call (first_arg, constructor_name_full (typename),\n+\t\t\t\t\tNULL_TREE, NULL_TREE, flags);\n+\t      if (rval == error_mark_node)\n+\t\t{\n+\t\t  if (for_sure == 0)\n+\t\t    return NULL_TREE;\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      TREE_VALUE (TREE_OPERAND (rval, 1)) = expr;\n+\n+\t      if (IS_AGGR_TYPE (type))\n+\t\t{\n+\t\t  tree init = build_method_call (NULL_TREE,\n+\t\t\t\t\t\t constructor_name_full (type),\n+\t\t\t\t\t\t build_tree_list (NULL_TREE, rval), NULL_TREE, LOOKUP_NORMAL);\n+\t\t  tree temp = build_cplus_new (type, init, 1);\n+\t\t  return build_up_reference (TYPE_REFERENCE_TO (type), temp,\n+\t\t\t\t\t     LOOKUP_COMPLAIN, 1);\n+\t\t}\n+\t      return convert (xtype, rval);\n+\t    }\n+\t  if (TYPE_BINFO_BASETYPES (basetype))\n+\t    basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n+\t  else\n+\t    break;\n+\t}\n+      /* No free conversions for reference types, right?.  */\n+      return NULL_TREE;\n+    }\n+\n+  if (exact_conversion)\n+    return NULL_TREE;\n+\n+  /* No perfect match found, try default.  */\n+#if 0 /* This is wrong; there is no standard conversion from void* to\n+         anything.  -jason */\n+  if (code == CONVERT_EXPR && TREE_CODE (type) == POINTER_TYPE)\n+    type_default = ptr_type_node;\n+  else\n+#endif\n+  if (type == void_type_node)\n+    return NULL_TREE;\n+  else\n+    {\n+      tree tmp = default_conversion (build1 (NOP_EXPR, type, integer_zero_node));\n+      if (tmp == error_mark_node)\n+\treturn NULL_TREE;\n+      type_default = TREE_TYPE (tmp);\n+    }\n+\n+  basetype = save_basetype;\n+\n+  if (type_default != type)\n+    {\n+      type = type_default;\n+      typename = build_typename_overload (type);\n+\n+      while (TYPE_HAS_CONVERSION (basetype))\n+\t{\n+\t  if (lookup_fnfields (TYPE_BINFO (basetype), typename, 0))\n+\t    return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n+\t  if (TYPE_BINFO_BASETYPES (basetype))\n+\t    basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n+\t  else\n+\t    break;\n+\t}\n+    }\n+\n+ try_pointer:\n+\n+  if (type == ptr_type_node)\n+    {\n+      /* Try converting to some other pointer type\n+\t with which void* is compatible, or in situations\n+\t in which void* is appropriate (such as &&,||, and !).  */\n+\n+      while (TYPE_HAS_CONVERSION (basetype))\n+\t{\n+\t  if (CLASSTYPE_CONVERSION (basetype, ptr_conv) != 0)\n+\t    {\n+\t      if (CLASSTYPE_CONVERSION (basetype, ptr_conv) == error_mark_node)\n+\t\treturn error_mark_node;\n+\t      typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, ptr_conv));\n+\t      return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n+\t    }\n+\t  if (TYPE_BINFO_BASETYPES (basetype))\n+\t    basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n+\t  else\n+\t    break;\n+\t}\n+    }\n+  if (TREE_CODE (type) == POINTER_TYPE\n+      && TYPE_READONLY (TREE_TYPE (type))\n+      && TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node)\n+    {\n+      /* Try converting to some other pointer type\n+\t with which const void* is compatible.  */\n+\n+      while (TYPE_HAS_CONVERSION (basetype))\n+\t{\n+\t  if (CLASSTYPE_CONVERSION (basetype, constptr_conv) != 0)\n+\t    {\n+\t      if (CLASSTYPE_CONVERSION (basetype, constptr_conv) == error_mark_node)\n+\t\treturn error_mark_node;\n+\t      typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, constptr_conv));\n+\t      return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n+\t    }\n+\t  if (TYPE_BINFO_BASETYPES (basetype))\n+\t    basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n+\t  else\n+\t    break;\n+\t}\n+    }\n+  /* Use the longer or shorter conversion that is appropriate.  Have\n+     to check against 0 because the conversion may come from a baseclass.  */\n+  if (TREE_CODE (type) == INTEGER_TYPE\n+      && TYPE_HAS_INT_CONVERSION (basetype)\n+      && CLASSTYPE_CONVERSION (basetype, int_conv) != 0\n+      && CLASSTYPE_CONVERSION (basetype, int_conv) != error_mark_node)\n+    {\n+      typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, int_conv));\n+      return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n+    }\n+\n+  if (TREE_CODE (type) == REAL_TYPE\n+      && TYPE_HAS_REAL_CONVERSION (basetype)\n+      && CLASSTYPE_CONVERSION (basetype, real_conv) != 0\n+      && CLASSTYPE_CONVERSION (basetype, real_conv) != error_mark_node)\n+    {\n+      /* Only accept using an operator double() if there isn't a conflicting\n+\t operator int().  */\n+      if (flag_ansi_overloading && TYPE_HAS_INT_CONVERSION (basetype))\n+\t{\n+\t  error (\"two possible conversions for type `%s'\",\n+\t\t TYPE_NAME_STRING (type));\n+\t  return error_mark_node;\n+\t}\n+\n+      typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, real_conv));\n+      return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n+    }\n+\n+  /* THIS IS A KLUDGE.  */\n+  if (TREE_CODE (type) != POINTER_TYPE\n+      && (code == TRUTH_ANDIF_EXPR\n+\t  || code == TRUTH_ORIF_EXPR\n+\t  || code == TRUTH_NOT_EXPR))\n+    {\n+      /* Here's when we can convert to a pointer.  */\n+      type = ptr_type_node;\n+      goto try_pointer;\n+    }\n+\n+  /* THESE ARE TOTAL KLUDGES.  */\n+  /* Default promotion yields no new alternatives, try\n+     conversions which are anti-default, such as\n+\n+     double -> float or int -> unsigned or unsigned -> long\n+\n+     */\n+  if (type_default == type\n+      && (TREE_CODE (type) == INTEGER_TYPE || TREE_CODE (type) == REAL_TYPE))\n+    {\n+      int not_again = 0;\n+\n+      if (type == double_type_node)\n+\ttypename = build_typename_overload (float_type_node);\n+      else if (type == integer_type_node)\n+\ttypename = build_typename_overload (unsigned_type_node);\n+      else if (type == unsigned_type_node)\n+\ttypename = build_typename_overload (long_integer_type_node);\n+\n+    again:\n+      basetype = save_basetype;\n+      while (TYPE_HAS_CONVERSION (basetype))\n+\t{\n+\t  if (lookup_fnfields (TYPE_BINFO (basetype), typename, 0))\n+\t    return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n+\t  if (TYPE_BINFO_BASETYPES (basetype))\n+\t    basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n+\t  else\n+\t    break;\n+\t}\n+      if (! not_again)\n+\t{\n+\t  if (type == integer_type_node)\n+\t    {\n+\t      typename = build_typename_overload (long_integer_type_node);\n+\t      not_again = 1;\n+\t      goto again;\n+\t    }\n+\t  else\n+\t    {\n+\t      typename = build_typename_overload (integer_type_node);\n+\t      not_again = 1;\n+\t      goto again;\n+\t    }\n+\t}\n+    }\n+\n+  /* Now, try C promotions...\n+\n+     float -> int\n+     int -> float, void *\n+     void * -> int\n+\n+     Truthvalue conversions let us try to convert\n+     to pointer if we were going for int, and to int\n+     if we were looking for pointer.  */\n+\n+    basetype = save_basetype;\n+    if (TREE_CODE (type) == REAL_TYPE\n+\t|| (TREE_CODE (type) == POINTER_TYPE\n+\t    && (code == TRUTH_ANDIF_EXPR\n+\t\t|| code == TRUTH_ORIF_EXPR\n+\t\t|| code == TRUTH_NOT_EXPR)))\n+      type = integer_type_node;\n+    else if (TREE_CODE (type) == INTEGER_TYPE)\n+      if (TYPE_HAS_REAL_CONVERSION (basetype))\n+\ttype = double_type_node;\n+      else\n+\treturn NULL_TREE;\n+    else\n+      return NULL_TREE;\n+\n+    typename = build_typename_overload (type);\n+    while (TYPE_HAS_CONVERSION (basetype))\n+      {\n+\tif (lookup_fnfields (TYPE_BINFO (basetype), typename, 0))\n+\t  {\n+\t    rval = build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n+\t    return rval;\n+\t  }\n+\tif (TYPE_BINFO_BASETYPES (basetype))\n+\t  basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n+\telse\n+\t  break;\n+      }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Must convert two aggregate types to non-aggregate type.\n+   Attempts to find a non-ambiguous, \"best\" type conversion.\n+\n+   Return 1 on success, 0 on failure.\n+\n+   @@ What are the real semantics of this supposed to be??? */\n+int\n+build_default_binary_type_conversion (code, arg1, arg2)\n+     enum tree_code code;\n+     tree *arg1, *arg2;\n+{\n+  tree type1 = TREE_TYPE (*arg1);\n+  tree type2 = TREE_TYPE (*arg2);\n+\n+  if (TREE_CODE (type1) == REFERENCE_TYPE\n+      || TREE_CODE (type1) == POINTER_TYPE)\n+    type1 = TREE_TYPE (type1);\n+  if (TREE_CODE (type2) == REFERENCE_TYPE\n+      || TREE_CODE (type2) == POINTER_TYPE)\n+    type2 = TREE_TYPE (type2);\n+\n+  if (TREE_CODE (TYPE_NAME (type1)) != TYPE_DECL)\n+    {\n+      tree decl = typedecl_for_tag (type1);\n+      if (decl)\n+\terror (\"type conversion nonexistent for type `%s'\",\n+\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n+      else\n+\terror (\"type conversion nonexistent for non-C++ type\");\n+      return 0;\n+    }\n+  if (TREE_CODE (TYPE_NAME (type2)) != TYPE_DECL)\n+    {\n+      tree decl = typedecl_for_tag (type2);\n+      if (decl)\n+\terror (\"type conversion nonexistent for type `%s'\",\n+\t       IDENTIFIER_POINTER (decl));\n+      else\n+\terror (\"type conversion nonexistent for non-C++ type\");\n+      return 0;\n+    }\n+\n+  if (!IS_AGGR_TYPE (type1) || !TYPE_HAS_CONVERSION (type1))\n+    {\n+      if (!IS_AGGR_TYPE (type2) || !TYPE_HAS_CONVERSION (type2))\n+\tcp_error (\"no conversion from `%T' and `%T' to types with default `%O' \",\n+\t\t  type1, type2, code);\n+      else\n+\tcp_error (\"no conversion from `%T' to type with default `%O'\",\n+\t\t  type1, code);\n+      return 0;\n+    }\n+  else if (!IS_AGGR_TYPE (type2) || !TYPE_HAS_CONVERSION (type2))\n+    {\n+      cp_error (\"no conversion from `%T' to type with default `%O'\",\n+\t\ttype2, code);\n+      return 0;\n+    }\n+\n+  if (TYPE_HAS_INT_CONVERSION (type1) && TYPE_HAS_REAL_CONVERSION (type1))\n+    cp_warning (\"ambiguous type conversion for type `%T', defaulting to int\",\n+\t\ttype1);\n+  if (TYPE_HAS_INT_CONVERSION (type1))\n+    {\n+      *arg1 = build_type_conversion (code, integer_type_node, *arg1, 1);\n+      *arg2 = build_type_conversion (code, integer_type_node, *arg2, 1);\n+    }\n+  else if (TYPE_HAS_REAL_CONVERSION (type1))\n+    {\n+      *arg1 = build_type_conversion (code, double_type_node, *arg1, 1);\n+      *arg2 = build_type_conversion (code, double_type_node, *arg2, 1);\n+    }\n+  else\n+    {\n+      *arg1 = build_type_conversion (code, ptr_type_node, *arg1, 1);\n+      if (*arg1 == error_mark_node)\n+\terror (\"ambiguous pointer conversion\");\n+      *arg2 = build_type_conversion (code, ptr_type_node, *arg2, 1);\n+      if (*arg1 != error_mark_node && *arg2 == error_mark_node)\n+\terror (\"ambiguous pointer conversion\");\n+    }\n+  if (*arg1 == 0)\n+    {\n+      if (*arg2 == 0 && type1 != type2)\n+\tcp_error (\"default type conversion for types `%T' and `%T' failed\",\n+\t\t  type1, type2);\n+      else\n+\tcp_error (\"default type conversion for type `%T' failed\", type1);\n+      return 0;\n+    }\n+  else if (*arg2 == 0)\n+    {\n+      cp_error (\"default type conversion for type `%T' failed\", type2);\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n+/* Must convert two aggregate types to non-aggregate type.\n+   Attempts to find a non-ambiguous, \"best\" type conversion.\n+\n+   Return 1 on success, 0 on failure.\n+\n+   The type of the argument is expected to be of aggregate type here.\n+\n+   @@ What are the real semantics of this supposed to be??? */\n+int\n+build_default_unary_type_conversion (code, arg)\n+     enum tree_code code;\n+     tree *arg;\n+{\n+  tree type = TREE_TYPE (*arg);\n+  tree id = TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+    ? TYPE_IDENTIFIER (type) : TYPE_NAME (type);\n+  char *name = IDENTIFIER_POINTER (id);\n+\n+  if (! TYPE_HAS_CONVERSION (type))\n+    {\n+      error (\"type conversion required for type `%s'\", name);\n+      return 0;\n+    }\n+\n+  if (TYPE_HAS_INT_CONVERSION (type) && TYPE_HAS_REAL_CONVERSION (type))\n+    warning (\"ambiguous type conversion for type `%s', defaulting to int\",\n+\t     name);\n+  if (TYPE_HAS_INT_CONVERSION (type))\n+    *arg = build_type_conversion (code, integer_type_node, *arg, 1);\n+  else if (TYPE_HAS_REAL_CONVERSION (type))\n+    *arg = build_type_conversion (code, double_type_node, *arg, 1);\n+  else\n+    {\n+      *arg = build_type_conversion (code, ptr_type_node, *arg, 1);\n+      if (*arg == error_mark_node)\n+\terror (\"ambiguous pointer conversion\");\n+    }\n+  if (*arg == NULL_TREE)\n+    {\n+      error (\"default type conversion for type `%s' failed\", name);\n+      return 0;\n+    }\n+  return 1;\n+}"}, {"sha": "9a31201f05467b91058b89355352e53c9cb48234", "filename": "gcc/cp/decl.c", "status": "added", "additions": 12087, "deletions": 0, "changes": 12087, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02"}, {"sha": "aabfa2fb92649b399c7a79378322a92201183a46", "filename": "gcc/cp/decl.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,59 @@\n+/* Variables and structures for declaration processing.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* In grokdeclarator, distinguish syntactic contexts of declarators.  */\n+enum decl_context\n+{ NORMAL,\t\t\t/* Ordinary declaration */\n+  FUNCDEF,\t\t\t/* Function definition */\n+  PARM,\t\t\t\t/* Declaration of parm before function body */\n+  FIELD,\t\t\t/* Declaration inside struct or union */\n+  BITFIELD,\t\t\t/* Likewise but with specified width */\n+  TYPENAME,\t\t\t/* Typename (inside cast or sizeof)  */\n+  MEMFUNCDEF\t\t\t/* Member function definition */\n+};\n+\n+/* C++: Keep these around to reduce calls to `get_identifier'.\n+   Identifiers for `this' in member functions and the auto-delete\n+   parameter for destructors.  */\n+extern tree this_identifier, in_charge_identifier;\n+\n+/* Parsing a function declarator leaves a list of parameter names\n+   or a chain or parameter decls here.  */\n+extern tree last_function_parms;\n+\n+/* A list of static class variables.  This is needed, because a\n+   static class variable can be declared inside the class without\n+   an initializer, and then initialized, staticly, outside the class.  */\n+extern tree pending_statics;\n+\n+/* A list of objects which have constructors or destructors\n+   which reside in the global scope.  The decl is stored in\n+   the TREE_VALUE slot and the initializer is stored\n+   in the TREE_PURPOSE slot.  */\n+extern tree static_aggregates;\n+\n+/* A list of functions which were declared inline, but later had their\n+   address taken.  Used only for non-virtual member functions, since we can\n+   find other functions easily enough.  */\n+extern tree pending_addressable_inlines;\n+\n+#ifdef DEBUG_CP_BINDING_LEVELS\n+/* Purely for debugging purposes.  */\n+extern int debug_bindings_indentation;\n+#endif"}, {"sha": "201dcf73a1172774cc86e9c7841fa53eac580a74", "filename": "gcc/cp/decl2.c", "status": "added", "additions": 2823, "deletions": 0, "changes": 2823, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,2823 @@\n+/* Process declarations and variables for C compiler.\n+   Copyright (C) 1988, 1992, 1993 Free Software Foundation, Inc.\n+   Hacked by Michael Tiemann (tiemann@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Process declarations and symbol lookup for C front end.\n+   Also constructs types; the standard scalar types at initialization,\n+   and structure, union, array and enum types when they are declared.  */\n+\n+/* ??? not all decl nodes are given the most useful possible\n+   line numbers.  For example, the CONST_DECLs for enum values.  */\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"cp-tree.h\"\n+#include \"decl.h\"\n+#include \"lex.h\"\n+\n+extern tree grokdeclarator ();\n+extern tree get_file_function_name ();\n+static void grok_function_init ();\n+\n+/* A list of virtual function tables we must make sure to write out.  */\n+tree pending_vtables;\n+\n+/* A list of static class variables.  This is needed, because a\n+   static class variable can be declared inside the class without\n+   an initializer, and then initialized, staticly, outside the class.  */\n+tree pending_statics;\n+\n+extern tree pending_addressable_inlines;\n+\n+/* Used to help generate temporary names which are unique within\n+   a function.  Reset to 0 by start_function.  */\n+\n+static int temp_name_counter;\n+\n+/* Same, but not reset.  Local temp variables and global temp variables\n+   can have the same name.  */\n+static int global_temp_name_counter;\n+\n+/* Flag used when debugging cp-spew.c */\n+\n+extern int spew_debug;\n+\f\n+/* C (and C++) language-specific option variables.  */\n+\n+/* Nonzero means allow type mismatches in conditional expressions;\n+   just make their values `void'.   */\n+\n+int flag_cond_mismatch;\n+\n+/* Nonzero means give `double' the same size as `float'.  */\n+\n+int flag_short_double;\n+\n+/* Nonzero means don't recognize the keyword `asm'.  */\n+\n+int flag_no_asm;\n+\n+/* Nonzero means don't recognize the non-ANSI builtin functions.  */\n+\n+int flag_no_builtin;\n+\n+/* Nonzero means do some things the same way PCC does.  */\n+\n+int flag_traditional;\n+\n+/* Nonzero means to treat bitfields as unsigned unless they say `signed'.  */\n+\n+int flag_signed_bitfields = 1;\n+\n+/* Nonzero means handle `#ident' directives.  0 means ignore them.  */\n+\n+int flag_no_ident = 0;\n+\n+/* Nonzero means handle things in ANSI, instead of GNU fashion.  This\n+   flag should be tested for language behavior that's different between\n+   ANSI and GNU, but not so horrible as to merit a PEDANTIC label.  */\n+\n+int flag_ansi = 0;\n+\n+/* Nonzero means do argument matching for overloading according to the\n+   ANSI rules, rather than what g++ used to believe to be correct.  */\n+\n+int flag_ansi_overloading = 1;\n+\n+/* Nonzero means do emit exported implementations of functions even if\n+   they can be inlined.  */\n+\n+int flag_implement_inlines = 1;\n+\n+/* Nonzero means do emit exported implementations of templates, instead of\n+   multiple static copies in each file that needs a definition. */\n+\n+int flag_external_templates = 0;\n+\n+/* Nonzero means that the decision to emit or not emit the implementation of a\n+   template depends on where the template is instantiated, rather than where\n+   it is defined.  */\n+\n+int flag_alt_external_templates = 0;\n+\n+/* Nonzero means warn about implicit declarations.  */\n+\n+int warn_implicit = 1;\n+\n+/* Nonzero means warn when all ctors or dtors are private, and the class\n+   has no friends.  */\n+\n+int warn_ctor_dtor_privacy = 1;\n+\n+/* Nonzero means give string constants the type `const char *'\n+   to get extra warnings from them.  These warnings will be too numerous\n+   to be useful, except in thoroughly ANSIfied programs.  */\n+\n+int warn_write_strings;\n+\n+/* Nonzero means warn about pointer casts that can drop a type qualifier\n+   from the pointer target type.  */\n+\n+int warn_cast_qual;\n+\n+/* Nonzero means warn that dbx info for template class methods isn't fully\n+   supported yet.  */\n+\n+int warn_template_debugging;\n+\n+/* Warn about traditional constructs whose meanings changed in ANSI C.  */\n+\n+int warn_traditional;\n+\n+/* Nonzero means warn about sizeof(function) or addition/subtraction\n+   of function pointers.  */\n+\n+int warn_pointer_arith;\n+\n+/* Nonzero means warn for non-prototype function decls\n+   or non-prototyped defs without previous prototype.  */\n+\n+int warn_strict_prototypes;\n+\n+/* Nonzero means warn for any function def without prototype decl.  */\n+\n+int warn_missing_prototypes;\n+\n+/* Nonzero means warn about multiple (redundant) decls for the same single\n+   variable or function.  */\n+\n+int warn_redundant_decls;\n+\n+/* Warn if initializer is not completely bracketed.  */\n+\n+int warn_missing_braces;\n+\n+/* Warn about *printf or *scanf format/argument anomalies. */\n+\n+int warn_format;\n+\n+/* Warn about a subscript that has type char.  */\n+\n+int warn_char_subscripts;\n+\n+/* Warn if a type conversion is done that might have confusing results.  */\n+\n+int warn_conversion;\n+\n+/* Warn if adding () is suggested.  */\n+\n+int warn_parentheses = 1;\n+\n+/* Non-zero means warn in function declared in derived class has the\n+   same name as a virtual in the base class, but fails to match the\n+   type signature of any virtual function in the base class.  */\n+int warn_overloaded_virtual;\n+\n+/* Non-zero means warn when declaring a class that has a non virtual\n+   destructor, when it really ought to have a virtual one. */\n+int warn_nonvdtor = 1;\n+\n+/* Non-zero means warn when a function is declared extern and later inline.  */\n+int warn_extern_inline;\n+\n+/* Nonzero means `$' can be in an identifier.\n+   See cccp.c for reasons why this breaks some obscure ANSI C programs.  */\n+\n+#ifndef DOLLARS_IN_IDENTIFIERS\n+#define DOLLARS_IN_IDENTIFIERS 1\n+#endif\n+int dollars_in_ident = DOLLARS_IN_IDENTIFIERS;\n+\n+/* Nonzero for -no-strict-prototype switch: do not consider empty\n+   argument prototype to mean function takes no arguments.  */\n+\n+int strict_prototype = 1;\n+int strict_prototypes_lang_c, strict_prototypes_lang_cplusplus = 1;\n+\n+/* Nonzero means that labels can be used as first-class objects */\n+\n+int flag_labels_ok;\n+\n+/* Non-zero means to collect statistics which might be expensive\n+   and to print them when we are done.  */\n+int flag_detailed_statistics;\n+\n+/* C++ specific flags.  */   \n+/* Nonzero for -fall-virtual: make every member function (except\n+   constructors) lay down in the virtual function table.  Calls\n+   can then either go through the virtual function table or not,\n+   depending.  */\n+\n+int flag_all_virtual;\n+\n+/* Zero means that `this' is a *const.  This gives nice behavior in the\n+   2.0 world.  1 gives 1.2-compatible behavior.  2 gives Spring behavior.\n+   -2 means we're constructing an object and it has fixed type.  */\n+\n+int flag_this_is_variable;\n+\n+/* Nonzero means memoize our member lookups.  */\n+\n+int flag_memoize_lookups; int flag_save_memoized_contexts;\n+\n+/* 3 means write out only virtuals function tables `defined'\n+   in this implementation file.\n+   2 means write out only specific virtual function tables\n+   and give them (C) public access.\n+   1 means write out virtual function tables and give them\n+   (C) public access.\n+   0 means write out virtual function tables and give them\n+   (C) static access (default).\n+   -1 means declare virtual function tables extern.  */\n+\n+int write_virtuals;\n+\n+/* Nonzero means we should attempt to elide constructors when possible.  */\n+\n+int flag_elide_constructors;\n+\n+/* Nonzero means recognize and handle exception handling constructs.\n+   2 means handle exceptions the way Spring wants them handled.  */\n+\n+int flag_handle_exceptions;\n+\n+/* Nonzero means recognize and handle exception handling constructs.\n+   Use ansi syntax and semantics.  WORK IN PROGRESS!\n+   2 means handle exceptions the way Spring wants them handled.  */\n+\n+int flag_ansi_exceptions;\n+\n+/* Nonzero means recognize and handle signature language constructs.  */\n+\n+int flag_handle_signatures;\n+\n+/* Nonzero means that member functions defined in class scope are\n+   inline by default.  */\n+\n+int flag_default_inline = 1;\n+\n+/* Controls whether enums and ints freely convert.\n+   1 means with complete freedom.\n+   0 means enums can convert to ints, but not vice-versa.  */\n+int flag_int_enum_equivalence;\n+\n+/* Controls whether compiler is operating under LUCID's Cadillac\n+   system.  1 means yes, 0 means no.  */\n+int flag_cadillac;\n+\n+/* Controls whether compiler generates code to build objects\n+   that can be collected when they become garbage.  */\n+int flag_gc;\n+\n+/* Controls whether compiler generates 'dossiers' that give\n+   run-time type information.  */\n+int flag_dossier;\n+\n+/* Nonzero if we wish to output cross-referencing information\n+   for the GNU class browser.  */\n+extern int flag_gnu_xref;\n+\n+/* Nonzero if compiler can make `reasonable' assumptions about\n+   references and objects.  For example, the compiler must be\n+   conservative about the following and not assume that `a' is nonnull:\n+\n+   obj &a = g ();\n+   a.f (2);\n+\n+   In general, it is `reasonable' to assume that for many programs,\n+   and better code can be generated in that case.  */\n+\n+int flag_assume_nonnull_objects;\n+\n+/* Nonzero if we want to support huge (> 2^(sizeof(short)*8-1) bytes)\n+   objects. */\n+int flag_huge_objects;\n+\n+/* Nonzero if we want to conserve space in the .o files.  We do this\n+   by putting uninitialized data and runtime initialized data into\n+   .common instead of .data at the expense of not flaging multiple\n+   definitions.  */\n+int flag_conserve_space;\n+\n+/* Table of language-dependent -f options.\n+   STRING is the option name.  VARIABLE is the address of the variable.\n+   ON_VALUE is the value to store in VARIABLE\n+    if `-fSTRING' is seen as an option.\n+   (If `-fno-STRING' is seen as an option, the opposite value is stored.)  */\n+\n+static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n+{\n+  {\"signed-char\", &flag_signed_char, 1},\n+  {\"unsigned-char\", &flag_signed_char, 0},\n+  {\"signed-bitfields\", &flag_signed_bitfields, 1},\n+  {\"unsigned-bitfields\", &flag_signed_bitfields, 0},\n+  {\"short-enums\", &flag_short_enums, 1},\n+  {\"short-double\", &flag_short_double, 1},\n+  {\"cond-mismatch\", &flag_cond_mismatch, 1},\n+  {\"asm\", &flag_no_asm, 0},\n+  {\"builtin\", &flag_no_builtin, 0},\n+  {\"ident\", &flag_no_ident, 0},\n+  {\"labels-ok\", &flag_labels_ok, 1},\n+  {\"stats\", &flag_detailed_statistics, 1},\n+  {\"this-is-variable\", &flag_this_is_variable, 1},\n+  {\"strict-prototype\", &strict_prototypes_lang_cplusplus, 1},\n+  {\"all-virtual\", &flag_all_virtual, 1},\n+  {\"memoize-lookups\", &flag_memoize_lookups, 1},\n+  {\"elide-constructors\", &flag_elide_constructors, 1},\n+  {\"handle-exceptions\", &flag_handle_exceptions, 1},\n+  {\"ansi-exceptions\", &flag_ansi_exceptions, 1},\n+  {\"handle-signatures\", &flag_handle_signatures, 1},\n+  {\"spring-exceptions\", &flag_handle_exceptions, 2},\n+  {\"default-inline\", &flag_default_inline, 1},\n+  {\"dollars-in-identifiers\", &dollars_in_ident, 1},\n+  {\"enum-int-equiv\", &flag_int_enum_equivalence, 1},\n+  {\"gc\", &flag_gc, 1},\n+  {\"dossier\", &flag_dossier, 1},\n+  {\"xref\", &flag_gnu_xref, 1},\n+  {\"nonnull-objects\", &flag_assume_nonnull_objects, 1},\n+  {\"implement-inlines\", &flag_implement_inlines, 1},\n+  {\"external-templates\", &flag_external_templates, 1},\n+  {\"ansi-overloading\", &flag_ansi_overloading, 1},\n+  {\"huge-objects\", &flag_huge_objects, 1},\n+  {\"conserve-space\", &flag_conserve_space, 1},\n+};\n+\n+/* Decode the string P as a language-specific option.\n+   Return 1 if it is recognized (and handle it);\n+   return 0 if not recognized.  */\n+\n+int   \n+lang_decode_option (p)\n+     char *p;\n+{\n+  if (!strcmp (p, \"-ftraditional\") || !strcmp (p, \"-traditional\"))\n+    flag_traditional = 1, dollars_in_ident = 1, flag_writable_strings = 1,\n+    flag_this_is_variable = 1;\n+  /* The +e options are for cfront compatibility.  They come in as\n+     `-+eN', to kludge around gcc.c's argument handling.  */\n+  else if (p[0] == '-' && p[1] == '+' && p[2] == 'e')\n+    {\n+      int old_write_virtuals = write_virtuals;\n+      if (p[3] == '1')\n+\twrite_virtuals = 1;\n+      else if (p[3] == '0')\n+\twrite_virtuals = -1;\n+      else if (p[3] == '2')\n+\twrite_virtuals = 2;\n+      else error (\"invalid +e option\");\n+      if (old_write_virtuals != 0\n+\t  && write_virtuals != old_write_virtuals)\n+\terror (\"conflicting +e options given\");\n+    }\n+  else if (p[0] == '-' && p[1] == 'f')\n+    {\n+      /* Some kind of -f option.\n+\t P's value is the option sans `-f'.\n+\t Search for it in the table of options.  */\n+      int found = 0, j;\n+\n+      p += 2;\n+      /* Try special -f options.  */\n+\n+      if (!strcmp (p, \"save-memoized\"))\n+\t{\n+\t  flag_memoize_lookups = 1;\n+\t  flag_save_memoized_contexts = 1;\n+\t  found = 1;\n+\t}\n+      if (!strcmp (p, \"no-save-memoized\"))\n+\t{\n+\t  flag_memoize_lookups = 0;\n+\t  flag_save_memoized_contexts = 0;\n+\t  found = 1;\n+\t}\n+      else if (! strncmp (p, \"cadillac\", 8))\n+\t{\n+\t  flag_cadillac = atoi (p+9);\n+\t  found = 1;\n+\t}\n+      else if (! strncmp (p, \"no-cadillac\", 11))\n+\t{\n+\t  flag_cadillac = 0;\n+\t  found = 1;\n+\t}\n+      else if (! strcmp (p, \"gc\"))\n+\t{\n+\t  flag_gc = 1;\n+\t  /* This must come along for the ride.  */\n+\t  flag_dossier = 1;\n+\t  found = 1;\n+\t}\n+      else if (! strcmp (p, \"no-gc\"))\n+\t{\n+\t  flag_gc = 0;\n+\t  /* This must come along for the ride.  */\n+\t  flag_dossier = 0;\n+\t  found = 1;\n+\t}\n+      else if (! strcmp (p, \"alt-external-templates\"))\n+\t{\n+\t  flag_external_templates = 1;\n+\t  flag_alt_external_templates = 1;\n+\t  found = 1;\n+\t}\n+      else if (! strcmp (p, \"no-alt-external-templates\"))\n+\t{\n+\t  flag_alt_external_templates = 0;\n+\t  found = 1;\n+\t}\n+      else for (j = 0;\n+\t\t!found && j < sizeof (lang_f_options) / sizeof (lang_f_options[0]);\n+\t\tj++)\n+\t{\n+\t  if (!strcmp (p, lang_f_options[j].string))\n+\t    {\n+\t      *lang_f_options[j].variable = lang_f_options[j].on_value;\n+\t      /* A goto here would be cleaner,\n+\t\t but breaks the vax pcc.  */\n+\t      found = 1;\n+\t    }\n+\t  if (p[0] == 'n' && p[1] == 'o' && p[2] == '-'\n+\t      && ! strcmp (p+3, lang_f_options[j].string))\n+\t    {\n+\t      *lang_f_options[j].variable = ! lang_f_options[j].on_value;\n+\t      found = 1;\n+\t    }\n+\t}\n+      return found;\n+    }\n+  else if (p[0] == '-' && p[1] == 'W')\n+    {\n+      int setting = 1;\n+\n+      /* The -W options control the warning behavior of the compiler.  */\n+      p += 2;\n+\n+      if (p[0] == 'n' && p[1] == 'o' && p[2] == '-')\n+\tsetting = 0, p += 3;\n+\n+      if (!strcmp (p, \"implicit\"))\n+\twarn_implicit = setting;\n+      else if (!strcmp (p, \"return-type\"))\n+\twarn_return_type = setting;\n+      else if (!strcmp (p, \"ctor-dtor-privacy\"))\n+\twarn_ctor_dtor_privacy = setting;\n+      else if (!strcmp (p, \"write-strings\"))\n+\twarn_write_strings = setting;\n+      else if (!strcmp (p, \"cast-qual\"))\n+\twarn_cast_qual = setting;\n+      else if (!strcmp (p, \"traditional\"))\n+\twarn_traditional = setting;\n+      else if (!strcmp (p, \"char-subscripts\"))\n+\twarn_char_subscripts = setting;\n+      else if (!strcmp (p, \"pointer-arith\"))\n+\twarn_pointer_arith = setting;\n+      else if (!strcmp (p, \"strict-prototypes\"))\n+\twarn_strict_prototypes = setting;\n+      else if (!strcmp (p, \"missing-prototypes\"))\n+\twarn_missing_prototypes = setting;\n+      else if (!strcmp (p, \"redundant-decls\"))\n+\twarn_redundant_decls = setting;\n+      else if (!strcmp (p, \"missing-braces\"))\n+\twarn_missing_braces = setting;\n+      else if (!strcmp (p, \"format\"))\n+\twarn_format = setting;\n+      else if (!strcmp (p, \"conversion\"))\n+\twarn_conversion = setting;\n+      else if (!strcmp (p, \"parentheses\"))\n+\twarn_parentheses = setting;\n+      else if (!strcmp (p, \"extern-inline\"))\n+\twarn_extern_inline = setting;\n+      else if (!strcmp (p, \"comment\"))\n+\t;\t\t\t/* cpp handles this one.  */\n+      else if (!strcmp (p, \"comments\"))\n+\t;\t\t\t/* cpp handles this one.  */\n+      else if (!strcmp (p, \"trigraphs\"))\n+\t;\t\t\t/* cpp handles this one.  */\n+      else if (!strcmp (p, \"import\"))\n+\t;\t\t\t/* cpp handles this one.  */\n+      else if (!strcmp (p, \"all\"))\n+\t{\n+\t  extra_warnings = setting;\n+\t  warn_return_type = setting;\n+\t  warn_unused = setting;\n+\t  warn_implicit = setting;\n+\t  warn_ctor_dtor_privacy = setting;\n+\t  warn_switch = setting;\n+\t  warn_format = setting;\n+\t  warn_missing_braces = setting;\n+\t  warn_extern_inline = setting;\n+\t  /* We save the value of warn_uninitialized, since if they put\n+\t     -Wuninitialized on the command line, we need to generate a\n+\t     warning about not using it without also specifying -O.  */\n+\t  if (warn_uninitialized != 1)\n+\t    warn_uninitialized = (setting ? 2 : 0);\n+\t  warn_template_debugging = setting;\n+\t}\n+\n+      else if (!strcmp (p, \"overloaded-virtual\"))\n+\twarn_overloaded_virtual = setting;\n+      else return 0;\n+    }\n+  else if (!strcmp (p, \"-ansi\"))\n+    flag_no_asm = 1, dollars_in_ident = 0, flag_ansi = 1;\n+#ifdef SPEW_DEBUG\n+  /* Undocumented, only ever used when you're invoking cc1plus by hand, since\n+     it's probably safe to assume no sane person would ever want to use this\n+     under normal circumstances.  */\n+  else if (!strcmp (p, \"-spew-debug\"))\n+    spew_debug = 1;\n+#endif\n+  else\n+    return 0;\n+\n+  return 1;\n+}\n+\f\n+/* Incorporate `const' and `volatile' qualifiers for member functions.\n+   FUNCTION is a TYPE_DECL or a FUNCTION_DECL.\n+   QUALS is a list of qualifiers.  */\n+tree\n+grok_method_quals (ctype, function, quals)\n+     tree ctype, function, quals;\n+{\n+  tree fntype = TREE_TYPE (function);\n+  tree raises = TYPE_RAISES_EXCEPTIONS (fntype);\n+\n+  do\n+    {\n+      extern tree ridpointers[];\n+\n+      if (TREE_VALUE (quals) == ridpointers[(int)RID_CONST])\n+\t{\n+\t  if (TYPE_READONLY (ctype))\n+\t    error (\"duplicate `%s' %s\",\n+\t\t   IDENTIFIER_POINTER (TREE_VALUE (quals)),\n+\t\t   (TREE_CODE (function) == FUNCTION_DECL\n+\t\t    ? \"for member function\" : \"in type declaration\"));\n+\t  ctype = build_type_variant (ctype, 1, TYPE_VOLATILE (ctype));\n+\t  build_pointer_type (ctype);\n+\t}\n+      else if (TREE_VALUE (quals) == ridpointers[(int)RID_VOLATILE])\n+\t{\n+\t  if (TYPE_VOLATILE (ctype))\n+\t    error (\"duplicate `%s' %s\",\n+\t\t   IDENTIFIER_POINTER (TREE_VALUE (quals)),\n+\t\t   (TREE_CODE (function) == FUNCTION_DECL\n+\t\t    ? \"for member function\" : \"in type declaration\"));\n+\t  ctype = build_type_variant (ctype, TYPE_READONLY (ctype), 1);\n+\t  build_pointer_type (ctype);\n+\t}\n+      else\n+\tmy_friendly_abort (20);\n+      quals = TREE_CHAIN (quals);\n+    }\n+  while (quals);\n+  fntype = build_cplus_method_type (ctype, TREE_TYPE (fntype),\n+\t\t\t\t    (TREE_CODE (fntype) == METHOD_TYPE\n+\t\t\t\t     ? TREE_CHAIN (TYPE_ARG_TYPES (fntype))\n+\t\t\t\t     : TYPE_ARG_TYPES (fntype)));\n+  if (raises)\n+    fntype = build_exception_variant (ctype, fntype, raises);\n+\n+  TREE_TYPE (function) = fntype;\n+  return ctype;\n+}\n+\n+/* This routine replaces cryptic DECL_NAMEs with readable DECL_NAMEs.\n+   It leaves DECL_ASSEMBLER_NAMEs with the correct value.  */\n+/* This does not yet work with user defined conversion operators\n+   It should.  */\n+static void\n+substitute_nice_name (decl)\n+     tree decl;\n+{\n+  if (DECL_NAME (decl) && TREE_CODE (DECL_NAME (decl)) == IDENTIFIER_NODE)\n+    {\n+      char *n = decl_as_string (DECL_NAME (decl), 1);\n+      if (n[strlen (n) - 1] == ' ')\n+\tn[strlen (n) - 1] = 0;\n+      DECL_NAME (decl) = get_identifier (n);\n+    }\n+}\n+\n+/* Warn when -fexternal-templates is used and #pragma\n+   interface/implementation is not used all the times it should be,\n+   inform the user.  */\n+void\n+warn_if_unknown_interface ()\n+{\n+  static int already_warned = 0;\n+  if (++already_warned == 1)\n+    warning (\"templates that are built with -fexternal-templates should be in files that have #pragma interface/implementation\");\n+}\n+\n+/* A subroutine of the parser, to handle a component list.  */\n+tree\n+grok_x_components (specs, components)\n+     tree specs, components;\n+{\n+  register tree t, x, tcode;\n+\n+  /* We just got some friends.  They have been recorded elsewhere.  */\n+  if (components == void_type_node)\n+    return NULL_TREE;\n+\n+  if (components == NULL_TREE)\n+    {\n+      t = groktypename (build_decl_list (specs, NULL_TREE));\n+\n+      if (t == NULL_TREE)\n+\t{\n+\t  error (\"error in component specification\");\n+\t  return NULL_TREE;\n+\t}\n+\n+      switch (TREE_CODE (t))\n+\t{\n+\tcase VAR_DECL:\n+\t  /* Static anonymous unions come out as VAR_DECLs.  */\n+\t  if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE\n+\t      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (TREE_TYPE (t))))\n+\t    return t;\n+\n+\t  /* We return SPECS here, because in the parser it was ending\n+\t     up with not doing anything to $$, which is what SPECS\n+\t     represents.  */\n+\t  return specs;\n+\t  break;\n+\n+\tcase RECORD_TYPE:\n+\t  /* This code may be needed for UNION_TYPEs as\n+\t     well.  */\n+\t  tcode = record_type_node;\n+\t  if (CLASSTYPE_DECLARED_CLASS(t))\n+\t    tcode = class_type_node;\n+\t  else if (IS_SIGNATURE(t))\n+\t    tcode = signature_type_node;\n+\t  else if (CLASSTYPE_DECLARED_EXCEPTION(t))\n+\t    tcode = exception_type_node;\n+\t  \n+\t  t = xref_defn_tag(tcode, TYPE_IDENTIFIER(t), NULL_TREE);\n+\t  if (TYPE_CONTEXT(t))\n+\t    CLASSTYPE_NO_GLOBALIZE(t) = 1;\n+\t  if (TYPE_LANG_SPECIFIC (t)\n+\t      && CLASSTYPE_DECLARED_EXCEPTION (t))\n+\t    shadow_tag (specs);\n+\t  return NULL_TREE;\n+\t  break;\n+\n+\tcase UNION_TYPE:\n+\tcase ENUMERAL_TYPE:\n+\t  if (TREE_CODE(t) == UNION_TYPE)\n+\t    tcode = union_type_node;\n+\t  else\n+\t    tcode = enum_type_node;\n+\n+\t  t = xref_defn_tag(tcode, TYPE_IDENTIFIER(t), NULL_TREE);\n+\t  if (TREE_CODE(t) == UNION_TYPE && TYPE_CONTEXT(t))\n+\t    CLASSTYPE_NO_GLOBALIZE(t) = 1;\n+\t  if (TREE_CODE (t) == UNION_TYPE\n+\t      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+\t    {\n+\t      struct pending_inline **p;\n+\t      x = build_lang_field_decl (FIELD_DECL, NULL_TREE, t);\n+\n+\t      /* Wipe out memory of synthesized methods */\n+\t      TYPE_HAS_CONSTRUCTOR (t) = 0;\n+\t      TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 0;\n+\t      TYPE_HAS_INIT_REF (t) = 0;\n+\t      TYPE_HAS_CONST_INIT_REF (t) = 0;\n+\t      TYPE_HAS_ASSIGN_REF (t) = 0;\n+\t      TYPE_HAS_ASSIGNMENT (t) = 0;\n+\t      TYPE_HAS_CONST_ASSIGN_REF (t) = 0;\n+\n+\t      p = &pending_inlines;\n+\t      for (; *p; *p = (*p)->next)\n+\t\tif (DECL_CONTEXT ((*p)->fndecl) != t)\n+\t\t  break;\n+\t    }\n+\t  else if (TREE_CODE (t) == ENUMERAL_TYPE)\n+\t    x = grok_enum_decls (t, NULL_TREE);\n+\t  else\n+\t    x = NULL_TREE;\n+\t  return x;\n+\t  break;\n+\n+\tdefault:\n+\t  if (t != void_type_node)\n+\t    error (\"empty component declaration\");\n+\t  return NULL_TREE;\n+\t}\n+    }\n+  else\n+    {\n+      t = TREE_TYPE (components);\n+      if (TREE_CODE (t) == ENUMERAL_TYPE && TREE_NONLOCAL_FLAG (t))\n+\treturn grok_enum_decls (t, components);\n+      else\n+\treturn components;\n+    }\n+}\n+\n+/* Classes overload their constituent function names automatically.\n+   When a function name is declared in a record structure,\n+   its name is changed to it overloaded name.  Since names for\n+   constructors and destructors can conflict, we place a leading\n+   '$' for destructors.\n+\n+   CNAME is the name of the class we are grokking for.\n+\n+   FUNCTION is a FUNCTION_DECL.  It was created by `grokdeclarator'.\n+\n+   FLAGS contains bits saying what's special about today's\n+   arguments.  1 == DESTRUCTOR.  2 == OPERATOR.\n+\n+   If FUNCTION is a destructor, then we must add the `auto-delete' field\n+   as a second parameter.  There is some hair associated with the fact\n+   that we must \"declare\" this variable in the manner consistent with the\n+   way the rest of the arguments were declared.\n+\n+   QUALS are the qualifiers for the this pointer.  */\n+\n+void\n+grokclassfn (ctype, cname, function, flags, quals)\n+     tree ctype, cname, function;\n+     enum overload_flags flags;\n+     tree quals;\n+{\n+  tree fn_name = DECL_NAME (function);\n+  tree arg_types;\n+  tree parm;\n+\n+  if (fn_name == NULL_TREE)\n+    {\n+      error (\"name missing for member function\");\n+      fn_name = get_identifier (\"<anonymous>\");\n+      DECL_NAME (function) = fn_name;\n+    }\n+\n+  if (quals)\n+    ctype = grok_method_quals (ctype, function, quals);\n+\n+  arg_types = TYPE_ARG_TYPES (TREE_TYPE (function));\n+  if (TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n+    {\n+      /* Must add the class instance variable up front.  */\n+      /* Right now we just make this a pointer.  But later\n+\t we may wish to make it special.  */\n+      tree type = TREE_VALUE (arg_types);\n+\n+      if (flags == DTOR_FLAG)\n+\ttype = TYPE_MAIN_VARIANT (type);\n+      else if (DECL_CONSTRUCTOR_P (function))\n+\t{\n+\t  if (TYPE_USES_VIRTUAL_BASECLASSES (ctype))\n+\t    {\n+\t      DECL_CONSTRUCTOR_FOR_VBASE_P (function) = 1;\n+\t      /* In this case we need \"in-charge\" flag saying whether\n+\t\t this constructor is responsible for initialization\n+\t\t of virtual baseclasses or not.  */\n+\t      parm = build_decl (PARM_DECL, in_charge_identifier, integer_type_node);\n+\t      /* Mark the artificial `__in_chrg' parameter as \"artificial\".  */\n+\t      DECL_SOURCE_LINE (parm) = 0;\n+\t      DECL_ARG_TYPE (parm) = integer_type_node;\n+\t      DECL_REGISTER (parm) = 1;\n+\t      TREE_CHAIN (parm) = last_function_parms;\n+\t      last_function_parms = parm;\n+\t    }\n+\t}\n+\n+      parm = build_decl (PARM_DECL, this_identifier, type);\n+      /* Mark the artificial `this' parameter as \"artificial\".  */\n+      DECL_SOURCE_LINE (parm) = 0;\n+      DECL_ARG_TYPE (parm) = type;\n+      /* We can make this a register, so long as we don't\n+\t accidentally complain if someone tries to take its address.  */\n+      DECL_REGISTER (parm) = 1;\n+#if 0\n+      /* it is wrong to flag the object as readonly, when\n+\t flag_this_is_variable is 0. */\n+      if (flags != DTOR_FLAG\n+\t  && (flag_this_is_variable <= 0 || TYPE_READONLY (type)))\n+#else\n+      if (flags != DTOR_FLAG && TYPE_READONLY (type))\n+#endif\n+\tTREE_READONLY (parm) = 1;\n+      TREE_CHAIN (parm) = last_function_parms;\n+      last_function_parms = parm;\n+    }\n+\n+  if (flags == DTOR_FLAG)\n+    {\n+      char *buf, *dbuf;\n+      tree const_integer_type = build_type_variant (integer_type_node, 1, 0);\n+      int len = sizeof (DESTRUCTOR_DECL_PREFIX)-1;\n+\n+      arg_types = hash_tree_chain (const_integer_type, void_list_node);\n+      TREE_SIDE_EFFECTS (arg_types) = 1;\n+      /* Build the overload name.  It will look like `7Example'.  */\n+      if (IDENTIFIER_TYPE_VALUE (cname))\n+\tdbuf = build_overload_name (IDENTIFIER_TYPE_VALUE (cname), 1, 1);\n+      else if (IDENTIFIER_LOCAL_VALUE (cname))\n+\tdbuf = build_overload_name (TREE_TYPE (IDENTIFIER_LOCAL_VALUE (cname)), 1, 1);\n+      else\n+      /* Using ctype fixes the `X::Y::~Y()' crash.  The cname has no type when\n+\t it's defined out of the class definition, since poplevel_class wipes\n+\t it out.  This used to be internal error 346.  */\n+\tdbuf = build_overload_name (ctype, 1, 1);\n+      buf = (char *) alloca (strlen (dbuf) + sizeof (DESTRUCTOR_DECL_PREFIX));\n+      bcopy (DESTRUCTOR_DECL_PREFIX, buf, len);\n+      buf[len] = '\\0';\n+      strcat (buf, dbuf);\n+      DECL_ASSEMBLER_NAME (function) = get_identifier (buf);\n+      parm = build_decl (PARM_DECL, in_charge_identifier, const_integer_type);\n+      /* Mark the artificial `__in_chrg' parameter as \"artificial\".  */\n+      DECL_SOURCE_LINE (parm) = 0;\n+      TREE_USED (parm) = 1;\n+#if 0\n+      /* We don't need to mark the __in_chrg parameter itself as `const'\n+ \t since its type is already `const int'.  In fact we MUST NOT mark\n+ \t it as `const' cuz that will screw up the debug info (causing it\n+ \t to say that the type of __in_chrg is `const const int').  */\n+      TREE_READONLY (parm) = 1;\n+#endif\n+      DECL_ARG_TYPE (parm) = const_integer_type;\n+      /* This is the same chain as DECL_ARGUMENTS (...).  */\n+      TREE_CHAIN (last_function_parms) = parm;\n+\n+      TREE_TYPE (function) = build_cplus_method_type (ctype, void_type_node,\n+\t\t\t\t\t\t      arg_types);\n+      TYPE_HAS_DESTRUCTOR (ctype) = 1;\n+    }\n+  else\n+    {\n+      tree these_arg_types;\n+\n+      if (DECL_CONSTRUCTOR_FOR_VBASE_P (function))\n+\t{\n+\t  arg_types = hash_tree_chain (integer_type_node,\n+\t\t\t\t       TREE_CHAIN (arg_types));\n+\t  TREE_TYPE (function)\n+\t    = build_cplus_method_type (ctype,\n+\t\t\t\t       TREE_TYPE (TREE_TYPE (function)),\n+\t\t\t\t       arg_types);\n+\t  arg_types = TYPE_ARG_TYPES (TREE_TYPE (function));\n+\t}\n+\n+      these_arg_types = arg_types;\n+\n+      if (TREE_CODE (TREE_TYPE (function)) == FUNCTION_TYPE)\n+\t/* Only true for static member functions.  */\n+\tthese_arg_types = hash_tree_chain (TYPE_POINTER_TO (ctype), arg_types);\n+\n+      DECL_ASSEMBLER_NAME (function)\n+\t= build_decl_overload (fn_name, these_arg_types,\n+\t\t\t       1 + DECL_CONSTRUCTOR_P (function));\n+\n+#if 0\n+      /* This code is going into the compiler, but currently, it makes\n+\t libg++/src/Interger.cc not compile.  The problem is that the nice name\n+\t winds up going into the symbol table, and conversion operations look\n+\t for the manged name.  */\n+      substitute_nice_name (function);\n+#endif\n+    }\n+\n+  DECL_ARGUMENTS (function) = last_function_parms;\n+  /* First approximations.  */\n+  DECL_CONTEXT (function) = ctype;\n+  DECL_CLASS_CONTEXT (function) = ctype;\n+}\n+\n+/* Work on the expr used by alignof (this is only called by the parser).  */\n+tree\n+grok_alignof (expr)\n+     tree expr;\n+{\n+  tree best, t;\n+  int bestalign;\n+\n+  if (TREE_CODE (expr) == COMPONENT_REF\n+      && DECL_BIT_FIELD (TREE_OPERAND (expr, 1)))\n+    error (\"`__alignof__' applied to a bit-field\");\n+\n+  if (TREE_CODE (expr) == INDIRECT_REF)\n+    {\n+      best = t = TREE_OPERAND (expr, 0);\n+      bestalign = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (t)));\n+\n+      while (TREE_CODE (t) == NOP_EXPR\n+\t     && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == POINTER_TYPE)\n+\t{\n+\t  int thisalign;\n+\t  t = TREE_OPERAND (t, 0);\n+\t  thisalign = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (t)));\n+\t  if (thisalign > bestalign)\n+\t    best = t, bestalign = thisalign;\n+\t}\n+      return c_alignof (TREE_TYPE (TREE_TYPE (best)));\n+    }\n+  else\n+    {\n+      /* ANSI says arrays and fns are converted inside comma.\n+\t But we can't convert them in build_compound_expr\n+\t because that would break commas in lvalues.\n+\t So do the conversion here if operand was a comma.  */\n+      if (TREE_CODE (expr) == COMPOUND_EXPR\n+\t  && (TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n+\t      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE))\n+\texpr = default_conversion (expr);\n+      return c_alignof (TREE_TYPE (expr));\n+    }\n+}\n+\n+/* Create an ARRAY_REF, checking for the user doing things backwards\n+   along the way.  */\n+tree\n+grok_array_decl (array_expr, index_exp)\n+     tree array_expr, index_exp;\n+{\n+  tree type = TREE_TYPE (array_expr);\n+\n+  if (type == error_mark_node || index_exp == error_mark_node)\n+    return error_mark_node;\n+  if (type == NULL_TREE)\n+    {\n+      /* Something has gone very wrong.  Assume we are mistakenly reducing\n+\t an expression instead of a declaration.  */\n+      error (\"parser may be lost: is there a '{' missing somewhere?\");\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (type) == OFFSET_TYPE\n+      || TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  /* If they have an `operator[]', use that.  */\n+  if (TYPE_LANG_SPECIFIC (type)\n+      && TYPE_OVERLOADS_ARRAY_REF (type))\n+    return build_opfncall (ARRAY_REF, LOOKUP_NORMAL,\n+\t\t\t array_expr, index_exp, NULL_TREE);\n+\n+  /* Otherwise, create an ARRAY_REF for a pointer or array type.  */\n+  if (TREE_CODE (type) == POINTER_TYPE\n+      || TREE_CODE (type) == ARRAY_TYPE)\n+    return build_array_ref (array_expr, index_exp);\n+\n+  /* Woops, looks like they did something like `5[a]' instead of `a[5]'.\n+     We don't emit a warning or error for this, since it's allowed\n+     by ARM $8.2.4.  */\n+\n+  type = TREE_TYPE (index_exp);\n+\n+  if (TREE_CODE (type) == OFFSET_TYPE\n+      || TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  if (TYPE_LANG_SPECIFIC (type)\n+      && TYPE_OVERLOADS_ARRAY_REF (type))\n+    error (\"array expression backwards\");\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   || TREE_CODE (type) == ARRAY_TYPE)\n+    return build_array_ref (index_exp, array_expr);\n+  else\n+    error(\"`[]' applied to non-pointer type\");\n+\n+  /* We gave an error, so give an error.  Huh?  */\n+  return error_mark_node;\n+}\n+\n+/* Given the cast expression EXP, checking out its validity.   Either return\n+   an error_mark_node if there was an unavoidable error, return a cast to\n+   void for trying to delete a pointer w/ the value 0, or return the\n+   call to delete.  If DOING_VEC is 1, we handle things differently\n+   for doing an array delete.  If DOING_VEC is 2, they gave us the\n+   array size as an argument to delete.\n+   Implements ARM $5.3.4.  This is called from the parser.  */\n+tree\n+delete_sanity (exp, size, doing_vec, use_global_delete)\n+     tree exp, size;\n+     int doing_vec, use_global_delete;\n+{\n+  tree t = stabilize_reference (convert_from_reference (exp));\n+  tree type = TREE_TYPE (t);\n+  enum tree_code code = TREE_CODE (type);\n+  /* For a regular vector delete (aka, no size argument) we will pass\n+     this down as a NULL_TREE into build_vec_delete.  */\n+  tree maxindex = NULL_TREE;\n+  /* This is used for deleting arrays.  */\n+  tree elt_size;\n+\n+  switch (doing_vec)\n+    {\n+    case 2:\n+      maxindex = build_binary_op (MINUS_EXPR, size, integer_one_node, 1);\n+      if (! flag_traditional)\n+\tpedwarn (\"ANSI C++ forbids array size in vector delete\");\n+      /* Fall through.  */\n+    case 1:\n+      elt_size = c_sizeof (type);\n+      break;\n+    default:\n+      if (code != POINTER_TYPE)\n+\t{\n+\t  cp_error (\"type `%#T' argument given to `delete', expected pointer\",\n+\t\t    type);\n+\t  return error_mark_node;\n+\t}\n+\n+      /* Deleting a pointer with the value zero is legal and has no effect.  */\n+      if (integer_zerop (t))\n+\treturn build1 (NOP_EXPR, void_type_node, t);\n+    }\n+\n+  /* You can't delete a pointer to constant.  */\n+  if (code == POINTER_TYPE && TREE_READONLY (TREE_TYPE (type)))\n+    {\n+      error (\"`const *' cannot be deleted\");\n+      return error_mark_node;\n+    }\n+\n+  /* If the type has no destructor, then we should build a regular\n+     delete, instead of a vector delete.  Otherwise, we would end\n+     up passing a bogus offset into __builtin_delete, which is\n+     not expecting it.  */ \n+  if (doing_vec\n+      && TREE_CODE (type) == POINTER_TYPE\n+      && !TYPE_HAS_DESTRUCTOR (TREE_TYPE (type)))\n+    doing_vec = 0;\n+\n+  if (doing_vec)\n+    return build_vec_delete (t, maxindex, elt_size, NULL_TREE,\n+\t\t\t     integer_one_node, integer_two_node);\n+  else\n+    return build_delete (type, t, integer_three_node,\n+\t\t\t LOOKUP_NORMAL|LOOKUP_HAS_IN_CHARGE,\n+\t\t\t use_global_delete\n+\t\t\t || TYPE_HAS_DESTRUCTOR (TREE_TYPE (type)));\n+}\n+\n+/* Sanity check: report error if this function FUNCTION is not\n+   really a member of the class (CTYPE) it is supposed to belong to.\n+   CNAME is the same here as it is for grokclassfn above.  */\n+\n+void\n+check_classfn (ctype, cname, function)\n+     tree ctype, cname, function;\n+{\n+  tree fn_name = DECL_NAME (function);\n+  tree fndecl;\n+  int need_quotes = 0;\n+  tree method_vec = CLASSTYPE_METHOD_VEC (ctype);\n+  tree *methods = 0;\n+  tree *end = 0;\n+\n+  if (method_vec != 0)\n+    {\n+      methods = &TREE_VEC_ELT (method_vec, 0);\n+      end = TREE_VEC_END (method_vec);\n+\n+      /* First suss out ctors and dtors.  */\n+      if (*methods && fn_name == cname)\n+\tgoto got_it;\n+\n+      while (++methods != end)\n+\t{\n+\t  if (fn_name == DECL_NAME (*methods))\n+\t    {\n+\t    got_it:\n+\t      fndecl = *methods;\n+\t      while (fndecl)\n+\t\t{\n+\t\t  if (DECL_ASSEMBLER_NAME (function) == DECL_ASSEMBLER_NAME (fndecl))\n+\t\t    return;\n+\t\t  fndecl = DECL_CHAIN (fndecl);\n+\t\t}\n+\t      break;\t\t/* loser */\n+\t    }\n+\t}\n+    }\n+\n+  if (methods != end)\n+    cp_error (\"argument list for `%D' does not match any in class `%T'\",\n+\t      fn_name, ctype);\n+  else\n+    {\n+      methods = 0;\n+      cp_error (\"no `%D' member function declared in class `%T'\",\n+\t\tfn_name, ctype);\n+    }\n+\n+  /* If we did not find the method in the class, add it to\n+     avoid spurious errors.  */\n+  add_method (ctype, methods, function);\n+}\n+\n+/* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)\n+   of a structure component, returning a FIELD_DECL node.\n+   QUALS is a list of type qualifiers for this decl (such as for declaring\n+   const member functions).\n+\n+   This is done during the parsing of the struct declaration.\n+   The FIELD_DECL nodes are chained together and the lot of them\n+   are ultimately passed to `build_struct' to make the RECORD_TYPE node.\n+\n+   C++:\n+\n+   If class A defines that certain functions in class B are friends, then\n+   the way I have set things up, it is B who is interested in permission\n+   granted by A.  However, it is in A's context that these declarations\n+   are parsed.  By returning a void_type_node, class A does not attempt\n+   to incorporate the declarations of the friends within its structure.\n+\n+   DO NOT MAKE ANY CHANGES TO THIS CODE WITHOUT MAKING CORRESPONDING\n+   CHANGES TO CODE IN `start_method'.  */\n+\n+tree\n+grokfield (declarator, declspecs, raises, init, asmspec_tree)\n+     tree declarator, declspecs, raises, init, asmspec_tree;\n+{\n+  register tree value;\n+  char *asmspec = 0;\n+\n+  /* Convert () initializers to = initializers.  */\n+  if (init == NULL_TREE && declarator != NULL_TREE\n+      && TREE_CODE (declarator) == CALL_EXPR\n+      && TREE_OPERAND (declarator, 0)\n+      && (TREE_CODE (TREE_OPERAND (declarator, 0)) == IDENTIFIER_NODE\n+\t  || TREE_CODE (TREE_OPERAND (declarator, 0)) == SCOPE_REF)\n+      && parmlist_is_exprlist (TREE_OPERAND (declarator, 1)))\n+    {\n+      init = TREE_OPERAND (declarator, 1);\n+      declarator = TREE_OPERAND (declarator, 0);\n+    }\n+\n+  if (init\n+      && TREE_CODE (init) == TREE_LIST\n+      && TREE_VALUE (init) == error_mark_node\n+      && TREE_CHAIN (init) == NULL_TREE)\n+\tinit = NULL_TREE;\n+\n+  value = grokdeclarator (declarator, declspecs, FIELD, init != 0, raises);\n+  if (! value)\n+    return NULL_TREE; /* friends went bad.  */\n+\n+  /* Pass friendly classes back.  */\n+  if (TREE_CODE (value) == VOID_TYPE)\n+    return void_type_node;\n+\n+  if (DECL_NAME (value) != NULL_TREE\n+      && IDENTIFIER_POINTER (DECL_NAME (value))[0] == '_'\n+      && ! strcmp (IDENTIFIER_POINTER (DECL_NAME (value)), \"_vptr\"))\n+    cp_error (\"member `%D' conflicts with virtual function table field name\", value);\n+\n+  /* Stash away type declarations.  */\n+  if (TREE_CODE (value) == TYPE_DECL)\n+    {\n+      DECL_NONLOCAL (value) = 1;\n+      CLASSTYPE_LOCAL_TYPEDECLS (current_class_type) = 1;\n+      pushdecl_class_level (value);\n+      return value;\n+    }\n+\n+  if (IS_SIGNATURE (current_class_type)\n+      && TREE_CODE (value) != FUNCTION_DECL)\n+    {\n+      error (\"field declaration not allowed in signature\");\n+      return void_type_node;\n+    }\n+\n+  if (DECL_IN_AGGR_P (value))\n+    {\n+      cp_error (\"`%D' is already defined in the class %T\", value,\n+\t\t  DECL_CONTEXT (value));\n+      return void_type_node;\n+    }\n+\n+  if (flag_cadillac)\n+    cadillac_start_decl (value);\n+\n+  if (asmspec_tree)\n+    asmspec = TREE_STRING_POINTER (asmspec_tree);\n+\n+  if (init)\n+    {\n+      if (IS_SIGNATURE (current_class_type)\n+\t  && TREE_CODE (value) == FUNCTION_DECL)\n+\t{\n+\t  error (\"function declarations cannot have initializers in signature\");\n+\t  init = NULL_TREE;\n+\t}\n+      else if (TREE_CODE (value) == FUNCTION_DECL)\n+\t{\n+\t  grok_function_init (value, init);\n+\t  init = NULL_TREE;\n+\t}\n+      else if (pedantic)\n+\t{\n+\t  if (DECL_NAME (value))\n+\t    pedwarn (\"ANSI C++ forbids initialization of member `%s'\",\n+\t\t     IDENTIFIER_POINTER (DECL_NAME (value)));\n+\t  else\n+\t    pedwarn (\"ANSI C++ forbids initialization of fields\");\n+\n+\t  init = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  /* We allow initializers to become parameters to base initializers.  */\n+\t  if (TREE_CODE (init) == TREE_LIST)\n+\t    {\n+\t      if (TREE_CHAIN (init) == NULL_TREE)\n+\t\tinit = TREE_VALUE (init);\n+\t      else\n+\t\tinit = digest_init (TREE_TYPE (value), init, (tree *)0);\n+\t    }\n+\t  \n+\t  if (TREE_CODE (init) == CONST_DECL)\n+\t    init = DECL_INITIAL (init);\n+\t  else if (TREE_READONLY_DECL_P (init))\n+\t    init = decl_constant_value (init);\n+\t  else if (TREE_CODE (init) == CONSTRUCTOR)\n+\t    init = digest_init (TREE_TYPE (value), init, (tree *)0);\n+\t  my_friendly_assert (TREE_PERMANENT (init), 192);\n+\t  if (init == error_mark_node)\n+\t    /* We must make this look different than `error_mark_node'\n+\t       because `decl_const_value' would mis-interpret it\n+\t       as only meaning that this VAR_DECL is defined.  */\n+\t    init = build1 (NOP_EXPR, TREE_TYPE (value), init);\n+\t  else if (! TREE_CONSTANT (init))\n+\t    {\n+\t      /* We can allow references to things that are effectively\n+\t\t static, since references are initialized with the address.  */\n+\t      if (TREE_CODE (TREE_TYPE (value)) != REFERENCE_TYPE\n+\t\t  || (TREE_STATIC (init) == 0\n+\t\t      && (TREE_CODE_CLASS (TREE_CODE (init)) != 'd'\n+\t\t\t  || DECL_EXTERNAL (init) == 0)))\n+\t\t{\n+\t\t  error (\"field initializer is not constant\");\n+\t\t  init = error_mark_node;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* The corresponding pop_obstacks is in finish_decl.  */\n+  push_obstacks_nochange ();\n+\n+  if (TREE_CODE (value) == VAR_DECL)\n+    {\n+      /* We cannot call pushdecl here, because that would\n+\t fill in the value of our TREE_CHAIN.  Instead, we\n+\t modify finish_decl to do the right thing, namely, to\n+\t put this decl out straight away.  */\n+      if (TREE_STATIC (value))\n+\t{\n+\t  /* current_class_type can be NULL_TREE in case of error.  */\n+\t  if (asmspec == 0 && current_class_type)\n+\t    {\n+\t      tree name;\n+\t      char *buf, *buf2;\n+\n+\t      buf2 = build_overload_name (current_class_type, 1, 1);\n+\t      buf = (char *)alloca (IDENTIFIER_LENGTH (DECL_NAME (value))\n+\t\t\t\t    + sizeof (STATIC_NAME_FORMAT)\n+\t\t\t\t    + strlen (buf2));\n+\t      sprintf (buf, STATIC_NAME_FORMAT, buf2,\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (value)));\n+\t      name = get_identifier (buf);\n+\t      TREE_PUBLIC (value) = 1;\n+\t      DECL_INITIAL (value) = error_mark_node;\n+\t      DECL_ASSEMBLER_NAME (value) = name;\n+\t    }\n+\t  pending_statics = perm_tree_cons (NULL_TREE, value, pending_statics);\n+\n+\t  /* Static consts need not be initialized in the class definition.  */\n+\t  if (init != NULL_TREE && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (value)))\n+\t    {\n+\t      static int explanation = 0;\n+\n+\t      error (\"initializer invalid for static member with constructor\");\n+\t      if (explanation++ == 0)\n+\t\terror (\"(you really want to initialize it separately)\");\n+\t      init = 0;\n+\t    }\n+\t  /* Force the compiler to know when an uninitialized static\n+\t     const member is being used.  */\n+\t  if (TYPE_READONLY (value) && init == 0)\n+\t    TREE_USED (value) = 1;\n+\t}\n+      DECL_INITIAL (value) = init;\n+      DECL_IN_AGGR_P (value) = 1;\n+\n+      finish_decl (value, init, asmspec_tree, 1);\n+      pushdecl_class_level (value);\n+      return value;\n+    }\n+  if (TREE_CODE (value) == FIELD_DECL)\n+    {\n+      if (asmspec)\n+\tDECL_ASSEMBLER_NAME (value) = get_identifier (asmspec);\n+      if (DECL_INITIAL (value) == error_mark_node)\n+\tinit = error_mark_node;\n+      finish_decl (value, init, asmspec_tree, 1);\n+      DECL_INITIAL (value) = init;\n+      DECL_IN_AGGR_P (value) = 1;\n+      return value;\n+    }\n+  if (TREE_CODE (value) == FUNCTION_DECL)\n+    {\n+      /* grokdeclarator defers setting this.  */\n+      TREE_PUBLIC (value) = 1;\n+      if (DECL_CHAIN (value) != NULL_TREE)\n+\t{\n+\t  /* Need a fresh node here so that we don't get circularity\n+\t     when we link these together.  */\n+\t  value = copy_node (value);\n+\t  /* When does this happen?  */\n+\t  my_friendly_assert (init == NULL_TREE, 193);\n+\t}\n+      finish_decl (value, init, asmspec_tree, 1);\n+\n+      /* Pass friends back this way.  */\n+      if (DECL_FRIEND_P (value))\n+\treturn void_type_node;\n+\n+      DECL_IN_AGGR_P (value) = 1;\n+      return value;\n+    }\n+  my_friendly_abort (21);\n+  /* NOTREACHED */\n+  return NULL_TREE;\n+}\n+\n+/* Like `grokfield', but for bitfields.\n+   WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.  */\n+\n+tree\n+grokbitfield (declarator, declspecs, width)\n+     tree declarator, declspecs, width;\n+{\n+  register tree value = grokdeclarator (declarator, declspecs, BITFIELD, 0, NULL_TREE);\n+\n+  if (! value) return NULL_TREE; /* friends went bad.  */\n+\n+  /* Pass friendly classes back.  */\n+  if (TREE_CODE (value) == VOID_TYPE)\n+    return void_type_node;\n+\n+  if (TREE_CODE (value) == TYPE_DECL)\n+    {\n+      cp_error (\"cannot declare `%D' to be a bitfield type\", value);\n+      return NULL_TREE;\n+    }\n+\n+  if (IS_SIGNATURE (current_class_type))\n+    {\n+      error (\"field declaration not allowed in signature\");\n+      return void_type_node;\n+    }\n+\n+  if (DECL_IN_AGGR_P (value))\n+    {\n+      cp_error (\"`%D' is already defined in the class %T\", value,\n+\t\t  DECL_CONTEXT (value));\n+      return void_type_node;\n+    }\n+\n+  GNU_xref_member (current_class_name, value);\n+\n+  if (TREE_STATIC (value))\n+    {\n+      cp_error (\"static member `%D' cannot be a bitfield\", value);\n+      return NULL_TREE;\n+    }\n+  finish_decl (value, NULL_TREE, NULL_TREE, 0);\n+\n+  if (width != error_mark_node)\n+    {\n+      /* detect invalid field size.  */\n+      if (TREE_CODE (width) == CONST_DECL)\n+\twidth = DECL_INITIAL (width);\n+      else if (TREE_READONLY_DECL_P (width))\n+\twidth = decl_constant_value (width);\n+      if (TREE_CODE (width) != INTEGER_CST)\n+\t{\n+\t  cp_error (\"structure field `%D' width not an integer constant\",\n+\t\t      value);\n+\t  DECL_INITIAL (value) = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  constant_expression_warning (width);\n+\t  DECL_INITIAL (value) = width;\n+\t  DECL_BIT_FIELD (value) = 1;\n+\t}\n+    }\n+\n+  DECL_IN_AGGR_P (value) = 1;\n+  return value;\n+}\n+\n+/* Like GROKFIELD, except that the declarator has been\n+   buried in DECLSPECS.  Find the declarator, and\n+   return something that looks like it came from\n+   GROKFIELD.  */\n+tree\n+groktypefield (declspecs, parmlist)\n+     tree declspecs;\n+     tree parmlist;\n+{\n+  tree spec = declspecs;\n+  tree prev = NULL_TREE;\n+\n+  tree type_id = NULL_TREE;\n+  tree quals = NULL_TREE;\n+  tree lengths = NULL_TREE;\n+  tree decl = NULL_TREE;\n+\n+  while (spec)\n+    {\n+      register tree id = TREE_VALUE (spec);\n+\n+      if (TREE_CODE (spec) != TREE_LIST)\n+\t/* Certain parse errors slip through.  For example,\n+\t   `int class ();' is not caught by the parser. Try\n+\t   weakly to recover here.  */\n+\treturn NULL_TREE;\n+\n+      if (TREE_CODE (id) == TYPE_DECL\n+\t  || (TREE_CODE (id) == IDENTIFIER_NODE && TREE_TYPE (id)))\n+\t{\n+\t  /* We have a constructor/destructor or\n+\t     conversion operator.  Use it.  */\n+\t  if (prev)\n+\t    TREE_CHAIN (prev) = TREE_CHAIN (spec);\n+\t  else\n+\t    declspecs = TREE_CHAIN (spec);\n+\n+\t  type_id = id;\n+\t  goto found;\n+\t}\n+      prev = spec;\n+      spec = TREE_CHAIN (spec);\n+    }\n+\n+  /* Nope, we have a conversion operator to a scalar type or something\n+     else, that includes things like constructor declarations for\n+     templates.  */\n+  spec = declspecs;\n+  while (spec)\n+    {\n+      tree id = TREE_VALUE (spec);\n+\n+      if (TREE_CODE (id) == IDENTIFIER_NODE)\n+\t{\n+\t  if (id == ridpointers[(int)RID_INT]\n+\t      || id == ridpointers[(int)RID_DOUBLE]\n+\t      || id == ridpointers[(int)RID_FLOAT]\n+\t      || id == ridpointers[(int)RID_WCHAR])\n+\t    {\n+\t      if (type_id)\n+\t\terror (\"extra `%s' ignored\",\n+\t\t       IDENTIFIER_POINTER (id));\n+\t      else\n+\t\ttype_id = id;\n+\t    }\n+\t  else if (id == ridpointers[(int)RID_LONG]\n+\t\t   || id == ridpointers[(int)RID_SHORT]\n+\t\t   || id == ridpointers[(int)RID_CHAR])\n+\t    {\n+\t      lengths = tree_cons (NULL_TREE, id, lengths);\n+\t    }\n+\t  else if (id == ridpointers[(int)RID_VOID])\n+\t    {\n+\t      if (type_id)\n+\t\terror (\"spurious `void' type ignored\");\n+\t      else\n+\t\terror (\"conversion to `void' type invalid\");\n+\t    }\n+\t  else if (id == ridpointers[(int)RID_AUTO]\n+\t\t   || id == ridpointers[(int)RID_REGISTER]\n+\t\t   || id == ridpointers[(int)RID_TYPEDEF]\n+\t\t   || id == ridpointers[(int)RID_CONST]\n+\t\t   || id == ridpointers[(int)RID_VOLATILE])\n+\t    {\n+\t      error (\"type specifier `%s' used invalidly\",\n+\t\t     IDENTIFIER_POINTER (id));\n+\t    }\n+\t  else if (id == ridpointers[(int)RID_FRIEND]\n+\t\t   || id == ridpointers[(int)RID_VIRTUAL]\n+\t\t   || id == ridpointers[(int)RID_INLINE]\n+\t\t   || id == ridpointers[(int)RID_UNSIGNED]\n+\t\t   || id == ridpointers[(int)RID_SIGNED]\n+\t\t   || id == ridpointers[(int)RID_STATIC]\n+\t\t   || id == ridpointers[(int)RID_EXTERN])\n+\t    {\n+\t      quals = tree_cons (NULL_TREE, id, quals);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Happens when we have a global typedef\n+\t\t and a class-local member function with\n+\t\t the same name.  */\n+\t      type_id = id;\n+\t      goto found;\n+\t    }\n+\t}\n+      else if (TREE_CODE (id) == RECORD_TYPE)\n+\t{\n+\t  type_id = TYPE_NAME (id);\n+\t  if (TREE_CODE (type_id) == TYPE_DECL)\n+\t    type_id = DECL_NAME (type_id);\n+\t  if (type_id == NULL_TREE)\n+\t    error (\"identifier for aggregate type conversion omitted\");\n+\t}\n+      else if (TREE_CODE_CLASS (TREE_CODE (id)) == 't')\n+\terror (\"`operator' missing on conversion operator or tag missing from type\");\n+      else\n+\tmy_friendly_abort (194);\n+      spec = TREE_CHAIN (spec);\n+    }\n+\n+  if (type_id)\n+    declspecs = chainon (lengths, quals);\n+  else if (lengths)\n+    {\n+      if (TREE_CHAIN (lengths))\n+\terror (\"multiple length specifiers\");\n+      type_id = ridpointers[(int)RID_INT];\n+      declspecs = chainon (lengths, quals);\n+    }\n+  else if (quals)\n+    {\n+      error (\"no type given, defaulting to `operator int ...'\");\n+      type_id = ridpointers[(int)RID_INT];\n+      declspecs = quals;\n+    }\n+  else\n+    return NULL_TREE;\n+\n+ found:\n+  decl = grokdeclarator (build_parse_node (CALL_EXPR, type_id, parmlist, NULL_TREE),\n+\t\t\t declspecs, FIELD, 0, NULL_TREE);\n+  if (decl == NULL_TREE)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_CHAIN (decl) != NULL_TREE)\n+    {\n+      /* Need a fresh node here so that we don't get circularity\n+\t when we link these together.  */\n+      decl = copy_node (decl);\n+    }\n+\n+  if (decl == void_type_node\n+      || (TREE_CODE (decl) == FUNCTION_DECL\n+\t  && TREE_CODE (TREE_TYPE (decl)) != METHOD_TYPE))\n+    /* bunch of friends.  */\n+    return decl;\n+\n+  if (DECL_IN_AGGR_P (decl))\n+    {\n+      cp_error (\"`%D' already defined in the class \", decl);\n+      return void_type_node;\n+    }\n+\n+  finish_decl (decl, NULL_TREE, NULL_TREE, 0);\n+\n+  /* If this declaration is common to another declaration\n+     complain about such redundancy, and return NULL_TREE\n+     so that we don't build a circular list.  */\n+  if (DECL_CHAIN (decl))\n+    {\n+      cp_error (\"function `%D' declared twice in class %T\", decl,\n+\t\t  DECL_CONTEXT (decl));\n+      return NULL_TREE;\n+    }\n+  DECL_IN_AGGR_P (decl) = 1;\n+  return decl;\n+}\n+\n+/* The precedence rules of this grammar (or any other deterministic LALR\n+   grammar, for that matter), place the CALL_EXPR somewhere where we\n+   may not want it.  The solution is to grab the first CALL_EXPR we see,\n+   pretend that that is the one that belongs to the parameter list of\n+   the type conversion function, and leave everything else alone.\n+   We pull it out in place.\n+\n+   CALL_REQUIRED is non-zero if we should complain if a CALL_EXPR\n+   does not appear in DECL.  */\n+tree\n+grokoptypename (decl, call_required)\n+     tree decl;\n+     int call_required;\n+{\n+  tree tmp, last;\n+\n+  my_friendly_assert (TREE_CODE (decl) == TYPE_EXPR, 195);\n+\n+  tmp = TREE_OPERAND (decl, 0);\n+  last = NULL_TREE;\n+\n+  while (tmp)\n+    {\n+      switch (TREE_CODE (tmp))\n+\t{\n+\tcase CALL_EXPR:\n+\t  {\n+\t    tree parms = TREE_OPERAND (tmp, 1);\n+\n+\t    if (last)\n+\t      TREE_OPERAND (last, 0) = TREE_OPERAND (tmp, 0);\n+\t    else\n+\t      TREE_OPERAND (decl, 0) = TREE_OPERAND (tmp, 0);\n+\n+\t    last = grokdeclarator (TREE_OPERAND (decl, 0),\n+\t\t\t\t   TREE_TYPE (decl),\n+\t\t\t\t   TYPENAME, 0, NULL_TREE);\n+\t    TREE_OPERAND (tmp, 0) = build_typename_overload (last);\n+\t    TREE_TYPE (TREE_OPERAND (tmp, 0)) = last;\n+\n+\t    if (parms\n+\t\t&& TREE_CODE (TREE_VALUE (parms)) == TREE_LIST)\n+\t      TREE_VALUE (parms)\n+\t\t= grokdeclarator (TREE_VALUE (TREE_VALUE (parms)),\n+\t\t\t\t  TREE_PURPOSE (TREE_VALUE (parms)),\n+\t\t\t\t  TYPENAME, 0, NULL_TREE);\n+\t    if (parms)\n+\t      {\n+\t\tif (TREE_VALUE (parms) != void_type_node)\n+\t\t  cp_error (\"`operator %T' requires empty parameter list\",\n+\t\t\t    last);\n+\t\telse\n+\t\t  /* Canonicalize parameter lists.  */\n+\t\t  TREE_OPERAND (tmp, 1) = void_list_node;\n+\t      }\n+\n+\t    return tmp;\n+\t  }\n+\n+\tcase INDIRECT_REF:\n+\tcase ADDR_EXPR:\n+\tcase ARRAY_REF:\n+\t  break;\n+\n+\tcase SCOPE_REF:\n+\t  /* This is legal when declaring a conversion to\n+\t     something of type pointer-to-member.  */\n+\t  if (TREE_CODE (TREE_OPERAND (tmp, 1)) == INDIRECT_REF)\n+\t    {\n+\t      tmp = TREE_OPERAND (tmp, 1);\n+\t    }\n+\t  else\n+\t    {\n+#if 0\n+\t      /* We may need to do this if grokdeclarator cannot handle this.  */\n+\t      error (\"type `member of class %s' invalid return type\",\n+\t\t     TYPE_NAME_STRING (TREE_OPERAND (tmp, 0)));\n+\t      TREE_OPERAND (tmp, 1) = build_parse_node (INDIRECT_REF, TREE_OPERAND (tmp, 1));\n+#endif\n+\t      tmp = TREE_OPERAND (tmp, 1);\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  my_friendly_abort (196);\n+\t}\n+      last = tmp;\n+      tmp = TREE_OPERAND (tmp, 0);\n+    }\n+\n+  last = grokdeclarator (TREE_OPERAND (decl, 0),\n+\t\t\t TREE_TYPE (decl),\n+\t\t\t TYPENAME, 0, NULL_TREE);\n+\n+  if (call_required)\n+    cp_error (\"`operator %T' construct requires parameter list\", last);\n+\n+  tmp = build_parse_node (CALL_EXPR, build_typename_overload (last),\n+\t\t\t  void_list_node, NULL_TREE);\n+  TREE_TYPE (TREE_OPERAND (tmp, 0)) = last;\n+  return tmp;\n+}\n+\n+/* When a function is declared with an initializer,\n+   do the right thing.  Currently, there are two possibilities:\n+\n+   class B\n+   {\n+    public:\n+     // initialization possibility #1.\n+     virtual void f () = 0;\n+     int g ();\n+   };\n+   \n+   class D1 : B\n+   {\n+    public:\n+     int d1;\n+     // error, no f ();\n+   };\n+   \n+   class D2 : B\n+   {\n+    public:\n+     int d2;\n+     void f ();\n+   };\n+   \n+   class D3 : B\n+   {\n+    public:\n+     int d3;\n+     // initialization possibility #2\n+     void f () = B::f;\n+   };\n+\n+*/\n+\n+static void\n+grok_function_init (decl, init)\n+     tree decl;\n+     tree init;\n+{\n+  /* An initializer for a function tells how this function should\n+     be inherited.  */\n+  tree type = TREE_TYPE (decl);\n+  extern tree abort_fndecl;\n+\n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n+    cp_error (\"initializer specified for non-member function `%D'\", decl);\n+  else if (DECL_VINDEX (decl) == NULL_TREE)\n+    cp_error (\"initializer specified for non-virtual method `%D'\", decl);\n+  else if (integer_zerop (init))\n+    {\n+      /* Mark this function as being \"defined\".  */\n+      DECL_INITIAL (decl) = error_mark_node;\n+      /* pure virtual destructors must be defined. */\n+      if (!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl)))\n+\t{\n+\t  /* Give this node rtl from `abort'.  */\n+\t  DECL_RTL (decl) = DECL_RTL (abort_fndecl);\n+\t}\n+      DECL_ABSTRACT_VIRTUAL_P (decl) = 1;\n+    }\n+  else if (TREE_CODE (init) == OFFSET_REF\n+\t   && TREE_OPERAND (init, 0) == NULL_TREE\n+\t   && TREE_CODE (TREE_TYPE (init)) == METHOD_TYPE)\n+    {\n+      tree basetype = DECL_CLASS_CONTEXT (init);\n+      tree basefn = TREE_OPERAND (init, 1);\n+      if (TREE_CODE (basefn) != FUNCTION_DECL)\n+\tcp_error (\"non-method initializer invalid for method `%D'\", decl);\n+      else if (! BINFO_OFFSET_ZEROP (TYPE_BINFO (DECL_CLASS_CONTEXT (basefn))))\n+\tsorry (\"base member function from other than first base class\");\n+      else\n+\t{\n+\t  tree binfo = get_binfo (basetype, TYPE_METHOD_BASETYPE (type), 1);\n+\t  if (binfo == error_mark_node)\n+\t    ;\n+\t  else if (binfo == 0)\n+\t    error_not_base_type (TYPE_METHOD_BASETYPE (TREE_TYPE (init)),\n+\t\t\t\t TYPE_METHOD_BASETYPE (type));\n+\t  else\n+\t    {\n+\t      /* Mark this function as being defined,\n+\t\t and give it new rtl.  */\n+\t      DECL_INITIAL (decl) = error_mark_node;\n+\t      DECL_RTL (decl) = DECL_RTL (basefn);\n+\t    }\n+\t}\n+    }\n+  else\n+    cp_error (\"invalid initializer for virtual method `%D'\", decl);\n+}\n+\f\n+/* When we get a declaration of the form\n+\n+   type cname::fname ...\n+\n+   the node for `cname::fname' gets built here in a special way.\n+   Namely, we push into `cname's scope.  When this declaration is\n+   processed, we pop back out.  */\n+tree\n+build_push_scope (cname, name)\n+     tree cname;\n+     tree name;\n+{\n+  extern int current_class_depth;\n+  tree ctype, rval;\n+  int is_ttp = 0;\n+\n+  if (cname == error_mark_node)\n+    return error_mark_node;\n+\n+  ctype = IDENTIFIER_TYPE_VALUE (cname);\n+\n+  if (TREE_CODE (ctype) == TEMPLATE_TYPE_PARM)\n+    is_ttp = 1;\n+  else if (ctype == NULL_TREE || ! IS_AGGR_TYPE (ctype))\n+    {\n+      cp_error (\"`%T' not defined as aggregate type\", cname);\n+      return name;\n+    }\n+  else if (IS_SIGNATURE (ctype))\n+    {\n+      error (\"cannot push into signature scope, scope resolution operator ignored\");\n+      return name;\n+    }\n+\n+  rval = build_parse_node (SCOPE_REF, cname, name);\n+\n+  /* Don't need to push the scope if we're already in it.\n+     We also don't need to push the scope for a ptr-to-member/method.  */\n+\n+  if (ctype == current_class_type || TREE_CODE (name) != IDENTIFIER_NODE\n+      || is_ttp)\n+    return rval;\n+\n+  /* We do need to push the scope in this case, since CTYPE helps\n+     determine subsequent intializers (i.e., Foo::Bar x = foo_enum_1;).  */\n+\n+  push_nested_class (ctype, 3);\n+  TREE_COMPLEXITY (rval) = current_class_depth;\n+  return rval;\n+}\n+\n+void cplus_decl_attributes (decl, attributes)\n+     tree decl, attributes;\n+{\n+  if (decl)\n+    decl_attributes (decl, attributes);\n+}\n+\f\n+/* CONSTRUCTOR_NAME:\n+   Return the name for the constructor (or destructor) for the\n+   specified class.  Argument can be RECORD_TYPE, TYPE_DECL, or\n+   IDENTIFIER_NODE.  When given a template, this routine doesn't\n+   lose the specialization.  */\n+tree\n+constructor_name_full (thing)\n+     tree thing;\n+{\n+  tree t;\n+  if (TREE_CODE (thing) == UNINSTANTIATED_P_TYPE)\n+    return DECL_NAME (UPT_TEMPLATE (thing));\n+  if (IS_AGGR_TYPE_CODE (TREE_CODE (thing)))\n+    {\n+      if (TYPE_WAS_ANONYMOUS (thing) && TYPE_HAS_CONSTRUCTOR (thing))\n+\tthing = DECL_NAME (TREE_VEC_ELT (TYPE_METHODS (thing), 0));\n+      else\n+\tthing = TYPE_NAME (thing);\n+    }\n+  if (TREE_CODE (thing) == TYPE_DECL\n+      || (TREE_CODE (thing) == TEMPLATE_DECL\n+\t  && DECL_TEMPLATE_IS_CLASS (thing)))\n+    thing = DECL_NAME (thing);\n+  my_friendly_assert (TREE_CODE (thing) == IDENTIFIER_NODE, 197);\n+  return thing;\n+}\n+\n+/* CONSTRUCTOR_NAME:\n+   Return the name for the constructor (or destructor) for the\n+   specified class.  Argument can be RECORD_TYPE, TYPE_DECL, or\n+   IDENTIFIER_NODE.  When given a template, return the plain\n+   unspecialized name.  */\n+tree\n+constructor_name (thing)\n+     tree thing;\n+{\n+  tree t;\n+  thing = constructor_name_full (thing);\n+  t = IDENTIFIER_TEMPLATE (thing);\n+  if (!t)\n+    return thing;\n+  t = TREE_PURPOSE (t);\n+  return DECL_NAME (t);\n+}\n+\f\n+/* Cache the value of this class's main virtual function table pointer\n+   in a register variable.  This will save one indirection if a\n+   more than one virtual function call is made this function.  */\n+void\n+setup_vtbl_ptr ()\n+{\n+  extern rtx base_init_insns;\n+\n+  if (base_init_insns == 0\n+      && DECL_CONSTRUCTOR_P (current_function_decl))\n+    emit_base_init (current_class_type, 0);\n+\n+#if 0\n+  /* This has something a little wrong with it.\n+\n+     On a sun4, code like:\n+\n+        be L6\n+        ld [%i0],%o1\n+\n+     is generated, when the below is used when -O4 is given.  The delay\n+     slot it filled with an instruction that is safe, when this isn't\n+     used, like in:\n+\n+        be L6\n+        sethi %hi(LC1),%o0\n+        ld [%i0],%o1\n+\n+     on code like:\n+\n+        struct A {\n+          virtual void print() { printf(\"xxx\"); }\n+          void f();\n+        };\n+\n+        void A::f() {\n+          if (this) {\n+            print();\n+          } else {\n+            printf(\"0\");\n+          }\n+        }\n+\n+     And that is why this is disabled for now. (mrs)\n+  */\n+\n+  if ((flag_this_is_variable & 1) == 0\n+      && optimize\n+      && current_class_type\n+      && CLASSTYPE_VSIZE (current_class_type)\n+      && ! DECL_STATIC_FUNCTION_P (current_function_decl))\n+    {\n+      tree vfield = build_vfield_ref (C_C_D, current_class_type);\n+      current_vtable_decl = CLASSTYPE_VTBL_PTR (current_class_type);\n+      DECL_RTL (current_vtable_decl) = 0;\n+      DECL_INITIAL (current_vtable_decl) = error_mark_node;\n+      /* Have to cast the initializer, since it may have come from a\n+\t more base class then we ascribe CURRENT_VTABLE_DECL to be.  */\n+      finish_decl (current_vtable_decl, convert_force (TREE_TYPE (current_vtable_decl), vfield), 0, 0);\n+      current_vtable_decl = build_indirect_ref (current_vtable_decl, NULL_PTR);\n+    }\n+  else\n+#endif\n+    current_vtable_decl = NULL_TREE;\n+}\n+\n+/* Record the existence of an addressable inline function.  */\n+void\n+mark_inline_for_output (decl)\n+     tree decl;\n+{\n+  if (DECL_PENDING_INLINE_INFO (decl) != 0\n+      && ! DECL_PENDING_INLINE_INFO (decl)->deja_vu)\n+    {\n+      struct pending_inline *t = pending_inlines;\n+      my_friendly_assert (DECL_SAVED_INSNS (decl) == 0, 198);\n+      while (t)\n+\t{\n+\t  if (t == DECL_PENDING_INLINE_INFO (decl))\n+\t    break;\n+\t  t = t->next;\n+\t}\n+      if (t == 0)\n+\t{\n+\t  t = DECL_PENDING_INLINE_INFO (decl);\n+\t  t->next = pending_inlines;\n+\t  pending_inlines = t;\n+\t}\n+      DECL_PENDING_INLINE_INFO (decl) = 0;\n+    }\n+  pending_addressable_inlines = perm_tree_cons (NULL_TREE, decl,\n+\t\t\t\t\t\tpending_addressable_inlines);\n+}\n+\n+void\n+clear_temp_name ()\n+{\n+  temp_name_counter = 0;\n+}\n+\n+/* Hand off a unique name which can be used for variable we don't really\n+   want to know about anyway, for example, the anonymous variables which\n+   are needed to make references work.  Declare this thing so we can use it.\n+   The variable created will be of type TYPE.\n+\n+   STATICP is nonzero if this variable should be static.  */\n+\n+tree\n+get_temp_name (type, staticp)\n+     tree type;\n+     int staticp;\n+{\n+  char buf[sizeof (AUTO_TEMP_FORMAT) + 20];\n+  tree decl;\n+  int toplev = global_bindings_p ();\n+\n+  push_obstacks_nochange ();\n+  if (toplev || staticp)\n+    {\n+      end_temporary_allocation ();\n+      sprintf (buf, AUTO_TEMP_FORMAT, global_temp_name_counter++);\n+      decl = pushdecl_top_level (build_decl (VAR_DECL, get_identifier (buf), type));\n+    }\n+  else\n+    {\n+      sprintf (buf, AUTO_TEMP_FORMAT, temp_name_counter++);\n+      decl = pushdecl (build_decl (VAR_DECL, get_identifier (buf), type));\n+    }\n+  TREE_USED (decl) = 1;\n+  TREE_STATIC (decl) = staticp;\n+\n+  /* If this is a local variable, then lay out its rtl now.\n+     Otherwise, callers of this function are responsible for dealing\n+     with this variable's rtl.  */\n+  if (! toplev)\n+    {\n+      expand_decl (decl);\n+      expand_decl_init (decl);\n+    }\n+  pop_obstacks ();\n+\n+  return decl;\n+}\n+\n+/* Get a variable which we can use for multiple assignments.\n+   It is not entered into current_binding_level, because\n+   that breaks things when it comes time to do final cleanups\n+   (which take place \"outside\" the binding contour of the function).  */\n+tree\n+get_temp_regvar (type, init)\n+     tree type, init;\n+{\n+  static char buf[sizeof (AUTO_TEMP_FORMAT) + 20] = { '_' };\n+  tree decl;\n+\n+  sprintf (buf+1, AUTO_TEMP_FORMAT, temp_name_counter++);\n+  decl = build_decl (VAR_DECL, get_identifier (buf), type);\n+  TREE_USED (decl) = 1;\n+  DECL_REGISTER (decl) = 1;\n+\n+  if (init)\n+    store_init_value (decl, init);\n+\n+  /* We can expand these without fear, since they cannot need\n+     constructors or destructors.  */\n+  expand_decl (decl);\n+  expand_decl_init (decl);\n+\n+  if (type_needs_gc_entry (type))\n+    DECL_GC_OFFSET (decl) = size_int (++current_function_obstack_index);\n+\n+  return decl;\n+}\n+\n+/* Make the macro TEMP_NAME_P available to units which do not\n+   include c-tree.h.  */\n+int\n+temp_name_p (decl)\n+     tree decl;\n+{\n+  return TEMP_NAME_P (decl);\n+}\n+\n+/* Finish off the processing of a UNION_TYPE structure.\n+   If there are static members, then all members are\n+   static, and must be laid out together.  If the\n+   union is an anonymous union, we arrange for that\n+   as well.  PUBLIC_P is nonzero if this union is\n+   not declared static.  */\n+void\n+finish_anon_union (anon_union_decl)\n+     tree anon_union_decl;\n+{\n+  tree type = TREE_TYPE (anon_union_decl);\n+  tree field, main_decl = NULL_TREE;\n+  tree elems = NULL_TREE;\n+  int public_p = TREE_PUBLIC (anon_union_decl);\n+  int static_p = TREE_STATIC (anon_union_decl);\n+  int external_p = DECL_EXTERNAL (anon_union_decl);\n+\n+  if ((field = TYPE_FIELDS (type)) == NULL_TREE)\n+    return;\n+\n+  if (public_p)\n+    {\n+      error (\"global anonymous unions must be declared static\");\n+      return;\n+    }\n+\n+  while (field)\n+    {\n+      tree decl = build_decl (VAR_DECL, DECL_NAME (field), TREE_TYPE (field));\n+      /* tell `pushdecl' that this is not tentative.  */\n+      DECL_INITIAL (decl) = error_mark_node;\n+      TREE_PUBLIC (decl) = public_p;\n+      TREE_STATIC (decl) = static_p;\n+      DECL_EXTERNAL (decl) = external_p;\n+      decl = pushdecl (decl);\n+\n+      /* Only write out one anon union element--choose the one that\n+\t can hold them all.  */\n+      if (main_decl == NULL_TREE\n+\t  && simple_cst_equal (DECL_SIZE (decl), DECL_SIZE (anon_union_decl)))\n+\t{\n+\t  main_decl = decl;\n+\t}\n+      else\n+\t{\n+\t  /* ??? This causes there to be no debug info written out\n+\t     about this decl.  */\n+\t  TREE_ASM_WRITTEN (decl) = 1;\n+\t}\n+\n+      DECL_INITIAL (decl) = NULL_TREE;\n+      /* If there's a cleanup to do, it belongs in the\n+\t TREE_PURPOSE of the following TREE_LIST.  */\n+      elems = tree_cons (NULL_TREE, decl, elems);\n+      TREE_TYPE (elems) = type;\n+      field = TREE_CHAIN (field);\n+    }\n+  if (static_p)\n+    {\n+      make_decl_rtl (main_decl, 0, global_bindings_p ());\n+      DECL_RTL (anon_union_decl) = DECL_RTL (main_decl);\n+    }\n+\n+  /* The following call assumes that there are never any cleanups\n+     for anonymous unions--a reasonable assumption.  */\n+  expand_anon_union_decl (anon_union_decl, NULL_TREE, elems);\n+\n+  if (flag_cadillac)\n+    cadillac_finish_anon_union (anon_union_decl);\n+}\n+\n+/* Finish and output a table which is generated by the compiler.\n+   NAME is the name to give the table.\n+   TYPE is the type of the table entry.\n+   INIT is all the elements in the table.\n+   PUBLICP is non-zero if this table should be given external access.  */\n+tree\n+finish_table (name, type, init, publicp)\n+     tree name, type, init;\n+     int publicp;\n+{\n+  tree itype, atype, decl;\n+  static tree empty_table;\n+  int is_empty = 0;\n+  tree asmspec;\n+\n+  itype = build_index_type (size_int (list_length (init) - 1));\n+  atype = build_cplus_array_type (type, itype);\n+  layout_type (atype);\n+\n+  if (TREE_VALUE (init) == integer_zero_node\n+      && TREE_CHAIN (init) == NULL_TREE)\n+    {\n+      if (empty_table == NULL_TREE)\n+\t{\n+\t  empty_table = get_temp_name (atype, 1);\n+\t  init = build (CONSTRUCTOR, atype, NULL_TREE, init);\n+\t  TREE_CONSTANT (init) = 1;\n+\t  TREE_STATIC (init) = 1;\n+\t  DECL_INITIAL (empty_table) = init;\n+\t  asmspec = build_string (IDENTIFIER_LENGTH (DECL_NAME (empty_table)),\n+\t\t\t\t  IDENTIFIER_POINTER (DECL_NAME (empty_table)));\n+\t  finish_decl (empty_table, init, asmspec, 0);\n+\t}\n+      is_empty = 1;\n+    }\n+\n+  if (name == NULL_TREE)\n+    {\n+      if (is_empty)\n+\treturn empty_table;\n+      decl = get_temp_name (atype, 1);\n+    }\n+  else\n+    {\n+      decl = build_decl (VAR_DECL, name, atype);\n+      decl = pushdecl (decl);\n+      TREE_STATIC (decl) = 1;\n+    }\n+\n+  if (is_empty == 0)\n+    {\n+      TREE_PUBLIC (decl) = publicp;\n+      init = build (CONSTRUCTOR, atype, NULL_TREE, init);\n+      TREE_CONSTANT (init) = 1;\n+      TREE_STATIC (init) = 1;\n+      DECL_INITIAL (decl) = init;\n+      asmspec = build_string (IDENTIFIER_LENGTH (DECL_NAME (decl)),\n+\t\t\t      IDENTIFIER_POINTER (DECL_NAME (decl)));\n+    }\n+  else\n+    {\n+      /* This will cause DECL to point to EMPTY_TABLE in rtl-land.  */\n+      DECL_EXTERNAL (decl) = 1;\n+      TREE_STATIC (decl) = 0;\n+      init = 0;\n+      asmspec = build_string (IDENTIFIER_LENGTH (DECL_NAME (empty_table)),\n+\t\t\t      IDENTIFIER_POINTER (DECL_NAME (empty_table)));\n+    }\n+\n+  finish_decl (decl, init, asmspec, 0);\n+  return decl;\n+}\n+\n+/* Finish processing a builtin type TYPE.  It's name is NAME,\n+   its fields are in the array FIELDS.  LEN is the number of elements\n+   in FIELDS minus one, or put another way, it is the maximum subscript\n+   used in FIELDS.\n+\n+   It is given the same alignment as ALIGN_TYPE.  */\n+void\n+finish_builtin_type (type, name, fields, len, align_type)\n+     tree type;\n+     char *name;\n+     tree fields[];\n+     int len;\n+     tree align_type;\n+{\n+  register int i;\n+\n+  TYPE_FIELDS (type) = fields[0];\n+  for (i = 0; i < len; i++)\n+    {\n+      layout_type (TREE_TYPE (fields[i]));\n+      DECL_FIELD_CONTEXT (fields[i]) = type;\n+      TREE_CHAIN (fields[i]) = fields[i+1];\n+    }\n+  DECL_FIELD_CONTEXT (fields[i]) = type;\n+  DECL_CLASS_CONTEXT (fields[i]) = type;\n+  TYPE_ALIGN (type) = TYPE_ALIGN (align_type);\n+  layout_type (type);\n+#if 0 /* not yet, should get fixed properly later */\n+  TYPE_NAME (type) = make_type_decl (get_identifier (name), type);\n+#else\n+  TYPE_NAME (type) = build_decl (TYPE_DECL, get_identifier (name), type);\n+#endif\n+  layout_decl (TYPE_NAME (type), 0);\n+}\n+\f\n+/* Auxiliary functions to make type signatures for\n+   `operator new' and `operator delete' correspond to\n+   what compiler will be expecting.  */\n+\n+extern tree sizetype;\n+\n+tree\n+coerce_new_type (type)\n+     tree type;\n+{\n+  int e1 = 0, e2 = 0;\n+\n+  if (TREE_CODE (type) == METHOD_TYPE)\n+    type = build_function_type (TREE_TYPE (type), TREE_CHAIN (TYPE_ARG_TYPES (type)));\n+  if (TREE_TYPE (type) != ptr_type_node)\n+    e1 = 1, error (\"`operator new' must return type `void *'\");\n+\n+  /* Technically the type must be `size_t', but we may not know\n+     what that is.  */\n+  if (TYPE_ARG_TYPES (type) == NULL_TREE)\n+    e1 = 1, error (\"`operator new' takes type `size_t' parameter\");\n+  else if (TREE_CODE (TREE_VALUE (TYPE_ARG_TYPES (type))) != INTEGER_TYPE\n+\t   || TYPE_PRECISION (TREE_VALUE (TYPE_ARG_TYPES (type))) != TYPE_PRECISION (sizetype))\n+    e2 = 1, error (\"`operator new' takes type `size_t' as first parameter\");\n+  if (e2)\n+    type = build_function_type (ptr_type_node, tree_cons (NULL_TREE, sizetype, TREE_CHAIN (TYPE_ARG_TYPES (type))));\n+  else if (e1)\n+    type = build_function_type (ptr_type_node, TYPE_ARG_TYPES (type));\n+  return type;\n+}\n+\n+tree\n+coerce_delete_type (type)\n+     tree type;\n+{\n+  int e1 = 0, e2 = 0, e3 = 0;\n+  tree arg_types = TYPE_ARG_TYPES (type);\n+\n+  if (TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      type = build_function_type (TREE_TYPE (type), TREE_CHAIN (arg_types));\n+      arg_types = TREE_CHAIN (arg_types);\n+    }\n+  if (TREE_TYPE (type) != void_type_node)\n+    e1 = 1, error (\"`operator delete' must return type `void'\");\n+  if (arg_types == NULL_TREE\n+      || TREE_VALUE (arg_types) != ptr_type_node)\n+    e2 = 1, error (\"`operator delete' takes type `void *' as first parameter\");\n+\n+  if (arg_types\n+      && TREE_CHAIN (arg_types)\n+      && TREE_CHAIN (arg_types) != void_list_node)\n+    {\n+      /* Again, technically this argument must be `size_t', but again\n+\t we may not know what that is.  */\n+      tree t2 = TREE_VALUE (TREE_CHAIN (arg_types));\n+      if (TREE_CODE (t2) != INTEGER_TYPE\n+\t  || TYPE_PRECISION (t2) != TYPE_PRECISION (sizetype))\n+\te3 = 1, error (\"second argument to `operator delete' must be of type `size_t'\");\n+      else if (TREE_CHAIN (TREE_CHAIN (arg_types)) != void_list_node)\n+\t{\n+\t  e3 = 1;\n+\t  if (TREE_CHAIN (TREE_CHAIN (arg_types)))\n+\t    error (\"too many arguments in declaration of `operator delete'\");\n+\t  else\n+\t    error (\"`...' invalid in specification of `operator delete'\");\n+\t}\n+    }\n+  if (e3)\n+    arg_types = tree_cons (NULL_TREE, ptr_type_node, build_tree_list (NULL_TREE, sizetype));\n+  else if (e3 |= e2)\n+    {\n+      if (arg_types == NULL_TREE)\n+\targ_types = void_list_node;\n+      else\n+\targ_types = tree_cons (NULL_TREE, ptr_type_node, TREE_CHAIN (arg_types));\n+    }\n+  else e3 |= e1;\n+\n+  if (e3)\n+    type = build_function_type (void_type_node, arg_types);\n+\n+  return type;\n+}\n+\f\n+static void\n+write_vtable_entries (decl)\n+     tree decl;\n+{\n+  tree entries = TREE_CHAIN (CONSTRUCTOR_ELTS (DECL_INITIAL (decl)));\n+\n+  if (flag_dossier)\n+    entries = TREE_CHAIN (entries);\n+\n+  for (; entries; entries = TREE_CHAIN (entries))\n+    {\n+      tree fnaddr = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (entries));\n+      tree fn = TREE_OPERAND (fnaddr, 0);\n+      if (! DECL_EXTERNAL (fn) && ! TREE_ASM_WRITTEN (fn)\n+\t  && DECL_SAVED_INSNS (fn))\n+\t{\n+\t  if (TREE_PUBLIC (DECL_CLASS_CONTEXT (fn)))\n+\t    TREE_PUBLIC (fn) = 1;\n+\t  TREE_ADDRESSABLE (fn) = 1;\n+\t  temporary_allocation ();\n+\t  output_inline_function (fn);\n+\t  permanent_allocation ();\n+\t}\n+      else\n+\tassemble_external (fn);\n+    }\n+}\n+\n+/* Note even though prev is never used in here, walk_vtables\n+   expects this to have two arguments, so concede.  */\n+static void\n+finish_vtable_typedecl (prev, vars)\n+     tree prev, vars;\n+{\n+  tree decl = TYPE_BINFO_VTABLE (TREE_TYPE (vars));\n+\n+  /* If we are controlled by `+e2', obey.  */\n+  if (write_virtuals == 2)\n+    {\n+      tree binfo = value_member (DECL_NAME (vars), pending_vtables);\n+      if (binfo)\n+\tTREE_PURPOSE (binfo) = void_type_node;\n+      else\n+\tdecl = NULL_TREE;\n+    }\n+  /* If this type has inline virtual functions, then\n+     write those functions out now.  */\n+  if (decl && write_virtuals >= 0\n+      && ! DECL_EXTERNAL (decl) && (TREE_PUBLIC (decl) || TREE_USED (decl)))\n+    write_vtable_entries (decl);\n+}\n+\n+static void\n+finish_vtable_vardecl (prev, vars)\n+     tree prev, vars;\n+{\n+  if (write_virtuals >= 0\n+      && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars)))\n+    {\n+      extern tree the_null_vtable_entry;\n+\n+      /* Stuff this virtual function table's size into\n+\t `pfn' slot of `the_null_vtable_entry'.  */\n+      tree nelts = array_type_nelts (TREE_TYPE (vars));\n+      SET_FNADDR_FROM_VTABLE_ENTRY (the_null_vtable_entry, nelts);\n+      /* Kick out the dossier before writing out the vtable.  */\n+      if (flag_dossier)\n+\trest_of_decl_compilation (TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (TREE_CHAIN (CONSTRUCTOR_ELTS (DECL_INITIAL (vars))))), 0), 0, 1, 1);\n+\n+      /* Write it out.  */\n+      write_vtable_entries (vars);\n+      if (TREE_TYPE (DECL_INITIAL (vars)) == 0)\n+\tstore_init_value (vars, DECL_INITIAL (vars));\n+\n+#ifdef DWARF_DEBUGGING_INFO\n+      if (write_symbols == DWARF_DEBUG)\n+\t{\n+\t  /* Mark the VAR_DECL node representing the vtable itself as a\n+\t     \"gratuitous\" one, thereby forcing dwarfout.c to ignore it.\n+\t     It is rather important that such things be ignored because\n+\t     any effort to actually generate DWARF for them will run\n+\t     into trouble when/if we encounter code like:\n+\n+\t\t#pragma interface\n+\t\tstruct S { virtual void member (); };\n+\n+\t      because the artificial declaration of the vtable itself (as\n+\t      manufactured by the g++ front end) will say that the vtable\n+\t      is a static member of `S' but only *after* the debug output\n+\t      for the definition of `S' has already been output.  This causes\n+\t      grief because the DWARF entry for the definition of the vtable\n+\t      will try to refer back to an earlier *declaration* of the\n+\t      vtable as a static member of `S' and there won't be one.\n+\t      We might be able to arrange to have the \"vtable static member\"\n+\t      attached to the member list for `S' before the debug info for\n+\t      `S' get written (which would solve the problem) but that would\n+\t      require more intrusive changes to the g++ front end.  */\n+\n+\t  DECL_IGNORED_P (vars) = 1;\n+\t}\n+#endif /* DWARF_DEBUGGING_INFO */\n+\n+      rest_of_decl_compilation (vars, 0, 1, 1);\n+    }\n+  /* We know that PREV must be non-zero here.  */\n+  TREE_CHAIN (prev) = TREE_CHAIN (vars);\n+}\n+\n+void\n+walk_vtables (typedecl_fn, vardecl_fn)\n+     register void (*typedecl_fn)();\n+     register void (*vardecl_fn)();\n+{\n+  tree prev, vars;\n+\n+  for (prev = 0, vars = getdecls (); vars; vars = TREE_CHAIN (vars))\n+    {\n+      register tree type = TREE_TYPE (vars);\n+\n+      if (TREE_CODE (vars) == TYPE_DECL\n+\t  && type != error_mark_node\n+\t  && TYPE_LANG_SPECIFIC (type)\n+\t  && CLASSTYPE_VSIZE (type))\n+\t{\n+\t  if (typedecl_fn) (*typedecl_fn) (prev, vars);\n+\t}\n+      else if (TREE_CODE (vars) == VAR_DECL && DECL_VIRTUAL_P (vars))\n+\t{\n+\t  if (vardecl_fn) (*vardecl_fn) (prev, vars);\n+\t}\n+      else\n+\tprev = vars;\n+    }\n+}\n+\n+extern int parse_time, varconst_time;\n+\n+#define TIMEVAR(VAR, BODY)    \\\n+do { int otime = get_run_time (); BODY; VAR += get_run_time () - otime; } while (0)\n+\n+/* This routine is called from the last rule in yyparse ().\n+   Its job is to create all the code needed to initialize and\n+   destroy the global aggregates.  We do the destruction\n+   first, since that way we only need to reverse the decls once.  */\n+\n+void\n+finish_file ()\n+{\n+  extern int lineno;\n+  int start_time, this_time;\n+\n+  tree fnname;\n+  tree vars = static_aggregates;\n+  int needs_cleaning = 0, needs_messing_up = 0;\n+\n+  if (flag_detailed_statistics)\n+    dump_tree_statistics ();\n+\n+  /* Bad parse errors.  Just forget about it.  */\n+  if (! global_bindings_p () || current_class_type)\n+    return;\n+\n+  start_time = get_run_time ();\n+\n+  /* Push into C language context, because that's all\n+     we'll need here.  */\n+  push_lang_context (lang_name_c);\n+\n+  /* Set up the name of the file-level functions we may need.  */\n+  /* Use a global object (which is already required to be unique over\n+     the program) rather than the file name (which imposes extra\n+     constraints).  -- Raeburn@MIT.EDU, 10 Jan 1990.  */\n+\n+  /* See if we really need the hassle.  */\n+  while (vars && needs_cleaning == 0)\n+    {\n+      tree decl = TREE_VALUE (vars);\n+      tree type = TREE_TYPE (decl);\n+      if (TYPE_NEEDS_DESTRUCTOR (type))\n+\t{\n+\t  needs_cleaning = 1;\n+\t  needs_messing_up = 1;\n+\t  break;\n+\t}\n+      else\n+\tneeds_messing_up |= TYPE_NEEDS_CONSTRUCTING (type);\n+      vars = TREE_CHAIN (vars);\n+    }\n+  if (needs_cleaning == 0)\n+    goto mess_up;\n+\n+  /* Otherwise, GDB can get confused, because in only knows\n+     about source for LINENO-1 lines.  */\n+  lineno -= 1;\n+\n+  fnname = get_file_function_name ('D');\n+  start_function (void_list_node, build_parse_node (CALL_EXPR, fnname, void_list_node, NULL_TREE), 0, 0);\n+  fnname = DECL_ASSEMBLER_NAME (current_function_decl);\n+  store_parm_decls ();\n+\n+  pushlevel (0);\n+  clear_last_expr ();\n+  push_momentary ();\n+  expand_start_bindings (0);\n+\n+  /* These must be done in backward order to destroy,\n+     in which they happen to be!  */\n+  while (vars)\n+    {\n+      tree decl = TREE_VALUE (vars);\n+      tree type = TREE_TYPE (decl);\n+      tree temp = TREE_PURPOSE (vars);\n+\n+      if (TYPE_NEEDS_DESTRUCTOR (type))\n+\t{\n+\t  if (TREE_STATIC (vars))\n+\t    expand_start_cond (build_binary_op (NE_EXPR, temp, integer_zero_node, 1), 0);\n+\t  if (TREE_CODE (type) == ARRAY_TYPE)\n+\t    temp = decl;\n+\t  else\n+\t    {\n+\t      mark_addressable (decl);\n+\t      temp = build1 (ADDR_EXPR, TYPE_POINTER_TO (type), decl);\n+\t    }\n+\t  temp = build_delete (TREE_TYPE (temp), temp,\n+\t\t\t       integer_two_node, LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n+\t  expand_expr_stmt (temp);\n+\n+\t  if (TREE_STATIC (vars))\n+\t    expand_end_cond ();\n+\t}\n+      vars = TREE_CHAIN (vars);\n+    }\n+\n+  expand_end_bindings (getdecls(), 1, 0);\n+  poplevel (1, 0, 0);\n+  pop_momentary ();\n+\n+  finish_function (lineno, 0);\n+\n+  assemble_destructor (IDENTIFIER_POINTER (fnname));\n+\n+  /* if it needed cleaning, then it will need messing up: drop through  */\n+\n+ mess_up:\n+  /* Must do this while we think we are at the top level.  */\n+  vars = nreverse (static_aggregates);\n+  if (vars != NULL_TREE)\n+    {\n+      fnname = get_file_function_name ('I');\n+      start_function (void_list_node, build_parse_node (CALL_EXPR, fnname, void_list_node, NULL_TREE), 0, 0);\n+      fnname = DECL_ASSEMBLER_NAME (current_function_decl);\n+      store_parm_decls ();\n+\n+      pushlevel (0);\n+      clear_last_expr ();\n+      push_momentary ();\n+      expand_start_bindings (0);\n+\n+      while (vars)\n+\t{\n+\t  tree decl = TREE_VALUE (vars);\n+\t  tree init = TREE_PURPOSE (vars);\n+\n+\t  /* If this was a static attribute within some function's scope,\n+\t     then don't initialize it here.  Also, don't bother\n+\t     with initializers that contain errors.  */\n+\t  if (TREE_STATIC (vars)\n+\t      || (init && TREE_CODE (init) == TREE_LIST\n+\t\t  && value_member (error_mark_node, init)))\n+\t    {\n+\t      vars = TREE_CHAIN (vars);\n+\t      continue;\n+\t    }\n+\n+\t  if (TREE_CODE (decl) == VAR_DECL)\n+\t    {\n+\t      /* Set these global variables so that GDB at least puts\n+\t\t us near the declaration which required the initialization.  */\n+\t      input_filename = DECL_SOURCE_FILE (decl);\n+\t      lineno = DECL_SOURCE_LINE (decl);\n+\t      emit_note (input_filename, lineno);\n+\n+\t      if (init)\n+\t\t{\n+\t\t  if (TREE_CODE (init) == VAR_DECL)\n+\t\t    {\n+\t\t      /* This behavior results when there are\n+\t\t\t multiple declarations of an aggregate,\n+\t\t\t the last of which defines it.  */\n+\t\t      if (DECL_RTL (init) == DECL_RTL (decl))\n+\t\t\t{\n+\t\t\t  my_friendly_assert (DECL_INITIAL (decl) == error_mark_node\n+\t\t\t\t  || (TREE_CODE (DECL_INITIAL (decl)) == CONSTRUCTOR\n+\t\t\t\t      && CONSTRUCTOR_ELTS (DECL_INITIAL (decl)) == NULL_TREE),\n+\t\t\t\t\t      199);\n+\t\t\t  init = DECL_INITIAL (init);\n+\t\t\t  if (TREE_CODE (init) == CONSTRUCTOR\n+\t\t\t      && CONSTRUCTOR_ELTS (init) == NULL_TREE)\n+\t\t\t    init = NULL_TREE;\n+\t\t\t}\n+#if 0\n+\t\t      else if (TREE_TYPE (decl) == TREE_TYPE (init))\n+\t\t\t{\n+#if 1\n+\t\t\t  my_friendly_abort (200);\n+#else\n+\t\t\t  /* point to real decl's rtl anyway.  */\n+\t\t\t  DECL_RTL (init) = DECL_RTL (decl);\n+\t\t\t  my_friendly_assert (DECL_INITIAL (decl) == error_mark_node,\n+\t\t\t\t\t      201);\n+\t\t\t  init = DECL_INITIAL (init);\n+#endif\t\t\t\t/* 1 */\n+\t\t\t}\n+#endif\t\t\t\t/* 0 */\n+\t\t    }\n+\t\t}\n+\t      if (IS_AGGR_TYPE (TREE_TYPE (decl))\n+\t\t  || init == 0\n+\t\t  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+\t\t{\n+#if 0\n+\t\t  /* Set this up so is_friend() works properly on _GLOBAL_\n+                     fns.  */\n+\t\t  tree old_dcc = DECL_CLASS_CONTEXT (current_function_decl);\n+\t\t  if (old_dcc == NULL_TREE && IS_AGGR_TYPE (TREE_TYPE (decl)))\n+\t\t    DECL_CLASS_CONTEXT (current_function_decl) = TREE_TYPE (decl);\n+\t\t  expand_aggr_init (decl, init, 0);\n+\t\t  DECL_CLASS_CONTEXT (current_function_decl) = old_dcc;\n+#else\n+\t\t  expand_aggr_init (decl, init, 0);\n+#endif\n+\t\t}\n+\t      else if (TREE_CODE (init) == TREE_VEC)\n+\t\t{\n+\t\t  expand_expr (expand_vec_init (decl, TREE_VEC_ELT (init, 0),\n+\t\t\t\t\t\tTREE_VEC_ELT (init, 1),\n+\t\t\t\t\t\tTREE_VEC_ELT (init, 2), 0),\n+\t\t\t       const0_rtx, VOIDmode, 0);\n+\t\t  free_temp_slots ();\n+\t\t}\n+\t      else\n+\t\texpand_assignment (decl, init, 0, 0);\n+\t    }\n+\t  else if (TREE_CODE (decl) == SAVE_EXPR)\n+\t    {\n+\t      if (! PARM_DECL_EXPR (decl))\n+\t\t{\n+\t\t  /* a `new' expression at top level.  */\n+\t\t  expand_expr (decl, const0_rtx, VOIDmode, 0);\n+\t\t  free_temp_slots ();\n+\t\t  expand_aggr_init (build_indirect_ref (decl, NULL_PTR), init, 0);\n+\t\t}\n+\t    }\n+\t  else if (decl == error_mark_node)\n+\t    ;\n+\t  else my_friendly_abort (22);\n+\t  vars = TREE_CHAIN (vars);\n+\t}\n+\n+      expand_end_bindings (getdecls(), 1, 0);\n+      poplevel (1, 0, 0);\n+      pop_momentary ();\n+\n+      finish_function (lineno, 0);\n+      assemble_constructor (IDENTIFIER_POINTER (fnname));\n+    }\n+\n+  /* Done with C language context needs.  */\n+  pop_lang_context ();\n+\n+  /* Now write out any static class variables (which may have since\n+     learned how to be initialized).  */\n+  while (pending_statics)\n+    {\n+      tree decl = TREE_VALUE (pending_statics);\n+      if (TREE_USED (decl) == 1\n+\t  || TREE_READONLY (decl) == 0\n+\t  || DECL_INITIAL (decl) == 0)\n+\trest_of_decl_compilation (decl, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)), 1, 1);\n+      pending_statics = TREE_CHAIN (pending_statics);\n+    }\n+\n+  this_time = get_run_time ();\n+  parse_time -= this_time - start_time;\n+  varconst_time += this_time - start_time;\n+\n+  /* Now write out inline functions which had their addresses taken\n+     and which were not declared virtual and which were not declared\n+     `extern inline'.  */\n+  while (pending_addressable_inlines)\n+    {\n+      tree decl = TREE_VALUE (pending_addressable_inlines);\n+      if (! TREE_ASM_WRITTEN (decl)\n+\t  && ! DECL_EXTERNAL (decl)\n+\t  && DECL_SAVED_INSNS (decl))\n+\t{\n+\t  temporary_allocation ();\n+\t  output_inline_function (decl);\n+\t  permanent_allocation ();\n+\t}\n+      pending_addressable_inlines = TREE_CHAIN (pending_addressable_inlines);\n+    }\n+\n+  start_time = get_run_time ();\n+\n+  /* Now delete from the chain of variables all virtual function tables.\n+     We output them all ourselves, because each will be treated specially.  */\n+\n+#if 1\n+  /* The reason for pushing garbage onto the global_binding_level is to\n+     ensure that we can slice out _DECLs which pertain to virtual function\n+     tables.  If the last thing pushed onto the global_binding_level was a\n+     virtual function table, then slicing it out would slice away all the\n+     decls (i.e., we lose the head of the chain).\n+\n+     There are several ways of getting the same effect, from changing the\n+     way that iterators over the chain treat the elements that pertain to\n+     virtual function tables, moving the implementation of this code to\n+     cp-decl.c (where we can manipulate global_binding_level directly),\n+     popping the garbage after pushing it and slicing away the vtable\n+     stuff, or just leaving it alone. */\n+\n+  /* Make last thing in global scope not be a virtual function table.  */\n+#if 0 /* not yet, should get fixed properly later */\n+  vars = make_type_decl (get_identifier (\" @%$#@!\"), integer_type_node);\n+#else\n+  vars = build_decl (TYPE_DECL, get_identifier (\" @%$#@!\"), integer_type_node);\n+#endif\n+  DECL_IGNORED_P (vars) = 1;\n+  DECL_SOURCE_LINE (vars) = 0;\n+  pushdecl (vars);\n+#endif\n+\n+  walk_vtables (finish_vtable_typedecl, finish_vtable_vardecl);\n+\n+  if (write_virtuals == 2)\n+    {\n+      /* Now complain about an virtual function tables promised\n+\t but not delivered.  */\n+      while (pending_vtables)\n+\t{\n+\t  if (TREE_PURPOSE (pending_vtables) == NULL_TREE)\n+\t    error (\"virtual function table for `%s' not defined\",\n+\t\t   IDENTIFIER_POINTER (TREE_VALUE (pending_vtables)));\n+\t  pending_vtables = TREE_CHAIN (pending_vtables);\n+\t}\n+    }\n+\n+  permanent_allocation ();\n+  this_time = get_run_time ();\n+  parse_time -= this_time - start_time;\n+  varconst_time += this_time - start_time;\n+\n+  if (flag_detailed_statistics)\n+    dump_time_statistics ();\n+}"}, {"sha": "21feb772b47382fe210f65d5e295131634f98375", "filename": "gcc/cp/errfn.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,217 @@\n+/* Provide a call-back mechanism for handling error output.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Contributed by Jason Merrill (jason@cygnus.com)\n+\n+   This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+   \n+#include \"config.h\"\n+#include \"tree.h\"\n+#include <ctype.h>\n+\n+/* cp_printer is the type of a function which converts an argument into\n+   a string for digestion by printf.  The cp_printer function should deal\n+   with all memory management; the functions in this file will not free\n+   the char*s returned.  See cp-error.c for an example use of this code.  */\n+\n+typedef char* cp_printer PROTO((HOST_WIDE_INT, int));\n+extern cp_printer * cp_printers[256];\n+\n+typedef void errorfn ();\t/* deliberately vague */\n+\n+extern char* cp_file_of PROTO((tree));\n+extern int   cp_line_of PROTO((tree));\n+\n+#define STRDUP(f) (ap = (char *) alloca (strlen (f) +1), strcpy (ap, (f)), ap)\n+\n+#define NARGS 3\n+#define arglist a1, a2, a3\n+#define arglist_dcl HOST_WIDE_INT a1, a2, a3;\n+#define ARGSINIT args[0] = a1; args[1] = a2; args[2] = a3;\n+#define ARGSLIST args[0], args[1], args[2]\n+\n+static void\n+cp_thing (errfn, atarg1, format, arglist)\n+     errorfn *errfn;\n+     int atarg1;\n+     char *format;\n+     arglist_dcl\n+{\n+  char *fmt;\n+  char *f;\n+  char *ap;\n+  int arg;\n+  HOST_WIDE_INT atarg = atarg1 ? a1 : 0;\n+  HOST_WIDE_INT args[NARGS];\n+  ARGSINIT\n+\n+  fmt = STRDUP(format);\n+  \n+  for (f = fmt, arg = 0; *f; ++f)\n+    {\n+      cp_printer * function;\n+      int alternate;\n+      int maybe_here;\n+      \n+      /* ignore text */\n+      if (*f != '%') continue;\n+\n+      ++f;\n+\n+      alternate = 0;\n+      maybe_here = 0;\n+\n+      /* ignore most flags */\n+      while (*f == ' ' || *f == '-' || *f == '+' || *f == '#')\n+\t{\n+\t  if (*f == '+')\n+\t    maybe_here = 1;\n+\t  else if (*f == '#')\n+\t    alternate = 1;\n+\t  ++f;\n+\t}\n+\n+      /* ignore field width */\n+      if (*f == '*')\n+\t{\n+\t  ++f;\n+\t  ++arg;\n+\t}\n+      else\n+\twhile (isdigit (*f))\n+\t  ++f;\n+\n+      /* ignore precision */\n+      if (*f == '.')\n+\t{\n+\t  ++f;\n+\t  if (*f == '*')\n+\t    {\n+\t      ++f;\n+\t      ++arg;\n+\t    }\n+\t  else\n+\t    while (isdigit (*f))\n+\t      ++f;\n+\t}\n+\n+      /* ignore \"long\" */\n+      if (*f == 'l')\n+\t++f;\n+\n+      function = cp_printers[*f];\n+\n+      if (function)\n+\t{\n+\t  char *p;\n+\n+\t  if (arg >= NARGS) abort ();\n+\t  \n+\t  if (maybe_here && atarg)\n+\t    atarg = args[arg];\n+\n+\t  /* Must use a temporary to avoid calling *function twice */\n+\t  p = (*function) (args[arg], alternate);\n+\t  args[arg] = (HOST_WIDE_INT) STRDUP(p);\n+\t  *f = 's';\n+\t}\n+\n+      ++arg;\t\t\t/* Assume valid format string */\n+\n+    }\n+\n+  if (atarg)\n+    {\n+      char *file = cp_file_of ((tree) atarg);\n+      int   line = cp_line_of ((tree) atarg);\n+      (*errfn) (file, line, fmt, ARGSLIST);\n+    }\n+  else\n+    (*errfn) (fmt, ARGSLIST);\n+\n+}\n+\n+void\n+cp_error (format, arglist)\n+     char *format;\n+     arglist_dcl\n+{\n+  extern errorfn error;\n+  cp_thing (error, 0, format, arglist);\n+}\n+\n+void\n+cp_warning (format, arglist)\n+     char *format;\n+     arglist_dcl\n+{\n+  extern errorfn warning;\n+  cp_thing (warning, 0, format, arglist);\n+}\n+\n+void\n+cp_pedwarn (format, arglist)\n+     char *format;\n+     arglist_dcl\n+{\n+  extern errorfn pedwarn;\n+  cp_thing (pedwarn, 0, format, arglist);\n+}\n+\n+void\n+cp_compiler_error (format, arglist)\n+     char *format;\n+     arglist_dcl\n+{\n+  extern errorfn compiler_error;\n+  cp_thing (compiler_error, 0, format, arglist);\n+}\n+\n+void\n+cp_sprintf (format, arglist)\n+     char *format;\n+     arglist_dcl\n+{\n+  extern errorfn sprintf;\n+  cp_thing (sprintf, 0, format, arglist);\n+}\n+\n+void\n+cp_error_at (format, arglist)\n+     char *format;\n+     arglist_dcl\n+{\n+  extern errorfn error_with_file_and_line;\n+  cp_thing (error_with_file_and_line, 1, format, arglist);\n+}\n+\n+void\n+cp_warning_at (format, arglist)\n+     char *format;\n+     arglist_dcl\n+{\n+  extern errorfn warning_with_file_and_line;\n+  cp_thing (warning_with_file_and_line, 1, format, arglist);\n+}\n+\n+void\n+cp_pedwarn_at (format, arglist)\n+     char *format;\n+     arglist_dcl\n+{\n+  extern errorfn pedwarn_with_file_and_line;\n+  cp_thing (pedwarn_with_file_and_line, 1, format, arglist);\n+}"}, {"sha": "75167fcdf4ed37cd117faf105af950f5e04c755f", "filename": "gcc/cp/error.c", "status": "added", "additions": 1339, "deletions": 0, "changes": 1339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,1339 @@\n+/* Call-backs for C++ error reporting.\n+   This code is non-reentrant.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"cp-tree.h\"\n+#include \"obstack.h\"\n+#include <ctype.h>\n+\n+typedef char* cp_printer ();\n+\n+#define A args_as_string\n+#define C code_as_string\n+#define D decl_as_string\n+#define E expr_as_string\n+#define L language_as_string\n+#define O op_as_string\n+#define P parm_as_string\n+#define T type_as_string\n+\n+#define _ (cp_printer *) 0\n+cp_printer * cp_printers[256] =\n+{ \n+/*0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */\n+  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x00 */\n+  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x10 */\n+  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x20 */\n+  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x30 */\n+  _, A, _, C, D, E, _, _, _, _, _, _, L, _, _, O, /* 0x40 */\n+  P, _, _, _, T, _, _, _, _, _, _, _, _, _, _, _, /* 0x50 */\n+  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x60 */\n+  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x70 */\n+};\n+#undef C\n+#undef D\n+#undef E\n+#undef L\n+#undef O\n+#undef P\n+#undef T\n+#undef _\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+/* Obstack where we build text strings for overloading, etc.  */\n+static struct obstack scratch_obstack;\n+static char *scratch_firstobj;\n+\n+# define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)\n+# define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))\n+# define OB_PUTC2(C1,C2)\t\\\n+  (obstack_1grow (&scratch_obstack, (C1)), obstack_1grow (&scratch_obstack, (C2)))\n+# define OB_PUTS(S) (obstack_grow (&scratch_obstack, (S), sizeof (S) - 1))\n+# define OB_PUTID(ID)  \\\n+  (obstack_grow (&scratch_obstack, IDENTIFIER_POINTER (ID),\t\\\n+\t\t IDENTIFIER_LENGTH (ID)))\n+# define OB_PUTCP(S) (obstack_grow (&scratch_obstack, (S), strlen (S)))\n+# define OB_FINISH() (obstack_1grow (&scratch_obstack, '\\0'))\n+# define OB_PUTI(CST) do { sprintf (digit_buffer, \"%d\", (CST)); \\\n+\t\t\t   OB_PUTCP (digit_buffer); } while (0)\n+\n+# define NEXT_CODE(t) (TREE_CODE (TREE_TYPE (t)))\n+\n+static void dump_type (), dump_decl (), dump_function_decl ();\n+static void dump_expr (), dump_unary_op (), dump_binary_op ();\n+static void dump_aggr_type (), dump_type_prefix (), dump_type_suffix ();\n+static void dump_function_name ();\n+\n+void\n+init_error ()\n+{\n+  gcc_obstack_init (&scratch_obstack);\n+  scratch_firstobj = (char *)obstack_alloc (&scratch_obstack, 0);\n+}\n+\n+/* Counter to help build parameter names in case they were omitted.  */\n+static int dummy_name;\n+\n+enum pad { none, before, after };\n+\n+static void\n+dump_readonly_or_volatile (t, p)\n+     tree t;\n+     enum pad p;\n+{\n+  if (TYPE_READONLY (t) || TYPE_VOLATILE (t))\n+    {\n+      if (p == before) OB_PUTC (' ');\n+      if (TYPE_READONLY (t))\n+\tOB_PUTS (\"const\");\n+      if (TYPE_VOLATILE (t))\n+\tOB_PUTS (\"volatile\");\n+      if (p == after) OB_PUTC (' ');\n+    }\n+}\n+\n+/* This must be large enough to hold any printed integer or floating-point\n+   value.  */\n+static char digit_buffer[128];\n+\n+/* Dump into the obstack a human-readable equivalent of TYPE. */\n+static void\n+dump_type (t, v)\n+     tree t;\n+     int v;\t\t\t/* verbose? */\n+{\n+  if (t == NULL_TREE)\n+    return;\n+  \n+  if (TYPE_PTRMEMFUNC_P (t))\n+    goto offset_type;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case ERROR_MARK:\n+      OB_PUTS (\"<error>\");\n+      break;\n+\n+    case UNKNOWN_TYPE:\n+      OB_PUTS (\"<unknown type>\");\n+      break;\n+\n+    case TREE_LIST:\n+      /* i.e. function taking no arguments */\n+      if (t != void_list_node)\n+\t{\n+\t  dump_type (TREE_VALUE (t), v);\n+\t  /* Can this happen other than for default arguments? */\n+\t  if (TREE_PURPOSE (t) && v)\n+\t    {\n+\t      OB_PUTS (\" = \");\n+\t      dump_expr (TREE_PURPOSE (t));\n+\t    }\n+\t  if (TREE_CHAIN (t))\n+\t    {\n+\t      if (TREE_CHAIN (t) != void_list_node)\n+\t\t{\n+\t\t  OB_PUTC2 (',', ' ');\n+\t\t  dump_type (TREE_CHAIN (t), v);\n+\t\t}\n+\t    }\n+\t  else OB_PUTS (\" ...\");\n+\t}\n+      break;\n+\n+    case IDENTIFIER_NODE:\n+      OB_PUTID (t);\n+      break;\n+\n+    case TREE_VEC:\n+      dump_type (BINFO_TYPE (t), v);\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      if (TYPE_LANG_SPECIFIC (t)\n+\t  && (IS_SIGNATURE_POINTER (t) || IS_SIGNATURE_REFERENCE (t)))\n+\t{\n+\t  if (TYPE_READONLY (t) | TYPE_VOLATILE (t))\n+\t    dump_readonly_or_volatile (t);\n+\t  dump_type (SIGNATURE_TYPE (t), v);\n+\t  if (IS_SIGNATURE_POINTER (t))\n+\t    OB_PUTC ('*');\n+\t  else\n+\t    OB_PUTC ('&');\n+\t}\n+      else\n+\tdump_aggr_type (t, v);\n+      break;\n+\n+    case TYPE_DECL:\n+      dump_readonly_or_volatile (t, after);\n+      OB_PUTID (DECL_NAME (t));\n+      break;\n+\n+    case INTEGER_TYPE:\n+      if (!TREE_UNSIGNED (TYPE_MAIN_VARIANT (t)) && TREE_UNSIGNED (t))\n+\tOB_PUTS (\"unsigned \");\n+      else if (TREE_UNSIGNED (TYPE_MAIN_VARIANT (t)) && !TREE_UNSIGNED (t))\n+\tOB_PUTS (\"signed \");\n+\n+      /* fall through.  */\n+    case REAL_TYPE:\n+    case VOID_TYPE:\n+      dump_readonly_or_volatile (t, after);\n+      OB_PUTID (TYPE_IDENTIFIER (t));\n+      break;\n+\n+    case TEMPLATE_TYPE_PARM:\n+      OB_PUTS (\"<template type parm \");\n+      OB_PUTID (TYPE_IDENTIFIER (t));\n+      OB_PUTC ('>');\n+      break;\n+\n+    case UNINSTANTIATED_P_TYPE:\n+      OB_PUTID (DECL_NAME (UPT_TEMPLATE (t)));\n+      OB_PUTS (\"<...>\");\n+      break;\n+\n+      /* This is not always necessary for pointers and such, but doing this\n+\t reduces code size.  */\n+    case ARRAY_TYPE:\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+    case OFFSET_TYPE:\n+    offset_type:\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+      dump_type_prefix (t, v);\n+      dump_type_suffix (t, v);\n+      break;\n+\n+    default:\n+      my_friendly_abort (68);\n+      \n+    }\n+}\n+\n+/* Print out a class declaration, in the form `class foo'. */\n+static void\n+dump_aggr_type (t, v)\n+     tree t;\n+     int v;\t\t\t/* verbose? */\n+{\n+  tree name;\n+  char *variety;\n+\n+  if (TREE_CODE (t) == ENUMERAL_TYPE)\n+    variety = \"enum\";\n+  else if (TREE_CODE (t) == UNION_TYPE)\n+    variety = \"union\";\n+  else if (TYPE_LANG_SPECIFIC (t) && CLASSTYPE_DECLARED_CLASS (t))\n+    variety = \"class\";\n+  else if (TYPE_LANG_SPECIFIC (t) && IS_SIGNATURE (t))\n+    variety = \"signature\";\n+  else\n+    variety = \"struct\";\n+\n+  dump_readonly_or_volatile (t, after);\n+\n+  if (v > 0)\n+    {\n+      OB_PUTCP (variety);\n+      OB_PUTC (' ');\n+    }\n+  \n+  name = TYPE_NAME (t);\n+\n+  if (DECL_CONTEXT (name))\n+    {\n+      /* FUNCTION_DECL or RECORD_TYPE */\n+      dump_decl (DECL_CONTEXT (name), 0);\n+      OB_PUTC2 (':', ':');\n+    }\n+\n+  /* kludge around wierd behavior on g++.brendan/line1.C */\n+  if (TREE_CODE (name) != IDENTIFIER_NODE)\n+    name = DECL_NAME (name);\n+\n+  if (ANON_AGGRNAME_P (name))\n+    {\n+      OB_PUTS (\"<anonymous\");\n+      if (!v)\n+\t{\n+\t  OB_PUTC (' ');\n+\t  OB_PUTCP (variety);\n+\t}\n+      OB_PUTC ('>');\n+    }\n+  else\n+    OB_PUTID (name);\n+}\n+\n+/* Dump into the obstack the initial part of the output for a given type.\n+   This is necessary when dealing with things like functions returning\n+   functions.  Examples:\n+\n+   return type of `int (* fee ())()': pointer -> function -> int.  Both\n+   pointer (and reference and offset) and function (and member) types must\n+   deal with prefix and suffix.\n+\n+   Arrays must also do this for DECL nodes, like int a[], and for things like\n+   int *[]&.  */\n+\n+static void\n+dump_type_prefix (t, v)\n+     tree t;\n+     int v;\t\t\t/* verbosity */\n+{\n+  if (TYPE_PTRMEMFUNC_P (t))\n+    {\n+      t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n+      goto offset_type;\n+    }\n+  \n+  switch (TREE_CODE (t))\n+    {\n+    case POINTER_TYPE:\n+      {\n+\ttree sub = TREE_TYPE (t);\n+\t\n+\tdump_type_prefix (sub, v);\n+\t/* A tree for a member pointer looks like pointer to offset,\n+\t   so let the OFFSET_TYPE case handle it.  */\n+\tif (TREE_CODE (sub) != OFFSET_TYPE)\n+\t  {\n+\t    switch (TREE_CODE (sub))\n+\t      {\n+\t\t/* We don't want int ( *)() */\n+\t      case FUNCTION_TYPE:\n+\t      case METHOD_TYPE:\n+\t\tbreak;\n+\t\t\n+\t      case POINTER_TYPE:\n+\t\t/* We don't want \"char * *\" */\n+\t\tif (! (TYPE_READONLY (sub) || TYPE_VOLATILE (sub)))\n+\t\t  break;\n+\t\t/* But we do want \"char *const *\" */\n+\t\t\n+\t      default:\n+\t\tOB_PUTC (' ');\n+\t      }\n+\t    OB_PUTC ('*');\n+\t    dump_readonly_or_volatile (t, none);\n+\t  }\n+      }\n+      break;\n+\n+    case REFERENCE_TYPE:\n+      {\n+\ttree sub = TREE_TYPE (t);\n+\tdump_type_prefix (sub, v);\n+\n+\tswitch (TREE_CODE (sub))\n+\t  {\n+\t  case POINTER_TYPE:\n+\t    /* We don't want \"char * &\" */\n+\t    if (! (TYPE_READONLY (sub) || TYPE_VOLATILE (sub)))\n+\t      break;\n+\t    /* But we do want \"char *const &\" */\n+\n+\t  default:\n+\t    OB_PUTC (' ');\n+\t  }\n+      }\n+      OB_PUTC ('&');\n+      dump_readonly_or_volatile (t, none);\n+      break;\n+\n+    case OFFSET_TYPE:\n+    offset_type:\n+      dump_type_prefix (TREE_TYPE (t), v);\n+      if (NEXT_CODE (t) != FUNCTION_TYPE && NEXT_CODE (t) != METHOD_TYPE)\n+\tOB_PUTC (' ');\n+      if (TREE_CODE (t) == OFFSET_TYPE)\n+\tdump_type (TYPE_OFFSET_BASETYPE (t), 0);\n+      else\t\t\t/* pointer to member function */\n+\tdump_type (TYPE_METHOD_BASETYPE (TREE_TYPE (t)), 0);\n+      OB_PUTC2 (':', ':');\n+      OB_PUTC ('*');\n+      dump_readonly_or_volatile (t, none);\n+      break;\n+\n+      /* Can only be reached through function pointer -- this would not be\n+         correct if FUNCTION_DECLs used it.  */\n+    case FUNCTION_TYPE:\n+      dump_type_prefix (TREE_TYPE (t), v);\n+      OB_PUTC2 (' ', '(');\n+      break;\n+\n+    case METHOD_TYPE:\n+      dump_type_prefix (TREE_TYPE (t), v);\n+      OB_PUTC2 (' ', '(');\n+      dump_aggr_type (TYPE_METHOD_BASETYPE (t), 0);\n+      OB_PUTC2 (':', ':');\n+      break;\n+\n+    case ARRAY_TYPE:\n+      dump_type_prefix (TREE_TYPE (t), v);\n+      break;\n+\n+    case ENUMERAL_TYPE:\n+    case ERROR_MARK:\n+    case IDENTIFIER_NODE:\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case RECORD_TYPE:\n+    case TEMPLATE_TYPE_PARM:\n+    case TREE_LIST:\n+    case TYPE_DECL:\n+    case TREE_VEC:\n+    case UNINSTANTIATED_P_TYPE:\n+    case UNION_TYPE:\n+    case UNKNOWN_TYPE:\n+    case VOID_TYPE:\n+      dump_type (t, v);\n+      break;\n+      \n+    default:\n+      my_friendly_abort (65);\n+    }\n+}\n+\n+static void\n+dump_type_suffix (t, v)\n+     tree t;\n+     int v;\t\t\t/* verbose? */\n+{\n+  if (TYPE_PTRMEMFUNC_P (t))\n+    t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+    case OFFSET_TYPE:\n+      dump_type_suffix (TREE_TYPE (t), v);\n+      break;\n+\n+      /* Can only be reached through function pointer */\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+      {\n+\ttree arg;\n+\tOB_PUTC2 (')', '(');\n+\targ = TYPE_ARG_TYPES (t);\n+\tif (TREE_CODE (t) == METHOD_TYPE)\n+\t  arg = TREE_CHAIN (arg);\n+\n+\tif (arg)\n+\t  dump_type (arg, v);\n+\telse\n+\t  OB_PUTS (\"...\");\n+\tOB_PUTC (')');\n+\tif (TREE_CODE (t) == METHOD_TYPE)\n+\t  dump_readonly_or_volatile\n+\t    (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))), before);\n+\tdump_type_suffix (TREE_TYPE (t), v);\n+\tbreak;\n+      }\n+\n+    case ARRAY_TYPE:\n+      OB_PUTC ('[');\n+      if (TYPE_DOMAIN (t))\n+\tOB_PUTI (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) + 1);\n+      OB_PUTC (']');\n+      dump_type_suffix (TREE_TYPE (t), v);\n+      break;\n+      \n+    case ENUMERAL_TYPE:\n+    case ERROR_MARK:\n+    case IDENTIFIER_NODE:\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case RECORD_TYPE:\n+    case TEMPLATE_TYPE_PARM:\n+    case TREE_LIST:\n+    case TYPE_DECL:\n+    case TREE_VEC:\n+    case UNINSTANTIATED_P_TYPE:\n+    case UNION_TYPE:\n+    case UNKNOWN_TYPE:\n+    case VOID_TYPE:\n+      break;\n+\n+    default:\n+      my_friendly_abort (67);\n+    }\n+}\n+\n+/* Return a function declaration which corresponds to the IDENTIFIER_NODE\n+   argument.  */\n+tree\n+ident_fndecl (t)\n+     tree t;\n+{\n+  tree n = IDENTIFIER_GLOBAL_VALUE (t);\n+\n+  if (TREE_CODE (n) == FUNCTION_DECL)\n+    return n;\n+  else if (TREE_CODE (n) == TREE_LIST\n+\t   && TREE_CODE (TREE_VALUE (n)) == FUNCTION_DECL)\n+    return TREE_VALUE (n);\n+  else\n+    my_friendly_abort (66);\n+}\n+\n+#ifndef NO_DOLLAR_IN_LABEL\n+#  define GLOBAL_THING \"_GLOBAL_$\"\n+#else\n+#  ifndef NO_DOT_IN_LABEL\n+#    define GLOBAL_THING \"_GLOBAL_.\"\n+#  else\n+#    define GLOBAL_THING \"_GLOBAL__\"\n+#  endif\n+#endif\n+\n+#define GLOBAL_IORD_P(NODE) \\\n+  !strncmp(IDENTIFIER_POINTER(NODE),GLOBAL_THING,sizeof(GLOBAL_THING)-1)\n+\n+void\n+dump_global_iord (t)\n+     tree t;\n+{\n+  char *name = IDENTIFIER_POINTER (t);\n+\n+  OB_PUTS (\"(static \");\n+  if (name [sizeof (GLOBAL_THING) - 1] == 'I')\n+    OB_PUTS (\"initializers\");\n+  else if (name [sizeof (GLOBAL_THING) - 1] == 'D')\n+    OB_PUTS (\"destructors\");\n+  else\n+    my_friendly_abort (352);\n+  \n+  OB_PUTS (\" for \");\n+  OB_PUTCP (input_filename);\n+  OB_PUTC (')');\n+}\n+\n+static void\n+dump_decl (t, v)\n+     tree t;\n+     int v;\t\t\t/* verbosity */\n+{\n+  if (t == NULL_TREE)\n+    return;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case ERROR_MARK:\n+      OB_PUTS (\" /* decl error */ \");\n+      break;\n+\n+    case VAR_DECL:\n+      if (VTABLE_NAME_P (DECL_NAME (t)))\n+\t{\n+\t  OB_PUTS (\"vtable for \");\n+\t  dump_type (DECL_CONTEXT (t), v);\n+\t  break;\n+\t}\n+      /* else fall through */\n+    case FIELD_DECL:\n+    case PARM_DECL:\n+      if (v > 0)\n+\t{\n+\t  dump_type_prefix (TREE_TYPE (t), v);\n+\t  OB_PUTC(' ');\n+\t}\n+      /* DECL_CLASS_CONTEXT isn't being set in some cases.  Hmm...  */\n+      if (TREE_CODE (t) == FIELD_DECL\n+\t  || (TREE_CODE (t) == VAR_DECL && DECL_CONTEXT (t)\n+\t      && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (t))) == 't'))\n+\t{\n+\t  dump_type (DECL_CONTEXT (t), 0);\n+\t  OB_PUTC2(':', ':');\n+\t}\n+      if (DECL_NAME (t))\n+\tdump_decl (DECL_NAME (t), v);\n+      else\n+\tOB_PUTS (\"<anon>\");\n+      if (v > 0) dump_type_suffix (TREE_TYPE (t), v);\n+      break;\n+\n+    case ARRAY_REF:\n+      dump_decl (TREE_OPERAND (t, 0), v);\n+      OB_PUTC ('[');\n+      dump_decl (TREE_OPERAND (t, 1), v);\n+      OB_PUTC (']');\n+      break;\n+\n+      /* So that we can do dump_decl in dump_aggr_type and have it work for\n+\t both class and function scope.  */\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      dump_type (t, v);\n+      break;\n+\n+    case TYPE_DECL:\n+      dump_type (TREE_TYPE (t), v);\n+      break;\n+\n+    case TYPE_EXPR:\n+      my_friendly_abort (69);\n+      break;\n+\n+      /* These special cases are duplicated here so that other functions\n+\t can feed identifiers to cp_error and get them demangled properly. */\n+    case IDENTIFIER_NODE:\n+      if (DESTRUCTOR_NAME_P (t))\n+\t{\n+\t  OB_PUTC ('~');\n+\t  dump_decl (DECL_NAME (ident_fndecl (t)), 0);\n+\t}\n+      else if (IDENTIFIER_TYPENAME_P (t))\n+\t{\n+\t  OB_PUTS (\"operator \");\n+\t  /* Not exactly IDENTIFIER_TYPE_VALUE.  */\n+\t  dump_type (TREE_TYPE (t), 0);\n+\t  break;\n+\t}\n+      else if (IDENTIFIER_OPNAME_P (t))\n+\t{\n+\t  char *name_string = operator_name_string (t);\n+\t  OB_PUTS (\"operator \");\n+\t  OB_PUTCP (name_string);\n+\t}\n+      else\n+\tOB_PUTID (t);\n+      break;\n+\n+    case FUNCTION_DECL:\n+      if (GLOBAL_IORD_P (DECL_ASSEMBLER_NAME (t)))\n+\tdump_global_iord (DECL_ASSEMBLER_NAME (t));\n+      else\n+\tdump_function_decl (t, v);\n+      break;\n+\n+    case TEMPLATE_DECL:\n+      switch (NEXT_CODE (t))\n+\t{\n+\tcase METHOD_TYPE:\n+\tcase FUNCTION_TYPE:\n+\t  dump_function_decl (t, v);\n+\t  break;\n+\n+\tdefault:\n+\t  my_friendly_abort (353);\n+\t}\n+      break;\n+\n+    case LABEL_DECL:\n+      OB_PUTID (DECL_NAME (t));\n+      break;\n+\n+    case CONST_DECL:\n+      if (NEXT_CODE (t) == ENUMERAL_TYPE)\n+\t{\n+\t  if (DECL_CONTEXT (t))\n+\t    {\n+\t      dump_decl (DECL_CONTEXT (t), 0);\n+\t      OB_PUTC2 (':', ':');\n+\t    }\n+\t  OB_PUTID (DECL_NAME (t));\n+\t}\n+      else\n+\tdump_expr (DECL_INITIAL (t), 0);\n+      break;\n+\n+    default:\n+      my_friendly_abort (70);\n+    }\n+}\n+\n+/* Pretty printing for announce_function.  T is the declaration of the\n+   function we are interested in seeing.  V is non-zero if we should print\n+   the type that this function returns.  */\n+\n+static void\n+dump_function_decl (t, v)\n+     tree t;\n+     int v;\n+{\n+  tree name = DECL_ASSEMBLER_NAME (t);\n+  tree fntype = TREE_TYPE (t);\n+  tree parmtypes = TYPE_ARG_TYPES (fntype);\n+  tree cname = NULL_TREE;\n+  int spaces = 0;\n+\n+  /* Friends have DECL_CLASS_CONTEXT set, but not DECL_CONTEXT.  */\n+  if (DECL_CONTEXT (t))\n+    cname = DECL_CLASS_CONTEXT (t);\n+  /* this is for partially instantiated template methods */\n+  else if (TREE_CODE (fntype) == METHOD_TYPE)\n+    cname = TREE_TYPE (TREE_VALUE (parmtypes));\n+\n+  v = (v > 0);\n+  \n+  if (v)\n+    {\n+      if (DECL_STATIC_FUNCTION_P (t))\n+\tOB_PUTS (\"static \");\n+    \n+      if (! IDENTIFIER_TYPENAME_P (name)\n+\t  && ! DECL_CONSTRUCTOR_P (t)\n+\t  && ! DESTRUCTOR_NAME_P (name))\n+\t{\n+\t  dump_type_prefix (TREE_TYPE (fntype), 1);\n+\t  OB_PUTC (' ');\n+\t}\n+    }\n+\n+  if (cname)\n+    {\n+      dump_type (cname, 0);\n+      OB_PUTC2 (':', ':');\n+      if (TREE_CODE (fntype) == METHOD_TYPE && parmtypes)\n+\tparmtypes = TREE_CHAIN (parmtypes);\n+      if (DECL_CONSTRUCTOR_FOR_VBASE_P (t))\n+\t/* Skip past \"in_charge\" identifier.  */\n+\tparmtypes = TREE_CHAIN (parmtypes);\n+    }\n+\n+  if (DESTRUCTOR_NAME_P (name))\n+    parmtypes = TREE_CHAIN (parmtypes);\n+  \n+  dump_function_name (t);\n+  \n+  OB_PUTC ('(');\n+\n+  if (parmtypes)\n+    dump_type (parmtypes, v);\n+  else\n+    OB_PUTS (\"...\");\n+\n+  OB_PUTC (')');\n+\n+  if (v && ! IDENTIFIER_TYPENAME_P (name))\n+    dump_type_suffix (TREE_TYPE (fntype), 1);\n+\n+  if (TREE_CODE (fntype) == METHOD_TYPE)\n+    {\n+      if (IS_SIGNATURE (cname))\n+\t/* We look at the type pointed to by the `optr' field of `this.'  */\n+\tdump_readonly_or_volatile\n+\t  (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_VALUE (TYPE_ARG_TYPES (fntype))))), before);\n+      else\n+\tdump_readonly_or_volatile\n+\t  (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))), before);\n+    }\n+}\n+\n+/* Handle the function name for a FUNCTION_DECL node, grokking operators\n+   and destructors properly.  */\n+static void\n+dump_function_name (t)\n+     tree t;\n+{\n+  tree name = DECL_NAME (t);\n+\n+  /* There ought to be a better way to find out whether or not something is\n+     a destructor.  */\n+  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (t)))\n+    {\n+      OB_PUTC ('~');\n+      dump_decl (name, 0);\n+    }\n+  else if (IDENTIFIER_TYPENAME_P (name))\n+    {\n+      /* This cannot use the hack that the operator's return\n+\t type is stashed off of its name because it may be\n+\t used for error reporting.  In the case of conflicting\n+\t declarations, both will have the same name, yet\n+\t the types will be different, hence the TREE_TYPE field\n+\t of the first name will be clobbered by the second.  */\n+      OB_PUTS (\"operator \");\n+      dump_type (TREE_TYPE (TREE_TYPE (t)), 0);\n+    }\n+  else if (IDENTIFIER_OPNAME_P (name))\n+    {\n+      char *name_string = operator_name_string (name);\n+      OB_PUTS (\"operator \");\n+      OB_PUTCP (name_string);\n+    }\n+  else\n+    dump_decl (name, 0);\n+}\n+\n+static void\n+dump_char (c)\n+     char c;\n+{\n+  switch (c)\n+    {\n+    case '\\n':\n+      OB_PUTS (\"\\\\n\");\n+      break;\n+    case '\\t':\n+      OB_PUTS (\"\\\\t\");\n+      break;\n+    case '\\v':\n+      OB_PUTS (\"\\\\v\");\n+      break;\n+    case '\\b':\n+      OB_PUTS (\"\\\\b\");\n+      break;\n+    case '\\r':\n+      OB_PUTS (\"\\\\r\");\n+      break;\n+    case '\\f':\n+      OB_PUTS (\"\\\\f\");\n+      break;\n+    case '\\a':\n+      OB_PUTS (\"\\\\a\");\n+      break;\n+    case '\\\\':\n+      OB_PUTS (\"\\\\\\\\\");\n+      break;\n+    case '\\'':\n+      OB_PUTS (\"\\\\'\");\n+      break;\n+    case '\\\"':\n+      OB_PUTS (\"\\\\\\\"\");\n+      break;\n+    default:\n+      if (isprint (c))\n+\tOB_PUTC (c);\n+      else\n+\t{\n+\t  sprintf (digit_buffer, \"\\\\%03o\", (int) c);\n+\t  OB_PUTCP (digit_buffer);\n+\t}\n+    }\n+}\n+\n+/* Print out a list of initializers (subr of dump_expr) */\n+static void\n+dump_expr_list (l)\n+     tree l;\n+{\n+  while (l)\n+    {\n+      dump_expr (TREE_VALUE (l), 0);\n+      if (TREE_CHAIN (l))\n+\tOB_PUTC2 (',', ' ');\n+      l = TREE_CHAIN (l);\n+    }\n+}\n+\n+/* Print out an expression */\n+static void\n+dump_expr (t, nop)\n+     tree t;\n+     int nop;\t\t\t/* suppress parens */\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case FIELD_DECL:\n+    case CONST_DECL:\n+    case FUNCTION_DECL:\n+      dump_decl (t, -1);\n+      break;\n+\n+    case INTEGER_CST:\n+      {\n+\ttree type = TREE_TYPE (t);\n+\tmy_friendly_assert (type != 0, 81);\n+\n+\t/* If it's an enum, output its tag, rather than its value.  */\n+\tif (TREE_CODE (type) == ENUMERAL_TYPE)\n+\t  {\n+\t    char *p = enum_name_string (t, type);\n+\t    OB_PUTCP (p);\n+\t  }\n+\telse if (type == char_type_node\n+\t\t || type == signed_char_type_node\n+\t\t || type == unsigned_char_type_node)\n+\t  {\n+\t    OB_PUTC ('\\'');\n+\t    dump_char (TREE_INT_CST_LOW (t));\n+\t    OB_PUTC ('\\'');\n+\t  }\n+\telse if (TREE_INT_CST_HIGH (t)\n+\t\t != (TREE_INT_CST_LOW (t) >> (HOST_BITS_PER_WIDE_INT - 1)))\n+\t  {\n+\t    tree val = t;\n+\t    if (TREE_INT_CST_HIGH (val) < 0)\n+\t      {\n+\t\tOB_PUTC ('-');\n+\t\tval = build_int_2 (~TREE_INT_CST_LOW (val),\n+\t\t\t\t   -TREE_INT_CST_HIGH (val));\n+\t      }\n+\t    /* Would \"%x%0*x\" or \"%x%*0x\" get zero-padding on all\n+\t       systems?  */\n+\t    {\n+\t      static char format[10]; /* \"%x%09999x\\0\" */\n+\t      if (!format[0])\n+\t\tsprintf (format, \"%%x%%0%dx\", HOST_BITS_PER_INT / 4);\n+\t      sprintf (digit_buffer, format, TREE_INT_CST_HIGH (val),\n+\t\t       TREE_INT_CST_LOW (val));\n+\t      OB_PUTCP (digit_buffer);\n+\t    }\n+\t  }\n+\telse\n+\t  OB_PUTI (TREE_INT_CST_LOW (t));\n+      }\n+      break;\n+\n+    case REAL_CST:\n+#ifndef REAL_IS_NOT_DOUBLE\n+      sprintf (digit_buffer, \"%g\", TREE_REAL_CST (t));\n+#else\n+      {\n+\tunsigned char *p = (unsigned char *) &TREE_REAL_CST (t);\n+\tint i;\n+\tstrcpy (digit_buffer, \"0x\");\n+\tfor (i = 0; i < sizeof TREE_REAL_CST (t); i++)\n+\t  sprintf (digit_buffer + 2 + 2*i, \"%02x\", *p++);\n+      }\n+#endif\n+      OB_PUTCP (digit_buffer);\n+      break;\n+\n+    case STRING_CST:\n+      {\n+\tchar *p = TREE_STRING_POINTER (t);\n+\tint len = TREE_STRING_LENGTH (t) - 1;\n+\tint i;\n+\n+\tOB_PUTC ('\\\"');\n+\tfor (i = 0; i < len; i++)\n+\t  dump_char (p[i]);\n+\tOB_PUTC ('\\\"');\n+      }\n+      break;\n+\n+    case COMPOUND_EXPR:\n+      dump_binary_op (\",\", t);\n+      break;\n+\n+    case COND_EXPR:\n+      OB_PUTC ('(');\n+      dump_expr (TREE_OPERAND (t, 0), 0);\n+      OB_PUTS (\" ? \");\n+      dump_expr (TREE_OPERAND (t, 1), 0);\n+      OB_PUTS (\" : \");\n+      dump_expr (TREE_OPERAND (t, 2), 0);\n+      OB_PUTC (')');\n+      break;\n+\n+    case SAVE_EXPR:\n+      if (TREE_HAS_CONSTRUCTOR (t))\n+\t{\n+\t  OB_PUTS (\"new \");\n+\t  dump_type (TREE_TYPE (TREE_TYPE (t)), 0);\n+\t  PARM_DECL_EXPR (t) = 1;\n+\t}\n+      else\n+\t{\n+\t  sorry (\"operand of SAVE_EXPR not understood\");\n+\t  goto error;\n+\t}\n+      break;\n+\n+    case NEW_EXPR:\n+      OB_PUTID (TYPE_IDENTIFIER (TREE_TYPE (t)));\n+      OB_PUTC ('(');\n+      dump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)));\n+      OB_PUTC (')');\n+      break;\n+\n+    case CALL_EXPR:\n+      {\n+\ttree fn = TREE_OPERAND (t, 0);\n+\ttree args = TREE_OPERAND (t, 1);\n+\t\n+\tif (TREE_CODE (fn) == ADDR_EXPR)\n+\t  fn = TREE_OPERAND (fn, 0);\n+\n+\tif (NEXT_CODE (fn) == METHOD_TYPE)\n+\t  {\n+\t    tree ob = TREE_VALUE (args);\n+\t    if (TREE_CODE (ob) == ADDR_EXPR)\n+\t      {\n+\t\tdump_expr (TREE_OPERAND (ob, 0), 0);\n+\t\tOB_PUTC ('.');\n+\t      }\n+\t    else if (TREE_CODE (ob) != PARM_DECL\n+\t\t     || strcmp (IDENTIFIER_POINTER (DECL_NAME (ob)), \"this\"))\n+\t      {\n+\t\tdump_expr (ob, 0);\n+\t\tOB_PUTC2 ('-', '>');\n+\t      }\n+\t    args = TREE_CHAIN (args);\n+\t  }\n+\tdump_expr (fn, 0);\n+\tOB_PUTC('(');\n+\tdump_expr_list (args);\n+\tOB_PUTC (')');\n+      }\n+      break;\n+\n+    case WITH_CLEANUP_EXPR:\n+      /* Note that this only works for G++ cleanups.  If somebody\n+\t builds a general cleanup, there's no way to represent it.  */\n+      dump_expr (TREE_OPERAND (t, 0), 0);\n+      break;\n+\n+    case TARGET_EXPR:\n+      /* Note that this only works for G++ target exprs.  If somebody\n+\t builds a general TARGET_EXPR, there's no way to represent that\n+\t it initializes anything other that the parameter slot for the\n+\t default argument.  Note we may have cleared out the first\n+\t operand in expand_expr, so don't go killing ourselves.  */\n+      if (TREE_OPERAND (t, 1))\n+\tdump_expr (TREE_OPERAND (t, 1), 0);\n+      break;\n+\n+    case MODIFY_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_ANDTC_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      dump_binary_op (opname_tab[(int) TREE_CODE (t)], t);\n+      break;\n+\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+      dump_binary_op (\"/\", t);\n+      break;\n+\n+    case CEIL_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+      dump_binary_op (\"%\", t);\n+      break;\n+\n+    case COMPONENT_REF:\n+      {\n+\ttree ob = TREE_OPERAND (t, 0);\n+\tif (TREE_CODE (ob) == INDIRECT_REF)\n+\t  {\n+\t    ob = TREE_OPERAND (ob, 0);\n+\t    if (TREE_CODE (ob) != PARM_DECL\n+\t\t|| strcmp (IDENTIFIER_POINTER (DECL_NAME (ob)), \"this\"))\n+\t      {\n+\t\tdump_expr (ob, 0);\n+\t\tOB_PUTC2 ('-', '>');\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    dump_expr (ob, 0);\n+\t    OB_PUTC ('.');\n+\t  }\n+\tdump_expr (TREE_OPERAND (t, 1), 1);\n+      }\n+      break;\n+\n+    case CONVERT_EXPR:\n+      dump_unary_op (\"+\", t, nop);\n+      break;\n+\n+    case ADDR_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL\n+\t  || TREE_CODE (TREE_OPERAND (t, 0)) == STRING_CST)\n+\tdump_expr (TREE_OPERAND (t, 0), 0);\n+      else\n+\tdump_unary_op (\"&\", t, nop);\n+      break;\n+\n+    case INDIRECT_REF:\n+      if (TREE_HAS_CONSTRUCTOR (t))\n+\t{\n+\t  t = TREE_OPERAND (t, 0);\n+\t  my_friendly_assert (TREE_CODE (t) == CALL_EXPR, 237);\n+\t  dump_expr (TREE_OPERAND (t, 0), 0);\n+\t  OB_PUTC ('(');\n+\t  dump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)));\n+\t  OB_PUTC (')');\n+\t}\n+      else\n+\t{\n+\t  if (NEXT_CODE (TREE_OPERAND (t, 0)) == REFERENCE_TYPE)\n+\t    dump_expr (TREE_OPERAND (t, 0), nop);\n+\t  else\n+\t    dump_unary_op (\"*\", t, nop);\n+\t}\n+      break;\n+\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+      dump_unary_op (opname_tab [(int)TREE_CODE (t)], t, nop);\n+      break;\n+\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+      OB_PUTC ('(');\n+      dump_expr (TREE_OPERAND (t, 0), 0);\n+      OB_PUTCP (opname_tab[(int)TREE_CODE (t)]);\n+      OB_PUTC (')');\n+      break;\n+\n+    case NON_LVALUE_EXPR:\n+      /* FIXME: This is a KLUDGE workaround for a parsing problem.  There\n+\t should be another level of INDIRECT_REF so that I don't have to do\n+\t this.  */\n+      if (NEXT_CODE (t) == POINTER_TYPE)\n+\t{\n+\t  tree next = TREE_TYPE (TREE_TYPE (t));\n+\n+\t  while (TREE_CODE (next) == POINTER_TYPE)\n+\t    next = TREE_TYPE (next);\n+\t  \n+\t  if (TREE_CODE (next) == FUNCTION_TYPE)\n+\t    {\n+\t      if (!nop) OB_PUTC ('(');\n+\t      OB_PUTC ('*');\n+\t      dump_expr (TREE_OPERAND (t, 0), 1);\n+\t      if (!nop) OB_PUTC (')');\n+\t      break;\n+\t    }\n+\t  /* else FALLTHRU */\n+\t}\n+      dump_expr (TREE_OPERAND (t, 0), 0);\n+      break;\n+\n+    case NOP_EXPR:\n+      dump_expr (TREE_OPERAND (t, 0), nop);\n+      break;\n+\n+    case CONSTRUCTOR:\n+      OB_PUTC ('{');\n+      dump_expr_list (CONSTRUCTOR_ELTS (t), 0);\n+      OB_PUTC ('}');\n+      break;\n+\n+      /*  This list is incomplete, but should suffice for now.\n+\t  It is very important that `sorry' does not call\n+\t  `report_error_function'.  That could cause an infinite loop.  */\n+    default:\n+      sorry (\"`%s' not supported by dump_expr\",\n+\t     tree_code_name[(int) TREE_CODE (t)]);\n+\n+      /* fall through to ERROR_MARK...  */\n+    case ERROR_MARK:\n+    error:\n+      OB_PUTCP (\"/* error */\");\n+      break;\n+    }\n+}\n+\n+static void\n+dump_binary_op (opstring, t)\n+     char *opstring;\n+     tree t;\n+{\n+  OB_PUTC ('(');\n+  dump_expr (TREE_OPERAND (t, 0), 1);\n+  OB_PUTC (' ');\n+  OB_PUTCP (opstring);\n+  OB_PUTC (' ');\n+  dump_expr (TREE_OPERAND (t, 1), 1);\n+  OB_PUTC (')');\n+}\n+\n+static void\n+dump_unary_op (opstring, t, nop)\n+     char *opstring;\n+     tree t;\n+     int nop;\n+{\n+  if (!nop) OB_PUTC ('(');\n+  OB_PUTCP (opstring);\n+  dump_expr (TREE_OPERAND (t, 0), 1);\n+  if (!nop) OB_PUTC (')');\n+}\n+\n+char *\n+fndecl_as_string (cname, fndecl, print_ret_type_p)\n+     tree cname, fndecl;\n+     int print_ret_type_p;\n+{\n+  return decl_as_string (fndecl, print_ret_type_p);\n+}\n+\n+/* Same, but handtype a _TYPE.\n+   Called from convert_to_reference, mangle_class_name_for_template,\n+   build_unary_op, and GNU_xref_decl.  */\n+char *\n+type_as_string (typ, v)\n+     tree typ;\n+     int v;\n+{\n+  OB_INIT ();\n+\n+  dump_type (typ, v);\n+\n+  OB_FINISH ();\n+\n+  return (char *)obstack_base (&scratch_obstack);\n+}\n+\n+char *\n+expr_as_string (decl, v)\n+     tree decl;\n+     int v;\n+{\n+  OB_INIT ();\n+\n+  dump_expr (decl, 1);\n+\n+  OB_FINISH ();\n+\n+  return (char *)obstack_base (&scratch_obstack);\n+}\n+\n+/* A cross between type_as_string and fndecl_as_string.\n+   Only called from substitute_nice_name.  */\n+char *\n+decl_as_string (decl, v)\n+     tree decl;\n+     int v;\n+{\n+  OB_INIT ();\n+\n+  dump_decl (decl, v);\n+\n+  OB_FINISH ();\n+\n+  return (char *)obstack_base (&scratch_obstack);\n+}\n+\n+char *\n+cp_file_of (t)\n+     tree t;\n+{\n+  if (TREE_CODE (t) == PARM_DECL)\n+    return DECL_SOURCE_FILE (DECL_CONTEXT (t));\n+  else if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+    return DECL_SOURCE_FILE (TYPE_NAME (t));\n+  else\n+    return DECL_SOURCE_FILE (t);\n+}\n+\n+int\n+cp_line_of (t)\n+     tree t;\n+{\n+  if (TREE_CODE (t) == PARM_DECL)\n+    return DECL_SOURCE_LINE (DECL_CONTEXT (t));\n+  else if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+    return DECL_SOURCE_LINE (TYPE_NAME (t));\n+  else\n+    return DECL_SOURCE_LINE (t);\n+}\n+\n+char *\n+code_as_string (c, v)\n+     enum tree_code c;\n+     int v;\n+{\n+  return tree_code_name [c];\n+}\n+\n+char *\n+language_as_string (c, v)\n+     enum languages c;\n+{\n+  switch (c)\n+    {\n+    case lang_c:\n+      return \"C\";\n+\n+    case lang_cplusplus:\n+      return \"C++\";\n+\n+    default:\n+      my_friendly_abort (355);\n+    }\n+}\n+\n+/* Return the proper printed version of a parameter to a C++ function.  */\n+char *\n+parm_as_string (p, v)\n+     int p;\n+{\n+  if (p < 0)\n+    return \"`this'\";\n+\n+  sprintf (digit_buffer, \"%d\", p+1);\n+  return digit_buffer;\n+}\n+\n+char *\n+op_as_string (p, v)\n+     enum tree_code p;\n+{\n+  static char buf[] = \"operator                \";\n+\n+  if (p == 0)\n+    return \"<unknown>\";\n+  \n+  strcpy (buf + 9, opname_tab [p]);\n+  return buf;\n+}\n+\n+char *\n+args_as_string (p, v)\n+     tree p;\n+     int v;\n+{\n+  if (p == NULL_TREE)\n+    return \"...\";\n+\n+  return type_as_string (p, v);\n+}"}, {"sha": "4d956fc73a6c6503ce6d4f91470ce0d33eefeedb", "filename": "gcc/cp/except.c", "status": "added", "additions": 1224, "deletions": 0, "changes": 1224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,1224 @@\n+/* Handle exceptional things in C++.\n+   Copyright (C) 1989, 1992, 1993 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* High-level class interface. */\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"cp-tree.h\"\n+#include \"flags.h\"\n+/* On Suns this can get you to the right definition if you\n+   set the right value for TARGET.  */\n+#include <setjmp.h>\n+#ifdef sequent\n+/* Can you believe they forgot this?  */\n+#define _JBLEN 11\n+#endif\n+\n+#ifndef _JBLEN\n+#define _JBLEN (sizeof(jmp_buf)/sizeof(int))\n+#endif\n+\n+#undef NULL\n+#define NULL (char *)0\n+\n+/* This should be part of `ansi_opname', or at least be defined by the std.  */\n+#define EXCEPTION_NAME_PREFIX \"__ex\"\n+#define EXCEPTION_NAME_LENGTH 4\n+\n+void init_exception_processing ();\n+void init_exception_processing_1 ();\n+\n+/* If non-zero, a VAR_DECL whose cleanup will cause a throw to the\n+   next exception handler.  Its value says whether to throw or not.\n+   In the case of functions which do not issue a RAISE, it should be\n+   possible to optimize away this VAR_DECL (and overhead associated\n+   with it).  */\n+tree exception_throw_decl;\n+/* Use this to know that we did not set `exception_throw_decl',\n+   until GCC optimizer is smart enough to figure it out for itself.  */\n+int sets_exception_throw_decl;\n+\n+/* The exception `type' currently in scope, or NULL_TREE if none.  */\n+tree current_exception_type;\n+\n+/* The exception handler object for the given scope.  */\n+tree current_exception_decl;\n+rtx current_exception_name_as_rtx;\n+rtx current_exception_parms_as_rtx;\n+\n+/* The ``object'' view of the current exception parameters.\n+   We cast up from the `parms' field to `current_exception_type'.  */\n+tree current_exception_object;\n+\n+/* Cache `setjmp', `longjmp', `raise_exception', and `unhandled_exception'\n+   after default conversion.  Maybe later they will get built-in.  */\n+static tree BISJ, BILJ, BIR, BIUE;\n+\n+/* Local variables which give the appearance that exception\n+   handling is part of the language and the execution model.  */\n+\n+/* The type of the exception handler stack.  */\n+tree EHS_type;\n+\n+/* The global handler stack.  */\n+tree EHS_decl;\n+\n+/* Cached component refs to fields of `EHS_decl'.  */\n+static tree EHS_prev, EHS_handler, EHS_parms, EHS_name;\n+static rtx EHS_parms_as_rtx, EHS_name_as_rtx;\n+\n+/* The parameter names of this exception type.  */\n+\n+static tree last_exception_fields;\n+static tree last_exception_field_types;\n+\n+/* When ID is VOID_TYPE_NODE, it means ``raise all''.\n+   Cannot be inline, since it uses `alloca', and that\n+   breaks code which pushes the result of this function\n+   on the stack.  */\n+static tree\n+exception_object_name (prefix, id)\n+     tree prefix;\n+     tree id;\n+{\n+  /* First, cons up the `name' of this exception.  */\n+  char *name;\n+  int length = (id == void_type_node ? 3 : IDENTIFIER_LENGTH (id)) + EXCEPTION_NAME_LENGTH;\n+\n+  if (prefix)\n+    length += IDENTIFIER_LENGTH (prefix) + 2;\n+\n+  name = (char *)alloca (length);\n+  strcpy (name, EXCEPTION_NAME_PREFIX);\n+  length = EXCEPTION_NAME_LENGTH;\n+  if (prefix)\n+    {\n+      strcpy (name + length, IDENTIFIER_POINTER (prefix));\n+#ifdef JOINER\n+      name[length + IDENTIFIER_LENGTH (prefix)] = JOINER;\n+#else\n+      name[length + IDENTIFIER_LENGTH (prefix)] = '_';\n+#endif\n+      length += IDENTIFIER_LENGTH (prefix) + 1;\n+    }\n+  if (id == void_type_node)\n+    strcpy (name + length, \"all\");\n+  else\n+    strcpy (name + length, IDENTIFIER_POINTER (id));\n+  return get_identifier (name);\n+}\n+\n+tree\n+lookup_exception_cname (ctype, cname, raise_id)\n+     tree ctype, cname;\n+     tree raise_id;\n+{\n+  tree this_cname = TREE_PURPOSE (raise_id);\n+  if (this_cname == NULL_TREE)\n+    {\n+      if (cname)\n+\t{\n+\t  tree name = TREE_VALUE (raise_id);\n+\t  if (purpose_member (name, CLASSTYPE_TAGS (ctype)))\n+\t    this_cname = cname;\n+\t}\n+    }\n+  else if (this_cname == void_type_node)\n+    this_cname = NULL_TREE;\n+  else if (TREE_CODE (this_cname) != IDENTIFIER_NODE)\n+    {\n+      sorry (\"multiple scope refs in `cplus_expand_raise_stmt'\");\n+      this_cname = error_mark_node;\n+    }\n+  return this_cname;\n+}\n+\n+tree\n+lookup_exception_tname (oname)\n+     tree oname;\n+{\n+  return get_identifier (IDENTIFIER_POINTER (oname) + EXCEPTION_NAME_LENGTH);\n+}\n+\n+tree\n+lookup_exception_object (cname, name, complain)\n+     tree cname, name;\n+     int complain;\n+{\n+  tree oname;\n+  tree decl;\n+\n+  if (cname == void_type_node)\n+    cname = NULL_TREE;\n+  else if (cname && TREE_CODE (cname) != IDENTIFIER_NODE)\n+    {\n+      sorry (\"multiple scope refs in `lookup_exception_object'\");\n+      cname = NULL_TREE;\n+    }\n+  oname = exception_object_name (cname, name);\n+  decl = IDENTIFIER_GLOBAL_VALUE (oname);\n+  if (decl == NULL_TREE || TREE_CODE (decl) != VAR_DECL)\n+    {\n+      if (complain)\n+\t{\n+\t  push_obstacks_nochange ();\n+\n+\t  if (cname)\n+\t    error (\"no exception name object for name `%s::%s'\",\n+\t\t   IDENTIFIER_POINTER (cname),\n+\t\t   IDENTIFIER_POINTER (name));\n+\t  else\n+\t    error (\"no exception name object for name `%s'\",\n+\t\t   IDENTIFIER_POINTER (name));\n+\t  end_temporary_allocation ();\n+\t  /* Avoid further error messages.  */\n+\t  pushdecl_top_level (build_lang_field_decl (VAR_DECL,\n+\t\t\t\t\t\t     exception_object_name (cname, name),\n+\t\t\t\t\t\t     error_mark_node));\n+\t  pop_obstacks ();\n+\t}\n+      return NULL_TREE;\n+    }\n+  return decl;\n+}\n+\n+tree\n+lookup_exception_type (ctype, cname, raise_id)\n+     tree ctype, cname;\n+     tree raise_id;\n+{\n+  tree name = TREE_VALUE (raise_id);\n+  tree purpose = TREE_PURPOSE (raise_id);\n+\n+  if (cname && purpose == NULL_TREE)\n+    purpose = cname;\n+\n+  if (purpose && purpose != void_type_node)\n+    {\n+      tree link = NULL_TREE;\n+\n+      if (TREE_CODE (purpose) != IDENTIFIER_NODE)\n+\t{\n+\t  sorry (\"multiple scope refs in `lookup_exception_type'\");\n+\t  TREE_PURPOSE (raise_id) = NULL_TREE;\n+\t  return NULL_TREE;\n+\t}\n+      if (! is_aggr_typedef (purpose, 1))\n+\treturn NULL_TREE;\n+      ctype = IDENTIFIER_TYPE_VALUE (purpose);\n+      link = purpose_member (name, CLASSTYPE_TAGS (ctype));\n+      if (link)\n+\treturn TREE_VALUE (link);\n+    }\n+\n+  ctype = lookup_name (name, 1);\n+  if (ctype && TREE_CODE (ctype) == TYPE_DECL)\n+    ctype = TREE_TYPE (ctype);\n+  if (ctype && TREE_CODE (ctype) == RECORD_TYPE\n+      && CLASSTYPE_DECLARED_EXCEPTION (ctype))\n+    return ctype;\n+  return NULL_TREE;\n+}\n+\n+tree\n+finish_exception (e, list_of_fieldlists)\n+     tree e;\n+     tree list_of_fieldlists;\n+{\n+  tree parmtypes = NULL_TREE, name_field;\n+  tree cname = TYPE_NAME (e);\n+\n+  if (TREE_CODE (cname) == TYPE_DECL)\n+    cname = DECL_NAME (cname);\n+\n+  if (last_exception_fields)\n+    error (\"cannot declare exceptions within exceptions\");\n+  if (list_of_fieldlists && ! ANON_AGGRNAME_P (cname))\n+    cp_error (\"exception name `%T' must follow body declaration\", e);\n+  if (list_of_fieldlists)\n+    {\n+      tree prev, field;\n+\n+      /* Note: no public, private, or protected allowed.  */\n+      if (TREE_CHAIN (list_of_fieldlists))\n+\terror (\"access declarations invalid in exception declaration\");\n+      else if (TREE_PURPOSE (list_of_fieldlists) != (tree)access_default)\n+\terror (\"access declarations invalid in exception declaration\");\n+      TREE_PURPOSE (list_of_fieldlists) = (tree)access_default;\n+\n+      /* Note also: no member function declarations allowed.  */\n+      for (prev = 0, field = TREE_VALUE (list_of_fieldlists);\n+\t   field; prev = field, field = TREE_CHAIN (field))\n+\t{\n+\t  switch (TREE_CODE (field))\n+\t    {\n+\t    case FIELD_DECL:\n+\t      /* ok.  */\n+\t      parmtypes = tree_cons (NULL_TREE, TREE_TYPE (field), parmtypes);\n+\t      continue;\n+\t    case FUNCTION_DECL:\n+\t      cp_error (\"declaration of function `%D' in exception invalid\",\n+\t\t\t  field);\n+\t      break;\n+\t    case VAR_DECL:\n+\t      if (TREE_STATIC (field))\n+\t\tcp_error (\"declaration of static variable `%D' in exception invalid\", field);\n+\t      else\n+\t\tcp_error (\"declaration of constant field `%D' in exception invalid\", field);\n+\t      break;\n+\t    case CONST_DECL:\n+\t      cp_error (\"declaration of enum value `%D' in exception invalid\", field);\n+\t      break;\n+\t    case SCOPE_REF:\n+\t      error (\"use of `::' in exception context invalid\");\n+\t      break;\n+\t    }\n+\t  if (prev)\n+\t    TREE_CHAIN (prev) = TREE_CHAIN (field);\n+\t  else\n+\t    TREE_VALUE (list_of_fieldlists) = TREE_CHAIN (field);\n+\t}\n+    }\n+\n+  /* Now that we've cleaned up the fields, add a name identifier at front.  */\n+  name_field = build_lang_field_decl (FIELD_DECL, get_identifier (\"__name\"),\n+\t\t\t\t      ptr_type_node);\n+  if (list_of_fieldlists)\n+    {\n+      TREE_CHAIN (name_field) = TREE_VALUE (list_of_fieldlists);\n+      TREE_VALUE (list_of_fieldlists) = name_field;\n+    }\n+  else\n+    list_of_fieldlists = build_tree_list (NULL_TREE, name_field);\n+\n+  last_exception_fields = TREE_VALUE (list_of_fieldlists);\n+  if (parmtypes)\n+    {\n+      last_exception_field_types = nreverse (parmtypes);\n+      /* Set the TREE_CHAIN of what is now at the end of the\n+\t list to `void_list_node'.  */\n+      TREE_CHAIN (parmtypes) = void_list_node;\n+    }\n+  else\n+    last_exception_field_types = void_list_node;\n+\n+  popclass (0);\n+\n+#if 0\n+  /* Remove aggregate types from the list of tags,\n+     since these appear at global scope.  */\n+  while (x && IS_AGGR_TYPE (TREE_VALUE (x)))\n+    x = TREE_CHAIN (x);\n+  CLASSTYPE_TAGS (t) = x;\n+  y = x;\n+  while (x)\n+    {\n+      if (IS_AGGR_TYPE (TREE_VALUE (x)))\n+\tTREE_CHAIN (y) = TREE_CHAIN (x);\n+      x = TREE_CHAIN (x);\n+    }\n+#endif\n+\n+  if (flag_cadillac)\n+    cadillac_finish_exception (e);\n+\n+  return e;\n+}\n+\n+void\n+finish_exception_decl (cname, decl)\n+     tree cname, decl;\n+{\n+  /* In cp-decl.h.  */\n+  extern tree last_function_parms;\n+\n+  /* An exception declaration.  */\n+  tree t, ctor;\n+  tree parmdecls = NULL_TREE, fields;\n+  tree list_of_fieldlists = temp_tree_cons (NULL_TREE,\n+\t\t\t\t\t    copy_list (last_exception_fields),\n+\t\t\t\t\t    NULL_TREE);\n+  tree edecl = build_lang_field_decl (VAR_DECL,\n+\t\t\t\t      exception_object_name (cname, DECL_NAME (decl)),\n+\t\t\t\t      ptr_type_node);\n+\n+  DECL_LANGUAGE (edecl) = lang_c;\n+  TREE_STATIC (edecl) = 1;\n+  TREE_PUBLIC (edecl) = 1;\n+  finish_decl (pushdecl (edecl), NULL_TREE, NULL_TREE, 0);\n+\n+  /* Now instantiate the exception decl.  */\n+  t = xref_tag (exception_type_node, DECL_NAME (decl), NULL_TREE, 0);\n+\n+  /* finish_struct will pop this.  */\n+  pushclass (t, 0);\n+\n+  /* Now add a constructor which takes as parameters all the types we\n+     just defined.  */\n+  ctor = build_lang_decl (FUNCTION_DECL, DECL_NAME (decl),\n+\t\t\t  build_cplus_method_type (t, TYPE_POINTER_TO (t),\n+\t\t\t\t\t\t   last_exception_field_types));\n+  /* Don't take `name'.  The constructor handles that.  */\n+  fields = TREE_CHAIN (TREE_VALUE (list_of_fieldlists));\n+  while (fields)\n+    {\n+      tree parm = build_decl (PARM_DECL, DECL_NAME (fields), TREE_TYPE (fields));\n+      /* Since there is a prototype, args are passed in their own types.  */\n+      DECL_ARG_TYPE (parm) = TREE_TYPE (parm);\n+#ifdef PROMOTE_PROTOTYPES\n+      if ((TREE_CODE (TREE_TYPE (fields)) == INTEGER_TYPE\n+\t   || TREE_CODE (TREE_TYPE (fields)) == ENUMERAL_TYPE)\n+\t  && TYPE_PRECISION (TREE_TYPE (fields)) < TYPE_PRECISION (integer_type_node))\n+\tDECL_ARG_TYPE (parm) = integer_type_node;\n+#endif\n+      TREE_CHAIN (parm) = parmdecls;\n+      parmdecls = parm;\n+      fields = TREE_CHAIN (fields);\n+    }\n+  fields = TREE_VALUE (list_of_fieldlists);\n+  last_function_parms = nreverse (parmdecls);\n+\n+  DECL_CONSTRUCTOR_P (ctor) = 1;\n+  TYPE_HAS_CONSTRUCTOR (t) = 1;\n+  grokclassfn (t, DECL_NAME (decl), ctor, NO_SPECIAL, NULL_TREE);\n+  DECL_EXTERNAL (ctor) = 1;\n+  TREE_STATIC (ctor) = 1;\n+  TREE_PUBLIC (ctor) = 0;\n+  DECL_INLINE (ctor) = 1;\n+  make_decl_rtl (ctor, NULL_PTR, 1);\n+  finish_decl (ctor, NULL_TREE, NULL_TREE, 0);\n+  TREE_CHAIN (ctor) = TREE_VALUE (list_of_fieldlists);\n+  TREE_VALUE (list_of_fieldlists) = ctor;\n+\n+  finish_struct (t, list_of_fieldlists, 0);\n+\n+  if (current_function_decl)\n+    error (\"cannot define exception inside function scope\");\n+  else\n+    {\n+      enum debug_info_type old_write_symbols = write_symbols;\n+      write_symbols = NO_DEBUG;\n+\n+      /* Now build the constructor for this exception.  */\n+      parmdecls = DECL_ARGUMENTS (ctor);\n+      start_function (NULL_TREE, ctor, 0, 1);\n+      store_parm_decls ();\n+      pushlevel (0);\n+      clear_last_expr ();\n+      push_momentary ();\n+      expand_start_bindings (0);\n+\n+      /* Move all the parameters to the fields, skipping `this'.  */\n+      parmdecls = TREE_CHAIN (parmdecls);\n+      /* Install `name' of this exception handler.  */\n+      DECL_INITIAL (fields) = build_unary_op (ADDR_EXPR, edecl, 0);\n+      fields = TREE_CHAIN (fields);\n+      /* Install all the values.  */\n+      while (fields)\n+\t{\n+\t  /* Set up the initialization for this field.  */\n+\t  DECL_INITIAL (fields) = parmdecls;\n+\t  fields = TREE_CHAIN (fields);\n+\t  parmdecls = TREE_CHAIN (parmdecls);\n+\t}\n+      emit_base_init (t, 0);\n+\n+      finish_function (DECL_SOURCE_LINE (ctor), 1);\n+      write_symbols = old_write_symbols;\n+    }\n+}\n+\n+void\n+end_exception_decls ()\n+{\n+  last_exception_field_types = NULL_TREE;\n+  last_exception_fields = NULL_TREE;\n+}\n+\f\n+/* Statement-level exception semantics.  */\n+\n+void\n+cplus_expand_start_try (implicit)\n+     int implicit;\n+{\n+  tree call_to_setjmp;\n+  tree handler, ref;\n+\n+  /* Start a new block enclosing the whole handler.  */\n+  if (implicit)\n+    {\n+      pushlevel_temporary (1);\n+    }\n+  else\n+    {\n+      pushlevel (0);\n+      clear_last_expr ();\n+      push_momentary ();\n+\n+      /* Encompass whole exception handler in one big binding contour.\n+\t If RAISE should throw out of the whole TRY/EXCEPT block, call\n+\t `expand_start_bindings' with argument of 1.  */\n+      expand_start_bindings (0);\n+    }\n+\n+  /* Allocate handler in that block.  It's real name will come later.\n+     Note that it will be the first name in this binding contour.  */\n+  handler = get_temp_name (EHS_type, 0);\n+  DECL_INITIAL (handler) = error_mark_node;\n+  finish_decl (handler, NULL_TREE, NULL_TREE, 0);\n+\n+  /* Must come after call to `finish_decl', else the cleanup for the temp\n+     for the handler will cause the contour we just created to be popped.  */\n+  if (implicit)\n+    declare_implicit_exception ();\n+\n+  /* Catch via `setjmp'.  */\n+  ref = build_component_ref (handler, get_identifier (\"handler\"), NULL_TREE, 0);\n+  call_to_setjmp = build_function_call (BISJ, build_tree_list (NULL_TREE, ref));\n+\n+  /* RAISE throws to EXCEPT part.  */\n+  expand_start_try (build_binary_op (EQ_EXPR, call_to_setjmp, integer_zero_node, 1), 0, 1);\n+}\n+\n+/* If KEEP is 1, then declarations in the TRY statement are worth keeping.\n+   If KEEP is 2, then the TRY statement was generated by the compiler.\n+   If KEEP is 0, the declarations in the TRY statement contain errors.  */\n+\n+tree\n+cplus_expand_end_try (keep)\n+     int keep;\n+{\n+  tree decls, decl, block;\n+\n+  if (keep < 2)\n+    pop_implicit_try_blocks (NULL_TREE);\n+\n+  decls = getdecls ();\n+\n+  /* Emit code to avoid falling through into a default\n+     handler that might come later.  */\n+  expand_end_try ();\n+\n+  /* Pops binding contour local to TRY, and get the exception handler\n+     object built by `...start_try'.  */\n+  switch (keep)\n+    {\n+    case 0:\n+      expand_end_bindings (decls, 0, 1);\n+      block = poplevel (0, 0, 0);\n+      pop_momentary (); \n+      decl = getdecls ();\n+      break;\n+\n+    case 1:\n+      expand_end_bindings (decls, 1, 1);\n+      block = poplevel (1, 1, 0);\n+      pop_momentary ();\n+      decl = getdecls ();\n+      break;\n+\n+    default:\n+      decl = tree_last (decls);\n+      block = NULL_TREE;\n+      break;\n+    }\n+\n+  my_friendly_assert (TREE_CODE (decl) == VAR_DECL\n+\t\t      && TREE_TYPE (decl) == EHS_type, 203);\n+  if (block)\n+    {\n+      BLOCK_HANDLER_BLOCK (block) = 1;\n+      TREE_USED (block) = 1;\n+    }\n+\n+  /* Pass it back so that its rtl can be bound to its name\n+     (or vice versa).  */\n+  return decl;\n+}\n+\n+void\n+cplus_expand_start_except (name, decl)\n+     tree name, decl;\n+{\n+  int yes;\n+  tree tmp, init;\n+\n+  expand_start_except (0, 1);\n+\n+  /* This is internal `eh'.  */\n+  current_exception_decl = decl;\n+  current_exception_name_as_rtx\n+    = expand_expr (build (COMPONENT_REF, ptr_type_node,\n+\t\t\t  current_exception_decl, TREE_OPERAND (EHS_name, 1)),\n+\t\t   0, 0, 0);\n+  init = build (COMPONENT_REF, ptr_type_node, decl, TREE_OPERAND (EHS_parms, 1));\n+  current_exception_parms_as_rtx = expand_expr (init, 0, 0, 0);\n+\n+  if (name)\n+    {\n+      /* Get the exception object into scope (user declared `ex').  */\n+      tmp = pushdecl (build_decl (VAR_DECL, name, ptr_type_node));\n+      DECL_INITIAL (tmp) = error_mark_node;\n+      finish_decl (tmp, init, 0, 0);\n+    }\n+  current_exception_type = NULL_TREE;\n+  yes = suspend_momentary ();\n+  if (name)\n+    {\n+      /* From now on, send the user to our faked-up object.  */\n+      current_exception_object = build1 (INDIRECT_REF, void_type_node, tmp);\n+      IDENTIFIER_LOCAL_VALUE (name) = current_exception_object;\n+    }\n+  resume_momentary (yes);\n+\n+  /* Pop exception handler stack.  */\n+  expand_assignment (EHS_decl, EHS_prev, 0, 0);\n+}\n+\n+/* Generate the call to `unhandled_exception' that is appropriate\n+   for this particular unhandled exception.  */\n+static tree\n+call_to_unhandled_exception ()\n+{\n+  extern int lineno;\n+  extern tree combine_strings ();\n+  tree parms = tree_cons (NULL_TREE,\n+\t\t\t  combine_strings (build_string (strlen (input_filename + 1), input_filename)),\n+\t\t\t  build_tree_list (NULL_TREE, build_int_2 (lineno, 0)));\n+  return build_function_call (BIUE, parms);\n+}\n+\n+/* Note that this must be mirror image of `...start_try'.\n+   DFAULT is the default clause, if there was one.\n+   DFAULT is ERROR_MARK_NODE when this ends an implicit handler.  */\n+void\n+cplus_expand_end_except (dfault)\n+     tree dfault;\n+{\n+  extern tree expand_end_except (); /* stmt.c.  */\n+  tree decls, raised;\n+\n+  if (dfault == NULL_TREE)\n+    {\n+      /* Uncaught exception at outermost level.  If raised locally,\n+\t reraise the exception.  Otherwise, generate code to call `abort'.  */\n+      if (in_try_block (1) == 0)\n+\t{\n+\t  expand_start_cond (build (EQ_EXPR, integer_type_node,\n+\t\t\t\t    exception_throw_decl, integer_zero_node), 0);\n+\t  expand_expr (call_to_unhandled_exception (), 0, VOIDmode, 0);\n+\t  expand_end_cond ();\n+\t}\n+      /* Try the next handler.  */\n+      if (! expand_escape_except ())\n+\tcompiler_error (\"except nesting botch\");\n+    }\n+\n+  raised = expand_end_except ();\n+\n+  decls = getdecls ();\n+  expand_end_bindings (decls, decls != 0, 1);\n+  poplevel (decls != 0, 1, 0);\n+\n+  /* Implicit handlers do not use the momentary obstack.  */\n+  if (dfault != error_mark_node)\n+    pop_momentary ();\n+\n+  if (! in_try_block (1))\n+    {\n+      /* Check that this function is not raising exceptions\n+\t it is not supposed to.  */\n+      while (raised)\n+\t{\n+\t  cp_error (\"exception `%D' raised but not declared raisable\",\n+\t\t      TREE_VALUE (raised));\n+\t  raised = TREE_CHAIN (raised);\n+\t}\n+    }\n+  else if (dfault == NULL_TREE || dfault == error_mark_node)\n+    {\n+      expand_start_cond (build (NE_EXPR, integer_type_node,\n+\t\t\t\texception_throw_decl,\n+\t\t\t\tinteger_zero_node), 0);\n+      /* We fell off the end of this try block.  Try going to the next.\n+\t The escape_label will be the beginning of the next try block.  */\n+      if (! expand_escape_except ())\n+\tcompiler_error (\"except nesting botch\");\n+      expand_end_cond ();\n+    }\n+}\n+\n+/* Generate code to raise exception RAISE_ID.\n+   If EXP is NULL_TREE, then PARMS is the list of parameters to use\n+   for constructing this exception.\n+   If EXP is non-NULL, then it is an already constructed object\n+   of the kind that we want.\n+\n+   FOR_RERAISE is non-zero if this raise is called by reraise.  In\n+   this case we do not need to emit extra gotos to avoid warning messages;\n+   the caller will do that once after all the exceptions it reraises\n+   are handled and raised.  */\n+void\n+cplus_expand_raise (raise_id, parms, exp, for_reraise)\n+     tree raise_id;\n+     tree parms;\n+     tree exp;\n+     int for_reraise;\n+{\n+  /* Allocate new exception of appropriate type, passing\n+     PARMS to its constructor.  */\n+  tree cname, name;\n+  tree decl;\n+  tree xexp = exp;\n+\n+  cname = lookup_exception_cname (current_class_type, current_class_name, raise_id);\n+  if (cname == error_mark_node)\n+    return;\n+  name = TREE_VALUE (raise_id);\n+\n+  decl = lookup_exception_object (cname, name, 1);\n+  if (decl == NULL_TREE)\n+    return;\n+\n+  if (exp == NULL_TREE)\n+    {\n+      exp = build_method_call (NULL_TREE, name, parms, NULL_TREE, LOOKUP_COMPLAIN);\n+      if (exp == error_mark_node)\n+\treturn;\n+    }\n+\n+  if (in_try_block (1))\n+    {\n+      expand_raise (decl);\n+    }\n+  else if (! current_function_decl)\n+    {\n+      if (xexp == NULL_TREE)\n+\tcp_error (\"invalid raise of `%D' outside of functions\", decl);\n+      else\n+\tcp_error (\"invalid reraise of `%D' outside of functions\", decl);\n+    }\n+  else\n+    {\n+      /* Test this raise against what this function permits.  */\n+      tree names = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl));\n+      while (names)\n+\t{\n+\t  if (decl == TREE_TYPE (names))\n+\t    break;\n+\t  names = TREE_CHAIN (names);\n+\t}\n+      if (names == NULL_TREE)\n+\t{\n+\t  error (\"current function not declared to raise exception `%s'\",\n+\t\t IDENTIFIER_POINTER (name));\n+\t  return;\n+\t}\n+    }\n+\n+  store_expr (exp, EHS_parms_as_rtx, 0);\n+\n+  /* Set the global exception handler stack's NAME field\n+     to the `name' of this exception.  The global exception\n+     handler stack is the container for the exception object\n+     we just built.\n+\n+     We go through a function call to make life easier when debugging.  */\n+#if 0\n+  expand_assignment (EHS_name, build_unary_op (ADDR_EXPR, decl, 0), 0, 0);\n+#else\n+  parms = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, EHS_name, 0),\n+\t\t     build_tree_list (NULL_TREE,\n+\t\t\t\t      build_unary_op (ADDR_EXPR, decl, 0)));\n+  expand_expr (build_function_call (BIR, parms), 0, 0, 0);\n+#endif\n+\n+  /* Activate thrower.  If we are inside a TRY statement,\n+     we can cheat and not do this, saving a longjmp.  */\n+  if (in_try_block (1) == 0)\n+    {\n+      sets_exception_throw_decl = 1;\n+      emit_move_insn (DECL_RTL (exception_throw_decl), const1_rtx);\n+    }\n+\n+  if (xexp == NULL_TREE)\n+    {    \n+      /* Invoke destructors for current procedure or handler.  */\n+      if (! expand_escape_except ())\n+\tcompiler_error (\"except nesting botch\");\n+      /* Throw via `longjmp'... Done as side-effect of goto.  */\n+    }\n+  /* To avoid spurious warning messages, we add a goto to the end\n+     of the function.  This code is dead, and the compiler should\n+     know how to delete it, but for now, we are stuck with it.  */\n+  if (! for_reraise\n+      && TREE_TYPE (DECL_RESULT (current_function_decl)) != void_type_node)\n+    expand_null_return ();\n+}\n+\n+extern tree cplus_exception_name ();\n+\n+tree\n+ansi_exception_object_lookup (type)\n+     tree type;\n+{\n+  tree raise_id = cplus_exception_name (type);\n+  tree decl;\n+\n+  decl = IDENTIFIER_GLOBAL_VALUE (raise_id);\n+  if (decl == NULL_TREE || TREE_CODE (decl) != VAR_DECL)\n+    {\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+      decl = build_decl (VAR_DECL, raise_id, ptr_type_node);\n+      TREE_PUBLIC (decl) = 1;\n+      TREE_STATIC (decl) = 1;\n+      pushdecl_top_level (decl);\n+      make_decl_rtl (decl, (char*)0, 1);\n+      pop_obstacks ();\n+    }\n+  return decl;\n+}\n+\n+/* Generate code to throw an exception using EXP.\n+   Usng ANSI syntax and semantics.\n+   If EXP is NULL_TREE< re-raise instead. */\n+\n+void\n+cplus_expand_throw (exp)\n+     tree exp;\n+{\n+  tree parms;\n+  int for_reraise;\n+  /* Allocate new exception of appropriate type, passing\n+     PARMS to its constructor.  */\n+  tree decl = ansi_exception_object_lookup (TREE_TYPE (exp));\n+  tree xexp = exp;\n+\n+  if (in_try_block (1))\n+    {\n+#if 1\n+      my_friendly_abort (35);\n+#else\n+      expand_raise (decl);\n+#endif\n+    }\n+  else if (! current_function_decl)\n+    error (\"invalid throw outside of functions\");\n+  else\n+    {\n+#if 0\n+      /* Test this raise against what this function permits.  */\n+      tree names = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl));\n+      while (names)\n+\t{\n+\t  if (decl == TREE_TYPE (names))\n+\t    break;\n+\t  names = TREE_CHAIN (names);\n+\t}\n+      if (names == NULL_TREE)\n+\t{\n+\t  error (\"current function not declared to raise exception `%s'\",\n+\t\t IDENTIFIER_POINTER (name));\n+\t  return;\n+\t}\n+#endif\n+    }\n+\n+  store_expr (exp, EHS_parms_as_rtx, 0);\n+\n+  /* Set the global exception handler stack's NAME field\n+     to the `name' of this exception.  The global exception\n+     handler stack is the container for the exception object\n+     we just built.\n+\n+     We go through a function call to make life easier when debugging.  */\n+#if 0\n+  expand_assignment (EHS_name, build_unary_op (ADDR_EXPR, decl, 0), 0, 0);\n+#else\n+  parms = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, EHS_name, 0),\n+\t\t     build_tree_list (NULL_TREE,\n+\t\t\t\t      build_unary_op (ADDR_EXPR, decl, 0)));\n+  expand_expr (build_function_call (BIR, parms), 0, 0, 0);\n+#endif\n+\n+  /* Activate thrower.  If we are inside a TRY statement,\n+     we can cheat and not do this, saving a longjmp.  */\n+  if (in_try_block (1) == 0)\n+    {\n+      sets_exception_throw_decl = 1;\n+      emit_move_insn (DECL_RTL (exception_throw_decl), const1_rtx);\n+    }\n+\n+  if (xexp == NULL_TREE)\n+    {    \n+      /* Invoke destructors for current procedure or handler.  */\n+      if (! expand_escape_except ())\n+\tcompiler_error (\"except nesting botch\");\n+      /* Throw via `longjmp'... Done as side-effect of goto.  */\n+    }\n+\n+  /* XXX: for_reraise is never set above here.  */\n+  /* To avoid spurious warning messages, we add a goto to the end\n+     of the function.  This code is dead, and the compiler should\n+     know how to delete it, but for now, we are stuck with it.  */\n+  if (! for_reraise\n+      && TREE_TYPE (DECL_RESULT (current_function_decl)) != void_type_node)\n+    expand_null_return ();\n+}\n+\n+tree\n+cplus_expand_start_catch (raise_id)\n+     tree raise_id;\n+{\n+  tree cname = lookup_exception_cname (current_class_type, current_class_name, raise_id);\n+  tree decl;\n+  tree cond;\n+\n+  if (cname == error_mark_node)\n+    {\n+      decl = error_mark_node;\n+      cond = error_mark_node;\n+    }\n+  else\n+    {\n+      decl = lookup_exception_object (cname, TREE_VALUE (raise_id), 1);\n+      if (decl == NULL_TREE)\n+\tcond = error_mark_node;\n+      else\n+\tcond = build_binary_op (EQ_EXPR, build_unary_op (ADDR_EXPR, decl, 0),\n+\t\t\t\tbuild (COMPONENT_REF, ptr_type_node,\n+\t\t\t\t       current_exception_decl,\n+\t\t\t\t       TREE_OPERAND (EHS_name, 1)),\n+\t\t\t\t1);\n+    }\n+  expand_start_cond (cond, 0);\n+\n+  /* Does nothing right now.  */\n+  expand_catch (decl);\n+  if (current_exception_type\n+      && TYPE_NEEDS_DESTRUCTOR (current_exception_type))\n+    {\n+      /* Make a cleanup for the name-specific exception object now in scope.  */\n+      tree cleanup = maybe_build_cleanup (current_exception_object);\n+      expand_start_bindings (0);\n+      expand_decl_cleanup (NULL_TREE, cleanup);\n+    }\n+  return decl;\n+}\n+tree\n+ansi_expand_start_catch (raise_type)\n+     tree raise_type;\n+{\n+  tree decl = ansi_exception_object_lookup (raise_type);\n+  tree cond;\n+\n+  if (decl == NULL_TREE)\n+      cond = error_mark_node;\n+  else\n+      cond = build_binary_op (EQ_EXPR, build_unary_op (ADDR_EXPR, decl, 0),\n+\t\t\t      build (COMPONENT_REF, ptr_type_node,\n+\t\t\t\t     current_exception_decl,\n+\t\t\t\t     TREE_OPERAND (EHS_name, 1)),\n+\t\t\t      1);\n+  expand_start_cond (cond, 0);\n+\n+  /* Does nothing right now.  */\n+  expand_catch (decl);\n+  return decl;\n+}\n+\n+void\n+cplus_expand_end_catch (for_reraise)\n+     int for_reraise;\n+{\n+  if (current_exception_type\n+      && TYPE_NEEDS_DESTRUCTOR (current_exception_type))\n+    {\n+      /* Destroy the specific exception object now in scope.  */\n+      expand_end_bindings (getdecls (), 0, 1);\n+    }\n+  if (for_reraise)\n+    {\n+      if (! expand_escape_except ())\n+\tmy_friendly_abort (36);\n+    }\n+  else\n+    {\n+      if (! expand_end_catch ())\n+\tmy_friendly_abort (37);\n+    }\n+  expand_end_cond ();\n+}\n+\n+/* Reraise an exception.\n+   If EXCEPTIONS is NULL_TREE, it means reraise whatever exception was caught.\n+   If EXCEPTIONS is an IDENTIFIER_NODE, it means reraise the exception\n+   object named by EXCEPTIONS.  This must be a variable declared in\n+   an `except' clause.\n+   If EXCEPTIONS is a TREE_LIST, it is the list of exceptions we are\n+   willing to reraise.  */\n+\n+void\n+cplus_expand_reraise (exceptions)\n+     tree exceptions;\n+{\n+  tree ex_ptr;\n+  tree ex_object = current_exception_object;\n+  rtx ex_ptr_as_rtx;\n+\n+  if (exceptions && TREE_CODE (exceptions) == IDENTIFIER_NODE)\n+    {\n+      /* Don't get tripped up if its TREE_TYPE is `error_mark_node'.  */\n+      ex_object = IDENTIFIER_LOCAL_VALUE (exceptions);\n+      if (ex_object == NULL_TREE || TREE_CODE (ex_object) != INDIRECT_REF)\n+\t{\n+\t  error (\"`%s' is not an exception decl\", IDENTIFIER_POINTER (exceptions));\n+\t  return;\n+\t}\n+      my_friendly_assert (TREE_CODE (TREE_OPERAND (ex_object, 0)) == VAR_DECL,\n+\t\t\t  204);\n+      exceptions = NULL_TREE;\n+    }\n+\n+  ex_ptr = build1 (NOP_EXPR, ptr_type_node, TREE_OPERAND (ex_object, 0));\n+  ex_ptr_as_rtx = expand_expr (ex_ptr, 0, 0, 0);\n+\n+  /* reraise ALL, used by compiler.  */\n+  if (exceptions == NULL_TREE)\n+    {\n+      /* Now treat reraise like catch/raise.  */\n+      expand_catch (error_mark_node);\n+      expand_raise (error_mark_node);\n+      emit_move_insn (EHS_name_as_rtx, current_exception_name_as_rtx);\n+      store_expr ((tree) EHS_parms_as_rtx, current_exception_parms_as_rtx, 0);\n+      if (in_try_block (1) == 0)\n+\t{\n+\t  sets_exception_throw_decl = 1;\n+\t  emit_move_insn (DECL_RTL (exception_throw_decl), const1_rtx);\n+\t}\n+      /* Set to zero so that destructor will not be called.  */\n+      emit_move_insn (ex_ptr_as_rtx, const0_rtx);\n+      if (! expand_escape_except ())\n+\tmy_friendly_abort (38);\n+\n+      /* To avoid spurious warning messages, we add a goto to the end\n+\t of the function.  This code is dead, and the compiler should\n+\t know how to delete it, but for now, we are stuck with it.  */\n+      if (TREE_TYPE (DECL_RESULT (current_function_decl)) != void_type_node)\n+\texpand_null_return ();\n+\n+      return;\n+    }\n+\n+  /* reraise from a list of exceptions.  */\n+  while (exceptions)\n+    {\n+      tree type = lookup_exception_type (current_class_type, current_class_name,\n+\t\t\t\t\t exceptions);\n+      if (type == NULL_TREE)\n+\t{\n+\t  error (\"`%s' is not an exception type\",\n+\t\t IDENTIFIER_POINTER (TREE_VALUE (exceptions)));\n+\t  current_exception_type = NULL_TREE;\n+\t  TREE_TYPE (ex_object) = error_mark_node;\n+\t  TREE_TYPE (ex_ptr) = error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  current_exception_type = type;\n+\t  /* In-place union.  */\n+\t  TREE_TYPE (ex_object) = type;\n+\t  TREE_TYPE (ex_ptr) = TYPE_POINTER_TO (type);\n+\t}\n+\n+      /* Now treat reraise like catch/raise.  */\n+      cplus_expand_start_catch (exceptions);\n+      cplus_expand_raise (exceptions, NULL_TREE, ex_ptr, 1);\n+      /* Set to zero so that destructor will not be called.  */\n+      if (TREE_TYPE (ex_ptr) != error_mark_node)\n+\temit_move_insn (ex_ptr_as_rtx, const0_rtx);\n+      cplus_expand_end_catch (1);\n+      exceptions = TREE_CHAIN (exceptions);\n+    }\n+  /* Don't propagate any unhandled exceptions.  */\n+  expand_expr (call_to_unhandled_exception (), 0, VOIDmode, 0);\n+\n+  /* To avoid spurious warning messages, we add a goto to the end\n+     of the function.  This code is dead, and the compiler should\n+     know how to delete it, but for now, we are stuck with it.  */\n+  if (TREE_TYPE (DECL_RESULT (current_function_decl)) != void_type_node)\n+    expand_null_return ();\n+}\n+\f\n+void\n+setup_exception_throw_decl ()\n+{\n+  tree call_to_longjmp, parms;\n+\n+  int old = suspend_momentary ();\n+\n+  exception_throw_decl = build_decl (VAR_DECL, get_identifier (THROW_NAME), integer_type_node);\n+  pushdecl (exception_throw_decl);\n+  parms = tree_cons (NULL_TREE, EHS_handler,\n+\t\t     build_tree_list (0, integer_one_node));\n+  call_to_longjmp = build_function_call (BILJ, parms);\n+\n+  expand_decl (exception_throw_decl);\n+  expand_decl_cleanup (exception_throw_decl,\n+\t\t       build (COND_EXPR, void_type_node,\n+\t\t\t      exception_throw_decl,\n+\t\t\t      call_to_longjmp, integer_zero_node));\n+  DECL_INITIAL (exception_throw_decl) = integer_zero_node;\n+  sets_exception_throw_decl = 0;\n+  resume_momentary (old);\n+\n+  /* Cache these, since they won't change throughout the function.  */\n+  EHS_parms_as_rtx = expand_expr (EHS_parms, 0, 0, 0);\n+  EHS_name_as_rtx = expand_expr (EHS_name, 0, 0, 0);\n+}\n+\n+void\n+init_exception_processing ()\n+{\n+  extern tree build_function_type (), define_function ();\n+  extern tree unhandled_exception_fndecl;\n+  tree cname = get_identifier (\"ExceptionHandler\");\n+  tree field, chain;\n+  tree ctor, dtor;\n+  tree jmp_buf_type = build_array_type (integer_type_node,\n+\t\t\t\t\tbuild_index_type (build_int_2 (_JBLEN-1, 0)));\n+  tree jmp_buf_arg_type = build_pointer_type (integer_type_node);\n+\n+  tree parmtypes = hash_tree_chain (jmp_buf_arg_type, void_list_node);\n+  tree setjmp_fndecl, longjmp_fndecl, raise_fndecl;\n+\n+  int old_interface_only = interface_only;\n+  int old_interface_unknown = interface_unknown;\n+  interface_only = 1;\n+  interface_unknown = 0;\n+  EHS_type = xref_tag (record_type_node, cname, NULL_TREE, 0);\n+  push_lang_context (lang_name_c);\n+  setjmp_fndecl = define_function (\"setjmp\",\n+\t\t\t\t   build_function_type (integer_type_node,\n+\t\t\t\t\t\t\tparmtypes),\n+\t\t\t\t   NOT_BUILT_IN, pushdecl, 0);\n+  BISJ = default_conversion (setjmp_fndecl);\n+  parmtypes = hash_tree_chain (jmp_buf_arg_type,\n+\t\t\t       hash_tree_chain (integer_type_node, void_list_node));\n+  longjmp_fndecl = define_function (\"longjmp\",\n+\t\t\t\t    build_function_type (void_type_node, parmtypes),\n+\t\t\t\t    NOT_BUILT_IN, pushdecl, 0);\n+  raise_fndecl = define_function (\"__raise_exception\",\n+\t\t\t\t  build_function_type (void_type_node,\n+\t\t\t\t\t\t       hash_tree_chain (ptr_type_node,\n+\t\t\t\t\t\t\t\t\thash_tree_chain (build_pointer_type (ptr_type_node), void_list_node))),\n+\t\t\t\t  NOT_BUILT_IN, pushdecl, 0);\n+  BILJ = default_conversion (longjmp_fndecl);\n+  BIR = default_conversion (raise_fndecl);\n+  BIUE = default_conversion (unhandled_exception_fndecl);\n+\n+  pop_lang_context ();\n+\n+  /* finish_struct will pop this.  */\n+  pushclass (EHS_type, 0);\n+  field = build_lang_field_decl (FIELD_DECL, get_identifier (\"parms\"), ptr_type_node);\n+  chain = field;\n+  field = build_lang_field_decl (FIELD_DECL, get_identifier (\"name\"),\n+\t\t\t\t build_pointer_type (default_function_type));\n+  TREE_CHAIN (field) = chain;\n+  chain = field;\n+  field = build_lang_field_decl (FIELD_DECL, get_identifier (\"handler\"), jmp_buf_type);\n+  TREE_CHAIN (field) = chain;\n+  chain = field;\n+  field = build_lang_field_decl (FIELD_DECL, get_identifier (\"prev\"),\n+\t\t\t\t TYPE_POINTER_TO (EHS_type));\n+  TREE_CHAIN (field) = chain;\n+  chain = field;\n+\n+  ctor = build_lang_decl (FUNCTION_DECL, cname,\n+\t\t\t  build_cplus_method_type (EHS_type, TYPE_POINTER_TO (EHS_type), void_list_node));\n+  DECL_CONSTRUCTOR_P (ctor) = 1;\n+  TREE_STATIC (ctor) = 1;\n+  TREE_PUBLIC (ctor) = 1;\n+  DECL_EXTERNAL (ctor) = 1;\n+  grokclassfn (EHS_type, cname, ctor, NO_SPECIAL, 0);\n+  grok_ctor_properties (EHS_type, ctor);\n+  finish_decl (pushdecl (ctor), NULL_TREE, NULL_TREE, 0);\n+  /* Must copy the node here because the FUNCTION_DECL\n+     used inside the struct ain't the same as the\n+     FUNCTION_DECL we stick into the global binding\n+     contour.  */\n+  ctor = copy_node (ctor);\n+  TREE_CHAIN (ctor) = chain;\n+  chain = ctor;\n+  dtor = build_lang_decl (FUNCTION_DECL, cname,\n+\t\t\t  build_cplus_method_type (EHS_type, TYPE_POINTER_TO (EHS_type), void_list_node));\n+  TREE_STATIC (dtor) = 1;\n+  TREE_PUBLIC (dtor) = 1;\n+  DECL_EXTERNAL (dtor) = 1;\n+  grokclassfn (EHS_type, cname, dtor, DTOR_FLAG, 0);\n+  finish_decl (pushdecl (dtor), NULL_TREE, NULL_TREE, 0);\n+  /* Copy for the same reason as copying ctor.  */\n+  dtor = copy_node (dtor);\n+  TREE_CHAIN (dtor) = chain;\n+  chain = dtor;\n+  TYPE_HAS_CONSTRUCTOR (EHS_type) = 1;\n+  TYPE_HAS_DESTRUCTOR (EHS_type) = 1;\n+  finish_struct (EHS_type, temp_tree_cons (NULL_TREE, chain, NULL_TREE), 0);\n+  interface_only = old_interface_only;\n+  interface_unknown = old_interface_unknown;\n+}\n+\n+void\n+init_exception_processing_1 ()\n+{\n+  register tree EHS_id = get_identifier (\"exceptionHandlerStack\");\n+\n+  EHS_decl = IDENTIFIER_GLOBAL_VALUE (EHS_id);\n+\n+  /* If we have no other definition, default to library implementation.  */\n+  if (EHS_decl == NULL_TREE)\n+    {\n+      EHS_decl = build_decl (VAR_DECL, EHS_id, TYPE_POINTER_TO (EHS_type));\n+      /* If we don't push this, its definition, should it be encountered,\n+\t will not be seen.  */\n+      EHS_decl = pushdecl (EHS_decl);\n+      DECL_EXTERNAL (EHS_decl) = 1;\n+      TREE_STATIC (EHS_decl) = 1;\n+      TREE_PUBLIC (EHS_decl) = 1;\n+      finish_decl (EHS_decl, NULL_TREE, NULL_TREE, 0);\n+    }\n+  else if (TREE_CODE (EHS_decl) != VAR_DECL\n+\t   || TREE_TYPE (EHS_decl) != TYPE_POINTER_TO (EHS_type))\n+    fatal (\"exception handling declarations conflict with compiler's internal model\");\n+\n+  if (EHS_prev == NULL_TREE)\n+    {\n+      register tree EHS_DECL = build1 (INDIRECT_REF, EHS_type, EHS_decl);\n+      EHS_prev = build_component_ref (EHS_DECL, get_identifier (\"prev\"), 0, 0);\n+      EHS_handler = build_component_ref (EHS_DECL, get_identifier (\"handler\"), 0, 0);\n+      EHS_parms = build_component_ref (EHS_DECL, get_identifier (\"parms\"), 0, 0);\n+      EHS_name = build_component_ref (EHS_DECL, get_identifier (\"name\"), 0, 0);\n+    }\n+}"}, {"sha": "c606ef06871cea00451f0d5ce59da73f41f9612d", "filename": "gcc/cp/expr.c", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,268 @@\n+/* Convert language-specific tree expression to rtl instructions,\n+   for GNU compiler.\n+   Copyright (C) 1988, 1992, 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"expr.h\"\n+#include \"cp-tree.h\"\n+\n+#undef NULL\n+#define NULL 0\n+\n+/* Hook used by expand_expr to expand language-specific tree codes.  */\n+\n+rtx\n+cplus_expand_expr (exp, target, tmode, modifier)\n+     tree exp;\n+     rtx target;\n+     enum machine_mode tmode;\n+     enum expand_modifier modifier;\n+{\n+  tree type = TREE_TYPE (exp);\n+  register enum machine_mode mode = TYPE_MODE (type);\n+  register enum tree_code code = TREE_CODE (exp);\n+  rtx original_target = target;\n+  int ignore = target == const0_rtx;\n+\n+  if (ignore)\n+    target = 0, original_target = 0;\n+\n+  /* No sense saving up arithmetic to be done\n+     if it's all in the wrong mode to form part of an address.\n+     And force_operand won't know whether to sign-extend or zero-extend.  */\n+\n+  if (mode != Pmode && modifier == EXPAND_SUM)\n+    modifier = EXPAND_NORMAL;\n+\n+  switch (code)\n+    {\n+    case NEW_EXPR:\n+      {\n+\t/* Something needs to be initialized, but we didn't know\n+\t   where that thing was when building the tree.  For example,\n+\t   it could be the return value of a function, or a parameter\n+\t   to a function which lays down in the stack, or a temporary\n+\t   variable which must be passed by reference.\n+\n+\t   Cleanups are handled in a language-specific way: they\n+\t   might be run by the called function (true in GNU C++\n+\t   for parameters with cleanups), or they might be\n+\t   run by the caller, after the call (true in GNU C++\n+\t   for other cleanup needs).  */\n+\n+\ttree func = TREE_OPERAND (exp, 0);\n+\ttree args = TREE_OPERAND (exp, 1);\n+\ttree type = TREE_TYPE (exp), slot;\n+\ttree fn_type = TREE_TYPE (TREE_TYPE (func));\n+\ttree return_type = TREE_TYPE (fn_type);\n+\ttree call_exp;\n+\trtx call_target, return_target;\n+\tint pcc_struct_return = 0;\n+\n+\t/* The expression `init' wants to initialize what\n+\t   `target' represents.  SLOT holds the slot for TARGET.  */\n+\tslot = TREE_OPERAND (exp, 2);\n+\n+\tif (target == 0)\n+\t  {\n+\t    /* Should always be called with a target in BLKmode case.  */\n+\t    my_friendly_assert (mode != BLKmode, 205);\n+\t    my_friendly_assert (DECL_RTL (slot) != 0, 206);\n+\n+\t    target = gen_reg_rtx (mode);\n+\t  }\n+\n+\t/* The target the initializer will initialize (CALL_TARGET)\n+\t   must now be directed to initialize the target we are\n+\t   supposed to initialize (TARGET).  The semantics for\n+\t   choosing what CALL_TARGET is is language-specific,\n+\t   as is building the call which will perform the\n+\t   initialization.  It is left here to show the choices that\n+\t   exist for C++.  */\n+\t   \n+\tif (TREE_CODE (func) == ADDR_EXPR\n+\t    && TREE_CODE (TREE_OPERAND (func, 0)) == FUNCTION_DECL\n+\t    && DECL_CONSTRUCTOR_P (TREE_OPERAND (func, 0)))\n+\t  {\n+\t    type = TYPE_POINTER_TO (type);\n+\t    /* Don't clobber a value that might be part of a default\n+\t       parameter value.  */\n+\t    if (TREE_PERMANENT (args))\n+\t      args = tree_cons (0, build1 (ADDR_EXPR, type, slot),\n+\t\t\t\tTREE_CHAIN (args));\n+\t    else\n+\t      TREE_VALUE (args) = build1 (ADDR_EXPR, type, slot);\n+\t    call_target = 0;\n+\t  }\n+\telse if (TREE_CODE (return_type) == REFERENCE_TYPE)\n+\t  {\n+\t    type = return_type;\n+\t    call_target = 0;\n+\t  }\n+\telse\n+\t  {\n+#ifdef PCC_STATIC_STRUCT_RETURN\n+\t    pcc_struct_return = 1;\n+\t    call_target = 0;\n+#else\n+\t    call_target = target;\n+#endif\n+\t  }\n+\tif (call_target)\n+\t  {\n+\t    preserve_temp_slots (call_target);\n+\n+\t    /* Make this a valid memory address now.  The code below assumes\n+\t       that it can compare rtx and make assumptions based on the\n+\t       result.  The assumptions are true only if the address was\n+\t       valid to begin with.  */\n+\t    call_target = validize_mem (call_target);\n+\t  }\n+\n+\tpreserve_temp_slots (DECL_RTL (slot));\n+\tcall_exp = build (CALL_EXPR, type, func, args, 0);\n+\tTREE_SIDE_EFFECTS (call_exp) = 1;\n+\treturn_target = expand_expr (call_exp, call_target, mode, 0);\n+\tfree_temp_slots ();\n+\tif (call_target == 0)\n+\t  {\n+\t    if (pcc_struct_return)\n+\t      {\n+\t\ttree init = build (RTL_EXPR, type, 0, return_target);\n+\t\tTREE_ADDRESSABLE (init) = 1;\n+\t\texpand_aggr_init (slot, init, 0);\n+\t\tif (TYPE_NEEDS_DESTRUCTOR (type))\n+\t\t  {\n+\t\t    init = build (RTL_EXPR, build_reference_type (type), 0,\n+\t\t\t\t  XEXP (return_target, 0));\n+\t\t    init = maybe_build_cleanup (convert_from_reference (init));\n+\t\t    if (init != NULL_TREE)\n+\t\t      expand_expr (init, 0, 0, 0);\n+\t\t  }\n+\t\tcall_target = return_target = DECL_RTL (slot);\n+\t      }\n+\t    else\n+\t      call_target = return_target;\n+\t  }\n+\n+\tif (call_target != return_target)\n+\t  {\n+\t    my_friendly_assert (! TYPE_NEEDS_CONSTRUCTING (type), 317);\n+\t    if (GET_MODE (return_target) == BLKmode)\n+\t      emit_block_move (call_target, return_target, expr_size (exp),\n+\t\t\t       TYPE_ALIGN (type) / BITS_PER_UNIT);\n+\t    else\n+\t      emit_move_insn (call_target, return_target);\n+\t  }\n+\n+\tif (TREE_CODE (return_type) == REFERENCE_TYPE)\n+\t  {\n+\t    tree init;\n+\n+\t    if (GET_CODE (call_target) == REG\n+\t\t&& REGNO (call_target) < FIRST_PSEUDO_REGISTER)\n+\t      my_friendly_abort (39);\n+\n+\t    type = TREE_TYPE (exp);\n+\n+\t    init = build (RTL_EXPR, return_type, 0, call_target);\n+\t    /* We got back a reference to the type we want.  Now initialize\n+\t       target with that.  */\n+\t    expand_aggr_init (slot, init, 0);\n+\t  }\n+\n+\tif (DECL_RTL (slot) != target)\n+\t  emit_move_insn (DECL_RTL (slot), target);\n+\treturn DECL_RTL (slot);\n+      }\n+\n+    case OFFSET_REF:\n+      {\n+#if 1\n+\treturn expand_expr (default_conversion (resolve_offset_ref (exp)),\n+\t\t\t    target, tmode, EXPAND_NORMAL);\n+#else\n+\t/* This is old crusty code, and does not handle all that the\n+\t   resolve_offset_ref function does.  (mrs) */\n+\ttree base = build_unary_op (ADDR_EXPR, TREE_OPERAND (exp, 0), 0);\n+\ttree offset = build_unary_op (ADDR_EXPR, TREE_OPERAND (exp, 1), 0);\n+\treturn expand_expr (build (PLUS_EXPR, TREE_TYPE (exp), base, offset),\n+\t\t\t    target, tmode, EXPAND_NORMAL);\n+#endif\n+      }\n+\n+    default:\n+      break;\n+    }\n+  my_friendly_abort (40);\n+  /* NOTREACHED */\n+  return NULL;\n+}\n+\n+void\n+init_cplus_expand ()\n+{\n+  lang_expand_expr = cplus_expand_expr;\n+}\n+\n+/* If DECL had its rtl moved from where callers expect it\n+   to be, fix it up.  RESULT is the nominal rtl for the RESULT_DECL,\n+   which may be a pseudo instead of a hard register.  */\n+\n+void\n+fixup_result_decl (decl, result)\n+     tree decl;\n+     rtx result;\n+{\n+  if (REG_P (result))\n+    {\n+      if (REGNO (result) >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  rtx real_decl_result;\n+\n+#ifdef FUNCTION_OUTGOING_VALUE\n+\t  real_decl_result\n+\t    = FUNCTION_OUTGOING_VALUE (TREE_TYPE (decl), current_function_decl);\n+#else\n+\t  real_decl_result\n+\t    = FUNCTION_VALUE (TREE_TYPE (decl), current_function_decl);\n+#endif\n+\t  REG_FUNCTION_VALUE_P (real_decl_result) = 1;\n+\t  result = real_decl_result;\n+\t}\n+      emit_move_insn (result, DECL_RTL (decl));\n+      emit_insn (gen_rtx (USE, VOIDmode, result));\n+    }\n+}\n+\n+/* Return nonzero iff DECL is memory-based.  The DECL_RTL of\n+   certain const variables might be a CONST_INT, or a REG\n+   in some cases.  We cannot use `memory_operand' as a test\n+   here because on most RISC machines, a variable's address\n+   is not, by itself, a legitimate address.  */\n+int\n+decl_in_memory_p (decl)\n+     tree decl;\n+{\n+  return DECL_RTL (decl) != 0 && GET_CODE (DECL_RTL (decl)) == MEM;\n+}"}, {"sha": "20eadb6efbca3eed46ab13663ea7786fa420d7a8", "filename": "gcc/cp/gxx.gperf", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,91 @@\n+%{\n+/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n+%}\n+struct resword { char *name; short token; enum rid rid;};\n+%%\n+__alignof, ALIGNOF, NORID\n+__alignof__, ALIGNOF, NORID\n+__asm, GCC_ASM_KEYWORD, NORID\n+__asm__, GCC_ASM_KEYWORD, NORID\n+__attribute, ATTRIBUTE, NORID\n+__attribute__, ATTRIBUTE, NORID\n+__classof, CLASSOF, NORID\n+__classof__, CLASSOF, NORID\n+__const, TYPE_QUAL, RID_CONST\n+__const__, TYPE_QUAL, RID_CONST\n+__extension__, EXTENSION, NORID\n+__headof, HEADOF, NORID\n+__headof__, HEADOF, NORID\n+__inline, SCSPEC, RID_INLINE\n+__inline__, SCSPEC, RID_INLINE\n+__label__, LABEL, NORID\n+__signed, TYPESPEC, RID_SIGNED\n+__signed__, TYPESPEC, RID_SIGNED\n+__typeof, TYPEOF, NORID\n+__typeof__, TYPEOF, NORID\n+__volatile, TYPE_QUAL, RID_VOLATILE\n+__volatile__, TYPE_QUAL, RID_VOLATILE\n+__wchar_t, TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,\n+all, ALL, NORID\t\t\t/* Extension */,\n+except, EXCEPT, NORID\t\t/* Extension */,\n+exception, AGGR, RID_EXCEPTION\t/* Extension */,\n+raise, RAISE, NORID\t\t/* Extension */,\n+raises, RAISES, NORID\t\t/* Extension */,\n+reraise, RERAISE, NORID\t\t/* Extension */,\n+throw, THROW, NORID\t\t/* Extension */,\n+try, TRY, NORID\t\t\t/* Extension */,\n+asm, ASM_KEYWORD, NORID,\n+auto, SCSPEC, RID_AUTO,\n+break, BREAK, NORID,\n+case, CASE, NORID,\n+catch, CATCH, NORID,\n+char, TYPESPEC, RID_CHAR,\n+class, AGGR, RID_CLASS,\n+classof, CLASSOF, NORID,\n+const, TYPE_QUAL, RID_CONST,\n+continue, CONTINUE, NORID,\n+default, DEFAULT, NORID,\n+delete, DELETE, NORID,\n+do, DO, NORID,\n+double, TYPESPEC, RID_DOUBLE,\n+dynamic_cast, DYNAMIC_CAST, NORID,\n+else, ELSE, NORID,\n+enum, ENUM, NORID,\n+extern, SCSPEC, RID_EXTERN,\n+float, TYPESPEC, RID_FLOAT,\n+for, FOR, NORID,\n+friend, SCSPEC, RID_FRIEND,\n+goto, GOTO, NORID,\n+headof, HEADOF, NORID,\n+if, IF, NORID,\n+inline, SCSPEC, RID_INLINE,\n+int, TYPESPEC, RID_INT,\n+long, TYPESPEC, RID_LONG,\n+mutable, SCSPEC, RID_MUTABLE,\n+new, NEW, NORID,\n+operator, OPERATOR, NORID,\n+overload, OVERLOAD, NORID,\n+private, VISSPEC, RID_PRIVATE,\n+protected, VISSPEC, RID_PROTECTED,\n+public, VISSPEC, RID_PUBLIC,\n+register, SCSPEC, RID_REGISTER,\n+return, RETURN, NORID,\n+short, TYPESPEC, RID_SHORT,\n+signature, AGGR, RID_SIGNATURE\t/* Extension */,\n+signed, TYPESPEC, RID_SIGNED,\n+sigof, SIGOF, NORID\t\t/* Extension */,\n+sizeof, SIZEOF, NORID,\n+static, SCSPEC, RID_STATIC,\n+struct, AGGR, RID_RECORD,\n+switch, SWITCH, NORID,\n+this, THIS, NORID,\n+template, TEMPLATE, NORID,\n+typedef, SCSPEC, RID_TYPEDEF,\n+typeof, TYPEOF, NORID,\n+typeid, TYPEID, NORID,\n+union, AGGR, RID_UNION,\n+unsigned, TYPESPEC, RID_UNSIGNED,\n+virtual, SCSPEC, RID_VIRTUAL,\n+void, TYPESPEC, RID_VOID,\n+volatile, TYPE_QUAL, RID_VOLATILE,\n+while, WHILE, NORID,"}, {"sha": "ef491092c5a3d6b8116d406429c6e6863c58ae91", "filename": "gcc/cp/gxxint.texi", "status": "added", "additions": 1030, "deletions": 0, "changes": 1030, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,1030 @@\n+\\input texinfo  @c -*-texinfo-*-\n+@c %**start of header \n+@setfilename g++int.info\n+@settitle G++ internals\n+@setchapternewpage odd\n+@c %**end of header\n+     \n+@node Top, Limitations of g++, (dir), (dir)\n+@chapter Internal Architecture of the Compiler\n+\n+This is meant to describe the C++ frontend for gcc in detail.\n+Questions and comments to mrs@@cygnus.com.\n+\n+@menu\n+* Limitations of g++::          \n+* Routines::                    \n+* Implementation Specifics::    \n+* Glossary::                    \n+* Macros::                      \n+* Typical Behavior::            \n+* Coding Conventions::          \n+* Templates::                   \n+* Access Control::              \n+* Error Reporting::             \n+* Concept Index::               \n+@end menu\n+\n+@node Limitations of g++, Routines, Top, Top\n+@section Limitations of g++\n+\n+@itemize @bullet\n+@item\n+Limitations on input source code: 240 nesting levels with the parser\n+stacksize (YYSTACKSIZE) set to 500 (the default), and requires around\n+16.4k swap space per nesting level.  The parser needs about 2.09 *\n+number of nesting levels worth of stackspace.\n+\n+@cindex pushdecl_class_level\n+@item\n+I suspect there are other uses of pushdecl_class_level that do not call\n+set_identifier_type_value in tandem with the call to\n+pushdecl_class_level.  It would seem to be an omission.\n+\n+@cindex delete, two argument\n+@item\n+For two argument delete, the second argument is always calculated by\n+``virtual_size ='' in the source.  It currently has a problem, in that\n+object size is not calculated by the virtual destructor and passed back\n+for the second parameter to delete.  Destructors need to return a value\n+just like constructors.  ANSI C++ Jun 5 92 wp 12.5.6\n+\n+The second argument is magically deleted in build_method_call, if it is\n+not used.  It needs to be deleted for global operator delete also.\n+\n+@cindex access checking\n+@item\n+Access checking in general is unimplemented, there are a few cases\n+where it is implemented.  grok_enum_decls should be used in more places\n+to do access checking, but this is only the tip of a bigger problem.\n+\n+@cindex @code{volatile}\n+@item\n+@code{volatile} is not implemented in general.\n+\n+@cindex pointers to members\n+@item\n+Pointers to members are only minimally supported, and there are places\n+where the grammar doesn't even properly accept them yet.\n+\n+@cindex multiple inheritance\n+@item\n+@code{this} will be wrong in virtual members functions defined in a\n+virtual base class, when they are overridden in a derived class, when\n+called via a non-left most object.\n+\n+An example would be:\n+\n+@example\n+extern \"C\" int printf(const char*, ...);\n+struct A { virtual void f() { } };\n+struct B : virtual A { int b; B() : b(0) {} void f() { b++; } };\n+struct C : B {};\n+struct D : B {};\n+struct E : C, D {};\n+int main()\n+{\n+  E e;\n+  C& c = e; D& d = e;\n+  c.f(); d.f();\n+  printf (\"C::b = %d, D::b = %d\\n\", e.C::b, e.D::b);\n+  return 0;\n+}\n+@end example\n+\n+This will print out 2, 0, instead of 1,1.\n+\n+@end itemize\n+\n+@node Routines, Implementation Specifics, Limitations of g++, Top\n+@section Routines\n+\n+This section describes some of the routines used in the C++ front-end.\n+\n+@code{build_vtable} and @code{prepare_fresh_vtable} is used only within\n+the @file{cp-class.c} file, and only in @code{finish_struct} and\n+@code{modify_vtable_entries}.\n+\n+@code{build_vtable}, @code{prepare_fresh_vtable}, and\n+@code{finish_struct} are the only routines that set @code{DECL_VPARENT}.\n+\n+@code{finish_struct} can steal the virtual function table from parents,\n+this prohibits related_vslot from working.  When finish_struct steals,\n+we know that\n+\n+@example\n+get_binfo (DECL_FIELD_CONTEXT (CLASSTYPE_VFIELD (t)), t, 0)\n+@end example\n+\n+@noindent\n+will get the related binfo.\n+\n+@code{layout_basetypes} does something with the VIRTUALS.\n+\n+Supposedly (according to Tiemann) most of the breadth first searching\n+done, like in @code{get_base_distance} and in @code{get_binfo} was not\n+because of any design decision.  I have since found out the at least one\n+part of the compiler needs the notion of depth first binfo searching, I\n+am going to try and convert the whole thing, it should just work.  The\n+term left-most refers to the depth first left-most node.  It uses\n+@code{MAIN_VARIANT == type} as the condition to get left-most, because\n+the things that have @code{BINFO_OFFSET}s of zero are shared and will\n+have themselves as their own @code{MAIN_VARIANT}s.  The non-shared right\n+ones, are copies of the left-most one, hence if it is its own\n+@code{MAIN_VARIENT}, we know it IS a left-most one, if it is not, it is\n+a non-left-most one.\n+\n+@code{get_base_distance}'s path and distance matters in its use in:\n+\n+@itemize @bullet\n+@item\n+@code{prepare_fresh_vtable} (the code is probably wrong)\n+@item\n+@code{init_vfields} Depends upon distance probably in a safe way,\n+build_offset_ref might use partial paths to do further lookups,\n+hack_identifier is probably not properly checking access.\n+\n+@item\n+@code{get_first_matching_virtual} probably should check for\n+@code{get_base_distance} returning -2.\n+\n+@item\n+@code{resolve_offset_ref} should be called in a more deterministic\n+manner.  Right now, it is called in some random contexts, like for\n+arguments at @code{build_method_call} time, @code{default_conversion}\n+time, @code{convert_arguments} time, @code{build_unary_op} time,\n+@code{build_c_cast} time, @code{build_modify_expr} time,\n+@code{convert_for_assignment} time, and\n+@code{convert_for_initialization} time.\n+\n+But, there are still more contexts it needs to be called in, one was the\n+ever simple:\n+\n+@example\n+if (obj.*pmi != 7)\n+   @dots{}\n+@end example\n+\n+Seems that the problems were due to the fact that @code{TREE_TYPE} of\n+the @code{OFFSET_REF} was not a @code{OFFSET_TYPE}, but rather the type\n+of the referent (like @code{INTEGER_TYPE}).  This problem was fixed by\n+changing @code{default_conversion} to check @code{TREE_CODE (x)},\n+instead of only checking @code{TREE_CODE (TREE_TYPE (x))} to see if it\n+was @code{OFFSET_TYPE}.\n+\n+@end itemize\n+\n+@node Implementation Specifics, Glossary, Routines, Top\n+@section Implementation Specifics\n+\n+@itemize @bullet\n+@item Explicit Initialization\n+\n+The global list @code{current_member_init_list} contains the list of\n+mem-initializers specified in a constructor declaration.  For example:\n+\n+@example\n+foo::foo() : a(1), b(2) @{@}\n+@end example\n+\n+@noindent\n+will initialize @samp{a} with 1 and @samp{b} with 2.\n+@code{expand_member_init} places each initialization (a with 1) on the\n+global list.  Then, when the fndecl is being processed,\n+@code{emit_base_init} runs down the list, initializing them.  It used to\n+be the case that g++ first ran down @code{current_member_init_list},\n+then ran down the list of members initializing the ones that weren't\n+explicitly initialized.  Things were rewritten to perform the\n+initializations in order of declaration in the class.  So, for the above\n+example, @samp{a} and @samp{b} will be initialized in the order that\n+they were declared:\n+\n+@example\n+class foo @{ public: int b; int a; foo (); @};\n+@end example\n+\n+@noindent\n+Thus, @samp{b} will be initialized with 2 first, then @samp{a} will be\n+initialized with 1, regardless of how they're listed in the mem-initializer.\n+\n+@item Argument Matching\n+\n+In early 1993, the argument matching scheme in @sc{gnu} C++ changed\n+significantly.  The original code was completely replaced with a new\n+method that will, hopefully, be easier to understand and make fixing\n+specific cases much easier.\n+\n+The @samp{-fansi-overloading} option is used to enable the new code; at\n+some point in the future, it will become the default behavior of the\n+compiler.\n+\n+The file @file{cp-call.c} contains all of the new work, in the functions\n+@code{rank_for_overload}, @code{compute_harshness},\n+@code{compute_conversion_costs}, and @code{ideal_candidate}.\n+\n+Instead of using obscure numerical values, the quality of an argument\n+match is now represented by clear, individual codes.  The new data\n+structure @code{struct harshness} (it used to be an @code{unsigned}\n+number) contains:\n+\n+@enumerate a\n+@item the @samp{code} field, to signify what was involved in matching two\n+arguments;\n+@item the @samp{distance} field, used in situations where inheritance\n+decides which function should be called (one is ``closer'' than\n+another);\n+@item and the @samp{int_penalty} field, used by some codes as a tie-breaker.\n+@end enumerate\n+\n+The @samp{code} field is a number with a given bit set for each type of\n+code, OR'd together.  The new codes are:\n+\n+@itemize @bullet\n+@item @code{EVIL_CODE}\n+The argument was not a permissible match.\n+\n+@item @code{CONST_CODE}\n+Currently, this is only used by @code{compute_conversion_costs}, to\n+distinguish when a non-@code{const} member function is called from a\n+@code{const} member function.\n+\n+@item @code{ELLIPSIS_CODE}\n+A match against an ellipsis @samp{...} is considered worse than all others.\n+\n+@item @code{USER_CODE}\n+Used for a match involving a user-defined conversion.\n+\n+@item @code{STD_CODE}\n+A match involving a standard conversion.\n+\n+@item @code{PROMO_CODE}\n+A match involving an integral promotion.  For these, the\n+@code{int_penalty} field is used to handle the ARM's rule (XXX cite)\n+that a smaller @code{unsigned} type should promote to a @code{int}, not\n+to an @code{unsigned int}.\n+\n+@item @code{QUAL_CODE}\n+Used to mark use of qualifiers like @code{const} and @code{volatile}.\n+\n+@item @code{TRIVIAL_CODE}\n+Used for trivial conversions.  The @samp{int_penalty} field is used by\n+@code{convert_harshness} to communicate further penalty information back\n+to @code{build_overload_call_real} when deciding which function should\n+be call.\n+@end itemize\n+\n+The functions @code{convert_to_aggr} and @code{build_method_call} use\n+@code{compute_conversion_costs} to rate each argument's suitability for\n+a given candidate function (that's how we get the list of candidates for\n+@code{ideal_candidate}).\n+\n+@end itemize\n+\n+@node Glossary, Macros, Implementation Specifics, Top\n+@section Glossary\n+\n+@table @r\n+@item binfo\n+The main data structure in the compiler used to represent the\n+inheritance relationships between classes.  The data in the binfo can be\n+accessed by the BINFO_ accessor macros.\n+\n+@item vtable\n+@itemx virtual function table\n+\n+The virtual function table holds information used in virtual function\n+dispatching.  In the compiler, they are usually referred to as vtables,\n+or vtbls.  The first index is not used in the normal way, I believe it\n+is probably used for the virtual destructor.\n+\n+@item vfield\n+\n+vfields can be thought of as the base information needed to build\n+vtables.  For every vtable that exists for a class, there is a vfield.\n+See also vtable and virtual function table pointer.  When a type is used\n+as a base class to another type, the virtual function table for the\n+derived class can be based upon the vtable for the base class, just\n+extended to include the additional virtual methods declared in the\n+derived class.  The virtual function table from a virtual base class is\n+never reused in a derived class.  @code{is_normal} depends upon this.\n+\n+@item virtual function table pointer\n+\n+These are @code{FIELD_DECL}s that are pointer types that point to\n+vtables.  See also vtable and vfield.\n+@end table\n+\n+@node Macros, Typical Behavior, Glossary, Top\n+@section Macros\n+\n+This section describes some of the macros used on trees.  The list\n+should be alphabetical.  Eventually all macros should be documented\n+here.  There are some postscript drawings that can be used to better\n+understnad from of the more complex data structures, contact Mike Stump\n+(@code{mrs@@cygnus.com}) for information about them.\n+\n+@table @code\n+@item BINFO_BASETYPES\n+A vector of additional binfos for the types inherited by this basetype.\n+The binfos are fully unshared (except for virtual bases, in which\n+case the binfo structure is shared).\n+\n+   If this basetype describes type D as inherited in C,\n+   and if the basetypes of D are E anf F,\n+   then this vector contains binfos for inheritance of E and F by C.\n+\n+Has values of:\n+\n+\tTREE_VECs\n+\n+\n+@item BINFO_INHERITANCE_CHAIN\n+Temporarily used to represent specific inheritances.  It usually points\n+to the binfo associated with the lesser derived type, but it can be\n+reversed by reverse_path.  For example:\n+\n+@example\n+\tZ ZbY\tleast derived\n+\t|\n+\tY YbX\n+\t|\n+\tX Xb\tmost derived\n+\n+TYPE_BINFO (X) == Xb\n+BINFO_INHERITANCE_CHAIN (Xb) == YbX\n+BINFO_INHERITANCE_CHAIN (Yb) == ZbY\n+BINFO_INHERITANCE_CHAIN (Zb) == 0\n+@end example\n+\n+Not sure is the above is really true, get_base_distance has is point\n+towards the most derived type, opposite from above.\n+\n+Set by build_vbase_path, recursive_bounded_basetype_p,\n+get_base_distance, lookup_field, lookup_fnfields, and reverse_path.\n+\n+What things can this be used on:\n+\n+\tTREE_VECs that are binfos\n+\n+\n+@item BINFO_OFFSET\n+The offset where this basetype appears in its containing type.\n+BINFO_OFFSET slot holds the offset (in bytes) from the base of the\n+complete object to the base of the part of the object that is allocated\n+on behalf of this `type'.  This is always 0 except when there is\n+multiple inheritance.\n+\n+Used on TREE_VEC_ELTs of the binfos BINFO_BASETYPES (...) for example.\n+\n+\n+@item BINFO_VIRTUALS\n+A unique list of functions for the virtual function table.  See also\n+TYPE_BINFO_VIRTUALS.\n+\n+What things can this be used on:\n+\n+\tTREE_VECs that are binfos\n+\n+\n+@item BINFO_VTABLE\n+Used to find the VAR_DECL that is the virtual function table associated\n+with this binfo.  See also TYPE_BINFO_VTABLE.  To get the virtual\n+function table pointer, see CLASSTYPE_VFIELD.\n+\n+What things can this be used on:\n+\n+\tTREE_VECs that are binfos\n+\n+Has values of:\n+\n+\tVAR_DECLs that are virtual function tables\n+\n+\n+@item BLOCK_SUPERCONTEXT\n+In the outermost scope of each function, it points to the FUNCTION_DECL\n+node.  It aids in better DWARF support of inline functions.\n+\n+\n+@item CLASSTYPE_TAGS\n+CLASSTYPE_TAGS is a linked (via TREE_CHAIN) list of member classes of a\n+class. TREE_PURPOSE is the name, TREE_VALUE is the type (pushclass scans\n+these and calls pushtag on them.)\n+\n+finish_struct scans these to produce TYPE_DECLs to add to the\n+TYPE_FIELDS of the type.\n+\n+It is expected that name found in the TREE_PURPOSE slot is unique,\n+resolve_scope_to_name is one such place that depends upon this\n+uniqueness.\n+\n+\n+@item CLASSTYPE_METHOD_VEC\n+The following is true after finish_struct has been called (on the\n+class?) but not before.  Before finish_struct is called, things are\n+different to some extent.  Contains a TREE_VEC of methods of the class.\n+The TREE_VEC_LENGTH is the number of differently named methods plus one\n+for the 0th entry.  The 0th entry is always allocated, and reserved for\n+ctors and dtors.  If there are none, TREE_VEC_ELT(N,0) == NULL_TREE.\n+Each entry of the TREE_VEC is a FUNCTION_DECL.  For each FUNCTION_DECL,\n+there is a DECL_CHAIN slot.  If the FUNCTION_DECL is the last one with a\n+given name, the DECL_CHAIN slot is NULL_TREE.  Otherwise it is the next\n+method that has the same name (but a different signature).  It would\n+seem that it is not true that because the DECL_CHAIN slot is used in\n+this way, we cannot call pushdecl to put the method in the global scope\n+(cause that would overwrite the TREE_CHAIN slot), because they use\n+different _CHAINs.  finish_struct_methods setups up one version of the\n+TREE_CHAIN slots on the FUNCTION_DECLs.\n+\n+friends are kept in TREE_LISTs, so that there's no need to use their\n+TREE_CHAIN slot for anything.\n+\n+Has values of:\n+\n+\tTREE_VECs\n+\t\n+\n+@item CLASSTYPE_VFIELD\n+Seems to be in the process of being renamed TYPE_VFIELD.  Use on types\n+to get the main virtual function table pointer.  To get the virtual\n+function table use BINFO_VTABLE (TYPE_BINFO ()).\n+\n+Has values of:\n+\n+\tFIELD_DECLs that are virtual function table pointers\n+\n+What things can this be used on:\n+\n+\tRECORD_TYPEs\n+\n+\n+@item DECL_CLASS_CONTEXT\n+Identifies the context that the _DECL was found in.  For virtual function\n+tables, it points to the type associated with the virtual function\n+table.  See also DECL_CONTEXT, DECL_FIELD_CONTEXT and DECL_FCONTEXT.\n+\n+The difference between this and DECL_CONTEXT, is that for virtuals\n+functions like:\n+\n+@example\n+struct A\n+@{\n+  virtual int f ();\n+@};\n+\n+struct B : A\n+@{\n+  int f ();\n+@};\n+\n+DECL_CONTEXT (A::f) == A\n+DECL_CLASS_CONTEXT (A::f) == A\n+\n+DECL_CONTEXT (B::f) == A\n+DECL_CLASS_CONTEXT (B::f) == B\n+@end example\n+\n+Has values of:\n+\n+\tRECORD_TYPEs, or UNION_TYPEs\n+\n+What things can this be used on:\n+\n+\tTYPE_DECLs, _DECLs\n+\n+\n+@item DECL_CONTEXT\n+Identifies the context that the _DECL was found in.  Can be used on\n+virtual function tables to find the type associated with the virtual\n+function table, but since they are FIELD_DECLs, DECL_FIELD_CONTEXT is a\n+better access method.  Internally the same as DECL_FIELD_CONTEXT, so\n+don't us both.  See also DECL_FIELD_CONTEXT, DECL_FCONTEXT and\n+DECL_CLASS_CONTEXT.\n+\n+Has values of:\n+\n+\tRECORD_TYPEs\n+\n+\n+What things can this be used on:\n+\n+@display\n+VAR_DECLs that are virtual function tables\n+_DECLs\n+@end display\n+\n+\n+@item DECL_FIELD_CONTEXT\n+Identifies the context that the FIELD_DECL was found in.  Internally the\n+same as DECL_CONTEXT, so don't us both.  See also DECL_CONTEXT,\n+DECL_FCONTEXT and DECL_CLASS_CONTEXT.\n+\n+Has values of:\n+\n+\tRECORD_TYPEs\n+\n+What things can this be used on:\n+\n+@display\n+FIELD_DECLs that are virtual function pointers\n+FIELD_DECLs\n+@end display\n+\n+\n+@item DECL_NESTED_TYPENAME\n+Holds the fully qualified type name.  Example, Base::Derived.\n+\n+Has values of:\n+\n+\tIDENTIFIER_NODEs\n+\n+What things can this be used on:\n+\n+\tTYPE_DECLs\n+\n+\n+@item DECL_NAME\n+\n+Has values of:\n+\n+@display\n+0 for things that don't have names\n+IDENTIFIER_NODEs for TYPE_DECLs\n+@end display\n+\n+@item DECL_IGNORED_P\n+A bit that can be set to inform the debug information output routines in\n+the backend that a certain _DECL node should be totally ignored.\n+\n+Used in cases where it is known that the debugging information will be\n+output in another file, or where a sub-type is known not to be needed\n+because the enclosing type is not needed.\n+\n+A compiler constructed virtual destructor in derived classes that do not\n+define an exlicit destructor that was defined exlicit in a base class\n+has this bit set as well.  Also used on __FUNCTION__ and\n+__PRETTY_FUNCTION__ to mark they are ``compiler generated.''  c-decl and\n+c-lex.c both want DECL_IGNORED_P set for ``internally generated vars,''\n+and ``user-invisible variable.''\n+\n+Functions built by the C++ front-end such as default destructors,\n+virtual desctructors and default constructors want to be marked that\n+they are compiler generated, but unsure why.\n+\n+Currently, it is used in an absolute way in the C++ front-end, as an\n+optimization, to tell the debug information output routines to not\n+generate debugging information that will be output by another separately\n+compiled file.\n+\n+\n+@item DECL_VIRTUAL_P\n+A flag used on FIELD_DECLs and VAR_DECLs.  (Documentation in tree.h is\n+wrong.)  Used in VAR_DECLs to indicate that the variable is a vtable.\n+It is also used in FIELD_DECLs for vtable pointers.\n+\n+What things can this be used on:\n+\n+\tFIELD_DECLs and VAR_DECLs\n+\n+\n+@item DECL_VPARENT\n+Used to point to the parent type of the vtable if there is one, else it\n+is just the type associated with the vtable.  Because of the sharing of\n+virtual function tables that goes on, this slot is not very useful, and\n+is in fact, not used in the compiler at all.  It can be removed.\n+\n+What things can this be used on:\n+\n+\tVAR_DECLs that are virtual function tables\n+\n+Has values of:\n+\n+\tRECORD_TYPEs maybe UNION_TYPEs\n+\n+\n+@item DECL_FCONTEXT\n+Used to find the first baseclass in which this FIELD_DECL is defined.\n+See also DECL_CONTEXT, DECL_FIELD_CONTEXT and DECL_CLASS_CONTEXT.\n+\n+How it is used:\n+\n+\tUsed when writing out debugging information about vfield and\n+\tvbase decls.\n+\n+What things can this be used on:\n+\n+\tFIELD_DECLs that are virtual function pointers\n+\tFIELD_DECLs\n+\n+\n+@item DECL_REFERENCE_SLOT\n+Used to hold the initialize for the reference.\n+\n+What things can this be used on:\n+\n+\tPARM_DECLs and VAR_DECLs that have a reference type\n+\n+\n+@item DECL_VINDEX\n+Used for FUNCTION_DECLs in two different ways.  Before the structure\n+containing the FUNCTION_DECL is laid out, DECL_VINDEX may point to a\n+FUNCTION_DECL in a base class which is the FUNCTION_DECL which this\n+FUNCTION_DECL will replace as a virtual function.  When the class is\n+laid out, this pointer is changed to an INTEGER_CST node which is\n+suitable to find an index into the virtual function table.  See\n+get_vtable_entry as to how one can find the right index into the virtual\n+function table.  The first index 0, of a virtual function table it not\n+used in the normal way, so the first real index is 1.\n+\n+DECL_VINDEX may be a TREE_LIST, that would seem to be a list of\n+overridden FUNCTION_DECLs.  add_virtual_function has code to deal with\n+this when it uses the variable base_fndecl_list, but it would seem that\n+somehow, it is possible for the TREE_LIST to pursist until method_call,\n+and it should not.\n+\n+\n+What things can this be used on:\n+\n+\tFUNCTION_DECLs\n+\n+\n+@item DECL_SOURCE_FILE\n+Identifies what source file a particular declaration was found in.\n+\n+Has values of:\n+\n+\t\"<built-in>\" on TYPE_DECLs to mean the typedef is built in\n+\n+\n+@item DECL_SOURCE_LINE\n+Identifies what source line number in the source file the declaration\n+was found at.\n+\n+Has values of:\n+\n+@display\n+0 for an undefined label\n+\n+0 for TYPE_DECLs that are internally generated\n+\n+0 for FUNCTION_DECLs for functions generated by the compiler\n+\t(not yet, but should be)\n+\n+0 for ``magic'' arguments to functions, that the user has no\n+\tcontrol over\n+@end display\n+\n+\n+@item TREE_USED\n+\n+Has values of:\n+\n+\t0 for unused labels\n+\n+\n+@item TREE_ADDRESSABLE\n+A flag that is set for any type that has a constructor.\n+\n+\n+@item TREE_COMPLEXITY\n+They seem a kludge way to track recursion, poping, and pushing.  They only\n+appear in cp-decl.c and cp-decl2.c, so the are a good candidate for\n+proper fixing, and removal.\n+\n+\n+@item TREE_PRIVATE\n+Set for FIELD_DECLs by finish_struct.  But not uniformly set.\n+\n+The following routines do something with PRIVATE access:\n+build_method_call, alter_access, finish_struct_methods,\n+finish_struct, convert_to_aggr, CWriteLanguageDecl, CWriteLanguageType,\n+CWriteUseObject, compute_access, lookup_field, dfs_pushdecl,\n+GNU_xref_member, dbxout_type_fields, dbxout_type_method_1\n+\n+\n+@item TREE_PROTECTED\n+The following routines do something with PROTECTED access:\n+build_method_call, alter_access, finish_struct, convert_to_aggr,\n+CWriteLanguageDecl, CWriteLanguageType, CWriteUseObject,\n+compute_access, lookup_field, GNU_xref_member, dbxout_type_fields,\n+dbxout_type_method_1\n+\n+\n+@item TYPE_BINFO\n+Used to get the binfo for the type.\n+\n+Has values of:\n+\n+\tTREE_VECs that are binfos\n+\n+What things can this be used on:\n+\n+\tRECORD_TYPEs\n+\n+\n+@item TYPE_BINFO_BASETYPES\n+See also BINFO_BASETYPES.\n+\n+@item TYPE_BINFO_VIRTUALS\n+A unique list of functions for the virtual function table.  See also\n+BINFO_VIRTUALS.\n+\n+What things can this be used on:\n+\n+\tRECORD_TYPEs\n+\n+\n+@item TYPE_BINFO_VTABLE\n+Points to the virtual function table associated with the given type.\n+See also BINFO_VTABLE.\n+\n+What things can this be used on:\n+\n+\tRECORD_TYPEs\n+\n+Has values of:\n+\n+\tVAR_DECLs that are virtual function tables\n+\n+\n+@item TYPE_NAME\n+Names the type.\n+\n+Has values of:\n+\n+@display\n+0 for things that don't have names.\n+should be IDENTIFIER_NODE for RECORD_TYPEs UNION_TYPEs and \n+        ENUM_TYPEs.\n+TYPE_DECL for RECORD_TYPEs, UNION_TYPEs and ENUM_TYPEs, but \n+        shouldn't be.\n+TYPE_DECL for typedefs, unsure why.\n+@end display\n+\n+What things can one use this on:\n+\n+@display\n+TYPE_DECLs\n+RECORD_TYPEs\n+UNION_TYPEs\n+ENUM_TYPEs\n+@end display\n+\n+History:\n+\n+\tIt currently points to the TYPE_DECL for RECORD_TYPEs,\n+\tUNION_TYPEs and ENUM_TYPEs, but it should be history soon.\n+\n+\n+@item TYPE_METHODS\n+Synonym for @code{CLASSTYPE_METHOD_VEC}.  Chained together with\n+@code{TREE_CHAIN}.  @file{dbxout.c} uses this to get at the methods of a\n+class.\n+\n+\n+@item TYPE_DECL\n+Used to represent typedefs, and used to represent bindings layers.\n+\n+Components:\n+\n+\tDECL_NAME is the name of the typedef.  For example, foo would\n+\tbe found in the DECL_NAME slot when @code{typedef int foo;} is\n+\tseen.\n+\n+\tDECL_SOURCE_LINE identifies what source line number in the\n+\tsource file the declaration was found at.  A value of 0\n+\tindicates that this TYPE_DECL is just an internal binding layer\n+\tmarker, and does not correspond to a user suppiled typedef.\n+\n+\tDECL_SOURCE_FILE\n+\n+@item TYPE_FIELDS\n+A linked list (via @code{TREE_CHAIN}) of member types of a class.  The\n+list can contain @code{TYPE_DECL}s, but there can also be other things\n+in the list apparently.  See also @code{CLASSTYPE_TAGS}.\n+\n+\n+@item TYPE_VIRTUAL_P\n+A flag used on a @code{FIELD_DECL} or a @code{VAR_DECL}, indicates it is\n+a virtual function table or a pointer to one.  When used on a\n+@code{FUNCTION_DECL}, indicates that it is a virtual function.  When\n+used on an @code{IDENTIFIER_NODE}, indicates that a function with this\n+same name exists and has been declared virtual.\n+\n+When used on types, it indicates that the type has virtual functions, or\n+is derived from one that does.\n+\n+Not sure if the above about virtual function tables is still true.  See\n+also info on @code{DECL_VIRTUAL_P}.\n+\n+What things can this be used on:\n+\n+\tFIELD_DECLs, VAR_DECLs, FUNCTION_DECLs, IDENTIFIER_NODEs\n+\n+\n+@item VF_BASETYPE_VALUE\n+Get the associated type from the binfo that caused the given vfield to\n+exist.  This is the least derived class (the most parent class) that\n+needed a virtual function table.  It is probably the case that all uses\n+of this field are misguided, but they need to be examined on a\n+case-by-case basis.  See history for more information on why the\n+previous statement was made.\n+\n+Set at @code{finish_base_struct} time.\n+\n+What things can this be used on:\n+\n+\tTREE_LISTs that are vfields\n+\n+History:\n+\n+\tThis field was used to determine if a virtual function table's\n+\tslot should be filled in with a certain virtual function, by\n+\tchecking to see if the type returned by VF_BASETYPE_VALUE was a\n+\tparent of the context in which the old virtual function existed.\n+\tThis incorrectly assumes that a given type _could_ not appear as\n+\ta parent twice in a given inheritance lattice.  For single\n+\tinheritance, this would in fact work, because a type could not\n+\tpossibly appear more than once in an inheritance lattice, but\n+\twith multiple inheritance, a type can appear more than once.\n+\n+\n+@item VF_BINFO_VALUE\n+Identifies the binfo that caused this vfield to exist.  If this vfield\n+is from the first direct base class that has a virtual function table,\n+then VF_BINFO_VALUE is NULL_TREE, otherwise it will be the binfo of the\n+direct base where the vfield came from.  Can use @code{TREE_VIA_VIRTUAL}\n+on result to find out if it is a virtual base class.  Related to the\n+binfo found by\n+\n+@example\n+get_binfo (VF_BASETYPE_VALUE (vfield), t, 0)\n+@end example\n+\n+@noindent\n+where @samp{t} is the type that has the given vfield.\n+\n+@example\n+get_binfo (VF_BASETYPE_VALUE (vfield), t, 0)\n+@end example\n+\n+@noindent\n+will return the binfo for the the given vfield.\n+\n+May or may not be set at @code{modify_vtable_entries} time.  Set at\n+@code{finish_base_struct} time.\n+\n+What things can this be used on:\n+\n+\tTREE_LISTs that are vfields\n+\n+\n+@item VF_DERIVED_VALUE\n+Identifies the type of the most derived class of the vfield, excluding\n+the the class this vfield is for.\n+\n+Set at @code{finish_base_struct} time.\n+\n+What things can this be used on:\n+\n+\tTREE_LISTs that are vfields\n+\n+\n+@item VF_NORMAL_VALUE\n+Identifies the type of the most derived class of the vfield, including\n+the class this vfield is for.\n+\n+Set at @code{finish_base_struct} time.\n+\n+What things can this be used on:\n+\n+\tTREE_LISTs that are vfields\n+\n+\n+@item WRITABLE_VTABLES\n+This is a option that can be defined when building the compiler, that\n+will cause the compiler to output vtables into the data segment so that\n+the vtables maybe written.  This is undefined by default, because\n+normally the vtables should be unwritable.  People that implement object\n+I/O facilities may, or people that want to change the dynamic type of\n+objects may want to have the vtables writable.  Another way of achieving\n+this would be to make a copy of the vtable into writable memory, but the\n+drawback there is that that method only changes the type for one object.\n+\n+@end table\n+\n+@node Typical Behavior, Coding Conventions, Macros, Top\n+@section Typical Behavior\n+\n+@cindex parse errors\n+\n+Whenever seemingly normal code fails with errors like\n+@code{syntax error at `\\@{'}, it's highly likely that grokdeclarator is\n+returning a NULL_TREE for whatever reason.\n+\n+@node Coding Conventions, Templates, Typical Behavior, Top\n+@section Coding Conventions\n+\n+It should never be that case that trees are modified in-place by the\n+back-end, @emph{unless} it is guaranteed that the semantics are the same\n+no matter how shared the tree structure is.  @file{fold-const.c} still\n+has some cases where this is not true, but rms hypothesizes that this\n+will never be a problem.\n+\n+@node Templates, Access Control, Coding Conventions, Top\n+@section Templates\n+\n+g++ uses the simple approach to instantiating templates: it blindly\n+generates the code for each instantiation as needed.  For class\n+templates, g++ pushes the template parameters into the namespace for the\n+duration of the instantiation; for function templates, it's a simple\n+search and replace.\n+\n+This approach does not support any of the template definition-time error\n+checking that is being bandied about by X3J16.  It makes no attempt to deal\n+with name binding in a consistent way.\n+\n+Instantiation of a class template is triggered by the use of a template\n+class anywhere but in a straight declaration like @code{class A<int>}.\n+This is wrong; in fact, it should not be triggered by typedefs or\n+declarations of pointers.  Now that explicit instantiation is supported,\n+this misfeature is not necessary.\n+\n+Important functions:\n+\n+@table @code\n+@item instantiate_class_template\n+This function \n+@end table\n+\n+@node Access Control, Error Reporting, Templates, Top\n+@section Access Control\n+The function compute_access returns one of three values:\n+\n+@table @code\n+@item access_public\n+means that the field can be accessed by the current lexical scope.\n+\n+@item access_protected\n+means that the field cannot be accessed by the current lexical scope\n+because it is protected.\n+\n+@item access_private\n+means that the field cannot be accessed by the current lexical scope\n+because it is private.\n+@end table\n+\n+DECL_ACCESS is used for access declarations; alter_access creates a list\n+of types and accesses for a given decl.\n+\n+Formerly, DECL_@{PUBLIC,PROTECTED,PRIVATE@} corresponded to the return\n+codes of compute_access and were used as a cache for compute_access.\n+Now they are not used at all.\n+\n+TREE_PROTECTED and TREE_PRIVATE are used to record the access levels\n+granted by the containing class.  BEWARE: TREE_PUBLIC means something\n+completely unrelated to access control!\n+\n+@node Error Reporting, Concept Index, Access Control, Top\n+@section Error Reporting\n+\n+The C++ frontend uses a call-back mechanism to allow functions to print\n+out reasonable strings for types and functions without putting extra\n+logic in the functions where errors are found.  The interface is through\n+the @code{cp_error} function (or @code{cp_warning}, etc.).  The\n+syntax is exactly like that of @code{error}, except that a few more\n+conversions are supported:\n+\n+@itemize @bullet\n+@item\n+%C indicates a value of `enum tree_code'.\n+@item\n+%D indicates a *_DECL node.\n+@item\n+%E indicates a *_EXPR node.\n+@item\n+%L indicates a value of `enum languages'.\n+@item\n+%P indicates the name of a parameter (i.e. \"this\", \"1\", \"2\", ...)\n+@item\n+%T indicates a *_TYPE node.\n+@item\n+%O indicates the name of an operator (MODIFY_EXPR -> \"operator =\").\n+\n+@end itemize\n+\n+There is some overlap between these; for instance, any of the node\n+options can be used for printing an identifier (though only @code{%D}\n+tries to decipher function names).\n+\n+For a more verbose message (@code{class foo} as opposed to just @code{foo},\n+including the return type for functions), use @code{%#c}.\n+To have the line number on the error message indicate the line of the\n+DECL, use @code{cp_error_at} and its ilk; to indicate which argument you want,\n+use @code{%+D}, or it will default to the first.\n+\n+@node Concept Index,  , Error Reporting, Top\n+@section Concept Index\n+\n+@printindex cp\n+\n+@bye"}, {"sha": "fceaa63ccfc6e28f6528816d3c698087802425e6", "filename": "gcc/cp/hash.h", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,207 @@\n+/* C code produced by gperf version 2.5 (GNU C++ version) */\n+/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ ../../../devo/gcc/cp/gxx.gperf  */\n+/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n+struct resword { char *name; short token; enum rid rid;};\n+\n+#define TOTAL_KEYWORDS 86\n+#define MIN_WORD_LENGTH 2\n+#define MAX_WORD_LENGTH 13\n+#define MIN_HASH_VALUE 4\n+#define MAX_HASH_VALUE 196\n+/* maximum key range = 193, duplicates = 0 */\n+\n+#ifdef __GNUC__\n+inline\n+#endif\n+static unsigned int\n+hash (str, len)\n+     register char *str;\n+     register int unsigned len;\n+{\n+  static unsigned char asso_values[] =\n+    {\n+     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n+     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n+     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n+     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n+     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n+     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n+     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n+     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n+     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n+     197, 197, 197, 197, 197,   0, 197,  93,   3,  35,\n+       3,   0,  71,   8,   4,  78, 197,   3,  30,   6,\n+      29,  18,  37, 197,  55,   0,   4,  11,   7,  20,\n+       0,   8, 197, 197, 197, 197, 197, 197,\n+    };\n+  register int hval = len;\n+\n+  switch (hval)\n+    {\n+      default:\n+      case 7:\n+        hval += asso_values[str[6]];\n+      case 6:\n+      case 5:\n+      case 4:\n+        hval += asso_values[str[3]];\n+      case 3:\n+      case 2:\n+      case 1:\n+        hval += asso_values[str[0]];\n+    }\n+  return hval + asso_values[str[len - 1]];\n+}\n+\n+#ifdef __GNUC__\n+inline\n+#endif\n+struct resword *\n+is_reserved_word (str, len)\n+     register char *str;\n+     register unsigned int len;\n+{\n+  static struct resword wordlist[] =\n+    {\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"else\",  ELSE, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n+      {\"this\",  THIS, NORID,},\n+      {\"delete\",  DELETE, NORID,},\n+      {\"except\",  EXCEPT, NORID\t\t/* Extension */,},\n+      {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n+      {\"double\",  TYPESPEC, RID_DOUBLE,},\n+      {\"typeid\",  TYPEID, NORID,},\n+      {\"switch\",  SWITCH, NORID,},\n+      {\"try\",  TRY, NORID\t\t\t/* Extension */,},\n+      {\"enum\",  ENUM, NORID,},\n+      {\"void\",  TYPESPEC, RID_VOID,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"struct\",  AGGR, RID_RECORD,},\n+      {\"\",}, \n+      {\"do\",  DO, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"__headof__\",  HEADOF, NORID},\n+      {\"\",}, {\"\",}, \n+      {\"__const__\",  TYPE_QUAL, RID_CONST},\n+      {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n+      {\"__const\",  TYPE_QUAL, RID_CONST},\n+      {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n+      {\"extern\",  SCSPEC, RID_EXTERN,},\n+      {\"__typeof__\",  TYPEOF, NORID},\n+      {\"\",}, \n+      {\"signed\",  TYPESPEC, RID_SIGNED,},\n+      {\"case\",  CASE, NORID,},\n+      {\"class\",  AGGR, RID_CLASS,},\n+      {\"__classof__\",  CLASSOF, NORID},\n+      {\"__extension__\",  EXTENSION, NORID},\n+      {\"\",}, \n+      {\"const\",  TYPE_QUAL, RID_CONST,},\n+      {\"static\",  SCSPEC, RID_STATIC,},\n+      {\"\",}, \n+      {\"throw\",  THROW, NORID\t\t/* Extension */,},\n+      {\"goto\",  GOTO, NORID,},\n+      {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"long\",  TYPESPEC, RID_LONG,},\n+      {\"private\",  VISSPEC, RID_PRIVATE,},\n+      {\"new\",  NEW, NORID,},\n+      {\"template\",  TEMPLATE, NORID,},\n+      {\"\",}, \n+      {\"while\",  WHILE, NORID,},\n+      {\"\",}, \n+      {\"protected\",  VISSPEC, RID_PROTECTED,},\n+      {\"continue\",  CONTINUE, NORID,},\n+      {\"\",}, \n+      {\"raise\",  RAISE, NORID\t\t/* Extension */,},\n+      {\"raises\",  RAISES, NORID\t\t/* Extension */,},\n+      {\"\",}, \n+      {\"union\",  AGGR, RID_UNION,},\n+      {\"short\",  TYPESPEC, RID_SHORT,},\n+      {\"\",}, \n+      {\"__inline\",  SCSPEC, RID_INLINE},\n+      {\"\",}, \n+      {\"__inline__\",  SCSPEC, RID_INLINE},\n+      {\"\",}, \n+      {\"__alignof__\",  ALIGNOF, NORID},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"sizeof\",  SIZEOF, NORID,},\n+      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n+      {\"catch\",  CATCH, NORID,},\n+      {\"friend\",  SCSPEC, RID_FRIEND,},\n+      {\"typeof\",  TYPEOF, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"headof\",  HEADOF, NORID,},\n+      {\"int\",  TYPESPEC, RID_INT,},\n+      {\"\",}, {\"\",}, \n+      {\"__signed__\",  TYPESPEC, RID_SIGNED},\n+      {\"__signed\",  TYPESPEC, RID_SIGNED},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"__attribute\",  ATTRIBUTE, NORID},\n+      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"__attribute__\",  ATTRIBUTE, NORID},\n+      {\"\",}, \n+      {\"__headof\",  HEADOF, NORID},\n+      {\"\",}, {\"\",}, \n+      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n+      {\"return\",  RETURN, NORID,},\n+      {\"asm\",  ASM_KEYWORD, NORID,},\n+      {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n+      {\"break\",  BREAK, NORID,},\n+      {\"__typeof\",  TYPEOF, NORID},\n+      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n+      {\"\",}, \n+      {\"public\",  VISSPEC, RID_PUBLIC,},\n+      {\"\",}, \n+      {\"__classof\",  CLASSOF, NORID},\n+      {\"default\",  DEFAULT, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"exception\",  AGGR, RID_EXCEPTION\t/* Extension */,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"all\",  ALL, NORID\t\t\t/* Extension */,},\n+      {\"\",}, {\"\",}, \n+      {\"for\",  FOR, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"__label__\",  LABEL, NORID},\n+      {\"auto\",  SCSPEC, RID_AUTO,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n+      {\"__alignof\",  ALIGNOF, NORID},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n+      {\"\",}, \n+      {\"char\",  TYPESPEC, RID_CHAR,},\n+      {\"\",}, \n+      {\"if\",  IF, NORID,},\n+      {\"\",}, \n+      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n+      {\"operator\",  OPERATOR, NORID,},\n+      {\"reraise\",  RERAISE, NORID\t\t/* Extension */,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"inline\",  SCSPEC, RID_INLINE,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, \n+      {\"float\",  TYPESPEC, RID_FLOAT,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"overload\",  OVERLOAD, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"classof\",  CLASSOF, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, \n+      {\"register\",  SCSPEC, RID_REGISTER,},\n+    };\n+\n+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n+    {\n+      register int key = hash (str, len);\n+\n+      if (key <= MAX_HASH_VALUE && key >= 0)\n+        {\n+          register char *s = wordlist[key].name;\n+\n+          if (*s == *str && !strcmp (str + 1, s + 1))\n+            return &wordlist[key];\n+        }\n+    }\n+  return 0;\n+}"}, {"sha": "12e0a640703938a26bcc8b1504653c7b4cff636e", "filename": "gcc/cp/init.c", "status": "added", "additions": 4181, "deletions": 0, "changes": 4181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02"}, {"sha": "1252aed187a87d5a8ca9c56e9bf4a42a3cce1a15", "filename": "gcc/cp/input.c", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finput.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,184 @@\n+/* Input handling for G++.\n+   Copyright (C) 1992, 1993 Free Software Foundation, Inc.\n+   Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* G++ needs to do enough saving and re-parsing of text that it is\n+   necessary to abandon the simple FILE* model and use a mechanism where\n+   we can pre-empt one input stream with another derived from saved text;\n+   we may need to do this arbitrarily often, and cannot depend on having\n+   the GNU library available, so FILE objects just don't cut it.\n+\n+   This file is written as a separate module, but can be included by\n+   cp-lex.c for very minor efficiency gains (primarily in function\n+   inlining).  */\n+\n+#include <stdio.h>\n+#include \"obstack.h\"\n+\n+extern FILE *finput;\n+\n+struct pending_input *save_pending_input ();\n+void restore_pending_input ();\n+\n+struct input_source {\n+  /* saved string */\n+  char *str;\n+  int length;\n+  /* current position, when reading as input */\n+  int offset;\n+  /* obstack to free this input string from when finished, if any */\n+  struct obstack *obstack;\n+  /* linked list maintenance */\n+  struct input_source *next;\n+  /* values to restore after reading all of current string */\n+  char *filename;\n+  int lineno;\n+  struct pending_input *input;\n+  int putback_char;\n+};\n+\n+static struct input_source *input, *free_inputs;\n+\n+extern char *input_filename;\n+extern int lineno;\n+\n+#ifdef __GNUC__\n+#define inline __inline__\n+#else\n+#define inline\n+#endif\n+\n+static inline struct input_source *\n+allocate_input ()\n+{\n+  struct input_source *inp;\n+  if (free_inputs)\n+    {\n+      inp = free_inputs;\n+      free_inputs = inp->next;\n+      inp->next = 0;\n+      return inp;\n+    }\n+  inp = (struct input_source *) xmalloc (sizeof (struct input_source));\n+  inp->next = 0;\n+  inp->obstack = 0;\n+  return inp;\n+}\n+\n+static inline void\n+free_input (inp)\n+     struct input_source *inp;\n+{\n+  if (inp->obstack)\n+    obstack_free (inp->obstack, inp->str);\n+  inp->obstack = 0;\n+  inp->str = 0;\n+  inp->length = 0;\n+  inp->next = free_inputs;\n+  free_inputs = inp;\n+}\n+\n+static int putback_char = -1;\n+\n+/* Some of these external functions are declared inline in case this file\n+   is included in cp-lex.c.  */\n+\n+inline\n+void\n+feed_input (str, len, delete)\n+     char *str;\n+     int len;\n+     struct obstack *delete;\n+{\n+  struct input_source *inp = allocate_input ();\n+\n+  /* This shouldn't be necessary.  */\n+  while (len && !str[len-1])\n+    len--;\n+\n+  inp->str = str;\n+  inp->length = len;\n+  inp->obstack = delete;\n+  inp->offset = 0;\n+  inp->next = input;\n+  inp->filename = input_filename;\n+  inp->lineno = lineno;\n+  inp->input = save_pending_input ();\n+  inp->putback_char = putback_char;\n+  putback_char = -1;\n+  input = inp;\n+}\n+\n+struct pending_input *to_be_restored; /* XXX */\n+extern int end_of_file;\n+\n+int\n+getch ()\n+{\n+  if (putback_char != -1)\n+    {\n+      int ch = putback_char;\n+      putback_char = -1;\n+      return ch;\n+    }\n+  if (input)\n+    {\n+      if (input->offset == input->length)\n+\t{\n+\t  struct input_source *inp = input;\n+\t  my_friendly_assert (putback_char == -1, 223);\n+\t  to_be_restored = inp->input;\n+\t  input->offset++;\n+\t  return EOF;\n+\t}\n+      else if (input->offset > input->length)\n+\t{\n+\t  struct input_source *inp = input;\n+\n+\t  end_of_file = 0;\n+\t  input = inp->next;\n+\t  input_filename = inp->filename;\n+\t  lineno = inp->lineno;\n+\t  /* Get interface/implementation back in sync. */\n+\t  extract_interface_info ();\n+\t  putback_char = inp->putback_char;\n+\t  free_input (inp);\n+\t  return getch ();\n+\t}\n+      if (input)\n+\treturn input->str[input->offset++];\n+    }\n+  return getc (finput);\n+}\n+\n+inline\n+void\n+put_back (ch)\n+     int ch;\n+{\n+  my_friendly_assert (putback_char == -1, 224);\n+  putback_char = ch;\n+}\n+\n+inline\n+int\n+input_redirected ()\n+{\n+  return input != 0;\n+}"}, {"sha": "233a33b5cc970a62ebbabeac19053ef3101f59aa", "filename": "gcc/cp/lex.c", "status": "added", "additions": 4783, "deletions": 0, "changes": 4783, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02"}, {"sha": "a212f5c8d6411793fd57f9bf4d8402a59fe54af7", "filename": "gcc/cp/lex.h", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,124 @@\n+/* Define constants and variables for communication with cp-parse.y.\n+   Copyright (C) 1987, 1992, 1993 Free Software Foundation, Inc.\n+   Hacked by Michael Tiemann (tiemann@cygnus.com)\n+   and by Brendan Kehoe (brendan@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY.  No author or distributor\n+accepts responsibility to anyone for the consequences of using it\n+or for whether it serves any particular purpose or works at all,\n+unless he says so in writing.  Refer to the GNU CC General Public\n+License for full details.\n+\n+Everyone is granted permission to copy, modify and redistribute\n+GNU CC, but only under the conditions described in the\n+GNU CC General Public License.   A copy of this license is\n+supposed to have been given to you along with GNU CC so you\n+can know your rights and responsibilities.  It should be in a\n+file named COPYING.  Among other things, the copyright notice\n+and this notice must be preserved on all copies.  */\n+\n+\n+\n+enum rid\n+{\n+  RID_UNUSED,\n+  RID_INT,\n+  RID_CHAR,\n+  RID_WCHAR,\n+  RID_FLOAT,\n+  RID_DOUBLE,\n+  RID_VOID,\n+\n+  /* C++ extension */\n+  RID_CLASS,\n+  RID_RECORD,\n+  RID_UNION,\n+  RID_ENUM,\n+  RID_LONGLONG,\n+\n+  /* This is where grokdeclarator starts its search when setting the specbits.\n+     The first seven are in the order of most frequently used, as found\n+     building libg++.  */\n+\n+  RID_EXTERN,\n+  RID_CONST,\n+  RID_LONG,\n+  RID_TYPEDEF,\n+  RID_UNSIGNED,\n+  RID_SHORT,\n+  RID_INLINE,\n+\n+  RID_STATIC,\n+\n+  RID_REGISTER,\n+  RID_VOLATILE,\n+  RID_FRIEND,\n+  RID_VIRTUAL,\n+  RID_PUBLIC,\n+  RID_PRIVATE,\n+  RID_PROTECTED,\n+  RID_SIGNED,\n+  RID_EXCEPTION,\n+  RID_RAISES,\n+  RID_AUTO,\n+  RID_MUTABLE,\n+  RID_SIGNATURE,\n+  /* Before adding enough to get up to 64, the RIDBIT_* macros\n+     will have to be changed a little. */\n+  RID_MAX\n+};\n+\n+#define NORID RID_UNUSED\n+\n+#define RID_FIRST_MODIFIER RID_EXTERN\n+\n+/* The type that can represent all values of RIDBIT.  */\n+/* We assume that we can stick in at least 32 bits into this. */\n+typedef struct { unsigned long idata[2]; }\n+     RID_BIT_TYPE;\n+\n+/* Be careful, all these modify N twice. */\n+#define RIDBIT_SETP(N, V) (((unsigned long)1 << (int) ((N)%32))\t\t      \\\n+\t\t\t    & (V).idata[(N)/32])\n+#define RIDBIT_NOTSETP(NN, VV) (! RIDBIT_SETP (NN, VV))\n+#define RIDBIT_SET(N, V) do {\t\t\t\t\t\t      \\\n+\t\t\t\t(V).idata[(N)/32]\t\t\t      \\\n+\t\t\t\t  |= ((unsigned long)1 << (int) ((N)%32));    \\\n+\t\t\t      } while (0)\n+#define RIDBIT_RESET(N, V) do {\t\t\t\t\t\t      \\\n+\t\t\t\t  (V).idata[(N)/32]\t\t\t      \\\n+\t\t\t\t    &= ~((unsigned long)1 << (int) ((N)%32)); \\\n+\t\t\t\t} while (0)\n+#define RIDBIT_RESET_ALL(V) do {\t\t\t\t\t      \\\n+\t\t\t\t   (V).idata[0] = 0;     \t\t      \\\n+\t\t\t\t   (V).idata[1] = 0;\t\t\t      \\\n+\t\t\t\t } while (0)\n+#define RIDBIT_ANY_SET(V) ((V).idata[0] || (V).idata[1])\n+\n+/* The elements of `ridpointers' are identifier nodes\n+   for the reserved type names and storage classes.\n+   It is indexed by a RID_... value.  */\n+extern tree ridpointers[(int) RID_MAX];\n+\n+/* the declaration found for the last IDENTIFIER token read in.\n+   yylex must look this up to detect typedefs, which get token type TYPENAME,\n+   so it is left around in case the identifier is not a typedef but is\n+   used in a context which makes it a reference to a variable.  */\n+extern tree lastiddecl;\n+\n+extern char *token_buffer;\t/* Pointer to token buffer.  */\n+\n+/* Back-door communication channel to the lexer.  */\n+extern int looking_for_typename;\n+\n+/* Pending language change.\n+   Positive is push count, negative is pop count.  */\n+extern int pending_lang_change;\n+\n+extern tree make_pointer_declarator (), make_reference_declarator ();\n+extern void reinit_parse_for_function ();\n+extern void reinit_parse_for_method ();\n+extern int yylex ();"}, {"sha": "83750436546e4b4b7e2090f3f1aa85811ad9b3ee", "filename": "gcc/cp/method.c", "status": "added", "additions": 1651, "deletions": 0, "changes": 1651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,1651 @@\n+/* Handle the hair of processing (but not expanding) inline functions.\n+   Also manage function and variable name overloading.\n+   Copyright (C) 1987, 1989, 1992, 1993 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@cygnus.com)\n+\n+   This file is part of GNU CC.\n+   \n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#ifndef PARM_CAN_BE_ARRAY_TYPE\n+#define PARM_CAN_BE_ARRAY_TYPE 1\n+#endif\n+\n+/* Handle method declarations.  */\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"cp-tree.h\"\n+#include \"class.h\"\n+#include \"obstack.h\"\n+#include <ctype.h>\n+\n+/* TREE_LIST of the current inline functions that need to be\n+   processed.  */\n+struct pending_inline *pending_inlines;\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+/* Obstack where we build text strings for overloading, etc.  */\n+static struct obstack scratch_obstack;\n+static char *scratch_firstobj;\n+\n+# define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)\n+# define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))\n+# define OB_PUTC2(C1,C2)\t\\\n+  (obstack_1grow (&scratch_obstack, (C1)), obstack_1grow (&scratch_obstack, (C2)))\n+# define OB_PUTS(S) (obstack_grow (&scratch_obstack, (S), sizeof (S) - 1))\n+# define OB_PUTID(ID)  \\\n+  (obstack_grow (&scratch_obstack, IDENTIFIER_POINTER (ID),\t\\\n+\t\t IDENTIFIER_LENGTH (ID)))\n+# define OB_PUTCP(S) (obstack_grow (&scratch_obstack, (S), strlen (S)))\n+# define OB_FINISH() (obstack_1grow (&scratch_obstack, '\\0'))\n+\n+#ifdef NO_AUTO_OVERLOAD\n+int is_overloaded ();\n+#endif\n+\n+void\n+init_method ()\n+{\n+  gcc_obstack_init (&scratch_obstack);\n+  scratch_firstobj = (char *)obstack_alloc (&scratch_obstack, 0);\n+}\n+\n+/* This must be large enough to hold any printed integer or floating-point\n+   value.  */\n+static char digit_buffer[128];\n+\n+/* Move inline function definitions out of structure so that they\n+   can be processed normally.  CNAME is the name of the class\n+   we are working from, METHOD_LIST is the list of method lists\n+   of the structure.  We delete friend methods here, after\n+   saving away their inline function definitions (if any).  */\n+\n+void\n+do_inline_function_hair (type, friend_list)\n+     tree type, friend_list;\n+{\n+  tree method = TYPE_METHODS (type);\n+\n+  if (method && TREE_CODE (method) == TREE_VEC)\n+    {\n+      if (TREE_VEC_ELT (method, 0))\n+\tmethod = TREE_VEC_ELT (method, 0);\n+      else\n+\tmethod = TREE_VEC_ELT (method, 1);\n+    }\n+\n+  while (method)\n+    {\n+      /* Do inline member functions.  */\n+      struct pending_inline *info = DECL_PENDING_INLINE_INFO (method);\n+      if (info)\n+\t{\n+\t  tree args;\n+\n+\t  my_friendly_assert (info->fndecl == method, 238);\n+\t  args = DECL_ARGUMENTS (method);\n+\t  while (args)\n+\t    {\n+\t      DECL_CONTEXT (args) = method;\n+\t      args = TREE_CHAIN (args);\n+\t    }\n+\n+\t  /* Allow this decl to be seen in global scope */\n+\t  IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (method)) = method;\n+\t}\n+      method = TREE_CHAIN (method);\n+    }\n+  while (friend_list)\n+    {\n+      tree fndecl = TREE_VALUE (friend_list);\n+      struct pending_inline *info = DECL_PENDING_INLINE_INFO (fndecl);\n+      if (info)\n+\t{\n+\t  tree args;\n+\n+\t  my_friendly_assert (info->fndecl == fndecl, 239);\n+\t  args = DECL_ARGUMENTS (fndecl);\n+\t  while (args)\n+\t    {\n+\t      DECL_CONTEXT (args) = fndecl;\n+\t      args = TREE_CHAIN (args);\n+\t    }\n+\n+\t  /* Allow this decl to be seen in global scope */\n+\t  IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (fndecl)) = fndecl;\n+\t}\n+\n+      friend_list = TREE_CHAIN (friend_list);\n+    }\n+}\n+\f\n+/* Report an argument type mismatch between the best declared function\n+   we could find and the current argument list that we have.  */\n+void\n+report_type_mismatch (cp, parmtypes, name_kind)\n+     struct candidate *cp;\n+     tree parmtypes;\n+     char *name_kind;\n+{\n+  int i = cp->u.bad_arg;\n+  tree ttf, tta;\n+  char *tmp_firstobj;\n+\n+  switch (i)\n+    {\n+    case -4:\n+      my_friendly_assert (TREE_CODE (cp->function) == TEMPLATE_DECL, 240);\n+      cp_error (\"type unification failed for function template `%#D'\",\n+\t\tcp->function);\n+      return;\n+\n+    case -3:\n+      if (TYPE_READONLY (TREE_TYPE (TREE_VALUE (parmtypes))))\n+\tcp_error (\"call to const %s `%#D' with non-const object\", name_kind,\n+\t\t  cp->function);\n+      else\n+\tcp_error (\"call to non-const %s `%#D' with const object\", name_kind,\n+\t\t  cp->function);\n+      return;\n+    case -2:\n+      cp_error (\"too few arguments for %s `%#D'\", name_kind, cp->function);\n+      return;\n+    case -1:\n+      cp_error (\"too many arguments for %s `%#D'\", name_kind, cp->function);\n+      return;\n+    case 0:\n+      if (TREE_CODE (TREE_TYPE (cp->function)) == METHOD_TYPE)\n+\t{\n+\t  /* Happens when we have an ambiguous base class.  */\n+\t  my_friendly_assert (get_binfo (DECL_CLASS_CONTEXT (cp->function),\n+\t\t\t     TREE_TYPE (TREE_TYPE (TREE_VALUE (parmtypes))), 1) == error_mark_node,\n+\t\t\t      241);\n+\t  return;\n+\t}\n+    }\n+\n+  ttf = TYPE_ARG_TYPES (TREE_TYPE (cp->function));\n+  tta = parmtypes;\n+\n+  while (i-- > 0)\n+    {\n+      ttf = TREE_CHAIN (ttf);\n+      tta = TREE_CHAIN (tta);\n+    }\n+\n+  OB_INIT ();\n+  OB_PUTS (\"bad argument \");\n+  sprintf (digit_buffer, \"%d\", cp->u.bad_arg\n+\t   - (TREE_CODE (TREE_TYPE (cp->function)) == METHOD_TYPE)\n+\t   + 1);\n+  OB_PUTCP (digit_buffer);\n+\n+  OB_PUTS (\" for function `\");\n+  OB_PUTCP (decl_as_string (cp->function, 1));\n+  OB_PUTS (\"' (type was \");\n+\n+  /* Reset `i' so that type printing routines do the right thing.  */\n+  if (tta)\n+    {\n+      enum tree_code code = TREE_CODE (TREE_TYPE (TREE_VALUE (tta)));\n+      if (code == ERROR_MARK)\n+\tOB_PUTS (\"(failed type instantiation)\");\n+      else\n+\t{\n+\t  i = (code == FUNCTION_TYPE || code == METHOD_TYPE);\n+\t  OB_PUTCP (type_as_string (TREE_TYPE (TREE_VALUE (tta)), 1));\n+\t}\n+    }\n+  else OB_PUTS (\"void\");\n+  OB_PUTC (')');\n+  OB_FINISH ();\n+\n+  tmp_firstobj = (char *)alloca (obstack_object_size (&scratch_obstack));\n+  bcopy (obstack_base (&scratch_obstack), tmp_firstobj,\n+\t obstack_object_size (&scratch_obstack));\n+  error (tmp_firstobj);\n+}\n+\f\n+/* Here is where overload code starts.  */\n+\n+/* Array of types seen so far in top-level call to `build_overload_name'.\n+   Allocated and deallocated by caller.  */\n+static tree *typevec;\n+\n+/* Number of types interned by `build_overload_name' so far.  */\n+static int maxtype;\n+\n+/* Number of occurrences of last type seen.  */\n+static int nrepeats;\n+\n+/* Nonzero if we should not try folding parameter types.  */\n+static int nofold;\n+\n+#define ALLOCATE_TYPEVEC(PARMTYPES) \\\n+  do { maxtype = 0, nrepeats = 0; \\\n+       typevec = (tree *)alloca (list_length (PARMTYPES) * sizeof (tree)); } while (0)\n+\n+#define DEALLOCATE_TYPEVEC(PARMTYPES) \\\n+  do { tree t = (PARMTYPES); \\\n+       while (t) { TREE_USED (TREE_VALUE (t)) = 0; t = TREE_CHAIN (t); } \\\n+  } while (0)\n+\n+/* Code to concatenate an asciified integer to a string.  */\n+static\n+#ifdef __GNUC__\n+__inline\n+#endif\n+void\n+icat (i)\n+     int i;\n+{\n+  /* Handle this case first, to go really quickly.  For many common values,\n+     the result of i/10 below is 1.  */\n+  if (i == 1)\n+    {\n+      OB_PUTC ('1');\n+      return;\n+    }\n+\n+  if (i < 0)\n+    {\n+      OB_PUTC ('m');\n+      i = -i;\n+    }\n+  if (i < 10)\n+    OB_PUTC ('0' + i);\n+  else\n+    {\n+      icat (i / 10);\n+      OB_PUTC ('0' + (i % 10));\n+    }\n+}\n+\n+static\n+#ifdef __GNUC__\n+__inline\n+#endif\n+void\n+flush_repeats (type)\n+     tree type;\n+{\n+  int tindex = 0;\n+\n+  while (typevec[tindex] != type)\n+    tindex++;\n+\n+  if (nrepeats > 1)\n+    {\n+      OB_PUTC ('N');\n+      icat (nrepeats);\n+      if (nrepeats > 9)\n+\tOB_PUTC ('_');\n+    }\n+  else\n+    OB_PUTC ('T');\n+  nrepeats = 0;\n+  icat (tindex);\n+  if (tindex > 9)\n+    OB_PUTC ('_');\n+}\n+\n+static void build_overload_identifier ();\n+\n+static void\n+build_overload_nested_name (context)\n+     tree context;\n+{\n+  /* We use DECL_NAME here, because pushtag now sets the DECL_ASSEMBLER_NAME.  */\n+  tree name = DECL_NAME (context);\n+  if (DECL_CONTEXT (context))\n+    {\n+      context = DECL_CONTEXT (context);\n+      if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n+\tcontext = TYPE_NAME (context);\n+      build_overload_nested_name (context);\n+    }\n+  build_overload_identifier (name);\n+}\n+\n+static void\n+build_overload_value (type, value)\n+     tree type, value;\n+{\n+  while (TREE_CODE (value) == NON_LVALUE_EXPR\n+\t || TREE_CODE (value) == NOP_EXPR)\n+    value = TREE_OPERAND (value, 0);\n+  my_friendly_assert (TREE_CODE (type) == PARM_DECL, 242);\n+  type = TREE_TYPE (type);\n+  switch (TREE_CODE (type))\n+    {\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+      {\n+\tmy_friendly_assert (TREE_CODE (value) == INTEGER_CST, 243);\n+\tif (TYPE_PRECISION (value) == 2 * HOST_BITS_PER_WIDE_INT)\n+\t  {\n+\t    if (tree_int_cst_lt (value, integer_zero_node))\n+\t      {\n+\t\tOB_PUTC ('m');\n+\t\tvalue = build_int_2 (~ TREE_INT_CST_LOW (value),\n+\t\t\t\t     - TREE_INT_CST_HIGH (value));\n+\t      }\n+\t    if (TREE_INT_CST_HIGH (value)\n+\t\t!= (TREE_INT_CST_LOW (value) >> (HOST_BITS_PER_WIDE_INT - 1)))\n+\t      {\n+\t\t/* need to print a DImode value in decimal */\n+\t\tsorry (\"conversion of long long as PT parameter\");\n+\t      }\n+\t    /* else fall through to print in smaller mode */\n+\t  }\n+\t/* Wordsize or smaller */\n+\ticat (TREE_INT_CST_LOW (value));\n+\treturn;\n+      }\n+#ifndef REAL_IS_NOT_DOUBLE\n+    case REAL_TYPE:\n+      {\n+\tREAL_VALUE_TYPE val;\n+\tchar *bufp = digit_buffer;\n+\textern char *index ();\n+\n+\tmy_friendly_assert (TREE_CODE (value) == REAL_CST, 244);\n+\tval = TREE_REAL_CST (value);\n+\tif (val < 0)\n+\t  {\n+\t    val = -val;\n+\t    *bufp++ = 'm';\n+\t  }\n+\tsprintf (bufp, \"%e\", val);\n+\tbufp = (char *) index (bufp, 'e');\n+\tif (!bufp)\n+\t  strcat (digit_buffer, \"e0\");\n+\telse\n+\t  {\n+\t    char *p;\n+\t    bufp++;\n+\t    if (*bufp == '-')\n+\t      {\n+\t\t*bufp++ = 'm';\n+\t      }\n+\t    p = bufp;\n+\t    if (*p == '+')\n+\t      p++;\n+\t    while (*p == '0')\n+\t      p++;\n+\t    if (*p == 0)\n+\t      {\n+\t\t*bufp++ = '0';\n+\t\t*bufp = 0;\n+\t      }\n+\t    else if (p != bufp)\n+\t      {\n+\t\twhile (*p)\n+\t\t  *bufp++ = *p++;\n+\t\t*bufp = 0;\n+\t      }\n+\t  }\n+\tOB_PUTCP (digit_buffer);\n+\treturn;\n+      }\n+#endif\n+    case POINTER_TYPE:\n+      value = TREE_OPERAND (value, 0);\n+      if (TREE_CODE (value) == VAR_DECL)\n+\t{\n+\t  my_friendly_assert (DECL_NAME (value) != 0, 245);\n+\t  build_overload_identifier (DECL_NAME (value));\n+\t  return;\n+\t}\n+      else if (TREE_CODE (value) == FUNCTION_DECL)\n+\t{\n+\t  my_friendly_assert (DECL_NAME (value) != 0, 246);\n+\t  build_overload_identifier (DECL_NAME (value));\n+\t  return;\n+\t}\n+      else\n+\tmy_friendly_abort (71);\n+      break; /* not really needed */\n+\n+    default:\n+      sorry (\"conversion of %s as template parameter\",\n+\t     tree_code_name [(int) TREE_CODE (type)]);\n+      my_friendly_abort (72);\n+    }\n+}\n+\n+static void\n+build_overload_identifier (name)\n+     tree name;\n+{\n+  if (IDENTIFIER_TEMPLATE (name))\n+    {\n+      tree template, parmlist, arglist, tname;\n+      int i, nparms;\n+      template = IDENTIFIER_TEMPLATE (name);\n+      arglist = TREE_VALUE (template);\n+      template = TREE_PURPOSE (template);\n+      tname = DECL_NAME (template);\n+      parmlist = DECL_ARGUMENTS (template);\n+      nparms = TREE_VEC_LENGTH (parmlist);\n+      OB_PUTC ('t');\n+      icat (IDENTIFIER_LENGTH (tname));\n+      OB_PUTID (tname);\n+      icat (nparms);\n+      for (i = 0; i < nparms; i++)\n+\t{\n+\t  tree parm = TREE_VEC_ELT (parmlist, i);\n+\t  tree arg = TREE_VEC_ELT (arglist, i);\n+\t  if (TREE_CODE (parm) == IDENTIFIER_NODE)\n+\t    {\n+\t      /* This parameter is a type.  */\n+\t      OB_PUTC ('Z');\n+\t      build_overload_name (arg, 0, 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* It's a PARM_DECL.  */\n+\t      build_overload_name (TREE_TYPE (parm), 0, 0);\n+\t      build_overload_value (parm, arg);\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      icat (IDENTIFIER_LENGTH (name));\n+      OB_PUTID (name);\n+    }\n+}\n+\n+/* Given a list of parameters in PARMTYPES, create an unambiguous\n+   overload string. Should distinguish any type that C (or C++) can\n+   distinguish. I.e., pointers to functions are treated correctly.\n+\n+   Caller must deal with whether a final `e' goes on the end or not.\n+\n+   Any default conversions must take place before this function\n+   is called.\n+\n+   BEGIN and END control initialization and finalization of the\n+   obstack where we build the string.  */\n+\n+char *\n+build_overload_name (parmtypes, begin, end)\n+     tree parmtypes;\n+     int begin, end;\n+{\n+  int just_one;\n+  tree parmtype;\n+\n+  if (begin) OB_INIT ();\n+\n+  if (just_one = (TREE_CODE (parmtypes) != TREE_LIST))\n+    {\n+      parmtype = parmtypes;\n+      goto only_one;\n+    }\n+\n+  while (parmtypes)\n+    {\n+      parmtype = TREE_VALUE (parmtypes);\n+\n+    only_one:\n+\n+      if (! nofold)\n+\t{\n+\t  if (! just_one)\n+\t    /* Every argument gets counted.  */\n+\t    typevec[maxtype++] = parmtype;\n+\n+\t  if (TREE_USED (parmtype))\n+\t    {\n+\t      if (! just_one && parmtype == typevec[maxtype-2])\n+\t\tnrepeats++;\n+\t      else\n+\t\t{\n+\t\t  if (nrepeats)\n+\t\t    flush_repeats (parmtype);\n+\t\t  if (! just_one && TREE_CHAIN (parmtypes)\n+\t\t      && parmtype == TREE_VALUE (TREE_CHAIN (parmtypes)))\n+\t\t    nrepeats++;\n+\t\t  else\n+\t\t    {\n+\t\t      int tindex = 0;\n+\n+\t\t      while (typevec[tindex] != parmtype)\n+\t\t\ttindex++;\n+\t\t      OB_PUTC ('T');\n+\t\t      icat (tindex);\n+\t\t      if (tindex > 9)\n+\t\t\tOB_PUTC ('_');\n+\t\t    }\n+\t\t}\n+\t      goto next;\n+\t    }\n+\t  if (nrepeats)\n+\t    flush_repeats (typevec[maxtype-2]);\n+\t  if (! just_one\n+\t      /* Only cache types which take more than one character.  */\n+\t      && (parmtype != TYPE_MAIN_VARIANT (parmtype)\n+\t\t  || (TREE_CODE (parmtype) != INTEGER_TYPE\n+\t\t      && TREE_CODE (parmtype) != REAL_TYPE)))\n+\t    TREE_USED (parmtype) = 1;\n+\t}\n+\n+      if (TYPE_PTRMEMFUNC_P (parmtype))\n+\tparmtype = TYPE_PTRMEMFUNC_FN_TYPE (parmtype);\n+\n+      if (TREE_READONLY (parmtype))\n+\tOB_PUTC ('C');\n+      if (TREE_CODE (parmtype) == INTEGER_TYPE\n+\t  && TYPE_MAIN_VARIANT (parmtype) == unsigned_type (TYPE_MAIN_VARIANT (parmtype)))\n+\tOB_PUTC ('U');\n+      if (TYPE_VOLATILE (parmtype))\n+\tOB_PUTC ('V');\n+\n+      switch (TREE_CODE (parmtype))\n+\t{\n+\tcase OFFSET_TYPE:\n+\t  OB_PUTC ('O');\n+\t  build_overload_name (TYPE_OFFSET_BASETYPE (parmtype), 0, 0);\n+\t  OB_PUTC ('_');\n+\t  build_overload_name (TREE_TYPE (parmtype), 0, 0);\n+\t  break;\n+\n+\tcase REFERENCE_TYPE:\n+\t  OB_PUTC ('R');\n+\t  goto more;\n+\n+\tcase ARRAY_TYPE:\n+#if PARM_CAN_BE_ARRAY_TYPE\n+\t  {\n+\t    tree length;\n+\n+\t    OB_PUTC ('A');\n+\t    if (TYPE_DOMAIN (parmtype) == NULL_TREE)\n+\t      {\n+\t\terror (\"parameter type with unspecified array bounds invalid\");\n+\t\ticat (1);\n+\t      }\n+\t    else\n+\t      {\n+\t\tlength = array_type_nelts (parmtype);\n+\t\tif (TREE_CODE (length) == INTEGER_CST)\n+\t\t  icat (TREE_INT_CST_LOW (length) + 1);\n+\t      }\n+\t    OB_PUTC ('_');\n+\t    goto more;\n+\t  }\n+#else\n+\t  OB_PUTC ('P');\n+\t  goto more;\n+#endif\n+\n+\tcase POINTER_TYPE:\n+\t  OB_PUTC ('P');\n+\tmore:\n+\t  build_overload_name (TREE_TYPE (parmtype), 0, 0);\n+\t  break;\n+\n+\tcase FUNCTION_TYPE:\n+\tcase METHOD_TYPE:\n+\t  {\n+\t    tree firstarg = TYPE_ARG_TYPES (parmtype);\n+\t    /* Otherwise have to implement reentrant typevecs,\n+\t       unmark and remark types, etc.  */\n+\t    int old_nofold = nofold;\n+\t    nofold = 1;\n+\n+\t    if (nrepeats)\n+\t      flush_repeats (typevec[maxtype-1]);\n+\n+\t    /* @@ It may be possible to pass a function type in\n+\t       which is not preceded by a 'P'.  */\n+\t    if (TREE_CODE (parmtype) == FUNCTION_TYPE)\n+\t      {\n+\t\tOB_PUTC ('F');\n+\t\tif (firstarg == NULL_TREE)\n+\t\t  OB_PUTC ('e');\n+\t\telse if (firstarg == void_list_node)\n+\t\t  OB_PUTC ('v');\n+\t\telse\n+\t\t  build_overload_name (firstarg, 0, 0);\n+\t      }\n+\t    else\n+\t      {\n+\t\tint constp = TYPE_READONLY (TREE_TYPE (TREE_VALUE (firstarg)));\n+\t\tint volatilep = TYPE_VOLATILE (TREE_TYPE (TREE_VALUE (firstarg)));\n+\t\tOB_PUTC ('M');\n+\t\tfirstarg = TREE_CHAIN (firstarg);\n+\n+\t\tbuild_overload_name (TYPE_METHOD_BASETYPE (parmtype), 0, 0);\n+\t\tif (constp)\n+\t\t  OB_PUTC ('C');\n+\t\tif (volatilep)\n+\t\t  OB_PUTC ('V');\n+\n+\t\t/* For cfront 2.0 compatibility.  */\n+\t\tOB_PUTC ('F');\n+\n+\t\tif (firstarg == NULL_TREE)\n+\t\t  OB_PUTC ('e');\n+\t\telse if (firstarg == void_list_node)\n+\t\t  OB_PUTC ('v');\n+\t\telse\n+\t\t  build_overload_name (firstarg, 0, 0);\n+\t      }\n+\n+\t    /* Separate args from return type.  */\n+\t    OB_PUTC ('_');\n+\t    build_overload_name (TREE_TYPE (parmtype), 0, 0);\n+\t    nofold = old_nofold;\n+\t    break;\n+\t  }\n+\n+\tcase INTEGER_TYPE:\n+\t  parmtype = TYPE_MAIN_VARIANT (parmtype);\n+\t  if (parmtype == integer_type_node\n+\t      || parmtype == unsigned_type_node)\n+\t    OB_PUTC ('i');\n+\t  else if (parmtype == long_integer_type_node\n+\t\t   || parmtype == long_unsigned_type_node)\n+\t    OB_PUTC ('l');\n+\t  else if (parmtype == short_integer_type_node\n+\t\t   || parmtype == short_unsigned_type_node)\n+\t    OB_PUTC ('s');\n+\t  else if (parmtype == signed_char_type_node)\n+\t    {\n+\t      OB_PUTC ('S');\n+\t      OB_PUTC ('c');\n+\t    }\n+\t  else if (parmtype == char_type_node\n+\t\t   || parmtype == unsigned_char_type_node)\n+\t    OB_PUTC ('c');\n+\t  else if (parmtype == wchar_type_node)\n+\t    OB_PUTC ('w');\n+\t  else if (parmtype == long_long_integer_type_node\n+\t      || parmtype == long_long_unsigned_type_node)\n+\t    OB_PUTC ('x');\n+#if 0\n+\t  /* it would seem there is no way to enter these in source code,\n+\t     yet.  (mrs) */\n+\t  else if (parmtype == long_long_long_integer_type_node\n+\t      || parmtype == long_long_long_unsigned_type_node)\n+\t    OB_PUTC ('q');\n+#endif\n+\t  else\n+\t    my_friendly_abort (73);\n+\t  break;\n+\n+\tcase REAL_TYPE:\n+\t  parmtype = TYPE_MAIN_VARIANT (parmtype);\n+\t  if (parmtype == long_double_type_node)\n+\t    OB_PUTC ('r');\n+\t  else if (parmtype == double_type_node)\n+\t    OB_PUTC ('d');\n+\t  else if (parmtype == float_type_node)\n+\t    OB_PUTC ('f');\n+\t  else my_friendly_abort (74);\n+\t  break;\n+\n+\tcase VOID_TYPE:\n+\t  if (! just_one)\n+\t    {\n+#if 0\n+\t      extern tree void_list_node;\n+\n+\t      /* See if anybody is wasting memory.  */\n+\t      my_friendly_assert (parmtypes == void_list_node, 247);\n+#endif\n+\t      /* This is the end of a parameter list.  */\n+\t      if (end) OB_FINISH ();\n+\t      return (char *)obstack_base (&scratch_obstack);\n+\t    }\n+\t  OB_PUTC ('v');\n+\t  break;\n+\n+\tcase ERROR_MARK:\t/* not right, but nothing is anyway */\n+\t  break;\n+\n+\t  /* have to do these */\n+\tcase UNION_TYPE:\n+\tcase RECORD_TYPE:\n+\t  if (! just_one)\n+\t    /* Make this type signature look incompatible\n+\t       with AT&T.  */\n+\t    OB_PUTC ('G');\n+\t  goto common;\n+\tcase ENUMERAL_TYPE:\n+\tcommon:\n+\t  {\n+\t    tree name = TYPE_NAME (parmtype);\n+\t    int i = 1;\n+\n+\t    if (TREE_CODE (name) == TYPE_DECL)\n+\t      {\n+\t\ttree context = name;\n+\t\twhile (DECL_CONTEXT (context))\n+\t\t  {\n+\t\t    i += 1;\n+\t\t    context = DECL_CONTEXT (context);\n+\t\t    if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n+\t\t      context = TYPE_NAME (context);\n+\t\t  }\n+\t\tname = DECL_NAME (name);\n+\t      }\n+\t    my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 248);\n+\t    if (i > 1)\n+\t      {\n+\t\tOB_PUTC ('Q');\n+\t\tif (i > 9)\n+\t\t  OB_PUTC ('_');\n+\t\ticat (i);\n+\t\tif (i > 9)\n+\t\t  OB_PUTC ('_');\n+\t\tbuild_overload_nested_name (TYPE_NAME (parmtype));\n+\t      }\n+\t    else\n+\t      build_overload_identifier (name);\n+\t    break;\n+\t  }\n+\n+\tcase UNKNOWN_TYPE:\n+\t  /* This will take some work.  */\n+\t  OB_PUTC ('?');\n+\t  break;\n+\n+\tcase TEMPLATE_TYPE_PARM:\n+\tcase TEMPLATE_CONST_PARM:\n+        case UNINSTANTIATED_P_TYPE:\n+\t  /* We don't ever want this output, but it's inconvenient not to\n+\t     be able to build the string.  This should cause assembler\n+\t     errors we'll notice.  */\n+\t  {\n+\t    static int n;\n+\t    sprintf (digit_buffer, \" *%d\", n++);\n+\t    OB_PUTCP (digit_buffer);\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  my_friendly_abort (75);\n+\t}\n+\n+    next:\n+      if (just_one) break;\n+      parmtypes = TREE_CHAIN (parmtypes);\n+    }\n+  if (! just_one)\n+    {\n+      if (nrepeats)\n+\tflush_repeats (typevec[maxtype-1]);\n+\n+      /* To get here, parms must end with `...'. */\n+      OB_PUTC ('e');\n+    }\n+\n+  if (end) OB_FINISH ();\n+  return (char *)obstack_base (&scratch_obstack);\n+}\n+\f\n+/* Generate an identifier that encodes the (ANSI) exception TYPE. */\n+\n+/* This should be part of `ansi_opname', or at least be defined by the std.  */\n+#define EXCEPTION_NAME_PREFIX \"__ex\"\n+#define EXCEPTION_NAME_LENGTH 4\n+\n+tree\n+cplus_exception_name (type)\n+     tree type;\n+{\n+  OB_INIT ();\n+  OB_PUTS (EXCEPTION_NAME_PREFIX);\n+  return get_identifier (build_overload_name (type, 0, 1));\n+}\n+\f\n+/* Change the name of a function definition so that it may be\n+   overloaded. NAME is the name of the function to overload,\n+   PARMS is the parameter list (which determines what name the\n+   final function obtains).\n+\n+   FOR_METHOD is 1 if this overload is being performed\n+   for a method, rather than a function type.  It is 2 if\n+   this overload is being performed for a constructor.  */\n+tree\n+build_decl_overload (dname, parms, for_method)\n+     tree dname;\n+     tree parms;\n+     int for_method;\n+{\n+  char *name = IDENTIFIER_POINTER (dname);\n+\n+  if (dname == ansi_opname[(int) NEW_EXPR]\n+      && parms != NULL_TREE\n+      && TREE_CODE (parms) == TREE_LIST\n+      && TREE_VALUE (parms) == sizetype\n+      && TREE_CHAIN (parms) == void_list_node)\n+    return get_identifier (\"__builtin_new\");\n+  else if (dname == ansi_opname[(int) DELETE_EXPR]\n+\t   && parms != NULL_TREE\n+\t   && TREE_CODE (parms) == TREE_LIST\n+\t   && TREE_VALUE (parms) == ptr_type_node\n+\t   && TREE_CHAIN (parms) == void_list_node)\n+    return get_identifier (\"__builtin_delete\");\n+  else if (dname == ansi_opname[(int) DELETE_EXPR]\n+\t   && parms != NULL_TREE\n+\t   && TREE_CODE (parms) == TREE_LIST\n+\t   && TREE_VALUE (parms) == ptr_type_node\n+\t   && TREE_CHAIN (parms) != NULL_TREE\n+\t   && TREE_CODE (TREE_CHAIN (parms)) == TREE_LIST\n+\t   && TREE_VALUE (TREE_CHAIN (parms)) == sizetype\n+\t   && TREE_CHAIN (TREE_CHAIN (parms)) == void_list_node)\n+    return get_identifier (\"__builtin_delete\");\n+\n+  OB_INIT ();\n+  if (for_method != 2)\n+    OB_PUTCP (name);\n+  /* Otherwise, we can divine that this is a constructor,\n+     and figure out its name without any extra encoding.  */\n+\n+  OB_PUTC2 ('_', '_');\n+  if (for_method)\n+    {\n+#if 0\n+      /* We can get away without doing this.  */\n+      OB_PUTC ('M');\n+#endif\n+      {\n+\ttree this_type = TREE_VALUE (parms);\n+\n+\tif (TREE_CODE (this_type) == RECORD_TYPE)  /* a signature pointer */\n+\t  parms = temp_tree_cons (NULL_TREE, SIGNATURE_TYPE (this_type),\n+\t\t\t\t  TREE_CHAIN (parms));\n+\telse\n+\t  parms = temp_tree_cons (NULL_TREE, TREE_TYPE (this_type),\n+\t\t\t\t  TREE_CHAIN (parms));\n+      }\n+    }\n+  else\n+    OB_PUTC ('F');\n+\n+  if (parms == NULL_TREE)\n+    OB_PUTC2 ('e', '\\0');\n+  else if (parms == void_list_node)\n+    OB_PUTC2 ('v', '\\0');\n+  else\n+    {\n+      ALLOCATE_TYPEVEC (parms);\n+      nofold = 0;\n+      if (for_method)\n+\t{\n+\t  build_overload_name (TREE_VALUE (parms), 0, 0);\n+\n+\t  typevec[maxtype++] = TREE_VALUE (parms);\n+\t  TREE_USED (TREE_VALUE (parms)) = 1;\n+\n+\t  if (TREE_CHAIN (parms))\n+\t    build_overload_name (TREE_CHAIN (parms), 0, 1);\n+\t  else\n+\t    OB_PUTC2 ('e', '\\0');\n+\t}\n+      else\n+\tbuild_overload_name (parms, 0, 1);\n+      DEALLOCATE_TYPEVEC (parms);\n+    }\n+  {\n+    tree n = get_identifier (obstack_base (&scratch_obstack));\n+    if (IDENTIFIER_OPNAME_P (dname))\n+      IDENTIFIER_OPNAME_P (n) = 1;\n+    return n;\n+  }\n+}\n+\n+/* Build an overload name for the type expression TYPE.  */\n+tree\n+build_typename_overload (type)\n+     tree type;\n+{\n+  tree id;\n+\n+  OB_INIT ();\n+  OB_PUTID (ansi_opname[(int) TYPE_EXPR]);\n+  nofold = 1;\n+  build_overload_name (type, 0, 1);\n+  id = get_identifier (obstack_base (&scratch_obstack));\n+  IDENTIFIER_OPNAME_P (id) = 1;\n+  return id;\n+}\n+\n+#ifndef NO_DOLLAR_IN_LABEL\n+#define T_DESC_FORMAT \"TD$\"\n+#define I_DESC_FORMAT \"ID$\"\n+#define M_DESC_FORMAT \"MD$\"\n+#else\n+#if !defined(NO_DOT_IN_LABEL)\n+#define T_DESC_FORMAT \"TD.\"\n+#define I_DESC_FORMAT \"ID.\"\n+#define M_DESC_FORMAT \"MD.\"\n+#else\n+#define T_DESC_FORMAT \"__t_desc_\"\n+#define I_DESC_FORMAT \"__i_desc_\"\n+#define M_DESC_FORMAT \"__m_desc_\"\n+#endif\n+#endif\n+\n+/* Build an overload name for the type expression TYPE.  */\n+tree\n+build_t_desc_overload (type)\n+     tree type;\n+{\n+  OB_INIT ();\n+  OB_PUTS (T_DESC_FORMAT);\n+  nofold = 1;\n+\n+#if 0\n+  /* Use a different format if the type isn't defined yet.  */\n+  if (TYPE_SIZE (type) == NULL_TREE)\n+    {\n+      char *p;\n+      int changed;\n+\n+      for (p = tname; *p; p++)\n+\tif (isupper (*p))\n+\t  {\n+\t    changed = 1;\n+\t    *p = tolower (*p);\n+\t  }\n+      /* If there's no change, we have an inappropriate T_DESC_FORMAT.  */\n+      my_friendly_assert (changed != 0, 249);\n+    }\n+#endif\n+\n+  build_overload_name (type, 0, 1);\n+  return get_identifier (obstack_base (&scratch_obstack));\n+}\n+\n+/* Top-level interface to explicit overload requests. Allow NAME\n+   to be overloaded. Error if NAME is already declared for the current\n+   scope. Warning if function is redundantly overloaded. */\n+\n+void\n+declare_overloaded (name)\n+     tree name;\n+{\n+#ifdef NO_AUTO_OVERLOAD\n+  if (is_overloaded (name))\n+    warning (\"function `%s' already declared overloaded\",\n+\t     IDENTIFIER_POINTER (name));\n+  else if (IDENTIFIER_GLOBAL_VALUE (name))\n+    error (\"overloading function `%s' that is already defined\",\n+\t   IDENTIFIER_POINTER (name));\n+  else\n+    {\n+      TREE_OVERLOADED (name) = 1;\n+      IDENTIFIER_GLOBAL_VALUE (name) = build_tree_list (name, NULL_TREE);\n+      TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (name)) = unknown_type_node;\n+    }\n+#else\n+  if (current_lang_name == lang_name_cplusplus)\n+    {\n+      if (0)\n+\twarning (\"functions are implicitly overloaded in C++\");\n+    }\n+  else if (current_lang_name == lang_name_c)\n+    error (\"overloading function `%s' cannot be done in C language context\");\n+  else\n+    my_friendly_abort (76);\n+#endif\n+}\n+\n+#ifdef NO_AUTO_OVERLOAD\n+/* Check to see if NAME is overloaded. For first approximation,\n+   check to see if its TREE_OVERLOADED is set.  This is used on\n+   IDENTIFIER nodes.  */\n+int\n+is_overloaded (name)\n+     tree name;\n+{\n+  /* @@ */\n+  return (TREE_OVERLOADED (name)\n+\t  && (! IDENTIFIER_CLASS_VALUE (name) || current_class_type == 0)\n+\t  && ! IDENTIFIER_LOCAL_VALUE (name));\n+}\n+#endif\n+\f\n+/* Given a tree_code CODE, and some arguments (at least one),\n+   attempt to use an overloaded operator on the arguments.\n+\n+   For unary operators, only the first argument need be checked.\n+   For binary operators, both arguments may need to be checked.\n+\n+   Member functions can convert class references to class pointers,\n+   for one-level deep indirection.  More than that is not supported.\n+   Operators [](), ()(), and ->() must be member functions.\n+\n+   We call function call building calls with LOOKUP_COMPLAIN if they\n+   are our only hope.  This is true when we see a vanilla operator\n+   applied to something of aggregate type.  If this fails, we are free\n+   to return `error_mark_node', because we will have reported the\n+   error.\n+\n+   Operators NEW and DELETE overload in funny ways: operator new takes\n+   a single `size' parameter, and operator delete takes a pointer to the\n+   storage being deleted.  When overloading these operators, success is\n+   assumed.  If there is a failure, report an error message and return\n+   `error_mark_node'.  */\n+\n+/* NOSTRICT */\n+tree\n+build_opfncall (code, flags, xarg1, xarg2, arg3)\n+     enum tree_code code;\n+     int flags;\n+     tree xarg1, xarg2, arg3;\n+{\n+  tree rval = 0;\n+  tree arg1, arg2;\n+  tree type1, type2, fnname;\n+  tree fields1 = 0, parms = 0;\n+  tree global_fn;\n+  int try_second;\n+  int binary_is_unary;\n+\n+  if (xarg1 == error_mark_node)\n+    return error_mark_node;\n+\n+  if (code == COND_EXPR)\n+    {\n+      if (TREE_CODE (xarg2) == ERROR_MARK\n+\t  || TREE_CODE (arg3) == ERROR_MARK)\n+\treturn error_mark_node;\n+    }\n+  if (code == COMPONENT_REF)\n+    if (TREE_CODE (TREE_TYPE (xarg1)) == POINTER_TYPE)\n+      return rval;\n+\n+  /* First, see if we can work with the first argument */\n+  type1 = TREE_TYPE (xarg1);\n+\n+  /* Some tree codes have length > 1, but we really only want to\n+     overload them if their first argument has a user defined type.  */\n+  switch (code)\n+    {\n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case COMPONENT_REF:\n+      binary_is_unary = 1;\n+      try_second = 0;\n+      break;\n+\n+      /* ARRAY_REFs and CALL_EXPRs must overload successfully.\n+\t If they do not, return error_mark_node instead of NULL_TREE.  */\n+    case ARRAY_REF:\n+      if (xarg2 == error_mark_node)\n+\treturn error_mark_node;\n+    case CALL_EXPR:\n+      rval = error_mark_node;\n+      binary_is_unary = 0;\n+      try_second = 0;\n+      break;\n+\n+    case NEW_EXPR:\n+      {\n+\tfnname = ansi_opname[(int) NEW_EXPR];\n+\tif (flags & LOOKUP_GLOBAL)\n+\t  return build_overload_call (fnname, tree_cons (NULL_TREE, xarg2, arg3),\n+\t\t\t\t      flags & LOOKUP_COMPLAIN,\n+\t\t\t\t      (struct candidate *)0);\n+\n+\trval = build_method_call\n+\t  (build_indirect_ref (build1 (NOP_EXPR, xarg1, error_mark_node),\n+\t\t\t       \"new\"),\n+\t   fnname, tree_cons (NULL_TREE, xarg2, arg3),\n+\t   NULL_TREE, flags);\n+\tif (rval == error_mark_node)\n+\t  /* User might declare fancy operator new, but invoke it\n+\t     like standard one.  */\n+\t  return rval;\n+\n+\tTREE_TYPE (rval) = xarg1;\n+\tTREE_CALLS_NEW (rval) = 1;\n+\treturn rval;\n+      }\n+      break;\n+\n+    case DELETE_EXPR:\n+      {\n+\tfnname = ansi_opname[(int) DELETE_EXPR];\n+\tif (flags & LOOKUP_GLOBAL)\n+\t  return build_overload_call (fnname,\n+\t\t\t\t      tree_cons (NULL_TREE, xarg1,\n+\t\t\t\t\t\t build_tree_list (NULL_TREE, xarg2)),\n+\t\t\t\t      flags & LOOKUP_COMPLAIN,\n+\t\t\t\t      (struct candidate *)0);\n+\n+\trval = build_method_call\n+\t  (build_indirect_ref (build1 (NOP_EXPR, TREE_TYPE (xarg1),\n+\t\t\t\t       error_mark_node),\n+\t\t\t       NULL_PTR),\n+\t   fnname, tree_cons (NULL_TREE, xarg1,\n+\t\t\t      build_tree_list (NULL_TREE, xarg2)),\n+\t   NULL_TREE, flags);\n+\t/* This happens when the user mis-declares `operator delete'.\n+\t   Should now be impossible.  */\n+\tmy_friendly_assert (rval != error_mark_node, 250);\n+\tTREE_TYPE (rval) = void_type_node;\n+\treturn rval;\n+      }\n+      break;\n+\n+    default:\n+      binary_is_unary = 0;\n+      try_second = tree_code_length [(int) code] == 2;\n+      if (try_second && xarg2 == error_mark_node)\n+\treturn error_mark_node;\n+      break;\n+    }\n+\n+  if (try_second && xarg2 == error_mark_node)\n+    return error_mark_node;\n+\n+  /* What ever it was, we do not know how to deal with it.  */\n+  if (type1 == NULL_TREE)\n+    return rval;\n+\n+  if (TREE_CODE (type1) == OFFSET_TYPE)\n+    type1 = TREE_TYPE (type1);\n+\n+  if (TREE_CODE (type1) == REFERENCE_TYPE)\n+    {\n+      arg1 = convert_from_reference (xarg1);\n+      type1 = TREE_TYPE (arg1);\n+    }\n+  else\n+    {\n+      arg1 = xarg1;\n+    }\n+\n+  if (!IS_AGGR_TYPE (type1) || TYPE_PTRMEMFUNC_P (type1))\n+    {\n+      /* Try to fail. First, fail if unary */\n+      if (! try_second)\n+\treturn rval;\n+      /* Second, see if second argument is non-aggregate. */\n+      type2 = TREE_TYPE (xarg2);\n+      if (TREE_CODE (type2) == OFFSET_TYPE)\n+\ttype2 = TREE_TYPE (type2);\n+      if (TREE_CODE (type2) == REFERENCE_TYPE)\n+\t{\n+\t  arg2 = convert_from_reference (xarg2);\n+\t  type2 = TREE_TYPE (arg2);\n+\t}\n+      else\n+\t{\n+\t  arg2 = xarg2;\n+\t}\n+\n+      if (!IS_AGGR_TYPE (type2))\n+\treturn rval;\n+      try_second = 0;\n+    }\n+\n+  if (try_second)\n+    {\n+      /* First arg may succeed; see whether second should.  */\n+      type2 = TREE_TYPE (xarg2);\n+      if (TREE_CODE (type2) == OFFSET_TYPE)\n+\ttype2 = TREE_TYPE (type2);\n+      if (TREE_CODE (type2) == REFERENCE_TYPE)\n+\t{\n+\t  arg2 = convert_from_reference (xarg2);\n+\t  type2 = TREE_TYPE (arg2);\n+\t}\n+      else\n+\t{\n+\t  arg2 = xarg2;\n+\t}\n+\n+      if (! IS_AGGR_TYPE (type2))\n+\ttry_second = 0;\n+    }\n+\n+  if (type1 == unknown_type_node\n+      || (try_second && TREE_TYPE (xarg2) == unknown_type_node))\n+    {\n+      /* This will not be implemented in the foreseeable future.  */\n+      return rval;\n+    }\n+\n+  if (code == MODIFY_EXPR)\n+    fnname = ansi_assopname[(int) TREE_CODE (arg3)];\n+  else\n+    fnname = ansi_opname[(int) code];\n+\n+  global_fn = IDENTIFIER_GLOBAL_VALUE (fnname);\n+\n+  /* This is the last point where we will accept failure.  This\n+     may be too eager if we wish an overloaded operator not to match,\n+     but would rather a normal operator be called on a type-converted\n+     argument.  */\n+\n+  if (IS_AGGR_TYPE (type1))\n+    {\n+      fields1 = lookup_fnfields (TYPE_BINFO (type1), fnname, 0);\n+      /* ARM $13.4.7, prefix/postfix ++/--.  */\n+      if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n+\t{\n+\t  xarg2 = integer_zero_node;\n+\t  binary_is_unary = 0;\n+\n+\t  if (fields1)\n+\t    {\n+\t      tree t, t2;\n+\t      int have_postfix = 0;\n+\n+\t      /* Look for an `operator++ (int)'.  If they didn't have\n+\t\t one, then we fall back to the old way of doing things.  */\n+\t      for (t = TREE_VALUE (fields1); t ; t = TREE_CHAIN (t))\n+\t\t{\n+\t\t  t2 = TYPE_ARG_TYPES (TREE_TYPE (t));\n+\t\t  if (TREE_CHAIN (t2) != NULL_TREE\n+\t\t      && TREE_VALUE (TREE_CHAIN (t2)) == integer_type_node)\n+\t\t    {\n+\t\t      have_postfix = 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\n+\t      if (! have_postfix)\n+\t\t{\n+\t\t  char *op = POSTINCREMENT_EXPR ? \"++\" : \"--\";\n+\n+\t\t  /* There's probably a LOT of code in the world that\n+\t\t     relies upon this old behavior.  So we'll only give this\n+\t\t     warning when we've been given -pedantic.  A few\n+\t\t     releases after 2.4, we'll convert this to be a pedwarn\n+\t\t     or something else more appropriate.  */\n+\t\t  if (pedantic)\n+\t\t    warning (\"no `operator%s (int)' declared for postfix `%s'\",\n+\t\t\t     op, op);\n+\t\t  xarg2 = NULL_TREE;\n+\t\t  binary_is_unary = 1;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (fields1 == NULL_TREE && global_fn == NULL_TREE)\n+    return rval;\n+\n+  /* If RVAL winds up being `error_mark_node', we will return\n+     that... There is no way that normal semantics of these\n+     operators will succeed.  */\n+\n+  /* This argument may be an uncommitted OFFSET_REF.  This is\n+     the case for example when dealing with static class members\n+     which are referenced from their class name rather than\n+     from a class instance.  */\n+  if (TREE_CODE (xarg1) == OFFSET_REF\n+      && TREE_CODE (TREE_OPERAND (xarg1, 1)) == VAR_DECL)\n+    xarg1 = TREE_OPERAND (xarg1, 1);\n+  if (try_second && xarg2 && TREE_CODE (xarg2) == OFFSET_REF\n+      && TREE_CODE (TREE_OPERAND (xarg2, 1)) == VAR_DECL)\n+    xarg2 = TREE_OPERAND (xarg2, 1);\n+\n+  if (global_fn)\n+    flags |= LOOKUP_GLOBAL;\n+\n+  if (code == CALL_EXPR)\n+    {\n+      /* This can only be a member function.  */\n+      return build_method_call (xarg1, fnname, xarg2,\n+\t\t\t\tNULL_TREE, LOOKUP_NORMAL);\n+    }\n+  else if (tree_code_length[(int) code] == 1 || binary_is_unary)\n+    {\n+      parms = NULL_TREE;\n+      rval = build_method_call (xarg1, fnname, NULL_TREE, NULL_TREE, flags);\n+    }\n+  else if (code == COND_EXPR)\n+    {\n+      parms = tree_cons (0, xarg2, build_tree_list (NULL_TREE, arg3));\n+      rval = build_method_call (xarg1, fnname, parms, NULL_TREE, flags);\n+    }\n+  else if (code == METHOD_CALL_EXPR)\n+    {\n+      /* must be a member function.  */\n+      parms = tree_cons (NULL_TREE, xarg2, arg3);\n+      return build_method_call (xarg1, fnname, parms, NULL_TREE,\n+\t\t\t\tLOOKUP_NORMAL);\n+    }\n+  else if (fields1)\n+    {\n+      parms = build_tree_list (NULL_TREE, xarg2);\n+      rval = build_method_call (xarg1, fnname, parms, NULL_TREE, flags);\n+    }\n+  else\n+    {\n+      parms = tree_cons (NULL_TREE, xarg1,\n+\t\t\t build_tree_list (NULL_TREE, xarg2));\n+      rval = build_overload_call (fnname, parms, flags,\n+\t\t\t\t  (struct candidate *)0);\n+    }\n+\n+  return rval;\n+}\n+\f\n+/* This function takes an identifier, ID, and attempts to figure out what\n+   it means. There are a number of possible scenarios, presented in increasing\n+   order of hair:\n+\n+   1) not in a class's scope\n+   2) in class's scope, member name of the class's method\n+   3) in class's scope, but not a member name of the class\n+   4) in class's scope, member name of a class's variable\n+\n+   NAME is $1 from the bison rule. It is an IDENTIFIER_NODE.\n+   VALUE is $$ from the bison rule. It is the value returned by lookup_name ($1)\n+   yychar is the pending input character (suitably encoded :-).\n+\n+   As a last ditch, try to look up the name as a label and return that\n+   address.\n+\n+   Values which are declared as being of REFERENCE_TYPE are\n+   automatically dereferenced here (as a hack to make the\n+   compiler faster).  */\n+\n+tree\n+hack_identifier (value, name, yychar)\n+     tree value, name;\n+     int yychar;\n+{\n+  tree type;\n+\n+  if (TREE_CODE (value) == ERROR_MARK)\n+    {\n+      if (current_class_name)\n+\t{\n+\t  tree fields = lookup_fnfields (TYPE_BINFO (current_class_type), name, 1);\n+\t  if (fields == error_mark_node)\n+\t    return error_mark_node;\n+\t  if (fields)\n+\t    {\n+\t      tree fndecl;\n+\n+\t      fndecl = TREE_VALUE (fields);\n+\t      my_friendly_assert (TREE_CODE (fndecl) == FUNCTION_DECL, 251);\n+\t      if (DECL_CHAIN (fndecl) == NULL_TREE)\n+\t\t{\n+\t\t  warning (\"methods cannot be converted to function pointers\");\n+\t\t  return fndecl;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  error (\"ambiguous request for method pointer `%s'\",\n+\t\t\t IDENTIFIER_POINTER (name));\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n+\t}\n+      if (flag_labels_ok && IDENTIFIER_LABEL_VALUE (name))\n+\t{\n+\t  return IDENTIFIER_LABEL_VALUE (name);\n+\t}\n+      return error_mark_node;\n+    }\n+\n+  type = TREE_TYPE (value);\n+  if (TREE_CODE (value) == FIELD_DECL)\n+    {\n+      if (current_class_decl == NULL_TREE)\n+\t{\n+\t  error (\"request for member `%s' in static member function\",\n+\t\t IDENTIFIER_POINTER (DECL_NAME (value)));\n+\t  return error_mark_node;\n+\t}\n+      TREE_USED (current_class_decl) = 1;\n+      if (yychar == '(')\n+\tif (! ((TYPE_LANG_SPECIFIC (type)\n+\t\t&& TYPE_OVERLOADS_CALL_EXPR (type))\n+\t       || (TREE_CODE (type) == REFERENCE_TYPE\n+\t\t   && TYPE_LANG_SPECIFIC (TREE_TYPE (type))\n+\t\t   && TYPE_OVERLOADS_CALL_EXPR (TREE_TYPE (type))))\n+\t    && TREE_CODE (type) != FUNCTION_TYPE\n+\t    && TREE_CODE (type) != METHOD_TYPE\n+\t    && !TYPE_PTRMEMFUNC_P (type)\n+\t    && (TREE_CODE (type) != POINTER_TYPE\n+\t\t|| (TREE_CODE (TREE_TYPE (type)) != FUNCTION_TYPE\n+\t\t    && TREE_CODE (TREE_TYPE (type)) != METHOD_TYPE)))\n+\t  {\n+\t    error (\"component `%s' is not a method\",\n+\t\t   IDENTIFIER_POINTER (name));\n+\t    return error_mark_node;\n+\t  }\n+      /* Mark so that if we are in a constructor, and then find that\n+\t this field was initialized by a base initializer,\n+\t we can emit an error message.  */\n+      TREE_USED (value) = 1;\n+      return build_component_ref (C_C_D, name, 0, 1);\n+    }\n+\n+  if (TREE_CODE (value) == TREE_LIST)\n+    {\n+      tree t = value;\n+      while (t && TREE_CODE (t) == TREE_LIST)\n+\t{\n+\t  assemble_external (TREE_VALUE (t));\n+\t  TREE_USED (t) = 1;\n+\t  t = TREE_CHAIN (t);\n+\t}\n+    }\n+  else\n+    {\n+      assemble_external (value);\n+      TREE_USED (value) = 1;\n+    }\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (value)) == 'd' && DECL_NONLOCAL (value))\n+    {\n+      if (DECL_LANG_SPECIFIC (value)\n+\t  && DECL_CLASS_CONTEXT (value) != current_class_type)\n+\t{\n+\t  tree path;\n+\t  enum access_type access;\n+\t  register tree context\n+\t    = (TREE_CODE (value) == FUNCTION_DECL && DECL_VIRTUAL_P (value))\n+\t      ? DECL_CLASS_CONTEXT (value)\n+\t      : DECL_CONTEXT (value);\n+\n+\t  get_base_distance (context, current_class_type, 0, &path);\n+\t  if (path)\n+\t    {\n+\t      access = compute_access (path, value);\n+\t      if (access != access_public)\n+\t\t{\n+\t\t  if (TREE_CODE (value) == VAR_DECL)\n+\t\t    error (\"static member `%s' is %s\",\n+\t\t\t   IDENTIFIER_POINTER (name),\n+\t\t\t   TREE_PRIVATE (value) ? \"private\" :\n+\t\t\t   \"from a private base class\");\n+\t\t  else\n+\t\t    error (\"enum `%s' is from private base class\",\n+\t\t\t   IDENTIFIER_POINTER (name));\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n+\t}\n+      return value;\n+    }\n+  if (TREE_CODE (value) == TREE_LIST && TREE_NONLOCAL_FLAG (value))\n+    {\n+      if (type == 0)\n+\t{\n+\t  error (\"request for member `%s' is ambiguous in multiple inheritance lattice\",\n+\t\t IDENTIFIER_POINTER (name));\n+\t  return error_mark_node;\n+\t}\n+\n+      return value;\n+    }\n+\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      my_friendly_assert (TREE_CODE (value) == VAR_DECL\n+\t\t\t  || TREE_CODE (value) == PARM_DECL\n+\t\t\t  || TREE_CODE (value) == RESULT_DECL, 252);\n+      if (DECL_REFERENCE_SLOT (value))\n+\treturn DECL_REFERENCE_SLOT (value);\n+    }\n+  return value;\n+}\n+\n+\f\n+/* Given an object OF, and a type conversion operator COMPONENT\n+   build a call to the conversion operator, if a call is requested,\n+   or return the address (as a pointer to member function) if one is not.\n+\n+   OF can be a TYPE_DECL or any kind of datum that would normally\n+   be passed to `build_component_ref'.  It may also be NULL_TREE,\n+   in which case `current_class_type' and `current_class_decl'\n+   provide default values.\n+\n+   BASETYPE_PATH, if non-null, is the path of basetypes\n+   to go through before we get the the instance of interest.\n+\n+   PROTECT says whether we apply C++ scoping rules or not.  */\n+tree\n+build_component_type_expr (of, component, basetype_path, protect)\n+     tree of, component, basetype_path;\n+     int protect;\n+{\n+  tree cname = NULL_TREE;\n+  tree tmp, last;\n+  tree name;\n+  int flags = protect ? LOOKUP_NORMAL : LOOKUP_COMPLAIN;\n+\n+  if (of)\n+    my_friendly_assert (IS_AGGR_TYPE (TREE_TYPE (of)), 253);\n+  my_friendly_assert (TREE_CODE (component) == TYPE_EXPR, 254);\n+\n+  tmp = TREE_OPERAND (component, 0);\n+  last = NULL_TREE;\n+\n+  while (tmp)\n+    {\n+      switch (TREE_CODE (tmp))\n+\t{\n+\tcase CALL_EXPR:\n+\t  if (last)\n+\t    TREE_OPERAND (last, 0) = TREE_OPERAND (tmp, 0);\n+\t  else\n+\t    TREE_OPERAND (component, 0) = TREE_OPERAND (tmp, 0);\n+\n+\t  last = groktypename (build_tree_list (TREE_TYPE (component),\n+\t\t\t\t\t\tTREE_OPERAND (component, 0)));\n+\t  name = build_typename_overload (last);\n+\t  TREE_TYPE (name) = last;\n+\n+\t  if (TREE_OPERAND (tmp, 0)\n+\t      && TREE_OPERAND (tmp, 0) != void_list_node)\n+\t    {\n+\t      cp_error (\"`operator %T' requires empty parameter list\", last);\n+\t      TREE_OPERAND (tmp, 0) = NULL_TREE;\n+\t    }\n+\n+\t  if (of && TREE_CODE (of) != TYPE_DECL)\n+\t    return build_method_call (of, name, NULL_TREE, NULL_TREE, flags);\n+\t  else if (of)\n+\t    {\n+\t      tree this_this;\n+\n+\t      if (current_class_decl == NULL_TREE)\n+\t\t{\n+\t\t  cp_error (\"object required for `operator %T' call\",\n+\t\t\t    TREE_TYPE (name));\n+\t\t  return error_mark_node;\n+\t\t}\n+\n+\t      this_this = convert_pointer_to (TREE_TYPE (of),\n+\t\t\t\t\t      current_class_decl);\n+\t      this_this = build_indirect_ref (this_this, NULL_PTR);\n+\t      return build_method_call (this_this, name, NULL_TREE,\n+\t\t\t\t\tNULL_TREE, flags | LOOKUP_NONVIRTUAL);\n+\t    }\n+\t  else if (current_class_decl)\n+\t    return build_method_call (tmp, name, NULL_TREE, NULL_TREE, flags);\n+\n+\t  cp_error (\"object required for `operator %T' call\",\n+\t\t    TREE_TYPE (name));\n+\t  return error_mark_node;\n+\n+\tcase INDIRECT_REF:\n+\tcase ADDR_EXPR:\n+\tcase ARRAY_REF:\n+\t  break;\n+\n+\tcase SCOPE_REF:\n+\t  my_friendly_assert (cname == 0, 255);\n+\t  cname = TREE_OPERAND (tmp, 0);\n+\t  tmp = TREE_OPERAND (tmp, 1);\n+\t  break;\n+\n+\tdefault:\n+\t  my_friendly_abort (77);\n+\t}\n+      last = tmp;\n+      tmp = TREE_OPERAND (tmp, 0);\n+    }\n+\n+  last = groktypename (build_tree_list (TREE_TYPE (component), TREE_OPERAND (component, 0)));\n+  name = build_typename_overload (last);\n+  TREE_TYPE (name) = last;\n+  if (of && TREE_CODE (of) == TYPE_DECL)\n+    {\n+      if (cname == NULL_TREE)\n+\t{\n+\t  cname = DECL_NAME (of);\n+\t  of = NULL_TREE;\n+\t}\n+      else my_friendly_assert (cname == DECL_NAME (of), 256);\n+    }\n+\n+  if (of)\n+    {\n+      tree this_this;\n+\n+      if (current_class_decl == NULL_TREE)\n+\t{\n+\t  cp_error (\"object required for `operator %T' call\",\n+\t\t    TREE_TYPE (name));\n+\t  return error_mark_node;\n+\t}\n+\n+      this_this = convert_pointer_to (TREE_TYPE (of), current_class_decl);\n+      return build_component_ref (this_this, name, 0, protect);\n+    }\n+  else if (cname)\n+    return build_offset_ref (cname, name);\n+  else if (current_class_name)\n+    return build_offset_ref (current_class_name, name);\n+\n+  cp_error (\"object required for `operator %T' member reference\",\n+\t    TREE_TYPE (name));\n+  return error_mark_node;\n+}"}, {"sha": "933cd444005ceb52d0768b67698aed18416e84d3", "filename": "gcc/cp/parse.y", "status": "added", "additions": 4099, "deletions": 0, "changes": 4099, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=8d08fdba598cf87c3794df53beae1026345ebb02"}, {"sha": "0727e9a00661413fefc80d9ff5b8f76aa8399422", "filename": "gcc/cp/pt.c", "status": "added", "additions": 2311, "deletions": 0, "changes": 2311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,2311 @@\n+/* Handle parameterized types (templates) for GNU C++.\n+   Copyright (C) 1992, 1993 Free Software Foundation, Inc.\n+   Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Known bugs or deficiencies include:\n+   * templates for class static data don't work (methods only)\n+   * duplicated method templates can crash the compiler\n+   * interface/impl data is taken from file defining the template\n+   * all methods must be provided in header files; can't use a source\n+     file that contains only the method templates and \"just win\"\n+   * method templates must be seen before the expansion of the\n+     class template is done\n+ */\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"obstack.h\"\n+\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"cp-tree.h\"\n+#include \"decl.h\"\n+#include \"parse.h\"\n+\n+extern struct obstack permanent_obstack;\n+extern tree grokdeclarator ();\n+\n+extern int lineno;\n+extern char *input_filename;\n+struct pending_inline *pending_template_expansions;\n+\n+int processing_template_decl;\n+int processing_template_defn;\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+static int unify ();\n+static void add_pending_template ();\n+\n+void overload_template_name (), pop_template_decls ();\n+\n+/* We've got a template header coming up; set obstacks up to save the\n+   nodes created permanently.  (There might be cases with nested templates\n+   where we don't have to do this, but they aren't implemented, and it\n+   probably wouldn't be worth the effort.)  */\n+void\n+begin_template_parm_list ()\n+{\n+  pushlevel (0);\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  pushlevel (0);\n+}\n+\n+/* Process information from new template parameter NEXT and append it to the\n+   LIST being built.  The rules for use of a template parameter type name\n+   by later parameters are not well-defined for us just yet.  However, the\n+   only way to avoid having to parse expressions of unknown complexity (and\n+   with tokens of unknown types) is to disallow it completely.\tSo for now,\n+   that is what is assumed.  */\n+tree\n+process_template_parm (list, next)\n+     tree list, next;\n+{\n+  tree parm;\n+  tree decl = 0;\n+  int is_type;\n+  parm = next;\n+  my_friendly_assert (TREE_CODE (parm) == TREE_LIST, 259);\n+  is_type = TREE_CODE (TREE_PURPOSE (parm)) == IDENTIFIER_NODE;\n+  if (!is_type)\n+    {\n+      tree tinfo = 0;\n+      int  idx = 0;\n+      parm = TREE_PURPOSE (parm);\n+      my_friendly_assert (TREE_CODE (parm) == TREE_LIST, 260);\n+      parm = TREE_VALUE (parm);\n+      /* is a const-param */\n+      parm = grokdeclarator (TREE_VALUE (next), TREE_PURPOSE (next),\n+\t\t\t     PARM, 0, NULL_TREE);\n+      /* A template parameter is not modifiable.  */\n+      TREE_READONLY (parm) = 1;\n+      if (TREE_CODE (TREE_TYPE (parm)) == RECORD_TYPE\n+\t  || TREE_CODE (TREE_TYPE (parm)) == UNION_TYPE)\n+\t{\n+\t  sorry (\"aggregate template parameter types\");\n+\t  TREE_TYPE (parm) = void_type_node;\n+\t}\n+      tinfo = make_node (TEMPLATE_CONST_PARM);\n+      my_friendly_assert (TREE_PERMANENT (tinfo), 260.5);\n+      if (TREE_PERMANENT (parm) == 0)\n+        {\n+\t  parm = copy_node (parm);\n+\t  TREE_PERMANENT (parm) = 1;\n+        }\n+      TREE_TYPE (tinfo) = TREE_TYPE (parm);\n+      decl = build_decl (CONST_DECL, DECL_NAME (parm), TREE_TYPE (parm));\n+      DECL_INITIAL (decl) = tinfo;\n+      DECL_INITIAL (parm) = tinfo;\n+    }\n+  else\n+    {\n+      tree t = make_node (TEMPLATE_TYPE_PARM);\n+      decl = build_lang_decl (TYPE_DECL, TREE_PURPOSE (parm), t);\n+      TYPE_NAME (t) = decl;\n+      TREE_VALUE (parm) = t;\n+    }\n+  pushdecl (decl);\n+  return chainon (list, parm);\n+}\n+\n+/* The end of a template parameter list has been reached.  Process the\n+   tree list into a parameter vector, converting each parameter into a more\n+   useful form.\t Type parameters are saved as IDENTIFIER_NODEs, and others\n+   as PARM_DECLs.  */\n+\n+tree\n+end_template_parm_list (parms)\n+     tree parms;\n+{\n+  int nparms = 0;\n+  tree saved_parmlist;\n+  tree parm;\n+  for (parm = parms; parm; parm = TREE_CHAIN (parm))\n+    nparms++;\n+  saved_parmlist = make_tree_vec (nparms);\n+\n+  for (parm = parms, nparms = 0; parm; parm = TREE_CHAIN (parm), nparms++)\n+    {\n+      tree p = parm;\n+      if (TREE_CODE (p) == TREE_LIST)\n+\t{\n+\t  tree t = TREE_VALUE (p);\n+\t  TREE_VALUE (p) = NULL_TREE;\n+\t  p = TREE_PURPOSE (p);\n+\t  my_friendly_assert (TREE_CODE (p) == IDENTIFIER_NODE, 261);\n+\t  TEMPLATE_TYPE_SET_INFO (t, saved_parmlist, nparms);\n+\t}\n+      else\n+\t{\n+\t  tree tinfo = DECL_INITIAL (p);\n+\t  DECL_INITIAL (p) = NULL_TREE;\n+\t  TEMPLATE_CONST_SET_INFO (tinfo, saved_parmlist, nparms);\n+\t}\n+      TREE_VEC_ELT (saved_parmlist, nparms) = p;\n+    }\n+  set_current_level_tags_transparency (1);\n+  processing_template_decl++;\n+  return saved_parmlist;\n+}\n+\n+/* end_template_decl is called after a template declaration is seen.\n+   D1 is template header; D2 is class_head_sans_basetype or a\n+   TEMPLATE_DECL with its DECL_RESULT field set.  */\n+void\n+end_template_decl (d1, d2, is_class)\n+     tree d1, d2, is_class;\n+{\n+  tree decl;\n+  struct template_info *tmpl;\n+\n+  tmpl = (struct template_info *) obstack_alloc (&permanent_obstack,\n+\t\t\t\t\t    sizeof (struct template_info));\n+  tmpl->text = 0;\n+  tmpl->length = 0;\n+  tmpl->aggr = is_class;\n+\n+  /* cloned from reinit_parse_for_template */\n+  tmpl->filename = input_filename;\n+  tmpl->lineno = lineno;\n+  tmpl->parm_vec = d1;          /* [eichin:19911015.2306EST] */\n+\n+  if (d2 == NULL_TREE || d2 == error_mark_node)\n+    {\n+      decl = 0;\n+      goto lose;\n+    }\n+\n+  if (is_class)\n+    {\n+      decl = build_lang_decl (TEMPLATE_DECL, d2, NULL_TREE);\n+    }\n+  else\n+    {\n+      if (TREE_CODE (d2) == TEMPLATE_DECL)\n+\tdecl = d2;\n+      else\n+\t{\n+\t  /* Class destructor templates and operator templates are\n+\t     slipping past as non-template nodes.  Process them here, since\n+\t     I haven't figured out where to catch them earlier.  I could\n+\t     go do that, but it's a choice between getting that done and\n+\t     staying only N months behind schedule.  Sorry....  */\n+\t  enum tree_code code;\n+\t  my_friendly_assert (TREE_CODE (d2) == CALL_EXPR, 263);\n+\t  code = TREE_CODE (TREE_OPERAND (d2, 0));\n+\t  my_friendly_assert (code == BIT_NOT_EXPR\n+\t\t  || code == OP_IDENTIFIER\n+\t\t  || code == SCOPE_REF, 264);\n+\t  d2 = grokdeclarator (d2, NULL_TREE, MEMFUNCDEF, 0, NULL_TREE);\n+\t  decl = build_lang_decl (TEMPLATE_DECL, DECL_NAME (d2),\n+\t\t\t\t  TREE_TYPE (d2));\n+\t  DECL_TEMPLATE_RESULT (decl) = d2;\n+\t  DECL_CONTEXT (decl) = DECL_CONTEXT (d2);\n+\t  DECL_CLASS_CONTEXT (decl) = DECL_CLASS_CONTEXT (d2);\n+\t  DECL_NAME (decl) = DECL_NAME (d2);\n+\t  TREE_TYPE (decl) = TREE_TYPE (d2);\n+\t  if (interface_unknown && flag_external_templates && ! DECL_IN_SYSTEM_HEADER (decl))\n+\t    warn_if_unknown_interface ();\n+\t  TREE_PUBLIC (decl) = TREE_PUBLIC (d2) = flag_external_templates && !interface_unknown;\n+\t  DECL_EXTERNAL (decl) = (DECL_EXTERNAL (d2)\n+\t\t\t\t  && !(DECL_CLASS_CONTEXT (d2)\n+\t\t\t\t       && !DECL_THIS_EXTERN (d2)));\n+\t}\n+\n+      /* All routines creating TEMPLATE_DECL nodes should now be using\n+\t build_lang_decl, which will have set this up already.\t*/\n+      my_friendly_assert (DECL_LANG_SPECIFIC (decl) != 0, 265);\n+\n+      /* @@ Somewhere, permanent allocation isn't being used.  */\n+      if (! DECL_TEMPLATE_IS_CLASS (decl)\n+\t  && TREE_CODE (DECL_TEMPLATE_RESULT (decl)) == FUNCTION_DECL)\n+\t{\n+\t  tree result = DECL_TEMPLATE_RESULT (decl);\n+\t  /* Will do nothing if allocation was already permanent.  */\n+\t  DECL_ARGUMENTS (result) = copy_to_permanent (DECL_ARGUMENTS (result));\n+\t}\n+\n+      /* If this is for a method, there's an extra binding level here.\t*/\n+      if (! DECL_TEMPLATE_IS_CLASS (decl)\n+\t  && DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl)) != NULL_TREE)\n+\t{\n+\t  /* @@ Find out where this should be getting set!  */\n+\t  tree r = DECL_TEMPLATE_RESULT (decl);\n+\t  if (DECL_CLASS_CONTEXT (r) == NULL_TREE)\n+\t    DECL_CLASS_CONTEXT (r) = DECL_CONTEXT (r);\n+\t}\n+    }\n+  DECL_TEMPLATE_INFO (decl) = tmpl;\n+  DECL_TEMPLATE_PARMS (decl) = d1;\n+lose:\n+  if (decl)\n+    {\n+      /* If context of decl is non-null (i.e., method template), add it\n+\t to the appropriate class template, and pop the binding levels.  */\n+      if (! DECL_TEMPLATE_IS_CLASS (decl)\n+\t  && DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl)) != NULL_TREE)\n+\t{\n+\t  tree ctx = DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl));\n+\t  tree tmpl;\n+\t  my_friendly_assert (TREE_CODE (ctx) == UNINSTANTIATED_P_TYPE, 266);\n+\t  tmpl = UPT_TEMPLATE (ctx);\n+\t  DECL_TEMPLATE_MEMBERS (tmpl) =\n+\t    perm_tree_cons (DECL_NAME (decl), decl,\n+\t\t\t    DECL_TEMPLATE_MEMBERS (tmpl));\n+\t  poplevel (0, 0, 0);\n+\t  poplevel (0, 0, 0);\n+\t}\n+      /* Otherwise, go back to top level first, and push the template decl\n+\t again there.  */\n+      else\n+\t{\n+\t  poplevel (0, 0, 0);\n+\t  poplevel (0, 0, 0);\n+\t  if (TREE_TYPE (decl)\n+\t      && IDENTIFIER_GLOBAL_VALUE (DECL_NAME (decl)) != NULL_TREE)\n+\t    push_overloaded_decl (decl, 0);\n+\t  else\n+\t    pushdecl (decl);\n+\t}\n+    }\n+#if 0 /* It happens sometimes, with syntactic or semantic errors.\n+\n+\t One specific case:\n+\t template <class A, int X, int Y> class Foo { ... };\n+\t template <class A, int X, int y> Foo<X,Y>::method (Foo& x) { ... }\n+\t Note the missing \"A\" in the class containing \"method\".  */\n+  my_friendly_assert (global_bindings_p (), 267);\n+#else\n+  while (! global_bindings_p ())\n+    poplevel (0, 0, 0);\n+#endif\n+  pop_obstacks ();\n+  processing_template_decl--;\n+  (void) get_pending_sizes ();\n+}\n+\n+/* If TYPE contains a template parm type, then substitute that type\n+   with its actual type that is found in TVEC. */\n+static void\n+grok_template_type (tvec, type)\n+     tree tvec;\n+     tree* type;\n+{\n+  switch (TREE_CODE (*type))\n+    {\n+    case TEMPLATE_TYPE_PARM:\n+      if (*type != TYPE_MAIN_VARIANT (*type))\n+        {\n+\t  /* we are here for cases like const T* etc. */\n+\t  grok_template_type (tvec, &TYPE_MAIN_VARIANT (*type));\n+\t  *type = build_type_variant (TYPE_MAIN_VARIANT (*type),\n+\t\t\t\t      TYPE_READONLY (*type),\n+\t\t\t\t      TYPE_VOLATILE (*type));\n+\t}\n+      else\n+\t  *type = TREE_VEC_ELT (tvec, TEMPLATE_TYPE_IDX (*type));\n+      return;\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      grok_template_type (tvec, &TREE_TYPE (*type));\n+      return;\n+    case FUNCTION_TYPE:\n+      {\n+\ttree p;\n+\t\n+\t/* take care of function's return type first */\n+\tgrok_template_type (tvec, &TREE_TYPE (*type));\n+\t\n+\t/* take care of function's arguments */\n+\tfor (p = TYPE_ARG_TYPES (*type); p; p = TREE_CHAIN (p))\n+\t  grok_template_type (tvec, &TREE_VALUE (p));\n+\treturn;\n+      }\n+    default:     \n+      break;\n+    }\n+  return;\n+}\n+\n+/* Convert all template arguments to their appropriate types, and return\n+   a vector containing the resulting values.  If any error occurs, return\n+   error_mark_node.  */\n+static tree\n+coerce_template_parms (parms, arglist, in_decl)\n+     tree parms, arglist;\n+     tree in_decl;\n+{\n+  int nparms, i, lost = 0;\n+  tree vec;\n+\n+  if (TREE_CODE (arglist) == TREE_VEC)\n+    nparms = TREE_VEC_LENGTH (arglist);\n+  else\n+    nparms = list_length (arglist);\n+  if (nparms != TREE_VEC_LENGTH (parms))\n+    {\n+      error (\"incorrect number of parameters (%d, should be %d)\",\n+\t     nparms, TREE_VEC_LENGTH (parms));\n+      if (in_decl)\n+\tcp_error_at (\"in template expansion for decl `%D'\", in_decl);\n+      return error_mark_node;\n+    }\n+\n+  if (TREE_CODE (arglist) == TREE_VEC)\n+    vec = copy_node (arglist);\n+  else\n+    {\n+      vec = make_tree_vec (nparms);\n+      for (i = 0; i < nparms; i++)\n+\t{\n+\t  tree arg = arglist;\n+\t  arglist = TREE_CHAIN (arglist);\n+\t  if (arg == error_mark_node)\n+\t    lost++;\n+\t  else\n+\t    arg = TREE_VALUE (arg);\n+\t  TREE_VEC_ELT (vec, i) = arg;\n+\t}\n+    }\n+  for (i = 0; i < nparms; i++)\n+    {\n+      tree arg = TREE_VEC_ELT (vec, i);\n+      tree parm = TREE_VEC_ELT (parms, i);\n+      tree val = 0;\n+      int is_type, requires_type;\n+\n+      is_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't';\n+      requires_type = TREE_CODE (parm) == IDENTIFIER_NODE;\n+      if (is_type != requires_type)\n+\t{\n+\t  if (in_decl)\n+\t    cp_error_at (\"type/value mismatch in template parameter list for `%D'\", in_decl);\n+\t  lost++;\n+\t  TREE_VEC_ELT (vec, i) = error_mark_node;\n+\t  continue;\n+\t}\n+      if (is_type)\n+\tval = groktypename (arg);\n+      else if (TREE_CODE (arg) == STRING_CST)\n+\t{\n+\t  cp_error (\"string literal %E is not a valid template argument\", arg);\n+\t  error (\"because it is the address of an object with static linkage\");\n+\t  val = error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  grok_template_type (vec, &TREE_TYPE (parm));\n+\t  val = digest_init (TREE_TYPE (parm), arg, (tree *) 0);\n+\t  \n+\t  if (val == error_mark_node)\n+\t    ;\n+\n+\t  /* 14.2: Other template-arguments must be constant-expressions,\n+\t     addresses of objects or functions with external linkage, or of\n+\t     static class members.  */\n+\t  else if (!TREE_CONSTANT (val))\n+\t    {\n+\t      cp_error (\"non-const `%E' cannot be used as template argument\",\n+\t\t\targ);\n+\t      val = error_mark_node;\n+\t    }\n+\t  else if (TREE_CODE (val) == ADDR_EXPR)\n+\t    {\n+\t      tree a = TREE_OPERAND (val, 0);\n+\t      if ((TREE_CODE (a) == VAR_DECL\n+\t\t   || TREE_CODE (a) == FUNCTION_DECL)\n+\t\t  && !TREE_PUBLIC (a))\n+\t\t{\n+\t\t  cp_error (\"address of non-extern `%E' cannot be used as template argument\", a);\n+\t\t  val = error_mark_node;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (val == error_mark_node)\n+\tlost++;\n+\n+      TREE_VEC_ELT (vec, i) = val;\n+    }\n+  if (lost)\n+    return error_mark_node;\n+  return vec;\n+}\n+\n+/* Given class template name and parameter list, produce a user-friendly name\n+   for the instantiation.  */\n+static char *\n+mangle_class_name_for_template (name, parms, arglist)\n+     char *name;\n+     tree parms, arglist;\n+{\n+  static struct obstack scratch_obstack;\n+  static char *scratch_firstobj;\n+  int i, nparms;\n+  char ibuf[100];\n+\n+  if (!scratch_firstobj)\n+    {\n+      gcc_obstack_init (&scratch_obstack);\n+      scratch_firstobj = obstack_alloc (&scratch_obstack, 1);\n+    }\n+  else\n+    obstack_free (&scratch_obstack, scratch_firstobj);\n+\n+#if 0\n+#define buflen\tsizeof(buf)\n+#define check\tif (bufp >= buf+buflen-1) goto too_long\n+#define ccat(c) *bufp++=(c); check\n+#define advance\tbufp+=strlen(bufp); check\n+#define cat(s)\tstrncpy(bufp, s, buf+buflen-bufp-1); advance\n+#else\n+#define check\n+#define ccat(c)\tobstack_1grow (&scratch_obstack, (c));\n+#define advance\n+#define cat(s)\tobstack_grow (&scratch_obstack, (s), strlen (s))\n+#endif\n+#define icat(n)\tsprintf(ibuf,\"%d\",(n)); cat(ibuf)\n+#define xcat(n)\tsprintf(ibuf,\"%ux\",n); cat(ibuf)\n+\n+  cat (name);\n+  ccat ('<');\n+  nparms = TREE_VEC_LENGTH (parms);\n+  my_friendly_assert (nparms == TREE_VEC_LENGTH (arglist), 268);\n+  for (i = 0; i < nparms; i++)\n+    {\n+      tree parm = TREE_VEC_ELT (parms, i), arg = TREE_VEC_ELT (arglist, i);\n+\n+      if (i)\n+\tccat (',');\n+\n+      if (TREE_CODE (parm) == IDENTIFIER_NODE)\n+\t{\n+\t  cat (type_as_string (arg, 0));\n+\t  continue;\n+\t}\n+      else\n+\tmy_friendly_assert (TREE_CODE (parm) == PARM_DECL, 269);\n+\n+      if (TREE_CODE (arg) == TREE_LIST)\n+\t{\n+\t  /* New list cell was built because old chain link was in\n+\t     use.  */\n+\t  my_friendly_assert (TREE_PURPOSE (arg) == NULL_TREE, 270);\n+\t  arg = TREE_VALUE (arg);\n+\t}\n+      /* No need to check arglist against parmlist here; we did that\n+\t in coerce_template_parms, called from lookup_template_class.  */\n+      cat (expr_as_string (arg, 0));\n+    }\n+  {\n+    char *bufp = obstack_next_free (&scratch_obstack);\n+    int offset = 0;\n+    while (bufp[offset - 1] == ' ')\n+      offset--;\n+    obstack_blank_fast (&scratch_obstack, offset);\n+\n+    /* B<C<char> >, not B<C<char>> */\n+    if (bufp[offset - 1] == '>')\n+      ccat (' ');\n+  }\n+  ccat ('>');\n+  ccat ('\\0');\n+  return (char *) obstack_base (&scratch_obstack);\n+\n+ too_long:\n+  fatal (\"out of (preallocated) string space creating template instantiation name\");\n+  /* NOTREACHED */\n+  return NULL;\n+}\n+\n+/* Given an IDENTIFIER_NODE (type TEMPLATE_DECL) and a chain of\n+   parameters, find the desired type.\n+\n+   D1 is the PTYPENAME terminal, and ARGLIST is the list of arguments.\n+   Since ARGLIST is build on the decl_obstack, we must copy it here\n+   to keep it from being reclaimed when the decl storage is reclaimed.\n+\n+   IN_DECL, if non-NULL, is the template declaration we are trying to\n+   instantiate.  */\n+tree\n+lookup_template_class (d1, arglist, in_decl)\n+     tree d1, arglist;\n+     tree in_decl;\n+{\n+  tree template, parmlist;\n+  char *mangled_name;\n+  tree id;\n+\n+  my_friendly_assert (TREE_CODE (d1) == IDENTIFIER_NODE, 272);\n+  template = IDENTIFIER_GLOBAL_VALUE (d1); /* XXX */\n+  if (! template)\n+    template = IDENTIFIER_CLASS_VALUE (d1);\n+  /* With something like `template <class T> class X class X { ... };'\n+     we could end up with D1 having nothing but an IDENTIFIER_LOCAL_VALUE.\n+     We don't want to do that, but we have to deal with the situation, so\n+     let's give them some syntax errors to chew on instead of a crash.  */\n+  if (! template)\n+    return error_mark_node;\n+  if (TREE_CODE (template) != TEMPLATE_DECL)\n+    {\n+      cp_error (\"non-template type `%T' used as a template\", d1);\n+      if (in_decl)\n+\tcp_error_at (\"for template declaration `%D'\", in_decl);\n+      return error_mark_node;\n+    }\n+  parmlist = DECL_TEMPLATE_PARMS (template);\n+\n+  arglist = coerce_template_parms (parmlist, arglist, in_decl);\n+  if (arglist == error_mark_node)\n+    return error_mark_node;\n+  if (uses_template_parms (arglist))\n+    {\n+      tree t = make_lang_type (UNINSTANTIATED_P_TYPE);\n+      tree d;\n+      id = make_anon_name ();\n+      d = build_lang_decl (TYPE_DECL, id, t);\n+      TYPE_NAME (t) = d;\n+      TYPE_VALUES (t) = build_tree_list (template, arglist);\n+      pushdecl_top_level (d);\n+    }\n+  else\n+    {\n+      mangled_name = mangle_class_name_for_template (IDENTIFIER_POINTER (d1),\n+\t\t\t\t\t\t     parmlist, arglist);\n+      id = get_identifier (mangled_name);\n+    }\n+  if (!IDENTIFIER_TEMPLATE (id))\n+    {\n+      arglist = copy_to_permanent (arglist);\n+      IDENTIFIER_TEMPLATE (id) = perm_tree_cons (template, arglist, NULL_TREE);\n+    }\n+  return id;\n+}\n+\f\n+void\n+push_template_decls (parmlist, arglist, class_level)\n+     tree parmlist, arglist;\n+     int class_level;\n+{\n+  int i, nparms;\n+\n+  /* Don't want to push values into global context.  */\n+  if (!class_level)\n+    pushlevel (0);\n+  nparms = TREE_VEC_LENGTH (parmlist);\n+\n+  for (i = 0; i < nparms; i++)\n+    {\n+      int requires_type, is_type;\n+      tree parm = TREE_VEC_ELT (parmlist, i);\n+      tree arg = TREE_VEC_ELT (arglist, i);\n+      tree decl = 0;\n+\n+      requires_type = TREE_CODE (parm) == IDENTIFIER_NODE;\n+      is_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't';\n+      if (is_type)\n+\t{\n+\t  /* add typename to namespace */\n+\t  if (!requires_type)\n+\t    {\n+\t      error (\"template use error: type provided where value needed\");\n+\t      continue;\n+\t    }\n+\t  decl = arg;\n+\t  my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 't', 273);\n+\t  decl = build_lang_decl (TYPE_DECL, parm, decl);\n+\t}\n+      else\n+\t{\n+\t  /* add const decl to namespace */\n+\t  tree val;\n+\t  if (requires_type)\n+\t    {\n+\t      error (\"template use error: value provided where type needed\");\n+\t      continue;\n+\t    }\n+\t  val = digest_init (TREE_TYPE (parm), arg, (tree *) 0);\n+\t  if (val != error_mark_node)\n+\t    {\n+\t      decl = build_decl (VAR_DECL, DECL_NAME (parm), TREE_TYPE (parm));\n+\t      DECL_INITIAL (decl) = val;\n+\t      TREE_READONLY (decl) = 1;\n+\t    }\n+\t}\n+      if (decl != 0)\n+\t{\n+\t  layout_decl (decl, 0);\n+\t  if (class_level)\n+\t    pushdecl_class_level (decl);\n+\t  else\n+\t    pushdecl (decl);\n+\t}\n+    }\n+  if (!class_level)\n+    set_current_level_tags_transparency (1);\n+}\n+\n+void\n+pop_template_decls (parmlist, arglist, class_level)\n+     tree parmlist, arglist;\n+     int class_level;\n+{\n+  if (!class_level)\n+    poplevel (0, 0, 0);\n+}\n+\f\n+/* Should be defined in cp-parse.h.  */\n+extern int yychar;\n+\n+int\n+uses_template_parms (t)\n+     tree t;\n+{\n+  if (!t)\n+    return 0;\n+  switch (TREE_CODE (t))\n+    {\n+    case INDIRECT_REF:\n+    case COMPONENT_REF:\n+      /* We assume that the object must be instantiated in order to build\n+\t the COMPONENT_REF, so we test only whether the type of the\n+\t COMPONENT_REF uses template parms.  */\n+      return uses_template_parms (TREE_TYPE (t));\n+\n+    case IDENTIFIER_NODE:\n+      if (!IDENTIFIER_TEMPLATE (t))\n+\treturn 0;\n+      return uses_template_parms (TREE_VALUE (IDENTIFIER_TEMPLATE (t)));\n+\n+      /* aggregates of tree nodes */\n+    case TREE_VEC:\n+      {\n+\tint i = TREE_VEC_LENGTH (t);\n+\twhile (i--)\n+\t  if (uses_template_parms (TREE_VEC_ELT (t, i)))\n+\t    return 1;\n+\treturn 0;\n+      }\n+    case TREE_LIST:\n+      if (uses_template_parms (TREE_PURPOSE (t))\n+\t  || uses_template_parms (TREE_VALUE (t)))\n+\treturn 1;\n+      return uses_template_parms (TREE_CHAIN (t));\n+\n+      /* constructed type nodes */\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      return uses_template_parms (TREE_TYPE (t));\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      if (!TYPE_NAME (t))\n+\treturn 0;\n+      if (!TYPE_IDENTIFIER (t))\n+\treturn 0;\n+      return uses_template_parms (TYPE_IDENTIFIER (t));\n+    case FUNCTION_TYPE:\n+      if (uses_template_parms (TYPE_ARG_TYPES (t)))\n+\treturn 1;\n+      return uses_template_parms (TREE_TYPE (t));\n+    case ARRAY_TYPE:\n+      if (uses_template_parms (TYPE_DOMAIN (t)))\n+\treturn 1;\n+      return uses_template_parms (TREE_TYPE (t));\n+    case OFFSET_TYPE:\n+      if (uses_template_parms (TYPE_OFFSET_BASETYPE (t)))\n+\treturn 1;\n+      return uses_template_parms (TREE_TYPE (t));\n+    case METHOD_TYPE:\n+      if (uses_template_parms (TYPE_OFFSET_BASETYPE (t)))\n+\treturn 1;\n+      if (uses_template_parms (TYPE_ARG_TYPES (t)))\n+\treturn 1;\n+      return uses_template_parms (TREE_TYPE (t));\n+\n+      /* decl nodes */\n+    case TYPE_DECL:\n+      return uses_template_parms (DECL_NAME (t));\n+    case FUNCTION_DECL:\n+      if (uses_template_parms (TREE_TYPE (t)))\n+\treturn 1;\n+      /* fall through */\n+    case VAR_DECL:\n+    case PARM_DECL:\n+      /* ??? What about FIELD_DECLs?  */\n+      /* The type of a decl can't use template parms if the name of the\n+\t variable doesn't, because it's impossible to resolve them.  So\n+\t ignore the type field for now.\t */\n+      if (DECL_CONTEXT (t) && uses_template_parms (DECL_CONTEXT (t)))\n+\treturn 1;\n+      if (uses_template_parms (TREE_TYPE (t)))\n+\t{\n+\t  error (\"template parms used where they can't be resolved\");\n+\t}\n+      return 0;\n+\n+    case CALL_EXPR:\n+      return uses_template_parms (TREE_TYPE (t));\n+    case ADDR_EXPR:\n+      return uses_template_parms (TREE_OPERAND (t, 0));\n+\n+      /* template parm nodes */\n+    case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_CONST_PARM:\n+      return 1;\n+\n+      /* simple type nodes */\n+    case INTEGER_TYPE:\n+      if (uses_template_parms (TYPE_MIN_VALUE (t)))\n+\treturn 1;\n+      return uses_template_parms (TYPE_MAX_VALUE (t));\n+\n+    case REAL_TYPE:\n+    case VOID_TYPE:\n+    case ENUMERAL_TYPE:\n+      return 0;\n+\n+      /* constants */\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case STRING_CST:\n+      return 0;\n+\n+    case ERROR_MARK:\n+      /* Non-error_mark_node ERROR_MARKs are bad things.  */\n+      my_friendly_assert (t == error_mark_node, 274);\n+      /* NOTREACHED */\n+      return 0;\n+\n+    case UNINSTANTIATED_P_TYPE:\n+      return 1;\n+\n+    default:\n+      switch (TREE_CODE_CLASS (TREE_CODE (t)))\n+\t{\n+\tcase '1':\n+\tcase '2':\n+\tcase '3':\n+\tcase '<':\n+\t  {\n+\t    int i;\n+\t    for (i = tree_code_length[(int) TREE_CODE (t)]; --i >= 0;)\n+\t      if (uses_template_parms (TREE_OPERAND (t, i)))\n+\t\treturn 1;\n+\t    return 0;\n+\t  }\n+\tdefault:\n+\t  break;\n+\t}\n+      sorry (\"testing %s for template parms\",\n+\t     tree_code_name [(int) TREE_CODE (t)]);\n+      my_friendly_abort (82);\n+      /* NOTREACHED */\n+      return 0;\n+    }\n+}\n+\n+void\n+instantiate_member_templates (classname)\n+     tree classname;\n+{\n+  tree t;\n+  tree id = classname;\n+  tree members = DECL_TEMPLATE_MEMBERS (TREE_PURPOSE (IDENTIFIER_TEMPLATE (id)));\n+\n+  for (t = members; t; t = TREE_CHAIN (t))\n+    {\n+      tree parmvec, type, classparms, tdecl, t2;\n+      int nparms, xxx = 0, i;\n+\n+      my_friendly_assert (TREE_VALUE (t) != NULL_TREE, 275);\n+      my_friendly_assert (TREE_CODE (TREE_VALUE (t)) == TEMPLATE_DECL, 276);\n+      /* @@ Should verify that class parm list is a list of\n+\t distinct template parameters, and covers all the template\n+\t parameters.  */\n+      tdecl = TREE_VALUE (t);\n+      type = DECL_CONTEXT (DECL_TEMPLATE_RESULT (tdecl));\n+      classparms = UPT_PARMS (type);\n+      nparms = TREE_VEC_LENGTH (classparms);\n+      parmvec = make_tree_vec (nparms);\n+      for (i = 0; i < nparms; i++)\n+\tTREE_VEC_ELT (parmvec, i) = NULL_TREE;\n+      switch (unify (DECL_TEMPLATE_PARMS (tdecl),\n+\t\t     &TREE_VEC_ELT (parmvec, 0), nparms,\n+\t\t     type, IDENTIFIER_TYPE_VALUE (classname),\n+\t\t     &xxx))\n+\t{\n+\tcase 0:\n+\t  /* Success -- well, no inconsistency, at least.  */\n+\t  for (i = 0; i < nparms; i++)\n+\t    if (TREE_VEC_ELT (parmvec, i) == NULL_TREE)\n+\t      goto failure;\n+\t  t2 = instantiate_template (tdecl,\n+\t\t\t\t     &TREE_VEC_ELT (parmvec, 0));\n+\t  type = IDENTIFIER_TYPE_VALUE (id);\n+\t  my_friendly_assert (type != 0, 277);\n+\t  if (CLASSTYPE_INTERFACE_UNKNOWN (type))\n+\t    {\n+\t      DECL_EXTERNAL (t2) = 0;\n+\t      TREE_PUBLIC (t2) = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      DECL_EXTERNAL (t2) = CLASSTYPE_INTERFACE_ONLY (type);\n+\t      TREE_PUBLIC (t2) = 1;\n+\t    }\n+\t  break;\n+\tcase 1:\n+\t  /* Failure.  */\n+\tfailure:\n+\t  cp_error (\"type unification error instantiating %T::%D\",\n+\t\t      classname, tdecl);\n+\t  cp_error_at (\"for template declaration `%D'\", tdecl);\n+\n+\t  continue /* loop of members */;\n+\tdefault:\n+\t  /* Eek, a bug.  */\n+\t  my_friendly_abort (83);\n+\t}\n+    }\n+}\n+\n+struct tinst_level *current_tinst_level = 0;\n+struct tinst_level *free_tinst_level = 0;\n+\n+void\n+push_tinst_level (name)\n+     tree name;\n+{\n+  struct tinst_level *new;\n+  tree global = IDENTIFIER_GLOBAL_VALUE (name);\n+\n+  if (free_tinst_level)\n+    {\n+      new = free_tinst_level;\n+      free_tinst_level = new->next;\n+    }\n+  else\n+    new = (struct tinst_level *) xmalloc (sizeof (struct tinst_level));\n+\n+  new->classname = name;\n+  if (global)\n+    {\n+      new->line = DECL_SOURCE_LINE (global);\n+      new->file = DECL_SOURCE_FILE (global);\n+    }\n+  else\n+    {\n+      new->line = lineno;\n+      new->file = input_filename;\n+    }\n+  new->next = current_tinst_level;\n+  current_tinst_level = new;\n+}\n+\n+void\n+pop_tinst_level ()\n+{\n+  struct tinst_level *old = current_tinst_level;\n+\n+  current_tinst_level = old->next;\n+  old->next = free_tinst_level;\n+  free_tinst_level = old;\n+}\n+\n+struct tinst_level *\n+tinst_for_decl ()\n+{\n+  struct tinst_level *p = current_tinst_level;\n+\n+  if (p)\n+    for (; p->next ; p = p->next )\n+      ;\n+  return p;\n+}\n+\n+tree\n+instantiate_class_template (classname, setup_parse)\n+     tree classname;\n+     int setup_parse;\n+{\n+  struct template_info *template_info;\n+  tree template, t1;\n+\n+  if (classname == error_mark_node)\n+    return error_mark_node;\n+\n+  my_friendly_assert (TREE_CODE (classname) == IDENTIFIER_NODE, 278);\n+  template = IDENTIFIER_TEMPLATE (classname);\n+\n+  if (IDENTIFIER_HAS_TYPE_VALUE (classname))\n+    {\n+      tree type = IDENTIFIER_TYPE_VALUE (classname);\n+      if (TREE_CODE (type) == UNINSTANTIATED_P_TYPE)\n+\treturn type;\n+      if (TYPE_BEING_DEFINED (type)\n+\t  || TYPE_SIZE (type)\n+\t  || CLASSTYPE_USE_TEMPLATE (type) != 0)\n+\treturn type;\n+    }\n+\n+  /* If IDENTIFIER_LOCAL_VALUE is already set on this template classname\n+     (it's something like `foo<int>'), that means we're already working on\n+     the instantiation for it.  Normally, a classname comes in with nothing\n+     but its IDENTIFIER_TEMPLATE slot set.  If we were to try to instantiate\n+     this again, we'd get a redeclaration error.  Since we're already working\n+     on it, we'll pass back this classname's TYPE_DECL (it's the value of\n+     the classname's IDENTIFIER_LOCAL_VALUE).  Only do this if we're setting\n+     things up for the parser, though---if we're just trying to instantiate\n+     it (e.g., via tsubst) we can trip up cuz it may not have an\n+     IDENTIFIER_TYPE_VALUE when it will need one.  */\n+  if (setup_parse && IDENTIFIER_LOCAL_VALUE (classname))\n+    return IDENTIFIER_LOCAL_VALUE (classname);\n+\n+  if (uses_template_parms (classname))\n+    {\n+      if (!TREE_TYPE (classname))\n+\t{\n+\t  tree t = make_lang_type (RECORD_TYPE);\n+\t  tree d = build_lang_decl (TYPE_DECL, classname, t);\n+\t  DECL_NAME (d) = classname;\n+\t  TYPE_NAME (t) = d;\n+\t  pushdecl (d);\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  t1 = TREE_PURPOSE (template);\n+  my_friendly_assert (TREE_CODE (t1) == TEMPLATE_DECL, 279);\n+\n+  /* If a template is declared but not defined, accept it; don't crash.\n+     Later uses requiring the definition will be flagged as errors by\n+     other code.  Thanks to niklas@appli.se for this bug fix.  */\n+  if (DECL_TEMPLATE_INFO (t1)->text == 0)\n+    setup_parse = 0;\n+\n+  push_to_top_level ();\n+  template_info = DECL_TEMPLATE_INFO (t1);\n+  if (setup_parse)\n+    {\n+      push_tinst_level (classname);\n+      push_template_decls (DECL_TEMPLATE_PARMS (TREE_PURPOSE (template)),\n+\t\t\t   TREE_VALUE (template), 0);\n+      set_current_level_tags_transparency (1);\n+      feed_input (template_info->text, template_info->length, (struct obstack *)0);\n+      lineno = template_info->lineno;\n+      input_filename = template_info->filename;\n+      /* Get interface/implementation back in sync.  */\n+      extract_interface_info ();\n+      overload_template_name (classname, 0);\n+      yychar = PRE_PARSED_CLASS_DECL;\n+      yylval.ttype = classname;\n+      processing_template_defn++;\n+      if (!flag_external_templates)\n+\tinterface_unknown++;\n+    }\n+  else\n+    {\n+      tree t, decl, id, tmpl;\n+\n+      id = classname;\n+      tmpl = TREE_PURPOSE (IDENTIFIER_TEMPLATE (id));\n+      t = xref_tag (DECL_TEMPLATE_INFO (tmpl)->aggr, id, NULL_TREE, 0);\n+      my_friendly_assert (TREE_CODE (t) == RECORD_TYPE\n+\t\t\t  || TREE_CODE (t) == UNION_TYPE, 280);\n+\n+      /* Now, put a copy of the decl in global scope, to avoid\n+       * recursive expansion.  */\n+      decl = IDENTIFIER_LOCAL_VALUE (id);\n+      if (!decl)\n+\tdecl = IDENTIFIER_CLASS_VALUE (id);\n+      if (decl)\n+\t{\n+\t  my_friendly_assert (TREE_CODE (decl) == TYPE_DECL, 281);\n+\t  /* We'd better make sure we're on the permanent obstack or else\n+\t   * we'll get a \"friendly\" abort 124 in pushdecl.  Perhaps a\n+\t   * copy_to_permanent would be sufficient here, but then a\n+\t   * sharing problem might occur.  I don't know -- niklas@appli.se */\n+\t  push_obstacks (&permanent_obstack, &permanent_obstack);\n+\t  pushdecl_top_level (copy_node (decl));\n+\t  pop_obstacks ();\n+\t}\n+      pop_from_top_level ();\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+static int\n+list_eq (t1, t2)\n+     tree t1, t2;\n+{\n+  if (t1 == NULL_TREE)\n+    return t2 == NULL_TREE;\n+  if (t2 == NULL_TREE)\n+    return 0;\n+  /* Don't care if one declares its arg const and the other doesn't -- the\n+     main variant of the arg type is all that matters.  */\n+  if (TYPE_MAIN_VARIANT (TREE_VALUE (t1))\n+      != TYPE_MAIN_VARIANT (TREE_VALUE (t2)))\n+    return 0;\n+  return list_eq (TREE_CHAIN (t1), TREE_CHAIN (t2));\n+}\n+\n+static tree \n+lookup_nested_type_by_name (ctype, name)\n+        tree ctype, name;\n+{\n+  tree t;\n+\n+  t = TREE_VALUE(CLASSTYPE_TAGS(ctype)); \n+  while (t)\n+  {\n+    if (strcmp(IDENTIFIER_POINTER(name), IDENTIFIER_POINTER(TYPE_IDENTIFIER(t)))\n+ == 0)\n+      return t;\n+    else \n+      t = TREE_CHAIN(t);\n+  }\n+  return NULL_TREE;\n+}\n+\n+static tree\n+search_nested_type_in_tmpl (tmpl, type)\n+        tree tmpl, type;\n+{\n+  tree t;\n+\n+  if (tmpl == NULL || TYPE_CONTEXT(type) == NULL)\n+    return tmpl;\n+  t = search_nested_type_in_tmpl (tmpl, TYPE_CONTEXT(type));\n+  if (t == NULL) return t;\n+  t = lookup_nested_type_by_name(t, DECL_NAME(TYPE_NAME(type)));\n+  return t;\n+}\n+\n+static tree\n+tsubst (t, args, nargs, in_decl)\n+     tree t, *args;\n+     int nargs;\n+     tree in_decl;\n+{\n+  tree type;\n+\n+  if (t == NULL_TREE || t == error_mark_node)\n+    return t;\n+\n+  type = TREE_TYPE (t);\n+  if (type\n+      /* Minor optimization.\n+\t ?? Are these really the most frequent cases?  Is the savings\n+\t significant?  */\n+      && type != integer_type_node\n+      && type != void_type_node\n+      && type != char_type_node)\n+    type = build_type_variant (tsubst (type, args, nargs, in_decl),\n+\t\t\t       TYPE_READONLY (type),\n+\t\t\t       TYPE_VOLATILE (type));\n+  switch (TREE_CODE (t))\n+    {\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (t))\n+\treturn build_ptrmemfunc_type\n+\t  (tsubst (TYPE_PTRMEMFUNC_FN_TYPE (t), args, nargs, in_decl));\n+\t  \n+      /* else fall through */\n+\n+    case ERROR_MARK:\n+    case IDENTIFIER_NODE:\n+    case OP_IDENTIFIER:\n+    case VOID_TYPE:\n+    case REAL_TYPE:\n+    case ENUMERAL_TYPE:\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case STRING_CST:\n+    case UNION_TYPE:\n+      return t;\n+\n+    case INTEGER_TYPE:\n+      if (t == integer_type_node)\n+\treturn t;\n+\n+      if (TREE_CODE (TYPE_MIN_VALUE (t)) == INTEGER_CST\n+\t  && TREE_CODE (TYPE_MAX_VALUE (t)) == INTEGER_CST)\n+\treturn t;\n+      return build_index_2_type\n+\t(tsubst (TYPE_MIN_VALUE (t), args, nargs, in_decl),\n+\t tsubst (TYPE_MAX_VALUE (t), args, nargs, in_decl));\n+\n+    case TEMPLATE_TYPE_PARM:\n+      return build_type_variant (args[TEMPLATE_TYPE_IDX (t)],\n+\t\t\t\t TYPE_READONLY (t),\n+\t\t\t\t TYPE_VOLATILE (t));\n+\n+    case TEMPLATE_CONST_PARM:\n+      return args[TEMPLATE_CONST_IDX (t)];\n+\n+    case FUNCTION_DECL:\n+      {\n+\ttree r;\n+\ttree fnargs, result;\n+\t\n+\tif (type == TREE_TYPE (t)\n+\t    && (DECL_CONTEXT (t) == NULL_TREE\n+\t\t|| TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (t))) != 't'))\n+\t  return t;\n+\tfnargs = tsubst (DECL_ARGUMENTS (t), args, nargs, t);\n+\tresult = tsubst (DECL_RESULT (t), args, nargs, t);\n+\tif (DECL_CONTEXT (t) != NULL_TREE\n+\t    && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (t))) == 't')\n+\t  {\n+\t    /* Look it up in that class, and return the decl node there,\n+\t       instead of creating a new one.  */\n+\t    tree ctx, methods, name, method;\n+\t    int n_methods;\n+\t    int i, found = 0;\n+\n+\t    name = DECL_NAME (t);\n+\t    ctx = tsubst (DECL_CONTEXT (t), args, nargs, t);\n+\t    methods = CLASSTYPE_METHOD_VEC (ctx);\n+\t    if (methods == NULL_TREE)\n+\t      /* No methods at all -- no way this one can match.  */\n+\t      goto no_match;\n+\t    n_methods = TREE_VEC_LENGTH (methods);\n+\n+\t    r = NULL_TREE;\n+\n+\t    if (!strncmp (OPERATOR_TYPENAME_FORMAT,\n+\t\t\t  IDENTIFIER_POINTER (name),\n+\t\t\t  sizeof (OPERATOR_TYPENAME_FORMAT) - 1))\n+\t      {\n+\t\t/* Type-conversion operator.  Reconstruct the name, in\n+\t\t   case it's the name of one of the template's parameters.  */\n+\t\tname = build_typename_overload (TREE_TYPE (type));\n+\t      }\n+\n+\t    if (DECL_CONTEXT (t) != NULL_TREE\n+\t\t&& TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (t))) == 't'\n+\t\t&& constructor_name (DECL_CONTEXT (t)) == DECL_NAME (t))\n+\t      name = constructor_name (ctx);\n+#if 0\n+\t    fprintf (stderr, \"\\nfor function %s in class %s:\\n\",\n+\t\t     IDENTIFIER_POINTER (name),\n+\t\t     IDENTIFIER_POINTER (TYPE_IDENTIFIER (ctx)));\n+#endif\n+\t    for (i = 0; i < n_methods; i++)\n+\t      {\n+\t\tint pass;\n+\n+\t\tmethod = TREE_VEC_ELT (methods, i);\n+\t\tif (method == NULL_TREE || DECL_NAME (method) != name)\n+\t\t  continue;\n+\n+\t\tpass = 0;\n+\t      maybe_error:\n+\t\tfor (; method; method = DECL_CHAIN (method))\n+\t\t  {\n+\t\t    my_friendly_assert (TREE_CODE (method) == FUNCTION_DECL,\n+\t\t\t\t\t282);\n+\t\t    if (TREE_TYPE (method) != type)\n+\t\t      {\n+\t\t\ttree mtype = TREE_TYPE (method);\n+\t\t\ttree t1, t2;\n+\n+\t\t\t/* Keep looking for a method that matches\n+\t\t\t   perfectly.  This takes care of the problem\n+\t\t\t   where destructors (which have implicit int args)\n+\t\t\t   look like constructors which have an int arg.  */\n+\t\t\tif (pass == 0)\n+\t\t\t  continue;\n+\n+\t\t\tt1 = TYPE_ARG_TYPES (mtype);\n+\t\t\tt2 = TYPE_ARG_TYPES (type);\n+\t\t\tif (TREE_CODE (mtype) == FUNCTION_TYPE)\n+\t\t\t  t2 = TREE_CHAIN (t2);\n+\n+\t\t\tif (list_eq (t1, t2))\n+\t\t\t  {\n+\t\t\t    if (TREE_CODE (mtype) == FUNCTION_TYPE)\n+\t\t\t      {\n+\t\t\t\ttree newtype;\n+\t\t\t\tnewtype = build_function_type (TREE_TYPE (type),\n+\t\t\t\t\t\t\t       TYPE_ARG_TYPES (type));\n+\t\t\t\tnewtype = build_type_variant (newtype,\n+\t\t\t\t\t\t\t      TYPE_READONLY (type),\n+\t\t\t\t\t\t\t      TYPE_VOLATILE (type));\n+\t\t\t\ttype = newtype;\n+\t\t\t\tif (TREE_TYPE (type) != TREE_TYPE (mtype))\n+\t\t\t\t  goto maybe_bad_return_type;\n+\t\t\t      }\n+\t\t\t    else if (TYPE_METHOD_BASETYPE (mtype)\n+\t\t\t\t     == TYPE_METHOD_BASETYPE (type))\n+\t\t\t      {\n+\t\t\t\t/* Types didn't match, but arg types and\n+\t\t\t\t   `this' do match, so the return type is\n+\t\t\t\t   all that should be messing it up.  */\n+\t\t\t      maybe_bad_return_type:\n+\t\t\t\tif (TREE_TYPE (type) != TREE_TYPE (mtype))\n+\t\t\t\t  error (\"inconsistent return types for method `%s' in class `%s'\",\n+\t\t\t\t\t IDENTIFIER_POINTER (name),\n+\t\t\t\t\t IDENTIFIER_POINTER (TYPE_IDENTIFIER (ctx)));\n+\t\t\t      }\n+\t\t\t    r = method;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t\tfound = 1;\n+\t\t\tcontinue;\n+\t\t      }\n+#if 0\n+\t\t    fprintf (stderr, \"\\tfound %s\\n\\n\",\n+\t\t\t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (method)));\n+#endif\n+\n+\t\t    if (DECL_ARGUMENTS (method)\n+\t\t\t&& ! TREE_PERMANENT (DECL_ARGUMENTS (method)))\n+\t\t      /* @@ Is this early enough?  Might we want to do\n+\t\t\t this instead while processing the expansion?\t */\n+\t\t      DECL_ARGUMENTS (method)\n+\t\t\t= tsubst (DECL_ARGUMENTS (t), args, nargs, t);\n+\t\t    r = method;\n+\t\t    break;\n+\t\t  }\n+\t\tif (r == NULL_TREE && pass == 0)\n+\t\t  {\n+\t\t    pass = 1;\n+\t\t    method = TREE_VEC_ELT (methods, i);\n+\t\t    goto maybe_error;\n+\t\t  }\n+\t      }\n+\t    if (r == NULL_TREE)\n+\t      {\n+\t      no_match:\n+\t\tcp_error\n+\t\t  (found\n+\t\t   ? \"template for method `%D' doesn't match any in class `%T'\"\n+\t\t   : \"method `%D' not found in class `%T'\", name, ctx);\n+\t\tif (in_decl)\n+\t\t  cp_error_at (\"in attempt to instantiate `%D' declared at this point in file\", in_decl);\n+\t\treturn error_mark_node;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    r = DECL_NAME (t);\n+\t    {\n+\t      tree decls;\n+\t      int got_it = 0;\n+\n+\t      decls = IDENTIFIER_GLOBAL_VALUE (r);\n+\t      if (decls == NULL_TREE)\n+\t\t/* no match */;\n+\t      else if (TREE_CODE (decls) == TREE_LIST)\n+\t\tfor (decls = TREE_VALUE (decls); decls ;\n+\t\t     decls = DECL_CHAIN (decls))\n+\t\t  {\n+\t\t    if (TREE_CODE (decls) == FUNCTION_DECL\n+\t\t\t&& TREE_TYPE (decls) == type)\n+\t\t      {\n+\t\t\tgot_it = 1;\n+\t\t\tr = decls;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      else\n+\t\t{\n+\t\t  tree val = decls;\n+\t\t  decls = NULL_TREE;\n+\t\t  if (TREE_CODE (val) == FUNCTION_DECL\n+\t\t      && TREE_TYPE (val) == type)\n+\t\t    {\n+\t\t      got_it = 1;\n+\t\t      r = val;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\n+\t      if (!got_it)\n+\t\t{\n+\t\t  r = build_decl_overload (r, TYPE_VALUES (type),\n+\t\t\t\t\t   DECL_CONTEXT (t) != NULL_TREE);\n+\t\t  r = build_lang_decl (FUNCTION_DECL, r, type);\n+\t\t}\n+\t    }\n+\t  }\n+\tTREE_PUBLIC (r) = TREE_PUBLIC (t);\n+\tDECL_EXTERNAL (r) = DECL_EXTERNAL (t);\n+\tTREE_STATIC (r) = TREE_STATIC (t);\n+\tDECL_INLINE (r) = DECL_INLINE (t);\n+\t{\n+#if 0\t\t\t\t/* Maybe later.  -jason  */\n+\t  struct tinst_level *til = tinst_for_decl();\n+\n+\t  /* should always be true under new approach */\n+\t  if (til)\n+\t    {\n+\t      DECL_SOURCE_FILE (r) = til->file;\n+\t      DECL_SOURCE_LINE (r) = til->line;\n+\t    }\n+\t  else\n+#endif\n+\t    {\n+\t      DECL_SOURCE_FILE (r) = DECL_SOURCE_FILE (t);\n+\t      DECL_SOURCE_LINE (r) = DECL_SOURCE_LINE (t);\n+\t    }\n+\t}\n+\tDECL_CLASS_CONTEXT (r) = tsubst (DECL_CLASS_CONTEXT (t), args, nargs, t);\n+\tmake_decl_rtl (r, NULL_PTR, 1);\n+\tDECL_ARGUMENTS (r) = fnargs;\n+\tDECL_RESULT (r) = result;\n+\tif (DECL_CONTEXT (t) == NULL_TREE\n+\t    || TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (t))) != 't')\n+\t  push_overloaded_decl_top_level (r, 0);\n+\treturn r;\n+      }\n+\n+    case PARM_DECL:\n+      {\n+\ttree r;\n+\tr = build_decl (PARM_DECL, DECL_NAME (t), type);\n+\tDECL_INITIAL (r) = TREE_TYPE (r);\n+\tif (TREE_CHAIN (t))\n+\t  TREE_CHAIN (r) = tsubst (TREE_CHAIN (t), args, nargs, TREE_CHAIN (t));\n+\treturn r;\n+      }\n+\n+    case TREE_LIST:\n+      {\n+\ttree purpose, value, chain, result;\n+\tint via_public, via_virtual, via_protected;\n+\n+\tif (t == void_list_node)\n+\t  return t;\n+\n+\tvia_public = TREE_VIA_PUBLIC (t);\n+\tvia_protected = TREE_VIA_PROTECTED (t);\n+\tvia_virtual = TREE_VIA_VIRTUAL (t);\n+\n+\tpurpose = TREE_PURPOSE (t);\n+\tif (purpose)\n+\t  purpose = tsubst (purpose, args, nargs, in_decl);\n+\tvalue = TREE_VALUE (t);\n+\tif (value)\n+\t  value = tsubst (value, args, nargs, in_decl);\n+\tchain = TREE_CHAIN (t);\n+\tif (chain && chain != void_type_node)\n+\t  chain = tsubst (chain, args, nargs, in_decl);\n+\tif (purpose == TREE_PURPOSE (t)\n+\t    && value == TREE_VALUE (t)\n+\t    && chain == TREE_CHAIN (t))\n+\t  return t;\n+\tresult = hash_tree_cons (via_public, via_virtual, via_protected,\n+\t\t\t\t purpose, value, chain);\n+\tTREE_PARMLIST (result) = TREE_PARMLIST (t);\n+\treturn result;\n+      }\n+    case TREE_VEC:\n+      {\n+\tint len = TREE_VEC_LENGTH (t), need_new = 0, i;\n+\ttree *elts = (tree *) alloca (len * sizeof (tree));\n+\tbzero (elts, len * sizeof (tree));\n+\n+\tfor (i = 0; i < len; i++)\n+\t  {\n+\t    elts[i] = tsubst (TREE_VEC_ELT (t, i), args, nargs, in_decl);\n+\t    if (elts[i] != TREE_VEC_ELT (t, i))\n+\t      need_new = 1;\n+\t  }\n+\n+\tif (!need_new)\n+\t  return t;\n+\n+\tt = make_tree_vec (len);\n+\tfor (i = 0; i < len; i++)\n+\t  TREE_VEC_ELT (t, i) = elts[i];\n+\treturn t;\n+      }\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      {\n+\ttree r;\n+\tenum tree_code code;\n+\tif (type == TREE_TYPE (t))\n+\t  return t;\n+\n+\tcode = TREE_CODE (t);\n+\tif (code == POINTER_TYPE)\n+\t  r = build_pointer_type (type);\n+\telse\n+\t  r = build_reference_type (type);\n+\tr = build_type_variant (r, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+\t/* Will this ever be needed for TYPE_..._TO values?  */\n+\tlayout_type (r);\n+\treturn r;\n+      }\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+      {\n+\ttree values = TYPE_VALUES (t); /* same as TYPE_ARG_TYPES */\n+\ttree context = TYPE_CONTEXT (t);\n+\ttree new_value;\n+\n+\t/* Don't bother recursing if we know it won't change anything.\t*/\n+\tif (values != void_list_node)\n+\t  values = tsubst (values, args, nargs, in_decl);\n+\tif (context)\n+\t  context = tsubst (context, args, nargs, in_decl);\n+\t/* Could also optimize cases where return value and\n+\t   values have common elements (e.g., T min(const &T, const T&).  */\n+\n+\t/* If the above parameters haven't changed, just return the type.  */\n+\tif (type == TREE_TYPE (t)\n+\t    && values == TYPE_VALUES (t)\n+\t    && context == TYPE_CONTEXT (t))\n+\t  return t;\n+\n+\t/* Construct a new type node and return it.  */\n+\tif (TREE_CODE (t) == FUNCTION_TYPE\n+\t    && context == NULL_TREE)\n+\t  {\n+\t    new_value = build_function_type (type, values);\n+\t  }\n+\telse if (context == NULL_TREE)\n+\t  {\n+\t    tree base = tsubst (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))),\n+\t\t\t\targs, nargs, in_decl);\n+\t    new_value = build_cplus_method_type (base, type,\n+\t\t\t\t\t\t TREE_CHAIN (values));\n+\t  }\n+\telse\n+\t  {\n+\t    new_value = make_node (TREE_CODE (t));\n+\t    TREE_TYPE (new_value) = type;\n+\t    TYPE_CONTEXT (new_value) = context;\n+\t    TYPE_VALUES (new_value) = values;\n+\t    TYPE_SIZE (new_value) = TYPE_SIZE (t);\n+\t    TYPE_ALIGN (new_value) = TYPE_ALIGN (t);\n+\t    TYPE_MODE (new_value) = TYPE_MODE (t);\n+\t    if (TYPE_METHOD_BASETYPE (t))\n+\t      TYPE_METHOD_BASETYPE (new_value) = tsubst (TYPE_METHOD_BASETYPE (t),\n+\t\t\t\t\t\t\t args, nargs, in_decl);\n+\t    /* Need to generate hash value.  */\n+\t    my_friendly_abort (84);\n+\t  }\n+\tnew_value = build_type_variant (new_value,\n+\t\t\t\t\tTYPE_READONLY (t),\n+\t\t\t\t\tTYPE_VOLATILE (t));\n+\treturn new_value;\n+      }\n+    case ARRAY_TYPE:\n+      {\n+\ttree domain = tsubst (TYPE_DOMAIN (t), args, nargs, in_decl);\n+\ttree r;\n+\tif (type == TREE_TYPE (t) && domain == TYPE_DOMAIN (t))\n+\t  return t;\n+\tr = build_cplus_array_type (type, domain);\n+\treturn r;\n+      }\n+\n+    case UNINSTANTIATED_P_TYPE:\n+      {\n+\tint nparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (UPT_TEMPLATE (t)));\n+\ttree argvec = make_tree_vec (nparms);\n+\ttree parmvec = UPT_PARMS (t);\n+\tint i;\n+\ttree id, rt;\n+\tfor (i = 0; i < nparms; i++)\n+\t  TREE_VEC_ELT (argvec, i) = tsubst (TREE_VEC_ELT (parmvec, i),\n+\t\t\t\t\t     args, nargs, in_decl);\n+\tid = lookup_template_class (DECL_NAME (UPT_TEMPLATE (t)), argvec, NULL_TREE);\n+\tif (! IDENTIFIER_HAS_TYPE_VALUE (id)) {\n+\t  instantiate_class_template(id, 0);\n+\t  /* set up pending_classes */\n+\t  add_pending_template (id);\n+\n+\t  TYPE_MAIN_VARIANT (IDENTIFIER_TYPE_VALUE (id)) =\n+\t    IDENTIFIER_TYPE_VALUE (id);\n+\t}\n+        rt = IDENTIFIER_TYPE_VALUE (id);\n+\n+\t/* kung: this part handles nested type in template definition */\n+        \n+\tif ( !ANON_AGGRNAME_P (DECL_NAME(TYPE_NAME(t))))\n+          {\n+\t    rt = search_nested_type_in_tmpl (rt, t);\n+          }\n+\n+\treturn build_type_variant (rt, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+      }\n+\n+    case MINUS_EXPR:\n+    case PLUS_EXPR:\n+      return fold (build (TREE_CODE (t), TREE_TYPE (t),\n+\t\t\t  tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n+\t\t\t  tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl)));\n+\n+    case NEGATE_EXPR:\n+    case NOP_EXPR:\n+      return fold (build1 (TREE_CODE (t), TREE_TYPE (t),\n+\t\t\t   tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl)));\n+\n+    default:\n+      sorry (\"use of `%s' in function template\",\n+\t     tree_code_name [(int) TREE_CODE (t)]);\n+      return error_mark_node;\n+    }\n+}\n+\n+tree\n+instantiate_template (tmpl, targ_ptr)\n+     tree tmpl, *targ_ptr;\n+{\n+  tree targs, fndecl;\n+  int i, len;\n+  struct pending_inline *p;\n+  struct template_info *t;\n+  struct obstack *old_fmp_obstack;\n+  extern struct obstack *function_maybepermanent_obstack;\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  old_fmp_obstack = function_maybepermanent_obstack;\n+  function_maybepermanent_obstack = &permanent_obstack;\n+\n+  my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 283);\n+  len = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (tmpl));\n+\n+  for (fndecl = DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n+       fndecl; fndecl = TREE_CHAIN (fndecl))\n+    {\n+      tree *t1 = &TREE_VEC_ELT (TREE_PURPOSE (fndecl), 0);\n+      for (i = len - 1; i >= 0; i--)\n+\tif (t1[i] != targ_ptr[i])\n+\t  goto no_match;\n+\n+      /* Here, we have a match.  */\n+      fndecl = TREE_VALUE (fndecl);\n+      function_maybepermanent_obstack = old_fmp_obstack;\n+      pop_obstacks ();\n+      return fndecl;\n+\n+    no_match:\n+      ;\n+    }\n+\n+  targs = make_tree_vec (len);\n+  i = len;\n+  while (i--)\n+    TREE_VEC_ELT (targs, i) = targ_ptr[i];\n+\n+  /* substitute template parameters */\n+  fndecl = tsubst (DECL_RESULT (tmpl), targ_ptr,\n+\t\t   TREE_VEC_LENGTH (targs), tmpl);\n+\n+  /* If it's a static member fn in the template, we need to change it\n+     into a FUNCTION_TYPE and chop off its this pointer.  */\n+  if (TREE_CODE (TREE_TYPE (DECL_RESULT (tmpl))) == METHOD_TYPE\n+      && fndecl != error_mark_node\n+      && DECL_STATIC_FUNCTION_P (fndecl))\n+    {\n+      tree olddecl = DECL_RESULT (tmpl);\n+      revert_static_member_fn (&TREE_TYPE (olddecl), &DECL_RESULT (tmpl),\n+\t\t\t       &TYPE_ARG_TYPES (TREE_TYPE (olddecl)));\n+      /* Chop off the this pointer that grokclassfn so kindly added\n+\t for us (it didn't know yet if the fn was static or not).  */\n+      DECL_ARGUMENTS (olddecl) = TREE_CHAIN (DECL_ARGUMENTS (olddecl));\n+      DECL_ARGUMENTS (fndecl) = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n+    }\n+     \n+  t = DECL_TEMPLATE_INFO (tmpl);\n+  if (t->text)\n+    {\n+      p = (struct pending_inline *) permalloc (sizeof (struct pending_inline));\n+      p->parm_vec = t->parm_vec;\n+      p->bindings = targs;\n+      p->can_free = 0;\n+      p->deja_vu = 0;\n+      p->buf = t->text;\n+      p->len = t->length;\n+      p->fndecl = fndecl;\n+      {\n+\tint l = lineno;\n+\tchar * f = input_filename;\n+\n+\tlineno = p->lineno = t->lineno;\n+\tinput_filename = p->filename = t->filename;\n+\n+\textract_interface_info ();\n+\t\n+\tif (interface_unknown && flag_external_templates && ! DECL_IN_SYSTEM_HEADER (tmpl))\n+\t  warn_if_unknown_interface ();\n+\tif (interface_unknown || !flag_external_templates)\n+\t  p->interface = 1;\t\t/* unknown */\n+\telse\n+\t  p->interface = interface_only ? 0 : 2;\n+\n+\tlineno = l;\n+\tinput_filename = f;\n+\n+\textract_interface_info ();\n+      }\n+    }\n+  else\n+    p = (struct pending_inline *)0;\n+\n+  DECL_TEMPLATE_INSTANTIATIONS (tmpl) =\n+    tree_cons (targs, fndecl, DECL_TEMPLATE_INSTANTIATIONS (tmpl));\n+\n+  function_maybepermanent_obstack = old_fmp_obstack;\n+  pop_obstacks ();\n+\n+  if (fndecl == error_mark_node || p == (struct pending_inline *)0)\n+    {\n+      /* do nothing */\n+    }\n+  else if (DECL_INLINE (fndecl))\n+    {\n+      DECL_PENDING_INLINE_INFO (fndecl) = p;\n+      p->next = pending_inlines;\n+      pending_inlines = p;\n+    }\n+  else\n+    {\n+      p->next = pending_template_expansions;\n+      pending_template_expansions = p;\n+    }\n+  return fndecl;\n+}\n+\n+void\n+undo_template_name_overload (id, classlevel)\n+     tree id;\n+     int classlevel;\n+{\n+  tree template;\n+\n+  template = IDENTIFIER_TEMPLATE (id);\n+  if (!template)\n+    return;\n+\n+#if 0 /* not yet, should get fixed properly later */\n+  poplevel (0, 0, 0);\n+#endif\n+#if 1 /* XXX */\n+  /* This was a botch... See `overload_template_name' just below.  */\n+  if (!classlevel)\n+    poplevel (0, 0, 0);\n+#endif\n+}\n+\n+void\n+overload_template_name (id, classlevel)\n+     tree id;\n+     int classlevel;\n+{\n+  tree template, t, decl;\n+  struct template_info *tinfo;\n+\n+  my_friendly_assert (TREE_CODE (id) == IDENTIFIER_NODE, 284);\n+  template = IDENTIFIER_TEMPLATE (id);\n+  if (!template)\n+    return;\n+\n+  template = TREE_PURPOSE (template);\n+  tinfo = DECL_TEMPLATE_INFO (template);\n+  template = DECL_NAME (template);\n+  my_friendly_assert (template != NULL_TREE, 285);\n+\n+#if 1 /* XXX */\n+  /* This was a botch... names of templates do not get their own private\n+     scopes.  Rather, the names of generated template instances should\n+     just get pushed into whatever scope we happen to be in at the moment.\n+     This will typically (but not always) be the global scope.  (Maybe\n+     what we really want to do here is a `push_to_toplevel' and then stay\n+     there while we are generating the instance; popping back out to the\n+     current scope when we are done generating the instance.)  */\n+  if (!classlevel)\n+    {\n+      pushlevel (1);\n+      declare_pseudo_global_level ();\n+    }\n+#endif\n+\n+  t = xref_tag (tinfo->aggr, id, NULL_TREE, 0);\n+  my_friendly_assert (TREE_CODE (t) == RECORD_TYPE\n+\t\t      || TREE_CODE (t) == UNION_TYPE\n+\t\t      || TREE_CODE (t) == UNINSTANTIATED_P_TYPE, 286);\n+\n+  decl = build_decl (TYPE_DECL, template, t);\n+\n+#if 0 /* fix this later */\n+  /* We don't want to call here if the work has already been done.  */\n+  t = (classlevel\n+       ? IDENTIFIER_CLASS_VALUE (template)\n+       : IDENTIFIER_LOCAL_VALUE (template));\n+  if (t\n+      && TREE_CODE (t) == TYPE_DECL\n+      && TREE_TYPE (t) == t)\n+    my_friendly_abort (85);\n+#endif\n+\n+  if (classlevel)\n+    pushdecl_class_level (decl);\n+  else\n+#if 0 /* not yet, should get fixed properly later */\n+    pushdecl (decl);\n+  pushlevel (1);\n+#else\n+    {\n+      pushdecl (decl);\n+      /* @@ Is this necessary now?  */\n+      IDENTIFIER_LOCAL_VALUE (template) = decl;\n+    }\n+#endif\n+\n+  /* Fake this for now, just to make dwarfout.c happy.  It will have to\n+     be done in a proper way later on.  */\n+  DECL_CONTEXT (decl) = t;\n+}\n+\n+/* NAME is the IDENTIFIER value of a PRE_PARSED_CLASS_DECL. */\n+void\n+end_template_instantiation (name)\n+     tree name;\n+{\n+  extern struct pending_input *to_be_restored;\n+  tree t, decl;\n+\n+  processing_template_defn--;\n+  if (!flag_external_templates)\n+    interface_unknown--;\n+\n+  /* Restore the old parser input state.  */\n+  if (yychar == YYEMPTY)\n+    yychar = yylex ();\n+  if (yychar != END_OF_SAVED_INPUT)\n+    error (\"parse error at end of class template\");\n+  else\n+    {\n+      restore_pending_input (to_be_restored);\n+      to_be_restored = 0;\n+    }\n+\n+  /* Our declarations didn't get stored in the global slot, since\n+     there was a (supposedly tags-transparent) scope in between.  */\n+  t = IDENTIFIER_TYPE_VALUE (name);\n+  my_friendly_assert (t != NULL_TREE\n+\t\t      && TREE_CODE_CLASS (TREE_CODE (t)) == 't',\n+\t\t      287);\n+  CLASSTYPE_USE_TEMPLATE (t) = 2;\n+  /* Make methods of template classes static, unless\n+     -fexternal-templates is given.  */\n+  if (!flag_external_templates)\n+    SET_CLASSTYPE_INTERFACE_UNKNOWN (t);\n+  decl = IDENTIFIER_GLOBAL_VALUE (name);\n+  my_friendly_assert (TREE_CODE (decl) == TYPE_DECL, 288);\n+\n+  undo_template_name_overload (name, 0);\n+  t = IDENTIFIER_TEMPLATE (name);\n+  pop_template_decls (DECL_TEMPLATE_PARMS (TREE_PURPOSE (t)), TREE_VALUE (t),\n+\t\t      0);\n+  /* This will fix up the type-value field.  */\n+  pushdecl (decl);\n+  pop_from_top_level ();\n+\n+#ifdef DWARF_DEBUGGING_INFO\n+  if (write_symbols == DWARF_DEBUG && TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      /* We just completed the definition of a new file-scope type,\n+\t so we can go ahead and output debug-info for it now.  */\n+      TYPE_STUB_DECL (TREE_TYPE (decl)) = decl;\n+      rest_of_type_compilation (TREE_TYPE (decl), 1);\n+    }\n+#endif /* DWARF_DEBUGGING_INFO */\n+\n+  /* Restore interface/implementation settings.\t */\n+  extract_interface_info ();\n+}\n+\f\n+/* Store away the text of an inline template function.\tNo rtl is\n+   generated for this function until it is actually needed.  */\n+\n+void\n+reinit_parse_for_template (yychar, d1, d2)\n+     int yychar;\n+     tree d1, d2;\n+{\n+  struct template_info *template_info;\n+  extern struct obstack inline_text_obstack; /* see comment in cp-lex.c */\n+\n+  if (d2 == NULL_TREE || d2 == error_mark_node)\n+    {\n+    lose:\n+      /* @@ Should use temp obstack, and discard results.  */\n+      reinit_parse_for_block (yychar, &inline_text_obstack, 1);\n+      return;\n+    }\n+\n+  if (TREE_CODE (d2) == IDENTIFIER_NODE)\n+    d2 = IDENTIFIER_GLOBAL_VALUE (d2);\n+  if (!d2)\n+    goto lose;\n+  template_info = DECL_TEMPLATE_INFO (d2);\n+  if (!template_info)\n+    {\n+      template_info = (struct template_info *) permalloc (sizeof (struct template_info));\n+      bzero (template_info, sizeof (struct template_info));\n+      DECL_TEMPLATE_INFO (d2) = template_info;\n+    }\n+  template_info->filename = input_filename;\n+  template_info->lineno = lineno;\n+  reinit_parse_for_block (yychar, &inline_text_obstack, 1);\n+  template_info->text = obstack_base (&inline_text_obstack);\n+  template_info->length = obstack_object_size (&inline_text_obstack);\n+  obstack_finish (&inline_text_obstack);\n+  template_info->parm_vec = d1;\n+}\n+\n+/* Type unification.\n+\n+   We have a function template signature with one or more references to\n+   template parameters, and a parameter list we wish to fit to this\n+   template.  If possible, produce a list of parameters for the template\n+   which will cause it to fit the supplied parameter list.\n+\n+   Return zero for success, 2 for an incomplete match that doesn't resolve\n+   all the types, and 1 for complete failure.  An error message will be\n+   printed only for an incomplete match.\n+\n+   TPARMS[NTPARMS] is an array of template parameter types;\n+   TARGS[NTPARMS] is the array of template parameter values.  PARMS is\n+   the function template's signature (using TEMPLATE_PARM_IDX nodes),\n+   and ARGS is the argument list we're trying to match against it.\n+\n+   If SUBR is 1, we're being called recursively (to unify the arguments of\n+   a function or method parameter of a function template), so don't zero\n+   out targs and don't fail on an incomplete match. */\n+\n+int\n+type_unification (tparms, targs, parms, args, nsubsts, subr)\n+     tree tparms, *targs, parms, args;\n+     int *nsubsts, subr;\n+{\n+  tree parm, arg;\n+  int i;\n+  int ntparms = TREE_VEC_LENGTH (tparms);\n+\n+  my_friendly_assert (TREE_CODE (tparms) == TREE_VEC, 289);\n+  my_friendly_assert (TREE_CODE (parms) == TREE_LIST, 290);\n+  /* ARGS could be NULL (via a call from cp-parse.y to\n+     build_x_function_call).  */\n+  if (args)\n+    my_friendly_assert (TREE_CODE (args) == TREE_LIST, 291);\n+  my_friendly_assert (ntparms > 0, 292);\n+\n+  if (!subr)\n+    bzero (targs, sizeof (tree) * ntparms);\n+\n+  while (parms\n+\t && parms != void_list_node\n+\t && args\n+\t && args != void_list_node)\n+    {\n+      parm = TREE_VALUE (parms);\n+      parms = TREE_CHAIN (parms);\n+      arg = TREE_VALUE (args);\n+      args = TREE_CHAIN (args);\n+\n+      if (arg == error_mark_node)\n+\treturn 1;\n+      if (arg == unknown_type_node)\n+\treturn 1;\n+#if 0\n+      if (TREE_CODE (arg) == VAR_DECL)\n+\targ = TREE_TYPE (arg);\n+      else if (TREE_CODE_CLASS (TREE_CODE (arg)) == 'e')\n+\targ = TREE_TYPE (arg);\n+#else\n+      if (TREE_CODE_CLASS (TREE_CODE (arg)) != 't')\n+\t{\n+\t  my_friendly_assert (TREE_TYPE (arg) != NULL_TREE, 293);\n+\t  arg = TREE_TYPE (arg);\n+\t}\n+#endif\n+      if (TREE_CODE (arg) == FUNCTION_TYPE\n+\t  || TREE_CODE (arg) == METHOD_TYPE)\n+\targ = build_pointer_type (arg);\n+\n+      switch (unify (tparms, targs, ntparms, parm, arg, nsubsts))\n+\t{\n+\tcase 0:\n+\t  break;\n+\tcase 1:\n+\t  return 1;\n+\t}\n+    }\n+  /* Fail if we've reached the end of the parm list, and more args\n+     are present, and the parm list isn't variadic.  */\n+  if (args && args != void_list_node && parms == void_list_node)\n+    return 1;\n+  /* Fail if parms are left and they don't have default values.\t */\n+  if (parms\n+      && parms != void_list_node\n+      && TREE_PURPOSE (parms) == NULL_TREE)\n+    return 1;\n+  if (!subr)\n+    for (i = 0; i < ntparms; i++)\n+      if (!targs[i])\n+\t{\n+\t  error (\"incomplete type unification\");\n+\t  return 2;\n+\t}\n+  return 0;\n+}\n+\n+/* Tail recursion is your friend.  */\n+static int\n+unify (tparms, targs, ntparms, parm, arg, nsubsts)\n+     tree tparms, *targs, parm, arg;\n+     int *nsubsts, ntparms;\n+{\n+  int idx;\n+\n+  /* I don't think this will do the right thing with respect to types.\n+     But the only case I've seen it in so far has been array bounds, where\n+     signedness is the only information lost, and I think that will be\n+     okay.  */\n+  while (TREE_CODE (parm) == NOP_EXPR)\n+    parm = TREE_OPERAND (parm, 0);\n+\n+  if (arg == error_mark_node)\n+    return 1;\n+  if (arg == unknown_type_node)\n+    return 1;\n+  if (arg == parm)\n+    return 0;\n+\n+  if (TREE_CODE (arg) == REFERENCE_TYPE)\n+    arg = TREE_TYPE (arg);\n+\n+  switch (TREE_CODE (parm))\n+    {\n+    case TEMPLATE_TYPE_PARM:\n+      (*nsubsts)++;\n+      if (TEMPLATE_TYPE_TPARMLIST (parm) != tparms)\n+\t{\n+\t  error (\"mixed template headers?!\");\n+\t  my_friendly_abort (86);\n+\t  return 1;\n+\t}\n+      idx = TEMPLATE_TYPE_IDX (parm);\n+      /* Simple cases: Value already set, does match or doesn't.  */\n+      if (targs[idx] == arg)\n+\treturn 0;\n+      else if (targs[idx])\n+\treturn 1;\n+      /* Check for mixed types and values.  */\n+      if (TREE_CODE (TREE_VEC_ELT (tparms, idx)) != IDENTIFIER_NODE)\n+\treturn 1;\n+      targs[idx] = arg;\n+      return 0;\n+    case TEMPLATE_CONST_PARM:\n+      (*nsubsts)++;\n+      idx = TEMPLATE_CONST_IDX (parm);\n+      if (targs[idx] == arg)\n+\treturn 0;\n+      else if (targs[idx])\n+\t{\n+\t  my_friendly_abort (87);\n+\t  return 1;\n+\t}\n+/*\telse if (typeof arg != tparms[idx])\n+\treturn 1;*/\n+\n+      targs[idx] = copy_to_permanent (arg);\n+      return 0;\n+\n+    case POINTER_TYPE:\n+      if (TREE_CODE (arg) != POINTER_TYPE)\n+\treturn 1;\n+      return unify (tparms, targs, ntparms, TREE_TYPE (parm), TREE_TYPE (arg),\n+\t\t    nsubsts);\n+\n+    case REFERENCE_TYPE:\n+      return unify (tparms, targs, ntparms, TREE_TYPE (parm), arg, nsubsts);\n+\n+    case ARRAY_TYPE:\n+      if (TREE_CODE (arg) != ARRAY_TYPE)\n+\treturn 1;\n+      if (unify (tparms, targs, ntparms, TYPE_DOMAIN (parm), TYPE_DOMAIN (arg),\n+\t\t nsubsts) != 0)\n+\treturn 1;\n+      return unify (tparms, targs, ntparms, TREE_TYPE (parm), TREE_TYPE (arg),\n+\t\t    nsubsts);\n+\n+    case REAL_TYPE:\n+    case INTEGER_TYPE:\n+      if (TREE_CODE (parm) == INTEGER_TYPE && TREE_CODE (arg) == INTEGER_TYPE)\n+\t{\n+\t  if (TYPE_MIN_VALUE (parm) && TYPE_MIN_VALUE (arg)\n+\t      && unify (tparms, targs, ntparms,\n+\t\t\tTYPE_MIN_VALUE (parm), TYPE_MIN_VALUE (arg), nsubsts))\n+\t    return 1;\n+\t  if (TYPE_MAX_VALUE (parm) && TYPE_MAX_VALUE (arg)\n+\t      && unify (tparms, targs, ntparms,\n+\t\t\tTYPE_MAX_VALUE (parm), TYPE_MAX_VALUE (arg), nsubsts))\n+\t    return 1;\n+\t}\n+      /* As far as unification is concerned, this wins.\t Later checks\n+\t will invalidate it if necessary.  */\n+      return 0;\n+\n+      /* Types INTEGER_CST and MINUS_EXPR can come from array bounds.  */\n+    case INTEGER_CST:\n+      if (TREE_CODE (arg) != INTEGER_CST)\n+\treturn 1;\n+      return !tree_int_cst_equal (parm, arg);\n+\n+    case MINUS_EXPR:\n+      {\n+\ttree t1, t2;\n+\tt1 = TREE_OPERAND (parm, 0);\n+\tt2 = TREE_OPERAND (parm, 1);\n+\tif (TREE_CODE (t1) != TEMPLATE_CONST_PARM)\n+\t  return 1;\n+\treturn unify (tparms, targs, ntparms, t1,\n+\t\t      fold (build (PLUS_EXPR, integer_type_node, arg, t2)),\n+\t\t      nsubsts);\n+      }\n+\n+    case TREE_VEC:\n+      {\n+\tint i;\n+\tif (TREE_CODE (arg) != TREE_VEC)\n+\t  return 1;\n+\tif (TREE_VEC_LENGTH (parm) != TREE_VEC_LENGTH (arg))\n+\t  return 1;\n+\tfor (i = TREE_VEC_LENGTH (parm) - 1; i >= 0; i--)\n+\t  if (unify (tparms, targs, ntparms,\n+\t\t     TREE_VEC_ELT (parm, i), TREE_VEC_ELT (arg, i),\n+\t\t     nsubsts))\n+\t    return 1;\n+\treturn 0;\n+      }\n+\n+    case UNINSTANTIATED_P_TYPE:\n+      {\n+\ttree a;\n+\t/* Unification of something that is not a template fails. (mrs) */\n+\tif (TYPE_NAME (arg) == 0)\n+\t  return 1;\n+\ta = IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (arg));\n+\t/* Unification of something that is not a template fails. (mrs) */\n+\tif (a == 0)\n+\t  return 1;\n+\tif (UPT_TEMPLATE (parm) != TREE_PURPOSE (a))\n+\t  /* different templates */\n+\t  return 1;\n+\treturn unify (tparms, targs, ntparms, UPT_PARMS (parm), TREE_VALUE (a),\n+\t\t      nsubsts);\n+      }\n+\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (parm))\n+\treturn unify (tparms, targs, ntparms, TYPE_PTRMEMFUNC_FN_TYPE (parm),\n+\t\t      arg, nsubsts);\n+\n+      /* Unification of something that is not a template fails. (mrs) */\n+      return 1;\n+\n+    case METHOD_TYPE:\n+      if (TREE_CODE (arg) != METHOD_TYPE)\n+\treturn 1;\n+      goto check_args;\n+\n+    case FUNCTION_TYPE:\n+      if (TREE_CODE (arg) != FUNCTION_TYPE)\n+\treturn 1;\n+     check_args:\n+      return type_unification (tparms, targs, TYPE_ARG_TYPES (parm),\n+\t\t\t       TYPE_ARG_TYPES (arg), nsubsts, 1);\n+\t\t    \n+    default:\n+      sorry (\"use of `%s' in template type unification\",\n+\t     tree_code_name [(int) TREE_CODE (parm)]);\n+      return 1;\n+    }\n+}\n+\n+\f\n+#undef DEBUG\n+\n+int\n+do_pending_expansions ()\n+{\n+  struct pending_inline *i, *new_list = 0;\n+\n+  if (!pending_template_expansions)\n+    return 0;\n+\n+#ifdef DEBUG\n+  fprintf (stderr, \"\\n\\n\\t\\t IN DO_PENDING_EXPANSIONS\\n\\n\");\n+#endif\n+\n+  i = pending_template_expansions;\n+  while (i)\n+    {\n+      tree context;\n+\n+      struct pending_inline *next = i->next;\n+      tree t = i->fndecl;\n+\n+      int decision = 0;\n+#define DECIDE(N) if(1){decision=(N); goto decided;}else\n+\n+      my_friendly_assert (TREE_CODE (t) == FUNCTION_DECL\n+\t\t\t  || TREE_CODE (t) == VAR_DECL, 294);\n+      if (TREE_ASM_WRITTEN (t))\n+\tDECIDE (0);\n+      /* If it's a method, let the class type decide it.\n+\t @@ What if the method template is in a separate file?\n+\t Maybe both file contexts should be taken into account?\n+\t Maybe only do this if i->interface == 1 (unknown)?  */\n+      context = DECL_CONTEXT (t);\n+      if (context != NULL_TREE\n+\t  && TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n+\t{\n+\t  /* I'm interested in the context of this version of the function,\n+\t     not the original virtual declaration.  */\n+\t  context = DECL_CLASS_CONTEXT (t);\n+\n+\t  /* If `unknown', we might want a static copy.\n+\t     If `implementation', we want a global one.\n+\t     If `interface', ext ref.  */\n+\t  if (CLASSTYPE_INTERFACE_KNOWN (context))\n+\t    DECIDE (!CLASSTYPE_INTERFACE_ONLY (context));\n+#if 0 /* This doesn't get us stuff needed only by the file initializer.  */\n+\t  DECIDE (TREE_USED (t));\n+#else /* This compiles too much stuff, but that's probably better in\n+\t most cases than never compiling the stuff we need.  */\n+\t  DECIDE (1);\n+#endif\n+\t}\n+\n+      if (i->interface == 1)\n+\tDECIDE (TREE_USED (t));\n+      else\n+\tDECIDE (i->interface);\n+\n+    decided:\n+#ifdef DEBUG\n+      print_node_brief (stderr, decision ? \"yes: \" : \"no: \", t, 0);\n+      fprintf (stderr, \"\\t%s\\n\",\n+\t       (DECL_ASSEMBLER_NAME (t)\n+\t\t? IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t))\n+\t\t: \"\"));\n+#endif\n+      if (decision)\n+\t{\n+\t  i->next = pending_inlines;\n+\t  pending_inlines = i;\n+\t}\n+      else\n+\t{\n+\t  i->next = new_list;\n+\t  new_list = i;\n+\t}\n+      i = next;\n+    }\n+  pending_template_expansions = new_list;\n+  if (!pending_inlines)\n+    return 0;\n+  do_pending_inlines ();\n+  return 1;\n+}\n+\n+\f\n+struct pending_template {\n+  struct pending_template *next;\n+  tree id;\n+};\n+\n+static struct pending_template* pending_templates;\n+\n+void\n+do_pending_templates ()\n+{\n+  struct pending_template* t;\n+  \n+  for ( t = pending_templates; t; t = t->next)\n+    {\n+      instantiate_class_template (t->id, 1);\n+    }\n+\n+  for ( t = pending_templates; t; t = pending_templates)\n+    {\n+      pending_templates = t->next;\n+      free(t);\n+    }\n+}\n+\n+static void\n+add_pending_template (pt)\n+     tree pt;\n+{\n+  struct pending_template *p;\n+  \n+  p = (struct pending_template *) malloc (sizeof (struct pending_template));\n+  p->next = pending_templates;\n+  pending_templates = p;\n+  p->id = pt;\n+}\n+\n+/* called from the parser.  */\n+void\n+do_function_instantiation (declspecs, declarator)\n+     tree declspecs, declarator;\n+{\n+  tree decl = grokdeclarator (declarator, declspecs, NORMAL, 0, 0);\n+  tree name = DECL_NAME (decl);\n+  tree fn = IDENTIFIER_GLOBAL_VALUE (name);\n+  tree result = NULL_TREE;\n+  if (fn)\n+    {\n+      for (fn = get_first_fn (fn); fn; fn = DECL_CHAIN (fn))\n+\tif (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t  {\n+\t    int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (fn));\n+\t    tree *targs = (tree *) malloc (sizeof (tree) * ntparms);\n+\t    int i, dummy;\n+\t    i = type_unification (DECL_TEMPLATE_PARMS (fn), targs,\n+\t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (fn)),\n+\t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (decl)),\n+\t\t\t\t  &dummy, 0);\n+\t    if (i == 0)\n+\t      {\n+\t\tif (result)\n+\t\t  cp_error (\"ambiguous template instantiation for `%D' requested\", decl);\n+\t\telse\n+\t\t  result = instantiate_template (fn, targs);\n+\t      }\n+\t  }\n+    }\n+  if (!result)\n+    cp_error (\"no matching template for `%D' found\", decl);\n+}"}, {"sha": "a259cbe2174d939dfb18dcc5eb564a148b3894b7", "filename": "gcc/cp/ptree.c", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,163 @@\n+/* Prints out trees in human readable form.\n+   Copyright (C) 1992, 1993 Free Software Foundation, Inc.\n+   Hacked by Michael Tiemann (tiemann@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include <stdio.h>\n+#include \"cp-tree.h\"\n+\n+void\n+print_lang_decl (file, node, indent)\n+     FILE *file;\n+     tree node;\n+     int indent;\n+{\n+  if (!DECL_LANG_SPECIFIC (node))\n+    return;\n+  /* A FIELD_DECL only has the flags structure, which we aren't displaying\n+     anyways.  */\n+  if (DECL_MUTABLE_P (node))\n+    {\n+      indent_to (file, indent + 3);\n+      fprintf (file, \" mutable \");\n+    }\n+  if (TREE_CODE (node) == FIELD_DECL)\n+    return;\n+  indent_to (file, indent + 3);\n+  if (DECL_MAIN_VARIANT (node))\n+    {\n+      fprintf (file, \" decl-main-variant \");\n+      fprintf (file, HOST_PTR_PRINTF, DECL_MAIN_VARIANT (node));\n+    }\n+  if (DECL_PENDING_INLINE_INFO (node))\n+    {\n+      fprintf (file, \" pending-inline-info \");\n+      fprintf (file, HOST_PTR_PRINTF, DECL_PENDING_INLINE_INFO (node));\n+    }\n+  if (DECL_TEMPLATE_INFO (node))\n+    {\n+      fprintf (file, \" template-info \");\n+      fprintf (file, HOST_PTR_PRINTF,  DECL_TEMPLATE_INFO (node));\n+    }\n+}\n+\n+void\n+print_lang_type (file, node, indent)\n+     FILE *file;\n+     register tree node;\n+     int indent;\n+{\n+  if (TREE_CODE (node) == TEMPLATE_TYPE_PARM)\n+    {\n+      print_node (file, \"tinfo\", TYPE_VALUES (node), indent + 4);\n+      return;\n+    }\n+\n+  if (TREE_CODE (node) == UNINSTANTIATED_P_TYPE)\n+    {\n+      print_node (file, \"template\", UPT_TEMPLATE (node), indent + 4);\n+      print_node (file, \"parameters\", UPT_PARMS (node), indent + 4);\n+      return;\n+    }\n+\n+  if (! (TREE_CODE (node) == RECORD_TYPE\n+\t || TREE_CODE (node) == UNION_TYPE))\n+    return;\n+\n+  if (!TYPE_LANG_SPECIFIC (node))\n+    return;\n+\n+  indent_to (file, indent + 3);\n+\n+  if (TYPE_NEEDS_CONSTRUCTING (node))\n+    fputs ( \"needs-constructor\", file);\n+  if (TYPE_NEEDS_DESTRUCTOR (node))\n+    fputs (\" needs-destructor\", file);\n+  if (TYPE_HAS_DESTRUCTOR (node))\n+    fputs (\" ~X()\", file);\n+  if (TYPE_HAS_DEFAULT_CONSTRUCTOR (node))\n+    fputs (\" X()\", file);\n+  if (TYPE_HAS_CONVERSION (node))\n+    fputs (\" has-type-conversion\", file);\n+  if (TYPE_HAS_INT_CONVERSION (node))\n+    fputs (\" has-int-conversion\", file);\n+  if (TYPE_HAS_REAL_CONVERSION (node))\n+    fputs (\" has-float-conversion\", file);\n+  if (TYPE_HAS_INIT_REF (node))\n+    {\n+      if (TYPE_HAS_CONST_INIT_REF (node))\n+\tfputs (\" X(constX&)\", file);\n+      else\n+\tfputs (\" X(X&)\", file);\n+    }\n+  if (TREE_GETS_NEW (node))\n+    fputs (\" gets-new\", file);\n+  if (TREE_GETS_DELETE (node))\n+    fputs (\" gets-delete\", file);\n+  if (TYPE_HAS_ASSIGNMENT (node))\n+    fputs (\" has=\", file);\n+  if (TYPE_HAS_ASSIGN_REF (node))\n+    fputs (\" this=(X&)\", file);\n+  if (TYPE_OVERLOADS_METHOD_CALL_EXPR (node))\n+    fputs (\" op->()\", file);\n+  if (TYPE_GETS_INIT_AGGR (node))\n+    fputs (\" gets X(X, ...)\", file);\n+  if (TYPE_OVERLOADS_CALL_EXPR (node))\n+    fputs (\" op()\", file);\n+  if (TYPE_OVERLOADS_ARRAY_REF (node))\n+    fputs (\" op[]\", file);\n+  if (TYPE_OVERLOADS_ARROW (node))\n+    fputs (\" op->\", file);\n+  if (TYPE_USES_MULTIPLE_INHERITANCE (node))\n+    fputs (\" uses-multiple-inheritance\", file);\n+\n+  if (TREE_CODE (node) == RECORD_TYPE)\n+    {\n+      fprintf (file, \" n_parents %d n_ancestors %d\",\n+\t       CLASSTYPE_N_BASECLASSES (node),\n+\t       CLASSTYPE_N_SUPERCLASSES (node));\n+      fprintf (file, \" use_template=%d\", CLASSTYPE_USE_TEMPLATE (node));\n+      if (CLASSTYPE_INTERFACE_ONLY (node))\n+\tfprintf (file, \" interface-only\");\n+      if (CLASSTYPE_INTERFACE_UNKNOWN (node))\n+\tfprintf (file, \" interface-unknown\");\n+      print_node (file, \"member-functions\", CLASSTYPE_METHOD_VEC (node),\n+\t\t  indent + 4);\n+      print_node (file, \"baselinks\",\n+\t\t  TYPE_BINFO_BASETYPES (node) ? CLASSTYPE_BASELINK_VEC (node) : NULL_TREE,\n+\t\t  indent + 4);\n+    }\n+}\n+\n+void\n+print_lang_identifier (file, node, indent)\n+     FILE *file;\n+     tree node;\n+     int indent;\n+{\n+  print_node (file, \"global\", IDENTIFIER_GLOBAL_VALUE (node), indent + 4);\n+  print_node (file, \"class\", IDENTIFIER_CLASS_VALUE (node), indent + 4);\n+  print_node (file, \"local\", IDENTIFIER_LOCAL_VALUE (node), indent + 4);\n+  print_node (file, \"label\", IDENTIFIER_LABEL_VALUE (node), indent + 4);\n+  print_node (file, \"template\", IDENTIFIER_TEMPLATE (node), indent + 4);\n+  print_node (file, \"implicit\", IDENTIFIER_IMPLICIT_DECL (node), indent + 4);\n+  print_node (file, \"error locus\", IDENTIFIER_ERROR_LOCUS (node), indent + 4);\n+}"}, {"sha": "3619663cc672ab7c250ab06e24b309c911a462b0", "filename": "gcc/cp/search.c", "status": "added", "additions": 3308, "deletions": 0, "changes": 3308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02"}, {"sha": "979d7aa837b681965b05623980ed429137f82175", "filename": "gcc/cp/sig.c", "status": "added", "additions": 998, "deletions": 0, "changes": 998, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,998 @@\n+/* Functions dealing with signatures and signature pointers/references.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Contributed by Gerald Baumgartner (gb@cs.purdue.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"obstack.h\"\n+#include \"tree.h\"\n+#include \"cp-tree.h\"\n+#include \"flags.h\"\n+#include \"assert.h\"\n+\n+extern struct obstack *current_obstack;\n+extern struct obstack permanent_obstack;\n+extern struct obstack *saveable_obstack;\n+\n+extern void error ();\n+extern void sorry ();\n+extern void compiler_error ();\n+extern void make_decl_rtl\t\t\tPROTO((tree, char *, int));\n+\n+/* Used to help generate globally unique names for signature tables.  */\n+\n+static int global_sigtable_name_counter;\n+\n+/* Build an identifier for a signature pointer or reference, so we\n+   can use it's name in function name mangling.  */\n+\n+static tree\n+build_signature_pointer_or_reference_name (to_type, constp, volatilep, refp)\n+     tree to_type;\n+     int constp, volatilep, refp;\n+{\n+  char * sig_name = TYPE_NAME_STRING (to_type);\n+  int name_len = TYPE_NAME_LENGTH (to_type) + constp + volatilep;\n+  char * name;\n+\n+  if (refp)\n+    {\n+      name = (char *) alloca (name_len + sizeof (SIGNATURE_REFERENCE_NAME) +2);\n+      sprintf (name, SIGNATURE_REFERENCE_NAME_FORMAT,\n+\t       constp ? \"C\" : \"\", volatilep ? \"V\": \"\", sig_name);\n+    }\n+  else\n+    {\n+      name = (char *) alloca (name_len + sizeof (SIGNATURE_POINTER_NAME) + 2);\n+      sprintf (name, SIGNATURE_POINTER_NAME_FORMAT,\n+\t       constp ? \"C\" : \"\", volatilep ? \"V\": \"\", sig_name);\n+    }\n+  return get_identifier (name);\n+}\n+\n+/* Build a DECL node for a signature pointer or reference, so we can\n+   tell the debugger the structure of signature pointers/references.\n+   This function is called at most eight times for a given signature,\n+   once for each [const] [volatile] signature pointer/reference.  */\n+\n+static void\n+build_signature_pointer_or_reference_decl (type, name)\n+     tree type, name;\n+{\n+  tree decl;\n+\n+  /* We don't enter this declaration in any sort of symbol table.  */\n+  decl = build_decl (TYPE_DECL, name, type);\n+  TYPE_NAME (type) = decl;\n+  TREE_CHAIN (type) = decl;\n+}\n+\n+/* Construct, lay out and return the type of pointers or references\n+   to signature TO_TYPE.  If such a type has already been constructed,\n+   reuse it. If CONSTP or VOLATILEP is specified, make the `optr' const\n+   or volatile, respectively.   If we are constructing a const/volatile\n+   type variant and the main type variant doesn't exist yet, it is built\n+   as well.  If REFP is 1, we construct a signature reference, otherwise\n+   a signature pointer is constructed.\n+\n+   This function is a subroutine of `build_signature_pointer_type' and\n+   `build_signature_reference_type'.  */\n+\n+static tree\n+build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n+     tree to_type;\n+     int constp, volatilep, refp;\n+{\n+  register tree t, m;\n+  register struct obstack *ambient_obstack = current_obstack;\n+  register struct obstack *ambient_saveable_obstack = saveable_obstack;\n+\n+  m = refp ? SIGNATURE_REFERENCE_TO (to_type) : SIGNATURE_POINTER_TO (to_type);\n+\n+  /* If we don't have the main variant yet, construct it.  */\n+  if (m == NULL_TREE\n+      && (constp || volatilep))\n+    m = build_signature_pointer_or_reference_type (to_type, 0, 0, refp);\n+\n+  /* Treat any nonzero argument as 1.  */\n+  constp = !!constp;\n+  volatilep = !!volatilep;\n+  refp = !!refp;\n+\n+  /* If not generating auxiliary info, search the chain of variants to see\n+     if there is already one there just like the one we need to have.  If so,\n+     use that existing one.\n+\n+     We don't do this in the case where we are generating aux info because\n+     in that case we want each typedef names to get it's own distinct type\n+     node, even if the type of this new typedef is the same as some other\n+     (existing) type.  */\n+\n+  if (m && !flag_gen_aux_info)\n+    for (t = m; t; t = TYPE_NEXT_VARIANT (t))\n+      if (constp == TYPE_READONLY (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (t))))\n+\t  && volatilep == TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (t)))))\n+        return t;\n+\n+  /* We need a new one.  If TO_TYPE is permanent, make this permanent too.  */\n+  if (TREE_PERMANENT (to_type))\n+    {\n+      current_obstack = &permanent_obstack;\n+      saveable_obstack = &permanent_obstack;\n+    }\n+\n+  /* A signature pointer or reference to a signature `s' looks like this:\n+\n+       struct {\n+         void * optr;\n+\t const s * sptr;\n+\t vtbl_type_node * vptr;\n+       };\n+\n+     A `const' signature pointer/reference is a\n+\n+       struct {\n+         const void * optr;\n+\t const s * sptr;\n+\t vtbl_type_node * vptr;\n+       };\n+\n+     Similarly, for `volatile' and `const volatile'.\n+   */\n+\n+  t = make_lang_type (RECORD_TYPE);\n+  {\n+    tree obj_type = build_type_variant (void_type_node, constp, volatilep);\n+    tree optr_type = build_pointer_type (obj_type);\n+    tree optr, sptr, vptr;\n+\n+    optr = build_lang_field_decl (FIELD_DECL,\n+\t\t\t\t  get_identifier (SIGNATURE_OPTR_NAME),\n+\t\t\t\t  optr_type);\n+    DECL_FIELD_CONTEXT (optr) = t;\n+    DECL_CLASS_CONTEXT (optr) = t;\n+\n+    if (m)\n+      {\n+\t/* We can share `sptr' and `vptr' among type variants.  */\n+\tsptr = TREE_CHAIN (TYPE_FIELDS (m));\n+\tvptr = TREE_CHAIN (sptr);\n+      }\n+    else\n+      {\n+\ttree sig_tbl_type = build_type_variant (to_type, 1, 0);\n+\t\n+\tsptr = build_lang_field_decl (FIELD_DECL,\n+\t\t\t\t      get_identifier (SIGNATURE_SPTR_NAME),\n+\t\t\t\t      build_pointer_type (sig_tbl_type));\n+\tvptr = build_lang_field_decl (FIELD_DECL,\n+\t\t\t\t      get_identifier (SIGNATURE_VPTR_NAME),\n+\t\t\t\t      build_pointer_type (vtbl_type_node));\n+\tDECL_FIELD_CONTEXT (sptr) = t;\n+\tDECL_CLASS_CONTEXT (sptr) = t;\n+\tDECL_FIELD_CONTEXT (vptr) = t;\n+\tDECL_CLASS_CONTEXT (vptr) = t;\n+\tTREE_CHAIN (sptr) = vptr;\n+\tTREE_CHAIN (vptr) = NULL_TREE;\n+      }\n+\n+    TREE_CHAIN (optr) = sptr;\n+    TYPE_FIELDS (t) = optr;\n+    /* To make `build_vfn_ref' work when building a signature method call.  */\n+    CLASSTYPE_VFIELD (t) = vptr;\n+    DECL_FCONTEXT (CLASSTYPE_VFIELD (t)) = t;\n+    TYPE_ALIGN (t) = TYPE_ALIGN (optr_type);\n+  }\n+\n+  {\n+    tree name = build_signature_pointer_or_reference_name (to_type, constp,\n+\t\t\t\t\t\t\t   volatilep, refp);\n+\n+    /* Build a DECL node for this type, so the debugger has access to it.  */\n+    build_signature_pointer_or_reference_decl (t, name);\n+  }\n+\n+  CLASSTYPE_GOT_SEMICOLON (t) = 1;\n+  IS_SIGNATURE_POINTER (t) = ! refp;\n+  IS_SIGNATURE_REFERENCE (t) = refp;\n+  SIGNATURE_TYPE (t) = to_type;\n+\n+  if (m)\n+    {\n+      /* Add this type to the chain of variants of TYPE.\n+\t Every type has to be its own TYPE_MAIN_VARIANT.  */\n+      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (m);\n+      TYPE_NEXT_VARIANT (m) = t;\n+    }\n+  else if (refp)\n+    /* Record this type as the reference to TO_TYPE.  */\n+    SIGNATURE_REFERENCE_TO (to_type) = t;\n+  else\n+    /* Record this type as the pointer to TO_TYPE.  */\n+    SIGNATURE_POINTER_TO (to_type) = t;\n+\n+  /* Lay out the type.  This function has many callers that are concerned\n+     with expression-construction, and this simplifies them all.\n+     Also, it guarantees the TYPE_SIZE is permanent if the type is.  */\n+  layout_type (t);\n+\n+  current_obstack = ambient_obstack;\n+  saveable_obstack = ambient_saveable_obstack;\n+\n+  /* Ouput debug information for this type.  */\n+  rest_of_type_compilation (t, 1);\n+\n+  return t;\n+}\n+\n+/* Construct, lay out and return the type of pointers to signature TO_TYPE.  */\n+\n+tree\n+build_signature_pointer_type (to_type, constp, volatilep)\n+     tree to_type;\n+     int constp, volatilep;\n+{\n+  return\n+    build_signature_pointer_or_reference_type (to_type, constp, volatilep, 0);\n+}\n+\n+/* Construct, lay out and return the type of pointers to signature TO_TYPE.  */\n+\n+tree\n+build_signature_reference_type (to_type, constp, volatilep)\n+     tree to_type;\n+     int constp, volatilep;\n+{\n+  return\n+    build_signature_pointer_or_reference_type (to_type, constp, volatilep, 1);\n+}\n+\n+/* Return the name of the signature table (as an IDENTIFIER_NODE)\n+   for the given signature type SIG_TYPE and rhs type RHS_TYPE.  */\n+\n+static tree\n+get_sigtable_name (sig_type, rhs_type)\n+     tree sig_type, rhs_type;\n+{\n+  tree sig_type_id = build_typename_overload (sig_type);\n+  tree rhs_type_id = build_typename_overload (rhs_type);\n+  char *buf = (char *) alloca (sizeof (SIGTABLE_NAME_FORMAT_LONG)\n+\t\t\t       + IDENTIFIER_LENGTH (sig_type_id)\n+\t\t\t       + IDENTIFIER_LENGTH (rhs_type_id) + 20);\n+  char *sig_ptr = IDENTIFIER_POINTER (sig_type_id);\n+  char *rhs_ptr = IDENTIFIER_POINTER (rhs_type_id);\n+  int i, j;\n+\n+  for (i = 0; sig_ptr[i] == OPERATOR_TYPENAME_FORMAT[i]; i++)\n+    /* do nothing */;\n+  while (sig_ptr[i] >= '0' && sig_ptr[i] <= '9')\n+    i += 1;\n+\n+  for (j = 0; rhs_ptr[j] == OPERATOR_TYPENAME_FORMAT[j]; j++)\n+    /* do nothing */;\n+  while (rhs_ptr[j] >= '0' && rhs_ptr[j] <= '9')\n+    j += 1;\n+\n+  if (IS_SIGNATURE (rhs_type))\n+    sprintf (buf, SIGTABLE_NAME_FORMAT_LONG, sig_ptr+i, rhs_ptr+j,\n+\t     global_sigtable_name_counter++);\n+  else\n+    sprintf (buf, SIGTABLE_NAME_FORMAT, sig_ptr+i, rhs_ptr+j);\n+  return get_identifier (buf);\n+}\n+\n+/* Build a field decl that points to a signature member function.  */\n+\n+static tree\n+build_member_function_pointer (member)\n+     tree member;\n+{\n+  char *namstr = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (member));\n+  int namlen = IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (member));\n+  char *name;\n+  tree entry;\n+  \n+  name = (char *) alloca (namlen + sizeof (SIGNATURE_FIELD_NAME) + 2);\n+  sprintf (name, SIGNATURE_FIELD_NAME_FORMAT, namstr);\n+\n+  /* @@ Do we really want to xref signature table fields?  */\n+  GNU_xref_ref (current_function_decl, name);\n+\n+  entry = build_lang_field_decl (FIELD_DECL, get_identifier (name),\n+\t\t\t\t TYPE_MAIN_VARIANT (sigtable_entry_type));\n+  TREE_CONSTANT (entry) = 1;\n+  TREE_READONLY (entry) = 1;\n+\n+  /* @@ Do we really want to xref signature table fields?  */\n+  GNU_xref_decl (current_function_decl, entry);\n+\n+  return entry;\n+}\n+\n+/* For each FUNCTION_DECL in a signature we construct a member function\n+   pointer of the appropriate type.  We also need two flags to test\n+   whether the member function pointer points to a virtual function or\n+   to a default implementation.  Those flags will be the two lower order\n+   bits of the member function pointer (or the two higher order bits,\n+   based on the configuration).\n+\n+   The new FIELD_DECLs are appended at the end of the last (and only)\n+   sublist of `list_of_fieldlists.'\n+\n+   As a side effect, each member function in the signature gets the\n+   `decl.ignored' bit turned on, so we don't output debug info for it.  */\n+\n+void\n+append_signature_fields (list_of_fieldlists)\n+     tree list_of_fieldlists;\n+{\n+  tree l, x;\n+  tree last_x = NULL_TREE;\n+  tree mfptr;\n+  tree last_mfptr;\n+  tree mfptr_list = NULL_TREE;\n+\t      \n+  /* For signatures it should actually be only a list with one element.  */\n+  for (l = list_of_fieldlists; l; l = TREE_CHAIN (l))\n+    {\n+      for (x = TREE_VALUE (l); x; x = TREE_CHAIN (x))\n+\t{\n+\t  if (TREE_CODE (x) == FUNCTION_DECL)\n+\t    {\n+\t      mfptr = build_member_function_pointer (x);\n+\t      DECL_MEMFUNC_POINTER_TO (x) = mfptr;\n+\t      DECL_MEMFUNC_POINTING_TO (mfptr) = x;\n+\t      DECL_IGNORED_P (x) = 1;\n+\t      DECL_IN_AGGR_P (mfptr) = 1;\n+\t      if (! mfptr_list)\n+\t\tmfptr_list = last_mfptr = mfptr;\n+\t      else\n+\t\t{\n+\t\t  TREE_CHAIN (last_mfptr) = mfptr;\n+\t\t  last_mfptr = mfptr;\n+\t\t}\n+\t    }\n+\t  last_x = x;\n+\t}\n+    }\n+\n+  /* Append the lists.  */\n+  if (last_x && mfptr_list)\n+    {\n+      TREE_CHAIN (last_x) = mfptr_list;\n+      TREE_CHAIN (last_mfptr) = NULL_TREE;\n+    }\n+}\n+\n+/* Compare the types of a signature member function and a class member\n+   function.  Returns 1 if the types are in the C++ `<=' relationship.\n+\n+   If we have a signature pointer/reference as argument or return type\n+   we don't want to do a recursive conformance check.  The conformance\n+   check only succeeds if both LHS and RHS refer to the same signature\n+   pointer.  Otherwise we need to keep information about parameter types\n+   around at run time to initialize the signature table correctly.  */\n+\n+static int\n+match_method_types (sig_mtype, class_mtype)\n+     tree sig_mtype, class_mtype;\n+{\n+  tree sig_return_type = TREE_TYPE (sig_mtype);\n+  tree sig_arg_types = TYPE_ARG_TYPES (sig_mtype);\n+  tree class_return_type = TREE_TYPE (class_mtype);\n+  tree class_arg_types = TYPE_ARG_TYPES (class_mtype);\n+\n+  /* The return types have to be the same.  */\n+  if (! comptypes (sig_return_type, class_return_type, 1))\n+    return 0;\n+\n+  /* Compare the first argument `this.'  */\n+  {\n+    /* Get the type of what the `optr' is pointing to.  */\n+    tree sig_this =\n+      TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_VALUE (sig_arg_types))));\n+    tree class_this = TREE_VALUE (class_arg_types);\n+\n+    if (TREE_CODE (class_this) == RECORD_TYPE)\t/* Is `this' a sig ptr?  */\n+      class_this = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (class_this)));\n+    else\n+      class_this = TREE_TYPE (class_this);\n+\n+    /* If a signature method's `this' is const or volatile, so has to be\n+       the corresponding class method's `this.'  */\n+    if ((TYPE_READONLY (sig_this) && ! TYPE_READONLY (class_this))\n+\t|| (TYPE_VOLATILE (sig_this) && ! TYPE_VOLATILE (class_this)))\n+      return 0;\n+  }\n+\n+  sig_arg_types = TREE_CHAIN (sig_arg_types);\n+  class_arg_types = TREE_CHAIN (class_arg_types);\n+\n+  /* The number of arguments and the argument types have to be the same.  */\n+  return compparms (sig_arg_types, class_arg_types, 3);\n+}\n+\n+/* Undo casts of opaque type variables to the RHS types.  */\n+static void\n+undo_casts (sig_ty)\n+     tree sig_ty;\n+{\n+  tree field = TYPE_FIELDS (sig_ty);\n+\n+  /* Since all the FIELD_DECLs for the signature table entries are at the end\n+     of the chain (see `append_signature_fields'), we can do it this way.  */\n+  for (; field && TREE_CODE (field) != FIELD_DECL; field = TREE_CHAIN (field))\n+    if (TYPE_MAIN_VARIANT (TREE_TYPE (field)) == opaque_type_node)\n+      TREE_TYPE (TREE_TYPE (field)) = TREE_TYPE (ptr_type_node);\n+}\n+\n+/* Do the type checking necessary to see whether the `rhs' conforms to\n+   the lhs's `sig_ty'.  Depending on the type of `rhs' return a NULL_TREE,\n+   an integer_zero_node, a constructor, or an expression offsetting the\n+   `rhs' signature table.  */\n+\n+static tree\n+build_signature_table_constructor (sig_ty, rhs)\n+     tree sig_ty, rhs;\n+{\n+  tree rhstype = TREE_TYPE (rhs);\n+  tree sig_field = TYPE_FIELDS (sig_ty);\n+  tree result = NULL_TREE;\n+  tree first_rhs_field = NULL_TREE;\n+  tree last_rhs_field;\n+  int sig_ptr_p = IS_SIGNATURE (rhstype);\n+  int offset_p = sig_ptr_p;\n+\n+  rhstype = sig_ptr_p ? rhstype : TREE_TYPE (rhstype);\n+\n+  if (CLASSTYPE_TAGS (sig_ty))\n+    {\n+      sorry (\"conformance check with signature containing class declarations\");\n+      return error_mark_node;\n+    }\n+\n+  for (; sig_field; sig_field = TREE_CHAIN (sig_field))\n+    {\n+      tree basetype_path, baselink, basetypes;\n+      tree sig_method, sig_mname, sig_mtype;\n+      tree rhs_method, tbl_entry;\n+\n+      if (TREE_CODE (sig_field) == TYPE_DECL)\n+\t{\n+\t  tree sig_field_type = TREE_TYPE (sig_field);\n+\n+\t  if (TYPE_MAIN_VARIANT (sig_field_type) == opaque_type_node)\n+\t    {\n+\t      /* We've got an opaque type here.  */\n+\t      tree oty_name = DECL_NAME (sig_field);\n+\t      tree oty_type = lookup_field (rhstype, oty_name, 1, 1);\n+\n+\t      if (oty_type == NULL_TREE || oty_type == error_mark_node)\n+\t\t{\n+\t\t  cp_error (\"class `%T' does not contain type `%T'\",\n+\t\t\t    rhstype, oty_type);\n+\t\t  undo_casts (sig_ty);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      oty_type = TREE_TYPE (oty_type);\n+\n+\t      /* Cast `sig_field' to be of type `oty_type'.  This will be\n+\t\t undone in `undo_casts' by walking over all the TYPE_DECLs.  */\n+\t      TREE_TYPE (sig_field_type) = TREE_TYPE (oty_type);\n+\t    }\n+\t  /* If we don't have an opaque type, we can ignore the `typedef'.  */\n+\t  continue;\n+\t}\n+\n+      /* Find the signature method corresponding to `sig_field'.  */\n+      sig_method = DECL_MEMFUNC_POINTING_TO (sig_field);\n+      sig_mname = DECL_NAME (sig_method);\n+      sig_mtype = TREE_TYPE (sig_method);\n+\n+      basetype_path = TYPE_BINFO (rhstype);\n+      baselink = lookup_fnfields (basetype_path, sig_mname, 0);\n+      if (baselink == NULL_TREE || baselink == error_mark_node)\n+\t{\n+\t  if (! IS_DEFAULT_IMPLEMENTATION (sig_method))\n+\t    {\n+\t      cp_error (\"class `%T' does not contain method `%s'\",\n+\t\t\trhstype, (int) IDENTIFIER_POINTER (sig_mname));\n+\t      undo_casts (sig_ty);\n+\t      return error_mark_node;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We use the signature's default implementation.  */\n+\t      rhs_method = sig_method;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Find the class method of the correct type.  */\n+\n+\t  basetypes = TREE_PURPOSE (baselink);\n+\t  if (TREE_CODE (basetypes) == TREE_LIST)\n+\t    basetypes = TREE_VALUE (basetypes);\n+\n+\t  rhs_method = TREE_VALUE (baselink);\n+\t  for (; rhs_method; rhs_method = TREE_CHAIN (rhs_method))\n+\t    if (sig_mname == DECL_NAME (rhs_method)\n+\t\t&& ! DECL_STATIC_FUNCTION_P (rhs_method)\n+\t\t&& match_method_types (sig_mtype, TREE_TYPE (rhs_method)))\n+\t      break;\n+\n+\t  if (rhs_method == NULL_TREE\n+\t      || (compute_access (basetypes, rhs_method)\n+\t\t  != access_public))\n+\t    {\n+\t      error (\"class `%s' does not contain a method conforming to `%s'\",\n+\t\t     TYPE_NAME_STRING (rhstype),\n+\t\t     fndecl_as_string (NULL, sig_method, 1));\n+\t      undo_casts (sig_ty);\n+\t      return error_mark_node;\n+\t    }\n+\t}\n+\n+      if (sig_ptr_p && rhs_method != sig_method)\n+\t{\n+\t  tree rhs_field = DECL_MEMFUNC_POINTER_TO (rhs_method);\n+\n+\t  if (first_rhs_field == NULL_TREE)\n+\t    {\n+\t      first_rhs_field = rhs_field;\n+\t      last_rhs_field = rhs_field;\n+\t    }\n+\t  else if (TREE_CHAIN (last_rhs_field) == rhs_field)\n+\t    last_rhs_field = rhs_field;\n+\t  else\n+\t    offset_p = 0;\n+\t  \n+\t  tbl_entry = build_component_ref (rhs, DECL_NAME (rhs_field),\n+\t\t\t\t\t   NULL_TREE, 1);\n+\t}\n+      else\n+\t{\n+\t  tree code, offset, pfn;\n+\n+\t  if (rhs_method == sig_method)\n+\t    {\n+\t      code = integer_two_node;\n+\t      offset = integer_zero_node;\n+\t      pfn = build_unary_op (ADDR_EXPR, rhs_method, 0);\n+\t      TREE_TYPE (pfn) = ptr_type_node;\n+\t      offset_p = 0;\t/* we can't offset the rhs sig table */\n+\t    }\n+\t  else if (DECL_VINDEX (rhs_method))\n+\t    {\n+\t      code = integer_one_node;\n+\t      offset = DECL_VINDEX (rhs_method);\n+\t      pfn = null_pointer_node;\n+\t    }\n+\t  else\n+\t    {\n+\t      code = integer_zero_node;\n+\t      offset = integer_zero_node;\n+\t      pfn = build_unary_op (ADDR_EXPR, rhs_method, 0);\n+\t      TREE_TYPE (pfn) = ptr_type_node;\n+\t    }\n+\n+\t  tbl_entry = tree_cons (NULL_TREE, code,\n+\t\t\t\t tree_cons (NULL_TREE, offset,\n+\t\t\t\t\t    build_tree_list (NULL_TREE, pfn)));\n+\t  tbl_entry = build_nt (CONSTRUCTOR, NULL_TREE, tbl_entry);\n+\t  TREE_HAS_CONSTRUCTOR (tbl_entry) = 1;\n+\t  TREE_CONSTANT (tbl_entry) = 1;\n+\t}\n+\n+      /* Chain those function address expressions together.  */\n+      if (result)\n+\tresult = tree_cons (NULL_TREE, tbl_entry, result);\n+      else\n+\tresult = build_tree_list (NULL_TREE, tbl_entry);\n+    }\n+\n+  if (result == NULL_TREE)\n+    {\n+      undo_casts (sig_ty);\n+      return NULL_TREE;\n+    }\n+\n+  if (offset_p)\n+    {\n+      if (first_rhs_field == TYPE_FIELDS (rhstype))\n+\t{\n+\t  undo_casts (sig_ty);\n+\t  return integer_zero_node;\n+\t}\n+      else\n+\t{\n+\t  undo_casts (sig_ty);\n+\t  return build_component_ref (rhs, DECL_NAME (first_rhs_field),\n+\t\t\t\t      NULL_TREE, 0);\n+\t}\n+    }\n+\n+  result = build_nt (CONSTRUCTOR, NULL_TREE, nreverse (result));\n+  TREE_HAS_CONSTRUCTOR (result) = 1;\n+  TREE_CONSTANT (result) = !sig_ptr_p;\n+\n+  undo_casts (sig_ty);\n+  return result;\n+}\n+\n+/* Build a signature table declaration and initialize it or return an\n+   existing one if we built one already.  If we don't get a constructor\n+   as initialization expression, we don't need a new signature table\n+   variable and just hand back the init expression.\n+\n+   The declaration processing is done by hand instead of using `finish_decl'\n+   so that we can make signature pointers global variables instead of\n+   static ones.  */\n+\n+static tree\n+build_sigtable (sig_type, rhs_type, init_from)\n+     tree sig_type, rhs_type, init_from;\n+{\n+  tree name = NULL_TREE;\n+  tree decl = NULL_TREE;\n+  tree init_expr;\n+\n+  push_obstacks_nochange ();\n+  end_temporary_allocation ();\n+\n+  if (! IS_SIGNATURE (rhs_type))\n+    {\n+      name = get_sigtable_name (sig_type, rhs_type);\n+      decl = IDENTIFIER_GLOBAL_VALUE (name);\n+    }\n+  if (decl == NULL_TREE)\n+    {\n+      tree init;\n+\n+      /* We allow only one signature table to be generated for signatures\n+\t with opaque types.  Otherwise we create a loophole in the type\n+\t system since we could cast data from one classes implementation\n+\t of the opaque type to that of another class.  */\n+      if (SIGNATURE_HAS_OPAQUE_TYPEDECLS (sig_type)\n+\t  && SIGTABLE_HAS_BEEN_GENERATED (sig_type))\n+\t{\n+\t  error (\"signature with opaque type implemented by multiple classes\");\n+\t  return error_mark_node;\n+\t}\n+      SIGTABLE_HAS_BEEN_GENERATED (sig_type) = 1;\n+\n+      init_expr = build_signature_table_constructor (sig_type, init_from);\n+      if (TREE_CODE (init_expr) != CONSTRUCTOR)\n+\treturn init_expr;\n+\n+      if (name == NULL_TREE)\n+\tname = get_sigtable_name (sig_type, rhs_type);\n+      {\n+\ttree context = current_function_decl;\n+\n+\t/* Make the signature table global, not just static in whichever\n+\t   function a signature pointer/ref is used for the first time.  */\n+\tcurrent_function_decl = NULL_TREE;\n+\tdecl = pushdecl_top_level (build_decl (VAR_DECL, name, sig_type));\n+\tcurrent_function_decl = context;\n+      }\n+      IDENTIFIER_GLOBAL_VALUE (name) = decl;\n+      store_init_value (decl, init_expr);\n+      if (IS_SIGNATURE (rhs_type))\n+\t{\n+\t  init = DECL_INITIAL (decl);\n+\t  DECL_INITIAL (decl) = error_mark_node;\n+\t}\n+\n+      DECL_ALIGN (decl) = MAX (TYPE_ALIGN (double_type_node),\n+\t\t\t       DECL_ALIGN (decl));\n+#if 0\n+      /* GDB-4.7 doesn't find the initialization value of a signature table\n+\t when it is constant.  */\n+      TREE_READONLY (decl) = 1;\n+#endif\n+      TREE_STATIC (decl) = 1;\n+      TREE_USED (decl) = 1;\n+\n+      make_decl_rtl (decl, NULL, 1);\n+      if (IS_SIGNATURE (rhs_type))\n+\texpand_static_init (decl, init);\n+    }\n+\n+  pop_obstacks ();\n+\n+  return decl;\n+}\n+\n+/* Create a constructor or modify expression if the LHS of an assignment\n+   is a signature pointer or a signature reference.  If LHS is a record\n+   type node, we build a constructor, otherwise a compound expression.  */\n+\n+tree\n+build_signature_pointer_constructor (lhs, rhs)\n+     tree lhs, rhs;\n+{\n+  register struct obstack *ambient_obstack = current_obstack;\n+  register struct obstack *ambient_saveable_obstack = saveable_obstack;\n+  int initp = (TREE_CODE (lhs) == RECORD_TYPE);\n+  tree lhstype = initp ? lhs : TREE_TYPE (lhs);\n+  tree rhstype = TREE_TYPE (rhs);\n+  tree sig_ty  = SIGNATURE_TYPE (lhstype);\n+  tree sig_tbl, sptr_expr, optr_expr, vptr_expr;\n+  tree result;\n+\n+  if (! ((TREE_CODE (rhstype) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (rhstype)) == RECORD_TYPE)\n+\t || (TYPE_LANG_SPECIFIC (rhstype) &&\n+\t     (IS_SIGNATURE_POINTER (rhstype)\n+\t      || IS_SIGNATURE_REFERENCE (rhstype)))))\n+    {\n+      error (\"invalid assignment to signature pointer or reference\");\n+      return error_mark_node;\n+    }\n+\n+  /* If SIG_TY is permanent, make the signature table constructor and\n+     the signature pointer/reference constructor permanent too.  */\n+  if (TREE_PERMANENT (sig_ty))\n+    {\n+      current_obstack = &permanent_obstack;\n+      saveable_obstack = &permanent_obstack;\n+    }\n+\n+  if (TYPE_LANG_SPECIFIC (rhstype) &&\n+      (IS_SIGNATURE_POINTER (rhstype) || IS_SIGNATURE_REFERENCE (rhstype)))\n+    {\n+      if (SIGNATURE_TYPE (rhstype) == sig_ty)\n+\t{\n+\t  /* LHS and RHS are signature pointers/refs of the same signature.  */\n+\t  optr_expr = build_optr_ref (rhs);\n+\t  sptr_expr = build_sptr_ref (rhs);\n+\t  vptr_expr = build_vptr_ref (rhs);\n+\t}\n+      else\n+\t{\n+\t  /* We need to create a new signature table and copy\n+\t     elements from the rhs signature table.  */\n+\t  tree rhs_sptr_ref = build_sptr_ref (rhs);\n+\t  tree rhs_tbl = build1 (INDIRECT_REF, SIGNATURE_TYPE (rhstype),\n+\t\t\t\t rhs_sptr_ref);\n+\n+\t  sig_tbl = build_sigtable (sig_ty, SIGNATURE_TYPE (rhstype), rhs_tbl);\n+\t  if (sig_tbl == error_mark_node)\n+\t    return error_mark_node;\n+\n+\t  optr_expr = build_optr_ref (rhs);\n+\t  if (sig_tbl == integer_zero_node)\n+\t    sptr_expr = rhs_sptr_ref;\n+\t  else\n+\t    sptr_expr = build_unary_op (ADDR_EXPR, sig_tbl, 0);\n+\t  TREE_TYPE (sptr_expr) = build_pointer_type (sig_ty);\n+\t  vptr_expr = build_vptr_ref (rhs);\n+\t}\n+    }\n+  else\n+    {\n+      tree rhs_vptr;\n+\n+      if (TYPE_USES_COMPLEX_INHERITANCE (TREE_TYPE (rhstype)))\n+\t{\n+\t  sorry (\"class with multiple inheritance as implementation of signature\");\n+\t  return error_mark_node;\n+\t}\n+\n+      sig_tbl = build_sigtable (sig_ty, TREE_TYPE (rhstype), rhs);\n+      if (sig_tbl == error_mark_node)\n+\treturn error_mark_node;\n+\n+      optr_expr = rhs;\n+      sptr_expr = build_unary_op (ADDR_EXPR, sig_tbl, 0);\n+      if (CLASSTYPE_VFIELD (TREE_TYPE (rhstype)))\n+\t{\n+\t  rhs_vptr = DECL_NAME (CLASSTYPE_VFIELD (TREE_TYPE (rhstype)));\n+\t  vptr_expr = build_component_ref (build_indirect_ref (rhs, 0),\n+\t\t\t\t\t   rhs_vptr, NULL_TREE, 0);\n+\t}\n+      else\n+\tvptr_expr = null_pointer_node;\n+      TREE_TYPE (vptr_expr) = build_pointer_type (vtbl_type_node);\n+    }\n+\n+  if (initp)\n+    {\n+      result = tree_cons (NULL_TREE, optr_expr,\n+\t\t\t  tree_cons (NULL_TREE, sptr_expr,\n+\t\t\t\t     build_tree_list (NULL_TREE, vptr_expr)));\n+      result = build_nt (CONSTRUCTOR, NULL_TREE, result);\n+      TREE_HAS_CONSTRUCTOR (result) = 1;\n+      result = digest_init (lhstype, result, 0);\n+    }\n+  else\n+    {\n+      if (TREE_READONLY (lhs) || TYPE_READONLY (lhstype))\n+\t  readonly_error (lhs, \"assignment\", 0);\n+\n+      optr_expr = build_modify_expr (build_optr_ref (lhs), NOP_EXPR,\n+\t\t\t\t     optr_expr);\n+      sptr_expr = build_modify_expr (build_sptr_ref (lhs), NOP_EXPR,\n+\t\t\t\t     sptr_expr);\n+      vptr_expr = build_modify_expr (build_vptr_ref (lhs), NOP_EXPR,\n+\t\t\t\t     vptr_expr);\n+\n+      result = tree_cons (NULL_TREE, optr_expr,\n+\t\t\t  tree_cons (NULL_TREE, sptr_expr,\n+\t\t\t\t     tree_cons (NULL_TREE, vptr_expr,\n+\t\t\t\t\t\tbuild_tree_list (NULL_TREE,\n+\t\t\t\t\t\t\t\t lhs))));\n+      result = build_compound_expr (result);\n+    }\n+\n+  current_obstack = ambient_obstack;\n+  saveable_obstack = ambient_saveable_obstack;\n+  return result;\n+}\n+\n+/* Build a temporary variable declaration for the instance of a signature\n+   member function call if it isn't a declaration node already.  Simply\n+   using a SAVE_EXPR doesn't work since we need `this' in both branches\n+   of a conditional expression.  */\n+\n+static tree\n+save_this (instance)\n+     tree instance;\n+{\n+  tree decl;\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (instance)) == 'd')\n+    decl = instance;\n+  else\n+    {\n+      decl = build_decl (VAR_DECL, NULL_TREE, TREE_TYPE (instance));\n+      DECL_REGISTER (decl) = 1;\n+      layout_decl (decl, 0);\n+      expand_decl (decl);\n+    }\n+\n+  return decl;\n+}\n+\n+/* Build a signature member function call.  Looks up the signature table\n+   entry corresponding to FUNCTION.  Depending on the value of the CODE\n+   field, either call the function in PFN directly, or use OFFSET to\n+   index INSTANCE's virtual function table.  */\n+\n+tree\n+build_signature_method_call (basetype, instance, function, parms)\n+     tree basetype, instance, function, parms;\n+{\n+  tree saved_instance = save_this (instance);\t/* Create temp for `this'.  */\n+  tree signature_tbl_ptr = build_sptr_ref (saved_instance);\n+  tree sig_field_name = DECL_NAME (DECL_MEMFUNC_POINTER_TO (function));\n+  tree basetype_path = TYPE_BINFO (basetype);\n+  tree tbl_entry = build_component_ref (build1 (INDIRECT_REF, basetype,\n+\t\t\t\t\t\tsignature_tbl_ptr),\n+\t\t\t\t\tsig_field_name, basetype_path, 1);\n+  tree code, offset, pfn, vfn;\n+  tree deflt_call = NULL_TREE, direct_call, virtual_call, result;\n+\n+  code = build_component_ref (tbl_entry, get_identifier (SIGTABLE_CODE_NAME),\n+\t\t\t     NULL_TREE, 1);\n+  offset = build_component_ref (tbl_entry,\n+\t\t\t\tget_identifier (SIGTABLE_OFFSET_NAME),\n+\t\t\t     NULL_TREE, 1);\n+  pfn = build_component_ref (tbl_entry, get_identifier (SIGTABLE_PFN_NAME),\n+\t\t\t     NULL_TREE, 1);\n+  TREE_TYPE (pfn) = build_pointer_type (TREE_TYPE (function)); \n+\n+  if (IS_DEFAULT_IMPLEMENTATION (function))\n+    {\n+      pfn = save_expr (pfn);\n+      deflt_call = build_function_call (pfn,\n+\t\t\t\t\ttree_cons (NULL_TREE, saved_instance,\n+\t\t\t\t\t\t   TREE_CHAIN (parms)));\n+    }\n+\n+  {\n+    /* Cast the signature method to have `this' of a normal pointer type.  */\n+    tree old_this = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn))));\n+\n+    TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn)))) =\n+      build_type_variant (TYPE_POINTER_TO (basetype),\n+\t\t\t  TYPE_READONLY (old_this),\n+\t\t\t  TYPE_VOLATILE (old_this));\n+\n+    direct_call = build_function_call (pfn, parms);\n+\n+    vfn = build_vfn_ref (&TREE_VALUE (parms), saved_instance, offset);\n+    TREE_TYPE (vfn) = build_pointer_type (TREE_TYPE (function));\n+    virtual_call = build_function_call (vfn, parms);\n+\n+    /* Undo the cast, make `this' a signature pointer again.  */\n+    TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn)))) = old_this;\n+  }\n+\n+  /* Once the function was found, there should be no reason why we\n+     couldn't build the member function pointer call.  */\n+  if (!direct_call || direct_call == error_mark_node\n+      || !virtual_call || virtual_call == error_mark_node\n+      || (IS_DEFAULT_IMPLEMENTATION (function)\n+\t  && (!deflt_call || deflt_call == error_mark_node)))\n+    {\n+      compiler_error (\"cannot build call of signature member function `%s'\",\n+\t\t      fndecl_as_string (NULL, function, 1));\n+      return error_mark_node;\n+    }\n+\n+  if (IS_DEFAULT_IMPLEMENTATION (function))\n+    {\n+      tree test = build_binary_op_nodefault (EQ_EXPR, code, integer_one_node,\n+\t\t\t\t\t     EQ_EXPR);\n+      result = build_conditional_expr (code,\n+\t\t\t\t       build_conditional_expr (test,\n+\t\t\t\t\t\t\t       virtual_call,\n+\t\t\t\t\t\t\t       deflt_call),\n+\t\t\t\t       direct_call);\n+    }\n+  else\n+    result = build_conditional_expr (code, virtual_call, direct_call);\n+\n+  /* If we created a temporary variable for `this', initialize it first.  */\n+  if (instance != saved_instance)\n+    result = build (COMPOUND_EXPR, TREE_TYPE (result),\n+\t\t    build_modify_expr (saved_instance, NOP_EXPR, instance),\n+\t\t    result);\n+\n+  return result;\n+}\n+\n+/* Create a COMPONENT_REF expression for referencing the OPTR field\n+   of a signature pointer or reference.  */\n+\n+tree\n+build_optr_ref (instance)\n+     tree instance;\n+{\n+  tree field = get_identifier (SIGNATURE_OPTR_NAME);\n+\n+  return build_component_ref (instance, field, NULL_TREE, 1);\n+}\n+\n+/* Create a COMPONENT_REF expression for referencing the SPTR field\n+   of a signature pointer or reference.  */\n+\n+tree\n+build_sptr_ref (instance)\n+     tree instance;\n+{\n+  tree field = get_identifier (SIGNATURE_SPTR_NAME);\n+\n+  return build_component_ref (instance, field, NULL_TREE, 1);\n+}\n+\n+/* Create a COMPONENT_REF expression for referencing the VPTR field\n+   of a signature pointer or reference.  */\n+\n+tree\n+build_vptr_ref (instance)\n+     tree instance;\n+{\n+  tree field = get_identifier (SIGNATURE_VPTR_NAME);\n+\n+  return build_component_ref (instance, field, NULL_TREE, 1);\n+}"}, {"sha": "211876e9e576271613ecfd8bf7ed2400c9819a9e", "filename": "gcc/cp/spew.c", "status": "added", "additions": 1141, "deletions": 0, "changes": 1141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02", "patch": "@@ -0,0 +1,1141 @@\n+/* Type Analyzer for GNU C++.\n+   Copyright (C) 1987, 1989, 1992, 1993 Free Software Foundation, Inc.\n+   Hacked... nay, bludgeoned... by Mark Eichin (eichin@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This file is the type analyzer for GNU C++.  To debug it, define SPEW_DEBUG\n+   when compiling cp-parse.c and cp-spew.c.  */\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"input.h\"\n+#include \"tree.h\"\n+#include \"lex.h\"\n+#include \"parse.h\"\n+#include \"cp-tree.h\"\n+#include \"flags.h\"\n+#include \"obstack.h\"\n+\n+/* This takes a token stream that hasn't decided much about types and\n+   tries to figure out as much as it can, with excessive lookahead and\n+   backtracking. */\n+\n+/* fifo of tokens recognized and available to parser. */\n+struct token  {\n+  /* The values for YYCHAR will fit in a short.  */\n+  short\t\tyychar;\n+  short\t\tend_of_file;\n+  YYSTYPE\tyylval;\n+};\n+\n+static int do_aggr ();\n+static struct token frob_identifier ();\n+static struct token hack_scope ();\n+static tree hack_ptype ();\n+static tree hack_more_ids ();\n+\n+/* From cp-lex.c: */\n+/* the declaration found for the last IDENTIFIER token read in.\n+   yylex must look this up to detect typedefs, which get token type TYPENAME,\n+   so it is left around in case the identifier is not a typedef but is\n+   used in a context which makes it a reference to a variable.  */\n+extern tree lastiddecl;\t\t/* let our brains leak out here too */\n+extern int\tyychar;\t\t/*  the lookahead symbol\t\t*/\n+extern YYSTYPE\tyylval;\t\t/*  the semantic value of the\t\t*/\n+\t\t\t\t/*  lookahead symbol\t\t\t*/\n+extern int end_of_file;\n+\n+struct obstack token_obstack;\n+int first_token;\n+  \n+#ifdef SPEW_DEBUG\n+int spew_debug = 0;\n+static unsigned int yylex_ctr = 0;\n+static int debug_yychar ();\n+#endif\n+\n+static char follows_typename[END_OF_SAVED_INPUT+1];\n+static char follows_identifier[END_OF_SAVED_INPUT+1];\n+\n+/* This is a hack!!! TEMPLATE_TYPE_SEEN_BEFORE_SCOPE consists of the name\n+ * of the last template_type parsed in cp-parse.y if it is followed by a\n+ * scope operator.  It will be reset inside the next invocation of yylex().\n+ * This is used for recognizing nested types inside templates.\n+ * - niklas@appli.se */\n+tree template_type_seen_before_scope;\n+\n+/* Initialize token_obstack. Called once, from init_lex.  */\n+void\n+init_spew ()\n+{\n+  static char *chars_following_identifier = \".+-|/%^!?:\";\n+  short *ps;\n+  static short toks_follow_ids[] =\n+    { ASSIGN, RANGE, OROR, ANDAND, MIN_MAX, EQCOMPARE,\n+      ARITHCOMPARE, LSHIFT, RSHIFT, UNARY, PLUSPLUS, MINUSMINUS, POINTSAT,\n+      POINTSAT_STAR, DOT_STAR, CONSTANT, STRING, SIZEOF, ENUM, IF,\n+      ELSE, WHILE, DO, FOR, SWITCH, CASE, DEFAULT, BREAK, CONTINUE,\n+      RETURN, GOTO, ASM_KEYWORD, GCC_ASM_KEYWORD, TYPEOF, ALIGNOF, HEADOF,\n+      CLASSOF, SIGOF, ATTRIBUTE, AGGR, VISSPEC, DELETE, RAISE, RERAISE, TRY,\n+      EXCEPT, CATCH, THROW, ANSI_TRY, ANSI_THROW, DYNAMIC_CAST, TYPEID,\n+      EXTERN_LANG_STRING, ALL, END_OF_SAVED_INPUT, -1 };\n+  static short toks_follow_types[] =\n+    { IDENTIFIER, TYPENAME, SCOPED_TYPENAME, SCOPED_NAME, SCSPEC, \n+      TYPESPEC, TYPE_QUAL,\n+      ELLIPSIS, THIS, OPERATOR, TEMPLATE, SCOPE, START_DECLARATOR,\n+      TYPENAME_COLON, PAREN_STAR_PAREN, TYPENAME_ELLIPSIS, PTYPENAME,\n+      PRE_PARSED_FUNCTION_DECL, PRE_PARSED_CLASS_DECL, -1 };\n+\n+  gcc_obstack_init(&token_obstack);\n+\n+  /* Initialize the arrays saying what tokens are definitely\n+     (or possibly) valid following typenames and identifiers.  */\n+  while (*chars_following_identifier)\n+    follows_identifier[*chars_following_identifier++] = 1;\n+  for (ps = toks_follow_ids; *ps != -1; ps++)\n+    follows_identifier[*ps] = 1;\n+  for (ps = toks_follow_types; *ps != -1; ps++)\n+    follows_typename[*ps] = 1;\n+}\n+\n+#ifdef SPEW_DEBUG\n+/* Use functions for debugging...  */\n+\n+/* Return the number of tokens available on the fifo. */\n+static int\n+num_tokens ()\n+{\n+  return (obstack_object_size(&token_obstack)/sizeof(struct token))\n+    - first_token;\n+}\n+\n+/* Fetch the token N down the line from the head of the fifo. */\n+static struct token*\n+nth_token (n)\n+     int n;\n+{\n+  /* could just have this do slurp_ implicitly, but this way is easier\n+   * to debug... */\n+  my_friendly_assert (n < num_tokens(), 298);\n+  return ((struct token*)obstack_base(&token_obstack))+n+first_token;\n+}\n+\n+/* Add a token to the token fifo. */\n+static void\n+add_token (t)\n+     struct token* t;\n+{\n+  obstack_grow(&token_obstack,t,sizeof (struct token));\n+}\n+\n+/* Consume the next token out of the fifo.  */\n+static void\n+consume_token()\n+{\n+  if (num_tokens() == 1)\n+    {\n+      obstack_free(&token_obstack, obstack_base (&token_obstack));\n+      first_token = 0;\n+    }\n+  else\n+    first_token++;\n+}\n+\n+#else\n+/* ...otherwise use macros.  */\n+\n+#define num_tokens() \\\n+  ((obstack_object_size(&token_obstack)/sizeof(struct token)) - first_token)\n+\n+#define nth_token(N) \\\n+  (((struct token*)obstack_base(&token_obstack))+(N)+first_token)\n+\n+#define add_token(T) obstack_grow(&token_obstack, (T), sizeof (struct token))\n+\n+#define consume_token() \\\n+  (num_tokens() == 1\t\t\t\t\t\t\t\\\n+   ? (obstack_free (&token_obstack, obstack_base (&token_obstack)),\t\\\n+      (first_token = 0))\t\t\t\t\t\t\\\n+   : first_token++)\n+#endif\n+\n+/* Pull in enough tokens from real_yylex that the queue is N long.  */\n+\n+static void\n+scan_tokens (n)\n+     int n;\n+{\n+  int i;\n+  struct token *tmp;\n+\n+  /* We cannot read past certain tokens, so make sure we don't.  */\n+  i = num_tokens ();\n+  if (i > n)\n+    return;\n+  while (i-- > 0)\n+    {\n+      tmp = nth_token (i);\n+      /* Never read past these characters: they might separate\n+\t the current input stream from one we save away later.  */\n+      if (tmp->yychar == '{' || tmp->yychar == ':' || tmp->yychar == ';')\n+\tgoto pad_tokens;\n+    }\n+\n+  while (num_tokens() <= n)\n+    {\n+      obstack_blank(&token_obstack,sizeof (struct token));\n+      tmp = ((struct token *)obstack_next_free (&token_obstack))-1;\n+      tmp->yychar = real_yylex();\n+      tmp->end_of_file = end_of_file;\n+      tmp->yylval = yylval;\n+      end_of_file = 0;\n+      if (tmp->yychar == '{'\n+\t  || tmp->yychar == ':'\n+\t  || tmp->yychar == ';')\n+\t{\n+\tpad_tokens:\n+\t  while (num_tokens () <= n)\n+\t    {\n+\t      obstack_blank(&token_obstack,sizeof (struct token));\n+\t      tmp = ((struct token *)obstack_next_free (&token_obstack))-1;\n+\t      tmp->yychar = EMPTY;\n+\t      tmp->end_of_file = 0;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Create room for N tokens at the front of the fifo.  This is used\n+   to insert new tokens into the stream ahead of the current token.  */\n+\n+static void\n+shift_tokens (n)\n+     int n;\n+{\n+  if (first_token >= n)\n+    first_token -= n;\n+  else\n+    {\n+      int old_token_count = num_tokens ();\n+      char *tmp;\n+\n+      obstack_blank (&token_obstack, (n-first_token) * sizeof (struct token));\n+      if (old_token_count)\n+\t{\n+\t  tmp = (char *)alloca ((num_tokens () + (n-first_token))\n+\t\t\t\t* sizeof (struct token));\n+\t  /* This move does not rely on the system being able to handle\n+\t     overlapping moves.  */\n+\t  bcopy (nth_token (0), tmp, old_token_count * sizeof (struct token));\n+\t  bcopy (tmp, nth_token (n), old_token_count * sizeof (struct token));\n+\t}\n+      first_token = 0;\n+    }\n+}\n+\n+static int\n+probe_obstack (h, obj, nlevels)\n+     struct obstack *h;\n+     tree obj;\n+     unsigned int nlevels;\n+{\n+  register struct _obstack_chunk*  lp;\t/* below addr of any objects in this chunk */\n+  register struct _obstack_chunk*  plp;\t/* point to previous chunk if any */\n+\n+  lp = (h)->chunk;\n+  /* We use >= rather than > since the object cannot be exactly at\n+     the beginning of the chunk but might be an empty object exactly\n+     at the end of an adjacent chunk. */\n+  for (; nlevels != 0 && lp != 0 && ((tree)lp >= obj || (tree)lp->limit < obj);\n+       nlevels -= 1)\n+    {\n+      plp = lp->prev;\n+      lp = plp;      \n+    }\n+  return nlevels != 0 && lp != 0;\n+}\n+\n+/* from cp-lex.c: */\n+/* Value is 1 if we should try to make the next identifier look like a\n+   typename (when it may be a local variable or a class variable).\n+   Value is 0 if we treat this name in a default fashion.\n+   Value is -1 if we must not see a type name.  */\n+extern int looking_for_typename;\n+\n+extern struct obstack *current_obstack, *saveable_obstack;\n+\n+int\n+yylex()\n+{\n+  struct token tmp_token;\n+  tree trrr;\n+\n+ retry:\n+#ifdef SPEW_DEBUG\n+  if (spew_debug)\n+  {\n+    yylex_ctr ++;\n+    fprintf(stderr, \"\\t\\t## %d ##\",yylex_ctr);\n+  }\n+#endif\n+  \n+  /* This is a kludge for recognizing nested types in templates */\n+  if (template_type_seen_before_scope)\n+    {\n+      shift_tokens (2);\t\t/* Sync in hack_more_ids (yes, it's ugly) */\n+      nth_token (1)->yychar = SCOPE;\n+      yylval.ttype = hack_more_ids (0, template_type_seen_before_scope);\n+      template_type_seen_before_scope = 0;\n+      if (!yylval.ttype)\n+\t{\n+\t  /* Sync back again, leaving SCOPE on the token stream, because we\n+\t   * failed to substitute the original SCOPE token with a\n+\t   * SCOPED_TYPENAME.  See rule \"template_type\" in cp-parse.y */\n+\t  consume_token ();\n+\t}\n+      else\n+\t{\n+\t  tree t = TREE_TYPE(yylval.ttype);\n+\t  if (TREE_CODE(yylval.ttype) == SCOPE_REF && \n+\t\tt && TREE_CODE(t) == UNINSTANTIATED_P_TYPE)\n+\t    yychar = SCOPED_NAME;\n+\t  else\n+\t    yychar = SCOPED_TYPENAME;\n+#ifdef SPEW_DEBUG    \n+\t  if (spew_debug)\n+\t    debug_yychar(yychar);\n+#endif\n+\t  return yychar;\n+\t}\n+    }\n+\n+  /* if we've got tokens, send them */\n+  if (num_tokens())\n+    {\n+      tmp_token= *nth_token(0);\n+\n+      /* TMP_TOKEN.YYLVAL.TTYPE may have been allocated on the wrong obstack.\n+\t If we don't find it in CURRENT_OBSTACK's current or immediately\n+\t previous chunk, assume it was and copy it to the current obstack.  */\n+      if ((tmp_token.yychar == CONSTANT\n+\t   || tmp_token.yychar == STRING)\n+\t  && ! TREE_PERMANENT (tmp_token.yylval.ttype)\n+\t  && ! probe_obstack (current_obstack, tmp_token.yylval.ttype, 2)\n+\t  && ! probe_obstack (saveable_obstack, tmp_token.yylval.ttype, 2))\n+\ttmp_token.yylval.ttype = copy_node (tmp_token.yylval.ttype);\n+    }\n+  else\n+    {\n+      /* if not, grab the next one and think about it */\n+      tmp_token.yychar = real_yylex ();\n+      tmp_token.yylval = yylval;\n+      tmp_token.end_of_file = end_of_file;\n+      add_token(&tmp_token);\n+    }\n+\n+  /* many tokens just need to be returned. At first glance, all we\n+   * have to do is send them back up, but some of them are needed to\n+   * figure out local context. */\n+  switch(tmp_token.yychar)\n+    {\n+    case EMPTY:\n+      /* This is a lexical no-op.  */\n+      consume_token ();\n+#ifdef SPEW_DEBUG    \n+      if (spew_debug)\n+\tdebug_yychar (tmp_token.yychar);\n+#endif\n+      goto retry;\n+\n+    case IDENTIFIER:\n+      /* Note: this calls arbitrate_lookup.  */\n+      trrr = lookup_name (tmp_token.yylval.ttype, -2);\n+      if (trrr)\n+\t{\n+\t  tmp_token.yychar = identifier_type (trrr);\n+\t  switch (tmp_token.yychar)\n+\t    {\n+\t    case TYPENAME:\n+\t      lastiddecl = identifier_typedecl_value (tmp_token.yylval.ttype);\n+\t      if (lastiddecl == NULL_TREE)\n+\t\tlastiddecl = trrr;\n+\t      break;\n+\t    case IDENTIFIER:\n+\t      lastiddecl = trrr;\n+\t      break;\n+\t    case PTYPENAME:\n+\t      /* This is for cases like\n+\t\t    template<class A> X<A>::operator[] ...\n+\t\t since \"X\" is (presumably) a PTYPENAME; we might want to\n+\t\t avoid seeing the entire thing as a type name, but X<A>\n+\t\t must be one.\n+\n+\t\t It might not work right if the thing after the ::\n+\t\t can be a typename nested in X<A>, but I don't think the\n+\t\t PT code would be up to dealing with that anyways.  --KR  */\n+\t      if (looking_for_typename == -1)\n+\t\t{\n+\t\t  scan_tokens (2);\n+\t\t  if (nth_token(1)->yychar == '<')\n+\t\t    looking_for_typename = 0;\n+\t\t}\n+\t      break;\n+\t    default:\n+\t      my_friendly_abort (101);\n+\t    }\n+\t}\n+      else\n+\tlastiddecl = trrr;\n+      /* and fall through to... */\n+    case TYPENAME:\n+    case PTYPENAME:\n+      /* if (new_token) add_token (&tmp_token); */\n+      *nth_token(0) = tmp_token;\n+      tmp_token = frob_identifier ();\n+      if (looking_for_typename < 0)\n+\t{\n+\t  tmp_token.yychar = IDENTIFIER;\n+\t  lastiddecl = 0;\n+\t  looking_for_typename = 0;\n+\t}\n+      else if (lastiddecl && TREE_CODE (lastiddecl) == TYPE_DECL)\n+\t{\n+\t  scan_tokens (2);\n+\t  if (nth_token(0)->yychar == IDENTIFIER\n+\t      && nth_token (1)->yychar != SCOPE)\n+\t    looking_for_typename = -1;\n+\t  else\n+\t    looking_for_typename = 0;\n+\t  goto finish_typename_processing;\n+\t}\n+      else\n+\tlooking_for_typename = 0;\n+      break;\n+\n+    case SCSPEC:\n+      /* do_aggr needs to check if the previous token was RID_FRIEND,\n+\t so just increment first_token instead of calling consume_token. */\n+      first_token++;\n+      goto finish_typename_processing;\n+    case TYPESPEC:\n+      consume_token ();\n+    finish_typename_processing:\n+      /* Now see if we should insert a START_DECLARATOR token.\n+         Here are the cases caught:\n+\n+\t typespec ( * ID ) (\t// ptr to function\n+\t typespec ( & ID ) (\t// ref to function\n+\t typespec ( * ID ) [\t// array of pointers\n+\t typespec ( & ID ) [\t// array of references\n+\n+\t This is a terrible kludge.  */\n+\n+      scan_tokens (2);\n+      if (nth_token (0)->yychar == '('\n+\t  && (nth_token (1)->yychar == '*'\n+\t      || nth_token (1)->yychar == '&'))\n+\t{\n+\t  scan_tokens (5);\n+\t  if (nth_token (3)->yychar == ')'\n+\t      && (nth_token (4)->yychar == '('\n+\t\t  || nth_token (4)->yychar == '['\n+\t\t  || nth_token (4)->yychar == LEFT_RIGHT)\n+\t      && (nth_token (2)->yychar == IDENTIFIER\n+\t\t  || nth_token (2)->yychar == TYPENAME))\n+\t    {\n+\t      shift_tokens (1);\n+\t      nth_token (0)->yychar = START_DECLARATOR;\n+\t    }\n+\t}\n+      /* Extend to handle:\n+\n+\t typespec (ID::* qf)(   // ptr to member function\n+\t typespec (ID::* qf)[   // array of ptr to member functions\n+\n+\t */\n+      if (nth_token (0)->yychar == '('\n+\t  && (nth_token (1)->yychar == IDENTIFIER\n+\t      || nth_token (1)->yychar == TYPENAME))\n+\t{\n+\t  scan_tokens (7);\n+\t  if (nth_token (2)->yychar == SCOPE\n+\t      && nth_token (3)->yychar == '*'\n+\t      && (nth_token (4)->yychar == IDENTIFIER\n+\t\t  || nth_token (4)->yychar == TYPENAME)\n+\t      && nth_token (5)->yychar == ')'\n+\t      && (nth_token (6)->yychar == '('\n+\t\t  || nth_token (6)->yychar == '['\n+\t\t  || nth_token (6)->yychar == LEFT_RIGHT))\n+\t    {\n+\t      shift_tokens (1);\n+\t      nth_token (0)->yychar = START_DECLARATOR;\n+\t    }\n+\t}\n+      break;\n+\n+#if 0\n+    case '(':\n+      /* Handle casts.  We are looking for one of:\n+         `( TYPENAME' followed by `)', or\n+\t `( TYPENAME *' followed by one of `[,*,&,)', or\n+\t `( TYPENAME &' followed by one of `[,*,&,)', or\n+\t `( TYPENAME [' followed by `]'.  We are punting\n+\t generality on scanning casts to array types.  */\n+      scan_tokens (4);\n+      if (nth_token (1)->yychar == IDENTIFIER)\n+\t{\n+\t  tree type = identifier_typedecl_value (nth_token (1)->yylval.ttype);\n+\t  if (type)\n+\t    switch (nth_token (2)->yychar)\n+\t      {\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t}\n+      break;\n+\n+    case SCOPE:\n+      /* if (new_token) add_token (&tmp_token); */\n+      *nth_token(0) = tmp_token;\n+      tmp_token = hack_scope ();\n+      break;\n+#endif\n+\n+    case AGGR:\n+      *nth_token(0) = tmp_token;\n+      do_aggr ();\n+      /* fall through to output... */\n+    case ENUM:\n+      /* Set this again, in case we are rescanning.  */\n+      looking_for_typename = 1;\n+      /* fall through... */\n+    default:\n+#ifdef SPEW_DEBUG    \n+      if (spew_debug)\n+\tdebug_yychar(tmp_token.yychar);\n+#endif\n+      consume_token();\n+      yylval = tmp_token.yylval;\n+      yychar = tmp_token.yychar;\n+      end_of_file = tmp_token.end_of_file;\n+      return tmp_token.yychar;\n+    }\n+\n+  if (tmp_token.yychar == SCOPED_TYPENAME)\n+    {\n+#if 0\n+      tree t2 = resolve_scope_to_name (NULL_TREE, tmp_token.yylval.ttype);\n+      if (t2 != NULL_TREE)\n+\t{\n+\t  tmp_token.yylval.ttype = t2;\n+\t  tmp_token.yychar = TYPENAME;\n+\t}\n+      else\n+\t{\n+\t  /* unwind? */\n+\t}\n+    }\n+  else\n+    {\n+      /* couldn't get here, as is... */\n+#endif\n+      tmp_token.yychar = TYPENAME;\n+    }\n+\n+  yylval = tmp_token.yylval;\n+  yychar = tmp_token.yychar;\n+  end_of_file = tmp_token.end_of_file;\n+#ifdef SPEW_DEBUG    \n+  if (spew_debug)\n+    debug_yychar(yychar);\n+#endif\n+/*  consume_token(); */ /* already eaten by frob_identifier?... */\n+  return yychar;\n+}\n+\n+/* token[0] == AGGR (struct/union/enum)\n+ * Thus, token[1] is either a TYPENAME or a TYPENAME_DEFN.\n+ * If token[2] == '{' or ':' then it's TYPENAME_DEFN.\n+ * It's also a definition if it's a forward declaration (as in 'struct Foo;')\n+ * which we can tell lf token[2] == ';' *and* token[-1] != FRIEND.\n+ */\n+static int\n+do_aggr ()\n+{\n+  int yc1, yc2;\n+  \n+  scan_tokens (2);\n+  yc1 = nth_token (1)->yychar;\n+  if (yc1 != TYPENAME && yc1 != IDENTIFIER && yc1 != PTYPENAME)\n+    return 0;\n+  yc2 = nth_token (2)->yychar;\n+  if (yc2 == ';')\n+    {\n+      /* It's a forward declaration iff we were not preceded by 'friend'. */\n+      if (first_token > 0 && nth_token (-1)->yychar == SCSPEC\n+\t  && nth_token (-1)->yylval.ttype == ridpointers[(int) RID_FRIEND])\n+\treturn 0;\n+    }\n+  else if (yc2 != '{' && yc2 != ':')\n+    return 0;\n+\n+  switch (yc1)\n+    {\n+    case TYPENAME:\n+      nth_token (1)->yychar = TYPENAME_DEFN;\n+      break;\n+    case PTYPENAME:\n+      nth_token (1)->yychar = PTYPENAME_DEFN;\n+      break;\n+    case IDENTIFIER:\n+      nth_token (1)->yychar = IDENTIFIER_DEFN;\n+      break;\n+    default:\n+      my_friendly_abort (102);\n+    }\n+  return 0;\n+}  \n+\n+static struct token\n+frob_identifier ()\n+{\n+  /* we could have a type, if it is followed by :: (if so, suck it all up); */\n+  /* we could have a ptypename; */\n+  /* we could have a normal identifier. */\n+  tree t1;\n+  struct token rt;\n+  \n+  scan_tokens(1);\n+  rt = *nth_token(0);\n+\n+#if 0\n+  if (nth_token(1)->yychar == '<')\n+    {\n+      t1 = hack_ptype();\t/* suck up the whole thing */\n+      if (t1)\n+\t{\n+\t  rt.yylval.ttype = t1;\n+\t  rt.yychar = TYPENAME;\n+\t  *nth_token(0) = rt;\n+\t}\n+      /* else fall out bottom */\n+    }\t\n+#endif\n+\n+  if (nth_token(1)->yychar == SCOPE)\n+    {\n+#if 0\n+      t1 = hack_more_ids(0);\n+      if (t1 && TREE_CODE(t1) == SCOPE_REF)\n+#else\n+      t1 = hack_more_ids(0, nth_token (0)->yylval.ttype);\n+      if (t1)\n+#endif\n+\t{\n+\t  rt.yylval.ttype = t1;\n+\t  rt.yychar = SCOPED_TYPENAME ;\n+\t  return rt;\n+\t}\n+      else\n+\t{\n+\t  /* deal with types (enums?) in classes... */\n+\t  struct token *tok;\n+\t  tree ta, tb;\n+\t  scan_tokens(3);\n+\n+\t  /* Have to check for a type conversion operator\n+\t     to a nested type.  */\n+\t  if (nth_token (2)->yychar == OPERATOR)\n+\t    tok = nth_token (3);\n+\t  else\n+\t    tok = nth_token(2);\n+\n+\t  if (tok->yychar == IDENTIFIER || tok->yychar == TYPENAME)\n+\t    {\n+\t      ta = build_parse_node (SCOPE_REF,\n+\t\t\t\t     nth_token(0)->yylval.ttype,\n+\t\t\t\t     tok->yylval.ttype);\n+\t      tb = resolve_scope_to_name (NULL_TREE, ta);\n+\n+\t      if (tb != NULL_TREE)\n+\t\t{\n+\t\t  if (nth_token (2)->yychar == OPERATOR)\n+\t\t    {\n+\t\t      /* Have to keep these tokens around\n+\t\t\t so we can finish parsing the declaration.\n+\t\t\t What do we do for\n+\n+\t\t\t int foo::operator bar::baz (); \n+\n+\t\t\t where bar is a nested class in foo?  */\n+\t\t      nth_token (3)->yychar = TYPENAME;\n+\t\t      nth_token (3)->yylval.ttype = tb;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      consume_token (); /* base type */\n+\t\t      consume_token (); /* SCOPE */\n+\t\t      consume_token (); /* member type */\n+\t\t      rt.yychar = TYPENAME;\n+\t\t      rt.yylval.ttype = tb;\n+\t\t      rt.end_of_file = tok->end_of_file;\n+\t\t      return rt;\n+\t\t    }\n+\t\t  \n+\t\t}\n+\t    }      \n+\t  /* else fall out bottom */\n+\t}\n+    }\n+\t     \n+  consume_token();\n+  return rt;\n+}\n+\n+/* When this function is called, nth_token(0) is the current\n+   token we are scanning.  This means that the next token we'll\n+   scan is nth_token (1).  Usually the next token we'll scan\n+   is nth_token (0) (and the current token is in [yylval,yychar]).  */\n+tree\n+arbitrate_lookup (name, exp_decl, type_decl)\n+     tree name, exp_decl, type_decl;\n+{\n+  int ch;\n+  tree t;\n+  char *assume;\n+\n+  scan_tokens (3);\n+  ch = nth_token (1)->yychar;\n+\n+  switch (ch)\n+    {\n+    case '(':\n+    case LEFT_RIGHT:\n+      /* If we guessed wrong here, `build_functional_cast' can fix it.  */\n+      return type_decl;\n+\n+    case '=':\n+      if (global_bindings_p ())\n+\t/* Probably a default parameter.  */\n+\treturn type_decl;\n+      /* Probably not an initialization.  */\n+      return exp_decl;\n+\n+    case '[':\n+      /* This needs special help because an expression inside the\n+\t brackets means nothing.  */\n+      {\n+\tint i;\n+\n+\tfor (i = 0; i < 42; i++)\n+\t  {\n+\t    int ith_yychar;\n+\n+\t    scan_tokens (3+i);\n+\t    ith_yychar = nth_token (2+i)->yychar;\n+\n+\t    /* If we hit an undefined identifier, assume\n+\t       the decl in arbitration is its type specifier.  */\n+\t    if (ith_yychar == IDENTIFIER\n+\t\t&& lookup_name (nth_token (2+i)->yylval.ttype, 0) == 0)\n+\t      return type_decl;\n+\t    else if (ith_yychar == ']')\n+\t      {\n+\t\t/* There are only a few things we expect after a ']'\n+\t\t   in a declarator.  */\n+\t\ti += 1;\n+\t\tscan_tokens (4+i);\n+\t\tith_yychar = nth_token (2+i)->yychar;\n+\n+\t\t/* These are inconclusive.  */\n+\t\tif (ith_yychar == LEFT_RIGHT\n+\t\t    || ith_yychar == '('\n+\t\t    || ith_yychar == '['\n+\t\t    || ith_yychar == ',')\n+\t\t  continue;\n+\t\t/* stmt or decl?  We'll probably never know.  */\n+\t\telse if (ith_yychar == ';')\n+\t\t  goto warn_ambiguous;\n+\n+\t\tif (ith_yychar == '=')\n+\t\t  {\n+\t\t    if (nth_token (3+i)->yychar == '{')\n+\t\t      return type_decl;\n+\t\t    continue;\n+\t\t  }\n+\n+\t\t/* Whatever it is, it looks like we're processing an expr.  */\n+\t\treturn exp_decl;\n+\t      }\n+\t  }\n+\tgoto warn_ambiguous;\n+      }\n+\n+    case ',':\n+    case ';':\n+    case '&':\n+    case '<':\n+    case '*':\n+    case ']':\n+    case ')':\n+    case '>':\n+      /* see if the next token looks like it wants to be part\n+\t of a declaration list or an expression list.  */\n+      {\n+\tint i;\n+\n+\t/* Some heuristics: if we are inside a function definition,\n+\t   prefer the local declaration.  */\n+\tif (! global_bindings_p ())\n+\t  {\n+\t    if (IDENTIFIER_LOCAL_VALUE (name) == exp_decl)\n+\t      return exp_decl;\n+\t    if (IDENTIFIER_LOCAL_VALUE (name) != type_decl\n+\t\t&& IDENTIFIER_CLASS_VALUE (name) == exp_decl)\n+\t      return exp_decl;\n+\t  }\n+\t/* If these symbols follow in a list, we know it's a list of\n+\t   expressions.  */\n+\tif (follows_identifier[nth_token (2)->yychar])\n+\t  return exp_decl;\n+\n+\t/* If we see a id&, or id&) the we are probably in an argument list. */\n+\tif (ch=='&'\n+\t    && (nth_token (2)->yychar == ',' || nth_token (2)->yychar == ')'))\n+\t  return type_decl;\n+\n+\t/* Look for the first identifier or other distinguishing token\n+\t   we find in the next several tokens.  */\n+\tfor (i = 0; i < 42; i++)\n+\t  {\n+\t    int ith_yychar;\n+\n+\t    scan_tokens (3+i);\n+\t    ith_yychar = nth_token (2+i)->yychar;\n+\n+\t    if (ith_yychar == IDENTIFIER)\n+\t      {\n+\t\ttree as_type = lookup_name (nth_token (2+i)->yylval.ttype, 1);\n+\t\tif (as_type && TREE_CODE (as_type) != TYPE_DECL)\n+\t\t  return exp_decl;\n+\t\t/* An undeclared identifier or a typename means we're\n+\t\t   probably looking at a typename.  */\n+\t\treturn type_decl;\n+\t      }\n+\t    else if (ith_yychar == EMPTY\n+\t\t     || follows_identifier[ith_yychar])\n+\t      return exp_decl;\n+\t    else if (follows_typename[ith_yychar])\n+\t      return type_decl;\n+\t    /* stmt or decl?  We'll probably never know.  */\n+\t    else if (ith_yychar == ';')\n+\t      goto warn_ambiguous;\n+\t  }\n+\tgoto warn_ambiguous;\n+      }\n+\n+    default:\n+      if (follows_identifier[ch])\n+\treturn exp_decl;\n+      if (follows_typename[ch])\n+\treturn type_decl;\n+\n+      /* Fall through...  */\n+    warn_ambiguous:\n+      if (ch == '[')\n+\t{\n+\t  assume = \"expression\";\n+\t  t = exp_decl;\n+\t}\n+      else\n+\t{\n+\t  assume = \"type\";\n+\t  t = type_decl;\n+\t}\n+\n+      warning (\"name `%s' could be type or expression; compiler assuming %s\",\n+\t       IDENTIFIER_POINTER (DECL_NAME (t)), assume);\n+      return t;\n+    }\n+}\n+\n+/* now returns decl_node */\n+\n+#if 0\n+static tree\n+hack_ptype()\n+{\n+  /* when we get here, we know that [0] is a ptype and [1] is '<'.\n+   * now we loop over simple parameters. */\n+  struct token this_param;\n+  int n = 2;\n+  tree tplist = 0;\n+  tree tc;\n+  scan_tokens(n+1);\n+  \n+  while((this_param = *nth_token(n)).yychar != '>')\n+    {\n+      /* if it is a type, add it to the list */\n+      tree thistype;\n+    \n+      switch(this_param.yychar)\n+\t{\n+\tcase IDENTIFIER:\n+\tcase TYPENAME:\n+\tcase TYPESPEC:\n+\t  break;\n+\tdefault:\n+\t  return 0;\n+\t}\n+\n+      thistype = this_param.yylval.ttype;\n+      thistype = lookup_name(thistype, 1);\n+      thistype = TREE_TYPE (thistype);\n+        \n+      if (tplist)\n+\ttplist = chainon (tplist, build_tree_list (NULL_TREE, thistype));\n+      else\n+\ttplist = build_tree_list(NULL_TREE, thistype);\n+    \n+    \n+      /* then suck up the comma */\n+      n++;\n+      scan_tokens(n+1);\n+      this_param = *nth_token(n);\n+      if (this_param.yychar == ',')\n+\t{\n+\t  n++;\n+\t  scan_tokens(n+1);\n+\t  continue;\n+\t}\n+      if (this_param.yychar == '>')\n+\tbreak;\n+      return 0;\n+    }\n+\n+  /* once we're done, lookup_template_class -> identifier */\n+  tc = lookup_template_class (nth_token(0)->yylval.ttype,tplist);\n+  /* then lookup_name on that to get a type, if there is one */\n+  tc = lookup_name (tc, 1);\n+  if (tc)\n+    {\n+      int i;\n+      /* don't actually eat the trailing '>'... we can replace it! */\n+      for (i=0; i<n; i++)\n+\tconsume_token();\n+      /*    IDENTIFIER_TYPE_VALUE (DECL_NAME (tc)) = */\n+      return DECL_NAME (tc);\n+    }\n+  return NULL_TREE;\n+}\n+#endif\n+\n+#if 0\n+static tree\n+hack_more_ids (n)\n+     int n;\n+{\n+  /*\n+   * The recursion should probably do consume_tokens(), since once we've started\n+   * down an IDENTIFIER SCOPE ... chain, we don't need to back-track - we just\n+   * get as much as we can, make SCOPE_REF's out of it, and return it.\n+   */\n+  struct token this_iter, this2_iter;\n+  int tmp_y;\n+  \n+  scan_tokens(n+1);\n+  this_iter = *nth_token(n);\n+\n+  tmp_y = nth_token(n)->yychar;\n+  if (tmp_y == IDENTIFIER || tmp_y == TYPENAME)\n+    {\n+      scan_tokens(n+2+2);\n+      if (nth_token(n+1)->yychar == SCOPE)\n+\t{\n+\t  if (nth_token(n+1+2)->yychar == SCOPE)\n+\t    {\n+\t      tree hmi;\n+\t\n+\t      consume_token();\t/* last IDENTIFIER (this_iter) */\n+\t      consume_token();\t/* last SCOPE */\n+\t      this2_iter = *nth_token(n);\n+\t\n+\t      hmi = hack_more_ids (n);\n+\t\n+\t      if (hmi)\n+\t\treturn build_parse_node (SCOPE_REF, this_iter.yylval.ttype, hmi);\n+\t      consume_token(); /* last IDENTIFIER (this2_iter) */\n+\t      return build_parse_node (SCOPE_REF, this_iter.yylval.ttype,\n+\t\t\t\t       this2_iter.yylval.ttype);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* consume_token();\t*/\t/* last IDENTIFIER */\n+\t      /* leave whatever else we got */\n+\t      /* return this_iter.yylval.ttype; */\n+\t      return NULL_TREE;\n+\t    }\n+\t}\n+    }\n+  return NULL_TREE;\t\t/* @@ may need to backtrack */\n+}\n+#else\n+/* niklas@appli.se says:  I didn't understand how the code above was intended\n+ * to work, so I rewrote it (also changed the interface a bit).  This code\n+ * dives down an IDENTIFIER/TYPENAME SCOPE ... chain as long as the parsed\n+ * type prefix constitutes recognizable (by resolve_scope_to_name) types.\n+ * Interface changed like this:\n+ * 1. Takes an extra argument containing the name of the the type recognized\n+ *    so far.\n+ * 2. Now returns the name of the type instead of a SCOPE_REF. */\n+static tree\n+hack_more_ids(n, outer)\n+  int n;\n+  tree outer;\n+{\n+  int ch;\n+  tree type, val, inner, outer_t;\n+\n+  scan_tokens (n + 2);\n+  if (nth_token (n + 1)->yychar != SCOPE\n+      || ((ch = nth_token (n + 2)->yychar) != IDENTIFIER && ch != TYPENAME))\n+    return NULL_TREE;\n+\n+  inner = nth_token(n+2)->yylval.ttype;\n+  val = build_parse_node (SCOPE_REF, outer, inner);\n+  outer_t = TREE_TYPE(outer);\n+  if (outer_t && TREE_CODE(outer_t) == UNINSTANTIATED_P_TYPE)\n+    {\n+      tree t = make_lang_type (UNINSTANTIATED_P_TYPE);\n+      tree id = inner;\n+      tree d = build_lang_decl (TYPE_DECL, id, t);\n+\n+      TYPE_NAME (t) = d;\n+      TYPE_VALUES (t) = TYPE_VALUES(outer_t);\n+      TYPE_CONTEXT(t) = outer_t;\n+/*\n+      pushdecl_top_level (d);\n+*/\n+      pushdecl(d);\n+\n+      type = val;\n+      TREE_TYPE(type) = t;\n+    }\n+  else\n+    {\n+      type = resolve_scope_to_name (NULL_TREE, val);\n+      if (type == NULL_TREE)\n+        return NULL_TREE;\n+    }\n+  consume_token ();\n+  consume_token ();\n+  val = hack_more_ids (n, type);\n+  if (! val)\n+    consume_token ();\n+  return val ? val : type;\n+}\n+#endif\n+\n+#if 0\n+static struct token\n+hack_scope ()\n+{\n+  /* we've got a :: - what follows is either a global var or a type. */\n+  /* hmm, template names can be in the global scope too... */\n+  tree t1;\n+  struct token rt;\n+  \n+  scan_tokens(1);\n+  if (nth_token(1)->yychar == IDENTIFIER)\n+    {\n+      /* @@ this is probably not right, but doesn't get hit yet */\n+      t1 = build_parse_node (SCOPE_REF,\n+\t\t\t     NULL_TREE, /* to get \"global\" scope */\n+\t\t\t     hack_more_ids(0)); /* do some prefetching */\n+      rt.yylval.ttype = t1;\n+      rt.yychar =\t\t/*SCOPED_*/TYPENAME;\n+      return rt;\n+    }\n+  else\n+    {\n+      rt = *nth_token(0);\n+      consume_token();\n+      return rt;\n+    }\n+}\n+#endif\n+  \n+/*\n+ * Generations:\n+ * \t\n+ * PINST: PTYPE { saved_arg_count = arg_count($1) }\n+ *        '<' { arg_c = 0; } PARGS '>'\n+ *        ;\n+ * PARG: TYPE\n+ *       | VALUE\n+ *       ;\n+ * (of course the arg counting doesn't work for recursion... Do it right.)\n+ * PARGS: PARG { assert(arg_c == saved_arg_count); }\n+ *        | PARG ',' PARGS\t{ arg_c++; }\n+ *        ;\n+ * ATYPE: PINST\n+ *        | TYPEID\n+ *        ;\n+ * TYPE: ATYPE\n+ *       | ATYPE { basetype = $1; } '::' TYPEKIDS\n+ *       ;\n+ * TYPEKIDS: TYPE { assert ($1 is a member of basetype); }\n+ * \t  | TYPEKIDS { basetype += $1} TYPE { assert( $3 is in basetype ); }\n+ * \t  ;\n+ *\n+ *\n+ * state0: ; ATYPE\n+ * \tTYPE '<': ac = args($0), base = CALL state1, state3\t\n+ * \tTYPE '::': base=$0, state3\n+ * \telse return TYPE\n+ * state1: ; begin PARGS\n+ * \tif(ac < list length) punt\n+ * \tPARG \",\": add to list, state1\n+ * \tPARG \">\": add to list, return\n+ * \telse unravel\n+ * state3: ; begin TYPEKIDS\n+ * \tTYPE: \n+ */\n+  \n+  \n+#ifdef SPEW_DEBUG    \n+/* debug_yychar takes a yychar (token number) value and prints its name. */\n+static int\n+debug_yychar (yy)\n+     int yy;\n+{\n+  /* In cp-parse.y: */\n+  extern char *debug_yytranslate ();\n+  \n+  int i;\n+  \n+  if(yy<256) {\n+    fprintf (stderr, \"<%d: %c >\\n\", yy, yy);\n+    return 0;\n+  }\n+  fprintf (stderr, \"<%d:%s>\\n\", yy, debug_yytranslate (yy));\n+  return 1;\n+}\n+\n+#endif"}, {"sha": "4edcabcaa344a28af4abef1fe1bc193257cfbbc3", "filename": "gcc/cp/tree.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02"}, {"sha": "e68893736d5f74b9ea82cc76c7e4439371abe9b6", "filename": "gcc/cp/typeck.c", "status": "added", "additions": 6926, "deletions": 0, "changes": 6926, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02"}, {"sha": "8106e58fee0d7f5954564018beff7561a1be9253", "filename": "gcc/cp/typeck2.c", "status": "added", "additions": 1827, "deletions": 0, "changes": 1827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02"}, {"sha": "4a300c2d63583064134d49e1a37c0135a7a18dd8", "filename": "gcc/cp/xref.c", "status": "added", "additions": 827, "deletions": 0, "changes": 827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d08fdba598cf87c3794df53beae1026345ebb02/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=8d08fdba598cf87c3794df53beae1026345ebb02"}]}