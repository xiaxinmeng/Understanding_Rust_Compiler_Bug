{"sha": "f1cfb09f718a2feb4eb9494c8a2c738d12f647d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFjZmIwOWY3MThhMmZlYjRlYjk0OTRjOGEyYzczOGQxMmY2NDdkNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-06-20T17:57:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-06-20T17:57:27Z"}, "message": "Mon Jun 10 20:42:34 CEST 2002  Jan Hubicka  <jh@suse.cz>\n\n\t* basic-block.h: Do not include et-forest.h\n\t(dominance_info): Declare as struct dominance-info.\n\t* cfglayout.c (cleanup_unconditional_jumps): Remove the edge before\n\tdeleting block.\n\t* dominance.c (struct dominance_info): Define.\n\t(BB_NODE, SET_BB_NODE): New macros.\n\t(bb_hash_func, bb_eq_func): Kill.\n\t(calculate_dominace_info, free_dominacne_info, set_immediate_dominator,\n\tnearest_common_dominator, dominated_by_p, recount_dominator,\n\tadd_to_dominance_info, delete_from_dominance_info): update for new\n\trepresentation.\n\t(get_dominated_by, redirect_immediate_dominators): Rewrite using\n\tenumerate_sons.\n\t* ifcvt.c (process_double_test_block, merge_if_block, find_cond_trap,\n\tfind_if_case_1, find_if_case_2): Remove killed blocks from dominance\n\tstructure.\n\n\t* et-forest.h: Update copyright; revamp all function to operate on\n\tnodes\n\t(et_forest_value): Kill.\n\t(et_forest_enumerate_sons, et_forest_node_value): New.\n\t* et-forest.c: Update copyright.\n\t* et-forest.h: Update copyright; revamp all function to operate on\n\tnodes\n\t(et_forest_value): Kill.\n\t(et_forest_enumerate_sons, et_forest_node_value): New.\n\n\tThu Jun  6 22:43:43 CEST 2002  Jan Hubicka  <jh@suse.cz>\n\n\t* basic-block.h: Inlude et-forest.h\n\t(basic_block_def): Kill dominator.\n\t(dominance_info): New type.\n\t(loops): Use dominace_info.\n\t(dominace handling functions): Take dominace_info as argument\n\tinstead of bitmaps.\n\t(create_preheader): Likewise.\n\t* cfg.c (entry_exit_blocks): Kill dominator.\n\t(dump_flow_info): Do not dump dominators.\n\t* cfglayout.c (cleanup_unconditonal_jumps): Delete deleted block from\n\tdominators.\n\t* cfgloop.c (flow_pre_header_find): Use dominacne_info.\n\t(flow_loops_pre_header_scan, make_forwarder_block,\n\tcanonicale_loop_headers, flow_loops_find): Likewise.\n\t* dominance.c: Include error.h\n\t(idoms_to_doms): Kill.\n\t(bb_hash_func, bb_eq_func): New static functions.\n\t(debug_dominace_info): New global function.\n\t(calculate_dominance_info): Use new et forest structure.\n\t(free_dominace_info, get_immediate_dominator, set_immediate_dominator,\n\tget_dominated_by, redirect_immediate_dominators,\n\tnearest_common_dominator, dominated_by_p, verify_dominators,\n\trecount_dominator, iterate_fix_dominators, add_to_dominace_info,\n\tdelete_from_dominance_info): New global functions.\n\t* gcse.c (domnators): CHange to dominance_info.\n\t(alloc_hoist_mem): Do not alloc dominators\n\t(free_code_hoist_mem): Use free_dominance_info.\n\t(compute_code_hoist_data): Use dominance_info.\n\t(hoist_code): Likewise.\n\t* ifcvt.c (post_dominators): Likewise.\n\t(find_if_case_2, if_convert): Likewise.\n\t* predict.c (process_note_predictions, process_note_prediction,\n\testimate-probability): Likewise.\n\t* sched-rgn.c (find_rgns, init_regions): Likewise.\n\t* ssa-dce.c (find_all_control_dependences, fint_control_depemndence,\n\tfind_pdom, delete_insn_bb, ssa_eliminate_dead_code): Likewise.\n\t* ssa.c (compute_dominance_frontiers_1, rename_block, rename_registers,\n\tfind_evaluations, convert_to_ssa): Likewise.\n\t* ssa.h (compute_dominance_frontiers): Likewise.\n\n\tThu Jun  6 22:57:34 CEST 2002  Pavel Nejedly <bim@atrey.karlin.mff.cuni.cz>\n\n\t* Makefile.in (et-forest.c): Add.\n\t* et-forest.c: New file.\n\t* at-forest.h: New file.\n\nFrom-SVN: r54844", "tree": {"sha": "693f50ac9512d1c5e30d62c99ee87e300a094ad0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/693f50ac9512d1c5e30d62c99ee87e300a094ad0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1cfb09f718a2feb4eb9494c8a2c738d12f647d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1cfb09f718a2feb4eb9494c8a2c738d12f647d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1cfb09f718a2feb4eb9494c8a2c738d12f647d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1cfb09f718a2feb4eb9494c8a2c738d12f647d4/comments", "author": null, "committer": null, "parents": [{"sha": "355be0dc5824199cd14e8ee57983332ae2b26226", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355be0dc5824199cd14e8ee57983332ae2b26226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/355be0dc5824199cd14e8ee57983332ae2b26226"}], "stats": {"total": 763, "additions": 763, "deletions": 0}, "files": [{"sha": "4e6216e5d32ff2277ce4fece210f0c134067be37", "filename": "gcc/et-forest.c", "status": "added", "additions": 680, "deletions": 0, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1cfb09f718a2feb4eb9494c8a2c738d12f647d4/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1cfb09f718a2feb4eb9494c8a2c738d12f647d4/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=f1cfb09f718a2feb4eb9494c8a2c738d12f647d4", "patch": "@@ -0,0 +1,680 @@\n+/* ET-trees datastructure implementation.\n+   Contributed by Pavel Nejedly\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If\n+not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+  The ET-forest structure is described in:\n+    D. D. Sleator and R. E. Tarjan. A data structure for dynamic trees.\n+    J.  G'omput. System Sci., 26(3):362 381, 1983.\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"et-forest.h\"\n+\n+struct et_forest_occurrence;\n+typedef struct et_forest_occurrence* et_forest_occurrence_t;\n+\n+/* The ET-forest type.  */\n+struct et_forest\n+{\n+  /* Linked list of nodes is used to destroy the structure.  */\n+  int nnodes;\n+};\n+\n+/* Single occurrence of node in ET-forest.  \n+   A single node may have multiple occurrences.\n+ */\n+struct et_forest_occurrence\n+{\n+  /* Parent in the splay-tree.  */\n+  et_forest_occurrence_t parent;\n+\n+  /* Children in the splay-tree.  */\n+  et_forest_occurrence_t left, right;\n+\n+  /* Counts of vertices in the two splay-subtrees.  */\n+  int count_left, count_right;\n+\n+  /* Next occurrence of this node in the sequence.  */\n+  et_forest_occurrence_t next;\n+\n+  /* The node, which this occurrence is of.  */\n+  et_forest_node_t node;\n+};\n+\n+\n+/* ET-forest node.  */\n+struct et_forest_node\n+{\n+  et_forest_t forest;\n+  void *value;\n+\n+  /* First and last occurrence of this node in the sequence.  */\n+  et_forest_occurrence_t first, last;\n+};\n+\n+\n+static et_forest_occurrence_t splay PARAMS ((et_forest_occurrence_t));\n+static void remove_all_occurrences PARAMS ((et_forest_node_t));\n+static inline et_forest_occurrence_t find_leftmost_node \n+                               PARAMS ((et_forest_occurrence_t));\n+static inline et_forest_occurrence_t find_rightmost_node \n+                               PARAMS ((et_forest_occurrence_t));\n+static int calculate_value PARAMS ((et_forest_occurrence_t));\n+\n+/* Return leftmost node present in the tree roted by OCC.  */\n+static inline et_forest_occurrence_t\n+find_leftmost_node (occ)\n+     et_forest_occurrence_t occ;\n+{\n+  while (occ->left)\n+    occ = occ->left;\n+\n+  return occ;\n+}\n+\n+/* Return rightmost node present in the tree roted by OCC.  */\n+static inline et_forest_occurrence_t\n+find_rightmost_node (occ)\n+     et_forest_occurrence_t occ;\n+{\n+  while (occ->right)\n+    occ = occ->right;\n+  return occ;\n+}\n+\n+\n+/* Operation splay for splay tree structure representing ocuurences.  */\n+static et_forest_occurrence_t\n+splay (node)\n+     et_forest_occurrence_t node;\n+{\n+  et_forest_occurrence_t parent;\n+  et_forest_occurrence_t grandparent;\n+\n+  while (1)\n+    {\n+      parent = node->parent;\n+\n+      if (! parent)\n+\treturn node;  /* node == root.  */\n+\n+      grandparent = parent->parent;\n+\n+      if (! grandparent)\n+\tbreak;\n+\n+      /* Now there are four possible combinations:  */\n+\n+      if (node == parent->left)\n+\t{\n+\t  if (parent == grandparent->left)\n+\t    {\n+\t      et_forest_occurrence_t node1, node2;\n+\t      int count1, count2;\n+\n+\t      node1 = node->right;\n+\t      count1 = node->count_right;\n+\t      node2 = parent->right;\n+\t      count2 = parent->count_right;\n+\n+\t      grandparent->left = node2;\n+\t      grandparent->count_left = count2;\n+\t      if (node2)\n+\t\tnode2->parent = grandparent;\n+\t      parent->left = node1;\n+\t      parent->count_left = count1;\n+\t      if (node1)\n+\t\tnode1->parent = parent;\n+\t      parent->right = grandparent;\n+\t      parent->count_right = count2 + grandparent->count_right + 1;\n+\t      node->right = parent;\n+\t      node->count_right = count1 + parent->count_right + 1;\n+\n+\t      node->parent = grandparent->parent;\n+\t      parent->parent = node;\n+\t      grandparent->parent = parent;\n+\n+\t      if (node->parent)\n+\t\t{\n+\t\t  if (node->parent->left == grandparent)\n+\t\t    node->parent->left = node;\n+\t\t  else\n+\t\t    node->parent->right = node;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* parent == grandparent->right && node == parent->left*/\n+\t      et_forest_occurrence_t node1, node2;\n+\t      int count1, count2;\n+\n+\t      node1 = node->left;\n+\t      count1 = node->count_left;\n+\t      node2 = node->right;\n+\t      count2 = node->count_right;\n+\n+\t      grandparent->right = node1;\n+\t      grandparent->count_right = count1;\n+\t      if (node1)\n+\t\tnode1->parent = grandparent;\n+\t      parent->left = node2;\n+\t      parent->count_left = count2;\n+\t      if (node2)\n+\t\tnode2->parent = parent;\n+\t      node->left = grandparent;\n+\t      node->count_left = grandparent->count_left + count1 + 1;\n+\t      node->right = parent;\n+\t      node->count_right = parent->count_right + count2 + 1;\n+\n+\t      node->parent = grandparent->parent;\n+\t      parent->parent = node;\n+\t      grandparent->parent = node;\n+\n+\t      if (node->parent)\n+\t\t{\n+\t\t  if (node->parent->left == grandparent)\n+\t\t    node->parent->left = node;\n+\t\t  else\n+\t\t    node->parent->right = node;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* node == parent->right.  */\n+\t  if (parent == grandparent->left)\n+\t    {\n+\t      et_forest_occurrence_t node1, node2;\n+\t      int count1, count2;\n+\n+\t      node1 = node->left;\n+\t      count1 = node->count_left;\n+\t      node2 = node->right;\n+\t      count2 = node->count_right;\n+\n+\t      parent->right = node1;\n+\t      parent->count_right = count1;\n+\t      if (node1)\n+\t\tnode1->parent = parent;\n+\t      grandparent->left = node2;\n+\t      grandparent->count_left = count2;\n+\t      if (node2)\n+\t\tnode2->parent = grandparent;\n+\t      node->left = parent;\n+\t      node->count_left = parent->count_left + count1 + 1;\n+\t      node->right = grandparent;\n+\t      node->count_right = grandparent->count_right + count2 + 1;\n+\n+\t      node->parent = grandparent->parent;\n+\t      parent->parent = node;\n+\t      grandparent->parent = node;\n+\n+\t      if (node->parent)\n+\t\t{\n+\t\t  if (node->parent->left == grandparent)\n+\t\t    node->parent->left = node;\n+\t\t  else\n+\t\t    node->parent->right = node;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* parent == grandparent->right && node == parent->right*/\n+\t      et_forest_occurrence_t node1, node2;\n+\t      int count1, count2;\n+\n+\t      node1 = node->left;\n+\t      count1 = node->count_left;\n+\t      node2 = parent->left;\n+\t      count2 = parent->count_left;\n+\n+\t      grandparent->right = node2;\n+\t      grandparent->count_right = count2;\n+\t      if (node2)\n+\t\tnode2->parent = grandparent;\n+\t      parent->right = node1;\n+\t      parent->count_right = count1;\n+\t      if (node1)\n+\t\tnode1->parent = parent;\n+\t      parent->left = grandparent;\n+\t      parent->count_left = count2 + grandparent->count_left + 1;\n+\t      node->left = parent;\n+\t      node->count_left = count1 + parent->count_left + 1;\n+\n+\t      node->parent = grandparent->parent;\n+\t      parent->parent = node;\n+\t      grandparent->parent = parent;\n+\n+\t      if (node->parent)\n+\t\t{\n+\t\t  if (node->parent->left == grandparent)\n+\t\t    node->parent->left = node;\n+\t\t  else\n+\t\t    node->parent->right = node;\n+\t\t}\n+\t    }\n+\t}\n+\t  \n+    }\n+\n+  /* parent == root.  */\n+  /* There are two possible combinations:  */\n+\n+  if (node == parent->left)\n+    {\n+      et_forest_occurrence_t node1;\n+      int count1;\n+      \n+      node1 = node->right;\n+      count1 = node->count_right;\n+\n+      parent->left = node1;\n+      parent->count_left = count1;\n+      if (node1)\n+\tnode1->parent = parent;\n+      node->right = parent;\n+      node->count_right = parent->count_right + 1 + count1;\n+      node->parent = parent->parent;  /* the same as = 0;  */\n+      parent->parent = node;\n+\n+      if (node->parent)\n+\t{\n+\t  if (node->parent->left == parent)\n+\t    node->parent->left = node;\n+\t  else\n+\t    node->parent->right = node;\n+\t}\n+    } \n+  else \n+    {\n+      /* node == parent->right.  */\n+      et_forest_occurrence_t node1;\n+      int count1;\n+      \n+      node1 = node->left;\n+      count1 = node->count_left;\n+\n+      parent->right = node1;\n+      parent->count_right = count1;\n+      if (node1)\n+\tnode1->parent = parent;\n+      node->left = parent;\n+      node->count_left = parent->count_left + 1 + count1;\n+      node->parent = parent->parent;  /* the same as = 0;  */\n+      parent->parent = node;\n+\n+      if (node->parent)\n+\t{\n+\t  if (node->parent->left == parent)\n+\t    node->parent->left = node;\n+\t  else\n+\t    node->parent->right = node;\n+\t}\n+    }\n+\n+  return node;\n+}\n+\n+/* Remove all occurences of the given node before destroying the node.  */\n+static void\n+remove_all_occurrences (forest_node)\n+     et_forest_node_t forest_node;\n+{\n+  et_forest_occurrence_t first = forest_node->first;\n+  et_forest_occurrence_t last = forest_node->last;\n+  et_forest_occurrence_t node;\n+\n+  splay (first);\n+\n+  if (first->left)\n+    first->left->parent = 0;\n+  if (first->right)\n+    first->right->parent = 0;   \n+\n+  if (last != first)\n+    {\n+      splay (last);\n+\n+      if (last->left)\n+\tlast->left->parent = 0;\n+      if (last->right)\n+\tlast->right->parent = 0;\n+    }\n+\n+  if (last->right && first->left) /* actually, first->left would suffice.  */\n+    {\n+      /* Need to join them.  */\n+      et_forest_occurrence_t prev_node, next_node;\n+\n+      prev_node = splay (find_rightmost_node (first->left));\n+      next_node = splay (find_leftmost_node (last->right));\n+      /* prev_node and next_node are consecutive occurencies\n+\t of the same node.  */\n+      if (prev_node->next != next_node)\n+\tabort ();\n+\n+      prev_node->right = next_node->right;\n+      prev_node->count_right = next_node->count_right;\n+      prev_node->next = next_node->next;\n+      if (prev_node->right)\n+\tprev_node->right->parent = prev_node;\n+\n+      if (prev_node->node->last == next_node)\n+\tprev_node->node->last = prev_node;\n+\n+      free (next_node);\n+    }\n+\n+  if (first != last)\n+    {\n+      node = first->next;\n+\n+      while (node != last)\n+\t{\n+\t  et_forest_occurrence_t next_node;\n+\n+\t  splay (node);\n+\n+\t  if (node->left)\n+\t    node->left->parent = 0;\n+\t  if (node->right)\n+\t    node->right->parent = 0;\n+\n+\t  next_node = node->next;\n+\t  free (node);\n+\t  node = next_node;\n+\t}\n+    }\n+\n+  free (first);\n+  if (first != last)\n+    free (last);\n+}\n+\n+/* Calculate ET value of the given node.  */\n+static inline int\n+calculate_value (node)\n+     et_forest_occurrence_t node;\n+{\n+  int value = node->count_left;\n+\n+  while (node->parent)\n+    {\n+      if (node == node->parent->right)\n+\tvalue += node->parent->count_left + 1;\n+\n+      node = node->parent;\n+    }\n+\n+  return value;\n+}\n+\n+\n+\n+\n+/* Create ET-forest structure.  */\n+et_forest_t\n+et_forest_create ()\n+{\n+\n+  et_forest_t forest = xmalloc (sizeof (struct et_forest));\n+\n+  forest->nnodes = 0;\n+  return forest;\n+}\n+\n+\n+\n+/* Deallocate the structure.  */\n+void \n+et_forest_delete (forest)\n+     et_forest_t forest;\n+{\n+  if (forest->nnodes)\n+    abort ();\n+\n+  free (forest);\n+}\n+\n+/* Create new node with VALUE and return the edge.\n+   Return NULL when memory allocation failed.  */\n+et_forest_node_t\n+et_forest_add_node (forest, value)\n+     et_forest_t forest;\n+     void *value;\n+{\n+  /* Create node with one occurrence.  */\n+  et_forest_node_t node;\n+  et_forest_occurrence_t occ;\n+\n+  node = xmalloc (sizeof (struct et_forest_node));\n+  occ = xmalloc (sizeof (struct et_forest_occurrence));\n+\n+  node->first = node->last = occ;\n+  node->value = value;\n+  forest->nnodes++;\n+\n+  occ->node = node;\n+  occ->left = occ->right = occ->parent = 0;\n+  occ->next = 0;\n+  occ->count_left = occ->count_right = 0;\n+  return node;\n+}\n+\n+/* Add new edge to the tree, return 1 if succesfull.\n+   0 indicates that creation of the edge will close the cycle in graph.  */\n+int\n+et_forest_add_edge (forest, parent_node, child_node)\n+     et_forest_t forest ATTRIBUTE_UNUSED;\n+     et_forest_node_t parent_node;\n+     et_forest_node_t child_node;\n+{\n+  et_forest_occurrence_t new_occ, parent_occ, child_occ;\n+\n+  if (! parent_node || ! child_node)\n+    abort ();\n+\n+  parent_occ = parent_node->first;\n+  child_occ = child_node->first;\n+\n+  splay (parent_occ);\n+  splay (child_occ);\n+\n+  if (parent_occ->parent)\n+    return 0; /* Both child and parent are in the same tree.  */\n+\n+  if (child_occ->left)\n+    abort ();  /* child must be root of its containing tree.  */\n+  \n+  new_occ = xmalloc (sizeof (struct et_forest_occurrence));\n+\n+  new_occ->node = parent_node;\n+  new_occ->left = child_occ;\n+  new_occ->count_left = child_occ->count_right + 1; /* count_left is 0.  */\n+  new_occ->right = parent_occ->right;\n+  new_occ->count_right = parent_occ->count_right;\n+  new_occ->parent = parent_occ;\n+  new_occ->next = parent_occ->next;\n+  child_occ->parent = new_occ;\n+  parent_occ->right = new_occ;\n+  parent_occ->count_right = new_occ->count_left + new_occ->count_right + 1;\n+  parent_occ->next = new_occ;\n+  if (new_occ->right)\n+    new_occ->right->parent = new_occ;\n+\n+  if (parent_node->last == parent_occ)\n+    parent_node->last = new_occ;\n+  return 1;\n+}\n+\n+/* Remove NODE from the tree and all connected edges.  */\n+void\n+et_forest_remove_node (forest, node)\n+     et_forest_t forest;\n+     et_forest_node_t node;\n+{\n+  remove_all_occurrences (node);\n+  forest->nnodes--;\n+\n+  free (node);\n+}\n+\n+/* Remove edge from the tree, return 1 if sucesfull,\n+   0 indicates nonexisting edge.  */\n+int\n+et_forest_remove_edge (forest, parent_node, child_node)\n+     et_forest_t forest ATTRIBUTE_UNUSED;\n+     et_forest_node_t parent_node;\n+     et_forest_node_t child_node;\n+{\n+  et_forest_occurrence_t parent_pre_occ, parent_post_occ;\n+\n+  splay (child_node->first);\n+\n+  if (! child_node->first->left)\n+    return 0;\n+\n+  parent_pre_occ = find_rightmost_node (child_node->first->left);\n+  if (parent_pre_occ->node != parent_node)\n+    abort ();\n+\n+  splay (parent_pre_occ);\n+  parent_pre_occ->right->parent = 0;\n+  \n+  parent_post_occ = parent_pre_occ->next;\n+  splay (parent_post_occ);\n+\n+  parent_post_occ->left->parent = 0;\n+\n+  parent_pre_occ->right = parent_post_occ->right;\n+  parent_pre_occ->count_right = parent_post_occ->count_right;\n+  if (parent_post_occ->right)\n+    parent_post_occ->right->parent = parent_pre_occ;\n+\n+  parent_pre_occ->next = parent_post_occ->next;\n+\n+  if (parent_post_occ == parent_node->last)\n+    parent_node->last = parent_pre_occ;\n+\n+  free (parent_post_occ);\n+  return 1;\n+}\n+\n+/* Return the parent of the NODE if any, NULL otherwise.  */\n+et_forest_node_t\n+et_forest_parent (forest, node)\n+     et_forest_t forest ATTRIBUTE_UNUSED;\n+     et_forest_node_t node;\n+{\n+  splay (node->first);\n+\n+  if (node->first->left)\n+    return find_rightmost_node (node->first->left)->node;\n+  else\n+    return 0;\n+}\n+\n+\n+/* Return nearest common ancestor of NODE1 and NODE2.\n+   Return NULL of they are in different trees.  */\n+et_forest_node_t\n+et_forest_common_ancestor (forest, node1, node2)\n+     et_forest_t forest ATTRIBUTE_UNUSED;\n+     et_forest_node_t node1;\n+     et_forest_node_t node2;\n+{\n+  int value1, value2, max_value;\n+  et_forest_node_t ancestor;\n+\n+  if (node1 == node2)\n+    return node1;\n+  \n+  if (! node1 || ! node2)\n+    abort ();\n+\n+  splay (node1->first);\n+  splay (node2->first);\n+\n+  if (! node1->first->parent)  /* The two vertices are in different trees.  */\n+    return 0;\n+\n+  value2 = calculate_value (node2->first);\n+  value1 = calculate_value (node1->first);\n+\n+  if (value1 < value2)\n+    {\n+      ancestor = node1;\n+      max_value = value2;\n+    }\n+  else\n+    {\n+      ancestor = node2;\n+      max_value = value1;\n+    }\n+  \n+  while (calculate_value (ancestor->last) < max_value)\n+    {\n+      /* Find parent node.  */\n+      splay (ancestor->first);\n+      ancestor = find_rightmost_node (ancestor->first->left) ->node;\n+    }\n+\n+  return ancestor;\n+}\n+\n+/* Return the value pointer of node set during it's creation.  */\n+void *\n+et_forest_node_value (forest, node)\n+     et_forest_t forest ATTRIBUTE_UNUSED;\n+     et_forest_node_t node;\n+{\n+  /* Alloc threading NULL as a special node of the forest.  */\n+  if (!node)\n+    return NULL;\n+  return node->value;\n+}\n+\n+/* Find all sons of NODE and store them into ARRAY allocated by the caller.\n+   Return number of nodes found.  */\n+int\n+et_forest_enumerate_sons (forest, node, array)\n+     et_forest_t forest ATTRIBUTE_UNUSED;\n+     et_forest_node_t node;\n+     et_forest_node_t *array;\n+{\n+  int n = 0;\n+  et_forest_occurrence_t occ = node->first, stop = node->last, occ1;\n+\n+  /* Parent is the rightmost node of the left successor.\n+     Look for all occurences having no right succesor\n+     and lookup the sons. */\n+  while (occ != stop)\n+    {\n+      splay (occ);\n+      if (occ->right)\n+\t{\n+          occ1 = find_leftmost_node (occ->right);\n+\t  if (occ1->node->first == occ1)\n+\t    array[n++] = occ1->node;\n+\t}\n+      occ = occ->next;\n+    }\n+  return n;\n+}"}, {"sha": "8f4290c1193e76ba7fac0312d9d6cf4d8c21d316", "filename": "gcc/et-forest.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1cfb09f718a2feb4eb9494c8a2c738d12f647d4/gcc%2Fet-forest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1cfb09f718a2feb4eb9494c8a2c738d12f647d4/gcc%2Fet-forest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.h?ref=f1cfb09f718a2feb4eb9494c8a2c738d12f647d4", "patch": "@@ -0,0 +1,83 @@\n+/* Et-forest data structure implementation.  \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2 of the License, or\n+(at your option) any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+/* This package implements ET forest data structure. Each tree in \n+   the structure maintains a tree structure and offers logarithmic time\n+   for tree operations (insertion and removal of nodes and edges) and\n+   poly-logarithmic time for nearest common ancesto.\n+ \n+   ET tree strores its structue as a sequence of symbols obtained \n+   by dfs(root)\n+\n+   dfs (node) \n+   {\n+     s = node;\n+     for each child c of node do\n+       s = concat (s, c, node);\n+     return s;\n+   }\n+   \n+   For example for tree\n+ \n+            1\n+          / | \\\n+         2  3  4\n+       / |\n+      4  5\n+ \n+   the sequence is 1 2 4 2 5 3 1 3 1 4 1.\n+ \n+   The sequence is stored in a sligtly modified splay tree.\n+   In order to support various types of node values, a hashtable\n+   is used to convert node values to the internal representation.  */\n+\n+#ifndef _ET_TREE_H\n+#define _ET_TREE_H\n+\n+#include <ansidecl.h>\n+#include <stddef.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /* __cplusplus */\n+\n+typedef struct et_forest *et_forest_t;\n+typedef struct et_forest_node *et_forest_node_t;\n+\n+extern et_forest_t et_forest_create PARAMS ((void));\n+\n+extern void et_forest_delete PARAMS ((et_forest_t));\n+\n+extern et_forest_node_t et_forest_add_node PARAMS ((et_forest_t, void *));\n+extern int et_forest_add_edge PARAMS ((et_forest_t, et_forest_node_t, \n+\t\t\t\t\tet_forest_node_t));\n+extern void et_forest_remove_node PARAMS ((et_forest_t, et_forest_node_t));\n+extern int et_forest_remove_edge PARAMS ((et_forest_t, et_forest_node_t,\n+\t\t\t\t\t   et_forest_node_t));\n+extern et_forest_node_t et_forest_parent PARAMS ((et_forest_t, et_forest_node_t));\n+extern et_forest_node_t et_forest_common_ancestor PARAMS ((et_forest_t,\n+\t\t\t\t\t\t\t  et_forest_node_t,\n+\t\t\t\t\t\t\t  et_forest_node_t));\n+extern void * et_forest_node_value PARAMS ((et_forest_t, et_forest_node_t));\n+extern int et_forest_enumerate_sons PARAMS ((et_forest_t, et_forest_node_t,\n+\t\t\t\t\t     et_forest_node_t *));\n+\n+#ifdef __cplusplus\n+}\n+#endif /* __cplusplus */\n+\n+#endif /* _ET_TREE_H */"}]}