{"sha": "309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA5ZGQ4ODVmZjlmNTY5YWVjMTJjYjVlMzI4MWEzYjRkZDczYThlMA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-09-21T15:21:17Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-09-21T15:21:17Z"}, "message": "Add FR30 port.\n\nFrom-SVN: r29549", "tree": {"sha": "06b0a14fcfffb5dbddc89ff6a4883172d092edbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06b0a14fcfffb5dbddc89ff6a4883172d092edbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/comments", "author": null, "committer": null, "parents": [{"sha": "09b5f8bf2f04be2c45f2d1529b0f5b3879f4c0e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09b5f8bf2f04be2c45f2d1529b0f5b3879f4c0e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09b5f8bf2f04be2c45f2d1529b0f5b3879f4c0e5"}], "stats": {"total": 7179, "additions": 7179, "deletions": 0}, "files": [{"sha": "ece5f0d165ebff2dba00f3107d40d612d023681b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "patch": "@@ -1,3 +1,17 @@\n+Tue Sep 21 14:13:27 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* configure.in: Add fr30 target.\n+\t* configure: Regenerate.\n+\t* config/fr30: New directory.\n+\t* config/fr30/crti.asm: New file.\n+\t* config/fr30/fr30.c: New file.\n+\t* config/fr30/crtn.asm: New file.\n+\t* config/fr30/fr30.h: New file.\n+\t* config/fr30/fr30.md: New file.\n+\t* config/fr30/lib1funcs.asm: New file.\n+\t* config/fr30/t-fr30: New file.\n+\t* config/fr30/xm-fr30.h: New file.\n+\n Tue Sep 21 06:45:31 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* flow.c (merge_blocks_move_successor_nojumps): Delete the"}, {"sha": "5b8def8ae13fc5b7e9c8d9094338593789535084", "filename": "gcc/config/fr30/crti.asm", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Fcrti.asm?ref=309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "patch": "@@ -0,0 +1,74 @@\n+# crti.s for ELF\n+\n+#   Copyright (C) 1992, 1998, 1999 Free Software Foundation, Inc.\n+#   Written By David Vinayak Henkel-Wallace, June 1992\n+# \n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+# \n+# In addition to the permissions in the GNU General Public License, the\n+# Free Software Foundation gives you unlimited permission to link the\n+# compiled version of this file with other programs, and to distribute\n+# those programs without any restriction coming from the use of this\n+# file.  (The General Public License restrictions do apply in other\n+# respects; for example, they cover modification of the file, and\n+# distribution when not linked into another program.)\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+# \n+#    As a special exception, if you link this library with files\n+#    compiled with GCC to produce an executable, this does not cause\n+#    the resulting executable to be covered by the GNU General Public License.\n+#    This exception does not however invalidate any other reasons why\n+#    the executable file might be covered by the GNU General Public License.\n+# \n+\n+# This file just make a stack frame for the contents of the .fini and\n+# .init sections.  Users may put any desired instructions in those\n+# sections.\n+\n+\t.file\t\t\"crti.asm\"\n+\n+\t.section\t\".init\"\n+\t.global\t_init\n+\t.type\t_init,#function\n+\t.align\t4\n+_init:\n+\tst\trp, @-r15\n+\tenter\t#4\n+\n+\t# These nops are here to align the end of this code with a 16 byte\n+\t# boundary.  The linker will start inserting code into the .init\n+\t# section at such a boundary.\n+\t\n+\tnop\n+\tnop\n+\tnop\n+\tnop\n+\tnop\n+\tnop\n+\n+\t\n+\t.section\t\".fini\"\n+\t.global\t_fini\n+\t.type\t_fini,#function\n+\t.align\t4\n+_fini:\n+\tst\trp, @-r15\n+\tenter\t#4\n+\tnop\n+\tnop\n+\tnop\n+\tnop\n+\tnop\n+\tnop"}, {"sha": "93b52c2428eadf1250b28414ff8724db64641dba", "filename": "gcc/config/fr30/crtn.asm", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Fcrtn.asm?ref=309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "patch": "@@ -0,0 +1,57 @@\n+# crtn.asm for ELF \n+\n+#   Copyright (C) 1992, 1999 Free Software Foundation, Inc.\n+#   Written By David Vinayak Henkel-Wallace, June 1992\n+# \n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+# \n+# In addition to the permissions in the GNU General Public License, the\n+# Free Software Foundation gives you unlimited permission to link the\n+# compiled version of this file with other programs, and to distribute\n+# those programs without any restriction coming from the use of this\n+# file.  (The General Public License restrictions do apply in other\n+# respects; for example, they cover modification of the file, and\n+# distribution when not linked into another program.)\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+# \n+#    As a special exception, if you link this library with files\n+#    compiled with GCC to produce an executable, this does not cause\n+#    the resulting executable to be covered by the GNU General Public License.\n+#    This exception does not however invalidate any other reasons why\n+#    the executable file might be covered by the GNU General Public License.\n+# \n+\n+# This file just makes sure that the .fini and .init sections do in\n+# fact return.  Users may put any desired instructions in those sections.\n+# This file is the last thing linked into any executable.\n+\n+\t.file\t\t\"crtn.s\"\n+\n+\t.section\t\".init\"\n+\t.align\t\t4\n+\n+\tleave\n+\tld @r15+,rp\n+\tret\n+\n+\t\n+\t.section\t\".fini\"\n+\t.align\t\t4\n+\n+\tleave\n+\tld @r15+,rp\n+\tret\n+\n+# Th-th-th-that is all folks!"}, {"sha": "445a5e1d67db75ca9b0aad5b7836716ecfafcd05", "filename": "gcc/config/fr30/fr30.c", "status": "added", "additions": 899, "deletions": 0, "changes": 899, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "patch": "@@ -0,0 +1,899 @@\n+/*{{{  Introduction */ \n+\n+/* FR30 specific functions.\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Contributed by Cygnus Solutions.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/*}}}*/\n+/*{{{  Includes */ \n+\n+#include <stdio.h>\n+#include <ctype.h>\n+#include <sys/param.h> /* so that MIn and MAX are defined before machmode.h */\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"obstack.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+\n+/*}}}*/\n+/*{{{  Function Prologues & Epilogues */ \n+\n+/* Define the information needed to generate branch and scc insns.  This is\n+   stored from the compare operation.  */\n+\n+struct rtx_def * fr30_compare_op0;\n+struct rtx_def * fr30_compare_op1;\n+\n+/* The FR30 stack looks like this:\n+\n+             Before call                       After call\n+   FP ->|                       |       |                       |\n+        +-----------------------+       +-----------------------+       high \n+        |                       |       |                       |       memory\n+        |  local variables,     |       |  local variables,     |\n+        |  reg save area, etc.  |       |  reg save area, etc.  |\n+        |                       |       |                       |\n+        +-----------------------+       +-----------------------+\n+        |                       |       |                       |\n+        | args to the func that |       |  args to this func.   |\n+        | is being called that  |       |                       |\n+   SP ->| do not fit in regs    |       |                       |\n+        +-----------------------+       +-----------------------+\n+                                        |  args that used to be |  \\\n+                                        | in regs; only created |   |  pretend_size \n+                                   AP-> |   for vararg funcs    |  /  \n+                                        +-----------------------+    \n+                                        |                       |  \\  \n+                                        |  register save area   |   |\n+                                        |                       |   |\n+\t\t\t\t\t+-----------------------+   |  reg_size\n+                                        |    return address     |   | \n+\t\t\t\t\t+-----------------------+   |\n+                                   FP ->|   previous frame ptr  |  /\n+                                        +-----------------------+    \n+                                        |                       |  \\   \n+                                        |  local variables      |   |  var_size \n+                                        |                       |  /  \n+                                        +-----------------------+    \n+                                        |                       |  \\       \n+     low                                |  room for args to     |   |\n+     memory                             |  other funcs called   |   |  args_size     \n+                                        |  from this one        |   |\n+                                   SP ->|                       |  /  \n+                                        +-----------------------+    \n+   \n+   Note, AP is a fake hard register.  It will be eliminated in favour of\n+   SP or FP as appropriate.\n+\n+   Note, Some or all of the stack sections above may be omitted if they \n+   are not needed.  */\n+\n+/* Structure to be filled in by fr30_compute_frame_size() with register\n+   save masks, and offsets for the current function.  */\n+struct fr30_frame_info\n+{\n+  unsigned int total_size;\t/* # Bytes that the entire frame takes up. */\n+  unsigned int pretend_size;\t/* # Bytes we push and pretend caller did. */\n+  unsigned int args_size;\t/* # Bytes that outgoing arguments take up. */\n+  unsigned int reg_size;\t/* # Bytes needed to store regs. */\n+  unsigned int var_size;\t/* # Bytes that variables take up. */\n+  unsigned int frame_size;      /* # Bytes in current frame.  */\n+  unsigned int gmask;\t\t/* Mask of saved registers. */\n+  unsigned int save_fp;\t\t/* Nonzero if frame pointer must be saved. */\n+  unsigned int save_rp;\t\t/* Nonzero if return popinter must be saved. */\n+  int          initialised;\t/* Nonzero if frame size already calculated. */\n+};\n+\n+/* Current frame information calculated by fr30_compute_frame_size().  */\n+static struct fr30_frame_info \tcurrent_frame_info;\n+\n+/* Zero structure to initialize current_frame_info.  */\n+static struct fr30_frame_info \tzero_frame_info;\n+\n+#define FRAME_POINTER_MASK \t(1 << (FRAME_POINTER_REGNUM))\n+#define RETURN_POINTER_MASK \t(1 << (RETURN_POINTER_REGNUM))\n+\n+/* Tell prologue and epilogue if register REGNO should be saved / restored.\n+   The return address and frame pointer are treated separately.\n+   Don't consider them here.  */\n+#define MUST_SAVE_REGISTER(regno)      \\\n+  (   (regno) != RETURN_POINTER_REGNUM \\\n+   && (regno) != FRAME_POINTER_REGNUM  \\\n+   &&   regs_ever_live [regno]         \\\n+   && ! call_used_regs [regno]         )\n+\n+#define MUST_SAVE_FRAME_POINTER\t (regs_ever_live [FRAME_POINTER_REGNUM]  || frame_pointer_needed)\n+#define MUST_SAVE_RETURN_POINTER (regs_ever_live [RETURN_POINTER_REGNUM] || profile_flag)\n+\n+#if UNITS_PER_WORD == 4\n+#define WORD_ALIGN(SIZE) (((SIZE) + 3) & ~3)\n+#endif\n+     \n+/* Returns the number of bytes offset between FROM_REG and TO_REG\n+   for the current function.  As a side effect it fills in the \n+   current_frame_info structure, if the data is available.  */\n+unsigned int\n+fr30_compute_frame_size (from_reg, to_reg)\n+     int from_reg;\n+     int to_reg;\n+{\n+  int \t\tregno;\n+  unsigned int \treturn_value;\n+  unsigned int\tvar_size;\n+  unsigned int\targs_size;\n+  unsigned int\tpretend_size;\n+  unsigned int \treg_size;\n+  unsigned int \tgmask;\n+\n+  var_size\t= WORD_ALIGN (get_frame_size ());\n+  args_size\t= WORD_ALIGN (current_function_outgoing_args_size);\n+  pretend_size\t= current_function_pretend_args_size;\n+\n+  reg_size\t= 0;\n+  gmask\t\t= 0;\n+\n+  /* Calculate space needed for registers.  */\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno ++)\n+    {\n+      if (MUST_SAVE_REGISTER (regno))\n+\t{\n+\t  reg_size += UNITS_PER_WORD;\n+\t  gmask |= 1 << regno;\n+\t}\n+    }\n+\n+  current_frame_info.save_fp = MUST_SAVE_FRAME_POINTER;\n+  current_frame_info.save_rp = MUST_SAVE_RETURN_POINTER;\n+\n+  reg_size += (current_frame_info.save_fp + current_frame_info.save_rp)\n+\t       * UNITS_PER_WORD;\n+\n+  /* Save computed information.  */\n+  current_frame_info.pretend_size = pretend_size;\n+  current_frame_info.var_size     = var_size;\n+  current_frame_info.args_size    = args_size;\n+  current_frame_info.reg_size\t  = reg_size;\n+  current_frame_info.frame_size   = args_size + var_size;\n+  current_frame_info.total_size   = args_size + var_size + reg_size + pretend_size;\n+  current_frame_info.gmask\t  = gmask;\n+  current_frame_info.initialised  = reload_completed;\n+\n+  /* Calculate the required distance.  */\n+  return_value = 0;\n+  \n+  if (to_reg == STACK_POINTER_REGNUM)\n+    return_value += args_size + var_size;\n+  \n+  if (from_reg == ARG_POINTER_REGNUM)\n+    return_value += reg_size;\n+\n+  return return_value;\n+}\n+\n+/* Called after register allocation to add any instructions needed for the\n+   prologue.  Using a prologue insn is favored compared to putting all of the\n+   instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n+   to intermix instructions with the saves of the caller saved registers.  In\n+   some cases, it might be necessary to emit a barrier instruction as the last\n+   insn to prevent such scheduling.  */\n+\n+void\n+fr30_expand_prologue ()\n+{\n+  int regno;\n+  rtx insn;\n+\n+  if (! current_frame_info.initialised)\n+    fr30_compute_frame_size (0, 0);\n+\n+  /* This cases shouldn't happen.  Catch it now.  */\n+  if (current_frame_info.total_size == 0\n+      && current_frame_info.gmask)\n+    abort ();\n+\n+  /* Allocate space for register arguments if this is a variadic function.  */\n+  if (current_frame_info.pretend_size)\n+    {\n+      int regs_to_save = current_frame_info.pretend_size / UNITS_PER_WORD;\n+      \n+      /* Push argument registers into the pretend arg area.  */\n+      for (regno = FIRST_ARG_REGNUM + FR30_NUM_ARG_REGS; regno --, regs_to_save --;)\n+        {\n+\t  insn = emit_insn (gen_movsi_push (gen_rtx_REG (Pmode, regno)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+    }\n+\n+  if (current_frame_info.gmask)\n+    {\n+      /* Save any needed call-saved regs.  */\n+      for (regno = STACK_POINTER_REGNUM; regno--;)\n+\t{\n+\t  if ((current_frame_info.gmask & (1 << regno)) != 0)\n+\t    {\n+\t      insn = emit_insn (gen_movsi_push (gen_rtx_REG (Pmode, regno)));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n+\t}\n+    }\n+\n+  /* Save return address if necessary.  */\n+  if (current_frame_info.save_rp)\n+    {\n+      insn = emit_insn (gen_movsi_push (gen_rtx_REG (Pmode, \n+      \t\t\t\t\t\t     RETURN_POINTER_REGNUM)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  /* Save old frame pointer and create new one, if necessary.  */\n+  if (current_frame_info.save_fp)\n+    {\n+      if (current_frame_info.frame_size < ((1 << 10) - UNITS_PER_WORD))\n+        {\n+\t  int enter_size = current_frame_info.frame_size + UNITS_PER_WORD;\n+\t  rtx pattern;\n+\t  \n+\t  insn = emit_insn (gen_enter_func (GEN_INT (enter_size)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+\t  \n+\t  pattern = PATTERN (insn);\n+\t  \n+\t  /* Also mark all 3 subexpressions as RTX_FRAME_RELATED_P. */\n+          if (GET_CODE (pattern) == PARALLEL)\n+            {\n+              int x;\n+              for (x = XVECLEN (pattern, 0); x--;)\n+\t\t{\n+\t\t  rtx part = XVECEXP (pattern, 0, x);\n+\t\t  \n+\t\t  /* One of the insns in the ENTER pattern updates the\n+\t\t     frame pointer.  If we do not actually need the frame\n+\t\t     pointer in this function then this is a side effect\n+\t\t     rather than a desired effect, so we do not mark that\n+\t\t     insn as being related to the frame set up.  Doing this\n+\t\t     allows us to compile the crash66.C test file in the\n+\t\t     G++ testsuite.  */\n+\t\t  if (! frame_pointer_needed\n+\t\t      && GET_CODE (part) == SET\n+\t\t      && REGNO (SET_DEST (part)) == HARD_FRAME_POINTER_REGNUM)\n+\t\t    RTX_FRAME_RELATED_P (part) = 0;\n+\t\t  else\n+\t\t    RTX_FRAME_RELATED_P (part) = 1;\n+\t\t}\n+            }\n+\t}\n+      else\n+\t{\n+\t  insn = emit_insn (gen_movsi_push (frame_pointer_rtx));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t  if (frame_pointer_needed)\n+\t    {\n+\t      insn = emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n+\t}\n+    }\n+\n+  /* Allocate the stack frame.  */\n+  if (current_frame_info.frame_size == 0)\n+    ; /* Nothing to do.  */\n+  else if (current_frame_info.save_fp\n+\t   && current_frame_info.frame_size < ((1 << 10) - UNITS_PER_WORD))\n+    ; /* Nothing to do.  */\n+  else if (current_frame_info.frame_size <= 512)\n+    {\n+      insn = emit_insn (gen_add_to_stack (GEN_INT (- current_frame_info.frame_size)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  else\n+    {\n+      rtx tmp = gen_rtx_REG (Pmode, PROLOGUE_TMP_REGNUM);\n+      insn = emit_insn (gen_movsi (tmp, GEN_INT (current_frame_info.frame_size)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      insn = emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, tmp));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  if (profile_flag || profile_block_flag)\n+    emit_insn (gen_blockage ());\n+}\n+\n+/* Called after register allocation to add any instructions needed for the\n+   epilogue.  Using a epilogue insn is favored compared to putting all of the\n+   instructions in the FUNCTION_EPILOGUE macro, since it allows the scheduler\n+   to intermix instructions with the restores of the caller saved registers.\n+   In some cases, it might be necessary to emit a barrier instruction as the\n+   first insn to prevent such scheduling.  */\n+void\n+fr30_expand_epilogue ()\n+{\n+  int regno;\n+\n+  /* Perform the inversion operations of the prologue.  */\n+  if (! current_frame_info.initialised)\n+    abort ();\n+\n+  /* Pop local variables and arguments off the stack.\n+     If frame_pointer_needed is TRUE then the frame pointer register\n+     has actually been used as a frame pointer, and we can recover\n+     the stack pointer from it, otherwise we must unwind the stack\n+     manually.  */\n+  if (current_frame_info.frame_size > 0)\n+    {\n+      if (current_frame_info.save_fp && frame_pointer_needed)\n+\t{\n+\t  emit_insn (gen_leave_func ());\n+\t  current_frame_info.save_fp = 0;\n+\t}\n+      else if (current_frame_info.frame_size <= 508)\n+\temit_insn (gen_add_to_stack\n+\t\t   (GEN_INT (current_frame_info.frame_size)));\n+      else\n+\t{\n+\t  rtx tmp = gen_rtx_REG (Pmode, PROLOGUE_TMP_REGNUM);\n+\t  emit_insn (gen_movsi (tmp, GEN_INT (current_frame_info.frame_size)));\n+\t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, tmp));\n+\t}\n+    }\n+  \n+  if (current_frame_info.save_fp)\n+    emit_insn (gen_movsi_pop (frame_pointer_rtx));\n+  \n+  /* Pop all the registers that were pushed.  */\n+  if (current_frame_info.save_rp)\n+    emit_insn (gen_movsi_pop (gen_rtx_REG (Pmode, RETURN_POINTER_REGNUM)));\n+    \n+  for (regno = 0; regno < STACK_POINTER_REGNUM; regno ++)\n+    if (current_frame_info.gmask & (1 << regno))\n+      emit_insn (gen_movsi_pop (gen_rtx_REG (Pmode, regno)));\n+  \n+  if (current_frame_info.pretend_size)\n+    emit_insn (gen_add_to_stack (GEN_INT (current_frame_info.pretend_size)));\n+\n+  /* Reset state info for each function.  */\n+  current_frame_info = zero_frame_info;\n+\n+  emit_insn (gen_return_from_func ());\n+}\n+\n+/* Do any needed setup for a variadic function.  We must create a register\n+   parameter block, and then copy any anonymous arguments, plus the last\n+   named argument, from registers into memory.  * copying actually done in\n+   fr30_expand_prologue().\n+\n+   ARG_REGS_USED_SO_FAR has *not* been updated for the last named argument\n+   which has type TYPE and mode MODE, and we rely on this fact.  */\n+void\n+fr30_setup_incoming_varargs (arg_regs_used_so_far, int_mode, type, pretend_size)\n+     CUMULATIVE_ARGS arg_regs_used_so_far;\n+     int             int_mode;\n+     tree            type;\n+     int *           pretend_size;\n+{\n+  enum machine_mode mode = (enum machine_mode)int_mode;\n+  int               size;\n+\n+  \n+  /* All BLKmode values are passed by reference.  */\n+  if (mode == BLKmode)\n+    abort ();\n+\n+#if STRICT_ARGUMENT_NAMING\n+  /* We must treat `__builtin_va_alist' as an anonymous arg.\n+     But otherwise if STRICT_ARGUMENT_NAMING is true then the\n+     last named arg must not be treated as an anonymous arg. */\n+  if (! current_function_varargs)\n+    arg_regs_used_so_far += fr30_num_arg_regs (int_mode, type);\n+#endif\n+  \n+  size = FR30_NUM_ARG_REGS - arg_regs_used_so_far;\n+\n+  if (size <= 0)\n+    return;\n+\n+  * pretend_size = (size * UNITS_PER_WORD);\n+}\n+\n+/*}}}*/\n+/*{{{  Printing operands */ \n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+void\n+fr30_print_operand_address (stream, address)\n+     FILE * stream;\n+     rtx    address;\n+{\n+  switch (GET_CODE (address))\n+    {\n+    case SYMBOL_REF:\n+      output_addr_const (stream, address);\n+      break;\n+      \n+    default:\n+      fprintf (stderr, \"code = %x\\n\", GET_CODE (address));\n+      debug_rtx (address);\n+      output_operand_lossage (\"fr30_print_operand_address: unhandled address\");\n+      break;\n+    }\n+}\n+\n+/* Print an operand.  */\n+\n+void\n+fr30_print_operand (file, x, code)\n+     FILE * file;\n+     rtx    x;\n+     int    code;\n+{\n+  rtx x0;\n+  \n+  switch (code)\n+    {\n+    case '#':\n+      /* Output a :D if this instruction is delayed.  */\n+      if (dbr_sequence_length () != 0)\n+\tfputs (\":D\", file);\n+      return;\n+      \n+    case 'p':\n+      /* Compute the register name of the second register in a hi/lo\n+\t register pair.  */\n+      if (GET_CODE (x) != REG)\n+\toutput_operand_lossage (\"fr30_print_operand: unrecognised %p code\");\n+      else\n+\tfprintf (file, \"r%d\", REGNO (x) + 1);\n+      return;\n+      \n+    case 'b':\n+      /* Convert GCC's comparison operators into FR30 comparison codes.  */\n+      switch (GET_CODE (x))\n+\t{\n+\tcase EQ:  fprintf (file, \"eq\"); break;\n+\tcase NE:  fprintf (file, \"ne\"); break;\n+\tcase LT:  fprintf (file, \"lt\"); break;\n+\tcase LE:  fprintf (file, \"le\"); break;\n+\tcase GT:  fprintf (file, \"gt\"); break;\n+\tcase GE:  fprintf (file, \"ge\"); break;\n+\tcase LTU: fprintf (file, \"c\"); break;\n+\tcase LEU: fprintf (file, \"ls\"); break;\n+\tcase GTU: fprintf (file, \"hi\"); break;\n+\tcase GEU: fprintf (file, \"nc\");  break;\n+\tdefault:\n+\t  output_operand_lossage (\"fr30_print_operand: unrecognised %b code\");\n+\t  break;\n+\t}\n+      return;\n+      \n+    case 'B':\n+      /* Convert GCC's comparison operators into the complimentary FR30\n+\t comparison codes.  */\n+      switch (GET_CODE (x))\n+\t{\n+\tcase EQ:  fprintf (file, \"ne\"); break;\n+\tcase NE:  fprintf (file, \"eq\"); break;\n+\tcase LT:  fprintf (file, \"ge\"); break;\n+\tcase LE:  fprintf (file, \"gt\"); break;\n+\tcase GT:  fprintf (file, \"le\"); break;\n+\tcase GE:  fprintf (file, \"lt\"); break;\n+\tcase LTU: fprintf (file, \"nc\"); break;\n+\tcase LEU: fprintf (file, \"hi\"); break;\n+\tcase GTU: fprintf (file, \"ls\"); break;\n+\tcase GEU: fprintf (file, \"c\"); break;\n+\tdefault:\n+\t  output_operand_lossage (\"fr30_print_operand: unrecognised %B code\");\n+\t  break;\n+\t}\n+      return;\n+\n+    case 'A':\n+      /* Print a signed byte value as an unsigned value.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"fr30_print_operand: invalid operand to %A code\");\n+      else\n+\t{\n+\t  HOST_WIDE_INT val;\n+\t  \n+\t  val = INTVAL (x);\n+\n+\t  val &= 0xff;\n+\n+\t  fprintf (file, \"%d\", val);\n+\t}\n+      return;\n+      \n+    case 'x':\n+      if (GET_CODE (x) != CONST_INT\n+\t  || INTVAL (x) < 16\n+\t  || INTVAL (x) > 32)\n+\toutput_operand_lossage (\"fr30_print_operand: invalid %x code\");\n+      else\n+\tfprintf (file, \"%d\", INTVAL (x) - 16);\n+      return;\n+\n+    case 'F':\n+      if (GET_CODE (x) != CONST_DOUBLE)\n+\toutput_operand_lossage (\"fr30_print_operand: invalid %F code\");\n+      else\n+\t{\n+\t  REAL_VALUE_TYPE d;\n+\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n+\t  fprintf (file, \"%.8f\", d);\n+\t}\n+      return;\n+      \n+    case 0:\n+      /* Handled below.  */\n+      break;\n+      \n+    default:\n+      fprintf (stderr, \"unknown code = %x\\n\", code);\n+      output_operand_lossage (\"fr30_print_operand: unknown code\");\n+      return;\n+    }\n+\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      fputs (reg_names [REGNO (x)], file);\n+      break;\n+\n+    case MEM:\n+      x0 = XEXP (x,0);\n+      \n+      switch (GET_CODE (x0))\n+\t{\n+\tcase REG:\n+\t  if (REGNO (x0) >= (sizeof (reg_names) / sizeof (reg_names[0])))\n+\t    abort ();\n+\t  fprintf (file, \"@%s\", reg_names [REGNO (x0)]);\n+\t  break;\n+\n+\tcase PLUS:\n+\t  if (GET_CODE (XEXP (x0, 0)) != REG\n+\t      || REGNO (XEXP (x0, 0)) < FRAME_POINTER_REGNUM\n+\t      || REGNO (XEXP (x0, 0)) > STACK_POINTER_REGNUM\n+\t      || GET_CODE (XEXP (x0, 1)) != CONST_INT)\n+\t    {\n+\t      fprintf (stderr, \"bad INDEXed address:\");\n+\t      debug_rtx (x);\n+\t      output_operand_lossage (\"fr30_print_operand: unhandled MEM\");\n+\t    }\n+\t  else if (REGNO (XEXP (x0, 0)) == FRAME_POINTER_REGNUM)\n+\t    {\n+\t      HOST_WIDE_INT val = INTVAL (XEXP (x0, 1));\n+\t      if (val < -(1 << 9) || val > ((1 << 9) - 4))\n+\t\t{\n+\t\t  fprintf (stderr, \"frame INDEX out of range:\");\n+\t\t  debug_rtx (x);\n+\t\t  output_operand_lossage (\"fr30_print_operand: unhandled MEM\");\n+\t\t}\n+\t      fprintf (file, \"@(r14, #%d)\", val);\n+\t    }\n+\t  else\n+\t    {\n+\t      HOST_WIDE_INT val = INTVAL (XEXP (x0, 1));\n+\t      if (val < 0 || val > ((1 << 6) - 4))\n+\t\t{\n+\t\t  fprintf (stderr, \"stack INDEX out of range:\");\n+\t\t  debug_rtx (x);\n+\t\t  output_operand_lossage (\"fr30_print_operand: unhandled MEM\");\n+\t\t}\n+\t      fprintf (file, \"@(r15, #%d)\", val);\n+\t    }\n+\t  break;\n+\t  \n+\tcase SYMBOL_REF:\n+\t  output_address (x0);\n+\t  break;\n+\t  \n+\tdefault:\n+\t  fprintf (stderr, \"bad MEM code = %x\\n\", GET_CODE (x0));\n+\t  debug_rtx (x);\n+\t  output_operand_lossage (\"fr30_print_operand: unhandled MEM\");\n+\t  break;\n+\t}\n+      break;\n+      \n+    case CONST_DOUBLE :\n+      /* We handle SFmode constants here as output_addr_const doesn't.  */\n+      if (GET_MODE (x) == SFmode)\n+\t{\n+\t  REAL_VALUE_TYPE d;\n+\t  long l;\n+\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n+\t  REAL_VALUE_TO_TARGET_SINGLE (d, l);\n+\t  fprintf (file, \"0x%08lx\", l);\n+\t  break;\n+\t}\n+\n+      /* Fall through.  Let output_addr_const deal with it.  */\n+    default:\n+      output_addr_const (file, x);\n+      break;\n+    }\n+\n+  return;\n+}\n+\n+/*}}}*/\n+/*{{{  Function arguments */ \n+\n+/* Compute the number of word sized registers needed to hold a\n+   function argument of mode INT_MODE and tree type TYPE.  */\n+int\n+fr30_num_arg_regs (int_mode, type)\n+     int int_mode;\n+     tree type;\n+{\n+  enum machine_mode mode = (enum machine_mode) int_mode;\n+  int size;\n+\n+  if (MUST_PASS_IN_STACK (mode, type))\n+    return 0;\n+\n+  if (type && mode == BLKmode)\n+    size = int_size_in_bytes (type);\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  return (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+}\n+\n+/* Implements the FUNCTION_ARG_PARTIAL_NREGS macro.\n+   Returns the number of argument registers required to hold *part* of\n+   a parameter of machine mode MODE and tree type TYPE (which may be\n+   NULL if the type is not known).  If the argument fits entirly in\n+   the argument registers, or entirely on the stack, then 0 is returned.\n+   CUM is the number of argument registers already used by earlier\n+   parameters to the function.  */\n+\n+int\n+fr30_function_arg_partial_nregs (cum, int_mode, type, named)\n+     CUMULATIVE_ARGS cum;\n+     int int_mode;\n+     tree type;\n+     int named;\n+{\n+  /* Unnamed arguments, ie those that are prototyped as ...\n+     are always passed on the stack.\n+     Also check here to see if all the argument registers are full.  */\n+  if (named == 0 || cum >= FR30_NUM_ARG_REGS)\n+    return 0;\n+\n+  /* Work out how many argument registers would be needed if this\n+     parameter were to be passed entirely in registers.  If there\n+     are sufficient argument registers available (or if no registers\n+     are needed because the parameter must be passed on the stack)\n+     then return zero, as this parameter does not require partial\n+     register, partial stack stack space.  */\n+  if (cum + fr30_num_arg_regs (int_mode, type) <= FR30_NUM_ARG_REGS)\n+    return 0;\n+  \n+  /* Otherwise return the number of registers that would be used.  */\n+  return FR30_NUM_ARG_REGS - cum;\n+}\n+\n+static rtx\n+fr30_pass_by_reference (valist, type)\n+     tree valist;\n+     tree type;\n+{\n+  tree type_ptr;\n+  tree type_ptr_ptr;\n+  tree t;\n+  \n+  type_ptr     = build_pointer_type (type);\n+  type_ptr_ptr = build_pointer_type (type_ptr);\n+  \n+  t = build (POSTINCREMENT_EXPR, va_list_type_node, valist, build_int_2 (UNITS_PER_WORD, 0));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  t = build1 (NOP_EXPR, type_ptr_ptr, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  t = build1 (INDIRECT_REF, type_ptr, t);\n+  \n+  return expand_expr (t, NULL_RTX, Pmode, EXPAND_NORMAL);\n+}\n+\n+static rtx\n+fr30_pass_by_value (valist, type)\n+     tree valist;\n+     tree type;\n+{\n+  HOST_WIDE_INT size = int_size_in_bytes (type);\n+  HOST_WIDE_INT rsize;\n+  rtx addr_rtx;\n+  tree t;\n+\n+  if ((size % UNITS_PER_WORD) == 0)\n+    {\n+      t = build (POSTINCREMENT_EXPR, va_list_type_node, valist, build_int_2 (size, 0));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      \n+      return expand_expr (t, NULL_RTX, Pmode, EXPAND_NORMAL);\n+    }\n+\n+  rsize = (size + UNITS_PER_WORD - 1) & - UNITS_PER_WORD;\n+      \n+  /* Care for bigendian correction on the aligned address.  */\n+  t = build (PLUS_EXPR, ptr_type_node, valist, build_int_2 (rsize - size, 0));\n+  addr_rtx = expand_expr (t, NULL_RTX, Pmode, EXPAND_NORMAL);\n+  addr_rtx = copy_to_reg (addr_rtx);\n+      \n+  /* Increment AP.  */\n+  t = build (PLUS_EXPR, va_list_type_node, valist, build_int_2 (rsize, 0));\n+  t = build (MODIFY_EXPR, va_list_type_node, valist, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  \n+  return addr_rtx;\n+}\n+\n+/* Implement `va_arg'.  */\n+\n+rtx\n+fr30_va_arg (valist, type)\n+     tree valist;\n+     tree type;\n+{\n+  HOST_WIDE_INT size;\n+  \n+  if (AGGREGATE_TYPE_P (type))\n+    return fr30_pass_by_reference (valist, type);\n+  \n+  size = int_size_in_bytes (type);\n+\n+  if ((size % sizeof (int)) == 0\n+      || size < 4)\n+    return fr30_pass_by_value (valist, type);\n+\n+  return fr30_pass_by_reference (valist, type);\n+}\n+\n+/*}}}*/\n+/*{{{  Operand predicates */ \n+\n+/* Returns true if OPERAND is an integer value suitable for use in\n+   an ADDSP instruction.  */\n+int\n+stack_add_operand (operand, mode)\n+     rtx operand;\n+     Mmode mode ATTRIBUTE_UNUSED;\n+{\n+  return\n+    (GET_CODE (operand) == CONST_INT\n+     && INTVAL (operand) >= -512\n+     && INTVAL (operand) <=  508\n+     && ((INTVAL (operand) & 3) == 0));\n+}\n+\n+/* Returns true if OPERAND is an integer value suitable for use in\n+   an ADD por ADD2 instruction, or if it is a register.  */\n+int\n+add_immediate_operand (operand, mode)\n+     rtx operand;\n+     Mmode mode ATTRIBUTE_UNUSED;\n+{\n+  return\n+    (GET_CODE (operand) == REG\n+     || (GET_CODE (operand) == CONST_INT\n+\t && INTVAL (operand) >= -16\n+\t && INTVAL (operand) <=  15));\n+}\n+\n+/* Returns true if OPERAND is hard register in the range 8 - 15.  */\n+int\n+high_register_operand (operand, mode)\n+     rtx operand;\n+     Mmode mode ATTRIBUTE_UNUSED;\n+{\n+  return\n+    (GET_CODE (operand) == REG\n+     && REGNO (operand) <= 15\n+     && REGNO (operand) >= 8);\n+}\n+\n+/* Returns true if OPERAND is hard register in the range 0 - 7.  */\n+int\n+low_register_operand (operand, mode)\n+     rtx operand;\n+     Mmode mode ATTRIBUTE_UNUSED;\n+{\n+  return\n+    (GET_CODE (operand) == REG\n+     && REGNO (operand) <= 7\n+     && REGNO (operand) >= 0);\n+}\n+\n+/* Returns true if OPERAND is suitable for use in a CALL insn.  */\n+int\n+call_operand (operand, mode)\n+     rtx operand;\n+     Mmode mode;\n+{\n+  return nonimmediate_operand (operand, mode)\n+    || (GET_CODE (operand) == MEM\n+\t&& GET_CODE (XEXP (operand, 0)) == SYMBOL_REF);\n+}\n+\n+/* Returns true iff all the registers in the operands array\n+   are in descending or ascending order.  */\n+int\n+fr30_check_multiple_regs (operands, num_operands, descending)\n+     rtx * operands;\n+     int   num_operands;\n+     int   descending;\n+{\n+  if (descending)\n+    {\n+      int prev_regno = -1;\n+      \n+      while (num_operands--)\n+\t{\n+\t  if (GET_CODE (operands [num_operands]) != REG)\n+\t    return 0;\n+\t  \n+\t  if (REGNO (operands [num_operands]) < prev_regno)\n+\t    return 0;\n+\t  \n+\t  prev_regno = REGNO (operands [num_operands]);\n+\t}\n+    }\n+  else\n+    {\n+      int prev_regno = CONDITION_CODE_REGNUM;\n+      \n+      while (num_operands--)\n+\t{\n+\t  if (GET_CODE (operands [num_operands]) != REG)\n+\t    return 0;\n+\t  \n+\t  if (REGNO (operands [num_operands]) > prev_regno)\n+\t    return 0;\n+\t  \n+\t  prev_regno = REGNO (operands [num_operands]);\n+\t}\n+    }\n+\n+  return 1;\n+}\n+\n+/*}}}*/\n+\n+/* Local Variables: */\n+/* folded-file: t   */\n+/* End:\t\t    */\n+"}, {"sha": "1c2d70f0504cabb4635e59414789abc1899bce5c", "filename": "gcc/config/fr30/fr30.h", "status": "added", "additions": 4505, "deletions": 0, "changes": 4505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=309dd885ff9f569aec12cb5e3281a3b4dd73a8e0"}, {"sha": "f0ac26a2374eb6dcea43d57c1b7d9e2a1d05733e", "filename": "gcc/config/fr30/fr30.md", "status": "added", "additions": 1400, "deletions": 0, "changes": 1400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Ffr30.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Ffr30.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.md?ref=309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "patch": "@@ -0,0 +1,1400 @@\n+;;{{{ Comment \n+\n+;; FR30 machine description.\n+;; Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+;; Contributed by Cygnus Solutions.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;;}}} \f\n+;;{{{ Attributes \n+\n+(define_attr \"length\" \"\" (const_int 2))\n+\n+;; Used to distinguish between small memory model targets and big mode targets.\n+\n+(define_attr \"size\" \"small,big\"\n+  (const (if_then_else (symbol_ref \"TARGET_SMALL_MODEL\")\n+\t\t       (const_string \"small\")\n+\t\t       (const_string \"big\"))))\n+\n+\n+;; Define an attribute to be used by the delay slot code.\n+;; An instruction by default is considered to be 'delyabable'\n+;; that is, it can be placed into a delay slot, but it is not\n+;; itself an delyaed branch type instruction.  An instruction\n+;; whoes type is 'delayed' is one which has a delay slot, and\n+;; an instruction whoes delay_type is 'other' is one which does\n+;; not have a delay slot, nor can it be placed into a delay slot.\n+\n+(define_attr \"delay_type\" \"delayable,delayed,other\" (const_string \"delayable\"))\n+\n+;;}}} \f\n+;;{{{ Delay Slot Specifications \n+\n+(define_delay (eq_attr \"delay_type\" \"delayed\")\n+  [(and (eq_attr \"delay_type\" \"delayable\")\n+\t(eq_attr \"length\" \"2\"))\n+   (nil)\n+   (nil)]\n+)\n+\n+;;}}}\n+;;{{{ Moves \n+\n+;;{{{ Comment \n+\n+;; Wrap moves in define_expand to prevent memory->memory moves from being\n+;; generated at the RTL level, which generates better code for most machines\n+;; which can't do mem->mem moves.\n+\n+;; If operand 0 is a `subreg' with mode M of a register whose own mode is wider\n+;; than M, the effect of this instruction is to store the specified value in\n+;; the part of the register that corresponds to mode M.  The effect on the rest\n+;; of the register is undefined.\n+\n+;; This class of patterns is special in several ways.  First of all, each of\n+;; these names *must* be defined, because there is no other way to copy a datum\n+;; from one place to another.\n+\n+;; Second, these patterns are not used solely in the RTL generation pass.  Even\n+;; the reload pass can generate move insns to copy values from stack slots into\n+;; temporary registers.  When it does so, one of the operands is a hard\n+;; register and the other is an operand that can need to be reloaded into a\n+;; register.\n+\n+;; Therefore, when given such a pair of operands, the pattern must\n+;; generate RTL which needs no reloading and needs no temporary\n+;; registers--no registers other than the operands.  For example, if\n+;; you support the pattern with a `define_expand', then in such a\n+;; case the `define_expand' mustn't call `force_reg' or any other such\n+;; function which might generate new pseudo registers.\n+\n+;; This requirement exists even for subword modes on a RISC machine\n+;; where fetching those modes from memory normally requires several\n+;; insns and some temporary registers.  Look in `spur.md' to see how\n+;; the requirement can be satisfied.\n+\n+;; During reload a memory reference with an invalid address may be passed as an\n+;; operand.  Such an address will be replaced with a valid address later in the\n+;; reload pass.  In this case, nothing may be done with the address except to\n+;; use it as it stands.  If it is copied, it will not be replaced with a valid\n+;; address.  No attempt should be made to make such an address into a valid\n+;; address and no routine (such as `change_address') that will do so may be\n+;; called.  Note that `general_operand' will fail when applied to such an\n+;; address.\n+;;\n+;; The global variable `reload_in_progress' (which must be explicitly declared\n+;; if required) can be used to determine whether such special handling is\n+;; required.\n+;;\n+;; The variety of operands that have reloads depends on the rest of\n+;; the machine description, but typically on a RISC machine these can\n+;; only be pseudo registers that did not get hard registers, while on\n+;; other machines explicit memory references will get optional\n+;; reloads.\n+;;\n+;; If a scratch register is required to move an object to or from memory, it\n+;; can be allocated using `gen_reg_rtx' prior to reload.  But this is\n+;; impossible during and after reload.  If there are cases needing scratch\n+;; registers after reload, you must define `SECONDARY_INPUT_RELOAD_CLASS' and\n+;; perhaps also `SECONDARY_OUTPUT_RELOAD_CLASS' to detect them, and provide\n+;; patterns `reload_inM' or `reload_outM' to handle them.\n+\n+;; The constraints on a `moveM' must permit moving any hard register to any\n+;; other hard register provided that `HARD_REGNO_MODE_OK' permits mode M in\n+;; both registers and `REGISTER_MOVE_COST' applied to their classes returns a\n+;; value of 2.\n+\n+;; It is obligatory to support floating point `moveM' instructions\n+;; into and out of any registers that can hold fixed point values,\n+;; because unions and structures (which have modes `SImode' or\n+;; `DImode') can be in those registers and they may have floating\n+;; point members.\n+\n+;; There may also be a need to support fixed point `moveM' instructions in and\n+;; out of floating point registers.  Unfortunately, I have forgotten why this\n+;; was so, and I don't know whether it is still true.  If `HARD_REGNO_MODE_OK'\n+;; rejects fixed point values in floating point registers, then the constraints\n+;; of the fixed point `moveM' instructions must be designed to avoid ever\n+;; trying to reload into a floating point register.\n+\n+;;}}}\n+;;{{{ Push and Pop  \n+\n+;; Push a register onto the stack\n+(define_insn \"movsi_push\"\n+  [(set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+\t(match_operand:SI 0 \"register_operand\" \"a\"))]\n+  \"\"\n+  \"st\t%0, @-r15\"\n+)\n+\n+;; Pop a register off the stack\n+(define_insn \"movsi_pop\"\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"a\")\n+\t(mem:SI (post_inc:SI (reg:SI 15))))]\n+  \"\"\n+  \"ld\t@r15+, %0\"\n+)\n+\n+;;}}}\n+;;{{{ 1 Byte Moves \n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (!reload_in_progress\n+      && !reload_completed\n+      && GET_CODE (operands[0]) == MEM\n+      && (GET_CODE (operands[1]) == MEM\n+         || immediate_operand (operands[1], QImode)))\n+    operands[1] = copy_to_mode_reg (QImode, operands[1]);\n+}\")\n+\n+(define_insn \"movqi_unsigned_register_load\"\n+  [(set (match_operand:SI 0 \"register_operand\"              \"=r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldub\t%1, %0\"\n+)\n+\n+(define_expand \"movqi_signed_register_load\"\n+  [(set (match_operand:SI 0 \"register_operand\"               \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"\")))]\n+  \"\"\n+  \"\n+  emit_insn (gen_movqi_unsigned_register_load (operands[0], operands[1]));\n+  emit_insn (gen_extendqisi2 (operands[0], operands[0]));\n+  DONE;\n+  \"\n+)\n+\n+(define_insn \"*movqi_internal\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,red,m,r\")\n+\t(match_operand:QI 1 \"general_operand\"       \"i,red,r,rm\"))]\n+  \"\"\n+  \"@\n+   ldi:8\\\\t#%A1, %0\n+   mov  \\\\t%1, %0\n+   stb  \\\\t%1, %0\n+   ldub \\\\t%1, %0\"\n+)\n+\n+;;}}}\n+;;{{{ 2 Byte Moves \n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (!reload_in_progress\n+      && !reload_completed\n+      && GET_CODE (operands[0]) == MEM\n+      && (GET_CODE (operands[1]) == MEM\n+\t || immediate_operand (operands[1], HImode)))\n+    operands[1] = copy_to_mode_reg (HImode, operands[1]);\n+}\")\n+\n+(define_insn \"movhi_unsigned_register_load\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"lduh\t%1, %0\"\n+)\n+\n+(define_expand \"movhi_signed_register_load\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"\")))]\n+  \"\"\n+  \"\n+  emit_insn (gen_movhi_unsigned_register_load (operands[0], operands[1]));\n+  emit_insn (gen_extendhisi2 (operands[0], operands[0]));\n+  DONE;\n+  \"\n+)\n+\n+(define_insn \"*movhi_internal\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,red,m,r\")\n+\t(match_operand:HI 1 \"general_operand\"       \"L,M,n,red,r,rm\"))]\n+  \"\"\n+  \"@\n+   ldi:8 \\\\t#%1, %0\n+   ldi:20\\\\t#%1, %0\n+   ldi:32\\\\t#%1, %0\n+   mov   \\\\t%1, %0\n+   sth   \\\\t%1, %0\n+   lduh  \\\\t%1, %0\"\n+  [(set_attr \"length\" \"*,4,6,*,*,*\")]\n+)\n+\n+;;}}}\n+;;{{{ 4 Byte Moves \n+\n+;; If the destination is a MEM and the source is a\n+;; MEM or an CONST_INT move the source into a register.\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"{\n+  if (!reload_in_progress\n+      && !reload_completed\n+      && GET_CODE(operands[0]) == MEM\n+      && (GET_CODE (operands[1]) == MEM\n+\t  || immediate_operand (operands[1], SImode)))\n+     operands[1] = copy_to_mode_reg (SImode, operands[1]);\n+  }\"\n+)\n+\n+;; We can do some clever tricks when loading certain immediate\n+;; values.  We implement these tricks as define_splits, rather\n+;; than putting the code into the define_expand \"movsi\" above,\n+;; because if we put them there, they will be evaluated at RTL\n+;; generation time and then the combiner pass will come along\n+;; and replace the multiple insns that have been generated with\n+;; the original, slower, load insns.  (The combiner pass only\n+;; cares about reducing the number of instructions, it does not\n+;; care about instruction lengths or speeds).  Splits are\n+;; evaluated after the combine pass and before the scheduling\n+;; passes, so that they are the perfect place to put this\n+;; intelligence.\n+;;\n+;; XXX we probably ought to implement these for QI and HI mode\n+;; loads as well.\n+\n+;; If we are loading a small negative constant we can save space\n+;; and time by loading the positive value and then sign extending it.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\"  \"r\")\n+\t(match_operand:SI 1 \"immediate_operand\" \"i\"))]\n+   \"INTVAL (operands[1]) <= -1 && INTVAL (operands[1]) >= -128\"\n+   [(set:SI (match_dup 0) (match_dup 2))\n+    (set:SI (match_dup 0) (sign_extend:SI (subreg:QI (match_dup 0) 0)))]\n+   \"{\n+   operands[2] = GEN_INT (INTVAL (operands[1]) & 0xff);\n+   }\"\n+)\n+\n+;; If we are loading a large negative constant, one which does\n+;; not have any of its bottom 24 bit set, then we can save time\n+;; and space by loading the byte value and shifting it into place.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\"  \"r\")\n+\t(match_operand:SI 1 \"immediate_operand\" \"i\"))]\n+   \"(INTVAL (operands[1]) < 0) && (INTVAL (operands[1]) & 0x00ffffff == 0)\"\n+   [(set:SI (match_dup 0) (match_dup 2))\n+    (parallel [(set:SI (match_dup 0) (ashift:SI (match_dup 0) (const_int 24)))\n+\t       (clobber (reg:CC 16))])]\n+   \"{\n+   HOST_WIDE_INT val = INTVAL (operands[1]);\n+   operands[2] = GEN_INT (val >> 24);\n+   }\"\n+)\n+\n+;; If we are loading a large positive constant, one which has bits\n+;; in the top byte set, but whoes set bits all lie within an 8 bit\n+;; range, then we can save time and space by loading the byte value\n+;; and shifting it into place.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\"  \"r\")\n+\t(match_operand:SI 1 \"immediate_operand\" \"i\"))]\n+   \"(INTVAL (operands[1]) > 0x00ffffff)\n+   && ((INTVAL (operands[1]) >> exact_log2 (INTVAL (operands[1]) & (- INTVAL (operands[1])))) < 0x100)\"\n+   [(set:SI (match_dup 0) (match_dup 2))\n+    (parallel [(set:SI (match_dup 0) (ashift:SI (match_dup 0) (match_dup 3)))\n+\t       (clobber (reg:CC 16))])]\n+   \"{\n+   HOST_WIDE_INT val = INTVAL (operands[1]);\n+   int shift = exact_log2 (val & ( - val));\n+   operands[2] = GEN_INT (val >> shift);\n+   operands[3] = GEN_INT (shift);\n+   }\"\n+)\n+\n+;; When TARGET_SMALL_MODEL is defined we assume that all symbolic\n+;; values are addresses which will fit in 20 bits.\n+\n+(define_insn \"movsi_internal\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,red,m,r\")\n+\t(match_operand:SI 1 \"general_operand\"       \"L,M,n,i,rde,r,rm\"))]\n+  \"\"\n+  \"*\n+  {\n+    switch (which_alternative)\n+    {\n+    case 0: return   \\\"ldi:8 \\\\t#%1, %0\\\";\n+    case 1: return   \\\"ldi:20\\\\t#%1, %0\\\";\n+    case 2: return   \\\"ldi:32\\\\t#%1, %0\\\";\n+    case 3: if (TARGET_SMALL_MODEL)\n+\t      return \\\"ldi:20\\\\t%1, %0\\\";\n+            else\n+\t      return \\\"ldi:32\\\\t%1, %0\\\";\n+    case 4: return   \\\"mov   \\\\t%1, %0\\\";\n+    case 5: return   \\\"st    \\\\t%1, %0\\\";\n+    case 6: return   \\\"ld    \\\\t%1, %0\\\";\n+    default: abort ();\t       \n+    }\n+  }\"\n+  [(set (attr \"length\") (cond [(eq_attr \"alternative\" \"1\") (const_int 4)\n+\t\t\t       (eq_attr \"alternative\" \"2\") (const_int 6)\n+\t\t\t       (eq_attr \"alternative\" \"3\") \n+\t\t\t                (if_then_else (eq_attr \"size\" \"small\")\n+\t\t\t\t\t\t      (const_int 4)\n+\t\t\t\t\t\t      (const_int 6))]\n+\t\t\t      (const_int 2)))]\n+)\n+\n+;;}}}\n+;;{{{ Load & Store Multiple Registers \n+\n+;; The load multiple and store multiple patterns are implemented\n+;; as peepholes because the only time they are expected to occur\n+;; is during function prologues and epilogues.\n+\n+(define_peephole\n+  [(set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+\t   (match_operand:SI 0 \"high_register_operand\" \"h\"))\n+   (set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+           (match_operand:SI 1 \"high_register_operand\" \"h\"))\n+   (set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+           (match_operand:SI 2 \"high_register_operand\" \"h\"))\n+   (set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+           (match_operand:SI 3 \"high_register_operand\" \"h\"))]\n+  \"fr30_check_multiple_regs (operands, 4, 1)\"\n+  \"stm1\t(%0, %1, %2, %3)\"\n+  [(set_attr \"delay_type\" \"other\")]\n+)\n+\n+(define_peephole\n+  [(set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+\t   (match_operand:SI 0 \"high_register_operand\" \"h\"))\n+   (set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+           (match_operand:SI 1 \"high_register_operand\" \"h\"))\n+   (set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+           (match_operand:SI 2 \"high_register_operand\" \"h\"))]\n+  \"fr30_check_multiple_regs (operands, 3, 1)\"\n+  \"stm1\t(%0, %1, %2)\"\n+  [(set_attr \"delay_type\" \"other\")]\n+)\n+\n+(define_peephole\n+  [(set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+\t   (match_operand:SI 0 \"high_register_operand\" \"h\"))\n+   (set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+           (match_operand:SI 1 \"high_register_operand\" \"h\"))]\n+  \"fr30_check_multiple_regs (operands, 2, 1)\"\n+  \"stm1\t(%0, %1)\"\n+  [(set_attr \"delay_type\" \"other\")]\n+)\n+\n+(define_peephole\n+  [(set:SI (match_operand:SI 0 \"high_register_operand\" \"h\")\n+           (mem:SI (post_inc:SI (reg:SI 15))))\n+   (set:SI (match_operand:SI 1 \"high_register_operand\" \"h\")\n+           (mem:SI (post_inc:SI (reg:SI 15))))\n+   (set:SI (match_operand:SI 2 \"high_register_operand\" \"h\")\n+           (mem:SI (post_inc:SI (reg:SI 15))))\n+   (set:SI (match_operand:SI 3 \"high_register_operand\" \"h\")\n+           (mem:SI (post_inc:SI (reg:SI 15))))]\n+  \"fr30_check_multiple_regs (operands, 4, 0)\"\n+  \"ldm1\t(%0, %1, %2, %3)\"\n+  [(set_attr \"delay_type\" \"other\")]\n+)\n+\n+(define_peephole\n+  [(set:SI (match_operand:SI 0 \"high_register_operand\" \"h\")\n+           (mem:SI (post_inc:SI (reg:SI 15))))\n+   (set:SI (match_operand:SI 1 \"high_register_operand\" \"h\")\n+           (mem:SI (post_inc:SI (reg:SI 15))))\n+   (set:SI (match_operand:SI 2 \"high_register_operand\" \"h\")\n+           (mem:SI (post_inc:SI (reg:SI 15))))]\n+  \"fr30_check_multiple_regs (operands, 3, 0)\"\n+  \"ldm1\t(%0, %1, %2)\"\n+  [(set_attr \"delay_type\" \"other\")]\n+)\n+\n+(define_peephole\n+  [(set:SI (match_operand:SI 0 \"high_register_operand\" \"h\")\n+           (mem:SI (post_inc:SI (reg:SI 15))))\n+   (set:SI (match_operand:SI 1 \"high_register_operand\" \"h\")\n+           (mem:SI (post_inc:SI (reg:SI 15))))]\n+  \"fr30_check_multiple_regs (operands, 2, 0)\"\n+  \"ldm1\t(%0, %1)\"\n+  [(set_attr \"delay_type\" \"other\")]\n+)\n+\n+(define_peephole\n+  [(set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+\t   (match_operand:SI 0 \"low_register_operand\" \"l\"))\n+   (set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+           (match_operand:SI 1 \"low_register_operand\" \"l\"))\n+   (set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+           (match_operand:SI 2 \"low_register_operand\" \"l\"))\n+   (set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+           (match_operand:SI 3 \"low_register_operand\" \"l\"))]\n+  \"fr30_check_multiple_regs (operands, 4, 1)\"\n+  \"stm0\t(%0, %1, %2, %3)\"\n+  [(set_attr \"delay_type\" \"other\")]\n+)\n+\n+(define_peephole\n+  [(set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+\t   (match_operand:SI 0 \"low_register_operand\" \"l\"))\n+   (set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+           (match_operand:SI 1 \"low_register_operand\" \"l\"))\n+   (set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+           (match_operand:SI 2 \"low_register_operand\" \"l\"))]\n+  \"fr30_check_multiple_regs (operands, 3, 1)\"\n+  \"stm0\t(%0, %1, %2)\"\n+  [(set_attr \"delay_type\" \"other\")]\n+)\n+\n+(define_peephole\n+  [(set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+\t   (match_operand:SI 0 \"low_register_operand\" \"l\"))\n+   (set:SI (mem:SI (pre_dec:SI (reg:SI 15)))\n+           (match_operand:SI 1 \"low_register_operand\" \"l\"))]\n+  \"fr30_check_multiple_regs (operands, 2, 1)\"\n+  \"stm0\t(%0, %1)\"\n+  [(set_attr \"delay_type\" \"other\")]\n+)\n+\n+;;}}}\n+;;{{{ Floating Point Moves \n+\n+;; Note - Patterns for SF mode moves are compulsory, but\n+;; patterns for DF are optional, as GCC can synthesise them.\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"{\n+  if (!reload_in_progress && !reload_completed\n+      && memory_operand (operands[0], SFmode)\n+      && memory_operand (operands[1], SFmode))\n+    operands[1] = copy_to_mode_reg (SFmode, operands[1]);\n+  }\"\n+)\n+\n+(define_insn \"*movsf_internal\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,red,m,r\")\n+\t(match_operand:SF 1 \"general_operand\"      \"Fn,i,rde,r,rm\"))]\n+  \"\"\n+  \"*\n+  {\n+    switch (which_alternative)\n+    {\n+    case 0: return   \\\"ldi:32\\\\t%1, %0\\\";\n+    case 1: if (TARGET_SMALL_MODEL)\n+\t      return \\\"ldi:20\\\\t%1, %0\\\";\n+            else\n+\t      return \\\"ldi:32\\\\t%1, %0\\\";\n+    case 2: return   \\\"mov   \\\\t%1, %0\\\";\n+    case 3: return   \\\"st    \\\\t%1, %0\\\";\n+    case 4: return   \\\"ld    \\\\t%1, %0\\\";\n+    default: abort ();\t       \n+    }\n+  }\"\n+  [(set (attr \"length\") (cond [(eq_attr \"alternative\" \"0\") (const_int 6)\n+\t\t\t       (eq_attr \"alternative\" \"1\") \n+\t\t\t                (if_then_else (eq_attr \"size\" \"small\")\n+\t\t\t\t\t\t      (const_int 4)\n+\t\t\t\t\t\t      (const_int 6))]\n+\t\t\t      (const_int 2)))]\n+)\n+\n+(define_insn \"*movsf_constant_store\"\n+  [(set (match_operand:SF 0 \"memory_operand\"    \"m\")\n+\t(match_operand:SF 1 \"immediate_operand\" \"F\"))]\n+  \"\"\n+  \"*\n+  {\n+  char *         ldi_instr;\n+  char *          tmp_reg;\n+  static char     buffer[100];\n+  REAL_VALUE_TYPE d;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (d, operands[1]);\n+  \n+  if (REAL_VALUES_EQUAL (d, dconst0))\n+    ldi_instr = \\\"ldi:8\\\";\n+  else\n+    ldi_instr = \\\"ldi:32\\\";\n+\n+  tmp_reg = reg_names [COMPILER_SCRATCH_REGISTER];\n+  \n+  sprintf (buffer, \\\"%s\\\\t#%%1, %s\\\\t;\\\\n\\\\tst\\\\t%s, %%0\\\\t; Created by movsf_constant_store\\\",\n+    ldi_instr, tmp_reg, tmp_reg);\n+\n+  return buffer;\n+  }\"\n+  [(set_attr \"length\" \"8\")]\n+)\n+\n+;;}}}\n+\n+;;}}} \f\n+;;{{{ Conversions \n+\n+;; Signed conversions from a smaller integer to a larger integer\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"                \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"extsb\t%0\"\n+)\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"                \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"extsh\t%0\"\n+)\n+\n+;; Unsigned conversions from a smaller integer to a larger integer\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"                \"=r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"extub\t%0\"\n+)\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"                \"=r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"extuh\t%0\"\n+)\n+\n+;;}}} \f\n+;;{{{ Arithmetic \n+\n+;;{{{ Addition \n+\n+;; This is a special pattern just for adjusting the stack size.\n+(define_insn \"add_to_stack\"\n+  [(set (reg:SI 15)\n+\t(plus:SI (reg:SI 15)\n+\t\t (match_operand:SI 0 \"stack_add_operand\" \"i\")))]\n+  \"\"\n+  \"addsp\t%0\"\n+)\n+\n+;; We need some trickery to be able to handle the addition of\n+;; large (ie outside +/- 16) constants.  We need to be able to\n+;; handle this because reload assumes that it can generate add\n+;; instructions with arbitary sized constants.\n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"           \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\"  \"\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"{\n+  if (   GET_CODE (operands[2]) == REG\n+      || GET_CODE (operands[2]) == SUBREG)\n+    emit_insn (gen_addsi_regs (operands[0], operands[1], operands[2]));\n+  else if (GET_CODE (operands[2]) != CONST_INT)\n+    emit_insn (gen_addsi_big_int (operands[0], operands[1], operands[2]));\n+  else if ((INTVAL (operands[2]) >= -16) && (INTVAL (operands[2]) <= 15))\n+    emit_insn (gen_addsi_small_int (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_addsi_big_int (operands[0], operands[1], operands[2]));\n+  DONE;\n+  }\"\n+)\n+\n+(define_insn \"addsi_regs\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"register_operand\"  \"r\")))]\n+  \"\"\n+  \"addn\t%2, %0\"\n+)\n+\n+(define_insn \"addsi_small_int\"\n+  [(set (match_operand:SI 0 \"register_operand\"              \"=r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\"      \"0,0\")\n+\t\t (match_operand:SI 2 \"add_immediate_operand\" \"I,J\")))]\n+  \"\"\n+  \"@\n+   addn\t%2, %0\n+   addn2\t%2, %0\"\n+)\n+\n+(define_expand \"addsi_big_int\"\n+  [(set (match_operand:SI 0 \"register_operand\"           \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\"  \"\")\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"{\n+  /* Cope with the possibility that ops 0 and 1 are the same register.  */\n+  if (REGNO (operands[0]) == REGNO (operands[1]))\n+    {\n+      if (reload_in_progress || reload_completed)\n+        {\n+\t  rtx reg = gen_rtx_REG (SImode, 0/*COMPILER_SCRATCH_REGISTER*/);\n+\t  \n+\t  emit_insn (gen_movsi (reg, operands[2]));\n+\t  emit_insn (gen_addsi_regs (operands[0], operands[0], reg));\n+\t}\n+      else\n+\t{\n+\t  operands[2] = force_reg (SImode, operands[2]);\n+\t  emit_insn (gen_addsi_regs (operands[0], operands[0], operands[2]));\n+\t}\n+    }\n+  else\n+    {\n+      emit_insn (gen_movsi (operands[0], operands[2]));\n+      emit_insn (gen_addsi_regs (operands[0], operands[0], operands[1]));\n+    }\n+  DONE;\n+  }\"\n+)\n+\n+(define_insn \"*addsi_for_reload\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=&r,r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\"  \"r,r,r\")\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"L,M,n\")))]\n+  \"reload_in_progress || reload_completed\"\n+  \"@\n+  ldi:8\\\\t#%2, %0  \\\\n\\\\taddn\\\\t%1, %0\n+  ldi:20\\\\t#%2, %0 \\\\n\\\\taddn\\\\t%1, %0\n+  ldi:32\\\\t#%2, %0 \\\\n\\\\taddn\\\\t%1, %0\"\n+  [(set_attr \"length\" \"4,6,8\")]\n+)\n+\n+;;}}}\n+;;{{{ Subtraction \n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"       \"=r\")\n+\t(minus (match_operand:SI 1 \"register_operand\" \"0\")\n+\t       (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"subn\t%2, %0\"\n+)\n+\n+;;}}}\n+;;{{{ Multiplication \n+\n+;; Signed multiplication producing 64 bit results from 32 bit inputs\n+(define_insn \"mulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\"                             \"=r\")\n+\t   (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%r\"))\n+\t\t    (sign_extend:DI (match_operand:SI 2 \"register_operand\"  \"r\"))))\n+   (clobber (reg:CC 16))]\n+  \"\"\n+  \"mul\t%2, %1\\\\n\\\\tmov\\\\tmdh, %0\\\\n\\\\tmov\\\\tmdl, %p0\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+;; Unsigned multiplication producing 64 bit results from 32 bit inputs\n+(define_insn \"umulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\"                             \"=r\")\n+\t   (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%r\"))\n+\t\t    (zero_extend:DI (match_operand:SI 2 \"register_operand\"  \"r\"))))\n+   (clobber (reg:CC 16))]\n+  \"\"\n+  \"mulu\t%2, %1\\\\n\\\\tmov\\\\tmdh, %0\\\\n\\\\tmov\\\\tmdl, %p0\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+;; Signed multiplication producing 32 bit result from 16 bit inputs\n+(define_insn \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"                             \"=r\")\n+\t   (mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%r\"))\n+\t\t    (sign_extend:SI (match_operand:HI 2 \"register_operand\"  \"r\"))))\n+   (clobber (reg:CC 16))]\n+  \"\"\n+  \"mulh\t%2, %1\\\\n\\\\tmov\\\\tmdl, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;; Unsigned multiplication producing 32 bit result from 16 bit inputs\n+(define_insn \"umulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"                             \"=r\")\n+\t   (mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%r\"))\n+\t\t    (zero_extend:SI (match_operand:HI 2 \"register_operand\"  \"r\"))))\n+   (clobber (reg:CC 16))]\n+  \"\"\n+  \"muluh\t%2, %1\\\\n\\\\tmov\\\\tmdl, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;; Signed multiplication producing 32 bit result from 32 bit inputs\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"             \"=r\")\n+\t   (mult:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t    (match_operand:SI 2 \"register_operand\"  \"r\")))\n+   (clobber (reg:CC 16))]\n+  \"\"\n+  \"mul\t%2, %1\\\\n\\\\tmov\\\\tmdl, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;;}}}\n+;;{{{ Negation \n+\n+(define_expand \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"{\n+  if (REGNO (operands[0]) == REGNO (operands[1]))\n+    {\n+      if (reload_in_progress || reload_completed)\n+        {\n+\t  rtx reg = gen_rtx_REG (SImode, 0/*COMPILER_SCRATCH_REGISTER*/);\n+\t  \n+\t  emit_insn (gen_movsi (reg, GEN_INT (0)));\n+\t  emit_insn (gen_subsi3 (reg, reg, operands[0]));\n+\t  emit_insn (gen_movsi (operands[0], reg));\n+\t}\n+      else\n+\t{\n+\t  rtx reg = gen_reg_rtx (SImode);\n+\t\n+\t  emit_insn (gen_movsi (reg, GEN_INT (0)));\n+\t  emit_insn (gen_subsi3 (reg, reg, operands[0]));\n+\t  emit_insn (gen_movsi (operands[0], reg));\n+\t}\n+    }\n+  else\n+    {\n+      emit_insn (gen_movsi_internal (operands[0], GEN_INT (0)));\n+      emit_insn (gen_subsi3 (operands[0], operands[0], operands[1]));\n+    }\n+  DONE;\n+  }\"\n+)\n+\n+;;}}}\n+\n+;;}}} \f\n+;;{{{ Shifts \n+\n+;; Arithmetic Shift Left\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"            \"=r,r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\"  \"0,0,0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"r,I,K\")))\n+   (clobber (reg:CC 16))]\n+  \"\"\n+  \"@\n+  lsl\t%2, %0\n+  lsl\t%2, %0\n+  lsl2\t%x2, %0\"\n+)\n+\n+;; Arithmetic Shift Right\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"              \"=r,r,r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\"  \"0,0,0\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"r,I,K\")))\n+   (clobber (reg:CC 16))]\n+  \"\"\n+  \"@\n+  asr\t%2, %0\n+  asr\t%2, %0\n+  asr2\t%x2, %0\"\n+)\n+\n+;; Logical Shift Right\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"              \"=r,r,r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"0,0,0\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"r,I,K\")))\n+   (clobber (reg:CC 16))]\n+  \"\"\n+  \"@\n+  lsr\t%2, %0\n+  lsr\t%2, %0\n+  lsr2\t%x2, %0\"\n+)\n+\n+;;}}} \f\n+;;{{{ Logical Operations \n+\n+;; Logical AND, 32 bit integers\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"register_operand\"  \"0\")))\n+   (clobber (reg:CC 16))]\n+  \"\"\n+  \"and\t%1, %0\"\n+)\n+\n+;; Inclusive OR, 32 bit integers\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"register_operand\"  \"0\")))\n+   (clobber (reg:CC 16))]\n+  \"\"\n+  \"or\t%1, %0\"\n+)\n+\n+;; Exclusive OR, 32 bit integers\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"register_operand\"  \"0\")))\n+   (clobber (reg:CC 16))]\n+  \"\"\n+  \"eor\t%1, %0\"\n+)\n+\n+;; One's complement, 32 bit integers\n+(define_expand \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"{\n+  if (REGNO (operands[0]) == REGNO (operands[1]))\n+    {\n+      if (reload_in_progress || reload_completed)\n+        {\n+\t  rtx reg = gen_rtx_REG (SImode, 0/*COMPILER_SCRATCH_REGISTER*/);\n+\t  \n+\t  emit_insn (gen_movsi (reg, GEN_INT (-1)));\n+\t  emit_insn (gen_xorsi3 (operands[0], operands[0], reg));\n+\t}\n+      else\n+\t{\n+\t  rtx reg = gen_reg_rtx (SImode);\n+\t\n+\t  emit_insn (gen_movsi (reg, GEN_INT (-1)));\n+\t  emit_insn (gen_xorsi3 (operands[0], operands[0], reg));\n+\t}\n+    }\n+  else\n+    {\n+      emit_insn (gen_movsi_internal (operands[0], GEN_INT (-1)));\n+      emit_insn (gen_xorsi3 (operands[0], operands[1], operands[0]));\n+    }\n+  DONE;\n+  }\"\n+)\n+\n+;;}}} \f\n+;;{{{ Comparisons \n+\n+;; Note, we store the operands in the comparison insns, and use them later\n+;; when generating the branch or scc operation.\n+\n+;; First the routines called by the machine independent part of the compiler\n+(define_expand \"cmpsi\"\n+  [(set (reg:CC 16)\n+        (compare:CC (match_operand:SI 0 \"register_operand\"  \"\")\n+\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"{\n+  fr30_compare_op0 = operands[0];\n+  fr30_compare_op1 = operands[1];\n+  DONE;\n+  }\"\n+)\n+\n+;; Now, the actual comparisons, generated by the branch and/or scc operations\n+\n+(define_insn \"*cmpsi_internal\"\n+  [(set (reg:CC 16)\n+\t(compare:CC (match_operand:SI 0 \"register_operand\"  \"r,r,r\")\n+\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"r,I,J\")))]\n+  \"\"\n+  \"@\n+  cmp\t%1, %0\n+  cmp\t%1, %0\n+  cmp2\t%1, %0\"\n+)\n+\n+;;}}} \f\n+;;{{{ Branches \n+\n+;; Define_expands called by the machine independent part of the compiler\n+;; to allocate a new comparison register\n+\n+(define_expand \"beq\"\n+  [(set (reg:CC 16)\n+\t(compare:CC (match_dup 1)\n+\t\t    (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (eq:CC (reg:CC 16)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"{\n+  operands[1] = fr30_compare_op0;\n+  operands[2] = fr30_compare_op1;\n+  }\"\n+)\n+\n+(define_expand \"bne\"\n+  [(set (reg:CC 16)\n+\t(compare:CC (match_dup 1)\n+\t\t    (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (ne:CC (reg:CC 16)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"{\n+  operands[1] = fr30_compare_op0;\n+  operands[2] = fr30_compare_op1;\n+  }\"\n+)\n+\n+(define_expand \"blt\"\n+  [(set (reg:CC 16)\n+\t(compare:CC (match_dup 1)\n+\t\t    (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (lt:CC (reg:CC 16)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"{\n+  operands[1] = fr30_compare_op0;\n+  operands[2] = fr30_compare_op1;\n+  }\"\n+)\n+\n+(define_expand \"ble\"\n+  [(set (reg:CC 16)\n+\t(compare:CC (match_dup 1)\n+\t\t    (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (le:CC (reg:CC 16)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"{\n+  operands[1] = fr30_compare_op0;\n+  operands[2] = fr30_compare_op1;\n+  }\"\n+)\n+\n+(define_expand \"bgt\"\n+  [(set (reg:CC 16)\n+\t(compare:CC (match_dup 1)\n+\t\t    (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (gt:CC (reg:CC 16)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"{\n+  operands[1] = fr30_compare_op0;\n+  operands[2] = fr30_compare_op1;\n+  }\"\n+)\n+\n+(define_expand \"bge\"\n+  [(set (reg:CC 16)\n+\t(compare:CC (match_dup 1)\n+\t\t    (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (ge:CC (reg:CC 16)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"{\n+  operands[1] = fr30_compare_op0;\n+  operands[2] = fr30_compare_op1;\n+  }\"\n+)\n+\n+(define_expand \"bltu\"\n+  [(set (reg:CC 16)\n+\t(compare:CC (match_dup 1)\n+\t\t    (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (ltu:CC (reg:CC 16)\n+\t\t\t      (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"{\n+  operands[1] = fr30_compare_op0;\n+  operands[2] = fr30_compare_op1;\n+  }\"\n+)\n+\n+(define_expand \"bleu\"\n+  [(set (reg:CC 16)\n+\t(compare:CC (match_dup 1)\n+\t\t    (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (leu:CC (reg:CC 16)\n+\t\t\t      (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"{\n+  operands[1] = fr30_compare_op0;\n+  operands[2] = fr30_compare_op1;\n+  }\"\n+)\n+\n+(define_expand \"bgtu\"\n+  [(set (reg:CC 16)\n+\t(compare:CC (match_dup 1)\n+\t\t    (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (gtu:CC (reg:CC 16)\n+\t\t\t      (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"{\n+  operands[1] = fr30_compare_op0;\n+  operands[2] = fr30_compare_op1;\n+  }\"\n+)\n+\n+(define_expand \"bgeu\"\n+  [(set (reg:CC 16)\n+\t(compare:CC (match_dup 1)\n+\t\t    (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (geu:CC (reg:CC 16)\n+\t\t\t      (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"{\n+  operands[1] = fr30_compare_op0;\n+  operands[2] = fr30_compare_op1;\n+  }\"\n+)\n+\n+;; Actual branches.  We must allow for the (label_ref) and the (pc) to be\n+;; swapped.  If they are swapped, it reverses the sense of the branch.\n+\n+;; This pattern matches the (branch-if-true) branches generated above.\n+;; It generates two different instruction sequences depending upon how\n+;; far away the destination is.\n+\n+;; The calculation for the instruction length is derived as follows:\n+;; The branch instruction has a 9 bit signed displacement so we have\n+;; this inequality for the displacement:\n+;;\n+;;               -256 <= pc < 256\n+;; or\n+;;\t   -256 + 256 <= pc + 256 < 256 + 256\n+;; ie\n+;;\t\t    0 <= pc + 256 < 512 \n+;;\n+;; if we consider the displacement as an unsigned value, then negative\n+;; displacements become very large positive displacements, and the\n+;; inequality becomes:\n+;;\n+;;\t\tpc + 256 < 512\n+;;\n+;; In order to allow for the fact that the real branch instruction works\n+;; from pc + 2, we increase the offset to 258.\n+;;\n+;; Note - we do not have to worry about whether the branch is delayed or\n+;; not, as branch shortening happens after delay slot reorganisation.\n+\n+(define_insn \"*branch_true\"\n+  [(set (pc)\n+\t(if_then_else (match_operator:CC 0 \"comparison_operator\"\n+\t\t\t\t\t [(reg:CC 16)\n+\t\t\t\t\t  (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+  {\n+    if (get_attr_length (insn) == 2)\n+      return \\\"b%b0%#\\\\t%l1\\\";\n+    else\n+      {\n+        static char buffer [100];\n+\tchar *      tmp_reg; \n+\tchar *      ldi_insn;\n+\t\n+        tmp_reg = reg_names [COMPILER_SCRATCH_REGISTER];\n+\t\n+\tldi_insn = TARGET_SMALL_MODEL ? \\\"ldi:20\\\" : \\\"ldi:32\\\";\n+\n+\t/* The code produced here is, for say the EQ case:\n+\n+\t       Bne  1f\n+\t       LDI  <label>, r0\n+\t       JMP  r0\n+\t     1:                                         */\n+\t     \n+\tsprintf (buffer,\n+\t  \\\"b%%B0\\\\t1f\\\\t;\\\\n\\\\t%s\\\\t%%l1, %s\\\\t;\\\\n\\\\tjmp%%#\\\\t@%s\\\\t;\\\\n1:\\\",\n+\t  ldi_insn, tmp_reg, tmp_reg);\n+ \n+        return buffer;\n+    }\n+  }\"\n+  [(set (attr \"length\") (if_then_else\n+\t\t\t  (ltu\n+\t\t\t    (plus\n+\t\t\t      (minus\n+\t\t\t        (match_dup 1)\n+\t\t\t\t(pc))\n+\t\t\t      (const_int 254))\n+\t\t\t    (const_int 506))\n+\t\t\t  (const_int 2)\n+\t\t\t  (if_then_else (eq_attr \"size\" \"small\")\n+\t\t\t\t\t(const_int 8)\n+\t\t\t\t\t(const_int 10))))\n+   (set_attr \"delay_type\" \"delayed\")]\n+)\n+\n+\n+;; This pattern is a duplicate of the previous one, except that the\n+;; branch occurs if the test is false, so the %B operator is used.\n+(define_insn \"*branch_false\"\n+  [(set (pc)\n+\t(if_then_else (match_operator:CC 0 \"comparison_operator\"\n+\t\t\t\t\t [(reg:CC 16)\n+\t\t\t\t\t  (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  {\n+    if (get_attr_length (insn) == 2)\n+      return \\\"b%B0%#\\\\t%l1 \\\";\n+    else\n+      {\n+        static char buffer [100];\n+\tchar *      tmp_reg; \n+\tchar *      ldi_insn;\n+\t\n+        tmp_reg = reg_names [COMPILER_SCRATCH_REGISTER];\n+\t\n+\tldi_insn = TARGET_SMALL_MODEL ? \\\"ldi:20\\\" : \\\"ldi:32\\\";\n+\n+\tsprintf (buffer,\n+\t  \\\"b%%b0\\\\t1f\\\\t;\\\\n\\\\t%s\\\\t%%l1, %s\\\\t;\\\\n\\\\tjmp%%#\\\\t@%s\\\\t;\\\\n1:\\\",\n+\t  ldi_insn, tmp_reg, tmp_reg);\n+ \n+        return buffer;\n+      }\n+  }\"\n+  [(set (attr \"length\") (if_then_else (ltu (plus (minus (match_dup 1) (pc))\n+\t\t\t\t\t\t (const_int 254))\n+\t\t\t\t\t   (const_int 506))\n+\t\t\t\t      (const_int 2)\n+\t\t\t\t      (if_then_else (eq_attr \"size\" \"small\")\n+\t\t\t\t\t\t    (const_int 8)\n+\t\t\t\t\t\t    (const_int 10))))\n+   (set_attr \"delay_type\" \"delayed\")]\n+)\n+\n+;;}}} \f\n+;;{{{ Calls & Jumps \n+\n+;; Subroutine call instruction returning no value.  Operand 0 is the function\n+;; to call; operand 1 is the number of bytes of arguments pushed (in mode\n+;; `SImode', except it is normally a `const_int'); operand 2 is the number of\n+;; registers used as operands.\n+\n+(define_insn \"call\"\n+  [(call (match_operand 0 \"call_operand\" \"Qrm\")\n+\t (match_operand 1 \"\"             \"g\"))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  \"call%#\\\\t%0\"\n+  [(set_attr \"delay_type\" \"delayed\")]\n+)\n+\n+;; Subroutine call instruction returning a value.  Operand 0 is the hard\n+;; register in which the value is returned.  There are three more operands, the\n+;; same as the three operands of the `call' instruction (but with numbers\n+;; increased by one).\n+\n+;; Subroutines that return `BLKmode' objects use the `call' insn.\n+\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"register_operand\"  \"=r\")\n+\t(call (match_operand 1 \"call_operand\" \"Qrm\")\n+\t      (match_operand 2 \"\"             \"g\")))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  \"call%#\\\\t%1\"\n+  [(set_attr \"delay_type\" \"delayed\")]\n+)\n+\n+;; Normal unconditional jump.\n+;; For a description of the computation of the length \n+;; attribute see the branch patterns above.\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+  {\n+    if (get_attr_length (insn) == 2)\n+       return \\\"bra%#\\\\t%0\\\";\n+    else\n+      {\n+        static char buffer [100];\n+\tchar *      tmp_reg; \n+\tchar *      ldi_insn;\n+\t\n+        tmp_reg = reg_names [COMPILER_SCRATCH_REGISTER];\n+\n+\tldi_insn = TARGET_SMALL_MODEL ? \\\"ldi:20\\\" : \\\"ldi:32\\\";\n+\n+\tsprintf (buffer, \\\"%s\\\\t%%0, %s\\\\t;\\\\n\\\\tjmp%%#\\\\t@%s\\\\t;\\\",\n+\t  ldi_insn, tmp_reg, tmp_reg);\n+ \n+        return buffer;\n+      }\n+  }\"\n+  [(set (attr \"length\") (if_then_else (ltu (plus (minus (match_dup 0) (pc))\n+\t\t\t\t\t\t(const_int 254))\n+\t\t\t\t\t  (const_int 506))\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (if_then_else (eq_attr \"size\" \"small\")\n+\t\t\t\t\t\t   (const_int 6)\n+\t\t\t\t\t\t   (const_int 8))))\n+   (set_attr \"delay_type\" \"delayed\")]\n+)\n+\n+;; Indirect jump through a register\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"nonimmediate_operand\" \"r\"))]\n+  \"GET_CODE (operands[0]) != MEM || GET_CODE (XEXP (operands[0], 0)) != PLUS\"\n+  \"jmp%#\\\\t@%0\"\n+  [(set_attr \"delay_type\" \"delayed\")]\n+)\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jmp%#\\\\t@%0\"\n+  [(set_attr \"delay_type\" \"delayed\")]\n+)\n+\n+;;}}} \f\n+;;{{{ Function Prologues and Epilogues \n+\n+;; Called after register allocation to add any instructions needed for the\n+;; prologue.  Using a prologue insn is favored compared to putting all of the\n+;; instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n+;; to intermix instructions with the saves of the caller saved registers.  In\n+;; some cases, it might be necessary to emit a barrier instruction as the last\n+;; insn to prevent such scheduling.\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"{\n+  fr30_expand_prologue ();\n+  DONE;\n+  }\"\n+)\n+\n+;; Called after register allocation to add any instructions needed for the\n+;; epilogue.  Using a epilogue insn is favored compared to putting all of the\n+;; instructions in the FUNCTION_EPILOGUE macro, since it allows the scheduler\n+;; to intermix instructions with the restores of the caller saved registers.\n+;; In some cases, it might be necessary to emit a barrier instruction as the\n+;; first insn to prevent such scheduling.\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"{\n+  fr30_expand_epilogue ();\n+  DONE;\n+  }\"\n+)\n+\n+(define_insn \"return_from_func\"\n+  [(return)\n+   (use (reg:SI 17))]\n+  \"reload_completed\"\n+  \"ret%#\"\n+  [(set_attr \"delay_type\" \"delayed\")]\n+)\n+\n+(define_insn \"leave_func\"\n+  [(set (reg:SI 15) (reg:SI 14))\n+   (set (reg:SI 14) (mem:SI (post_inc:SI (reg:SI 15))))]\n+  \"reload_completed\"\n+  \"leave\"\n+)\n+\n+(define_insn \"enter_func\"\n+  [(set:SI (mem:SI (minus:SI (reg:SI 15)\n+\t\t\t     (const_int 4)))\n+\t   (reg:SI 14))\n+   (set:SI (reg:SI 14)\n+\t   (minus:SI (reg:SI 15)\n+\t\t     (const_int 4)))\n+   (set:SI (reg:SI 15)\n+\t   (minus:SI (reg:SI 15)\n+\t\t     (match_operand 0 \"immediate_operand\" \"i\")))]\n+  \"reload_completed\"\n+  \"enter\t#%0\"\n+  [(set_attr \"delay_type\" \"other\")]\n+)\n+\n+;;}}} \f\n+;;{{{ Miscellaneous \n+\n+;; No operation, needed in case the user uses -g but not -O.\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+)\n+\n+;; Pseudo instruction that prevents the scheduler from moving code above this\n+;; point.\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")]\n+)\n+  \n+;; Local Variables:\n+;; mode: md\n+;; folded-file: t\n+;; End:\n+\n+;;}}} \f"}, {"sha": "13693276f160aa6f16a42fb99af2ff232021a549", "filename": "gcc/config/fr30/lib1funcs.asm", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Flib1funcs.asm?ref=309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "patch": "@@ -0,0 +1,126 @@\n+/* libgcc1 routines for the FR30.\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\t\n+\n+\t.macro FUNC_START name\n+\t.text\n+\t.globl __\\name\n+\t.type  __\\name, @function\n+__\\name:\n+\t.endm\n+\n+\t.macro FUNC_END name\n+\t.size  __\\name, . - __\\name\n+\t.endm\n+\n+\t.macro DIV_BODY reg number\n+\t.if \\number\n+\tDIV_BODY  \\reg, \"\\number - 1\"\n+\tdiv1\t\\reg\n+\t.endif\n+\t.endm\n+\t\n+#ifdef L_udivsi3\n+FUNC_START udivsi3\n+\t;; Perform an unsiged division of r4 / r5 and place the result in r4.\n+\t;; Does not handle overflow yet...\n+\tmov\tr4, mdl\n+\tdiv0u\tr5\n+\tDIV_BODY r5 32\n+\tmov\tmdl, r4\n+\tret\n+FUNC_END udivsi3\n+#endif /* L_udivsi3 */\n+\n+#ifdef L_divsi3\n+FUNC_START divsi3\n+\t;; Perform a siged division of r4 / r5 and place the result in r4.\n+\t;; Does not handle overflow yet...\n+\tmov\tr4, mdl\n+\tdiv0s\tr5\n+\tDIV_BODY r5 32\n+\tdiv2    r5\n+\tdiv3\n+\tdiv4s\n+\tmov\tmdl, r4\n+\tret\n+FUNC_END divsi3\n+#endif /* L_divsi3 */\n+\n+#ifdef L_umodsi3\n+FUNC_START umodsi3\n+\t;; Perform an unsiged division of r4 / r5 and places the remainder in r4.\n+\t;; Does not handle overflow yet...\n+\tmov\tr4, mdl\n+\tdiv0u\tr5\n+\tDIV_BODY r5 32\n+\tmov\tmdh, r4\n+\tret\n+FUNC_END umodsi3\n+#endif /* L_umodsi3 */\n+\n+#ifdef L_modsi3\n+FUNC_START modsi3\n+\t;; Perform a siged division of r4 / r5 and place the remainder in r4.\n+\t;; Does not handle overflow yet...\n+\tmov\tr4, mdl\n+\tdiv0s\tr5\n+\tDIV_BODY r5 32\n+\tdiv2    r5\n+\tdiv3\n+\tdiv4s\n+\tmov\tmdh, r4\n+\tret\n+FUNC_END modsi3\n+#endif /* L_modsi3 */\n+\n+#ifdef L_negsi2\n+FUNC_START negsi2\n+\tldi:8\t#0, r0\n+\tsub\tr4, r0\n+\tmov\tr0, r4\n+\tret\n+FUNC_END negsi2\n+#endif /* L_negsi2 */\n+\n+#ifdef L_one_cmplsi2\n+FUNC_START one_cmplsi2\n+\tldi:8\t#0xff, r0\n+\textsb\tr0\n+\teor\tr0, r4\n+\tret\n+FUNC_END one_cmplsi2\n+#endif /* L_one_cmplsi2 */\n+\n+"}, {"sha": "46387d8334d1077be61b086a77356af208f84619", "filename": "gcc/config/fr30/t-fr30", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Ft-fr30", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Ft-fr30", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ft-fr30?ref=309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "patch": "@@ -0,0 +1,47 @@\n+\n+# Name of assembly file containing libgcc1 functions.\n+# This entry must be present, but it can be empty if the target does\n+# not need any assembler functions to support its code generation.\n+# CROSS_LIBGCC1 =\n+#\n+# Alternatively if assembler functions *are* needed then define the\n+# entries below:\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC    = fr30/lib1funcs.asm\n+LIB1ASMFUNCS  = _udivsi3 _divsi3 _umodsi3 _modsi3\n+\n+# Assemble startup files.\n+crti.o: $(srcdir)/config/fr30/crti.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) -c -o crti.o -x assembler $(srcdir)/config/fr30/crti.asm\n+\n+crtn.o: $(srcdir)/config/fr30/crtn.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) -c -o crtn.o -x assembler $(srcdir)/config/fr30/crtn.asm\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so...\n+\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+\n+# If any special flags are necessary when building libgcc2 put them here.\n+#\n+# TARGET_LIBGCC2_CFLAGS\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+# Enable the following if multilibs are needed.\n+# See gcc/genmultilib, gcc/gcc.texi and gcc/tm.texi for a\n+# description of the options and their values.\n+#\n+# MULTILIB_OPTIONS    = \n+# MULTILIB_DIRNAMES   = \n+# MULTILIB_MATCHES    =\n+# MULTILIB_EXCEPTIONS =\n+# MULTILIB_EXTRA_OPTS = \n+#\n+# LIBGCC = stmp-multilib\n+# INSTALL_LIBGCC = install-multilib"}, {"sha": "a43a3324c371971ee7bc98e6a20f3950ff5852ea", "filename": "gcc/config/fr30/xm-fr30.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Fxm-fr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfig%2Ffr30%2Fxm-fr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Fxm-fr30.h?ref=309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "patch": "@@ -0,0 +1,47 @@\n+/* Definitions of FR30 target.\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Contributed by Cygnus Solutions.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define\tFALSE\t0\n+#define\tTRUE\t1\n+\n+/* A C expression for the status code to be returned when the compiler exits\n+   after serious errors.  */\n+#define FATAL_EXIT_CODE 33\n+\n+/* A C expression for the status code to be returned when the compiler exits\n+   without serious errors.  */\n+#define SUCCESS_EXIT_CODE 0\n+\n+/* Defined if the host machine stores words of multi-word values in big-endian\n+   order.  (GNU CC does not depend on the host byte ordering within a word.)  */\n+/* #define HOST_WORDS_BIG_ENDIAN 1 */\n+\n+/* In addition, configuration files for system V define `bcopy', `bzero' and\n+   `bcmp' as aliases.  Some files define `alloca' as a macro when compiled with\n+   GNU CC, in order to take advantage of the benefit of GNU CC's built-in\n+   `alloca'.  */\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+#include \"tm.h\"\n+\n+/* end of xm-fr30.h */"}, {"sha": "73e3b9a24e95218293c9e306ebc9ac7427e0a03e", "filename": "gcc/configure", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "patch": "@@ -3392,6 +3392,11 @@ for machine in $build $host $target; do\n \telxsi-elxsi-*)\n \t\tuse_collect2=yes\n \t\t;;\n+\tfr30-*-elf)\n+\t\ttm_file=\"fr30/fr30.h\"\n+\t\ttmake_file=fr30/t-fr30\n+\t\textra_parts=\"crti.o crtn.o crtbegin.o crtend.o\"\n+\t\t;;\n # This hasn't been upgraded to GCC 2.\n #\tfx80-alliant-*)\t\t\t# Alliant FX/80\n #\t\t;;"}, {"sha": "5db57ae10cb33ab1d8ab623271b2dd38224d6c71", "filename": "gcc/configure.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309dd885ff9f569aec12cb5e3281a3b4dd73a8e0/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=309dd885ff9f569aec12cb5e3281a3b4dd73a8e0", "patch": "@@ -865,6 +865,11 @@ changequote([,])dnl\n \telxsi-elxsi-*)\n \t\tuse_collect2=yes\n \t\t;;\n+\tfr30-*-elf)\n+\t\ttm_file=\"fr30/fr30.h\"\n+\t\ttmake_file=fr30/t-fr30\n+\t\textra_parts=\"crti.o crtn.o crtbegin.o crtend.o\"\n+\t\t;;\n # This hasn't been upgraded to GCC 2.\n #\tfx80-alliant-*)\t\t\t# Alliant FX/80\n #\t\t;;"}]}