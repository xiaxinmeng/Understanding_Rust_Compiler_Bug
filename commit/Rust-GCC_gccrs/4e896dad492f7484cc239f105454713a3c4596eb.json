{"sha": "4e896dad492f7484cc239f105454713a3c4596eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU4OTZkYWQ0OTJmNzQ4NGNjMjM5ZjEwNTQ1NDcxM2EzYzQ1OTZlYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-08-12T08:59:28Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-12T08:59:28Z"}, "message": "[Ada] Eliminate redundant range checks on conversions\n\nThis gets rid of redundant range checks generated in 5 out of the 9\ncases of scalar conversions, i.e. (integer, fixed-point, floating-point)\nconverted to (integer, fixed-point, floating-point).\n\nThe problem is that the Real_Range_Check routine rewrites the conversion\nnode into a conversion to the base type so, when its parent node is\nanalyzed, a new conversion to the subtype may be introduced, depending\non the context, giving rise to a second range check against the subtype\nbounds.\n\nThis change makes Real_Range_Check rewrite the expression of the\nconversion node instead of the node, so that the type of the node is\npreserved and no new conversion is introduced.  As a matter of fact,\nthis is exactly what happens in the float-to-float case which goes to\nthe Generate_Range_Check circuit instead and does not suffer from the\nduplication of range checks.\n\nFor the following procedure, the compiler must now generate exactly one\nrange check per nested function:\n\nprocedure P is\n\n  type I1 is new Integer range -100 .. 100;\n\n  type I2 is new Integer range -200 .. 200;\n\n  type D1 is delta 0.5 range -100.0 .. 100.0;\n\n  type D2 is delta 0.5 range -200.0 .. 200.0;\n\n  type F1 is new Long_Float range -100.0 .. 100.0;\n\n  type F2 is new Long_Float range -200.0 .. 200.0;\n\n  function Conv (A : I2) return I1 is\n  begin\n    return I1 (A);\n  end;\n\n  function Conv (A : D2) return I1 is\n  begin\n    return I1 (A);\n  end;\n\n  function Conv (A : F2) return I1 is\n  begin\n    return I1 (A);\n  end;\n\n  function Conv (A : I2) return D1 is\n  begin\n    return D1 (A);\n  end;\n\n  function Conv (A : D2) return D1 is\n  begin\n    return D1 (A);\n  end;\n\n  function Conv (A : F2) return D1 is\n  begin\n    return D1 (A);\n  end;\n\n  function Conv (A : I2) return F1 is\n  begin\n    return F1 (A);\n  end;\n\n  function Conv (A : D2) return F1 is\n  begin\n    return F1 (A);\n  end;\n\n  function Conv (A : F2) return F1 is\n  begin\n    return F1 (A);\n  end;\n\nbegin\n  null;\nend;\n\n2019-08-12  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch4.adb (Real_Range_Check): Do not rewrite the conversion\n\tnode but its expression instead, after having fetched its\n\tcurrent value.  Clear the Do_Range_Check flag on entry.  Return\n\tearly for a rewritten float-to-float conversion.  Remove\n\tredundant local variable.  Suppress all checks when inserting\n\tthe temporary and do not reanalyze the node.\n\nFrom-SVN: r274287", "tree": {"sha": "cd09f826db06fdc86d3ce5f01813709dbebd678f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd09f826db06fdc86d3ce5f01813709dbebd678f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e896dad492f7484cc239f105454713a3c4596eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e896dad492f7484cc239f105454713a3c4596eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e896dad492f7484cc239f105454713a3c4596eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e896dad492f7484cc239f105454713a3c4596eb/comments", "author": null, "committer": null, "parents": [{"sha": "5aa76fe17be6f6c222d16d5a51f60ed7755c6ad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa76fe17be6f6c222d16d5a51f60ed7755c6ad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aa76fe17be6f6c222d16d5a51f60ed7755c6ad6"}], "stats": {"total": 106, "additions": 62, "deletions": 44}, "files": [{"sha": "d30e8e9b72081095a01a0ddd094676ce428216d5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e896dad492f7484cc239f105454713a3c4596eb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e896dad492f7484cc239f105454713a3c4596eb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4e896dad492f7484cc239f105454713a3c4596eb", "patch": "@@ -1,3 +1,12 @@\n+2019-08-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch4.adb (Real_Range_Check): Do not rewrite the conversion\n+\tnode but its expression instead, after having fetched its\n+\tcurrent value.  Clear the Do_Range_Check flag on entry.  Return\n+\tearly for a rewritten float-to-float conversion.  Remove\n+\tredundant local variable.  Suppress all checks when inserting\n+\tthe temporary and do not reanalyze the node.\n+\n 2019-08-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sprint.ads: Minor comment tweak."}, {"sha": "43be9c9acb3fb9cd162a0d21554a22f759fa21c3", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 53, "deletions": 44, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e896dad492f7484cc239f105454713a3c4596eb/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e896dad492f7484cc239f105454713a3c4596eb/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=4e896dad492f7484cc239f105454713a3c4596eb", "patch": "@@ -11229,12 +11229,12 @@ package body Exp_Ch4 is\n \n       --     Tnn : typ'Base := typ'Base (x);\n       --     [constraint_error when Tnn < typ'First or else Tnn > typ'Last]\n-      --     Tnn\n+      --     typ (Tnn)\n \n       --  This is necessary when there is a conversion of integer to float or\n       --  to fixed-point to ensure that the correct checks are made. It is not\n-      --  necessary for float to float where it is enough to simply set the\n-      --  Do_Range_Check flag.\n+      --  necessary for the float-to-float case where it is enough to just set\n+      --  the Do_Range_Check flag on the expression.\n \n       procedure Real_Range_Check is\n          Btyp : constant Entity_Id := Base_Type (Target_Type);\n@@ -11246,6 +11246,7 @@ package body Exp_Ch4 is\n          Hi_Val : Node_Id;\n          Lo_Arg : Node_Id;\n          Lo_Val : Node_Id;\n+         Expr   : Entity_Id;\n          Tnn    : Entity_Id;\n \n       begin\n@@ -11255,6 +11256,12 @@ package body Exp_Ch4 is\n             return;\n          end if;\n \n+         Expr := Expression (N);\n+\n+         --  Clear the flag once for all\n+\n+         Set_Do_Range_Check (Expr, False);\n+\n          --  Nothing to do if range checks suppressed, or target has the same\n          --  range as the base type (or is the base type).\n \n@@ -11263,22 +11270,24 @@ package body Exp_Ch4 is\n                       and then\n                     Hi = Type_High_Bound (Btyp))\n          then\n-            --  Unset the range check flag on the current value of\n-            --  Expression (N), since the captured Operand may have\n-            --  been rewritten (such as for the case of a conversion\n-            --  to a fixed-point type).\n-\n-            Set_Do_Range_Check (Expression (N), False);\n             return;\n          end if;\n \n          --  Nothing to do if expression is an entity on which checks have been\n          --  suppressed.\n \n-         if Is_Entity_Name (Operand)\n-           and then Range_Checks_Suppressed (Entity (Operand))\n+         if Is_Entity_Name (Expr)\n+           and then Range_Checks_Suppressed (Entity (Expr))\n+         then\n+            return;\n+         end if;\n+\n+         --  Nothing to do if expression was rewritten into a float-to-float\n+         --  conversion, since this kind of conversions is handled elsewhere.\n+\n+         if Is_Floating_Point_Type (Etype (Expr))\n+           and then Is_Floating_Point_Type (Target_Type)\n          then\n-            Set_Do_Range_Check (Expression (N), False);\n             return;\n          end if;\n \n@@ -11288,12 +11297,12 @@ package body Exp_Ch4 is\n          --  not trust it to be in range (might be infinite)\n \n          declare\n-            S_Lo : constant Node_Id := Type_Low_Bound (Operand_Type);\n-            S_Hi : constant Node_Id := Type_High_Bound (Operand_Type);\n+            S_Lo : constant Node_Id := Type_Low_Bound (Etype (Expr));\n+            S_Hi : constant Node_Id := Type_High_Bound (Etype (Expr));\n \n          begin\n-            if (not Is_Floating_Point_Type (Operand_Type)\n-                 or else Is_Constrained (Operand_Type))\n+            if (not Is_Floating_Point_Type (Etype (Expr))\n+                 or else Is_Constrained (Etype (Expr)))\n               and then Compile_Time_Known_Value (S_Lo)\n               and then Compile_Time_Known_Value (S_Hi)\n               and then Compile_Time_Known_Value (Hi)\n@@ -11306,7 +11315,7 @@ package body Exp_Ch4 is\n                   S_Hiv : Ureal;\n \n                begin\n-                  if Is_Real_Type (Operand_Type) then\n+                  if Is_Real_Type (Etype (Expr)) then\n                      S_Lov := Expr_Value_R (S_Lo);\n                      S_Hiv := Expr_Value_R (S_Hi);\n                   else\n@@ -11318,7 +11327,6 @@ package body Exp_Ch4 is\n                     and then S_Lov >= D_Lov\n                     and then S_Hiv <= D_Hiv\n                   then\n-                     Set_Do_Range_Check (Expression (N), False);\n                      return;\n                   end if;\n                end;\n@@ -11327,18 +11335,21 @@ package body Exp_Ch4 is\n \n          --  Otherwise rewrite the conversion as described above\n \n-         Set_Do_Range_Check (Expression (N), False);\n+         Conv := Convert_To (Btyp, Expr);\n \n-         Conv := Relocate_Node (N);\n-         Rewrite (Subtype_Mark (Conv), New_Occurrence_Of (Btyp, Loc));\n-         Set_Etype (Conv, Btyp);\n+         --  If a conversion is necessary, then copy the specific flags from\n+         --  the original one and also move the Do_Overflow_Check flag since\n+         --  this new conversion is to the base type.\n \n-         --  Enable overflow except for case of integer to float conversions,\n-         --  where it is never required, since we can never have overflow in\n-         --  this case.\n+         if Nkind (Conv) = N_Type_Conversion then\n+            Set_Conversion_OK  (Conv, Conversion_OK  (N));\n+            Set_Float_Truncate (Conv, Float_Truncate (N));\n+            Set_Rounded_Result (Conv, Rounded_Result (N));\n \n-         if not Is_Integer_Type (Operand_Type) then\n-            Enable_Overflow_Check (Conv);\n+            if Do_Overflow_Check (N) then\n+               Set_Do_Overflow_Check (Conv);\n+               Set_Do_Overflow_Check (N, False);\n+            end if;\n          end if;\n \n          Tnn := Make_Temporary (Loc, 'T', Conv);\n@@ -11361,36 +11372,33 @@ package body Exp_Ch4 is\n          --  in systems where Duration is larger than Long_Integer.\n \n          if Is_Ordinary_Fixed_Point_Type (Target_Type)\n-           and then Is_Floating_Point_Type (Operand_Type)\n-           and then RM_Size (Base_Type (Target_Type)) <=\n-                    RM_Size (Standard_Long_Integer)\n+           and then Is_Floating_Point_Type (Etype (Expr))\n+           and then RM_Size (Btyp) <= RM_Size (Standard_Long_Integer)\n            and then Nkind (Lo) = N_Real_Literal\n            and then Nkind (Hi) = N_Real_Literal\n          then\n-            --  Find the integer type of the right size to perform an unchecked\n-            --  conversion to the target fixed-point type.\n-\n             declare\n-               Bfx_Type : constant Entity_Id := Base_Type (Target_Type);\n-               Expr_Id  : constant Entity_Id :=\n-                            Make_Temporary (Loc, 'T', Conv);\n+               Expr_Id : constant Entity_Id := Make_Temporary (Loc, 'T', Conv);\n                Int_Type : Entity_Id;\n \n             begin\n-               if RM_Size (Bfx_Type) > RM_Size (Standard_Integer) then\n+               --  Find an integer type of the appropriate size to perform an\n+               --  unchecked conversion to the target fixed-point type.\n+\n+               if RM_Size (Btyp) > RM_Size (Standard_Integer) then\n                   Int_Type := Standard_Long_Integer;\n \n-               elsif RM_Size (Bfx_Type) > RM_Size (Standard_Short_Integer) then\n+               elsif RM_Size (Btyp) > RM_Size (Standard_Short_Integer) then\n                   Int_Type := Standard_Integer;\n \n                else\n                   Int_Type := Standard_Short_Integer;\n                end if;\n \n                --  Generate a temporary with the integer value. Required in the\n-               --  CCG compiler to ensure that runtime checks reference this\n+               --  CCG compiler to ensure that run-time checks reference this\n                --  integer expression (instead of the resulting fixed-point\n-               --  value) because fixed-point values are handled by means of\n+               --  value because fixed-point values are handled by means of\n                --  unsigned integer types).\n \n                Insert_Action (N,\n@@ -11443,7 +11451,8 @@ package body Exp_Ch4 is\n                 Attribute_Name => Name_Last);\n          end if;\n \n-         --  Build code for range checking\n+         --  Build code for range checking. Note that checks are suppressed\n+         --  here since we don't want a recursive range check popping up.\n \n          Insert_Actions (N, New_List (\n            Make_Object_Declaration (Loc,\n@@ -11464,10 +11473,10 @@ package body Exp_Ch4 is\n                   Make_Op_Gt (Loc,\n                     Left_Opnd  => Hi_Arg,\n                     Right_Opnd => Hi_Val)),\n-              Reason   => CE_Range_Check_Failed)));\n+              Reason   => CE_Range_Check_Failed)),\n+           Suppress => All_Checks);\n \n-         Rewrite (N, New_Occurrence_Of (Tnn, Loc));\n-         Analyze_And_Resolve (N, Btyp);\n+         Rewrite (Expr, New_Occurrence_Of (Tnn, Loc));\n       end Real_Range_Check;\n \n       -----------------------------"}]}