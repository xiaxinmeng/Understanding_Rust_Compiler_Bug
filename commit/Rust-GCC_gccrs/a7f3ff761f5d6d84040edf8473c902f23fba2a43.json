{"sha": "a7f3ff761f5d6d84040edf8473c902f23fba2a43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdmM2ZmNzYxZjVkNmQ4NDA0MGVkZjg0NzNjOTAyZjIzZmJhMmE0Mw==", "commit": {"author": {"name": "Robert Schuster", "email": "robertschuster@fsfe.org", "date": "2006-02-03T13:47:51Z"}, "committer": {"name": "Robert Schuster", "email": "rschuster@gcc.gnu.org", "date": "2006-02-03T13:47:51Z"}, "message": "re PR libgcj/26073 (libjava fails to compile)\n\nFixes PR #26073.\n\n2006-02-03  Robert Schuster  <robertschuster@fsfe.org>\n\n\t* include/jvm.h:\n\t(_Jv_Linker::create_error_method): New method declaration.\n\t* link.cc:\n\t(_Jv_Linker::create_error_method): New method.\n\t(_Jv_Linker::link_symbol_table): Use new method above.\n\nFrom-SVN: r110543", "tree": {"sha": "b0c60c99de505db1e6a5f18abcad4fea5a1a875a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0c60c99de505db1e6a5f18abcad4fea5a1a875a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7f3ff761f5d6d84040edf8473c902f23fba2a43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f3ff761f5d6d84040edf8473c902f23fba2a43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7f3ff761f5d6d84040edf8473c902f23fba2a43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f3ff761f5d6d84040edf8473c902f23fba2a43/comments", "author": null, "committer": null, "parents": [{"sha": "ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab184b2a8fed51da5abc8af01a3258b9090f4aaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab184b2a8fed51da5abc8af01a3258b9090f4aaf"}], "stats": {"total": 108, "additions": 63, "deletions": 45}, "files": [{"sha": "92ebb77b6baf41b7d86ddcaf3328a21ee511156d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f3ff761f5d6d84040edf8473c902f23fba2a43/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f3ff761f5d6d84040edf8473c902f23fba2a43/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a7f3ff761f5d6d84040edf8473c902f23fba2a43", "patch": "@@ -1,3 +1,11 @@\n+2006-02-03  Robert Schuster  <robertschuster@fsfe.org>\n+\n+\t* include/jvm.h:\n+\t(_Jv_Linker::create_error_method): New method declaration.\n+\t* link.cc:\n+\t(_Jv_Linker::create_error_method): New method.\n+\t(_Jv_Linker::link_symbol_table): Use new method above.\n+\n 2006-02-01  Robert Schuster  <robertschuster@fsfe.org>\n \n \t* link.cc:"}, {"sha": "b0b330583074373604864f4e3ccd3303a450ccdd", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f3ff761f5d6d84040edf8473c902f23fba2a43/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f3ff761f5d6d84040edf8473c902f23fba2a43/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=a7f3ff761f5d6d84040edf8473c902f23fba2a43", "patch": "@@ -264,6 +264,7 @@ class _Jv_Linker\n   static _Jv_Method *search_method_in_class (jclass, jclass,\n \t\t\t\t\t     _Jv_Utf8Const *,\n \t\t\t\t\t     _Jv_Utf8Const *);\n+  static void *create_error_method(_Jv_Utf8Const *);\n \n public:\n "}, {"sha": "83681fed1435e76d27d738299e263082d8b25599", "filename": "libjava/link.cc", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f3ff761f5d6d84040edf8473c902f23fba2a43/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f3ff761f5d6d84040edf8473c902f23fba2a43/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=a7f3ff761f5d6d84040edf8473c902f23fba2a43", "patch": "@@ -767,6 +767,7 @@ _Jv_ThrowNoSuchMethodError ()\n   throw new java::lang::NoSuchMethodError;\n }\n \n+#ifdef USE_LIBFFI\n // A function whose invocation is prepared using libffi. It gets called\n // whenever a static method of a missing class is invoked. The data argument\n // holds a reference to a String denoting the missing class.\n@@ -777,14 +778,18 @@ _Jv_ThrowNoClassDefFoundErrorTrampoline(ffi_cif *,\n                                         void **,\n                                         void *data)\n {\n-  throw new java::lang::NoClassDefFoundError((jstring) data);\n+  throw new java::lang::NoClassDefFoundError(\n+    _Jv_NewStringUtf8Const( (_Jv_Utf8Const *) data));\n }\n-\n+#else\n+// A variant of the NoClassDefFoundError throwing method that can\n+// be used without libffi.\n void\n _Jv_ThrowNoClassDefFoundError()\n {\n   throw new java::lang::NoClassDefFoundError();\n }\n+#endif\n \n // Throw a NoSuchFieldError.  Called by compiler-generated code when\n // an otable entry is zero.  OTABLE_INDEX is the index in the caller's\n@@ -950,6 +955,51 @@ _Jv_Linker::find_iindex (jclass *ifaces, jshort *offsets, jshort num)\n }\n \n \n+void *\n+_Jv_Linker::create_error_method (_Jv_Utf8Const *class_name)\n+{\n+#ifdef USE_LIBFFI\n+  // TODO: The following structs/objects are heap allocated are\n+  // unreachable by the garbage collector:\n+  // - cif, arg_types\n+\n+  ffi_closure *closure = (ffi_closure *) _Jv_Malloc( sizeof( ffi_closure ));\n+  ffi_cif *cif = (ffi_cif *) _Jv_Malloc( sizeof( ffi_cif ));\n+\n+  // Pretends that we want to call a void (*) (void) function via\n+  // ffi_call.\n+  ffi_type **arg_types = (ffi_type **) _Jv_Malloc( sizeof( ffi_type * ));\n+  arg_types[0] = &ffi_type_void;\n+\n+  // Initializes the cif and the closure. If that worked the closure is\n+  // returned and can be used as a function pointer in a class' atable.\n+  if (ffi_prep_cif (\n+        cif, FFI_DEFAULT_ABI, 1, &ffi_type_void, arg_types) == FFI_OK\n+      && (ffi_prep_closure (\n+            closure, cif, _Jv_ThrowNoClassDefFoundErrorTrampoline,\n+            class_name) == FFI_OK))\n+    {\n+      return closure;\n+    }\n+    else\n+    {\n+      java::lang::StringBuffer *buffer = new java::lang::StringBuffer();\n+      buffer->append(\n+        JvNewStringLatin1(\"Error setting up FFI closure\"\n+                          \" for static method of missing class: \"));\n+      \n+      buffer->append (_Jv_NewStringUtf8Const(class_name));\n+\n+      throw new java::lang::InternalError(buffer->toString());\n+    }\n+#else\n+  // Codepath for platforms which do not support (or want) libffi.\n+  // You have to accept that it is impossible to provide the name\n+  // of the missing class then.\n+  return _Jv_ThrowNoClassDefFoundError;\n+#endif\n+}\n+\n // Functions for indirect dispatch (symbolic virtual binding) support.\n \n // There are three tables, atable otable and itable.  atable is an\n@@ -1118,46 +1168,7 @@ _Jv_Linker::link_symbol_table (jclass klass)\n       // code in classes where the missing class is part of the\n       // execution environment as long as it is never referenced.\n       if (target_class == NULL)\n-        {\n-          // TODO: The following structs/objects are heap allocated are\n-          // unreachable by the garbage collector:\n-          // - cif, arg_types\n-          // - the Java string inside the if-statement\n-\n-          ffi_closure *closure =\n-            (ffi_closure *) _Jv_Malloc( sizeof( ffi_closure ));\n-          ffi_cif *cif = (ffi_cif *) _Jv_Malloc( sizeof( ffi_cif ));\n-\n-          // Pretends that we want to call a void (*) (void) function via\n-          // ffi_call.\n-          ffi_type **arg_types = (ffi_type **) _Jv_Malloc( sizeof( ffi_type * ));\n-          arg_types[0] = &ffi_type_void;\n-\n-          // Initializes the cif and the closure. If that worked the closure is\n-          // stored as a function pointer in the atable.\n-          if ( ffi_prep_cif(cif, FFI_DEFAULT_ABI, 1,\n-                            &ffi_type_void, arg_types) == FFI_OK\n-               && (ffi_prep_closure \n-                   (closure, cif,\n-                   _Jv_ThrowNoClassDefFoundErrorTrampoline,\n-                   (void *) _Jv_NewStringUtf8Const(sym.class_name))\n-                   == FFI_OK))\n-            {\n-              klass->atable->addresses[index] = (void *) closure;\n-            }\n-          else\n-            {\n-              // If you land here it is possible that your architecture does\n-              // not support the Closure API yet. Let's port it!\n-              java::lang::StringBuffer *buffer = new java::lang::StringBuffer();\n-              buffer->append \n-                (JvNewStringLatin1(\"Error setting up FFI closure\"\n-                                   \" for static method of missing class: \"));\n-              buffer->append (_Jv_NewStringUtf8Const(sym.class_name));\n-\n-              throw new java::lang::InternalError(buffer->toString());\n-            }\n-        }\n+        klass->atable->addresses[index] = create_error_method(sym.class_name);\n       // We're looking for a static field or a static method, and we\n       // can tell which is needed by looking at the signature.\n       else if (signature->first() == '(' && signature->len() >= 2)\n@@ -1198,10 +1209,8 @@ _Jv_Linker::link_symbol_table (jclass klass)\n \t\t}\n \t    }\n \t  else\n-            // TODO: Use _Jv_ThrowNoClassDefFoundErrorTrampoline to be able\n-            // to print the class name.\n \t    klass->atable->addresses[index]\n-\t\t= (void *) _Jv_ThrowNoClassDefFoundError;\n+              = create_error_method(sym.class_name);\n \n \t  continue;\n \t}"}]}