{"sha": "a58942422c0b4b60efa76fd7261961c1d4ea612a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU4OTQyNDIyYzBiNGI2MGVmYTc2ZmQ3MjYxOTYxYzFkNGVhNjEyYQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-05-01T21:36:30Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-05-01T21:36:30Z"}, "message": "68th Cygnus<->FSF merge\n\nFrom-SVN: r9555", "tree": {"sha": "f55181d11e596ce4e3e70758e2a9719c1df1da98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f55181d11e596ce4e3e70758e2a9719c1df1da98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a58942422c0b4b60efa76fd7261961c1d4ea612a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a58942422c0b4b60efa76fd7261961c1d4ea612a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a58942422c0b4b60efa76fd7261961c1d4ea612a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a58942422c0b4b60efa76fd7261961c1d4ea612a/comments", "author": null, "committer": null, "parents": [{"sha": "896fc322095445704ce26291914335cf44902de1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/896fc322095445704ce26291914335cf44902de1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/896fc322095445704ce26291914335cf44902de1"}], "stats": {"total": 528, "additions": 351, "deletions": 177}, "files": [{"sha": "8347b18ca9fa513ba4b7df04bc911ee5e4357985", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a58942422c0b4b60efa76fd7261961c1d4ea612a", "patch": "@@ -1,3 +1,97 @@\n+Fri Apr 28 07:58:41 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* lex.c (cons_up_default_function): Fix linkage of #pragma\n+\timplemented functions.\n+\n+Thu Apr 27 16:56:24 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* method.c (build_overload_name): Simplify and fix repeated type\n+\tfolding.\n+\n+\t* decl.c (grokdeclarator): Prohibit pointers to void or reference\n+        members.\n+\n+Thu Apr 27 09:49:07 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck2.c (process_init_constructor): Make sure initializers are\n+\tfully digested.\n+\n+Thu Apr 27 01:11:55 1995  Jason Merrill  <jason@python.cygnus.com>\n+\n+\t* lex.c (cons_up_default_function): Always defer synthesis.\n+\n+Thu Apr 27 00:20:37 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl2.c (mark_inline_for_output): Don't play with pending_inline\n+\tstuff.\n+\n+Wed Apr 26 17:48:24 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (user_harshness): New function; like build_type_conversion,\n+\tbut doesn't actually build anything.\n+\t(compute_conversion_costs): Use it instead of build_type_conversion.\n+\n+Wed Apr 26 17:11:25 1995  Jason Merrill  <jason@deneb.cygnus.com>\n+\n+\t* typeck.c (build_function_call_real): Improve error message for\n+\tcalling a non-function.\n+\n+\t* method.c (hack_identifier): Lose check for calling a data member.\n+\n+Wed Apr 26 16:59:13 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck2.c (build_functional_cast): Remove very old cruft.\n+\tSeems like good code is generated without it.\n+\n+Wed Apr 26 00:47:16 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* method.c (do_build_assign_ref): Fix handling of anonymous unions.\n+\t(do_build_copy_constructor): Ditto.\n+\n+\t* parse.y (simple_stmt, SWITCH): Call {push,pop}_switch.\n+\n+\t* decl.c (push_switch): New function.\n+\t(pop_switch): Ditto.\n+\t(define_case_label): Check for jumping over initialization.\n+\n+\t* call.c (build_method_call): Check for an inline function being\n+\tcalled before its definition has been seen.\n+\t* typeck.c (build_function_call_real): Ditto.\n+\n+\t* decl.c (duplicate_decls): Check for a function being redeclared\n+\tinline after its address has been taken.\n+\n+\t* typeck.c (build_conditional_expr): Handle related class lvalues.\n+\n+Tue Apr 25 13:20:45 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* pt.c (do_pending_expansions): Don't expand unused templates.\n+\n+\t* parse.y (component_decl): Accept a lone semicolon.\n+\n+Tue Apr 25 00:25:56 1995  Jason Merrill  <jason@rtl.cygnus.com>\n+\n+\t* call.c (build_method_call): Don't allow an RTL_EXPR to serve as the\n+\tobject parameter anymore.\n+\n+\t* expr.c (cplus_expand_expr): Don't create RTL_EXPRs with no insns.\n+\n+Mon Apr 24 12:35:48 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* parse.y (simple_stmt, decl case): Clear prefix_attributes.\n+\t(lang_extdef): Ditto.\n+\n+\t* parse.y (maybe_parmlist): New rule for use in declarators where\n+\tthis could either be a list of expressions or parameters.  Calls\n+\tsuspend_momentary before deciding which.\n+\t(direct_after_type_declarator): Use it.\n+\t(complex_direct_notype_declarator): Use it.\n+\n+\t* pt.c (tsubst): Propagate attributes const and noreturn.\n+\n+\t* typeck.c (build_modify_expr): If warn_synth, call build_opfncall\n+\tbefore doing the default thing.\n+\n Thu Apr 27 21:49:36 1995  Doug Evans  <dje@cygnus.com>\n \n \t* typeck.c (common_type): Call lookup_attribute instead of"}, {"sha": "6779c84fa524f2f07f8f6687f99729d494af5a81", "filename": "gcc/cp/call.c", "status": "modified", "additions": 54, "deletions": 30, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a58942422c0b4b60efa76fd7261961c1d4ea612a", "patch": "@@ -585,6 +585,47 @@ convert_harshness (type, parmtype, parm)\n   return EVIL_RETURN (h);\n }\n \n+int\n+user_harshness (type, parmtype, parm)\n+     register tree type, parmtype;\n+     tree parm;\n+{\n+  tree conv;\n+  tree winner = NULL_TREE;\n+  int code;\n+\n+  {\n+    tree typename = build_typename_overload (type);\n+    if (lookup_fnfields (TYPE_BINFO (parmtype), typename, 0))\n+      return 0;\n+  }\n+\t\t\t\n+  for (conv = lookup_conversions (parmtype); conv; conv = TREE_CHAIN (conv))\n+    {\n+      struct harshness_code tmp;\n+\n+      if (winner && TREE_PURPOSE (winner) == TREE_PURPOSE (conv))\n+\tcontinue;\n+\n+      if (tmp = convert_harshness (type, TREE_VALUE (conv), NULL_TREE),\n+\t  tmp.code < USER_CODE)\n+\t{\n+\t  if (winner)\n+\t    return EVIL_CODE;\n+\t  else\n+\t    {\n+\t      winner = conv;\n+\t      code = tmp.code;\n+\t    }\n+\t}\n+    }\n+\n+  if (winner)\n+    return code;\n+\n+  return -1;\n+}\n+\n int\n can_convert (to, from)\n      tree to, from;\n@@ -884,30 +925,14 @@ compute_conversion_costs (function, tta_in, cp, arglen)\n \t\t  if (TYPE_LANG_SPECIFIC (actual_type)\n \t\t      && TYPE_HAS_CONVERSION (actual_type))\n \t\t    {\n-\t\t      tree conv;\n-\t\t      /* Don't issue warnings since we're only groping\n-\t\t\t around for the right answer, we haven't yet\n-\t\t\t committed to going with this solution.  */\n-\t\t      int old_inhibit_warnings = inhibit_warnings;\n-\n-\t\t      inhibit_warnings = 1;\n-\t\t      conv = build_type_conversion\n-\t\t\t(CALL_EXPR, formal_type, TREE_VALUE (tta), 0);\n-\t\t      inhibit_warnings = old_inhibit_warnings;\n-\n-\t\t      if (conv)\n+\t\t      int extra = user_harshness (formal_type, actual_type);\n+\n+\t\t      if (extra == EVIL_CODE)\n+\t\t\twin += 2;\n+\t\t      else if (extra >= 0)\n \t\t\t{\n-\t\t\t  if (conv == error_mark_node\n-\t\t\t      || (TREE_CODE (TREE_VALUE (ttf)) == REFERENCE_TYPE\n-\t\t\t\t  && ! TYPE_READONLY (TREE_VALUE (TREE_VALUE (ttf)))\n-\t\t\t\t  && ! lvalue_p (conv)))\n-\t\t\t    win += 2;\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      win++;\n-\t\t\t      if (TREE_CODE (conv) != CALL_EXPR)\n-\t\t\t\textra_conversions = 1;\n-\t\t\t    }\n+\t\t\t  win++;\n+\t\t\t  extra_conversions = extra;\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -1789,11 +1814,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    }\n \t  else\n \t    {\n-\t      if (TREE_CODE (instance) != CALL_EXPR\n-#ifdef PCC_STATIC_STRUCT_RETURN\n-\t\t  && TREE_CODE (instance) != RTL_EXPR\n-#endif\n-\t\t  )\n+\t      if (TREE_CODE (instance) != CALL_EXPR)\n \t\tmy_friendly_abort (125);\n \t      if (TYPE_NEEDS_CONSTRUCTING (basetype))\n \t\tinstance = build_cplus_new (basetype, instance, 0);\n@@ -2397,13 +2418,16 @@ build_method_call (instance, name, parms, basetype_path, flags)\n #if 1\n   /* Is it a synthesized method that needs to be synthesized?  */\n   if (DECL_ARTIFICIAL (function) && ! flag_no_inline\n-      && DECL_SAVED_INSNS (function) == 0\n-      && ! TREE_ASM_WRITTEN (function)\n+      && ! DECL_INITIAL (function)\n       /* Kludge: don't synthesize for default args.  */\n       && current_function_decl)\n     synthesize_method (function);\n #endif\n \n+  if (pedantic && DECL_THIS_INLINE (function) && ! DECL_ARTIFICIAL (function)\n+       && ! DECL_INITIAL (function) && ! DECL_PENDING_INLINE_INFO (function))\n+    cp_pedwarn (\"inline function `%#D' called before definition\", function);\n+\n   fntype = TREE_TYPE (function);\n   if (TREE_CODE (fntype) == POINTER_TYPE)\n     fntype = TREE_TYPE (fntype);"}, {"sha": "dcabbd22284e9c5ed035953ecc0993389143e6ae", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a58942422c0b4b60efa76fd7261961c1d4ea612a", "patch": "@@ -2315,6 +2315,11 @@ duplicate_decls (newdecl, olddecl)\n \t\t\t\t olddecl);\n \t\t  }\n \t      }\n+\n+\t  if (DECL_THIS_INLINE (newdecl) && ! DECL_THIS_INLINE (olddecl)\n+\t      && TREE_ADDRESSABLE (olddecl))\n+\t    cp_pedwarn (\"`%#D' was used before it was declared inline\",\n+\t\t\tnewdecl);\n \t}\n       /* These bits are logically part of the type for non-functions.  */\n       else if (TREE_READONLY (newdecl) != TREE_READONLY (olddecl)\n@@ -3660,26 +3665,77 @@ define_label (filename, line, name)\n     }\n }\n \n+struct cp_switch\n+{\n+  struct binding_level *level;\n+  struct cp_switch *next;\n+};\n+\n+static struct cp_switch *switch_stack;\n+\n+void\n+push_switch ()\n+{\n+  struct cp_switch *p\n+    = (struct cp_switch *) oballoc (sizeof (struct cp_switch));\n+  p->level = current_binding_level;\n+  p->next = switch_stack;\n+  switch_stack = p;\n+}\n+\n+void\n+pop_switch ()\n+{\n+  switch_stack = switch_stack->next;\n+}\n+\n /* Same, but for CASE labels.  If DECL is NULL_TREE, it's the default.  */\n /* XXX Note decl is never actually used. (bpk) */\n void\n define_case_label (decl)\n      tree decl;\n {\n   tree cleanup = last_cleanup_this_contour ();\n+  struct binding_level *b = current_binding_level;\n+  int identified = 0;\n+\n   if (cleanup)\n     {\n       static int explained = 0;\n-      cp_error_at (\"destructor needed for `%#D'\", TREE_PURPOSE (cleanup));\n-      error (\"where case label appears here\");\n+      cp_warning_at (\"destructor needed for `%#D'\", TREE_PURPOSE (cleanup));\n+      warning (\"where case label appears here\");\n       if (!explained)\n \t{\n-\t  error (\"(enclose actions of previous case statements requiring\");\n-\t  error (\"destructors in their own binding contours.)\");\n+\t  warning (\"(enclose actions of previous case statements requiring\");\n+\t  warning (\"destructors in their own binding contours.)\");\n \t  explained = 1;\n \t}\n     }\n \n+  for (; b && b != switch_stack->level; b = b->level_chain)\n+    {\n+      tree new_decls = b->names;\n+      for (; new_decls; new_decls = TREE_CHAIN (new_decls))\n+\t{\n+\t  if (TREE_CODE (new_decls) == VAR_DECL\n+\t      /* Don't complain about crossing initialization\n+\t\t of internal entities.  They can't be accessed,\n+\t\t and they should be cleaned up\n+\t\t by the time we get to the label.  */\n+\t      && ! DECL_ARTIFICIAL (new_decls)\n+\t      && ((DECL_INITIAL (new_decls) != NULL_TREE\n+\t\t   && DECL_INITIAL (new_decls) != error_mark_node)\n+\t\t  || TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (new_decls))))\n+\t    {\n+\t      if (! identified)\n+\t\terror (\"jump to case label\");\n+\t      identified = 1;\n+\t      cp_error_at (\"  crosses initialization of `%#D'\",\n+\t\t\t   new_decls);\n+\t    }\n+\t}\n+    }\n+\n   /* After labels, make any new cleanups go into their\n      own new (temporary) binding contour.  */\n \n@@ -8428,6 +8484,15 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t      continue;\n \t    }\n \n+\t  if (TREE_CODE (type) == OFFSET_TYPE\n+\t      && (TREE_CODE (TREE_TYPE (type)) == VOID_TYPE\n+\t\t  || TREE_CODE (TREE_TYPE (type)) == REFERENCE_TYPE))\n+\t    {\n+\t      cp_error (\"cannot declare pointer to `%#T' member\",\n+\t\t\tTREE_TYPE (type));\n+\t      type = TREE_TYPE (type);\n+\t    }\n+\n \t  /* Merge any constancy or volatility into the target type\n \t     for the pointer.  */\n "}, {"sha": "6e4ad20a964d3d668768d642860d049c7945c1bb", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a58942422c0b4b60efa76fd7261961c1d4ea612a", "patch": "@@ -2078,6 +2078,7 @@ mark_inline_for_output (decl)\n     return;\n   my_friendly_assert (TREE_PERMANENT (decl), 363);\n   DECL_SAVED_INLINE (decl) = 1;\n+#if 0\n   if (DECL_PENDING_INLINE_INFO (decl) != 0\n       && ! DECL_PENDING_INLINE_INFO (decl)->deja_vu)\n     {\n@@ -2097,6 +2098,7 @@ mark_inline_for_output (decl)\n \t}\n       DECL_PENDING_INLINE_INFO (decl) = 0;\n     }\n+#endif\n   saved_inlines = perm_tree_cons (NULL_TREE, decl, saved_inlines);\n }\n "}, {"sha": "c722dcbe6e0682fb393fca8f3f182a975372c575", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=a58942422c0b4b60efa76fd7261961c1d4ea612a", "patch": "@@ -151,17 +151,20 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t\textern int flag_access_control;\n \t\tint old_ac = flag_access_control;\n \n-\t\ttree init = build (RTL_EXPR, type, 0, return_target);\n+\t\ttree init = build_decl (VAR_DECL, 0, type);\n \t\tTREE_ADDRESSABLE (init) = 1;\n+\t\tDECL_RTL (init) = return_target;\n \n \t\tflag_access_control = 0;\n \t\texpand_aggr_init (slot, init, 0, LOOKUP_ONLYCONVERTING);\n \t\tflag_access_control = old_ac;\n \n \t\tif (TYPE_NEEDS_DESTRUCTOR (type))\n \t\t  {\n-\t\t    init = build (RTL_EXPR, build_reference_type (type), 0,\n-\t\t\t\t  XEXP (return_target, 0));\n+\t\t    init = build_decl (VAR_DECL, 0,\n+\t\t\t\t       build_reference_type (type));\n+\t\t    DECL_RTL (init) = XEXP (return_target, 0);\n+\n \t\t    init = maybe_build_cleanup (convert_from_reference (init));\n \t\t    if (init != NULL_TREE)\n \t\t      expand_expr (init, 0, 0, 0);"}, {"sha": "68623b2d292dd5f1b593775e0b2f5ff3fb0ffee5", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=a58942422c0b4b60efa76fd7261961c1d4ea612a", "patch": "@@ -1321,6 +1321,17 @@ main()\n @}\n @end example\n \n+@section Linkage\n+The linkage code in g++ is horribly twisted in order to meet two design goals:\n+\n+1) Avoid unnecessary emission of inlines and vtables.\n+\n+2) Support pedantic assemblers like the one in AIX.\n+\n+To meet the first goal, we defer emission of inlines and vtables until\n+the end of the translation unit, where we can decide whether or not they\n+are needed, and how to emit them if they are.\n+\n @node Concept Index,  , Free Store, Top\n @section Concept Index\n "}, {"sha": "0585787e3249e46e3454cca59044f9a61dcc6762", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a58942422c0b4b60efa76fd7261961c1d4ea612a", "patch": "@@ -1797,13 +1797,13 @@ cons_up_default_function (type, full_name, kind)\n   if (CLASSTYPE_INTERFACE_KNOWN (type))\n     {\n       DECL_INTERFACE_KNOWN (fn) = 1;\n-      DECL_EXTERNAL (fn) = (CLASSTYPE_INTERFACE_ONLY (type)\n-\t\t\t    || ! flag_implement_inlines);\n-      TREE_STATIC (fn) = ! DECL_EXTERNAL (fn);\n+      DECL_NOT_REALLY_EXTERN (fn) = (!CLASSTYPE_INTERFACE_ONLY (type)\n+\t\t\t\t     && flag_implement_inlines);\n     }\n   else\n     DECL_NOT_REALLY_EXTERN (fn) = 1;\n \n+#if 0\n   /* When on-the-fly synthesis works properly, remove the second and third\n      conditions here.  */\n   if (flag_keep_inline_functions\n@@ -1822,6 +1822,7 @@ cons_up_default_function (type, full_name, kind)\n       store_pending_inline (fn, t);\n     }\n   else\n+#endif\n     mark_inline_for_output (fn);\n \n #ifdef DEBUG_DEFAULT_FUNCTIONS"}, {"sha": "1e26e20b90f4242ac6c82e60bdb373e45788c853", "filename": "gcc/cp/method.c", "status": "modified", "additions": 40, "deletions": 66, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a58942422c0b4b60efa76fd7261961c1d4ea612a", "patch": "@@ -562,44 +562,30 @@ build_overload_name (parmtypes, begin, end)\n \n     only_one:\n \n-      if (! nofold)\n+      if (! nofold && ! just_one)\n \t{\n-\t  if (! just_one)\n-\t    /* Every argument gets counted.  */\n-\t    typevec[maxtype++] = parmtype;\n+\t  /* Every argument gets counted.  */\n+\t  typevec[maxtype++] = parmtype;\n \n-\t  if (TREE_USED (parmtype))\n+\t  if (TREE_USED (parmtype) && parmtype == typevec[maxtype-2])\n \t    {\n-\t      if (! just_one && parmtype == typevec[maxtype-2])\n-\t\tnrepeats++;\n-\t      else\n-\t\t{\n-\t\t  if (nrepeats)\n-\t\t    flush_repeats (parmtype);\n-\t\t  if (! just_one && TREE_CHAIN (parmtypes)\n-\t\t      && parmtype == TREE_VALUE (TREE_CHAIN (parmtypes)))\n-\t\t    nrepeats++;\n-\t\t  else\n-\t\t    {\n-\t\t      int tindex = 0;\n-\n-\t\t      while (typevec[tindex] != parmtype)\n-\t\t\ttindex++;\n-\t\t      OB_PUTC ('T');\n-\t\t      icat (tindex);\n-\t\t      if (tindex > 9)\n-\t\t\tOB_PUTC ('_');\n-\t\t    }\n-\t\t}\n+\t      nrepeats++;\n \t      goto next;\n \t    }\n+\n \t  if (nrepeats)\n \t    flush_repeats (typevec[maxtype-2]);\n-\t  if (! just_one\n-\t      /* Only cache types which take more than one character.  */\n-\t      && (parmtype != TYPE_MAIN_VARIANT (parmtype)\n-\t\t  || (TREE_CODE (parmtype) != INTEGER_TYPE\n-\t\t      && TREE_CODE (parmtype) != REAL_TYPE)))\n+\n+\t  if (TREE_USED (parmtype))\n+\t    {\n+\t      flush_repeats (parmtype);\n+\t      goto next;\n+\t    }\n+\n+\t  /* Only cache types which take more than one character.  */\n+\t  if (parmtype != TYPE_MAIN_VARIANT (parmtype)\n+\t      || (TREE_CODE (parmtype) != INTEGER_TYPE\n+\t\t  && TREE_CODE (parmtype) != REAL_TYPE))\n \t    TREE_USED (parmtype) = 1;\n \t}\n \n@@ -1496,23 +1482,7 @@ hack_identifier (value, name, yychar)\n \t  return error_mark_node;\n \t}\n       TREE_USED (current_class_decl) = 1;\n-      if (yychar == '(')\n-\tif (! ((TYPE_LANG_SPECIFIC (type)\n-\t\t&& TYPE_OVERLOADS_CALL_EXPR (type))\n-\t       || (TREE_CODE (type) == REFERENCE_TYPE\n-\t\t   && TYPE_LANG_SPECIFIC (TREE_TYPE (type))\n-\t\t   && TYPE_OVERLOADS_CALL_EXPR (TREE_TYPE (type))))\n-\t    && TREE_CODE (type) != FUNCTION_TYPE\n-\t    && TREE_CODE (type) != METHOD_TYPE\n-\t    && !TYPE_PTRMEMFUNC_P (type)\n-\t    && (TREE_CODE (type) != POINTER_TYPE\n-\t\t|| (TREE_CODE (TREE_TYPE (type)) != FUNCTION_TYPE\n-\t\t    && TREE_CODE (TREE_TYPE (type)) != METHOD_TYPE)))\n-\t  {\n-\t    error (\"component `%s' is not a method\",\n-\t\t   IDENTIFIER_POINTER (name));\n-\t    return error_mark_node;\n-\t  }\n+\n       /* Mark so that if we are in a constructor, and then find that\n \t this field was initialized by a base initializer,\n \t we can emit an error message.  */\n@@ -2094,32 +2064,34 @@ do_build_copy_constructor (fndecl)\n       for (; fields; fields = TREE_CHAIN (fields))\n \t{\n \t  tree name, init, t;\n-\t  if (TREE_CODE (fields) != FIELD_DECL)\n+\t  tree field = fields;\n+\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n-\t  if (DECL_NAME (fields))\n+\t  if (DECL_NAME (field))\n \t    {\n-\t      if (VFIELD_NAME_P (DECL_NAME (fields)))\n+\t      if (VFIELD_NAME_P (DECL_NAME (field)))\n \t\tcontinue;\n-\t      if (VBASE_NAME_P (DECL_NAME (fields)))\n+\t      if (VBASE_NAME_P (DECL_NAME (field)))\n \t\tcontinue;\n \n \t      /* True for duplicate members.  */\n-\t      if (IDENTIFIER_CLASS_VALUE (DECL_NAME (fields)) != fields)\n+\t      if (IDENTIFIER_CLASS_VALUE (DECL_NAME (field)) != field)\n \t\tcontinue;\n \t    }\n-\t  else if ((t = TREE_TYPE (fields)) != NULL_TREE\n+\t  else if ((t = TREE_TYPE (field)) != NULL_TREE\n \t\t   && TREE_CODE (t) == UNION_TYPE\n \t\t   && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t))\n \t\t   && TYPE_FIELDS (t) != NULL_TREE)\n-\t    fields = largest_union_member (t);\n+\t    field = largest_union_member (t);\n \t  else\n \t    continue;\n \n-\t  init = build (COMPONENT_REF, TREE_TYPE (fields), parm, fields);\n+\t  init = build (COMPONENT_REF, TREE_TYPE (field), parm, field);\n \t  init = build_tree_list (NULL_TREE, init);\n \n \t  current_member_init_list\n-\t    = tree_cons (DECL_NAME (fields), init, current_member_init_list);\n+\t    = tree_cons (DECL_NAME (field), init, current_member_init_list);\n \t}\n       current_member_init_list = nreverse (current_member_init_list);\n       current_base_init_list = nreverse (current_base_init_list);\n@@ -2171,29 +2143,31 @@ do_build_assign_ref (fndecl)\n       for (; fields; fields = TREE_CHAIN (fields))\n \t{\n \t  tree comp, init, t;\n-\t  if (TREE_CODE (fields) != FIELD_DECL)\n+\t  tree field = fields;\n+\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n-\t  if (DECL_NAME (fields))\n+\t  if (DECL_NAME (field))\n \t    {\n-\t      if (VFIELD_NAME_P (DECL_NAME (fields)))\n+\t      if (VFIELD_NAME_P (DECL_NAME (field)))\n \t\tcontinue;\n-\t      if (VBASE_NAME_P (DECL_NAME (fields)))\n+\t      if (VBASE_NAME_P (DECL_NAME (field)))\n \t\tcontinue;\n \n \t      /* True for duplicate members.  */\n-\t      if (IDENTIFIER_CLASS_VALUE (DECL_NAME (fields)) != fields)\n+\t      if (IDENTIFIER_CLASS_VALUE (DECL_NAME (field)) != field)\n \t\tcontinue;\n \t    }\n-\t  else if ((t = TREE_TYPE (fields)) != NULL_TREE\n+\t  else if ((t = TREE_TYPE (field)) != NULL_TREE\n \t\t   && TREE_CODE (t) == UNION_TYPE\n \t\t   && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t))\n \t\t   && TYPE_FIELDS (t) != NULL_TREE)\n-\t    fields = largest_union_member (t);\n+\t    field = largest_union_member (t);\n \t  else\n \t    continue;\n \n-\t  comp = build (COMPONENT_REF, TREE_TYPE (fields), C_C_D, fields);\n-\t  init = build (COMPONENT_REF, TREE_TYPE (fields), parm, fields);\n+\t  comp = build (COMPONENT_REF, TREE_TYPE (field), C_C_D, field);\n+\t  init = build (COMPONENT_REF, TREE_TYPE (field), parm, field);\n \n \t  expand_expr_stmt (build_modify_expr (comp, NOP_EXPR, init));\n \t}"}, {"sha": "d7005927ed01aa4a35be6448277239d47db02065", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a58942422c0b4b60efa76fd7261961c1d4ea612a", "patch": "@@ -25,20 +25,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    all derivations; this is applied before the explicit action, if one\n    is given.  Keep this in mind when reading the actions.  */\n \n-/* Also note: this version contains experimental exception\n-   handling features.  They could break, change, disappear,\n-   or otherwise exhibit volatile behavior.  Don't depend on\n-   me (Michael Tiemann) to protect you from any negative impact\n-   this may have on your professional, personal, or spiritual life.\n-\n-   NEWS FLASH:  This version now supports the exception handling\n-   syntax of Stroustrup's 2nd edition, if -fansi-exceptions is given.\n-   THIS IS WORK IN PROGRESS!!!  The type of the 'throw' and the\n-   'catch' much match EXACTLY (no inheritance support or coercions).\n-   Also, throw-specifications of functions don't work.\n-   Destructors aren't called correctly.  Etc, etc.  --Per Bothner.\n-  */\n-\n %{\n /* Cause the `yydebug' variable to be defined.  */\n #define YYDEBUG 1\n@@ -251,7 +237,7 @@ empty_parms ()\n %type <ttype> object aggr\n %type <itype> new delete\n /* %type <ttype> primary_no_id */\n-%type <ttype> nonmomentary_expr\n+%type <ttype> nonmomentary_expr maybe_parmlist\n %type <itype> forhead.2 initdcl0 notype_initdcl0 member_init_list\n %type <ttype> template_header template_parm_list template_parm\n %type <ttype> template_type_parm\n@@ -346,7 +332,8 @@ lang_extdef:\n \t  { if (pending_lang_change) do_pending_lang_change(); }\n \t  extdef\n \t  { if (! global_bindings_p () && ! pseudo_global_level_p())\n-\t      pop_everything (); }\n+\t      pop_everything ();\n+\t    prefix_attributes = NULL_TREE; }\n \t;\n \n extdef:\n@@ -2600,7 +2587,6 @@ component_decl_list:\n \t\t\t$$ = $2;\n \t\t    }\n \t\t}\n-\t| component_decl_list ';'\n \t;\n \n component_decl:\n@@ -2614,6 +2600,8 @@ component_decl:\n \t\t{ $$ = finish_method ($$); }\n \t| fn.def2 '{' /* nodecls compstmt */\n \t\t{ $$ = finish_method ($$); }\n+\t| ';'\n+\t\t{ $$ = NULL_TREE; }\n \t;\n \n component_decl_1:\n@@ -2796,12 +2784,27 @@ nonempty_type_quals:\n /* These rules must follow the rules for function declarations\n    and component declarations.  That way, longer rules are preferred.  */\n \n+suspend_mom:\n+\t{ $<itype>$ = suspend_momentary (); } \n+\n /* An expression which will not live on the momentary obstack.  */\n nonmomentary_expr:\n-\t{ $<itype>$ = suspend_momentary (); } expr\n+\tsuspend_mom expr\n \t{ resume_momentary ((int) $<itype>1); $$ = $2; }\n \t;\n \n+/* An expression which will not live on the momentary obstack.  */\n+maybe_parmlist:\n+\t  suspend_mom '(' nonnull_exprlist ')'\n+\t\t{ resume_momentary ((int) $<itype>1); $$ = $3; }\n+\t| suspend_mom '(' parmlist ')'\n+\t\t{ resume_momentary ((int) $<itype>1); $$ = $3; }\n+\t| suspend_mom LEFT_RIGHT\n+\t\t{ resume_momentary ((int) $<itype>1); $$ = empty_parms (); }\n+\t| suspend_mom '(' error ')'\n+\t\t{ resume_momentary ((int) $<itype>1); $$ = NULL_TREE; }\n+\t;\n+\n /* A declarator that is allowed only after an explicit typespec.  */\n /* may all be followed by prec '.' */\n after_type_declarator:\n@@ -2843,14 +2846,8 @@ nested_type:\n \t;\n \n direct_after_type_declarator:\n-\t  direct_after_type_declarator '(' nonnull_exprlist ')' type_quals %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n-\t| direct_after_type_declarator '(' parmlist ')' type_quals %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n-\t| direct_after_type_declarator LEFT_RIGHT type_quals %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $3); }\n-\t| direct_after_type_declarator '(' error ')' type_quals %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, NULL_TREE, NULL_TREE); }\n+\t  direct_after_type_declarator maybe_parmlist type_quals %prec '.'\n+\t\t{ $$ = build_parse_node (CALL_EXPR, $$, $2, $3); }\n \t| direct_after_type_declarator '[' nonmomentary_expr ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n \t| direct_after_type_declarator '[' ']'\n@@ -2900,14 +2897,8 @@ complex_notype_declarator:\n \t;\n \n complex_direct_notype_declarator:\n-\t  direct_notype_declarator '(' nonnull_exprlist ')' type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n-\t| direct_notype_declarator '(' parmlist ')' type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n-\t| direct_notype_declarator LEFT_RIGHT type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $3); }\n-\t| direct_notype_declarator '(' error ')' type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, NULL_TREE, NULL_TREE); }\n+\t  direct_notype_declarator maybe_parmlist type_quals  %prec '.'\n+\t\t{ $$ = build_parse_node (CALL_EXPR, $$, $2, $3); }\n \t| '(' complex_notype_declarator ')'\n \t\t{ $$ = $2; }\n \t| direct_notype_declarator '[' nonmomentary_expr ']'\n@@ -3192,7 +3183,8 @@ stmt:\n \n simple_stmt:\n \t  decl\n-\t\t{ finish_stmt (); }\n+\t\t{ finish_stmt ();\n+\t\t  prefix_attributes = NULL_TREE; }\n \t| expr ';'\n \t\t{\n \t\t  tree expr = $1;\n@@ -3294,12 +3286,14 @@ simple_stmt:\n \t| SWITCH .pushlevel '(' condition ')'\n \t\t{ emit_line_note (input_filename, lineno);\n \t\t  c_expand_start_case ($4);\n+\t\t  push_switch ();\n \t\t  /* Don't let the tree nodes for $4 be discarded by\n \t\t     clear_momentary during the parsing of the next stmt.  */\n \t\t  push_momentary (); }\n \t  implicitly_scoped_stmt\n \t\t{ expand_end_case ($4);\n \t\t  pop_momentary ();\n+\t\t  pop_switch ();\n \t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary ();"}, {"sha": "8c995a8fa99d1a84434854d409531721b31c3003", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a58942422c0b4b60efa76fd7261961c1d4ea612a", "patch": "@@ -1452,6 +1452,8 @@ tsubst (t, args, nargs, in_decl)\n \tDECL_INTERFACE_KNOWN (r) = 0;\n \tDECL_INLINE (r) = DECL_INLINE (t);\n \tDECL_THIS_INLINE (r) = DECL_THIS_INLINE (t);\n+\tTREE_READONLY (r) = TREE_READONLY (t);\n+\tTREE_THIS_VOLATILE (r) = TREE_THIS_VOLATILE (t);\n \t{\n #if 0\t\t\t\t/* Maybe later.  -jason  */\n \t  struct tinst_level *til = tinst_for_decl();\n@@ -2412,7 +2414,7 @@ do_pending_expansions ()\n \t     If `interface', ext ref.  */\n \t  if (CLASSTYPE_INTERFACE_KNOWN (context))\n \t    DECIDE (!CLASSTYPE_INTERFACE_ONLY (context));\n-#if 0 /* This doesn't get us stuff needed only by the file initializer.  */\n+#if 1 /* This doesn't get us stuff needed only by the file initializer.  */\n \t  DECIDE (TREE_USED (t));\n #else /* This compiles too much stuff, but that's probably better in\n \t most cases than never compiling the stuff we need.  */"}, {"sha": "8580c9b34c544bd9d5a4b3cd1fa8a43f2b4db764", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a58942422c0b4b60efa76fd7261961c1d4ea612a", "patch": "@@ -51,6 +51,7 @@ static tree convert_sequence ();\n static tree get_delta_difference PROTO((tree, tree, int));\n \n extern rtx original_result_rtx;\n+extern int warn_synth;\n \n /* Return the target type of TYPE, which meas return T for:\n    T*, T&, T[], T (...), and otherwise, just T.  */\n@@ -2359,6 +2360,12 @@ build_function_call_real (function, params, require_complete, flags)\n \t  pedwarn (\"ANSI C++ forbids calling `main' from within program\");\n \t}\n \n+      if (pedantic && DECL_THIS_INLINE (function) && ! DECL_INITIAL (function)\n+\t  && ! DECL_ARTIFICIAL (function)\n+\t  && ! DECL_PENDING_INLINE_INFO (function))\n+\tcp_pedwarn (\"inline function `%#D' called before definition\",\n+\t\t    function);\n+\n       /* Differs from default_conversion by not setting TREE_ADDRESSABLE\n \t (because calling an inline function does not mean the function\n \t needs to be separately compiled).  */\n@@ -2403,7 +2410,7 @@ build_function_call_real (function, params, require_complete, flags)\n \t && TREE_CODE (TREE_TYPE (fntype)) == FUNCTION_TYPE)\n \t|| is_method))\n     {\n-      error (\"called object is not a function\");\n+      cp_error (\"`%E' cannot be used as a function\", function);\n       return error_mark_node;\n     }\n \n@@ -4617,9 +4624,21 @@ build_conditional_expr (ifexp, op1, op2)\n       code2 = TREE_CODE (type2);\n     }\n \n+  if (code1 == RECORD_TYPE && code2 == RECORD_TYPE\n+      && real_lvalue_p (op1) && real_lvalue_p (op2)\n+      && comptypes (type1, type2, -1))\n+    {\n+      type1 = build_reference_type (type1);\n+      type2 = build_reference_type (type2);\n+      result_type = common_type (type1, type2);\n+      op1 = convert_to_reference (result_type, op1, CONV_IMPLICIT,\n+\t\t\t\t  LOOKUP_NORMAL, NULL_TREE);\n+      op2 = convert_to_reference (result_type, op2, CONV_IMPLICIT,\n+\t\t\t\t  LOOKUP_NORMAL, NULL_TREE);\n+    }\n   /* Quickly detect the usual case where op1 and op2 have the same type\n      after promotion.  */\n-  if (TYPE_MAIN_VARIANT (type1) == TYPE_MAIN_VARIANT (type2))\n+  else if (TYPE_MAIN_VARIANT (type1) == TYPE_MAIN_VARIANT (type2))\n     {\n       if (type1 == type2)\n \tresult_type = type1;\n@@ -4814,7 +4833,8 @@ build_conditional_expr (ifexp, op1, op2)\n   if (TREE_CONSTANT (ifexp))\n     return integer_zerop (ifexp) ? op2 : op1;\n \n-  return fold (build (COND_EXPR, result_type, ifexp, op1, op2));\n+  return convert_from_reference\n+    (fold (build (COND_EXPR, result_type, ifexp, op1, op2)));\n }\n \f\n /* Handle overloading of the ',' operator when needed.  Otherwise,\n@@ -5630,7 +5650,14 @@ build_modify_expr (lhs, modifycode, rhs)\n \tcp_error (\"`%T' does not define operator=\", lhstype);\n       else if (TYPE_HAS_TRIVIAL_ASSIGN_REF (lhstype)\n \t       && TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))\n-\t/* Do the default thing */;\n+\t{\n+\t  if (warn_synth)\n+\t    /* If we care about this, do overload resolution.  */\n+\t    build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL,\n+\t\t\t    lhs, rhs, make_node (NOP_EXPR));\n+\n+\t  /* Do the default thing */;\n+\t}\n       else\n \t{\n \t  result = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL,"}, {"sha": "e69ada49009a5d4b3c5c2dee741e9c932f4a7bca", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58942422c0b4b60efa76fd7261961c1d4ea612a/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a58942422c0b4b60efa76fd7261961c1d4ea612a", "patch": "@@ -975,6 +975,13 @@ process_init_constructor (type, init, elts)\n \t      tree tail1 = tail;\n \t      next1 = digest_init (TYPE_MAIN_VARIANT (TREE_TYPE (type)),\n \t\t\t\t   TREE_VALUE (tail), &tail1);\n+\t      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (type))\n+\t\t  && TYPE_MAIN_VARIANT (TREE_TYPE (type)) != TYPE_MAIN_VARIANT (TREE_TYPE (next1)))\n+\t\t{\n+\t\t  /* The fact this needs to be done suggests this code needs\n+\t\t     to be totally rewritten.  */\n+\t\t  next1 = convert_for_initialization (NULL_TREE, TREE_TYPE (type), next1, LOOKUP_NORMAL, \"initialization\", NULL_TREE, 0);\n+\t\t}\n \t      my_friendly_assert (tail1 == 0\n \t\t\t\t  || TREE_CODE (tail1) == TREE_LIST, 319);\n \t      if (tail == tail1 && len < 0)\n@@ -1529,37 +1536,7 @@ build_functional_cast (exp, parms)\n   if (expr_as_ctor == error_mark_node)\n     return error_mark_node;\n \n-  if (current_function_decl)\n-    return build_cplus_new (type, expr_as_ctor, 1);\n-\n-  {\n-    register tree parm = TREE_OPERAND (expr_as_ctor, 1);\n-\n-    /* Initializers for static variables and parameters have\n-       to handle doing the initialization and cleanup themselves.  */\n-    my_friendly_assert (TREE_CODE (expr_as_ctor) == CALL_EXPR, 322);\n-#if 0\n-    /* The following assertion fails in cases where we are initializing\n-       a static member variable of a particular instance of a template\n-       class with a call to a constructor of the given instance, as in:\n-       \n-       TMPL<int> object = TMPL<int>();\n-       \n-       Curiously, the assertion does not fail if we do the same thing\n-       for a static member of a non-template class, as in:\n-       \n-       T object = T();\n-       \n-       I can't see why we should care here whether or not the initializer\n-       expression involves a call to `new', so for the time being, it\n-       seems best to just avoid doing this assertion.  */\n-    my_friendly_assert (TREE_CALLS_NEW (TREE_VALUE (parm)), 323);\n-#endif\n-    TREE_VALUE (parm) = NULL_TREE;\n-    expr_as_ctor = build_indirect_ref (expr_as_ctor, NULL_PTR);\n-    TREE_HAS_CONSTRUCTOR (expr_as_ctor) = 1;\n-  }\n-  return expr_as_ctor;\n+  return build_cplus_new (type, expr_as_ctor, 1);\n }\n \f\n /* Return the character string for the name that encodes the"}]}