{"sha": "f27e6bb249adee339489e8179e8010142c7c09fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI3ZTZiYjI0OWFkZWUzMzk0ODllODE3OWU4MDEwMTQyYzdjMDlmYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-10-18T04:41:35Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2000-10-18T04:41:35Z"}, "message": "reorg.c: Fix formatting.\n\n2000-10-18  Kazu Hirata  <kazu@hxi.com>\n\n\t* reorg.c: Fix formatting.\n\nFrom-SVN: r36926", "tree": {"sha": "0ab2f6d657973355bee989929f633c5a2f7b4e58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ab2f6d657973355bee989929f633c5a2f7b4e58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f27e6bb249adee339489e8179e8010142c7c09fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f27e6bb249adee339489e8179e8010142c7c09fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f27e6bb249adee339489e8179e8010142c7c09fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f27e6bb249adee339489e8179e8010142c7c09fb/comments", "author": null, "committer": null, "parents": [{"sha": "b054460b55b917dbb6759a58ff4095715036bf8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b054460b55b917dbb6759a58ff4095715036bf8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b054460b55b917dbb6759a58ff4095715036bf8f"}], "stats": {"total": 186, "additions": 92, "deletions": 94}, "files": [{"sha": "0243c19f0fcab6d1c6f928b120409a48ef0e3a2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27e6bb249adee339489e8179e8010142c7c09fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27e6bb249adee339489e8179e8010142c7c09fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f27e6bb249adee339489e8179e8010142c7c09fb", "patch": "@@ -4,6 +4,8 @@\n \texpander that is used when not optimizing.  Output a tab after\n \teach assembly insns.\n \n+\t* reorg.c: Fix formatting.\n+\n 2000-10-17  Joern Rennecke <amylaar@redhat.co.uk>\n \n \t* reload1.c (move2add_note_store): Check for simple"}, {"sha": "4005c0ac76ba08b8f825780fe2915d7f18d8f8fa", "filename": "gcc/reorg.c", "status": "modified", "additions": 90, "deletions": 94, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27e6bb249adee339489e8179e8010142c7c09fb/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27e6bb249adee339489e8179e8010142c7c09fb/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=f27e6bb249adee339489e8179e8010142c7c09fb", "patch": "@@ -56,7 +56,7 @@ Boston, MA 02111-1307, USA.  */\n    is taken.\n \n    The HP-PA always has a branch delay slot.  For unconditional branches\n-   its effects can be annulled when the branch is taken.  The effects \n+   its effects can be annulled when the branch is taken.  The effects\n    of the delay slot in a conditional branch can be nullified for forward\n    taken branches, or for untaken backward branches.  This means\n    we can hoist insns from the fall-through path for forward branches or\n@@ -140,7 +140,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-attr.h\"\n #include \"resource.h\"\n \n-\n #ifdef DELAY_SLOTS\n \n #define obstack_chunk_alloc xmalloc\n@@ -353,7 +352,7 @@ find_end_label ()\n \t\t || GET_CODE (PATTERN (insn)) == CLOBBER)))\n     insn = PREV_INSN (insn);\n \n-  /* When a target threads its epilogue we might already have a \n+  /* When a target threads its epilogue we might already have a\n      suitable return insn.  If so put a label before it for the\n      end_of_function_label.  */\n   if (GET_CODE (insn) == BARRIER\n@@ -387,27 +386,27 @@ find_end_label ()\n \t{\n \t  insn = PREV_INSN (insn);\n \n-      \t  /* Put the label before an USE insns that may proceed the\n+\t  /* Put the label before an USE insns that may proceed the\n \t     RETURN insn.  */\n-      \t  while (GET_CODE (insn) == USE)\n+\t  while (GET_CODE (insn) == USE)\n \t    insn = PREV_INSN (insn);\n \n-      \t  emit_label_after (end_of_function_label, insn);\n+\t  emit_label_after (end_of_function_label, insn);\n \t}\n       else\n \t{\n-          /* Otherwise, make a new label and emit a RETURN and BARRIER,\n+\t  /* Otherwise, make a new label and emit a RETURN and BARRIER,\n \t     if needed.  */\n-          emit_label (end_of_function_label);\n+\t  emit_label (end_of_function_label);\n #ifdef HAVE_return\n-          if (HAVE_return)\n+\t  if (HAVE_return)\n \t    {\n \t      /* The return we make may have delay slots too.  */\n \t      rtx insn = gen_return ();\n \t      insn = emit_jump_insn (insn);\n \t      emit_barrier ();\n-              if (num_delay_slots (insn) > 0)\n-\t        obstack_ptr_grow (&unfilled_slots_obstack, insn);\n+\t      if (num_delay_slots (insn) > 0)\n+\t\tobstack_ptr_grow (&unfilled_slots_obstack, insn);\n \t    }\n #endif\n \t}\n@@ -451,7 +450,7 @@ emit_delay_sequence (insn, list, length)\n   rtx delay_insn = copy_rtx (insn);\n \n   /* If INSN is followed by a BARRIER, delete the BARRIER since it will only\n-     confuse further processing.  Update LAST in case it was the last insn.  \n+     confuse further processing.  Update LAST in case it was the last insn.\n      We will put the BARRIER back in later.  */\n   if (NEXT_INSN (insn) && GET_CODE (NEXT_INSN (insn)) == BARRIER)\n     {\n@@ -520,7 +519,7 @@ emit_delay_sequence (insn, list, length)\n   if (NEXT_INSN (seq_insn) && GET_CODE (NEXT_INSN (seq_insn)) == INSN\n       && GET_CODE (PATTERN (NEXT_INSN (seq_insn))) == SEQUENCE)\n     PREV_INSN (XVECEXP (PATTERN (NEXT_INSN (seq_insn)), 0, 0)) = seq_insn;\n-    \n+\n   /* If there used to be a BARRIER, put it back.  */\n   if (had_barrier)\n     emit_barrier_after (seq_insn);\n@@ -554,7 +553,7 @@ add_to_delay_list (insn, delay_list)\n   XEXP (delay_list, 1) = add_to_delay_list (insn, XEXP (delay_list, 1));\n \n   return delay_list;\n-}   \n+}\n \f\n /* Delete INSN from the delay slot of the insn that it is in, which may\n    produce an insn with no delay slots.  Return the new insn.  */\n@@ -792,7 +791,6 @@ optimize_skip (insn)\n }\n #endif\n \f\n-\n /*  Encode and return branch direction and prediction information for\n     INSN assuming it will jump to LABEL.\n \n@@ -816,15 +814,15 @@ get_jump_flags (insn, label)\n       && INSN_UID (insn) <= max_uid\n       && label != 0\n       && INSN_UID (label) <= max_uid)\n-    flags \n+    flags\n       = (uid_to_ruid[INSN_UID (label)] > uid_to_ruid[INSN_UID (insn)])\n \t ? ATTR_FLAG_forward : ATTR_FLAG_backward;\n   /* No valid direction information.  */\n   else\n     flags = 0;\n-  \n+\n   /* If insn is a conditional branch call mostly_true_jump to get\n-     determine the branch prediction.  \n+     determine the branch prediction.\n \n      Non conditional branches are predicted as very likely taken.  */\n   if (GET_CODE (insn) == JUMP_INSN\n@@ -835,21 +833,21 @@ get_jump_flags (insn, label)\n       prediction = mostly_true_jump (insn, get_branch_condition (insn, label));\n       switch (prediction)\n \t{\n-\t  case 2:\n-\t    flags |= (ATTR_FLAG_very_likely | ATTR_FLAG_likely);\n-\t    break;\n-\t  case 1:\n-\t    flags |= ATTR_FLAG_likely;\n-\t    break;\n-\t  case 0:\n-\t    flags |= ATTR_FLAG_unlikely;\n-\t    break;\n-\t  case -1:\n-\t    flags |= (ATTR_FLAG_very_unlikely | ATTR_FLAG_unlikely);\n-\t    break;\n+\tcase 2:\n+\t  flags |= (ATTR_FLAG_very_likely | ATTR_FLAG_likely);\n+\t  break;\n+\tcase 1:\n+\t  flags |= ATTR_FLAG_likely;\n+\t  break;\n+\tcase 0:\n+\t  flags |= ATTR_FLAG_unlikely;\n+\t  break;\n+\tcase -1:\n+\t  flags |= (ATTR_FLAG_very_unlikely | ATTR_FLAG_unlikely);\n+\t  break;\n \n-\t  default:\n-\t    abort();\n+\tdefault:\n+\t  abort ();\n \t}\n     }\n   else\n@@ -882,7 +880,7 @@ rare_destination (insn)\n \tcase CODE_LABEL:\n \t  return 0;\n \tcase BARRIER:\n-\t  /* A BARRIER can either be after a JUMP_INSN or a CALL_INSN.  We \n+\t  /* A BARRIER can either be after a JUMP_INSN or a CALL_INSN.  We\n \t     don't scan past JUMP_INSNs, so any barrier we find here must\n \t     have been after a CALL_INSN and hence mean the call doesn't\n \t     return.  */\n@@ -932,13 +930,13 @@ mostly_true_jump (jump_insn, condition)\n       int prob = INTVAL (XEXP (note, 0));\n \n       if (prob >= REG_BR_PROB_BASE * 9 / 10)\n-        return 2;\n+\treturn 2;\n       else if (prob >= REG_BR_PROB_BASE / 2)\n-        return 1;\n+\treturn 1;\n       else if (prob >= REG_BR_PROB_BASE / 10)\n-        return 0;\n+\treturn 0;\n       else\n-        return -1;\n+\treturn -1;\n     }\n \n   /* ??? Ought to use estimate_probability instead.  */\n@@ -956,7 +954,7 @@ mostly_true_jump (jump_insn, condition)\n     {\n       /* If this is the test of a loop, it is very likely true.  We scan\n \t backwards from the target label.  If we find a NOTE_INSN_LOOP_BEG\n-\t before the next real insn, we assume the branch is to the top of \n+\t before the next real insn, we assume the branch is to the top of\n \t the loop.  */\n       for (insn = PREV_INSN (target_label);\n \t   insn && GET_CODE (insn) == NOTE;\n@@ -992,7 +990,7 @@ mostly_true_jump (jump_insn, condition)\n       return 2;\n     }\n \n-  /* If we couldn't figure out what this jump was, assume it won't be \n+  /* If we couldn't figure out what this jump was, assume it won't be\n      taken.  This should be rare.  */\n   if (condition == 0)\n     return 0;\n@@ -1012,7 +1010,7 @@ mostly_true_jump (jump_insn, condition)\n     case LE:\n     case LT:\n       if (XEXP (condition, 1) == const0_rtx)\n-        return 0;\n+\treturn 0;\n       break;\n     case GE:\n     case GT:\n@@ -1045,7 +1043,7 @@ get_branch_condition (insn, target)\n {\n   rtx pat = PATTERN (insn);\n   rtx src;\n-  \n+\n   if (condjump_in_parallel_p (insn))\n     pat = XVECEXP (pat, 0, 0);\n \n@@ -1135,7 +1133,7 @@ redirect_with_delay_slots_safe_p (jump, newlabel, seq)\n \t   ? eligible_for_annul_true (jump, i - 1,\n \t\t\t\t      XVECEXP (pat, 0, i), flags) :\n #endif\n-\t   eligible_for_delay (jump, i -1, XVECEXP (pat, 0, i), flags)))\n+\t   eligible_for_delay (jump, i - 1, XVECEXP (pat, 0, i), flags)))\n       break;\n \n   return (i == XVECLEN (pat, 0));\n@@ -1188,18 +1186,17 @@ check_annul_list_true_false (annul_true_p, delay_list)\n   if (delay_list)\n     {\n       for (temp = delay_list; temp; temp = XEXP (temp, 1))\n-        {\n-          rtx trial = XEXP (temp, 0);\n- \n-          if ((annul_true_p && INSN_FROM_TARGET_P (trial))\n+\t{\n+\t  rtx trial = XEXP (temp, 0);\n+\n+\t  if ((annul_true_p && INSN_FROM_TARGET_P (trial))\n \t      || (!annul_true_p && !INSN_FROM_TARGET_P (trial)))\n \t    return 0;\n-        }\n+\t}\n     }\n \n   return 1;\n }\n-\n \f\n /* INSN branches to an insn whose pattern SEQ is a SEQUENCE.  Given that\n    the condition tested by INSN is CONDITION and the resources shown in\n@@ -1255,10 +1252,10 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n      moving the instructions in the delay slots.\n \n      We can not steal the delay list if one of the instructions in the\n-     current delay_list modifies the condition codes and the jump in the \n+     current delay_list modifies the condition codes and the jump in the\n      sequence is a conditional jump. We can not do this because we can\n      not change the direction of the jump because the condition codes\n-     will effect the direction of the jump in the sequence. */\n+     will effect the direction of the jump in the sequence.  */\n \n   CLEAR_RESOURCE (&cc_set);\n   for (temp = delay_list; temp; temp = XEXP (temp, 1))\n@@ -1267,7 +1264,7 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n \n       mark_set_resources (trial, &cc_set, 0, MARK_SRC_DEST_CALL);\n       if (insn_references_resource_p (XVECEXP (seq , 0, 0), &cc_set, 0))\n-        return delay_list;\n+\treturn delay_list;\n     }\n \n   if (XVECLEN (seq, 0) - 1 > slots_remaining\n@@ -1347,13 +1344,13 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n   return delay_list;\n }\n \f\n-/* Similar to steal_delay_list_from_target except that SEQ is on the \n+/* Similar to steal_delay_list_from_target except that SEQ is on the\n    fallthrough path of INSN.  Here we only do something if the delay insn\n    of SEQ is an unconditional branch.  In that case we steal its delay slot\n    for INSN since unconditional branches are much easier to fill.  */\n \n static rtx\n-steal_delay_list_from_fallthrough (insn, condition, seq, \n+steal_delay_list_from_fallthrough (insn, condition, seq,\n \t\t\t\t   delay_list, sets, needed, other_needed,\n \t\t\t\t   slots_to_fill, pslots_filled, pannul_p)\n      rtx insn, condition;\n@@ -1426,7 +1423,6 @@ steal_delay_list_from_fallthrough (insn, condition, seq,\n     *pannul_p = 1;\n   return delay_list;\n }\n-\n \f\n /* Try merging insns starting at THREAD which match exactly the insns in\n    INSN's delay list.\n@@ -1464,9 +1460,9 @@ try_merge_delay_insns (insn, thread)\n      will essentially disable this optimization.  This method is somewhat of\n      a kludge, but I don't see a better way.)  */\n   if (! annul_p)\n-    for (i = 1 ; i < num_slots ; i++)\n+    for (i = 1 ; i < num_slots; i++)\n       if (XVECEXP (PATTERN (insn), 0, i))\n-        mark_referenced_resources (XVECEXP (PATTERN (insn), 0, i), &needed, 1);\n+\tmark_referenced_resources (XVECEXP (PATTERN (insn), 0, i), &needed, 1);\n \n   for (trial = thread; !stop_search_p (trial, 1); trial = next_trial)\n     {\n@@ -1571,8 +1567,8 @@ try_merge_delay_insns (insn, thread)\n \t    {\n \t      /* Keep track of the set/referenced resources for the delay\n \t\t slots of any trial insns we encounter.  */\n-              mark_set_resources (dtrial, &set, 0, MARK_SRC_DEST_CALL);\n-              mark_referenced_resources (dtrial, &needed, 1);\n+\t      mark_set_resources (dtrial, &set, 0, MARK_SRC_DEST_CALL);\n+\t      mark_referenced_resources (dtrial, &needed, 1);\n \t    }\n \t}\n     }\n@@ -1666,17 +1662,17 @@ redundant_insn (insn, target, delay_list)\n \t    return 0;\n \n \t  /* Stop for an INSN or JUMP_INSN with delayed effects and its delay\n-\t     slots because it is difficult to track its resource needs \n+\t     slots because it is difficult to track its resource needs\n \t     correctly.  */\n \n #ifdef INSN_SETS_ARE_DELAYED\n \t  if (INSN_SETS_ARE_DELAYED (XVECEXP (pat, 0, 0)))\n-\t    return 0; \n+\t    return 0;\n #endif\n \n #ifdef INSN_REFERENCES_ARE_DELAYED\n \t  if (INSN_REFERENCES_ARE_DELAYED (XVECEXP (pat, 0, 0)))\n-\t    return 0; \n+\t    return 0;\n #endif\n \n \t  /* See if any of the insns in the delay slot match, updating\n@@ -1771,12 +1767,12 @@ redundant_insn (insn, target, delay_list)\n \n #ifdef INSN_SETS_ARE_DELAYED\n \t  if (INSN_SETS_ARE_DELAYED (XVECEXP (pat, 0, 0)))\n-\t    return 0; \n+\t    return 0;\n #endif\n \n #ifdef INSN_REFERENCES_ARE_DELAYED\n \t  if (INSN_REFERENCES_ARE_DELAYED (XVECEXP (pat, 0, 0)))\n-\t    return 0; \n+\t    return 0;\n #endif\n \n \t  /* See if any of the insns in the delay slot match, updating\n@@ -1804,8 +1800,7 @@ redundant_insn (insn, target, delay_list)\n \t\treturn 0;\n \t    }\n \n-\n-\t  /* If the insn requiring the delay slot conflicts with INSN, we \n+\t  /* If the insn requiring the delay slot conflicts with INSN, we\n \t     must stop.  */\n \t  if (insn_sets_resource_p (XVECEXP (pat, 0, 0), &needed, 1))\n \t    return 0;\n@@ -1886,7 +1881,7 @@ update_block (insn, where)\n      rtx insn;\n      rtx where;\n {\n-  /* Ignore if this was in a delay slot and it came from the target of \n+  /* Ignore if this was in a delay slot and it came from the target of\n      a branch.  */\n   if (INSN_FROM_TARGET_P (insn))\n     return;\n@@ -2046,7 +2041,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t  || (GET_CODE (insn) == JUMP_INSN && non_jumps_p)\n \t  || (GET_CODE (insn) != JUMP_INSN && ! non_jumps_p))\n \tcontinue;\n-     \n+\n       /* It may have been that this insn used to need delay slots, but\n \t now doesn't; ignore in that case.  This can happen, for example,\n \t on the HP PA RISC, where the number of delay slots depends on\n@@ -2082,7 +2077,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t insn must exist when it is subsequently scanned.\n \n \t This is tried on each insn with delay slots as some machines\n-\t have insns which perform calls, but are not represented as \n+\t have insns which perform calls, but are not represented as\n \t CALL_INSNs.  */\n \n       slots_filled = 0;\n@@ -2134,7 +2129,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t forward in execution sequence), it must not need or set any resources\n \t that were set by later insns and must not set any resources that\n \t are needed for those insns.\n-\t \n+\n \t The delay slot insn itself sets resources unless it is a call\n \t (in which case the called routine, not the insn itself, is doing\n \t the setting).  */\n@@ -2158,7 +2153,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n \t\tcontinue;\n \n-\t      /* Check for resource conflict first, to avoid unnecessary \n+\t      /* Check for resource conflict first, to avoid unnecessary\n \t\t splitting.  */\n \t      if (! insn_references_resource_p (trial, &set, 1)\n \t\t  && ! insn_sets_resource_p (trial, &set, 1)\n@@ -2200,7 +2195,7 @@ fill_simple_delay_slots (non_jumps_p)\n #if defined(ANNUL_IFFALSE_SLOTS) || defined(ANNUL_IFTRUE_SLOTS)\n       if (slots_filled != slots_to_fill\n \t  && delay_list == 0\n-\t  && GET_CODE (insn) == JUMP_INSN \n+\t  && GET_CODE (insn) == JUMP_INSN\n \t  && (condjump_p (insn) || condjump_in_parallel_p (insn)))\n \t{\n \t  delay_list = optimize_skip (insn);\n@@ -2223,10 +2218,10 @@ fill_simple_delay_slots (non_jumps_p)\n \t fill_eager_delay_slots anyways, it was just deleted.  */\n \n       if (slots_filled != slots_to_fill\n-          && (GET_CODE (insn) != JUMP_INSN\n+\t  && (GET_CODE (insn) != JUMP_INSN\n \t      || ((condjump_p (insn) || condjump_in_parallel_p (insn))\n-\t\t   && ! simplejump_p (insn)\n-\t\t   && JUMP_LABEL (insn) != 0)))\n+\t\t  && ! simplejump_p (insn)\n+\t\t  && JUMP_LABEL (insn) != 0)))\n \t{\n \t  rtx target = 0;\n \t  int maybe_never = 0;\n@@ -2241,7 +2236,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t      mark_referenced_resources (insn, &needed, 1);\n \t      maybe_never = 1;\n \t    }\n-\t  else \n+\t  else\n \t    {\n \t      mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \t      mark_referenced_resources (insn, &needed, 1);\n@@ -2283,7 +2278,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t\t    break;\n \t\t  else if (JUMP_LABEL (trial_delay) != target)\n \t\t    {\n-\t\t      rtx ninsn = \n+\t\t      rtx ninsn =\n \t\t\tnext_active_insn (JUMP_LABEL (trial_delay));\n \n \t\t      mark_target_live_regs (get_insns (), ninsn,\n@@ -2338,7 +2333,7 @@ fill_simple_delay_slots (non_jumps_p)\n \n \t  /* If there are slots left to fill and our search was stopped by an\n \t     unconditional branch, try the insn at the branch target.  We can\n-\t     redirect the branch if it works. \n+\t     redirect the branch if it works.\n \n \t     Don't do this if the insn at the branch target is a branch.  */\n \t  if (slots_to_fill != slots_filled\n@@ -2367,7 +2362,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t      else\n \t\tnew_label = find_end_label ();\n \n-\t      delay_list \n+\t      delay_list\n \t\t= add_to_delay_list (copy_rtx (next_trial), delay_list);\n \t      slots_filled++;\n \t      reorg_redirect_jump (trial, new_label);\n@@ -2405,7 +2400,7 @@ fill_simple_delay_slots (non_jumps_p)\n \n #ifdef DELAY_SLOTS_FOR_EPILOGUE\n   /* See if the epilogue needs any delay slots.  Try to fill them if so.\n-     The only thing we can do is scan backwards from the end of the \n+     The only thing we can do is scan backwards from the end of the\n      function.  If we did this in a previous pass, it is incorrect to do it\n      again.  */\n   if (current_function_epilogue_delay_list)\n@@ -2439,7 +2434,7 @@ fill_simple_delay_slots (non_jumps_p)\n     SET_HARD_REG_BIT (needed.regs, STACK_POINTER_REGNUM);\n \n #ifdef EPILOGUE_USES\n-  for (i = 0; i <FIRST_PSEUDO_REGISTER; i++)\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       if (EPILOGUE_USES (i))\n \tSET_HARD_REG_BIT (needed.regs, i);\n@@ -2548,7 +2543,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n   /* If our thread is the end of subroutine, we can't get any delay\n      insns from that.  */\n   if (thread == 0)\n-      return delay_list;\n+    return delay_list;\n \n   /* If this is an unconditional branch, nothing is needed at the\n      opposite thread.  Otherwise, compute what is needed there.  */\n@@ -3122,7 +3117,7 @@ relax_delay_slots (first)\n \t      continue;\n \t    }\n \t}\n-\t  \n+\n       /* If this is an unconditional jump and the previous insn is a\n \t conditional jump, try reversing the condition of the previous\n \t insn and swapping our targets.  The next pass might be able to\n@@ -3221,7 +3216,7 @@ relax_delay_slots (first)\n \t  if (trial == 0 && target_label != 0)\n \t    trial = find_end_label ();\n \n-\t  if (trial != target_label \n+\t  if (trial != target_label\n \t      && redirect_with_delay_slots_safe_p (delay_insn, trial, insn))\n \t    {\n \t      reorg_redirect_jump (delay_insn, trial);\n@@ -3243,10 +3238,10 @@ relax_delay_slots (first)\n \t\ttmp = find_end_label ();\n \n \t      /* Insert the special USE insn and update dataflow info.  */\n-              update_block (trial, tmp);\n+\t      update_block (trial, tmp);\n \n \t      /* Now emit a label before the special USE insn, and\n-\t\t redirect our jump to the new label.  */ \n+\t\t redirect our jump to the new label.  */\n \t      target_label = get_label_before (PREV_INSN (tmp));\n \t      reorg_redirect_jump (delay_insn, target_label);\n \t      next = insn;\n@@ -3266,7 +3261,7 @@ relax_delay_slots (first)\n \t      if (target_label == 0)\n \t\ttarget_label = find_end_label ();\n \n-\t      if (redirect_with_delay_slots_safe_p (delay_insn, target_label, \n+\t      if (redirect_with_delay_slots_safe_p (delay_insn, target_label,\n \t\t\t\t\t\t    insn))\n \t\t{\n \t\t  reorg_redirect_jump (delay_insn, target_label);\n@@ -3413,7 +3408,7 @@ make_return_insns (first)\n \treal_return_label = get_label_before (insn);\n \tbreak;\n       }\n-  \n+\n   /* Show an extra usage of REAL_RETURN_LABEL so it won't go away if it\n      was equal to END_OF_FUNCTION_LABEL.  */\n   LABEL_NUSES (real_return_label)++;\n@@ -3471,7 +3466,8 @@ make_return_insns (first)\n \t\t   ? eligible_for_annul_true (jump_insn, i - 1,\n \t\t\t\t\t      XVECEXP (pat, 0, i), flags) :\n #endif\n-\t\t   eligible_for_delay (jump_insn, i -1, XVECEXP (pat, 0, i), flags)))\n+\t\t   eligible_for_delay (jump_insn, i - 1,\n+\t\t\t\t       XVECEXP (pat, 0, i), flags)))\n \t      break;\n \t}\n       else\n@@ -3535,7 +3531,7 @@ dbr_schedule (first, file)\n   flag_no_peephole = old_flag_no_peephole;\n #endif\n \n-  /* If the current function has no insns other than the prologue and \n+  /* If the current function has no insns other than the prologue and\n      epilogue, then do not try to fill any delay slots.  */\n   if (n_basic_blocks == 0)\n     return;\n@@ -3554,7 +3550,7 @@ dbr_schedule (first, file)\n   uid_to_ruid = (int *) xmalloc ((max_uid + 1) * sizeof (int));\n   for (i = 0, insn = first; insn; i++, insn = NEXT_INSN (insn))\n     uid_to_ruid[INSN_UID (insn)] = i;\n-  \n+\n   /* Initialize the list of insns that need filling.  */\n   if (unfilled_firstobj == 0)\n     {\n@@ -3574,12 +3570,12 @@ dbr_schedule (first, file)\n \t  && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n \t      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n \tcontinue;\n-    \n+\n       if (num_delay_slots (insn) > 0)\n \tobstack_ptr_grow (&unfilled_slots_obstack, insn);\n \n       /* Ensure all jumps go to the last of a set of consecutive labels.  */\n-      if (GET_CODE (insn) == JUMP_INSN \n+      if (GET_CODE (insn) == JUMP_INSN\n \t  && (condjump_p (insn) || condjump_in_parallel_p (insn))\n \t  && JUMP_LABEL (insn) != 0\n \t  && ((target = prev_label (next_active_insn (JUMP_LABEL (insn))))\n@@ -3690,7 +3686,7 @@ dbr_schedule (first, file)\n \t\t  else\n \t\t    total_delay_slots[j]++;\n \t\t}\n-              else if (num_delay_slots (insn) > 0)\n+\t      else if (num_delay_slots (insn) > 0)\n \t\ttotal_delay_slots[0]++;\n \t    }\n \t}\n@@ -3735,7 +3731,7 @@ dbr_schedule (first, file)\n       int pred_flags;\n \n       if (GET_CODE (insn) == INSN)\n-        {\n+\t{\n \t  rtx pat = PATTERN (insn);\n \n \t  if (GET_CODE (pat) == SEQUENCE)"}]}