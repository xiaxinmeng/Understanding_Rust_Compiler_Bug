{"sha": "1b4572a81dd40921680e70eef7469f0c80bc20e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI0NTcyYTgxZGQ0MDkyMTY4MGU3MGVlZjc0NjlmMGM4MGJjMjBlMA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-06-26T00:25:08Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-06-26T00:25:08Z"}, "message": "dwarf2out.c (new_cfi, [...]): Fix -Wc++-compat and/or -Wcast-qual warnings.\n\n\t* dwarf2out.c (new_cfi, queue_reg_save, dwarf2out_begin_prologue,\n\tdwarf2out_frame_init, new_loc_descr, new_die, lookup_decl_die,\n\tlookup_decl_loc, add_var_loc_to_decl, compute_section_prefix,\n\tassign_symbol_names, htab_cu_hash, htab_cu_eq, htab_cu_del,\n\tbuild_abbrev_table, new_loc_list, output_comp_unit, add_arange,\n\tadd_ranges_num, add_ranges_by_labels, file_info_cmp,\n\tfile_name_acquire, output_file_names, add_const_value_attribute,\n\tpremark_used_types_helper, file_table_eq, file_table_hash,\n\tlookup_filename, dwarf2out_var_location, dwarf2out_source_line,\n\tdwarf2out_init, file_table_relative_p): Fix -Wc++-compat and/or\n\t-Wcast-qual warnings.\n\t* ebitmap.c (ebitmap_array_grow, ebitmap_array_init,\n\tebitmap_alloc, ebitmap_ior, ebitmap_and_compl): Likewise.\n\t* emit-rtl.c (get_mem_attrs, get_reg_attrs, gen_rtvec,\n\tgen_reg_rtx, start_sequence, init_emit): Likewise.\n\t* et-forest.c (et_new_occ, et_new_tree): Likewise.\n\t* except.c (init_eh_for_function, gen_eh_region,\n\tremove_unreachable_regions, add_ehl_entry, duplicate_eh_regions_1,\n\tarh_to_landing_pad, arh_to_label, add_action_record,\n\tadd_call_site, switch_to_exception_section): Likewise.\n\t* expmed.c (synth_mult): Likewise.\n\t* expr.c (gen_group_rtx, emit_group_load, emit_group_store,\n\tstore_expr): Likewise.\n\t* final.c (shorten_branches, final_scan_insn, debug_queue_symbol):\n\tLikewise.\n\t* function.c (assign_stack_temp_for_type,\n\tallocate_struct_function, match_asm_constraints_1): Likewise.\n\t* gcov-io.c (gcov_allocate): Likewise.\n\t* gcse.c (GNEW, GCNEW, GNEWVEC, GCNEWVEC, GRESIZEVEC, GNEWVAR,\n\tGCNEWVAR, GRESIZEVAR, GOBNEW, GOBNEWVAR): New.\n\t(gcse_main, alloc_gcse_mem, alloc_gcse_mem, alloc_reg_set_mem,\n\trecord_one_set, insert_expr_in_table, insert_set_in_table,\n\tdump_hash_table, compute_hash_table_work, alloc_hash_table,\n\tpre_ldst_expr_hash, pre_ldst_expr_eq, find_rtx_in_ldst,\n\treg_set_info, reg_clear_last_set): Fix -Wc++-compat and/or\n\t-Wcast-qual warnings.\n\nFrom-SVN: r137136", "tree": {"sha": "5cf8ceabdd8f1c5995f5d74b7dc88765e4b60528", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cf8ceabdd8f1c5995f5d74b7dc88765e4b60528"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b4572a81dd40921680e70eef7469f0c80bc20e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b4572a81dd40921680e70eef7469f0c80bc20e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b4572a81dd40921680e70eef7469f0c80bc20e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b4572a81dd40921680e70eef7469f0c80bc20e0/comments", "author": null, "committer": null, "parents": [{"sha": "7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a"}], "stats": {"total": 311, "additions": 179, "deletions": 132}, "files": [{"sha": "d6d5920604450eef4699861ae6b93d274e38c7cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b4572a81dd40921680e70eef7469f0c80bc20e0", "patch": "@@ -1,3 +1,42 @@\n+2008-06-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* dwarf2out.c (new_cfi, queue_reg_save, dwarf2out_begin_prologue,\n+\tdwarf2out_frame_init, new_loc_descr, new_die, lookup_decl_die,\n+\tlookup_decl_loc, add_var_loc_to_decl, compute_section_prefix,\n+\tassign_symbol_names, htab_cu_hash, htab_cu_eq, htab_cu_del,\n+\tbuild_abbrev_table, new_loc_list, output_comp_unit, add_arange,\n+\tadd_ranges_num, add_ranges_by_labels, file_info_cmp,\n+\tfile_name_acquire, output_file_names, add_const_value_attribute,\n+\tpremark_used_types_helper, file_table_eq, file_table_hash,\n+\tlookup_filename, dwarf2out_var_location, dwarf2out_source_line,\n+\tdwarf2out_init, file_table_relative_p): Fix -Wc++-compat and/or\n+\t-Wcast-qual warnings.\n+\t* ebitmap.c (ebitmap_array_grow, ebitmap_array_init,\n+\tebitmap_alloc, ebitmap_ior, ebitmap_and_compl): Likewise.\n+\t* emit-rtl.c (get_mem_attrs, get_reg_attrs, gen_rtvec,\n+\tgen_reg_rtx, start_sequence, init_emit): Likewise.\n+\t* et-forest.c (et_new_occ, et_new_tree): Likewise.\n+\t* except.c (init_eh_for_function, gen_eh_region,\n+\tremove_unreachable_regions, add_ehl_entry, duplicate_eh_regions_1,\n+\tarh_to_landing_pad, arh_to_label, add_action_record,\n+\tadd_call_site, switch_to_exception_section): Likewise.\n+\t* expmed.c (synth_mult): Likewise.\n+\t* expr.c (gen_group_rtx, emit_group_load, emit_group_store,\n+\tstore_expr): Likewise.\n+\t* final.c (shorten_branches, final_scan_insn, debug_queue_symbol):\n+\tLikewise.\n+\t* function.c (assign_stack_temp_for_type,\n+\tallocate_struct_function, match_asm_constraints_1): Likewise.\n+\t* gcov-io.c (gcov_allocate): Likewise.\n+\t* gcse.c (GNEW, GCNEW, GNEWVEC, GCNEWVEC, GRESIZEVEC, GNEWVAR,\n+\tGCNEWVAR, GRESIZEVAR, GOBNEW, GOBNEWVAR): New.\n+\t(gcse_main, alloc_gcse_mem, alloc_gcse_mem, alloc_reg_set_mem,\n+\trecord_one_set, insert_expr_in_table, insert_set_in_table,\n+\tdump_hash_table, compute_hash_table_work, alloc_hash_table,\n+\tpre_ldst_expr_hash, pre_ldst_expr_eq, find_rtx_in_ldst,\n+\treg_set_info, reg_clear_last_set): Fix -Wc++-compat and/or\n+\t-Wcast-qual warnings.\n+\n 2008-06-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cse.c (approx_reg_cost_1, cse_insn): Fix -Wc++-compat and/or"}, {"sha": "f3d917e26796ccb8fea789fd1106c7d6ec5e8707", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 60, "deletions": 62, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=1b4572a81dd40921680e70eef7469f0c80bc20e0", "patch": "@@ -606,7 +606,7 @@ dwarf_cfi_name (unsigned int cfi_opc)\n static inline dw_cfi_ref\n new_cfi (void)\n {\n-  dw_cfi_ref cfi = ggc_alloc (sizeof (dw_cfi_node));\n+  dw_cfi_ref cfi = GGC_NEW (dw_cfi_node);\n \n   cfi->dw_cfi_next = NULL;\n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = 0;\n@@ -1251,7 +1251,7 @@ queue_reg_save (const char *label, rtx reg, rtx sreg, HOST_WIDE_INT offset)\n \n   if (q == NULL)\n     {\n-      q = ggc_alloc (sizeof (*q));\n+      q = GGC_NEW (struct queued_reg_save);\n       q->next = queued_reg_saves;\n       queued_reg_saves = q;\n     }\n@@ -2643,8 +2643,7 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   if (fde_table_in_use == fde_table_allocated)\n     {\n       fde_table_allocated += FDE_TABLE_INCREMENT;\n-      fde_table = ggc_realloc (fde_table,\n-\t\t\t       fde_table_allocated * sizeof (dw_fde_node));\n+      fde_table = GGC_RESIZEVEC (dw_fde_node, fde_table, fde_table_allocated);\n       memset (fde_table + fde_table_in_use, 0,\n \t      FDE_TABLE_INCREMENT * sizeof (dw_fde_node));\n     }\n@@ -2704,7 +2703,7 @@ void\n dwarf2out_frame_init (void)\n {\n   /* Allocate the initial hunk of the fde_table.  */\n-  fde_table = ggc_alloc_cleared (FDE_TABLE_INCREMENT * sizeof (dw_fde_node));\n+  fde_table = GGC_CNEWVEC (dw_fde_node, FDE_TABLE_INCREMENT);\n   fde_table_allocated = FDE_TABLE_INCREMENT;\n   fde_table_in_use = 0;\n \n@@ -3228,7 +3227,7 @@ static inline dw_loc_descr_ref\n new_loc_descr (enum dwarf_location_atom op, unsigned HOST_WIDE_INT oprnd1,\n \t       unsigned HOST_WIDE_INT oprnd2)\n {\n-  dw_loc_descr_ref descr = ggc_alloc_cleared (sizeof (dw_loc_descr_node));\n+  dw_loc_descr_ref descr = GGC_CNEW (dw_loc_descr_node);\n \n   descr->dw_loc_opc = op;\n   descr->dw_loc_oprnd1.val_class = dw_val_class_unsigned_const;\n@@ -5747,7 +5746,7 @@ splice_child_die (dw_die_ref parent, dw_die_ref child)\n static inline dw_die_ref\n new_die (enum dwarf_tag tag_value, dw_die_ref parent_die, tree t)\n {\n-  dw_die_ref die = ggc_alloc_cleared (sizeof (die_node));\n+  dw_die_ref die = GGC_CNEW (die_node);\n \n   die->die_tag = tag_value;\n \n@@ -5757,7 +5756,7 @@ new_die (enum dwarf_tag tag_value, dw_die_ref parent_die, tree t)\n     {\n       limbo_die_node *limbo_node;\n \n-      limbo_node = ggc_alloc_cleared (sizeof (limbo_die_node));\n+      limbo_node = GGC_CNEW (limbo_die_node);\n       limbo_node->die = die;\n       limbo_node->created_for = t;\n       limbo_node->next = limbo_die_list;\n@@ -5804,7 +5803,7 @@ decl_die_table_eq (const void *x, const void *y)\n static inline dw_die_ref\n lookup_decl_die (tree decl)\n {\n-  return htab_find_with_hash (decl_die_table, decl, DECL_UID (decl));\n+  return (dw_die_ref) htab_find_with_hash (decl_die_table, decl, DECL_UID (decl));\n }\n \n /* Returns a hash value for X (which really is a var_loc_list).  */\n@@ -5829,7 +5828,8 @@ decl_loc_table_eq (const void *x, const void *y)\n static inline var_loc_list *\n lookup_decl_loc (const_tree decl)\n {\n-  return htab_find_with_hash (decl_loc_table, decl, DECL_UID (decl));\n+  return (var_loc_list *)\n+    htab_find_with_hash (decl_loc_table, decl, DECL_UID (decl));\n }\n \n /* Equate a DIE to a particular declaration.  */\n@@ -5857,12 +5857,12 @@ add_var_loc_to_decl (tree decl, struct var_loc_node *loc)\n   slot = htab_find_slot_with_hash (decl_loc_table, decl, decl_id, INSERT);\n   if (*slot == NULL)\n     {\n-      temp = ggc_alloc_cleared (sizeof (var_loc_list));\n+      temp = GGC_CNEW (var_loc_list);\n       temp->decl_id = decl_id;\n       *slot = temp;\n     }\n   else\n-    temp = *slot;\n+    temp = (var_loc_list *) *slot;\n \n   if (temp->last)\n     {\n@@ -6354,7 +6354,7 @@ compute_section_prefix (dw_die_ref unit_die)\n {\n   const char *die_name = get_AT_string (unit_die, DW_AT_name);\n   const char *base = die_name ? lbasename (die_name) : \"anonymous\";\n-  char *name = alloca (strlen (base) + 64);\n+  char *name = XALLOCAVEC (char, strlen (base) + 64);\n   char *p;\n   int i, mark;\n   unsigned char checksum[16];\n@@ -6476,7 +6476,7 @@ assign_symbol_names (dw_die_ref die)\n     {\n       if (comdat_symbol_id)\n \t{\n-\t  char *p = alloca (strlen (comdat_symbol_id) + 64);\n+\t  char *p = XALLOCAVEC (char, strlen (comdat_symbol_id) + 64);\n \n \t  sprintf (p, \"%s.%s.%x\", DIE_LABEL_PREFIX,\n \t\t   comdat_symbol_id, comdat_symbol_number++);\n@@ -6500,24 +6500,27 @@ struct cu_hash_table_entry\n static hashval_t\n htab_cu_hash (const void *of)\n {\n-  const struct cu_hash_table_entry *entry = of;\n+  const struct cu_hash_table_entry *const entry =\n+    (const struct cu_hash_table_entry *) of;\n \n   return htab_hash_string (entry->cu->die_symbol);\n }\n \n static int\n htab_cu_eq (const void *of1, const void *of2)\n {\n-  const struct cu_hash_table_entry *entry1 = of1;\n-  const struct die_struct *entry2 = of2;\n+  const struct cu_hash_table_entry *const entry1 =\n+    (const struct cu_hash_table_entry *) of1;\n+  const struct die_struct *const entry2 = (const struct die_struct *) of2;\n \n   return !strcmp (entry1->cu->die_symbol, entry2->die_symbol);\n }\n \n static void\n htab_cu_del (void *what)\n {\n-  struct cu_hash_table_entry *next, *entry = what;\n+  struct cu_hash_table_entry *next,\n+    *entry = (struct cu_hash_table_entry *) what;\n \n   while (entry)\n     {\n@@ -6737,8 +6740,8 @@ build_abbrev_table (dw_die_ref die)\n       if (abbrev_die_table_in_use >= abbrev_die_table_allocated)\n \t{\n \t  n_alloc = abbrev_die_table_allocated + ABBREV_DIE_TABLE_INCREMENT;\n-\t  abbrev_die_table = ggc_realloc (abbrev_die_table,\n-\t\t\t\t\t  sizeof (dw_die_ref) * n_alloc);\n+\t  abbrev_die_table = GGC_RESIZEVEC (dw_die_ref, abbrev_die_table,\n+\t\t\t\t\t    n_alloc);\n \n \t  memset (&abbrev_die_table[abbrev_die_table_allocated], 0,\n \t\t (n_alloc - abbrev_die_table_allocated) * sizeof (dw_die_ref));\n@@ -7128,7 +7131,7 @@ static inline dw_loc_list_ref\n new_loc_list (dw_loc_descr_ref expr, const char *begin, const char *end,\n \t      const char *section, unsigned int gensym)\n {\n-  dw_loc_list_ref retlist = ggc_alloc_cleared (sizeof (dw_loc_list_node));\n+  dw_loc_list_ref retlist = GGC_CNEW (dw_loc_list_node);\n \n   retlist->begin = begin;\n   retlist->end = end;\n@@ -7458,7 +7461,7 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n   oldsym = die->die_symbol;\n   if (oldsym)\n     {\n-      tmp = alloca (strlen (oldsym) + 24);\n+      tmp = XALLOCAVEC (char, strlen (oldsym) + 24);\n \n       sprintf (tmp, \".gnu.linkonce.wi.%s\", oldsym);\n       secname = tmp;\n@@ -7602,9 +7605,8 @@ add_arange (tree decl, dw_die_ref die)\n   if (arange_table_in_use == arange_table_allocated)\n     {\n       arange_table_allocated += ARANGE_TABLE_INCREMENT;\n-      arange_table = ggc_realloc (arange_table,\n-\t\t\t\t  (arange_table_allocated\n-\t\t\t\t   * sizeof (dw_die_ref)));\n+      arange_table = GGC_RESIZEVEC (dw_die_ref, arange_table,\n+\t\t\t\t    arange_table_allocated);\n       memset (arange_table + arange_table_in_use, 0,\n \t      ARANGE_TABLE_INCREMENT * sizeof (dw_die_ref));\n     }\n@@ -7715,9 +7717,8 @@ add_ranges_num (int num)\n   if (in_use == ranges_table_allocated)\n     {\n       ranges_table_allocated += RANGES_TABLE_INCREMENT;\n-      ranges_table\n-\t= ggc_realloc (ranges_table, (ranges_table_allocated\n-\t\t\t\t      * sizeof (struct dw_ranges_struct)));\n+      ranges_table = GGC_RESIZEVEC (struct dw_ranges_struct, ranges_table,\n+\t\t\t\t    ranges_table_allocated);\n       memset (ranges_table + ranges_table_in_use, 0,\n \t      RANGES_TABLE_INCREMENT * sizeof (struct dw_ranges_struct));\n     }\n@@ -7748,10 +7749,9 @@ add_ranges_by_labels (const char *begin, const char *end)\n   if (in_use == ranges_by_label_allocated)\n     {\n       ranges_by_label_allocated += RANGES_TABLE_INCREMENT;\n-      ranges_by_label\n-\t= ggc_realloc (ranges_by_label,\n-\t\t       (ranges_by_label_allocated\n-\t\t\t* sizeof (struct dw_ranges_by_label_struct)));\n+      ranges_by_label = GGC_RESIZEVEC (struct dw_ranges_by_label_struct,\n+\t\t\t\t       ranges_by_label,\n+\t\t\t\t       ranges_by_label_allocated);\n       memset (ranges_by_label + ranges_by_label_in_use, 0,\n \t      RANGES_TABLE_INCREMENT\n \t      * sizeof (struct dw_ranges_by_label_struct));\n@@ -7876,8 +7876,8 @@ struct dir_info\n static int\n file_info_cmp (const void *p1, const void *p2)\n {\n-  const struct file_info *s1 = p1;\n-  const struct file_info *s2 = p2;\n+  const struct file_info *const s1 = (const struct file_info *) p1;\n+  const struct file_info *const s2 = (const struct file_info *) p2;\n   const unsigned char *cp1;\n   const unsigned char *cp2;\n \n@@ -7920,8 +7920,8 @@ struct file_name_acquire_data\n static int\n file_name_acquire (void ** slot, void *data)\n {\n-  struct file_name_acquire_data *fnad = data;\n-  struct dwarf_file_data *d = *slot;\n+  struct file_name_acquire_data *fnad = (struct file_name_acquire_data *) data;\n+  struct dwarf_file_data *d = (struct dwarf_file_data *) *slot;\n   struct file_info *fi;\n   const char *f;\n \n@@ -7991,8 +7991,8 @@ output_file_names (void)\n   numfiles = last_emitted_file->emitted_number;\n \n   /* Allocate the various arrays we need.  */\n-  files = alloca (numfiles * sizeof (struct file_info));\n-  dirs = alloca (numfiles * sizeof (struct dir_info));\n+  files = XALLOCAVEC (struct file_info, numfiles);\n+  dirs = XALLOCAVEC (struct dir_info, numfiles);\n \n   fnad.files = files;\n   fnad.used_files = 0;\n@@ -8050,8 +8050,8 @@ output_file_names (void)\n      where we would have to check out every combination of every single\n      possible prefix.  Instead we use a heuristic which provides nearly optimal\n      results in most cases and never is much off.  */\n-  saved = alloca (ndirs * sizeof (int));\n-  savehere = alloca (ndirs * sizeof (int));\n+  saved = XALLOCAVEC (int, ndirs);\n+  savehere = XALLOCAVEC (int, ndirs);\n \n   memset (saved, '\\0', ndirs * sizeof (saved[0]));\n   for (i = 0; i < ndirs; i++)\n@@ -8117,7 +8117,7 @@ output_file_names (void)\n   /* We have to emit them in the order of emitted_number since that's\n      used in the debug info generation.  To do this efficiently we\n      generate a back-mapping of the indices first.  */\n-  backmap = alloca (numfiles * sizeof (int));\n+  backmap = XALLOCAVEC (int, numfiles);\n   for (i = 0; i < numfiles; i++)\n     backmap[files[i].file_idx->emitted_number - 1] = i;\n \n@@ -10293,7 +10293,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \tif (SCALAR_FLOAT_MODE_P (mode))\n \t  {\n \t    unsigned int length = GET_MODE_SIZE (mode);\n-\t    unsigned char *array = ggc_alloc (length);\n+\t    unsigned char *array = GGC_NEWVEC (unsigned char, length);\n \n \t    insert_float (rtl, array);\n \t    add_AT_vec (die, DW_AT_const_value, length / 4, 4, array);\n@@ -10314,7 +10314,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \tenum machine_mode mode = GET_MODE (rtl);\n \tunsigned int elt_size = GET_MODE_UNIT_SIZE (mode);\n \tunsigned int length = CONST_VECTOR_NUNITS (rtl);\n-\tunsigned char *array = ggc_alloc (length * elt_size);\n+\tunsigned char *array = GGC_NEWVEC (unsigned char, length * elt_size);\n \tunsigned int i;\n \tunsigned char *p;\n \n@@ -12359,7 +12359,7 @@ premark_used_types_helper (void **slot, void *data ATTRIBUTE_UNUSED)\n   tree type;\n   dw_die_ref die;\n \n-  type = *slot;\n+  type = (tree) *slot;\n   die = lookup_type_die (type);\n   if (die != NULL)\n     die->die_perennial_p = 1;\n@@ -14423,15 +14423,16 @@ dwarf2out_ignore_block (const_tree block)\n static int\n file_table_eq (const void *p1_p, const void *p2_p)\n {\n-  const struct dwarf_file_data * p1 = p1_p;\n-  const char * p2 = p2_p;\n+  const struct dwarf_file_data *const p1 =\n+    (const struct dwarf_file_data *) p1_p;\n+  const char *const p2 = (const char *) p2_p;\n   return strcmp (p1->filename, p2) == 0;\n }\n \n static hashval_t\n file_table_hash (const void *p_p)\n {\n-  const struct dwarf_file_data * p = p_p;\n+  const struct dwarf_file_data *const p = (const struct dwarf_file_data *) p_p;\n   return htab_hash_string (p->filename);\n }\n \n@@ -14463,9 +14464,9 @@ lookup_filename (const char *file_name)\n   slot = htab_find_slot_with_hash (file_table, file_name,\n \t\t\t\t   htab_hash_string (file_name), INSERT);\n   if (*slot)\n-    return *slot;\n+    return (struct dwarf_file_data *) *slot;\n \n-  created = ggc_alloc (sizeof (struct dwarf_file_data));\n+  created = GGC_NEW (struct dwarf_file_data);\n   created->filename = file_name;\n   created->emitted_number = 0;\n   *slot = created;\n@@ -14519,7 +14520,7 @@ dwarf2out_var_location (rtx loc_note)\n     return;\n   prev_insn = PREV_INSN (loc_note);\n \n-  newloc = ggc_alloc_cleared (sizeof (struct var_loc_node));\n+  newloc = GGC_CNEW (struct var_loc_node);\n   /* If the insn we processed last time is the previous insn\n      and it is also a var location note, use the label we emitted\n      last time.  */\n@@ -14607,9 +14608,9 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n \t    {\n \t      separate_line_info_table_allocated += LINE_INFO_TABLE_INCREMENT;\n \t      separate_line_info_table\n-\t\t= ggc_realloc (separate_line_info_table,\n-\t\t\t       separate_line_info_table_allocated\n-\t\t\t       * sizeof (dw_separate_line_info_entry));\n+\t\t= GGC_RESIZEVEC (dw_separate_line_info_entry,\n+\t\t\t\t separate_line_info_table,\n+\t\t\t\t separate_line_info_table_allocated);\n \t      memset (separate_line_info_table\n \t\t       + separate_line_info_table_in_use,\n \t\t      0,\n@@ -14636,9 +14637,8 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n \t    {\n \t      line_info_table_allocated += LINE_INFO_TABLE_INCREMENT;\n \t      line_info_table\n-\t\t= ggc_realloc (line_info_table,\n-\t\t\t       (line_info_table_allocated\n-\t\t\t\t* sizeof (dw_line_info_entry)));\n+\t\t= GGC_RESIZEVEC (dw_line_info_entry, line_info_table,\n+\t\t\t\t line_info_table_allocated);\n \t      memset (line_info_table + line_info_table_in_use, 0,\n \t\t      LINE_INFO_TABLE_INCREMENT * sizeof (dw_line_info_entry));\n \t    }\n@@ -14749,15 +14749,13 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   decl_scope_table = VEC_alloc (tree, gc, 256);\n \n   /* Allocate the initial hunk of the abbrev_die_table.  */\n-  abbrev_die_table = ggc_alloc_cleared (ABBREV_DIE_TABLE_INCREMENT\n-\t\t\t\t\t* sizeof (dw_die_ref));\n+  abbrev_die_table = GGC_CNEWVEC (dw_die_ref, ABBREV_DIE_TABLE_INCREMENT);\n   abbrev_die_table_allocated = ABBREV_DIE_TABLE_INCREMENT;\n   /* Zero-th entry is allocated, but unused.  */\n   abbrev_die_table_in_use = 1;\n \n   /* Allocate the initial hunk of the line_info_table.  */\n-  line_info_table = ggc_alloc_cleared (LINE_INFO_TABLE_INCREMENT\n-\t\t\t\t       * sizeof (dw_line_info_entry));\n+  line_info_table = GGC_CNEWVEC (dw_line_info_entry, LINE_INFO_TABLE_INCREMENT);\n   line_info_table_allocated = LINE_INFO_TABLE_INCREMENT;\n \n   /* Zero-th entry is allocated, but unused.  */\n@@ -15121,8 +15119,8 @@ prune_unused_types (void)\n static int\n file_table_relative_p (void ** slot, void *param)\n {\n-  bool *p = param;\n-  struct dwarf_file_data *d = *slot;\n+  bool *p = (bool *) param;\n+  struct dwarf_file_data *d = (struct dwarf_file_data *) *slot;\n   if (!IS_ABSOLUTE_PATH (d->filename))\n     {\n       *p = true;"}, {"sha": "d25a163ff14a248fc1d25f27c5b7effb491c8d72", "filename": "gcc/ebitmap.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Febitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Febitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.c?ref=1b4572a81dd40921680e70eef7469f0c80bc20e0", "patch": "@@ -118,7 +118,7 @@ ebitmap_array_grow (ebitmap map, unsigned int newsize)\n   newsize += newsize / 4;\n \n   map->n_elts = newsize;\n-  map->elts = xrealloc (map->elts, sizeof (EBITMAP_ELT_TYPE) * newsize);\n+  map->elts = XRESIZEVEC (EBITMAP_ELT_TYPE, map->elts, newsize);\n }\n \n /* Grow the internal word array for MAP so it is at least SIZE\n@@ -161,7 +161,7 @@ ebitmap_array_init (ebitmap map, unsigned int size)\n {\n   if (size > 0)\n     {\n-      map->elts = xmalloc (sizeof (EBITMAP_ELT_TYPE) * size);\n+      map->elts = XNEWVEC (EBITMAP_ELT_TYPE, size);\n       map->n_elts = size;\n     }\n   else\n@@ -202,7 +202,7 @@ ebitmap_clear (ebitmap map)\n ebitmap\n ebitmap_alloc (unsigned int size)\n {\n-  ebitmap ret = xmalloc (sizeof (struct ebitmap_def));\n+  ebitmap ret = XNEW (struct ebitmap_def);\n   if (size == 0)\n     size = EBITMAP_ELT_BITS;\n   ebitmap_array_init (ret, (size + EBITMAP_ELT_BITS - 1) / EBITMAP_ELT_BITS);\n@@ -595,7 +595,7 @@ ebitmap_ior_into (ebitmap dst, ebitmap src)\n \t}\n     }\n   newarraysize = src->numwords + dst->numwords;\n-  newarray = xmalloc (newarraysize * sizeof (EBITMAP_ELT_TYPE));\n+  newarray = XNEWVEC (EBITMAP_ELT_TYPE, newarraysize);\n \n   EXECUTE_IF_SET_IN_SBITMAP (tempmask, 0, i, sbi)\n     {\n@@ -704,7 +704,7 @@ ebitmap_ior (ebitmap dst, ebitmap src1, ebitmap src2)\n \t}\n     }\n   newarraysize = src1->numwords + src2->numwords;\n-  newarray = xmalloc (newarraysize * sizeof (EBITMAP_ELT_TYPE));\n+  newarray = XNEWVEC (EBITMAP_ELT_TYPE, newarraysize);\n \n   EXECUTE_IF_SET_IN_SBITMAP (tempmask, 0, i, sbi)\n     {\n@@ -883,7 +883,7 @@ ebitmap_and_compl (ebitmap dst, ebitmap src1, ebitmap src2)\n   sbitmap_copy (tempmask, src1->wordmask);\n \n   newarraysize = src1->numwords;\n-  newarray = xmalloc (newarraysize * sizeof (EBITMAP_ELT_TYPE));\n+  newarray = XNEWVEC (EBITMAP_ELT_TYPE, newarraysize);\n \n   EXECUTE_IF_SET_IN_SBITMAP (src1->wordmask, 0, i, sbi)\n     {"}, {"sha": "899679cd2966b149c4f5da89effb9f71a9079d91", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=1b4572a81dd40921680e70eef7469f0c80bc20e0", "patch": "@@ -349,7 +349,7 @@ get_mem_attrs (alias_set_type alias, tree expr, rtx offset, rtx size,\n       memcpy (*slot, &attrs, sizeof (mem_attrs));\n     }\n \n-  return *slot;\n+  return (mem_attrs *) *slot;\n }\n \n /* Returns a hash code for X (which is a really a reg_attrs *).  */\n@@ -398,7 +398,7 @@ get_reg_attrs (tree decl, int offset)\n       memcpy (*slot, &attrs, sizeof (reg_attrs));\n     }\n \n-  return *slot;\n+  return (reg_attrs *) *slot;\n }\n \n \n@@ -812,7 +812,7 @@ gen_rtvec (int n, ...)\n   if (n == 0)\n     return NULL_RTVEC;\t\t/* Don't allocate an empty rtvec...\t*/\n \n-  vector = alloca (n * sizeof (rtx));\n+  vector = XALLOCAVEC (rtx, n);\n \n   for (i = 0; i < n; i++)\n     vector[i] = va_arg (p, rtx);\n@@ -893,12 +893,11 @@ gen_reg_rtx (enum machine_mode mode)\n       char *new;\n       rtx *new1;\n \n-      new = xrealloc (crtl->emit.regno_pointer_align, old_size * 2);\n+      new = XRESIZEVEC (char, crtl->emit.regno_pointer_align, old_size * 2);\n       memset (new + old_size, 0, old_size);\n       crtl->emit.regno_pointer_align = (unsigned char *) new;\n \n-      new1 = ggc_realloc (regno_reg_rtx,\n-\t\t\t  old_size * 2 * sizeof (rtx));\n+      new1 = GGC_RESIZEVEC (rtx, regno_reg_rtx, old_size * 2);\n       memset (new1 + old_size, 0, old_size * sizeof (rtx));\n       regno_reg_rtx = new1;\n \n@@ -4741,7 +4740,7 @@ start_sequence (void)\n       free_sequence_stack = tem->next;\n     }\n   else\n-    tem = ggc_alloc (sizeof (struct sequence_stack));\n+    tem = GGC_NEW (struct sequence_stack);\n \n   tem->next = seq_stack;\n   tem->first = first_insn;\n@@ -5047,11 +5046,10 @@ init_emit (void)\n   crtl->emit.regno_pointer_align_length = LAST_VIRTUAL_REGISTER + 101;\n \n   crtl->emit.regno_pointer_align\n-    = xcalloc (crtl->emit.regno_pointer_align_length\n-\t       * sizeof (unsigned char), 1);\n+    = XCNEWVEC (unsigned char, crtl->emit.regno_pointer_align_length);\n \n   regno_reg_rtx\n-    = ggc_alloc (crtl->emit.regno_pointer_align_length * sizeof (rtx));\n+    = GGC_NEWVEC (rtx, crtl->emit.regno_pointer_align_length);\n \n   /* Put copies of all the hard registers into regno_reg_rtx.  */\n   memcpy (regno_reg_rtx,"}, {"sha": "e87322c6428eae40dcb90dac7a976139a41c0496", "filename": "gcc/et-forest.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=1b4572a81dd40921680e70eef7469f0c80bc20e0", "patch": "@@ -447,7 +447,7 @@ et_new_occ (struct et_node *node)\n   \n   if (!et_occurrences)\n     et_occurrences = create_alloc_pool (\"et_occ pool\", sizeof (struct et_occ), 300);\n-  nw = pool_alloc (et_occurrences);\n+  nw = (struct et_occ *) pool_alloc (et_occurrences);\n \n   nw->of = node;\n   nw->parent = NULL;\n@@ -470,7 +470,7 @@ et_new_tree (void *data)\n   \n   if (!et_nodes)\n     et_nodes = create_alloc_pool (\"et_node pool\", sizeof (struct et_node), 300);\n-  nw = pool_alloc (et_nodes);\n+  nw = (struct et_node *) pool_alloc (et_nodes);\n \n   nw->data = data;\n   nw->father = NULL;"}, {"sha": "1d9a73639b6c2a36c17f87f63102bc40129c14de", "filename": "gcc/except.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=1b4572a81dd40921680e70eef7469f0c80bc20e0", "patch": "@@ -409,7 +409,7 @@ init_eh (void)\n void\n init_eh_for_function (void)\n {\n-  cfun->eh = ggc_alloc_cleared (sizeof (struct eh_status));\n+  cfun->eh = GGC_CNEW (struct eh_status);\n }\n \f\n /* Routines to generate the exception tree somewhat directly.\n@@ -426,7 +426,7 @@ gen_eh_region (enum eh_region_type type, struct eh_region *outer)\n #endif\n \n   /* Insert a new blank region as a leaf in the tree.  */\n-  new = ggc_alloc_cleared (sizeof (*new));\n+  new = GGC_CNEW (struct eh_region);\n   new->type = type;\n   new->outer = outer;\n   if (outer)\n@@ -632,8 +632,8 @@ remove_unreachable_regions (rtx insns)\n   struct eh_region *r;\n   rtx insn;\n \n-  uid_region_num = xcalloc (get_max_uid (), sizeof(int));\n-  reachable = xcalloc (cfun->eh->last_region_number + 1, sizeof(bool));\n+  uid_region_num = XCNEWVEC (int, get_max_uid ());\n+  reachable = XCNEWVEC (bool, cfun->eh->last_region_number + 1);\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n@@ -736,7 +736,7 @@ add_ehl_entry (rtx label, struct eh_region *region)\n \n   LABEL_PRESERVE_P (label) = 1;\n \n-  entry = ggc_alloc (sizeof (*entry));\n+  entry = GGC_NEW (struct ehl_map_entry);\n   entry->label = label;\n   entry->region = region;\n \n@@ -847,7 +847,7 @@ duplicate_eh_regions_1 (eh_region old, eh_region outer, int eh_offset)\n {\n   eh_region ret, n;\n \n-  ret = n = ggc_alloc (sizeof (struct eh_region));\n+  ret = n = GGC_NEW (struct eh_region);\n \n   *n = *old;\n   n->outer = outer;\n@@ -2587,15 +2587,15 @@ foreach_reachable_handler (int region_number, bool is_resx,\n static void\n arh_to_landing_pad (struct eh_region *region, void *data)\n {\n-  rtx *p_handlers = data;\n+  rtx *p_handlers = (rtx *) data;\n   if (! *p_handlers)\n     *p_handlers = alloc_INSN_LIST (region->landing_pad, NULL_RTX);\n }\n \n static void\n arh_to_label (struct eh_region *region, void *data)\n {\n-  rtx *p_handlers = data;\n+  rtx *p_handlers = (rtx *) data;\n   *p_handlers = alloc_INSN_LIST (region->label, *p_handlers);\n }\n \n@@ -3055,7 +3055,7 @@ add_action_record (htab_t ar_hash, int filter, int next)\n \n   if ((new = *slot) == NULL)\n     {\n-      new = xmalloc (sizeof (*new));\n+      new = XNEW (struct action_record);\n       new->offset = VARRAY_ACTIVE_SIZE (crtl->eh.action_record_data) + 1;\n       new->filter = filter;\n       new->next = next;\n@@ -3191,7 +3191,7 @@ add_call_site (rtx landing_pad, int action)\n {\n   call_site_record record;\n   \n-  record = ggc_alloc (sizeof (struct call_site_record));\n+  record = GGC_NEW (struct call_site_record);\n   record->landing_pad = landing_pad;\n   record->action = action;\n \n@@ -3522,7 +3522,7 @@ switch_to_exception_section (const char * ARG_UNUSED (fnname))\n #ifdef HAVE_LD_EH_GC_SECTIONS\n \t  if (flag_function_sections)\n \t    {\n-\t      char *section_name = xmalloc (strlen (fnname) + 32);\n+\t      char *section_name = XNEWVEC (char, strlen (fnname) + 32);\n \t      sprintf (section_name, \".gcc_except_table.%s\", fnname);\n \t      s = get_section (section_name, flags, NULL);\n \t      free (section_name);"}, {"sha": "bf045fee3605dcb6d8f79fd4e5e3f2ec99fecf68", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=1b4572a81dd40921680e70eef7469f0c80bc20e0", "patch": "@@ -2381,8 +2381,8 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \n   /* We'll be needing a couple extra algorithm structures now.  */\n \n-  alg_in = alloca (sizeof (struct algorithm));\n-  best_alg = alloca (sizeof (struct algorithm));\n+  alg_in = XALLOCA (struct algorithm);\n+  best_alg = XALLOCA (struct algorithm);\n   best_cost = *cost_limit;\n \n   /* Compute the hash index.  */"}, {"sha": "6d6278a7bc7cd1ace8a7c5b5ce6b3af45c7bb2b2", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1b4572a81dd40921680e70eef7469f0c80bc20e0", "patch": "@@ -1614,7 +1614,7 @@ gen_group_rtx (rtx orig)\n   gcc_assert (GET_CODE (orig) == PARALLEL);\n \n   length = XVECLEN (orig, 0);\n-  tmps = alloca (sizeof (rtx) * length);\n+  tmps = XALLOCAVEC (rtx, length);\n \n   /* Skip a NULL entry in first slot.  */\n   i = XEXP (XVECEXP (orig, 0, 0), 0) ? 0 : 1;\n@@ -1819,7 +1819,7 @@ emit_group_load (rtx dst, rtx src, tree type, int ssize)\n   rtx *tmps;\n   int i;\n \n-  tmps = alloca (sizeof (rtx) * XVECLEN (dst, 0));\n+  tmps = XALLOCAVEC (rtx, XVECLEN (dst, 0));\n   emit_group_load_1 (tmps, dst, src, type, ssize);\n \n   /* Copy the extracted pieces into the proper (probable) hard regs.  */\n@@ -1939,7 +1939,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n     start = 1;\n   finish = XVECLEN (src, 0);\n \n-  tmps = alloca (sizeof (rtx) * finish);\n+  tmps = XALLOCAVEC (rtx, finish);\n \n   /* Copy the (probable) hard regs into pseudos.  */\n   for (i = start; i < finish; i++)\n@@ -4555,15 +4555,15 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t}\n       str_copy_len = MIN (str_copy_len, exp_len);\n       if (!can_store_by_pieces (str_copy_len, builtin_strncpy_read_str,\n-\t\t\t\t(void *) TREE_STRING_POINTER (exp),\n+\t\t\t\tCONST_CAST(char *, TREE_STRING_POINTER (exp)),\n \t\t\t\tMEM_ALIGN (target), false))\n \tgoto normal_expr;\n \n       dest_mem = target;\n \n       dest_mem = store_by_pieces (dest_mem,\n \t\t\t\t  str_copy_len, builtin_strncpy_read_str,\n-\t\t\t\t  (void *) TREE_STRING_POINTER (exp),\n+\t\t\t\t  CONST_CAST(char *, TREE_STRING_POINTER (exp)),\n \t\t\t\t  MEM_ALIGN (target), false,\n \t\t\t\t  exp_len > str_copy_len ? 1 : 0);\n       if (exp_len > str_copy_len)"}, {"sha": "1f673fb7858a5ba995dbbf7be9da3308d6d927af", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=1b4572a81dd40921680e70eef7469f0c80bc20e0", "patch": "@@ -858,8 +858,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n       n_labels = max_labelno - min_labelno + 1;\n       n_old_labels = old - min_labelno + 1;\n \n-      label_align = xrealloc (label_align,\n-\t\t\t      n_labels * sizeof (struct label_alignment));\n+      label_align = XRESIZEVEC (struct label_alignment, label_align, n_labels);\n \n       /* Range of labels grows monotonically in the function.  Failing here\n          means that the initialization of array got lost.  */\n@@ -2181,7 +2180,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \tif (asm_noperands (body) >= 0)\n \t  {\n \t    unsigned int noperands = asm_noperands (body);\n-\t    rtx *ops = alloca (noperands * sizeof (rtx));\n+\t    rtx *ops = XALLOCAVEC (rtx, noperands);\n \t    const char *string;\n \t    location_t loc;\n \t    expanded_location expanded;\n@@ -4056,8 +4055,7 @@ debug_queue_symbol (tree decl)\n   if (symbol_queue_index >= symbol_queue_size)\n     {\n       symbol_queue_size += 10;\n-      symbol_queue = xrealloc (symbol_queue,\n-\t\t\t       symbol_queue_size * sizeof (tree));\n+      symbol_queue = XRESIZEVEC (tree, symbol_queue, symbol_queue_size);\n     }\n \n   symbol_queue[symbol_queue_index++] = decl;"}, {"sha": "c8d5e77daaafb6fff94b143eea5df1be16c0a29a", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=1b4572a81dd40921680e70eef7469f0c80bc20e0", "patch": "@@ -598,7 +598,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n \n \t  if (best_p->size - rounded_size >= alignment)\n \t    {\n-\t      p = ggc_alloc (sizeof (struct temp_slot));\n+\t      p = GGC_NEW (struct temp_slot);\n \t      p->in_use = p->addr_taken = 0;\n \t      p->size = best_p->size - rounded_size;\n \t      p->base_offset = best_p->base_offset + rounded_size;\n@@ -623,7 +623,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n     {\n       HOST_WIDE_INT frame_offset_old = frame_offset;\n \n-      p = ggc_alloc (sizeof (struct temp_slot));\n+      p = GGC_NEW (struct temp_slot);\n \n       /* We are passing an explicit alignment request to assign_stack_local.\n \t One side effect of that is assign_stack_local will not round SIZE\n@@ -3841,7 +3841,7 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n   tree result;\n   tree fntype = fndecl ? TREE_TYPE (fndecl) : NULL_TREE;\n \n-  cfun = ggc_alloc_cleared (sizeof (struct function));\n+  cfun = GGC_CNEW (struct function);\n \n   current_function_funcdef_no = get_next_funcdef_no ();\n \n@@ -5251,7 +5251,7 @@ match_asm_constraints_1 (rtx insn, rtx *p_sets, int noutputs)\n   rtx op = SET_SRC (p_sets[0]);\n   int ninputs = ASM_OPERANDS_INPUT_LENGTH (op);\n   rtvec inputs = ASM_OPERANDS_INPUT_VEC (op);\n-  bool *output_matched = alloca (noutputs * sizeof (bool));\n+  bool *output_matched = XALLOCAVEC (bool, noutputs);\n \n   memset (output_matched, 0, noutputs * sizeof (bool));\n   for (i = 0; i < ninputs; i++)"}, {"sha": "98a9287debd1c146b296192d5400a8a28e2fd1f3", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=1b4572a81dd40921680e70eef7469f0c80bc20e0", "patch": "@@ -196,7 +196,7 @@ gcov_allocate (unsigned length)\n   new_size *= 2;\n   \n   gcov_var.alloc = new_size;\n-  gcov_var.buffer = xrealloc (gcov_var.buffer, new_size << 2);\n+  gcov_var.buffer = XRESIZEVAR (gcov_unsigned_t, gcov_var.buffer, new_size << 2);\n }\n #endif\n "}, {"sha": "771df43a32134c873105ccb295c58233aa1ea043", "filename": "gcc/gcse.c", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4572a81dd40921680e70eef7469f0c80bc20e0/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=1b4572a81dd40921680e70eef7469f0c80bc20e0", "patch": "@@ -638,6 +638,20 @@ static void local_cprop_find_used_regs (rtx *, void *);\n static bool do_local_cprop (rtx, rtx, bool);\n static void local_cprop_pass (bool);\n static bool is_too_expensive (const char *);\n+\n+#define GNEW(T)\t\t\t((T *) gmalloc (sizeof (T)))\n+#define GCNEW(T)\t\t((T *) gcalloc (1, sizeof (T)))\n+\n+#define GNEWVEC(T, N)\t\t((T *) gmalloc (sizeof (T) * (N)))\n+#define GCNEWVEC(T, N)\t\t((T *) gcalloc ((N), sizeof (T)))\n+#define GRESIZEVEC(T, P, N)\t((T *) grealloc ((void *) (P), sizeof (T) * (N)))\n+\n+#define GNEWVAR(T, S)\t\t((T *) gmalloc ((S)))\n+#define GCNEWVAR(T, S)\t\t((T *) gcalloc (1, (S)))\n+#define GRESIZEVAR(T, P, S)\t((T *) grealloc ((P), (S)))\n+\n+#define GOBNEW(T)\t\t((T *) gcse_alloc (sizeof (T)))\n+#define GOBNEWVAR(T, S)\t\t((T *) gcse_alloc ((S)))\n \f\n \n /* Entry point for global common subexpression elimination.\n@@ -698,7 +712,7 @@ gcse_main (rtx f ATTRIBUTE_UNUSED)\n   pass = 0;\n   initial_bytes_used = bytes_used;\n   max_pass_bytes = 0;\n-  gcse_obstack_bottom = gcse_alloc (1);\n+  gcse_obstack_bottom = GOBNEWVAR (char, 1);\n   changed = 1;\n   while (changed && pass < MAX_GCSE_PASSES)\n     {\n@@ -736,8 +750,8 @@ gcse_main (rtx f ATTRIBUTE_UNUSED)\n \t  if (changed)\n \t    {\n \t      free_modify_mem_tables ();\n-\t      modify_mem_list = gcalloc (last_basic_block, sizeof (rtx));\n-\t      canon_modify_mem_list = gcalloc (last_basic_block, sizeof (rtx));\n+\t      modify_mem_list = GCNEWVEC (rtx, last_basic_block);\n+\t      canon_modify_mem_list = GCNEWVEC (rtx, last_basic_block);\n \t    }\n \t  free_reg_set_mem ();\n \t  alloc_reg_set_mem (max_reg_num ());\n@@ -931,7 +945,7 @@ alloc_gcse_mem (void)\n      but we should never see those anyway, so this is OK.)  */\n \n   max_uid = get_max_uid ();\n-  uid_cuid = gcalloc (max_uid + 1, sizeof (int));\n+  uid_cuid = GCNEWVEC (int, max_uid + 1);\n   i = 0;\n   FOR_EACH_BB (bb)\n     FOR_BB_INSNS (bb, insn)\n@@ -951,8 +965,8 @@ alloc_gcse_mem (void)\n   reg_set_in_block = sbitmap_vector_alloc (last_basic_block, max_gcse_regno);\n   /* Allocate array to keep a list of insns which modify memory in each\n      basic block.  */\n-  modify_mem_list = gcalloc (last_basic_block, sizeof (rtx));\n-  canon_modify_mem_list = gcalloc (last_basic_block, sizeof (rtx));\n+  modify_mem_list = GCNEWVEC (rtx, last_basic_block);\n+  canon_modify_mem_list = GCNEWVEC (rtx, last_basic_block);\n   modify_mem_list_set = BITMAP_ALLOC (NULL);\n   blocks_with_calls = BITMAP_ALLOC (NULL);\n }\n@@ -1076,7 +1090,7 @@ static void\n alloc_reg_set_mem (int n_regs)\n {\n   reg_set_table_size = n_regs + REG_SET_TABLE_SLOP;\n-  reg_set_table = gcalloc (reg_set_table_size, sizeof (struct reg_set *));\n+  reg_set_table = GCNEWVEC (struct reg_set *, reg_set_table_size);\n \n   gcc_obstack_init (&reg_set_obstack);\n }\n@@ -1101,14 +1115,13 @@ record_one_set (int regno, rtx insn)\n     {\n       int new_size = regno + REG_SET_TABLE_SLOP;\n \n-      reg_set_table = grealloc (reg_set_table,\n-\t\t\t\tnew_size * sizeof (struct reg_set *));\n+      reg_set_table = GRESIZEVEC (struct reg_set *, reg_set_table, new_size);\n       memset (reg_set_table + reg_set_table_size, 0,\n \t      (new_size - reg_set_table_size) * sizeof (struct reg_set *));\n       reg_set_table_size = new_size;\n     }\n \n-  new_reg_info = obstack_alloc (&reg_set_obstack, sizeof (struct reg_set));\n+  new_reg_info = XOBNEW (&reg_set_obstack, struct reg_set);\n   bytes_used += sizeof (struct reg_set);\n   new_reg_info->bb_index = BLOCK_NUM (insn);\n   new_reg_info->next = reg_set_table[regno];\n@@ -1509,7 +1522,7 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n \n   if (! found)\n     {\n-      cur_expr = gcse_alloc (sizeof (struct expr));\n+      cur_expr = GOBNEW (struct expr);\n       bytes_used += sizeof (struct expr);\n       if (table->table[hash] == NULL)\n \t/* This is the first pattern that hashed to this index.  */\n@@ -1542,7 +1555,7 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n       else\n \t{\n \t  /* First occurrence of this expression in this basic block.  */\n-\t  antic_occr = gcse_alloc (sizeof (struct occr));\n+\t  antic_occr = GOBNEW (struct occr);\n \t  bytes_used += sizeof (struct occr);\n \t  antic_occr->insn = insn;\n \t  antic_occr->next = cur_expr->antic_occr;\n@@ -1566,7 +1579,7 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n       else\n \t{\n \t  /* First occurrence of this expression in this basic block.  */\n-\t  avail_occr = gcse_alloc (sizeof (struct occr));\n+\t  avail_occr = GOBNEW (struct occr);\n \t  bytes_used += sizeof (struct occr);\n \t  avail_occr->insn = insn;\n \t  avail_occr->next = cur_expr->avail_occr;\n@@ -1606,7 +1619,7 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table *table)\n \n   if (! found)\n     {\n-      cur_expr = gcse_alloc (sizeof (struct expr));\n+      cur_expr = GOBNEW (struct expr);\n       bytes_used += sizeof (struct expr);\n       if (table->table[hash] == NULL)\n \t/* This is the first pattern that hashed to this index.  */\n@@ -1639,7 +1652,7 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table *table)\n   else\n     {\n       /* First occurrence of this expression in this basic block.  */\n-      cur_occr = gcse_alloc (sizeof (struct occr));\n+      cur_occr = GOBNEW (struct occr);\n       bytes_used += sizeof (struct occr);\n \n \t  cur_occr->insn = insn;\n@@ -1878,8 +1891,8 @@ dump_hash_table (FILE *file, const char *name, struct hash_table *table)\n   unsigned int *hash_val;\n   struct expr *expr;\n \n-  flat_table = xcalloc (table->n_elems, sizeof (struct expr *));\n-  hash_val = xmalloc (table->n_elems * sizeof (unsigned int));\n+  flat_table = XCNEWVEC (struct expr *, table->n_elems);\n+  hash_val = XNEWVEC (unsigned int, table->n_elems);\n \n   for (i = 0; i < (int) table->size; i++)\n     for (expr = table->table[i]; expr != NULL; expr = expr->next_same_hash)\n@@ -2048,7 +2061,7 @@ compute_hash_table_work (struct hash_table *table)\n   /* re-Cache any INSN_LIST nodes we have allocated.  */\n   clear_modify_mem_tables ();\n   /* Some working arrays used to track first and last set in each block.  */\n-  reg_avail_info = gmalloc (max_gcse_regno * sizeof (struct reg_avail_info));\n+  reg_avail_info = GNEWVEC (struct reg_avail_info, max_gcse_regno);\n \n   for (i = 0; i < max_gcse_regno; ++i)\n     reg_avail_info[i].last_bb = NULL;\n@@ -2116,7 +2129,7 @@ alloc_hash_table (int n_insns, struct hash_table *table, int set_p)\n      ??? Later take some measurements.  */\n   table->size |= 1;\n   n = table->size * sizeof (struct expr *);\n-  table->table = gmalloc (n);\n+  table->table = GNEWVAR (struct expr *, n);\n   table->set_p = set_p;\n }\n \n@@ -4988,14 +5001,15 @@ static hashval_t\n pre_ldst_expr_hash (const void *p)\n {\n   int do_not_record_p = 0;\n-  const struct ls_expr *x = p;\n+  const struct ls_expr *const x = (const struct ls_expr *) p;\n   return hash_rtx (x->pattern, GET_MODE (x->pattern), &do_not_record_p, NULL, false);\n }\n \n static int\n pre_ldst_expr_eq (const void *p1, const void *p2)\n {\n-  const struct ls_expr *ptr1 = p1, *ptr2 = p2;\n+  const struct ls_expr *const ptr1 = (const struct ls_expr *) p1,\n+    *const ptr2 = (const struct ls_expr *) p2;\n   return expr_equiv_p (ptr1->pattern, ptr2->pattern);\n }\n \n@@ -5117,7 +5131,7 @@ find_rtx_in_ldst (rtx x)\n   slot = htab_find_slot (pre_ldst_table, &e, NO_INSERT);\n   if (!slot || ((struct ls_expr *)*slot)->invalid)\n     return NULL;\n-  return *slot;\n+  return (struct ls_expr *) *slot;\n }\n \n /* Assign each element of the list of mems a monotonically increasing value.  */\n@@ -5425,7 +5439,7 @@ static void\n reg_set_info (rtx dest, const_rtx setter ATTRIBUTE_UNUSED,\n \t      void *data)\n {\n-  sbitmap bb_reg = data;\n+  sbitmap bb_reg = (sbitmap) data;\n \n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n@@ -5445,7 +5459,7 @@ static void\n reg_clear_last_set (rtx dest, const_rtx setter ATTRIBUTE_UNUSED,\n \t      void *data)\n {\n-  int *dead_vec = data;\n+  int *dead_vec = (int *) data;\n \n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);"}]}