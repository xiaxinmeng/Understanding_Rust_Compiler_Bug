{"sha": "591e15a110886aa13f6b54fe4d0ab5a8a8bf8574", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkxZTE1YTExMDg4NmFhMTNmNmI1NGZlNGQwYWI1YThhOGJmODU3NA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-03-02T07:35:12Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-03-02T07:35:12Z"}, "message": "cppfiles.c (struct include_file): Update.\n\n        * cppfiles.c (struct include_file): Update.\n        (stack_include_file): Use search_from.\n        (cpp_included, find_include_file): Update.\n        (cpp_execute_include): Update.  ptr->name may not be\n        null terminated.  Use the new search_from member variable\n        of cpp_buffer.\n        (_cpp_compare_file_date): Similarly.\n        (search_from): New function, similiar to actual_directory.\n        (actual_directory): Delete.\n        (remap_filename): Update.  loc->name may not be null terminated.\n        (struct file_name_list): Rename search_path.  Update.\n        * cpphash.h (struct cpp_buffer): Delete actual_dir.  New members\n        search_from and dir.\n        (struct cpp_reader): Remove actual_dirs.\n        * cppinit.c (struct cpp_pending): Update for renamed objects.\n        (append_include_chain, remove_dup_dir, remove_dup_dirs,\n        merge_include_chains, cpp_destroy, cpp_start_read): Similarly.\n        * cpplib.h (struct cpp_options): Similarly.\n\nFrom-SVN: r40178", "tree": {"sha": "ae411edfe1a33d4c87567b4c5791c4fa1ec59310", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae411edfe1a33d4c87567b4c5791c4fa1ec59310"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574", "html_url": "https://github.com/Rust-GCC/gccrs/commit/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574/comments", "author": null, "committer": null, "parents": [{"sha": "c04278f74fd6b49f7a770ae51fd1dd0412989af7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c04278f74fd6b49f7a770ae51fd1dd0412989af7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c04278f74fd6b49f7a770ae51fd1dd0412989af7"}], "stats": {"total": 278, "additions": 141, "deletions": 137}, "files": [{"sha": "73859316b99181539999d18caabf238af5722bb8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=591e15a110886aa13f6b54fe4d0ab5a8a8bf8574", "patch": "@@ -1,3 +1,24 @@\n+2001-03-02  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+        * cppfiles.c (struct include_file): Update.\n+        (stack_include_file): Use search_from.\n+        (cpp_included, find_include_file): Update.\n+        (cpp_execute_include): Update.  ptr->name may not be\n+        null terminated.  Use the new search_from member variable\n+        of cpp_buffer.\n+        (_cpp_compare_file_date): Similarly.\n+        (search_from): New function, similiar to actual_directory.\n+        (actual_directory): Delete.\n+        (remap_filename): Update.  loc->name may not be null terminated.\n+        (struct file_name_list): Rename search_path.  Update.\n+        * cpphash.h (struct cpp_buffer): Delete actual_dir.  New members\n+        search_from and dir.\n+        (struct cpp_reader): Remove actual_dirs.\n+        * cppinit.c (struct cpp_pending): Update for renamed objects.\n+        (append_include_chain, remove_dup_dir, remove_dup_dirs,\n+        merge_include_chains, cpp_destroy, cpp_start_read): Similarly.\n+        * cpplib.h (struct cpp_options): Similarly.\n+\n 2001-03-01  Zack Weinberg  <zackw@stanford.edu>\n \n \t* config/xm-lynx.h, config/xm-std32.h, config/a29k/xm-a29k.h,"}, {"sha": "72af4333531e87b82f2e779e77797543df13563d", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 75, "deletions": 93, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=591e15a110886aa13f6b54fe4d0ab5a8a8bf8574", "patch": "@@ -68,7 +68,7 @@ struct include_file\n {\n   const char *name;\t\t/* actual path name of file */\n   const cpp_hashnode *cmacro;\t/* macro, if any, preventing reinclusion.  */\n-  const struct file_name_list *foundhere;\n+  const struct search_path *foundhere;\n \t\t\t\t/* location in search path where file was\n \t\t\t\t   found, for #include_next and sysp.  */\n   const unsigned char *buffer;\t/* pointer to cached file contents */\n@@ -94,12 +94,12 @@ static struct file_name_map *read_name_map\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n static char *read_filename_string PARAMS ((int, FILE *));\n static char *remap_filename \tPARAMS ((cpp_reader *, char *,\n-\t\t\t\t\t struct file_name_list *));\n-static struct file_name_list *actual_directory\n-\t\t\t\tPARAMS ((cpp_reader *, const char *));\n+\t\t\t\t\t struct search_path *));\n+static struct search_path *search_from PARAMS ((cpp_reader *,\n+\t\t\t\t\t\tstruct include_file *));\n static struct include_file *find_include_file\n \t\t\t\tPARAMS ((cpp_reader *, const char *,\n-\t\t\t\t\t struct file_name_list *));\n+\t\t\t\t\t struct search_path *));\n static struct include_file *open_file PARAMS ((cpp_reader *, const char *));\n static void read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static void stack_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n@@ -296,11 +296,7 @@ stack_include_file (pfile, inc)\n   fp->inc = inc;\n   fp->inc->refcnt++;\n   fp->sysp = sysp;\n-\n-  /* The ->actual_dir field is only used when ignore_srcdir is not in effect;\n-     see do_include */\n-  if (!CPP_OPTION (pfile, ignore_srcdir))\n-    fp->actual_dir = actual_directory (pfile, inc->name);\n+  fp->search_from = search_from (pfile, inc);\n \n   /* Initialise controlling macro state.  */\n   pfile->mi_state = MI_OUTSIDE;\n@@ -461,7 +457,7 @@ cpp_included (pfile, fname)\n      cpp_reader *pfile;\n      const char *fname;\n {\n-  struct file_name_list *path;\n+  struct search_path *path;\n   char *name;\n   splay_tree_node nd;\n \n@@ -477,9 +473,9 @@ cpp_included (pfile, fname)\n \t\t\t  + 2 + INCLUDE_LEN_FUDGE);\n   for (path = CPP_OPTION (pfile, quote_include); path; path = path->next)\n     {\n-      memcpy (name, path->name, path->nlen);\n-      name[path->nlen] = '/';\n-      strcpy (&name[path->nlen+1], fname);\n+      memcpy (name, path->name, path->len);\n+      name[path->len] = '/';\n+      strcpy (&name[path->len + 1], fname);\n       _cpp_simplify_pathname (name);\n       if (CPP_OPTION (pfile, remap))\n \tname = remap_filename (pfile, name, path);\n@@ -499,9 +495,9 @@ static struct include_file *\n find_include_file (pfile, fname, search_start)\n      cpp_reader *pfile;\n      const char *fname;\n-     struct file_name_list *search_start;\n+     struct search_path *search_start;\n {\n-  struct file_name_list *path;\n+  struct search_path *path;\n   char *name;\n   struct include_file *file;\n \n@@ -513,9 +509,9 @@ find_include_file (pfile, fname, search_start)\n \t\t\t  + 2 + INCLUDE_LEN_FUDGE);\n   for (path = search_start; path; path = path->next)\n     {\n-      memcpy (name, path->name, path->nlen);\n-      name[path->nlen] = '/';\n-      strcpy (&name[path->nlen+1], fname);\n+      memcpy (name, path->name, path->len);\n+      name[path->len] = '/';\n+      strcpy (&name[path->len + 1], fname);\n       _cpp_simplify_pathname (name);\n       if (CPP_OPTION (pfile, remap))\n \tname = remap_filename (pfile, name, path);\n@@ -527,6 +523,7 @@ find_include_file (pfile, fname, search_start)\n \t  return file;\n \t}\n     }\n+\n   return 0;\n }\n \n@@ -587,7 +584,7 @@ _cpp_execute_include (pfile, header, no_reinclude, include_next)\n      int no_reinclude;\n      int include_next;\n {\n-  struct file_name_list *search_start = 0;\n+  struct search_path *search_start = 0;\n   unsigned int len = header->val.str.len;\n   unsigned int angle_brackets = header->type == CPP_HEADER_NAME;\n   struct include_file *inc;\n@@ -637,10 +634,8 @@ _cpp_execute_include (pfile, header, no_reinclude, include_next)\n     {\n       if (angle_brackets)\n \tsearch_start = CPP_OPTION (pfile, bracket_include);\n-      else if (CPP_OPTION (pfile, ignore_srcdir))\n-\tsearch_start = CPP_OPTION (pfile, quote_include);\n       else\n-\tsearch_start = CPP_BUFFER (pfile)->actual_dir;\n+\tsearch_start = pfile->buffer->search_from;\n \n       if (!search_start)\n \t{\n@@ -685,17 +680,18 @@ _cpp_execute_include (pfile, header, no_reinclude, include_next)\n       else\n \t{\n \t  char *p;\n-\t  struct file_name_list *ptr;\n+\t  struct search_path *ptr;\n \t  int len;\n \n \t  /* If requested as a system header, assume it belongs in\n-\t     the first system header directory. */\n+\t     the first system header directory.  */\n \t  if (CPP_OPTION (pfile, bracket_include))\n \t    ptr = CPP_OPTION (pfile, bracket_include);\n \t  else\n \t    ptr = CPP_OPTION (pfile, quote_include);\n \n-\t  len = strlen (ptr->name);\n+\t  /* FIXME: ptr can be null, no?  */\n+\t  len = ptr->len;\n \t  p = (char *) alloca (len + strlen (fname) + 2);\n \t  if (len)\n \t    {\n@@ -728,15 +724,13 @@ _cpp_compare_file_date (pfile, f)\n {\n   unsigned int len = f->val.str.len;\n   char *fname;\n-  struct file_name_list *search_start;\n+  struct search_path *search_start;\n   struct include_file *inc;\n \n   if (f->type == CPP_HEADER_NAME)\n     search_start = CPP_OPTION (pfile, bracket_include);\n   else if (CPP_OPTION (pfile, ignore_srcdir))\n-    search_start = CPP_OPTION (pfile, quote_include);\n-  else\n-    search_start = CPP_BUFFER (pfile)->actual_dir;\n+    search_start = pfile->buffer->search_from;\n \n   fname = alloca (len + 1);\n   memcpy (fname, f->val.str.text, len);\n@@ -804,6 +798,47 @@ _cpp_pop_file_buffer (pfile, buf)\n     purge_cache (inc);\n }\n \n+/* Returns the first place in the include chain to start searching for\n+   \"\" includes.  This involves stripping away the basename of the\n+   current file, unless -I- was specified.  */\n+static struct search_path *\n+search_from (pfile, inc)\n+     cpp_reader *pfile;\n+     struct include_file *inc;\n+{\n+  cpp_buffer *buffer = pfile->buffer;\n+  unsigned int dlen;\n+\n+  /* Ignore the current file's directory if -I- was given.  */\n+  if (CPP_OPTION (pfile, ignore_srcdir))\n+    return CPP_OPTION (pfile, quote_include);\n+\n+  dlen = basename (inc->name) - inc->name;\n+  if (dlen)\n+    {\n+      /* We don't guarantee NAME is null-terminated.  This saves\n+\t allocating and freeing memory, and duplicating it when faking\n+\t buffers in cpp_push_buffer.  Drop a trailing '/'.  */\n+      buffer->dir.name = inc->name;\n+      if (dlen > 1)\n+\tdlen--;\n+    }\n+  else\n+    {\n+      buffer->dir.name = \".\";\n+      dlen = 1;\n+    }\n+\n+  if (dlen > pfile->max_include_len)\n+    pfile->max_include_len = dlen;\n+\n+  buffer->dir.len = dlen;\n+  buffer->dir.next = CPP_OPTION (pfile, quote_include);\n+  buffer->dir.sysp = buffer->sysp;\n+\n+  return &buffer->dir;\n+}\n+\n /* The file_name_map structure holds a mapping of file names for a\n    particular directory.  This mapping is read from the file named\n    FILE_NAME_MAP_FILE in that directory.  Such a file can be used to\n@@ -950,20 +985,26 @@ static char *\n remap_filename (pfile, name, loc)\n      cpp_reader *pfile;\n      char *name;\n-     struct file_name_list *loc;\n+     struct search_path *loc;\n {\n   struct file_name_map *map;\n   const char *from, *p;\n-  char *dir;\n+  char *dir, *dname;\n+\n+  /* Get a null-terminated path.  */\n+  dname = alloca (loc->len + 1);\n+  memcpy (dname, loc->name, loc->len);\n+  dname[loc->len] = '\\0';\n \n   if (! loc->name_map)\n     {\n-      loc->name_map = read_name_map (pfile, loc->name ? loc->name : \".\");\n+      loc->name_map = read_name_map (pfile, dname);\n       if (! loc->name_map)\n \treturn name;\n     }\n   \n-  from = name + strlen (loc->name) + 1;\n+  /* FIXME: this doesn't look right - NAME has been simplified.  */\n+  from = name + loc->len + 1;\n   \n   for (map = loc->name_map; map; map = map->map_next)\n     if (!strcmp (map->map_from, from))\n@@ -993,65 +1034,6 @@ remap_filename (pfile, name, loc)\n   return name;\n }\n \n-/* Given a path FNAME, extract the directory component and place it\n-   onto the actual_dirs list.  Return a pointer to the allocated\n-   file_name_list structure.  These structures are used to implement\n-   current-directory \"\" include searching. */\n-\n-static struct file_name_list *\n-actual_directory (pfile, fname)\n-     cpp_reader *pfile;\n-     const char *fname;\n-{\n-  char *last_slash, *dir;\n-  size_t dlen;\n-  struct file_name_list *x;\n-  \n-  dir = xstrdup (fname);\n-  last_slash = strrchr (dir, '/');\n-  if (last_slash)\n-    {\n-      if (last_slash == dir)\n-        {\n-\t  dlen = 1;\n-\t  last_slash[1] = '\\0';\n-\t}\n-      else\n-\t{\n-\t  dlen = last_slash - dir;\n-\t  *last_slash = '\\0';\n-\t}\n-    }\n-  else\n-    {\n-      free (dir);\n-      dir = xstrdup (\".\");\n-      dlen = 1;\n-    }\n-\n-  if (dlen > pfile->max_include_len)\n-    pfile->max_include_len = dlen;\n-\n-  for (x = pfile->actual_dirs; x; x = x->alloc)\n-    if (!strcmp (x->name, dir))\n-      {\n-\tfree (dir);\n-\treturn x;\n-      }\n-\n-  /* Not found, make a new one. */\n-  x = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n-  x->name = dir;\n-  x->nlen = dlen;\n-  x->next = CPP_OPTION (pfile, quote_include);\n-  x->alloc = pfile->actual_dirs;\n-  x->sysp = pfile->buffer->sysp;\n-  x->name_map = NULL;\n-\n-  pfile->actual_dirs = x;\n-  return x;\n-}\n-\n /* Simplify a path name in place, deleting redundant components.  This\n    reduces OS overhead and guarantees that equivalent paths compare\n    the same (modulo symlinks)."}, {"sha": "5b2c24bd0ae3be58747a7f916fe45e6a94cf4ccb", "filename": "gcc/cpphash.h", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=591e15a110886aa13f6b54fe4d0ab5a8a8bf8574", "patch": "@@ -72,23 +72,23 @@ struct cpp_pool\n   unsigned int locks;\n };\n \n-/* List of directories to look for include files in. */\n-struct file_name_list\n+/* List of directories to look for include files in.  */\n+struct search_path\n {\n-  struct file_name_list *next;\n-  struct file_name_list *alloc; /* for the cache of\n-\t\t\t\t   current directory entries */\n-  char *name;\n-  unsigned int nlen;\n+  struct search_path *next;\n+\n+  /* NOTE: NAME may not be null terminated for the case of the current\n+     file's directory!  */\n+  const char *name;\n+  unsigned int len;\n   /* We use these to tell if the directory mentioned here is a duplicate\n-     of an earlier directory on the search path. */\n+     of an earlier directory on the search path.  */\n   ino_t ino;\n   dev_t dev;\n-  /* If the following is nonzero, it is a C-language system include\n-     directory.  */\n+  /* Non-zero if it is a system include directory.  */\n   int sysp;\n-  /* Mapping of file names for this directory.\n-     Only used on MS-DOS and related platforms. */\n+  /* Mapping of file names for this directory.  Only used on MS-DOS\n+     and related platforms.  */\n   struct file_name_map *name_map;\n };\n \n@@ -180,9 +180,6 @@ struct cpp_buffer\n   /* Filename specified with #line command.  */\n   const char *nominal_fname;\n \n-  /* Actual directory of this file, used only for \"\" includes */\n-  struct file_name_list *actual_dir;\n-\n   /* Pointer into the include table.  Used for include_next and\n      to record control macros. */\n   struct include_file *inc;\n@@ -227,6 +224,15 @@ struct cpp_buffer\n \n   /* Buffer type.  */\n   ENUM_BITFIELD (cpp_buffer_type) type : 8;\n+\n+  /* The directory of the this buffer's file.  Its NAME member is not\n+     allocated, so we don't need to worry about freeing it.  */\n+  struct search_path dir;\n+\n+  /* The directory to start searching for \"\" include files.  Is either\n+     \"dir\" above, or options.quote_include, depending upon whether -I-\n+     was on the command line.  */\n+  struct search_path *search_from;\n };\n \n /* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n@@ -297,10 +303,6 @@ struct cpp_reader\n   /* Tree of other included files.  See cppfiles.c.  */\n   struct splay_tree_s *all_include_files;\n \n-  /* Chain of `actual directory' file_name_list entries, for \"\"\n-     inclusion.  */\n-  struct file_name_list *actual_dirs;\n-\n   /* Current maximum length of directory names in the search path\n      for include files.  (Altered as we get more of them.)  */\n   unsigned int max_include_len;"}, {"sha": "0406e629040fa2b7bfd78c2c55678acbba06abfc", "filename": "gcc/cppinit.c", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=591e15a110886aa13f6b54fe4d0ab5a8a8bf8574", "patch": "@@ -70,10 +70,10 @@ struct cpp_pending\n {\n   struct pending_option *directive_head, *directive_tail;\n \n-  struct file_name_list *quote_head, *quote_tail;\n-  struct file_name_list *brack_head, *brack_tail;\n-  struct file_name_list *systm_head, *systm_tail;\n-  struct file_name_list *after_head, *after_tail;\n+  struct search_path *quote_head, *quote_tail;\n+  struct search_path *brack_head, *brack_tail;\n+  struct search_path *systm_head, *systm_tail;\n+  struct search_path *after_head, *after_tail;\n \n   struct pending_option *imacros_head, *imacros_tail;\n   struct pending_option *include_head, *include_tail;\n@@ -100,10 +100,10 @@ static void init_library\t\tPARAMS ((void));\n static void init_builtins\t\tPARAMS ((cpp_reader *));\n static void append_include_chain\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t char *, int, int));\n-struct file_name_list * remove_dup_dir\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t struct file_name_list *));\n-struct file_name_list * remove_dup_dirs PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t struct file_name_list *));\n+struct search_path * remove_dup_dir\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t struct search_path *));\n+struct search_path * remove_dup_dirs PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t struct search_path *));\n static void merge_include_chains\tPARAMS ((cpp_reader *));\n static void do_includes\t\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t struct pending_option *,\n@@ -207,7 +207,7 @@ append_include_chain (pfile, dir, path, cxx_aware)\n      int cxx_aware ATTRIBUTE_UNUSED;\n {\n   struct cpp_pending *pend = CPP_OPTION (pfile, pending);\n-  struct file_name_list *new;\n+  struct search_path *new;\n   struct stat st;\n   unsigned int len;\n \n@@ -232,9 +232,9 @@ append_include_chain (pfile, dir, path, cxx_aware)\n   if (len > pfile->max_include_len)\n     pfile->max_include_len = len;\n \n-  new = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n+  new = (struct search_path *) xmalloc (sizeof (struct search_path));\n   new->name = dir;\n-  new->nlen = len;\n+  new->len = len;\n   new->ino  = st.st_ino;\n   new->dev  = st.st_dev;\n   if (path == SYSTEM)\n@@ -247,7 +247,6 @@ append_include_chain (pfile, dir, path, cxx_aware)\n     new->sysp = 0;\n   new->name_map = NULL;\n   new->next = NULL;\n-  new->alloc = NULL;\n \n   switch (path)\n     {\n@@ -260,18 +259,18 @@ append_include_chain (pfile, dir, path, cxx_aware)\n /* Handle a duplicated include path.  PREV is the link in the chain\n    before the duplicate.  The duplicate is removed from the chain and\n    freed.  Returns PREV.  */\n-struct file_name_list *\n+struct search_path *\n remove_dup_dir (pfile, prev)\n      cpp_reader *pfile;\n-     struct file_name_list *prev;\n+     struct search_path *prev;\n {\n-  struct file_name_list *cur = prev->next;\n+  struct search_path *cur = prev->next;\n \n   if (CPP_OPTION (pfile, verbose))\n     fprintf (stderr, _(\"ignoring duplicate directory \\\"%s\\\"\\n\"), cur->name);\n \n   prev->next = cur->next;\n-  free (cur->name);\n+  free ((PTR) cur->name);\n   free (cur);\n \n   return prev;\n@@ -281,12 +280,12 @@ remove_dup_dir (pfile, prev)\n    chain, or NULL if the chain is empty.  This algorithm is quadratic\n    in the number of -I switches, which is acceptable since there\n    aren't usually that many of them.  */\n-struct file_name_list *\n+struct search_path *\n remove_dup_dirs (pfile, head)\n      cpp_reader *pfile;\n-     struct file_name_list *head;\n+     struct search_path *head;\n {\n-  struct file_name_list *prev = NULL, *cur, *other;\n+  struct search_path *prev = NULL, *cur, *other;\n \n   for (cur = head; cur; cur = cur->next)\n     {\n@@ -315,7 +314,7 @@ static void\n merge_include_chains (pfile)\n      cpp_reader *pfile;\n {\n-  struct file_name_list *quote, *brack, *systm, *qtail;\n+  struct search_path *quote, *brack, *systm, *qtail;\n \n   struct cpp_pending *pend = CPP_OPTION (pfile, pending);\n \n@@ -559,7 +558,7 @@ cpp_destroy (pfile)\n      cpp_reader *pfile;\n {\n   int result;\n-  struct file_name_list *dir, *dirn;\n+  struct search_path *dir, *dirn;\n   cpp_context *context, *contextn;\n \n   while (CPP_BUFFER (pfile) != NULL)\n@@ -587,7 +586,7 @@ cpp_destroy (pfile)\n   for (dir = CPP_OPTION (pfile, quote_include); dir; dir = dirn)\n     {\n       dirn = dir->next;\n-      free (dir->name);\n+      free ((PTR) dir->name);\n       free (dir);\n     }\n \n@@ -910,7 +909,7 @@ cpp_start_read (pfile, fname)\n   /* With -v, print the list of dirs to search.  */\n   if (CPP_OPTION (pfile, verbose))\n     {\n-      struct file_name_list *l;\n+      struct search_path *l;\n       fprintf (stderr, _(\"#include \\\"...\\\" search starts here:\\n\"));\n       for (l = CPP_OPTION (pfile, quote_include); l; l = l->next)\n \t{"}, {"sha": "50d3bfe5de81a5ec092e64f366c08a1f3c4ef49e", "filename": "gcc/cpplib.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/591e15a110886aa13f6b54fe4d0ab5a8a8bf8574/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=591e15a110886aa13f6b54fe4d0ab5a8a8bf8574", "patch": "@@ -240,8 +240,8 @@ struct cpp_options\n   const char *deps_file;\n \n   /* Search paths for include files.  */\n-  struct file_name_list *quote_include;\t /* First dir to search for \"file\" */\n-  struct file_name_list *bracket_include;/* First dir to search for <file> */\n+  struct search_path *quote_include;\t/* \"\" */\n+  struct search_path *bracket_include;  /* <> */\n \n   /* Map between header names and file names, used only on DOS where\n      file names are limited in length.  */"}]}