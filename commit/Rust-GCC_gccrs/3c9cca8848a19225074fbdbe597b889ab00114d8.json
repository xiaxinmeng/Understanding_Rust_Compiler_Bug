{"sha": "3c9cca8848a19225074fbdbe597b889ab00114d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M5Y2NhODg0OGExOTIyNTA3NGZiZGJlNTk3Yjg4OWFiMDAxMTRkOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-29T15:01:20Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-29T15:01:20Z"}, "message": "Stat hack representation\n\n\tStat hack representation\n\t* name-lookup.c (STAT_HACK_P, STAT_TYPE, STAT_DECL)\n\tMAYBE_STAT_DECL, MAYBE_STAT_TYPE): New.\n\t(stat_hack): New.\n\t(find_namespace_binding): Replace with ...\n\t(find_namespace_slot): ... this.\n\t(find_namespace_value): New.\n\t(name_lookup::search_namespace_only,\n\tname_lookup::adl_namespace_only): Adjust.\n\t(update_binding): Add SLOT parameter, adjust.\n\t(check_local_shadow): Use find_namespace_value.\n\t(set_local_extern_decl_linkage): Likewise.\n\t(do_pushdecl): Adjust for namespace slot.\n\t(push_local_binding): Assert not a namespace binding.\n\t(check_for_out_of_scope_variable): Use find_namespace_value.\n\t(set_identifier_type_value_with_scope): Likewise.\n\t(get_namespace_binding): Likewise.\n\t(set_namespace_binding): Delete.\n\t(set_global_binding): Directly update the binding.\n\t(finish_namespace_using_decl): Likewise.\n\t(lookup_type_scope_1): Use find_namespace_slot and update.\n\t(do_push_nested_namespace): Use find_namespace_value.\n\nFrom-SVN: r248574", "tree": {"sha": "f4f41ec1b0bf661f5747be5d0c071ff2a4e77f68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4f41ec1b0bf661f5747be5d0c071ff2a4e77f68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c9cca8848a19225074fbdbe597b889ab00114d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9cca8848a19225074fbdbe597b889ab00114d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9cca8848a19225074fbdbe597b889ab00114d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9cca8848a19225074fbdbe597b889ab00114d8/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e514ab0c32480f03cbba49160caa822e7e5b3c94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e514ab0c32480f03cbba49160caa822e7e5b3c94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e514ab0c32480f03cbba49160caa822e7e5b3c94"}], "stats": {"total": 272, "additions": 175, "deletions": 97}, "files": [{"sha": "4a9ba45212dfe5aaba438f5edb81c793191e3198", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9cca8848a19225074fbdbe597b889ab00114d8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9cca8848a19225074fbdbe597b889ab00114d8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3c9cca8848a19225074fbdbe597b889ab00114d8", "patch": "@@ -1,5 +1,28 @@\n 2017-05-29  Nathan Sidwell  <nathan@acm.org>\n \n+\tStat hack representation\n+\t* name-lookup.c (STAT_HACK_P, STAT_TYPE, STAT_DECL,\n+\tMAYBE_STAT_DECL, MAYBE_STAT_TYPE): New.\n+\t(stat_hack): New.\n+\t(find_namespace_binding): Replace with ...\n+\t(find_namespace_slot): ... this.\n+\t(find_namespace_value): New.\n+\t(name_lookup::search_namespace_only,\n+\tname_lookup::adl_namespace_only): Adjust.\n+\t(update_binding): Add SLOT parameter, adjust.\n+\t(check_local_shadow): Use find_namespace_value.\n+\t(set_local_extern_decl_linkage): Likewise.\n+\t(do_pushdecl): Adjust for namespace slot.\n+\t(push_local_binding): Assert not a namespace binding.\n+\t(check_for_out_of_scope_variable): Use find_namespace_value.\n+\t(set_identifier_type_value_with_scope): Likewise.\n+\t(get_namespace_binding): Likewise.\n+\t(set_namespace_binding): Delete.\n+\t(set_global_binding): Directly update the binding.\n+\t(finish_namespace_using_decl): Likewise.\n+\t(lookup_type_scope_1): Use find_namespace_slot and update.\n+\t(do_push_nested_namespace): Use find_namespace_value.\n+\n \tPR c++/80891 (#1)\n \t* pt.c (most_specialized_instantiation): Cope with duplicate\n \tinstantiations."}, {"sha": "f0dc10f6eac0c98966ff221056ff1aa6f094d6be", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 152, "deletions": 97, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9cca8848a19225074fbdbe597b889ab00114d8/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9cca8848a19225074fbdbe597b889ab00114d8/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=3c9cca8848a19225074fbdbe597b889ab00114d8", "patch": "@@ -38,6 +38,27 @@ static cp_binding_level *innermost_nonclass_level (void);\n static void set_identifier_type_value_with_scope (tree id, tree decl,\n \t\t\t\t\t\t  cp_binding_level *b);\n \n+/* Create an overload suitable for recording an artificial TYPE_DECL\n+   and another decl.  We use this machanism to implement the struct\n+   stat hack within a namespace.  It'd be nice to use it everywhere.  */\n+\n+#define STAT_HACK_P(N) ((N) && TREE_CODE (N) == OVERLOAD && OVL_LOOKUP_P (N))\n+#define STAT_TYPE(N) TREE_TYPE (N)\n+#define STAT_DECL(N) OVL_FUNCTION (N)\n+#define MAYBE_STAT_DECL(N) (STAT_HACK_P (N) ? STAT_DECL (N) : N)\n+#define MAYBE_STAT_TYPE(N) (STAT_HACK_P (N) ? STAT_TYPE (N) : NULL_TREE)\n+\n+static tree stat_hack (tree decl = NULL_TREE, tree type = NULL_TREE)\n+{\n+  tree result = make_node (OVERLOAD);\n+\n+  /* Mark this as a lookup, so we can tell this is a stat hack.  */\n+  OVL_LOOKUP_P (result) = true;\n+  STAT_DECL (result) = decl;\n+  STAT_TYPE (result) = type;\n+  return result;\n+}\n+\n /* Create a local binding level for NAME.  */\n \n static cxx_binding *\n@@ -58,15 +79,15 @@ create_local_binding (cp_binding_level *level, tree name)\n /* Find the binding for NAME in namespace NS.  If CREATE_P is true,\n    make an empty binding if there wasn't one.  */\n \n-static cxx_binding *\n-find_namespace_binding (tree ns, tree name, bool create_p = false)\n+static tree *\n+find_namespace_slot (tree ns, tree name, bool create_p = false)\n {\n   cp_binding_level *level = NAMESPACE_LEVEL (ns);\n   cxx_binding *binding = IDENTIFIER_NAMESPACE_BINDINGS (name);\n \n   for (;binding; binding = binding->previous)\n     if (binding->scope == level)\n-      return binding;\n+      return &binding->value;\n \n   if (create_p)\n     {\n@@ -76,9 +97,18 @@ find_namespace_binding (tree ns, tree name, bool create_p = false)\n       binding->is_local = false;\n       binding->value_is_inherited = false;\n       IDENTIFIER_NAMESPACE_BINDINGS (name) = binding;\n+      return &binding->value;\n     }\n \n-  return binding;\n+  return NULL;\n+}\n+\n+static tree\n+find_namespace_value (tree ns, tree name)\n+{\n+  tree *b = find_namespace_slot (ns, name);\n+\n+  return b ? MAYBE_STAT_DECL (*b) : NULL_TREE;\n }\n \n /* Add DECL to the list of things declared in B.  */\n@@ -480,8 +510,9 @@ name_lookup::search_namespace_only (tree scope)\n {\n   bool found = false;\n \n-  if (cxx_binding *binding = find_namespace_binding (scope, name))\n-    found |= process_binding (binding->value, binding->type);\n+  if (tree *binding = find_namespace_slot (scope, name))\n+    found |= process_binding (MAYBE_STAT_DECL (*binding),\n+\t\t\t      MAYBE_STAT_TYPE (*binding));\n \n   return found;\n }\n@@ -688,8 +719,8 @@ name_lookup::adl_namespace_only (tree scope)\n     for (unsigned ix = inlinees->length (); ix--;)\n       adl_namespace_only ((*inlinees)[ix]);\n \n-  if (cxx_binding *binding = find_namespace_binding (scope, name))\n-    add_fns (ovl_skip_hidden (binding->value));\n+  if (tree fns = find_namespace_value (scope, name))\n+    add_fns (ovl_skip_hidden (fns));\n }\n \n /* Find the containing non-inlined namespace, add it and all its\n@@ -1636,18 +1667,19 @@ matching_fn_p (tree one, tree two)\n   return true;\n }\n \n-/* Push DECL into nonclass LEVEL BINDING.  OLD is the current\n+/* Push DECL into nonclass LEVEL BINDING or SLOT.  OLD is the current\n    binding value (possibly with anticipated builtins stripped).\n    Diagnose conflicts and return updated decl.  */\n \n static tree\n-update_binding (cp_binding_level *level, cxx_binding *binding,\n+update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t\ttree old, tree decl, bool is_friend)\n {\n   tree to_val = decl;\n   tree to_type = NULL_TREE;\n \n-  gcc_assert (level->kind != sk_class);\n+  gcc_assert (level->kind == sk_namespace ? !binding\n+\t      : level->kind != sk_class && !slot);\n   if (old == error_mark_node)\n     old = NULL_TREE;\n \n@@ -1778,7 +1810,7 @@ update_binding (cp_binding_level *level, cxx_binding *binding,\n \t  add_decl_to_level (level, to_add);\n \t}\n \n-      if (to_type == binding->type)\n+      if (to_type == (slot ? MAYBE_STAT_TYPE (*slot) : binding->type))\n \tto_type = NULL_TREE;\n \n       if (to_type)\n@@ -1795,9 +1827,25 @@ update_binding (cp_binding_level *level, cxx_binding *binding,\n \t\t     decl, type);\n \t}\n \n-      if (to_type)\n-\tbinding->type = to_type;\n-      binding->value = to_val;\n+      if (slot)\n+\t{\n+\t  if (STAT_HACK_P (*slot))\n+\t    {\n+\t      if (to_type)\n+\t\tSTAT_TYPE (*slot) = to_type;\n+\t      STAT_DECL (*slot) = to_val;\n+\t    }\n+\t  else if (to_type)\n+\t    *slot = stat_hack (to_val, to_type);\n+\t  else\n+\t    *slot = to_val;\n+\t}\n+      else\n+\t{\n+\t  if (to_type)\n+\t    binding->type = to_type;\n+\t  binding->value = to_val;\n+\t}\n     }\n \n   return decl;\n@@ -2056,7 +2104,7 @@ check_local_shadow (tree decl)\n       }\n \n   /* Now look for a namespace shadow.  */\n-  old = get_namespace_binding (current_namespace, DECL_NAME (decl));\n+  old = find_namespace_value (current_namespace, DECL_NAME (decl));\n   if (old\n       && (VAR_P (old)\n \t  || (TREE_CODE (old) == TYPE_DECL\n@@ -2134,7 +2182,7 @@ set_local_extern_decl_linkage (tree decl, bool shadowed)\n       if (!loc_value)\n \t{\n \t  ns_value\n-\t    = get_namespace_binding (current_namespace, DECL_NAME (decl));\n+\t    = find_namespace_value (current_namespace, DECL_NAME (decl));\n \t  loc_value = ns_value;\n \t}\n       if (loc_value == error_mark_node)\n@@ -2173,7 +2221,7 @@ set_local_extern_decl_linkage (tree decl, bool shadowed)\n   if (TREE_PUBLIC (decl))\n     {\n       /* DECL is externally visible.  Make sure it matches a matching\n-\t decl in the namespace scpe.  We only really need to check\n+\t decl in the namespace scope.  We only really need to check\n \t this when inserting the decl, not when we find an existing\n \t match in the current scope.  However, in practice we're\n \t going to be inserting a new decl in the majority of cases --\n@@ -2183,7 +2231,7 @@ set_local_extern_decl_linkage (tree decl, bool shadowed)\n \n       /* Avoid repeating a lookup.  */\n       if (ns_value == decl)\n-\tns_value = get_namespace_binding (current_namespace, DECL_NAME (decl));\n+\tns_value = find_namespace_value (current_namespace, DECL_NAME (decl));\n \n       if (ns_value == error_mark_node)\n \tns_value = NULL_TREE;\n@@ -2237,8 +2285,9 @@ do_pushdecl (tree decl, bool is_friend)\n \n   if (tree name = DECL_NAME (decl))\n     {\n-      cxx_binding *binding = NULL;\n+      cxx_binding *binding = NULL; /* Local scope binding.  */\n       tree ns = NULL_TREE; /* Searched namespace.  */\n+      tree *slot = NULL; /* Binding slot in namespace.  */\n       tree old = NULL_TREE;\n \n       if (level->kind == sk_namespace)\n@@ -2250,13 +2299,16 @@ do_pushdecl (tree decl, bool is_friend)\n \t\t? CP_DECL_CONTEXT (decl) : current_namespace);\n \t  /* Create the binding, if this is current namespace, because\n \t     that's where we'll be pushing anyway.  */\n-\t  binding = find_namespace_binding (ns, name, ns == current_namespace);\n+\t  slot = find_namespace_slot (ns, name, ns == current_namespace);\n+\t  if (slot)\n+\t    old = MAYBE_STAT_DECL (*slot);\n \t}\n       else\n-\tbinding = find_local_binding (level, name);\n-\n-      if (binding)\n-\told = binding->value;\n+\t{\n+\t  binding = find_local_binding (level, name);\n+\t  if (binding)\n+\t    old = binding->value;\n+\t}\n \n       if (current_function_decl && VAR_OR_FUNCTION_DECL_P (decl)\n \t  && DECL_EXTERNAL (decl))\n@@ -2279,10 +2331,15 @@ do_pushdecl (tree decl, bool is_friend)\n \t\tif (head != old)\n \t\t  {\n \t\t    if (!ns)\n-\t\t      update_local_overload (binding, head);\n-\t\t    binding->value = head;\n+\t\t      {\n+\t\t\tupdate_local_overload (binding, head);\n+\t\t\tbinding->value = head;\n+\t\t      }\n+\t\t    else if (STAT_HACK_P (*slot))\n+\t\t      STAT_DECL (*slot) = head;\n+\t\t    else\n+\t\t      *slot = head;\n \t\t  }\n-\n \t\tif (TREE_CODE (match) == FUNCTION_DECL\n \t\t    && DECL_EXTERN_C_P (match))\n \t\t  /* We need to check and register the fn now.  */\n@@ -2329,13 +2386,13 @@ do_pushdecl (tree decl, bool is_friend)\n \t  if (!binding)\n \t    binding = create_local_binding (level, name);\n \t}\n-      else if (!binding)\n+      else if (!slot)\n \t{\n \t  ns = current_namespace;\n-\t  binding = find_namespace_binding (ns, name, true);\n+\t  slot = find_namespace_slot (ns, name, true);\n \t}\n \n-      old = update_binding (level, binding, old, decl, is_friend);\n+      old = update_binding (level, binding, slot, old, decl, is_friend);\n \n       if (old != decl)\n \t/* An existing decl matched, use it.  */\n@@ -2421,19 +2478,12 @@ maybe_push_decl (tree decl)\n static void\n push_local_binding (tree id, tree decl, bool is_using)\n {\n-  cp_binding_level *b;\n-\n   /* Skip over any local classes.  This makes sense if we call\n      push_local_binding with a friend decl of a local class.  */\n-  b = innermost_nonclass_level ();\n-\n-  cxx_binding *binding = NULL;\n-  if (b->kind == sk_namespace)\n-    binding = find_namespace_binding (current_namespace, id);\n-  else\n-    binding = find_local_binding (b, id);\n+  cp_binding_level *b = innermost_nonclass_level ();\n \n-  if (binding)\n+  gcc_assert (b->kind != sk_namespace);\n+  if (find_local_binding (b, id))\n     {\n       /* Supplement the existing binding.  */\n       if (!supplement_binding (IDENTIFIER_BINDING (id), decl))\n@@ -2479,7 +2529,7 @@ check_for_out_of_scope_variable (tree decl)\n     shadowed = DECL_HAS_SHADOWED_FOR_VAR_P (shadowed)\n       ? DECL_SHADOWED_FOR_VAR (shadowed) : NULL_TREE;\n   if (!shadowed)\n-    shadowed = get_namespace_binding (current_namespace, DECL_NAME (decl));\n+    shadowed = find_namespace_value (current_namespace, DECL_NAME (decl));\n   if (shadowed)\n     {\n       if (!DECL_ERROR_REPORTED (decl))\n@@ -3081,13 +3131,9 @@ set_identifier_type_value_with_scope (tree id, tree decl, cp_binding_level *b)\n     }\n   else\n     {\n-      cxx_binding *binding\n-\t= find_namespace_binding (current_namespace, id, true);\n-\n-      if (binding->value)\n-\tsupplement_binding (binding, decl);\n-      else\n-\tbinding->value = decl;\n+      tree *slot = find_namespace_slot (current_namespace, id, true);\n+      gcc_assert (decl);\n+      update_binding (b, NULL, slot, MAYBE_STAT_DECL (*slot), decl, false);\n \n       /* Store marker instead of real type.  */\n       type = global_type_node;\n@@ -4156,26 +4202,10 @@ get_namespace_binding (tree ns, tree name)\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   if (!ns)\n     ns = global_namespace;\n-  cxx_binding *binding = find_namespace_binding (ns, name);\n+  gcc_checking_assert (!DECL_NAMESPACE_ALIAS (ns));\n+  tree ret = find_namespace_value (ns, name);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return binding ? binding->value : NULL_TREE;\n-}\n-\n-static void\n-set_namespace_binding (tree scope, tree name, tree val)\n-{\n-  if (scope == NULL_TREE)\n-    scope = global_namespace;\n-  cxx_binding *binding = find_namespace_binding (scope, name, true);\n-  if (!binding->value\n-      /* For templates and using we create a single element OVERLOAD.\n-\t Look for the chain to know whether this is really augmenting\n-\t an existing overload.  */\n-      || (TREE_CODE (val) == OVERLOAD && OVL_CHAIN (val))\n-      || val == error_mark_node)\n-    binding->value = val;\n-  else\n-    supplement_binding (binding, val);\n+  return ret;\n }\n \n /* Set value binding of NAME in the global namespace to VAL.  Does not\n@@ -4186,7 +4216,23 @@ set_global_binding (tree name, tree val)\n {\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n \n-  set_namespace_binding (global_namespace, name, val);\n+  tree *slot = find_namespace_slot (global_namespace, name, true);\n+  tree old = MAYBE_STAT_DECL (*slot);\n+\n+  if (!old)\n+    *slot = val;\n+  else if (old == val)\n+    ;\n+  else if (!STAT_HACK_P (*slot)\n+\t   && TREE_CODE (val) == TYPE_DECL && DECL_ARTIFICIAL (val))\n+    *slot = stat_hack (old, val);\n+  else if (!STAT_HACK_P (*slot)\n+\t   && TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n+    *slot = stat_hack (val, old);\n+  else\n+    /* The user's placed something in the implementor's\n+       namespace.  */\n+    diagnose_name_conflict (val, old);\n \n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n@@ -4496,30 +4542,31 @@ finish_namespace_using_decl (tree decl, tree scope, tree name)\n {\n   tree orig_decl = decl;\n \n-  gcc_checking_assert (current_binding_level->kind == sk_namespace);\n+  gcc_checking_assert (current_binding_level->kind == sk_namespace\n+\t\t       && !processing_template_decl);\n   decl = validate_nonmember_using_decl (decl, scope, name);\n   if (decl == NULL_TREE)\n     return;\n \n-  cxx_binding *binding\n-    = find_namespace_binding (current_namespace, name, true);\n-\n-  tree value = binding->value;\n-  tree type = binding->type;\n-\n-  do_nonmember_using_decl (scope, name, &value, &type);\n-\n-  /* Copy declarations found.  */\n-  binding->value = value;\n-  binding->type = type;\n+  tree *slot = find_namespace_slot (current_namespace, name, true);\n+  tree val = slot ? MAYBE_STAT_DECL (*slot) : NULL_TREE;\n+  tree type = slot ? MAYBE_STAT_TYPE (*slot) : NULL_TREE;\n+  do_nonmember_using_decl (scope, name, &val, &type);\n+  if (STAT_HACK_P (*slot))\n+    {\n+      STAT_DECL (*slot) = val;\n+      STAT_TYPE (*slot) = type;\n+    }\n+  else if (type)\n+    *slot = stat_hack (val, type);\n+  else\n+    *slot = val;\n \n   /* Emit debug info.  */\n-  gcc_assert (!processing_template_decl);\n-  if (!processing_template_decl)\n-    cp_emit_debug_info_for_using (orig_decl, current_namespace);\n+  cp_emit_debug_info_for_using (orig_decl, current_namespace);\n }\n \n-/* Process a using-declaration at local scope.  */\n+/* Process a using-declaration at function scope.  */\n \n void\n finish_local_using_decl (tree decl, tree scope, tree name)\n@@ -5324,6 +5371,7 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n {\n   cxx_binding *iter = NULL;\n   tree val = NULL_TREE;\n+  cp_binding_level *level = NULL;\n \n   /* Look in non-namespace scope first.  */\n   if (current_binding_level->kind != sk_namespace)\n@@ -5355,19 +5403,26 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n     }\n \n   /* Look in namespace scope.  */\n-  if (!val)\n+  if (val)\n+    level = iter->scope;\n+  else\n     {\n-      iter = find_namespace_binding (current_decl_namespace (), name);\n+      tree ns = current_decl_namespace ();\n \n-      if (iter)\n+      if (tree *slot = find_namespace_slot (ns, name))\n \t{\n \t  /* If this is the kind of thing we're looking for, we're done.  */\n-\t  if (qualify_lookup (iter->type, LOOKUP_PREFER_TYPES))\n-\t    val = iter->type;\n-\t  else if (qualify_lookup (iter->value, LOOKUP_PREFER_TYPES))\n-\t    val = iter->value;\n+\t  if (tree type = MAYBE_STAT_TYPE (*slot))\n+\t    if (qualify_lookup (type, LOOKUP_PREFER_TYPES))\n+\t      val = type;\n+\t  if (!val)\n+\t    {\n+\t      if (tree decl = MAYBE_STAT_DECL (*slot))\n+\t\tif (qualify_lookup (decl, LOOKUP_PREFER_TYPES))\n+\t\t  val = decl;\n+\t    }\n+\t  level = NAMESPACE_LEVEL (ns);\n \t}\n-\n     }\n \n   /* Type found, check if it is in the allowed scopes, ignoring cleanup\n@@ -5377,7 +5432,7 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n       cp_binding_level *b = current_binding_level;\n       while (b)\n \t{\n-\t  if (iter->scope == b)\n+\t  if (level == b)\n \t    return val;\n \n \t  if (b->kind == sk_cleanup || b->kind == sk_template_parms\n@@ -5929,9 +5984,9 @@ do_push_nested_namespace (tree ns)\n     {\n       do_push_nested_namespace (CP_DECL_CONTEXT (ns));\n       gcc_checking_assert\n-\t(get_namespace_binding (current_namespace,\n-\t\t\t\tDECL_NAME (ns) ? DECL_NAME (ns)\n-\t\t\t\t: anon_identifier) == ns);\n+\t(find_namespace_value (current_namespace,\n+\t\t\t       DECL_NAME (ns) ? DECL_NAME (ns)\n+\t\t\t       : anon_identifier) == ns);\n       resume_scope (NAMESPACE_LEVEL (ns));\n       current_namespace = ns;\n     }"}]}