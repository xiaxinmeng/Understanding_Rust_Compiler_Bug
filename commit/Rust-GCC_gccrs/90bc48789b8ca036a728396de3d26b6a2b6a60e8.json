{"sha": "90bc48789b8ca036a728396de3d26b6a2b6a60e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBiYzQ4Nzg5YjhjYTAzNmE3MjgzOTZkZTNkMjZiNmEyYjZhNjBlOA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2015-10-06T16:26:22Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2015-10-06T16:26:22Z"}, "message": "gcc\t* config/msp430/msp430.c (ATTR_NOINIT): New constant.\n\n\t(ATTR_PERSIST): New constant.\n\t(msp430_data_attr): New function - verifies an attribute that only\n\tapplies to variables.\n\t(msp430_attributes): Add noinit and persistent attributes.\n\t(noinit_section): New variable.\n\t(presis_section): New variable.\n\t(TARGET_ASM_INIT_SECTIONS): Define.\n\t(msp430_init_sections): New function - initialises the noinit and\n\tpersist section variables.\n\t(msp430_select_section): Add support for noinit and persist\n\tattributes.\n\t(msp430_section_type_flags): Likewise.\n\t* doc/extend.texi:  Document the reent, critical, wakeup, noinit\n\tand persistent attributes.\n\ntests\t* gcc.target/msp430: New directory.\n\t* gcc.target/msp430/msp430.exp: New file.  Runs MSP430 specific\n\ttests.\n\t* gcc.target/msp430/data-attributes.c: New file.  Checks the\n\tnoinit and persistent data attributes.\n\nFrom-SVN: r228531", "tree": {"sha": "cab0ca94b0c4571ec5452234d295d64177c9f136", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cab0ca94b0c4571ec5452234d295d64177c9f136"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90bc48789b8ca036a728396de3d26b6a2b6a60e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90bc48789b8ca036a728396de3d26b6a2b6a60e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90bc48789b8ca036a728396de3d26b6a2b6a60e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90bc48789b8ca036a728396de3d26b6a2b6a60e8/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eaec70cd8bb0d06d550878428a961a41e755f213", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaec70cd8bb0d06d550878428a961a41e755f213", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaec70cd8bb0d06d550878428a961a41e755f213"}], "stats": {"total": 237, "additions": 235, "deletions": 2}, "files": [{"sha": "918ff3ebfc9849ef131c7663eecea6e4d93aa0db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90bc48789b8ca036a728396de3d26b6a2b6a60e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90bc48789b8ca036a728396de3d26b6a2b6a60e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90bc48789b8ca036a728396de3d26b6a2b6a60e8", "patch": "@@ -1,3 +1,21 @@\n+2015-10-06  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/msp430/msp430.c (ATTR_NOINIT): New constant.\n+\t(ATTR_PERSIST): New constant.\n+\t(msp430_data_attr): New function - verifies an attribute that only\n+\tapplies to variables.\n+\t(msp430_attributes): Add noinit and persistent attributes.\n+\t(noinit_section): New variable.\n+\t(presis_section): New variable.\n+\t(TARGET_ASM_INIT_SECTIONS): Define.\n+\t(msp430_init_sections): New function - initialises the noinit and\n+\tpersist section variables.\n+\t(msp430_select_section): Add support for noinit and persist\n+\tattributes.\n+\t(msp430_section_type_flags): Likewise.\n+\t* doc/extend.texi:  Document the reent, critical, wakeup, noinit\n+\tand persistent attributes.\n+\n 2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "4f6df0191ccb17d500830c514334f35910c833f5", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90bc48789b8ca036a728396de3d26b6a2b6a60e8/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90bc48789b8ca036a728396de3d26b6a2b6a60e8/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=90bc48789b8ca036a728396de3d26b6a2b6a60e8", "patch": "@@ -1148,6 +1148,8 @@ const char * const  ATTR_CRIT   = \"critical\";\n const char * const  ATTR_LOWER  = \"lower\";\n const char * const  ATTR_UPPER  = \"upper\";\n const char * const  ATTR_EITHER = \"either\";\n+const char * const  ATTR_NOINIT = \"noinit\";\n+const char * const  ATTR_PERSIST = \"persistent\";\n \n static inline bool\n has_attr (const char * attr, tree decl)\n@@ -1278,7 +1280,7 @@ msp430_attr (tree * node,\n       if (is_naked_func (* node))\n \tmessage = \"naked functions cannot be critical\";\n       else if (is_reentrant_func (* node))\n-\tmessage = \"reentranct functions cannot be critical\";\n+\tmessage = \"reentrant functions cannot be critical\";\n     }\n   else if (TREE_NAME_EQ (name, ATTR_NAKED))\n     {\n@@ -1344,6 +1346,39 @@ msp430_section_attr (tree * node,\n   return NULL_TREE;\n }\n \n+static tree\n+msp430_data_attr (tree * node,\n+\t\t  tree   name,\n+\t\t  tree   args,\n+\t\t  int    flags ATTRIBUTE_UNUSED,\n+\t\t  bool * no_add_attrs ATTRIBUTE_UNUSED)\n+{\n+  const char * message = NULL;\n+\n+  gcc_assert (DECL_P (* node));\n+  gcc_assert (args == NULL);\n+\n+  if (TREE_CODE (* node) != VAR_DECL)\n+    message = \"%qE attribute only applies to variables\";\n+\n+  if (DECL_SECTION_NAME (* node))\n+    message = \"%qE attribute cannot be applied to variables with specific sections\";\n+\n+  /* If this var is thought to be common, then change this.  Common variables\n+     are assigned to sections before the backend has a chance to process them.  */\n+  if (DECL_COMMON (* node))\n+    DECL_COMMON (* node) = 0;\n+\n+  if (message)\n+    {\n+      warning (OPT_Wattributes, message, name);\n+      * no_add_attrs = true;\n+    }\n+    \n+  return NULL_TREE;\n+}\n+\n+\n #undef  TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE\t\tmsp430_attribute_table\n \n@@ -1363,6 +1398,9 @@ const struct attribute_spec msp430_attribute_table[] =\n   { ATTR_UPPER,       0, 0, true,  false, false, msp430_section_attr, false },\n   { ATTR_EITHER,      0, 0, true,  false, false, msp430_section_attr, false },\n \n+  { ATTR_NOINIT,      0, 0, true,  false, false, msp430_data_attr, false },\n+  { ATTR_PERSIST,     0, 0, true,  false, false, msp430_data_attr, false },\n+\n   { NULL,             0, 0, false, false, false, NULL,        false }\n };\n \n@@ -1536,6 +1574,19 @@ gen_prefix (tree decl)\n   return NULL;\n }\n \n+static section * noinit_section;\n+static section * persist_section;\n+\n+#undef  TARGET_ASM_INIT_SECTIONS\n+#define TARGET_ASM_INIT_SECTIONS msp430_init_sections\n+\n+static void\n+msp430_init_sections (void)\n+{\n+  noinit_section = get_unnamed_section (0, output_section_asm_op, \".section .noinit,\\\"aw\\\"\");\n+  persist_section = get_unnamed_section (0, output_section_asm_op, \".section .persistent,\\\"aw\\\"\");\n+}\n+\n #undef  TARGET_ASM_SELECT_SECTION\n #define TARGET_ASM_SELECT_SECTION msp430_select_section\n \n@@ -1561,6 +1612,10 @@ msp430_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n     {\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \treturn text_section;\n+      else if (has_attr (ATTR_NOINIT, decl))\n+\treturn noinit_section;\n+      else if (has_attr (ATTR_PERSIST, decl))\n+\treturn persist_section;\n       else\n \treturn default_select_section (decl, reloc, align);\n     }\n@@ -1629,7 +1684,11 @@ msp430_section_type_flags (tree decl, const char * name, int reloc)\n     name += strlen (upper_prefix);\n   else if (strncmp (name, either_prefix, strlen (either_prefix)) == 0)\n     name += strlen (either_prefix);\n-\n+  else if (strcmp (name, \".noinit\") == 0)\n+    return SECTION_WRITE | SECTION_BSS | SECTION_NOTYPE;\n+  else if (strcmp (name, \".persisten\") == 0)\n+    return SECTION_WRITE | SECTION_NOTYPE;\n+  \n   return default_section_type_flags (decl, name, reloc);\n }\n "}, {"sha": "79440d301fb819e26489e26848df858e1ffbc91f", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90bc48789b8ca036a728396de3d26b6a2b6a60e8/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90bc48789b8ca036a728396de3d26b6a2b6a60e8/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=90bc48789b8ca036a728396de3d26b6a2b6a60e8", "patch": "@@ -3319,6 +3319,24 @@ one pass over the objects and does the best that it can.  Using the\n options can help the packing however, since they produce smaller,\n easier to pack regions.\n \n+@item reentrant\n+On the MSP430 a function can be given the @code{reentant} attribute.\n+This makes the function disable interrupts upon entry and enable\n+interrupts upon exit.  Reentrant functions cannot be @code{naked}.\n+\n+@item critical\n+On the MSP430 a function can be given the @code{critical} attribute.\n+This makes the function disable interrupts upon entry and restore the\n+previous interrupt enabled/disabled state upon exit.  A function\n+cannot have both the @code{reentrant} and @code{critical} attributes.\n+Critical functions cannot be @code{naked}.\n+\n+@item wakeup\n+On the MSP430 a function can be given the @code{wakeup} attribute.\n+Such a function must also have the @code{interrupt} attribute.  When a\n+function with the @code{wakeup} attribute exists the processor will be\n+woken up from any low-power state in which it may be residing.\n+\n @end table\n \n @c This is the end of the target-independent attribute table\n@@ -5264,6 +5282,7 @@ attributes.\n * M32R/D Variable Attributes::\n * MeP Variable Attributes::\n * Microsoft Windows Variable Attributes::\n+* MSP430 Variable Attributes::\n * PowerPC Variable Attributes::\n * SPU Variable Attributes::\n * x86 Variable Attributes::\n@@ -5854,6 +5873,38 @@ The @code{shared} attribute is only available on Microsoft Windows@.\n \n @end table\n \n+@node MSP430 Variable Attributes\n+@subsection MSP430 Variable Attributes\n+\n+@table @code\n+@item noinit\n+@cindex @code{noinit} MSP430 variable attribute\n+Any data with the @code{noinit} attribute will not be initialised by\n+the C runtime startup code, or the program loader.  Not initialising\n+data in this way can reduce program startup times.\n+\n+@item persistent\n+@cindex @code{persistent} MSP430 variable attribute\n+Any variable with the @code{persistent} attribute will not be\n+initialised by the C runtime startup code.  Instead its value will be\n+set once, when the application is loaded, and then never initialised\n+again, even if the processor is reset or the program restarts.\n+Persistent data is intended to be placed into FLASH RAM, where its\n+value will be retained across resets.  The linker script being used to\n+create the application should ensure that persistent data is correctly\n+placed.\n+\n+@item lower\n+@itemx upper\n+@itemx either\n+@cindex @code{lower} memory region on the MSP430\n+@cindex @code{upper} memory region on the MSP430\n+@cindex @code{either} memory region on the MSP430\n+These attributes are the same as the MSP430 function attributes of the\n+same name.  These attributes can be applied to both functions and\n+variables.\n+@end table\n+\n @node PowerPC Variable Attributes\n @subsection PowerPC Variable Attributes\n "}, {"sha": "0e06ee82cd2454d6121e38eae7853eb7eba1673f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90bc48789b8ca036a728396de3d26b6a2b6a60e8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90bc48789b8ca036a728396de3d26b6a2b6a60e8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=90bc48789b8ca036a728396de3d26b6a2b6a60e8", "patch": "@@ -1,3 +1,11 @@\n+2015-10-06  Nick Clifton  <nickc@redhat.com>\n+\n+\t* gcc.target/msp430: New directory.\n+\t* gcc.target/msp430/msp430.exp: New file.  Runs MSP430 specific\n+\ttests.\n+\t* gcc.target/msp430/data-attributes.c: New file.  Checks the\n+\tnoinit and persistent data attributes.\n+\n 2015-10-06  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* gcc.target/i386/builtin_target.c: Fix AVX-512VBMI detection."}, {"sha": "10dd1714d72eb137fa2d316c7882ca4e3b1bd658", "filename": "gcc/testsuite/gcc.target/msp430/data-attributes.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90bc48789b8ca036a728396de3d26b6a2b6a60e8/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fdata-attributes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90bc48789b8ca036a728396de3d26b6a2b6a60e8/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fdata-attributes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fdata-attributes.c?ref=90bc48789b8ca036a728396de3d26b6a2b6a60e8", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+/* This test checks that persistent and noinit data are handled correctly.  */\n+\n+extern void __crt0_start (void) __attribute__ ((noreturn));\n+extern void abort (void) __attribute__ ((noreturn));\n+extern void exit (int) __attribute__ ((noreturn));\n+\n+int a;\n+int b = 0;\n+int c = 1;\n+int __attribute__((noinit)) d;\n+int __attribute__((persistent)) e = 2;\n+\n+int\n+main (void)\n+{\n+  /* Make sure that the C startup code has correctly initialised the ordinary variables.  */\n+  if (a != 0)\n+    abort ();\n+\n+#ifndef __MSP430X_LARGE__\n+  /* For non-large targets we use the ordinary msp430-sim.ld linker script.\n+     This does not support FLASH, and as a side effect it does not support\n+     reinitialising initialised data.  Hence we only test b and c if this\n+     is the first time through this test, or large support has been enabled.  */\n+  if (e == 2)\n+#endif\n+  if (b != 0 || c != 1)\n+    abort ();\n+  \n+  switch (e)\n+    {\n+    case 2:\n+      /* First time through - change all the values.  */\n+      a = b = c = d = e = 3;\n+      break;\n+\n+    case 3:\n+      /* Second time through - make sure that d has not been reset.  */\n+      if (d != 3)\n+\tabort ();\n+      exit (0);\n+\n+    default:\n+      /* Any other value for e is an error.  */\n+      abort ();\n+    }\n+\n+  /* Simulate a processor reset by calling the C startup code.  */\n+  __crt0_start ();\n+\n+  /* Should never reach here.  */\n+  abort ();\n+}"}, {"sha": "488fcb1a79b0bbd2c25e100195aadadfa08bd5c7", "filename": "gcc/testsuite/gcc.target/msp430/msp430.exp", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90bc48789b8ca036a728396de3d26b6a2b6a60e8/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmsp430.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90bc48789b8ca036a728396de3d26b6a2b6a60e8/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmsp430.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmsp430.exp?ref=90bc48789b8ca036a728396de3d26b6a2b6a60e8", "patch": "@@ -0,0 +1,41 @@\n+# Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  \n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't the right target.\n+if { ![istarget msp430-*-*] } then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \"\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cCS\\]]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}]}