{"sha": "36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZhNWVhZGQxYTE4YTU1YjdiMmI1ODViYjVlYjM3MzZhYjY4YmE0OA==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2002-09-16T18:33:23Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2002-09-16T18:33:23Z"}, "message": "Index: gcc/ChangeLog\n2002-09-12  Geoffrey Keating  <geoffk@apple.com>\n\n\t* ggc-common.c (ggc_mark_rtx_children_1): Update for changed name\n\tmangling.\n\n\tThe following changes are merged from pch-branch:\n\n\t* doc/gty.texi (GTY Options): Document %a.\n\t* gengtype.c (do_scalar_typedef): New function.\n\t(process_gc_options): Handle `length' option.\n\t(set_gc_used_type): A pointer to an array of structures doesn't\n\tqualify as a pointer to a structure.\n\t(output_escaped_param): Add `%a' escape.\n\t(write_gc_structure_fields): Allow 'desc' on array of unions.\n\t(main): Define `uint8', `jword' and `JCF_u2' as scalars; use\n\tdo_scalar_typedef.\n\n\t* gengtype.c (enum rtx_code): Make global.\n\t(rtx_format): Make global.\n\t(rtx_next): New.\n\t(gen_rtx_next): New.\n\t(write_rtx_next): New.\n\t(adjust_field_rtx_def): Skip fields marked by chain_next.\n\t(open_base_files): Delete redundant prototype.\n\t(write_enum_defn): New.\n\t(output_mangled_typename): Correct abort call.\n\t(write_gc_marker_routine_for_structure): Handle chain_next and\n\tchain_prev options.\n\t(finish_root_table): Don't output redundant \\n.\n\t(main): Call gen_rtx_next, write_rtx_next, write_enum_defn.\n\t* c-tree.h (union lang_tree_node): Add chain_next option.\n\n\t* gengtype.h (NUM_PARAM): New definition.\n\t(struct type): For TYPE_PARAM_STRUCT, allow multiple parameters.\n\t* gengtype.c (find_param_structure): New.\n\t(adjust_field_type): Handle param<n>_is option.\n\t(process_gc_options): Detect use_params option.  Update callers.\n\t(set_gc_used_type): Add 'param' parameter, update callers.  Handle\n\t'use_params' option.\n\t(open_base_files): Add splay-tree.h to list of files included.\n\t(output_mangled_typename): New.\n\t(write_gc_structure_fields): Update 'param' parameter to support\n\tmultiple parameters.  Change name mangling.  Allow parameterized\n\tfields to have an apparent scalar type.  Handle param<n>_is options,\n\tuse_param option.\n\t(write_gc_marker_routine_for_structure): Update for change to name\n\tmangling.  Better guess the output file for parameterized types.\n\t(write_gc_types): Update for change to name mangling.\n\t(write_gc_root): Update for change to name mangling.  Handle (ignore)\n\tparam<n>_is options.\n\t* doc/gty.texi (GTY Options): Add description of param<n>_is\n\toptions, use_params option.\n\t* ggc.h (ggc_mark_rtx): Update for changed name mangling.\n\t* gengtype-lex.l: Produce token for param<n>_is.\n\t* gengtype-yacc.y: Parse param<n>_is.\n\n\t* gengtype.c (adjust_field_tree_exp): Don't name a variable 'rindex'.\n\n\t* rtl.c: Update comment describing rtx_format.\n\t* rtl.h (union rtunion): Separate definition and typedef.\n\t(struct rtx_def): Use gengtype to mark.\n\t* Makefile.in (gengtype.o): Also depend on rtl.def.\n\t* ggc.h (ggc_mark_rtx_children): Delete prototype.\n\t(ggc_mark_rtx): Change to alias of gengtype-generated routine.\n\t* ggc-common.c (ggc_mark_rtx_children): Delete.\n\t(ggc_mark_rtx_children_1): Delete.\n\t(gt_ggc_m_rtx_def): Delete.\n\t* gengtype.c (adjust_field_rtx_def): New.\n\t(adjust_field_type): Call adjust_field_rtx_def.\n\t(write_gc_structure_fields): Add 'default' case to switch if none\n\tis specified; remove unused code.\n\n\t* tree.h (struct tree_exp): Update for change to meaning\n\tof special.\n\t* gengtype.c (adjust_field_tree_exp): New function.\n\t(adjust_field_type): Handle `tree_exp' special here.\n\t(write_gc_structure_fields): Don't handle `tree_exp' special here.\n\tHandle new `dot' option.\n\n\t* gengtype.h: Make `info' a pointer-to-const.\n\t* gengtype-yacc.y (yacc_ids): Use xasprintf.\n\n\t* gengtype.c (write_gc_structure_fields): Remove implementation\n\tof `always' option, add `default' option.\n\t* doc/gty.texi (GTY Options): Remove documentation of `always',\n\tadd `default'.\n\nIndex: gcc/cp/ChangeLog\n2002-09-12  Geoffrey Keating  <geoffk@apple.com>\n\n\t* cp-tree.h (union lang_tree_node): Add chain_next option.\n\nIndex: gcc/f/ChangeLog\n2002-09-12  Geoffrey Keating  <geoffk@apple.com>\n\n\t* com.c (union lang_tree_node): Add chain_next option.\n\nIndex: gcc/java/ChangeLog\n2002-09-12  Geoffrey Keating  <geoffk@apple.com>\n\n\t* java-tree.h (union lang_tree_node): Add chain_next option.\n\nFrom-SVN: r57206", "tree": {"sha": "c61dabe0ee2f12a433921e41d3b1799e3b26b2f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c61dabe0ee2f12a433921e41d3b1799e3b26b2f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7f6d760f368c9600bb96e142545303cc06d6abe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f6d760f368c9600bb96e142545303cc06d6abe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7f6d760f368c9600bb96e142545303cc06d6abe"}], "stats": {"total": 1439, "additions": 1054, "deletions": 385}, "files": [{"sha": "47c56942e7ea927cc820b8a25efec2877ff3f5af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -1,3 +1,90 @@\n+2002-09-16  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* ggc-common.c (ggc_mark_rtx_children_1): Update for changed name\n+\tmangling.\n+\n+\tThe following changes are merged from pch-branch:\n+\n+\t* doc/gty.texi (GTY Options): Document %a.\n+\t* gengtype.c (do_scalar_typedef): New function.\n+\t(process_gc_options): Handle `length' option.\n+\t(set_gc_used_type): A pointer to an array of structures doesn't\n+\tqualify as a pointer to a structure.\n+\t(output_escaped_param): Add `%a' escape.\n+\t(write_gc_structure_fields): Allow 'desc' on array of unions.\n+\t(main): Define `uint8', `jword' and `JCF_u2' as scalars; use\n+\tdo_scalar_typedef.\n+\n+\t* gengtype.c (enum rtx_code): Make global.\n+\t(rtx_format): Make global.\n+\t(rtx_next): New.\n+\t(gen_rtx_next): New.\n+\t(write_rtx_next): New.\n+\t(adjust_field_rtx_def): Skip fields marked by chain_next.\n+\t(open_base_files): Delete redundant prototype.\n+\t(write_enum_defn): New.\n+\t(output_mangled_typename): Correct abort call.\n+\t(write_gc_marker_routine_for_structure): Handle chain_next and\n+\tchain_prev options.\n+\t(finish_root_table): Don't output redundant \\n.\n+\t(main): Call gen_rtx_next, write_rtx_next, write_enum_defn.\n+\t* c-tree.h (union lang_tree_node): Add chain_next option.\n+\n+\t* gengtype.h (NUM_PARAM): New definition.\n+\t(struct type): For TYPE_PARAM_STRUCT, allow multiple parameters.\n+\t* gengtype.c (find_param_structure): New.\n+\t(adjust_field_type): Handle param<n>_is option.\n+\t(process_gc_options): Detect use_params option.  Update callers.\n+\t(set_gc_used_type): Add 'param' parameter, update callers.  Handle\n+\t'use_params' option.\n+\t(open_base_files): Add splay-tree.h to list of files included.\n+\t(output_mangled_typename): New.\n+\t(write_gc_structure_fields): Update 'param' parameter to support\n+\tmultiple parameters.  Change name mangling.  Allow parameterized\n+\tfields to have an apparent scalar type.  Handle param<n>_is options,\n+\tuse_param option.\n+\t(write_gc_marker_routine_for_structure): Update for change to name\n+\tmangling.  Better guess the output file for parameterized types.\n+\t(write_gc_types): Update for change to name mangling.\n+\t(write_gc_root): Update for change to name mangling.  Handle (ignore)\n+\tparam<n>_is options.\n+\t* doc/gty.texi (GTY Options): Add description of param<n>_is\n+\toptions, use_params option.\n+\t* ggc.h (ggc_mark_rtx): Update for changed name mangling.\n+\t* gengtype-lex.l: Produce token for param<n>_is.\n+\t* gengtype-yacc.y: Parse param<n>_is.\n+\n+\t* gengtype.c (adjust_field_tree_exp): Don't name a variable 'rindex'.\n+\n+\t* rtl.c: Update comment describing rtx_format.\n+\t* rtl.h (union rtunion): Separate definition and typedef.\n+\t(struct rtx_def): Use gengtype to mark.\n+\t* Makefile.in (gengtype.o): Also depend on rtl.def.\n+\t* ggc.h (ggc_mark_rtx_children): Delete prototype.\n+\t(ggc_mark_rtx): Change to alias of gengtype-generated routine.\n+\t* ggc-common.c (ggc_mark_rtx_children): Delete.\n+\t(ggc_mark_rtx_children_1): Delete.\n+\t(gt_ggc_m_rtx_def): Delete.\n+\t* gengtype.c (adjust_field_rtx_def): New.\n+\t(adjust_field_type): Call adjust_field_rtx_def.\n+\t(write_gc_structure_fields): Add 'default' case to switch if none\n+\tis specified; remove unused code.\n+\n+\t* tree.h (struct tree_exp): Update for change to meaning\n+\tof special.\n+\t* gengtype.c (adjust_field_tree_exp): New function.\n+\t(adjust_field_type): Handle `tree_exp' special here.\n+\t(write_gc_structure_fields): Don't handle `tree_exp' special here.\n+\tHandle new `dot' option.\n+\n+\t* gengtype.h: Make `info' a pointer-to-const.\n+\t* gengtype-yacc.y (yacc_ids): Use xasprintf.\n+\n+\t* gengtype.c (write_gc_structure_fields): Remove implementation\n+\tof `always' option, add `default' option.\n+\t* doc/gty.texi (GTY Options): Remove documentation of `always',\n+\tadd `default'.\n+\n 2002-09-16  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* output.h: Remove #ifdef RTX_CODE and #ifdef TREE_CODE."}, {"sha": "d95232419f6f4892cb89f64dd7c94190ab333c3f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -2053,7 +2053,8 @@ gengtype$(build_exeext) : gengtype.o gengtype-lex.o gengtype-yacc.o \\\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n \t gengtype.o gengtype-lex.o gengtype-yacc.o $(HOST_LIBS)\n \n-gengtype.o : gengtype.c gengtype.h $(HCONFIG_H) $(SYSTEM_H) real.h gtyp-gen.h\n+gengtype.o : gengtype.c gengtype.h $(HCONFIG_H) $(SYSTEM_H) real.h rtl.def \\\n+  gtyp-gen.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n \t  $(srcdir)/gengtype.c $(OUTPUT_OPTION)\n "}, {"sha": "159c235224e230fc94b48cc47b1789dd49edd910", "filename": "gcc/c-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -48,7 +48,8 @@ struct lang_identifier GTY(())\n /* The resulting tree type.  */\n \n union lang_tree_node \n-  GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\")))\n+  GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n+       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n {\n   union tree_node GTY ((tag (\"0\"), \n \t\t\tdesc (\"tree_node_structure (&%h)\"))) "}, {"sha": "4a480412cf5bdfb48f9e1b3d84ea93ed261d8fd6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -1,3 +1,7 @@\n+2002-09-16  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* cp-tree.h (union lang_tree_node): Add chain_next option.\n+\n 2002-09-16  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* parse.y (parse_finish_call_expr): Check lookup_member result."}, {"sha": "bbfdd3a889ce4018a6a6195d57ea828c1af3b8e1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -505,7 +505,8 @@ enum cp_tree_node_structure_enum {\n };\n \n /* The resulting tree type.  */\n-union lang_tree_node GTY((desc (\"cp_tree_node_structure (&%h)\")))\n+union lang_tree_node GTY((desc (\"cp_tree_node_structure (&%h)\"),\n+       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n {\n   struct tree_common GTY ((tag (\"TS_CP_COMMON\"))) common;\n   union tree_node GTY ((tag (\"TS_CP_GENERIC\"),"}, {"sha": "e0d9a33cde645d5379dfa7288e88a2f5b3e504cb", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -72,6 +72,10 @@ immediately contains the current structure.\n @item %0\n This expands to an expression that evaluates to the outermost structure\n that contains the current structure.\n+@item %a\n+This expands to the string of the form @code{[i1][i2]...} that indexes\n+the array item currently being marked.  For instance, if the field\n+being marked is @code{foo}, then @code{%1.foo%a} is the same as @code{%h}.\n @end table\n \n The available options are:\n@@ -121,10 +125,10 @@ field really isn't ever used.\n \n @findex desc\n @findex tag\n-@findex always\n+@findex default\n @item desc\n @itemx tag\n-@itemx always\n+@itemx default\n \n The type machinery needs to be told which field of a @code{union} is\n currently active.  This is done by giving each field a constant @code{tag}\n@@ -146,23 +150,49 @@ it discriminates.  Use @code{%1} to mean the structure containing it.\n (There are no escapes available to the @code{tag} option, since it's\n supposed to be a constant.)\n \n-You can use @code{always} to mean that this field is always used.\n+Each @code{tag} should be different.  If no @code{tag} is matched,\n+the field marked with @code{default} is used if there is one, otherwise\n+no field in the union will be marked.\n \n @findex param_is\n @findex use_param\n @item param_is\n @itemx use_param\n \n Sometimes it's convenient to define some data structure to work on\n-generic pointers (that is, @code{PTR}), and then use it with specific types.\n-@code{param_is} specifies the real type pointed to, and @code{use_param}\n-says where in the generic data structure that type should be put.\n+generic pointers (that is, @code{PTR}) and then use it with a specific\n+type.  @code{param_is} specifies the real type pointed to, and\n+@code{use_param} says where in the generic data structure that type\n+should be put.\n \n For instance, to have a @code{htab_t} that points to trees, one should write\n @verbatim\n   htab_t GTY ((param_is (union tree_node))) ict;\n @end verbatim\n \n+@findex param@var{n}_is\n+@findex use_param@var{n}\n+@item param@var{n}_is\n+@itemx use_param@var{n}\n+\n+In more complicated cases, the data structure might need to work on\n+several different types, which might not necessarily all be pointers.\n+For this, @code{param1_is} through @code{param9_is} may be used to\n+specify the real type of a field identified by @code{use_param1} through\n+@code{use_param9}.\n+\n+@findex use_params\n+@item use_params\n+\n+When a structure contains another structure that is parameterised,\n+there's no need to do anything special, the inner stucture inherits the\n+parameters of the outer one.  When a structure contains a pointer to a\n+parameterised structure, the type machinery won't automatically detect\n+this (it could, it just doesn't yet), so it's necessary to tell it that\n+the pointed-to structure should use the same parameters as the outer\n+structure.  This is done by marking the pointer with the\n+@code{use_params} option.\n+\n @findex deletable\n @item deletable\n "}, {"sha": "e71c8c72e3228b326300cec47908c7f7a18d6730", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -1,3 +1,7 @@\n+2002-09-16  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* com.c (union lang_tree_node): Add chain_next option.\n+\n 2002-09-16  Richard Henderson  <rth@redhat.com>\n \n \t* target.c (ffetarget_real1): Don't pass FFETARGET_ATOF_"}, {"sha": "931858afac1e3bc69b68ad7d4820fb224cf4936d", "filename": "gcc/f/com.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -605,7 +605,8 @@ struct lang_identifier GTY(())\n \n /* The resulting tree type.  */\n union lang_tree_node \n-  GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\")))\n+  GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n+       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n {\n   union tree_node GTY ((tag (\"0\"), \n \t\t\tdesc (\"tree_node_structure (&%h)\"))) "}, {"sha": "91cdde29580d41f60c70f85f16efb2bbb865b4a6", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -203,8 +203,11 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n \"struct\"/[^[:alnum:]_]\t\t{ return STRUCT; }\n \"enum\"/[^[:alnum:]_]\t\t{ return ENUM; }\n \"ptr_alias\"/[^[:alnum:]_]\t{ return ALIAS; }\n-\"param_is\"/[^[:alnum:]_]\t{ return PARAM_IS; }\n [0-9]+\t\t\t\t{ return NUM; }\n+\"param\"[0-9]*\"_is\"/[^[:alnum:]_]\t\t{ \n+  yylval.s = xmemdup (yytext, yyleng, yyleng+1);\n+  return PARAM_IS;\n+}\n \n {IWORD}({WS}{IWORD})*/[^[:alnum:]_]\t\t|\n \"ENUM_BITFIELD\"{WS}?\"(\"{WS}?{ID}{WS}?\")\"\t{"}, {"sha": "87837b407bed9dc7b76afc791d664b74d3c7fb18", "filename": "gcc/gengtype-yacc.y", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fgengtype-yacc.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fgengtype-yacc.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-yacc.y?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -42,7 +42,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n %token STRUCT \"struct\"\n %token ENUM \"enum\"\n %token ALIAS \"ptr_alias\"\n-%token PARAM_IS \"param_is\"\n+%token <s>PARAM_IS\n %token NUM\n %token PERCENTPERCENT \"%%\"\n %token <t>SCALAR\n@@ -174,8 +174,7 @@ yacc_ids: /* empty */\n \t  p->opt = xmalloc (sizeof (*(p->opt)));\n \t  p->opt->name = \"tag\";\n \t  p->opt->next = NULL;\n-\t  p->opt->info = xmalloc (3 + strlen ($2));\n-\t  sprintf (p->opt->info, \"'%s'\", $2);\n+\t  p->opt->info = xasprintf (\"'%s'\", $2);\n \t  $$ = p;\n \t}\n      ;\n@@ -263,14 +262,14 @@ options: GTY_TOKEN '(' '(' optionseqopt ')' ')'\n type_option : ALIAS\n \t        { $$ = \"ptr_alias\"; }\n \t      | PARAM_IS\n-\t        { $$ = \"param_is\"; }\n+\t        { $$ = $1; }\n \t      ;\n \n option:\ttype_option '(' type ')'\n \t   {\n \t     options_p o = xmalloc (sizeof (*o));\n \t     o->name = $1;\n-\t     o->info = $3;\n+\t     o->info = adjust_field_type ($3, NULL);\n \t     $$ = o;\n \t   }\n \t| ID '(' STRING ')'"}, {"sha": "9ec9863de8cf711065e4354e98444cb87c4be680", "filename": "gcc/gengtype.c", "status": "modified", "additions": 866, "deletions": 215, "changes": 1081, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -26,10 +26,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Nonzero iff an error has occurred.  */\n static int hit_error = 0;\n \n+static void gen_rtx_next PARAMS ((void));\n+static void write_rtx_next PARAMS ((void));\n static void open_base_files PARAMS ((void));\n static void close_output_files PARAMS ((void));\n \n-\n /* Report an error at POS, printing MSG.  */\n \n void\n@@ -89,6 +90,12 @@ static type_p structures;\n static type_p param_structs;\n static pair_p variables;\n \n+static void do_scalar_typedef PARAMS ((const char *, struct fileloc *));\n+static type_p find_param_structure \n+  PARAMS ((type_p t, type_p param[NUM_PARAM]));\n+static type_p adjust_field_tree_exp PARAMS ((type_p t, options_p opt));\n+static type_p adjust_field_rtx_def PARAMS ((type_p t, options_p opt));\n+\n /* Define S as a typedef to T at POS.  */\n \n void\n@@ -118,6 +125,16 @@ do_typedef (s, t, pos)\n   typedefs = p;\n }\n \n+/* Define S as a typename of a scalar.  */\n+\n+static void\n+do_scalar_typedef (s, pos)\n+     const char *s;\n+     struct fileloc *pos;\n+{\n+  do_typedef (s, create_scalar_type (s, strlen (s)), pos);\n+}\n+\n /* Return the type previously defined for S.  Use POS to report errors.  */\n \n type_p\n@@ -235,6 +252,34 @@ find_structure (name, isunion)\n   return s;\n }\n \n+/* Return the previously-defined parameterised structure for structure\n+   T and parameters PARAM, or a new parameterised empty structure or\n+   union if none was defined previously.    */\n+\n+static type_p\n+find_param_structure (t, param)\n+     type_p t;\n+     type_p param[NUM_PARAM];\n+{\n+  type_p res;\n+  \n+  for (res = param_structs; res; res = res->next)\n+    if (res->u.param_struct.stru == t\n+\t&& memcmp (res->u.param_struct.param, param, \n+\t\t   sizeof (type_p) * NUM_PARAM) == 0)\n+      break;\n+  if (res == NULL)\n+    {\n+      res = xcalloc (1, sizeof (*res));\n+      res->kind = TYPE_PARAM_STRUCT;\n+      res->next = param_structs;\n+      param_structs = res;\n+      res->u.param_struct.stru = t;\n+      memcpy (res->u.param_struct.param, param, sizeof (type_p) * NUM_PARAM);\n+    }\n+  return res;\n+}\n+\n /* Return a scalar type with name NAME.  */\n \n type_p\n@@ -280,13 +325,420 @@ create_array (t, len)\n   return v;\n }\n \n+/* Add a variable named S of type T with options O defined at POS,\n+   to `variables'.  */\n+\n+void\n+note_variable (s, t, o, pos)\n+     const char *s;\n+     type_p t;\n+     options_p o;\n+     struct fileloc *pos;\n+{\n+  pair_p n;\n+  n = xmalloc (sizeof (*n));\n+  n->name = s;\n+  n->type = t;\n+  n->line = *pos;\n+  n->opt = o;\n+  n->next = variables;\n+  variables = n;\n+}\n+\n+enum rtx_code {\n+#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   ENUM ,\n+#include \"rtl.def\"\n+#undef DEF_RTL_EXPR\n+    NUM_RTX_CODE\n+};\n+\n+/* We really don't care how long a CONST_DOUBLE is.  */\n+#define CONST_DOUBLE_FORMAT \"ww\"\n+static const char * const rtx_format[NUM_RTX_CODE] = {\n+#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   FORMAT ,\n+#include \"rtl.def\"\n+#undef DEF_RTL_EXPR\n+};\n+\n+static char rtx_next[NUM_RTX_CODE];\n+\n+/* Generate the contents of the rtx_next array.  This really doesn't belong\n+   in gengtype at all, but it's needed for adjust_field_rtx_def.  */\n+\n+static void\n+gen_rtx_next ()\n+{\n+  int i;\n+  for (i = 0; i < NUM_RTX_CODE; i++)\n+    {\n+      int k;\n+      \n+      rtx_next[i] = -1;\n+      if (strncmp (rtx_format[i], \"iuu\", 3) == 0)\n+\trtx_next[i] = 2;\n+      else if (i == COND_EXEC || i == SET || i == EXPR_LIST || i == INSN_LIST)\n+\trtx_next[i] = 1;\n+      else \n+\tfor (k = strlen (rtx_format[i]) - 1; k >= 0; k--)\n+\t  if (rtx_format[i][k] == 'e' || rtx_format[i][k] == 'u')\n+\t    rtx_next[i] = k;\n+    }\n+}\n+\n+/* Write out the contents of the rtx_next array.  */\n+static void\n+write_rtx_next ()\n+{\n+  outf_p f = get_output_file_with_visibility (NULL);\n+  int i;\n+  \n+  oprintf (f, \"\\n/* Used to implement the RTX_NEXT macro.  */\\n\");\n+  oprintf (f, \"const unsigned char rtx_next[NUM_RTX_CODE] = {\\n\");\n+  for (i = 0; i < NUM_RTX_CODE; i++)\n+    if (rtx_next[i] == -1)\n+      oprintf (f, \"  0,\\n\");\n+    else\n+      oprintf (f, \n+\t       \"  offsetof (struct rtx_def, fld) + %d * sizeof (rtunion),\\n\",\n+\t       rtx_next[i]);\n+  oprintf (f, \"};\\n\");\n+}\n+\n+/* Handle `special(\"rtx_def\")'.  This is a special case for field\n+   `fld' of struct rtx_def, which is an array of unions whose values\n+   are based in a complex way on the type of RTL.  */\n+\n+static type_p\n+adjust_field_rtx_def (t, opt)\n+     type_p t;\n+     options_p opt ATTRIBUTE_UNUSED;\n+{\n+  pair_p flds = NULL;\n+  options_p nodot;\n+  int i;\n+  type_p rtx_tp, rtvec_tp, tree_tp, mem_attrs_tp, note_union_tp, scalar_tp;\n+  type_p bitmap_tp, basic_block_tp;\n+\n+  static const char * const rtx_name[NUM_RTX_CODE] = {\n+#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   NAME ,\n+#include \"rtl.def\"\n+#undef DEF_RTL_EXPR\n+  };\n+  \n+  if (t->kind != TYPE_ARRAY)\n+    {\n+      error_at_line (&lexer_line, \n+\t\t     \"special `rtx_def' must be applied to an array\");\n+      return &string_type;\n+    }\n+  \n+  nodot = xmalloc (sizeof (*nodot));\n+  nodot->next = NULL;\n+  nodot->name = \"dot\";\n+  nodot->info = \"\";\n+\n+  rtx_tp = create_pointer (find_structure (\"rtx_def\", 0));\n+  rtvec_tp = create_pointer (find_structure (\"rtvec_def\", 0));\n+  tree_tp = create_pointer (find_structure (\"tree_node\", 1));\n+  mem_attrs_tp = create_pointer (find_structure (\"mem_attrs\", 0));\n+  bitmap_tp = create_pointer (find_structure (\"bitmap_element_def\", 0));\n+  basic_block_tp = create_pointer (find_structure (\"basic_block_def\", 0));\n+  scalar_tp = create_scalar_type (\"rtunion scalar\", 14);\n+\n+  {\n+    pair_p note_flds = NULL;\n+    int c;\n+    \n+    for (c = 0; c < 3; c++)\n+      {\n+\tpair_p old_note_flds = note_flds;\n+\t\n+\tnote_flds = xmalloc (sizeof (*note_flds));\n+\tnote_flds->line.file = __FILE__;\n+\tnote_flds->line.line = __LINE__;\n+\tnote_flds->name = \"rttree\";\n+\tnote_flds->type = tree_tp;\n+\tnote_flds->opt = xmalloc (sizeof (*note_flds->opt));\n+\tnote_flds->opt->next = nodot;\n+\tnote_flds->opt->name = \"tag\";\n+\tnote_flds->next = old_note_flds;\n+      }\n+    \n+    note_flds->type = rtx_tp;\n+    note_flds->name = \"rtx\";\n+    note_flds->opt->info = \"NOTE_INSN_EXPECTED_VALUE\";\n+    note_flds->next->opt->info = \"NOTE_INSN_BLOCK_BEG\";\n+    note_flds->next->next->opt->info = \"NOTE_INSN_BLOCK_END\";\n+    \n+    new_structure (\"rtx_def_note_subunion\", 1, &lexer_line, note_flds, NULL);\n+  }\n+  \n+  note_union_tp = find_structure (\"rtx_def_note_subunion\", 1);\n+\n+  for (i = 0; i < NUM_RTX_CODE; i++)\n+    {\n+      pair_p old_flds = flds;\n+      pair_p subfields = NULL;\n+      size_t aindex, nmindex;\n+      const char *sname;\n+      char *ftag;\n+\n+      for (aindex = 0; aindex < strlen (rtx_format[i]); aindex++)\n+\t{\n+\t  pair_p old_subf = subfields;\n+\t  type_p t;\n+\t  const char *subname;\n+\n+\t  switch (rtx_format[i][aindex])\n+\t    {\n+\t    case '*':\n+\t    case 'i':\n+\t    case 'n':\n+\t    case 'w':\n+\t      t = scalar_tp;\n+\t      subname = \"rtint\";\n+\t      break;\n+\n+\t    case '0':\n+\t      if (i == MEM && aindex == 1)\n+\t\tt = mem_attrs_tp, subname = \"rtmem\";\n+\t      else if (i == JUMP_INSN && aindex == 9)\n+\t\tt = rtx_tp, subname = \"rtx\";\n+\t      else if (i == CODE_LABEL && aindex == 4)\n+\t\tt = scalar_tp, subname = \"rtint\";\n+\t      else if (i == CODE_LABEL && aindex == 5)\n+\t\tt = rtx_tp, subname = \"rtx\";\n+\t      else if (i == LABEL_REF\n+\t\t       && (aindex == 1 || aindex == 2))\n+\t\tt = rtx_tp, subname = \"rtx\";\n+\t      else if (i == NOTE && aindex == 4)\n+\t\tt = note_union_tp, subname = \"\";\n+\t      else if (i == NOTE && aindex >= 7)\n+\t\tt = scalar_tp, subname = \"rtint\";\n+\t      else if (i == ADDR_DIFF_VEC && aindex == 4)\n+\t\tt = scalar_tp, subname = \"rtint\";\n+\t      else if (i == VALUE && aindex == 0)\n+\t\tt = scalar_tp, subname = \"rtint\";\n+\t      else if (i == REG && aindex == 1)\n+\t\tt = scalar_tp, subname = \"rtint\";\n+\t      else if (i == SCRATCH && aindex == 0)\n+\t\tt = scalar_tp, subname = \"rtint\";\n+\t      else if (i == BARRIER && aindex >= 3)\n+\t\tt = scalar_tp, subname = \"rtint\";\n+\t      else\n+\t\t{\n+\t\t  error_at_line (&lexer_line, \n+\t\t\t\"rtx type `%s' has `0' in position %d, can't handle\",\n+\t\t\t\t rtx_name[i], aindex);\n+\t\t  t = &string_type;\n+\t\t  subname = \"rtint\";\n+\t\t}\n+\t      break;\n+\t      \n+\t    case 's':\n+\t    case 'S':\n+\t    case 'T':\n+\t      t = &string_type;\n+\t      subname = \"rtstr\";\n+\t      break;\n+\n+\t    case 'e':\n+\t    case 'u':\n+\t      t = rtx_tp;\n+\t      subname = \"rtx\";\n+\t      break;\n+\n+\t    case 'E':\n+\t    case 'V':\n+\t      t = rtvec_tp;\n+\t      subname = \"rtvec\";\n+\t      break;\n+\n+\t    case 't':\n+\t      t = tree_tp;\n+\t      subname = \"rttree\";\n+\t      break;\n+\n+\t    case 'b':\n+\t      t = bitmap_tp;\n+\t      subname = \"rtbit\";\n+\t      break;\n+\n+\t    case 'B':\n+\t      t = basic_block_tp;\n+\t      subname = \"bb\";\n+\t      break;\n+\n+\t    default:\n+\t      error_at_line (&lexer_line, \n+\t\t     \"rtx type `%s' has `%c' in position %d, can't handle\",\n+\t\t\t     rtx_name[i], rtx_format[i][aindex],\n+\t\t\t     aindex);\n+\t      t = &string_type;\n+\t      subname = \"rtint\";\n+\t      break;\n+\t    }\n+\n+\t  subfields = xmalloc (sizeof (*subfields));\n+\t  subfields->next = old_subf;\n+\t  subfields->type = t;\n+\t  subfields->name = xasprintf (\"[%d].%s\", aindex, subname);\n+\t  subfields->line.file = __FILE__;\n+\t  subfields->line.line = __LINE__;\n+\t  if (t == note_union_tp)\n+\t    {\n+\t      subfields->opt = xmalloc (sizeof (*subfields->opt));\n+\t      subfields->opt->next = nodot;\n+\t      subfields->opt->name = \"desc\";\n+\t      subfields->opt->info = \"NOTE_LINE_NUMBER (&%0)\";\n+\t    }\n+\t  else if (t == basic_block_tp)\n+\t    {\n+\t      /* We don't presently GC basic block structures... */\n+\t      subfields->opt = xmalloc (sizeof (*subfields->opt));\n+\t      subfields->opt->next = nodot;\n+\t      subfields->opt->name = \"skip\";\n+\t      subfields->opt->info = NULL;\n+\t    }\n+\t  else if ((size_t) rtx_next[i] == aindex)\n+\t    {\n+\t      /* The 'next' field will be marked by the chain_next option.  */\n+\t      subfields->opt = xmalloc (sizeof (*subfields->opt));\n+\t      subfields->opt->next = nodot;\n+\t      subfields->opt->name = \"skip\";\n+\t      subfields->opt->info = NULL;\n+\t    }\n+\t  else\n+\t    subfields->opt = nodot;\n+\t}\n+\n+      flds = xmalloc (sizeof (*flds));\n+      flds->next = old_flds;\n+      flds->name = \"\";\n+      sname = xasprintf (\"rtx_def_%s\", rtx_name[i]);\n+      new_structure (sname, 0, &lexer_line, subfields, NULL);\n+      flds->type = find_structure (sname, 0);\n+      flds->line.file = __FILE__;\n+      flds->line.line = __LINE__;\n+      flds->opt = xmalloc (sizeof (*flds->opt));\n+      flds->opt->next = nodot;\n+      flds->opt->name = \"tag\";\n+      ftag = xstrdup (rtx_name[i]);\n+      for (nmindex = 0; nmindex < strlen (ftag); nmindex++)\n+\tftag[nmindex] = TOUPPER (ftag[nmindex]);\n+      flds->opt->info = ftag;\n+    }\n+\n+  new_structure (\"rtx_def_subunion\", 1, &lexer_line, flds, nodot);\n+  return find_structure (\"rtx_def_subunion\", 1);\n+}\n+\n+/* Handle `special(\"tree_exp\")'.  This is a special case for\n+   field `operands' of struct tree_exp, which although it claims to contain\n+   pointers to trees, actually sometimes contains pointers to RTL too.  \n+   Passed T, the old type of the field, and OPT its options.  Returns\n+   a new type for the field.  */\n+\n+static type_p\n+adjust_field_tree_exp (t, opt)\n+     type_p t;\n+     options_p opt ATTRIBUTE_UNUSED;\n+{\n+  pair_p flds;\n+  options_p nodot;\n+  size_t i;\n+  static const struct {\n+    const char *name;\n+    int first_rtl;\n+    int num_rtl;\n+  } data[] = {\n+    { \"SAVE_EXPR\", 2, 1 },\n+    { \"GOTO_SUBROUTINE_EXPR\", 0, 2 },\n+    { \"RTL_EXPR\", 0, 2 },\n+    { \"WITH_CLEANUP_EXPR\", 2, 1 },\n+    { \"METHOD_CALL_EXPR\", 3, 1 }\n+  };\n+  \n+  if (t->kind != TYPE_ARRAY)\n+    {\n+      error_at_line (&lexer_line, \n+\t\t     \"special `tree_exp' must be applied to an array\");\n+      return &string_type;\n+    }\n+  \n+  nodot = xmalloc (sizeof (*nodot));\n+  nodot->next = NULL;\n+  nodot->name = \"dot\";\n+  nodot->info = \"\";\n+\n+  flds = xmalloc (sizeof (*flds));\n+  flds->next = NULL;\n+  flds->name = \"\";\n+  flds->type = t;\n+  flds->line.file = __FILE__;\n+  flds->line.line = __LINE__;\n+  flds->opt = xmalloc (sizeof (*flds->opt));\n+  flds->opt->next = nodot;\n+  flds->opt->name = \"length\";\n+  flds->opt->info = \"TREE_CODE_LENGTH (TREE_CODE ((tree) &%0))\";\n+  {\n+    options_p oldopt = flds->opt;\n+    flds->opt = xmalloc (sizeof (*flds->opt));\n+    flds->opt->next = oldopt;\n+    flds->opt->name = \"default\";\n+    flds->opt->info = \"\";\n+  }\n+  \n+  for (i = 0; i < ARRAY_SIZE (data); i++)\n+    {\n+      pair_p old_flds = flds;\n+      pair_p subfields = NULL;\n+      int r_index;\n+      const char *sname;\n+      \n+      for (r_index = 0; \n+\t   r_index < data[i].first_rtl + data[i].num_rtl; \n+\t   r_index++)\n+\t{\n+\t  pair_p old_subf = subfields;\n+\t  subfields = xmalloc (sizeof (*subfields));\n+\t  subfields->next = old_subf;\n+\t  subfields->name = xasprintf (\"[%d]\", r_index);\n+\t  if (r_index < data[i].first_rtl)\n+\t    subfields->type = t->u.a.p;\n+\t  else\n+\t    subfields->type = create_pointer (find_structure (\"rtx_def\", 0));\n+\t  subfields->line.file = __FILE__;\n+\t  subfields->line.line = __LINE__;\n+\t  subfields->opt = nodot;\n+\t}\n+\n+      flds = xmalloc (sizeof (*flds));\n+      flds->next = old_flds;\n+      flds->name = \"\";\n+      sname = xasprintf (\"tree_exp_%s\", data[i].name);\n+      new_structure (sname, 0, &lexer_line, subfields, NULL);\n+      flds->type = find_structure (sname, 0);\n+      flds->line.file = __FILE__;\n+      flds->line.line = __LINE__;\n+      flds->opt = xmalloc (sizeof (*flds->opt));\n+      flds->opt->next = nodot;\n+      flds->opt->name = \"tag\";\n+      flds->opt->info = data[i].name;\n+    }\n+\n+  new_structure (\"tree_exp_subunion\", 1, &lexer_line, flds, nodot);\n+  return find_structure (\"tree_exp_subunion\", 1);\n+}\n+\n /* Perform any special processing on a type T, about to become the type\n    of a field.  Return the appropriate type for the field.\n    At present:\n    - Converts pointer-to-char, with no length parameter, to TYPE_STRING;\n    - Similarly for arrays of pointer-to-char;\n    - Converts structures for which a parameter is provided to\n-   TYPE_PARAM_STRUCT.\n+     TYPE_PARAM_STRUCT;\n+   - Handles \"special\" options.\n */   \n \n type_p\n@@ -296,30 +748,61 @@ adjust_field_type (t, opt)\n {\n   int length_p = 0;\n   const int pointer_p = t->kind == TYPE_POINTER;\n+  type_p params[NUM_PARAM];\n+  int params_p = 0;\n+  int i;\n+\n+  for (i = 0; i < NUM_PARAM; i++)\n+    params[i] = NULL;\n   \n   for (; opt; opt = opt->next)\n     if (strcmp (opt->name, \"length\") == 0)\n       length_p = 1;\n-    else if (strcmp (opt->name, \"param_is\") == 0)\n+    else if (strcmp (opt->name, \"param_is\") == 0\n+\t     || (strncmp (opt->name, \"param\", 5) == 0\n+\t\t && ISDIGIT (opt->name[5])\n+\t\t && strcmp (opt->name + 6, \"_is\") == 0))\n       {\n-\ttype_p realt;\n+\tint num = ISDIGIT (opt->name[5]) ? opt->name[5] - '0' : 0;\n \n-\tif (pointer_p)\n-\t  t = t->u.p;\n-\t\n-\tfor (realt = param_structs; realt; realt = realt->next)\n-\t  if (realt->u.param_struct.stru == t\n-\t      && realt->u.param_struct.param == (type_p) opt->info)\n-\t    return pointer_p ? create_pointer (realt) : realt;\n-\trealt = xcalloc (1, sizeof (*realt));\n-\trealt->kind = TYPE_PARAM_STRUCT;\n-\trealt->next = param_structs;\n-\tparam_structs = realt;\n-\trealt->u.param_struct.stru = t;\n-\trealt->u.param_struct.param = (type_p) opt->info;\n-\treturn pointer_p ? create_pointer (realt) : realt;\n+\tif (! UNION_OR_STRUCT_P (t)\n+\t    && (t->kind != TYPE_POINTER || ! UNION_OR_STRUCT_P (t->u.p)))\n+\t  {\n+\t    error_at_line (&lexer_line, \n+   \"option `%s' may only be applied to structures or structure pointers\",\n+\t\t\t   opt->name);\n+\t    return t;\n+\t  }\n+\n+\tparams_p = 1;\n+\tif (params[num] != NULL)\n+\t  error_at_line (&lexer_line, \"duplicate `%s' option\", opt->name);\n+\tif (! ISDIGIT (opt->name[5]))\n+\t  params[num] = create_pointer ((type_p) opt->info);\n+\telse\n+\t  params[num] = (type_p) opt->info;\n       }\n-  \n+    else if (strcmp (opt->name, \"special\") == 0)\n+      {\n+\tconst char *special_name = (const char *)opt->info;\n+\tif (strcmp (special_name, \"tree_exp\") == 0)\n+\t  t = adjust_field_tree_exp (t, opt);\n+\telse if (strcmp (special_name, \"rtx_def\") == 0)\n+\t  t = adjust_field_rtx_def (t, opt);\n+\telse\n+\t  error_at_line (&lexer_line, \"unknown special `%s'\", special_name);\n+      }\n+\n+  if (params_p)\n+    {\n+      type_p realt;\n+      \n+      if (pointer_p)\n+\tt = t->u.p;\n+      realt = find_param_structure (t, params);\n+      t = pointer_p ? create_pointer (realt) : realt;\n+    }\n+\n   if (! length_p\n       && pointer_p\n       && t->u.p->kind == TYPE_SCALAR\n@@ -335,26 +818,6 @@ adjust_field_type (t, opt)\n   return t;\n }\n \n-/* Add a variable named S of type T with options O defined at POS,\n-   to `variables'.  */\n-\n-void\n-note_variable (s, t, o, pos)\n-     const char *s;\n-     type_p t;\n-     options_p o;\n-     struct fileloc *pos;\n-{\n-  pair_p n;\n-  n = xmalloc (sizeof (*n));\n-  n->name = s;\n-  n->type = t;\n-  n->line = *pos;\n-  n->opt = o;\n-  n->next = variables;\n-  variables = n;\n-}\n-\n /* Create a union for YYSTYPE, as yacc would do it, given a fieldlist FIELDS\n    and information about the correspondance between token types and fields\n    in TYPEINFO.  POS is used for error messages.  */\n@@ -419,36 +882,44 @@ note_yacc_type (o, fields, typeinfo, pos)\n   do_typedef (\"YYSTYPE\", find_structure (\"yy_union\", 1), pos);\n }\n \f\n-static void process_gc_options PARAMS ((options_p, enum gc_used_enum, int *));\n-static void set_gc_used_type PARAMS ((type_p, enum gc_used_enum));\n+static void process_gc_options PARAMS ((options_p, enum gc_used_enum, \n+\t\t\t\t\tint *, int *, int *));\n+static void set_gc_used_type PARAMS ((type_p, enum gc_used_enum, type_p *));\n static void set_gc_used PARAMS ((pair_p));\n \n /* Handle OPT for set_gc_used_type.  */\n \n static void\n-process_gc_options (opt, level, maybe_undef)\n+process_gc_options (opt, level, maybe_undef, pass_param, length)\n      options_p opt;\n      enum gc_used_enum level;\n      int *maybe_undef;\n+     int *pass_param;\n+     int *length;\n {\n   options_p o;\n   for (o = opt; o; o = o->next)\n     if (strcmp (o->name, \"ptr_alias\") == 0 && level == GC_POINTED_TO)\n-      set_gc_used_type ((type_p) o->info, GC_POINTED_TO);\n+      set_gc_used_type ((type_p) o->info, GC_POINTED_TO, NULL);\n     else if (strcmp (o->name, \"maybe_undef\") == 0)\n       *maybe_undef = 1;\n+    else if (strcmp (o->name, \"use_params\") == 0)\n+      *pass_param = 1;\n+    else if (strcmp (o->name, \"length\") == 0)\n+      *length = 1;\n }\n \n /* Set the gc_used field of T to LEVEL, and handle the types it references.  */\n \n static void\n-set_gc_used_type (t, level)\n+set_gc_used_type (t, level, param)\n      type_p t;\n      enum gc_used_enum level;\n+     type_p param[NUM_PARAM];\n {\n   if (t->gc_used >= level)\n     return;\n-\n+  \n   t->gc_used = level;\n \n   switch (t->kind)\n@@ -459,53 +930,72 @@ set_gc_used_type (t, level)\n \tpair_p f;\n \tint dummy;\n \n-\tprocess_gc_options (t->u.s.opt, level, &dummy);\n+\tprocess_gc_options (t->u.s.opt, level, &dummy, &dummy, &dummy);\n \n \tfor (f = t->u.s.fields; f; f = f->next)\n \t  {\n \t    int maybe_undef = 0;\n-\t    process_gc_options (t->u.s.opt, level, &maybe_undef);\n+\t    int pass_param = 0;\n+\t    int length = 0;\n+\t    process_gc_options (f->opt, level, &maybe_undef, &pass_param,\n+\t\t\t\t&length);\n \t    \n-\t    if (maybe_undef && f->type->kind == TYPE_POINTER)\n-\t      set_gc_used_type (f->type->u.p, GC_MAYBE_POINTED_TO);\n+\t    if (length && f->type->kind == TYPE_POINTER)\n+\t      set_gc_used_type (f->type->u.p, GC_USED, NULL);\n+\t    else if (maybe_undef && f->type->kind == TYPE_POINTER)\n+\t      set_gc_used_type (f->type->u.p, GC_MAYBE_POINTED_TO, NULL);\n+\t    else if (pass_param && f->type->kind == TYPE_POINTER && param)\n+\t      set_gc_used_type (find_param_structure (f->type->u.p, param),\n+\t\t\t\tGC_POINTED_TO, NULL);\n \t    else\n-\t      set_gc_used_type (f->type, GC_USED);\n+\t      set_gc_used_type (f->type, GC_USED, pass_param ? param : NULL);\n \t  }\n \tbreak;\n       }\n \n     case TYPE_POINTER:\n-      set_gc_used_type (t->u.p, GC_POINTED_TO);\n+      set_gc_used_type (t->u.p, GC_POINTED_TO, NULL);\n       break;\n \n     case TYPE_ARRAY:\n-      set_gc_used_type (t->u.a.p, GC_USED);\n+      set_gc_used_type (t->u.a.p, GC_USED, param);\n       break;\n       \n     case TYPE_LANG_STRUCT:\n       for (t = t->u.s.lang_struct; t; t = t->next)\n-\tset_gc_used_type (t, level);\n+\tset_gc_used_type (t, level, param);\n       break;\n \n     case TYPE_PARAM_STRUCT:\n-      set_gc_used_type (t->u.param_struct.param, GC_POINTED_TO);\n-      set_gc_used_type (t->u.param_struct.stru, GC_USED);\n+      {\n+\tint i;\n+\tfor (i = 0; i < NUM_PARAM; i++)\n+\t  if (t->u.param_struct.param[i] != 0)\n+\t    set_gc_used_type (t->u.param_struct.param[i], GC_USED, NULL);\n+      }\n+      if (t->u.param_struct.stru->gc_used == GC_POINTED_TO)\n+\tlevel = GC_POINTED_TO;\n+      else\n+\tlevel = GC_USED;\n+      t->u.param_struct.stru->gc_used = GC_UNUSED;\n+      set_gc_used_type (t->u.param_struct.stru, level, \n+\t\t\tt->u.param_struct.param);\n       break;\n \n     default:\n       break;\n     }\n }\n \n-/* Set the gc_used fileds of all the types pointed to by VARIABLES.  */\n+/* Set the gc_used fields of all the types pointed to by VARIABLES.  */\n \n static void\n set_gc_used (variables)\n      pair_p variables;\n {\n   pair_p p;\n   for (p = variables; p; p = p->next)\n-    set_gc_used_type (p->type, GC_USED);\n+    set_gc_used_type (p->type, GC_USED, NULL);\n }\n \f\n /* File mapping routines.  For each input file, there is one output .c file\n@@ -609,8 +1099,6 @@ oprintf VPARAMS ((outf_p o, const char *format, ...))\n \n /* Open the global header file and the language-specific header files.  */\n \n-static void open_base_files PARAMS((void));\n-\n static void\n open_base_files ()\n {\n@@ -626,7 +1114,7 @@ open_base_files ()\n   {\n     /* The order of files here matters very much.  */\n     static const char *const ifiles [] = {\n-      \"config.h\", \"system.h\", \"varray.h\", \"hashtab.h\",\n+      \"config.h\", \"system.h\", \"varray.h\", \"hashtab.h\", \"splay-tree.h\",\n       \"bitmap.h\", \"tree.h\", \"rtl.h\", \"function.h\", \"insn-config.h\",\n       \"expr.h\", \"hard-reg-set.h\", \"basic-block.h\", \"cselib.h\",\n       \"insn-addr.h\", \"ssa.h\", \"optabs.h\", \"libfuncs.h\",\n@@ -878,11 +1366,14 @@ struct flist {\n static void output_escaped_param PARAMS ((outf_p , const char *, const char *,\n \t\t\t\t\t  const char *, const char *,\n \t\t\t\t\t  struct fileloc *));\n+static void output_mangled_typename PARAMS ((outf_p, type_p));\n static void write_gc_structure_fields \n   PARAMS ((outf_p , type_p, const char *, const char *, options_p, \n-\t   int, struct fileloc *, lang_bitmap, type_p));\n-static void write_gc_marker_routine_for_structure PARAMS ((type_p, type_p));\n+\t   int, struct fileloc *, lang_bitmap, type_p *));\n+static void write_gc_marker_routine_for_structure PARAMS ((type_p, type_p, \n+\t\t\t\t\t\t\t   type_p *));\n static void write_gc_types PARAMS ((type_p structures, type_p param_structs));\n+static void write_enum_defn PARAMS ((type_p structures, type_p param_structs));\n static void put_mangled_filename PARAMS ((outf_p , const char *));\n static void finish_root_table PARAMS ((struct flist *flp, const char *pfx, \n \t\t\t\t       const char *tname, const char *lastname,\n@@ -911,15 +1402,70 @@ output_escaped_param (of, param, val, prev_val, oname, line)\n   for (p = param; *p; p++)\n     if (*p != '%')\n       oprintf (of, \"%c\", *p);\n-    else if (*++p == 'h')\n-      oprintf (of, \"(%s)\", val);\n-    else if (*p == '0')\n-      oprintf (of, \"(*x)\");\n-    else if (*p == '1')\n-      oprintf (of, \"(%s)\", prev_val);\n-    else\n-      error_at_line (line, \"`%s' option contains bad escape %c%c\",\n-\t\t     oname, '%', *p);\n+    else switch (*++p)\n+      {\n+      case 'h':\n+\toprintf (of, \"(%s)\", val);\n+\tbreak;\n+      case '0':\n+\toprintf (of, \"(*x)\");\n+\tbreak;\n+      case '1':\n+\toprintf (of, \"(%s)\", prev_val);\n+\tbreak;\n+      case 'a':\n+\t{\n+\t  const char *pp = val + strlen (val);\n+\t  while (pp[-1] == ']')\n+\t    while (*pp != '[')\n+\t      pp--;\n+\t  oprintf (of, \"%s\", pp);\n+\t}\n+\tbreak;\n+      default:\n+\terror_at_line (line, \"`%s' option contains bad escape %c%c\",\n+\t\t       oname, '%', *p);\n+      }\n+}\n+\n+/* Print a mangled name representing T to OF.  */\n+\n+static void\n+output_mangled_typename (of, t)\n+     outf_p of;\n+     type_p t;\n+{\n+  if (t == NULL)\n+    oprintf (of, \"Z\");\n+  else switch (t->kind)\n+    {\n+    case TYPE_POINTER:\n+      oprintf (of, \"P\");\n+      output_mangled_typename (of, t->u.p);\n+      break;\n+    case TYPE_SCALAR:\n+      oprintf (of, \"I\");\n+      break;\n+    case TYPE_STRING:\n+      oprintf (of, \"S\");\n+      break;\n+    case TYPE_STRUCT:\n+    case TYPE_UNION:\n+    case TYPE_LANG_STRUCT:\n+      oprintf (of, \"%d%s\", strlen (t->u.s.tag), t->u.s.tag);\n+      break;\n+    case TYPE_PARAM_STRUCT:\n+      {\n+\tint i;\n+\tfor (i = 0; i < NUM_PARAM; i++)\n+\t  if (t->u.param_struct.param[i] != NULL)\n+\t    output_mangled_typename (of, t->u.param_struct.param[i]);\n+\toutput_mangled_typename (of, t->u.param_struct.stru);\t\n+      }\n+      break;\n+    case TYPE_ARRAY:\n+      abort ();\n+    }\n }\n \n /* Write out code to OF which marks the fields of S.  VAL references\n@@ -940,10 +1486,10 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n      int indent;\n      struct fileloc *line;\n      lang_bitmap bitmap;\n-     type_p param;\n+     type_p * param;\n {\n   pair_p f;\n-  int tagcounter = -1;\n+  int seen_default = 0;\n \n   if (! s->u.s.line.file)\n     error_at_line (line, \"incomplete structure `%s'\", s->u.s.tag);\n@@ -958,7 +1504,6 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n       const char *tagexpr = NULL;\n       options_p oo;\n       \n-      tagcounter = ++gc_counter;\n       for (oo = opts; oo; oo = oo->next)\n \tif (strcmp (oo->name, \"desc\") == 0)\n \t  tagexpr = (const char *)oo->info;\n@@ -968,29 +1513,26 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t  error_at_line (line, \"missing `desc' option\");\n \t}\n \n-      oprintf (of, \"%*s{\\n\", indent, \"\");\n-      indent += 2;\n-      oprintf (of, \"%*sunsigned int tag%d = (\", indent, \"\", tagcounter);\n+      oprintf (of, \"%*sswitch (\", indent, \"\");\n       output_escaped_param (of, tagexpr, val, prev_val, \"desc\", line);\n-      oprintf (of, \");\\n\");\n+      oprintf (of, \")\\n\");\n+      indent += 2;\n+      oprintf (of, \"%*s{\\n\", indent, \"\");\n     }\n   \n   for (f = s->u.s.fields; f; f = f->next)\n     {\n       const char *tagid = NULL;\n       const char *length = NULL;\n-      const char *special = NULL;\n       int skip_p = 0;\n-      int always_p = 0;\n+      int default_p = 0;\n       int maybe_undef_p = 0;\n-      int use_param_p = 0;\n+      int use_param_num = -1;\n+      int use_params_p = 0;\n+      int needs_cast_p = 0;\n       options_p oo;\n       type_p t = f->type;\n-      \n-      if (t->kind == TYPE_SCALAR\n-\t  || (t->kind == TYPE_ARRAY \n-\t      && t->u.a.p->kind == TYPE_SCALAR))\n-\tcontinue;\n+      const char *dot = \".\";\n       \n       for (oo = f->opt; oo; oo = oo->next)\n \tif (strcmp (oo->name, \"length\") == 0)\n@@ -1000,62 +1542,88 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \telse if (strcmp (oo->name, \"tag\") == 0)\n \t  tagid = (const char *)oo->info;\n \telse if (strcmp (oo->name, \"special\") == 0)\n-\t  special = (const char *)oo->info;\n+\t  ;\n \telse if (strcmp (oo->name, \"skip\") == 0)\n \t  skip_p = 1;\n-\telse if (strcmp (oo->name, \"always\") == 0)\n-\t  always_p = 1;\n-\telse if (strcmp (oo->name, \"desc\") == 0 && UNION_P (t))\n+\telse if (strcmp (oo->name, \"default\") == 0)\n+\t  default_p = 1;\n+\telse if (strcmp (oo->name, \"desc\") == 0)\n \t  ;\n- \telse if (strcmp (oo->name, \"descbits\") == 0 && UNION_P (t))\n+ \telse if (strcmp (oo->name, \"descbits\") == 0)\n \t  ;\n  \telse if (strcmp (oo->name, \"param_is\") == 0)\n \t  ;\n-\telse if (strcmp (oo->name, \"use_param\") == 0)\n-\t  use_param_p = 1;\n+\telse if (strncmp (oo->name, \"use_param\", 9) == 0\n+\t\t && (oo->name[9] == '\\0' || ISDIGIT (oo->name[9])))\n+\t  use_param_num = oo->name[9] == '\\0' ? 0 : oo->name[9] - '0';\n+\telse if (strcmp (oo->name, \"use_params\") == 0)\n+\t  use_params_p = 1;\n+\telse if (strcmp (oo->name, \"dot\") == 0)\n+\t  dot = (const char *)oo->info;\n \telse\n \t  error_at_line (&f->line, \"unknown field option `%s'\\n\", oo->name);\n \n       if (skip_p)\n \tcontinue;\n+\n+      if (use_params_p)\n+\t{\n+\t  int pointer_p = t->kind == TYPE_POINTER;\n+\n+\t  if (pointer_p)\n+\t    t = t->u.p;\n+\t  t = find_param_structure (t, param);\n+\t  if (pointer_p)\n+\t    t = create_pointer (t);\n+\t}\n       \n-      if (use_param_p)\n+      if (use_param_num != -1)\n \t{\n-\t  if (param != NULL)\n+\t  if (param != NULL && param[use_param_num] != NULL)\n \t    {\n-\t      type_p t1;\n-\t      type_p nt = param;\n-\t      int arraycount = 0;\n+\t      type_p nt = param[use_param_num];\n \t      \n-\t      for (t1 = t; t->kind == TYPE_ARRAY; t = t->u.a.p)\n-\t\tarraycount++;\n-\t      for (; t->kind == TYPE_POINTER; t = t->u.p)\n-\t\tnt = create_pointer (nt);\n-\t      while (arraycount-- > 0)\n+\t      if (t->kind == TYPE_ARRAY)\n \t\tnt = create_array (nt, t->u.a.len);\n+\t      else if (length != NULL && t->kind == TYPE_POINTER)\n+\t\tnt = create_pointer (nt);\n+\t      needs_cast_p = (t->kind != TYPE_POINTER\n+\t\t\t      && nt->kind == TYPE_POINTER);\n \t      t = nt;\n \t    }\n-\t  else if (s->kind == TYPE_UNION && ! always_p && tagid)\n-\t    ;\n-\t  else\n+\t  else if (s->kind != TYPE_UNION)\n \t    error_at_line (&f->line, \"no parameter defined\");\n \t}\n \n+      if (t->kind == TYPE_SCALAR\n+\t  || (t->kind == TYPE_ARRAY \n+\t      && t->u.a.p->kind == TYPE_SCALAR))\n+\tcontinue;\n+      \n+      seen_default |= default_p;\n+\n       if (maybe_undef_p\n \t  && (t->kind != TYPE_POINTER\n \t      || t->u.p->kind != TYPE_STRUCT))\n \terror_at_line (&f->line, \n \t\t       \"field `%s' has invalid option `maybe_undef_p'\\n\",\n \t\t       f->name);\n-      if (s->kind == TYPE_UNION && ! always_p )\n+      if (s->kind == TYPE_UNION)\n \t{\n-\t  if (! tagid)\n+\t  if (tagid)\n+\t    {\n+\t      oprintf (of, \"%*scase %s:\\n\", indent, \"\", tagid);\n+\n+\t    }\n+\t  else if (default_p)\n+\t    {\n+\t      oprintf (of, \"%*sdefault:\\n\", indent, \"\");\n+\t    }\n+\t  else\n \t    {\n \t      error_at_line (&f->line, \"field `%s' has no tag\", f->name);\n \t      continue;\n \t    }\n-\t  oprintf (of, \"%*sif (tag%d == (%s)) {\\n\", indent, \"\", \n-\t\t   tagcounter, tagid);\n \t  indent += 2;\n \t}\n       \n@@ -1087,7 +1655,7 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t  {\n \t    char *newval;\n \n-\t    newval = xasprintf (\"%s.%s\", val, f->name);\n+\t    newval = xasprintf (\"%s%s%s\", val, dot, f->name);\n \t    write_gc_structure_fields (of, t, newval, val, f->opt, indent, \n \t\t\t\t       &f->line, bitmap, param);\n \t    free (newval);\n@@ -1099,36 +1667,39 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t    {\n \t      if (maybe_undef_p\n \t\t  && t->u.p->u.s.line.file == NULL)\n-\t\toprintf (of, \"%*sif (%s.%s) abort();\\n\", indent, \"\",\n-\t\t\t val, f->name);\n-\t      else if (UNION_OR_STRUCT_P (t->u.p))\n-\t\toprintf (of, \"%*sgt_ggc_m_%s (%s.%s);\\n\", indent, \"\", \n-\t\t\t t->u.p->u.s.tag, val, f->name);\n-\t      else if (t->u.p->kind == TYPE_PARAM_STRUCT)\n-\t\toprintf (of, \"%*sgt_ggc_mm_%d%s_%s (%s.%s);\\n\", indent, \"\",\n-\t\t\t (int) strlen (t->u.p->u.param_struct.param->u.s.tag),\n-\t\t\t t->u.p->u.param_struct.param->u.s.tag,\n-\t\t\t t->u.p->u.param_struct.stru->u.s.tag,\n-\t\t\t val, f->name);\n+\t\toprintf (of, \"%*sif (%s%s%s) abort();\\n\", indent, \"\",\n+\t\t\t val, dot, f->name);\n+\t      else if (UNION_OR_STRUCT_P (t->u.p)\n+\t\t       || t->u.p->kind == TYPE_PARAM_STRUCT)\n+\t\t{\n+\t\t  oprintf (of, \"%*sgt_ggc_m_\", indent, \"\");\n+\t\t  output_mangled_typename (of, t->u.p);\n+\t\t  oprintf (of, \" (\");\n+\t\t  if (needs_cast_p)\n+\t\t    oprintf (of, \"(%s %s *)\", \n+\t\t\t     UNION_P (t->u.p) ? \"union\" : \"struct\",\n+\t\t\t     t->u.p->u.s.tag);\n+\t\t  oprintf (of, \"%s%s%s);\\n\", val, dot, f->name);\n+\t\t}\n \t      else\n \t\terror_at_line (&f->line, \"field `%s' is pointer to scalar\",\n \t\t\t       f->name);\n \t      break;\n \t    }\n \t  else if (t->u.p->kind == TYPE_SCALAR\n \t\t   || t->u.p->kind == TYPE_STRING)\n-\t    oprintf (of, \"%*sggc_mark (%s.%s);\\n\", indent, \"\", \n-\t\t     val, f->name);\n+\t    oprintf (of, \"%*sggc_mark (%s%s%s);\\n\", indent, \"\", \n+\t\t     val, dot, f->name);\n \t  else\n \t    {\n \t      int loopcounter = ++gc_counter;\n \t      \n-\t      oprintf (of, \"%*sif (%s.%s != NULL) {\\n\", indent, \"\",\n-\t\t       val, f->name);\n+\t      oprintf (of, \"%*sif (%s%s%s != NULL) {\\n\", indent, \"\",\n+\t\t       val, dot, f->name);\n \t      indent += 2;\n \t      oprintf (of, \"%*ssize_t i%d;\\n\", indent, \"\", loopcounter);\n-\t      oprintf (of, \"%*sggc_set_mark (%s.%s);\\n\", indent, \"\", \n-\t\t       val, f->name);\n+\t      oprintf (of, \"%*sggc_set_mark (%s%s%s);\\n\", indent, \"\", \n+\t\t       val, dot, f->name);\n \t      oprintf (of, \"%*sfor (i%d = 0; i%d < (size_t)(\", indent, \"\", \n \t\t       loopcounter, loopcounter);\n \t      output_escaped_param (of, length, val, prev_val, \"length\", line);\n@@ -1141,7 +1712,7 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t\t  {\n \t\t    char *newval;\n \t\t    \n-\t\t    newval = xasprintf (\"%s.%s[i%d]\", val, f->name, \n+\t\t    newval = xasprintf (\"%s%s%s[i%d]\", val, dot, f->name, \n \t\t\t\t\tloopcounter);\n \t\t    write_gc_structure_fields (of, t->u.p, newval, val,\n \t\t\t\t\t       f->opt, indent, &f->line,\n@@ -1150,10 +1721,14 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t\t    break;\n \t\t  }\n \t\tcase TYPE_POINTER:\n-\t\t  if (UNION_OR_STRUCT_P (t->u.p->u.p))\n-\t\t    oprintf (of, \"%*sgt_ggc_m_%s (%s.%s[i%d]);\\n\", indent, \"\", \n-\t\t\t     t->u.p->u.p->u.s.tag, val, f->name,\n-\t\t\t     loopcounter);\n+\t\t  if (UNION_OR_STRUCT_P (t->u.p->u.p)\n+\t\t      || t->u.p->u.p->kind == TYPE_PARAM_STRUCT)\n+\t\t    {\n+\t\t      oprintf (of, \"%*sgt_ggc_m_\", indent, \"\");\n+\t\t      output_mangled_typename (of, t->u.p->u.p);\n+\t\t      oprintf (of, \" (%s%s%s[i%d]);\\n\", val, dot, f->name,\n+\t\t\t       loopcounter);\n+\t\t    }\n \t\t  else\n \t\t    error_at_line (&f->line, \n \t\t\t\t   \"field `%s' is array of pointer to scalar\",\n@@ -1195,17 +1770,6 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t    oprintf (of, \"%*s{\\n\", indent, \"\");\n \t    indent += 2;\n \n-\t    if (special != NULL && strcmp (special, \"tree_exp\") == 0)\n-\t      {\n-\t\toprintf (of, \"%*sconst size_t tree_exp_size = (\",\n-                         indent, \"\");\n-\t\toutput_escaped_param (of, length, val, prev_val,\n-\t\t\t\t      \"length\", line);\n-\t\toprintf (of, \");\\n\");\n-\n-\t\tlength = \"first_rtl_op (TREE_CODE ((tree)&%h))\";\n-\t      }\n-\n \t    for (ta = t, i = 0; ta->kind == TYPE_ARRAY; ta = ta->u.a.p, i++)\n \t      {\n \t\toprintf (of, \"%*ssize_t i%d_%d;\\n\", \n@@ -1230,11 +1794,12 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t      }\n \n \t    if (ta->kind == TYPE_POINTER\n-\t\t&& (ta->u.p->kind == TYPE_STRUCT\n-\t\t    || ta->u.p->kind == TYPE_UNION))\n+\t\t&& (UNION_OR_STRUCT_P (ta->u.p)\n+\t\t    || ta->u.p->kind == TYPE_PARAM_STRUCT))\n \t      {\n-\t\toprintf (of, \"%*sgt_ggc_m_%s (%s.%s\", \n-\t\t\t indent, \"\", ta->u.p->u.s.tag, val, f->name);\n+\t\toprintf (of, \"%*sgt_ggc_m_\", indent, \"\");\n+\t\toutput_mangled_typename (of, ta->u.p);\n+\t\toprintf (of, \" (%s%s%s\", val, dot, f->name);\n \t\tfor (ta = t, i = 0; \n \t\t     ta->kind == TYPE_ARRAY; \n \t\t     ta = ta->u.a.p, i++)\n@@ -1251,7 +1816,7 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t\t  len += sizeof (\"[i_]\") + 2*6;\n \t\t\n \t\tnewval = xmalloc (len);\n-\t\tsprintf (newval, \"%s.%s\", val, f->name);\n+\t\tsprintf (newval, \"%s%s%s\", val, dot, f->name);\n \t\tfor (ta = t, i = 0; \n \t\t     ta->kind == TYPE_ARRAY; \n \t\t     ta = ta->u.a.p, i++)\n@@ -1263,7 +1828,7 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t\tfree (newval);\n \t      }\n \t    else if (ta->kind == TYPE_POINTER && ta->u.p->kind == TYPE_SCALAR\n-\t\t     && use_param_p && param == NULL)\n+\t\t     && use_param_num != -1 && param == NULL)\n \t      oprintf (of, \"%*sabort();\\n\", indent, \"\");\n \t    else\n \t      error_at_line (&f->line, \n@@ -1275,16 +1840,6 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t\toprintf (of, \"%*s}\\n\", indent, \"\");\n \t      }\n \n-\t    if (special != NULL && strcmp (special, \"tree_exp\") == 0)\n-\t      {\n-\t\toprintf (of, \n-\t\t \"%*sfor (; i%d_0 < tree_exp_size; i%d_0++)\\n\",\n-\t\t\t indent, \"\", loopcounter, loopcounter);\n-\t\toprintf (of, \"%*s  gt_ggc_m_rtx_def (%s.%s[i%d_0]);\\n\",\n-\t\t\t indent, \"\", val, f->name, loopcounter);\n-\t\tspecial = NULL;\n-\t      }\n-\n \t    indent -= 2;\n \t    oprintf (of, \"%*s}\\n\", indent, \"\");\n \t    break;\n@@ -1297,55 +1852,118 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t  break;\n \t}\n       \n-      if (s->kind == TYPE_UNION && ! always_p )\n+      if (s->kind == TYPE_UNION)\n \t{\n+\t  oprintf (of, \"%*sbreak;\\n\", indent, \"\");\n \t  indent -= 2;\n-\t  oprintf (of, \"%*s}\\n\", indent, \"\");\n \t}\n-      if (special)\n-\terror_at_line (&f->line, \"unhandled special `%s'\", special);\n     }\n   if (s->kind == TYPE_UNION)\n     {\n-      indent -= 2;\n+      if (! seen_default)\n+\t{\n+\t  oprintf (of, \"%*sdefault:\\n\", indent, \"\");\n+\t  oprintf (of, \"%*s  break;\\n\", indent, \"\");\n+\t}\n       oprintf (of, \"%*s}\\n\", indent, \"\");\n+      indent -= 2;\n     }\n }\n \n /* Write out a marker routine for S.  PARAM is the parameter from an\n    enclosing PARAM_IS option.  */\n \n static void\n-write_gc_marker_routine_for_structure (s, param)\n+write_gc_marker_routine_for_structure (orig_s, s, param)\n+     type_p orig_s;\n      type_p s;\n-     type_p param;\n+     type_p * param;\n {\n   outf_p f;\n-  if (param == NULL)\n-    f = get_output_file_with_visibility (s->u.s.line.file);\n-  else\n-    f = get_output_file_with_visibility (param->u.s.line.file);\n+  const char *fn = s->u.s.line.file;\n+  int i;\n+  const char *chain_next = NULL;\n+  const char *chain_prev = NULL;\n+  options_p opt;\n+  \n+  /* This is a hack, and not the good kind either.  */\n+  for (i = NUM_PARAM - 1; i >= 0; i--)\n+    if (param && param[i] && param[i]->kind == TYPE_POINTER \n+\t&& UNION_OR_STRUCT_P (param[i]->u.p))\n+      fn = param[i]->u.p->u.s.line.file;\n+  \n+  f = get_output_file_with_visibility (fn);\n   \n-  oprintf (f, \"%c\", '\\n');\n+  for (opt = s->u.s.opt; opt; opt = opt->next)\n+    if (strcmp (opt->name, \"chain_next\") == 0)\n+      chain_next = (const char *) opt->info;\n+    else if (strcmp (opt->name, \"chain_prev\") == 0)\n+      chain_prev = (const char *) opt->info;\n+\n+  if (chain_prev != NULL && chain_next == NULL)\n+    error_at_line (&s->u.s.line, \"chain_prev without chain_next\");\n+\n+  oprintf (f, \"\\n\");\n   oprintf (f, \"void\\n\");\n   if (param == NULL)\n-    oprintf (f, \"gt_ggc_mx_%s (x_p)\\n\", s->u.s.tag);\n+    oprintf (f, \"gt_ggc_mx_%s\", s->u.s.tag);\n   else\n-    oprintf (f, \"gt_ggc_mm_%d%s_%s (x_p)\\n\", (int) strlen (param->u.s.tag),\n-\t     param->u.s.tag, s->u.s.tag);\n+    {\n+      oprintf (f, \"gt_ggc_m_\");\n+      output_mangled_typename (f, orig_s);\n+    }\n+  oprintf (f, \" (x_p)\\n\");\n   oprintf (f, \"      void *x_p;\\n\");\n   oprintf (f, \"{\\n\");\n-  oprintf (f, \"  %s %s * const x = (%s %s *)x_p;\\n\",\n+  oprintf (f, \"  %s %s * %sx = (%s %s *)x_p;\\n\",\n \t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n+\t   chain_next == NULL ? \"const \" : \"\",\n \t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n-  oprintf (f, \"  if (! ggc_test_and_set_mark (x))\\n\");\n-  oprintf (f, \"    return;\\n\");\n+  if (chain_next != NULL)\n+    oprintf (f, \"  %s %s * xlimit = x;\\n\",\n+\t     s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n+  if (chain_next == NULL)\n+    oprintf (f, \"  if (ggc_test_and_set_mark (x))\\n\");\n+  else\n+    {\n+      oprintf (f, \"  while (ggc_test_and_set_mark (xlimit))\\n\");\n+      oprintf (f, \"   xlimit = (\");\n+      output_escaped_param (f, chain_next, \"*xlimit\", \"*xlimit\", \n+\t\t\t    \"chain_next\", &s->u.s.line);\n+      oprintf (f, \");\\n\");\n+      if (chain_prev != NULL)\n+\t{\n+\t  oprintf (f, \"  if (x != xlimit)\\n\");\n+\t  oprintf (f, \"    for (;;)\\n\");\n+\t  oprintf (f, \"      {\\n\");\n+\t  oprintf (f, \"        %s %s * const xprev = (\",\n+\t\t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n+\t  output_escaped_param (f, chain_prev, \"*x\", \"*x\",\n+\t\t\t\t\"chain_prev\", &s->u.s.line);\n+\t  oprintf (f, \");\\n\");\n+\t  oprintf (f, \"        if (xprev == NULL) break;\\n\");\n+\t  oprintf (f, \"        x = xprev;\\n\");\n+\t  oprintf (f, \"        ggc_set_mark (xprev);\\n\");\n+\t  oprintf (f, \"      }\\n\");\n+\t}\n+      oprintf (f, \"  while (x != xlimit)\\n\");\n+    }\n+  oprintf (f, \"    {\\n\");\n   \n   gc_counter = 0;\n   write_gc_structure_fields (f, s, \"(*x)\", \"not valid postage\",\n-\t\t\t     s->u.s.opt, 2, &s->u.s.line, s->u.s.bitmap,\n+\t\t\t     s->u.s.opt, 6, &s->u.s.line, s->u.s.bitmap,\n \t\t\t     param);\n   \n+  if (chain_next != NULL)\n+    {\n+      oprintf (f, \"      x = (\");\n+      output_escaped_param (f, chain_next, \"*x\", \"*x\",\n+\t\t\t    \"chain_next\", &s->u.s.line);\n+      oprintf (f, \");\\n\");\n+    }\n+\n+  oprintf (f, \"  }\\n\");\n   oprintf (f, \"}\\n\");\n }\n \n@@ -1369,8 +1987,9 @@ write_gc_types (structures, param_structs)\n \t    && s->u.s.line.file == NULL)\n \t  continue;\n \n-\toprintf (header_file,\n-\t\t \"#define gt_ggc_m_%s(X) do { \\\\\\n\", s->u.s.tag);\n+\toprintf (header_file, \"#define gt_ggc_m_\");\n+\toutput_mangled_typename (header_file, s);\n+\toprintf (header_file, \"(X) do { \\\\\\n\");\n \toprintf (header_file,\n \t\t \"  if (X != NULL) gt_ggc_mx_%s (X);\\\\\\n\", s->u.s.tag);\n \toprintf (header_file,\n@@ -1410,31 +2029,22 @@ write_gc_types (structures, param_structs)\n \t  {\n \t    type_p ss;\n \t    for (ss = s->u.s.lang_struct; ss; ss = ss->next)\n-\t      write_gc_marker_routine_for_structure (ss, NULL);\n+\t      write_gc_marker_routine_for_structure (s, ss, NULL);\n \t  }\n \telse\n-\t  write_gc_marker_routine_for_structure (s, NULL);\n+\t  write_gc_marker_routine_for_structure (s, s, NULL);\n       }\n \n   for (s = param_structs; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO)\n       {\n-\ttype_p param = s->u.param_struct.param;\n+\ttype_p * param = s->u.param_struct.param;\n \ttype_p stru = s->u.param_struct.stru;\n \n-\tif (param->kind != TYPE_STRUCT && param->kind != TYPE_UNION\n-\t    && param->kind != TYPE_LANG_STRUCT)\n-\t  {\n-\t    error_at_line (&s->u.param_struct.line,\n-\t\t\t   \"unsupported parameter type\");\n-\t    continue;\n-\t  }\n-\t\n \t/* Declare the marker procedure.  */\n-\toprintf (header_file, \n-\t\t \"extern void gt_ggc_mm_%d%s_%s PARAMS ((void *));\\n\",\n-\t\t (int) strlen (param->u.s.tag), param->u.s.tag,\n-\t\t stru->u.s.tag);\n+\toprintf (header_file, \"extern void gt_ggc_m_\");\n+\toutput_mangled_typename (header_file, s);\n+\toprintf (header_file, \" PARAMS ((void *));\\n\");\n   \n \tif (stru->u.s.line.file == NULL)\n \t  {\n@@ -1447,13 +2057,48 @@ write_gc_types (structures, param_structs)\n \t  {\n \t    type_p ss;\n \t    for (ss = stru->u.s.lang_struct; ss; ss = ss->next)\n-\t      write_gc_marker_routine_for_structure (ss, param);\n+\t      write_gc_marker_routine_for_structure (s, ss, param);\n \t  }\n \telse\n-\t  write_gc_marker_routine_for_structure (stru, param);\n+\t  write_gc_marker_routine_for_structure (s, stru, param);\n+      }\n+}\n+\n+/* Write out the 'enum' definition for gt_types_enum.  */\n+\n+static void\n+write_enum_defn (structures, param_structs)\n+     type_p structures;\n+     type_p param_structs;\n+{\n+  type_p s;\n+  \n+  oprintf (header_file, \"\\n/* Enumeration of types known.  */\\n\");\n+  oprintf (header_file, \"enum gt_types_enum {\\n\");\n+  for (s = structures; s; s = s->next)\n+    if (s->gc_used == GC_POINTED_TO\n+\t|| s->gc_used == GC_MAYBE_POINTED_TO)\n+      {\n+\tif (s->gc_used == GC_MAYBE_POINTED_TO\n+\t    && s->u.s.line.file == NULL)\n+\t  continue;\n+\n+\toprintf (header_file, \" gt_ggc_e_\");\n+\toutput_mangled_typename (header_file, s);\n+\toprintf (header_file, \", \\n\");\n       }\n+  for (s = param_structs; s; s = s->next)\n+    if (s->gc_used == GC_POINTED_TO)\n+      {\n+\toprintf (header_file, \" gt_e_\");\n+\toutput_mangled_typename (header_file, s);\n+\toprintf (header_file, \", \\n\");\n+      }\n+  oprintf (header_file, \" gt_types_enum_last\\n\");\n+  oprintf (header_file, \"};\\n\");\n }\n \n+\n /* Mangle FN and print it to F.  */\n \n static void\n@@ -1540,7 +2185,7 @@ finish_root_table (flp, pfx, lastname, tname, name)\n       if (bitmap & 1)\n \t{\n \t  oprintf (base_files[fnum], \"  NULL\\n\");\n-\t  oprintf (base_files[fnum], \"};\\n\\n\");\n+\t  oprintf (base_files[fnum], \"};\\n\");\n \t}\n   }\n }\n@@ -1667,10 +2312,8 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n \t  }\n \telse if (! has_length && tp->kind == TYPE_PARAM_STRUCT)\n \t  {\n-\t    oprintf (f, \"    &gt_ggc_mm_%d%s_%s\",\n-\t\t     (int) strlen (tp->u.param_struct.param->u.s.tag),\n-\t\t     tp->u.param_struct.param->u.s.tag,\n-\t\t     tp->u.param_struct.stru->u.s.tag);\n+\t    oprintf (f, \"    &gt_ggc_m_\");\n+\t    output_mangled_typename (f, tp);\n \t  }\n \telse if (has_length\n \t\t && (tp->kind == TYPE_POINTER || UNION_OR_STRUCT_P (tp)))\n@@ -1724,6 +2367,10 @@ write_gc_roots (variables)\n \t  deletable_p = 1;\n \telse if (strcmp (o->name, \"param_is\") == 0)\n \t  ;\n+ \telse if (strncmp (o->name, \"param\", 5) == 0\n+\t\t && ISDIGIT (o->name[5])\n+\t\t && strcmp (o->name + 6, \"_is\") == 0)\n+\t  ;\n \telse if (strcmp (o->name, \"if_marked\") == 0)\n \t  ;\n \telse\n@@ -1768,15 +2415,18 @@ write_gc_roots (variables)\n \t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n \t      oprintf (f, \"  if (ggc_test_and_set_mark (x))\\n\");\n \t      oprintf (f, \"    for (i = 0; i < (%s); i++)\\n\", length);\n-\t      if (s->kind != TYPE_STRUCT && s->kind != TYPE_UNION)\n+\t      if (! UNION_OR_STRUCT_P (s)\n+\t\t  && ! s->kind == TYPE_PARAM_STRUCT)\n \t\t{\n \t\t  error_at_line (&v->line, \n \t\t\t\t \"global `%s' has unsupported ** type\",\n \t\t\t\t v->name);\n \t\t  continue;\n \t\t}\n \n-\t      oprintf (f, \"      gt_ggc_m_%s (x[i]);\\n\", s->u.s.tag);\n+\t      oprintf (f, \"      gt_ggc_m_\");\n+\t      output_mangled_typename (f, s);\n+\t      oprintf (f, \" (x[i]);\\n\");\n \t    }\n \t  else\n \t    {\n@@ -1906,7 +2556,7 @@ write_gc_roots (variables)\n \t  oprintf (f, \"[] = {\\n\");\n \t}\n       \n-      write_gc_root (f, v, create_pointer (v->type->u.p->u.param_struct.param),\n+      write_gc_root (f, v, v->type->u.p->u.param_struct.param[0],\n \t\t     v->name, length_p, &v->line, if_marked);\n     }\n   \n@@ -1925,20 +2575,19 @@ main(argc, argv)\n   static struct fileloc pos = { __FILE__, __LINE__ };\n   unsigned j;\n   \n+  gen_rtx_next ();\n+\n   srcdir_len = strlen (srcdir);\n \n-  do_typedef (\"CUMULATIVE_ARGS\",\n-\t      create_scalar_type (\"CUMULATIVE_ARGS\", \n-\t\t\t\t  strlen (\"CUMULATIVE_ARGS\")),\n-\t      &pos);\n-  do_typedef (\"REAL_VALUE_TYPE\",\n-\t      create_scalar_type (\"REAL_VALUE_TYPE\", \n-\t\t\t\t  strlen (\"REAL_VALUE_TYPE\")),\n-\t      &pos);\n+  do_scalar_typedef (\"CUMULATIVE_ARGS\", &pos);\n+  do_scalar_typedef (\"REAL_VALUE_TYPE\", &pos);\n+  do_scalar_typedef (\"uint8\", &pos);\n+  do_scalar_typedef (\"jword\", &pos);\n+  do_scalar_typedef (\"JCF_u2\", &pos);\n+\n   do_typedef (\"PTR\", create_pointer (create_scalar_type (\"void\",\n \t\t\t\t\t\t\t strlen (\"void\"))),\n \t      &pos);\n-\n   do_typedef (\"HARD_REG_SET\", create_array (\n \t      create_scalar_type (\"unsigned long\", strlen (\"unsigned long\")),\n \t      \"2\"), &pos);\n@@ -1965,8 +2614,10 @@ main(argc, argv)\n   set_gc_used (variables);\n \n   open_base_files ();\n+  write_enum_defn (structures, param_structs);\n   write_gc_types (structures, param_structs);\n   write_gc_roots (variables);\n+  write_rtx_next ();\n   close_output_files ();\n \n   return (hit_error != 0);"}, {"sha": "0c23d95f44a6c36b7548b0d7e0ce36aa5c26befa", "filename": "gcc/gengtype.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -41,7 +41,7 @@ enum typekind {\n typedef struct options {\n   struct options *next;\n   const char *name;\n-  void *info;\n+  const void *info;\n } *options_p;\n \n typedef struct pair *pair_p;\n@@ -57,6 +57,8 @@ struct pair {\n   options_p opt;\n };\n \n+#define NUM_PARAM 10\n+\n /* A description of a type.  */\n struct type {\n   enum typekind kind;\n@@ -85,7 +87,7 @@ struct type {\n     } a;\n     struct {\n       type_p stru;\n-      type_p param;\n+      type_p param[NUM_PARAM];\n       struct fileloc line;\n     } param_struct;\n   } u;"}, {"sha": "2674cec52a14565b09734ea0c663e3032e7052e5", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -34,7 +34,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Statistics about the allocation.  */\n static ggc_statistics *ggc_stats;\n \n-static void ggc_mark_rtx_children_1 PARAMS ((rtx));\n static int ggc_htab_delete PARAMS ((void **, void *));\n \n /* Maintain global roots that are preserved during GC.  */\n@@ -132,140 +131,6 @@ ggc_mark_roots ()\n \thtab_traverse (*cti->base, ggc_htab_delete, (PTR) cti);\n }\n \n-/* R had not been previously marked, but has now been marked via\n-   ggc_set_mark.  Now recurse and process the children.  */\n-\n-void\n-ggc_mark_rtx_children (r)\n-     rtx r;\n-{\n-  rtx i, last;\n-\n-  /* Special case the instruction chain.  This is a data structure whose\n-     chain length is potentially unbounded, and which contain references\n-     within the chain (e.g. label_ref and insn_list).  If do nothing here,\n-     we risk blowing the stack recursing through a long chain of insns.\n-\n-     Combat this by marking all of the instructions in the chain before\n-     marking the contents of those instructions.  */\n-\n-  switch (GET_CODE (r))\n-    {\n-    case INSN:\n-    case JUMP_INSN:\n-    case CALL_INSN:\n-    case NOTE:\n-    case CODE_LABEL:\n-    case BARRIER:\n-      for (i = NEXT_INSN (r); ; i = NEXT_INSN (i))\n-\tif (! ggc_test_and_set_mark (i))\n-\t  break;\n-      last = i;\n-\n-      for (i = NEXT_INSN (r); i != last; i = NEXT_INSN (i))\n-\tggc_mark_rtx_children_1 (i);\n-\n-    default:\n-      break;\n-    }\n-\n-  ggc_mark_rtx_children_1 (r);\n-}\n-\n-static void\n-ggc_mark_rtx_children_1 (r)\n-     rtx r;\n-{\n-  const char *fmt;\n-  int i;\n-  rtx next_rtx;\n-\n-  do\n-    {\n-      enum rtx_code code = GET_CODE (r);\n-      /* This gets set to a child rtx to eliminate tail recursion.  */\n-      next_rtx = NULL;\n-\n-      /* Collect statistics, if appropriate.  */\n-      if (ggc_stats)\n-\t{\n-\t  ++ggc_stats->num_rtxs[(int) code];\n-\t  ggc_stats->size_rtxs[(int) code] += ggc_get_size (r);\n-\t}\n-\n-      /* ??? If (some of) these are really pass-dependent info, do we\n-\t have any right poking our noses in?  */\n-      switch (code)\n-\t{\n-\tcase MEM:\n-\t  gt_ggc_m_mem_attrs (MEM_ATTRS (r));\n-\t  break;\n-\tcase JUMP_INSN:\n-\t  ggc_mark_rtx (JUMP_LABEL (r));\n-\t  break;\n-\tcase CODE_LABEL:\n-\t  ggc_mark_rtx (LABEL_REFS (r));\n-\t  break;\n-\tcase LABEL_REF:\n-\t  ggc_mark_rtx (LABEL_NEXTREF (r));\n-\t  ggc_mark_rtx (CONTAINING_INSN (r));\n-\t  break;\n-\tcase ADDRESSOF:\n-\t  ggc_mark_tree (ADDRESSOF_DECL (r));\n-\t  break;\n-\tcase NOTE:\n-\t  switch (NOTE_LINE_NUMBER (r))\n-\t    {\n-\t    case NOTE_INSN_EXPECTED_VALUE:\n-\t      ggc_mark_rtx (NOTE_EXPECTED_VALUE (r));\n-\t      break;\n-\n-\t    case NOTE_INSN_BLOCK_BEG:\n-\t    case NOTE_INSN_BLOCK_END:\n-\t      ggc_mark_tree (NOTE_BLOCK (r));\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      for (fmt = GET_RTX_FORMAT (GET_CODE (r)), i = 0; *fmt ; ++fmt, ++i)\n-\t{\n-\t  rtx exp;\n-\t  switch (*fmt)\n-\t    {\n-\t    case 'e': case 'u':\n-\t      exp = XEXP (r, i);\n-\t      if (ggc_test_and_set_mark (exp))\n-\t\t{\n-\t\t  if (next_rtx == NULL)\n-\t\t    next_rtx = exp;\n-\t\t  else\n-\t\t    ggc_mark_rtx_children (exp);\n-\t\t}\n-\t      break;\n-\t    case 'V': case 'E':\n-\t      gt_ggc_m_rtvec_def (XVEC (r, i));\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  while ((r = next_rtx) != NULL);\n-}\n-\n-/* Various adaptor functions.  */\n-void\n-gt_ggc_mx_rtx_def (x)\n-     void *x;\n-{\n-  ggc_mark_rtx((rtx)x);\n-}\n-\n /* Allocate a block of memory, then clear it.  */\n void *\n ggc_alloc_cleared (size)"}, {"sha": "b672cbecfaf86500814b3eb01893ded4b0b597cd", "filename": "gcc/ggc.h", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -1,5 +1,5 @@\n /* Garbage collection for the GNU compiler.\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -62,21 +62,13 @@ extern const struct ggc_cache_tab * const gt_ggc_cache_rtab[];\n \n extern void ggc_mark_roots\t\tPARAMS ((void));\n \n-extern void ggc_mark_rtx_children\tPARAMS ((struct rtx_def *));\n-\n /* If EXPR is not NULL and previously unmarked, mark it and evaluate\n    to true.  Otherwise evaluate to false.  */\n #define ggc_test_and_set_mark(EXPR) \\\n   ((EXPR) != NULL && ((void *) (EXPR)) != (void *) 1 && ! ggc_set_mark (EXPR))\n \n-#define ggc_mark_rtx(EXPR)                      \\\n-  do {                                          \\\n-    rtx const r__ = (EXPR);                     \\\n-    if (ggc_test_and_set_mark (r__))            \\\n-      ggc_mark_rtx_children (r__);              \\\n-  } while (0)\n-\n-#define ggc_mark_tree gt_ggc_m_tree_node\n+#define ggc_mark_rtx gt_ggc_m_7rtx_def\n+#define ggc_mark_tree gt_ggc_m_9tree_node\n \n #define ggc_mark(EXPR)\t\t\t\t\\\n   do {\t\t\t\t\t\t\\"}, {"sha": "e1eb6f145587c00bc7e83610366e944d02f0b583", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -1,3 +1,7 @@\n+2002-09-16  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* java-tree.h (union lang_tree_node): Add chain_next option.\n+\n 2002-09-16  Richard Henderson  <rth@redhat.com>\n \n \t* jcf-parse.c (get_constant): Runtime check for IEEE format;"}, {"sha": "324156d23369c6faf54970980c66809d5d4d5eaa", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -693,7 +693,8 @@ struct lang_identifier GTY(())\n \n /* The resulting tree type.  */\n union lang_tree_node \n-  GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\")))\n+  GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n+       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n {\n   union tree_node GTY ((tag (\"0\"), \n \t\t\tdesc (\"tree_node_structure (&%h)\"))) "}, {"sha": "292dcc351841df3590ca8eec081fbaad5581899a", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -186,6 +186,7 @@ const char * const rtx_format[NUM_RTX_CODE] = {\n      \"u\" a pointer to another insn\n          prints the uid of the insn.\n      \"b\" is a pointer to a bitmap header.\n+     \"B\" is a basic block pointer.\n      \"t\" is a tree pointer.  */\n \n #define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   FORMAT ,"}, {"sha": "0fd7e6775b9a3923aa595155ccc6717b4e05f7a3", "filename": "gcc/rtl.h", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -62,6 +62,8 @@ extern const char * const rtx_format[NUM_RTX_CODE];\n \n extern const char rtx_class[NUM_RTX_CODE];\n #define GET_RTX_CLASS(CODE)\t\t(rtx_class[(int) (CODE)])\n+\n+extern const unsigned char rtx_next[NUM_RTX_CODE];\n \f\n /* The flags and bitfields of an ADDR_DIFF_VEC.  BASE is the base label\n    relative to which the offsets are calculated, as explained in rtl.def.  */\n@@ -103,7 +105,7 @@ typedef struct mem_attrs GTY(())\n \n /* Common union for an element of an rtx.  */\n \n-typedef union rtunion_def\n+union rtunion_def\n {\n   HOST_WIDE_INT rtwint;\n   int rtint;\n@@ -118,11 +120,13 @@ typedef union rtunion_def\n   tree rttree;\n   struct basic_block_def *bb;\n   mem_attrs *rtmem;\n-} rtunion;\n+};\n+typedef union rtunion_def rtunion;\n \n /* RTL expression (\"rtx\").  */\n \n-struct rtx_def\n+struct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"), \n+\t\t    chain_prev (\"RTX_PREV (&%h)\")))\n {\n   /* The kind of expression this is.  */\n   ENUM_BITFIELD(rtx_code) code: 16;\n@@ -198,11 +202,29 @@ struct rtx_def\n   /* The first element of the operands of this rtx.\n      The number of operands and their types are controlled\n      by the `code' field, according to rtl.def.  */\n-  rtunion fld[1];\n+  rtunion GTY ((special (\"rtx_def\"),\n+\t\tdesc (\"GET_CODE (&%0)\"))) fld[1];\n };\n \n #define NULL_RTX (rtx) 0\n \n+/* The \"next\" and \"previous\" RTX, relative to this one.  */\n+\n+#define RTX_NEXT(X) (rtx_next[GET_CODE (X)] == 0 ? NULL\t\t\t\\\n+\t\t     : *(rtx *)(((char *)X) + rtx_next[GET_CODE (X)]))\n+\n+/* FIXME: the \"NEXT_INSN (PREV_INSN (X)) == X\" condition shouldn't be needed.\n+ */\n+#define RTX_PREV(X) ((GET_CODE (X) == INSN              \\\n+                      || GET_CODE (X) == CALL_INSN      \\\n+                      || GET_CODE (X) == JUMP_INSN      \\\n+                      || GET_CODE (X) == NOTE           \\\n+                      || GET_CODE (X) == BARRIER        \\\n+                      || GET_CODE (X) == CODE_LABEL)    \\\n+                     && PREV_INSN (X) != NULL           \\\n+                     && NEXT_INSN (PREV_INSN (X)) == X  \\\n+                     ? PREV_INSN (X) : NULL)\n+\n /* Define macros to access the `code' field of the rtx.  */\n \n #define GET_CODE(RTX)\t    ((enum rtx_code) (RTX)->code)"}, {"sha": "6eab3307c8cff9b55c816e4d746e267f014d80fc", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=36a5eadd1a18a55b7b2b585bb5eb3736ab68ba48", "patch": "@@ -889,7 +889,7 @@ struct tree_exp GTY(())\n   struct tree_common common;\n   int complexity;\n   tree GTY ((special (\"tree_exp\"), \n-\t     length (\"TREE_CODE_LENGTH (TREE_CODE ((tree) &%h))\"))) \n+\t     desc (\"TREE_CODE ((tree) &%0)\"))) \n     operands[1];\n };\n \f"}]}