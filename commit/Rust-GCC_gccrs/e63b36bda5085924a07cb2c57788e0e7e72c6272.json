{"sha": "e63b36bda5085924a07cb2c57788e0e7e72c6272", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYzYjM2YmRhNTA4NTkyNGEwN2NiMmM1Nzc4OGUwZTdlNzJjNjI3Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-04-15T08:59:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-04-15T08:59:12Z"}, "message": "utils.c (type_for_vector_element_p): New predicate.\n\n\t* gcc-interface/utils.c (type_for_vector_element_p): New predicate.\n\t(build_vector_type_for_size): New function.\n\t(build_vector_type_for_array): Likewise.\n\t(unchecked_convert): Build an intermediate vector type to convert\n\tfrom a generic array type to a vector type.\n\t(handle_vector_size_attribute): Reimplement.\n\t(handle_vector_type_attribute): Likewise.\n\nFrom-SVN: r209410", "tree": {"sha": "aea21531a57e6d5ba997f144b7a862cf0bed3289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aea21531a57e6d5ba997f144b7a862cf0bed3289"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e63b36bda5085924a07cb2c57788e0e7e72c6272", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63b36bda5085924a07cb2c57788e0e7e72c6272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e63b36bda5085924a07cb2c57788e0e7e72c6272", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63b36bda5085924a07cb2c57788e0e7e72c6272/comments", "author": null, "committer": null, "parents": [{"sha": "bd6a077a919f616121b641802c73de75587c99ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd6a077a919f616121b641802c73de75587c99ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd6a077a919f616121b641802c73de75587c99ff"}], "stats": {"total": 279, "additions": 157, "deletions": 122}, "files": [{"sha": "7f66b56fcf44cd676e92583bade88b00fb459824", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63b36bda5085924a07cb2c57788e0e7e72c6272/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63b36bda5085924a07cb2c57788e0e7e72c6272/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e63b36bda5085924a07cb2c57788e0e7e72c6272", "patch": "@@ -1,3 +1,13 @@\n+2014-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (type_for_vector_element_p): New predicate.\n+\t(build_vector_type_for_size): New function.\n+\t(build_vector_type_for_array): Likewise.\n+\t(unchecked_convert): Build an intermediate vector type to convert\n+\tfrom a generic array type to a vector type.\n+\t(handle_vector_size_attribute): Reimplement.\n+\t(handle_vector_type_attribute): Likewise.\n+\n 2014-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (prepend_one_attribute_pragma): Call"}, {"sha": "8172f5f9900c00cf25fc208d44b607c1be6b3056", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 118, "deletions": 122, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63b36bda5085924a07cb2c57788e0e7e72c6272/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63b36bda5085924a07cb2c57788e0e7e72c6272/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=e63b36bda5085924a07cb2c57788e0e7e72c6272", "patch": "@@ -3194,6 +3194,96 @@ build_template (tree template_type, tree array_type, tree expr)\n   return gnat_build_constructor (template_type, template_elts);\n }\n \f\n+/* Return true if TYPE is suitable for the element type of a vector.  */\n+\n+static bool\n+type_for_vector_element_p (tree type)\n+{\n+  enum machine_mode mode;\n+\n+  if (!INTEGRAL_TYPE_P (type)\n+      && !SCALAR_FLOAT_TYPE_P (type)\n+      && !FIXED_POINT_TYPE_P (type))\n+    return false;\n+\n+  mode = TYPE_MODE (type);\n+  if (GET_MODE_CLASS (mode) != MODE_INT\n+      && !SCALAR_FLOAT_MODE_P (mode)\n+      && !ALL_SCALAR_FIXED_POINT_MODE_P (mode))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return a vector type given the SIZE and the INNER_TYPE, or NULL_TREE if\n+   this is not possible.  If ATTRIBUTE is non-zero, we are processing the\n+   attribute declaration and want to issue error messages on failure.  */\n+\n+static tree\n+build_vector_type_for_size (tree inner_type, tree size, tree attribute)\n+{\n+  unsigned HOST_WIDE_INT size_int, inner_size_int;\n+  int nunits;\n+\n+  /* Silently punt on variable sizes.  We can't make vector types for them,\n+     need to ignore them on front-end generated subtypes of unconstrained\n+     base types, and this attribute is for binding implementors, not end\n+     users, so we should never get there from legitimate explicit uses.  */\n+  if (!tree_fits_uhwi_p (size))\n+    return NULL_TREE;\n+  size_int = tree_to_uhwi (size);\n+\n+  if (!type_for_vector_element_p (inner_type))\n+    {\n+      if (attribute)\n+\terror (\"invalid element type for attribute %qs\",\n+\t       IDENTIFIER_POINTER (attribute));\n+      return NULL_TREE;\n+    }\n+  inner_size_int = tree_to_uhwi (TYPE_SIZE_UNIT (inner_type));\n+\n+  if (size_int % inner_size_int)\n+    {\n+      if (attribute)\n+\terror (\"vector size not an integral multiple of component size\");\n+      return NULL_TREE;\n+    }\n+\n+  if (size_int == 0)\n+    {\n+      if (attribute)\n+\terror (\"zero vector size\");\n+      return NULL_TREE;\n+    }\n+\n+  nunits = size_int / inner_size_int;\n+  if (nunits & (nunits - 1))\n+    {\n+      if (attribute)\n+\terror (\"number of components of vector not a power of two\");\n+      return NULL_TREE;\n+    }\n+\n+  return build_vector_type (inner_type, nunits);\n+}\n+\n+/* Return a vector type whose representative array type is ARRAY_TYPE, or\n+   NULL_TREE if this is not possible.  If ATTRIBUTE is non-zero, we are\n+   processing the attribute and want to issue error messages on failure.  */\n+\n+static tree\n+build_vector_type_for_array (tree array_type, tree attribute)\n+{\n+  tree vector_type = build_vector_type_for_size (TREE_TYPE (array_type),\n+\t\t\t\t\t\t TYPE_SIZE_UNIT (array_type),\n+\t\t\t\t\t\t attribute);\n+  if (!vector_type)\n+    return NULL_TREE;\n+\n+  TYPE_REPRESENTATIVE_ARRAY (vector_type) = array_type;\n+  return vector_type;\n+}\n+\f\n /* Helper routine to make a descriptor field.  FIELD_LIST is the list of decls\n    being built; the new decl is chained on to the front of the list.  */\n \n@@ -5268,6 +5358,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n   tree etype = TREE_TYPE (expr);\n   enum tree_code ecode = TREE_CODE (etype);\n   enum tree_code code = TREE_CODE (type);\n+  tree tem;\n   int c;\n \n   /* If the expression is already of the right type, we are done.  */\n@@ -5414,6 +5505,18 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t\t\t\t       etype))\n     expr = convert (type, expr);\n \n+  /* And, if the array type is not the representative, we try to build an\n+     intermediate vector type of which the array type is the representative\n+     and to do the unchecked conversion between the vector types, in order\n+     to enable further simplifications in the middle-end.  */\n+  else if (code == VECTOR_TYPE\n+\t   && ecode == ARRAY_TYPE\n+\t   && (tem = build_vector_type_for_array (etype, NULL_TREE)))\n+    {\n+      expr = convert (tem, expr);\n+      return unchecked_convert (type, expr, notrunc_p);\n+    }\n+\n   /* If we are converting a CONSTRUCTOR to a more aligned RECORD_TYPE, bump\n      the alignment of the CONSTRUCTOR to speed up the copy operation.  */\n   else if (TREE_CODE (expr) == CONSTRUCTOR\n@@ -6310,81 +6413,31 @@ handle_type_generic_attribute (tree *node, tree ARG_UNUSED (name),\n \n static tree\n handle_vector_size_attribute (tree *node, tree name, tree args,\n-\t\t\t      int ARG_UNUSED (flags),\n-\t\t\t      bool *no_add_attrs)\n+\t\t\t      int ARG_UNUSED (flags), bool *no_add_attrs)\n {\n-  unsigned HOST_WIDE_INT vecsize, nunits;\n-  enum machine_mode orig_mode;\n-  tree type = *node, new_type, size;\n+  tree type = *node;\n+  tree vector_type;\n \n   *no_add_attrs = true;\n \n-  size = TREE_VALUE (args);\n-\n-  if (!tree_fits_uhwi_p (size))\n-    {\n-      warning (OPT_Wattributes, \"%qs attribute ignored\",\n-\t       IDENTIFIER_POINTER (name));\n-      return NULL_TREE;\n-    }\n-\n-  /* Get the vector size (in bytes).  */\n-  vecsize = tree_to_uhwi (size);\n-\n   /* We need to provide for vector pointers, vector arrays, and\n      functions returning vectors.  For example:\n \n        __attribute__((vector_size(16))) short *foo;\n \n      In this case, the mode is SI, but the type being modified is\n      HI, so we need to look further.  */\n-\n   while (POINTER_TYPE_P (type)\n \t || TREE_CODE (type) == FUNCTION_TYPE\n \t || TREE_CODE (type) == ARRAY_TYPE)\n     type = TREE_TYPE (type);\n \n-  /* Get the mode of the type being modified.  */\n-  orig_mode = TYPE_MODE (type);\n-\n-  if ((!INTEGRAL_TYPE_P (type)\n-       && !SCALAR_FLOAT_TYPE_P (type)\n-       && !FIXED_POINT_TYPE_P (type))\n-      || (!SCALAR_FLOAT_MODE_P (orig_mode)\n-\t  && GET_MODE_CLASS (orig_mode) != MODE_INT\n-\t  && !ALL_SCALAR_FIXED_POINT_MODE_P (orig_mode))\n-      || !tree_fits_uhwi_p (TYPE_SIZE_UNIT (type))\n-      || TREE_CODE (type) == BOOLEAN_TYPE)\n-    {\n-      error (\"invalid vector type for attribute %qs\",\n-\t     IDENTIFIER_POINTER (name));\n-      return NULL_TREE;\n-    }\n-\n-  if (vecsize % tree_to_uhwi (TYPE_SIZE_UNIT (type)))\n-    {\n-      error (\"vector size not an integral multiple of component size\");\n-      return NULL;\n-    }\n-\n-  if (vecsize == 0)\n-    {\n-      error (\"zero vector size\");\n-      return NULL;\n-    }\n-\n-  /* Calculate how many units fit in the vector.  */\n-  nunits = vecsize / tree_to_uhwi (TYPE_SIZE_UNIT (type));\n-  if (nunits & (nunits - 1))\n-    {\n-      error (\"number of components of the vector not a power of two\");\n-      return NULL_TREE;\n-    }\n-\n-  new_type = build_vector_type (type, nunits);\n+  vector_type = build_vector_type_for_size (type, TREE_VALUE (args), name);\n+  if (!vector_type)\n+    return NULL_TREE;\n \n   /* Build back pointers if needed.  */\n-  *node = reconstruct_complex_type (*node, new_type);\n+  *node = reconstruct_complex_type (*node, vector_type);\n \n   return NULL_TREE;\n }\n@@ -6394,83 +6447,26 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n \n static tree\n handle_vector_type_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n-\t\t\t      int ARG_UNUSED (flags),\n-\t\t\t      bool *no_add_attrs)\n+\t\t\t      int ARG_UNUSED (flags), bool *no_add_attrs)\n {\n-  /* Vector representative type and size.  */\n-  tree rep_type = *node;\n-  tree rep_size = TYPE_SIZE_UNIT (rep_type);\n-\n-  /* Vector size in bytes and number of units.  */\n-  unsigned HOST_WIDE_INT vec_bytes, vec_units;\n-\n-  /* Vector element type and mode.  */\n-  tree elem_type;\n-  enum machine_mode elem_mode;\n+  tree type = *node;\n+  tree vector_type;\n \n   *no_add_attrs = true;\n \n-  if (TREE_CODE (rep_type) != ARRAY_TYPE)\n+  if (TREE_CODE (type) != ARRAY_TYPE)\n     {\n       error (\"attribute %qs applies to array types only\",\n \t     IDENTIFIER_POINTER (name));\n       return NULL_TREE;\n     }\n \n-  /* Silently punt on variable sizes.  We can't make vector types for them,\n-     need to ignore them on front-end generated subtypes of unconstrained\n-     bases, and this attribute is for binding implementors, not end-users, so\n-     we should never get there from legitimate explicit uses.  */\n-\n-  if (!tree_fits_uhwi_p (rep_size))\n+  vector_type = build_vector_type_for_array (type, name);\n+  if (!vector_type)\n     return NULL_TREE;\n \n-  /* Get the element type/mode and check this is something we know\n-     how to make vectors of.  */\n-\n-  elem_type = TREE_TYPE (rep_type);\n-  elem_mode = TYPE_MODE (elem_type);\n-\n-  if ((!INTEGRAL_TYPE_P (elem_type)\n-       && !SCALAR_FLOAT_TYPE_P (elem_type)\n-       && !FIXED_POINT_TYPE_P (elem_type))\n-      || (!SCALAR_FLOAT_MODE_P (elem_mode)\n-\t  && GET_MODE_CLASS (elem_mode) != MODE_INT\n-\t  && !ALL_SCALAR_FIXED_POINT_MODE_P (elem_mode))\n-      || !tree_fits_uhwi_p (TYPE_SIZE_UNIT (elem_type)))\n-    {\n-      error (\"invalid element type for attribute %qs\",\n-\t     IDENTIFIER_POINTER (name));\n-      return NULL_TREE;\n-    }\n-\n-  /* Sanity check the vector size and element type consistency.  */\n-\n-  vec_bytes = tree_to_uhwi (rep_size);\n-\n-  if (vec_bytes % tree_to_uhwi (TYPE_SIZE_UNIT (elem_type)))\n-    {\n-      error (\"vector size not an integral multiple of component size\");\n-      return NULL;\n-    }\n-\n-  if (vec_bytes == 0)\n-    {\n-      error (\"zero vector size\");\n-      return NULL;\n-    }\n-\n-  vec_units = vec_bytes / tree_to_uhwi (TYPE_SIZE_UNIT (elem_type));\n-  if (vec_units & (vec_units - 1))\n-    {\n-      error (\"number of components of the vector not a power of two\");\n-      return NULL_TREE;\n-    }\n-\n-  /* Build the vector type and replace.  */\n-\n-  *node = build_vector_type (elem_type, vec_units);\n-  TYPE_REPRESENTATIVE_ARRAY (*node) = rep_type;\n+  TYPE_REPRESENTATIVE_ARRAY (vector_type) = type;\n+  *node = vector_type;\n \n   return NULL_TREE;\n }"}, {"sha": "a2645d84097964b1168bc287d509baf55864d9e5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63b36bda5085924a07cb2c57788e0e7e72c6272/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63b36bda5085924a07cb2c57788e0e7e72c6272/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e63b36bda5085924a07cb2c57788e0e7e72c6272", "patch": "@@ -1,3 +1,7 @@\n+2014-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/vect14.adb: New test.\n+\n 2014-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/vect12.ad[sb]: New test."}, {"sha": "adc6ff14b66c8ca20d7383e42710a844aa63a608", "filename": "gcc/testsuite/gnat.dg/vect14.adb", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63b36bda5085924a07cb2c57788e0e7e72c6272/gcc%2Ftestsuite%2Fgnat.dg%2Fvect14.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63b36bda5085924a07cb2c57788e0e7e72c6272/gcc%2Ftestsuite%2Fgnat.dg%2Fvect14.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect14.adb?ref=e63b36bda5085924a07cb2c57788e0e7e72c6272", "patch": "@@ -0,0 +1,25 @@\n+-- { dg-do compile { target i?86-*-* x86_64-*-* } }\n+-- { dg-options \"-fdump-tree-optimized\" }\n+\n+with Interfaces;\n+with Unchecked_Conversion;\n+\n+with GNAT.SSE.Vector_Types; use GNAT.SSE.Vector_Types;\n+\n+procedure Vect14 is\n+\n+  Msk1  : constant := 16#000FFAFFFFFFFB3F#;\n+  Msk2  : constant := 16#000FFDFFFC90FFFD#;\n+\n+  type Unsigned_64_Array_Type is array (1 .. 2) of Interfaces.Unsigned_64;\n+\n+  function Convert is new Unchecked_Conversion (Unsigned_64_Array_Type, M128i);\n+\n+  Sse2_Param_Mask : constant M128i := Convert ((Msk1, Msk2));\n+\n+begin\n+  null;\n+end;\n+\n+-- { dg-final { scan-tree-dump-not \"VIEW_CONVERT_EXPR\" \"optimized\" } }\n+-- { dg-final { cleanup-tree-dump \"optimized\" } }"}]}