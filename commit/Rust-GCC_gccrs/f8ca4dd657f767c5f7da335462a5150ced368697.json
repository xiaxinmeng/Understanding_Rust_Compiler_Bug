{"sha": "f8ca4dd657f767c5f7da335462a5150ced368697", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhjYTRkZDY1N2Y3NjdjNWY3ZGEzMzU0NjJhNTE1MGNlZDM2ODY5Nw==", "commit": {"author": {"name": "Dmitriy Anisimkov", "email": "anisimko@adacore.com", "date": "2020-01-23T09:05:58Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-05T12:17:50Z"}, "message": "[Ada] Optimize Normalize_Pathname\n\n2020-06-05  Dmitriy Anisimkov  <anisimko@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/s-os_lib.adb (Is_Dirsep): Moved from Build_Path to\n\tpackage level to reuse.\n\t(Normalize_Pathname.Final_Value): Reduce 2 'if' statements to\n\tone.\n\t(Normalize_Pathname.Fill_Directory): New procedure instead of\n\tfunction Get_Directory. Remove slash to backslash conversion and\n\tdrive letter uppercasing on Windows.", "tree": {"sha": "1cfdc77e150b2c8e5c15aacc18b9cbcacf4fa06e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cfdc77e150b2c8e5c15aacc18b9cbcacf4fa06e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8ca4dd657f767c5f7da335462a5150ced368697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ca4dd657f767c5f7da335462a5150ced368697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8ca4dd657f767c5f7da335462a5150ced368697", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ca4dd657f767c5f7da335462a5150ced368697/comments", "author": {"login": "anisimkov", "id": 15864134, "node_id": "MDQ6VXNlcjE1ODY0MTM0", "avatar_url": "https://avatars.githubusercontent.com/u/15864134?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anisimkov", "html_url": "https://github.com/anisimkov", "followers_url": "https://api.github.com/users/anisimkov/followers", "following_url": "https://api.github.com/users/anisimkov/following{/other_user}", "gists_url": "https://api.github.com/users/anisimkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/anisimkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anisimkov/subscriptions", "organizations_url": "https://api.github.com/users/anisimkov/orgs", "repos_url": "https://api.github.com/users/anisimkov/repos", "events_url": "https://api.github.com/users/anisimkov/events{/privacy}", "received_events_url": "https://api.github.com/users/anisimkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8e89a6de5d926701e0a68dba5ace9f27c33725a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8e89a6de5d926701e0a68dba5ace9f27c33725a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8e89a6de5d926701e0a68dba5ace9f27c33725a"}], "stats": {"total": 258, "additions": 136, "deletions": 122}, "files": [{"sha": "288325c895f77155204faedec8584fbd4121b0b7", "filename": "gcc/ada/libgnat/s-os_lib.adb", "status": "modified", "additions": 136, "deletions": 122, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ca4dd657f767c5f7da335462a5150ced368697/gcc%2Fada%2Flibgnat%2Fs-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ca4dd657f767c5f7da335462a5150ced368697/gcc%2Fada%2Flibgnat%2Fs-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-os_lib.adb?ref=f8ca4dd657f767c5f7da335462a5150ced368697", "patch": "@@ -63,6 +63,11 @@ package body System.OS_Lib is\n    --  Mode = 1 - copy time stamps and read/write/execute attributes\n    --  Mode = 2 - copy read/write/execute attributes\n \n+   function Is_Dirsep (C : Character) return Boolean;\n+   pragma Inline (Is_Dirsep);\n+   --  Returns True if C is a directory separator. On Windows we\n+   --  accept both \\ and / as a directory separator.\n+\n    On_Windows : constant Boolean := Directory_Separator = '\\';\n    --  An indication that we are on Windows. Used in Normalize_Pathname, to\n    --  deal with drive letters in the beginning of absolute paths.\n@@ -336,22 +341,6 @@ package body System.OS_Lib is\n       ----------------\n \n       function Build_Path (Dir : String; File : String) return String is\n-         function Is_Dirsep (C : Character) return Boolean;\n-         pragma Inline (Is_Dirsep);\n-         --  Returns True if C is a directory separator. On Windows we\n-         --  handle both styles of directory separator.\n-\n-         ---------------\n-         -- Is_Dirsep --\n-         ---------------\n-\n-         function Is_Dirsep (C : Character) return Boolean is\n-         begin\n-            return C = Directory_Separator or else C = '/';\n-         end Is_Dirsep;\n-\n-         --  Local variables\n-\n          Base_File_Ptr : Integer;\n          --  The base file name is File (Base_File_Ptr + 1 .. File'Last)\n \n@@ -1472,6 +1461,15 @@ package body System.OS_Lib is\n       return Is_Absolute_Path (Name'Address, Name'Length) /= 0;\n    end Is_Absolute_Path;\n \n+   ---------------\n+   -- Is_Dirsep --\n+   ---------------\n+\n+   function Is_Dirsep (C : Character) return Boolean is\n+   begin\n+      return C = Directory_Separator or else C = '/';\n+   end Is_Dirsep;\n+\n    ------------------\n    -- Is_Directory --\n    ------------------\n@@ -2085,17 +2083,61 @@ package body System.OS_Lib is\n \n       Fold_To_Lower_Case : constant Boolean :=\n                              not Case_Sensitive\n-                               and then Get_File_Names_Case_Sensitive = 0;\n+                                 and then Get_File_Names_Case_Sensitive = 0;\n+\n+      Cur_Dir_Len : Natural  := 0;\n+      End_Path    : Natural  := Name'Length;\n+      Last        : Positive := 1;\n+      Path_Buffer : String (1 .. End_Path + 2 * Max_Path + 4);\n+      --  We need to potentially store in this buffer the following elements:\n+      --  the path itself, the current directory if the path is relative,\n+      --  and additional fragments up to Max_Path in length in case\n+      --  there are any symlinks.\n \n       function Final_Value (S : String) return String;\n       --  Make final adjustment to the returned string. This function strips\n       --  trailing directory separators, and folds returned string to lower\n       --  case if required.\n \n-      function Get_Directory  (Dir : String) return String;\n-      --  If Dir is not empty, return it, adding a directory separator\n-      --  if not already present, otherwise return current working directory\n-      --  with terminating directory separator.\n+      procedure Fill_Directory (Drive_Only : Boolean := False);\n+      --  Fill Cur_Dir and Cur_Dir_Len with Directory and ending directory\n+      --  separator or with current directory if Directory is not defined.\n+      --  If Drive_Only is True takes only Drive letter with colon and\n+      --  directory separator from Directory parameter or from current\n+      --  directory if Directory parameter is empty.\n+\n+      function Is_With_Drive (Name : String) return Boolean;\n+      pragma Inline (Is_With_Drive);\n+      --  Returns True only if the Name is including a drive\n+      --  letter at start.\n+\n+      function Missed_Drive_Letter (Name : String) return Boolean;\n+      --  Missed drive letter at start of the normalized pathname\n+\n+      -------------------\n+      -- Is_With_Drive --\n+      -------------------\n+\n+      function Is_With_Drive (Name : String) return Boolean is\n+      begin\n+         return Name'Length > 1\n+           and then Name (Name'First + 1) = ':'\n+           and then (Name (Name'First) in 'a' .. 'z'\n+                     or else Name (Name'First) in 'A' .. 'Z');\n+      end Is_With_Drive;\n+\n+      -------------------------\n+      -- Missed_Drive_Letter --\n+      -------------------------\n+\n+      function Missed_Drive_Letter (Name : String) return Boolean is\n+      begin\n+         return On_Windows\n+           and then not Is_With_Drive (Name)\n+           and then (Name'Length < 2 -- not \\\\name case\n+                     or else Name (Name'First .. Name'First + 1)\n+                             /= Directory_Separator & Directory_Separator);\n+      end Missed_Drive_Letter;\n \n       -----------------\n       -- Final_Value --\n@@ -2116,22 +2158,14 @@ package body System.OS_Lib is\n \n          Last := S1'Last;\n \n-         if Last > 1\n-           and then (S1 (Last) = '/'\n-                       or else\n-                     S1 (Last) = Directory_Separator)\n-         then\n-            --  Special case for Windows: C:\\\n-\n-            if Last = 3\n+         if Last > 1 and then Is_Dirsep (S1 (Last))\n+           and then not\n+             (On_Windows -- Special case for Windows: C:\\\n+              and then Last = 3\n               and then S1 (1) /= Directory_Separator\n-              and then S1 (2) = ':'\n-            then\n-               null;\n-\n-            else\n-               Last := Last - 1;\n-            end if;\n+              and then S1 (2) = ':')\n+         then\n+            Last := Last - 1;\n          end if;\n \n          --  And ensure that there is a trailing directory separator if the\n@@ -2148,90 +2182,80 @@ package body System.OS_Lib is\n          end if;\n       end Final_Value;\n \n-      -------------------\n-      -- Get_Directory --\n-      -------------------\n+      --------------------\n+      -- Fill_Directory --\n+      --------------------\n \n-      function Get_Directory (Dir : String) return String is\n+      procedure Fill_Directory (Drive_Only : Boolean := False) is\n       begin\n-         --  Directory given, add directory separator if needed\n+         if Drive_Only and then Is_With_Drive (Directory) then\n+            Path_Buffer (1 .. 3) :=\n+              Directory (Directory'First .. Directory'First + 2);\n \n-         if Dir'Length > 0 then\n-            declare\n-               Result : String   :=\n-                          Normalize_Pathname\n-                            (Dir, \"\", Resolve_Links, Case_Sensitive)\n-                             & Directory_Separator;\n-               Last   : Positive := Result'Last - 1;\n+         elsif Directory = \"\"\n+           or else not Is_Absolute_Path (Directory)\n+           or else Missed_Drive_Letter (Directory)\n+         then\n+            --  Directory name not given or it is not absolute or without drive\n+            --  letter on Windows, get current directory.\n \n-            begin\n-               --  On Windows, change all '/' to '\\'\n-\n-               if On_Windows then\n-                  for J in Result'First .. Last - 1 loop\n-                     if Result (J) = '/' then\n-                        Result (J) := Directory_Separator;\n-                     end if;\n-                  end loop;\n-               end if;\n+            Cur_Dir_Len := Max_Path;\n \n-               --  Include additional directory separator, if needed\n+            Get_Current_Dir (Path_Buffer'Address, Cur_Dir_Len'Address);\n \n-               if Result (Last) /= Directory_Separator then\n-                  Last := Last + 1;\n-               end if;\n+            if Cur_Dir_Len = 0 then\n+               raise Program_Error;\n+            end if;\n \n-               return Result (Result'First .. Last);\n-            end;\n+            if not Resolve_Links then\n+               Last := Cur_Dir_Len;\n+            end if;\n \n-         --  Directory name not given, get current directory\n+            if not Drive_Only and then Directory /= \"\" then\n+               if On_Windows and then Is_Absolute_Path (Directory) then\n+                  --  Drive letter taken from current directory but directory\n+                  --  itself taken from Directory parameter.\n \n-         else\n-            declare\n-               Buffer   : String (1 .. Max_Path + 2);\n-               Path_Len : Natural := Max_Path;\n+                  Path_Buffer (3 .. Directory'Length + 2) := Directory;\n+                  Cur_Dir_Len := Directory'Length + 2;\n+                  Last := 3;\n \n-            begin\n-               Get_Current_Dir (Buffer'Address, Path_Len'Address);\n+               else\n+                  --  Append relative Directory to current directory\n \n-               if Path_Len = 0 then\n-                  raise Program_Error;\n+                  Path_Buffer\n+                    (Cur_Dir_Len + 1 .. Cur_Dir_Len + Directory'Length) :=\n+                    Directory;\n+                  Cur_Dir_Len := Cur_Dir_Len + Directory'Length;\n                end if;\n+            end if;\n \n-               if Buffer (Path_Len) /= Directory_Separator then\n-                  Path_Len := Path_Len + 1;\n-                  Buffer (Path_Len) := Directory_Separator;\n-               end if;\n+         elsif Directory'Length >= Path_Buffer'Length then\n+            raise Constraint_Error with \"Directory name to big\";\n+\n+         else\n+            Path_Buffer (1 .. Directory'Length) := Directory;\n+            Cur_Dir_Len := Directory'Length;\n+         end if;\n \n-               --  By default, the drive letter on Windows is in upper case\n+         if Drive_Only then\n+            --  When we need only drive letter from current directory on\n+            --  Windows\n \n-               if On_Windows\n-                 and then Path_Len >= 2\n-                 and then Buffer (2) = ':'\n-               then\n-                  System.Case_Util.To_Upper (Buffer (1 .. 1));\n-               end if;\n+            Cur_Dir_Len := 3;\n+            Last := Cur_Dir_Len;\n \n-               return Buffer (1 .. Path_Len);\n-            end;\n+         elsif not Is_Dirsep (Path_Buffer (Cur_Dir_Len)) then\n+            Cur_Dir_Len := Cur_Dir_Len + 1;\n+            Path_Buffer (Cur_Dir_Len) := Directory_Separator;\n          end if;\n-      end Get_Directory;\n+      end Fill_Directory;\n \n       --  Local variables\n \n       Max_Iterations : constant := 500;\n \n-      Cur_Dir     : constant String  := Get_Directory (Directory);\n-      Cur_Dir_Len : constant Natural := Cur_Dir'Length;\n-\n-      End_Path    : Natural := Name'Length;\n-      Last        : Positive := 1;\n       Link_Buffer : String (1 .. Max_Path + 2);\n-      Path_Buffer : String (1 .. End_Path + Cur_Dir_Len + Max_Path + 2);\n-      --  We need to potentially store in this buffer the following elements:\n-      --  the path itself, the current directory if the path is relative,\n-      --  and additional fragments up to Max_Path in length in case\n-      --  there are any symlinks.\n \n       Finish : Positive;\n       Start  : Positive;\n@@ -2247,14 +2271,23 @@ package body System.OS_Lib is\n       end if;\n \n       if Is_Absolute_Path (Name) then\n-         Path_Buffer (1 .. End_Path) := Name;\n+         if Missed_Drive_Letter (Name) then\n+            Fill_Directory (Drive_Only => True);\n+\n+            --  Take only drive letter part with colon\n+\n+            End_Path := End_Path + 2;\n+            Path_Buffer (3 .. End_Path) := Name;\n+\n+         else\n+            Path_Buffer (1 .. End_Path) := Name;\n+         end if;\n \n       else\n          --  If this is a relative pathname, prepend current directory\n-         Path_Buffer (1 .. Cur_Dir_Len) := Cur_Dir;\n+         Fill_Directory;\n          Path_Buffer (Cur_Dir_Len + 1 .. Cur_Dir_Len + End_Path) := Name;\n          End_Path := Cur_Dir_Len + End_Path;\n-         Last := Cur_Dir_Len;\n       end if;\n \n       --  Special handling for Windows:\n@@ -2271,30 +2304,11 @@ package body System.OS_Lib is\n             end if;\n          end loop;\n \n-         --  If we have an absolute path starting with a directory\n-         --  separator (but not a UNC path), we need to have the drive letter\n-         --  in front of the path. Get_Current_Dir returns a path starting\n-         --  with a drive letter. So we take this drive letter and prepend it\n-         --  to the current path.\n+         --  Ensure drive letter is upper-case\n \n-         if Path_Buffer (1) = Directory_Separator\n-           and then Path_Buffer (2) /= Directory_Separator\n-         then\n-            if Cur_Dir'Length > 2\n-              and then Cur_Dir (Cur_Dir'First + 1) = ':'\n-            then\n-               Path_Buffer (3 .. End_Path + 2) :=\n-                 Path_Buffer (1 .. End_Path);\n-               Path_Buffer (1 .. 2) :=\n-                 Cur_Dir (Cur_Dir'First .. Cur_Dir'First + 1);\n-               End_Path := End_Path + 2;\n-            end if;\n+         pragma Assert (Path_Buffer (2) = ':');\n \n-         --  We have a drive letter already, ensure it is upper-case\n-\n-         elsif Path_Buffer (1) in 'a' .. 'z'\n-           and then Path_Buffer (2) = ':'\n-         then\n+         if Path_Buffer (1) in 'a' .. 'z' then\n             System.Case_Util.To_Upper (Path_Buffer (1 .. 1));\n          end if;\n "}]}