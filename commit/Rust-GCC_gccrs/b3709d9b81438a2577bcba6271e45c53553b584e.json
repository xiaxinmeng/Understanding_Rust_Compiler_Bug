{"sha": "b3709d9b81438a2577bcba6271e45c53553b584e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM3MDlkOWI4MTQzOGEyNTc3YmNiYTYyNzFlNDVjNTM1NTNiNTg0ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-03-23T23:08:59Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-03-23T23:08:59Z"}, "message": "decl.c (make_typename_type): Revert.\n\n\t* decl.c (make_typename_type): Revert.\n\t(make_implicit_typename): Remove.\n\t(lookup_name_real): Don't call it.  Call lookup_field if we see a\n\tTYPE_DECL from a template base.\n\t* search.c (lookup_field): Do implicit typename stuff.\n\nFrom-SVN: r18790", "tree": {"sha": "40624676d7892a98410a9386d3308df81752e208", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40624676d7892a98410a9386d3308df81752e208"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3709d9b81438a2577bcba6271e45c53553b584e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3709d9b81438a2577bcba6271e45c53553b584e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3709d9b81438a2577bcba6271e45c53553b584e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3709d9b81438a2577bcba6271e45c53553b584e/comments", "author": null, "committer": null, "parents": [{"sha": "bc289659328c9dc90c6870fae99ff83fc4d2d99b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc289659328c9dc90c6870fae99ff83fc4d2d99b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc289659328c9dc90c6870fae99ff83fc4d2d99b"}], "stats": {"total": 125, "additions": 35, "deletions": 90}, "files": [{"sha": "291ceabd208733e52d479124a98d0845fdeefc18", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3709d9b81438a2577bcba6271e45c53553b584e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3709d9b81438a2577bcba6271e45c53553b584e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b3709d9b81438a2577bcba6271e45c53553b584e", "patch": "@@ -1,3 +1,11 @@\n+Mon Mar 23 12:24:37 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (make_typename_type): Revert.\n+\t(make_implicit_typename): Remove.\n+\t(lookup_name_real): Don't call it.  Call lookup_field if we see a\n+\tTYPE_DECL from a template base.\n+\t* search.c (lookup_field): Do implicit typename stuff.\n+\n Sun Mar 22 00:50:42 1998  Nick Clifton  <nickc@cygnus.com>\n                           Geoff Noer    <noer@cygnus.com>\n "}, {"sha": "7f2df3f82805109fe3e2baa1cb22e2c9da27e147", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 68, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3709d9b81438a2577bcba6271e45c53553b584e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3709d9b81438a2577bcba6271e45c53553b584e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b3709d9b81438a2577bcba6271e45c53553b584e", "patch": "@@ -4555,14 +4555,6 @@ make_typename_type (context, name)\n \t      return error_mark_node;\n \t    }\n \n-\t  /* If this is really from a base that uses template parms,\n-\t     push the TYPENAME_TYPE down.  */\n-\t  if (processing_template_decl\n-\t      && context == current_class_type\n-\t      && DECL_CONTEXT (t) != context\n-\t      && uses_template_parms (DECL_CONTEXT (t)))\n-\t    return make_implicit_typename (context, t);\n-\n \t  return TREE_TYPE (t);\n \t}\n     }\n@@ -4584,49 +4576,6 @@ make_typename_type (context, name)\n   return t;\n }\n \n-/* Given a TYPE_DECL T looked up in CONTEXT, return a TYPENAME_TYPE\n-   where the scope is the first class along the inheritance chain to T\n-   that is not current_class_type.\n-\n-   Called from lookup_name_real to implement the implicit typename\n-   extension.  */\n-\n-static tree\n-make_implicit_typename (context, t)\n-     tree context, t;\n-{\n-  tree retval;\n-\n-  if (context == current_class_type)\n-    {\n-      tree binfos = TYPE_BINFO_BASETYPES (context);\n-      int n_baselinks = TREE_VEC_LENGTH (binfos);\n-      int i;\n-\n-      /* We can't use DECL_CONTEXT (t) to help us here, because it refers\n-\t to the uninstantiated template type that t comes from, which is\n-\t probably not a base of ours.  This happens because we don't\n-         actually do partial instantiation of types in\n-         instantiate_class_template.  */\n-\n-      for (i = 0; i < n_baselinks; ++i)\n-\t{\n-\t  tree basetype = BINFO_TYPE (TREE_VEC_ELT (binfos, i));\n-\t  if (lookup_field (basetype, DECL_NAME (t), 0, 1))\n-\t    {\n-\t      context = basetype;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  retval = make_typename_type (context, DECL_NAME (t));\n-\n-  if (TREE_CODE (retval) == TYPENAME_TYPE)\n-    TREE_TYPE (retval) = TREE_TYPE (t);\n-  return retval;\n-}\n-\n /* Look up NAME in the current binding level and its superiors in the\n    namespace of variables, functions and typedefs.  Return a ..._DECL\n    node of some kind representing its definition if there is only one\n@@ -4716,17 +4665,6 @@ lookup_name_real (name, prefer_type, nonclass)\n       else\n \tval = NULL_TREE;\n \n-      /* Add implicit 'typename' to scoped types from other classes.  */\n-      if (got_scope && processing_template_decl\n-\t  && got_scope != current_class_type\n-\t  && uses_template_parms (got_scope)\n-\t  && val && TREE_CODE (val) == TYPE_DECL\n-\t  && ! DECL_ARTIFICIAL (val))\n-\t{\n-\t  tree t = make_implicit_typename (got_scope, val);\n-\t  val = TYPE_MAIN_DECL (t);\n-\t}\n-\n       if (got_scope)\n \tgoto done;\n       else if (got_object && val)\n@@ -4756,16 +4694,14 @@ lookup_name_real (name, prefer_type, nonclass)\n       if (classval == NULL_TREE)\n \tclassval = lookup_nested_field (name, ! yylex);\n \n-      /* Add implicit 'typename' to types from base classes.  */\n+      /* Add implicit 'typename' to types from template bases.  lookup_field\n+         will do this for us.  */\n       if (processing_template_decl\n \t  && classval && TREE_CODE (classval) == TYPE_DECL\n \t  && DECL_CONTEXT (classval) != current_class_type\n-\t  && uses_template_parms (DECL_CONTEXT (classval))\n+\t  && uses_template_parms (current_class_type)\n \t  && ! DECL_ARTIFICIAL (classval))\n-\t{\n-\t  tree t = make_implicit_typename (current_class_type, classval);\n-\t  classval = TYPE_MAIN_DECL (t);\n-\t}\n+\tclassval = lookup_field (current_class_type, name, 0, 1);\n     }\n \n   if (locval && classval)"}, {"sha": "fe0a3a419662bb8e6e9ff5ed9af38b1f1ad85aa7", "filename": "gcc/cp/search.c", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3709d9b81438a2577bcba6271e45c53553b584e/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3709d9b81438a2577bcba6271e45c53553b584e/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=b3709d9b81438a2577bcba6271e45c53553b584e", "patch": "@@ -1304,28 +1304,8 @@ lookup_field (xbasetype, name, protect, want_type)\n \t    }\n \t}\n \n-      if (entry)\n-\t{\n-\t  if (errstr)\n-\t    {\n-\t      /* This depends on behavior of lookup_field_1!  */\n-\t      tree error_string = my_build_string (errstr);\n-\t      TREE_TYPE (entry) = error_string;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Let entry know there is no problem with this access.  */\n-\t      TREE_TYPE (entry) = NULL_TREE;\n-\t    }\n-\t  TREE_VALUE (entry) = rval;\n-\t}\n-\n-      if (errstr && protect)\n-\t{\n-\t  cp_error (errstr, name, type);\n-\t  return error_mark_node;\n-\t}\n-      return rval;\n+      rval_binfo = basetype_path;\n+      goto out;\n     }\n \n   basetype_chain = build_expr_list (NULL_TREE, basetype_path);\n@@ -1522,6 +1502,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \t    : \"member `%D' is from protected base class\";\n     }\n \n+ out:\n   if (entry)\n     {\n       if (errstr)\n@@ -1550,6 +1531,26 @@ lookup_field (xbasetype, name, protect, want_type)\n       cp_error (errstr, name, type);\n       rval = error_mark_node;\n     }\n+\n+  /* Do implicit typename stuff.  */\n+  if (rval && TREE_CODE (rval) == TYPE_DECL\n+      && ! DECL_ARTIFICIAL (rval)\n+      && processing_template_decl\n+      && BINFO_TYPE (rval_binfo) != current_class_type\n+      && uses_template_parms (type))\n+    {\n+      binfo = rval_binfo;\n+      for (; ; binfo = BINFO_INHERITANCE_CHAIN (binfo))\n+\tif (BINFO_INHERITANCE_CHAIN (binfo) == NULL_TREE\n+\t    || (BINFO_TYPE (BINFO_INHERITANCE_CHAIN (binfo))\n+\t\t== current_class_type))\n+\t  break;\n+\n+      entry = make_typename_type (BINFO_TYPE (binfo), name);\n+      TREE_TYPE (entry) = TREE_TYPE (rval);\n+      rval = TYPE_MAIN_DECL (entry);\n+    }\n+\n   return rval;\n }\n "}]}