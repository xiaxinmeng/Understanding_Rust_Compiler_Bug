{"sha": "4b97aaeb34b0e0dadbd2eced838111fd77b4c0dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI5N2FhZWIzNGIwZTBkYWRiZDJlY2VkODM4MTExZmQ3N2I0YzBkYw==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-04-01T17:02:51Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-04-01T17:02:51Z"}, "message": "c4x.md (ashlhi3, [...]): Force operand 1 into a register if shift count not constant.\n\n\t* config/c4x/c4x.md (ashlhi3, lshrhi3, ashrhi3): Force operand 1\n\tinto a register if shift count not constant.\n\t(ashlhi3_reg, lshrhi3_reg, ashrhi3_reg): Ensure that operand 1\n\tis a register.\n\nFrom-SVN: r26109", "tree": {"sha": "a4c904eee8e0704a31d9d9badd85dd038116c659", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4c904eee8e0704a31d9d9badd85dd038116c659"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b97aaeb34b0e0dadbd2eced838111fd77b4c0dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b97aaeb34b0e0dadbd2eced838111fd77b4c0dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b97aaeb34b0e0dadbd2eced838111fd77b4c0dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b97aaeb34b0e0dadbd2eced838111fd77b4c0dc/comments", "author": null, "committer": null, "parents": [{"sha": "8de858c039e88a7957458d6c21ec5545818d634d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de858c039e88a7957458d6c21ec5545818d634d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8de858c039e88a7957458d6c21ec5545818d634d"}], "stats": {"total": 33, "additions": 23, "deletions": 10}, "files": [{"sha": "e0e39a6f7305cd1ad3eb1313601a5bc18eb508fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b97aaeb34b0e0dadbd2eced838111fd77b4c0dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b97aaeb34b0e0dadbd2eced838111fd77b4c0dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b97aaeb34b0e0dadbd2eced838111fd77b4c0dc", "patch": "@@ -1,3 +1,10 @@\n+Fri Apr  2 12:58:26 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.md (ashlhi3, lshrhi3, ashrhi3): Force operand 1\n+\tinto a register if shift count not constant.\n+\t(ashlhi3_reg, lshrhi3_reg, ashrhi3_reg): Ensure that operand 1\n+\tis a register.\n+\n Fri Apr  2 12:19:17 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.md (*db): Enable pattern if TARGET_LOOP_UNSIGNED"}, {"sha": "ab96ddd57ddb9574128dee669d34ef7160429a0b", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b97aaeb34b0e0dadbd2eced838111fd77b4c0dc/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b97aaeb34b0e0dadbd2eced838111fd77b4c0dc/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=4b97aaeb34b0e0dadbd2eced838111fd77b4c0dc", "patch": "@@ -5791,7 +5791,6 @@\n    operands[7] = c4x_operand_subword (operands[1], 1, 1, HImode);\n    operands[8] = c4x_operand_subword (operands[2], 1, 1, HImode);\")\n \n-; This should do all the dirty work with define_split\n (define_expand \"ashlhi3\"\n  [(parallel [(set (match_operand:HI 0 \"reg_operand\" \"\")\n              (ashift:HI (match_operand:HI 1 \"src_operand\" \"\")\n@@ -5812,14 +5811,17 @@\n        emit_insn (gen_movqi (op0lo, const0_rtx));\n        DONE;\n     }\n-    emit_insn (gen_ashlhi3_reg (operands[0], operands[1], operands[2]));\n-    DONE;\")\n+  if (! REG_P (operands[1]))\n+    operands[1] = force_reg (HImode, operands[1]);\n+  emit_insn (gen_ashlhi3_reg (operands[0], operands[1], operands[2]));\n+  DONE;\n+ \")\n \n ; %0.lo = %1.lo << %2\n ; %0.hi = (%1.hi << %2 ) | (%1.lo >> (32 - %2))\n ; This algorithm should work for shift counts greater than 32\n (define_expand \"ashlhi3_reg\" \n- [(use (match_operand:HI 1 \"src_operand\" \"\"))\n+ [(use (match_operand:HI 1 \"reg_operand\" \"\"))\n   (use (match_operand:HI 0 \"reg_operand\" \"\"))\n   /* If the shift count is greater than 32 this will give zero.  */\n   (parallel [(set (match_dup 7)\n@@ -5874,14 +5876,16 @@\n        emit_insn (gen_movqi (op0hi, const0_rtx));\n        DONE;\n     }\n-    emit_insn (gen_lshrhi3_reg (operands[0], operands[1], operands[2]));\n-    DONE;\")\n+  if (! REG_P (operands[1]))\n+    operands[1] = force_reg (HImode, operands[1]);\n+  emit_insn (gen_lshrhi3_reg (operands[0], operands[1], operands[2]));\n+  DONE;\")\n \n ; %0.hi = %1.hi >> %2\n ; %0.lo = (%1.lo >> %2 ) | (%1.hi << (32 - %2))\n ; This algorithm should work for shift counts greater than 32\n (define_expand \"lshrhi3_reg\" \n- [(use (match_operand:HI 1 \"src_operand\" \"\"))\n+ [(use (match_operand:HI 1 \"reg_operand\" \"\"))\n   (use (match_operand:HI 0 \"reg_operand\" \"\"))\n   (parallel [(set (match_dup 11)\n                   (neg:QI (match_operand:QI 2 \"reg_operand\" \"\")))\n@@ -5942,14 +5946,16 @@\n        emit_insn (gen_ashrqi3 (op0hi, op1hi, GEN_INT (31)));\n        DONE;\n     }\n-    emit_insn (gen_ashrhi3_reg (operands[0], operands[1], operands[2]));\n-    DONE;\")\n+  if (! REG_P (operands[1]))\n+    operands[1] = force_reg (HImode, operands[1]);\n+  emit_insn (gen_ashrhi3_reg (operands[0], operands[1], operands[2]));\n+  DONE;\")\n \n ; %0.hi = %1.hi >> %2\n ; %0.lo = (%1.lo >> %2 ) | (%1.hi << (32 - %2))\n ; This algorithm should work for shift counts greater than 32\n (define_expand \"ashrhi3_reg\" \n- [(use (match_operand:HI 1 \"src_operand\" \"\"))\n+ [(use (match_operand:HI 1 \"reg_operand\" \"\"))\n   (use (match_operand:HI 0 \"reg_operand\" \"\"))\n   (parallel [(set (match_dup 11)\n                   (neg:QI (match_operand:QI 2 \"reg_operand\" \"\")))"}]}