{"sha": "31d7a8bd3d322870543d960e7f8e7b909d7e4950", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFkN2E4YmQzZDMyMjg3MDU0M2Q5NjBlN2Y4ZTdiOTA5ZDdlNDk1MA==", "commit": {"author": {"name": "Pat Rogers", "email": "rogers@adacore.com", "date": "2006-02-15T09:33:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:33:57Z"}, "message": "a-rttiev.adb, [...]: New files.\n\n2006-02-13  Pat Rogers  <rogers@adacore.com>\n\n\t* a-rttiev.adb, a-rttiev.ads: New files.\n\nFrom-SVN: r111040", "tree": {"sha": "34354464d6518e98e41a6f32161e69cb07a086d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34354464d6518e98e41a6f32161e69cb07a086d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31d7a8bd3d322870543d960e7f8e7b909d7e4950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31d7a8bd3d322870543d960e7f8e7b909d7e4950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31d7a8bd3d322870543d960e7f8e7b909d7e4950", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31d7a8bd3d322870543d960e7f8e7b909d7e4950/comments", "author": {"login": "pat-rogers", "id": 14908705, "node_id": "MDQ6VXNlcjE0OTA4NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/14908705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pat-rogers", "html_url": "https://github.com/pat-rogers", "followers_url": "https://api.github.com/users/pat-rogers/followers", "following_url": "https://api.github.com/users/pat-rogers/following{/other_user}", "gists_url": "https://api.github.com/users/pat-rogers/gists{/gist_id}", "starred_url": "https://api.github.com/users/pat-rogers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pat-rogers/subscriptions", "organizations_url": "https://api.github.com/users/pat-rogers/orgs", "repos_url": "https://api.github.com/users/pat-rogers/repos", "events_url": "https://api.github.com/users/pat-rogers/events{/privacy}", "received_events_url": "https://api.github.com/users/pat-rogers/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "261ce0eb820454b391d8a521bad03c8d46d22359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261ce0eb820454b391d8a521bad03c8d46d22359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/261ce0eb820454b391d8a521bad03c8d46d22359"}], "stats": {"total": 456, "additions": 456, "deletions": 0}, "files": [{"sha": "f28af4e011b837122dc6b97a5d5f5846e7668574", "filename": "gcc/ada/a-rttiev.adb", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31d7a8bd3d322870543d960e7f8e7b909d7e4950/gcc%2Fada%2Fa-rttiev.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31d7a8bd3d322870543d960e7f8e7b909d7e4950/gcc%2Fada%2Fa-rttiev.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rttiev.adb?ref=31d7a8bd3d322870543d960e7f8e7b909d7e4950", "patch": "@@ -0,0 +1,328 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--          A D A . R E A L _ T I M E . T I M I N G _ E V E N T S           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--           Copyright (C) 2005-2006, Free Software Foundation, Inc.        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Tasking.Utilities;\n+--  for Make_Independent\n+\n+with Ada.Containers.Doubly_Linked_Lists;\n+pragma Elaborate_All (Ada.Containers.Doubly_Linked_Lists);\n+\n+package body Ada.Real_Time.Timing_Events is\n+\n+   type Any_Timing_Event is access all Timing_Event'Class;\n+   --  We must also handle user-defined types derived from Timing_Event\n+\n+   ------------\n+   -- Events --\n+   ------------\n+\n+   package Events is\n+      new Ada.Containers.Doubly_Linked_Lists (Any_Timing_Event);\n+\n+   -----------------\n+   -- Event_Queue --\n+   -----------------\n+\n+   protected Event_Queue is\n+      pragma Priority (System.Priority'Last);\n+\n+      procedure Insert (This : Any_Timing_Event);\n+      --  Inserts This into the queue in ascending order by Timeout\n+\n+      procedure Process_Events;\n+      --  Iterates over the list of events and calls the handlers for any of\n+      --  those that have timed out. Deletes those that have timed out.\n+\n+    private\n+      All_Events : Events.List;\n+   end Event_Queue;\n+\n+   -----------\n+   -- Timer --\n+   -----------\n+\n+   task Timer is\n+      pragma Priority (System.Priority'Last);\n+   end Timer;\n+\n+   task body Timer is\n+      Period : constant Time_Span := Milliseconds (100);\n+      --  This is a \"chiming\" clock timer that fires periodically. The period\n+      --  selected is arbitrary and could be changed to suit the application\n+      --  requirements. Obviously a shorter period would give better resolution\n+      --  at the cost of more overhead.\n+\n+   begin\n+      System.Tasking.Utilities.Make_Independent;\n+      loop\n+         Event_Queue.Process_Events;\n+         delay until Clock + Period;\n+      end loop;\n+   end Timer;\n+\n+   ------------\n+   -- Sooner --\n+   ------------\n+\n+   function Sooner (Left, Right : Any_Timing_Event) return Boolean;\n+   --  Used by the Event_Queue insertion routine to keep the events in\n+   --  ascending order by timeout value.\n+\n+   -----------------\n+   -- Event_Queue --\n+   -----------------\n+\n+   protected body Event_Queue is\n+\n+      procedure Insert (This : Any_Timing_Event) is\n+         package By_Timeout is new Events.Generic_Sorting (Sooner);\n+         --  Used to keep the events in ascending order by timeout value\n+\n+      begin\n+         All_Events.Append (This);\n+\n+         --  A critical property of the implementation of this package is that\n+         --  all occurrences are in ascending order by Timeout. Thus the first\n+         --  event in the queue always has the \"next\" value for the Timer task\n+         --  to use in its delay statement.\n+\n+         By_Timeout.Sort (All_Events);\n+      end Insert;\n+\n+      procedure Process_Events is\n+         Next_Event : Any_Timing_Event;\n+      begin\n+         while not All_Events.Is_Empty loop\n+            Next_Event := All_Events.First_Element;\n+\n+            --  Clients can cancel a timeout (setting the handler to null) but\n+            --  cannot otherwise change the timeout/handler tuple until the\n+            --  call to Reset below.\n+\n+            if Next_Event.Control.Current_Timeout > Clock then\n+\n+               --  We found one that has not yet timed-out. The queue is in\n+               --  ascending order by Timeout so there is no need to continue\n+               --  processing (and indeed we must not continue since we always\n+               --  delete the first element).\n+\n+               return;\n+            end if;\n+\n+            declare\n+               Response : Timing_Event_Handler;\n+\n+            begin\n+               --  We take a local snapshot of the handler to avoid a race\n+               --  condition because we evaluate the handler value in the\n+               --  if-statement and again in the call and the client might have\n+               --  set it to null between those two evaluations.\n+\n+               Response := Next_Event.Control.Current_Handler;\n+\n+               if Response /= null then\n+\n+                  --  D.15 (13/2) says we only invoke the handler if it is\n+                  --  set when the timeout expires.\n+\n+                  Response (Timing_Event (Next_Event.all));\n+               end if;\n+\n+            exception\n+               when others =>\n+                  null;  --  per D.15 (21/2)\n+            end;\n+\n+            Next_Event.Control.Reset;\n+\n+            --  Clients can now change the timeout/handler pair for this event\n+\n+            --  And now we can delete the event from the queue. Any item we\n+            --  delete would be the first in the queue because we exit the loop\n+            --  when we first find one that is not yet timed-out. This fact\n+            --  allows us to use these \"First oriented\" list processing\n+            --  routines instead of the cursor oriented versions because we can\n+            --  avoid handling the way deletion affects cursors.\n+\n+            All_Events.Delete_First;\n+         end loop;\n+      end Process_Events;\n+\n+   end Event_Queue;\n+\n+   -----------------\n+   -- Set_Handler --\n+   -----------------\n+\n+   procedure Set_Handler\n+     (Event   : in out Timing_Event;\n+      At_Time : Time;\n+      Handler : Timing_Event_Handler)\n+   is\n+   begin\n+      Event.Control.Cancel;\n+\n+      if At_Time <= Clock then\n+         if Handler /= null then\n+            Handler (Event);\n+         end if;\n+         return;\n+      end if;\n+\n+      if Handler /= null then\n+         Event.Control.Set (At_Time, Handler);\n+         Event_Queue.Insert (Event'Unchecked_Access);\n+      end if;\n+   end Set_Handler;\n+\n+   -----------------\n+   -- Set_Handler --\n+   -----------------\n+\n+   procedure Set_Handler\n+     (Event   : in out Timing_Event;\n+      In_Time : Time_Span;\n+      Handler : Timing_Event_Handler)\n+   is\n+   begin\n+      Event.Control.Cancel;\n+\n+      if In_Time <= Time_Span_Zero then\n+         if Handler /= null then\n+            Handler (Event);\n+         end if;\n+         return;\n+      end if;\n+\n+      if Handler /= null then\n+         Event.Control.Set (Clock + In_Time, Handler);\n+         Event_Queue.Insert (Event'Unchecked_Access);\n+      end if;\n+   end Set_Handler;\n+\n+   -----------------\n+   -- Event_State --\n+   -----------------\n+\n+   protected body Event_State is\n+\n+      entry Set\n+        (Timeout : Time;\n+         Handler : Timing_Event_Handler)\n+      when\n+         Available\n+      is\n+      begin\n+         Event_State.Timeout := Set.Timeout;\n+         Event_State.Handler := Set.Handler;\n+         Available := False;\n+      end Set;\n+\n+      procedure Reset is\n+      begin\n+         Cancel;\n+         Available := True;\n+      end Reset;\n+\n+      procedure Cancel is\n+      begin\n+         Handler := null;\n+         Timeout := Time_First;\n+      end Cancel;\n+\n+      function Current_Timeout return Time is\n+      begin\n+         return Timeout;\n+      end Current_Timeout;\n+\n+      function Current_Handler return Timing_Event_Handler is\n+      begin\n+         return Handler;\n+      end Current_Handler;\n+\n+   end Event_State;\n+\n+   ---------------------\n+   -- Current_Handler --\n+   ---------------------\n+\n+   function Current_Handler\n+     (Event : Timing_Event) return Timing_Event_Handler\n+   is\n+   begin\n+      return Event.Control.Current_Handler;\n+   end Current_Handler;\n+\n+   --------------------\n+   -- Cancel_Handler --\n+   --------------------\n+\n+   procedure Cancel_Handler\n+     (Event     : in out Timing_Event;\n+      Cancelled : out Boolean)\n+   is\n+   begin\n+      Cancelled := Event.Control.Current_Handler /= null;\n+      Event.Control.Cancel;\n+   end Cancel_Handler;\n+\n+   -------------------\n+   -- Time_Of_Event --\n+   -------------------\n+\n+   function Time_Of_Event (Event : Timing_Event) return Time is\n+   begin\n+      return Event.Control.Current_Timeout;\n+   end Time_Of_Event;\n+\n+   ------------\n+   -- Sooner --\n+   ------------\n+\n+   function Sooner (Left, Right : Any_Timing_Event) return Boolean is\n+   begin\n+      return Left.Control.Current_Timeout < Right.Control.Current_Timeout;\n+   end Sooner;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (This : in out Timing_Event) is\n+   begin\n+      --  D.15 (19/2) says finalization clears the event\n+\n+      This.Control.Cancel;\n+   end Finalize;\n+\n+end Ada.Real_Time.Timing_Events;"}, {"sha": "9d114d4f598120e66f5f979925f9a47f5dc969bd", "filename": "gcc/ada/a-rttiev.ads", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31d7a8bd3d322870543d960e7f8e7b909d7e4950/gcc%2Fada%2Fa-rttiev.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31d7a8bd3d322870543d960e7f8e7b909d7e4950/gcc%2Fada%2Fa-rttiev.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rttiev.ads?ref=31d7a8bd3d322870543d960e7f8e7b909d7e4950", "patch": "@@ -0,0 +1,128 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--          A D A . R E A L _ T I M E . T I M I N G _ E V E N T S           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--           Copyright (C) 2005-2006, Free Software Foundation, Inc.        --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Finalization;\n+\n+package Ada.Real_Time.Timing_Events is\n+\n+   type Timing_Event is tagged limited private;\n+\n+   type Timing_Event_Handler\n+     is access protected procedure (Event : in out Timing_Event);\n+\n+   procedure Set_Handler\n+     (Event   : in out Timing_Event;\n+      At_Time : Time;\n+      Handler : Timing_Event_Handler);\n+\n+   procedure Set_Handler\n+     (Event   : in out Timing_Event;\n+      In_Time : Time_Span;\n+      Handler : Timing_Event_Handler);\n+\n+   function Current_Handler\n+     (Event : Timing_Event) return Timing_Event_Handler;\n+\n+   procedure Cancel_Handler\n+     (Event     : in out Timing_Event;\n+      Cancelled : out Boolean);\n+\n+   function Time_Of_Event (Event : Timing_Event) return Time;\n+\n+private\n+\n+   protected type Event_State is\n+\n+      --  D.15 (22/2) requires atomicity with respect to the operations\n+      --  provided by the package and the timing events they manipulate. On\n+      --  real-time operating systems suitable for implementing this package, a\n+      --  different implementation strategy would be employed to meet that\n+      --  requirement.\n+\n+      entry Set (Timeout : Time;  Handler : Timing_Event_Handler);\n+      --  Changes the timeout and handler values for procedure Set_Handler. Can\n+      --  only execute when the event is 'available', to prevent a race\n+      --  condition between the caller of Set_Handler and the internal Timer\n+      --  task that processes the events. In particular, D.15 (22/2) requires\n+      --  that there be no possibility of a new handler executing in response\n+      --  to an old timeout.\n+\n+      procedure Reset;\n+      --  First resets the timeout to Time_First and the handler to\n+      --  null. Indicates that Set (for Set_Handler) can now change the timeout\n+      --  and/or handler.  Called only by the interal Timer task.\n+\n+      procedure Cancel;\n+      --  Resets the timeout to Time_First and the handler to\n+      --  null. Called by procedure Cancel_Handler and by procedure Reset.\n+\n+      function Current_Timeout return Time;\n+      --  Returns the currently set timeout. The value Time_First is returned\n+      --  if the Timing_Event is in the \"cleared\" state. Called by function\n+      --  Time_of_Event.\n+\n+      function Current_Handler return Timing_Event_Handler;\n+      --  Returns the currently set handler. The value null is returned if the\n+      --  Timing_Event is in the \"cleared\" state. Called by function\n+      --  Curent_Handler.\n+\n+   private\n+      Timeout : Time := Time_First;\n+      --  The time at which the user's handler should be invoked when the\n+      --  event is \"set\" (i.e., when Handler is not null).\n+\n+      Handler : Timing_Event_Handler;\n+      --  An access value designating the protected procedure to be invoked\n+      --  at the Timeout time in the future.  When this value is null the event\n+      --  is said to be \"cleared\" and no timeout is processed.\n+\n+      Available : Boolean := True;\n+      --  A flag controlling when users can change the Timeout and Handler\n+      --  tuple. In particular the entry Set, called by procedure Set_Handler,\n+      --  is controlled by this flag.\n+\n+   end Event_State;\n+\n+   type Timing_Event is new Ada.Finalization.Limited_Controlled with record\n+      Control : Event_State;\n+   end record;\n+\n+   overriding procedure Finalize (This : in out Timing_Event);\n+   --  Finalization procedure is required to satisfy (RM D.15 (19/2)), which\n+   --  says that the object must be cleared on finalization.\n+\n+end Ada.Real_Time.Timing_Events;"}]}