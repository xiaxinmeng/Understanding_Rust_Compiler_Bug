{"sha": "f61134e88be4321c6cce477d4db0539d4c99a237", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYxMTM0ZTg4YmU0MzIxYzZjY2U0NzdkNGRiMDUzOWQ0Yzk5YTIzNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-03T19:59:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-03T19:59:13Z"}, "message": "ia64.c (TARGET_VECTOR_MODE_SUPPORTED_P): New.\n\n        * config/ia64/ia64.c (TARGET_VECTOR_MODE_SUPPORTED_P): New.\n        (ia64_const_ok_for_letter_p): New.\n        (ia64_const_double_ok_for_letter_p): New.\n        (ia64_extra_constraint): New.\n        (ia64_expand_vecint_compare): New.\n        (ia64_expand_vcondu_v2si): New.\n        (ia64_expand_vecint_cmov): New.\n        (ia64_expand_vecint_minmax): New.\n        (ia64_print_operand): Add 'v'.\n        (ia64_preferred_reload_class): New.\n        (ia64_vector_mode_supported_p): New.\n        * config/ia64/ia64.h (UNITS_PER_SIMD_WORD): New.\n        (PREFERRED_RELOAD_CLASS): Move to function.\n        (CONST_OK_FOR_LETTER_P): Move to function.\n        (CONST_DOUBLE_OK_FOR_LETTER_P): Move to function.\n        (CONSTRAINT_OK_FOR_Q, CONSTRAINT_OK_FOR_R): Remove.\n        (CONSTRAINT_OK_FOR_S, CONSTRAINT_OK_FOR_T): Remove.\n        (EXTRA_CONSTRAINT): Move to function.\n        * config/ia64/ia64.md: Include vect.md.\n        (itanium_class): Add mmalua.\n        (type): Handle it.\n        * config/ia64/itanium1.md (1_mmalua): New.  Add it to bypasses.\n        (1b_mmalua): New.\n        * config/ia64/itanium2.md (2_mmalua, 2b_mmalua): Similarly.\n        * config/ia64/predicates.md (gr_reg_or_0_operand): Accept any\n        CONST0_RTX.\n        (const_int_2bit_operand): New.\n        (fr_reg_or_0_operand): New.\n        * config/ia64/ia64-modes.def: Add vector modes.\n        * config/ia64/ia64-protos.h: Update.\n        * config/ia64/vect.md: New file.\n\n        * gcc.dg/vect/vect.exp: Enable for ia64.\n        * lib/target-supports.exp (check_effective_target_vect_int): Likewise.\n        (check_effective_target_vect_float): Likewise.\n        (check_effective_target_vect_no_align): Likewise.\n        * gcc.dg/vect/vect-30.c: XFAIL for vect_no_align.\n        * gcc.dg/vect/vect-8.c: Likewise.\n\nFrom-SVN: r92862", "tree": {"sha": "ccfd57538990a65fee413ecc4781ca4127de0aa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccfd57538990a65fee413ecc4781ca4127de0aa3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f61134e88be4321c6cce477d4db0539d4c99a237", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f61134e88be4321c6cce477d4db0539d4c99a237", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f61134e88be4321c6cce477d4db0539d4c99a237", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f61134e88be4321c6cce477d4db0539d4c99a237/comments", "author": null, "committer": null, "parents": [{"sha": "3198b947a84e0db7870158c7cd357396a91c2b30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3198b947a84e0db7870158c7cd357396a91c2b30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3198b947a84e0db7870158c7cd357396a91c2b30"}], "stats": {"total": 1610, "additions": 1544, "deletions": 66}, "files": [{"sha": "ec51b646fe566fcd978272de1d42a99eea8e1bf2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -1,3 +1,37 @@\n+2005-01-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.c (TARGET_VECTOR_MODE_SUPPORTED_P): New.\n+\t(ia64_const_ok_for_letter_p): New.\n+\t(ia64_const_double_ok_for_letter_p): New.\n+\t(ia64_extra_constraint): New.\n+\t(ia64_expand_vecint_compare): New.\n+\t(ia64_expand_vcondu_v2si): New.\n+\t(ia64_expand_vecint_cmov): New.\n+\t(ia64_expand_vecint_minmax): New.\n+\t(ia64_print_operand): Add 'v'.\n+\t(ia64_preferred_reload_class): New.\n+\t(ia64_vector_mode_supported_p): New.\n+\t* config/ia64/ia64.h (UNITS_PER_SIMD_WORD): New.\n+\t(PREFERRED_RELOAD_CLASS): Move to function.\n+\t(CONST_OK_FOR_LETTER_P): Move to function.\n+\t(CONST_DOUBLE_OK_FOR_LETTER_P): Move to function.\n+\t(CONSTRAINT_OK_FOR_Q, CONSTRAINT_OK_FOR_R): Remove.\n+\t(CONSTRAINT_OK_FOR_S, CONSTRAINT_OK_FOR_T): Remove.\n+\t(EXTRA_CONSTRAINT): Move to function.\n+\t* config/ia64/ia64.md: Include vect.md.\n+\t(itanium_class): Add mmalua.\n+\t(type): Handle it.\n+\t* config/ia64/itanium1.md (1_mmalua): New.  Add it to bypasses.\n+\t(1b_mmalua): New.\n+\t* config/ia64/itanium2.md (2_mmalua, 2b_mmalua): Similarly.\n+\t* config/ia64/predicates.md (gr_reg_or_0_operand): Accept any\n+\tCONST0_RTX.\n+\t(const_int_2bit_operand): New.\n+\t(fr_reg_or_0_operand): New.\n+\t* config/ia64/ia64-modes.def: Add vector modes.\n+\t* config/ia64/ia64-protos.h: Update.\n+\t* config/ia64/vect.md: New file.\n+\n 2005-01-03  Richard Henderson  <rth@redhat.com>\n \n \t* simplify-rtx.c (simplify_binary_operation): Handle VEC_CONCAT."}, {"sha": "3611638a7c2d3605144282a24857a62956b980db", "filename": "gcc/config/ia64/ia64-modes.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fia64-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fia64-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-modes.def?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -66,3 +66,11 @@ INT_MODE (OI, 32);\n    so that flow doesn't do something stupid.  */\n \n CC_MODE (CCI);\n+\n+/* Vector modes.  */\n+VECTOR_MODES (INT, 4);\t\t/* V4QI V2HI */\n+VECTOR_MODES (INT, 8);\t\t/* V8QI V4HI V2SI */\n+VECTOR_MODE (INT, QI, 16);\n+VECTOR_MODE (INT, HI, 8);\n+VECTOR_MODE (INT, SI, 4);\n+VECTOR_MODE (FLOAT, SF, 2);"}, {"sha": "5b4b935cdd1d1e348520dc348be61a76a492debc", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -34,6 +34,10 @@ extern int ia64_st_address_bypass_p (rtx, rtx);\n extern int ia64_ld_address_bypass_p (rtx, rtx);\n extern int ia64_produce_address_p (rtx);\n \n+extern bool ia64_const_ok_for_letter_p (HOST_WIDE_INT, char);\n+extern bool ia64_const_double_ok_for_letter_p (rtx, char);\n+extern bool ia64_extra_constraint (rtx, char);\n+\n extern rtx ia64_expand_move (rtx, rtx);\n extern int ia64_move_ok (rtx, rtx);\n extern int addp4_optimize_ok (rtx, rtx);\n@@ -42,6 +46,8 @@ extern int ia64_depz_field_mask (rtx, rtx);\n extern void ia64_split_tmode_move (rtx[]);\n extern rtx spill_xfmode_operand (rtx, int);\n extern rtx ia64_expand_compare (enum rtx_code, enum machine_mode);\n+extern void ia64_expand_vecint_cmov (rtx[]);\n+extern bool ia64_expand_vecint_minmax (enum rtx_code, enum machine_mode, rtx[]);\n extern void ia64_expand_call (rtx, rtx, rtx, int);\n extern void ia64_split_call (rtx, rtx, rtx, rtx, rtx, int, int);\n extern void ia64_reload_gp (void);\n@@ -57,6 +63,7 @@ extern int ia64_hard_regno_rename_ok (int, int);\n extern void ia64_initialize_trampoline (rtx, rtx, rtx);\n extern void ia64_print_operand_address (FILE *, rtx);\n extern void ia64_print_operand (FILE *, rtx, int);\n+extern enum reg_class ia64_preferred_reload_class (rtx, enum reg_class);\n extern enum reg_class ia64_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t   enum machine_mode, rtx);\n extern void ia64_output_dwarf_dtprel (FILE*, int, rtx);"}, {"sha": "a6197c0ef459d19473bf76c1d19c0d23fa39b0a2", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 419, "deletions": 2, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -279,6 +279,7 @@ static void ia64_encode_section_info (tree, rtx, int);\n static rtx ia64_struct_value_rtx (tree, int);\n static tree ia64_gimplify_va_arg (tree, tree, tree *, tree *);\n static bool ia64_scalar_mode_supported_p (enum machine_mode mode);\n+static bool ia64_vector_mode_supported_p (enum machine_mode mode);\n \n \f\n /* Table of valid machine attributes.  */\n@@ -423,6 +424,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n \n #undef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P ia64_scalar_mode_supported_p\n+#undef TARGET_VECTOR_MODE_SUPPORTED_P\n+#define TARGET_VECTOR_MODE_SUPPORTED_P ia64_vector_mode_supported_p\n \n /* ia64 architecture manual 4.4.7: ... reads, writes, and flushes may occur\n    in an order different from the specified program order.  */\n@@ -472,7 +475,8 @@ ia64_get_addr_area (tree decl)\n }\n \n static tree\n-ia64_handle_model_attribute (tree *node, tree name, tree args, int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n+ia64_handle_model_attribute (tree *node, tree name, tree args,\n+\t\t\t     int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n {\n   ia64_addr_area addr_area = ADDR_AREA_NORMAL;\n   ia64_addr_area area;\n@@ -554,6 +558,103 @@ ia64_encode_section_info (tree decl, rtx rtl, int first)\n     ia64_encode_addr_area (decl, XEXP (rtl, 0));\n }\n \f\n+/* Implement CONST_OK_FOR_LETTER_P.  */\n+\n+bool\n+ia64_const_ok_for_letter_p (HOST_WIDE_INT value, char c)\n+{\n+  switch (c)\n+    {\n+    case 'I':\n+      return CONST_OK_FOR_I (value);\n+    case 'J':\n+      return CONST_OK_FOR_J (value);\n+    case 'K':\n+      return CONST_OK_FOR_K (value);\n+    case 'L':\n+      return CONST_OK_FOR_L (value);\n+    case 'M':\n+      return CONST_OK_FOR_M (value);\n+    case 'N':\n+      return CONST_OK_FOR_N (value);\n+    case 'O':\n+      return CONST_OK_FOR_O (value);\n+    case 'P':\n+      return CONST_OK_FOR_P (value);\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Implement CONST_DOUBLE_OK_FOR_LETTER_P.  */\n+\n+bool\n+ia64_const_double_ok_for_letter_p (rtx value, char c)\n+{\n+  switch (c)\n+    {\n+    case 'G':\n+      return CONST_DOUBLE_OK_FOR_G (value);\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Implement EXTRA_CONSTRAINT.  */\n+\n+bool\n+ia64_extra_constraint (rtx value, char c)\n+{\n+  switch (c)\n+    {\n+    case 'Q':\n+      /* Non-volatile memory for FP_REG loads/stores.  */\n+      return memory_operand(value, VOIDmode) && !MEM_VOLATILE_P (value);\n+\n+    case 'R':\n+      /* 1..4 for shladd arguments.  */\n+      return (GET_CODE (value) == CONST_INT\n+\t      && INTVAL (value) >= 1 && INTVAL (value) <= 4);\n+\n+    case 'S':\n+      /* Non-post-inc memory for asms and other unsavory creatures.  */\n+      return (GET_CODE (value) == MEM\n+\t      && GET_RTX_CLASS (GET_CODE (XEXP (value, 0))) != RTX_AUTOINC\n+\t      && (reload_in_progress || memory_operand (value, VOIDmode)));\n+\n+    case 'T':\n+      /* Symbol ref to small-address-area.  */\n+      return (GET_CODE (value) == SYMBOL_REF\n+\t      && SYMBOL_REF_SMALL_ADDR_P (value));\n+\n+    case 'U':\n+      /* Vector zero.  */\n+      return value == CONST0_RTX (GET_MODE (value));\n+\n+    case 'W':\n+      /* An integer vector, such that conversion to an integer yields a\n+\t value appropriate for an integer 'J' constraint.  */\n+      if (GET_CODE (value) == CONST_VECTOR\n+\t  && GET_MODE_CLASS (GET_MODE (value)) == MODE_VECTOR_INT)\n+\t{\n+\t  value = simplify_subreg (DImode, value, GET_MODE (value), 0);\n+\t  return ia64_const_ok_for_letter_p (INTVAL (value), 'J');\n+\t}\n+      return false;\n+\n+    case 'Y':\n+      /* A V2SF vector containing elements that satisfy 'G'.  */\n+      return\n+\t(GET_CODE (value) == CONST_VECTOR\n+\t && GET_MODE (value) == V2SFmode\n+\t && ia64_const_double_ok_for_letter_p (XVECEXP (value, 0, 0), 'G')\n+\t && ia64_const_double_ok_for_letter_p (XVECEXP (value, 0, 1), 'G'));\n+\n+    default:\n+      return false;\n+    }\n+}\n+\f\n /* Return 1 if the operands of a move are ok.  */\n \n int\n@@ -1166,6 +1267,264 @@ ia64_expand_compare (enum rtx_code code, enum machine_mode mode)\n   return gen_rtx_fmt_ee (code, mode, cmp, const0_rtx);\n }\n \n+/* Generate an integral vector comparison.  */\n+\n+static bool\n+ia64_expand_vecint_compare (enum rtx_code code, enum machine_mode mode,\n+\t\t\t    rtx dest, rtx op0, rtx op1)\n+{\n+  bool negate = false;\n+  rtx x;\n+\n+  switch (code)\n+    {\n+    case EQ:\n+    case GT:\n+      break;\n+\n+    case NE:\n+      code = EQ;\n+      negate = true;\n+      break;\n+\n+    case LE:\n+      code = GT;\n+      negate = true;\n+      break;\n+\n+    case GE:\n+      negate = true;\n+      /* FALLTHRU */\n+\n+    case LT:\n+      x = op0;\n+      op0 = op1;\n+      op1 = x;\n+      code = GT;\n+      break;\n+\n+    case GTU:\n+    case GEU:\n+    case LTU:\n+    case LEU:\n+      {\n+\trtx w0h, w0l, w1h, w1l, ch, cl;\n+\tenum machine_mode wmode;\n+\trtx (*unpack_l) (rtx, rtx, rtx);\n+\trtx (*unpack_h) (rtx, rtx, rtx);\n+\trtx (*pack) (rtx, rtx, rtx);\n+\n+\t/* We don't have native unsigned comparisons, but we can generate\n+\t   them better than generic code can.  */\n+\n+\tif (mode == V2SImode)\n+\t  abort ();\n+\telse if (mode == V8QImode)\n+\t  {\n+\t    wmode = V4HImode;\n+\t    pack = gen_pack2_sss;\n+\t    unpack_l = gen_unpack1_l;\n+\t    unpack_h = gen_unpack1_h;\n+\t  }\n+\telse if (mode == V4HImode)\n+\t  {\n+\t    wmode = V2SImode;\n+\t    pack = gen_pack4_sss;\n+\t    unpack_l = gen_unpack2_l;\n+\t    unpack_h = gen_unpack2_h;\n+\t  }\n+\telse\n+\t  abort ();\n+\n+\t/* Unpack into wider vectors, zero extending the elements.  */\n+\n+\tw0l = gen_reg_rtx (wmode);\n+\tw0h = gen_reg_rtx (wmode);\n+\tw1l = gen_reg_rtx (wmode);\n+\tw1h = gen_reg_rtx (wmode);\n+\temit_insn (unpack_l (gen_lowpart (mode, w0l), op0, CONST0_RTX (mode)));\n+\temit_insn (unpack_h (gen_lowpart (mode, w0h), op0, CONST0_RTX (mode)));\n+\temit_insn (unpack_l (gen_lowpart (mode, w1l), op1, CONST0_RTX (mode)));\n+\temit_insn (unpack_h (gen_lowpart (mode, w1h), op1, CONST0_RTX (mode)));\n+\n+\t/* Compare in the wider mode.  */\n+\n+\tcl = gen_reg_rtx (wmode);\n+\tch = gen_reg_rtx (wmode);\n+\tcode = signed_condition (code);\n+\tia64_expand_vecint_compare (code, wmode, cl, w0l, w1l);\n+\tnegate = ia64_expand_vecint_compare (code, wmode, ch, w0h, w1h);\n+\n+\t/* Repack into a single narrower vector.  */\n+\n+\temit_insn (pack (dest, cl, ch));\n+      }\n+      return negate;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  x = gen_rtx_fmt_ee (code, mode, op0, op1);\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+\n+  return negate;\n+}\n+\n+static void\n+ia64_expand_vcondu_v2si (enum rtx_code code, rtx operands[])\n+{\n+  rtx dl, dh, bl, bh, op1l, op1h, op2l, op2h, op4l, op4h, op5l, op5h, x;\n+\n+  /* In this case, we extract the two SImode quantities and generate\n+     normal comparisons for each of them.  */\n+\n+  op1l = gen_lowpart (SImode, operands[1]);\n+  op2l = gen_lowpart (SImode, operands[2]);\n+  op4l = gen_lowpart (SImode, operands[4]);\n+  op5l = gen_lowpart (SImode, operands[5]);\n+\n+  op1h = gen_reg_rtx (SImode);\n+  op2h = gen_reg_rtx (SImode);\n+  op4h = gen_reg_rtx (SImode);\n+  op5h = gen_reg_rtx (SImode);\n+\n+  emit_insn (gen_lshrdi3 (gen_lowpart (DImode, op1h),\n+\t\t\t  gen_lowpart (DImode, operands[1]), GEN_INT (32)));\n+  emit_insn (gen_lshrdi3 (gen_lowpart (DImode, op2h),\n+\t\t\t  gen_lowpart (DImode, operands[2]), GEN_INT (32)));\n+  emit_insn (gen_lshrdi3 (gen_lowpart (DImode, op4h),\n+\t\t\t  gen_lowpart (DImode, operands[4]), GEN_INT (32)));\n+  emit_insn (gen_lshrdi3 (gen_lowpart (DImode, op5h),\n+\t\t\t  gen_lowpart (DImode, operands[5]), GEN_INT (32)));\n+\n+  bl = gen_reg_rtx (BImode);\n+  x = gen_rtx_fmt_ee (code, BImode, op4l, op5l);\n+  emit_insn (gen_rtx_SET (VOIDmode, bl, x));\n+\n+  bh = gen_reg_rtx (BImode);\n+  x = gen_rtx_fmt_ee (code, BImode, op4h, op5h);\n+  emit_insn (gen_rtx_SET (VOIDmode, bh, x));\n+\n+  /* With the results of the comparisons, emit conditional moves.  */\n+\n+  dl = gen_reg_rtx (SImode);\n+  x = gen_rtx_IF_THEN_ELSE (SImode, bl, op1l, op2l);\n+  emit_insn (gen_rtx_SET (VOIDmode, dl, x));\n+\n+  dh = gen_reg_rtx (SImode);\n+  x = gen_rtx_IF_THEN_ELSE (SImode, bh, op1h, op2h);\n+  emit_insn (gen_rtx_SET (VOIDmode, dh, x));\n+\n+  /* Merge the two partial results back into a vector.  */\n+\n+  x = gen_rtx_VEC_CONCAT (V2SImode, dl, dh);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n+}\n+\n+/* Emit an integral vector conditional move.  */\n+\n+void\n+ia64_expand_vecint_cmov (rtx operands[])\n+{\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  enum rtx_code code = GET_CODE (operands[3]);\n+  bool negate;\n+  rtx cmp, x, ot, of;\n+\n+  /* Since we don't have unsigned V2SImode comparisons, it's more efficient\n+     to special-case them entirely.  */\n+  if (mode == V2SImode\n+      && (code == GTU || code == GEU || code == LEU || code == LTU))\n+    {\n+      ia64_expand_vcondu_v2si (code, operands);\n+      return;\n+    }\n+\n+  cmp = gen_reg_rtx (mode);\n+  negate = ia64_expand_vecint_compare (code, mode, cmp,\n+\t\t\t\t       operands[4], operands[5]);\n+\n+  ot = operands[1+negate];\n+  of = operands[2-negate];\n+\n+  if (ot == CONST0_RTX (mode))\n+    {\n+      if (of == CONST0_RTX (mode))\n+\t{\n+\t  emit_move_insn (operands[0], ot);\n+\t  return;\n+\t}\n+\n+      x = gen_rtx_NOT (mode, cmp);\n+      x = gen_rtx_AND (mode, x, of);\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n+    }\n+  else if (of == CONST0_RTX (mode))\n+    {\n+      x = gen_rtx_AND (mode, cmp, ot);\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n+    }\n+  else\n+    {\n+      rtx t, f;\n+\n+      t = gen_reg_rtx (mode);\n+      x = gen_rtx_AND (mode, cmp, operands[1+negate]);\n+      emit_insn (gen_rtx_SET (VOIDmode, t, x));\n+\n+      f = gen_reg_rtx (mode);\n+      x = gen_rtx_NOT (mode, cmp);\n+      x = gen_rtx_AND (mode, x, operands[2-negate]);\n+      emit_insn (gen_rtx_SET (VOIDmode, f, x));\n+\n+      x = gen_rtx_IOR (mode, t, f);\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n+    }\n+}\n+\n+/* Emit an integral vector min or max operation.  Return true if all done.  */\n+\n+bool\n+ia64_expand_vecint_minmax (enum rtx_code code, enum machine_mode mode,\n+\t\t\t   rtx operands[])\n+{\n+  rtx xops[5];\n+\n+  /* These four combinations are supported directly.  */\n+  if (mode == V8QImode && (code == UMIN || code == UMAX))\n+    return false;\n+  if (mode == V4HImode && (code == SMIN || code == SMAX))\n+    return false;\n+\n+  /* Everything else implemented via vector comparisons.  */\n+  xops[0] = operands[0];\n+  xops[4] = xops[1] = operands[1];\n+  xops[5] = xops[2] = operands[2];\n+\n+  switch (code)\n+    {\n+    case UMIN:\n+      code = LTU;\n+      break;\n+    case UMAX:\n+      code = GTU;\n+      break;\n+    case SMIN:\n+      code = LT;\n+      break;\n+    case SMAX:\n+      code = GT;\n+      break;\n+    default:\n+      abort ();\n+    }\n+  xops[3] = gen_rtx_fmt_ee (code, VOIDmode, operands[1], operands[2]);\n+\n+  ia64_expand_vecint_cmov (xops);\n+  return true;\n+}\n+\n /* Emit the appropriate sequence for a call.  */\n \n void\n@@ -3613,7 +3972,9 @@ ia64_print_operand_address (FILE * stream ATTRIBUTE_UNUSED,\n    U\tPrint an 8-bit sign extended number (K) as a 64-bit unsigned number\n \tfor Intel assembler.\n    r\tPrint register name, or constant 0 as r0.  HP compatibility for\n-\tLinux kernel.  */\n+\tLinux kernel.\n+   v    Print vector constant value as an 8-byte integer value.  */\n+\n void\n ia64_print_operand (FILE * file, rtx x, int code)\n {\n@@ -3771,6 +4132,11 @@ ia64_print_operand (FILE * file, rtx x, int code)\n \toutput_operand_lossage (\"invalid %%r value\");\n       return;\n \n+    case 'v':\n+      gcc_assert (GET_CODE (x) == CONST_VECTOR);\n+      x = simplify_subreg (DImode, x, GET_MODE (x), 0);\n+      break;\n+\n     case '+':\n       {\n \tconst char *which;\n@@ -3994,6 +4360,39 @@ ia64_register_move_cost (enum machine_mode mode, enum reg_class from,\n   return 2;\n }\n \n+/* Implement PREFERRED_RELOAD_CLASS.  Place additional restrictions on CLASS\n+   to use when copying X into that class.  */\n+\n+enum reg_class\n+ia64_preferred_reload_class (rtx x, enum reg_class class)\n+{\n+  switch (class)\n+    {\n+    case FR_REGS:\n+      /* Don't allow volatile mem reloads into floating point registers.\n+\t This is defined to force reload to choose the r/m case instead\n+\t of the f/f case when reloading (set (reg fX) (mem/v)).  */\n+      if (MEM_P (x) && MEM_VOLATILE_P (x))\n+\treturn NO_REGS;\n+      \n+      /* Force all unrecognized constants into the constant pool.  */\n+      if (CONSTANT_P (x))\n+\treturn NO_REGS;\n+      break;\n+\n+    case AR_M_REGS:\n+    case AR_I_REGS:\n+      if (!OBJECT_P (x))\n+\treturn NO_REGS;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return class;\n+}\n+\n /* This function returns the register class required for a secondary\n    register when copying between one of the registers in CLASS, and X,\n    using MODE.  A return value of NO_REGS means that no secondary register\n@@ -8587,4 +8986,22 @@ ia64_scalar_mode_supported_p (enum machine_mode mode)\n     }\n }\n \n+static bool\n+ia64_vector_mode_supported_p (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case V8QImode:\n+    case V4HImode:\n+    case V2SImode:\n+      return true;\n+\n+    case V2SFmode:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n #include \"gt-ia64.h\""}, {"sha": "21f9dc3b09131ca16793f07a70c3312c9e3b764a", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 6, "deletions": 41, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -338,6 +338,8 @@ extern const char *ia64_tune_string;\n \n #define UNITS_PER_WORD 8\n \n+#define UNITS_PER_SIMD_WORD UNITS_PER_WORD\n+\n #define POINTER_SIZE (TARGET_ILP32 ? 32 : 64)\n \n /* A C expression whose value is zero if pointers that need to be extended\n@@ -1024,18 +1026,8 @@ enum reg_class\n    The value is a register class; perhaps CLASS, or perhaps another, smaller\n    class.  */\n \n-/* Don't allow volatile mem reloads into floating point registers.  This\n-   is defined to force reload to choose the r/m case instead of the f/f case\n-   when reloading (set (reg fX) (mem/v)).\n-\n-   Do not reload expressions into AR regs.  */\n-\n #define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n-  (CLASS == FR_REGS && GET_CODE (X) == MEM && MEM_VOLATILE_P (X) ? NO_REGS   \\\n-   : CLASS == FR_REGS && GET_CODE (X) == CONST_DOUBLE ? NO_REGS\t\t     \\\n-   : !OBJECT_P (X)\t\t\t\t\t\t\t     \\\n-     && (CLASS == AR_M_REGS || CLASS == AR_I_REGS) ? NO_REGS\t\t     \\\n-   : CLASS)\n+  ia64_preferred_reload_class (X, CLASS)\n \n /* You should define this macro to indicate to the reload phase that it may\n    need to allocate at least one register for a reload in addition to the\n@@ -1106,15 +1098,7 @@ enum reg_class\n #define CONST_OK_FOR_P(VALUE) ((VALUE) == 0 || (VALUE) == -1)\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n-((C) == 'I' ? CONST_OK_FOR_I (VALUE)\t\t\\\n- : (C) == 'J' ? CONST_OK_FOR_J (VALUE)\t\t\\\n- : (C) == 'K' ? CONST_OK_FOR_K (VALUE)\t\t\\\n- : (C) == 'L' ? CONST_OK_FOR_L (VALUE)\t\t\\\n- : (C) == 'M' ? CONST_OK_FOR_M (VALUE)\t\t\\\n- : (C) == 'N' ? CONST_OK_FOR_N (VALUE)\t\t\\\n- : (C) == 'O' ? CONST_OK_FOR_O (VALUE)\t\t\\\n- : (C) == 'P' ? CONST_OK_FOR_P (VALUE)\t\t\\\n- : 0)\n+  ia64_const_ok_for_letter_p (VALUE, C)\n \n /* A C expression that defines the machine-dependent operand constraint letters\n    (`G', `H') that specify particular ranges of `const_double' values.  */\n@@ -1125,33 +1109,14 @@ enum reg_class\n    || (VALUE) == CONST1_RTX (GET_MODE (VALUE)))\n \n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n-  ((C) == 'G' ? CONST_DOUBLE_OK_FOR_G (VALUE) : 0)\n+  ia64_const_double_ok_for_letter_p (VALUE, C)\n \n /* A C expression that defines the optional machine-dependent constraint\n    letters (`Q', `R', `S', `T', `U') that can be used to segregate specific\n    types of operands, usually memory references, for the target machine.  */\n \n-/* Non-volatile memory for FP_REG loads/stores.  */\n-#define CONSTRAINT_OK_FOR_Q(VALUE) \\\n-  (memory_operand((VALUE), VOIDmode) && ! MEM_VOLATILE_P (VALUE))\n-/* 1..4 for shladd arguments.  */\n-#define CONSTRAINT_OK_FOR_R(VALUE) \\\n-  (GET_CODE (VALUE) == CONST_INT && INTVAL (VALUE) >= 1 && INTVAL (VALUE) <= 4)\n-/* Non-post-inc memory for asms and other unsavory creatures.  */\n-#define CONSTRAINT_OK_FOR_S(VALUE)\t\t\t\t\t\\\n-  (GET_CODE (VALUE) == MEM\t\t\t\t\t\t\\\n-   && GET_RTX_CLASS (GET_CODE (XEXP ((VALUE), 0))) != RTX_AUTOINC\t\\\n-   && (reload_in_progress || memory_operand ((VALUE), VOIDmode)))\n-/* Symbol ref to small-address-area: */\n-#define CONSTRAINT_OK_FOR_T(VALUE)\t\t\t\t\t\t\\\n-\t(GET_CODE (VALUE) == SYMBOL_REF && SYMBOL_REF_SMALL_ADDR_P (VALUE))\n-\n #define EXTRA_CONSTRAINT(VALUE, C) \\\n-  ((C) == 'Q' ? CONSTRAINT_OK_FOR_Q (VALUE)\t\\\n-   : (C) == 'R' ? CONSTRAINT_OK_FOR_R (VALUE)\t\\\n-   : (C) == 'S' ? CONSTRAINT_OK_FOR_S (VALUE)\t\\\n-   : (C) == 'T' ? CONSTRAINT_OK_FOR_T (VALUE)\t\\\n-   : 0)\n+  ia64_extra_constraint (VALUE, C)\n \f\n /* Basic Stack Layout */\n "}, {"sha": "8ce878d0c431c724a2e4f51f8935190e46b04e55", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -121,9 +121,9 @@\n \n (define_attr \"itanium_class\" \"unknown,ignore,stop_bit,br,fcmp,fcvtfx,fld,\n \tfmac,fmisc,frar_i,frar_m,frbr,frfr,frpr,ialu,icmp,ilog,ishf,ld,\n-\tchk_s,long_i,mmmul,mmshf,mmshfi,rse_m,scall,sem,stf,st,syst_m0,\n-\tsyst_m,tbit,toar_i,toar_m,tobr,tofr,topr,xmpy,xtd,nop,nop_b,nop_f,\n-\tnop_i,nop_m,nop_x,lfetch,pre_cycle\"\n+\tchk_s,long_i,mmalua,mmmul,mmshf,mmshfi,rse_m,scall,sem,stf,\n+        st,syst_m0, syst_m,tbit,toar_i,toar_m,tobr,tofr,topr,xmpy,xtd,nop,\n+        nop_b,nop_f,nop_i,nop_m,nop_x,lfetch,pre_cycle\"\n   (const_string \"unknown\"))\n \n ;; chk_s has an I and an M form; use type A for convenience.\n@@ -132,7 +132,8 @@\n \t (eq_attr \"itanium_class\" \"rse_m,syst_m,syst_m0\") (const_string \"M\")\n \t (eq_attr \"itanium_class\" \"frar_m,toar_m,frfr,tofr\") (const_string \"M\")\n \t (eq_attr \"itanium_class\" \"lfetch\") (const_string \"M\")\n-\t (eq_attr \"itanium_class\" \"chk_s,ialu,icmp,ilog\") (const_string \"A\")\n+\t (eq_attr \"itanium_class\" \"chk_s,ialu,icmp,ilog,mmalua\")\n+\t   (const_string \"A\")\n \t (eq_attr \"itanium_class\" \"fmisc,fmac,fcmp,xmpy\") (const_string \"F\")\n \t (eq_attr \"itanium_class\" \"fcvtfx,nop_f\") (const_string \"F\")\n \t (eq_attr \"itanium_class\" \"frar_i,toar_i,frbr,tobr\") (const_string \"I\")\n@@ -6036,3 +6037,6 @@\n   \"addp4_optimize_ok (operands[1], operands[2])\"\n   \"addp4 %0 = %1, %2\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n+\n+;; Vector operations\n+(include \"vect.md\")"}, {"sha": "f4fcd1c2fd66adb520c294c288085cbc05356967", "filename": "gcc/config/ia64/itanium1.md", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fitanium1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fitanium1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fitanium1.md?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -589,6 +589,11 @@\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"ilog\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_A\")\n+(define_insn_reservation \"1_mmalua\" 2\n+    (and (and (eq_attr \"cpu\" \"itanium\")\n+              (eq_attr \"itanium_class\" \"mmalua\"))\n+         (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+    \"1_A\")\n (define_insn_reservation \"1_ishf\"    1\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"ishf\"))\n@@ -920,7 +925,7 @@\n ;; There is only one insn `mov ar.pfs =' for toar_i.\n (define_bypass  0 \"1_tobr,1_topr,1_toar_i\" \"1_br,1_scall\")\n \n-(define_bypass  3 \"1_ialu,1_ialu_addr\" \"1_mmmul,1_mmshf\")\n+(define_bypass  3 \"1_ialu,1_ialu_addr\" \"1_mmmul,1_mmshf,1_mmalua\")\n ;; ??? howto describe ialu for I slot only.  We use ialu_addr for that\n ;;(define_bypass  2 \"1_ialu\" \"1_ld\"  \"ia64_ld_address_bypass_p\")\n ;; ??? howto describe ialu st/address for I slot only.  We use ialu_addr\n@@ -940,7 +945,7 @@\n \n ;; Intel docs say only LD, ST, IALU, ILOG, ISHF consumers have latency 4,\n ;;      but HP engineers say any non-MM operation.\n-(define_bypass  4 \"1_mmmul,1_mmshf\"\n+(define_bypass  4 \"1_mmmul,1_mmshf,1_mmalua\"\n      \"1_br,1_fcmp,1_fcvtfx,1_fld,1_fmac,1_fmisc,1_frar_i,1_frar_m,\\\n       1_frbr,1_frfr,1_frpr,1_ialu,1_icmp,1_ilog,1_ishf,1_ld,1_chk_s,\\\n       1_long_i,1_rse_m,1_sem,1_stf,1_st,1_syst_m0,1_syst_m,\\\n@@ -958,13 +963,13 @@\n ;; We don't use here fcmp because scall may be predicated.\n (define_bypass  0 \"1_fcvtfx,1_fld,1_fmac,1_fmisc,1_frar_i,1_frar_m,\\\n                    1_frbr,1_frfr,1_frpr,1_ialu,1_ialu_addr,1_ilog,1_ishf,\\\n-\t           1_ld,1_long_i,1_mmmul,1_mmshf,1_mmshfi,1_toar_m,1_tofr,\\\n-                   1_xmpy,1_xtd\" \"1_scall\")\n+\t           1_ld,1_long_i,2_mmalua,1_mmmul,1_mmshf,1_mmshfi,1_toar_m,\\\n+\t\t   1_tofr,1_xmpy,1_xtd\" \"1_scall\")\n \n (define_bypass  0 \"1_unknown,1_ignore,1_stop_bit,1_br,1_fcmp,1_fcvtfx,\\\n                    1_fld,1_fmac,1_fmisc,1_frar_i,1_frar_m,1_frbr,1_frfr,\\\n                    1_frpr,1_ialu,1_ialu_addr,1_icmp,1_ilog,1_ishf,1_ld,\\\n-                   1_chk_s,1_long_i,1_mmmul,1_mmshf,1_mmshfi,1_nop,\\\n+                   1_chk_s,1_long_i,1_mmalua,1_mmmul,1_mmshf,1_mmshfi,1_nop,\\\n                    1_nop_b,1_nop_f,1_nop_i,1_nop_m,1_nop_x,1_rse_m,1_scall,\\\n                    1_sem,1_stf,1_st,1_syst_m0,1_syst_m,1_tbit,1_toar_i,\\\n                    1_toar_m,1_tobr,1_tofr,1_topr,1_xmpy,1_xtd,1_lfetch\"\n@@ -1458,6 +1463,10 @@\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"ilog\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_A\")\n+(define_insn_reservation \"1b_mmalua\"  2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"mmalua\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_A\")\n (define_insn_reservation \"1b_ishf\"    1\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"ishf\"))"}, {"sha": "ad24d19931e6a4d13b023a808f500b62ffec3fe9", "filename": "gcc/config/ia64/itanium2.md", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fitanium2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fitanium2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fitanium2.md?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -786,6 +786,10 @@\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"ilog\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_A\")\n+(define_insn_reservation \"2_mmalua\"  2\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"mmalua\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_A\")\n ;; Latency time ???\n (define_insn_reservation \"2_ishf\"    1\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n@@ -1016,23 +1020,24 @@\n (define_bypass  0 \"2_tbit\" \"2_br,2_scall\")\n (define_bypass  2 \"2_ld\" \"2_ld\"  \"ia64_ld_address_bypass_p\")\n (define_bypass  2 \"2_ld\" \"2_st\"  \"ia64_st_address_bypass_p\")\n-(define_bypass  2 \"2_ld\" \"2_mmmul,2_mmshf\")\n-(define_bypass  3 \"2_ilog\" \"2_mmmul,2_mmshf\")\n-(define_bypass  3 \"2_ialu\" \"2_mmmul,2_mmshf\")\n-(define_bypass  3 \"2_mmmul,2_mmshf\" \"2_ialu,2_ilog,2_ishf,2_st,2_ld\")\n+(define_bypass  2 \"2_ld\" \"2_mmalua,2_mmmul,2_mmshf\")\n+(define_bypass  3 \"2_ilog\" \"2_mmalua,2_mmmul,2_mmshf\")\n+(define_bypass  3 \"2_ialu\" \"2_mmalua,2_mmmul,2_mmshf\")\n+(define_bypass  3 \"2_mmalua,2_mmmul,2_mmshf\" \"2_ialu,2_ilog,2_ishf,2_st,2_ld\")\n (define_bypass  6 \"2_tofr\"  \"2_frfr,2_stf\")\n (define_bypass  7 \"2_fmac\"  \"2_frfr,2_stf\")\n \n ;; We don't use here fcmp because scall may be predicated.\n (define_bypass  0 \"2_fcvtfx,2_fld,2_fmac,2_fmisc,2_frar_i,2_frar_m,\\\n                    2_frbr,2_frfr,2_frpr,2_ialu,2_ilog,2_ishf,2_ld,2_long_i,\\\n-                   2_mmmul,2_mmshf,2_mmshfi,2_toar_m,2_tofr,2_xmpy,2_xtd\"\n+                   2_mmalua,2_mmmul,2_mmshf,2_mmshfi,2_toar_m,2_tofr,\\\n+\t\t   2_xmpy,2_xtd\"\n                   \"2_scall\")\n \n (define_bypass  0 \"2_unknown,2_ignore,2_stop_bit,2_br,2_fcmp,2_fcvtfx,2_fld,\\\n                    2_fmac,2_fmisc,2_frar_i,2_frar_m,2_frbr,2_frfr,2_frpr,\\\n-                   2_ialu,2_icmp,2_ilog,2_ishf,2_ld,2_chk_s,\\\n-                   2_long_i,2_mmmul,2_mmshf,2_mmshfi,2_nop,2_nop_b,2_nop_f,\\\n+                   2_ialu,2_icmp,2_ilog,2_ishf,2_ld,2_chk_s,2_long_i,\\\n+\t\t   2_mmalua,2_mmmul,2_mmshf,2_mmshfi,2_nop,2_nop_b,2_nop_f,\\\n                    2_nop_i,2_nop_m,2_nop_x,2_rse_m,2_scall,2_sem,2_stf,2_st,\\\n                    2_syst_m0,2_syst_m,2_tbit,2_toar_i,2_toar_m,2_tobr,2_tofr,\\\n                    2_topr,2_xmpy,2_xtd,2_lfetch\" \"2_ignore\")\n@@ -1586,6 +1591,10 @@\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"ilog\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_A\")\n+(define_insn_reservation \"2b_mmalua\"  2\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"mmalua\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_A\")\n ;; Latency time ???\n (define_insn_reservation \"2b_ishf\"    1\n   (and (and (eq_attr \"cpu\" \"itanium2\")"}, {"sha": "7c9a76f1dce02b5b7ac9770311faf1498cbad77c", "filename": "gcc/config/ia64/predicates.md", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fpredicates.md?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -236,8 +236,8 @@\n ;; True if OP is a GR register operand, or zero.\n (define_predicate \"gr_reg_or_0_operand\"\n   (ior (match_operand 0 \"gr_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"op == const0_rtx\"))))\n+       (and (match_code \"const_int,const_double,const_vector\")\n+\t    (match_test \"op == CONST0_RTX (GET_MODE (op))\"))))\n \n ;; True if OP is a GR register operand, or a 5 bit immediate operand.\n (define_predicate \"gr_reg_or_5bit_operand\"\n@@ -320,6 +320,10 @@\n                     INTVAL (op) == 1   || INTVAL (op) == 4  ||\n                     INTVAL (op) == 8   || INTVAL (op) == 16\")))\n \n+;; True if OP is 0..3.\n+(define_predicate \"const_int_2bit_operand\"\n+  (and (match_code \"const_int\")\n+        (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 3\")))\n \n ;; True if OP is a floating-point constant zero, one, or a register.\n (define_predicate \"fr_reg_or_fp01_operand\"\n@@ -332,6 +336,12 @@\n   (and (match_operand 0 \"fr_reg_or_fp01_operand\")\n        (not (match_code \"subreg\"))))\n \n+;; True if OP is a constant zero, or a register.\n+(define_predicate \"fr_reg_or_0_operand\"\n+  (ior (match_operand 0 \"fr_register_operand\")\n+       (and (match_code \"const_double,const_vector\")\n+\t    (match_test \"op == CONST0_RTX (GET_MODE (op))\"))))\n+\n ;; True if this is a comparison operator, which accepts a normal 8-bit\n ;; signed immediate operand.\n (define_predicate \"normal_comparison_operator\""}, {"sha": "a42ad2a2dc130e476c87e37b00b6ea145ac7e69d", "filename": "gcc/config/ia64/vect.md", "status": "added", "additions": 996, "deletions": 0, "changes": 996, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fvect.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Fconfig%2Fia64%2Fvect.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvect.md?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -0,0 +1,996 @@\n+;; IA-64 machine description for vector operations.\n+;; Copyright (C) 2004\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+\n+;; Integer vector operations\n+\n+(define_mode_macro VECINT [V8QI V4HI V2SI])\n+(define_mode_macro VECINT12 [V8QI V4HI])\n+(define_mode_macro VECINT24 [V4HI V2SI])\n+(define_mode_attr vecsize [(V8QI \"1\") (V4HI \"2\") (V2SI \"4\")])\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:VECINT 0 \"general_operand\" \"\")\n+        (match_operand:VECINT 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  rtx op1 = ia64_expand_move (operands[0], operands[1]);\n+  if (!op1)\n+    DONE;\n+  operands[1] = op1;\n+})\n+\n+(define_insn \"*mov<mode>_internal\"\n+  [(set (match_operand:VECINT 0 \"destination_operand\"\n+\t\t\t\t\t\"=r,r,r,r,m ,*f ,*f,Q ,r ,*f\")\n+\t(match_operand:VECINT 1 \"move_operand\"\n+\t\t\t\t\t\"rU,W,i,m,rU,U*f,Q ,*f,*f,r \"))]\n+  \"ia64_move_ok (operands[0], operands[1])\"\n+  \"@\n+   mov %0 = %r1\n+   addl %0 = %v1, r0\n+   movl %0 = %v1\n+   ld8%O1 %0 = %1%P1\n+   st8%Q0 %0 = %r1%P0\n+   mov %0 = %F1\n+   ldf8 %0 = %1%P1\n+   stf8 %0 = %1%P0\n+   getf.sig %0 = %1\n+   setf.sig %0 = %1\"\n+  [(set_attr \"itanium_class\" \"ialu,ialu,long_i,ld,st,fmisc,fld,stf,frfr,tofr\")])\n+\n+(define_insn \"one_cmpl<mode>2\"\n+  [(set (match_operand:VECINT 0 \"gr_register_operand\" \"=r\")\n+\t(not:VECINT (match_operand:VECINT 1 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"andcm %0 = -1, %1\"\n+  [(set_attr \"itanium_class\" \"ilog\")])\n+\n+(define_insn \"and<mode>3\"\n+  [(set (match_operand:VECINT 0 \"grfr_register_operand\" \"=r,*f\")\n+\t(and:VECINT\n+\t  (match_operand:VECINT 1 \"grfr_register_operand\" \"r,*f\")\n+\t  (match_operand:VECINT 2 \"grfr_reg_or_8bit_operand\" \"r,*f\")))]\n+  \"\"\n+  \"@\n+   and %0 = %2, %1\n+   fand %0 = %2, %1\"\n+  [(set_attr \"itanium_class\" \"ilog,fmisc\")])\n+\n+(define_insn \"*andnot<mode>\"\n+  [(set (match_operand:VECINT 0 \"grfr_register_operand\" \"=r,*f\")\n+\t(and:VECINT\n+\t  (not:VECINT (match_operand:VECINT 1 \"grfr_register_operand\" \"r,*f\"))\n+\t  (match_operand:VECINT 2 \"grfr_reg_or_8bit_operand\" \"r,*f\")))]\n+  \"\"\n+  \"@\n+   andcm %0 = %2, %1\n+   fandcm %0 = %2, %1\"\n+  [(set_attr \"itanium_class\" \"ilog,fmisc\")])\n+\n+(define_insn \"ior<mode>3\"\n+  [(set (match_operand:VECINT 0 \"grfr_register_operand\" \"=r,*f\")\n+\t(ior:VECINT\n+\t  (match_operand:VECINT 1 \"grfr_register_operand\" \"r,*f\")\n+\t  (match_operand:VECINT 2 \"grfr_reg_or_8bit_operand\" \"r,*f\")))]\n+  \"\"\n+  \"@\n+   or %0 = %2, %1\n+   for %0 = %2, %1\"\n+  [(set_attr \"itanium_class\" \"ilog,fmisc\")])\n+\n+(define_insn \"xor<mode>3\"\n+  [(set (match_operand:VECINT 0 \"grfr_register_operand\" \"=r,*f\")\n+\t(xor:VECINT\n+\t  (match_operand:VECINT 1 \"grfr_register_operand\" \"r,*f\")\n+\t  (match_operand:VECINT 2 \"grfr_reg_or_8bit_operand\" \"r,*f\")))]\n+  \"\"\n+  \"@\n+   xor %0 = %2, %1\n+   fxor %0 = %2, %1\"\n+  [(set_attr \"itanium_class\" \"ilog,fmisc\")])\n+\n+(define_insn \"neg<mode>2\"\n+  [(set (match_operand:VECINT 0 \"gr_register_operand\" \"=r\")\n+\t(neg:VECINT (match_operand:VECINT 1 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"psub<vecsize> %0 = r0, %1\"\n+  [(set_attr \"itanium_class\" \"mmalua\")])\n+\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:VECINT 0 \"gr_register_operand\" \"=r\")\n+\t(plus:VECINT (match_operand:VECINT 1 \"gr_register_operand\" \"r\")\n+\t\t     (match_operand:VECINT 2 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"padd<vecsize> %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"mmalua\")])\n+\n+(define_insn \"*ssadd<mode>3\"\n+  [(set (match_operand:VECINT12 0 \"gr_register_operand\" \"=r\")\n+\t(ss_plus:VECINT12\n+\t  (match_operand:VECINT12 1 \"gr_register_operand\" \"r\")\n+\t  (match_operand:VECINT12 2 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"padd<vecsize>.sss %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"mmalua\")])\n+\n+(define_insn \"*usadd<mode>3\"\n+  [(set (match_operand:VECINT12 0 \"gr_register_operand\" \"=r\")\n+\t(us_plus:VECINT12\n+\t  (match_operand:VECINT12 1 \"gr_register_operand\" \"r\")\n+\t  (match_operand:VECINT12 2 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"padd<vecsize>.uuu %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"mmalua\")])\n+\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:VECINT 0 \"gr_register_operand\" \"=r\")\n+\t(minus:VECINT (match_operand:VECINT 1 \"gr_register_operand\" \"r\")\n+\t\t      (match_operand:VECINT 2 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"psub<vecsize> %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"mmalua\")])\n+\n+(define_insn \"*sssub<mode>3\"\n+  [(set (match_operand:VECINT12 0 \"gr_register_operand\" \"=r\")\n+\t(ss_minus:VECINT12\n+\t  (match_operand:VECINT12 1 \"gr_register_operand\" \"r\")\n+\t  (match_operand:VECINT12 2 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"psub<vecsize>.sss %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"mmalua\")])\n+\n+(define_insn \"*ussub<mode>3\"\n+  [(set (match_operand:VECINT12 0 \"gr_register_operand\" \"=r\")\n+\t(us_minus:VECINT12\n+\t  (match_operand:VECINT12 1 \"gr_register_operand\" \"r\")\n+\t  (match_operand:VECINT12 2 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"psub<vecsize>.uuu %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"mmalua\")])\n+\n+(define_expand \"mulv8qi3\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"\")\n+\t(mult:V8QI (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n+\t\t   (match_operand:V8QI 2 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+{\n+  rtx l1, h1, l2, h2, lm, hm, lz, hz;\n+\n+  l1 = gen_reg_rtx (V4HImode);\n+  h1 = gen_reg_rtx (V4HImode);\n+  l2 = gen_reg_rtx (V4HImode);\n+  h2 = gen_reg_rtx (V4HImode);\n+\n+  /* Zero-extend the QImode elements into two words of HImode elements.  */\n+  emit_insn (gen_unpack1_l (gen_lowpart (V8QImode, l1),\n+\t\t\t    operands[1], CONST0_RTX (V8QImode)));\n+  emit_insn (gen_unpack1_l (gen_lowpart (V8QImode, l2),\n+\t\t\t    operands[2], CONST0_RTX (V8QImode)));\n+  emit_insn (gen_unpack1_h (gen_lowpart (V8QImode, h1),\n+\t\t\t    operands[1], CONST0_RTX (V8QImode)));\n+  emit_insn (gen_unpack1_h (gen_lowpart (V8QImode, h2),\n+\t\t\t    operands[2], CONST0_RTX (V8QImode)));\n+\n+  /* Multiply.  */\n+  lm = gen_reg_rtx (V4HImode);\n+  hm = gen_reg_rtx (V4HImode);\n+  emit_insn (gen_mulv4hi3 (lm, l1, l2));\n+  emit_insn (gen_mulv4hi3 (hm, h1, h2));\n+\n+  /* Zap the high order bytes of the HImode elements.  There are several\n+     ways that this could be done.  On Itanium2, there's 1 cycle latency\n+     moving between the ALU units and the PALU units, so using AND would\n+     be 3 cycles latency into the eventual pack insn, whereas using MIX\n+     is only 2 cycles.  */\n+  lz = gen_reg_rtx (V4HImode);\n+  hz = gen_reg_rtx (V4HImode);\n+  emit_insn (gen_mix1_r (gen_lowpart (V8QImode, lz),\n+\t\t\t gen_lowpart (V8QImode, lm), CONST0_RTX (V8QImode)));\n+  emit_insn (gen_mix1_r (gen_lowpart (V8QImode, lz),\n+\t\t\t gen_lowpart (V8QImode, lm), CONST0_RTX (V8QImode)));\n+\n+  /* Repack the HImode elements as QImode elements.  */\n+  emit_insn (gen_pack2_sss (operands[0], lz, hz));\n+  DONE;\n+})\n+\n+(define_insn \"mulv4hi3\"\n+  [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n+\t(mult:V4HI (match_operand:V4HI 1 \"gr_register_operand\" \"r\")\n+\t\t   (match_operand:V4HI 2 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"pmpyshr2 %0 = %1, %2, 0\"\n+  [(set_attr \"itanium_class\" \"mmalua\")])\n+\n+(define_expand \"umax<mode>3\"\n+  [(set (match_operand:VECINT 0 \"gr_register_operand\" \"\")\n+\t(smax:VECINT (match_operand:VECINT 1 \"gr_register_operand\" \"\")\n+\t\t     (match_operand:VECINT 2 \"gr_register_operand\" \"\")))]\n+  \"\"\n+{\n+  if (ia64_expand_vecint_minmax (UMAX, <MODE>mode, operands))\n+    DONE;\n+})\n+\n+(define_expand \"smax<mode>3\"\n+  [(set (match_operand:VECINT 0 \"gr_register_operand\" \"\")\n+\t(smax:VECINT (match_operand:VECINT 1 \"gr_reg_or_0_operand\" \"\")\n+\t\t     (match_operand:VECINT 2 \"gr_reg_or_0_operand\" \"\")))]\n+  \"\"\n+{\n+  if (ia64_expand_vecint_minmax (SMAX, <MODE>mode, operands))\n+    DONE;\n+})\n+\n+(define_expand \"umin<mode>3\"\n+  [(set (match_operand:VECINT 0 \"gr_register_operand\" \"\")\n+\t(umin:VECINT (match_operand:VECINT 1 \"gr_register_operand\" \"\")\n+\t\t     (match_operand:VECINT 2 \"gr_register_operand\" \"\")))]\n+  \"\"\n+{\n+  if (ia64_expand_vecint_minmax (UMIN, <MODE>mode, operands))\n+    DONE;\n+})\n+\n+(define_expand \"smin<mode>3\"\n+  [(set (match_operand:VECINT 0 \"gr_register_operand\" \"\")\n+\t(smin:VECINT (match_operand:VECINT 1 \"gr_reg_or_0_operand\" \"\")\n+\t\t     (match_operand:VECINT 2 \"gr_reg_or_0_operand\" \"\")))]\n+  \"\"\n+{\n+  if (ia64_expand_vecint_minmax (SMIN, <MODE>mode, operands))\n+    DONE;\n+})\n+\n+(define_insn \"*umaxv8qi3\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(umax:V8QI (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n+\t\t   (match_operand:V8QI 2 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"pmax1.u %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*smaxv4hi3\"\n+  [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n+\t(smax:V4HI (match_operand:V4HI 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t\t   (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\")))]\n+  \"\"\n+  \"pmax2 %0 = %r1, %r2\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*uminv8qi3\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(umin:V8QI (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n+\t\t   (match_operand:V8QI 2 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"pmin1.u %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*sminv4hi3\"\n+  [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n+\t(smin:V4HI (match_operand:V4HI 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t\t   (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\")))]\n+  \"\"\n+  \"pmin2 %0 = %r1, %r2\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"ashl<mode>3\"\n+  [(set (match_operand:VECINT24 0 \"gr_register_operand\" \"=r\")\n+\t(ashift:VECINT24\n+\t  (match_operand:VECINT24 1 \"gr_register_operand\" \"r\")\n+\t  (match_operand:VECINT24 2 \"gr_reg_or_5bit_operand\" \"rn\")))]\n+  \"\"\n+  \"pshl<vecsize> %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"ashr<mode>3\"\n+  [(set (match_operand:VECINT24 0 \"gr_register_operand\" \"=r\")\n+\t(ashiftrt:VECINT24\n+\t  (match_operand:VECINT24 1 \"gr_register_operand\" \"r\")\n+\t  (match_operand:VECINT24 2 \"gr_reg_or_5bit_operand\" \"rn\")))]\n+  \"\"\n+  \"pshr<vecsize> %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"lshr<mode>3\"\n+  [(set (match_operand:VECINT24 0 \"gr_register_operand\" \"=r\")\n+\t(lshiftrt:VECINT24\n+\t  (match_operand:VECINT24 1 \"gr_register_operand\" \"r\")\n+\t  (match_operand:VECINT24 2 \"gr_reg_or_5bit_operand\" \"rn\")))]\n+  \"\"\n+  \"pshr<vecsize>.u %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_expand \"vcond<mode>\"\n+  [(set (match_operand:VECINT 0 \"gr_register_operand\" \"\")\n+\t(if_then_else:VECINT\n+\t  (match_operator 3 \"\" \n+\t    [(match_operand:VECINT 4 \"gr_reg_or_0_operand\" \"\")\n+\t     (match_operand:VECINT 5 \"gr_reg_or_0_operand\" \"\")])\n+\t  (match_operand:VECINT 1 \"gr_reg_or_0_operand\" \"\")\n+\t  (match_operand:VECINT 2 \"gr_reg_or_0_operand\" \"\")))]\n+  \"\"\n+{\n+  ia64_expand_vecint_cmov (operands);\n+  DONE;\n+})\n+\n+(define_expand \"vcondu<mode>\"\n+  [(set (match_operand:VECINT 0 \"gr_register_operand\" \"\")\n+\t(if_then_else:VECINT\n+\t  (match_operator 3 \"\" \n+\t    [(match_operand:VECINT 4 \"gr_reg_or_0_operand\" \"\")\n+\t     (match_operand:VECINT 5 \"gr_reg_or_0_operand\" \"\")])\n+\t  (match_operand:VECINT 1 \"gr_reg_or_0_operand\" \"\")\n+\t  (match_operand:VECINT 2 \"gr_reg_or_0_operand\" \"\")))]\n+  \"\"\n+{\n+  ia64_expand_vecint_cmov (operands);\n+  DONE;\n+})\n+\n+(define_insn \"*cmpeq_<mode>\"\n+  [(set (match_operand:VECINT 0 \"gr_register_operand\" \"=r\")\n+\t(eq:VECINT (match_operand:VECINT 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t\t   (match_operand:VECINT 2 \"gr_reg_or_0_operand\" \"rU\")))]\n+  \"\"\n+  \"pcmp<vecsize>.eq %0 = %r1, %r2\"\n+  [(set_attr \"itanium_class\" \"mmalua\")])\n+\n+(define_insn \"*cmpgt_<mode>\"\n+  [(set (match_operand:VECINT 0 \"gr_register_operand\" \"=r\")\n+\t(gt:VECINT (match_operand:VECINT 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t\t   (match_operand:VECINT 2 \"gr_reg_or_0_operand\" \"rU\")))]\n+  \"\"\n+  \"pcmp<vecsize>.gt %0 = %r1, %r2\"\n+  [(set_attr \"itanium_class\" \"mmalua\")])\n+\n+(define_insn \"pack2_sss\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_concat:V8QI\n+\t  (ss_truncate:V4QI\n+\t    (match_operand:V4HI 1 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (ss_truncate:V4QI\n+\t    (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\"))))]\n+  \"\"\n+  \"pack2.sss %0 = %r1, %r2\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*pack2_uss\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_concat:V8QI\n+\t  (us_truncate:V4QI\n+\t    (match_operand:V4HI 1 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (us_truncate:V4QI\n+\t    (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\"))))]\n+  \"\"\n+  \"pack2.uss %0 = %r1, %r2\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"pack4_sss\"\n+  [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_concat:V4HI\n+\t  (ss_truncate:V2HI\n+\t    (match_operand:V2SI 1 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (ss_truncate:V2HI\n+\t    (match_operand:V2SI 2 \"gr_reg_or_0_operand\" \"rU\"))))]\n+  \"\"\n+  \"pack4.sss %0 = %r1, %r2\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"unpack1_l\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V8QI\n+\t  (vec_concat:V16QI\n+\t    (match_operand:V8QI 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t    (match_operand:V8QI 2 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (parallel [(const_int 0)\n+\t\t     (const_int 1)\n+\t\t     (const_int 2)\n+\t\t     (const_int 3)\n+\t\t     (const_int 8)\n+\t\t     (const_int 9)\n+\t\t     (const_int 10)\n+\t\t     (const_int 11)])))]\n+  \"\"\n+  \"unpack1.l %0 = %r2, %r1\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"unpack1_h\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V8QI\n+\t  (vec_concat:V16QI\n+\t    (match_operand:V8QI 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t    (match_operand:V8QI 2 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (parallel [(const_int 4)\n+\t\t     (const_int 5)\n+\t\t     (const_int 6)\n+\t\t     (const_int 7)\n+\t\t     (const_int 12)\n+\t\t     (const_int 13)\n+\t\t     (const_int 14)\n+\t\t     (const_int 15)])))]\n+  \"\"\n+  \"unpack1.h %0 = %r2, %r1\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"mix1_r\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V8QI\n+\t  (vec_concat:V16QI\n+\t    (match_operand:V8QI 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t    (match_operand:V8QI 2 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (parallel [(const_int 0)\n+\t\t     (const_int 8)\n+\t\t     (const_int 2)\n+\t\t     (const_int 10)\n+\t\t     (const_int 4)\n+\t\t     (const_int 12)\n+\t\t     (const_int 6)\n+\t\t     (const_int 14)])))]\n+  \"\"\n+  \"mix1.r %0 = %r2, %r1\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*mix1_l\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V8QI\n+\t  (vec_concat:V16QI\n+\t    (match_operand:V8QI 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t    (match_operand:V8QI 2 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (parallel [(const_int 1)\n+\t\t     (const_int 9)\n+\t\t     (const_int 3)\n+\t\t     (const_int 11)\n+\t\t     (const_int 5)\n+\t\t     (const_int 13)\n+\t\t     (const_int 7)\n+\t\t     (const_int 15)])))]\n+  \"\"\n+  \"mix1.l %0 = %r2, %r1\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*mux1_rev\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V8QI\n+\t  (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n+\t  (parallel [(const_int 7)\n+\t\t     (const_int 6)\n+\t\t     (const_int 5)\n+\t\t     (const_int 4)\n+\t\t     (const_int 3)\n+\t\t     (const_int 2)\n+\t\t     (const_int 1)\n+\t\t     (const_int 0)])))]\n+  \"\"\n+  \"mux1 %0 = %1, @rev\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*mux1_mix\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V8QI\n+\t  (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n+\t  (parallel [(const_int 0)\n+\t\t     (const_int 4)\n+\t\t     (const_int 2)\n+\t\t     (const_int 6)\n+\t\t     (const_int 1)\n+\t\t     (const_int 5)\n+\t\t     (const_int 3)\n+\t\t     (const_int 7)])))]\n+  \"\"\n+  \"mux1 %0 = %1, @mix\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*mux1_shuf\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V8QI\n+\t  (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n+\t  (parallel [(const_int 0)\n+\t\t     (const_int 4)\n+\t\t     (const_int 1)\n+\t\t     (const_int 5)\n+\t\t     (const_int 2)\n+\t\t     (const_int 6)\n+\t\t     (const_int 3)\n+\t\t     (const_int 7)])))]\n+  \"\"\n+  \"mux1 %0 = %1, @shuf\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*mux1_alt\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V8QI\n+\t  (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n+\t  (parallel [(const_int 0)\n+\t\t     (const_int 2)\n+\t\t     (const_int 4)\n+\t\t     (const_int 6)\n+\t\t     (const_int 1)\n+\t\t     (const_int 3)\n+\t\t     (const_int 5)\n+\t\t     (const_int 7)])))]\n+  \"\"\n+  \"mux1 %0 = %1, @alt\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*mux1_brcst_v8qi\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V8QI\n+\t  (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n+\t  (parallel [(const_int 0)\n+\t\t     (const_int 0)\n+\t\t     (const_int 0)\n+\t\t     (const_int 0)\n+\t\t     (const_int 0)\n+\t\t     (const_int 0)\n+\t\t     (const_int 0)\n+\t\t     (const_int 0)])))]\n+  \"\"\n+  \"mux1 %0 = %1, @brcst\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*mux1_brcst_qi\"\n+  [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_duplicate:V8QI\n+\t  (match_operand:QI 1 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"mux1 %0 = %1, @brcst\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"unpack2_l\"\n+  [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V4HI\n+\t  (vec_concat:V8HI\n+\t    (match_operand:V4HI 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t    (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (parallel [(const_int 0)\n+\t\t     (const_int 4)\n+\t\t     (const_int 1)\n+\t\t     (const_int 5)])))]\n+  \"\"\n+  \"unpack2.l %0 = %r2, %r1\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"unpack2_h\"\n+  [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V4HI\n+\t  (vec_concat:V8HI\n+\t    (match_operand:V4HI 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t    (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (parallel [(const_int 2)\n+\t\t     (const_int 6)\n+\t\t     (const_int 3)\n+\t\t     (const_int 7)])))]\n+  \"\"\n+  \"unpack2.h %0 = %r2, %r1\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*mix2_r\"\n+  [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V4HI\n+\t  (vec_concat:V8HI\n+\t    (match_operand:V4HI 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t    (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (parallel [(const_int 0)\n+\t\t     (const_int 4)\n+\t\t     (const_int 2)\n+\t\t     (const_int 6)])))]\n+  \"\"\n+  \"mix2.r %0 = %r2, %r1\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*mix2_l\"\n+  [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V4HI\n+\t  (vec_concat:V8HI\n+\t    (match_operand:V4HI 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t    (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (parallel [(const_int 1)\n+\t\t     (const_int 5)\n+\t\t     (const_int 3)\n+\t\t     (const_int 7)])))]\n+  \"\"\n+  \"mix2.l %0 = %r2, %r1\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*mux2\"\n+  [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V4HI\n+\t  (match_operand:V4HI 1 \"gr_register_operand\" \"r\")\n+\t  (parallel [(match_operand 2 \"const_int_2bit_operand\" \"\")\n+\t\t     (match_operand 3 \"const_int_2bit_operand\" \"\")\n+\t\t     (match_operand 4 \"const_int_2bit_operand\" \"\")\n+\t\t     (match_operand 5 \"const_int_2bit_operand\" \"\")])))]\n+  \"\"\n+{\n+  int mask;\n+  mask  = INTVAL (operands[2]);\n+  mask |= INTVAL (operands[3]) << 2;\n+  mask |= INTVAL (operands[4]) << 4;\n+  mask |= INTVAL (operands[5]) << 6;\n+  operands[2] = GEN_INT (mask);\n+  return \"%,mux2 %0 = %1, %2\";\n+}\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_insn \"*mux2_brcst_hi\"\n+  [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_duplicate:V4HI\n+\t  (match_operand:HI 1 \"gr_register_operand\" \"r\")))]\n+  \"\"\n+  \"mux2 %0 = %1, 0\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+;; Note that mix4.r performs the exact same operation.\n+(define_insn \"*unpack4_l\"\n+  [(set (match_operand:V2SI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V2SI\n+\t  (vec_concat:V4SI\n+\t    (match_operand:V2SI 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t    (match_operand:V2SI 2 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (parallel [(const_int 0)\n+\t\t     (const_int 2)])))]\n+  \"\"\n+  \"unpack4.l %0 = %r2, %r1\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+;; Note that mix4.l performs the exact same operation.\n+(define_insn \"*unpack4_h\"\n+  [(set (match_operand:V2SI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_select:V2SI\n+\t  (vec_concat:V4SI\n+\t    (match_operand:V2SI 1 \"gr_reg_or_0_operand\" \"rU\")\n+\t    (match_operand:V2SI 2 \"gr_reg_or_0_operand\" \"rU\"))\n+\t  (parallel [(const_int 1)\n+\t\t     (const_int 3)])))]\n+  \"\"\n+  \"unpack4.h %0 = %r2, %r1\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+(define_expand \"vec_initv2si\"\n+  [(match_operand:V2SF 0 \"gr_register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"\"\n+{\n+  rtx op1 = XVECEXP (operands[1], 0, 0);\n+  rtx op2 = XVECEXP (operands[1], 0, 1);\n+  rtx x;\n+\n+  if (GET_CODE (op1) == CONST_INT && GET_CODE (op2) == CONST_INT)\n+    {\n+      x = gen_rtx_CONST_VECTOR (V2SImode, XVEC (operands[1], 0));\n+      emit_move_insn (operands[0], x);\n+      DONE;\n+    }\n+\n+  if (!gr_reg_or_0_operand (op1, SImode))\n+    op1 = force_reg (SImode, op1);\n+  if (!gr_reg_or_0_operand (op2, SImode))\n+    op2 = force_reg (SImode, op2);\n+\n+  x = gen_rtx_VEC_CONCAT (V2SImode, op1, op2);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n+  DONE;\n+})\n+\n+(define_insn \"*vecinit_v2si\"\n+  [(set (match_operand:V2SI 0 \"gr_register_operand\" \"=r\")\n+\t(vec_concat:V2SI\n+\t  (match_operand:SI 1 \"gr_reg_or_0_operand\" \"rO\")\n+\t  (match_operand:SI 2 \"gr_reg_or_0_operand\" \"rO\")))]\n+  \"\"\n+  \"unpack4.l %0 = %r2, %r1\"\n+  [(set_attr \"itanium_class\" \"mmshf\")])\n+\n+;; Missing operations\n+;; padd.uus\n+;; pavg\n+;; pavgsub\n+;; pmpy\n+;; pmpyshr, general form\n+;; psad\n+;; pshladd\n+;; pshradd\n+;; psub.uus\n+;; vec_set<mode>\n+;; vec_extract<mode>\n+;; vec_init<mode>\n+\f\n+;; Floating point vector operations\n+\n+(define_expand \"movv2sf\"\n+  [(set (match_operand:V2SF 0 \"general_operand\" \"\")\n+        (match_operand:V2SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  rtx op1 = ia64_expand_move (operands[0], operands[1]);\n+  if (!op1)\n+    DONE;\n+  operands[1] = op1;\n+})\n+\n+(define_insn \"*movv2sf_internal\"\n+  [(set (match_operand:V2SF 0 \"destination_operand\"\n+\t\t\t\t\t\"=f,f,f,Q,*r ,*r,*r,*r,m ,f ,*r\")\n+\t(match_operand:V2SF 1 \"move_operand\"\n+\t\t\t\t\t\"fU,Y,Q,f,U*r,W ,i ,m ,*r,*r,f \"))]\n+  \"ia64_move_ok (operands[0], operands[1])\"\n+{\n+  static const char * const alt[] = {\n+    \"%,mov %0 = %F1\",\n+    \"%,fpack %0 = %F2, %F1\",\n+    \"%,ldf8 %0 = %1%P1\",\n+    \"%,stf8 %0 = %1%P0\",\n+    \"%,mov %0 = %r1\",\n+    \"%,addl %0 = %v1, r0\",\n+    \"%,movl %0 = %v1\",\n+    \"%,ld8%O1 %0 = %1%P1\",\n+    \"%,st8%Q0 %0 = %r1%P0\",\n+    \"%,setf.sig %0 = %1\",\n+    \"%,getf.sig %0 = %1\"\n+  };\n+\n+  if (which_alternative == 1)\n+    {\n+      operands[2] = XVECEXP (operands[1], 0, 1);\n+      operands[1] = XVECEXP (operands[1], 0, 0);\n+    }\n+\n+  return alt[which_alternative];\n+}\n+  [(set_attr \"itanium_class\" \"fmisc,fmisc,fld,stf,ialu,ialu,long_i,ld,st,tofr,frfr\")])\n+\n+(define_insn \"absv2sf2\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(abs:V2SF (match_operand:V2SF 1 \"fr_register_operand\" \"f\")))]\n+  \"\"\n+  \"fpabs %0 = %1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+(define_insn \"negv2sf2\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(neg:V2SF (match_operand:V2SF 1 \"fr_register_operand\" \"f\")))]\n+  \"\"\n+  \"fpneg %0 = %1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+(define_insn \"*negabsv2sf2\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(neg:V2SF\n+\t  (abs:V2SF (match_operand:V2SF 1 \"fr_register_operand\" \"f\"))))]\n+  \"\"\n+  \"fpnegabs %0 = %1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+(define_expand \"addv2sf3\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"\")\n+\t(plus:V2SF\n+\t  (mult:V2SF (match_operand:V2SF 1 \"fr_register_operand\" \"\")\n+\t\t     (match_dup 3))\n+\t  (match_operand:V2SF 2 \"fr_register_operand\" \"\")))]\n+  \"\"\n+{\n+  rtvec v = gen_rtvec (2, CONST1_RTX (SFmode), CONST1_RTX (SFmode));\n+  operands[3] = force_reg (V2SFmode, gen_rtx_CONST_VECTOR (V2SFmode, v));\n+})\n+\n+(define_expand \"subv2sf3\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"\")\n+\t(minus:V2SF\n+\t  (mult:V2SF (match_operand:V2SF 1 \"fr_register_operand\" \"\")\n+\t\t     (match_dup 3))\n+\t  (match_operand:V2SF 2 \"fr_register_operand\" \"\")))]\n+  \"\"\n+{\n+  rtvec v = gen_rtvec (2, CONST1_RTX (SFmode), CONST1_RTX (SFmode));\n+  operands[3] = force_reg (V2SFmode, gen_rtx_CONST_VECTOR (V2SFmode, v));\n+})\n+\n+(define_insn \"mulv2sf3\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(mult:V2SF (match_operand:V2SF 1 \"fr_register_operand\" \"f\")\n+\t\t   (match_operand:V2SF 2 \"fr_register_operand\" \"f\")))]\n+  \"\"\n+  \"fpmpy %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"fmac\")])\n+\n+(define_insn \"*fpma\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(plus:V2SF\n+\t  (mult:V2SF (match_operand:V2SF 1 \"fr_register_operand\" \"f\")\n+\t\t     (match_operand:V2SF 2 \"fr_register_operand\" \"f\"))\n+\t  (match_operand:V2SF 3 \"fr_register_operand\" \"f\")))]\n+  \"\"\n+  \"fpma %0 = %1, %2, %3\"\n+  [(set_attr \"itanium_class\" \"fmac\")])\n+\n+(define_insn \"*fpms\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(minus:V2SF\n+\t  (mult:V2SF (match_operand:V2SF 1 \"fr_register_operand\" \"f\")\n+\t\t     (match_operand:V2SF 2 \"fr_register_operand\" \"f\"))\n+\t  (match_operand:V2SF 3 \"fr_register_operand\" \"f\")))]\n+  \"\"\n+  \"fpms %0 = %1, %2, %3\"\n+  [(set_attr \"itanium_class\" \"fmac\")])\n+\n+(define_insn \"*fpnmpy\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(neg:V2SF\n+\t  (mult:V2SF (match_operand:V2SF 1 \"fr_register_operand\" \"f\")\n+\t\t     (match_operand:V2SF 2 \"fr_register_operand\" \"f\"))))]\n+  \"\"\n+  \"fpnmpy %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"fmac\")])\n+\n+(define_insn \"*fpnma\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(plus:V2SF\n+\t  (neg:V2SF\n+\t    (mult:V2SF (match_operand:V2SF 1 \"fr_register_operand\" \"f\")\n+\t\t       (match_operand:V2SF 2 \"fr_register_operand\" \"f\")))\n+\t  (match_operand:V2SF 3 \"fr_register_operand\" \"f\")))]\n+  \"\"\n+  \"fpnma %0 = %1, %2, %3\"\n+  [(set_attr \"itanium_class\" \"fmac\")])\n+\n+(define_insn \"smaxv2sf2\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(smax:V2SF (match_operand:V2SF 1 \"fr_register_operand\" \"f\")\n+\t\t   (match_operand:V2SF 2 \"fr_register_operand\" \"f\")))]\n+  \"\"\n+  \"fpmax %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+(define_insn \"sminv2sf2\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(smin:V2SF (match_operand:V2SF 1 \"fr_register_operand\" \"f\")\n+\t\t   (match_operand:V2SF 2 \"fr_register_operand\" \"f\")))]\n+  \"\"\n+  \"fpmin %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+(define_expand \"vcondv2sf\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"\")\n+\t(if_then_else:V2SF\n+\t  (match_operator 3 \"\" \n+\t    [(match_operand:V2SF 4 \"fr_reg_or_0_operand\" \"\")\n+\t     (match_operand:V2SF 5 \"fr_reg_or_0_operand\" \"\")])\n+\t  (match_operand:V2SF 1 \"fr_reg_or_0_operand\" \"\")\n+\t  (match_operand:V2SF 2 \"fr_reg_or_0_operand\" \"\")))]\n+  \"\"\n+{\n+  rtx x, cmp;\n+\n+  PUT_MODE (operands[3], V2SFmode);\n+  switch (GET_CODE (operands[3]))\n+    {\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case LE:\n+    case UNORDERED:\n+    case ORDERED:\n+      break;\n+\n+    case GT:\n+    case GE:\n+      x = XEXP (operands[3], 0);\n+      XEXP (operands[3], 0) = XEXP (operands[3], 1);\n+      XEXP (operands[3], 1) = x;\n+      PUT_CODE (operands[3], swap_condition (GET_CODE (operands[3])));\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  cmp = gen_reg_rtx (V2SFmode);\n+  emit_insn (gen_rtx_SET (VOIDmode, cmp, operands[3]));\n+\n+  x = gen_rtx_IF_THEN_ELSE (V2SFmode, cmp, operands[1], operands[2]);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n+  DONE;\n+})\n+\n+(define_insn \"*fpcmp\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(if_then_else:V2SF\n+\t  (match_operand:V2SF 1 \"fr_register_operand\" \"f\")\n+\t  (match_operand:V2SF 2 \"fr_reg_or_0_operand\" \"fU\")\n+\t  (match_operand:V2SF 3 \"fr_reg_or_0_operand\" \"fU\")))]\n+  \"\"\n+  \"fselect %0 = %2, %3, %1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+(define_expand \"vec_initv2sf\"\n+  [(match_operand:V2SF 0 \"fr_register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"\"\n+{\n+  rtx op1 = XVECEXP (operands[1], 0, 0);\n+  rtx op2 = XVECEXP (operands[1], 0, 1);\n+  rtx x;\n+\n+  if (GET_CODE (op1) == CONST_DOUBLE && GET_CODE (op2) == CONST_DOUBLE)\n+    {\n+      x = gen_rtx_CONST_VECTOR (V2SFmode, XVEC (operands[1], 0));\n+      emit_move_insn (operands[0], x);\n+      DONE;\n+    }\n+\n+  if (!fr_reg_or_fp01_operand (op1, SFmode))\n+    op1 = force_reg (SFmode, op1);\n+  if (!fr_reg_or_fp01_operand (op2, SFmode))\n+    op2 = force_reg (SFmode, op2);\n+\n+  x = gen_rtx_VEC_CONCAT (V2SFmode, op1, op2);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n+  DONE;\n+})\n+\n+(define_insn \"*fpack_sfsf\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(vec_concat:V2SF\n+\t  (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n+\t  (match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n+  \"fpack %0 = %F2, %F1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+(define_insn \"*fpack_sfxf\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(vec_concat:V2SF\n+\t  (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n+\t  (float_truncate:SF\n+\t    (match_operand 2 \"fr_register_operand\" \"f\"))))]\n+  \"GET_MODE (operands[2]) == DFmode || GET_MODE (operands[2]) == XFmode\"\n+  \"fpack %0 = %2, %F1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+(define_insn \"*fpack_xfsf\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(vec_concat:V2SF\n+\t  (float_truncate:SF\n+\t    (match_operand 1 \"fr_register_operand\" \"f\"))\n+\t  (match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"fG\")))]\n+  \"GET_MODE (operands[1]) == DFmode || GET_MODE (operands[1]) == XFmode\"\n+  \"fpack %0 = %F2, %1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+(define_insn \"*fpack_xfxf\"\n+  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n+\t(vec_concat:V2SF\n+\t  (float_truncate:SF\n+\t    (match_operand 1 \"fr_register_operand\" \"f\"))\n+\t  (float_truncate:SF\n+\t    (match_operand 2 \"fr_register_operand\" \"f\"))))]\n+  \"(GET_MODE (operands[1]) == DFmode || GET_MODE (operands[1]) == XFmode)\n+   && (GET_MODE (operands[2]) == DFmode || GET_MODE (operands[2]) == XFmode)\"\n+  \"fpack %0 = %2, %1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+;; Missing operations\n+;; fprcpa\n+;; fpsqrta\n+;; vec_setv2sf\n+;; vec_extractv2sf"}, {"sha": "56e4aed962d7f9553072a701f66641ab62d72abb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -1,4 +1,14 @@\n+2005-01-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.dg/vect/vect.exp: Enable for ia64.\n+\t* lib/target-supports.exp (check_effective_target_vect_int): Likewise.\n+\t(check_effective_target_vect_float): Likewise.\n+\t(check_effective_target_vect_no_align): Likewise.\n+\t* gcc.dg/vect/vect-30.c: XFAIL for vect_no_align.\n+\t* gcc.dg/vect/vect-8.c: Likewise.\n+\n 2005-01-03  Uros Bizjak <uros@kss-loka.si>\n+\n \tPR target/19235\n \t* gcc.dg/pr19236-1.c: New test case.\n "}, {"sha": "c6f03ed212199f69db67db653b464440987dc47d", "filename": "gcc/testsuite/gcc.dg/vect/vect-30.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-30.c?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -59,4 +59,6 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\"  } } */\n+/* Need misalignment support, or cgraph to delay emitting the arrays until\n+   after vectorization can force-align them.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail vect_no_align } } } */"}, {"sha": "7712a02cfab60f0d067bb0903cb9c6f94d3885df", "filename": "gcc/testsuite/gcc.dg/vect/vect-8.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-8.c?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -34,4 +34,6 @@ int main (void)\n   return main1 (N);\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* Need misalignment support, or cgraph to delay emitting the arrays until\n+   after vectorization can force-align them.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */"}, {"sha": "94fd56c588dd73534cdda1a2d12268ec5c681fd0", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -65,6 +65,8 @@ if [istarget \"powerpc*-*-*\"] {\n     } else {\n \tset dg-do-what-default compile\n     }\n+} elseif [istarget \"ia64-*-*\"] {\n+    set dg-do-what-default run\n } else {\n     return\n }"}, {"sha": "defb4d4e75db4c8dd2e8fbad6869d66f7e2c7333", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61134e88be4321c6cce477d4db0539d4c99a237/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=f61134e88be4321c6cce477d4db0539d4c99a237", "patch": "@@ -455,7 +455,8 @@ proc check_effective_target_vect_int { } {\n \t      || [istarget powerpc*-*-*]\n \t      || [istarget x86_64-*-*]\n \t      || [istarget sparc*-*-*]\n-\t      || [istarget alpha*-*-*] } {\n+\t      || [istarget alpha*-*-*]\n+\t      || [istarget ia64-*-*] } {\n \t   set et_vect_int_saved 1\n \t}\n     }\n@@ -496,7 +497,8 @@ proc check_effective_target_vect_float { } {\n \tif { [istarget i?86-*-*]\n \t      || [istarget powerpc*-*-*]\n \t      || [istarget mipsisa64*-*-*]\n-\t      || [istarget x86_64-*-*] } {\n+\t      || [istarget x86_64-*-*]\n+\t      || [istarget ia64-*-*] } {\n \t   set et_vect_float_saved 1\n \t}\n     }\n@@ -583,7 +585,8 @@ proc check_effective_target_vect_no_align { } {\n     } else {\n \tset et_vect_no_align_saved 0\n \tif { [istarget mipsisa64*-*-*]\n-\t     || [istarget sparc*-*-*] } {\n+\t     || [istarget sparc*-*-*]\n+\t     || [istarget ia64-*-*] } {\n \t    set et_vect_no_align_saved 1\n \t}\n     }"}]}