{"sha": "bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "node_id": "C_kwDOANBUbNoAKGJiMmE3ZjgwYTk4ZGUzZmViZWZiYjMyYjFlNDg5ODA2MmJkYjZhZjg", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-12-16T18:40:42Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-12-16T18:40:42Z"}, "message": "c++: two-stage name lookup for overloaded operators [PR51577]\n\nIn order to properly implement two-stage name lookup for dependent\noperator expressions, we need to remember the result of unqualified\nlookup of the operator at template definition time, and reuse that\nresult rather than performing another unqualified lookup at\ninstantiation time.\n\nIdeally we could just store the lookup in the expression directly, but\nas pointed out in r9-6405 this isn't really possible since we use the\nstandard tree codes to represent most dependent operator expressions.\n\nWe could perhaps create a new tree code to represent dependent operator\nexpressions, with enough operands to store the lookup along with\neverything else, but that'd require a lot of careful work to make sure\nwe handle this new tree code properly across the frontend.\n\nBut currently type-dependent operator (and call) expressions are given\nan empty TREE_TYPE, which dependent_type_p treats as dependent, so this\nfield is effectively unused except to signal that the expression is\ntype-dependent.  It'd be convenient if we could store the lookup there\nwhile preserving the dependent-ness of the expression.\n\nTo that end, this patch creates a new kind of type, called\nDEPENDENT_OPERATOR_TYPE, which we give to dependent operator expressions\nand into which we can store the result of operator lookup at template\ndefinition time (DEPENDENT_OPERATOR_TYPE_SAVED_LOOKUPS).  Since this\ntype is always dependent (by definition), and since the frontend doesn't\nseem to care much about the exact type of a type-dependent expression,\nusing this type in place of a NULL_TREE type seems to \"just work\"; only\ndependent_type_p and WILDCARD_TYPE_P need to be adjusted to return true\nfor this new type.\n\nThe rest of the patch mostly consists of adding the necessary plumbing\nto pass DEPENDENT_OPERATOR_TYPE_SAVED_LOOKUPS to add_operator_candidates,\nadjusting all callers of build_x_* appropriately, and removing the now\nunnecessary push_operator_bindings mechanism.\n\nIn passing, this patch simplifies finish_constraint_binary_op to avoid\nusing build_x_binary_op for building a binary constraint-expr; we don't\nneed to consider operator overloads here, as the &&/|| inside a\nconstraint effectively always has the built-in meaning (since atomic\nconstraints must have bool type).\n\nThis patch also makes FOLD_EXPR_OP yield a tree_code instead of a raw\nINTEGER_CST.\n\nFinally, this patch adds the XFAILed test operator-8.C which is about\nbroken two-stage name lookup for rewritten non-dependent operator\nexpressions, an existing bug that's otherwise only documented in\nbuild_new_op.\n\n\tPR c++/51577\n\tPR c++/83035\n\tPR c++/100465\n\ngcc/cp/ChangeLog:\n\n\t* call.c (add_operator_candidates): Add lookups parameter.\n\tUse it to avoid performing a second unqualified lookup when\n\tinstantiating a dependent operator expression.\n\t(build_new_op): Add lookups parameter and pass it appropriately.\n\t* constraint.cc (finish_constraint_binary_op): Use\n\tbuild_min_nt_loc instead of build_x_binary_op.\n\t* coroutines.cc (build_co_await): Adjust call to build_new_op.\n\t* cp-objcp-common.c (cp_common_init_ts): Mark\n\tDEPENDENT_OPERATOR_TYPE appropriately.\n\t* cp-tree.def (DEPENDENT_OPERATOR_TYPE): Define.\n\t* cp-tree.h (WILDCARD_TYPE_P): Accept DEPENDENT_OPERATOR_TYPE.\n\t(FOLD_EXPR_OP_RAW): New, renamed from ...\n\t(FOLD_EXPR_OP): ... this.  Change this to return the tree_code directly.\n\t(DEPENDENT_OPERATOR_TYPE_SAVED_LOOKUPS): Define.\n\t(templated_operator_saved_lookups): Define.\n\t(build_new_op): Add lookups parameter.\n\t(build_dependent_operator_type): Declare.\n\t(build_x_indirect_ref): Add lookups parameter.\n\t(build_x_binary_op): Likewise.\n\t(build_x_unary_op): Likewise.\n\t(build_x_compound_expr): Likewise.\n\t(build_x_modify_expr): Likewise.\n\t* cxx-pretty-print.c (get_fold_operator): Adjust after\n\tFOLD_EXPR_OP change.\n\t* decl.c (start_preparsed_function): Don't call\n\tpush_operator_bindings.\n\t* decl2.c (grok_array_decl): Adjust calls to build_new_op.\n\t* method.c (do_one_comp): Likewise.\n\t(build_comparison_op): Likewise.\n\t* module.cc (trees_out::type_node): Handle DEPENDENT_OPERATOR_TYPE.\n\t(trees_in::tree_node): Likewise.\n\t* name-lookup.c (lookup_name): Revert r11-2876 change.\n\t(op_unqualified_lookup): Remove.\n\t(maybe_save_operator_binding): Remove.\n\t(discard_operator_bindings): Remove.\n\t(push_operator_bindings): Remove.\n\t* name-lookup.h (maybe_save_operator_binding): Remove.\n\t(push_operator_bindings): Remove.\n\t(discard_operator_bindings): Remove.\n\t* parser.c (cp_parser_unary_expression): Adjust calls to build_x_*.\n\t(cp_parser_binary_expression): Likewise.\n\t(cp_parser_assignment_expression): Likewise.\n\t(cp_parser_expression): Likewise.\n\t(do_range_for_auto_deduction): Likewise.\n\t(cp_convert_range_for): Likewise.\n\t(cp_parser_perform_range_for_lookup): Likewise.\n\t(cp_parser_template_argument): Likewise.\n\t(cp_parser_omp_for_cond): Likewise.\n\t(cp_parser_omp_for_incr): Likewise.\n\t(cp_parser_omp_for_loop_init): Likewise.\n\t(cp_convert_omp_range_for): Likewise.\n\t(cp_finish_omp_range_for): Likewise.\n\t* pt.c (fold_expression): Adjust after FOLD_EXPR_OP change. Pass\n\ttemplated_operator_saved_lookups to build_x_*.\n\t(tsubst_omp_for_iterator): Adjust call to build_x_modify_expr.\n\t(tsubst_expr) <case COMPOUND_EXPR>: Pass\n\ttemplated_operator_saved_lookups to build_x_*.\n\t(tsubst_copy_and_build) <case INDIRECT_REF>: Likewise.\n\t<case tcc_unary>: Likewise.\n\t<case tcc_binary>: Likewise.\n\t<case MODOP_EXPR>: Likewise.\n\t<case COMPOUND_EXPR>: Likewise.\n\t(dependent_type_p_r): Return true for DEPENDENT_OPERATOR_TYPE.\n\t* ptree.c (cxx_print_type): Handle DEPENDENT_OPERATOR_TYPE.\n\t* semantics.c (finish_increment_expr): Adjust call to\n\tbuild_x_unary_op.\n\t(finish_unary_op_expr): Likewise.\n\t(handle_omp_for_class_iterator): Adjust calls to build_x_*.\n\t(finish_omp_cancel): Likewise.\n\t(finish_unary_fold_expr): Use build_dependent_operator_type.\n\t(finish_binary_fold_expr): Likewise.\n\t* tree.c (cp_free_lang_data): Don't call discard_operator_bindings.\n\t* typeck.c (rationalize_conditional_expr): Adjust call to\n\tbuild_x_binary_op.\n\t(op_unqualified_lookup): Define.\n\t(build_dependent_operator_type): Define.\n\t(build_x_indirect_ref): Add lookups parameter and use\n\tbuild_dependent_operator_type.\n\t(build_x_binary_op): Likewise.\n\t(build_x_array_ref): Likewise.\n\t(build_x_unary_op): Likewise.\n\t(build_x_compound_expr_from_list): Adjust call to\n\tbuild_x_compound_expr.\n\t(build_x_compound_expr_from_vec): Likewise.\n\t(build_x_compound_expr): Add lookups parameter and use\n\tbuild_dependent_operator_type.\n\t(cp_build_modify_expr): Adjust call to build_new_op.\n\t(build_x_modify_expr): Add lookups parameter and use\n\tbuild_dependent_operator_type.\n\t* typeck2.c (build_x_arrow): Adjust call to build_new_op.\n\nlibcc1/ChangeLog:\n\n\t* libcp1plugin.cc (plugin_build_unary_expr): Adjust call to\n\tbuild_x_unary_op.\n\t(plugin_build_binary_expr): Adjust call to build_x_binary_op.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/lookup/operator-3.C: Split out operator overload\n\tdeclarations into ...\n\t* g++.dg/lookup/operator-3-ops.h: ... here.\n\t* g++.dg/lookup/operator-3a.C: New test.\n\t* g++.dg/lookup/operator-4.C: New test.\n\t* g++.dg/lookup/operator-4a.C: New test.\n\t* g++.dg/lookup/operator-5.C: New test.\n\t* g++.dg/lookup/operator-5a.C: New test.\n\t* g++.dg/lookup/operator-6.C: New test.\n\t* g++.dg/lookup/operator-7.C: New test.\n\t* g++.dg/lookup/operator-8.C: New test.", "tree": {"sha": "755d59d7edc782cd013dcc67e5d706e4a6a63af7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/755d59d7edc782cd013dcc67e5d706e4a6a63af7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/comments", "author": null, "committer": null, "parents": [{"sha": "271e36d9d5b3a75e7f1a927e594477e6a5dd6fc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271e36d9d5b3a75e7f1a927e594477e6a5dd6fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/271e36d9d5b3a75e7f1a927e594477e6a5dd6fc0"}], "stats": {"total": 1096, "additions": 796, "deletions": 300}, "files": [{"sha": "495dcdd77b3b8cfa89406c88c38655bfd2dfec95", "filename": "gcc/cp/call.c", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -6285,12 +6285,17 @@ op_is_ordered (tree_code code)\n \n /* Subroutine of build_new_op: Add to CANDIDATES all candidates for the\n    operator indicated by CODE/CODE2.  This function calls itself recursively to\n-   handle C++20 rewritten comparison operator candidates.  */\n+   handle C++20 rewritten comparison operator candidates.\n+\n+   LOOKUPS, if non-NULL, is the set of pertinent namespace-scope operator\n+   overloads to consider.  This parameter is used when instantiating a\n+   dependent operator expression and has the same structure as\n+   DEPENDENT_OPERATOR_TYPE_SAVED_LOOKUPS.  */\n \n static tree\n add_operator_candidates (z_candidate **candidates,\n \t\t\t tree_code code, tree_code code2,\n-\t\t\t vec<tree, va_gc> *arglist,\n+\t\t\t vec<tree, va_gc> *arglist, tree lookups,\n \t\t\t int flags, tsubst_flags_t complain)\n {\n   z_candidate *start_candidates = *candidates;\n@@ -6326,7 +6331,15 @@ add_operator_candidates (z_candidate **candidates,\n      consider.  */\n   if (!memonly)\n     {\n-      tree fns = lookup_name (fnname, LOOK_where::BLOCK_NAMESPACE);\n+      tree fns;\n+      if (!lookups)\n+\tfns = lookup_name (fnname, LOOK_where::BLOCK_NAMESPACE);\n+      /* If LOOKUPS is non-NULL, then we're instantiating a dependent operator\n+\t expression, and LOOKUPS is the result of stage 1 name lookup.  */\n+      else if (tree found = purpose_member (fnname, lookups))\n+\tfns = TREE_VALUE (found);\n+      else\n+\tfns = NULL_TREE;\n       fns = lookup_arg_dependent (fnname, fns, arglist);\n       add_candidates (fns, NULL_TREE, arglist, NULL_TREE,\n \t\t      NULL_TREE, false, NULL_TREE, NULL_TREE,\n@@ -6429,7 +6442,7 @@ add_operator_candidates (z_candidate **candidates,\n \t  if (rewrite_code != code)\n \t    /* Add rewritten candidates in same order.  */\n \t    add_operator_candidates (candidates, rewrite_code, ERROR_MARK,\n-\t\t\t\t     arglist, flags, complain);\n+\t\t\t\t     arglist, lookups, flags, complain);\n \n \t  z_candidate *save_cand = *candidates;\n \n@@ -6439,7 +6452,7 @@ add_operator_candidates (z_candidate **candidates,\n \t  revlist->quick_push ((*arglist)[1]);\n \t  revlist->quick_push ((*arglist)[0]);\n \t  add_operator_candidates (candidates, rewrite_code, ERROR_MARK,\n-\t\t\t\t   revlist, flags, complain);\n+\t\t\t\t   revlist, lookups, flags, complain);\n \n \t  /* Release the vec if we didn't add a candidate that uses it.  */\n \t  for (z_candidate *c = *candidates; c != save_cand; c = c->next)\n@@ -6457,8 +6470,8 @@ add_operator_candidates (z_candidate **candidates,\n \n tree\n build_new_op (const op_location_t &loc, enum tree_code code, int flags,\n-\t      tree arg1, tree arg2, tree arg3, tree *overload,\n-\t      tsubst_flags_t complain)\n+\t      tree arg1, tree arg2, tree arg3, tree lookups,\n+\t      tree *overload, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   releasing_vec arglist;\n@@ -6552,7 +6565,7 @@ build_new_op (const op_location_t &loc, enum tree_code code, int flags,\n   p = conversion_obstack_alloc (0);\n \n   result = add_operator_candidates (&candidates, code, code2, arglist,\n-\t\t\t\t    flags, complain);\n+\t\t\t\t    lookups, flags, complain);\n   if (result == error_mark_node)\n     goto user_defined_result_ready;\n \n@@ -6608,7 +6621,7 @@ build_new_op (const op_location_t &loc, enum tree_code code, int flags,\n \t  else\n \t    code = PREDECREMENT_EXPR;\n \t  result = build_new_op (loc, code, flags, arg1, NULL_TREE,\n-\t\t\t\t NULL_TREE, overload, complain);\n+\t\t\t\t NULL_TREE, lookups, overload, complain);\n \t  break;\n \n \t  /* The caller will deal with these.  */\n@@ -6765,7 +6778,7 @@ build_new_op (const op_location_t &loc, enum tree_code code, int flags,\n \t\t    warning_sentinel ws (warn_zero_as_null_pointer_constant);\n \t\t    result = build_new_op (loc, code,\n \t\t\t\t\t   LOOKUP_NORMAL|LOOKUP_REWRITTEN,\n-\t\t\t\t\t   lhs, rhs, NULL_TREE,\n+\t\t\t\t\t   lhs, rhs, NULL_TREE, lookups,\n \t\t\t\t\t   NULL, complain);\n \t\t  }\n \t\t  break;"}, {"sha": "8e25ae2367028b95c05c8ea6857aef0cb6cca0e6", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -202,15 +202,8 @@ finish_constraint_binary_op (location_t loc,\n     return error_mark_node;\n   if (!check_constraint_operands (loc, lhs, rhs))\n     return error_mark_node;\n-  tree overload;\n-  cp_expr expr = build_x_binary_op (loc, code,\n-\t\t\t\t    lhs, TREE_CODE (lhs),\n-\t\t\t\t    rhs, TREE_CODE (rhs),\n-\t\t\t\t    &overload, tf_none);\n-  /* When either operand is dependent, the overload set may be non-empty.  */\n-  if (expr == error_mark_node)\n-    return error_mark_node;\n-  expr.set_location (loc);\n+  cp_expr expr\n+    = build_min_nt_loc (loc, code, lhs.get_value (), rhs.get_value ());\n   expr.set_range (lhs.get_start (), rhs.get_finish ());\n   return expr;\n }"}, {"sha": "c00672eeb6e73b87fe63657d2dfca241e62c771a", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -912,7 +912,7 @@ build_co_await (location_t loc, tree a, suspend_point_kind suspend_kind)\n   if (MAYBE_CLASS_TYPE_P (TREE_TYPE (a)))\n     {\n       o = build_new_op (loc, CO_AWAIT_EXPR, LOOKUP_NORMAL, a, NULL_TREE,\n-\t\t\tNULL_TREE, NULL, tf_warning_or_error);\n+\t\t\tNULL_TREE, NULL_TREE, NULL, tf_warning_or_error);\n       /* If no viable functions are found, o is a.  */\n       if (!o || o == error_mark_node)\n \to = a;"}, {"sha": "36e04cdee5eaa28168146583ee862b77d7966897", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -484,6 +484,7 @@ cp_common_init_ts (void)\n   /* New Types.  */\n   MARK_TS_TYPE_COMMON (UNBOUND_CLASS_TEMPLATE);\n   MARK_TS_TYPE_COMMON (TYPE_ARGUMENT_PACK);\n+  MARK_TS_TYPE_COMMON (DEPENDENT_OPERATOR_TYPE);\n \n   MARK_TS_TYPE_NON_COMMON (DECLTYPE_TYPE);\n   MARK_TS_TYPE_NON_COMMON (TYPENAME_TYPE);"}, {"sha": "6fb838cc850eb03c6a70f0fa75ef26eb36622e14", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -476,6 +476,11 @@ DEFTREECODE (UNDERLYING_TYPE, \"underlying_type\", tcc_type, 0)\n    BASES_TYPE is the type in question.  */\n DEFTREECODE (BASES, \"bases\", tcc_type, 0)\n \n+/* Dependent operator expressions are given this type rather than a NULL_TREE\n+   type so that we have somewhere to stash the result of phase 1 name lookup\n+   (namely into DEPENDENT_OPERATOR_TYPE_SAVED_LOOKUPS).  */\n+DEFTREECODE (DEPENDENT_OPERATOR_TYPE, \"dependent_operator_type\", tcc_type, 0)\n+\n /* Used to represent the template information stored by template\n    specializations.\n    The accessors are:"}, {"sha": "9eff4349181d78d4305a7db196b862191dbee8e7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -2185,7 +2185,8 @@ enum languages { lang_c, lang_cplusplus };\n    || TREE_CODE (T) == TYPENAME_TYPE\t\t\t\\\n    || TREE_CODE (T) == TYPEOF_TYPE\t\t\t\\\n    || TREE_CODE (T) == BOUND_TEMPLATE_TEMPLATE_PARM\t\\\n-   || TREE_CODE (T) == DECLTYPE_TYPE)\n+   || TREE_CODE (T) == DECLTYPE_TYPE\t\t\t\\\n+   || TREE_CODE (T) == DEPENDENT_OPERATOR_TYPE)\n \n /* Nonzero if T is a class (or struct or union) type.  Also nonzero\n    for template type parameters, typename types, and instantiated\n@@ -3978,9 +3979,13 @@ struct GTY(()) lang_decl {\n   TREE_LANG_FLAG_0 (FOLD_EXPR_CHECK (NODE))\n \n /* An INTEGER_CST containing the tree code of the folded operator. */\n-#define FOLD_EXPR_OP(NODE) \\\n+#define FOLD_EXPR_OP_RAW(NODE) \\\n   TREE_OPERAND (FOLD_EXPR_CHECK (NODE), 0)\n \n+/* The tree code of the folded operator.  */\n+#define FOLD_EXPR_OP(NODE) \\\n+  ((enum tree_code) TREE_INT_CST_LOW (FOLD_EXPR_OP_RAW (NODE)))\n+\n /* The expression containing an unexpanded parameter pack. */\n #define FOLD_EXPR_PACK(NODE) \\\n   TREE_OPERAND (FOLD_EXPR_CHECK (NODE), 1)\n@@ -4035,6 +4040,26 @@ struct GTY(()) lang_decl {\n #define CALL_EXPR_OPERATOR_SYNTAX(NODE) \\\n   TREE_LANG_FLAG_6 (CALL_OR_AGGR_INIT_CHECK (NODE))\n \n+/* A TREE_LIST containing the result of phase 1 name lookup of the operator\n+   overloads that are pertinent to the dependent operator expression whose\n+   type is NODE.  Each TREE_PURPOSE is an IDENTIFIER_NODE and TREE_VALUE is\n+   the corresponding (possibly empty) lookup result.  The TREE_TYPE of the\n+   first TREE_LIST node points back to NODE.  */\n+#define DEPENDENT_OPERATOR_TYPE_SAVED_LOOKUPS(NODE) \\\n+  TYPE_VALUES_RAW (DEPENDENT_OPERATOR_TYPE_CHECK (NODE))\n+\n+/* Guarded helper for the above accessor macro that takes a (templated)\n+   operator expression instead of the type thereof.  */\n+inline tree\n+templated_operator_saved_lookups (tree t)\n+{\n+  tree type = TREE_TYPE (EXPR_CHECK (t));\n+  if (type && TREE_CODE (type) == DEPENDENT_OPERATOR_TYPE)\n+    return DEPENDENT_OPERATOR_TYPE_SAVED_LOOKUPS (type);\n+  else\n+    return NULL_TREE;\n+}\n+\n /* Indicates whether a string literal has been parenthesized. Such\n    usages are disallowed in certain circumstances.  */\n \n@@ -6464,14 +6489,15 @@ extern tree build_special_member_call\t\t(tree, tree,\n \t\t\t\t\t\t tree, int, tsubst_flags_t);\n extern tree build_new_op\t\t\t(const op_location_t &,\n \t\t\t\t\t\t enum tree_code,\n-\t\t\t\t\t\t int, tree, tree, tree, tree *,\n-\t\t\t\t\t\t tsubst_flags_t);\n+\t\t\t\t\t\t int, tree, tree, tree, tree,\n+\t\t\t\t\t\t tree *, tsubst_flags_t);\n /* Wrapper that leaves out the usually-null op3 and overload parms.  */\n inline tree build_new_op (const op_location_t &loc, enum tree_code code,\n \t\t\t  int flags, tree arg1, tree arg2,\n \t\t\t  tsubst_flags_t complain)\n {\n-  return build_new_op (loc, code, flags, arg1, arg2, NULL_TREE, NULL, complain);\n+  return build_new_op (loc, code, flags, arg1, arg2, NULL_TREE, NULL_TREE,\n+\t\t       NULL, complain);\n }\n extern tree build_op_call\t\t\t(tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tsubst_flags_t);\n@@ -7875,8 +7901,9 @@ extern tree build_class_member_access_expr      (cp_expr, tree, tree, bool,\n extern tree finish_class_member_access_expr     (cp_expr, tree, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree lookup_destructor\t\t\t(tree, tree, tree, tsubst_flags_t);\n+extern tree build_dependent_operator_type\t(tree, enum tree_code, bool);\n extern tree build_x_indirect_ref\t\t(location_t, tree,\n-\t\t\t\t\t\t ref_operator,\n+\t\t\t\t\t\t ref_operator, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree cp_build_indirect_ref\t\t(location_t, tree,\n \t\t\t\t\t\t ref_operator,\n@@ -7894,20 +7921,20 @@ extern tree cp_build_function_call_vec\t\t(tree, vec<tree, va_gc> **,\n extern tree build_x_binary_op\t\t\t(const op_location_t &,\n \t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t enum tree_code, tree,\n-\t\t\t\t\t\t enum tree_code, tree *,\n-\t\t\t\t\t\t tsubst_flags_t);\n+\t\t\t\t\t\t enum tree_code, tree,\n+\t\t\t\t\t\t tree *, tsubst_flags_t);\n inline tree build_x_binary_op (const op_location_t &loc,\n \t\t\t       enum tree_code code, tree arg1, tree arg2,\n \t\t\t       tsubst_flags_t complain)\n {\n   return build_x_binary_op (loc, code, arg1, TREE_CODE (arg1), arg2,\n-\t\t\t    TREE_CODE (arg2), NULL, complain);\n+\t\t\t    TREE_CODE (arg2), NULL_TREE, NULL, complain);\n }\n extern tree build_x_array_ref\t\t\t(location_t, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_x_unary_op\t\t\t(location_t,\n \t\t\t\t\t\t enum tree_code, cp_expr,\n-                                                 tsubst_flags_t);\n+\t\t\t\t\t\t tree, tsubst_flags_t);\n extern tree cp_build_addressof\t\t\t(location_t, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree cp_build_addr_expr\t\t\t(tree, tsubst_flags_t);\n@@ -7922,7 +7949,7 @@ extern tree build_x_compound_expr_from_list\t(tree, expr_list_kind,\n extern tree build_x_compound_expr_from_vec\t(vec<tree, va_gc> *,\n \t\t\t\t\t\t const char *, tsubst_flags_t);\n extern tree build_x_compound_expr\t\t(location_t, tree, tree,\n-\t\t\t\t\t\t tsubst_flags_t);\n+\t\t\t\t\t\t tree, tsubst_flags_t);\n extern tree build_compound_expr                 (location_t, tree, tree);\n extern tree cp_build_compound_expr\t\t(tree, tree, tsubst_flags_t);\n extern tree build_static_cast\t\t\t(location_t, tree, tree,\n@@ -7938,7 +7965,7 @@ extern tree cp_build_c_cast\t\t\t(location_t, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern cp_expr build_x_modify_expr\t\t(location_t, tree,\n \t\t\t\t\t\t enum tree_code, tree,\n-\t\t\t\t\t\t tsubst_flags_t);\n+\t\t\t\t\t\t tree, tsubst_flags_t);\n extern tree cp_build_modify_expr\t\t(location_t, tree,\n \t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t tsubst_flags_t);"}, {"sha": "6af009c68907a6132b780d94de2c614274902b6a", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -2541,8 +2541,8 @@ pp_cxx_addressof_expression (cxx_pretty_printer *pp, tree t)\n static char const*\n get_fold_operator (tree t)\n {\n-  int op = int_cst_value (FOLD_EXPR_OP (t));\n-  ovl_op_info_t *info = OVL_OP_INFO (FOLD_EXPR_MODIFY_P (t), op);\n+  ovl_op_info_t *info = OVL_OP_INFO (FOLD_EXPR_MODIFY_P (t),\n+\t\t\t\t     FOLD_EXPR_OP (t));\n   return info->name;\n }\n "}, {"sha": "7ca8770bd025a58dc7d1bf309129c91594aab3b0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -17118,8 +17118,6 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \n   store_parm_decls (current_function_parms);\n \n-  push_operator_bindings ();\n-\n   if (!processing_template_decl\n       && (flag_lifetime_dse > 1)\n       && DECL_CONSTRUCTOR_P (decl1)"}, {"sha": "062c175430bf85522a033431cff5a7c309fdc87b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -417,7 +417,8 @@ grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n     {\n       if (index_exp)\n \texpr = build_new_op (loc, ARRAY_REF, LOOKUP_NORMAL, array_expr,\n-\t\t\t     index_exp, NULL_TREE, &overload, complain);\n+\t\t\t     index_exp, NULL_TREE, NULL_TREE,\n+\t\t\t     &overload, complain);\n       else if ((*index_exp_list)->is_empty ())\n \texpr = build_op_subscript (loc, array_expr, index_exp_list, &overload,\n \t\t\t\t   complain);\n@@ -431,7 +432,7 @@ grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n \t\t\t\t\t\t\t tf_none);\n \t      if (idx != error_mark_node)\n \t\texpr = build_new_op (loc, ARRAY_REF, LOOKUP_NORMAL, array_expr,\n-\t\t\t\t     idx, NULL_TREE, &overload,\n+\t\t\t\t     idx, NULL_TREE, NULL_TREE, &overload,\n \t\t\t\t     complain & tf_decltype);\n \t      if (expr == error_mark_node)\n \t\t{"}, {"sha": "44439bae4ec7e6153e7bb6d8d74a5f7c7a8e8bd2", "filename": "gcc/cp/method.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -1372,7 +1372,7 @@ do_one_comp (location_t loc, const comp_info &info, tree sub, tree lhs, tree rhs\n      to </=, so don't give an error yet if <=> lookup fails.  */\n   bool tentative = retcat != cc_last;\n   tree comp = build_new_op (loc, code, flags, lhs, rhs,\n-\t\t\t    NULL_TREE, &overload,\n+\t\t\t    NULL_TREE, NULL_TREE, &overload,\n \t\t\t    tentative ? tf_none : complain);\n \n   if (code != SPACESHIP_EXPR)\n@@ -1684,8 +1684,8 @@ build_comparison_op (tree fndecl, bool defining, tsubst_flags_t complain)\n \t\t  comp = retval = var;\n \t\t}\n \t      eq = build_new_op (info.loc, EQ_EXPR, flags, comp,\n-\t\t\t\t integer_zero_node, NULL_TREE, NULL,\n-\t\t\t\t complain);\n+\t\t\t\t integer_zero_node, NULL_TREE, NULL_TREE,\n+\t\t\t\t NULL, complain);\n \t    }\n \t  tree ceq = contextual_conv_bool (eq, complain);\n \t  info.check (ceq);\n@@ -1720,7 +1720,7 @@ build_comparison_op (tree fndecl, bool defining, tsubst_flags_t complain)\n   else if (code == NE_EXPR)\n     {\n       tree comp = build_new_op (info.loc, EQ_EXPR, flags, lhs, rhs,\n-\t\t\t\tNULL_TREE, NULL, complain);\n+\t\t\t\tNULL_TREE, NULL_TREE, NULL, complain);\n       comp = contextual_conv_bool (comp, complain);\n       info.check (comp);\n       if (defining)\n@@ -1732,9 +1732,9 @@ build_comparison_op (tree fndecl, bool defining, tsubst_flags_t complain)\n   else\n     {\n       tree comp = build_new_op (info.loc, SPACESHIP_EXPR, flags, lhs, rhs,\n-\t\t\t\tNULL_TREE, NULL, complain);\n+\t\t\t\tNULL_TREE, NULL_TREE, NULL, complain);\n       tree comp2 = build_new_op (info.loc, code, flags, comp, integer_zero_node,\n-\t\t\t\t NULL_TREE, NULL, complain);\n+\t\t\t\t NULL_TREE, NULL_TREE, NULL, complain);\n       info.check (comp2);\n       if (defining)\n \tfinish_return_stmt (comp2);"}, {"sha": "f3e7af22699ce64152fbf46304c5e75a2a491005", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -8789,6 +8789,7 @@ trees_out::type_node (tree type)\n     case DECLTYPE_TYPE:\n     case TYPEOF_TYPE:\n     case UNDERLYING_TYPE:\n+    case DEPENDENT_OPERATOR_TYPE:\n       tree_node (TYPE_VALUES_RAW (type));\n       if (TREE_CODE (type) == DECLTYPE_TYPE)\n \t/* We stash a whole bunch of things into decltype's\n@@ -9311,6 +9312,7 @@ trees_in::tree_node (bool is_use)\n \t  case DECLTYPE_TYPE:\n \t  case TYPEOF_TYPE:\n \t  case UNDERLYING_TYPE:\n+\t  case DEPENDENT_OPERATOR_TYPE:\n \t    {\n \t      tree expr = tree_node ();\n \t      if (!get_overrun ())"}, {"sha": "3bd7b206abb51b996ab0256b61a79da00d5428dc", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 2, "deletions": 131, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -7725,29 +7725,21 @@ lookup_name (tree name, LOOK_where where, LOOK_want want)\n \n \t    if (binding)\n \t      {\n-\t\t/* The saved lookups for an operator record 'nothing\n-\t\t   found' as error_mark_node.  We need to stop the search\n-\t\t   here, but not return the error mark node.  */\n-\t\tif (binding == error_mark_node)\n-\t\t  binding = NULL_TREE;\n-\n \t\tval = binding;\n-\t\tgoto found;\n+\t\tbreak;\n \t      }\n \t  }\n       }\n \n   /* Now lookup in namespace scopes.  */\n-  if (bool (where & LOOK_where::NAMESPACE))\n+  if (!val && bool (where & LOOK_where::NAMESPACE))\n     {\n       name_lookup lookup (name, want);\n       if (lookup.search_unqualified\n \t  (current_decl_namespace (), current_binding_level))\n \tval = lookup.value;\n     }\n \n- found:;\n-\n   /* If we have a known type overload, pull it out.  This can happen\n      for both using decls and unhidden functions.  */\n   if (val && TREE_CODE (val) == OVERLOAD && TREE_TYPE (val) != unknown_type_node)\n@@ -8949,125 +8941,4 @@ cp_emit_debug_info_for_using (tree t, tree context)\n     }\n }\n \n-/* Return the result of unqualified lookup for the overloaded operator\n-   designated by CODE, if we are in a template and the binding we find is\n-   not.  */\n-\n-static tree\n-op_unqualified_lookup (tree fnname)\n-{\n-  if (cxx_binding *binding = IDENTIFIER_BINDING (fnname))\n-    {\n-      cp_binding_level *l = binding->scope;\n-      while (l && !l->this_entity)\n-\tl = l->level_chain;\n-\n-      if (l && uses_template_parms (l->this_entity))\n-\t/* Don't preserve decls from an uninstantiated template,\n-\t   wait until that template is instantiated.  */\n-\treturn NULL_TREE;\n-    }\n-\n-  tree fns = lookup_name (fnname);\n-  if (!fns)\n-    /* Remember we found nothing!  */\n-    return error_mark_node;\n-\n-  tree d = fns;\n-  if (TREE_CODE (d) == TREE_LIST)\n-    d = TREE_VALUE (d);\n-  if (is_overloaded_fn (d))\n-    d = get_first_fn (d);\n-  if (DECL_CLASS_SCOPE_P (d))\n-    /* We don't need to remember class-scope functions or declarations,\n-       normal unqualified lookup will find them again.  */\n-    return NULL_TREE;\n-\n-  return fns;\n-}\n-\n-/* E is an expression representing an operation with dependent type, so we\n-   don't know yet whether it will use the built-in meaning of the operator or a\n-   function.  Remember declarations of that operator in scope.\n-\n-   We then inject a fake binding of that lookup into the\n-   instantiation's parameter scope.  This approach fails if the user\n-   has different using declarations or directives in different local\n-   binding of the current function from whence we need to do lookups\n-   (we'll cache what we see on the first lookup).  */\n-\n-static const char *const op_bind_attrname = \"operator bindings\";\n-\n-void\n-maybe_save_operator_binding (tree e)\n-{\n-  /* This is only useful in a template.  */\n-  if (!processing_template_decl)\n-    return;\n-\n-  tree cfn = current_function_decl;\n-  if (!cfn)\n-    return;\n-\n-  tree fnname;\n-  if(TREE_CODE (e) == MODOP_EXPR)\n-    fnname = ovl_op_identifier (true, TREE_CODE (TREE_OPERAND (e, 1)));\n-  else\n-    fnname = ovl_op_identifier (false, TREE_CODE (e));\n-  if (!fnname || fnname == assign_op_identifier)\n-    return;\n-\n-  tree attributes = DECL_ATTRIBUTES (cfn);\n-  tree op_attr = lookup_attribute (op_bind_attrname, attributes);\n-  if (!op_attr)\n-    {\n-      tree *ap = &DECL_ATTRIBUTES (cfn);\n-      while (*ap && ATTR_IS_DEPENDENT (*ap))\n-\tap = &TREE_CHAIN (*ap);\n-      op_attr = tree_cons (get_identifier (op_bind_attrname),\n-\t\t\t   NULL_TREE, *ap);\n-      *ap = op_attr;\n-    }\n-\n-  tree op_bind = purpose_member (fnname, TREE_VALUE (op_attr));\n-  if (!op_bind)\n-    {\n-      tree fns = op_unqualified_lookup (fnname);\n-\n-      /* Always record, so we don't keep looking for this\n-\t operator.  */\n-      TREE_VALUE (op_attr) = tree_cons (fnname, fns, TREE_VALUE (op_attr));\n-    }\n-}\n-\n-/* Called from cp_free_lang_data so we don't put this into LTO.  */\n-\n-void\n-discard_operator_bindings (tree decl)\n-{\n-  DECL_ATTRIBUTES (decl) = remove_attribute (op_bind_attrname,\n-\t\t\t\t\t     DECL_ATTRIBUTES (decl));\n-}\n-\n-/* Subroutine of start_preparsed_function: push the bindings we saved away in\n-   maybe_save_op_lookup into the function parameter binding level.  */\n-\n-void\n-push_operator_bindings ()\n-{\n-  tree decl1 = current_function_decl;\n-  if (tree attr = lookup_attribute (op_bind_attrname,\n-\t\t\t\t    DECL_ATTRIBUTES (decl1)))\n-    for (tree binds = TREE_VALUE (attr); binds; binds = TREE_CHAIN (binds))\n-      if (tree val = TREE_VALUE (binds))\n-\t{\n-\t  tree name = TREE_PURPOSE (binds);\n-\t  if (TREE_CODE (val) == TREE_LIST)\n-\t    for (tree v = val; v; v = TREE_CHAIN (v))\n-\t      push_local_binding (name, TREE_VALUE (v), /*using*/true);\n-\t  else\n-\t    push_local_binding (name, val, /*using*/true);\n-\t}\n-}\n-\n #include \"gt-cp-name-lookup.h\""}, {"sha": "db705d20c68b85cc40faf4ecb709f165b8d66d79", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -465,10 +465,7 @@ extern void push_nested_namespace (tree);\n extern void pop_nested_namespace (tree);\n extern void push_to_top_level (void);\n extern void pop_from_top_level (void);\n-extern void maybe_save_operator_binding (tree);\n-extern void push_operator_bindings (void);\n extern void push_using_decl_bindings (tree, tree);\n-extern void discard_operator_bindings (tree);\n \n /* Lower level interface for modules. */\n extern tree *mergeable_namespace_slots (tree ns, tree name, bool is_global,"}, {"sha": "5d72201f87c7eea0af4acb85998916e3e6d67548", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -8731,7 +8731,7 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t    return build_x_unary_op (token->location,\n \t\t\t\t     (keyword == RID_REALPART\n \t\t\t\t      ? REALPART_EXPR : IMAGPART_EXPR),\n-\t\t\t\t     expression,\n+\t\t\t\t     expression, NULL_TREE,\n                                      tf_warning_or_error);\n \t  }\n \t  break;\n@@ -8908,7 +8908,7 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \tcase INDIRECT_REF:\n \t  non_constant_p = NIC_STAR;\n \t  expression = build_x_indirect_ref (loc, cast_expression,\n-\t\t\t\t\t     RO_UNARY_STAR,\n+\t\t\t\t\t     RO_UNARY_STAR, NULL_TREE,\n                                              complain);\n           /* TODO: build_x_indirect_ref does not always honor the\n              location, so ensure it is set.  */\n@@ -8921,7 +8921,7 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \tcase BIT_NOT_EXPR:\n \t  expression = build_x_unary_op (loc, unary_operator,\n \t\t\t\t\t cast_expression,\n-                                         complain);\n+\t\t\t\t\t NULL_TREE, complain);\n           /* TODO: build_x_unary_op does not always honor the location,\n              so ensure it is set.  */\n           expression.set_location (loc);\n@@ -10149,7 +10149,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t  op_location_t op_loc (current.loc, combined_loc);\n \t  current.lhs = build_x_binary_op (op_loc, current.tree_type,\n                                            current.lhs, current.lhs_type,\n-                                           rhs, rhs_type, &overload,\n+\t\t\t\t\t   rhs, rhs_type, NULL_TREE, &overload,\n                                            complain_flags (decltype_p));\n           /* TODO: build_x_binary_op doesn't always honor the location.  */\n           current.lhs.set_location (combined_loc);\n@@ -10328,7 +10328,7 @@ cp_parser_assignment_expression (cp_parser* parser, cp_id_kind * pidk,\n \t\t\t\t   rhs.get_finish ());\n \t      expr = build_x_modify_expr (loc, expr,\n \t\t\t\t\t  assignment_operator,\n-\t\t\t\t\t  rhs,\n+\t\t\t\t\t  rhs, NULL_TREE,\n \t\t\t\t\t  complain_flags (decltype_p));\n               /* TODO: build_x_modify_expr doesn't honor the location,\n                  so we must set it here.  */\n@@ -10480,7 +10480,7 @@ cp_parser_expression (cp_parser* parser, cp_id_kind * pidk,\n \t\t\t       expression.get_start (),\n \t\t\t       assignment_expression.get_finish ());\n \t  expression = build_x_compound_expr (loc, expression,\n-\t\t\t\t\t      assignment_expression,\n+\t\t\t\t\t      assignment_expression, NULL_TREE,\n \t\t\t\t\t      complain_flags (decltype_p));\n \t  expression.set_location (loc);\n \t}\n@@ -13617,7 +13617,7 @@ do_range_for_auto_deduction (tree decl, tree range_expr)\n \t  iter_decl = build_decl (input_location, VAR_DECL, NULL_TREE,\n \t\t\t\t  iter_type);\n \t  iter_decl = build_x_indirect_ref (input_location, iter_decl,\n-\t\t\t\t\t    RO_UNARY_STAR,\n+\t\t\t\t\t    RO_UNARY_STAR, NULL_TREE,\n \t\t\t\t\t    tf_warning_or_error);\n \t  TREE_TYPE (decl) = do_auto_deduction (TREE_TYPE (decl),\n \t\t\t\t\t\titer_decl, auto_node,\n@@ -13804,7 +13804,7 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr,\n   condition = build_x_binary_op (input_location, NE_EXPR,\n \t\t\t\t begin, ERROR_MARK,\n \t\t\t\t end, ERROR_MARK,\n-\t\t\t\t NULL, tf_warning_or_error);\n+\t\t\t\t NULL_TREE, NULL, tf_warning_or_error);\n   finish_for_cond (condition, statement, ivdep, unroll);\n \n   /* The new increment expression.  */\n@@ -13818,7 +13818,7 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr,\n \n   /* The declaration is initialized with *__begin inside the loop body.  */\n   tree deref_begin = build_x_indirect_ref (input_location, begin, RO_UNARY_STAR,\n-\t\t\t\t\t   tf_warning_or_error);\n+\t\t\t\t\t   NULL_TREE, tf_warning_or_error);\n   cp_finish_decl (range_decl, deref_begin,\n \t\t  /*is_constant_init*/false, NULL_TREE,\n \t\t  LOOKUP_ONLYCONVERTING);\n@@ -13924,7 +13924,7 @@ cp_parser_perform_range_for_lookup (tree range, tree *begin, tree *end)\n \t\t  && (build_x_binary_op (input_location, NE_EXPR,\n \t\t\t\t\t *begin, ERROR_MARK,\n \t\t\t\t\t *end, ERROR_MARK,\n-\t\t\t\t\t NULL, tf_none)\n+\t\t\t\t\t NULL_TREE, NULL, tf_none)\n \t\t      != error_mark_node))\n \t\t/* P0184R0 allows __begin and __end to have different types,\n \t\t   but make sure they are comparable so we can give a better\n@@ -18924,7 +18924,7 @@ cp_parser_template_argument (cp_parser* parser)\n \t    {\n \t      if (address_p)\n \t\targument = build_x_unary_op (loc, ADDR_EXPR, argument,\n-\t\t\t\t\t     tf_warning_or_error);\n+\t\t\t\t\t     NULL_TREE, tf_warning_or_error);\n \t      else\n \t\targument = convert_from_reference (argument);\n \t      return argument;\n@@ -41564,7 +41564,7 @@ cp_parser_omp_for_cond (cp_parser *parser, tree decl, enum tree_code code)\n \t\t\t    TREE_CODE (cond),\n \t\t\t    TREE_OPERAND (cond, 0), ERROR_MARK,\n \t\t\t    TREE_OPERAND (cond, 1), ERROR_MARK,\n-\t\t\t    /*overload=*/NULL, tf_warning_or_error);\n+\t\t\t    NULL_TREE, /*overload=*/NULL, tf_warning_or_error);\n }\n \n /* Helper function, to parse omp for increment expression.  */\n@@ -41641,11 +41641,13 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n \t\tlhs = rhs;\n \t      else\n \t\tlhs = build_x_unary_op (input_location, NEGATE_EXPR, rhs,\n-\t\t\t\t\ttf_warning_or_error);\n+\t\t\t\t\tNULL_TREE, tf_warning_or_error);\n \t    }\n \t  else\n-\t    lhs = build_x_binary_op (input_location, op, lhs, ERROR_MARK, rhs,\n-\t\t\t\t     ERROR_MARK, NULL, tf_warning_or_error);\n+\t    lhs = build_x_binary_op (input_location, op,\n+\t\t\t\t     lhs, ERROR_MARK,\n+\t\t\t\t     rhs, ERROR_MARK,\n+\t\t\t\t     NULL_TREE, NULL, tf_warning_or_error);\n \t}\n     }\n   while (token->type == CPP_PLUS || token->type == CPP_MINUS);\n@@ -41873,7 +41875,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t  orig_init = rhs;\n \t  finish_expr_stmt (build_x_modify_expr (EXPR_LOCATION (rhs),\n \t\t\t\t\t\t decl, NOP_EXPR,\n-\t\t\t\t\t\t rhs,\n+\t\t\t\t\t\t rhs, NULL_TREE,\n \t\t\t\t\t\t tf_warning_or_error));\n \t  if (!add_private_clause)\n \t    add_private_clause = decl;\n@@ -41995,7 +41997,7 @@ cp_convert_omp_range_for (tree &this_pre_body, vec<tree, va_gc> *for_block,\n     cond = build_x_binary_op (input_location, NE_EXPR,\n \t\t\t      begin, ERROR_MARK,\n \t\t\t      end, ERROR_MARK,\n-\t\t\t      NULL, tf_warning_or_error);\n+\t\t\t      NULL_TREE, NULL, tf_warning_or_error);\n \n   /* The new increment expression.  */\n   if (CLASS_TYPE_P (iter_type))\n@@ -42033,7 +42035,7 @@ cp_convert_omp_range_for (tree &this_pre_body, vec<tree, va_gc> *for_block,\n   if (auto_node)\n     {\n       tree t = build_x_indirect_ref (input_location, begin, RO_UNARY_STAR,\n-\t\t\t\t     tf_none);\n+\t\t\t\t     NULL_TREE, tf_none);\n       if (!error_operand_p (t))\n \tTREE_TYPE (orig_decl) = do_auto_deduction (TREE_TYPE (orig_decl),\n \t\t\t\t\t\t   t, auto_node);\n@@ -42073,7 +42075,7 @@ cp_finish_omp_range_for (tree orig, tree begin)\n   /* The declaration is initialized with *__begin inside the loop body.  */\n   cp_finish_decl (decl,\n \t\t  build_x_indirect_ref (input_location, begin, RO_UNARY_STAR,\n-\t\t\t\t\ttf_warning_or_error),\n+\t\t\t\t\tNULL_TREE, tf_warning_or_error),\n \t\t  /*is_constant_init*/false, NULL_TREE,\n \t\t  LOOKUP_ONLYCONVERTING);\n   if (VAR_P (decl) && DECL_DECOMPOSITION_P (decl))"}, {"sha": "18c6f118ae6c2a14c85406bc0d998475e9dc6d53", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -12640,23 +12640,26 @@ expand_empty_fold (tree t, tsubst_flags_t complain)\n static tree\n fold_expression (tree t, tree left, tree right, tsubst_flags_t complain)\n {\n-  tree op = FOLD_EXPR_OP (t);\n-  tree_code code = (tree_code)TREE_INT_CST_LOW (op);\n+  tree_code code = FOLD_EXPR_OP (t);\n+\n+  tree lookups = templated_operator_saved_lookups (t);\n \n   // Handle compound assignment operators.\n   if (FOLD_EXPR_MODIFY_P (t))\n-    return build_x_modify_expr (input_location, left, code, right, complain);\n+    return build_x_modify_expr (input_location, left, code, right,\n+\t\t\t\tlookups, complain);\n \n   warning_sentinel s(warn_parentheses);\n   switch (code)\n     {\n     case COMPOUND_EXPR:\n-      return build_x_compound_expr (input_location, left, right, complain);\n+      return build_x_compound_expr (input_location, left, right,\n+\t\t\t\t    lookups, complain);\n     default:\n       return build_x_binary_op (input_location, code,\n                                 left, TREE_CODE (left),\n                                 right, TREE_CODE (right),\n-                                /*overload=*/NULL,\n+\t\t\t\tlookups, /*overload=*/NULL,\n                                 complain);\n     }\n }\n@@ -17891,7 +17894,7 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree &orig_declv,\n \t      tree lhs = RECUR (TREE_OPERAND (incr, 0));\n \t      tree rhs = RECUR (TREE_OPERAND (incr, 1));\n \t      incr = build_x_modify_expr (EXPR_LOCATION (incr), lhs,\n-\t\t\t\t\t  NOP_EXPR, rhs, complain);\n+\t\t\t\t\t  NOP_EXPR, rhs, NULL_TREE, complain);\n \t    }\n \t  else\n \t    incr = RECUR (incr);\n@@ -19204,6 +19207,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \tRETURN (RECUR (TREE_OPERAND (t, 1)));\n       RETURN (build_x_compound_expr (EXPR_LOCATION (t), tmp,\n \t\t\t\t    RECUR (TREE_OPERAND (t, 1)),\n+\t\t\t\t    templated_operator_saved_lookups (t),\n \t\t\t\t    complain));\n \n     case ANNOTATE_EXPR:\n@@ -19855,6 +19859,7 @@ tsubst_copy_and_build (tree t,\n \t  }\n \telse\n \t  r = build_x_indirect_ref (input_location, r, RO_UNARY_STAR,\n+\t\t\t\t    templated_operator_saved_lookups (t),\n \t\t\t\t    complain|decltype_flag);\n \n \tif (REF_PARENTHESIZED_P (t))\n@@ -19965,6 +19970,7 @@ tsubst_copy_and_build (tree t,\n       op1 = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),\n \t\t\t\t\t\targs, complain, in_decl);\n       RETURN (build_x_unary_op (input_location, TREE_CODE (t), op1,\n+\t\t\t\ttemplated_operator_saved_lookups (t),\n \t\t\t\tcomplain|decltype_flag));\n \n     case PREDECREMENT_EXPR:\n@@ -19978,6 +19984,7 @@ tsubst_copy_and_build (tree t,\n     case IMAGPART_EXPR:\n       RETURN (build_x_unary_op (input_location, TREE_CODE (t),\n \t\t\t\tRECUR (TREE_OPERAND (t, 0)),\n+\t\t\t\ttemplated_operator_saved_lookups (t),\n \t\t\t\tcomplain|decltype_flag));\n \n     case FIX_TRUNC_EXPR:\n@@ -19996,6 +20003,7 @@ tsubst_copy_and_build (tree t,\n \top1 = tsubst_non_call_postfix_expression (op1, args, complain,\n \t\t\t\t\t\t  in_decl);\n       RETURN (build_x_unary_op (input_location, ADDR_EXPR, op1,\n+\t\t\t\ttemplated_operator_saved_lookups (t),\n \t\t\t\tcomplain|decltype_flag));\n \n     case PLUS_EXPR:\n@@ -20060,6 +20068,7 @@ tsubst_copy_and_build (tree t,\n \t   (warning_suppressed_p (TREE_OPERAND (t, 1))\n \t    ? ERROR_MARK\n \t    : TREE_CODE (TREE_OPERAND (t, 1))),\n+\t   templated_operator_saved_lookups (t),\n \t   /*overload=*/NULL,\n \t   complain|decltype_flag);\n \tif (EXPR_P (r))\n@@ -20212,8 +20221,10 @@ tsubst_copy_and_build (tree t,\n \twarning_sentinel s(warn_div_by_zero);\n \ttree lhs = RECUR (TREE_OPERAND (t, 0));\n \ttree rhs = RECUR (TREE_OPERAND (t, 2));\n+\n \ttree r = build_x_modify_expr\n \t  (EXPR_LOCATION (t), lhs, TREE_CODE (TREE_OPERAND (t, 1)), rhs,\n+\t   templated_operator_saved_lookups (t),\n \t   complain|decltype_flag);\n \t/* TREE_NO_WARNING must be set if either the expression was\n \t   parenthesized or it uses an operator such as >>= rather\n@@ -20314,6 +20325,7 @@ tsubst_copy_and_build (tree t,\n \tRETURN (build_x_compound_expr (EXPR_LOCATION (t),\n \t\t\t\t       op0,\n \t\t\t\t       RECUR (TREE_OPERAND (t, 1)),\n+\t\t\t\t       templated_operator_saved_lookups (t),\n \t\t\t\t       complain|decltype_flag));\n       }\n \n@@ -26994,6 +27006,9 @@ dependent_type_p_r (tree type)\n   if (TREE_CODE (type) == TYPE_PACK_EXPANSION)\n     return true;\n \n+  if (TREE_CODE (type) == DEPENDENT_OPERATOR_TYPE)\n+    return true;\n+\n   if (any_dependent_type_attributes_p (TYPE_ATTRIBUTES (type)))\n     return true;\n "}, {"sha": "f7ddae77679c878576982a1e0dfb73e24d7094a8", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -151,6 +151,12 @@ cxx_print_type (FILE *file, tree node, int indent)\n       print_node (file, \"expr\", DECLTYPE_TYPE_EXPR (node), indent + 4);\n       return;\n \n+    case DEPENDENT_OPERATOR_TYPE:\n+      print_node (file, \"saved_lookups\",\n+\t\t  DEPENDENT_OPERATOR_TYPE_SAVED_LOOKUPS (node),\n+\t\t  indent + 4);\n+      return;\n+\n     case TYPENAME_TYPE:\n       print_node (file, \"fullname\", TYPENAME_TYPE_FULLNAME (node),\n \t\t  indent + 4);"}, {"sha": "6603066c6207b226a0130f69b2f366c797f78745", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -2920,7 +2920,7 @@ finish_increment_expr (cp_expr expr, enum tree_code code)\n \t\t\t\t\t   expr.get_start (),\n \t\t\t\t\t   get_finish (input_location));\n   cp_expr result = build_x_unary_op (combined_loc, code, expr,\n-\t\t\t\t     tf_warning_or_error);\n+\t\t\t\t     NULL_TREE, tf_warning_or_error);\n   /* TODO: build_x_unary_op doesn't honor the location, so set it here.  */\n   result.set_location (combined_loc);\n   return result;\n@@ -3031,7 +3031,8 @@ finish_unary_op_expr (location_t op_loc, enum tree_code code, cp_expr expr,\n      of the operator token to the end of EXPR.  */\n   location_t combined_loc = make_location (op_loc,\n \t\t\t\t\t   op_loc, expr.get_finish ());\n-  cp_expr result = build_x_unary_op (combined_loc, code, expr, complain);\n+  cp_expr result = build_x_unary_op (combined_loc, code, expr,\n+\t\t\t\t     NULL_TREE, complain);\n   /* TODO: build_x_unary_op doesn't always honor the location.  */\n   result.set_location (combined_loc);\n \n@@ -9884,7 +9885,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t\t\t\t\tTREE_CODE (cond),\n \t\t\t\t\titer, ERROR_MARK,\n \t\t\t\t\tTREE_OPERAND (cond, 1), ERROR_MARK,\n-\t\t\t\t\tNULL, tf_warning_or_error);\n+\t\t\t\t\tNULL_TREE, NULL, tf_warning_or_error);\n \t  if (error_operand_p (tem))\n \t    return true;\n \t}\n@@ -9898,9 +9899,10 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n       error_at (elocus, \"invalid controlling predicate\");\n       return true;\n     }\n-  diff = build_x_binary_op (elocus, MINUS_EXPR, TREE_OPERAND (cond, 1),\n-\t\t\t    ERROR_MARK, iter, ERROR_MARK, NULL,\n-\t\t\t    tf_warning_or_error);\n+  diff = build_x_binary_op (elocus, MINUS_EXPR,\n+\t\t\t    TREE_OPERAND (cond, 1), ERROR_MARK,\n+\t\t\t    iter, ERROR_MARK,\n+\t\t\t    NULL_TREE, NULL, tf_warning_or_error);\n   diff = cp_fully_fold (diff);\n   if (error_operand_p (diff))\n     return true;\n@@ -9928,7 +9930,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t}\n       iter_incr = build_x_unary_op (EXPR_LOCATION (incr),\n \t\t\t\t    TREE_CODE (incr), iter,\n-\t\t\t\t    tf_warning_or_error);\n+\t\t\t\t    NULL_TREE, tf_warning_or_error);\n       if (error_operand_p (iter_incr))\n \treturn true;\n       else if (TREE_CODE (incr) == PREINCREMENT_EXPR\n@@ -9954,6 +9956,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t\t  iter_incr = build_x_modify_expr (EXPR_LOCATION (rhs),\n \t\t\t\t\t\t   iter, TREE_CODE (rhs),\n \t\t\t\t\t\t   TREE_OPERAND (rhs, 1),\n+\t\t\t\t\t\t   NULL_TREE,\n \t\t\t\t\t\t   tf_warning_or_error);\n \t\t  if (error_operand_p (iter_incr))\n \t\t    return true;\n@@ -9983,13 +9986,13 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t\t\t\t\t\t PLUS_EXPR,\n \t\t\t\t\t\t TREE_OPERAND (rhs, 0),\n \t\t\t\t\t\t ERROR_MARK, iter,\n-\t\t\t\t\t\t ERROR_MARK, NULL,\n+\t\t\t\t\t\t ERROR_MARK, NULL_TREE, NULL,\n \t\t\t\t\t\t tf_warning_or_error);\n \t\t  if (error_operand_p (iter_incr))\n \t\t    return true;\n \t\t  iter_incr = build_x_modify_expr (EXPR_LOCATION (rhs),\n \t\t\t\t\t\t   iter, NOP_EXPR,\n-\t\t\t\t\t\t   iter_incr,\n+\t\t\t\t\t\t   iter_incr, NULL_TREE,\n \t\t\t\t\t\t   tf_warning_or_error);\n \t\t  if (error_operand_p (iter_incr))\n \t\t    return true;\n@@ -10100,7 +10103,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n   if (init != NULL)\n     finish_expr_stmt (build_x_modify_expr (elocus,\n \t\t\t\t\t   iter, NOP_EXPR, init,\n-\t\t\t\t\t   tf_warning_or_error));\n+\t\t\t\t\t   NULL_TREE, tf_warning_or_error));\n   init = build_int_cst (TREE_TYPE (diff), 0);\n   if (c && iter_incr == NULL\n       && (!ordered || (i < collapse && collapse > 1)))\n@@ -10109,23 +10112,24 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t{\n \t  finish_expr_stmt (build_x_modify_expr (elocus,\n \t\t\t\t\t\t incr_var, NOP_EXPR,\n-\t\t\t\t\t\t incr, tf_warning_or_error));\n+\t\t\t\t\t\t incr, NULL_TREE,\n+\t\t\t\t\t\t tf_warning_or_error));\n \t  incr = incr_var;\n \t}\n       iter_incr = build_x_modify_expr (elocus,\n \t\t\t\t       iter, PLUS_EXPR, incr,\n-\t\t\t\t       tf_warning_or_error);\n+\t\t\t\t       NULL_TREE, tf_warning_or_error);\n     }\n   if (c && ordered && i < collapse && collapse > 1)\n     iter_incr = incr;\n   finish_expr_stmt (build_x_modify_expr (elocus,\n \t\t\t\t\t last, NOP_EXPR, init,\n-\t\t\t\t\t tf_warning_or_error));\n+\t\t\t\t\t NULL_TREE, tf_warning_or_error));\n   if (diffvar)\n     {\n       finish_expr_stmt (build_x_modify_expr (elocus,\n \t\t\t\t\t     diffvar, NOP_EXPR,\n-\t\t\t\t\t     diff, tf_warning_or_error));\n+\t\t\t\t\t     diff, NULL_TREE, tf_warning_or_error));\n       diff = diffvar;\n     }\n   *pre_body = pop_stmt_list (*pre_body);\n@@ -10141,13 +10145,13 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n   iter_init = build2 (MINUS_EXPR, TREE_TYPE (diff), decl, last);\n   iter_init = build_x_modify_expr (elocus,\n \t\t\t\t   iter, PLUS_EXPR, iter_init,\n-\t\t\t\t   tf_warning_or_error);\n+\t\t\t\t   NULL_TREE, tf_warning_or_error);\n   if (iter_init != error_mark_node)\n     iter_init = build1 (NOP_EXPR, void_type_node, iter_init);\n   finish_expr_stmt (iter_init);\n   finish_expr_stmt (build_x_modify_expr (elocus,\n \t\t\t\t\t last, NOP_EXPR, decl,\n-\t\t\t\t\t tf_warning_or_error));\n+\t\t\t\t\t NULL_TREE, tf_warning_or_error));\n   add_stmt (orig_body);\n   *body = pop_stmt_list (*body);\n \n@@ -10165,7 +10169,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t  iter_init = build2 (MINUS_EXPR, TREE_TYPE (diff), iter_init, last);\n \t  iter_init = build_x_modify_expr (elocus,\n \t\t\t\t\t   iter, PLUS_EXPR, iter_init,\n-\t\t\t\t\t   tf_warning_or_error);\n+\t\t\t\t\t   NULL_TREE, tf_warning_or_error);\n \t  if (iter_init != error_mark_node)\n \t    iter_init = build1 (NOP_EXPR, void_type_node, iter_init);\n \t  finish_expr_stmt (iter_init);\n@@ -10876,7 +10880,7 @@ finish_omp_cancel (tree clauses)\n \tifc = build_x_binary_op (OMP_CLAUSE_LOCATION (ifc), NE_EXPR,\n \t\t\t\t OMP_CLAUSE_IF_EXPR (ifc), ERROR_MARK,\n \t\t\t\t integer_zero_node, ERROR_MARK,\n-\t\t\t\t NULL, tf_warning_or_error);\n+\t\t\t\t NULL_TREE, NULL, tf_warning_or_error);\n     }\n   else\n     ifc = boolean_true_node;\n@@ -12128,6 +12132,9 @@ finish_unary_fold_expr (tree expr, int op, tree_code dir)\n   tree code = build_int_cstu (integer_type_node, abs (op));\n   tree fold = build_min_nt_loc (UNKNOWN_LOCATION, dir, code, pack);\n   FOLD_EXPR_MODIFY_P (fold) = (op < 0);\n+  TREE_TYPE (fold) = build_dependent_operator_type (NULL_TREE,\n+\t\t\t\t\t\t    FOLD_EXPR_OP (fold),\n+\t\t\t\t\t\t    FOLD_EXPR_MODIFY_P (fold));\n   return fold;\n }\n \n@@ -12154,6 +12161,9 @@ finish_binary_fold_expr (tree pack, tree init, int op, tree_code dir)\n   tree code = build_int_cstu (integer_type_node, abs (op));\n   tree fold = build_min_nt_loc (UNKNOWN_LOCATION, dir, code, pack, init);\n   FOLD_EXPR_MODIFY_P (fold) = (op < 0);\n+  TREE_TYPE (fold) = build_dependent_operator_type (NULL_TREE,\n+\t\t\t\t\t\t    FOLD_EXPR_OP (fold),\n+\t\t\t\t\t\t    FOLD_EXPR_MODIFY_P (fold));\n   return fold;\n }\n "}, {"sha": "29f3c171606a927b90a7bae2077afb070e401c21", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -5975,8 +5975,6 @@ cp_free_lang_data (tree t)\n       DECL_EXTERNAL (t) = 1;\n       TREE_STATIC (t) = 0;\n     }\n-  if (TREE_CODE (t) == FUNCTION_DECL)\n-    discard_operator_bindings (t);\n   if (TREE_CODE (t) == NAMESPACE_DECL)\n     /* We do not need the leftover chaining of namespaces from the\n        binding level.  */"}, {"sha": "5184b02d3e4ee8bd71826a746e28f188e4e4f084", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 94, "deletions": 21, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -2602,6 +2602,7 @@ rationalize_conditional_expr (enum tree_code code, tree t,\n \t\t\t\t\t\t    ? LE_EXPR : GE_EXPR),\n \t\t\t\t\t\t   op0, TREE_CODE (op0),\n \t\t\t\t\t\t   op1, TREE_CODE (op1),\n+\t\t\t\t\t\t   NULL_TREE,\n \t\t\t\t\t\t   /*overload=*/NULL,\n \t\t\t\t\t\t   complain),\n                                 cp_build_unary_op (code, op0, false, complain),\n@@ -3487,6 +3488,67 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n   return build_simple_component_ref (ptrmem, member);\n }\n \n+/* Return a TREE_LIST of namespace-scope overloads for the given operator,\n+   and for any other relevant operator.  */\n+\n+static tree\n+op_unqualified_lookup (tree_code code, bool is_assign)\n+{\n+  tree lookups = NULL_TREE;\n+\n+  if (cxx_dialect >= cxx20 && !is_assign)\n+    {\n+      if (code == NE_EXPR)\n+\t{\n+\t  /* != can get rewritten in terms of ==.  */\n+\t  tree fnname = ovl_op_identifier (false, EQ_EXPR);\n+\t  if (tree fns = lookup_name (fnname, LOOK_where::BLOCK_NAMESPACE))\n+\t    lookups = tree_cons (fnname, fns, lookups);\n+\t}\n+      else if (code == GT_EXPR || code == LE_EXPR\n+\t       || code == LT_EXPR || code == GE_EXPR)\n+\t{\n+\t  /* These can get rewritten in terms of <=>.  */\n+\t  tree fnname = ovl_op_identifier (false, SPACESHIP_EXPR);\n+\t  if (tree fns = lookup_name (fnname, LOOK_where::BLOCK_NAMESPACE))\n+\t    lookups = tree_cons (fnname, fns, lookups);\n+\t}\n+    }\n+\n+  tree fnname = ovl_op_identifier (is_assign, code);\n+  if (tree fns = lookup_name (fnname, LOOK_where::BLOCK_NAMESPACE))\n+    lookups = tree_cons (fnname, fns, lookups);\n+\n+  if (lookups)\n+    return lookups;\n+  else\n+    return build_tree_list (NULL_TREE, NULL_TREE);\n+}\n+\n+/* Create a DEPENDENT_OPERATOR_TYPE for a dependent operator expression of\n+   the given operator.  LOOKUPS, if non-NULL, is the result of phase 1\n+   name lookup for the given operator.  */\n+\n+tree\n+build_dependent_operator_type (tree lookups, tree_code code, bool is_assign)\n+{\n+  if (lookups)\n+    /* We're partially instantiating a dependent operator expression, and\n+       LOOKUPS is the result of phase 1 name lookup that we performed\n+       earlier at template definition time, so just reuse the corresponding\n+       DEPENDENT_OPERATOR_TYPE.  */\n+    return TREE_TYPE (lookups);\n+\n+  /* Otherwise we're processing a dependent operator expression at template\n+     definition time, so perform phase 1 name lookup now.  */\n+  lookups = op_unqualified_lookup (code, is_assign);\n+\n+  tree type = cxx_make_type (DEPENDENT_OPERATOR_TYPE);\n+  DEPENDENT_OPERATOR_TYPE_SAVED_LOOKUPS (type) = lookups;\n+  TREE_TYPE (lookups) = type;\n+  return type;\n+}\n+\n /* Given an expression PTR for a pointer, return an expression\n    for the value pointed to.\n    ERRORSTRING is the name of the operator to appear in error messages.\n@@ -3496,7 +3558,7 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n \n tree\n build_x_indirect_ref (location_t loc, tree expr, ref_operator errorstring, \n-                      tsubst_flags_t complain)\n+\t\t      tree lookups, tsubst_flags_t complain)\n {\n   tree orig_expr = expr;\n   tree rval;\n@@ -3516,12 +3578,18 @@ build_x_indirect_ref (location_t loc, tree expr, ref_operator errorstring,\n \t  return build_min (INDIRECT_REF, TREE_TYPE (TREE_TYPE (expr)), expr);\n \t}\n       if (type_dependent_expression_p (expr))\n-\treturn build_min_nt_loc (loc, INDIRECT_REF, expr);\n+\t{\n+\t  expr = build_min_nt_loc (loc, INDIRECT_REF, expr);\n+\t  TREE_TYPE (expr)\n+\t    = build_dependent_operator_type (lookups, INDIRECT_REF, false);\n+\t  return expr;\n+\t}\n       expr = build_non_dependent_expr (expr);\n     }\n \n   rval = build_new_op (loc, INDIRECT_REF, LOOKUP_NORMAL, expr,\n-\t\t       NULL_TREE, NULL_TREE, &overload, complain);\n+\t\t       NULL_TREE, NULL_TREE, lookups,\n+\t\t       &overload, complain);\n   if (!rval)\n     rval = cp_build_indirect_ref (loc, expr, errorstring, complain);\n \n@@ -4458,8 +4526,8 @@ convert_arguments (tree typelist, vec<tree, va_gc> **values, tree fndecl,\n tree\n build_x_binary_op (const op_location_t &loc, enum tree_code code, tree arg1,\n \t\t   enum tree_code arg1_code, tree arg2,\n-\t\t   enum tree_code arg2_code, tree *overload_p,\n-\t\t   tsubst_flags_t complain)\n+\t\t   enum tree_code arg2_code, tree lookups,\n+\t\t   tree *overload_p, tsubst_flags_t complain)\n {\n   tree orig_arg1;\n   tree orig_arg2;\n@@ -4475,7 +4543,8 @@ build_x_binary_op (const op_location_t &loc, enum tree_code code, tree arg1,\n \t  || type_dependent_expression_p (arg2))\n \t{\n \t  expr = build_min_nt_loc (loc, code, arg1, arg2);\n-\t  maybe_save_operator_binding (expr);\n+\t  TREE_TYPE (expr)\n+\t    = build_dependent_operator_type (lookups, code, false);\n \t  return expr;\n \t}\n       arg1 = build_non_dependent_expr (arg1);\n@@ -4486,7 +4555,7 @@ build_x_binary_op (const op_location_t &loc, enum tree_code code, tree arg1,\n     expr = build_m_component_ref (arg1, arg2, complain);\n   else\n     expr = build_new_op (loc, code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE,\n-\t\t\t &overload, complain);\n+\t\t\t lookups, &overload, complain);\n \n   if (overload_p != NULL)\n     *overload_p = overload;\n@@ -4538,7 +4607,7 @@ build_x_array_ref (location_t loc, tree arg1, tree arg2,\n     }\n \n   expr = build_new_op (loc, ARRAY_REF, LOOKUP_NORMAL, arg1, arg2,\n-\t\t       NULL_TREE, &overload, complain);\n+\t\t       NULL_TREE, NULL_TREE, &overload, complain);\n \n   if (processing_template_decl && expr != error_mark_node)\n     {\n@@ -6402,7 +6471,7 @@ pointer_diff (location_t loc, tree op0, tree op1, tree ptrtype,\n \n tree\n build_x_unary_op (location_t loc, enum tree_code code, cp_expr xarg,\n-\t\t  tsubst_flags_t complain)\n+\t\t  tree lookups, tsubst_flags_t complain)\n {\n   tree orig_expr = xarg;\n   tree exp;\n@@ -6414,7 +6483,7 @@ build_x_unary_op (location_t loc, enum tree_code code, cp_expr xarg,\n       if (type_dependent_expression_p (xarg))\n \t{\n \t  tree e = build_min_nt_loc (loc, code, xarg.get_value (), NULL_TREE);\n-\t  maybe_save_operator_binding (e);\n+\t  TREE_TYPE (e) = build_dependent_operator_type (lookups, code, false);\n \t  return e;\n \t}\n \n@@ -6439,7 +6508,7 @@ build_x_unary_op (location_t loc, enum tree_code code, cp_expr xarg,\n     /* Don't look for a function.  */;\n   else\n     exp = build_new_op (loc, code, LOOKUP_NORMAL, xarg, NULL_TREE,\n-\t\t\tNULL_TREE, &overload, complain);\n+\t\t\tNULL_TREE, lookups, &overload, complain);\n \n   if (!exp && code == ADDR_EXPR)\n     {\n@@ -7508,7 +7577,8 @@ build_x_compound_expr_from_list (tree list, expr_list_kind exp,\n \n       for (list = TREE_CHAIN (list); list; list = TREE_CHAIN (list))\n \texpr = build_x_compound_expr (EXPR_LOCATION (TREE_VALUE (list)),\n-\t\t\t\t      expr, TREE_VALUE (list), complain);\n+\t\t\t\t      expr, TREE_VALUE (list), NULL_TREE,\n+\t\t\t\t      complain);\n     }\n \n   return expr;\n@@ -7543,7 +7613,7 @@ build_x_compound_expr_from_vec (vec<tree, va_gc> *vec, const char *msg,\n       expr = (*vec)[0];\n       for (ix = 1; vec->iterate (ix, &t); ++ix)\n \texpr = build_x_compound_expr (EXPR_LOCATION (t), expr,\n-\t\t\t\t      t, complain);\n+\t\t\t\t      t, NULL_TREE, complain);\n \n       return expr;\n     }\n@@ -7553,7 +7623,7 @@ build_x_compound_expr_from_vec (vec<tree, va_gc> *vec, const char *msg,\n \n tree\n build_x_compound_expr (location_t loc, tree op1, tree op2,\n-\t\t       tsubst_flags_t complain)\n+\t\t       tree lookups, tsubst_flags_t complain)\n {\n   tree result;\n   tree orig_op1 = op1;\n@@ -7566,15 +7636,16 @@ build_x_compound_expr (location_t loc, tree op1, tree op2,\n \t  || type_dependent_expression_p (op2))\n \t{\n \t  result = build_min_nt_loc (loc, COMPOUND_EXPR, op1, op2);\n-\t  maybe_save_operator_binding (result);\n+\t  TREE_TYPE (result)\n+\t    = build_dependent_operator_type (lookups, COMPOUND_EXPR, false);\n \t  return result;\n \t}\n       op1 = build_non_dependent_expr (op1);\n       op2 = build_non_dependent_expr (op2);\n     }\n \n   result = build_new_op (loc, COMPOUND_EXPR, LOOKUP_NORMAL, op1, op2,\n-\t\t\t NULL_TREE, &overload, complain);\n+\t\t\t NULL_TREE, lookups, &overload, complain);\n   if (!result)\n     result = cp_build_compound_expr (op1, op2, complain);\n \n@@ -9017,8 +9088,8 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t    {\n \t      result = build_new_op (input_location, MODIFY_EXPR,\n \t\t\t\t     LOOKUP_NORMAL, lhs, rhs,\n-\t\t\t\t     make_node (NOP_EXPR), /*overload=*/NULL,\n-\t\t\t\t     complain);\n+\t\t\t\t     make_node (NOP_EXPR), NULL_TREE,\n+\t\t\t\t     /*overload=*/NULL, complain);\n \t      if (result == NULL_TREE)\n \t\treturn error_mark_node;\n \t      goto ret;\n@@ -9233,7 +9304,7 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \n cp_expr\n build_x_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n-\t\t     tree rhs, tsubst_flags_t complain)\n+\t\t     tree rhs, tree lookups, tsubst_flags_t complain)\n {\n   tree orig_lhs = lhs;\n   tree orig_rhs = rhs;\n@@ -9250,7 +9321,9 @@ build_x_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t{\n \t  tree op = build_min_nt_loc (loc, modifycode, NULL_TREE, NULL_TREE);\n \t  tree rval = build_min_nt_loc (loc, MODOP_EXPR, lhs, op, rhs);\n-\t  maybe_save_operator_binding (rval);\n+\t  if (modifycode != NOP_EXPR)\n+\t    TREE_TYPE (rval)\n+\t      = build_dependent_operator_type (lookups, modifycode, true);\n \t  return rval;\n \t}\n \n@@ -9262,7 +9335,7 @@ build_x_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n     {\n       tree op = build_nt (modifycode, NULL_TREE, NULL_TREE);\n       tree rval = build_new_op (loc, MODIFY_EXPR, LOOKUP_NORMAL,\n-\t\t\t\tlhs, rhs, op, &overload, complain);\n+\t\t\t\tlhs, rhs, op, lookups, &overload, complain);\n       if (rval)\n \t{\n \t  if (rval == error_mark_node)"}, {"sha": "724684c0457d8cd9c1e4e4929e647410e6ac8370", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -1956,7 +1956,7 @@ build_x_arrow (location_t loc, tree expr, tsubst_flags_t complain)\n \n       while ((expr = build_new_op (loc, COMPONENT_REF,\n \t\t\t\t   LOOKUP_NORMAL, expr, NULL_TREE, NULL_TREE,\n-\t\t\t\t   &fn, complain)))\n+\t\t\t\t   NULL_TREE, &fn, complain)))\n \t{\n \t  if (expr == error_mark_node)\n \t    return error_mark_node;"}, {"sha": "fbd242a4e66b599df7728510d34b45e6e17c1ea4", "filename": "gcc/testsuite/g++.dg/lookup/operator-3-ops.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-3-ops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-3-ops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-3-ops.h?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -0,0 +1,53 @@\n+void operator+(N::A);\n+void operator-(N::A);\n+void operator*(N::A);\n+void operator~(N::A);\n+#if __cplusplus >= 201103L\n+void operator&(N::A) = delete;\n+#else\n+void operator&(N::A);\n+#endif\n+void operator!(N::A);\n+void operator++(N::A);\n+void operator--(N::A);\n+void operator++(N::A, int);\n+void operator--(N::A, int);\n+\n+void operator->*(N::A, N::A);\n+void operator/(N::A, N::A);\n+void operator*(N::A, N::A);\n+void operator+(N::A, N::A);\n+void operator-(N::A, N::A);\n+void operator%(N::A, N::A);\n+void operator&(N::A, N::A);\n+void operator|(N::A, N::A);\n+void operator^(N::A, N::A);\n+void operator<<(N::A, N::A);\n+void operator>>(N::A, N::A);\n+void operator&&(N::A, N::A);\n+void operator||(N::A, N::A);\n+#if __cplusplus >= 201103L\n+void operator,(N::A, N::A) = delete;\n+#else\n+void operator,(N::A, N::A);\n+#endif\n+\n+void operator==(N::A, N::A);\n+void operator!=(N::A, N::A);\n+void operator<(N::A, N::A);\n+void operator>(N::A, N::A);\n+void operator<=(N::A, N::A);\n+void operator>=(N::A, N::A);\n+#if __cplusplus > 201703L\n+void operator<=>(N::A, N::A);\n+#endif\n+\n+void operator+=(N::A, N::A);\n+void operator-=(N::A, N::A);\n+void operator*=(N::A, N::A);\n+void operator/=(N::A, N::A);\n+void operator%=(N::A, N::A);\n+void operator|=(N::A, N::A);\n+void operator^=(N::A, N::A);\n+void operator<<=(N::A, N::A);\n+void operator>>=(N::A, N::A);"}, {"sha": "ab0257a66aaf60e9806464f4471c6c3f79eaed7d", "filename": "gcc/testsuite/g++.dg/lookup/operator-3.C", "status": "modified", "additions": 3, "deletions": 53, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-3.C?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -1,4 +1,6 @@\n // PR c++/51577\n+// Verify we don't consider later-declared namespace-scope operator overloads\n+// when instantiating a dependent operator expression that occurs at block scope.\n \n template <class T> void f (T x) {\n   +x; // { dg-error \"no match\" }\n@@ -50,59 +52,7 @@ template <class T> void f (T x) {\n \n namespace N { struct A { }; }\n \n-void operator+(N::A);\n-void operator-(N::A);\n-void operator*(N::A);\n-void operator~(N::A);\n-#if __cplusplus >= 201103L\n-void operator&(N::A) = delete;\n-#else\n-void operator&(N::A);\n-#endif\n-void operator!(N::A);\n-void operator++(N::A);\n-void operator--(N::A);\n-void operator++(N::A, int);\n-void operator--(N::A, int);\n-\n-void operator->*(N::A, N::A);\n-void operator/(N::A, N::A);\n-void operator*(N::A, N::A);\n-void operator+(N::A, N::A);\n-void operator-(N::A, N::A);\n-void operator%(N::A, N::A);\n-void operator&(N::A, N::A);\n-void operator|(N::A, N::A);\n-void operator^(N::A, N::A);\n-void operator<<(N::A, N::A);\n-void operator>>(N::A, N::A);\n-void operator&&(N::A, N::A);\n-void operator||(N::A, N::A);\n-#if __cplusplus >= 201103L\n-void operator,(N::A, N::A) = delete;\n-#else\n-void operator,(N::A, N::A);\n-#endif\n-\n-void operator==(N::A, N::A);\n-void operator!=(N::A, N::A);\n-void operator<(N::A, N::A);\n-void operator>(N::A, N::A);\n-void operator<=(N::A, N::A);\n-void operator>=(N::A, N::A);\n-#if __cplusplus > 201703L\n-void operator<=>(N::A, N::A);\n-#endif\n-\n-void operator+=(N::A, N::A);\n-void operator-=(N::A, N::A);\n-void operator*=(N::A, N::A);\n-void operator/=(N::A, N::A);\n-void operator%=(N::A, N::A);\n-void operator|=(N::A, N::A);\n-void operator^=(N::A, N::A);\n-void operator<<=(N::A, N::A);\n-void operator>>=(N::A, N::A);\n+#include \"operator-3-ops.h\"\n \n int main() {\n   f(N::A());"}, {"sha": "62ae5c36dc2fc541a8ad1c10dcc3af735a76f53c", "filename": "gcc/testsuite/g++.dg/lookup/operator-3a.C", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-3a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-3a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-3a.C?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -0,0 +1,61 @@\n+// PR c++/51577\n+// { dg-do compile { target c++14 } }\n+// Like operator-3.C but also containing a partial instantiation step.\n+\n+template <class...> auto f () {\n+  return [] (auto x) {\n+    +x; // { dg-error \"no match\" }\n+    -x; // { dg-error \"no match\" }\n+    *x; // { dg-error \"no match\" }\n+    ~x; // { dg-error \"no match\" }\n+    &x;\n+    !x; // { dg-error \"no match\" }\n+    ++x; // { dg-error \"no match\" }\n+    --x; // { dg-error \"no match\" }\n+    x++; // { dg-error \"declared for postfix\" }\n+    x--; // { dg-error \"declared for postfix\" }\n+\n+    x->*x; // { dg-error \"no match\" }\n+    x / x; // { dg-error \"no match\" }\n+    x * x; // { dg-error \"no match\" }\n+    x + x; // { dg-error \"no match\" }\n+    x - x; // { dg-error \"no match\" }\n+    x % x; // { dg-error \"no match\" }\n+    x & x; // { dg-error \"no match\" }\n+    x | x; // { dg-error \"no match\" }\n+    x ^ x; // { dg-error \"no match\" }\n+    x << x; // { dg-error \"no match\" }\n+    x >> x; // { dg-error \"no match\" }\n+    x && x; // { dg-error \"no match\" }\n+    x || x; // { dg-error \"no match\" }\n+    x, x;\n+\n+    x == x; // { dg-error \"no match\" }\n+    x != x; // { dg-error \"no match\" }\n+    x < x; // { dg-error \"no match\" }\n+    x > x; // { dg-error \"no match\" }\n+    x <= x; // { dg-error \"no match\" }\n+    x >= x; // { dg-error \"no match\" }\n+#if __cplusplus > 201703L\n+    x <=> x; // { dg-error \"no match\" \"\" { target c++20 } }\n+#endif\n+\n+    x += x; // { dg-error \"no match\" }\n+    x -= x; // { dg-error \"no match\" }\n+    x *= x; // { dg-error \"no match\" }\n+    x /= x; // { dg-error \"no match\" }\n+    x %= x; // { dg-error \"no match\" }\n+    x |= x; // { dg-error \"no match\" }\n+    x ^= x; // { dg-error \"no match\" }\n+    x <<= x; // { dg-error \"no match\" }\n+    x >>= x; // { dg-error \"no match\" }\n+  };\n+}\n+\n+namespace N { struct A { }; }\n+\n+#include \"operator-3-ops.h\"\n+\n+int main() {\n+  f()(N::A());\n+}"}, {"sha": "e0b80a1c3b39329fb5d9ddc85e4ae51a837b6652", "filename": "gcc/testsuite/g++.dg/lookup/operator-4.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-4.C?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -0,0 +1,74 @@\n+// PR c++/51577\n+// { dg-do compile { target c++17 } }\n+// Like operator-3.C but for unary fold expressions.\n+\n+template <class... Ts> void f (Ts... xs) {\n+  (xs->*...); // { dg-error \"no match\" }\n+  (...->*xs); // { dg-error \"no match\" }\n+  (xs / ...); // { dg-error \"no match\" }\n+  (... / xs); // { dg-error \"no match\" }\n+  (xs * ...); // { dg-error \"no match\" }\n+  (... * xs); // { dg-error \"no match\" }\n+  (xs + ...); // { dg-error \"no match\" }\n+  (... + xs); // { dg-error \"no match\" }\n+  (xs - ...); // { dg-error \"no match\" }\n+  (... - xs); // { dg-error \"no match\" }\n+  (xs % ...); // { dg-error \"no match\" }\n+  (... % xs); // { dg-error \"no match\" }\n+  (xs & ...); // { dg-error \"no match\" }\n+  (... & xs); // { dg-error \"no match\" }\n+  (xs | ...); // { dg-error \"no match\" }\n+  (... | xs); // { dg-error \"no match\" }\n+  (xs ^ ...); // { dg-error \"no match\" }\n+  (... ^ xs); // { dg-error \"no match\" }\n+  (xs << ...); // { dg-error \"no match\" }\n+  (... << xs); // { dg-error \"no match\" }\n+  (xs >> ...); // { dg-error \"no match\" }\n+  (... >> xs); // { dg-error \"no match\" }\n+  (xs && ...); // { dg-error \"no match\" }\n+  (... && xs); // { dg-error \"no match\" }\n+  (xs || ...); // { dg-error \"no match\" }\n+  (... || xs); // { dg-error \"no match\" }\n+  (xs, ...);\n+  (..., xs);\n+\n+  (xs == ...); // { dg-error \"no match\" }\n+  (... == xs); // { dg-error \"no match\" }\n+  (xs != ...); // { dg-error \"no match\" }\n+  (... != xs); // { dg-error \"no match\" }\n+  (xs < ...); // { dg-error \"no match\" }\n+  (... < xs); // { dg-error \"no match\" }\n+  (xs > ...); // { dg-error \"no match\" }\n+  (... > xs); // { dg-error \"no match\" }\n+  (xs <= ...); // { dg-error \"no match\" }\n+  (... <= xs); // { dg-error \"no match\" }\n+  (xs >= ...); // { dg-error \"no match\" }\n+  (... >= xs); // { dg-error \"no match\" }\n+\n+  (xs += ...); // { dg-error \"no match\" }\n+  (... += xs); // { dg-error \"no match\" }\n+  (xs -= ...); // { dg-error \"no match\" }\n+  (... -= xs); // { dg-error \"no match\" }\n+  (xs *= ...); // { dg-error \"no match\" }\n+  (... *= xs); // { dg-error \"no match\" }\n+  (xs /= ...); // { dg-error \"no match\" }\n+  (... /= xs); // { dg-error \"no match\" }\n+  (xs %= ...); // { dg-error \"no match\" }\n+  (... %= xs); // { dg-error \"no match\" }\n+  (xs |= ...); // { dg-error \"no match\" }\n+  (... |= xs); // { dg-error \"no match\" }\n+  (xs ^= ...); // { dg-error \"no match\" }\n+  (... ^= xs); // { dg-error \"no match\" }\n+  (xs <<= ...); // { dg-error \"no match\" }\n+  (... <<= xs); // { dg-error \"no match\" }\n+  (xs >>= ...); // { dg-error \"no match\" }\n+  (... >>= xs); // { dg-error \"no match\" }\n+}\n+\n+namespace N { struct A { }; }\n+\n+#include \"operator-3-ops.h\"\n+\n+int main() {\n+  f(N::A(), N::A());\n+}"}, {"sha": "b4a3f947b05246f36dfd67c3e90e5161afe97125", "filename": "gcc/testsuite/g++.dg/lookup/operator-4a.C", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-4a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-4a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-4a.C?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -0,0 +1,76 @@\n+// PR c++/51577\n+// { dg-do compile { target c++17 } }\n+// Like operator-4.C but also containing a partial instantiation step.\n+\n+template <class...> auto f () {\n+  return [] (auto... xs) {\n+    (xs->*...); // { dg-error \"no match\" }\n+    (...->*xs); // { dg-error \"no match\" }\n+    (xs / ...); // { dg-error \"no match\" }\n+    (... / xs); // { dg-error \"no match\" }\n+    (xs * ...); // { dg-error \"no match\" }\n+    (... * xs); // { dg-error \"no match\" }\n+    (xs + ...); // { dg-error \"no match\" }\n+    (... + xs); // { dg-error \"no match\" }\n+    (xs - ...); // { dg-error \"no match\" }\n+    (... - xs); // { dg-error \"no match\" }\n+    (xs % ...); // { dg-error \"no match\" }\n+    (... % xs); // { dg-error \"no match\" }\n+    (xs & ...); // { dg-error \"no match\" }\n+    (... & xs); // { dg-error \"no match\" }\n+    (xs | ...); // { dg-error \"no match\" }\n+    (... | xs); // { dg-error \"no match\" }\n+    (xs ^ ...); // { dg-error \"no match\" }\n+    (... ^ xs); // { dg-error \"no match\" }\n+    (xs << ...); // { dg-error \"no match\" }\n+    (... << xs); // { dg-error \"no match\" }\n+    (xs >> ...); // { dg-error \"no match\" }\n+    (... >> xs); // { dg-error \"no match\" }\n+    (xs && ...); // { dg-error \"no match\" }\n+    (... && xs); // { dg-error \"no match\" }\n+    (xs || ...); // { dg-error \"no match\" }\n+    (... || xs); // { dg-error \"no match\" }\n+    (xs, ...);\n+    (..., xs);\n+\n+    (xs == ...); // { dg-error \"no match\" }\n+    (... == xs); // { dg-error \"no match\" }\n+    (xs != ...); // { dg-error \"no match\" }\n+    (... != xs); // { dg-error \"no match\" }\n+    (xs < ...); // { dg-error \"no match\" }\n+    (... < xs); // { dg-error \"no match\" }\n+    (xs > ...); // { dg-error \"no match\" }\n+    (... > xs); // { dg-error \"no match\" }\n+    (xs <= ...); // { dg-error \"no match\" }\n+    (... <= xs); // { dg-error \"no match\" }\n+    (xs >= ...); // { dg-error \"no match\" }\n+    (... >= xs); // { dg-error \"no match\" }\n+\n+    (xs += ...); // { dg-error \"no match\" }\n+    (... += xs); // { dg-error \"no match\" }\n+    (xs -= ...); // { dg-error \"no match\" }\n+    (... -= xs); // { dg-error \"no match\" }\n+    (xs *= ...); // { dg-error \"no match\" }\n+    (... *= xs); // { dg-error \"no match\" }\n+    (xs /= ...); // { dg-error \"no match\" }\n+    (... /= xs); // { dg-error \"no match\" }\n+    (xs %= ...); // { dg-error \"no match\" }\n+    (... %= xs); // { dg-error \"no match\" }\n+    (xs |= ...); // { dg-error \"no match\" }\n+    (... |= xs); // { dg-error \"no match\" }\n+    (xs ^= ...); // { dg-error \"no match\" }\n+    (... ^= xs); // { dg-error \"no match\" }\n+    (xs <<= ...); // { dg-error \"no match\" }\n+    (... <<= xs); // { dg-error \"no match\" }\n+    (xs >>= ...); // { dg-error \"no match\" }\n+    (... >>= xs); // { dg-error \"no match\" }\n+  };\n+}\n+\n+namespace N { struct A { }; }\n+\n+#include \"operator-3-ops.h\"\n+\n+int main() {\n+  f()(N::A(), N::A());\n+}"}, {"sha": "2bbb2c41618c0ccfe674a90e19c6887566d20d78", "filename": "gcc/testsuite/g++.dg/lookup/operator-5.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-5.C?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -0,0 +1,74 @@\n+// PR c++/51577\n+// { dg-do compile { target c++17 } }\n+// Like operator-4.C but for binary fold expressions.\n+\n+namespace N { struct A { }; }\n+\n+template <class... Ts> void f (Ts... xs) {\n+  (xs->*...->*N::A{}); // { dg-error \"no match\" }\n+  (N::A{}->*...->*xs); // { dg-error \"no match\" }\n+  (xs / ... / N::A{}); // { dg-error \"no match\" }\n+  (N::A{} / ... / xs); // { dg-error \"no match\" }\n+  (xs * ... * N::A{}); // { dg-error \"no match\" }\n+  (N::A{} * ... * xs); // { dg-error \"no match\" }\n+  (xs + ... + N::A{}); // { dg-error \"no match\" }\n+  (N::A{} + ... + xs); // { dg-error \"no match\" }\n+  (xs - ... - N::A{}); // { dg-error \"no match\" }\n+  (N::A{} - ... - xs); // { dg-error \"no match\" }\n+  (xs % ... % N::A{}); // { dg-error \"no match\" }\n+  (N::A{} % ... % xs); // { dg-error \"no match\" }\n+  (xs & ... & N::A{}); // { dg-error \"no match\" }\n+  (N::A{} & ... & xs); // { dg-error \"no match\" }\n+  (xs | ... | N::A{}); // { dg-error \"no match\" }\n+  (N::A{} | ... | xs); // { dg-error \"no match\" }\n+  (xs ^ ... ^ N::A{}); // { dg-error \"no match\" }\n+  (N::A{} ^ ... ^ xs); // { dg-error \"no match\" }\n+  (xs << ... << N::A{}); // { dg-error \"no match\" }\n+  (N::A{} << ... << xs); // { dg-error \"no match\" }\n+  (xs >> ... >> N::A{}); // { dg-error \"no match\" }\n+  (N::A{} >> ... >> xs); // { dg-error \"no match\" }\n+  (xs && ... && N::A{}); // { dg-error \"no match\" }\n+  (N::A{} && ... && xs); // { dg-error \"no match\" }\n+  (xs || ... || N::A{}); // { dg-error \"no match\" }\n+  (N::A{} || ... || xs); // { dg-error \"no match\" }\n+  (xs , ... , N::A{});\n+  (N::A{} , ... , xs);\n+\n+  (xs == ... == N::A{}); // { dg-error \"no match\" }\n+  (N::A{} == ... == xs); // { dg-error \"no match\" }\n+  (xs != ... != N::A{}); // { dg-error \"no match\" }\n+  (N::A{} != ... != xs); // { dg-error \"no match\" }\n+  (xs < ... < N::A{}); // { dg-error \"no match\" }\n+  (N::A{} < ... < xs); // { dg-error \"no match\" }\n+  (xs > ... > N::A{}); // { dg-error \"no match\" }\n+  (N::A{} > ... > xs); // { dg-error \"no match\" }\n+  (xs <= ... <= N::A{}); // { dg-error \"no match\" }\n+  (N::A{} <= ... <= xs); // { dg-error \"no match\" }\n+  (xs >= ... >= N::A{}); // { dg-error \"no match\" }\n+  (N::A{} >= ... >= xs); // { dg-error \"no match\" }\n+\n+  (xs += ... += N::A{}); // { dg-error \"no match\" }\n+  (N::A{} += ... += xs); // { dg-error \"no match\" }\n+  (xs -= ... -= N::A{}); // { dg-error \"no match\" }\n+  (N::A{} -= ... -= xs); // { dg-error \"no match\" }\n+  (xs *= ... *= N::A{}); // { dg-error \"no match\" }\n+  (N::A{} *= ... *= xs); // { dg-error \"no match\" }\n+  (xs /= ... /= N::A{}); // { dg-error \"no match\" }\n+  (N::A{} /= ... /= xs); // { dg-error \"no match\" }\n+  (xs %= ... %= N::A{}); // { dg-error \"no match\" }\n+  (N::A{} %= ... %= xs); // { dg-error \"no match\" }\n+  (xs |= ... |= N::A{}); // { dg-error \"no match\" }\n+  (N::A{} |= ... |= xs); // { dg-error \"no match\" }\n+  (xs ^= ... ^= N::A{}); // { dg-error \"no match\" }\n+  (N::A{} ^= ... ^= xs); // { dg-error \"no match\" }\n+  (xs <<= ... <<= N::A{}); // { dg-error \"no match\" }\n+  (N::A{} <<= ... <<= xs); // { dg-error \"no match\" }\n+  (xs >>= ... >>= N::A{}); // { dg-error \"no match\" }\n+  (N::A{} >>= ... >>= xs); // { dg-error \"no match\" }\n+}\n+\n+#include \"operator-3-ops.h\"\n+\n+int main() {\n+  f(N::A());\n+}"}, {"sha": "6f9ecd65a50b66a61b40f2384907e0d3ca0a5777", "filename": "gcc/testsuite/g++.dg/lookup/operator-5a.C", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-5a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-5a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-5a.C?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -0,0 +1,76 @@\n+// PR c++/51577\n+// { dg-do compile { target c++17 } }\n+// Like operator-5.C but also containing a partial instantiation step.\n+\n+namespace N { struct A { }; }\n+\n+template <class...> auto f () {\n+  return [] (auto... xs) {\n+    (xs->*...->*N::A{}); // { dg-error \"no match\" }\n+    (N::A{}->*...->*xs); // { dg-error \"no match\" }\n+    (xs / ... / N::A{}); // { dg-error \"no match\" }\n+    (N::A{} / ... / xs); // { dg-error \"no match\" }\n+    (xs * ... * N::A{}); // { dg-error \"no match\" }\n+    (N::A{} * ... * xs); // { dg-error \"no match\" }\n+    (xs + ... + N::A{}); // { dg-error \"no match\" }\n+    (N::A{} + ... + xs); // { dg-error \"no match\" }\n+    (xs - ... - N::A{}); // { dg-error \"no match\" }\n+    (N::A{} - ... - xs); // { dg-error \"no match\" }\n+    (xs % ... % N::A{}); // { dg-error \"no match\" }\n+    (N::A{} % ... % xs); // { dg-error \"no match\" }\n+    (xs & ... & N::A{}); // { dg-error \"no match\" }\n+    (N::A{} & ... & xs); // { dg-error \"no match\" }\n+    (xs | ... | N::A{}); // { dg-error \"no match\" }\n+    (N::A{} | ... | xs); // { dg-error \"no match\" }\n+    (xs ^ ... ^ N::A{}); // { dg-error \"no match\" }\n+    (N::A{} ^ ... ^ xs); // { dg-error \"no match\" }\n+    (xs << ... << N::A{}); // { dg-error \"no match\" }\n+    (N::A{} << ... << xs); // { dg-error \"no match\" }\n+    (xs >> ... >> N::A{}); // { dg-error \"no match\" }\n+    (N::A{} >> ... >> xs); // { dg-error \"no match\" }\n+    (xs && ... && N::A{}); // { dg-error \"no match\" }\n+    (N::A{} && ... && xs); // { dg-error \"no match\" }\n+    (xs || ... || N::A{}); // { dg-error \"no match\" }\n+    (N::A{} || ... || xs); // { dg-error \"no match\" }\n+    (xs , ... , N::A{});\n+    (N::A{} , ... , xs);\n+\n+    (xs == ... == N::A{}); // { dg-error \"no match\" }\n+    (N::A{} == ... == xs); // { dg-error \"no match\" }\n+    (xs != ... != N::A{}); // { dg-error \"no match\" }\n+    (N::A{} != ... != xs); // { dg-error \"no match\" }\n+    (xs < ... < N::A{}); // { dg-error \"no match\" }\n+    (N::A{} < ... < xs); // { dg-error \"no match\" }\n+    (xs > ... > N::A{}); // { dg-error \"no match\" }\n+    (N::A{} > ... > xs); // { dg-error \"no match\" }\n+    (xs <= ... <= N::A{}); // { dg-error \"no match\" }\n+    (N::A{} <= ... <= xs); // { dg-error \"no match\" }\n+    (xs >= ... >= N::A{}); // { dg-error \"no match\" }\n+    (N::A{} >= ... >= xs); // { dg-error \"no match\" }\n+\n+    (xs += ... += N::A{}); // { dg-error \"no match\" }\n+    (N::A{} += ... += xs); // { dg-error \"no match\" }\n+    (xs -= ... -= N::A{}); // { dg-error \"no match\" }\n+    (N::A{} -= ... -= xs); // { dg-error \"no match\" }\n+    (xs *= ... *= N::A{}); // { dg-error \"no match\" }\n+    (N::A{} *= ... *= xs); // { dg-error \"no match\" }\n+    (xs /= ... /= N::A{}); // { dg-error \"no match\" }\n+    (N::A{} /= ... /= xs); // { dg-error \"no match\" }\n+    (xs %= ... %= N::A{}); // { dg-error \"no match\" }\n+    (N::A{} %= ... %= xs); // { dg-error \"no match\" }\n+    (xs |= ... |= N::A{}); // { dg-error \"no match\" }\n+    (N::A{} |= ... |= xs); // { dg-error \"no match\" }\n+    (xs ^= ... ^= N::A{}); // { dg-error \"no match\" }\n+    (N::A{} ^= ... ^= xs); // { dg-error \"no match\" }\n+    (xs <<= ... <<= N::A{}); // { dg-error \"no match\" }\n+    (N::A{} <<= ... <<= xs); // { dg-error \"no match\" }\n+    (xs >>= ... >>= N::A{}); // { dg-error \"no match\" }\n+    (N::A{} >>= ... >>= xs); // { dg-error \"no match\" }\n+  };\n+}\n+\n+#include \"operator-3-ops.h\"\n+\n+int main() {\n+  f()(N::A());\n+}"}, {"sha": "b59c137226ae67a85e7b0af3c9fe70f4b286a136", "filename": "gcc/testsuite/g++.dg/lookup/operator-6.C", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-6.C?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -0,0 +1,59 @@\n+// PR c++/83035\n+// { dg-do compile { target c++11 } }\n+// Like operator-3.C but where the lookup occurs at non-block scope.\n+\n+template<class T, class = void> struct S {\n+  static constexpr bool is_primary = true;\n+};\n+\n+template<class T> struct S<T, decltype(+T())> { };\n+template<class T> struct S<T, decltype(-T())> { };\n+template<class T> struct S<T, decltype(*T())> { };\n+template<class T> struct S<T, decltype(~T())> { };\n+template<class T> struct S<T, decltype(&T())> { };\n+template<class T> struct S<T, decltype(!T())> { };\n+template<class T> struct S<T, decltype(++T())> { };\n+template<class T> struct S<T, decltype(--T())> { };\n+template<class T> struct S<T, decltype(T()++)> { };\n+template<class T> struct S<T, decltype(T()--)> { };\n+\n+template<class T> struct S<T, decltype(T()->*T())> { };\n+template<class T> struct S<T, decltype(T() / T())> { };\n+template<class T> struct S<T, decltype(T() * T())> { };\n+template<class T> struct S<T, decltype(T() + T())> { };\n+template<class T> struct S<T, decltype(T() - T())> { };\n+template<class T> struct S<T, decltype(T() % T())> { };\n+template<class T> struct S<T, decltype(T() & T())> { };\n+template<class T> struct S<T, decltype(T() | T())> { };\n+template<class T> struct S<T, decltype(T() ^ T())> { };\n+template<class T> struct S<T, decltype(T() << T())> { };\n+template<class T> struct S<T, decltype(T() >> T())> { };\n+template<class T> struct S<T, decltype(T() && T())> { };\n+template<class T> struct S<T, decltype(T() || T())> { };\n+template<class T> struct S<T, decltype(T(), T())> { };\n+\n+template<class T> struct S<T, decltype(T() == T())> { };\n+template<class T> struct S<T, decltype(T() != T())> { };\n+template<class T> struct S<T, decltype(T() < T())> { };\n+template<class T> struct S<T, decltype(T() > T())> { };\n+template<class T> struct S<T, decltype(T() <= T())> { };\n+template<class T> struct S<T, decltype(T() >= T())> { };\n+#if __cplusplus > 201703L\n+template<class T> struct S<T, decltype(T() <=> T())> { };\n+#endif\n+\n+template<class T> struct S<T, decltype(T() += T())> { };\n+template<class T> struct S<T, decltype(T() -= T())> { };\n+template<class T> struct S<T, decltype(T() *= T())> { };\n+template<class T> struct S<T, decltype(T() /= T())> { };\n+template<class T> struct S<T, decltype(T() %= T())> { };\n+template<class T> struct S<T, decltype(T() |= T())> { };\n+template<class T> struct S<T, decltype(T() ^= T())> { };\n+template<class T> struct S<T, decltype(T() <<= T())> { };\n+template<class T> struct S<T, decltype(T() >>= T())> { };\n+\n+namespace N { struct A { }; }\n+\n+#include \"operator-3-ops.h\"\n+\n+static_assert(S<N::A>::is_primary, \"\");"}, {"sha": "546fcb0a52684c21923963043029826f3649a26f", "filename": "gcc/testsuite/g++.dg/lookup/operator-7.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-7.C?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -0,0 +1,27 @@\n+// PR c++/100465\n+\n+namespace N\n+{\n+  struct string\n+  {\n+    template<typename T>\n+    void operator+=(T);\n+  };\n+\n+  struct A {\n+    void operator+=(char); // #1\n+\n+    template<typename T>\n+    void f() {\n+      string s;\n+      s += T();\n+    }\n+\n+    void g() {\n+      f<char>();\n+    }\n+  };\n+} // namespace N\n+\n+template<typename T>\n+void operator+=(N::string, T);"}, {"sha": "64d8a97cdd005e81cda1a8754719adf01eb96871", "filename": "gcc/testsuite/g++.dg/lookup/operator-8.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-8.C?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -0,0 +1,34 @@\n+// Verify phase 1 lookup works properly for rewritten non-dependent conditional\n+// operator expressions.\n+\n+// This test currently fails due to build_min_non_dep_op_overload not knowing\n+// how to handle rewritten operator expressions; see the FIXME in build_new_op.\n+\n+// { dg-do compile { target c++20 } }\n+\n+#include <compare>\n+\n+struct A {\n+  bool operator==(int);\n+  std::strong_ordering operator<=>(int);\n+};\n+\n+template<class T>\n+void f() {\n+  A a;\n+  (void)(a != 0, 0 != a); // { dg-bogus \"deleted\" \"\" { xfail *-*-* } }\n+  (void)(a < 0, 0 < a);   // { dg-bogus \"deleted\" \"\" { xfail *-*-* } }\n+  (void)(a <= 0, 0 <= a); // { dg-bogus \"deleted\" \"\" { xfail *-*-* } }\n+  (void)(a > 0, 0 > a);   // { dg-bogus \"deleted\" \"\" { xfail *-*-* } }\n+  (void)(a >= 0, 0 >= a); // { dg-bogus \"deleted\" \"\" { xfail *-*-* } }\n+}\n+\n+// These later-declared namespace-scope overloads shouldn't be considered\n+// when instantiating f<int>.\n+bool operator!=(A, int) = delete;\n+bool operator<(A, int) = delete;\n+bool operator<=(A, int) = delete;\n+bool operator>(A, int) = delete;\n+bool operator>=(A, int) = delete;\n+\n+template void f<int>();"}, {"sha": "fccdce6ad47d2687286dc769a580f65d05fdbb18", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2a7f80a98de3febefbb32b1e4898062bdb6af8/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=bb2a7f80a98de3febefbb32b1e4898062bdb6af8", "patch": "@@ -2669,7 +2669,7 @@ plugin_build_unary_expr (cc1_plugin::connection *self,\n       break;\n \n     default:\n-      result = build_x_unary_op (/*loc=*/0, opcode, op0, tf_error);\n+      result = build_x_unary_op (/*loc=*/0, opcode, op0, NULL_TREE, tf_error);\n       break;\n     }\n \n@@ -2794,7 +2794,7 @@ plugin_build_binary_expr (cc1_plugin::connection *self,\n \n     default:\n       result = build_x_binary_op (/*loc=*/0, opcode, op0, ERROR_MARK,\n-\t\t\t\t  op1, ERROR_MARK, NULL, tf_error);\n+\t\t\t\t  op1, ERROR_MARK, NULL_TREE, NULL, tf_error);\n       break;\n     }\n "}]}