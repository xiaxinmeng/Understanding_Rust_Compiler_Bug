{"sha": "03d90a20a1afcbb9c30da8d4adf4922b0685061f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNkOTBhMjBhMWFmY2JiOWMzMGRhOGQ0YWRmNDkyMmIwNjg1MDYxZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-05-20T13:58:22Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-05-20T13:58:22Z"}, "message": "Avoid SCC hashing on unmergeable trees\n\nThis is new incarantion of patch to identify unmergeable tree at streaming out\ntime rather than streaming in and to avoid pickling them to sccs with with hash\ncodes.\n\nBuilding cc1 plus this patch reduces:\n\n[WPA] read 4452927 SCCs of average size 1.986030\n[WPA] 8843646 tree bodies read in total\n[WPA] tree SCC table: size 524287, 205158 elements, collision ratio: 0.505204\n[WPA] tree SCC max chain length 43 (size 1)\n[WPA] Compared 947551 SCCs, 780270 collisions (0.823460)\n[WPA] Merged 944038 SCCs\n[WPA] Merged 5253521 tree bodies\n[WPA] Merged 590027 types\n...\n[WPA] Size of mmap'd section decls: 99229066 bytes\n[WPA] Size of mmap'd section function_body: 18398837 bytes\n[WPA] Size of mmap'd section refs: 733678 bytes\n[WPA] Size of mmap'd section jmpfuncs: 2965981 bytes\n[WPA] Size of mmap'd section pureconst: 170248 bytes\n[WPA] Size of mmap'd section profile: 17985 bytes\n[WPA] Size of mmap'd section symbol_nodes: 3392736 bytes\n[WPA] Size of mmap'd section inline: 2693920 bytes\n[WPA] Size of mmap'd section icf: 435557 bytes\n[WPA] Size of mmap'd section offload_table: 0 bytes\n[WPA] Size of mmap'd section lto: 4320 bytes\n[WPA] Size of mmap'd section ipa_sra: 651660 bytes\n\n... to ...\n\n[WPA] read 3312246 unshared trees\n[WPA] read 1144381 mergeable SCCs of average size 4.833785\n[WPA] 8843938 tree bodies read in total\n[WPA] tree SCC table: size 524287, 197767 elements, collision ratio: 0.506446\n[WPA] tree SCC max chain length 43 (size 1)\n[WPA] Compared 946614 SCCs, 775077 collisions (0.818789)\n[WPA] Merged 943798 SCCs\n[WPA] Merged 5253336 tree bodies\n[WPA] Merged 590105 types\n....\n[WPA] Size of mmap'd section decls: 81262144 bytes\n[WPA] Size of mmap'd section function_body: 14702611 bytes\n[WPA] Size of mmap'd section ext_symtab: 0 bytes\n[WPA] Size of mmap'd section refs: 733695 bytes\n[WPA] Size of mmap'd section jmpfuncs: 2332150 bytes\n[WPA] Size of mmap'd section pureconst: 170292 bytes\n[WPA] Size of mmap'd section profile: 17986 bytes\n[WPA] Size of mmap'd section symbol_nodes: 3393358 bytes\n[WPA] Size of mmap'd section inline: 2567939 bytes\n[WPA] Size of mmap'd section icf: 435633 bytes\n[WPA] Size of mmap'd section lto: 4320 bytes\n[WPA] Size of mmap'd section ipa_sra: 651824 bytes\n\nso results in about 22% reduction in global decl stream and 24% reduction on\nfunction bodies stream (which is read mostly by ICF)\n\nMartin, the zstd compression breaks the compression statistics (it works when\nGCC is configured for zlib)\n\nAt first ltrans I get:\n\n[LTRANS] Size of mmap'd section decls: 3734248 bytes\n[LTRANS] Size of mmap'd section function_body: 4895962 bytes\n\n... to ...\n\n[LTRANS] Size of mmap'd section decls: 3479850 bytes\n[LTRANS] Size of mmap'd section function_body: 3722935 bytes\n\nSo 7% reduction of global stream and 31% reduction of function bodies.\n\nStream in seems to get about 3% faster and stream out about 5% but it is\nclose to noise factor of my experiment.  I expect bigger speedups on\nFirefox but I did not test it today since my Firefox setup broke again.\nGCC is not very good example on the problem with anonymous namespace\ntypes since we do not have so many of them.\n\nSice of object files in gcc directory is reduced by 11% (because hash\nnumbers do not compress well I guess).\n\nThe patch makes DFS walk to recognize trees that are not merged (anonymous\nnamespace, local function/variable decls, anonymous types etc).  As discussed\non IRC this is now done during the SCC walk rather than during the hash\ncomputation.  When local tree is discovered we know that SCC components of everything that is on\nthe stack reffers to it and thus is also local. Moreover we mark trees into hash set in output block\nso if we get a cross edge referring to local tree it gets marked too.\n\nPatch also takes care of avoiding SCC wrappers around some trees. In particular\n 1) singleton unmergeable SCCs are now streamed inline in global decl stream\n    This includes INTEGER_CSTs and IDENTIFIER_NODEs that are shared by different\n    code than rest of tree merging.\n 2) We use LTO_trees instead of LTO_tree_scc to wrap unmergeable SCC components.\n    It is still necessary to mark them because of forward references.  LTO_trees\n    has simple header with number of trees and then things are streamed same way\n    as for LTO_tree_scc. That is tree headers first followed by pickled references\n    so things may point to future.\n\n    Of course it is not necessary for LTO_tree_scc to be single component and\n    streamer out may group more components together, but I decided to not snowball\n    the patch even more\n 3) In local streams when lto_output_tree is called and the topmost SCC components\n    turns out to be singleton we stream the tree directly\n    instead of LTO_tree_scc, hash code, pickled tree, reference to just stremaed tree.\n\n    LTO_trees is used to wrap all trees needed to represent tree being streamed.\n    It would make sense again to use only one LTO_trees rather than one per SCC\n    but I think this can be done incrementally.\n\nIn general local trees are now recognized by new predicate local_tree_p\n\nBit subtle is handing of TRANLSATION_UNIT_DECL, INTEGER_CST and\nIDENTIFIER_NODE.\n\nTRANSLATION_UNIT_DECL a local tree but references to it does not make\nother trees local (because we also understand local decls now).\nSo I check for it later after localness propagation is done.\n\nINTEGER_CST and IDENTIFIER_NODEs are merged but not via the tree merging\nmachinery. So it makes sense to stream them as unmergeable trees but we\nstill need to compute their hashes so SCCs referring them do not get too\nlarge collision chains.  For this reason they are checked just prior\nstream out.\n\nlto-bootstrapped/regteted x86_64-linux, OK?\n\ngcc/ChangeLog:\n\n2020-05-19  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* lto-streamer-in.c (lto_input_scc): Add SHARED_SCC parameter.\n\t(lto_input_tree_1): Strenghten sanity check.\n\t(lto_input_tree): Update call of lto_input_scc.\n\t* lto-streamer-out.c: Include ipa-utils.h\n\t(create_output_block): Initialize local_trees if merigng is going\n\tto happen.\n\t(destroy_output_block): Destroy local_trees.\n\t(DFS): Add max_local_entry.\n\t(local_tree_p): New function.\n\t(DFS::DFS): Initialize and maintain it.\n\t(DFS::DFS_write_tree): Decide on streaming format.\n\t(lto_output_tree): Stream inline singleton SCCs\n\t* lto-streamer.h (enum LTO_tags): Add LTO_trees.\n\t(struct output_block): Add local_trees.\n\t(lto_input_scc): Update prototype.\n\ngcc/lto/ChangeLog:\n\n2020-05-19  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* lto-common.c (compare_tree_sccs_1): Sanity check that we never\n\tread TRANSLATION_UNIT_DECL.\n\t(process_dref): Break out from ...\n\t(unify_scc): ... here.\n\t(process_new_tree): Break out from ...\n\t(lto_read_decls): ... here; handle streaming of singleton trees.\n\t(print_lto_report_1): Update statistics.", "tree": {"sha": "400ebde593b20c6f604b5c44870275c92e159eef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/400ebde593b20c6f604b5c44870275c92e159eef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03d90a20a1afcbb9c30da8d4adf4922b0685061f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d90a20a1afcbb9c30da8d4adf4922b0685061f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03d90a20a1afcbb9c30da8d4adf4922b0685061f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d90a20a1afcbb9c30da8d4adf4922b0685061f/comments", "author": null, "committer": null, "parents": [{"sha": "eb069ae8819c3a84d7f78becc5501e21ee3a9554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb069ae8819c3a84d7f78becc5501e21ee3a9554", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb069ae8819c3a84d7f78becc5501e21ee3a9554"}], "stats": {"total": 450, "additions": 325, "deletions": 125}, "files": [{"sha": "5dd558ae8a3a0b514203987f339a931a53726ca0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d90a20a1afcbb9c30da8d4adf4922b0685061f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d90a20a1afcbb9c30da8d4adf4922b0685061f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03d90a20a1afcbb9c30da8d4adf4922b0685061f", "patch": "@@ -1,3 +1,21 @@\n+2020-05-20  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-streamer-in.c (lto_input_scc): Add SHARED_SCC parameter.\n+\t(lto_input_tree_1): Strenghten sanity check.\n+\t(lto_input_tree): Update call of lto_input_scc.\n+\t* lto-streamer-out.c: Include ipa-utils.h\n+\t(create_output_block): Initialize local_trees if merigng is going\n+\tto happen.\n+\t(destroy_output_block): Destroy local_trees.\n+\t(DFS): Add max_local_entry.\n+\t(local_tree_p): New function.\n+\t(DFS::DFS): Initialize and maintain it.\n+\t(DFS::DFS_write_tree): Decide on streaming format.\n+\t(lto_output_tree): Stream inline singleton SCCs\n+\t* lto-streamer.h (enum LTO_tags): Add LTO_trees.\n+\t(struct output_block): Add local_trees.\n+\t(lto_input_scc): Update prototype.\n+\n 2020-05-20  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/95223"}, {"sha": "85d0edf49a707f33db73027764145af0707c4abe", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d90a20a1afcbb9c30da8d4adf4922b0685061f/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d90a20a1afcbb9c30da8d4adf4922b0685061f/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=03d90a20a1afcbb9c30da8d4adf4922b0685061f", "patch": "@@ -1424,16 +1424,17 @@ lto_read_tree (class lto_input_block *ib, class data_in *data_in,\n \n \n /* Populate the reader cache with trees materialized from the SCC\n-   following in the IB, DATA_IN stream.  */\n+   following in the IB, DATA_IN stream.\n+   If SHARED_SCC is true we input LTO_tree_scc.  */\n \n hashval_t\n lto_input_scc (class lto_input_block *ib, class data_in *data_in,\n-\t       unsigned *len, unsigned *entry_len)\n+\t       unsigned *len, unsigned *entry_len, bool shared_scc)\n {\n   /* A blob of unnamed tree nodes, fill the cache from it and\n      recurse.  */\n   unsigned size = streamer_read_uhwi (ib);\n-  hashval_t scc_hash = streamer_read_uhwi (ib);\n+  hashval_t scc_hash = shared_scc ? streamer_read_uhwi (ib) : 0;\n   unsigned scc_entry_len = 1;\n \n   if (size == 1)\n@@ -1456,7 +1457,8 @@ lto_input_scc (class lto_input_block *ib, class data_in *data_in,\n \t      || (tag >= LTO_field_decl_ref && tag <= LTO_global_decl_ref)\n \t      || tag == LTO_tree_pickle_reference\n \t      || tag == LTO_integer_cst\n-\t      || tag == LTO_tree_scc)\n+\t      || tag == LTO_tree_scc\n+\t      || tag == LTO_trees)\n \t    gcc_unreachable ();\n \n \t  result = streamer_alloc_tree (ib, data_in, tag);\n@@ -1522,7 +1524,7 @@ lto_input_tree_1 (class lto_input_block *ib, class data_in *data_in,\n \t\t\t\t (a, len, TYPE_PRECISION (type)));\n       streamer_tree_cache_append (data_in->reader_cache, result, hash);\n     }\n-  else if (tag == LTO_tree_scc)\n+  else if (tag == LTO_tree_scc || tag == LTO_trees)\n     gcc_unreachable ();\n   else\n     {\n@@ -1538,11 +1540,11 @@ lto_input_tree (class lto_input_block *ib, class data_in *data_in)\n {\n   enum LTO_tags tag;\n \n-  /* Input and skip SCCs.  */\n-  while ((tag = streamer_read_record_start (ib)) == LTO_tree_scc)\n+  /* Input pickled trees needed to stream in the reference.  */\n+  while ((tag = streamer_read_record_start (ib)) == LTO_trees)\n     {\n       unsigned len, entry_len;\n-      lto_input_scc (ib, data_in, &len, &entry_len);\n+      lto_input_scc (ib, data_in, &len, &entry_len, false);\n \n       /* Register DECLs with the debuginfo machinery.  */\n       while (!dref_queue.is_empty ())\n@@ -1551,7 +1553,15 @@ lto_input_tree (class lto_input_block *ib, class data_in *data_in)\n \t  debug_hooks->register_external_die (e.decl, e.sym, e.off);\n \t}\n     }\n-  return lto_input_tree_1 (ib, data_in, tag, 0);\n+  tree t = lto_input_tree_1 (ib, data_in, tag, 0);\n+\n+  if (!dref_queue.is_empty ())\n+    {\n+      dref_entry e = dref_queue.pop ();\n+      debug_hooks->register_external_die (e.decl, e.sym, e.off);\n+      gcc_checking_assert (dref_queue.is_empty ());\n+    }\n+  return t;\n }\n \n "}, {"sha": "0e1794680434c44d3c77eb0666a0352c4b2d72d7", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 127, "deletions": 19, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d90a20a1afcbb9c30da8d4adf4922b0685061f/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d90a20a1afcbb9c30da8d4adf4922b0685061f/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=03d90a20a1afcbb9c30da8d4adf4922b0685061f", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"file-prefix-map.h\" /* remap_debug_filename()  */\n #include \"output.h\"\n+#include \"ipa-utils.h\"\n \n \n static void lto_write_tree (struct output_block*, tree, bool);\n@@ -75,6 +76,10 @@ create_output_block (enum lto_section_type section_type)\n \n   ob->section_type = section_type;\n   ob->decl_state = lto_get_out_decl_state ();\n+  /* Only global decl stream in non-wpa will ever be considered by tree\n+     merging.  */\n+  if (!flag_wpa && section_type == LTO_section_decls)\n+    ob->local_trees = new (hash_set <tree>);\n   ob->main_stream = XCNEW (struct lto_output_stream);\n   ob->string_stream = XCNEW (struct lto_output_stream);\n   ob->writer_cache = streamer_tree_cache_create (!flag_wpa, true, false);\n@@ -100,6 +105,7 @@ destroy_output_block (struct output_block *ob)\n \n   delete ob->string_hash_table;\n   ob->string_hash_table = NULL;\n+  delete ob->local_trees;\n \n   free (ob->main_stream);\n   free (ob->string_stream);\n@@ -532,6 +538,8 @@ class DFS\n     bool ref_p;\n     bool this_ref_p;\n   };\n+  /* Maximum index of scc stack containing a local tree.  */\n+  int max_local_entry;\n \n   static int scc_entry_compare (const void *, const void *);\n \n@@ -550,6 +558,41 @@ class DFS\n   struct obstack sccstate_obstack;\n };\n \n+/* Return true if type can not be merged with structurally same tree in\n+   other translation unit.  During stream out this information is propagated\n+   to all trees referring to T and they are not streamed with additional\n+   information needed by the tree merging in lto-common.c (in particular,\n+   scc hash codes are not streamed).\n+\n+   TRANSLATION_UNIT_DECL is handled specially since references to it does\n+   not make other trees local as well.  */\n+\n+static bool\n+local_tree_p (tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case LABEL_DECL:\n+      return true;\n+    case NAMESPACE_DECL:\n+      return !DECL_NAME (t);\n+    case VAR_DECL:\n+    case FUNCTION_DECL:\n+      return !TREE_PUBLIC (t) && !DECL_EXTERNAL (t);\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      /* Anonymous namespace types are local.\n+\t Only work hard for main variants;\n+\t variant types will inherit locality.  */\n+      return TYPE_MAIN_VARIANT (t) == t\n+\t     && odr_type_p (t) && type_with_linkage_p (t)\n+\t     && type_in_anonymous_namespace_p (t);\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Emit the physical representation of tree node EXPR to output block OB,\n    using depth-first search on the subgraph.  If THIS_REF_P is true, the\n    leaves of EXPR are emitted as references via lto_output_tree_ref.\n@@ -560,6 +603,8 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \t  bool single_p)\n {\n   unsigned int next_dfs_num = 1;\n+\n+  max_local_entry = -1;\n   gcc_obstack_init (&sccstate_obstack);\n   DFS_write_tree (ob, NULL, expr, ref_p, this_ref_p);\n   while (!worklist_vec.is_empty ())\n@@ -586,6 +631,8 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \t  scc_entry e = { expr, 0 };\n \t  /* Not yet visited.  DFS recurse and push it onto the stack.  */\n \t  *slot = cstate = XOBNEW (&sccstate_obstack, struct sccs);\n+\t  if (ob->local_trees && local_tree_p (expr))\n+\t    max_local_entry = sccstack.length ();\n \t  sccstack.safe_push (e);\n \t  cstate->dfsnum = next_dfs_num++;\n \t  cstate->low = cstate->dfsnum;\n@@ -640,7 +687,26 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \t     any merging there.  */\n \t  hashval_t scc_hash = 0;\n \t  unsigned scc_entry_len = 0;\n-\t  if (!flag_wpa)\n+\t  bool local_to_unit = !ob->local_trees\n+\t\t\t       || max_local_entry >= (int)first;\n+\n+\t  /* Remember that trees are local so info gets propagated to other\n+\t     SCCs.  */\n+\t  if (local_to_unit && ob->local_trees)\n+\t    {\n+\t      for (unsigned i = 0; i < size; ++i)\n+\t\tob->local_trees->add (sccstack[first + i].t);\n+\t    }\n+\n+\t  /* As a special case do not stream TRANSLATION_UNIT_DECL as shared\n+\t     tree.  We can not mark it local because references to it does not\n+\t     make other trees local (all global decls reffer to it via\n+\t     CONTEXT).  */\n+\t  if (size == 1\n+\t      && TREE_CODE (sccstack[first].t) == TRANSLATION_UNIT_DECL)\n+\t    local_to_unit = true;\n+\n+\t  if (!local_to_unit)\n \t    {\n \t      scc_hash = hash_scc (ob, first, size, ref_p, this_ref_p);\n \n@@ -672,18 +738,47 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \t      gcc_checking_assert (scc_entry_len == 1);\n \t    }\n \n-\t  /* Write LTO_tree_scc.  */\n-\t  streamer_write_record_start (ob, LTO_tree_scc);\n-\t  streamer_write_uhwi (ob, size);\n-\t  streamer_write_uhwi (ob, scc_hash);\n+\t  worklist_vec.pop ();\n+\n+\t  /* Only global decl sections are considered by tree merging.  */\n+\t  if (ob->section_type != LTO_section_decls)\n+\t    {\n+\t      /* If this is the original tree we stream and it forms SCC\n+\t\t by itself then we do not need to stream SCC at all.  */\n+\t      if (worklist_vec.is_empty () && first == 0 && size == 1)\n+\t\t return;\n+\t      streamer_write_record_start (ob, LTO_trees);\n+\t      streamer_write_uhwi (ob, size);\n+\t    }\n+\t  /* Write LTO_tree_scc if tree merging is going to be performed.  */\n+\t  else if (!local_to_unit\n+\t\t   /* These are special since sharing is not done by tree\n+\t\t      merging machinery.  We can not special case them earlier\n+\t\t      because we still need to compute hash for further sharing\n+\t\t      of trees referring to them.  */\n+\t\t   && (size != 1\n+\t\t       || (TREE_CODE (sccstack[first].t) != IDENTIFIER_NODE\n+\t\t\t   && (TREE_CODE (sccstack[first].t) != INTEGER_CST\n+\t\t\t       || TREE_OVERFLOW (sccstack[first].t)))))\n+\n+\t    {\n+\t      gcc_checking_assert (ob->section_type == LTO_section_decls);\n+\t      streamer_write_record_start (ob, LTO_tree_scc);\n+\t      streamer_write_uhwi (ob, size);\n+\t      streamer_write_uhwi (ob, scc_hash);\n+\t    }\n+\t  /* Non-trivial SCCs must be packed to trees blocks so forward\n+\t     references work correctly.  */\n+\t  else if (size != 1)\n+\t    {\n+\t       streamer_write_record_start (ob, LTO_trees);\n+\t       streamer_write_uhwi (ob, size);\n+\t    }\n \n \t  /* Write size-1 SCCs without wrapping them inside SCC bundles.\n \t     All INTEGER_CSTs need to be handled this way as we need\n \t     their type to materialize them.  Also builtins are handled\n-\t     this way.\n-\t     ???  We still wrap these in LTO_tree_scc so at the\n-\t     input side we can properly identify the tree we want\n-\t     to ultimatively return.  */\n+\t     this way.  */\n \t  if (size == 1)\n \t    lto_output_tree_1 (ob, expr, scc_hash, ref_p, this_ref_p);\n \t  else\n@@ -722,10 +817,11 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \n \t  /* Finally truncate the vector.  */\n \t  sccstack.truncate (first);\n+\t  if ((int)first <= max_local_entry)\n+\t    max_local_entry = first - 1;\n \n \t  if (from_state)\n \t    from_state->low = MIN (from_state->low, cstate->low);\n-\t  worklist_vec.pop ();\n \t  continue;\n \t}\n \n@@ -1569,7 +1665,14 @@ DFS::DFS_write_tree (struct output_block *ob, sccs *from_state,\n \n   /* Check if we already streamed EXPR.  */\n   if (streamer_tree_cache_lookup (ob->writer_cache, expr, NULL))\n-    return;\n+    {\n+      /* Refernece to a local tree makes entry also local.  We always process\n+\t top of stack entry, so set max to number of entries in stack - 1.  */\n+      if (ob->local_trees\n+\t  && ob->local_trees->contains (expr))\n+\tmax_local_entry = sccstack.length () - 1;\n+      return;\n+    }\n \n   worklist w;\n   w.expr = expr;\n@@ -1641,15 +1744,20 @@ lto_output_tree (struct output_block *ob, tree expr,\n       DFS (ob, expr, ref_p, this_ref_p, false);\n       in_dfs_walk = false;\n \n-      /* Finally append a reference to the tree we were writing.\n-\t ???  If expr ended up as a singleton we could have\n-\t inlined it here and avoid outputting a reference.  */\n+      /* Finally append a reference to the tree we were writing.  */\n       existed_p = streamer_tree_cache_lookup (ob->writer_cache, expr, &ix);\n-      gcc_assert (existed_p);\n-      streamer_write_record_start (ob, LTO_tree_pickle_reference);\n-      streamer_write_uhwi (ob, ix);\n-      streamer_write_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS,\n-\t\t\t   lto_tree_code_to_tag (TREE_CODE (expr)));\n+\n+      /* DFS walk above possibly skipped streaming EXPR itself to let us inline\n+\t it.  */\n+      if (!existed_p)\n+\tlto_output_tree_1 (ob, expr, 0, ref_p, this_ref_p);\n+      else\n+\t{\n+\t  streamer_write_record_start (ob, LTO_tree_pickle_reference);\n+\t  streamer_write_uhwi (ob, ix);\n+\t  streamer_write_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS,\n+\t\t\t       lto_tree_code_to_tag (TREE_CODE (expr)));\n+\t}\n       if (streamer_dump_file)\n \t{\n \t  print_node_brief (streamer_dump_file, \"   Finished SCC of \","}, {"sha": "a466fb8b329e94c08f8e8e2a50b5b2490b153b76", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d90a20a1afcbb9c30da8d4adf4922b0685061f/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d90a20a1afcbb9c30da8d4adf4922b0685061f/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=03d90a20a1afcbb9c30da8d4adf4922b0685061f", "patch": "@@ -178,6 +178,9 @@ enum LTO_tags\n   /* Special for global streamer.  A blob of unnamed tree nodes.  */\n   LTO_tree_scc,\n \n+  /* Sequence of trees.  */\n+  LTO_trees,\n+\n   /* References to indexable tree nodes.  These objects are stored in\n      tables that are written separately from the function bodies that\n      reference them.  This way they can be instantiated even when the\n@@ -751,6 +754,9 @@ struct output_block\n   /* Cache of nodes written in this section.  */\n   struct streamer_tree_cache_d *writer_cache;\n \n+  /* All trees identified as local to the unit streamed.  */\n+  hash_set<tree> *local_trees;\n+\n   /* All data persistent across whole duration of output block\n      can go here.  */\n   struct obstack obstack;\n@@ -901,7 +907,7 @@ tree lto_input_tree_ref (class lto_input_block *, class data_in *,\n void lto_tag_check_set (enum LTO_tags, int, ...);\n void lto_init_eh (void);\n hashval_t lto_input_scc (class lto_input_block *, class data_in *,\n-\t\t\t unsigned *, unsigned *);\n+\t\t\t unsigned *, unsigned *, bool);\n tree lto_input_tree_1 (class lto_input_block *, class data_in *,\n \t\t       enum LTO_tags, hashval_t hash);\n tree lto_input_tree (class lto_input_block *, class data_in *);"}, {"sha": "aedcba9d83a9b1eef395a14cb0e3698346cccf00", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d90a20a1afcbb9c30da8d4adf4922b0685061f/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d90a20a1afcbb9c30da8d4adf4922b0685061f/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=03d90a20a1afcbb9c30da8d4adf4922b0685061f", "patch": "@@ -1,3 +1,13 @@\n+2020-05-20  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-common.c (compare_tree_sccs_1): Sanity check that we never\n+\tread TRANSLATION_UNIT_DECL.\n+\t(process_dref): Break out from ...\n+\t(unify_scc): ... here.\n+\t(process_new_tree): Break out from ...\n+\t(lto_read_decls): ... here; handle streaming of singleton trees.\n+\t(print_lto_report_1): Update statistics.\n+\n 2020-05-07  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/94703"}, {"sha": "d04b1c9ca7be54e54c16285012c09d60e509eac0", "filename": "gcc/lto/lto-common.c", "status": "modified", "additions": 144, "deletions": 96, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d90a20a1afcbb9c30da8d4adf4922b0685061f/gcc%2Flto%2Flto-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d90a20a1afcbb9c30da8d4adf4922b0685061f/gcc%2Flto%2Flto-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-common.c?ref=03d90a20a1afcbb9c30da8d4adf4922b0685061f", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"lto-common.h\"\n #include \"tree-pretty-print.h\"\n+#include \"print-tree.h\"\n \n /* True when no new types are going to be streamd from the global stream.  */\n \n@@ -1054,6 +1055,7 @@ static unsigned long num_prevailing_types;\n static unsigned long num_type_scc_trees;\n static unsigned long total_scc_size;\n static unsigned long num_sccs_read;\n+static unsigned long num_unshared_trees_read;\n static unsigned long total_scc_size_merged;\n static unsigned long num_sccs_merged;\n static unsigned long num_scc_compares;\n@@ -1088,6 +1090,10 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n   compare_values (TREE_CODE);\n   code = TREE_CODE (t1);\n \n+  /* If we end up comparing translation unit decls we either forgot to mark\n+     some SCC as local or we compare too much.  */\n+  gcc_checking_assert (code != TRANSLATION_UNIT_DECL);\n+\n   if (!TYPE_P (t1))\n     {\n       compare_values (TREE_SIDE_EFFECTS);\n@@ -1626,6 +1632,28 @@ cmp_tree (const void *p1_, const void *p2_)\n   return ((uintptr_t)p1[1] < (uintptr_t)p2[1]) ? -1 : 1;\n }\n \n+/* New scc of size 1 containing T was streamed in from DATA_IN and not merged.\n+   Register it to reader cache at index FROM.  */\n+\n+static void\n+process_dref (class data_in *data_in, tree t, unsigned from)\n+{\n+  struct streamer_tree_cache_d *cache = data_in->reader_cache;\n+  /* If we got a debug reference queued, see if the prevailing\n+     tree has a debug reference and if not, register the one\n+     for the tree we are about to throw away.  */\n+  if (dref_queue.length () == 1)\n+    {\n+      dref_entry e = dref_queue.pop ();\n+      gcc_assert (e.decl\n+\t\t  == streamer_tree_cache_get_tree (cache, from));\n+      const char *sym;\n+      unsigned HOST_WIDE_INT off;\n+      if (!debug_hooks->die_ref_for_decl (t, &sym, &off))\n+\tdebug_hooks->register_external_die (t, e.sym, e.off);\n+    }\n+}\n+\n /* Try to unify the SCC with nodes FROM to FROM + LEN in CACHE and\n    hash value SCC_HASH with an already recorded SCC.  Return true if\n    that was successful, otherwise return false.  */\n@@ -1646,22 +1674,16 @@ unify_scc (class data_in *data_in, unsigned from,\n     {\n       tree t = streamer_tree_cache_get_tree (cache, from + i);\n       scc->entries[i] = t;\n-      /* Do not merge SCCs with local entities inside them.  Also do\n-\t not merge TRANSLATION_UNIT_DECLs and anonymous namespaces\n-\t and types therein types.  */\n-      if (TREE_CODE (t) == TRANSLATION_UNIT_DECL\n-\t  || (VAR_OR_FUNCTION_DECL_P (t)\n-\t      && !(TREE_PUBLIC (t) || DECL_EXTERNAL (t)))\n-\t  || TREE_CODE (t) == LABEL_DECL\n-\t  || (TREE_CODE (t) == NAMESPACE_DECL && !DECL_NAME (t))\n-\t  || (TYPE_P (t)\n-\t      && type_with_linkage_p (TYPE_MAIN_VARIANT (t))\n-\t      && type_in_anonymous_namespace_p (TYPE_MAIN_VARIANT (t))))\n-\t{\n-\t  /* Avoid doing any work for these cases and do not worry to\n-\t     record the SCCs for further merging.  */\n-\t  return false;\n-\t}\n+      /* These types should be streamed as unshared.  */\n+      gcc_checking_assert\n+\t (!(TREE_CODE (t) == TRANSLATION_UNIT_DECL\n+\t    || (VAR_OR_FUNCTION_DECL_P (t)\n+\t\t&& !(TREE_PUBLIC (t) || DECL_EXTERNAL (t)))\n+\t    || TREE_CODE (t) == LABEL_DECL\n+\t    || (TREE_CODE (t) == NAMESPACE_DECL && !DECL_NAME (t))\n+\t    || (TYPE_P (t)\n+\t\t&& type_with_linkage_p (TYPE_MAIN_VARIANT (t))\n+\t\t&& type_in_anonymous_namespace_p (TYPE_MAIN_VARIANT (t)))));\n     }\n \n   /* Look for the list of candidate SCCs to compare against.  */\n@@ -1712,21 +1734,7 @@ unify_scc (class data_in *data_in, unsigned from,\n \t     to the tree node mapping computed by compare_tree_sccs.  */\n \t  if (len == 1)\n \t    {\n-\t      /* If we got a debug reference queued, see if the prevailing\n-\t\t tree has a debug reference and if not, register the one\n-\t\t for the tree we are about to throw away.  */\n-\t      if (dref_queue.length () == 1)\n-\t\t{\n-\t\t  dref_entry e = dref_queue.pop ();\n-\t\t  gcc_assert (e.decl\n-\t\t\t      == streamer_tree_cache_get_tree (cache, from));\n-\t\t  const char *sym;\n-\t\t  unsigned HOST_WIDE_INT off;\n-\t\t  if (!debug_hooks->die_ref_for_decl (pscc->entries[0], &sym,\n-\t\t\t\t\t\t      &off))\n-\t\t    debug_hooks->register_external_die (pscc->entries[0],\n-\t\t\t\t\t\t\te.sym, e.off);\n-\t\t}\n+\t      process_dref (data_in, pscc->entries[0], from);\n \t      lto_maybe_register_decl (data_in, pscc->entries[0], from);\n \t      streamer_tree_cache_replace_tree (cache, pscc->entries[0], from);\n \t    }\n@@ -1785,7 +1793,65 @@ unify_scc (class data_in *data_in, unsigned from,\n   return unified_p;\n }\n \n+typedef int_hash<unsigned, 0, UINT_MAX> code_id_hash;\n+\n+/* Do registering necessary once new tree fully streamed in (including all\n+   trees it reffers to).  */\n+\n+static void\n+process_new_tree (tree t, hash_map <code_id_hash, unsigned> *hm,\n+\t\t  unsigned index, unsigned *total, class data_in *data_in)\n+{\n+  /* Reconstruct the type variant and pointer-to/reference-to\n+     chains.  */\n+  if (TYPE_P (t))\n+    {\n+      /* Map the tree types to their frequencies.  */\n+      if (flag_lto_dump_type_stats)\n+\t{\n+\t  unsigned key = (unsigned) TREE_CODE (t);\n+\t  unsigned *countp = hm->get (key);\n+\t  hm->put (key, countp ? (*countp) + 1 : 1);\n+\t  (*total)++;\n+\t}\n+\n+      num_prevailing_types++;\n+      lto_fixup_prevailing_type (t);\n \n+      /* Compute the canonical type of all non-ODR types.\n+\t Delay ODR types for the end of merging process - the canonical\n+\t type for those can be computed using the (unique) name however\n+\t we want to do this only if units in other languages do not\n+\t contain structurally equivalent type.\n+\n+\t Because SCC components are streamed in random (hash) order\n+\t we may have encountered the type before while registering\n+\t type canonical of a derived type in the same SCC.  */\n+      if (!TYPE_CANONICAL (t))\n+\t{\n+\t  if (!RECORD_OR_UNION_TYPE_P (t)\n+\t      || !TYPE_CXX_ODR_P (t))\n+\t    gimple_register_canonical_type (t);\n+\t  else if (COMPLETE_TYPE_P (t))\n+\t    vec_safe_push (types_to_register, t);\n+\t}\n+      if (TYPE_MAIN_VARIANT (t) == t && odr_type_p (t))\n+\tregister_odr_type (t);\n+    }\n+  /* Link shared INTEGER_CSTs into TYPE_CACHED_VALUEs of its\n+     type which is also member of this SCC.  */\n+  if (TREE_CODE (t) == INTEGER_CST\n+      && !TREE_OVERFLOW (t))\n+    cache_integer_cst (t);\n+  if (!flag_ltrans)\n+    {\n+      lto_maybe_register_decl (data_in, t, index);\n+      /* Scan the tree for references to global functions or\n+\t variables and record those for later fixup.  */\n+      if (mentions_vars_p (t))\n+\tvec_safe_push (tree_with_vars, t);\n+    }\n+}\n \n /* Read all the symbols from buffer DATA, using descriptors in DECL_DATA.\n    RESOLUTIONS is the set of symbols picked by the linker (read from the\n@@ -1813,7 +1879,6 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n   /* We do not uniquify the pre-loaded cache entries, those are middle-end\n      internal types that should not be merged.  */\n \n-  typedef int_hash<unsigned, 0, UINT_MAX> code_id_hash;\n   hash_map <code_id_hash, unsigned> hm;\n   unsigned total = 0;\n \n@@ -1824,31 +1889,41 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n       unsigned from = data_in->reader_cache->nodes.length ();\n       /* Read and uniquify SCCs as in the input stream.  */\n       enum LTO_tags tag = streamer_read_record_start (&ib_main);\n-      if (tag == LTO_tree_scc)\n+      if (tag == LTO_tree_scc || tag == LTO_trees)\n \t{\n \t  unsigned len_;\n \t  unsigned scc_entry_len;\n+\n+\t  /* Because we stream in SCC order we know that all unshared trees\n+\t     are now fully streamed.  Process them.  */\n \t  hashval_t scc_hash = lto_input_scc (&ib_main, data_in, &len_,\n-\t\t\t\t\t      &scc_entry_len);\n+\t\t\t\t\t      &scc_entry_len,\n+\t\t\t\t\t      tag == LTO_tree_scc);\n \t  unsigned len = data_in->reader_cache->nodes.length () - from;\n \t  gcc_assert (len == len_);\n \n-\t  total_scc_size += len;\n-\t  num_sccs_read++;\n+\t  if (tag == LTO_tree_scc)\n+\t    {\n+\t      total_scc_size += len;\n+\t      num_sccs_read++;\n+\t    }\n+\t  else\n+\t    num_unshared_trees_read += len;\n \n \t  /* We have the special case of size-1 SCCs that are pre-merged\n \t     by means of identifier and string sharing for example.\n \t     ???  Maybe we should avoid streaming those as SCCs.  */\n \t  tree first = streamer_tree_cache_get_tree (data_in->reader_cache,\n \t\t\t\t\t\t     from);\n-\t  if (len == 1\n-\t      && (TREE_CODE (first) == IDENTIFIER_NODE\n-\t\t  || (TREE_CODE (first) == INTEGER_CST\n-\t\t      && !TREE_OVERFLOW (first))))\n-\t    continue;\n+\t  /* Identifier and integers are shared specially, they should never\n+\t     go by the tree merging path.  */\n+\t  gcc_checking_assert ((TREE_CODE (first) != IDENTIFIER_NODE\n+\t\t\t\t&& (TREE_CODE (first) != INTEGER_CST\n+\t\t\t\t    || TREE_OVERFLOW (first)))\n+\t\t\t       || len != 1);\n \n \t  /* Try to unify the SCC with already existing ones.  */\n-\t  if (!flag_ltrans\n+\t  if (!flag_ltrans && tag != LTO_trees\n \t      && unify_scc (data_in, from,\n \t\t\t    len, scc_entry_len, scc_hash))\n \t    continue;\n@@ -1862,56 +1937,9 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t    {\n \t      tree t = streamer_tree_cache_get_tree (data_in->reader_cache,\n \t\t\t\t\t\t     from + i);\n-\t      /* Reconstruct the type variant and pointer-to/reference-to\n-\t\t chains.  */\n+\t      process_new_tree (t, &hm, from + i, &total, data_in);\n \t      if (TYPE_P (t))\n-\t\t{\n-\t\t  /* Map the tree types to their frequencies.  */\n-\t\t  if (flag_lto_dump_type_stats)\n-\t\t    {\n-\t\t      unsigned key = (unsigned) TREE_CODE (t);\n-\t\t      unsigned *countp = hm.get (key);\n-\t\t      hm.put (key, countp ? (*countp) + 1 : 1);\n-\t\t      total++;\n-\t\t    }\n-\n-\t\t  seen_type = true;\n-\t\t  num_prevailing_types++;\n-\t\t  lto_fixup_prevailing_type (t);\n-\n-\t\t  /* Compute the canonical type of all non-ODR types.\n-\t\t     Delay ODR types for the end of merging process - the canonical\n-\t\t     type for those can be computed using the (unique) name however\n-\t\t     we want to do this only if units in other languages do not\n-\t\t     contain structurally equivalent type.\n-\n-\t\t     Because SCC components are streamed in random (hash) order\n-\t\t     we may have encountered the type before while registering\n-\t\t     type canonical of a derived type in the same SCC.  */\n-\t\t  if (!TYPE_CANONICAL (t))\n-\t\t    {\n-\t\t      if (!RECORD_OR_UNION_TYPE_P (t)\n-\t\t\t  || !TYPE_CXX_ODR_P (t))\n-\t\t        gimple_register_canonical_type (t);\n-\t\t      else if (COMPLETE_TYPE_P (t))\n-\t\t\tvec_safe_push (types_to_register, t);\n-\t\t    }\n-\t\t  if (TYPE_MAIN_VARIANT (t) == t && odr_type_p (t))\n-\t\t    register_odr_type (t);\n-\t\t}\n-\t      /* Link shared INTEGER_CSTs into TYPE_CACHED_VALUEs of its\n-\t\t type which is also member of this SCC.  */\n-\t      if (TREE_CODE (t) == INTEGER_CST\n-\t\t  && !TREE_OVERFLOW (t))\n-\t\tcache_integer_cst (t);\n-\t      if (!flag_ltrans)\n-\t\t{\n-\t\t  lto_maybe_register_decl (data_in, t, from + i);\n-\t\t  /* Scan the tree for references to global functions or\n-\t\t     variables and record those for later fixup.  */\n-\t\t  if (mentions_vars_p (t))\n-\t\t    vec_safe_push (tree_with_vars, t);\n-\t\t}\n+\t\tseen_type = true;\n \t    }\n \n \t  /* Register DECLs with the debuginfo machinery.  */\n@@ -1926,9 +1954,26 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t}\n       else\n \t{\n-\t  /* Pickle stray references.  */\n \t  t = lto_input_tree_1 (&ib_main, data_in, tag, 0);\n-\t  gcc_assert (t && data_in->reader_cache->nodes.length () == from);\n+\t  /* We streamed in new tree.  Add it to cache and process dref.  */\n+\t  if (data_in->reader_cache->nodes.length () == from + 1)\n+\t    {\n+\t      num_unshared_trees_read++;\n+\t      data_in->location_cache.accept_location_cache ();\n+\t      process_dref (data_in, t, from);\n+\t      if (TREE_CODE (t) == IDENTIFIER_NODE\n+\t\t  || (TREE_CODE (t) == INTEGER_CST\n+\t\t      && !TREE_OVERFLOW (t)))\n+\t\t;\n+\t      else\n+\t\t{\n+\t\t  lto_maybe_register_decl (data_in, t, from);\n+\t\t  process_new_tree (t, &hm, from, &total, data_in);\n+\t\t}\n+\t    }\n+\t  else\n+\t    /* FIXME: It seems useless to pickle stray references.  */\n+\t    gcc_assert (data_in->reader_cache->nodes.length () == from);\n \t}\n     }\n \n@@ -2953,10 +2998,13 @@ print_lto_report_1 (void)\n   const char *pfx = (flag_lto) ? \"LTO\" : (flag_wpa) ? \"WPA\" : \"LTRANS\";\n   fprintf (stderr, \"%s statistics\\n\", pfx);\n \n-  fprintf (stderr, \"[%s] read %lu SCCs of average size %f\\n\",\n+  fprintf (stderr, \"[%s] read %lu unshared trees\\n\",\n+\t   pfx, num_unshared_trees_read);\n+  fprintf (stderr, \"[%s] read %lu mergeable SCCs of average size %f\\n\",\n \t   pfx, num_sccs_read, total_scc_size / (double)num_sccs_read);\n-  fprintf (stderr, \"[%s] %lu tree bodies read in total\\n\", pfx, total_scc_size);\n-  if (flag_wpa && tree_scc_hash)\n+  fprintf (stderr, \"[%s] %lu tree bodies read in total\\n\", pfx,\n+\t   total_scc_size + num_unshared_trees_read);\n+  if (flag_wpa && tree_scc_hash && num_sccs_read)\n     {\n       fprintf (stderr, \"[%s] tree SCC table: size %ld, %ld elements, \"\n \t       \"collision ratio: %f\\n\", pfx,"}]}