{"sha": "3b6cac2b44b384cd2091eaeaebeb3478c253a25d", "node_id": "C_kwDOANBUbNoAKDNiNmNhYzJiNDRiMzg0Y2QyMDkxZWFlYWViZWIzNDc4YzI1M2EyNWQ", "commit": {"author": {"name": "Florian Weimer", "email": "fweimer@redhat.com", "date": "2023-01-02T15:18:02Z"}, "committer": {"name": "Florian Weimer", "email": "fweimer@redhat.com", "date": "2023-01-02T15:18:02Z"}, "message": "Compute a table of DWARF register sizes at compile\n\nThe sizes are compile-time constants.  Create a vector with them,\nso that they can be inspected at compile time.\n\ngcc/\n\n\t* dwarf2cfi.cc (init_return_column_size): Remove.\n\t(init_one_dwarf_reg_size): Adjust.\n\t(generate_dwarf_reg_sizes): New function.  Extracted\n\tfrom expand_builtin_init_dwarf_reg_sizes.\n\t(expand_builtin_init_dwarf_reg_sizes): Call\n\tgenerate_dwarf_reg_sizes.\n\t* target.def (init_dwarf_reg_sizes_extra): Adjust\n\thook signature.\n\t* config/msp430/msp430.cc\n\t(msp430_init_dwarf_reg_sizes_extra): Adjust.\n\t* config/rs6000/rs6000.cc\n\t(rs6000_init_dwarf_reg_sizes_extra): Likewise.\n\t* doc/tm.texi: Update.", "tree": {"sha": "0c7eaab6bb102eca8829b40fef1e9d531f10eb7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c7eaab6bb102eca8829b40fef1e9d531f10eb7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b6cac2b44b384cd2091eaeaebeb3478c253a25d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b6cac2b44b384cd2091eaeaebeb3478c253a25d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b6cac2b44b384cd2091eaeaebeb3478c253a25d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b6cac2b44b384cd2091eaeaebeb3478c253a25d/comments", "author": {"login": "fweimer-rh", "id": 75532728, "node_id": "MDQ6VXNlcjc1NTMyNzI4", "avatar_url": "https://avatars.githubusercontent.com/u/75532728?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fweimer-rh", "html_url": "https://github.com/fweimer-rh", "followers_url": "https://api.github.com/users/fweimer-rh/followers", "following_url": "https://api.github.com/users/fweimer-rh/following{/other_user}", "gists_url": "https://api.github.com/users/fweimer-rh/gists{/gist_id}", "starred_url": "https://api.github.com/users/fweimer-rh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fweimer-rh/subscriptions", "organizations_url": "https://api.github.com/users/fweimer-rh/orgs", "repos_url": "https://api.github.com/users/fweimer-rh/repos", "events_url": "https://api.github.com/users/fweimer-rh/events{/privacy}", "received_events_url": "https://api.github.com/users/fweimer-rh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fweimer-rh", "id": 75532728, "node_id": "MDQ6VXNlcjc1NTMyNzI4", "avatar_url": "https://avatars.githubusercontent.com/u/75532728?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fweimer-rh", "html_url": "https://github.com/fweimer-rh", "followers_url": "https://api.github.com/users/fweimer-rh/followers", "following_url": "https://api.github.com/users/fweimer-rh/following{/other_user}", "gists_url": "https://api.github.com/users/fweimer-rh/gists{/gist_id}", "starred_url": "https://api.github.com/users/fweimer-rh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fweimer-rh/subscriptions", "organizations_url": "https://api.github.com/users/fweimer-rh/orgs", "repos_url": "https://api.github.com/users/fweimer-rh/repos", "events_url": "https://api.github.com/users/fweimer-rh/events{/privacy}", "received_events_url": "https://api.github.com/users/fweimer-rh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8385088039f58a1d403cbb0792105236d240de85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8385088039f58a1d403cbb0792105236d240de85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8385088039f58a1d403cbb0792105236d240de85"}], "stats": {"total": 133, "additions": 58, "deletions": 75}, "files": [{"sha": "dbea8d7f50ff5a9785e98fed9bc20309f3dd38be", "filename": "gcc/config/msp430/msp430.cc", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6cac2b44b384cd2091eaeaebeb3478c253a25d/gcc%2Fconfig%2Fmsp430%2Fmsp430.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6cac2b44b384cd2091eaeaebeb3478c253a25d/gcc%2Fconfig%2Fmsp430%2Fmsp430.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.cc?ref=3b6cac2b44b384cd2091eaeaebeb3478c253a25d", "patch": "@@ -3202,11 +3202,9 @@ msp430_expand_eh_return (rtx eh_handler)\n #undef  TARGET_INIT_DWARF_REG_SIZES_EXTRA\n #define TARGET_INIT_DWARF_REG_SIZES_EXTRA msp430_init_dwarf_reg_sizes_extra\n void\n-msp430_init_dwarf_reg_sizes_extra (tree address)\n+msp430_init_dwarf_reg_sizes_extra (poly_uint16 *sizes)\n {\n   int i;\n-  rtx addr = expand_normal (address);\n-  rtx mem = gen_rtx_MEM (BLKmode, addr);\n \n   /* This needs to match msp430_unwind_word_mode (above).  */\n   if (!msp430x)\n@@ -3218,12 +3216,7 @@ msp430_init_dwarf_reg_sizes_extra (tree address)\n       unsigned int rnum = DWARF2_FRAME_REG_OUT (dnum, 1);\n \n       if (rnum < DWARF_FRAME_REGISTERS)\n-\t{\n-\t  HOST_WIDE_INT offset = rnum * GET_MODE_SIZE (QImode);\n-\n-\t  emit_move_insn (adjust_address (mem, QImode, offset),\n-\t\t\t  gen_int_mode (4, QImode));\n-\t}\n+\tsizes[rnum] = 4;\n     }\n }\n "}, {"sha": "875684a3895ca04b3f02de42b1a087c73f376001", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6cac2b44b384cd2091eaeaebeb3478c253a25d/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6cac2b44b384cd2091eaeaebeb3478c253a25d/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=3b6cac2b44b384cd2091eaeaebeb3478c253a25d", "patch": "@@ -23860,27 +23860,17 @@ rs6000_initial_elimination_offset (int from, int to)\n /* Fill in sizes of registers used by unwinder.  */\n \n static void\n-rs6000_init_dwarf_reg_sizes_extra (tree address)\n+rs6000_init_dwarf_reg_sizes_extra (poly_uint16 *sizes)\n {\n   if (TARGET_MACHO && ! TARGET_ALTIVEC)\n     {\n       int i;\n-      machine_mode mode = TYPE_MODE (char_type_node);\n-      rtx addr = expand_expr (address, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      rtx mem = gen_rtx_MEM (BLKmode, addr);\n-      rtx value = gen_int_mode (16, mode);\n \n       /* On Darwin, libgcc may be built to run on both G3 and G4/5.\n \t The unwinder still needs to know the size of Altivec registers.  */\n \n       for (i = FIRST_ALTIVEC_REGNO; i < LAST_ALTIVEC_REGNO+1; i++)\n-\t{\n-\t  int column = DWARF_REG_TO_UNWIND_COLUMN\n-\t\t(DWARF2_FRAME_REG_OUT (DWARF_FRAME_REGNUM (i), true));\n-\t  HOST_WIDE_INT offset = column * GET_MODE_SIZE (mode);\n-\n-\t  emit_move_insn (adjust_address (mem, mode, offset), value);\n-\t}\n+\tsizes[i] = 16;\n     }\n }\n "}, {"sha": "b6d7900f212749b5bde3fb7c226a0e20cd4e8e27", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6cac2b44b384cd2091eaeaebeb3478c253a25d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6cac2b44b384cd2091eaeaebeb3478c253a25d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=3b6cac2b44b384cd2091eaeaebeb3478c253a25d", "patch": "@@ -9840,13 +9840,14 @@ used to return a smaller mode than the raw mode to prevent call\n clobbered parts of a register altering the frame register size\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_INIT_DWARF_REG_SIZES_EXTRA (tree @var{address})\n+@deftypefn {Target Hook} void TARGET_INIT_DWARF_REG_SIZES_EXTRA (poly_uint16 *@var{sizes})\n If some registers are represented in Dwarf-2 unwind information in\n multiple pieces, define this hook to fill in information about the\n sizes of those pieces in the table used by the unwinder at runtime.\n-It will be called by @code{expand_builtin_init_dwarf_reg_sizes} after\n+It will be called by @code{generate_dwarf_reg_sizes} after\n filling in a single size corresponding to each hard register;\n-@var{address} is the address of the table.\n+@var{sizes} is the address of the table.  It will contain\n+@code{DWARF_FRAME_REGISTERS} elements when this hook is called.\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_ASM_TTYPE (rtx @var{sym})"}, {"sha": "4d2bd869a4b9e094e474543fcaa256a687edd696", "filename": "gcc/dwarf2cfi.cc", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6cac2b44b384cd2091eaeaebeb3478c253a25d/gcc%2Fdwarf2cfi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6cac2b44b384cd2091eaeaebeb3478c253a25d/gcc%2Fdwarf2cfi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.cc?ref=3b6cac2b44b384cd2091eaeaebeb3478c253a25d", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"except.h\"\t\t/* expand_builtin_dwarf_sp_column */\n #include \"profile-count.h\"\t/* For expr.h */\n-#include \"expr.h\"\t\t/* init_return_column_size */\n+#include \"expr.h\"\t\t/* expand_normal, emit_move_insn */\n #include \"output.h\"\t\t/* asm_out_file */\n #include \"debug.h\"\t\t/* dwarf2out_do_frame, dwarf2out_do_cfi_asm */\n #include \"flags.h\"\t\t/* dwarf_debuginfo_p */\n@@ -241,18 +241,6 @@ expand_builtin_dwarf_sp_column (void)\n   return GEN_INT (DWARF2_FRAME_REG_OUT (dwarf_regnum, 1));\n }\n \n-/* MEM is a memory reference for the register size table, each element of\n-   which has mode MODE.  Initialize column C as a return address column.  */\n-\n-static void\n-init_return_column_size (scalar_int_mode mode, rtx mem, unsigned int c)\n-{\n-  HOST_WIDE_INT offset = c * GET_MODE_SIZE (mode);\n-  HOST_WIDE_INT size = GET_MODE_SIZE (Pmode);\n-  emit_move_insn (adjust_address (mem, mode, offset),\n-\t\t  gen_int_mode (size, mode));\n-}\n-\n /* Datastructure used by expand_builtin_init_dwarf_reg_sizes and\n    init_one_dwarf_reg_size to communicate on what has been done by the\n    latter.  */\n@@ -274,17 +262,14 @@ struct init_one_dwarf_reg_state\n    use for the size entry to initialize, and INIT_STATE is the communication\n    datastructure conveying what we're doing to our caller.  */\n \n-static\n-void init_one_dwarf_reg_size (int regno, machine_mode regmode,\n-\t\t\t      rtx table, machine_mode slotmode,\n-\t\t\t      init_one_dwarf_reg_state *init_state)\n+static void\n+init_one_dwarf_reg_size (int regno, machine_mode regmode,\n+\t\t\t poly_uint16 *table,\n+\t\t\t init_one_dwarf_reg_state *init_state)\n {\n   const unsigned int dnum = DWARF_FRAME_REGNUM (regno);\n   const unsigned int rnum = DWARF2_FRAME_REG_OUT (dnum, 1);\n   const unsigned int dcol = DWARF_REG_TO_UNWIND_COLUMN (rnum);\n-  \n-  poly_int64 slotoffset = dcol * GET_MODE_SIZE (slotmode);\n-  poly_int64 regsize = GET_MODE_SIZE (regmode);\n \n   init_state->processed_regno[regno] = true;\n \n@@ -298,66 +283,80 @@ void init_one_dwarf_reg_size (int regno, machine_mode regmode,\n       init_state->wrote_return_column = true;\n     }\n \n-  /* ??? When is this true?  Should it be a test based on DCOL instead?  */\n-  if (maybe_lt (slotoffset, 0))\n-    return;\n-\n-  emit_move_insn (adjust_address (table, slotmode, slotoffset),\n-\t\t  gen_int_mode (regsize, slotmode));\n+  table[dcol] = GET_MODE_SIZE (regmode);\n }\n \n-/* Generate code to initialize the dwarf register size table located\n-   at the provided ADDRESS.  */\n+/* Fill SIZES with size information for each DWARF register. */\n \n-void\n-expand_builtin_init_dwarf_reg_sizes (tree address)\n+static void\n+generate_dwarf_reg_sizes (poly_uint16 *sizes)\n {\n-  unsigned int i;\n-  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (char_type_node);\n-  rtx addr = expand_normal (address);\n-  rtx mem = gen_rtx_MEM (BLKmode, addr);\n-\n-  init_one_dwarf_reg_state init_state;\n+  for (unsigned int i = 0; i < DWARF_FRAME_REGISTERS; i++)\n+    sizes[i] = poly_uint16{};\n \n+  init_one_dwarf_reg_state init_state{};\n   memset ((char *)&init_state, 0, sizeof (init_state));\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+  for (unsigned int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-      machine_mode save_mode;\n-      rtx span;\n-\n       /* No point in processing a register multiple times.  This could happen\n \t with register spans, e.g. when a reg is first processed as a piece of\n \t a span, then as a register on its own later on.  */\n \n       if (init_state.processed_regno[i])\n \tcontinue;\n \n-      save_mode = targetm.dwarf_frame_reg_mode (i);\n-      span = targetm.dwarf_register_span (gen_rtx_REG (save_mode, i));\n+      machine_mode save_mode = targetm.dwarf_frame_reg_mode (i);\n+      rtx span = targetm.dwarf_register_span (gen_rtx_REG (save_mode, i));\n \n       if (!span)\n-\tinit_one_dwarf_reg_size (i, save_mode, mem, mode, &init_state);\n+\tinit_one_dwarf_reg_size (i, save_mode, sizes, &init_state);\n       else\n \t{\n \t  for (int si = 0; si < XVECLEN (span, 0); si++)\n \t    {\n \t      rtx reg = XVECEXP (span, 0, si);\n \n \t      init_one_dwarf_reg_size\n-\t\t(REGNO (reg), GET_MODE (reg), mem, mode, &init_state);\n+\t\t(REGNO (reg), GET_MODE (reg), sizes, &init_state);\n \t    }\n \t}\n     }\n \n   if (!init_state.wrote_return_column)\n-    init_return_column_size (mode, mem, DWARF_FRAME_RETURN_COLUMN);\n+    sizes[DWARF_FRAME_RETURN_COLUMN] = GET_MODE_SIZE (Pmode);\n \n #ifdef DWARF_ALT_FRAME_RETURN_COLUMN\n-  init_return_column_size (mode, mem, DWARF_ALT_FRAME_RETURN_COLUMN);\n+  sizes[DWARF_ALT_FRAME_RETURN_COLUMN] = GET_MODE_SIZE (Pmode);\n #endif\n \n-  targetm.init_dwarf_reg_sizes_extra (address);\n+  if (targetm.init_dwarf_reg_sizes_extra != nullptr)\n+    targetm.init_dwarf_reg_sizes_extra (sizes);\n+}\n+\n+/* Generate code to initialize the dwarf register size table located\n+   at the provided ADDRESS.  */\n+\n+void\n+expand_builtin_init_dwarf_reg_sizes (tree address)\n+{\n+  poly_uint16 *sizes = XALLOCAVEC (poly_uint16, DWARF_FRAME_REGISTERS);\n+  generate_dwarf_reg_sizes (sizes);\n+\n+  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (char_type_node);\n+  rtx addr = expand_normal (address);\n+  rtx mem = gen_rtx_MEM (BLKmode, addr);\n+  for (unsigned int i = 0; i < DWARF_FRAME_REGISTERS; ++i)\n+    {\n+      unsigned short value;\n+      if (sizes[i].is_constant (&value) && value == 0)\n+\t/* No need to set the value to zero again.  */\n+\tcontinue;\n+\n+      HOST_WIDE_INT offset = i * GET_MODE_SIZE (mode);\n+      emit_move_insn (adjust_address (mem, mode, offset),\n+\t\t      gen_int_mode (sizes[i], mode));\n+    }\n }\n \n \f"}, {"sha": "da5dd31d7a4ba85457cf7f52997d16c98a721134", "filename": "gcc/target.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6cac2b44b384cd2091eaeaebeb3478c253a25d/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6cac2b44b384cd2091eaeaebeb3478c253a25d/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=3b6cac2b44b384cd2091eaeaebeb3478c253a25d", "patch": "@@ -4039,11 +4039,11 @@ DEFHOOK\n  \"If some registers are represented in Dwarf-2 unwind information in\\n\\\n multiple pieces, define this hook to fill in information about the\\n\\\n sizes of those pieces in the table used by the unwinder at runtime.\\n\\\n-It will be called by @code{expand_builtin_init_dwarf_reg_sizes} after\\n\\\n+It will be called by @code{generate_dwarf_reg_sizes} after\\n\\\n filling in a single size corresponding to each hard register;\\n\\\n-@var{address} is the address of the table.\",\n- void, (tree address),\n- hook_void_tree)\n+@var{sizes} is the address of the table.  It will contain\\n\\\n+@code{DWARF_FRAME_REGISTERS} elements when this hook is called.\",\n+ void, (poly_uint16 *sizes), nullptr)\n \n /* Fetch the fixed register(s) which hold condition codes, for\n    targets where it makes sense to look for duplicate assignments to"}]}