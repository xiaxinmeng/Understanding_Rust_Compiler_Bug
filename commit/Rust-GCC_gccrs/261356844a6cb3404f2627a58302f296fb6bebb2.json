{"sha": "261356844a6cb3404f2627a58302f296fb6bebb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYxMzU2ODQ0YTZjYjM0MDRmMjYyN2E1ODMwMmYyOTZmYjZiZWJiMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-02-15T23:29:02Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-05-09T22:20:13Z"}, "message": "libbacktrace: support fetching executable name using sysctl\n\nThis supports FreeBSD and NetBSD when /proc is not mounted.\n\nlibbacktrace/\n\t* fileline.c (sysctl_exec_name): New static function.\n\t(sysctl_exec_name1): New macro or static function.\n\t(sysctl_exec_name2): Likewise.\n\t(fileline_initialize): Try sysctl_exec_name[12].\n\t* configure.ac: Check for sysctl args to fetch executable name.\n\t* configure: Regenerate.\n\t* config.h.in: Regenerate.", "tree": {"sha": "84dbfe1a8086ad45ee32fabca2ca1212b6050b85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84dbfe1a8086ad45ee32fabca2ca1212b6050b85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/261356844a6cb3404f2627a58302f296fb6bebb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261356844a6cb3404f2627a58302f296fb6bebb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/261356844a6cb3404f2627a58302f296fb6bebb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261356844a6cb3404f2627a58302f296fb6bebb2/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "925b418e065a9d94bd2c0d87fbfc93b573a309af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/925b418e065a9d94bd2c0d87fbfc93b573a309af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/925b418e065a9d94bd2c0d87fbfc93b573a309af"}], "stats": {"total": 202, "additions": 201, "deletions": 1}, "files": [{"sha": "1739be9eedd2b22176de0b6e36c05542bf37ec39", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261356844a6cb3404f2627a58302f296fb6bebb2/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261356844a6cb3404f2627a58302f296fb6bebb2/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=261356844a6cb3404f2627a58302f296fb6bebb2", "patch": "@@ -1,3 +1,13 @@\n+2020-05-08  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* fileline.c (sysctl_exec_name): New static function.\n+\t(sysctl_exec_name1): New macro or static function.\n+\t(sysctl_exec_name2): Likewise.\n+\t(fileline_initialize): Try sysctl_exec_name[12].\n+\t* configure.ac: Check for sysctl args to fetch executable name.\n+\t* configure: Regenerate.\n+\t* config.h.in: Regenerate.\n+\n 2020-02-15  Ian Lance Taylor  <iant@golang.org>\n \n \t* ztest.c (test_large): Update file to current libgo test file."}, {"sha": "034ef81c3ec4870bd3ec266924d3862fe67959eb", "filename": "libbacktrace/config.h.in", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261356844a6cb3404f2627a58302f296fb6bebb2/libbacktrace%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261356844a6cb3404f2627a58302f296fb6bebb2/libbacktrace%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfig.h.in?ref=261356844a6cb3404f2627a58302f296fb6bebb2", "patch": "@@ -34,6 +34,14 @@\n /* Define to 1 if you have the <inttypes.h> header file. */\n #undef HAVE_INTTYPES_H\n \n+/* Define to 1 if you have KERN_PROC and KERN_PROC_PATHNAME in <sys/sysctl.h>.\n+   */\n+#undef HAVE_KERN_PROC\n+\n+/* Define to 1 if you have KERN_PROCARGS and KERN_PROC_PATHNAME in\n+   <sys/sysctl.h>. */\n+#undef HAVE_KERN_PROC_ARGS\n+\n /* Define to 1 if you have the <link.h> header file. */\n #undef HAVE_LINK_H\n "}, {"sha": "33ce5891e6edea38c6c335dd0bc58967bae08e22", "filename": "libbacktrace/configure", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261356844a6cb3404f2627a58302f296fb6bebb2/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261356844a6cb3404f2627a58302f296fb6bebb2/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=261356844a6cb3404f2627a58302f296fb6bebb2", "patch": "@@ -13182,6 +13182,76 @@ $as_echo \"#define HAVE_GETEXECNAME 1\" >>confdefs.h\n \n fi\n \n+# Check for sysctl definitions.\n+\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for KERN_PROC\" >&5\n+$as_echo_n \"checking for KERN_PROC... \" >&6; }\n+if ${libbacktrace_cv_proc+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+#include <sys/types.h>\n+#include <sys/sysctl.h>\n+\n+int\n+main ()\n+{\n+int mib0 = CTL_KERN; int mib1 = KERN_PROC; int mib2 = KERN_PROC_PATHNAME;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  libbacktrace_cv_proc=yes\n+else\n+  libbacktrace_cv_proc=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libbacktrace_cv_proc\" >&5\n+$as_echo \"$libbacktrace_cv_proc\" >&6; }\n+if test \"$libbacktrace_cv_proc\" = \"yes\"; then\n+\n+$as_echo \"#define HAVE_KERN_PROC 1\" >>confdefs.h\n+\n+fi\n+\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for KERN_PROG_ARGS\" >&5\n+$as_echo_n \"checking for KERN_PROG_ARGS... \" >&6; }\n+if ${libbacktrace_cv_procargs+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+#include <sys/types.h>\n+#include <sys/sysctl.h>\n+\n+int\n+main ()\n+{\n+int mib0 = CTL_KERN; int mib1 = KERN_PROC_ARGS; int mib2 = KERN_PROC_PATHNAME;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  libbacktrace_cv_procargs=yes\n+else\n+  libbacktrace_cv_procargs=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libbacktrace_cv_procargs\" >&5\n+$as_echo \"$libbacktrace_cv_procargs\" >&6; }\n+if test \"$libbacktrace_cv_procargs\" = \"yes\"; then\n+\n+$as_echo \"#define HAVE_KERN_PROC_ARGS 1\" >>confdefs.h\n+\n+fi\n+\n # Check for the clock_gettime function.\n for ac_func in clock_gettime\n do :"}, {"sha": "5beed68ccf6a85243466463d66913c957b4c99b4", "filename": "libbacktrace/configure.ac", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261356844a6cb3404f2627a58302f296fb6bebb2/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261356844a6cb3404f2627a58302f296fb6bebb2/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=261356844a6cb3404f2627a58302f296fb6bebb2", "patch": "@@ -388,6 +388,36 @@ if test \"$have_getexecname\" = \"yes\"; then\n   AC_DEFINE(HAVE_GETEXECNAME, 1, [Define if getexecname is available.])\n fi\n \n+# Check for sysctl definitions.\n+\n+AC_CACHE_CHECK([for KERN_PROC],\n+[libbacktrace_cv_proc],\n+[AC_COMPILE_IFELSE(\n+  [AC_LANG_PROGRAM([\n+#include <sys/types.h>\n+#include <sys/sysctl.h>\n+], [int mib0 = CTL_KERN; int mib1 = KERN_PROC; int mib2 = KERN_PROC_PATHNAME;])],\n+  [libbacktrace_cv_proc=yes],\n+  [libbacktrace_cv_proc=no])])\n+if test \"$libbacktrace_cv_proc\" = \"yes\"; then\n+  AC_DEFINE([HAVE_KERN_PROC], 1,\n+            [Define to 1 if you have KERN_PROC and KERN_PROC_PATHNAME in <sys/sysctl.h>.])\n+fi\n+\n+AC_CACHE_CHECK([for KERN_PROG_ARGS],\n+[libbacktrace_cv_procargs],\n+[AC_COMPILE_IFELSE(\n+  [AC_LANG_PROGRAM([\n+#include <sys/types.h>\n+#include <sys/sysctl.h>\n+], [int mib0 = CTL_KERN; int mib1 = KERN_PROC_ARGS; int mib2 = KERN_PROC_PATHNAME;])],\n+  [libbacktrace_cv_procargs=yes],\n+  [libbacktrace_cv_procargs=no])])\n+if test \"$libbacktrace_cv_procargs\" = \"yes\"; then\n+  AC_DEFINE([HAVE_KERN_PROC_ARGS], 1,\n+            [Define to 1 if you have KERN_PROCARGS and KERN_PROC_PATHNAME in <sys/sysctl.h>.])\n+fi\n+\n # Check for the clock_gettime function.\n AC_CHECK_FUNCS(clock_gettime)\n clock_gettime_link="}, {"sha": "cc1011e8b5ddab19e18db94f6a8fce824bb27822", "filename": "libbacktrace/fileline.c", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261356844a6cb3404f2627a58302f296fb6bebb2/libbacktrace%2Ffileline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261356844a6cb3404f2627a58302f296fb6bebb2/libbacktrace%2Ffileline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Ffileline.c?ref=261356844a6cb3404f2627a58302f296fb6bebb2", "patch": "@@ -39,13 +39,89 @@ POSSIBILITY OF SUCH DAMAGE.  */\n #include <stdlib.h>\n #include <unistd.h>\n \n+#if defined (HAVE_KERN_PROC_ARGS) || defined (HAVE_KERN_PROC)\n+#include <sys/sysctl.h>\n+#endif\n+\n #include \"backtrace.h\"\n #include \"internal.h\"\n \n #ifndef HAVE_GETEXECNAME\n #define getexecname() NULL\n #endif\n \n+#if !defined (HAVE_KERN_PROC_ARGS) && !defined (HAVE_KERN_PROC)\n+\n+#define sysctl_exec_name1(state, error_callback, data) NULL\n+#define sysctl_exec_name2(state, error_callback, data) NULL\n+\n+#else /* defined (HAVE_KERN_PROC_ARGS) || |defined (HAVE_KERN_PROC) */\n+\n+static char *\n+sysctl_exec_name (struct backtrace_state *state,\n+\t\t  int mib0, int mib1, int mib2, int mib3,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  int mib[4];\n+  size_t len;\n+  char *name;\n+  size_t rlen;\n+\n+  mib[0] = mib0;\n+  mib[1] = mib1;\n+  mib[2] = mib2;\n+  mib[3] = mib3;\n+\n+  if (sysctl (mib, 4, NULL, &len, NULL, 0) < 0)\n+    return NULL;\n+  name = (char *) backtrace_alloc (state, len, error_callback, data);\n+  if (name == NULL)\n+    return NULL;\n+  rlen = len;\n+  if (sysctl (mib, 4, name, &rlen, NULL, 0) < 0)\n+    {\n+      backtrace_free (state, name, len, error_callback, data);\n+      return NULL;\n+    }\n+  return name;\n+}\n+\n+#ifdef HAVE_KERN_PROC_ARGS\n+\n+static char *\n+sysctl_exec_name1 (struct backtrace_state *state,\n+\t\t   backtrace_error_callback error_callback, void *data)\n+{\n+  /* This variant is used on NetBSD.  */\n+  return sysctl_exec_name (state, CTL_KERN, KERN_PROC_ARGS, -1,\n+\t\t\t   KERN_PROC_PATHNAME, error_callback, data);\n+}\n+\n+#else\n+\n+#define sysctl_exec_name1(state, error_callback, data) NULL\n+\n+#endif\n+\n+#ifdef HAVE_KERN_PROC\n+\n+static char *\n+sysctl_exec_name2 (struct backtrace_state *state,\n+\t\t   backtrace_error_callback error_callback, void *data)\n+{\n+  /* This variant is used on FreeBSD.  */\n+  return sysctl_exec_name (state, CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1,\n+\t\t\t   error_callback, data);\n+}\n+\n+#else\n+\n+#define sysctl_exec_name2(state, error_callback, data) NULL\n+\n+#endif\n+\n+#endif /* defined (HAVE_KERN_PROC_ARGS) || |defined (HAVE_KERN_PROC) */\n+\n /* Initialize the fileline information from the executable.  Returns 1\n    on success, 0 on failure.  */\n \n@@ -83,7 +159,7 @@ fileline_initialize (struct backtrace_state *state,\n \n   descriptor = -1;\n   called_error_callback = 0;\n-  for (pass = 0; pass < 5; ++pass)\n+  for (pass = 0; pass < 7; ++pass)\n     {\n       int does_not_exist;\n \n@@ -106,6 +182,12 @@ fileline_initialize (struct backtrace_state *state,\n \t\t    (long) getpid ());\n \t  filename = buf;\n \t  break;\n+\tcase 5:\n+\t  filename = sysctl_exec_name1 (state, error_callback, data);\n+\t  break;\n+\tcase 6:\n+\t  filename = sysctl_exec_name2 (state, error_callback, data);\n+\t  break;\n \tdefault:\n \t  abort ();\n \t}"}]}