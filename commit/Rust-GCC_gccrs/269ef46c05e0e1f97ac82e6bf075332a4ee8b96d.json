{"sha": "269ef46c05e0e1f97ac82e6bf075332a4ee8b96d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY5ZWY0NmMwNWUwZTFmOTdhYzgyZTZiZjA3NTMzMmE0ZWU4Yjk2ZA==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-11-05T06:20:37Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-11-05T06:20:37Z"}, "message": "Begin cleaning up jump.c\n\n\tBegin cleaning up jump.c\n\t* jump.c (init_label_info, delete_barrier_successors,\n\tmark_all_labels, delete_unreferenced_labels,\n\tdelete_noop_moves, calculate_can_reach_end): New functions broken\n\tout of jump_optimize.\n\t(jump_optimize): Use them.\n\nFrom-SVN: r23539", "tree": {"sha": "3891a8892562a3a0ef0922c8f099e512f202c6c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3891a8892562a3a0ef0922c8f099e512f202c6c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/269ef46c05e0e1f97ac82e6bf075332a4ee8b96d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269ef46c05e0e1f97ac82e6bf075332a4ee8b96d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/269ef46c05e0e1f97ac82e6bf075332a4ee8b96d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269ef46c05e0e1f97ac82e6bf075332a4ee8b96d/comments", "author": null, "committer": null, "parents": [{"sha": "b37f006bf09e6f219c27810c2910ec8a95fa7043", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b37f006bf09e6f219c27810c2910ec8a95fa7043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b37f006bf09e6f219c27810c2910ec8a95fa7043"}], "stats": {"total": 836, "additions": 457, "deletions": 379}, "files": [{"sha": "20138d45541eae251fa6c19b57c46f7eb8c54625", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269ef46c05e0e1f97ac82e6bf075332a4ee8b96d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269ef46c05e0e1f97ac82e6bf075332a4ee8b96d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=269ef46c05e0e1f97ac82e6bf075332a4ee8b96d", "patch": "@@ -1,3 +1,11 @@\n+Thu Nov  5 07:59:05 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* jump.c (init_label_info, delete_barrier_successors,\n+\tmark_all_labels, delete_unreferenced_labels,\n+\tdelete_noop_moves, calculate_can_reach_end): New functions broken\n+\tout of jump_optimize.\n+\t(jump_optimize): Use them.\n+\n Thu Nov  5 07:57:45 EST 1998  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* except.c (expand_fixup_region_end): Make sure outer context labels"}, {"sha": "cfc7f4f9da0bc951318212dc9d06cab2445c5968", "filename": "gcc/jump.c", "status": "modified", "additions": 449, "deletions": 379, "changes": 828, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269ef46c05e0e1f97ac82e6bf075332a4ee8b96d/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269ef46c05e0e1f97ac82e6bf075332a4ee8b96d/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=269ef46c05e0e1f97ac82e6bf075332a4ee8b96d", "patch": "@@ -108,6 +108,12 @@ int can_reach_end;\n \n static int cross_jump_death_matters = 0;\n \n+static int init_label_info\t\tPROTO((rtx));\n+static void delete_barrier_successors\tPROTO((rtx));\n+static void mark_all_labels\t\tPROTO((rtx, int));\n+static rtx delete_unreferenced_labels\tPROTO((rtx));\n+static void delete_noop_moves\t\tPROTO((rtx));\n+static int calculate_can_reach_end\tPROTO((rtx, int, int));\n static int duplicate_loop_exit_test\tPROTO((rtx));\n static void find_cross_jump\t\tPROTO((rtx, rtx, int, rtx *, rtx *));\n static void do_cross_jump\t\tPROTO((rtx, rtx, rtx));\n@@ -157,90 +163,23 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n   rtx last_insn;\n \n   cross_jump_death_matters = (cross_jump == 2);\n-\n-  /* Initialize LABEL_NUSES and JUMP_LABEL fields.  Delete any REG_LABEL\n-     notes whose labels don't occur in the insn any more.  */\n-\n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == CODE_LABEL)\n-\tLABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n-      else if (GET_CODE (insn) == JUMP_INSN)\n-\tJUMP_LABEL (insn) = 0;\n-      else if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n-\tfor (note = REG_NOTES (insn); note; note = next)\n-\t  {\n-\t    next = XEXP (note, 1);\n-\t    if (REG_NOTE_KIND (note) == REG_LABEL\n-\t\t&& ! reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n-\t      remove_note (insn, note);\n-\t  }\n-\n-      if (INSN_UID (insn) > max_uid)\n-\tmax_uid = INSN_UID (insn);\n-    }\n-\n-  max_uid++;\n+  max_uid = init_label_info (f) + 1;\n \n   /* If we are performing cross jump optimizations, then initialize\n      tables mapping UIDs to EH regions to avoid incorrect movement\n      of insns from one EH region to another.  */\n   if (flag_exceptions && cross_jump)\n     init_insn_eh_region (f, max_uid);\n \n-  /* Delete insns following barriers, up to next label.  */\n-\n-  for (insn = f; insn;)\n-    {\n-      if (GET_CODE (insn) == BARRIER)\n-\t{\n-\t  insn = NEXT_INSN (insn);\n-\t  while (insn != 0 && GET_CODE (insn) != CODE_LABEL)\n-\t    {\n-\t      if (GET_CODE (insn) == NOTE\n-\t\t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_END)\n-\t\tinsn = NEXT_INSN (insn);\n-\t      else\n-\t\tinsn = delete_insn (insn);\n-\t    }\n-\t  /* INSN is now the code_label.  */\n-\t}\n-      else\n-\tinsn = NEXT_INSN (insn);\n-    }\n+  delete_barrier_successors (f);\n \n   /* Leave some extra room for labels and duplicate exit test insns\n      we make.  */\n   max_jump_chain = max_uid * 14 / 10;\n   jump_chain = (rtx *) alloca (max_jump_chain * sizeof (rtx));\n   bzero ((char *) jump_chain, max_jump_chain * sizeof (rtx));\n \n-  /* Mark the label each jump jumps to.\n-     Combine consecutive labels, and count uses of labels.\n-\n-     For each label, make a chain (using `jump_chain')\n-     of all the *unconditional* jumps that jump to it;\n-     also make a chain of all returns.  */\n-\n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n-    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-      {\n-\tmark_jump_label (PATTERN (insn), insn, cross_jump);\n-\tif (! INSN_DELETED_P (insn) && GET_CODE (insn) == JUMP_INSN)\n-\t  {\n-\t    if (JUMP_LABEL (insn) != 0 && simplejump_p (insn))\n-\t      {\n-\t\tjump_chain[INSN_UID (insn)]\n-\t\t  = jump_chain[INSN_UID (JUMP_LABEL (insn))];\n-\t\tjump_chain[INSN_UID (JUMP_LABEL (insn))] = insn;\n-\t      }\n-\t    if (GET_CODE (PATTERN (insn)) == RETURN)\n-\t      {\n-\t\tjump_chain[INSN_UID (insn)] = jump_chain[0];\n-\t\tjump_chain[0] = insn;\n-\t      }\n-\t  }\n-      }\n+  mark_all_labels (f, cross_jump);\n \n   /* Keep track of labels used from static data;\n      they cannot ever be deleted.  */\n@@ -258,51 +197,11 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \n   exception_optimize ();\n \n-  /* Delete all labels already not referenced.\n-     Also find the last insn.  */\n-\n-  last_insn = 0;\n-  for (insn = f; insn; )\n-    {\n-      if (GET_CODE (insn) == CODE_LABEL && LABEL_NUSES (insn) == 0)\n-\tinsn = delete_insn (insn);\n-      else\n-\t{\n-\t  last_insn = insn;\n-\t  insn = NEXT_INSN (insn);\n-\t}\n-    }\n+  last_insn = delete_unreferenced_labels (f);\n \n   if (!optimize)\n     {\n-      /* See if there is still a NOTE_INSN_FUNCTION_END in this function.\n-\t If so record that this function can drop off the end.  */\n-\n-      insn = last_insn;\n-      {\n-\tint n_labels = 1;\n-\twhile (insn\n-\t       /* One label can follow the end-note: the return label.  */\n-\t       && ((GET_CODE (insn) == CODE_LABEL && n_labels-- > 0)\n-\t\t   /* Ordinary insns can follow it if returning a structure.  */\n-\t\t   || GET_CODE (insn) == INSN\n-\t\t   /* If machine uses explicit RETURN insns, no epilogue,\n-\t\t      then one of them follows the note.  */\n-\t\t   || (GET_CODE (insn) == JUMP_INSN\n-\t\t       && GET_CODE (PATTERN (insn)) == RETURN)\n-\t\t   /* A barrier can follow the return insn.  */\n-\t\t   || GET_CODE (insn) == BARRIER\n-\t\t   /* Other kinds of notes can follow also.  */\n-\t\t   || (GET_CODE (insn) == NOTE\n-\t\t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_END)))\n-\t  insn = PREV_INSN (insn);\n-      }\n-\n-      /* Report if control can fall through at the end of the function.  */\n-      if (insn && GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_END\n-\t  && ! INSN_DELETED_P (insn))\n-\tcan_reach_end = 1;\n+      can_reach_end = calculate_can_reach_end (last_insn, 1, 0);\n \n       /* Zero the \"deleted\" flag of all the \"deleted\" insns.  */\n       for (insn = f; insn; insn = NEXT_INSN (insn))\n@@ -333,245 +232,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n #endif\n \n   if (noop_moves)\n-    for (insn = f; insn; )\n-      {\n-\tnext = NEXT_INSN (insn);\n-\n-\tif (GET_CODE (insn) == INSN)\n-\t  {\n-\t    register rtx body = PATTERN (insn);\n-\n-/* Combine stack_adjusts with following push_insns.  */\n-#ifdef PUSH_ROUNDING\n-\t    if (GET_CODE (body) == SET\n-\t\t&& SET_DEST (body) == stack_pointer_rtx\n-\t\t&& GET_CODE (SET_SRC (body)) == PLUS\n-\t\t&& XEXP (SET_SRC (body), 0) == stack_pointer_rtx\n-\t\t&& GET_CODE (XEXP (SET_SRC (body), 1)) == CONST_INT\n-\t\t&& INTVAL (XEXP (SET_SRC (body), 1)) > 0)\n-\t      {\n-\t\trtx p;\n-\t\trtx stack_adjust_insn = insn;\n-\t\tint stack_adjust_amount = INTVAL (XEXP (SET_SRC (body), 1));\n-\t\tint total_pushed = 0;\n-\t\tint pushes = 0;\n-\n-\t\t/* Find all successive push insns.  */\n-\t\tp = insn;\n-\t\t/* Don't convert more than three pushes;\n-\t\t   that starts adding too many displaced addresses\n-\t\t   and the whole thing starts becoming a losing\n-\t\t   proposition.  */\n-\t\twhile (pushes < 3)\n-\t\t  {\n-\t\t    rtx pbody, dest;\n-\t\t    p = next_nonnote_insn (p);\n-\t\t    if (p == 0 || GET_CODE (p) != INSN)\n-\t\t      break;\n-\t\t    pbody = PATTERN (p);\n-\t\t    if (GET_CODE (pbody) != SET)\n-\t\t      break;\n-\t\t    dest = SET_DEST (pbody);\n-\t\t    /* Allow a no-op move between the adjust and the push.  */\n-\t\t    if (GET_CODE (dest) == REG\n-\t\t\t&& GET_CODE (SET_SRC (pbody)) == REG\n-\t\t\t&& REGNO (dest) == REGNO (SET_SRC (pbody)))\n-\t\t      continue;\n-\t\t    if (! (GET_CODE (dest) == MEM\n-\t\t\t   && GET_CODE (XEXP (dest, 0)) == POST_INC\n-\t\t\t   && XEXP (XEXP (dest, 0), 0) == stack_pointer_rtx))\n-\t\t      break;\n-\t\t    pushes++;\n-\t\t    if (total_pushed + GET_MODE_SIZE (GET_MODE (SET_DEST (pbody)))\n-\t\t\t> stack_adjust_amount)\n-\t\t      break;\n-\t\t    total_pushed += GET_MODE_SIZE (GET_MODE (SET_DEST (pbody)));\n-\t\t  }\n-\n-\t\t/* Discard the amount pushed from the stack adjust;\n-\t\t   maybe eliminate it entirely.  */\n-\t\tif (total_pushed >= stack_adjust_amount)\n-\t\t  {\n-\t\t    delete_computation (stack_adjust_insn);\n-\t\t    total_pushed = stack_adjust_amount;\n-\t\t  }\n-\t\telse\n-\t\t  XEXP (SET_SRC (PATTERN (stack_adjust_insn)), 1)\n-\t\t    = GEN_INT (stack_adjust_amount - total_pushed);\n-\n-\t\t/* Change the appropriate push insns to ordinary stores.  */\n-\t\tp = insn;\n-\t\twhile (total_pushed > 0)\n-\t\t  {\n-\t\t    rtx pbody, dest;\n-\t\t    p = next_nonnote_insn (p);\n-\t\t    if (GET_CODE (p) != INSN)\n-\t\t      break;\n-\t\t    pbody = PATTERN (p);\n-\t\t    if (GET_CODE (pbody) != SET)\n-\t\t      break;\n-\t\t    dest = SET_DEST (pbody);\n-\t\t    /* Allow a no-op move between the adjust and the push.  */\n-\t\t    if (GET_CODE (dest) == REG\n-\t\t\t&& GET_CODE (SET_SRC (pbody)) == REG\n-\t\t\t&& REGNO (dest) == REGNO (SET_SRC (pbody)))\n-\t\t      continue;\n-\t\t    if (! (GET_CODE (dest) == MEM\n-\t\t\t   && GET_CODE (XEXP (dest, 0)) == POST_INC\n-\t\t\t   && XEXP (XEXP (dest, 0), 0) == stack_pointer_rtx))\n-\t\t      break;\n-\t\t    total_pushed -= GET_MODE_SIZE (GET_MODE (SET_DEST (pbody)));\n-\t\t    /* If this push doesn't fully fit in the space\n-\t\t       of the stack adjust that we deleted,\n-\t\t       make another stack adjust here for what we\n-\t\t       didn't use up.  There should be peepholes\n-\t\t       to recognize the resulting sequence of insns.  */\n-\t\t    if (total_pushed < 0)\n-\t\t      {\n-\t\t\temit_insn_before (gen_add2_insn (stack_pointer_rtx,\n-\t\t\t\t\t\t\t GEN_INT (- total_pushed)),\n-\t\t\t\t\t  p);\n-\t\t\tbreak;\n-\t\t      }\n-\t\t    XEXP (dest, 0)\n-\t\t      = plus_constant (stack_pointer_rtx, total_pushed);\n-\t\t  }\n-\t      }\n-#endif\n-\n-\t    /* Detect and delete no-op move instructions\n-\t       resulting from not allocating a parameter in a register.  */\n-\n-\t    if (GET_CODE (body) == SET\n-\t\t&& (SET_DEST (body) == SET_SRC (body)\n-\t\t    || (GET_CODE (SET_DEST (body)) == MEM\n-\t\t\t&& GET_CODE (SET_SRC (body)) == MEM\n-\t\t\t&& rtx_equal_p (SET_SRC (body), SET_DEST (body))))\n-\t\t&& ! (GET_CODE (SET_DEST (body)) == MEM\n-\t\t      && MEM_VOLATILE_P (SET_DEST (body)))\n-\t\t&& ! (GET_CODE (SET_SRC (body)) == MEM\n-\t\t      && MEM_VOLATILE_P (SET_SRC (body))))\n-\t      delete_computation (insn);\n-\n-\t    /* Detect and ignore no-op move instructions\n-\t       resulting from smart or fortuitous register allocation.  */\n-\n-\t    else if (GET_CODE (body) == SET)\n-\t      {\n-\t\tint sreg = true_regnum (SET_SRC (body));\n-\t\tint dreg = true_regnum (SET_DEST (body));\n-\n-\t\tif (sreg == dreg && sreg >= 0)\n-\t\t  delete_insn (insn);\n-\t\telse if (sreg >= 0 && dreg >= 0)\n-\t\t  {\n-\t\t    rtx trial;\n-\t\t    rtx tem = find_equiv_reg (NULL_RTX, insn, 0,\n-\t\t\t\t\t      sreg, NULL_PTR, dreg,\n-\t\t\t\t\t      GET_MODE (SET_SRC (body)));\n-\n-\t\t    if (tem != 0\n-\t\t\t&& GET_MODE (tem) == GET_MODE (SET_DEST (body)))\n-\t\t      {\n-\t\t\t/* DREG may have been the target of a REG_DEAD note in\n-\t\t\t   the insn which makes INSN redundant.  If so, reorg\n-\t\t\t   would still think it is dead.  So search for such a\n-\t\t\t   note and delete it if we find it.  */\n-\t\t\tif (! find_regno_note (insn, REG_UNUSED, dreg))\n-\t\t\t  for (trial = prev_nonnote_insn (insn);\n-\t\t\t       trial && GET_CODE (trial) != CODE_LABEL;\n-\t\t\t       trial = prev_nonnote_insn (trial))\n-\t\t\t    if (find_regno_note (trial, REG_DEAD, dreg))\n-\t\t\t      {\n-\t\t\t\tremove_death (dreg, trial);\n-\t\t\t\tbreak;\n-\t\t\t      }\n-\n-\t\t\t/* Deleting insn could lose a death-note for SREG.  */\n-\t\t\tif ((trial = find_regno_note (insn, REG_DEAD, sreg)))\n-\t\t\t  {\n-\t\t\t    /* Change this into a USE so that we won't emit\n-\t\t\t       code for it, but still can keep the note.  */\n-\t\t\t    PATTERN (insn)\n-\t\t\t      = gen_rtx_USE (VOIDmode, XEXP (trial, 0));\n-\t\t\t    INSN_CODE (insn) = -1;\n-\t\t\t    /* Remove all reg notes but the REG_DEAD one.  */\n-\t\t\t    REG_NOTES (insn) = trial;\n-\t\t\t    XEXP (trial, 1) = NULL_RTX;\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  delete_insn (insn);\n-\t\t      }\n-\t\t  }\n-\t\telse if (dreg >= 0 && CONSTANT_P (SET_SRC (body))\n-\t\t\t && find_equiv_reg (SET_SRC (body), insn, 0, dreg,\n-\t\t\t\t\t    NULL_PTR, 0,\n-\t\t\t\t\t    GET_MODE (SET_DEST (body))))\n-\t\t  {\n-\t\t    /* This handles the case where we have two consecutive\n-\t\t       assignments of the same constant to pseudos that didn't\n-\t\t       get a hard reg.  Each SET from the constant will be\n-\t\t       converted into a SET of the spill register and an\n-\t\t       output reload will be made following it.  This produces\n-\t\t       two loads of the same constant into the same spill\n-\t\t       register.  */\n-\n-\t\t    rtx in_insn = insn;\n-\n-\t\t    /* Look back for a death note for the first reg.\n-\t\t       If there is one, it is no longer accurate.  */\n-\t\t    while (in_insn && GET_CODE (in_insn) != CODE_LABEL)\n-\t\t      {\n-\t\t\tif ((GET_CODE (in_insn) == INSN\n-\t\t\t     || GET_CODE (in_insn) == JUMP_INSN)\n-\t\t\t    && find_regno_note (in_insn, REG_DEAD, dreg))\n-\t\t\t  {\n-\t\t\t    remove_death (dreg, in_insn);\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t\tin_insn = PREV_INSN (in_insn);\n-\t\t      }\n-\n-\t\t    /* Delete the second load of the value.  */\n-\t\t    delete_insn (insn);\n-\t\t  }\n-\t      }\n-\t    else if (GET_CODE (body) == PARALLEL)\n-\t      {\n-\t\t/* If each part is a set between two identical registers or\n-\t\t   a USE or CLOBBER, delete the insn.  */\n-\t\tint i, sreg, dreg;\n-\t\trtx tem;\n-\n-\t\tfor (i = XVECLEN (body, 0) - 1; i >= 0; i--)\n-\t\t  {\n-\t\t    tem = XVECEXP (body, 0, i);\n-\t\t    if (GET_CODE (tem) == USE || GET_CODE (tem) == CLOBBER)\n-\t\t      continue;\n-\n-\t\t    if (GET_CODE (tem) != SET\n-\t\t    \t|| (sreg = true_regnum (SET_SRC (tem))) < 0\n-\t\t    \t|| (dreg = true_regnum (SET_DEST (tem))) < 0\n-\t\t    \t|| dreg != sreg)\n-\t\t      break;\n-\t\t  }\n-\t\t  \n-\t\tif (i < 0)\n-\t\t  delete_insn (insn);\n-\t      }\n-\t    /* Also delete insns to store bit fields if they are no-ops.  */\n-\t    /* Not worth the hair to detect this in the big-endian case.  */\n-\t    else if (! BYTES_BIG_ENDIAN\n-\t\t     && GET_CODE (body) == SET\n-\t\t     && GET_CODE (SET_DEST (body)) == ZERO_EXTRACT\n-\t\t     && XEXP (SET_DEST (body), 2) == const0_rtx\n-\t\t     && XEXP (SET_DEST (body), 0) == SET_SRC (body)\n-\t\t     && ! (GET_CODE (SET_SRC (body)) == MEM\n-\t\t\t   && MEM_VOLATILE_P (SET_SRC (body))))\n-\t      delete_insn (insn);\n-\t  }\n-      insn = next;\n-    }\n+    delete_noop_moves (f);\n \n   /* If we haven't yet gotten to reload and we have just run regscan,\n      delete any insn that sets a register that isn't used elsewhere.\n@@ -2371,41 +2032,450 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n     }\n #endif\n \n-  /* See if there is still a NOTE_INSN_FUNCTION_END in this function.\n-     If so, delete it, and record that this function can drop off the end.  */\n+  can_reach_end = calculate_can_reach_end (last_insn, 0, 1);\n+\n+  /* Show JUMP_CHAIN no longer valid.  */\n+  jump_chain = 0;\n+}\n+\f\n+/* Initialize LABEL_NUSES and JUMP_LABEL fields.  Delete any REG_LABEL\n+   notes whose labels don't occur in the insn any more.  Returns the\n+   largest INSN_UID found.  */\n+static int\n+init_label_info (f)\n+     rtx f;\n+{\n+  int largest_uid = 0;\n+  rtx insn;\n+\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\tLABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n+      else if (GET_CODE (insn) == JUMP_INSN)\n+\tJUMP_LABEL (insn) = 0;\n+      else if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  rtx note, next;\n+\n+\t  for (note = REG_NOTES (insn); note; note = next)\n+\t    {\n+\t      next = XEXP (note, 1);\n+\t      if (REG_NOTE_KIND (note) == REG_LABEL\n+\t\t  && ! reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n+\t\tremove_note (insn, note);\n+\t    }\n+\t}\n+      if (INSN_UID (insn) > largest_uid)\n+\tlargest_uid = INSN_UID (insn);\n+    }\n+\n+  return largest_uid;\n+}\n+\n+/* Delete insns following barriers, up to next label.  */\n+static void\n+delete_barrier_successors (f)\n+     rtx f;\n+{\n+  rtx insn;\n+\n+  for (insn = f; insn;)\n+    {\n+      if (GET_CODE (insn) == BARRIER)\n+\t{\n+\t  insn = NEXT_INSN (insn);\n+\t  while (insn != 0 && GET_CODE (insn) != CODE_LABEL)\n+\t    {\n+\t      if (GET_CODE (insn) == NOTE\n+\t\t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_END)\n+\t\tinsn = NEXT_INSN (insn);\n+\t      else\n+\t\tinsn = delete_insn (insn);\n+\t    }\n+\t  /* INSN is now the code_label.  */\n+\t}\n+      else\n+\tinsn = NEXT_INSN (insn);\n+    }\n+}\n+\n+/* Mark the label each jump jumps to.\n+   Combine consecutive labels, and count uses of labels.\n+\n+   For each label, make a chain (using `jump_chain')\n+   of all the *unconditional* jumps that jump to it;\n+   also make a chain of all returns.\n+\n+   CROSS_JUMP indicates whether we are doing cross jumping\n+   and if we are whether we will be paying attention to\n+   death notes or not.  */\n+\n+static void\n+mark_all_labels (f, cross_jump)\n+     rtx f;\n+     int cross_jump;\n+{\n+  rtx insn;\n+\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+      {\n+\tmark_jump_label (PATTERN (insn), insn, cross_jump);\n+\tif (! INSN_DELETED_P (insn) && GET_CODE (insn) == JUMP_INSN)\n+\t  {\n+\t    if (JUMP_LABEL (insn) != 0 && simplejump_p (insn))\n+\t      {\n+\t\tjump_chain[INSN_UID (insn)]\n+\t\t  = jump_chain[INSN_UID (JUMP_LABEL (insn))];\n+\t\tjump_chain[INSN_UID (JUMP_LABEL (insn))] = insn;\n+\t      }\n+\t    if (GET_CODE (PATTERN (insn)) == RETURN)\n+\t      {\n+\t\tjump_chain[INSN_UID (insn)] = jump_chain[0];\n+\t\tjump_chain[0] = insn;\n+\t      }\n+\t  }\n+      }\n+}\n+\n+/* Delete all labels already not referenced.\n+   Also find and return the last insn.  */\n+\n+static rtx\n+delete_unreferenced_labels (f)\n+     rtx f;\n+{\n+  rtx final = NULL_RTX;\n+  rtx insn;\n+\n+  for (insn = f; insn; )\n+    {\n+      if (GET_CODE (insn) == CODE_LABEL && LABEL_NUSES (insn) == 0)\n+\tinsn = delete_insn (insn);\n+      else\n+\t{\n+\t  final = insn;\n+\t  insn = NEXT_INSN (insn);\n+\t}\n+    }\n+\n+  return final;\n+}\n+\n+/* Delete various simple forms of moves which have no necessary\n+   side effect.  */\n+\n+static void\n+delete_noop_moves (f)\n+     rtx f;\n+{\n+  rtx insn, next;\n+\n+  for (insn = f; insn; )\n+    {\n+      next = NEXT_INSN (insn);\n+\n+      if (GET_CODE (insn) == INSN)\n+\t{\n+\t  register rtx body = PATTERN (insn);\n+\n+/* Combine stack_adjusts with following push_insns.  */\n+#ifdef PUSH_ROUNDING\n+\t  if (GET_CODE (body) == SET\n+\t      && SET_DEST (body) == stack_pointer_rtx\n+\t      && GET_CODE (SET_SRC (body)) == PLUS\n+\t      && XEXP (SET_SRC (body), 0) == stack_pointer_rtx\n+\t      && GET_CODE (XEXP (SET_SRC (body), 1)) == CONST_INT\n+\t      && INTVAL (XEXP (SET_SRC (body), 1)) > 0)\n+\t    {\n+\t      rtx p;\n+\t      rtx stack_adjust_insn = insn;\n+\t      int stack_adjust_amount = INTVAL (XEXP (SET_SRC (body), 1));\n+\t      int total_pushed = 0;\n+\t      int pushes = 0;\n+\n+\t      /* Find all successive push insns.  */\n+\t      p = insn;\n+\t      /* Don't convert more than three pushes;\n+\t\t that starts adding too many displaced addresses\n+\t\t and the whole thing starts becoming a losing\n+\t\t proposition.  */\n+\t      while (pushes < 3)\n+\t\t{\n+\t\t  rtx pbody, dest;\n+\t\t  p = next_nonnote_insn (p);\n+\t\t  if (p == 0 || GET_CODE (p) != INSN)\n+\t\t    break;\n+\t\t  pbody = PATTERN (p);\n+\t\t  if (GET_CODE (pbody) != SET)\n+\t\t    break;\n+\t\t  dest = SET_DEST (pbody);\n+\t\t  /* Allow a no-op move between the adjust and the push.  */\n+\t\t  if (GET_CODE (dest) == REG\n+\t\t      && GET_CODE (SET_SRC (pbody)) == REG\n+\t\t      && REGNO (dest) == REGNO (SET_SRC (pbody)))\n+\t\t    continue;\n+\t\t  if (! (GET_CODE (dest) == MEM\n+\t\t\t && GET_CODE (XEXP (dest, 0)) == POST_INC\n+\t\t\t && XEXP (XEXP (dest, 0), 0) == stack_pointer_rtx))\n+\t\t    break;\n+\t\t  pushes++;\n+\t\t  if (total_pushed + GET_MODE_SIZE (GET_MODE (SET_DEST (pbody)))\n+\t\t      > stack_adjust_amount)\n+\t\t    break;\n+\t\t  total_pushed += GET_MODE_SIZE (GET_MODE (SET_DEST (pbody)));\n+\t\t}\n+\n+\t      /* Discard the amount pushed from the stack adjust;\n+\t\t maybe eliminate it entirely.  */\n+\t      if (total_pushed >= stack_adjust_amount)\n+\t\t{\n+\t\t  delete_computation (stack_adjust_insn);\n+\t\t  total_pushed = stack_adjust_amount;\n+\t\t}\n+\t      else\n+\t\tXEXP (SET_SRC (PATTERN (stack_adjust_insn)), 1)\n+\t\t  = GEN_INT (stack_adjust_amount - total_pushed);\n+\n+\t      /* Change the appropriate push insns to ordinary stores.  */\n+\t      p = insn;\n+\t      while (total_pushed > 0)\n+\t\t{\n+\t\t  rtx pbody, dest;\n+\t\t  p = next_nonnote_insn (p);\n+\t\t  if (GET_CODE (p) != INSN)\n+\t\t    break;\n+\t\t  pbody = PATTERN (p);\n+\t\t  if (GET_CODE (pbody) != SET)\n+\t\t    break;\n+\t\t  dest = SET_DEST (pbody);\n+\t\t  /* Allow a no-op move between the adjust and the push.  */\n+\t\t  if (GET_CODE (dest) == REG\n+\t\t      && GET_CODE (SET_SRC (pbody)) == REG\n+\t\t      && REGNO (dest) == REGNO (SET_SRC (pbody)))\n+\t\t    continue;\n+\t\t  if (! (GET_CODE (dest) == MEM\n+\t\t\t && GET_CODE (XEXP (dest, 0)) == POST_INC\n+\t\t\t && XEXP (XEXP (dest, 0), 0) == stack_pointer_rtx))\n+\t\t    break;\n+\t\t  total_pushed -= GET_MODE_SIZE (GET_MODE (SET_DEST (pbody)));\n+\t\t  /* If this push doesn't fully fit in the space\n+\t\t     of the stack adjust that we deleted,\n+\t\t     make another stack adjust here for what we\n+\t\t     didn't use up.  There should be peepholes\n+\t\t     to recognize the resulting sequence of insns.  */\n+\t\t  if (total_pushed < 0)\n+\t\t    {\n+\t\t      emit_insn_before (gen_add2_insn (stack_pointer_rtx,\n+\t\t\t\t\t\t       GEN_INT (- total_pushed)),\n+\t\t\t\t\tp);\n+\t\t      break;\n+\t\t    }\n+\t\t  XEXP (dest, 0)\n+\t\t    = plus_constant (stack_pointer_rtx, total_pushed);\n+\t\t}\n+\t    }\n+#endif\n+\n+\t  /* Detect and delete no-op move instructions\n+\t     resulting from not allocating a parameter in a register.  */\n+\n+\t  if (GET_CODE (body) == SET\n+\t      && (SET_DEST (body) == SET_SRC (body)\n+\t\t  || (GET_CODE (SET_DEST (body)) == MEM\n+\t\t      && GET_CODE (SET_SRC (body)) == MEM\n+\t\t      && rtx_equal_p (SET_SRC (body), SET_DEST (body))))\n+\t      && ! (GET_CODE (SET_DEST (body)) == MEM\n+\t\t    && MEM_VOLATILE_P (SET_DEST (body)))\n+\t      && ! (GET_CODE (SET_SRC (body)) == MEM\n+\t\t    && MEM_VOLATILE_P (SET_SRC (body))))\n+\t    delete_computation (insn);\n+\n+\t  /* Detect and ignore no-op move instructions\n+\t     resulting from smart or fortuitous register allocation.  */\n+\n+\t  else if (GET_CODE (body) == SET)\n+\t    {\n+\t      int sreg = true_regnum (SET_SRC (body));\n+\t      int dreg = true_regnum (SET_DEST (body));\n+\n+\t      if (sreg == dreg && sreg >= 0)\n+\t\tdelete_insn (insn);\n+\t      else if (sreg >= 0 && dreg >= 0)\n+\t\t{\n+\t\t  rtx trial;\n+\t\t  rtx tem = find_equiv_reg (NULL_RTX, insn, 0,\n+\t\t\t\t\t    sreg, NULL_PTR, dreg,\n+\t\t\t\t\t    GET_MODE (SET_SRC (body)));\n+\n+\t\t  if (tem != 0\n+\t\t      && GET_MODE (tem) == GET_MODE (SET_DEST (body)))\n+\t\t    {\n+\t\t      /* DREG may have been the target of a REG_DEAD note in\n+\t\t\t the insn which makes INSN redundant.  If so, reorg\n+\t\t\t would still think it is dead.  So search for such a\n+\t\t\t note and delete it if we find it.  */\n+\t\t      if (! find_regno_note (insn, REG_UNUSED, dreg))\n+\t\t\tfor (trial = prev_nonnote_insn (insn);\n+\t\t\t     trial && GET_CODE (trial) != CODE_LABEL;\n+\t\t\t     trial = prev_nonnote_insn (trial))\n+\t\t\t  if (find_regno_note (trial, REG_DEAD, dreg))\n+\t\t\t    {\n+\t\t\t      remove_death (dreg, trial);\n+\t\t\t      break;\n+\t\t\t    }\n+\n+\t\t      /* Deleting insn could lose a death-note for SREG.  */\n+\t\t      if ((trial = find_regno_note (insn, REG_DEAD, sreg)))\n+\t\t\t{\n+\t\t\t  /* Change this into a USE so that we won't emit\n+\t\t\t     code for it, but still can keep the note.  */\n+\t\t\t  PATTERN (insn)\n+\t\t\t    = gen_rtx_USE (VOIDmode, XEXP (trial, 0));\n+\t\t\t  INSN_CODE (insn) = -1;\n+\t\t\t  /* Remove all reg notes but the REG_DEAD one.  */\n+\t\t\t  REG_NOTES (insn) = trial;\n+\t\t\t  XEXP (trial, 1) = NULL_RTX;\n+\t\t\t}\n+\t\t      else\n+\t\t\tdelete_insn (insn);\n+\t\t    }\n+\t\t}\n+\t      else if (dreg >= 0 && CONSTANT_P (SET_SRC (body))\n+\t\t       && find_equiv_reg (SET_SRC (body), insn, 0, dreg,\n+\t\t\t\t\t  NULL_PTR, 0,\n+\t\t\t\t\t  GET_MODE (SET_DEST (body))))\n+\t\t{\n+\t\t  /* This handles the case where we have two consecutive\n+\t\t     assignments of the same constant to pseudos that didn't\n+\t\t     get a hard reg.  Each SET from the constant will be\n+\t\t     converted into a SET of the spill register and an\n+\t\t     output reload will be made following it.  This produces\n+\t\t     two loads of the same constant into the same spill\n+\t\t     register.  */\n+\n+\t\t  rtx in_insn = insn;\n+\n+\t\t  /* Look back for a death note for the first reg.\n+\t\t     If there is one, it is no longer accurate.  */\n+\t\t  while (in_insn && GET_CODE (in_insn) != CODE_LABEL)\n+\t\t    {\n+\t\t      if ((GET_CODE (in_insn) == INSN\n+\t\t\t   || GET_CODE (in_insn) == JUMP_INSN)\n+\t\t\t  && find_regno_note (in_insn, REG_DEAD, dreg))\n+\t\t\t{\n+\t\t\t  remove_death (dreg, in_insn);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      in_insn = PREV_INSN (in_insn);\n+\t\t    }\n+\n+\t\t  /* Delete the second load of the value.  */\n+\t\t  delete_insn (insn);\n+\t\t}\n+\t    }\n+\t  else if (GET_CODE (body) == PARALLEL)\n+\t    {\n+\t      /* If each part is a set between two identical registers or\n+\t\t a USE or CLOBBER, delete the insn.  */\n+\t      int i, sreg, dreg;\n+\t      rtx tem;\n+\n+\t      for (i = XVECLEN (body, 0) - 1; i >= 0; i--)\n+\t\t{\n+\t\t  tem = XVECEXP (body, 0, i);\n+\t\t  if (GET_CODE (tem) == USE || GET_CODE (tem) == CLOBBER)\n+\t\t    continue;\n+\n+\t\t  if (GET_CODE (tem) != SET\n+\t\t      || (sreg = true_regnum (SET_SRC (tem))) < 0\n+\t\t      || (dreg = true_regnum (SET_DEST (tem))) < 0\n+\t\t      || dreg != sreg)\n+\t\t    break;\n+\t\t}\n+\t\t  \n+\t      if (i < 0)\n+\t\tdelete_insn (insn);\n+\t    }\n+\t  /* Also delete insns to store bit fields if they are no-ops.  */\n+\t  /* Not worth the hair to detect this in the big-endian case.  */\n+\t  else if (! BYTES_BIG_ENDIAN\n+\t\t   && GET_CODE (body) == SET\n+\t\t   && GET_CODE (SET_DEST (body)) == ZERO_EXTRACT\n+\t\t   && XEXP (SET_DEST (body), 2) == const0_rtx\n+\t\t   && XEXP (SET_DEST (body), 0) == SET_SRC (body)\n+\t\t   && ! (GET_CODE (SET_SRC (body)) == MEM\n+\t\t\t && MEM_VOLATILE_P (SET_SRC (body))))\n+\t    delete_insn (insn);\n+\t}\n+      insn = next;\n+    }\n+}\n+\n+/* See if there is still a NOTE_INSN_FUNCTION_END in this function.\n+   If so indicate that this function can drop off the end by returning\n+   1, else return 0.\n+\n+   CHECK_DELETED indicates whether we must check if the note being\n+   searched for has the deleted flag set.\n+\n+   DELETE_FINAL_NOTE indicates whether we should delete the note\n+   if we find it.  */\n+\n+static int\n+calculate_can_reach_end (last, check_deleted, delete_final_note)\n+     rtx last;\n+     int check_deleted;\n+     int delete_final_note;\n+{\n+  rtx insn = last;\n+  int n_labels = 1;\n+\n+  while (insn != NULL_RTX)\n+    {\n+      int ok = 0;\n+\n+      /* One label can follow the end-note: the return label.  */\n+      if (GET_CODE (insn) == CODE_LABEL && n_labels-- > 0)\n+\tok = 1;\n+      /* Ordinary insns can follow it if returning a structure.  */\n+      else if (GET_CODE (insn) == INSN)\n+\tok = 1;\n+      /* If machine uses explicit RETURN insns, no epilogue,\n+\t then one of them follows the note.  */\n+      else if (GET_CODE (insn) == JUMP_INSN\n+\t       && GET_CODE (PATTERN (insn)) == RETURN)\n+\tok = 1;\n+      /* A barrier can follow the return insn.  */\n+      else if (GET_CODE (insn) == BARRIER)\n+\tok = 1;\n+      /* Other kinds of notes can follow also.  */\n+      else if (GET_CODE (insn) == NOTE\n+\t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_END)\n+\tok = 1;\n+\n+      if (ok != 1)\n+\tbreak;\n \n-  insn = last_insn;\n-  {\n-    int n_labels = 1;\n-    while (insn\n-\t   /* One label can follow the end-note: the return label.  */\n-\t   && ((GET_CODE (insn) == CODE_LABEL && n_labels-- > 0)\n-\t       /* Ordinary insns can follow it if returning a structure.  */\n-\t       || GET_CODE (insn) == INSN\n-\t       /* If machine uses explicit RETURN insns, no epilogue,\n-\t\t  then one of them follows the note.  */\n-\t       || (GET_CODE (insn) == JUMP_INSN\n-\t\t   && GET_CODE (PATTERN (insn)) == RETURN)\n-\t       /* A barrier can follow the return insn.  */\n-\t       || GET_CODE (insn) == BARRIER\n-\t       /* Other kinds of notes can follow also.  */\n-\t       || (GET_CODE (insn) == NOTE\n-\t\t   && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_END)))\n       insn = PREV_INSN (insn);\n-  }\n+    }\n \n-  /* Report if control can fall through at the end of the function.  */\n-  if (insn && GET_CODE (insn) == NOTE\n-      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_END)\n+  /* See if we backed up to the appropriate type of note.  */\n+  if (insn != NULL_RTX\n+      && GET_CODE (insn) == NOTE\n+      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_END\n+      && (check_deleted != 0\n+\t  && ! INSN_DELETED_P (insn)))\n     {\n-      can_reach_end = 1;\n-      delete_insn (insn);\n+      if (delete_final_note)\n+\tdelete_insn (insn);\n+      return 1;\n     }\n \n-  /* Show JUMP_CHAIN no longer valid.  */\n-  jump_chain = 0;\n+  return 0;\n }\n-\f\n+\n /* LOOP_START is a NOTE_INSN_LOOP_BEG note that is followed by an unconditional\n    jump.  Assume that this unconditional jump is to the exit test code.  If\n    the code is sufficiently simple, make a copy of it before INSN,"}]}