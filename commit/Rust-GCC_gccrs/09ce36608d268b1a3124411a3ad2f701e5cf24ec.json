{"sha": "09ce36608d268b1a3124411a3ad2f701e5cf24ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDljZTM2NjA4ZDI2OGIxYTMxMjQ0MTFhM2FkMmY3MDFlNWNmMjRlYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-13T12:21:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-13T12:21:16Z"}, "message": "cgraph.c (cgraph_turn_edge_to_speculative): Return newly introduced edge; fix typo in sanity check.\n\n\n\t* cgraph.c (cgraph_turn_edge_to_speculative): Return newly\n\tintroduced edge; fix typo in sanity check.\n\t(cgraph_resolve_speculation): Export; improve diagnostic.\n\t(cgraph_redirect_edge_call_stmt_to_callee): Better diagnostic; cancel\n\tspeculation at type mismatch.\n\t* cgraph.h (cgraph_turn_edge_to_speculative): Update.\n\t(cgraph_resolve_speculation): Declare.\n\t(symtab_can_be_discarded): New function.\n\t* value-prof.c (gimple_ic_transform): Remove actual transform code.\n\t* ipa-inline-transform.c (speculation_removed): New global var.\n\t(clone_inlined_nodes): See if speculation can be removed.\n\t(inline_call): If speculations was removed, we growths may not match.\n\t* ipa-inline.c (can_inline_edge_p): Add DISREGARD_LIMITS parameter.\n\t(speculation_useful_p): New function.\n\t(resolve_noninline_speculation): New function.\n\t(inline_small_functions): Resolve useless speculations.\n\t* ipa-inline.h (speculation_useful_p): Declare\n\t* ipa.c (can_replace_by_local_alias): Simplify.\n\t(ipa_profile): Produce speculative calls in non-lto, too;\n\tadd simple cost model; produce local aliases.\n\nFrom-SVN: r201683", "tree": {"sha": "e903dc537f27c5dd690cb3a98029321225e8f7b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e903dc537f27c5dd690cb3a98029321225e8f7b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09ce36608d268b1a3124411a3ad2f701e5cf24ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09ce36608d268b1a3124411a3ad2f701e5cf24ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09ce36608d268b1a3124411a3ad2f701e5cf24ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09ce36608d268b1a3124411a3ad2f701e5cf24ec/comments", "author": null, "committer": null, "parents": [{"sha": "537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/537e035c48955b3ea88dcb3a4b0ff03ef4bb2e31"}], "stats": {"total": 552, "additions": 401, "deletions": 151}, "files": [{"sha": "508a14a943883c46770bfd0eae93fb0716666e2d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09ce36608d268b1a3124411a3ad2f701e5cf24ec", "patch": "@@ -1,3 +1,26 @@\n+2013-08-13  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_turn_edge_to_speculative): Return newly\n+\tintroduced edge; fix typo in sanity check.\n+\t(cgraph_resolve_speculation): Export; improve diagnostic.\n+\t(cgraph_redirect_edge_call_stmt_to_callee): Better diagnostic; cancel\n+\tspeculation at type mismatch.\n+\t* cgraph.h (cgraph_turn_edge_to_speculative): Update.\n+\t(cgraph_resolve_speculation): Declare.\n+\t(symtab_can_be_discarded): New function.\n+\t* value-prof.c (gimple_ic_transform): Remove actual transform code.\n+\t* ipa-inline-transform.c (speculation_removed): New global var.\n+\t(clone_inlined_nodes): See if speculation can be removed.\n+\t(inline_call): If speculations was removed, we growths may not match.\n+\t* ipa-inline.c (can_inline_edge_p): Add DISREGARD_LIMITS parameter.\n+\t(speculation_useful_p): New function.\n+\t(resolve_noninline_speculation): New function.\n+\t(inline_small_functions): Resolve useless speculations.\n+\t* ipa-inline.h (speculation_useful_p): Declare\n+\t* ipa.c (can_replace_by_local_alias): Simplify.\n+\t(ipa_profile): Produce speculative calls in non-lto, too;\n+\tadd simple cost model; produce local aliases.\n+\n 2013-08-13  David Malcolm  <dmalcolm@redhat.com>\n \n \t* config/i386/t-i386 (i386.o): Rename stray PIPELINE_H to"}, {"sha": "a939ae834848571941c3160c50292ae36e99afaf", "filename": "gcc/cgraph.c", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=09ce36608d268b1a3124411a3ad2f701e5cf24ec", "patch": "@@ -1040,9 +1040,11 @@ cgraph_set_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n \n    At this time the function just creates the direct call,\n    the referencd representing the if conditional and attaches\n-   them all to the orginal indirect call statement.  */\n+   them all to the orginal indirect call statement.  \n \n-void\n+   Return direct edge created.  */\n+\n+struct cgraph_edge *\n cgraph_turn_edge_to_speculative (struct cgraph_edge *e,\n \t\t\t\t struct cgraph_node *n2,\n \t\t\t\t gcov_type direct_count,\n@@ -1073,6 +1075,7 @@ cgraph_turn_edge_to_speculative (struct cgraph_edge *e,\n \t\t\t      IPA_REF_ADDR, e->call_stmt);\n   ref->lto_stmt_uid = e->lto_stmt_uid;\n   ref->speculative = e->speculative;\n+  return e2;\n }\n \n /* Speculative call consist of three components:\n@@ -1107,7 +1110,7 @@ cgraph_speculative_call_info (struct cgraph_edge *e,\n       if (e2->call_stmt)\n \t{\n \t  e = cgraph_edge (e->caller, e2->call_stmt);\n-\t  gcc_assert (!e->speculative && !e->indirect_unknown_callee);\n+\t  gcc_assert (e->speculative && !e->indirect_unknown_callee);\n \t}\n       else\n \tfor (e = e->caller->callees; \n@@ -1147,7 +1150,7 @@ cgraph_redirect_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n    Remove the speculative call sequence and return edge representing the call.\n    It is up to caller to redirect the call as appropriate. */\n \n-static struct cgraph_edge *\n+struct cgraph_edge *\n cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n {\n   struct cgraph_edge *e2;\n@@ -1159,12 +1162,21 @@ cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n     {\n       if (dump_file)\n \t{\n-\t  fprintf (dump_file, \"Speculative indirect call %s/%i => %s/%i has \"\n-\t\t   \"turned out to have contradicitng known target \",\n-\t\t   xstrdup (cgraph_node_name (edge->caller)), edge->caller->symbol.order,\n-\t\t   xstrdup (cgraph_node_name (e2->callee)), e2->callee->symbol.order);\n-\t  print_generic_expr (dump_file, callee_decl, 0);\n-          fprintf (dump_file, \"\\n\");\n+\t  if (callee_decl)\n+\t    {\n+\t      fprintf (dump_file, \"Speculative indirect call %s/%i => %s/%i has \"\n+\t\t       \"turned out to have contradicting known target \",\n+\t\t       xstrdup (cgraph_node_name (edge->caller)), edge->caller->symbol.order,\n+\t\t       xstrdup (cgraph_node_name (e2->callee)), e2->callee->symbol.order);\n+\t      print_generic_expr (dump_file, callee_decl, 0);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  else\n+\t    {\n+\t      fprintf (dump_file, \"Removing speculative call %s/%i => %s/%i\\n\",\n+\t\t       xstrdup (cgraph_node_name (edge->caller)), edge->caller->symbol.order,\n+\t\t       xstrdup (cgraph_node_name (e2->callee)), e2->callee->symbol.order);\n+\t    }\n \t}\n     }\n   else\n@@ -1264,12 +1276,24 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n       cgraph_speculative_call_info (e, e, e2, ref);\n       if (gimple_call_fndecl (e->call_stmt))\n \te = cgraph_resolve_speculation (e, gimple_call_fndecl (e->call_stmt));\n-      else\n+      if (!gimple_check_call_matching_types (e->call_stmt, e->callee->symbol.decl,\n+\t\t\t\t\t     true))\n \t{\n+\t  e = cgraph_resolve_speculation (e, NULL);\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"Expanding speculative call of %s/%i -> %s/%i\\n\",\n+\t    fprintf (dump_file, \"Not expanding speculative call of %s/%i -> %s/%i\\n\"\n+\t\t     \"Type mismatch.\\n\",\n \t\t     xstrdup (cgraph_node_name (e->caller)), e->caller->symbol.order,\n \t\t     xstrdup (cgraph_node_name (e->callee)), e->callee->symbol.order);\n+\t}\n+      else\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Expanding speculative call of %s/%i -> %s/%i count:\"\n+\t\t     HOST_WIDEST_INT_PRINT_DEC\"\\n\",\n+\t\t     xstrdup (cgraph_node_name (e->caller)), e->caller->symbol.order,\n+\t\t     xstrdup (cgraph_node_name (e->callee)), e->callee->symbol.order,\n+\t\t     (HOST_WIDEST_INT)e->count);\n \t  gcc_assert (e2->speculative);\n \t  push_cfun (DECL_STRUCT_FUNCTION (e->caller->symbol.decl));\n \t  new_stmt = gimple_ic (e->call_stmt, cgraph (ref->referred),"}, {"sha": "6c25bf283f9de1de349575111d3ab8d87d1f448b", "filename": "gcc/cgraph.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=09ce36608d268b1a3124411a3ad2f701e5cf24ec", "patch": "@@ -726,7 +726,7 @@ bool cgraph_propagate_frequency (struct cgraph_node *node);\n struct cgraph_node * cgraph_function_node (struct cgraph_node *,\n \t\t\t\t\t   enum availability *avail = NULL);\n bool cgraph_get_body (struct cgraph_node *node);\n-void\n+struct cgraph_edge *\n cgraph_turn_edge_to_speculative (struct cgraph_edge *,\n \t\t\t\t struct cgraph_node *,\n \t\t\t\t gcov_type, int);\n@@ -783,6 +783,7 @@ struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n \t\t\t\t\t\tbasic_block, const char *);\n void tree_function_versioning (tree, tree, vec<ipa_replace_map_p, va_gc> *,\n \t\t\t       bool, bitmap, bool, bitmap, basic_block);\n+struct cgraph_edge *cgraph_resolve_speculation (struct cgraph_edge *, tree);\n \n /* In cgraphbuild.c  */\n unsigned int rebuild_cgraph_edges (void);\n@@ -1398,4 +1399,16 @@ symtab_real_symbol_p (symtab_node node)\n     return false;\n   return true;\n }\n+\n+/* Return true if NODE can be discarded by linker from the binary.  */\n+\n+static inline bool\n+symtab_can_be_discarded (symtab_node node)\n+{\n+  return (DECL_EXTERNAL (node->symbol.decl)\n+\t  || (DECL_ONE_ONLY (node->symbol.decl)\n+\t      && node->symbol.resolution != LDPR_PREVAILING_DEF\n+\t      && node->symbol.resolution != LDPR_PREVAILING_DEF_IRONLY\n+\t      && node->symbol.resolution != LDPR_PREVAILING_DEF_IRONLY_EXP));\n+}\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "8ead336de64ef8b5ef7f10ff6baec82c877e9f8c", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=09ce36608d268b1a3124411a3ad2f701e5cf24ec", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n \n int ncalls_inlined;\n int nfunctions_inlined;\n+bool speculation_removed;\n \n /* Scale frequency of NODE edges by FREQ_SCALE.  */\n \n@@ -134,6 +135,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t\t     bool update_original, int *overall_size)\n {\n   struct cgraph_node *inlining_into;\n+  struct cgraph_edge *next;\n \n   if (e->caller->global.inlined_to)\n     inlining_into = e->caller->global.inlined_to;\n@@ -186,9 +188,17 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n   e->callee->global.inlined_to = inlining_into;\n \n   /* Recursively clone all bodies.  */\n-  for (e = e->callee->callees; e; e = e->next_callee)\n-    if (!e->inline_failed)\n-      clone_inlined_nodes (e, duplicate, update_original, overall_size);\n+  for (e = e->callee->callees; e; e = next)\n+    {\n+      next = e->next_callee;\n+      if (!e->inline_failed)\n+        clone_inlined_nodes (e, duplicate, update_original, overall_size);\n+      if (e->speculative && !speculation_useful_p (e, true))\n+\t{\n+\t  cgraph_resolve_speculation (e, NULL);\n+\t  speculation_removed = true;\n+\t}\n+    }\n }\n \n \n@@ -218,6 +228,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   bool predicated = inline_edge_summary (e)->predicate != NULL;\n #endif\n \n+  speculation_removed = false;\n   /* Don't inline inlined edges.  */\n   gcc_assert (e->inline_failed);\n   /* Don't even think of inlining inline clone.  */\n@@ -267,6 +278,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n      error due to INLINE_SIZE_SCALE roudoff errors.  */\n   gcc_assert (!update_overall_summary || !overall_size || new_edges_found\n \t      || abs (estimated_growth - (new_size - old_size)) <= 1\n+\t      || speculation_removed\n \t      /* FIXME: a hack.  Edges with false predicate are accounted\n \t\t wrong, we should remove them from callgraph.  */\n \t      || predicated);"}, {"sha": "a9eb1ad75a6487cb059013abd93d8e484e964488", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 191, "deletions": 64, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=09ce36608d268b1a3124411a3ad2f701e5cf24ec", "patch": "@@ -229,10 +229,13 @@ report_inline_failed_reason (struct cgraph_edge *e)\n    We check whether inlining is possible at all and whether\n    caller growth limits allow doing so.  \n \n-   if REPORT is true, output reason to the dump file.  */\n+   if REPORT is true, output reason to the dump file.  \n+\n+   if DISREGARD_LIMITES is true, ignore size limits.*/\n \n static bool\n-can_inline_edge_p (struct cgraph_edge *e, bool report)\n+can_inline_edge_p (struct cgraph_edge *e, bool report,\n+\t\t   bool disregard_limits = false)\n {\n   bool inlinable = true;\n   enum availability avail;\n@@ -309,6 +312,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n     }\n   /* Check if caller growth allows the inlining.  */\n   else if (!DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl)\n+\t   && !disregard_limits\n \t   && !lookup_attribute (\"flatten\",\n \t\t\t\t DECL_ATTRIBUTES\n \t\t\t\t   (e->caller->global.inlined_to\n@@ -1400,6 +1404,79 @@ heap_edge_removal_hook (struct cgraph_edge *e, void *data)\n     }\n }\n \n+/* Return true if speculation of edge E seems useful.\n+   If ANTICIPATE_INLINING is true, be conservative and hope that E\n+   may get inlined.  */\n+\n+bool\n+speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining)\n+{\n+  enum availability avail;\n+  struct cgraph_node *target = cgraph_function_or_thunk_node (e->callee, &avail);\n+  struct cgraph_edge *direct, *indirect;\n+  struct ipa_ref *ref;\n+\n+  gcc_assert (e->speculative && !e->indirect_unknown_callee);\n+\n+  if (!cgraph_maybe_hot_edge_p (e))\n+    return false;\n+\n+  /* See if IP optimizations found something potentially useful about the\n+     function.  For now we look only for CONST/PURE flags.  Almost everything\n+     else we propagate is useless.  */\n+  if (avail >= AVAIL_AVAILABLE)\n+    {\n+      int ecf_flags = flags_from_decl_or_type (target->symbol.decl);\n+      if (ecf_flags & ECF_CONST)\n+        {\n+          cgraph_speculative_call_info (e, direct, indirect, ref);\n+\t  if (!(indirect->indirect_info->ecf_flags & ECF_CONST))\n+\t    return true;\n+        }\n+      else if (ecf_flags & ECF_PURE)\n+        {\n+          cgraph_speculative_call_info (e, direct, indirect, ref);\n+\t  if (!(indirect->indirect_info->ecf_flags & ECF_PURE))\n+\t    return true;\n+        }\n+    }\n+  /* If we did not managed to inline the function nor redirect\n+     to an ipa-cp clone (that are seen by having local flag set),\n+     it is probably pointless to inline it unless hardware is missing\n+     indirect call predictor.  */\n+  if (!anticipate_inlining && e->inline_failed && !target->local.local)\n+    return false;\n+  /* For overwritable targets there is not much to do.  */\n+  if (e->inline_failed && !can_inline_edge_p (e, false, true))\n+    return false;\n+  /* OK, speculation seems interesting.  */\n+  return true;\n+}\n+\n+/* We know that EDGE is not going to be inlined.\n+   See if we can remove speculation.  */\n+\n+static void\n+resolve_noninline_speculation (fibheap_t edge_heap, struct cgraph_edge *edge)\n+{\n+  if (edge->speculative && !speculation_useful_p (edge, false))\n+    {\n+      struct cgraph_node *node = edge->caller;\n+      struct cgraph_node *where = node->global.inlined_to\n+\t\t\t\t  ? node->global.inlined_to : node;\n+      bitmap updated_nodes = BITMAP_ALLOC (NULL);\n+\n+      cgraph_resolve_speculation (edge, NULL);\n+      reset_node_growth_cache (where);\n+      reset_edge_caches (where);\n+      inline_update_overall_summary (where);\n+      update_caller_keys (edge_heap, where,\n+\t\t\t  updated_nodes, NULL);\n+      reset_node_growth_cache (where);\n+      BITMAP_FREE (updated_nodes);\n+    }\n+}\n+\n /* We use greedy algorithm for inlining of small functions:\n    All inline candidates are put into prioritized heap ordered in\n    increasing badness.\n@@ -1478,22 +1555,44 @@ inline_small_functions (void)\n   /* Populate the heeap with all edges we might inline.  */\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (!node->global.inlined_to)\n-      {\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"Enqueueing calls of %s/%i.\\n\",\n-\t\t   cgraph_node_name (node), node->symbol.order);\n+    {\n+      bool update = false;\n+      struct cgraph_edge *next;\n \n-\tfor (edge = node->callers; edge; edge = edge->next_caller)\n+      if (dump_file)\n+\tfprintf (dump_file, \"Enqueueing calls in %s/%i.\\n\",\n+\t\t cgraph_node_name (node), node->symbol.order);\n+\n+      for (edge = node->callees; edge; edge = next)\n+\t{\n+\t  next = edge->next_callee;\n \t  if (edge->inline_failed\n+\t      && !edge->aux\n \t      && can_inline_edge_p (edge, true)\n \t      && want_inline_small_function_p (edge, true)\n \t      && edge->inline_failed)\n \t    {\n \t      gcc_assert (!edge->aux);\n \t      update_edge_key (edge_heap, edge);\n \t    }\n-      }\n+\t  if (edge->speculative && !speculation_useful_p (edge, edge->aux != NULL))\n+\t    {\n+\t      cgraph_resolve_speculation (edge, NULL);\n+\t      update = true;\n+\t    }\n+\t}\n+      if (update)\n+\t{\n+\t  struct cgraph_node *where = node->global.inlined_to\n+\t\t\t\t      ? node->global.inlined_to : node;\n+\t  inline_update_overall_summary (where);\n+          reset_node_growth_cache (where);\n+\t  reset_edge_caches (where);\n+          update_caller_keys (edge_heap, where,\n+\t\t\t      updated_nodes, NULL);\n+          bitmap_clear (updated_nodes);\n+\t}\n+    }\n \n   gcc_assert (in_lto_p\n \t      || !max_count\n@@ -1534,7 +1633,10 @@ inline_small_functions (void)\n \t}\n \n       if (!can_inline_edge_p (edge, true))\n-\tcontinue;\n+\t{\n+\t  resolve_noninline_speculation (edge_heap, edge);\n+\t  continue;\n+\t}\n       \n       callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n       growth = estimate_edge_growth (edge);\n@@ -1568,11 +1670,15 @@ inline_small_functions (void)\n \t{\n \t  edge->inline_failed = CIF_INLINE_UNIT_GROWTH_LIMIT;\n \t  report_inline_failed_reason (edge);\n+\t  resolve_noninline_speculation (edge_heap, edge);\n \t  continue;\n \t}\n \n       if (!want_inline_small_function_p (edge, true))\n-\tcontinue;\n+\t{\n+\t  resolve_noninline_speculation (edge_heap, edge);\n+\t  continue;\n+\t}\n \n       /* Heuristics for inlining small functions works poorly for\n \t recursive calls where we do efect similar to loop unrolling.\n@@ -1588,6 +1694,7 @@ inline_small_functions (void)\n \t\t\t\t   ? &new_indirect_edges : NULL))\n \t    {\n \t      edge->inline_failed = CIF_RECURSIVE_INLINING;\n+\t      resolve_noninline_speculation (edge_heap, edge);\n \t      continue;\n \t    }\n \t  reset_edge_caches (where);\n@@ -1596,6 +1703,7 @@ inline_small_functions (void)\n \t  if (flag_indirect_inlining)\n \t    add_new_edges_to_heap (edge_heap, new_indirect_edges);\n           update_callee_keys (edge_heap, where, updated_nodes);\n+\t  bitmap_clear (updated_nodes);\n \t}\n       else\n \t{\n@@ -1621,6 +1729,7 @@ inline_small_functions (void)\n \t      edge->inline_failed\n \t\t= (DECL_DISREGARD_INLINE_LIMITS (edge->callee->symbol.decl)\n \t\t   ? CIF_RECURSIVE_INLINING : CIF_UNSPECIFIED);\n+\t      resolve_noninline_speculation (edge_heap, edge);\n \t      continue;\n \t    }\n \t  else if (depth && dump_file)\n@@ -1773,6 +1882,7 @@ ipa_inline (void)\n   struct cgraph_node **order =\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   int i;\n+  int cold;\n \n   if (in_lto_p && optimize)\n     ipa_update_after_lto_read ();\n@@ -1820,66 +1930,83 @@ ipa_inline (void)\n      code size will shrink because the out-of-line copy is eliminated. \n      We do this regardless on the callee size as long as function growth limits\n      are met.  */\n-  if (flag_inline_functions_called_once)\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"\\nDeciding on functions to be inlined into all callers and removing useless speculations:\\n\");\n+\n+  /* Inlining one function called once has good chance of preventing\n+     inlining other function into the same callee.  Ideally we should\n+     work in priority order, but probably inlining hot functions first\n+     is good cut without the extra pain of maintaining the queue.\n+\n+     ??? this is not really fitting the bill perfectly: inlining function\n+     into callee often leads to better optimization of callee due to\n+     increased context for optimization.\n+     For example if main() function calls a function that outputs help\n+     and then function that does the main optmization, we should inline\n+     the second with priority even if both calls are cold by themselves.\n+\n+     We probably want to implement new predicate replacing our use of\n+     maybe_hot_edge interpreted as maybe_hot_edge || callee is known\n+     to be hot.  */\n+  for (cold = 0; cold <= 1; cold ++)\n     {\n-      int cold;\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \"\\nDeciding on functions to be inlined into all callers:\\n\");\n-\n-      /* Inlining one function called once has good chance of preventing\n-\t inlining other function into the same callee.  Ideally we should\n-\t work in priority order, but probably inlining hot functions first\n-\t is good cut without the extra pain of maintaining the queue.\n-\n-\t ??? this is not really fitting the bill perfectly: inlining function\n-\t into callee often leads to better optimization of callee due to\n-\t increased context for optimization.\n-\t For example if main() function calls a function that outputs help\n-\t and then function that does the main optmization, we should inline\n-\t the second with priority even if both calls are cold by themselves.\n-\n-\t We probably want to implement new predicate replacing our use of\n-\t maybe_hot_edge interpreted as maybe_hot_edge || callee is known\n-\t to be hot.  */\n-      for (cold = 0; cold <= 1; cold ++)\n+      FOR_EACH_DEFINED_FUNCTION (node)\n \t{\n-\t  FOR_EACH_DEFINED_FUNCTION (node)\n+\t  struct cgraph_edge *edge, *next;\n+\t  bool update=false;\n+\n+\t  for (edge = node->callees; edge; edge = next)\n \t    {\n-\t      if (want_inline_function_to_all_callers_p (node, cold))\n+\t      next = edge->next_callee;\n+\t      if (edge->speculative && !speculation_useful_p (edge, false))\n \t\t{\n-\t\t  int num_calls = 0;\n-\t\t  struct cgraph_edge *e;\n-\t\t  for (e = node->callers; e; e = e->next_caller)\n-\t\t    num_calls++;\n-\t\t  while (node->callers && !node->global.inlined_to)\n+\t\t  cgraph_resolve_speculation (edge, NULL);\n+\t\t  update = true;\n+\t\t}\n+\t    }\n+\t  if (update)\n+\t    {\n+\t      struct cgraph_node *where = node->global.inlined_to\n+\t\t\t\t\t  ? node->global.inlined_to : node;\n+              reset_node_growth_cache (where);\n+\t      reset_edge_caches (where);\n+\t      inline_update_overall_summary (where);\n+\t    }\n+\t  if (flag_inline_functions_called_once\n+\t      && want_inline_function_to_all_callers_p (node, cold))\n+\t    {\n+\t      int num_calls = 0;\n+\t      struct cgraph_edge *e;\n+\t      for (e = node->callers; e; e = e->next_caller)\n+\t\tnum_calls++;\n+\t      while (node->callers && !node->global.inlined_to)\n+\t\t{\n+\t\t  struct cgraph_node *caller = node->callers->caller;\n+\n+\t\t  if (dump_file)\n \t\t    {\n-\t\t      struct cgraph_node *caller = node->callers->caller;\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"\\nInlining %s size %i.\\n\",\n+\t\t\t       cgraph_node_name (node),\n+\t\t\t       inline_summary (node)->size);\n+\t\t      fprintf (dump_file,\n+\t\t\t       \" Called once from %s %i insns.\\n\",\n+\t\t\t       cgraph_node_name (node->callers->caller),\n+\t\t\t       inline_summary (node->callers->caller)->size);\n+\t\t    }\n \n+\t\t  inline_call (node->callers, true, NULL, NULL, true);\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \" Inlined into %s which now has %i size\\n\",\n+\t\t\t     cgraph_node_name (caller),\n+\t\t\t     inline_summary (caller)->size);\n+\t\t  if (!num_calls--)\n+\t\t    {\n \t\t      if (dump_file)\n-\t\t\t{\n-\t\t\t  fprintf (dump_file,\n-\t\t\t\t   \"\\nInlining %s size %i.\\n\",\n-\t\t\t\t   cgraph_node_name (node),\n-\t\t\t\t   inline_summary (node)->size);\n-\t\t\t  fprintf (dump_file,\n-\t\t\t\t   \" Called once from %s %i insns.\\n\",\n-\t\t\t\t   cgraph_node_name (node->callers->caller),\n-\t\t\t\t   inline_summary (node->callers->caller)->size);\n-\t\t\t}\n-\n-\t\t      inline_call (node->callers, true, NULL, NULL, true);\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \" Inlined into %s which now has %i size\\n\",\n-\t\t\t\t cgraph_node_name (caller),\n-\t\t\t\t inline_summary (caller)->size);\n-\t\t      if (!num_calls--)\n-\t\t        {\n-\t\t\t  if (dump_file)\n-\t\t\t    fprintf (dump_file, \"New calls found; giving up.\\n\");\n-\t\t\t  break;\n-\t\t        }\n+\t\t\tfprintf (dump_file, \"New calls found; giving up.\\n\");\n+\t\t      break;\n \t\t    }\n \t\t}\n \t    }"}, {"sha": "000d1abc968982b7a1574fe625d97721d897e4c8", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=09ce36608d268b1a3124411a3ad2f701e5cf24ec", "patch": "@@ -226,6 +226,7 @@ inline_hints do_estimate_edge_hints (struct cgraph_edge *edge);\n void initialize_growth_caches (void);\n void free_growth_caches (void);\n void compute_inline_parameters (struct cgraph_node *, bool);\n+bool speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining);\n \n /* In ipa-inline-transform.c  */\n bool inline_call (struct cgraph_edge *, bool, vec<cgraph_edge_p> *, int *, bool);"}, {"sha": "1578aed70e8ae71d24f167b669e2f2a1ed664cd3", "filename": "gcc/ipa.c", "status": "modified", "additions": 104, "deletions": 52, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=09ce36608d268b1a3124411a3ad2f701e5cf24ec", "patch": "@@ -768,11 +768,7 @@ bool\n can_replace_by_local_alias (symtab_node node)\n {\n   return (symtab_node_availability (node) > AVAIL_OVERWRITABLE\n-\t  && !DECL_EXTERNAL (node->symbol.decl)\n-\t  && (!DECL_ONE_ONLY (node->symbol.decl)\n-\t      || node->symbol.resolution == LDPR_PREVAILING_DEF\n-\t      || node->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t      || node->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY_EXP));\n+\t  && !symtab_can_be_discarded (node));\n }\n \n /* Mark visibility of all functions.\n@@ -1407,53 +1403,9 @@ ipa_profile (void)\n   bool something_changed = false;\n   int i;\n   gcov_type overall_time = 0, cutoff = 0, cumulated = 0, overall_size = 0;\n-\n-  /* Produce speculative calls: we saved common traget from porfiling into\n-     e->common_target_id.  Now, at link time, we can look up corresponding\n-     function node and produce speculative call.  */\n-  if (in_lto_p)\n-    {\n-      struct cgraph_edge *e;\n-      struct cgraph_node *n,*n2;\n-\n-      init_node_map (false);\n-      FOR_EACH_DEFINED_FUNCTION (n)\n-\t{\n-\t  bool update = false;\n-\n-\t  for (e = n->indirect_calls; e; e = e->next_callee)\n-\t    if (e->indirect_info->common_target_id)\n-\t      {\n-\t\tn2 = find_func_by_profile_id (e->indirect_info->common_target_id);\n-\t\tif (n2)\n-\t\t  {\n-\t\t    if (dump_file)\n-\t\t      {\n-\t\t\tfprintf (dump_file, \"Indirect call -> direct call from\"\n-\t\t\t\t \" other module %s/%i => %s/%i, prob %3.2f\\n\",\n-\t\t\t\t xstrdup (cgraph_node_name (n)), n->symbol.order,\n-\t\t\t\t xstrdup (cgraph_node_name (n2)), n2->symbol.order,\n-\t\t\t\t e->indirect_info->common_target_probability\n-\t\t\t\t / (float)REG_BR_PROB_BASE);\n-\t\t      }\n-\t\t    cgraph_turn_edge_to_speculative\n-\t\t      (e, n2,\n-\t\t       apply_scale (e->count,\n-\t\t\t\t    e->indirect_info->common_target_probability),\n-\t\t       apply_scale (e->frequency,\n-\t\t\t\t    e->indirect_info->common_target_probability));\n-\t\t    update = true;\n-\t\t  }\n-\t\telse\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"Function with profile-id %i not found.\\n\",\n-\t\t\t     e->indirect_info->common_target_id);\n-\t       }\n-\t     if (update)\n-\t       inline_update_overall_summary (n);\n-\t   }\n-\tdel_node_map ();\n-    }\n+  struct cgraph_node *n,*n2;\n+  int nindirect = 0, ncommon = 0, nunknown = 0, nuseless = 0, nconverted = 0;\n+  bool node_map_initialized = false;\n \n   if (dump_file)\n     dump_histogram (dump_file, histogram);\n@@ -1523,6 +1475,106 @@ ipa_profile (void)\n   histogram.release();\n   free_alloc_pool (histogram_pool);\n \n+  /* Produce speculative calls: we saved common traget from porfiling into\n+     e->common_target_id.  Now, at link time, we can look up corresponding\n+     function node and produce speculative call.  */\n+\n+  FOR_EACH_DEFINED_FUNCTION (n)\n+    {\n+      bool update = false;\n+\n+      for (e = n->indirect_calls; e; e = e->next_callee)\n+\t{\n+\t  if (n->count)\n+\t    nindirect++;\n+\t  if (e->indirect_info->common_target_id)\n+\t    {\n+\t      if (!node_map_initialized)\n+\t        init_node_map (false);\n+\t      node_map_initialized = true;\n+\t      ncommon++;\n+\t      n2 = find_func_by_profile_id (e->indirect_info->common_target_id);\n+\t      if (n2)\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file, \"Indirect call -> direct call from\"\n+\t\t\t       \" other module %s/%i => %s/%i, prob %3.2f\\n\",\n+\t\t\t       xstrdup (cgraph_node_name (n)), n->symbol.order,\n+\t\t\t       xstrdup (cgraph_node_name (n2)), n2->symbol.order,\n+\t\t\t       e->indirect_info->common_target_probability\n+\t\t\t       / (float)REG_BR_PROB_BASE);\n+\t\t    }\n+\t\t  if (e->indirect_info->common_target_probability\n+\t\t      < REG_BR_PROB_BASE / 2)\n+\t\t    {\n+\t\t      nuseless++;\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \"Not speculating: probability is too low.\\n\");\n+\t\t    }\n+\t\t  else if (!cgraph_maybe_hot_edge_p (e))\n+\t\t    {\n+\t\t      nuseless++;\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \"Not speculating: call is cold.\\n\");\n+\t\t    }\n+\t\t  else if (cgraph_function_body_availability (n2)\n+\t\t\t   <= AVAIL_OVERWRITABLE\n+\t\t\t   && symtab_can_be_discarded ((symtab_node) n2))\n+\t\t    {\n+\t\t      nuseless++;\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \"Not speculating: target is overwritable \"\n+\t\t\t\t \"and can be discarded.\\n\");\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* Target may be overwritable, but profile says that\n+\t\t\t control flow goes to this particular implementation\n+\t\t\t of N2.  Speculate on the local alias to allow inlining.\n+\t\t       */\n+\t\t      if (!symtab_can_be_discarded ((symtab_node) n2))\n+\t\t\tn2 = cgraph (symtab_nonoverwritable_alias ((symtab_node)n2));\n+\t\t      nconverted++;\n+\t\t      cgraph_turn_edge_to_speculative\n+\t\t\t(e, n2,\n+\t\t\t apply_scale (e->count,\n+\t\t\t\t      e->indirect_info->common_target_probability),\n+\t\t\t apply_scale (e->frequency,\n+\t\t\t\t      e->indirect_info->common_target_probability));\n+\t\t      update = true;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Function with profile-id %i not found.\\n\",\n+\t\t\t     e->indirect_info->common_target_id);\n+\t\t  nunknown++;\n+\t\t}\n+\t    }\n+\t }\n+       if (update)\n+\t inline_update_overall_summary (n);\n+     }\n+  if (node_map_initialized)\n+    del_node_map ();\n+  if (dump_file && nindirect)\n+    fprintf (dump_file,\n+\t     \"%i indirect calls trained.\\n\"\n+\t     \"%i (%3.2f%%) have common target.\\n\"\n+\t     \"%i (%3.2f%%) targets was not found.\\n\"\n+\t     \"%i (%3.2f%%) speculations seems useless.\\n\"\n+\t     \"%i (%3.2f%%) speculations produced.\\n\",\n+\t     nindirect,\n+\t     ncommon, ncommon * 100.0 / nindirect,\n+\t     nunknown, nunknown * 100.0 / nindirect,\n+\t     nuseless, nuseless * 100.0 / nindirect,\n+\t     nconverted, nconverted * 100.0 / nindirect);\n+\n   order_pos = ipa_reverse_postorder (order);\n   for (i = order_pos - 1; i >= 0; i--)\n     {"}, {"sha": "8aa9fcda905f5c5580c552d0849cd821118c0031", "filename": "gcc/value-prof.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ce36608d268b1a3124411a3ad2f701e5cf24ec/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=09ce36608d268b1a3124411a3ad2f701e5cf24ec", "patch": "@@ -1431,8 +1431,6 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n   gimple stmt = gsi_stmt (*gsi);\n   histogram_value histogram;\n   gcov_type val, count, all, bb_all;\n-  gcov_type prob;\n-  gimple modify;\n   struct cgraph_node *direct_call;\n \n   if (gimple_code (stmt) != GIMPLE_CALL)\n@@ -1452,12 +1450,6 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n   count = histogram->hvalue.counters [1];\n   all = histogram->hvalue.counters [2];\n \n-  if (4 * count <= 3 * all)\n-    {\n-      gimple_remove_histogram_value (cfun, stmt, histogram);\n-      return false;\n-    }\n-\n   bb_all = gimple_bb (stmt)->count;\n   /* The order of CHECK_COUNTER calls is important -\n      since check_counter can correct the third parameter\n@@ -1469,10 +1461,9 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n       return false;\n     }\n \n-  if (all > 0)\n-    prob = GCOV_COMPUTE_SCALE (count, all);\n-  else\n-    prob = 0;\n+  if (4 * count <= 3 * all)\n+    return false;\n+\n   direct_call = find_func_by_profile_id ((int)val);\n \n   if (direct_call == NULL)\n@@ -1488,23 +1479,30 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n \t}\n       return false;\n     }\n-  gimple_remove_histogram_value (cfun, stmt, histogram);\n \n   if (!check_ic_target (stmt, direct_call))\n-    return false;\n-\n-  modify = gimple_ic (stmt, direct_call, prob, count, all);\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Indirect call -> direct call \");\n+\t  print_generic_expr (dump_file, gimple_call_fn (stmt), TDF_SLIM);\n+\t  fprintf (dump_file, \"=> \");\n+\t  print_generic_expr (dump_file, direct_call->symbol.decl, TDF_SLIM);\n+\t  fprintf (dump_file, \" transformation skipped because of type mismatch\");\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t}\n+      gimple_remove_histogram_value (cfun, stmt, histogram);\n+      return false;\n+    }\n \n   if (dump_file)\n     {\n       fprintf (dump_file, \"Indirect call -> direct call \");\n       print_generic_expr (dump_file, gimple_call_fn (stmt), TDF_SLIM);\n       fprintf (dump_file, \"=> \");\n       print_generic_expr (dump_file, direct_call->symbol.decl, TDF_SLIM);\n-      fprintf (dump_file, \" transformation on insn \");\n+      fprintf (dump_file, \" transformation on insn postponned to ipa-profile\");\n       print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n-      fprintf (dump_file, \" to \");\n-      print_gimple_stmt (dump_file, modify, 0, TDF_SLIM);\n       fprintf (dump_file, \"hist->count \"HOST_WIDEST_INT_PRINT_DEC\n \t       \" hist->all \"HOST_WIDEST_INT_PRINT_DEC\"\\n\", count, all);\n     }"}]}