{"sha": "6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZlNjNmYjQzZjVmZjcxYmJkNWJhNGIzZTYxMjhiZmRkNWVmZTM3ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-03T12:15:05Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-03T12:15:05Z"}, "message": "Canonicalize canonical type hashing\n\n\tCanonicalize canonical type hashing\n\tgcc/\n\t* tree.h (type_hash_canon_hash): Declare.\n\t* tree.c (type_hash_list, attribute_hash_list): Move into\n\ttype_hash_canon_hash.\n\t(build_type_attribute_qual_variant): Break out hash code calc into\n\ttype_hash_canon_hash.\n\t(type_hash_canon_hash): New.  Generic type hash computation.\n\t(build_range_type_1, build_array_type_1, build_function_type)\n\tbuild_method_type_directly, build_offset_type, build_complex_type,\n\tmake_vector_type): Call it.\n\tgcc/c-family/\n\t* c-common.c (complete_array_type): Use type_hash_canon.\n(--This line, and those below, will be ignored--\n\nM    gcc/tree.c\nM    gcc/tree.h\nM    gcc/c-family/ChangeLog\nM    gcc/c-family/c-common.c\nM    gcc/ChangeLog\n\nFrom-SVN: r247546", "tree": {"sha": "5e19613b53174533182ee0857af5ce77c9c9f137", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e19613b53174533182ee0857af5ce77c9c9f137"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "49ab46214e9288ee1268f87ddcd64dacfd21c31d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49ab46214e9288ee1268f87ddcd64dacfd21c31d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49ab46214e9288ee1268f87ddcd64dacfd21c31d"}], "stats": {"total": 209, "additions": 109, "deletions": 100}, "files": [{"sha": "40cf1e95d7931f16a1b2bec443accaa250ebc70e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d", "patch": "@@ -1,3 +1,16 @@\n+2017-05-03  Nathan Sidwell  <nathan@acm.org>\n+\n+\tCanonicalize canonical type hashing\n+\t* tree.h (type_hash_canon_hash): Declare.\n+\t* tree.c (type_hash_list, attribute_hash_list): Move into\n+\ttype_hash_canon_hash.\n+\t(build_type_attribute_qual_variant): Break out hash code calc into\n+\ttype_hash_canon_hash.\n+\t(type_hash_canon_hash): New.  Generic type hash computation.\n+\t(build_range_type_1, build_array_type_1, build_function_type,\n+\tbuild_method_type_directly, build_offset_type, build_complex_type,\n+\tmake_vector_type): Call it.\n+\n 2017-05-03  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment):\n@@ -711,7 +724,7 @@\n \t(crc32_unsigned_n): ... this.\n \t(crc32_unsigned, crc32_byte): Remove.\n \t(crc32_string): Remove unnecessary braces.\n-\n+ \n 2017-04-25  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-cp.c (estimate_local_effects): Convert sreal to int."}, {"sha": "07a2e00c0a84529efbb66cbdc9ea497dd12ef368", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d", "patch": "@@ -1,3 +1,8 @@\n+2017-05-03  Nathan Sidwell  <nathan@acm.org>\n+\n+\tCanonicalize canonical type hashing\n+\t* c-common.c (complete_array_type): Use type_hash_canon.\n+\n 2017-05-01  Xi Ruoyao  <ryxi@stu.xidian.edu.cn>\n \n         PR c++/80038"}, {"sha": "088492294cac1a7292f1ca0bd71eb2fb0c19e460", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d", "patch": "@@ -6368,12 +6368,8 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n   layout_type (main_type);\n \n   /* Make sure we have the canonical MAIN_TYPE. */\n-  inchash::hash hstate;\n-  hstate.add_object (TYPE_HASH (unqual_elt));\n-  hstate.add_object (TYPE_HASH (TYPE_DOMAIN (main_type)));\n-  if (!AGGREGATE_TYPE_P (unqual_elt))\n-    hstate.add_flag (TYPE_TYPELESS_STORAGE (main_type));\n-  main_type = type_hash_canon (hstate.end (), main_type);\n+  hashval_t hashcode = type_hash_canon_hash (main_type);\n+  main_type = type_hash_canon (hashcode, main_type);\n \n   /* Fix the canonical type.  */\n   if (TYPE_STRUCTURAL_EQUALITY_P (TREE_TYPE (main_type))"}, {"sha": "d88c445d32bc8628b90784bd165929b1c9a32c60", "filename": "gcc/tree.c", "status": "modified", "additions": 87, "deletions": 93, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d", "patch": "@@ -248,8 +248,6 @@ static void set_type_quals (tree, int);\n static void print_type_hash_statistics (void);\n static void print_debug_expr_statistics (void);\n static void print_value_expr_statistics (void);\n-static void type_hash_list (const_tree, inchash::hash &);\n-static void attribute_hash_list (const_tree, inchash::hash &);\n \n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n@@ -4828,11 +4826,7 @@ build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)\n {\n   if (! attribute_list_equal (TYPE_ATTRIBUTES (ttype), attribute))\n     {\n-      inchash::hash hstate;\n       tree ntype;\n-      int i;\n-      tree t;\n-      enum tree_code code = TREE_CODE (ttype);\n \n       /* Building a distinct copy of a tagged type is inappropriate; it\n \t causes breakage in code that expects there to be a one-to-one\n@@ -4856,37 +4850,8 @@ build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)\n \n       TYPE_ATTRIBUTES (ntype) = attribute;\n \n-      hstate.add_int (code);\n-      if (TREE_TYPE (ntype))\n-\thstate.add_object (TYPE_HASH (TREE_TYPE (ntype)));\n-      attribute_hash_list (attribute, hstate);\n-\n-      switch (TREE_CODE (ntype))\n-\t{\n-\tcase FUNCTION_TYPE:\n-\t  type_hash_list (TYPE_ARG_TYPES (ntype), hstate);\n-\t  break;\n-\tcase ARRAY_TYPE:\n-\t  if (TYPE_DOMAIN (ntype))\n-\t    hstate.add_object (TYPE_HASH (TYPE_DOMAIN (ntype)));\n-\t  break;\n-\tcase INTEGER_TYPE:\n-\t  t = TYPE_MAX_VALUE (ntype);\n-\t  for (i = 0; i < TREE_INT_CST_NUNITS (t); i++)\n-\t    hstate.add_object (TREE_INT_CST_ELT (t, i));\n-\t  break;\n-\tcase REAL_TYPE:\n-\tcase FIXED_POINT_TYPE:\n-\t  {\n-\t    unsigned int precision = TYPE_PRECISION (ntype);\n-\t    hstate.add_object (precision);\n-\t  }\n-\t  break;\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      ntype = type_hash_canon (hstate.end(), ntype);\n+      hashval_t hash = type_hash_canon_hash (ntype);\n+      ntype = type_hash_canon (hash, ntype);\n \n       /* If the target-dependent attributes make NTYPE different from\n \t its canonical type, we will need to use structural equality\n@@ -6994,18 +6959,80 @@ decl_debug_args_insert (tree from)\n /* Hashing of types so that we don't make duplicates.\n    The entry point is `type_hash_canon'.  */\n \n-/* Compute a hash code for a list of types (chain of TREE_LIST nodes\n-   with types in the TREE_VALUE slots), by adding the hash codes\n-   of the individual types.  */\n+/* Generate the default hash code for TYPE.  This is designed for\n+   speed, rather than maximum entropy.  */\n \n-static void\n-type_hash_list (const_tree list, inchash::hash &hstate)\n+hashval_t\n+type_hash_canon_hash (tree type)\n {\n-  const_tree tail;\n+  inchash::hash hstate;\n+\n+  hstate.add_int (TREE_CODE (type));\n+\n+  if (TREE_TYPE (type))\n+    hstate.add_object (TYPE_HASH (TREE_TYPE (type)));\n+\n+  for (tree t = TYPE_ATTRIBUTES (type); t; t = TREE_CHAIN (t))\n+    /* Just the identifier is adequate to distinguish.  */\n+    hstate.add_object (IDENTIFIER_HASH_VALUE (get_attribute_name (t)));\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case METHOD_TYPE:\n+      hstate.add_object (TYPE_HASH (TYPE_METHOD_BASETYPE (type)));\n+      /* FALLTHROUGH. */\n+    case FUNCTION_TYPE:\n+      for (tree t = TYPE_ARG_TYPES (type); t; t = TREE_CHAIN (t))\n+\tif (TREE_VALUE (t) != error_mark_node)\n+\t  hstate.add_object (TYPE_HASH (TREE_VALUE (t)));\n+      break;\n+\n+    case OFFSET_TYPE:\n+      hstate.add_object (TYPE_HASH (TYPE_OFFSET_BASETYPE (type)));\n+      break;\n+\n+    case ARRAY_TYPE:\n+      {\n+\tif (TYPE_DOMAIN (type))\n+\t  hstate.add_object (TYPE_HASH (TYPE_DOMAIN (type)));\n+\tif (!AGGREGATE_TYPE_P (TREE_TYPE (type)))\n+\t  {\n+\t    unsigned typeless = TYPE_TYPELESS_STORAGE (type);\n+\t    hstate.add_object (typeless);\n+\t  }\n+      }\n+      break;\n \n-  for (tail = list; tail; tail = TREE_CHAIN (tail))\n-    if (TREE_VALUE (tail) != error_mark_node)\n-      hstate.add_object (TYPE_HASH (TREE_VALUE (tail)));\n+    case INTEGER_TYPE:\n+      {\n+\ttree t = TYPE_MAX_VALUE (type);\n+\tif (!t)\n+\t  t = TYPE_MIN_VALUE (type);\n+\tfor (int i = 0; i < TREE_INT_CST_NUNITS (t); i++)\n+\t  hstate.add_object (TREE_INT_CST_ELT (t, i));\n+\tbreak;\n+      }\n+      \n+    case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n+      {\n+\tunsigned prec = TYPE_PRECISION (type);\n+\thstate.add_object (prec);\n+\tbreak;\n+      }\n+\n+    case VECTOR_TYPE:\n+      {\n+\tunsigned nunits = TYPE_VECTOR_SUBPARTS (type);\n+\thstate.add_object (nunits);\n+\tbreak;\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  return hstate.end ();\n }\n \n /* These are the Hashtable callback functions.  */\n@@ -7186,20 +7213,6 @@ print_type_hash_statistics (void)\n \t   type_hash_table->collisions ());\n }\n \n-/* Compute a hash code for a list of attributes (chain of TREE_LIST nodes\n-   with names in the TREE_PURPOSE slots and args in the TREE_VALUE slots),\n-   by adding the hash codes of the individual attributes.  */\n-\n-static void\n-attribute_hash_list (const_tree list, inchash::hash &hstate)\n-{\n-  const_tree tail;\n-\n-  for (tail = list; tail; tail = TREE_CHAIN (tail))\n-    /* ??? Do we want to add in TREE_VALUE too? */\n-    hstate.add_object (IDENTIFIER_HASH_VALUE (get_attribute_name (tail)));\n-}\n-\n /* Given two lists of attributes, return true if list l2 is\n    equivalent to l1.  */\n \n@@ -8264,7 +8277,6 @@ static tree\n build_range_type_1 (tree type, tree lowval, tree highval, bool shared)\n {\n   tree itype = make_node (INTEGER_TYPE);\n-  inchash::hash hstate;\n \n   TREE_TYPE (itype) = type;\n \n@@ -8292,10 +8304,8 @@ build_range_type_1 (tree type, tree lowval, tree highval, bool shared)\n       return itype;\n     }\n \n-  inchash::add_expr (TYPE_MIN_VALUE (itype), hstate);\n-  inchash::add_expr (TYPE_MAX_VALUE (itype), hstate);\n-  hstate.merge_hash (TYPE_HASH (type));\n-  itype = type_hash_canon (hstate.end (), itype);\n+  hashval_t hash = type_hash_canon_hash (itype);\n+  itype = type_hash_canon (hash, itype);\n \n   return itype;\n }\n@@ -8403,13 +8413,8 @@ build_array_type_1 (tree elt_type, tree index_type, bool typeless_storage,\n \n   if (shared)\n     {\n-      inchash::hash hstate;\n-      hstate.add_object (TYPE_HASH (elt_type));\n-      if (index_type)\n-\thstate.add_object (TYPE_HASH (index_type));\n-      if (!AGGREGATE_TYPE_P (elt_type))\n-\thstate.add_flag (TYPE_TYPELESS_STORAGE (t));\n-      t = type_hash_canon (hstate.end (), t);\n+      hashval_t hash = type_hash_canon_hash (t);\n+      t = type_hash_canon (hash, t);\n     }\n \n   if (TYPE_CANONICAL (t) == t)\n@@ -8566,9 +8571,8 @@ build_function_type (tree value_type, tree arg_types)\n   TYPE_ARG_TYPES (t) = arg_types;\n \n   /* If we already have such a type, use the old one.  */\n-  hstate.add_object (TYPE_HASH (value_type));\n-  type_hash_list (arg_types, hstate);\n-  t = type_hash_canon (hstate.end (), t);\n+  hashval_t hash = type_hash_canon_hash (t);\n+  t = type_hash_canon (hash, t);\n \n   /* Set up the canonical type. */\n   any_structural_p   = TYPE_STRUCTURAL_EQUALITY_P (value_type);\n@@ -8705,7 +8709,6 @@ build_method_type_directly (tree basetype,\n {\n   tree t;\n   tree ptype;\n-  inchash::hash hstate;\n   bool any_structural_p, any_noncanonical_p;\n   tree canon_argtypes;\n \n@@ -8722,10 +8725,8 @@ build_method_type_directly (tree basetype,\n   TYPE_ARG_TYPES (t) = argtypes;\n \n   /* If we already have such a type, use the old one.  */\n-  hstate.add_object (TYPE_HASH (basetype));\n-  hstate.add_object (TYPE_HASH (rettype));\n-  type_hash_list (argtypes, hstate);\n-  t = type_hash_canon (hstate.end (), t);\n+  hashval_t hash = type_hash_canon_hash (t);\n+  t = type_hash_canon (hash, t);\n \n   /* Set up the canonical type. */\n   any_structural_p\n@@ -8773,7 +8774,6 @@ tree\n build_offset_type (tree basetype, tree type)\n {\n   tree t;\n-  inchash::hash hstate;\n \n   /* Make a node of the sort we want.  */\n   t = make_node (OFFSET_TYPE);\n@@ -8782,9 +8782,8 @@ build_offset_type (tree basetype, tree type)\n   TREE_TYPE (t) = type;\n \n   /* If we already have such a type, use the old one.  */\n-  hstate.add_object (TYPE_HASH (basetype));\n-  hstate.add_object (TYPE_HASH (type));\n-  t = type_hash_canon (hstate.end (), t);\n+  hashval_t hash = type_hash_canon_hash (t);\n+  t = type_hash_canon (hash, t);\n \n   if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n@@ -8815,7 +8814,6 @@ tree\n build_complex_type (tree component_type, bool named)\n {\n   tree t;\n-  inchash::hash hstate;\n \n   gcc_assert (INTEGRAL_TYPE_P (component_type)\n \t      || SCALAR_FLOAT_TYPE_P (component_type)\n@@ -8827,8 +8825,8 @@ build_complex_type (tree component_type, bool named)\n   TREE_TYPE (t) = TYPE_MAIN_VARIANT (component_type);\n \n   /* If we already have such a type, use the old one.  */\n-  hstate.add_object (TYPE_HASH (component_type));\n-  t = type_hash_canon (hstate.end (), t);\n+  hashval_t hash = type_hash_canon_hash (t);\n+  t = type_hash_canon (hash, t);\n \n   if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n@@ -10083,7 +10081,6 @@ static tree\n make_vector_type (tree innertype, int nunits, machine_mode mode)\n {\n   tree t;\n-  inchash::hash hstate;\n   tree mv_innertype = TYPE_MAIN_VARIANT (innertype);\n \n   t = make_node (VECTOR_TYPE);\n@@ -10101,11 +10098,8 @@ make_vector_type (tree innertype, int nunits, machine_mode mode)\n \n   layout_type (t);\n \n-  hstate.add_wide_int (VECTOR_TYPE);\n-  hstate.add_wide_int (nunits);\n-  hstate.add_wide_int (mode);\n-  hstate.add_object (TYPE_HASH (TREE_TYPE (t)));\n-  t = type_hash_canon (hstate.end (), t);\n+  hashval_t hash = type_hash_canon_hash (t);\n+  t = type_hash_canon (hash, t);\n \n   /* We have built a main variant, based on the main variant of the\n      inner type. Use it to build the variant we return.  */"}, {"sha": "21c7220111074a80d54aeb6328541f768b5d3ed7", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6fe63fb43f5ff71bbd5ba4b3e6128bfdd5efe37d", "patch": "@@ -4303,6 +4303,7 @@ extern tree build_variant_type_copy (tree CXX_MEM_STAT_INFO);\n    How the hash code is computed is up to the caller, as long as any two\n    callers that could hash identical-looking type nodes agree.  */\n \n+extern hashval_t type_hash_canon_hash (tree);\n extern tree type_hash_canon (unsigned int, tree);\n \n extern tree convert (tree, tree);"}]}