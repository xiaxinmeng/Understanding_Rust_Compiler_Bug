{"sha": "667db6dedd80487663c29b21efa942f661b569a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY3ZGI2ZGVkZDgwNDg3NjYzYzI5YjIxZWZhOTQyZjY2MWI1NjlhOA==", "commit": {"author": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2020-10-30T19:49:32Z"}, "committer": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2020-10-30T19:49:32Z"}, "message": "PR libfortran/97581 - clean up size calculation of random generator state\n\nThe random number generator internal state may be saved to/restored from\nan array of integers.  Clean up calculation of needed number of elements\nto avoid redefiniton of auxiliary macro SZ.\n\nlibgfortran/ChangeLog:\n\n\t* intrinsics/random.c (SZ_IN_INT_4): Define size of state in int32_t.\n\t(SZ_IN_INT_8): Define size of state in int64_t.\n\t(SZ): Remove.\n\t(random_seed_i4): Use size SZ_IN_INT_4 instead of SZ.\n\t(random_seed_i8): Use size SZ_IN_INT_8 instead of SZ.", "tree": {"sha": "a00ecf106df97f1dd30e55ff7e7817b0c5819130", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a00ecf106df97f1dd30e55ff7e7817b0c5819130"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/667db6dedd80487663c29b21efa942f661b569a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/667db6dedd80487663c29b21efa942f661b569a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/667db6dedd80487663c29b21efa942f661b569a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/667db6dedd80487663c29b21efa942f661b569a8/comments", "author": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "committer": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d10f3e900b0377b4760a090b0f90371bcef01686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d10f3e900b0377b4760a090b0f90371bcef01686", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d10f3e900b0377b4760a090b0f90371bcef01686"}], "stats": {"total": 32, "additions": 17, "deletions": 15}, "files": [{"sha": "a864ab9f1fd27a0712bd60a074f820e230c83f17", "filename": "libgfortran/intrinsics/random.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/667db6dedd80487663c29b21efa942f661b569a8/libgfortran%2Fintrinsics%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/667db6dedd80487663c29b21efa942f661b569a8/libgfortran%2Fintrinsics%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frandom.c?ref=667db6dedd80487663c29b21efa942f661b569a8", "patch": "@@ -723,6 +723,9 @@ arandom_r16 (gfc_array_r16 *x)\n /* Number of elements in master_state array.  */\n #define SZU64 (sizeof (master_state.s) / sizeof (uint64_t))\n \n+/* Equivalent number of elements in an array of GFC_INTEGER_{4,8}.  */\n+#define SZ_IN_INT_4 (SZU64 * (sizeof (uint64_t) / sizeof (GFC_INTEGER_4)))\n+#define SZ_IN_INT_8 (SZU64 * (sizeof (uint64_t) / sizeof (GFC_INTEGER_8)))\n \n /* Keys for scrambling the seed in order to avoid poor seeds.  */\n \n@@ -751,14 +754,13 @@ void\n random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n {\n   uint64_t seed[SZU64];\n-#define SZ (sizeof (master_state.s) / sizeof (GFC_INTEGER_4))\n \n   /* Check that we only have one argument present.  */\n   if ((size ? 1 : 0) + (put ? 1 : 0) + (get ? 1 : 0) > 1)\n     runtime_error (\"RANDOM_SEED should have at most one argument present.\");\n \n   if (size != NULL)\n-    *size = SZ;\n+    *size = SZ_IN_INT_4;\n \n   prng_state* rs = get_rand_state();\n \n@@ -770,7 +772,7 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n \truntime_error (\"Array rank of GET is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) SZ)\n+      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) SZ_IN_INT_4)\n \truntime_error (\"Array size of GET is too small.\");\n \n       if (!rs->init)\n@@ -780,8 +782,9 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n       scramble_seed (seed, rs->s);\n \n       /*  Then copy it back to the user variable.  */\n-      for (size_t i = 0; i < SZ ; i++)\n-\tmemcpy (&(get->base_addr[(SZ - 1 - i) * GFC_DESCRIPTOR_STRIDE(get,0)]),\n+      for (size_t i = 0; i < SZ_IN_INT_4 ; i++)\n+\tmemcpy (&(get->base_addr[(SZ_IN_INT_4 - 1 - i) *\n+\t\t\t\t GFC_DESCRIPTOR_STRIDE(get,0)]),\n \t\t(unsigned char*) seed + i * sizeof(GFC_UINTEGER_4),\n                sizeof(GFC_UINTEGER_4));\n     }\n@@ -805,13 +808,14 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n         runtime_error (\"Array rank of PUT is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) SZ)\n+      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) SZ_IN_INT_4)\n         runtime_error (\"Array size of PUT is too small.\");\n \n       /*  We copy the seed given by the user.  */\n-      for (size_t i = 0; i < SZ; i++)\n+      for (size_t i = 0; i < SZ_IN_INT_4; i++)\n \tmemcpy ((unsigned char*) seed + i * sizeof(GFC_UINTEGER_4),\n-\t\t&(put->base_addr[(SZ - 1 - i) * GFC_DESCRIPTOR_STRIDE(put,0)]),\n+\t\t&(put->base_addr[(SZ_IN_INT_4 - 1 - i) *\n+\t\t\t\t GFC_DESCRIPTOR_STRIDE(put,0)]),\n \t\tsizeof(GFC_UINTEGER_4));\n \n       /* We put it after scrambling the bytes, to paper around users who\n@@ -823,7 +827,6 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n \n   __gthread_mutex_unlock (&random_lock);\n     }\n-#undef SZ\n }\n iexport(random_seed_i4);\n \n@@ -837,9 +840,8 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n   if ((size ? 1 : 0) + (put ? 1 : 0) + (get ? 1 : 0) > 1)\n     runtime_error (\"RANDOM_SEED should have at most one argument present.\");\n \n-#define SZ (sizeof (master_state.s) / sizeof (GFC_INTEGER_8))\n   if (size != NULL)\n-    *size = SZ;\n+    *size = SZ_IN_INT_8;\n \n   prng_state* rs = get_rand_state();\n \n@@ -851,7 +853,7 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n \truntime_error (\"Array rank of GET is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) SZ)\n+      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) SZ_IN_INT_8)\n \truntime_error (\"Array size of GET is too small.\");\n \n       if (!rs->init)\n@@ -861,7 +863,7 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n       scramble_seed (seed, rs->s);\n \n       /*  This code now should do correct strides.  */\n-      for (size_t i = 0; i < SZ; i++)\n+      for (size_t i = 0; i < SZ_IN_INT_8; i++)\n \tmemcpy (&(get->base_addr[i * GFC_DESCRIPTOR_STRIDE(get,0)]), &seed[i],\n \t\tsizeof (GFC_UINTEGER_8));\n     }\n@@ -885,11 +887,11 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n         runtime_error (\"Array rank of PUT is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) SZ)\n+      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) SZ_IN_INT_8)\n         runtime_error (\"Array size of PUT is too small.\");\n \n       /*  This code now should do correct strides.  */\n-      for (size_t i = 0; i < SZ; i++)\n+      for (size_t i = 0; i < SZ_IN_INT_8; i++)\n \tmemcpy (&seed[i], &(put->base_addr[i * GFC_DESCRIPTOR_STRIDE(put,0)]),\n \t\tsizeof (GFC_UINTEGER_8));\n "}]}