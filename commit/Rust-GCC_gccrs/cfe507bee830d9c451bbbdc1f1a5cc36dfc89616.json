{"sha": "cfe507bee830d9c451bbbdc1f1a5cc36dfc89616", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZlNTA3YmVlODMwZDljNDUxYmJiZGMxZjFhNWNjMzZkZmM4OTYxNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-17T22:35:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-17T22:35:19Z"}, "message": "decl.c (add_decl_to_level): New function.\n\n\t* decl.c (add_decl_to_level): New function.\n\t(push_local_binding): Use it.\n\t(find_binding): Fix typo in comment.\n\t(pushdecl): Use add_decl_to_level.  Put templates on the\n\tcorresponding namespace-scope binding levels.\n\t* dump.c (dequeue_and_dump): Print the specializations of a\n\ttemplate.\n\t* pt.c (push_template_decl_real): Don't push a template multiple\n\ttimes.\n\nFrom-SVN: r28738", "tree": {"sha": "42f4395767e8a85f8e3d853c22f9a94eaaefea02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42f4395767e8a85f8e3d853c22f9a94eaaefea02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfe507bee830d9c451bbbdc1f1a5cc36dfc89616", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfe507bee830d9c451bbbdc1f1a5cc36dfc89616", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfe507bee830d9c451bbbdc1f1a5cc36dfc89616", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfe507bee830d9c451bbbdc1f1a5cc36dfc89616/comments", "author": null, "committer": null, "parents": [{"sha": "db4b04f1f4eeee834532ac0000516dba24cef7a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db4b04f1f4eeee834532ac0000516dba24cef7a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db4b04f1f4eeee834532ac0000516dba24cef7a6"}], "stats": {"total": 74, "additions": 55, "deletions": 19}, "files": [{"sha": "ee595ab50c00443076fc385139c9320bcc72e91f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe507bee830d9c451bbbdc1f1a5cc36dfc89616/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe507bee830d9c451bbbdc1f1a5cc36dfc89616/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cfe507bee830d9c451bbbdc1f1a5cc36dfc89616", "patch": "@@ -1,3 +1,15 @@\n+1999-08-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl.c (add_decl_to_level): New function.\n+\t(push_local_binding): Use it.\n+\t(find_binding): Fix typo in comment.\n+\t(pushdecl): Use add_decl_to_level.  Put templates on the\n+\tcorresponding namespace-scope binding levels.\n+\t* dump.c (dequeue_and_dump): Print the specializations of a\n+\ttemplate.\n+\t* pt.c (push_template_decl_real): Don't push a template multiple\n+\ttimes.\n+\n 1999-08-17  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (CALL_DECLARATOR_PARMS): New macro."}, {"sha": "baf1a32cbf59d1002d7b0e6858feccbfe519bfb5", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe507bee830d9c451bbbdc1f1a5cc36dfc89616/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe507bee830d9c451bbbdc1f1a5cc36dfc89616/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cfe507bee830d9c451bbbdc1f1a5cc36dfc89616", "patch": "@@ -189,6 +189,7 @@ static tree poplevel_class PROTO((void));\n static void warn_about_implicit_typename_lookup PROTO((tree, tree));\n static int walk_namespaces_r PROTO((tree, walk_namespaces_fn, void *));\n static int walk_globals_r PROTO((tree, void *));\n+static void add_decl_to_level PROTO((tree, struct binding_level *));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -1099,9 +1100,29 @@ add_binding (id, decl)\n   return ok;\n }\n \n-/* Bind DECL to ID in the current_binding_level.\n-   If PUSH_USING is set in FLAGS, we know that DECL doesn't really belong\n-   to this binding level, that it got here through a using-declaration.  */\n+/* Add DECL to the list of things declared in B.  */\n+\n+static void\n+add_decl_to_level (decl, b)\n+     tree decl;\n+     struct binding_level *b;\n+{\n+  /* Only things that will live forever should go in the global\n+     binding level.  */\n+  my_friendly_assert (!(b == global_binding_level \n+\t\t\t&& !TREE_PERMANENT (decl)),\n+\t\t      19990817);\n+\n+  /* We build up the list in reverse order, and reverse it later if\n+     necessary.  */\n+  TREE_CHAIN (decl) = b->names;\n+  b->names = decl;\n+}\n+\n+/* Bind DECL to ID in the current_binding_level, assumed to be a local\n+   binding level.  If PUSH_USING is set in FLAGS, we know that DECL\n+   doesn't really belong to this binding level, that it got here\n+   through a using-declaration.  */\n \n void\n push_local_binding (id, decl, flags)\n@@ -1138,8 +1159,7 @@ push_local_binding (id, decl, flags)\n \n   /* And put DECL on the list of things declared by the current\n      binding level.  */\n-  TREE_CHAIN (decl) = b->names;\n-  b->names = decl;\n+  add_decl_to_level (decl, b);\n }\n \n /* Bind DECL to ID in the class_binding_level.  Returns nonzero if the\n@@ -2148,7 +2168,7 @@ find_binding (name, scope)\n       my_friendly_assert (TREE_CODE (iter) == CPLUS_BINDING, 374);\n       if (BINDING_SCOPE (iter) == scope)\n \t{\n-\t  /* Move binding found to the fron of the list, so\n+\t  /* Move binding found to the front of the list, so\n              subsequent lookups will find it faster. */\n \t  if (prev)\n \t    {\n@@ -3955,7 +3975,12 @@ pushdecl (x)\n \t    need_new_binding = 0;\n \t}\n       else if (DECL_FUNCTION_TEMPLATE_P (x) && DECL_NAMESPACE_SCOPE_P (x))\n-\treturn push_overloaded_decl (x, PUSH_GLOBAL);\n+\t{\n+\t  t = push_overloaded_decl (x, PUSH_GLOBAL);\n+\t  if (t == x)\n+\t    add_decl_to_level (x, NAMESPACE_LEVEL (CP_DECL_CONTEXT (t)));\n+\t  return t;\n+\t}\n \n       /* If declaring a type as a typedef, copy the type (unless we're\n \t at line 0), and install this TYPE_DECL as the new type's typedef\n@@ -4189,15 +4214,7 @@ pushdecl (x)\n     }\n \n   if (need_new_binding)\n-    {\n-      /* Put decls on list in reverse order.\n-\t We will reverse them later if necessary.  */\n-      TREE_CHAIN (x) = current_binding_level->names;\n-      current_binding_level->names = x;\n-      if (current_binding_level == global_binding_level\n-\t  && !TREE_PERMANENT (x))\n-\tmy_friendly_abort (124);\n-    }\n+    add_decl_to_level (x, current_binding_level);\n \n   return x;\n }"}, {"sha": "d67ab68867de93368cd4af580c883a75449fd110", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe507bee830d9c451bbbdc1f1a5cc36dfc89616/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe507bee830d9c451bbbdc1f1a5cc36dfc89616/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=cfe507bee830d9c451bbbdc1f1a5cc36dfc89616", "patch": "@@ -606,7 +606,7 @@ dequeue_and_dump (di)\n       if (DECL_CONV_FN_P (t))\n \tdump_string (di, \"conversion\");\n       if (dump_children_p)\n-\tdump_child (\"body\", DECL_INITIAL (t));\n+\tdump_child (\"body\", DECL_SAVED_TREE (t));\n       break;\n \n     case NAMESPACE_DECL:\n@@ -618,6 +618,11 @@ dequeue_and_dump (di)\n \tdump_child (\"dcls\", cp_namespace_decls (t));\n       break;\n \n+    case TEMPLATE_DECL:\n+      if (dump_children_p)\n+\tdump_child (\"spcs\", DECL_TEMPLATE_SPECIALIZATIONS (t));\n+      break;\n+\n     case OVERLOAD:\n       if (dump_children_p)\n \t{"}, {"sha": "924f03fad59e9be94fce683e3acb6bcc3530789e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe507bee830d9c451bbbdc1f1a5cc36dfc89616/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe507bee830d9c451bbbdc1f1a5cc36dfc89616/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cfe507bee830d9c451bbbdc1f1a5cc36dfc89616", "patch": "@@ -2385,6 +2385,7 @@ push_template_decl_real (decl, is_friend)\n   tree ctx;\n   int primary;\n   int is_partial;\n+  int new_template_p = 0;\n \n   /* See if this is a partial specialization.  */\n   is_partial = (DECL_IMPLICIT_TYPEDEF_P (decl)\n@@ -2449,7 +2450,8 @@ push_template_decl_real (decl, is_friend)\n       else\n \t{\n \t  tmpl = build_template_decl (decl, current_template_parms);\n-\t  \n+\t  new_template_p = 1;\n+\n \t  if (DECL_LANG_SPECIFIC (decl)\n \t      && DECL_TEMPLATE_SPECIALIZATION (decl))\n \t    {\n@@ -2560,7 +2562,7 @@ push_template_decl_real (decl, is_friend)\n      that we do not try to push a global template friend declared in a\n      template class; such a thing may well depend on the template\n      parameters of the class.  */\n-  if (! ctx \n+  if (new_template_p && !ctx \n       && !(is_friend && template_class_depth (current_class_type) > 0))\n     tmpl = pushdecl_namespace_level (tmpl);\n "}]}