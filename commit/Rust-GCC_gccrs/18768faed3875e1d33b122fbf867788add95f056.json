{"sha": "18768faed3875e1d33b122fbf867788add95f056", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg3NjhmYWVkMzg3NWUxZDMzYjEyMmZiZjg2Nzc4OGFkZDk1ZjA1Ng==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2013-11-23T19:01:57Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-11-23T19:01:57Z"}, "message": "compiler: Fix backend representation of calls to interface methods.\n\nAlso unify all identical result parameter sets into a single\nstruct type, and fix the use of backend function pointers.\n\n\t* go-gcc.cc (Gcc_backend::function_type): Add result_struct\n\tparameter.\n\nFrom-SVN: r205316", "tree": {"sha": "4b25b8df89857ef87087b3f0a341c0a0d717af7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b25b8df89857ef87087b3f0a341c0a0d717af7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18768faed3875e1d33b122fbf867788add95f056", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18768faed3875e1d33b122fbf867788add95f056", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18768faed3875e1d33b122fbf867788add95f056", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18768faed3875e1d33b122fbf867788add95f056/comments", "author": null, "committer": null, "parents": [{"sha": "7c42f52b7419ea5db30917cf39c15783e5aa2bf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c42f52b7419ea5db30917cf39c15783e5aa2bf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c42f52b7419ea5db30917cf39c15783e5aa2bf5"}], "stats": {"total": 259, "additions": 202, "deletions": 57}, "files": [{"sha": "a7dafac8e7465be0c9846a166ad606bfb904aab4", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18768faed3875e1d33b122fbf867788add95f056/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18768faed3875e1d33b122fbf867788add95f056/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=18768faed3875e1d33b122fbf867788add95f056", "patch": "@@ -1,3 +1,8 @@\n+2013-11-23  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::function_type): Add result_struct\n+\tparameter.\n+\n 2013-11-22  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* go-gcc.cc: Add required include files from gimple.h."}, {"sha": "939be20c3494e742242a8bf2cec5be72a95ce83e", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18768faed3875e1d33b122fbf867788add95f056/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18768faed3875e1d33b122fbf867788add95f056/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=18768faed3875e1d33b122fbf867788add95f056", "patch": "@@ -158,6 +158,7 @@ class Gcc_backend : public Backend\n   function_type(const Btyped_identifier&,\n \t\tconst std::vector<Btyped_identifier>&,\n \t\tconst std::vector<Btyped_identifier>&,\n+\t\tBtype*,\n \t\tconst Location);\n \n   Btype*\n@@ -493,7 +494,8 @@ Btype*\n Gcc_backend::function_type(const Btyped_identifier& receiver,\n \t\t\t   const std::vector<Btyped_identifier>& parameters,\n \t\t\t   const std::vector<Btyped_identifier>& results,\n-\t\t\t   Location location)\n+\t\t\t   Btype* result_struct,\n+\t\t\t   Location)\n {\n   tree args = NULL_TREE;\n   tree* pp = &args;\n@@ -528,29 +530,8 @@ Gcc_backend::function_type(const Btyped_identifier& receiver,\n     result = results.front().btype->get_tree();\n   else\n     {\n-      result = make_node(RECORD_TYPE);\n-      tree field_trees = NULL_TREE;\n-      pp = &field_trees;\n-      for (std::vector<Btyped_identifier>::const_iterator p = results.begin();\n-\t   p != results.end();\n-\t   ++p)\n-\t{\n-\t  const std::string name = (p->name.empty()\n-\t\t\t\t    ? \"UNNAMED\"\n-\t\t\t\t    : p->name);\n-\t  tree name_tree = get_identifier_from_string(name);\n-\t  tree field_type_tree = p->btype->get_tree();\n-\t  if (field_type_tree == error_mark_node)\n-\t    return this->error_type();\n-\t  gcc_assert(TYPE_SIZE(field_type_tree) != NULL_TREE);\n-\t  tree field = build_decl(location.gcc_location(), FIELD_DECL,\n-                                  name_tree, field_type_tree);\n-\t  DECL_CONTEXT(field) = result;\n-\t  *pp = field;\n-\t  pp = &DECL_CHAIN(field);\n-\t}\n-      TYPE_FIELDS(result) = field_trees;\n-      layout_type(result);\n+      gcc_assert(result_struct != NULL);\n+      result = result_struct->get_tree();\n     }\n   if (result == error_mark_node)\n     return this->error_type();"}, {"sha": "8344da40120d5706b34fc51dde7b728a19c6e3fa", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18768faed3875e1d33b122fbf867788add95f056/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18768faed3875e1d33b122fbf867788add95f056/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=18768faed3875e1d33b122fbf867788add95f056", "patch": "@@ -101,11 +101,15 @@ class Backend\n   // is provided so that the names are available.  This should return\n   // not the type of a Go function (which is a pointer to a struct)\n   // but the type of a C function pointer (which will be used as the\n-  // type of the first field of the struct).\n+  // type of the first field of the struct).  If there is more than\n+  // one result, RESULT_STRUCT is a struct type to hold the results,\n+  // and RESULTS may be ignored; if there are zero or one results,\n+  // RESULT_STRUCT is NULL.\n   virtual Btype*\n   function_type(const Btyped_identifier& receiver,\n \t\tconst std::vector<Btyped_identifier>& parameters,\n \t\tconst std::vector<Btyped_identifier>& results,\n+\t\tBtype* result_struct,\n \t\tLocation location) = 0;\n \n   // Get a struct type.\n@@ -121,10 +125,11 @@ class Backend\n   // NAME is the name of the type, and the location is where the named\n   // type is defined.  This function is also used for unnamed function\n   // types with multiple results, in which case the type has no name\n-  // and NAME will be empty.  FOR_FUNCTION is true if this is for a Go\n-  // function type, which corresponds to a C/C++ pointer to function\n-  // type.  The return value will later be passed as the first\n-  // parameter to set_placeholder_pointer_type or\n+  // and NAME will be empty.  FOR_FUNCTION is true if this is for a C\n+  // pointer to function type.  A Go func type is represented as a\n+  // pointer to a struct, and the first field of the struct is a C\n+  // pointer to function.  The return value will later be passed as\n+  // the first parameter to set_placeholder_pointer_type or\n   // set_placeholder_function_type.\n   virtual Btype*\n   placeholder_pointer_type(const std::string& name, Location,"}, {"sha": "4f9368ed255105316b5f835f7cada10cc6f3290d", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18768faed3875e1d33b122fbf867788add95f056/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18768faed3875e1d33b122fbf867788add95f056/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=18768faed3875e1d33b122fbf867788add95f056", "patch": "@@ -9863,8 +9863,11 @@ Call_expression::do_get_tree(Translate_context* context)\n     fndecl = TREE_OPERAND(fndecl, 0);\n \n   // Add a type cast in case the type of the function is a recursive\n-  // type which refers to itself.\n-  if (!DECL_P(fndecl) || !DECL_IS_BUILTIN(fndecl))\n+  // type which refers to itself.  We don't do this for an interface\n+  // method because 1) an interface method never refers to itself, so\n+  // we always have a function type here; 2) we pass an extra first\n+  // argument to an interface method, so fnfield_type is not correct.\n+  if ((!DECL_P(fndecl) || !DECL_IS_BUILTIN(fndecl)) && !is_interface_method)\n     fn = fold_convert_loc(location.gcc_location(), fnfield_type, fn);\n \n   // This is to support builtin math functions when using 80387 math."}, {"sha": "28a5b3201a21ce8b0897a0ba7c67f0d12be73b3d", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 140, "deletions": 24, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18768faed3875e1d33b122fbf867788add95f056/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18768faed3875e1d33b122fbf867788add95f056/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=18768faed3875e1d33b122fbf867788add95f056", "patch": "@@ -1059,8 +1059,9 @@ Type::get_backend_placeholder(Gogo* gogo)\n     {\n     case TYPE_FUNCTION:\n       {\n+\t// A Go function type is a pointer to a struct type.\n \tLocation loc = this->function_type()->location();\n-\tbt = gogo->backend()->placeholder_pointer_type(\"\", loc, true);\n+\tbt = gogo->backend()->placeholder_pointer_type(\"\", loc, false);\n       }\n       break;\n \n@@ -1153,7 +1154,7 @@ Type::finish_backend(Gogo* gogo, Btype *placeholder)\n     case TYPE_FUNCTION:\n       {\n \tBtype* bt = this->do_get_backend(gogo);\n-\tif (!gogo->backend()->set_placeholder_function_type(placeholder, bt))\n+\tif (!gogo->backend()->set_placeholder_pointer_type(placeholder, bt))\n \t  go_assert(saw_errors());\n       }\n       break;\n@@ -3378,6 +3379,48 @@ Function_type::do_hash_for_method(Gogo* gogo) const\n   return ret;\n }\n \n+// Hash result parameters.\n+\n+unsigned int\n+Function_type::Results_hash::operator()(const Typed_identifier_list* t) const\n+{\n+  unsigned int hash = 0;\n+  for (Typed_identifier_list::const_iterator p = t->begin();\n+       p != t->end();\n+       ++p)\n+    {\n+      hash <<= 2;\n+      hash = Type::hash_string(p->name(), hash);\n+      hash += p->type()->hash_for_method(NULL);\n+    }\n+  return hash;\n+}\n+\n+// Compare result parameters so that can map identical result\n+// parameters to a single struct type.\n+\n+bool\n+Function_type::Results_equal::operator()(const Typed_identifier_list* a,\n+\t\t\t\t\t const Typed_identifier_list* b) const\n+{\n+  if (a->size() != b->size())\n+    return false;\n+  Typed_identifier_list::const_iterator pa = a->begin();\n+  for (Typed_identifier_list::const_iterator pb = b->begin();\n+       pb != b->end();\n+       ++pa, ++pb)\n+    {\n+      if (pa->name() != pb->name()\n+\t  || !Type::are_identical(pa->type(), pb->type(), true, NULL))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+// Hash from results to a backend struct type.\n+\n+Function_type::Results_structs Function_type::results_structs;\n+\n // Get the backend representation for a function type.\n \n Btype*\n@@ -3416,23 +3459,57 @@ Function_type::get_backend_fntype(Gogo* gogo)\n         }\n \n       std::vector<Backend::Btyped_identifier> bresults;\n+      Btype* bresult_struct = NULL;\n       if (this->results_ != NULL)\n         {\n           bresults.resize(this->results_->size());\n           size_t i = 0;\n           for (Typed_identifier_list::const_iterator p =\n-                   this->results_->begin(); p != this->results_->end();\n+                   this->results_->begin();\n+\t       p != this->results_->end();\n                ++p, ++i)\n \t    {\n               bresults[i].name = Gogo::unpack_hidden_name(p->name());\n               bresults[i].btype = p->type()->get_backend(gogo);\n               bresults[i].location = p->location();\n             }\n           go_assert(i == bresults.size());\n+\n+\t  if (this->results_->size() > 1)\n+\t    {\n+\t      // Use the same results struct for all functions that\n+\t      // return the same set of results.  This is useful to\n+\t      // unify calls to interface methods with other calls.\n+\t      std::pair<Typed_identifier_list*, Btype*> val;\n+\t      val.first = this->results_;\n+\t      val.second = NULL;\n+\t      std::pair<Results_structs::iterator, bool> ins =\n+\t\tFunction_type::results_structs.insert(val);\n+\t      if (ins.second)\n+\t\t{\n+\t\t  // Build a new struct type.\n+\t\t  Struct_field_list* sfl = new Struct_field_list;\n+\t\t  for (Typed_identifier_list::const_iterator p =\n+\t\t\t this->results_->begin();\n+\t\t       p != this->results_->end();\n+\t\t       ++p)\n+\t\t    {\n+\t\t      Typed_identifier tid = *p;\n+\t\t      if (tid.name().empty())\n+\t\t\ttid = Typed_identifier(\"UNNAMED\", tid.type(),\n+\t\t\t\t\t       tid.location());\n+\t\t      sfl->push_back(Struct_field(tid));\n+\t\t    }\n+\t\t  Struct_type* st = Type::make_struct_type(sfl,\n+\t\t\t\t\t\t\t   this->location());\n+\t\t  ins.first->second = st->get_backend(gogo);\n+\t\t}\n+\t      bresult_struct = ins.first->second;\n+\t    }\n         }\n \n       this->fnbtype_ = gogo->backend()->function_type(breceiver, bparameters,\n-                                                      bresults,\n+                                                      bresults, bresult_struct,\n                                                       this->location());\n \n     }\n@@ -7134,18 +7211,18 @@ Interface_type::get_backend_empty_interface_type(Gogo* gogo)\n   return empty_interface_type;\n }\n \n-// Return the fields of a non-empty interface type.  This is not\n-// declared in types.h so that types.h doesn't have to #include\n-// backend.h.\n+// Return a pointer to the backend representation of the method table.\n \n-static void\n-get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n-\t\t\t     bool use_placeholder,\n-\t\t\t     std::vector<Backend::Btyped_identifier>* bfields)\n+Btype*\n+Interface_type::get_backend_methods(Gogo* gogo)\n {\n-  Location loc = type->location();\n+  if (this->bmethods_ != NULL && !this->bmethods_is_placeholder_)\n+    return this->bmethods_;\n \n-  std::vector<Backend::Btyped_identifier> mfields(type->methods()->size() + 1);\n+  Location loc = this->location();\n+\n+  std::vector<Backend::Btyped_identifier>\n+    mfields(this->all_methods_->size() + 1);\n \n   Type* pdt = Type::make_type_descriptor_ptr_type();\n   mfields[0].name = \"__type_descriptor\";\n@@ -7154,8 +7231,8 @@ get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n \n   std::string last_name = \"\";\n   size_t i = 1;\n-  for (Typed_identifier_list::const_iterator p = type->methods()->begin();\n-       p != type->methods()->end();\n+  for (Typed_identifier_list::const_iterator p = this->all_methods_->begin();\n+       p != this->all_methods_->end();\n        ++p, ++i)\n     {\n       // The type of the method in Go only includes the parameters.\n@@ -7186,21 +7263,56 @@ get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n \t\t\t\t\t\t    ft->location());\n \n       mfields[i].name = Gogo::unpack_hidden_name(p->name());\n-      mfields[i].btype = (use_placeholder\n-\t\t\t  ? mft->get_backend_placeholder(gogo)\n-\t\t\t  : mft->get_backend(gogo));\n+      mfields[i].btype = mft->get_backend_fntype(gogo);\n       mfields[i].location = loc;\n+\n       // Sanity check: the names should be sorted.\n       go_assert(p->name() > last_name);\n       last_name = p->name();\n     }\n \n-  Btype* methods = gogo->backend()->struct_type(mfields);\n+  Btype* st = gogo->backend()->struct_type(mfields);\n+  Btype* ret = gogo->backend()->pointer_type(st);\n+\n+  if (this->bmethods_ != NULL && this->bmethods_is_placeholder_)\n+    gogo->backend()->set_placeholder_pointer_type(this->bmethods_, ret);\n+  this->bmethods_ = ret;\n+  this->bmethods_is_placeholder_ = false;\n+  return ret;\n+}\n+\n+// Return a placeholder for the pointer to the backend methods table.\n+\n+Btype*\n+Interface_type::get_backend_methods_placeholder(Gogo* gogo)\n+{\n+  if (this->bmethods_ == NULL)\n+    {\n+      Location loc = this->location();\n+      this->bmethods_ = gogo->backend()->placeholder_pointer_type(\"\", loc,\n+\t\t\t\t\t\t\t\t  false);\n+      this->bmethods_is_placeholder_ = true;\n+    }\n+  return this->bmethods_;\n+}\n+\n+// Return the fields of a non-empty interface type.  This is not\n+// declared in types.h so that types.h doesn't have to #include\n+// backend.h.\n+\n+static void\n+get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n+\t\t\t     bool use_placeholder,\n+\t\t\t     std::vector<Backend::Btyped_identifier>* bfields)\n+{\n+  Location loc = type->location();\n \n   bfields->resize(2);\n \n   (*bfields)[0].name = \"__methods\";\n-  (*bfields)[0].btype = gogo->backend()->pointer_type(methods);\n+  (*bfields)[0].btype = (use_placeholder\n+\t\t\t ? type->get_backend_methods_placeholder(gogo)\n+\t\t\t : type->get_backend_methods(gogo));\n   (*bfields)[0].location = loc;\n \n   Type* vt = Type::make_pointer_type(Type::make_void_type());\n@@ -7241,7 +7353,7 @@ Interface_type::do_get_backend(Gogo* gogo)\n void\n Interface_type::finish_backend_methods(Gogo* gogo)\n {\n-  if (!this->interface_type()->is_empty())\n+  if (!this->is_empty())\n     {\n       const Typed_identifier_list* methods = this->methods();\n       if (methods != NULL)\n@@ -7251,6 +7363,10 @@ Interface_type::finish_backend_methods(Gogo* gogo)\n \t       ++p)\n \t    p->type()->get_backend(gogo);\n \t}\n+\n+      // Getting the backend methods now will set the placeholder\n+      // pointer.\n+      this->get_backend_methods(gogo);\n     }\n }\n \n@@ -8542,14 +8658,14 @@ Named_type::do_get_backend(Gogo* gogo)\n       if (this->seen_in_get_backend_)\n \t{\n \t  this->is_circular_ = true;\n-\t  return gogo->backend()->circular_pointer_type(bt, true);\n+\t  return gogo->backend()->circular_pointer_type(bt, false);\n \t}\n       this->seen_in_get_backend_ = true;\n       bt1 = Type::get_named_base_btype(gogo, base);\n       this->seen_in_get_backend_ = false;\n       if (this->is_circular_)\n-\tbt1 = gogo->backend()->circular_pointer_type(bt, true);\n-      if (!gogo->backend()->set_placeholder_function_type(bt, bt1))\n+\tbt1 = gogo->backend()->circular_pointer_type(bt, false);\n+      if (!gogo->backend()->set_placeholder_pointer_type(bt, bt1))\n \tbt = gogo->backend()->error_type();\n       return bt;\n "}, {"sha": "d1a739af354643c9f7a7bd4953943a025ba97aed", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18768faed3875e1d33b122fbf867788add95f056/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18768faed3875e1d33b122fbf867788add95f056/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=18768faed3875e1d33b122fbf867788add95f056", "patch": "@@ -1840,6 +1840,27 @@ class Function_type : public Type\n   type_descriptor_params(Type*, const Typed_identifier*,\n \t\t\t const Typed_identifier_list*);\n \n+  // A mapping from a list of result types to a backend struct type.\n+  class Results_hash\n+  {\n+  public:\n+    unsigned int\n+    operator()(const Typed_identifier_list*) const;\n+  };\n+\n+  class Results_equal\n+  {\n+  public:\n+    bool\n+    operator()(const Typed_identifier_list*,\n+\t       const Typed_identifier_list*) const;\n+  };\n+\n+  typedef Unordered_map_hash(Typed_identifier_list*, Btype*,\n+\t\t\t     Results_hash, Results_equal) Results_structs;\n+\n+  static Results_structs results_structs;\n+\n   // The receiver name and type.  This will be NULL for a normal\n   // function, non-NULL for a method.\n   Typed_identifier* receiver_;\n@@ -2552,8 +2573,9 @@ class Interface_type : public Type\n   Interface_type(Typed_identifier_list* methods, Location location)\n     : Type(TYPE_INTERFACE),\n       parse_methods_(methods), all_methods_(NULL), location_(location),\n-      interface_btype_(NULL), assume_identical_(NULL),\n-      methods_are_finalized_(false), seen_(false)\n+      interface_btype_(NULL), bmethods_(NULL), assume_identical_(NULL),\n+      methods_are_finalized_(false), bmethods_is_placeholder_(false),\n+      seen_(false)\n   { go_assert(methods == NULL || !methods->empty()); }\n \n   // The location where the interface type was defined.\n@@ -2620,6 +2642,15 @@ class Interface_type : public Type\n   static Btype*\n   get_backend_empty_interface_type(Gogo*);\n \n+  // Get a pointer to the backend representation of the method table.\n+  Btype*\n+  get_backend_methods(Gogo*);\n+\n+  // Return a placeholder for the backend representation of the\n+  // pointer to the method table.\n+  Btype*\n+  get_backend_methods_placeholder(Gogo*);\n+\n   // Finish the backend representation of the method types.\n   void\n   finish_backend_methods(Gogo*);\n@@ -2686,11 +2717,15 @@ class Interface_type : public Type\n   Location location_;\n   // The backend representation of this type during backend conversion.\n   Btype* interface_btype_;\n+  // The backend representation of the pointer to the method table.\n+  Btype* bmethods_;\n   // A list of interface types assumed to be identical during\n   // interface comparison.\n   mutable Assume_identical* assume_identical_;\n   // Whether the methods have been finalized.\n   bool methods_are_finalized_;\n+  // Whether the bmethods_ field is a placeholder.\n+  bool bmethods_is_placeholder_;\n   // Used to avoid endless recursion in do_mangled_name.\n   mutable bool seen_;\n };"}]}