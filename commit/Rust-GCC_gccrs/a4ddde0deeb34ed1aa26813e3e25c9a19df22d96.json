{"sha": "a4ddde0deeb34ed1aa26813e3e25c9a19df22d96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRkZGRlMGRlZWIzNGVkMWFhMjY4MTNlM2UyNWM5YTE5ZGYyMmQ5Ng==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2004-05-30T14:41:39Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2004-05-30T14:41:39Z"}, "message": "std_complex.h (complex<_Tp>): Properly indent to follow C++STYLE.\n\n\t* include/std/std_complex.h (complex<_Tp>): Properly indent\n\tto follow C++STYLE.\n\t(complex<>::__rep): New.\n\t(__complex_abs): New.  Dispatch to built-ins.\n\t(abs): Use them.\n\t(__complex_arg): New. Dispatch to built-ins.\n\t(arg): Use it.\n\t(__complex_cos): New. Dispatch to built-ins.\n\t(cos): Use it.\n\t(__complex_cosh): New. Dispatch to built-ins.\n\t(cosh): Use it.\n\t(__complex_exp): New. Dispatch to built-ins.\n\t(exp): Use it.\n\t(__complex_log): New. Dispatch to built-ins.\n\t(log): Use it.\n\t(__complex_sin): New. Dispatch to built-ins.\n\t(sin): Use it.\n\t(__complex_sinh): New. Dispatch to built-ins.\n\t(sinh): Use it.\n\t(__complex_sqrt): New. Dispatch to built-ins.\n\t(sqrt): Use it.\n\t(__complex_tan): New. Dispatch to built-ins.\n\t(tan): Use it.\n\t(__complex_tanh): New. Dispatch to built-ins.\n\t(tanh): Use it.\n\t(__complex_pow): New. Dispatch to built-ins.\n\t(pow): Use it.\n\nFrom-SVN: r82453", "tree": {"sha": "d0ec7f7f2658706ccd0e614f24c7c1b4c7927748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0ec7f7f2658706ccd0e614f24c7c1b4c7927748"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4ddde0deeb34ed1aa26813e3e25c9a19df22d96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4ddde0deeb34ed1aa26813e3e25c9a19df22d96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4ddde0deeb34ed1aa26813e3e25c9a19df22d96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4ddde0deeb34ed1aa26813e3e25c9a19df22d96/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606"}], "stats": {"total": 551, "additions": 385, "deletions": 166}, "files": [{"sha": "216b9a9623ac0600217f0715e7b6a846c85cebe9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ddde0deeb34ed1aa26813e3e25c9a19df22d96/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ddde0deeb34ed1aa26813e3e25c9a19df22d96/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a4ddde0deeb34ed1aa26813e3e25c9a19df22d96", "patch": "@@ -1,3 +1,33 @@\n+2004-05-30  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* include/std/std_complex.h (complex<_Tp>): Properly indent\n+\tto follow C++STYLE. \n+\t(complex<>::__rep): New.\n+\t(__complex_abs): New.  Dispatch to built-ins.\n+\t(abs): Use them.\n+\t(__complex_arg): New. Dispatch to built-ins.\n+\t(arg): Use it.\n+\t(__complex_cos): New. Dispatch to built-ins.\n+\t(cos): Use it.\n+\t(__complex_cosh): New. Dispatch to built-ins.\n+\t(cosh): Use it.\n+\t(__complex_exp): New. Dispatch to built-ins.\n+\t(exp): Use it.\n+\t(__complex_log): New. Dispatch to built-ins.\n+\t(log): Use it.\n+\t(__complex_sin): New. Dispatch to built-ins.\n+\t(sin): Use it.\n+\t(__complex_sinh): New. Dispatch to built-ins.\n+\t(sinh): Use it.\n+\t(__complex_sqrt): New. Dispatch to built-ins.\n+\t(sqrt): Use it.\n+\t(__complex_tan): New. Dispatch to built-ins.\n+\t(tan): Use it.\n+\t(__complex_tanh): New. Dispatch to built-ins.\n+\t(tanh): Use it.\n+\t(__complex_pow): New. Dispatch to built-ins.\n+\t(pow): Use it.\n+\n 2004-05-29  Richard B. Kreckel  <Richard.Kreckel@Framatome-ANP.com>\n             Benjamin Kosnik  <bkoz@redhat.com>\n \t"}, {"sha": "097ce3b7f9f48da0d71841f4d1f58786276ede5c", "filename": "libstdc++-v3/include/std/std_complex.h", "status": "modified", "additions": 355, "deletions": 166, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ddde0deeb34ed1aa26813e3e25c9a19df22d96/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ddde0deeb34ed1aa26813e3e25c9a19df22d96/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h?ref=a4ddde0deeb34ed1aa26813e3e25c9a19df22d96", "patch": "@@ -87,7 +87,7 @@ namespace std\n   template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);\n   /// Return @a x to the @a y'th power.\n   template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, \n-\t\t\t\t\t   const complex<_Tp>&);\n+                                          const complex<_Tp>&);\n   /// Return @a x to the @a y'th power.\n   template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);\n   /// Return complex sine of @a z.\n@@ -113,9 +113,8 @@ namespace std\n    *  @param  Tp  Type of real and imaginary values.\n   */\n   template<typename _Tp>\n-    class complex\n+    struct complex\n     {\n-    public:\n       /// Value typedef.\n       typedef _Tp value_type;\n       \n@@ -168,6 +167,8 @@ namespace std\n       template<typename _Up>\n         complex<_Tp>& operator/=(const complex<_Up>&);\n \n+      const complex& __rep() const;\n+\n     private:\n       _Tp _M_real;\n       _Tp _M_imag;\n@@ -305,6 +306,10 @@ namespace std\n       _M_real = __r / __n;\n       return *this;\n     }\n+\n+  template<typename _Tp>\n+    inline const complex<_Tp>&\n+    complex<_Tp>::__rep() const { return *this; }\n     \n   // Operators:\n   //@{\n@@ -542,9 +547,10 @@ namespace std\n     imag(const complex<_Tp>& __z)\n     { return __z.imag(); }\n \n+  // 26.2.7/3 abs(__z):  Returns the magnitude of __z.\n   template<typename _Tp>\n     inline _Tp\n-    abs(const complex<_Tp>& __z)\n+    __complex_abs(const complex<_Tp>& __z)\n     {\n       _Tp __x = __z.real();\n       _Tp __y = __z.imag();\n@@ -553,13 +559,47 @@ namespace std\n         return __s;\n       __x /= __s; \n       __y /= __s;\n-      return __s * sqrt(__x * __x + __y * __y);\n+          return __s * sqrt(__x * __x + __y * __y);\n     }\n \n+  inline float\n+  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }\n+\n+  inline double\n+  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }\n+\n+  inline long double\n+  __complex_abs(const __complex__ long double& __z)\n+  {\n+    return __builtin_cabsl(__z);\n+  }\n+  \n+  template<typename _Tp>\n+    inline _Tp\n+    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }\n+\n+\n+  // 26.2.7/4: arg(__z): Returns the phase angle of __z.\n   template<typename _Tp>\n     inline _Tp\n-    arg(const complex<_Tp>& __z)\n-    { return atan2(__z.imag(), __z.real()); }\n+    __complex_arg(const complex<_Tp>& __z)\n+    {\n+      return  atan2(__z.imag(), __z.real()); \n+    }\n+\n+  inline float\n+  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }\n+\n+  inline double\n+  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }\n+\n+  inline long double\n+  __complex_arg(const __complex__ long double& __z)\n+  { return __builtin_cargl(__z); }\n+\n+  template<typename _Tp>\n+    inline _Tp\n+    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }\n \n   // 26.2.7/5: norm(__z) returns the squared magintude of __z.\n   //     As defined, norm() is -not- a norm is the common mathematical\n@@ -607,60 +647,155 @@ namespace std\n     { return complex<_Tp>(__z.real(), -__z.imag()); }\n   \n   // Transcendentals\n+\n+  // 26.2.8/1 cos(__z):  Returns the cosine of __z.\n   template<typename _Tp>\n     inline complex<_Tp>\n-    cos(const complex<_Tp>& __z)\n+    __complex_cos(const complex<_Tp>& __z)\n     {\n       const _Tp __x = __z.real();\n       const _Tp __y = __z.imag();\n       return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));\n     }\n \n+  inline __complex__ float\n+  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }\n+\n+  inline __complex__ double\n+  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }\n+\n+  inline __complex__ long double\n+  __complex_cos(const __complex__ long double& __z)\n+  { return __builtin_ccosl(__z); }\n+  \n   template<typename _Tp>\n     inline complex<_Tp>\n-    cosh(const complex<_Tp>& __z)\n-    {\n-      const _Tp __x = __z.real();\n-      const _Tp __y = __z.imag();\n-      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));\n-    }\n+    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }\n+\n+  // 26.2.8/2 cosh(__z): Returns the hyperbolic cosine of __z.\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_cosh(const complex<_Tp>& __z)\n+      {\n+        const _Tp __x = __z.real();\n+        const _Tp __y = __z.imag();\n+        return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));\n+      }\n+\n+  inline __complex__ float\n+  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }\n+\n+  inline __complex__ double\n+  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_cosh(const __complex__ long double& __z)\n+  { return __builtin_ccoshl(__z); }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n-    exp(const complex<_Tp>& __z)\n+    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }\n+\n+  // 26.2.8/3 exp(__z): Returns the complex base e exponential of x\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_exp(const complex<_Tp>& __z)\n     { return std::polar(exp(__z.real()), __z.imag()); }\n \n+  inline __complex__ float\n+  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }\n+\n+  inline __complex__ double\n+  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }\n+\n+  inline __complex__ long double\n+    __complex_exp(const __complex__ long double& __z)\n+    { return __builtin_cexpl(__z); }\n+  \n   template<typename _Tp>\n     inline complex<_Tp>\n-    log(const complex<_Tp>& __z)\n+    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }\n+\n+  // 26.2.8/5 log(__z): Reurns the natural complex logaritm of __z.\n+  //                    The branch cut is along the negative axis.\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_log(const complex<_Tp>& __z)\n     { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }\n \n+  /*\n+  inline __complex__ float\n+  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }\n+\n+  inline __complex__ double\n+  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }\n+\n+  inline __complex__ long double\n+  __complex_log(const __complex__ long double& __z)\n+  { return __builtin_clog(__z); } */\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }\n+\n   template<typename _Tp>\n     inline complex<_Tp>\n     log10(const complex<_Tp>& __z)\n     { return std::log(__z) / log(_Tp(10.0)); }\n \n+  // 26.2.8/10 sin(__z): Returns the sine of __z.\n   template<typename _Tp>\n     inline complex<_Tp>\n-    sin(const complex<_Tp>& __z)\n+    __complex_sin(const complex<_Tp>& __z)\n     {\n       const _Tp __x = __z.real();\n       const _Tp __y = __z.imag();\n       return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y)); \n     }\n \n+  inline __complex__ float\n+  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }\n+\n+  inline __complex__ double\n+  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }\n+\n+  inline __complex__ long double\n+  __complex_sin(const __complex__ long double& __z)\n+  { return __builtin_csinl(__z); }\n+\n   template<typename _Tp>\n     inline complex<_Tp>\n-    sinh(const complex<_Tp>& __z)\n+    sin(const complex<_Tp>& __z) { __complex_sin(__z.__rep()); }\n+\n+  // 26.2.8/11 sinh(__z): Returns the hyperbolic sine of __z.\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_sinh(const complex<_Tp>& __z)\n     {\n       const _Tp __x = __z.real();\n       const _Tp  __y = __z.imag();\n       return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));\n     }\n \n+  inline __complex__ float\n+  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }      \n+\n+  inline __complex__ double\n+  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }      \n+\n+  inline __complex__ long double\n+  __complex_sinh(const __complex__ long double& __z)\n+  { return __builtin_csinhl(__z); }      \n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }\n+\n+  // 26.2.8/13 sqrt(__z): Returns the complex square root of __z.\n+  //                     The branch cut is on the negative axis.\n   template<typename _Tp>\n     complex<_Tp>\n-    sqrt(const complex<_Tp>& __z)\n+    __complex_sqrt(const complex<_Tp>& __z)\n     {\n       _Tp __x = __z.real();\n       _Tp __y = __z.imag();\n@@ -680,20 +815,65 @@ namespace std\n         }\n     }\n \n+  inline __complex__ float\n+  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }\n+\n+  inline __complex__ double\n+  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }\n+\n+  inline __complex__ long double\n+  __complex_sqrt(const __complex__ long double& __z)\n+  { return __builtin_csqrtl(__z); }\n+\n   template<typename _Tp>\n     inline complex<_Tp>\n-    tan(const complex<_Tp>& __z)\n-    {\n-      return std::sin(__z) / std::cos(__z);\n-    }\n+    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }\n \n+  // 26.2.8/14 tan(__z):  Return the complex tangent of __z.\n+  \n   template<typename _Tp>\n     inline complex<_Tp>\n-    tanh(const complex<_Tp>& __z)\n-    {\n-      return std::sinh(__z) / std::cosh(__z);\n-    }\n+    __complex_tan(const complex<_Tp>& __z)\n+    { return std::sin(__z) / std::cos(__z); }\n+\n+  inline __complex__ float\n+  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }\n+\n+  inline __complex__ double\n+  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }\n+\n+  inline __complex__ long double\n+  __complex_tan(const __complex__ long double& __z)\n+  { return __builtin_ctanl(__z); }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }\n+\n+  // 26.2.8/15 tanh(__z):  Returns the hyperbolic tangent of __z.\n+  \n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_tanh(const complex<_Tp>& __z)\n+    { return std::sinh(__z) / std::cosh(__z); }\n+\n+  inline __complex__ float\n+  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }\n+\n+  inline __complex__ double\n+  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_tanh(const __complex__ long double& __z)\n+  { return __builtin_ctanhl(__z); }\n \n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }\n+\n+  // 26.2.8/9  pow(__x, __y): Returns the complex power base of __x\n+  //                          raised to the __y-th power.  The branch\n+  //                          cut is on the negative axis.\n   template<typename _Tp>\n     inline complex<_Tp>\n     pow(const complex<_Tp>& __z, int __n)\n@@ -712,12 +892,27 @@ namespace std\n       return std::polar(exp(__y * __t.real()), __y * __t.imag());\n     }\n \n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }\n+\n+  inline __complex__ float\n+  __complex_pow(__complex__ float __x, __complex__ float __y)\n+  { return __builtin_cpowf(__x, __y); }\n+\n+  inline __complex__ double\n+  __complex_pow(__complex__ double __x, __complex__ double __y)\n+  { return __builtin_cpow(__x, __y); }\n+\n+  inline __complex__ long double\n+  __complex_pow(__complex__ long double& __x, __complex__ long double& __y)\n+  { return __builtin_cpowl(__x, __y); }\n+  \n   template<typename _Tp>\n     inline complex<_Tp>\n     pow(const complex<_Tp>& __x, const complex<_Tp>& __y)\n-    {\n-      return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x));\n-    }\n+    { return __complex_pow(__x, __y); }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n@@ -730,52 +925,51 @@ namespace std\n \n   // 26.2.3  complex specializations\n   // complex<float> specialization\n-  template<> class complex<float>\n-  {\n-  public:\n-    typedef float value_type;\n-    \n-    complex(float = 0.0f, float = 0.0f);\n+  template<>\n+    struct complex<float>\n+    {\n+      typedef float value_type;\n+      typedef __complex__ float _ComplexT;\n+\n+      complex(_ComplexT __z) : _M_value(__z) { }\n+\n+      complex(float = 0.0f, float = 0.0f);\n #ifdef _GLIBCXX_BUGGY_COMPLEX\n-    complex(const complex& __z) : _M_value(__z._M_value) { }\n+      complex(const complex& __z) : _M_value(__z._M_value) { }\n #endif\n-    explicit complex(const complex<double>&);\n-    explicit complex(const complex<long double>&);\n-\n-    float& real();\n-    const float& real() const;\n-    float& imag();\n-    const float& imag() const;\n-\n-    complex<float>& operator=(float);\n-    complex<float>& operator+=(float);\n-    complex<float>& operator-=(float);\n-    complex<float>& operator*=(float);\n-    complex<float>& operator/=(float);\n-        \n-    // Let's the compiler synthetize the copy and assignment\n-    // operator.  It always does a pretty good job.\n-    // complex& operator= (const complex&);\n-    template<typename _Tp>\n-      complex<float>&operator=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<float>& operator+=(const complex<_Tp>&);\n-    template<class _Tp>\n-      complex<float>& operator-=(const complex<_Tp>&);\n-    template<class _Tp>\n-      complex<float>& operator*=(const complex<_Tp>&);\n-    template<class _Tp>\n-      complex<float>&operator/=(const complex<_Tp>&);\n-\n-  private:\n-    typedef __complex__ float _ComplexT;\n-    _ComplexT _M_value;\n-\n-    complex(_ComplexT __z) : _M_value(__z) { }\n-        \n-    friend class complex<double>;\n-    friend class complex<long double>;\n-  };\n+      explicit complex(const complex<double>&);\n+      explicit complex(const complex<long double>&);\n+\n+      float& real();\n+      const float& real() const;\n+      float& imag();\n+      const float& imag() const;\n+\n+      complex<float>& operator=(float);\n+      complex<float>& operator+=(float);\n+      complex<float>& operator-=(float);\n+      complex<float>& operator*=(float);\n+      complex<float>& operator/=(float);\n+\n+      // Let's the compiler synthetize the copy and assignment\n+      // operator.  It always does a pretty good job.\n+      // complex& operator= (const complex&);\n+      template<typename _Tp>\n+        complex<float>&operator=(const complex<_Tp>&);\n+      template<typename _Tp>\n+        complex<float>& operator+=(const complex<_Tp>&);\n+      template<class _Tp>\n+        complex<float>& operator-=(const complex<_Tp>&);\n+      template<class _Tp>\n+        complex<float>& operator*=(const complex<_Tp>&);\n+      template<class _Tp>\n+        complex<float>&operator/=(const complex<_Tp>&);\n+\n+      const _ComplexT& __rep() const { return _M_value; }\n+\n+    private:\n+      _ComplexT _M_value;\n+    };\n \n   inline float&\n   complex<float>::real()\n@@ -887,51 +1081,50 @@ namespace std\n \n   // 26.2.3  complex specializations\n   // complex<double> specialization\n-  template<> class complex<double>\n-  {\n-  public:\n-    typedef double value_type;\n+  template<>\n+    struct complex<double>\n+    {\n+      typedef double value_type;\n+      typedef __complex__ double _ComplexT;\n+\n+      complex(_ComplexT __z) : _M_value(__z) { }\n \n-    complex(double  =0.0, double =0.0);\n+      complex(double  = 0.0, double = 0.0);\n #ifdef _GLIBCXX_BUGGY_COMPLEX\n-    complex(const complex& __z) : _M_value(__z._M_value) { }\n+      complex(const complex& __z) : _M_value(__z._M_value) { }\n #endif\n-    complex(const complex<float>&);\n-    explicit complex(const complex<long double>&);\n+      complex(const complex<float>&);\n+      explicit complex(const complex<long double>&);\n+\n+      double& real();\n+      const double& real() const;\n+      double& imag();\n+      const double& imag() const;\n+\n+      complex<double>& operator=(double);\n+      complex<double>& operator+=(double);\n+      complex<double>& operator-=(double);\n+      complex<double>& operator*=(double);\n+      complex<double>& operator/=(double);\n+\n+      // The compiler will synthetize this, efficiently.\n+      // complex& operator= (const complex&);\n+      template<typename _Tp>\n+        complex<double>& operator=(const complex<_Tp>&);\n+      template<typename _Tp>\n+        complex<double>& operator+=(const complex<_Tp>&);\n+      template<typename _Tp>\n+        complex<double>& operator-=(const complex<_Tp>&);\n+      template<typename _Tp>\n+        complex<double>& operator*=(const complex<_Tp>&);\n+      template<typename _Tp>\n+        complex<double>& operator/=(const complex<_Tp>&);\n \n-    double& real();\n-    const double& real() const;\n-    double& imag();\n-    const double& imag() const;\n-        \n-    complex<double>& operator=(double);\n-    complex<double>& operator+=(double);\n-    complex<double>& operator-=(double);\n-    complex<double>& operator*=(double);\n-    complex<double>& operator/=(double);\n-\n-    // The compiler will synthetize this, efficiently.\n-    // complex& operator= (const complex&);\n-    template<typename _Tp>\n-      complex<double>& operator=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<double>& operator+=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<double>& operator-=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<double>& operator*=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<double>& operator/=(const complex<_Tp>&);\n-\n-  private:\n-    typedef __complex__ double _ComplexT;\n-    _ComplexT _M_value;\n-\n-    complex(_ComplexT __z) : _M_value(__z) { }\n-        \n-    friend class complex<float>;\n-    friend class complex<long double>;\n-  };\n+      const _ComplexT& __rep() const { return _M_value; }\n+\n+    private:\n+      _ComplexT _M_value;\n+    };\n \n   inline double&\n   complex<double>::real()\n@@ -1043,51 +1236,50 @@ namespace std\n \n   // 26.2.3  complex specializations\n   // complex<long double> specialization\n-  template<> class complex<long double>\n-  {\n-  public:\n-    typedef long double value_type;\n+  template<>\n+    struct complex<long double>\n+    {\n+      typedef long double value_type;\n+      typedef __complex__ long double _ComplexT;\n \n-    complex(long double = 0.0L, long double = 0.0L);\n+      complex(_ComplexT __z) : _M_value(__z) { }\n+\n+      complex(long double = 0.0L, long double = 0.0L);\n #ifdef _GLIBCXX_BUGGY_COMPLEX\n-    complex(const complex& __z) : _M_value(__z._M_value) { }\n+      complex(const complex& __z) : _M_value(__z._M_value) { }\n #endif\n-    complex(const complex<float>&);\n-    complex(const complex<double>&);\n-\n-    long double& real();\n-    const long double& real() const;\n-    long double& imag();\n-    const long double& imag() const;\n-\n-    complex<long double>& operator= (long double);\n-    complex<long double>& operator+= (long double);\n-    complex<long double>& operator-= (long double);\n-    complex<long double>& operator*= (long double);\n-    complex<long double>& operator/= (long double);\n-\n-    // The compiler knows how to do this efficiently\n-    // complex& operator= (const complex&);\n-    template<typename _Tp>\n-      complex<long double>& operator=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<long double>& operator+=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<long double>& operator-=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<long double>& operator*=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<long double>& operator/=(const complex<_Tp>&);\n-\n-  private:\n-    typedef __complex__ long double _ComplexT;\n-    _ComplexT _M_value;\n-\n-    complex(_ComplexT __z) : _M_value(__z) { }\n-\n-    friend class complex<float>;\n-    friend class complex<double>;\n-  };\n+      complex(const complex<float>&);\n+      complex(const complex<double>&);\n+\n+      long double& real();\n+      const long double& real() const;\n+      long double& imag();\n+      const long double& imag() const;\n+\n+      complex<long double>& operator= (long double);\n+      complex<long double>& operator+= (long double);\n+      complex<long double>& operator-= (long double);\n+      complex<long double>& operator*= (long double);\n+      complex<long double>& operator/= (long double);\n+\n+      // The compiler knows how to do this efficiently\n+      // complex& operator= (const complex&);\n+      template<typename _Tp>\n+        complex<long double>& operator=(const complex<_Tp>&);\n+      template<typename _Tp>\n+        complex<long double>& operator+=(const complex<_Tp>&);\n+      template<typename _Tp>\n+        complex<long double>& operator-=(const complex<_Tp>&);\n+      template<typename _Tp>\n+        complex<long double>& operator*=(const complex<_Tp>&);\n+      template<typename _Tp>\n+        complex<long double>& operator/=(const complex<_Tp>&);\n+\n+      const _ComplexT& __rep() const { return _M_value; }\n+\n+    private:\n+      _ComplexT _M_value;\n+    };\n \n   inline\n   complex<long double>::complex(long double __r, long double __i)\n@@ -1203,30 +1395,27 @@ namespace std\n   // inlining.  It suffices that class specializations be defined.\n   inline\n   complex<float>::complex(const complex<double>& __z)\n-  : _M_value(_ComplexT(__z._M_value)) { }\n+  : _M_value(__z.__rep()) { }\n \n   inline\n   complex<float>::complex(const complex<long double>& __z)\n-  : _M_value(_ComplexT(__z._M_value)) { }\n+  : _M_value(__z.__rep()) { }\n \n   inline\n   complex<double>::complex(const complex<float>& __z) \n-  : _M_value(_ComplexT(__z._M_value)) { }\n+  : _M_value(__z.__rep()) { }\n \n   inline\n   complex<double>::complex(const complex<long double>& __z)\n-  {\n-    __real__ _M_value = __z.real();\n-    __imag__ _M_value = __z.imag();\n-  }\n+    : _M_value(__z.__rep()) { }\n \n   inline\n   complex<long double>::complex(const complex<float>& __z)\n-  : _M_value(_ComplexT(__z._M_value)) { }\n+  : _M_value(__z.__rep()) { }\n \n   inline\n   complex<long double>::complex(const complex<double>& __z)\n-  : _M_value(_ComplexT(__z._M_value)) { }\n+  : _M_value(__z.__rep()) { }\n } // namespace std\n \n #endif\t/* _GLIBCXX_COMPLEX */"}]}