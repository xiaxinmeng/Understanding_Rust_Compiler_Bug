{"sha": "df98a50bb05465d9ad789c039281975230a27188", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY5OGE1MGJiMDU0NjVkOWFkNzg5YzAzOTI4MTk3NTIzMGEyNzE4OA==", "commit": {"author": {"name": "Warren Levy", "email": "warrenl@cygnus.com", "date": "2000-10-27T10:33:46Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "2000-10-27T10:33:46Z"}, "message": "Makefile.am: Added locale files from Classpath.\n\n\t* Makefile.am: Added locale files from Classpath.\n\t* Makefile.in: Rebuilt.\n\t* gnu/java/locale/Calendar.java: New file.\n\t* gnu/java/locale/Calendar_de.java: New file.\n\t* gnu/java/locale/Calendar_en.java: New file.\n\t* gnu/java/locale/Calendar_nl.java: New file.\n\t* java/lang/ClassNotFoundException.java: Replaced with Classpath file.\n\t* java/math/BigDecimal.java (intVal): Renamed from 'num' for\n\tserialization compatibility.\n\t(scale): Made private.\n\t(serialVersionUID): New field.\n\t* java/math/BigInteger.java (ival): Made transient.\n\t(words): Made transient.\n\t(bitCount): New serialization field.\n\t(bitLength): Ditto.\n\t(firstNonzeroByteNum): Ditto.\n\t(lowestSetBit): Ditto.\n\t(magnitude): Ditto.\n\t(signum): Ditto.\n\t(serialVersionUID): New field.\n\t(readObject): New method.\n\t(writeObject): New method.\n\t* java/util/BitSet.java (serialVersionUID): New field.\n\t* java/util/Calendar.java: Replaced with Classpath file.\n\t* java/util/GregorianCalendar.java (GregorianCalendar): Pass result\n\tof getDefault() for TimeZone or Locale instead of passing nulls.\n\t* java/util/Locale.java (serialVersionUID): New field.\n\t(writeObject): New method.\n\t(readObject): New method.\n\t* java/util/SimpleTimeZone.java: Replaced with Classpath file.\n\nSerialization mods.\n\nFrom-SVN: r37080", "tree": {"sha": "c250d6267fbdab1f69cdf85ae2a504f5447570f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c250d6267fbdab1f69cdf85ae2a504f5447570f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df98a50bb05465d9ad789c039281975230a27188", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df98a50bb05465d9ad789c039281975230a27188", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df98a50bb05465d9ad789c039281975230a27188", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df98a50bb05465d9ad789c039281975230a27188/comments", "author": null, "committer": null, "parents": [{"sha": "c11a03240fe13025b4f33184ead72e441d7297b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11a03240fe13025b4f33184ead72e441d7297b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c11a03240fe13025b4f33184ead72e441d7297b0"}], "stats": {"total": 2618, "additions": 2221, "deletions": 397}, "files": [{"sha": "c8c398689c1c024b9e9a8edeafe1d3f18f4bb9ca", "filename": "libjava/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -1,3 +1,36 @@\n+2000-10-27  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* Makefile.am: Added locale files from Classpath.\n+\t* Makefile.in: Rebuilt.\n+\t* gnu/java/locale/Calendar.java: New file.\n+\t* gnu/java/locale/Calendar_de.java: New file.\n+\t* gnu/java/locale/Calendar_en.java: New file.\n+\t* gnu/java/locale/Calendar_nl.java: New file.\n+\t* java/lang/ClassNotFoundException.java: Replaced with Classpath file.\n+\t* java/math/BigDecimal.java (intVal): Renamed from 'num' for\n+\tserialization compatibility.\n+\t(scale): Made private.\n+\t(serialVersionUID): New field.\n+\t* java/math/BigInteger.java (ival): Made transient.\n+\t(words): Made transient.\n+\t(bitCount): New serialization field.\n+\t(bitLength): Ditto.\n+\t(firstNonzeroByteNum): Ditto.\n+\t(lowestSetBit): Ditto.\n+\t(magnitude): Ditto.\n+\t(signum): Ditto.\n+\t(serialVersionUID): New field.\n+\t(readObject): New method.\n+\t(writeObject): New method.\n+\t* java/util/BitSet.java (serialVersionUID): New field.\n+\t* java/util/Calendar.java: Replaced with Classpath file.\n+\t* java/util/GregorianCalendar.java (GregorianCalendar): Pass result\n+\tof getDefault() for TimeZone or Locale instead of passing nulls.\n+\t* java/util/Locale.java (serialVersionUID): New field.\n+\t(writeObject): New method.\n+\t(readObject): New method.\n+\t* java/util/SimpleTimeZone.java: Replaced with Classpath file.\n+\n 2000-10-25  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* Makefile.am (GCJCOMPILE): Pass --tag=GCJ to libtool."}, {"sha": "998968c93f242d02abe527d7cb527ea6c03ba703", "filename": "libjava/Makefile.am", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -998,6 +998,10 @@ gnu/java/io/ObjectIdentityWrapper.java \\\n gnu/java/lang/ArrayHelper.java \\\n gnu/java/lang/ClassHelper.java \\\n gnu/java/lang/reflect/TypeSignature.java \\\n+gnu/java/locale/Calendar.java \\\n+gnu/java/locale/Calendar_de.java \\\n+gnu/java/locale/Calendar_en.java \\\n+gnu/java/locale/Calendar_nl.java \\\n gnu/java/security/provider/Gnu.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\"}, {"sha": "0422a1371f4023dff2ecce1b424e6d2bf766c705", "filename": "libjava/Makefile.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -742,6 +742,10 @@ gnu/java/io/ObjectIdentityWrapper.java \\\n gnu/java/lang/ArrayHelper.java \\\n gnu/java/lang/ClassHelper.java \\\n gnu/java/lang/reflect/TypeSignature.java \\\n+gnu/java/locale/Calendar.java \\\n+gnu/java/locale/Calendar_de.java \\\n+gnu/java/locale/Calendar_en.java \\\n+gnu/java/locale/Calendar_nl.java \\\n gnu/java/security/provider/Gnu.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n@@ -1256,6 +1260,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/io/ObjectIdentityWrapper.P \\\n .deps/gnu/java/lang/ArrayHelper.P .deps/gnu/java/lang/ClassHelper.P \\\n .deps/gnu/java/lang/reflect/TypeSignature.P \\\n+.deps/gnu/java/locale/Calendar.P .deps/gnu/java/locale/Calendar_de.P \\\n+.deps/gnu/java/locale/Calendar_en.P .deps/gnu/java/locale/Calendar_nl.P \\\n .deps/gnu/java/security/provider/Gnu.P \\\n .deps/gnu/java/security/provider/SHA.P \\\n .deps/gnu/java/security/provider/SHA1PRNG.P .deps/interpret.P \\"}, {"sha": "70da30bbe7bdd8c593c33172d3f817897b2cdbce", "filename": "libjava/gnu/java/locale/Calendar.java", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fgnu%2Fjava%2Flocale%2FCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fgnu%2Fjava%2Flocale%2FCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FCalendar.java?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -0,0 +1,112 @@\n+/* Calendar.java -- Default Calendar locale data\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.locale;\n+\n+import java.util.ListResourceBundle;\n+import java.util.Locale;\n+import java.util.Date;\n+\n+/**\n+ * This class contains locale data for java.util.Calendar.<br>\n+ *\n+ * If you localize this to another language only set fields, that\n+ * you change.  See Calendar_de for an example.  Also add your\n+ * locale to this list of availableLocales below in this(!) file.\n+ *\n+ * @author Jochen Hoenicke\n+ */\n+public class Calendar extends ListResourceBundle\n+{\n+  /**\n+   * The locales for which Calendar is localized.\n+   */\n+  private static final Locale[] availableLocales = {\n+    Locale.GERMAN, Locale.ENGLISH, new Locale(\"nl\", \"\")\n+  };\n+\n+  /**\n+   * This is the default calendar class, that is returned on\n+   * java.util.Calendar.getInstance().\n+   * @see java.util.Calendar#getInstance()\n+   */\n+  private static final String calendarClass = \"java.util.GregorianCalendar\";\n+  \n+  /**\n+   * This is used by java.util.Calendar.\n+   * @see java.util.Calendar#getFirstDayOfWeek()\n+   */\n+  private static final Integer firstDayOfWeek\n+    = new Integer(java.util.Calendar.SUNDAY);\n+  /**\n+   * This is used by java.util.Calendar.\n+   * @see java.util.Calendar#getMinimalDaysInFirstWeek()\n+   */\n+  private static final Integer minimalDaysInFirstWeek = new Integer(1);\n+\n+  /**\n+   * The point at which the Gregorian calendar rules were used.\n+   * The default for most catholic\n+   * countries is midnight (UTC) on October 5, 1582 (Julian),\n+   * or October 15, 1582 (Gregorian).\n+   * @see java.util.GregorianCalendar#getGregorianCutOver\n+   */\n+  /* If you change this date be aware, that this formular does only \n+   * work for months from MARCH to DECEMBER and doesn't work in \n+   * leap years (look in java.util.GregorianCalendar.getDayOfYear for\n+   * more info).\n+   */\n+  private static final Date gregorianCutOver = new Date\n+  ((24*60*60*1000L) *\n+   (((1582*(365*4+1))/4 + \n+     (java.util.Calendar.OCTOBER*(31+30+31+30+31) - 9) / 5 + 5) -\n+    ((1970*(365*4+1))/4 + 1 - 13)));\n+  \n+  /**\n+   * This is the object array used to hold the keys and values\n+   * for this bundle\n+   */\n+  private static final Object[][] contents =\n+  {\n+    { \"availableLocales\", availableLocales },\n+    { \"calendarClass\", calendarClass },\n+    { \"firstDayOfWeek\", firstDayOfWeek },\n+    { \"minimalDaysInFirstWeek\", minimalDaysInFirstWeek },\n+    { \"gregorianCutOver\", gregorianCutOver }\n+  };\n+\n+  /**\n+   * This method returns the object array of key, value pairs containing\n+   * the data for this bundle.\n+   *\n+   * @return The key, value information.\n+   */\n+  public Object[][] getContents()\n+  {\n+    return(contents);\n+  }\n+}"}, {"sha": "45ed5b77d647834be753e1dba336ff9be2e88962", "filename": "libjava/gnu/java/locale/Calendar_de.java", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fgnu%2Fjava%2Flocale%2FCalendar_de.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fgnu%2Fjava%2Flocale%2FCalendar_de.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FCalendar_de.java?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -0,0 +1,60 @@\n+/* Calendar_de.java -- German calendar locale data\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.locale;\n+\n+import java.util.ListResourceBundle;\n+import java.util.Calendar;\n+\n+/**\n+ * This class contains locale data for java.util.Calendar specific for \n+ * german language.\n+ * @author Jochen Hoenicke\n+ */\n+public class Calendar_de extends ListResourceBundle\n+{\n+  /**\n+   * This is the object array used to hold the keys and values\n+   * for this bundle\n+   */\n+  private static final Object[][] contents =\n+  {\n+    { \"firstDayOfWeek\", new Integer(Calendar.MONDAY) },\n+    { \"minimalDaysInFirstWeek\", new Integer(4) },\n+  };\n+\n+  /**\n+   * This method returns the object array of key, value pairs containing\n+   * the data for this bundle.\n+   *\n+   * @return The key, value information.\n+   */\n+  public Object[][] getContents()\n+  {\n+    return contents;\n+  }\n+}"}, {"sha": "7bd0512e9806ac792f82862f8a7b82b19bad7f8f", "filename": "libjava/gnu/java/locale/Calendar_en.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fgnu%2Fjava%2Flocale%2FCalendar_en.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fgnu%2Fjava%2Flocale%2FCalendar_en.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FCalendar_en.java?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -0,0 +1,59 @@\n+/* Calendar_en.java -- English calendar locale data\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.locale;\n+\n+import java.util.ListResourceBundle;\n+import java.util.Calendar;\n+\n+/**\n+ * This class contains locale data for java.util.Calendar specific for \n+ * english language.\n+ * @author Jochen Hoenicke\n+ */\n+public class Calendar_en extends ListResourceBundle\n+{\n+  /**\n+   * This is the object array used to hold the keys and values\n+   * for this bundle\n+   */\n+  private static final Object[][] contents =\n+  {\n+    /* Use default values. */\n+  };\n+\n+  /**\n+   * This method returns the object array of key, value pairs containing\n+   * the data for this bundle.\n+   *\n+   * @return The key, value information.\n+   */\n+  public Object[][] getContents()\n+  {\n+    return contents;\n+  }\n+}"}, {"sha": "1c46012a289ea4447d7c414e3e051fd91724b593", "filename": "libjava/gnu/java/locale/Calendar_nl.java", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fgnu%2Fjava%2Flocale%2FCalendar_nl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fgnu%2Fjava%2Flocale%2FCalendar_nl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FCalendar_nl.java?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -0,0 +1,63 @@\n+/* Calendar_nl.java -- Dutch calendar locale data\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.locale;\n+\n+import java.util.ListResourceBundle;\n+import java.util.Calendar;\n+\n+/**\n+ * This class contains locale data for java.util.Calendar specific for \n+ * dutch language.\n+ * @author Mark Wielaard\n+ */\n+public class Calendar_nl extends ListResourceBundle\n+{\n+  /**\n+   * This is the object array used to hold the keys and values\n+   * for this bundle\n+   */\n+  private static final Object[][] contents =\n+  {\n+    { \"firstDayOfWeek\", new Integer(Calendar.MONDAY) },\n+\n+    /* XXX - I guess the default for gregorianCutover \n+     * is also true for the Netherlands. But is it?\n+     */\n+  };\n+\n+  /**\n+   * This method returns the object array of key, value pairs containing\n+   * the data for this bundle.\n+   *\n+   * @return The key, value information.\n+   */\n+  public Object[][] getContents()\n+  {\n+    return contents;\n+  }\n+}"}, {"sha": "3ce89ea6596eff6ee19d2f15b488f03d37eded0a", "filename": "libjava/java/lang/ClassNotFoundException.java", "status": "modified", "additions": 153, "deletions": 50, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Flang%2FClassNotFoundException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Flang%2FClassNotFoundException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassNotFoundException.java?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -1,61 +1,164 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* ClassNotFoundException.java -- exception thrown when attempting to load\n+   a class when no definition for the class can be found.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n package java.lang;\n- \n+\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 18, 1998.  \n+ * Exceptions may be thrown by one part of a Java program and caught\n+ * by another in order to deal with exceptional conditions.  This \n+ * exception can by thrown by specific methods of <code>ClassLoader</code>\n+ * and <code>Class</code> when attempting to load a class when no definition\n+ * for the specified class can be found.\n+ *\n+ * @since JDK 1.0\n+ * \n+ * @author Brian Jones\n  */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n- \n public class ClassNotFoundException extends Exception\n {\n-  // TODO12:\n-  // Throwable ex;\n+  static final long serialVersionUID = 9176873029745254542L;\n \n+  private Throwable ex = null;\n+  \n+  /**\n+   * Create an exception without a message.\n+   */\n   public ClassNotFoundException()\n-  {\n-    super();\n-  }\n-\n-  // TODO12:\n-  // public ClassNotFoundException(String msg, Throwable ex)\n-  // {\n-  //   FIXME: Set 'ex' here.\n-  // }\n-\n-  public ClassNotFoundException(String msg)\n-  {\n-    super(msg);\n-  }\n-\n-  // TODO12:\n-  // public Throwable getException()\n-  // {\n-  // }\n-\n-  // TBD: if this needs to be implemented\n-  // public void printStackTrace()\n-  // {\n-  // }\n-\n-  // TBD: if this needs to be implemented\n-  // public void printStackTrace(PrintStream ps)\n-  // {\n-  // }\n-\n-  // TBD: if this needs to be implemented\n-  // public void printStackTrace(PrintWriter pw)\n-  // {\n-  // }\n+    {\n+      super();\n+    }\n+\n+  /**\n+   * Create an exception with a message.\n+   */\n+  public ClassNotFoundException(String s)\n+    {\n+      super(s);\n+    }\n+\n+  /**\n+   * Create an exception with a message and include the exception \n+   * which occurred while loading the class.\n+   *\n+   * @param ex the exception which occurred while loading the class\n+   *\n+   * @since JDK 1.2\n+   */\n+  public ClassNotFoundException(String s, Throwable ex)\n+    {\n+      super(s);\n+      this.ex = ex;\n+    }\n+\n+  /**\n+   * Returns the exception which occurred while loading the class, \n+   * otherwise returns null.\n+   * \n+   * @since JDK 1.2\n+   */\n+  public Throwable getException()\n+    {\n+      return ex;\n+    }\n+\n+  /**\n+   * Print a stack trace of the exception that occurred.\n+   */\n+  public void printStackTrace()\n+    {\n+      if (ex == null)\n+        {\n+          super.printStackTrace();\n+        }\n+      else\n+        {\n+          ex.printStackTrace();\n+        }\n+    }\n+\n+  /**\n+   * Print a stack trace of the exception that occurred to \n+   * the specified <code>PrintStream</code>.\n+   */\n+  public void printStackTrace(PrintStream ps)\n+    {\n+      if (ex == null)\n+        {\n+          super.printStackTrace(ps);\n+        }\n+      else\n+        {\n+          ex.printStackTrace(ps);\n+        }\n+    }\n+\n+  /**\n+   * Print a stack trace of the exception that occurred to \n+   * the specified <code>PrintWriter</code>.\n+   */\n+  public void printStackTrace(PrintWriter pw)\n+    {\n+      if (ex == null)\n+        {\n+          super.printStackTrace(pw);\n+        }\n+      else\n+        {\n+          ex.printStackTrace(pw);\n+        }\n+    }\n+\n+  /**\n+   * Serialize the object in a manner binary compatible with the JDK 1.2\n+   */\n+  private void writeObject(java.io.ObjectOutputStream s) \n+    throws IOException\n+    {\n+      ObjectOutputStream.PutField oFields;\n+      oFields = s.putFields();\n+      oFields.put(\"ex\", this.ex);\n+      s.writeFields(); \n+    }\n+\n+  /**\n+   * Deserialize the object in a manner binary compatible with the JDK 1.2\n+   */    \n+  private void readObject(java.io.ObjectInputStream s)\n+    throws IOException, ClassNotFoundException\n+    {\n+      ObjectInputStream.GetField oFields;\n+      oFields = s.readFields();\n+      ex = (Throwable)oFields.get(\"ex\", (Throwable)null);\n+    }\n }"}, {"sha": "6844b24961ab4810f7b4478f126e1bc4b20aec9e", "filename": "libjava/java/math/BigDecimal.java", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Fmath%2FBigDecimal.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Fmath%2FBigDecimal.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fmath%2FBigDecimal.java?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -29,8 +29,9 @@\n import java.math.BigInteger;\n \n public class BigDecimal extends Number implements Comparable {\n-  BigInteger num;\n-  int scale;\n+  private BigInteger intVal;\n+  private int scale;\n+  private static final long serialVersionUID = 6108874887143696463L;\n \n   private final static BigDecimal ZERO = \n     new BigDecimal (BigInteger.valueOf (0), 0);\n@@ -56,7 +57,7 @@ public BigDecimal (BigInteger num, int scale) throws NumberFormatException\n   {\n     if (scale < 0) \n       throw new NumberFormatException (\"scale of \" + scale + \" is < 0\");\n-    this.num = num;\n+    this.intVal = num;\n     this.scale = scale;\n   }\n \n@@ -68,7 +69,7 @@ public BigDecimal (double num) throws NumberFormatException\n   public BigDecimal (String num) throws NumberFormatException \n   {\n     int point = num.indexOf('.');\n-    this.num = new BigInteger (point == -1 ? num :\n+    this.intVal = new BigInteger (point == -1 ? num :\n \t\t\t       num.substring (0, point) + \n \t\t\t       num.substring (point + 1));\n     scale = num.length() - (point == -1 ? num.length () : point + 1);\n@@ -99,8 +100,8 @@ public BigDecimal add (BigDecimal val)\n     // For addition, need to line up decimals.  Note that the movePointRight\n     // method cannot be used for this as it might return a BigDecimal with\n     // scale == 0 instead of the scale we need.\n-    BigInteger op1 = num;\n-    BigInteger op2 = val.num;\n+    BigInteger op1 = intVal;\n+    BigInteger op2 = val.intVal;\n     if (scale < val.scale)\n       op1 = op1.multiply (BigInteger.valueOf (10).pow (val.scale - scale));\n     else if (scale > val.scale)\n@@ -116,7 +117,7 @@ public BigDecimal subtract (BigDecimal val)\n \n   public BigDecimal multiply (BigDecimal val) \n   {\n-    return new BigDecimal (num.multiply (val.num), scale + val.scale);\n+    return new BigDecimal (intVal.multiply (val.intVal), scale + val.scale);\n   }\n \n   public BigDecimal divide (BigDecimal val, int roundingMode) \n@@ -135,13 +136,13 @@ public BigDecimal divide(BigDecimal val, int newScale, int roundingMode)\n     if (scale < 0)\n       throw new ArithmeticException (\"scale is negative: \" + scale);\n \n-    if (num.signum () == 0)\t// handle special case of 0.0/0.0\n+    if (intVal.signum () == 0)\t// handle special case of 0.0/0.0\n       return ZERO;\n     \n-    BigInteger dividend = num.multiply (BigInteger.valueOf (10).pow \n+    BigInteger dividend = intVal.multiply (BigInteger.valueOf (10).pow \n \t\t\t\t\t(newScale + 1 - (scale - val.scale)));\n     \n-    BigInteger parts[] = dividend.divideAndRemainder (val.num);\n+    BigInteger parts[] = dividend.divideAndRemainder (val.intVal);\n //      System.out.println(\"int: \" + parts[0]);\n //      System.out.println(\"rem: \" + parts[1]);\n \n@@ -194,12 +195,12 @@ public BigDecimal divide(BigDecimal val, int newScale, int roundingMode)\n   public int compareTo (BigDecimal val) \n   {\n     if (scale == val.scale)\n-      return num.compareTo (val.num);\n+      return intVal.compareTo (val.intVal);\n \n     BigInteger thisParts[] = \n-      num.divideAndRemainder (BigInteger.valueOf (10).pow (scale));\n+      intVal.divideAndRemainder (BigInteger.valueOf (10).pow (scale));\n     BigInteger valParts[] =\n-      val.num.divideAndRemainder (BigInteger.valueOf (10).pow (val.scale));\n+      val.intVal.divideAndRemainder (BigInteger.valueOf (10).pow (val.scale));\n     \n     int compare;\n     if ((compare = thisParts[0].compareTo (valParts[0])) != 0)\n@@ -263,7 +264,7 @@ public BigDecimal min (BigDecimal val)\n \n   public BigDecimal movePointLeft (int n)\n   {\n-    return (n < 0) ? movePointRight (-n) : new BigDecimal (num, scale + n);\n+    return (n < 0) ? movePointRight (-n) : new BigDecimal (intVal, scale + n);\n   }\n \n   public BigDecimal movePointRight (int n)\n@@ -272,15 +273,15 @@ public BigDecimal movePointRight (int n)\n       return movePointLeft (-n);\n \n     if (scale >= n)\n-      return new BigDecimal (num, scale - n);\n+      return new BigDecimal (intVal, scale - n);\n \n-    return new BigDecimal (num.multiply \n+    return new BigDecimal (intVal.multiply \n \t\t\t   (BigInteger.valueOf (10).pow (n - scale)), 0);\n   }\n \n   public int signum () \n   {\n-    return num.signum ();\n+    return intVal.signum ();\n   }\n \n   public int scale () \n@@ -290,17 +291,17 @@ public int scale ()\n   \n   public BigDecimal abs () \n   {\n-    return new BigDecimal (num.abs (), scale);\n+    return new BigDecimal (intVal.abs (), scale);\n   }\n \n   public BigDecimal negate () \n   {\n-    return new BigDecimal (num.negate (), scale);\n+    return new BigDecimal (intVal.negate (), scale);\n   }\n \n   public String toString () \n   {\n-    String bigStr = num.toString();\n+    String bigStr = intVal.toString();\n     if (scale == 0) \n       return bigStr;\n \n@@ -322,7 +323,8 @@ public String toString ()\n \n   public BigInteger toBigInteger () \n   {\n-    return scale == 0 ? num : num.divide (BigInteger.valueOf (10).pow (scale));\n+    return scale == 0 ? intVal :\n+      intVal.divide (BigInteger.valueOf (10).pow (scale));\n   }\n \n \f"}, {"sha": "ed1f4f044cbea516c294ed65103465e904d82aff", "filename": "libjava/java/math/BigInteger.java", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Fmath%2FBigInteger.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Fmath%2FBigInteger.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fmath%2FBigInteger.java?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -11,6 +11,9 @@\n package java.math;\n import gnu.gcj.math.*;\n import java.util.Random;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.IOException;\n \n /**\n  * @author Warren Levy <warrenl@cygnus.com>\n@@ -35,8 +38,17 @@ public class BigInteger extends Number implements Comparable\n    * If words == null, the ival is the value of this BigInteger.\n    * Otherwise, the first ival elements of words make the value\n    * of this BigInteger, stored in little-endian order, 2's-complement form. */\n-  private int ival;\n-  private int[] words;\n+  transient private int ival;\n+  transient private int[] words;\n+\n+  // Serialization fields.\n+  private int bitCount = -1;\n+  private int bitLength = -1;\n+  private int firstNonzeroByteNum = -2;\n+  private int lowestSetBit = -2;\n+  private byte[] magnitude;\n+  private int signum;\n+  private static final long serialVersionUID = -8287574255936472291L;\n \n \n   /** We pre-allocate integers in the range minFixNum..maxFixNum. */\n@@ -2201,4 +2213,22 @@ public int bitCount()\n       }\n     return isNegative() ? x_len * 32 - i : i;\n   }\n+\n+  private void readObject(ObjectInputStream s)\n+    throws IOException, ClassNotFoundException\n+  {\n+    s.defaultReadObject();\n+    words = byteArrayToIntArray(magnitude, signum < 0 ? -1 : 0);\n+    BigInteger result = make(words, words.length);\n+    this.ival = result.ival;\n+    this.words = result.words;\n+  }\n+\n+  private void writeObject(ObjectOutputStream s)\n+    throws IOException, ClassNotFoundException\n+  {\n+    signum = signum();\n+    magnitude = toByteArray();\n+    s.defaultWriteObject();\n+  }\n }"}, {"sha": "b40da61f3d68ef2202d37d56989ace83d5970d72", "filename": "libjava/java/util/BitSet.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Futil%2FBitSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Futil%2FBitSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBitSet.java?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -174,4 +174,5 @@ private final void ensure (int lastElt)\n \n   // The actual bits.\n   private long[] bits;\n+  private static final long serialVersionUID = 7997698588986878753L;\n }"}, {"sha": "f31577a9dcfc8512943aba3e46c1bde1c5eb23fe", "filename": "libjava/java/util/Calendar.java", "status": "modified", "additions": 879, "deletions": 175, "changes": 1054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Futil%2FCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Futil%2FCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCalendar.java?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -1,274 +1,978 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* java.util.Calendar\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n+import java.lang.reflect.InvocationTargetException;\n+import java.io.*;\n \n /**\n- * @author Per Bothner <bothner@cygnus.com>\n- * @date October 24, 1998.\n+ * This class is an abstract base class for Calendars, which can be\n+ * used to convert between <code>Date</code> objects and a set of\n+ * integer fields which represent <code>YEAR</code>,\n+ * <code>MONTH</code>, <code>DAY</code>, etc.  The <code>Date</code>\n+ * object represents a time in milliseconds since the Epoch. <br>\n+ * \n+ * This class is locale sensitive.  To get the Object matching the\n+ * current locale you can use <code>getInstance</code>.  You can even provide\n+ * a locale or a timezone.  <code>getInstance</code> returns currently\n+ * a <code>GregorianCalendar</code> for the current date. <br>\n+ *\n+ * If you want to convert a date from the Year, Month, Day, DayOfWeek,\n+ * etc.  Representation to a <code>Date</code>-Object, you can create\n+ * a new Calendar with <code>getInstance()</code>,\n+ * <code>clear()</code> all fields, <code>set(int,int)</code> the\n+ * fields you need and convert it with <code>getTime()</code>. <br>\n+ *\n+ * If you want to convert a <code>Date</code>-object to the Calendar\n+ * representation, create a new Calendar, assign the\n+ * <code>Date</code>-Object with <code>setTime()</code>, and read the\n+ * fields with <code>get(int)</code>. <br>\n+ *\n+ * When computing the date from time fields, it may happen, that there\n+ * are either two few fields set, or some fields are inconsistent.  This\n+ * cases will handled in a calender specific way.  Missing fields are\n+ * replaced by the fields of the epoch: 1970 January 1 00:00. <br>\n+ *\n+ * To understand, how the day of year is computed out of the fields\n+ * look at the following table.  It is traversed from top to bottom,\n+ * and for the first line all fields are set, that line is used to\n+ * compute the day. <br>\n+ *\n+ * <pre>\n+ * month + day_of_month\n+ * month + week_of_month + day_of_week\n+ * month + day_of_week_of_month + day_of_week\n+ * day_of_year\n+ * day_of_week + week_of_year\n+ * </pre>\n+ * \n+ * The hour_of_day-field takes precedence over the ampm and\n+ * hour_of_ampm fields. <br>\n+ *\n+ * <STRONG>Note:</STRONG> This can differ for non-Gregorian calendar. <br>\n+ *\n+ * To convert a calendar to a human readable form and vice versa,  use\n+ * the <code>java.text.DateFormat</code> class. <br>\n+ * \n+ * Other useful things you can do with an calendar, is\n+ * <code>roll</code>ing fields (that means increase/decrease a\n+ * specific field by one, propagating overflows), or\n+ * <code>add</code>ing/substracting a fixed amount to a field.\n+ *\n+ * @see Date\n+ * @see GregorianCalendar\n+ * @see TimeZone\n+ * @see java.text.DateFormat \n  */\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3,\n- * and \"The Java Language Specification\", ISBN 0-201-63451-1.\n- * Status:  Unimplemented:  getAvailableLocales.\n- *   No Locale knowledge.\n- */\n-\n-public abstract class Calendar implements java.io.Serializable, Cloneable\n+public abstract class Calendar implements Serializable, Cloneable\n {\n-  public final static int JANUARY = 0;\n-  public final static int FEBRUARY = 1;\n-  public final static int MARCH = 2;\n-  public final static int APRIL = 3;\n-  public final static int MAY = 4;\n-  public final static int JUNE = 5;\n-  public final static int JULY = 6;\n-  public final static int AUGUST = 7;\n-  public final static int SEPTEMBER = 8;\n-  public final static int OCTOBER = 9;\n-  public final static int NOVEMBER = 10;\n-  public final static int DECEMBER = 11;\n-  public final static int UNDECIMBER = 12;\n-\n-  public final static int SUNDAY = 1;\n-  public final static int MONDAY = 2;\n-  public final static int TUESDAY = 3;\n-  public final static int WEDNESDAY = 4;\n-  public final static int THURSDAY = 5;\n-  public final static int FRIDAY = 6;\n-  public final static int SATURDAY = 7;\n-\n-  public final static int AM = 0;\n-  public final static int PM = 1;\n-\n-  public final static int FIELD_COUNT = 17;\n-\n-  // These constants are not docuemnted, but were determined using\n-  // a simple test program.\n-  public final static int ERA = 0;\n-  public final static int YEAR = 1;\n-  public final static int MONTH = 2;\n-  public final static int WEEK_OF_YEAR = 3;\n-  public final static int WEEK_OF_MONTH = 4;\n-  public final static int DATE = 5;\n-  public final static int DAY_OF_MONTH = 5;\n-  public final static int DAY_OF_YEAR = 6;\n-  public final static int DAY_OF_WEEK = 7;\n-  public final static int DAY_OF_WEEK_IN_MONTH = 8;\n-  public final static int AM_PM = 9;\n-  public final static int HOUR = 10;\n-  public final static int HOUR_OF_DAY = 11;\n-  public final static int MINUTE = 12;\n-  public final static int SECOND = 13;\n-  public final static int MILLISECOND = 14;\n-  public final static int ZONE_OFFSET = 15;\n-  public final static int DST_OFFSET = 16;\n-\n-  // The fields are as specified in Sun's \"Serialized Form\"\n-  // in the JDK 1.2 beta 4 API specification.\n-  protected boolean areFieldsSet;\n-  protected int[] fields;\n-  private int firstDayOfWeek;\n-  protected boolean[] isSet;\n+  /**\n+   * Constant representing the era time field.\n+   */\n+  public static final int ERA = 0;\n+  /**\n+   * Constant representing the year time field.\n+   */\n+  public static final int YEAR = 1;\n+  /**\n+   * Constant representing the month time field.  This field\n+   * should contain one of the JANUARY,...,DECEMBER constants below.\n+   */\n+  public static final int MONTH = 2;\n+  /**\n+   * Constant representing the week of the year field.\n+   * @see #setFirstDayOfWeek(int)\n+   */\n+  public static final int WEEK_OF_YEAR = 3;\n+  /**\n+   * Constant representing the week of the month time field.\n+   * @see #setFirstDayOfWeek(int)\n+   */\n+  public static final int WEEK_OF_MONTH = 4;\n+  /**\n+   * Constant representing the day time field, synonym for DAY_OF_MONTH.\n+   */\n+  public static final int DATE = 5;\n+  /**\n+   * Constant representing the day time field.\n+   */\n+  public static final int DAY_OF_MONTH = 5;\n+  /**\n+   * Constant representing the day of year time field.  This is\n+   * 1 for the first day in month.\n+   */\n+  public static final int DAY_OF_YEAR = 6;\n+  /**\n+   * Constant representing the day of week time field.  This field\n+   * should contain one of the SUNDAY,...,SATURDAY constants below.\n+   */\n+  public static final int DAY_OF_WEEK = 7;\n+  /**\n+   * Constant representing the day-of-week-in-month field.  For\n+   * instance this field contains 2 for the second thursday in a\n+   * month.  If you give a negative number here, the day will count\n+   * from the end of the month.\n+   */\n+  public static final int DAY_OF_WEEK_IN_MONTH = 8;\n+  /**\n+   * Constant representing the part of the day for 12-hour clock.  This\n+   * should be one of AM or PM.\n+   */\n+  public static final int AM_PM = 9;\n+  /**\n+   * Constant representing the hour time field for 12-hour clock.\n+   */\n+  public static final int HOUR = 10;\n+  /**\n+   * Constant representing the hour of day time field for 24-hour clock.\n+   */\n+  public static final int HOUR_OF_DAY = 11;\n+  /**\n+   * Constant representing the minute of hour time field.\n+   */\n+  public static final int MINUTE = 12;\n+  /**\n+   * Constant representing the second time field.\n+   */\n+  public static final int SECOND = 13;\n+  /**\n+   * Constant representing the millisecond time field.\n+   */\n+  public static final int MILLISECOND = 14;\n+  /**\n+   * Constant representing the time zone offset time field for the\n+   * time given in the other fields.  It is measured in\n+   * milliseconds.  The default is the offset of the time zone.  \n+   */\n+  public static final int ZONE_OFFSET = 15;\n+  /**\n+   * Constant representing the daylight saving time offset in\n+   * milliseconds.  The default is the value given by the time zone.  \n+   */\n+  public static final int DST_OFFSET = 16;\n+  /**\n+   * Number of time fields.\n+   */\n+  public static final int FIELD_COUNT = 17;\n+\n+  /**\n+   * Constant representing Sunday.\n+   */\n+  public static final int SUNDAY = 1;\n+  /**\n+   * Constant representing Monday.\n+   */\n+  public static final int MONDAY = 2;\n+  /**\n+   * Constant representing Tuesday.\n+   */\n+  public static final int TUESDAY = 3;\n+  /**\n+   * Constant representing Wednesday.\n+   */\n+  public static final int WEDNESDAY = 4;\n+  /**\n+   * Constant representing Thursday.\n+   */\n+  public static final int THURSDAY = 5;\n+  /**\n+   * Constant representing Friday.\n+   */\n+  public static final int FRIDAY = 6;\n+  /**\n+   * Constant representing Saturday.\n+   */\n+  public static final int SATURDAY = 7;\n+\n+  /**\n+   * Constant representing January.\n+   */\n+  public static final int JANUARY = 0;\n+  /**\n+   * Constant representing February.\n+   */\n+  public static final int FEBRUARY = 1;\n+  /**\n+   * Constant representing March.\n+   */\n+  public static final int MARCH = 2;\n+  /**\n+   * Constant representing April.\n+   */\n+  public static final int APRIL = 3;\n+  /**\n+   * Constant representing May.\n+   */\n+  public static final int MAY = 4;\n+  /**\n+   * Constant representing June.\n+   */\n+  public static final int JUNE = 5;\n+  /**\n+   * Constant representing July.\n+   */\n+  public static final int JULY = 6;\n+  /**\n+   * Constant representing August.\n+   */\n+  public static final int AUGUST = 7;\n+  /**\n+   * Constant representing September.\n+   */\n+  public static final int SEPTEMBER = 8;\n+  /**\n+   * Constant representing October.\n+   */\n+  public static final int OCTOBER = 9;\n+  /**\n+   * Constant representing November.\n+   */\n+  public static final int NOVEMBER = 10;\n+  /**\n+   * Constant representing December.\n+   */\n+  public static final int DECEMBER = 11;\n+  /**\n+   * Constant representing Undecimber. This is an artifical name useful\n+   * for lunar calendars.\n+   */\n+  public static final int UNDECIMBER = 12;\n+\n+  /**\n+   * Useful constant for 12-hour clock.\n+   */\n+  public static final int AM = 0;\n+  /**\n+   * Useful constant for 12-hour clock.\n+   */\n+  public static final int PM = 1;\n+\n+  /**\n+   * The time fields.  The array is indexed by the constants YEAR to\n+   * DST_OFFSET.\n+   * @serial\n+   */\n+  protected int[] fields = new int[FIELD_COUNT];\n+  /**\n+   * The flags which tell if the fields above have a value.\n+   * @serial\n+   */\n+  protected boolean[] isSet = new boolean[FIELD_COUNT];\n+  /**\n+   * The time in milliseconds since the epoch.\n+   * @serial\n+   */\n+  protected long time;\n+  /**\n+   * Tells if the above field has a valid value.\n+   * @serial\n+   */\n   protected boolean isTimeSet;\n+  /**\n+   * Tells if the fields have a valid value.  This superseeds the isSet\n+   * array.\n+   * @serial\n+   */\n+  protected boolean areFieldsSet;\n+\n+  /**\n+   * The time zone of this calendar.  Used by sub classes to do UTC / local\n+   * time conversion.  Sub classes can access this field with getTimeZone().\n+   * @serial\n+   */\n+  private TimeZone zone;\n+\n+  /**\n+   * Specifies if the date/time interpretation should be lenient.\n+   * If the flag is set, a date such as \"February 30, 1996\" will be\n+   * treated as the 29th day after the February 1.  If this flag\n+   * is false, such dates will cause an exception.\n+   * @serial\n+   */\n   private boolean lenient;\n+\n+  /**\n+   * Sets what the first day of week is.  This is used for\n+   * WEEK_OF_MONTH and WEEK_OF_YEAR fields. \n+   * @serial\n+   */\n+  private int firstDayOfWeek;\n+\n+  /**\n+   * Sets how many days are required in the first week of the year.\n+   * If the first day of the year should be the first week you should\n+   * set this value to 1.  If the first week must be a full week, set\n+   * it to 7.\n+   * @serial\n+   */\n   private int minimalDaysInFirstWeek;\n-  private int nextStamp;\n-  //private int serialVersionOnStream;\n-  protected long time;\n-  private TimeZone zone;\n \n-  protected Calendar ()\n+  /**\n+   * The version of the serialized data on the stream. \n+   * <dl><dt>0 or not present</dt>\n+   * <dd> JDK 1.1.5 or later.</dd>\n+   * <dl><dt>1</dt>\n+   * <dd>JDK 1.1.6 or later.  This always writes a correct `time' value\n+   * on the stream, as well as the other fields, to be compatible with\n+   * earlier versions</dd>\n+   * @since JDK1.1.6\n+   * @serial\n+   */\n+  private int serialVersionOnStream = 1;\n+\n+  /**\n+   * XXX - I have not checked the compatibility.  The documentation of\n+   * the serialized-form is quite hairy...\n+   */\n+  static final long serialVersionUID = -1807547505821590642L;\n+\n+  /**\n+   * The name of the resource bundle.\n+   */\n+  private static final String bundleName = \"gnu.java.locale.Calendar\";\n+\n+  /**\n+   * Constructs a new Calender with the default time zone and the default\n+   * locale.\n+   */\n+  protected Calendar()\n   {\n-    this (null, null);\n+    this(TimeZone.getDefault(), Locale.getDefault());\n   }\n \n-  protected Calendar (TimeZone zone, Locale loc)\n+  /**\n+   * Constructs a new Calender with the given time zone and the given\n+   * locale.\n+   * @param zone a time zone.\n+   * @param locale a locale.\n+   */\n+  protected Calendar(TimeZone zone, Locale locale)\n   {\n-    fields = new int[FIELD_COUNT];\n-    isSet = new boolean[FIELD_COUNT];\n-    firstDayOfWeek = SUNDAY;  // Locale-dependent.  FIXME.\n-    this.zone = zone != null ? zone : TimeZone.getDefault();\n-  }\n+    this.zone = zone;\n+    lenient = true;\n \n-  public Object clone ()\n-  {\n-    try\n-      {\n-\treturn super.clone();\n-      }\n-    catch (CloneNotSupportedException ex)\n-      {\n-\tthrow new RuntimeException(\"internal error - \"+ex);\n-      }\n+    ResourceBundle rb = ResourceBundle.getBundle(bundleName, locale);\n+\n+    firstDayOfWeek = ((Integer) rb.getObject(\"firstDayOfWeek\")).intValue();\n+    minimalDaysInFirstWeek =\n+      ((Integer) rb.getObject(\"minimalDaysInFirstWeek\")).intValue();\n   }\n \n-  public String toString ()\n+  /**\n+   * Creates a calendar representing the actual time, using the default\n+   * time zone and locale.\n+   */\n+  public static synchronized Calendar getInstance()\n   {\n-    // We have much latitude in how we implement this.\n-    return (\"areFieldsSet \" + areFieldsSet\n-\t    + \"; fields \" + fields\n-\t    + \"; firstDayOfWeek \" + firstDayOfWeek\n-\t    + \"; isSet \" + isSet\n-\t    + \"; isTimeSet \" + isTimeSet\n-\t    + \"; lenient \" + lenient\n-\t    + \"; minimalDaysInFirstWeek \" + minimalDaysInFirstWeek\n-\t    + \"; nextStamp \" + nextStamp\n-\t    + \"; time \" + time\n-\t    + \"; zone \" + zone);\n+    return getInstance(TimeZone.getDefault(), Locale.getDefault());\n   }\n \n-  public static Calendar getInstance ()\n+  /**\n+   * Creates a calendar representing the actual time, using the given\n+   * time zone and the default locale.\n+   * @param zone a time zone.\n+   */\n+  public static synchronized Calendar getInstance(TimeZone zone)\n   {\n-    return new GregorianCalendar ();\n+    return getInstance(zone, Locale.getDefault());\n   }\n \n-  public static Calendar getInstance (TimeZone zone)\n+  /**\n+   * Creates a calendar representing the actual time, using the default\n+   * time zone and the given locale.\n+   * @param locale a locale.\n+   */\n+  public static synchronized Calendar getInstance(Locale locale)\n   {\n-    return new GregorianCalendar (zone);\n+    return getInstance(TimeZone.getDefault(), locale);\n   }\n \n-  public static Calendar getInstance (Locale locale)\n+  /**\n+   * Creates a calendar representing the actual time, using the given\n+   * time zone and locale.\n+   * @param zone a time zone.\n+   * @param locale a locale.\n+   */\n+  public static synchronized Calendar getInstance(TimeZone zone, Locale locale)\n   {\n-    return new GregorianCalendar (locale);\n+    String calendarClassName = null;\n+    ResourceBundle rb = ResourceBundle.getBundle(bundleName, locale);\n+    calendarClassName = rb.getString(\"calendarClass\");\n+    if (calendarClassName != null)\n+      {\n+\ttry\n+\t  {\n+\t    Class calendarClass = Class.forName(calendarClassName);\n+\t    if (Calendar.class.isAssignableFrom(calendarClass))\n+\t      {\n+\t\treturn (Calendar) calendarClass.getConstructor(\n+\t\t  new Class[] { TimeZone.class, Locale.class}\n+\t\t).newInstance(new Object[] {zone, locale} );\n+\t      }\n+\t  }\n+\tcatch (ClassNotFoundException ex) {}\n+\tcatch (IllegalAccessException ex) {}\n+\tcatch (NoSuchMethodException ex) {}\n+\tcatch (InstantiationException ex) {}\n+\tcatch (InvocationTargetException ex) {}\n+\t// XXX should we ignore these errors or throw an exception ?\n+      }\n+    return new GregorianCalendar(zone, locale);\n   }\n \n-  public static Calendar getInstance (TimeZone zone, Locale locale)\n+  /**\n+   * Gets the set of locales for which a Calendar is availiable.\n+   * @exception MissingResourceException if locale data couldn't be found.\n+   * @return the set of locales.\n+   */\n+  public static synchronized Locale[] getAvailableLocales()\n   {\n-    return new GregorianCalendar (zone, locale);\n+    ResourceBundle rb = ResourceBundle.getBundle(bundleName,\n+\t\t\t\t\t\t new Locale(\"\", \"\"));\n+    return (Locale[]) rb.getObject(\"availableLocales\");\n   }\n \n-  public boolean isLenient() { return lenient; }\n-  public void setLenient (boolean lenient) { this.lenient = lenient; }\n+  /**\n+   * Converts the time field values (<code>fields</code>) to\n+   * milliseconds since the epoch UTC (<code>time</code>).  Override\n+   * this method if you write your own Calendar.  */\n+  protected abstract void computeTime();\n \n-  public int getFirstDayOfWeek ()\n+  /**\n+   * Converts the milliseconds since the epoch UTC\n+   * (<code>time</code>) to time fields\n+   * (<code>fields</code>). Override this method if you write your\n+   * own Calendar.  \n+   */\n+  protected abstract void computeFields();\n+\n+  /**\n+   * Converts the time represented by this object to a\n+   * <code>Date</code>-Object.\n+   * @return the Date.\n+   */\n+  public final Date getTime()\n   {\n-    return firstDayOfWeek;\n+    if (!isTimeSet)\n+      computeTime();\n+    return new Date(time);\n   }\n \n-  public void setFirstDayOfWeek (int value)\n+  /**\n+   * Sets this Calender's time to the given Date.  All time fields\n+   * are invalidated by this method.\n+   */\n+  public final void setTime(Date date)\n   {\n-    firstDayOfWeek = value;\n+    setTimeInMillis(date.getTime());\n   }\n \n-  public int getMinimalDaysInFirstWeek ()\n+  /**\n+   * Returns the time represented by this Calendar.\n+   * @return the time in milliseconds since the epoch.\n+   */\n+  protected long getTimeInMillis()\n   {\n-    return minimalDaysInFirstWeek;\n+    if (!isTimeSet)\n+      computeTime();\n+    return time;\n   }\n \n-  public void setMinimalDaysInFirstWeek (int value)\n+  /**\n+   * Sets this Calender's time to the given Time.  All time fields\n+   * are invalidated by this method.\n+   * @param time the time in milliseconds since the epoch\n+   */\n+  protected void setTimeInMillis(long time)\n   {\n-    minimalDaysInFirstWeek = value;\n+    this.time = time;\n+    isTimeSet = true;\n+    computeFields();\n   }\n \n-  public TimeZone getTimeZone ()\n+  /**\n+   * Gets the value of the specified field.  They are recomputed\n+   * if they are invalid.\n+   * @param field the time field. One of the time field constants.\n+   * @return the value of the specified field\n+   */\n+  public final int get(int field)\n   {\n-    return zone;\n+    complete();\n+    return fields[field];\n   }\n \n-  public void setTimeZone (TimeZone tz)\n+  /**\n+   * Gets the value of the specified field. This method doesn't \n+   * recompute the fields, if they are invalid.\n+   * @param field the time field. One of the time field constants.\n+   * @return the value of the specified field, undefined if\n+   * <code>areFieldsSet</code> or <code>isSet[field]</code> is false.\n+   */\n+  protected final int internalGet(int field)\n   {\n-    zone = tz;\n+    return fields[field];\n   }\n \n-  abstract public void add(int fld, int amount);\n-  abstract public void roll (int fld, boolean up);\n+  /**\n+   * Sets the time field with the given value.  This does invalidate\n+   * the time in milliseconds.\n+   * @param field the time field. One of the time field constants\n+   * @param value the value to be set.\n+   */\n+  public final void set(int field, int value)\n+  {\n+    if (!areFieldsSet)\n+      computeFields();\n+    isTimeSet = false;\n+    fields[field] = value;\n+    isSet[field] = true;\n+  }\n \n-  public final void set (int year, int month, int date)\n+  /**\n+   * Sets the fields for year, month, and date\n+   * @param year the year.\n+   * @param month the month, one of the constants JANUARY..UNDICEMBER.\n+   * @param date the day of the month\n+   */\n+  public final void set(int year, int month, int date)\n   {\n-    set(YEAR, year);\n-    set(MONTH, month);\n-    set(DATE, date);\n+    if (!areFieldsSet)\n+      computeFields();\n+    isTimeSet = false;\n+    fields[YEAR] = year;\n+    fields[MONTH] = month;\n+    fields[DATE] = date;\n+    isSet[YEAR] = isSet[MONTH] = isSet[DATE] = true;\n   }\n \n-  public final void set (int year, int month, int date, int hour, int minute)\n+  /**\n+   * Sets the fields for year, month, date, hour, and minute\n+   * @param year the year.\n+   * @param month the month, one of the constants JANUARY..UNDICEMBER.\n+   * @param date the day of the month\n+   * @param hour the hour of day.\n+   * @param minute the minute.\n+   */\n+  public final void set(int year, int month, int date, int hour, int minute)\n   {\n     set(year, month, date);\n-    set(HOUR_OF_DAY, hour);\n-    set(MINUTE, minute);\n+    fields[HOUR] = hour;\n+    fields[MINUTE] = minute;\n+    isSet[HOUR] = isSet[MINUTE] = true;\n   }\n \n-  public final void set (int year, int month, int date,\n-\t\t\t int hour, int minute, int second)\n+  /**\n+   * Sets the fields for year, month, date, hour, and minute\n+   * @param year the year.\n+   * @param month the month, one of the constants JANUARY..UNDICEMBER.\n+   * @param date the day of the month\n+   * @param hour the hour of day.\n+   * @param minute the minute.\n+   * @param second the second.\n+   */\n+  public final void set(int year, int month, int date,\n+\t\t\tint hour, int minute, int second)\n   {\n     set(year, month, date, hour, minute);\n-    set(SECOND, second);\n+    fields[SECOND] = second;\n+    isSet[SECOND] = true;\n   }\n \n-  public final void set (int fld, int value)\n+  /**\n+   * Clears the values of all the time fields.\n+   */\n+  public final void clear()\n   {\n-    if (! areFieldsSet) computeFields();\n-    fields[fld] = value;\n     isTimeSet = false;\n+    areFieldsSet = false;\n+    for (int i = 0; i < FIELD_COUNT; i++)\n+      isSet[i] = false;\n   }\n \n-  public final void clear (int fld)\n+  /**\n+   * Clears the values of the specified time field.\n+   * @param field the time field. One of the time field constants.\n+   */\n+  public final void clear(int field)\n   {\n-    fields[fld] = 0;\n-    isSet[fld] = false;\n+    isTimeSet = false;\n     areFieldsSet = false;\n+    isSet[field] = false;\n+  }\n+\n+  /**\n+   * Determines if the specified field has a valid value.\n+   * @return true if the specified field has a value.\n+   */\n+  public final boolean isSet(int field)\n+  {\n+    return isSet[field];\n+  }\n+\n+  /**\n+   * Fills any unset fields in the time field list\n+   * @return true if the specified field has a value.  \n+   */\n+  protected void complete()\n+  {\n+    if (!isTimeSet)\n+      computeTime();\n+    if (!areFieldsSet)\n+      computeFields();\n   }\n \n-  public final void clear ()\n+  /**\n+   * Compares the given calender with this.  \n+   * @param o the object to that we should compare.\n+   * @return true, if the given object is a calendar, that represents\n+   * the same time (but doesn't neccessary have the same fields).\n+   */\n+  public boolean equals(Object o)\n   {\n-    for (int fld = FIELD_COUNT;  --fld >= 0; )\n+    return (o instanceof Calendar)\n+      && getTimeInMillis() == ((Calendar) o).getTimeInMillis();\n+  }\n+\n+  /**\n+   * Returns a hash code for this calendar.\n+   * @return a hash code, which fullfits the general contract of \n+   * <code>hashCode()</code>\n+   */\n+  public int hashCode()\n+  {\n+    long time = getTimeInMillis();\n+    return (int) ((time & 0xffffffffL) ^ (time >> 32));\n+  }\n+\n+  /**\n+   * Compares the given calender with this.  \n+   * @param o the object to that we should compare.\n+   * @return true, if the given object is a calendar, and this calendar\n+   * represents a smaller time than the calender o.\n+   * @exception ClassCastException if o is not an calendar.\n+   * @since JDK1.2 you don't need to override this method\n+   */\n+  public boolean before(Object o)\n+  {\n+    return getTimeInMillis() < ((Calendar) o).getTimeInMillis();\n+  }\n+\n+  /**\n+   * Compares the given calender with this.  \n+   * @param o the object to that we should compare.\n+   * @return true, if the given object is a calendar, and this calendar\n+   * represents a bigger time than the calender o.\n+   * @exception ClassCastException if o is not an calendar.\n+   * @since JDK1.2 you don't need to override this method\n+   */\n+  public boolean after(Object o)\n+  {\n+    return getTimeInMillis() > ((Calendar) o).getTimeInMillis();\n+  }\n+\n+  /**\n+   * Adds the specified amount of time to the given time field.  The\n+   * amount may be negative to subtract the time.  If the field overflows\n+   * it does what you expect: Jan, 25 + 10 Days is Feb, 4.\n+   * @param field the time field. One of the time field constants.\n+   * @param amount the amount of time.\n+   */\n+  public abstract void add(int field, int amount);\n+\n+  /**\n+   * Rolls the specified time field up or down.  This means add one\n+   * to the specified field, but don't change the other fields.  If\n+   * the maximum for this field is reached, start over with the \n+   * minimum value.  <br>\n+   *\n+   * <strong>Note:</strong> There may be situation, where the other\n+   * fields must be changed, e.g rolling the month on May, 31. \n+   * The date June, 31 is automatically converted to July, 1.\n+   * @param field the time field. One of the time field constants.\n+   * @param up the direction, true for up, false for down.\n+   */\n+  public abstract void roll(int field, boolean up);\n+\n+  /**\n+   * Rolls up or down the specified time field by the given amount.\n+   * A negative amount rolls down.  The default implementation is\n+   * call <code>roll(int, boolean)</code> for the specified amount.\n+   *\n+   * Subclasses should override this method to do more intuitiv things.\n+   *\n+   * @param field the time field. One of the time field constants.\n+   * @param amount the amount to roll by, positive for rolling up,\n+   * negative for rolling down.  \n+   * @since JDK1.2\n+   */\n+  public void roll(int field, int amount)\n+  {\n+    while (amount > 0)\n       {\n-\tfields[fld] = 0;\n-\tisSet[fld] = false;\n+\troll(field, true);\n+\tamount--;\n+      }\n+    while (amount < 0)\n+      {\n+\troll(field, false);\n+\tamount++;\n       }\n-    areFieldsSet = false;\n   }\n \n-  protected void complete()\n+\n+  /**\n+   * Sets the time zone to the specified value.\n+   * @param zone the new time zone\n+   */\n+  public void setTimeZone(TimeZone zone)\n   {\n-    if (!isTimeSet) computeTime();\n-    if (!areFieldsSet) computeFields();\n+    this.zone = zone;\n   }\n \n-  protected abstract void computeFields();\n-  protected abstract void computeTime();\n+  /**\n+   * Gets the time zone of this calendar\n+   * @return the current time zone.\n+   */\n+  public TimeZone getTimeZone()\n+  {\n+    return zone;\n+  }\n \n-  protected final int internalGet (int fld) { return fields[fld]; }\n+  /**\n+   * Specifies if the date/time interpretation should be lenient.\n+   * If the flag is set, a date such as \"February 30, 1996\" will be\n+   * treated as the 29th day after the February 1.  If this flag\n+   * is false, such dates will cause an exception.\n+   * @param lenient true, if the date should be interpreted linient,\n+   * false if it should be interpreted strict.\n+   */\n+  public void setLenient(boolean lenient)\n+  {\n+    this.lenient = lenient;\n+  }\n \n-  public final int get(int fld)\n+  /**\n+   * Tells if the date/time interpretation is lenient.\n+   * @return true, if the date should be interpreted linient,\n+   * false if it should be interpreted strict.\n+   */\n+  public boolean isLenient()\n   {\n-    complete();\n-    return fields[fld];\n+    return lenient;\n   }\n \n-  public abstract boolean after (Object cal);\n-  public abstract boolean before (Object cal);\n-  public abstract boolean equals (Object obj);\n+  /**\n+   * Sets what the first day of week is.  This is used for\n+   * WEEK_OF_MONTH and WEEK_OF_YEAR fields. \n+   * @param value the first day of week.  One of SUNDAY to SATURDAY.\n+   */\n+  public void setFirstDayOfWeek(int value)\n+  {\n+    firstDayOfWeek = value;\n+  }\n \n-  protected long getTimeInMillis()\n+  /**\n+   * Gets what the first day of week is.  This is used for\n+   * WEEK_OF_MONTH and WEEK_OF_YEAR fields. \n+   * @return the first day of week.  One of SUNDAY to SATURDAY.\n+   */\n+  public int getFirstDayOfWeek()\n   {\n-    if (!isTimeSet) computeTime();\n-    return time;\n+    return firstDayOfWeek;\n   }\n \n-  public final Date getTime() { return new Date(getTimeInMillis()); }\n+  /**\n+   * Sets how many days are required in the first week of the year.\n+   * If the first day of the year should be the first week you should\n+   * set this value to 1.  If the first week must be a full week, set\n+   * it to 7.\n+   * @param value the minimal days required in the first week.\n+   */\n+  public void setMinimalDaysInFirstWeek(int value)\n+  {\n+    minimalDaysInFirstWeek = value;\n+  }\n \n-  public final void setTime (Date date)\n+  /**\n+   * Gets how many days are required in the first week of the year.\n+   * @return the minimal days required in the first week.\n+   * @see #setMinimalDaysInFirstWeek\n+   */\n+  public int getMinimalDaysInFirstWeek()\n   {\n-    setTimeInMillis(date.getTime());\n+    return minimalDaysInFirstWeek;\n   }\n \n-  protected void setTimeInMillis (long millis)\n+  /**\n+   * Gets the smallest value that is allowed for the specified field.\n+   * @param field the time field. One of the time field constants.\n+   * @return the smallest value.\n+   */\n+  public abstract int getMinimum(int field);\n+\n+  /**\n+   * Gets the biggest value that is allowed for the specified field.\n+   * @param field the time field. One of the time field constants.\n+   * @return the biggest value.\n+   */\n+  public abstract int getMaximum(int field);\n+\n+\n+  /**\n+   * Gets the greatest minimum value that is allowed for the specified field.\n+   * @param field the time field. One of the time field constants.\n+   * @return the greatest minimum value.\n+   */\n+  public abstract int getGreatestMinimum(int field);\n+\n+  /**\n+   * Gets the smallest maximum value that is allowed for the\n+   * specified field.  For example this is 28 for DAY_OF_MONTH.\n+   * @param field the time field. One of the time field constants.\n+   * @return the least maximum value.  \n+   */\n+  public abstract int getLeastMaximum(int field);\n+\n+  /**\n+   * Gets the actual minimum value that is allowed for the specified field.\n+   * This value is dependant on the values of the other fields.\n+   * @param field the time field. One of the time field constants.\n+   * @return the actual minimum value.\n+   * @since jdk1.2\n+   */\n+  // FIXME: XXX: Not abstract in JDK 1.2.\n+  // public abstract int getActualMinimum(int field);\n+\n+  /**\n+   * Gets the actual maximum value that is allowed for the specified field.\n+   * This value is dependant on the values of the other fields.\n+   * @param field the time field. One of the time field constants.\n+   * @return the actual maximum value.  \n+   * @since jdk1.2\n+   */\n+  // FIXME: XXX: Not abstract in JDK 1.2.\n+  // public abstract int getActualMaximum(int field);\n+\n+  /**\n+   * Return a clone of this object.\n+   */\n+  public Object clone()\n   {\n-    time = millis;\n-    isTimeSet = true;\n-    clear();\n+    try\n+      {\n+\tCalendar cal = (Calendar) super.clone();\n+\tcal.fields = (int[]) fields.clone();\n+\tcal.isSet = (boolean[])isSet.clone();\n+\treturn cal;\n+      }\n+    catch (CloneNotSupportedException ex)\n+      {\n+\treturn null;\n+      }\n   }\n \n-  abstract public int getMaximum(int fld);\n-  abstract public int getMinimum(int fld);\n-  abstract public int getGreatestMinimum(int fld);\n-  abstract public int getLeastMaximum(int fld);\n+  private final static String[] fieldNames = {\n+    \",ERA=\", \",YEAR=\", \",MONTH=\",\n+    \",WEEK_OF_YEAR=\", \",WEEK_OF_MONTH=\",\n+    \",DAY_OF_MONTH=\", \",DAY_OF_YEAR=\", \",DAY_OF_WEEK=\",\n+    \",DAY_OF_WEEK_IN_MONTH=\",\n+    \",AM_PM=\", \",HOUR=\", \",HOUR_OF_DAY=\",\n+    \",MINUTE=\", \",SECOND=\", \",MILLISECOND=\",\n+    \",ZONE_OFFSET=\", \",DST_OFFSET=\"\n+  };\n+\n+\n+  /**\n+   * Returns a string representation of this object.  It is mainly\n+   * for debugging purposes and its content is implementation\n+   * specific.\n+   */\n+  public String toString()\n+  {\n+    StringBuffer sb = new StringBuffer();\n+    sb.append(getClass().getName()).append('[');\n+    sb.append(\"time=\");\n+    if (isTimeSet)\n+      sb.append(time);\n+    else\n+      sb.append(\"?\");\n+    sb.append(\",zone=\" + zone);\n+    sb.append(\",areFieldsSet=\" + areFieldsSet);\n+    for (int i = 0; i < FIELD_COUNT; i++)\n+      {\n+\tsb.append(fieldNames[i]);\n+\tif (isSet[i])\n+\t  sb.append(fields[i]);\n+\telse\n+\t  sb.append(\"?\");\n+      }\n+    sb.append(\",lenient=\").append(lenient);\n+    sb.append(\",firstDayOfWeek=\").append(firstDayOfWeek);\n+    sb.append(\",minimalDaysInFirstWeek=\").append(minimalDaysInFirstWeek);\n+    sb.append(\"]\");\n+    return sb.toString();\n+  }\n \n-  public final boolean isSet(int fld) { return isSet[fld]; }\n+  /**\n+   * Saves the state of the object to the stream.  Ideally we would\n+   * only write the time field, but we need to be compatible with\n+   * earlier versions. <br>\n+   *\n+   * This doesn't write the JDK1.1 field nextStamp to the stream, as\n+   * I don't know what it is good for, and because the documentation\n+   * says, that it could be omitted.  */\n+  private void writeObject(ObjectOutputStream stream) throws IOException\n+  {\n+    if (!isTimeSet)\n+      computeTime();\n+    stream.defaultWriteObject();\n+  }\n+\n+  /**\n+   * Reads the object back from stream (deserialization).\n+   */\n+  private void readObject(ObjectInputStream stream)\n+    throws IOException, ClassNotFoundException\n+  {\n+    stream.defaultReadObject();\n+    if (!isTimeSet)\n+      computeTime();\n+\n+    if (serialVersionOnStream > 1)\n+      {\n+\t// This is my interpretation of the serial number:\n+\t// Sun wants to remove all fields from the stream someday\n+\t// and will then increase the serialVersion number again.\n+\t// We prepare to be compatible.\n+\n+\tfields = new int[FIELD_COUNT];\n+\tisSet = new boolean[FIELD_COUNT];\n+\tareFieldsSet = false;\n+      }\n+  }\n }"}, {"sha": "bef7828d56c3e20a09b89f2e29582b0bb790126c", "filename": "libjava/java/util/GregorianCalendar.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FGregorianCalendar.java?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -93,17 +93,17 @@ public class GregorianCalendar extends Calendar {\n \n   public GregorianCalendar ()\n   {\n-    this(null, null);\n+    this(TimeZone.getDefault (), Locale.getDefault ());\n   }\n \n   public GregorianCalendar (TimeZone zone)\n   {\n-    this (zone, null);\n+    this (zone, Locale.getDefault ());\n   }\n \n   public GregorianCalendar (Locale locale)\n   {\n-    this (null, locale);\n+    this (TimeZone.getDefault (), locale);\n   }\n \n   public GregorianCalendar (TimeZone zone, Locale locale)"}, {"sha": "c9e1e2cb0f565a4d0b3a92f08e37d8b9b120b6f5", "filename": "libjava/java/util/Locale.java", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Futil%2FLocale.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Futil%2FLocale.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLocale.java?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -26,6 +26,7 @@ public final class Locale implements java.io.Serializable, Cloneable\n   private String language;\n   private String variant;\n   private static Locale defaultLocale;\n+  private static final long serialVersionUID = 9149081749638150636L;\n \n   // These are as specified in the JDK 1.2 AP documentation\n \n@@ -145,4 +146,28 @@ public String toString ()\n       }\n     return result.toString();\n   }\n+\n+ /**\n+   * @serialdata According to jdk1.2 the hashcode should always be \n+   * written as -1; \n+   */\n+  private void writeObject(java.io.ObjectOutputStream output)\n+    throws java.io.IOException\n+  {\n+    int tmpHashcode = hashcode;\n+    hashcode = -1;\n+    output.defaultWriteObject();\n+    hashcode = tmpHashcode;\n+  }\n+\n+  /**\n+   * @serialdata  According to jdk1.2 the hashCode is always invalid\n+   * and must be recomputed.\n+   */\n+  private void readObject(java.io.ObjectInputStream input)\n+    throws java.io.IOException, ClassNotFoundException\n+  {\n+    input.defaultReadObject();\n+    hashcode = language.hashCode() ^ country.hashCode() ^ variant.hashCode();\n+  }\n }"}, {"sha": "4fc05e4c19cce375cf59feb37815c39033e01b30", "filename": "libjava/java/util/SimpleTimeZone.java", "status": "modified", "additions": 767, "deletions": 145, "changes": 912, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Futil%2FSimpleTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df98a50bb05465d9ad789c039281975230a27188/libjava%2Fjava%2Futil%2FSimpleTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FSimpleTimeZone.java?ref=df98a50bb05465d9ad789c039281975230a27188", "patch": "@@ -1,208 +1,830 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* java.util.SimpleTimeZone\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-package java.util;\n-\n-/**\n- * @author Per Bothner <bothner@cygnus.com>\n- * @date October 24, 1998.\n- */\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3.\n- * Status:  Does not know how to figure out if daylight savings time\n- *   is in effect;  hence only correct for zones without DST.\n- *   No known spec for hashCode.\n- */\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n \n-public class SimpleTimeZone extends TimeZone\n-{\n-  // The fields are as specified in Sun's \"Serialized Form\"\n-  // in the JDK 1.2 beta 4 API specification.\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-  int dstSavings = 60 * 60 * 1000;\n \n-  int rawOffset;\n+package java.util;\n \n-  // int serialVersionOnStream;\n+import java.text.DateFormatSymbols;\n \n-  int startDay;\n-  int startDayOfWeek;\n-  int startMode;  /// Seems to be JDK 1.2 only.\n+/**\n+ * This class represents a simple time zone offset and handles\n+ * daylight savings.  It can only handle one daylight savings rule, so\n+ * it can't represent historical changes.\n+ *\n+ * This object is tightly bound to the Gregorian calendar.  It assumes\n+ * a regular seven days week, and the month lengths are that of the\n+ * Gregorian Calendar.  It can only handle daylight savings for years\n+ * lying in the AD era.\n+ *\n+ * @see Calendar\n+ * @see GregorianCalender \n+ * @author Jochen Hoenicke */\n+public class SimpleTimeZone extends TimeZone\n+{\n+  /**\n+   * The raw time zone offset in milliseconds to GMT, ignoring\n+   * daylight savings.  \n+   * @serial\n+   */\n+  private int rawOffset;\n+\n+  /**\n+   * True, if this timezone uses daylight savings, false otherwise.\n+   * @serial\n+   */\n+  private boolean useDaylight;\n+\n+  /**\n+   * The daylight savings offset.  This is a positive offset in\n+   * milliseconds with respect to standard time.  Typically this\n+   * is one hour, but for some time zones this may be half an our.\n+   * @serial\n+   * @since JDK1.1.4\n+   */\n+  private int dstSavings = 60 * 60 * 1000;\n+\n+  /**\n+   * The first year, in which daylight savings rules applies.  \n+   * @serial\n+   */\n+  private int startYear;\n+\n+  private static final int DOM_MODE = 1;\n+  private static final int DOW_IN_MONTH_MODE = 2;\n+  private static final int DOW_GE_DOM_MODE = 3;\n+  private static final int DOW_LE_DOM_MODE = 4;\n+  /**\n+   * The mode of the start rule. This takes one of the following values:\n+   * <dl>\n+   * <dt>DOM_MODE (1)</dt>\n+   * <dd> startDay contains the day in month of the start date,\n+   * startDayOfWeek is unused. </dd>\n+   * <dt>DOW_IN_MONTH_MODE (2)</dt>\n+   * <dd> The startDay gives the day of week in month, and\n+   * startDayOfWeek the day of week.  For example startDay=2 and\n+   * startDayOfWeek=Calender.SUNDAY specifies that the change is on\n+   * the second sunday in that month.  You must make sure, that this\n+   * day always exists (ie. don't specify the 5th sunday).\n+   * </dd>\n+   * <dt>DOW_GE_DOM_MODE (3)</dt>\n+   * <dd> The start is on the first startDayOfWeek on or after\n+   * startDay.  For example startDay=13 and\n+   * startDayOfWeek=Calendar.FRIDAY specifies that the daylight\n+   * savings start on the first FRIDAY on or after the 13th of that\n+   * Month. Make sure that the change is always in the given month, or\n+   * the result is undefined.\n+   * </dd>\n+   * <dt>DOW_LE_DOM_MONTH (4)</dt>\n+   * <dd> The start is on the first startDayOfWeek on or before the\n+   * startDay.  Make sure that the change is always in the given\n+   * month, or the result is undefined.\n+   </dd>\n+   * </dl>\n+   * @serial */\n+  private int startMode;\n+\n+  /**\n+   * The month in which daylight savings start.  This is one of the\n+   * constants Calendar.JANUARY, ..., Calendar.DECEMBER.  \n+   * @serial\n+   */\n+  private int startMonth;\n+\n+  /**\n+   * This variable can have different meanings.  See startMode for details\n+   * @see #startMode;\n+   * @serial\n+   */   \n+  private int startDay;\n+  \n+  /**\n+   * This variable specifies the day of week the change takes place.  If \n+   * startMode == DOM_MODE, this is undefined.\n+   * @serial\n+   * @see #startMode;\n+   */   \n+  private int startDayOfWeek;\n+  \n+  /**\n+   * This variable specifies the time of change to daylight savings.\n+   * This time is given in milliseconds after midnight local\n+   * standard time.  \n+   * @serial\n+   */\n+  private int startTime;\n+   \n+  /**\n+   * The month in which daylight savings ends.  This is one of the\n+   * constants Calendar.JANUARY, ..., Calendar.DECEMBER.  \n+   * @serial\n+   */   \n+  private int endMonth;\n+\n+  /**\n+   * This variable gives the mode for the end of daylight savings rule.\n+   * It can take the same values as startMode.\n+   * @serial\n+   * @see #startMode\n+   */   \n+  private int endMode;\n+\n+  /**\n+   * This variable can have different meanings.  See startMode for details\n+   * @serial\n+   * @see #startMode;\n+   */\n+  private int endDay;\n+  \n+  /**\n+   * This variable specifies the day of week the change takes place.  If \n+   * endMode == DOM_MODE, this is undefined.\n+   * @serial\n+   * @see #startMode;\n+   */\n+  private int endDayOfWeek;\n+  \n+  /**\n+   * This variable specifies the time of change back to standard time.\n+   * This time is given in milliseconds after midnight local\n+   * standard time.  \n+   * @serial\n+   */\n+  private int endTime;\n+\n+  /**\n+   * This variable points to a deprecated array from JDK 1.1.  It is\n+   * ignored in JDK 1.2 but streamed out for compatibility with JDK 1.1.\n+   * The array contains the lengths of the months in the year and is\n+   * assigned from a private static final field to avoid allocating\n+   * the array for every instance of the object.\n+   * Note that static final fields are not serialized.\n+   * @serial\n+   */\n+  private byte[] monthLength = monthArr;\n+  private static final byte[] monthArr =\n+    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n+\n+  /**\n+   * The version of the serialized data on the stream.\n+   * <dl>\n+   * <dt>0 or not present on stream</dt>\n+   * <dd> JDK 1.1.3 or earlier, only provides this fields:\n+   * rawOffset, startDay, startDayOfWeek, startMonth, startTime,\n+   * startYear, endDay, endDayOfWeek, endMonth, endTime\n+   * </dd>\n+   * <dd> JDK 1.1.4 or later. This includes three new fields, namely\n+   * startMode, endMode and dstSavings.  And there is a optional section\n+   * as described in writeObject.\n+   * </dd>\n+   *\n+   * XXX - JDK 1.2 Beta 4 docu states 1.1.4, but my 1.1.5 has the old\n+   * version.\n+   *\n+   * When streaming out this class it is always written in the latest\n+   * version.\n+   * @serial\n+   * @since JDK1.1.4 \n+   */\n+  private int serialVersionOnStream = 1;\n+\n+  private static final long serialVersionUID = -403250971215465050L;\n+\n+  /**\n+   * Create a <code>SimpleTimeZone</code> with the given time offset\n+   * from GMT and without daylight savings.  \n+   * @param rawOffset the time offset from GMT in milliseconds.\n+   * @param id The identifier of this time zone.  \n+   */\n+  public SimpleTimeZone(int rawOffset, String id)\n+  {\n+    this.rawOffset = rawOffset;\n+    setID(id);\n+    useDaylight = false;\n+    startYear = 0;\n+  }\n \n-  int startMonth;\n+  /**\n+   * Create a <code>SimpleTimeZone</code> with the given time offset\n+   * from GMT and with daylight savings.  The start/end parameters\n+   * can have different meaning (replace WEEKDAY with a real day of\n+   * week). Only the first two meanings were supported by earlier \n+   * versions of jdk.\n+   *\n+   * <dl>\n+   * <dt><code>day &gt; 0, dayOfWeek = Calendar.WEEKDAY</code></dt>\n+   * <dd>The start/end of daylight savings is on the <code>day</code>-th\n+   * <code>WEEKDAY</code> in the given month. </dd>\n+   * <dt><code>day &lt; 0, dayOfWeek = Calendar.WEEKDAY</code></dt>\n+   * <dd>The start/end of daylight savings is on the <code>-day</code>-th\n+   * <code>WEEKDAY</code> counted from the <i>end</i> of the month. </dd>\n+   * <dt><code>day &gt; 0, dayOfWeek = 0</code></dt>\n+   * <dd>The start/end of daylight is on the <code>day</code>-th day of\n+   * the month. </dd>\n+   * <dt><code>day &gt; 0, dayOfWeek = -Calendar.WEEKDAY</code></dt>\n+   * <dd>The start/end of daylight is on the first WEEKDAY on or after\n+   * the <code>day</code>-th day of the month.  You must make sure that\n+   * this day lies in the same month. </dd>\n+   * <dt><code>day &lt; 0, dayOfWeek = -Calendar.WEEKDAY</code></dt>\n+   * <dd>The start/end of daylight is on the first WEEKDAY on or\n+   * <i>before</i> the <code>-day</code>-th day of the month.  You\n+   * must make sure that this day lies in the same month. </dd>\n+   * </dl>\n+   *\n+   * If you give a non existing month, a day that is zero, or too big, \n+   * or a dayOfWeek that is too big,  the result is undefined.\n+   *\n+   * The start rule must have a different month than the end rule.\n+   * This restriction shouldn't hurt for all possible time zones.\n+   * \n+   * @param rawOffset The time offset from GMT in milliseconds.\n+   * @param id  The identifier of this time zone.\n+   * @param startMonth The start month of daylight savings; use the\n+   * constants in Calendar.\n+   * @param startday A day in month or a day of week number, as\n+   * described above.\n+   * @param startDayOfWeek The start rule day of week; see above.\n+   * @param startTime A time in millis in standard time.\n+   * @param endMonth The end month of daylight savings; use the\n+   * constants in Calendar.\n+   * @param endday A day in month or a day of week number, as \n+   * described above.\n+   * @param endDayOfWeek The end rule day of week; see above.\n+   * @param endTime A time in millis in standard time.  */\n+  public SimpleTimeZone(int rawOffset, String id,\n+\t\t\tint startMonth, int startDayOfWeekInMonth,\n+\t\t\tint startDayOfWeek, int startTime,\n+\t\t\tint endMonth, int endDayOfWeekInMonth,\n+\t\t\tint endDayOfWeek, int endTime)\n+  {\n+    this.rawOffset = rawOffset;\n+    setID(id);\n+    useDaylight = true;\n+\n+    setStartRule(startMonth, startDayOfWeekInMonth,\n+\t\t startDayOfWeek, startTime);\n+    setEndRule(endMonth, endDayOfWeekInMonth, endDayOfWeek, endTime);\n+    if (startMonth == endMonth)\n+      throw new IllegalArgumentException\n+\t(\"startMonth and endMonth must be different\");\n+    this.startYear = 0;\n+  }\n \n-  int startTime;\n+  /**\n+   * This constructs a new SimpleTimeZone that supports a daylight savings\n+   * rule.  The parameter are the same as for the constructor above, except\n+   * there is the additional dstSavaings parameter.\n+   *\n+   * @param dstSavings the amount of savings for daylight savings\n+   * time in milliseconds.  This must be positive.\n+   */\n+  public SimpleTimeZone(int rawOffset, String id,\n+\t\t\tint startMonth, int startDayOfWeekInMonth,\n+\t\t\tint startDayOfWeek, int startTime,\n+\t\t\tint endMonth, int endDayOfWeekInMonth,\n+\t\t\tint endDayOfWeek, int endTime, int dstSavings)\n+  {\n+    this(rawOffset, id,\n+\t startMonth, startDayOfWeekInMonth, startDayOfWeek, startTime,\n+\t endMonth, endDayOfWeekInMonth, endDayOfWeek, endTime);\n \n-  int startYear;\n+    this.dstSavings = dstSavings;\n+  }\n \n-  int endDay;\n+  /**\n+   * Sets the first year, where daylight savings applies.  The daylight\n+   * savings rule never apply for years in the BC era.  Note that this\n+   * is gregorian calendar specific.\n+   * @param year the start year.\n+   */\n+  public void setStartYear(int year)\n+  {\n+    startYear = year;\n+    useDaylight = true;\n+  }\n \n-  int endDayOfWeek;\n+  /**\n+   * Checks if the month, day, dayOfWeek arguments are in range and\n+   * returns the mode of the rule.\n+   * @param month the month parameter as in the constructor\n+   * @param day the day parameter as in the constructor\n+   * @param dayOfWeek the day of week parameter as in the constructor\n+   * @return the mode of this rule see startMode.\n+   * @exception IllegalArgumentException if parameters are out of range.\n+   * @see #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)\n+   * @see #startMode\n+   */\n+  private int checkRule(int month, int day, int dayOfWeek)\n+  {\n+    int daysInMonth = getDaysInMonth(month, 1);\n+    if (dayOfWeek == 0)\n+      {\n+\tif (day <= 0 || day > daysInMonth)\n+\t  throw new IllegalArgumentException(\"day out of range\");\n+\treturn DOM_MODE;\n+      }\n+    else if (dayOfWeek > 0)\n+      {\n+\tif (Math.abs(day) > (daysInMonth + 6) / 7)\n+\t  throw new IllegalArgumentException(\"dayOfWeekInMonth out of range\");\n+\tif (dayOfWeek > Calendar.SATURDAY)\n+\t  throw new IllegalArgumentException(\"dayOfWeek out of range\");\n+\treturn DOW_IN_MONTH_MODE;\n+      }\n+    else\n+      {\n+\tif (day == 0 || Math.abs(day) > daysInMonth)\n+\t  throw new IllegalArgumentException(\"day out of range\");\n+\tif (dayOfWeek < -Calendar.SATURDAY)\n+\t  throw new IllegalArgumentException(\"dayOfWeek out of range\");\n+\tif (day < 0)\n+\t  return DOW_LE_DOM_MODE;\n+\telse\n+\t  return DOW_GE_DOM_MODE;\n+      }\n+  }\n \n-  int endMode;  // Seems to be JDK 1.2 only.\n \n-  int endMonth;\n+  /**\n+   * Sets the daylight savings start rule.  You must also set the\n+   * end rule with <code>setEndRule</code> or the result of\n+   * getOffset is undefined.  For the parameters see the ten-argument\n+   * constructor above.\n+   *\n+   * @param month The month where daylight savings start, zero\n+   * based.  You should use the constants in Calendar.\n+   * @param day A day of month or day of week in month.\n+   * @param dayOfWeek The day of week where daylight savings start.\n+   * @param time The time in milliseconds standard time where daylight\n+   * savings start.\n+   * @see SimpleTimeZone */\n+  public void setStartRule(int month, int day, int dayOfWeek, int time)\n+  {\n+    this.startMode = checkRule(month, day, dayOfWeek);\n+    this.startMonth = month;\n+    // FIXME: XXX: JDK 1.2 allows negative values and has 2 new variations\n+    // of this method.\n+    this.startDay = Math.abs(day);\n+    this.startDayOfWeek = Math.abs(dayOfWeek);\n+    this.startTime = time;\n+    useDaylight = true;\n+  }\n \n-  int endTime;\n+  /**\n+   * Sets the daylight savings end rule.  You must also set the\n+   * start rule with <code>setStartRule</code> or the result of\n+   * getOffset is undefined. For the parameters see the ten-argument\n+   * constructor above.\n+   *\n+   * @param rawOffset The time offset from GMT.\n+   * @param id  The identifier of this time zone.\n+   * @param Month The end month of daylight savings.\n+   * @param day A day in month, or a day of week in month.\n+   * @param DayOfWeek A day of week, when daylight savings ends.\n+   * @param Time A time in millis in standard time.\n+   * @see #setStartRule */\n+  public void setEndRule(int month, int day, int dayOfWeek, int time)\n+  {\n+    this.endMode = checkRule(month, day, dayOfWeek);\n+    this.endMonth = month;\n+    // FIXME: XXX: JDK 1.2 allows negative values and has 2 new variations\n+    // of this method.\n+    this.endDay = Math.abs(day);\n+    this.endDayOfWeek = Math.abs(dayOfWeek);\n+    this.endTime = time;\n+    useDaylight = true;\n+  }\n \n-  // byte[] monthLength;\n+  /**\n+   * Gets the time zone offset, for current date, modified in case of \n+   * daylight savings.  This is the offset to add to UTC to get the local\n+   * time.\n+   *\n+   * In the standard JDK the results given by this method may result in\n+   * inaccurate results at the end of February or the beginning of March.\n+   * To avoid this, you should use Calendar instead:\n+   * <pre>\n+   * offset = cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET);\n+   * </pre>\n+   * You could also use in\n+   *\n+   * This version doesn't suffer this inaccuracy.\n+   *\n+   * @param era the era of the given date\n+   * @param year the year of the given date\n+   * @param month the month of the given date, 0 for January.\n+   * @param day the day of month\n+   * @param dayOfWeek the day of week; this must be matching the\n+   * other fields.\n+   * @param millis the millis in the day (in local standard time)\n+   * @return the time zone offset in milliseconds.  */\n+  public int getOffset(int era, int year, int month,\n+\t\t       int day, int dayOfWeek, int millis)\n+  {\n+    // This method is called by Calendar, so we mustn't use that class.\n+    int daylightSavings = 0;\n+    if (useDaylight && era == GregorianCalendar.AD && year >= startYear)\n+      {\n+\t// This does only work for Gregorian calendars :-(\n+\t// This is mainly because setStartYear doesn't take an era.\n+\n+\tboolean afterStart = !isBefore(year, month, day, dayOfWeek, millis,\n+\t\t\t\t       startMode, startMonth,\n+\t\t\t\t       startDay, startDayOfWeek, startTime);\n+\tboolean beforeEnd = isBefore(year, month, day, dayOfWeek, millis,\n+\t\t\t\t     endMode, endMonth,\n+\t\t\t\t     endDay, endDayOfWeek, endTime);\n+\n+\tif (startMonth < endMonth)\n+\t  {\n+\t    // use daylight savings, if the date is after the start of\n+\t    // savings, and before the end of savings.\n+\t    daylightSavings = afterStart && beforeEnd ? dstSavings : 0;\n+\t  }\n+\telse\n+\t  {\n+\t    // use daylight savings, if the date is before the end of\n+\t    // savings, or after the start of savings.\n+\t    daylightSavings = beforeEnd || afterStart ? dstSavings : 0;\n+\t  }\n+      }\n+    return rawOffset + daylightSavings;\n+  }\n \n-  boolean useDaylight;\n+  /**\n+   * Returns the time zone offset to GMT in milliseconds, ignoring\n+   * day light savings.\n+   * @return the time zone offset.  */\n+  public int getRawOffset()\n+  {\n+    return rawOffset;\n+  }\n \n-  public SimpleTimeZone (int rawOffset, String ID)\n+  /**\n+   * Sets the standard time zone offset to GMT.\n+   * @param rawOffset The time offset from GMT in milliseconds.\n+   */\n+  public void setRawOffset(int rawOffset)\n   {\n-    setID(ID);\n     this.rawOffset = rawOffset;\n   }\n \n-  public SimpleTimeZone (int rawOffset, String ID,\n-\t\t\t int startMonth, int startDay,\n-\t\t\t int startDayOfWeek, int startTime,\n-\t\t\t int endMonth, int endDay,\n-\t\t\t int endDayOfWeek, int endTime)\n+  /**\n+   * Gets the daylight savings offset.  This is a positive offset in\n+   * milliseconds with respect to standard time.  Typically this\n+   * is one hour, but for some time zones this may be half an our.\n+   * @return the daylight savings offset in milliseconds.\n+   * @since JDK1.1.4?\n+   */\n+  public int getDSTSavings()\n   {\n-    this(rawOffset, ID);\n-    setStartRule (startMonth, startDay, startDayOfWeek, startTime);\n-    setEndRule (endMonth, endDay, endDayOfWeek, endTime);\n+    return dstSavings;\n   }\n \n-  public int getRawOffset() { return rawOffset; }\n-  public void setRawOffset (int offsetMillis) { rawOffset = offsetMillis; }\n+  /**\n+   * Returns if this time zone uses daylight savings time.\n+   * @return true, if we use daylight savings time, false otherwise.\n+   */\n+  public boolean useDaylightTime()\n+  {\n+    return useDaylight;\n+  }\n \n-  public int getOffset (int era, int year, int month, int day,\n-\t\t\tint dayOfWeek, int millis)\n+  /**\n+   * Returns the number of days in the given month.  It does always\n+   * use the Gregorian leap year rule.  \n+   * @param month The month, zero based; use one of the Calendar constants.\n+   * @param year  The year.\n+   */\n+  private int getDaysInMonth(int month, int year)\n   {\n-    int offset = getRawOffset();\n-    if (useDaylight)\n+    // Most of this is copied from GregorianCalendar.getActualMaximum()\n+    if (month == Calendar.FEBRUARY)\n       {\n-\tif (startYear != 0\n-\t    && (year < startYear || era == GregorianCalendar.BC))\n-\t  return offset;\n-\tboolean midYearSummer = startMonth < endMonth;\n-\tif (midYearSummer ? (month < startMonth || month > endMonth)\n-\t    : (month < startMonth && month > endMonth))\n-\t  return offset; // Definitely not DST.\n-\tif (midYearSummer ? (month > startMonth && month < endMonth)\n-\t    : (month > startMonth || month < endMonth))\n-\t  return offset + dstSavings;  // Definitely DST.\n-\t// Now it gets more complicated.  Bail for now.\n-\tthrow new Error(\"not implemented - SimpleTimeZone.getOffset\");\n+\treturn ((year & 3) == 0 && (year % 100 != 0 || year % 400 == 0))\n+\t  ? 29 : 28;\n       }\n-    return offset;\n+    else if (month < Calendar.AUGUST)\n+        return 31 - (month & 1);\n+    else\n+      return 30 + (month & 1);\n   }\n \n-  public boolean useDaylightTime() { return useDaylight; }\n-\n-  public boolean inDaylightTime(Date date)\n+  /**\n+   * Checks if the date given in calXXXX, is before the change between\n+   * dst and standard time.\n+   * @param calYear the year of the date to check (for leap day cheking).\n+   * @param calMonth the month of the date to check.\n+   * @param calDay the day of month of the date to check.\n+   * @param calDayOfWeek the day of week of the date to check.\n+   * @param calMillis the millis of day of the date to check (standard time).\n+   * @param mode  the change mode; same semantic as startMode.\n+   * @param month the change month; same semantic as startMonth.\n+   * @param day   the change day; same semantic as startDay.\n+   * @param dayOfWeek the change day of week; \n+   * @param millis the change time in millis since midnight standard time.\n+   * same semantic as startDayOfWeek.\n+   * @return true, if cal is before the change, false if cal is on\n+   * or after the change.\n+   */\n+  private boolean isBefore(int calYear,\n+\t\t\t   int calMonth, int calDayOfMonth, int calDayOfWeek,\n+\t\t\t   int calMillis, int mode, int month,\n+\t\t\t   int day, int dayOfWeek, int millis)\n   {\n-    if (! useDaylight)\n-      return false;\n-    throw new Error(\"not implemented - SimpleTimeZone.inDaylightTime\");\n-  }\n \n-  public int getDSTSavings () { return dstSavings; }\n+    // This method is called by Calendar, so we mustn't use that class.\n+    // We have to do all calculations by hand.\n+\n+    // check the months:\n \n-  public void setDSTSavings (int millisSavedDuringDST)\n-  { dstSavings = millisSavedDuringDST; }\n+    // XXX - this is not correct:\n+    // for the DOW_GE_DOM and DOW_LE_DOM modes the change date may\n+    // be in a different month.\n+    if (calMonth != month)\n+      return calMonth < month;\n \n-  public void setStartRule (int month, int dayOfWeekInMonth,\n-\t\t\t    int dayOfWeek, int time)\n+    // check the day:\n+    switch (mode)\n+      {\n+      case DOM_MODE:\n+\tif (calDayOfMonth != day)\n+\t  return calDayOfMonth < day;\n+\tbreak;\n+      case DOW_IN_MONTH_MODE:\n+\t{\n+\t  // This computes the day of month of the day of type\n+\t  // \"dayOfWeek\" that lies in the same (sunday based) week as cal.\n+\t  calDayOfMonth += (dayOfWeek - calDayOfWeek);\n+\n+\t  // Now we convert it to 7 based number (to get a one based offset\n+\t  // after dividing by 7).  If we count from the end of the\n+\t  // month, we get want a -7 based number counting the days from \n+\t  // the end:\n+\n+\t  if (day < 0)\n+\t    calDayOfMonth -= getDaysInMonth(calMonth, calYear) + 7;\n+\t  else\n+\t    calDayOfMonth += 6;\n+\n+\t  //  day > 0                    day < 0\n+\t  //  S  M  T  W  T  F  S        S  M  T  W  T  F  S\n+\t  //     7  8  9 10 11 12         -36-35-34-33-32-31\n+\t  // 13 14 15 16 17 18 19      -30-29-28-27-26-25-24\n+\t  // 20 21 22 23 24 25 26      -23-22-21-20-19-18-17\n+\t  // 27 28 29 30 31 32 33      -16-15-14-13-12-11-10\n+\t  // 34 35 36                   -9 -8 -7\n+\n+\t  // Now we calculate the day of week in month:\n+\t  int week = calDayOfMonth / 7;\n+\t  //  day > 0                    day < 0\n+\t  //  S  M  T  W  T  F  S        S  M  T  W  T  F  S\n+\t  //     1  1  1  1  1  1          -5 -5 -4 -4 -4 -4\n+\t  //  1  2  2  2  2  2  2       -4 -4 -4 -3 -3 -3 -3\n+\t  //  2  3  3  3  3  3  3       -3 -3 -3 -2 -2 -2 -2\n+\t  //  3  4  4  4  4  4  4       -2 -2 -2 -1 -1 -1 -1\n+\t  //  4  5  5                   -1 -1 -1\n+\n+\t  if (week != day)\n+\t    return week < day;\n+\n+\t  if (calDayOfWeek != dayOfWeek)\n+\t    return calDayOfWeek < dayOfWeek;\n+\n+\t  // daylight savings starts/ends  on the given day.\n+\t  break;\n+\t}\n+\n+      case DOW_LE_DOM_MODE:\n+\t// The greatest sunday before or equal December, 12\n+\t// is the same as smallest sunday after or equal December, 6.\n+\tday -= 6;\n+\n+      case DOW_GE_DOM_MODE:\n+\n+\t// Calculate the day of month of the day of type\n+\t// \"dayOfWeek\" that lies before (or on) the given date.\n+\tcalDayOfMonth -= (calDayOfWeek < dayOfWeek ? 7 : 0)\n+\t  + calDayOfWeek - dayOfWeek;\n+\tif (calDayOfMonth < day)\n+\t  return true;\n+\tif (calDayOfWeek != dayOfWeek || calDayOfMonth >= day + 7)\n+\t  return false;\n+\t// now we have the same day\n+\tbreak;\n+      }\n+    // the millis decides:\n+    return (calMillis < millis);\n+  }\n+\n+  /**\n+   * Determines if the given date is in daylight savings time.\n+   * @return true, if it is in daylight savings time, false otherwise.\n+   */\n+  public boolean inDaylightTime(Date date)\n   {\n-    this.startMonth = month;\n-    this.startDay = dayOfWeekInMonth;\n-    this.startDayOfWeek = dayOfWeek;\n-    this.startTime = time;\n-    this.useDaylight = true;\n+    Calendar cal = Calendar.getInstance(this);\n+    cal.setTime(date);\n+    return (cal.get(Calendar.DST_OFFSET) != 0);\n   }\n \n-  public void setEndRule (int month, int dayOfWeekInMonth,\n-\t\t\t    int dayOfWeek, int time)\n+  /**\n+   * Generates the hashCode for the SimpleDateFormat object.  It is\n+   * the rawOffset, possibly, if useDaylightSavings is true, xored\n+   * with startYear, startMonth, startDayOfWeekInMonth, ..., endTime.  \n+   */\n+  public synchronized int hashCode()\n   {\n-    this.endMonth = month;\n-    this.endDay = dayOfWeekInMonth;\n-    this.endDayOfWeek = dayOfWeek;\n-    this.endTime = time;\n-    this.useDaylight = true;\n+    return rawOffset ^\n+      (useDaylight ?\n+       startMonth ^ startDay ^ startDayOfWeek ^ startTime\n+       ^ endMonth ^ endDay ^ endDayOfWeek ^ endTime : 0);\n   }\n \n-  public void setStartYear (int year)\n+  public synchronized boolean equals(Object o)\n   {\n-    this.startYear = startYear;\n+    if (this == o)\n+      return true;\n+    if (!(o instanceof SimpleTimeZone))\n+      return false;\n+    SimpleTimeZone zone = (SimpleTimeZone) o;\n+    if (zone.hashCode() != hashCode()\n+\t|| !getID().equals(zone.getID())\n+\t|| rawOffset != zone.rawOffset || useDaylight != zone.useDaylight)\n+      return false;\n+    if (!useDaylight)\n+      return true;\n+    return (startYear == zone.startYear\n+\t    && startMonth == zone.startMonth\n+\t    && startDay == zone.startDay\n+\t    && startDayOfWeek == zone.startDayOfWeek\n+\t    && startTime == zone.startTime\n+\t    && endMonth == zone.endMonth\n+\t    && endDay == zone.endDay\n+\t    && endDayOfWeek == zone.endDayOfWeek\n+\t    && endTime == zone.endTime);\n   }\n \n-  public boolean hasSameRules (TimeZone other)\n+  /**\n+   * Test if the other time zone uses the same rule and only\n+   * possibly differs in ID.  This implementation for this particular\n+   * class will return true if the other object is a SimpleTimeZone,\n+   * the raw offsets and useDaylight are identical and if useDaylight\n+   * is true, also the start and end datas are identical.\n+   * @return true if this zone uses the same rule.\n+   */\n+  public boolean hasSameRules(TimeZone other)\n   {\n     if (this == other)\n       return true;\n-    if (! (other instanceof SimpleTimeZone))\n-      return false;\n-    SimpleTimeZone o = (SimpleTimeZone) other;\n-    if (rawOffset != o.rawOffset)\n+    if (!(other instanceof SimpleTimeZone))\n       return false;\n-    if (useDaylight != o.useDaylight)\n+    SimpleTimeZone zone = (SimpleTimeZone) other;\n+    if (zone.hashCode() != hashCode()\n+\t|| rawOffset != zone.rawOffset || useDaylight != zone.useDaylight)\n       return false;\n-    if (! useDaylight)\n+    if (!useDaylight)\n       return true;\n-    return startDay == o.startDay\n-      && startDayOfWeek == o.startDayOfWeek\n-      && startMonth == o.startMonth\n-      && startTime == o.startTime\n-      && endDay == o.endDay\n-      && endDayOfWeek == o.endDayOfWeek\n-      && endMonth == o.endMonth\n-      && endTime == o.endTime\n-      && startYear == o.startYear\n-      && startMode == o.startMode\n-      && endMode == o.endMode;\n-  }\n-\n-  public boolean equals (Object obj)\n-  {\n-    if (! (obj instanceof SimpleTimeZone))\n-      return false;\n-    SimpleTimeZone other = (SimpleTimeZone) obj;\n-    return getID() == other.getID() && hasSameRules(other);\n+    return (startYear == zone.startYear\n+\t    && startMonth == zone.startMonth\n+\t    && startDay == zone.startDay\n+\t    && startDayOfWeek == zone.startDayOfWeek\n+\t    && startTime == zone.startTime\n+\t    && endMonth == zone.endMonth\n+\t    && endDay == zone.endDay\n+\t    && endDayOfWeek == zone.endDayOfWeek && endTime == zone.endTime);\n   }\n \n-  public Object clone ()\n+  /**\n+   * Returns a string representation of this SimpleTimeZone object.\n+   * @return a string representation of this SimpleTimeZone object.\n+   */\n+  public String toString()\n   {\n-    // We know the superclass just call's Object's generic cloner.\n-    return super.clone ();\n+    // the test for useDaylight is an incompatibility to jdk1.2, but\n+    // I think this shouldn't hurt.\n+    return getClass().getName() + \"[\"\n+      + \"id=\" + getID()\n+      + \",offset=\" + rawOffset\n+      + \",dstSavings=\" + dstSavings\n+      + \",useDaylight=\" + useDaylight\n+      + (useDaylight ?\n+\t \",startYear=\" + startYear\n+\t + \",startMode=\" + startMode\n+\t + \",startMonth=\" + startMonth\n+\t + \",startDay=\" + startDay\n+\t + \",startDayOfWeek=\" + startDayOfWeek\n+\t + \",startTime=\" + startTime\n+\t + \",endMode=\" + endMode\n+\t + \",endMonth=\" + endMonth\n+\t + \",endDay=\" + endDay\n+\t + \",endDayOfWeek=\" + endDayOfWeek\n+\t + \",endTime=\" + endTime : \"\") + \"]\";\n   }\n \n-  public String toString ()\n+  /**\n+   * Reads a serialized simple time zone from stream.\n+   * @see #writeObject\n+   */\n+  private void readObject(java.io.ObjectInputStream input)\n+    throws java.io.IOException, ClassNotFoundException\n   {\n-    // The docs don't say much about how we might implement this.\n-    // We choose a debugging implementation.\n-    return (\"dstSavings \" + dstSavings\n-\t    + \"; rawOffset \" + rawOffset\n-\t    + \"; startDay \" + startDay\n-\t    + \"; startDayOfWeek \" + startDayOfWeek\n-\t    + \"; startMode \" + startMode\n-\t    + \"; startMonth \" + startMonth\n-\t    + \"; startTime \" + startTime\n-\t    + \"; startYear \" + startYear\n-\t    + \"; endDay \" + endDay\n-\t    + \"; endDayOfWeek \" + endDayOfWeek\n-\t    + \"; endMode \" + endMode\n-\t    + \"; endMonth \" + endMonth\n-\t    + \"; endTime \" + endTime\n-\t    + \"; useDaylight \" + useDaylight);\n+    input.defaultReadObject();\n+    if (serialVersionOnStream == 0)\n+      {\n+\t// initialize the new fields to default values.\n+\tdstSavings = 60 * 60 * 1000;\n+\tendMode = DOW_IN_MONTH_MODE;\n+\tstartMode = DOW_IN_MONTH_MODE;\n+\tserialVersionOnStream = 1;\n+      }\n+    else\n+      {\n+\tint length = input.readInt();\n+\tbyte[]byteArray = new byte[length];\n+\tinput.read(byteArray, 0, length);\n+\tif (length >= 4)\n+\t  {\n+\t    // Lets hope that Sun does extensions to the serialized\n+\t    // form in a sane manner.\n+\t    startDay = byteArray[0];\n+\t    startDayOfWeek = byteArray[1];\n+\t    endDay = byteArray[2];\n+\t    endDayOfWeek = byteArray[3];\n+\t  }\n+      }\n   }\n \n-  public int hashCode ()\n+  /**\n+   * Serializes this object to a stream.  @serialdata The object is\n+   * first written in the old JDK 1.1 format, so that it can be read\n+   * by by the old classes.  This means, that the\n+   * <code>start/endDay(OfWeek)</code>-Fields are written in the\n+   * DOW_IN_MONTH_MODE rule, since this was the only supported rule\n+   * in 1.1.\n+   * \n+   * In the optional section, we write first the length of an byte\n+   * array as int and afterwards the byte array itself.  The byte\n+   * array contains in this release four elements, namely the real\n+   * startDay, startDayOfWeek endDay, endDayOfWeek in that Order.\n+   * These fields are needed, because for compatibility reasons only\n+   * approximative values are written to the required section, as\n+   * described above.  \n+   */\n+  private void writeObject(java.io.ObjectOutputStream output)\n+    throws java.io.IOException\n   {\n-    // FIXME - this does not folow any spec (since none is public)!\n-    int hash = rawOffset;\n-    if (useDaylight)\n-      hash += dstSavings + startYear + startMode + endMode\n-\t+ startDay + startDayOfWeek + startMonth + startTime\n-\t+ endDay + endDayOfWeek + endMonth + endTime;\n-    return hash;\n+    byte[] byteArray = new byte[]\n+    {\n+      (byte) startDay, (byte) startDayOfWeek,\n+\t(byte) endDay, (byte) endDayOfWeek};\n+\n+    /* calculate the approximation for JDK 1.1 */\n+    switch (startMode)\n+      {\n+      case DOM_MODE:\n+\tstartDayOfWeek = Calendar.SUNDAY;\t// random day of week\n+\t// fall through\n+      case DOW_GE_DOM_MODE:\n+      case DOW_LE_DOM_MODE:\n+\tstartDay = (startDay + 6) / 7;\n+      }\n+    switch (endMode)\n+      {\n+      case DOM_MODE:\n+\tendDayOfWeek = Calendar.SUNDAY;\n+\t// fall through\n+      case DOW_GE_DOM_MODE:\n+      case DOW_LE_DOM_MODE:\n+\tendDay = (endDay + 6) / 7;\n+      }\n+\n+    // the required part:\n+    output.defaultWriteObject();\n+    // the optional part:\n+    output.writeInt(byteArray.length);\n+    output.write(byteArray, 0, byteArray.length);\n   }\n }"}]}