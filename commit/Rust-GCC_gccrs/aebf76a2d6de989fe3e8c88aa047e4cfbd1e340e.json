{"sha": "aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWViZjc2YTJkNmRlOTg5ZmUzZThjODhhYTA0N2U0Y2ZiZDFlMzQwZQ==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-11-20T15:10:11Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-11-20T15:10:11Z"}, "message": "implement a replacement for if_marked\n\ngcc/ChangeLog:\n\n2014-11-20  Trevor Saunders  <tsaunders@mozilla.com>\n\n\t* doc/gty.texi: Document the new cache gty attribute.\n\t* gengtype.c (finish_cache_funcs): New function.\n\t(write_roots): Call gt_clear_cache on global variables with the cache\n\tgty attribute.\n\t* ggc-common.c (ggc_mark_roots): Call gt_clear_caches.\n\t* ggc.h (gt_clear_caches): New declaration.\n\t* hash-table.h (struct ggc_cache_hasher): New hasher for caches in gc\n\tmemory.\n\t(gt_cleare_cache): New function.\n\t* emit-rtl.c, rtl.h, tree.c: Use hash_table instead of htab.\n\nFrom-SVN: r217866", "tree": {"sha": "fa770de679e7f22bf1d98fb9ad84e84a0d60cfa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa770de679e7f22bf1d98fb9ad84e84a0d60cfa0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/comments", "author": null, "committer": null, "parents": [{"sha": "77486f4480db2a2365e08a08c223655c7335aab4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77486f4480db2a2365e08a08c223655c7335aab4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77486f4480db2a2365e08a08c223655c7335aab4"}], "stats": {"total": 443, "additions": 302, "deletions": 141}, "files": [{"sha": "a27c298a3b4df9b15d26d3da362e9fcebcbd102b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "patch": "@@ -1,3 +1,16 @@\n+2014-11-20  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* doc/gty.texi: Document the new cache gty attribute.\n+\t* gengtype.c (finish_cache_funcs): New function.\n+\t(write_roots): Call gt_clear_cache on global variables with the cache\n+\tgty attribute.\n+\t* ggc-common.c (ggc_mark_roots): Call gt_clear_caches.\n+\t* ggc.h (gt_clear_caches): New declaration.\n+\t* hash-table.h (struct ggc_cache_hasher): New hasher for caches in gc\n+\tmemory.\n+\t(gt_cleare_cache): New function.\n+\t* emit-rtl.c, rtl.h, tree.c: Use hash_table instead of htab.\n+\n 2014-11-20  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* combine.c (try_combine): Prefer to delete dead SETs inside"}, {"sha": "e4d2b604687f8ede6535c8ca997d559a60bc3220", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "patch": "@@ -293,6 +293,14 @@ the pointed-to structure should use the same parameters as the outer\n structure.  This is done by marking the pointer with the\n @code{use_params} option.\n \n+@findex cache\n+@item cache\n+\n+When the @code{cache} option is applied to a global variable gt_clear_cache is\n+called on that variable between the mark and sweep phases of garbage\n+collection.  The gt_clear_cache function is free to mark blocks as used, or to\n+clear pointers in the variable.\n+\n @findex deletable\n @item deletable\n "}, {"sha": "1226aad0c137f94f83ee01db5e130f675bb408b5", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 93, "deletions": 85, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "patch": "@@ -131,45 +131,62 @@ rtx cc0_rtx;\n /* A hash table storing CONST_INTs whose absolute value is greater\n    than MAX_SAVED_CONST_INT.  */\n \n-static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n-     htab_t const_int_htab;\n+struct const_int_hasher : ggc_cache_hasher<rtx>\n+{\n+  typedef HOST_WIDE_INT compare_type;\n+\n+  static hashval_t hash (rtx i);\n+  static bool equal (rtx i, HOST_WIDE_INT h);\n+};\n \n-static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n-     htab_t const_wide_int_htab;\n+static GTY ((cache)) hash_table<const_int_hasher> *const_int_htab;\n+\n+struct const_wide_int_hasher : ggc_cache_hasher<rtx>\n+{\n+  static hashval_t hash (rtx x);\n+  static bool equal (rtx x, rtx y);\n+};\n+\n+static GTY ((cache)) hash_table<const_wide_int_hasher> *const_wide_int_htab;\n \n /* A hash table storing register attribute structures.  */\n-static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct reg_attrs)))\n-     htab_t reg_attrs_htab;\n+struct reg_attr_hasher : ggc_cache_hasher<reg_attrs *>\n+{\n+  static hashval_t hash (reg_attrs *x);\n+  static bool equal (reg_attrs *a, reg_attrs *b);\n+};\n+\n+static GTY ((cache)) hash_table<reg_attr_hasher> *reg_attrs_htab;\n \n /* A hash table storing all CONST_DOUBLEs.  */\n-static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n-     htab_t const_double_htab;\n+struct const_double_hasher : ggc_cache_hasher<rtx>\n+{\n+  static hashval_t hash (rtx x);\n+  static bool equal (rtx x, rtx y);\n+};\n+\n+static GTY ((cache)) hash_table<const_double_hasher> *const_double_htab;\n \n /* A hash table storing all CONST_FIXEDs.  */\n-static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n-     htab_t const_fixed_htab;\n+struct const_fixed_hasher : ggc_cache_hasher<rtx>\n+{\n+  static hashval_t hash (rtx x);\n+  static bool equal (rtx x, rtx y);\n+};\n+\n+static GTY ((cache)) hash_table<const_fixed_hasher> *const_fixed_htab;\n \n #define cur_insn_uid (crtl->emit.x_cur_insn_uid)\n #define cur_debug_insn_uid (crtl->emit.x_cur_debug_insn_uid)\n #define first_label_num (crtl->emit.x_first_label_num)\n \n static void set_used_decls (tree);\n static void mark_label_nuses (rtx);\n-static hashval_t const_int_htab_hash (const void *);\n-static int const_int_htab_eq (const void *, const void *);\n #if TARGET_SUPPORTS_WIDE_INT\n-static hashval_t const_wide_int_htab_hash (const void *);\n-static int const_wide_int_htab_eq (const void *, const void *);\n static rtx lookup_const_wide_int (rtx);\n #endif\n-static hashval_t const_double_htab_hash (const void *);\n-static int const_double_htab_eq (const void *, const void *);\n static rtx lookup_const_double (rtx);\n-static hashval_t const_fixed_htab_hash (const void *);\n-static int const_fixed_htab_eq (const void *, const void *);\n static rtx lookup_const_fixed (rtx);\n-static hashval_t reg_attrs_htab_hash (const void *);\n-static int reg_attrs_htab_eq (const void *, const void *);\n static reg_attrs *get_reg_attrs (tree, int);\n static rtx gen_const_vector (machine_mode, int);\n static void copy_rtx_if_shared_1 (rtx *orig);\n@@ -180,31 +197,31 @@ int split_branch_probability = -1;\n \f\n /* Returns a hash code for X (which is a really a CONST_INT).  */\n \n-static hashval_t\n-const_int_htab_hash (const void *x)\n+hashval_t\n+const_int_hasher::hash (rtx x)\n {\n-  return (hashval_t) INTVAL ((const_rtx) x);\n+  return (hashval_t) INTVAL (x);\n }\n \n /* Returns nonzero if the value represented by X (which is really a\n    CONST_INT) is the same as that given by Y (which is really a\n    HOST_WIDE_INT *).  */\n \n-static int\n-const_int_htab_eq (const void *x, const void *y)\n+bool\n+const_int_hasher::equal (rtx x, HOST_WIDE_INT y)\n {\n-  return (INTVAL ((const_rtx) x) == *((const HOST_WIDE_INT *) y));\n+  return (INTVAL (x) == y);\n }\n \n #if TARGET_SUPPORTS_WIDE_INT\n /* Returns a hash code for X (which is a really a CONST_WIDE_INT).  */\n \n-static hashval_t\n-const_wide_int_htab_hash (const void *x)\n+hashval_t\n+const_wide_int_hasher::hash (rtx x)\n {\n   int i;\n   HOST_WIDE_INT hash = 0;\n-  const_rtx xr = (const_rtx) x;\n+  const_rtx xr = x;\n \n   for (i = 0; i < CONST_WIDE_INT_NUNITS (xr); i++)\n     hash += CONST_WIDE_INT_ELT (xr, i);\n@@ -216,28 +233,28 @@ const_wide_int_htab_hash (const void *x)\n    CONST_WIDE_INT) is the same as that given by Y (which is really a\n    CONST_WIDE_INT).  */\n \n-static int\n-const_wide_int_htab_eq (const void *x, const void *y)\n+bool\n+const_wide_int_hasher::equal (rtx x, rtx y)\n {\n   int i;\n-  const_rtx xr = (const_rtx) x;\n-  const_rtx yr = (const_rtx) y;\n+  const_rtx xr = x;\n+  const_rtx yr = y;\n   if (CONST_WIDE_INT_NUNITS (xr) != CONST_WIDE_INT_NUNITS (yr))\n-    return 0;\n+    return false;\n \n   for (i = 0; i < CONST_WIDE_INT_NUNITS (xr); i++)\n     if (CONST_WIDE_INT_ELT (xr, i) != CONST_WIDE_INT_ELT (yr, i))\n-      return 0;\n+      return false;\n \n-  return 1;\n+  return true;\n }\n #endif\n \n /* Returns a hash code for X (which is really a CONST_DOUBLE).  */\n-static hashval_t\n-const_double_htab_hash (const void *x)\n+hashval_t\n+const_double_hasher::hash (rtx x)\n {\n-  const_rtx const value = (const_rtx) x;\n+  const_rtx const value = x;\n   hashval_t h;\n \n   if (TARGET_SUPPORTS_WIDE_INT == 0 && GET_MODE (value) == VOIDmode)\n@@ -253,10 +270,10 @@ const_double_htab_hash (const void *x)\n \n /* Returns nonzero if the value represented by X (really a ...)\n    is the same as that represented by Y (really a ...) */\n-static int\n-const_double_htab_eq (const void *x, const void *y)\n+bool\n+const_double_hasher::equal (rtx x, rtx y)\n {\n-  const_rtx const a = (const_rtx)x, b = (const_rtx)y;\n+  const_rtx const a = x, b = y;\n \n   if (GET_MODE (a) != GET_MODE (b))\n     return 0;\n@@ -270,10 +287,10 @@ const_double_htab_eq (const void *x, const void *y)\n \n /* Returns a hash code for X (which is really a CONST_FIXED).  */\n \n-static hashval_t\n-const_fixed_htab_hash (const void *x)\n+hashval_t\n+const_fixed_hasher::hash (rtx x)\n {\n-  const_rtx const value = (const_rtx) x;\n+  const_rtx const value = x;\n   hashval_t h;\n \n   h = fixed_hash (CONST_FIXED_VALUE (value));\n@@ -282,13 +299,13 @@ const_fixed_htab_hash (const void *x)\n   return h;\n }\n \n-/* Returns nonzero if the value represented by X (really a ...)\n-   is the same as that represented by Y (really a ...).  */\n+/* Returns nonzero if the value represented by X is the same as that\n+   represented by Y.  */\n \n-static int\n-const_fixed_htab_eq (const void *x, const void *y)\n+bool\n+const_fixed_hasher::equal (rtx x, rtx y)\n {\n-  const_rtx const a = (const_rtx) x, b = (const_rtx) y;\n+  const_rtx const a = x, b = y;\n \n   if (GET_MODE (a) != GET_MODE (b))\n     return 0;\n@@ -338,23 +355,22 @@ set_mem_attrs (rtx mem, mem_attrs *attrs)\n \n /* Returns a hash code for X (which is a really a reg_attrs *).  */\n \n-static hashval_t\n-reg_attrs_htab_hash (const void *x)\n+hashval_t\n+reg_attr_hasher::hash (reg_attrs *x)\n {\n-  const reg_attrs *const p = (const reg_attrs *) x;\n+  const reg_attrs *const p = x;\n \n   return ((p->offset * 1000) ^ (intptr_t) p->decl);\n }\n \n-/* Returns nonzero if the value represented by X (which is really a\n-   reg_attrs *) is the same as that given by Y (which is also really a\n-   reg_attrs *).  */\n+/* Returns nonzero if the value represented by X  is the same as that given by\n+   Y.  */\n \n-static int\n-reg_attrs_htab_eq (const void *x, const void *y)\n+bool\n+reg_attr_hasher::equal (reg_attrs *x, reg_attrs *y)\n {\n-  const reg_attrs *const p = (const reg_attrs *) x;\n-  const reg_attrs *const q = (const reg_attrs *) y;\n+  const reg_attrs *const p = x;\n+  const reg_attrs *const q = y;\n \n   return (p->decl == q->decl && p->offset == q->offset);\n }\n@@ -366,7 +382,6 @@ static reg_attrs *\n get_reg_attrs (tree decl, int offset)\n {\n   reg_attrs attrs;\n-  void **slot;\n \n   /* If everything is the default, we can just return zero.  */\n   if (decl == 0 && offset == 0)\n@@ -375,14 +390,14 @@ get_reg_attrs (tree decl, int offset)\n   attrs.decl = decl;\n   attrs.offset = offset;\n \n-  slot = htab_find_slot (reg_attrs_htab, &attrs, INSERT);\n+  reg_attrs **slot = reg_attrs_htab->find_slot (&attrs, INSERT);\n   if (*slot == 0)\n     {\n       *slot = ggc_alloc<reg_attrs> ();\n       memcpy (*slot, &attrs, sizeof (reg_attrs));\n     }\n \n-  return (reg_attrs *) *slot;\n+  return *slot;\n }\n \n \n@@ -444,8 +459,6 @@ gen_rtx_INSN (machine_mode mode, rtx_insn *prev_insn, rtx_insn *next_insn,\n rtx\n gen_rtx_CONST_INT (machine_mode mode ATTRIBUTE_UNUSED, HOST_WIDE_INT arg)\n {\n-  void **slot;\n-\n   if (arg >= - MAX_SAVED_CONST_INT && arg <= MAX_SAVED_CONST_INT)\n     return const_int_rtx[arg + MAX_SAVED_CONST_INT];\n \n@@ -455,12 +468,12 @@ gen_rtx_CONST_INT (machine_mode mode ATTRIBUTE_UNUSED, HOST_WIDE_INT arg)\n #endif\n \n   /* Look up the CONST_INT in the hash table.  */\n-  slot = htab_find_slot_with_hash (const_int_htab, &arg,\n-\t\t\t\t   (hashval_t) arg, INSERT);\n+  rtx *slot = const_int_htab->find_slot_with_hash (arg, (hashval_t) arg,\n+\t\t\t\t\t\t   INSERT);\n   if (*slot == 0)\n     *slot = gen_rtx_raw_CONST_INT (VOIDmode, arg);\n \n-  return (rtx) *slot;\n+  return *slot;\n }\n \n rtx\n@@ -479,11 +492,11 @@ gen_int_mode (HOST_WIDE_INT c, machine_mode mode)\n static rtx\n lookup_const_double (rtx real)\n {\n-  void **slot = htab_find_slot (const_double_htab, real, INSERT);\n+  rtx *slot = const_double_htab->find_slot (real, INSERT);\n   if (*slot == 0)\n     *slot = real;\n \n-  return (rtx) *slot;\n+  return *slot;\n }\n \n /* Return a CONST_DOUBLE rtx for a floating-point value specified by\n@@ -506,11 +519,11 @@ const_double_from_real_value (REAL_VALUE_TYPE value, machine_mode mode)\n static rtx\n lookup_const_fixed (rtx fixed)\n {\n-  void **slot = htab_find_slot (const_fixed_htab, fixed, INSERT);\n+  rtx *slot = const_fixed_htab->find_slot (fixed, INSERT);\n   if (*slot == 0)\n     *slot = fixed;\n \n-  return (rtx) *slot;\n+  return *slot;\n }\n \n /* Return a CONST_FIXED rtx for a fixed-point value specified by\n@@ -557,11 +570,11 @@ rtx_to_double_int (const_rtx cst)\n static rtx\n lookup_const_wide_int (rtx wint)\n {\n-  void **slot = htab_find_slot (const_wide_int_htab, wint, INSERT);\n+  rtx *slot = const_wide_int_htab->find_slot (wint, INSERT);\n   if (*slot == 0)\n     *slot = wint;\n \n-  return (rtx) *slot;\n+  return *slot;\n }\n #endif\n \n@@ -5812,7 +5825,7 @@ init_emit_regs (void)\n   mem_attrs *attrs;\n \n   /* Reset register attributes */\n-  htab_empty (reg_attrs_htab);\n+  reg_attrs_htab->empty ();\n \n   /* We need reg_raw_mode, so initialize the modes now.  */\n   init_reg_modes_target ();\n@@ -5901,21 +5914,16 @@ init_emit_once (void)\n \n   /* Initialize the CONST_INT, CONST_WIDE_INT, CONST_DOUBLE,\n      CONST_FIXED, and memory attribute hash tables.  */\n-  const_int_htab = htab_create_ggc (37, const_int_htab_hash,\n-\t\t\t\t    const_int_htab_eq, NULL);\n+  const_int_htab = hash_table<const_int_hasher>::create_ggc (37);\n \n #if TARGET_SUPPORTS_WIDE_INT\n-  const_wide_int_htab = htab_create_ggc (37, const_wide_int_htab_hash,\n-\t\t\t\t\t const_wide_int_htab_eq, NULL);\n+  const_wide_int_htab = hash_table<const_wide_int_hasher>::create_ggc (37);\n #endif\n-  const_double_htab = htab_create_ggc (37, const_double_htab_hash,\n-\t\t\t\t       const_double_htab_eq, NULL);\n+  const_double_htab = hash_table<const_double_hasher>::create_ggc (37);\n \n-  const_fixed_htab = htab_create_ggc (37, const_fixed_htab_hash,\n-\t\t\t\t      const_fixed_htab_eq, NULL);\n+  const_fixed_htab = hash_table<const_fixed_hasher>::create_ggc (37);\n \n-  reg_attrs_htab = htab_create_ggc (37, reg_attrs_htab_hash,\n-\t\t\t\t    reg_attrs_htab_eq, NULL);\n+  reg_attrs_htab = hash_table<reg_attr_hasher>::create_ggc (37);\n \n #ifdef INIT_EXPANDERS\n   /* This is to initialize {init|mark|free}_machine_status before the first"}, {"sha": "2dc857e57bd643d2faa1322cea810bc5321286bc", "filename": "gcc/gengtype.c", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "patch": "@@ -4482,6 +4482,60 @@ finish_root_table (struct flist *flp, const char *pfx, const char *lastname,\n   }\n }\n \n+/* Finish off the created gt_clear_caches_file_c functions.  */\n+\n+static void\n+finish_cache_funcs (flist *flp)\n+{\n+  struct flist *fli2;\n+\n+  for (fli2 = flp; fli2; fli2 = fli2->next)\n+    if (fli2->started_p)\n+      {\n+\toprintf (fli2->f, \"}\\n\\n\");\n+      }\n+\n+  for (fli2 = flp; fli2 && base_files; fli2 = fli2->next)\n+    if (fli2->started_p)\n+      {\n+\tlang_bitmap bitmap = get_lang_bitmap (fli2->file);\n+\tint fnum;\n+\n+\tfor (fnum = 0; bitmap != 0; fnum++, bitmap >>= 1)\n+\t  if (bitmap & 1)\n+\t    {\n+\t      oprintf (base_files[fnum], \"extern void gt_clear_caches_\");\n+\t      put_mangled_filename (base_files[fnum], fli2->file);\n+\t      oprintf (base_files[fnum], \" ();\\n\");\n+\t    }\n+      }\n+\n+  for (size_t fnum = 0; base_files && fnum < num_lang_dirs; fnum++)\n+    oprintf (base_files[fnum], \"void\\ngt_clear_caches ()\\n{\\n\");\n+\n+  for (fli2 = flp; fli2; fli2 = fli2->next)\n+    if (fli2->started_p)\n+      {\n+\tlang_bitmap bitmap = get_lang_bitmap (fli2->file);\n+\tint fnum;\n+\n+\tfli2->started_p = 0;\n+\n+\tfor (fnum = 0; base_files && bitmap != 0; fnum++, bitmap >>= 1)\n+\t  if (bitmap & 1)\n+\t    {\n+\t      oprintf (base_files[fnum], \"  gt_clear_caches_\");\n+\t      put_mangled_filename (base_files[fnum], fli2->file);\n+\t      oprintf (base_files[fnum], \" ();\\n\");\n+\t    }\n+      }\n+\n+  for (size_t fnum = 0; base_files && fnum < num_lang_dirs; fnum++)\n+    {\n+      oprintf (base_files[fnum], \"}\\n\");\n+    }\n+}\n+\n /* Write the first three fields (pointer, count and stride) for\n    root NAME to F.  V and LINE are as for write_root.\n \n@@ -4801,6 +4855,8 @@ write_roots (pair_p variables, bool emit_pch)\n \t  ;\n \telse if (strcmp (o->name, \"if_marked\") == 0)\n \t  ;\n+\telse if (strcmp (o->name, \"cache\") == 0)\n+\t  ;\n \telse\n \t  error_at_line (&v->line,\n \t\t\t \"global `%s' has unknown option `%s'\",\n@@ -4952,6 +5008,37 @@ write_roots (pair_p variables, bool emit_pch)\n   finish_root_table (flp, \"ggc_rc\", \"LAST_GGC_CACHE_TAB\", \"ggc_cache_tab\",\n \t\t     \"gt_ggc_cache_rtab\");\n \n+  for (v = variables; v; v = v->next)\n+    {\n+      outf_p f = get_output_file_with_visibility (CONST_CAST (input_file*,\n+\t\t\t\t\t\t\t      v->line.file));\n+      struct flist *fli;\n+      bool cache = false;\n+      options_p o;\n+\n+      for (o = v->opt; o; o = o->next)\n+\tif (strcmp (o->name, \"cache\") == 0)\n+\t  cache = true;\n+       if (!cache)\n+\tcontinue;\n+\n+      for (fli = flp; fli; fli = fli->next)\n+\tif (fli->f == f)\n+\t  break;\n+      if (!fli->started_p)\n+\t{\n+\t  fli->started_p = 1;\n+\n+\t  oprintf (f, \"void\\ngt_clear_caches_\");\n+\t  put_mangled_filename (f, v->line.file);\n+\t  oprintf (f, \" ()\\n{\\n\");\n+\t}\n+\n+      oprintf (f, \"  gt_cleare_cache (%s);\\n\", v->name);\n+    }\n+\n+  finish_cache_funcs (flp);\n+\n   if (!emit_pch)\n     return;\n "}, {"sha": "06f70c2f35303b01e888ed6ec7a946832aed587b", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "patch": "@@ -162,6 +162,8 @@ ggc_mark_roots (void)\n   for (ct = gt_ggc_cache_rtab; *ct; ct++)\n     ggc_scan_cache_tab (*ct);\n \n+  gt_clear_caches ();\n+\n   FOR_EACH_VEC_ELT (extra_cache_vec, i, ctp)\n     ggc_scan_cache_tab (ctp);\n "}, {"sha": "fb8ce733a8b3edbe243c6c6b4cd861d28c405079", "filename": "gcc/ggc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "patch": "@@ -54,6 +54,9 @@ extern int gt_pch_note_object (void *, void *, gt_note_pointers);\n    function.  */\n extern void gt_pch_note_reorder (void *, void *, gt_handle_reorder);\n \n+/* generated function to clear caches in gc memory.  */\n+extern void gt_clear_caches ();\n+\n /* Mark the object in the first parameter and anything it points to.  */\n typedef void (*gt_pointer_walker) (void *);\n "}, {"sha": "a6f66c05dd65819597579119d59e88baabf7f015", "filename": "gcc/hash-table.h", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "patch": "@@ -334,6 +334,44 @@ struct ggc_hasher\n   }\n };\n \n+/* Hasher for cache entry in gc memory.  */\n+\n+template<typename T>\n+struct ggc_cache_hasher\n+{\n+  typedef T value_type;\n+  typedef T compare_type;\n+  typedef int store_values_directly;\n+\n+  static void remove (T &) {}\n+\n+  /* Entries are weakly held because this is for caches.  */\n+\n+  static void ggc_mx (T &) {}\n+\n+  static void\n+  pch_nx (T &p)\n+  {\n+  extern void gt_pch_nx (T &);\n+  gt_pch_nx (p);\n+  }\n+\n+  static void\n+  pch_nx (T &p, gt_pointer_operator op, void *cookie)\n+  {\n+    op (&p, cookie);\n+  }\n+\n+  /* Clear out entries if they are about to be gc'd.  */\n+\n+  static void\n+  handle_cache_entry (T &e)\n+  {\n+    if (e != HTAB_EMPTY_ENTRY && e != HTAB_DELETED_ENTRY && !ggc_marked_p (e))\n+      e = static_cast<T> (HTAB_DELETED_ENTRY);\n+  }\n+};\n+\n \n /* Table of primes and their inversion information.  */\n \n@@ -1667,4 +1705,16 @@ gt_pch_nx (hash_table<D> *h, gt_pointer_operator op, void *cookie)\n   op (&h->m_entries, cookie);\n }\n \n+template<typename H>\n+inline void\n+gt_cleare_cache (hash_table<H> *h)\n+{\n+  if (!h)\n+    return;\n+\n+  for (typename hash_table<H>::iterator iter = h->begin (); iter != h->end ();\n+       ++iter)\n+    H::handle_cache_entry (*iter);\n+}\n+\n #endif /* TYPED_HASHTAB_H */"}, {"sha": "b9d62ae3cf7c47a65900c5a2df761c20b2f2c55a", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "patch": "@@ -181,7 +181,7 @@ struct GTY(()) mem_attrs\n    object in the low part of a 4-byte register, the OFFSET field\n    will be -3 rather than 0.  */\n \n-struct GTY(()) reg_attrs {\n+struct GTY((for_user)) reg_attrs {\n   tree decl;\t\t\t/* decl corresponding to REG.  */\n   HOST_WIDE_INT offset;\t\t/* Offset from start of DECL.  */\n };"}, {"sha": "35d2ad83c441260679f613852e408b7897f40341", "filename": "gcc/tree.c", "status": "modified", "additions": 45, "deletions": 55, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "patch": "@@ -205,8 +205,14 @@ static GTY ((if_marked (\"type_hash_marked_p\"), param_is (struct type_hash)))\n \n /* Hash table and temporary node for larger integer const values.  */\n static GTY (()) tree int_cst_node;\n-static GTY ((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n-     htab_t int_cst_hash_table;\n+\n+struct int_cst_hasher : ggc_cache_hasher<tree>\n+{\n+  static hashval_t hash (tree t);\n+  static bool equal (tree x, tree y);\n+};\n+\n+static GTY ((cache)) hash_table<int_cst_hasher> *int_cst_hash_table;\n \n /* Hash table for optimization flags and target option flags.  Use the same\n    hash table for both sets of options.  Nodes for building the current\n@@ -215,8 +221,14 @@ static GTY ((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n    allocating and freeing up a node repeatably.  */\n static GTY (()) tree cl_optimization_node;\n static GTY (()) tree cl_target_option_node;\n-static GTY ((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n-     htab_t cl_option_hash_table;\n+\n+struct cl_option_hasher : ggc_cache_hasher<tree>\n+{\n+  static hashval_t hash (tree t);\n+  static bool equal (tree x, tree y);\n+};\n+\n+static GTY ((cache)) hash_table<cl_option_hasher> *cl_option_hash_table;\n \n /* General tree->tree mapping  structure for use in hash tables.  */\n \n@@ -233,10 +245,6 @@ static GTY ((if_marked (\"tree_vec_map_marked_p\"), param_is (struct tree_vec_map)\n static void set_type_quals (tree, int);\n static int type_hash_eq (const void *, const void *);\n static hashval_t type_hash_hash (const void *);\n-static hashval_t int_cst_hash_hash (const void *);\n-static int int_cst_hash_eq (const void *, const void *);\n-static hashval_t cl_option_hash_hash (const void *);\n-static int cl_option_hash_eq (const void *, const void *);\n static void print_type_hash_statistics (void);\n static void print_debug_expr_statistics (void);\n static void print_value_expr_statistics (void);\n@@ -585,13 +593,11 @@ init_ttree (void)\n   value_expr_for_decl = htab_create_ggc (512, tree_decl_map_hash,\n \t\t\t\t\t tree_decl_map_eq, 0);\n \n-  int_cst_hash_table = htab_create_ggc (1024, int_cst_hash_hash,\n-\t\t\t\t\tint_cst_hash_eq, NULL);\n+  int_cst_hash_table = hash_table<int_cst_hasher>::create_ggc (1024);\n \n   int_cst_node = make_int_cst (1, 1);\n \n-  cl_option_hash_table = htab_create_ggc (64, cl_option_hash_hash,\n-\t\t\t\t\t  cl_option_hash_eq, NULL);\n+  cl_option_hash_table = hash_table<cl_option_hasher>::create_ggc (64);\n \n   cl_optimization_node = make_node (OPTIMIZATION_NODE);\n   cl_target_option_node = make_node (TARGET_OPTION_NODE);\n@@ -1256,10 +1262,10 @@ force_fit_type (tree type, const wide_int_ref &cst,\n \n /* Return the hash code code X, an INTEGER_CST.  */\n \n-static hashval_t\n-int_cst_hash_hash (const void *x)\n+hashval_t\n+int_cst_hasher::hash (tree x)\n {\n-  const_tree const t = (const_tree) x;\n+  const_tree const t = x;\n   hashval_t code = htab_hash_pointer (TREE_TYPE (t));\n   int i;\n \n@@ -1272,11 +1278,11 @@ int_cst_hash_hash (const void *x)\n /* Return nonzero if the value represented by *X (an INTEGER_CST tree node)\n    is the same as that given by *Y, which is the same.  */\n \n-static int\n-int_cst_hash_eq (const void *x, const void *y)\n+bool\n+int_cst_hasher::equal (tree x, tree y)\n {\n-  const_tree const xt = (const_tree) x;\n-  const_tree const yt = (const_tree) y;\n+  const_tree const xt = x;\n+  const_tree const yt = y;\n \n   if (TREE_TYPE (xt) != TREE_TYPE (yt)\n       || TREE_INT_CST_NUNITS (xt) != TREE_INT_CST_NUNITS (yt)\n@@ -1408,13 +1414,12 @@ wide_int_to_tree (tree type, const wide_int_ref &pcst)\n \t{\n \t  /* Use the cache of larger shared ints, using int_cst_node as\n \t     a temporary.  */\n-\t  void **slot;\n \n \t  TREE_INT_CST_ELT (int_cst_node, 0) = hwi;\n \t  TREE_TYPE (int_cst_node) = type;\n \n-\t  slot = htab_find_slot (int_cst_hash_table, int_cst_node, INSERT);\n-\t  t = (tree) *slot;\n+\t  tree *slot = int_cst_hash_table->find_slot (int_cst_node, INSERT);\n+\t  t = *slot;\n \t  if (!t)\n \t    {\n \t      /* Insert this one into the hash table.  */\n@@ -1430,11 +1435,10 @@ wide_int_to_tree (tree type, const wide_int_ref &pcst)\n       /* The value either hashes properly or we drop it on the floor\n \t for the gc to take care of.  There will not be enough of them\n \t to worry about.  */\n-      void **slot;\n \n       tree nt = build_new_int_cst (type, cst);\n-      slot = htab_find_slot (int_cst_hash_table, nt, INSERT);\n-      t = (tree) *slot;\n+      tree *slot = int_cst_hash_table->find_slot (nt, INSERT);\n+      t = *slot;\n       if (!t)\n \t{\n \t  /* Insert this one into the hash table.  */\n@@ -1539,9 +1543,7 @@ cache_integer_cst (tree t)\n   else\n     {\n       /* Use the cache of larger shared ints.  */\n-      void **slot;\n-\n-      slot = htab_find_slot (int_cst_hash_table, t, INSERT);\n+      tree *slot = int_cst_hash_table->find_slot (t, INSERT);\n       /* If there is already an entry for the number verify it's the\n          same.  */\n       if (*slot)\n@@ -11498,10 +11500,10 @@ tree_nonartificial_location (tree exp)\n \n /* Return the hash code code X, an OPTIMIZATION_NODE or TARGET_OPTION code.  */\n \n-static hashval_t\n-cl_option_hash_hash (const void *x)\n+hashval_t\n+cl_option_hasher::hash (tree x)\n {\n-  const_tree const t = (const_tree) x;\n+  const_tree const t = x;\n   const char *p;\n   size_t i;\n   size_t len = 0;\n@@ -11532,11 +11534,11 @@ cl_option_hash_hash (const void *x)\n    TARGET_OPTION tree node) is the same as that given by *Y, which is the\n    same.  */\n \n-static int\n-cl_option_hash_eq (const void *x, const void *y)\n+bool\n+cl_option_hasher::equal (tree x, tree y)\n {\n-  const_tree const xt = (const_tree) x;\n-  const_tree const yt = (const_tree) y;\n+  const_tree const xt = x;\n+  const_tree const yt = y;\n   const char *xp;\n   const char *yp;\n   size_t len;\n@@ -11569,15 +11571,14 @@ tree\n build_optimization_node (struct gcc_options *opts)\n {\n   tree t;\n-  void **slot;\n \n   /* Use the cache of optimization nodes.  */\n \n   cl_optimization_save (TREE_OPTIMIZATION (cl_optimization_node),\n \t\t\topts);\n \n-  slot = htab_find_slot (cl_option_hash_table, cl_optimization_node, INSERT);\n-  t = (tree) *slot;\n+  tree *slot = cl_option_hash_table->find_slot (cl_optimization_node, INSERT);\n+  t = *slot;\n   if (!t)\n     {\n       /* Insert this one into the hash table.  */\n@@ -11597,15 +11598,14 @@ tree\n build_target_option_node (struct gcc_options *opts)\n {\n   tree t;\n-  void **slot;\n \n   /* Use the cache of optimization nodes.  */\n \n   cl_target_option_save (TREE_TARGET_OPTION (cl_target_option_node),\n \t\t\t opts);\n \n-  slot = htab_find_slot (cl_option_hash_table, cl_target_option_node, INSERT);\n-  t = (tree) *slot;\n+  tree *slot = cl_option_hash_table->find_slot (cl_target_option_node, INSERT);\n+  t = *slot;\n   if (!t)\n     {\n       /* Insert this one into the hash table.  */\n@@ -11619,26 +11619,16 @@ build_target_option_node (struct gcc_options *opts)\n   return t;\n }\n \n-/* Reset TREE_TARGET_GLOBALS cache for TARGET_OPTION_NODE.\n-   Called through htab_traverse.  */\n-\n-static int\n-prepare_target_option_node_for_pch (void **slot, void *)\n-{\n-  tree node = (tree) *slot;\n-  if (TREE_CODE (node) == TARGET_OPTION_NODE)\n-    TREE_TARGET_GLOBALS (node) = NULL;\n-  return 1;\n-}\n-\n /* Clear TREE_TARGET_GLOBALS of all TARGET_OPTION_NODE trees,\n    so that they aren't saved during PCH writing.  */\n \n void\n prepare_target_option_nodes_for_pch (void)\n {\n-  htab_traverse (cl_option_hash_table, prepare_target_option_node_for_pch,\n-\t\t NULL);\n+  hash_table<cl_option_hasher>::iterator iter = cl_option_hash_table->begin ();\n+  for (; iter != cl_option_hash_table->end (); ++iter)\n+    if (TREE_CODE (*iter) == TARGET_OPTION_NODE)\n+      TREE_TARGET_GLOBALS (*iter) = NULL;\n }\n \n /* Determine the \"ultimate origin\" of a block.  The block may be an inlined"}]}