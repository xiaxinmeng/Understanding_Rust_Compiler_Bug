{"sha": "003b40ae57ba5c1acb06752936536298e029c189", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAzYjQwYWU1N2JhNWMxYWNiMDY3NTI5MzY1MzYyOThlMDI5YzE4OQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-08-13T06:59:25Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-08-13T06:59:25Z"}, "message": "gimple.h (gcall::code_): New constant static member.\n\n2015-08-13  Richard Biener  <rguenther@suse.de>\n\n\t* gimple.h (gcall::code_): New constant static member.\n\t(gcond::code_): Likewise.\n\t* gimple.c (gcall::code_): Define.\n\t(gcond::code_): Likewise.\n\t(is_a_helper <const gcond *>): Add.\n\t(gimple_call_lhs): Use GIMPLE_CHECK2 in the gimple overload\n\tand forward to a new gcall overload with less checking and a\n\tcheaper way to access the operand.\n\t(gimple_call_lhs_ptr): Likewise.\n\t(gimple_call_set_lhs): Likewise.\n\t(gimple_call_internal_p): Likewise.\n\t(gimple_call_with_bounds_p): Likewise.\n\t(gimple_call_set_with_bounds): Likewise.\n\t(gimple_call_internal_fn): Likewise.\n\t(gimple_call_set_ctrl_altering): Likewise.\n\t(gimple_call_ctrl_altering_p): Likewise.\n\t(gimple_call_fntype): Likewise.\n\t(gimple_call_fn): Likewise.\n\t(gimple_call_fn_ptr): Likewise.\n\t(gimple_call_set_fndecl): Likewise.\n\t(gimple_call_fndecl): Likewise.\n\t(gimple_call_chain): Likewise.\n\t(gimple_call_num_args): Likewise.\n\t(gimple_call_arg): Likewise.\n\t(gimple_call_arg_ptr): Likewise.\n\t(gimple_call_set_arg): Likewise.\n\t(gimple_call_noreturn_p): Likewise.\n\t(gimple_cond_code): Likewise.\n\t(gimple_cond_lhs): Likewise.\n\t(gimple_cond_rhs): Likewise.\n\t(gimple_has_lhs): Reduce checking.\n\nFrom-SVN: r226849", "tree": {"sha": "6025528cd24e8489935090edf995acae8c4d6f89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6025528cd24e8489935090edf995acae8c4d6f89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/003b40ae57ba5c1acb06752936536298e029c189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/003b40ae57ba5c1acb06752936536298e029c189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/003b40ae57ba5c1acb06752936536298e029c189", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/003b40ae57ba5c1acb06752936536298e029c189/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "95765f369f6f6ee15399d352593cb6912a024d28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95765f369f6f6ee15399d352593cb6912a024d28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95765f369f6f6ee15399d352593cb6912a024d28"}], "stats": {"total": 299, "additions": 244, "deletions": 55}, "files": [{"sha": "ae73d58fb584e886425fb42dd8bf4660c61ff278", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003b40ae57ba5c1acb06752936536298e029c189/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003b40ae57ba5c1acb06752936536298e029c189/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=003b40ae57ba5c1acb06752936536298e029c189", "patch": "@@ -1,3 +1,37 @@\n+2015-08-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple.h (gcall::code_): New constant static member.\n+\t(gcond::code_): Likewise.\n+\t* gimple.c (gcall::code_): Define.\n+\t(gcond::code_): Likewise.\n+\t(is_a_helper <const gcond *>): Add.\n+\t(gimple_call_lhs): Use GIMPLE_CHECK2 in the gimple overload\n+\tand forward to a new gcall overload with less checking and a\n+\tcheaper way to access the operand.\n+\t(gimple_call_lhs_ptr): Likewise.\n+\t(gimple_call_set_lhs): Likewise.\n+\t(gimple_call_internal_p): Likewise.\n+\t(gimple_call_with_bounds_p): Likewise.\n+\t(gimple_call_set_with_bounds): Likewise.\n+\t(gimple_call_internal_fn): Likewise.\n+\t(gimple_call_set_ctrl_altering): Likewise.\n+\t(gimple_call_ctrl_altering_p): Likewise.\n+\t(gimple_call_fntype): Likewise.\n+\t(gimple_call_fn): Likewise.\n+\t(gimple_call_fn_ptr): Likewise.\n+\t(gimple_call_set_fndecl): Likewise.\n+\t(gimple_call_fndecl): Likewise.\n+\t(gimple_call_chain): Likewise.\n+\t(gimple_call_num_args): Likewise.\n+\t(gimple_call_arg): Likewise.\n+\t(gimple_call_arg_ptr): Likewise.\n+\t(gimple_call_set_arg): Likewise.\n+\t(gimple_call_noreturn_p): Likewise.\n+\t(gimple_cond_code): Likewise.\n+\t(gimple_cond_lhs): Likewise.\n+\t(gimple_cond_rhs): Likewise.\n+\t(gimple_has_lhs): Reduce checking.\n+\n 2015-08-13  Naveen H.S  <Naveen.Hurugalawadi@caviumnetworks.com>\n \n \tPR middle-end/25529"}, {"sha": "cca328a30e4ec025bfd18789e7b96a1022624e77", "filename": "gcc/gimple.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003b40ae57ba5c1acb06752936536298e029c189/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003b40ae57ba5c1acb06752936536298e029c189/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=003b40ae57ba5c1acb06752936536298e029c189", "patch": "@@ -91,6 +91,8 @@ static const char * const gimple_alloc_kind_names[] = {\n \n /* Static gimple tuple members.  */\n const enum gimple_code gassign::code_;\n+const enum gimple_code gcall::code_;\n+const enum gimple_code gcond::code_;\n \n \n /* Gimple tuple constructors."}, {"sha": "55f21318c26d259868280db57b3bf2966ff3e271", "filename": "gcc/gimple.h", "status": "modified", "additions": 208, "deletions": 55, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003b40ae57ba5c1acb06752936536298e029c189/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003b40ae57ba5c1acb06752936536298e029c189/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=003b40ae57ba5c1acb06752936536298e029c189", "patch": "@@ -351,6 +351,8 @@ struct GTY((tag(\"GSS_CALL\")))\n      of this structure.  In particular, this means that this\n      structure cannot be embedded inside another one.  */\n   tree GTY((length (\"%h.num_ops\"))) op[1];\n+\n+  static const enum gimple_code code_ = GIMPLE_CALL;\n };\n \n \n@@ -837,6 +839,7 @@ struct GTY((tag(\"GSS_WITH_OPS\")))\n   gcond : public gimple_statement_with_ops\n {\n   /* no additional fields; this uses the layout for GSS_WITH_OPS. */\n+  static const enum gimple_code code_ = GIMPLE_COND;\n };\n \n /* A statement with the invariant that\n@@ -956,6 +959,14 @@ is_a_helper <gcond *>::test (gimple gs)\n   return gs->code == GIMPLE_COND;\n }\n \n+template <>\n+template <>\n+inline bool\n+is_a_helper <const gcond *>::test (const_gimple gs)\n+{\n+  return gs->code == GIMPLE_COND;\n+}\n+\n template <>\n template <>\n inline bool\n@@ -2745,114 +2756,175 @@ is_gimple_call (const_gimple gs)\n \n /* Return the LHS of call statement GS.  */\n \n+static inline tree\n+gimple_call_lhs (const gcall *gs)\n+{\n+  return gs->op[0];\n+}\n+\n static inline tree\n gimple_call_lhs (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  return gimple_op (gs, 0);\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_lhs (gc);\n }\n \n \n /* Return a pointer to the LHS of call statement GS.  */\n \n+static inline tree *\n+gimple_call_lhs_ptr (const gcall *gs)\n+{\n+  return const_cast<tree *> (&gs->op[0]);\n+}\n+\n static inline tree *\n gimple_call_lhs_ptr (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  return gimple_op_ptr (gs, 0);\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_lhs_ptr (gc);\n }\n \n \n /* Set LHS to be the LHS operand of call statement GS.  */\n \n static inline void\n-gimple_call_set_lhs (gimple gs, tree lhs)\n+gimple_call_set_lhs (gcall *gs, tree lhs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  gimple_set_op (gs, 0, lhs);\n+  gs->op[0] = lhs;\n   if (lhs && TREE_CODE (lhs) == SSA_NAME)\n     SSA_NAME_DEF_STMT (lhs) = gs;\n }\n \n+static inline void\n+gimple_call_set_lhs (gimple gs, tree lhs)\n+{\n+  gcall *gc = GIMPLE_CHECK2<gcall *> (gs);\n+  gimple_call_set_lhs (gc, lhs);\n+}\n+\n \n /* Return true if call GS calls an internal-only function, as enumerated\n    by internal_fn.  */\n \n static inline bool\n-gimple_call_internal_p (const_gimple gs)\n+gimple_call_internal_p (const gcall *gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n   return (gs->subcode & GF_CALL_INTERNAL) != 0;\n }\n \n+static inline bool\n+gimple_call_internal_p (const_gimple gs)\n+{\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_internal_p (gc);\n+}\n+\n \n /* Return true if call GS is marked as instrumented by\n    Pointer Bounds Checker.  */\n \n static inline bool\n-gimple_call_with_bounds_p (const_gimple gs)\n+gimple_call_with_bounds_p (const gcall *gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n   return (gs->subcode & GF_CALL_WITH_BOUNDS) != 0;\n }\n \n+static inline bool\n+gimple_call_with_bounds_p (const_gimple gs)\n+{\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_with_bounds_p (gc);\n+}\n+\n \n /* If INSTRUMENTED_P is true, marm statement GS as instrumented by\n    Pointer Bounds Checker.  */\n \n static inline void\n-gimple_call_set_with_bounds (gimple gs, bool with_bounds)\n+gimple_call_set_with_bounds (gcall *gs, bool with_bounds)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n   if (with_bounds)\n     gs->subcode |= GF_CALL_WITH_BOUNDS;\n   else\n     gs->subcode &= ~GF_CALL_WITH_BOUNDS;\n }\n \n+static inline void\n+gimple_call_set_with_bounds (gimple gs, bool with_bounds)\n+{\n+  gcall *gc = GIMPLE_CHECK2<gcall *> (gs);\n+  gimple_call_set_with_bounds (gc, with_bounds);\n+}\n+\n \n /* Return the target of internal call GS.  */\n \n static inline enum internal_fn\n-gimple_call_internal_fn (const_gimple gs)\n+gimple_call_internal_fn (const gcall *gs)\n {\n   gcc_gimple_checking_assert (gimple_call_internal_p (gs));\n-  return static_cast <const gcall *> (gs)->u.internal_fn;\n+  return gs->u.internal_fn;\n+}\n+\n+static inline enum internal_fn\n+gimple_call_internal_fn (const_gimple gs)\n+{\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_internal_fn (gc);\n }\n \n /* If CTRL_ALTERING_P is true, mark GIMPLE_CALL S to be a stmt\n    that could alter control flow.  */\n \n static inline void\n-gimple_call_set_ctrl_altering (gimple s, bool ctrl_altering_p)\n+gimple_call_set_ctrl_altering (gcall *s, bool ctrl_altering_p)\n {\n-  GIMPLE_CHECK (s, GIMPLE_CALL);\n   if (ctrl_altering_p)\n     s->subcode |= GF_CALL_CTRL_ALTERING;\n   else\n     s->subcode &= ~GF_CALL_CTRL_ALTERING;\n }\n \n+static inline void\n+gimple_call_set_ctrl_altering (gimple s, bool ctrl_altering_p)\n+{\n+  gcall *gc = GIMPLE_CHECK2<gcall *> (s);\n+  gimple_call_set_ctrl_altering (gc, ctrl_altering_p);\n+}\n+\n /* Return true if call GS calls an func whose GF_CALL_CTRL_ALTERING\n    flag is set. Such call could not be a stmt in the middle of a bb.  */\n \n static inline bool\n-gimple_call_ctrl_altering_p (const_gimple gs)\n+gimple_call_ctrl_altering_p (const gcall *gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n   return (gs->subcode & GF_CALL_CTRL_ALTERING) != 0;\n }\n \n+static inline bool\n+gimple_call_ctrl_altering_p (const_gimple gs)\n+{\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_ctrl_altering_p (gc);\n+}\n+\n \n /* Return the function type of the function called by GS.  */\n \n static inline tree\n-gimple_call_fntype (const_gimple gs)\n+gimple_call_fntype (const gcall *gs)\n {\n-  const gcall *call_stmt = as_a <const gcall *> (gs);\n   if (gimple_call_internal_p (gs))\n     return NULL_TREE;\n-  return call_stmt->u.fntype;\n+  return gs->u.fntype;\n+}\n+\n+static inline tree\n+gimple_call_fntype (const_gimple gs)\n+{\n+  const gcall *call_stmt = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_fntype (call_stmt);\n }\n \n /* Set the type of the function called by CALL_STMT to FNTYPE.  */\n@@ -2868,21 +2940,33 @@ gimple_call_set_fntype (gcall *call_stmt, tree fntype)\n /* Return the tree node representing the function called by call\n    statement GS.  */\n \n+static inline tree\n+gimple_call_fn (const gcall *gs)\n+{\n+  return gs->op[1];\n+}\n+\n static inline tree\n gimple_call_fn (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  return gimple_op (gs, 1);\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_fn (gc);\n }\n \n /* Return a pointer to the tree node representing the function called by call\n    statement GS.  */\n \n+static inline tree *\n+gimple_call_fn_ptr (const gcall *gs)\n+{\n+  return const_cast<tree *> (&gs->op[1]);\n+}\n+\n static inline tree *\n gimple_call_fn_ptr (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  return gimple_op_ptr (gs, 1);\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_fn_ptr (gc);\n }\n \n \n@@ -2899,13 +2983,18 @@ gimple_call_set_fn (gcall *gs, tree fn)\n /* Set FNDECL to be the function called by call statement GS.  */\n \n static inline void\n-gimple_call_set_fndecl (gimple gs, tree decl)\n+gimple_call_set_fndecl (gcall *gs, tree decl)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n   gcc_gimple_checking_assert (!gimple_call_internal_p (gs));\n-  gimple_set_op (gs, 1, build1_loc (gimple_location (gs), ADDR_EXPR,\n-\t\t\t\t     build_pointer_type (TREE_TYPE (decl)),\n-\t\t\t\t     decl));\n+  gs->op[1] = build1_loc (gimple_location (gs), ADDR_EXPR,\n+\t\t\t  build_pointer_type (TREE_TYPE (decl)), decl);\n+}\n+\n+static inline void\n+gimple_call_set_fndecl (gimple gs, tree decl)\n+{\n+  gcall *gc = GIMPLE_CHECK2<gcall *> (gs);\n+  gimple_call_set_fndecl (gc, decl);\n }\n \n \n@@ -2924,11 +3013,18 @@ gimple_call_set_internal_fn (gcall *call_stmt, enum internal_fn fn)\n    get_callee_fndecl in tree land.  */\n \n static inline tree\n-gimple_call_fndecl (const_gimple gs)\n+gimple_call_fndecl (const gcall *gs)\n {\n   return gimple_call_addr_fndecl (gimple_call_fn (gs));\n }\n \n+static inline tree\n+gimple_call_fndecl (const_gimple gs)\n+{\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_fndecl (gc);\n+}\n+\n \n /* Return the type returned by call statement GS.  */\n \n@@ -2948,11 +3044,17 @@ gimple_call_return_type (const gcall *gs)\n \n /* Return the static chain for call statement GS.  */\n \n+static inline tree\n+gimple_call_chain (const gcall *gs)\n+{\n+  return gs->op[2];\n+}\n+\n static inline tree\n gimple_call_chain (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  return gimple_op (gs, 2);\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_chain (gc);\n }\n \n \n@@ -2975,44 +3077,69 @@ gimple_call_set_chain (gcall *call_stmt, tree chain)\n \n /* Return the number of arguments used by call statement GS.  */\n \n+static inline unsigned\n+gimple_call_num_args (const gcall *gs)\n+{\n+  return gimple_num_ops (gs) - 3;\n+}\n+\n static inline unsigned\n gimple_call_num_args (const_gimple gs)\n {\n-  unsigned num_ops;\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  num_ops = gimple_num_ops (gs);\n-  return num_ops - 3;\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_num_args (gc);\n }\n \n \n /* Return the argument at position INDEX for call statement GS.  */\n \n+static inline tree\n+gimple_call_arg (const gcall *gs, unsigned index)\n+{\n+  gcc_gimple_checking_assert (gimple_num_ops (gs) > index + 3);\n+  return gs->op[index + 3];\n+}\n+\n static inline tree\n gimple_call_arg (const_gimple gs, unsigned index)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  return gimple_op (gs, index + 3);\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_arg (gc, index);\n }\n \n \n /* Return a pointer to the argument at position INDEX for call\n    statement GS.  */\n \n+static inline tree *\n+gimple_call_arg_ptr (const gcall *gs, unsigned index)\n+{\n+  gcc_gimple_checking_assert (gimple_num_ops (gs) > index + 3);\n+  return const_cast<tree *> (&gs->op[index + 3]);\n+}\n+\n static inline tree *\n gimple_call_arg_ptr (const_gimple gs, unsigned index)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  return gimple_op_ptr (gs, index + 3);\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n+  return gimple_call_arg_ptr (gc, index);\n }\n \n \n /* Set ARG to be the argument at position INDEX for call statement GS.  */\n \n+static inline void\n+gimple_call_set_arg (gcall *gs, unsigned index, tree arg)\n+{\n+  gcc_gimple_checking_assert (gimple_num_ops (gs) > index + 3);\n+  gs->op[index + 3] = arg;\n+}\n+\n static inline void\n gimple_call_set_arg (gimple gs, unsigned index, tree arg)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  gimple_set_op (gs, index + 3, arg);\n+  gcall *gc = GIMPLE_CHECK2<gcall *> (gs);\n+  gimple_call_set_arg (gc, index, arg);\n }\n \n \n@@ -3110,12 +3237,18 @@ gimple_call_va_arg_pack_p (gcall *s)\n /* Return true if S is a noreturn call.  */\n \n static inline bool\n-gimple_call_noreturn_p (gimple s)\n+gimple_call_noreturn_p (const gcall *s)\n {\n-  GIMPLE_CHECK (s, GIMPLE_CALL);\n   return (gimple_call_flags (s) & ECF_NORETURN) != 0;\n }\n \n+static inline bool\n+gimple_call_noreturn_p (const_gimple s)\n+{\n+  const gcall *gc = GIMPLE_CHECK2<const gcall *> (s);\n+  return gimple_call_noreturn_p (gc);\n+}\n+\n \n /* If NOTHROW_P is true, GIMPLE_CALL S is a call that is known to not throw\n    even if the called function can throw in other cases.  */\n@@ -3194,21 +3327,29 @@ gimple_call_clobber_set (gcall *call_stmt)\n static inline bool\n gimple_has_lhs (gimple stmt)\n {\n-  return (is_gimple_assign (stmt)\n-\t  || (is_gimple_call (stmt)\n-\t      && gimple_call_lhs (stmt) != NULL_TREE));\n+  if (is_gimple_assign (stmt))\n+    return true;\n+  if (gcall *call = dyn_cast <gcall *> (stmt))\n+    return gimple_call_lhs (call) != NULL_TREE;\n+  return false;\n }\n \n \n /* Return the code of the predicate computed by conditional statement GS.  */\n \n static inline enum tree_code\n-gimple_cond_code (const_gimple gs)\n+gimple_cond_code (const gcond *gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_COND);\n   return (enum tree_code) gs->subcode;\n }\n \n+static inline enum tree_code\n+gimple_cond_code (const_gimple gs)\n+{\n+  const gcond *gc = GIMPLE_CHECK2<const gcond *> (gs);\n+  return gimple_cond_code (gc);\n+}\n+\n \n /* Set CODE to be the predicate code for the conditional statement GS.  */\n \n@@ -3221,11 +3362,17 @@ gimple_cond_set_code (gcond *gs, enum tree_code code)\n \n /* Return the LHS of the predicate computed by conditional statement GS.  */\n \n+static inline tree\n+gimple_cond_lhs (const gcond *gs)\n+{\n+  return gs->op[0];\n+}\n+\n static inline tree\n gimple_cond_lhs (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_COND);\n-  return gimple_op (gs, 0);\n+  const gcond *gc = GIMPLE_CHECK2<const gcond *> (gs);\n+  return gimple_cond_lhs (gc);\n }\n \n /* Return the pointer to the LHS of the predicate computed by conditional\n@@ -3249,11 +3396,17 @@ gimple_cond_set_lhs (gcond *gs, tree lhs)\n \n /* Return the RHS operand of the predicate computed by conditional GS.  */\n \n+static inline tree\n+gimple_cond_rhs (const gcond *gs)\n+{\n+  return gs->op[1];\n+}\n+\n static inline tree\n gimple_cond_rhs (const_gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_COND);\n-  return gimple_op (gs, 1);\n+  const gcond *gc = GIMPLE_CHECK2<const gcond *> (gs);\n+  return gimple_cond_rhs (gc);\n }\n \n /* Return the pointer to the RHS operand of the predicate computed by"}]}