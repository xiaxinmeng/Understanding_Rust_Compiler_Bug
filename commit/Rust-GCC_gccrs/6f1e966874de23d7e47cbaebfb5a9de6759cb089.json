{"sha": "6f1e966874de23d7e47cbaebfb5a9de6759cb089", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYxZTk2Njg3NGRlMjNkN2U0N2NiYWViZmI1YTlkZTY3NTljYjA4OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-12-04T09:18:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-12-04T09:18:13Z"}, "message": "[C++] Opt out of GNU vector extensions for built-in SVE types\n\nThis is the C++ equivalent of r277950.  The changes are very similar\nto there.  Perhaps the only noteworthy thing (that I know of) is that\nthe patch continues to treat !gnu_vector_type_p vector types as literal\ntypes/potential constexprs.  Disabling the GNU vector extensions\nshouldn't in itself stop the types from being literal types, since\nwhatever the target provides instead might be constexpr material.\n\n2019-12-04  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/cp/\n\t* cp-tree.h (CP_AGGREGATE_TYPE_P): Check for gnu_vector_type_p\n\tinstead of VECTOR_TYPE.\n\t* call.c (build_conditional_expr_1): Restrict vector handling\n\tto vectors that satisfy gnu_vector_type_p.\n\t* cvt.c (ocp_convert): Only allow vectors to be converted\n\tto bool if they satisfy gnu_vector_type_p.\n\t(build_expr_type_conversion): Only allow conversions from\n\tvectors if they satisfy gnu_vector_type_p.\n\t* typeck.c (cp_build_binary_op): Only allow binary operators to be\n\tapplied to vectors if they satisfy gnu_vector_type_p.\n\t(cp_build_unary_op): Likewise unary operators.\n\t(build_reinterpret_cast_1):\n\ngcc/testsuite/\n\t* g++.target/aarch64/sve/acle/general-c++/gnu_vectors_1.C: New test.\n\t* g++.target/aarch64/sve/acle/general-c++/gnu_vectors_2.C: New test.\n\nFrom-SVN: r278957", "tree": {"sha": "beca6737116bc2ac5c28e4a0d8e95cbb7b85e652", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/beca6737116bc2ac5c28e4a0d8e95cbb7b85e652"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f1e966874de23d7e47cbaebfb5a9de6759cb089", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1e966874de23d7e47cbaebfb5a9de6759cb089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f1e966874de23d7e47cbaebfb5a9de6759cb089", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1e966874de23d7e47cbaebfb5a9de6759cb089/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a8a5f4cc04c802d74176f6935509b8a4303de399", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8a5f4cc04c802d74176f6935509b8a4303de399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8a5f4cc04c802d74176f6935509b8a4303de399"}], "stats": {"total": 1057, "additions": 1038, "deletions": 19}, "files": [{"sha": "fbf28741936cace4c0d6c342cba772358f82b2f2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6f1e966874de23d7e47cbaebfb5a9de6759cb089", "patch": "@@ -1,3 +1,18 @@\n+2019-12-04  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* cp-tree.h (CP_AGGREGATE_TYPE_P): Check for gnu_vector_type_p\n+\tinstead of VECTOR_TYPE.\n+\t* call.c (build_conditional_expr_1): Restrict vector handling\n+\tto vectors that satisfy gnu_vector_type_p.\n+\t* cvt.c (ocp_convert): Only allow vectors to be converted\n+\tto bool if they satisfy gnu_vector_type_p.\n+\t(build_expr_type_conversion): Only allow conversions from\n+\tvectors if they satisfy gnu_vector_type_p.\n+\t* typeck.c (cp_build_binary_op): Only allow binary operators to be\n+\tapplied to vectors if they satisfy gnu_vector_type_p.\n+\t(cp_build_unary_op): Likewise unary operators.\n+\t(build_reinterpret_cast_1):\n+\n 2019-12-03  Jakub Jelinek  <jakub@redhat.com>\n \n \t* cp-tree.h (enum cp_tree_index): Add CPTI_SOURCE_LOCATION_IMPL."}, {"sha": "5e9523e97b566d3be270ffa6a12d43bcd739fbf5", "filename": "gcc/cp/call.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6f1e966874de23d7e47cbaebfb5a9de6759cb089", "patch": "@@ -5093,7 +5093,8 @@ build_conditional_expr_1 (const op_location_t &loc,\n   orig_arg2 = arg2;\n   orig_arg3 = arg3;\n \n-  if (VECTOR_INTEGER_TYPE_P (TREE_TYPE (arg1)))\n+  if (gnu_vector_type_p (TREE_TYPE (arg1))\n+      && VECTOR_INTEGER_TYPE_P (TREE_TYPE (arg1)))\n     {\n       tree arg1_type = TREE_TYPE (arg1);\n \n@@ -5172,7 +5173,8 @@ build_conditional_expr_1 (const op_location_t &loc,\n \t  arg3_type = vtype;\n \t}\n \n-      if (VECTOR_TYPE_P (arg2_type) != VECTOR_TYPE_P (arg3_type))\n+      if ((gnu_vector_type_p (arg2_type) && !VECTOR_TYPE_P (arg3_type))\n+\t  || (gnu_vector_type_p (arg3_type) && !VECTOR_TYPE_P (arg2_type)))\n \t{\n \t  enum stv_conv convert_flag =\n \t    scalar_to_vector (loc, VEC_COND_EXPR, arg2, arg3,\n@@ -5203,7 +5205,9 @@ build_conditional_expr_1 (const op_location_t &loc,\n \t    }\n \t}\n \n-      if (!same_type_p (arg2_type, arg3_type)\n+      if (!gnu_vector_type_p (arg2_type)\n+\t  || !gnu_vector_type_p (arg3_type)\n+\t  || !same_type_p (arg2_type, arg3_type)\n \t  || maybe_ne (TYPE_VECTOR_SUBPARTS (arg1_type),\n \t\t       TYPE_VECTOR_SUBPARTS (arg2_type))\n \t  || TYPE_SIZE (arg1_type) != TYPE_SIZE (arg2_type))"}, {"sha": "89828d904d5a13882fbf2afba0fdb1a60d296a93", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6f1e966874de23d7e47cbaebfb5a9de6759cb089", "patch": "@@ -4254,7 +4254,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    As an extension, we also treat vectors as aggregates.  Keep these\n    checks in ascending code order.  */\n #define CP_AGGREGATE_TYPE_P(TYPE)\t\t\t\t\\\n-  (TREE_CODE (TYPE) == VECTOR_TYPE\t\t\t\t\\\n+  (gnu_vector_type_p (TYPE)\t\t\t\t\t\\\n    || TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\\\n    || (CLASS_TYPE_P (TYPE) && COMPLETE_TYPE_P (TYPE) && !CLASSTYPE_NON_AGGREGATE (TYPE)))\n "}, {"sha": "cde3760886ae1a6585812c34bb0b4b599664be02", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=6f1e966874de23d7e47cbaebfb5a9de6759cb089", "patch": "@@ -836,6 +836,14 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \t      return error_mark_node;\n \t    }\n \n+\t  if (VECTOR_TYPE_P (intype) && !gnu_vector_type_p (intype))\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror_at (loc, \"could not convert %qE from %qH to %qI\", expr,\n+\t\t\t  TREE_TYPE (expr), type);\n+\t      return error_mark_node;\n+\t    }\n+\n \t  /* We can't implicitly convert a scoped enum to bool, so convert\n \t     to the underlying type first.  */\n \t  if (SCOPED_ENUM_P (intype) && (convtype & CONV_STATIC))\n@@ -1763,8 +1771,11 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n \t\t\t\t\t\t\t    tf_warning_or_error)\n \t\t\t\t\t: NULL_TREE;\n \n-      case COMPLEX_TYPE:\n       case VECTOR_TYPE:\n+\tif (!gnu_vector_type_p (basetype))\n+\t  return NULL_TREE;\n+\t/* FALLTHROUGH */\n+      case COMPLEX_TYPE:\n \tif ((desires & WANT_VECTOR_OR_COMPLEX) == 0)\n \t  return NULL_TREE;\n \tswitch (TREE_CODE (TREE_TYPE (basetype)))"}, {"sha": "5976b6c7bbcc29e828f58bea82907a0b5a668a94", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6f1e966874de23d7e47cbaebfb5a9de6759cb089", "patch": "@@ -4547,7 +4547,8 @@ cp_build_binary_op (const op_location_t &location,\n \n   /* In case when one of the operands of the binary operation is\n      a vector and another is a scalar -- convert scalar to vector.  */\n-  if ((code0 == VECTOR_TYPE) != (code1 == VECTOR_TYPE))\n+  if ((gnu_vector_type_p (type0) && code1 != VECTOR_TYPE)\n+      || (gnu_vector_type_p (type1) && code0 != VECTOR_TYPE))\n     {\n       enum stv_conv convert_flag = scalar_to_vector (location, code, op0, op1,\n \t\t\t\t\t\t     complain & tf_error);\n@@ -4740,7 +4741,7 @@ cp_build_binary_op (const op_location_t &location,\n     case TRUTH_ORIF_EXPR:\n     case TRUTH_AND_EXPR:\n     case TRUTH_OR_EXPR:\n-      if (!VECTOR_TYPE_P (type0) && VECTOR_TYPE_P (type1))\n+      if (!VECTOR_TYPE_P (type0) && gnu_vector_type_p (type1))\n \t{\n \t  if (!COMPARISON_CLASS_P (op1))\n \t    op1 = cp_build_binary_op (EXPR_LOCATION (op1), NE_EXPR, op1,\n@@ -4758,7 +4759,8 @@ cp_build_binary_op (const op_location_t &location,\n \t  else\n \t    gcc_unreachable ();\n \t}\n-      if (VECTOR_TYPE_P (type0))\n+      if (gnu_vector_type_p (type0)\n+\t  && (!VECTOR_TYPE_P (type1) || gnu_vector_type_p (type1)))\n \t{\n \t  if (!COMPARISON_CLASS_P (op0))\n \t    op0 = cp_build_binary_op (EXPR_LOCATION (op0), NE_EXPR, op0,\n@@ -4791,13 +4793,15 @@ cp_build_binary_op (const op_location_t &location,\n \t Also set SHORT_SHIFT if shifting rightward.  */\n \n     case RSHIFT_EXPR:\n-      if (code0 == VECTOR_TYPE && code1 == INTEGER_TYPE\n-          && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE)\n+      if (gnu_vector_type_p (type0)\n+\t  && code1 == INTEGER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE)\n         {\n           result_type = type0;\n           converted = 1;\n         }\n-      else if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE\n+      else if (gnu_vector_type_p (type0)\n+\t       && gnu_vector_type_p (type1)\n \t       && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE\n \t       && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE\n \t       && known_eq (TYPE_VECTOR_SUBPARTS (type0),\n@@ -4837,13 +4841,15 @@ cp_build_binary_op (const op_location_t &location,\n       break;\n \n     case LSHIFT_EXPR:\n-      if (code0 == VECTOR_TYPE && code1 == INTEGER_TYPE\n+      if (gnu_vector_type_p (type0)\n+\t  && code1 == INTEGER_TYPE\n           && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE)\n         {\n           result_type = type0;\n           converted = 1;\n         }\n-      else if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE\n+      else if (gnu_vector_type_p (type0)\n+\t       && gnu_vector_type_p (type1)\n \t       && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE\n \t       && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE\n \t       && known_eq (TYPE_VECTOR_SUBPARTS (type0),\n@@ -4896,7 +4902,7 @@ cp_build_binary_op (const op_location_t &location,\n \n     case EQ_EXPR:\n     case NE_EXPR:\n-      if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE)\n+      if (gnu_vector_type_p (type0) && gnu_vector_type_p (type1))\n \tgoto vector_compare;\n       if ((complain & tf_warning)\n \t  && c_inhibit_evaluation_warnings == 0\n@@ -5186,7 +5192,7 @@ cp_build_binary_op (const op_location_t &location,\n \t\t\t\"in unspecified behavior\");\n \t}\n \n-      if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE)\n+      if (gnu_vector_type_p (type0) && gnu_vector_type_p (type1))\n \t{\n \tvector_compare:\n \t  tree intt;\n@@ -5341,7 +5347,7 @@ cp_build_binary_op (const op_location_t &location,\n     {\n       arithmetic_types_p = 0;\n       /* Vector arithmetic is only allowed when both sides are vectors.  */\n-      if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE)\n+      if (gnu_vector_type_p (type0) && gnu_vector_type_p (type1))\n \t{\n \t  if (!tree_int_cst_equal (TYPE_SIZE (type0), TYPE_SIZE (type1))\n \t      || !vector_types_compatible_elements_p (type0, type1))\n@@ -6435,7 +6441,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,\n       break;\n \n     case TRUTH_NOT_EXPR:\n-      if (VECTOR_TYPE_P (TREE_TYPE (arg)))\n+      if (gnu_vector_type_p (TREE_TYPE (arg)))\n \treturn cp_build_binary_op (input_location, EQ_EXPR, arg,\n \t\t\t\t   build_zero_cst (TREE_TYPE (arg)), complain);\n       arg = perform_implicit_conversion (boolean_type_node, arg,\n@@ -7811,9 +7817,9 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n \t\t \"is conditionally-supported\");\n       return build_nop_reinterpret (type, expr);\n     }\n-  else if (VECTOR_TYPE_P (type))\n+  else if (gnu_vector_type_p (type))\n     return convert_to_vector (type, expr);\n-  else if (VECTOR_TYPE_P (intype)\n+  else if (gnu_vector_type_p (intype)\n \t   && INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n     return convert_to_integer_nofold (type, expr);\n   else"}, {"sha": "3dbf60162f5e08587b1cdc7c804855340ef1ef02", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6f1e966874de23d7e47cbaebfb5a9de6759cb089", "patch": "@@ -1,3 +1,8 @@\n+2019-12-04  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* g++.target/aarch64/sve/acle/general-c++/gnu_vectors_1.C: New test.\n+\t* g++.target/aarch64/sve/acle/general-c++/gnu_vectors_2.C: New test.\n+\n 2019-12-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/92756"}, {"sha": "d1da64c901b00792b39044ec58f337235f036deb", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/gnu_vectors_1.C", "status": "added", "additions": 489, "deletions": 0, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fgnu_vectors_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fgnu_vectors_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fgnu_vectors_1.C?ref=6f1e966874de23d7e47cbaebfb5a9de6759cb089", "patch": "@@ -0,0 +1,489 @@\n+// { dg-options \"-msve-vector-bits=256 -std=gnu++2a\" }\n+\n+#include <arm_sve.h>\n+\n+typedef uint8_t gnu_uint8_t __attribute__ ((vector_size (32)));\n+typedef int8_t gnu_int8_t __attribute__ ((vector_size (32)));\n+\n+void\n+f (svuint8_t sve_u1, svint8_t sve_s1,\n+   gnu_uint8_t gnu_u1, gnu_int8_t gnu_s1, int n, unsigned char uc)\n+{\n+  // Initialization\n+\n+  svuint8_t init_sve_u1 = 0; // { dg-error {cannot convert 'int' to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u2 = {};\n+  svuint8_t init_sve_u3 = { sve_u1 };\n+  svuint8_t init_sve_u4 = { gnu_u1 };\n+  svuint8_t init_sve_u5 = { sve_s1 }; // { dg-error {cannot convert 'svint8_t' to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u6 = { gnu_s1 }; // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u7 = { 0 }; // { dg-error {cannot convert 'int' to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u8 = { sve_u1, sve_u1 }; // { dg-error {too many initializers for 'svuint8_t'} }\n+  svuint8_t init_sve_u9 = { gnu_u1, gnu_u1 }; // { dg-error {too many initializers for 'svuint8_t'} }\n+  svuint8_t init_sve_u10 {};\n+  svuint8_t init_sve_u11 { sve_u1 };\n+  svuint8_t init_sve_u12 { gnu_u1 };\n+  svuint8_t init_sve_u13 { sve_s1 }; // { dg-error {cannot convert 'svint8_t' to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u14 { gnu_s1 }; // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u15 { 0 }; // { dg-error {cannot convert 'int' to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u16 { sve_u1, sve_u1 }; // { dg-error {too many initializers for 'svuint8_t'} }\n+  svuint8_t init_sve_u17 { gnu_u1, gnu_u1 }; // { dg-error {too many initializers for 'svuint8_t'} }\n+  svuint8_t init_sve_u18 (0); // { dg-error {cannot convert 'int' to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u19 (sve_u1);\n+  svuint8_t init_sve_u20 (gnu_u1);\n+  svuint8_t init_sve_u21 (sve_s1); // { dg-error {cannot convert 'svint8_t' to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u22 (gnu_s1); // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'svuint8_t' in initialization} }\n+\n+  gnu_uint8_t init_gnu_u1 = 0; // { dg-error {cannot convert 'int' to 'gnu_uint8_t'[^\\n]* in initialization} }\n+  gnu_uint8_t init_gnu_u2 = {};\n+  gnu_uint8_t init_gnu_u3 = { sve_u1 };\n+  gnu_uint8_t init_gnu_u4 = { gnu_u1 };\n+  gnu_uint8_t init_gnu_u5 = { sve_s1 }; // { dg-error {cannot convert 'svint8_t' to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u6 = { gnu_s1 }; // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u7 = { 0 };\n+  gnu_uint8_t init_gnu_u8 = { sve_u1, sve_u1 }; // { dg-error {cannot convert 'svuint8_t' to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u9 = { gnu_u1, gnu_u1 }; // { dg-error {cannot convert 'gnu_uint8_t'[^\\n]* to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u10 { sve_u1 };\n+  gnu_uint8_t init_gnu_u11 { gnu_u1 };\n+  gnu_uint8_t init_gnu_u12 { sve_s1 }; // { dg-error {cannot convert 'svint8_t' to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u13 { gnu_s1 }; // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u14 { 0 };\n+  gnu_uint8_t init_gnu_u15 { sve_u1, sve_u1 }; // { dg-error {cannot convert 'svuint8_t' to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u16 { gnu_u1, gnu_u1 }; // { dg-error {cannot convert 'gnu_uint8_t'[^\\n]* to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u17 (0); // { dg-error {cannot convert 'int' to 'gnu_uint8_t'[^\\n]* in initialization} }\n+  gnu_uint8_t init_gnu_u18 (sve_u1);\n+  gnu_uint8_t init_gnu_u19 (gnu_u1);\n+  gnu_uint8_t init_gnu_u20 (sve_s1); // { dg-error {cannot convert 'svint8_t' to 'gnu_uint8_t'[^\\n]* in initialization} }\n+  gnu_uint8_t init_gnu_u21 (gnu_s1); // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'gnu_uint8_t'[^\\n]* in initialization} }\n+\n+  // Compound literals\n+\n+  (svuint8_t) {};\n+  (svuint8_t) { 0 }; // { dg-error {cannot convert 'int' to 'svuint8_t' in initialization} }\n+  (svuint8_t) { sve_u1 };\n+  (svuint8_t) { gnu_u1 };\n+  (svuint8_t) { sve_s1 }; // { dg-error {cannot convert 'svint8_t' to 'svuint8_t' in initialization} }\n+  (svuint8_t) { gnu_s1 }; // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'svuint8_t' in initialization} }\n+  (svuint8_t) { sve_u1, sve_u1 }; // { dg-error {too many initializers for 'svuint8_t'} }\n+  (svuint8_t) { gnu_u1, gnu_u1 }; // { dg-error {too many initializers for 'svuint8_t'} }\n+\n+  (gnu_uint8_t) {};\n+  (gnu_uint8_t) { 0 };\n+  (gnu_uint8_t) { sve_u1 };\n+  (gnu_uint8_t) { gnu_u1 };\n+  (gnu_uint8_t) { sve_s1 }; // { dg-error {cannot convert 'svint8_t' to 'unsigned char' in initialization} }\n+  (gnu_uint8_t) { gnu_s1 }; // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'unsigned char' in initialization} }\n+  (gnu_uint8_t) { sve_u1, sve_u1 }; // { dg-error {cannot convert 'svuint8_t' to 'unsigned char' in initialization} }\n+  (gnu_uint8_t) { gnu_u1, gnu_u1 }; // { dg-error {cannot convert 'gnu_uint8_t'[^\\n]* to 'unsigned char' in initialization} }\n+\n+  // Assignment\n+\n+  sve_u1 = 0; // { dg-error {cannot convert 'int' to 'svuint8_t' in assignment} }\n+  sve_u1 = sve_u1;\n+  sve_u1 = gnu_u1;\n+  sve_u1 = sve_s1; // { dg-error {cannot convert 'svint8_t' to 'svuint8_t' in assignment} }\n+  sve_u1 = gnu_s1; // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'svuint8_t' in assignment} }\n+\n+  gnu_u1 = 0; // { dg-error {cannot convert 'int' to 'gnu_uint8_t'[^\\n]* in assignment} }\n+  gnu_u1 = sve_u1;\n+  gnu_u1 = gnu_u1;\n+  gnu_u1 = sve_s1; // { dg-error {cannot convert 'svint8_t' to 'gnu_uint8_t'[^\\n]* in assignment} }\n+  gnu_u1 = gnu_s1; // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'gnu_uint8_t'[^\\n]* in assignment} }\n+\n+  // Casts\n+\n+  (void) sve_u1;\n+  (int) sve_u1; // { dg-error {invalid cast from type 'svuint8_t' to type 'int'} }\n+  (bool) sve_u1; // { dg-error {invalid cast from type 'svuint8_t' to type 'bool'} }\n+  (svuint8_t) 0; // { dg-error {invalid cast from type 'int' to type 'svuint8_t'} }\n+  (svuint8_t) n; // { dg-error {invalid cast from type 'int' to type 'svuint8_t'} }\n+  (svuint8_t) sve_u1;\n+  (svuint8_t) gnu_u1;\n+  (svuint8_t) sve_s1; // { dg-error {invalid cast from type 'svint8_t' to type 'svuint8_t'} }\n+  (svuint8_t) gnu_s1; // { dg-error {invalid cast from type 'gnu_int8_t'[^\\n]* to type 'svuint8_t'} }\n+\n+  (void) gnu_u1;\n+  (int) gnu_u1; // { dg-error {cannot convert a vector of type 'gnu_uint8_t'[^\\n]* to type 'int'} }\n+  (bool) gnu_u1; // { dg-error {cannot convert a vector of type 'gnu_uint8_t'[^\\n]* to type 'bool'} }\n+  (gnu_uint8_t) 0; // { dg-error {cannot convert a value of type 'int' to vector type 'gnu_uint8_t'} }\n+  (gnu_uint8_t) n; // { dg-error {cannot convert a value of type 'int' to vector type 'gnu_uint8_t'} }\n+  (gnu_uint8_t) sve_u1;\n+  (gnu_uint8_t) gnu_u1;\n+  (gnu_uint8_t) sve_s1;\n+  (gnu_uint8_t) gnu_s1;\n+\n+  // Vector indexing.\n+\n+  sve_u1[0]; // { dg-error {subscripted value is neither array nor pointer} }\n+  &sve_u1[0]; // { dg-error {subscripted value is neither array nor pointer} }\n+\n+  gnu_u1[0];\n+  &gnu_u1[0];\n+\n+  // Unary vector arithmetic.\n+\n+  +sve_u1; // { dg-error {wrong type argument to unary plus} }\n+  -sve_u1; // { dg-error {wrong type argument to unary minus} }\n+  ~sve_u1; // { dg-error {wrong type argument to bit-complement} }\n+  !sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+        // { dg-error {in argument to unary !} \"\" { target *-*-* } .-1 }\n+  *sve_u1; // { dg-error {invalid type argument of unary '\\*'} }\n+  __real sve_u1; // { dg-error {wrong type argument to __real} }\n+  __imag sve_u1; // { dg-error {wrong type argument to __imag} }\n+  ++sve_u1; // { dg-error {no pre-increment operator for type} }\n+  --sve_u1; // { dg-error {no pre-decrement operator for type} }\n+  sve_u1++; // { dg-error {no post-increment operator for type} }\n+  sve_u1--; // { dg-error {no post-decrement operator for type} }\n+\n+  +gnu_u1;\n+  -gnu_u1;\n+  ~gnu_u1;\n+  !gnu_u1;\n+  *gnu_u1; // { dg-error {invalid type argument of unary '\\*'} }\n+  __real gnu_u1; // { dg-error {wrong type argument to __real} }\n+  __imag gnu_u1; // { dg-error {wrong type argument to __imag} }\n+  ++gnu_u1;\n+  --gnu_u1;\n+  gnu_u1++;\n+  gnu_u1--;\n+\n+  // Vector-vector binary arithmetic.\n+\n+  sve_u1 + sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator\\+'} }\n+  sve_u1 - sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator-'} }\n+  sve_u1 * sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator\\*'} }\n+  sve_u1 / sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator/'} }\n+  sve_u1 % sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator%'} }\n+  sve_u1 & sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator\\&'} }\n+  sve_u1 | sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator\\|'} }\n+  sve_u1 ^ sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator\\^'} }\n+  sve_u1 == sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator=='} }\n+  sve_u1 != sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator!='} }\n+  sve_u1 <= sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator<='} }\n+  sve_u1 < sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator<'} }\n+  sve_u1 > sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator>'} }\n+  sve_u1 >= sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator>='} }\n+  sve_u1 <=> sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator<=>'} }\n+  sve_u1 << sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator<<'} }\n+  sve_u1 >> sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator>>'} }\n+  sve_u1 && sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 || sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  sve_u1 + gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator\\+'} }\n+  sve_u1 - gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator-'} }\n+  sve_u1 * gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator\\*'} }\n+  sve_u1 / gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator/'} }\n+  sve_u1 % gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator%'} }\n+  sve_u1 & gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator\\&'} }\n+  sve_u1 | gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator\\|'} }\n+  sve_u1 ^ gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator\\^'} }\n+  sve_u1 == gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator=='} }\n+  sve_u1 != gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator!='} }\n+  sve_u1 <= gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator<='} }\n+  sve_u1 < gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator<'} }\n+  sve_u1 > gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator>'} }\n+  sve_u1 >= gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator>='} }\n+  sve_u1 <=> gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator<=>'} }\n+  sve_u1 << gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator<<'} }\n+  sve_u1 >> gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator>>'} }\n+  sve_u1 && gnu_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 || gnu_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  gnu_u1 + sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator\\+'} }\n+  gnu_u1 - sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator-'} }\n+  gnu_u1 * sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator\\*'} }\n+  gnu_u1 / sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator/'} }\n+  gnu_u1 % sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator%'} }\n+  gnu_u1 & sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator\\&'} }\n+  gnu_u1 | sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator\\|'} }\n+  gnu_u1 ^ sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator\\^'} }\n+  gnu_u1 == sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator=='} }\n+  gnu_u1 != sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator!='} }\n+  gnu_u1 <= sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator<='} }\n+  gnu_u1 < sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator<'} }\n+  gnu_u1 > sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator>'} }\n+  gnu_u1 >= sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator>='} }\n+  gnu_u1 <=> sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator<=>'} }\n+  gnu_u1 << sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator<<'} }\n+  gnu_u1 >> sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator>>'} }\n+  gnu_u1 && sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  gnu_u1 || sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  gnu_u1 + gnu_u1;\n+  gnu_u1 - gnu_u1;\n+  gnu_u1 * gnu_u1;\n+  gnu_u1 / gnu_u1;\n+  gnu_u1 % gnu_u1;\n+  gnu_u1 & gnu_u1;\n+  gnu_u1 | gnu_u1;\n+  gnu_u1 ^ gnu_u1;\n+  gnu_u1 == gnu_u1;\n+  gnu_u1 != gnu_u1;\n+  gnu_u1 <= gnu_u1;\n+  gnu_u1 < gnu_u1;\n+  gnu_u1 > gnu_u1;\n+  gnu_u1 >= gnu_u1;\n+  // This is a target-independent sorry.  There's no ACLE reason why it\n+  // needs to be kept.\n+  gnu_u1 <=> gnu_u1; // { dg-message {three-way comparison of vectors} }\n+  gnu_u1 << gnu_u1;\n+  gnu_u1 >> gnu_u1;\n+  gnu_u1 && gnu_u1;\n+  gnu_u1 || gnu_u1;\n+\n+  // Vector-scalar binary arithmetic.\n+\n+  sve_u1 + 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator\\+'} }\n+  sve_u1 - 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator-'} }\n+  sve_u1 * 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator\\*'} }\n+  sve_u1 / 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator/'} }\n+  sve_u1 % 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator%'} }\n+  sve_u1 & 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator\\&'} }\n+  sve_u1 | 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator\\|'} }\n+  sve_u1 ^ 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator\\^'} }\n+  sve_u1 == 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator=='} }\n+  sve_u1 != 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator!='} }\n+  sve_u1 <= 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator<='} }\n+  sve_u1 < 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator<'} }\n+  sve_u1 > 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator>'} }\n+  sve_u1 >= 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator>='} }\n+  sve_u1 <=> 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator<=>'} }\n+  sve_u1 << 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator<<'} }\n+  sve_u1 >> 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator>>'} }\n+  sve_u1 && 2; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 || 2; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  sve_u1 + uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator\\+'} }\n+  sve_u1 - uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator-'} }\n+  sve_u1 * uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator\\*'} }\n+  sve_u1 / uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator/'} }\n+  sve_u1 % uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator%'} }\n+  sve_u1 & uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator\\&'} }\n+  sve_u1 | uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator\\|'} }\n+  sve_u1 ^ uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator\\^'} }\n+  sve_u1 == uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator=='} }\n+  sve_u1 != uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator!='} }\n+  sve_u1 <= uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator<='} }\n+  sve_u1 < uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator<'} }\n+  sve_u1 > uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator>'} }\n+  sve_u1 >= uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator>='} }\n+  sve_u1 <=> uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator<=>'} }\n+  sve_u1 << uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator<<'} }\n+  sve_u1 >> uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator>>'} }\n+  sve_u1 && uc; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 || uc; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  gnu_u1 + 2;\n+  gnu_u1 - 2;\n+  gnu_u1 * 2;\n+  gnu_u1 / 2;\n+  gnu_u1 % 2;\n+  gnu_u1 & 2;\n+  gnu_u1 | 2;\n+  gnu_u1 ^ 2;\n+  gnu_u1 == 2;\n+  gnu_u1 != 2;\n+  gnu_u1 <= 2;\n+  gnu_u1 < 2;\n+  gnu_u1 > 2;\n+  gnu_u1 >= 2;\n+  gnu_u1 <=> 2; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'int' to binary 'operator<=>'} }\n+  gnu_u1 << 2;\n+  gnu_u1 >> 2;\n+  gnu_u1 && 2;\n+  gnu_u1 || 2;\n+\n+  gnu_u1 + uc;\n+  gnu_u1 - uc;\n+  gnu_u1 * uc;\n+  gnu_u1 / uc;\n+  gnu_u1 % uc;\n+  gnu_u1 & uc;\n+  gnu_u1 | uc;\n+  gnu_u1 ^ uc;\n+  gnu_u1 == uc;\n+  gnu_u1 != uc;\n+  gnu_u1 <= uc;\n+  gnu_u1 < uc;\n+  gnu_u1 > uc;\n+  gnu_u1 >= uc;\n+  gnu_u1 <=> uc; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'unsigned char' to binary 'operator<=>'} }\n+  gnu_u1 << uc;\n+  gnu_u1 >> uc;\n+  gnu_u1 && uc;\n+  gnu_u1 || uc;\n+\n+  // Scalar-vector binary 'operatorarithmetic.\n+\n+  3 + sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator\\+'} }\n+  3 - sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator-'} }\n+  3 * sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator\\*'} }\n+  3 / sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator/'} }\n+  3 % sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator%'} }\n+  3 & sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator\\&'} }\n+  3 | sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator\\|'} }\n+  3 ^ sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator\\^'} }\n+  3 == sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator=='} }\n+  3 != sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator!='} }\n+  3 <= sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator<='} }\n+  3 <=> sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator<=>'} }\n+  3 < sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator<'} }\n+  3 > sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator>'} }\n+  3 >= sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator>='} }\n+  3 << sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator<<'} }\n+  3 >> sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator>>'} }\n+  3 && sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  3 || sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  3 + gnu_u1;\n+  3 - gnu_u1;\n+  3 * gnu_u1;\n+  3 / gnu_u1;\n+  3 % gnu_u1;\n+  3 & gnu_u1;\n+  3 | gnu_u1;\n+  3 ^ gnu_u1;\n+  3 == gnu_u1;\n+  3 != gnu_u1;\n+  3 <= gnu_u1;\n+  3 <=> gnu_u1; // { dg-error {invalid operands of types 'int' and 'gnu_uint8_t'[^\\n]* to binary 'operator<=>'} }\n+  3 < gnu_u1;\n+  3 > gnu_u1;\n+  3 >= gnu_u1;\n+  3 << gnu_u1;\n+  3 >> gnu_u1;\n+  3 && gnu_u1;\n+  3 || gnu_u1;\n+\n+  // Mismatched types.\n+\n+  sve_u1 + sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator\\+'} }\n+  sve_u1 - sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator-'} }\n+  sve_u1 * sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator\\*'} }\n+  sve_u1 / sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator/'} }\n+  sve_u1 % sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator%'} }\n+  sve_u1 & sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator\\&'} }\n+  sve_u1 | sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator\\|'} }\n+  sve_u1 ^ sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator\\^'} }\n+  sve_u1 == sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator=='} }\n+  sve_u1 != sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator!='} }\n+  sve_u1 <= sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator<='} }\n+  sve_u1 < sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator<'} }\n+  sve_u1 > sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator>'} }\n+  sve_u1 >= sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator>='} }\n+  sve_u1 <=> sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator<=>'} }\n+  sve_u1 << sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator<<'} }\n+  sve_u1 >> sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator>>'} }\n+\n+  sve_u1 + gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator\\+'} }\n+  sve_u1 - gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator-'} }\n+  sve_u1 * gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator\\*'} }\n+  sve_u1 / gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator/'} }\n+  sve_u1 % gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator%'} }\n+  sve_u1 & gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator\\&'} }\n+  sve_u1 | gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator\\|'} }\n+  sve_u1 ^ gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator\\^'} }\n+  sve_u1 == gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator=='} }\n+  sve_u1 != gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator!='} }\n+  sve_u1 <= gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator<='} }\n+  sve_u1 < gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator<'} }\n+  sve_u1 > gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator>'} }\n+  sve_u1 >= gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator>='} }\n+  sve_u1 <=> gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator<=>'} }\n+  sve_u1 << gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator<<'} }\n+  sve_u1 >> gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator>>'} }\n+\n+  gnu_u1 + sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator\\+'} }\n+  gnu_u1 - sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator-'} }\n+  gnu_u1 * sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator\\*'} }\n+  gnu_u1 / sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator/'} }\n+  gnu_u1 % sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator%'} }\n+  gnu_u1 & sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator\\&'} }\n+  gnu_u1 | sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator\\|'} }\n+  gnu_u1 ^ sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator\\^'} }\n+  gnu_u1 == sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator=='} }\n+  gnu_u1 != sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator!='} }\n+  gnu_u1 <= sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator<='} }\n+  gnu_u1 < sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator<'} }\n+  gnu_u1 > sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator>'} }\n+  gnu_u1 >= sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator>='} }\n+  gnu_u1 <=> sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator<=>'} }\n+  gnu_u1 << sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator<<'} }\n+  gnu_u1 >> sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator>>'} }\n+\n+  gnu_u1 + gnu_s1;\n+  gnu_u1 - gnu_s1;\n+  gnu_u1 * gnu_s1;\n+  gnu_u1 / gnu_s1;\n+  gnu_u1 % gnu_s1;\n+  gnu_u1 & gnu_s1;\n+  gnu_u1 | gnu_s1;\n+  gnu_u1 ^ gnu_s1;\n+  gnu_u1 == gnu_s1;\n+  gnu_u1 != gnu_s1;\n+  gnu_u1 <= gnu_s1;\n+  gnu_u1 < gnu_s1;\n+  gnu_u1 > gnu_s1;\n+  gnu_u1 >= gnu_s1;\n+  // This is a target-independent sorry.  There's no ACLE reason why it\n+  // needs to be kept.\n+  gnu_u1 <=> gnu_s1; // { dg-message {three-way comparison of vectors} }\n+  gnu_u1 << gnu_s1;\n+  gnu_u1 >> gnu_s1;\n+\n+  // Conditional expressions.\n+\n+  uc ? sve_u1 : sve_u1;\n+  uc ? gnu_u1 : sve_u1; // { dg-error {operands to '\\?:' have different types 'gnu_uint8_t'[^\\n]* and 'svuint8_t'} \"\" { xfail *-*-* } }\n+  uc ? sve_u1 : gnu_u1; // { dg-error {operands to '\\?:' have different types 'svuint8_t' and 'gnu_uint8_t'} \"\" { xfail *-*-* } }\n+  uc ? gnu_u1 : gnu_u1;\n+\n+  sve_u1 ? sve_u1 : sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? gnu_u1 : sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? sve_u1 : gnu_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? gnu_u1 : gnu_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? sve_u1 : uc; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? uc : sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? gnu_u1 : uc; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? uc : gnu_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  gnu_u1 ? sve_u1 : sve_u1; // { dg-error {incompatible vector types in conditional expression} }\n+  gnu_u1 ? gnu_u1 : sve_u1; // { dg-error {incompatible vector types in conditional expression} }\n+  gnu_u1 ? sve_u1 : gnu_u1; // { dg-error {incompatible vector types in conditional expression} }\n+  gnu_u1 ? gnu_u1 : gnu_u1;\n+  gnu_u1 ? sve_u1 : uc; // { dg-error {incompatible vector types in conditional expression} }\n+  gnu_u1 ? uc : sve_u1; // { dg-error {incompatible vector types in conditional expression} }\n+  gnu_u1 ? gnu_u1 : uc;\n+  gnu_u1 ? uc : gnu_u1;\n+\n+  // Vector built-ins.\n+\n+  __builtin_shuffle (sve_u1, sve_u1, sve_u1); // { dg-error {'__builtin_shuffle' last argument must be an integer vector} }\n+  __builtin_shuffle (sve_u1, gnu_u1, gnu_u1); // { dg-error {'__builtin_shuffle' arguments must be vectors} }\n+  __builtin_shuffle (gnu_u1, sve_u1, gnu_u1); // { dg-error {'__builtin_shuffle' arguments must be vectors} }\n+  __builtin_shuffle (gnu_u1, gnu_u1, sve_u1); // { dg-error {'__builtin_shuffle' last argument must be an integer vector} }\n+  __builtin_shuffle (gnu_u1, gnu_u1, gnu_u1);\n+\n+  __builtin_convertvector (sve_u1, svuint8_t); // { dg-error {'__builtin_convertvector' first argument must be an integer or floating vector} }\n+  __builtin_convertvector (gnu_u1, svuint8_t); // { dg-error {'__builtin_convertvector' second argument must be an integer or floating vector type} }\n+  __builtin_convertvector (sve_u1, gnu_uint8_t); // { dg-error {'__builtin_convertvector' first argument must be an integer or floating vector} }\n+  __builtin_convertvector (gnu_u1, gnu_uint8_t);\n+\n+  // Type queries.\n+\n+  static_assert(__is_literal_type(svuint8_t));\n+  static_assert(__is_literal_type(gnu_uint8_t));\n+\n+  svuint8_t *sve_ptr1 = &sve_u1;\n+  svuint8_t *sve_ptr2 = &gnu_u1;\n+  svuint8_t *sve_ptr3 = &sve_s1; // { dg-error {cannot convert 'svint8_t\\*' to 'svuint8_t\\*' in initialization} }\n+  svuint8_t *sve_ptr4 = &gnu_s1; // { dg-error {cannot convert 'gnu_int8_t\\*'[^\\n]* to 'svuint8_t\\*' in initialization} }\n+\n+  gnu_uint8_t *gnu_ptr1 = &sve_u1;\n+  gnu_uint8_t *gnu_ptr2 = &gnu_u1;\n+  gnu_uint8_t *gnu_ptr3 = &sve_s1; // { dg-error {cannot convert 'svint8_t\\*' to 'gnu_uint8_t\\*'} }\n+  gnu_uint8_t *gnu_ptr4 = &gnu_s1; // { dg-error {cannot convert 'gnu_int8_t\\*'[^\\n]* to 'gnu_uint8_t\\*'} }\n+}\n+\n+constexpr svuint8_t const1 (svuint8_t x) { return x; }\n+constexpr gnu_uint8_t const2 (gnu_uint8_t x) { return x; }"}, {"sha": "da4462b24217cae6e34eac610ef260e07f15a2de", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/gnu_vectors_2.C", "status": "added", "additions": 489, "deletions": 0, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fgnu_vectors_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1e966874de23d7e47cbaebfb5a9de6759cb089/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fgnu_vectors_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fgnu_vectors_2.C?ref=6f1e966874de23d7e47cbaebfb5a9de6759cb089", "patch": "@@ -0,0 +1,489 @@\n+// { dg-options \"-msve-vector-bits=256 -std=gnu++2a -flax-vector-conversions\" }\n+\n+#include <arm_sve.h>\n+\n+typedef uint8_t gnu_uint8_t __attribute__ ((vector_size (32)));\n+typedef int8_t gnu_int8_t __attribute__ ((vector_size (32)));\n+\n+void\n+f (svuint8_t sve_u1, svint8_t sve_s1,\n+   gnu_uint8_t gnu_u1, gnu_int8_t gnu_s1, int n, unsigned char uc)\n+{\n+  // Initialization\n+\n+  svuint8_t init_sve_u1 = 0; // { dg-error {cannot convert 'int' to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u2 = {};\n+  svuint8_t init_sve_u3 = { sve_u1 };\n+  svuint8_t init_sve_u4 = { gnu_u1 };\n+  svuint8_t init_sve_u5 = { sve_s1 };\n+  svuint8_t init_sve_u6 = { gnu_s1 };\n+  svuint8_t init_sve_u7 = { 0 }; // { dg-error {cannot convert 'int' to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u8 = { sve_u1, sve_u1 }; // { dg-error {too many initializers for 'svuint8_t'} }\n+  svuint8_t init_sve_u9 = { gnu_u1, gnu_u1 }; // { dg-error {too many initializers for 'svuint8_t'} }\n+  svuint8_t init_sve_u10 {};\n+  svuint8_t init_sve_u11 { sve_u1 };\n+  svuint8_t init_sve_u12 { gnu_u1 };\n+  svuint8_t init_sve_u13 { sve_s1 };\n+  svuint8_t init_sve_u14 { gnu_s1 };\n+  svuint8_t init_sve_u15 { 0 }; // { dg-error {cannot convert 'int' to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u16 { sve_u1, sve_u1 }; // { dg-error {too many initializers for 'svuint8_t'} }\n+  svuint8_t init_sve_u17 { gnu_u1, gnu_u1 }; // { dg-error {too many initializers for 'svuint8_t'} }\n+  svuint8_t init_sve_u18 (0); // { dg-error {cannot convert 'int' to 'svuint8_t' in initialization} }\n+  svuint8_t init_sve_u19 (sve_u1);\n+  svuint8_t init_sve_u20 (gnu_u1);\n+  svuint8_t init_sve_u21 (sve_s1);\n+  svuint8_t init_sve_u22 (gnu_s1);\n+\n+  gnu_uint8_t init_gnu_u1 = 0; // { dg-error {cannot convert 'int' to 'gnu_uint8_t'[^\\n]* in initialization} }\n+  gnu_uint8_t init_gnu_u2 = {};\n+  gnu_uint8_t init_gnu_u3 = { sve_u1 };\n+  gnu_uint8_t init_gnu_u4 = { gnu_u1 };\n+  gnu_uint8_t init_gnu_u5 = { sve_s1 }; // { dg-error {cannot convert 'svint8_t' to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u6 = { gnu_s1 }; // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u7 = { 0 };\n+  gnu_uint8_t init_gnu_u8 = { sve_u1, sve_u1 }; // { dg-error {cannot convert 'svuint8_t' to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u9 = { gnu_u1, gnu_u1 }; // { dg-error {cannot convert 'gnu_uint8_t'[^\\n]* to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u10 { sve_u1 };\n+  gnu_uint8_t init_gnu_u11 { gnu_u1 };\n+  gnu_uint8_t init_gnu_u12 { sve_s1 }; // { dg-error {cannot convert 'svint8_t' to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u13 { gnu_s1 }; // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u14 { 0 };\n+  gnu_uint8_t init_gnu_u15 { sve_u1, sve_u1 }; // { dg-error {cannot convert 'svuint8_t' to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u16 { gnu_u1, gnu_u1 }; // { dg-error {cannot convert 'gnu_uint8_t'[^\\n]* to 'unsigned char' in initialization} }\n+  gnu_uint8_t init_gnu_u17 (0); // { dg-error {cannot convert 'int' to 'gnu_uint8_t'[^\\n]* in initialization} }\n+  gnu_uint8_t init_gnu_u18 (sve_u1);\n+  gnu_uint8_t init_gnu_u19 (gnu_u1);\n+  gnu_uint8_t init_gnu_u20 (sve_s1);\n+  gnu_uint8_t init_gnu_u21 (gnu_s1);\n+\n+  // Compound literals\n+\n+  (svuint8_t) {};\n+  (svuint8_t) { 0 }; // { dg-error {cannot convert 'int' to 'svuint8_t' in initialization} }\n+  (svuint8_t) { sve_u1 };\n+  (svuint8_t) { gnu_u1 };\n+  (svuint8_t) { sve_s1 };\n+  (svuint8_t) { gnu_s1 };\n+  (svuint8_t) { sve_u1, sve_u1 }; // { dg-error {too many initializers for 'svuint8_t'} }\n+  (svuint8_t) { gnu_u1, gnu_u1 }; // { dg-error {too many initializers for 'svuint8_t'} }\n+\n+  (gnu_uint8_t) {};\n+  (gnu_uint8_t) { 0 };\n+  (gnu_uint8_t) { sve_u1 };\n+  (gnu_uint8_t) { gnu_u1 };\n+  (gnu_uint8_t) { sve_s1 }; // { dg-error {cannot convert 'svint8_t' to 'unsigned char' in initialization} }\n+  (gnu_uint8_t) { gnu_s1 }; // { dg-error {cannot convert 'gnu_int8_t'[^\\n]* to 'unsigned char' in initialization} }\n+  (gnu_uint8_t) { sve_u1, sve_u1 }; // { dg-error {cannot convert 'svuint8_t' to 'unsigned char' in initialization} }\n+  (gnu_uint8_t) { gnu_u1, gnu_u1 }; // { dg-error {cannot convert 'gnu_uint8_t'[^\\n]* to 'unsigned char' in initialization} }\n+\n+  // Assignment\n+\n+  sve_u1 = 0; // { dg-error {cannot convert 'int' to 'svuint8_t' in assignment} }\n+  sve_u1 = sve_u1;\n+  sve_u1 = gnu_u1;\n+  sve_u1 = sve_s1;\n+  sve_u1 = gnu_s1;\n+\n+  gnu_u1 = 0; // { dg-error {cannot convert 'int' to 'gnu_uint8_t'[^\\n]* in assignment} }\n+  gnu_u1 = sve_u1;\n+  gnu_u1 = gnu_u1;\n+  gnu_u1 = sve_s1;\n+  gnu_u1 = gnu_s1;\n+\n+  // Casts\n+\n+  (void) sve_u1;\n+  (int) sve_u1; // { dg-error {invalid cast from type 'svuint8_t' to type 'int'} }\n+  (bool) sve_u1; // { dg-error {invalid cast from type 'svuint8_t' to type 'bool'} }\n+  (svuint8_t) 0; // { dg-error {invalid cast from type 'int' to type 'svuint8_t'} }\n+  (svuint8_t) n; // { dg-error {invalid cast from type 'int' to type 'svuint8_t'} }\n+  (svuint8_t) sve_u1;\n+  (svuint8_t) gnu_u1;\n+  (svuint8_t) sve_s1;\n+  (svuint8_t) gnu_s1;\n+\n+  (void) gnu_u1;\n+  (int) gnu_u1; // { dg-error {cannot convert a vector of type 'gnu_uint8_t'[^\\n]* to type 'int'} }\n+  (bool) gnu_u1; // { dg-error {cannot convert a vector of type 'gnu_uint8_t'[^\\n]* to type 'bool'} }\n+  (gnu_uint8_t) 0; // { dg-error {cannot convert a value of type 'int' to vector type 'gnu_uint8_t'} }\n+  (gnu_uint8_t) n; // { dg-error {cannot convert a value of type 'int' to vector type 'gnu_uint8_t'} }\n+  (gnu_uint8_t) sve_u1;\n+  (gnu_uint8_t) gnu_u1;\n+  (gnu_uint8_t) sve_s1;\n+  (gnu_uint8_t) gnu_s1;\n+\n+  // Vector indexing.\n+\n+  sve_u1[0]; // { dg-error {subscripted value is neither array nor pointer} }\n+  &sve_u1[0]; // { dg-error {subscripted value is neither array nor pointer} }\n+\n+  gnu_u1[0];\n+  &gnu_u1[0];\n+\n+  // Unary vector arithmetic.\n+\n+  +sve_u1; // { dg-error {wrong type argument to unary plus} }\n+  -sve_u1; // { dg-error {wrong type argument to unary minus} }\n+  ~sve_u1; // { dg-error {wrong type argument to bit-complement} }\n+  !sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+        // { dg-error {in argument to unary !} \"\" { target *-*-* } .-1 }\n+  *sve_u1; // { dg-error {invalid type argument of unary '\\*'} }\n+  __real sve_u1; // { dg-error {wrong type argument to __real} }\n+  __imag sve_u1; // { dg-error {wrong type argument to __imag} }\n+  ++sve_u1; // { dg-error {no pre-increment operator for type} }\n+  --sve_u1; // { dg-error {no pre-decrement operator for type} }\n+  sve_u1++; // { dg-error {no post-increment operator for type} }\n+  sve_u1--; // { dg-error {no post-decrement operator for type} }\n+\n+  +gnu_u1;\n+  -gnu_u1;\n+  ~gnu_u1;\n+  !gnu_u1;\n+  *gnu_u1; // { dg-error {invalid type argument of unary '\\*'} }\n+  __real gnu_u1; // { dg-error {wrong type argument to __real} }\n+  __imag gnu_u1; // { dg-error {wrong type argument to __imag} }\n+  ++gnu_u1;\n+  --gnu_u1;\n+  gnu_u1++;\n+  gnu_u1--;\n+\n+  // Vector-vector binary arithmetic.\n+\n+  sve_u1 + sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator\\+'} }\n+  sve_u1 - sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator-'} }\n+  sve_u1 * sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator\\*'} }\n+  sve_u1 / sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator/'} }\n+  sve_u1 % sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator%'} }\n+  sve_u1 & sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator\\&'} }\n+  sve_u1 | sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator\\|'} }\n+  sve_u1 ^ sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator\\^'} }\n+  sve_u1 == sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator=='} }\n+  sve_u1 != sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator!='} }\n+  sve_u1 <= sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator<='} }\n+  sve_u1 < sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator<'} }\n+  sve_u1 > sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator>'} }\n+  sve_u1 >= sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator>='} }\n+  sve_u1 <=> sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator<=>'} }\n+  sve_u1 << sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator<<'} }\n+  sve_u1 >> sve_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'svuint8_t' to binary 'operator>>'} }\n+  sve_u1 && sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 || sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  sve_u1 + gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator\\+'} }\n+  sve_u1 - gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator-'} }\n+  sve_u1 * gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator\\*'} }\n+  sve_u1 / gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator/'} }\n+  sve_u1 % gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator%'} }\n+  sve_u1 & gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator\\&'} }\n+  sve_u1 | gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator\\|'} }\n+  sve_u1 ^ gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator\\^'} }\n+  sve_u1 == gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator=='} }\n+  sve_u1 != gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator!='} }\n+  sve_u1 <= gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator<='} }\n+  sve_u1 < gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator<'} }\n+  sve_u1 > gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator>'} }\n+  sve_u1 >= gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator>='} }\n+  sve_u1 <=> gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator<=>'} }\n+  sve_u1 << gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator<<'} }\n+  sve_u1 >> gnu_u1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_uint8_t'[^\\n]* to binary 'operator>>'} }\n+  sve_u1 && gnu_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 || gnu_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  gnu_u1 + sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator\\+'} }\n+  gnu_u1 - sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator-'} }\n+  gnu_u1 * sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator\\*'} }\n+  gnu_u1 / sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator/'} }\n+  gnu_u1 % sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator%'} }\n+  gnu_u1 & sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator\\&'} }\n+  gnu_u1 | sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator\\|'} }\n+  gnu_u1 ^ sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator\\^'} }\n+  gnu_u1 == sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator=='} }\n+  gnu_u1 != sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator!='} }\n+  gnu_u1 <= sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator<='} }\n+  gnu_u1 < sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator<'} }\n+  gnu_u1 > sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator>'} }\n+  gnu_u1 >= sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator>='} }\n+  gnu_u1 <=> sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator<=>'} }\n+  gnu_u1 << sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator<<'} }\n+  gnu_u1 >> sve_u1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svuint8_t' to binary 'operator>>'} }\n+  gnu_u1 && sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  gnu_u1 || sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  gnu_u1 + gnu_u1;\n+  gnu_u1 - gnu_u1;\n+  gnu_u1 * gnu_u1;\n+  gnu_u1 / gnu_u1;\n+  gnu_u1 % gnu_u1;\n+  gnu_u1 & gnu_u1;\n+  gnu_u1 | gnu_u1;\n+  gnu_u1 ^ gnu_u1;\n+  gnu_u1 == gnu_u1;\n+  gnu_u1 != gnu_u1;\n+  gnu_u1 <= gnu_u1;\n+  gnu_u1 < gnu_u1;\n+  gnu_u1 > gnu_u1;\n+  gnu_u1 >= gnu_u1;\n+  // This is a target-independent sorry.  There's no ACLE reason why it\n+  // needs to be kept.\n+  gnu_u1 <=> gnu_u1; // { dg-message {three-way comparison of vectors} }\n+  gnu_u1 << gnu_u1;\n+  gnu_u1 >> gnu_u1;\n+  gnu_u1 && gnu_u1;\n+  gnu_u1 || gnu_u1;\n+\n+  // Vector-scalar binary arithmetic.\n+\n+  sve_u1 + 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator\\+'} }\n+  sve_u1 - 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator-'} }\n+  sve_u1 * 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator\\*'} }\n+  sve_u1 / 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator/'} }\n+  sve_u1 % 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator%'} }\n+  sve_u1 & 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator\\&'} }\n+  sve_u1 | 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator\\|'} }\n+  sve_u1 ^ 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator\\^'} }\n+  sve_u1 == 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator=='} }\n+  sve_u1 != 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator!='} }\n+  sve_u1 <= 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator<='} }\n+  sve_u1 < 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator<'} }\n+  sve_u1 > 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator>'} }\n+  sve_u1 >= 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator>='} }\n+  sve_u1 <=> 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator<=>'} }\n+  sve_u1 << 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator<<'} }\n+  sve_u1 >> 2; // { dg-error {invalid operands of types 'svuint8_t' and 'int' to binary 'operator>>'} }\n+  sve_u1 && 2; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 || 2; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  sve_u1 + uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator\\+'} }\n+  sve_u1 - uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator-'} }\n+  sve_u1 * uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator\\*'} }\n+  sve_u1 / uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator/'} }\n+  sve_u1 % uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator%'} }\n+  sve_u1 & uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator\\&'} }\n+  sve_u1 | uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator\\|'} }\n+  sve_u1 ^ uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator\\^'} }\n+  sve_u1 == uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator=='} }\n+  sve_u1 != uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator!='} }\n+  sve_u1 <= uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator<='} }\n+  sve_u1 < uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator<'} }\n+  sve_u1 > uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator>'} }\n+  sve_u1 >= uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator>='} }\n+  sve_u1 <=> uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator<=>'} }\n+  sve_u1 << uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator<<'} }\n+  sve_u1 >> uc; // { dg-error {invalid operands of types 'svuint8_t' and 'unsigned char' to binary 'operator>>'} }\n+  sve_u1 && uc; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 || uc; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  gnu_u1 + 2;\n+  gnu_u1 - 2;\n+  gnu_u1 * 2;\n+  gnu_u1 / 2;\n+  gnu_u1 % 2;\n+  gnu_u1 & 2;\n+  gnu_u1 | 2;\n+  gnu_u1 ^ 2;\n+  gnu_u1 == 2;\n+  gnu_u1 != 2;\n+  gnu_u1 <= 2;\n+  gnu_u1 < 2;\n+  gnu_u1 > 2;\n+  gnu_u1 >= 2;\n+  gnu_u1 <=> 2; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'int' to binary 'operator<=>'} }\n+  gnu_u1 << 2;\n+  gnu_u1 >> 2;\n+  gnu_u1 && 2;\n+  gnu_u1 || 2;\n+\n+  gnu_u1 + uc;\n+  gnu_u1 - uc;\n+  gnu_u1 * uc;\n+  gnu_u1 / uc;\n+  gnu_u1 % uc;\n+  gnu_u1 & uc;\n+  gnu_u1 | uc;\n+  gnu_u1 ^ uc;\n+  gnu_u1 == uc;\n+  gnu_u1 != uc;\n+  gnu_u1 <= uc;\n+  gnu_u1 < uc;\n+  gnu_u1 > uc;\n+  gnu_u1 >= uc;\n+  gnu_u1 <=> uc; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'unsigned char' to binary 'operator<=>'} }\n+  gnu_u1 << uc;\n+  gnu_u1 >> uc;\n+  gnu_u1 && uc;\n+  gnu_u1 || uc;\n+\n+  // Scalar-vector binary 'operatorarithmetic.\n+\n+  3 + sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator\\+'} }\n+  3 - sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator-'} }\n+  3 * sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator\\*'} }\n+  3 / sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator/'} }\n+  3 % sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator%'} }\n+  3 & sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator\\&'} }\n+  3 | sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator\\|'} }\n+  3 ^ sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator\\^'} }\n+  3 == sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator=='} }\n+  3 != sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator!='} }\n+  3 <= sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator<='} }\n+  3 <=> sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator<=>'} }\n+  3 < sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator<'} }\n+  3 > sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator>'} }\n+  3 >= sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator>='} }\n+  3 << sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator<<'} }\n+  3 >> sve_u1; // { dg-error {invalid operands of types 'int' and 'svuint8_t' to binary 'operator>>'} }\n+  3 && sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  3 || sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  3 + gnu_u1;\n+  3 - gnu_u1;\n+  3 * gnu_u1;\n+  3 / gnu_u1;\n+  3 % gnu_u1;\n+  3 & gnu_u1;\n+  3 | gnu_u1;\n+  3 ^ gnu_u1;\n+  3 == gnu_u1;\n+  3 != gnu_u1;\n+  3 <= gnu_u1;\n+  3 <=> gnu_u1; // { dg-error {invalid operands of types 'int' and 'gnu_uint8_t'[^\\n]* to binary 'operator<=>'} }\n+  3 < gnu_u1;\n+  3 > gnu_u1;\n+  3 >= gnu_u1;\n+  3 << gnu_u1;\n+  3 >> gnu_u1;\n+  3 && gnu_u1;\n+  3 || gnu_u1;\n+\n+  // Mismatched types.\n+\n+  sve_u1 + sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator\\+'} }\n+  sve_u1 - sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator-'} }\n+  sve_u1 * sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator\\*'} }\n+  sve_u1 / sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator/'} }\n+  sve_u1 % sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator%'} }\n+  sve_u1 & sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator\\&'} }\n+  sve_u1 | sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator\\|'} }\n+  sve_u1 ^ sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator\\^'} }\n+  sve_u1 == sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator=='} }\n+  sve_u1 != sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator!='} }\n+  sve_u1 <= sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator<='} }\n+  sve_u1 < sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator<'} }\n+  sve_u1 > sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator>'} }\n+  sve_u1 >= sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator>='} }\n+  sve_u1 <=> sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator<=>'} }\n+  sve_u1 << sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator<<'} }\n+  sve_u1 >> sve_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'svint8_t' to binary 'operator>>'} }\n+\n+  sve_u1 + gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator\\+'} }\n+  sve_u1 - gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator-'} }\n+  sve_u1 * gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator\\*'} }\n+  sve_u1 / gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator/'} }\n+  sve_u1 % gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator%'} }\n+  sve_u1 & gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator\\&'} }\n+  sve_u1 | gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator\\|'} }\n+  sve_u1 ^ gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator\\^'} }\n+  sve_u1 == gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator=='} }\n+  sve_u1 != gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator!='} }\n+  sve_u1 <= gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator<='} }\n+  sve_u1 < gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator<'} }\n+  sve_u1 > gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator>'} }\n+  sve_u1 >= gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator>='} }\n+  sve_u1 <=> gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator<=>'} }\n+  sve_u1 << gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator<<'} }\n+  sve_u1 >> gnu_s1; // { dg-error {invalid operands of types 'svuint8_t' and 'gnu_int8_t'[^\\n]* to binary 'operator>>'} }\n+\n+  gnu_u1 + sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator\\+'} }\n+  gnu_u1 - sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator-'} }\n+  gnu_u1 * sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator\\*'} }\n+  gnu_u1 / sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator/'} }\n+  gnu_u1 % sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator%'} }\n+  gnu_u1 & sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator\\&'} }\n+  gnu_u1 | sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator\\|'} }\n+  gnu_u1 ^ sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator\\^'} }\n+  gnu_u1 == sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator=='} }\n+  gnu_u1 != sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator!='} }\n+  gnu_u1 <= sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator<='} }\n+  gnu_u1 < sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator<'} }\n+  gnu_u1 > sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator>'} }\n+  gnu_u1 >= sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator>='} }\n+  gnu_u1 <=> sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator<=>'} }\n+  gnu_u1 << sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator<<'} }\n+  gnu_u1 >> sve_s1; // { dg-error {invalid operands of types 'gnu_uint8_t'[^\\n]* and 'svint8_t' to binary 'operator>>'} }\n+\n+  gnu_u1 + gnu_s1;\n+  gnu_u1 - gnu_s1;\n+  gnu_u1 * gnu_s1;\n+  gnu_u1 / gnu_s1;\n+  gnu_u1 % gnu_s1;\n+  gnu_u1 & gnu_s1;\n+  gnu_u1 | gnu_s1;\n+  gnu_u1 ^ gnu_s1;\n+  gnu_u1 == gnu_s1;\n+  gnu_u1 != gnu_s1;\n+  gnu_u1 <= gnu_s1;\n+  gnu_u1 < gnu_s1;\n+  gnu_u1 > gnu_s1;\n+  gnu_u1 >= gnu_s1;\n+  // This is a target-independent sorry.  There's no ACLE reason why it\n+  // needs to be kept.\n+  gnu_u1 <=> gnu_s1; // { dg-message {three-way comparison of vectors} }\n+  gnu_u1 << gnu_s1;\n+  gnu_u1 >> gnu_s1;\n+\n+  // Conditional expressions.\n+\n+  uc ? sve_u1 : sve_u1;\n+  uc ? gnu_u1 : sve_u1; // { dg-error {operands to '\\?:' have different types 'gnu_uint8_t'[^\\n]* and 'svuint8_t'} \"\" { xfail *-*-* } }\n+  uc ? sve_u1 : gnu_u1; // { dg-error {operands to '\\?:' have different types 'svuint8_t' and 'gnu_uint8_t'} \"\" { xfail *-*-* } }\n+  uc ? gnu_u1 : gnu_u1;\n+\n+  sve_u1 ? sve_u1 : sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? gnu_u1 : sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? sve_u1 : gnu_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? gnu_u1 : gnu_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? sve_u1 : uc; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? uc : sve_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? gnu_u1 : uc; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+  sve_u1 ? uc : gnu_u1; // { dg-error {could not convert 'sve_u1' from 'svuint8_t' to 'bool'} }\n+\n+  gnu_u1 ? sve_u1 : sve_u1; // { dg-error {incompatible vector types in conditional expression} }\n+  gnu_u1 ? gnu_u1 : sve_u1; // { dg-error {incompatible vector types in conditional expression} }\n+  gnu_u1 ? sve_u1 : gnu_u1; // { dg-error {incompatible vector types in conditional expression} }\n+  gnu_u1 ? gnu_u1 : gnu_u1;\n+  gnu_u1 ? sve_u1 : uc; // { dg-error {incompatible vector types in conditional expression} }\n+  gnu_u1 ? uc : sve_u1; // { dg-error {incompatible vector types in conditional expression} }\n+  gnu_u1 ? gnu_u1 : uc;\n+  gnu_u1 ? uc : gnu_u1;\n+\n+  // Vector built-ins.\n+\n+  __builtin_shuffle (sve_u1, sve_u1, sve_u1); // { dg-error {'__builtin_shuffle' last argument must be an integer vector} }\n+  __builtin_shuffle (sve_u1, gnu_u1, gnu_u1); // { dg-error {'__builtin_shuffle' arguments must be vectors} }\n+  __builtin_shuffle (gnu_u1, sve_u1, gnu_u1); // { dg-error {'__builtin_shuffle' arguments must be vectors} }\n+  __builtin_shuffle (gnu_u1, gnu_u1, sve_u1); // { dg-error {'__builtin_shuffle' last argument must be an integer vector} }\n+  __builtin_shuffle (gnu_u1, gnu_u1, gnu_u1);\n+\n+  __builtin_convertvector (sve_u1, svuint8_t); // { dg-error {'__builtin_convertvector' first argument must be an integer or floating vector} }\n+  __builtin_convertvector (gnu_u1, svuint8_t); // { dg-error {'__builtin_convertvector' second argument must be an integer or floating vector type} }\n+  __builtin_convertvector (sve_u1, gnu_uint8_t); // { dg-error {'__builtin_convertvector' first argument must be an integer or floating vector} }\n+  __builtin_convertvector (gnu_u1, gnu_uint8_t);\n+\n+  // Type queries.\n+\n+  static_assert(__is_literal_type(svuint8_t));\n+  static_assert(__is_literal_type(gnu_uint8_t));\n+\n+  svuint8_t *sve_ptr1 = &sve_u1;\n+  svuint8_t *sve_ptr2 = &gnu_u1;\n+  svuint8_t *sve_ptr3 = &sve_s1; // { dg-error {invalid conversion from 'svint8_t\\*' to 'svuint8_t\\*'} }\n+  svuint8_t *sve_ptr4 = &gnu_s1; // { dg-error {invalid conversion from 'gnu_int8_t\\*'[^\\n]* to 'svuint8_t\\*'} }\n+\n+  gnu_uint8_t *gnu_ptr1 = &sve_u1;\n+  gnu_uint8_t *gnu_ptr2 = &gnu_u1;\n+  gnu_uint8_t *gnu_ptr3 = &sve_s1; // { dg-error {invalid conversion from 'svint8_t\\*' to 'gnu_uint8_t\\*'} }\n+  gnu_uint8_t *gnu_ptr4 = &gnu_s1; // { dg-error {invalid conversion from 'gnu_int8_t\\*'[^\\n]* to 'gnu_uint8_t\\*'} }\n+}\n+\n+constexpr svuint8_t const1 (svuint8_t x) { return x; }\n+constexpr gnu_uint8_t const2 (gnu_uint8_t x) { return x; }"}]}