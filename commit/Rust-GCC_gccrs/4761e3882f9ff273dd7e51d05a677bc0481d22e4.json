{"sha": "4761e3882f9ff273dd7e51d05a677bc0481d22e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc2MWUzODgyZjlmZjI3M2RkN2U1MWQwNWE2NzdiYzA0ODFkMjJlNA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-29T10:01:52Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-29T10:01:52Z"}, "message": "m68k.c (m68k_initial_elimination_offset): Use gcc_assert and gcc_unreachable as appropriate.\n\n\t* config/m68k/m68k.c (m68k_initial_elimination_offset): Use\n\tgcc_assert and gcc_unreachable as appropriate.\n\t(output_dbcc_and_branch, output_scc_di, legitimize_pic_address,\n\tconst_int_cost, output_move_const_into_data_reg,\n\toutput_move_qimode, output_move_double, find_addr_reg,\n\tprint_operand, print_operand_address): Likewise.\n\t* config/m68k/m68k.md (adddi3, subdi3, negsf2, negdf2, abssf2,\n\tabsdf2, sordered, sunordered, suneq, sunge, sungt, sunle, sunlt,\n\tsltgt, bordered, bunordered, buneq, bunge, bungt, bunle, bunlt,\n\tbltgt, *bordered_rev, *bunordered_rev, *buneq_rev, *bunge_rev,\n\t*bunle_rev, *bunlt_rev, *bltgt_rev, negxf2, absxf2,\n\tconditional_trap): Likewise.\n\t* config/m68k/m68kelf.h (ASM_OUTPUT_ALIGN): Remove unreachable code.\n\nFrom-SVN: r98981", "tree": {"sha": "0992b9cd5f3577424710b3288ac59c3cf1d6ab35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0992b9cd5f3577424710b3288ac59c3cf1d6ab35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4761e3882f9ff273dd7e51d05a677bc0481d22e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4761e3882f9ff273dd7e51d05a677bc0481d22e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4761e3882f9ff273dd7e51d05a677bc0481d22e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4761e3882f9ff273dd7e51d05a677bc0481d22e4/comments", "author": null, "committer": null, "parents": [{"sha": "4c1f4f52ed766b2a646a5adf181b7933ae0949d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c1f4f52ed766b2a646a5adf181b7933ae0949d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c1f4f52ed766b2a646a5adf181b7933ae0949d6"}], "stats": {"total": 237, "additions": 103, "deletions": 134}, "files": [{"sha": "46ca9ff2ca5171eddb68c6be8c4488081e55f76b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4761e3882f9ff273dd7e51d05a677bc0481d22e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4761e3882f9ff273dd7e51d05a677bc0481d22e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4761e3882f9ff273dd7e51d05a677bc0481d22e4", "patch": "@@ -1,3 +1,19 @@\n+2005-04-29  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/m68k/m68k.c (m68k_initial_elimination_offset): Use\n+\tgcc_assert and gcc_unreachable as appropriate.\n+\t(output_dbcc_and_branch, output_scc_di, legitimize_pic_address,\n+\tconst_int_cost, output_move_const_into_data_reg,\n+\toutput_move_qimode, output_move_double, find_addr_reg,\n+\tprint_operand, print_operand_address): Likewise.\n+\t* config/m68k/m68k.md (adddi3, subdi3, negsf2, negdf2, abssf2,\n+\tabsdf2, sordered, sunordered, suneq, sunge, sungt, sunle, sunlt,\n+\tsltgt, bordered, bunordered, buneq, bunge, bungt, bunle, bunlt,\n+\tbltgt, *bordered_rev, *bunordered_rev, *buneq_rev, *bunge_rev,\n+\t*bunle_rev, *bunlt_rev, *bltgt_rev, negxf2, absxf2,\n+\tconditional_trap): Likewise.\n+\t* config/m68k/m68kelf.h (ASM_OUTPUT_ALIGN): Remove unreachable code.\n+\n 2005-04-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/xtensa/xtensa.c (gen_int_relational): Use gcc_assert and"}, {"sha": "e456317fb1d7a335052cd166c8121cbe4724e4ad", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 52, "deletions": 66, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4761e3882f9ff273dd7e51d05a677bc0481d22e4/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4761e3882f9ff273dd7e51d05a677bc0481d22e4/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=4761e3882f9ff273dd7e51d05a677bc0481d22e4", "patch": "@@ -442,12 +442,17 @@ m68k_initial_elimination_offset (int from, int to)\n \n   m68k_compute_frame_layout ();\n \n-  if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return current_frame.offset + current_frame.size + (frame_pointer_needed ? -UNITS_PER_WORD * 2 : -UNITS_PER_WORD);\n-  else if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return current_frame.offset + current_frame.size;\n-\n-  abort();\n+  gcc_assert (to == STACK_POINTER_REGNUM);\n+  switch (from)\n+    {\n+      case ARG_POINTER_REGNUM:\n+\treturn current_frame.offset + current_frame.size\n+\t  + (frame_pointer_needed ? -UNITS_PER_WORD * 2 : -UNITS_PER_WORD);\n+    case FRAME_POINTER_REGNUM:\n+      return current_frame.offset + current_frame.size;\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \n /* Refer to the array `regs_ever_live' to determine which registers\n@@ -1147,7 +1152,7 @@ output_dbcc_and_branch (rtx *operands)\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n \n   /* If the decrement is to be done in SImode, then we have\n@@ -1165,12 +1170,12 @@ output_dbcc_and_branch (rtx *operands)\n         break;\n \n       default:\n-        abort ();\n+        gcc_unreachable ();\n     }\n }\n \n const char *\n-output_scc_di(rtx op, rtx operand1, rtx operand2, rtx dest)\n+output_scc_di (rtx op, rtx operand1, rtx operand2, rtx dest)\n {\n   rtx loperands[7];\n   enum rtx_code op_code = GET_CODE (op);\n@@ -1320,7 +1325,7 @@ output_scc_di(rtx op, rtx operand1, rtx operand2, rtx dest)\n         break;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n   return \"\";\n }\n@@ -1413,8 +1418,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n   /* First handle a simple SYMBOL_REF or LABEL_REF */\n   if (GET_CODE (orig) == SYMBOL_REF || GET_CODE (orig) == LABEL_REF)\n     {\n-      if (reg == 0)\n-\tabort ();\n+      gcc_assert (reg);\n \n       pic_ref = gen_rtx_MEM (Pmode,\n \t\t\t     gen_rtx_PLUS (Pmode,\n@@ -1433,17 +1437,14 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n \treturn orig;\n \n-      if (reg == 0)\n-\tabort ();\n+      gcc_assert (reg);\n \n       /* legitimize both operands of the PLUS */\n-      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n-\t{\n-\t  base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n-\t  orig = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n-\t\t\t\t\t base == reg ? 0 : reg);\n-\t}\n-      else abort ();\n+      gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);\n+      \n+      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n+      orig = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n+\t\t\t\t     base == reg ? 0 : reg);\n \n       if (GET_CODE (orig) == CONST_INT)\n \treturn plus_constant (base, INTVAL (orig));\n@@ -1523,7 +1524,7 @@ const_int_cost (rtx constant)\n       case MOVL :\n \treturn 2;\n       default :\n-        abort ();\n+        gcc_unreachable ();\n     }\n }\n \n@@ -1685,7 +1686,7 @@ output_move_const_into_data_reg (rtx *operands)\n     case MOVL :\n \treturn \"move%.l %1,%0\";\n     default :\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n }\n \n@@ -1819,13 +1820,13 @@ output_move_qimode (rtx *operands)\n {\n   /* 68k family always modifies the stack pointer by at least 2, even for\n      byte pushes.  The 5200 (ColdFire) does not do this.  */\n-  if (GET_CODE (operands[0]) == MEM\n-      && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n-      && XEXP (XEXP (operands[0], 0), 0) == stack_pointer_rtx\n-      && ! ADDRESS_REG_P (operands[1])\n-      && ! TARGET_COLDFIRE)\n-    /* generated by pushqi1 pattern now */\n-    abort ();\n+  \n+  /* This case is generated by pushqi1 pattern now */\n+  gcc_assert (!(GET_CODE (operands[0]) == MEM\n+\t\t&& GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n+\t\t&& XEXP (XEXP (operands[0], 0), 0) == stack_pointer_rtx\n+\t\t&& ! ADDRESS_REG_P (operands[1])\n+\t\t&& ! TARGET_COLDFIRE));\n \n   /* clr and st insns on 68000 read before writing.\n      This isn't so on the 68010, but we have no TARGET_68010.  */\n@@ -1947,12 +1948,10 @@ output_move_double (rtx *operands)\n   else\n     optype1 = RNDOP;\n \n-  /* Check for the cases that the operand constraints are not\n-     supposed to allow to happen.  Abort if we get one,\n-     because generating code for these cases is painful.  */\n-\n-  if (optype0 == RNDOP || optype1 == RNDOP)\n-    abort ();\n+  /* Check for the cases that the operand constraints are not supposed\n+     to allow to happen.  Generating code for these cases is\n+     painful.  */\n+  gcc_assert (optype0 != RNDOP && optype1 != RNDOP);\n \n   /* If one operand is decrementing and one is incrementing\n      decrement the former register explicitly\n@@ -2048,15 +2047,11 @@ output_move_double (rtx *operands)\n \t      middlehalf[1] = GEN_INT (l[1]);\n \t      latehalf[1] = GEN_INT (l[2]);\n \t    }\n-\t  else if (CONSTANT_P (operands[1]))\n+\t  else\n \t    {\n-\t      /* actually, no non-CONST_DOUBLE constant should ever\n-\t\t appear here.  */\n-\t      abort ();\n-\t      if (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) < 0)\n-\t\tlatehalf[1] = constm1_rtx;\n-\t      else\n-\t\tlatehalf[1] = const0_rtx;\n+\t      /* No non-CONST_DOUBLE constant should ever appear\n+\t\t here.  */\n+\t      gcc_assert (!CONSTANT_P (operands[1]));\n \t    }\n \t}\n       else\n@@ -2109,7 +2104,7 @@ output_move_double (rtx *operands)\n \t  /* If both halves of dest are used in the src memory address,\n \t     compute the address into latehalf of dest.\n \t     Note that this can't happen if the dest is two data regs.  */\n-compadr:\n+\tcompadr:\n \t  xops[0] = latehalf[0];\n \t  xops[1] = XEXP (operands[1], 0);\n \t  output_asm_insn (\"lea %a1,%0\", xops);\n@@ -2140,8 +2135,7 @@ output_move_double (rtx *operands)\n \t    goto compadr;\n \n \t  /* JRV says this can't happen: */\n-\t  if (addreg0 || addreg1)\n-\t    abort ();\n+\t  gcc_assert (!addreg0 && !addreg1);\n \n \t  /* Only the middle reg conflicts; simply put it last.  */\n \t  output_asm_insn (singlemove_string (operands), operands);\n@@ -2267,11 +2261,10 @@ find_addr_reg (rtx addr)\n       else if (CONSTANT_P (XEXP (addr, 1)))\n \taddr = XEXP (addr, 0);\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n-  if (GET_CODE (addr) == REG)\n-    return addr;\n-  abort ();\n+  gcc_assert (GET_CODE (addr) == REG);\n+  return addr;\n }\n \n /* Output assembler code to perform a 32-bit 3-operand add.  */\n@@ -2667,9 +2660,9 @@ print_operand (FILE *file, rtx op, int letter)\n   else if (letter == 'o')\n     {\n       /* This is only for direct addresses with TARGET_PCREL */\n-      if (GET_CODE (op) != MEM || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n-          || !TARGET_PCREL)\n-\tabort ();\n+      gcc_assert (GET_CODE (op) == MEM\n+\t\t  && GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t\t  && TARGET_PCREL);\n       output_addr_const (file, XEXP (op, 0));\n     }\n   else if (GET_CODE (op) == REG)\n@@ -2856,10 +2849,7 @@ print_operand_address (FILE *file, rtx addr)\n #endif\n \tif (offset != 0)\n \t  {\n-\t    if (addr != 0)\n-\t      {\n-\t\tabort ();\n-\t      }\n+\t    gcc_assert (!addr);\n \t    addr = offset;\n \t  }\n \tif ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\n@@ -2914,14 +2904,10 @@ print_operand_address (FILE *file, rtx addr)\n \tif (ireg != 0 || breg != 0)\n \t  {\n \t    int scale = 1;\n-\t    if (breg == 0)\n-\t      {\n-\t\tabort ();\n-\t      }\n-\t    if (! flag_pic && addr && GET_CODE (addr) == LABEL_REF)\n-\t      {\n-\t\tabort ();\n-\t      }\n+\t    \n+\t    gcc_assert (breg);\n+\t    gcc_assert (flag_pic || !addr || GET_CODE (addr) != LABEL_REF);\n+\t    \n \t    if (MOTOROLA)\n \t      {\n \t\tif (addr != 0)"}, {"sha": "19e0d1b84ef2a014ab2c5fd066848dfe1485119f", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 35, "deletions": 66, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4761e3882f9ff273dd7e51d05a677bc0481d22e4/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4761e3882f9ff273dd7e51d05a677bc0481d22e4/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=4761e3882f9ff273dd7e51d05a677bc0481d22e4", "patch": "@@ -715,7 +715,7 @@\n   \"!TARGET_COLDFIRE\"\n   \"* return output_move_himode (operands);\")\n \n- (define_insn \"\"\n+(define_insn \"\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r<Q>,g,U\")\n \t(match_operand:HI 1 \"general_operand\" \"g,r<Q>,U\"))]\n   \"TARGET_COLDFIRE\"\n@@ -1778,8 +1778,9 @@\n \t  return \"add%.l %1,%R0\\;addx%.l %3,%0\";\n \t}\n     }\n-  else if (GET_CODE (operands[0]) == MEM)\n+  else\n     {\n+      gcc_assert (GET_CODE (operands[0]) == MEM);\n       if (GET_CODE (operands[2]) == MEM\n \t  && GET_CODE (XEXP (operands[2], 0)) == PRE_DEC)\n \treturn \"add%.l %2,%0\\;addx%.l %2,%0\";\n@@ -1801,8 +1802,6 @@\n \t  return \"add%.l %R2,%1\\;move%.l %0,%3\\;addx%.l %2,%3\\;move%.l %3,%0\";\n \t}\n     }\n-  else\n-    abort ();\n })\n \n (define_insn \"addsi_lshrsi_31\"\n@@ -2254,8 +2253,9 @@\n \t  return \"sub%.l %1,%R0\\;subx%.l %3,%0\";\n \t}\n     }\n-  else if (GET_CODE (operands[0]) == MEM)\n+  else\n     {\n+      gcc_assert (GET_CODE (operands[0]) == MEM);\n       if (GET_CODE (operands[2]) == MEM\n \t  && GET_CODE (XEXP (operands[2], 0)) == PRE_DEC)\n \treturn \"sub%.l %2,%0\\;subx%.l %2,%0\";\n@@ -2277,8 +2277,6 @@\n \t  return \"sub%.l %R2,%1\\;move%.l %0,%3\\;subx%.l %2,%3\\;move%.l %3,%0\";\n \t}\n     }\n-  else\n-    abort ();\n })\n \n (define_insn \"subsi3\"\n@@ -3577,8 +3575,7 @@\n       result = expand_binop (SImode, xor_optab,\n \t\t\t     operand_subword_force (operands[1], 0, SFmode),\n \t\t\t     GEN_INT (0x80000000), target, 0, OPTAB_WIDEN);\n-      if (result == 0)\n-\tabort ();\n+      gcc_assert (result);\n \n       if (result != target)\n \temit_move_insn (result, target);\n@@ -3620,8 +3617,7 @@\n       result = expand_binop (SImode, xor_optab,\n \t\t\t     operand_subword_force (operands[1], 0, DFmode),\n \t\t\t     GEN_INT (0x80000000), target, 0, OPTAB_WIDEN);\n-      if (result == 0)\n-\tabort ();\n+      gcc_assert (result);\n \n       if (result != target)\n \temit_move_insn (result, target);\n@@ -3693,8 +3689,7 @@\n       result = expand_binop (SImode, and_optab,\n \t\t\t     operand_subword_force (operands[1], 0, SFmode),\n \t\t\t     GEN_INT (0x7fffffff), target, 0, OPTAB_WIDEN);\n-      if (result == 0)\n-\tabort ();\n+      gcc_assert (result);\n \n       if (result != target)\n \temit_move_insn (result, target);\n@@ -3731,8 +3726,7 @@\n       result = expand_binop (SImode, and_optab,\n \t\t\t     operand_subword_force (operands[1], 0, DFmode),\n \t\t\t     GEN_INT (0x7fffffff), target, 0, OPTAB_WIDEN);\n-      if (result == 0)\n-\tabort ();\n+      gcc_assert (result);\n \n       if (result != target)\n \temit_move_insn (result, target);\n@@ -5165,8 +5159,7 @@\n \t(ordered:QI (cc0) (const_int 0)))]\n   \"TARGET_68881 && !TARGET_68060\"\n {\n-  if (! m68k_last_compare_had_fp_operands)\n-    abort ();\n+  gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n })\n \n@@ -5184,8 +5177,7 @@\n \t(unordered:QI (cc0) (const_int 0)))]\n   \"TARGET_68881 && !TARGET_68060\"\n {\n-  if (! m68k_last_compare_had_fp_operands)\n-    abort ();\n+  gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n })\n \n@@ -5203,8 +5195,7 @@\n \t(uneq:QI (cc0) (const_int 0)))]\n   \"TARGET_68881 && !TARGET_68060\"\n {\n-  if (! m68k_last_compare_had_fp_operands)\n-    abort ();\n+  gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n })\n \n@@ -5222,8 +5213,7 @@\n \t(unge:QI (cc0) (const_int 0)))]\n   \"TARGET_68881 && !TARGET_68060\"\n {\n-  if (! m68k_last_compare_had_fp_operands)\n-    abort ();\n+  gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n })\n \n@@ -5241,8 +5231,7 @@\n \t(ungt:QI (cc0) (const_int 0)))]\n   \"TARGET_68881 && !TARGET_68060\"\n {\n-  if (! m68k_last_compare_had_fp_operands)\n-    abort ();\n+  gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n })\n \n@@ -5260,8 +5249,7 @@\n \t(unle:QI (cc0) (const_int 0)))]\n   \"TARGET_68881 && !TARGET_68060\"\n {\n-  if (! m68k_last_compare_had_fp_operands)\n-    abort ();\n+  gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n })\n \n@@ -5279,8 +5267,7 @@\n \t(unlt:QI (cc0) (const_int 0)))]\n   \"TARGET_68881 && !TARGET_68060\"\n {\n-  if (! m68k_last_compare_had_fp_operands)\n-    abort ();\n+  gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n })\n \n@@ -5298,8 +5285,7 @@\n \t(ltgt:QI (cc0) (const_int 0)))]\n   \"TARGET_68881 && !TARGET_68060\"\n {\n-  if (! m68k_last_compare_had_fp_operands)\n-    abort ();\n+  gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n })\n \n@@ -5689,8 +5675,7 @@\n \t\t      (pc)))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbor %l0\" : \"fjor %l0\";\n })\n \n@@ -5701,8 +5686,7 @@\n \t\t      (pc)))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbun %l0\" : \"fjun %l0\";\n })\n \n@@ -5713,8 +5697,7 @@\n \t\t      (pc)))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbueq %l0\" : \"fjueq %l0\";\n })\n \n@@ -5725,8 +5708,7 @@\n \t\t      (pc)))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbuge %l0\" : \"fjuge %l0\";\n })\n \n@@ -5737,8 +5719,7 @@\n \t\t      (pc)))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbugt %l0\" : \"fjugt %l0\";\n })\n \n@@ -5749,8 +5730,7 @@\n \t\t      (pc)))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbule %l0\" : \"fjule %l0\";\n })\n \n@@ -5761,8 +5741,7 @@\n \t\t      (pc)))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbult %l0\" : \"fjult %l0\";\n })\n \n@@ -5773,8 +5752,7 @@\n \t\t      (pc)))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbogl %l0\" : \"fjogl %l0\";\n })\n \f\n@@ -5915,8 +5893,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbun %l0\" : \"fjun %l0\";\n })\n \n@@ -5927,8 +5904,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbor %l0\" : \"fjor %l0\";\n })\n \n@@ -5939,8 +5915,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbogl %l0\" : \"fjogl %l0\";\n })\n \n@@ -5951,8 +5926,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbolt %l0\" : \"fjolt %l0\";\n })\n \n@@ -5963,8 +5937,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbogt %l0\" : \"fjogt %l0\";\n })\n \n@@ -5975,8 +5948,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fboge %l0\" : \"fjoge %l0\";\n })\n \n@@ -5987,8 +5959,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"TARGET_68881\"\n {\n-  if (!(cc_prev_status.flags & CC_IN_68881))\n-    abort ();\n+  gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return MOTOROLA ? \"fbueq %l0\" : \"fjueq %l0\";\n })\n \f\n@@ -6947,8 +6918,7 @@\n       result = expand_binop (SImode, xor_optab,\n \t\t\t     operand_subword_force (operands[1], 0, XFmode),\n \t\t\t     GEN_INT (0x80000000), target, 0, OPTAB_WIDEN);\n-      if (result == 0)\n-\tabort ();\n+      gcc_assert (result);\n \n       if (result != target)\n \temit_move_insn (result, target);\n@@ -6992,8 +6962,7 @@\n       result = expand_binop (SImode, and_optab,\n \t\t\t     operand_subword_force (operands[1], 0, XFmode),\n \t\t\t     GEN_INT (0x7fffffff), target, 0, OPTAB_WIDEN);\n-      if (result == 0)\n-\tabort ();\n+      gcc_assert (result);\n \n       if (result != target)\n \temit_move_insn (result, target);\n@@ -7106,6 +7075,6 @@\n   case GEU: return \"trapcc\";\n   case LE:  return \"traple\";\n   case LEU: return \"trapls\";\n-  default: abort();\n+  default: gcc_unreachable ();\n   }\n })"}, {"sha": "0fdd59d02ecf2cb2fa9c2bc779c9ac04ffcfb57c", "filename": "gcc/config/m68k/m68kelf.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4761e3882f9ff273dd7e51d05a677bc0481d22e4/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4761e3882f9ff273dd7e51d05a677bc0481d22e4/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kelf.h?ref=4761e3882f9ff273dd7e51d05a677bc0481d22e4", "patch": "@@ -86,8 +86,6 @@ Boston, MA 02111-1307, USA.  */\n do {\t\t\t\t\t\t\t\t\\\n   if ((LOG) > 0)\t\t\t\t\t\t\\\n     fprintf ((FILE), \"%s%u\\n\", ALIGN_ASM_OP, 1 << (LOG));\t\\\n-  else if ((LOG) > 31)\t\t\t\t\t\t\\\n-    abort ();\t\t\t\t\t\t\t\\\n } while (0)\n \n /* Use proper assembler syntax for these macros.  */"}]}