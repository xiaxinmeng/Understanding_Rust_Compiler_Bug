{"sha": "351aa1c1a04f782e11e16efa07a18cdacc71942b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUxYWExYzFhMDRmNzgyZTExZTE2ZWZhMDdhMThjZGFjYzcxOTQyYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-09T13:09:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-09T13:09:59Z"}, "message": "(reload_conflicts): Rewrite to clean up and fix numerous bugs; move to\nlater in file.\n\nFrom-SVN: r7002", "tree": {"sha": "f675ca4236de5c9b1a3b5884cb8c267bc624cd21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f675ca4236de5c9b1a3b5884cb8c267bc624cd21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/351aa1c1a04f782e11e16efa07a18cdacc71942b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/351aa1c1a04f782e11e16efa07a18cdacc71942b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/351aa1c1a04f782e11e16efa07a18cdacc71942b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/351aa1c1a04f782e11e16efa07a18cdacc71942b/comments", "author": null, "committer": null, "parents": [{"sha": "46b1c39385d1b94f3adad6add99786924f3801ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b1c39385d1b94f3adad6add99786924f3801ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46b1c39385d1b94f3adad6add99786924f3801ae"}], "stats": {"total": 156, "additions": 62, "deletions": 94}, "files": [{"sha": "2ff7fd4b9ec11cce133808a00ccc9ba35606f615", "filename": "gcc/reload1.c", "status": "modified", "additions": 62, "deletions": 94, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/351aa1c1a04f782e11e16efa07a18cdacc71942b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/351aa1c1a04f782e11e16efa07a18cdacc71942b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=351aa1c1a04f782e11e16efa07a18cdacc71942b", "patch": "@@ -346,7 +346,6 @@ static int hard_reg_use_compare\t\tPROTO((struct hard_reg_n_uses *,\n \t\t\t\t\t       struct hard_reg_n_uses *));\n static void order_regs_for_reload\tPROTO((void));\n static void reload_as_needed\t\tPROTO((rtx, int));\n-static int reloads_conflict \t\tPROTO((int, int));\n static void forget_old_reloads_1\tPROTO((rtx, rtx));\n static int reload_reg_class_lower\tPROTO((short *, short *));\n static void mark_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n@@ -356,6 +355,7 @@ static void clear_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n static int reload_reg_free_p\t\tPROTO((int, int, enum reload_type));\n static int reload_reg_free_before_p\tPROTO((int, int, enum reload_type));\n static int reload_reg_reaches_end_p\tPROTO((int, int, enum reload_type));\n+static int reloads_conflict \t\tPROTO((int, int));\n static int allocate_reload_reg\t\tPROTO((int, rtx, int, int));\n static void choose_reload_regs\t\tPROTO((rtx, rtx));\n static void merge_assigned_reloads\tPROTO((rtx));\n@@ -4066,99 +4066,6 @@ forget_old_reloads_1 (x, ignored)\n     if (n_reloads == 0 || reg_has_output_reload[regno + nr] == 0)\n       reg_last_reload_reg[regno + nr] = 0;\n }\n-\n-/* 1 if reload1 and reload2 conflict with each other */\n-\n-static int\n-reloads_conflict (reload1, reload2)\n-int reload1, reload2;\n-{\n-  int i;\n-  enum reload_type reload1_type = reload_when_needed[reload1];\n-  enum reload_type reload2_type = reload_when_needed[reload2];\n-  int reload1_opnum = reload_opnum[reload1];\n-  int reload2_opnum = reload_opnum[reload2];\n-\n-  /* RELOAD_OTHER conflicts with everything. */\n-  \n-  if (reload1_type == RELOAD_OTHER \n-      || reload2_type == RELOAD_OTHER)\n-    return 1;\n-\n-  switch (reload1_type)\n-    {\n-    case RELOAD_FOR_OTHER_ADDRESS:\n-      if (reload2_type == RELOAD_FOR_OTHER_ADDRESS)\n-\treturn 1;\n-      break;\n-\n-    case RELOAD_FOR_INPUT:\n-      if (reload2_type == RELOAD_FOR_INSN \n-\t  || reload2_type == RELOAD_FOR_OPERAND_ADDRESS\n-\t  || reload2_type == RELOAD_FOR_INPUT)\n-\treturn 1;\n-\n-      /* RELOAD_FOR_INPUT conflicts with any later\n-\t RELOAD_FOR_INPUT_ADDRESS reloads */\n-      for (i = reload2_opnum + 1; i < n_reloads; i++) \n-\tif (reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS) \n-\t  return 1;\n-      break;\n-\n-    case RELOAD_FOR_INPUT_ADDRESS:\n-      if (reload2_type == RELOAD_FOR_INPUT_ADDRESS \n-\t  && (reload1_opnum == reload2_opnum))\n-\treturn 1;\n-\n-      /* RELOAD_FOR_INPUT_ADDRESS conflicts with any\n-\t earlier RELOAD_FOR_INPUT reloads */\n-      for (i = 0; i < reload2_opnum; i++)\n-\tif (reload_when_needed[i] == RELOAD_FOR_INPUT)\n-\t  return 1;\n-      break;\n-\n-    case RELOAD_FOR_OUTPUT_ADDRESS:\n-      if (reload2_type == RELOAD_FOR_OUTPUT_ADDRESS\n-\t  && (reload1_opnum == reload2_opnum))\n-\treturn 1;\n-\n-      for (i = reload2_opnum; i < n_reloads; i++)\n-\tif (reload_when_needed[i] == RELOAD_FOR_INPUT)\n-\t  return 1;\n-      break;\n-\n-    case RELOAD_FOR_OPERAND_ADDRESS:\n-      if (reload2_type == RELOAD_FOR_INPUT \n-\t  || reload2_type == RELOAD_FOR_INSN\n-\t  || reload2_type == RELOAD_FOR_OPERAND_ADDRESS)\n-\t  return 1;\n-      break;\n-\n-    case RELOAD_FOR_OUTPUT:\n-      if (reload2_type == RELOAD_FOR_INSN \n-\t  || reload2_type == RELOAD_FOR_OUTPUT)\n-\t  return 1;\n-\n-      for (i = 0; i <= reload2_opnum; i++)\n-\tif (reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS)\n-\t  return 1;\n-      break;\n-\n-    case RELOAD_FOR_INSN:\n-      if (reload2_type == RELOAD_FOR_INPUT\n-\t  || reload2_type == RELOAD_FOR_OUTPUT\n-\t  || reload2_type == RELOAD_FOR_INSN\n-\t  || reload2_type == RELOAD_FOR_OPERAND_ADDRESS\n-\t  || reload2_type == RELOAD_FOR_OTHER_ADDRESS)\n-\treturn 1;\n-      break;\n-    }\n-\n-  /* No conflict */\n-  return 0;\n-}\n-\n-\n \f\n /* For each reload, the mode of the reload register.  */\n static enum machine_mode reload_mode[MAX_RELOADS];\n@@ -4661,6 +4568,67 @@ reload_reg_reaches_end_p (regno, opnum, type)\n   abort ();\n }\n \f\n+/* Return 1 if the reloads denoted by R1 and R2 cannot share a register.\n+   Return 0 otherwise.\n+\n+   This function uses the same algorithm as reload_reg_free_p above.  */\n+\n+static int\n+reloads_conflict (r1, r2)\n+     int r1, r2;\n+{\n+  enum reload_type r1_type = reload_when_needed[r1];\n+  enum reload_type r2_type = reload_when_needed[r2];\n+  int r1_opnum = reload_opnum[r1];\n+  int r2_opnum = reload_opnum[r2];\n+\n+  /* RELOAD_OTHER conflicts with everything except\n+     RELOAD_FOR_OTHER_ADDRESS.  */\n+  \n+  if ((r1_type == RELOAD_OTHER && r2_type != RELOAD_FOR_OTHER_ADDRESS)\n+      || (r2_type == RELOAD_OTHER && r1_type != RELOAD_FOR_OTHER_ADDRESS))\n+    return 1;\n+\n+  /* Otherwise, check conflicts differently for each type.  */\n+\n+  switch (r1_type)\n+    {\n+    case RELOAD_FOR_INPUT:\n+      return (r2_type == RELOAD_FOR_INSN \n+\t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS\n+\t      || r2_type == RELOAD_FOR_INPUT\n+\t      || (r2_type == RELOAD_FOR_INPUT_ADDRESS && r2_opnum > r1_opnum));\n+\n+    case RELOAD_FOR_INPUT_ADDRESS:\n+      return ((r2_type == RELOAD_FOR_INPUT_ADDRESS && r1_opnum == r2_opnum)\n+\t      || (r2_type == RELOAD_FOR_INPUT && r2_opnum < r1_opnum));\n+\n+    case RELOAD_FOR_OUTPUT_ADDRESS:\n+      return ((r2_type == RELOAD_FOR_OUTPUT_ADDRESS && r2_opnum == r1_opnum)\n+\t      || (r2_type == RELOAD_FOR_OUTPUT && r2_opnum >= r1_opnum));\n+\n+    case RELOAD_FOR_OPERAND_ADDRESS:\n+      return (r2_type == RELOAD_FOR_INPUT || r2_type == RELOAD_FOR_INSN\n+\t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS);\n+\n+    case RELOAD_FOR_OUTPUT:\n+      return (r2_type == RELOAD_FOR_INSN || r2_type == RELOAD_FOR_OUTPUT\n+\t      || (r2_type == RELOAD_FOR_OPERAND_ADDRESS\n+\t\t  && r2_opnum >= r1_opnum));\n+\n+    case RELOAD_FOR_INSN:\n+      return (r2_type == RELOAD_FOR_INPUT || r2_type == RELOAD_FOR_OUTPUT\n+\t      || r2_type == RELOAD_FOR_INSN\n+\t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS);\n+\n+    case RELOAD_FOR_OTHER_ADDRESS:\n+      return r2_type == RELOAD_FOR_OTHER_ADDRESS;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\f\n /* Vector of reload-numbers showing the order in which the reloads should\n    be processed.  */\n short reload_order[MAX_RELOADS];"}]}