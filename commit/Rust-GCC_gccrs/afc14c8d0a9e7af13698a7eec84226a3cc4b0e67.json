{"sha": "afc14c8d0a9e7af13698a7eec84226a3cc4b0e67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZjMTRjOGQwYTllN2FmMTM2OThhN2VlYzg0MjI2YTNjYzRiMGU2Nw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-10T16:28:31Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-10T16:30:58Z"}, "message": "c++: modularize spelling suggestions\n\nThis augments the spelling suggestion code to understand about visible\nimported modules.  Simply consider each visible binding in the\nbinding_vector, until we find one that has something of interest.\n\n\tgcc/cp/\n\t* name-lookup.c: Include bitmap.h.\n\t(enum binding_slots): New.\n\t(maybe_add_fuzzy_binding): Return bool true if found.\n\t(consider_binding_level): Add module support.\n\t* module.cc (get_import_bitmap): Stub.", "tree": {"sha": "30c63a5c82a77f4bc8b7101920d7f60f576c0624", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30c63a5c82a77f4bc8b7101920d7f60f576c0624"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afc14c8d0a9e7af13698a7eec84226a3cc4b0e67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afc14c8d0a9e7af13698a7eec84226a3cc4b0e67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afc14c8d0a9e7af13698a7eec84226a3cc4b0e67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afc14c8d0a9e7af13698a7eec84226a3cc4b0e67/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b46dd03fe94e2428cbcdbfc4d081d89ed604803a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46dd03fe94e2428cbcdbfc4d081d89ed604803a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b46dd03fe94e2428cbcdbfc4d081d89ed604803a"}], "stats": {"total": 79, "additions": 74, "deletions": 5}, "files": [{"sha": "dc4fa41bbc4a46e493e27e41c56a9de63fceaf33", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc14c8d0a9e7af13698a7eec84226a3cc4b0e67/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc14c8d0a9e7af13698a7eec84226a3cc4b0e67/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=afc14c8d0a9e7af13698a7eec84226a3cc4b0e67", "patch": "@@ -80,6 +80,12 @@ module_name (unsigned, bool)\n   return nullptr;\n }\n \n+bitmap\n+get_import_bitmap ()\n+{\n+  return nullptr;\n+}\n+\n void\n mangle_module (int, bool)\n {"}, {"sha": "c921baa630134e722ab7ea53c5fe64975ea90fa4", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 68, "deletions": 5, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc14c8d0a9e7af13698a7eec84226a3cc4b0e67/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc14c8d0a9e7af13698a7eec84226a3cc4b0e67/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=afc14c8d0a9e7af13698a7eec84226a3cc4b0e67", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/name-hint.h\"\n #include \"c-family/known-headers.h\"\n #include \"c-family/c-spellcheck.h\"\n+#include \"bitmap.h\"\n \n static cxx_binding *cxx_binding_make (tree value, tree type);\n static cp_binding_level *innermost_nonclass_level (void);\n@@ -46,6 +47,18 @@ static name_hint maybe_suggest_missing_std_header (location_t location,\n static name_hint suggest_alternatives_for_1 (location_t location, tree name,\n \t\t\t\t\t     bool suggest_misspellings);\n \n+/* Slots in BINDING_VECTOR.  */\n+enum binding_slots\n+{\n+ BINDING_SLOT_CURRENT,\t/* Slot for current TU.  */\n+ BINDING_SLOT_GLOBAL,\t/* Slot for merged global module. */\n+ BINDING_SLOT_PARTITION, /* Slot for merged partition entities\n+\t\t\t    (optional).  */\n+\n+ /* Number of always-allocated slots.  */\n+ BINDING_SLOTS_FIXED = BINDING_SLOT_GLOBAL + 1\n+};\n+\n /* Create an overload suitable for recording an artificial TYPE_DECL\n    and another decl.  We use this machanism to implement the struct\n    stat hack within a namespace.  It'd be nice to use it everywhere.  */\n@@ -6137,9 +6150,10 @@ maybe_add_fuzzy_decl (auto_vec<tree> &vec, tree decl)\n }\n \n /* Examing the namespace binding BINDING, and add at most one instance\n-   of the name, if it contains a visible entity of interest.  */\n+   of the name, if it contains a visible entity of interest.  Return\n+   true if we added something.  */\n \n-void\n+bool\n maybe_add_fuzzy_binding (auto_vec<tree> &vec, tree binding,\n \t\t\t      lookup_name_fuzzy_kind kind)\n {\n@@ -6151,7 +6165,7 @@ maybe_add_fuzzy_binding (auto_vec<tree> &vec, tree binding,\n \t  && STAT_TYPE (binding))\n \t{\n \t  if (maybe_add_fuzzy_decl (vec, STAT_TYPE (binding)))\n-\t    return;\n+\t    return true;\n \t}\n       else if (!STAT_DECL_HIDDEN_P (binding))\n \tvalue = STAT_DECL (binding);\n@@ -6166,8 +6180,11 @@ maybe_add_fuzzy_binding (auto_vec<tree> &vec, tree binding,\n       if (kind != FUZZY_LOOKUP_TYPENAME\n \t  || TREE_CODE (STRIP_TEMPLATE (value)) == TYPE_DECL)\n \tif (maybe_add_fuzzy_decl (vec, value))\n-\t  return;\n+\t  return true;\n     }\n+\n+  /* Nothing found.  */\n+  return false;\n }\n \n /* Helper function for lookup_name_fuzzy.\n@@ -6233,8 +6250,54 @@ consider_binding_level (tree name, best_match <tree, const char *> &bm,\n \t(DECL_NAMESPACE_BINDINGS (ns)->end ());\n       for (hash_table<named_decl_hash>::iterator iter\n \t     (DECL_NAMESPACE_BINDINGS (ns)->begin ()); iter != end; ++iter)\n-\tmaybe_add_fuzzy_binding (vec, *iter, kind);\n+\t{\n+\t  tree binding = *iter;\n \n+\t  if (TREE_CODE (binding) == BINDING_VECTOR)\n+\t    {\n+\t      bitmap imports = get_import_bitmap ();\n+\t      binding_cluster *cluster = BINDING_VECTOR_CLUSTER_BASE (binding);\n+\n+\t      if (tree bind = cluster->slots[BINDING_SLOT_CURRENT])\n+\t\tif (maybe_add_fuzzy_binding (vec, bind, kind))\n+\t\t  continue;\n+\n+\t      /* Scan the imported bindings.  */\n+\t      unsigned ix = BINDING_VECTOR_NUM_CLUSTERS (binding);\n+\t      if (BINDING_VECTOR_SLOTS_PER_CLUSTER == BINDING_SLOTS_FIXED)\n+\t\t{\n+\t\t  ix--;\n+\t\t  cluster++;\n+\t\t}\n+\n+\t      for (; ix--; cluster++)\n+\t\tfor (unsigned jx = 0; jx != BINDING_VECTOR_SLOTS_PER_CLUSTER;\n+\t\t     jx++)\n+\t\t  {\n+\t\t    /* Are we importing this module?  */\n+\t\t    if (unsigned base = cluster->indices[jx].base)\n+\t\t      if (unsigned span = cluster->indices[jx].span)\n+\t\t\tdo\n+\t\t\t  if (bitmap_bit_p (imports, base))\n+\t\t\t    goto found;\n+\t\t\twhile (++base, --span);\n+\t\t    continue;\n+\n+\t\t  found:;\n+\t\t    /* Is it loaded?  */\n+\t\t    if (cluster->slots[jx].is_lazy ())\n+\t\t      /* Let's not read in everything on the first\n+\t\t\t spello! **/\n+\t\t      continue;\n+\t\t    if (tree bind = cluster->slots[jx])\n+\t\t      if (maybe_add_fuzzy_binding (vec, bind, kind))\n+\t\t\tbreak;\n+\t\t  }\n+\t    }\n+\t  else\n+\t    maybe_add_fuzzy_binding (vec, binding, kind);\n+\t}\n+\t\n       vec.qsort ([] (const void *a_, const void *b_)\n \t\t {\n \t\t   return strcmp (IDENTIFIER_POINTER (*(const tree *)a_),"}]}