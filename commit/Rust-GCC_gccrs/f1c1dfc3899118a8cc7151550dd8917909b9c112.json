{"sha": "f1c1dfc3899118a8cc7151550dd8917909b9c112", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFjMWRmYzM4OTkxMThhOGNjNzE1MTU1MGRkODkxNzkwOWI5YzExMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-09-12T08:39:36Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-09-12T08:39:36Z"}, "message": "Fix hard reg cost calculations in CSE; some minor cleanups\n\nFrom-SVN: r36354", "tree": {"sha": "f237fb1035a9a711c819be217b1535718637090c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f237fb1035a9a711c819be217b1535718637090c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1c1dfc3899118a8cc7151550dd8917909b9c112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c1dfc3899118a8cc7151550dd8917909b9c112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1c1dfc3899118a8cc7151550dd8917909b9c112", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c1dfc3899118a8cc7151550dd8917909b9c112/comments", "author": null, "committer": null, "parents": [{"sha": "a6c8d25340249a8a41661a37467ebf73fc226f20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c8d25340249a8a41661a37467ebf73fc226f20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6c8d25340249a8a41661a37467ebf73fc226f20"}], "stats": {"total": 90, "additions": 68, "deletions": 22}, "files": [{"sha": "48f476b8ac1b1d0ad7347a33b88a3eb439123ed2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c1dfc3899118a8cc7151550dd8917909b9c112/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c1dfc3899118a8cc7151550dd8917909b9c112/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1c1dfc3899118a8cc7151550dd8917909b9c112", "patch": "@@ -1,3 +1,18 @@\n+2000-09-12  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* cse.c (approx_reg_cost): If SMALL_REGISTER_CLASSES, return INT_MAX\n+\tif a reference to non-fixed hardreg is seen.  Otherwise, count hard\n+\tregs with a higher cost.\n+\t(preferrable): Deal with cases where either cost or regcost is\n+\tMAX_COST.\n+\t(cse_insn): Use MAX_COST rather than 10000.  Always initialize\n+\tregcost values.\n+\t(COSTS_N_INSNS): Move definition...\n+\t* rtl.h: ...here.\n+\t(MAX_COST): New macro.\n+\t* loop.c (init_loop): Use COSTS_N_INSNS macro instead of hardcoded\n+\tconstant.\n+\n 2000-09-11  Mark Mitchell  <mark@codesourcery.com>\n \n \t* c-common.h (genrtl_clear_out_block): Remove."}, {"sha": "553ffaec37103e17ed5f596e7673853331a00d34", "filename": "gcc/cse.c", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c1dfc3899118a8cc7151550dd8917909b9c112/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c1dfc3899118a8cc7151550dd8917909b9c112/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f1c1dfc3899118a8cc7151550dd8917909b9c112", "patch": "@@ -730,7 +730,7 @@ approx_reg_cost_1 (xp, data)\n /* Return an estimate of the cost of the registers used in an rtx.\n    This is mostly the number of different REG expressions in the rtx;\n    however for some excecptions like fixed registers we use a cost of\n-   0.  */\n+   0.  If any other hard register reference occurs, return MAX_COST.  */\n \n static int\n approx_reg_cost (x)\n@@ -739,6 +739,7 @@ approx_reg_cost (x)\n   regset_head set;\n   int i;\n   int cost = 0;\n+  int hardregs = 0;\n \n   INIT_REG_SET (&set);\n   for_each_rtx (&x, approx_reg_cost_1, (void *)&set);\n@@ -747,11 +748,16 @@ approx_reg_cost (x)\n     (&set, 0, i,\n      {\n        if (! CHEAP_REGNO (i))\n-\t cost++;\n+\t {\n+\t   if (i < FIRST_PSEUDO_REGISTER)\n+\t     hardregs++;\n+\n+\t   cost += i < FIRST_PSEUDO_REGISTER ? 2 : 1;\n+\t }\n      });\n \n   CLEAR_REG_SET (&set);\n-  return cost;\n+  return hardregs && SMALL_REGISTER_CLASSES ? MAX_COST : cost;\n }\n \n /* Return a negative value if an rtx A, whose costs are given by COST_A\n@@ -762,8 +768,29 @@ static int\n preferrable (cost_a, regcost_a, cost_b, regcost_b)\n      int cost_a, regcost_a, cost_b, regcost_b;\n {\n+  /* First, get rid of a cases involving expressions that are entirely\n+     unwanted.  */\n+  if (cost_a != cost_b)\n+    {\n+      if (cost_a == MAX_COST)\n+\treturn 1;\n+      if (cost_b == MAX_COST)\n+\treturn -1;\n+    }\n+\n+  /* Avoid extending lifetimes of hardregs.  */\n+  if (regcost_a != regcost_b)\n+    {\n+      if (regcost_a == MAX_COST)\n+\treturn 1;\n+      if (regcost_b == MAX_COST)\n+\treturn -1;\n+    }\n+\n+  /* Normal operation costs take precedence.  */\n   if (cost_a != cost_b)\n     return cost_a - cost_b;\n+  /* Only if these are identical consider effects on register pressure.  */\n   if (regcost_a != regcost_b)\n     return regcost_a - regcost_b;\n   return 0;\n@@ -789,12 +816,6 @@ notreg_cost (x)\n \t  : rtx_cost (x, SET) * 2);\n }\n \n-/* Return the right cost to give to an operation\n-   to make the cost of the corresponding register-to-register instruction\n-   N times that of a fast register-to-register instruction.  */\n-\n-#define COSTS_N_INSNS(N) ((N) * 2)\n-\n /* Return an estimate of the cost of computing rtx X.\n    One use is in cse, to decide which expression to keep in the hash table.\n    Another is in rtl generation, to pick the cheapest way to multiply.\n@@ -4881,8 +4902,8 @@ cse_insn (insn, libcall_insn)\n       rtx src_const = 0;\n       rtx src_related = 0;\n       struct table_elt *src_const_elt = 0;\n-      int src_cost = 10000, src_eqv_cost = 10000, src_folded_cost = 10000;\n-      int src_related_cost = 10000, src_elt_cost = 10000;\n+      int src_cost = MAX_COST, src_eqv_cost = MAX_COST, src_folded_cost = MAX_COST;\n+      int src_related_cost = MAX_COST, src_elt_cost = MAX_COST;\n       int src_regcost, src_eqv_regcost, src_folded_regcost;\n       int src_related_regcost, src_elt_regcost;\n       /* Set non-zero if we need to call force_const_mem on with the\n@@ -5291,7 +5312,7 @@ cse_insn (insn, libcall_insn)\n       if (src)\n \t{\n \t  if (rtx_equal_p (src, dest))\n-\t    src_cost = -1;\n+\t    src_cost = src_regcost = -1;\n \t  else\n \t    {\n \t      src_cost = COST (src);\n@@ -5302,7 +5323,7 @@ cse_insn (insn, libcall_insn)\n       if (src_eqv_here)\n \t{\n \t  if (rtx_equal_p (src_eqv_here, dest))\n-\t    src_eqv_cost = -1;\n+\t    src_eqv_cost = src_eqv_regcost = -1;\n \t  else\n \t    {\n \t      src_eqv_cost = COST (src_eqv_here);\n@@ -5313,7 +5334,7 @@ cse_insn (insn, libcall_insn)\n       if (src_folded)\n \t{\n \t  if (rtx_equal_p (src_folded, dest))\n-\t    src_folded_cost = -1;\n+\t    src_folded_cost = src_folded_regcost = -1;\n \t  else\n \t    {\n \t      src_folded_cost = COST (src_folded);\n@@ -5324,7 +5345,7 @@ cse_insn (insn, libcall_insn)\n       if (src_related)\n \t{\n \t  if (rtx_equal_p (src_related, dest))\n-\t    src_related_cost = -1;\n+\t    src_related_cost = src_related_regcost = -1;\n \t  else\n \t    {\n \t      src_related_cost = COST (src_related);\n@@ -5335,7 +5356,7 @@ cse_insn (insn, libcall_insn)\n       /* If this was an indirect jump insn, a known label will really be\n \t cheaper even though it looks more expensive.  */\n       if (dest == pc_rtx && src_const && GET_CODE (src_const) == LABEL_REF)\n-\tsrc_folded = src_const, src_folded_cost = -1;\n+\tsrc_folded = src_const, src_folded_cost = src_folded_regcost -1;\n \n       /* Terminate loop when replacement made.  This must terminate since\n          the current contents will be tested and will always be valid.  */\n@@ -5385,7 +5406,7 @@ cse_insn (insn, libcall_insn)\n \t      && preferrable (src_folded_cost, src_folded_regcost,\n \t\t\t      src_elt_cost, src_elt_regcost) <= 0)\n \t    {\n-\t      trial = src_folded, src_folded_cost = 10000;\n+\t      trial = src_folded, src_folded_cost = MAX_COST;\n \t      if (src_folded_force_flag)\n \t\ttrial = force_const_mem (mode, trial);\n \t    }\n@@ -5395,20 +5416,20 @@ cse_insn (insn, libcall_insn)\n \t\t\t\t   src_related_cost, src_related_regcost) <= 0\n \t\t   && preferrable (src_cost, src_regcost,\n \t\t\t\t   src_elt_cost, src_elt_regcost) <= 0)\n-\t    trial = src, src_cost = 10000;\n+\t    trial = src, src_cost = MAX_COST;\n \t  else if (preferrable (src_eqv_cost, src_eqv_regcost,\n \t\t\t\tsrc_related_cost, src_related_regcost) <= 0\n \t\t   && preferrable (src_eqv_cost, src_eqv_regcost,\n \t\t\t\t   src_elt_cost, src_elt_regcost) <= 0)\n-\t    trial = copy_rtx (src_eqv_here), src_eqv_cost = 10000;\n+\t    trial = copy_rtx (src_eqv_here), src_eqv_cost = MAX_COST;\n \t  else if (preferrable (src_related_cost, src_related_regcost,\n \t\t\t\tsrc_elt_cost, src_elt_regcost) <= 0)\n-  \t    trial = copy_rtx (src_related), src_related_cost = 10000;\n+  \t    trial = copy_rtx (src_related), src_related_cost = MAX_COST;\n \t  else\n \t    {\n \t      trial = copy_rtx (elt->exp);\n \t      elt = elt->next_same_value;\n-\t      src_elt_cost = 10000;\n+\t      src_elt_cost = MAX_COST;\n \t    }\n \n \t  /* We don't normally have an insn matching (set (pc) (pc)), so"}, {"sha": "7d172e9147a0f511c7ea52d4331e6c0789a210d1", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c1dfc3899118a8cc7151550dd8917909b9c112/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c1dfc3899118a8cc7151550dd8917909b9c112/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=f1c1dfc3899118a8cc7151550dd8917909b9c112", "patch": "@@ -300,7 +300,7 @@ init_loop ()\n \n   reg_address_cost = address_cost (reg, SImode);\n \n-  copy_cost = 2;\n+  copy_cost = COSTS_N_INSNS (1);\n \n   /* Free the objects we just allocated.  */\n   obfree (free_point);"}, {"sha": "37acbd5ed819f931601cd18e3ff839f108b439c3", "filename": "gcc/rtl.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c1dfc3899118a8cc7151550dd8917909b9c112/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c1dfc3899118a8cc7151550dd8917909b9c112/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f1c1dfc3899118a8cc7151550dd8917909b9c112", "patch": "@@ -1633,6 +1633,16 @@ extern void push_obstacks\t\tPARAMS ((struct obstack *,\n \t\t\t\t\t\tstruct obstack *));\n /* In cse.c */\n struct cse_basic_block_data;\n+\n+/* Return the right cost to give to an operation\n+   to make the cost of the corresponding register-to-register instruction\n+   N times that of a fast register-to-register instruction.  */\n+#define COSTS_N_INSNS(N) ((N) * 4)\n+\n+/* Maximum cost of a rtl expression.  This value has the special meaning\n+   not to use an rtx with this cost under any circumstances.  */\n+#define MAX_COST INT_MAX\n+\n extern int rtx_cost\t\t\tPARAMS ((rtx, enum rtx_code));\n extern int address_cost\t\t\tPARAMS ((rtx, enum machine_mode));\n extern void delete_trivially_dead_insns\tPARAMS ((rtx, int));"}]}